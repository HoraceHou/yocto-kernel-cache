From c5ba7adddea861c62abaa37f1aae9abaaf761b88 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Thu, 12 Sep 2019 06:45:54 +0530
Subject: [PATCH 11/11] coresight: Fix assumptions on coresight topology

commit 923c488e675803a3aa6982a1105e46a4a1780341 from
git@git.assembla.com:cavium/WindRiver.linux.git

Remove the assumption that there is common sink
for all the trace sources.
Note: This is fixed only for the sysfs interface.

Change-Id: Iefc073a2410d211b5e6b743f5bea404dbd9ea995
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/16637
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../hwtracing/coresight/coresight-etm-perf.c  |  2 +-
 drivers/hwtracing/coresight/coresight-priv.h  |  3 ++-
 drivers/hwtracing/coresight/coresight.c       | 25 +++++++++++++++++--
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/drivers/hwtracing/coresight/coresight-etm-perf.c b/drivers/hwtracing/coresight/coresight-etm-perf.c
index 0f5e03e4df22..5ddb305a9f0e 100644
--- a/drivers/hwtracing/coresight/coresight-etm-perf.c
+++ b/drivers/hwtracing/coresight/coresight-etm-perf.c
@@ -205,7 +205,7 @@ static void *etm_setup_aux(struct perf_event *event, void **pages,
 	 * while from perf, the perf tools will do it based on the choice made
 	 * on the cmd line.  As such the "enable_sink" flag in sysFS is reset.
 	 */
-	sink = coresight_get_enabled_sink(true);
+	sink = coresight_get_enabled_sink(NULL, true);
 	if (!sink)
 		goto err;
 
diff --git a/drivers/hwtracing/coresight/coresight-priv.h b/drivers/hwtracing/coresight/coresight-priv.h
index 0e5a74dae6a6..f80a02945305 100644
--- a/drivers/hwtracing/coresight/coresight-priv.h
+++ b/drivers/hwtracing/coresight/coresight-priv.h
@@ -131,7 +131,8 @@ static inline void coresight_write_reg_pair(void __iomem *addr, u64 val,
 void coresight_disable_path(struct list_head *path);
 int coresight_enable_path(struct list_head *path, u32 mode);
 struct coresight_device *coresight_get_sink(struct list_head *path);
-struct coresight_device *coresight_get_enabled_sink(bool reset);
+struct coresight_device *coresight_get_enabled_sink(struct coresight_device *cs,
+						    bool reset);
 struct list_head *coresight_build_path(struct coresight_device *csdev,
 				       struct coresight_device *sink);
 void coresight_release_path(struct list_head *path);
diff --git a/drivers/hwtracing/coresight/coresight.c b/drivers/hwtracing/coresight/coresight.c
index b673718952f6..6c4d1360ce18 100644
--- a/drivers/hwtracing/coresight/coresight.c
+++ b/drivers/hwtracing/coresight/coresight.c
@@ -406,6 +406,7 @@ static int coresight_enabled_sink(struct device *dev, void *data)
 
 /**
  * coresight_get_enabled_sink - returns the first enabled sink found on the bus
+ * In case the child port is a single source ETR, returns the child port as sink
  * @deactivate:	Whether the 'enable_sink' flag should be reset
  *
  * When operated from perf the deactivate parameter should be set to 'true'.
@@ -416,10 +417,30 @@ static int coresight_enabled_sink(struct device *dev, void *data)
  * parameter should be set to 'false', hence mandating users to explicitly
  * clear the flag.
  */
-struct coresight_device *coresight_get_enabled_sink(bool deactivate)
+struct coresight_device *coresight_get_enabled_sink(struct coresight_device *s,
+						    bool deactivate)
 {
+	struct coresight_device *child;
 	struct device *dev = NULL;
 
+	if (s == NULL)
+		goto skip_single_source;
+
+	/* If the connected port is an ETR with single trace source,
+	 * nothing to search further.
+	 */
+	child = s->conns[0].child_dev;
+	if (s->nr_outport == 1 &&
+	    child->type == CORESIGHT_DEV_TYPE_SINK &&
+	    child->subtype.sink_subtype == CORESIGHT_DEV_SUBTYPE_SINK_BUFFER &&
+	    child->nr_inport == 1 &&
+	    child->activated) {
+		if (deactivate)
+			child->activated = false;
+		return child;
+	}
+
+skip_single_source:
 	dev = bus_find_device(&coresight_bustype, NULL, &deactivate,
 			      coresight_enabled_sink);
 
@@ -587,7 +608,7 @@ int coresight_enable(struct coresight_device *csdev)
 	 * Search for a valid sink for this session but don't reset the
 	 * "enable_sink" flag in sysFS.  Users get to do that explicitly.
 	 */
-	sink = coresight_get_enabled_sink(false);
+	sink = coresight_get_enabled_sink(csdev, false);
 	if (!sink) {
 		ret = -EINVAL;
 		goto out;
-- 
2.17.1


From 97c92dacf8e831b9e93bbd208943f71cc0cf1b13 Mon Sep 17 00:00:00 2001
From: Richard Gong <richard.gong@intel.com>
Date: Tue, 19 Jun 2018 11:01:53 -0500
Subject: [PATCH 4/5] FogBugz #566902: driver: misc: change SVC to use
 kthread_create_on_node API

commit 47ba7e3279787d0183a10d97a5f791eec21e8872 from
https://github.com/altera-opensource/linux-socfpga.git

Service layer creates a kthread to handle SMC/HVC calls between kernel
driver and secure monitor software, and stops the kthread once service is
completed.

Change service layer to use kthread_create_on_node() API for a kthread
creation so we can prevent kernel from crash with FPGA configuration.

Signed-off-by: Richard Gong <richard.gong@intel.com>
Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
---
 drivers/misc/intel-service.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/drivers/misc/intel-service.c b/drivers/misc/intel-service.c
index c9a939d..5b31f95 100644
--- a/drivers/misc/intel-service.c
+++ b/drivers/misc/intel-service.c
@@ -258,6 +258,7 @@ int intel_svc_send(struct intel_svc_chan *chan, void *msg)
 	struct intel_svc_data_mem *p_mem;
 	struct intel_svc_data *p_data;
 	int ret = 0;
+	unsigned int cpu = 0;
 
 	p_data = kmalloc(sizeof(*p_data), GFP_KERNEL);
 	if (!p_data)
@@ -266,8 +267,9 @@ int intel_svc_send(struct intel_svc_chan *chan, void *msg)
 	/* first client will create kernel thread */
 	if (!chan->ctrl->task) {
 		chan->ctrl->task =
-			kthread_create_on_cpu(svc_normal_to_secure_thread,
-					      (void *)chan->ctrl, 0,
+			kthread_create_on_node(svc_normal_to_secure_thread,
+					      (void *)chan->ctrl,
+					      cpu_to_node(cpu),
 					      "svc_smc_hvc_thread");
 			if (IS_ERR(chan->ctrl->task)) {
 				dev_err(chan->ctrl->dev,
@@ -275,6 +277,7 @@ int intel_svc_send(struct intel_svc_chan *chan, void *msg)
 				kfree(p_data);
 				return -EINVAL;
 			}
+			kthread_bind(chan->ctrl->task, cpu);
 			wake_up_process(chan->ctrl->task);
 	}
 
@@ -748,15 +751,17 @@ static int svc_get_sh_memory_param(struct platform_device *pdev,
 {
 	struct device *dev = &pdev->dev;
 	struct task_struct *sh_memory_task;
+	unsigned int cpu = 0;
 
 	init_completion(&param->sync_complete);
 
 	/* smc/hvc call happens on cpu 0 bound kthread */
-	sh_memory_task = kthread_create_on_cpu(svc_normal_to_secure_shm_thread,
-					       (void *)param,
-						0, "svc_smc_hvc_shm_thread");
+	sh_memory_task = kthread_create_on_node(svc_normal_to_secure_shm_thread,
+					       (void *)param, cpu_to_node(cpu),
+					       "svc_smc_hvc_shm_thread");
 	if (IS_ERR(sh_memory_task))
 		dev_err(dev, "fail to create intel_svc_smc_shm_thread\n");
+	kthread_bind(sh_memory_task, cpu);
 	wake_up_process(sh_memory_task);
 
 	if (!wait_for_completion_timeout(&param->sync_complete, 10 * HZ)) {
-- 
1.7.9.5


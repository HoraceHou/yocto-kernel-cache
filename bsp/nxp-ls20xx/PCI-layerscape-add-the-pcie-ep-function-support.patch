From 62ad48676e34b2ff2193ba5b49d84147542a4ffc Mon Sep 17 00:00:00 2001
From: Bao Xiaowei <xiaowei.bao@nxp.com>
Date: Wed, 31 Jan 2018 17:19:55 +0800
Subject: [PATCH 404/767] PCI: layerscape: add the pcie ep function support

Add the pcie controller ep function support of layerscape base on
pcie ep framework.

[recomposed the title]

Signed-off-by: Bao Xiaowei <xiaowei.bao@nxp.com>
Signed-off-by: Hou Zhiqiang <Zhiqiang.Hou@nxp.com>
[Xulin: Original patch taken from NXP LSDK-18.09.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/pci/controller/dwc/pci-layerscape.c | 120 ++++++++++++++++++--
 1 file changed, 113 insertions(+), 7 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-layerscape.c b/drivers/pci/controller/dwc/pci-layerscape.c
index 3724d3ef7008..4d2760b77804 100644
--- a/drivers/pci/controller/dwc/pci-layerscape.c
+++ b/drivers/pci/controller/dwc/pci-layerscape.c
@@ -33,7 +33,12 @@
 #define PCIE_ABSERR		0x8d0 /* Bridge Slave Error Response Register */
 #define PCIE_ABSERR_SETTING	0x9401 /* Forward error of non-posted request */
 
+#define PCIE_DBI2_BASE		0x1000	/* DBI2 base address*/
+#define PCIE_MSI_MSG_DATA_OFF	0x5c	/* MSI Data register address*/
+#define PCIE_MSI_OB_SIZE	4096
+#define PCIE_MSI_ADDR_OFFSET	(1024 * 1024)
 #define PCIE_IATU_NUM		6
+#define PCIE_EP_ADDR_SPACE_SIZE 0x100000000
 
 struct ls_pcie_drvdata {
 	u32 lut_offset;
@@ -43,12 +48,20 @@ struct ls_pcie_drvdata {
 	const struct dw_pcie_ops *dw_pcie_ops;
 };
 
+struct ls_pcie_ep {
+	dma_addr_t msi_phys_addr;
+	void __iomem *msi_virt_addr;
+	u64 msi_msg_addr;
+	u16 msi_msg_data;
+};
+
 struct ls_pcie {
 	struct dw_pcie *pci;
 	void __iomem *lut;
 	struct regmap *scfg;
 	const struct ls_pcie_drvdata *drvdata;
 	int index;
+	struct ls_pcie_ep *pcie_ep;
 };
 
 #define to_ls_pcie(x)	dev_get_drvdata((x)->dev)
@@ -271,6 +284,99 @@ static const struct of_device_id ls_pcie_of_match[] = {
 	{ },
 };
 
+static void ls_pcie_raise_msi_irq(struct ls_pcie_ep *pcie_ep)
+{
+	iowrite32(pcie_ep->msi_msg_data, pcie_ep->msi_virt_addr);
+}
+
+static int ls_pcie_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
+		enum pci_epc_irq_type type, u8 interrupt_num)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	struct ls_pcie *pcie = to_ls_pcie(pci);
+	struct ls_pcie_ep *pcie_ep = pcie->pcie_ep;
+	u32 free_win;
+
+	/* get the msi message address and msi message data */
+	pcie_ep->msi_msg_addr = ioread32(pci->dbi_base + MSI_MESSAGE_ADDR_L32) |
+		(((u64)ioread32(pci->dbi_base + MSI_MESSAGE_ADDR_U32)) << 32);
+	pcie_ep->msi_msg_data = ioread16(pci->dbi_base + PCIE_MSI_MSG_DATA_OFF);
+
+	/* request and config the outband window for msi */
+	free_win = find_first_zero_bit(ep->ob_window_map,
+					sizeof(ep->ob_window_map));
+	if (free_win >= ep->num_ob_windows) {
+		dev_err(pci->dev, "no free outbound window\n");
+		return -ENOMEM;
+	}
+
+	dw_pcie_prog_outbound_atu(pci, free_win, PCIE_ATU_TYPE_MEM,
+					pcie_ep->msi_phys_addr,
+					pcie_ep->msi_msg_addr,
+					PCIE_MSI_OB_SIZE);
+
+	set_bit(free_win, ep->ob_window_map);
+
+	/* generate the msi interrupt */
+	ls_pcie_raise_msi_irq(pcie_ep);
+
+	/* release the outband window of msi */
+	dw_pcie_disable_atu(pci, free_win, DW_PCIE_REGION_OUTBOUND);
+	clear_bit(free_win, ep->ob_window_map);
+
+	return 0;
+}
+
+static struct dw_pcie_ep_ops pcie_ep_ops = {
+	.raise_irq = ls_pcie_raise_irq,
+};
+
+static int __init ls_add_pcie_ep(struct ls_pcie *pcie,
+					struct platform_device *pdev)
+{
+	struct dw_pcie *pci = pcie->pci;
+	struct device *dev = pci->dev;
+	struct dw_pcie_ep *ep;
+	struct ls_pcie_ep *pcie_ep;
+	struct resource *cfg_res;
+	int ret;
+
+	ep = &pci->ep;
+	ep->ops = &pcie_ep_ops;
+
+	pcie_ep = devm_kzalloc(dev, sizeof(*pcie_ep), GFP_KERNEL);
+	if (!pcie_ep)
+		return -ENOMEM;
+
+	pcie->pcie_ep = pcie_ep;
+
+	cfg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");
+	if (cfg_res) {
+		ep->phys_base = cfg_res->start;
+		ep->addr_size = PCIE_EP_ADDR_SPACE_SIZE;
+	} else {
+		dev_err(dev, "missing *config* space\n");
+		return -ENODEV;
+	}
+
+	pcie_ep->msi_phys_addr = ep->phys_base + PCIE_MSI_ADDR_OFFSET;
+
+	pcie_ep->msi_virt_addr = ioremap(pcie_ep->msi_phys_addr,
+						PCIE_MSI_OB_SIZE);
+	if (!pcie_ep->msi_virt_addr) {
+		dev_err(dev, "failed to map MSI outbound region\n");
+		return -ENOMEM;
+	}
+
+	ret = dw_pcie_ep_init(ep);
+	if (ret) {
+		dev_err(dev, "failed to initialize endpoint\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 static int __init ls_add_pcie_port(struct ls_pcie *pcie)
 {
 	struct dw_pcie *pci = pcie->pci;
@@ -317,18 +423,18 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 	if (IS_ERR(pci->dbi_base))
 		return PTR_ERR(pci->dbi_base);
 
-	pcie->lut = pci->dbi_base + pcie->drvdata->lut_offset;
+	pci->dbi_base2 = pci->dbi_base + PCIE_DBI2_BASE;
 
-	if (!ls_pcie_is_bridge(pcie))
-		return -ENODEV;
+	pcie->lut = pci->dbi_base + pcie->drvdata->lut_offset;
 
 	platform_set_drvdata(pdev, pcie);
 
-	ret = ls_add_pcie_port(pcie);
-	if (ret < 0)
-		return ret;
+	if (!ls_pcie_is_bridge(pcie))
+		ret = ls_add_pcie_ep(pcie, pdev);
+	else
+		ret = ls_add_pcie_port(pcie);
 
-	return 0;
+	return ret;
 }
 
 static struct platform_driver ls_pcie_driver = {
-- 
2.17.0


From cb699240e09ff163690bb617f70c644fd3104ec2 Mon Sep 17 00:00:00 2001
From: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Date: Tue, 2 Dec 2014 10:29:36 +0530
Subject: [PATCH 293/767] usb: pm: Fix sleep/deep-sleep issue for external ULPI
 phy

External ULPI phy registers are not to be restored
during normal sleep when phy power is not cut-off.
In addition, phy saving/restoration needs to happen only
during deep-sleep

Signed-off-by: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Signed-off-by: yinbo.zhu <yinbo.zhu@nxp.com>
[Xulin: Original patch taken from NXP LSDK-18.09.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/usb/host/ehci-fsl.c | 34 +++++++++++++++++++++++-----------
 1 file changed, 23 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 1328418b9ddb..9821644441c1 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -357,12 +357,12 @@ static int ehci_fsl_setup_phy(struct usb_hcd *hcd,
 		portsc |= PORT_PTS_PTW;
 		/* fall through */
 	case FSL_USB2_PHY_UTMI:
+	case FSL_USB2_PHY_UTMI_DUAL:
 		if (pdata->has_fsl_erratum_a006918) {
 			pr_warn("fsl-ehci: USB PHY clock invalid\n");
 			return -EINVAL;
 		}
 
-	case FSL_USB2_PHY_UTMI_DUAL:
 		/* PHY_CLK_VALID bit is de-featured from all controller
 		 * versions below 2.4 and is to be checked only for
 		 * internal UTMI phy
@@ -541,15 +541,21 @@ static int ehci_fsl_save_context(struct usb_hcd *hcd)
 	struct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
+	struct device *dev = hcd->self.controller;
+	struct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);
 
-	phy_reg = ioremap(FSL_USB_PHY_ADDR, sizeof(struct ccsr_usb_phy));
-	_memcpy_fromio((void *)&ehci_fsl->saved_phy_regs, phy_reg,
+	if (pdata->phy_mode == FSL_USB2_PHY_UTMI_DUAL) {
+	phy_reg = ioremap(FSL_USB_PHY_ADDR,
 			sizeof(struct ccsr_usb_phy));
+	_memcpy_fromio((void *)&ehci_fsl->saved_phy_regs, phy_reg,
+	sizeof(struct ccsr_usb_phy));
+	}
+
 	_memcpy_fromio((void *)&ehci_fsl->saved_regs, ehci->regs,
-			sizeof(struct ehci_regs));
-	ehci_fsl->usb_ctrl = in_be32(non_ehci + FSL_SOC_USB_CTRL);
-	return 0;
+					sizeof(struct ehci_regs));
+	ehci_fsl->usb_ctrl = ioread32be(non_ehci + FSL_SOC_USB_CTRL);
 
+	return 0;
 }
 
 /*Restore usb registers */
@@ -558,10 +564,15 @@ static int ehci_fsl_restore_context(struct usb_hcd *hcd)
 	struct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
+	struct device *dev = hcd->self.controller;
+	struct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);
 
-	if (phy_reg)
-		_memcpy_toio(phy_reg, (void *)&ehci_fsl->saved_phy_regs,
+	if (pdata->phy_mode == FSL_USB2_PHY_UTMI_DUAL) {
+		if (phy_reg)
+			_memcpy_toio(phy_reg,
+				(void *)&ehci_fsl->saved_phy_regs,
 				sizeof(struct ccsr_usb_phy));
+	}
 
 	_memcpy_toio(ehci->regs, (void *)&ehci_fsl->saved_regs,
 				sizeof(struct ehci_regs));
@@ -744,11 +755,11 @@ static int ehci_fsl_drv_suspend(struct device *dev)
 	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),
 			device_may_wakeup(dev));
 
-	ehci_fsl_save_context(hcd);
-
 	if (!fsl_deep_sleep())
 		return 0;
 
+	ehci_fsl_save_context(hcd);
+
 	ehci_fsl->usb_ctrl = ioread32be(non_ehci + FSL_SOC_USB_CTRL);
 	return 0;
 }
@@ -760,7 +771,8 @@ static int ehci_fsl_drv_resume(struct device *dev)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
 
-	ehci_fsl_restore_context(hcd);
+	if (fsl_deep_sleep())
+		ehci_fsl_restore_context(hcd);
 
 #if defined(CONFIG_FSL_USB2_OTG) || defined(CONFIG_FSL_USB2_OTG_MODULE)
 	struct usb_bus host = hcd->self;
-- 
2.17.0


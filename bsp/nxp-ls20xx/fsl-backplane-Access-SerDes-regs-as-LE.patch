From eb9837957ac6a994ad586d3d96ad76b5e30ee406 Mon Sep 17 00:00:00 2001
From: costi <constantin.tudor@freescale.com>
Date: Tue, 30 May 2017 14:37:21 +0300
Subject: [PATCH 223/767] fsl-backplane: Access SerDes regs as LE

Signed-off-by: costi <constantin.tudor@freescale.com>
[Xulin: Original patch taken from NXP LSDK-18.09.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/phy/fsl_backplane.c | 46 ++++++++++++++++-----------------
 1 file changed, 23 insertions(+), 23 deletions(-)

diff --git a/drivers/net/phy/fsl_backplane.c b/drivers/net/phy/fsl_backplane.c
index acc970cee027..ba73d4219a78 100644
--- a/drivers/net/phy/fsl_backplane.c
+++ b/drivers/net/phy/fsl_backplane.c
@@ -242,13 +242,13 @@ void tune_tecr0(struct fsl_xgkr_inst *inst)
 		inst->ratio_pst1q << POST_COE_SHIFT;
 
 	/* reset the lane */
-	iowrite32be(ioread32be(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
-	iowrite32be(val, &reg_base->tecr0);
+	iowrite32(val, &reg_base->tecr0);
 	udelay(1);
 	/* unreset the lane */
-	iowrite32be(ioread32be(&reg_base->gcr0) | GCR0_RESET_MASK,
+	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 }
@@ -267,10 +267,10 @@ static void reset_gcr0(struct fsl_xgkr_inst *inst)
 {
 	struct per_lane_ctrl_status *reg_base = inst->reg_base;
 
-	iowrite32be(ioread32be(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
-	iowrite32be(ioread32be(&reg_base->gcr0) | GCR0_RESET_MASK,
+	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 }
@@ -281,25 +281,25 @@ void lane_set_1gkx(void *reg)
 	u32 val;
 
 	/* reset the lane */
-	iowrite32be(ioread32be(&reg_base->gcr0) & ~GCR0_RESET_MASK,
+	iowrite32(ioread32(&reg_base->gcr0) & ~GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 
 	/* set gcr1 for 1GKX */
-	val = ioread32be(&reg_base->gcr1);
+	val = ioread32(&reg_base->gcr1);
 	val &= ~(GCR1_REIDL_TH_MASK | GCR1_REIDL_EX_SEL_MASK |
 		 GCR1_REIDL_ET_MAS_MASK);
-	iowrite32be(val, &reg_base->gcr1);
+	iowrite32(val, &reg_base->gcr1);
 	udelay(1);
 
 	/* set tecr0 for 1GKX */
-	val = ioread32be(&reg_base->tecr0);
+	val = ioread32(&reg_base->tecr0);
 	val &= ~TECR0_AMP_RED_MASK;
-	iowrite32be(val, &reg_base->tecr0);
+	iowrite32(val, &reg_base->tecr0);
 	udelay(1);
 
 	/* unreset the lane */
-	iowrite32be(ioread32be(&reg_base->gcr0) | GCR0_RESET_MASK,
+	iowrite32(ioread32(&reg_base->gcr0) | GCR0_RESET_MASK,
 		    &reg_base->gcr0);
 	udelay(1);
 }
@@ -388,7 +388,7 @@ static int get_median_gaink2(u32 *reg)
 	for (i = 0; i < BIN_SNAPSHOT_NUM; i++) {
 		/* wait RECR1_CTL_SNP_DONE_MASK has cleared */
 		timeout = 100;
-		while (ioread32be(&reg_base->recr1) &
+		while (ioread32(&reg_base->recr1) &
 		       RECR1_CTL_SNP_DONE_MASK) {
 			udelay(1);
 			timeout--;
@@ -397,13 +397,13 @@ static int get_median_gaink2(u32 *reg)
 		}
 
 		/* start snap shot */
-		iowrite32be((ioread32be(&reg_base->gcr1) |
+		iowrite32((ioread32(&reg_base->gcr1) |
 			    GCR1_CTL_SNP_START_MASK),
 			    &reg_base->gcr1);
 
 		/* wait for SNP done */
 		timeout = 100;
-		while (!(ioread32be(&reg_base->recr1) &
+		while (!(ioread32(&reg_base->recr1) &
 		       RECR1_CTL_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
@@ -412,12 +412,12 @@ static int get_median_gaink2(u32 *reg)
 		}
 
 		/* read and save the snap shot */
-		rx_eq_snp = ioread32be(&reg_base->recr1);
+		rx_eq_snp = ioread32(&reg_base->recr1);
 		gaink2_snap_shot[i] = (rx_eq_snp & RECR1_GAINK2_MASK) >>
 					RECR1_GAINK2_SHIFT;
 
 		/* terminate the snap shot by setting GCR1[REQ_CTL_SNP] */
-		iowrite32be((ioread32be(&reg_base->gcr1) &
+		iowrite32((ioread32(&reg_base->gcr1) &
 			    ~GCR1_CTL_SNP_START_MASK),
 			    &reg_base->gcr1);
 	}
@@ -452,7 +452,7 @@ static bool is_bin_early(int bin_sel, void *reg)
 	for (i = 0; i < BIN_SNAPSHOT_NUM; i++) {
 		/* wait RECR1_SNP_DONE_MASK has cleared */
 		timeout = 100;
-		while ((ioread32be(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
+		while ((ioread32(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
 			if (timeout == 0)
@@ -461,22 +461,22 @@ static bool is_bin_early(int bin_sel, void *reg)
 
 		/* set TCSR1[CDR_SEL] to BinM1/BinLong */
 		if (bin_sel == BIN_M1) {
-			iowrite32be((ioread32be(&reg_base->tcsr1) &
+			iowrite32((ioread32(&reg_base->tcsr1) &
 				    ~CDR_SEL_MASK) | BIN_M1_SEL,
 				    &reg_base->tcsr1);
 		} else {
-			iowrite32be((ioread32be(&reg_base->tcsr1) &
+			iowrite32((ioread32(&reg_base->tcsr1) &
 				    ~CDR_SEL_MASK) | BIN_Long_SEL,
 				    &reg_base->tcsr1);
 		}
 
 		/* start snap shot */
-		iowrite32be(ioread32be(&reg_base->gcr1) | GCR1_SNP_START_MASK,
+		iowrite32(ioread32(&reg_base->gcr1) | GCR1_SNP_START_MASK,
 			    &reg_base->gcr1);
 
 		/* wait for SNP done */
 		timeout = 100;
-		while (!(ioread32be(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
+		while (!(ioread32(&reg_base->recr1) & RECR1_SNP_DONE_MASK)) {
 			udelay(1);
 			timeout--;
 			if (timeout == 0)
@@ -484,13 +484,13 @@ static bool is_bin_early(int bin_sel, void *reg)
 		}
 
 		/* read and save the snap shot */
-		bin_snap_shot[i] = (ioread32be(&reg_base->tcsr1) &
+		bin_snap_shot[i] = (ioread32(&reg_base->tcsr1) &
 				TCSR1_SNP_DATA_MASK) >> TCSR1_SNP_DATA_SHIFT;
 		if (bin_snap_shot[i] & TCSR1_EQ_SNPBIN_SIGN_MASK)
 			negative_count++;
 
 		/* terminate the snap shot by setting GCR1[REQ_CTL_SNP] */
-		iowrite32be(ioread32be(&reg_base->gcr1) & ~GCR1_SNP_START_MASK,
+		iowrite32(ioread32(&reg_base->gcr1) & ~GCR1_SNP_START_MASK,
 			    &reg_base->gcr1);
 	}
 
-- 
2.17.0


From fe0ddfcf5812771ee348519e4ab43069db6cc153 Mon Sep 17 00:00:00 2001
From: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Date: Wed, 26 Nov 2014 22:59:05 +0530
Subject: [PATCH 292/767] usb: fsl: Fix deep-sleep resume issue caused by usb

usb ip driver needs to save and restore all registers including
phy registers across deep-sleep. This is required since latest
changes in u-boot code doesn't re-init usb phy anymore during
deep-sleep resume

Signed-off-by: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Signed-off-by: Suresh Gupta <suresh.gupta@freescale.com>
Signed-off-by: Nikhil Badola <nikhil.badola@freescale.com>
Signed-off-by: yinbo.zhu <yinbo.zhu@nxp.com>
[Xulin: Original patch taken from NXP LSDK-18.09.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/usb/host/ehci-fsl.c | 62 ++++++++++++++++++++++++++++---------
 1 file changed, 48 insertions(+), 14 deletions(-)

diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 269492a43ad0..1328418b9ddb 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -27,6 +27,39 @@
 #include "ehci.h"
 #include "ehci-fsl.h"
 
+#define FSL_USB_PHY_ADDR       0xffe214000
+
+struct ccsr_usb_port_ctrl {
+	u32     ctrl;
+	u32     drvvbuscfg;
+	u32     pwrfltcfg;
+	u32     sts;
+	u8      res_14[0xc];
+	u32     bistcfg;
+	u32     biststs;
+	u32     abistcfg;
+	u32     abiststs;
+	u8      res_30[0x10];
+	u32     xcvrprg;
+	u32     anaprg;
+	u32     anadrv;
+	u32     anasts;
+};
+
+struct ccsr_usb_phy {
+	u32     id;
+	struct ccsr_usb_port_ctrl port1;
+	u8      res_50[0xc];
+	u32     tvr;
+	u32     pllprg[4];
+	u8      res_70[0x4];
+	u32     anaccfg;
+	u32     dbg;
+	u8      res_7c[0x4];
+	struct ccsr_usb_port_ctrl port2;
+	u8      res_dc[0x334];
+};
+
 #define DRIVER_DESC "Freescale EHCI Host controller driver"
 #define DRV_NAME "ehci-fsl"
 
@@ -499,9 +532,9 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 }
 
 
-
-
 #ifdef CONFIG_PM
+void __iomem *phy_reg;
+
 /* save usb registers */
 static int ehci_fsl_save_context(struct usb_hcd *hcd)
 {
@@ -509,11 +542,11 @@ static int ehci_fsl_save_context(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
 
-	ehci_fsl->saved_regs = kzalloc(sizeof(struct ehci_regs), GFP_KERNEL);
-	if (!ehci_fsl->saved_regs)
-		return -ENOMEM;
-	_memcpy_fromio(ehci_fsl->saved_regs, ehci->regs,
-					sizeof(struct ehci_regs));
+	phy_reg = ioremap(FSL_USB_PHY_ADDR, sizeof(struct ccsr_usb_phy));
+	_memcpy_fromio((void *)&ehci_fsl->saved_phy_regs, phy_reg,
+			sizeof(struct ccsr_usb_phy));
+	_memcpy_fromio((void *)&ehci_fsl->saved_regs, ehci->regs,
+			sizeof(struct ehci_regs));
 	ehci_fsl->usb_ctrl = in_be32(non_ehci + FSL_SOC_USB_CTRL);
 	return 0;
 
@@ -526,13 +559,14 @@ static int ehci_fsl_restore_context(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd->regs;
 
-	if (ehci_fsl->saved_regs) {
-		_memcpy_toio(ehci->regs, ehci_fsl->saved_regs,
-						sizeof(struct ehci_regs));
-		out_be32(non_ehci + FSL_SOC_USB_CTRL, ehci_fsl->usb_ctrl);
-		kfree(ehci_fsl->saved_regs);
-		ehci_fsl->saved_regs = NULL;
-	}
+	if (phy_reg)
+		_memcpy_toio(phy_reg, (void *)&ehci_fsl->saved_phy_regs,
+				sizeof(struct ccsr_usb_phy));
+
+	_memcpy_toio(ehci->regs, (void *)&ehci_fsl->saved_regs,
+				sizeof(struct ehci_regs));
+	iowrite32be(ehci_fsl->usb_ctrl, non_ehci + FSL_SOC_USB_CTRL);
+
 	return 0;
 }
 
-- 
2.17.0


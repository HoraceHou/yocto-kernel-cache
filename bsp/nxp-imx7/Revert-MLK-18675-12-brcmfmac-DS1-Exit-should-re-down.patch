From a070e2629c730a3981ed25e8bba220cef7735f16 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 6 Jun 2019 16:12:20 +0800
Subject: [PATCH 8/8] Revert"MLK-18675-12 brcmfmac: DS1 Exit should re download
 the firmware"

Revert commit 6e81b3d809bd3636221c034293bb6c6ac40a76cc
("MLK-18675-12 brcmfmac: DS1 Exit should re download the firmware").

Since this patch is dropped by imx-sdk, and it break driver building.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../broadcom/brcm80211/brcmfmac/core.c        |  17 +-
 .../broadcom/brcm80211/brcmfmac/sdio.c        | 156 +-----------------
 2 files changed, 5 insertions(+), 168 deletions(-)

diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
index 94b2d0225df5..a6a96f651520 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
@@ -1098,9 +1098,6 @@ int brcmf_attach(struct device *dev, struct brcmf_mp_device *settings)
 	struct wiphy *wiphy;
 	struct cfg80211_ops *ops;
 	struct brcmf_pub *drvr = NULL;
-	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
-	struct brcmf_sdio_dev *sdiod = bus_if->bus_priv.sdio;
-	struct brcmf_sdio *bus = sdiod->bus;
 	int ret = 0;
 	int i;
 
@@ -1143,16 +1140,10 @@ int brcmf_attach(struct device *dev, struct brcmf_mp_device *settings)
 	/* attach firmware event handler */
 	brcmf_fweh_attach(drvr);
 
-	/* Waking up from deep sleep don't requirerd to reint the sdio bus
-	 * as all sdiod core registers will get restored by Firmware using
-	 * FCBS engine.
-	 */
-	if (!bus->sdiodev->ulp) {
-		ret = brcmf_bus_started(dev);
-		if (ret != 0) {
-			brcmf_err("dongle is not responding\n");
-			goto fail;
-		}
+	ret = brcmf_bus_started(drvr, ops);
+	if (ret != 0) {
+		brcmf_err("dongle is not responding: err=%d\n", ret);
+		goto fail;
 	}
 
 	drvr->config->ops = ops;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
index 98ae3820ffbd..5ce8b48322b8 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
@@ -45,7 +45,6 @@
 #include "core.h"
 #include "common.h"
 #include "bcdc.h"
-#include "fwil.h"
 
 #define DCMD_RESP_TIMEOUT	msecs_to_jiffies(2500)
 #define CTL_DONE_TIMEOUT	msecs_to_jiffies(2500)
@@ -327,10 +326,6 @@ struct rte_console {
 #define MAX_KSO_ATTEMPTS (PMU_MAX_TRANSITION_DLY/KSO_WAIT_US)
 #define BRCMF_SDIO_MAX_ACCESS_ERRORS	5
 
-static void brcmf_sdio_firmware_callback(struct device *dev, int err,
-					 const struct firmware *code,
-					 void *nvram, u32 nvram_len);
-
 #ifdef DEBUG
 /* Device console log buffer state */
 struct brcmf_console {
@@ -2537,149 +2532,6 @@ static int brcmf_sdio_intr_rstatus(struct brcmf_sdio *bus)
 	return ret;
 }
 
-/* This Function is used to retrieve important
- * details from dongle related to ULP mode Mostly
- * values/SHM details that will be vary depending
- * on the firmware branches
- */
-static void
-brcmf_sdio_ulp_preinit(struct device *dev)
-{
-	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
-	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
-	struct brcmf_if *ifp = bus_if->drvr->iflist[0];
-	s32 err = 0;
-
-	brcmf_dbg(TRACE, "Enter\n");
-
-	/* Query ulp_sdioctrl iovar to get the ULP related SHM offsets */
-	err = brcmf_fil_iovar_data_get(ifp, "ulp_sdioctrl", &sdiodev->shm_ulp,
-				       sizeof(sdiodev->shm_ulp));
-	if (err)
-		brcmf_err("ulp_sdioctrl iovar returned err = %d\n", err);
-
-	sdiodev->ulp = false;
-
-	brcmf_dbg(TRACE, "m_ulp_ctrl_sdio[%x] m_ulp_wakeevt_ind [%x]\n",
-		  M_DS1_CTRL_SDIO(sdiodev->shm_ulp),
-		  M_WAKEEVENT_IND(sdiodev->shm_ulp));
-	brcmf_dbg(TRACE, "m_ulp_wakeind [%x]\n",
-		  M_ULP_WAKE_IND(sdiodev->shm_ulp));
-}
-
-/* Reinitialize ARM because In DS1 mode ARM got off */
-static int
-brcmf_sdio_ulp_reinit_fw(struct brcmf_sdio *bus)
-{
-	struct brcmf_sdio_dev *sdiodev = bus->sdiodev;
-	int err = 0;
-
-	/* After firmware redownload tx/rx seq are reset accordingly
-	 * these values are reset on FMAC side tx_max is initially set to 4,
-	 * which later is updated by FW.
-	 */
-	bus->tx_seq = 0;
-	bus->rx_seq = 0;
-	bus->tx_max = 4;
-
-	err = brcmf_fw_get_firmwares(sdiodev->dev, BRCMF_FW_REQUEST_NVRAM,
-				     sdiodev->fw_name, sdiodev->nvram_name,
-				     brcmf_sdio_firmware_callback);
-	if (err != 0)
-		brcmf_err("async firmware request failed: %d\n", err);
-	return err;
-}
-
-/* Check if device is in DS1 mode and handshake with ULP UCODE */
-static bool
-brcmf_sdio_ulp_pre_redownload_check(struct brcmf_sdio *bus)
-{
-	int err = 0;
-	u32 value = 0;
-	u32 val32, ulp_wake_ind, wowl_wake_ind;
-	int reg_addr;
-	unsigned long timeout;
-
-	value = brcmf_sdiod_readb(bus->sdiodev, SDIO_CCCR_IOEx, &err);
-
-	if (value == SDIO_FUNC_ENABLE_1) {
-		brcmf_dbg(SDIO, "GOT THE INTERRUPT FROM UCODE\n");
-		bus->sdiodev->ulp = true;
-		ulp_wake_ind = D11SHM_RD(bus->sdiodev, M_ULP_WAKE_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-		wowl_wake_ind = D11SHM_RD(bus->sdiodev, M_WAKEEVENT_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-
-		brcmf_dbg(SDIO, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x\n",
-			  wowl_wake_ind, ulp_wake_ind);
-
-		if (wowl_wake_ind || ulp_wake_ind) {
-			/* TX wake Don't do anything.
-			 * Just bail out and re-download firmware.
-			 */
-		} else {
-			/* RX wake negotiate with MAC */
-			brcmf_dbg(SDIO, "M_DS1_CTRL_SDIO: 0x%08x\n",
-				  (u32)D11SHM_RD(bus->sdiodev,
-				  M_DS1_CTRL_SDIO(bus->sdiodev->shm_ulp),
-				  &err));
-			D11SHM_WR(bus->sdiodev, M_DS1_CTRL_SDIO(
-				  bus->sdiodev->shm_ulp),
-				  C_DS1_CTRL_SDIO_DS1_EXIT |
-				  C_DS1_CTRL_REQ_VALID,
-				  &err);
-			val32 = D11REG_RD(bus->sdiodev,
-					  D11_MACCONTROL_REG, &err);
-			val32 = val32 | D11_MACCONTROL_REG_WAKE;
-			D11REG_WR(bus->sdiodev,
-				  D11_MACCONTROL_REG, val32, &err);
-
-			/* Poll for PROC_DONE to be set by ucode */
-			value = D11SHM_RD(bus->sdiodev,
-					  M_DS1_CTRL_SDIO(
-					  bus->sdiodev->shm_ulp), &err);
-			/* Wait here (polling) for C_DS1_CTRL_PROC_DONE */
-			timeout = jiffies + ULP_HUDI_PROC_DONE_TIME;
-			while (!(value & C_DS1_CTRL_PROC_DONE)) {
-				value = D11SHM_RD(bus->sdiodev,
-						  M_DS1_CTRL_SDIO(
-						  bus->sdiodev->shm_ulp), &err);
-				if (time_after(jiffies, timeout))
-					break;
-				usleep_range(1000, 2000);
-			}
-			brcmf_dbg(SDIO, "M_DS1_CTRL_SDIO: 0x%08x\n",
-				  (u32)D11SHM_RD(bus->sdiodev,
-				  M_DS1_CTRL_SDIO(
-				  bus->sdiodev->shm_ulp), &err));
-			value = D11SHM_RD(bus->sdiodev,
-					  M_DS1_CTRL_SDIO(
-					  bus->sdiodev->shm_ulp), &err);
-			if (!(value & C_DS1_CTRL_PROC_DONE)) {
-				brcmf_err("%s: timeout Failed to enter DS1 Exit state!\n",
-					  __func__);
-				return false;
-			}
-		}
-		ulp_wake_ind = D11SHM_RD(bus->sdiodev, M_ULP_WAKE_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-		wowl_wake_ind = D11SHM_RD(bus->sdiodev, M_WAKEEVENT_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-		brcmf_dbg(SDIO, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x\n",
-			  wowl_wake_ind, ulp_wake_ind);
-		reg_addr = CORE_CC_REG(
-			  brcmf_chip_get_pmu(bus->ci)->base, min_res_mask);
-		brcmf_sdiod_writel(bus->sdiodev, reg_addr,
-				  DEFAULT_43012_MIN_RES_MASK, &err);
-		if (err)
-			brcmf_err("min_res_mask failed\n");
-
-		return true;
-	}
-
-	return false;
-}
-
 static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 {
 	struct brcmf_sdio_dev *sdiod = bus->sdiodev;
@@ -2753,8 +2605,6 @@ static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 	if (intstatus & I_HMB_HOST_INT) {
 		intstatus &= ~I_HMB_HOST_INT;
 		intstatus |= brcmf_sdio_hostmail(bus);
-		if (brcmf_sdio_ulp_pre_redownload_check(bus))
-			brcmf_sdio_ulp_reinit_fw(bus);
 	}
 
 	sdio_release_host(bus->sdiodev->func1);
@@ -3642,10 +3492,6 @@ static int brcmf_sdio_bus_preinit(struct device *dev)
 	if (err < 0)
 		goto done;
 
-	/* initialize SHM address from firmware for DS1 */
-	if (!bus->sdiodev->ulp)
-		brcmf_sdio_ulp_preinit(dev);
-
 	bus->tx_hdrlen = SDPCM_HWHDR_LEN + SDPCM_SWHDR_LEN;
 	if (sdiodev->sg_support) {
 		bus->txglom = false;
@@ -4328,7 +4174,7 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 			brcmf_sdiod_writeb(sdiod,
 					  SBSDIO_WATERMARK,
 					  CY_43012_F2_WATERMARK, &err);
-			devctl = brcmf_sdiod_regrb(sdiod,
+			devctl = brcmf_sdiod_readb(sdiod,
 						   SBSDIO_DEVICE_CTL, &err);
 			devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
 			brcmf_sdiod_writeb(sdiod,
-- 
2.17.1


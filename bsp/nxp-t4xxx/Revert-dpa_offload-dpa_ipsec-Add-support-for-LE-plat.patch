From f62b684e44de87334aa1222654f9abecb7eca882 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Wed, 11 Jul 2018 16:33:05 +0800
Subject: [PATCH 1/2] Revert "dpa_offload/dpa_ipsec: Add support for LE
 platforms"

This reverts commit 11270f1efa3b868997f07fa995392390b633e05e.

Since this kernel only supports BE to avoid build issues due to
missing others LE patches.

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c      |   43 +++++++---------
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |   58 +++++++++++-----------
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |   28 ++++++++++-
 3 files changed, 73 insertions(+), 56 deletions(-)
 mode change 100644 => 100755 drivers/staging/fsl_dpa_offload/dpa_ipsec.c

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
old mode 100644
new mode 100755
index 7b3f11f..1592573
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1572,7 +1572,7 @@ static int create_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd, int *hmd)
 	} else {
 		offld_params->u.ipsec.variableIpVersion = true;
 		offld_params->u.ipsec.outerIPHdrLen = (uint8_t)
-				caam16_to_cpu(sa->sec_desc->pdb_en.ip_hdr_len);
+						sa->sec_desc->pdb_en.ip_hdr_len;
 	}
 	offld_params->u.ipsec.ecnCopy = sa->ecn_copy;
 	offld_params->u.ipsec.dscpCopy = sa->dscp_copy;
@@ -1656,7 +1656,7 @@ static int update_ipsec_manip(struct dpa_ipsec_sa *sa, int next_hmd, int *hmd)
 	} else {
 		offld_params->u.ipsec.variableIpVersion = true;
 		offld_params->u.ipsec.outerIPHdrLen = (uint8_t)
-				caam16_to_cpu(sa->sec_desc->pdb_en.ip_hdr_len);
+						sa->sec_desc->pdb_en.ip_hdr_len;
 	}
 	offld_params->u.ipsec.ecnCopy = sa->ecn_copy;
 	offld_params->u.ipsec.dscpCopy = sa->dscp_copy;
@@ -2139,8 +2139,8 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 			offset += IP_PROTO_FIELD_LEN;
 		}
 
-		*(uint32_t *)(key + offset) = cpu_to_be32(sa->spi);
-		offset += sizeof(sa->spi);
+		memcpy(key + offset, (uint8_t *) &sa->spi, ESP_SPI_FIELD_LEN);
+		offset += ESP_SPI_FIELD_LEN;
 
 		/* determine padding length based on the table params */
 		err = dpa_classif_table_get_params(table, &tbl_params);
@@ -2436,14 +2436,14 @@ static int create_sec_frame_queue(uint32_t fq_id, uint16_t channel,
 		}
 #if (DPAA_VERSION == 10)
 		/* FMAN v2 devices: opcode and flow id are stored in contextB */
-		fq_opts.fqd.context_a.hi |= FM_CONTEXTA_OVERRIDE_MASK;
+		FM_CONTEXTA_SET_OVERRIDE(&fq_opts.fqd.context_a, true);
 		FM_CONTEXTB_SET_FQID(&(fq_opts.fqd.context_b), ctxB |
 					(sp_op_code << 20));
 #elif (DPAA_VERSION == 11)
 		/* FMAN v3 devices: opcode and flow id are stored in contextA */
-		fq_opts.fqd.context_a.hi &= ~FM_CONTEXTA_A1_MASK;
-		fq_opts.fqd.context_a.hi |= (ctxB << 4) | sp_op_code;
-		fq_opts.fqd.context_a.hi |= FM_CONTEXTA_A1_VALID_MASK;
+		FM_CONTEXTA_SET_A1_VALID(&fq_opts.fqd.context_a, true);
+		FM_CONTEXTA_SET_A1(&fq_opts.fqd.context_a,
+				((ctxB << 4) | sp_op_code));
 #endif
 	}
 
@@ -2610,7 +2610,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	memcpy(sa->cipher_data.cipher_key,
 	       sa_params->crypto_params.cipher_key,
 	       sa_params->crypto_params.cipher_key_len);
-	sa->sec_desc->pdb_en.spi = cpu_to_caam32(sa_params->spi);
+	sa->sec_desc->pdb_en.spi = sa_params->spi;
 	sa->sec_desc->pdb_en.options &= 0xffffff00;
 	sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_TUNNEL |
 				       PDBOPTS_ESP_INCIPHDR |
@@ -2639,11 +2639,11 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 
 	if (sa_params->use_ext_seq_num) {
 		sa->sec_desc->pdb_en.seq_num_ext_hi =
-			cpu_to_caam32((sa_params->start_seq_num & SEQ_NUM_HI_MASK) >> 32);
+			(sa_params->start_seq_num & SEQ_NUM_HI_MASK) >> 32;
 		sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_ESN;
 	}
 	sa->sec_desc->pdb_en.seq_num =
-		cpu_to_caam32(sa_params->start_seq_num & SEQ_NUM_LOW_MASK);
+				sa_params->start_seq_num & SEQ_NUM_LOW_MASK;
 
 	if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv6)
 		sa->sec_desc->pdb_en.options |= PDBOPTS_ESP_IPV6;
@@ -2698,9 +2698,6 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 		sa->sec_desc->pdb_en.ip_hdr_len =
 				sa_params->sa_out_params.ip_hdr_size;
 	}
-	/* Update endianness of this value to match SEC endianness: */
-	sa->sec_desc->pdb_en.ip_hdr_len =
-				cpu_to_caam16(sa->sec_desc->pdb_en.ip_hdr_len);
 
 	if (ip_addr_type == DPA_IPSEC_ADDR_T_IPv4) {
 		outer_ip_hdr = (struct iphdr *) &sa->sec_desc->pdb_en.ip_hdr[0];
@@ -2803,7 +2800,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	}
 
 	sa->sec_desc->pdb_dec.seq_num =
-		cpu_to_caam32(sa_params->start_seq_num & SEQ_NUM_LOW_MASK);
+			sa_params->start_seq_num & SEQ_NUM_LOW_MASK;
 	sa->sec_desc->pdb_dec.options &= 0xffffff00;
 	sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_TUNNEL |
 					PDBOPTS_ESP_OUTFMT;
@@ -2813,7 +2810,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 
 	if (sa_params->use_ext_seq_num) {
 		sa->sec_desc->pdb_dec.seq_num_ext_hi =
-			cpu_to_caam32((sa_params->start_seq_num & SEQ_NUM_HI_MASK) >> 32);
+			(sa_params->start_seq_num & SEQ_NUM_HI_MASK) >> 32;
 		sa->sec_desc->pdb_dec.options |= PDBOPTS_ESP_ESN;
 	}
 
@@ -2868,8 +2865,6 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 		sa->ecn_copy =
 			sa_params->hdr_upd_flags & DPA_IPSEC_HDR_COPY_ECN;
 	}
-	sa->sec_desc->pdb_dec.hmo_ip_hdr_len =
-			cpu_to_caam16(sa->sec_desc->pdb_dec.hmo_ip_hdr_len);
 
 	/* Only for outbound */
 	sa->enable_dpovrd = false;
@@ -5348,15 +5343,11 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 
 	desc = (uint32_t *)sa->sec_desc->desc;
 	if (!sa->sec_desc_extended) {
-		sa_stats->packets_count =
-				be32_to_cpu(*(desc + sa->stats_offset / 4));
-		sa_stats->bytes_count =
-				be32_to_cpu(*(desc + sa->stats_offset / 4 + 1));
+		sa_stats->packets_count = *(desc + sa->stats_offset / 4);
+		sa_stats->bytes_count = *(desc + sa->stats_offset / 4 + 1);
 	} else {
-		sa_stats->bytes_count =
-				be32_to_cpu(*(desc + sa->stats_offset / 4));
-		sa_stats->packets_count =
-				be32_to_cpu(*(desc + sa->stats_offset / 4 + 1));
+		sa_stats->bytes_count = *(desc + sa->stats_offset / 4);
+		sa_stats->packets_count = *(desc + sa->stats_offset / 4 + 1);
 	}
 
 	if (!sa->enable_extended_stats)
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 0d72f02..0fac5ae 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -71,7 +71,7 @@ int get_sec_info(struct dpa_ipsec *dpa_ipsec)
 	if (sec_node) {
 		sec_era = of_get_property(sec_node, "fsl,sec-era", &prop_size);
 		if (sec_era && prop_size == sizeof(*sec_era) && *sec_era > 0)
-			dpa_ipsec->sec_era = be32_to_cpu(*sec_era);
+			dpa_ipsec->sec_era = *sec_era;
 		of_node_put(sec_node);
 	}
 
@@ -317,12 +317,24 @@ static inline void save_stats_in_external_mem(struct dpa_ipsec_sa *sa)
 	append_jump(desc, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
 }
 
+/* insert a cmd in the desc at a given index and optionally update desc len */
+static void insert_sec_cmd(uint32_t *desc, uint32_t index, uint32_t cmd,
+			  bool update_len)
+{
+	uint32_t *desc_cmd;
+
+	desc_cmd = desc + index;
+	*desc_cmd = cmd;
+
+	if (update_len)
+		(*desc)++;
+}
+
 /* insert cmds for SEQ_IN/OUT_PTR copy with specified offset (shr_desc_len) */
 static void insert_ptr_copy_cmds(uint32_t *desc, uint32_t index,
 				 uint32_t shr_desc_len, bool update_desc_len)
 {
-	uint32_t move_cmd, off, len;
-	uint32_t *tmp;
+	uint32_t cmd, off, len;
 
 	/*
 	 * insert the commands at the specified index
@@ -331,7 +343,6 @@ static void insert_ptr_copy_cmds(uint32_t *desc, uint32_t index,
 	if (!index)
 		index = desc_len(desc);
 
-	tmp = desc + index;
 	/*
 	 * move out ptr (from job desc) to math reg 1 & 2, except the last byte;
 	 * assuming all buffers are 256 bits aligned, setting the last address
@@ -340,11 +351,8 @@ static void insert_ptr_copy_cmds(uint32_t *desc, uint32_t index,
 	off = CAAM_PTR_SZ;
 	off = (shr_desc_len * CAAM_CMD_SZ + off) << MOVE_OFFSET_SHIFT;
 	len = CAAM_CMD_SZ + JOB_DESC_HDR_LEN + ALIGNED_PTR_ADDRESS_SZ;
-	move_cmd = CMD_MOVE | MOVE_SRC_DESCBUF | MOVE_DEST_MATH1 | off | len;
-	if (update_desc_len)
-		append_cmd(desc, move_cmd);
-	else
-		tmp = write_cmd(tmp, move_cmd);
+	cmd = CMD_MOVE | MOVE_SRC_DESCBUF | MOVE_DEST_MATH1 | off | len;
+	insert_sec_cmd(desc, index, cmd, update_desc_len);
 
 	/*
 	 * move in ptr (from job desc) to math reg 0, except the last byte;
@@ -354,11 +362,8 @@ static void insert_ptr_copy_cmds(uint32_t *desc, uint32_t index,
 	off = JOB_DESC_HDR_LEN + 3 * CAAM_CMD_SZ + 2 * CAAM_PTR_SZ;
 	off = (shr_desc_len * CAAM_CMD_SZ + off) << MOVE_OFFSET_SHIFT;
 	len = ALIGNED_PTR_ADDRESS_SZ;
-	move_cmd = CMD_MOVE | MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | off | len;
-	if (update_desc_len)
-		append_cmd(desc, move_cmd);
-	else
-		tmp = write_cmd(tmp, move_cmd);
+	cmd = CMD_MOVE | MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | off | len;
+	insert_sec_cmd(desc, ++index, cmd, update_desc_len);
 }
 
 /* build the command set for copying the frame meta data */
@@ -499,8 +504,7 @@ int build_shared_descriptor(struct dpa_ipsec_sa *sa,
 	if (sa->sa_dir == DPA_IPSEC_OUTBOUND) {
 		/* Compute optional header size, rounded up to descriptor
 		 * word size */
-		opthdrsz = (caam16_to_cpu(sa->sec_desc->pdb_en.ip_hdr_len) +
-				3) & ~3;
+		opthdrsz = (sa->sec_desc->pdb_en.ip_hdr_len + 3) & ~3;
 		pdb_len += sizeof(struct ipsec_encap_pdb) + opthdrsz;
 		init_sh_desc_pdb(desc, HDR_SAVECTX | HDR_SHARE_SERIAL, pdb_len);
 	} else {
@@ -1353,7 +1357,7 @@ int build_extended_decap_shared_descriptor(struct dpa_ipsec_sa *sa,
 
 	/* data = outer IP header - should be read from DPOVRD register
 	 * MATH 2 = outer IP header length */
-	data = cpu_to_caam32(20);
+	data = 20;
 	opt = LDST_CLASS_DECO | LDST_SRCDST_WORD_DECO_MATH2;
 	len = sizeof(data) << LDST_LEN_SHIFT;
 	append_load_as_imm(desc, &data, len, opt);
@@ -1452,17 +1456,13 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa)
 done_shared_desc:
 	sec_desc = sa->sec_desc;
 	/* setup preheader */
-	PREHEADER_PREP_IDLEN(sec_desc->preheader, desc_len(sec_desc->desc));
-	PREHEADER_PREP_BPID(sec_desc->preheader, sa->sa_bpid);
-	PREHEADER_PREP_BSIZE(sec_desc->preheader, sa->sa_bufsize);
-	if (sa->sa_dir == DPA_IPSEC_INBOUND)
-		PREHEADER_PREP_OFFSET(sec_desc->preheader,
-			sa->dpa_ipsec->config.post_sec_in_params.data_off);
-	else
-		PREHEADER_PREP_OFFSET(sec_desc->preheader,
-			sa->dpa_ipsec->config.post_sec_out_params.data_off);
-
-	sec_desc->preheader = cpu_to_caam64(sec_desc->preheader);
+	sec_desc->preheader.hi.field.idlen = desc_len((u32 *) sec_desc->desc);
+	sec_desc->preheader.lo.field.pool_id = sa->sa_bpid;
+	sec_desc->preheader.lo.field.pool_buffer_size = sa->sa_bufsize;
+	sec_desc->preheader.lo.field.offset =
+		(sa->sa_dir == DPA_IPSEC_INBOUND) ?
+			sa->dpa_ipsec->config.post_sec_in_params.data_off :
+			sa->dpa_ipsec->config.post_sec_out_params.data_off;
 
 	dma_unmap_single(jrdev, auth_key_dma,
 			 sa->auth_data.split_key_pad_len, DMA_TO_DEVICE);
@@ -1519,7 +1519,7 @@ int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw,
 	BUG_ON(!sa);
 	BUG_ON(!sa->sec_desc);
 	desc = (uint32_t *)sa->sec_desc->desc;
-	options = (uint8_t)(be32_to_cpu(*(desc + 1)) & 0x000000FF);
+	options = (uint8_t)(*(desc + 1) & 0x000000FF);
 	c_arw = options >> 6;
 	if (c_arw == arw) {
 		log_err("SA %d has already set this ARS %d\n", sa->id, arw);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index e228bdb..15fc056 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -41,6 +41,32 @@
 					 * shared descriptor length is 50 words
 					 */
 
+/* preheader */
+struct preheader {
+	union {
+		uint32_t word;
+		struct {
+			uint16_t rsvd63_48;
+			unsigned int rsvd47_39:9;
+			unsigned int idlen:7;
+		} field;
+	} __packed hi;
+
+	union {
+		uint32_t word;
+		struct {
+			unsigned int rsvd31_30:2;
+			unsigned int fsgt:1;
+			unsigned int lng:1;
+			unsigned int offset:2;
+			unsigned int abs:1;
+			unsigned int add_buf:1;
+			uint8_t pool_id;
+			uint16_t pool_buffer_size;
+		} field;
+	} __packed lo;
+} __packed;
+
 struct desc_hdr {
 	uint32_t hdr_word;
 	union {
@@ -50,7 +76,7 @@ struct desc_hdr {
 };
 
 struct sec_descriptor {
-	u64	preheader;
+	struct preheader preheader;	/* SEC preheader */
 	/* SEC Shared Descriptor */
 	union {
 		uint32_t desc[MAX_CAAM_DESCSIZE];
-- 
1.7.9.5


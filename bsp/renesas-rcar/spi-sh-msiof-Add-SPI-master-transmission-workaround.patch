From 62571019415f43db5eab1405e1419a5b85512988 Mon Sep 17 00:00:00 2001
From: Hiromitsu Yamasaki <hiromitsu.yamasaki.ym@renesas.com>
Date: Thu, 2 Feb 2017 20:16:52 +0900
Subject: [PATCH 245/909] spi: sh-msiof: Add SPI master transmission workaround

commit 40439722c876dfd25fde2a0624100e35e863d400 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

The patch is a workaround(H/W Restriction No.6) of the
master transfer for H3(WS1.0, WS1.1).

Signed-off-by: Hiromitsu Yamasaki <hiromitsu.yamasaki.ym@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/spi/spi-sh-msiof.c | 58 ++++++++++++++++++++++++++++++++++++--
 1 file changed, 56 insertions(+), 2 deletions(-)

diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c
index 0662f58db142..df9866154cca 100644
--- a/drivers/spi/spi-sh-msiof.c
+++ b/drivers/spi/spi-sh-msiof.c
@@ -29,6 +29,7 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/sh_dma.h>
+#include <linux/sys_soc.h>
 
 #include <linux/spi/sh_msiof.h>
 #include <linux/spi/spi.h>
@@ -65,6 +66,7 @@ struct sh_msiof_spi_priv {
 	bool native_cs_inited;
 	bool native_cs_high;
 	bool slave_aborted;
+	unsigned int quirks;
 };
 
 #define MAX_SS	3	/* Maximum number of native chip selects */
@@ -95,6 +97,7 @@ struct sh_msiof_spi_priv {
 #define MDR1_SYNCMD_LR	 0x30000000 /*   L/R mode */
 #define MDR1_SYNCAC_SHIFT	 25 /* Sync Polarity (1 = Active-low) */
 #define MDR1_BITLSB_SHIFT	 24 /* MSB/LSB First (1 = LSB first) */
+#define MDR1_DTDL_MASK   0x00700000 /* Data Pin Bit Delay Mask */
 #define MDR1_DTDL_SHIFT		 20 /* Data Pin Bit Delay for MSIOF_SYNC */
 #define MDR1_SYNCDL_SHIFT	 16 /* Frame Sync Signal Timing Delay */
 #define MDR1_FLD_MASK	 0x0000000c /* Frame Sync Signal Interval (0-3) */
@@ -197,6 +200,17 @@ struct sh_msiof_spi_priv {
 #define IER_RFUDFE	0x00000010 /* Receive FIFO Underflow Enable */
 #define IER_RFOVFE	0x00000008 /* Receive FIFO Overflow Enable */
 
+/* Check LSI revisions and set specific quirk value */
+#define TRANSFER_WORKAROUND_H3WS10  BIT(0) /* H3ES1.0 workaround */
+#define TRANSFER_WORKAROUND_H3WS11  BIT(1) /* H3ES1.1 workaround */
+
+static const struct soc_device_attribute rcar_quirks_match[]  = {
+	{ .soc_id = "r8a7795", .revision = "ES1.0",
+		.data = (void *)TRANSFER_WORKAROUND_H3WS10, },
+	{ .soc_id = "r8a7795", .revision = "ES1.1",
+		.data = (void *)TRANSFER_WORKAROUND_H3WS11, },
+	{/*sentinel*/},
+};
 
 static u32 sh_msiof_read(struct sh_msiof_spi_priv *p, int reg_offs)
 {
@@ -380,6 +394,19 @@ static void sh_msiof_spi_set_pin_regs(struct sh_msiof_spi_priv *p, u32 ss,
 	tmp |= !cs_high << MDR1_SYNCAC_SHIFT;
 	tmp |= lsb_first << MDR1_BITLSB_SHIFT;
 	tmp |= sh_msiof_spi_get_dtdl_and_syncdl(p);
+	if (p->quirks & TRANSFER_WORKAROUND_H3WS10) {
+		if (!spi_controller_is_slave(p->master)) {
+			tmp &= ~MDR1_DTDL_MASK;
+			tmp |= 0 << MDR1_DTDL_SHIFT;
+		}
+	}
+	if (p->quirks & TRANSFER_WORKAROUND_H3WS11) {
+		if (!spi_controller_is_slave(p->master)) {
+			tmp &= ~MDR1_DTDL_MASK;
+			tmp |= 1 << MDR1_DTDL_SHIFT;
+		}
+	}
+
 	if (spi_controller_is_slave(p->master)) {
 		sh_msiof_write(p, TMDR1, tmp | TMDR1_PCON);
 	} else {
@@ -387,6 +414,18 @@ static void sh_msiof_spi_set_pin_regs(struct sh_msiof_spi_priv *p, u32 ss,
 			       tmp | MDR1_TRMD | TMDR1_PCON |
 			       (ss < MAX_SS ? ss : 0) << TMDR1_SYNCCH_SHIFT);
 	}
+	if (p->quirks & TRANSFER_WORKAROUND_H3WS10) {
+		if (!spi_controller_is_slave(p->master)) {
+			tmp &= ~MDR1_DTDL_MASK;
+			tmp |= 2 << MDR1_DTDL_SHIFT;
+		}
+	}
+	if (p->quirks & TRANSFER_WORKAROUND_H3WS11) {
+		if (!spi_controller_is_slave(p->master)) {
+			tmp &= ~MDR1_DTDL_MASK;
+			tmp |= 1 << MDR1_DTDL_SHIFT;
+		}
+	}
 	if (p->master->flags & SPI_MASTER_MUST_TX) {
 		/* These bits are reserved if RX needs TX */
 		tmp &= ~0x0000ffff;
@@ -394,8 +433,18 @@ static void sh_msiof_spi_set_pin_regs(struct sh_msiof_spi_priv *p, u32 ss,
 	sh_msiof_write(p, RMDR1, tmp);
 
 	tmp = 0;
-	tmp |= CTR_TSCKIZ_SCK | cpol << CTR_TSCKIZ_POL_SHIFT;
-	tmp |= CTR_RSCKIZ_SCK | cpol << CTR_RSCKIZ_POL_SHIFT;
+	if (p->quirks & TRANSFER_WORKAROUND_H3WS10) {
+		if (!spi_controller_is_slave(p->master)) {
+			tmp |= 0 << CTR_TSCKIZ_POL_SHIFT;
+			tmp |= 0 << CTR_RSCKIZ_POL_SHIFT;
+		} else {
+			tmp |= CTR_TSCKIZ_SCK | cpol << CTR_TSCKIZ_POL_SHIFT;
+			tmp |= CTR_RSCKIZ_SCK | cpol << CTR_RSCKIZ_POL_SHIFT;
+		}
+	} else {
+		tmp |= CTR_TSCKIZ_SCK | cpol << CTR_TSCKIZ_POL_SHIFT;
+		tmp |= CTR_RSCKIZ_SCK | cpol << CTR_RSCKIZ_POL_SHIFT;
+	}
 
 	edge = cpol ^ !cpha;
 
@@ -1340,6 +1389,7 @@ static int sh_msiof_spi_probe(struct platform_device *pdev)
 	struct sh_msiof_spi_priv *p;
 	int i;
 	int ret;
+	const struct soc_device_attribute *attr;
 
 	chipdata = of_device_get_match_data(&pdev->dev);
 	if (chipdata) {
@@ -1370,6 +1420,10 @@ static int sh_msiof_spi_probe(struct platform_device *pdev)
 	p->info = info;
 	p->min_div_pow = chipdata->min_div_pow;
 
+	attr = soc_device_match(rcar_quirks_match);
+	if (attr)
+		p->quirks = (uintptr_t)attr->data;
+
 	init_completion(&p->done);
 	init_completion(&p->done_txdma);
 
-- 
2.17.1


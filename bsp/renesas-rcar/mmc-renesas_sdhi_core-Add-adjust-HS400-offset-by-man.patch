From 8861e7188e378f3fc88c73c861d6ed1d218c5fd6 Mon Sep 17 00:00:00 2001
From: Takeshi Saito <takeshi.saito.xv@renesas.com>
Date: Wed, 22 Aug 2018 14:37:10 +0900
Subject: [PATCH 225/909] mmc: renesas_sdhi_core: Add adjust HS400 offset by
 manual calibration mode

commit 1f84d574931b1319ebc1229678816338578f2d1e from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

Since Gen3 SDHI has a internal DS signal AC-spec violation in HS400 mode,
CRC-error may occur in read command. It is only HS400 mode.
This phoenomenon occurs at low/high temperature.
(R-Car Gen3 HW restriction No.109)

To fix this, after completion of HS400 tuning, enable manual calibration.
However, Gen3 M3 Ver.1.2 or earlier and H3 1.x does not support HS400.
These SoC forcibly use HS200 mode by SoC attribute.

[Flow of Manual Calibration mode]
1) Complete tuning in HS400 mode.
2) Switch card to HS400
3) Set HS400 timing (SDHI transitions to HS400)
4) Send command (CMD13)
5) Enable manual calibration

Before enabling manual calibration mode, CMD13 command must be issued.
In card initialization processing, CMD13 is executed at the end of
select HS400.
So, when CMD13 request completes, enables manual mode.

[Flow of enable manual calibration]
1) Disable register write protect
2) Read current calibration code and adjust it
3) Set manual mode with new calibration code
4) Set offset

[Flow of disable manual calibration]
1) Disable register write protect
2) Clear manual mode
3) Clear offset

Parameters for adjust HS400 are automatically set according to SoC.
For customization, these parameters can be overwritten by device tree.
Please refer to the latest HW manual for parameter for each product.

ex)
adjust_hs400_offset = <0>;
adjust_hs400_calibrate = <2>;

Signed-off-by: Takeshi Saito <takeshi.saito.xv@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mmc/host/renesas_sdhi.h      |   2 +
 drivers/mmc/host/renesas_sdhi_core.c | 216 +++++++++++++++++++++++++--
 2 files changed, 206 insertions(+), 12 deletions(-)

diff --git a/drivers/mmc/host/renesas_sdhi.h b/drivers/mmc/host/renesas_sdhi.h
index 2a710e2323ec..f191c9b3604c 100644
--- a/drivers/mmc/host/renesas_sdhi.h
+++ b/drivers/mmc/host/renesas_sdhi.h
@@ -53,6 +53,8 @@ struct renesas_sdhi {
 	void __iomem *scc_ctl;
 	u32 scc_tappos;
 	int scc_offset;
+	u32 adjust_hs400_offset;
+	u32 adjust_hs400_calibrate;
 };
 
 #define host_to_priv(host) \
diff --git a/drivers/mmc/host/renesas_sdhi_core.c b/drivers/mmc/host/renesas_sdhi_core.c
index a54f06041ef8..4fe841d2d2d3 100644
--- a/drivers/mmc/host/renesas_sdhi_core.c
+++ b/drivers/mmc/host/renesas_sdhi_core.c
@@ -49,18 +49,6 @@
 #define SDHI_VER_GEN3_SD	0xcc10
 #define SDHI_VER_GEN3_SDMMC	0xcd10
 
-static const struct soc_device_attribute sdhi_quirks_match[]  = {
-	{ .soc_id = "r8a7795", .revision = "ES1.*",
-	  .data = (void *)(DTRAEND1_SET_BIT17 | HS400_USE_4TAP), },
-	{ .soc_id = "r8a7795", .revision = "ES2.0",
-	  .data = (void *)HS400_USE_4TAP, },
-	{ .soc_id = "r8a7796", .revision = "ES1.0",
-	  .data = (void *)(DTRAEND1_SET_BIT17 | HS400_USE_4TAP), },
-	{ .soc_id = "r8a7796", .revision = "ES1.1",
-	  .data = (void *)HS400_USE_4TAP, },
-	{/*sentinel*/},
-};
-
 static void renesas_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 {
 	u32 val;
@@ -227,6 +215,11 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 #define SH_MOBILE_SDHI_SCC_RVSREQ	0x00A
 #define SH_MOBILE_SDHI_SCC_SMPCMP	0x00C
 #define SH_MOBILE_SDHI_SCC_TMPPORT2	0x00E
+#define SH_MOBILE_SDHI_SCC_TMPPORT3	0x014
+#define SH_MOBILE_SDHI_SCC_TMPPORT4	0x016
+#define SH_MOBILE_SDHI_SCC_TMPPORT5	0x018
+#define SH_MOBILE_SDHI_SCC_TMPPORT6	0x01A
+#define SH_MOBILE_SDHI_SCC_TMPPORT7	0x01C
 
 /* Definitions for values the SH_MOBILE_SDHI_SCC_DTCNTL register */
 #define SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN		BIT(0)
@@ -243,6 +236,52 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 #define SH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL	BIT(4)
 #define SH_MOBILE_SDHI_SCC_TMPPORT2_HS400EN	BIT(31)
 
+/* Definitions for values the SH_MOBILE_SDHI_SCC_TMPPORT3 register */
+#define SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_0	3
+#define SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_1	2
+#define SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_2	1
+#define SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_3	0
+#define SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_MASK	0x3
+
+/* Definitions for values the SH_MOBILE_SDHI_SCC_TMPPORT4 register */
+#define SH_MOBILE_SDHI_SCC_TMPPORT4_DLL_ACC_START	BIT(0)
+
+/* Definitions for values the SH_MOBILE_SDHI_SCC_TMPPORT5 register */
+#define SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_R	BIT(8)
+#define SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_W	(0 << 8)
+#define SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_ADR_MASK	0x3F
+
+/* Definitions for values the SH_MOBILE_SDHI_SCC register */
+#define SH_MOBILE_SDHI_SCC_TMPPORT_DISABLE_WP_CODE	0xa5000000
+#define SH_MOBILE_SDHI_SCC_TMPPORT_CALIB_CODE_MASK	0x1f
+#define SH_MOBILE_SDHI_SCC_TMPPORT_MANUAL_MODE		BIT(7)
+
+static const struct soc_device_attribute sdhi_quirks_match[]  = {
+	{ .soc_id = "r8a7795", .revision = "ES1.*",
+	  .data = (void *)(DTRAEND1_SET_BIT17 | HS400_USE_4TAP |
+			   FORCE_HS200), },
+	{ .soc_id = "r8a7795", .revision = "ES2.0",
+	  .data = (void *)HS400_USE_4TAP, },
+	{ .soc_id = "r8a7796", .revision = "ES1.0",
+	  .data = (void *)(DTRAEND1_SET_BIT17 | HS400_USE_4TAP |
+			   FORCE_HS200), },
+	{ .soc_id = "r8a7796", .revision = "ES1.1",
+	  .data = (void *)(HS400_USE_4TAP | FORCE_HS200), },
+	{ .soc_id = "r8a7796", .revision = "ES1.*",
+	  .data = (void *)(HS400_USE_4TAP | HS400_USE_MANUAL_CALIB |
+			   (SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_0 << 24) |
+			   (0x9 << 16)), },
+	{ .soc_id = "r8a77965",
+	  .data = (void *)(HS400_USE_MANUAL_CALIB |
+			   (SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_0 << 24) |
+			   (0x0 << 16)), },
+	{ .soc_id = "r8a77990",
+	  .data = (void *)(HS400_USE_MANUAL_CALIB |
+			   (SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_0 << 24) |
+			   (0x2 << 16)), },
+	{/*sentinel*/},
+};
+
 static inline u32 sd_scc_read32(struct tmio_mmc_host *host,
 				struct renesas_sdhi *priv, int addr)
 {
@@ -371,6 +410,94 @@ static void renesas_sdhi_prepare_hs400_tuning(struct mmc_host *mmc,
 
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |
 		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+
+	/* execute adjust hs400 offset after setting to HS400 mode */
+	host->needs_adjust_hs400 = true;
+}
+
+static u32 sd_scc_tmpport_read32(struct tmio_mmc_host *host,
+				 struct renesas_sdhi *priv, u32 addr)
+{
+	/* read mode */
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT5,
+		       SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_R |
+		       (SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_ADR_MASK & addr));
+
+	/* access start and stop */
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4,
+		       SH_MOBILE_SDHI_SCC_TMPPORT4_DLL_ACC_START);
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4, 0);
+
+	return sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT7);
+}
+
+static void sd_scc_tmpport_write32(struct tmio_mmc_host *host,
+				   struct renesas_sdhi *priv, u32 addr, u32 val)
+{
+	/* write mode */
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT5,
+		       SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_W |
+		       (SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_ADR_MASK & addr));
+
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT6, val);
+
+	/* access start and stop */
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4,
+		       SH_MOBILE_SDHI_SCC_TMPPORT4_DLL_ACC_START);
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4, 0);
+}
+
+static void renesas_sdhi_adjust_hs400_mode_enable(struct mmc_host *mmc)
+{
+	struct tmio_mmc_host *host = mmc_priv(mmc);
+	struct renesas_sdhi *priv = host_to_priv(host);
+	u32 calib_code;
+
+	/* Enabled Manual adjust HS400 mode
+	 *
+	 * 1) Disabled Write Protect
+	 *    W(addr=0x00, WP_DISABLE_CODE)
+	 * 2) Read Calibration code and adjust
+	 *    R(addr=0x26) - adjust value
+	 * 3) Enabled Manual Calibration
+	 *    W(addr=0x22, manual mode | Calibration code)
+	 * 4) Set Offset value to TMPPORT3 Reg
+	 */
+	sd_scc_tmpport_write32(host, priv, 0x00,
+			       SH_MOBILE_SDHI_SCC_TMPPORT_DISABLE_WP_CODE);
+	calib_code = sd_scc_tmpport_read32(host, priv, 0x26);
+	calib_code &= SH_MOBILE_SDHI_SCC_TMPPORT_CALIB_CODE_MASK;
+	if (calib_code > priv->adjust_hs400_calibrate)
+		calib_code -= priv->adjust_hs400_calibrate;
+	else
+		calib_code = 0;
+	sd_scc_tmpport_write32(host, priv, 0x22,
+			       SH_MOBILE_SDHI_SCC_TMPPORT_MANUAL_MODE |
+			       calib_code);
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT3,
+		       priv->adjust_hs400_offset);
+
+	/* Clear flag */
+	host->needs_adjust_hs400 = false;
+}
+
+static void renesas_sdhi_adjust_hs400_mode_disable(struct mmc_host *mmc)
+{
+	struct tmio_mmc_host *host = mmc_priv(mmc);
+	struct renesas_sdhi *priv = host_to_priv(host);
+
+	/* Disabled Manual adjust HS400 mode
+	 *
+	 * 1) Disabled Write Protect
+	 *    W(addr=0x00, WP_DISABLE_CODE)
+	 * 2) Disabled Manual Calibration
+	 *    W(addr=0x22, 0)
+	 * 3) Clear offset value to TMPPORT3 Reg
+	 */
+	sd_scc_tmpport_write32(host, priv, 0x00,
+			       SH_MOBILE_SDHI_SCC_TMPPORT_DISABLE_WP_CODE);
+	sd_scc_tmpport_write32(host, priv, 0x22, 0);
+	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT3, 0);
 }
 
 static void renesas_sdhi_reset_hs400_mode(struct mmc_host *mmc)
@@ -389,6 +516,9 @@ static void renesas_sdhi_reset_hs400_mode(struct mmc_host *mmc)
 			 SH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL) &
 			sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2));
 
+	if (host->adjust_hs400_mode_disable)
+		host->adjust_hs400_mode_disable(host->mmc);
+
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |
 			sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
 }
@@ -406,6 +536,9 @@ static int renesas_sdhi_select_tuning(struct tmio_mmc_host *host)
 	unsigned long i;
 	bool select = false;
 
+	/* clear flag */
+	host->needs_adjust_hs400 = false;
+
 	/* Clear SCC_RVSREQ */
 	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);
 
@@ -547,6 +680,10 @@ static void renesas_sdhi_hw_reset(struct tmio_mmc_host *host)
 			 SH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL) &
 			sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2));
 
+	/* Disaled adjust HS400 mode */
+	if (host->adjust_hs400_mode_disable)
+		host->adjust_hs400_mode_disable(host->mmc);
+
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |
 			sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
 
@@ -639,6 +776,8 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	struct resource *res;
 	const struct soc_device_attribute *attr;
 	int irq, ret, i;
+	const struct device_node *np = pdev->dev.of_node;
+	u32 value;
 
 	of_data = of_device_get_match_data(&pdev->dev);
 
@@ -714,6 +853,7 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	host->clk_disable	= renesas_sdhi_clk_disable;
 	host->multi_io_quirk	= renesas_sdhi_multi_io_quirk;
 	host->dma_ops		= dma_ops;
+	host->needs_adjust_hs400 = false;
 
 	/* For some SoC, we disable internal WP. GPIO may override this */
 	if (mmc_can_gpio_ro(host->mmc))
@@ -727,6 +867,58 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 			renesas_sdhi_start_signal_voltage_switch;
 	}
 
+	/* Adjust HS400 mode */
+	priv->adjust_hs400_offset = 0;
+	priv->adjust_hs400_calibrate = 0;
+
+	if (np && !of_property_read_u32(np, "adjust_hs400_offset", &value)) {
+		/* DeviceTree can invalidate SoC attribute for HS400 */
+		switch (value) {
+		case 0:
+			priv->adjust_hs400_offset =
+				SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_0;
+			break;
+		case 1:
+			priv->adjust_hs400_offset =
+				SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_1;
+			break;
+		case 2:
+			priv->adjust_hs400_offset =
+				SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_2;
+			break;
+		case 3:
+			priv->adjust_hs400_offset =
+				SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_3;
+			break;
+		default:
+			priv->adjust_hs400_offset =
+				SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_3;
+			dev_warn(&host->pdev->dev, "Unknown adjust hs400 offset\n");
+		}
+		if (!of_property_read_u32(np, "adjust_hs400_calibrate", &value))
+			priv->adjust_hs400_calibrate = value;
+		host->adjust_hs400_mode_enable =
+			renesas_sdhi_adjust_hs400_mode_enable;
+		host->adjust_hs400_mode_disable =
+			renesas_sdhi_adjust_hs400_mode_disable;
+	} else if (host->mmc->caps2 & MMC_CAP2_HS400) {
+		if (host->sdhi_quirks & FORCE_HS200) {
+			host->mmc->caps2 &=
+				~(MMC_CAP2_HS400 | MMC_CAP2_HS400_ES);
+		} else if (host->sdhi_quirks & HS400_USE_MANUAL_CALIB) {
+			priv->adjust_hs400_offset =
+				(host->sdhi_quirks >> 24) &
+				SH_MOBILE_SDHI_SCC_TMPPORT3_OFFSET_MASK;
+			priv->adjust_hs400_calibrate =
+				(host->sdhi_quirks >> 16) &
+				SH_MOBILE_SDHI_SCC_TMPPORT_CALIB_CODE_MASK;
+			host->adjust_hs400_mode_enable =
+				renesas_sdhi_adjust_hs400_mode_enable;
+			host->adjust_hs400_mode_disable =
+				renesas_sdhi_adjust_hs400_mode_disable;
+		}
+	}
+
 	/* Orginally registers were 16 bit apart, could be 32 or 64 nowadays */
 	if (!host->bus_shift && resource_size(res) > 0x100) /* old way to determine the shift */
 		host->bus_shift = 1;
-- 
2.17.1


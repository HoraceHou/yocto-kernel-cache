From a4307d0a4d0c69d7b2588dd90a00cd4d14de2ea9 Mon Sep 17 00:00:00 2001
From: Tomohiro Fujiwara <tomohiro.fujiwara.cw@hitachi.com>
Date: Tue, 5 Dec 2017 17:36:19 +0900
Subject: [PATCH 148/909] tee: tee_shm: Fix the release function to the shared
 memory

commit eef19e7c5353b6acd3c77e2ff5efd8466c740e11 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

When the kernel module releases the shared memory by the
tee_shm_free function, this function performs setting for
releasing at the end of the task but does not actually release the
memory. Therefore, when securing a lot of memory with one task, an
error occurs, so the shared memory is released each time
tee_shm_free is called.

Fixed checkpatch issues.

Signed-off-by: Tomohiro Fujiwara <tomohiro.fujiwara.cw@hitachi.com>
Signed-off-by: Hiroki Negishi <hiroki.negishi.bx@renesas.com>
Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tee/tee_shm.c | 59 +++++++++++++++++++++++--------------------
 1 file changed, 31 insertions(+), 28 deletions(-)

diff --git a/drivers/tee/tee_shm.c b/drivers/tee/tee_shm.c
index 07d3be6f0780..086471b8b667 100644
--- a/drivers/tee/tee_shm.c
+++ b/drivers/tee/tee_shm.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2015-2016, Linaro Limited
+ * Copyright (c) 2018, Renesas Electronics Corporation
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -24,41 +25,43 @@ static void tee_shm_release(struct tee_shm *shm)
 {
 	struct tee_device *teedev = shm->teedev;
 
-	mutex_lock(&teedev->mutex);
-	idr_remove(&teedev->idr, shm->id);
-	if (shm->ctx)
-		list_del(&shm->link);
-	mutex_unlock(&teedev->mutex);
+	if (shm->kaddr) {
+		mutex_lock(&teedev->mutex);
+		idr_remove(&teedev->idr, shm->id);
+		if (shm->ctx)
+			list_del(&shm->link);
+		mutex_unlock(&teedev->mutex);
 
-	if (shm->flags & TEE_SHM_POOL) {
-		struct tee_shm_pool_mgr *poolm;
+		if (shm->flags & TEE_SHM_POOL) {
+			struct tee_shm_pool_mgr *poolm;
 
-		if (shm->flags & TEE_SHM_DMA_BUF)
-			poolm = teedev->pool->dma_buf_mgr;
-		else
-			poolm = teedev->pool->private_mgr;
+			if (shm->flags & TEE_SHM_DMA_BUF)
+				poolm = teedev->pool->dma_buf_mgr;
+			else
+				poolm = teedev->pool->private_mgr;
 
-		poolm->ops->free(poolm, shm);
-	} else if (shm->flags & TEE_SHM_REGISTER) {
-		size_t n;
-		int rc = teedev->desc->ops->shm_unregister(shm->ctx, shm);
+			poolm->ops->free(poolm, shm);
+		} else if (shm->flags & TEE_SHM_REGISTER) {
+			size_t n;
+			int rc = teedev->desc->ops->shm_unregister(shm->ctx, shm);
 
-		if (rc)
-			dev_err(teedev->dev.parent,
-				"unregister shm %p failed: %d", shm, rc);
+			if (rc)
+				dev_err(teedev->dev.parent,
+					"unregister shm %p failed: %d", shm, rc);
 
-		for (n = 0; n < shm->num_pages; n++)
-			put_page(shm->pages[n]);
+			for (n = 0; n < shm->num_pages; n++)
+				put_page(shm->pages[n]);
 
-		kfree(shm->pages);
-	}
+			kfree(shm->pages);
+		}
 
-	if (shm->ctx)
-		teedev_ctx_put(shm->ctx);
+		if (shm->ctx)
+			teedev_ctx_put(shm->ctx);
 
-	kfree(shm);
+		kfree(shm);
 
-	tee_device_put(teedev);
+		tee_device_put(teedev);
+	}
 }
 
 static struct sg_table *tee_shm_op_map_dma_buf(struct dma_buf_attachment
@@ -382,8 +385,8 @@ void tee_shm_free(struct tee_shm *shm)
 	 */
 	if (shm->flags & TEE_SHM_DMA_BUF)
 		dma_buf_put(shm->dmabuf);
-	else
-		tee_shm_release(shm);
+
+	tee_shm_release(shm);
 }
 EXPORT_SYMBOL_GPL(tee_shm_free);
 
-- 
2.17.1


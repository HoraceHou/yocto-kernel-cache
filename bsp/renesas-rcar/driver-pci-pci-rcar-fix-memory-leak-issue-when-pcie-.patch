From 1b267332e33fa4924398fbea95839baf128571fd Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Tue, 3 Sep 2019 03:28:30 +0000
Subject: [PATCH] driver: pci: pci-rcar: fix memory leak issue when pcie
 regulator is not ready

During booting up kernel, pcie controller driver is loaded before pcie
regulator. In this case, pcie controller driver return EPROBE_DEFER,
but forget to free struct pci_host_bridge instance alloced before.
This issue is involed by commit 6984ab610e5d("pci: pcie-rcar: add
regulators support")
Therefore, free struct pci_host_bridge instance before return pcie
probe() function to fix this issue.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/controller/pcie-rcar.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/controller/pcie-rcar.c b/drivers/pci/controller/pcie-rcar.c
index 764a0fdee12e..408824f5b26a 100644
--- a/drivers/pci/controller/pcie-rcar.c
+++ b/drivers/pci/controller/pcie-rcar.c
@@ -1261,21 +1261,26 @@ static int rcar_pcie_probe(struct platform_device *pdev)
 
 	pcie->pcie3v3 = devm_regulator_get_optional(dev, "pcie3v3");
 	if (IS_ERR(pcie->pcie3v3)) {
-		if (PTR_ERR(pcie->pcie3v3) == -EPROBE_DEFER)
+		if (PTR_ERR(pcie->pcie3v3) == -EPROBE_DEFER) {
+			pci_free_host_bridge(bridge);
 			return -EPROBE_DEFER;
+		}
 		dev_info(dev, "no pcie3v3 regulator found\n");
 	}
 
 	pcie->pcie1v8 = devm_regulator_get_optional(dev, "pcie1v8");
 	if (IS_ERR(pcie->pcie1v8)) {
-		if (PTR_ERR(pcie->pcie1v8) == -EPROBE_DEFER)
+		if (PTR_ERR(pcie->pcie1v8) == -EPROBE_DEFER) {
+			pci_free_host_bridge(bridge);
 			return -EPROBE_DEFER;
+		}
 		dev_info(dev, "no pcie1v8 regulator found\n");
 	}
 
 	err = rcar_pcie_set_vpcie(pcie);
 	if (err) {
 		dev_err(dev, "failed to set pcie regulators\n");
+		pci_free_host_bridge(bridge);
 		return err;
 	}
 
@@ -1364,6 +1369,12 @@ static int rcar_pcie_probe(struct platform_device *pdev)
 	pci_free_resource_list(&pcie->resources);
 
 err_free_bridge:
+	if(!IS_ERR(pcie->pcie3v3))
+		if (regulator_is_enabled(pcie->pcie3v3))
+			regulator_disable(pcie->pcie3v3);
+	if(!IS_ERR(pcie->pcie1v8))
+		if (regulator_is_enabled(pcie->pcie1v8))
+			regulator_disable(pcie->pcie1v8);
 	pci_free_host_bridge(bridge);
 
 	return err;
-- 
2.17.1


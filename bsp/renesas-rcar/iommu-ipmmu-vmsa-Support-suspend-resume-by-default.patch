From baea5ae00a21a79408730193e5552c03cf522b8e Mon Sep 17 00:00:00 2001
From: Hai Nguyen Pham <hai.pham.ud@renesas.com>
Date: Thu, 7 Mar 2019 11:41:52 +0700
Subject: [PATCH 750/909] iommu/ipmmu-vmsa: Support suspend/resume by default

commit 53043d1897d2f75cbdb428c40e452df110d9eeba from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

Remove unnecessary macro guards to support suspend/resume by default

Signed-off-by: Hai Nguyen Pham <hai.pham.ud@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/iommu/ipmmu-vmsa.c | 26 +-------------------------
 1 file changed, 1 insertion(+), 25 deletions(-)

diff --git a/drivers/iommu/ipmmu-vmsa.c b/drivers/iommu/ipmmu-vmsa.c
index d229bdce2edc..f9a6bf186c93 100644
--- a/drivers/iommu/ipmmu-vmsa.c
+++ b/drivers/iommu/ipmmu-vmsa.c
@@ -1,7 +1,7 @@
 /*
  * IPMMU VMSA
  *
- * Copyright (C) 2014 Renesas Electronics Corporation
+ * Copyright (C) 2014-2019 Renesas Electronics Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,13 +57,11 @@ struct ipmmu_features {
 #endif
 };
 
-#ifdef CONFIG_RCAR_DDR_BACKUP
 struct hw_register {
 	char *reg_name;
 	unsigned int reg_offset;
 	unsigned int reg_data;
 };
-#endif
 
 struct ipmmu_vmsa_device {
 	struct device *dev;
@@ -76,11 +74,9 @@ struct ipmmu_vmsa_device {
 	spinlock_t lock;			/* Protects ctx and domains[] */
 	DECLARE_BITMAP(ctx, IPMMU_CTX_MAX);
 	struct ipmmu_vmsa_domain *domains[IPMMU_CTX_MAX];
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	struct hw_register *reg_backup[IPMMU_CTX_MAX];
 	unsigned int *utlbs_val;
 	unsigned int *asids_val;
-#endif
 
 	struct iommu_group *group;
 	struct dma_iommu_mapping *mapping;
@@ -100,7 +96,6 @@ struct ipmmu_vmsa_domain {
 	struct mutex mutex;			/* Protects mappings */
 };
 
-#ifdef CONFIG_RCAR_DDR_BACKUP
 struct ipmmu_vmsa_backup {
 	struct device *dev;
 	struct list_head list;
@@ -108,7 +103,6 @@ struct ipmmu_vmsa_backup {
 
 static DEFINE_SPINLOCK(ipmmu_devices_backup_lock);
 static LIST_HEAD(ipmmu_devices_backup);
-#endif
 
 static struct ipmmu_vmsa_domain *to_vmsa_domain(struct iommu_domain *dom)
 {
@@ -422,7 +416,6 @@ static struct ipmmu_whitelist *r8a77990_whitelist[] = {
 #define IMUASID_ASID0_MASK		(0xff << 0)
 #define IMUASID_ASID0_SHIFT		0
 
-#ifdef CONFIG_RCAR_DDR_BACKUP
 #define HW_REGISTER_BACKUP_SIZE		ARRAY_SIZE(root_pgtable0_reg)
 static struct hw_register root_pgtable0_reg[] = {
 	{"IMTTLBR0",	IMTTLBR0,	0},
@@ -522,7 +515,6 @@ static struct hw_register *root_pgtable[IPMMU_CTX_MAX] = {
 	root_pgtable6_reg,
 	root_pgtable7_reg,
 };
-#endif /* CONFIG_RCAR_DDR_BACKUP */
 
 /* -----------------------------------------------------------------------------
  * Root device handling
@@ -752,9 +744,7 @@ static int ipmmu_domain_init_context(struct ipmmu_vmsa_domain *domain)
 		return ret;
 
 	domain->context_id = ret;
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	domain->mmu->root->reg_backup[ret] = root_pgtable[ret];
-#endif
 
 	domain->iop = alloc_io_pgtable_ops(ARM_32_LPAE_S1, &domain->cfg,
 					   domain);
@@ -828,9 +818,7 @@ static void ipmmu_domain_destroy_context(struct ipmmu_vmsa_domain *domain)
 	ipmmu_ctx_write_all(domain, IMCTR, IMCTR_FLUSH);
 	ipmmu_tlb_sync(domain);
 
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	domain->mmu->root->reg_backup[domain->context_id] = NULL;
-#endif
 
 	ipmmu_domain_free_context(domain->mmu->root, domain->context_id);
 }
@@ -1248,12 +1236,10 @@ static int ipmmu_init_arm_mapping(struct device *dev)
 static int ipmmu_add_device(struct device *dev)
 {
 	struct iommu_group *group;
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	struct ipmmu_vmsa_backup *dev_backup;
 	struct iommu_fwspec *fwspec;
 	struct ipmmu_vmsa_device *mmu;
 	unsigned int *utlbs_val, *asids_val;
-#endif
 
 	/*
 	 * Only let through devices that have been verified in xlate()
@@ -1270,7 +1256,6 @@ static int ipmmu_add_device(struct device *dev)
 
 	iommu_group_put(group);
 
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	dev_backup = kzalloc(sizeof(*dev_backup), GFP_KERNEL);
 	dev_backup->dev = dev;
 	fwspec = dev->iommu_fwspec;
@@ -1290,14 +1275,12 @@ static int ipmmu_add_device(struct device *dev)
 
 	mmu->utlbs_val = utlbs_val;
 	mmu->asids_val = asids_val;
-#endif
 
 	return 0;
 }
 
 static void ipmmu_remove_device(struct device *dev)
 {
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	struct ipmmu_vmsa_device *mmu = to_ipmmu(dev);
 	struct ipmmu_vmsa_backup *slave_dev;
 
@@ -1312,7 +1295,6 @@ static void ipmmu_remove_device(struct device *dev)
 
 	kfree(mmu->utlbs_val);
 	kfree(mmu->asids_val);
-#endif
 
 	arm_iommu_detach_device(dev);
 	iommu_group_remove_device(dev);
@@ -1609,7 +1591,6 @@ static int ipmmu_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
-#ifdef CONFIG_RCAR_DDR_BACKUP
 static int ipmmu_utlbs_backup(struct ipmmu_vmsa_device *mmu)
 {
 	unsigned int i;
@@ -1741,11 +1722,9 @@ static int ipmmu_domain_restore_context(struct ipmmu_vmsa_domain *domain)
 
 	return 0;
 }
-#endif /* CONFIG_RCAR_DDR_BACKUP */
 
 static int ipmmu_suspend(struct device *dev)
 {
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	unsigned int i;
 	struct ipmmu_vmsa_device *mmu = dev_get_drvdata(dev);
 
@@ -1761,14 +1740,12 @@ static int ipmmu_suspend(struct device *dev)
 		}
 	else
 		ipmmu_utlbs_backup(mmu);
-#endif
 
 	return 0;
 }
 
 static int ipmmu_resume(struct device *dev)
 {
-#ifdef CONFIG_RCAR_DDR_BACKUP
 	unsigned int i;
 	struct ipmmu_vmsa_device *mmu = dev_get_drvdata(dev);
 
@@ -1782,7 +1759,6 @@ static int ipmmu_resume(struct device *dev)
 		}
 	else
 		ipmmu_utlbs_restore(mmu);
-#endif
 
 	return 0;
 }
-- 
2.17.1


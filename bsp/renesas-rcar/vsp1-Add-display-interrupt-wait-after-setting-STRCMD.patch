From c0fdca1a9da9fe3e60749fc83dab0e79b2027b5f Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Mon, 3 Sep 2018 20:00:52 +0900
Subject: [PATCH 313/909] vsp1: Add display interrupt wait after setting STRCMD
 bit

commit f57dc2f092c5dab3a377fc62f77184c574b1b805 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

According to H/W manual, the DST bit in VI6_DISP0_IRQ_STA register
should be wait after STRCMD bit in VI6_CMD register is set.
This patch adds it.

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/vsp1/vsp1_drm.c  | 9 +++++++++
 drivers/media/platform/vsp1/vsp1_drv.c  | 4 ++++
 drivers/media/platform/vsp1/vsp1_pipe.h | 4 ++++
 3 files changed, 17 insertions(+)

diff --git a/drivers/media/platform/vsp1/vsp1_drm.c b/drivers/media/platform/vsp1/vsp1_drm.c
index 8ff03512156f..68364d48b308 100644
--- a/drivers/media/platform/vsp1/vsp1_drm.c
+++ b/drivers/media/platform/vsp1/vsp1_drm.c
@@ -758,11 +758,19 @@ int vsp1_du_setup_lif(struct device *dev, unsigned int pipe_index,
 	if (ret < 0)
 		return ret;
 
+	if (pipe->state == VSP1_PIPELINE_STOPPED)
+		pipe->dst_cnt = 1;
+
 	/* Start the pipeline. */
 	spin_lock_irqsave(&pipe->irqlock, flags);
 	vsp1_pipeline_run(pipe);
 	spin_unlock_irqrestore(&pipe->irqlock, flags);
 
+	/* Check display start interrupt */
+	if (!wait_event_timeout(pipe->dst_wait, pipe->dst_cnt == 0,
+				msecs_to_jiffies(100)))
+		dev_warn(vsp1->dev, "display interrupt timeout\n");
+
 	dev_dbg(vsp1->dev, "%s: pipeline enabled\n", __func__);
 
 	return 0;
@@ -1040,6 +1048,7 @@ int vsp1_drm_init(struct vsp1_device *vsp1)
 		pipe->output->write_back = WB_STAT_CATP_DONE;
 		init_waitqueue_head(&pipe->event_wait);
 		list_add_tail(&pipe->output->entity.list_pipe, &pipe->entities);
+		init_waitqueue_head(&pipe->dst_wait);
 
 		pipe->lif->pipe = pipe;
 		list_add_tail(&pipe->lif->list_pipe, &pipe->entities);
diff --git a/drivers/media/platform/vsp1/vsp1_drv.c b/drivers/media/platform/vsp1/vsp1_drv.c
index c84b81b29f61..39197cba10bc 100644
--- a/drivers/media/platform/vsp1/vsp1_drv.c
+++ b/drivers/media/platform/vsp1/vsp1_drv.c
@@ -202,6 +202,10 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
 		if (disp_st & VI6_DISP_IRQ_STA_DST) {
 			vsp1_drm_display_start(vsp1, i, wpf->entity.pipe);
 			ret = IRQ_HANDLED;
+			if (wpf->entity.pipe->dst_cnt) {
+				if (--wpf->entity.pipe->dst_cnt == 0)
+					wake_up(&wpf->entity.pipe->dst_wait);
+			}
 		}
 
 		if ((vsp1->ths_quirks & VSP1_UNDERRUN_WORKAROUND) && underrun)
diff --git a/drivers/media/platform/vsp1/vsp1_pipe.h b/drivers/media/platform/vsp1/vsp1_pipe.h
index 969c3283e78d..d3acfe78308d 100644
--- a/drivers/media/platform/vsp1/vsp1_pipe.h
+++ b/drivers/media/platform/vsp1/vsp1_pipe.h
@@ -110,6 +110,8 @@ struct vsp1_partition {
  * @vmute_flag: Enable mute flag of VSPD
  * @event_wait: wait queue to wait for write back state
  * @completed: display update completion flag
+ * @dst_cnt: display interrupt count
+ * @dst_wait: wait queue used to display interrupt signal
  */
 struct vsp1_pipeline {
 	struct media_pipeline pipe;
@@ -153,6 +155,8 @@ struct vsp1_pipeline {
 	bool vmute_flag;
 	wait_queue_head_t event_wait;
 	bool completed;
+	unsigned int dst_cnt;
+	wait_queue_head_t dst_wait;
 };
 
 void vsp1_pipeline_reset(struct vsp1_pipeline *pipe);
-- 
2.17.1


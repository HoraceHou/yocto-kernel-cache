From 49d3edd524016d2de82608cc994c705cc0e8ed3f Mon Sep 17 00:00:00 2001
From: Dien Pham <dien.pham.ry@renesas.com>
Date: Thu, 15 Mar 2018 18:15:14 +0700
Subject: [PATCH 029/909] soc: renesas: rcar-sysc: Improve power domains always
 on implementation

commit 52dc6ae173a1c7546dfd73a675feb29b63dffcc9 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

R-Car Gen3 SoC has some power domains, which are transitioned by
multiple triggers. According to Hardware Manual, it is necessary
to control that the state transitions do not conflict for each
power domains.

The patterns of conflict are below.

1. CA5x  vs CA5x : Exclusion control with HW
2. CA5x  vs 3DG  : Exclusion control with HW
3. CA5x  vs Other: Exclusion control with SW (Not implemented yet)
4. 3DG   vs Other: Exclusion control with SW (already implemented)
5. Other vs Other: Exclusion control with SW (already implemented)

This patch fixes pattern 3 by turning on the other power domains
at always. This conflict issue now occurs only on: H3 v1.*,
H3 v2.0, M3 v1.*, M3N v1.0. So, this implementation is improved
to apply for these platforms only.

Please note this change causes an increase of power consumption.

Signed-off-by: Dien Pham <dien.pham.ry@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/renesas/rcar-sysc.c | 69 +++++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/drivers/soc/renesas/rcar-sysc.c b/drivers/soc/renesas/rcar-sysc.c
index e06bcea8e7f7..1c2e19e51122 100644
--- a/drivers/soc/renesas/rcar-sysc.c
+++ b/drivers/soc/renesas/rcar-sysc.c
@@ -9,6 +9,9 @@
  * for more details.
  */
 
+#include <dt-bindings/power/r8a7795-sysc.h>
+#include <dt-bindings/power/r8a7796-sysc.h>
+#include <dt-bindings/power/r8a77965-sysc.h>
 #include <linux/clk/renesas.h>
 #include <linux/delay.h>
 #include <linux/err.h>
@@ -19,6 +22,7 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/soc/renesas/rcar-sysc.h>
+#include <linux/sys_soc.h>
 #include <linux/syscore_ops.h>
 
 #include "rcar-sysc.h"
@@ -59,6 +63,37 @@
 
 #define RCAR_PD_ALWAYS_ON	32	/* Always-on power area */
 
+static
+const struct soc_device_attribute rcar_sysc_quirks_match[] __initconst = {
+	{
+		.soc_id = "r8a7795", .revision = "ES2.0",
+		.data = (void *)(BIT(R8A7795_PD_A3VP) | BIT(R8A7795_PD_CR7)
+			| BIT(R8A7795_PD_A3VC) | BIT(R8A7795_PD_A2VC0)
+			| BIT(R8A7795_PD_A2VC1) | BIT(R8A7795_PD_A3IR)),
+	},
+	{
+		.soc_id = "r8a7795", .revision = "ES1.*",
+		.data = (void *)(BIT(R8A7795_PD_A3VP) | BIT(R8A7795_PD_CR7)
+			| BIT(R8A7795_PD_A3VC) | BIT(R8A7795_PD_A2VC0)
+			| BIT(R8A7795_PD_A2VC1) | BIT(R8A7795_PD_A3IR)),
+	},
+	{
+		.soc_id = "r8a7796", .revision = "ES1.*",
+		.data = (void *)(BIT(R8A7796_PD_CR7) | BIT(R8A7796_PD_A3VC)
+			| BIT(R8A7796_PD_A2VC0) | BIT(R8A7796_PD_A2VC1)
+			| BIT(R8A7796_PD_A3IR)),
+	},
+	{
+		.soc_id = "r8a77965", .revision = "ES1.0",
+		.data = (void *)(BIT(R8A77965_PD_A3VP) | BIT(R8A77965_PD_CR7)
+			| BIT(R8A77965_PD_A3VC) | BIT(R8A77965_PD_A2VC1)
+			| BIT(R8A77965_PD_A3IR)),
+	},
+	{ /* sentinel */ }
+};
+
+static u32 rcar_sysc_quirks;
+
 static void __iomem *rcar_sysc_base;
 static DEFINE_SPINLOCK(rcar_sysc_lock); /* SMP CPUs + I/O devices */
 
@@ -274,6 +309,27 @@ static int __init rcar_sysc_pd_setup(struct rcar_sysc_pd *pd)
 	return error;
 }
 
+struct rcar_sysc_pd *rcar_domains[RCAR_PD_ALWAYS_ON + 1];
+
+static void rcar_power_on_force(void)
+{
+	int i;
+
+	for (i = 0; i < RCAR_PD_ALWAYS_ON; i++) {
+		struct rcar_sysc_pd *pd = rcar_domains[i];
+
+		if (!pd)
+			continue;
+
+		if (rcar_sysc_quirks & BIT(pd->ch.isr_bit)) {
+			if (!rcar_sysc_power_is_off(&pd->ch))
+				continue;
+
+			rcar_sysc_power_up(&pd->ch);
+		}
+	}
+}
+
 static u32 syscier_val, syscimr_val;
 #ifdef CONFIG_PM_SLEEP
 static void rcar_sysc_resume(void)
@@ -283,6 +339,8 @@ static void rcar_sysc_resume(void)
 	/* Re-enable interrupts as init */
 	iowrite32(syscimr_val, rcar_sysc_base + SYSCIMR);
 	iowrite32(syscier_val, rcar_sysc_base + SYSCIER);
+
+	rcar_power_on_force();
 }
 
 static struct syscore_ops rcar_sysc_syscore_ops = {
@@ -356,6 +414,7 @@ static int __init rcar_sysc_pd_init(void)
 	void __iomem *base;
 	unsigned int i;
 	int error;
+	const struct soc_device_attribute *attr;
 
 	if (rcar_sysc_base)
 		return 0;
@@ -375,6 +434,10 @@ static int __init rcar_sysc_pd_init(void)
 	has_cpg_mstp = of_find_compatible_node(NULL, NULL,
 					       "renesas,cpg-mstp-clocks");
 
+	attr = soc_device_match(rcar_sysc_quirks_match);
+	if (attr)
+		rcar_sysc_quirks = (uintptr_t)attr->data;
+
 	base = of_iomap(np, 0);
 	if (!base) {
 		pr_warn("%pOF: Cannot map regs\n", np);
@@ -439,11 +502,15 @@ static int __init rcar_sysc_pd_init(void)
 		pd->ch.isr_bit = area->isr_bit;
 		pd->flags = area->flags;
 
+		if (rcar_sysc_quirks & BIT(pd->ch.isr_bit))
+			pd->flags |= PD_NO_CR;
+
 		error = rcar_sysc_pd_setup(pd);
 		if (error)
 			goto out_put;
 
 		domains->domains[area->isr_bit] = &pd->genpd;
+		rcar_domains[i] = pd;
 	}
 
 	/*
@@ -462,6 +529,8 @@ static int __init rcar_sysc_pd_init(void)
 				area->name, area->parent);
 	}
 
+	rcar_power_on_force();
+
 	error = of_genpd_add_provider_onecell(np, &domains->onecell_data);
 
 #ifdef CONFIG_PM_SLEEP
-- 
2.17.1


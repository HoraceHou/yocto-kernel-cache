From c8b8c80aaa65c045a47394f00fb88077516c28e8 Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Thu, 27 Sep 2018 14:53:18 +0900
Subject: [PATCH 334/909] drm: rcar-du: Add dual-link mode support

commit 0293106e6497e0d8a363136671f4a6932856d41c from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../bindings/display/bridge/renesas,lvds.txt  |   3 +-
 drivers/gpu/drm/rcar-du/rcar_lvds.c           | 233 ++++++++++++++++--
 2 files changed, 208 insertions(+), 28 deletions(-)

diff --git a/Documentation/devicetree/bindings/display/bridge/renesas,lvds.txt b/Documentation/devicetree/bindings/display/bridge/renesas,lvds.txt
index 32f5c427c78b..eb4d127ce8f5 100644
--- a/Documentation/devicetree/bindings/display/bridge/renesas,lvds.txt
+++ b/Documentation/devicetree/bindings/display/bridge/renesas,lvds.txt
@@ -26,7 +26,8 @@ Required properties:
   - On R8A77990 and R8A77995, the LVDS encoder can use the EXTAL or
     DU_DOTCLKINx clocks. Those clocks are optional. When supplied they must be
     named "extal" and "dclkin.x" respectively, with "x" being the DU_DOTCLKIN
-    numerical index.
+    numerical index. In addition, dual-link mode is supported. specify
+    mode = "dual-link" in dts file when enabling.
   - When the clocks property only contains the functional clock, the
     clock-names property may be omitted.
 - resets: A phandle + reset specifier for the module reset
diff --git a/drivers/gpu/drm/rcar-du/rcar_lvds.c b/drivers/gpu/drm/rcar-du/rcar_lvds.c
index 29b2707ce2c1..03a74fa7e6ab 100644
--- a/drivers/gpu/drm/rcar-du/rcar_lvds.c
+++ b/drivers/gpu/drm/rcar-du/rcar_lvds.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/of.h>
@@ -36,6 +37,11 @@ enum rcar_lvds_mode {
 	RCAR_LVDS_MODE_VESA = 4,
 };
 
+enum rcar_lvds_link_mode {
+	RCAR_LVDS_SINGLE = 0,
+	RCAR_LVDS_DUAL,
+};
+
 #define RCAR_LVDS_QUIRK_LANES		BIT(0)	/* LVDS lanes 1 and 3 inverted */
 #define RCAR_LVDS_QUIRK_GEN3_LVEN	BIT(1)	/* LVEN bit needs to be set on R8A77970/R8A7799x */
 #define RCAR_LVDS_QUIRK_PWD		BIT(2)	/* PWD bit available (all of Gen3 but E3) */
@@ -69,6 +75,7 @@ struct rcar_lvds {
 
 	struct drm_display_mode display_mode;
 	enum rcar_lvds_mode mode;
+	enum rcar_lvds_link_mode link_mode;
 	u32 id;
 };
 
@@ -350,6 +357,9 @@ static void rcar_lvds_pll_setup_d3_e3(struct rcar_lvds *lvds, unsigned int freq)
 		lvdpllcr |= LVDPLLCR_STP_CLKOUTE | LVDPLLCR_OUTCLKSEL
 			 |  LVDPLLCR_PLLE(pll.pll_e - 1);
 
+	/* Wait 200us until pll-lock */
+	usleep_range(200, 250);
+
 	rcar_lvds_write(lvds, LVDPLLCR, lvdpllcr);
 
 	if (pll.div > 1)
@@ -359,6 +369,75 @@ static void rcar_lvds_pll_setup_d3_e3(struct rcar_lvds *lvds, unsigned int freq)
 		rcar_lvds_write(lvds, LVDDIV, 0);
 }
 
+static void rcar_lvds_dual_mode(struct rcar_lvds *lvds0,
+				struct rcar_lvds *lvds1)
+{
+	u32 lvdcr0 = 0, lvdcr1 = 0, lvdhcr;
+	u32 lvdcr0_lvres, lvdcr1_lvres;
+
+	lvdcr0_lvres = rcar_lvds_read(lvds0, LVDCR0) & LVDCR0_LVRES;
+	lvdcr1_lvres = rcar_lvds_read(lvds1, LVDCR0) & LVDCR0_LVRES;
+
+	if (lvdcr0_lvres && lvdcr1_lvres)
+		return;
+
+	lvdhcr = LVDCHCR_CHSEL_CH(0, 0) | LVDCHCR_CHSEL_CH(1, 1) |
+		 LVDCHCR_CHSEL_CH(2, 2) | LVDCHCR_CHSEL_CH(3, 3);
+
+	rcar_lvds_write(lvds0, LVDCTRCR, LVDCTRCR_CTR3SEL_ZERO |
+			LVDCTRCR_CTR2SEL_DISP | LVDCTRCR_CTR1SEL_VSYNC |
+			LVDCTRCR_CTR0SEL_HSYNC);
+	rcar_lvds_write(lvds0, LVDCHCR, lvdhcr);
+	rcar_lvds_write(lvds0, LVDSTRIPE, LVDSTRIPE_ST_ON);
+
+	rcar_lvds_write(lvds1, LVDCTRCR, LVDCTRCR_CTR3SEL_ZERO |
+			LVDCTRCR_CTR2SEL_DISP | LVDCTRCR_CTR1SEL_VSYNC |
+			LVDCTRCR_CTR0SEL_HSYNC);
+	rcar_lvds_write(lvds1, LVDCHCR, lvdhcr);
+	rcar_lvds_write(lvds1, LVDSTRIPE, LVDSTRIPE_ST_ON);
+
+	/* Turn all the channels on. */
+	rcar_lvds_write(lvds0, LVDCR1,
+			LVDCR1_CHSTBY(3) | LVDCR1_CHSTBY(2) |
+			LVDCR1_CHSTBY(1) | LVDCR1_CHSTBY(0) | LVDCR1_CLKSTBY);
+	rcar_lvds_write(lvds1, LVDCR1,
+			LVDCR1_CHSTBY(3) | LVDCR1_CHSTBY(2) |
+			LVDCR1_CHSTBY(1) | LVDCR1_CHSTBY(0) | LVDCR1_CLKSTBY);
+
+	/*
+	 * Turn the PLL on, set it to LVDS normal mode, wait for the startup
+	 * delay and turn the output on.
+	 */
+	if ((lvds0->info->quirks & RCAR_LVDS_QUIRK_PWD) ||
+	    (lvds1->info->quirks & RCAR_LVDS_QUIRK_PWD)) {
+		lvdcr0 |= LVDCR0_PWD;
+		rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+
+		lvdcr1 |= LVDCR0_PWD;
+		rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+
+		lvdcr1 |= LVDCR0_LVEN | LVDCR0_LVRES;
+		rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+
+		lvdcr0 |= LVDCR0_LVEN | LVDCR0_LVRES;
+		rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+
+		return;
+	}
+
+	lvdcr0 |= LVDCR0_LVEN;
+	rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+
+	lvdcr1 |= LVDCR0_LVEN;
+	rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+
+	lvdcr1 |= LVDCR0_LVRES;
+	rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+
+	lvdcr0 |= LVDCR0_LVRES;
+	rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+}
+
 /* -----------------------------------------------------------------------------
  * Bridge
  */
@@ -378,6 +457,22 @@ static void rcar_lvds_enable(struct drm_bridge *bridge)
 
 	WARN_ON(lvds->enabled);
 
+	if ((lvds->info->quirks & RCAR_LVDS_QUIRK_DUAL_LINK) &&
+	    lvds->link_mode == RCAR_LVDS_DUAL) {
+		struct rcar_lvds *lvds0;
+		struct rcar_lvds *lvds1;
+
+		if (!g_lvds[0] || !g_lvds[1])
+			return;
+
+		lvds0 = g_lvds[0];
+		lvds1 = g_lvds[1];
+
+		rcar_lvds_dual_mode(lvds0, lvds1);
+
+		goto dual_link;
+	}
+
 	if (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {
 		reset_control_deassert(lvds->rstc);
 		ret = clk_prepare_enable(lvds->clocks.mod);
@@ -406,11 +501,6 @@ static void rcar_lvds_enable(struct drm_bridge *bridge)
 
 	rcar_lvds_write(lvds, LVDCHCR, lvdhcr);
 
-	if (lvds->info->quirks & RCAR_LVDS_QUIRK_DUAL_LINK) {
-		/* Disable dual-link mode. */
-		rcar_lvds_write(lvds, LVDSTRIPE, 0);
-	}
-
 	/* PLL clock configuration. */
 	if (lvds->info->pll_setup)
 		lvds->info->pll_setup(lvds, mode->clock * 1000);
@@ -462,6 +552,7 @@ static void rcar_lvds_enable(struct drm_bridge *bridge)
 	lvdcr0 |= LVDCR0_LVRES;
 	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
 
+dual_link:
 	if (lvds->panel) {
 		drm_panel_prepare(lvds->panel);
 		drm_panel_enable(lvds->panel);
@@ -482,30 +573,78 @@ static void __rcar_lvds_disable(struct drm_bridge *bridge)
 		drm_panel_unprepare(lvds->panel);
 	}
 
-	lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_LVRES;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+	if (lvds->info->quirks & RCAR_LVDS_QUIRK_DUAL_LINK &&
+	    lvds->link_mode == RCAR_LVDS_DUAL) {
+		struct rcar_lvds *lvds_pair;
+		struct rcar_lvds *lvds0;
+		struct rcar_lvds *lvds1;
+		u32 id;
 
-	if (lvds->info->quirks & RCAR_LVDS_QUIRK_GEN3_LVEN) {
-		lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_LVEN;
-		rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-	}
+		if (!g_lvds[0] || !g_lvds[1])
+			return;
 
-	if (lvds->info->quirks & RCAR_LVDS_QUIRK_PWD) {
-		lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_PWD;
-		rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-	}
+		lvds0 = g_lvds[0];
+		lvds1 = g_lvds[1];
 
-	if (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {
-		lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_PLLON;
+		id = lvds->id == 0 ? 1 : 0;
+		lvds_pair = g_lvds[id];
+
+		if (!lvds_pair->enabled) {
+			u32 lvdcr0 = 0, lvdcr1 = 0;
+
+			lvdcr0 = rcar_lvds_read(lvds0, LVDCR0) & ~LVDCR0_LVRES;
+			rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+			lvdcr1 = rcar_lvds_read(lvds1, LVDCR0) & ~LVDCR0_LVRES;
+			rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+
+			lvdcr0 = rcar_lvds_read(lvds0, LVDCR0) & ~LVDCR0_LVEN;
+			rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+			lvdcr1 = rcar_lvds_read(lvds1, LVDCR0) & ~LVDCR0_LVEN;
+			rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+
+			if (lvds->info->quirks & RCAR_LVDS_QUIRK_PWD) {
+				lvdcr0 = rcar_lvds_read(lvds0, LVDCR0)
+							& ~LVDCR0_PWD;
+				rcar_lvds_write(lvds0, LVDCR0, lvdcr0);
+				lvdcr1 = rcar_lvds_read(lvds1, LVDCR0)
+							& ~LVDCR0_PWD;
+				rcar_lvds_write(lvds1, LVDCR0, lvdcr1);
+			}
+			rcar_lvds_write(lvds0, LVDCR1, 0);
+			rcar_lvds_write(lvds1, LVDCR1, 0);
+			rcar_lvds_write(lvds0, LVDPLLCR, 0);
+			rcar_lvds_write(lvds1, LVDPLLCR, 0);
+
+			clk_disable_unprepare(lvds0->clocks.mod);
+			clk_disable_unprepare(lvds1->clocks.mod);
+			reset_control_assert(lvds0->rstc);
+			reset_control_assert(lvds1->rstc);
+		}
+	} else {
+		lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_LVRES;
 		rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-	}
 
-	rcar_lvds_write(lvds, LVDCR1, 0);
-	rcar_lvds_write(lvds, LVDPLLCR, 0);
+		if (lvds->info->quirks & RCAR_LVDS_QUIRK_GEN3_LVEN) {
+			lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_LVEN;
+			rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+		}
 
-	clk_disable_unprepare(lvds->clocks.mod);
+		if (lvds->info->quirks & RCAR_LVDS_QUIRK_PWD) {
+			lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_PWD;
+			rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+		}
+
+		if (!(lvds->info->quirks & RCAR_LVDS_QUIRK_EXT_PLL)) {
+			lvdcr0 = rcar_lvds_read(lvds, LVDCR0) & ~LVDCR0_PLLON;
+			rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+		}
 
-	reset_control_assert(lvds->rstc);
+		rcar_lvds_write(lvds, LVDCR1, 0);
+		rcar_lvds_write(lvds, LVDPLLCR, 0);
+
+		clk_disable_unprepare(lvds->clocks.mod);
+		reset_control_assert(lvds->rstc);
+	}
 
 	lvds->enabled = false;
 }
@@ -648,6 +787,7 @@ static int rcar_lvds_parse_dt(struct rcar_lvds *lvds)
 	bool is_bridge = false;
 	int ret = 0;
 	u32 id;
+	const char *str;
 
 	local_output = of_graph_get_endpoint_by_regs(lvds->dev->of_node, 1, 0);
 	if (!local_output) {
@@ -703,6 +843,15 @@ static int rcar_lvds_parse_dt(struct rcar_lvds *lvds)
 	else
 		lvds->id = 0;
 
+	if (!of_property_read_string(lvds->dev->of_node, "mode", &str)) {
+		if (!strcmp(str, "dual-link"))
+			lvds->link_mode = RCAR_LVDS_DUAL;
+		else
+			lvds->link_mode = RCAR_LVDS_SINGLE;
+	} else {
+		lvds->link_mode = RCAR_LVDS_SINGLE;
+	}
+
 done:
 	of_node_put(local_output);
 	of_node_put(remote_input);
@@ -727,11 +876,41 @@ int rcar_lvds_pll_round_rate(u32 index, unsigned long rate)
 	if (rate == 0) {
 		__rcar_lvds_disable(&lvds->bridge);
 	} else {
-		reset_control_deassert(lvds->rstc);
-		ret = clk_prepare_enable(lvds->clocks.mod);
-		if (ret < 0)
-			return ret;
-		rcar_lvds_pll_setup_d3_e3(lvds, rate);
+		if ((lvds->info->quirks & RCAR_LVDS_QUIRK_DUAL_LINK) &&
+		    lvds->link_mode == RCAR_LVDS_DUAL) {
+			bool enable;
+			struct rcar_lvds *lvds0;
+			struct rcar_lvds *lvds1;
+
+			if (!g_lvds[0] || !g_lvds[1])
+				return 0;
+
+			lvds0 = g_lvds[0];
+			lvds1 = g_lvds[1];
+
+			enable = __clk_is_enabled(lvds->clocks.mod);
+			if (enable)
+				goto skip;
+
+			reset_control_deassert(lvds0->rstc);
+			reset_control_deassert(lvds1->rstc);
+
+			ret = clk_prepare_enable(lvds0->clocks.mod);
+			if (ret < 0)
+				return ret;
+
+			ret = clk_prepare_enable(lvds1->clocks.mod);
+			if (ret < 0)
+				return ret;
+skip:
+			rcar_lvds_pll_setup_d3_e3(lvds, rate);
+		} else {
+			reset_control_deassert(lvds->rstc);
+			ret = clk_prepare_enable(lvds->clocks.mod);
+			if (ret < 0)
+				return ret;
+			rcar_lvds_pll_setup_d3_e3(lvds, rate);
+		}
 	}
 
 	return 0;
-- 
2.17.1


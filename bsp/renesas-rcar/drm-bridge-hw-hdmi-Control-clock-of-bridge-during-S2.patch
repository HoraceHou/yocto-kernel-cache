From ccd7b7927ad1e8510718913d45087b5817ed0f71 Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Fri, 24 Aug 2018 19:01:42 +0900
Subject: [PATCH 302/909] drm/bridge: hw-hdmi: Control clock of bridge during
 S2RAM

commit 02b6acf4089e00b0e90e268192147255e6bafca9 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

This patch helps to control the clocks of
bridge/hw-hdmi during system suspend/resume.

Currently, "hdmi" clock is enabled when the DU driver
is enabled but it is not disabled at system suspend.

So, when the system resumes the software state (enabled)
and hardware (disabled) of clock are not matched.
And it makes the system resume fails.

This patches is necessary to synchronize software
and hardware state of clock when backup/restore code
of clock (CPG module) is removed.

In addtion, the procedure for enabling hot plug is added.

Reported-by: Dien Pham <dien.pham.ry@renesas.com>
Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/bridge/synopsys/dw-hdmi.c | 35 +++++++++++++++++++++++
 include/drm/bridge/dw_hdmi.h              |  1 +
 2 files changed, 36 insertions(+)

diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
index 3c136f2b954f..3c0e3b595372 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
@@ -2033,6 +2033,41 @@ static void dw_hdmi_bridge_enable(struct drm_bridge *bridge)
 	mutex_unlock(&hdmi->mutex);
 }
 
+/*
+ * This function controls clocks of dw_hdmi through drm_bridge
+ * at system suspend/resume.
+ * Arguments:
+ *  bridge: drm_bridge that contains dw_hdmi.
+ *  flag: controlled flag.
+ *		false: is used when suspend.
+ *		true: is used when resume.
+ */
+void dw_hdmi_s2r_ctrl(struct drm_bridge *bridge, int flag)
+{
+	struct dw_hdmi *hdmi = bridge->driver_private;
+
+	if (!hdmi)
+		return;
+
+	if (flag) { /* enable clk */
+		if (hdmi->isfr_clk)
+			clk_prepare_enable(hdmi->isfr_clk);
+		if (hdmi->iahb_clk)
+			clk_prepare_enable(hdmi->iahb_clk);
+
+		initialize_hdmi_ih_mutes(hdmi);
+		dw_hdmi_setup_i2c(hdmi);
+		dw_hdmi_i2c_init(hdmi);
+		dw_hdmi_phy_setup_hpd(hdmi, NULL);
+	} else { /* disable clk */
+		if (hdmi->isfr_clk)
+			clk_disable_unprepare(hdmi->isfr_clk);
+		if (hdmi->iahb_clk)
+			clk_disable_unprepare(hdmi->iahb_clk);
+	}
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_s2r_ctrl);
+
 static const struct drm_bridge_funcs dw_hdmi_bridge_funcs = {
 	.attach = dw_hdmi_bridge_attach,
 	.enable = dw_hdmi_bridge_enable,
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index ccb5aa8468e0..8b9741948f7d 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -161,6 +161,7 @@ void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
 void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address);
 void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
 			   unsigned char addr);
+void dw_hdmi_s2r_ctrl(struct drm_bridge *bridge, int flag);
 
 void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable);
 void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable);
-- 
2.17.1


From 031bae0dfc514ab9822e3f060a92edc0644fd0e2 Mon Sep 17 00:00:00 2001
From: Hien Dang <hien.dang.eb@renesas.com>
Date: Tue, 21 Nov 2017 14:55:06 +0700
Subject: [PATCH 163/909] thermal: rcar_gen3_thermal: Use FUSE values if they
 are available

commit fe7d0d1c77f9bd6f77930cd68273ac880a30aa87 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

FUSE values are required for temperature calculation.
Currently, they are missing so pseudo values are used.
However, if they are available, the values should be fetched
from registers.

THSCP.COR_PARA_VLD[1:0] is used to check whether FUSE values
are available or not.

When COR_PARA_VLD[1:0] = b'11, it uses hardware FUSE values,
pseudo fixed ones otherwise.

Signed-off-by: Dien Pham <dien.pham.ry@renesas.com>
Signed-off-by: Hien Dang <hien.dang.eb@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/thermal/rcar_gen3_thermal.c | 46 ++++++++++++++++++++++++++++-
 1 file changed, 45 insertions(+), 1 deletion(-)

diff --git a/drivers/thermal/rcar_gen3_thermal.c b/drivers/thermal/rcar_gen3_thermal.c
index 766521eb7071..89cd8e9bbfda 100644
--- a/drivers/thermal/rcar_gen3_thermal.c
+++ b/drivers/thermal/rcar_gen3_thermal.c
@@ -44,6 +44,14 @@
 #define REG_GEN3_THCODE2	0x54
 #define REG_GEN3_THCODE3	0x58
 
+/* FUSE register base and offsets */
+#define PTAT_BASE               0xE6198000
+#define REG_GEN3_PTAT1          0x5C
+#define REG_GEN3_PTAT2          0x60
+#define REG_GEN3_PTAT3          0x64
+#define REG_GEN3_THSCP          0x68
+#define REG_GEN3_MAX_SIZE       (REG_GEN3_THSCP + 0x4)
+
 /* IRQ{STR,MSK,EN} bits */
 #define IRQ_TEMP1		BIT(0)
 #define IRQ_TEMP2		BIT(1)
@@ -52,6 +60,9 @@
 #define IRQ_TEMPD2		BIT(4)
 #define IRQ_TEMPD3		BIT(5)
 
+/* THSCP bit */
+#define COR_PARA_VLD            (0x3 << 14)
+
 /* CTSR bits */
 #define CTSR_PONM	BIT(8)
 #define CTSR_AOUT	BIT(7)
@@ -352,9 +363,10 @@ static int rcar_gen3_thermal_probe(struct platform_device *pdev)
 	struct thermal_zone_device *zone;
 	int ret, irq, i;
 	char *irqname;
+	void __iomem *ptat_base;
+	unsigned int cor_para_value;
 
 	/* default values if FUSEs are missing */
-	/* TODO: Read values from hardware on supported platforms */
 	int ptat[3] = { 2631, 1509, 435 };
 	int thcode[TSC_MAX_NUM][3] = {
 		{ 3397, 2800, 2221 },
@@ -362,6 +374,28 @@ static int rcar_gen3_thermal_probe(struct platform_device *pdev)
 		{ 3389, 2805, 2237 },
 	};
 
+	/* Use FUSE default values if they are missing.
+	 * If not, fetch them from registers.
+	 */
+	ptat_base = ioremap_nocache(PTAT_BASE, REG_GEN3_MAX_SIZE);
+	if (!ptat_base) {
+		dev_err(dev, "Cannot map FUSE register\n");
+		return -ENOMEM;
+	}
+
+	cor_para_value = ioread32(ptat_base + REG_GEN3_THSCP) & COR_PARA_VLD;
+
+	if (cor_para_value != COR_PARA_VLD) {
+		dev_info(dev, "is using pseudo fixed FUSE values\n");
+	} else {
+		dev_info(dev, "is using FUSE values\n");
+		ptat[0] = ioread32(ptat_base + REG_GEN3_PTAT1) & GEN3_FUSE_MASK;
+		ptat[1] = ioread32(ptat_base + REG_GEN3_PTAT2) & GEN3_FUSE_MASK;
+		ptat[2] = ioread32(ptat_base + REG_GEN3_PTAT3) & GEN3_FUSE_MASK;
+	}
+
+	iounmap(ptat_base);
+
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -421,6 +455,16 @@ static int rcar_gen3_thermal_probe(struct platform_device *pdev)
 		priv->tscs[i] = tsc;
 
 		priv->thermal_init(tsc);
+
+		if (cor_para_value == COR_PARA_VLD) {
+			thcode[i][0] = GEN3_FUSE_MASK &
+				rcar_gen3_thermal_read(tsc, REG_GEN3_THCODE1);
+			thcode[i][1] = GEN3_FUSE_MASK &
+				rcar_gen3_thermal_read(tsc, REG_GEN3_THCODE2);
+			thcode[i][2] = GEN3_FUSE_MASK &
+				rcar_gen3_thermal_read(tsc, REG_GEN3_THCODE3);
+		}
+
 		rcar_gen3_thermal_calc_coefs(&tsc->coef, ptat, thcode[i]);
 
 		zone = devm_thermal_zone_of_sensor_register(dev, i, tsc,
-- 
2.17.1


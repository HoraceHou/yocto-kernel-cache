From 79751f5c0bf180a99ea27feb6b3e23b6cf88aa09 Mon Sep 17 00:00:00 2001
From: Hai Nguyen Pham <hai.pham.ud@renesas.com>
Date: Mon, 26 Nov 2018 14:50:20 +0700
Subject: [PATCH 407/909] iommu/ipmmu-vmsa: Whitelist devices for r8a77965

commit 84f1548ebe77070aec643797f24e0cdb4998fae9 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

This adds whitelist devices support for r8a77965 (R-Car M3N)

- For unsupported R-Car Gen3 SoCs, IPMMU will probe error.
- For unsupported IPMMU cache devices or unsupported master devices,
IPMMU will not do address translation.

Signed-off-by: Hai Nguyen Pham <hai.pham.ud@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/iommu/ipmmu-vmsa-whitelist.h | 48 ++++++++++++++++++++++++++++
 drivers/iommu/ipmmu-vmsa.c           | 47 +++++++++++++++++++++++++++
 2 files changed, 95 insertions(+)

diff --git a/drivers/iommu/ipmmu-vmsa-whitelist.h b/drivers/iommu/ipmmu-vmsa-whitelist.h
index 413435cb89c8..67f5567a3546 100644
--- a/drivers/iommu/ipmmu-vmsa-whitelist.h
+++ b/drivers/iommu/ipmmu-vmsa-whitelist.h
@@ -236,6 +236,54 @@
 				 M_SYS_DMAC_46 | M_SYS_DMAC_47 | \
 				 M_SDHI0 | M_SDHI1 | M_SDHI2 | M_SDHI3)
 
+/* Support masters for r8a77965 */
+#define M3N_IPMMU_VI0_MASTER	(M_VIN_0_3 | M_VIN_4_7 | M_FCPVD_0 | M_FCPVD_1)
+#define M3N_IPMMU_HC_MASTER	(M_PCIE_0 | M_PCIE_1 | M_SATA | M_USB2H_0 | \
+				 M_USB_DMAC_0 | M_USB_DMAC_1 | M_USB3H_0 | \
+				 M_USB3F_0)
+#define M3N_IPMMU_MP_MASTER	(M_AUDIO_DMAC_0 | M_AUDIO_DMAC_1 | \
+				 M_AUDIO_DMAC_2 | M_AUDIO_DMAC_3 | \
+				 M_AUDIO_DMAC_4 | M_AUDIO_DMAC_5 | \
+				 M_AUDIO_DMAC_6 | M_AUDIO_DMAC_7 | \
+				 M_AUDIO_DMAC_8 | M_AUDIO_DMAC_9 | \
+				 M_AUDIO_DMAC_10 | M_AUDIO_DMAC_11 | \
+				 M_AUDIO_DMAC_12 | M_AUDIO_DMAC_13 | \
+				 M_AUDIO_DMAC_14 | M_AUDIO_DMAC_15 | \
+				 M_AUDIO_DMAC_16 | M_AUDIO_DMAC_17 | \
+				 M_AUDIO_DMAC_18 | M_AUDIO_DMAC_19 | \
+				 M_AUDIO_DMAC_20 | M_AUDIO_DMAC_21 | \
+				 M_AUDIO_DMAC_22 | M_AUDIO_DMAC_23 | \
+				 M_AUDIO_DMAC_24 | M_AUDIO_DMAC_25 | \
+				 M_AUDIO_DMAC_16 | M_AUDIO_DMAC_27 | \
+				 M_AUDIO_DMAC_28 | M_AUDIO_DMAC_29 | \
+				 M_AUDIO_DMAC_30 | M_AUDIO_DMAC_31)
+#define M3N_IPMMU_DS0_MASTER	(M_SYS_DMAC_0 | M_SYS_DMAC_1 | \
+				 M_SYS_DMAC_2 | M_SYS_DMAC_3 | \
+				 M_SYS_DMAC_4 | M_SYS_DMAC_5 | \
+				 M_SYS_DMAC_6 | M_SYS_DMAC_7 | \
+				 M_SYS_DMAC_8 | M_SYS_DMAC_9 | \
+				 M_SYS_DMAC_10 | M_SYS_DMAC_11 | \
+				 M_SYS_DMAC_12 | M_SYS_DMAC_13 | \
+				 M_SYS_DMAC_14 | M_SYS_DMAC_15 | \
+				 M_ETHERNET)
+#define M3N_IPMMU_DS1_MASTER	(M_SYS_DMAC_16 | M_SYS_DMAC_17 | \
+				 M_SYS_DMAC_18 | M_SYS_DMAC_19 | \
+				 M_SYS_DMAC_20 | M_SYS_DMAC_21 | \
+				 M_SYS_DMAC_22 | M_SYS_DMAC_23 | \
+				 M_SYS_DMAC_24 | M_SYS_DMAC_25 | \
+				 M_SYS_DMAC_26 | M_SYS_DMAC_27 | \
+				 M_SYS_DMAC_28 | M_SYS_DMAC_29 | \
+				 M_SYS_DMAC_30 | M_SYS_DMAC_31 | \
+				 M_SYS_DMAC_32 | M_SYS_DMAC_33 | \
+				 M_SYS_DMAC_34 | M_SYS_DMAC_35 | \
+				 M_SYS_DMAC_36 | M_SYS_DMAC_37 | \
+				 M_SYS_DMAC_38 | M_SYS_DMAC_39 | \
+				 M_SYS_DMAC_40 | M_SYS_DMAC_41 | \
+				 M_SYS_DMAC_42 | M_SYS_DMAC_43 | \
+				 M_SYS_DMAC_44 | M_SYS_DMAC_45 | \
+				 M_SYS_DMAC_46 | M_SYS_DMAC_47 | \
+				 M_SDHI0 | M_SDHI1 | M_SDHI2 | M_SDHI3)
+
 struct ipmmu_whitelist {
 	 const char *ipmmu_name;
 	 unsigned int base_addr;
diff --git a/drivers/iommu/ipmmu-vmsa.c b/drivers/iommu/ipmmu-vmsa.c
index e8f2a479a34e..2bc36d157e76 100644
--- a/drivers/iommu/ipmmu-vmsa.c
+++ b/drivers/iommu/ipmmu-vmsa.c
@@ -207,6 +207,46 @@ static struct ipmmu_whitelist *r8a7796_whitelist[] = {
 	&r8a7796_ipmmu_ds1,
 	NULL, /* Terminator */
 };
+
+/* R-Car M3N (R8A77965) */
+static struct ipmmu_whitelist r8a77965_ipmmu_vi0 = {
+	.ipmmu_name	= "febd0000.mmu",
+	.base_addr	= IPMMU_VI0_BASE,
+	.ip_masters	= M3N_IPMMU_VI0_MASTER,
+};
+
+static struct ipmmu_whitelist r8a77965_ipmmu_hc = {
+	.ipmmu_name	= "e6570000.mmu",
+	.base_addr	= IPMMU_HC_BASE,
+	.ip_masters	= M3N_IPMMU_HC_MASTER,
+};
+
+static struct ipmmu_whitelist r8a77965_ipmmu_mp = {
+	.ipmmu_name	= "ec670000.mmu",
+	.base_addr	= IPMMU_MP_BASE,
+	.ip_masters	= M3N_IPMMU_MP_MASTER,
+};
+
+static struct ipmmu_whitelist r8a77965_ipmmu_ds0 = {
+	.ipmmu_name	= "e6740000.mmu",
+	.base_addr	= IPMMU_DS0_BASE,
+	.ip_masters	= M3N_IPMMU_DS0_MASTER,
+};
+
+static struct ipmmu_whitelist r8a77965_ipmmu_ds1 = {
+	.ipmmu_name	= "e7740000.mmu",
+	.base_addr	= IPMMU_DS1_BASE,
+	.ip_masters	= M3N_IPMMU_DS1_MASTER,
+};
+
+static struct ipmmu_whitelist *r8a77965_whitelist[] = {
+	&r8a77965_ipmmu_vi0,
+	&r8a77965_ipmmu_hc,
+	&r8a77965_ipmmu_mp,
+	&r8a77965_ipmmu_ds0,
+	&r8a77965_ipmmu_ds1,
+	NULL, /* Terminator */
+};
 #endif /* CONFIG_IPMMU_VMSA_WHITELIST */
 
 #define TLB_LOOP_TIMEOUT		100	/* 100us */
@@ -1060,6 +1100,11 @@ static const struct soc_device_attribute r8a7796[]  = {
 	{ .soc_id = "r8a7796" },
 	{ /* sentinel */ }
 };
+
+static const struct soc_device_attribute r8a77965[]  = {
+	{ .soc_id = "r8a77965" },
+	{ /* sentinel */ }
+};
 #endif /* CONFIG_IPMMU_VMSA_WHITELIST */
 
 static int ipmmu_of_xlate(struct device *dev,
@@ -1357,6 +1402,8 @@ static int ipmmu_whitelist_init(struct ipmmu_vmsa_device *mmu)
 		mmu->whitelist = r8a7795_whitelist;
 	else if (soc_device_match(r8a7796))
 		mmu->whitelist = r8a7796_whitelist;
+	else if (soc_device_match(r8a77965))
+		mmu->whitelist = r8a77965_whitelist;
 	else
 		mmu->whitelist = NULL;
 
-- 
2.17.1


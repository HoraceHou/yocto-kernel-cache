From a81c70720ccef07e1f9d86b2c291fd6775b8602f Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Wed, 5 Sep 2018 17:27:42 +0900
Subject: [PATCH 312/909] drm: rcar-du: Add register access check

commit 87064ac2cbb559fa8a68ed72f7bb6c4427b02087 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

According to latest H/W manual, following register access was
changed. The accessible number of ESCR, OTAR, and DORCR registers
was changed. And SPIM bit of PnMR register specification is changed.
This patch fixes it.

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/rcar-du/rcar_du_drv.c   |  9 ++-
 drivers/gpu/drm/rcar-du/rcar_du_drv.h   |  5 ++
 drivers/gpu/drm/rcar-du/rcar_du_group.c | 75 +++++++++++++++++++++++++
 drivers/gpu/drm/rcar-du/rcar_du_plane.c | 17 +++++-
 4 files changed, 101 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
index 01bacbb46445..49ba401fce47 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
@@ -196,7 +196,8 @@ static const struct rcar_du_device_info rcar_du_r8a7795_info = {
 	.gen = 3,
 	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
 		  | RCAR_DU_FEATURE_EXT_CTRL_REGS
-		  | RCAR_DU_FEATURE_VSP1_SOURCE,
+		  | RCAR_DU_FEATURE_VSP1_SOURCE
+		  | RCAR_DU_FEATURE_R8A7795_REGS,
 	.channels_mask = BIT(3) | BIT(2) | BIT(1) | BIT(0),
 	.routes = {
 		/*
@@ -228,7 +229,8 @@ static const struct rcar_du_device_info rcar_du_r8a7796_info = {
 	.gen = 3,
 	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
 		  | RCAR_DU_FEATURE_EXT_CTRL_REGS
-		  | RCAR_DU_FEATURE_VSP1_SOURCE,
+		  | RCAR_DU_FEATURE_VSP1_SOURCE
+		  | RCAR_DU_FEATURE_R8A7796_REGS,
 	.channels_mask = BIT(2) | BIT(1) | BIT(0),
 	.routes = {
 		/*
@@ -256,7 +258,8 @@ static const struct rcar_du_device_info rcar_du_r8a77965_info = {
 	.gen = 3,
 	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
 		  | RCAR_DU_FEATURE_EXT_CTRL_REGS
-		  | RCAR_DU_FEATURE_VSP1_SOURCE,
+		  | RCAR_DU_FEATURE_VSP1_SOURCE
+		  | RCAR_DU_FEATURE_R8A77965_REGS,
 	.channels_mask = BIT(3) | BIT(1) | BIT(0),
 	.routes = {
 		/*
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index d6346524194f..f0a9edb6a679 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -30,6 +30,11 @@ struct rcar_du_device;
 #define RCAR_DU_FEATURE_CRTC_IRQ_CLOCK	(1 << 0)	/* Per-CRTC IRQ and clock */
 #define RCAR_DU_FEATURE_EXT_CTRL_REGS	(1 << 1)	/* Has extended control registers */
 #define RCAR_DU_FEATURE_VSP1_SOURCE	(1 << 2)	/* Has inputs from VSP1 */
+#define RCAR_DU_FEATURE_R8A7795_REGS	(1 << 3)        /* Use R8A7795 registers */
+#define RCAR_DU_FEATURE_R8A7796_REGS	(1 << 4)        /* Use R8A7796 registers */
+#define RCAR_DU_FEATURE_R8A77965_REGS	(1 << 5)        /* Use R8A77965 registers */
+#define RCAR_DU_FEATURE_R8A77990_REGS	(1 << 6)        /* Use R8A77990 registers */
+#define RCAR_DU_FEATURE_R8A77995_REGS	(1 << 7)        /* Use R8A77995 registers */
 
 #define RCAR_DU_QUIRK_ALIGN_128B	(1 << 0)	/* Align pitches to 128 bytes */
 
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_group.c b/drivers/gpu/drm/rcar-du/rcar_du_group.c
index 62794d61577a..69a95b381518 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_group.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_group.c
@@ -34,13 +34,88 @@
 #include "rcar_du_group.h"
 #include "rcar_du_regs.h"
 
+static bool rcar_du_register_access_check(struct rcar_du_group *rgrp, u32 reg)
+{
+	struct rcar_du_device *rcdu = rgrp->dev;
+
+	/* ESCR register access check */
+	if (reg == ESCR || reg == ESCR2) {
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7795_REGS) ||
+		    rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A77965_REGS)) {
+			if (rgrp->index == 0 && reg == ESCR2)
+				return false;
+			else if (rgrp->index == 1 && reg == ESCR)
+				return false;
+			else
+				return true;
+		}
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7796_REGS)) {
+			if (rgrp->index == 0 && reg == ESCR2)
+				return false;
+			else
+				return true;
+		}
+	}
+
+	/* OTAR register access check */
+	if (reg == OTAR || reg == OTAR2) {
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7795_REGS) ||
+		    rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A77965_REGS)) {
+			if (rgrp->index == 1 && reg == OTAR2)
+				return true;
+			else
+				return false;
+		}
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7796_REGS)) {
+			if (rgrp->index == 1 && reg == OTAR)
+				return true;
+			else
+				return false;
+		}
+	}
+
+	return true;
+}
+
+static u32 rcar_du_register_data_mask(struct rcar_du_group *rgrp, u32 reg)
+{
+	struct rcar_du_device *rcdu = rgrp->dev;
+	u32 mask_data = 0;
+
+	/* Set mask for R1 register */
+	if (reg == DORCR && rgrp->index == 1) {
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7795_REGS) ||
+		    rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7796_REGS) ||
+		    rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A77965_REGS))
+			mask_data = DORCR_PG2T | DORCR_DK2S | DORCR_PG2D_DS2;
+	}
+
+	return mask_data;
+}
+
 u32 rcar_du_group_read(struct rcar_du_group *rgrp, u32 reg)
 {
+	struct rcar_du_device *rcdu = rgrp->dev;
+
+	if (!rcar_du_register_access_check(rgrp, reg)) {
+		dev_warn(rcdu->dev, "reserved register was read\n");
+		return 0;
+	}
+
 	return rcar_du_read(rgrp->dev, rgrp->mmio_offset + reg);
 }
 
 void rcar_du_group_write(struct rcar_du_group *rgrp, u32 reg, u32 data)
 {
+	u32 mask = 0;
+
+	if (!rcar_du_register_access_check(rgrp, reg))
+		return;
+
+	mask = rcar_du_register_data_mask(rgrp, reg);
+	if (mask)
+		data |= mask;
+
 	rcar_du_write(rgrp->dev, rgrp->mmio_offset + reg, data);
 }
 
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_plane.c b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
index 0e881a01450f..8bc36ee9463f 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_plane.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
@@ -506,8 +506,21 @@ static void rcar_du_plane_setup_format_gen3(struct rcar_du_group *rgrp,
 					    unsigned int index,
 					    const struct rcar_du_plane_state *state)
 {
-	rcar_du_plane_write(rgrp, index, PnMR,
-			    PnMR_SPIM_TP_OFF | state->format->pnmr);
+	struct rcar_du_device *rcdu = rgrp->dev;
+
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_R8A7795_REGS)) {
+		rcar_du_plane_write(rgrp, index, PnMR,
+				    PnMR_SPIM_TP_OFF | state->format->pnmr);
+	} else {
+		if (rgrp->index == 0)
+			rcar_du_plane_write(rgrp, index, PnMR,
+					    PnMR_SPIM_TP_OFF |
+					    state->format->pnmr);
+		else
+			rcar_du_plane_write(rgrp, index, PnMR,
+					    PnMR_SPIM_TP_OFF |
+					    PnMR_DDDF_16BPP);
+	}
 
 	rcar_du_plane_write(rgrp, index, PnDDCR4,
 			    state->format->edf | PnDDCR4_CODE);
-- 
2.17.1


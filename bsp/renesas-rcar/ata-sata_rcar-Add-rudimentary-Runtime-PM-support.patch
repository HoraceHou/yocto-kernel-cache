From 60a59cba1ac6ba954b24e7f3763c06693d51c874 Mon Sep 17 00:00:00 2001
From: Geert Uytterhoeven <geert+renesas@glider.be>
Date: Fri, 20 Jul 2018 14:27:39 +0200
Subject: [PATCH 269/909] ata: sata_rcar: Add rudimentary Runtime PM support

commit 1ecd34ddf63ef1d4015da5e5de6881e6845a6b0a upstream

Replace the explicit clock handling to enable/disable the SATA module by
calls to Runtime PM.

This makes the driver independent of actual SoC clock/power hierarchies,
and is needed to support virtualization, where the guest is not in full
control of power management.

Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
Reviewed-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Signed-off-by: Tejun Heo <tj@kernel.org>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/ata/sata_rcar.c | 40 ++++++++++++++++++----------------------
 1 file changed, 18 insertions(+), 22 deletions(-)

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 5233096059c5..c3910e241842 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -17,7 +17,7 @@
 #include <linux/libata.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
-#include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/err.h>
 
 #define DRV_NAME "sata_rcar"
@@ -152,7 +152,6 @@ enum sata_rcar_type {
 
 struct sata_rcar_priv {
 	void __iomem *base;
-	struct clk *clk;
 	enum sata_rcar_type type;
 };
 
@@ -900,21 +899,17 @@ static int sata_rcar_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	priv->type = (enum sata_rcar_type)of_device_get_match_data(dev);
-	priv->clk = devm_clk_get(dev, NULL);
-	if (IS_ERR(priv->clk)) {
-		dev_err(dev, "failed to get access to sata clock\n");
-		return PTR_ERR(priv->clk);
-	}
 
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
-		return ret;
+	pm_runtime_enable(dev);
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		goto err_pm_disable;
 
 	host = ata_host_alloc(dev, 1);
 	if (!host) {
 		dev_err(dev, "ata_host_alloc failed\n");
 		ret = -ENOMEM;
-		goto cleanup;
+		goto err_pm_put;
 	}
 
 	host->private_data = priv;
@@ -923,7 +918,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	priv->base = devm_ioremap_resource(dev, mem);
 	if (IS_ERR(priv->base)) {
 		ret = PTR_ERR(priv->base);
-		goto cleanup;
+		goto err_pm_put;
 	}
 
 	/* setup port */
@@ -937,9 +932,10 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	if (!ret)
 		return 0;
 
-cleanup:
-	clk_disable_unprepare(priv->clk);
-
+err_pm_put:
+	pm_runtime_put(dev);
+err_pm_disable:
+	pm_runtime_disable(dev);
 	return ret;
 }
 
@@ -957,7 +953,8 @@ static int sata_rcar_remove(struct platform_device *pdev)
 	iowrite32(0, base + SATAINTSTAT_REG);
 	iowrite32(0x7ff, base + SATAINTMASK_REG);
 
-	clk_disable_unprepare(priv->clk);
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }
@@ -977,7 +974,7 @@ static int sata_rcar_suspend(struct device *dev)
 		/* mask */
 		iowrite32(0x7ff, base + SATAINTMASK_REG);
 
-		clk_disable_unprepare(priv->clk);
+		pm_runtime_put(dev);
 	}
 
 	return ret;
@@ -990,8 +987,8 @@ static int sata_rcar_resume(struct device *dev)
 	void __iomem *base = priv->base;
 	int ret;
 
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
 		return ret;
 
 	if (priv->type == RCAR_GEN3_SATA) {
@@ -1014,11 +1011,10 @@ static int sata_rcar_resume(struct device *dev)
 static int sata_rcar_restore(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
-	struct sata_rcar_priv *priv = host->private_data;
 	int ret;
 
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
 		return ret;
 
 	sata_rcar_setup_port(host);
-- 
2.17.1


From ac6de5aa1cf75b26af8a5da5ee8315b1b1c2acc5 Mon Sep 17 00:00:00 2001
From: MengLi <meng.li@windriver.com>
Date: Tue, 9 Jul 2019 17:37:14 +0800
Subject: [PATCH 907/909] driver: thermal: register interrupt handler after
 device initialization

When run kdump feature, the second kernel will hang when call the
probe function thermal driver. Because the interrupt of thermal deivce
is in enable status and generate meaningless interrupt continuously
when the second kernel boots up. If the interrupt handler is registered
before device initialization, interrupt handler is invoked continuously,
and the cause kernel hang.
Therefore, it is need to do device initialization that includes
interrupt mask operation firstly, and then register ISR. At last, enable
device interrupt.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/thermal/rcar_gen3_thermal.c | 44 ++++++++++++++---------------
 1 file changed, 22 insertions(+), 22 deletions(-)

diff --git a/drivers/thermal/rcar_gen3_thermal.c b/drivers/thermal/rcar_gen3_thermal.c
index ae17e73d770b..65aedf0b088e 100644
--- a/drivers/thermal/rcar_gen3_thermal.c
+++ b/drivers/thermal/rcar_gen3_thermal.c
@@ -600,28 +600,6 @@ static int rcar_gen3_thermal_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, priv);
 
-	/*
-	 * Request 2 (of the 3 possible) IRQs, the driver only needs to
-	 * to trigger on the low and high trip points of the current
-	 * temp window at this point.
-	 */
-	for (i = 0; i < 2; i++) {
-		irq = platform_get_irq(pdev, i);
-		if (irq < 0)
-			return irq;
-
-		irqname = devm_kasprintf(dev, GFP_KERNEL, "%s:ch%d",
-					 dev_name(dev), i);
-		if (!irqname)
-			return -ENOMEM;
-
-		ret = devm_request_threaded_irq(dev, irq, rcar_gen3_thermal_irq,
-						rcar_gen3_thermal_irq_thread,
-						IRQF_SHARED, irqname, priv);
-		if (ret)
-			return ret;
-	}
-
 	pm_runtime_enable(dev);
 	pm_runtime_get_sync(dev);
 
@@ -704,6 +682,28 @@ static int rcar_gen3_thermal_probe(struct platform_device *pdev)
 		goto error_unregister;
 	}
 
+	/*
+	 * Request 2 (of the 3 possible) IRQs, the driver only needs to
+	 * to trigger on the low and high trip points of the current
+	 * temp window at this point.
+	 */
+	for (i = 0; i < 2; i++) {
+		irq = platform_get_irq(pdev, i);
+		if (irq < 0)
+			return irq;
+
+		irqname = devm_kasprintf(dev, GFP_KERNEL, "%s:ch%d",
+					 dev_name(dev), i);
+		if (!irqname)
+			return -ENOMEM;
+
+		ret = devm_request_threaded_irq(dev, irq, rcar_gen3_thermal_irq,
+						rcar_gen3_thermal_irq_thread,
+						IRQF_SHARED, irqname, priv);
+		if (ret)
+			return ret;
+	}
+
 	rcar_thermal_irq_set(priv, true);
 
 	return 0;
-- 
2.17.1


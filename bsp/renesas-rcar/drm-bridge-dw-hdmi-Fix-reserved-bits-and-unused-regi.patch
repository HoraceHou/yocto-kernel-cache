From 2906e093f344a813cdbe563262d62161419970e1 Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Thu, 27 Sep 2018 11:40:58 +0900
Subject: [PATCH 329/909] drm: bridge/dw-hdmi: Fix reserved bits and unused
 registers for R-Car

commit d95944dba87f348bb8f2aff6a9922dbcc8142adc from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

When using open source of dw-hdmi in R-Car, Unused registers are
accessed, and reserved bits are set by incorrect value.
This patch fixes it.

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/bridge/synopsys/dw-hdmi.c | 221 ++++++++++++++++++----
 drivers/gpu/drm/bridge/synopsys/dw-hdmi.h |  15 ++
 include/drm/bridge/dw_hdmi.h              |   6 +
 3 files changed, 201 insertions(+), 41 deletions(-)

diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
index 3c0e3b595372..15ea549874f1 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
@@ -1,6 +1,7 @@
 /*
  * DesignWare High-Definition Multimedia Interface (HDMI) driver
  *
+ * Copyright (C) 2018 Renesas Electronics Corporation
  * Copyright (C) 2013-2015 Mentor Graphics Inc.
  * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  * Copyright (C) 2010, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
@@ -224,12 +225,21 @@ static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
 	hdmi_writeb(hdmi, 0x00, HDMI_I2CM_SOFTRSTZ);
 
 	/* Set Standard Mode speed (determined to be 100KHz on iMX6) */
-	hdmi_writeb(hdmi, 0x00, HDMI_I2CM_DIV);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_modb(hdmi, 0x00, HDMI_I2CM_DIV_FAST_STD_MODE_MASK,
+			  HDMI_I2CM_DIV);
+	else
+		hdmi_writeb(hdmi, 0x00, HDMI_I2CM_DIV);
 
 	/* Set done, not acknowledged and arbitration interrupt polarities */
-	hdmi_writeb(hdmi, HDMI_I2CM_INT_DONE_POL, HDMI_I2CM_INT);
-	hdmi_writeb(hdmi, HDMI_I2CM_CTLINT_NAC_POL | HDMI_I2CM_CTLINT_ARB_POL,
-		    HDMI_I2CM_CTLINT);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI) {
+		hdmi_writeb(hdmi, 0, HDMI_I2CM_INT);
+		hdmi_writeb(hdmi, 0, HDMI_I2CM_CTLINT);
+	} else {
+		hdmi_writeb(hdmi, HDMI_I2CM_INT_DONE_POL, HDMI_I2CM_INT);
+		hdmi_writeb(hdmi, HDMI_I2CM_CTLINT_NAC_POL |
+			    HDMI_I2CM_CTLINT_ARB_POL, HDMI_I2CM_CTLINT);
+	}
 
 	/* Clear DONE and ERROR interrupts */
 	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
@@ -856,8 +866,11 @@ static void hdmi_video_csc(struct dw_hdmi *hdmi)
 
 	/* Configure the CSC registers */
 	hdmi_writeb(hdmi, interpolation | decimation, HDMI_CSC_CFG);
-	hdmi_modb(hdmi, color_depth, HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,
-		  HDMI_CSC_SCALE);
+
+	if (hdmi->plat_data->dev_type != RCAR_HDMI)
+		hdmi_modb(hdmi, color_depth,
+			  HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,
+			  HDMI_CSC_SCALE);
 
 	dw_hdmi_update_csc_coeffs(hdmi);
 }
@@ -918,15 +931,18 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 	}
 
 	/* set the packetizer registers */
-	val = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
-		HDMI_VP_PR_CD_COLOR_DEPTH_MASK) |
-		((hdmi_data->pix_repet_factor <<
-		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &
-		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);
-	hdmi_writeb(hdmi, val, HDMI_VP_PR_CD);
+	if (hdmi->plat_data->dev_type != RCAR_HDMI) {
+		val = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
+			HDMI_VP_PR_CD_COLOR_DEPTH_MASK) |
+			((hdmi_data->pix_repet_factor <<
+			HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &
+			HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);
+		hdmi_writeb(hdmi, val, HDMI_VP_PR_CD);
+	}
 
-	hdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,
-		  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);
+	if (hdmi->plat_data->dev_type != RCAR_HDMI)
+		hdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,
+			  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);
 
 	/* Data from pixel repeater block */
 	if (hdmi_data->pix_repet_factor > 1) {
@@ -937,14 +953,20 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 			  HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;
 	}
 
-	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_PR_EN_MASK |
-		  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_modb(hdmi, vp_conf,
+			  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
+	else
+		hdmi_modb(hdmi, vp_conf,
+			  HDMI_VP_CONF_PR_EN_MASK |
+			  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
 
-	hdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,
-		  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);
+	if (hdmi->plat_data->dev_type != RCAR_HDMI)
+		hdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,
+			  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);
 
-	hdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);
+	if (hdmi->plat_data->dev_type != RCAR_HDMI)
+		hdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);
 
 	if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {
 		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
@@ -962,14 +984,24 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 		return;
 	}
 
-	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |
-		  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
-
-	hdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
-			HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
-		  HDMI_VP_STUFF_PP_STUFFING_MASK |
-		  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_modb(hdmi, vp_conf,
+			  HDMI_VP_CONF_BYPASS_EN_MASK |
+			  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
+	else
+		hdmi_modb(hdmi, vp_conf,
+			  HDMI_VP_CONF_BYPASS_EN_MASK |
+			  HDMI_VP_CONF_PP_EN_ENMASK |
+			  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
+
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_writeb(hdmi, HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
+			    HDMI_VP_STUFF);
+	else
+		hdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
+				HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
+			  HDMI_VP_STUFF_PP_STUFFING_MASK |
+			  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);
 
 	hdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,
 		  HDMI_VP_CONF);
@@ -982,6 +1014,9 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 static inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi,
 				       unsigned char bit)
 {
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		return;
+
 	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,
 		  HDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);
 }
@@ -1003,7 +1038,12 @@ static bool hdmi_phy_wait_i2c_done(struct dw_hdmi *hdmi, int msec)
 void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
 			   unsigned char addr)
 {
-	hdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_writeb(hdmi, HDMI_IH_I2CMPHY_STAT0_I2CMPHYDONE |
+			    HDMI_IH_I2CMPHY_STAT0_I2CMPHYERROR,
+			    HDMI_IH_I2CMPHY_STAT0);
+	else
+		hdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);
 	hdmi_writeb(hdmi, addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
 	hdmi_writeb(hdmi, (unsigned char)(data >> 8),
 		    HDMI_PHY_I2CM_DATAO_1_ADDR);
@@ -1017,6 +1057,9 @@ EXPORT_SYMBOL_GPL(dw_hdmi_phy_i2c_write);
 
 static void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)
 {
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		return;
+
 	hdmi_mask_writeb(hdmi, !enable, HDMI_PHY_CONF0,
 			 HDMI_PHY_CONF0_PDZ_OFFSET,
 			 HDMI_PHY_CONF0_PDZ_MASK);
@@ -1024,6 +1067,9 @@ static void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)
 
 static void dw_hdmi_phy_enable_tmds(struct dw_hdmi *hdmi, u8 enable)
 {
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		return;
+
 	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
 			 HDMI_PHY_CONF0_ENTMDS_OFFSET,
 			 HDMI_PHY_CONF0_ENTMDS_MASK);
@@ -1222,7 +1268,9 @@ static int hdmi_phy_configure(struct dw_hdmi *hdmi)
 
 	dw_hdmi_phy_reset(hdmi);
 
-	hdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);
+	if (hdmi->plat_data->dev_type != RCAR_HDMI)
+		hdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT,
+			    HDMI_MC_HEACPHY_RST);
 
 	dw_hdmi_phy_i2c_set_addr(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);
 
@@ -1302,8 +1350,15 @@ void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data)
 	/* Clear and unmute interrupts. */
 	hdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE,
 		    HDMI_IH_PHY_STAT0);
-	hdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE),
-		    HDMI_IH_MUTE_PHY_STAT0);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_writeb(hdmi, (HDMI_IH_MUTE_PHY_STAT0_MASK &
+			    ~(HDMI_IH_PHY_STAT0_HPD |
+			    HDMI_IH_PHY_STAT0_RX_SENSE)),
+			    HDMI_IH_MUTE_PHY_STAT0);
+	else
+		hdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD |
+			    HDMI_IH_PHY_STAT0_RX_SENSE),
+			    HDMI_IH_MUTE_PHY_STAT0);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_phy_setup_hpd);
 
@@ -1671,7 +1726,13 @@ static void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)
 	}
 
 	/* TMDS software reset */
-	hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_modb(hdmi, 0,
+			  HDMI_MC_SWRSTZ_TMDSSWRST_MASK,
+			  HDMI_MC_SWRSTZ);
+	else
+		hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
+			    HDMI_MC_SWRSTZ);
 
 	val = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);
 	for (i = 0; i < count; i++)
@@ -1781,6 +1842,52 @@ static void dw_hdmi_setup_i2c(struct dw_hdmi *hdmi)
 		    HDMI_PHY_I2CM_CTLINT_ADDR);
 }
 
+static void initialize_hdmi_rcar_ih_mutes(struct dw_hdmi *hdmi)
+{
+	u8 ih_mute;
+	/*
+	 * Boot up defaults are:
+	 * HDMI_IH_MUTE   = 0x03 (disabled)
+	 * HDMI_IH_MUTE_* = 0x00 (enabled)
+	 *
+	 * Disable top level interrupt bits in HDMI block
+	 */
+	ih_mute = hdmi_readb(hdmi, HDMI_IH_MUTE) |
+		  HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
+		  HDMI_IH_MUTE_MUTE_ALL_INTERRUPT;
+
+	hdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);
+
+	/* by default mask all interrupts */
+	hdmi_writeb(hdmi, 0xff, HDMI_VP_MASK);
+	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK0);
+	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK1);
+	hdmi_writeb(hdmi, 0x03, HDMI_FC_MASK2);
+	hdmi_writeb(hdmi, 0xf3, HDMI_PHY_MASK0);
+	hdmi_writeb(hdmi, 0x0c, HDMI_PHY_I2CM_INT_ADDR);
+	hdmi_writeb(hdmi, 0xcc, HDMI_PHY_I2CM_CTLINT_ADDR);
+	hdmi_writeb(hdmi, 0x0c, HDMI_AUD_INT);
+	hdmi_writeb(hdmi, 0xdf, HDMI_A_APIINTMSK);
+	hdmi_writeb(hdmi, 0x7f, HDMI_MISC_MASK);
+	hdmi_writeb(hdmi, 0x44, HDMI_I2CM_INT);
+	hdmi_writeb(hdmi, 0x44, HDMI_I2CM_CTLINT);
+
+	/* Disable interrupts in the IH_MUTE_* registers */
+	hdmi_writeb(hdmi, 0xdf, HDMI_IH_MUTE_FC_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT1);
+	hdmi_writeb(hdmi, 0x03, HDMI_IH_MUTE_FC_STAT2);
+	hdmi_writeb(hdmi, 0x1f, HDMI_IH_MUTE_AS_STAT0);
+	hdmi_writeb(hdmi, 0x3f, HDMI_IH_MUTE_PHY_STAT0);
+	hdmi_writeb(hdmi, 0x03, HDMI_IH_MUTE_I2CM_STAT0);
+	hdmi_writeb(hdmi, 0x0f, HDMI_IH_MUTE_VP_STAT0);
+	hdmi_writeb(hdmi, 0x03, HDMI_IH_MUTE_I2CMPHY_STAT0);
+
+	/* Enable top level interrupt bits in HDMI block */
+	ih_mute &= ~(HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
+		    HDMI_IH_MUTE_MUTE_ALL_INTERRUPT);
+	hdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);
+}
+
 static void initialize_hdmi_ih_mutes(struct dw_hdmi *hdmi)
 {
 	u8 ih_mute;
@@ -2055,7 +2162,10 @@ void dw_hdmi_s2r_ctrl(struct drm_bridge *bridge, int flag)
 		if (hdmi->iahb_clk)
 			clk_prepare_enable(hdmi->iahb_clk);
 
-		initialize_hdmi_ih_mutes(hdmi);
+		if (hdmi->plat_data->dev_type == RCAR_HDMI)
+			initialize_hdmi_rcar_ih_mutes(hdmi);
+		else
+			initialize_hdmi_ih_mutes(hdmi);
 		dw_hdmi_setup_i2c(hdmi);
 		dw_hdmi_i2c_init(hdmi);
 		dw_hdmi_phy_setup_hpd(hdmi, NULL);
@@ -2105,7 +2215,10 @@ static irqreturn_t dw_hdmi_hardirq(int irq, void *dev_id)
 
 	intr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);
 	if (intr_stat) {
-		hdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);
+		if (hdmi->plat_data->dev_type == RCAR_HDMI)
+			hdmi_writeb(hdmi, 0x3f, HDMI_IH_MUTE_PHY_STAT0);
+		else
+			hdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);
 		return IRQ_WAKE_THREAD;
 	}
 
@@ -2190,8 +2303,14 @@ static irqreturn_t dw_hdmi_irq(int irq, void *dev_id)
 	}
 
 	hdmi_writeb(hdmi, intr_stat, HDMI_IH_PHY_STAT0);
-	hdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE),
-		    HDMI_IH_MUTE_PHY_STAT0);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_writeb(hdmi, (HDMI_IH_MUTE_PHY_STAT0_MASK &
+				 ~(HDMI_IH_PHY_STAT0_HPD |
+				  HDMI_IH_PHY_STAT0_RX_SENSE)),
+				  HDMI_IH_MUTE_PHY_STAT0);
+	else
+		hdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD |
+			 HDMI_IH_PHY_STAT0_RX_SENSE), HDMI_IH_MUTE_PHY_STAT0);
 
 	return IRQ_HANDLED;
 }
@@ -2280,6 +2399,9 @@ static int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)
 
 static void dw_hdmi_cec_enable(struct dw_hdmi *hdmi)
 {
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		return;
+
 	mutex_lock(&hdmi->mutex);
 	hdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
 	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
@@ -2288,6 +2410,9 @@ static void dw_hdmi_cec_enable(struct dw_hdmi *hdmi)
 
 static void dw_hdmi_cec_disable(struct dw_hdmi *hdmi)
 {
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		return;
+
 	mutex_lock(&hdmi->mutex);
 	hdmi->mc_clkdis |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
 	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
@@ -2343,8 +2468,16 @@ __dw_hdmi_probe(struct platform_device *pdev,
 	hdmi->sample_rate = 48000;
 	hdmi->disabled = true;
 	hdmi->rxsense = true;
-	hdmi->phy_mask = (u8)~(HDMI_PHY_HPD | HDMI_PHY_RX_SENSE);
-	hdmi->mc_clkdis = 0x7f;
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi->phy_mask = (u8)~(BIT(3) | BIT(2) | HDMI_PHY_HPD |
+					 HDMI_PHY_RX_SENSE);
+	else
+		hdmi->phy_mask = (u8)~(HDMI_PHY_HPD | HDMI_PHY_RX_SENSE);
+
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi->mc_clkdis = 0x5f;
+	else
+		hdmi->mc_clkdis = 0x7f;
 
 	mutex_init(&hdmi->mutex);
 	mutex_init(&hdmi->audio_mutex);
@@ -2466,7 +2599,10 @@ __dw_hdmi_probe(struct platform_device *pdev,
 		 prod_id1 & HDMI_PRODUCT_ID1_HDCP ? "with" : "without",
 		 hdmi->phy.name);
 
-	initialize_hdmi_ih_mutes(hdmi);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		initialize_hdmi_rcar_ih_mutes(hdmi);
+	else
+		initialize_hdmi_ih_mutes(hdmi);
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -2595,7 +2731,10 @@ static void __dw_hdmi_remove(struct dw_hdmi *hdmi)
 		platform_device_unregister(hdmi->cec);
 
 	/* Disable all interrupts */
-	hdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);
+	if (hdmi->plat_data->dev_type == RCAR_HDMI)
+		hdmi_writeb(hdmi, 0x3f, HDMI_IH_MUTE_PHY_STAT0);
+	else
+		hdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);
 
 	if (hdmi->cec_notifier)
 		cec_notifier_put(hdmi->cec_notifier);
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.h b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.h
index 9d90eb9c46e5..3d00338499f0 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.h
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2018 Renesas Electronics Corporation
  * Copyright (C) 2011 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -478,6 +479,9 @@
 #define HDMI_A_PRESETUP                         0x501A
 #define HDMI_A_SRM_BASE                         0x5020
 
+/* Misc Mask Regigter for R-Car only */
+#define HDMI_MISC_MASK                          0x7D02
+
 /* I2C Master Registers (E-DDC) */
 #define HDMI_I2CM_SLAVE                         0x7E00
 #define HDMI_I2CM_ADDRESS                       0x7E01
@@ -537,6 +541,10 @@ enum {
 	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
 	HDMI_IH_PHY_STAT0_HPD = 0x1,
 
+/* IH_I2CMPHY_STAT0 field values */
+	HDMI_IH_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
+	HDMI_IH_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
+
 /* IH_I2CM_STAT0 and IH_MUTE_I2CM_STAT0 field values */
 	HDMI_IH_I2CM_STAT0_DONE = 0x2,
 	HDMI_IH_I2CM_STAT0_ERROR = 0x1,
@@ -566,6 +574,9 @@ enum {
 	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
 	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
 
+/* IH_MUTE_PHY_STAT0 field values */
+	HDMI_IH_MUTE_PHY_STAT0_MASK = 0x3f,
+
 /* IH_MUTE field values */
 	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
 	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
@@ -942,6 +953,7 @@ enum {
 
 /* MC_SWRSTZ field values */
 	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
+	HDMI_MC_SWRSTZ_TMDSSWRST_MASK = 0x02,
 
 /* MC_FLOWCTRL field values */
 	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
@@ -1042,6 +1054,9 @@ enum {
 	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
 	HDMI_I2CM_CTLINT_ARB_POL = 0x8,
 	HDMI_I2CM_CTLINT_ARB_MASK = 0x4,
+
+/* I2CM_DIV field values */
+	HDMI_I2CM_DIV_FAST_STD_MODE_MASK = 0x08,
 };
 
 /*
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 8b9741948f7d..e99f91a9fdd1 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2018 Renesas Electronics Corporation
  * Copyright (C) 2011 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -82,6 +83,10 @@ enum {
 	DW_HDMI_RES_MAX,
 };
 
+enum dw_hdmi_devtype {
+	RCAR_HDMI = 1,
+};
+
 enum dw_hdmi_phy_type {
 	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0x00,
 	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 0xb2,
@@ -123,6 +128,7 @@ struct dw_hdmi_phy_ops {
 };
 
 struct dw_hdmi_plat_data {
+	enum dw_hdmi_devtype dev_type;
 	struct regmap *regm;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
 					   const struct drm_display_mode *mode);
-- 
2.17.1


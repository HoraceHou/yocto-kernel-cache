From c837614a0dcb66bd2a36e1d6a9c92dc9ff21aad1 Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Tue, 27 Nov 2018 10:39:33 +0900
Subject: [PATCH 384/909] media: i2c: adv748x: Add option for changing SD
 output route to TXA

commit ece3fe90f5477609e98201580fa2e647741af536 from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git

The current driver only supports the following connections.
Signed-off-by: Meng Li <Meng.Li@windriver.com>
HDMI IN(CP) ----> TXA ----> CSI40
CVBS IN(SDP)----> TXB ----> CSI20

This patch supports additionally the following connections.
HDMI IN(CP)   /-> TXA ----> CSI40
CVBS IN(SDP)--    TXB       CSI20

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
---
 .../devicetree/bindings/media/i2c/adv748x.txt |  3 +
 drivers/media/i2c/adv748x/adv748x-afe.c       |  5 +-
 drivers/media/i2c/adv748x/adv748x-core.c      | 89 ++++++++++++++++---
 drivers/media/i2c/adv748x/adv748x-csi2.c      |  7 +-
 drivers/media/i2c/adv748x/adv748x.h           |  2 +
 5 files changed, 89 insertions(+), 17 deletions(-)

diff --git a/Documentation/devicetree/bindings/media/i2c/adv748x.txt b/Documentation/devicetree/bindings/media/i2c/adv748x.txt
index a33218b6dfd2..3786b5ccaccd 100644
--- a/Documentation/devicetree/bindings/media/i2c/adv748x.txt
+++ b/Documentation/devicetree/bindings/media/i2c/adv748x.txt
@@ -23,6 +23,9 @@ Optional Properties:
   - virtual-channel: Specify the same virtual-channel value for the both and adv7482_txa
 		     and adv7482_txb node of ADV748x as follows, If not specified, it is 0.
 		     virtual-channel = <0 or 1 or 2 or 3>;
+  - txa_direction: Change routing to MIPI CSI 4-lane Tx (TXA) from CP to SDP
+		   Please describe option as follows in adv7482_txa endpoint.
+		   txa_direction = "afe";
 
 The device node must contain one 'port' child node per device input and output
 port, in accordance with the video interface bindings defined in
diff --git a/drivers/media/i2c/adv748x/adv748x-afe.c b/drivers/media/i2c/adv748x/adv748x-afe.c
index 4f432164f4d9..aafe038df6bd 100644
--- a/drivers/media/i2c/adv748x/adv748x-afe.c
+++ b/drivers/media/i2c/adv748x/adv748x-afe.c
@@ -284,7 +284,10 @@ static int adv748x_afe_s_stream(struct v4l2_subdev *sd, int enable)
 			goto unlock;
 	}
 
-	ret = adv748x_txb_power(state, enable);
+	if (state->afe.txa_switch)
+		ret = adv748x_txa_power(state, enable);
+	else
+		ret = adv748x_txb_power(state, enable);
 	if (ret)
 		goto unlock;
 
diff --git a/drivers/media/i2c/adv748x/adv748x-core.c b/drivers/media/i2c/adv748x/adv748x-core.c
index e750d7d4490a..a8cdf3f44123 100644
--- a/drivers/media/i2c/adv748x/adv748x-core.c
+++ b/drivers/media/i2c/adv748x/adv748x-core.c
@@ -369,6 +369,7 @@ int adv748x_txa_power(struct adv748x_state *state, bool on)
 	WARN_ONCE((on && val & ADV748X_CSI_FS_AS_LS_UNKNOWN),
 			"Enabling with unknown bit set");
 
+	/* Use the following processing at both hdmi and afe */
 	if (on) {
 		if (state->hdmi.use_lane == 1)
 			txa_on = adv748x_power_up_txa_1lane;
@@ -555,9 +556,54 @@ static const struct adv748x_reg_value adv748x_init_txb_1lane[] = {
 	{ADV748X_PAGE_EOR, 0xff, 0xff}	/* End of register table */
 };
 
+static const struct adv748x_reg_value adv748x_init_txa_afe_1lane[] = {
+	{ADV748X_PAGE_IO, 0x00, 0x30},	/* Disable chip powerdown Rx */
+	{ADV748X_PAGE_IO, 0x0e, 0xff},	/* LLC/PIX/AUD/SPI PINS TRISTATED */
+	{ADV748X_PAGE_SDP, 0x0f, 0x00},	/* Exit Power Down Mode */
+	{ADV748X_PAGE_SDP, 0x52, 0xcd},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x00, 0x07},	/* INSEL = CVBS in on Ain 8 */
+	{ADV748X_PAGE_SDP, 0x0e, 0x80},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x9c, 0x00},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x9c, 0xff},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x0e, 0x00},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x80, 0x51},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x81, 0x51},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x82, 0x68},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x03, 0x42},
+		/* Tri-S Output Drivers, PwrDwn 656 pads */
+	{ADV748X_PAGE_SDP, 0x04, 0xb5},	/* ITU-R BT.656-4 compatible */
+	{ADV748X_PAGE_SDP, 0x13, 0x00},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0x17, 0x41},	/* Select SH1 */
+	{ADV748X_PAGE_SDP, 0x31, 0x12},	/* ADI Required Write */
+	{ADV748X_PAGE_SDP, 0xe6, 0x4f},
+		/* Set V bit end position manually in NTSC mode */
+	{ADV748X_PAGE_IO, 0x10, 0xb8 },
+		/* Enable pixel output and route SD through Pixel port */
+	{ADV748X_PAGE_TXA, 0x00, 0x81},
+		/* Enable 4-lane MIPI, 1-Lane Configuration */
+	{ADV748X_PAGE_TXA, 0x00, 0xa1},	/* Set Auto DPHY Timing */
+	{ADV748X_PAGE_TXA, 0xd2, 0x40},	/* ADI Required Write */
+	{ADV748X_PAGE_TXA, 0xc4, 0x0a},	/* ADI Required Write */
+	{ADV748X_PAGE_TXA, 0x71, 0x33},	/* ADI Required Write */
+	{ADV748X_PAGE_TXA, 0x72, 0x11},	/* ADI Required Write */
+	{ADV748X_PAGE_TXA, 0xf0, 0x00},	/* i2c_dphy_pwdn - 1'b0 */
+	{ADV748X_PAGE_TXA, 0x31, 0x82},	/* ADI Required Write */
+	{ADV748X_PAGE_TXA, 0x1e, 0x40},	/* ADI Required Write */
+	{ADV748X_PAGE_TXA, 0xda, 0x00},	/* i2c_mipi_pll_en - 1'b1 */
+	{ADV748X_PAGE_WAIT, 0x00, 0x02},	/* delay 2 */
+	{ADV748X_PAGE_TXA, 0x00, 0x21},	/* Power-up CSI-TX */
+	{ADV748X_PAGE_WAIT, 0x00, 0x01},	/* delay 1 */
+	{ADV748X_PAGE_TXA, 0xc1, 0x2b},	/* ADI Required Write */
+	{ADV748X_PAGE_WAIT, 0x00, 0x01},	/* delay 1 */
+	{ADV748X_PAGE_TXA, 0x31, 0x80},	/* ADI Required Write */
+
+	{ADV748X_PAGE_EOR, 0xff, 0xff}	/* End of register table */
+};
+
 static int adv748x_reset(struct adv748x_state *state)
 {
 	int ret;
+	u8 value;
 
 	ret = adv748x_write_regs(state, adv748x_sw_reset);
 	if (ret < 0)
@@ -568,24 +614,33 @@ static int adv748x_reset(struct adv748x_state *state)
 		return ret;
 
 	/* Init and power down TXA */
-	ret = adv748x_write_regs(state, adv748x_init_txa_4lane);
-	if (ret)
-		return ret;
+	if (state->afe.txa_switch) {
+		ret = adv748x_write_regs(state, adv748x_init_txa_afe_1lane);
+		if (ret)
+			return ret;
+		adv748x_txa_power(state, 0);
+		value = ADV748X_IO_10_OUT_SD_TXA;
+	} else {
+		ret = adv748x_write_regs(state, adv748x_init_txa_4lane);
+		if (ret)
+			return ret;
 
-	adv748x_txa_power(state, 0);
+		adv748x_txa_power(state, 0);
 
-	/* Init and power down TXB */
-	ret = adv748x_write_regs(state, adv748x_init_txb_1lane);
-	if (ret)
-		return ret;
+		/* Init and power down TXB */
+		ret = adv748x_write_regs(state, adv748x_init_txb_1lane);
+		if (ret)
+			return ret;
 
-	adv748x_txb_power(state, 0);
+		adv748x_txb_power(state, 0);
+		value = 0;
+	}
 
 	/* Disable chip powerdown & Enable HDMI Rx block */
 	io_write(state, ADV748X_IO_PD, ADV748X_IO_PD_RX_EN);
 
 	/* Enable 4-lane CSI Tx & Pixel Port */
-	io_write(state, ADV748X_IO_10, ADV748X_IO_10_CSI4_EN |
+	io_write(state, ADV748X_IO_10, value | ADV748X_IO_10_CSI4_EN |
 				       ADV748X_IO_10_CSI1_EN |
 				       ADV748X_IO_10_PIX_OUT_EN);
 
@@ -671,10 +726,22 @@ static int adv748x_parse_dt(struct adv748x_state *state)
 
 		of_node_get(ep_np);
 		state->endpoints[ep.port] = ep_np;
-		if (ep.port == ADV748X_PORT_TXA)
+		if (ep.port == ADV748X_PORT_TXA) {
+			const char *str;
+
 			state->hdmi.use_lane =
 				v4l2_ep.bus.mipi_csi2.num_data_lanes;
 
+			if (!of_property_read_string(ep_np, "txa_direction",
+						     &str)) {
+				if (!strcmp(str, "afe"))
+					state->afe.txa_switch = true;
+				else
+					state->afe.txa_switch = false;
+			} else {
+				state->afe.txa_switch = false;
+			}
+		}
 		/*
 		 * At least one input endpoint and one output endpoint shall
 		 * be defined.
diff --git a/drivers/media/i2c/adv748x/adv748x-csi2.c b/drivers/media/i2c/adv748x/adv748x-csi2.c
index 102ae6f393a0..12ea83570dc9 100644
--- a/drivers/media/i2c/adv748x/adv748x-csi2.c
+++ b/drivers/media/i2c/adv748x/adv748x-csi2.c
@@ -82,12 +82,9 @@ static int adv748x_csi2_registered(struct v4l2_subdev *sd)
 			sd->name);
 
 	/*
-	 * The adv748x hardware allows the AFE to route through the TXA, however
-	 * this is not currently supported in this driver.
-	 *
-	 * Link HDMI->TXA, and AFE->TXB directly.
+	 * The adv748x hardware allows the AFE to route through the TXA.
 	 */
-	if (is_txa(tx)) {
+	if (is_txa(tx) && !state->afe.txa_switch) {
 		return adv748x_csi2_register_link(tx, sd->v4l2_dev,
 						  &state->hdmi.sd,
 						  ADV748X_HDMI_SOURCE);
diff --git a/drivers/media/i2c/adv748x/adv748x.h b/drivers/media/i2c/adv748x/adv748x.h
index e343cec1cbe5..7a736ba30b07 100644
--- a/drivers/media/i2c/adv748x/adv748x.h
+++ b/drivers/media/i2c/adv748x/adv748x.h
@@ -144,6 +144,7 @@ struct adv748x_afe {
 	bool streaming;
 	v4l2_std_id curr_norm;
 	unsigned int input;
+	bool txa_switch;
 };
 
 #define adv748x_ctrl_to_afe(ctrl) \
@@ -210,6 +211,7 @@ struct adv748x_state {
 #define ADV748X_IO_10_CSI4_EN		BIT(7)
 #define ADV748X_IO_10_CSI1_EN		BIT(6)
 #define ADV748X_IO_10_PIX_OUT_EN	BIT(5)
+#define ADV748X_IO_10_OUT_SD_TXA	BIT(3)
 
 #define ADV748X_IO_CHIP_REV_ID_1	0xdf
 #define ADV748X_IO_CHIP_REV_ID_2	0xe0
-- 
2.17.1


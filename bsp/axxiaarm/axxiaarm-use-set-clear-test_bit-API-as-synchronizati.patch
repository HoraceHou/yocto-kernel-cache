From 3ed9226a082a6d1c3519242d97d177ce44749087 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Fri, 1 Mar 2019 13:40:59 +0800
Subject: [PATCH] axxiaarm: use set/clear/test_bit() API as synchronization

The commit 8111b95bfc9b ("axxia: add sync between cpu_die and cpu_kill") add
spinlock to protect the global variable axxia_cpu_die_flag. But in preempt-rt
kernel it will trigger calltrace as below:

[87930.434034] BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:974
[87930.434040] in_atomic(): 1, irqs_disabled(): 128, pid: 0, name: swapper/1
[87930.434043] INFO: lockdep is turned off.
[87930.434046] Preemption disabled at:
[87930.434061] [<c0611bd8>] secondary_start_kernel+0x11c/0x1dc
[87930.434070] CPU: 1 PID: 0 Comm: swapper/1 Tainted: P O 4.18.20-rt8-yocto-preempt-rt #1
[87930.434074] Hardware name: INTEL Axxia
[87930.434088] [<c061529c>] (unwind_backtrace) from [<c060e228>] (show_stack+0x20/0x24)
[87930.434101] [<c060e228>] (show_stack) from [<c1007914>] (dump_stack+0x9c/0xd0)
[87930.434112] [<c1007914>] (dump_stack) from [<c0662b80>] (___might_sleep+0x174/0x1e0)
[87930.434123] [<c0662b80>] (___might_sleep) from [<c1022550>] (rt_spin_lock+0x78/0x8c)
[87930.434133] [<c1022550>] (rt_spin_lock) from [<c062b538>] (axxia_platform_cpu_die+0x20/0xc4)
[87930.434142] [<c062b538>] (axxia_platform_cpu_die) from [<c0611a78>] (arch_cpu_idle_dead+0x50/0x94)
[87930.434151] [<c0611a78>] (arch_cpu_idle_dead) from [<c066c510>] (do_idle+0xb8/0x174)
[87930.434159] [<c066c510>] (do_idle) from [<c066c890>] (cpu_startup_entry+0x28/0x2c)
[87930.434166] [<c066c890>] (cpu_startup_entry) from [<c0611c64>] (secondary_start_kernel+0x1a8/0x1dc)
[87930.434177] [<c0611c64>] (secondary_start_kernel) from [<00602b4c>] (0x602b4c)

Use set/vlear/test_bit() APIs can simplify the code and avoid the calltrace.

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/arm/mach-axxia/hotplug.c |   15 ++++-----------
 1 file changed, 4 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-axxia/hotplug.c b/arch/arm/mach-axxia/hotplug.c
index 0cc33d3..df5645d 100644
--- a/arch/arm/mach-axxia/hotplug.c
+++ b/arch/arm/mach-axxia/hotplug.c
@@ -21,8 +21,7 @@
 #include "axxia_power_management.h"
 
 extern volatile int pen_release;
-static int axxia_cpu_die_flag;
-static DEFINE_SPINLOCK(axxia_cpu_die_lock);
+static unsigned long axxia_cpu_die_flag;
 
 static inline void pm_cpu_logical_shutdown(u32 cpu)
 {
@@ -222,9 +221,7 @@ int axxia_platform_cpu_kill(unsigned int cpu)
 
 	retry = 50;
 	while (1) {
-		spin_lock(&axxia_cpu_die_lock);
-		ret = axxia_cpu_die_flag & (1<<cpu);
-		spin_unlock(&axxia_cpu_die_lock);
+		ret = test_bit(cpu, &axxia_cpu_die_flag);
 		if (ret != 0) {
 			break;
 		}
@@ -238,9 +235,7 @@ int axxia_platform_cpu_kill(unsigned int cpu)
 	pm_cpu_shutdown(cpu);
 	put_cpu();
 
-	spin_lock(&axxia_cpu_die_lock);
-	axxia_cpu_die_flag &= ~(1<<cpu);
-	spin_unlock(&axxia_cpu_die_lock);
+	clear_bit(cpu, &axxia_cpu_die_flag);
 #endif
 	return 1;
 }
@@ -256,9 +251,7 @@ void axxia_platform_cpu_die(unsigned int cpu)
 #ifdef CONFIG_HOTPLUG_CPU_COMPLETE_POWER_DOWN
 	bool last_cpu;
 
-	spin_lock(&axxia_cpu_die_lock);
-	axxia_cpu_die_flag |= (1<<cpu);
-	spin_unlock(&axxia_cpu_die_lock);
+	set_bit(cpu, &axxia_cpu_die_flag);
 	last_cpu = pm_cpu_last_of_cluster(cpu);
 
 	if (last_cpu)
-- 
1.7.9.5


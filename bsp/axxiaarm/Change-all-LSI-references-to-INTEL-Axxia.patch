From 89a5aa75dd1ec2263778b9ed0c425aa173b00111 Mon Sep 17 00:00:00 2001
From: Daniel Dragomir <daniel.dragomir@windriver.com>
Date: Tue, 3 Apr 2018 19:31:52 +0300
Subject: [PATCH 268/278] Change all LSI references to INTEL Axxia

Signed-off-by: Daniel Dragomir <daniel.dragomir@windriver.com>
Signed-off-by: John Jacques <john.jacques@intel.com>
---
 Documentation/devicetree/bindings/arm/axxia.txt    |    6 +-
 .../devicetree/bindings/arm/axxia/edac_cpu.txt     |    2 +-
 .../devicetree/bindings/arm/axxia/edac_l1.txt      |    2 +-
 .../devicetree/bindings/arm/axxia/edac_l2.txt      |    2 +-
 .../bindings/clock/axxia,axm5516-clks.txt          |   27 +
 .../devicetree/bindings/clock/lsi,axm5516-clks.txt |   29 -
 .../devicetree/bindings/hwrng/axxia_rng.txt        |    4 +-
 .../devicetree/bindings/i2c/i2c-axxia.txt          |    6 +-
 .../devicetree/bindings/misc/axxia-mtc.txt         |   15 +
 Documentation/devicetree/bindings/misc/lsi-mtc.txt |   15 -
 .../devicetree/bindings/net/axxia-femac.txt        |   20 +
 .../devicetree/bindings/net/axxia-mdio.txt         |   26 +
 .../devicetree/bindings/net/lsi-femac.txt          |   20 -
 Documentation/devicetree/bindings/net/lsi-mdio.txt |   26 -
 .../devicetree/bindings/pci/intel,axxia-pcie.txt   |    4 +-
 .../bindings/power/reset/axxia-reset.txt           |    8 +-
 .../bindings/rapidio/intel,axxia-rapidio.txt       |    4 +-
 .../devicetree/bindings/usb/intel,axxia-dwc3.txt   |    4 +-
 arch/arm/boot/dts/axm5504-cpus.dtsi                |    2 +-
 arch/arm/boot/dts/axm5504-emu.dts                  |    4 +-
 arch/arm/boot/dts/axm5504-sim-mmc.dts              |    4 +-
 arch/arm/boot/dts/axm5504-sim-virtio.dts           |    4 +-
 arch/arm/boot/dts/axm5504-sim.dts                  |    4 +-
 arch/arm/boot/dts/axm5507-cpus.dtsi                |    2 +-
 arch/arm/boot/dts/axm5507-emu.dts                  |    4 +-
 arch/arm/boot/dts/axm5508-amarillo.dts             |    4 +-
 arch/arm/boot/dts/axm5508-cpus.dtsi                |    2 +-
 arch/arm/boot/dts/axm5512-amarillo.dts             |    4 +-
 arch/arm/boot/dts/axm5512-cpus.dtsi                |    2 +-
 arch/arm/boot/dts/axm5516-amarillo.dts             |    4 +-
 arch/arm/boot/dts/axm5516-cpus.dtsi                |    2 +-
 arch/arm/boot/dts/axm5516-sim-common.dts           |    4 +-
 arch/arm/boot/dts/axm5516-sim-mmc.dts              |    4 +-
 arch/arm/boot/dts/axm5516-sim-virtio.dts           |    4 +-
 arch/arm/boot/dts/axm5516-sim.dts                  |    4 +-
 arch/arm/boot/dts/axm55xx.dtsi                     |   44 +-
 arch/arm/mach-axxia/Kconfig                        |    8 +-
 arch/arm/mach-axxia/Makefile                       |    2 +-
 arch/arm/mach-axxia/axxia-gic.c                    |    4 +-
 arch/arm/mach-axxia/axxia.c                        |   14 +-
 arch/arm/mach-axxia/axxia_power_management.c       | 1350 +++++++
 arch/arm/mach-axxia/axxia_power_management.h       |  192 +
 arch/arm/mach-axxia/clock.c                        |    2 +-
 arch/arm/mach-axxia/ddr_retention.c                |    6 +-
 arch/arm/mach-axxia/hotplug.c                      |    2 +-
 arch/arm/mach-axxia/include/mach/hardware.h        |    2 +-
 arch/arm/mach-axxia/include/mach/rio.h             |    2 +-
 arch/arm/mach-axxia/include/mach/timers.h          |    2 +-
 arch/arm/mach-axxia/io.c                           |    4 +-
 arch/arm/mach-axxia/lsi_power_management.c         | 1350 -------
 arch/arm/mach-axxia/lsi_power_management.h         |  192 -
 arch/arm/mach-axxia/perf_event_memc.c              |    4 +-
 arch/arm/mach-axxia/perf_event_memc.h              |    4 +-
 arch/arm/mach-axxia/perf_event_pcx.c               |    4 +-
 arch/arm/mach-axxia/perf_event_platform.c          |   20 +-
 arch/arm/mach-axxia/perf_event_vp.c                |    4 +-
 arch/arm/mach-axxia/platsmp.c                      |    8 +-
 arch/arm/mach-axxia/rapidio.c                      |    4 +-
 arch/arm/mach-axxia/smon.c                         |    4 +-
 arch/arm/mach-axxia/smon.h                         |    2 +-
 arch/arm/mach-axxia/ssp-gpio.c                     |    6 +-
 arch/arm/mach-axxia/timers.c                       |    2 +-
 arch/arm64/Kconfig.platforms                       |    2 +-
 arch/arm64/boot/dts/intel/axc6704-emu.dts          |    6 +-
 arch/arm64/boot/dts/intel/axc6704-sim.dts          |    2 +-
 arch/arm64/boot/dts/intel/axc6704-waco.dts         |   10 +-
 arch/arm64/boot/dts/intel/axc6712-emu.dts          |    6 +-
 arch/arm64/boot/dts/intel/axc6716-sim.dts          |    2 +-
 arch/arm64/boot/dts/intel/axc6732-sim.dts          |    2 +-
 arch/arm64/boot/dts/intel/axc6732-waco.dts         |   10 +-
 arch/arm64/boot/dts/intel/axc67xx.dtsi             |   46 +-
 arch/arm64/boot/dts/intel/axm5604-sim.dts          |    6 +-
 arch/arm64/boot/dts/intel/axm5606-emu.dts          |    8 +-
 arch/arm64/boot/dts/intel/axm5608-sim.dts          |    6 +-
 arch/arm64/boot/dts/intel/axm5616-sim.dts          |    6 +-
 arch/arm64/boot/dts/intel/axm5616-victoria.dts     |    6 +-
 arch/arm64/boot/dts/intel/axm56xx.dtsi             |   32 +-
 drivers/char/hw_random/axxia-rng.c                 |    2 +-
 drivers/dma/Kconfig                                |    6 +-
 drivers/dma/Makefile                               |    2 +-
 drivers/dma/axxia-dma32.c                          |  839 ++++
 drivers/dma/axxia-dma32.h                          |  221 +
 drivers/dma/lsi-dma32.c                            |  839 ----
 drivers/dma/lsi-dma32.h                            |  221 -
 drivers/edac/axxia_edac-cmc_56xx.c                 |    2 +-
 drivers/edac/axxia_edac-l2_cpu.c                   |   70 +-
 drivers/edac/axxia_edac-l2_cpu_56xx.c              |    2 +-
 drivers/edac/axxia_edac-l3.c                       |   42 +-
 drivers/edac/axxia_edac-l3_56xx.c                  |    2 +-
 drivers/edac/axxia_edac-mc.c                       |   42 +-
 drivers/edac/axxia_edac-mc_56xx.c                  |    2 +-
 drivers/gpio/gpio-axxia.c                          |    2 +-
 drivers/i2c/busses/i2c-axxia.c                     |    4 +-
 drivers/misc/Kconfig                               |   16 +-
 drivers/misc/Makefile                              |    6 +-
 drivers/misc/axxia-fault.c                         |    8 +-
 drivers/misc/axxia-mdio.c                          |   10 +-
 drivers/misc/axxia-mtc.c                           | 4233 ++++++++++++++++++++
 drivers/misc/axxia-ncr.c                           | 1277 ++++++
 drivers/misc/axxia-oem.c                           |    2 +-
 drivers/misc/axxia-pei.c                           |   10 +-
 drivers/misc/axxia-smmon.c                         |  306 ++
 drivers/misc/lsi-mtc.c                             | 4233 --------------------
 drivers/misc/lsi-ncr.c                             | 1277 ------
 drivers/misc/lsi-smmon.c                           |  306 --
 drivers/mtd/nand/Kconfig                           |    4 +-
 drivers/mtd/nand/Makefile                          |    4 +-
 drivers/mtd/nand/axxia_acp_nand.c                  | 3676 +++++++++++++++++
 drivers/mtd/nand/axxia_ubootenv.c                  |  569 +++
 drivers/mtd/nand/lsi_acp_nand.c                    | 3676 -----------------
 drivers/mtd/nand/lsi_ubootenv.c                    |  569 ---
 drivers/net/ethernet/Kconfig                       |    6 +-
 drivers/net/ethernet/Makefile                      |    2 +-
 drivers/net/ethernet/axxia/Kconfig                 |   38 +
 drivers/net/ethernet/axxia/Makefile                |    4 +
 drivers/net/ethernet/axxia/axxia_acp_mdio.c        |  338 ++
 drivers/net/ethernet/axxia/axxia_acp_net.c         | 2000 +++++++++
 drivers/net/ethernet/axxia/axxia_acp_net.h         |  669 ++++
 drivers/net/ethernet/lsi/Kconfig                   |   38 -
 drivers/net/ethernet/lsi/Makefile                  |    4 -
 drivers/net/ethernet/lsi/lsi_acp_mdio.c            |  338 --
 drivers/net/ethernet/lsi/lsi_acp_net.c             | 2000 ---------
 drivers/net/ethernet/lsi/lsi_acp_net.h             |  669 ----
 drivers/pci/host/axxia_pci.c                       |    2 +-
 drivers/pci/host/pcie-axxia.c                      |    6 +-
 drivers/power/reset/axxia-reset.c                  |    4 +-
 drivers/rapidio/devices/Kconfig                    |    2 +-
 drivers/rapidio/devices/Makefile                   |    2 +-
 drivers/rapidio/devices/axxia/Kconfig              |   47 +
 drivers/rapidio/devices/axxia/Makefile             |    5 +
 drivers/rapidio/devices/axxia/axxia-rio-irq.c      | 2842 +++++++++++++
 drivers/rapidio/devices/axxia/axxia-rio-irq.h      |  211 +
 drivers/rapidio/devices/axxia/axxia-rio-sysfs.c    |  306 ++
 drivers/rapidio/devices/axxia/axxia-rio.c          | 1885 +++++++++
 drivers/rapidio/devices/axxia/axxia-rio.h          |  620 +++
 drivers/rapidio/devices/lsi/Kconfig                |   47 -
 drivers/rapidio/devices/lsi/Makefile               |    5 -
 drivers/rapidio/devices/lsi/axxia-rio-irq.c        | 2842 -------------
 drivers/rapidio/devices/lsi/axxia-rio-irq.h        |  211 -
 drivers/rapidio/devices/lsi/axxia-rio-sysfs.c      |  306 --
 drivers/rapidio/devices/lsi/axxia-rio.c            | 1885 ---------
 drivers/rapidio/devices/lsi/axxia-rio.h            |  620 ---
 drivers/spi/Kconfig                                |    6 +-
 drivers/spi/Makefile                               |    2 +-
 drivers/spi/spi-pl022.c                            |    4 +-
 drivers/tty/serial/Kconfig                         |    4 +-
 drivers/tty/serial/Makefile                        |    2 +-
 drivers/tty/serial/axxia_acp_serial.c              | 1247 ++++++
 drivers/tty/serial/lsi_acp_serial.c                | 1247 ------
 drivers/usb/dwc3/dwc3-axxia.c                      |    2 +-
 drivers/usb/host/Kconfig                           |    6 +-
 drivers/usb/host/ehci-ci13612.c                    |   34 +-
 include/linux/axxia-ncr.h                          |   58 +
 include/linux/axxia_mtc_ioctl.h                    |  153 +
 include/linux/lsi-ncr.h                            |   58 -
 include/linux/lsi_mtc_ioctl.h                      |  153 -
 156 files changed, 23537 insertions(+), 23539 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/clock/axxia,axm5516-clks.txt
 delete mode 100644 Documentation/devicetree/bindings/clock/lsi,axm5516-clks.txt
 create mode 100644 Documentation/devicetree/bindings/misc/axxia-mtc.txt
 delete mode 100644 Documentation/devicetree/bindings/misc/lsi-mtc.txt
 create mode 100644 Documentation/devicetree/bindings/net/axxia-femac.txt
 create mode 100644 Documentation/devicetree/bindings/net/axxia-mdio.txt
 delete mode 100644 Documentation/devicetree/bindings/net/lsi-femac.txt
 delete mode 100644 Documentation/devicetree/bindings/net/lsi-mdio.txt
 create mode 100644 arch/arm/mach-axxia/axxia_power_management.c
 create mode 100644 arch/arm/mach-axxia/axxia_power_management.h
 delete mode 100644 arch/arm/mach-axxia/lsi_power_management.c
 delete mode 100644 arch/arm/mach-axxia/lsi_power_management.h
 create mode 100644 drivers/dma/axxia-dma32.c
 create mode 100644 drivers/dma/axxia-dma32.h
 delete mode 100644 drivers/dma/lsi-dma32.c
 delete mode 100644 drivers/dma/lsi-dma32.h
 create mode 100644 drivers/misc/axxia-mtc.c
 create mode 100644 drivers/misc/axxia-ncr.c
 create mode 100644 drivers/misc/axxia-smmon.c
 delete mode 100644 drivers/misc/lsi-mtc.c
 delete mode 100644 drivers/misc/lsi-ncr.c
 delete mode 100644 drivers/misc/lsi-smmon.c
 create mode 100644 drivers/mtd/nand/axxia_acp_nand.c
 create mode 100644 drivers/mtd/nand/axxia_ubootenv.c
 delete mode 100644 drivers/mtd/nand/lsi_acp_nand.c
 delete mode 100644 drivers/mtd/nand/lsi_ubootenv.c
 create mode 100644 drivers/net/ethernet/axxia/Kconfig
 create mode 100644 drivers/net/ethernet/axxia/Makefile
 create mode 100644 drivers/net/ethernet/axxia/axxia_acp_mdio.c
 create mode 100644 drivers/net/ethernet/axxia/axxia_acp_net.c
 create mode 100644 drivers/net/ethernet/axxia/axxia_acp_net.h
 delete mode 100644 drivers/net/ethernet/lsi/Kconfig
 delete mode 100644 drivers/net/ethernet/lsi/Makefile
 delete mode 100644 drivers/net/ethernet/lsi/lsi_acp_mdio.c
 delete mode 100644 drivers/net/ethernet/lsi/lsi_acp_net.c
 delete mode 100644 drivers/net/ethernet/lsi/lsi_acp_net.h
 create mode 100644 drivers/rapidio/devices/axxia/Kconfig
 create mode 100644 drivers/rapidio/devices/axxia/Makefile
 create mode 100644 drivers/rapidio/devices/axxia/axxia-rio-irq.c
 create mode 100644 drivers/rapidio/devices/axxia/axxia-rio-irq.h
 create mode 100644 drivers/rapidio/devices/axxia/axxia-rio-sysfs.c
 create mode 100644 drivers/rapidio/devices/axxia/axxia-rio.c
 create mode 100644 drivers/rapidio/devices/axxia/axxia-rio.h
 delete mode 100644 drivers/rapidio/devices/lsi/Kconfig
 delete mode 100644 drivers/rapidio/devices/lsi/Makefile
 delete mode 100644 drivers/rapidio/devices/lsi/axxia-rio-irq.c
 delete mode 100644 drivers/rapidio/devices/lsi/axxia-rio-irq.h
 delete mode 100644 drivers/rapidio/devices/lsi/axxia-rio-sysfs.c
 delete mode 100644 drivers/rapidio/devices/lsi/axxia-rio.c
 delete mode 100644 drivers/rapidio/devices/lsi/axxia-rio.h
 create mode 100644 drivers/tty/serial/axxia_acp_serial.c
 delete mode 100644 drivers/tty/serial/lsi_acp_serial.c
 create mode 100644 include/linux/axxia-ncr.h
 create mode 100644 include/linux/axxia_mtc_ioctl.h
 delete mode 100644 include/linux/lsi-ncr.h
 delete mode 100644 include/linux/lsi_mtc_ioctl.h

diff --git a/Documentation/devicetree/bindings/arm/axxia.txt b/Documentation/devicetree/bindings/arm/axxia.txt
index 7b4ef9c..ccd7994 100644
--- a/Documentation/devicetree/bindings/arm/axxia.txt
+++ b/Documentation/devicetree/bindings/arm/axxia.txt
@@ -1,12 +1,12 @@
-Axxia AXM55xx device tree bindings
+INTEL Axxia AXM55xx device tree bindings
 
 Boards using the AXM55xx SoC need to have the following properties:
 
 Required root node property:
 
-  - compatible = "lsi,axm5516"
+  - compatible = "axxia,axm5516"
 
 Boards:
 
   LSI AXM5516 Validation board (Amarillo)
-	compatible = "lsi,axm5516-amarillo", "lsi,axm5516"
+	compatible = "axxia,axm5516-amarillo", "axxia,axm5516"
diff --git a/Documentation/devicetree/bindings/arm/axxia/edac_cpu.txt b/Documentation/devicetree/bindings/arm/axxia/edac_cpu.txt
index da12bd5..d867ec2 100644
--- a/Documentation/devicetree/bindings/arm/axxia/edac_cpu.txt
+++ b/Documentation/devicetree/bindings/arm/axxia/edac_cpu.txt
@@ -3,7 +3,7 @@ The EDAC accesses ARM v7/v8 CPUMERRSR_EL1 register data.
 
 Required properties:
 - compatible 	: should contain "intel,cortex-a57-cpu" for AXM56xx
-		: should contain "lsi,cortex-a15-cpu" for AXM55xx
+		: should contain "axxia,cortex-a15-cpu" for AXM55xx
 - syscon	: should referernce syscon node for both 55xx/56xx
 
 Example:
diff --git a/Documentation/devicetree/bindings/arm/axxia/edac_l1.txt b/Documentation/devicetree/bindings/arm/axxia/edac_l1.txt
index 5e0a8dc..e459e4a 100644
--- a/Documentation/devicetree/bindings/arm/axxia/edac_l1.txt
+++ b/Documentation/devicetree/bindings/arm/axxia/edac_l1.txt
@@ -4,7 +4,7 @@ The EDAC accesses ARM v7/v8 L2MERRSR_EL1 register data.
 Required properties:
 - compatible	: should contain "intel,cortex-a53-cpu" for AXM67xx
 		: should contain "intel,cortex-a57-cpu" for AXM56xx
-		: should contain "lsi,cortex-a15-cpu" for AXM55xx
+		: should contain "axxia,cortex-a15-cpu" for AXM55xx
 - syscon	: should referernce syscon node for both 55xx/56xx/67xx
 
 Example:
diff --git a/Documentation/devicetree/bindings/arm/axxia/edac_l2.txt b/Documentation/devicetree/bindings/arm/axxia/edac_l2.txt
index b99e77a..1a7ebff 100644
--- a/Documentation/devicetree/bindings/arm/axxia/edac_l2.txt
+++ b/Documentation/devicetree/bindings/arm/axxia/edac_l2.txt
@@ -4,7 +4,7 @@ The EDAC accesses ARM v7/v8 L2MERRSR_EL1 register data.
 Required properties:
 - compatible	: should contain "intel,cortex-a53-l2-cache" for AXM67xx
 		: should contain "intel,cortex-a57-l2-cache" for AXM56xx
-		: should contain "lsi,cortex-a15-l2-cache" for AXM55xx
+		: should contain "axxia,cortex-a15-l2-cache" for AXM55xx
 - syscon	: should referernce syscon node for both 55xx/56xx/67xx
 
 Example:
diff --git a/Documentation/devicetree/bindings/clock/axxia,axm5516-clks.txt b/Documentation/devicetree/bindings/clock/axxia,axm5516-clks.txt
new file mode 100644
index 0000000..4795e4b
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/axxia,axm5516-clks.txt
@@ -0,0 +1,27 @@
+AXM5516 clock driver bindings
+-----------------------------
+
+Required properties :
+- compatible : shall contain "axxia,axm5516-clks"
+- reg : shall contain base register location and length
+- #clock-cells : shall contain 1
+
+The consumer specifies the desired clock by having the clock ID in its "clocks"
+phandle cell. See <dt-bindings/clock/axxia,axxia-clock.h> for the list of
+supported clock IDs.
+
+Example:
+
+clks: clock-controller@2010020000 {
+	compatible = "axxia,axm5516-clks";
+	#clock-cells = <1>;
+	reg = <0x20 0x10020000 0 0x20000>;
+};
+
+serial0: uart@2010080000 {
+	compatible = "arm,pl011", "arm,primecell";
+	reg = <0x20 0x10080000 0 0x1000>;
+	interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+	clocks = <&clks AXXIA_CLK_PER>;
+	clock-names = "apb_pclk";
+};
diff --git a/Documentation/devicetree/bindings/clock/lsi,axm5516-clks.txt b/Documentation/devicetree/bindings/clock/lsi,axm5516-clks.txt
deleted file mode 100644
index 3ce97cf..0000000
--- a/Documentation/devicetree/bindings/clock/lsi,axm5516-clks.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-AXM5516 clock driver bindings
------------------------------
-
-Required properties :
-- compatible : shall contain "lsi,axm5516-clks"
-- reg : shall contain base register location and length
-- #clock-cells : shall contain 1
-
-The consumer specifies the desired clock by having the clock ID in its "clocks"
-phandle cell. See <dt-bindings/clock/lsi,axxia-clock.h> for the list of
-supported clock IDs.
-
-Example:
-
-	clks: clock-controller@2010020000 {
-		compatible = "lsi,axm5516-clks";
-		#clock-cells = <1>;
-		reg = <0x20 0x10020000 0 0x20000>;
-	};
-
-	serial0: uart@2010080000 {
-		compatible = "arm,pl011", "arm,primecell";
-		reg = <0x20 0x10080000 0 0x1000>;
-		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
-		clocks = <&clks AXXIA_CLK_PER>;
-		clock-names = "apb_pclk";
-	};
-																																};
-
diff --git a/Documentation/devicetree/bindings/hwrng/axxia_rng.txt b/Documentation/devicetree/bindings/hwrng/axxia_rng.txt
index acdf2e57..b219ea7 100644
--- a/Documentation/devicetree/bindings/hwrng/axxia_rng.txt
+++ b/Documentation/devicetree/bindings/hwrng/axxia_rng.txt
@@ -3,13 +3,13 @@ AXXIA TRNG HWRNG Driver Module
 Required properties:
 
 - compatible : Should contain entries for this.
-  - "lsi,trng" for AXXIA devices
+  - "axxia,trng" for AXXIA devices
 - reg : Offset and length of the register set for the module
 - interrupts : the interrupt number for the TRNG module.
 
 Example:
 trng: trng@8031060000 {
-	compatible = "lsi,trng";
+	compatible = "axxia,trng";
 	reg = <0x80 0x31060000 0x20000>;
 	interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
 };
diff --git a/Documentation/devicetree/bindings/i2c/i2c-axxia.txt b/Documentation/devicetree/bindings/i2c/i2c-axxia.txt
index 2296d78..ffa5fc4 100644
--- a/Documentation/devicetree/bindings/i2c/i2c-axxia.txt
+++ b/Documentation/devicetree/bindings/i2c/i2c-axxia.txt
@@ -1,7 +1,7 @@
-LSI Axxia I2C
+INTEL Axxia I2C
 
 Required properties :
-- compatible : Must be "lsi,api2c"
+- compatible : Must be "axxia,api2c"
 - reg : Offset and length of the register set for the device
 - interrupts : the interrupt specifier
 - #address-cells : Must be <1>;
@@ -18,7 +18,7 @@ Optional properties :
 Example :
 
 i2c@02010084000 {
-	compatible = "lsi,api2c";
+	compatible = "axxia,api2c";
 	device_type = "i2c";
 	#address-cells = <1>;
 	#size-cells = <0>;
diff --git a/Documentation/devicetree/bindings/misc/axxia-mtc.txt b/Documentation/devicetree/bindings/misc/axxia-mtc.txt
new file mode 100644
index 0000000..e2ad143
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/axxia-mtc.txt
@@ -0,0 +1,15 @@
+* INTEL Axxia Master Test Controller (MTC)
+
+Required properties:
+- compatible : Should be "axxia,mtc"
+- reg : Address and length of the register set for the device
+  registers)
+- interrupts : Should contain MTC interrupt
+
+
+Example:
+mtc: mtc@8080210000 {
+		compatible = "axxia,mtc";
+		reg = <0x80 0x80210000 0x10000>;
+		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+};
diff --git a/Documentation/devicetree/bindings/misc/lsi-mtc.txt b/Documentation/devicetree/bindings/misc/lsi-mtc.txt
deleted file mode 100644
index c6bca89..0000000
--- a/Documentation/devicetree/bindings/misc/lsi-mtc.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-* LSI Master Test Controller (MTC)
-
-Required properties:
-- compatible : Should be "lsi,mtc"
-- reg : Address and length of the register set for the device
-  registers)
-- interrupts : Should contain MTC interrupt
-
-
-Example:
-mtc: mtc@8080210000 {
-		compatible = "lsi,mtc";
-		reg = <0x80 0x80210000 0x10000>;
-		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
-};
diff --git a/Documentation/devicetree/bindings/net/axxia-femac.txt b/Documentation/devicetree/bindings/net/axxia-femac.txt
new file mode 100644
index 0000000..add8253
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/axxia-femac.txt
@@ -0,0 +1,20 @@
+* INTEL Axxia Fast Ethernet Controller (FEMAC)
+
+Required properties:
+- compatible : Should be "axxia,femac"
+- reg : Address and length of the register set for the device (RX, TX and DMA
+  registers)
+- interrupts : Should contain FEMAC DMA interrupt
+
+Optional properties:
+- local-mac-address or mac-address: 6 bytes, mac address
+
+Example:
+
+ethernet@2010120000 {
+	compatible = "axxia,femac";
+	reg = <0x20 0x10120000 0 0x1000>,
+	      <0x20 0x10121000 0 0x1000>,
+	      <0x20 0x10122000 0 0x1000>;
+	interrupts = <0 4 4>;
+};
diff --git a/Documentation/devicetree/bindings/net/axxia-mdio.txt b/Documentation/devicetree/bindings/net/axxia-mdio.txt
new file mode 100644
index 0000000..20ade5c
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/axxia-mdio.txt
@@ -0,0 +1,26 @@
+* INTEL Axxia Fast Ethernet Controller (FEMAC)
+
+Required properties:
+- compatible : Should be "axxia,axm-mdio"
+- reg : Address and length of the register set.
+- #address-cells : Must be 1.
+- #size-cells : Must be 0.
+
+Optional properties:
+- axxia,mdio-clk-offset : Set value used to offset the MDIO output signal. A
+value of N means the MDIO output signal is held for (N + 1) clk_per units long.
+- axxia,mdio-clk-period : Set value used to offset the MDC signal. A value of N
+means the MDC signal is 2 x (N + 1) clk_per units long.
+
+Example:
+
+mdio@2010090000 {
+	compatible = "axxia,axm-mdio";
+	reg = <0x20 0x10090000 0 0x1000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	phy0: ethernet-phy@1e {
+		reg = <0x1e>;
+	};
+};
diff --git a/Documentation/devicetree/bindings/net/lsi-femac.txt b/Documentation/devicetree/bindings/net/lsi-femac.txt
deleted file mode 100644
index e5af847..0000000
--- a/Documentation/devicetree/bindings/net/lsi-femac.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-* LSI Fast Ethernet Controller (FEMAC)
-
-Required properties:
-- compatible : Should be "lsi,femac"
-- reg : Address and length of the register set for the device (RX, TX and DMA
-  registers)
-- interrupts : Should contain FEMAC DMA interrupt
-
-Optional properties:
-- local-mac-address or mac-address: 6 bytes, mac address
-
-Example:
-
-ethernet@2010120000 {
-	compatible = "lsi,femac";
-	reg = <0x20 0x10120000 0 0x1000>,
-	      <0x20 0x10121000 0 0x1000>,
-	      <0x20 0x10122000 0 0x1000>;
-	interrupts = <0 4 4>;
-};
diff --git a/Documentation/devicetree/bindings/net/lsi-mdio.txt b/Documentation/devicetree/bindings/net/lsi-mdio.txt
deleted file mode 100644
index 45b76359..0000000
--- a/Documentation/devicetree/bindings/net/lsi-mdio.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-* LSI Fast Ethernet Controller (FEMAC)
-
-Required properties:
-- compatible : Should be "lsi,axm-mdio"
-- reg : Address and length of the register set.
-- #address-cells : Must be 1.
-- #size-cells : Must be 0.
-
-Optional properties:
-- lsi,mdio-clk-offset : Set value used to offset the MDIO output signal. A
-value of N means the MDIO output signal is held for (N + 1) clk_per units long.
-- lsi,mdio-clk-period : Set value used to offset the MDC signal. A value of N
-means the MDC signal is 2 x (N + 1) clk_per units long.
-
-Example:
-
-mdio@2010090000 {
-	compatible = "lsi,axm-mdio";
-	reg = <0x20 0x10090000 0 0x1000>;
-	#address-cells = <1>;
-	#size-cells = <0>;
-
-	phy0: ethernet-phy@1e {
-		reg = <0x1e>;
-	};
-};
diff --git a/Documentation/devicetree/bindings/pci/intel,axxia-pcie.txt b/Documentation/devicetree/bindings/pci/intel,axxia-pcie.txt
index c7dbcac..9f65b3b 100644
--- a/Documentation/devicetree/bindings/pci/intel,axxia-pcie.txt
+++ b/Documentation/devicetree/bindings/pci/intel,axxia-pcie.txt
@@ -1,7 +1,7 @@
 * Intel Axxia Designware PCIe interface
 
 Required properties:
-- compatible: should contain "intel,axxia-pcie" to identify the core.
+- compatible: should contain "axxia,axxia-pcie" to identify the core.
 - reg: Should contain the DBI, AXI GPREG and CC GPREG address space.
 - reg-names: Must be "dbi" for the DBI, "axi_gpreg" for
 	AXI GPREG and "cc_gpreg" for CC GPREG address space.
@@ -14,7 +14,7 @@ Required properties:
 
 Example:
 	pci0: pcie@c000000000 {
-		compatible = "intel,axxia-pcie";
+		compatible = "axxia,axxia-pcie";
 		device_type = "pci";
 		reg = <0xa0 0x02000000 0x00100000 /* dbi */
 			0xa0 0x03000000 0x00008000 /* AXI gpreg */
diff --git a/Documentation/devicetree/bindings/power/reset/axxia-reset.txt b/Documentation/devicetree/bindings/power/reset/axxia-reset.txt
index 47e720d..27ffc19 100644
--- a/Documentation/devicetree/bindings/power/reset/axxia-reset.txt
+++ b/Documentation/devicetree/bindings/power/reset/axxia-reset.txt
@@ -1,20 +1,20 @@
-Axxia Restart Driver
+INTEL Axxia Restart Driver
 
 This driver can do reset of the Axxia SoC. It uses the registers in the syscon
 block to initiate a chip reset.
 
 Required Properties:
-  -compatible: "lsi,axm55xx-reset"
+  -compatible: "axxia,axm55xx-reset"
   -syscon: phandle to the syscon node.
 
 Example:
 
 	syscon: syscon@2010030000 {
-		compatible = "lsi,axxia-syscon", "syscon";
+		compatible = "axxia,axxia-syscon", "syscon";
 		reg = <0x20 0x10030000 0 0x2000>;
 	};
 
 	reset: reset@2010031000 {
-		compatible = "lsi,axm55xx-reset";
+		compatible = "axxia,axm55xx-reset";
 		syscon = <&syscon>;
 	};
diff --git a/Documentation/devicetree/bindings/rapidio/intel,axxia-rapidio.txt b/Documentation/devicetree/bindings/rapidio/intel,axxia-rapidio.txt
index 9e329a3..8fc2ac03 100644
--- a/Documentation/devicetree/bindings/rapidio/intel,axxia-rapidio.txt
+++ b/Documentation/devicetree/bindings/rapidio/intel,axxia-rapidio.txt
@@ -1,7 +1,7 @@
 * Intel Axxia Designware Serial RapidIO interface
 
 Required properties:
-- compatible: should contain "intel,axxia-rapidio" to identify the core.
+- compatible: should contain "axxia,axxia-rapidio" to identify the core.
 - reg: Should contain the sRIO Register address space.
 - #address-cells: set to <2>
 - #size-cells: set to <2>
@@ -13,7 +13,7 @@ Required properties:
 Example:
 	rio0: rapidio@0xb000000000 {
 		index = <0>;
-		compatible = "intel,axxia-rapidio";
+		compatible = "axxia,axxia-rapidio";
 		device_type = "rapidio";
 		reg = <0xa0 0x00020000 0 0x00001000>;
 		#address-cells = <2>;
diff --git a/Documentation/devicetree/bindings/usb/intel,axxia-dwc3.txt b/Documentation/devicetree/bindings/usb/intel,axxia-dwc3.txt
index 3b5b1fc..4a99057 100644
--- a/Documentation/devicetree/bindings/usb/intel,axxia-dwc3.txt
+++ b/Documentation/devicetree/bindings/usb/intel,axxia-dwc3.txt
@@ -1,14 +1,14 @@
 Intel Axxia DWC3 USB SoC controller
 
 Required properties:
-- compatible:	should contain "intel,axxia-dwc3"
+- compatible:	should contain "axxia,axxia-dwc3"
 
 Required child node:
 A child node must exist to represent the core DWC3 IP block. The content
 of the node is defined in dwc3.txt.
 
 	usb0: usb@9000000000 {
-		compatible = "intel,axxia-dwc3";
+		compatible = "axxia,axxia-dwc3";
 		dma-coherent;
 		status = "disabled";
 		#address-cells = <2>;
diff --git a/arch/arm/boot/dts/axm5504-cpus.dtsi b/arch/arm/boot/dts/axm5504-cpus.dtsi
index f76d716..05efd2a 100644
--- a/arch/arm/boot/dts/axm5504-cpus.dtsi
+++ b/arch/arm/boot/dts/axm5504-cpus.dtsi
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5504-cpus.dtsi
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/boot/dts/axm5504-emu.dts b/arch/arm/boot/dts/axm5504-emu.dts
index 0e37f8e..531067e 100644
--- a/arch/arm/boot/dts/axm5504-emu.dts
+++ b/arch/arm/boot/dts/axm5504-emu.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5504-emulation.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Emulation Platform AXM5500";
-	compatible = "lsi,axm5500-emu", "lsi,axm5500";
+	compatible = "axxia,axm5500-emu", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5504-sim-mmc.dts b/arch/arm/boot/dts/axm5504-sim-mmc.dts
index 22ee70f..8b19a1b 100644
--- a/arch/arm/boot/dts/axm5504-sim-mmc.dts
+++ b/arch/arm/boot/dts/axm5504-sim-mmc.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5504-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM5500";
-	compatible = "lsi,axm5500-sim", "lsi,axm5500";
+	compatible = "axxia,axm5500-sim", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5504-sim-virtio.dts b/arch/arm/boot/dts/axm5504-sim-virtio.dts
index da047c7..777299f 100644
--- a/arch/arm/boot/dts/axm5504-sim-virtio.dts
+++ b/arch/arm/boot/dts/axm5504-sim-virtio.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5504-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM5500";
-	compatible = "lsi,axm5500-sim", "lsi,axm5500";
+	compatible = "axxia,axm5500-sim", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5504-sim.dts b/arch/arm/boot/dts/axm5504-sim.dts
index 088a468..68d029c 100644
--- a/arch/arm/boot/dts/axm5504-sim.dts
+++ b/arch/arm/boot/dts/axm5504-sim.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM55xx";
-	compatible = "lsi,axm5516-sim", "lsi,axm5516";
+	compatible = "axxia,axm5516-sim", "axxia,axm5516";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5507-cpus.dtsi b/arch/arm/boot/dts/axm5507-cpus.dtsi
index a32372b..b1e0758 100644
--- a/arch/arm/boot/dts/axm5507-cpus.dtsi
+++ b/arch/arm/boot/dts/axm5507-cpus.dtsi
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5508-cpus.dtsi
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/boot/dts/axm5507-emu.dts b/arch/arm/boot/dts/axm5507-emu.dts
index 2fc938b..cdc0e50 100644
--- a/arch/arm/boot/dts/axm5507-emu.dts
+++ b/arch/arm/boot/dts/axm5507-emu.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5507-emu.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Emulation Platform AXM5500";
-	compatible = "lsi,axm5500-emu", "lsi,axm5500";
+	compatible = "axxia,axm5500-emu", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5508-amarillo.dts b/arch/arm/boot/dts/axm5508-amarillo.dts
index 0d67253..3be8951 100644
--- a/arch/arm/boot/dts/axm5508-amarillo.dts
+++ b/arch/arm/boot/dts/axm5508-amarillo.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5508-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Amarillo AXM5500";
-	compatible = "lsi,axm5500-amarillo", "lsi,axm5500";
+	compatible = "axxia,axm5500-amarillo", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5508-cpus.dtsi b/arch/arm/boot/dts/axm5508-cpus.dtsi
index 85ee3e4..fb722b6 100644
--- a/arch/arm/boot/dts/axm5508-cpus.dtsi
+++ b/arch/arm/boot/dts/axm5508-cpus.dtsi
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5508-cpus.dtsi
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/boot/dts/axm5512-amarillo.dts b/arch/arm/boot/dts/axm5512-amarillo.dts
index 50bfb9b..abf877b 100644
--- a/arch/arm/boot/dts/axm5512-amarillo.dts
+++ b/arch/arm/boot/dts/axm5512-amarillo.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5512-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Amarillo AXM5500";
-	compatible = "lsi,axm5500-amarillo", "lsi,axm5500";
+	compatible = "axxia,axm5500-amarillo", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5512-cpus.dtsi b/arch/arm/boot/dts/axm5512-cpus.dtsi
index b45a344..0be01d5 100644
--- a/arch/arm/boot/dts/axm5512-cpus.dtsi
+++ b/arch/arm/boot/dts/axm5512-cpus.dtsi
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5512-cpus.dtsi
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/boot/dts/axm5516-amarillo.dts b/arch/arm/boot/dts/axm5516-amarillo.dts
index f49b51b..b56f0bb 100644
--- a/arch/arm/boot/dts/axm5516-amarillo.dts
+++ b/arch/arm/boot/dts/axm5516-amarillo.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Amarillo AXM5500";
-	compatible = "lsi,axm5500-amarillo", "lsi,axm5500";
+	compatible = "axxia,axm5500-amarillo", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5516-cpus.dtsi b/arch/arm/boot/dts/axm5516-cpus.dtsi
index 923f92ea..bd25250 100644
--- a/arch/arm/boot/dts/axm5516-cpus.dtsi
+++ b/arch/arm/boot/dts/axm5516-cpus.dtsi
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-cpus.dtsi
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/boot/dts/axm5516-sim-common.dts b/arch/arm/boot/dts/axm5516-sim-common.dts
index abbd00a..7ffa575 100644
--- a/arch/arm/boot/dts/axm5516-sim-common.dts
+++ b/arch/arm/boot/dts/axm5516-sim-common.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-sim.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM5500";
-	compatible = "lsi,axm5500-sim", "lsi,axm5500";
+	compatible = "axxia,axm5500-sim", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5516-sim-mmc.dts b/arch/arm/boot/dts/axm5516-sim-mmc.dts
index e9fe852..d31e2ac 100644
--- a/arch/arm/boot/dts/axm5516-sim-mmc.dts
+++ b/arch/arm/boot/dts/axm5516-sim-mmc.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-sim.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM5500";
-	compatible = "lsi,axm5500-sim", "lsi,axm5500";
+	compatible = "axxia,axm5500-sim", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5516-sim-virtio.dts b/arch/arm/boot/dts/axm5516-sim-virtio.dts
index eeaff79..11ffed4 100644
--- a/arch/arm/boot/dts/axm5516-sim-virtio.dts
+++ b/arch/arm/boot/dts/axm5516-sim-virtio.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-sim.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM5500";
-	compatible = "lsi,axm5500-sim", "lsi,axm5500";
+	compatible = "axxia,axm5500-sim", "axxia,axm5500";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm5516-sim.dts b/arch/arm/boot/dts/axm5516-sim.dts
index c3e3ff1..82ed1b2 100644
--- a/arch/arm/boot/dts/axm5516-sim.dts
+++ b/arch/arm/boot/dts/axm5516-sim.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm5516-amarillo.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
 
 / {
 	model = "Simulation Platform AXM55xx";
-	compatible = "lsi,axm5516-sim", "lsi,axm5516";
+	compatible = "axxia,axm5516-sim", "axxia,axm5516";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm/boot/dts/axm55xx.dtsi b/arch/arm/boot/dts/axm55xx.dtsi
index b08b563..03be6eb 100644
--- a/arch/arm/boot/dts/axm55xx.dtsi
+++ b/arch/arm/boot/dts/axm55xx.dtsi
@@ -1,7 +1,7 @@
 /*
  * arch/arm/boot/dts/axm55xx.dtsi
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -68,7 +68,7 @@
 	};
 
 	edac: edac0@0x1000 {
-		compatible = "lsi,edac";
+		compatible = "axxia,edac";
 		reg = <0 0x00220000 0 0x1000>,
 			<0 0x000f0000 0 0x1000>,
 			<0x20 0x10030000 0 0001000>,
@@ -94,12 +94,12 @@
 	};
 
 	perf_platform: perf_platform {
-		compatible = "lsi,axm-platformperf";
+		compatible = "axxia,axm-platformperf";
 		status = "disabled";
 	};
 
 	sm0: sm0@00220000 {
-		compatible = "lsi,smmon";
+		compatible = "axxia,smmon";
 		reg = <0 0x00220000 0 0x1000>,
 			<0x20 0x10030000 0 0001000>;
 		interrupts = <0 161 4>;
@@ -107,7 +107,7 @@
 	};
 
 	sm1: sm1@00220000 {
-		compatible = "lsi,smmon";
+		compatible = "axxia,smmon";
 		reg = <0 0x000f0000 0 0x1000>,
 			<0x20 0x10030000 0 0001000>;
 		interrupts = <0 160 4>;
@@ -115,7 +115,7 @@
 	};
 
 	femac: femac@0x2010120000 {
-		compatible = "lsi,acp-femac";
+		compatible = "axxia,acp-femac";
 		device_type = "network";
 		reg = <0x20 0x10120000 0 0x1000>,
 		      <0x20 0x10121000 0 0x1000>,
@@ -142,7 +142,7 @@
 		ranges;
 
 		gpdma0: gpdma@2020140000 {
-			compatible = "lsi,dma32";
+			compatible = "axxia,dma32";
 			reg = <0x20 0x20140000 0x00 0x1000>;
 			interrupts = <0 60 4>,
 				     <0 61 4>;
@@ -157,7 +157,7 @@
 		};
 
 		gpdma1: gpdma@2020141000 {
-			compatible = "lsi,dma32";
+			compatible = "axxia,dma32";
 			reg = <0x20 0x20141000 0x00 0x1000>;
 			interrupts = <0 64 4>,
 				     <0 65 4>;
@@ -172,12 +172,12 @@
 		};
 
 		gpreg: gpreg@2010094000  {
-			compatible = "lsi,gpreg";
+			compatible = "axxia,gpreg";
 			reg = <0x20 0x10094000 0 0x1000>;
 		};
 
 		pcie0: pciex@0x3000000000 {
-			compatible = "lsi,plb-pciex";
+			compatible = "axxia,plb-pciex";
 			device_type = "pci";
 			#interrupt-cells = <1>;
 			#size-cells = <2>;
@@ -218,7 +218,7 @@
 		};
 
 		pcie1: pciex@0x3080000000 {
-			compatible = "lsi,plb-pciex";
+			compatible = "axxia,plb-pciex";
 			device_type = "pci";
 			#interrupt-cells = <1>;
 			#size-cells = <2>;
@@ -246,7 +246,7 @@
 			index = <0>;
 			#address-cells = <2>;
 			#size-cells = <2>;
-			compatible = "intel,axxia-rapidio";
+			compatible = "axxia,axxia-rapidio";
 			device_type = "rapidio";
 			reg = <0x0020 0x20142000 0x0 0x1000>; /* SRIO Conf 0 region */
 			ranges = <0x0 0x0 0x0031 0x00000000 0x0 0x40000000>;
@@ -261,7 +261,7 @@
 			index = <1>;
 			#address-cells = <2>;
 			#size-cells = <2>;
-			compatible = "intel,axxia-rapidio";
+			compatible = "axxia,axxia-rapidio";
 			device_type = "rapidio";
 			reg = <0x0020 0x20143000 0x0 0x1000>; /* SRIO Conf 1 region */
 			ranges = <0x0 0x0 0x0031 0x40000000 0x0 0x40000000>;
@@ -273,7 +273,7 @@
 		};
 
 		usb0: usb@004a4000 {
-			compatible = "lsi,acp-usb";
+			compatible = "axxia,acp-usb";
 			device_type = "usb";
 			reg = <0x20 0x10140000 0x0 0020000>,
 			      <0x20 0x10094000 0x0 0002000>;
@@ -283,7 +283,7 @@
 		};
 
 		i2c0: i2c@0x02010084000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			device_type = "i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -293,7 +293,7 @@
 		};
 
 		i2c1: i2c@0x02010085000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			device_type = "i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -303,7 +303,7 @@
 		};
 
 		i2c2: i2c@0x02010086000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			device_type = "i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -313,7 +313,7 @@
 		};
 
 		i2c3: i2c@0x02010087000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			device_type = "i2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -323,21 +323,21 @@
 		};
 
 		mtc: mtc@0x2010098000 {
-			compatible = "lsi,mtc";
+			compatible = "axxia,mtc";
 			reg = <0x20 0x10098000 0 0x3000>;
 			interrupts = <0 45 4>;
 			status = "disabled";
 		};
 
 		trng: trng@0x20101a0000 {
-			compatible = "lsi,trng";
+			compatible = "axxia,trng";
 			reg = <0x20 0x101a0000 0 0x20000>;
 			interrupts = <0 8 4>;
 			status = "disabled";
 		};
 
 		nca@2020100000 {
-			compatible = "lsi,nca";
+			compatible = "axxia,nca";
 			reg = <0x20 0x20100000 0 0x20000>;
 		};
 
@@ -419,7 +419,7 @@
 
 			spics: sspgpio@2010088030 {
 				#gpio-cells = <2>;
-				compatible = "lsi,ssp-gpio";
+				compatible = "axxia,ssp-gpio";
 				gpio-controller;
 				reg = <0x20 0x10088000 0x00 0x1000>;
 				status = "disabled";
diff --git a/arch/arm/mach-axxia/Kconfig b/arch/arm/mach-axxia/Kconfig
index 3f23fbb..08d4383 100644
--- a/arch/arm/mach-axxia/Kconfig
+++ b/arch/arm/mach-axxia/Kconfig
@@ -2,18 +2,18 @@ menu "Axxia platform type"
 	depends on ARCH_AXXIA
 
 config ARCH_AXXIA_GIC
-        bool "Multi-cluster ARM GIC support for the LSI Axxia platforms"
+        bool "Multi-cluster ARM GIC support for the INTEL Axxia platforms"
         select IRQ_DOMAIN
         select MULTI_IRQ_HANDLER
 	help
-	  The LSI Axxia platforms can have up to four clusters, each having
+	  The INTEL Axxia platforms can have up to four clusters, each having
 	  four cores (so a total of 16 cores). This requires the use of a
 	  distributed interrupt system in lieu of of a single ARM GIC.
 
 	  This option enables support for this multi-cluster setup.
 
 config ARCH_AXXIA_DT
-	bool "Device Tree support for LSI Axxia platforms"
+	bool "Device Tree support for INTEL Axxia platforms"
 	select ARCH_AXXIA_GIC
 	select ARM_PATCH_PHYS_VIRT
 	select AUTO_ZRELADDR
@@ -22,7 +22,7 @@ config ARCH_AXXIA_DT
 	select MIGHT_HAVE_CACHE_L2X0
 	select USE_OF
 	help
-	  The LSI Axxia platforms require a Flattened Device Tree to be passed
+	  The INTEL Axxia platforms require a Flattened Device Tree to be passed
 	  to the kernel.
 
 	  If your bootloader supports Flattened Device Tree based booting,
diff --git a/arch/arm/mach-axxia/Makefile b/arch/arm/mach-axxia/Makefile
index cae1d41..739b80d 100644
--- a/arch/arm/mach-axxia/Makefile
+++ b/arch/arm/mach-axxia/Makefile
@@ -10,6 +10,6 @@ obj-y					+= timers.o
 obj-y					+= ddr_retention.o ddr_shutdown.o
 obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o
 obj-$(CONFIG_ARCH_AXXIA_GIC)		+= axxia-gic.o
-obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o lsi_power_management.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o axxia_power_management.o
 #obj-$(CONFIG_AXXIA_RIO)                 += rapidio.o
 obj-$(CONFIG_HW_PERF_EVENTS)            += perf_event_platform.o smon.o
diff --git a/arch/arm/mach-axxia/axxia-gic.c b/arch/arm/mach-axxia/axxia-gic.c
index 3ed3f07..3b9a9e6 100644
--- a/arch/arm/mach-axxia/axxia-gic.c
+++ b/arch/arm/mach-axxia/axxia-gic.c
@@ -3,7 +3,7 @@
  *
  *  Cloned from linux/arch/arm/common/gic.c
  *
- *  Copyright (C) 2013 LSI Corporation
+ *  Copyright (C) 2013 INTEL Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -45,7 +45,7 @@
 #include <asm/mach/irq.h>
 
 #include <mach/axxia-gic.h>
-#include "lsi_power_management.h"
+#include "axxia_power_management.h"
 
 #define MAX_GIC_INTERRUPTS  1020
 
diff --git a/arch/arm/mach-axxia/axxia.c b/arch/arm/mach-axxia/axxia.c
index 6945c36..f130ddf 100644
--- a/arch/arm/mach-axxia/axxia.c
+++ b/arch/arm/mach-axxia/axxia.c
@@ -1,9 +1,9 @@
 /*
  * arch/arm/mach-axxia/axxia.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2012 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -38,7 +38,7 @@
 #include <linux/sizes.h>
 #include <linux/pmu.h>
 #include <linux/kexec.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #ifdef CONFIG_ARM_ARCH_TIMER
 #include <asm/arch_timer.h>
 #endif
@@ -57,7 +57,7 @@
 #endif
 
 static const char *axxia_dt_match[] __initconst = {
-	"lsi,axm5500",
+	"axxia,axm5500",
 	NULL
 };
 
@@ -134,7 +134,7 @@ void __init axxia_dt_timer_init(void)
 {
 	int is_sim;
 
-	is_sim = of_find_compatible_node(NULL, NULL, "lsi,axm5500-sim") != NULL;
+	is_sim = of_find_compatible_node(NULL, NULL, "axxia,axm5500-sim") != NULL;
 
 	axxia_init_clocks(is_sim);
 
@@ -197,7 +197,7 @@ void __init axxia_dt_timer_init(void)
 void __init axxia_dt_init(void)
 {
 	base = ioremap(0x2010000000, 0x40000);
-	if (!of_find_compatible_node(NULL, NULL, "lsi,axm5500-sim")) {
+	if (!of_find_compatible_node(NULL, NULL, "axxia,axm5500-sim")) {
 		dickens = ioremap(0x2000000000, SZ_16M);
 #ifdef CONFIG_KEXEC
 		kexec_reinit = flush_l3;
@@ -229,7 +229,7 @@ static void axxia_restart(enum reboot_mode mode, const char *cmd)
 	writel(0x00080802, base + 0x31008); /* Chip Reset */
 }
 
-DT_MACHINE_START(AXXIA_DT, "LSI Axxia")
+DT_MACHINE_START(AXXIA_DT, "INTEL Axxia")
 .dt_compat	= axxia_dt_match,
 	.smp		= smp_ops(axxia_smp_ops),
 	.map_io		= axxia_dt_map_io,
diff --git a/arch/arm/mach-axxia/axxia_power_management.c b/arch/arm/mach-axxia/axxia_power_management.c
new file mode 100644
index 0000000..85af898
--- /dev/null
+++ b/arch/arm/mach-axxia/axxia_power_management.c
@@ -0,0 +1,1350 @@
+/*
+ *  linux/arch/arm/mach-axxia/axxia_power_management.c
+ *
+ *  C *  Created on: Jun 19, 2014
+ *      Author: z8cpaul
+ *  opyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Created on: Jun 19, 2014
+ *      Author: z8cpaul
+ */
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/delay.h>
+#include <linux/of_address.h>
+#include <asm/exception.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include <asm/cp15.h>
+
+#include "axxia.h"
+#include <mach/axxia-gic.h>
+#include "axxia_power_management.h"
+
+#undef DEBUG_CPU_PM
+
+#define PM_WAIT_TIME (10000)
+#define MAX_CLUSTER  (4)
+#define IPI_IRQ_MASK (0xFFFF)
+
+#define CHECK_BIT(var, pos) ((var) & (1 << (pos)))
+
+bool pm_in_progress[16];
+bool cluster_power_up[4];
+
+static const u32 cluster_to_node[MAX_CLUSTER] = { DKN_CLUSTER0_NODE,
+DKN_CLUSTER1_NODE,
+DKN_CLUSTER2_NODE,
+DKN_CLUSTER3_NODE };
+
+static const u32 cluster_to_poreset[MAX_CLUSTER] = {
+PORESET_CLUSTER0,
+PORESET_CLUSTER1,
+PORESET_CLUSTER2,
+PORESET_CLUSTER3 };
+
+static const u32 cluster_to_mask[MAX_CLUSTER] = {
+		IPI0_MASK,
+		IPI1_MASK,
+		IPI2_MASK,
+		IPI3_MASK
+};
+
+static const u32 ipi_register[MAX_IPI] = {
+		NCP_SYSCON_MASK_IPI0,
+		NCP_SYSCON_MASK_IPI1,
+		NCP_SYSCON_MASK_IPI2,
+		NCP_SYSCON_MASK_IPI3,
+		NCP_SYSCON_MASK_IPI4,
+		NCP_SYSCON_MASK_IPI5,
+		NCP_SYSCON_MASK_IPI6,
+		NCP_SYSCON_MASK_IPI7,
+		NCP_SYSCON_MASK_IPI8,
+		NCP_SYSCON_MASK_IPI9,
+		NCP_SYSCON_MASK_IPI10,
+		NCP_SYSCON_MASK_IPI11,
+		NCP_SYSCON_MASK_IPI12,
+		NCP_SYSCON_MASK_IPI13,
+		NCP_SYSCON_MASK_IPI14,
+		NCP_SYSCON_MASK_IPI15,
+		NCP_SYSCON_MASK_IPI16,
+		NCP_SYSCON_MASK_IPI17,
+		NCP_SYSCON_MASK_IPI18
+};
+
+enum pm_error_code {
+	PM_ERR_DICKENS_IOREMAP = 200,
+	PM_ERR_DICKENS_SNOOP_DOMAIN,
+	PM_ERR_FAILED_PWR_DWN_RAM,
+	PM_ERR_FAILED_STAGE_1,
+	PM_ERR_ACK1_FAIL,
+	PM_ERR_RAM_ACK_FAIL,
+	PM_ERR_FAIL_L2ACK,
+	PM_ERR_FAIL_L2HSRAM
+};
+
+u32 pm_cpu_powered_down;
+
+/*======================= LOCAL FUNCTIONS ==============================*/
+static void pm_set_bits_syscon_register(u32 reg, u32 data);
+static void pm_or_bits_syscon_register(u32 reg, u32 data);
+static void pm_clear_bits_syscon_register(u32 reg, u32 data);
+static bool pm_test_for_bit_with_timeout(u32 reg, u32 bit);
+static bool pm_wait_for_bit_clear_with_timeout(u32 reg, u32 bit);
+static void pm_dickens_logical_shutdown(u32 cluster);
+static int pm_dickens_logical_powerup(u32 cluster);
+static int pm_cpu_physical_isolation_and_power_down(int cpu);
+static void pm_L2_isolation_and_power_down(int cluster);
+static int pm_cpu_physical_connection_and_power_up(int cpu);
+static int pm_L2_physical_connection_and_power_up(u32 cluster);
+static int pm_L2_logical_powerup(u32 cluster, u32 cpu);
+
+static bool pm_first_cpu_of_cluster(u32 cpu)
+{
+#ifdef CONFIG_HOTPLUG_CPU_L2_POWER_DOWN
+
+	u32 count = 0;
+
+	switch (cpu) {
+	case (0):
+	case (1):
+	case (2):
+	case (3):
+		/* This will never happen because cpu 0 will never be turned off */
+		break;
+	case (4):
+	case (5):
+	case (6):
+	case (7):
+		if (pm_cpu_powered_down & (1 << 4))
+			count++;
+		if (pm_cpu_powered_down & (1 << 5))
+			count++;
+		if (pm_cpu_powered_down & (1 << 6))
+			count++;
+		if (pm_cpu_powered_down & (1 << 7))
+			count++;
+		if (count == 4)
+			return true;
+		break;
+	case (8):
+	case (9):
+	case (10):
+	case (11):
+		if (pm_cpu_powered_down & (1 << 8))
+			count++;
+		if (pm_cpu_powered_down & (1 << 9))
+			count++;
+		if (pm_cpu_powered_down & (1 << 10))
+			count++;
+		if (pm_cpu_powered_down & (1 << 11))
+			count++;
+		if (count == 4)
+			return true;
+		break;
+	case (12):
+	case (13):
+	case (14):
+	case (15):
+		if (pm_cpu_powered_down & (1 << 12))
+			count++;
+		if (pm_cpu_powered_down & (1 << 13))
+			count++;
+		if (pm_cpu_powered_down & (1 << 14))
+			count++;
+		if (pm_cpu_powered_down & (1 << 15))
+			count++;
+		if (count == 4)
+			return true;
+		break;
+	default:
+		pr_err("ERROR: the cpu does not exist: %d - %s:%d\n", cpu, __FILE__,
+				__LINE__);
+		break;
+	}
+#endif
+	return false;
+}
+
+bool pm_cpu_last_of_cluster(u32 cpu)
+{
+#ifdef CONFIG_HOTPLUG_CPU_L2_POWER_DOWN
+
+	u32 count = 0;
+
+	switch (cpu) {
+	case (0):
+	case (1):
+	case (2):
+	case (3):
+		/* This will never happen because cpu 0 will never be turned off */
+		break;
+	case (4):
+	case (5):
+	case (6):
+	case (7):
+		if (pm_cpu_powered_down & (1 << 4))
+			count++;
+		if (pm_cpu_powered_down & (1 << 5))
+			count++;
+		if (pm_cpu_powered_down & (1 << 6))
+			count++;
+		if (pm_cpu_powered_down & (1 << 7))
+			count++;
+		if (count == 3)
+			return true;
+		break;
+	case (8):
+	case (9):
+	case (10):
+	case (11):
+		if (pm_cpu_powered_down & (1 << 8))
+			count++;
+		if (pm_cpu_powered_down & (1 << 9))
+			count++;
+		if (pm_cpu_powered_down & (1 << 10))
+			count++;
+		if (pm_cpu_powered_down & (1 << 11))
+			count++;
+		if (count == 3)
+			return true;
+		break;
+	case (12):
+	case (13):
+	case (14):
+	case (15):
+		if (pm_cpu_powered_down & (1 << 12))
+			count++;
+		if (pm_cpu_powered_down & (1 << 13))
+			count++;
+		if (pm_cpu_powered_down & (1 << 14))
+			count++;
+		if (pm_cpu_powered_down & (1 << 15))
+			count++;
+		if (count == 3)
+			return true;
+		break;
+	default:
+		pr_err("ERROR: the cpu does not exist: %d - %s:%d\n", cpu,  __FILE__,
+				__LINE__);
+		break;
+	}
+#endif
+	return false;
+}
+
+static void pm_set_bits_syscon_register(u32 reg, u32 data)
+{
+	writel(data, syscon + reg);
+}
+
+static void pm_or_bits_syscon_register(u32 reg, u32 data)
+{
+	u32 tmp;
+
+	tmp = readl(syscon + reg);
+	tmp |= data;
+	writel(tmp, syscon + reg);
+}
+
+
+static void pm_clear_bits_syscon_register(u32 reg, u32 data)
+{
+	u32 tmp;
+
+	tmp = readl(syscon + reg);
+	tmp &= ~(data);
+	writel(tmp, syscon + reg);
+}
+
+static bool pm_test_for_bit_with_timeout(u32 reg, u32 bit)
+{
+
+	u32 tmp = 0;
+	u32 cnt = 0;
+
+	while (cnt < PM_WAIT_TIME) {
+		tmp = readl(syscon + reg);
+		if (CHECK_BIT(tmp, bit))
+			break;
+		cnt++;
+	}
+	if (cnt == PM_WAIT_TIME) {
+		pr_err("reg=0x%x tmp:=0x%x\n", reg, tmp);
+		return false;
+	}
+	return true;
+}
+
+static bool pm_wait_for_bit_clear_with_timeout(u32 reg, u32 bit)
+{
+	u32 cnt = 0;
+	u32 tmp = 0;
+
+	while (cnt < PM_WAIT_TIME) {
+		tmp = readl(syscon + reg);
+		if (!(CHECK_BIT(tmp, bit)))
+			break;
+		cnt++;
+	}
+	if (cnt == PM_WAIT_TIME) {
+		pr_err("reg=0x%x tmp:=0x%x\n", reg, tmp);
+		return false;
+	}
+
+	return true;
+}
+static void pm_dickens_logical_shutdown(u32 cluster)
+{
+	int i;
+	int status;
+	u32 bit;
+	u32 bit_pos;
+	int retries;
+
+	bit = (0x01 << cluster_to_node[cluster]);
+	bit_pos = cluster_to_node[cluster];
+
+	for (i = 0; i < DKN_HNF_TOTAL_NODES; ++i) {
+		writel(bit,
+				dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
+						+ DKN_HNF_SNOOP_DOMAIN_CTL_CLR);
+
+		retries = PM_WAIT_TIME;
+
+		do {
+			status = readl(
+					dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
+							+ DKN_HNF_SNOOP_DOMAIN_CTL);
+			udelay(1);
+		} while ((0 < --retries) && CHECK_BIT(status, bit_pos));
+
+		if (0 == retries) {
+			pr_err("DICKENS: Failed to clear the SNOOP main control. LOOP:%d reg: 0x%x\n", i, status);
+			return;
+
+		}
+
+	}
+	/* Clear the domain cluster */
+	writel(bit, dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET) + DKN_MN_DVM_DOMAIN_CTL_CLR);
+
+	/* Check for complete */
+	retries = PM_WAIT_TIME;
+
+	do {
+		status = readl(
+				dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET)
+						+ DKN_MN_DVM_DOMAIN_CTL);
+		udelay(1);
+	} while ((0 < --retries) && CHECK_BIT(status, bit_pos));
+
+	if (0 == retries) {
+		pr_err("DICKENS: failed to set DOMAIN OFFSET Reg=0x%x\n", status);
+		return;
+
+	}
+}
+
+static int pm_dickens_logical_powerup(u32 cluster)
+{
+	int i;
+	u32 status;
+	u32 bit;
+	u32 bit_pos;
+	int retries;
+	int rval = 0;
+
+
+	bit = (0x01 << cluster_to_node[cluster]);
+	bit_pos = cluster_to_node[cluster];
+
+	for (i = 0; i < DKN_HNF_TOTAL_NODES; ++i) {
+		writel(bit,
+				dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
+						+ DKN_HNF_SNOOP_DOMAIN_CTL_SET);
+
+		retries = PM_WAIT_TIME;
+
+		do {
+			status = readl(
+					dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
+							+ DKN_HNF_SNOOP_DOMAIN_CTL);
+			udelay(1);
+		} while ((0 < --retries) && !CHECK_BIT(status, bit_pos));
+
+		if (0 == retries) {
+			pr_err("DICKENS: Failed on the SNOOP DONAIN\n");
+			return -PM_ERR_DICKENS_SNOOP_DOMAIN;
+		}
+
+	}
+
+	/* Clear the domain cluster */
+	writel(bit, dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET) + DKN_MN_DVM_DOMAIN_CTL_SET);
+
+	/* Check for complete */
+	retries = PM_WAIT_TIME;
+
+	do {
+		status = readl(
+				dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET)
+						+ DKN_MN_DVM_DOMAIN_CTL);
+		udelay(1);
+	} while ((0 < --retries) && !CHECK_BIT(status, bit_pos));
+
+	if (0 == retries) {
+		pr_err("DICKENS: Failed on the SNOOP DONAIN CTL SET\n");
+		return -PM_ERR_DICKENS_SNOOP_DOMAIN;
+	}
+
+	return rval;
+}
+
+static void pm_disable_ipi_interrupts(u32 cpu)
+{
+	pm_clear_bits_syscon_register(ipi_register[cpu], IPI_IRQ_MASK);
+}
+
+static void pm_enable_ipi_interrupts(u32 cpu)
+{
+
+	u32 i;
+	u32 powered_on_cpu = (~(pm_cpu_powered_down) & IPI_IRQ_MASK);
+
+	pm_set_bits_syscon_register(ipi_register[cpu], powered_on_cpu);
+
+	for (i = 0; i < MAX_CPUS; i++) {
+		if ((1 << i) & powered_on_cpu)
+			pm_or_bits_syscon_register(ipi_register[i], (1 << cpu));
+	}
+}
+
+bool pm_cpu_active(u32 cpu)
+{
+
+	bool success = false;
+	u32 reg;
+
+	reg = readl(syscon + NCP_SYSCON_PWR_QACTIVE);
+	if (reg & (1 << cpu))
+		success = true;
+
+	return success;
+
+}
+
+void pm_cpu_shutdown(u32 cpu)
+{
+
+	bool success;
+	u32 reqcpu = cpu_logical_map(cpu);
+	u32 cluster = reqcpu / CORES_PER_CLUSTER;
+	u32 cluster_mask = (0x01 << cluster);
+	bool last_cpu;
+	int rval = 0;
+
+	/* Check to see if the cpu is powered up */
+	if (pm_cpu_powered_down & (1 << reqcpu)) {
+		pr_err("CPU %d is already powered off - %s:%d\n", cpu, __FILE__, __LINE__);
+		return;
+	}
+
+	/*
+	 * Is this the last cpu of a cluster then turn off the L2 cache
+	 * along with the CPU.
+	 */
+	last_cpu = pm_cpu_last_of_cluster(reqcpu);
+	if (last_cpu) {
+
+		/* Disable all the interrupts to the cluster gic */
+		pm_or_bits_syscon_register(NCP_SYSCON_GIC_DISABLE, cluster_mask);
+
+		/* Remove the cluster from the Dickens coherency domain */
+		pm_dickens_logical_shutdown(cluster);
+
+		/* Power down the cpu */
+		pm_cpu_physical_isolation_and_power_down(reqcpu);
+
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_CSYSREQ_CNT, cluster_mask);
+		success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_CACTIVE_CNT, cluster);
+		if (!success) {
+			pr_err(
+					"Failed to keep other cluster count going on cluster %d: %s-%d\n",
+					cluster, __FILE__, __LINE__);
+			goto pm_shutdown_exit;
+		}
+
+		/* Turn off the ACE */
+		pm_or_bits_syscon_register(NCP_SYSCON_PWR_ACEPWRDNRQ, cluster_mask);
+
+		/* Wait for ACE to complete power off */
+		success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NACEPWRDNACK, cluster);
+		if (!success) {
+			pr_err("Failed to power off ACE on cluster %d: %s-%d\n",
+					cluster, __FILE__, __LINE__);
+			goto pm_shutdown_exit;
+		}
+
+		/* Isolate the cluster */
+		pm_or_bits_syscon_register(NCP_SYSCON_PWR_ISOLATEL2MISC, cluster_mask);
+
+		/* Wait for WFI L2 to go to standby */
+		success = pm_test_for_bit_with_timeout(NCP_SYSCON_PWR_STANDBYWFIL2, cluster);
+		if (!success) {
+			pr_err("Failed to enter L2 WFI on cluster %d: %s-%d\n",
+					cluster, __FILE__, __LINE__);
+			goto pm_shutdown_exit;
+		}
+
+		/* Power off the L2 */
+		pm_L2_isolation_and_power_down(cluster);
+		if (rval == 0) {
+			pr_info("CPU %d is powered down with cluster: %d\n", reqcpu, cluster);
+			pm_cpu_powered_down |= (1 << reqcpu);
+		} else
+			pr_err("CPU %d failed to power down\n", reqcpu);
+
+
+	} else {
+
+		rval = pm_cpu_physical_isolation_and_power_down(reqcpu);
+		if (rval == 0)
+			pm_cpu_powered_down |= (1 << reqcpu);
+		else
+			pr_err("CPU %d failed to power down\n", reqcpu);
+	}
+
+pm_shutdown_exit:
+	return;
+
+}
+
+int pm_cpu_powerup(u32 cpu)
+{
+
+	bool first_cpu;
+	int rval = 0;
+	u32 cpu_mask = (0x01 << cpu);
+
+	u32 reqcpu = cpu_logical_map(cpu);
+	u32 cluster = reqcpu / CORES_PER_CLUSTER;
+
+	u32 cluster_mask = (0x01 << cluster);
+
+	/*
+	 * Is this the first cpu of a cluster to come back on?
+	 * Then power up the L2 cache.
+	 */
+	first_cpu = pm_first_cpu_of_cluster(cpu);
+	if (first_cpu) {
+
+		rval = pm_L2_logical_powerup(cluster, cpu);
+		if (rval) {
+			pr_err("CPU: Failed the logical L2 power up\n");
+			goto pm_power_up;
+		} else
+			pr_info("CPU %d is powered up with cluster: %d\n", reqcpu, cluster);
+
+		cluster_power_up[cluster] = true;
+		pm_clear_bits_syscon_register(NCP_SYSCON_GIC_DISABLE, cluster_mask);
+
+
+	} else {
+		/* Set the CPU into reset */
+		pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+		pm_or_bits_syscon_register(NCP_SYSCON_PWRUP_CPU_RST, cpu_mask);
+	}
+
+
+	/*
+	 * Power up the CPU
+	 */
+	rval = pm_cpu_physical_connection_and_power_up(cpu);
+	if (rval) {
+		pr_err("Failed to power up physical connection of cpu: %d\n", cpu);
+		goto pm_power_up;
+	}
+
+	/*
+	 * The key value must be written before the CPU RST can be written.
+	 */
+	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWRUP_CPU_RST,	cpu_mask);
+
+	/*
+	 * Clear the powered down mask
+	 */
+	pm_cpu_powered_down &= ~(1 << cpu);
+
+	/* Enable the CPU IPI */
+	pm_enable_ipi_interrupts(cpu);
+
+pm_power_up:
+	return rval;
+}
+
+unsigned long pm_get_powered_down_cpu(void)
+{
+	return pm_cpu_powered_down;
+}
+
+inline void pm_cpu_logical_powerup(void)
+{
+	unsigned int v;
+
+	asm volatile(
+			"	mrc	p15, 0, %0, c1, c0, 0\n"
+			"	orr	%0, %0, %1\n"
+			"	mcr	p15, 0, %0, c1, c0, 0\n"
+			"	mrc	p15, 0, %0, c1, c0, 0\n"
+			"	orr	%0, %0, %2\n"
+			"	mcr	p15, 0, %0, c1, c0, 0\n"
+			: "=&r" (v)
+			: "Ir" (CR_C), "Ir" (CR_I)
+			: "cc");
+
+	/*
+	 *  Iniitalize the ACTLR2 register (all cores).
+	*/
+
+	asm volatile(
+			"	mrc		p15, 1, %0, c15, c0, 4\n"
+			"	bic	%0, %0, %1\n"
+			"	mcr		p15, 1, %0, c15, c0, 4\n"
+			: "=&r" (v)
+			: "Ir" (0x1)
+			: "cc");
+
+	isb();
+	dsb();
+}
+
+inline void pm_cluster_logical_powerup(void)
+{
+	unsigned int v;
+
+	/*
+	 * Initialize the L2CTLR register (primary core in each cluster).
+	 */
+	asm volatile(
+	"	mrc	p15, 1, %0, c9, c0, 2\n"
+	"	orr	%0, %0, %1\n"
+	"	orr	%0, %0, %2\n"
+	"	mcr	p15, 1, %0, c9, c0, 2"
+	  : "=&r" (v)
+	  : "Ir" (0x01), "Ir" (0x1 << 21)
+	  : "cc");
+
+	isb();
+	dsb();
+
+	/*
+	 * Initialize the L2ACTLR register (primary core in each cluster).
+	 */
+	asm volatile(
+		"	mrc	p15, 1, r0, c15, c0, 0\n"
+		"	orr	%0, %0, %1\n"
+		"	orr	%0, %0, %2\n"
+		"	orr	%0, %0, %3\n"
+		"	orr	%0, %0, %4\n"
+		"	orr	%0, %0, %5\n"
+		"	mcr	p15, 1, %0, c15, c0, 0"
+		: "=&r" (v)
+			: "Ir" (0x1 << 3), "Ir" (0x1 << 7), "Ir" (0x1 << 12), "Ir" (0x1 << 13), "Ir" (0x1 << 14)
+		 : "cc");
+	isb();
+	dsb();
+}
+
+static int pm_cpu_physical_isolation_and_power_down(int cpu)
+{
+	int rval = 0;
+
+	bool success;
+	u32 mask = (0x01 << cpu);
+
+	/* Disable the CPU IPI */
+	pm_disable_ipi_interrupts(cpu);
+
+	/* Initiate power down of the CPU's HS Rams */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPURAM, mask);
+
+	/* Wait until the RAM power down is complete */
+	success = pm_test_for_bit_with_timeout(NCP_SYSCON_PWR_NPWRUPCPURAM_ACK, cpu);
+	if (!success) {
+		rval = -PM_ERR_FAILED_PWR_DWN_RAM;
+		pr_err("CPU: Failed to power down CPU RAM\n");
+		goto power_down_cleanup;
+	}
+
+	/* Activate the CPU's isolation clamps */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_ISOLATECPU, mask);
+
+	/* Initiate power down of the CPU logic */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG2, mask);
+
+	udelay(16);
+
+	/* Continue power down of the CPU logic */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG1, mask);
+
+	success = pm_test_for_bit_with_timeout(NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK, cpu);
+	if (!success) {
+		rval = -PM_ERR_FAILED_STAGE_1;
+		pr_err("CPU: Failed to power down stage 1 cpu\n");
+		goto power_down_cleanup;
+	}
+
+power_down_cleanup:
+	return rval;
+}
+
+static int pm_cpu_physical_connection_and_power_up(int cpu)
+{
+	int rval = 0;
+
+	bool success;
+	u32 mask = (0x01 << cpu);
+
+	/* Initiate power up of the CPU */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG1, mask);
+
+	/* Wait until CPU logic power is compete */
+	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK, cpu);
+	if (!success) {
+		rval = -PM_ERR_ACK1_FAIL;
+		pr_err("CPU: Failed to get ACK from power down stage 1\n");
+		goto power_up_cleanup;
+	}
+
+	/* Continue stage 2 power up of the CPU*/
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG2, mask);
+
+	udelay(16);
+
+	/* Initiate power up of HS Rams */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPURAM, mask);
+
+	/* Wait until the RAM power up is complete */
+	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPCPURAM_ACK, cpu);
+	if (!success) {
+		rval = -PM_ERR_RAM_ACK_FAIL;
+		pr_err("CPU: Failed to get ACK of power power up\n");
+		goto power_up_cleanup;
+	}
+
+	/* Release the CPU's isolation clamps */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ISOLATECPU, mask);
+
+	udelay(16);
+
+power_up_cleanup:
+
+	return rval;
+
+}
+/*========================================== L2 FUNCTIONS ========================================*/
+
+static void pm_L2_isolation_and_power_down(int cluster)
+{
+	u32 mask = (0x1 << cluster);
+
+	/* Enable the chip select for the cluster */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_CHIPSELECTEN, mask);
+
+	/* Disable the hsram */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2HSRAM, mask);
+
+	switch (cluster) {
+	case (0):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+
+#endif
+		break;
+	case (1):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+#endif
+		break;
+	case (2):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+#endif
+		break;
+	case (3):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+#endif
+		break;
+	default:
+		pr_err("Illegal cluster: %d > 3\n", cluster);
+		break;
+	}
+
+	/* Power down stage 2 */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG2, mask);
+
+	/* Power down stage 1 */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG1, mask);
+
+}
+
+static int pm_L2_physical_connection_and_power_up(u32 cluster)
+{
+
+	bool success;
+	u32 mask = (0x1 << cluster);
+	int rval = 0;
+
+	/* Power up stage 1 */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG1, mask);
+
+	/* Wait for the stage 1 power up to complete */
+	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPL2LGCSTG1_ACK, cluster);
+	if (!success) {
+		pr_err("CPU: Failed to ack the L2 Stage 1 Power up\n");
+		rval = -PM_ERR_FAIL_L2ACK;
+		goto power_up_l2_cleanup;
+	}
+
+	/* Power on stage 2 */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG2, mask);
+
+	/* Set the chip select */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_CHIPSELECTEN, mask);
+
+	/* Power up the snoop ram */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2HSRAM, mask);
+
+	/* Wait for the stage 1 power up to complete */
+	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPL2HSRAM_ACK, cluster);
+	if (!success) {
+		pr_err("CPU: failed to get the HSRAM power up ACK\n");
+		rval = -PM_ERR_FAIL_L2HSRAM;
+		goto power_up_l2_cleanup;
+	}
+
+	switch (cluster) {
+	case (0):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+
+#endif
+		break;
+	case (1):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+	udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+#endif
+		break;
+	case (2):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+#endif
+		break;
+	case (3):
+
+#ifdef PM_POWER_OFF_ONLY_DATARAM
+
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(syscon,
+				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
+		udelay(20);
+#else
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_ALL_MASK);
+		udelay(20);
+		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0, RAM_ALL_MASK);
+		udelay(20);
+#endif
+		break;
+	default:
+		pr_err("Illegal cluster: %d > 3\n", cluster);
+		break;
+	}
+
+	/* Clear the chip select */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_CHIPSELECTEN, mask);
+
+	/* Release the isolation clamps */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ISOLATEL2MISC, mask);
+
+	/* Turn the ACE bridge power on*/
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ACEPWRDNRQ, mask);
+
+power_up_l2_cleanup:
+	return rval;
+}
+
+static int pm_L2_logical_powerup(u32 cluster, u32 cpu)
+{
+
+	u32 mask = (0x1 << cluster);
+	int rval = 0;
+	u32 cluster_mask;
+
+	if (cluster == 0)
+		cluster_mask = 0xe;
+	else
+		cluster_mask = 0xf << (cluster * 4);
+
+	/* put the cluster into a cpu hold */
+	pm_or_bits_syscon_register(NCP_SYSCON_RESET_AXIS,
+			cluster_to_poreset[cluster]);
+
+	/*
+	 * The key value has to be written before the CPU RST can be written.
+	 */
+	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+	pm_or_bits_syscon_register(NCP_SYSCON_PWRUP_CPU_RST, cluster_mask);
+
+	/* Hold the chip debug cluster */
+	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+	pm_or_bits_syscon_register(NCP_SYSCON_HOLD_DBG, mask);
+
+	/* Hold the L2 cluster */
+	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+	pm_or_bits_syscon_register(NCP_SYSCON_HOLD_L2, mask);
+
+
+	/* Cluster physical power up */
+	rval = pm_L2_physical_connection_and_power_up(cluster);
+	if (rval)
+		goto exit_pm_L2_logical_powerup;
+
+	udelay(16);
+
+	/* take the cluster out of a cpu hold */
+	pm_clear_bits_syscon_register(NCP_SYSCON_RESET_AXIS,
+			cluster_to_poreset[cluster]);
+
+	udelay(64);
+
+	/* Enable the system counter */
+	pm_or_bits_syscon_register(NCP_SYSCON_PWR_CSYSREQ_CNT, mask);
+
+	/* Release the L2 cluster */
+	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+	pm_clear_bits_syscon_register(NCP_SYSCON_HOLD_L2, mask);
+
+	/* Release the chip debug cluster */
+	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
+	pm_clear_bits_syscon_register(NCP_SYSCON_HOLD_DBG, mask);
+
+	/* Power up the dickens */
+	rval = pm_dickens_logical_powerup(cluster);
+	if (rval)
+		goto exit_pm_L2_logical_powerup;
+
+	/* start L2 */
+	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ACINACTM, mask);
+
+exit_pm_L2_logical_powerup:
+
+	return rval;
+
+}
+
+#ifdef DEBUG_CPU_PM
+
+void pm_debug_read_pwr_registers(void)
+{
+	u32 reg;
+
+	reg = readl(syscon + 0x1400);
+	pr_err("NCP_SYSCON_PWR_CLKEN: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_PWR_ACINACTM);
+	pr_err("NCP_SYSCON_PWR_ACINACTM: 0x%x\n", reg);
+	reg = readl(syscon + 0x140c);
+	pr_err("NCP_SYSCON_PWR_CHIPSELECTEN: 0x%x\n", reg);
+	reg = readl(syscon + 0x1410);
+	pr_err("NCP_SYSCON_PWR_CSYSREQ_TS: 0x%x\n", reg);
+	reg = readl(syscon + 0x1414);
+	pr_err("NCP_SYSCON_PWR_CSYSREQ_CNT: 0x%x\n", reg);
+	reg = readl(syscon + 0x1418);
+	pr_err("NCP_SYSCON_PWR_CSYSREQ_ATB: 0x%x\n", reg);
+	reg = readl(syscon + 0x141c);
+	pr_err("NCP_SYSCON_PWR_CSYSREQ_APB: 0x%x\n", reg);
+	reg = readl(syscon + 0x1420);
+	pr_err("NCP_SYSCON_PWR_PWRUPL2LGCSTG1: 0x%x\n", reg);
+	reg = readl(syscon + 0x1424);
+	pr_err("NCP_SYSCON_PWR_PWRUPL2LGCSTG2: 0x%x\n", reg);
+	reg = readl(syscon + 0x1428);
+	pr_err("NCP_SYSCON_PWR_PWRUPL2HSRAM: 0x%x\n", reg);
+	reg = readl(syscon + 0x142c);
+	pr_err("NCP_SYSCON_PWR_ACEPWRDNRQ: 0x%x\n", reg);
+	reg = readl(syscon + 0x1430);
+	pr_err("NCP_SYSCON_PWR_ISOLATEL2MIS: 0x%x\n", reg);
+	reg = readl(syscon + 0x1438);
+	pr_err("NCP_SYSCON_PWR_NPWRUPL2LGCSTG1_ACK: 0x%x\n", reg);
+	reg = readl(syscon + 0x143c);
+	pr_err("NCP_SYSCON_PWR_NPWRUPL2HSRAM_ACK: 0x%x\n", reg);
+	reg = readl(syscon + 0x1440);
+	pr_err("NCP_SYSCON_PWR_STANDBYWFIL2: 0x%x\n", reg);
+	reg = readl(syscon + 0x1444);
+	pr_err("NCP_SYSCON_PWR_CSYSACK_TS: 0x%x\n", reg);
+	reg = readl(syscon + 0x1448);
+	pr_err("NCP_SYSCON_PWR_CACTIVE_TS: 0x%x\n", reg);
+	reg = readl(syscon + 0x144c);
+	pr_err("NCP_SYSCON_PWR_CSYSACK_CNT: 0x%x\n", reg);
+	reg = readl(syscon + 0x1450);
+	pr_err("NCP_SYSCON_PWR_CACTIVE_CNT: 0x%x\n", reg);
+	reg = readl(syscon + 0x1454);
+	pr_err("NCP_SYSCON_PWR_CSYSACK_ATB: 0x%x\n", reg);
+	reg = readl(syscon + 0x1458);
+	pr_err("NCP_SYSCON_PWR_CACTIVE_ATB: 0x%x\n", reg);
+	reg = readl(syscon + 0x145c);
+	pr_err("NCP_SYSCON_PWR_CSYSACK_APB: 0x%x\n", reg);
+	reg = readl(syscon + 0x1460);
+	pr_err("NCP_SYSCON_PWR_CACTIVE_APB: 0x%x\n", reg);
+	reg = readl(syscon + 0x1464);
+	pr_err("NCP_SYSCON_PWR_NACEPWRDNACK: 0x%x\n", reg);
+	reg = readl(syscon + 0x1468);
+	pr_err("NCP_SYSCON_PWR_CACTIVEM_EAGM: 0x%x\n", reg);
+	reg = readl(syscon + 0x146c);
+	pr_err("NCP_SYSCON_PWR_CACTIVEM_EAGS: 0x%x\n", reg);
+	reg = readl(syscon + 0x1470);
+	pr_err("NCP_SYSCON_PWR_CACTIVES_EAGM: 0x%x\n", reg);
+	reg = readl(syscon + 0x1474);
+	pr_err("NCP_SYSCON_PWR_CACTIVES_EAGS: 0x%x\n", reg);
+	reg = readl(syscon + 0x1480);
+	pr_err("NCP_SYSCON_PWR_PWRUPCPUSTG1: 0x%x\n", reg);
+	reg = readl(syscon + 0x1484);
+	pr_err("NCP_SYSCON_PWR_PWRUPCPUSTG2: 0x%x\n", reg);
+	reg = readl(syscon + 0x1488);
+	pr_err("NCP_SYSCON_PWR_PWRUPCPURAM: 0x%x\n", reg);
+	reg = readl(syscon + 0x148c);
+	pr_err("NCP_SYSCON_PWR_ISOLATECPU: 0x%x\n", reg);
+	reg = readl(syscon + 0x1490);
+	pr_err("NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK: 0x%x\n", reg);
+	reg = readl(syscon + 0x1494);
+	pr_err("NCP_SYSCON_PWR_NPWRUPCPURAM_ACK: 0x%x\n", reg);
+	reg = readl(syscon + 0x1498);
+	pr_err("NCP_SYSCON_PWR_QACTIVE: 0x%x\n", reg);
+	reg = readl(syscon + 0x149C);
+	pr_err("NCP_SYSCON_PWR_STANDBYWFI: 0x%x\n", reg);
+	reg = readl(syscon + 0x14A0);
+	pr_err("NCP_SYSCON_PWR_STANDBYWFE: 0x%x\n", reg);
+	reg = readl(syscon + 0x14A4);
+	pr_err("NCP_SYSCON_PWR_DBGNOPWRDWN: 0x%x\n", reg);
+	reg = readl(syscon + 0x14A8);
+	pr_err("NCP_SYSCON_PWR_DBGPWRUPREQ: 0x%x\n", reg);
+	reg = readl(syscon + 0x1040);
+	pr_err("NCP_SYSCON_RESET_AXIS: 0x%x\n", reg);
+	reg = readl(syscon + 0x1044);
+	pr_err("NCP_SYSCON_RESET_AXIS-WORD1: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_RESET_CPU);
+	pr_err("NCP_SYSCON_RESET_CPU: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_HOLD_DBG);
+	pr_err("NCP_SYSCON_HOLD_DBG: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_HOLD_L2);
+	pr_err("NCP_SYSCON_HOLD_L2: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_HOLD_CPU);
+	pr_err("NCP_SYSCON_HOLD_CPU: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_PWRUP_CPU_RST);
+	pr_err("NCP_SYSCON_PWRUP_CPU_RST: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_RESET_STATUS);
+	pr_err("NCP_SYSCON_RESET_STATUS: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_RESET_CORE_STATUS);
+	pr_err("NCP_SYSCON_RESET_CORE_STATUS: 0x%x\n", reg);
+
+
+#if 0
+	reg = readl(syscon + NCP_SYSCON_MCG_CSW_CPU);
+	pr_err("NCP_SYSCON_MCG_CSW_CPU: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MCG_CSW_SYS);
+	pr_err("NCP_SYSCON_MCG_CSW_SYS: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MCG_DIV_CPU);
+	pr_err("NCP_SYSCON_MCG_DIV_CPU: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MCG_DIV_SYS);
+	pr_err("NCP_SYSCON_MCG_DIV_SYS: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_CLKDEBUG);
+	pr_err("NCP_SYSCON_CLKDEBUG: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_EVENT_ENB);
+	pr_err("NCP_SYSCON_EVENT_ENB: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_CPU_FAST_INT);
+	pr_err("NCP_SYSCON_CPU_FAST_INT: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_GIC_DISABLE);
+	pr_err("NCP_SYSCON_GIC_DISABLE: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_CP15SDISABLE);
+	pr_err("NCP_SYSCON_CP15SDISABLE: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_LDO_CTL);
+	pr_err("NCP_SYSCON_LDO_CTL: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_SHWK_QOS);
+	pr_err("NCP_SYSCON_SHWK_QOS: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_FUSE_RTO);
+	pr_err("NCP_SYSCON_FUSE_RTO: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_PFUSE);
+	pr_err("NCP_SYSCON_PFUSE: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_FUSE_STAT);
+	pr_err("NCP_SYSCON_FUSE_STAT: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_SCRATCH);
+	pr_err("NCP_SYSCON_SCRATCH: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI0);
+	pr_err("NCP_SYSCON_MASK_IPI0: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI1);
+	pr_err("NCP_SYSCON_MASK_IPI1: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI2);
+	pr_err("NCP_SYSCON_MASK_IPI2: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI3);
+	pr_err("NCP_SYSCON_MASK_IPI3: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI4);
+	pr_err("NCP_SYSCON_MASK_IPI4: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI5);
+	pr_err("NCP_SYSCON_MASK_IPI5: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI6);
+	pr_err("NCP_SYSCON_MASK_IPI6: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI7);
+	pr_err("NCP_SYSCON_MASK_IPI7: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI8);
+	pr_err("NCP_SYSCON_MASK_IPI8: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI9);
+	pr_err("NCP_SYSCON_MASK_IPI9: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI10);
+	pr_err("NCP_SYSCON_MASK_IPI10: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI11);
+	pr_err("NCP_SYSCON_MASK_IPI11: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI12);
+	pr_err("NCP_SYSCON_MASK_IPI12: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI13);
+	pr_err("NCP_SYSCON_MASK_IPI13: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI14);
+	pr_err("NCP_SYSCON_MASK_IPI14: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_MASK_IPI15);
+	pr_err("NCP_SYSCON_MASK_IPI15: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_SPARE0);
+	pr_err("NCP_SYSCON_SPARE0: 0x%x\n", reg);
+	reg = readl(syscon + NCP_SYSCON_STOP_CLK_CPU);
+	pr_err("NCP_SYSCON_STOP_CLK_CPU: 0x%x\n", reg);
+#endif
+
+
+}
+
+
+void pm_dump_L2_registers(void)
+{
+	u32 reg;
+
+
+	reg = readl(syscon + 0x1580);
+	pr_err("NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2: 0x%x\n", reg);
+	reg = readl(syscon + 0x1584);
+	pr_err("NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1: 0x%x\n", reg);
+	reg = readl(syscon + 0x1588);
+	pr_err("NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0: 0x%x\n", reg);
+	reg = readl(syscon + 0x158c);
+	pr_err("NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2: 0x%x\n", reg);
+	reg = readl(syscon + 0x1590);
+	pr_err("NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1: 0x%x\n", reg);
+	reg = readl(syscon + 0x1594);
+	pr_err("NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0: 0x%x\n", reg);
+	reg = readl(syscon + 0x1598);
+	pr_err("NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2: 0x%x\n", reg);
+	reg = readl(syscon + 0x159c);
+	pr_err("NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1: 0x%x\n", reg);
+	reg = readl(syscon + 0x15a0);
+	pr_err("NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0: 0x%x\n", reg);
+	reg = readl(syscon + 0x15a4);
+	pr_err("NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2: 0x%x\n", reg);
+	reg = readl(syscon + 0x15a8);
+	pr_err("NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1: 0x%x\n", reg);
+	reg = readl(syscon + 0x15ac);
+	pr_err("NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0: 0x%x\n", reg);
+
+
+
+
+void pm_dump_dickens(void)
+{
+
+	u32 status;
+	u32 i;
+
+	for (i = 0; i < DKN_HNF_TOTAL_NODES; ++i) {
+		status = readl(
+				dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
+						+ DKN_HNF_SNOOP_DOMAIN_CTL);
+		udelay(1);
+		pr_err("DKN_HNF_SNOOP_DOMAIN_CTL[%d]: 0x%x\n", i, status);
+	}
+
+	status = readl(
+			dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET)
+					+ DKN_MN_DVM_DOMAIN_CTL);
+
+	pr_err("DKN_MN_DVM_DOMAIN_CTL: 0x%x\n", status);
+}
+
+#endif
diff --git a/arch/arm/mach-axxia/axxia_power_management.h b/arch/arm/mach-axxia/axxia_power_management.h
new file mode 100644
index 0000000..42cda78
--- /dev/null
+++ b/arch/arm/mach-axxia/axxia_power_management.h
@@ -0,0 +1,192 @@
+/*
+ * axxia_power_management.h
+ *
+ *  Created on: Jun 23, 2014
+ *      Author: z8cpaul
+ */
+
+#ifndef AXXIA_POWER_MANAGEMENT_H_
+#define AXXIA_POWER_MANAGEMENT_H_
+
+
+#define     NCP_SYSCON_MCG_CSW_CPU                              (0x00000000)
+#define     NCP_SYSCON_MCG_CSW_SYS                              (0x00000004)
+#define     NCP_SYSCON_MCG_DIV_CPU                              (0x00000008)
+#define     NCP_SYSCON_MCG_DIV_SYS                              (0x0000000c)
+#define     NCP_SYSCON_CLKDEBUG                                 (0x00000010)
+#define     NCP_SYSCON_EVENT_ENB                                (0x00000014)
+#define     NCP_SYSCON_CPU_FAST_INT                             (0x00000018)
+#define     NCP_SYSCON_GIC_DISABLE                              (0x0000001c)
+#define     NCP_SYSCON_CP15SDISABLE                             (0x00000020)
+#define     NCP_SYSCON_LRSTDISABLE                              (0x00000024)
+#define     NCP_SYSCON_LDO_CTL                                  (0x00000028)
+#define     NCP_SYSCON_SHWK_QOS                                 (0x0000002c)
+#define     NCP_SYSCON_FUSE_RTO                                 (0x00000030)
+#define     NCP_SYSCON_PFUSE                                    (0x00000034)
+#define     NCP_SYSCON_FUSE_STAT                                (0x00000038)
+#define     NCP_SYSCON_SCRATCH                                  (0x0000003c)
+#define     NCP_SYSCON_MASK_IPI0                                (0x00000040)
+#define     NCP_SYSCON_MASK_IPI1                                (0x00000044)
+#define     NCP_SYSCON_MASK_IPI2                                (0x00000048)
+#define     NCP_SYSCON_MASK_IPI3                                (0x0000004c)
+#define     NCP_SYSCON_MASK_IPI4                                (0x00000050)
+#define     NCP_SYSCON_MASK_IPI5                                (0x00000054)
+#define     NCP_SYSCON_MASK_IPI6                                (0x00000058)
+#define     NCP_SYSCON_MASK_IPI7                                (0x0000005c)
+#define     NCP_SYSCON_MASK_IPI8                                (0x00000060)
+#define     NCP_SYSCON_MASK_IPI9                                (0x00000064)
+#define     NCP_SYSCON_MASK_IPI10                               (0x00000068)
+#define     NCP_SYSCON_MASK_IPI11                               (0x0000006c)
+#define     NCP_SYSCON_MASK_IPI12                               (0x00000070)
+#define     NCP_SYSCON_MASK_IPI13                               (0x00000074)
+#define     NCP_SYSCON_MASK_IPI14                               (0x00000078)
+#define     NCP_SYSCON_MASK_IPI15                               (0x0000007c)
+#define     NCP_SYSCON_MASK_IPI16                               (0x00000080)
+#define     NCP_SYSCON_MASK_IPI17                               (0x00000084)
+#define     NCP_SYSCON_MASK_IPI18                               (0x00000088)
+#define     NCP_SYSCON_SPARE0                                   (0x0000008c)
+#define     NCP_SYSCON_STOP_CLK_CPU                             (0x00000090)
+
+
+#define     NCP_SYSCON_RESET_STATUS                             (0x00000100)
+#define     NCP_SYSCON_RESET_CORE_STATUS                        (0x00000108)
+
+#define     NCP_SYSCON_KEY                                      (0x00001000)
+#define     NCP_SYSCON_RESET_CTL                                (0x00001008)
+#define     NCP_SYSCON_RESET_CPU                                (0x0000100c)
+#define     NCP_SYSCON_HOLD_CPU                                 (0x00001010)
+#define     NCP_SYSCON_HOLD_PTM                                 (0x00001014)
+#define     NCP_SYSCON_HOLD_L2                                  (0x00001018)
+#define     NCP_SYSCON_HOLD_DBG                                 (0x0000101c)
+
+#define     NCP_SYSCON_PWRUP_CPU_RST                            (0x00001030)
+
+#define     NCP_SYSCON_RESET_AXIS                               (0x00001040)
+#define     NCP_SYSCON_RESET_AXIS_ACCESS_SIZE                   (0x00000008)
+
+#define     NCP_SYSCON_PWR_CLKEN                                (0x00001400)
+#define     NCP_SYSCON_ENABLE_CLKEN_SET                         (0x00001404)
+#define     NCP_SYSCON_PWR_ACINACTM                             (0x00001408)
+#define     NCP_SYSCON_PWR_CHIPSELECTEN                         (0x0000140c)
+#define     NCP_SYSCON_PWR_CSYSREQ_TS                           (0x00001410)
+#define     NCP_SYSCON_PWR_CSYSREQ_CNT                          (0x00001414)
+#define     NCP_SYSCON_PWR_CSYSREQ_ATB                          (0x00001418)
+#define     NCP_SYSCON_PWR_CSYSREQ_APB                          (0x0000141c)
+#define     NCP_SYSCON_PWR_PWRUPL2LGCSTG1                       (0x00001420)
+#define     NCP_SYSCON_PWR_PWRUPL2LGCSTG2                       (0x00001424)
+#define     NCP_SYSCON_PWR_PWRUPL2HSRAM                         (0x00001428)
+#define     NCP_SYSCON_PWR_ACEPWRDNRQ                           (0x0000142c)
+#define     NCP_SYSCON_PWR_ISOLATEL2MISC                        (0x00001430)
+#define     NCP_SYSCON_PWR_NPWRUPL2LGCSTG1_ACK                  (0x00001438)
+#define     NCP_SYSCON_PWR_NPWRUPL2HSRAM_ACK                    (0x0000143c)
+#define     NCP_SYSCON_PWR_STANDBYWFIL2                         (0x00001440)
+#define     NCP_SYSCON_PWR_CSYSACK_TS                           (0x00001444)
+#define     NCP_SYSCON_PWR_CACTIVE_TS                           (0x00001448)
+#define     NCP_SYSCON_PWR_CSYSACK_CNT                          (0x0000144c)
+#define     NCP_SYSCON_PWR_CACTIVE_CNT                          (0x00001450)
+#define     NCP_SYSCON_PWR_CSYSACK_ATB                          (0x00001454)
+#define     NCP_SYSCON_PWR_CACTIVE_ATB                          (0x00001458)
+#define     NCP_SYSCON_PWR_CSYSACK_APB                          (0x0000145c)
+#define     NCP_SYSCON_PWR_CACTIVE_APB                          (0x00001460)
+#define     NCP_SYSCON_PWR_NACEPWRDNACK                         (0x00001464)
+#define     NCP_SYSCON_PWR_CACTIVEM_EAGM                        (0x00001468)
+#define     NCP_SYSCON_PWR_CACTIVEM_EAGS                        (0x0000146c)
+#define     NCP_SYSCON_PWR_CACTIVES_EAGM                        (0x00001470)
+#define     NCP_SYSCON_PWR_CACTIVES_EAGS                        (0x00001474)
+#define     NCP_SYSCON_PWR_PWRUPCPUSTG1                         (0x00001480)
+#define     NCP_SYSCON_PWR_PWRUPCPUSTG2                         (0x00001484)
+#define     NCP_SYSCON_PWR_PWRUPCPURAM                          (0x00001488)
+#define     NCP_SYSCON_PWR_ISOLATECPU                           (0x0000148c)
+#define     NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK                    (0x00001490)
+#define     NCP_SYSCON_PWR_NPWRUPCPURAM_ACK                     (0x00001494)
+#define     NCP_SYSCON_PWR_QACTIVE                              (0x00001498)
+#define     NCP_SYSCON_PWR_STANDBYWFI                           (0x0000149c)
+#define     NCP_SYSCON_PWR_STANDBYWFE                           (0x000014a0)
+#define     NCP_SYSCON_PWR_DBGNOPWRDWN                          (0x000014a4)
+#define     NCP_SYSCON_PWR_DBGPWRUPREQ                          (0x000014a8)
+#define     NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2              (0x00001580)
+#define     NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1              (0x00001584)
+#define     NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0              (0x00001588)
+#define     NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2              (0x0000158c)
+#define     NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1              (0x00001590)
+#define     NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0              (0x00001594)
+#define     NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2              (0x00001598)
+#define     NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1              (0x0000159c)
+#define     NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0              (0x000015a0)
+#define     NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2              (0x000015a4)
+#define     NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1              (0x000015a8)
+#define     NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0              (0x000015ac)
+
+#define		RAM_BANK0_MASK			(0x0FFF0000)
+#define		RAM_BANK1_LS_MASK		(0xF0000000)
+#define		RAM_BANK1_MS_MASK		(0x000000FF)
+#define		RAM_BANK2_MASK			(0x000FFF00)
+#define		RAM_BANK3_MASK			(0xFFF00000)
+#define		RAM_ALL_MASK			(0xFFFFFFFF)
+
+/* DICKENS REGISTERS (Miscelaneous Node) */
+#define		DKN_MN_NODE_ID				(0x0)
+#define		DKN_DVM_DOMAIN_OFFSET		(0x0)
+#define		DKN_MN_DVM_DOMAIN_CTL		(0x200)
+#define		DKN_MN_DVM_DOMAIN_CTL_SET	(0x210)
+#define		DKN_MN_DVM_DOMAIN_CTL_CLR	(0x220)
+
+/* DICKENS HN-F (Fully-coherent Home Node) */
+#define		DKN_HNF_NODE_ID					(0x20)
+#define		DKN_HNF_TOTAL_NODES				(0x8)
+#define		DKN_HNF_SNOOP_DOMAIN_CTL		(0x200)
+#define		DKN_HNF_SNOOP_DOMAIN_CTL_SET	(0x210)
+#define		DKN_HNF_SNOOP_DOMAIN_CTL_CLR	(0x220)
+
+/* DICKENS clustid to Node */
+#define		DKN_CLUSTER0_NODE		(1)
+#define		DKN_CLUSTER1_NODE		(9)
+#define		DKN_CLUSTER2_NODE		(11)
+#define		DKN_CLUSTER3_NODE		(19)
+
+/* PO RESET cluster id to bit */
+#define		PORESET_CLUSTER0		(0x10000)
+#define		PORESET_CLUSTER1		(0x20000)
+#define		PORESET_CLUSTER2		(0x40000)
+#define		PORESET_CLUSTER3		(0x80000)
+
+/* IPI Masks */
+#define		IPI0_MASK				(0x1111)
+#define		IPI1_MASK				(0x2222)
+#define		IPI2_MASK				(0x4444)
+#define 	IPI3_MASK				(0x8888)
+
+/* SYSCON KEY Value */
+#define VALID_KEY_VALUE			(0xAB)
+
+#define MAX_NUM_CLUSTERS    (4)
+#define CORES_PER_CLUSTER   (4)
+#define MAX_IPI				(19)
+#define MAX_CPUS			(MAX_NUM_CLUSTERS * CORES_PER_CLUSTER)
+
+typedef struct {
+	u32 cpu;
+	u32 cluster;
+} pm_data;
+
+
+void pm_cpu_shutdown(u32 cpu);
+int pm_cpu_powerup(u32 cpu);
+void pm_debug_read_pwr_registers(void);
+void pm_dump_L2_registers(void);
+int pm_cpu_logical_die(pm_data *pm_request);
+int pm_cpul2_logical_die(pm_data *pm_request);
+unsigned long pm_get_powered_down_cpu(void);
+bool pm_cpu_last_of_cluster(u32 cpu);
+void pm_dump_dickens(void);
+void pm_init_cpu(u32 cpu);
+void pm_cpu_logical_powerup(void);
+void pm_cluster_logical_powerup(void);
+bool pm_cpu_active(u32 cpu);
+void pm_init_syscon(void);
+extern bool pm_in_progress[];
+extern bool cluster_power_up[];
+extern u32 pm_cpu_powered_down;
+
+
+#endif /* AXXIA_POWER_MANAGEMENT_H_ */
diff --git a/arch/arm/mach-axxia/clock.c b/arch/arm/mach-axxia/clock.c
index b8b839a..f33e2f3c 100644
--- a/arch/arm/mach-axxia/clock.c
+++ b/arch/arm/mach-axxia/clock.c
@@ -1,7 +1,7 @@
 /*
  *  linux/arch/arm/mach-axxia/clock.c
  *
- *  Copyright (C) 2012 LSI
+ *  Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/arch/arm/mach-axxia/ddr_retention.c b/arch/arm/mach-axxia/ddr_retention.c
index 4a850e0..aae1f37 100644
--- a/arch/arm/mach-axxia/ddr_retention.c
+++ b/arch/arm/mach-axxia/ddr_retention.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2013 LSI Corporation
+ *  Copyright (C) 2013 INTEL Corporation
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -28,7 +28,7 @@
 
 #include <linux/of.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <asm/cacheflush.h>
 #include "axxia.h"
 
@@ -337,7 +337,7 @@ static void exercise_stack_ptr(volatile char *recursions)
 	* Only available on ASIC systems.
 	*/
 
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5500-amarillo")) {
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5500-amarillo")) {
 		/* Create /proc entry. */
 		if (!proc_create("driver/axxia_ddr_retention_reset",
 				S_IWUSR, NULL, &axxia_ddr_retention_proc_ops)) {
diff --git a/arch/arm/mach-axxia/hotplug.c b/arch/arm/mach-axxia/hotplug.c
index 61235fb..0fcd4f9 100644
--- a/arch/arm/mach-axxia/hotplug.c
+++ b/arch/arm/mach-axxia/hotplug.c
@@ -18,7 +18,7 @@
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/cp15.h>
-#include "lsi_power_management.h"
+#include "axxia_power_management.h"
 
 extern volatile int pen_release;
 
diff --git a/arch/arm/mach-axxia/include/mach/hardware.h b/arch/arm/mach-axxia/include/mach/hardware.h
index 2f3686e..38c7577 100644
--- a/arch/arm/mach-axxia/include/mach/hardware.h
+++ b/arch/arm/mach-axxia/include/mach/hardware.h
@@ -1,7 +1,7 @@
 /*
  * arch/arm/mach-axxia/include/mach/hardware.h
  *
- * Copyright (c) 2013 LSI Corporation
+ * Copyright (c) 2013 INTEL Corporation
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
diff --git a/arch/arm/mach-axxia/include/mach/rio.h b/arch/arm/mach-axxia/include/mach/rio.h
index 20d50ae..9861e94 100644
--- a/arch/arm/mach-axxia/include/mach/rio.h
+++ b/arch/arm/mach-axxia/include/mach/rio.h
@@ -1,7 +1,7 @@
 /*
  * Helper module for board specific RAPIDIO bus registration
  *
- * Copyright (C) 2014 LSI Corporation.
+ * Copyright (C) 2014 INTEL Corporation.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/arch/arm/mach-axxia/include/mach/timers.h b/arch/arm/mach-axxia/include/mach/timers.h
index f2f0f0f..955de02 100644
--- a/arch/arm/mach-axxia/include/mach/timers.h
+++ b/arch/arm/mach-axxia/include/mach/timers.h
@@ -1,7 +1,7 @@
 /*
  *  arch/arm/mach-axxia/include/mach/timers.h
  *
- *  Copyright (C) 2012 LSI
+ *  Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-axxia/io.c b/arch/arm/mach-axxia/io.c
index 0530c67..38074ac 100644
--- a/arch/arm/mach-axxia/io.c
+++ b/arch/arm/mach-axxia/io.c
@@ -1,9 +1,9 @@
 /*
  * arch/arm/mach-axxia/io.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2012 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-axxia/lsi_power_management.c b/arch/arm/mach-axxia/lsi_power_management.c
deleted file mode 100644
index ab4bed5..0000000
--- a/arch/arm/mach-axxia/lsi_power_management.c
+++ /dev/null
@@ -1,1350 +0,0 @@
-/*
- *  linux/arch/arm/mach-axxia/lsi_power_management.c
- *
- *  C *  Created on: Jun 19, 2014
- *      Author: z8cpaul
- *  opyright (C) 2002 ARM Ltd.
- *  All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *  Created on: Jun 19, 2014
- *      Author: z8cpaul
- */
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/smp.h>
-#include <linux/delay.h>
-#include <linux/of_address.h>
-#include <asm/exception.h>
-#include <asm/cacheflush.h>
-#include <asm/smp_plat.h>
-#include <asm/cp15.h>
-
-#include "axxia.h"
-#include <mach/axxia-gic.h>
-#include "lsi_power_management.h"
-
-#undef DEBUG_CPU_PM
-
-#define PM_WAIT_TIME (10000)
-#define MAX_CLUSTER  (4)
-#define IPI_IRQ_MASK (0xFFFF)
-
-#define CHECK_BIT(var, pos) ((var) & (1 << (pos)))
-
-bool pm_in_progress[16];
-bool cluster_power_up[4];
-
-static const u32 cluster_to_node[MAX_CLUSTER] = { DKN_CLUSTER0_NODE,
-DKN_CLUSTER1_NODE,
-DKN_CLUSTER2_NODE,
-DKN_CLUSTER3_NODE };
-
-static const u32 cluster_to_poreset[MAX_CLUSTER] = {
-PORESET_CLUSTER0,
-PORESET_CLUSTER1,
-PORESET_CLUSTER2,
-PORESET_CLUSTER3 };
-
-static const u32 cluster_to_mask[MAX_CLUSTER] = {
-		IPI0_MASK,
-		IPI1_MASK,
-		IPI2_MASK,
-		IPI3_MASK
-};
-
-static const u32 ipi_register[MAX_IPI] = {
-		NCP_SYSCON_MASK_IPI0,
-		NCP_SYSCON_MASK_IPI1,
-		NCP_SYSCON_MASK_IPI2,
-		NCP_SYSCON_MASK_IPI3,
-		NCP_SYSCON_MASK_IPI4,
-		NCP_SYSCON_MASK_IPI5,
-		NCP_SYSCON_MASK_IPI6,
-		NCP_SYSCON_MASK_IPI7,
-		NCP_SYSCON_MASK_IPI8,
-		NCP_SYSCON_MASK_IPI9,
-		NCP_SYSCON_MASK_IPI10,
-		NCP_SYSCON_MASK_IPI11,
-		NCP_SYSCON_MASK_IPI12,
-		NCP_SYSCON_MASK_IPI13,
-		NCP_SYSCON_MASK_IPI14,
-		NCP_SYSCON_MASK_IPI15,
-		NCP_SYSCON_MASK_IPI16,
-		NCP_SYSCON_MASK_IPI17,
-		NCP_SYSCON_MASK_IPI18
-};
-
-enum pm_error_code {
-	PM_ERR_DICKENS_IOREMAP = 200,
-	PM_ERR_DICKENS_SNOOP_DOMAIN,
-	PM_ERR_FAILED_PWR_DWN_RAM,
-	PM_ERR_FAILED_STAGE_1,
-	PM_ERR_ACK1_FAIL,
-	PM_ERR_RAM_ACK_FAIL,
-	PM_ERR_FAIL_L2ACK,
-	PM_ERR_FAIL_L2HSRAM
-};
-
-u32 pm_cpu_powered_down;
-
-/*======================= LOCAL FUNCTIONS ==============================*/
-static void pm_set_bits_syscon_register(u32 reg, u32 data);
-static void pm_or_bits_syscon_register(u32 reg, u32 data);
-static void pm_clear_bits_syscon_register(u32 reg, u32 data);
-static bool pm_test_for_bit_with_timeout(u32 reg, u32 bit);
-static bool pm_wait_for_bit_clear_with_timeout(u32 reg, u32 bit);
-static void pm_dickens_logical_shutdown(u32 cluster);
-static int pm_dickens_logical_powerup(u32 cluster);
-static int pm_cpu_physical_isolation_and_power_down(int cpu);
-static void pm_L2_isolation_and_power_down(int cluster);
-static int pm_cpu_physical_connection_and_power_up(int cpu);
-static int pm_L2_physical_connection_and_power_up(u32 cluster);
-static int pm_L2_logical_powerup(u32 cluster, u32 cpu);
-
-static bool pm_first_cpu_of_cluster(u32 cpu)
-{
-#ifdef CONFIG_HOTPLUG_CPU_L2_POWER_DOWN
-
-	u32 count = 0;
-
-	switch (cpu) {
-	case (0):
-	case (1):
-	case (2):
-	case (3):
-		/* This will never happen because cpu 0 will never be turned off */
-		break;
-	case (4):
-	case (5):
-	case (6):
-	case (7):
-		if (pm_cpu_powered_down & (1 << 4))
-			count++;
-		if (pm_cpu_powered_down & (1 << 5))
-			count++;
-		if (pm_cpu_powered_down & (1 << 6))
-			count++;
-		if (pm_cpu_powered_down & (1 << 7))
-			count++;
-		if (count == 4)
-			return true;
-		break;
-	case (8):
-	case (9):
-	case (10):
-	case (11):
-		if (pm_cpu_powered_down & (1 << 8))
-			count++;
-		if (pm_cpu_powered_down & (1 << 9))
-			count++;
-		if (pm_cpu_powered_down & (1 << 10))
-			count++;
-		if (pm_cpu_powered_down & (1 << 11))
-			count++;
-		if (count == 4)
-			return true;
-		break;
-	case (12):
-	case (13):
-	case (14):
-	case (15):
-		if (pm_cpu_powered_down & (1 << 12))
-			count++;
-		if (pm_cpu_powered_down & (1 << 13))
-			count++;
-		if (pm_cpu_powered_down & (1 << 14))
-			count++;
-		if (pm_cpu_powered_down & (1 << 15))
-			count++;
-		if (count == 4)
-			return true;
-		break;
-	default:
-		pr_err("ERROR: the cpu does not exist: %d - %s:%d\n", cpu, __FILE__,
-				__LINE__);
-		break;
-	}
-#endif
-	return false;
-}
-
-bool pm_cpu_last_of_cluster(u32 cpu)
-{
-#ifdef CONFIG_HOTPLUG_CPU_L2_POWER_DOWN
-
-	u32 count = 0;
-
-	switch (cpu) {
-	case (0):
-	case (1):
-	case (2):
-	case (3):
-		/* This will never happen because cpu 0 will never be turned off */
-		break;
-	case (4):
-	case (5):
-	case (6):
-	case (7):
-		if (pm_cpu_powered_down & (1 << 4))
-			count++;
-		if (pm_cpu_powered_down & (1 << 5))
-			count++;
-		if (pm_cpu_powered_down & (1 << 6))
-			count++;
-		if (pm_cpu_powered_down & (1 << 7))
-			count++;
-		if (count == 3)
-			return true;
-		break;
-	case (8):
-	case (9):
-	case (10):
-	case (11):
-		if (pm_cpu_powered_down & (1 << 8))
-			count++;
-		if (pm_cpu_powered_down & (1 << 9))
-			count++;
-		if (pm_cpu_powered_down & (1 << 10))
-			count++;
-		if (pm_cpu_powered_down & (1 << 11))
-			count++;
-		if (count == 3)
-			return true;
-		break;
-	case (12):
-	case (13):
-	case (14):
-	case (15):
-		if (pm_cpu_powered_down & (1 << 12))
-			count++;
-		if (pm_cpu_powered_down & (1 << 13))
-			count++;
-		if (pm_cpu_powered_down & (1 << 14))
-			count++;
-		if (pm_cpu_powered_down & (1 << 15))
-			count++;
-		if (count == 3)
-			return true;
-		break;
-	default:
-		pr_err("ERROR: the cpu does not exist: %d - %s:%d\n", cpu,  __FILE__,
-				__LINE__);
-		break;
-	}
-#endif
-	return false;
-}
-
-static void pm_set_bits_syscon_register(u32 reg, u32 data)
-{
-	writel(data, syscon + reg);
-}
-
-static void pm_or_bits_syscon_register(u32 reg, u32 data)
-{
-	u32 tmp;
-
-	tmp = readl(syscon + reg);
-	tmp |= data;
-	writel(tmp, syscon + reg);
-}
-
-
-static void pm_clear_bits_syscon_register(u32 reg, u32 data)
-{
-	u32 tmp;
-
-	tmp = readl(syscon + reg);
-	tmp &= ~(data);
-	writel(tmp, syscon + reg);
-}
-
-static bool pm_test_for_bit_with_timeout(u32 reg, u32 bit)
-{
-
-	u32 tmp = 0;
-	u32 cnt = 0;
-
-	while (cnt < PM_WAIT_TIME) {
-		tmp = readl(syscon + reg);
-		if (CHECK_BIT(tmp, bit))
-			break;
-		cnt++;
-	}
-	if (cnt == PM_WAIT_TIME) {
-		pr_err("reg=0x%x tmp:=0x%x\n", reg, tmp);
-		return false;
-	}
-	return true;
-}
-
-static bool pm_wait_for_bit_clear_with_timeout(u32 reg, u32 bit)
-{
-	u32 cnt = 0;
-	u32 tmp = 0;
-
-	while (cnt < PM_WAIT_TIME) {
-		tmp = readl(syscon + reg);
-		if (!(CHECK_BIT(tmp, bit)))
-			break;
-		cnt++;
-	}
-	if (cnt == PM_WAIT_TIME) {
-		pr_err("reg=0x%x tmp:=0x%x\n", reg, tmp);
-		return false;
-	}
-
-	return true;
-}
-static void pm_dickens_logical_shutdown(u32 cluster)
-{
-	int i;
-	int status;
-	u32 bit;
-	u32 bit_pos;
-	int retries;
-
-	bit = (0x01 << cluster_to_node[cluster]);
-	bit_pos = cluster_to_node[cluster];
-
-	for (i = 0; i < DKN_HNF_TOTAL_NODES; ++i) {
-		writel(bit,
-				dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
-						+ DKN_HNF_SNOOP_DOMAIN_CTL_CLR);
-
-		retries = PM_WAIT_TIME;
-
-		do {
-			status = readl(
-					dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
-							+ DKN_HNF_SNOOP_DOMAIN_CTL);
-			udelay(1);
-		} while ((0 < --retries) && CHECK_BIT(status, bit_pos));
-
-		if (0 == retries) {
-			pr_err("DICKENS: Failed to clear the SNOOP main control. LOOP:%d reg: 0x%x\n", i, status);
-			return;
-
-		}
-
-	}
-	/* Clear the domain cluster */
-	writel(bit, dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET) + DKN_MN_DVM_DOMAIN_CTL_CLR);
-
-	/* Check for complete */
-	retries = PM_WAIT_TIME;
-
-	do {
-		status = readl(
-				dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET)
-						+ DKN_MN_DVM_DOMAIN_CTL);
-		udelay(1);
-	} while ((0 < --retries) && CHECK_BIT(status, bit_pos));
-
-	if (0 == retries) {
-		pr_err("DICKENS: failed to set DOMAIN OFFSET Reg=0x%x\n", status);
-		return;
-
-	}
-}
-
-static int pm_dickens_logical_powerup(u32 cluster)
-{
-	int i;
-	u32 status;
-	u32 bit;
-	u32 bit_pos;
-	int retries;
-	int rval = 0;
-
-
-	bit = (0x01 << cluster_to_node[cluster]);
-	bit_pos = cluster_to_node[cluster];
-
-	for (i = 0; i < DKN_HNF_TOTAL_NODES; ++i) {
-		writel(bit,
-				dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
-						+ DKN_HNF_SNOOP_DOMAIN_CTL_SET);
-
-		retries = PM_WAIT_TIME;
-
-		do {
-			status = readl(
-					dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
-							+ DKN_HNF_SNOOP_DOMAIN_CTL);
-			udelay(1);
-		} while ((0 < --retries) && !CHECK_BIT(status, bit_pos));
-
-		if (0 == retries) {
-			pr_err("DICKENS: Failed on the SNOOP DONAIN\n");
-			return -PM_ERR_DICKENS_SNOOP_DOMAIN;
-		}
-
-	}
-
-	/* Clear the domain cluster */
-	writel(bit, dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET) + DKN_MN_DVM_DOMAIN_CTL_SET);
-
-	/* Check for complete */
-	retries = PM_WAIT_TIME;
-
-	do {
-		status = readl(
-				dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET)
-						+ DKN_MN_DVM_DOMAIN_CTL);
-		udelay(1);
-	} while ((0 < --retries) && !CHECK_BIT(status, bit_pos));
-
-	if (0 == retries) {
-		pr_err("DICKENS: Failed on the SNOOP DONAIN CTL SET\n");
-		return -PM_ERR_DICKENS_SNOOP_DOMAIN;
-	}
-
-	return rval;
-}
-
-static void pm_disable_ipi_interrupts(u32 cpu)
-{
-	pm_clear_bits_syscon_register(ipi_register[cpu], IPI_IRQ_MASK);
-}
-
-static void pm_enable_ipi_interrupts(u32 cpu)
-{
-
-	u32 i;
-	u32 powered_on_cpu = (~(pm_cpu_powered_down) & IPI_IRQ_MASK);
-
-	pm_set_bits_syscon_register(ipi_register[cpu], powered_on_cpu);
-
-	for (i = 0; i < MAX_CPUS; i++) {
-		if ((1 << i) & powered_on_cpu)
-			pm_or_bits_syscon_register(ipi_register[i], (1 << cpu));
-	}
-}
-
-bool pm_cpu_active(u32 cpu)
-{
-
-	bool success = false;
-	u32 reg;
-
-	reg = readl(syscon + NCP_SYSCON_PWR_QACTIVE);
-	if (reg & (1 << cpu))
-		success = true;
-
-	return success;
-
-}
-
-void pm_cpu_shutdown(u32 cpu)
-{
-
-	bool success;
-	u32 reqcpu = cpu_logical_map(cpu);
-	u32 cluster = reqcpu / CORES_PER_CLUSTER;
-	u32 cluster_mask = (0x01 << cluster);
-	bool last_cpu;
-	int rval = 0;
-
-	/* Check to see if the cpu is powered up */
-	if (pm_cpu_powered_down & (1 << reqcpu)) {
-		pr_err("CPU %d is already powered off - %s:%d\n", cpu, __FILE__, __LINE__);
-		return;
-	}
-
-	/*
-	 * Is this the last cpu of a cluster then turn off the L2 cache
-	 * along with the CPU.
-	 */
-	last_cpu = pm_cpu_last_of_cluster(reqcpu);
-	if (last_cpu) {
-
-		/* Disable all the interrupts to the cluster gic */
-		pm_or_bits_syscon_register(NCP_SYSCON_GIC_DISABLE, cluster_mask);
-
-		/* Remove the cluster from the Dickens coherency domain */
-		pm_dickens_logical_shutdown(cluster);
-
-		/* Power down the cpu */
-		pm_cpu_physical_isolation_and_power_down(reqcpu);
-
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_CSYSREQ_CNT, cluster_mask);
-		success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_CACTIVE_CNT, cluster);
-		if (!success) {
-			pr_err(
-					"Failed to keep other cluster count going on cluster %d: %s-%d\n",
-					cluster, __FILE__, __LINE__);
-			goto pm_shutdown_exit;
-		}
-
-		/* Turn off the ACE */
-		pm_or_bits_syscon_register(NCP_SYSCON_PWR_ACEPWRDNRQ, cluster_mask);
-
-		/* Wait for ACE to complete power off */
-		success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NACEPWRDNACK, cluster);
-		if (!success) {
-			pr_err("Failed to power off ACE on cluster %d: %s-%d\n",
-					cluster, __FILE__, __LINE__);
-			goto pm_shutdown_exit;
-		}
-
-		/* Isolate the cluster */
-		pm_or_bits_syscon_register(NCP_SYSCON_PWR_ISOLATEL2MISC, cluster_mask);
-
-		/* Wait for WFI L2 to go to standby */
-		success = pm_test_for_bit_with_timeout(NCP_SYSCON_PWR_STANDBYWFIL2, cluster);
-		if (!success) {
-			pr_err("Failed to enter L2 WFI on cluster %d: %s-%d\n",
-					cluster, __FILE__, __LINE__);
-			goto pm_shutdown_exit;
-		}
-
-		/* Power off the L2 */
-		pm_L2_isolation_and_power_down(cluster);
-		if (rval == 0) {
-			pr_info("CPU %d is powered down with cluster: %d\n", reqcpu, cluster);
-			pm_cpu_powered_down |= (1 << reqcpu);
-		} else
-			pr_err("CPU %d failed to power down\n", reqcpu);
-
-
-	} else {
-
-		rval = pm_cpu_physical_isolation_and_power_down(reqcpu);
-		if (rval == 0)
-			pm_cpu_powered_down |= (1 << reqcpu);
-		else
-			pr_err("CPU %d failed to power down\n", reqcpu);
-	}
-
-pm_shutdown_exit:
-	return;
-
-}
-
-int pm_cpu_powerup(u32 cpu)
-{
-
-	bool first_cpu;
-	int rval = 0;
-	u32 cpu_mask = (0x01 << cpu);
-
-	u32 reqcpu = cpu_logical_map(cpu);
-	u32 cluster = reqcpu / CORES_PER_CLUSTER;
-
-	u32 cluster_mask = (0x01 << cluster);
-
-	/*
-	 * Is this the first cpu of a cluster to come back on?
-	 * Then power up the L2 cache.
-	 */
-	first_cpu = pm_first_cpu_of_cluster(cpu);
-	if (first_cpu) {
-
-		rval = pm_L2_logical_powerup(cluster, cpu);
-		if (rval) {
-			pr_err("CPU: Failed the logical L2 power up\n");
-			goto pm_power_up;
-		} else
-			pr_info("CPU %d is powered up with cluster: %d\n", reqcpu, cluster);
-
-		cluster_power_up[cluster] = true;
-		pm_clear_bits_syscon_register(NCP_SYSCON_GIC_DISABLE, cluster_mask);
-
-
-	} else {
-		/* Set the CPU into reset */
-		pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-		pm_or_bits_syscon_register(NCP_SYSCON_PWRUP_CPU_RST, cpu_mask);
-	}
-
-
-	/*
-	 * Power up the CPU
-	 */
-	rval = pm_cpu_physical_connection_and_power_up(cpu);
-	if (rval) {
-		pr_err("Failed to power up physical connection of cpu: %d\n", cpu);
-		goto pm_power_up;
-	}
-
-	/*
-	 * The key value must be written before the CPU RST can be written.
-	 */
-	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWRUP_CPU_RST,	cpu_mask);
-
-	/*
-	 * Clear the powered down mask
-	 */
-	pm_cpu_powered_down &= ~(1 << cpu);
-
-	/* Enable the CPU IPI */
-	pm_enable_ipi_interrupts(cpu);
-
-pm_power_up:
-	return rval;
-}
-
-unsigned long pm_get_powered_down_cpu(void)
-{
-	return pm_cpu_powered_down;
-}
-
-inline void pm_cpu_logical_powerup(void)
-{
-	unsigned int v;
-
-	asm volatile(
-			"	mrc	p15, 0, %0, c1, c0, 0\n"
-			"	orr	%0, %0, %1\n"
-			"	mcr	p15, 0, %0, c1, c0, 0\n"
-			"	mrc	p15, 0, %0, c1, c0, 0\n"
-			"	orr	%0, %0, %2\n"
-			"	mcr	p15, 0, %0, c1, c0, 0\n"
-			: "=&r" (v)
-			: "Ir" (CR_C), "Ir" (CR_I)
-			: "cc");
-
-	/*
-	 *  Iniitalize the ACTLR2 register (all cores).
-	*/
-
-	asm volatile(
-			"	mrc		p15, 1, %0, c15, c0, 4\n"
-			"	bic	%0, %0, %1\n"
-			"	mcr		p15, 1, %0, c15, c0, 4\n"
-			: "=&r" (v)
-			: "Ir" (0x1)
-			: "cc");
-
-	isb();
-	dsb();
-}
-
-inline void pm_cluster_logical_powerup(void)
-{
-	unsigned int v;
-
-	/*
-	 * Initialize the L2CTLR register (primary core in each cluster).
-	 */
-	asm volatile(
-	"	mrc	p15, 1, %0, c9, c0, 2\n"
-	"	orr	%0, %0, %1\n"
-	"	orr	%0, %0, %2\n"
-	"	mcr	p15, 1, %0, c9, c0, 2"
-	  : "=&r" (v)
-	  : "Ir" (0x01), "Ir" (0x1 << 21)
-	  : "cc");
-
-	isb();
-	dsb();
-
-	/*
-	 * Initialize the L2ACTLR register (primary core in each cluster).
-	 */
-	asm volatile(
-		"	mrc	p15, 1, r0, c15, c0, 0\n"
-		"	orr	%0, %0, %1\n"
-		"	orr	%0, %0, %2\n"
-		"	orr	%0, %0, %3\n"
-		"	orr	%0, %0, %4\n"
-		"	orr	%0, %0, %5\n"
-		"	mcr	p15, 1, %0, c15, c0, 0"
-		: "=&r" (v)
-			: "Ir" (0x1 << 3), "Ir" (0x1 << 7), "Ir" (0x1 << 12), "Ir" (0x1 << 13), "Ir" (0x1 << 14)
-		 : "cc");
-	isb();
-	dsb();
-}
-
-static int pm_cpu_physical_isolation_and_power_down(int cpu)
-{
-	int rval = 0;
-
-	bool success;
-	u32 mask = (0x01 << cpu);
-
-	/* Disable the CPU IPI */
-	pm_disable_ipi_interrupts(cpu);
-
-	/* Initiate power down of the CPU's HS Rams */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPURAM, mask);
-
-	/* Wait until the RAM power down is complete */
-	success = pm_test_for_bit_with_timeout(NCP_SYSCON_PWR_NPWRUPCPURAM_ACK, cpu);
-	if (!success) {
-		rval = -PM_ERR_FAILED_PWR_DWN_RAM;
-		pr_err("CPU: Failed to power down CPU RAM\n");
-		goto power_down_cleanup;
-	}
-
-	/* Activate the CPU's isolation clamps */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_ISOLATECPU, mask);
-
-	/* Initiate power down of the CPU logic */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG2, mask);
-
-	udelay(16);
-
-	/* Continue power down of the CPU logic */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG1, mask);
-
-	success = pm_test_for_bit_with_timeout(NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK, cpu);
-	if (!success) {
-		rval = -PM_ERR_FAILED_STAGE_1;
-		pr_err("CPU: Failed to power down stage 1 cpu\n");
-		goto power_down_cleanup;
-	}
-
-power_down_cleanup:
-	return rval;
-}
-
-static int pm_cpu_physical_connection_and_power_up(int cpu)
-{
-	int rval = 0;
-
-	bool success;
-	u32 mask = (0x01 << cpu);
-
-	/* Initiate power up of the CPU */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG1, mask);
-
-	/* Wait until CPU logic power is compete */
-	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK, cpu);
-	if (!success) {
-		rval = -PM_ERR_ACK1_FAIL;
-		pr_err("CPU: Failed to get ACK from power down stage 1\n");
-		goto power_up_cleanup;
-	}
-
-	/* Continue stage 2 power up of the CPU*/
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPUSTG2, mask);
-
-	udelay(16);
-
-	/* Initiate power up of HS Rams */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPCPURAM, mask);
-
-	/* Wait until the RAM power up is complete */
-	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPCPURAM_ACK, cpu);
-	if (!success) {
-		rval = -PM_ERR_RAM_ACK_FAIL;
-		pr_err("CPU: Failed to get ACK of power power up\n");
-		goto power_up_cleanup;
-	}
-
-	/* Release the CPU's isolation clamps */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ISOLATECPU, mask);
-
-	udelay(16);
-
-power_up_cleanup:
-
-	return rval;
-
-}
-/*========================================== L2 FUNCTIONS ========================================*/
-
-static void pm_L2_isolation_and_power_down(int cluster)
-{
-	u32 mask = (0x1 << cluster);
-
-	/* Enable the chip select for the cluster */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_CHIPSELECTEN, mask);
-
-	/* Disable the hsram */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2HSRAM, mask);
-
-	switch (cluster) {
-	case (0):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-
-#endif
-		break;
-	case (1):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-#endif
-		break;
-	case (2):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-#endif
-		break;
-	case (3):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-#endif
-		break;
-	default:
-		pr_err("Illegal cluster: %d > 3\n", cluster);
-		break;
-	}
-
-	/* Power down stage 2 */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG2, mask);
-
-	/* Power down stage 1 */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG1, mask);
-
-}
-
-static int pm_L2_physical_connection_and_power_up(u32 cluster)
-{
-
-	bool success;
-	u32 mask = (0x1 << cluster);
-	int rval = 0;
-
-	/* Power up stage 1 */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG1, mask);
-
-	/* Wait for the stage 1 power up to complete */
-	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPL2LGCSTG1_ACK, cluster);
-	if (!success) {
-		pr_err("CPU: Failed to ack the L2 Stage 1 Power up\n");
-		rval = -PM_ERR_FAIL_L2ACK;
-		goto power_up_l2_cleanup;
-	}
-
-	/* Power on stage 2 */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2LGCSTG2, mask);
-
-	/* Set the chip select */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_CHIPSELECTEN, mask);
-
-	/* Power up the snoop ram */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL2HSRAM, mask);
-
-	/* Wait for the stage 1 power up to complete */
-	success = pm_wait_for_bit_clear_with_timeout(NCP_SYSCON_PWR_NPWRUPL2HSRAM_ACK, cluster);
-	if (!success) {
-		pr_err("CPU: failed to get the HSRAM power up ACK\n");
-		rval = -PM_ERR_FAIL_L2HSRAM;
-		goto power_up_l2_cleanup;
-	}
-
-	switch (cluster) {
-	case (0):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-
-#endif
-		break;
-	case (1):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-	udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-#endif
-		break;
-	case (2):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-#endif
-		break;
-	case (3):
-
-#ifdef PM_POWER_OFF_ONLY_DATARAM
-
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK0_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_BANK1_LS_MASK);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK1_MS_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK2_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(syscon,
-				NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_BANK3_MASK);
-		udelay(20);
-#else
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1, RAM_ALL_MASK);
-		udelay(20);
-		pm_set_bits_syscon_register(NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0, RAM_ALL_MASK);
-		udelay(20);
-#endif
-		break;
-	default:
-		pr_err("Illegal cluster: %d > 3\n", cluster);
-		break;
-	}
-
-	/* Clear the chip select */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_CHIPSELECTEN, mask);
-
-	/* Release the isolation clamps */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ISOLATEL2MISC, mask);
-
-	/* Turn the ACE bridge power on*/
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ACEPWRDNRQ, mask);
-
-power_up_l2_cleanup:
-	return rval;
-}
-
-static int pm_L2_logical_powerup(u32 cluster, u32 cpu)
-{
-
-	u32 mask = (0x1 << cluster);
-	int rval = 0;
-	u32 cluster_mask;
-
-	if (cluster == 0)
-		cluster_mask = 0xe;
-	else
-		cluster_mask = 0xf << (cluster * 4);
-
-	/* put the cluster into a cpu hold */
-	pm_or_bits_syscon_register(NCP_SYSCON_RESET_AXIS,
-			cluster_to_poreset[cluster]);
-
-	/*
-	 * The key value has to be written before the CPU RST can be written.
-	 */
-	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-	pm_or_bits_syscon_register(NCP_SYSCON_PWRUP_CPU_RST, cluster_mask);
-
-	/* Hold the chip debug cluster */
-	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-	pm_or_bits_syscon_register(NCP_SYSCON_HOLD_DBG, mask);
-
-	/* Hold the L2 cluster */
-	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-	pm_or_bits_syscon_register(NCP_SYSCON_HOLD_L2, mask);
-
-
-	/* Cluster physical power up */
-	rval = pm_L2_physical_connection_and_power_up(cluster);
-	if (rval)
-		goto exit_pm_L2_logical_powerup;
-
-	udelay(16);
-
-	/* take the cluster out of a cpu hold */
-	pm_clear_bits_syscon_register(NCP_SYSCON_RESET_AXIS,
-			cluster_to_poreset[cluster]);
-
-	udelay(64);
-
-	/* Enable the system counter */
-	pm_or_bits_syscon_register(NCP_SYSCON_PWR_CSYSREQ_CNT, mask);
-
-	/* Release the L2 cluster */
-	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-	pm_clear_bits_syscon_register(NCP_SYSCON_HOLD_L2, mask);
-
-	/* Release the chip debug cluster */
-	pm_set_bits_syscon_register(NCP_SYSCON_KEY, VALID_KEY_VALUE);
-	pm_clear_bits_syscon_register(NCP_SYSCON_HOLD_DBG, mask);
-
-	/* Power up the dickens */
-	rval = pm_dickens_logical_powerup(cluster);
-	if (rval)
-		goto exit_pm_L2_logical_powerup;
-
-	/* start L2 */
-	pm_clear_bits_syscon_register(NCP_SYSCON_PWR_ACINACTM, mask);
-
-exit_pm_L2_logical_powerup:
-
-	return rval;
-
-}
-
-#ifdef DEBUG_CPU_PM
-
-void pm_debug_read_pwr_registers(void)
-{
-	u32 reg;
-
-	reg = readl(syscon + 0x1400);
-	pr_err("NCP_SYSCON_PWR_CLKEN: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_PWR_ACINACTM);
-	pr_err("NCP_SYSCON_PWR_ACINACTM: 0x%x\n", reg);
-	reg = readl(syscon + 0x140c);
-	pr_err("NCP_SYSCON_PWR_CHIPSELECTEN: 0x%x\n", reg);
-	reg = readl(syscon + 0x1410);
-	pr_err("NCP_SYSCON_PWR_CSYSREQ_TS: 0x%x\n", reg);
-	reg = readl(syscon + 0x1414);
-	pr_err("NCP_SYSCON_PWR_CSYSREQ_CNT: 0x%x\n", reg);
-	reg = readl(syscon + 0x1418);
-	pr_err("NCP_SYSCON_PWR_CSYSREQ_ATB: 0x%x\n", reg);
-	reg = readl(syscon + 0x141c);
-	pr_err("NCP_SYSCON_PWR_CSYSREQ_APB: 0x%x\n", reg);
-	reg = readl(syscon + 0x1420);
-	pr_err("NCP_SYSCON_PWR_PWRUPL2LGCSTG1: 0x%x\n", reg);
-	reg = readl(syscon + 0x1424);
-	pr_err("NCP_SYSCON_PWR_PWRUPL2LGCSTG2: 0x%x\n", reg);
-	reg = readl(syscon + 0x1428);
-	pr_err("NCP_SYSCON_PWR_PWRUPL2HSRAM: 0x%x\n", reg);
-	reg = readl(syscon + 0x142c);
-	pr_err("NCP_SYSCON_PWR_ACEPWRDNRQ: 0x%x\n", reg);
-	reg = readl(syscon + 0x1430);
-	pr_err("NCP_SYSCON_PWR_ISOLATEL2MIS: 0x%x\n", reg);
-	reg = readl(syscon + 0x1438);
-	pr_err("NCP_SYSCON_PWR_NPWRUPL2LGCSTG1_ACK: 0x%x\n", reg);
-	reg = readl(syscon + 0x143c);
-	pr_err("NCP_SYSCON_PWR_NPWRUPL2HSRAM_ACK: 0x%x\n", reg);
-	reg = readl(syscon + 0x1440);
-	pr_err("NCP_SYSCON_PWR_STANDBYWFIL2: 0x%x\n", reg);
-	reg = readl(syscon + 0x1444);
-	pr_err("NCP_SYSCON_PWR_CSYSACK_TS: 0x%x\n", reg);
-	reg = readl(syscon + 0x1448);
-	pr_err("NCP_SYSCON_PWR_CACTIVE_TS: 0x%x\n", reg);
-	reg = readl(syscon + 0x144c);
-	pr_err("NCP_SYSCON_PWR_CSYSACK_CNT: 0x%x\n", reg);
-	reg = readl(syscon + 0x1450);
-	pr_err("NCP_SYSCON_PWR_CACTIVE_CNT: 0x%x\n", reg);
-	reg = readl(syscon + 0x1454);
-	pr_err("NCP_SYSCON_PWR_CSYSACK_ATB: 0x%x\n", reg);
-	reg = readl(syscon + 0x1458);
-	pr_err("NCP_SYSCON_PWR_CACTIVE_ATB: 0x%x\n", reg);
-	reg = readl(syscon + 0x145c);
-	pr_err("NCP_SYSCON_PWR_CSYSACK_APB: 0x%x\n", reg);
-	reg = readl(syscon + 0x1460);
-	pr_err("NCP_SYSCON_PWR_CACTIVE_APB: 0x%x\n", reg);
-	reg = readl(syscon + 0x1464);
-	pr_err("NCP_SYSCON_PWR_NACEPWRDNACK: 0x%x\n", reg);
-	reg = readl(syscon + 0x1468);
-	pr_err("NCP_SYSCON_PWR_CACTIVEM_EAGM: 0x%x\n", reg);
-	reg = readl(syscon + 0x146c);
-	pr_err("NCP_SYSCON_PWR_CACTIVEM_EAGS: 0x%x\n", reg);
-	reg = readl(syscon + 0x1470);
-	pr_err("NCP_SYSCON_PWR_CACTIVES_EAGM: 0x%x\n", reg);
-	reg = readl(syscon + 0x1474);
-	pr_err("NCP_SYSCON_PWR_CACTIVES_EAGS: 0x%x\n", reg);
-	reg = readl(syscon + 0x1480);
-	pr_err("NCP_SYSCON_PWR_PWRUPCPUSTG1: 0x%x\n", reg);
-	reg = readl(syscon + 0x1484);
-	pr_err("NCP_SYSCON_PWR_PWRUPCPUSTG2: 0x%x\n", reg);
-	reg = readl(syscon + 0x1488);
-	pr_err("NCP_SYSCON_PWR_PWRUPCPURAM: 0x%x\n", reg);
-	reg = readl(syscon + 0x148c);
-	pr_err("NCP_SYSCON_PWR_ISOLATECPU: 0x%x\n", reg);
-	reg = readl(syscon + 0x1490);
-	pr_err("NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK: 0x%x\n", reg);
-	reg = readl(syscon + 0x1494);
-	pr_err("NCP_SYSCON_PWR_NPWRUPCPURAM_ACK: 0x%x\n", reg);
-	reg = readl(syscon + 0x1498);
-	pr_err("NCP_SYSCON_PWR_QACTIVE: 0x%x\n", reg);
-	reg = readl(syscon + 0x149C);
-	pr_err("NCP_SYSCON_PWR_STANDBYWFI: 0x%x\n", reg);
-	reg = readl(syscon + 0x14A0);
-	pr_err("NCP_SYSCON_PWR_STANDBYWFE: 0x%x\n", reg);
-	reg = readl(syscon + 0x14A4);
-	pr_err("NCP_SYSCON_PWR_DBGNOPWRDWN: 0x%x\n", reg);
-	reg = readl(syscon + 0x14A8);
-	pr_err("NCP_SYSCON_PWR_DBGPWRUPREQ: 0x%x\n", reg);
-	reg = readl(syscon + 0x1040);
-	pr_err("NCP_SYSCON_RESET_AXIS: 0x%x\n", reg);
-	reg = readl(syscon + 0x1044);
-	pr_err("NCP_SYSCON_RESET_AXIS-WORD1: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_RESET_CPU);
-	pr_err("NCP_SYSCON_RESET_CPU: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_HOLD_DBG);
-	pr_err("NCP_SYSCON_HOLD_DBG: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_HOLD_L2);
-	pr_err("NCP_SYSCON_HOLD_L2: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_HOLD_CPU);
-	pr_err("NCP_SYSCON_HOLD_CPU: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_PWRUP_CPU_RST);
-	pr_err("NCP_SYSCON_PWRUP_CPU_RST: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_RESET_STATUS);
-	pr_err("NCP_SYSCON_RESET_STATUS: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_RESET_CORE_STATUS);
-	pr_err("NCP_SYSCON_RESET_CORE_STATUS: 0x%x\n", reg);
-
-
-#if 0
-	reg = readl(syscon + NCP_SYSCON_MCG_CSW_CPU);
-	pr_err("NCP_SYSCON_MCG_CSW_CPU: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MCG_CSW_SYS);
-	pr_err("NCP_SYSCON_MCG_CSW_SYS: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MCG_DIV_CPU);
-	pr_err("NCP_SYSCON_MCG_DIV_CPU: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MCG_DIV_SYS);
-	pr_err("NCP_SYSCON_MCG_DIV_SYS: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_CLKDEBUG);
-	pr_err("NCP_SYSCON_CLKDEBUG: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_EVENT_ENB);
-	pr_err("NCP_SYSCON_EVENT_ENB: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_CPU_FAST_INT);
-	pr_err("NCP_SYSCON_CPU_FAST_INT: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_GIC_DISABLE);
-	pr_err("NCP_SYSCON_GIC_DISABLE: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_CP15SDISABLE);
-	pr_err("NCP_SYSCON_CP15SDISABLE: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_LDO_CTL);
-	pr_err("NCP_SYSCON_LDO_CTL: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_SHWK_QOS);
-	pr_err("NCP_SYSCON_SHWK_QOS: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_FUSE_RTO);
-	pr_err("NCP_SYSCON_FUSE_RTO: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_PFUSE);
-	pr_err("NCP_SYSCON_PFUSE: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_FUSE_STAT);
-	pr_err("NCP_SYSCON_FUSE_STAT: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_SCRATCH);
-	pr_err("NCP_SYSCON_SCRATCH: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI0);
-	pr_err("NCP_SYSCON_MASK_IPI0: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI1);
-	pr_err("NCP_SYSCON_MASK_IPI1: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI2);
-	pr_err("NCP_SYSCON_MASK_IPI2: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI3);
-	pr_err("NCP_SYSCON_MASK_IPI3: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI4);
-	pr_err("NCP_SYSCON_MASK_IPI4: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI5);
-	pr_err("NCP_SYSCON_MASK_IPI5: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI6);
-	pr_err("NCP_SYSCON_MASK_IPI6: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI7);
-	pr_err("NCP_SYSCON_MASK_IPI7: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI8);
-	pr_err("NCP_SYSCON_MASK_IPI8: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI9);
-	pr_err("NCP_SYSCON_MASK_IPI9: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI10);
-	pr_err("NCP_SYSCON_MASK_IPI10: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI11);
-	pr_err("NCP_SYSCON_MASK_IPI11: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI12);
-	pr_err("NCP_SYSCON_MASK_IPI12: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI13);
-	pr_err("NCP_SYSCON_MASK_IPI13: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI14);
-	pr_err("NCP_SYSCON_MASK_IPI14: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_MASK_IPI15);
-	pr_err("NCP_SYSCON_MASK_IPI15: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_SPARE0);
-	pr_err("NCP_SYSCON_SPARE0: 0x%x\n", reg);
-	reg = readl(syscon + NCP_SYSCON_STOP_CLK_CPU);
-	pr_err("NCP_SYSCON_STOP_CLK_CPU: 0x%x\n", reg);
-#endif
-
-
-}
-
-
-void pm_dump_L2_registers(void)
-{
-	u32 reg;
-
-
-	reg = readl(syscon + 0x1580);
-	pr_err("NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2: 0x%x\n", reg);
-	reg = readl(syscon + 0x1584);
-	pr_err("NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1: 0x%x\n", reg);
-	reg = readl(syscon + 0x1588);
-	pr_err("NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0: 0x%x\n", reg);
-	reg = readl(syscon + 0x158c);
-	pr_err("NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2: 0x%x\n", reg);
-	reg = readl(syscon + 0x1590);
-	pr_err("NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1: 0x%x\n", reg);
-	reg = readl(syscon + 0x1594);
-	pr_err("NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0: 0x%x\n", reg);
-	reg = readl(syscon + 0x1598);
-	pr_err("NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2: 0x%x\n", reg);
-	reg = readl(syscon + 0x159c);
-	pr_err("NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1: 0x%x\n", reg);
-	reg = readl(syscon + 0x15a0);
-	pr_err("NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0: 0x%x\n", reg);
-	reg = readl(syscon + 0x15a4);
-	pr_err("NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2: 0x%x\n", reg);
-	reg = readl(syscon + 0x15a8);
-	pr_err("NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1: 0x%x\n", reg);
-	reg = readl(syscon + 0x15ac);
-	pr_err("NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0: 0x%x\n", reg);
-
-
-
-
-void pm_dump_dickens(void)
-{
-
-	u32 status;
-	u32 i;
-
-	for (i = 0; i < DKN_HNF_TOTAL_NODES; ++i) {
-		status = readl(
-				dickens + (0x10000 * (DKN_HNF_NODE_ID + i))
-						+ DKN_HNF_SNOOP_DOMAIN_CTL);
-		udelay(1);
-		pr_err("DKN_HNF_SNOOP_DOMAIN_CTL[%d]: 0x%x\n", i, status);
-	}
-
-	status = readl(
-			dickens + (0x10000 * DKN_DVM_DOMAIN_OFFSET)
-					+ DKN_MN_DVM_DOMAIN_CTL);
-
-	pr_err("DKN_MN_DVM_DOMAIN_CTL: 0x%x\n", status);
-}
-
-#endif
diff --git a/arch/arm/mach-axxia/lsi_power_management.h b/arch/arm/mach-axxia/lsi_power_management.h
deleted file mode 100644
index ef70af3..0000000
--- a/arch/arm/mach-axxia/lsi_power_management.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * lsi_power_management.h
- *
- *  Created on: Jun 23, 2014
- *      Author: z8cpaul
- */
-
-#ifndef LSI_POWER_MANAGEMENT_H_
-#define LSI_POWER_MANAGEMENT_H_
-
-
-#define     NCP_SYSCON_MCG_CSW_CPU                              (0x00000000)
-#define     NCP_SYSCON_MCG_CSW_SYS                              (0x00000004)
-#define     NCP_SYSCON_MCG_DIV_CPU                              (0x00000008)
-#define     NCP_SYSCON_MCG_DIV_SYS                              (0x0000000c)
-#define     NCP_SYSCON_CLKDEBUG                                 (0x00000010)
-#define     NCP_SYSCON_EVENT_ENB                                (0x00000014)
-#define     NCP_SYSCON_CPU_FAST_INT                             (0x00000018)
-#define     NCP_SYSCON_GIC_DISABLE                              (0x0000001c)
-#define     NCP_SYSCON_CP15SDISABLE                             (0x00000020)
-#define     NCP_SYSCON_LRSTDISABLE                              (0x00000024)
-#define     NCP_SYSCON_LDO_CTL                                  (0x00000028)
-#define     NCP_SYSCON_SHWK_QOS                                 (0x0000002c)
-#define     NCP_SYSCON_FUSE_RTO                                 (0x00000030)
-#define     NCP_SYSCON_PFUSE                                    (0x00000034)
-#define     NCP_SYSCON_FUSE_STAT                                (0x00000038)
-#define     NCP_SYSCON_SCRATCH                                  (0x0000003c)
-#define     NCP_SYSCON_MASK_IPI0                                (0x00000040)
-#define     NCP_SYSCON_MASK_IPI1                                (0x00000044)
-#define     NCP_SYSCON_MASK_IPI2                                (0x00000048)
-#define     NCP_SYSCON_MASK_IPI3                                (0x0000004c)
-#define     NCP_SYSCON_MASK_IPI4                                (0x00000050)
-#define     NCP_SYSCON_MASK_IPI5                                (0x00000054)
-#define     NCP_SYSCON_MASK_IPI6                                (0x00000058)
-#define     NCP_SYSCON_MASK_IPI7                                (0x0000005c)
-#define     NCP_SYSCON_MASK_IPI8                                (0x00000060)
-#define     NCP_SYSCON_MASK_IPI9                                (0x00000064)
-#define     NCP_SYSCON_MASK_IPI10                               (0x00000068)
-#define     NCP_SYSCON_MASK_IPI11                               (0x0000006c)
-#define     NCP_SYSCON_MASK_IPI12                               (0x00000070)
-#define     NCP_SYSCON_MASK_IPI13                               (0x00000074)
-#define     NCP_SYSCON_MASK_IPI14                               (0x00000078)
-#define     NCP_SYSCON_MASK_IPI15                               (0x0000007c)
-#define     NCP_SYSCON_MASK_IPI16                               (0x00000080)
-#define     NCP_SYSCON_MASK_IPI17                               (0x00000084)
-#define     NCP_SYSCON_MASK_IPI18                               (0x00000088)
-#define     NCP_SYSCON_SPARE0                                   (0x0000008c)
-#define     NCP_SYSCON_STOP_CLK_CPU                             (0x00000090)
-
-
-#define     NCP_SYSCON_RESET_STATUS                             (0x00000100)
-#define     NCP_SYSCON_RESET_CORE_STATUS                        (0x00000108)
-
-#define     NCP_SYSCON_KEY                                      (0x00001000)
-#define     NCP_SYSCON_RESET_CTL                                (0x00001008)
-#define     NCP_SYSCON_RESET_CPU                                (0x0000100c)
-#define     NCP_SYSCON_HOLD_CPU                                 (0x00001010)
-#define     NCP_SYSCON_HOLD_PTM                                 (0x00001014)
-#define     NCP_SYSCON_HOLD_L2                                  (0x00001018)
-#define     NCP_SYSCON_HOLD_DBG                                 (0x0000101c)
-
-#define     NCP_SYSCON_PWRUP_CPU_RST                            (0x00001030)
-
-#define     NCP_SYSCON_RESET_AXIS                               (0x00001040)
-#define     NCP_SYSCON_RESET_AXIS_ACCESS_SIZE                   (0x00000008)
-
-#define     NCP_SYSCON_PWR_CLKEN                                (0x00001400)
-#define     NCP_SYSCON_ENABLE_CLKEN_SET                         (0x00001404)
-#define     NCP_SYSCON_PWR_ACINACTM                             (0x00001408)
-#define     NCP_SYSCON_PWR_CHIPSELECTEN                         (0x0000140c)
-#define     NCP_SYSCON_PWR_CSYSREQ_TS                           (0x00001410)
-#define     NCP_SYSCON_PWR_CSYSREQ_CNT                          (0x00001414)
-#define     NCP_SYSCON_PWR_CSYSREQ_ATB                          (0x00001418)
-#define     NCP_SYSCON_PWR_CSYSREQ_APB                          (0x0000141c)
-#define     NCP_SYSCON_PWR_PWRUPL2LGCSTG1                       (0x00001420)
-#define     NCP_SYSCON_PWR_PWRUPL2LGCSTG2                       (0x00001424)
-#define     NCP_SYSCON_PWR_PWRUPL2HSRAM                         (0x00001428)
-#define     NCP_SYSCON_PWR_ACEPWRDNRQ                           (0x0000142c)
-#define     NCP_SYSCON_PWR_ISOLATEL2MISC                        (0x00001430)
-#define     NCP_SYSCON_PWR_NPWRUPL2LGCSTG1_ACK                  (0x00001438)
-#define     NCP_SYSCON_PWR_NPWRUPL2HSRAM_ACK                    (0x0000143c)
-#define     NCP_SYSCON_PWR_STANDBYWFIL2                         (0x00001440)
-#define     NCP_SYSCON_PWR_CSYSACK_TS                           (0x00001444)
-#define     NCP_SYSCON_PWR_CACTIVE_TS                           (0x00001448)
-#define     NCP_SYSCON_PWR_CSYSACK_CNT                          (0x0000144c)
-#define     NCP_SYSCON_PWR_CACTIVE_CNT                          (0x00001450)
-#define     NCP_SYSCON_PWR_CSYSACK_ATB                          (0x00001454)
-#define     NCP_SYSCON_PWR_CACTIVE_ATB                          (0x00001458)
-#define     NCP_SYSCON_PWR_CSYSACK_APB                          (0x0000145c)
-#define     NCP_SYSCON_PWR_CACTIVE_APB                          (0x00001460)
-#define     NCP_SYSCON_PWR_NACEPWRDNACK                         (0x00001464)
-#define     NCP_SYSCON_PWR_CACTIVEM_EAGM                        (0x00001468)
-#define     NCP_SYSCON_PWR_CACTIVEM_EAGS                        (0x0000146c)
-#define     NCP_SYSCON_PWR_CACTIVES_EAGM                        (0x00001470)
-#define     NCP_SYSCON_PWR_CACTIVES_EAGS                        (0x00001474)
-#define     NCP_SYSCON_PWR_PWRUPCPUSTG1                         (0x00001480)
-#define     NCP_SYSCON_PWR_PWRUPCPUSTG2                         (0x00001484)
-#define     NCP_SYSCON_PWR_PWRUPCPURAM                          (0x00001488)
-#define     NCP_SYSCON_PWR_ISOLATECPU                           (0x0000148c)
-#define     NCP_SYSCON_PWR_NPWRUPCPUSTG1_ACK                    (0x00001490)
-#define     NCP_SYSCON_PWR_NPWRUPCPURAM_ACK                     (0x00001494)
-#define     NCP_SYSCON_PWR_QACTIVE                              (0x00001498)
-#define     NCP_SYSCON_PWR_STANDBYWFI                           (0x0000149c)
-#define     NCP_SYSCON_PWR_STANDBYWFE                           (0x000014a0)
-#define     NCP_SYSCON_PWR_DBGNOPWRDWN                          (0x000014a4)
-#define     NCP_SYSCON_PWR_DBGPWRUPREQ                          (0x000014a8)
-#define     NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM2              (0x00001580)
-#define     NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM1              (0x00001584)
-#define     NCP_SYSCON_PWR_PWRUPL20RAM_PWRUPL2RAM0              (0x00001588)
-#define     NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM2              (0x0000158c)
-#define     NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM1              (0x00001590)
-#define     NCP_SYSCON_PWR_PWRUPL21RAM_PWRUPL2RAM0              (0x00001594)
-#define     NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM2              (0x00001598)
-#define     NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM1              (0x0000159c)
-#define     NCP_SYSCON_PWR_PWRUPL22RAM_PWRUPL2RAM0              (0x000015a0)
-#define     NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM2              (0x000015a4)
-#define     NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM1              (0x000015a8)
-#define     NCP_SYSCON_PWR_PWRUPL23RAM_PWRUPL2RAM0              (0x000015ac)
-
-#define		RAM_BANK0_MASK			(0x0FFF0000)
-#define		RAM_BANK1_LS_MASK		(0xF0000000)
-#define		RAM_BANK1_MS_MASK		(0x000000FF)
-#define		RAM_BANK2_MASK			(0x000FFF00)
-#define		RAM_BANK3_MASK			(0xFFF00000)
-#define		RAM_ALL_MASK			(0xFFFFFFFF)
-
-/* DICKENS REGISTERS (Miscelaneous Node) */
-#define		DKN_MN_NODE_ID				(0x0)
-#define		DKN_DVM_DOMAIN_OFFSET		(0x0)
-#define		DKN_MN_DVM_DOMAIN_CTL		(0x200)
-#define		DKN_MN_DVM_DOMAIN_CTL_SET	(0x210)
-#define		DKN_MN_DVM_DOMAIN_CTL_CLR	(0x220)
-
-/* DICKENS HN-F (Fully-coherent Home Node) */
-#define		DKN_HNF_NODE_ID					(0x20)
-#define		DKN_HNF_TOTAL_NODES				(0x8)
-#define		DKN_HNF_SNOOP_DOMAIN_CTL		(0x200)
-#define		DKN_HNF_SNOOP_DOMAIN_CTL_SET	(0x210)
-#define		DKN_HNF_SNOOP_DOMAIN_CTL_CLR	(0x220)
-
-/* DICKENS clustid to Node */
-#define		DKN_CLUSTER0_NODE		(1)
-#define		DKN_CLUSTER1_NODE		(9)
-#define		DKN_CLUSTER2_NODE		(11)
-#define		DKN_CLUSTER3_NODE		(19)
-
-/* PO RESET cluster id to bit */
-#define		PORESET_CLUSTER0		(0x10000)
-#define		PORESET_CLUSTER1		(0x20000)
-#define		PORESET_CLUSTER2		(0x40000)
-#define		PORESET_CLUSTER3		(0x80000)
-
-/* IPI Masks */
-#define		IPI0_MASK				(0x1111)
-#define		IPI1_MASK				(0x2222)
-#define		IPI2_MASK				(0x4444)
-#define 	IPI3_MASK				(0x8888)
-
-/* SYSCON KEY Value */
-#define VALID_KEY_VALUE			(0xAB)
-
-#define MAX_NUM_CLUSTERS    (4)
-#define CORES_PER_CLUSTER   (4)
-#define MAX_IPI				(19)
-#define MAX_CPUS			(MAX_NUM_CLUSTERS * CORES_PER_CLUSTER)
-
-typedef struct {
-	u32 cpu;
-	u32 cluster;
-} pm_data;
-
-
-void pm_cpu_shutdown(u32 cpu);
-int pm_cpu_powerup(u32 cpu);
-void pm_debug_read_pwr_registers(void);
-void pm_dump_L2_registers(void);
-int pm_cpu_logical_die(pm_data *pm_request);
-int pm_cpul2_logical_die(pm_data *pm_request);
-unsigned long pm_get_powered_down_cpu(void);
-bool pm_cpu_last_of_cluster(u32 cpu);
-void pm_dump_dickens(void);
-void pm_init_cpu(u32 cpu);
-void pm_cpu_logical_powerup(void);
-void pm_cluster_logical_powerup(void);
-bool pm_cpu_active(u32 cpu);
-void pm_init_syscon(void);
-extern bool pm_in_progress[];
-extern bool cluster_power_up[];
-extern u32 pm_cpu_powered_down;
-
-
-#endif /* LSI_POWER_MANAGEMENT_H_ */
diff --git a/arch/arm/mach-axxia/perf_event_memc.c b/arch/arm/mach-axxia/perf_event_memc.c
index cec554b..89c7b86 100644
--- a/arch/arm/mach-axxia/perf_event_memc.c
+++ b/arch/arm/mach-axxia/perf_event_memc.c
@@ -2,9 +2,9 @@
  * arch/arm/mach-axxia/perf_event_memc.c
  * included from arch/arm/mach-axxia/perf_event_platform.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2014 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-axxia/perf_event_memc.h b/arch/arm/mach-axxia/perf_event_memc.h
index e2f266f..d0106f3 100644
--- a/arch/arm/mach-axxia/perf_event_memc.h
+++ b/arch/arm/mach-axxia/perf_event_memc.h
@@ -2,9 +2,9 @@
  * arch/arm/mach-axxia/perf_event_memc.h
  * included from arch/arm/mach-axxia/perf_event_memc.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2014 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-axxia/perf_event_pcx.c b/arch/arm/mach-axxia/perf_event_pcx.c
index d6d78d6..c8cfec3 100644
--- a/arch/arm/mach-axxia/perf_event_pcx.c
+++ b/arch/arm/mach-axxia/perf_event_pcx.c
@@ -2,9 +2,9 @@
  * arch/arm/mach-axxia/perf_event_pcx.c
  * included from arch/arm/mach-axxia/perf_event_platform.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2014 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-axxia/perf_event_platform.c b/arch/arm/mach-axxia/perf_event_platform.c
index 8da1c42..0d55a37 100644
--- a/arch/arm/mach-axxia/perf_event_platform.c
+++ b/arch/arm/mach-axxia/perf_event_platform.c
@@ -1,9 +1,9 @@
 /*
  * arch/arm/mach-axxia/perf_event_platform.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2014 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -45,7 +45,7 @@
 #include <linux/proc_fs.h>
 
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <asm/cacheflush.h>
 
 #include "perf_event_platform.h"
@@ -198,7 +198,7 @@ static void axmperf_device_release(struct device *dev)
 
 #define PLATFORM_PMU_NAME_LEN 32
 
-struct lsi_platform_pmu {
+struct axxia_platform_pmu {
 	struct pmu pmu;
 	char name[PLATFORM_PMU_NAME_LEN];
 };
@@ -206,9 +206,9 @@ struct lsi_platform_pmu {
 static int axmperf_probe(struct platform_device *dev)
 {
 	int ret;
-	struct lsi_platform_pmu *axm_pmu;
+	struct axxia_platform_pmu *axm_pmu;
 
-	axm_pmu = kzalloc(sizeof(struct lsi_platform_pmu), GFP_KERNEL);
+	axm_pmu = kzalloc(sizeof(struct axxia_platform_pmu), GFP_KERNEL);
 	if (!axm_pmu) {
 		pr_warn("Failed platform perf memory alloc!\n");
 		return -ENOMEM;
@@ -225,7 +225,7 @@ static int axmperf_probe(struct platform_device *dev)
 		.event_idx = platform_pmu_event_idx,
 	};
 
-	sprintf(axm_pmu->name, "LSI AXM55xx Platform");
+	sprintf(axm_pmu->name, "INTEL Axxia AXM55xx Platform");
 
 	ret = perf_pmu_register(&axm_pmu->pmu, axm_pmu->name, PERF_TYPE_RAW);
 
@@ -241,15 +241,15 @@ static int axmperf_probe(struct platform_device *dev)
 	return ret;
 }
 
-static const struct of_device_id lsi_platformperf_match[] = {
-	{ .compatible = "lsi,axm-platformperf", },
+static const struct of_device_id axxia_platformperf_match[] = {
+	{ .compatible = "axxia,axm-platformperf", },
 	{},
 };
 
 static struct platform_driver axmperf_driver = {
 	.driver = {
 		.name = "AXM55xxPlatformPerf",
-		.of_match_table = lsi_platformperf_match,
+		.of_match_table = axxia_platformperf_match,
 		.owner = THIS_MODULE,
 		},
 	.probe = axmperf_probe,
diff --git a/arch/arm/mach-axxia/perf_event_vp.c b/arch/arm/mach-axxia/perf_event_vp.c
index 6405db8..5d4a750 100644
--- a/arch/arm/mach-axxia/perf_event_vp.c
+++ b/arch/arm/mach-axxia/perf_event_vp.c
@@ -2,9 +2,9 @@
  * arch/arm/mach-axxia/perf_event_vp.c
  * included from arch/arm/mach-axxia/perf_event_platform.c
  *
- * Support for the LSI Axxia boards based on ARM cores.
+ * Support for the INTEL Axxia boards based on ARM cores.
  *
- * Copyright (C) 2014 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-axxia/platsmp.c b/arch/arm/mach-axxia/platsmp.c
index e27cb45..2e9f1d6 100644
--- a/arch/arm/mach-axxia/platsmp.c
+++ b/arch/arm/mach-axxia/platsmp.c
@@ -1,7 +1,7 @@
 /*
  * linux/arch/arm/mach-axxia/platsmp.c
  *
- * Copyright (C) 2012 LSI Corporation
+ * Copyright (C) 2012 INTEL Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -24,7 +24,7 @@
 #include <asm/virt.h>
 
 #include "axxia.h"
-#include "lsi_power_management.h"
+#include "axxia_power_management.h"
 #include <mach/axxia-gic.h>
 
 #define SYSCON_PHYS_ADDR 0x002010030000ULL
@@ -237,9 +237,9 @@ static void __init axxia_smp_prepare_cpus(unsigned int max_cpus)
 	do_fixup_sev();
 
 	if (of_find_compatible_node(NULL, NULL,
-				    "lsi,axm5500-sim") != NULL ||
+				    "axxia,axm5500-sim") != NULL ||
 	    of_find_compatible_node(NULL, NULL,
-				    "lsi,axm5500-emu") != NULL)
+				    "axxia,axm5500-emu") != NULL)
 		wfe_available = 0;
 	else
 		wfe_available = 1;
diff --git a/arch/arm/mach-axxia/rapidio.c b/arch/arm/mach-axxia/rapidio.c
index 04e57be..ba4c98b 100644
--- a/arch/arm/mach-axxia/rapidio.c
+++ b/arch/arm/mach-axxia/rapidio.c
@@ -3,7 +3,7 @@
  *
  * Helper module for board specific RAPIDIO bus registration
  *
- * Copyright (C) 2013-2014 LSI Corporation.
+ * Copyright (C) 2013-2014 INTEL Corporation.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -27,7 +27,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/signal.h>
 
 #include <mach/rio.h>
diff --git a/arch/arm/mach-axxia/smon.c b/arch/arm/mach-axxia/smon.c
index 17a1cfb..7b8277e 100644
--- a/arch/arm/mach-axxia/smon.c
+++ b/arch/arm/mach-axxia/smon.c
@@ -3,7 +3,7 @@
  *
  * Platform perf helper module for generic VP statistical monitor
  *
- * Copyright (C) 2013 LSI Corporation.
+ * Copyright (C) 2013 INTEL Corporation.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,7 +20,7 @@
 
 #include <linux/io.h>
 
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 
 #include "smon.h"
 
diff --git a/arch/arm/mach-axxia/smon.h b/arch/arm/mach-axxia/smon.h
index 0e84275..54c3555 100644
--- a/arch/arm/mach-axxia/smon.h
+++ b/arch/arm/mach-axxia/smon.h
@@ -1,7 +1,7 @@
 /*
  * Helper module for board specific I2C bus registration
  *
- * Copyright (C) 2014 LSI Corporation.
+ * Copyright (C) 2014 INTEL Corporation.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/arch/arm/mach-axxia/ssp-gpio.c b/arch/arm/mach-axxia/ssp-gpio.c
index af75d38..c22a8e9 100644
--- a/arch/arm/mach-axxia/ssp-gpio.c
+++ b/arch/arm/mach-axxia/ssp-gpio.c
@@ -1,7 +1,7 @@
 /*
  * GPIO interface for SSP chip select pins.
  *
- * Copyright (C) 2013 LSI Corporation
+ * Copyright (C) 2013 INTEL Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -114,7 +114,7 @@ struct gpio_dev {
 }
 
 static const struct of_device_id ssp_gpio_id_table[] = {
-	{ .compatible = "lsi,ssp-gpio" },
+	{ .compatible = "axxia,ssp-gpio" },
 	{}
 };
 MODULE_DEVICE_TABLE(platform, ssp_gpio_id_table);
@@ -131,6 +131,6 @@ struct gpio_dev {
 
 module_platform_driver(ssp_gpio_driver);
 
-MODULE_AUTHOR("LSI Corporation");
+MODULE_AUTHOR("INTEL Corporation");
 MODULE_DESCRIPTION("GPIO interface for SSP chip selects");
 MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-axxia/timers.c b/arch/arm/mach-axxia/timers.c
index 85df882..ae234b9 100644
--- a/arch/arm/mach-axxia/timers.c
+++ b/arch/arm/mach-axxia/timers.c
@@ -1,7 +1,7 @@
 /*
  *  arch/arm/mach-axxia/timers.c
  *
- *  Copyright (C) 2012 LSI
+ *  Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 0ce13c5..57551bc 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -55,7 +55,7 @@ config ARCH_BRCMSTB
 config ARCH_AXXIA
 	bool "Axxia SoC family"
 	help
-	  This enables support for LSI Axxia 56xx SOC Family
+	  This enables support for INTEL Axxia 56xx SOC Family
 
 config ARCH_EXYNOS
 	bool "ARMv8 based Samsung Exynos SoC family"
diff --git a/arch/arm64/boot/dts/intel/axc6704-emu.dts b/arch/arm64/boot/dts/intel/axc6704-emu.dts
index 6083496..b6229c4 100644
--- a/arch/arm64/boot/dts/intel/axc6704-emu.dts
+++ b/arch/arm64/boot/dts/intel/axc6704-emu.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "Lionfish Emulation";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
@@ -42,8 +42,8 @@
 
 &mdio0 {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x5>;
-	lsi,mdio-clk-period = <0xc>;
+	axxia,mdio-clk-offset = <0x5>;
+	axxia,mdio-clk-period = <0xc>;
 
 	phy0: ethernet-phy@3 {
 		reg = <0x3>;
diff --git a/arch/arm64/boot/dts/intel/axc6704-sim.dts b/arch/arm64/boot/dts/intel/axc6704-sim.dts
index d7f59f1..26b9e46 100644
--- a/arch/arm64/boot/dts/intel/axc6704-sim.dts
+++ b/arch/arm64/boot/dts/intel/axc6704-sim.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "Lionfish Simulator";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm64/boot/dts/intel/axc6704-waco.dts b/arch/arm64/boot/dts/intel/axc6704-waco.dts
index 8367142..2f79f8e 100644
--- a/arch/arm64/boot/dts/intel/axc6704-waco.dts
+++ b/arch/arm64/boot/dts/intel/axc6704-waco.dts
@@ -17,7 +17,7 @@
 
 / {
 	model = "Lionfish";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
@@ -47,8 +47,8 @@
 
 &mdio0 {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x1c>;
-	lsi,mdio-clk-period = <0xf0>;
+	axxia,mdio-clk-offset = <0x1c>;
+	axxia,mdio-clk-period = <0xf0>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
@@ -58,8 +58,8 @@
 
 &mdio1 {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x1c>;
-	lsi,mdio-clk-period = <0xf0>;
+	axxia,mdio-clk-offset = <0x1c>;
+	axxia,mdio-clk-period = <0xf0>;
 	max-speed = <10>;
 };
 
diff --git a/arch/arm64/boot/dts/intel/axc6712-emu.dts b/arch/arm64/boot/dts/intel/axc6712-emu.dts
index 66d3f77..c0adab4 100644
--- a/arch/arm64/boot/dts/intel/axc6712-emu.dts
+++ b/arch/arm64/boot/dts/intel/axc6712-emu.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "Lionfish Emulation";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
@@ -46,8 +46,8 @@
 
 &mdio0 {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x5>;
-	lsi,mdio-clk-period = <0xc>;
+	axxia,mdio-clk-offset = <0x5>;
+	axxia,mdio-clk-period = <0xc>;
 
 	phy0: ethernet-phy@3 {
 		reg = <0x3>;
diff --git a/arch/arm64/boot/dts/intel/axc6716-sim.dts b/arch/arm64/boot/dts/intel/axc6716-sim.dts
index aa90a24..e952723 100644
--- a/arch/arm64/boot/dts/intel/axc6716-sim.dts
+++ b/arch/arm64/boot/dts/intel/axc6716-sim.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "Lionfish Simulator";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm64/boot/dts/intel/axc6732-sim.dts b/arch/arm64/boot/dts/intel/axc6732-sim.dts
index 9b0d2f2..64bfa91 100644
--- a/arch/arm64/boot/dts/intel/axc6732-sim.dts
+++ b/arch/arm64/boot/dts/intel/axc6732-sim.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "Lionfish Simulator";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
diff --git a/arch/arm64/boot/dts/intel/axc6732-waco.dts b/arch/arm64/boot/dts/intel/axc6732-waco.dts
index 93ef965..cb84f54 100644
--- a/arch/arm64/boot/dts/intel/axc6732-waco.dts
+++ b/arch/arm64/boot/dts/intel/axc6732-waco.dts
@@ -17,7 +17,7 @@
 
 / {
 	model = "Lionfish";
-	compatible = "lsi,axc6732";
+	compatible = "axxia,axc6732";
 
 	memory {
 		device_type = "memory";
@@ -47,8 +47,8 @@
 
 &mdio0 {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x1c>;
-	lsi,mdio-clk-period = <0xf0>;
+	axxia,mdio-clk-offset = <0x1c>;
+	axxia,mdio-clk-period = <0xf0>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
@@ -58,8 +58,8 @@
 
 &mdio1 {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x1c>;
-	lsi,mdio-clk-period = <0xf0>;
+	axxia,mdio-clk-offset = <0x1c>;
+	axxia,mdio-clk-period = <0xf0>;
 	max-speed = <10>;
 };
 
diff --git a/arch/arm64/boot/dts/intel/axc67xx.dtsi b/arch/arm64/boot/dts/intel/axc67xx.dtsi
index d4d3171..1e414c8 100644
--- a/arch/arm64/boot/dts/intel/axc67xx.dtsi
+++ b/arch/arm64/boot/dts/intel/axc67xx.dtsi
@@ -108,7 +108,7 @@
 		ranges;
 
 		syscon: syscon@8002000000 {
-			compatible = "intel,axxia-syscon", "syscon";
+			compatible = "axxia,axxia-syscon", "syscon";
 			reg = <0x80 0x02c00000 0 0x40000>;
 		};
 
@@ -148,7 +148,7 @@
 		};
 
 		mdio0: mdio@8080260000 {
-			compatible = "lsi,axm-mdio", "intel,axxia-mdio0";
+			compatible = "axxia,axm-mdio", "axxia,axxia-mdio0";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80260000 0 0x1000>;
@@ -156,7 +156,7 @@
 		};
 
 		mdio1: mdio@8080270000 {
-			compatible = "intel,axxia-mdio1";
+			compatible = "axxia,axxia-mdio1";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80270000 0 0x1000>;
@@ -204,7 +204,7 @@
 		};
 
 		usb0: usb@9000000000 {
-			compatible = "intel,axxia-dwc3";
+			compatible = "axxia,axxia-dwc3";
 			dma-coherent;
 			status = "disabled";
 			#address-cells = <2>;
@@ -218,7 +218,7 @@
 		};
 
 		usb1: usb@9800000000 {
-			compatible = "intel,axxia-dwc3";
+			compatible = "axxia,axxia-dwc3";
 			dma-coherent;
 			status = "disabled";
 			#address-cells = <2>;
@@ -232,7 +232,7 @@
 		};
 
 		gpdma0: gpdma@8005020000 {
-			compatible = "lsi,dma32";
+			compatible = "axxia,dma32";
 			reg = <0x80 0x05020000 0 0x10000>;
 			interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
@@ -246,7 +246,7 @@
 		};
 
 		gpdma1: gpdma@8005030000 {
-			compatible = "lsi,dma32";
+			compatible = "axxia,dma32";
 			reg = <0x80 0x05030000 0 0x10000>;
 			interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
@@ -261,7 +261,7 @@
 		};
 
 		i2c0: i2c@8080600000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80600000 0 0x1000>;
@@ -272,7 +272,7 @@
 		};
 
 		i2c1: i2c@8080610000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80610000 0 0x1000>;
@@ -283,7 +283,7 @@
 		};
 
 		i2c2: i2c@8080620000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80620000 0 0x1000>;
@@ -294,7 +294,7 @@
 		};
 
 		i2c3: i2c@8080630000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80630000 0 0x1000>;
@@ -305,7 +305,7 @@
 		};
 
 		i2c4: i2c@8080640000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80640000 0 0x1000>;
@@ -316,7 +316,7 @@
 		};
 
 		i2c5: i2c@8080650000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80650000 0 0x1000>;
@@ -327,7 +327,7 @@
 		};
 
 		i2c6: i2c@8080660000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80660000 0 0x1000>;
@@ -338,7 +338,7 @@
 		};
 
 		i2c7: i2c@8080670000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80670000 0 0x1000>;
@@ -349,7 +349,7 @@
 		};
 
 		i2c8: i2c@8080680000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80680000 0 0x1000>;
@@ -360,7 +360,7 @@
 		};
 
 		i2c9: i2c@8080690000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80690000 0 0x1000>;
@@ -371,7 +371,7 @@
 		};
 
 		i2c10: i2c@80806a0000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x806a0000 0 0x1000>;
@@ -382,7 +382,7 @@
 		};
 
 		i2c11: i2c@80806b0000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x806b0000 0 0x1000>;
@@ -393,7 +393,7 @@
 		};
 
 		i2c12: i2c@80806c0000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x806c0000 0 0x1000>;
@@ -404,21 +404,21 @@
 		};
 
 		mtc: mtc@8080210000 {
-			compatible = "lsi,mtc";
+			compatible = "axxia,mtc";
 			reg = <0x80 0x80210000 0 0x10000>;
 			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
 		trng: trng@8031060000 {
-			compatible = "lsi,trng";
+			compatible = "axxia,trng";
 			reg = <0x80 0x31060000 0 0x20000>;
 			interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
 		pci0: pcie@c000000000 {
-			compatible = "intel,axxia-pcie";
+			compatible = "axxia,axxia-pcie";
 			device_type = "pci";
 			reg = <0xa0 0x02000000 0 0x00100000   /* dbi */
 			       0xa0 0x03000000 0 0x00008000   /* AXI gpreg */
diff --git a/arch/arm64/boot/dts/intel/axm5604-sim.dts b/arch/arm64/boot/dts/intel/axm5604-sim.dts
index eb91e67..6fe38bf 100644
--- a/arch/arm64/boot/dts/intel/axm5604-sim.dts
+++ b/arch/arm64/boot/dts/intel/axm5604-sim.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "AXM56xx Simulator";
-	compatible = "lsi,axm5616";
+	compatible = "axxia,axm5616";
 
 	memory {
 		device_type = "memory";
@@ -69,8 +69,8 @@
 
 &mdio {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x5>;
-	lsi,mdio-clk-period = <0xc>;
+	axxia,mdio-clk-offset = <0x5>;
+	axxia,mdio-clk-period = <0xc>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
diff --git a/arch/arm64/boot/dts/intel/axm5606-emu.dts b/arch/arm64/boot/dts/intel/axm5606-emu.dts
index 04f1ae2..b5172f2 100644
--- a/arch/arm64/boot/dts/intel/axm5606-emu.dts
+++ b/arch/arm64/boot/dts/intel/axm5606-emu.dts
@@ -1,7 +1,7 @@
 /*
  * arch/arm64/boot/dts/intel/axm5606-emu.dts
  *
- * Copyright (C) 2013 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -16,7 +16,7 @@
 
 / {
 	model = "AXM56xx Emulation";
-	compatible = "lsi,axm5616";
+	compatible = "axxia,axm5616";
 
 	memory {
 		device_type = "memory";
@@ -46,8 +46,8 @@
 
 &mdio {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x5>;
-	lsi,mdio-clk-period = <0xc>;
+	axxia,mdio-clk-offset = <0x5>;
+	axxia,mdio-clk-period = <0xc>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
diff --git a/arch/arm64/boot/dts/intel/axm5608-sim.dts b/arch/arm64/boot/dts/intel/axm5608-sim.dts
index 93ce350..38bd397 100644
--- a/arch/arm64/boot/dts/intel/axm5608-sim.dts
+++ b/arch/arm64/boot/dts/intel/axm5608-sim.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "AXM56xx Simulator";
-	compatible = "lsi,axm5616";
+	compatible = "axxia,axm5616";
 
 	memory {
 		device_type = "memory";
@@ -69,8 +69,8 @@
 
 &mdio {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x5>;
-	lsi,mdio-clk-period = <0xc>;
+	axxia,mdio-clk-offset = <0x5>;
+	axxia,mdio-clk-period = <0xc>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
diff --git a/arch/arm64/boot/dts/intel/axm5616-sim.dts b/arch/arm64/boot/dts/intel/axm5616-sim.dts
index 7572830..feac11b 100644
--- a/arch/arm64/boot/dts/intel/axm5616-sim.dts
+++ b/arch/arm64/boot/dts/intel/axm5616-sim.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "AXM56xx Simulator";
-	compatible = "lsi,axm5616";
+	compatible = "axxia,axm5616";
 
 	memory {
 		device_type = "memory";
@@ -69,8 +69,8 @@
 
 &mdio {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x5>;
-	lsi,mdio-clk-period = <0xc>;
+	axxia,mdio-clk-offset = <0x5>;
+	axxia,mdio-clk-period = <0xc>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
diff --git a/arch/arm64/boot/dts/intel/axm5616-victoria.dts b/arch/arm64/boot/dts/intel/axm5616-victoria.dts
index ce815f9..d7b8ea01 100644
--- a/arch/arm64/boot/dts/intel/axm5616-victoria.dts
+++ b/arch/arm64/boot/dts/intel/axm5616-victoria.dts
@@ -16,7 +16,7 @@
 
 / {
 	model = "AXM56xx Victoria";
-	compatible = "lsi,axm5616";
+	compatible = "axxia,axm5616";
 
 	memory {
 		device_type = "memory";
@@ -58,8 +58,8 @@
 
 &mdio {
 	status = "okay";
-	lsi,mdio-clk-offset = <0x1c>;
-	lsi,mdio-clk-period = <0xf0>;
+	axxia,mdio-clk-offset = <0x1c>;
+	axxia,mdio-clk-period = <0xf0>;
 	max-speed = <10>;
 
 	phy0: ethernet-phy@3 {
diff --git a/arch/arm64/boot/dts/intel/axm56xx.dtsi b/arch/arm64/boot/dts/intel/axm56xx.dtsi
index 203aac0..6385357 100644
--- a/arch/arm64/boot/dts/intel/axm56xx.dtsi
+++ b/arch/arm64/boot/dts/intel/axm56xx.dtsi
@@ -97,7 +97,7 @@
 		ranges;
 
 		syscon: syscon@8002000000 {
-			compatible = "intel,axxia-syscon", "syscon";
+			compatible = "axxia,axxia-syscon", "syscon";
 			reg = <0x80 0x02c00000 0 0x40000>;
 		};
 		edac_cpu: edac_cpu {
@@ -152,7 +152,7 @@
 		};
 
 		mdio: mdio@8080200000 {
-			compatible = "lsi,axm-mdio", "intel,axxia-mdio0";
+			compatible = "axxia,axm-mdio", "axxia,axxia-mdio0";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80200000 0 0x1000>;
@@ -176,7 +176,7 @@
 		};
 
 		usb0: usb@9000000000 {
-			compatible = "intel,axxia-dwc3";
+			compatible = "axxia,axxia-dwc3";
 			dma-coherent;
 			status = "disabled";
 			#address-cells = <2>;
@@ -204,7 +204,7 @@
 		};
 
 		gpdma0: gpdma@8004120000 {
-			compatible = "lsi,dma32";
+			compatible = "axxia,dma32";
 			reg = <0x80 0x04120000 0 0x10000>;
 			interrupts = <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
@@ -218,7 +218,7 @@
 		};
 
 		gpdma1: gpdma@8004130000 {
-			compatible = "lsi,dma32";
+			compatible = "axxia,dma32";
 			reg = <0x80 0x04130000 0 0x10000>;
 			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
@@ -233,7 +233,7 @@
 		};
 
 		i2c0: i2c@8080080000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80080000 0 0x1000>;
@@ -244,7 +244,7 @@
 		};
 
 		i2c1: i2c@8080090000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x80090000 0 0x1000>;
@@ -255,7 +255,7 @@
 		};
 
 		i2c2: i2c@80800a0000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x800a0000 0 0x1000>;
@@ -266,7 +266,7 @@
 		};
 
 		i2c3: i2c@80800b0000 {
-			compatible = "lsi,api2c";
+			compatible = "axxia,api2c";
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0x80 0x800b0000 0 0x1000>;
@@ -277,21 +277,21 @@
 		};
 
 		mtc: mtc@8080210000 {
-			compatible = "lsi,mtc";
+			compatible = "axxia,mtc";
 			reg = <0x80 0x80210000 0 0x10000>;
 			interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
 		trng: trng@8031060000 {
-			compatible = "lsi,trng";
+			compatible = "axxia,trng";
 			reg = <0x80 0x31060000 0 0x20000>;
 			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
 		pci0: pcie@c000000000 {
-			compatible = "intel,axxia-pcie";
+			compatible = "axxia,axxia-pcie";
 			device_type = "pci";
 			reg = <0xa0 0x02000000 0 0x00100000   /* dbi */
 			       0xa0 0x03000000 0 0x00008000   /* AXI gpreg */
@@ -347,7 +347,7 @@
 		};
 
 		pci1: pcie@c800000000 {
-			compatible = "intel,axxia-pcie";
+			compatible = "axxia,axxia-pcie";
 			device_type = "pci";
 			reg = <0xa0 0x04000000 0 0x00100000   /* dbi */
 			       0xa0 0x05000000 0 0x00008000   /* AXI gpreg */
@@ -375,7 +375,7 @@
 		};
 
 		pci2: pcie@d000000000 {
-			compatible = "intel,axxia-pcie";
+			compatible = "axxia,axxia-pcie";
 			device_type = "pci";
 			reg = <0xa0 0x06000000 0 0x00100000   /* dbi */
 			       0xa0 0x07000000 0 0x00008000   /* AXI gpreg */
@@ -404,7 +404,7 @@
 
 		rio0: rapidio@0xb000000000 {
 			index = <0>;
-			compatible = "intel,axxia-rapidio";
+			compatible = "axxia,axxia-rapidio";
 			device_type = "rapidio";
 			reg = <0xa0 0x00020000 0 0x00001000>;
 			#address-cells = <2>;
@@ -420,7 +420,7 @@
 
 		rio1: rapidio@0xb800000000 {
 			index = <1>;
-			compatible = "intel,axxia-rapidio";
+			compatible = "axxia,axxia-rapidio";
 			device_type = "rapidio";
 			reg = <0xa0 0x00030000 0 0x00001000>;
 			#address-cells = <2>;
diff --git a/drivers/char/hw_random/axxia-rng.c b/drivers/char/hw_random/axxia-rng.c
index 42b1ba3..0503800 100644
--- a/drivers/char/hw_random/axxia-rng.c
+++ b/drivers/char/hw_random/axxia-rng.c
@@ -567,7 +567,7 @@ static int trng_resume(struct platform_device *pdev)
 #endif
 
 static const struct of_device_id trng_of_ids[] = {
-	{.compatible = "lsi,trng"},
+	{.compatible = "axxia,trng"},
 	{}
 };
 
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index f5e4427..7fd8585 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -89,15 +89,15 @@ config AT_XDMAC
 	help
 	  Support the Atmel XDMA controller.
 
-config LSI_DMA
-	tristate "LSI General Purpose DMA support"
+config AXXIA_DMA
+	tristate "INTEL Axxia General Purpose DMA support"
 	depends on ARCH_AXXIA
 	default y
 	select DMA_ENGINE
 	select DMA_VIRTUAL_CHANNELS
 	select ASYNC_TX_ENABLE_CHANNEL_SWITCH
 	help
-	  Enable support for the LSI General Purpose DMA controller found
+	  Enable support for the INTEL Axxia General Purpose DMA controller found
 	  on ACP34xx, AXM25xx, AXM55xx and AXM56xx devices.
 
 config AXI_DMAC
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 462f3ad..b26f48c 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -35,7 +35,7 @@ obj-$(CONFIG_IMG_MDC_DMA) += img-mdc-dma.o
 obj-$(CONFIG_IMX_DMA) += imx-dma.o
 obj-$(CONFIG_IMX_SDMA) += imx-sdma.o
 obj-$(CONFIG_INTEL_IDMA64) += idma64.o
-obj-$(CONFIG_LSI_DMA) += lsi-dma32.o
+obj-$(CONFIG_AXXIA_DMA) += axxia-dma32.o
 obj-$(CONFIG_INTEL_IOATDMA) += ioat/
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
 obj-$(CONFIG_INTEL_MIC_X100_DMA) += mic_x100_dma.o
diff --git a/drivers/dma/axxia-dma32.c b/drivers/dma/axxia-dma32.c
new file mode 100644
index 0000000..38a9728
--- /dev/null
+++ b/drivers/dma/axxia-dma32.c
@@ -0,0 +1,839 @@
+/*
+ * Driver for the INTEL Axxia DMA controller DMA-32.
+ *
+ * The driver is based on:
+ *
+ * axxia-dma32.c -
+ * axxia-dma.c - Copyright 2011 Mentor Graphics
+ * acp_gpdma.c - Copyright (c) 2011, Ericsson AB
+ *               Niclas Bengtsson <niklas.x.bengtsson@ericsson.com>
+ *               Kerstin Jonsson <kerstin.jonsson@ericsson.com>
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/export.h>
+#include <linux/stat.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <asm/page.h>
+#include <linux/bitops.h>
+#include <linux/atomic.h>
+#include <linux/sizes.h>
+#include "virt-dma.h"
+#include "axxia-dma32.h"
+
+#ifdef DEBUG
+#define engine_dbg(engine, fmt, ...) \
+	do { \
+		struct gpdma_engine *_e = engine; \
+		(void)_e; \
+		pr_debug("dma0: " fmt, ##__VA_ARGS__); \
+	} while (0)
+
+#define ch_dbg(dmac, fmt, ...) \
+	do { \
+		struct gpdma_channel *_c = dmac; \
+		(void)_c; \
+		pr_debug("dma0ch%d: [%s] " fmt, \
+			dmac->id, __func__, ##__VA_ARGS__); \
+	} while (0)
+#else
+#define engine_dbg(engine, fmt, ...) do {} while (0)
+#define ch_dbg(dmac, fmt, ...)       do {} while (0)
+#endif
+
+static unsigned int burst = 5;
+module_param(burst, uint, 0644);
+MODULE_PARM_DESC(burst,
+		 "Preferred burst setting (0=SINGLE,3=INCR4,5=INCR8,7=INCR16)");
+
+static void reset_channel(struct gpdma_channel *dmac)
+{
+	const int WAIT = 1024;
+	int i;
+
+	/* Pause channel */
+	writel(DMA_STATUS_CH_PAUS_WR_EN | DMA_STATUS_CH_PAUSE,
+	     dmac->base+DMA_STATUS);
+	/* Memory Barrier */
+	wmb();
+
+	/* Disable channel */
+	writel(0, dmac->base+DMA_CHANNEL_CONFIG);
+	for (i = 0; readl(dmac->base+DMA_CHANNEL_CONFIG) && i < WAIT; i++)
+		cpu_relax();
+	if (i == WAIT)
+		ch_dbg(dmac, "Failed to DISABLE channel\n");
+
+	/* Clear FIFO */
+	writel(DMA_CONFIG_CLEAR_FIFO, dmac->base+DMA_CHANNEL_CONFIG);
+	for (i = 0; readl(dmac->base+DMA_CHANNEL_CONFIG) && i < WAIT; i++)
+		cpu_relax();
+	if (i == WAIT)
+		ch_dbg(dmac, "Failed to clear FIFO\n");
+}
+
+static void soft_reset(struct gpdma_engine *engine)
+{
+	int i;
+	u32 cfg;
+
+	/* Reset all channels */
+	for (i = 0; i < engine->chip->num_channels; i++)
+		reset_channel(&engine->channel[i]);
+
+	/* Reset GPDMA by writing Magic Number to reset reg */
+	writel(GPDMA_MAGIC, engine->gbase + SOFT_RESET);
+	/* Memory Barrier */
+	wmb();
+
+	cfg = (engine->pool.phys & 0xfff00000) | GEN_CONFIG_EXT_MEM;
+
+	if (engine->chip->flags & AXXIADMA_EDGE_INT) {
+		for (i = 0; i < engine->chip->num_channels; i++)
+			cfg |= GEN_CONFIG_INT_EDGE(i);
+		engine_dbg(engine, "Using edge-triggered interrupts\n");
+	}
+	writel(cfg, engine->gbase + GEN_CONFIG);
+	engine_dbg(engine, "engine->desc.phys & 0xfff00000 == %llx\n",
+		   (engine->pool.phys & 0xfff00000));
+
+	engine->ch_busy = 0;
+}
+
+static int alloc_desc_table(struct gpdma_engine *engine)
+{
+	/*
+	 * For controllers that doesn't support full descriptor addresses, all
+	 * descriptors must be in the same 1 MB page, i.e address bits 31..20
+	 * must be the same for all descriptors.
+	 */
+	u32 order = 20 - PAGE_SHIFT;
+	int i;
+
+	if (engine->chip->flags & AXXIADMA_NEXT_FULL) {
+		/*
+		 * Controller can do full descriptor addresses, then we need no
+		 * special alignment on the descriptor block.
+		 */
+		order = get_order(GPDMA_MAX_DESCRIPTORS *
+				  sizeof(struct gpdma_desc));
+	}
+
+	engine->pool.va = (struct gpdma_desc *)
+			  __get_free_pages(GFP_KERNEL|GFP_DMA, order);
+	if (!engine->pool.va)
+		return -ENOMEM;
+	engine->pool.order = order;
+	engine->pool.phys = virt_to_phys(engine->pool.va);
+	engine_dbg(engine, "order=%d pa=%#llx va=%p\n",
+		   engine->pool.order, engine->pool.phys, engine->pool.va);
+
+	INIT_LIST_HEAD(&engine->free_list);
+	for (i = 0; i < GPDMA_MAX_DESCRIPTORS; i++) {
+		struct gpdma_desc *desc = &engine->pool.va[i];
+
+		async_tx_ack(&desc->vdesc.tx);
+		desc->engine = engine;
+		list_add_tail(&desc->vdesc.node, &engine->free_list);
+	}
+
+	return 0;
+}
+
+static void free_desc_table(struct gpdma_engine *engine)
+{
+	if (engine->pool.va)
+		free_pages((unsigned long)engine->pool.va, engine->pool.order);
+}
+
+static struct gpdma_desc *get_descriptor(struct gpdma_engine *engine)
+{
+	unsigned long flags;
+	struct gpdma_desc *new = NULL, *desc, *tmp;
+
+	spin_lock_irqsave(&engine->lock, flags);
+	list_for_each_entry_safe(desc, tmp, &engine->free_list, vdesc.node) {
+		if (async_tx_test_ack(&desc->vdesc.tx)) {
+			list_del(&desc->vdesc.node);
+			new = desc;
+			new->chain = NULL;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&engine->lock, flags);
+
+	return new;
+}
+
+/**
+ * init_descriptor - Fill out all descriptor fields
+ */
+static void init_descriptor(struct gpdma_desc *desc,
+			    dma_addr_t src, u32 src_acc,
+			    dma_addr_t dst, u32 dst_acc,
+			    size_t len)
+{
+	u32 src_count = len >> src_acc;
+	u32 dst_count = len >> dst_acc;
+	u32 rot_len = (2 * (1 << src_acc)) - 1;
+
+	BUG_ON(src_count * (1<<src_acc) != len);
+	BUG_ON(dst_count * (1<<dst_acc) != len);
+
+	desc->src = src;
+	desc->dst = dst;
+
+	desc->hw.src_x_ctr     = cpu_to_le16(src_count - 1);
+	desc->hw.src_y_ctr     = 0;
+	desc->hw.src_x_mod     = cpu_to_le32(1 << src_acc);
+	desc->hw.src_y_mod     = 0;
+	desc->hw.src_addr      = cpu_to_le32(src & 0xffffffff);
+	desc->hw.src_data_mask = ~0;
+	desc->hw.src_access    = cpu_to_le16((rot_len << 6) |
+					    (src_acc << 3) |
+					    (burst & 7));
+	desc->hw.dst_access    = cpu_to_le16((dst_acc << 3) |
+					    (burst & 7));
+	desc->hw.ch_config     = cpu_to_le32(DMA_CONFIG_ONE_SHOT(1));
+	desc->hw.next_ptr      = 0;
+	desc->hw.dst_x_ctr     = cpu_to_le16(dst_count - 1);
+	desc->hw.dst_y_ctr     = 0;
+	desc->hw.dst_x_mod     = cpu_to_le32(1 << dst_acc);
+	desc->hw.dst_y_mod     = 0;
+	desc->hw.dst_addr      = cpu_to_le32(dst & 0xffffffff);
+}
+
+static phys_addr_t desc_to_paddr(const struct gpdma_channel *dmac,
+				 const struct gpdma_desc *desc)
+{
+	phys_addr_t paddr = virt_to_phys(&desc->hw);
+
+	WARN_ON(paddr & 0xf);
+	if (dmac->engine->chip->flags & AXXIADMA_NEXT_FULL)
+		paddr |= 0x8;
+	else
+		paddr &= 0xfffff;
+
+	return paddr;
+}
+
+static void free_descriptor(struct virt_dma_desc *vd)
+{
+	struct gpdma_desc *desc = to_gpdma_desc(vd);
+	struct gpdma_engine *engine = desc->engine;
+	unsigned long flags;
+
+	BUG_ON(desc == NULL);
+
+	spin_lock_irqsave(&engine->lock, flags);
+	while (desc) {
+		list_add_tail(&desc->vdesc.node, &engine->free_list);
+		desc = desc->chain;
+	}
+	spin_unlock_irqrestore(&engine->lock, flags);
+}
+
+static int segment_match(struct gpdma_engine *engine, struct gpdma_desc *desc)
+{
+	unsigned int gpreg_dma = readl(engine->gpreg);
+	unsigned int seg_src = (gpreg_dma >> 0) & 0x3f;
+	unsigned int seg_dst = (gpreg_dma >> 8) & 0x3f;
+
+	return (seg_src == ((desc->src >> 32) & 0x3f) &&
+		seg_dst == ((desc->dst >> 32) & 0x3f));
+}
+
+static void gpdma_start(struct gpdma_channel *dmac)
+{
+	struct virt_dma_desc *vdesc;
+	struct gpdma_desc    *desc;
+	phys_addr_t           paddr;
+
+	vdesc = vchan_next_desc(&dmac->vc);
+	if (!vdesc) {
+		clear_bit(dmac->id, &dmac->engine->ch_busy);
+		dmac->active = NULL;
+		return;
+	}
+
+	/* Remove from list and mark as active */
+	list_del(&vdesc->node);
+	desc = to_gpdma_desc(vdesc);
+	dmac->active = desc;
+
+	if (!(dmac->engine->chip->flags & AXXIADMA_SEG_REGS)) {
+		/*
+		 * No segment registers -> descriptor address bits must match
+		 * running descriptor on any other channel.
+		 */
+		if (dmac->engine->ch_busy && !segment_match(dmac->engine, desc))
+			return;
+	}
+
+	/* Physical address of descriptor to load */
+	paddr = desc_to_paddr(dmac, desc);
+	writel((u32)paddr, dmac->base + DMA_NXT_DESCR);
+
+	if (dmac->engine->chip->flags & AXXIADMA_SEG_REGS) {
+		/* Segment bits [39..32] of descriptor, src and dst addresses */
+		writel(paddr >> 32, dmac->base + DMA_DESCR_ADDR_SEG);
+		writel(desc->src >> 32, dmac->base + DMA_SRC_ADDR_SEG);
+		writel(desc->dst >> 32, dmac->base + DMA_DST_ADDR_SEG);
+	} else {
+		unsigned int seg_src = (desc->src >> 32) & 0x3f;
+		unsigned int seg_dst = (desc->dst >> 32) & 0x3f;
+
+		writel((seg_dst << 8) | seg_src, dmac->engine->gpreg);
+	}
+	/* Memory barrier */
+	wmb();
+	writel(DMA_CONFIG_DSC_LOAD, dmac->base + DMA_CHANNEL_CONFIG);
+	set_bit(dmac->id, &dmac->engine->ch_busy);
+}
+
+static irqreturn_t gpdma_isr_err(int irqno, void *_engine)
+{
+	struct gpdma_engine *engine = _engine;
+	u32 status = readl(engine->gbase + GEN_STAT);
+	u32 ch = (status & GEN_STAT_CH0_ERROR) ? 0 : 1;
+	struct gpdma_channel *dmac = &engine->channel[ch];
+
+	if (0 == (status & (GEN_STAT_CH0_ERROR | GEN_STAT_CH1_ERROR)))
+		return IRQ_NONE;
+
+	/* Read the channel status bits and dump the error */
+	status = readl(dmac->base + DMA_STATUS);
+	pr_err("dma: channel%d error %08x\n", dmac->id, status);
+	/* Clear the error indication */
+	writel(DMA_STATUS_ERROR, dmac->base+DMA_STATUS);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpdma_isr(int irqno, void *_dmac)
+{
+	struct gpdma_channel *dmac = _dmac;
+	struct gpdma_desc    *desc = dmac->active;
+	u32                  status;
+	u32	             error;
+
+	status = readl(dmac->base+DMA_STATUS);
+	error = status & DMA_STATUS_ERROR;
+	writel(DMA_STATUS_CLEAR, dmac->base+DMA_STATUS);
+
+	ch_dbg(dmac, "irq%u channel status %08x, error %08x\n",
+		irqno, status, error);
+
+	WARN_ON((status & DMA_STATUS_CH_ACTIVE) != 0);
+
+	if (error) {
+		if (error & DMA_STATUS_UNALIGNED_ERR) {
+			dev_warn(dmac->engine->dev,
+				 "Unaligned transaction on ch%d (status=%#x)\n",
+				 dmac->id, status);
+			reset_channel(dmac);
+		} else {
+			dev_warn(dmac->engine->dev,
+				 "DMA transaction error on ch%d (status=%#x)\n",
+				 dmac->id, status);
+		}
+	}
+
+	BUG_ON(desc == NULL);
+
+	spin_lock(&dmac->vc.lock);
+	vchan_cookie_complete(&desc->vdesc);
+	dmac->active = NULL;
+	if (vchan_next_desc(&dmac->vc)) {
+		gpdma_start(dmac);
+	} else {
+		/* Stop channel */
+		writel(0, dmac->base + DMA_CHANNEL_CONFIG);
+		writel(DMA_CONFIG_CLEAR_FIFO, dmac->base + DMA_CHANNEL_CONFIG);
+		clear_bit(dmac->id, &dmac->engine->ch_busy);
+	}
+	spin_unlock(&dmac->vc.lock);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Perform soft reset procedure on DMA Engine.  Needed occasionally to work
+ * around nasty bug ACP3400 sRIO HW.
+ */
+static ssize_t __ref
+reset_engine(struct device *dev,
+	     struct device_attribute *attr,
+	     const char *buf, size_t count)
+{
+	struct gpdma_engine *engine = dev_get_drvdata(dev);
+	int i;
+
+	if (!engine)
+		return -EINVAL;
+
+	/* Disable interrupts and tasklet and acquire each channel lock */
+	for (i = 0; i < engine->chip->num_channels; i++) {
+		struct gpdma_channel *dmac = &engine->channel[i];
+
+		disable_irq(dmac->irq);
+		spin_lock(&dmac->vc.lock);
+		tasklet_disable(&dmac->vc.task);
+	}
+
+	soft_reset(engine);
+
+	for (i = 0; i < engine->chip->num_channels; i++) {
+		struct gpdma_channel *dmac = &engine->channel[i];
+
+		tasklet_enable(&dmac->vc.task);
+		enable_irq(dmac->irq);
+		/* Restart any active jobs */
+		if (dmac->active) {
+			struct gpdma_desc *active = dmac->active;
+
+			dmac->active = NULL;
+			list_add(&active->vdesc.node, &dmac->vc.desc_submitted);
+			if (vchan_issue_pending(&dmac->vc))
+				gpdma_start(dmac);
+		}
+		spin_unlock(&dmac->vc.lock);
+	}
+
+	return count;
+}
+static DEVICE_ATTR(soft_reset, S_IWUSR, NULL, reset_engine);
+
+/*
+ *===========================================================================
+ *
+ *                       DMA DEVICE INTERFACE
+ *
+ *===========================================================================
+ *
+ */
+
+/**
+ * gpdma_alloc_chan_resources - Allocate resources and return the number of
+ * allocated descriptors.
+ *
+ */
+static int gpdma_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct gpdma_channel *dmac = to_gpdma_chan(chan);
+
+	(void) dmac;
+	return 1;
+}
+
+/**
+ * gpdma_free_chan_resources - Release DMA channel's resources.
+ *
+ */
+static void gpdma_free_chan_resources(struct dma_chan *chan)
+{
+	struct gpdma_channel *dmac = to_gpdma_chan(chan);
+
+	(void) dmac;
+}
+
+/**
+ * gpdma_prep_sg - Prepares a transfer using sg lists.
+ *
+ */
+static struct dma_async_tx_descriptor *
+gpdma_prep_sg(struct dma_chan *chan,
+	      struct scatterlist *dst_sg, unsigned int dst_nents,
+	      struct scatterlist *src_sg, unsigned int src_nents,
+	      unsigned long flags)
+{
+	struct gpdma_channel *dmac = to_gpdma_chan(chan);
+	struct gpdma_desc *first = NULL, *prev = NULL, *new;
+	size_t dst_avail, src_avail;
+	dma_addr_t dst, src;
+	u32 src_acc, dst_acc;
+	size_t len;
+
+	if (dst_nents == 0 || src_nents == 0)
+		return NULL;
+
+	if (dst_sg == NULL || src_sg == NULL)
+		return NULL;
+
+	dst_avail = sg_dma_len(dst_sg);
+	src_avail = sg_dma_len(src_sg);
+
+	/* Loop until we run out of entries... */
+	for (;;) {
+		/* Descriptor count is limited to 64K */
+		len = min_t(size_t, src_avail, dst_avail);
+		len = min_t(size_t, len, (size_t)SZ_64K);
+
+		if (len > 0) {
+			dst = sg_dma_address(dst_sg) +
+				sg_dma_len(dst_sg) - dst_avail;
+			src = sg_dma_address(src_sg) +
+				sg_dma_len(src_sg) - src_avail;
+
+			src_acc = min(ffs((u32)src | len) - 1, 4);
+			dst_acc = min(ffs((u32)dst | len) - 1, 4);
+
+			new = get_descriptor(dmac->engine);
+			if (!new) {
+				ch_dbg(dmac, "ERROR: No descriptor\n");
+				goto fail;
+			}
+
+			init_descriptor(new, src, src_acc, dst, dst_acc, len);
+
+			/* Link descriptors together */
+			if (!first) {
+				first = new;
+			} else {
+				prev->hw.next_ptr = desc_to_paddr(dmac, new);
+				prev->chain = new;
+			}
+			prev = new;
+
+			/* update metadata */
+			dst_avail -= len;
+			src_avail -= len;
+		}
+
+		/* dst: Advance to next sg-entry */
+		if (dst_avail == 0) {
+			/* no more entries: we're done */
+			if (dst_nents == 0)
+				break;
+			/* fetch the next entry: if there are no more: done */
+			dst_sg = sg_next(dst_sg);
+			if (dst_sg == NULL)
+				break;
+
+			dst_nents--;
+			dst_avail = sg_dma_len(dst_sg);
+		}
+
+		/* src: Advance to next sg-entry */
+		if (src_avail == 0) {
+			/* no more entries: we're done */
+			if (src_nents == 0)
+				break;
+			/* fetch the next entry: if there are no more: done */
+			src_sg = sg_next(src_sg);
+			if (src_sg == NULL)
+				break;
+
+			src_nents--;
+			src_avail = sg_dma_len(src_sg);
+		}
+	}
+
+	/* Interrupt on last descriptor in chain */
+	prev->hw.ch_config |= cpu_to_le32(DMA_CONFIG_END);
+
+	return vchan_tx_prep(&dmac->vc, &first->vdesc, flags);
+
+fail:
+	if (first)
+		free_descriptor(&first->vdesc);
+	return NULL;
+}
+
+/**
+ * gpdma_prep_memcpy - Prepares a memcpy operation.
+ *
+ */
+static struct dma_async_tx_descriptor *
+gpdma_prep_memcpy(struct dma_chan *chan,
+		  dma_addr_t dst,
+		  dma_addr_t src,
+		  size_t size,
+		  unsigned long dma_flags)
+{
+	struct gpdma_channel *dmac = to_gpdma_chan(chan);
+	struct gpdma_desc *first = NULL, *prev = NULL, *new;
+	u32 src_acc, dst_acc;
+	size_t len;
+
+	if (size == 0)
+		return NULL;
+
+	do {
+		new = get_descriptor(dmac->engine);
+		if (new == NULL) {
+			ch_dbg(dmac, "ERROR: No descriptor\n");
+			goto fail;
+		}
+
+		len = min_t(size_t, size, (size_t)SZ_64K);
+
+		/* Maximize access width based on address and length alignmet */
+		src_acc = min(ffs((u32)src | len) - 1, 4);
+		dst_acc = min(ffs((u32)dst | len) - 1, 4);
+
+		init_descriptor(new, src, src_acc, dst, dst_acc, len);
+
+		if (!first) {
+			first = new;
+		} else {
+			prev->hw.next_ptr = desc_to_paddr(dmac, new);
+			prev->chain = new;
+		}
+		prev = new;
+
+		size -= len;
+		src  += len;
+		dst  += len;
+
+	} while (size > 0);
+
+	prev->hw.ch_config |= cpu_to_le32(DMA_CONFIG_END);
+
+	return vchan_tx_prep(&dmac->vc, &first->vdesc, DMA_CTRL_ACK);
+
+fail:
+	if (first)
+		free_descriptor(&first->vdesc);
+	return NULL;
+}
+
+/**
+ * gpdma_issue_pending - Push pending transactions to hardware.
+ *
+ */
+static void gpdma_issue_pending(struct dma_chan *chan)
+{
+	struct gpdma_channel *dmac = to_gpdma_chan(chan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmac->vc.lock, flags);
+	if (vchan_issue_pending(&dmac->vc) && !dmac->active)
+		gpdma_start(dmac);
+	spin_unlock_irqrestore(&dmac->vc.lock, flags);
+}
+
+/**
+ * gpdma_tx_status - Poll for transaction completion, the optional txstate
+ * parameter can be supplied with a pointer to get a struct with auxiliary
+ * transfer status information, otherwise the call will just return a simple
+ * status code.
+ */
+static enum dma_status gpdma_tx_status(struct dma_chan *chan,
+				       dma_cookie_t cookie,
+				       struct dma_tx_state *txstate)
+{
+	return dma_cookie_status(chan, cookie, txstate);
+}
+
+static int setup_channel(struct gpdma_channel *dmac, struct device_node *child)
+{
+	struct gpdma_engine *engine = dmac->engine;
+	int rc;
+
+	dmac->base = engine->iobase + dmac->id * engine->chip->chregs_offset;
+	dev_dbg(engine->dev, "channel%d base @ %p\n", dmac->id, dmac->base);
+
+	/* Find the IRQ line, if it exists in the device tree */
+	dmac->irq = irq_of_parse_and_map(child, 0);
+	dev_dbg(engine->dev, "channel %d, irq %d\n", dmac->id, dmac->irq);
+	rc = devm_request_irq(engine->dev, dmac->irq, gpdma_isr, 0,
+			      "axxia-dma", dmac);
+	if (rc) {
+		dev_err(engine->dev, "failed to request_irq, error = %d\n", rc);
+		return rc;
+	}
+	/* Initialize the virt-channel */
+	dmac->vc.desc_free = free_descriptor;
+	vchan_init(&dmac->vc, &engine->dma_device);
+
+	return 0;
+}
+
+static struct axxiadma_hw axxia_dma32 = {
+	.num_channels   = 2,
+	.chregs_offset  = 0x80,
+	.genregs_offset = 0xF00,
+	.flags          = (AXXIADMA_NEXT_FULL |
+			   AXXIADMA_SEG_REGS)
+};
+
+static struct axxiadma_hw axxia_dma31 = {
+	.num_channels   = 4,
+	.chregs_offset  = 0x40,
+	.genregs_offset = 0x400,
+	.flags          = 0
+};
+
+static const struct of_device_id gpdma_of_ids[] = {
+	{
+		.compatible = "axxia,dma32",
+		.data       = &axxia_dma32
+	},
+	{
+		.compatible = "axxia,dma31",
+		.data       = &axxia_dma31
+	},
+	{
+		.compatible = "gp-dma,acp-dma",
+		.data       = &axxia_dma31
+	},
+	{
+		.compatible = "gp-dma,acp-gpdma",
+		.data       = &axxia_dma31
+	},
+	{ }
+};
+
+static int gpdma_of_probe(struct platform_device *op)
+{
+	struct gpdma_engine *engine;
+	struct dma_device   *dma;
+	struct device_node *child;
+	struct resource *res;
+	const struct of_device_id *match;
+	int rc = -ENOMEM;
+	int id = 0;
+
+	match = of_match_device(gpdma_of_ids, &op->dev);
+	if (!match)
+		return -EINVAL;
+
+	engine = devm_kzalloc(&op->dev, sizeof(*engine), GFP_KERNEL);
+	if (!engine)
+		return -ENOMEM;
+
+	spin_lock_init(&engine->lock);
+	engine->dev = &op->dev;
+	engine->chip = (struct axxiadma_hw *)match->data;
+
+	/* Initialize dma_device struct */
+	dma = &engine->dma_device;
+	dma->dev = &op->dev;
+	dma_cap_zero(dma->cap_mask);
+	dma_cap_set(DMA_MEMCPY, dma->cap_mask);
+	dma_cap_set(DMA_SG, dma->cap_mask);
+	dma->copy_align = 2;
+	dma->chancnt = engine->chip->num_channels;
+	dma->device_alloc_chan_resources = gpdma_alloc_chan_resources;
+	dma->device_free_chan_resources = gpdma_free_chan_resources;
+	dma->device_tx_status = gpdma_tx_status;
+	dma->device_prep_dma_memcpy = gpdma_prep_memcpy;
+	dma->device_prep_dma_sg = gpdma_prep_sg;
+	dma->device_issue_pending = gpdma_issue_pending;
+	INIT_LIST_HEAD(&dma->channels);
+
+	/* Map device I/O memory
+	 */
+	res = platform_get_resource(op, IORESOURCE_MEM, 0);
+	engine->iobase = devm_ioremap_resource(&op->dev, res);
+	if (IS_ERR(engine->iobase))
+		return PTR_ERR(engine->iobase);
+	dev_dbg(&op->dev, "mapped base @ %p\n", engine->iobase);
+
+	res = platform_get_resource(op, IORESOURCE_MEM, 1);
+	if (res) {
+		engine->gpreg = devm_ioremap_nocache(&op->dev,
+						     res->start,
+						     resource_size(res));
+		if (IS_ERR(engine->gpreg))
+			return PTR_ERR(engine->gpreg);
+		dev_dbg(&op->dev, "mapped gpreg @ %p\n", engine->gpreg);
+	}
+
+	engine->err_irq = platform_get_irq(op, 1);
+	if (engine->err_irq) {
+		rc = devm_request_irq(&op->dev, engine->err_irq,
+				      gpdma_isr_err, 0, "axxia-dma-err", engine);
+		if (rc) {
+			dev_err(engine->dev, "failed to request irq%d\n",
+				engine->err_irq);
+			engine->err_irq = 0;
+		}
+	}
+
+	/* General registers at device specific offset */
+	engine->gbase = engine->iobase + engine->chip->genregs_offset;
+
+	rc = alloc_desc_table(engine);
+	if (rc)
+		return rc;
+
+	/* Setup channels */
+	for_each_child_of_node(op->dev.of_node, child) {
+		struct gpdma_channel *dmac = &engine->channel[id];
+
+		if (id >= engine->chip->num_channels) {
+			dev_dbg(engine->dev, "Too many channels (%d)\n", id);
+			return -ENODEV;
+		}
+
+		dmac->id = id;
+		dmac->engine = engine;
+		rc = setup_channel(dmac, child);
+		if (rc)
+			return rc;
+		++id;
+	}
+
+	soft_reset(engine);
+
+	rc = dma_async_device_register(&engine->dma_device);
+	if (rc) {
+		dev_err(engine->dev, "unable to register\n");
+		return rc;
+	}
+
+	device_create_file(&op->dev, &dev_attr_soft_reset);
+	dev_set_drvdata(&op->dev, engine);
+
+	return 0;
+}
+
+static int gpdma_of_remove(struct platform_device *op)
+{
+	struct gpdma_engine *engine = dev_get_drvdata(&op->dev);
+
+	dev_dbg(&op->dev, "%s\n", __func__);
+
+	device_remove_file(&op->dev, &dev_attr_soft_reset);
+	dma_async_device_unregister(&engine->dma_device);
+	free_desc_table(engine);
+	dev_set_drvdata(&op->dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver gpdma_of_driver = {
+	.driver = {
+		.name           = "axxia-dma32",
+		.owner          = THIS_MODULE,
+		.of_match_table = gpdma_of_ids,
+	},
+	.probe  = gpdma_of_probe,
+	.remove = gpdma_of_remove,
+};
+
+module_platform_driver(gpdma_of_driver);
+
+MODULE_DESCRIPTION("INTEL Axxia DMA driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/axxia-dma32.h b/drivers/dma/axxia-dma32.h
new file mode 100644
index 0000000..a3a2e12
--- /dev/null
+++ b/drivers/dma/axxia-dma32.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2012 Ericsson AB. All rights reserved.
+ *
+ * Author:
+ *   Kerstin Jonsson <kerstin.jonsson@ericsson.com>, Feb 2012
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __AXXIA_DMA32_H
+#define __AXXIA_DMA32_H
+
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include "virt-dma.h"
+
+#define MAX_GPDMA_CHANNELS      4
+#define GPDMA_MAX_DESCRIPTORS  128
+#define GPDMA_MAGIC            0xABCD1234UL
+
+#define DMA_X_SRC_COUNT				0x00
+#define DMA_Y_SRC_COUNT				0x04
+#define DMA_X_MODIF_SRC				0x08
+#define DMA_Y_MODIF_SRC				0x0c
+#define DMA_SRC_CUR_ADDR			0x10
+#define DMA_SRC_ACCESS				0x14
+#define    DMA_SRC_ACCESS_BURST_TYPE		(1<<15)
+#define    DMA_SRC_ACCESS_TAIL_LENGTH(x)	(((x) & 0xF) << 11)
+#define    DMA_SRC_ACCESS_ROTATOR_LENGTH(x)	(((x) & 1F) << 6)
+#define    DMA_SRC_ACCESS_SRC_SIZE(x)		(((x) & 7) << 3)
+#define    DMA_SRC_ACCESS_SRC_BURST(x)		(((x) & 7) << 0)
+#define DMA_SRC_MASK				0x18
+#define DMA_X_DST_COUNT				0x1c
+#define DMA_Y_DST_COUNT				0x20
+#define DMA_X_MODIF_DST				0x24
+#define DMA_Y_MODIF_DST				0x28
+#define DMA_DST_CUR_ADDR			0x2C
+#define DMA_DST_ACCESS				0x30
+#define    DMA_DST_ACCESS_DST_SIZE(x)		(((x) & 7) << 3)
+#define    DMA_DST_ACCESS_DST_BURST(x)		(((x) & 7) << 0)
+#define DMA_NXT_DESCR				0x34
+#define DMA_CHANNEL_CONFIG			0x38
+#define    DMA_CONFIG_DST_SPACE(x)		(((x) & 7) << 26)
+#define    DMA_CONFIG_SRC_SPACE(x)		(((x) & 7) << 23)
+#define    DMA_CONFIG_PRIORITY_ROW		(1<<21)
+#define    DMA_CONFIG_PRIORITY			(1<<20)
+#define    DMA_CONFIG_LAST_BLOCK		(1<<15)
+#define    DMA_CONFIG_CLEAR_FIFO		(1<<14)
+#define    DMA_CONFIG_START_MEM_LOAD		(1<<13)
+#define    DMA_CONFIG_STOP_DST_EOB		(1<<11)
+#define    DMA_CONFIG_FULL_DESCR_ADDR		(1<<8)
+#define    DMA_CONFIG_INT_DST_EOT		(1<<7)
+#define    DMA_CONFIG_INT_DST_EOB		(1<<6)
+#define    DMA_CONFIG_WAIT_FOR_TASK_CNT2	(1<<5)
+#define    DMA_CONFIG_TASK_CNT2_RESET		(1<<4)
+#define    DMA_CONFIG_WAIT_FOR_TASK_CNT1	(1<<3)
+#define    DMA_CONFIG_TASK_CNT1_RESET		(1<<2)
+#define    DMA_CONFIG_TX_EN			(1<<1)
+#define    DMA_CONFIG_CHAN_EN			(1<<0)
+#define DMA_STATUS				0x3C
+#define    DMA_STATUS_WAIT_TASK_CNT2		(1<<20)
+#define    DMA_STATUS_TASK_CNT2_OVERFLOW	(1<<19)
+#define    DMA_STATUS_WAIT_TASK_CNT1		(1<<18)
+#define    DMA_STATUS_TASK_CNT1_OVERFLOW	(1<<17)
+#define    DMA_STATUS_CH_PAUS_WR_EN		(1<<16)
+#define    DMA_STATUS_ERR_ACC_DESCR		(1<<14)
+#define    DMA_STATUS_ERR_ACC_DST		(1<<13)
+#define    DMA_STATUS_ERR_ACC_SRC		(1<<12)
+#define    DMA_STATUS_ERR_OVERFLOW		(1<<9)
+#define    DMA_STATUS_ERR_UNDERFLOW		(1<<8)
+#define    DMA_STATUS_CH_PAUSE			(1<<7)
+#define    DMA_STATUS_CH_WAITING		(1<<5)
+#define    DMA_STATUS_CH_ACTIVE			(1<<4)
+#define    DMA_STATUS_TR_COMPLETE		(1<<3)
+#define    DMA_STATUS_BLK_COMPLETE		(1<<2)
+#define    DMA_STATUS_UNALIGNED_READ		(1<<1)
+#define    DMA_STATUS_UNALIGNED_WRITE		(1<<0)
+#define    DMA_STATUS_UNALIGNED_ERR		(DMA_STATUS_UNALIGNED_READ | \
+						 DMA_STATUS_UNALIGNED_WRITE)
+#define DMA_TASK_CNT_1				0x40
+#define DMA_TASK_CNT_2				0x44
+#define DMA_MODE_CONFIG				0x48
+#define DMA_CURR_DESCR				0x4c
+#define DMA_PREV_DESCR				0x50
+#define DMA_SRC_ADDR_SEG			0x54
+#define DMA_DST_ADDR_SEG			0x58
+#define DMA_DESCR_ADDR_SEG			0x5c
+
+#define DMA_STATUS_ERROR		(DMA_STATUS_ERR_ACC_DESCR | \
+					 DMA_STATUS_ERR_ACC_DST   | \
+					 DMA_STATUS_ERR_ACC_SRC   | \
+					 DMA_STATUS_ERR_OVERFLOW  | \
+					 DMA_STATUS_ERR_UNDERFLOW | \
+					 DMA_STATUS_UNALIGNED_ERR)
+
+#define DMA_STATUS_CLEAR		(DMA_STATUS_CH_PAUS_WR_EN | \
+					 DMA_STATUS_TR_COMPLETE   | \
+					 DMA_STATUS_BLK_COMPLETE)
+
+#define DMA_CONFIG_END			(DMA_CONFIG_LAST_BLOCK | \
+					 DMA_CONFIG_INT_DST_EOT)
+
+#define DMA_CONFIG_ONE_SHOT(__ext)	(DMA_CONFIG_DST_SPACE((__ext)) | \
+					 DMA_CONFIG_SRC_SPACE((__ext)) | \
+					 DMA_CONFIG_TX_EN              | \
+					 DMA_CONFIG_CHAN_EN)
+
+#define DMA_CONFIG_DSC_LOAD		(DMA_CONFIG_START_MEM_LOAD  | \
+					 DMA_CONFIG_FULL_DESCR_ADDR | \
+					 DMA_CONFIG_CHAN_EN)
+
+#define GEN_STAT       0x0
+#define   GEN_STAT_CH0_ACTIVE (1<<0)
+#define   GEN_STAT_CH1_ACTIVE (1<<2)
+#define   GEN_STAT_CH1_ACTIVE (1<<2)
+#define   GEN_STAT_CH0_ERROR  (1<<16)
+#define   GEN_STAT_CH1_ERROR  (1<<17)
+#define GEN_CONFIG     0x4
+#define  GEN_CONFIG_EXT_MEM                     (1<<19)
+#define  GEN_CONFIG_INT_EDGE(_ch)               (1<<(_ch))
+#define SOFT_RESET     0x8
+
+#define GPDMA_GEN_STAT(__p) ((__p)->gbase + GEN_STAT)
+#define GPDMA_GEN_CONFIG(__p) ((__p)->gbase + GEN_CONFIG)
+#define GPDMA_SOFT_RESET(__p) ((__p)->gbase + SOFT_RESET)
+
+
+struct descriptor {
+	u16 src_x_ctr;
+	u16 src_y_ctr;
+	s32 src_x_mod;
+	s32 src_y_mod;
+	u32 src_addr;
+	u32 src_data_mask;
+	u16 src_access;
+	u16 dst_access;
+	u32 ch_config;
+	u32 next_ptr;
+	u16 dst_x_ctr;
+	u16 dst_y_ctr;
+	s32 dst_x_mod;
+	s32 dst_y_mod;
+	u32 dst_addr;
+} __aligned(32);
+
+struct gpdma_engine;
+
+struct gpdma_desc {
+	struct descriptor               hw;
+	struct gpdma_desc              *chain;
+	dma_addr_t                      src;
+	dma_addr_t                      dst;
+	struct gpdma_engine            *engine;
+	struct virt_dma_desc	        vdesc;
+} __aligned(32);
+
+static struct gpdma_desc *to_gpdma_desc(struct virt_dma_desc *vdesc)
+{
+	return container_of(vdesc, struct gpdma_desc, vdesc);
+}
+
+struct gpdma_channel {
+	/* Back reference to DMA engine */
+	struct gpdma_engine		*engine;
+	/* Channel registers */
+	void __iomem			*base;
+	/* Channel id */
+	int			        id;
+	/* IRQ number as passed to request_irq() */
+	int				irq;
+	/* Currently running descriptor */
+	struct gpdma_desc               *active;
+	/* Channel parameters (DMA engine framework) */
+	struct virt_dma_chan		vc;
+};
+
+static inline struct gpdma_channel *to_gpdma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct gpdma_channel, vc.chan);
+}
+
+struct axxiadma_hw {
+	unsigned int num_channels;
+	unsigned int chregs_offset;
+	unsigned int genregs_offset;
+	unsigned int flags;
+#define AXXIADMA_NEXT_FULL     (1<<0)
+#define AXXIADMA_SEG_REGS      (1<<1)
+#define AXXIADMA_EDGE_INT      (1<<2)
+};
+
+struct gpdma_engine {
+	struct device			*dev;
+	struct axxiadma_hw		*chip;
+	struct gpdma_channel		channel[MAX_GPDMA_CHANNELS];
+	/** Bit mask where bit[n] == 1 if channel busy */
+	unsigned long                   ch_busy;
+	int                             err_irq;
+	void __iomem			*iobase;
+	void __iomem			*gbase;
+	void __iomem			*gpreg;
+	spinlock_t			lock;
+	struct list_head                free_list;
+	struct {
+		u32                     order;
+		dma_addr_t              phys;
+		struct gpdma_desc       *va;
+	} pool;
+	struct dma_device		dma_device;
+};
+
+#define desc_to_engine(n) container_of(n, struct gpdma_engine, desc)
+
+#endif
diff --git a/drivers/dma/lsi-dma32.c b/drivers/dma/lsi-dma32.c
deleted file mode 100644
index 4e3e749..0000000
--- a/drivers/dma/lsi-dma32.c
+++ /dev/null
@@ -1,839 +0,0 @@
-/*
- * Driver for the LSI DMA controller DMA-32.
- *
- * The driver is based on:
- *
- * lsi-dma32.c -
- * lsi-dma.c - Copyright 2011 Mentor Graphics
- * acp_gpdma.c - Copyright (c) 2011, Ericsson AB
- *               Niclas Bengtsson <niklas.x.bengtsson@ericsson.com>
- *               Kerstin Jonsson <kerstin.jonsson@ericsson.com>
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#include <linux/export.h>
-#include <linux/stat.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <linux/of.h>
-#include <linux/delay.h>
-#include <asm/page.h>
-#include <linux/bitops.h>
-#include <linux/atomic.h>
-#include <linux/sizes.h>
-#include "virt-dma.h"
-#include "lsi-dma32.h"
-
-#ifdef DEBUG
-#define engine_dbg(engine, fmt, ...) \
-	do { \
-		struct gpdma_engine *_e = engine; \
-		(void)_e; \
-		pr_debug("dma0: " fmt, ##__VA_ARGS__); \
-	} while (0)
-
-#define ch_dbg(dmac, fmt, ...) \
-	do { \
-		struct gpdma_channel *_c = dmac; \
-		(void)_c; \
-		pr_debug("dma0ch%d: [%s] " fmt, \
-			dmac->id, __func__, ##__VA_ARGS__); \
-	} while (0)
-#else
-#define engine_dbg(engine, fmt, ...) do {} while (0)
-#define ch_dbg(dmac, fmt, ...)       do {} while (0)
-#endif
-
-static unsigned int burst = 5;
-module_param(burst, uint, 0644);
-MODULE_PARM_DESC(burst,
-		 "Preferred burst setting (0=SINGLE,3=INCR4,5=INCR8,7=INCR16)");
-
-static void reset_channel(struct gpdma_channel *dmac)
-{
-	const int WAIT = 1024;
-	int i;
-
-	/* Pause channel */
-	writel(DMA_STATUS_CH_PAUS_WR_EN | DMA_STATUS_CH_PAUSE,
-	     dmac->base+DMA_STATUS);
-	/* Memory Barrier */
-	wmb();
-
-	/* Disable channel */
-	writel(0, dmac->base+DMA_CHANNEL_CONFIG);
-	for (i = 0; readl(dmac->base+DMA_CHANNEL_CONFIG) && i < WAIT; i++)
-		cpu_relax();
-	if (i == WAIT)
-		ch_dbg(dmac, "Failed to DISABLE channel\n");
-
-	/* Clear FIFO */
-	writel(DMA_CONFIG_CLEAR_FIFO, dmac->base+DMA_CHANNEL_CONFIG);
-	for (i = 0; readl(dmac->base+DMA_CHANNEL_CONFIG) && i < WAIT; i++)
-		cpu_relax();
-	if (i == WAIT)
-		ch_dbg(dmac, "Failed to clear FIFO\n");
-}
-
-static void soft_reset(struct gpdma_engine *engine)
-{
-	int i;
-	u32 cfg;
-
-	/* Reset all channels */
-	for (i = 0; i < engine->chip->num_channels; i++)
-		reset_channel(&engine->channel[i]);
-
-	/* Reset GPDMA by writing Magic Number to reset reg */
-	writel(GPDMA_MAGIC, engine->gbase + SOFT_RESET);
-	/* Memory Barrier */
-	wmb();
-
-	cfg = (engine->pool.phys & 0xfff00000) | GEN_CONFIG_EXT_MEM;
-
-	if (engine->chip->flags & LSIDMA_EDGE_INT) {
-		for (i = 0; i < engine->chip->num_channels; i++)
-			cfg |= GEN_CONFIG_INT_EDGE(i);
-		engine_dbg(engine, "Using edge-triggered interrupts\n");
-	}
-	writel(cfg, engine->gbase + GEN_CONFIG);
-	engine_dbg(engine, "engine->desc.phys & 0xfff00000 == %llx\n",
-		   (engine->pool.phys & 0xfff00000));
-
-	engine->ch_busy = 0;
-}
-
-static int alloc_desc_table(struct gpdma_engine *engine)
-{
-	/*
-	 * For controllers that doesn't support full descriptor addresses, all
-	 * descriptors must be in the same 1 MB page, i.e address bits 31..20
-	 * must be the same for all descriptors.
-	 */
-	u32 order = 20 - PAGE_SHIFT;
-	int i;
-
-	if (engine->chip->flags & LSIDMA_NEXT_FULL) {
-		/*
-		 * Controller can do full descriptor addresses, then we need no
-		 * special alignment on the descriptor block.
-		 */
-		order = get_order(GPDMA_MAX_DESCRIPTORS *
-				  sizeof(struct gpdma_desc));
-	}
-
-	engine->pool.va = (struct gpdma_desc *)
-			  __get_free_pages(GFP_KERNEL|GFP_DMA, order);
-	if (!engine->pool.va)
-		return -ENOMEM;
-	engine->pool.order = order;
-	engine->pool.phys = virt_to_phys(engine->pool.va);
-	engine_dbg(engine, "order=%d pa=%#llx va=%p\n",
-		   engine->pool.order, engine->pool.phys, engine->pool.va);
-
-	INIT_LIST_HEAD(&engine->free_list);
-	for (i = 0; i < GPDMA_MAX_DESCRIPTORS; i++) {
-		struct gpdma_desc *desc = &engine->pool.va[i];
-
-		async_tx_ack(&desc->vdesc.tx);
-		desc->engine = engine;
-		list_add_tail(&desc->vdesc.node, &engine->free_list);
-	}
-
-	return 0;
-}
-
-static void free_desc_table(struct gpdma_engine *engine)
-{
-	if (engine->pool.va)
-		free_pages((unsigned long)engine->pool.va, engine->pool.order);
-}
-
-static struct gpdma_desc *get_descriptor(struct gpdma_engine *engine)
-{
-	unsigned long flags;
-	struct gpdma_desc *new = NULL, *desc, *tmp;
-
-	spin_lock_irqsave(&engine->lock, flags);
-	list_for_each_entry_safe(desc, tmp, &engine->free_list, vdesc.node) {
-		if (async_tx_test_ack(&desc->vdesc.tx)) {
-			list_del(&desc->vdesc.node);
-			new = desc;
-			new->chain = NULL;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&engine->lock, flags);
-
-	return new;
-}
-
-/**
- * init_descriptor - Fill out all descriptor fields
- */
-static void init_descriptor(struct gpdma_desc *desc,
-			    dma_addr_t src, u32 src_acc,
-			    dma_addr_t dst, u32 dst_acc,
-			    size_t len)
-{
-	u32 src_count = len >> src_acc;
-	u32 dst_count = len >> dst_acc;
-	u32 rot_len = (2 * (1 << src_acc)) - 1;
-
-	BUG_ON(src_count * (1<<src_acc) != len);
-	BUG_ON(dst_count * (1<<dst_acc) != len);
-
-	desc->src = src;
-	desc->dst = dst;
-
-	desc->hw.src_x_ctr     = cpu_to_le16(src_count - 1);
-	desc->hw.src_y_ctr     = 0;
-	desc->hw.src_x_mod     = cpu_to_le32(1 << src_acc);
-	desc->hw.src_y_mod     = 0;
-	desc->hw.src_addr      = cpu_to_le32(src & 0xffffffff);
-	desc->hw.src_data_mask = ~0;
-	desc->hw.src_access    = cpu_to_le16((rot_len << 6) |
-					    (src_acc << 3) |
-					    (burst & 7));
-	desc->hw.dst_access    = cpu_to_le16((dst_acc << 3) |
-					    (burst & 7));
-	desc->hw.ch_config     = cpu_to_le32(DMA_CONFIG_ONE_SHOT(1));
-	desc->hw.next_ptr      = 0;
-	desc->hw.dst_x_ctr     = cpu_to_le16(dst_count - 1);
-	desc->hw.dst_y_ctr     = 0;
-	desc->hw.dst_x_mod     = cpu_to_le32(1 << dst_acc);
-	desc->hw.dst_y_mod     = 0;
-	desc->hw.dst_addr      = cpu_to_le32(dst & 0xffffffff);
-}
-
-static phys_addr_t desc_to_paddr(const struct gpdma_channel *dmac,
-				 const struct gpdma_desc *desc)
-{
-	phys_addr_t paddr = virt_to_phys(&desc->hw);
-
-	WARN_ON(paddr & 0xf);
-	if (dmac->engine->chip->flags & LSIDMA_NEXT_FULL)
-		paddr |= 0x8;
-	else
-		paddr &= 0xfffff;
-
-	return paddr;
-}
-
-static void free_descriptor(struct virt_dma_desc *vd)
-{
-	struct gpdma_desc *desc = to_gpdma_desc(vd);
-	struct gpdma_engine *engine = desc->engine;
-	unsigned long flags;
-
-	BUG_ON(desc == NULL);
-
-	spin_lock_irqsave(&engine->lock, flags);
-	while (desc) {
-		list_add_tail(&desc->vdesc.node, &engine->free_list);
-		desc = desc->chain;
-	}
-	spin_unlock_irqrestore(&engine->lock, flags);
-}
-
-static int segment_match(struct gpdma_engine *engine, struct gpdma_desc *desc)
-{
-	unsigned int gpreg_dma = readl(engine->gpreg);
-	unsigned int seg_src = (gpreg_dma >> 0) & 0x3f;
-	unsigned int seg_dst = (gpreg_dma >> 8) & 0x3f;
-
-	return (seg_src == ((desc->src >> 32) & 0x3f) &&
-		seg_dst == ((desc->dst >> 32) & 0x3f));
-}
-
-static void gpdma_start(struct gpdma_channel *dmac)
-{
-	struct virt_dma_desc *vdesc;
-	struct gpdma_desc    *desc;
-	phys_addr_t           paddr;
-
-	vdesc = vchan_next_desc(&dmac->vc);
-	if (!vdesc) {
-		clear_bit(dmac->id, &dmac->engine->ch_busy);
-		dmac->active = NULL;
-		return;
-	}
-
-	/* Remove from list and mark as active */
-	list_del(&vdesc->node);
-	desc = to_gpdma_desc(vdesc);
-	dmac->active = desc;
-
-	if (!(dmac->engine->chip->flags & LSIDMA_SEG_REGS)) {
-		/*
-		 * No segment registers -> descriptor address bits must match
-		 * running descriptor on any other channel.
-		 */
-		if (dmac->engine->ch_busy && !segment_match(dmac->engine, desc))
-			return;
-	}
-
-	/* Physical address of descriptor to load */
-	paddr = desc_to_paddr(dmac, desc);
-	writel((u32)paddr, dmac->base + DMA_NXT_DESCR);
-
-	if (dmac->engine->chip->flags & LSIDMA_SEG_REGS) {
-		/* Segment bits [39..32] of descriptor, src and dst addresses */
-		writel(paddr >> 32, dmac->base + DMA_DESCR_ADDR_SEG);
-		writel(desc->src >> 32, dmac->base + DMA_SRC_ADDR_SEG);
-		writel(desc->dst >> 32, dmac->base + DMA_DST_ADDR_SEG);
-	} else {
-		unsigned int seg_src = (desc->src >> 32) & 0x3f;
-		unsigned int seg_dst = (desc->dst >> 32) & 0x3f;
-
-		writel((seg_dst << 8) | seg_src, dmac->engine->gpreg);
-	}
-	/* Memory barrier */
-	wmb();
-	writel(DMA_CONFIG_DSC_LOAD, dmac->base + DMA_CHANNEL_CONFIG);
-	set_bit(dmac->id, &dmac->engine->ch_busy);
-}
-
-static irqreturn_t gpdma_isr_err(int irqno, void *_engine)
-{
-	struct gpdma_engine *engine = _engine;
-	u32 status = readl(engine->gbase + GEN_STAT);
-	u32 ch = (status & GEN_STAT_CH0_ERROR) ? 0 : 1;
-	struct gpdma_channel *dmac = &engine->channel[ch];
-
-	if (0 == (status & (GEN_STAT_CH0_ERROR | GEN_STAT_CH1_ERROR)))
-		return IRQ_NONE;
-
-	/* Read the channel status bits and dump the error */
-	status = readl(dmac->base + DMA_STATUS);
-	pr_err("dma: channel%d error %08x\n", dmac->id, status);
-	/* Clear the error indication */
-	writel(DMA_STATUS_ERROR, dmac->base+DMA_STATUS);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t gpdma_isr(int irqno, void *_dmac)
-{
-	struct gpdma_channel *dmac = _dmac;
-	struct gpdma_desc    *desc = dmac->active;
-	u32                  status;
-	u32	             error;
-
-	status = readl(dmac->base+DMA_STATUS);
-	error = status & DMA_STATUS_ERROR;
-	writel(DMA_STATUS_CLEAR, dmac->base+DMA_STATUS);
-
-	ch_dbg(dmac, "irq%u channel status %08x, error %08x\n",
-		irqno, status, error);
-
-	WARN_ON((status & DMA_STATUS_CH_ACTIVE) != 0);
-
-	if (error) {
-		if (error & DMA_STATUS_UNALIGNED_ERR) {
-			dev_warn(dmac->engine->dev,
-				 "Unaligned transaction on ch%d (status=%#x)\n",
-				 dmac->id, status);
-			reset_channel(dmac);
-		} else {
-			dev_warn(dmac->engine->dev,
-				 "DMA transaction error on ch%d (status=%#x)\n",
-				 dmac->id, status);
-		}
-	}
-
-	BUG_ON(desc == NULL);
-
-	spin_lock(&dmac->vc.lock);
-	vchan_cookie_complete(&desc->vdesc);
-	dmac->active = NULL;
-	if (vchan_next_desc(&dmac->vc)) {
-		gpdma_start(dmac);
-	} else {
-		/* Stop channel */
-		writel(0, dmac->base + DMA_CHANNEL_CONFIG);
-		writel(DMA_CONFIG_CLEAR_FIFO, dmac->base + DMA_CHANNEL_CONFIG);
-		clear_bit(dmac->id, &dmac->engine->ch_busy);
-	}
-	spin_unlock(&dmac->vc.lock);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Perform soft reset procedure on DMA Engine.  Needed occasionally to work
- * around nasty bug ACP3400 sRIO HW.
- */
-static ssize_t __ref
-reset_engine(struct device *dev,
-	     struct device_attribute *attr,
-	     const char *buf, size_t count)
-{
-	struct gpdma_engine *engine = dev_get_drvdata(dev);
-	int i;
-
-	if (!engine)
-		return -EINVAL;
-
-	/* Disable interrupts and tasklet and acquire each channel lock */
-	for (i = 0; i < engine->chip->num_channels; i++) {
-		struct gpdma_channel *dmac = &engine->channel[i];
-
-		disable_irq(dmac->irq);
-		spin_lock(&dmac->vc.lock);
-		tasklet_disable(&dmac->vc.task);
-	}
-
-	soft_reset(engine);
-
-	for (i = 0; i < engine->chip->num_channels; i++) {
-		struct gpdma_channel *dmac = &engine->channel[i];
-
-		tasklet_enable(&dmac->vc.task);
-		enable_irq(dmac->irq);
-		/* Restart any active jobs */
-		if (dmac->active) {
-			struct gpdma_desc *active = dmac->active;
-
-			dmac->active = NULL;
-			list_add(&active->vdesc.node, &dmac->vc.desc_submitted);
-			if (vchan_issue_pending(&dmac->vc))
-				gpdma_start(dmac);
-		}
-		spin_unlock(&dmac->vc.lock);
-	}
-
-	return count;
-}
-static DEVICE_ATTR(soft_reset, S_IWUSR, NULL, reset_engine);
-
-/*
- *===========================================================================
- *
- *                       DMA DEVICE INTERFACE
- *
- *===========================================================================
- *
- */
-
-/**
- * gpdma_alloc_chan_resources - Allocate resources and return the number of
- * allocated descriptors.
- *
- */
-static int gpdma_alloc_chan_resources(struct dma_chan *chan)
-{
-	struct gpdma_channel *dmac = to_gpdma_chan(chan);
-
-	(void) dmac;
-	return 1;
-}
-
-/**
- * gpdma_free_chan_resources - Release DMA channel's resources.
- *
- */
-static void gpdma_free_chan_resources(struct dma_chan *chan)
-{
-	struct gpdma_channel *dmac = to_gpdma_chan(chan);
-
-	(void) dmac;
-}
-
-/**
- * gpdma_prep_sg - Prepares a transfer using sg lists.
- *
- */
-static struct dma_async_tx_descriptor *
-gpdma_prep_sg(struct dma_chan *chan,
-	      struct scatterlist *dst_sg, unsigned int dst_nents,
-	      struct scatterlist *src_sg, unsigned int src_nents,
-	      unsigned long flags)
-{
-	struct gpdma_channel *dmac = to_gpdma_chan(chan);
-	struct gpdma_desc *first = NULL, *prev = NULL, *new;
-	size_t dst_avail, src_avail;
-	dma_addr_t dst, src;
-	u32 src_acc, dst_acc;
-	size_t len;
-
-	if (dst_nents == 0 || src_nents == 0)
-		return NULL;
-
-	if (dst_sg == NULL || src_sg == NULL)
-		return NULL;
-
-	dst_avail = sg_dma_len(dst_sg);
-	src_avail = sg_dma_len(src_sg);
-
-	/* Loop until we run out of entries... */
-	for (;;) {
-		/* Descriptor count is limited to 64K */
-		len = min_t(size_t, src_avail, dst_avail);
-		len = min_t(size_t, len, (size_t)SZ_64K);
-
-		if (len > 0) {
-			dst = sg_dma_address(dst_sg) +
-				sg_dma_len(dst_sg) - dst_avail;
-			src = sg_dma_address(src_sg) +
-				sg_dma_len(src_sg) - src_avail;
-
-			src_acc = min(ffs((u32)src | len) - 1, 4);
-			dst_acc = min(ffs((u32)dst | len) - 1, 4);
-
-			new = get_descriptor(dmac->engine);
-			if (!new) {
-				ch_dbg(dmac, "ERROR: No descriptor\n");
-				goto fail;
-			}
-
-			init_descriptor(new, src, src_acc, dst, dst_acc, len);
-
-			/* Link descriptors together */
-			if (!first) {
-				first = new;
-			} else {
-				prev->hw.next_ptr = desc_to_paddr(dmac, new);
-				prev->chain = new;
-			}
-			prev = new;
-
-			/* update metadata */
-			dst_avail -= len;
-			src_avail -= len;
-		}
-
-		/* dst: Advance to next sg-entry */
-		if (dst_avail == 0) {
-			/* no more entries: we're done */
-			if (dst_nents == 0)
-				break;
-			/* fetch the next entry: if there are no more: done */
-			dst_sg = sg_next(dst_sg);
-			if (dst_sg == NULL)
-				break;
-
-			dst_nents--;
-			dst_avail = sg_dma_len(dst_sg);
-		}
-
-		/* src: Advance to next sg-entry */
-		if (src_avail == 0) {
-			/* no more entries: we're done */
-			if (src_nents == 0)
-				break;
-			/* fetch the next entry: if there are no more: done */
-			src_sg = sg_next(src_sg);
-			if (src_sg == NULL)
-				break;
-
-			src_nents--;
-			src_avail = sg_dma_len(src_sg);
-		}
-	}
-
-	/* Interrupt on last descriptor in chain */
-	prev->hw.ch_config |= cpu_to_le32(DMA_CONFIG_END);
-
-	return vchan_tx_prep(&dmac->vc, &first->vdesc, flags);
-
-fail:
-	if (first)
-		free_descriptor(&first->vdesc);
-	return NULL;
-}
-
-/**
- * gpdma_prep_memcpy - Prepares a memcpy operation.
- *
- */
-static struct dma_async_tx_descriptor *
-gpdma_prep_memcpy(struct dma_chan *chan,
-		  dma_addr_t dst,
-		  dma_addr_t src,
-		  size_t size,
-		  unsigned long dma_flags)
-{
-	struct gpdma_channel *dmac = to_gpdma_chan(chan);
-	struct gpdma_desc *first = NULL, *prev = NULL, *new;
-	u32 src_acc, dst_acc;
-	size_t len;
-
-	if (size == 0)
-		return NULL;
-
-	do {
-		new = get_descriptor(dmac->engine);
-		if (new == NULL) {
-			ch_dbg(dmac, "ERROR: No descriptor\n");
-			goto fail;
-		}
-
-		len = min_t(size_t, size, (size_t)SZ_64K);
-
-		/* Maximize access width based on address and length alignmet */
-		src_acc = min(ffs((u32)src | len) - 1, 4);
-		dst_acc = min(ffs((u32)dst | len) - 1, 4);
-
-		init_descriptor(new, src, src_acc, dst, dst_acc, len);
-
-		if (!first) {
-			first = new;
-		} else {
-			prev->hw.next_ptr = desc_to_paddr(dmac, new);
-			prev->chain = new;
-		}
-		prev = new;
-
-		size -= len;
-		src  += len;
-		dst  += len;
-
-	} while (size > 0);
-
-	prev->hw.ch_config |= cpu_to_le32(DMA_CONFIG_END);
-
-	return vchan_tx_prep(&dmac->vc, &first->vdesc, DMA_CTRL_ACK);
-
-fail:
-	if (first)
-		free_descriptor(&first->vdesc);
-	return NULL;
-}
-
-/**
- * gpdma_issue_pending - Push pending transactions to hardware.
- *
- */
-static void gpdma_issue_pending(struct dma_chan *chan)
-{
-	struct gpdma_channel *dmac = to_gpdma_chan(chan);
-	unsigned long flags;
-
-	spin_lock_irqsave(&dmac->vc.lock, flags);
-	if (vchan_issue_pending(&dmac->vc) && !dmac->active)
-		gpdma_start(dmac);
-	spin_unlock_irqrestore(&dmac->vc.lock, flags);
-}
-
-/**
- * gpdma_tx_status - Poll for transaction completion, the optional txstate
- * parameter can be supplied with a pointer to get a struct with auxiliary
- * transfer status information, otherwise the call will just return a simple
- * status code.
- */
-static enum dma_status gpdma_tx_status(struct dma_chan *chan,
-				       dma_cookie_t cookie,
-				       struct dma_tx_state *txstate)
-{
-	return dma_cookie_status(chan, cookie, txstate);
-}
-
-static int setup_channel(struct gpdma_channel *dmac, struct device_node *child)
-{
-	struct gpdma_engine *engine = dmac->engine;
-	int rc;
-
-	dmac->base = engine->iobase + dmac->id * engine->chip->chregs_offset;
-	dev_dbg(engine->dev, "channel%d base @ %p\n", dmac->id, dmac->base);
-
-	/* Find the IRQ line, if it exists in the device tree */
-	dmac->irq = irq_of_parse_and_map(child, 0);
-	dev_dbg(engine->dev, "channel %d, irq %d\n", dmac->id, dmac->irq);
-	rc = devm_request_irq(engine->dev, dmac->irq, gpdma_isr, 0,
-			      "lsi-dma", dmac);
-	if (rc) {
-		dev_err(engine->dev, "failed to request_irq, error = %d\n", rc);
-		return rc;
-	}
-	/* Initialize the virt-channel */
-	dmac->vc.desc_free = free_descriptor;
-	vchan_init(&dmac->vc, &engine->dma_device);
-
-	return 0;
-}
-
-static struct lsidma_hw lsi_dma32 = {
-	.num_channels   = 2,
-	.chregs_offset  = 0x80,
-	.genregs_offset = 0xF00,
-	.flags          = (LSIDMA_NEXT_FULL |
-			   LSIDMA_SEG_REGS)
-};
-
-static struct lsidma_hw lsi_dma31 = {
-	.num_channels   = 4,
-	.chregs_offset  = 0x40,
-	.genregs_offset = 0x400,
-	.flags          = 0
-};
-
-static const struct of_device_id gpdma_of_ids[] = {
-	{
-		.compatible = "lsi,dma32",
-		.data       = &lsi_dma32
-	},
-	{
-		.compatible = "lsi,dma31",
-		.data       = &lsi_dma31
-	},
-	{
-		.compatible = "gp-dma,acp-dma",
-		.data       = &lsi_dma31
-	},
-	{
-		.compatible = "gp-dma,acp-gpdma",
-		.data       = &lsi_dma31
-	},
-	{ }
-};
-
-static int gpdma_of_probe(struct platform_device *op)
-{
-	struct gpdma_engine *engine;
-	struct dma_device   *dma;
-	struct device_node *child;
-	struct resource *res;
-	const struct of_device_id *match;
-	int rc = -ENOMEM;
-	int id = 0;
-
-	match = of_match_device(gpdma_of_ids, &op->dev);
-	if (!match)
-		return -EINVAL;
-
-	engine = devm_kzalloc(&op->dev, sizeof(*engine), GFP_KERNEL);
-	if (!engine)
-		return -ENOMEM;
-
-	spin_lock_init(&engine->lock);
-	engine->dev = &op->dev;
-	engine->chip = (struct lsidma_hw *)match->data;
-
-	/* Initialize dma_device struct */
-	dma = &engine->dma_device;
-	dma->dev = &op->dev;
-	dma_cap_zero(dma->cap_mask);
-	dma_cap_set(DMA_MEMCPY, dma->cap_mask);
-	dma_cap_set(DMA_SG, dma->cap_mask);
-	dma->copy_align = 2;
-	dma->chancnt = engine->chip->num_channels;
-	dma->device_alloc_chan_resources = gpdma_alloc_chan_resources;
-	dma->device_free_chan_resources = gpdma_free_chan_resources;
-	dma->device_tx_status = gpdma_tx_status;
-	dma->device_prep_dma_memcpy = gpdma_prep_memcpy;
-	dma->device_prep_dma_sg = gpdma_prep_sg;
-	dma->device_issue_pending = gpdma_issue_pending;
-	INIT_LIST_HEAD(&dma->channels);
-
-	/* Map device I/O memory
-	 */
-	res = platform_get_resource(op, IORESOURCE_MEM, 0);
-	engine->iobase = devm_ioremap_resource(&op->dev, res);
-	if (IS_ERR(engine->iobase))
-		return PTR_ERR(engine->iobase);
-	dev_dbg(&op->dev, "mapped base @ %p\n", engine->iobase);
-
-	res = platform_get_resource(op, IORESOURCE_MEM, 1);
-	if (res) {
-		engine->gpreg = devm_ioremap_nocache(&op->dev,
-						     res->start,
-						     resource_size(res));
-		if (IS_ERR(engine->gpreg))
-			return PTR_ERR(engine->gpreg);
-		dev_dbg(&op->dev, "mapped gpreg @ %p\n", engine->gpreg);
-	}
-
-	engine->err_irq = platform_get_irq(op, 1);
-	if (engine->err_irq) {
-		rc = devm_request_irq(&op->dev, engine->err_irq,
-				      gpdma_isr_err, 0, "lsi-dma-err", engine);
-		if (rc) {
-			dev_err(engine->dev, "failed to request irq%d\n",
-				engine->err_irq);
-			engine->err_irq = 0;
-		}
-	}
-
-	/* General registers at device specific offset */
-	engine->gbase = engine->iobase + engine->chip->genregs_offset;
-
-	rc = alloc_desc_table(engine);
-	if (rc)
-		return rc;
-
-	/* Setup channels */
-	for_each_child_of_node(op->dev.of_node, child) {
-		struct gpdma_channel *dmac = &engine->channel[id];
-
-		if (id >= engine->chip->num_channels) {
-			dev_dbg(engine->dev, "Too many channels (%d)\n", id);
-			return -ENODEV;
-		}
-
-		dmac->id = id;
-		dmac->engine = engine;
-		rc = setup_channel(dmac, child);
-		if (rc)
-			return rc;
-		++id;
-	}
-
-	soft_reset(engine);
-
-	rc = dma_async_device_register(&engine->dma_device);
-	if (rc) {
-		dev_err(engine->dev, "unable to register\n");
-		return rc;
-	}
-
-	device_create_file(&op->dev, &dev_attr_soft_reset);
-	dev_set_drvdata(&op->dev, engine);
-
-	return 0;
-}
-
-static int gpdma_of_remove(struct platform_device *op)
-{
-	struct gpdma_engine *engine = dev_get_drvdata(&op->dev);
-
-	dev_dbg(&op->dev, "%s\n", __func__);
-
-	device_remove_file(&op->dev, &dev_attr_soft_reset);
-	dma_async_device_unregister(&engine->dma_device);
-	free_desc_table(engine);
-	dev_set_drvdata(&op->dev, NULL);
-
-	return 0;
-}
-
-static struct platform_driver gpdma_of_driver = {
-	.driver = {
-		.name           = "lsi-dma32",
-		.owner          = THIS_MODULE,
-		.of_match_table = gpdma_of_ids,
-	},
-	.probe  = gpdma_of_probe,
-	.remove = gpdma_of_remove,
-};
-
-module_platform_driver(gpdma_of_driver);
-
-MODULE_DESCRIPTION("LSI DMA driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/dma/lsi-dma32.h b/drivers/dma/lsi-dma32.h
deleted file mode 100644
index c5a2701..0000000
--- a/drivers/dma/lsi-dma32.h
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2012 Ericsson AB. All rights reserved.
- *
- * Author:
- *   Kerstin Jonsson <kerstin.jonsson@ericsson.com>, Feb 2012
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-#ifndef __LSI_DMA32_H
-#define __LSI_DMA32_H
-
-#include <linux/dmaengine.h>
-#include <linux/dma-mapping.h>
-#include <linux/dma-mapping.h>
-#include <linux/device.h>
-#include <linux/spinlock.h>
-#include <linux/types.h>
-#include "virt-dma.h"
-
-#define MAX_GPDMA_CHANNELS      4
-#define GPDMA_MAX_DESCRIPTORS  128
-#define GPDMA_MAGIC            0xABCD1234UL
-
-#define DMA_X_SRC_COUNT				0x00
-#define DMA_Y_SRC_COUNT				0x04
-#define DMA_X_MODIF_SRC				0x08
-#define DMA_Y_MODIF_SRC				0x0c
-#define DMA_SRC_CUR_ADDR			0x10
-#define DMA_SRC_ACCESS				0x14
-#define    DMA_SRC_ACCESS_BURST_TYPE		(1<<15)
-#define    DMA_SRC_ACCESS_TAIL_LENGTH(x)	(((x) & 0xF) << 11)
-#define    DMA_SRC_ACCESS_ROTATOR_LENGTH(x)	(((x) & 1F) << 6)
-#define    DMA_SRC_ACCESS_SRC_SIZE(x)		(((x) & 7) << 3)
-#define    DMA_SRC_ACCESS_SRC_BURST(x)		(((x) & 7) << 0)
-#define DMA_SRC_MASK				0x18
-#define DMA_X_DST_COUNT				0x1c
-#define DMA_Y_DST_COUNT				0x20
-#define DMA_X_MODIF_DST				0x24
-#define DMA_Y_MODIF_DST				0x28
-#define DMA_DST_CUR_ADDR			0x2C
-#define DMA_DST_ACCESS				0x30
-#define    DMA_DST_ACCESS_DST_SIZE(x)		(((x) & 7) << 3)
-#define    DMA_DST_ACCESS_DST_BURST(x)		(((x) & 7) << 0)
-#define DMA_NXT_DESCR				0x34
-#define DMA_CHANNEL_CONFIG			0x38
-#define    DMA_CONFIG_DST_SPACE(x)		(((x) & 7) << 26)
-#define    DMA_CONFIG_SRC_SPACE(x)		(((x) & 7) << 23)
-#define    DMA_CONFIG_PRIORITY_ROW		(1<<21)
-#define    DMA_CONFIG_PRIORITY			(1<<20)
-#define    DMA_CONFIG_LAST_BLOCK		(1<<15)
-#define    DMA_CONFIG_CLEAR_FIFO		(1<<14)
-#define    DMA_CONFIG_START_MEM_LOAD		(1<<13)
-#define    DMA_CONFIG_STOP_DST_EOB		(1<<11)
-#define    DMA_CONFIG_FULL_DESCR_ADDR		(1<<8)
-#define    DMA_CONFIG_INT_DST_EOT		(1<<7)
-#define    DMA_CONFIG_INT_DST_EOB		(1<<6)
-#define    DMA_CONFIG_WAIT_FOR_TASK_CNT2	(1<<5)
-#define    DMA_CONFIG_TASK_CNT2_RESET		(1<<4)
-#define    DMA_CONFIG_WAIT_FOR_TASK_CNT1	(1<<3)
-#define    DMA_CONFIG_TASK_CNT1_RESET		(1<<2)
-#define    DMA_CONFIG_TX_EN			(1<<1)
-#define    DMA_CONFIG_CHAN_EN			(1<<0)
-#define DMA_STATUS				0x3C
-#define    DMA_STATUS_WAIT_TASK_CNT2		(1<<20)
-#define    DMA_STATUS_TASK_CNT2_OVERFLOW	(1<<19)
-#define    DMA_STATUS_WAIT_TASK_CNT1		(1<<18)
-#define    DMA_STATUS_TASK_CNT1_OVERFLOW	(1<<17)
-#define    DMA_STATUS_CH_PAUS_WR_EN		(1<<16)
-#define    DMA_STATUS_ERR_ACC_DESCR		(1<<14)
-#define    DMA_STATUS_ERR_ACC_DST		(1<<13)
-#define    DMA_STATUS_ERR_ACC_SRC		(1<<12)
-#define    DMA_STATUS_ERR_OVERFLOW		(1<<9)
-#define    DMA_STATUS_ERR_UNDERFLOW		(1<<8)
-#define    DMA_STATUS_CH_PAUSE			(1<<7)
-#define    DMA_STATUS_CH_WAITING		(1<<5)
-#define    DMA_STATUS_CH_ACTIVE			(1<<4)
-#define    DMA_STATUS_TR_COMPLETE		(1<<3)
-#define    DMA_STATUS_BLK_COMPLETE		(1<<2)
-#define    DMA_STATUS_UNALIGNED_READ		(1<<1)
-#define    DMA_STATUS_UNALIGNED_WRITE		(1<<0)
-#define    DMA_STATUS_UNALIGNED_ERR		(DMA_STATUS_UNALIGNED_READ | \
-						 DMA_STATUS_UNALIGNED_WRITE)
-#define DMA_TASK_CNT_1				0x40
-#define DMA_TASK_CNT_2				0x44
-#define DMA_MODE_CONFIG				0x48
-#define DMA_CURR_DESCR				0x4c
-#define DMA_PREV_DESCR				0x50
-#define DMA_SRC_ADDR_SEG			0x54
-#define DMA_DST_ADDR_SEG			0x58
-#define DMA_DESCR_ADDR_SEG			0x5c
-
-#define DMA_STATUS_ERROR		(DMA_STATUS_ERR_ACC_DESCR | \
-					 DMA_STATUS_ERR_ACC_DST   | \
-					 DMA_STATUS_ERR_ACC_SRC   | \
-					 DMA_STATUS_ERR_OVERFLOW  | \
-					 DMA_STATUS_ERR_UNDERFLOW | \
-					 DMA_STATUS_UNALIGNED_ERR)
-
-#define DMA_STATUS_CLEAR		(DMA_STATUS_CH_PAUS_WR_EN | \
-					 DMA_STATUS_TR_COMPLETE   | \
-					 DMA_STATUS_BLK_COMPLETE)
-
-#define DMA_CONFIG_END			(DMA_CONFIG_LAST_BLOCK | \
-					 DMA_CONFIG_INT_DST_EOT)
-
-#define DMA_CONFIG_ONE_SHOT(__ext)	(DMA_CONFIG_DST_SPACE((__ext)) | \
-					 DMA_CONFIG_SRC_SPACE((__ext)) | \
-					 DMA_CONFIG_TX_EN              | \
-					 DMA_CONFIG_CHAN_EN)
-
-#define DMA_CONFIG_DSC_LOAD		(DMA_CONFIG_START_MEM_LOAD  | \
-					 DMA_CONFIG_FULL_DESCR_ADDR | \
-					 DMA_CONFIG_CHAN_EN)
-
-#define GEN_STAT       0x0
-#define   GEN_STAT_CH0_ACTIVE (1<<0)
-#define   GEN_STAT_CH1_ACTIVE (1<<2)
-#define   GEN_STAT_CH1_ACTIVE (1<<2)
-#define   GEN_STAT_CH0_ERROR  (1<<16)
-#define   GEN_STAT_CH1_ERROR  (1<<17)
-#define GEN_CONFIG     0x4
-#define  GEN_CONFIG_EXT_MEM                     (1<<19)
-#define  GEN_CONFIG_INT_EDGE(_ch)               (1<<(_ch))
-#define SOFT_RESET     0x8
-
-#define GPDMA_GEN_STAT(__p) ((__p)->gbase + GEN_STAT)
-#define GPDMA_GEN_CONFIG(__p) ((__p)->gbase + GEN_CONFIG)
-#define GPDMA_SOFT_RESET(__p) ((__p)->gbase + SOFT_RESET)
-
-
-struct descriptor {
-	u16 src_x_ctr;
-	u16 src_y_ctr;
-	s32 src_x_mod;
-	s32 src_y_mod;
-	u32 src_addr;
-	u32 src_data_mask;
-	u16 src_access;
-	u16 dst_access;
-	u32 ch_config;
-	u32 next_ptr;
-	u16 dst_x_ctr;
-	u16 dst_y_ctr;
-	s32 dst_x_mod;
-	s32 dst_y_mod;
-	u32 dst_addr;
-} __aligned(32);
-
-struct gpdma_engine;
-
-struct gpdma_desc {
-	struct descriptor               hw;
-	struct gpdma_desc              *chain;
-	dma_addr_t                      src;
-	dma_addr_t                      dst;
-	struct gpdma_engine            *engine;
-	struct virt_dma_desc	        vdesc;
-} __aligned(32);
-
-static struct gpdma_desc *to_gpdma_desc(struct virt_dma_desc *vdesc)
-{
-	return container_of(vdesc, struct gpdma_desc, vdesc);
-}
-
-struct gpdma_channel {
-	/* Back reference to DMA engine */
-	struct gpdma_engine		*engine;
-	/* Channel registers */
-	void __iomem			*base;
-	/* Channel id */
-	int			        id;
-	/* IRQ number as passed to request_irq() */
-	int				irq;
-	/* Currently running descriptor */
-	struct gpdma_desc               *active;
-	/* Channel parameters (DMA engine framework) */
-	struct virt_dma_chan		vc;
-};
-
-static inline struct gpdma_channel *to_gpdma_chan(struct dma_chan *chan)
-{
-	return container_of(chan, struct gpdma_channel, vc.chan);
-}
-
-struct lsidma_hw {
-	unsigned int num_channels;
-	unsigned int chregs_offset;
-	unsigned int genregs_offset;
-	unsigned int flags;
-#define LSIDMA_NEXT_FULL     (1<<0)
-#define LSIDMA_SEG_REGS      (1<<1)
-#define LSIDMA_EDGE_INT      (1<<2)
-};
-
-struct gpdma_engine {
-	struct device			*dev;
-	struct lsidma_hw		*chip;
-	struct gpdma_channel		channel[MAX_GPDMA_CHANNELS];
-	/** Bit mask where bit[n] == 1 if channel busy */
-	unsigned long                   ch_busy;
-	int                             err_irq;
-	void __iomem			*iobase;
-	void __iomem			*gbase;
-	void __iomem			*gpreg;
-	spinlock_t			lock;
-	struct list_head                free_list;
-	struct {
-		u32                     order;
-		dma_addr_t              phys;
-		struct gpdma_desc       *va;
-	} pool;
-	struct dma_device		dma_device;
-};
-
-#define desc_to_engine(n) container_of(n, struct gpdma_engine, desc)
-
-#endif
diff --git a/drivers/edac/axxia_edac-cmc_56xx.c b/drivers/edac/axxia_edac-cmc_56xx.c
index 97fb4bb..2cdd5ab 100644
--- a/drivers/edac/axxia_edac-cmc_56xx.c
+++ b/drivers/edac/axxia_edac-cmc_56xx.c
@@ -13,7 +13,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
diff --git a/drivers/edac/axxia_edac-l2_cpu.c b/drivers/edac/axxia_edac-l2_cpu.c
index 27d9b65..05a3a7c 100644
--- a/drivers/edac/axxia_edac-l2_cpu.c
+++ b/drivers/edac/axxia_edac-l2_cpu.c
@@ -3,7 +3,7 @@
   *
   * EDAC Driver for Avago's Axxia 5500 A15 CPUs and L2 caches
   *
-  * Copyright (C) 2010 LSI Inc.
+  * Copyright (C) 2018 INTEL Inc.
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
@@ -24,7 +24,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
@@ -37,7 +37,7 @@
 #include "axxia_edac.h"
 #include "axxia_l2_55xx.h"
 
-#define LSI_EDAC_MOD_STR     "lsi_edac"
+#define AXXIA_EDAC_MOD_STR     "axxia_edac"
 #define CORES_PER_CLUSTER 4
 
 #define APB2_PERSIST_SCRATCH 0xdc
@@ -45,7 +45,7 @@
 #define CPU_PERSIST_SCRATCH_BIT (0x1 << 6)
 
 /* Private structure for common edac device */
-struct lsi_edac_dev_info {
+struct axxia_edac_dev_info {
 	struct platform_device *pdev;
 	char *ctl_name;
 	char *blk_name;
@@ -61,7 +61,7 @@ void log_cpumerrsr(void *edac)
 	u64 val, clear_val;
 	u32 count0, count1;
 	int i;
-	struct lsi_edac_dev_info *dev_info;
+	struct axxia_edac_dev_info *dev_info;
 
 	dev_info = edac_dev->pvt_info;
 
@@ -96,7 +96,7 @@ void log_cpumerrsr(void *edac)
 
 
 /* Check for CPU Errors */
-static void lsi_cpu_error_check(struct edac_device_ctl_info *edac_dev)
+static void axxia_cpu_error_check(struct edac_device_ctl_info *edac_dev)
 {
 	/* execute on current cpu */
 	log_cpumerrsr(edac_dev);
@@ -112,7 +112,7 @@ void log_l2merrsr(void *edac)
 	u64 val, clear_val;
 	u32 count0, count1;
 	int i;
-	struct lsi_edac_dev_info *dev_info;
+	struct axxia_edac_dev_info *dev_info;
 
 	dev_info = edac_dev->pvt_info;
 
@@ -146,7 +146,7 @@ void log_l2merrsr(void *edac)
 }
 
 /* Check for L2 Errors */
-static void lsi_l2_error_check(struct edac_device_ctl_info *edac_dev)
+static void axxia_l2_error_check(struct edac_device_ctl_info *edac_dev)
 {
 	/* 4 cores per cluster */
 	int nr_cluster_ids = ((nr_cpu_ids - 1) / CORES_PER_CLUSTER) + 1;
@@ -177,10 +177,10 @@ static void lsi_l2_error_check(struct edac_device_ctl_info *edac_dev)
 	}
 }
 
-static void lsi_add_edac_devices(struct platform_device *pdev,
+static void axxia_add_edac_devices(struct platform_device *pdev,
 	int num)
 {
-	struct lsi_edac_dev_info *dev_info = NULL;
+	struct axxia_edac_dev_info *dev_info = NULL;
 	/* 4 cores per cluster */
 	int nr_cluster_ids = ((nr_cpu_ids - 1) / CORES_PER_CLUSTER) + 1;
 	struct device_node *np = pdev->dev.of_node;
@@ -192,10 +192,10 @@ static void lsi_add_edac_devices(struct platform_device *pdev,
 	dev_info->ctl_name = kstrdup(np->name, GFP_KERNEL);
 	if (num == 0) {
 		dev_info->blk_name = "cpumerrsr";
-		dev_info->check = lsi_cpu_error_check;
+		dev_info->check = axxia_cpu_error_check;
 	} else {
 		dev_info->blk_name = "l2merrsr";
-		dev_info->check = lsi_l2_error_check;
+		dev_info->check = axxia_l2_error_check;
 	}
 	dev_info->pdev = pdev;
 	dev_info->edac_idx = edac_device_alloc_index();
@@ -225,7 +225,7 @@ static void lsi_add_edac_devices(struct platform_device *pdev,
 	dev_info->edac_dev->pvt_info = dev_info;
 	dev_info->edac_dev->dev = &dev_info->pdev->dev;
 	dev_info->edac_dev->ctl_name = dev_info->ctl_name;
-	dev_info->edac_dev->mod_name = LSI_EDAC_MOD_STR;
+	dev_info->edac_dev->mod_name = AXXIA_EDAC_MOD_STR;
 	dev_info->edac_dev->dev_name = dev_name(&dev_info->pdev->dev);
 
 	dev_info->edac_dev->edac_check = dev_info->check;
@@ -243,65 +243,65 @@ static void lsi_add_edac_devices(struct platform_device *pdev,
 	platform_device_unregister(dev_info->pdev);
 }
 
-static int lsi_edac_cpu_probe(struct platform_device *pdev)
+static int axxia_edac_cpu_probe(struct platform_device *pdev)
 {
 	edac_op_state = EDAC_OPSTATE_POLL;
-	lsi_add_edac_devices(pdev, 0);
+	axxia_add_edac_devices(pdev, 0);
 	return 0;
 }
 
-static int lsi_edac_cpu_remove(struct platform_device *pdev)
+static int axxia_edac_cpu_remove(struct platform_device *pdev)
 {
 	platform_device_unregister(pdev);
 	return 0;
 }
 
-static int lsi_edac_l2_probe(struct platform_device *pdev)
+static int axxia_edac_l2_probe(struct platform_device *pdev)
 {
 	edac_op_state = EDAC_OPSTATE_POLL;
-	lsi_add_edac_devices(pdev, 1);
+	axxia_add_edac_devices(pdev, 1);
 	return 0;
 }
 
-static int lsi_edac_l2_remove(struct platform_device *pdev)
+static int axxia_edac_l2_remove(struct platform_device *pdev)
 {
 	platform_device_unregister(pdev);
 	return 0;
 }
 
-static struct of_device_id lsi_edac_l2_match[] = {
+static struct of_device_id axxia_edac_l2_match[] = {
 	{
-	.compatible = "lsi,cortex-a15-l2-cache",
+	.compatible = "axxia,cortex-a15-l2-cache",
 	},
 	{},
 };
 
-static struct platform_driver lsi_edac_l2_driver = {
-	.probe = lsi_edac_l2_probe,
-	.remove = lsi_edac_l2_remove,
+static struct platform_driver axxia_edac_l2_driver = {
+	.probe = axxia_edac_l2_probe,
+	.remove = axxia_edac_l2_remove,
 	.driver = {
-		.name = "lsi_edac_l2",
-		.of_match_table = lsi_edac_l2_match,
+		.name = "axxia_edac_l2",
+		.of_match_table = axxia_edac_l2_match,
 	}
 };
-static struct of_device_id lsi_edac_cpu_match[] = {
+static struct of_device_id axxia_edac_cpu_match[] = {
 	{
-	.compatible = "lsi,cortex-a15-cpu",
+	.compatible = "axxia,cortex-a15-cpu",
 	},
 	{},
 };
 
-static struct platform_driver lsi_edac_cpu_driver = {
-	.probe = lsi_edac_cpu_probe,
-	.remove = lsi_edac_cpu_remove,
+static struct platform_driver axxia_edac_cpu_driver = {
+	.probe = axxia_edac_cpu_probe,
+	.remove = axxia_edac_cpu_remove,
 	.driver = {
-		.name = "lsi_edac_cpu",
-		.of_match_table = lsi_edac_cpu_match,
+		.name = "axxia_edac_cpu",
+		.of_match_table = axxia_edac_cpu_match,
 	}
 };
 
-module_platform_driver(lsi_edac_cpu_driver);
-module_platform_driver(lsi_edac_l2_driver);
+module_platform_driver(axxia_edac_cpu_driver);
+module_platform_driver(axxia_edac_l2_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Sangeetha Rao <sangeetha.rao@avagotech.com>");
diff --git a/drivers/edac/axxia_edac-l2_cpu_56xx.c b/drivers/edac/axxia_edac-l2_cpu_56xx.c
index 42dd811..1a67b88 100644
--- a/drivers/edac/axxia_edac-l2_cpu_56xx.c
+++ b/drivers/edac/axxia_edac-l2_cpu_56xx.c
@@ -15,7 +15,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
diff --git a/drivers/edac/axxia_edac-l3.c b/drivers/edac/axxia_edac-l3.c
index 48a0ad0..31ea7c0 100644
--- a/drivers/edac/axxia_edac-l3.c
+++ b/drivers/edac/axxia_edac-l3.c
@@ -3,7 +3,7 @@
   *
   * EDAC Driver for Avago's Axxia 5500 for L3 cache
   *
-  * Copyright (C) 2010 LSI Inc.
+  * Copyright (C) 2018 INTEL Inc.
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
@@ -24,7 +24,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
@@ -36,13 +36,13 @@
 #include "edac_module.h"
 #include "axxia_edac.h"
 
-#define LSI_EDAC_MOD_STR     "lsi_edac"
+#define AXXIA_EDAC_MOD_STR     "axxia_edac"
 
 #define APB2_PERSIST_SCRATCH 0xdc
 #define L3_PERSIST_SCRATCH_BIT (0x1 << 4)
 
 /* Private structure for common edac device */
-struct lsi_edac_dev_info {
+struct axxia_edac_dev_info {
 	struct platform_device *pdev;
 	char *ctl_name;
 	char *blk_name;
@@ -54,14 +54,14 @@ struct lsi_edac_dev_info {
 };
 
 /* Check for L3 Errors */
-static void lsi_l3_error_check(struct edac_device_ctl_info *edac_dev)
+static void axxia_l3_error_check(struct edac_device_ctl_info *edac_dev)
 {
 	unsigned long regVal1, regVal2;
 	unsigned count = 0;
 	int i, instance;
-	struct lsi_edac_dev_info *dev_info;
+	struct axxia_edac_dev_info *dev_info;
 
-	dev_info = (struct lsi_edac_dev_info *) edac_dev->pvt_info;
+	dev_info = (struct axxia_edac_dev_info *) edac_dev->pvt_info;
 
 	for (instance = 0; instance < 8; instance++) {
 		regVal1 = readl(dev_info->dickens_L3 + (instance * 0x10000));
@@ -89,9 +89,9 @@ static void lsi_l3_error_check(struct edac_device_ctl_info *edac_dev)
 	}
 }
 
-static int lsi_edac_l3_probe(struct platform_device *pdev)
+static int axxia_edac_l3_probe(struct platform_device *pdev)
 {
-	struct lsi_edac_dev_info *dev_info = NULL;
+	struct axxia_edac_dev_info *dev_info = NULL;
 	struct device_node *np = pdev->dev.of_node;
 	struct resource *r;
 
@@ -113,7 +113,7 @@ static int lsi_edac_l3_probe(struct platform_device *pdev)
 	dev_info->dickens_L3 = devm_ioremap(&pdev->dev, r->start,
 					    resource_size(r));
 	if (!dev_info->dickens_L3) {
-		pr_err("LSI_L3 devm_ioremap error\n");
+		pr_err("AXXIA_L3 devm_ioremap error\n");
 		goto err1;
 	}
 
@@ -137,10 +137,10 @@ static int lsi_edac_l3_probe(struct platform_device *pdev)
 	dev_info->edac_dev->pvt_info = dev_info;
 	dev_info->edac_dev->dev = &dev_info->pdev->dev;
 	dev_info->edac_dev->ctl_name = dev_info->ctl_name;
-	dev_info->edac_dev->mod_name = LSI_EDAC_MOD_STR;
+	dev_info->edac_dev->mod_name = AXXIA_EDAC_MOD_STR;
 	dev_info->edac_dev->dev_name = dev_name(&dev_info->pdev->dev);
 	edac_op_state = EDAC_OPSTATE_POLL;
-	dev_info->edac_dev->edac_check = lsi_l3_error_check;
+	dev_info->edac_dev->edac_check = axxia_l3_error_check;
 
 	if (edac_device_add_device(dev_info->edac_dev) != 0) {
 		pr_info("Unable to add edac device for %s\n",
@@ -156,29 +156,29 @@ static int lsi_edac_l3_probe(struct platform_device *pdev)
 	return 1;
 }
 
-static int lsi_edac_l3_remove(struct platform_device *pdev)
+static int axxia_edac_l3_remove(struct platform_device *pdev)
 {
 	platform_device_unregister(pdev);
 	return 0;
 }
 
-static struct of_device_id lsi_edac_l3_match[] = {
+static struct of_device_id axxia_edac_l3_match[] = {
 	{
-	.compatible = "lsi,ccn504-l3-cache",
+	.compatible = "axxia,ccn504-l3-cache",
 	},
 	{},
 };
 
-static struct platform_driver lsi_edac_l3_driver = {
-	.probe = lsi_edac_l3_probe,
-	.remove = lsi_edac_l3_remove,
+static struct platform_driver axxia_edac_l3_driver = {
+	.probe = axxia_edac_l3_probe,
+	.remove = axxia_edac_l3_remove,
 	.driver = {
-		.name = "lsi_edac_l3",
-		.of_match_table = lsi_edac_l3_match,
+		.name = "axxia_edac_l3",
+		.of_match_table = axxia_edac_l3_match,
 	}
 };
 
-module_platform_driver(lsi_edac_l3_driver);
+module_platform_driver(axxia_edac_l3_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Sangeetha Rao <sangeetha.rao@avagotech.com>");
diff --git a/drivers/edac/axxia_edac-l3_56xx.c b/drivers/edac/axxia_edac-l3_56xx.c
index 1e0471b..1568c1f 100644
--- a/drivers/edac/axxia_edac-l3_56xx.c
+++ b/drivers/edac/axxia_edac-l3_56xx.c
@@ -16,7 +16,7 @@
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/interrupt.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
diff --git a/drivers/edac/axxia_edac-mc.c b/drivers/edac/axxia_edac-mc.c
index 197723c..e009c9c 100644
--- a/drivers/edac/axxia_edac-mc.c
+++ b/drivers/edac/axxia_edac-mc.c
@@ -13,7 +13,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
@@ -28,7 +28,7 @@
 #include "edac_module.h"
 #include "axxia_edac.h"
 
-#define LSI_EDAC_MOD_STR     "lsi_edac"
+#define AXXIA_EDAC_MOD_STR     "axxia_edac"
 
 #define APB2_SER3_PHY_ADDR        0x002010030000ULL
 #define APB2_SER3_PHY_SIZE   0x1000
@@ -136,7 +136,7 @@ enum events {
 };
 
 /* Private structure for common edac device */
-struct lsi_edac_dev_info {
+struct axxia_edac_dev_info {
 	struct platform_device *pdev;
 	char *ctl_name;
 	char *blk_name;
@@ -151,7 +151,7 @@ struct lsi_edac_dev_info {
 static irqreturn_t
 smmon_isr(int interrupt, void *device)
 {
-	struct lsi_edac_dev_info *edac_dev = device;
+	struct axxia_edac_dev_info *edac_dev = device;
 	u32 status;
 	unsigned long set_val;
 	int i;
@@ -195,12 +195,12 @@ struct lsi_edac_dev_info {
 	return IRQ_HANDLED;
 }
 
-static void lsi_sm_error_check(struct edac_device_ctl_info *edac_dev)
+static void axxia_sm_error_check(struct edac_device_ctl_info *edac_dev)
 {
 	unsigned long sm_reg_val, clear_val;
-	struct lsi_edac_dev_info *dev_info;
+	struct axxia_edac_dev_info *dev_info;
 
-	dev_info = (struct lsi_edac_dev_info *) edac_dev->pvt_info;
+	dev_info = (struct axxia_edac_dev_info *) edac_dev->pvt_info;
 
 	/* SM0 is instance 0 */
 	ncr_read(dev_info->sm_region, SM_INT_STATUS_REG, 4, &sm_reg_val);
@@ -215,10 +215,10 @@ static void lsi_sm_error_check(struct edac_device_ctl_info *edac_dev)
 }
 
 
-static int lsi_edac_mc_probe(struct platform_device *pdev)
+static int axxia_edac_mc_probe(struct platform_device *pdev)
 {
 	static int count;
-	struct lsi_edac_dev_info *dev_info = NULL;
+	struct axxia_edac_dev_info *dev_info = NULL;
 	/* 4 cores per cluster */
 	struct resource *io;
 	struct device_node *np = pdev->dev.of_node;
@@ -294,9 +294,9 @@ static int lsi_edac_mc_probe(struct platform_device *pdev)
 	dev_info->edac_dev->pvt_info = dev_info;
 	dev_info->edac_dev->dev = &dev_info->pdev->dev;
 	dev_info->edac_dev->ctl_name = dev_info->ctl_name;
-	dev_info->edac_dev->mod_name = LSI_EDAC_MOD_STR;
+	dev_info->edac_dev->mod_name = AXXIA_EDAC_MOD_STR;
 	dev_info->edac_dev->dev_name = dev_name(&dev_info->pdev->dev);
-	dev_info->edac_dev->edac_check = lsi_sm_error_check;
+	dev_info->edac_dev->edac_check = axxia_sm_error_check;
 
 
 	if (edac_device_add_device(dev_info->edac_dev) != 0) {
@@ -313,27 +313,27 @@ static int lsi_edac_mc_probe(struct platform_device *pdev)
 	return 1;
 }
 
-static int lsi_edac_mc_remove(struct platform_device *pdev)
+static int axxia_edac_mc_remove(struct platform_device *pdev)
 {
 	platform_device_unregister(pdev);
 	return 0;
 }
 
-static const struct of_device_id lsi_edac_smmon_match[] = {
-	{ .compatible = "lsi,smmon" },
+static const struct of_device_id axxia_edac_smmon_match[] = {
+	{ .compatible = "axxia,smmon" },
 	{ }
 };
-MODULE_DEVICE_TABLE(platform, lsi_edac_smmon_match);
+MODULE_DEVICE_TABLE(platform, axxia_edac_smmon_match);
 
-static struct platform_driver lsi_edac_mc_driver = {
-	.probe = lsi_edac_mc_probe,
-	.remove = lsi_edac_mc_remove,
+static struct platform_driver axxia_edac_mc_driver = {
+	.probe = axxia_edac_mc_probe,
+	.remove = axxia_edac_mc_remove,
 	.driver = {
-		.name = "lsi_edac_smmon",
-		.of_match_table = lsi_edac_smmon_match,
+		.name = "axxia_edac_smmon",
+		.of_match_table = axxia_edac_smmon_match,
 	}
 };
-module_platform_driver(lsi_edac_mc_driver);
+module_platform_driver(axxia_edac_mc_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Sangeetha Rao <sangeetha.rao@avagotech.com>");
diff --git a/drivers/edac/axxia_edac-mc_56xx.c b/drivers/edac/axxia_edac-mc_56xx.c
index e891216..7fa1443 100644
--- a/drivers/edac/axxia_edac-mc_56xx.c
+++ b/drivers/edac/axxia_edac-mc_56xx.c
@@ -14,7 +14,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/edac.h>
 #include <linux/of_platform.h>
 #include <linux/of.h>
diff --git a/drivers/gpio/gpio-axxia.c b/drivers/gpio/gpio-axxia.c
index 0b80482..dce94e2 100644
--- a/drivers/gpio/gpio-axxia.c
+++ b/drivers/gpio/gpio-axxia.c
@@ -356,7 +356,7 @@ static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 		return ret;
 	}
 
-	if (of_find_compatible_node(NULL, NULL, "lsi,axc6732")) {
+	if (of_find_compatible_node(NULL, NULL, "axxia,axc6732")) {
 		for (i = 0; i < AMBA_NR_IRQS; i++) {
 			if (adev->irq[i] <= 0)
 				continue;
diff --git a/drivers/i2c/busses/i2c-axxia.c b/drivers/i2c/busses/i2c-axxia.c
index 7c98d7a..8574747 100644
--- a/drivers/i2c/busses/i2c-axxia.c
+++ b/drivers/i2c/busses/i2c-axxia.c
@@ -689,7 +689,7 @@ static int axxia_i2c_resume(struct platform_device *pdev)
 #endif
 /* Match table for of_platform binding */
 static const struct of_device_id axxia_i2c_of_match[] = {
-	{ .compatible = "lsi,api2c", },
+	{ .compatible = "axxia,api2c", },
 	{},
 };
 
@@ -710,5 +710,5 @@ static int axxia_i2c_resume(struct platform_device *pdev)
 module_platform_driver(axxia_i2c_driver);
 
 MODULE_DESCRIPTION("Axxia I2C Bus driver");
-MODULE_AUTHOR("Anders Berg <anders.berg@lsi.com>");
+MODULE_AUTHOR("Anders Berg <anders.berg@intel.com>");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 23599c6..0925bed 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -495,8 +495,8 @@ config SRAM
 config SRAM_EXEC
 	bool
 
-config LSI_MTC
-	tristate "LSI Master Test Controller driver"
+config AXXIA_MTC
+	tristate "INTEL Axxia Master Test Controller driver"
 	depends on ARCH_AXXIA
 	help
 	  The Master Test Controller (MTC) is a test generator that is fully
@@ -504,22 +504,22 @@ config LSI_MTC
 	  external devices.
 	  Say N if you are unsure
 
-config LSI_NCR
-	bool "LSI NCR Access"
+config AXXIA_NCR
+	bool "AXXIA NCR Access"
 	depends on ARCH_AXXIA || ACP
 	help
-	  Provides access to the LSI Axxia NCR bus.
+	  Provides access to the INTEL Axxia NCR bus.
 
 config ARCH_AXXIA_NCR_RESET_CHECK
 	bool "Axxia NCR driver reset checking"
-	depends on LSI_NCR
+	depends on AXXIA_NCR
 	help
 	  Enabling this option will allow the Axxia NCA Config Ring driver
 	  to coordinate with the RTE ncp driver to detect when NCA hardware
 	  is being held in reset.
 
-config LSI_SMMON
-	tristate "LSI System Memory Monitor"
+config AXXIA_SMMON
+	tristate "INTEL Axxia System Memory Monitor"
 	depends on ARCH_AXXIA || ACP
 	depends on !EDAC_AXXIA
 	help
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 24589f6..0b84df9 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -53,9 +53,9 @@ obj-$(CONFIG_SRAM)		+= sram.o
 obj-$(CONFIG_SRAM_EXEC)		+= sram-exec.o
 obj-y				+= mic/
 obj-$(CONFIG_GENWQE)		+= genwqe/
-obj-$(CONFIG_LSI_NCR)           += lsi-ncr.o
-obj-$(CONFIG_LSI_MTC)		+= lsi-mtc.o
-obj-$(CONFIG_LSI_SMMON)         += lsi-smmon.o
+obj-$(CONFIG_AXXIA_NCR)           += axxia-ncr.o
+obj-$(CONFIG_AXXIA_MTC)		+= axxia-mtc.o
+obj-$(CONFIG_AXXIA_SMMON)         += axxia-smmon.o
 obj-$(CONFIG_AXXIA_OEM)         += axxia-oem.o
 obj-$(CONFIG_AXXIA_FAULT)       += axxia-fault.o
 obj-$(CONFIG_AXXIA_PEI)         += axxia-pei.o
diff --git a/drivers/misc/axxia-fault.c b/drivers/misc/axxia-fault.c
index 5918f54..5f4c29e 100644
--- a/drivers/misc/axxia-fault.c
+++ b/drivers/misc/axxia-fault.c
@@ -155,16 +155,16 @@
 axxia_fault_init(void)
 {
 #if defined(ARM)
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5500") ||
-	    of_find_compatible_node(NULL, NULL, "lsi,axm5516")) {
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5500") ||
+	    of_find_compatible_node(NULL, NULL, "axxia,axm5516")) {
 		mask_aborts = 1;
 		hook_fault_code(0x11, axxia_x7_fault, SIGBUS, 0,
 				"asynchronous external abort");
 		pr_debug("Set up fault handler for Axxia 5500\n");
 	}
 #elif defined(ARM64)
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-	    of_find_compatible_node(NULL, NULL, "lsi,axc6732"))
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+	    of_find_compatible_node(NULL, NULL, "axxia,axc6732"))
 		pr_debug("Set up fault handler for Axxia 5600/6700\n");
 #endif
 
diff --git a/drivers/misc/axxia-mdio.c b/drivers/misc/axxia-mdio.c
index 1607c77..2d8f7e9 100644
--- a/drivers/misc/axxia-mdio.c
+++ b/drivers/misc/axxia-mdio.c
@@ -163,8 +163,8 @@ struct axxia_mdio_priv {
 	priv->bus->parent = &pdev->dev;
 	dev_set_drvdata(&pdev->dev, priv->bus);
 
-	of_property_read_u32(np, "lsi,mdio-clk-offset", &clk_offset);
-	of_property_read_u32(np, "lsi,mdio-clk-period", &clk_period);
+	of_property_read_u32(np, "axxia,mdio-clk-offset", &clk_offset);
+	of_property_read_u32(np, "axxia,mdio-clk-period", &clk_period);
 
 	writel(clk_offset, priv->base + MDIO_CLK_OFFSET);
 	writel(clk_period, priv->base + MDIO_CLK_PERIOD);
@@ -200,9 +200,9 @@ struct axxia_mdio_priv {
 }
 
 static struct of_device_id axxia_mdio_match[] = {
-	{ .compatible = "lsi,axm-mdio", },
-	{ .compatible = "intel,axxia-mdio0", },
-	{ .compatible = "intel,axxia-mdio1", },
+	{ .compatible = "axxia,axm-mdio", },
+	{ .compatible = "axxia,axxia-mdio0", },
+	{ .compatible = "axxia,axxia-mdio1", },
 	{},
 };
 
diff --git a/drivers/misc/axxia-mtc.c b/drivers/misc/axxia-mtc.c
new file mode 100644
index 0000000..7377f9ee
--- /dev/null
+++ b/drivers/misc/axxia-mtc.c
@@ -0,0 +1,4233 @@
+/*
+ *  Copyright (C) 2013 INTEL Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  Device driver for INTEL Axxia Master Test Controller (MTC), which is a test
+ *  generator that is fully compliant with IEEE 1149.1 and can run JTAG test
+ *  sequences on external devices. The device is accessed via a character
+ *  device (/dev/mtc) through which test sequences can be loaded and exececuted
+ *  by the controller.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/atomic.h>
+#include <linux/io.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include "linux/axxia_mtc_ioctl.h"
+
+
+/*
+   device tree node:
+
+   mtc@2010098000 {
+	   compatible = "axxia,mtc";
+	   reg = <0x20 0x10098000 0 0x3000>;
+	   interrupts = <0 45 4>;
+   };
+
+ */
+
+/* MTC registers */
+struct mtc_regs {
+	u32 params;		/* 0x00 */
+	u32 scratch0;		/* 0x04 */
+	u32 scratch1;		/* 0x08 */
+	u32 reserved_0c[1];	/* 0x0c */
+	u32 config0;		/* 0x10 */
+	u32 config1;		/* 0x14 */
+	u32 reserved_18[2];	/* 0x18..0x1c */
+	u32 status1;		/* 0x20 */
+	u32 status2;		/* 0x24 */
+	u32 reserved_28[2];	/* 0x28..0x2c */
+	u32 execute;		/* 0x30 */
+	u32 reserved_34[3];	/* 0x34..0x3c */
+	u32 mem_init;		/* 0x40 */
+	u32 ecc_disable;	/* 0x44 */
+	u32 ecc_invert_en;	/* 0x48 */
+	u32 ecc_invert;		/* 0x4c */
+	u32 int_status;		/* 0x50 */
+	u32 int_enable;		/* 0x54 */
+	u32 int_force;		/* 0x58 */
+	u32 ecc_int_status;	/* 0x5c */
+	u32 ecc_int_enable;	/* 0x60 */
+	u32 ecc_int_force;	/* 0x64 */
+	u32 reserved_68[6];	/* 0x68..0x7c */
+	u32 debug0;		/* 0x80 */
+	u32 debug1;		/* 0x84 */
+	u32 debug2;		/* 0x88 */
+	u32 debug3;		/* 0x8c */
+	u32 debug4;		/* 0x90 */
+	u32 debug5;		/* 0x94 */
+	u32 reserved_98[2];	/* 0x98..0x9c */
+	u32 axi_config0;	/* 0x100 */
+	u32 axi_config1;	/* 0x104 */
+	u32 axi_config2;	/* 0x108 */
+	u32 axi_config3;	/* 0x10c */
+	u32 axi_config4;	/* 0x110 */
+	u32 axi_config5;	/* 0x114 */
+	u32 axi_config6;	/* 0x118 */
+	u32 axi_status0;	/* 0x200 */
+	u32 axi_status1;	/* 0x204 */
+	u32 axi_status2;	/* 0x208 */
+	u32 axi_status3;	/* 0x20c */
+};
+
+#define MTC_PRGMEM_OFFSET 0x1000
+#define MTC_TDOMEM_OFFSET 0x2000
+#define MTC_PRGMEM_SIZE 256	/* program memory size in words */
+#define MTC_TDOMEM_SIZE 256	/* tdo memory size in words */
+
+#ifdef __MTC_SIMULATION
+struct mtc_regs _mtc_regs;
+u32 _mtc_tdomem[256] = { 0x11110000, 0x22221111, 0x33332222 };
+u32 *_mtc_prgmem = _mtc_tdomem;
+#endif
+
+/******************************************************/
+/* register definitions generated from RDL */
+
+/******************************************************/
+
+   /* NODE 0x15d , TARGET 0xffffffff */
+
+#define     NCP_AXIS_MTC_MTC_INST_PARAMS0_REG_ADDR              (0x00000000)
+#define     NCP_AXIS_MTC_MTC_SCRATCH0_REG_ADDR                  (0x00000004)
+#define     NCP_AXIS_MTC_MTC_SCRATCH1_REG_ADDR                  (0x00000008)
+#define     NCP_AXIS_MTC_MTC_CONFIG0_REG_ADDR                   (0x00000010)
+#define     NCP_AXIS_MTC_MTC_CONFIG1_REG_ADDR                   (0x00000014)
+#define     NCP_AXIS_MTC_MTC_STATUS1_REG_ADDR                   (0x00000020)
+#define     NCP_AXIS_MTC_MTC_STATUS2_REG_ADDR                   (0x00000024)
+#define     NCP_AXIS_MTC_MTC_EXECUTE1_REG_ADDR                  (0x00000030)
+#define     NCP_AXIS_MTC_MTC_MEM_INIT_REG_ADDR                  (0x00000040)
+#define     NCP_AXIS_MTC_MTC_ECC_DISABLE_REG_ADDR               (0x00000044)
+#define     NCP_AXIS_MTC_MTC_ECC_INVERT_EN_REG_ADDR             (0x00000048)
+#define     NCP_AXIS_MTC_MTC_ECC_INVERT_REG_ADDR                (0x0000004c)
+#define     NCP_AXIS_MTC_MTC_DEBUG0_REG_ADDR                    (0x00000080)
+#define     NCP_AXIS_MTC_MTC_DEBUG1_REG_ADDR                    (0x00000084)
+#define     NCP_AXIS_MTC_MTC_DEBUG2_REG_ADDR                    (0x00000088)
+#define     NCP_AXIS_MTC_MTC_DEBUG3_REG_ADDR                    (0x0000008c)
+#define     NCP_AXIS_MTC_MTC_DEBUG4_REG_ADDR                    (0x00000090)
+#define     NCP_AXIS_MTC_MTC_DEBUG5_REG_ADDR                    (0x00000094)
+
+#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_BASE           (0x00001000)
+#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR(n)      (0x00001000 + (4*(n)))
+#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_COUNT          (0x00000100)
+#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_IDX(addr) \
+	(((addr) - NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_BASE) / 4)
+#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_END            (0x00001400)
+#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_RANGE(addr) \
+	(((addr) >= NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_BASE) && \
+	((addr) < NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_END))
+
+#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_BASE    (0x00002000)
+#define   NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR(n) (0x00002000 + (4*(n)))
+#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_COUNT   (0x00000100)
+#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_IDX(addr) \
+	(((addr) - NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_BASE) / 4)
+#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_END     (0x00002400)
+#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_RANGE(addr) \
+	(((addr) >= NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_BASE) && \
+	((addr) < NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_END))
+
+#define     NCP_AXIS_MTC_MTC_AXI_CFG0_REG_ADDR_5600             (0x00000100)
+#define     NCP_AXIS_MTC_MTC_AXI_CFG1_REG_ADDR_5600             (0x00000104)
+#define     NCP_AXIS_MTC_MTC_AXI_CFG2_REG_ADDR_5600             (0x00000108)
+#define     NCP_AXIS_MTC_MTC_AXI_CFG3_REG_ADDR_5600             (0x0000010c)
+#define     NCP_AXIS_MTC_MTC_AXI_CFG4_REG_ADDR_5600             (0x00000110)
+#define     NCP_AXIS_MTC_MTC_AXI_CFG5_REG_ADDR_5600             (0x00000114)
+#define     NCP_AXIS_MTC_MTC_AXI_CFG6_REG_ADDR_5600             (0x00000118)
+#define     NCP_AXIS_MTC_MTC_AXI_STATUS0_REG_ADDR_5600          (0x00000200)
+#define     NCP_AXIS_MTC_MTC_AXI_STATUS1_REG_ADDR_FIFO_STAT_5600  (0x00000204)
+#define     NCP_AXIS_MTC_MTC_AXI_STATUS2_REG_ADDR_5600          (0x00000208)
+#define     NCP_AXIS_MTC_MTC_AXI_STATUS3_REG_ADDR_5600          (0x0000020c)
+#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_STATUS                  (0x00000050)
+#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_STATUS_ALARM_MASK       (0x0000007f)
+#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_EN                      (0x00000054)
+#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_EN_ALARM_MASK           (0x0000007f)
+#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_FRC                     (0x00000058)
+#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_FRC_ALARM_MASK          (0x0000007f)
+#define     NCP_AXIS_MTC_MTC_ECC_INT_STATUS                     (0x0000005c)
+#define     NCP_AXIS_MTC_MTC_ECC_INT_STATUS_ALARM_MASK          (0x0000000f)
+#define     NCP_AXIS_MTC_MTC_ECC_INT_EN                         (0x00000060)
+#define     NCP_AXIS_MTC_MTC_ECC_INT_EN_ALARM_MASK              (0x0000000f)
+#define     NCP_AXIS_MTC_MTC_ECC_INT_FRC                        (0x00000064)
+#define     NCP_AXIS_MTC_MTC_ECC_INT_FRC_ALARM_MASK             (0x0000000f)
+
+/*! @struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t
+ *  @brief MTC Parameter Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_memory_size </td>
+ *     <td width="20%" align="center"> 10 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Size of TDO record memory in bytes. </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *     <td width="20%" align="center"> 10 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_prgm_memory_size </td>
+ *     <td width="20%" align="center"> 10 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Size of Test Program memory in bytes. </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:6;
+	unsigned tdo_memory_size:10;
+	unsigned reserved1:6;
+	unsigned tst_prgm_memory_size:10;
+#else	/* Little Endian */
+	unsigned tst_prgm_memory_size:10;
+	unsigned reserved1:6;
+	unsigned tdo_memory_size:10;
+	unsigned reserved0:6;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t
+ *  @brief MTC Scratch 0 Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param scratchpad0 </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> SW read/write register - Not used by MTC hardware. </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t {
+	unsigned int scratchpad0;
+};
+
+/*! @struct ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t
+ *  @brief MTC Scratch 1 Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param scratchpad1 </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> SW read/write register - Not used by MTC hardware. </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t {
+	unsigned int scratchpad1;
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t
+ *  @brief MTC Config 0 Register
+ *  @details Configuration/Control Registers for the MTC block
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_mpu_tdo_inactive_en </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 15 </td>
+ *   <td width="30%"> 1) When Config mode Includes the AXM in the scan chain.
+ *         1'b0 = MTC_TDO_ENB = 1'b1; TDO Output buffer always
+ *        enabled.  1'b1 = MTC_TDO_ENB = JTC_TDO_ENB; TDO
+ *        Output buffer follows the JTC control signal.  2)
+ *        When Config mode Excludes the AXM in the scan chain.
+ *        1'b0 = MTC_TDO_ENB = 1'b1; TDO Output buffer always
+ *        enabled. 1'b1 = MTC_TDO_ENB = Active (1'b1) when in
+ *        shift-DR or shift-IR states and inactive (1'b0) in
+ *        all other states (tri-state capable).
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param loop_en </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 14 </td>
+ *   <td width="30%"> 1'b1 = When an End-of-test command is received the
+ *        test program will continue to execute from location
+ *        0 of the memory instead of halting.   This assumes
+ *        the test program fits within the 256 x 32 bit memory.
+ *        1'b0 = In normal operation the MTC_TESTGEN block
+ *        will loop through the 256 location program memory
+ *        until an end-of-test command is detected.  Once
+ *        detected the program will stop execution in its current
+ *        state (Run/Test Idle, pause-IR, or pause-DR).
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param single_step_en </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> 1'b1 = Single step mode is enabled;  1'b0 = Single
+ *        step mode is disabled (ignore writes to single_step
+ *        one-shot register  Note: In single step mode the
+ *        TACP state machine cannot stop in the Select-DR-Scan
+ *        state waitng for the user to write the single_step
+ *        one-shot register.  Therefore, the end-state-bit[28]
+ *        value is ignored in this mode and always pauses in
+ *        run-test/idle state.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param start_stopn </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *   <td width="30%"> 1'b1 = Run/Resume  1'b0 = Stop in current task </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *     <td width="20%" align="center"> 9 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param rate_sel </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> TCK clock rate based off the internal clk_per clock
+ *        rate (nominal value 200 MHz)  5'd0, others = TCK
+ *        = Disable  5'd1 = TCK = 20.00 MHz (/10)  5'd2
+ *        = TCK = 16.67 MHz (/12)  5'd3 = TCK = 14.28 MHz
+ *        (/14)  5'd4 = TCK = 12.50 MHz (/16)  5'd5 =
+ *        TCK = 11.11 MHz (/18)  5'd6 = TCK = 10.00 MHz (/20)
+ *         5'd7 = TCK = 9.09 MHz (/22)  5'd8 = TCK = 8.33
+ *        MHz (/24)  5'd9 = TCK = 7.14 MHz (/28)  5'd10
+ *        = TCK = 6.25 MHz (/32)  5'd11 = TCK = 5.00 MHz
+ *        (/40)  5'd12 = TCK = 4.00 MHz (/50)  5'd13 =
+ *        TCK = 3.00 MHz (/66)  5'd14 = TCK = 2.00 MHz (/100)
+ *         5'd15 = TCK = 1.00 MHz (/200)  5'd16 = TCK
+ *        = 0.50 MHz (/400)
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved2 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param cfg_config_ctl </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> 0,others,illegal=Board Test Mode  1=MTC Internal
+ *        Test Mode - Not Supported in AXM  2=MTC External
+ *        Mode (AXM Included) - Not Supported in AXM  3=MTC
+ *        External Mode (AXM NOT Included)  4=MTC System Test
+ *        Mode (AXM Included) - Not Supported in AXM  5=MTC
+ *        System Test Mode (AXM NOT Included)  Note: The MTC
+ *        hardware inhibits entering modes identifed as Not
+ *        Supported when mtc_axm_selftst_disable control bit
+ *        = 1.  If a Not Supported mode is programmed the
+ *        device will default to the Board Test Mode.
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:16;
+	unsigned mtc_mpu_tdo_inactive_en:1;
+	unsigned loop_en:1;
+	unsigned single_step_en:1;
+	unsigned start_stopn:1;
+	unsigned reserved1:3;
+	unsigned rate_sel:5;
+	unsigned reserved2:1;
+	unsigned cfg_config_ctl:3;
+#else				/* Little Endian */
+	unsigned cfg_config_ctl:3;
+	unsigned reserved2:1;
+	unsigned rate_sel:5;
+	unsigned reserved1:3;
+	unsigned start_stopn:1;
+	unsigned single_step_en:1;
+	unsigned loop_en:1;
+	unsigned mtc_mpu_tdo_inactive_en:1;
+	unsigned reserved0:16;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t
+ *  @brief MTC Config 1 Register
+ *  @details TDO Capture and TCK Gapped Clock Control Signals
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param record_tdo_in_shift_ir_state </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *   <td width="30%"> 1'b1=Capture TDI Input data when in shift-IR state,
+ *         1'b0=Don't Capture data in shift-IR state.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param record_tdo_in_shift_dr_state </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> 1'b1=Capture TDI Input data when in shift-DR state,
+ *         1'b0=Don't Capture data in shift-DR state.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param sw_gate_tck_test_logic_reset </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> 1'b1=Gap TCK output clock in Test-Logic-Reset State
+ *        and start_stopn = STOP(1'b0) Only;  1'b0=Don't Gap
+ *        TCK clock
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param sw_gate_tck </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> 1'b1=Gap TCK output clock in all TAPC states;  1'b0=Don't
+ *        Gap TCK clock
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:26;
+	unsigned record_tdo_in_shift_ir_state:1;
+	unsigned record_tdo_in_shift_dr_state:1;
+	unsigned reserved1:2;
+	unsigned sw_gate_tck_test_logic_reset:1;
+	unsigned sw_gate_tck:1;
+#else				/* Little Endian */
+	unsigned sw_gate_tck:1;
+	unsigned sw_gate_tck_test_logic_reset:1;
+	unsigned reserved1:2;
+	unsigned record_tdo_in_shift_dr_state:1;
+	unsigned record_tdo_in_shift_ir_state:1;
+	unsigned reserved0:26;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t
+ *  @brief MTC Status 1 Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_record_ram_bit_counter </td>
+ *     <td width="20%" align="center"> 14 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Number of Valid Bits in the TDO capture memory </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_record_ram_last_addr </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *   <td width="30%"> Last address within the TDO capture memory that contains
+ *        valid data.  Addresses are filled started at bit
+ *        location 0 (MSB) -> 31(LSB); address 1, bit 0 -> 31,
+ *        ...
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param prgm_mem_rd_addr </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Next Address to be read from program memory  In
+ *        the pause state this address should be written with
+ *        the next task to be processed
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:2;
+	unsigned tdo_record_ram_bit_counter:14;
+	unsigned tdo_record_ram_last_addr:8;
+	unsigned prgm_mem_rd_addr:8;
+#else				/* Little Endian */
+	unsigned prgm_mem_rd_addr:8;
+	unsigned tdo_record_ram_last_addr:8;
+	unsigned tdo_record_ram_bit_counter:14;
+	unsigned reserved0:2;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t
+ *  @brief MTC Status 2 Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_cmpl_enablen </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *   <td width="30%"> 1'b0=Disable MTC Block from Driving JTAG primary IO,
+ *         1'b1=Allow cfg_config_ctl[2:0] register to select
+ *        the mode of the MTC block.  Note: Control signal
+ *        from primary device input pin.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_axm_selftst_disable </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> 1'b1=Disable all MTC configuration modes that allow
+ *        access to the internal JTC controller.  1'b0=Allow
+ *        all modes.  Note: Control signal from internal EFUSE
+ *        module.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *     <td width="20%" align="center"> 18 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_task_error </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 17 </td>
+ *   <td width="30%"> Fatal Error Detected while Processing a Task resulting
+ *        in the MTC block halting.  Once the program is fixed
+ *        a SW reset is needed to restart the block.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_gen_state_error </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Fatal Error Detected while Processing a Task resulting
+ *        in the MTC block halting.  Once the program is fixed
+ *        a SW reset is needed to restart the block.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 15 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftir_tck_off </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 14 </td>
+ *   <td width="30%"> TAPC paused in pause-IR state with the TCK clock off
+ *        to allow reloading of TESTGEN memory with more instruction
+ *        data. The one-shot cont_after_pause, single_step or
+ *        the sw_reset register must be written to exit this
+ * state. pause_in_shiftir
+ *               = (curr_task_load_jtag_instr_reg_and_pause_in_pause_ir
+ * | curr_task_load_jtag_instr_reg_continue_from_pause_ir
+ * | curr_task_load_jtag_instr_reg_continue_from_pause_ir_and_stop_in_pause_ir)
+ *        && curr_tapc_pause_IR) & curr_task_gap_tck_en;
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftdr_tck_off </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> TAPC paused in pause-DR state with the TCK clock off
+ *        to allow reloading of TESTGEN memory with more data.
+ *        The one-shot cont_after_pause, single_step or the
+ *        sw_reset register must be written to exit this state.
+ *        pause_in_shiftdr = (curr_task_load_jtag_data_reg_and_pause_in_pause_dr
+ *        | curr_task_load_jtag_data_reg_continue_from_pause_dr
+ *  | curr_task_load_jtag_data_reg_continue_from_pause_dr_and_stop_in_pause_dr)
+ *        && curr_tapc_pause_DR) & curr_task_gap_tck_en;
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_run_test_idle_tck_off </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *   <td width="30%"> TESTGEN State Machine is Paused in the Run-Test/Idle
+ *        state because TCK clock is gapped.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_test_logic_reset_tck_off </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 11 </td>
+ *   <td width="30%"> TESTGEN State Machine is Paused in the Test-Logic-Reset
+ *        state because TCK clock is gapped.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param testgen_state_machine_paused </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 10 </td>
+ *   <td width="30%"> TESTGEN state machine is paused - valid in single
+ *        step mode and pause modes
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 9 </td>
+ *   <td width="30%"> TAPC paused in pause-IR state to allow reloading of
+ *        TESTGEN memory with more instruction data.  The
+ *        one-shot cont_after_pause, single_step or the sw_reset
+ *        register must be written to exit this state.  pause_in_shiftir
+ *        =  (curr_task_load_jtag_instr_reg_and_pause_in_pause_ir
+ *        | curr_task_load_jtag_instr_reg_continue_from_pause_ir
+ * | curr_task_load_jtag_instr_reg_continue_from_pause_ir_and_stop_in_pause_ir)
+ *        && curr_tapc_pause_IR);
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftdr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *   <td width="30%"> TAPC paused in pause-DR state to allow reloading of
+ *        TESTGEN memory with more data.  The one-shot cont_after_pause,
+ *        single_step or the sw_reset register must be written
+ *   to exit this state.  pause_in_shiftdr
+*           =  (curr_task_load_jtag_data_reg_and_pause_in_pause_dr
+ *        | curr_task_load_jtag_data_reg_continue_from_pause_dr
+ *  | curr_task_load_jtag_data_reg_continue_from_pause_dr_and_stop_in_pause_dr)
+ *        && curr_tapc_pause_DR);
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_inst_i </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Current task value. </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved2 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_end_of_test </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Test Finished </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_pause_in_run_test_idle_state </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Pause Bit </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param start_stopn </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Busy Bit </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned mtc_cmpl_enablen:1;
+	unsigned mtc_axm_selftst_disable:1;
+	unsigned reserved0:12;
+	unsigned nxt_task_error:1;
+	unsigned tst_gen_state_error:1;
+	unsigned reserved1:1;
+	unsigned pause_in_shiftir_tck_off:1;
+	unsigned pause_in_shiftdr_tck_off:1;
+	unsigned pause_in_run_test_idle_tck_off:1;
+	unsigned pause_in_test_logic_reset_tck_off:1;
+	unsigned testgen_state_machine_paused:1;
+	unsigned pause_in_shiftir:1;
+	unsigned pause_in_shiftdr:1;
+	unsigned curr_task_inst_i:4;
+	unsigned reserved2:1;
+	unsigned curr_task_end_of_test:1;
+	unsigned curr_task_pause_in_run_test_idle_state:1;
+	unsigned start_stopn:1;
+#else				/* Little Endian */
+	unsigned start_stopn:1;
+	unsigned curr_task_pause_in_run_test_idle_state:1;
+	unsigned curr_task_end_of_test:1;
+	unsigned reserved2:1;
+	unsigned curr_task_inst_i:4;
+	unsigned pause_in_shiftdr:1;
+	unsigned pause_in_shiftir:1;
+	unsigned testgen_state_machine_paused:1;
+	unsigned pause_in_test_logic_reset_tck_off:1;
+	unsigned pause_in_run_test_idle_tck_off:1;
+	unsigned pause_in_shiftdr_tck_off:1;
+	unsigned pause_in_shiftir_tck_off:1;
+	unsigned reserved1:1;
+	unsigned tst_gen_state_error:1;
+	unsigned nxt_task_error:1;
+	unsigned reserved0:12;
+	unsigned mtc_axm_selftst_disable:1;
+	unsigned mtc_cmpl_enablen:1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t
+ *  @brief MTC EXECUTE Register - One-Shot Registers
+ *  @details Self Clearing Bits
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 27 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_flush_capture_data </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Write to 1 to force the MTC TDO CAPTURE state machine
+ *        to write any remaining data to memory. This signal
+ *        would be written before the tdo_capture_reset bit
+ *        is set.  Self clearing bit.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_capture_reset </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Write to 1 to reset the MTC TDO CAPTURE state machine.
+ *        All variables set to zero (memory write address, tdo
+ *        capture bit count, etc).  Self clearing bit.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param sw_reset </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Write to 1 to reset the MTC TESTGEN, MTC TDO CAPTURE
+ *        state machines and to recover from the state machine
+ *        haulting due to a command error.  Self clearing
+ *        bit.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param cont_after_pause </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Write to 1 to allow the MTC TESTGEN state machine
+ *        to continue from the pause-IR or pause-DR states.
+ *         Self clearing bit.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param single_step </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Write to 1 to allow the MTC_TESTGEN state machine
+ *        to process the next command.  In the single step
+ *        mode the state machine will stop after each task is
+ *        processed.  Self clearing bit.
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:27;
+	unsigned tdo_flush_capture_data:1;
+	unsigned tdo_capture_reset:1;
+	unsigned sw_reset:1;
+	unsigned cont_after_pause:1;
+	unsigned single_step:1;
+#else				/* Little Endian */
+	unsigned single_step:1;
+	unsigned cont_after_pause:1;
+	unsigned sw_reset:1;
+	unsigned tdo_capture_reset:1;
+	unsigned tdo_flush_capture_data:1;
+	unsigned reserved0:27;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t
+ *  @brief MTC MEM Init Register
+ *  @details Registers to Control Initializing the TDO Capture and TESTPROG memories
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 21 </td>
+ *     <td width="20%" align="center"> 11 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_capture_mem_ini_value </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 10 </td>
+ *   <td width="30%"> Memory init value for capture memory </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_capture_mem_do_mem_init </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 9 </td>
+ *   <td width="30%"> Do memory initialization. When set, the capture memory
+ *        is initialized to either zero or one depending
+ *        on tdo_capture_mem_ini_value value by hardware. This
+ *        bit clears itself one cycle after being set
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_capture_mem_init_done </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *   <td width="30%"> Memory initialization done. When set, the program
+ *        memory has been initialized to zero or one by hardware
+ *        following setting the tst_prgm_mem_do_mem_init bit
+ *        and tst_prgm_mem_ini_value of this register.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_prgm_mem_ini_value </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Memory init value for program memory </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_prgm_mem_do_mem_init </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Do memory initialization. When set, the program memory
+ *        is initialized to either all zero or ones depending
+ *        on tst_prgm_mem_ini_value value by hardware. This
+ *        bit clears itself one cycle after being set
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_prgm_mem_init_done </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Memory initialization done. When set, the program
+ *        memory has been initialized to zero or one by hardware
+ *        following setting  the tst_prgm_mem_do_mem_init
+ *        bit and tst_prgm_mem_ini_value of this register.
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:21;
+	unsigned tdo_capture_mem_ini_value:1;
+	unsigned tdo_capture_mem_do_mem_init:1;
+	unsigned tdo_capture_mem_init_done:1;
+	unsigned reserved1:5;
+	unsigned tst_prgm_mem_ini_value:1;
+	unsigned tst_prgm_mem_do_mem_init:1;
+	unsigned tst_prgm_mem_init_done:1;
+#else				/* Little Endian */
+	unsigned tst_prgm_mem_init_done:1;
+	unsigned tst_prgm_mem_do_mem_init:1;
+	unsigned tst_prgm_mem_ini_value:1;
+	unsigned reserved1:5;
+	unsigned tdo_capture_mem_init_done:1;
+	unsigned tdo_capture_mem_do_mem_init:1;
+	unsigned tdo_capture_mem_ini_value:1;
+	unsigned reserved0:21;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t
+ *  @brief MTC MEM Init Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param disable_ecc_mtc_tst_prgm_mem </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> This bit disables the ECC correction for mtc_tst_prgm_mem
+ *        memory.
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param disable_ecc_mtc_tdo_record_mem </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ * <td width="30%"> This bit disables the ECC correction for mtc_tdo_record_mem
+ *        memory.
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t {
+
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:30;
+	unsigned disable_ecc_mtc_tst_prgm_mem:1;
+	unsigned disable_ecc_mtc_tdo_record_mem:1;
+#else				/* Little Endian */
+	unsigned disable_ecc_mtc_tdo_record_mem:1;
+	unsigned disable_ecc_mtc_tst_prgm_mem:1;
+	unsigned reserved0:30;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t
+ *  @brief MTC MEM Invert Enable ECC Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_invert_en_mtc_tst_prgm_mem </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> ECC invert enable for mtc_tst_prgm_mem memory. </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_invert_en_tc_tdo_record_mem </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> ECC invert enable for mtc_tdo_record memory. </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:30;
+	unsigned ecc_invert_en_mtc_tst_prgm_mem:1;
+	unsigned ecc_invert_en_tc_tdo_record_mem:1;
+#else				/* Little Endian */
+	unsigned ecc_invert_en_tc_tdo_record_mem:1;
+	unsigned ecc_invert_en_mtc_tst_prgm_mem:1;
+	unsigned reserved0:30;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t
+ *  @brief MTC MEM Invert ECC Register
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 25 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_invert_reg </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Each memory type uses appropriate number of bits in
+ *        this field starting from right to left.   Set one
+ *        bit to cause a single bit error, two bits to cause
+ *        a double bit error.
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:25;
+	unsigned ecc_invert_reg:7;
+#else				/* Little Endian */
+	unsigned ecc_invert_reg:7;
+	unsigned reserved0:25;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t
+ *  @brief MTC Debug0 Register
+ *  @details DEBUG0: Current Task Values
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_testgen_tdo_inactive_enb </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *   <td width="30%"> When mtc_mpu_tdo_inactive_en control signal is active
+ *        (1'b1) this signal is used to control the TDO output
+ *        buffer tri-state control input.  1'b1 = TDO Output
+ *        Buffer Active;  1'b0 = TDO Output Buffer Inactive
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_gap_tck_en </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> 1'b1 = Gap TCK clock in end state;  1'b0 = Don't
+ *        Gap TCK clock in end state
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_tck_ctl_i </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 29 </td>
+ *   <td width="30%"> Current TASK TCK Control Value </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_end_state_ctl_i </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 28 </td>
+ *   <td width="30%"> 1'b1 = Start Next Command from the Select-DR-Scan
+ *        State (Clock cannot be stopped)  1'b0 = Go to Run-test/Idle
+ *        State - Pause only if Gap TCK Clock active
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_ctl_i </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 24 </td>
+ *   <td width="30%"> Current Task control values </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *     <td width="20%" align="center"> 21 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_tstgen_tdi_cnt30 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Next Shift Cnt value </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved2 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param task_sub_state </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *   <td width="30%"> TESTGEN state Machine subtask counter </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved3 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_task_inst_i </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Next Task Command Value </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t {
+
+#ifdef NCP_BIG_ENDIAN
+	unsigned mtc_testgen_tdo_inactive_enb:1;
+	unsigned curr_task_gap_tck_en:1;
+	unsigned curr_task_tck_ctl_i:1;
+	unsigned curr_task_end_state_ctl_i:1;
+	unsigned reserved0:2;
+	unsigned curr_task_ctl_i:2;
+	unsigned reserved1:3;
+	unsigned nxt_tstgen_tdi_cnt30:5;
+	unsigned reserved2:4;
+	unsigned task_sub_state:4;
+	unsigned reserved3:4;
+	unsigned nxt_task_inst_i:4;
+#else				/* Little Endian */
+	unsigned nxt_task_inst_i:4;
+	unsigned reserved3:4;
+	unsigned task_sub_state:4;
+	unsigned reserved2:4;
+	unsigned nxt_tstgen_tdi_cnt30:5;
+	unsigned reserved1:3;
+	unsigned curr_task_ctl_i:2;
+	unsigned reserved0:2;
+	unsigned curr_task_end_state_ctl_i:1;
+	unsigned curr_task_tck_ctl_i:1;
+	unsigned curr_task_gap_tck_en:1;
+	unsigned mtc_testgen_tdo_inactive_enb:1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t
+ *  @brief MTC Debug1 Register
+ *  @details DEBUG1: Current TASK Being Processed
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_no_operation </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *<td width="30%"> Current task being processed is No Operation(4'b0000) </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_test_reset_1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> Current task being processed is Test reset 1 (TRSTZ
+ *        low for x TCK cycles - 4'b0001)
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_test_reset_2 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 29 </td>
+ *   <td width="30%"> Current task being processed is Test reset 2 (TMS
+ *        high for x TCK cycles) - 4'b0010
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_load_jtag_inst_reg </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 28 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG instruction
+ *        register
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_load_jtag_data_reg </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 27 </td>
+ *<td width="30%"> Current task being processed is Load JTAG data register </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_mtc_reserved_task_id_5 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *   <td width="30%"> Reserved Task value - Illegal - 4'b0101 </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_mtc_reserved_task_id_6 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 25 </td>
+ *   <td width="30%"> Reserved Task value - Illegal - 4'b0110 </td>
+ * </tr>
+ *   <tr>
+ * <td width="30%">
+ * @param curr_task_wait_in_run_test_idle_state_xtck_cycles </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 24 </td>
+ *   <td width="30%"> Current task being processed is Wait in Run-Test-Idle
+ *        state a number of TCK cycles - 4'b1010
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_pause_in_run_test_idle_state </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 23 </td>
+ *   <td width="30%"> Current task being processed is Pause in Run-Test-Idle
+ *        State - 4'b1011
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_end_of_test </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 22 </td>
+ *<td width="30%"> Current task being processed is End of Test - 4'b1100 </td>
+ * </tr>
+ *   <tr>
+ *<td width="30%"> @param
+ *   curr_task_load_jtag_data_reg_and_pause_in_pause_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 21 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG Data Register
+ *        and pause in pause-DR state - 4'b0111
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param
+ *  curr_task_load_jtag_data_reg_continue_from_pause_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 20 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG Data Register
+ *        (continue from pause-DR state) - 4'b1000
+ *   </td>
+ * </tr>
+ *   <tr>
+ * <td width="30%"> @param
+*curr_task_load_jtag_data_reg_continue_from_pause_dr_and_stop_in_pause_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 19 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG Data Register
+ *        (continue from pause-DR state and end in pause-DR
+ *        state - 4'b1001
+ *   </td>
+ * </tr>
+ *   <tr>
+ *<td width="30%"> @param
+ *  curr_task_load_jtag_inst_reg_and_pause_in_pause_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 18 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG Instruction
+ *        Register and pause in pause-IR state - 4'b1101
+ *   </td>
+ * </tr>
+ *   <tr>
+ * <td width="30%"> @param
+ *  curr_task_load_jtag_inst_reg_continue_from_pause_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 17 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG Instruction
+ *        Register (continue from pause-IR state) - 4'b1110
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param
+*curr_task_load_jtag_inst_reg_continue_from_pause_ir_and_stop_in_pause_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Current task being processed is Load JTAG Instruction
+ *        Register (continue from pause-IR state and end in
+ *        pause-IR state - 4'b1111
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_inst_i </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *   <td width="30%"> Value of current task being processed </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param prgm_mem_rd_addr </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Address of memory location to be read from program
+ *        memory
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned curr_task_no_operation:1;
+	unsigned curr_task_test_reset_1:1;
+	unsigned curr_task_test_reset_2:1;
+	unsigned curr_task_load_jtag_inst_reg:1;
+	unsigned curr_task_load_jtag_data_reg:1;
+	unsigned curr_task_mtc_reserved_task_id_5:1;
+	unsigned curr_task_mtc_reserved_task_id_6:1;
+	unsigned curr_task_wait_in_run_test_idle_state_xtck_cycles:1;
+	unsigned curr_task_pause_in_run_test_idle_state:1;
+	unsigned curr_task_end_of_test:1;
+	unsigned curr_task_load_jtag_data_reg_and_pause_in_pause_dr:1;
+	unsigned curr_task_load_jtag_data_reg_continue_from_pause_dr:1;
+	unsigned stop_in_pause_dr:1;
+	unsigned curr_task_load_jtag_inst_reg_and_pause_in_pause_ir:1;
+	unsigned curr_task_load_jtag_inst_reg_continue_from_pause_ir:1;
+	unsigned stop_in_pause_ir:1;
+	unsigned reserved0:4;
+	unsigned curr_task_inst_i:4;
+	unsigned prgm_mem_rd_addr:8;
+#else				/* Little Endian */
+	unsigned prgm_mem_rd_addr:8;
+	unsigned curr_task_inst_i:4;
+	unsigned reserved0:4;
+	unsigned stop_in_pause_ir:1;
+	unsigned curr_task_load_jtag_inst_reg_continue_from_pause_ir:1;
+	unsigned curr_task_load_jtag_inst_reg_and_pause_in_pause_ir:1;
+	unsigned stop_in_pause_dr:1;
+	unsigned curr_task_load_jtag_data_reg_continue_from_pause_dr:1;
+	unsigned curr_task_load_jtag_data_reg_and_pause_in_pause_dr:1;
+	unsigned curr_task_end_of_test:1;
+	unsigned curr_task_pause_in_run_test_idle_state:1;
+	unsigned curr_task_wait_in_run_test_idle_state_xtck_cycles:1;
+	unsigned curr_task_mtc_reserved_task_id_6:1;
+	unsigned curr_task_mtc_reserved_task_id_5:1;
+	unsigned curr_task_load_jtag_data_reg:1;
+	unsigned curr_task_load_jtag_inst_reg:1;
+	unsigned curr_task_test_reset_2:1;
+	unsigned curr_task_test_reset_1:1;
+	unsigned curr_task_no_operation:1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t
+ *  @brief MTC Debug2 Register
+ *  @details Current TAPC
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_update_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *   <td width="30%"> Current TAPC State is UPDATE-IR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_exit2_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> Current TAPC State is EXIT2-IR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_pause_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 29 </td>
+ *   <td width="30%"> Current TAPC State is PAUSE-IR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_exit1_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 28 </td>
+ *   <td width="30%"> Current TAPC State is EXIT1-IR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_shift_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 27 </td>
+ *   <td width="30%"> Current TAPC State is SHIFT-IR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_capture_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *   <td width="30%"> Current TAPC State is CAPTURE-IR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_update_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 25 </td>
+ *   <td width="30%"> Current TAPC State is UPDATE-DR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_exit2_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 24 </td>
+ *   <td width="30%"> Current TAPC State is EXIT2-DR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_pause_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 23 </td>
+ *   <td width="30%"> Current TAPC State is PAUSE-DR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_exit1_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 22 </td>
+ *   <td width="30%"> Current TAPC State is EXIT1-DR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_shift_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 21 </td>
+ *   <td width="30%"> Current TAPC State is SHIFT-DR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_capture_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 20 </td>
+ *   <td width="30%"> Current TAPC State is CAPTURE-DR </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_select_ir_scan </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 19 </td>
+ *   <td width="30%"> Current TAPC State is SELECT-IR-SCAN </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_select_dr_scan </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 18 </td>
+ *   <td width="30%"> Current TAPC State is SELECT-DR-SCAN </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_run_test_idle </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 17 </td>
+ *   <td width="30%"> Current TAPC State is RUN-TEST_IDLE </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_tapc_test_logic_reset </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Current TAPC State is TEST-LOGIC-RESET </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tapc_state </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Current TAPC state value </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned curr_tapc_update_ir:1;
+	unsigned curr_tapc_exit2_ir:1;
+	unsigned curr_tapc_pause_ir:1;
+	unsigned curr_tapc_exit1_ir:1;
+	unsigned curr_tapc_shift_ir:1;
+	unsigned curr_tapc_capture_ir:1;
+	unsigned curr_tapc_update_dr:1;
+	unsigned curr_tapc_exit2_dr:1;
+	unsigned curr_tapc_pause_dr:1;
+	unsigned curr_tapc_exit1_dr:1;
+	unsigned curr_tapc_shift_dr:1;
+	unsigned curr_tapc_capture_dr:1;
+	unsigned curr_tapc_select_ir_scan:1;
+	unsigned curr_tapc_select_dr_scan:1;
+	unsigned curr_tapc_run_test_idle:1;
+	unsigned curr_tapc_test_logic_reset:1;
+	unsigned reserved0:12;
+	unsigned tapc_state:4;
+#else				/* Little Endian */
+	unsigned tapc_state:4;
+	unsigned reserved0:12;
+	unsigned curr_tapc_test_logic_reset:1;
+	unsigned curr_tapc_run_test_idle:1;
+	unsigned curr_tapc_select_dr_scan:1;
+	unsigned curr_tapc_select_ir_scan:1;
+	unsigned curr_tapc_capture_dr:1;
+	unsigned curr_tapc_shift_dr:1;
+	unsigned curr_tapc_exit1_dr:1;
+	unsigned curr_tapc_pause_dr:1;
+	unsigned curr_tapc_exit2_dr:1;
+	unsigned curr_tapc_update_dr:1;
+	unsigned curr_tapc_capture_ir:1;
+	unsigned curr_tapc_shift_ir:1;
+	unsigned curr_tapc_exit1_ir:1;
+	unsigned curr_tapc_pause_ir:1;
+	unsigned curr_tapc_exit2_ir:1;
+	unsigned curr_tapc_update_ir:1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t
+ *  @brief MTC Debug3 Register
+ *  @details TDO Data
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_tdi_shift_data_d </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *   <td width="30%"> TDO value output on the next falling edge of the TCK
+ *        clock - nxt_tdi_shift_data_d[0]
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_tdi_shift_data </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Next Data to be shifted out </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned nxt_tdi_shift_data_d:1;
+	unsigned reserved0:1;
+	unsigned nxt_tdi_shift_data:30;
+#else				/* Little Endian */
+	unsigned nxt_tdi_shift_data:30;
+	unsigned reserved0:1;
+	unsigned nxt_tdi_shift_data_d:1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t
+ *  @brief MTC Debug4 Register
+ *  @details Next Task Value
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_task_inst_i </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Next TASK to be processed </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t {
+	unsigned int nxt_task_inst_i;
+};
+
+/*! @struct ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t
+ *  @brief MTC Debug5 Register
+ *  @details Shift Count Value
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param delay_shift_cnt </td>
+ *     <td width="20%" align="center"> 26 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Data shift value </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:6;
+	unsigned delay_shift_cnt:26;
+#else				/* Little Endian */
+	unsigned delay_shift_cnt:26;
+	unsigned reserved0:6;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t
+ *  @brief MTC Test Program Memory
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_prgm </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> TESTGEN program memory  Task1 Format: [31:30]=2'b10,
+ *        [29]=TCK Action, [28]=0, [27:4]=Unused, [3:0]=Inst
+ *        Code  Task2 Format: [31:30]=2'b10, [29:16]=Not Used,
+ *        [15:4]=TCK Cycles., [3:0]=Inst Code  Task3 Format:
+ *        [31:30]=2'b10, [29:4]=TCK Cycles., [3:0]=Inst Code
+ *         Task4 Format_1: [31:30]=2'b11, [29]=TCK Action,
+ *        [28]=End State, [27:16]=Data Shift,  [15:4]=Inst
+ *        Shift, [3:0]=Inst Code  Task4 Format_2: [31:30]=2'b01,
+ *        [29:0]=TDI Data (more data to Follow).  Task4 Format_3:
+ *        [31:30]=2'b00, [29:0]=TDI Data (LAST data).
+ *        TASK defintions:Value:Description:TCK [29]:End-State
+ *        [28]:Task Format:One-Shot used to release from PAUSE
+ *        state  4'b0000:	No operation - Should not be used
+ *        in programs.:NA:NA:1:NO  4'b0001:	Generate test
+ *        reset 1 (TRSTZ low for x TCK cycles):NA:NA:2:NO
+ *        4'b0010:	Generate test reset 2 (TMS high for x TCK
+ *        cycles):NA:NA:2:NO  4'b0011:	Load JTAG instruction
+ *        register:YES:YES:4:YES  4'b0100:	Load JTAG data
+ *        register:YES:YES:4:YES  4'b0101:	Reserved State:-:-:-:-
+ *         4'b0110:	Reserved State:-:-:-:-  4'b0111:	Load
+ *        JTAG data register and pause in pause-dr:YES:NA:4:YES
+ *         4'b1000:	Load JTAG data register (continue from
+ *        pause-dr):YES:YES:4:YES  4'b1001:	Load JTAG data
+ *        register (continue from pause-dr and stop in pause-dr):
+ *                  YES:YES:4:YES
+ *         4'b1010:	Wait in Run-Test-Idle state a number of
+ *        TCK cycles:NA:NA:3:NO  4'b1011:	Pause in Run-Test-Idle
+ *        state:YES:0:1:YES  4'b1100:	End of test:YES:0:1:NO
+ *         4'b1101:	Load JTAG instruction register and pause
+ *        in pause-ir:YES:NA:4:YES  4'b1110:	Load JTAG instruction
+ *        register (continue from pause-ir):YES:YES:4:YES
+ *        4'b1111:	Load JTAG instruction register (continue
+ *        from pause-ir and stop in pause-ir):YES:YES:4:YES
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t {
+	unsigned int tst_prgm;
+};
+
+/*! @struct ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t
+ *  @brief MTC TDO capture Memory Program Memory
+ *  @details null
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_capture </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> TDI capture memory - Data is right justified when
+ *        written to the memory
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t
+ *
+ */
+
+struct ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t {
+
+	unsigned int tdo_capture;
+};
+
+/*! @struct ncp_axis_mtc_mtc_tstgen_int_status_r_t
+ *  @brief Interrupt Status Register
+ *  @details This register holds interrupt status
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_mtc_tstgen_int_status_r_t\n
+ *   </td>(
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 25 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_record_ram_addr_overflow_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *   <td width="30%"> The TDO Capture memory overflowed. Data is lost when
+ *        this alarm occurs. Status
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_task_error_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
+ *        state machine is halted at that failure.  The errored
+ *        task must be fixed and the sw_reset signal written
+ *        to restart the test. Status
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_gen_state_error_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
+ *        state machine is halted at the failure.  The errored
+ *        task must be fixed and the sw_reset signal written
+ *        to restart the test. Status
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param cont_after_pause_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Active anytime the TESTGEN state machine is paused.
+ *        A write to cont_after_pause or single_step one-shot
+ *        registers will release the state machine from the
+ *        paused state. Status
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftir_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Paused in Shift-IR state Status </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftdr_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Paused in Shift-DR state Status </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_end_of_test_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> In End-of-Test Task Status </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_tstgen_int_status_r_t
+ *
+ */
+
+struct ncp_axis_mtc_mtc_tstgen_int_status_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:25;
+	unsigned tdo_record_ram_addr_overflow_os:1;
+	unsigned nxt_task_error_os:1;
+	unsigned tst_gen_state_error_os:1;
+	unsigned cont_after_pause_os:1;
+	unsigned pause_in_shiftir_os:1;
+	unsigned pause_in_shiftdr_os:1;
+	unsigned curr_task_end_of_test_os:1;
+#else				/* Little Endian */
+	unsigned curr_task_end_of_test_os:1;
+	unsigned pause_in_shiftdr_os:1;
+	unsigned pause_in_shiftir_os:1;
+	unsigned cont_after_pause_os:1;
+	unsigned tst_gen_state_error_os:1;
+	unsigned nxt_task_error_os:1;
+	unsigned tdo_record_ram_addr_overflow_os:1;
+	unsigned reserved0:25;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_mtc_tstgen_int_en_r_t
+ *  @brief Interrupt Enable Register
+ *  @details This register enables interrupts
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_mtc_tstgen_int_en_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 25 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_record_ram_addr_overflow_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *   <td width="30%"> The TDO Capture memory overflowed. Data is lost when
+ *        this alarm occurs. Enable
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_task_error_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
+ *        state machine is halted at that failure.  The errored
+ *        task must be fixed and the sw_reset signal written
+ *        to restart the test. Enable
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_gen_state_error_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
+ *        state machine is halted at the failure.  The errored
+ *        task must be fixed and the sw_reset signal written
+ *        to restart the test. Enable
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param cont_after_pause_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Active anytime the TESTGEN state machine is paused.
+ *        A write to cont_after_pause or single_step one-shot
+ *        registers will release the state machine from the
+ *        paused state. Enable
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftir_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Paused in Shift-IR state Enable </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftdr_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Paused in Shift-DR state Enable </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_end_of_test_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> In End-of-Test Task Enable </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_tstgen_int_en_r_t
+ *
+ */
+
+struct ncp_axis_mtc_mtc_tstgen_int_en_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:25;
+	unsigned tdo_record_ram_addr_overflow_os:1;
+	unsigned nxt_task_error_os:1;
+	unsigned tst_gen_state_error_os:1;
+	unsigned cont_after_pause_os:1;
+	unsigned pause_in_shiftir_os:1;
+	unsigned pause_in_shiftdr_os:1;
+	unsigned curr_task_end_of_test_os:1;
+#else				/* Little Endian */
+	unsigned curr_task_end_of_test_os:1;
+	unsigned pause_in_shiftdr_os:1;
+	unsigned pause_in_shiftir_os:1;
+	unsigned cont_after_pause_os:1;
+	unsigned tst_gen_state_error_os:1;
+	unsigned nxt_task_error_os:1;
+	unsigned tdo_record_ram_addr_overflow_os:1;
+	unsigned reserved0:25;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_mtc_tstgen_int_force_r_t
+ *  @brief Interrupt Force Register
+ *  @details This address is an alias for the Interrupt Status register
+      that allows normal CFG writes (as opposed to the Clear-On-Write-One
+      behavior if the Interrupt Status register address is used).  This
+     allows CFG to set interrupt bits for testing purposes.  Reading this
+    address returns the current value of the Interrupt Status Register.
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_mtc_tstgen_int_force_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 25 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tdo_record_ram_addr_overflow_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *   <td width="30%"> The TDO Capture memory overflowed. Data is lost when
+ *        this alarm occurs. Force
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param nxt_task_error_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 5 </td>
+ *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
+ *        state machine is halted at that failure.  The errored
+ *        task must be fixed and the sw_reset signal written
+ *        to restart the test. Force
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param tst_gen_state_error_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
+ *        state machine is halted at the failure.  The errored
+ *        task must be fixed and the sw_reset signal written
+ *        to restart the test. Force
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param cont_after_pause_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Active anytime the TESTGEN state machine is paused.
+ *        A write to cont_after_pause or single_step one-shot
+ *        registers will release the state machine from the
+ *        paused state. Force
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftir_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Paused in Shift-IR state Force </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param pause_in_shiftdr_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Paused in Shift-DR state Force </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param curr_task_end_of_test_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> In End-of-Test Task Force </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_tstgen_int_force_r_t
+ *
+ */
+
+struct ncp_axis_mtc_mtc_tstgen_int_force_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:25;
+	unsigned tdo_record_ram_addr_overflow_os:1;
+	unsigned nxt_task_error_os:1;
+	unsigned tst_gen_state_error_os:1;
+	unsigned cont_after_pause_os:1;
+	unsigned pause_in_shiftir_os:1;
+	unsigned pause_in_shiftdr_os:1;
+	unsigned curr_task_end_of_test_os:1;
+#else				/* Little Endian */
+	unsigned curr_task_end_of_test_os:1;
+	unsigned pause_in_shiftdr_os:1;
+	unsigned pause_in_shiftir_os:1;
+	unsigned cont_after_pause_os:1;
+	unsigned tst_gen_state_error_os:1;
+	unsigned nxt_task_error_os:1;
+	unsigned tdo_record_ram_addr_overflow_os:1;
+	unsigned reserved0:25;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_mtc_ecc_int_status_r_t
+ *  @brief Interrupt Status Register
+ *  @details This register holds interrupt status
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_mtc_ecc_int_status_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 28 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_mult_tstgen_prgm_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Multi-bit ECC Error in TESTGEN Program Memory Status </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_mult_tdo_capture_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Multi-bit ECC Error in TDO Capture Memory Status </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_single_tstgen_prgm_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ * <td width="30%"> Single-bit ECC Error in TESTGEN Program Memory Status </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_single_tdo_capture_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Single-bit ECC Error in TDO Capture Memory Status </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_ecc_int_status_r_t
+ *
+ */
+
+struct ncp_axis_mtc_mtc_ecc_int_status_r_t {
+
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:28;
+	unsigned ecc_mult_tstgen_prgm_mem_os:1;
+	unsigned ecc_mult_tdo_capture_mem_os:1;
+	unsigned ecc_single_tstgen_prgm_mem_os:1;
+	unsigned ecc_single_tdo_capture_mem_os:1;
+#else				/* Little Endian */
+	unsigned ecc_single_tdo_capture_mem_os:1;
+	unsigned ecc_single_tstgen_prgm_mem_os:1;
+	unsigned ecc_mult_tdo_capture_mem_os:1;
+	unsigned ecc_mult_tstgen_prgm_mem_os:1;
+	unsigned reserved0:28;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_mtc_ecc_int_en_r_t
+ *  @brief Interrupt Enable Register
+ *  @details This register enables interrupts
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_mtc_ecc_int_en_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 28 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_mult_tstgen_prgm_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Multi-bit ECC Error in TESTGEN Program Memory Enable </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_mult_tdo_capture_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Multi-bit ECC Error in TDO Capture Memory Enable </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_single_tstgen_prgm_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ * <td width="30%"> Single-bit ECC Error in TESTGEN Program Memory Enable </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_single_tdo_capture_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Single-bit ECC Error in TDO Capture Memory Enable </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_ecc_int_en_r_t
+ *
+ */
+
+struct ncp_axis_mtc_mtc_ecc_int_en_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:28;
+	unsigned ecc_mult_tstgen_prgm_mem_os:1;
+	unsigned ecc_mult_tdo_capture_mem_os:1;
+	unsigned ecc_single_tstgen_prgm_mem_os:1;
+	unsigned ecc_single_tdo_capture_mem_os:1;
+#else				/* Little Endian */
+	unsigned ecc_single_tdo_capture_mem_os:1;
+	unsigned ecc_single_tstgen_prgm_mem_os:1;
+	unsigned ecc_mult_tdo_capture_mem_os:1;
+	unsigned ecc_mult_tstgen_prgm_mem_os:1;
+	unsigned reserved0:28;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_mtc_ecc_int_force_r_t
+ *  @brief Interrupt Force Register
+ *  @details This address is an alias for the Interrupt Status register
+       that allows normal CFG writes (as opposed to the Clear-On-Write-One
+	behavior if the Interrupt Status register address is used).  This
+	allows CFG to set interrupt bits for testing purposes.  Reading this
+	address returns the current value of the Interrupt Status Register.
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_mtc_ecc_int_force_r_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 28 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_mult_tstgen_prgm_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Multi-bit ECC Error in TESTGEN Program Memory Force </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_mult_tdo_capture_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Multi-bit ECC Error in TDO Capture Memory Force </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ecc_single_tstgen_prgm_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Single-bit ECC Error in TESTGEN Program Memory Force </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @:param ecc_single_tdo_capture_mem_os </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Single-bit ECC Error in TDO Capture Memory Force </td>
+ * </tr>
+ * </table>
+ * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_ecc_int_force_r_t
+ *
+ */
+struct ncp_axis_mtc_mtc_ecc_int_force_r_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned reserved0:28;
+	unsigned ecc_mult_tstgen_prgm_mem_os:1;
+	unsigned ecc_mult_tdo_capture_mem_os:1;
+	unsigned ecc_single_tstgen_prgm_mem_os:1;
+	unsigned ecc_single_tdo_capture_mem_os:1;
+#else				/* Little Endian */
+	unsigned ecc_single_tdo_capture_mem_os:1;
+	unsigned ecc_single_tstgen_prgm_mem_os:1;
+	unsigned ecc_mult_tdo_capture_mem_os:1;
+	unsigned ecc_mult_tstgen_prgm_mem_os:1;
+	unsigned reserved0:28;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 0 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_inv0 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *   <td width="30%"> TDO capture Bit value to monitor within the window
+ *        size inverted
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 29 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_bit0 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> TDO capture Bit position to monitor within the window
+ *        size
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_en </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 15 </td>
+ *   <td width="30%"> AXI Master External Program Memory Mode Enable; 1=enable,
+ *        0=disable
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_cnt </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> TDO capture Monitor Window Size in bits; 0=disable,
+ *        1=monitor first bit captured, ...
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG0_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned      ext_prgm_mem_capture_window_mon_inv0      :  1;
+	unsigned      reserved0                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_mon_bit0      : 13;
+	unsigned      ext_prgm_mem_en                           :  1;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_cnt           : 13;
+#else    /* Little Endian */
+	unsigned      ext_prgm_mem_capture_window_cnt           : 13;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_en                           :  1;
+	unsigned      ext_prgm_mem_capture_window_mon_bit0      : 13;
+	unsigned      reserved0                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_mon_inv0      :  1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 1 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_inv2 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 31 </td>
+ *   <td width="30%"> TDO capture Bit value to monitor within the window
+ *        size inverted
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 29 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_bit2 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> TDO capture Bit position to monitor within the window
+ *        size
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_inv1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 15 </td>
+ *   <td width="30%"> TDO capture Bit value to monitor within the window
+ *        size inverted
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_bit1 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> TDO capture Bit position to monitor within the window
+ *        size
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG1_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned      ext_prgm_mem_capture_window_mon_inv2      :  1;
+	unsigned      reserved0                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_mon_bit2      : 13;
+	unsigned      ext_prgm_mem_capture_window_mon_inv1      :  1;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_mon_bit1      : 13;
+#else    /* Little Endian */
+	unsigned      ext_prgm_mem_capture_window_mon_bit1      : 13;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_mon_inv1      :  1;
+	unsigned      ext_prgm_mem_capture_window_mon_bit2      : 13;
+	unsigned      reserved0                                 :  2;
+	unsigned      ext_prgm_mem_capture_window_mon_inv2      :  1;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 2 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 30 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_cfg_high_wm </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *     <td width="20%" align="center"> 24 </td>
+ *   <td width="30%"> AXI Master Program FIFO High Water Mark </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 22 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_cfg_low_wm </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> AXI Master Program FIFO Low Water Mark </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved2 </td>
+ *     <td width="20%" align="center"> 9 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param cfg_mtc_axi_m_arprot </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> AXI Master Read ARPROT Value </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved3 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG2_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned      reserved0                                 :  2;
+	unsigned      ext_prgm_mem_cfg_high_wm                  :  6;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_cfg_low_wm                   :  6;
+	unsigned      reserved2                                 :  9;
+	unsigned      cfg_mtc_axi_m_arprot                      :  3;
+	unsigned      reserved3                                 :  4;
+#else    /* Little Endian */
+	unsigned      reserved3                                 :  4;
+	unsigned      cfg_mtc_axi_m_arprot                      :  3;
+	unsigned      reserved2                                 :  9;
+	unsigned      ext_prgm_mem_cfg_low_wm                   :  6;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_cfg_high_wm                  :  6;
+	unsigned      reserved0                                 :  2;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 3 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgrm_axi_start_addr_low </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> AXI Master Start Address Low [31:0] </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG3_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t {
+	unsigned  int      ext_prgrm_axi_start_addr_low;
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 4 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgrm_axi_start_addr_high </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> AXI Master Start Address High [63:32] </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG4_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t {
+	unsigned  int      ext_prgrm_axi_start_addr_high;
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 5 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgrm_axi_stop_addr_low </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> AXI Master Stop Address Low [31:0] </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG5_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t {
+	unsigned  int      ext_prgrm_axi_stop_addr_low;
+};
+
+/*! @struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Config 6 Register
+ *  @details Parameters used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgrm_axi_stop_addr_high </td>
+ *     <td width="20%" align="center"> 32 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> AXI Master Stop Address High [63:32] </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_CFG6_REG_ADDR
+ */
+struct  ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t {
+	unsigned  int      ext_prgrm_axi_stop_addr_high;
+};
+
+/*! @struct ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Status 0 Register
+ *  @details MTC Status used in AXI Master External Program Memory Mode
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 17 </td>
+ *     <td width="20%" align="center"> 15 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_axi_m_awvalid </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 14 </td>
+ *   <td width="30%"> AXI Master AWVAILD Signal Value </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_axi_m_awready </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> AXI Master AWREADY Signal Value </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_axi_m_rvalid </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 12 </td>
+ *   <td width="30%"> AXI Master RVAILD Signal Value </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 10 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_shift_dr </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 9 </td>
+ *   <td width="30%"> Capure TDO data in shift-dr state </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_capture_shift_ir </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 8 </td>
+ *   <td width="30%"> Capure TDO data in shift-ir state </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved2 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 7 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_done </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 6 </td>
+ *   <td width="30%"> Value of done signal to syscon block </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param mtc_status </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *     <td width="20%" align="center"> 4 </td>
+ *   <td width="30%"> Value of status signal to syscon block Definition:
+ *        {mtc_done, mtc_status[1:0]}.  -- 3'110: test pass,
+ *         -- 3'100: test failed,  -- 3'1x1: execution error,
+ *         -- 3'0xx: not complete).
+ *   </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved3 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_done </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 2 </td>
+ *   <td width="30%"> Done signal from testgen module </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_execute_error </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *   <td width="30%"> Execution error detected while processing program </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param ext_prgm_mem_comp_pass </td>
+ *     <td width="20%" align="center"> 1 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Composite Pass(1'b1)/Fail(1'b0) value from TDO capture
+ *        module
+ *   </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_STATUS0_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned      reserved0                                 : 17;
+	unsigned      mtc_axi_m_awvalid                         :  1;
+	unsigned      mtc_axi_m_awready                         :  1;
+	unsigned      mtc_axi_m_rvalid                          :  1;
+	unsigned      reserved1                                 :  2;
+	unsigned      ext_prgm_mem_capture_shift_dr             :  1;
+	unsigned      ext_prgm_mem_capture_shift_ir             :  1;
+	unsigned      reserved2                                 :  1;
+	unsigned      mtc_done                                  :  1;
+	unsigned      mtc_status                                :  2;
+	unsigned      reserved3                                 :  1;
+	unsigned      ext_prgm_mem_done                         :  1;
+	unsigned      ext_prgm_mem_execute_error                :  1;
+	unsigned      ext_prgm_mem_comp_pass                    :  1;
+#else    /* Little Endian */
+	unsigned      ext_prgm_mem_comp_pass                    :  1;
+	unsigned      ext_prgm_mem_execute_error                :  1;
+	unsigned      ext_prgm_mem_done                         :  1;
+	unsigned      reserved3                                 :  1;
+	unsigned      mtc_status                                :  2;
+	unsigned      mtc_done                                  :  1;
+	unsigned      reserved2                                 :  1;
+	unsigned      ext_prgm_mem_capture_shift_ir             :  1;
+	unsigned      ext_prgm_mem_capture_shift_dr             :  1;
+	unsigned      reserved1                                 :  2;
+	unsigned      mtc_axi_m_rvalid                          :  1;
+	unsigned      mtc_axi_m_awready                         :  1;
+	unsigned      mtc_axi_m_awvalid                         :  1;
+	unsigned      reserved0                                 : 17;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Status 2 Register
+ *  @details DEBUG: MTC AXI Master External Program Memory Mode - TDO Capture Monitor Debug Counters
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 19 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param window_cnt </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> AXI Monitor Window Count Value </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_STATUS2_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned      reserved0                                 : 19;
+	unsigned      window_cnt                                : 13;
+#else    /* Little Endian */
+	unsigned      window_cnt                                : 13;
+	unsigned      reserved0                                 : 19;
+#endif
+};
+
+/*! @struct ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t
+ *  @brief MTC AXI Status 3 Register
+ *  @details DEBUG:
+ *  <table width="70%" align="center">
+ *  <tr>
+ *   <td colspan="4" align="center">
+ *    struct ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t\n
+ *   </td>
+ *  </tr>
+ *  <tr>
+ *     <td width="30%"><b> Name </b></td>
+ *     <td width="20%" align="center"><b> Width </b></td>
+ *     <td width="20%" align="center"><b> Start Offset </b></td>
+ *     <td width="30%"><b> Description </b></td>
+ *  </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved0 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *     <td width="20%" align="center"> 29 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved2 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 16 </td>
+ *   <td width="30%"> Reserved </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 3 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *   <td width="30%"> Reserved for future use </td>
+ * </tr>
+ *   <tr>
+ *     <td width="30%"> @param reserved1 </td>
+ *     <td width="20%" align="center"> 13 </td>
+ *     <td width="20%" align="center"> 0 </td>
+ *   <td width="30%"> Reserved </td>
+ * </tr>
+ * </table>
+ * Applies to: 5600 --> ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t
+ *
+ * Implemented by:
+ *      MTC_AXI_STATUS3_REG_ADDR
+ */
+struct ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t {
+#ifdef NCP_BIG_ENDIAN
+	unsigned      reserved0                                 :  3;
+	unsigned      reserved1                                 : 13;
+	unsigned      reserved2                                 :  3;
+	unsigned      reserved3                                 : 13;
+#else    /* Little Endian */
+	unsigned      reserved3                                 : 13;
+	unsigned      reserved2                                 :  3;
+	unsigned      reserved1                                 : 13;
+	unsigned      reserved0                                 :  3;
+#endif
+};
+
+/******************************************************/
+/* end of RDL register definitions */
+/******************************************************/
+
+struct mtc_device {
+	struct kref ref;
+	struct platform_device *pdev;
+	unsigned long flags;
+#define FLAG_REGISTERED        0	/* Misc device registered */
+	struct mtc_regs __iomem *regs;
+	u32 __iomem *prgmem;
+	u32 __iomem *tdomem;
+	unsigned int irq;
+	struct miscdevice char_device;
+	unsigned int ext_prgm_mode;
+	u64 ext_strt_addr;
+	u64 ext_stop_addr;
+};
+
+#define miscdev_to_mtc(mdev) container_of(mdev, struct mtc_device, char_device)
+
+/* Called when removed and last reference is released */
+static void mtc_destroy(struct kref *ref);
+
+/**
+ * mtc_dev_open
+ *
+ * Returns 0 for success or negative errno.
+ */
+static int mtc_dev_open(struct inode *inode, struct file *filp)
+{
+	struct miscdevice *misc = filp->private_data;
+	struct mtc_device *dev = miscdev_to_mtc(misc);
+
+	pr_debug("mtc_dev_open(%p)\n", dev);
+	kref_get(&dev->ref);
+	return 0;
+}
+
+/**
+ * mtc_dev_release
+ */
+static int mtc_dev_release(struct inode *inode, struct file *filp)
+{
+	struct miscdevice *misc = filp->private_data;
+	struct mtc_device *dev = miscdev_to_mtc(misc);
+
+	pr_debug("mtc_dev_release(%p)\n", dev);
+	kref_put(&dev->ref, mtc_destroy);
+	return 0;
+}
+
+/**
+ * mtc_dev_read
+ *
+ * Returns number of valid bits read or negative errno.
+ */
+static ssize_t
+mtc_dev_read(struct file *filp, char __user *data, size_t len, loff_t *ppose)
+{
+	struct miscdevice *misc = filp->private_data;
+	struct mtc_device *dev = miscdev_to_mtc(misc);
+	u32 __iomem *ptdo;
+	u32 tdo_size_word, tdo_size_bit;	/* data to be read in words */
+	struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t status1Reg = { 0 };
+	struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1Reg = { 0 };
+	u32 i = 0;
+	char *tmp_data = NULL;
+
+	pr_debug("mtc_dev_read(%u @ %llu)\n", (unsigned int) len, *ppose);
+	ptdo = dev->tdomem;
+
+	/* flush tdo buffer */
+	exec1Reg.tdo_flush_capture_data = 1;
+	dev->regs->execute = *((u32 *) &exec1Reg);
+
+	/* read status 1register */
+	status1Reg =
+	    *((struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t *)
+	      &(dev->regs->status1));
+	tdo_size_bit = status1Reg.tdo_record_ram_bit_counter;
+
+	/* test code for mtc memory sim only */
+	/* tdo_size_bit = 8192; */
+	/* end of test code */
+
+	tdo_size_word = (tdo_size_bit + 31) / 32;
+#ifdef DEBUG
+	pr_debug("mtc_dev_read(), tdo_bit=%d tdo_word=%d\n",
+		 tdo_size_bit, tdo_size_word);
+#endif
+
+	tmp_data = kmalloc(tdo_size_word*4, GFP_KERNEL);
+
+	if (!tmp_data)
+		return -EFAULT;
+
+	memset(tmp_data, 0, tdo_size_word * 4);
+	for (i = 0; i < tdo_size_word*4; i++) {
+#ifdef DEBUG
+		pr_debug("data[%d]=0x%x\n", i, ptdo[i]);
+#endif
+		tmp_data[i] = (ptdo[i/4] & (0xFF << ((i%4) * 8))) >>
+			((i%4) * 8);
+	}
+	/* copy tdo data to user space, always read from location 0
+	   because we reset tdomem after each read */
+	if (copy_to_user((void *)data, tmp_data, tdo_size_word * 4)) {
+		kfree(tmp_data);
+		return -EFAULT;
+	}
+#ifdef DEBUG
+	for (i = 0; i < tdo_size_word*4; i++) {
+		pr_debug("copied data[%d]=0x%x tmp_data=0x%x\n",
+				 i, data[i], tmp_data[i]);
+	}
+#endif
+	kfree(tmp_data);
+
+	/* data sent to user, reset tdo capture buffer */
+	memset(&exec1Reg, 0, sizeof(exec1Reg));
+	exec1Reg.tdo_capture_reset = 1;
+	dev->regs->execute = *((u32 *) &exec1Reg);
+
+	/* return # of bits */
+	return tdo_size_bit;
+}
+
+static ssize_t
+_mtc_axi_dev_write(struct file *filp,
+	      const char __user *data,
+	      size_t len,
+	      loff_t *ppose)
+{
+
+	struct miscdevice *misc = filp->private_data;
+	struct mtc_device *dev = miscdev_to_mtc(misc);
+	u32 __iomem *pprg;
+	u32 *mtc_buf;
+	u32 size, size1, i;	/* size in word */
+
+	pr_debug("mtc_axi_dev_write(%u @ %llu)\n", (unsigned int) len, *ppose);
+
+	size = len / 4;
+	size1 = size;
+
+	mtc_buf = kmalloc(len, GFP_KERNEL);
+	if (!mtc_buf)
+		return -EFAULT;
+
+	/* copy to a local buffer */
+	memset(mtc_buf, 0, len);
+	if (copy_from_user((void *)mtc_buf, (void *)data, len)) {
+		pr_debug("MTC Error write\n");
+		return -EFAULT;
+	}
+
+	/* ioremap the start-stop address range. */
+	pprg = ioremap(dev->ext_strt_addr,
+			(dev->ext_stop_addr-dev->ext_strt_addr));
+	if (!pprg) {
+		/* free the mtc_buf */
+		kfree(mtc_buf);
+		return -EFAULT;
+	}
+
+	for (i = 0; i < size; i++) {
+#ifdef DEBUG
+		pr_debug("i=%d mtc_buf[i]=%d pprg=0x%llx\n",
+			 i, mtc_buf[i], (u64) pprg);
+#endif
+		*pprg = mtc_buf[i];
+		pprg++;
+	}
+
+	/* free mtc_buf */
+	kfree(mtc_buf);
+
+	/* unmap memory */
+	iounmap(pprg);
+
+	return len;
+}
+
+/**
+ * mtc_dev_write
+ *
+ * Returns number of bytes written or negative errno.
+ */
+
+static ssize_t
+mtc_dev_write(struct file *filp,
+	      const char __user *data,
+	      size_t len,
+	      loff_t *ppose)
+{
+
+	struct miscdevice *misc = filp->private_data;
+	struct mtc_device *dev = miscdev_to_mtc(misc);
+	u32 __iomem *pprg;
+	u32 mtc_buf[256];	/* max 256 words */
+	u32 size, size1, isWraparound = 0, i;	/* size in word */
+	struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t status1Reg = { 0 };
+
+	pr_debug("mtc_dev_write(%u @ %llu)\n", (unsigned int) len, *ppose);
+
+	/* If external program memory mode, write to external memory instead
+	of program memory.
+	*/
+	if (dev->ext_prgm_mode == 1)
+		return _mtc_axi_dev_write(filp, data, len, ppose);
+
+	if (len > 1024)
+		return -EINVAL;
+
+	size = len / 4;
+	size1 = size;
+
+#ifdef DEBUG
+	for (i = 0; i < len; i++)
+		pr_debug("input data[%d]=0x%x\n", i, data[i]);
+#endif
+	/* copy to a lcoal buffer */
+	memset(mtc_buf, 0, 1024);
+	if (copy_from_user((void *)mtc_buf, (void *)data, len)) {
+		pr_debug("MTC Error write\n");
+		return -EFAULT;
+	}
+
+#ifdef DEBUG
+	for (i = 0; i < len; i++)
+		pr_debug("after copying: mtc_buf[%d]=0x%x\n", i, mtc_buf[i]);
+#endif
+	/* read status 1register, find the starting write offset */
+	status1Reg =
+	    *((struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t *)
+	      &(dev->regs->status1));
+
+	/* TEST CODE when mtc sim is used */
+	/* status1Reg.prgm_mem_rd_addr = 253; */
+	/* pr_debug("buf offset=%d\n",status1Reg.prgm_mem_rd_addr ); */
+	/*END OF TEST CODE */
+
+	/* find starting location of the write */
+	pprg = dev->prgmem + status1Reg.prgm_mem_rd_addr;
+
+	/* determine if wrap around is needed */
+	if (status1Reg.prgm_mem_rd_addr + size > 256) {
+		isWraparound = 1;
+		/* number of words load from starting location */
+		size1 = 256 - status1Reg.prgm_mem_rd_addr;
+		/*number of words load from location 0 will be size-size1 */
+#ifdef DEBUG
+		pr_debug("Wraparound size=%d, size1=%d size-size1=%d\n", size,
+			 size1, size - size1);
+#endif
+	}
+#ifdef DEBUG
+	pr_debug("Appending buff size1=%d\n", size1);
+#endif
+
+	for (i = 0; i < size1; i++) {
+#ifdef DEBUG
+		pr_debug("i=%d mtc_buf[i]=%d pprg=0x%llx\n",
+			 i, mtc_buf[i], (u64) pprg);
+#endif
+		*pprg = mtc_buf[i];
+		pprg++;
+	}
+
+	/* wraparound, copy the 2nd half */
+	if (isWraparound) {
+		pprg = dev->prgmem;	/* reset write pointer to location 0 */
+#ifdef DEBUG
+		pr_debug("\n\nWraparound buff size=%d\n",
+			 size - size1);
+#endif
+		for (i = 0; i < (size - size1); i++) {
+#ifdef DEBUG
+			pr_debug("i=%d mtc_buf[size1+i]=%d pprg=0x%llx\n", i,
+				 mtc_buf[size1 + i], (u64) pprg);
+#endif
+			*pprg = mtc_buf[size1 + i];
+			pprg++;
+		}
+	}
+
+	return len;
+}
+
+/**
+ * mtc_dev_ioctl
+ *
+ */
+
+static long _mtc_config(struct mtc_device *dev, struct axxia_mtc_cfg_t *pMTCCfg);
+
+static long
+mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct miscdevice *misc = filp->private_data;
+	struct mtc_device *dev = miscdev_to_mtc(misc);
+	long ret = 0;
+	u32 addr, tmp2;
+	unsigned long numByteCopied;
+
+	pr_debug("mtc_dev_ioctl(%#x, %#lx)\n", cmd, arg);
+	switch (cmd) {
+
+	case MTC_DEBUG_OP:
+		numByteCopied =
+		    copy_from_user((void *)&addr, (void *)arg,
+				   sizeof(unsigned int));
+		if (numByteCopied) {
+			pr_debug("MTC Error ioctl\n");
+			return -EFAULT;
+		}
+		tmp2 = *((u32 *) dev->regs + addr / 4);
+
+		if (copy_to_user((void *)arg, &tmp2, sizeof(unsigned int)))
+			return -EFAULT;
+
+		break;
+
+	case MTC_CFG:
+		{
+			struct axxia_mtc_cfg_t mtc_cfg;
+
+			if (copy_from_user
+			    ((void *)&mtc_cfg, (void *)arg, sizeof(mtc_cfg))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			ret = _mtc_config(dev, &mtc_cfg);
+		}
+		break;
+
+	case MTC_SINGLESTEP_ENABLE:
+		{
+			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
+			int single_step;
+
+			if (copy_from_user
+			    ((void *)&single_step, (void *)arg, sizeof(int))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if ((single_step != 0) && (single_step != 1))
+				return -EINVAL;
+
+			cfg0 =
+			    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
+			      &(dev->regs->config0));
+			cfg0.single_step_en = single_step;
+			dev->regs->config0 = *((u32 *) &cfg0);
+#ifdef DEBUG
+			pr_debug(
+			    "MTC_SINGLESTEP_ENABLE: dev->regs->config0=0x%x\n",
+			    dev->regs->config0);
+#endif
+		}
+
+		break;
+
+	case MTC_LOOPMODE_ENABLE:
+		{
+			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
+			int loop_mode;
+
+			if (copy_from_user
+			    ((void *)&loop_mode, (void *)arg, sizeof(int))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if ((loop_mode != 0) && (loop_mode != 1))
+				return -EINVAL;
+
+			cfg0 =
+			    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
+			      &(dev->regs->config0));
+			cfg0.loop_en = loop_mode;
+			dev->regs->config0 = *((u32 *) &cfg0);
+#ifdef DEBUG
+			pr_debug(
+			       "MTC_LOOPMODE_ENABLE dev->regs->config0=0x%x\n",
+			       dev->regs->config0);
+#endif
+		}
+
+		break;
+
+	case MTC_RESET:
+		{
+			struct
+			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
+			exec1.sw_reset = 1;
+			dev->regs->execute = *((u32 *) &exec1);
+#ifdef DEBUG
+			pr_debug("dev->regs->execute=0x%x\n",
+				 dev->regs->execute);
+#endif
+		}
+
+		break;
+
+	case MTC_TCKCLK_GATE:
+		{
+			struct axxia_mtc_tckclk_gate_t tckGate;
+			struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t cfg1 = {0};
+
+			if (copy_from_user
+			    ((void *)&tckGate, (void *)arg, sizeof(tckGate))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if (((tckGate.gate_tck_test_logic_reset != 0)
+			     && (tckGate.gate_tck_test_logic_reset != 1))
+			    || ((tckGate.gate_tck != 0)
+				&& (tckGate.gate_tck != 1)))
+				return -EINVAL;
+
+			cfg1 =
+			    *((struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t *)
+			      &(dev->regs->config1));
+			cfg1.sw_gate_tck_test_logic_reset =
+			    tckGate.gate_tck_test_logic_reset;
+			cfg1.sw_gate_tck = tckGate.gate_tck;
+			dev->regs->config1 = *((u32 *) &cfg1);
+#ifdef DEBUG
+			pr_debug("dev->regs->config1=0x%x\n",
+				 dev->regs->config1);
+#endif
+		}
+
+		break;
+
+	case MTC_STARTSTOP_EXEC:
+		{
+			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
+			int start_stop;
+
+			if (copy_from_user
+			    ((void *)&start_stop, (void *)arg, sizeof(int))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if ((start_stop != 0) && (start_stop != 1))
+				return -EINVAL;
+
+			cfg0 =
+			    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
+			      &(dev->regs->config0));
+			cfg0.start_stopn = start_stop;
+			dev->regs->config0 = *((u32 *) &cfg0);
+#ifdef DEBUG
+			pr_debug("dev->regs->config0=0x%x\n",
+				 dev->regs->config0);
+#endif
+		}
+
+		break;
+
+	case MTC_SINGLESTEP_EXEC:
+		{
+			struct
+			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
+			exec1.single_step = 1;
+			dev->regs->execute = *((u32 *) &exec1);
+			pr_debug("dev->regs->execute=0x%x\n",
+				 dev->regs->execute);
+
+		}
+		break;
+
+	case MTC_CONTINUE_EXEC:
+		{
+			struct
+			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
+			exec1.cont_after_pause = 1;
+			dev->regs->execute = *((u32 *) &exec1);
+			pr_debug("dev->regs->execute=0x%x\n",
+				 dev->regs->execute);
+
+		}
+		break;
+
+	case MTC_READ_STATS:
+		{
+			struct axxia_mtc_stats_regs_t stats;
+
+			stats.statsReg1 = dev->regs->status1;
+			stats.statsReg2 = dev->regs->status2;
+
+			if (copy_to_user((void *)arg, &stats, sizeof(stats)))
+				return -EFAULT;
+
+		}
+		break;
+
+	case MTC_READ_DEBUG:
+		{
+			struct axxia_mtc_debug_regs_t debug;
+
+			debug.debugReg0 = dev->regs->debug0;
+			debug.debugReg1 = dev->regs->debug1;
+			debug.debugReg2 = dev->regs->debug2;
+			debug.debugReg3 = dev->regs->debug3;
+			debug.debugReg4 = dev->regs->debug4;
+			debug.debugReg5 = dev->regs->debug5;
+
+			if (copy_to_user((void *)arg, &debug, sizeof(debug)))
+				return -EFAULT;
+
+		}
+
+		break;
+
+	case MTC_AXI_EXT_PRGM_MEM_ENABLE:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+			struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t cfg0
+							= {0};
+			int ext_prgm_mode;
+
+			if (copy_from_user((void *)&ext_prgm_mode,
+					(void *)arg,
+					sizeof(int))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if ((ext_prgm_mode != 0) && (ext_prgm_mode != 1))
+				return -EINVAL;
+			cfg0 =
+			*((struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config0));
+			cfg0.ext_prgm_mem_en = ext_prgm_mode;
+			dev->regs->axi_config0 = *((u32 *) &cfg0);
+			dev->ext_prgm_mode = ext_prgm_mode;
+#ifdef DEBUG
+			pr_debug(
+			"MTC_AXI_EXT_PRGM_MEM_ENABLE axi_config0=0x%x\n",
+			       dev->regs->axi_config0);
+#endif
+		} else
+			return -EPERM;
+		break;
+
+	case MTC_AXI_CAPT_WINDOW_PARAM_SET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_capt_window_param_t wndparm;
+
+			struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t cfg0
+							= {0};
+			struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t cfg1
+							= {0};
+
+			if (copy_from_user
+			    ((void *)&wndparm, (void *)arg, sizeof(wndparm))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if ((wndparm.captWindowCnt > 0x1FFF) ||
+			     (wndparm.captWindowMonBit0 > 0x1FFF) ||
+			     ((wndparm.captWindowMonInv0 != 1) &&
+				(wndparm.captWindowMonInv0 != 0)) ||
+			     (wndparm.captWindowMonBit1 > 0x1FFF) ||
+			     ((wndparm.captWindowMonInv1 != 1) &&
+				(wndparm.captWindowMonInv1 != 0)) ||
+			     (wndparm.captWindowMonBit2 > 0x1FFF) ||
+			     ((wndparm.captWindowMonInv2 != 1) &&
+				(wndparm.captWindowMonInv2 != 0)))
+				return -EINVAL;
+
+			cfg0 =
+			*((struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config0));
+			cfg1 =
+			*((struct  ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config1));
+
+			cfg0.ext_prgm_mem_capture_window_cnt =
+						wndparm.captWindowCnt;
+			cfg0.ext_prgm_mem_capture_window_mon_bit0 =
+						wndparm.captWindowMonBit0;
+			cfg0.ext_prgm_mem_capture_window_mon_inv0 =
+						wndparm.captWindowMonInv0;
+
+			cfg1.ext_prgm_mem_capture_window_mon_bit1 =
+						wndparm.captWindowMonBit1;
+			cfg1.ext_prgm_mem_capture_window_mon_inv1 =
+						wndparm.captWindowMonInv1;
+			cfg1.ext_prgm_mem_capture_window_mon_bit2 =
+						wndparm.captWindowMonBit2;
+			cfg1.ext_prgm_mem_capture_window_mon_inv2 =
+						wndparm.captWindowMonInv2;
+
+			dev->regs->axi_config0 = *((u32 *) &cfg0);
+			dev->regs->axi_config1 = *((u32 *) &cfg1);
+#ifdef DEBUG
+			pr_debug(
+			"MTC_AXI_CAPT_WINDOW_PARAM_SET cfg0=0x%x cfg1=0x%x\n",
+				 dev->regs->axi_config0,
+				 dev->regs->axi_config1);
+#endif
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_CAPT_WINDOW_PARAM_GET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_capt_window_param_t wndparm;
+			struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t cfg0
+								= {0};
+			struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t cfg1
+								= {0};
+
+			cfg0 =
+			*((struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t *)
+			&(dev->regs->axi_config0));
+			cfg1 =
+			*((struct  ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t *)
+			&(dev->regs->axi_config1));
+
+			wndparm.captWindowCnt	=
+				cfg0.ext_prgm_mem_capture_window_cnt;
+			wndparm.captWindowMonBit0 =
+				cfg0.ext_prgm_mem_capture_window_mon_bit0;
+			wndparm.captWindowMonInv0 =
+				cfg0.ext_prgm_mem_capture_window_mon_inv0;
+
+			wndparm.captWindowMonBit1 =
+				cfg1.ext_prgm_mem_capture_window_mon_bit1;
+			wndparm.captWindowMonInv1 =
+				cfg1.ext_prgm_mem_capture_window_mon_inv1;
+			wndparm.captWindowMonBit2 =
+				cfg1.ext_prgm_mem_capture_window_mon_bit2;
+			wndparm.captWindowMonInv2 =
+				cfg1.ext_prgm_mem_capture_window_mon_inv2;
+
+			if (copy_to_user((void *)arg,
+				&wndparm, sizeof(wndparm)))
+				return -EFAULT;
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_WATER_MARK_SET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_extmem_wm_t wm;
+			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
+								 = {0};
+
+			if (copy_from_user
+			    ((void *)&wm, (void *)arg, sizeof(wm))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if ((wm.highWaterMark > 0x3f) ||
+				(wm.lowWaterMark > 0x3f))
+				return -EINVAL;
+
+			cfg2 =
+			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
+				&(dev->regs->axi_config2));
+
+			/* set the values */
+			cfg2.ext_prgm_mem_cfg_high_wm = wm.highWaterMark;
+			cfg2.ext_prgm_mem_cfg_low_wm = wm.lowWaterMark;
+
+			dev->regs->axi_config2 = *((u32 *) &cfg2);
+#ifdef DEBUG
+			pr_debug("MTC_AXI_WATER_MARK_SET cfg2=0x%x\n",
+					dev->regs->axi_config2);
+#endif
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_WATER_MARK_GET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_extmem_wm_t wm;
+			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
+						 = {0};
+
+
+			cfg2 =
+			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config2));
+
+			wm.highWaterMark = cfg2.ext_prgm_mem_cfg_high_wm;
+			wm.lowWaterMark = cfg2.ext_prgm_mem_cfg_low_wm;
+
+			if (copy_to_user((void *)arg, &wm, sizeof(wm)))
+				return -EFAULT;
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_M_ARPROT_SET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+			int arprot;
+			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
+								 = {0};
+
+			if (copy_from_user
+			    ((void *)&arprot, (void *)arg, sizeof(int))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			if (arprot > 0x7)
+				return -EINVAL;
+
+			cfg2 =
+			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config2));
+
+			/* set the values */
+			cfg2.cfg_mtc_axi_m_arprot = arprot;
+
+			dev->regs->axi_config2 = *((u32 *) &cfg2);
+#ifdef DEBUG
+			pr_debug("MTC_AXI_M_ARPROT_SET cfg2=0x%x\n",
+				dev->regs->axi_config2);
+#endif
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_M_ARPROT_GET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			int arprot;
+			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
+							 = {0};
+
+			cfg2 =
+			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
+			&(dev->regs->axi_config2));
+
+			arprot = cfg2.cfg_mtc_axi_m_arprot;
+
+			if (copy_to_user((void *)arg, &arprot, sizeof(int)))
+				return -EFAULT;
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_MASTER_ADDR_SET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_master_addr_t addr;
+
+			struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t cfg3
+								 = {0};
+			struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t cfg4
+								 = {0};
+			struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t cfg5
+								 = {0};
+			struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t cfg6
+								= {0};
+
+			if (copy_from_user
+			    ((void *)&addr, (void *)arg,
+				sizeof(struct axxia_mtc_axi_master_addr_t))) {
+				pr_debug("MTC Error ioctl\n");
+				return -EFAULT;
+			}
+
+			cfg3 =
+			*((struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config3));
+
+			cfg4 =
+			*((struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config4));
+
+			cfg5 =
+			*((struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config5));
+
+			cfg6 =
+			*((struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config6));
+
+			/* set the values */
+			cfg3.ext_prgrm_axi_start_addr_low = addr.strtAddrLow;
+			cfg4.ext_prgrm_axi_start_addr_high = addr.strtAddrHigh;
+
+			cfg5.ext_prgrm_axi_stop_addr_low = addr.stopAddrLow;
+			cfg6.ext_prgrm_axi_stop_addr_high = addr.stopAddrHigh;
+
+			dev->regs->axi_config3 = *((u32 *) &cfg3);
+			dev->regs->axi_config4 = *((u32 *) &cfg4);
+			dev->regs->axi_config5 = *((u32 *) &cfg5);
+			dev->regs->axi_config6 = *((u32 *) &cfg6);
+
+			dev->ext_strt_addr =
+				(((u64) (addr.strtAddrHigh)) << 32) |
+				(u64)(addr.strtAddrLow);
+
+			dev->ext_stop_addr =
+				 (((u64) (addr.stopAddrHigh)) << 32) |
+				(u64)(addr.stopAddrLow);
+
+#ifdef DEBUG
+			pr_debug(
+			"MTC_AXI_MASTER_ADDR_SET cfg3=0x%x cfg4=0x%x\n",
+				dev->regs->axi_config3,
+				dev->regs->axi_config4);
+
+			pr_debug("cfg5=0x%x cfg6=0x%x\n",
+				dev->regs->axi_config5,
+				dev->regs->axi_config6);
+#endif
+		} else
+			return -EPERM;
+
+		break;
+
+	case MTC_AXI_MASTER_ADDR_GET:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_master_addr_t addr;
+			struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t cfg3
+									 = {0};
+			struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t cfg4
+									 = {0};
+			struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t cfg5
+									 = {0};
+			struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t cfg6
+									 = {0};
+
+			cfg3 =
+			*((struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config3));
+
+			cfg4 =
+			*((struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config4));
+
+			cfg5 =
+			*((struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config5));
+
+			cfg6 =
+			*((struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t *)
+			      &(dev->regs->axi_config6));
+
+			addr.strtAddrLow = cfg3.ext_prgrm_axi_start_addr_low;
+			addr.strtAddrHigh = cfg4.ext_prgrm_axi_start_addr_high;
+
+			addr.stopAddrLow = cfg5.ext_prgrm_axi_stop_addr_low;
+			addr.stopAddrHigh = cfg6.ext_prgrm_axi_stop_addr_high;
+
+			if (copy_to_user((void *)arg, &addr, sizeof(addr)))
+				return -EFAULT;
+		} else {
+			return -EPERM;
+		}
+
+		break;
+
+	case MTC_AXI_READ_STATUS:
+
+		if (of_find_compatible_node(NULL, NULL, "axxia,axm5616") ||
+		   (of_find_compatible_node(NULL, NULL, "axxia,axc6732"))) {
+
+			struct axxia_mtc_axi_status_regs_t status;
+
+			status.axiStatusReg0 = dev->regs->axi_status0;
+			status.axiStatusReg1 = dev->regs->axi_status1;
+			status.axiStatusReg2 = dev->regs->axi_status2;
+			status.axiStatusReg3 = dev->regs->axi_status3;
+
+			if (copy_to_user((void *)arg, &status, sizeof(status)))
+				return -EFAULT;
+		} else {
+			return -EPERM;
+		}
+
+		break;
+
+	default:
+		pr_debug("Invalid ioctl cmd=%d MTC_DEBUG_OP=%u\n",
+			 cmd, (unsigned int)MTC_DEBUG_OP);
+		ret = -EINVAL;
+
+	}
+
+	return ret;
+}
+
+static const struct file_operations mtc_char_ops = {
+	.owner = THIS_MODULE,
+	.open = mtc_dev_open,
+	.release = mtc_dev_release,
+	.llseek = generic_file_llseek,
+	.read = mtc_dev_read,
+	.write = mtc_dev_write,
+	.unlocked_ioctl = mtc_dev_ioctl,
+	.compat_ioctl = mtc_dev_ioctl
+};
+
+static irqreturn_t mtc_isr(int irq_no, void *arg)
+{
+	struct mtc_device *priv = arg;
+	u32 status = readl(&priv->regs->int_status);
+
+	pr_debug("mtc: int status %#x\n", status);
+
+	/* Handle interrupt */
+	/* ... */
+
+	/* Write bits to clear interrupt status */
+	writel(status, &priv->regs->int_status);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * mtc_probe
+ *
+ * Initialize device.
+ */
+static int mtc_probe(struct platform_device *pdev)
+{
+	static struct mtc_device *dev;
+	void __iomem *regs;
+	int rc;
+	u32 *pRegs;
+
+	pr_debug("!!!!MTC: mtc_probe()\n");
+	/* Allocate space for device private data */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		rc = -ENOMEM;
+		goto err;
+	}
+	dev_set_drvdata(&pdev->dev, &dev);
+	kref_init(&dev->ref);
+	dev->pdev = pdev;
+
+	/* Map hardware registers */
+	regs = of_iomap(pdev->dev.of_node, 0);
+	if (!regs) {
+		rc = -EINVAL;
+		goto err;
+	}
+	pRegs = (u32 *) regs;
+#ifdef __MTC_SIMULATION
+	dev->regs = &_mtc_regs;
+	dev->prgmem = _mtc_prgmem;
+	dev->tdomem = _mtc_tdomem;
+
+#else
+	dev->regs = regs;
+	dev->prgmem =  pRegs + MTC_PRGMEM_OFFSET/4;
+	dev->tdomem =  pRegs + MTC_TDOMEM_OFFSET/4;
+#endif
+	/* Attach to IRQ */
+	dev->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	rc = request_irq(dev->irq, mtc_isr, 0, "mtc", &dev);
+	if (rc)
+		goto err;
+
+	/* Initialize hardware */
+	/* ... */
+
+	/*
+	 * Register device client interface
+	 */
+
+	dev->char_device.minor = MISC_DYNAMIC_MINOR;
+	dev->char_device.name = "mtc";
+	dev->char_device.fops = &mtc_char_ops;
+
+	rc = misc_register(&dev->char_device);
+	if (rc)
+		goto err;
+	set_bit(FLAG_REGISTERED, &dev->flags);
+
+	return 0;
+
+ err:
+	if (dev)
+		kref_put(&dev->ref, mtc_destroy);
+	dev_err(&pdev->dev, "Failed to probe device (%d)\n", rc);
+	return rc;
+}
+
+/**
+ * mtc_remove
+ */
+static int mtc_remove(struct platform_device *pdev)
+{
+	struct mtc_device *dev = dev_get_drvdata(&pdev->dev);
+
+	kref_put(&dev->ref, mtc_destroy);
+	return 0;
+}
+
+/*
+ * mtc_destroy
+ *
+ * Called when refcount reaches zero to unregister device and free resources.
+ */
+static void mtc_destroy(struct kref *ref)
+{
+	struct mtc_device *dev = container_of(ref, struct mtc_device, ref);
+
+	dev_set_drvdata(&dev->pdev->dev, NULL);
+	if (test_and_clear_bit(FLAG_REGISTERED, &dev->flags))
+		misc_deregister(&dev->char_device);
+	if (dev->irq)
+		free_irq(dev->irq, &dev);
+	iounmap(dev->regs);
+	kfree(dev);
+}
+
+#ifdef CONFIG_PM
+static int mtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return -1;
+}
+
+static int mtc_resume(struct platform_device *pdev)
+{
+	return -1;
+}
+#else
+#define mtc_suspend	NULL
+#define mtc_resume	NULL
+#endif
+
+static const struct of_device_id mtc_of_ids[] = {
+	{.compatible = "axxia,mtc"},
+	{}
+};
+
+static struct platform_driver mtc_driver = {
+	.driver = {
+		   .name = "mtc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = mtc_of_ids,
+		   },
+	.probe = mtc_probe,
+	.remove = mtc_remove,
+	.suspend = mtc_suspend,
+	.resume = mtc_resume
+};
+
+module_platform_driver(mtc_driver);
+
+MODULE_AUTHOR("INTEL Corporation");
+MODULE_DESCRIPTION("Master Test Controller driver");
+MODULE_LICENSE("GPL");
+
+/* MTC operating mode. */
+#define  AXXIA_MTC_BOARDTEST_MODE 0  /* MTC Board Test Mode.  */
+#define  AXXIA_MTC_EXTTEST_MODE   1  /* MTC External Test Mode DBC3 excluded. */
+#define  AXXIA_MTC_SYSTTEST_MODE  2  /* MTC System Test Mode DBC3 excluded. */
+
+/* Test data output recording mode. */
+/* Do not save TDO data during shiftir and shiftdr. */
+#define   AXXIA_MTC_TDO_NOREC 0
+  /* Do not save TDO data during shiftir, but save TDO during shiftdr. */
+#define   AXXIA_MTC_TDO_NOREC_SHIFTIR 1
+  /* Do not save TDO data during shiftdr, but save TDO during shiftir. */
+#define  AXXIA_MTC_TDO_NOREC_SHIFTDR 2
+  /* Save TDO data during shiftdr and shiftir. */
+#define   ACELL_MTCI_TDO_REC_ALL  3
+
+/* Test data output buffer mode. */
+/* TDO output buffer always enabled. */
+#define  AXXIA_MTC_TDOBUF_ENABLED 0
+/* TDO output buffer active  when in shift-DR or shift-IR states
+   and inactive in all other states. */
+#define  AXXIA_MTC_TDOBUF_TRISTATE_CAPABLE 1
+
+/* config MTC hardware */
+static long _mtc_config(struct mtc_device *dev, struct axxia_mtc_cfg_t *pMTCCfg)
+{
+
+	struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = { 0 };
+	struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t cfg1 = { 0 };
+	struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = { 0 };
+	u32	init_reg = { 0 };
+
+	if ((!pMTCCfg) || (!dev))
+		return -EINVAL;
+
+	/* 1. stop testgen state machine */
+	cfg0 =
+	    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
+	      &(dev->regs->config0));
+	cfg0.start_stopn = 0;
+	dev->regs->config0 = *((u32 *) &cfg0);
+
+	/* 2. reset testgen, and init mem */
+	exec1.sw_reset = 1;
+	dev->regs->execute = *((u32 *) &exec1);
+	dev->regs->mem_init = 0x202;
+	/* wait for the init to complete */
+	udelay(2);
+	init_reg = readl(&(dev->regs->mem_init));
+	if ((init_reg & 0x101) != 0x101) {
+		pr_debug("warning: mem_init failed value=0x%x (expected:0x101)\n",
+			       init_reg);
+	}
+	/* clear ECC interrupt status */
+	dev->regs->ecc_int_status = 0xF;
+
+	/* 3. config MTC */
+	cfg0 =
+	    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
+	      &(dev->regs->config0));
+
+	cfg1 =
+	    *((struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t *)
+	      &(dev->regs->config1));
+
+	/*set MTC mode */
+	if (pMTCCfg->opMode == AXXIA_MTC_BOARDTEST_MODE) {
+		/* board testing mode */
+		cfg0.cfg_config_ctl = 0;
+	} else if (pMTCCfg->opMode == AXXIA_MTC_EXTTEST_MODE) {
+		/* external testing mode */
+		cfg0.cfg_config_ctl = 3;
+	} else {
+		/* system testing mode */
+		cfg0.cfg_config_ctl = 5;
+
+	}
+
+	/* set clock rate */
+	cfg0.rate_sel = pMTCCfg->clkSpeed;
+
+	/* set TDO buffer mode */
+	cfg0.mtc_mpu_tdo_inactive_en = pMTCCfg->buffMode;
+
+	/* set TDO recording mode */
+	if (pMTCCfg->recMode == AXXIA_MTC_TDO_NOREC) {
+		cfg1.record_tdo_in_shift_ir_state = 0;
+		cfg1.record_tdo_in_shift_dr_state = 0;
+	} else if (pMTCCfg->recMode == AXXIA_MTC_TDO_NOREC_SHIFTIR) {
+		cfg1.record_tdo_in_shift_ir_state = 0;
+		cfg1.record_tdo_in_shift_dr_state = 1;
+	} else if (pMTCCfg->recMode == AXXIA_MTC_TDO_NOREC_SHIFTDR) {
+		cfg1.record_tdo_in_shift_ir_state = 1;
+		cfg1.record_tdo_in_shift_dr_state = 0;
+	} else {
+		/* recMode == ACELL_MTCI_TDO_REC_ALL */
+		cfg1.record_tdo_in_shift_ir_state = 1;
+		cfg1.record_tdo_in_shift_dr_state = 1;
+	}
+
+	dev->regs->config0 = *((u32 *) &cfg0);
+	dev->regs->config1 = *((u32 *) &cfg1);
+
+#ifdef DEBUG
+	pr_debug("buffmode=%d,rate=%d dev->regs->config0 =0x%x\n",
+		 pMTCCfg->buffMode, pMTCCfg->clkSpeed, dev->regs->config0);
+
+	pr_debug("dev->regs->config1 =0x%x, dev->regs-> execute=0x%x\n",
+		 dev->regs->config1, dev->regs->execute);
+#endif
+	/* test */
+	return 0;
+}
diff --git a/drivers/misc/axxia-ncr.c b/drivers/misc/axxia-ncr.c
new file mode 100644
index 0000000..bcc394a
--- /dev/null
+++ b/drivers/misc/axxia-ncr.c
@@ -0,0 +1,1277 @@
+/*
+ *  Copyright (C) 2009 INTEL Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/axxia-ncr.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/sizes.h>
+
+static int ncr_available;
+static int nca_big_endian = 1;
+static int is_5500;
+static int is_5600;
+static int is_6700;
+static void __iomem *nca;
+static void __iomem *apb2ser0;
+
+#define WFC_TIMEOUT (400000)
+
+/*
+ * We provide both 'normal' and 'nolock' versions of the
+ * ncr_read/write functions. For normal operation we use
+ * locking to provide thread-safe operation.
+ * There are two levels of locking.
+ *
+ * 1. ncr_spin_lock -
+ *      This is a high-level lock that protects the NCA PIO
+ *      registers from concurrent use. The NCA PIO mechanism
+ *      only supports a single thread of execution.
+ *
+ * 2. nca_access_lock -
+ *       This is a low-level lock that protects each individual
+ *       register read/write to the NCA registers. This is a
+ *       workaround for a bug in rev 1.0 silicon where the bus
+ *       interface may hang if the NCA is subjected to simultaneous
+ *       requests from multiple masters.
+ *
+ * The 'nolock' versions of ncr_read/write should only be used in
+ * special cases where the caller can guarantee there will be no
+ * other threads of execution.
+ */
+
+/* Lock #1 : Protect NCA PIO registers from concurrent use. */
+static DEFINE_RAW_SPINLOCK(ncr_spin_lock);
+
+/* Lock #2 : Protect each individual NCA register access. */
+DEFINE_RAW_SPINLOCK(nca_access_lock);
+EXPORT_SYMBOL(nca_access_lock);
+
+static unsigned long ncr_spin_flags;
+
+#ifdef CONFIG_ARCH_AXXIA_NCR_RESET_CHECK
+/*
+ * define behavior if NCA register read/write is called while
+ * the axxia device is being reset. Any attempt to access NCA
+ * AXI registers while the NCA is in reset will hang the system.
+ *
+ * Due to higher level locking (ncr_spin_lock) this should not
+ * occur as part of normal config ring access (ncr_read/write),
+ * so we handle this condition as a BUG(). If it turns out there
+ * is some valid case where this may occur we can re-implement
+ * this as a wait loop.
+ */
+int ncr_reset_active;
+EXPORT_SYMBOL(ncr_reset_active);
+
+#define AXXIA_NCR_RESET_ACTIVE_CHECK()			\
+	do { if (ncr_reset_active) BUG(); } while (0)
+#else
+#define AXXIA_NCR_RESET_ACTIVE_CHECK()
+#endif
+
+#define LOCK_DOMAIN 0
+
+union command_data_register_0 {
+	unsigned int raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned int start_done:1;
+		unsigned int unused:6;
+		unsigned int local_bit:1;
+		unsigned int status:2;
+		unsigned int byte_swap_enable:1;
+		unsigned int cfg_cmpl_int_enable:1;
+		unsigned int cmd_type:4;
+		unsigned int dbs:16;
+#else
+		unsigned int dbs:16;
+		unsigned int cmd_type:4;
+		unsigned int cfg_cmpl_int_enable:1;
+		unsigned int byte_swap_enable:1;
+		unsigned int status:2;
+		unsigned int local_bit:1;
+		unsigned int unused:6;
+		unsigned int start_done:1;
+#endif
+	} __packed bits;
+} __packed;
+
+union command_data_register_1 {
+	unsigned int raw;
+	struct {
+		unsigned int target_address:32;
+	} __packed bits;
+} __packed;
+
+union command_data_register_2 {
+	unsigned int raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned int unused:16;
+		unsigned int target_node_id:8;
+		unsigned int target_id_address_upper:8;
+#else
+		unsigned int target_id_address_upper:8;
+		unsigned int target_node_id:8;
+		unsigned int unused:16;
+#endif
+	} __packed bits;
+} __packed;
+
+static int trace;
+module_param(trace, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(trace, "Trace NCR Accesses");
+
+static int trace_value_read;
+module_param(trace_value_read, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(trace_value_read, "Trace NCR Value Read");
+
+/*
+ * ncr_register_read/write
+ *   low-level access functions to Axxia registers,
+ *   with checking to ensure device is not currently
+ *   held in reset.
+ */
+unsigned int
+ncr_register_read(unsigned int *address)
+{
+	unsigned int value;
+
+	AXXIA_NCR_RESET_ACTIVE_CHECK();
+	value = __raw_readl(address);
+
+	if (0 == nca_big_endian)
+		return value;
+
+	return be32_to_cpu(value);
+}
+
+void
+ncr_register_write(const unsigned int value, unsigned int *address)
+{
+	AXXIA_NCR_RESET_ACTIVE_CHECK();
+
+	if (0 == nca_big_endian)
+		__raw_writel(value, address);
+	else
+		__raw_writel(cpu_to_be32(value), address);
+}
+
+/*
+ * ncr_register_read/write_lock
+ *   access functions for Axxia NCA block.
+ *   These functions protect the register access with a spinlock.
+ *   This is needed to workaround an AXM55xx v1.0 h/w bug.
+ *
+ */
+static unsigned int
+ncr_register_read_lock(unsigned int *address)
+{
+	unsigned int value;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&nca_access_lock, flags);
+	value = ncr_register_read(address);
+	raw_spin_unlock_irqrestore(&nca_access_lock, flags);
+
+	return value;
+}
+
+static void
+ncr_register_write_lock(const unsigned value, unsigned int *address)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&nca_access_lock, flags);
+	ncr_register_write(value, address);
+	raw_spin_unlock_irqrestore(&nca_access_lock, flags);
+}
+
+/*
+ * define two sets of function pointers for low-level register
+ * access - one with locking and one without.
+ */
+struct ncr_io_fns {
+	unsigned int (*rd)(unsigned int *address);
+	void (*wr)(const unsigned int value, unsigned int *address);
+};
+
+struct ncr_io_fns ncr_io_fn_lock = {
+	ncr_register_read_lock,
+	ncr_register_write_lock
+};
+
+struct ncr_io_fns ncr_io_fn_nolock = {
+	ncr_register_read,
+	ncr_register_write
+};
+
+struct ncr_io_fns *default_io_fn;
+
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_lock
+
+  Used to serialize all access to NCA PIO interface.
+*/
+
+int
+ncr_lock(int domain)
+{
+	raw_spin_lock_irqsave(&ncr_spin_lock, ncr_spin_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ncr_lock);
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_unlock
+
+  Used to serialize all access to NCA PIO interface.
+*/
+
+void
+ncr_unlock(int domain)
+{
+	raw_spin_unlock_irqrestore(&ncr_spin_lock, ncr_spin_flags);
+
+	return;
+}
+EXPORT_SYMBOL(ncr_unlock);
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_pio_error_dump
+*/
+
+static void
+ncr_pio_error_dump(struct ncr_io_fns *io_fn, char *str)
+{
+	unsigned int cdr0, cdr1, cdr2;
+	unsigned int stat0, stat1;
+
+	cdr0 = io_fn->rd((unsigned int *)(nca + 0xf0));
+	cdr1 = io_fn->rd((unsigned int *)(nca + 0xf4));
+	cdr2 = io_fn->rd((unsigned int *)(nca + 0xf8));
+
+	stat0 = io_fn->rd((unsigned int *)(nca + 0xe4));
+	stat1 = io_fn->rd((unsigned int *)(nca + 0xe8));
+
+	pr_err("axxia-ncr: %8s failed, error status : 0x%08x 0x%08x\n",
+	       str, stat0, stat1);
+	pr_err("axxia-ncr:  CDR0-2: 0x%08x 0x%08x 0x%08x\n",
+	       cdr0, cdr1, cdr2);
+}
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_check_pio_status
+*/
+
+static int
+ncr_check_pio_status(struct ncr_io_fns *io_fn, char *str)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
+	union command_data_register_0 cdr0;
+
+	/*
+	  Make sure any previous commands completed, and check for errors.
+	*/
+
+	do {
+		cdr0.raw = io_fn->rd((unsigned int *)(nca + 0xf0));
+	} while ((0x1 == cdr0.bits.start_done) &&
+		 (time_before(jiffies, timeout)));
+
+	if (0x1 == cdr0.bits.start_done) {
+		/* timed out without completing */
+		pr_err("axxia-ncr: PIO operation timeout cdr0=0x%08x!\n",
+		       cdr0.raw);
+		ncr_pio_error_dump(io_fn, str);
+		BUG();
+
+		return -1;
+	}
+
+	if (cdr0.raw && (0x3 != cdr0.bits.status)) {
+		/* completed with non-success status */
+		ncr_pio_error_dump(io_fn, str);
+		/* clear CDR0 to allow subsequent commands to complete */
+		io_fn->wr(0, (unsigned int *) (nca + 0xf0));
+
+		/*
+		 * we now treat any config ring error as a BUG().
+		 * this should never occur during normal operation with
+		 * 'good' system software.
+		 *
+		 * In the debug/lab environment the config ring errors
+		 * can occur more often. If this BUG() becomes too onerous
+		 * we may provide a way for the RTE to suppress this BUG()
+		 */
+		BUG();
+		return -1;
+	}
+
+	return 0;
+}
+
+union ncp_apb2ser_indirect_command {
+	unsigned     raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned      valid                                     :  1;
+		unsigned      hwrite                                    :  1;
+		unsigned      tshift                                    :  4;
+		unsigned      hsize                                     :  3;
+		unsigned      htrans                                    :  2;
+		unsigned      reserved                                  :  5;
+		unsigned      haddr                                     : 16;
+#else    /* Little Endian */
+		unsigned      haddr                                     : 16;
+		unsigned      reserved                                  :  5;
+		unsigned      htrans                                    :  2;
+		unsigned      hsize                                     :  3;
+		unsigned      tshift                                    :  4;
+		unsigned      hwrite                                    :  1;
+		unsigned      valid                                     :  1;
+#endif
+	} __packed bits;
+} __packed;
+
+/*
+  ------------------------------------------------------------------------------
+  apb2ser_indirect_setup
+*/
+
+static int
+apb2ser_indirect_setup(unsigned int region,
+		       unsigned int *indirect_offset,
+		       unsigned int *transfer_width)
+{
+	unsigned int node = NCP_NODE_ID(region);
+	unsigned int target = NCP_TARGET_ID(region);
+	unsigned int base;
+
+	if (is_5600)
+		if ((node < 0x110) || (node > 0x11a))
+			return -1;
+
+	if (is_6700)
+		if ((node < 0x110) || (node > 0x11f))
+			return -1;
+
+	if (node <= 0x114) {
+		base = (node - 0x110) * 2;
+	} else if (node >= 0x116) {
+		base = (node - 0x111) * 2;
+	} else {
+		if (is_5600)
+			base = 0x14;
+		else
+			base = 0x1e;
+	}
+
+	*indirect_offset = ((base + target) * 0x10000);
+	*transfer_width = (target > 0) ? 2 : 4;
+	udelay(10);
+
+	return 0;
+}
+
+/*
+ * ------------------------------------------------------------------------------
+ * apb2ser_indirect_access
+ */
+
+static int
+apb2ser_indirect_access(unsigned int offset,
+			unsigned int indirect_offset,
+			unsigned int transfer_width,
+			int write,
+			unsigned int *value)
+{
+	union ncp_apb2ser_indirect_command indcmd;
+	unsigned wfc;
+
+	memset(&indcmd, 0, sizeof(union ncp_apb2ser_indirect_command));
+	indcmd.bits.valid = 1;
+	indcmd.bits.hwrite = (0 == write) ? 0 : 1;
+	indcmd.bits.tshift = 0xf;
+	indcmd.bits.htrans = 2;
+	indcmd.bits.hsize = 2;
+	indcmd.bits.haddr = offset;
+
+	if (0 != write)
+		writel(*value, (apb2ser0 + indirect_offset));
+
+	pr_debug("ncr: indcmd.raw=0x%x\n", indcmd.raw);
+	writel(indcmd.raw, (apb2ser0 + indirect_offset + 4));
+	wfc = WFC_TIMEOUT;
+
+	do {
+		--wfc;
+		indcmd.raw = readl(apb2ser0 + indirect_offset + 4);
+	} while (1 == indcmd.bits.valid && 0 < wfc);
+
+	if (0 == wfc) {
+		pr_err("APB2SER Timeout!\n");
+
+		return -1;
+	}
+
+	if (0 == write)
+		*value = readl(apb2ser0 + indirect_offset + 8);
+
+	return 0;
+}
+
+/*
+ * ------------------------------------------------------------------------------
+ * ncr_apb2ser
+ */
+
+static int
+ncr_apb2ser(unsigned int region,
+	    unsigned int offset,
+	    int write,
+	    unsigned int *value)
+{
+	int rc;
+	unsigned int indirect_offset;
+	unsigned int transfer_width;
+
+	rc = apb2ser_indirect_setup(region, &indirect_offset, &transfer_width);
+
+	if (0 != rc) {
+		pr_err("APB2SER Indirect Setup Failed!\n");
+
+		return -1;
+	}
+
+	rc = apb2ser_indirect_access(offset, indirect_offset, transfer_width,
+				     write, value);
+
+	if (0 != rc) {
+		pr_err("APB2SER Indirect Setup Failed!\n");
+
+		return -1;
+	}
+
+	return 0;
+}
+
+union ncp_cobalt_serdes_ctrl98 {
+	unsigned short raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+	unsigned short reserved_b53 : 13;
+	unsigned short cr_ack_clear :  1;
+	unsigned short cr_rd        :  1;
+	unsigned short cr_wr        :  1;
+#else    /* Little Endian */
+	unsigned short cr_wr        :  1;
+	unsigned short cr_rd        :  1;
+	unsigned short cr_ack_clear :  1;
+	unsigned short reserved_b53 : 13;
+#endif
+	} __packed bits;
+} __packed;
+
+
+union ncp_cobalt_serdes_ctrl99 {
+	unsigned short raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned short reserved : 15;
+		unsigned short cr_ack   :  1;
+#else    /* Little Endian */
+		unsigned short cr_ack   :  1;
+		unsigned short reserved : 15;
+#endif
+	} __packed bits;
+} __packed;
+
+/*
+ * ------------------------------------------------------------------------------
+ * ncr_apb2ser_e12
+ */
+
+static int
+ncr_apb2ser_e12(unsigned int region,
+		unsigned int offset,
+		int write,
+		unsigned int *value)
+{
+	unsigned int indirect_offset;
+	unsigned int transfer_width;
+	union ncp_cobalt_serdes_ctrl98 hss_cobalt_ctrl_98 = {0};
+	union ncp_cobalt_serdes_ctrl99 hss_cobalt_ctrl_99 = {0};
+	unsigned short e12_addr = 0;
+	unsigned int ctrl_96_off;
+	unsigned int ctrl_97_off;
+	unsigned int ctrl_98_off;
+	unsigned int ctrl_99_off;
+	unsigned int ctrl_224_off;
+
+	if (0 !=
+	    apb2ser_indirect_setup(region, &indirect_offset, &transfer_width))
+		return -1;
+
+	if (is_5600) {
+		ctrl_96_off = 0x00c0;
+		ctrl_97_off = 0x00c2;
+		ctrl_98_off = 0x00c4;
+		ctrl_99_off = 0x00c6;
+		ctrl_224_off = 0x01c0;
+	} else {
+		ctrl_96_off = 0x0180;
+		ctrl_97_off = 0x0184;
+		ctrl_98_off = 0x0188;
+		ctrl_99_off = 0x018c;
+		ctrl_224_off = 0x0380;
+		offset >>= 1;
+	}
+
+	if ((offset >= 0x1000) && (offset <= 0x10d0))
+		e12_addr = (offset - 0x1000) / 2;
+	else if (offset >= 0x2000)
+		e12_addr = offset / 2;
+
+	apb2ser_indirect_access(ctrl_96_off, indirect_offset, 4,
+				1, (unsigned int *)&e12_addr);
+
+	if (write) {
+		apb2ser_indirect_access(ctrl_97_off, indirect_offset, 4, 1,
+					value);
+		hss_cobalt_ctrl_98.bits.cr_rd = 0; /* bus read strobe */
+		hss_cobalt_ctrl_98.bits.cr_wr = 1;
+	} else  {
+		hss_cobalt_ctrl_98.bits.cr_rd = 1; /* bus read strobe */
+		hss_cobalt_ctrl_98.bits.cr_wr = 0;
+	}
+
+	hss_cobalt_ctrl_98.bits.cr_ack_clear = 0;
+	apb2ser_indirect_access(ctrl_98_off, indirect_offset, 4, 1,
+				(unsigned int *)&hss_cobalt_ctrl_98.raw);
+
+	/* poll for cr_ack to get set */
+	do {
+		apb2ser_indirect_access(ctrl_99_off, indirect_offset, 4, 0,
+					(unsigned int *)
+					&hss_cobalt_ctrl_99.raw);
+	} while (0 == hss_cobalt_ctrl_99.bits.cr_ack);
+
+	hss_cobalt_ctrl_98.bits.cr_rd = 0;
+	hss_cobalt_ctrl_98.bits.cr_wr = 0;
+	hss_cobalt_ctrl_98.bits.cr_ack_clear = 1;
+	apb2ser_indirect_access(ctrl_98_off, indirect_offset, 4, 1,
+				(unsigned int *)&hss_cobalt_ctrl_98.raw);
+
+	hss_cobalt_ctrl_98.bits.cr_ack_clear = 0;
+	apb2ser_indirect_access(ctrl_98_off, indirect_offset, 4, 1,
+				(unsigned int *)&hss_cobalt_ctrl_98.raw);
+
+	if (!write)
+		apb2ser_indirect_access(ctrl_224_off, indirect_offset, 4, 0,
+					value);
+
+	return 0;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_0x115_5500
+*/
+
+static int
+ncr_0x115_5500(unsigned int region, unsigned int offset, int write,
+	       unsigned int *value)
+{
+	unsigned int control;
+	void __iomem *base;
+	unsigned wfc_timeout = 400000;
+
+	if (0xffff < offset)
+		return -1;
+
+	switch (NCP_TARGET_ID(region)) {
+	case 0:
+		base = (apb2ser0 + 0x1e0);
+		break;
+	case 1:
+		base = (apb2ser0 + 0x1f0);
+		break;
+	case 2:
+		base = (apb2ser0 + 0x200);
+		break;
+	case 3:
+		base = (apb2ser0 + 0x210);
+		break;
+	case 4:
+		base = (apb2ser0 + 0x220);
+		break;
+	case 5:
+		base = (apb2ser0 + 0x230);
+		break;
+	default:
+		return -1;
+	}
+
+	if ((NCP_TARGET_ID(region) == 0x1) ||
+	    (NCP_TARGET_ID(region) == 0x4))
+		control = 0x84c00000;
+	else
+		control = 0x85400000;
+
+	if (0 != write)
+		control |= 0x40000000;
+
+	writel((control + offset), (base + 4));
+
+	do {
+		--wfc_timeout;
+		*((unsigned long *)value) = readl(base + 4);
+	} while (0 != (*((unsigned long *)value) & 0x80000000) &&
+		 0 < wfc_timeout);
+
+	if (0 == wfc_timeout)
+		return -1;
+
+	if (0 == write) {
+		if ((NCP_TARGET_ID(region) == 0x1) ||
+		    (NCP_TARGET_ID(region) == 0x4)) {
+			*((unsigned short *)value) = readl(base + 8);
+		} else {
+			*((unsigned long *)value) = readl(base + 8);
+		}
+	}
+
+	return 0;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_axi2ser
+*/
+
+static int
+ncr_axi2ser(unsigned int region, unsigned int offset, int write,
+	    unsigned int *value)
+{
+	unsigned int *address;
+
+	address = apb2ser0;
+
+	switch (NCP_NODE_ID(region)) {
+	case 0x153:
+		if (0 != is_5500) {
+			address += (offset & (~0x3));
+
+			/*
+			 * Copy from buffer to the data words.
+			 */
+
+			if (0 != write)
+				*((unsigned long *)address) =
+					*((unsigned long *)value);
+			else
+				*((unsigned long *)value) =
+					*((unsigned long *)address);
+		}
+		break;
+	case 0x155:
+		address += 0x800000;
+		break;
+	case 0x156:
+		address += 0xc00000;
+		break;
+	case 0x165:
+		address += 0x1400000;
+		break;
+	case 0x167:
+		address += 0x1c00000;
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	if (0x156 == NCP_NODE_ID(region))
+		address += NCP_TARGET_ID(region) * 0x4000;
+	else
+		address += NCP_TARGET_ID(region) * 0x10000;
+
+	address += offset;
+
+	if (0 == write)
+		*value = readl(address);
+	else
+		writel(*value, address);
+
+	return 0;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Public Interface
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  __ncr_read
+*/
+
+static int
+__ncr_read(struct ncr_io_fns *io_fn,
+	   unsigned int region, unsigned long address, int number,
+	   void *buffer)
+{
+	union command_data_register_0 cdr0;
+	union command_data_register_1 cdr1;
+	union command_data_register_2 cdr2;
+	unsigned char *input = buffer;
+
+	if (0 == ncr_available)
+		return -1;
+
+	pr_debug("%s:%d - region=0x%x node=0x%x target=0x%x\n",
+	      __FILE__, __LINE__,
+	      region, NCP_NODE_ID(region), NCP_TARGET_ID(region));
+
+	if (0x110 <= NCP_NODE_ID(region) &&
+	    0x11f >= NCP_NODE_ID(region)) {
+		int rc;
+
+		if (is_5500) {
+			rc = ncr_0x115_5500(region, address, 0, buffer);
+		} else if ((NCP_TARGET_ID(region) != 0) &&
+			   (address >= 0x1000)) {
+			rc = ncr_apb2ser_e12(region, address, 0, buffer);
+		} else {
+			rc = ncr_apb2ser(region, address, 0, buffer);
+		}
+
+		if (0 != rc)
+			return -1;
+	} else if (0x153 == NCP_NODE_ID(region) ||
+		   0x155 == NCP_NODE_ID(region) ||
+		   0x156 == NCP_NODE_ID(region) ||
+		   0x165 == NCP_NODE_ID(region) ||
+		   0x167 == NCP_NODE_ID(region)) {
+		if (0 != ncr_axi2ser(region, address, 0, buffer))
+			return -1;
+	} else if (0x100 > NCP_NODE_ID(region)) {
+		/* make sure any previous command has completed */
+		if (0 != ncr_check_pio_status(io_fn, "previous"))
+			return -1;
+
+		/*
+		  Set up the read command.
+		*/
+
+		cdr2.raw = 0;
+		cdr2.bits.target_node_id = NCP_NODE_ID(region);
+		cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+		io_fn->wr(cdr2.raw, (unsigned int *) (nca + 0xf8));
+
+		cdr1.raw = 0;
+		cdr1.bits.target_address = (address >> 2);
+		io_fn->wr(cdr1.raw, (unsigned int *) (nca + 0xf4));
+
+		cdr0.raw = 0;
+		cdr0.bits.start_done = 1;
+
+		if (0xff == cdr2.bits.target_id_address_upper)
+			cdr0.bits.local_bit = 1;
+
+		cdr0.bits.cmd_type = 4;
+		/* TODO: Verify number... */
+		cdr0.bits.dbs = (number - 1);
+		io_fn->wr(cdr0.raw, (unsigned int *) (nca + 0xf0));
+		mb();
+
+		/*
+		  Wait for completion.
+		*/
+		if (0 != ncr_check_pio_status(io_fn, "read"))
+			return -1;
+
+		/*
+_		  Copy data words to the buffer.
+		*/
+
+		address = (unsigned long)(nca + 0x1000);
+		while (4 <= number) {
+			*((unsigned int *) buffer) =
+				io_fn->rd((unsigned int *) address);
+			address += 4;
+			buffer += 4;
+			number -= 4;
+		}
+
+		if (0 < number) {
+			unsigned int temp =
+				io_fn->rd((unsigned int *) address);
+			memcpy((void *) buffer, &temp, number);
+		}
+	} else {
+		printk(KERN_ERR "Unhandled Region (r): 0x%x 0x%x 0%x 0x%lx\n",
+		       region, NCP_NODE_ID(region), NCP_TARGET_ID(region),
+		       address);
+
+		return -1;
+	}
+
+	if (0 != trace) {
+		printk("ncpRead");
+
+		switch (number) {
+		case 1:
+			printk("   -w8 0.");
+			break;
+		case 2:
+			printk("  -w16 0.");
+			break;
+		case 4:
+			printk("       0.");
+			break;
+		default:
+			break;
+		}
+
+		printk("%u.%u.0x00%08lx 1",
+		       NCP_NODE_ID(region),
+		       NCP_TARGET_ID(region),
+		       address);
+
+		if (0 != trace_value_read) {
+			switch (number) {
+			case 1:
+				printk(" [0x%02x]\n",
+				       *((unsigned char *)input));
+				break;
+			case 2:
+				printk(" [0x%04x]\n",
+				       *((unsigned short *)input));
+				break;
+			case 4:
+				printk(" [0x%08x]\n",
+				       *((unsigned int *)input));
+				break;
+			default:
+				break;
+			}
+		} else {
+			printk("\n");
+		}
+	}
+
+	return 0;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_read_nolock
+*/
+
+int
+ncr_read_nolock(unsigned int region, unsigned int address,
+		int number, void *buffer)
+{
+	if (0 == ncr_available)
+		return -1;
+
+	return __ncr_read(&ncr_io_fn_nolock, region, address, number, buffer);
+}
+EXPORT_SYMBOL(ncr_read_nolock);
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_read
+*/
+
+int
+ncr_read(unsigned int region, unsigned int address, int number, void *buffer)
+{
+	int rc;
+
+	if (0 == ncr_available)
+		return -1;
+
+	ncr_lock(LOCK_DOMAIN);
+
+	/* call __ncr_read with chip version dependent io_fn */
+	rc = __ncr_read(default_io_fn, region, address, number, buffer);
+
+	ncr_unlock(LOCK_DOMAIN);
+
+	return rc;
+}
+
+EXPORT_SYMBOL(ncr_read);
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_read32
+*/
+
+int
+ncr_read32(unsigned int region, unsigned int offset, unsigned int *value)
+{
+	unsigned int val;
+	int rc;
+
+	rc = ncr_read(region, offset, 4, &val);
+	pr_debug("%s:%d - read 0x%x from 0x%x.0x%x.0x%x rc=%d\n",
+		 __FILE__, __LINE__, val,
+		 NCP_NODE_ID(region), NCP_TARGET_ID(region), offset, rc);
+	*value = val;
+
+	return rc;
+}
+
+EXPORT_SYMBOL(ncr_read32);
+
+/*
+  ----------------------------------------------------------------------
+  ncr_write
+*/
+
+static int
+__ncr_write(struct ncr_io_fns *io_fn,
+	    unsigned int region, unsigned int address, int number,
+	    void *buffer)
+{
+	union command_data_register_0 cdr0;
+	union command_data_register_1 cdr1;
+	union command_data_register_2 cdr2;
+	unsigned long data_word_base;
+	int dbs = (number - 1);
+
+	if (0 == ncr_available)
+		return -1;
+
+	if (0 != trace) {
+		printk("ncpWrite");
+
+		switch (number) {
+		case 1:
+			printk("  -w8 0.");
+			break;
+		case 2:
+			printk(" -w16 0.");
+			break;
+		case 4:
+			printk("      0.");
+			break;
+		default:
+			break;
+		}
+
+		printk("%u.%u.0x00%08x",
+		       NCP_NODE_ID(region),
+		       NCP_TARGET_ID(region),
+		       address);
+
+		switch (number) {
+		case 1:
+			printk(" 0x%02x\n", *((unsigned char *)buffer));
+			break;
+		case 2:
+			printk(" 0x%04x\n", *((unsigned short *)buffer));
+			break;
+		case 4:
+			printk(" 0x%08x\n", *((unsigned int *)buffer));
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (0x110 <= NCP_NODE_ID(region) &&
+	    0x11f >= NCP_NODE_ID(region)) {
+		int rc;
+
+		if (is_5500) {
+			rc = ncr_0x115_5500(region, address, 1, buffer);
+		} else if ((NCP_TARGET_ID(region) != 0) &&
+			   (address >= 0x1000)) {
+			rc = ncr_apb2ser_e12(region, address, 1, buffer);
+		} else {
+			rc = ncr_apb2ser(region, address, 1, buffer);
+		}
+
+		if (0 != rc)
+			return -1;
+	} else if (0x153 == NCP_NODE_ID(region) ||
+		   0x155 == NCP_NODE_ID(region) ||
+		   0x156 == NCP_NODE_ID(region) ||
+		   0x165 == NCP_NODE_ID(region) ||
+		   0x167 == NCP_NODE_ID(region)) {
+		if (0 != ncr_axi2ser(region, address, 1, buffer))
+			return -1;
+	} else if (0x100 > NCP_NODE_ID(region)) {
+		/* make sure any previous command has completed */
+		if (0 != ncr_check_pio_status(io_fn, "previous"))
+			return -1;
+
+		/*
+		  Set up the write.
+		*/
+
+		cdr2.raw = 0;
+		cdr2.bits.target_node_id = NCP_NODE_ID(region);
+		cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+		io_fn->wr(cdr2.raw, (unsigned *) (nca + 0xf8));
+
+		cdr1.raw = 0;
+		cdr1.bits.target_address = (address >> 2);
+		io_fn->wr(cdr1.raw, (unsigned *) (nca + 0xf4));
+
+		/*
+		  Copy from buffer to the data words.
+		*/
+
+		data_word_base = (unsigned long)(nca + 0x1000);
+
+		while (4 <= number) {
+			io_fn->wr(*((unsigned int *)buffer),
+				  (unsigned int *)data_word_base);
+			data_word_base += 4;
+			buffer += 4;
+			number -= 4;
+		}
+
+		if (0 < number) {
+			unsigned int temp = 0;
+
+			memcpy((void *) &temp, (void *) buffer, number);
+			io_fn->wr(temp, (unsigned *) data_word_base);
+			data_word_base += number;
+			buffer += number;
+			number = 0;
+		}
+
+		cdr0.raw = 0;
+		cdr0.bits.start_done = 1;
+
+		if (0xff == cdr2.bits.target_id_address_upper)
+			cdr0.bits.local_bit = 1;
+
+		cdr0.bits.cmd_type = 5;
+		/* TODO: Verify number... */
+		cdr0.bits.dbs = dbs;
+		io_fn->wr(cdr0.raw, (unsigned *) (nca + 0xf0));
+		mb();
+
+		/*
+		  Wait for completion.
+		*/
+
+		if (0 != ncr_check_pio_status(io_fn, "write"))
+			return -1;
+	} else {
+		printk(KERN_ERR "Unhandled Region (w): 0x%x 0x%x 0x%x 0x%x\n",
+		       region, NCP_NODE_ID(region), NCP_TARGET_ID(region),
+		       address);
+
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+ncr_write_nolock(unsigned int region, unsigned int address, int number,
+		 void *buffer)
+{
+	if (0 == ncr_available)
+		return -1;
+
+	/* call the __ncr_write function with nolock io_fn */
+	return __ncr_write(&ncr_io_fn_nolock,
+			   region, address, number, buffer);
+}
+EXPORT_SYMBOL(ncr_write_nolock);
+
+int
+ncr_write(unsigned int region, unsigned int address, int number,
+	  void *buffer)
+{
+	int rc = 0;
+
+	if (0 == ncr_available)
+		return -1;
+
+	/* grab the ncr_lock */
+	ncr_lock(LOCK_DOMAIN);
+
+	/* call the __ncr_write function with chip-version dependent io_fn */
+	rc = __ncr_write(default_io_fn, region, address, number, buffer);
+
+	/* free the ncr_lock */
+	ncr_unlock(LOCK_DOMAIN);
+
+	return rc;
+}
+EXPORT_SYMBOL(ncr_write);
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_write32
+*/
+
+int
+ncr_write32(unsigned int region, unsigned int offset, unsigned int value)
+{
+	int rc;
+
+	rc = ncr_write(region, offset, 4, &value);
+	pr_debug("%s:%d - wrote 0x%x to 0x%x.0x%x.0x%x rc=%d\n",
+		 __FILE__, __LINE__, value,
+		 NCP_NODE_ID(region), NCP_TARGET_ID(region), offset, rc);
+
+	return rc;
+}
+
+EXPORT_SYMBOL(ncr_write32);
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_start_trace
+*/
+
+void
+ncr_start_trace(void)
+{
+	trace = 1;
+}
+EXPORT_SYMBOL(ncr_start_trace);
+
+/*
+ * ------------------------------------------------------------------------------
+ * ncr_stop_trace
+ */
+
+void
+ncr_stop_trace(void)
+{
+	trace = 0;
+}
+EXPORT_SYMBOL(ncr_stop_trace);
+
+/*
+ * ------------------------------------------------------------------------------
+ * ncr_init
+ */
+
+static int
+ncr_init(void)
+{
+#ifdef CONFIG_ARCH_AXXIA
+	default_io_fn = &ncr_io_fn_nolock;
+
+
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5500-amarillo")) {
+		u32 pfuse;
+		u32 chip_type;
+		u32 chip_ver;
+		void __iomem *syscon;
+
+		syscon = ioremap(0x002010030000ULL, SZ_64K);
+
+		if (WARN_ON(!syscon))
+			return -ENODEV;
+
+		/*
+		 * read chip type/revision to determine if low-level locking
+		 * is required and select the appropriate io_fns.
+		 */
+
+		pfuse = readl(syscon + 0x34);
+		chip_type = pfuse & 0x1f;
+		chip_ver  = (pfuse >> 8) & 0x7;
+
+		if ((chip_type == 0 || chip_type == 9) && (chip_ver == 0)) {
+			/* AXM5516v1.0 needs low-level locking */
+			default_io_fn = &ncr_io_fn_lock;
+			pr_debug("Using NCA lock functions (AXM5500 v1.0)\n");
+		}
+
+		iounmap(syscon);
+	}
+
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5500") ||
+	    of_find_compatible_node(NULL, NULL, "axxia,axm5516")) {
+		pr_debug("Using AXM5500 Addresses\n");
+		nca = ioremap(0x002020100000ULL, 0x20000);
+		apb2ser0 = ioremap(0x002010000000ULL, 0x10000);
+		is_5500 = 1;
+	} else if (of_find_compatible_node(NULL, NULL, "axxia,axm5616")) {
+		pr_debug("Using AXM5600 Addresses\n");
+		nca = ioremap(0x8031080000ULL, 0x20000);
+		apb2ser0 = ioremap(0x8002000000ULL, 0x4000000);
+		is_5600 = 1;
+		pr_debug("0x%lx 0x%lx\n",
+			 (unsigned long)nca,
+			 (unsigned long)apb2ser0);
+	} else if (of_find_compatible_node(NULL, NULL, "axxia,axc6732")) {
+		pr_debug("Using AXC6700 Addresses\n");
+		nca = ioremap(0x8020000000ULL, 0x20000);
+		apb2ser0 = ioremap(0x8002000000ULL, 0x400000);
+		is_6700 = 1;
+		nca_big_endian = 0; /* The 6700 NCA is LE */
+	} else {
+		pr_err("No Valid Compatible String Found for NCR!\n");
+		return -1;
+	}
+#else
+	if (of_find_compatible_node(NULL, NULL, "axxia,acp3500")) {
+		pr_debug("Using ACP3500 Addresses\n");
+		nca = ioremap(0x002000520000ULL, 0x20000);
+		default_io_fn = &ncr_io_fn_nolock;
+	} else {
+		pr_debug("Using ACP34xx Addresses\n");
+		nca = ioremap(0x002000520000ULL, 0x20000);
+		default_io_fn = &ncr_io_fn_lock;
+	}
+#endif
+
+	pr_info("ncr: available\n");
+	ncr_available = 1;
+
+	return 0;
+}
+
+arch_initcall(ncr_init);
+
+MODULE_AUTHOR("John Jacques <john.jacques@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Register Ring access for Axxia");
diff --git a/drivers/misc/axxia-oem.c b/drivers/misc/axxia-oem.c
index bcd1a8c..e7436dd 100644
--- a/drivers/misc/axxia-oem.c
+++ b/drivers/misc/axxia-oem.c
@@ -380,7 +380,7 @@ struct oem_parameters {
 static int
 axxia_oem_init(void)
 {
-	if (of_find_compatible_node(NULL, NULL, "lsi,axc6732")) {
+	if (of_find_compatible_node(NULL, NULL, "axxia,axc6732")) {
 		/* Only applicable to the 6700. */
 		if (NULL == proc_create("driver/axxia_dspc", S_IWUSR, NULL,
 					&axxia_dspc_proc_ops))
diff --git a/drivers/misc/axxia-pei.c b/drivers/misc/axxia-pei.c
index b9d23a0..f1b39a1 100644
--- a/drivers/misc/axxia-pei.c
+++ b/drivers/misc/axxia-pei.c
@@ -30,7 +30,7 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/of.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <linux/mutex.h>
 
 static int is_5500;
@@ -2228,10 +2228,10 @@ int axxia_pei_is_control_set(void)
 	memset(axxia_pei, 0, sizeof(axxia_pei));
 
 	/* Use the device tree to determine the Axxia type. */
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5500") ||
-	    of_find_compatible_node(NULL, NULL, "lsi,axm5516")) {
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5500") ||
+	    of_find_compatible_node(NULL, NULL, "axxia,axm5516")) {
 		is_5500 = 1;
-	} else if (of_find_compatible_node(NULL, NULL, "lsi,axm5616")) {
+	} else if (of_find_compatible_node(NULL, NULL, "axxia,axm5616")) {
 		is_5600 = 1;
 		axxia_pei[0].phys = 0xa003000000;
 		axxia_pei[0].virt = ioremap(axxia_pei[0].phys, 0x10000);
@@ -2241,7 +2241,7 @@ int axxia_pei_is_control_set(void)
 		axxia_pei[2].virt = ioremap(axxia_pei[2].phys, 0x10000);
 		pcie_rc = ioremap(0xa002000000, 0x1000);
 		syscon = ioremap(0x8002c00000, 0x4000);
-	} else if (of_find_compatible_node(NULL, NULL, "lsi,axc6732")) {
+	} else if (of_find_compatible_node(NULL, NULL, "axxia,axc6732")) {
 		is_6700 = 1;
 		axxia_pei[0].phys = 0xa003000000;
 		axxia_pei[0].virt = ioremap(axxia_pei[0].phys, 0x10000);
diff --git a/drivers/misc/axxia-smmon.c b/drivers/misc/axxia-smmon.c
new file mode 100644
index 0000000..3daa59c
--- /dev/null
+++ b/drivers/misc/axxia-smmon.c
@@ -0,0 +1,306 @@
+/*
+ *  Copyright (C) 2013 INTEL Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  Error monitor for system memory.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/ratelimit.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/reboot.h>
+
+#include <mach/ncr.h>
+
+#define APB2_SER3_PHY_ADDR        0x002010030000ULL
+#define APB2_SER3_PHY_SIZE   0x1000
+
+static int log = 1;
+module_param(log, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(log, "Log each error to kernel log.");
+
+static int machineRestart = 1;
+module_param(machineRestart, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(machineRestart, "Machine restart on fatal error.");
+/*
+  AXM55xx memory controller interrupt status bits:
+
+  Bit [24] = The software-initiated control word write has completed.
+  Bit [23] = The user-initiated DLL resync has completed.
+  Bit [22] = A state change has been detected on the dfi_init_complete signal
+	     after initialization.
+  Bit [21] = The assertion of the INHIBIT_DRAM_CMD parameter has successfully
+	     inhibited the command queue.
+  Bit [20] = The register interface-initiated mode register write has completed
+	     and another mode register write may be issued.
+  Bit [19] = A parity error has been detected on the address/control bus on a
+	     registered DIMM.
+  Bit [18] = The leveling operation has completed.
+  Bit [17] = A leveling operation has been requested.
+  Bit [16] = A DFI update error has occurred. Error information can be found in
+	     the UPDATE_ERROR_STATUS parameter.
+  Bit [15] = A write leveling error has occurred. Error information can be found
+	     in the WRLVL_ERROR_STATUS parameter.
+  Bit [14] = A read leveling gate training error has occurred. Error information
+	     can be found in the RDLVL_ERROR_STATUS parameter.
+  Bit [13] = A read leveling error has occurred. Error information can be found
+	     in the RDLVL_ERROR_STATUS parameter.
+  Bit [12] = The user has programmed an invalid setting associated with user
+	     words per burst. Examples: Setting param_reduc when burst
+	     length = 2. A 1:2 MC:PHY clock ratio with burst length = 2.
+  Bit [11] = A wrap cycle crossing a DRAM page has been detected. This is
+	     unsupported & may result in memory data corruption.
+  Bit [10] = The BIST operation has been completed.
+  Bit [09] = The low power operation has been completed.
+  Bit [08] = The MC initialization has been completed.
+  Bit [07] = An error occurred on the port command channel.
+  Bit [06] = Multiple uncorrectable ECC events have been detected.
+  Bit [05] = An uncorrectable ECC event has been detected.
+  Bit [04] = Multiple correctable ECC events have been detected.
+  Bit [03] = A correctable ECC event has been detected.
+  Bit [02] = Multiple accesses outside the defined PHYSICAL memory space have
+	     occurred.
+  Bit [01] = A memory access outside the defined PHYSICAL memory space has
+	     occurred.
+  Bit [00] = The memory reset is valid on the DFI bus.
+
+  Of these, 1, 2, 3, 4, 5, 6, 7, 11, and 19 are of interest.
+*/
+#define SM_INT_MASK (0x1f7f701)
+
+enum events {
+	EV_ILLEGAL = 0,
+	EV_MULT_ILLEGAL,
+	EV_CORR_ECC,
+	EV_MULT_CORR_ECC,
+	EV_UNCORR_ECC,
+	EV_MULT_UNCORR_ECC,
+	EV_PORT_ERROR,
+	EV_WRAP_ERROR,
+	EV_PARITY_ERROR,
+	NR_EVENTS
+};
+
+static const u32 event_mask[NR_EVENTS] = {
+	[EV_ILLEGAL]          = 0x00000002,
+	[EV_MULT_ILLEGAL]     = 0x00000004,
+	[EV_CORR_ECC]         = 0x00000008,
+	[EV_MULT_CORR_ECC]    = 0x00000010,
+	[EV_UNCORR_ECC]       = 0x00000020,
+	[EV_MULT_UNCORR_ECC]  = 0x00000040,
+	[EV_PORT_ERROR]       = 0x00000080,
+	[EV_WRAP_ERROR]       = 0x00000800,
+	[EV_PARITY_ERROR]     = 0x00080000,
+};
+
+static const struct event_logging {
+	int         fatal;
+	const char *level;
+	const char *name;
+} event_logging[NR_EVENTS] = {
+	[EV_ILLEGAL]         = {0, KERN_ERR, "Illegal access"},
+	[EV_MULT_ILLEGAL]    = {0, KERN_ERR, "Illegal access"},
+	[EV_CORR_ECC]        = {0, KERN_NOTICE, "Correctable ECC error"},
+	[EV_MULT_CORR_ECC]   = {0, KERN_NOTICE, "Correctable ECC error"},
+	[EV_UNCORR_ECC]      = {1, KERN_CRIT, "Uncorrectable ECC error"},
+	[EV_MULT_UNCORR_ECC] = {1, KERN_CRIT, "Uncorrectable ECC error"},
+	[EV_PORT_ERROR]      = {0, KERN_CRIT, "Port error"},
+	[EV_WRAP_ERROR]      = {0, KERN_CRIT, "Wrap error"},
+	[EV_PARITY_ERROR]    = {0, KERN_CRIT, "Parity error"},
+};
+
+struct smmon_attr {
+	struct device_attribute attr;
+	int                     event;
+};
+
+#define SMMON_ATTR(_name, _event) \
+	{ \
+		.attr = __ATTR(_name, S_IRUGO, smmon_show, NULL), \
+		.event = _event \
+	}
+
+struct sm_dev {
+	struct platform_device *pdev;
+	u32 region; /* NCR region address */
+	void __iomem *apb2ser3_region;
+	u32 counter[NR_EVENTS];
+};
+
+
+static ssize_t
+smmon_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sm_dev *sm = dev_get_drvdata(dev);
+	struct smmon_attr *sma = container_of(attr, struct smmon_attr, attr);
+	return sprintf(buf, "%u", sm->counter[sma->event]);
+}
+
+static struct smmon_attr smmon_attr_counter[] = {
+	SMMON_ATTR(illegal_access, EV_ILLEGAL),
+	SMMON_ATTR(illegal_access_mult, EV_MULT_ILLEGAL),
+	SMMON_ATTR(correctable_ecc_error, EV_CORR_ECC),
+	SMMON_ATTR(correctable_ecc_error_mult, EV_MULT_CORR_ECC),
+	SMMON_ATTR(uncorrectable_ecc_error, EV_UNCORR_ECC),
+	SMMON_ATTR(uncorrectable_ecc_error_mult, EV_MULT_UNCORR_ECC),
+	SMMON_ATTR(port_error, EV_PORT_ERROR),
+	SMMON_ATTR(wrap_error, EV_WRAP_ERROR),
+	SMMON_ATTR(parity_error, EV_PARITY_ERROR),
+};
+
+static struct attribute *smmon_attr[] = {
+	&smmon_attr_counter[EV_ILLEGAL].attr.attr,
+	&smmon_attr_counter[EV_MULT_ILLEGAL].attr.attr,
+	&smmon_attr_counter[EV_CORR_ECC].attr.attr,
+	&smmon_attr_counter[EV_MULT_CORR_ECC].attr.attr,
+	&smmon_attr_counter[EV_UNCORR_ECC].attr.attr,
+	&smmon_attr_counter[EV_MULT_UNCORR_ECC].attr.attr,
+	&smmon_attr_counter[EV_PORT_ERROR].attr.attr,
+	&smmon_attr_counter[EV_WRAP_ERROR].attr.attr,
+	&smmon_attr_counter[EV_PARITY_ERROR].attr.attr,
+	NULL
+};
+
+static struct attribute_group smmon_attr_group = {
+	.name  = "counters",
+	.attrs = smmon_attr
+};
+
+static irqreturn_t
+smmon_isr(int interrupt, void *device)
+{
+	struct sm_dev *sm = device;
+	u32 status;
+	unsigned long setVal;
+	int i;
+
+	if (ncr_read(sm->region, 0x410, 4, &status)) {
+		pr_err("%s: Error reading interrupt status\n",
+		       dev_name(&sm->pdev->dev));
+		return IRQ_NONE;
+	}
+
+	for (i = 0; i < NR_EVENTS; ++i) {
+		if ((status & event_mask[i]) != 0) {
+			++sm->counter[i];
+			if (machineRestart && event_logging[i].fatal) {
+				setVal = readl(sm->apb2ser3_region + 0xdc);
+				/* set bit 3 in pscratch reg */
+				setVal = (setVal) | (0x1 << 3);
+				writel(setVal, sm->apb2ser3_region + 0xdc);
+				pr_info("CPU uncorrectable error\n");
+				machine_restart(NULL);
+			}
+			if (log)
+				printk_ratelimited("%s%s: %s\n",
+						   event_logging[i].level,
+						   dev_name(&sm->pdev->dev),
+						   event_logging[i].name);
+		}
+	}
+
+	/* Clear interrupt */
+	ncr_write(sm->region, 0x548, 4, &status);
+
+	return IRQ_HANDLED;
+}
+
+static int
+smmon_probe(struct platform_device *pdev)
+{
+	struct sm_dev *sm;
+	struct resource *io;
+	int irq;
+	u32 mask;
+	int rc = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+
+	sm = devm_kzalloc(&pdev->dev, sizeof(*sm), GFP_KERNEL);
+	if (!sm) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	sm->pdev = pdev;
+
+	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!io) {
+		rc = -EINVAL;
+		goto out;
+	}
+	sm->region = io->start;
+
+	sm->apb2ser3_region = of_iomap(np, 1);
+	if (!sm->apb2ser3_region)
+		sm->apb2ser3_region = ioremap(APB2_SER3_PHY_ADDR,
+				APB2_SER3_PHY_SIZE);
+
+	/* Disable all memory controller interrupts */
+	mask = 0xffffffff;
+	ncr_write(sm->region, 0x414, 4, &mask);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		rc = irq;
+		goto out;
+	}
+
+	rc = devm_request_irq(&pdev->dev, irq, smmon_isr,
+			      IRQF_ONESHOT, dev_name(&pdev->dev), sm);
+	if (rc)
+		goto out;
+
+	rc = sysfs_create_group(&pdev->dev.kobj, &smmon_attr_group);
+	if (rc)
+		goto out;
+
+	dev_set_drvdata(&pdev->dev, sm);
+	pr_info("%s: Memory controller monitor\n", dev_name(&pdev->dev));
+
+	/* Enable memory controller interrupts. We need to disable the
+	 * interrupt while unmasking it, since otherwise there will be a
+	 * locking conflict in ncr_write/ncr_read when the ISR tries to read
+	 * interrupt status.
+	 */
+	disable_irq(irq);
+	mask = SM_INT_MASK;
+	ncr_write(sm->region, 0x414, 4, &mask);
+	enable_irq(irq);
+out:
+	return rc;
+}
+
+static int
+smmon_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &smmon_attr_group);
+	return 0;
+}
+
+static const struct of_device_id smmon_id_table[] = {
+	{ .compatible = "axxia,smmon" },
+	{ }
+};
+MODULE_DEVICE_TABLE(platform, smmon_id_table);
+
+static struct platform_driver smmon_driver = {
+	.driver = {
+		.name = "axxia-smmon",
+		.of_match_table = smmon_id_table
+	},
+	.probe = smmon_probe,
+	.remove = smmon_remove,
+};
+
+module_platform_driver(smmon_driver);
diff --git a/drivers/misc/lsi-mtc.c b/drivers/misc/lsi-mtc.c
deleted file mode 100644
index 354082b..0000000
--- a/drivers/misc/lsi-mtc.c
+++ /dev/null
@@ -1,4233 +0,0 @@
-/*
- *  Copyright (C) 2013 LSI Corporation
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  Device driver for LSI Master Test Controller (MTC), which is a test
- *  generator that is fully compliant with IEEE 1149.1 and can run JTAG test
- *  sequences on external devices. The device is accessed via a character
- *  device (/dev/mtc) through which test sequences can be loaded and exececuted
- *  by the controller.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <linux/fs.h>
-#include <linux/poll.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/mutex.h>
-#include <linux/atomic.h>
-#include <linux/io.h>
-#include <linux/string.h>
-#include <linux/delay.h>
-#include "linux/lsi_mtc_ioctl.h"
-
-
-/*
-   device tree node:
-
-   mtc@2010098000 {
-	   compatible = "lsi,mtc";
-	   reg = <0x20 0x10098000 0 0x3000>;
-	   interrupts = <0 45 4>;
-   };
-
- */
-
-/* MTC registers */
-struct mtc_regs {
-	u32 params;		/* 0x00 */
-	u32 scratch0;		/* 0x04 */
-	u32 scratch1;		/* 0x08 */
-	u32 reserved_0c[1];	/* 0x0c */
-	u32 config0;		/* 0x10 */
-	u32 config1;		/* 0x14 */
-	u32 reserved_18[2];	/* 0x18..0x1c */
-	u32 status1;		/* 0x20 */
-	u32 status2;		/* 0x24 */
-	u32 reserved_28[2];	/* 0x28..0x2c */
-	u32 execute;		/* 0x30 */
-	u32 reserved_34[3];	/* 0x34..0x3c */
-	u32 mem_init;		/* 0x40 */
-	u32 ecc_disable;	/* 0x44 */
-	u32 ecc_invert_en;	/* 0x48 */
-	u32 ecc_invert;		/* 0x4c */
-	u32 int_status;		/* 0x50 */
-	u32 int_enable;		/* 0x54 */
-	u32 int_force;		/* 0x58 */
-	u32 ecc_int_status;	/* 0x5c */
-	u32 ecc_int_enable;	/* 0x60 */
-	u32 ecc_int_force;	/* 0x64 */
-	u32 reserved_68[6];	/* 0x68..0x7c */
-	u32 debug0;		/* 0x80 */
-	u32 debug1;		/* 0x84 */
-	u32 debug2;		/* 0x88 */
-	u32 debug3;		/* 0x8c */
-	u32 debug4;		/* 0x90 */
-	u32 debug5;		/* 0x94 */
-	u32 reserved_98[2];	/* 0x98..0x9c */
-	u32 axi_config0;	/* 0x100 */
-	u32 axi_config1;	/* 0x104 */
-	u32 axi_config2;	/* 0x108 */
-	u32 axi_config3;	/* 0x10c */
-	u32 axi_config4;	/* 0x110 */
-	u32 axi_config5;	/* 0x114 */
-	u32 axi_config6;	/* 0x118 */
-	u32 axi_status0;	/* 0x200 */
-	u32 axi_status1;	/* 0x204 */
-	u32 axi_status2;	/* 0x208 */
-	u32 axi_status3;	/* 0x20c */
-};
-
-#define MTC_PRGMEM_OFFSET 0x1000
-#define MTC_TDOMEM_OFFSET 0x2000
-#define MTC_PRGMEM_SIZE 256	/* program memory size in words */
-#define MTC_TDOMEM_SIZE 256	/* tdo memory size in words */
-
-#ifdef __MTC_SIMULATION
-struct mtc_regs _mtc_regs;
-u32 _mtc_tdomem[256] = { 0x11110000, 0x22221111, 0x33332222 };
-u32 *_mtc_prgmem = _mtc_tdomem;
-#endif
-
-/******************************************************/
-/* register definitions generated from RDL */
-
-/******************************************************/
-
-   /* NODE 0x15d , TARGET 0xffffffff */
-
-#define     NCP_AXIS_MTC_MTC_INST_PARAMS0_REG_ADDR              (0x00000000)
-#define     NCP_AXIS_MTC_MTC_SCRATCH0_REG_ADDR                  (0x00000004)
-#define     NCP_AXIS_MTC_MTC_SCRATCH1_REG_ADDR                  (0x00000008)
-#define     NCP_AXIS_MTC_MTC_CONFIG0_REG_ADDR                   (0x00000010)
-#define     NCP_AXIS_MTC_MTC_CONFIG1_REG_ADDR                   (0x00000014)
-#define     NCP_AXIS_MTC_MTC_STATUS1_REG_ADDR                   (0x00000020)
-#define     NCP_AXIS_MTC_MTC_STATUS2_REG_ADDR                   (0x00000024)
-#define     NCP_AXIS_MTC_MTC_EXECUTE1_REG_ADDR                  (0x00000030)
-#define     NCP_AXIS_MTC_MTC_MEM_INIT_REG_ADDR                  (0x00000040)
-#define     NCP_AXIS_MTC_MTC_ECC_DISABLE_REG_ADDR               (0x00000044)
-#define     NCP_AXIS_MTC_MTC_ECC_INVERT_EN_REG_ADDR             (0x00000048)
-#define     NCP_AXIS_MTC_MTC_ECC_INVERT_REG_ADDR                (0x0000004c)
-#define     NCP_AXIS_MTC_MTC_DEBUG0_REG_ADDR                    (0x00000080)
-#define     NCP_AXIS_MTC_MTC_DEBUG1_REG_ADDR                    (0x00000084)
-#define     NCP_AXIS_MTC_MTC_DEBUG2_REG_ADDR                    (0x00000088)
-#define     NCP_AXIS_MTC_MTC_DEBUG3_REG_ADDR                    (0x0000008c)
-#define     NCP_AXIS_MTC_MTC_DEBUG4_REG_ADDR                    (0x00000090)
-#define     NCP_AXIS_MTC_MTC_DEBUG5_REG_ADDR                    (0x00000094)
-
-#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_BASE           (0x00001000)
-#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR(n)      (0x00001000 + (4*(n)))
-#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_COUNT          (0x00000100)
-#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_IDX(addr) \
-	(((addr) - NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_BASE) / 4)
-#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_END            (0x00001400)
-#define     NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_RANGE(addr) \
-	(((addr) >= NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_BASE) && \
-	((addr) < NCP_AXIS_MTC_MTC_PRGM_MEM_START_ADDR_END))
-
-#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_BASE    (0x00002000)
-#define   NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR(n) (0x00002000 + (4*(n)))
-#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_COUNT   (0x00000100)
-#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_IDX(addr) \
-	(((addr) - NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_BASE) / 4)
-#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_END     (0x00002400)
-#define     NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_RANGE(addr) \
-	(((addr) >= NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_BASE) && \
-	((addr) < NCP_AXIS_MTC_MTC_TDO_CAPTURE_MEM_START_ADDR_END))
-
-#define     NCP_AXIS_MTC_MTC_AXI_CFG0_REG_ADDR_5600             (0x00000100)
-#define     NCP_AXIS_MTC_MTC_AXI_CFG1_REG_ADDR_5600             (0x00000104)
-#define     NCP_AXIS_MTC_MTC_AXI_CFG2_REG_ADDR_5600             (0x00000108)
-#define     NCP_AXIS_MTC_MTC_AXI_CFG3_REG_ADDR_5600             (0x0000010c)
-#define     NCP_AXIS_MTC_MTC_AXI_CFG4_REG_ADDR_5600             (0x00000110)
-#define     NCP_AXIS_MTC_MTC_AXI_CFG5_REG_ADDR_5600             (0x00000114)
-#define     NCP_AXIS_MTC_MTC_AXI_CFG6_REG_ADDR_5600             (0x00000118)
-#define     NCP_AXIS_MTC_MTC_AXI_STATUS0_REG_ADDR_5600          (0x00000200)
-#define     NCP_AXIS_MTC_MTC_AXI_STATUS1_REG_ADDR_FIFO_STAT_5600  (0x00000204)
-#define     NCP_AXIS_MTC_MTC_AXI_STATUS2_REG_ADDR_5600          (0x00000208)
-#define     NCP_AXIS_MTC_MTC_AXI_STATUS3_REG_ADDR_5600          (0x0000020c)
-#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_STATUS                  (0x00000050)
-#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_STATUS_ALARM_MASK       (0x0000007f)
-#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_EN                      (0x00000054)
-#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_EN_ALARM_MASK           (0x0000007f)
-#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_FRC                     (0x00000058)
-#define     NCP_AXIS_MTC_MTC_TSTGEN_INT_FRC_ALARM_MASK          (0x0000007f)
-#define     NCP_AXIS_MTC_MTC_ECC_INT_STATUS                     (0x0000005c)
-#define     NCP_AXIS_MTC_MTC_ECC_INT_STATUS_ALARM_MASK          (0x0000000f)
-#define     NCP_AXIS_MTC_MTC_ECC_INT_EN                         (0x00000060)
-#define     NCP_AXIS_MTC_MTC_ECC_INT_EN_ALARM_MASK              (0x0000000f)
-#define     NCP_AXIS_MTC_MTC_ECC_INT_FRC                        (0x00000064)
-#define     NCP_AXIS_MTC_MTC_ECC_INT_FRC_ALARM_MASK             (0x0000000f)
-
-/*! @struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t
- *  @brief MTC Parameter Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 6 </td>
- *     <td width="20%" align="center"> 26 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_memory_size </td>
- *     <td width="20%" align="center"> 10 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Size of TDO record memory in bytes. </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 6 </td>
- *     <td width="20%" align="center"> 10 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_prgm_memory_size </td>
- *     <td width="20%" align="center"> 10 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Size of Test Program memory in bytes. </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:6;
-	unsigned tdo_memory_size:10;
-	unsigned reserved1:6;
-	unsigned tst_prgm_memory_size:10;
-#else	/* Little Endian */
-	unsigned tst_prgm_memory_size:10;
-	unsigned reserved1:6;
-	unsigned tdo_memory_size:10;
-	unsigned reserved0:6;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t
- *  @brief MTC Scratch 0 Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param scratchpad0 </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> SW read/write register - Not used by MTC hardware. </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_SCRATCH0_REG_ADDR_r_t {
-	unsigned int scratchpad0;
-};
-
-/*! @struct ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t
- *  @brief MTC Scratch 1 Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param scratchpad1 </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> SW read/write register - Not used by MTC hardware. </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_SCRATCH1_REG_ADDR_r_t {
-	unsigned int scratchpad1;
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t
- *  @brief MTC Config 0 Register
- *  @details Configuration/Control Registers for the MTC block
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 16 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_mpu_tdo_inactive_en </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 15 </td>
- *   <td width="30%"> 1) When Config mode Includes the AXM in the scan chain.
- *         1'b0 = MTC_TDO_ENB = 1'b1; TDO Output buffer always
- *        enabled.  1'b1 = MTC_TDO_ENB = JTC_TDO_ENB; TDO
- *        Output buffer follows the JTC control signal.  2)
- *        When Config mode Excludes the AXM in the scan chain.
- *        1'b0 = MTC_TDO_ENB = 1'b1; TDO Output buffer always
- *        enabled. 1'b1 = MTC_TDO_ENB = Active (1'b1) when in
- *        shift-DR or shift-IR states and inactive (1'b0) in
- *        all other states (tri-state capable).
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param loop_en </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 14 </td>
- *   <td width="30%"> 1'b1 = When an End-of-test command is received the
- *        test program will continue to execute from location
- *        0 of the memory instead of halting.   This assumes
- *        the test program fits within the 256 x 32 bit memory.
- *        1'b0 = In normal operation the MTC_TESTGEN block
- *        will loop through the 256 location program memory
- *        until an end-of-test command is detected.  Once
- *        detected the program will stop execution in its current
- *        state (Run/Test Idle, pause-IR, or pause-DR).
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param single_step_en </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> 1'b1 = Single step mode is enabled;  1'b0 = Single
- *        step mode is disabled (ignore writes to single_step
- *        one-shot register  Note: In single step mode the
- *        TACP state machine cannot stop in the Select-DR-Scan
- *        state waitng for the user to write the single_step
- *        one-shot register.  Therefore, the end-state-bit[28]
- *        value is ignored in this mode and always pauses in
- *        run-test/idle state.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param start_stopn </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 12 </td>
- *   <td width="30%"> 1'b1 = Run/Resume  1'b0 = Stop in current task </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *     <td width="20%" align="center"> 9 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param rate_sel </td>
- *     <td width="20%" align="center"> 5 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> TCK clock rate based off the internal clk_per clock
- *        rate (nominal value 200 MHz)  5'd0, others = TCK
- *        = Disable  5'd1 = TCK = 20.00 MHz (/10)  5'd2
- *        = TCK = 16.67 MHz (/12)  5'd3 = TCK = 14.28 MHz
- *        (/14)  5'd4 = TCK = 12.50 MHz (/16)  5'd5 =
- *        TCK = 11.11 MHz (/18)  5'd6 = TCK = 10.00 MHz (/20)
- *         5'd7 = TCK = 9.09 MHz (/22)  5'd8 = TCK = 8.33
- *        MHz (/24)  5'd9 = TCK = 7.14 MHz (/28)  5'd10
- *        = TCK = 6.25 MHz (/32)  5'd11 = TCK = 5.00 MHz
- *        (/40)  5'd12 = TCK = 4.00 MHz (/50)  5'd13 =
- *        TCK = 3.00 MHz (/66)  5'd14 = TCK = 2.00 MHz (/100)
- *         5'd15 = TCK = 1.00 MHz (/200)  5'd16 = TCK
- *        = 0.50 MHz (/400)
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved2 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param cfg_config_ctl </td>
- *     <td width="20%" align="center"> 3 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> 0,others,illegal=Board Test Mode  1=MTC Internal
- *        Test Mode - Not Supported in AXM  2=MTC External
- *        Mode (AXM Included) - Not Supported in AXM  3=MTC
- *        External Mode (AXM NOT Included)  4=MTC System Test
- *        Mode (AXM Included) - Not Supported in AXM  5=MTC
- *        System Test Mode (AXM NOT Included)  Note: The MTC
- *        hardware inhibits entering modes identifed as Not
- *        Supported when mtc_axm_selftst_disable control bit
- *        = 1.  If a Not Supported mode is programmed the
- *        device will default to the Board Test Mode.
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:16;
-	unsigned mtc_mpu_tdo_inactive_en:1;
-	unsigned loop_en:1;
-	unsigned single_step_en:1;
-	unsigned start_stopn:1;
-	unsigned reserved1:3;
-	unsigned rate_sel:5;
-	unsigned reserved2:1;
-	unsigned cfg_config_ctl:3;
-#else				/* Little Endian */
-	unsigned cfg_config_ctl:3;
-	unsigned reserved2:1;
-	unsigned rate_sel:5;
-	unsigned reserved1:3;
-	unsigned start_stopn:1;
-	unsigned single_step_en:1;
-	unsigned loop_en:1;
-	unsigned mtc_mpu_tdo_inactive_en:1;
-	unsigned reserved0:16;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t
- *  @brief MTC Config 1 Register
- *  @details TDO Capture and TCK Gapped Clock Control Signals
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 26 </td>
- *     <td width="20%" align="center"> 6 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param record_tdo_in_shift_ir_state </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 5 </td>
- *   <td width="30%"> 1'b1=Capture TDI Input data when in shift-IR state,
- *         1'b0=Don't Capture data in shift-IR state.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param record_tdo_in_shift_dr_state </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> 1'b1=Capture TDI Input data when in shift-DR state,
- *         1'b0=Don't Capture data in shift-DR state.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param sw_gate_tck_test_logic_reset </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> 1'b1=Gap TCK output clock in Test-Logic-Reset State
- *        and start_stopn = STOP(1'b0) Only;  1'b0=Don't Gap
- *        TCK clock
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param sw_gate_tck </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> 1'b1=Gap TCK output clock in all TAPC states;  1'b0=Don't
- *        Gap TCK clock
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:26;
-	unsigned record_tdo_in_shift_ir_state:1;
-	unsigned record_tdo_in_shift_dr_state:1;
-	unsigned reserved1:2;
-	unsigned sw_gate_tck_test_logic_reset:1;
-	unsigned sw_gate_tck:1;
-#else				/* Little Endian */
-	unsigned sw_gate_tck:1;
-	unsigned sw_gate_tck_test_logic_reset:1;
-	unsigned reserved1:2;
-	unsigned record_tdo_in_shift_dr_state:1;
-	unsigned record_tdo_in_shift_ir_state:1;
-	unsigned reserved0:26;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t
- *  @brief MTC Status 1 Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_record_ram_bit_counter </td>
- *     <td width="20%" align="center"> 14 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Number of Valid Bits in the TDO capture memory </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_record_ram_last_addr </td>
- *     <td width="20%" align="center"> 8 </td>
- *     <td width="20%" align="center"> 8 </td>
- *   <td width="30%"> Last address within the TDO capture memory that contains
- *        valid data.  Addresses are filled started at bit
- *        location 0 (MSB) -> 31(LSB); address 1, bit 0 -> 31,
- *        ...
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param prgm_mem_rd_addr </td>
- *     <td width="20%" align="center"> 8 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Next Address to be read from program memory  In
- *        the pause state this address should be written with
- *        the next task to be processed
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:2;
-	unsigned tdo_record_ram_bit_counter:14;
-	unsigned tdo_record_ram_last_addr:8;
-	unsigned prgm_mem_rd_addr:8;
-#else				/* Little Endian */
-	unsigned prgm_mem_rd_addr:8;
-	unsigned tdo_record_ram_last_addr:8;
-	unsigned tdo_record_ram_bit_counter:14;
-	unsigned reserved0:2;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t
- *  @brief MTC Status 2 Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_cmpl_enablen </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *   <td width="30%"> 1'b0=Disable MTC Block from Driving JTAG primary IO,
- *         1'b1=Allow cfg_config_ctl[2:0] register to select
- *        the mode of the MTC block.  Note: Control signal
- *        from primary device input pin.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_axm_selftst_disable </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> 1'b1=Disable all MTC configuration modes that allow
- *        access to the internal JTC controller.  1'b0=Allow
- *        all modes.  Note: Control signal from internal EFUSE
- *        module.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 12 </td>
- *     <td width="20%" align="center"> 18 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_task_error </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 17 </td>
- *   <td width="30%"> Fatal Error Detected while Processing a Task resulting
- *        in the MTC block halting.  Once the program is fixed
- *        a SW reset is needed to restart the block.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_gen_state_error </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Fatal Error Detected while Processing a Task resulting
- *        in the MTC block halting.  Once the program is fixed
- *        a SW reset is needed to restart the block.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 15 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftir_tck_off </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 14 </td>
- *   <td width="30%"> TAPC paused in pause-IR state with the TCK clock off
- *        to allow reloading of TESTGEN memory with more instruction
- *        data. The one-shot cont_after_pause, single_step or
- *        the sw_reset register must be written to exit this
- * state. pause_in_shiftir
- *               = (curr_task_load_jtag_instr_reg_and_pause_in_pause_ir
- * | curr_task_load_jtag_instr_reg_continue_from_pause_ir
- * | curr_task_load_jtag_instr_reg_continue_from_pause_ir_and_stop_in_pause_ir)
- *        && curr_tapc_pause_IR) & curr_task_gap_tck_en;
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftdr_tck_off </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> TAPC paused in pause-DR state with the TCK clock off
- *        to allow reloading of TESTGEN memory with more data.
- *        The one-shot cont_after_pause, single_step or the
- *        sw_reset register must be written to exit this state.
- *        pause_in_shiftdr = (curr_task_load_jtag_data_reg_and_pause_in_pause_dr
- *        | curr_task_load_jtag_data_reg_continue_from_pause_dr
- *  | curr_task_load_jtag_data_reg_continue_from_pause_dr_and_stop_in_pause_dr)
- *        && curr_tapc_pause_DR) & curr_task_gap_tck_en;
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_run_test_idle_tck_off </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 12 </td>
- *   <td width="30%"> TESTGEN State Machine is Paused in the Run-Test/Idle
- *        state because TCK clock is gapped.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_test_logic_reset_tck_off </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 11 </td>
- *   <td width="30%"> TESTGEN State Machine is Paused in the Test-Logic-Reset
- *        state because TCK clock is gapped.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param testgen_state_machine_paused </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 10 </td>
- *   <td width="30%"> TESTGEN state machine is paused - valid in single
- *        step mode and pause modes
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 9 </td>
- *   <td width="30%"> TAPC paused in pause-IR state to allow reloading of
- *        TESTGEN memory with more instruction data.  The
- *        one-shot cont_after_pause, single_step or the sw_reset
- *        register must be written to exit this state.  pause_in_shiftir
- *        =  (curr_task_load_jtag_instr_reg_and_pause_in_pause_ir
- *        | curr_task_load_jtag_instr_reg_continue_from_pause_ir
- * | curr_task_load_jtag_instr_reg_continue_from_pause_ir_and_stop_in_pause_ir)
- *        && curr_tapc_pause_IR);
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftdr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 8 </td>
- *   <td width="30%"> TAPC paused in pause-DR state to allow reloading of
- *        TESTGEN memory with more data.  The one-shot cont_after_pause,
- *        single_step or the sw_reset register must be written
- *   to exit this state.  pause_in_shiftdr
-*           =  (curr_task_load_jtag_data_reg_and_pause_in_pause_dr
- *        | curr_task_load_jtag_data_reg_continue_from_pause_dr
- *  | curr_task_load_jtag_data_reg_continue_from_pause_dr_and_stop_in_pause_dr)
- *        && curr_tapc_pause_DR);
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_inst_i </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Current task value. </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved2 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_end_of_test </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Test Finished </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_pause_in_run_test_idle_state </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Pause Bit </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param start_stopn </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Busy Bit </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_STATUS2_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned mtc_cmpl_enablen:1;
-	unsigned mtc_axm_selftst_disable:1;
-	unsigned reserved0:12;
-	unsigned nxt_task_error:1;
-	unsigned tst_gen_state_error:1;
-	unsigned reserved1:1;
-	unsigned pause_in_shiftir_tck_off:1;
-	unsigned pause_in_shiftdr_tck_off:1;
-	unsigned pause_in_run_test_idle_tck_off:1;
-	unsigned pause_in_test_logic_reset_tck_off:1;
-	unsigned testgen_state_machine_paused:1;
-	unsigned pause_in_shiftir:1;
-	unsigned pause_in_shiftdr:1;
-	unsigned curr_task_inst_i:4;
-	unsigned reserved2:1;
-	unsigned curr_task_end_of_test:1;
-	unsigned curr_task_pause_in_run_test_idle_state:1;
-	unsigned start_stopn:1;
-#else				/* Little Endian */
-	unsigned start_stopn:1;
-	unsigned curr_task_pause_in_run_test_idle_state:1;
-	unsigned curr_task_end_of_test:1;
-	unsigned reserved2:1;
-	unsigned curr_task_inst_i:4;
-	unsigned pause_in_shiftdr:1;
-	unsigned pause_in_shiftir:1;
-	unsigned testgen_state_machine_paused:1;
-	unsigned pause_in_test_logic_reset_tck_off:1;
-	unsigned pause_in_run_test_idle_tck_off:1;
-	unsigned pause_in_shiftdr_tck_off:1;
-	unsigned pause_in_shiftir_tck_off:1;
-	unsigned reserved1:1;
-	unsigned tst_gen_state_error:1;
-	unsigned nxt_task_error:1;
-	unsigned reserved0:12;
-	unsigned mtc_axm_selftst_disable:1;
-	unsigned mtc_cmpl_enablen:1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t
- *  @brief MTC EXECUTE Register - One-Shot Registers
- *  @details Self Clearing Bits
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 27 </td>
- *     <td width="20%" align="center"> 5 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_flush_capture_data </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Write to 1 to force the MTC TDO CAPTURE state machine
- *        to write any remaining data to memory. This signal
- *        would be written before the tdo_capture_reset bit
- *        is set.  Self clearing bit.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_capture_reset </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Write to 1 to reset the MTC TDO CAPTURE state machine.
- *        All variables set to zero (memory write address, tdo
- *        capture bit count, etc).  Self clearing bit.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param sw_reset </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Write to 1 to reset the MTC TESTGEN, MTC TDO CAPTURE
- *        state machines and to recover from the state machine
- *        haulting due to a command error.  Self clearing
- *        bit.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param cont_after_pause </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Write to 1 to allow the MTC TESTGEN state machine
- *        to continue from the pause-IR or pause-DR states.
- *         Self clearing bit.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param single_step </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Write to 1 to allow the MTC_TESTGEN state machine
- *        to process the next command.  In the single step
- *        mode the state machine will stop after each task is
- *        processed.  Self clearing bit.
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:27;
-	unsigned tdo_flush_capture_data:1;
-	unsigned tdo_capture_reset:1;
-	unsigned sw_reset:1;
-	unsigned cont_after_pause:1;
-	unsigned single_step:1;
-#else				/* Little Endian */
-	unsigned single_step:1;
-	unsigned cont_after_pause:1;
-	unsigned sw_reset:1;
-	unsigned tdo_capture_reset:1;
-	unsigned tdo_flush_capture_data:1;
-	unsigned reserved0:27;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t
- *  @brief MTC MEM Init Register
- *  @details Registers to Control Initializing the TDO Capture and TESTPROG memories
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 21 </td>
- *     <td width="20%" align="center"> 11 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_capture_mem_ini_value </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 10 </td>
- *   <td width="30%"> Memory init value for capture memory </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_capture_mem_do_mem_init </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 9 </td>
- *   <td width="30%"> Do memory initialization. When set, the capture memory
- *        is initialized to either zero or one depending
- *        on tdo_capture_mem_ini_value value by hardware. This
- *        bit clears itself one cycle after being set
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_capture_mem_init_done </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 8 </td>
- *   <td width="30%"> Memory initialization done. When set, the program
- *        memory has been initialized to zero or one by hardware
- *        following setting the tst_prgm_mem_do_mem_init bit
- *        and tst_prgm_mem_ini_value of this register.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 5 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_prgm_mem_ini_value </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Memory init value for program memory </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_prgm_mem_do_mem_init </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Do memory initialization. When set, the program memory
- *        is initialized to either all zero or ones depending
- *        on tst_prgm_mem_ini_value value by hardware. This
- *        bit clears itself one cycle after being set
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_prgm_mem_init_done </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Memory initialization done. When set, the program
- *        memory has been initialized to zero or one by hardware
- *        following setting  the tst_prgm_mem_do_mem_init
- *        bit and tst_prgm_mem_ini_value of this register.
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_MEM_INIT_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:21;
-	unsigned tdo_capture_mem_ini_value:1;
-	unsigned tdo_capture_mem_do_mem_init:1;
-	unsigned tdo_capture_mem_init_done:1;
-	unsigned reserved1:5;
-	unsigned tst_prgm_mem_ini_value:1;
-	unsigned tst_prgm_mem_do_mem_init:1;
-	unsigned tst_prgm_mem_init_done:1;
-#else				/* Little Endian */
-	unsigned tst_prgm_mem_init_done:1;
-	unsigned tst_prgm_mem_do_mem_init:1;
-	unsigned tst_prgm_mem_ini_value:1;
-	unsigned reserved1:5;
-	unsigned tdo_capture_mem_init_done:1;
-	unsigned tdo_capture_mem_do_mem_init:1;
-	unsigned tdo_capture_mem_ini_value:1;
-	unsigned reserved0:21;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t
- *  @brief MTC MEM Init Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 30 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param disable_ecc_mtc_tst_prgm_mem </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> This bit disables the ECC correction for mtc_tst_prgm_mem
- *        memory.
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param disable_ecc_mtc_tdo_record_mem </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- * <td width="30%"> This bit disables the ECC correction for mtc_tdo_record_mem
- *        memory.
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_ECC_DISABLE_REG_ADDR_r_t {
-
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:30;
-	unsigned disable_ecc_mtc_tst_prgm_mem:1;
-	unsigned disable_ecc_mtc_tdo_record_mem:1;
-#else				/* Little Endian */
-	unsigned disable_ecc_mtc_tdo_record_mem:1;
-	unsigned disable_ecc_mtc_tst_prgm_mem:1;
-	unsigned reserved0:30;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t
- *  @brief MTC MEM Invert Enable ECC Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 30 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_invert_en_mtc_tst_prgm_mem </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> ECC invert enable for mtc_tst_prgm_mem memory. </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_invert_en_tc_tdo_record_mem </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> ECC invert enable for mtc_tdo_record memory. </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_ECC_INVERT_EN_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:30;
-	unsigned ecc_invert_en_mtc_tst_prgm_mem:1;
-	unsigned ecc_invert_en_tc_tdo_record_mem:1;
-#else				/* Little Endian */
-	unsigned ecc_invert_en_tc_tdo_record_mem:1;
-	unsigned ecc_invert_en_mtc_tst_prgm_mem:1;
-	unsigned reserved0:30;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t
- *  @brief MTC MEM Invert ECC Register
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 25 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_invert_reg </td>
- *     <td width="20%" align="center"> 7 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Each memory type uses appropriate number of bits in
- *        this field starting from right to left.   Set one
- *        bit to cause a single bit error, two bits to cause
- *        a double bit error.
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_ECC_INVERT_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:25;
-	unsigned ecc_invert_reg:7;
-#else				/* Little Endian */
-	unsigned ecc_invert_reg:7;
-	unsigned reserved0:25;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t
- *  @brief MTC Debug0 Register
- *  @details DEBUG0: Current Task Values
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_testgen_tdo_inactive_enb </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *   <td width="30%"> When mtc_mpu_tdo_inactive_en control signal is active
- *        (1'b1) this signal is used to control the TDO output
- *        buffer tri-state control input.  1'b1 = TDO Output
- *        Buffer Active;  1'b0 = TDO Output Buffer Inactive
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_gap_tck_en </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> 1'b1 = Gap TCK clock in end state;  1'b0 = Don't
- *        Gap TCK clock in end state
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_tck_ctl_i </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 29 </td>
- *   <td width="30%"> Current TASK TCK Control Value </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_end_state_ctl_i </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 28 </td>
- *   <td width="30%"> 1'b1 = Start Next Command from the Select-DR-Scan
- *        State (Clock cannot be stopped)  1'b0 = Go to Run-test/Idle
- *        State - Pause only if Gap TCK Clock active
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 26 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_ctl_i </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 24 </td>
- *   <td width="30%"> Current Task control values </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *     <td width="20%" align="center"> 21 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_tstgen_tdi_cnt30 </td>
- *     <td width="20%" align="center"> 5 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Next Shift Cnt value </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved2 </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 12 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param task_sub_state </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 8 </td>
- *   <td width="30%"> TESTGEN state Machine subtask counter </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved3 </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_task_inst_i </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Next Task Command Value </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_DEBUG0_REG_ADDR_r_t {
-
-#ifdef NCP_BIG_ENDIAN
-	unsigned mtc_testgen_tdo_inactive_enb:1;
-	unsigned curr_task_gap_tck_en:1;
-	unsigned curr_task_tck_ctl_i:1;
-	unsigned curr_task_end_state_ctl_i:1;
-	unsigned reserved0:2;
-	unsigned curr_task_ctl_i:2;
-	unsigned reserved1:3;
-	unsigned nxt_tstgen_tdi_cnt30:5;
-	unsigned reserved2:4;
-	unsigned task_sub_state:4;
-	unsigned reserved3:4;
-	unsigned nxt_task_inst_i:4;
-#else				/* Little Endian */
-	unsigned nxt_task_inst_i:4;
-	unsigned reserved3:4;
-	unsigned task_sub_state:4;
-	unsigned reserved2:4;
-	unsigned nxt_tstgen_tdi_cnt30:5;
-	unsigned reserved1:3;
-	unsigned curr_task_ctl_i:2;
-	unsigned reserved0:2;
-	unsigned curr_task_end_state_ctl_i:1;
-	unsigned curr_task_tck_ctl_i:1;
-	unsigned curr_task_gap_tck_en:1;
-	unsigned mtc_testgen_tdo_inactive_enb:1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t
- *  @brief MTC Debug1 Register
- *  @details DEBUG1: Current TASK Being Processed
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_no_operation </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *<td width="30%"> Current task being processed is No Operation(4'b0000) </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_test_reset_1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> Current task being processed is Test reset 1 (TRSTZ
- *        low for x TCK cycles - 4'b0001)
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_test_reset_2 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 29 </td>
- *   <td width="30%"> Current task being processed is Test reset 2 (TMS
- *        high for x TCK cycles) - 4'b0010
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_load_jtag_inst_reg </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 28 </td>
- *   <td width="30%"> Current task being processed is Load JTAG instruction
- *        register
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_load_jtag_data_reg </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 27 </td>
- *<td width="30%"> Current task being processed is Load JTAG data register </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_mtc_reserved_task_id_5 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 26 </td>
- *   <td width="30%"> Reserved Task value - Illegal - 4'b0101 </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_mtc_reserved_task_id_6 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 25 </td>
- *   <td width="30%"> Reserved Task value - Illegal - 4'b0110 </td>
- * </tr>
- *   <tr>
- * <td width="30%">
- * @param curr_task_wait_in_run_test_idle_state_xtck_cycles </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 24 </td>
- *   <td width="30%"> Current task being processed is Wait in Run-Test-Idle
- *        state a number of TCK cycles - 4'b1010
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_pause_in_run_test_idle_state </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 23 </td>
- *   <td width="30%"> Current task being processed is Pause in Run-Test-Idle
- *        State - 4'b1011
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_end_of_test </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 22 </td>
- *<td width="30%"> Current task being processed is End of Test - 4'b1100 </td>
- * </tr>
- *   <tr>
- *<td width="30%"> @param
- *   curr_task_load_jtag_data_reg_and_pause_in_pause_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 21 </td>
- *   <td width="30%"> Current task being processed is Load JTAG Data Register
- *        and pause in pause-DR state - 4'b0111
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param
- *  curr_task_load_jtag_data_reg_continue_from_pause_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 20 </td>
- *   <td width="30%"> Current task being processed is Load JTAG Data Register
- *        (continue from pause-DR state) - 4'b1000
- *   </td>
- * </tr>
- *   <tr>
- * <td width="30%"> @param
-*curr_task_load_jtag_data_reg_continue_from_pause_dr_and_stop_in_pause_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 19 </td>
- *   <td width="30%"> Current task being processed is Load JTAG Data Register
- *        (continue from pause-DR state and end in pause-DR
- *        state - 4'b1001
- *   </td>
- * </tr>
- *   <tr>
- *<td width="30%"> @param
- *  curr_task_load_jtag_inst_reg_and_pause_in_pause_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 18 </td>
- *   <td width="30%"> Current task being processed is Load JTAG Instruction
- *        Register and pause in pause-IR state - 4'b1101
- *   </td>
- * </tr>
- *   <tr>
- * <td width="30%"> @param
- *  curr_task_load_jtag_inst_reg_continue_from_pause_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 17 </td>
- *   <td width="30%"> Current task being processed is Load JTAG Instruction
- *        Register (continue from pause-IR state) - 4'b1110
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param
-*curr_task_load_jtag_inst_reg_continue_from_pause_ir_and_stop_in_pause_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Current task being processed is Load JTAG Instruction
- *        Register (continue from pause-IR state and end in
- *        pause-IR state - 4'b1111
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 12 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_inst_i </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 8 </td>
- *   <td width="30%"> Value of current task being processed </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param prgm_mem_rd_addr </td>
- *     <td width="20%" align="center"> 8 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Address of memory location to be read from program
- *        memory
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_DEBUG1_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned curr_task_no_operation:1;
-	unsigned curr_task_test_reset_1:1;
-	unsigned curr_task_test_reset_2:1;
-	unsigned curr_task_load_jtag_inst_reg:1;
-	unsigned curr_task_load_jtag_data_reg:1;
-	unsigned curr_task_mtc_reserved_task_id_5:1;
-	unsigned curr_task_mtc_reserved_task_id_6:1;
-	unsigned curr_task_wait_in_run_test_idle_state_xtck_cycles:1;
-	unsigned curr_task_pause_in_run_test_idle_state:1;
-	unsigned curr_task_end_of_test:1;
-	unsigned curr_task_load_jtag_data_reg_and_pause_in_pause_dr:1;
-	unsigned curr_task_load_jtag_data_reg_continue_from_pause_dr:1;
-	unsigned stop_in_pause_dr:1;
-	unsigned curr_task_load_jtag_inst_reg_and_pause_in_pause_ir:1;
-	unsigned curr_task_load_jtag_inst_reg_continue_from_pause_ir:1;
-	unsigned stop_in_pause_ir:1;
-	unsigned reserved0:4;
-	unsigned curr_task_inst_i:4;
-	unsigned prgm_mem_rd_addr:8;
-#else				/* Little Endian */
-	unsigned prgm_mem_rd_addr:8;
-	unsigned curr_task_inst_i:4;
-	unsigned reserved0:4;
-	unsigned stop_in_pause_ir:1;
-	unsigned curr_task_load_jtag_inst_reg_continue_from_pause_ir:1;
-	unsigned curr_task_load_jtag_inst_reg_and_pause_in_pause_ir:1;
-	unsigned stop_in_pause_dr:1;
-	unsigned curr_task_load_jtag_data_reg_continue_from_pause_dr:1;
-	unsigned curr_task_load_jtag_data_reg_and_pause_in_pause_dr:1;
-	unsigned curr_task_end_of_test:1;
-	unsigned curr_task_pause_in_run_test_idle_state:1;
-	unsigned curr_task_wait_in_run_test_idle_state_xtck_cycles:1;
-	unsigned curr_task_mtc_reserved_task_id_6:1;
-	unsigned curr_task_mtc_reserved_task_id_5:1;
-	unsigned curr_task_load_jtag_data_reg:1;
-	unsigned curr_task_load_jtag_inst_reg:1;
-	unsigned curr_task_test_reset_2:1;
-	unsigned curr_task_test_reset_1:1;
-	unsigned curr_task_no_operation:1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t
- *  @brief MTC Debug2 Register
- *  @details Current TAPC
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_update_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *   <td width="30%"> Current TAPC State is UPDATE-IR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_exit2_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> Current TAPC State is EXIT2-IR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_pause_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 29 </td>
- *   <td width="30%"> Current TAPC State is PAUSE-IR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_exit1_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 28 </td>
- *   <td width="30%"> Current TAPC State is EXIT1-IR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_shift_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 27 </td>
- *   <td width="30%"> Current TAPC State is SHIFT-IR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_capture_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 26 </td>
- *   <td width="30%"> Current TAPC State is CAPTURE-IR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_update_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 25 </td>
- *   <td width="30%"> Current TAPC State is UPDATE-DR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_exit2_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 24 </td>
- *   <td width="30%"> Current TAPC State is EXIT2-DR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_pause_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 23 </td>
- *   <td width="30%"> Current TAPC State is PAUSE-DR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_exit1_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 22 </td>
- *   <td width="30%"> Current TAPC State is EXIT1-DR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_shift_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 21 </td>
- *   <td width="30%"> Current TAPC State is SHIFT-DR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_capture_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 20 </td>
- *   <td width="30%"> Current TAPC State is CAPTURE-DR </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_select_ir_scan </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 19 </td>
- *   <td width="30%"> Current TAPC State is SELECT-IR-SCAN </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_select_dr_scan </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 18 </td>
- *   <td width="30%"> Current TAPC State is SELECT-DR-SCAN </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_run_test_idle </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 17 </td>
- *   <td width="30%"> Current TAPC State is RUN-TEST_IDLE </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_tapc_test_logic_reset </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Current TAPC State is TEST-LOGIC-RESET </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 12 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tapc_state </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Current TAPC state value </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_DEBUG2_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned curr_tapc_update_ir:1;
-	unsigned curr_tapc_exit2_ir:1;
-	unsigned curr_tapc_pause_ir:1;
-	unsigned curr_tapc_exit1_ir:1;
-	unsigned curr_tapc_shift_ir:1;
-	unsigned curr_tapc_capture_ir:1;
-	unsigned curr_tapc_update_dr:1;
-	unsigned curr_tapc_exit2_dr:1;
-	unsigned curr_tapc_pause_dr:1;
-	unsigned curr_tapc_exit1_dr:1;
-	unsigned curr_tapc_shift_dr:1;
-	unsigned curr_tapc_capture_dr:1;
-	unsigned curr_tapc_select_ir_scan:1;
-	unsigned curr_tapc_select_dr_scan:1;
-	unsigned curr_tapc_run_test_idle:1;
-	unsigned curr_tapc_test_logic_reset:1;
-	unsigned reserved0:12;
-	unsigned tapc_state:4;
-#else				/* Little Endian */
-	unsigned tapc_state:4;
-	unsigned reserved0:12;
-	unsigned curr_tapc_test_logic_reset:1;
-	unsigned curr_tapc_run_test_idle:1;
-	unsigned curr_tapc_select_dr_scan:1;
-	unsigned curr_tapc_select_ir_scan:1;
-	unsigned curr_tapc_capture_dr:1;
-	unsigned curr_tapc_shift_dr:1;
-	unsigned curr_tapc_exit1_dr:1;
-	unsigned curr_tapc_pause_dr:1;
-	unsigned curr_tapc_exit2_dr:1;
-	unsigned curr_tapc_update_dr:1;
-	unsigned curr_tapc_capture_ir:1;
-	unsigned curr_tapc_shift_ir:1;
-	unsigned curr_tapc_exit1_ir:1;
-	unsigned curr_tapc_pause_ir:1;
-	unsigned curr_tapc_exit2_ir:1;
-	unsigned curr_tapc_update_ir:1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t
- *  @brief MTC Debug3 Register
- *  @details TDO Data
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_tdi_shift_data_d </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *   <td width="30%"> TDO value output on the next falling edge of the TCK
- *        clock - nxt_tdi_shift_data_d[0]
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_tdi_shift_data </td>
- *     <td width="20%" align="center"> 30 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Next Data to be shifted out </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_DEBUG3_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned nxt_tdi_shift_data_d:1;
-	unsigned reserved0:1;
-	unsigned nxt_tdi_shift_data:30;
-#else				/* Little Endian */
-	unsigned nxt_tdi_shift_data:30;
-	unsigned reserved0:1;
-	unsigned nxt_tdi_shift_data_d:1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t
- *  @brief MTC Debug4 Register
- *  @details Next Task Value
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_task_inst_i </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Next TASK to be processed </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_DEBUG4_REG_ADDR_r_t {
-	unsigned int nxt_task_inst_i;
-};
-
-/*! @struct ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t
- *  @brief MTC Debug5 Register
- *  @details Shift Count Value
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 6 </td>
- *     <td width="20%" align="center"> 26 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param delay_shift_cnt </td>
- *     <td width="20%" align="center"> 26 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Data shift value </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_DEBUG5_REG_ADDR_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:6;
-	unsigned delay_shift_cnt:26;
-#else				/* Little Endian */
-	unsigned delay_shift_cnt:26;
-	unsigned reserved0:6;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t
- *  @brief MTC Test Program Memory
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param tst_prgm </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> TESTGEN program memory  Task1 Format: [31:30]=2'b10,
- *        [29]=TCK Action, [28]=0, [27:4]=Unused, [3:0]=Inst
- *        Code  Task2 Format: [31:30]=2'b10, [29:16]=Not Used,
- *        [15:4]=TCK Cycles., [3:0]=Inst Code  Task3 Format:
- *        [31:30]=2'b10, [29:4]=TCK Cycles., [3:0]=Inst Code
- *         Task4 Format_1: [31:30]=2'b11, [29]=TCK Action,
- *        [28]=End State, [27:16]=Data Shift,  [15:4]=Inst
- *        Shift, [3:0]=Inst Code  Task4 Format_2: [31:30]=2'b01,
- *        [29:0]=TDI Data (more data to Follow).  Task4 Format_3:
- *        [31:30]=2'b00, [29:0]=TDI Data (LAST data).
- *        TASK defintions:Value:Description:TCK [29]:End-State
- *        [28]:Task Format:One-Shot used to release from PAUSE
- *        state  4'b0000:	No operation - Should not be used
- *        in programs.:NA:NA:1:NO  4'b0001:	Generate test
- *        reset 1 (TRSTZ low for x TCK cycles):NA:NA:2:NO
- *        4'b0010:	Generate test reset 2 (TMS high for x TCK
- *        cycles):NA:NA:2:NO  4'b0011:	Load JTAG instruction
- *        register:YES:YES:4:YES  4'b0100:	Load JTAG data
- *        register:YES:YES:4:YES  4'b0101:	Reserved State:-:-:-:-
- *         4'b0110:	Reserved State:-:-:-:-  4'b0111:	Load
- *        JTAG data register and pause in pause-dr:YES:NA:4:YES
- *         4'b1000:	Load JTAG data register (continue from
- *        pause-dr):YES:YES:4:YES  4'b1001:	Load JTAG data
- *        register (continue from pause-dr and stop in pause-dr):
- *                  YES:YES:4:YES
- *         4'b1010:	Wait in Run-Test-Idle state a number of
- *        TCK cycles:NA:NA:3:NO  4'b1011:	Pause in Run-Test-Idle
- *        state:YES:0:1:YES  4'b1100:	End of test:YES:0:1:NO
- *         4'b1101:	Load JTAG instruction register and pause
- *        in pause-ir:YES:NA:4:YES  4'b1110:	Load JTAG instruction
- *        register (continue from pause-ir):YES:YES:4:YES
- *        4'b1111:	Load JTAG instruction register (continue
- *        from pause-ir and stop in pause-ir):YES:YES:4:YES
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_PRGM_MEM_START_ADDR_r_t {
-	unsigned int tst_prgm;
-};
-
-/*! @struct ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t
- *  @brief MTC TDO capture Memory Program Memory
- *  @details null
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_capture </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> TDI capture memory - Data is right justified when
- *        written to the memory
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t
- *
- */
-
-struct ncp_axis_mtc_MTC_TDO_CAPTURE_MEM_START_ADDR_r_t {
-
-	unsigned int tdo_capture;
-};
-
-/*! @struct ncp_axis_mtc_mtc_tstgen_int_status_r_t
- *  @brief Interrupt Status Register
- *  @details This register holds interrupt status
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_mtc_tstgen_int_status_r_t\n
- *   </td>(
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 25 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_record_ram_addr_overflow_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 6 </td>
- *   <td width="30%"> The TDO Capture memory overflowed. Data is lost when
- *        this alarm occurs. Status
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_task_error_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 5 </td>
- *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
- *        state machine is halted at that failure.  The errored
- *        task must be fixed and the sw_reset signal written
- *        to restart the test. Status
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_gen_state_error_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
- *        state machine is halted at the failure.  The errored
- *        task must be fixed and the sw_reset signal written
- *        to restart the test. Status
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param cont_after_pause_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Active anytime the TESTGEN state machine is paused.
- *        A write to cont_after_pause or single_step one-shot
- *        registers will release the state machine from the
- *        paused state. Status
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftir_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Paused in Shift-IR state Status </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftdr_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Paused in Shift-DR state Status </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_end_of_test_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> In End-of-Test Task Status </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_tstgen_int_status_r_t
- *
- */
-
-struct ncp_axis_mtc_mtc_tstgen_int_status_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:25;
-	unsigned tdo_record_ram_addr_overflow_os:1;
-	unsigned nxt_task_error_os:1;
-	unsigned tst_gen_state_error_os:1;
-	unsigned cont_after_pause_os:1;
-	unsigned pause_in_shiftir_os:1;
-	unsigned pause_in_shiftdr_os:1;
-	unsigned curr_task_end_of_test_os:1;
-#else				/* Little Endian */
-	unsigned curr_task_end_of_test_os:1;
-	unsigned pause_in_shiftdr_os:1;
-	unsigned pause_in_shiftir_os:1;
-	unsigned cont_after_pause_os:1;
-	unsigned tst_gen_state_error_os:1;
-	unsigned nxt_task_error_os:1;
-	unsigned tdo_record_ram_addr_overflow_os:1;
-	unsigned reserved0:25;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_mtc_tstgen_int_en_r_t
- *  @brief Interrupt Enable Register
- *  @details This register enables interrupts
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_mtc_tstgen_int_en_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 25 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_record_ram_addr_overflow_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 6 </td>
- *   <td width="30%"> The TDO Capture memory overflowed. Data is lost when
- *        this alarm occurs. Enable
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_task_error_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 5 </td>
- *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
- *        state machine is halted at that failure.  The errored
- *        task must be fixed and the sw_reset signal written
- *        to restart the test. Enable
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_gen_state_error_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
- *        state machine is halted at the failure.  The errored
- *        task must be fixed and the sw_reset signal written
- *        to restart the test. Enable
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param cont_after_pause_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Active anytime the TESTGEN state machine is paused.
- *        A write to cont_after_pause or single_step one-shot
- *        registers will release the state machine from the
- *        paused state. Enable
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftir_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Paused in Shift-IR state Enable </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftdr_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Paused in Shift-DR state Enable </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_end_of_test_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> In End-of-Test Task Enable </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_tstgen_int_en_r_t
- *
- */
-
-struct ncp_axis_mtc_mtc_tstgen_int_en_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:25;
-	unsigned tdo_record_ram_addr_overflow_os:1;
-	unsigned nxt_task_error_os:1;
-	unsigned tst_gen_state_error_os:1;
-	unsigned cont_after_pause_os:1;
-	unsigned pause_in_shiftir_os:1;
-	unsigned pause_in_shiftdr_os:1;
-	unsigned curr_task_end_of_test_os:1;
-#else				/* Little Endian */
-	unsigned curr_task_end_of_test_os:1;
-	unsigned pause_in_shiftdr_os:1;
-	unsigned pause_in_shiftir_os:1;
-	unsigned cont_after_pause_os:1;
-	unsigned tst_gen_state_error_os:1;
-	unsigned nxt_task_error_os:1;
-	unsigned tdo_record_ram_addr_overflow_os:1;
-	unsigned reserved0:25;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_mtc_tstgen_int_force_r_t
- *  @brief Interrupt Force Register
- *  @details This address is an alias for the Interrupt Status register
-      that allows normal CFG writes (as opposed to the Clear-On-Write-One
-      behavior if the Interrupt Status register address is used).  This
-     allows CFG to set interrupt bits for testing purposes.  Reading this
-    address returns the current value of the Interrupt Status Register.
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_mtc_tstgen_int_force_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 25 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tdo_record_ram_addr_overflow_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 6 </td>
- *   <td width="30%"> The TDO Capture memory overflowed. Data is lost when
- *        this alarm occurs. Force
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param nxt_task_error_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 5 </td>
- *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
- *        state machine is halted at that failure.  The errored
- *        task must be fixed and the sw_reset signal written
- *        to restart the test. Force
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param tst_gen_state_error_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Fatal Error Occurred while processing a TASK. TESTGEN
- *        state machine is halted at the failure.  The errored
- *        task must be fixed and the sw_reset signal written
- *        to restart the test. Force
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param cont_after_pause_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Active anytime the TESTGEN state machine is paused.
- *        A write to cont_after_pause or single_step one-shot
- *        registers will release the state machine from the
- *        paused state. Force
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftir_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Paused in Shift-IR state Force </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param pause_in_shiftdr_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Paused in Shift-DR state Force </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param curr_task_end_of_test_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> In End-of-Test Task Force </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_tstgen_int_force_r_t
- *
- */
-
-struct ncp_axis_mtc_mtc_tstgen_int_force_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:25;
-	unsigned tdo_record_ram_addr_overflow_os:1;
-	unsigned nxt_task_error_os:1;
-	unsigned tst_gen_state_error_os:1;
-	unsigned cont_after_pause_os:1;
-	unsigned pause_in_shiftir_os:1;
-	unsigned pause_in_shiftdr_os:1;
-	unsigned curr_task_end_of_test_os:1;
-#else				/* Little Endian */
-	unsigned curr_task_end_of_test_os:1;
-	unsigned pause_in_shiftdr_os:1;
-	unsigned pause_in_shiftir_os:1;
-	unsigned cont_after_pause_os:1;
-	unsigned tst_gen_state_error_os:1;
-	unsigned nxt_task_error_os:1;
-	unsigned tdo_record_ram_addr_overflow_os:1;
-	unsigned reserved0:25;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_mtc_ecc_int_status_r_t
- *  @brief Interrupt Status Register
- *  @details This register holds interrupt status
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_mtc_ecc_int_status_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 28 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_mult_tstgen_prgm_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Multi-bit ECC Error in TESTGEN Program Memory Status </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_mult_tdo_capture_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Multi-bit ECC Error in TDO Capture Memory Status </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_single_tstgen_prgm_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- * <td width="30%"> Single-bit ECC Error in TESTGEN Program Memory Status </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_single_tdo_capture_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Single-bit ECC Error in TDO Capture Memory Status </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_ecc_int_status_r_t
- *
- */
-
-struct ncp_axis_mtc_mtc_ecc_int_status_r_t {
-
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:28;
-	unsigned ecc_mult_tstgen_prgm_mem_os:1;
-	unsigned ecc_mult_tdo_capture_mem_os:1;
-	unsigned ecc_single_tstgen_prgm_mem_os:1;
-	unsigned ecc_single_tdo_capture_mem_os:1;
-#else				/* Little Endian */
-	unsigned ecc_single_tdo_capture_mem_os:1;
-	unsigned ecc_single_tstgen_prgm_mem_os:1;
-	unsigned ecc_mult_tdo_capture_mem_os:1;
-	unsigned ecc_mult_tstgen_prgm_mem_os:1;
-	unsigned reserved0:28;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_mtc_ecc_int_en_r_t
- *  @brief Interrupt Enable Register
- *  @details This register enables interrupts
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_mtc_ecc_int_en_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 28 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_mult_tstgen_prgm_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Multi-bit ECC Error in TESTGEN Program Memory Enable </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_mult_tdo_capture_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Multi-bit ECC Error in TDO Capture Memory Enable </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_single_tstgen_prgm_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- * <td width="30%"> Single-bit ECC Error in TESTGEN Program Memory Enable </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_single_tdo_capture_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Single-bit ECC Error in TDO Capture Memory Enable </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_ecc_int_en_r_t
- *
- */
-
-struct ncp_axis_mtc_mtc_ecc_int_en_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:28;
-	unsigned ecc_mult_tstgen_prgm_mem_os:1;
-	unsigned ecc_mult_tdo_capture_mem_os:1;
-	unsigned ecc_single_tstgen_prgm_mem_os:1;
-	unsigned ecc_single_tdo_capture_mem_os:1;
-#else				/* Little Endian */
-	unsigned ecc_single_tdo_capture_mem_os:1;
-	unsigned ecc_single_tstgen_prgm_mem_os:1;
-	unsigned ecc_mult_tdo_capture_mem_os:1;
-	unsigned ecc_mult_tstgen_prgm_mem_os:1;
-	unsigned reserved0:28;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_mtc_ecc_int_force_r_t
- *  @brief Interrupt Force Register
- *  @details This address is an alias for the Interrupt Status register
-       that allows normal CFG writes (as opposed to the Clear-On-Write-One
-	behavior if the Interrupt Status register address is used).  This
-	allows CFG to set interrupt bits for testing purposes.  Reading this
-	address returns the current value of the Interrupt Status Register.
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_mtc_ecc_int_force_r_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 28 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_mult_tstgen_prgm_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Multi-bit ECC Error in TESTGEN Program Memory Force </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_mult_tdo_capture_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Multi-bit ECC Error in TDO Capture Memory Force </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ecc_single_tstgen_prgm_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Single-bit ECC Error in TESTGEN Program Memory Force </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @:param ecc_single_tdo_capture_mem_os </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Single-bit ECC Error in TDO Capture Memory Force </td>
- * </tr>
- * </table>
- * Applies to: 5500/5600 --> ncp_axis_mtc_mtc_ecc_int_force_r_t
- *
- */
-struct ncp_axis_mtc_mtc_ecc_int_force_r_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned reserved0:28;
-	unsigned ecc_mult_tstgen_prgm_mem_os:1;
-	unsigned ecc_mult_tdo_capture_mem_os:1;
-	unsigned ecc_single_tstgen_prgm_mem_os:1;
-	unsigned ecc_single_tdo_capture_mem_os:1;
-#else				/* Little Endian */
-	unsigned ecc_single_tdo_capture_mem_os:1;
-	unsigned ecc_single_tstgen_prgm_mem_os:1;
-	unsigned ecc_mult_tdo_capture_mem_os:1;
-	unsigned ecc_mult_tstgen_prgm_mem_os:1;
-	unsigned reserved0:28;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 0 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_inv0 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *   <td width="30%"> TDO capture Bit value to monitor within the window
- *        size inverted
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 29 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_bit0 </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> TDO capture Bit position to monitor within the window
- *        size
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_en </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 15 </td>
- *   <td width="30%"> AXI Master External Program Memory Mode Enable; 1=enable,
- *        0=disable
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_cnt </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> TDO capture Monitor Window Size in bits; 0=disable,
- *        1=monitor first bit captured, ...
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG0_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned      ext_prgm_mem_capture_window_mon_inv0      :  1;
-	unsigned      reserved0                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_mon_bit0      : 13;
-	unsigned      ext_prgm_mem_en                           :  1;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_cnt           : 13;
-#else    /* Little Endian */
-	unsigned      ext_prgm_mem_capture_window_cnt           : 13;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_en                           :  1;
-	unsigned      ext_prgm_mem_capture_window_mon_bit0      : 13;
-	unsigned      reserved0                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_mon_inv0      :  1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 1 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_inv2 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 31 </td>
- *   <td width="30%"> TDO capture Bit value to monitor within the window
- *        size inverted
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 29 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_bit2 </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> TDO capture Bit position to monitor within the window
- *        size
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_inv1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 15 </td>
- *   <td width="30%"> TDO capture Bit value to monitor within the window
- *        size inverted
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_window_mon_bit1 </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> TDO capture Bit position to monitor within the window
- *        size
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG1_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned      ext_prgm_mem_capture_window_mon_inv2      :  1;
-	unsigned      reserved0                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_mon_bit2      : 13;
-	unsigned      ext_prgm_mem_capture_window_mon_inv1      :  1;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_mon_bit1      : 13;
-#else    /* Little Endian */
-	unsigned      ext_prgm_mem_capture_window_mon_bit1      : 13;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_mon_inv1      :  1;
-	unsigned      ext_prgm_mem_capture_window_mon_bit2      : 13;
-	unsigned      reserved0                                 :  2;
-	unsigned      ext_prgm_mem_capture_window_mon_inv2      :  1;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 2 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 30 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_cfg_high_wm </td>
- *     <td width="20%" align="center"> 6 </td>
- *     <td width="20%" align="center"> 24 </td>
- *   <td width="30%"> AXI Master Program FIFO High Water Mark </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 22 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_cfg_low_wm </td>
- *     <td width="20%" align="center"> 6 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> AXI Master Program FIFO Low Water Mark </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved2 </td>
- *     <td width="20%" align="center"> 9 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param cfg_mtc_axi_m_arprot </td>
- *     <td width="20%" align="center"> 3 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> AXI Master Read ARPROT Value </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved3 </td>
- *     <td width="20%" align="center"> 4 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG2_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned      reserved0                                 :  2;
-	unsigned      ext_prgm_mem_cfg_high_wm                  :  6;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_cfg_low_wm                   :  6;
-	unsigned      reserved2                                 :  9;
-	unsigned      cfg_mtc_axi_m_arprot                      :  3;
-	unsigned      reserved3                                 :  4;
-#else    /* Little Endian */
-	unsigned      reserved3                                 :  4;
-	unsigned      cfg_mtc_axi_m_arprot                      :  3;
-	unsigned      reserved2                                 :  9;
-	unsigned      ext_prgm_mem_cfg_low_wm                   :  6;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_cfg_high_wm                  :  6;
-	unsigned      reserved0                                 :  2;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 3 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgrm_axi_start_addr_low </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> AXI Master Start Address Low [31:0] </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG3_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t {
-	unsigned  int      ext_prgrm_axi_start_addr_low;
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 4 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgrm_axi_start_addr_high </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> AXI Master Start Address High [63:32] </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG4_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t {
-	unsigned  int      ext_prgrm_axi_start_addr_high;
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 5 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgrm_axi_stop_addr_low </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> AXI Master Stop Address Low [31:0] </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG5_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t {
-	unsigned  int      ext_prgrm_axi_stop_addr_low;
-};
-
-/*! @struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t
- *  @brief MTC AXI Config 6 Register
- *  @details Parameters used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgrm_axi_stop_addr_high </td>
- *     <td width="20%" align="center"> 32 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> AXI Master Stop Address High [63:32] </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_CFG6_REG_ADDR
- */
-struct  ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t {
-	unsigned  int      ext_prgrm_axi_stop_addr_high;
-};
-
-/*! @struct ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t
- *  @brief MTC AXI Status 0 Register
- *  @details MTC Status used in AXI Master External Program Memory Mode
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 17 </td>
- *     <td width="20%" align="center"> 15 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_axi_m_awvalid </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 14 </td>
- *   <td width="30%"> AXI Master AWVAILD Signal Value </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_axi_m_awready </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> AXI Master AWREADY Signal Value </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_axi_m_rvalid </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 12 </td>
- *   <td width="30%"> AXI Master RVAILD Signal Value </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 10 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_shift_dr </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 9 </td>
- *   <td width="30%"> Capure TDO data in shift-dr state </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_capture_shift_ir </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 8 </td>
- *   <td width="30%"> Capure TDO data in shift-ir state </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved2 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 7 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_done </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 6 </td>
- *   <td width="30%"> Value of done signal to syscon block </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param mtc_status </td>
- *     <td width="20%" align="center"> 2 </td>
- *     <td width="20%" align="center"> 4 </td>
- *   <td width="30%"> Value of status signal to syscon block Definition:
- *        {mtc_done, mtc_status[1:0]}.  -- 3'110: test pass,
- *         -- 3'100: test failed,  -- 3'1x1: execution error,
- *         -- 3'0xx: not complete).
- *   </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved3 </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_done </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 2 </td>
- *   <td width="30%"> Done signal from testgen module </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_execute_error </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 1 </td>
- *   <td width="30%"> Execution error detected while processing program </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param ext_prgm_mem_comp_pass </td>
- *     <td width="20%" align="center"> 1 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Composite Pass(1'b1)/Fail(1'b0) value from TDO capture
- *        module
- *   </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_STATUS0_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_STATUS3_REG_ADDR_r_5600_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned      reserved0                                 : 17;
-	unsigned      mtc_axi_m_awvalid                         :  1;
-	unsigned      mtc_axi_m_awready                         :  1;
-	unsigned      mtc_axi_m_rvalid                          :  1;
-	unsigned      reserved1                                 :  2;
-	unsigned      ext_prgm_mem_capture_shift_dr             :  1;
-	unsigned      ext_prgm_mem_capture_shift_ir             :  1;
-	unsigned      reserved2                                 :  1;
-	unsigned      mtc_done                                  :  1;
-	unsigned      mtc_status                                :  2;
-	unsigned      reserved3                                 :  1;
-	unsigned      ext_prgm_mem_done                         :  1;
-	unsigned      ext_prgm_mem_execute_error                :  1;
-	unsigned      ext_prgm_mem_comp_pass                    :  1;
-#else    /* Little Endian */
-	unsigned      ext_prgm_mem_comp_pass                    :  1;
-	unsigned      ext_prgm_mem_execute_error                :  1;
-	unsigned      ext_prgm_mem_done                         :  1;
-	unsigned      reserved3                                 :  1;
-	unsigned      mtc_status                                :  2;
-	unsigned      mtc_done                                  :  1;
-	unsigned      reserved2                                 :  1;
-	unsigned      ext_prgm_mem_capture_shift_ir             :  1;
-	unsigned      ext_prgm_mem_capture_shift_dr             :  1;
-	unsigned      reserved1                                 :  2;
-	unsigned      mtc_axi_m_rvalid                          :  1;
-	unsigned      mtc_axi_m_awready                         :  1;
-	unsigned      mtc_axi_m_awvalid                         :  1;
-	unsigned      reserved0                                 : 17;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t
- *  @brief MTC AXI Status 2 Register
- *  @details DEBUG: MTC AXI Master External Program Memory Mode - TDO Capture Monitor Debug Counters
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 19 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param window_cnt </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> AXI Monitor Window Count Value </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_STATUS2_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_STATUS5_REG_ADDR_r_5600_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned      reserved0                                 : 19;
-	unsigned      window_cnt                                : 13;
-#else    /* Little Endian */
-	unsigned      window_cnt                                : 13;
-	unsigned      reserved0                                 : 19;
-#endif
-};
-
-/*! @struct ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t
- *  @brief MTC AXI Status 3 Register
- *  @details DEBUG:
- *  <table width="70%" align="center">
- *  <tr>
- *   <td colspan="4" align="center">
- *    struct ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t\n
- *   </td>
- *  </tr>
- *  <tr>
- *     <td width="30%"><b> Name </b></td>
- *     <td width="20%" align="center"><b> Width </b></td>
- *     <td width="20%" align="center"><b> Start Offset </b></td>
- *     <td width="30%"><b> Description </b></td>
- *  </tr>
- *   <tr>
- *     <td width="30%"> @param reserved0 </td>
- *     <td width="20%" align="center"> 3 </td>
- *     <td width="20%" align="center"> 29 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved2 </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 16 </td>
- *   <td width="30%"> Reserved </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 3 </td>
- *     <td width="20%" align="center"> 13 </td>
- *   <td width="30%"> Reserved for future use </td>
- * </tr>
- *   <tr>
- *     <td width="30%"> @param reserved1 </td>
- *     <td width="20%" align="center"> 13 </td>
- *     <td width="20%" align="center"> 0 </td>
- *   <td width="30%"> Reserved </td>
- * </tr>
- * </table>
- * Applies to: 5600 --> ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t
- *
- * Implemented by:
- *      MTC_AXI_STATUS3_REG_ADDR
- */
-struct ncp_axis_mtc_MTC_STATUS6_REG_ADDR_r_5600_t {
-#ifdef NCP_BIG_ENDIAN
-	unsigned      reserved0                                 :  3;
-	unsigned      reserved1                                 : 13;
-	unsigned      reserved2                                 :  3;
-	unsigned      reserved3                                 : 13;
-#else    /* Little Endian */
-	unsigned      reserved3                                 : 13;
-	unsigned      reserved2                                 :  3;
-	unsigned      reserved1                                 : 13;
-	unsigned      reserved0                                 :  3;
-#endif
-};
-
-/******************************************************/
-/* end of RDL register definitions */
-/******************************************************/
-
-struct mtc_device {
-	struct kref ref;
-	struct platform_device *pdev;
-	unsigned long flags;
-#define FLAG_REGISTERED        0	/* Misc device registered */
-	struct mtc_regs __iomem *regs;
-	u32 __iomem *prgmem;
-	u32 __iomem *tdomem;
-	unsigned int irq;
-	struct miscdevice char_device;
-	unsigned int ext_prgm_mode;
-	u64 ext_strt_addr;
-	u64 ext_stop_addr;
-};
-
-#define miscdev_to_mtc(mdev) container_of(mdev, struct mtc_device, char_device)
-
-/* Called when removed and last reference is released */
-static void mtc_destroy(struct kref *ref);
-
-/**
- * mtc_dev_open
- *
- * Returns 0 for success or negative errno.
- */
-static int mtc_dev_open(struct inode *inode, struct file *filp)
-{
-	struct miscdevice *misc = filp->private_data;
-	struct mtc_device *dev = miscdev_to_mtc(misc);
-
-	pr_debug("mtc_dev_open(%p)\n", dev);
-	kref_get(&dev->ref);
-	return 0;
-}
-
-/**
- * mtc_dev_release
- */
-static int mtc_dev_release(struct inode *inode, struct file *filp)
-{
-	struct miscdevice *misc = filp->private_data;
-	struct mtc_device *dev = miscdev_to_mtc(misc);
-
-	pr_debug("mtc_dev_release(%p)\n", dev);
-	kref_put(&dev->ref, mtc_destroy);
-	return 0;
-}
-
-/**
- * mtc_dev_read
- *
- * Returns number of valid bits read or negative errno.
- */
-static ssize_t
-mtc_dev_read(struct file *filp, char __user *data, size_t len, loff_t *ppose)
-{
-	struct miscdevice *misc = filp->private_data;
-	struct mtc_device *dev = miscdev_to_mtc(misc);
-	u32 __iomem *ptdo;
-	u32 tdo_size_word, tdo_size_bit;	/* data to be read in words */
-	struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t status1Reg = { 0 };
-	struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1Reg = { 0 };
-	u32 i = 0;
-	char *tmp_data = NULL;
-
-	pr_debug("mtc_dev_read(%u @ %llu)\n", (unsigned int) len, *ppose);
-	ptdo = dev->tdomem;
-
-	/* flush tdo buffer */
-	exec1Reg.tdo_flush_capture_data = 1;
-	dev->regs->execute = *((u32 *) &exec1Reg);
-
-	/* read status 1register */
-	status1Reg =
-	    *((struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t *)
-	      &(dev->regs->status1));
-	tdo_size_bit = status1Reg.tdo_record_ram_bit_counter;
-
-	/* test code for mtc memory sim only */
-	/* tdo_size_bit = 8192; */
-	/* end of test code */
-
-	tdo_size_word = (tdo_size_bit + 31) / 32;
-#ifdef DEBUG
-	pr_debug("mtc_dev_read(), tdo_bit=%d tdo_word=%d\n",
-		 tdo_size_bit, tdo_size_word);
-#endif
-
-	tmp_data = kmalloc(tdo_size_word*4, GFP_KERNEL);
-
-	if (!tmp_data)
-		return -EFAULT;
-
-	memset(tmp_data, 0, tdo_size_word * 4);
-	for (i = 0; i < tdo_size_word*4; i++) {
-#ifdef DEBUG
-		pr_debug("data[%d]=0x%x\n", i, ptdo[i]);
-#endif
-		tmp_data[i] = (ptdo[i/4] & (0xFF << ((i%4) * 8))) >>
-			((i%4) * 8);
-	}
-	/* copy tdo data to user space, always read from location 0
-	   because we reset tdomem after each read */
-	if (copy_to_user((void *)data, tmp_data, tdo_size_word * 4)) {
-		kfree(tmp_data);
-		return -EFAULT;
-	}
-#ifdef DEBUG
-	for (i = 0; i < tdo_size_word*4; i++) {
-		pr_debug("copied data[%d]=0x%x tmp_data=0x%x\n",
-				 i, data[i], tmp_data[i]);
-	}
-#endif
-	kfree(tmp_data);
-
-	/* data sent to user, reset tdo capture buffer */
-	memset(&exec1Reg, 0, sizeof(exec1Reg));
-	exec1Reg.tdo_capture_reset = 1;
-	dev->regs->execute = *((u32 *) &exec1Reg);
-
-	/* return # of bits */
-	return tdo_size_bit;
-}
-
-static ssize_t
-_mtc_axi_dev_write(struct file *filp,
-	      const char __user *data,
-	      size_t len,
-	      loff_t *ppose)
-{
-
-	struct miscdevice *misc = filp->private_data;
-	struct mtc_device *dev = miscdev_to_mtc(misc);
-	u32 __iomem *pprg;
-	u32 *mtc_buf;
-	u32 size, size1, i;	/* size in word */
-
-	pr_debug("mtc_axi_dev_write(%u @ %llu)\n", (unsigned int) len, *ppose);
-
-	size = len / 4;
-	size1 = size;
-
-	mtc_buf = kmalloc(len, GFP_KERNEL);
-	if (!mtc_buf)
-		return -EFAULT;
-
-	/* copy to a local buffer */
-	memset(mtc_buf, 0, len);
-	if (copy_from_user((void *)mtc_buf, (void *)data, len)) {
-		pr_debug("MTC Error write\n");
-		return -EFAULT;
-	}
-
-	/* ioremap the start-stop address range. */
-	pprg = ioremap(dev->ext_strt_addr,
-			(dev->ext_stop_addr-dev->ext_strt_addr));
-	if (!pprg) {
-		/* free the mtc_buf */
-		kfree(mtc_buf);
-		return -EFAULT;
-	}
-
-	for (i = 0; i < size; i++) {
-#ifdef DEBUG
-		pr_debug("i=%d mtc_buf[i]=%d pprg=0x%llx\n",
-			 i, mtc_buf[i], (u64) pprg);
-#endif
-		*pprg = mtc_buf[i];
-		pprg++;
-	}
-
-	/* free mtc_buf */
-	kfree(mtc_buf);
-
-	/* unmap memory */
-	iounmap(pprg);
-
-	return len;
-}
-
-/**
- * mtc_dev_write
- *
- * Returns number of bytes written or negative errno.
- */
-
-static ssize_t
-mtc_dev_write(struct file *filp,
-	      const char __user *data,
-	      size_t len,
-	      loff_t *ppose)
-{
-
-	struct miscdevice *misc = filp->private_data;
-	struct mtc_device *dev = miscdev_to_mtc(misc);
-	u32 __iomem *pprg;
-	u32 mtc_buf[256];	/* max 256 words */
-	u32 size, size1, isWraparound = 0, i;	/* size in word */
-	struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t status1Reg = { 0 };
-
-	pr_debug("mtc_dev_write(%u @ %llu)\n", (unsigned int) len, *ppose);
-
-	/* If external program memory mode, write to external memory instead
-	of program memory.
-	*/
-	if (dev->ext_prgm_mode == 1)
-		return _mtc_axi_dev_write(filp, data, len, ppose);
-
-	if (len > 1024)
-		return -EINVAL;
-
-	size = len / 4;
-	size1 = size;
-
-#ifdef DEBUG
-	for (i = 0; i < len; i++)
-		pr_debug("input data[%d]=0x%x\n", i, data[i]);
-#endif
-	/* copy to a lcoal buffer */
-	memset(mtc_buf, 0, 1024);
-	if (copy_from_user((void *)mtc_buf, (void *)data, len)) {
-		pr_debug("MTC Error write\n");
-		return -EFAULT;
-	}
-
-#ifdef DEBUG
-	for (i = 0; i < len; i++)
-		pr_debug("after copying: mtc_buf[%d]=0x%x\n", i, mtc_buf[i]);
-#endif
-	/* read status 1register, find the starting write offset */
-	status1Reg =
-	    *((struct ncp_axis_mtc_MTC_STATUS1_REG_ADDR_r_t *)
-	      &(dev->regs->status1));
-
-	/* TEST CODE when mtc sim is used */
-	/* status1Reg.prgm_mem_rd_addr = 253; */
-	/* pr_debug("buf offset=%d\n",status1Reg.prgm_mem_rd_addr ); */
-	/*END OF TEST CODE */
-
-	/* find starting location of the write */
-	pprg = dev->prgmem + status1Reg.prgm_mem_rd_addr;
-
-	/* determine if wrap around is needed */
-	if (status1Reg.prgm_mem_rd_addr + size > 256) {
-		isWraparound = 1;
-		/* number of words load from starting location */
-		size1 = 256 - status1Reg.prgm_mem_rd_addr;
-		/*number of words load from location 0 will be size-size1 */
-#ifdef DEBUG
-		pr_debug("Wraparound size=%d, size1=%d size-size1=%d\n", size,
-			 size1, size - size1);
-#endif
-	}
-#ifdef DEBUG
-	pr_debug("Appending buff size1=%d\n", size1);
-#endif
-
-	for (i = 0; i < size1; i++) {
-#ifdef DEBUG
-		pr_debug("i=%d mtc_buf[i]=%d pprg=0x%llx\n",
-			 i, mtc_buf[i], (u64) pprg);
-#endif
-		*pprg = mtc_buf[i];
-		pprg++;
-	}
-
-	/* wraparound, copy the 2nd half */
-	if (isWraparound) {
-		pprg = dev->prgmem;	/* reset write pointer to location 0 */
-#ifdef DEBUG
-		pr_debug("\n\nWraparound buff size=%d\n",
-			 size - size1);
-#endif
-		for (i = 0; i < (size - size1); i++) {
-#ifdef DEBUG
-			pr_debug("i=%d mtc_buf[size1+i]=%d pprg=0x%llx\n", i,
-				 mtc_buf[size1 + i], (u64) pprg);
-#endif
-			*pprg = mtc_buf[size1 + i];
-			pprg++;
-		}
-	}
-
-	return len;
-}
-
-/**
- * mtc_dev_ioctl
- *
- */
-
-static long _mtc_config(struct mtc_device *dev, struct lsi_mtc_cfg_t *pMTCCfg);
-
-static long
-mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	struct miscdevice *misc = filp->private_data;
-	struct mtc_device *dev = miscdev_to_mtc(misc);
-	long ret = 0;
-	u32 addr, tmp2;
-	unsigned long numByteCopied;
-
-	pr_debug("mtc_dev_ioctl(%#x, %#lx)\n", cmd, arg);
-	switch (cmd) {
-
-	case MTC_DEBUG_OP:
-		numByteCopied =
-		    copy_from_user((void *)&addr, (void *)arg,
-				   sizeof(unsigned int));
-		if (numByteCopied) {
-			pr_debug("MTC Error ioctl\n");
-			return -EFAULT;
-		}
-		tmp2 = *((u32 *) dev->regs + addr / 4);
-
-		if (copy_to_user((void *)arg, &tmp2, sizeof(unsigned int)))
-			return -EFAULT;
-
-		break;
-
-	case MTC_CFG:
-		{
-			struct lsi_mtc_cfg_t mtc_cfg;
-
-			if (copy_from_user
-			    ((void *)&mtc_cfg, (void *)arg, sizeof(mtc_cfg))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			ret = _mtc_config(dev, &mtc_cfg);
-		}
-		break;
-
-	case MTC_SINGLESTEP_ENABLE:
-		{
-			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
-			int single_step;
-
-			if (copy_from_user
-			    ((void *)&single_step, (void *)arg, sizeof(int))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if ((single_step != 0) && (single_step != 1))
-				return -EINVAL;
-
-			cfg0 =
-			    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
-			      &(dev->regs->config0));
-			cfg0.single_step_en = single_step;
-			dev->regs->config0 = *((u32 *) &cfg0);
-#ifdef DEBUG
-			pr_debug(
-			    "MTC_SINGLESTEP_ENABLE: dev->regs->config0=0x%x\n",
-			    dev->regs->config0);
-#endif
-		}
-
-		break;
-
-	case MTC_LOOPMODE_ENABLE:
-		{
-			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
-			int loop_mode;
-
-			if (copy_from_user
-			    ((void *)&loop_mode, (void *)arg, sizeof(int))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if ((loop_mode != 0) && (loop_mode != 1))
-				return -EINVAL;
-
-			cfg0 =
-			    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
-			      &(dev->regs->config0));
-			cfg0.loop_en = loop_mode;
-			dev->regs->config0 = *((u32 *) &cfg0);
-#ifdef DEBUG
-			pr_debug(
-			       "MTC_LOOPMODE_ENABLE dev->regs->config0=0x%x\n",
-			       dev->regs->config0);
-#endif
-		}
-
-		break;
-
-	case MTC_RESET:
-		{
-			struct
-			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
-			exec1.sw_reset = 1;
-			dev->regs->execute = *((u32 *) &exec1);
-#ifdef DEBUG
-			pr_debug("dev->regs->execute=0x%x\n",
-				 dev->regs->execute);
-#endif
-		}
-
-		break;
-
-	case MTC_TCKCLK_GATE:
-		{
-			struct lsi_mtc_tckclk_gate_t tckGate;
-			struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t cfg1 = {0};
-
-			if (copy_from_user
-			    ((void *)&tckGate, (void *)arg, sizeof(tckGate))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if (((tckGate.gate_tck_test_logic_reset != 0)
-			     && (tckGate.gate_tck_test_logic_reset != 1))
-			    || ((tckGate.gate_tck != 0)
-				&& (tckGate.gate_tck != 1)))
-				return -EINVAL;
-
-			cfg1 =
-			    *((struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t *)
-			      &(dev->regs->config1));
-			cfg1.sw_gate_tck_test_logic_reset =
-			    tckGate.gate_tck_test_logic_reset;
-			cfg1.sw_gate_tck = tckGate.gate_tck;
-			dev->regs->config1 = *((u32 *) &cfg1);
-#ifdef DEBUG
-			pr_debug("dev->regs->config1=0x%x\n",
-				 dev->regs->config1);
-#endif
-		}
-
-		break;
-
-	case MTC_STARTSTOP_EXEC:
-		{
-			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
-			int start_stop;
-
-			if (copy_from_user
-			    ((void *)&start_stop, (void *)arg, sizeof(int))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if ((start_stop != 0) && (start_stop != 1))
-				return -EINVAL;
-
-			cfg0 =
-			    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
-			      &(dev->regs->config0));
-			cfg0.start_stopn = start_stop;
-			dev->regs->config0 = *((u32 *) &cfg0);
-#ifdef DEBUG
-			pr_debug("dev->regs->config0=0x%x\n",
-				 dev->regs->config0);
-#endif
-		}
-
-		break;
-
-	case MTC_SINGLESTEP_EXEC:
-		{
-			struct
-			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
-			exec1.single_step = 1;
-			dev->regs->execute = *((u32 *) &exec1);
-			pr_debug("dev->regs->execute=0x%x\n",
-				 dev->regs->execute);
-
-		}
-		break;
-
-	case MTC_CONTINUE_EXEC:
-		{
-			struct
-			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
-			exec1.cont_after_pause = 1;
-			dev->regs->execute = *((u32 *) &exec1);
-			pr_debug("dev->regs->execute=0x%x\n",
-				 dev->regs->execute);
-
-		}
-		break;
-
-	case MTC_READ_STATS:
-		{
-			struct lsi_mtc_stats_regs_t stats;
-
-			stats.statsReg1 = dev->regs->status1;
-			stats.statsReg2 = dev->regs->status2;
-
-			if (copy_to_user((void *)arg, &stats, sizeof(stats)))
-				return -EFAULT;
-
-		}
-		break;
-
-	case MTC_READ_DEBUG:
-		{
-			struct lsi_mtc_debug_regs_t debug;
-
-			debug.debugReg0 = dev->regs->debug0;
-			debug.debugReg1 = dev->regs->debug1;
-			debug.debugReg2 = dev->regs->debug2;
-			debug.debugReg3 = dev->regs->debug3;
-			debug.debugReg4 = dev->regs->debug4;
-			debug.debugReg5 = dev->regs->debug5;
-
-			if (copy_to_user((void *)arg, &debug, sizeof(debug)))
-				return -EFAULT;
-
-		}
-
-		break;
-
-	case MTC_AXI_EXT_PRGM_MEM_ENABLE:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-			struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t cfg0
-							= {0};
-			int ext_prgm_mode;
-
-			if (copy_from_user((void *)&ext_prgm_mode,
-					(void *)arg,
-					sizeof(int))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if ((ext_prgm_mode != 0) && (ext_prgm_mode != 1))
-				return -EINVAL;
-			cfg0 =
-			*((struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config0));
-			cfg0.ext_prgm_mem_en = ext_prgm_mode;
-			dev->regs->axi_config0 = *((u32 *) &cfg0);
-			dev->ext_prgm_mode = ext_prgm_mode;
-#ifdef DEBUG
-			pr_debug(
-			"MTC_AXI_EXT_PRGM_MEM_ENABLE axi_config0=0x%x\n",
-			       dev->regs->axi_config0);
-#endif
-		} else
-			return -EPERM;
-		break;
-
-	case MTC_AXI_CAPT_WINDOW_PARAM_SET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_capt_window_param_t wndparm;
-
-			struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t cfg0
-							= {0};
-			struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t cfg1
-							= {0};
-
-			if (copy_from_user
-			    ((void *)&wndparm, (void *)arg, sizeof(wndparm))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if ((wndparm.captWindowCnt > 0x1FFF) ||
-			     (wndparm.captWindowMonBit0 > 0x1FFF) ||
-			     ((wndparm.captWindowMonInv0 != 1) &&
-				(wndparm.captWindowMonInv0 != 0)) ||
-			     (wndparm.captWindowMonBit1 > 0x1FFF) ||
-			     ((wndparm.captWindowMonInv1 != 1) &&
-				(wndparm.captWindowMonInv1 != 0)) ||
-			     (wndparm.captWindowMonBit2 > 0x1FFF) ||
-			     ((wndparm.captWindowMonInv2 != 1) &&
-				(wndparm.captWindowMonInv2 != 0)))
-				return -EINVAL;
-
-			cfg0 =
-			*((struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config0));
-			cfg1 =
-			*((struct  ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config1));
-
-			cfg0.ext_prgm_mem_capture_window_cnt =
-						wndparm.captWindowCnt;
-			cfg0.ext_prgm_mem_capture_window_mon_bit0 =
-						wndparm.captWindowMonBit0;
-			cfg0.ext_prgm_mem_capture_window_mon_inv0 =
-						wndparm.captWindowMonInv0;
-
-			cfg1.ext_prgm_mem_capture_window_mon_bit1 =
-						wndparm.captWindowMonBit1;
-			cfg1.ext_prgm_mem_capture_window_mon_inv1 =
-						wndparm.captWindowMonInv1;
-			cfg1.ext_prgm_mem_capture_window_mon_bit2 =
-						wndparm.captWindowMonBit2;
-			cfg1.ext_prgm_mem_capture_window_mon_inv2 =
-						wndparm.captWindowMonInv2;
-
-			dev->regs->axi_config0 = *((u32 *) &cfg0);
-			dev->regs->axi_config1 = *((u32 *) &cfg1);
-#ifdef DEBUG
-			pr_debug(
-			"MTC_AXI_CAPT_WINDOW_PARAM_SET cfg0=0x%x cfg1=0x%x\n",
-				 dev->regs->axi_config0,
-				 dev->regs->axi_config1);
-#endif
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_CAPT_WINDOW_PARAM_GET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_capt_window_param_t wndparm;
-			struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t cfg0
-								= {0};
-			struct ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t cfg1
-								= {0};
-
-			cfg0 =
-			*((struct ncp_axis_mtc_MTC_CONFIG2_REG_ADDR_r_5600_t *)
-			&(dev->regs->axi_config0));
-			cfg1 =
-			*((struct  ncp_axis_mtc_MTC_CONFIG3_REG_ADDR_r_5600_t *)
-			&(dev->regs->axi_config1));
-
-			wndparm.captWindowCnt	=
-				cfg0.ext_prgm_mem_capture_window_cnt;
-			wndparm.captWindowMonBit0 =
-				cfg0.ext_prgm_mem_capture_window_mon_bit0;
-			wndparm.captWindowMonInv0 =
-				cfg0.ext_prgm_mem_capture_window_mon_inv0;
-
-			wndparm.captWindowMonBit1 =
-				cfg1.ext_prgm_mem_capture_window_mon_bit1;
-			wndparm.captWindowMonInv1 =
-				cfg1.ext_prgm_mem_capture_window_mon_inv1;
-			wndparm.captWindowMonBit2 =
-				cfg1.ext_prgm_mem_capture_window_mon_bit2;
-			wndparm.captWindowMonInv2 =
-				cfg1.ext_prgm_mem_capture_window_mon_inv2;
-
-			if (copy_to_user((void *)arg,
-				&wndparm, sizeof(wndparm)))
-				return -EFAULT;
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_WATER_MARK_SET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_extmem_wm_t wm;
-			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
-								 = {0};
-
-			if (copy_from_user
-			    ((void *)&wm, (void *)arg, sizeof(wm))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if ((wm.highWaterMark > 0x3f) ||
-				(wm.lowWaterMark > 0x3f))
-				return -EINVAL;
-
-			cfg2 =
-			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
-				&(dev->regs->axi_config2));
-
-			/* set the values */
-			cfg2.ext_prgm_mem_cfg_high_wm = wm.highWaterMark;
-			cfg2.ext_prgm_mem_cfg_low_wm = wm.lowWaterMark;
-
-			dev->regs->axi_config2 = *((u32 *) &cfg2);
-#ifdef DEBUG
-			pr_debug("MTC_AXI_WATER_MARK_SET cfg2=0x%x\n",
-					dev->regs->axi_config2);
-#endif
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_WATER_MARK_GET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_extmem_wm_t wm;
-			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
-						 = {0};
-
-
-			cfg2 =
-			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config2));
-
-			wm.highWaterMark = cfg2.ext_prgm_mem_cfg_high_wm;
-			wm.lowWaterMark = cfg2.ext_prgm_mem_cfg_low_wm;
-
-			if (copy_to_user((void *)arg, &wm, sizeof(wm)))
-				return -EFAULT;
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_M_ARPROT_SET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-			int arprot;
-			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
-								 = {0};
-
-			if (copy_from_user
-			    ((void *)&arprot, (void *)arg, sizeof(int))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			if (arprot > 0x7)
-				return -EINVAL;
-
-			cfg2 =
-			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config2));
-
-			/* set the values */
-			cfg2.cfg_mtc_axi_m_arprot = arprot;
-
-			dev->regs->axi_config2 = *((u32 *) &cfg2);
-#ifdef DEBUG
-			pr_debug("MTC_AXI_M_ARPROT_SET cfg2=0x%x\n",
-				dev->regs->axi_config2);
-#endif
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_M_ARPROT_GET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			int arprot;
-			struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t cfg2
-							 = {0};
-
-			cfg2 =
-			*((struct ncp_axis_mtc_MTC_CONFIG4_REG_ADDR_r_5600_t *)
-			&(dev->regs->axi_config2));
-
-			arprot = cfg2.cfg_mtc_axi_m_arprot;
-
-			if (copy_to_user((void *)arg, &arprot, sizeof(int)))
-				return -EFAULT;
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_MASTER_ADDR_SET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_master_addr_t addr;
-
-			struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t cfg3
-								 = {0};
-			struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t cfg4
-								 = {0};
-			struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t cfg5
-								 = {0};
-			struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t cfg6
-								= {0};
-
-			if (copy_from_user
-			    ((void *)&addr, (void *)arg,
-				sizeof(struct lsi_mtc_axi_master_addr_t))) {
-				pr_debug("MTC Error ioctl\n");
-				return -EFAULT;
-			}
-
-			cfg3 =
-			*((struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config3));
-
-			cfg4 =
-			*((struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config4));
-
-			cfg5 =
-			*((struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config5));
-
-			cfg6 =
-			*((struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config6));
-
-			/* set the values */
-			cfg3.ext_prgrm_axi_start_addr_low = addr.strtAddrLow;
-			cfg4.ext_prgrm_axi_start_addr_high = addr.strtAddrHigh;
-
-			cfg5.ext_prgrm_axi_stop_addr_low = addr.stopAddrLow;
-			cfg6.ext_prgrm_axi_stop_addr_high = addr.stopAddrHigh;
-
-			dev->regs->axi_config3 = *((u32 *) &cfg3);
-			dev->regs->axi_config4 = *((u32 *) &cfg4);
-			dev->regs->axi_config5 = *((u32 *) &cfg5);
-			dev->regs->axi_config6 = *((u32 *) &cfg6);
-
-			dev->ext_strt_addr =
-				(((u64) (addr.strtAddrHigh)) << 32) |
-				(u64)(addr.strtAddrLow);
-
-			dev->ext_stop_addr =
-				 (((u64) (addr.stopAddrHigh)) << 32) |
-				(u64)(addr.stopAddrLow);
-
-#ifdef DEBUG
-			pr_debug(
-			"MTC_AXI_MASTER_ADDR_SET cfg3=0x%x cfg4=0x%x\n",
-				dev->regs->axi_config3,
-				dev->regs->axi_config4);
-
-			pr_debug("cfg5=0x%x cfg6=0x%x\n",
-				dev->regs->axi_config5,
-				dev->regs->axi_config6);
-#endif
-		} else
-			return -EPERM;
-
-		break;
-
-	case MTC_AXI_MASTER_ADDR_GET:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_master_addr_t addr;
-			struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t cfg3
-									 = {0};
-			struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t cfg4
-									 = {0};
-			struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t cfg5
-									 = {0};
-			struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t cfg6
-									 = {0};
-
-			cfg3 =
-			*((struct ncp_axis_mtc_MTC_CONFIG5_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config3));
-
-			cfg4 =
-			*((struct ncp_axis_mtc_MTC_CONFIG6_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config4));
-
-			cfg5 =
-			*((struct ncp_axis_mtc_MTC_CONFIG7_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config5));
-
-			cfg6 =
-			*((struct ncp_axis_mtc_MTC_CONFIG8_REG_ADDR_r_5600_t *)
-			      &(dev->regs->axi_config6));
-
-			addr.strtAddrLow = cfg3.ext_prgrm_axi_start_addr_low;
-			addr.strtAddrHigh = cfg4.ext_prgrm_axi_start_addr_high;
-
-			addr.stopAddrLow = cfg5.ext_prgrm_axi_stop_addr_low;
-			addr.stopAddrHigh = cfg6.ext_prgrm_axi_stop_addr_high;
-
-			if (copy_to_user((void *)arg, &addr, sizeof(addr)))
-				return -EFAULT;
-		} else {
-			return -EPERM;
-		}
-
-		break;
-
-	case MTC_AXI_READ_STATUS:
-
-		if (of_find_compatible_node(NULL, NULL, "lsi,axm5616") ||
-		   (of_find_compatible_node(NULL, NULL, "lsi,axc6732"))) {
-
-			struct lsi_mtc_axi_status_regs_t status;
-
-			status.axiStatusReg0 = dev->regs->axi_status0;
-			status.axiStatusReg1 = dev->regs->axi_status1;
-			status.axiStatusReg2 = dev->regs->axi_status2;
-			status.axiStatusReg3 = dev->regs->axi_status3;
-
-			if (copy_to_user((void *)arg, &status, sizeof(status)))
-				return -EFAULT;
-		} else {
-			return -EPERM;
-		}
-
-		break;
-
-	default:
-		pr_debug("Invalid ioctl cmd=%d MTC_DEBUG_OP=%u\n",
-			 cmd, (unsigned int)MTC_DEBUG_OP);
-		ret = -EINVAL;
-
-	}
-
-	return ret;
-}
-
-static const struct file_operations mtc_char_ops = {
-	.owner = THIS_MODULE,
-	.open = mtc_dev_open,
-	.release = mtc_dev_release,
-	.llseek = generic_file_llseek,
-	.read = mtc_dev_read,
-	.write = mtc_dev_write,
-	.unlocked_ioctl = mtc_dev_ioctl,
-	.compat_ioctl = mtc_dev_ioctl
-};
-
-static irqreturn_t mtc_isr(int irq_no, void *arg)
-{
-	struct mtc_device *priv = arg;
-	u32 status = readl(&priv->regs->int_status);
-
-	pr_debug("mtc: int status %#x\n", status);
-
-	/* Handle interrupt */
-	/* ... */
-
-	/* Write bits to clear interrupt status */
-	writel(status, &priv->regs->int_status);
-
-	return IRQ_HANDLED;
-}
-
-/**
- * mtc_probe
- *
- * Initialize device.
- */
-static int mtc_probe(struct platform_device *pdev)
-{
-	static struct mtc_device *dev;
-	void __iomem *regs;
-	int rc;
-	u32 *pRegs;
-
-	pr_debug("!!!!MTC: mtc_probe()\n");
-	/* Allocate space for device private data */
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		rc = -ENOMEM;
-		goto err;
-	}
-	dev_set_drvdata(&pdev->dev, &dev);
-	kref_init(&dev->ref);
-	dev->pdev = pdev;
-
-	/* Map hardware registers */
-	regs = of_iomap(pdev->dev.of_node, 0);
-	if (!regs) {
-		rc = -EINVAL;
-		goto err;
-	}
-	pRegs = (u32 *) regs;
-#ifdef __MTC_SIMULATION
-	dev->regs = &_mtc_regs;
-	dev->prgmem = _mtc_prgmem;
-	dev->tdomem = _mtc_tdomem;
-
-#else
-	dev->regs = regs;
-	dev->prgmem =  pRegs + MTC_PRGMEM_OFFSET/4;
-	dev->tdomem =  pRegs + MTC_TDOMEM_OFFSET/4;
-#endif
-	/* Attach to IRQ */
-	dev->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
-	rc = request_irq(dev->irq, mtc_isr, 0, "mtc", &dev);
-	if (rc)
-		goto err;
-
-	/* Initialize hardware */
-	/* ... */
-
-	/*
-	 * Register device client interface
-	 */
-
-	dev->char_device.minor = MISC_DYNAMIC_MINOR;
-	dev->char_device.name = "mtc";
-	dev->char_device.fops = &mtc_char_ops;
-
-	rc = misc_register(&dev->char_device);
-	if (rc)
-		goto err;
-	set_bit(FLAG_REGISTERED, &dev->flags);
-
-	return 0;
-
- err:
-	if (dev)
-		kref_put(&dev->ref, mtc_destroy);
-	dev_err(&pdev->dev, "Failed to probe device (%d)\n", rc);
-	return rc;
-}
-
-/**
- * mtc_remove
- */
-static int mtc_remove(struct platform_device *pdev)
-{
-	struct mtc_device *dev = dev_get_drvdata(&pdev->dev);
-
-	kref_put(&dev->ref, mtc_destroy);
-	return 0;
-}
-
-/*
- * mtc_destroy
- *
- * Called when refcount reaches zero to unregister device and free resources.
- */
-static void mtc_destroy(struct kref *ref)
-{
-	struct mtc_device *dev = container_of(ref, struct mtc_device, ref);
-
-	dev_set_drvdata(&dev->pdev->dev, NULL);
-	if (test_and_clear_bit(FLAG_REGISTERED, &dev->flags))
-		misc_deregister(&dev->char_device);
-	if (dev->irq)
-		free_irq(dev->irq, &dev);
-	iounmap(dev->regs);
-	kfree(dev);
-}
-
-#ifdef CONFIG_PM
-static int mtc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return -1;
-}
-
-static int mtc_resume(struct platform_device *pdev)
-{
-	return -1;
-}
-#else
-#define mtc_suspend	NULL
-#define mtc_resume	NULL
-#endif
-
-static const struct of_device_id mtc_of_ids[] = {
-	{.compatible = "lsi,mtc"},
-	{}
-};
-
-static struct platform_driver mtc_driver = {
-	.driver = {
-		   .name = "mtc",
-		   .owner = THIS_MODULE,
-		   .of_match_table = mtc_of_ids,
-		   },
-	.probe = mtc_probe,
-	.remove = mtc_remove,
-	.suspend = mtc_suspend,
-	.resume = mtc_resume
-};
-
-module_platform_driver(mtc_driver);
-
-MODULE_AUTHOR("LSI Corporation");
-MODULE_DESCRIPTION("Master Test Controller driver");
-MODULE_LICENSE("GPL");
-
-/* MTC operating mode. */
-#define  LSI_MTC_BOARDTEST_MODE 0  /* MTC Board Test Mode.  */
-#define  LSI_MTC_EXTTEST_MODE   1  /* MTC External Test Mode DBC3 excluded. */
-#define  LSI_MTC_SYSTTEST_MODE  2  /* MTC System Test Mode DBC3 excluded. */
-
-/* Test data output recording mode. */
-/* Do not save TDO data during shiftir and shiftdr. */
-#define   LSI_MTC_TDO_NOREC 0
-  /* Do not save TDO data during shiftir, but save TDO during shiftdr. */
-#define   LSI_MTC_TDO_NOREC_SHIFTIR 1
-  /* Do not save TDO data during shiftdr, but save TDO during shiftir. */
-#define  LSI_MTC_TDO_NOREC_SHIFTDR 2
-  /* Save TDO data during shiftdr and shiftir. */
-#define   ACELL_MTCI_TDO_REC_ALL  3
-
-/* Test data output buffer mode. */
-/* TDO output buffer always enabled. */
-#define  LSI_MTC_TDOBUF_ENABLED 0
-/* TDO output buffer active  when in shift-DR or shift-IR states
-   and inactive in all other states. */
-#define  LSI_MTC_TDOBUF_TRISTATE_CAPABLE 1
-
-/* config MTC hardware */
-static long _mtc_config(struct mtc_device *dev, struct lsi_mtc_cfg_t *pMTCCfg)
-{
-
-	struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = { 0 };
-	struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t cfg1 = { 0 };
-	struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = { 0 };
-	u32	init_reg = { 0 };
-
-	if ((!pMTCCfg) || (!dev))
-		return -EINVAL;
-
-	/* 1. stop testgen state machine */
-	cfg0 =
-	    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
-	      &(dev->regs->config0));
-	cfg0.start_stopn = 0;
-	dev->regs->config0 = *((u32 *) &cfg0);
-
-	/* 2. reset testgen, and init mem */
-	exec1.sw_reset = 1;
-	dev->regs->execute = *((u32 *) &exec1);
-	dev->regs->mem_init = 0x202;
-	/* wait for the init to complete */
-	udelay(2);
-	init_reg = readl(&(dev->regs->mem_init));
-	if ((init_reg & 0x101) != 0x101) {
-		pr_debug("warning: mem_init failed value=0x%x (expected:0x101)\n",
-			       init_reg);
-	}
-	/* clear ECC interrupt status */
-	dev->regs->ecc_int_status = 0xF;
-
-	/* 3. config MTC */
-	cfg0 =
-	    *((struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t *)
-	      &(dev->regs->config0));
-
-	cfg1 =
-	    *((struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t *)
-	      &(dev->regs->config1));
-
-	/*set MTC mode */
-	if (pMTCCfg->opMode == LSI_MTC_BOARDTEST_MODE) {
-		/* board testing mode */
-		cfg0.cfg_config_ctl = 0;
-	} else if (pMTCCfg->opMode == LSI_MTC_EXTTEST_MODE) {
-		/* external testing mode */
-		cfg0.cfg_config_ctl = 3;
-	} else {
-		/* system testing mode */
-		cfg0.cfg_config_ctl = 5;
-
-	}
-
-	/* set clock rate */
-	cfg0.rate_sel = pMTCCfg->clkSpeed;
-
-	/* set TDO buffer mode */
-	cfg0.mtc_mpu_tdo_inactive_en = pMTCCfg->buffMode;
-
-	/* set TDO recording mode */
-	if (pMTCCfg->recMode == LSI_MTC_TDO_NOREC) {
-		cfg1.record_tdo_in_shift_ir_state = 0;
-		cfg1.record_tdo_in_shift_dr_state = 0;
-	} else if (pMTCCfg->recMode == LSI_MTC_TDO_NOREC_SHIFTIR) {
-		cfg1.record_tdo_in_shift_ir_state = 0;
-		cfg1.record_tdo_in_shift_dr_state = 1;
-	} else if (pMTCCfg->recMode == LSI_MTC_TDO_NOREC_SHIFTDR) {
-		cfg1.record_tdo_in_shift_ir_state = 1;
-		cfg1.record_tdo_in_shift_dr_state = 0;
-	} else {
-		/* recMode == ACELL_MTCI_TDO_REC_ALL */
-		cfg1.record_tdo_in_shift_ir_state = 1;
-		cfg1.record_tdo_in_shift_dr_state = 1;
-	}
-
-	dev->regs->config0 = *((u32 *) &cfg0);
-	dev->regs->config1 = *((u32 *) &cfg1);
-
-#ifdef DEBUG
-	pr_debug("buffmode=%d,rate=%d dev->regs->config0 =0x%x\n",
-		 pMTCCfg->buffMode, pMTCCfg->clkSpeed, dev->regs->config0);
-
-	pr_debug("dev->regs->config1 =0x%x, dev->regs-> execute=0x%x\n",
-		 dev->regs->config1, dev->regs->execute);
-#endif
-	/* test */
-	return 0;
-}
diff --git a/drivers/misc/lsi-ncr.c b/drivers/misc/lsi-ncr.c
deleted file mode 100644
index a5fd0f3..0000000
--- a/drivers/misc/lsi-ncr.c
+++ /dev/null
@@ -1,1277 +0,0 @@
-/*
- *  Copyright (C) 2009 LSI Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.
- */
-
-#include <linux/module.h>
-#include <linux/io.h>
-#include <linux/lsi-ncr.h>
-#include <linux/of.h>
-#include <linux/delay.h>
-#include <linux/sizes.h>
-
-static int ncr_available;
-static int nca_big_endian = 1;
-static int is_5500;
-static int is_5600;
-static int is_6700;
-static void __iomem *nca;
-static void __iomem *apb2ser0;
-
-#define WFC_TIMEOUT (400000)
-
-/*
- * We provide both 'normal' and 'nolock' versions of the
- * ncr_read/write functions. For normal operation we use
- * locking to provide thread-safe operation.
- * There are two levels of locking.
- *
- * 1. ncr_spin_lock -
- *      This is a high-level lock that protects the NCA PIO
- *      registers from concurrent use. The NCA PIO mechanism
- *      only supports a single thread of execution.
- *
- * 2. nca_access_lock -
- *       This is a low-level lock that protects each individual
- *       register read/write to the NCA registers. This is a
- *       workaround for a bug in rev 1.0 silicon where the bus
- *       interface may hang if the NCA is subjected to simultaneous
- *       requests from multiple masters.
- *
- * The 'nolock' versions of ncr_read/write should only be used in
- * special cases where the caller can guarantee there will be no
- * other threads of execution.
- */
-
-/* Lock #1 : Protect NCA PIO registers from concurrent use. */
-static DEFINE_RAW_SPINLOCK(ncr_spin_lock);
-
-/* Lock #2 : Protect each individual NCA register access. */
-DEFINE_RAW_SPINLOCK(nca_access_lock);
-EXPORT_SYMBOL(nca_access_lock);
-
-static unsigned long ncr_spin_flags;
-
-#ifdef CONFIG_ARCH_AXXIA_NCR_RESET_CHECK
-/*
- * define behavior if NCA register read/write is called while
- * the axxia device is being reset. Any attempt to access NCA
- * AXI registers while the NCA is in reset will hang the system.
- *
- * Due to higher level locking (ncr_spin_lock) this should not
- * occur as part of normal config ring access (ncr_read/write),
- * so we handle this condition as a BUG(). If it turns out there
- * is some valid case where this may occur we can re-implement
- * this as a wait loop.
- */
-int ncr_reset_active;
-EXPORT_SYMBOL(ncr_reset_active);
-
-#define AXXIA_NCR_RESET_ACTIVE_CHECK()			\
-	do { if (ncr_reset_active) BUG(); } while (0)
-#else
-#define AXXIA_NCR_RESET_ACTIVE_CHECK()
-#endif
-
-#define LOCK_DOMAIN 0
-
-union command_data_register_0 {
-	unsigned int raw;
-	struct {
-#ifdef __BIG_ENDIAN
-		unsigned int start_done:1;
-		unsigned int unused:6;
-		unsigned int local_bit:1;
-		unsigned int status:2;
-		unsigned int byte_swap_enable:1;
-		unsigned int cfg_cmpl_int_enable:1;
-		unsigned int cmd_type:4;
-		unsigned int dbs:16;
-#else
-		unsigned int dbs:16;
-		unsigned int cmd_type:4;
-		unsigned int cfg_cmpl_int_enable:1;
-		unsigned int byte_swap_enable:1;
-		unsigned int status:2;
-		unsigned int local_bit:1;
-		unsigned int unused:6;
-		unsigned int start_done:1;
-#endif
-	} __packed bits;
-} __packed;
-
-union command_data_register_1 {
-	unsigned int raw;
-	struct {
-		unsigned int target_address:32;
-	} __packed bits;
-} __packed;
-
-union command_data_register_2 {
-	unsigned int raw;
-	struct {
-#ifdef __BIG_ENDIAN
-		unsigned int unused:16;
-		unsigned int target_node_id:8;
-		unsigned int target_id_address_upper:8;
-#else
-		unsigned int target_id_address_upper:8;
-		unsigned int target_node_id:8;
-		unsigned int unused:16;
-#endif
-	} __packed bits;
-} __packed;
-
-static int trace;
-module_param(trace, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
-MODULE_PARM_DESC(trace, "Trace NCR Accesses");
-
-static int trace_value_read;
-module_param(trace_value_read, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
-MODULE_PARM_DESC(trace_value_read, "Trace NCR Value Read");
-
-/*
- * ncr_register_read/write
- *   low-level access functions to Axxia registers,
- *   with checking to ensure device is not currently
- *   held in reset.
- */
-unsigned int
-ncr_register_read(unsigned int *address)
-{
-	unsigned int value;
-
-	AXXIA_NCR_RESET_ACTIVE_CHECK();
-	value = __raw_readl(address);
-
-	if (0 == nca_big_endian)
-		return value;
-
-	return be32_to_cpu(value);
-}
-
-void
-ncr_register_write(const unsigned int value, unsigned int *address)
-{
-	AXXIA_NCR_RESET_ACTIVE_CHECK();
-
-	if (0 == nca_big_endian)
-		__raw_writel(value, address);
-	else
-		__raw_writel(cpu_to_be32(value), address);
-}
-
-/*
- * ncr_register_read/write_lock
- *   access functions for Axxia NCA block.
- *   These functions protect the register access with a spinlock.
- *   This is needed to workaround an AXM55xx v1.0 h/w bug.
- *
- */
-static unsigned int
-ncr_register_read_lock(unsigned int *address)
-{
-	unsigned int value;
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&nca_access_lock, flags);
-	value = ncr_register_read(address);
-	raw_spin_unlock_irqrestore(&nca_access_lock, flags);
-
-	return value;
-}
-
-static void
-ncr_register_write_lock(const unsigned value, unsigned int *address)
-{
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&nca_access_lock, flags);
-	ncr_register_write(value, address);
-	raw_spin_unlock_irqrestore(&nca_access_lock, flags);
-}
-
-/*
- * define two sets of function pointers for low-level register
- * access - one with locking and one without.
- */
-struct ncr_io_fns {
-	unsigned int (*rd)(unsigned int *address);
-	void (*wr)(const unsigned int value, unsigned int *address);
-};
-
-struct ncr_io_fns ncr_io_fn_lock = {
-	ncr_register_read_lock,
-	ncr_register_write_lock
-};
-
-struct ncr_io_fns ncr_io_fn_nolock = {
-	ncr_register_read,
-	ncr_register_write
-};
-
-struct ncr_io_fns *default_io_fn;
-
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_lock
-
-  Used to serialize all access to NCA PIO interface.
-*/
-
-int
-ncr_lock(int domain)
-{
-	raw_spin_lock_irqsave(&ncr_spin_lock, ncr_spin_flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_lock);
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_unlock
-
-  Used to serialize all access to NCA PIO interface.
-*/
-
-void
-ncr_unlock(int domain)
-{
-	raw_spin_unlock_irqrestore(&ncr_spin_lock, ncr_spin_flags);
-
-	return;
-}
-EXPORT_SYMBOL(ncr_unlock);
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_pio_error_dump
-*/
-
-static void
-ncr_pio_error_dump(struct ncr_io_fns *io_fn, char *str)
-{
-	unsigned int cdr0, cdr1, cdr2;
-	unsigned int stat0, stat1;
-
-	cdr0 = io_fn->rd((unsigned int *)(nca + 0xf0));
-	cdr1 = io_fn->rd((unsigned int *)(nca + 0xf4));
-	cdr2 = io_fn->rd((unsigned int *)(nca + 0xf8));
-
-	stat0 = io_fn->rd((unsigned int *)(nca + 0xe4));
-	stat1 = io_fn->rd((unsigned int *)(nca + 0xe8));
-
-	pr_err("lsi-ncr: %8s failed, error status : 0x%08x 0x%08x\n",
-	       str, stat0, stat1);
-	pr_err("lsi-ncr:  CDR0-2: 0x%08x 0x%08x 0x%08x\n",
-	       cdr0, cdr1, cdr2);
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_check_pio_status
-*/
-
-static int
-ncr_check_pio_status(struct ncr_io_fns *io_fn, char *str)
-{
-	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
-	union command_data_register_0 cdr0;
-
-	/*
-	  Make sure any previous commands completed, and check for errors.
-	*/
-
-	do {
-		cdr0.raw = io_fn->rd((unsigned int *)(nca + 0xf0));
-	} while ((0x1 == cdr0.bits.start_done) &&
-		 (time_before(jiffies, timeout)));
-
-	if (0x1 == cdr0.bits.start_done) {
-		/* timed out without completing */
-		pr_err("lsi-ncr: PIO operation timeout cdr0=0x%08x!\n",
-		       cdr0.raw);
-		ncr_pio_error_dump(io_fn, str);
-		BUG();
-
-		return -1;
-	}
-
-	if (cdr0.raw && (0x3 != cdr0.bits.status)) {
-		/* completed with non-success status */
-		ncr_pio_error_dump(io_fn, str);
-		/* clear CDR0 to allow subsequent commands to complete */
-		io_fn->wr(0, (unsigned int *) (nca + 0xf0));
-
-		/*
-		 * we now treat any config ring error as a BUG().
-		 * this should never occur during normal operation with
-		 * 'good' system software.
-		 *
-		 * In the debug/lab environment the config ring errors
-		 * can occur more often. If this BUG() becomes too onerous
-		 * we may provide a way for the RTE to suppress this BUG()
-		 */
-		BUG();
-		return -1;
-	}
-
-	return 0;
-}
-
-union ncp_apb2ser_indirect_command {
-	unsigned     raw;
-
-	struct {
-#ifdef __BIG_ENDIAN
-		unsigned      valid                                     :  1;
-		unsigned      hwrite                                    :  1;
-		unsigned      tshift                                    :  4;
-		unsigned      hsize                                     :  3;
-		unsigned      htrans                                    :  2;
-		unsigned      reserved                                  :  5;
-		unsigned      haddr                                     : 16;
-#else    /* Little Endian */
-		unsigned      haddr                                     : 16;
-		unsigned      reserved                                  :  5;
-		unsigned      htrans                                    :  2;
-		unsigned      hsize                                     :  3;
-		unsigned      tshift                                    :  4;
-		unsigned      hwrite                                    :  1;
-		unsigned      valid                                     :  1;
-#endif
-	} __packed bits;
-} __packed;
-
-/*
-  ------------------------------------------------------------------------------
-  apb2ser_indirect_setup
-*/
-
-static int
-apb2ser_indirect_setup(unsigned int region,
-		       unsigned int *indirect_offset,
-		       unsigned int *transfer_width)
-{
-	unsigned int node = NCP_NODE_ID(region);
-	unsigned int target = NCP_TARGET_ID(region);
-	unsigned int base;
-
-	if (is_5600)
-		if ((node < 0x110) || (node > 0x11a))
-			return -1;
-
-	if (is_6700)
-		if ((node < 0x110) || (node > 0x11f))
-			return -1;
-
-	if (node <= 0x114) {
-		base = (node - 0x110) * 2;
-	} else if (node >= 0x116) {
-		base = (node - 0x111) * 2;
-	} else {
-		if (is_5600)
-			base = 0x14;
-		else
-			base = 0x1e;
-	}
-
-	*indirect_offset = ((base + target) * 0x10000);
-	*transfer_width = (target > 0) ? 2 : 4;
-	udelay(10);
-
-	return 0;
-}
-
-/*
- * ------------------------------------------------------------------------------
- * apb2ser_indirect_access
- */
-
-static int
-apb2ser_indirect_access(unsigned int offset,
-			unsigned int indirect_offset,
-			unsigned int transfer_width,
-			int write,
-			unsigned int *value)
-{
-	union ncp_apb2ser_indirect_command indcmd;
-	unsigned wfc;
-
-	memset(&indcmd, 0, sizeof(union ncp_apb2ser_indirect_command));
-	indcmd.bits.valid = 1;
-	indcmd.bits.hwrite = (0 == write) ? 0 : 1;
-	indcmd.bits.tshift = 0xf;
-	indcmd.bits.htrans = 2;
-	indcmd.bits.hsize = 2;
-	indcmd.bits.haddr = offset;
-
-	if (0 != write)
-		writel(*value, (apb2ser0 + indirect_offset));
-
-	pr_debug("ncr: indcmd.raw=0x%x\n", indcmd.raw);
-	writel(indcmd.raw, (apb2ser0 + indirect_offset + 4));
-	wfc = WFC_TIMEOUT;
-
-	do {
-		--wfc;
-		indcmd.raw = readl(apb2ser0 + indirect_offset + 4);
-	} while (1 == indcmd.bits.valid && 0 < wfc);
-
-	if (0 == wfc) {
-		pr_err("APB2SER Timeout!\n");
-
-		return -1;
-	}
-
-	if (0 == write)
-		*value = readl(apb2ser0 + indirect_offset + 8);
-
-	return 0;
-}
-
-/*
- * ------------------------------------------------------------------------------
- * ncr_apb2ser
- */
-
-static int
-ncr_apb2ser(unsigned int region,
-	    unsigned int offset,
-	    int write,
-	    unsigned int *value)
-{
-	int rc;
-	unsigned int indirect_offset;
-	unsigned int transfer_width;
-
-	rc = apb2ser_indirect_setup(region, &indirect_offset, &transfer_width);
-
-	if (0 != rc) {
-		pr_err("APB2SER Indirect Setup Failed!\n");
-
-		return -1;
-	}
-
-	rc = apb2ser_indirect_access(offset, indirect_offset, transfer_width,
-				     write, value);
-
-	if (0 != rc) {
-		pr_err("APB2SER Indirect Setup Failed!\n");
-
-		return -1;
-	}
-
-	return 0;
-}
-
-union ncp_cobalt_serdes_ctrl98 {
-	unsigned short raw;
-
-	struct {
-#ifdef __BIG_ENDIAN
-	unsigned short reserved_b53 : 13;
-	unsigned short cr_ack_clear :  1;
-	unsigned short cr_rd        :  1;
-	unsigned short cr_wr        :  1;
-#else    /* Little Endian */
-	unsigned short cr_wr        :  1;
-	unsigned short cr_rd        :  1;
-	unsigned short cr_ack_clear :  1;
-	unsigned short reserved_b53 : 13;
-#endif
-	} __packed bits;
-} __packed;
-
-
-union ncp_cobalt_serdes_ctrl99 {
-	unsigned short raw;
-
-	struct {
-#ifdef __BIG_ENDIAN
-		unsigned short reserved : 15;
-		unsigned short cr_ack   :  1;
-#else    /* Little Endian */
-		unsigned short cr_ack   :  1;
-		unsigned short reserved : 15;
-#endif
-	} __packed bits;
-} __packed;
-
-/*
- * ------------------------------------------------------------------------------
- * ncr_apb2ser_e12
- */
-
-static int
-ncr_apb2ser_e12(unsigned int region,
-		unsigned int offset,
-		int write,
-		unsigned int *value)
-{
-	unsigned int indirect_offset;
-	unsigned int transfer_width;
-	union ncp_cobalt_serdes_ctrl98 hss_cobalt_ctrl_98 = {0};
-	union ncp_cobalt_serdes_ctrl99 hss_cobalt_ctrl_99 = {0};
-	unsigned short e12_addr = 0;
-	unsigned int ctrl_96_off;
-	unsigned int ctrl_97_off;
-	unsigned int ctrl_98_off;
-	unsigned int ctrl_99_off;
-	unsigned int ctrl_224_off;
-
-	if (0 !=
-	    apb2ser_indirect_setup(region, &indirect_offset, &transfer_width))
-		return -1;
-
-	if (is_5600) {
-		ctrl_96_off = 0x00c0;
-		ctrl_97_off = 0x00c2;
-		ctrl_98_off = 0x00c4;
-		ctrl_99_off = 0x00c6;
-		ctrl_224_off = 0x01c0;
-	} else {
-		ctrl_96_off = 0x0180;
-		ctrl_97_off = 0x0184;
-		ctrl_98_off = 0x0188;
-		ctrl_99_off = 0x018c;
-		ctrl_224_off = 0x0380;
-		offset >>= 1;
-	}
-
-	if ((offset >= 0x1000) && (offset <= 0x10d0))
-		e12_addr = (offset - 0x1000) / 2;
-	else if (offset >= 0x2000)
-		e12_addr = offset / 2;
-
-	apb2ser_indirect_access(ctrl_96_off, indirect_offset, 4,
-				1, (unsigned int *)&e12_addr);
-
-	if (write) {
-		apb2ser_indirect_access(ctrl_97_off, indirect_offset, 4, 1,
-					value);
-		hss_cobalt_ctrl_98.bits.cr_rd = 0; /* bus read strobe */
-		hss_cobalt_ctrl_98.bits.cr_wr = 1;
-	} else  {
-		hss_cobalt_ctrl_98.bits.cr_rd = 1; /* bus read strobe */
-		hss_cobalt_ctrl_98.bits.cr_wr = 0;
-	}
-
-	hss_cobalt_ctrl_98.bits.cr_ack_clear = 0;
-	apb2ser_indirect_access(ctrl_98_off, indirect_offset, 4, 1,
-				(unsigned int *)&hss_cobalt_ctrl_98.raw);
-
-	/* poll for cr_ack to get set */
-	do {
-		apb2ser_indirect_access(ctrl_99_off, indirect_offset, 4, 0,
-					(unsigned int *)
-					&hss_cobalt_ctrl_99.raw);
-	} while (0 == hss_cobalt_ctrl_99.bits.cr_ack);
-
-	hss_cobalt_ctrl_98.bits.cr_rd = 0;
-	hss_cobalt_ctrl_98.bits.cr_wr = 0;
-	hss_cobalt_ctrl_98.bits.cr_ack_clear = 1;
-	apb2ser_indirect_access(ctrl_98_off, indirect_offset, 4, 1,
-				(unsigned int *)&hss_cobalt_ctrl_98.raw);
-
-	hss_cobalt_ctrl_98.bits.cr_ack_clear = 0;
-	apb2ser_indirect_access(ctrl_98_off, indirect_offset, 4, 1,
-				(unsigned int *)&hss_cobalt_ctrl_98.raw);
-
-	if (!write)
-		apb2ser_indirect_access(ctrl_224_off, indirect_offset, 4, 0,
-					value);
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_0x115_5500
-*/
-
-static int
-ncr_0x115_5500(unsigned int region, unsigned int offset, int write,
-	       unsigned int *value)
-{
-	unsigned int control;
-	void __iomem *base;
-	unsigned wfc_timeout = 400000;
-
-	if (0xffff < offset)
-		return -1;
-
-	switch (NCP_TARGET_ID(region)) {
-	case 0:
-		base = (apb2ser0 + 0x1e0);
-		break;
-	case 1:
-		base = (apb2ser0 + 0x1f0);
-		break;
-	case 2:
-		base = (apb2ser0 + 0x200);
-		break;
-	case 3:
-		base = (apb2ser0 + 0x210);
-		break;
-	case 4:
-		base = (apb2ser0 + 0x220);
-		break;
-	case 5:
-		base = (apb2ser0 + 0x230);
-		break;
-	default:
-		return -1;
-	}
-
-	if ((NCP_TARGET_ID(region) == 0x1) ||
-	    (NCP_TARGET_ID(region) == 0x4))
-		control = 0x84c00000;
-	else
-		control = 0x85400000;
-
-	if (0 != write)
-		control |= 0x40000000;
-
-	writel((control + offset), (base + 4));
-
-	do {
-		--wfc_timeout;
-		*((unsigned long *)value) = readl(base + 4);
-	} while (0 != (*((unsigned long *)value) & 0x80000000) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout)
-		return -1;
-
-	if (0 == write) {
-		if ((NCP_TARGET_ID(region) == 0x1) ||
-		    (NCP_TARGET_ID(region) == 0x4)) {
-			*((unsigned short *)value) = readl(base + 8);
-		} else {
-			*((unsigned long *)value) = readl(base + 8);
-		}
-	}
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_axi2ser
-*/
-
-static int
-ncr_axi2ser(unsigned int region, unsigned int offset, int write,
-	    unsigned int *value)
-{
-	unsigned int *address;
-
-	address = apb2ser0;
-
-	switch (NCP_NODE_ID(region)) {
-	case 0x153:
-		if (0 != is_5500) {
-			address += (offset & (~0x3));
-
-			/*
-			 * Copy from buffer to the data words.
-			 */
-
-			if (0 != write)
-				*((unsigned long *)address) =
-					*((unsigned long *)value);
-			else
-				*((unsigned long *)value) =
-					*((unsigned long *)address);
-		}
-		break;
-	case 0x155:
-		address += 0x800000;
-		break;
-	case 0x156:
-		address += 0xc00000;
-		break;
-	case 0x165:
-		address += 0x1400000;
-		break;
-	case 0x167:
-		address += 0x1c00000;
-		break;
-	default:
-		BUG();
-		break;
-	}
-
-	if (0x156 == NCP_NODE_ID(region))
-		address += NCP_TARGET_ID(region) * 0x4000;
-	else
-		address += NCP_TARGET_ID(region) * 0x10000;
-
-	address += offset;
-
-	if (0 == write)
-		*value = readl(address);
-	else
-		writel(*value, address);
-
-	return 0;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Public Interface
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  __ncr_read
-*/
-
-static int
-__ncr_read(struct ncr_io_fns *io_fn,
-	   unsigned int region, unsigned long address, int number,
-	   void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	unsigned char *input = buffer;
-
-	if (0 == ncr_available)
-		return -1;
-
-	pr_debug("%s:%d - region=0x%x node=0x%x target=0x%x\n",
-	      __FILE__, __LINE__,
-	      region, NCP_NODE_ID(region), NCP_TARGET_ID(region));
-
-	if (0x110 <= NCP_NODE_ID(region) &&
-	    0x11f >= NCP_NODE_ID(region)) {
-		int rc;
-
-		if (is_5500) {
-			rc = ncr_0x115_5500(region, address, 0, buffer);
-		} else if ((NCP_TARGET_ID(region) != 0) &&
-			   (address >= 0x1000)) {
-			rc = ncr_apb2ser_e12(region, address, 0, buffer);
-		} else {
-			rc = ncr_apb2ser(region, address, 0, buffer);
-		}
-
-		if (0 != rc)
-			return -1;
-	} else if (0x153 == NCP_NODE_ID(region) ||
-		   0x155 == NCP_NODE_ID(region) ||
-		   0x156 == NCP_NODE_ID(region) ||
-		   0x165 == NCP_NODE_ID(region) ||
-		   0x167 == NCP_NODE_ID(region)) {
-		if (0 != ncr_axi2ser(region, address, 0, buffer))
-			return -1;
-	} else if (0x100 > NCP_NODE_ID(region)) {
-		/* make sure any previous command has completed */
-		if (0 != ncr_check_pio_status(io_fn, "previous"))
-			return -1;
-
-		/*
-		  Set up the read command.
-		*/
-
-		cdr2.raw = 0;
-		cdr2.bits.target_node_id = NCP_NODE_ID(region);
-		cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-		io_fn->wr(cdr2.raw, (unsigned int *) (nca + 0xf8));
-
-		cdr1.raw = 0;
-		cdr1.bits.target_address = (address >> 2);
-		io_fn->wr(cdr1.raw, (unsigned int *) (nca + 0xf4));
-
-		cdr0.raw = 0;
-		cdr0.bits.start_done = 1;
-
-		if (0xff == cdr2.bits.target_id_address_upper)
-			cdr0.bits.local_bit = 1;
-
-		cdr0.bits.cmd_type = 4;
-		/* TODO: Verify number... */
-		cdr0.bits.dbs = (number - 1);
-		io_fn->wr(cdr0.raw, (unsigned int *) (nca + 0xf0));
-		mb();
-
-		/*
-		  Wait for completion.
-		*/
-		if (0 != ncr_check_pio_status(io_fn, "read"))
-			return -1;
-
-		/*
-_		  Copy data words to the buffer.
-		*/
-
-		address = (unsigned long)(nca + 0x1000);
-		while (4 <= number) {
-			*((unsigned int *) buffer) =
-				io_fn->rd((unsigned int *) address);
-			address += 4;
-			buffer += 4;
-			number -= 4;
-		}
-
-		if (0 < number) {
-			unsigned int temp =
-				io_fn->rd((unsigned int *) address);
-			memcpy((void *) buffer, &temp, number);
-		}
-	} else {
-		printk(KERN_ERR "Unhandled Region (r): 0x%x 0x%x 0%x 0x%lx\n",
-		       region, NCP_NODE_ID(region), NCP_TARGET_ID(region),
-		       address);
-
-		return -1;
-	}
-
-	if (0 != trace) {
-		printk("ncpRead");
-
-		switch (number) {
-		case 1:
-			printk("   -w8 0.");
-			break;
-		case 2:
-			printk("  -w16 0.");
-			break;
-		case 4:
-			printk("       0.");
-			break;
-		default:
-			break;
-		}
-
-		printk("%u.%u.0x00%08lx 1",
-		       NCP_NODE_ID(region),
-		       NCP_TARGET_ID(region),
-		       address);
-
-		if (0 != trace_value_read) {
-			switch (number) {
-			case 1:
-				printk(" [0x%02x]\n",
-				       *((unsigned char *)input));
-				break;
-			case 2:
-				printk(" [0x%04x]\n",
-				       *((unsigned short *)input));
-				break;
-			case 4:
-				printk(" [0x%08x]\n",
-				       *((unsigned int *)input));
-				break;
-			default:
-				break;
-			}
-		} else {
-			printk("\n");
-		}
-	}
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_read_nolock
-*/
-
-int
-ncr_read_nolock(unsigned int region, unsigned int address,
-		int number, void *buffer)
-{
-	if (0 == ncr_available)
-		return -1;
-
-	return __ncr_read(&ncr_io_fn_nolock, region, address, number, buffer);
-}
-EXPORT_SYMBOL(ncr_read_nolock);
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_read
-*/
-
-int
-ncr_read(unsigned int region, unsigned int address, int number, void *buffer)
-{
-	int rc;
-
-	if (0 == ncr_available)
-		return -1;
-
-	ncr_lock(LOCK_DOMAIN);
-
-	/* call __ncr_read with chip version dependent io_fn */
-	rc = __ncr_read(default_io_fn, region, address, number, buffer);
-
-	ncr_unlock(LOCK_DOMAIN);
-
-	return rc;
-}
-
-EXPORT_SYMBOL(ncr_read);
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_read32
-*/
-
-int
-ncr_read32(unsigned int region, unsigned int offset, unsigned int *value)
-{
-	unsigned int val;
-	int rc;
-
-	rc = ncr_read(region, offset, 4, &val);
-	pr_debug("%s:%d - read 0x%x from 0x%x.0x%x.0x%x rc=%d\n",
-		 __FILE__, __LINE__, val,
-		 NCP_NODE_ID(region), NCP_TARGET_ID(region), offset, rc);
-	*value = val;
-
-	return rc;
-}
-
-EXPORT_SYMBOL(ncr_read32);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_write
-*/
-
-static int
-__ncr_write(struct ncr_io_fns *io_fn,
-	    unsigned int region, unsigned int address, int number,
-	    void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	unsigned long data_word_base;
-	int dbs = (number - 1);
-
-	if (0 == ncr_available)
-		return -1;
-
-	if (0 != trace) {
-		printk("ncpWrite");
-
-		switch (number) {
-		case 1:
-			printk("  -w8 0.");
-			break;
-		case 2:
-			printk(" -w16 0.");
-			break;
-		case 4:
-			printk("      0.");
-			break;
-		default:
-			break;
-		}
-
-		printk("%u.%u.0x00%08x",
-		       NCP_NODE_ID(region),
-		       NCP_TARGET_ID(region),
-		       address);
-
-		switch (number) {
-		case 1:
-			printk(" 0x%02x\n", *((unsigned char *)buffer));
-			break;
-		case 2:
-			printk(" 0x%04x\n", *((unsigned short *)buffer));
-			break;
-		case 4:
-			printk(" 0x%08x\n", *((unsigned int *)buffer));
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (0x110 <= NCP_NODE_ID(region) &&
-	    0x11f >= NCP_NODE_ID(region)) {
-		int rc;
-
-		if (is_5500) {
-			rc = ncr_0x115_5500(region, address, 1, buffer);
-		} else if ((NCP_TARGET_ID(region) != 0) &&
-			   (address >= 0x1000)) {
-			rc = ncr_apb2ser_e12(region, address, 1, buffer);
-		} else {
-			rc = ncr_apb2ser(region, address, 1, buffer);
-		}
-
-		if (0 != rc)
-			return -1;
-	} else if (0x153 == NCP_NODE_ID(region) ||
-		   0x155 == NCP_NODE_ID(region) ||
-		   0x156 == NCP_NODE_ID(region) ||
-		   0x165 == NCP_NODE_ID(region) ||
-		   0x167 == NCP_NODE_ID(region)) {
-		if (0 != ncr_axi2ser(region, address, 1, buffer))
-			return -1;
-	} else if (0x100 > NCP_NODE_ID(region)) {
-		/* make sure any previous command has completed */
-		if (0 != ncr_check_pio_status(io_fn, "previous"))
-			return -1;
-
-		/*
-		  Set up the write.
-		*/
-
-		cdr2.raw = 0;
-		cdr2.bits.target_node_id = NCP_NODE_ID(region);
-		cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-		io_fn->wr(cdr2.raw, (unsigned *) (nca + 0xf8));
-
-		cdr1.raw = 0;
-		cdr1.bits.target_address = (address >> 2);
-		io_fn->wr(cdr1.raw, (unsigned *) (nca + 0xf4));
-
-		/*
-		  Copy from buffer to the data words.
-		*/
-
-		data_word_base = (unsigned long)(nca + 0x1000);
-
-		while (4 <= number) {
-			io_fn->wr(*((unsigned int *)buffer),
-				  (unsigned int *)data_word_base);
-			data_word_base += 4;
-			buffer += 4;
-			number -= 4;
-		}
-
-		if (0 < number) {
-			unsigned int temp = 0;
-
-			memcpy((void *) &temp, (void *) buffer, number);
-			io_fn->wr(temp, (unsigned *) data_word_base);
-			data_word_base += number;
-			buffer += number;
-			number = 0;
-		}
-
-		cdr0.raw = 0;
-		cdr0.bits.start_done = 1;
-
-		if (0xff == cdr2.bits.target_id_address_upper)
-			cdr0.bits.local_bit = 1;
-
-		cdr0.bits.cmd_type = 5;
-		/* TODO: Verify number... */
-		cdr0.bits.dbs = dbs;
-		io_fn->wr(cdr0.raw, (unsigned *) (nca + 0xf0));
-		mb();
-
-		/*
-		  Wait for completion.
-		*/
-
-		if (0 != ncr_check_pio_status(io_fn, "write"))
-			return -1;
-	} else {
-		printk(KERN_ERR "Unhandled Region (w): 0x%x 0x%x 0x%x 0x%x\n",
-		       region, NCP_NODE_ID(region), NCP_TARGET_ID(region),
-		       address);
-
-		return -1;
-	}
-
-	return 0;
-}
-
-int
-ncr_write_nolock(unsigned int region, unsigned int address, int number,
-		 void *buffer)
-{
-	if (0 == ncr_available)
-		return -1;
-
-	/* call the __ncr_write function with nolock io_fn */
-	return __ncr_write(&ncr_io_fn_nolock,
-			   region, address, number, buffer);
-}
-EXPORT_SYMBOL(ncr_write_nolock);
-
-int
-ncr_write(unsigned int region, unsigned int address, int number,
-	  void *buffer)
-{
-	int rc = 0;
-
-	if (0 == ncr_available)
-		return -1;
-
-	/* grab the ncr_lock */
-	ncr_lock(LOCK_DOMAIN);
-
-	/* call the __ncr_write function with chip-version dependent io_fn */
-	rc = __ncr_write(default_io_fn, region, address, number, buffer);
-
-	/* free the ncr_lock */
-	ncr_unlock(LOCK_DOMAIN);
-
-	return rc;
-}
-EXPORT_SYMBOL(ncr_write);
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_write32
-*/
-
-int
-ncr_write32(unsigned int region, unsigned int offset, unsigned int value)
-{
-	int rc;
-
-	rc = ncr_write(region, offset, 4, &value);
-	pr_debug("%s:%d - wrote 0x%x to 0x%x.0x%x.0x%x rc=%d\n",
-		 __FILE__, __LINE__, value,
-		 NCP_NODE_ID(region), NCP_TARGET_ID(region), offset, rc);
-
-	return rc;
-}
-
-EXPORT_SYMBOL(ncr_write32);
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_start_trace
-*/
-
-void
-ncr_start_trace(void)
-{
-	trace = 1;
-}
-EXPORT_SYMBOL(ncr_start_trace);
-
-/*
- * ------------------------------------------------------------------------------
- * ncr_stop_trace
- */
-
-void
-ncr_stop_trace(void)
-{
-	trace = 0;
-}
-EXPORT_SYMBOL(ncr_stop_trace);
-
-/*
- * ------------------------------------------------------------------------------
- * ncr_init
- */
-
-static int
-ncr_init(void)
-{
-#ifdef CONFIG_ARCH_AXXIA
-	default_io_fn = &ncr_io_fn_nolock;
-
-
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5500-amarillo")) {
-		u32 pfuse;
-		u32 chip_type;
-		u32 chip_ver;
-		void __iomem *syscon;
-
-		syscon = ioremap(0x002010030000ULL, SZ_64K);
-
-		if (WARN_ON(!syscon))
-			return -ENODEV;
-
-		/*
-		 * read chip type/revision to determine if low-level locking
-		 * is required and select the appropriate io_fns.
-		 */
-
-		pfuse = readl(syscon + 0x34);
-		chip_type = pfuse & 0x1f;
-		chip_ver  = (pfuse >> 8) & 0x7;
-
-		if ((chip_type == 0 || chip_type == 9) && (chip_ver == 0)) {
-			/* AXM5516v1.0 needs low-level locking */
-			default_io_fn = &ncr_io_fn_lock;
-			pr_debug("Using NCA lock functions (AXM5500 v1.0)\n");
-		}
-
-		iounmap(syscon);
-	}
-
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5500") ||
-	    of_find_compatible_node(NULL, NULL, "lsi,axm5516")) {
-		pr_debug("Using AXM5500 Addresses\n");
-		nca = ioremap(0x002020100000ULL, 0x20000);
-		apb2ser0 = ioremap(0x002010000000ULL, 0x10000);
-		is_5500 = 1;
-	} else if (of_find_compatible_node(NULL, NULL, "lsi,axm5616")) {
-		pr_debug("Using AXM5600 Addresses\n");
-		nca = ioremap(0x8031080000ULL, 0x20000);
-		apb2ser0 = ioremap(0x8002000000ULL, 0x4000000);
-		is_5600 = 1;
-		pr_debug("0x%lx 0x%lx\n",
-			 (unsigned long)nca,
-			 (unsigned long)apb2ser0);
-	} else if (of_find_compatible_node(NULL, NULL, "lsi,axc6732")) {
-		pr_debug("Using AXC6700 Addresses\n");
-		nca = ioremap(0x8020000000ULL, 0x20000);
-		apb2ser0 = ioremap(0x8002000000ULL, 0x400000);
-		is_6700 = 1;
-		nca_big_endian = 0; /* The 6700 NCA is LE */
-	} else {
-		pr_err("No Valid Compatible String Found for NCR!\n");
-		return -1;
-	}
-#else
-	if (of_find_compatible_node(NULL, NULL, "lsi,acp3500")) {
-		pr_debug("Using ACP3500 Addresses\n");
-		nca = ioremap(0x002000520000ULL, 0x20000);
-		default_io_fn = &ncr_io_fn_nolock;
-	} else {
-		pr_debug("Using ACP34xx Addresses\n");
-		nca = ioremap(0x002000520000ULL, 0x20000);
-		default_io_fn = &ncr_io_fn_lock;
-	}
-#endif
-
-	pr_info("ncr: available\n");
-	ncr_available = 1;
-
-	return 0;
-}
-
-arch_initcall(ncr_init);
-
-MODULE_AUTHOR("John Jacques <john.jacques@intel.com>");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Register Ring access for Axxia");
diff --git a/drivers/misc/lsi-smmon.c b/drivers/misc/lsi-smmon.c
deleted file mode 100644
index dd02647..0000000
--- a/drivers/misc/lsi-smmon.c
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- *  Copyright (C) 2013 LSI Corporation
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  Error monitor for system memory.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/ratelimit.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/of_address.h>
-#include <linux/reboot.h>
-
-#include <mach/ncr.h>
-
-#define APB2_SER3_PHY_ADDR        0x002010030000ULL
-#define APB2_SER3_PHY_SIZE   0x1000
-
-static int log = 1;
-module_param(log, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(log, "Log each error to kernel log.");
-
-static int machineRestart = 1;
-module_param(machineRestart, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(machineRestart, "Machine restart on fatal error.");
-/*
-  AXM55xx memory controller interrupt status bits:
-
-  Bit [24] = The software-initiated control word write has completed.
-  Bit [23] = The user-initiated DLL resync has completed.
-  Bit [22] = A state change has been detected on the dfi_init_complete signal
-	     after initialization.
-  Bit [21] = The assertion of the INHIBIT_DRAM_CMD parameter has successfully
-	     inhibited the command queue.
-  Bit [20] = The register interface-initiated mode register write has completed
-	     and another mode register write may be issued.
-  Bit [19] = A parity error has been detected on the address/control bus on a
-	     registered DIMM.
-  Bit [18] = The leveling operation has completed.
-  Bit [17] = A leveling operation has been requested.
-  Bit [16] = A DFI update error has occurred. Error information can be found in
-	     the UPDATE_ERROR_STATUS parameter.
-  Bit [15] = A write leveling error has occurred. Error information can be found
-	     in the WRLVL_ERROR_STATUS parameter.
-  Bit [14] = A read leveling gate training error has occurred. Error information
-	     can be found in the RDLVL_ERROR_STATUS parameter.
-  Bit [13] = A read leveling error has occurred. Error information can be found
-	     in the RDLVL_ERROR_STATUS parameter.
-  Bit [12] = The user has programmed an invalid setting associated with user
-	     words per burst. Examples: Setting param_reduc when burst
-	     length = 2. A 1:2 MC:PHY clock ratio with burst length = 2.
-  Bit [11] = A wrap cycle crossing a DRAM page has been detected. This is
-	     unsupported & may result in memory data corruption.
-  Bit [10] = The BIST operation has been completed.
-  Bit [09] = The low power operation has been completed.
-  Bit [08] = The MC initialization has been completed.
-  Bit [07] = An error occurred on the port command channel.
-  Bit [06] = Multiple uncorrectable ECC events have been detected.
-  Bit [05] = An uncorrectable ECC event has been detected.
-  Bit [04] = Multiple correctable ECC events have been detected.
-  Bit [03] = A correctable ECC event has been detected.
-  Bit [02] = Multiple accesses outside the defined PHYSICAL memory space have
-	     occurred.
-  Bit [01] = A memory access outside the defined PHYSICAL memory space has
-	     occurred.
-  Bit [00] = The memory reset is valid on the DFI bus.
-
-  Of these, 1, 2, 3, 4, 5, 6, 7, 11, and 19 are of interest.
-*/
-#define SM_INT_MASK (0x1f7f701)
-
-enum events {
-	EV_ILLEGAL = 0,
-	EV_MULT_ILLEGAL,
-	EV_CORR_ECC,
-	EV_MULT_CORR_ECC,
-	EV_UNCORR_ECC,
-	EV_MULT_UNCORR_ECC,
-	EV_PORT_ERROR,
-	EV_WRAP_ERROR,
-	EV_PARITY_ERROR,
-	NR_EVENTS
-};
-
-static const u32 event_mask[NR_EVENTS] = {
-	[EV_ILLEGAL]          = 0x00000002,
-	[EV_MULT_ILLEGAL]     = 0x00000004,
-	[EV_CORR_ECC]         = 0x00000008,
-	[EV_MULT_CORR_ECC]    = 0x00000010,
-	[EV_UNCORR_ECC]       = 0x00000020,
-	[EV_MULT_UNCORR_ECC]  = 0x00000040,
-	[EV_PORT_ERROR]       = 0x00000080,
-	[EV_WRAP_ERROR]       = 0x00000800,
-	[EV_PARITY_ERROR]     = 0x00080000,
-};
-
-static const struct event_logging {
-	int         fatal;
-	const char *level;
-	const char *name;
-} event_logging[NR_EVENTS] = {
-	[EV_ILLEGAL]         = {0, KERN_ERR, "Illegal access"},
-	[EV_MULT_ILLEGAL]    = {0, KERN_ERR, "Illegal access"},
-	[EV_CORR_ECC]        = {0, KERN_NOTICE, "Correctable ECC error"},
-	[EV_MULT_CORR_ECC]   = {0, KERN_NOTICE, "Correctable ECC error"},
-	[EV_UNCORR_ECC]      = {1, KERN_CRIT, "Uncorrectable ECC error"},
-	[EV_MULT_UNCORR_ECC] = {1, KERN_CRIT, "Uncorrectable ECC error"},
-	[EV_PORT_ERROR]      = {0, KERN_CRIT, "Port error"},
-	[EV_WRAP_ERROR]      = {0, KERN_CRIT, "Wrap error"},
-	[EV_PARITY_ERROR]    = {0, KERN_CRIT, "Parity error"},
-};
-
-struct smmon_attr {
-	struct device_attribute attr;
-	int                     event;
-};
-
-#define SMMON_ATTR(_name, _event) \
-	{ \
-		.attr = __ATTR(_name, S_IRUGO, smmon_show, NULL), \
-		.event = _event \
-	}
-
-struct sm_dev {
-	struct platform_device *pdev;
-	u32 region; /* NCR region address */
-	void __iomem *apb2ser3_region;
-	u32 counter[NR_EVENTS];
-};
-
-
-static ssize_t
-smmon_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct sm_dev *sm = dev_get_drvdata(dev);
-	struct smmon_attr *sma = container_of(attr, struct smmon_attr, attr);
-	return sprintf(buf, "%u", sm->counter[sma->event]);
-}
-
-static struct smmon_attr smmon_attr_counter[] = {
-	SMMON_ATTR(illegal_access, EV_ILLEGAL),
-	SMMON_ATTR(illegal_access_mult, EV_MULT_ILLEGAL),
-	SMMON_ATTR(correctable_ecc_error, EV_CORR_ECC),
-	SMMON_ATTR(correctable_ecc_error_mult, EV_MULT_CORR_ECC),
-	SMMON_ATTR(uncorrectable_ecc_error, EV_UNCORR_ECC),
-	SMMON_ATTR(uncorrectable_ecc_error_mult, EV_MULT_UNCORR_ECC),
-	SMMON_ATTR(port_error, EV_PORT_ERROR),
-	SMMON_ATTR(wrap_error, EV_WRAP_ERROR),
-	SMMON_ATTR(parity_error, EV_PARITY_ERROR),
-};
-
-static struct attribute *smmon_attr[] = {
-	&smmon_attr_counter[EV_ILLEGAL].attr.attr,
-	&smmon_attr_counter[EV_MULT_ILLEGAL].attr.attr,
-	&smmon_attr_counter[EV_CORR_ECC].attr.attr,
-	&smmon_attr_counter[EV_MULT_CORR_ECC].attr.attr,
-	&smmon_attr_counter[EV_UNCORR_ECC].attr.attr,
-	&smmon_attr_counter[EV_MULT_UNCORR_ECC].attr.attr,
-	&smmon_attr_counter[EV_PORT_ERROR].attr.attr,
-	&smmon_attr_counter[EV_WRAP_ERROR].attr.attr,
-	&smmon_attr_counter[EV_PARITY_ERROR].attr.attr,
-	NULL
-};
-
-static struct attribute_group smmon_attr_group = {
-	.name  = "counters",
-	.attrs = smmon_attr
-};
-
-static irqreturn_t
-smmon_isr(int interrupt, void *device)
-{
-	struct sm_dev *sm = device;
-	u32 status;
-	unsigned long setVal;
-	int i;
-
-	if (ncr_read(sm->region, 0x410, 4, &status)) {
-		pr_err("%s: Error reading interrupt status\n",
-		       dev_name(&sm->pdev->dev));
-		return IRQ_NONE;
-	}
-
-	for (i = 0; i < NR_EVENTS; ++i) {
-		if ((status & event_mask[i]) != 0) {
-			++sm->counter[i];
-			if (machineRestart && event_logging[i].fatal) {
-				setVal = readl(sm->apb2ser3_region + 0xdc);
-				/* set bit 3 in pscratch reg */
-				setVal = (setVal) | (0x1 << 3);
-				writel(setVal, sm->apb2ser3_region + 0xdc);
-				pr_info("CPU uncorrectable error\n");
-				machine_restart(NULL);
-			}
-			if (log)
-				printk_ratelimited("%s%s: %s\n",
-						   event_logging[i].level,
-						   dev_name(&sm->pdev->dev),
-						   event_logging[i].name);
-		}
-	}
-
-	/* Clear interrupt */
-	ncr_write(sm->region, 0x548, 4, &status);
-
-	return IRQ_HANDLED;
-}
-
-static int
-smmon_probe(struct platform_device *pdev)
-{
-	struct sm_dev *sm;
-	struct resource *io;
-	int irq;
-	u32 mask;
-	int rc = 0;
-	struct device_node *np = pdev->dev.of_node;
-
-
-	sm = devm_kzalloc(&pdev->dev, sizeof(*sm), GFP_KERNEL);
-	if (!sm) {
-		rc = -ENOMEM;
-		goto out;
-	}
-	sm->pdev = pdev;
-
-	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!io) {
-		rc = -EINVAL;
-		goto out;
-	}
-	sm->region = io->start;
-
-	sm->apb2ser3_region = of_iomap(np, 1);
-	if (!sm->apb2ser3_region)
-		sm->apb2ser3_region = ioremap(APB2_SER3_PHY_ADDR,
-				APB2_SER3_PHY_SIZE);
-
-	/* Disable all memory controller interrupts */
-	mask = 0xffffffff;
-	ncr_write(sm->region, 0x414, 4, &mask);
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		rc = irq;
-		goto out;
-	}
-
-	rc = devm_request_irq(&pdev->dev, irq, smmon_isr,
-			      IRQF_ONESHOT, dev_name(&pdev->dev), sm);
-	if (rc)
-		goto out;
-
-	rc = sysfs_create_group(&pdev->dev.kobj, &smmon_attr_group);
-	if (rc)
-		goto out;
-
-	dev_set_drvdata(&pdev->dev, sm);
-	pr_info("%s: Memory controller monitor\n", dev_name(&pdev->dev));
-
-	/* Enable memory controller interrupts. We need to disable the
-	 * interrupt while unmasking it, since otherwise there will be a
-	 * locking conflict in ncr_write/ncr_read when the ISR tries to read
-	 * interrupt status.
-	 */
-	disable_irq(irq);
-	mask = SM_INT_MASK;
-	ncr_write(sm->region, 0x414, 4, &mask);
-	enable_irq(irq);
-out:
-	return rc;
-}
-
-static int
-smmon_remove(struct platform_device *pdev)
-{
-	sysfs_remove_group(&pdev->dev.kobj, &smmon_attr_group);
-	return 0;
-}
-
-static const struct of_device_id smmon_id_table[] = {
-	{ .compatible = "lsi,smmon" },
-	{ }
-};
-MODULE_DEVICE_TABLE(platform, smmon_id_table);
-
-static struct platform_driver smmon_driver = {
-	.driver = {
-		.name = "lsi-smmon",
-		.of_match_table = smmon_id_table
-	},
-	.probe = smmon_probe,
-	.remove = smmon_remove,
-};
-
-module_platform_driver(smmon_driver);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index fe1794a..c7a65d3 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -542,10 +542,10 @@ config MTD_NAND_EP501X
 	  and EP501G3 controllers.
 
 config MTD_NAND_EP501X_UBOOTENV
-	tristate "U-Boot Environment Access for LSI's APP and ACP"
+	tristate "U-Boot Environment Access for INTEL Axxia's APP and ACP"
 	depends on ( MTD_NAND_EP501X && CRC32 )
 	help
-	  Add U-Boot environment access on LSI's APP/ACP boards.
+	  Add U-Boot environment access on INTEL Axxia's APP/ACP boards.
 
 config MTD_NAND_SUNXI
 	tristate "Support for NAND on Allwinner SoCs"
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index b999272..6a0b508 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -54,8 +54,8 @@ obj-$(CONFIG_MTD_NAND_JZ4780)		+= jz4780_nand.o jz4780_bch.o
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
 obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
 obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
-obj-$(CONFIG_MTD_NAND_EP501X)		+= lsi_acp_nand.o
-obj-$(CONFIG_MTD_NAND_EP501X_UBOOTENV)	+= lsi_ubootenv.o
+obj-$(CONFIG_MTD_NAND_EP501X)		+= axxia_acp_nand.o
+obj-$(CONFIG_MTD_NAND_EP501X_UBOOTENV)	+= axxia_ubootenv.o
 obj-$(CONFIG_MTD_NAND_SUNXI)		+= sunxi_nand.o
 obj-$(CONFIG_MTD_NAND_HISI504)	        += hisi504_nand.o
 obj-$(CONFIG_MTD_NAND_BRCMNAND)		+= brcmnand/
diff --git a/drivers/mtd/nand/axxia_acp_nand.c b/drivers/mtd/nand/axxia_acp_nand.c
new file mode 100644
index 0000000..ede266e
--- /dev/null
+++ b/drivers/mtd/nand/axxia_acp_nand.c
@@ -0,0 +1,3676 @@
+/*
+ * drivers/axxia/acp/nand.c
+ *
+ * NAND Controller Driver for INTEL Axxia's ACP
+ *
+ * Copyright (C) 2018 INTEL Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+
+/* -- DEBUG --------------------------------------------------------- */
+
+#include <asm/axxia/debug.h>
+
+/* -- LOGIO --------------------------------------------------------- */
+
+#undef LOGIO
+/*#define LOGIO*/
+#ifdef LOGIO
+int enable_logio;
+static inline unsigned long _READL(const char *, int, unsigned long);
+static inline unsigned long
+_READL(const char *file, int line, unsigned long address)
+{
+	unsigned long value;
+
+	value = readl(address);
+
+	if (0 != enable_logio)
+		pr_info("%s:%d - Read 0x%08lx from 0x%08lx\n",
+		       file, line, value, address);
+
+	return value;
+}
+#define READL(address) _READL(__FILE__, __LINE__, (address))
+static inline void _WRITEL(const char *, int, unsigned long, unsigned long);
+static inline void
+_WRITEL(const char *file, int line, unsigned long value, unsigned long address)
+{
+	writel(value, address);
+
+	if (0 != enable_logio)
+		pr_err("%s:%d - Wrote 0x%08lx to 0x%08lx\n",
+		       file, line, value, address);
+}
+#define WRITEL(value, address) _WRITEL(__FILE__, __LINE__, (value), (address))
+#else  /* LOGIO */
+#define READL(address) readl((address))
+#define WRITEL(value, address) writel((value), (address))
+#endif /* LOGIO */
+
+/*
+  ----------------------------------------------------------------------
+*/
+
+#define NAND_DATA_REG	      0x00000000
+#define NAND_CMD_REG	      0x00008000
+#define NAND_INDEX_REG	      0x00008004
+#define NAND_STATUS1_REG      0x00008008
+#define NAND_STATUS2_REG      0x0000800C
+#define NAND_ID0_REG	      0x00008010
+#define NAND_ID1_REG	      0x00008014
+#define NAND_ID2_REG	      0x00008018
+#define NAND_ID3_REG	      0x0000801C
+#define NAND_ID4_REG	      0x00008020
+#define NAND_ID5_REG	      0x00008024
+#define NAND_ID6_REG	      0x00008028
+#define NAND_ID7_REG	      0x0000802C
+#define NAND_INTR_EN_REG      0x00008030
+#define NAND_INTR_STATUS_REG  0x00008034
+#define NAND_INTR_REG	      0x00008038
+#define NAND_ECC_ADDR_LOG_REG 0x0000803C
+#define NAND_ECC_VAL_REG      0x00008040
+#define NAND_ECC_INJECT_REG   0x00008044
+#define NAND_EXT_INDEX_REG    0x00008048
+#define NAND_TIMING1_REG      0x0000804C
+#define NAND_TIMING2_REG      0x00008050
+#define NAND_CONFIG_REG	      0x00008054
+#define NAND_PECC_REG	      0x00008058
+
+#define EP501_NAND_DATA_REG         0x0000
+#define EP501_NAND_CMD_REG          0x8000
+#define EP501_NAND_INDEX_REG        0x8004
+#define EP501_NAND_STATUS0_REG      0x8008
+#define EP501_NAND_STATUS1_REG      0x800C
+#define EP501_NAND_ID0_REG          0x8010
+#define EP501_NAND_ID1_REG          0x8014
+#define EP501_NAND_ID2_REG          0x8018
+#define EP501_NAND_ID3_REG          0x801C
+#define EP501_NAND_ID4_REG          0x8020
+#define EP501_NAND_ID5_REG          0x8024
+#define EP501_NAND_ID6_REG          0x8028
+#define EP501_NAND_ID7_REG          0x802C
+#define EP501_NAND_INTR_EN_REG      0x8030
+#define EP501_NAND_INTR_STATUS_REG  0x8034
+#define EP501_NAND_INTR_REG         0x8038
+#define EP501_NAND_ECC_ADDR_LOG_REG 0x803C
+#define EP501_NAND_ECC_VAL_REG      0x8040
+#define EP501_NAND_ECC_INJECT_REG   0x8044
+#define EP501_NAND_EXT_INDEX_REG    0x8048
+#define EP501_NAND_TIMING0_REG      0x804C
+#define EP501_NAND_TIMING1_REG      0x8050
+#define EP501_NAND_CONFIG_REG       0x8054
+#define EP501_NAND_PECC_REG         0x8058
+
+#define EP501G1_NAND_DATA_REG         0x0000
+#define EP501G1_NAND_CMD_REG          0x8000
+#define EP501G1_NAND_INDEX_REG        0x8004
+#define EP501G1_NAND_STATUS0_REG      0x8008
+#define EP501G1_NAND_ID0_REG          0x8010
+#define EP501G1_NAND_ID2_REG          0x8018
+#define EP501G1_NAND_ID4_REG          0x8020
+#define EP501G1_NAND_ID6_REG          0x8028
+#define EP501G1_NAND_INTR_EN_REG      0x8030
+#define EP501G1_NAND_INTR_STATUS_REG  0x8034
+#define EP501G1_NAND_INTR_REG         0x8038
+#define EP501G1_NAND_EXT_INDEX_REG    0x8048
+#define EP501G1_NAND_TIMING0_REG      0x804C
+#define EP501G1_NAND_TIMING1_REG      0x8050
+#define EP501G1_NAND_CONFIG_REG       0x8054
+#define EP501G1_NAND_1BIT_ECC0_STATUS 0x8058
+#define EP501G1_NAND_1BIT_ECC1_STATUS 0x805c
+#define EP501G1_NAND_1BIT_ECC2_STATUS 0x8060
+#define EP501G1_NAND_1BIT_ECC3_STATUS 0x8064
+#define EP501G1_NAND_1BIT_ECC4_STATUS 0x8068
+#define EP501G1_NAND_1BIT_ECC5_STATUS 0x806c
+#define EP501G1_NAND_1BIT_ECC6_STATUS 0x8070
+#define EP501G1_NAND_1BIT_ECC7_STATUS 0x8074
+#define EP501G1_NAND_BCH_STATUS       0x807c
+#define EP501G1_NAND_SYN_R12_S0       0x8080
+#define EP501G1_NAND_SYN_R34_S0       0x8084
+#define EP501G1_NAND_SYN_R56_S0       0x8088
+#define EP501G1_NAND_SYN_R78_S0       0x808c
+#define EP501G1_NAND_SYN_R12_S1       0x8090
+#define EP501G1_NAND_SYN_R34_S1       0x8094
+#define EP501G1_NAND_SYN_R56_S1       0x8098
+#define EP501G1_NAND_SYN_R78_S1       0x809c
+#define EP501G1_NAND_SYN_R12_S2       0x80a0
+#define EP501G1_NAND_SYN_R34_S2       0x80a4
+#define EP501G1_NAND_SYN_R56_S2       0x80a8
+#define EP501G1_NAND_SYN_R78_S2       0x80ac
+#define EP501G1_NAND_SYN_R12_S3       0x80b0
+#define EP501G1_NAND_SYN_R34_S3       0x80b4
+#define EP501G1_NAND_SYN_R56_S3       0x80b8
+#define EP501G1_NAND_SYN_R78_S3       0x80bc
+#define EP501G1_NAND_SYN_R12_S4       0x80c0
+#define EP501G1_NAND_SYN_R34_S4       0x80c4
+#define EP501G1_NAND_SYN_R56_S4       0x80c8
+#define EP501G1_NAND_SYN_R78_S4       0x80cc
+#define EP501G1_NAND_SYN_R12_S5       0x80d0
+#define EP501G1_NAND_SYN_R34_S5       0x80d4
+#define EP501G1_NAND_SYN_R56_S5       0x80d8
+#define EP501G1_NAND_SYN_R78_S5       0x80dc
+#define EP501G1_NAND_SYN_R12_S6       0x80e0
+#define EP501G1_NAND_SYN_R34_S6       0x80e4
+#define EP501G1_NAND_SYN_R56_S6       0x80e8
+#define EP501G1_NAND_SYN_R78_S6       0x80ec
+#define EP501G1_NAND_SYN_R12_S7       0x80f0
+#define EP501G1_NAND_SYN_R34_S7       0x80f4
+#define EP501G1_NAND_SYN_R56_S7       0x80f8
+#define EP501G1_NAND_SYN_R78_S7       0x80fc
+
+#define EP501G3_NAND_DATA_REG         0x0000
+#define EP501G3_NAND_CMD_REG          0x8000
+#define EP501G3_NAND_INDEX_REG        0x8004
+#define EP501G3_NAND_STATUS0_REG      0x8008
+#define EP501G3_NAND_ID0_REG          0x8010
+#define EP501G3_NAND_ID2_REG          0x8018
+#define EP501G3_NAND_ID4_REG          0x8020
+#define EP501G3_NAND_ID6_REG          0x8028
+#define EP501G3_NAND_INTR_EN_REG      0x8030
+#define EP501G3_NAND_INTR_STATUS_REG  0x8034
+#define EP501G3_NAND_INTR_REG         0x8038
+#define EP501G3_NAND_EXT_INDEX_REG    0x8048
+#define EP501G3_NAND_TIMING0_REG      0x804C
+#define EP501G3_NAND_TIMING1_REG      0x8050
+#define EP501G3_NAND_CONFIG_REG       0x8054
+#define EP501G3_NAND_TIMING2_REG      0x805c
+#define EP501G3_NAND_BCH_STATUS       0x807c
+#define EP501G3_NAND_SYN_R12_S0       0x8080
+#define EP501G3_NAND_SYN_R34_S0       0x8084
+#define EP501G3_NAND_SYN_R56_S0       0x8088
+#define EP501G3_NAND_SYN_R78_S0       0x808c
+#define EP501G3_NAND_SYN_R12_S1       0x8090
+#define EP501G3_NAND_SYN_R34_S1       0x8094
+#define EP501G3_NAND_SYN_R56_S1       0x8098
+#define EP501G3_NAND_SYN_R78_S1       0x809c
+#define EP501G3_NAND_SYN_R12_S2       0x80a0
+#define EP501G3_NAND_SYN_R34_S2       0x80a4
+#define EP501G3_NAND_SYN_R56_S2       0x80a8
+#define EP501G3_NAND_SYN_R78_S2       0x80ac
+#define EP501G3_NAND_SYN_R12_S3       0x80b0
+#define EP501G3_NAND_SYN_R34_S3       0x80b4
+#define EP501G3_NAND_SYN_R56_S3       0x80b8
+#define EP501G3_NAND_SYN_R78_S3       0x80bc
+#define EP501G3_NAND_SYN_R12_S4       0x80c0
+#define EP501G3_NAND_SYN_R34_S4       0x80c4
+#define EP501G3_NAND_SYN_R56_S4       0x80c8
+#define EP501G3_NAND_SYN_R78_S4       0x80cc
+#define EP501G3_NAND_SYN_R12_S5       0x80d0
+#define EP501G3_NAND_SYN_R34_S5       0x80d4
+#define EP501G3_NAND_SYN_R56_S5       0x80d8
+#define EP501G3_NAND_SYN_R78_S5       0x80dc
+#define EP501G3_NAND_SYN_R12_S6       0x80e0
+#define EP501G3_NAND_SYN_R34_S6       0x80e4
+#define EP501G3_NAND_SYN_R56_S6       0x80e8
+#define EP501G3_NAND_SYN_R78_S6       0x80ec
+#define EP501G3_NAND_SYN_R12_S7       0x80f0
+#define EP501G3_NAND_SYN_R34_S7       0x80f4
+#define EP501G3_NAND_SYN_R56_S7       0x80f8
+#define EP501G3_NAND_SYN_R78_S7       0x80fc
+#define EP501G3_NAND_SYN_R12_S8       0x8100
+#define EP501G3_NAND_SYN_R34_S8       0x8104
+#define EP501G3_NAND_SYN_R56_S8       0x8108
+#define EP501G3_NAND_SYN_R78_S8       0x810c
+#define EP501G3_NAND_SYN_R12_S9       0x8110
+#define EP501G3_NAND_SYN_R34_S9       0x8114
+#define EP501G3_NAND_SYN_R56_S9       0x8118
+#define EP501G3_NAND_SYN_R78_S9       0x811c
+#define EP501G3_NAND_SYN_R12_S10      0x8120
+#define EP501G3_NAND_SYN_R34_S10      0x8124
+#define EP501G3_NAND_SYN_R56_S10      0x8128
+#define EP501G3_NAND_SYN_R78_S10      0x812c
+#define EP501G3_NAND_SYN_R12_S11      0x8130
+#define EP501G3_NAND_SYN_R34_S11      0x8134
+#define EP501G3_NAND_SYN_R56_S11      0x8138
+#define EP501G3_NAND_SYN_R78_S11      0x813c
+#define EP501G3_NAND_SYN_R12_S12      0x8140
+#define EP501G3_NAND_SYN_R34_S12      0x8144
+#define EP501G3_NAND_SYN_R56_S12      0x8148
+#define EP501G3_NAND_SYN_R78_S12      0x814c
+#define EP501G3_NAND_SYN_R12_S13      0x8150
+#define EP501G3_NAND_SYN_R34_S13      0x8154
+#define EP501G3_NAND_SYN_R56_S13      0x8158
+#define EP501G3_NAND_SYN_R78_S13      0x815c
+#define EP501G3_NAND_SYN_R12_S14      0x8160
+#define EP501G3_NAND_SYN_R34_S14      0x8164
+#define EP501G3_NAND_SYN_R56_S14      0x8168
+#define EP501G3_NAND_SYN_R78_S14      0x816c
+#define EP501G3_NAND_SYN_R12_S15      0x8170
+#define EP501G3_NAND_SYN_R34_S15      0x8174
+#define EP501G3_NAND_SYN_R56_S15      0x8178
+#define EP501G3_NAND_SYN_R78_S15      0x817c
+
+/*
+  ==============================================================================
+  ==============================================================================
+  Some Oddities...
+
+  -1-
+  Reading EP501 registers while the device is calculating ECC will
+  hang the AHB.	 As the only way to know that an ECC calculation is in
+  progress is to read the "extra bits" added to the interrupt status
+  register, this can cause problems.  To get around this, the
+  PECC_BUSY signal from the controller is also available in a general
+  purpose system register.  0x149.0.0xc/0x0020_0040_0000_c00c, bit 24.
+  So, before reading the interrupt status register (or any other
+  register for that matter) make sure the bit mentioned above is
+  clear.  See BZ21212.
+
+  -2-
+  Extra bits have been added to the interrupt status register.	See
+  BZ21196.  From that defect...
+
+  == Bit 0
+  This bit is set when un-correctable ECC is detected. This bit can be
+  cleared by writing "0" to this register. Writing "1" has no
+  effect. An interrupt is generated if this bit and the enable bit
+  (bit 0) in the Interrupt Enable Register are "1". This bit is not
+  set if ECC is disabled.
+
+  == Bit 1
+  This bit is set when correctable ECC is detected. This bit can be
+  cleared by writing "0" to this register. Writing "1" has no
+  effect. An interrupt is generated if this bit and the enable bit
+  (bit 1) in the Interrupt Enable Register are "1". This bit is not
+  set if ECC is disabled.
+
+  == Bit 2
+  This bit is set when a rising edge is detected on the non gated
+  READY/BUSY# input from the NAND Flash. This bit can be cleared by
+  writing a "0" to this register. Writing a "1" has no effect. An
+  interrupt is generated if this bit and the enable bit (bit 2) in the
+  Interrupt Enable Register are "1".
+
+  == Bit 3
+  This bit is set when a falling edge is detected on the non gated
+  READY/BUSY# input from the NAND Flash. This bit can be cleared by
+  writing a "0" to this register. Writing a "1" has no effect. An
+  interrupt is generated if this bit and the enable bit (bit 3) in the
+  Interrupt Enable Register are "1".
+
+  == Bit 4
+  This bit is set when a falling edge is detected on the PECC_BUSY
+  signal which indicates when the NAND controller has taken control of
+  the NAND Flash for ECC byte access. This bit can be cleared by
+  writing a "0" to this register. Writing a "1" has no effect. An
+  interrupt is generated if this bit and the enable bit (bit 4) in the
+  Interrupt Enable Register are "1".
+
+  == Bit 5
+  This bit is read only and is the synchronized level on the non gated
+  READY/BUSY# input from the NAND Flash. This bit can be used to poll
+  the status of this signal and is not used to generate an interrupt.
+
+  == Bit 6
+  This bit is read only and indicates the level on the PECC_BUSY
+  signal which indicates when the NAND controller has taken control of
+  the NAND Flash for ECC byte access. This bit can be used to poll the
+  level of this signal and is not used to generate an interrupt.
+
+  ==============================================================================
+  ==============================================================================
+*/
+
+static void *gpreg_base;
+static void *pecc_busy_register;
+static unsigned long pecc_busy_mask;
+
+#define MAX_READ_BUF	16
+
+/*
+  ----------------------------------------------------------------------
+  MTD structures
+*/
+
+static struct mtd_info axxia_nand_mtd = { 0 };
+static struct nand_chip axxia_nand_chip = { 0 };
+
+static struct axxia_nand_private {
+	int cur;	/* -1 means there is no meaningful data in buffer */
+	uint8_t buf[MAX_READ_BUF];
+} axxia_nand_private;
+
+#define NAND_CMD_START_ECC_READ	  0x23
+
+#define NAND_CMD_CE_OFF_501	  0xEE
+#define NAND_CMD_CE_OFF_501G1	  0xEE
+#define NAND_CMD_CE_OFF_501G3	  0xFE
+static int nand_cmd_ce_off;
+
+typedef union {
+	unsigned long raw;
+
+	struct {
+#ifdef CONFIG_ACP
+		unsigned long th:8;
+		unsigned long trp:8;
+		unsigned long twp:8;
+		unsigned long ts:8;
+#else
+		unsigned long ts:8;
+		unsigned long twp:8;
+		unsigned long trp:8;
+		unsigned long th:8;
+#endif
+	} __packed bits;
+} nand_timing_control_register_0_t;
+
+typedef union {
+	unsigned long raw;
+
+	struct {
+#ifdef CONFIG_ACP
+		unsigned long twb:8;
+		unsigned long trr:8;
+		unsigned long trh:8;
+		unsigned long twh:8;
+#else
+		unsigned long twh:8;
+		unsigned long trh:8;
+		unsigned long trr:8;
+		unsigned long twb:8;
+#endif
+	} __packed bits;
+} __packed nand_timing_control_register_1_t;
+
+typedef union {
+	unsigned long raw;
+
+	struct {
+#ifdef CONFIG_ACP
+		unsigned long:8;
+		unsigned long trhw:8;
+		unsigned long twhr:8;
+		unsigned long tccs:8;
+#else
+		unsigned long tccs:8;
+		unsigned long twhr:8;
+		unsigned long trhw:8;
+		unsigned long:8;
+#endif
+	} __packed bits;
+} __packed nand_timing_control_register_2_t;
+
+typedef enum {
+	AXXIA_NAND_NONE, AXXIA_NAND_EP501, AXXIA_NAND_EP501G1, AXXIA_NAND_EP501G3
+} axxia_nand_type_t;
+
+static axxia_nand_type_t axxia_nand_type;
+
+typedef struct page_wise_ecc_status_st {
+	unsigned err_bit:3;
+	unsigned column:9;
+	unsigned status:2;
+	unsigned rsvd:18;
+} page_wise_ecc_status_t;
+
+/*
+  =============================================================================
+  =============================================================================
+  Concerning ECC
+
+  The EP501 only supports 1 bit ECC mode.  The EP501G1 supports both 1
+  bit and 4 bit modes.  The EP501G3 supports 4 bit, 8 bit, and 12 bit.
+  The NAND part normally used on ACP boards has 2K pages (supported by
+  all three controllers) with 64 bytes of OOB.  For a 2K page, 1 bit
+  ECC uses 12 bytes, 4 bit ECC uses 32 bytes, 8 bit ECC uses 64 bytes
+  and 12 bit ECC uses 80 bytes.  In order to to keep the bad block
+  markers (first two bytes) and leave some OOB available for file
+  systems etc., this driver only supports 1 bit ECC or 4 bit ECC.
+
+  For now, the EP501 version will use 1 bit ECC (only option), the
+  EP501G1 version will use 4 bit (for compabitility with the EP501G3)
+  and teh EP501G3 versions will use 4 bit (due to the amount of OOB
+  required and for compatibility with the EP501G1).
+
+  EP501
+
+  The driver has not been tested with small page (512 byte) devices.
+  The only usable option is 2K.  So, the OOB should be 64 bytes.  The
+  first 2 bytes are reserved for marking bad blocks.  The last 12
+  bytes are reserved for ECC.  All other bytes are free.  See
+  axxia_ep501_2k_ecclayout below.
+
+  EP501G1
+
+  This driver has been tested with 2K and 4K page sizes using 1 bit
+  and 4 bit ECC.
+  =============================================================================
+  =============================================================================
+*/
+
+static struct nand_ecclayout axxia_2k_1bit_ecclayout = {
+	.eccbytes = 12,
+	.eccpos = {
+		52, 53, 54, 55, 56, 57,
+		58, 59, 60, 61, 62, 63},
+	.oobfree = {{2, 50} }
+};
+
+/*
+static struct nand_ecclayout axxia_4k_1bit_ecclayout = {
+	.eccbytes = 24,
+	.eccpos = {
+		52, 53, 54, 55, 56, 57,
+		58, 59, 60, 61, 62, 63},
+	.oobfree = {{2, 50}}
+};
+*/
+
+static struct nand_ecclayout axxia_2k_4bit_ecclayout = {
+	.eccbytes = 32,
+	.eccpos = {
+		32, 33, 34, 35, 36, 37, 38, 39,
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53, 54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63 },
+	.oobfree = {{2, 30} }
+};
+
+static struct nand_ecclayout axxia_4k_4bit_ecclayout = {
+	.eccbytes = 64,
+	.eccpos = {
+		64,  65,  66,  67,  68,  69,  70,  71,
+		72,  73,  74,  75,  76,  77,  78,  79,
+		80,  81,  82,  83,  84,  85,  86,  87,
+		88,  89,  90,  91,  92,  93,  94,  95,
+		96,  97,  98,  99, 100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127
+	},
+	.oobfree = {{2, 63} }
+};
+
+#ifdef NOT_USED
+
+static struct nand_ecclayout axxia_8k_4bit_ecclayout = {
+	.eccbytes = 128,
+	.eccpos = {
+		128, 129, 130, 131, 132, 133, 134, 135,
+		136, 137, 138, 139, 140, 141, 142, 143,
+		144, 145, 146, 147, 148, 149, 150, 151,
+		152, 153, 154, 155, 156, 157, 158, 159,
+		160, 161, 162, 163, 164, 165, 166, 167,
+		168, 169, 170, 171, 172, 173, 174, 175,
+		176, 177, 178, 179, 180, 181, 182, 183,
+		184, 185, 186, 187, 188, 189, 190, 191,
+		192, 193, 194, 195, 196, 197, 198, 199,
+		200, 201, 202, 203, 204, 205, 206, 207,
+		208, 209, 210, 211, 212, 213, 214, 215,
+		216, 217, 218, 219, 220, 221, 222, 223,
+		224, 225, 226, 227, 228, 229, 230, 231,
+		232, 233, 234, 235, 236, 237, 238, 239,
+		240, 241, 242, 243, 244, 245, 246, 247,
+		248, 249, 250, 251, 252, 253, 254, 255
+	},
+	.oobfree = {{2, 126} }
+};
+
+#endif
+
+/*
+  -----------------------------------------------------------------------------
+  axxia_nand_hwcontrol
+*/
+
+static void
+axxia_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (cmd != NAND_CMD_NONE)
+		WRITEL(cmd, (chip->IO_ADDR_W + NAND_CMD_REG));
+}
+
+/*
+  ------------------------------------------------------------------------------
+  axxia_nand_device_ready
+
+  The READ/BUSY# input from the NAND device(s) (ORed if there are more
+  than one) is availble as an extra bit in the interrupt status
+  register.  Note that this register shouldn't be read unless the
+  controller is not in the middle of calculating ECC (see "Some
+  Oddities..." above).
+*/
+
+static int
+axxia_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	unsigned long interrupt_status;
+
+	/* Get the status. */
+	interrupt_status = READL(chip->IO_ADDR_R + NAND_INTR_STATUS_REG);
+
+	return interrupt_status & NAND_STATUS_TRUE_READY;
+}
+
+/**
+ * axxia_nand_command - [DEFAULT] Send command to NAND large page device
+ * @mtd:	MTD device structure
+ * @command:	the command to be sent
+ * @column:	the column address for this command, -1 if none
+ * @page_addr:	the page address for this command, -1 if none
+ *
+ * Send command to NAND device. This is the version for the new large page
+ * devices We dont have the separate regions as we have in the small page
+ * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
+ */
+static void
+axxia_nand_command(struct mtd_info *mtd, unsigned int command,
+		 int column, int page_addr)
+{
+	register struct nand_chip *chip = mtd->priv;
+	unsigned int status = 0;
+	struct axxia_nand_private *priv = &axxia_nand_private;
+	struct device_node *np = NULL;
+
+	DEBUG_PRINT("command=0x%x\n", command);
+	command &= 0xff;
+
+	/* Emulate NAND_CMD_READOOB */
+	if (command == NAND_CMD_READOOB) {
+		column += mtd->writesize;
+		command = NAND_CMD_READ0;
+	}
+
+	/* return if unhandled command is issued */
+	if (command != NAND_CMD_READ0 &&
+	    command != NAND_CMD_SEQIN &&
+	    command != NAND_CMD_ERASE1 &&
+	    command != NAND_CMD_STATUS &&
+	    command != NAND_CMD_READID &&
+	    command != NAND_CMD_RESET &&
+	    command != NAND_CMD_START_ECC_READ &&
+	    command != NAND_CMD_PAGEPROG &&
+	    command != NAND_CMD_ERASE2) {
+		pr_err("axxia_nand_command(): WARN: Unhandled command 0x%x "
+		       "issued for page=0x%x, column=0x%x.\n",
+		       command, page_addr, column);
+		return;
+	}
+
+	priv->cur = -1;
+	/* Command latch cycle */
+	chip->cmd_ctrl(mtd, command,
+		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+
+	if (column != -1 || page_addr != -1) {
+		unsigned long index = 0;
+		unsigned long extended_index = 0;
+
+		/* column number */
+		/*
+		  Since the ACP uses 8 bit device access, only that
+		  mode is supported.
+		*/
+
+		if (AXXIA_NAND_EP501 == axxia_nand_type) {
+			/* column number */
+			if (column != -1)
+				index = column & 0xfff;
+
+			/* page and block number */
+			if (page_addr != -1)
+				index += ((page_addr & 0x7ffff) << 12);
+		} else {
+			/* column number */
+			if (-1 != column) {
+				switch (mtd->writesize) {
+				case 512:
+					index |= (column & 0x1ff);
+					break;
+				case 2048:
+					index |= (column & 0xfff);
+					break;
+				case 4096:
+					index |= (column & 0x1fff);
+					break;
+				default:
+					break;
+				}
+			}
+
+			/* page_addr and block number */
+			if (-1 != page_addr) {
+				switch (mtd->writesize) {
+				case 512:
+					index |= (page_addr & 0x7fffff) << 9;
+					break;
+				case 2048:
+					index |= (page_addr & 0xfffff) << 12;
+					extended_index |=
+						(page_addr & 0xfff00000);
+					break;
+				case 4096:
+					index |= (page_addr & 0x7ffff) << 13;
+					extended_index |=
+						(page_addr & 0xfff80000);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+
+		/* write index reg */
+		WRITEL(index, chip->IO_ADDR_W + NAND_INDEX_REG);
+
+		/* write ext index reg */
+		WRITEL(extended_index, chip->IO_ADDR_W + NAND_EXT_INDEX_REG);
+
+		/* Memory Barrier */
+		mb();
+	}
+
+	/* for read command, send 0xe0 so data is populated */
+	if (command == NAND_CMD_READ0) {
+		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
+			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		do {
+			udelay(chip->chip_delay);
+			status = READL((void *)pecc_busy_register);
+		} while (0 != (status & pecc_busy_mask));
+
+		/* wait until CHIP_BUSY goes low */
+		do {
+			udelay(chip->chip_delay);
+			status = chip->dev_ready(mtd);
+		} while (!status);
+	} else if (command == NAND_CMD_STATUS) {
+		udelay(chip->chip_delay);
+		priv->cur = 0;
+		priv->buf[0] = readb(chip->IO_ADDR_R + NAND_STATUS1_REG);
+	} else if (command == NAND_CMD_READID) {
+		priv->cur = 0;
+		priv->buf[0] = readb(chip->IO_ADDR_R + NAND_ID0_REG);
+		priv->buf[1] = readb(chip->IO_ADDR_R + NAND_ID2_REG);
+		priv->buf[2] = readb(chip->IO_ADDR_R + NAND_ID4_REG);
+		priv->buf[3] = readb(chip->IO_ADDR_R + NAND_ID6_REG);
+	}
+}
+
+/**
+ * axxia_nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void axxia_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i = 0;
+	struct nand_chip *chip = (struct nand_chip *) mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+#if defined(LOGIO)
+	if (0 != enable_logio)
+		pr_notice("Reading NAND Buffer (len=%d)...\n", len);
+#endif
+
+	for (i = 0; i < (len >> 2); i++)
+		p[i] = readl(chip->IO_ADDR_R);
+}
+
+/**
+ * axxia_nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void
+axxia_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i = 0;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+#if defined(LOGIO)
+	if (0 != enable_logio)
+		pr_notice("Writing NAND Buffer (len=%d)...\n", len);
+#endif
+
+	for (i = 0; i < (len >> 2); i++)
+		writel(p[i], chip->IO_ADDR_W);
+}
+
+static int axxia_nand_read_status(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, NAND_CMD_STATUS, 0);
+
+	return READL(chip->IO_ADDR_R + NAND_STATUS1_REG) & 0xff;
+}
+
+
+/**
+ * axxia_nand_wait - [DEFAULT]  wait until the command is done
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip structure
+ *
+ * Wait for command done. This applies to erase and program only
+ * Erase can take up to 400ms and program up to 20ms according to
+ * general NAND and SmartMedia specs
+ */
+static int axxia_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	unsigned long status = 0;
+	loff_t offset = 0;
+	struct device_node *np = NULL;
+
+	/*
+	  When reading or writing, wait for the
+	  controller's PECC_BUSY signal to clear.
+	*/
+#ifdef NOT_USED
+	if (FL_READING == chip->state || FL_WRITING == chip->state) {
+		for (;;) {
+			status = READL((void *)pecc_busy_register);
+
+			if (0 == (status & pecc_busy_mask))
+				break;
+
+			udelay(chip->chip_delay);
+		}
+	}
+#else
+	for (;;) {
+		status = READL((void *)pecc_busy_register);
+
+		if (0 == (status & pecc_busy_mask))
+			break;
+
+		udelay(chip->chip_delay);
+	}
+#endif
+
+	/*
+	  In all cases, wait for the NAND device to be "ready".
+
+	  N.B. The FL_READING case is handled in axxia_nand_command().
+	*/
+
+	if (FL_WRITING == chip->state || FL_ERASING == chip->state) {
+		for (;;) {
+			if (chip->dev_ready(mtd))
+				break;
+
+			udelay(chip->chip_delay);
+		}
+	}
+
+	/*
+	  Then get the status.
+	*/
+
+	for (;;) {
+		status = axxia_nand_read_status(mtd);
+
+		if (0 != (status & NAND_STATUS_READY))
+			break;
+
+		udelay(chip->chip_delay);
+	}
+
+	if (status & NAND_STATUS_FAIL) {
+		offset = (READL(chip->IO_ADDR_R + NAND_INDEX_REG) /
+			  mtd->writesize) * mtd->writesize;
+		pr_err("axxia_nand_wait(): Action %d failed for "
+		       "Offset: 0x%llx, status 0x%lx\n",
+		       chip->state, offset, status);
+	}
+
+	return status;
+}
+
+/*
+  axxia_nand_ecc_hwctl
+*/
+
+void
+axxia_nand_ecc_hwctl(struct mtd_info *mtd, int mode)
+{
+	/* nothing to do to enable ECC */
+}
+
+/**
+ * axxia_nand_ecc_calculate
+ */
+
+int
+axxia_nand_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
+		       uint8_t *ecc_code)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	/* start ECC calculation */
+	if (chip->state == FL_READING)
+		chip->cmdfunc(mtd, NAND_CMD_START_ECC_READ, -1, -1);
+	else if (chip->state == FL_WRITING)
+		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/* wait for PECC_BUSY to go down */
+	return chip->waitfunc(mtd, chip);
+}
+
+/**
+ * axxia_nand_ecc_correct
+ */
+
+int
+axxia_nand_ecc_correct(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
+		     uint8_t *calc_ecc)
+{
+	/* nothing to do to correct ECC */
+	return 0;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  report_ecc_errors_ep501
+*/
+
+static int
+report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip,
+			uint8_t *buffer, int page)
+{
+	int rc = 0;
+	unsigned long ecc_status;
+	page_wise_ecc_status_t *ecc_status_reg =
+		(page_wise_ecc_status_t *)&ecc_status;
+	int column;
+	int i;
+
+	for (i = 0; i < (mtd->writesize >> 9); i++) {
+		ecc_status = READL(chip->IO_ADDR_R + EP501_NAND_PECC_REG);
+		column = (i << 9) + ecc_status_reg->column;
+
+		if (1 == ecc_status_reg->status) {
+			pr_notice("Single ECC Error: "
+				  "Page=0x%x Column=0x%x Bit=0x%x\n",
+				  page, column, ecc_status_reg->err_bit);
+
+			if (column < mtd->writesize) {
+				buffer[column] ^=
+					(1 << ecc_status_reg->err_bit);
+				++mtd->ecc_stats.corrected;
+			} else {
+				pr_err("Single ECC Error Not Corrected: "
+				       "Column 0x%x not in "
+				       "Page Size 0x%x\n",
+				       column, mtd->writesize);
+				rc = -1;
+			}
+		} else if ((ecc_status & 0x3000) == 2) {
+			pr_err("Uncorrectable ECC Error: "
+			       "Page=0x%x Column=0x%x\n",
+			       page, column);
+			rc = -1;
+		}
+	}
+
+	return rc;
+}
+
+int i_to_a[8192] = {
+	-1, 0, 1, 7953, 2, 7715, 7954, 3551, 3, 3313, 7716, 5441,
+	7955, 1529, 3552, 7477, 4, 7239, 3314, 1441, 7717, 7102, 5442,
+	1291, 7956, 7545, 1530, 3075, 3553, 5203, 7478, 2784, 5, 2546,
+	7240, 5080, 3315, 4596, 1442, 4965, 7718, 466, 7103, 7307,
+	5443, 2837, 1292, 822, 7957, 801, 7546, 7001, 1531, 1203,
+	3076, 4294, 3554, 1053, 5204, 3033, 7479, 6073, 2785, 6864, 6,
+	6626, 2547, 7658, 7241, 2691, 5081, 5835, 3316, 2893, 4597,
+	815, 1443, 2795, 4966, 2905, 7719, 3058, 467, 563, 7104, 6763,
+	7308, 1956, 5444, 4056, 2838, 838, 1293, 6335, 823, 965, 7958,
+	3626, 802, 2308, 7547, 4842, 7002, 7279, 1532, 4727, 1204,
+	2462, 3077, 8003, 4295, 4358, 3555, 584, 1054, 7877, 5205,
+	2629, 3034, 2599, 7480, 4992, 6074, 228, 2786, 7069, 6865,
+	6970, 7, 6732, 6627, 4178, 2548, 7845, 7659, 6831, 7242, 5051,
+	2692, 4754, 5082, 8181, 5836, 5864, 3317, 1826, 2894, 346,
+	4598, 7639, 816, 4352, 1444, 2361, 2796, 4313, 4967, 5263,
+	2906, 2391, 7720, 6584, 3059, 3388, 468, 2070, 564, 7693,
+	7105, 7041, 6764, 1387, 7309, 6882, 1957, 4604, 5445, 4120,
+	4057, 1433, 2839, 883, 839, 7765, 1294, 7442, 6336, 4489, 824,
+	2224, 966, 260, 7959, 5281, 3627, 6388, 803, 7420, 2309, 2970,
+	7548, 5597, 4843, 4681, 7003, 4373, 7280, 2453, 1533, 2667,
+	4728, 213, 1205, 7320, 2463, 2557, 3078, 34, 8004, 2655, 4296,
+	577, 4359, 4017, 3556, 727, 585, 4795, 1055, 3138, 7878, 6097,
+	5206, 440, 2630, 3818, 3035, 600, 2600, 7645, 7481, 4303,
+	4993, 2820, 6075, 325, 229, 7021, 2787, 1718, 7070, 8147,
+	6866, 2746, 6971, 6525, 8, 6287, 6733, 3363, 6628, 2882, 4179,
+	2508, 2549, 6263, 7846, 1480, 7660, 7909, 6832, 4562, 7243,
+	6013, 5052, 4065, 2693, 2582, 4755, 2138, 5083, 6783, 8182,
+	6197, 5837, 5184, 5865, 87, 3318, 7602, 1827, 489, 2895, 4557,
+	347, 7177, 4599, 5859, 7640, 2448, 817, 7472, 4353, 2900,
+	1445, 7407, 2362, 5907, 2797, 2639, 4314, 362, 4968, 3697,
+	5264, 202, 2907, 3580, 2392, 1752, 7721, 6899, 6585, 5043,
+	3060, 6150, 3389, 1846, 469, 2732, 2071, 6180, 565, 1726,
+	7694, 7182, 7106, 2215, 7042, 5823, 6765, 5568, 1388, 4135,
+	7310, 3237, 6883, 5359, 1958, 4443, 4605, 1761, 5446, 3779,
+	4121, 136, 4058, 1688, 1434, 339, 2840, 3670, 884, 7987, 840,
+	2417, 7766, 352, 1295, 4024, 7443, 2429, 6337, 8166, 4490,
+	7494, 825, 2319, 2225, 2611, 967, 2330, 261, 7082, 7960, 4389,
+	5282, 6494, 3628, 3940, 6389, 7145, 804, 6593, 7421, 1411,
+	2310, 4211, 2971, 7607, 7549, 5626, 5598, 1695, 4844, 283,
+	4682, 7943, 7004, 6125, 4374, 4813, 7281, 4516, 2454, 7979,
+	1534, 2153, 2668, 3174, 4729, 5507, 214, 5025, 1206, 4956,
+	7321, 2123, 2464, 4075, 2558, 3323, 3079, 1335, 35, 1588,
+	8005, 108, 2656, 6609, 4297, 4114, 578, 795, 4360, 1329, 4018,
+	7401, 3557, 22, 728, 6678, 586, 1995, 4796, 1986, 1056, 3018,
+	3139, 7204, 7879, 4251, 6098, 494, 5207, 4225, 441, 3882,
+	2631, 1195, 3819, 6271, 3036, 7527, 601, 6242, 2601, 5487,
+	7646, 645, 7482, 1544, 4304, 6346, 4994, 3150, 2821, 1857,
+	6076, 7455, 326, 2351, 230, 6456, 7022, 1832, 2788, 4366,
+	1719, 4244, 7071, 550, 8148, 6644, 6867, 3187, 2747, 6803,
+	6972, 1149, 6526, 6444, 9, 6206, 6288, 2811, 6734, 5427, 3364,
+	911, 6629, 4158, 2883, 2949, 4180, 6565, 2509, 3585, 2550,
+	1949, 6264, 4128, 7847, 4006, 1481, 989, 7661, 6406, 7910,
+	5343, 6833, 7568, 4563, 312, 7244, 1160, 6014, 1306, 5053,
+	6108, 4066, 1215, 2694, 1619, 2583, 2680, 4756, 1108, 2139,
+	2912, 5084, 1594, 6784, 3402, 8183, 6279, 6198, 6218, 5838,
+	3764, 5185, 7217, 5866, 2113, 88, 6037, 3319, 7397, 7603,
+	7975, 1828, 6440, 490, 641, 2896, 1748, 4558, 83, 348, 7078,
+	7178, 1757, 4600, 256, 5860, 2387, 7641, 6521, 2449, 4013,
+	818, 6860, 7473, 2780, 4354, 6966, 2901, 961, 1446, 407, 7408,
+	7924, 2363, 5326, 5908, 5249, 2798, 2340, 2640, 7289, 4315,
+	6004, 363, 2397, 4969, 41, 3698, 3987, 5265, 3644, 203, 8057,
+	2908, 6033, 3581, 308, 2393, 953, 1753, 957, 7722, 2263, 6900,
+	4151, 6586, 6256, 5044, 3306, 3061, 6907, 6151, 666, 3390,
+	3005, 1847, 3702, 470, 7369, 2733, 143, 2072, 1402, 6181,
+	3973, 566, 1497, 1727, 6355, 7695, 1173, 7183, 3991, 7107,
+	7741, 2216, 1321, 7043, 5295, 5824, 4278, 6766, 155, 5569,
+	5887, 1389, 4575, 4136, 4973, 7311, 1341, 3238, 5388, 6884,
+	1457, 5360, 5166, 1959, 7705, 4444, 6689, 4606, 7115, 1762,
+	45, 5447, 7163, 3780, 617, 4122, 2381, 137, 1091, 4059, 5817,
+	1689, 3876, 1435, 557, 340, 207, 2841, 538, 3671, 1097, 885,
+	1350, 7988, 7854, 841, 6371, 2418, 2295, 7767, 4908, 353,
+	8061, 1296, 3507, 4025, 1915, 7444, 2936, 2430, 8132, 6338,
+	4787, 8167, 1907, 4491, 5155, 7495, 5269, 826, 3085, 2320,
+	6297, 2226, 2922, 2612, 3837, 968, 6716, 2331, 4718, 262,
+	1885, 7083, 3648, 7961, 6226, 4390, 6049, 5283, 3125, 6495,
+	3250, 3629, 2270, 3941, 4434, 6390, 5127, 7146, 2644, 805,
+	4324, 6594, 5453, 7422, 4400, 1412, 7671, 2311, 4984, 4212,
+	6025, 2972, 1242, 7608, 7293, 7550, 8040, 5627, 7587, 5599,
+	4422, 1696, 4946, 4845, 5735, 284, 6545, 4683, 5959, 7944,
+	2802, 7005, 6615, 6126, 5775, 4375, 3827, 4814, 8070, 7282,
+	1900, 4517, 2992, 2455, 3811, 7980, 2344, 1535, 1514, 2154,
+	2242, 2669, 3606, 3175, 3342, 4730, 5994, 5508, 3459, 215,
+	8155, 5026, 367, 1207, 4938, 4957, 7169, 7322, 5669, 2124,
+	996, 2465, 124, 4076, 5897, 2559, 3950, 3324, 2401, 3080, 533,
+	1336, 7364, 36, 251, 1589, 1944, 8006, 6939, 109, 4524, 2657,
+	4933, 6610, 4319, 4298, 2662, 4115, 1821, 579, 3053, 796,
+	7234, 4361, 4220, 1330, 5621, 4019, 2210, 7402, 6008, 3558,
+	6844, 23, 7380, 729, 6506, 6679, 2092, 587, 7729, 1996, 2081,
+	4797, 2373, 1987, 7412, 1057, 4529, 3019, 3786, 3140, 2191,
+	7205, 7514, 7880, 7256, 4252, 3205, 6099, 4587, 495, 7928,
+	5208, 5401, 4226, 3541, 442, 8089, 3883, 176, 2632, 101, 1196,
+	876, 3820, 1224, 6272, 1450, 3037, 114, 7528, 3485, 602, 1231,
+	6243, 2179, 2602, 5612, 5488, 3432, 7647, 7749, 646, 411,
+	7483, 7864, 1545, 6661, 4305, 4805, 6347, 3197, 4995, 1608,
+	3151, 1137, 2822, 6651, 1858, 5912, 6077, 6944, 7456, 623,
+	327, 7810, 2352, 1488, 231, 4620, 6457, 2494, 7023, 5942,
+	1833, 5253, 2789, 1523, 4367, 8175, 1720, 7903, 4245, 4205,
+	7072, 6559, 551, 2999, 8149, 5121, 6645, 2367, 6868, 8011,
+	3188, 1977, 2748, 5585, 6804, 5377, 6973, 3897, 1150, 64,
+	6527, 4474, 6445, 5330, 10, 5092, 6207, 4692, 6289, 1969,
+	2812, 4236, 6735, 3709, 5428, 3659, 3365, 8017, 912, 7914,
+	6630, 1001, 4159, 7773, 2884, 1739, 2950, 4886, 4181, 5139,
+	6566, 5718, 2510, 3570, 3586, 5347, 2551, 4346, 1950, 1285,
+	6265, 7937, 4129, 2132, 7848, 3967, 4007, 983, 1482, 7508,
+	990, 7665, 7662, 2129, 6407, 4880, 7911, 4233, 5344, 4883,
+	6834, 5701, 7569, 6321, 4564, 2761, 313, 6410, 7245, 932,
+	1161, 7626, 6015, 6423, 1307, 2764, 5054, 2959, 6109, 4334,
+	4067, 6874, 1216, 4567, 2695, 5674, 1620, 4914, 2584, 1644,
+	2681, 6413, 4757, 4667, 1109, 1370, 2140, 899, 2913, 316,
+	5085, 5015, 1595, 5763, 6785, 712, 3403, 5704, 8184, 6725,
+	6280, 4382, 6199, 2256, 6219, 6837, 5839, 7327, 3765, 6706,
+	5186, 385, 7218, 6324, 5867, 1250, 2114, 867, 89, 1872, 6038,
+	7572, 3320, 5022, 7398, 6606, 7604, 7142, 7976, 7940, 1829,
+	1854, 6441, 6641, 491, 1983, 642, 6268, 2897, 7174, 1749, 359,
+	4559, 2505, 84, 2135, 349, 336, 7079, 7491, 7179, 1843, 1758,
+	4132, 4601, 7690, 257, 7762, 5861, 6828, 2388, 4349, 7642,
+	6094, 6522, 7018, 2450, 2967, 4014, 2554, 819, 4962, 6861,
+	4291, 7474, 3548, 2781, 1288, 4355, 7276, 6967, 2596, 2902,
+	5832, 962, 1953, 1447, 173, 408, 2176, 7409, 2089, 7925, 7511,
+	2364, 4202, 5327, 5374, 5909, 3194, 5250, 1485, 2799, 4943,
+	2341, 8067, 2641, 3247, 7290, 7668, 4316, 1941, 6005, 7231,
+	364, 3339, 2398, 993, 4970, 4275, 42, 5163, 3699, 3303, 3988,
+	3970, 5266, 8129, 3645, 3834, 204, 1088, 8058, 7851, 2909,
+	1212, 6034, 6215, 3582, 908, 309, 986, 2394, 5246, 954, 8054,
+	1754, 638, 958, 4010, 7723, 1602, 2264, 5988, 6901, 5811,
+	4152, 1742, 6587, 3012, 6257, 2726, 5045, 5591, 3307, 2887,
+	3062, 2406, 6908, 847, 6152, 397, 667, 4889, 3391, 3098, 3006,
+	2032, 1848, 4196, 3703, 2953, 471, 7055, 7370, 2015, 2734,
+	1631, 144, 1004, 2073, 658, 1403, 4746, 6182, 5787, 3974,
+	6633, 567, 3329, 1498, 4086, 1728, 5215, 6356, 7776, 7696,
+	7433, 1174, 7267, 7184, 2520, 3992, 4162, 7108, 2106, 7742,
+	3804, 2217, 6066, 1322, 3573, 7044, 2038, 5296, 1662, 5825,
+	2754, 4279, 2513, 6767, 3955, 156, 6377, 5570, 5537, 5888,
+	5350, 1390, 7832, 4576, 5546, 4137, 2279, 4974, 3589, 7312,
+	1187, 1342, 7802, 3239, 7349, 5389, 5142, 6885, 4708, 1458,
+	4821, 5361, 4045, 5167, 4184, 1960, 2564, 7706, 5418, 4445,
+	1563, 6690, 5721, 4607, 2980, 7116, 5497, 1763, 6307, 46,
+	6569, 5448, 5770, 7164, 1816, 3781, 3480, 618, 1972, 4123,
+	3397, 2382, 3982, 138, 5383, 1092, 6292, 4060, 5902, 5818,
+	2424, 1690, 1583, 3877, 4239, 1436, 6996, 558, 7872, 341,
+	1428, 208, 2815, 2842, 187, 539, 295, 3672, 7126, 1098, 5095,
+	886, 1706, 1351, 5876, 7989, 5062, 7855, 13, 842, 4081, 6372,
+	5413, 2419, 5408, 2296, 4695, 7768, 4875, 4909, 6701, 354,
+	4286, 8062, 6210, 1297, 5071, 3508, 1276, 4026, 2004, 1916,
+	8020, 7445, 3104, 2937, 4101, 2431, 6810, 8133, 3368, 6339,
+	129, 4788, 2301, 8168, 7357, 1908, 7917, 4492, 7795, 5156,
+	5756, 7496, 3221, 5270, 915, 827, 2163, 3086, 4499, 2321,
+	2201, 6298, 3712, 2227, 3114, 2923, 8077, 2613, 5659, 3838,
+	6738, 969, 2470, 6717, 4700, 2332, 6931, 4719, 3662, 263, 758,
+	1886, 4864, 7084, 1804, 3649, 5431, 7962, 6792, 6227, 5968,
+	4391, 2573, 6050, 388, 5284, 673, 3126, 699, 6496, 3903, 3251,
+	5189, 3630, 3347, 2271, 891, 3942, 6958, 4435, 6327, 6391,
+	3855, 5128, 3920, 7147, 2711, 2645, 7221, 806, 74, 4325, 3517,
+	6595, 504, 5454, 7330, 7423, 3687, 4401, 6168, 1413, 5105,
+	7672, 5842, 2312, 3180, 4985, 1711, 4213, 3890, 6026, 6709,
+	2973, 751, 1243, 5239, 7609, 2045, 7294, 3768, 7551, 5799,
+	8041, 6752, 5628, 2854, 7588, 1875, 5600, 4895, 4423, 3526,
+	1697, 6979, 4947, 92, 4846, 3611, 5736, 1356, 285, 3164, 6546,
+	7575, 4684, 5980, 5960, 1023, 7945, 3355, 2803, 6041, 7006,
+	6162, 6616, 922, 6127, 1068, 5776, 1253, 4376, 977, 3828,
+	7012, 4815, 4740, 8071, 5870, 7283, 2674, 1901, 5881, 4518,
+	6539, 2993, 870, 2456, 7301, 3812, 1381, 7981, 2442, 2345,
+	2117, 1536, 719, 1515, 3499, 2155, 4267, 2243, 715, 2670,
+	6158, 3607, 5795, 3176, 70, 3343, 6788, 4731, 2247, 5995,
+	7994, 5509, 3749, 3460, 5707, 216, 7819, 8156, 1553, 5027,
+	5312, 368, 3406, 1208, 4271, 4939, 169, 4958, 7686, 7170,
+	5018, 7323, 5011, 5670, 928, 2125, 4342, 997, 5088, 2466,
+	2159, 125, 5067, 4077, 183, 5898, 5766, 2560, 1183, 3951,
+	2102, 3325, 7051, 2402, 1598, 3081, 3503, 534, 7159, 1337,
+	7737, 7365, 2259, 37, 403, 252, 7393, 1590, 1156, 1945, 6202,
+	8007, 1519, 6940, 7860, 110, 5397, 4525, 6840, 2658, 529,
+	4934, 1510, 6611, 8036, 4320, 6222, 4299, 723, 2663, 5277,
+	4116, 6580, 1822, 6728, 580, 3622, 3054, 6622, 797, 2542,
+	7235, 8187, 4362, 1540, 4221, 18, 1331, 2149, 5622, 4385,
+	4020, 3775, 2211, 6895, 7403, 7598, 6009, 6283, 3559, 3410,
+	6845, 1031, 24, 1931, 7381, 1647, 730, 6914, 6507, 6478, 6680,
+	4480, 2093, 2587, 588, 372, 7730, 2847, 1997, 6059, 2082,
+	6416, 4798, 3599, 2374, 6433, 1988, 6143, 7413, 2684, 1058,
+	5316, 4530, 3269, 3020, 1677, 3787, 5677, 3141, 7894, 2192,
+	1074, 7206, 8113, 7515, 2698, 7881, 5031, 7257, 192, 4253,
+	449, 3206, 4917, 6100, 4414, 4588, 4549, 496, 1669, 7929,
+	1623, 5209, 1557, 5402, 6925, 4227, 379, 3542, 902, 443, 853,
+	8090, 2531, 3884, 6533, 177, 2143, 2633, 8160, 102, 544, 1197,
+	2623, 877, 319, 3821, 3047, 1225, 5579, 6273, 3638, 1451,
+	2916, 3038, 7823, 115, 3228, 7529, 5689, 3486, 4670, 603,
+	2478, 1232, 6133, 6244, 2057, 2180, 4760, 2603, 220, 5613,
+	300, 5489, 859, 3433, 1373, 7648, 7616, 7750, 3441, 647, 3721,
+	412, 1112, 7484, 5711, 7865, 2025, 1546, 3913, 6662, 6426,
+	4306, 3068, 4806, 6190, 6348, 5336, 3198, 6018, 4996, 3464,
+	1609, 3677, 3152, 780, 1138, 2767, 2823, 1267, 6652, 6669,
+	1859, 428, 5913, 1310, 6078, 3753, 6945, 5475, 7457, 1127,
+	624, 935, 328, 6988, 7811, 1259, 2353, 6117, 1489, 7248, 232,
+	5513, 4621, 7131, 6458, 8096, 2495, 7629, 7024, 3735, 5943,
+	1789, 1834, 5303, 5254, 1164, 2790, 7998, 1524, 2832, 4368,
+	595, 8176, 6877, 1721, 2412, 7904, 7467, 4246, 6451, 4206,
+	4070, 7073, 5999, 6560, 1103, 552, 5150, 3000, 4570, 8150,
+	4928, 5122, 5954, 6646, 5116, 2368, 1219, 6869, 2251, 8012,
+	7503, 3189, 1083, 1978, 2962, 2749, 4040, 5586, 5782, 6805,
+	5654, 5378, 5057, 6974, 4735, 3898, 5100, 1151, 2537, 65,
+	4337, 6528, 2052, 4475, 8108, 6446, 5649, 5331, 6112, 11,
+	5874, 5093, 293, 6208, 6699, 4693, 5411, 6290, 3980, 1970,
+	1814, 2813, 7870, 4237, 2422, 6736, 8075, 3710, 4497, 5429,
+	4862, 3660, 4698, 3366, 4099, 8018, 1274, 913, 5754, 7915,
+	2299, 6631, 4744, 1002, 2013, 4160, 7265, 7774, 4084, 2885,
+	2724, 1740, 5986, 2951, 2030, 4887, 845, 4182, 4819, 5140,
+	7800, 6567, 5495, 5719, 5416, 2511, 1660, 3571, 3802, 3587,
+	5544, 5348, 6375, 2552, 7016, 4347, 7760, 1951, 2594, 1286,
+	4289, 6266, 6639, 7938, 6604, 4130, 7489, 2133, 357, 7849,
+	3832, 3968, 5161, 4008, 8052, 984, 6213, 1483, 5372, 7509,
+	2174, 991, 7229, 7666, 8065, 7663, 981, 2130, 1283, 6408,
+	6319, 4881, 4878, 7912, 3657, 4234, 4690, 5345, 5716, 4884,
+	7771, 6835, 4380, 5702, 5761, 7570, 865, 6322, 6704, 4565,
+	4332, 2762, 7624, 314, 1368, 6411, 4912, 7246, 1257, 933,
+	5473, 1162, 1787, 7627, 7129, 6016, 6188, 6424, 2023, 1308,
+	6667, 2765, 3675, 5055, 5780, 2960, 7501, 6110, 8106, 4335,
+	5098, 4068, 7465, 6875, 2830, 1217, 5952, 4568, 1101, 2696,
+	1072, 5675, 3267, 1621, 4547, 4915, 190, 2585, 6476, 1645,
+	1029, 2682, 6431, 6414, 2845, 4758, 6131, 4668, 3226, 1110,
+	3439, 1371, 298, 2141, 2529, 900, 6923, 2914, 5577, 317, 542,
+	5086, 926, 5016, 167, 1596, 2100, 5764, 5065, 6786, 5793, 713,
+	3497, 3404, 1551, 5705, 7992, 8185, 6620, 6726, 5275, 6281,
+	6893, 4383, 16, 6200, 7391, 2257, 7157, 6220, 1508, 6838,
+	7858, 5840, 6166, 7328, 3515, 3766, 5237, 6707, 1709, 5187,
+	697, 386, 5966, 7219, 3918, 6325, 889, 5868, 7010, 1251, 920,
+	2115, 1379, 868, 5879, 90, 3524, 1873, 6750, 6039, 1021, 7573,
+	1354, 3321, 2121, 5023, 3172, 7399, 793, 6607, 1586, 7605,
+	1409, 7143, 6492, 7977, 4811, 7941, 1693, 1830, 2349, 1855,
+	6344, 6442, 6801, 6642, 4242, 492, 7202, 1984, 6676, 643,
+	6240, 6269, 3880, 2898, 2446, 7175, 487, 1750, 200, 360, 5905,
+	4560, 1478, 2506, 3361, 85, 6195, 2136, 4063, 350, 7985, 337,
+	134, 7080, 2609, 7492, 2427, 7180, 6178, 1844, 5041, 1759,
+	5357, 4133, 5821, 4602, 1385, 7691, 3386, 258, 4487, 7763,
+	1431, 5862, 4752, 6829, 4176, 2389, 4311, 4350, 344, 7643,
+	3816, 6095, 4793, 6523, 8145, 7019, 2818, 2451, 4679, 2968,
+	6386, 4015, 2653, 2555, 211, 820, 7305, 4963, 5078, 6862,
+	3031, 4292, 6999, 7475, 5439, 3549, 7951, 2782, 3073, 1289,
+	1439, 4356, 2460, 7277, 2306, 6968, 226, 2597, 7875, 2903,
+	813, 5833, 7656, 963, 836, 1954, 561, 1448, 874, 174, 3539,
+	409, 3430, 2177, 3483, 7410, 2079, 2090, 7378, 7926, 3203,
+	7512, 3784, 2365, 2997, 4203, 8173, 5328, 62, 5375, 1975,
+	5910, 1135, 3195, 6659, 5251, 2492, 1486, 621, 2800, 6543,
+	4944, 7585, 2342, 2990, 8068, 5773, 2642, 4432, 3248, 6047,
+	7291, 6023, 7669, 5451, 4317, 4522, 1942, 7362, 6006, 5619,
+	7232, 1819, 365, 3457, 3340, 2240, 2399, 5895, 994, 7167,
+	4971, 5885, 4276, 1319, 43, 6687, 5164, 5386, 3700, 664, 3304,
+	4149, 3989, 6353, 3971, 141, 5267, 1905, 8130, 1913, 3646,
+	4716, 3835, 6295, 205, 3874, 1089, 615, 8059, 2293, 7852,
+	1095, 2910, 2678, 1213, 1304, 6035, 7215, 6216, 3400, 3583,
+	2947, 909, 2809, 310, 5341, 987, 4126, 2395, 7287, 5247, 7922,
+	955, 306, 8055, 3985, 1755, 81, 639, 7973, 959, 2778, 4011,
+	2385, 7724, 96, 1603, 6554, 2265, 5730, 5989, 6934, 6902, 150,
+	5812, 4782, 4153, 1614, 1743, 2335, 6588, 4951, 3013, 7450,
+	6258, 5854, 2727, 3665, 5046, 7036, 5592, 435, 3308, 461,
+	2888, 4722, 3063, 6983, 2407, 4035, 6909, 7889, 848, 2473,
+	6153, 5006, 398, 3617, 668, 3682, 4890, 972, 3392, 1701, 3099,
+	3109, 3007, 653, 2033, 4703, 1849, 6089, 4197, 8124, 3704,
+	3962, 2954, 6720, 472, 3530, 7056, 4775, 7371, 6485, 2016,
+	1807, 2735, 1010, 1632, 513, 145, 5001, 1005, 7087, 2074,
+	4427, 659, 2942, 1404, 1473, 4747, 5434, 6183, 6471, 5788,
+	692, 3975, 2719, 6634, 3652, 568, 4899, 3330, 8027, 1499,
+	3279, 4087, 761, 1729, 7092, 5216, 4852, 6357, 3469, 7777,
+	266, 7697, 5604, 7434, 4106, 1175, 3727, 7268, 4867, 7185,
+	5461, 2521, 3449, 3993, 5930, 4163, 1889, 7109, 1879, 2107,
+	947, 7743, 4468, 3805, 2204, 2218, 2740, 6067, 7063, 1323,
+	1143, 3574, 2324, 7045, 7592, 2039, 2436, 5297, 5643, 1663,
+	3715, 5826, 632, 2755, 1866, 4280, 1798, 2514, 6301, 6768,
+	2858, 3956, 5924, 157, 684, 6378, 2166, 5571, 1015, 5538,
+	1362, 5889, 2772, 5351, 830, 1391, 5632, 7833, 6815, 4577,
+	418, 5547, 4502, 4138, 7193, 2280, 739, 4975, 6774, 3590,
+	3089, 7313, 6756, 1188, 5561, 1343, 6514, 7803, 5662, 3240,
+	1637, 7350, 5530, 5390, 3157, 5143, 2616, 6886, 8045, 4709,
+	8138, 1459, 1466, 4822, 6741, 5362, 4635, 4046, 4657, 5168,
+	3288, 4185, 3841, 1961, 5803, 2565, 1923, 7707, 2874, 5419,
+	3117, 4446, 518, 1564, 5742, 6691, 785, 5722, 2230, 4608,
+	7555, 2981, 3373, 7117, 1118, 5498, 8080, 1764, 7337, 6308,
+	4831, 47, 2864, 6570, 2926, 5449, 6045, 5771, 7583, 7165,
+	2238, 1817, 7360, 3782, 7376, 3481, 3537, 619, 6657, 1973,
+	8171, 4124, 2807, 3398, 1302, 2383, 7971, 3983, 7920, 139,
+	4147, 5384, 1317, 1093, 613, 6293, 1911, 4061, 3359, 5903,
+	485, 5819, 5039, 2425, 132, 1691, 6490, 1584, 3170, 3878,
+	6674, 4240, 6342, 1437, 7949, 6997, 5076, 559, 7654, 7873,
+	2304, 342, 4174, 1429, 3384, 209, 6384, 2816, 4791, 2843,
+	1027, 188, 3265, 540, 6921, 296, 3224, 3673, 2021, 7127, 5471,
+	1099, 2828, 5096, 7499, 887, 5964, 1707, 3513, 1352, 6748,
+	5877, 918, 7990, 3495, 5063, 165, 7856, 7155, 14, 5273, 843,
+	5984, 4082, 2011, 6373, 3800, 5414, 7798, 2420, 1812, 5409,
+	291, 2297, 1272, 4696, 4495, 7769, 4688, 4876, 1281, 4910,
+	7622, 6702, 5759, 355, 6602, 4287, 7758, 8063, 2172, 6211,
+	5159, 1298, 7579, 5072, 481, 3509, 3261, 1277, 2007, 4027,
+	477, 2005, 479, 1917, 5918, 8021, 4029, 7446, 6550, 3105,
+	4031, 2938, 4771, 4102, 8023, 2432, 943, 6811, 5920, 8134,
+	5557, 3369, 1919, 6340, 3168, 130, 483, 4789, 3382, 2302,
+	5074, 8169, 3535, 7358, 7581, 1909, 1315, 7918, 1300, 4493,
+	289, 7796, 2009, 5157, 7756, 5757, 1279, 7497, 5469, 3222,
+	3263, 5271, 163, 916, 3511, 828, 1360, 2164, 5922, 3087, 737,
+	4500, 6813, 2322, 7061, 2202, 945, 6299, 1864, 3713, 2434,
+	2228, 5740, 3115, 1921, 2924, 4829, 8078, 3371, 2614, 5528,
+	5660, 5559, 3839, 4655, 6739, 8136, 970, 3615, 2471, 4033,
+	6718, 8122, 4701, 3107, 2333, 4780, 6932, 6552, 4720, 433,
+	3663, 7448, 264, 4850, 759, 8025, 1887, 3447, 4865, 4104,
+	7085, 511, 1805, 4773, 3650, 690, 5432, 2940, 7963, 5846,
+	6793, 4854, 6228, 4454, 5969, 5218, 4392, 3998, 2574, 7094,
+	6051, 6950, 389, 1731, 5285, 7676, 674, 268, 3127, 5226, 700,
+	7779, 6497, 3931, 3904, 3471, 3252, 3421, 5190, 6359, 3631,
+	5109, 3348, 8029, 2272, 3214, 892, 3332, 3943, 5935, 6959,
+	4901, 4436, 5480, 6328, 570, 6392, 1417, 3856, 763, 5129,
+	7535, 3921, 4089, 7148, 4648, 2712, 3281, 2646, 2286, 7222,
+	1501, 807, 6172, 75, 3451, 4326, 1654, 3518, 2523, 6596, 4168,
+	505, 5463, 5455, 6083, 7331, 7187, 7424, 4405, 3688, 1891,
+	4402, 4642, 6169, 4165, 1414, 4645, 5106, 5932, 7673, 3928,
+	5843, 3995, 2313, 3691, 3181, 4108, 4986, 1047, 1712, 7436,
+	4214, 1894, 3891, 5606, 6027, 3758, 6710, 7699, 2974, 7427,
+	752, 4869, 1244, 5695, 5240, 7270, 7610, 4408, 2046, 3729,
+	7295, 745, 3769, 1177, 7552, 7334, 5800, 515, 8042, 4632,
+	6753, 1634, 5629, 7190, 2855, 1012, 7589, 629, 1876, 2737,
+	5601, 5458, 4896, 7089, 4424, 6468, 3527, 1007, 1698, 6086,
+	6980, 5003, 4948, 7033, 93, 147, 4847, 508, 3612, 4777, 5737,
+	5525, 1357, 7058, 286, 5466, 3165, 3532, 6547, 940, 7576, 474,
+	4685, 6599, 5981, 1809, 5961, 3492, 1024, 2018, 7946, 4171,
+	3356, 6487, 2804, 4144, 6042, 7373, 7007, 3521, 6163, 694,
+	6617, 7388, 923, 5790, 6128, 2526, 1069, 6473, 5777, 7462,
+	1254, 6185, 4377, 4329, 978, 3654, 3829, 5369, 7013, 6636,
+	4816, 1657, 4741, 2721, 8072, 4096, 5871, 3977, 7284, 78,
+	2675, 2944, 1902, 3871, 5882, 661, 4519, 3454, 6540, 4429,
+	2994, 1132, 871, 2076, 2457, 810, 7302, 5436, 3813, 4676,
+	1382, 4749, 7982, 6175, 2443, 1475, 2346, 7199, 2118, 1406,
+	1537, 3772, 720, 3619, 1516, 526, 3500, 400, 2156, 1180, 4268,
+	5008, 2244, 7816, 716, 6155, 2671, 7298, 6159, 974, 3608,
+	5977, 5796, 4892, 3177, 748, 71, 3684, 3344, 3852, 6789, 670,
+	4732, 2049, 2248, 4037, 5996, 4925, 7995, 2409, 5510, 3732,
+	3750, 6985, 3461, 1264, 5708, 3065, 217, 7613, 7820, 2475,
+	8157, 3044, 1554, 850, 5028, 4411, 5313, 7891, 369, 3596,
+	3407, 6911, 1209, 5243, 4272, 8126, 4940, 1938, 170, 4199,
+	4959, 7273, 7687, 6091, 7171, 333, 5019, 1851, 7324, 1247,
+	5012, 6722, 5671, 4664, 929, 2956, 2126, 5698, 4343, 3964,
+	998, 5136, 5089, 3706, 2467, 755, 2160, 3111, 126, 7792, 5068,
+	3101, 4078, 4872, 184, 1703, 5899, 6993, 5767, 3394, 2561,
+	2977, 1184, 4705, 3952, 7829, 2103, 2035, 3326, 7430, 7052,
+	655, 2403, 3095, 1599, 3009, 3082, 6713, 3504, 4784, 535,
+	6368, 7160, 5814, 1338, 7702, 7738, 152, 7366, 1494, 2260,
+	6904, 38, 6030, 404, 2337, 253, 6857, 7394, 1745, 1591, 3761,
+	1157, 1616, 1946, 6403, 6203, 4155, 8008, 3894, 1520, 6556,
+	6941, 4617, 7861, 1605, 111, 5609, 5398, 98, 4526, 7253, 6841,
+	7726, 2659, 4217, 530, 6936, 4935, 121, 1511, 5991, 6612,
+	1897, 8037, 5732, 4321, 4981, 6223, 2267, 4300, 1715, 724,
+	437, 2664, 31, 5278, 5594, 4117, 7439, 6581, 7038, 1823, 2358,
+	6729, 5048, 581, 4989, 3623, 4724, 3055, 4053, 6623, 2890,
+	798, 1050, 2543, 463, 7236, 7542, 8188, 3310, 4363, 3184,
+	1541, 7452, 4222, 7524, 19, 3015, 1332, 4111, 2150, 4953,
+	5623, 6122, 4386, 6590, 4021, 2316, 3776, 3667, 2212, 3234,
+	6896, 2729, 7404, 3694, 7599, 5856, 6010, 6780, 6284, 6260,
+	3560, 5193, 3411, 5744, 6846, 1572, 1032, 1566, 25, 6362,
+	1932, 520, 7382, 4626, 1648, 4448, 731, 3255, 6915, 2232,
+	6508, 4462, 6479, 5724, 6681, 3424, 4481, 787, 2094, 1781,
+	2588, 6693, 589, 3907, 373, 1925, 7731, 4261, 2848, 2567,
+	1998, 3474, 6060, 5805, 2083, 7136, 6417, 1963, 4799, 6500,
+	3600, 3119, 2375, 6250, 6434, 5421, 1989, 3934, 6144, 2876,
+	7414, 7839, 2685, 7709, 1059, 703, 5317, 4833, 4531, 1038,
+	3270, 6310, 3021, 7782, 1678, 7339, 3788, 237, 5678, 1766,
+	3142, 3130, 7895, 2928, 2193, 3295, 1075, 6572, 7207, 5229,
+	8114, 2866, 7516, 3863, 2699, 49, 7882, 677, 5032, 3375, 7258,
+	4540, 193, 2983, 4254, 271, 450, 7557, 3207, 5518, 4918, 4610,
+	6101, 5288, 4415, 8082, 4589, 2063, 4550, 5500, 497, 7679,
+	1670, 1120, 7930, 6821, 1624, 7119, 5210, 392, 1558, 5532,
+	5403, 1578, 6926, 7352, 4228, 1734, 380, 1639, 3543, 2500,
+	903, 3242, 444, 6054, 854, 2618, 8091, 775, 2532, 5145, 3885,
+	6953, 6534, 3159, 178, 3744, 2144, 5392, 2634, 2577, 8161,
+	5563, 103, 278, 545, 1190, 1198, 7097, 2624, 6758, 878, 7634,
+	320, 7315, 3822, 4395, 3048, 5664, 1226, 2186, 5580, 7805,
+	6274, 4001, 3639, 6516, 1452, 1397, 2917, 1345, 3039, 5972,
+	7824, 4659, 116, 6852, 3229, 4048, 7530, 5221, 5690, 4637,
+	3487, 6463, 4671, 5364, 604, 6231, 2479, 3843, 1233, 5175,
+	6134, 4187, 6245, 4457, 2058, 3290, 2181, 770, 4761, 5170,
+	2604, 6796, 221, 8140, 5614, 57, 301, 4711, 5490, 4857, 860,
+	8047, 3434, 8101, 1374, 6888, 7649, 7966, 7617, 6743, 7751,
+	4766, 3442, 4824, 648, 5849, 3722, 1468, 413, 5638, 1113,
+	1461, 7485, 7225, 5712, 1364, 7866, 5750, 2026, 5540, 1547,
+	1504, 3914, 1017, 6663, 5948, 6427, 5573, 4307, 2649, 3069,
+	832, 4807, 6236, 6191, 5353, 6349, 2289, 5337, 2774, 3199,
+	2488, 6019, 5891, 4997, 2715, 3465, 5926, 1610, 457, 3678,
+	3958, 3153, 3284, 781, 2860, 1139, 1794, 2768, 6770, 2824,
+	7151, 1268, 2168, 6653, 609, 6670, 6380, 1860, 4651, 429, 686,
+	5914, 5553, 1311, 159, 6079, 3924, 3754, 741, 6946, 3417,
+	5476, 2282, 7458, 4092, 1128, 7195, 625, 7029, 936, 4140, 329,
+	5132, 6989, 3091, 7812, 3848, 1260, 3592, 2354, 7538, 6118,
+	6776, 1490, 6399, 7249, 4977, 233, 3859, 5514, 6817, 4622,
+	1777, 7132, 7835, 6459, 766, 8097, 5634, 2496, 3740, 7630,
+	1393, 7025, 6395, 3736, 4504, 5944, 2484, 1790, 5549, 1835,
+	1420, 5304, 420, 5255, 4508, 1165, 4579, 2791, 6331, 7999,
+	7065, 1525, 5199, 2833, 6069, 4369, 573, 596, 2742, 8177,
+	5259, 6878, 2220, 1722, 4439, 2413, 2326, 7905, 5180, 7468,
+	3576, 4247, 5483, 6452, 1145, 4207, 4512, 4071, 1325, 7074,
+	6962, 6000, 949, 6561, 7564, 1104, 2109, 553, 4904, 5151,
+	1881, 3001, 1169, 4571, 7111, 8151, 3946, 4929, 2206, 5123,
+	1238, 5955, 3807, 6647, 5938, 5117, 4470, 2369, 4583, 1220,
+	7745, 6870, 895, 2252, 1868, 8013, 3566, 7504, 2757, 3190,
+	3335, 1084, 634, 1979, 1839, 2963, 5828, 2750, 2275, 4041,
+	6303, 5587, 4192, 5783, 2516, 6806, 3217, 5655, 1800, 5379,
+	1424, 5058, 4282, 6975, 3351, 4736, 2438, 3899, 2707, 5101,
+	2041, 1152, 8032, 2538, 7594, 66, 5308, 4338, 7047, 6529,
+	3634, 2053, 3717, 4476, 6139, 8109, 1665, 6447, 5112, 5650,
+	5645, 5332, 424, 6113, 5299, 12, 5061, 5875, 1705, 5094, 7125,
+	294, 186, 6209, 4285, 6700, 4874, 4694, 5407, 5412, 4080,
+	6291, 5382, 3981, 3396, 1971, 3479, 1815, 5769, 2814, 1427,
+	7871, 6995, 4238, 1582, 2423, 5901, 6737, 5658, 8076, 3113,
+	3711, 2200, 4498, 2162, 5430, 1803, 4863, 757, 3661, 6930,
+	4699, 2469, 3367, 6809, 4100, 3103, 8019, 2003, 1275, 5070,
+	914, 3220, 5755, 7794, 7916, 7356, 2300, 128, 6632, 5786,
+	4745, 657, 1003, 1630, 2014, 7054, 4161, 2519, 7266, 7432,
+	7775, 5214, 4085, 3328, 2886, 5590, 2725, 3011, 1741, 5810,
+	5987, 1601, 2952, 4195, 2031, 3097, 4888, 396, 846, 2405,
+	4183, 4044, 4820, 4707, 5141, 7348, 7801, 1186, 6568, 6306,
+	5496, 2979, 5720, 1562, 5417, 2563, 2512, 2753, 1661, 2037,
+	3572, 6065, 3803, 2105, 3588, 2278, 5545, 7831, 5349, 5536,
+	6376, 3954, 2553, 2966, 7017, 6093, 4348, 6827, 7761, 7689,
+	1952, 5831, 2595, 7275, 1287, 3547, 4290, 4961, 6267, 1982,
+	6640, 1853, 7939, 7141, 6605, 5021, 4131, 1842, 7490, 335,
+	2134, 2504, 358, 7173, 7850, 1087, 3833, 8128, 3969, 3302,
+	5162, 4274, 4009, 637, 8053, 5245, 985, 907, 6214, 1211, 1484,
+	3193, 5373, 4201, 7510, 2088, 2175, 172, 992, 3338, 7230,
+	1940, 7667, 3246, 8066, 4942, 7664, 7507, 982, 3966, 2131,
+	7936, 1284, 4345, 6409, 2760, 6320, 5700, 4882, 4232, 4879,
+	2128, 7913, 8016, 3658, 3708, 4235, 1968, 4691, 5091, 5346,
+	3569, 5717, 5138, 4885, 1738, 7772, 1000, 6836, 2255, 4381,
+	6724, 5703, 711, 5762, 5014, 7571, 1871, 866, 1249, 6323, 384,
+	6705, 7326, 4566, 6873, 4333, 2958, 2763, 6422, 7625, 931,
+	315, 898, 1369, 4666, 6412, 1643, 4913, 5673, 7247, 6116,
+	1258, 6987, 934, 1126, 5474, 3752, 1163, 5302, 1788, 3734,
+	7628, 8095, 7130, 5512, 6017, 5335, 6189, 3067, 6425, 3912,
+	2024, 5710, 1309, 427, 6668, 1266, 2766, 779, 3676, 3463,
+	5056, 5653, 5781, 4039, 2961, 1082, 7502, 2250, 6111, 5648,
+	8107, 2051, 4336, 2536, 5099, 4734, 4069, 6450, 7466, 2411,
+	6876, 594, 2831, 7997, 1218, 5115, 5953, 4927, 4569, 5149,
+	1102, 5998, 2697, 8112, 1073, 7893, 5676, 1676, 3268, 5315,
+	1622, 1668, 4548, 4413, 4916, 448, 191, 5030, 2586, 4479,
+	6477, 6913, 1646, 1930, 1030, 3409, 2683, 6142, 6432, 3598,
+	6415, 6058, 2846, 371, 4759, 2056, 6132, 2477, 4669, 5688,
+	3227, 7822, 1111, 3720, 3440, 7615, 1372, 858, 299, 219, 2142,
+	6532, 2530, 852, 901, 378, 6924, 1556, 2915, 3637, 5578, 3046,
+	318, 2622, 543, 8159, 5087, 4341, 927, 5010, 5017, 7685, 168,
+	4270, 1597, 7050, 2101, 1182, 5765, 182, 5066, 2158, 6787, 69,
+	5794, 6157, 714, 4266, 3498, 718, 3405, 5311, 1552, 7818,
+	5706, 3748, 7993, 2246, 8186, 2541, 6621, 3621, 6727, 6579,
+	5276, 722, 6282, 7597, 6894, 3774, 4384, 2148, 17, 1539, 6201,
+	1155, 7392, 402, 2258, 7736, 7158, 3502, 6221, 8035, 1509,
+	528, 6839, 5396, 7859, 1518, 5841, 5104, 6167, 3686, 7329,
+	503, 3516, 73, 3767, 2044, 5238, 750, 6708, 3889, 1710, 3179,
+	5188, 3902, 698, 672, 387, 2572, 5967, 6791, 7220, 2710, 3919,
+	3854, 6326, 6957, 890, 3346, 5869, 4739, 7011, 976, 1252,
+	1067, 921, 6161, 2116, 2441, 1380, 7300, 869, 6538, 5880,
+	2673, 91, 6978, 3525, 4894, 1874, 2853, 6751, 5798, 6040,
+	3354, 1022, 5979, 7574, 3163, 1355, 3610, 3322, 4074, 2122,
+	4955, 5024, 5506, 3173, 2152, 7400, 1328, 794, 4113, 6608,
+	107, 1587, 1334, 7606, 4210, 1410, 6592, 7144, 3939, 6493,
+	4388, 7978, 4515, 4812, 6124, 7942, 282, 1694, 5625, 1831,
+	6455, 2350, 7454, 1856, 3149, 6345, 1543, 6443, 1148, 6802,
+	3186, 6643, 549, 4243, 4365, 493, 4250, 7203, 3017, 1985,
+	1994, 6677, 21, 644, 5486, 6241, 7526, 6270, 1194, 3881, 4224,
+	2899, 7471, 2447, 5858, 7176, 4556, 488, 7601, 1751, 3579,
+	201, 3696, 361, 2638, 5906, 7406, 4561, 7908, 1479, 6262,
+	2507, 2881, 3362, 6286, 86, 5183, 6196, 6782, 2137, 2581,
+	4064, 6012, 351, 2416, 7986, 3669, 338, 1687, 135, 3778, 7081,
+	2329, 2610, 2318, 7493, 8165, 2428, 4023, 7181, 1725, 6179,
+	2731, 1845, 6149, 5042, 6898, 1760, 4442, 5358, 3236, 4134,
+	5567, 5822, 2214, 4603, 6881, 1386, 7040, 7692, 2069, 3387,
+	6583, 259, 2223, 4488, 7441, 7764, 882, 1432, 4119, 5863,
+	8180, 4753, 5050, 6830, 7844, 4177, 6731, 2390, 5262, 4312,
+	2360, 4351, 7638, 345, 1825, 7644, 599, 3817, 439, 6096, 3137,
+	4794, 726, 6524, 2745, 8146, 1717, 7020, 324, 2819, 4302,
+	2452, 4372, 4680, 5596, 2969, 7419, 6387, 5280, 4016, 576,
+	2654, 33, 2556, 7319, 212, 2666, 821, 2836, 7306, 465, 4964,
+	4595, 5079, 2545, 6863, 6072, 3032, 1052, 4293, 1202, 7000,
+	800, 7476, 1528, 5440, 3312, 3550, 7714, 7952, 8190, 2783,
+	5202, 3074, 7544, 1290, 7101, 1440, 7238, 4357, 8002, 2461,
+	4726, 7278, 4841, 2307, 3625, 6969, 7068, 227, 4991, 2598,
+	2628, 7876, 583, 2904, 2794, 814, 2892, 5834, 2690, 7657,
+	6625, 964, 6334, 837, 4055, 1955, 6762, 562, 3057, 1449, 1223,
+	875, 100, 175, 8088, 3540, 5400, 410, 7748, 3431, 5611, 2178,
+	1230, 3484, 113, 7411, 2372, 2080, 7728, 2091, 6505, 7379,
+	6843, 7927, 4586, 3204, 7255, 7513, 2190, 3785, 4528, 2366,
+	5120, 2998, 6558, 4204, 7902, 8174, 1522, 5329, 4473, 63,
+	3896, 5376, 5584, 1976, 8010, 5911, 6650, 1136, 1607, 3196,
+	4804, 6660, 7863, 5252, 5941, 2493, 4619, 1487, 7809, 622,
+	6943, 2801, 5958, 6544, 5734, 4945, 4421, 7586, 8039, 2343,
+	3810, 2991, 1899, 8069, 3826, 5774, 6614, 2643, 5126, 4433,
+	2269, 3249, 3124, 6048, 6225, 7292, 1241, 6024, 4983, 7670,
+	4399, 5452, 4323, 4318, 4932, 4523, 6938, 1943, 250, 7363,
+	532, 6007, 2209, 5620, 4219, 7233, 3052, 1820, 2661, 366,
+	8154, 3458, 5993, 3341, 3605, 2241, 1513, 2400, 3949, 5896,
+	123, 995, 5668, 7168, 4937, 4972, 4574, 5886, 154, 4277, 5294,
+	1320, 7740, 44, 7114, 6688, 7704, 5165, 1456, 5387, 1340,
+	3701, 3004, 665, 6906, 3305, 6255, 4150, 2262, 3990, 1172,
+	6354, 1496, 3972, 1401, 142, 7368, 5268, 5154, 1906, 4786,
+	8131, 2935, 1914, 3506, 3647, 1884, 4717, 6715, 3836, 2921,
+	6296, 3084, 206, 556, 3875, 5816, 1090, 2380, 616, 7162, 8060,
+	4907, 2294, 6370, 7853, 1349, 1096, 537, 2911, 1107, 2679,
+	1618, 1214, 6107, 1305, 1159, 6036, 2112, 7216, 3763, 6217,
+	6278, 3401, 1593, 3584, 6564, 2948, 4157, 910, 5426, 2810,
+	6205, 311, 7567, 5342, 6405, 988, 4005, 4127, 1948, 2396,
+	6003, 7288, 2339, 5248, 5325, 7923, 406, 956, 952, 307, 6032,
+	8056, 3643, 3986, 40, 1756, 7077, 82, 1747, 640, 6439, 7974,
+	7396, 960, 6965, 2779, 6859, 4012, 6520, 2386, 255, 7725,
+	7252, 97, 5608, 1604, 4616, 6555, 3893, 2266, 4980, 5731,
+	1896, 5990, 120, 6935, 4216, 6903, 1493, 151, 7701, 5813,
+	6367, 4783, 6712, 4154, 6402, 1615, 3760, 1744, 6856, 2336,
+	6029, 6589, 6121, 4952, 4110, 3014, 7523, 7451, 3183, 6259,
+	6779, 5855, 3693, 2728, 3233, 3666, 2315, 5047, 2357, 7037,
+	7438, 5593, 30, 436, 1714, 3309, 7541, 462, 1049, 2889, 4052,
+	4723, 4988, 3064, 1263, 6984, 3731, 2408, 4924, 4036, 2048,
+	6910, 3595, 7890, 4410, 849, 3043, 2474, 7612, 6154, 7815,
+	5007, 1179, 399, 525, 3618, 3771, 669, 3851, 3683, 747, 4891,
+	5976, 973, 7297, 3393, 6992, 1702, 4871, 3100, 7791, 3110,
+	754, 3008, 3094, 654, 7429, 2034, 7828, 4704, 2976, 1850, 332,
+	6090, 7272, 4198, 1937, 8125, 5242, 3705, 5135, 3963, 5697,
+	2955, 4663, 6721, 1246, 473, 939, 3531, 5465, 7057, 5524,
+	4776, 507, 7372, 4143, 6486, 4170, 2017, 3491, 1808, 6598,
+	2736, 628, 1011, 7189, 1633, 4631, 514, 7333, 146, 7032, 5002,
+	6085, 1006, 6467, 7088, 5457, 2075, 1131, 4428, 3453, 660,
+	3870, 2943, 77, 1405, 7198, 1474, 6174, 4748, 4675, 5435, 809,
+	6184, 7461, 6472, 2525, 5789, 7387, 693, 3520, 3976, 4095,
+	2720, 1656, 6635, 5368, 3653, 4328, 569, 5479, 4900, 5934,
+	3331, 3213, 8028, 5108, 1500, 2285, 3280, 4647, 4088, 7534,
+	762, 1416, 1730, 6949, 7093, 3997, 5217, 4453, 4853, 5845,
+	6358, 3420, 3470, 3930, 7778, 5225, 267, 7675, 7698, 3757,
+	5605, 1893, 7435, 1046, 4107, 3690, 1176, 744, 3728, 4407,
+	7269, 5694, 4868, 7426, 7186, 6082, 5462, 4167, 2522, 1653,
+	3450, 6171, 3994, 3927, 5931, 4644, 4164, 4641, 1890, 4404,
+	7110, 1168, 1880, 4903, 2108, 7563, 948, 6961, 7744, 4582,
+	4469, 5937, 3806, 1237, 2205, 3945, 2219, 5258, 2741, 572,
+	6068, 5198, 7064, 6330, 1324, 4511, 1144, 5482, 3575, 5179,
+	2325, 4438, 7046, 5307, 7593, 8031, 2040, 2706, 2437, 3350,
+	5298, 423, 5644, 5111, 1664, 6138, 3716, 3633, 5827, 1838,
+	633, 3334, 2756, 3565, 1867, 894, 4281, 1423, 1799, 3216,
+	2515, 4191, 6302, 2274, 6769, 1793, 2859, 3283, 3957, 456,
+	5925, 2714, 158, 5552, 685, 4650, 6379, 608, 2167, 7150, 5572,
+	5947, 1016, 1503, 5539, 5749, 1363, 7224, 5890, 2487, 2773,
+	2288, 5352, 6235, 831, 2648, 1392, 3739, 5633, 765, 7834,
+	1776, 6816, 3858, 4578, 4507, 419, 1419, 5548, 2483, 4503,
+	6394, 4139, 7028, 7194, 4091, 2281, 3416, 740, 3923, 4976,
+	6398, 6775, 7537, 3591, 3847, 3090, 5131, 7314, 7633, 6757,
+	7096, 1189, 277, 5562, 2576, 1344, 1396, 6515, 4000, 7804,
+	2185, 5663, 4394, 3241, 2499, 1638, 1733, 7351, 1577, 5531,
+	391, 5391, 3743, 3158, 6952, 5144, 774, 2617, 6053, 6887,
+	8100, 8046, 4856, 4710, 56, 8139, 6795, 1460, 5637, 1467,
+	5848, 4823, 4765, 6742, 7965, 5363, 6462, 4636, 5220, 4047,
+	6851, 4658, 5971, 5169, 769, 3289, 4456, 4186, 5174, 3842,
+	6230, 1962, 7135, 5804, 3473, 2566, 4260, 1924, 3906, 7708,
+	7838, 2875, 3933, 5420, 6249, 3118, 6499, 4447, 4625, 519,
+	6361, 1565, 1571, 5743, 5192, 6692, 1780, 786, 3423, 5723,
+	4461, 2231, 3254, 4609, 5517, 7556, 270, 2982, 4539, 3374,
+	676, 7118, 6820, 1119, 7678, 5499, 2062, 8081, 5287, 1765,
+	236, 7338, 7781, 6309, 1037, 4832, 702, 48, 3862, 2865, 5228,
+	6571, 3294, 2927, 3129, 5450, 6022, 6046, 4431, 5772, 2989,
+	7584, 6542, 7166, 5894, 2239, 3456, 1818, 5618, 7361, 4521,
+	3783, 3202, 7377, 2078, 3482, 3429, 3538, 873, 620, 2491,
+	6658, 1134, 1974, 61, 8172, 2996, 4125, 5340, 2808, 2946,
+	3399, 7214, 1303, 2677, 2384, 2777, 7972, 80, 3984, 305, 7921,
+	7286, 140, 6352, 4148, 663, 5385, 6686, 1318, 5884, 1094,
+	2292, 614, 3873, 6294, 4715, 1912, 1904, 4062, 6194, 3360,
+	1477, 5904, 199, 486, 2445, 5820, 5356, 5040, 6177, 2426,
+	2608, 133, 7984, 1692, 4810, 6491, 1408, 1585, 792, 3171,
+	2120, 3879, 6239, 6675, 7201, 4241, 6800, 6343, 2348, 1438,
+	3072, 7950, 5438, 6998, 3030, 5077, 7304, 560, 835, 7655, 812,
+	7874, 225, 2305, 2459, 343, 4310, 4175, 4751, 1430, 4486,
+	3385, 1384, 210, 2652, 6385, 4678, 2817, 8144, 4792, 3815,
+	2844, 6430, 1028, 6475, 189, 4546, 3266, 1071, 541, 5576,
+	6922, 2528, 297, 3438, 3225, 6130, 3674, 6666, 2022, 6187,
+	7128, 1786, 5472, 1256, 1100, 5951, 2829, 7464, 5097, 8105,
+	7500, 5779, 888, 3917, 5965, 696, 1708, 5236, 3514, 6165,
+	1353, 1020, 6749, 3523, 5878, 1378, 919, 7009, 7991, 1550,
+	3496, 5792, 5064, 2099, 166, 925, 7857, 1507, 7156, 7390, 15,
+	6892, 5274, 6619, 844, 2029, 5985, 2723, 4083, 7264, 2012,
+	4743, 6374, 5543, 3801, 1659, 5415, 5494, 7799, 4818, 2421,
+	7869, 1813, 3979, 5410, 6698, 292, 5873, 2298, 5753, 1273,
+	4098, 4697, 4861, 4496, 8074, 7770, 5715, 4689, 3656, 4877,
+	6318, 1282, 980, 4911, 1367, 7623, 4331, 6703, 864, 5760,
+	4379, 356, 7488, 6603, 6638, 4288, 2593, 7759, 7015, 8064,
+	7228, 2173, 5371, 6212, 8051, 5160, 3831, 1299, 1314, 7580,
+	3534, 5073, 3381, 482, 3167, 3510, 162, 3262, 5468, 1278,
+	7755, 2008, 288, 4028, 5917, 478, 476, 2006, 3260, 480, 7578,
+	1918, 5556, 5919, 942, 8022, 4770, 4030, 6549, 7447, 432,
+	6551, 4779, 3106, 8121, 4032, 3614, 2939, 689, 4772, 510,
+	4103, 3446, 8024, 4849, 2433, 1863, 944, 7060, 6812, 736,
+	5921, 1359, 8135, 4654, 5558, 5527, 3370, 4828, 1920, 5739,
+	6341, 6673, 3169, 6489, 131, 5038, 484, 3358, 4790, 6383,
+	3383, 4173, 2303, 7653, 5075, 7948, 8170, 6656, 3536, 7375,
+	7359, 2237, 7582, 6044, 1910, 612, 1316, 4146, 7919, 7970,
+	1301, 2806, 4494, 1271, 290, 1811, 7797, 3799, 2010, 5983,
+	5158, 2171, 7757, 6601, 5758, 7621, 1280, 4687, 7498, 2827,
+	5470, 2020, 3223, 6920, 3264, 1026, 5272, 7154, 164, 3494,
+	917, 6747, 3512, 5963, 829, 2771, 1361, 1014, 2165, 683, 5923,
+	2857, 3088, 6773, 738, 7192, 4501, 417, 6814, 5631, 2323,
+	1142, 7062, 2739, 2203, 4467, 946, 1878, 6300, 1797, 1865,
+	631, 3714, 5642, 2435, 7591, 2229, 784, 5741, 517, 3116, 2873,
+	1922, 5802, 2925, 2863, 4830, 7336, 8079, 1117, 3372, 7554,
+	2615, 3156, 5529, 1636, 5661, 6513, 5560, 6755, 3840, 3287,
+	4656, 4634, 6740, 1465, 8137, 8044, 971, 3681, 3616, 5005,
+	2472, 7888, 4034, 6982, 6719, 3961, 8123, 6088, 4702, 652,
+	3108, 1700, 2334, 1613, 4781, 149, 6933, 5729, 6553, 95, 4721,
+	460, 434, 7035, 3664, 5853, 7449, 4950, 265, 3468, 4851, 7091,
+	760, 3278, 8026, 4898, 1888, 5929, 3448, 5460, 4866, 3726,
+	4105, 5603, 7086, 5000, 512, 1009, 1806, 6484, 4774, 3529,
+	3651, 2718, 691, 6470, 5433, 1472, 2941, 4426, 7964, 4764,
+	5847, 5636, 6794, 55, 4855, 8099, 6229, 5173, 4455, 768, 5970,
+	6850, 5219, 6461, 4393, 2184, 3999, 1395, 2575, 276, 7095,
+	7632, 6052, 773, 6951, 3742, 390, 1576, 1732, 2498, 5286,
+	2061, 7677, 6819, 675, 4538, 269, 5516, 3128, 3293, 5227,
+	3861, 701, 1036, 7780, 235, 6498, 6248, 3932, 7837, 3905,
+	4259, 3472, 7134, 3253, 4460, 3422, 1779, 5191, 1570, 6360,
+	4624, 3632, 6137, 5110, 422, 3349, 2705, 8030, 5306, 2273,
+	4190, 3215, 1422, 893, 3564, 3333, 1837, 3944, 1236, 5936,
+	4581, 6960, 7562, 4902, 1167, 4437, 5178, 5481, 4510, 6329,
+	5197, 571, 5257, 6393, 2482, 1418, 4506, 3857, 1775, 764,
+	3738, 5130, 3846, 7536, 6397, 3922, 3415, 4090, 7027, 7149,
+	607, 4649, 5551, 2713, 455, 3282, 1792, 2647, 6234, 2287,
+	2486, 7223, 5748, 1502, 5946, 808, 4674, 6173, 7197, 76, 3869,
+	3452, 1130, 4327, 5367, 1655, 4094, 3519, 7386, 2524, 7460,
+	6597, 3490, 4169, 4142, 506, 5523, 5464, 938, 5456, 6466,
+	6084, 7031, 7332, 4630, 7188, 627, 7425, 5693, 4406, 743,
+	3689, 1045, 1892, 3756, 4403, 4640, 4643, 3926, 6170, 1652,
+	4166, 6081, 1415, 7533, 4646, 2284, 5107, 3212, 5933, 5478,
+	7674, 5224, 3929, 3419, 5844, 4452, 3996, 6948, 2314, 3232,
+	3692, 6778, 3182, 7522, 4109, 6120, 4987, 4051, 1048, 7540,
+	1713, 29, 7437, 2356, 4215, 119, 1895, 4979, 3892, 4615, 5607,
+	7251, 6028, 6855, 3759, 6401, 6711, 6366, 7700, 1492, 2975,
+	7827, 7428, 3093, 753, 7790, 4870, 6991, 1245, 4662, 5696,
+	5134, 5241, 1936, 7271, 331, 7611, 3042, 4409, 3594, 2047,
+	4923, 3730, 1262, 7296, 5975, 746, 3850, 3770, 524, 1178,
+	7814, 7553, 1116, 7335, 2862, 5801, 2872, 516, 783, 8043,
+	1464, 4633, 3286, 6754, 6512, 1635, 3155, 5630, 416, 7191,
+	6772, 2856, 682, 1013, 2770, 7590, 5641, 630, 1796, 1877,
+	4466, 2738, 1141, 5602, 3725, 5459, 5928, 4897, 3277, 7090,
+	3467, 4425, 1471, 6469, 2717, 3528, 6483, 1008, 4999, 1699,
+	651, 6087, 3960, 6981, 7887, 5004, 3680, 4949, 5852, 7034,
+	459, 94, 5728, 148, 1612, 4848, 3445, 509, 688, 3613, 8120,
+	4778, 431, 5738, 4827, 5526, 4653, 1358, 735, 7059, 1862, 287,
+	7754, 5467, 161, 3166, 3380, 3533, 1313, 6548, 4769, 941,
+	5555, 7577, 3259, 475, 5916, 4686, 7620, 6600, 2170, 5982,
+	3798, 1810, 1270, 5962, 6746, 3493, 7153, 1025, 6919, 2019,
+	2826, 7947, 7652, 4172, 6382, 3357, 5037, 6488, 6672, 2805,
+	7969, 4145, 611, 6043, 2236, 7374, 6655, 7008, 1377, 3522,
+	1019, 6164, 5235, 695, 3916, 6618, 6891, 7389, 1506, 924,
+	2098, 5791, 1549, 6129, 3437, 2527, 5575, 1070, 4545, 6474,
+	6429, 5778, 8104, 7463, 5950, 1255, 1785, 6186, 6665, 4378,
+	863, 4330, 1366, 979, 6317, 3655, 5714, 3830, 8050, 5370,
+	7227, 7014, 2592, 6637, 7487, 4817, 5493, 1658, 5542, 4742,
+	7263, 2722, 2028, 8073, 4860, 4097, 5752, 5872, 6697, 3978,
+	7868, 7285, 304, 79, 2776, 2676, 7213, 2945, 5339, 1903, 4714,
+	3872, 2291, 5883, 6685, 662, 6351, 4520, 5617, 3455, 5893,
+	6541, 2988, 4430, 6021, 2995, 60, 1133, 2490, 872, 3428, 2077,
+	3201, 2458, 224, 811, 834, 7303, 3029, 5437, 3071, 3814, 8143,
+	4677, 2651, 1383, 4485, 4750, 4309, 7983, 2607, 6176, 5355,
+	2444, 198, 1476, 6193, 2347, 6799, 7200, 6238, 2119, 791,
+	1407, 4809, 1538, 2147, 3773, 7596, 721, 6578, 3620, 2540,
+	1517, 5395, 527, 8034, 3501, 7735, 401, 1154, 2157, 181, 1181,
+	7049, 4269, 7684, 5009, 4340, 2245, 3747, 7817, 5310, 717,
+	4265, 6156, 68, 2672, 6537, 7299, 2440, 6160, 1066, 975, 4738,
+	3609, 3162, 5978, 3353, 5797, 2852, 4893, 6977, 3178, 3888,
+	749, 2043, 72, 502, 3685, 5103, 3345, 6956, 3853, 2709, 6790,
+	2571, 671, 3901, 4733, 2535, 2050, 5647, 2249, 1081, 4038,
+	5652, 5997, 5148, 4926, 5114, 7996, 593, 2410, 6449, 5511,
+	8094, 3733, 5301, 3751, 1125, 6986, 6115, 3462, 778, 1265,
+	426, 5709, 3911, 3066, 5334, 218, 857, 7614, 3719, 7821, 5687,
+	2476, 2055, 8158, 2621, 3045, 3636, 1555, 377, 851, 6531,
+	5029, 447, 4412, 1667, 5314, 1675, 7892, 8111, 370, 6057,
+	3597, 6141, 3408, 1929, 6912, 4478, 1210, 906, 5244, 636,
+	4273, 3301, 8127, 1086, 4941, 3245, 1939, 3337, 171, 2087,
+	4200, 3192, 4960, 3546, 7274, 5830, 7688, 6826, 6092, 2965,
+	7172, 2503, 334, 1841, 5020, 7140, 1852, 1981, 7325, 383,
+	1248, 1870, 5013, 710, 6723, 2254, 5672, 1642, 4665, 897, 930,
+	6421, 2957, 6872, 2127, 4231, 5699, 2759, 4344, 7935, 3965,
+	7506, 999, 1737, 5137, 3568, 5090, 1967, 3707, 8015, 2468,
+	6929, 756, 1802, 2161, 2199, 3112, 5657, 127, 7355, 7793,
+	3219, 5069, 2002, 3102, 6808, 4079, 5406, 4873, 4284, 185,
+	7124, 1704, 5060, 5900, 1581, 6994, 1426, 5768, 3478, 3395,
+	5381, 2562, 1561, 2978, 6305, 1185, 7347, 4706, 4043, 3953,
+	5535, 7830, 2277, 2104, 6064, 2036, 2752, 3327, 5213, 7431,
+	2518, 7053, 1629, 656, 5785, 2404, 395, 3096, 4194, 1600,
+	5809, 3010, 5589, 3083, 2920, 6714, 1883, 3505, 2934, 4785,
+	5153, 536, 1348, 6369, 4906, 7161, 2379, 5815, 555, 1339,
+	1455, 7703, 7113, 7739, 5293, 153, 4573, 7367, 1400, 1495,
+	1171, 2261, 6254, 6905, 3003, 39, 3642, 6031, 951, 405, 5324,
+	2338, 6002, 254, 6519, 6858, 6964, 7395, 6438, 1746, 7076,
+	1592, 6277, 3762, 2111, 1158, 6106, 1617, 1106, 1947, 4004,
+	6404, 7566, 6204, 5425, 4156, 6563, 8009, 5583, 3895, 4472,
+	1521, 7901, 6557, 5119, 6942, 7808, 4618, 5940, 7862, 4803,
+	1606, 6649, 112, 1229, 5610, 7747, 5399, 8087, 99, 1222, 4527,
+	2189, 7254, 4585, 6842, 6504, 7727, 2371, 2660, 3051, 4218,
+	2208, 531, 249, 6937, 4931, 4936, 5667, 122, 3948, 1512, 3604,
+	5992, 8153, 6613, 3825, 1898, 3809, 8038, 4420, 5733, 5957,
+	4322, 4398, 4982, 1240, 6224, 3123, 2268, 5125, 4301, 323,
+	1716, 2744, 725, 3136, 438, 598, 2665, 7318, 32, 575, 5279,
+	7418, 5595, 4371, 4118, 881, 7440, 2222, 6582, 2068, 7039,
+	6880, 1824, 7637, 2359, 5261, 6730, 7843, 5049, 8179, 582,
+	2627, 4990, 7067, 3624, 4840, 4725, 8001, 3056, 6761, 4054,
+	6333, 6624, 2689, 2891, 2793, 799, 1201, 1051, 6071, 2544,
+	4594, 464, 2835, 7237, 7100, 7543, 5201, 8189, 7713, 3311,
+	1527, 4364, 548, 3185, 1147, 1542, 3148, 7453, 6454, 4223,
+	1193, 7525, 5485, 20, 1993, 3016, 4249, 1333, 106, 4112, 1327,
+	2151, 5505, 4954, 4073, 5624, 281, 6123, 4514, 4387, 3938,
+	6591, 4209, 4022, 8164, 2317, 2328, 3777, 1686, 3668, 2415,
+	2213, 5566, 3235, 4441, 6897, 6148, 2730, 1724, 7405, 2637,
+	3695, 3578, 7600, 4555, 5857, 7470, 6011, 2580, 6781, 5182,
+	6285, 2880, 6261, 7907, 3561, 2702, 5194, 7559, 3412, 1772,
+	5745, 452, 6847, 52, 1573, 273, 1033, 4535, 1567, 4256, 26,
+	7519, 6363, 4612, 1933, 7787, 521, 4920, 7383, 3866, 4627,
+	5520, 1649, 1042, 4449, 3209, 732, 8117, 3256, 3377, 6916,
+	3795, 2233, 5034, 6509, 2869, 4463, 679, 6480, 3274, 5725,
+	7884, 6682, 7210, 3425, 2985, 4482, 3026, 788, 195, 2095,
+	5232, 1782, 4542, 2589, 6314, 6694, 7260, 590, 1078, 3908,
+	1122, 374, 5684, 1926, 1672, 7732, 6575, 4262, 7681, 2849,
+	1063, 2568, 499, 1999, 2196, 3475, 7121, 6061, 7344, 5806,
+	1626, 2084, 3298, 7137, 6823, 6418, 707, 1964, 7932, 4800,
+	7898, 6501, 8084, 3601, 246, 3120, 4417, 2376, 2931, 6251,
+	5290, 6435, 5321, 5422, 6103, 1990, 3145, 3935, 5502, 6145,
+	1683, 2877, 4552, 7415, 3133, 7840, 2065, 2686, 4837, 7710,
+	4591, 1060, 5681, 704, 7341, 5318, 243, 4834, 1680, 4532,
+	1769, 1039, 7784, 3271, 3792, 6311, 3023, 3022, 3791, 7783,
+	1768, 1679, 242, 7340, 5680, 3789, 240, 238, 239, 5679, 241,
+	1767, 3790, 3143, 1681, 3131, 4835, 7896, 244, 2929, 5319,
+	2194, 7342, 3296, 705, 1076, 5682, 6573, 1061, 7208, 3024,
+	5230, 6312, 8115, 3793, 2867, 3272, 7517, 7785, 3864, 1040,
+	2700, 1770, 50, 4533, 7883, 3273, 678, 2868, 5033, 3794, 3376,
+	8116, 7259, 6313, 4541, 5231, 194, 3025, 2984, 7209, 4255,
+	4534, 272, 51, 451, 1771, 7558, 2701, 3208, 1041, 5519, 3865,
+	4919, 7786, 4611, 7518, 6102, 5320, 5289, 2930, 4416, 245,
+	8083, 7897, 4590, 4836, 2064, 3132, 4551, 1682, 5501, 3144,
+	498, 1062, 7680, 6574, 1671, 5683, 1121, 1077, 7931, 706,
+	6822, 3297, 1625, 7343, 7120, 2195, 5211, 1627, 393, 5807,
+	1559, 7345, 5533, 6062, 5404, 7122, 1579, 3476, 6927, 2197,
+	7353, 2000, 4229, 7933, 1735, 1965, 381, 708, 1640, 6419,
+	3544, 6824, 2501, 7138, 904, 3299, 3243, 2085, 445, 1673,
+	6055, 1927, 855, 5685, 2619, 375, 8092, 1123, 776, 3909, 2533,
+	1079, 5146, 591, 3886, 500, 6954, 2569, 6535, 1064, 3160,
+	2850, 179, 7682, 3745, 4263, 2145, 6576, 5393, 7733, 2635,
+	4553, 2578, 2878, 8162, 1684, 5564, 6146, 104, 5503, 279,
+	3936, 546, 3146, 1191, 1991, 1199, 4592, 7098, 7711, 2625,
+	4838, 6759, 2687, 879, 2066, 7635, 7841, 321, 3134, 7316,
+	7416, 3823, 4418, 4396, 3121, 3049, 247, 5665, 3602, 1227,
+	8085, 2187, 6502, 5581, 7899, 7806, 4801, 6275, 6104, 4002,
+	5423, 3640, 5322, 6517, 6436, 1453, 5291, 1398, 6252, 2918,
+	2932, 1346, 2377, 3040, 4921, 5973, 522, 7825, 7788, 4660,
+	1934, 117, 4613, 6853, 6364, 3230, 7520, 4049, 27, 7531, 3210,
+	5222, 4450, 5691, 1043, 4638, 1650, 3488, 5521, 6464, 4628,
+	4672, 3867, 5365, 7384, 605, 453, 6232, 5746, 2480, 1773,
+	3844, 3413, 1234, 7560, 5176, 5195, 6135, 2703, 4188, 3562,
+	6246, 4257, 4458, 1568, 2059, 4536, 3291, 1034, 2182, 274,
+	771, 1574, 4762, 53, 5171, 6848, 2605, 196, 6797, 789, 222,
+	3027, 8141, 4483, 5615, 2986, 58, 3426, 302, 7211, 4712, 6683,
+	5491, 7261, 4858, 6695, 861, 6315, 8048, 2590, 3435, 4543,
+	8102, 1783, 1375, 5233, 6889, 2096, 7650, 5035, 7967, 2234,
+	7618, 3796, 6744, 6917, 7752, 3378, 4767, 3257, 3443, 8118,
+	4825, 733, 649, 7885, 5850, 5726, 3723, 3275, 1469, 6481, 414,
+	680, 5639, 4464, 1114, 2870, 1462, 6510, 7486, 2591, 7226,
+	8049, 5713, 6316, 1365, 862, 7867, 6696, 5751, 4859, 2027,
+	7262, 5541, 5492, 1548, 2097, 1505, 6890, 3915, 5234, 1018,
+	1376, 6664, 1784, 5949, 8103, 6428, 4544, 5574, 3436, 4308,
+	4484, 2650, 8142, 3070, 3028, 833, 223, 4808, 790, 6237, 6798,
+	6192, 197, 5354, 2606, 6350, 6684, 2290, 4713, 5338, 7212,
+	2775, 303, 3200, 3427, 2489, 59, 6020, 2987, 5892, 5616, 4998,
+	6482, 2716, 1470, 3466, 3276, 5927, 3724, 1611, 5727, 458,
+	5851, 3679, 7886, 3959, 650, 3154, 6511, 3285, 1463, 782,
+	2871, 2861, 1115, 1140, 4465, 1795, 5640, 2769, 681, 6771,
+	415, 2825, 6918, 7152, 6745, 1269, 3797, 2169, 7619, 6654,
+	2235, 610, 7968, 6671, 5036, 6381, 7651, 1861, 734, 4652,
+	4826, 430, 8119, 687, 3444, 5915, 3258, 5554, 4768, 1312,
+	3379, 160, 7753, 6080, 1651, 3925, 4639, 3755, 1044, 742,
+	5692, 6947, 4451, 3418, 5223, 5477, 3211, 2283, 7532, 7459,
+	7385, 4093, 5366, 1129, 3868, 7196, 4673, 626, 4629, 7030,
+	6465, 937, 5522, 4141, 3489, 330, 1935, 5133, 4661, 6990,
+	7789, 3092, 7826, 7813, 523, 3849, 5974, 1261, 4922, 3593,
+	3041, 2355, 28, 7539, 4050, 6119, 7521, 6777, 3231, 1491,
+	6365, 6400, 6854, 7250, 4614, 4978, 118, 234, 1035, 3860,
+	3292, 5515, 4537, 6818, 2060, 4623, 1569, 1778, 4459, 7133,
+	4258, 7836, 6247, 6460, 6849, 767, 5172, 8098, 54, 5635, 4763,
+	2497, 1575, 3741, 772, 7631, 275, 1394, 2183, 7026, 3414,
+	6396, 3845, 3737, 1774, 4505, 2481, 5945, 5747, 2485, 6233,
+	1791, 454, 5550, 606, 1836, 3563, 1421, 4189, 5305, 2704, 421,
+	6136, 5256, 5196, 4509, 5177, 1166, 7561, 4580, 1235, 2792,
+	2688, 6332, 6760, 8000, 4839, 7066, 2626, 1526, 7712, 5200,
+	7099, 2834, 4593, 6070, 1200, 4370, 7417, 574, 7317, 597,
+	3135, 2743, 322, 8178, 7842, 5260, 7636, 6879, 2067, 2221,
+	880, 1723, 6147, 4440, 5565, 2414, 1685, 2327, 8163, 7906,
+	2879, 5181, 2579, 7469, 4554, 3577, 2636, 4248, 1992, 5484,
+	1192, 6453, 3147, 1146, 547, 4208, 3937, 4513, 280, 4072,
+	5504, 1326, 105, 7075, 6437, 6963, 6518, 6001, 5323, 950,
+	3641, 6562, 5424, 7565, 4003, 1105, 6105, 2110, 6276, 554,
+	2378, 4905, 1347, 5152, 2933, 1882, 2919, 3002, 6253, 1170,
+	1399, 4572, 5292, 7112, 1454, 8152, 3603, 3947, 5666, 4930,
+	248, 2207, 3050, 5124, 3122, 1239, 4397, 5956, 4419, 3808,
+	3824, 6648, 4802, 5939, 7807, 5118, 7900, 4471, 5582, 2370,
+	6503, 4584, 2188, 1221, 8086, 7746, 1228, 6871, 6420, 896,
+	1641, 2253, 709, 1869, 382, 8014, 1966, 3567, 1736, 7505,
+	7934, 2758, 4230, 3191, 2086, 3336, 3244, 1085, 3300, 635,
+	905, 1980, 7139, 1840, 2502, 2964, 6825, 5829, 3545, 2751,
+	6063, 2276, 5534, 4042, 7346, 6304, 1560, 5588, 5808, 4193,
+	394, 5784, 1628, 2517, 5212, 6807, 2001, 3218, 7354, 5656,
+	2198, 1801, 6928, 5380, 3477, 1425, 1580, 5059, 7123, 4283,
+	5405, 6976, 2851, 3352, 3161, 4737, 1065, 2439, 6536, 3900,
+	2570, 2708, 6955, 5102, 501, 2042, 3887, 1153, 7734, 8033,
+	5394, 2539, 6577, 7595, 2146, 67, 4264, 5309, 3746, 4339,
+	7683, 7048, 180, 6530, 376, 3635, 2620, 2054, 5686, 3718, 856,
+	4477, 1928, 6140, 6056, 8110, 1674, 1666, 446, 6448, 592,
+	5113, 5147, 5651, 1080, 5646, 2534, 5333, 3910, 425, 777,
+	6114, 1124, 5300, 8093
+};
+
+int a_to_i[8192] = {
+	1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 1455,
+	2910, 5820, 2263, 4526, 1779, 3558, 7116, 4663, 449, 898,
+	1796, 3592, 7184, 7567, 7857, 6349, 5173, 3525, 7050, 4795,
+	217, 434, 868, 1736, 3472, 6944, 5103, 625, 1250, 2500, 5000,
+	703, 1406, 2812, 5624, 3679, 7358, 7379, 7177, 7613, 7893,
+	6149, 5541, 3813, 7626, 7739, 6617, 5661, 2453, 4906, 1019,
+	2038, 4076, 8152, 6687, 4497, 1677, 3354, 6708, 4551, 1569,
+	3138, 6276, 5287, 3297, 6594, 5675, 2553, 5106, 587, 1174,
+	2348, 4696, 287, 574, 1148, 2296, 4592, 1615, 3230, 6460,
+	6103, 2561, 5122, 3499, 6998, 4867, 937, 1874, 3748, 7496,
+	7999, 7121, 4621, 437, 874, 1748, 3496, 6992, 4879, 945, 1890,
+	3780, 7560, 7871, 6353, 5133, 3509, 7018, 4987, 857, 1714,
+	3428, 6856, 4159, 1489, 2978, 5956, 2855, 5710, 2355, 4710,
+	355, 710, 1420, 2840, 5680, 2511, 5022, 659, 1318, 2636, 5272,
+	3231, 6462, 6099, 2569, 5138, 3467, 6934, 4995, 681, 1362,
+	2724, 5448, 3903, 7806, 6483, 5897, 3005, 6010, 2907, 5814,
+	2243, 4486, 1699, 3398, 6796, 4279, 1217, 2434, 4868, 935,
+	1870, 3740, 7480, 8159, 6673, 4493, 1717, 3434, 6868, 4103,
+	1441, 2882, 5764, 2215, 4430, 1843, 3686, 7372, 7223, 7617,
+	7725, 6645, 5701, 2341, 4682, 315, 630, 1260, 2520, 5040, 719,
+	1438, 2876, 5752, 2399, 4798, 211, 422, 844, 1688, 3376, 6752,
+	4463, 1905, 3810, 7620, 7719, 6625, 5741, 2421, 4842, 123,
+	246, 492, 984, 1968, 3936, 7872, 6191, 5617, 3661, 7322, 7323,
+	7321, 7325, 7317, 7301, 7333, 7397, 7269, 7525, 8037, 7013,
+	4965, 869, 1738, 3476, 6952, 5119, 593, 1186, 2372, 4744, 191,
+	382, 764, 1528, 3056, 6112, 2671, 5342, 3091, 6182, 5603,
+	3689, 7378, 7179, 7609, 7901, 6165, 5509, 3749, 7498, 7995,
+	7129, 4637, 405, 810, 1620, 3240, 6480, 5903, 2993, 5986,
+	2923, 5846, 2051, 4102, 1443, 2886, 5772, 2231, 4462, 1907,
+	3814, 7628, 7735, 6593, 5677, 2549, 5098, 635, 1270, 2540,
+	5080, 543, 1086, 2172, 4344, 1119, 2238, 4476, 1879, 3758,
+	7516, 7959, 7041, 4781, 245, 490, 980, 1960, 3920, 7840, 6383,
+	5233, 3405, 6810, 4251, 1177, 2354, 4708, 359, 718, 1436,
+	2872, 5744, 2383, 4766, 147, 294, 588, 1176, 2352, 4704, 367,
+	734, 1468, 2936, 5872, 2127, 4254, 1171, 2342, 4684, 311, 622,
+	1244, 2488, 4976, 847, 1694, 3388, 6776, 4447, 1809, 3618,
+	7236, 7463, 8161, 6765, 4469, 1861, 3722, 7444, 8071, 6817,
+	4333, 1141, 2282, 4564, 1543, 3086, 6172, 5527, 3713, 7426,
+	8107, 6905, 4189, 1301, 2602, 5204, 3335, 6670, 4531, 1737,
+	3474, 6948, 5095, 609, 1218, 2436, 4872, 959, 1918, 3836,
+	7672, 7775, 6417, 6029, 2741, 5482, 3963, 7926, 6211, 5417,
+	4093, 8186, 6747, 4377, 1949, 3898, 7796, 6471, 5921, 3053,
+	6106, 2587, 5174, 3523, 7046, 4771, 233, 466, 932, 1864, 3728,
+	7456, 8175, 6769, 4429, 1845, 3690, 7380, 7175, 7585, 7917,
+	6261, 5445, 3877, 7754, 6459, 6105, 2589, 5178, 3547, 7094,
+	4803, 41, 82, 164, 328, 656, 1312, 2624, 5248, 3247, 6494,
+	5907, 2953, 5906, 2955, 5910, 2947, 5894, 2979, 5958, 2851,
+	5702, 2339, 4678, 291, 582, 1164, 2328, 4656, 463, 926, 1852,
+	3704, 7408, 7247, 7473, 8141, 6709, 4549, 1573, 3146, 6292,
+	5255, 3233, 6466, 5931, 3065, 6130, 2635, 5270, 3203, 6406,
+	6051, 2793, 5586, 3595, 7190, 7555, 7849, 6397, 5205, 3333,
+	6666, 4539, 1753, 3506, 7012, 4967, 865, 1730, 3460, 6920,
+	5055, 721, 1442, 2884, 5768, 2239, 4478, 1875, 3750, 7500,
+	7991, 7105, 4653, 501, 1002, 2004, 4008, 8016, 6927, 5041,
+	717, 1434, 2868, 5736, 2431, 4862, 83, 166, 332, 664, 1328,
+	2656, 5312, 3119, 6238, 5395, 3977, 7954, 7051, 4793, 221,
+	442, 884, 1768, 3536, 7072, 4847, 113, 226, 452, 904, 1808,
+	3616, 7232, 7471, 8177, 6733, 4405, 1989, 3978, 7956, 7047,
+	4769, 237, 474, 948, 1896, 3792, 7584, 7919, 6257, 5453, 3893,
+	7786, 6523, 5977, 2845, 5690, 2523, 5046, 707, 1414, 2828,
+	5656, 2463, 4926, 979, 1958, 3916, 7832, 6303, 5265, 3213,
+	6426, 6043, 2713, 5426, 4043, 8086, 6787, 4265, 1277, 2554,
+	5108, 583, 1166, 2332, 4664, 479, 958, 1916, 3832, 7664, 7759,
+	6449, 6093, 2613, 5226, 3451, 6902, 4163, 1321, 2642, 5284,
+	3303, 6606, 5683, 2505, 5010, 651, 1302, 2604, 5208, 3359,
+	6718, 4563, 1545, 3090, 6180, 5607, 3681, 7362, 7211, 7673,
+	7773, 6421, 6021, 2725, 5450, 3899, 7798, 6467, 5929, 3069,
+	6138, 2651, 5302, 3267, 6534, 5795, 2281, 4562, 1547, 3094,
+	6188, 5623, 3649, 7298, 7339, 7417, 7261, 7445, 8069, 6821,
+	4325, 1125, 2250, 4500, 1671, 3342, 6684, 4503, 1665, 3330,
+	6660, 4519, 1761, 3522, 7044, 4775, 225, 450, 900, 1800, 3600,
+	7200, 7663, 7793, 6477, 5941, 3013, 6026, 2747, 5494, 3907,
+	7814, 6307, 5353, 3197, 6394, 5211, 3353, 6706, 4555, 1593,
+	3186, 6372, 5223, 3425, 6850, 4139, 1529, 3058, 6116, 2663,
+	5326, 3123, 6246, 5475, 3945, 7890, 6155, 5561, 3805, 7610,
+	7899, 6169, 5533, 3733, 7466, 8187, 6745, 4381, 1941, 3882,
+	7764, 6407, 6049, 2797, 5594, 3611, 7222, 7619, 7721, 6653,
+	5717, 2309, 4618, 443, 886, 1772, 3544, 7088, 4815, 49, 98,
+	196, 392, 784, 1568, 3136, 6272, 5295, 3313, 6626, 5739, 2425,
+	4850, 75, 150, 300, 600, 1200, 2400, 4800, 47, 94, 188, 376,
+	752, 1504, 3008, 6016, 2735, 5470, 3859, 7718, 6627, 5737,
+	2429, 4858, 91, 182, 364, 728, 1456, 2912, 5824, 2095, 4190,
+	1299, 2598, 5196, 3383, 6766, 4467, 1865, 3730, 7460, 8167,
+	6753, 4461, 1909, 3818, 7636, 7687, 6561, 5869, 2165, 4330,
+	1147, 2294, 4588, 1655, 3310, 6620, 5655, 2433, 4866, 939,
+	1878, 3756, 7512, 7967, 7057, 4749, 181, 362, 724, 1448, 2896,
+	5792, 2287, 4574, 1555, 3110, 6220, 5431, 4033, 8066, 6827,
+	4345, 1117, 2234, 4468, 1863, 3726, 7452, 8087, 6785, 4269,
+	1269, 2538, 5076, 519, 1038, 2076, 4152, 1503, 3006, 6012,
+	2903, 5806, 2291, 4582, 1635, 3270, 6540, 5815, 2241, 4482,
+	1707, 3414, 6828, 4343, 1089, 2178, 4356, 1959, 3918, 7836,
+	6295, 5249, 3245, 6490, 5915, 2969, 5938, 3019, 6038, 2691,
+	5382, 4003, 8006, 6947, 5097, 637, 1274, 2548, 5096, 639,
+	1278, 2556, 5112, 607, 1214, 2428, 4856, 95, 190, 380, 760,
+	1520, 3040, 6080, 2607, 5214, 3347, 6694, 4579, 1641, 3282,
+	6564, 5863, 2145, 4290, 1067, 2134, 4268, 1271, 2542, 5084,
+	535, 1070, 2140, 4280, 1247, 2494, 4988, 855, 1710, 3420,
+	6840, 4319, 1041, 2082, 4164, 1319, 2638, 5276, 3223, 6446,
+	6131, 2633, 5266, 3211, 6422, 6019, 2729, 5458, 3851, 7702,
+	6531, 5801, 2301, 4602, 1627, 3254, 6508, 6007, 2881, 5762,
+	2219, 4438, 1795, 3590, 7180, 7607, 7873, 6189, 5621, 3653,
+	7306, 7355, 7385, 7197, 7573, 7813, 6309, 5349, 3173, 6346,
+	5179, 3545, 7090, 4811, 57, 114, 228, 456, 912, 1824, 3648,
+	7296, 7343, 7409, 7245, 7477, 8133, 6693, 4581, 1637, 3274,
+	6548, 5767, 2209, 4418, 1835, 3670, 7340, 7415, 7233, 7469,
+	8181, 6725, 4389, 2021, 4042, 8084, 6791, 4257, 1261, 2522,
+	5044, 711, 1422, 2844, 5688, 2527, 5054, 723, 1446, 2892,
+	5784, 2207, 4414, 2003, 4006, 8012, 6967, 5057, 557, 1114,
+	2228, 4456, 1919, 3838, 7676, 7767, 6401, 6061, 2805, 5610,
+	3707, 7414, 7235, 7465, 8189, 6741, 4357, 1957, 3914, 7828,
+	6279, 5281, 3309, 6618, 5659, 2457, 4914, 971, 1942, 3884,
+	7768, 6431, 6033, 2701, 5402, 3995, 7990, 7107, 4649, 509,
+	1018, 2036, 4072, 8144, 6671, 4529, 1741, 3482, 6964, 5063,
+	545, 1090, 2180, 4360, 1983, 3966, 7932, 6231, 5377, 4013,
+	8026, 6939, 5017, 669, 1338, 2676, 5352, 3199, 6398, 5203,
+	3337, 6674, 4491, 1721, 3442, 6884, 4199, 1377, 2754, 5508,
+	3751, 7502, 7987, 7113, 4669, 469, 938, 1876, 3752, 7504,
+	7951, 7089, 4813, 53, 106, 212, 424, 848, 1696, 3392, 6784,
+	4271, 1265, 2530, 5060, 551, 1102, 2204, 4408, 2015, 4030,
+	8060, 6999, 4865, 941, 1882, 3764, 7528, 8063, 6993, 4877,
+	949, 1898, 3796, 7592, 7935, 6225, 5389, 4021, 8042, 7035,
+	4953, 797, 1594, 3188, 6376, 5247, 3409, 6818, 4331, 1145,
+	2290, 4580, 1639, 3278, 6556, 5783, 2177, 4354, 1963, 3926,
+	7852, 6391, 5185, 3373, 6746, 4379, 1945, 3890, 7780, 6503,
+	5985, 2925, 5850, 2075, 4150, 1475, 2950, 5900, 2999, 5998,
+	2931, 5862, 2147, 4294, 1059, 2118, 4236, 1207, 2414, 4828,
+	23, 46, 92, 184, 368, 736, 1472, 2944, 5888, 2991, 5982, 2835,
+	5670, 2531, 5062, 547, 1094, 2188, 4376, 1951, 3902, 7804,
+	6487, 5889, 2989, 5978, 2843, 5686, 2499, 4998, 675, 1350,
+	2700, 5400, 3999, 7998, 7123, 4617, 445, 890, 1780, 3560,
+	7120, 4623, 433, 866, 1732, 3464, 6928, 5007, 689, 1378, 2756,
+	5512, 3775, 7550, 8019, 6921, 5053, 725, 1450, 2900, 5800,
+	2303, 4606, 1619, 3238, 6476, 5943, 3009, 6018, 2731, 5462,
+	3843, 7686, 6563, 5865, 2173, 4346, 1115, 2230, 4460, 1911,
+	3822, 7644, 7703, 6529, 5805, 2293, 4586, 1659, 3318, 6636,
+	5751, 2369, 4738, 171, 342, 684, 1368, 2736, 5472, 3951, 7902,
+	6163, 5513, 3773, 7546, 8027, 6937, 5021, 661, 1322, 2644,
+	5288, 3327, 6654, 5715, 2313, 4626, 395, 790, 1580, 3160,
+	6320, 5327, 3121, 6242, 5483, 3961, 7922, 6219, 5433, 4061,
+	8122, 6875, 4121, 1437, 2874, 5748, 2375, 4750, 179, 358, 716,
+	1432, 2864, 5728, 2415, 4830, 19, 38, 76, 152, 304, 608, 1216,
+	2432, 4864, 943, 1886, 3772, 7544, 8031, 6929, 5005, 693,
+	1386, 2772, 5544, 3839, 7678, 7763, 6409, 6077, 2773, 5546,
+	3835, 7670, 7747, 6441, 6141, 2645, 5290, 3323, 6646, 5699,
+	2345, 4690, 267, 534, 1068, 2136, 4272, 1231, 2462, 4924, 983,
+	1966, 3932, 7864, 6367, 5137, 3469, 6938, 5019, 665, 1330,
+	2660, 5320, 3135, 6270, 5459, 3849, 7698, 6539, 5817, 2269,
+	4538, 1755, 3510, 7020, 4983, 833, 1666, 3332, 6664, 4543,
+	1745, 3490, 6980, 4903, 993, 1986, 3972, 7944, 7103, 4817, 13,
+	26, 52, 104, 208, 416, 832, 1664, 3328, 6656, 4527, 1777,
+	3554, 7108, 4647, 481, 962, 1924, 3848, 7696, 6543, 5809,
+	2253, 4506, 1691, 3382, 6764, 4471, 1857, 3714, 7428, 8103,
+	6881, 4205, 1397, 2794, 5588, 3591, 7182, 7603, 7881, 6205,
+	5589, 3589, 7178, 7611, 7897, 6173, 5525, 3717, 7434, 8123,
+	6873, 4125, 1429, 2858, 5716, 2311, 4622, 435, 870, 1740,
+	3480, 6960, 5071, 561, 1122, 2244, 4488, 1727, 3454, 6908,
+	4183, 1281, 2562, 5124, 3495, 6990, 4915, 969, 1938, 3876,
+	7752, 6463, 6097, 2573, 5146, 3483, 6966, 5059, 553, 1106,
+	2212, 4424, 1855, 3710, 7420, 7255, 7425, 8109, 6901, 4165,
+	1317, 2634, 5268, 3207, 6414, 6067, 2761, 5522, 3723, 7446,
+	8067, 6825, 4349, 1109, 2218, 4436, 1799, 3598, 7196, 7575,
+	7809, 6317, 5365, 3141, 6282, 5307, 3289, 6578, 5835, 2105,
+	4210, 1355, 2710, 5420, 4087, 8174, 6771, 4425, 1853, 3706,
+	7412, 7239, 7457, 8173, 6773, 4421, 1829, 3658, 7316, 7303,
+	7329, 7405, 7285, 7493, 7973, 7141, 4709, 357, 714, 1428,
+	2856, 5712, 2319, 4638, 403, 806, 1612, 3224, 6448, 6095,
+	2609, 5218, 3435, 6870, 4099, 1449, 2898, 5796, 2279, 4558,
+	1587, 3174, 6348, 5175, 3521, 7042, 4779, 249, 498, 996, 1992,
+	3984, 7968, 7151, 4721, 333, 666, 1332, 2664, 5328, 3087,
+	6174, 5523, 3721, 7442, 8075, 6841, 4317, 1045, 2090, 4180,
+	1287, 2574, 5148, 3479, 6958, 5107, 585, 1170, 2340, 4680,
+	319, 638, 1276, 2552, 5104, 591, 1182, 2364, 4728, 351, 702,
+	1404, 2808, 5616, 3663, 7326, 7315, 7305, 7357, 7381, 7173,
+	7589, 7909, 6245, 5477, 3941, 7882, 6203, 5593, 3613, 7226,
+	7643, 7705, 6557, 5781, 2181, 4362, 1979, 3958, 7916, 6263,
+	5441, 3885, 7770, 6427, 6041, 2717, 5434, 4059, 8118, 6851,
+	4137, 1533, 3066, 6132, 2631, 5262, 3251, 6502, 5987, 2921,
+	5842, 2059, 4118, 1411, 2822, 5644, 2487, 4974, 883, 1766,
+	3532, 7064, 4767, 145, 290, 580, 1160, 2320, 4640, 495, 990,
+	1980, 3960, 7920, 6223, 5425, 4045, 8090, 6811, 4249, 1181,
+	2362, 4724, 327, 654, 1308, 2616, 5232, 3407, 6814, 4243,
+	1161, 2322, 4644, 487, 974, 1948, 3896, 7792, 6479, 5937,
+	3021, 6042, 2715, 5430, 4035, 8070, 6819, 4329, 1149, 2298,
+	4596, 1607, 3214, 6428, 6039, 2689, 5378, 4011, 8022, 6915,
+	5033, 765, 1530, 3060, 6120, 2687, 5374, 3155, 6310, 5347,
+	3177, 6354, 5131, 3513, 7026, 4939, 825, 1650, 3300, 6600,
+	5695, 2513, 5026, 747, 1494, 2988, 5976, 2847, 5694, 2515,
+	5030, 739, 1478, 2956, 5912, 2975, 5950, 3027, 6054, 2787,
+	5574, 3619, 7238, 7459, 8169, 6781, 4437, 1797, 3594, 7188,
+	7559, 7841, 6381, 5237, 3397, 6794, 4283, 1241, 2482, 4964,
+	871, 1742, 3484, 6968, 5087, 529, 1058, 2116, 4232, 1215,
+	2430, 4860, 87, 174, 348, 696, 1392, 2784, 5568, 3631, 7262,
+	7443, 8073, 6845, 4309, 1029, 2058, 4116, 1415, 2830, 5660,
+	2455, 4910, 1011, 2022, 4044, 8088, 6815, 4241, 1165, 2330,
+	4660, 455, 910, 1820, 3640, 7280, 7503, 7985, 7117, 4661, 453,
+	906, 1812, 3624, 7248, 7439, 8113, 6861, 4149, 1477, 2954,
+	5908, 2951, 5902, 2995, 5990, 2915, 5830, 2083, 4166, 1315,
+	2630, 5260, 3255, 6510, 6003, 2889, 5778, 2187, 4374, 1923,
+	3846, 7692, 6583, 5825, 2093, 4186, 1307, 2614, 5228, 3447,
+	6894, 4211, 1353, 2706, 5412, 4071, 8142, 6707, 4553, 1597,
+	3194, 6388, 5191, 3361, 6722, 4395, 2041, 4082, 8164, 6759,
+	4449, 1901, 3802, 7604, 7879, 6177, 5613, 3701, 7402, 7291,
+	7513, 7965, 7061, 4741, 165, 330, 660, 1320, 2640, 5280, 3311,
+	6622, 5651, 2441, 4882, 907, 1814, 3628, 7256, 7455, 8081,
+	6797, 4277, 1221, 2442, 4884, 903, 1806, 3612, 7224, 7647,
+	7697, 6541, 5813, 2245, 4490, 1723, 3446, 6892, 4215, 1345,
+	2690, 5380, 4007, 8014, 6963, 5065, 573, 1146, 2292, 4584,
+	1663, 3326, 6652, 5719, 2305, 4610, 427, 854, 1708, 3416,
+	6832, 4303, 1073, 2146, 4292, 1063, 2126, 4252, 1175, 2350,
+	4700, 279, 558, 1116, 2232, 4464, 1871, 3742, 7484, 8151,
+	6657, 4525, 1781, 3562, 7124, 4615, 417, 834, 1668, 3336,
+	6672, 4495, 1713, 3426, 6852, 4135, 1505, 3010, 6020, 2727,
+	5454, 3891, 7782, 6499, 5993, 2941, 5882, 2139, 4278, 1219,
+	2438, 4876, 951, 1902, 3804, 7608, 7903, 6161, 5517, 3765,
+	7530, 8059, 7001, 4893, 917, 1834, 3668, 7336, 7423, 7249,
+	7437, 8117, 6853, 4133, 1509, 3018, 6036, 2695, 5390, 4019,
+	8038, 7011, 4969, 893, 1786, 3572, 7144, 4735, 337, 674, 1348,
+	2696, 5392, 3983, 7966, 7059, 4745, 189, 378, 756, 1512, 3024,
+	6048, 2799, 5598, 3603, 7206, 7651, 7785, 6525, 5973, 2821,
+	5642, 2491, 4982, 835, 1670, 3340, 6680, 4511, 1681, 3362,
+	6724, 4391, 2017, 4034, 8068, 6823, 4321, 1133, 2266, 4532,
+	1735, 3470, 6940, 5015, 641, 1282, 2564, 5128, 3519, 7038,
+	4947, 777, 1554, 3108, 6216, 5439, 4049, 8098, 6891, 4217,
+	1373, 2746, 5492, 3911, 7822, 6323, 5321, 3133, 6266, 5467,
+	3865, 7730, 6603, 5689, 2525, 5050, 731, 1462, 2924, 5848,
+	2079, 4158, 1491, 2982, 5964, 2871, 5742, 2419, 4838, 99, 198,
+	396, 792, 1584, 3168, 6336, 5167, 3569, 7138, 4715, 377, 754,
+	1508, 3016, 6032, 2703, 5406, 3987, 7974, 7139, 4713, 381,
+	762, 1524, 3048, 6096, 2575, 5150, 3475, 6950, 5091, 617,
+	1234, 2468, 4936, 831, 1662, 3324, 6648, 5727, 2321, 4642,
+	491, 982, 1964, 3928, 7856, 6351, 5169, 3533, 7066, 4763, 153,
+	306, 612, 1224, 2448, 4896, 1007, 2014, 4028, 8056, 7007,
+	4881, 909, 1818, 3636, 7272, 7551, 8017, 6925, 5045, 709,
+	1418, 2836, 5672, 2559, 5118, 595, 1190, 2380, 4760, 159, 318,
+	636, 1272, 2544, 5088, 623, 1246, 2492, 4984, 863, 1726, 3452,
+	6904, 4191, 1297, 2594, 5188, 3367, 6734, 4403, 1993, 3986,
+	7972, 7143, 4705, 365, 730, 1460, 2920, 5840, 2063, 4126,
+	1427, 2854, 5708, 2359, 4718, 371, 742, 1484, 2968, 5936,
+	3023, 6046, 2707, 5414, 4067, 8134, 6691, 4585, 1661, 3322,
+	6644, 5703, 2337, 4674, 299, 598, 1196, 2392, 4784, 207, 414,
+	828, 1656, 3312, 6624, 5743, 2417, 4834, 107, 214, 428, 856,
+	1712, 3424, 6848, 4143, 1521, 3042, 6084, 2599, 5198, 3379,
+	6758, 4451, 1897, 3794, 7588, 7911, 6241, 5485, 3957, 7914,
+	6267, 5465, 3869, 7738, 6619, 5657, 2461, 4922, 987, 1974,
+	3948, 7896, 6175, 5521, 3725, 7450, 8091, 6809, 4253, 1173,
+	2346, 4692, 263, 526, 1052, 2104, 4208, 1359, 2718, 5436,
+	4055, 8110, 6899, 4169, 1341, 2682, 5364, 3143, 6286, 5299,
+	3273, 6546, 5771, 2233, 4466, 1867, 3734, 7468, 8183, 6721,
+	4397, 2037, 4074, 8148, 6663, 4513, 1773, 3546, 7092, 4807,
+	33, 66, 132, 264, 528, 1056, 2112, 4224, 1199, 2398, 4796,
+	215, 430, 860, 1720, 3440, 6880, 4207, 1393, 2786, 5572, 3623,
+	7246, 7475, 8137, 6717, 4565, 1541, 3082, 6164, 5511, 3745,
+	7490, 7979, 7161, 4701, 277, 554, 1108, 2216, 4432, 1807,
+	3614, 7228, 7639, 7681, 6573, 5877, 2117, 4234, 1211, 2422,
+	4844, 119, 238, 476, 952, 1904, 3808, 7616, 7727, 6641, 5709,
+	2357, 4714, 379, 758, 1516, 3032, 6064, 2767, 5534, 3731,
+	7462, 8163, 6761, 4477, 1877, 3754, 7508, 7943, 7073, 4845,
+	117, 234, 468, 936, 1872, 3744, 7488, 7983, 7153, 4685, 309,
+	618, 1236, 2472, 4944, 783, 1566, 3132, 6264, 5471, 3857,
+	7714, 6635, 5753, 2397, 4794, 219, 438, 876, 1752, 3504, 7008,
+	4975, 881, 1762, 3524, 7048, 4799, 209, 418, 836, 1672, 3344,
+	6688, 4591, 1649, 3298, 6596, 5671, 2529, 5058, 555, 1110,
+	2220, 4440, 1823, 3646, 7292, 7511, 7937, 7085, 4853, 69, 138,
+	276, 552, 1104, 2208, 4416, 1839, 3678, 7356, 7383, 7169,
+	7597, 7925, 6213, 5413, 4069, 8138, 6715, 4569, 1565, 3130,
+	6260, 5447, 3873, 7746, 6443, 6137, 2653, 5306, 3291, 6582,
+	5827, 2089, 4178, 1291, 2582, 5164, 3575, 7150, 4723, 329,
+	658, 1316, 2632, 5264, 3215, 6430, 6035, 2697, 5394, 3979,
+	7958, 7043, 4777, 253, 506, 1012, 2024, 4048, 8096, 6895,
+	4209, 1357, 2714, 5428, 4039, 8078, 6835, 4297, 1085, 2170,
+	4340, 1095, 2190, 4380, 1943, 3886, 7772, 6423, 6017, 2733,
+	5466, 3867, 7734, 6595, 5673, 2557, 5114, 603, 1206, 2412,
+	4824, 31, 62, 124, 248, 496, 992, 1984, 3968, 7936, 7087,
+	4849, 77, 154, 308, 616, 1232, 2464, 4928, 815, 1630, 3260,
+	6520, 5983, 2833, 5666, 2539, 5078, 515, 1030, 2060, 4120,
+	1439, 2878, 5756, 2391, 4782, 243, 486, 972, 1944, 3888, 7776,
+	6511, 6001, 2893, 5786, 2203, 4406, 1987, 3974, 7948, 7095,
+	4801, 45, 90, 180, 360, 720, 1440, 2880, 5760, 2223, 4446,
+	1811, 3622, 7244, 7479, 8129, 6701, 4597, 1605, 3210, 6420,
+	6023, 2721, 5442, 3883, 7766, 6403, 6057, 2813, 5626, 3675,
+	7350, 7363, 7209, 7677, 7765, 6405, 6053, 2789, 5578, 3643,
+	7286, 7491, 7977, 7165, 4693, 261, 522, 1044, 2088, 4176,
+	1295, 2590, 5180, 3543, 7086, 4851, 73, 146, 292, 584, 1168,
+	2336, 4672, 303, 606, 1212, 2424, 4848, 79, 158, 316, 632,
+	1264, 2528, 5056, 559, 1118, 2236, 4472, 1887, 3774, 7548,
+	8023, 6913, 5037, 757, 1514, 3028, 6056, 2815, 5630, 3667,
+	7334, 7395, 7273, 7549, 8021, 6917, 5029, 741, 1482, 2964,
+	5928, 3071, 6142, 2643, 5286, 3299, 6598, 5667, 2537, 5074,
+	523, 1046, 2092, 4184, 1311, 2622, 5244, 3415, 6830, 4339,
+	1097, 2194, 4388, 2023, 4046, 8092, 6807, 4225, 1197, 2394,
+	4788, 199, 398, 796, 1592, 3184, 6368, 5231, 3441, 6882, 4203,
+	1401, 2802, 5604, 3687, 7374, 7219, 7625, 7741, 6613, 5637,
+	2469, 4938, 827, 1654, 3308, 6616, 5663, 2449, 4898, 1003,
+	2006, 4012, 8024, 6943, 5009, 653, 1306, 2612, 5224, 3455,
+	6910, 4179, 1289, 2578, 5156, 3559, 7118, 4659, 457, 914,
+	1828, 3656, 7312, 7311, 7345, 7373, 7221, 7621, 7717, 6629,
+	5733, 2405, 4810, 59, 118, 236, 472, 944, 1888, 3776, 7552,
+	7855, 6385, 5197, 3381, 6762, 4475, 1881, 3762, 7524, 8039,
+	7009, 4973, 885, 1770, 3540, 7080, 4863, 81, 162, 324, 648,
+	1296, 2592, 5184, 3375, 6750, 4371, 1929, 3858, 7716, 6631,
+	5729, 2413, 4826, 27, 54, 108, 216, 432, 864, 1728, 3456,
+	6912, 5039, 753, 1506, 3012, 6024, 2751, 5502, 3923, 7846,
+	6371, 5225, 3453, 6906, 4187, 1305, 2610, 5220, 3431, 6862,
+	4147, 1481, 2962, 5924, 3047, 6094, 2611, 5222, 3427, 6854,
+	4131, 1513, 3026, 6052, 2791, 5582, 3635, 7270, 7523, 8041,
+	7037, 4949, 773, 1546, 3092, 6184, 5631, 3665, 7330, 7403,
+	7289, 7517, 7957, 7045, 4773, 229, 458, 916, 1832, 3664, 7328,
+	7407, 7281, 7501, 7989, 7109, 4645, 485, 970, 1940, 3880,
+	7760, 6415, 6065, 2765, 5530, 3739, 7478, 8131, 6697, 4605,
+	1621, 3242, 6484, 5895, 2977, 5954, 2859, 5718, 2307, 4614,
+	419, 838, 1676, 3352, 6704, 4559, 1585, 3170, 6340, 5159,
+	3553, 7106, 4651, 505, 1010, 2020, 4040, 8080, 6799, 4273,
+	1229, 2458, 4916, 967, 1934, 3868, 7736, 6623, 5649, 2445,
+	4890, 923, 1846, 3692, 7384, 7199, 7569, 7821, 6325, 5317,
+	3109, 6218, 5435, 4057, 8114, 6859, 4153, 1501, 3002, 6004,
+	2887, 5774, 2227, 4454, 1891, 3782, 7564, 7863, 6337, 5165,
+	3573, 7146, 4731, 345, 690, 1380, 2760, 5520, 3727, 7454,
+	8083, 6793, 4285, 1237, 2474, 4948, 775, 1550, 3100, 6200,
+	5599, 3601, 7202, 7659, 7801, 6493, 5909, 2949, 5898, 3003,
+	6006, 2883, 5766, 2211, 4422, 1827, 3654, 7308, 7351, 7361,
+	7213, 7669, 7749, 6437, 6117, 2661, 5322, 3131, 6262, 5443,
+	3881, 7762, 6411, 6073, 2781, 5562, 3803, 7606, 7875, 6185,
+	5629, 3669, 7338, 7419, 7257, 7453, 8085, 6789, 4261, 1253,
+	2506, 5012, 647, 1294, 2588, 5176, 3551, 7102, 4819, 9, 18,
+	36, 72, 144, 288, 576, 1152, 2304, 4608, 431, 862, 1724, 3448,
+	6896, 4175, 1329, 2658, 5316, 3111, 6222, 5427, 4041, 8082,
+	6795, 4281, 1245, 2490, 4980, 839, 1678, 3356, 6712, 4575,
+	1553, 3106, 6212, 5415, 4065, 8130, 6699, 4601, 1629, 3258,
+	6516, 5959, 2849, 5698, 2347, 4694, 259, 518, 1036, 2072,
+	4144, 1487, 2974, 5948, 3031, 6062, 2803, 5606, 3683, 7366,
+	7203, 7657, 7805, 6485, 5893, 2981, 5962, 2875, 5750, 2371,
+	4742, 163, 326, 652, 1304, 2608, 5216, 3439, 6878, 4115, 1417,
+	2834, 5668, 2535, 5070, 563, 1126, 2252, 4504, 1695, 3390,
+	6780, 4439, 1793, 3586, 7172, 7591, 7905, 6253, 5493, 3909,
+	7818, 6331, 5337, 3101, 6202, 5595, 3609, 7218, 7627, 7737,
+	6621, 5653, 2437, 4874, 955, 1910, 3820, 7640, 7711, 6545,
+	5773, 2229, 4458, 1915, 3830, 7660, 7799, 6465, 5933, 3061,
+	6122, 2683, 5366, 3139, 6278, 5283, 3305, 6610, 5643, 2489,
+	4978, 843, 1686, 3372, 6744, 4383, 1937, 3874, 7748, 6439,
+	6113, 2669, 5338, 3099, 6198, 5571, 3625, 7250, 7435, 8121,
+	6877, 4117, 1413, 2826, 5652, 2439, 4878, 947, 1894, 3788,
+	7576, 7839, 6289, 5261, 3253, 6506, 6011, 2905, 5810, 2251,
+	4502, 1667, 3334, 6668, 4535, 1729, 3458, 6916, 5031, 737,
+	1474, 2948, 5896, 3007, 6014, 2899, 5798, 2275, 4550, 1571,
+	3142, 6284, 5303, 3265, 6530, 5803, 2297, 4594, 1611, 3222,
+	6444, 6135, 2625, 5250, 3243, 6486, 5891, 2985, 5970, 2827,
+	5654, 2435, 4870, 931, 1862, 3724, 7448, 8095, 6801, 4237,
+	1205, 2410, 4820, 7, 14, 28, 56, 112, 224, 448, 896, 1792,
+	3584, 7168, 7599, 7921, 6221, 5429, 4037, 8074, 6843, 4313,
+	1053, 2106, 4212, 1351, 2702, 5404, 3991, 7982, 7155, 4681,
+	317, 634, 1268, 2536, 5072, 527, 1054, 2108, 4216, 1375, 2750,
+	5500, 3927, 7854, 6387, 5193, 3389, 6778, 4443, 1817, 3634,
+	7268, 7527, 8033, 7021, 4981, 837, 1674, 3348, 6696, 4607,
+	1617, 3234, 6468, 5927, 3041, 6082, 2603, 5206, 3331, 6662,
+	4515, 1769, 3538, 7076, 4839, 97, 194, 388, 776, 1552, 3104,
+	6208, 5423, 4081, 8162, 6763, 4473, 1885, 3770, 7540, 8007,
+	6945, 5101, 629, 1258, 2516, 5032, 767, 1534, 3068, 6136,
+	2655, 5310, 3283, 6566, 5859, 2153, 4306, 1035, 2070, 4140,
+	1527, 3054, 6108, 2583, 5166, 3571, 7142, 4707, 361, 722,
+	1444, 2888, 5776, 2191, 4382, 1939, 3878, 7756, 6455, 6081,
+	2605, 5210, 3355, 6710, 4547, 1577, 3154, 6308, 5351, 3169,
+	6338, 5163, 3577, 7154, 4683, 313, 626, 1252, 2504, 5008, 655,
+	1310, 2620, 5240, 3423, 6846, 4307, 1033, 2066, 4132, 1511,
+	3022, 6044, 2711, 5422, 4083, 8166, 6755, 4457, 1917, 3834,
+	7668, 7751, 6433, 6125, 2677, 5354, 3195, 6390, 5187, 3369,
+	6738, 4363, 1977, 3954, 7908, 6247, 5473, 3949, 7898, 6171,
+	5529, 3741, 7482, 8155, 6681, 4509, 1685, 3370, 6740, 4359,
+	1953, 3906, 7812, 6311, 5345, 3181, 6362, 5147, 3481, 6962,
+	5067, 569, 1138, 2276, 4552, 1599, 3198, 6396, 5207, 3329,
+	6658, 4523, 1785, 3570, 7140, 4711, 353, 706, 1412, 2824,
+	5648, 2447, 4894, 915, 1830, 3660, 7320, 7327, 7313, 7309,
+	7349, 7365, 7205, 7653, 7781, 6501, 5989, 2917, 5834, 2107,
+	4214, 1347, 2694, 5388, 4023, 8046, 7027, 4937, 829, 1658,
+	3316, 6632, 5759, 2385, 4770, 235, 470, 940, 1880, 3760, 7520,
+	8047, 7025, 4941, 821, 1642, 3284, 6568, 5887, 2129, 4258,
+	1259, 2518, 5036, 759, 1518, 3036, 6072, 2783, 5566, 3795,
+	7590, 7907, 6249, 5501, 3925, 7850, 6395, 5209, 3357, 6714,
+	4571, 1561, 3122, 6244, 5479, 3937, 7874, 6187, 5625, 3677,
+	7354, 7387, 7193, 7581, 7829, 6277, 5285, 3301, 6602, 5691,
+	2521, 5042, 715, 1430, 2860, 5720, 2335, 4670, 467, 934, 1868,
+	3736, 7472, 8143, 6705, 4557, 1589, 3178, 6356, 5127, 3489,
+	6978, 4907, 1017, 2034, 4068, 8136, 6719, 4561, 1549, 3098,
+	6196, 5575, 3617, 7234, 7467, 8185, 6749, 4373, 1925, 3850,
+	7700, 6535, 5793, 2285, 4570, 1563, 3126, 6252, 5495, 3905,
+	7810, 6315, 5369, 3165, 6330, 5339, 3097, 6194, 5579, 3641,
+	7282, 7499, 7993, 7133, 4629, 389, 778, 1556, 3112, 6224,
+	5391, 4017, 8034, 7019, 4985, 861, 1722, 3444, 6888, 4223,
+	1361, 2722, 5444, 3879, 7758, 6451, 6089, 2621, 5242, 3419,
+	6838, 4291, 1065, 2130, 4260, 1255, 2510, 5020, 663, 1326,
+	2652, 5304, 3295, 6590, 5843, 2057, 4114, 1419, 2838, 5676,
+	2551, 5102, 627, 1254, 2508, 5016, 671, 1342, 2684, 5368,
+	3167, 6334, 5331, 3081, 6162, 5515, 3769, 7538, 8011, 6969,
+	5085, 533, 1066, 2132, 4264, 1279, 2558, 5116, 599, 1198,
+	2396, 4792, 223, 446, 892, 1784, 3568, 7136, 4719, 369, 738,
+	1476, 2952, 5904, 2959, 5918, 2963, 5926, 3043, 6086, 2595,
+	5190, 3363, 6726, 4387, 2025, 4050, 8100, 6887, 4193, 1389,
+	2778, 5556, 3783, 7566, 7859, 6345, 5181, 3541, 7082, 4859,
+	89, 178, 356, 712, 1424, 2848, 5696, 2351, 4702, 275, 550,
+	1100, 2200, 4400, 1999, 3998, 7996, 7127, 4609, 429, 858,
+	1716, 3432, 6864, 4111, 1457, 2914, 5828, 2087, 4174, 1331,
+	2662, 5324, 3127, 6254, 5491, 3913, 7826, 6283, 5305, 3293,
+	6586, 5851, 2073, 4146, 1483, 2966, 5932, 3063, 6126, 2675,
+	5350, 3171, 6342, 5155, 3561, 7122, 4619, 441, 882, 1764,
+	3528, 7056, 4751, 177, 354, 708, 1416, 2832, 5664, 2543, 5086,
+	531, 1062, 2124, 4248, 1183, 2366, 4732, 343, 686, 1372, 2744,
+	5488, 3919, 7838, 6291, 5257, 3261, 6522, 5979, 2841, 5682,
+	2507, 5014, 643, 1286, 2572, 5144, 3487, 6974, 5075, 521,
+	1042, 2084, 4168, 1343, 2686, 5372, 3159, 6318, 5363, 3145,
+	6290, 5259, 3257, 6514, 5963, 2873, 5746, 2379, 4758, 131,
+	262, 524, 1048, 2096, 4192, 1391, 2782, 5564, 3799, 7598,
+	7923, 6217, 5437, 4053, 8106, 6907, 4185, 1309, 2618, 5236,
+	3399, 6798, 4275, 1225, 2450, 4900, 999, 1998, 3996, 7992,
+	7135, 4625, 397, 794, 1588, 3176, 6352, 5135, 3505, 7010,
+	4971, 889, 1778, 3556, 7112, 4671, 465, 930, 1860, 3720, 7440,
+	8079, 6833, 4301, 1077, 2154, 4308, 1031, 2062, 4124, 1431,
+	2862, 5724, 2327, 4654, 499, 998, 1996, 3992, 7984, 7119,
+	4657, 461, 922, 1844, 3688, 7376, 7183, 7601, 7885, 6197,
+	5573, 3621, 7242, 7483, 8153, 6685, 4501, 1669, 3338, 6676,
+	4487, 1697, 3394, 6788, 4263, 1249, 2498, 4996, 679, 1358,
+	2716, 5432, 4063, 8126, 6867, 4105, 1469, 2938, 5876, 2119,
+	4238, 1203, 2406, 4812, 55, 110, 220, 440, 880, 1760, 3520,
+	7040, 4783, 241, 482, 964, 1928, 3856, 7712, 6639, 5745, 2381,
+	4762, 155, 310, 620, 1240, 2480, 4960, 879, 1758, 3516, 7032,
+	4959, 785, 1570, 3140, 6280, 5311, 3281, 6562, 5867, 2169,
+	4338, 1099, 2198, 4396, 2039, 4078, 8156, 6679, 4481, 1709,
+	3418, 6836, 4295, 1057, 2114, 4228, 1191, 2382, 4764, 151,
+	302, 604, 1208, 2416, 4832, 111, 222, 444, 888, 1776, 3552,
+	7104, 4655, 497, 994, 1988, 3976, 7952, 7055, 4785, 205, 410,
+	820, 1640, 3280, 6560, 5871, 2161, 4322, 1131, 2262, 4524,
+	1783, 3566, 7132, 4631, 385, 770, 1540, 3080, 6160, 5519,
+	3761, 7522, 8043, 7033, 4957, 789, 1578, 3156, 6312, 5375,
+	3153, 6306, 5355, 3193, 6386, 5195, 3385, 6770, 4427, 1849,
+	3698, 7396, 7271, 7521, 8045, 7029, 4933, 805, 1610, 3220,
+	6440, 6143, 2641, 5282, 3307, 6614, 5635, 2473, 4946, 779,
+	1558, 3116, 6232, 5407, 3985, 7970, 7147, 4729, 349, 698,
+	1396, 2792, 5584, 3599, 7198, 7571, 7817, 6333, 5333, 3077,
+	6154, 5563, 3801, 7602, 7883, 6201, 5597, 3605, 7210, 7675,
+	7769, 6429, 6037, 2693, 5386, 4027, 8054, 6979, 4905, 1021,
+	2042, 4084, 8168, 6783, 4433, 1805, 3610, 7220, 7623, 7713,
+	6637, 5749, 2373, 4746, 187, 374, 748, 1496, 2992, 5984, 2927,
+	5854, 2067, 4134, 1507, 3014, 6028, 2743, 5486, 3955, 7910,
+	6243, 5481, 3965, 7930, 6235, 5401, 3997, 7994, 7131, 4633,
+	413, 826, 1652, 3304, 6608, 5647, 2481, 4962, 875, 1750, 3500,
+	7000, 4895, 913, 1826, 3652, 7304, 7359, 7377, 7181, 7605,
+	7877, 6181, 5605, 3685, 7370, 7227, 7641, 7709, 6549, 5765,
+	2213, 4426, 1851, 3702, 7404, 7287, 7489, 7981, 7157, 4677,
+	293, 586, 1172, 2344, 4688, 271, 542, 1084, 2168, 4336, 1103,
+	2206, 4412, 2007, 4014, 8028, 6935, 4993, 685, 1370, 2740,
+	5480, 3967, 7934, 6227, 5385, 4029, 8058, 7003, 4889, 925,
+	1850, 3700, 7400, 7295, 7505, 7949, 7093, 4805, 37, 74, 148,
+	296, 592, 1184, 2368, 4736, 175, 350, 700, 1400, 2800, 5600,
+	3695, 7390, 7187, 7561, 7869, 6357, 5125, 3493, 6986, 4923,
+	985, 1970, 3940, 7880, 6207, 5585, 3597, 7194, 7579, 7833,
+	6301, 5269, 3205, 6410, 6075, 2777, 5554, 3787, 7574, 7811,
+	6313, 5373, 3157, 6314, 5371, 3161, 6322, 5323, 3129, 6258,
+	5451, 3897, 7794, 6475, 5945, 3037, 6074, 2779, 5558, 3779,
+	7558, 7843, 6377, 5245, 3413, 6826, 4347, 1113, 2226, 4452,
+	1895, 3790, 7580, 7831, 6273, 5293, 3317, 6634, 5755, 2393,
+	4786, 203, 406, 812, 1624, 3248, 6496, 5999, 2929, 5858, 2155,
+	4310, 1027, 2054, 4108, 1463, 2926, 5852, 2071, 4142, 1523,
+	3046, 6092, 2615, 5230, 3443, 6886, 4195, 1385, 2770, 5540,
+	3815, 7630, 7731, 6601, 5693, 2517, 5034, 763, 1526, 3052,
+	6104, 2591, 5182, 3539, 7078, 4835, 105, 210, 420, 840, 1680,
+	3360, 6720, 4399, 2033, 4066, 8132, 6695, 4577, 1645, 3290,
+	6580, 5831, 2081, 4162, 1323, 2646, 5292, 3319, 6638, 5747,
+	2377, 4754, 139, 278, 556, 1112, 2224, 4448, 1903, 3806, 7612,
+	7895, 6145, 5549, 3829, 7658, 7803, 6489, 5917, 2965, 5930,
+	3067, 6134, 2627, 5254, 3235, 6470, 5923, 3049, 6098, 2571,
+	5142, 3459, 6918, 5027, 745, 1490, 2980, 5960, 2879, 5758,
+	2387, 4774, 227, 454, 908, 1816, 3632, 7264, 7535, 8049, 6989,
+	4917, 965, 1930, 3860, 7720, 6655, 5713, 2317, 4634, 411, 822,
+	1644, 3288, 6576, 5839, 2097, 4194, 1387, 2774, 5548, 3831,
+	7662, 7795, 6473, 5949, 3029, 6058, 2811, 5622, 3651, 7302,
+	7331, 7401, 7293, 7509, 7941, 7077, 4837, 101, 202, 404, 808,
+	1616, 3232, 6464, 5935, 3057, 6114, 2667, 5334, 3075, 6150,
+	5539, 3817, 7634, 7691, 6585, 5853, 2069, 4138, 1531, 3062,
+	6124, 2679, 5358, 3187, 6374, 5219, 3433, 6866, 4107, 1465,
+	2930, 5860, 2151, 4302, 1075, 2150, 4300, 1079, 2158, 4316,
+	1047, 2094, 4188, 1303, 2606, 5212, 3351, 6702, 4595, 1609,
+	3218, 6436, 6119, 2657, 5314, 3115, 6230, 5379, 4009, 8018,
+	6923, 5049, 733, 1466, 2932, 5864, 2175, 4350, 1107, 2214,
+	4428, 1847, 3694, 7388, 7191, 7553, 7853, 6389, 5189, 3365,
+	6730, 4411, 2009, 4018, 8036, 7015, 4961, 877, 1754, 3508,
+	7016, 4991, 849, 1698, 3396, 6792, 4287, 1233, 2466, 4932,
+	807, 1614, 3228, 6456, 6111, 2577, 5154, 3563, 7126, 4611,
+	425, 850, 1700, 3400, 6800, 4239, 1201, 2402, 4804, 39, 78,
+	156, 312, 624, 1248, 2496, 4992, 687, 1374, 2748, 5496, 3935,
+	7870, 6355, 5129, 3517, 7034, 4955, 793, 1586, 3172, 6344,
+	5183, 3537, 7074, 4843, 121, 242, 484, 968, 1936, 3872, 7744,
+	6447, 6129, 2637, 5274, 3227, 6454, 6083, 2601, 5202, 3339,
+	6678, 4483, 1705, 3410, 6820, 4327, 1121, 2242, 4484, 1703,
+	3406, 6812, 4247, 1153, 2306, 4612, 423, 846, 1692, 3384,
+	6768, 4431, 1841, 3682, 7364, 7207, 7649, 7789, 6517, 5957,
+	2853, 5706, 2363, 4726, 323, 646, 1292, 2584, 5168, 3535,
+	7070, 4755, 137, 274, 548, 1096, 2192, 4384, 2031, 4062, 8124,
+	6871, 4097, 1453, 2906, 5812, 2247, 4494, 1715, 3430, 6860,
+	4151, 1473, 2946, 5892, 2983, 5966, 2867, 5734, 2403, 4806,
+	35, 70, 140, 280, 560, 1120, 2240, 4480, 1711, 3422, 6844,
+	4311, 1025, 2050, 4100, 1447, 2894, 5788, 2199, 4398, 2035,
+	4070, 8140, 6711, 4545, 1581, 3162, 6324, 5319, 3105, 6210,
+	5419, 4089, 8178, 6731, 4409, 2013, 4026, 8052, 6983, 4897,
+	1005, 2010, 4020, 8040, 7039, 4945, 781, 1562, 3124, 6248,
+	5503, 3921, 7842, 6379, 5241, 3421, 6842, 4315, 1049, 2098,
+	4196, 1383, 2766, 5532, 3735, 7470, 8179, 6729, 4413, 2005,
+	4010, 8020, 6919, 5025, 749, 1498, 2996, 5992, 2943, 5886,
+	2131, 4262, 1251, 2502, 5004, 695, 1390, 2780, 5560, 3807,
+	7614, 7891, 6153, 5565, 3797, 7594, 7931, 6233, 5405, 3989,
+	7978, 7163, 4697, 285, 570, 1140, 2280, 4560, 1551, 3102,
+	6204, 5591, 3585, 7170, 7595, 7929, 6237, 5397, 3973, 7946,
+	7099, 4825, 29, 58, 116, 232, 464, 928, 1856, 3712, 7424,
+	8111, 6897, 4173, 1333, 2666, 5332, 3079, 6158, 5555, 3785,
+	7570, 7819, 6329, 5341, 3093, 6186, 5627, 3673, 7346, 7371,
+	7225, 7645, 7701, 6533, 5797, 2277, 4554, 1595, 3190, 6380,
+	5239, 3393, 6786, 4267, 1273, 2546, 5092, 615, 1230, 2460,
+	4920, 991, 1982, 3964, 7928, 6239, 5393, 3981, 7962, 7067,
+	4761, 157, 314, 628, 1256, 2512, 5024, 751, 1502, 3004, 6008,
+	2911, 5822, 2259, 4518, 1763, 3526, 7052, 4791, 193, 386, 772,
+	1544, 3088, 6176, 5615, 3697, 7394, 7275, 7545, 8029, 6933,
+	4997, 677, 1354, 2708, 5416, 4095, 8190, 6739, 4361, 1981,
+	3962, 7924, 6215, 5409, 4077, 8154, 6683, 4505, 1693, 3386,
+	6772, 4423, 1825, 3650, 7300, 7335, 7393, 7277, 7541, 8005,
+	6949, 5093, 613, 1226, 2452, 4904, 1023, 2046, 4092, 8184,
+	6751, 4369, 1933, 3866, 7732, 6599, 5665, 2541, 5082, 539,
+	1078, 2156, 4312, 1055, 2110, 4220, 1367, 2734, 5468, 3863,
+	7726, 6643, 5705, 2365, 4730, 347, 694, 1388, 2776, 5552,
+	3791, 7582, 7827, 6281, 5309, 3285, 6570, 5883, 2137, 4274,
+	1227, 2454, 4908, 1015, 2030, 4060, 8120, 6879, 4113, 1421,
+	2842, 5684, 2503, 5006, 691, 1382, 2764, 5528, 3743, 7486,
+	8147, 6665, 4541, 1749, 3498, 6996, 4871, 929, 1858, 3716,
+	7432, 8127, 6865, 4109, 1461, 2922, 5844, 2055, 4110, 1459,
+	2918, 5836, 2103, 4206, 1395, 2790, 5580, 3639, 7278, 7539,
+	8009, 6973, 5077, 517, 1034, 2068, 4136, 1535, 3070, 6140,
+	2647, 5294, 3315, 6630, 5731, 2409, 4818, 11, 22, 44, 88, 176,
+	352, 704, 1408, 2816, 5632, 2479, 4958, 787, 1574, 3148, 6296,
+	5279, 3217, 6434, 6123, 2681, 5362, 3147, 6294, 5251, 3241,
+	6482, 5899, 3001, 6002, 2891, 5782, 2179, 4358, 1955, 3910,
+	7820, 6327, 5313, 3117, 6234, 5403, 3993, 7986, 7115, 4665,
+	477, 954, 1908, 3816, 7632, 7695, 6577, 5837, 2101, 4202,
+	1403, 2806, 5612, 3703, 7406, 7283, 7497, 7997, 7125, 4613,
+	421, 842, 1684, 3368, 6736, 4367, 1969, 3938, 7876, 6183,
+	5601, 3693, 7386, 7195, 7577, 7837, 6293, 5253, 3237, 6474,
+	5947, 3033, 6066, 2763, 5526, 3715, 7430, 8099, 6889, 4221,
+	1365, 2730, 5460, 3847, 7694, 6579, 5833, 2109, 4218, 1371,
+	2742, 5484, 3959, 7918, 6259, 5449, 3901, 7802, 6491, 5913,
+	2973, 5946, 3035, 6070, 2755, 5510, 3747, 7494, 7971, 7145,
+	4733, 341, 682, 1364, 2728, 5456, 3855, 7710, 6547, 5769,
+	2237, 4474, 1883, 3766, 7532, 8055, 6977, 4909, 1013, 2026,
+	4052, 8104, 6911, 4177, 1293, 2586, 5172, 3527, 7054, 4787,
+	201, 402, 804, 1608, 3216, 6432, 6127, 2673, 5346, 3179, 6358,
+	5123, 3497, 6994, 4875, 953, 1906, 3812, 7624, 7743, 6609,
+	5645, 2485, 4970, 891, 1782, 3564, 7128, 4639, 401, 802, 1604,
+	3208, 6416, 6031, 2737, 5474, 3947, 7894, 6147, 5545, 3837,
+	7674, 7771, 6425, 6045, 2709, 5418, 4091, 8182, 6723, 4393,
+	2045, 4090, 8180, 6727, 4385, 2029, 4058, 8116, 6855, 4129,
+	1517, 3034, 6068, 2759, 5518, 3763, 7526, 8035, 7017, 4989,
+	853, 1706, 3412, 6824, 4351, 1105, 2210, 4420, 1831, 3662,
+	7324, 7319, 7297, 7341, 7413, 7237, 7461, 8165, 6757, 4453,
+	1893, 3786, 7572, 7815, 6305, 5357, 3189, 6378, 5243, 3417,
+	6834, 4299, 1081, 2162, 4324, 1127, 2254, 4508, 1687, 3374,
+	6748, 4375, 1921, 3842, 7684, 6567, 5857, 2157, 4314, 1051,
+	2102, 4204, 1399, 2798, 5596, 3607, 7214, 7667, 7753, 6461,
+	6101, 2565, 5130, 3515, 7030, 4931, 809, 1618, 3236, 6472,
+	5951, 3025, 6050, 2795, 5590, 3587, 7174, 7587, 7913, 6269,
+	5461, 3845, 7690, 6587, 5849, 2077, 4154, 1499, 2998, 5996,
+	2935, 5870, 2163, 4326, 1123, 2246, 4492, 1719, 3438, 6876,
+	4119, 1409, 2818, 5636, 2471, 4942, 819, 1638, 3276, 6552,
+	5791, 2193, 4386, 2027, 4054, 8108, 6903, 4161, 1325, 2650,
+	5300, 3271, 6542, 5811, 2249, 4498, 1675, 3350, 6700, 4599,
+	1601, 3202, 6404, 6055, 2785, 5570, 3627, 7254, 7427, 8105,
+	6909, 4181, 1285, 2570, 5140, 3463, 6926, 5043, 713, 1426,
+	2852, 5704, 2367, 4734, 339, 678, 1356, 2712, 5424, 4047,
+	8094, 6803, 4233, 1213, 2426, 4852, 71, 142, 284, 568, 1136,
+	2272, 4544, 1583, 3166, 6332, 5335, 3073, 6146, 5547, 3833,
+	7666, 7755, 6457, 6109, 2581, 5162, 3579, 7158, 4675, 297,
+	594, 1188, 2376, 4752, 143, 286, 572, 1144, 2288, 4576, 1647,
+	3294, 6588, 5847, 2049, 4098, 1451, 2902, 5804, 2295, 4590,
+	1651, 3302, 6604, 5687, 2497, 4994, 683, 1366, 2732, 5464,
+	3871, 7742, 6611, 5641, 2493, 4986, 859, 1718, 3436, 6872,
+	4127, 1425, 2850, 5700, 2343, 4686, 307, 614, 1228, 2456,
+	4912, 975, 1950, 3900, 7800, 6495, 5905, 2957, 5914, 2971,
+	5942, 3011, 6022, 2723, 5446, 3875, 7750, 6435, 6121, 2685,
+	5370, 3163, 6326, 5315, 3113, 6226, 5387, 4025, 8050, 6987,
+	4921, 989, 1978, 3956, 7912, 6271, 5457, 3853, 7706, 6555,
+	5785, 2205, 4410, 2011, 4022, 8044, 7031, 4929, 813, 1626,
+	3252, 6504, 6015, 2897, 5794, 2283, 4566, 1539, 3078, 6156,
+	5559, 3777, 7554, 7851, 6393, 5213, 3349, 6698, 4603, 1625,
+	3250, 6500, 5991, 2913, 5826, 2091, 4182, 1283, 2566, 5132,
+	3511, 7022, 4979, 841, 1682, 3364, 6728, 4415, 2001, 4002,
+	8004, 6951, 5089, 621, 1242, 2484, 4968, 895, 1790, 3580,
+	7160, 4703, 273, 546, 1092, 2184, 4368, 1935, 3870, 7740,
+	6615, 5633, 2477, 4954, 795, 1590, 3180, 6360, 5151, 3473,
+	6946, 5099, 633, 1266, 2532, 5064, 575, 1150, 2300, 4600,
+	1631, 3262, 6524, 5975, 2817, 5634, 2475, 4950, 771, 1542,
+	3084, 6168, 5535, 3729, 7458, 8171, 6777, 4445, 1813, 3626,
+	7252, 7431, 8097, 6893, 4213, 1349, 2698, 5396, 3975, 7950,
+	7091, 4809, 61, 122, 244, 488, 976, 1952, 3904, 7808, 6319,
+	5361, 3149, 6298, 5275, 3225, 6450, 6091, 2617, 5234, 3403,
+	6806, 4227, 1193, 2386, 4772, 231, 462, 924, 1848, 3696, 7392,
+	7279, 7537, 8013, 6965, 5061, 549, 1098, 2196, 4392, 2047,
+	4094, 8188, 6743, 4353, 1965, 3930, 7860, 6343, 5153, 3565,
+	7130, 4635, 409, 818, 1636, 3272, 6544, 5775, 2225, 4450,
+	1899, 3798, 7596, 7927, 6209, 5421, 4085, 8170, 6779, 4441,
+	1821, 3642, 7284, 7495, 7969, 7149, 4725, 325, 650, 1300,
+	2600, 5200, 3343, 6686, 4499, 1673, 3346, 6692, 4583, 1633,
+	3266, 6532, 5799, 2273, 4546, 1579, 3158, 6316, 5367, 3137,
+	6274, 5291, 3321, 6642, 5707, 2361, 4722, 331, 662, 1324,
+	2648, 5296, 3279, 6558, 5779, 2185, 4370, 1931, 3862, 7724,
+	6647, 5697, 2349, 4698, 283, 566, 1132, 2264, 4528, 1743,
+	3486, 6972, 5079, 513, 1026, 2052, 4104, 1471, 2942, 5884,
+	2135, 4270, 1267, 2534, 5068, 567, 1134, 2268, 4536, 1759,
+	3518, 7036, 4951, 769, 1538, 3076, 6152, 5567, 3793, 7586,
+	7915, 6265, 5469, 3861, 7722, 6651, 5721, 2333, 4666, 475,
+	950, 1900, 3800, 7600, 7887, 6193, 5581, 3637, 7274, 7547,
+	8025, 6941, 5013, 645, 1290, 2580, 5160, 3583, 7166, 4691,
+	265, 530, 1060, 2120, 4240, 1167, 2334, 4668, 471, 942, 1884,
+	3768, 7536, 8015, 6961, 5069, 565, 1130, 2260, 4520, 1791,
+	3582, 7164, 4695, 257, 514, 1028, 2056, 4112, 1423, 2846,
+	5692, 2519, 5038, 755, 1510, 3020, 6040, 2719, 5438, 4051,
+	8102, 6883, 4201, 1405, 2810, 5620, 3655, 7310, 7347, 7369,
+	7229, 7637, 7685, 6565, 5861, 2149, 4298, 1083, 2166, 4332,
+	1143, 2286, 4572, 1559, 3118, 6236, 5399, 3969, 7938, 7083,
+	4857, 93, 186, 372, 744, 1488, 2976, 5952, 2863, 5726, 2323,
+	4646, 483, 966, 1932, 3864, 7728, 6607, 5681, 2509, 5018, 667,
+	1334, 2668, 5336, 3103, 6206, 5587, 3593, 7186, 7563, 7865,
+	6365, 5141, 3461, 6922, 5051, 729, 1458, 2916, 5832, 2111,
+	4222, 1363, 2726, 5452, 3895, 7790, 6515, 5961, 2877, 5754,
+	2395, 4790, 195, 390, 780, 1560, 3120, 6240, 5487, 3953, 7906,
+	6251, 5497, 3933, 7866, 6363, 5145, 3485, 6970, 5083, 537,
+	1074, 2148, 4296, 1087, 2174, 4348, 1111, 2222, 4444, 1815,
+	3630, 7260, 7447, 8065, 6829, 4341, 1093, 2186, 4372, 1927,
+	3854, 7708, 6551, 5761, 2221, 4442, 1819, 3638, 7276, 7543,
+	8001, 6957, 5109, 581, 1162, 2324, 4648, 511, 1022, 2044,
+	4088, 8176, 6735, 4401, 1997, 3994, 7988, 7111, 4641, 493,
+	986, 1972, 3944, 7888, 6159, 5553, 3789, 7578, 7835, 6297,
+	5277, 3221, 6442, 6139, 2649, 5298, 3275, 6550, 5763, 2217,
+	4434, 1803, 3606, 7212, 7671, 7745, 6445, 6133, 2629, 5258,
+	3259, 6518, 5955, 2857, 5714, 2315, 4630, 387, 774, 1548,
+	3096, 6192, 5583, 3633, 7266, 7531, 8057, 7005, 4885, 901,
+	1802, 3604, 7208, 7679, 7761, 6413, 6069, 2757, 5514, 3771,
+	7542, 8003, 6953, 5117, 597, 1194, 2388, 4776, 255, 510, 1020,
+	2040, 4080, 8160, 6767, 4465, 1869, 3738, 7476, 8135, 6689,
+	4589, 1653, 3306, 6612, 5639, 2465, 4930, 811, 1622, 3244,
+	6488, 5919, 2961, 5922, 3051, 6102, 2563, 5126, 3491, 6982,
+	4899, 1001, 2002, 4004, 8008, 6975, 5073, 525, 1050, 2100,
+	4200, 1407, 2814, 5628, 3671, 7342, 7411, 7241, 7485, 8149,
+	6661, 4517, 1765, 3530, 7060, 4743, 161, 322, 644, 1288, 2576,
+	5152, 3567, 7134, 4627, 393, 786, 1572, 3144, 6288, 5263,
+	3249, 6498, 5995, 2937, 5874, 2123, 4246, 1155, 2310, 4620,
+	439, 878, 1756, 3512, 7024, 4943, 817, 1634, 3268, 6536, 5823,
+	2257, 4514, 1771, 3542, 7084, 4855, 65, 130, 260, 520, 1040,
+	2080, 4160, 1327, 2654, 5308, 3287, 6574, 5875, 2121, 4242,
+	1163, 2326, 4652, 503, 1006, 2012, 4024, 8048, 6991, 4913,
+	973, 1946, 3892, 7784, 6527, 5969, 2829, 5658, 2459, 4918,
+	963, 1926, 3852, 7704, 6559, 5777, 2189, 4378, 1947, 3894,
+	7788, 6519, 5953, 2861, 5722, 2331, 4662, 451, 902, 1804,
+	3608, 7216, 7631, 7729, 6605, 5685, 2501, 5002, 699, 1398,
+	2796, 5592, 3615, 7230, 7635, 7689, 6589, 5845, 2053, 4106,
+	1467, 2934, 5868, 2167, 4334, 1139, 2278, 4556, 1591, 3182,
+	6364, 5143, 3457, 6914, 5035, 761, 1522, 3044, 6088, 2623,
+	5246, 3411, 6822, 4323, 1129, 2258, 4516, 1767, 3534, 7068,
+	4759, 129, 258, 516, 1032, 2064, 4128, 1519, 3038, 6076, 2775,
+	5550, 3827, 7654, 7779, 6505, 6013, 2901, 5802, 2299, 4598,
+	1603, 3206, 6412, 6071, 2753, 5506, 3755, 7510, 7939, 7081,
+	4861, 85, 170, 340, 680, 1360, 2720, 5440, 3887, 7774, 6419,
+	6025, 2749, 5498, 3931, 7862, 6339, 5161, 3581, 7162, 4699,
+	281, 562, 1124, 2248, 4496, 1679, 3358, 6716, 4567, 1537,
+	3074, 6148, 5543, 3809, 7618, 7723, 6649, 5725, 2325, 4650,
+	507, 1014, 2028, 4056, 8112, 6863, 4145, 1485, 2970, 5940,
+	3015, 6030, 2739, 5478, 3939, 7878, 6179, 5609, 3709, 7418,
+	7259, 7449, 8093, 6805, 4229, 1189, 2378, 4756, 135, 270, 540,
+	1080, 2160, 4320, 1135, 2270, 4540, 1751, 3502, 7004, 4887,
+	897, 1794, 3588, 7176, 7615, 7889, 6157, 5557, 3781, 7562,
+	7867, 6361, 5149, 3477, 6954, 5115, 601, 1202, 2404, 4808, 63,
+	126, 252, 504, 1008, 2016, 4032, 8064, 6831, 4337, 1101, 2202,
+	4404, 1991, 3982, 7964, 7063, 4737, 173, 346, 692, 1384, 2768,
+	5536, 3823, 7646, 7699, 6537, 5821, 2261, 4522, 1787, 3574,
+	7148, 4727, 321, 642, 1284, 2568, 5136, 3471, 6942, 5011, 649,
+	1298, 2596, 5192, 3391, 6782, 4435, 1801, 3602, 7204, 7655,
+	7777, 6509, 6005, 2885, 5770, 2235, 4470, 1859, 3718, 7436,
+	8119, 6849, 4141, 1525, 3050, 6100, 2567, 5134, 3507, 7014,
+	4963, 873, 1746, 3492, 6984, 4927, 977, 1954, 3908, 7816,
+	6335, 5329, 3085, 6170, 5531, 3737, 7474, 8139, 6713, 4573,
+	1557, 3114, 6228, 5383, 4001, 8002, 6955, 5113, 605, 1210,
+	2420, 4840, 127, 254, 508, 1016, 2032, 4064, 8128, 6703, 4593,
+	1613, 3226, 6452, 6087, 2593, 5186, 3371, 6742, 4355, 1961,
+	3922, 7844, 6375, 5217, 3437, 6874, 4123, 1433, 2866, 5732,
+	2407, 4814, 51, 102, 204, 408, 816, 1632, 3264, 6528, 5807,
+	2289, 4578, 1643, 3286, 6572, 5879, 2113, 4226, 1195, 2390,
+	4780, 247, 494, 988, 1976, 3952, 7904, 6255, 5489, 3917, 7834,
+	6299, 5273, 3229, 6458, 6107, 2585, 5170, 3531, 7062, 4739,
+	169, 338, 676, 1352, 2704, 5408, 4079, 8158, 6675, 4489, 1725,
+	3450, 6900, 4167, 1313, 2626, 5252, 3239, 6478, 5939, 3017,
+	6034, 2699, 5398, 3971, 7942, 7075, 4841, 125, 250, 500, 1000,
+	2000, 4000, 8000, 6959, 5105, 589, 1178, 2356, 4712, 383, 766,
+	1532, 3064, 6128, 2639, 5278, 3219, 6438, 6115, 2665, 5330,
+	3083, 6166, 5507, 3753, 7506, 7947, 7097, 4829, 21, 42, 84,
+	168, 336, 672, 1344, 2688, 5376, 4015, 8030, 6931, 5001, 701,
+	1402, 2804, 5608, 3711, 7422, 7251, 7433, 8125, 6869, 4101,
+	1445, 2890, 5780, 2183, 4366, 1971, 3942, 7884, 6199, 5569,
+	3629, 7258, 7451, 8089, 6813, 4245, 1157, 2314, 4628, 391,
+	782, 1564, 3128, 6256, 5455, 3889, 7778, 6507, 6009, 2909,
+	5818, 2267, 4534, 1731, 3462, 6924, 5047, 705, 1410, 2820,
+	5640, 2495, 4990, 851, 1702, 3404, 6808, 4255, 1169, 2338,
+	4676, 295, 590, 1180, 2360, 4720, 335, 670, 1340, 2680, 5360,
+	3151, 6302, 5267, 3209, 6418, 6027, 2745, 5490, 3915, 7830,
+	6275, 5289, 3325, 6650, 5723, 2329, 4658, 459, 918, 1836,
+	3672, 7344, 7375, 7217, 7629, 7733, 6597, 5669, 2533, 5066,
+	571, 1142, 2284, 4568, 1567, 3134, 6268, 5463, 3841, 7682,
+	6571, 5881, 2141, 4282, 1243, 2486, 4972, 887, 1774, 3548,
+	7096, 4831, 17, 34, 68, 136, 272, 544, 1088, 2176, 4352, 1967,
+	3934, 7868, 6359, 5121, 3501, 7002, 4891, 921, 1842, 3684,
+	7368, 7231, 7633, 7693, 6581, 5829, 2085, 4170, 1339, 2678,
+	5356, 3191, 6382, 5235, 3401, 6802, 4235, 1209, 2418, 4836,
+	103, 206, 412, 824, 1648, 3296, 6592, 5679, 2545, 5090, 619,
+	1238, 2476, 4952, 799, 1598, 3196, 6392, 5215, 3345, 6690,
+	4587, 1657, 3314, 6628, 5735, 2401, 4802, 43, 86, 172, 344,
+	688, 1376, 2752, 5504, 3759, 7518, 7955, 7049, 4797, 213, 426,
+	852, 1704, 3408, 6816, 4335, 1137, 2274, 4548, 1575, 3150,
+	6300, 5271, 3201, 6402, 6059, 2809, 5618, 3659, 7318, 7299,
+	7337, 7421, 7253, 7429, 8101, 6885, 4197, 1381, 2762, 5524,
+	3719, 7438, 8115, 6857, 4157, 1493, 2986, 5972, 2823, 5646,
+	2483, 4966, 867, 1734, 3468, 6936, 5023, 657, 1314, 2628,
+	5256, 3263, 6526, 5971, 2825, 5650, 2443, 4886, 899, 1798,
+	3596, 7192, 7583, 7825, 6285, 5301, 3269, 6538, 5819, 2265,
+	4530, 1739, 3478, 6956, 5111, 577, 1154, 2308, 4616, 447, 894,
+	1788, 3576, 7152, 4687, 305, 610, 1220, 2440, 4880, 911, 1822,
+	3644, 7288, 7519, 7953, 7053, 4789, 197, 394, 788, 1576, 3152,
+	6304, 5359, 3185, 6370, 5227, 3449, 6898, 4171, 1337, 2674,
+	5348, 3175, 6350, 5171, 3529, 7058, 4747, 185, 370, 740, 1480,
+	2960, 5920, 3055, 6110, 2579, 5158, 3555, 7110, 4643, 489,
+	978, 1956, 3912, 7824, 6287, 5297, 3277, 6554, 5787, 2201,
+	4402, 1995, 3990, 7980, 7159, 4673, 301, 602, 1204, 2408,
+	4816, 15, 30, 60, 120, 240, 480, 960, 1920, 3840, 7680, 6575,
+	5873, 2125, 4250, 1179, 2358, 4716, 375, 750, 1500, 3000,
+	6000, 2895, 5790, 2195, 4390, 2019, 4038, 8076, 6839, 4289,
+	1069, 2138, 4276, 1223, 2446, 4892, 919, 1838, 3676, 7352,
+	7391, 7185, 7565, 7861, 6341, 5157, 3557, 7114, 4667, 473,
+	946, 1892, 3784, 7568, 7823, 6321, 5325, 3125, 6250, 5499,
+	3929, 7858, 6347, 5177, 3549, 7098, 4827, 25, 50, 100, 200,
+	400, 800, 1600, 3200, 6400, 6063, 2801, 5602, 3691, 7382,
+	7171, 7593, 7933, 6229, 5381, 4005, 8010, 6971, 5081, 541,
+	1082, 2164, 4328, 1151, 2302, 4604, 1623, 3246, 6492, 5911,
+	2945, 5890, 2987, 5974, 2819, 5638, 2467, 4934, 803, 1606,
+	3212, 6424, 6047, 2705, 5410, 4075, 8150, 6659, 4521, 1789,
+	3578, 7156, 4679, 289, 578, 1156, 2312, 4624, 399, 798, 1596,
+	3192, 6384, 5199, 3377, 6754, 4459, 1913, 3826, 7652, 7783,
+	6497, 5997, 2933, 5866, 2171, 4342, 1091, 2182, 4364, 1975,
+	3950, 7900, 6167, 5505, 3757, 7514, 7963, 7065, 4765, 149,
+	298, 596, 1192, 2384, 4768, 239, 478, 956, 1912, 3824, 7648,
+	7791, 6513, 5965, 2869, 5738, 2427, 4854, 67, 134, 268, 536,
+	1072, 2144, 4288, 1071, 2142, 4284, 1239, 2478, 4956, 791,
+	1582, 3164, 6328, 5343, 3089, 6178, 5611, 3705, 7410, 7243,
+	7481, 8157, 6677, 4485, 1701, 3402, 6804, 4231, 1185, 2370,
+	4740, 167, 334, 668, 1336, 2672, 5344, 3183, 6366, 5139, 3465,
+	6930, 5003, 697, 1394, 2788, 5576, 3647, 7294, 7507, 7945,
+	7101, 4821, 5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560,
+	5120, 3503, 7006, 4883, 905, 1810, 3620, 7240, 7487, 8145,
+	6669, 4533, 1733, 3466, 6932, 4999, 673, 1346, 2692, 5384,
+	4031, 8062, 6995, 4873, 957, 1914, 3828, 7656, 7807, 6481,
+	5901, 2997, 5994, 2939, 5878, 2115, 4230, 1187, 2374, 4748,
+	183, 366, 732, 1464, 2928, 5856, 2159, 4318, 1043, 2086, 4172,
+	1335, 2670, 5340, 3095, 6190, 5619, 3657, 7314, 7307, 7353,
+	7389, 7189, 7557, 7845, 6373, 5221, 3429, 6858, 4155, 1497,
+	2994, 5988, 2919, 5838, 2099, 4198, 1379, 2758, 5516, 3767,
+	7534, 8051, 6985, 4925, 981, 1962, 3924, 7848, 6399, 5201,
+	3341, 6682, 4507, 1689, 3378, 6756, 4455, 1889, 3778, 7556,
+	7847, 6369, 5229, 3445, 6890, 4219, 1369, 2738, 5476, 3943,
+	7886, 6195, 5577, 3645, 7290, 7515, 7961, 7069, 4757, 133,
+	266, 532, 1064, 2128, 4256, 1263, 2526, 5052, 727, 1454, 2908,
+	5816, 2271, 4542, 1747, 3494, 6988, 4919, 961, 1922, 3844,
+	7688, 6591, 5841, 2061, 4122, 1435, 2870, 5740, 2423, 4846,
+	115, 230, 460, 920, 1840, 3680, 7360, 7215, 7665, 7757, 6453,
+	6085, 2597, 5194, 3387, 6774, 4419, 1833, 3666, 7332, 7399,
+	7265, 7533, 8053, 6981, 4901, 997, 1994, 3988, 7976, 7167,
+	4689, 269, 538, 1076, 2152, 4304, 1039, 2078, 4156, 1495,
+	2990, 5980, 2839, 5678, 2547, 5094, 611, 1222, 2444, 4888,
+	927, 1854, 3708, 7416, 7263, 7441, 8077, 6837, 4293, 1061,
+	2122, 4244, 1159, 2318, 4636, 407, 814, 1628, 3256, 6512,
+	5967, 2865, 5730, 2411, 4822, 3, 6, 12, 24, 48, 96, 192, 384,
+	768, 1536, 3072, 6144, 5551, 3825, 7650, 7787, 6521, 5981,
+	2837, 5674, 2555, 5110, 579, 1158, 2316, 4632, 415, 830, 1660,
+	3320, 6640, 5711, 2353, 4706, 363, 726, 1452, 2904, 5808,
+	2255, 4510, 1683, 3366, 6732, 4407, 1985, 3970, 7940, 7079,
+	4833, 109, 218, 436, 872, 1744, 3488, 6976, 4911, 1009, 2018,
+	4036, 8072, 6847, 4305, 1037, 2074, 4148, 1479, 2958, 5916,
+	2967, 5934, 3059, 6118, 2659, 5318, 3107, 6214, 5411, 4073,
+	8146, 6667, 4537, 1757, 3514, 7028, 4935, 801, 1602, 3204,
+	6408, 6079, 2769, 5538, 3819, 7638, 7683, 6569, 5885, 2133,
+	4266, 1275, 2550, 5100, 631, 1262, 2524, 5048, 735, 1470,
+	2940, 5880, 2143, 4286, 1235, 2470, 4940, 823, 1646, 3292,
+	6584, 5855, 2065, 4130, 1515, 3030, 6060, 2807, 5614, 3699,
+	7398, 7267, 7529, 8061, 6997, 4869, 933, 1866, 3732, 7464,
+	8191, 6737, 4365, 1973, 3946, 7892, 6151, 5537, 3821, 7642,
+	7707, 6553, 5789, 2197, 4394, 2043, 4086, 8172, 6775, 4417,
+	1837, 3674, 7348, 7367, 7201, 7661, 7797, 6469, 5925, 3045,
+	6090, 2619, 5238, 3395, 6790, 4259, 1257, 2514, 5028, 743,
+	1486, 2972, 5944, 3039, 6078, 2771, 5542, 3811, 7622, 7715,
+	6633, 5757, 2389, 4778, 251, 502, 1004, 2008, 4016, 8032,
+	7023, 4977, 845, 1690, 3380, 6760, 4479, 1873, 3746, 7492,
+	7975, 7137, 4717, 373, 746, 1492, 2984, 5968, 2831, 5662,
+	2451, 4902, 995, 1990, 3980, 7960, 7071, 4753, 141, 282, 564,
+	1128, 2256, 4512, 1775, 3550, 7100, 4823, 0
+};
+
+static int err_loc_ply[100][100];
+
+static int
+fix_section(unsigned long offset, void *data, int *syndromes_in)
+{
+	int i, j, elp_sum;
+	int syndromes[9];
+	int Matrix_a[11];
+	int Matrix_b[11];
+	int Matrix_c[12];
+	int Element[7];
+	int alpha;
+	int temp_index;
+	int data_location, rev_location;
+	int result_byte, result_bit;
+	int err_location[20];
+	int err_count;
+	int d_flg;
+	int block_length, data_length;
+
+	/* correct 4 bits in 512 bytes */
+	data_length = 4096;
+	block_length = 8191;
+
+	/*
+	  If there are no errors, just return.
+	*/
+
+	j = 0;
+
+	for (i = 0; i < 8; ++i) {
+		if (0 != syndromes_in[i]) {
+			j = 1;
+			break;
+		}
+	}
+
+	if (0 == j)
+		return 0;
+
+	/*
+	  Decode.
+	*/
+
+	memcpy((void *)syndromes, (void *)syndromes_in, sizeof(int) * 9);
+	d_flg = 0;
+
+	/* initialise table entries */
+	for (i = 0; i < 8; i++)
+		syndromes[i] = i_to_a[syndromes[i]];
+
+	Matrix_c[0] = 0;
+	Matrix_c[1] = syndromes[0];
+	err_loc_ply[0][0] = 1;
+	err_loc_ply[1][0] = 1;
+	for (i = 1; i < 8; i++) {
+		err_loc_ply[0][i] = 0;
+		err_loc_ply[1][i] = 0;
+	}
+	Matrix_a[0] = 0;
+	Matrix_a[1] = 0;
+	Matrix_b[0] = -1;
+	Matrix_b[1] = 0;
+	alpha = -1;
+
+	do {
+		/* skip even loops */
+		alpha += 2;
+		if (Matrix_c[alpha] != -1) {
+			temp_index = alpha - 2;
+			if (temp_index < 0)
+				temp_index = 0;
+			while ((Matrix_c[temp_index] == -1) && (temp_index > 0))
+				temp_index = temp_index - 2;
+			if (temp_index < 0)
+				temp_index = 0;
+
+			if (temp_index > 0) {
+				j = temp_index;
+				do {
+					j = j - 2;
+					if (j < 0)
+						j = 0;
+					if ((Matrix_c[j] != -1) &&
+					   (Matrix_b[temp_index] < Matrix_b[j]))
+						temp_index = j;
+				} while (j > 0);
+			}
+
+			if (Matrix_a[alpha] > Matrix_a[temp_index] +
+				alpha - temp_index)
+				Matrix_a[alpha + 2] = Matrix_a[alpha];
+			else
+				Matrix_a[alpha + 2] = Matrix_a[temp_index] +
+					 alpha - temp_index;
+
+			for (i = 0; i < 8; ++i)
+				err_loc_ply[alpha + 2][i] = 0;
+
+			for (i = 0; i <= Matrix_a[temp_index]; i++) {
+				if (err_loc_ply[temp_index][i] != 0)
+					err_loc_ply[alpha + 2][i +
+						alpha - temp_index] =
+					a_to_i[(Matrix_c[alpha] +
+						block_length -
+						Matrix_c[temp_index] +
+						i_to_a[err_loc_ply[temp_index]
+						[i]]) % block_length];
+			}
+
+			for (i = 0; i <= Matrix_a[alpha]; i++)
+				err_loc_ply[alpha + 2][i] ^=
+					err_loc_ply[alpha][i];
+		} else {
+			Matrix_a[alpha + 2] = Matrix_a[alpha];
+
+			for (i = 0; i <= Matrix_a[alpha]; i++)
+				err_loc_ply[alpha + 2][i] =
+					err_loc_ply[alpha][i];
+		}
+
+		Matrix_b[alpha + 2] = alpha+1 - Matrix_a[alpha + 2];
+
+		/* Form (alpha+2)th discrepancy. */
+		if (alpha < 8) {
+			if (syndromes[alpha + 1] != -1)
+				Matrix_c[alpha + 2] =
+					a_to_i[syndromes[alpha + 1]];
+			else
+				Matrix_c[alpha + 2] = 0;
+
+			for (i = 1; i <= Matrix_a[alpha + 2]; i++) {
+				if ((syndromes[alpha + 1 - i] != -1) &&
+					(err_loc_ply[alpha + 2][i] != 0))
+					Matrix_c[alpha + 2] ^=
+						a_to_i[(syndromes[alpha + 1 - i]
+						+ i_to_a[err_loc_ply[alpha + 2]
+						[i]]) % block_length];
+			}
+			Matrix_c[alpha + 2] = i_to_a[Matrix_c[alpha + 2]];
+		}
+	} while ((alpha < 7) && (Matrix_a[alpha + 2] <= 4));
+
+	alpha = alpha+2;
+	Matrix_a[7] = Matrix_a[alpha];
+	if (Matrix_a[7] <= 4) {
+		for (i = 1; i <= Matrix_a[7]; i++)
+			Element[i] = i_to_a[err_loc_ply[alpha][i]];
+
+		err_count = 0;
+		for (i = 1; i <= block_length; i++) {
+			elp_sum = 1;
+			for (j = 1; j <= Matrix_a[7]; j++)
+				if (Element[j] != -1) {
+					Element[j] = (Element[j] + j) %
+						block_length;
+					elp_sum ^= a_to_i[Element[j]];
+				}
+
+			if (!elp_sum) {
+				err_location[err_count] = block_length - i;
+				err_count++;
+			}
+		}
+
+		if (err_count == Matrix_a[7])
+			d_flg = 1;
+	}
+
+	if (d_flg == 0)
+		return -1;
+	else {
+		for (i = 0; i < err_count; i++) {
+			if (err_location[i] >= 52)
+				data_location = err_location[i] - 52;
+			else
+				data_location = err_location[i] + data_length;
+
+			if (data_location <= 4095) {
+				rev_location = 4095 - data_location;
+				result_bit = rev_location % 8;
+				result_byte = (rev_location - result_bit) / 8;
+
+				pr_notice("Corrected ECC Error: offset 0x%lx byte 0x%x bit %d\n",
+					  offset, result_byte, result_bit);
+
+				result_byte =
+					(result_byte & 0xfffffffc) |
+					((result_byte & 0x3) ^ 0x3);
+				*((unsigned char *)(data +
+						    result_byte)) ^=
+					(1 << result_bit);
+			} else {
+				rev_location = 4147 - data_location;
+				result_bit = rev_location % 8;
+				result_byte = (rev_location - result_bit) / 8;
+				pr_err("BCH byte = %d, bit = %d\n",
+				       result_byte, result_bit);
+			}
+		}
+
+		if (0 != err_count)
+			return 1;
+		else
+			return 0;
+	}
+}
+
+/*
+  ------------------------------------------------------------------------------
+  report_ecc_errors_ep501g1
+*/
+
+static int
+report_ecc_errors_ep501g1(struct mtd_info *mtd, struct nand_chip *chip,
+			  uint8_t *buffer, int page)
+{
+	unsigned long ecc_status;
+	int i;
+
+	for (i = 0; i < (mtd->writesize / 1024); ++i) {
+		ecc_status = readl(chip->IO_ADDR_R +
+				   EP501G1_NAND_1BIT_ECC0_STATUS + (i * 4));
+
+		switch (ecc_status & (3 << 12)) {
+		case 01:
+			pr_err("Correctable ECC Error: %d:0x%lx\n",
+			       i, ecc_status);
+			break;
+		case 02:
+			pr_err("Uncorrectable ECC Error: %d:0x%lx\n",
+			       i, ecc_status);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  report_ecc_errors_ep501g3
+*/
+
+static int
+report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
+			  uint8_t *buffer, int page)
+{
+	unsigned long bch_status;
+	int rc = 0;
+	unsigned long value;
+	int i;
+	int is_blank = 1;
+	uint8_t *data = buffer;
+	int section;
+	int syndrome;
+	unsigned long syndromes[8][8];
+
+	/* Verify 4-bit mode in the EP501G3 case. */
+	value = (READL(chip->IO_ADDR_R + EP501_NAND_CONFIG_REG) & 0x1800) >> 11;
+
+	if (1 != value) {
+		pr_err("Only 4-Bit ECC is supported.\n");
+		rc = -1;
+		goto report_ecc_errors_ep501g3_end;
+	}
+
+	/* If there are no errors, return. */
+	bch_status = READL(chip->IO_ADDR_R + EP501G1_NAND_BCH_STATUS);
+
+	if (0 == bch_status)
+		goto report_ecc_errors_ep501g3_end;
+
+	switch (mtd->writesize) {
+	case 512:
+		bch_status &= 0x1;
+		break;
+	case 2048:
+		bch_status &= 0xf;
+		break;
+	case 4096:
+		bch_status &= 0xff;
+		break;
+	default:
+		pr_err("Unexpected Page Size!\n");
+		rc = -1;
+		goto report_ecc_errors_ep501g3_end;
+	}
+
+	/* Ignore fully erased blocks. */
+	if (NULL != data) {
+		for (i = 0; i < mtd->writesize; ++i) {
+			if (0xff != *data++) {
+				is_blank = 0;
+				break;
+			}
+		}
+	}
+
+	if (0 != is_blank)
+		goto report_ecc_errors_ep501g3_end;
+
+	/* Read the syndrome registers and split them into syndromes. */
+	for (section = 0; section < 8; ++section) {
+		unsigned long address;
+		unsigned long value;
+
+		address = EP501G1_NAND_SYN_R12_S0 + (section * 0x10);
+
+		for (syndrome = 0; syndrome < ((mtd->writesize / 512) * 2);
+		     syndrome += 2, address += 4) {
+			value = READL(chip->IO_ADDR_R + address);
+			syndromes[section][syndrome] =
+				(value & 0x1fff);
+			syndromes[section][syndrome + 1] =
+				((value & 0x1fff0000) >> 16);
+		}
+	}
+
+#ifdef NOT_USED
+	/* Debug output (BCH status register and syndromes). */
+	pr_info("BCH Status Register: 0x%02lx\n", bch_status);
+
+	for (section = 0; section < 8; ++section) {
+		pr_info("Syndromes, Section %d: ", section);
+
+		for (syndrome = 0; syndrome < 8; ++syndrome)
+			pr_info("0x%04lx ",
+
+		pr_info("\n");
+	}
+#endif
+
+	for (i = 0; i < 4; ++i) {
+		if ((1 << i) == (bch_status & (1 << i))) {
+			rc = fix_section(((page * mtd->writesize) + (512 * i)),
+					 (void *)(buffer + (512 * i)),
+					 (int *)&syndromes[i]);
+
+			if (-1 == rc)
+				pr_err("Uncorrectable ECC Error: Page %d\n",
+				       page);
+		}
+	}
+
+ report_ecc_errors_ep501g3_end:
+
+	return rc;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  report_ecc_errors
+*/
+
+static int
+report_ecc_errors(struct mtd_info *mtd, struct nand_chip *chip,
+		  uint8_t *buffer, int page)
+{
+	int rc = 0;
+
+	switch (axxia_nand_type) {
+	case AXXIA_NAND_EP501:
+		rc = report_ecc_errors_ep501(mtd, chip, buffer, page);
+		break;
+	case AXXIA_NAND_EP501G1:
+		rc = report_ecc_errors_ep501g1(mtd, chip, buffer, page);
+		break;
+	case AXXIA_NAND_EP501G3:
+		rc = report_ecc_errors_ep501g3(mtd, chip, buffer, page);
+		break;
+	default:
+		rc = -1;
+		break;
+	}
+
+	return rc;
+}
+
+
+/**
+ * nand_read_page_hwecc - hardware ecc based page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ *
+ * Not for syndrome calculating ecc controllers which need a special oob layout
+ */
+
+static int
+axxia_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+			 uint8_t *buf, int oob_required, int page)
+{
+	int rc;
+	/*int page = 0;*/
+
+	/* Read the current page number and save it. */
+	/*page = READL(chip->IO_ADDR_R + NAND_INDEX_REG) >> 12;*/
+
+	/* read the page */
+	chip->read_buf(mtd, buf, mtd->writesize);
+
+	/* read oob data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* start ECC calculations */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* Read the ECC Status and see if there were any errors */
+	rc = report_ecc_errors(mtd, chip, buf, page);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
+	return rc;
+}
+
+/**
+ * axxia_nand_write_page_hwecc - hardware ecc based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ */
+static int
+axxia_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+			   const uint8_t *buf, int oob_required)
+{
+	/* write the page data */
+	chip->write_buf(mtd, buf, mtd->writesize);
+
+	/*
+	 * Write the oob data. Last 12 bytes are used by HW ECC.
+	 * Do not touch them.
+	 */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize - chip->ecc.bytes);
+	return 0;
+}
+
+/**
+ * axxia_nand_write_page - [REPLACEABLE] write one page
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip descriptor
+ * @buf:	the data to write
+ * @page:	page number to write
+ * @cached:	cached programming
+ * @raw:	use _raw version of write_page
+ */
+
+static int
+axxia_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		    uint32_t offset, int data_len, const uint8_t *buf,
+		    int oob_required, int page, int cached, int raw)
+{
+	int status;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+	if (unlikely(raw))
+		chip->ecc.write_page_raw(mtd, chip, buf, 0);
+	else
+		chip->ecc.write_page(mtd, chip, buf, 0);
+
+	/* calculate ECC */
+	status = chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
+
+	/*
+	 * See if operation failed and additional status checks are
+	 * available
+	 */
+	if (status & NAND_STATUS_FAIL) {
+		pr_err("ERROR: Page write failed for page 0x%x\n",
+		       page);
+
+		if (chip->errstat)
+			status = chip->errstat(mtd, chip, FL_WRITING, status,
+					       page);
+
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+/**
+ * axxia_nand_read_oob_std - [REPLACABLE] the most common OOB data read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to read
+ * @sndcmd:	flag whether to issue read command or not
+ */
+
+static int
+axxia_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		  int page)
+{
+	int rc;
+
+	/* send command to read oob */
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	/* read oob data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* start ECC calculations */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* Read the ECC Status and see if there were any errors */
+	rc = report_ecc_errors(mtd, chip, NULL, page);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
+
+	return 0;
+}
+
+/**
+ * axxia_nand_write_oob_std - [REPLACABLE] the most common OOB data write
+ *			      function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to write
+ */
+
+static int
+axxia_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
+{
+	/* start OOB write */
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/*
+	 * Write the oob data. Last 12 bytes are used by HW ECC.
+	 * Do not touch them.
+	 */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize - chip->ecc.bytes);
+
+	/* calculate ECC */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
+
+	return (chip->dev_ready(mtd) & NAND_STATUS_FAIL) ? -EIO : 0;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Public
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ------------------------------------------------------------------------------
+  axxia_nand_set_config
+*/
+
+int
+axxia_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	unsigned long config = 0;
+	unsigned long mbits;
+
+	mbits = ((chip->chipsize >> 20) * 8);
+
+	if (AXXIA_NAND_EP501 == axxia_nand_type) {
+		/* The EP501 only supports 512 and 2k page sizes. */
+		if (512 != mtd->writesize &&
+		    2048 != mtd->writesize)
+			return -1;
+
+		while (64 < mbits) {
+			++config; /* 0b000=64Mbit, 0b001=128Mbit, etc. */
+			mbits >>= 1;
+		}
+
+		if (512 < mtd->writesize)
+			config |= 0x100; /* large block */
+
+		config |= 0x200;	/* not write protected */
+		chip->ecc.layout = &axxia_2k_1bit_ecclayout;
+		chip->ecc.size = mtd->writesize;
+		chip->ecc.bytes = chip->ecc.layout->eccbytes;
+		chip->ecc.strength = 1;
+	} else if (AXXIA_NAND_EP501G1 == axxia_nand_type) {
+		/* The EP501G1 only supports 512, 2k, and 4k page sizes, */
+		if (512 != mtd->writesize &&
+		    2048 != mtd->writesize &&
+		    4096 != mtd->writesize)
+			return -1;
+
+		/* and device sizes as follows. */
+		if (512 == mtd->writesize) {
+			switch (mbits) {
+			case 64:
+				break;
+			case 128:
+				config |= 1;
+				break;
+			case 256:
+				config |= 2;
+				break;
+			case 512:
+				config |= 3;
+				break;
+			case 1024:
+				config |= 4;
+				break;
+			case 2048:
+				config |= 5;
+				break;
+			case 4096:
+				config |= 6;
+				break;
+			case 8192:
+				config |= 7;
+				 break;
+			default:
+				return -1;
+			}
+		} else {
+			switch (mbits) {
+			case 512:
+				config |= 3;
+				break;
+			case 1024:
+				config |= 4;
+				break;
+			case 2048:
+				config |= 5;
+				break;
+			case 4096:
+				config |= 6;
+				break;
+			case 8192:
+				config |= 7;
+				break;
+			case 16384:
+				break;
+			case 32768:
+				config |= 1;
+				break;
+			case 65536:
+				config |= 2;
+				break;
+			default:
+				return -1;
+			}
+		}
+
+		switch (mtd->writesize) {
+		case 512:
+			break;
+		case 2048:
+			config |= 0x1 << 8;
+			chip->ecc.layout = &axxia_2k_4bit_ecclayout;
+			break;
+		case 4096:
+			config |= 0x2 << 8;
+			chip->ecc.layout = &axxia_4k_4bit_ecclayout;
+			break;
+		default:
+			return -1;
+		}
+
+		config |= 1 << 10; /* not write protected */
+
+		config |= 1 << 11; /* 4 bit ECC */
+
+		if (512 < mtd->writesize)
+			config |= 1 << 12; /* 3 cycle row address */
+
+		chip->ecc.size = mtd->writesize;
+
+		if (mtd->oobsize == 224)
+			chip->ecc.bytes = 224 - chip->ecc.layout->eccbytes;
+		else
+			chip->ecc.bytes = chip->ecc.layout->eccbytes;
+
+		chip->ecc.strength = 4;
+
+	} else if (AXXIA_NAND_EP501G3 == axxia_nand_type) {
+		/* The EP501G3 only supports 2k, 4k, and 8k page sizes, */
+		if (2048 != mtd->writesize &&
+		    4096 != mtd->writesize &&
+		    8192 != mtd->writesize)
+			return -1;
+
+		/* and device sizes as follows. */
+		switch (mbits) {
+		case 512:
+			config |= 3;
+			break;
+		case 1024:
+			config |= 4;
+			break;
+		case 2048:
+			config |= 5;
+			break;
+		case 4096:
+			config |= 6;
+			break;
+		case 8192:
+			config |= 7;
+			break;
+		case 16384:
+			break;
+		case 32768:
+			config |= 1;
+			break;
+		case 65536:
+			config |= 2;
+			break;
+		default:
+			pr_err("Invalid Device Size: 0x%lx\n", mbits);
+			return -1;
+		}
+
+		switch (mtd->writesize) {
+		case 2048:
+			config |= 0x1 << 8;
+			chip->ecc.layout = &axxia_2k_4bit_ecclayout;
+			break;
+		case 4096:
+			config |= 0x2 << 8;
+			chip->ecc.layout = &axxia_4k_4bit_ecclayout;
+			break;
+#ifdef NOT_USED
+		case 8192:
+			config |= 0x3 << 8;
+			chip->ecc.layout = &axxia_8k_4bit_ecclayout;
+			break;
+#endif
+		default:
+			return -1;
+		}
+
+		config |= 1 << 10; /* not write protected */
+		config |= 1 << 13; /* 3 cycle row address */
+
+		/*
+		  2K/4bit  - 32 bytes (8192)
+		  2K/8bit  - 64 bytes (16384)
+		  2K/12bit - 80 bytes (24576)
+		  ...
+		  8K/12bit - 320 bytes (98304)
+		*/
+
+		if (mtd->oobsize < chip->ecc.layout->eccbytes) {
+			pr_err("ECC requires %d bytes, only %d are available\n",
+			       chip->ecc.layout->eccbytes, mtd->oobsize);
+			return -1;
+		}
+
+		config |= 1 << 11; /* 4 bit ECC */
+		mtd->oobavail = mtd->oobsize - chip->ecc.layout->eccbytes;
+		mtd->oobavail -= (mtd->oobavail % 4);
+		config |= (chip->ecc.layout->eccbytes / 4) << 16;
+		chip->ecc.size = mtd->writesize;
+		chip->ecc.bytes = chip->ecc.layout->eccbytes;
+		chip->ecc.strength = 4;
+	} else {
+		return -1;
+	}
+
+	WRITEL(config, chip->IO_ADDR_W + EP501_NAND_CONFIG_REG);
+
+	return 0;
+}
+
+static uint8_t
+axxia_nand_read_byte(struct mtd_info *mtd)
+{
+	struct axxia_nand_private *priv = &axxia_nand_private;
+	struct nand_chip *chip = mtd->priv;
+
+	if (priv->cur >= 0) {
+		WARN_ON(priv->cur >= MAX_READ_BUF);
+		return priv->buf[priv->cur++];
+	} else
+		return readb(chip->IO_ADDR_R);
+}
+
+static int axxia_nand_errstat
+	(struct mtd_info *mtd, struct nand_chip *chip,
+	int state, int status, int page) {
+	/* if erase failed for a block, mark it as bad block */
+	if ((FL_ERASING == chip->state) && (status & NAND_STATUS_FAIL))
+		mtd_block_markbad(mtd, page << chip->page_shift);
+
+	return status;
+}
+
+static int
+axxia_nand_init_size(struct mtd_info *mtd, struct nand_chip *chip, u8 *id_data)
+{
+	int busw, extid;
+
+	/* The 3rd id byte holds MLC / multichip data */
+	chip->cellinfo = readb(chip->IO_ADDR_R + NAND_ID4_REG);
+	/* The 4th id byte is the important one */
+	extid = readb(chip->IO_ADDR_R + NAND_ID6_REG);
+
+	/* Add workaournd for Micron MT29Fxxxxxx NAND flash */
+	if (id_data[0] == NAND_MFR_MICRON && id_data[1] == 0x48) {
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x03);
+		extid >>= 2;
+		/*Calc oobsize */
+		mtd->oobsize = ((extid & 0x03) == 0x03) ? 218 : 224;
+		extid >>= 3;
+		/* Calc blocksize. Blocksize is multiples of 256KiB */
+		mtd->erasesize = (256 * 1024) << (extid & 0x03);
+		busw = 0;
+	} else {
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x03);
+		extid >>= 2;
+		/* Calc oobsize */
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		mtd->erasesize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+	}
+
+	axxia_nand_set_config(mtd, chip);
+
+	return busw;
+}
+
+/*
+  ----------------------------------------------------------------------
+  axxia_nand_init
+*/
+
+#define NAND_BASE 0x002000440000ULL
+#define NAND_SIZE 0x20000
+#define GPREG_BASE 0x00200040c000ULL
+#define GPREG_SIZE 0x1000
+
+static int __init
+axxia_nand_init(void)
+{
+	void *nand_base;
+	struct device_node *np = NULL;
+	struct mtd_part_parser_data ppdata;
+	static const char *part_probe_types[]
+		= { "cmdlinepart", "ofpart", NULL };
+	const u32 *reg;
+	int reglen;
+	u64 nand_address;
+	unsigned long nand_length;
+	u64 gpreg_address;
+	unsigned long gpreg_length;
+	const u32 *enabled;
+	unsigned long cr;
+	unsigned long cr_save;
+
+	memset(&ppdata, 0, sizeof(ppdata));
+
+	np = of_find_node_by_type(np, "nand");
+
+	while (np && !of_device_is_compatible(np, "acp-nand"))
+		np = of_find_node_by_type(np, "nand");
+
+	if (NULL == np) {
+		pr_err("No NAND Nodes in Device Tree\n");
+
+		return -1;
+	}
+
+	enabled = of_get_property(np, "enabled", NULL);
+
+	if (!enabled || (enabled && (0 == *enabled))) {
+		pr_err("ACP NAND Controller Isn't Enabled.\n");
+		return -ENODEV;
+	}
+
+	reg = of_get_property(np, "reg", &reglen);
+
+	if (reg && (16 == reglen)) {
+		nand_address = of_translate_address(np, reg);
+		nand_length = reg[1];
+		reg += 2;
+		gpreg_address = of_translate_address(np, reg);
+		gpreg_length = reg[1];
+		pr_info("nand_address=0x%08llx nand_length=0x%lx\n"
+			"gpreg_address=0x%08llx gpreg_length=0x%lx\n",
+			nand_address, nand_length,
+			gpreg_address, gpreg_length);
+		nand_base = ioremap(nand_address, nand_length);
+		gpreg_base = ioremap(gpreg_address, gpreg_length);
+	} else {
+		return -1;
+	}
+
+	ppdata.of_node = np;
+
+	/*
+	  Determine the Axxia system type.
+
+	  The ECC status register and mask are different on 344x, 342x, 35xx...
+	*/
+
+	if (of_machine_is_compatible("axxia,acp3500")) {
+		pecc_busy_register = (gpreg_base + 0x8c);
+		pecc_busy_mask = (1 << 20);
+	} else {
+		if (of_machine_is_compatible("axxia,acp3420")) {
+			pecc_busy_register = (gpreg_base + 0xc);
+			pecc_busy_mask = (1 << 28);
+		} else {
+			if (of_machine_is_compatible("axxia,acp3440")) {
+				pecc_busy_register = (gpreg_base + 0xc);
+				pecc_busy_mask = (1 << 28);
+			} else {
+				pr_err("Unsupported NAND Target\n");
+
+				return -1;
+			}
+		}
+	}
+
+	/*
+	  Determine the version of the controller.
+
+	  As there is not version register, see if bits 5:3 of the
+	  configuration register are writable.  There are in the EP501
+	  case and aren't in the EP501G1 case.
+	*/
+
+	cr = cr_save = READL((void *)(nand_base + NAND_CONFIG_REG));
+	cr = 0x2038;
+	WRITEL(cr, (void *)(nand_base + EP501_NAND_CONFIG_REG));
+	cr = READL((void *)nand_base + EP501_NAND_CONFIG_REG);
+	WRITEL(cr_save, (void *)(nand_base + EP501_NAND_CONFIG_REG));
+
+	if (0 == (cr & 0x2038))
+		axxia_nand_type = AXXIA_NAND_EP501G1;
+	else if (0x38 == (cr & 0x2038))
+		axxia_nand_type = AXXIA_NAND_EP501;
+	else if (0x2000 == (cr & 0x2038))
+		axxia_nand_type = AXXIA_NAND_EP501G3;
+	else
+		axxia_nand_type = AXXIA_NAND_NONE;
+
+	switch (axxia_nand_type) {
+	case AXXIA_NAND_EP501:
+		pr_info("EP501 NAND Controller.\n");
+		nand_cmd_ce_off = NAND_CMD_CE_OFF_501;
+		break;
+	case AXXIA_NAND_EP501G1:
+		pr_info("EP501G1 NAND Controller.\n");
+		nand_cmd_ce_off = NAND_CMD_CE_OFF_501G1;
+		break;
+	case AXXIA_NAND_EP501G3:
+		pr_info("EP501G3 NAND Controller.\n");
+		nand_cmd_ce_off = NAND_CMD_CE_OFF_501G3;
+		break;
+	default:
+		pr_info("Unknown NAND Controller!\n");
+		return -1;
+	}
+
+	/* Initialize structures */
+	memset(&axxia_nand_mtd, 0, sizeof(struct mtd_info));
+	memset(&axxia_nand_chip, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	axxia_nand_mtd.priv = &axxia_nand_chip;
+	axxia_nand_mtd.owner = THIS_MODULE;
+	axxia_nand_mtd.name = "acp-nand";
+
+	/* init chip callbacks */
+	axxia_nand_chip.IO_ADDR_R = (void *) nand_base;
+	axxia_nand_chip.IO_ADDR_W = (void *) nand_base;
+	axxia_nand_chip.write_buf = axxia_nand_write_buf;
+	axxia_nand_chip.read_buf = axxia_nand_read_buf;
+	axxia_nand_chip.write_page = axxia_nand_write_page;
+	axxia_nand_chip.cmd_ctrl = axxia_nand_hwcontrol;
+	axxia_nand_chip.dev_ready = axxia_nand_device_ready;
+	axxia_nand_chip.cmdfunc = axxia_nand_command;
+	axxia_nand_chip.waitfunc = axxia_nand_wait;
+	axxia_nand_chip.chip_delay = 10;
+	axxia_nand_chip.bbt_options = NAND_BBT_USE_FLASH;
+	axxia_nand_chip.read_byte = axxia_nand_read_byte;
+	axxia_nand_chip.errstat = axxia_nand_errstat;
+	axxia_nand_chip.init_size = axxia_nand_init_size;
+
+	/* initialize ECC */
+	axxia_nand_chip.ecc.mode = NAND_ECC_HW;
+	axxia_nand_chip.ecc.steps = 1;
+	axxia_nand_chip.ecc.total = 12;
+	axxia_nand_chip.ecc.hwctl = axxia_nand_ecc_hwctl;
+	axxia_nand_chip.ecc.calculate = axxia_nand_ecc_calculate;
+	axxia_nand_chip.ecc.correct = axxia_nand_ecc_correct;
+	axxia_nand_chip.ecc.read_page = axxia_nand_read_page_hwecc;
+	axxia_nand_chip.ecc.write_page = axxia_nand_write_page_hwecc;
+	axxia_nand_chip.ecc.read_page_raw = axxia_nand_read_page_hwecc;
+	axxia_nand_chip.ecc.write_page_raw = axxia_nand_write_page_hwecc;
+	axxia_nand_chip.ecc.read_oob = axxia_nand_read_oob;
+	axxia_nand_chip.ecc.write_oob = axxia_nand_write_oob;
+
+	pr_err("Enabling NAND ECC...\n");
+	/* clear any existing ECC status */
+	WRITEL(0x0, axxia_nand_chip.IO_ADDR_W + NAND_INTR_STATUS_REG);
+	/* enable ECC */
+	WRITEL(0x0, axxia_nand_chip.IO_ADDR_W + NAND_INTR_EN_REG);
+
+	/*
+	  ======================================================================
+	  Timing Control
+
+	  This may need to be changed, based on the devices used.  Each field is
+	  described below.
+	*/
+
+	/*
+	  TCR0 - NAND Timing Control Register 0
+	*/
+
+	{
+		nand_timing_control_register_0_t tcr0;
+
+		/* TH [31:24] - CLE, CE & ALE hold Time */
+		tcr0.bits.th = 0x08;
+
+		/* TRP [23:16] - Read Pulse Width */
+		tcr0.bits.trp = 0x0c;
+
+		/* TWP [15:8] - Write Pulse Width */
+		tcr0.bits.twp = 0x0c;
+
+		/* TS [7:0] - Setup Time for CLE, CE & ALE */
+		tcr0.bits.ts = 0x05;
+
+		WRITEL(tcr0.raw,
+		       (axxia_nand_chip.IO_ADDR_W + NAND_TIMING1_REG));
+	}
+
+	/*
+	  TCR1 - NAND Timing Control Register 1
+	*/
+
+	{
+		nand_timing_control_register_1_t tcr1;
+
+		/* TWB [31:24] - WE Rising Edge to RY/BY Falling Edge */
+		tcr1.bits.twb = 0x1e;
+
+		/* TRR [23:16] - RY/BY Rising Edge To Read Falling Edge */
+		tcr1.bits.trr = 0x07;
+
+		/* TRH [15:8] - Read Pulse High Time */
+		tcr1.bits.trh = 0x03;
+
+		/* TWH [7:0] - Write Pulse High Time */
+		tcr1.bits.twh = 0x03;
+
+		WRITEL(tcr1.raw,
+		       (axxia_nand_chip.IO_ADDR_W + NAND_TIMING2_REG));
+	}
+
+	/*
+	  TCR2 - NAND Timing Control Register 2 (EP501G3 Only)
+	*/
+
+	{
+		nand_timing_control_register_2_t tcr2;
+
+		tcr2.bits.tccs = 0x10;
+		tcr2.bits.twhr = 0x10;
+		tcr2.bits.trhw = 0x14;
+		WRITEL(tcr2.raw,
+		       (axxia_nand_chip.IO_ADDR_W + EP501G3_NAND_TIMING2_REG));
+	}
+
+	pr_err("Searching for NAND flash...\n");
+	/* Scan to find existence of the device */
+	if (nand_scan(&axxia_nand_mtd, 1)) {
+		pr_err("nand_scan failure...\n");
+		return -ENXIO;
+	}
+
+	/* Register the partitions */
+
+	mtd_device_parse_register(&axxia_nand_mtd, part_probe_types, &ppdata,
+				  NULL, 0);
+
+	/* Return happy */
+	return 0;
+}
+
+module_init(axxia_nand_init);
+
+/*
+  ----------------------------------------------------------------------
+  axxia_nand_exit
+*/
+
+static void __exit
+axxia_nand_exit(void)
+{
+	/* Release resources, unregister device */
+	nand_release(&axxia_nand_mtd);
+}
+
+module_exit(axxia_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jay Jayatheerthan <jay.jayatheerthan@intel.com>");
+MODULE_DESCRIPTION("MTD map driver for INTEL Axxia's ACP board");
diff --git a/drivers/mtd/nand/axxia_ubootenv.c b/drivers/mtd/nand/axxia_ubootenv.c
new file mode 100644
index 0000000..508c9d0
--- /dev/null
+++ b/drivers/mtd/nand/axxia_ubootenv.c
@@ -0,0 +1,569 @@
+/*
+ * drivers/axxia/acp/ubootenv.c
+ *
+ * Copyright (C) 2018 INTEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/crc32.h>
+#include <linux/io.h>
+
+/*
+  ======================================================================
+  Data types and Macros
+  ======================================================================
+*/
+#include <asm/axxia/debug.h>
+
+/*
+  ======================================================================
+  Global Variables
+  ======================================================================
+*/
+
+static struct kobject *ubootenv_kobj;
+
+
+static unsigned long uboot_env_size = (128 * 1024);
+static unsigned long uboot_env_cs_size = (128 * 1024);
+static int uboot_env_current = -1;
+
+#define ENVIRONMENT_DATA_SIZE(size) (size - (2 * sizeof(unsigned long)))
+
+typedef struct environment {
+
+	unsigned long crc32;
+	unsigned long flags;
+	unsigned char data[];
+
+} __packed environment_t;
+
+static environment_t *environment = (environment_t *) 0;
+
+static unsigned long crc32_lut[256] = {
+
+	/*   0 -- */           0u, 1996959894u, 3993919788u, 2567524794u,
+	/*   4 -- */   124634137u, 1886057615u, 3915621685u, 2657392035u,
+	/*   8 -- */   249268274u, 2044508324u, 3772115230u, 2547177864u,
+	/*  12 -- */   162941995u, 2125561021u, 3887607047u, 2428444049u,
+	/*  16 -- */   498536548u, 1789927666u, 4089016648u, 2227061214u,
+	/*  20 -- */   450548861u, 1843258603u, 4107580753u, 2211677639u,
+	/*  24 -- */   325883990u, 1684777152u, 4251122042u, 2321926636u,
+	/*  28 -- */   335633487u, 1661365465u, 4195302755u, 2366115317u,
+	/*  32 -- */   997073096u, 1281953886u, 3579855332u, 2724688242u,
+	/*  36 -- */  1006888145u, 1258607687u, 3524101629u, 2768942443u,
+	/*  40 -- */   901097722u, 1119000684u, 3686517206u, 2898065728u,
+	/*  44 -- */   853044451u, 1172266101u, 3705015759u, 2882616665u,
+	/*  48 -- */   651767980u, 1373503546u, 3369554304u, 3218104598u,
+	/*  52 -- */   565507253u, 1454621731u, 3485111705u, 3099436303u,
+	/*  56 -- */   671266974u, 1594198024u, 3322730930u, 2970347812u,
+	/*  60 -- */   795835527u, 1483230225u, 3244367275u, 3060149565u,
+	/*  64 -- */  1994146192u,   31158534u, 2563907772u, 4023717930u,
+	/*  68 -- */  1907459465u,  112637215u, 2680153253u, 3904427059u,
+	/*  72 -- */  2013776290u,  251722036u, 2517215374u, 3775830040u,
+	/*  76 -- */  2137656763u,  141376813u, 2439277719u, 3865271297u,
+	/*  80 -- */  1802195444u,  476864866u, 2238001368u, 4066508878u,
+	/*  84 -- */  1812370925u,  453092731u, 2181625025u, 4111451223u,
+	/*  88 -- */  1706088902u,  314042704u, 2344532202u, 4240017532u,
+	/*  92 -- */  1658658271u,  366619977u, 2362670323u, 4224994405u,
+	/*  96 -- */  1303535960u,  984961486u, 2747007092u, 3569037538u,
+	/* 100 -- */  1256170817u, 1037604311u, 2765210733u, 3554079995u,
+	/* 104 -- */  1131014506u,  879679996u, 2909243462u, 3663771856u,
+	/* 108 -- */  1141124467u,  855842277u, 2852801631u, 3708648649u,
+	/* 112 -- */  1342533948u,  654459306u, 3188396048u, 3373015174u,
+	/* 116 -- */  1466479909u,  544179635u, 3110523913u, 3462522015u,
+	/* 120 -- */  1591671054u,  702138776u, 2966460450u, 3352799412u,
+	/* 124 -- */  1504918807u,  783551873u, 3082640443u, 3233442989u,
+	/* 128 -- */  3988292384u, 2596254646u,   62317068u, 1957810842u,
+	/* 132 -- */  3939845945u, 2647816111u,   81470997u, 1943803523u,
+	/* 136 -- */  3814918930u, 2489596804u,  225274430u, 2053790376u,
+	/* 140 -- */  3826175755u, 2466906013u,  167816743u, 2097651377u,
+	/* 144 -- */  4027552580u, 2265490386u,  503444072u, 1762050814u,
+	/* 148 -- */  4150417245u, 2154129355u,  426522225u, 1852507879u,
+	/* 152 -- */  4275313526u, 2312317920u,  282753626u, 1742555852u,
+	/* 156 -- */  4189708143u, 2394877945u,  397917763u, 1622183637u,
+	/* 160 -- */  3604390888u, 2714866558u,  953729732u, 1340076626u,
+	/* 164 -- */  3518719985u, 2797360999u, 1068828381u, 1219638859u,
+	/* 168 -- */  3624741850u, 2936675148u,  906185462u, 1090812512u,
+	/* 172 -- */  3747672003u, 2825379669u,  829329135u, 1181335161u,
+	/* 176 -- */  3412177804u, 3160834842u,  628085408u, 1382605366u,
+	/* 180 -- */  3423369109u, 3138078467u,  570562233u, 1426400815u,
+	/* 184 -- */  3317316542u, 2998733608u,  733239954u, 1555261956u,
+	/* 188 -- */  3268935591u, 3050360625u,  752459403u, 1541320221u,
+	/* 192 -- */  2607071920u, 3965973030u, 1969922972u,   40735498u,
+	/* 196 -- */  2617837225u, 3943577151u, 1913087877u,   83908371u,
+	/* 200 -- */  2512341634u, 3803740692u, 2075208622u,  213261112u,
+	/* 204 -- */  2463272603u, 3855990285u, 2094854071u,  198958881u,
+	/* 208 -- */  2262029012u, 4057260610u, 1759359992u,  534414190u,
+	/* 212 -- */  2176718541u, 4139329115u, 1873836001u,  414664567u,
+	/* 216 -- */  2282248934u, 4279200368u, 1711684554u,  285281116u,
+	/* 220 -- */  2405801727u, 4167216745u, 1634467795u,  376229701u,
+	/* 224 -- */  2685067896u, 3608007406u, 1308918612u,  956543938u,
+	/* 228 -- */  2808555105u, 3495958263u, 1231636301u, 1047427035u,
+	/* 232 -- */  2932959818u, 3654703836u, 1088359270u,  936918000u,
+	/* 236 -- */  2847714899u, 3736837829u, 1202900863u,  817233897u,
+	/* 240 -- */  3183342108u, 3401237130u, 1404277552u,  615818150u,
+	/* 244 -- */  3134207493u, 3453421203u, 1423857449u,  601450431u,
+	/* 248 -- */  3009837614u, 3294710456u, 1567103746u,  711928724u,
+	/* 252 -- */  3020668471u, 3272380065u, 1510334235u,  755167117u
+
+};
+
+/*
+  ======================================================================
+  Prototypes
+  ======================================================================
+*/
+
+static unsigned long ubootenv_crc32(unsigned char *, unsigned long);
+static int ubootenv_initialize(void);
+static void ubootenv_finalize(void);
+static int ubootenv_read(struct mtd_info *, size_t, void *);
+static void create_env_sysfs(void);
+/*
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_crc32
+*/
+
+static unsigned long
+ubootenv_crc32(unsigned char *start, unsigned long size)
+{
+	unsigned long crc = (unsigned long)0xffffffff, index;
+
+	DEBUG_PRINT("start=0x%lx size=0x%lx\n", (unsigned long)start, size);
+
+	for (index = 0; index < size; index++) {
+		unsigned long temp = (crc ^ *(start++)) & 0x000000ff;
+
+		crc = ((crc >> 8) & 0x00ffffff) ^ crc32_lut[temp];
+	}
+	return ~crc;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_read
+*/
+
+static int
+ubootenv_read(struct mtd_info *mtd, size_t size, void *buffer)
+{
+	int read = 0;
+	loff_t offset = 0;
+
+	DEBUG_PRINT("size=0x%x mtd->erasesize=0x%x mtd->size=0x%llx\n",
+		    size, mtd->erasesize, mtd->size);
+
+	if (0 != size % mtd->erasesize) {
+		ERROR_PRINT("size=%u/%llu is not a multiple of erasesize=%u\n",
+			    size, mtd->size, mtd->erasesize);
+		return -1;
+	}
+
+	if (size > mtd->size) {
+		ERROR_PRINT("size=%llu can't contain size=%u\n",
+			    mtd->size, size);
+		return -1;
+	}
+
+	while ((read < size) && (offset < mtd->size)) {
+		int return_code;
+		size_t bytes_read;
+
+		DEBUG_PRINT("read=0x%x size=0x%x offset=0x%llx\n",
+			    read, size, offset);
+
+		if (0 != mtd_block_isbad(mtd, offset)) {
+			offset += mtd->erasesize;
+			continue;
+		}
+
+		return_code = mtd_read(mtd, offset, mtd->erasesize,
+				       &bytes_read, (u_char *) buffer);
+
+		if (mtd->erasesize != bytes_read) {
+			ERROR_PRINT("Error Reading Environment!\n");
+			return -1;
+		}
+
+		offset += mtd->erasesize;
+		read += mtd->erasesize;
+		buffer += mtd->erasesize;
+	}
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_initialize
+*/
+
+static int
+ubootenv_initialize(void)
+{
+	environment_t *env0;
+	environment_t *env1;
+	unsigned long crc32_env0;
+	unsigned long crc32_env1;
+	struct mtd_info *mtd_env0;
+	struct mtd_info *mtd_env1;
+
+	DEBUG_PRINT("Getting MTD Devices.\n");
+
+	mtd_env0 = get_mtd_device_nm("env-0");
+	if ((struct mtd_info *)-ENODEV == mtd_env0) {
+		ERROR_PRINT(" --> Couldn't get MTD device by name!\n");
+		return -1;
+	}
+
+	mtd_env1 = get_mtd_device_nm("env-1");
+	if ((struct mtd_info *)-ENODEV == mtd_env1) {
+		ERROR_PRINT(" --> Couldn't get MTD device by name!\n");
+		return -1;
+	}
+
+	/*
+	 * If the erasesize is larger than the size of the environment,
+	 * change the environment size (so reading and writing will
+	 * work as expected) but use the original environment size to
+	 * calculate the checksum.
+	 */
+
+	if (mtd_env0->erasesize > uboot_env_size)
+		uboot_env_size = mtd_env0->erasesize;
+
+	DEBUG_PRINT("Allocating Environment Buffers.\n");
+
+	env0 = vmalloc(uboot_env_size);
+	if ((environment_t *)0 == env0) {
+		ERROR_PRINT("Unable to allocate %lu bytes\n", uboot_env_size);
+		return -1;
+	}
+
+	env1 = vmalloc(uboot_env_size);
+	if ((environment_t *) 0 == env1) {
+		ERROR_PRINT("Unable to allocate %lu bytes\n", uboot_env_size);
+		vfree((void *) env0);
+		return -1;
+	}
+
+	DEBUG_PRINT("Reading Environments.\n");
+
+	if (0 != ubootenv_read(mtd_env0, uboot_env_size, env0))
+		return -1;
+
+	if (0 != ubootenv_read(mtd_env1, uboot_env_size, env1))
+		return -1;
+
+	DEBUG_PRINT("Calculating CRC values.\n");
+	crc32_env0 = ubootenv_crc32((unsigned char *)env0->data,
+				    ENVIRONMENT_DATA_SIZE(uboot_env_cs_size));
+	crc32_env1 = ubootenv_crc32((unsigned char *)env1->data,
+				    ENVIRONMENT_DATA_SIZE(uboot_env_cs_size));
+	DEBUG_PRINT("crc32_env0=0x%lx env0->crc32=0x%lx\n",
+		    crc32_env0, env0->crc32);
+	DEBUG_PRINT("crc32_env2=0x%lx env1->crc32=0x%lx\n",
+		     crc32_env1, env1->crc32);
+	DEBUG_PRINT("Picking a Copy.\n");
+
+	if ((crc32_env0 == env0->crc32) &&
+	    (crc32_env1 != env1->crc32)) {
+		/* Use env0 */
+		DEBUG_PRINT("Using Copy 0.\n");
+		uboot_env_current = 0;
+		vfree((void *) env1);
+		environment = env0;
+	} else if ((crc32_env0 != env0->crc32) &&
+		   (crc32_env1 == env1->crc32)) {
+		/* Use env1 */
+		DEBUG_PRINT("Using Copy 1.\n");
+		uboot_env_current = 1;
+		vfree((void *) env0);
+		environment = env1;
+	} else if ((crc32_env0 != env0->crc32) &&
+		   (crc32_env1 != env1->crc32)) {
+		/* No Environment Available */
+		uboot_env_current = -1;
+		vfree((void *) env0);
+		vfree((void *) env1);
+		ERROR_PRINT("Bad CRCs: No Valid U-Boot Environment Found!\n");
+		return -1;
+	} else if (env0->flags > env1->flags) {
+		/* Use env0 */
+		DEBUG_PRINT("Using Copy 0.\n");
+		uboot_env_current = 0;
+		vfree((void *) env1);
+		environment = env0;
+	} else if (env0->flags < env1->flags) {
+		/* Use env1 */
+		DEBUG_PRINT("Using Copy 1.\n");
+		uboot_env_current = 1;
+		vfree((void *) env0);
+		environment = env1;
+	} else if (env0->flags == env1->flags) {
+		/* Use Either */
+		DEBUG_PRINT("Using Copy 0.\n");
+		uboot_env_current = 0;
+		vfree((void *) env1);
+		environment = env0;
+	} else {
+		/* No Environment Available */
+		uboot_env_current = -1;
+		vfree((void *) env0);
+		vfree((void *) env1);
+		ERROR_PRINT("Bad Flags: No Valid U-Boot Environment Found!\n");
+		return -1;
+	}
+
+	DEBUG_PRINT("Done...\n");
+	create_env_sysfs();
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_finalize
+*/
+
+static void
+ubootenv_finalize(void)
+{
+	DEBUG_PRINT("Freeing the environment.\n");
+
+	if ((void *)0 != environment)
+		vfree((void *)environment);
+
+	environment = (environment_t *)0;
+}
+
+/*
+  ======================================================================
+  Public Interface
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_get
+*/
+
+int
+ubootenv_get(const char *key, char *value)
+{
+	int return_code = -1;
+	char *string;
+
+	if (NULL == environment) {
+		ERROR_PRINT("Environment Isn't Available!\n");
+		return -1;
+	}
+
+	string = environment->data;
+
+	while (0x00 != string[0]) {
+		if (0 == strncmp(key, string, strlen(key))) {
+			char *value_ = strchr(string, '=');
+			++value_;
+			strcpy(value, value_);
+			return_code = 0;
+			break;
+		}
+
+		string += (strlen(string) + 1);
+	}
+
+	return return_code;
+}
+EXPORT_SYMBOL(ubootenv_get);
+
+/*
+  ======================================================================
+  ======================================================================
+  Sysfs Stuff
+  ======================================================================
+  ======================================================================
+*/
+
+struct bin_attribute uboot_env[100];
+
+static ssize_t read_env(struct file *filep, struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t size)
+{
+	int retsize = -1;
+	char *string;
+
+	if (size <= 1)
+		return 0;
+
+	if (NULL == environment) {
+		ERROR_PRINT("Environment Isn't Available!\n");
+		return -1;
+	}
+
+	string = environment->data;
+
+	while (0x00 != string[0]) {
+		if (0 == strncmp(bin_attr->attr.name,
+				 string, strlen(bin_attr->attr.name))) {
+			char *value_ = strchr(string, '=');
+			++value_;
+
+			retsize = 1 + strlcpy(buf, value_, size);
+			break;
+		}
+
+		string += (strlen(string) + 1);
+	}
+
+	return retsize;
+}
+
+static void create_env_sysfs(void)
+{
+	char *string;
+	int i = 0;
+
+	if (NULL == environment) {
+		ERROR_PRINT("Environment Isn't Available!\n");
+		return;
+	}
+
+	string = environment->data;
+
+	while (0x00 != string[0]) {
+		char *value_ = strchr(string, '=');
+		char *name = vmalloc(1 + value_ - string);
+
+		strlcpy(name, string, 1 + value_ - string);
+
+		uboot_env[i].attr.name = name;
+		uboot_env[i].attr.mode = 0400;
+		uboot_env[i].size = strlen(string) - (value_ - string);
+		uboot_env[i].read = read_env;
+
+		if (sysfs_create_bin_file(ubootenv_kobj, &uboot_env[i]))
+			ERROR_PRINT("unable to add uboot-env sysfs file\n");
+
+		string += (strlen(string) + 1);
+		i++;
+		if (i > 99) {
+			ERROR_PRINT("More than 100 uboot env variables.\n");
+			return;
+		}
+	}
+}
+
+
+static ssize_t list_env(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	int i = 1;
+
+	while (i < uboot_env_size - 2) {
+		if (environment->data[i-1] == 0)
+			if (environment->data[i] == 0)
+				if (environment->data[i+1] == 0)
+					break;
+		i++;
+	}
+	memcpy(buf, environment->data, i);
+	return i;
+}
+
+static DEVICE_ATTR(list_env, 0444, list_env, NULL);
+
+static struct attribute *attrs[] = {
+	&dev_attr_list_env.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+
+/*
+  ======================================================================
+  ======================================================================
+  Linux Module Stuff
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_module_init
+*/
+
+int __init
+ubootenv_module_init(void)
+{
+	int retval;
+
+	DEBUG_PRINT("\n");
+	ubootenv_kobj = kobject_create_and_add("uboot-env", kernel_kobj);
+	if (!ubootenv_kobj)
+		return -ENOMEM;
+
+	/* Create the files associated with this kobject */
+	retval = sysfs_create_group(ubootenv_kobj, &attr_group);
+	if (retval)
+		goto fail;
+
+	retval = ubootenv_initialize();
+	if (retval)
+		goto fail;
+
+	return 0;
+fail:
+	kobject_put(ubootenv_kobj);
+
+	return retval;
+}
+
+module_init(ubootenv_module_init);
+
+/*
+  ----------------------------------------------------------------------
+  ubootenv_module_exit
+*/
+
+void __exit
+ubootenv_module_exit(void)
+{
+	DEBUG_PRINT("\n");
+	kobject_put(ubootenv_kobj);
+	ubootenv_finalize();
+}
+
+module_exit(ubootenv_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Jacques <john.jacques@intel.com>");
+MODULE_DESCRIPTION("Read Access of the U-Boot Environment");
diff --git a/drivers/mtd/nand/lsi_acp_nand.c b/drivers/mtd/nand/lsi_acp_nand.c
deleted file mode 100644
index 7ac34ab..0000000
--- a/drivers/mtd/nand/lsi_acp_nand.c
+++ /dev/null
@@ -1,3676 +0,0 @@
-/*
- * drivers/lsi/acp/nand.c
- *
- * NAND Controller Driver for LSI's ACP
- *
- * Copyright (C) 2009 LSI Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.
- */
-
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/of.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <asm/cacheflush.h>
-
-/* -- DEBUG --------------------------------------------------------- */
-
-#include <asm/lsi/debug.h>
-
-/* -- LOGIO --------------------------------------------------------- */
-
-#undef LOGIO
-/*#define LOGIO*/
-#ifdef LOGIO
-int enable_logio;
-static inline unsigned long _READL(const char *, int, unsigned long);
-static inline unsigned long
-_READL(const char *file, int line, unsigned long address)
-{
-	unsigned long value;
-
-	value = readl(address);
-
-	if (0 != enable_logio)
-		pr_info("%s:%d - Read 0x%08lx from 0x%08lx\n",
-		       file, line, value, address);
-
-	return value;
-}
-#define READL(address) _READL(__FILE__, __LINE__, (address))
-static inline void _WRITEL(const char *, int, unsigned long, unsigned long);
-static inline void
-_WRITEL(const char *file, int line, unsigned long value, unsigned long address)
-{
-	writel(value, address);
-
-	if (0 != enable_logio)
-		pr_err("%s:%d - Wrote 0x%08lx to 0x%08lx\n",
-		       file, line, value, address);
-}
-#define WRITEL(value, address) _WRITEL(__FILE__, __LINE__, (value), (address))
-#else  /* LOGIO */
-#define READL(address) readl((address))
-#define WRITEL(value, address) writel((value), (address))
-#endif /* LOGIO */
-
-/*
-  ----------------------------------------------------------------------
-*/
-
-#define NAND_DATA_REG	      0x00000000
-#define NAND_CMD_REG	      0x00008000
-#define NAND_INDEX_REG	      0x00008004
-#define NAND_STATUS1_REG      0x00008008
-#define NAND_STATUS2_REG      0x0000800C
-#define NAND_ID0_REG	      0x00008010
-#define NAND_ID1_REG	      0x00008014
-#define NAND_ID2_REG	      0x00008018
-#define NAND_ID3_REG	      0x0000801C
-#define NAND_ID4_REG	      0x00008020
-#define NAND_ID5_REG	      0x00008024
-#define NAND_ID6_REG	      0x00008028
-#define NAND_ID7_REG	      0x0000802C
-#define NAND_INTR_EN_REG      0x00008030
-#define NAND_INTR_STATUS_REG  0x00008034
-#define NAND_INTR_REG	      0x00008038
-#define NAND_ECC_ADDR_LOG_REG 0x0000803C
-#define NAND_ECC_VAL_REG      0x00008040
-#define NAND_ECC_INJECT_REG   0x00008044
-#define NAND_EXT_INDEX_REG    0x00008048
-#define NAND_TIMING1_REG      0x0000804C
-#define NAND_TIMING2_REG      0x00008050
-#define NAND_CONFIG_REG	      0x00008054
-#define NAND_PECC_REG	      0x00008058
-
-#define EP501_NAND_DATA_REG         0x0000
-#define EP501_NAND_CMD_REG          0x8000
-#define EP501_NAND_INDEX_REG        0x8004
-#define EP501_NAND_STATUS0_REG      0x8008
-#define EP501_NAND_STATUS1_REG      0x800C
-#define EP501_NAND_ID0_REG          0x8010
-#define EP501_NAND_ID1_REG          0x8014
-#define EP501_NAND_ID2_REG          0x8018
-#define EP501_NAND_ID3_REG          0x801C
-#define EP501_NAND_ID4_REG          0x8020
-#define EP501_NAND_ID5_REG          0x8024
-#define EP501_NAND_ID6_REG          0x8028
-#define EP501_NAND_ID7_REG          0x802C
-#define EP501_NAND_INTR_EN_REG      0x8030
-#define EP501_NAND_INTR_STATUS_REG  0x8034
-#define EP501_NAND_INTR_REG         0x8038
-#define EP501_NAND_ECC_ADDR_LOG_REG 0x803C
-#define EP501_NAND_ECC_VAL_REG      0x8040
-#define EP501_NAND_ECC_INJECT_REG   0x8044
-#define EP501_NAND_EXT_INDEX_REG    0x8048
-#define EP501_NAND_TIMING0_REG      0x804C
-#define EP501_NAND_TIMING1_REG      0x8050
-#define EP501_NAND_CONFIG_REG       0x8054
-#define EP501_NAND_PECC_REG         0x8058
-
-#define EP501G1_NAND_DATA_REG         0x0000
-#define EP501G1_NAND_CMD_REG          0x8000
-#define EP501G1_NAND_INDEX_REG        0x8004
-#define EP501G1_NAND_STATUS0_REG      0x8008
-#define EP501G1_NAND_ID0_REG          0x8010
-#define EP501G1_NAND_ID2_REG          0x8018
-#define EP501G1_NAND_ID4_REG          0x8020
-#define EP501G1_NAND_ID6_REG          0x8028
-#define EP501G1_NAND_INTR_EN_REG      0x8030
-#define EP501G1_NAND_INTR_STATUS_REG  0x8034
-#define EP501G1_NAND_INTR_REG         0x8038
-#define EP501G1_NAND_EXT_INDEX_REG    0x8048
-#define EP501G1_NAND_TIMING0_REG      0x804C
-#define EP501G1_NAND_TIMING1_REG      0x8050
-#define EP501G1_NAND_CONFIG_REG       0x8054
-#define EP501G1_NAND_1BIT_ECC0_STATUS 0x8058
-#define EP501G1_NAND_1BIT_ECC1_STATUS 0x805c
-#define EP501G1_NAND_1BIT_ECC2_STATUS 0x8060
-#define EP501G1_NAND_1BIT_ECC3_STATUS 0x8064
-#define EP501G1_NAND_1BIT_ECC4_STATUS 0x8068
-#define EP501G1_NAND_1BIT_ECC5_STATUS 0x806c
-#define EP501G1_NAND_1BIT_ECC6_STATUS 0x8070
-#define EP501G1_NAND_1BIT_ECC7_STATUS 0x8074
-#define EP501G1_NAND_BCH_STATUS       0x807c
-#define EP501G1_NAND_SYN_R12_S0       0x8080
-#define EP501G1_NAND_SYN_R34_S0       0x8084
-#define EP501G1_NAND_SYN_R56_S0       0x8088
-#define EP501G1_NAND_SYN_R78_S0       0x808c
-#define EP501G1_NAND_SYN_R12_S1       0x8090
-#define EP501G1_NAND_SYN_R34_S1       0x8094
-#define EP501G1_NAND_SYN_R56_S1       0x8098
-#define EP501G1_NAND_SYN_R78_S1       0x809c
-#define EP501G1_NAND_SYN_R12_S2       0x80a0
-#define EP501G1_NAND_SYN_R34_S2       0x80a4
-#define EP501G1_NAND_SYN_R56_S2       0x80a8
-#define EP501G1_NAND_SYN_R78_S2       0x80ac
-#define EP501G1_NAND_SYN_R12_S3       0x80b0
-#define EP501G1_NAND_SYN_R34_S3       0x80b4
-#define EP501G1_NAND_SYN_R56_S3       0x80b8
-#define EP501G1_NAND_SYN_R78_S3       0x80bc
-#define EP501G1_NAND_SYN_R12_S4       0x80c0
-#define EP501G1_NAND_SYN_R34_S4       0x80c4
-#define EP501G1_NAND_SYN_R56_S4       0x80c8
-#define EP501G1_NAND_SYN_R78_S4       0x80cc
-#define EP501G1_NAND_SYN_R12_S5       0x80d0
-#define EP501G1_NAND_SYN_R34_S5       0x80d4
-#define EP501G1_NAND_SYN_R56_S5       0x80d8
-#define EP501G1_NAND_SYN_R78_S5       0x80dc
-#define EP501G1_NAND_SYN_R12_S6       0x80e0
-#define EP501G1_NAND_SYN_R34_S6       0x80e4
-#define EP501G1_NAND_SYN_R56_S6       0x80e8
-#define EP501G1_NAND_SYN_R78_S6       0x80ec
-#define EP501G1_NAND_SYN_R12_S7       0x80f0
-#define EP501G1_NAND_SYN_R34_S7       0x80f4
-#define EP501G1_NAND_SYN_R56_S7       0x80f8
-#define EP501G1_NAND_SYN_R78_S7       0x80fc
-
-#define EP501G3_NAND_DATA_REG         0x0000
-#define EP501G3_NAND_CMD_REG          0x8000
-#define EP501G3_NAND_INDEX_REG        0x8004
-#define EP501G3_NAND_STATUS0_REG      0x8008
-#define EP501G3_NAND_ID0_REG          0x8010
-#define EP501G3_NAND_ID2_REG          0x8018
-#define EP501G3_NAND_ID4_REG          0x8020
-#define EP501G3_NAND_ID6_REG          0x8028
-#define EP501G3_NAND_INTR_EN_REG      0x8030
-#define EP501G3_NAND_INTR_STATUS_REG  0x8034
-#define EP501G3_NAND_INTR_REG         0x8038
-#define EP501G3_NAND_EXT_INDEX_REG    0x8048
-#define EP501G3_NAND_TIMING0_REG      0x804C
-#define EP501G3_NAND_TIMING1_REG      0x8050
-#define EP501G3_NAND_CONFIG_REG       0x8054
-#define EP501G3_NAND_TIMING2_REG      0x805c
-#define EP501G3_NAND_BCH_STATUS       0x807c
-#define EP501G3_NAND_SYN_R12_S0       0x8080
-#define EP501G3_NAND_SYN_R34_S0       0x8084
-#define EP501G3_NAND_SYN_R56_S0       0x8088
-#define EP501G3_NAND_SYN_R78_S0       0x808c
-#define EP501G3_NAND_SYN_R12_S1       0x8090
-#define EP501G3_NAND_SYN_R34_S1       0x8094
-#define EP501G3_NAND_SYN_R56_S1       0x8098
-#define EP501G3_NAND_SYN_R78_S1       0x809c
-#define EP501G3_NAND_SYN_R12_S2       0x80a0
-#define EP501G3_NAND_SYN_R34_S2       0x80a4
-#define EP501G3_NAND_SYN_R56_S2       0x80a8
-#define EP501G3_NAND_SYN_R78_S2       0x80ac
-#define EP501G3_NAND_SYN_R12_S3       0x80b0
-#define EP501G3_NAND_SYN_R34_S3       0x80b4
-#define EP501G3_NAND_SYN_R56_S3       0x80b8
-#define EP501G3_NAND_SYN_R78_S3       0x80bc
-#define EP501G3_NAND_SYN_R12_S4       0x80c0
-#define EP501G3_NAND_SYN_R34_S4       0x80c4
-#define EP501G3_NAND_SYN_R56_S4       0x80c8
-#define EP501G3_NAND_SYN_R78_S4       0x80cc
-#define EP501G3_NAND_SYN_R12_S5       0x80d0
-#define EP501G3_NAND_SYN_R34_S5       0x80d4
-#define EP501G3_NAND_SYN_R56_S5       0x80d8
-#define EP501G3_NAND_SYN_R78_S5       0x80dc
-#define EP501G3_NAND_SYN_R12_S6       0x80e0
-#define EP501G3_NAND_SYN_R34_S6       0x80e4
-#define EP501G3_NAND_SYN_R56_S6       0x80e8
-#define EP501G3_NAND_SYN_R78_S6       0x80ec
-#define EP501G3_NAND_SYN_R12_S7       0x80f0
-#define EP501G3_NAND_SYN_R34_S7       0x80f4
-#define EP501G3_NAND_SYN_R56_S7       0x80f8
-#define EP501G3_NAND_SYN_R78_S7       0x80fc
-#define EP501G3_NAND_SYN_R12_S8       0x8100
-#define EP501G3_NAND_SYN_R34_S8       0x8104
-#define EP501G3_NAND_SYN_R56_S8       0x8108
-#define EP501G3_NAND_SYN_R78_S8       0x810c
-#define EP501G3_NAND_SYN_R12_S9       0x8110
-#define EP501G3_NAND_SYN_R34_S9       0x8114
-#define EP501G3_NAND_SYN_R56_S9       0x8118
-#define EP501G3_NAND_SYN_R78_S9       0x811c
-#define EP501G3_NAND_SYN_R12_S10      0x8120
-#define EP501G3_NAND_SYN_R34_S10      0x8124
-#define EP501G3_NAND_SYN_R56_S10      0x8128
-#define EP501G3_NAND_SYN_R78_S10      0x812c
-#define EP501G3_NAND_SYN_R12_S11      0x8130
-#define EP501G3_NAND_SYN_R34_S11      0x8134
-#define EP501G3_NAND_SYN_R56_S11      0x8138
-#define EP501G3_NAND_SYN_R78_S11      0x813c
-#define EP501G3_NAND_SYN_R12_S12      0x8140
-#define EP501G3_NAND_SYN_R34_S12      0x8144
-#define EP501G3_NAND_SYN_R56_S12      0x8148
-#define EP501G3_NAND_SYN_R78_S12      0x814c
-#define EP501G3_NAND_SYN_R12_S13      0x8150
-#define EP501G3_NAND_SYN_R34_S13      0x8154
-#define EP501G3_NAND_SYN_R56_S13      0x8158
-#define EP501G3_NAND_SYN_R78_S13      0x815c
-#define EP501G3_NAND_SYN_R12_S14      0x8160
-#define EP501G3_NAND_SYN_R34_S14      0x8164
-#define EP501G3_NAND_SYN_R56_S14      0x8168
-#define EP501G3_NAND_SYN_R78_S14      0x816c
-#define EP501G3_NAND_SYN_R12_S15      0x8170
-#define EP501G3_NAND_SYN_R34_S15      0x8174
-#define EP501G3_NAND_SYN_R56_S15      0x8178
-#define EP501G3_NAND_SYN_R78_S15      0x817c
-
-/*
-  ==============================================================================
-  ==============================================================================
-  Some Oddities...
-
-  -1-
-  Reading EP501 registers while the device is calculating ECC will
-  hang the AHB.	 As the only way to know that an ECC calculation is in
-  progress is to read the "extra bits" added to the interrupt status
-  register, this can cause problems.  To get around this, the
-  PECC_BUSY signal from the controller is also available in a general
-  purpose system register.  0x149.0.0xc/0x0020_0040_0000_c00c, bit 24.
-  So, before reading the interrupt status register (or any other
-  register for that matter) make sure the bit mentioned above is
-  clear.  See BZ21212.
-
-  -2-
-  Extra bits have been added to the interrupt status register.	See
-  BZ21196.  From that defect...
-
-  == Bit 0
-  This bit is set when un-correctable ECC is detected. This bit can be
-  cleared by writing "0" to this register. Writing "1" has no
-  effect. An interrupt is generated if this bit and the enable bit
-  (bit 0) in the Interrupt Enable Register are "1". This bit is not
-  set if ECC is disabled.
-
-  == Bit 1
-  This bit is set when correctable ECC is detected. This bit can be
-  cleared by writing "0" to this register. Writing "1" has no
-  effect. An interrupt is generated if this bit and the enable bit
-  (bit 1) in the Interrupt Enable Register are "1". This bit is not
-  set if ECC is disabled.
-
-  == Bit 2
-  This bit is set when a rising edge is detected on the non gated
-  READY/BUSY# input from the NAND Flash. This bit can be cleared by
-  writing a "0" to this register. Writing a "1" has no effect. An
-  interrupt is generated if this bit and the enable bit (bit 2) in the
-  Interrupt Enable Register are "1".
-
-  == Bit 3
-  This bit is set when a falling edge is detected on the non gated
-  READY/BUSY# input from the NAND Flash. This bit can be cleared by
-  writing a "0" to this register. Writing a "1" has no effect. An
-  interrupt is generated if this bit and the enable bit (bit 3) in the
-  Interrupt Enable Register are "1".
-
-  == Bit 4
-  This bit is set when a falling edge is detected on the PECC_BUSY
-  signal which indicates when the NAND controller has taken control of
-  the NAND Flash for ECC byte access. This bit can be cleared by
-  writing a "0" to this register. Writing a "1" has no effect. An
-  interrupt is generated if this bit and the enable bit (bit 4) in the
-  Interrupt Enable Register are "1".
-
-  == Bit 5
-  This bit is read only and is the synchronized level on the non gated
-  READY/BUSY# input from the NAND Flash. This bit can be used to poll
-  the status of this signal and is not used to generate an interrupt.
-
-  == Bit 6
-  This bit is read only and indicates the level on the PECC_BUSY
-  signal which indicates when the NAND controller has taken control of
-  the NAND Flash for ECC byte access. This bit can be used to poll the
-  level of this signal and is not used to generate an interrupt.
-
-  ==============================================================================
-  ==============================================================================
-*/
-
-static void *gpreg_base;
-static void *pecc_busy_register;
-static unsigned long pecc_busy_mask;
-
-#define MAX_READ_BUF	16
-
-/*
-  ----------------------------------------------------------------------
-  MTD structures
-*/
-
-static struct mtd_info lsi_nand_mtd = { 0 };
-static struct nand_chip lsi_nand_chip = { 0 };
-
-static struct lsi_nand_private {
-	int cur;	/* -1 means there is no meaningful data in buffer */
-	uint8_t buf[MAX_READ_BUF];
-} lsi_nand_private;
-
-#define NAND_CMD_START_ECC_READ	  0x23
-
-#define NAND_CMD_CE_OFF_501	  0xEE
-#define NAND_CMD_CE_OFF_501G1	  0xEE
-#define NAND_CMD_CE_OFF_501G3	  0xFE
-static int nand_cmd_ce_off;
-
-typedef union {
-	unsigned long raw;
-
-	struct {
-#ifdef CONFIG_ACP
-		unsigned long th:8;
-		unsigned long trp:8;
-		unsigned long twp:8;
-		unsigned long ts:8;
-#else
-		unsigned long ts:8;
-		unsigned long twp:8;
-		unsigned long trp:8;
-		unsigned long th:8;
-#endif
-	} __packed bits;
-} nand_timing_control_register_0_t;
-
-typedef union {
-	unsigned long raw;
-
-	struct {
-#ifdef CONFIG_ACP
-		unsigned long twb:8;
-		unsigned long trr:8;
-		unsigned long trh:8;
-		unsigned long twh:8;
-#else
-		unsigned long twh:8;
-		unsigned long trh:8;
-		unsigned long trr:8;
-		unsigned long twb:8;
-#endif
-	} __packed bits;
-} __packed nand_timing_control_register_1_t;
-
-typedef union {
-	unsigned long raw;
-
-	struct {
-#ifdef CONFIG_ACP
-		unsigned long:8;
-		unsigned long trhw:8;
-		unsigned long twhr:8;
-		unsigned long tccs:8;
-#else
-		unsigned long tccs:8;
-		unsigned long twhr:8;
-		unsigned long trhw:8;
-		unsigned long:8;
-#endif
-	} __packed bits;
-} __packed nand_timing_control_register_2_t;
-
-typedef enum {
-	LSI_NAND_NONE, LSI_NAND_EP501, LSI_NAND_EP501G1, LSI_NAND_EP501G3
-} lsi_nand_type_t;
-
-static lsi_nand_type_t lsi_nand_type;
-
-typedef struct page_wise_ecc_status_st {
-	unsigned err_bit:3;
-	unsigned column:9;
-	unsigned status:2;
-	unsigned rsvd:18;
-} page_wise_ecc_status_t;
-
-/*
-  =============================================================================
-  =============================================================================
-  Concerning ECC
-
-  The EP501 only supports 1 bit ECC mode.  The EP501G1 supports both 1
-  bit and 4 bit modes.  The EP501G3 supports 4 bit, 8 bit, and 12 bit.
-  The NAND part normally used on ACP boards has 2K pages (supported by
-  all three controllers) with 64 bytes of OOB.  For a 2K page, 1 bit
-  ECC uses 12 bytes, 4 bit ECC uses 32 bytes, 8 bit ECC uses 64 bytes
-  and 12 bit ECC uses 80 bytes.  In order to to keep the bad block
-  markers (first two bytes) and leave some OOB available for file
-  systems etc., this driver only supports 1 bit ECC or 4 bit ECC.
-
-  For now, the EP501 version will use 1 bit ECC (only option), the
-  EP501G1 version will use 4 bit (for compabitility with the EP501G3)
-  and teh EP501G3 versions will use 4 bit (due to the amount of OOB
-  required and for compatibility with the EP501G1).
-
-  EP501
-
-  The driver has not been tested with small page (512 byte) devices.
-  The only usable option is 2K.  So, the OOB should be 64 bytes.  The
-  first 2 bytes are reserved for marking bad blocks.  The last 12
-  bytes are reserved for ECC.  All other bytes are free.  See
-  lsi_ep501_2k_ecclayout below.
-
-  EP501G1
-
-  This driver has been tested with 2K and 4K page sizes using 1 bit
-  and 4 bit ECC.
-  =============================================================================
-  =============================================================================
-*/
-
-static struct nand_ecclayout lsi_2k_1bit_ecclayout = {
-	.eccbytes = 12,
-	.eccpos = {
-		52, 53, 54, 55, 56, 57,
-		58, 59, 60, 61, 62, 63},
-	.oobfree = {{2, 50} }
-};
-
-/*
-static struct nand_ecclayout lsi_4k_1bit_ecclayout = {
-	.eccbytes = 24,
-	.eccpos = {
-		52, 53, 54, 55, 56, 57,
-		58, 59, 60, 61, 62, 63},
-	.oobfree = {{2, 50}}
-};
-*/
-
-static struct nand_ecclayout lsi_2k_4bit_ecclayout = {
-	.eccbytes = 32,
-	.eccpos = {
-		32, 33, 34, 35, 36, 37, 38, 39,
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
-		56, 57, 58, 59, 60, 61, 62, 63 },
-	.oobfree = {{2, 30} }
-};
-
-static struct nand_ecclayout lsi_4k_4bit_ecclayout = {
-	.eccbytes = 64,
-	.eccpos = {
-		64,  65,  66,  67,  68,  69,  70,  71,
-		72,  73,  74,  75,  76,  77,  78,  79,
-		80,  81,  82,  83,  84,  85,  86,  87,
-		88,  89,  90,  91,  92,  93,  94,  95,
-		96,  97,  98,  99, 100, 101, 102, 103,
-		104, 105, 106, 107, 108, 109, 110, 111,
-		112, 113, 114, 115, 116, 117, 118, 119,
-		120, 121, 122, 123, 124, 125, 126, 127
-	},
-	.oobfree = {{2, 63} }
-};
-
-#ifdef NOT_USED
-
-static struct nand_ecclayout lsi_8k_4bit_ecclayout = {
-	.eccbytes = 128,
-	.eccpos = {
-		128, 129, 130, 131, 132, 133, 134, 135,
-		136, 137, 138, 139, 140, 141, 142, 143,
-		144, 145, 146, 147, 148, 149, 150, 151,
-		152, 153, 154, 155, 156, 157, 158, 159,
-		160, 161, 162, 163, 164, 165, 166, 167,
-		168, 169, 170, 171, 172, 173, 174, 175,
-		176, 177, 178, 179, 180, 181, 182, 183,
-		184, 185, 186, 187, 188, 189, 190, 191,
-		192, 193, 194, 195, 196, 197, 198, 199,
-		200, 201, 202, 203, 204, 205, 206, 207,
-		208, 209, 210, 211, 212, 213, 214, 215,
-		216, 217, 218, 219, 220, 221, 222, 223,
-		224, 225, 226, 227, 228, 229, 230, 231,
-		232, 233, 234, 235, 236, 237, 238, 239,
-		240, 241, 242, 243, 244, 245, 246, 247,
-		248, 249, 250, 251, 252, 253, 254, 255
-	},
-	.oobfree = {{2, 126} }
-};
-
-#endif
-
-/*
-  -----------------------------------------------------------------------------
-  lsi_nand_hwcontrol
-*/
-
-static void
-lsi_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
-{
-	struct nand_chip *chip = mtd->priv;
-
-	if (cmd != NAND_CMD_NONE)
-		WRITEL(cmd, (chip->IO_ADDR_W + NAND_CMD_REG));
-}
-
-/*
-  ------------------------------------------------------------------------------
-  lsi_nand_device_ready
-
-  The READ/BUSY# input from the NAND device(s) (ORed if there are more
-  than one) is availble as an extra bit in the interrupt status
-  register.  Note that this register shouldn't be read unless the
-  controller is not in the middle of calculating ECC (see "Some
-  Oddities..." above).
-*/
-
-static int
-lsi_nand_device_ready(struct mtd_info *mtd)
-{
-	struct nand_chip *chip = mtd->priv;
-	unsigned long interrupt_status;
-
-	/* Get the status. */
-	interrupt_status = READL(chip->IO_ADDR_R + NAND_INTR_STATUS_REG);
-
-	return interrupt_status & NAND_STATUS_TRUE_READY;
-}
-
-/**
- * lsi_nand_command - [DEFAULT] Send command to NAND large page device
- * @mtd:	MTD device structure
- * @command:	the command to be sent
- * @column:	the column address for this command, -1 if none
- * @page_addr:	the page address for this command, -1 if none
- *
- * Send command to NAND device. This is the version for the new large page
- * devices We dont have the separate regions as we have in the small page
- * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
- */
-static void
-lsi_nand_command(struct mtd_info *mtd, unsigned int command,
-		 int column, int page_addr)
-{
-	register struct nand_chip *chip = mtd->priv;
-	unsigned int status = 0;
-	struct lsi_nand_private *priv = &lsi_nand_private;
-	struct device_node *np = NULL;
-
-	DEBUG_PRINT("command=0x%x\n", command);
-	command &= 0xff;
-
-	/* Emulate NAND_CMD_READOOB */
-	if (command == NAND_CMD_READOOB) {
-		column += mtd->writesize;
-		command = NAND_CMD_READ0;
-	}
-
-	/* return if unhandled command is issued */
-	if (command != NAND_CMD_READ0 &&
-	    command != NAND_CMD_SEQIN &&
-	    command != NAND_CMD_ERASE1 &&
-	    command != NAND_CMD_STATUS &&
-	    command != NAND_CMD_READID &&
-	    command != NAND_CMD_RESET &&
-	    command != NAND_CMD_START_ECC_READ &&
-	    command != NAND_CMD_PAGEPROG &&
-	    command != NAND_CMD_ERASE2) {
-		pr_err("lsi_nand_command(): WARN: Unhandled command 0x%x "
-		       "issued for page=0x%x, column=0x%x.\n",
-		       command, page_addr, column);
-		return;
-	}
-
-	priv->cur = -1;
-	/* Command latch cycle */
-	chip->cmd_ctrl(mtd, command,
-		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
-
-	if (column != -1 || page_addr != -1) {
-		unsigned long index = 0;
-		unsigned long extended_index = 0;
-
-		/* column number */
-		/*
-		  Since the ACP uses 8 bit device access, only that
-		  mode is supported.
-		*/
-
-		if (LSI_NAND_EP501 == lsi_nand_type) {
-			/* column number */
-			if (column != -1)
-				index = column & 0xfff;
-
-			/* page and block number */
-			if (page_addr != -1)
-				index += ((page_addr & 0x7ffff) << 12);
-		} else {
-			/* column number */
-			if (-1 != column) {
-				switch (mtd->writesize) {
-				case 512:
-					index |= (column & 0x1ff);
-					break;
-				case 2048:
-					index |= (column & 0xfff);
-					break;
-				case 4096:
-					index |= (column & 0x1fff);
-					break;
-				default:
-					break;
-				}
-			}
-
-			/* page_addr and block number */
-			if (-1 != page_addr) {
-				switch (mtd->writesize) {
-				case 512:
-					index |= (page_addr & 0x7fffff) << 9;
-					break;
-				case 2048:
-					index |= (page_addr & 0xfffff) << 12;
-					extended_index |=
-						(page_addr & 0xfff00000);
-					break;
-				case 4096:
-					index |= (page_addr & 0x7ffff) << 13;
-					extended_index |=
-						(page_addr & 0xfff80000);
-					break;
-				default:
-					break;
-				}
-			}
-		}
-
-		/* write index reg */
-		WRITEL(index, chip->IO_ADDR_W + NAND_INDEX_REG);
-
-		/* write ext index reg */
-		WRITEL(extended_index, chip->IO_ADDR_W + NAND_EXT_INDEX_REG);
-
-		/* Memory Barrier */
-		mb();
-	}
-
-	/* for read command, send 0xe0 so data is populated */
-	if (command == NAND_CMD_READ0) {
-		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
-			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
-		do {
-			udelay(chip->chip_delay);
-			status = READL((void *)pecc_busy_register);
-		} while (0 != (status & pecc_busy_mask));
-
-		/* wait until CHIP_BUSY goes low */
-		do {
-			udelay(chip->chip_delay);
-			status = chip->dev_ready(mtd);
-		} while (!status);
-	} else if (command == NAND_CMD_STATUS) {
-		udelay(chip->chip_delay);
-		priv->cur = 0;
-		priv->buf[0] = readb(chip->IO_ADDR_R + NAND_STATUS1_REG);
-	} else if (command == NAND_CMD_READID) {
-		priv->cur = 0;
-		priv->buf[0] = readb(chip->IO_ADDR_R + NAND_ID0_REG);
-		priv->buf[1] = readb(chip->IO_ADDR_R + NAND_ID2_REG);
-		priv->buf[2] = readb(chip->IO_ADDR_R + NAND_ID4_REG);
-		priv->buf[3] = readb(chip->IO_ADDR_R + NAND_ID6_REG);
-	}
-}
-
-/**
- * lsi_nand_read_buf - [DEFAULT] read chip data into buffer
- * @mtd:	MTD device structure
- * @buf:	buffer to store date
- * @len:	number of bytes to read
- *
- * Default read function for 8bit buswith
- */
-static void lsi_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
-{
-	int i = 0;
-	struct nand_chip *chip = (struct nand_chip *) mtd->priv;
-	uint32_t *p = (uint32_t *)buf;
-
-#if defined(LOGIO)
-	if (0 != enable_logio)
-		pr_notice("Reading NAND Buffer (len=%d)...\n", len);
-#endif
-
-	for (i = 0; i < (len >> 2); i++)
-		p[i] = readl(chip->IO_ADDR_R);
-}
-
-/**
- * lsi_nand_write_buf - [DEFAULT] write buffer to chip
- * @mtd:	MTD device structure
- * @buf:	data buffer
- * @len:	number of bytes to write
- *
- * Default write function for 8bit buswith
- */
-static void
-lsi_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
-{
-	int i = 0;
-	struct nand_chip *chip = mtd->priv;
-	uint32_t *p = (uint32_t *)buf;
-
-#if defined(LOGIO)
-	if (0 != enable_logio)
-		pr_notice("Writing NAND Buffer (len=%d)...\n", len);
-#endif
-
-	for (i = 0; i < (len >> 2); i++)
-		writel(p[i], chip->IO_ADDR_W);
-}
-
-static int lsi_nand_read_status(struct mtd_info *mtd)
-{
-	struct nand_chip *chip = mtd->priv;
-
-	chip->cmd_ctrl(mtd, NAND_CMD_STATUS, 0);
-
-	return READL(chip->IO_ADDR_R + NAND_STATUS1_REG) & 0xff;
-}
-
-
-/**
- * lsi_nand_wait - [DEFAULT]  wait until the command is done
- * @mtd:	MTD device structure
- * @chip:	NAND chip structure
- *
- * Wait for command done. This applies to erase and program only
- * Erase can take up to 400ms and program up to 20ms according to
- * general NAND and SmartMedia specs
- */
-static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
-{
-	unsigned long status = 0;
-	loff_t offset = 0;
-	struct device_node *np = NULL;
-
-	/*
-	  When reading or writing, wait for the
-	  controller's PECC_BUSY signal to clear.
-	*/
-#ifdef NOT_USED
-	if (FL_READING == chip->state || FL_WRITING == chip->state) {
-		for (;;) {
-			status = READL((void *)pecc_busy_register);
-
-			if (0 == (status & pecc_busy_mask))
-				break;
-
-			udelay(chip->chip_delay);
-		}
-	}
-#else
-	for (;;) {
-		status = READL((void *)pecc_busy_register);
-
-		if (0 == (status & pecc_busy_mask))
-			break;
-
-		udelay(chip->chip_delay);
-	}
-#endif
-
-	/*
-	  In all cases, wait for the NAND device to be "ready".
-
-	  N.B. The FL_READING case is handled in lsi_nand_command().
-	*/
-
-	if (FL_WRITING == chip->state || FL_ERASING == chip->state) {
-		for (;;) {
-			if (chip->dev_ready(mtd))
-				break;
-
-			udelay(chip->chip_delay);
-		}
-	}
-
-	/*
-	  Then get the status.
-	*/
-
-	for (;;) {
-		status = lsi_nand_read_status(mtd);
-
-		if (0 != (status & NAND_STATUS_READY))
-			break;
-
-		udelay(chip->chip_delay);
-	}
-
-	if (status & NAND_STATUS_FAIL) {
-		offset = (READL(chip->IO_ADDR_R + NAND_INDEX_REG) /
-			  mtd->writesize) * mtd->writesize;
-		pr_err("lsi_nand_wait(): Action %d failed for "
-		       "Offset: 0x%llx, status 0x%lx\n",
-		       chip->state, offset, status);
-	}
-
-	return status;
-}
-
-/*
-  lsi_nand_ecc_hwctl
-*/
-
-void
-lsi_nand_ecc_hwctl(struct mtd_info *mtd, int mode)
-{
-	/* nothing to do to enable ECC */
-}
-
-/**
- * lsi_nand_ecc_calculate
- */
-
-int
-lsi_nand_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
-		       uint8_t *ecc_code)
-{
-	struct nand_chip *chip = mtd->priv;
-
-	/* start ECC calculation */
-	if (chip->state == FL_READING)
-		chip->cmdfunc(mtd, NAND_CMD_START_ECC_READ, -1, -1);
-	else if (chip->state == FL_WRITING)
-		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
-
-	/* wait for PECC_BUSY to go down */
-	return chip->waitfunc(mtd, chip);
-}
-
-/**
- * lsi_nand_ecc_correct
- */
-
-int
-lsi_nand_ecc_correct(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
-		     uint8_t *calc_ecc)
-{
-	/* nothing to do to correct ECC */
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  report_ecc_errors_ep501
-*/
-
-static int
-report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buffer, int page)
-{
-	int rc = 0;
-	unsigned long ecc_status;
-	page_wise_ecc_status_t *ecc_status_reg =
-		(page_wise_ecc_status_t *)&ecc_status;
-	int column;
-	int i;
-
-	for (i = 0; i < (mtd->writesize >> 9); i++) {
-		ecc_status = READL(chip->IO_ADDR_R + EP501_NAND_PECC_REG);
-		column = (i << 9) + ecc_status_reg->column;
-
-		if (1 == ecc_status_reg->status) {
-			pr_notice("Single ECC Error: "
-				  "Page=0x%x Column=0x%x Bit=0x%x\n",
-				  page, column, ecc_status_reg->err_bit);
-
-			if (column < mtd->writesize) {
-				buffer[column] ^=
-					(1 << ecc_status_reg->err_bit);
-				++mtd->ecc_stats.corrected;
-			} else {
-				pr_err("Single ECC Error Not Corrected: "
-				       "Column 0x%x not in "
-				       "Page Size 0x%x\n",
-				       column, mtd->writesize);
-				rc = -1;
-			}
-		} else if ((ecc_status & 0x3000) == 2) {
-			pr_err("Uncorrectable ECC Error: "
-			       "Page=0x%x Column=0x%x\n",
-			       page, column);
-			rc = -1;
-		}
-	}
-
-	return rc;
-}
-
-int i_to_a[8192] = {
-	-1, 0, 1, 7953, 2, 7715, 7954, 3551, 3, 3313, 7716, 5441,
-	7955, 1529, 3552, 7477, 4, 7239, 3314, 1441, 7717, 7102, 5442,
-	1291, 7956, 7545, 1530, 3075, 3553, 5203, 7478, 2784, 5, 2546,
-	7240, 5080, 3315, 4596, 1442, 4965, 7718, 466, 7103, 7307,
-	5443, 2837, 1292, 822, 7957, 801, 7546, 7001, 1531, 1203,
-	3076, 4294, 3554, 1053, 5204, 3033, 7479, 6073, 2785, 6864, 6,
-	6626, 2547, 7658, 7241, 2691, 5081, 5835, 3316, 2893, 4597,
-	815, 1443, 2795, 4966, 2905, 7719, 3058, 467, 563, 7104, 6763,
-	7308, 1956, 5444, 4056, 2838, 838, 1293, 6335, 823, 965, 7958,
-	3626, 802, 2308, 7547, 4842, 7002, 7279, 1532, 4727, 1204,
-	2462, 3077, 8003, 4295, 4358, 3555, 584, 1054, 7877, 5205,
-	2629, 3034, 2599, 7480, 4992, 6074, 228, 2786, 7069, 6865,
-	6970, 7, 6732, 6627, 4178, 2548, 7845, 7659, 6831, 7242, 5051,
-	2692, 4754, 5082, 8181, 5836, 5864, 3317, 1826, 2894, 346,
-	4598, 7639, 816, 4352, 1444, 2361, 2796, 4313, 4967, 5263,
-	2906, 2391, 7720, 6584, 3059, 3388, 468, 2070, 564, 7693,
-	7105, 7041, 6764, 1387, 7309, 6882, 1957, 4604, 5445, 4120,
-	4057, 1433, 2839, 883, 839, 7765, 1294, 7442, 6336, 4489, 824,
-	2224, 966, 260, 7959, 5281, 3627, 6388, 803, 7420, 2309, 2970,
-	7548, 5597, 4843, 4681, 7003, 4373, 7280, 2453, 1533, 2667,
-	4728, 213, 1205, 7320, 2463, 2557, 3078, 34, 8004, 2655, 4296,
-	577, 4359, 4017, 3556, 727, 585, 4795, 1055, 3138, 7878, 6097,
-	5206, 440, 2630, 3818, 3035, 600, 2600, 7645, 7481, 4303,
-	4993, 2820, 6075, 325, 229, 7021, 2787, 1718, 7070, 8147,
-	6866, 2746, 6971, 6525, 8, 6287, 6733, 3363, 6628, 2882, 4179,
-	2508, 2549, 6263, 7846, 1480, 7660, 7909, 6832, 4562, 7243,
-	6013, 5052, 4065, 2693, 2582, 4755, 2138, 5083, 6783, 8182,
-	6197, 5837, 5184, 5865, 87, 3318, 7602, 1827, 489, 2895, 4557,
-	347, 7177, 4599, 5859, 7640, 2448, 817, 7472, 4353, 2900,
-	1445, 7407, 2362, 5907, 2797, 2639, 4314, 362, 4968, 3697,
-	5264, 202, 2907, 3580, 2392, 1752, 7721, 6899, 6585, 5043,
-	3060, 6150, 3389, 1846, 469, 2732, 2071, 6180, 565, 1726,
-	7694, 7182, 7106, 2215, 7042, 5823, 6765, 5568, 1388, 4135,
-	7310, 3237, 6883, 5359, 1958, 4443, 4605, 1761, 5446, 3779,
-	4121, 136, 4058, 1688, 1434, 339, 2840, 3670, 884, 7987, 840,
-	2417, 7766, 352, 1295, 4024, 7443, 2429, 6337, 8166, 4490,
-	7494, 825, 2319, 2225, 2611, 967, 2330, 261, 7082, 7960, 4389,
-	5282, 6494, 3628, 3940, 6389, 7145, 804, 6593, 7421, 1411,
-	2310, 4211, 2971, 7607, 7549, 5626, 5598, 1695, 4844, 283,
-	4682, 7943, 7004, 6125, 4374, 4813, 7281, 4516, 2454, 7979,
-	1534, 2153, 2668, 3174, 4729, 5507, 214, 5025, 1206, 4956,
-	7321, 2123, 2464, 4075, 2558, 3323, 3079, 1335, 35, 1588,
-	8005, 108, 2656, 6609, 4297, 4114, 578, 795, 4360, 1329, 4018,
-	7401, 3557, 22, 728, 6678, 586, 1995, 4796, 1986, 1056, 3018,
-	3139, 7204, 7879, 4251, 6098, 494, 5207, 4225, 441, 3882,
-	2631, 1195, 3819, 6271, 3036, 7527, 601, 6242, 2601, 5487,
-	7646, 645, 7482, 1544, 4304, 6346, 4994, 3150, 2821, 1857,
-	6076, 7455, 326, 2351, 230, 6456, 7022, 1832, 2788, 4366,
-	1719, 4244, 7071, 550, 8148, 6644, 6867, 3187, 2747, 6803,
-	6972, 1149, 6526, 6444, 9, 6206, 6288, 2811, 6734, 5427, 3364,
-	911, 6629, 4158, 2883, 2949, 4180, 6565, 2509, 3585, 2550,
-	1949, 6264, 4128, 7847, 4006, 1481, 989, 7661, 6406, 7910,
-	5343, 6833, 7568, 4563, 312, 7244, 1160, 6014, 1306, 5053,
-	6108, 4066, 1215, 2694, 1619, 2583, 2680, 4756, 1108, 2139,
-	2912, 5084, 1594, 6784, 3402, 8183, 6279, 6198, 6218, 5838,
-	3764, 5185, 7217, 5866, 2113, 88, 6037, 3319, 7397, 7603,
-	7975, 1828, 6440, 490, 641, 2896, 1748, 4558, 83, 348, 7078,
-	7178, 1757, 4600, 256, 5860, 2387, 7641, 6521, 2449, 4013,
-	818, 6860, 7473, 2780, 4354, 6966, 2901, 961, 1446, 407, 7408,
-	7924, 2363, 5326, 5908, 5249, 2798, 2340, 2640, 7289, 4315,
-	6004, 363, 2397, 4969, 41, 3698, 3987, 5265, 3644, 203, 8057,
-	2908, 6033, 3581, 308, 2393, 953, 1753, 957, 7722, 2263, 6900,
-	4151, 6586, 6256, 5044, 3306, 3061, 6907, 6151, 666, 3390,
-	3005, 1847, 3702, 470, 7369, 2733, 143, 2072, 1402, 6181,
-	3973, 566, 1497, 1727, 6355, 7695, 1173, 7183, 3991, 7107,
-	7741, 2216, 1321, 7043, 5295, 5824, 4278, 6766, 155, 5569,
-	5887, 1389, 4575, 4136, 4973, 7311, 1341, 3238, 5388, 6884,
-	1457, 5360, 5166, 1959, 7705, 4444, 6689, 4606, 7115, 1762,
-	45, 5447, 7163, 3780, 617, 4122, 2381, 137, 1091, 4059, 5817,
-	1689, 3876, 1435, 557, 340, 207, 2841, 538, 3671, 1097, 885,
-	1350, 7988, 7854, 841, 6371, 2418, 2295, 7767, 4908, 353,
-	8061, 1296, 3507, 4025, 1915, 7444, 2936, 2430, 8132, 6338,
-	4787, 8167, 1907, 4491, 5155, 7495, 5269, 826, 3085, 2320,
-	6297, 2226, 2922, 2612, 3837, 968, 6716, 2331, 4718, 262,
-	1885, 7083, 3648, 7961, 6226, 4390, 6049, 5283, 3125, 6495,
-	3250, 3629, 2270, 3941, 4434, 6390, 5127, 7146, 2644, 805,
-	4324, 6594, 5453, 7422, 4400, 1412, 7671, 2311, 4984, 4212,
-	6025, 2972, 1242, 7608, 7293, 7550, 8040, 5627, 7587, 5599,
-	4422, 1696, 4946, 4845, 5735, 284, 6545, 4683, 5959, 7944,
-	2802, 7005, 6615, 6126, 5775, 4375, 3827, 4814, 8070, 7282,
-	1900, 4517, 2992, 2455, 3811, 7980, 2344, 1535, 1514, 2154,
-	2242, 2669, 3606, 3175, 3342, 4730, 5994, 5508, 3459, 215,
-	8155, 5026, 367, 1207, 4938, 4957, 7169, 7322, 5669, 2124,
-	996, 2465, 124, 4076, 5897, 2559, 3950, 3324, 2401, 3080, 533,
-	1336, 7364, 36, 251, 1589, 1944, 8006, 6939, 109, 4524, 2657,
-	4933, 6610, 4319, 4298, 2662, 4115, 1821, 579, 3053, 796,
-	7234, 4361, 4220, 1330, 5621, 4019, 2210, 7402, 6008, 3558,
-	6844, 23, 7380, 729, 6506, 6679, 2092, 587, 7729, 1996, 2081,
-	4797, 2373, 1987, 7412, 1057, 4529, 3019, 3786, 3140, 2191,
-	7205, 7514, 7880, 7256, 4252, 3205, 6099, 4587, 495, 7928,
-	5208, 5401, 4226, 3541, 442, 8089, 3883, 176, 2632, 101, 1196,
-	876, 3820, 1224, 6272, 1450, 3037, 114, 7528, 3485, 602, 1231,
-	6243, 2179, 2602, 5612, 5488, 3432, 7647, 7749, 646, 411,
-	7483, 7864, 1545, 6661, 4305, 4805, 6347, 3197, 4995, 1608,
-	3151, 1137, 2822, 6651, 1858, 5912, 6077, 6944, 7456, 623,
-	327, 7810, 2352, 1488, 231, 4620, 6457, 2494, 7023, 5942,
-	1833, 5253, 2789, 1523, 4367, 8175, 1720, 7903, 4245, 4205,
-	7072, 6559, 551, 2999, 8149, 5121, 6645, 2367, 6868, 8011,
-	3188, 1977, 2748, 5585, 6804, 5377, 6973, 3897, 1150, 64,
-	6527, 4474, 6445, 5330, 10, 5092, 6207, 4692, 6289, 1969,
-	2812, 4236, 6735, 3709, 5428, 3659, 3365, 8017, 912, 7914,
-	6630, 1001, 4159, 7773, 2884, 1739, 2950, 4886, 4181, 5139,
-	6566, 5718, 2510, 3570, 3586, 5347, 2551, 4346, 1950, 1285,
-	6265, 7937, 4129, 2132, 7848, 3967, 4007, 983, 1482, 7508,
-	990, 7665, 7662, 2129, 6407, 4880, 7911, 4233, 5344, 4883,
-	6834, 5701, 7569, 6321, 4564, 2761, 313, 6410, 7245, 932,
-	1161, 7626, 6015, 6423, 1307, 2764, 5054, 2959, 6109, 4334,
-	4067, 6874, 1216, 4567, 2695, 5674, 1620, 4914, 2584, 1644,
-	2681, 6413, 4757, 4667, 1109, 1370, 2140, 899, 2913, 316,
-	5085, 5015, 1595, 5763, 6785, 712, 3403, 5704, 8184, 6725,
-	6280, 4382, 6199, 2256, 6219, 6837, 5839, 7327, 3765, 6706,
-	5186, 385, 7218, 6324, 5867, 1250, 2114, 867, 89, 1872, 6038,
-	7572, 3320, 5022, 7398, 6606, 7604, 7142, 7976, 7940, 1829,
-	1854, 6441, 6641, 491, 1983, 642, 6268, 2897, 7174, 1749, 359,
-	4559, 2505, 84, 2135, 349, 336, 7079, 7491, 7179, 1843, 1758,
-	4132, 4601, 7690, 257, 7762, 5861, 6828, 2388, 4349, 7642,
-	6094, 6522, 7018, 2450, 2967, 4014, 2554, 819, 4962, 6861,
-	4291, 7474, 3548, 2781, 1288, 4355, 7276, 6967, 2596, 2902,
-	5832, 962, 1953, 1447, 173, 408, 2176, 7409, 2089, 7925, 7511,
-	2364, 4202, 5327, 5374, 5909, 3194, 5250, 1485, 2799, 4943,
-	2341, 8067, 2641, 3247, 7290, 7668, 4316, 1941, 6005, 7231,
-	364, 3339, 2398, 993, 4970, 4275, 42, 5163, 3699, 3303, 3988,
-	3970, 5266, 8129, 3645, 3834, 204, 1088, 8058, 7851, 2909,
-	1212, 6034, 6215, 3582, 908, 309, 986, 2394, 5246, 954, 8054,
-	1754, 638, 958, 4010, 7723, 1602, 2264, 5988, 6901, 5811,
-	4152, 1742, 6587, 3012, 6257, 2726, 5045, 5591, 3307, 2887,
-	3062, 2406, 6908, 847, 6152, 397, 667, 4889, 3391, 3098, 3006,
-	2032, 1848, 4196, 3703, 2953, 471, 7055, 7370, 2015, 2734,
-	1631, 144, 1004, 2073, 658, 1403, 4746, 6182, 5787, 3974,
-	6633, 567, 3329, 1498, 4086, 1728, 5215, 6356, 7776, 7696,
-	7433, 1174, 7267, 7184, 2520, 3992, 4162, 7108, 2106, 7742,
-	3804, 2217, 6066, 1322, 3573, 7044, 2038, 5296, 1662, 5825,
-	2754, 4279, 2513, 6767, 3955, 156, 6377, 5570, 5537, 5888,
-	5350, 1390, 7832, 4576, 5546, 4137, 2279, 4974, 3589, 7312,
-	1187, 1342, 7802, 3239, 7349, 5389, 5142, 6885, 4708, 1458,
-	4821, 5361, 4045, 5167, 4184, 1960, 2564, 7706, 5418, 4445,
-	1563, 6690, 5721, 4607, 2980, 7116, 5497, 1763, 6307, 46,
-	6569, 5448, 5770, 7164, 1816, 3781, 3480, 618, 1972, 4123,
-	3397, 2382, 3982, 138, 5383, 1092, 6292, 4060, 5902, 5818,
-	2424, 1690, 1583, 3877, 4239, 1436, 6996, 558, 7872, 341,
-	1428, 208, 2815, 2842, 187, 539, 295, 3672, 7126, 1098, 5095,
-	886, 1706, 1351, 5876, 7989, 5062, 7855, 13, 842, 4081, 6372,
-	5413, 2419, 5408, 2296, 4695, 7768, 4875, 4909, 6701, 354,
-	4286, 8062, 6210, 1297, 5071, 3508, 1276, 4026, 2004, 1916,
-	8020, 7445, 3104, 2937, 4101, 2431, 6810, 8133, 3368, 6339,
-	129, 4788, 2301, 8168, 7357, 1908, 7917, 4492, 7795, 5156,
-	5756, 7496, 3221, 5270, 915, 827, 2163, 3086, 4499, 2321,
-	2201, 6298, 3712, 2227, 3114, 2923, 8077, 2613, 5659, 3838,
-	6738, 969, 2470, 6717, 4700, 2332, 6931, 4719, 3662, 263, 758,
-	1886, 4864, 7084, 1804, 3649, 5431, 7962, 6792, 6227, 5968,
-	4391, 2573, 6050, 388, 5284, 673, 3126, 699, 6496, 3903, 3251,
-	5189, 3630, 3347, 2271, 891, 3942, 6958, 4435, 6327, 6391,
-	3855, 5128, 3920, 7147, 2711, 2645, 7221, 806, 74, 4325, 3517,
-	6595, 504, 5454, 7330, 7423, 3687, 4401, 6168, 1413, 5105,
-	7672, 5842, 2312, 3180, 4985, 1711, 4213, 3890, 6026, 6709,
-	2973, 751, 1243, 5239, 7609, 2045, 7294, 3768, 7551, 5799,
-	8041, 6752, 5628, 2854, 7588, 1875, 5600, 4895, 4423, 3526,
-	1697, 6979, 4947, 92, 4846, 3611, 5736, 1356, 285, 3164, 6546,
-	7575, 4684, 5980, 5960, 1023, 7945, 3355, 2803, 6041, 7006,
-	6162, 6616, 922, 6127, 1068, 5776, 1253, 4376, 977, 3828,
-	7012, 4815, 4740, 8071, 5870, 7283, 2674, 1901, 5881, 4518,
-	6539, 2993, 870, 2456, 7301, 3812, 1381, 7981, 2442, 2345,
-	2117, 1536, 719, 1515, 3499, 2155, 4267, 2243, 715, 2670,
-	6158, 3607, 5795, 3176, 70, 3343, 6788, 4731, 2247, 5995,
-	7994, 5509, 3749, 3460, 5707, 216, 7819, 8156, 1553, 5027,
-	5312, 368, 3406, 1208, 4271, 4939, 169, 4958, 7686, 7170,
-	5018, 7323, 5011, 5670, 928, 2125, 4342, 997, 5088, 2466,
-	2159, 125, 5067, 4077, 183, 5898, 5766, 2560, 1183, 3951,
-	2102, 3325, 7051, 2402, 1598, 3081, 3503, 534, 7159, 1337,
-	7737, 7365, 2259, 37, 403, 252, 7393, 1590, 1156, 1945, 6202,
-	8007, 1519, 6940, 7860, 110, 5397, 4525, 6840, 2658, 529,
-	4934, 1510, 6611, 8036, 4320, 6222, 4299, 723, 2663, 5277,
-	4116, 6580, 1822, 6728, 580, 3622, 3054, 6622, 797, 2542,
-	7235, 8187, 4362, 1540, 4221, 18, 1331, 2149, 5622, 4385,
-	4020, 3775, 2211, 6895, 7403, 7598, 6009, 6283, 3559, 3410,
-	6845, 1031, 24, 1931, 7381, 1647, 730, 6914, 6507, 6478, 6680,
-	4480, 2093, 2587, 588, 372, 7730, 2847, 1997, 6059, 2082,
-	6416, 4798, 3599, 2374, 6433, 1988, 6143, 7413, 2684, 1058,
-	5316, 4530, 3269, 3020, 1677, 3787, 5677, 3141, 7894, 2192,
-	1074, 7206, 8113, 7515, 2698, 7881, 5031, 7257, 192, 4253,
-	449, 3206, 4917, 6100, 4414, 4588, 4549, 496, 1669, 7929,
-	1623, 5209, 1557, 5402, 6925, 4227, 379, 3542, 902, 443, 853,
-	8090, 2531, 3884, 6533, 177, 2143, 2633, 8160, 102, 544, 1197,
-	2623, 877, 319, 3821, 3047, 1225, 5579, 6273, 3638, 1451,
-	2916, 3038, 7823, 115, 3228, 7529, 5689, 3486, 4670, 603,
-	2478, 1232, 6133, 6244, 2057, 2180, 4760, 2603, 220, 5613,
-	300, 5489, 859, 3433, 1373, 7648, 7616, 7750, 3441, 647, 3721,
-	412, 1112, 7484, 5711, 7865, 2025, 1546, 3913, 6662, 6426,
-	4306, 3068, 4806, 6190, 6348, 5336, 3198, 6018, 4996, 3464,
-	1609, 3677, 3152, 780, 1138, 2767, 2823, 1267, 6652, 6669,
-	1859, 428, 5913, 1310, 6078, 3753, 6945, 5475, 7457, 1127,
-	624, 935, 328, 6988, 7811, 1259, 2353, 6117, 1489, 7248, 232,
-	5513, 4621, 7131, 6458, 8096, 2495, 7629, 7024, 3735, 5943,
-	1789, 1834, 5303, 5254, 1164, 2790, 7998, 1524, 2832, 4368,
-	595, 8176, 6877, 1721, 2412, 7904, 7467, 4246, 6451, 4206,
-	4070, 7073, 5999, 6560, 1103, 552, 5150, 3000, 4570, 8150,
-	4928, 5122, 5954, 6646, 5116, 2368, 1219, 6869, 2251, 8012,
-	7503, 3189, 1083, 1978, 2962, 2749, 4040, 5586, 5782, 6805,
-	5654, 5378, 5057, 6974, 4735, 3898, 5100, 1151, 2537, 65,
-	4337, 6528, 2052, 4475, 8108, 6446, 5649, 5331, 6112, 11,
-	5874, 5093, 293, 6208, 6699, 4693, 5411, 6290, 3980, 1970,
-	1814, 2813, 7870, 4237, 2422, 6736, 8075, 3710, 4497, 5429,
-	4862, 3660, 4698, 3366, 4099, 8018, 1274, 913, 5754, 7915,
-	2299, 6631, 4744, 1002, 2013, 4160, 7265, 7774, 4084, 2885,
-	2724, 1740, 5986, 2951, 2030, 4887, 845, 4182, 4819, 5140,
-	7800, 6567, 5495, 5719, 5416, 2511, 1660, 3571, 3802, 3587,
-	5544, 5348, 6375, 2552, 7016, 4347, 7760, 1951, 2594, 1286,
-	4289, 6266, 6639, 7938, 6604, 4130, 7489, 2133, 357, 7849,
-	3832, 3968, 5161, 4008, 8052, 984, 6213, 1483, 5372, 7509,
-	2174, 991, 7229, 7666, 8065, 7663, 981, 2130, 1283, 6408,
-	6319, 4881, 4878, 7912, 3657, 4234, 4690, 5345, 5716, 4884,
-	7771, 6835, 4380, 5702, 5761, 7570, 865, 6322, 6704, 4565,
-	4332, 2762, 7624, 314, 1368, 6411, 4912, 7246, 1257, 933,
-	5473, 1162, 1787, 7627, 7129, 6016, 6188, 6424, 2023, 1308,
-	6667, 2765, 3675, 5055, 5780, 2960, 7501, 6110, 8106, 4335,
-	5098, 4068, 7465, 6875, 2830, 1217, 5952, 4568, 1101, 2696,
-	1072, 5675, 3267, 1621, 4547, 4915, 190, 2585, 6476, 1645,
-	1029, 2682, 6431, 6414, 2845, 4758, 6131, 4668, 3226, 1110,
-	3439, 1371, 298, 2141, 2529, 900, 6923, 2914, 5577, 317, 542,
-	5086, 926, 5016, 167, 1596, 2100, 5764, 5065, 6786, 5793, 713,
-	3497, 3404, 1551, 5705, 7992, 8185, 6620, 6726, 5275, 6281,
-	6893, 4383, 16, 6200, 7391, 2257, 7157, 6220, 1508, 6838,
-	7858, 5840, 6166, 7328, 3515, 3766, 5237, 6707, 1709, 5187,
-	697, 386, 5966, 7219, 3918, 6325, 889, 5868, 7010, 1251, 920,
-	2115, 1379, 868, 5879, 90, 3524, 1873, 6750, 6039, 1021, 7573,
-	1354, 3321, 2121, 5023, 3172, 7399, 793, 6607, 1586, 7605,
-	1409, 7143, 6492, 7977, 4811, 7941, 1693, 1830, 2349, 1855,
-	6344, 6442, 6801, 6642, 4242, 492, 7202, 1984, 6676, 643,
-	6240, 6269, 3880, 2898, 2446, 7175, 487, 1750, 200, 360, 5905,
-	4560, 1478, 2506, 3361, 85, 6195, 2136, 4063, 350, 7985, 337,
-	134, 7080, 2609, 7492, 2427, 7180, 6178, 1844, 5041, 1759,
-	5357, 4133, 5821, 4602, 1385, 7691, 3386, 258, 4487, 7763,
-	1431, 5862, 4752, 6829, 4176, 2389, 4311, 4350, 344, 7643,
-	3816, 6095, 4793, 6523, 8145, 7019, 2818, 2451, 4679, 2968,
-	6386, 4015, 2653, 2555, 211, 820, 7305, 4963, 5078, 6862,
-	3031, 4292, 6999, 7475, 5439, 3549, 7951, 2782, 3073, 1289,
-	1439, 4356, 2460, 7277, 2306, 6968, 226, 2597, 7875, 2903,
-	813, 5833, 7656, 963, 836, 1954, 561, 1448, 874, 174, 3539,
-	409, 3430, 2177, 3483, 7410, 2079, 2090, 7378, 7926, 3203,
-	7512, 3784, 2365, 2997, 4203, 8173, 5328, 62, 5375, 1975,
-	5910, 1135, 3195, 6659, 5251, 2492, 1486, 621, 2800, 6543,
-	4944, 7585, 2342, 2990, 8068, 5773, 2642, 4432, 3248, 6047,
-	7291, 6023, 7669, 5451, 4317, 4522, 1942, 7362, 6006, 5619,
-	7232, 1819, 365, 3457, 3340, 2240, 2399, 5895, 994, 7167,
-	4971, 5885, 4276, 1319, 43, 6687, 5164, 5386, 3700, 664, 3304,
-	4149, 3989, 6353, 3971, 141, 5267, 1905, 8130, 1913, 3646,
-	4716, 3835, 6295, 205, 3874, 1089, 615, 8059, 2293, 7852,
-	1095, 2910, 2678, 1213, 1304, 6035, 7215, 6216, 3400, 3583,
-	2947, 909, 2809, 310, 5341, 987, 4126, 2395, 7287, 5247, 7922,
-	955, 306, 8055, 3985, 1755, 81, 639, 7973, 959, 2778, 4011,
-	2385, 7724, 96, 1603, 6554, 2265, 5730, 5989, 6934, 6902, 150,
-	5812, 4782, 4153, 1614, 1743, 2335, 6588, 4951, 3013, 7450,
-	6258, 5854, 2727, 3665, 5046, 7036, 5592, 435, 3308, 461,
-	2888, 4722, 3063, 6983, 2407, 4035, 6909, 7889, 848, 2473,
-	6153, 5006, 398, 3617, 668, 3682, 4890, 972, 3392, 1701, 3099,
-	3109, 3007, 653, 2033, 4703, 1849, 6089, 4197, 8124, 3704,
-	3962, 2954, 6720, 472, 3530, 7056, 4775, 7371, 6485, 2016,
-	1807, 2735, 1010, 1632, 513, 145, 5001, 1005, 7087, 2074,
-	4427, 659, 2942, 1404, 1473, 4747, 5434, 6183, 6471, 5788,
-	692, 3975, 2719, 6634, 3652, 568, 4899, 3330, 8027, 1499,
-	3279, 4087, 761, 1729, 7092, 5216, 4852, 6357, 3469, 7777,
-	266, 7697, 5604, 7434, 4106, 1175, 3727, 7268, 4867, 7185,
-	5461, 2521, 3449, 3993, 5930, 4163, 1889, 7109, 1879, 2107,
-	947, 7743, 4468, 3805, 2204, 2218, 2740, 6067, 7063, 1323,
-	1143, 3574, 2324, 7045, 7592, 2039, 2436, 5297, 5643, 1663,
-	3715, 5826, 632, 2755, 1866, 4280, 1798, 2514, 6301, 6768,
-	2858, 3956, 5924, 157, 684, 6378, 2166, 5571, 1015, 5538,
-	1362, 5889, 2772, 5351, 830, 1391, 5632, 7833, 6815, 4577,
-	418, 5547, 4502, 4138, 7193, 2280, 739, 4975, 6774, 3590,
-	3089, 7313, 6756, 1188, 5561, 1343, 6514, 7803, 5662, 3240,
-	1637, 7350, 5530, 5390, 3157, 5143, 2616, 6886, 8045, 4709,
-	8138, 1459, 1466, 4822, 6741, 5362, 4635, 4046, 4657, 5168,
-	3288, 4185, 3841, 1961, 5803, 2565, 1923, 7707, 2874, 5419,
-	3117, 4446, 518, 1564, 5742, 6691, 785, 5722, 2230, 4608,
-	7555, 2981, 3373, 7117, 1118, 5498, 8080, 1764, 7337, 6308,
-	4831, 47, 2864, 6570, 2926, 5449, 6045, 5771, 7583, 7165,
-	2238, 1817, 7360, 3782, 7376, 3481, 3537, 619, 6657, 1973,
-	8171, 4124, 2807, 3398, 1302, 2383, 7971, 3983, 7920, 139,
-	4147, 5384, 1317, 1093, 613, 6293, 1911, 4061, 3359, 5903,
-	485, 5819, 5039, 2425, 132, 1691, 6490, 1584, 3170, 3878,
-	6674, 4240, 6342, 1437, 7949, 6997, 5076, 559, 7654, 7873,
-	2304, 342, 4174, 1429, 3384, 209, 6384, 2816, 4791, 2843,
-	1027, 188, 3265, 540, 6921, 296, 3224, 3673, 2021, 7127, 5471,
-	1099, 2828, 5096, 7499, 887, 5964, 1707, 3513, 1352, 6748,
-	5877, 918, 7990, 3495, 5063, 165, 7856, 7155, 14, 5273, 843,
-	5984, 4082, 2011, 6373, 3800, 5414, 7798, 2420, 1812, 5409,
-	291, 2297, 1272, 4696, 4495, 7769, 4688, 4876, 1281, 4910,
-	7622, 6702, 5759, 355, 6602, 4287, 7758, 8063, 2172, 6211,
-	5159, 1298, 7579, 5072, 481, 3509, 3261, 1277, 2007, 4027,
-	477, 2005, 479, 1917, 5918, 8021, 4029, 7446, 6550, 3105,
-	4031, 2938, 4771, 4102, 8023, 2432, 943, 6811, 5920, 8134,
-	5557, 3369, 1919, 6340, 3168, 130, 483, 4789, 3382, 2302,
-	5074, 8169, 3535, 7358, 7581, 1909, 1315, 7918, 1300, 4493,
-	289, 7796, 2009, 5157, 7756, 5757, 1279, 7497, 5469, 3222,
-	3263, 5271, 163, 916, 3511, 828, 1360, 2164, 5922, 3087, 737,
-	4500, 6813, 2322, 7061, 2202, 945, 6299, 1864, 3713, 2434,
-	2228, 5740, 3115, 1921, 2924, 4829, 8078, 3371, 2614, 5528,
-	5660, 5559, 3839, 4655, 6739, 8136, 970, 3615, 2471, 4033,
-	6718, 8122, 4701, 3107, 2333, 4780, 6932, 6552, 4720, 433,
-	3663, 7448, 264, 4850, 759, 8025, 1887, 3447, 4865, 4104,
-	7085, 511, 1805, 4773, 3650, 690, 5432, 2940, 7963, 5846,
-	6793, 4854, 6228, 4454, 5969, 5218, 4392, 3998, 2574, 7094,
-	6051, 6950, 389, 1731, 5285, 7676, 674, 268, 3127, 5226, 700,
-	7779, 6497, 3931, 3904, 3471, 3252, 3421, 5190, 6359, 3631,
-	5109, 3348, 8029, 2272, 3214, 892, 3332, 3943, 5935, 6959,
-	4901, 4436, 5480, 6328, 570, 6392, 1417, 3856, 763, 5129,
-	7535, 3921, 4089, 7148, 4648, 2712, 3281, 2646, 2286, 7222,
-	1501, 807, 6172, 75, 3451, 4326, 1654, 3518, 2523, 6596, 4168,
-	505, 5463, 5455, 6083, 7331, 7187, 7424, 4405, 3688, 1891,
-	4402, 4642, 6169, 4165, 1414, 4645, 5106, 5932, 7673, 3928,
-	5843, 3995, 2313, 3691, 3181, 4108, 4986, 1047, 1712, 7436,
-	4214, 1894, 3891, 5606, 6027, 3758, 6710, 7699, 2974, 7427,
-	752, 4869, 1244, 5695, 5240, 7270, 7610, 4408, 2046, 3729,
-	7295, 745, 3769, 1177, 7552, 7334, 5800, 515, 8042, 4632,
-	6753, 1634, 5629, 7190, 2855, 1012, 7589, 629, 1876, 2737,
-	5601, 5458, 4896, 7089, 4424, 6468, 3527, 1007, 1698, 6086,
-	6980, 5003, 4948, 7033, 93, 147, 4847, 508, 3612, 4777, 5737,
-	5525, 1357, 7058, 286, 5466, 3165, 3532, 6547, 940, 7576, 474,
-	4685, 6599, 5981, 1809, 5961, 3492, 1024, 2018, 7946, 4171,
-	3356, 6487, 2804, 4144, 6042, 7373, 7007, 3521, 6163, 694,
-	6617, 7388, 923, 5790, 6128, 2526, 1069, 6473, 5777, 7462,
-	1254, 6185, 4377, 4329, 978, 3654, 3829, 5369, 7013, 6636,
-	4816, 1657, 4741, 2721, 8072, 4096, 5871, 3977, 7284, 78,
-	2675, 2944, 1902, 3871, 5882, 661, 4519, 3454, 6540, 4429,
-	2994, 1132, 871, 2076, 2457, 810, 7302, 5436, 3813, 4676,
-	1382, 4749, 7982, 6175, 2443, 1475, 2346, 7199, 2118, 1406,
-	1537, 3772, 720, 3619, 1516, 526, 3500, 400, 2156, 1180, 4268,
-	5008, 2244, 7816, 716, 6155, 2671, 7298, 6159, 974, 3608,
-	5977, 5796, 4892, 3177, 748, 71, 3684, 3344, 3852, 6789, 670,
-	4732, 2049, 2248, 4037, 5996, 4925, 7995, 2409, 5510, 3732,
-	3750, 6985, 3461, 1264, 5708, 3065, 217, 7613, 7820, 2475,
-	8157, 3044, 1554, 850, 5028, 4411, 5313, 7891, 369, 3596,
-	3407, 6911, 1209, 5243, 4272, 8126, 4940, 1938, 170, 4199,
-	4959, 7273, 7687, 6091, 7171, 333, 5019, 1851, 7324, 1247,
-	5012, 6722, 5671, 4664, 929, 2956, 2126, 5698, 4343, 3964,
-	998, 5136, 5089, 3706, 2467, 755, 2160, 3111, 126, 7792, 5068,
-	3101, 4078, 4872, 184, 1703, 5899, 6993, 5767, 3394, 2561,
-	2977, 1184, 4705, 3952, 7829, 2103, 2035, 3326, 7430, 7052,
-	655, 2403, 3095, 1599, 3009, 3082, 6713, 3504, 4784, 535,
-	6368, 7160, 5814, 1338, 7702, 7738, 152, 7366, 1494, 2260,
-	6904, 38, 6030, 404, 2337, 253, 6857, 7394, 1745, 1591, 3761,
-	1157, 1616, 1946, 6403, 6203, 4155, 8008, 3894, 1520, 6556,
-	6941, 4617, 7861, 1605, 111, 5609, 5398, 98, 4526, 7253, 6841,
-	7726, 2659, 4217, 530, 6936, 4935, 121, 1511, 5991, 6612,
-	1897, 8037, 5732, 4321, 4981, 6223, 2267, 4300, 1715, 724,
-	437, 2664, 31, 5278, 5594, 4117, 7439, 6581, 7038, 1823, 2358,
-	6729, 5048, 581, 4989, 3623, 4724, 3055, 4053, 6623, 2890,
-	798, 1050, 2543, 463, 7236, 7542, 8188, 3310, 4363, 3184,
-	1541, 7452, 4222, 7524, 19, 3015, 1332, 4111, 2150, 4953,
-	5623, 6122, 4386, 6590, 4021, 2316, 3776, 3667, 2212, 3234,
-	6896, 2729, 7404, 3694, 7599, 5856, 6010, 6780, 6284, 6260,
-	3560, 5193, 3411, 5744, 6846, 1572, 1032, 1566, 25, 6362,
-	1932, 520, 7382, 4626, 1648, 4448, 731, 3255, 6915, 2232,
-	6508, 4462, 6479, 5724, 6681, 3424, 4481, 787, 2094, 1781,
-	2588, 6693, 589, 3907, 373, 1925, 7731, 4261, 2848, 2567,
-	1998, 3474, 6060, 5805, 2083, 7136, 6417, 1963, 4799, 6500,
-	3600, 3119, 2375, 6250, 6434, 5421, 1989, 3934, 6144, 2876,
-	7414, 7839, 2685, 7709, 1059, 703, 5317, 4833, 4531, 1038,
-	3270, 6310, 3021, 7782, 1678, 7339, 3788, 237, 5678, 1766,
-	3142, 3130, 7895, 2928, 2193, 3295, 1075, 6572, 7207, 5229,
-	8114, 2866, 7516, 3863, 2699, 49, 7882, 677, 5032, 3375, 7258,
-	4540, 193, 2983, 4254, 271, 450, 7557, 3207, 5518, 4918, 4610,
-	6101, 5288, 4415, 8082, 4589, 2063, 4550, 5500, 497, 7679,
-	1670, 1120, 7930, 6821, 1624, 7119, 5210, 392, 1558, 5532,
-	5403, 1578, 6926, 7352, 4228, 1734, 380, 1639, 3543, 2500,
-	903, 3242, 444, 6054, 854, 2618, 8091, 775, 2532, 5145, 3885,
-	6953, 6534, 3159, 178, 3744, 2144, 5392, 2634, 2577, 8161,
-	5563, 103, 278, 545, 1190, 1198, 7097, 2624, 6758, 878, 7634,
-	320, 7315, 3822, 4395, 3048, 5664, 1226, 2186, 5580, 7805,
-	6274, 4001, 3639, 6516, 1452, 1397, 2917, 1345, 3039, 5972,
-	7824, 4659, 116, 6852, 3229, 4048, 7530, 5221, 5690, 4637,
-	3487, 6463, 4671, 5364, 604, 6231, 2479, 3843, 1233, 5175,
-	6134, 4187, 6245, 4457, 2058, 3290, 2181, 770, 4761, 5170,
-	2604, 6796, 221, 8140, 5614, 57, 301, 4711, 5490, 4857, 860,
-	8047, 3434, 8101, 1374, 6888, 7649, 7966, 7617, 6743, 7751,
-	4766, 3442, 4824, 648, 5849, 3722, 1468, 413, 5638, 1113,
-	1461, 7485, 7225, 5712, 1364, 7866, 5750, 2026, 5540, 1547,
-	1504, 3914, 1017, 6663, 5948, 6427, 5573, 4307, 2649, 3069,
-	832, 4807, 6236, 6191, 5353, 6349, 2289, 5337, 2774, 3199,
-	2488, 6019, 5891, 4997, 2715, 3465, 5926, 1610, 457, 3678,
-	3958, 3153, 3284, 781, 2860, 1139, 1794, 2768, 6770, 2824,
-	7151, 1268, 2168, 6653, 609, 6670, 6380, 1860, 4651, 429, 686,
-	5914, 5553, 1311, 159, 6079, 3924, 3754, 741, 6946, 3417,
-	5476, 2282, 7458, 4092, 1128, 7195, 625, 7029, 936, 4140, 329,
-	5132, 6989, 3091, 7812, 3848, 1260, 3592, 2354, 7538, 6118,
-	6776, 1490, 6399, 7249, 4977, 233, 3859, 5514, 6817, 4622,
-	1777, 7132, 7835, 6459, 766, 8097, 5634, 2496, 3740, 7630,
-	1393, 7025, 6395, 3736, 4504, 5944, 2484, 1790, 5549, 1835,
-	1420, 5304, 420, 5255, 4508, 1165, 4579, 2791, 6331, 7999,
-	7065, 1525, 5199, 2833, 6069, 4369, 573, 596, 2742, 8177,
-	5259, 6878, 2220, 1722, 4439, 2413, 2326, 7905, 5180, 7468,
-	3576, 4247, 5483, 6452, 1145, 4207, 4512, 4071, 1325, 7074,
-	6962, 6000, 949, 6561, 7564, 1104, 2109, 553, 4904, 5151,
-	1881, 3001, 1169, 4571, 7111, 8151, 3946, 4929, 2206, 5123,
-	1238, 5955, 3807, 6647, 5938, 5117, 4470, 2369, 4583, 1220,
-	7745, 6870, 895, 2252, 1868, 8013, 3566, 7504, 2757, 3190,
-	3335, 1084, 634, 1979, 1839, 2963, 5828, 2750, 2275, 4041,
-	6303, 5587, 4192, 5783, 2516, 6806, 3217, 5655, 1800, 5379,
-	1424, 5058, 4282, 6975, 3351, 4736, 2438, 3899, 2707, 5101,
-	2041, 1152, 8032, 2538, 7594, 66, 5308, 4338, 7047, 6529,
-	3634, 2053, 3717, 4476, 6139, 8109, 1665, 6447, 5112, 5650,
-	5645, 5332, 424, 6113, 5299, 12, 5061, 5875, 1705, 5094, 7125,
-	294, 186, 6209, 4285, 6700, 4874, 4694, 5407, 5412, 4080,
-	6291, 5382, 3981, 3396, 1971, 3479, 1815, 5769, 2814, 1427,
-	7871, 6995, 4238, 1582, 2423, 5901, 6737, 5658, 8076, 3113,
-	3711, 2200, 4498, 2162, 5430, 1803, 4863, 757, 3661, 6930,
-	4699, 2469, 3367, 6809, 4100, 3103, 8019, 2003, 1275, 5070,
-	914, 3220, 5755, 7794, 7916, 7356, 2300, 128, 6632, 5786,
-	4745, 657, 1003, 1630, 2014, 7054, 4161, 2519, 7266, 7432,
-	7775, 5214, 4085, 3328, 2886, 5590, 2725, 3011, 1741, 5810,
-	5987, 1601, 2952, 4195, 2031, 3097, 4888, 396, 846, 2405,
-	4183, 4044, 4820, 4707, 5141, 7348, 7801, 1186, 6568, 6306,
-	5496, 2979, 5720, 1562, 5417, 2563, 2512, 2753, 1661, 2037,
-	3572, 6065, 3803, 2105, 3588, 2278, 5545, 7831, 5349, 5536,
-	6376, 3954, 2553, 2966, 7017, 6093, 4348, 6827, 7761, 7689,
-	1952, 5831, 2595, 7275, 1287, 3547, 4290, 4961, 6267, 1982,
-	6640, 1853, 7939, 7141, 6605, 5021, 4131, 1842, 7490, 335,
-	2134, 2504, 358, 7173, 7850, 1087, 3833, 8128, 3969, 3302,
-	5162, 4274, 4009, 637, 8053, 5245, 985, 907, 6214, 1211, 1484,
-	3193, 5373, 4201, 7510, 2088, 2175, 172, 992, 3338, 7230,
-	1940, 7667, 3246, 8066, 4942, 7664, 7507, 982, 3966, 2131,
-	7936, 1284, 4345, 6409, 2760, 6320, 5700, 4882, 4232, 4879,
-	2128, 7913, 8016, 3658, 3708, 4235, 1968, 4691, 5091, 5346,
-	3569, 5717, 5138, 4885, 1738, 7772, 1000, 6836, 2255, 4381,
-	6724, 5703, 711, 5762, 5014, 7571, 1871, 866, 1249, 6323, 384,
-	6705, 7326, 4566, 6873, 4333, 2958, 2763, 6422, 7625, 931,
-	315, 898, 1369, 4666, 6412, 1643, 4913, 5673, 7247, 6116,
-	1258, 6987, 934, 1126, 5474, 3752, 1163, 5302, 1788, 3734,
-	7628, 8095, 7130, 5512, 6017, 5335, 6189, 3067, 6425, 3912,
-	2024, 5710, 1309, 427, 6668, 1266, 2766, 779, 3676, 3463,
-	5056, 5653, 5781, 4039, 2961, 1082, 7502, 2250, 6111, 5648,
-	8107, 2051, 4336, 2536, 5099, 4734, 4069, 6450, 7466, 2411,
-	6876, 594, 2831, 7997, 1218, 5115, 5953, 4927, 4569, 5149,
-	1102, 5998, 2697, 8112, 1073, 7893, 5676, 1676, 3268, 5315,
-	1622, 1668, 4548, 4413, 4916, 448, 191, 5030, 2586, 4479,
-	6477, 6913, 1646, 1930, 1030, 3409, 2683, 6142, 6432, 3598,
-	6415, 6058, 2846, 371, 4759, 2056, 6132, 2477, 4669, 5688,
-	3227, 7822, 1111, 3720, 3440, 7615, 1372, 858, 299, 219, 2142,
-	6532, 2530, 852, 901, 378, 6924, 1556, 2915, 3637, 5578, 3046,
-	318, 2622, 543, 8159, 5087, 4341, 927, 5010, 5017, 7685, 168,
-	4270, 1597, 7050, 2101, 1182, 5765, 182, 5066, 2158, 6787, 69,
-	5794, 6157, 714, 4266, 3498, 718, 3405, 5311, 1552, 7818,
-	5706, 3748, 7993, 2246, 8186, 2541, 6621, 3621, 6727, 6579,
-	5276, 722, 6282, 7597, 6894, 3774, 4384, 2148, 17, 1539, 6201,
-	1155, 7392, 402, 2258, 7736, 7158, 3502, 6221, 8035, 1509,
-	528, 6839, 5396, 7859, 1518, 5841, 5104, 6167, 3686, 7329,
-	503, 3516, 73, 3767, 2044, 5238, 750, 6708, 3889, 1710, 3179,
-	5188, 3902, 698, 672, 387, 2572, 5967, 6791, 7220, 2710, 3919,
-	3854, 6326, 6957, 890, 3346, 5869, 4739, 7011, 976, 1252,
-	1067, 921, 6161, 2116, 2441, 1380, 7300, 869, 6538, 5880,
-	2673, 91, 6978, 3525, 4894, 1874, 2853, 6751, 5798, 6040,
-	3354, 1022, 5979, 7574, 3163, 1355, 3610, 3322, 4074, 2122,
-	4955, 5024, 5506, 3173, 2152, 7400, 1328, 794, 4113, 6608,
-	107, 1587, 1334, 7606, 4210, 1410, 6592, 7144, 3939, 6493,
-	4388, 7978, 4515, 4812, 6124, 7942, 282, 1694, 5625, 1831,
-	6455, 2350, 7454, 1856, 3149, 6345, 1543, 6443, 1148, 6802,
-	3186, 6643, 549, 4243, 4365, 493, 4250, 7203, 3017, 1985,
-	1994, 6677, 21, 644, 5486, 6241, 7526, 6270, 1194, 3881, 4224,
-	2899, 7471, 2447, 5858, 7176, 4556, 488, 7601, 1751, 3579,
-	201, 3696, 361, 2638, 5906, 7406, 4561, 7908, 1479, 6262,
-	2507, 2881, 3362, 6286, 86, 5183, 6196, 6782, 2137, 2581,
-	4064, 6012, 351, 2416, 7986, 3669, 338, 1687, 135, 3778, 7081,
-	2329, 2610, 2318, 7493, 8165, 2428, 4023, 7181, 1725, 6179,
-	2731, 1845, 6149, 5042, 6898, 1760, 4442, 5358, 3236, 4134,
-	5567, 5822, 2214, 4603, 6881, 1386, 7040, 7692, 2069, 3387,
-	6583, 259, 2223, 4488, 7441, 7764, 882, 1432, 4119, 5863,
-	8180, 4753, 5050, 6830, 7844, 4177, 6731, 2390, 5262, 4312,
-	2360, 4351, 7638, 345, 1825, 7644, 599, 3817, 439, 6096, 3137,
-	4794, 726, 6524, 2745, 8146, 1717, 7020, 324, 2819, 4302,
-	2452, 4372, 4680, 5596, 2969, 7419, 6387, 5280, 4016, 576,
-	2654, 33, 2556, 7319, 212, 2666, 821, 2836, 7306, 465, 4964,
-	4595, 5079, 2545, 6863, 6072, 3032, 1052, 4293, 1202, 7000,
-	800, 7476, 1528, 5440, 3312, 3550, 7714, 7952, 8190, 2783,
-	5202, 3074, 7544, 1290, 7101, 1440, 7238, 4357, 8002, 2461,
-	4726, 7278, 4841, 2307, 3625, 6969, 7068, 227, 4991, 2598,
-	2628, 7876, 583, 2904, 2794, 814, 2892, 5834, 2690, 7657,
-	6625, 964, 6334, 837, 4055, 1955, 6762, 562, 3057, 1449, 1223,
-	875, 100, 175, 8088, 3540, 5400, 410, 7748, 3431, 5611, 2178,
-	1230, 3484, 113, 7411, 2372, 2080, 7728, 2091, 6505, 7379,
-	6843, 7927, 4586, 3204, 7255, 7513, 2190, 3785, 4528, 2366,
-	5120, 2998, 6558, 4204, 7902, 8174, 1522, 5329, 4473, 63,
-	3896, 5376, 5584, 1976, 8010, 5911, 6650, 1136, 1607, 3196,
-	4804, 6660, 7863, 5252, 5941, 2493, 4619, 1487, 7809, 622,
-	6943, 2801, 5958, 6544, 5734, 4945, 4421, 7586, 8039, 2343,
-	3810, 2991, 1899, 8069, 3826, 5774, 6614, 2643, 5126, 4433,
-	2269, 3249, 3124, 6048, 6225, 7292, 1241, 6024, 4983, 7670,
-	4399, 5452, 4323, 4318, 4932, 4523, 6938, 1943, 250, 7363,
-	532, 6007, 2209, 5620, 4219, 7233, 3052, 1820, 2661, 366,
-	8154, 3458, 5993, 3341, 3605, 2241, 1513, 2400, 3949, 5896,
-	123, 995, 5668, 7168, 4937, 4972, 4574, 5886, 154, 4277, 5294,
-	1320, 7740, 44, 7114, 6688, 7704, 5165, 1456, 5387, 1340,
-	3701, 3004, 665, 6906, 3305, 6255, 4150, 2262, 3990, 1172,
-	6354, 1496, 3972, 1401, 142, 7368, 5268, 5154, 1906, 4786,
-	8131, 2935, 1914, 3506, 3647, 1884, 4717, 6715, 3836, 2921,
-	6296, 3084, 206, 556, 3875, 5816, 1090, 2380, 616, 7162, 8060,
-	4907, 2294, 6370, 7853, 1349, 1096, 537, 2911, 1107, 2679,
-	1618, 1214, 6107, 1305, 1159, 6036, 2112, 7216, 3763, 6217,
-	6278, 3401, 1593, 3584, 6564, 2948, 4157, 910, 5426, 2810,
-	6205, 311, 7567, 5342, 6405, 988, 4005, 4127, 1948, 2396,
-	6003, 7288, 2339, 5248, 5325, 7923, 406, 956, 952, 307, 6032,
-	8056, 3643, 3986, 40, 1756, 7077, 82, 1747, 640, 6439, 7974,
-	7396, 960, 6965, 2779, 6859, 4012, 6520, 2386, 255, 7725,
-	7252, 97, 5608, 1604, 4616, 6555, 3893, 2266, 4980, 5731,
-	1896, 5990, 120, 6935, 4216, 6903, 1493, 151, 7701, 5813,
-	6367, 4783, 6712, 4154, 6402, 1615, 3760, 1744, 6856, 2336,
-	6029, 6589, 6121, 4952, 4110, 3014, 7523, 7451, 3183, 6259,
-	6779, 5855, 3693, 2728, 3233, 3666, 2315, 5047, 2357, 7037,
-	7438, 5593, 30, 436, 1714, 3309, 7541, 462, 1049, 2889, 4052,
-	4723, 4988, 3064, 1263, 6984, 3731, 2408, 4924, 4036, 2048,
-	6910, 3595, 7890, 4410, 849, 3043, 2474, 7612, 6154, 7815,
-	5007, 1179, 399, 525, 3618, 3771, 669, 3851, 3683, 747, 4891,
-	5976, 973, 7297, 3393, 6992, 1702, 4871, 3100, 7791, 3110,
-	754, 3008, 3094, 654, 7429, 2034, 7828, 4704, 2976, 1850, 332,
-	6090, 7272, 4198, 1937, 8125, 5242, 3705, 5135, 3963, 5697,
-	2955, 4663, 6721, 1246, 473, 939, 3531, 5465, 7057, 5524,
-	4776, 507, 7372, 4143, 6486, 4170, 2017, 3491, 1808, 6598,
-	2736, 628, 1011, 7189, 1633, 4631, 514, 7333, 146, 7032, 5002,
-	6085, 1006, 6467, 7088, 5457, 2075, 1131, 4428, 3453, 660,
-	3870, 2943, 77, 1405, 7198, 1474, 6174, 4748, 4675, 5435, 809,
-	6184, 7461, 6472, 2525, 5789, 7387, 693, 3520, 3976, 4095,
-	2720, 1656, 6635, 5368, 3653, 4328, 569, 5479, 4900, 5934,
-	3331, 3213, 8028, 5108, 1500, 2285, 3280, 4647, 4088, 7534,
-	762, 1416, 1730, 6949, 7093, 3997, 5217, 4453, 4853, 5845,
-	6358, 3420, 3470, 3930, 7778, 5225, 267, 7675, 7698, 3757,
-	5605, 1893, 7435, 1046, 4107, 3690, 1176, 744, 3728, 4407,
-	7269, 5694, 4868, 7426, 7186, 6082, 5462, 4167, 2522, 1653,
-	3450, 6171, 3994, 3927, 5931, 4644, 4164, 4641, 1890, 4404,
-	7110, 1168, 1880, 4903, 2108, 7563, 948, 6961, 7744, 4582,
-	4469, 5937, 3806, 1237, 2205, 3945, 2219, 5258, 2741, 572,
-	6068, 5198, 7064, 6330, 1324, 4511, 1144, 5482, 3575, 5179,
-	2325, 4438, 7046, 5307, 7593, 8031, 2040, 2706, 2437, 3350,
-	5298, 423, 5644, 5111, 1664, 6138, 3716, 3633, 5827, 1838,
-	633, 3334, 2756, 3565, 1867, 894, 4281, 1423, 1799, 3216,
-	2515, 4191, 6302, 2274, 6769, 1793, 2859, 3283, 3957, 456,
-	5925, 2714, 158, 5552, 685, 4650, 6379, 608, 2167, 7150, 5572,
-	5947, 1016, 1503, 5539, 5749, 1363, 7224, 5890, 2487, 2773,
-	2288, 5352, 6235, 831, 2648, 1392, 3739, 5633, 765, 7834,
-	1776, 6816, 3858, 4578, 4507, 419, 1419, 5548, 2483, 4503,
-	6394, 4139, 7028, 7194, 4091, 2281, 3416, 740, 3923, 4976,
-	6398, 6775, 7537, 3591, 3847, 3090, 5131, 7314, 7633, 6757,
-	7096, 1189, 277, 5562, 2576, 1344, 1396, 6515, 4000, 7804,
-	2185, 5663, 4394, 3241, 2499, 1638, 1733, 7351, 1577, 5531,
-	391, 5391, 3743, 3158, 6952, 5144, 774, 2617, 6053, 6887,
-	8100, 8046, 4856, 4710, 56, 8139, 6795, 1460, 5637, 1467,
-	5848, 4823, 4765, 6742, 7965, 5363, 6462, 4636, 5220, 4047,
-	6851, 4658, 5971, 5169, 769, 3289, 4456, 4186, 5174, 3842,
-	6230, 1962, 7135, 5804, 3473, 2566, 4260, 1924, 3906, 7708,
-	7838, 2875, 3933, 5420, 6249, 3118, 6499, 4447, 4625, 519,
-	6361, 1565, 1571, 5743, 5192, 6692, 1780, 786, 3423, 5723,
-	4461, 2231, 3254, 4609, 5517, 7556, 270, 2982, 4539, 3374,
-	676, 7118, 6820, 1119, 7678, 5499, 2062, 8081, 5287, 1765,
-	236, 7338, 7781, 6309, 1037, 4832, 702, 48, 3862, 2865, 5228,
-	6571, 3294, 2927, 3129, 5450, 6022, 6046, 4431, 5772, 2989,
-	7584, 6542, 7166, 5894, 2239, 3456, 1818, 5618, 7361, 4521,
-	3783, 3202, 7377, 2078, 3482, 3429, 3538, 873, 620, 2491,
-	6658, 1134, 1974, 61, 8172, 2996, 4125, 5340, 2808, 2946,
-	3399, 7214, 1303, 2677, 2384, 2777, 7972, 80, 3984, 305, 7921,
-	7286, 140, 6352, 4148, 663, 5385, 6686, 1318, 5884, 1094,
-	2292, 614, 3873, 6294, 4715, 1912, 1904, 4062, 6194, 3360,
-	1477, 5904, 199, 486, 2445, 5820, 5356, 5040, 6177, 2426,
-	2608, 133, 7984, 1692, 4810, 6491, 1408, 1585, 792, 3171,
-	2120, 3879, 6239, 6675, 7201, 4241, 6800, 6343, 2348, 1438,
-	3072, 7950, 5438, 6998, 3030, 5077, 7304, 560, 835, 7655, 812,
-	7874, 225, 2305, 2459, 343, 4310, 4175, 4751, 1430, 4486,
-	3385, 1384, 210, 2652, 6385, 4678, 2817, 8144, 4792, 3815,
-	2844, 6430, 1028, 6475, 189, 4546, 3266, 1071, 541, 5576,
-	6922, 2528, 297, 3438, 3225, 6130, 3674, 6666, 2022, 6187,
-	7128, 1786, 5472, 1256, 1100, 5951, 2829, 7464, 5097, 8105,
-	7500, 5779, 888, 3917, 5965, 696, 1708, 5236, 3514, 6165,
-	1353, 1020, 6749, 3523, 5878, 1378, 919, 7009, 7991, 1550,
-	3496, 5792, 5064, 2099, 166, 925, 7857, 1507, 7156, 7390, 15,
-	6892, 5274, 6619, 844, 2029, 5985, 2723, 4083, 7264, 2012,
-	4743, 6374, 5543, 3801, 1659, 5415, 5494, 7799, 4818, 2421,
-	7869, 1813, 3979, 5410, 6698, 292, 5873, 2298, 5753, 1273,
-	4098, 4697, 4861, 4496, 8074, 7770, 5715, 4689, 3656, 4877,
-	6318, 1282, 980, 4911, 1367, 7623, 4331, 6703, 864, 5760,
-	4379, 356, 7488, 6603, 6638, 4288, 2593, 7759, 7015, 8064,
-	7228, 2173, 5371, 6212, 8051, 5160, 3831, 1299, 1314, 7580,
-	3534, 5073, 3381, 482, 3167, 3510, 162, 3262, 5468, 1278,
-	7755, 2008, 288, 4028, 5917, 478, 476, 2006, 3260, 480, 7578,
-	1918, 5556, 5919, 942, 8022, 4770, 4030, 6549, 7447, 432,
-	6551, 4779, 3106, 8121, 4032, 3614, 2939, 689, 4772, 510,
-	4103, 3446, 8024, 4849, 2433, 1863, 944, 7060, 6812, 736,
-	5921, 1359, 8135, 4654, 5558, 5527, 3370, 4828, 1920, 5739,
-	6341, 6673, 3169, 6489, 131, 5038, 484, 3358, 4790, 6383,
-	3383, 4173, 2303, 7653, 5075, 7948, 8170, 6656, 3536, 7375,
-	7359, 2237, 7582, 6044, 1910, 612, 1316, 4146, 7919, 7970,
-	1301, 2806, 4494, 1271, 290, 1811, 7797, 3799, 2010, 5983,
-	5158, 2171, 7757, 6601, 5758, 7621, 1280, 4687, 7498, 2827,
-	5470, 2020, 3223, 6920, 3264, 1026, 5272, 7154, 164, 3494,
-	917, 6747, 3512, 5963, 829, 2771, 1361, 1014, 2165, 683, 5923,
-	2857, 3088, 6773, 738, 7192, 4501, 417, 6814, 5631, 2323,
-	1142, 7062, 2739, 2203, 4467, 946, 1878, 6300, 1797, 1865,
-	631, 3714, 5642, 2435, 7591, 2229, 784, 5741, 517, 3116, 2873,
-	1922, 5802, 2925, 2863, 4830, 7336, 8079, 1117, 3372, 7554,
-	2615, 3156, 5529, 1636, 5661, 6513, 5560, 6755, 3840, 3287,
-	4656, 4634, 6740, 1465, 8137, 8044, 971, 3681, 3616, 5005,
-	2472, 7888, 4034, 6982, 6719, 3961, 8123, 6088, 4702, 652,
-	3108, 1700, 2334, 1613, 4781, 149, 6933, 5729, 6553, 95, 4721,
-	460, 434, 7035, 3664, 5853, 7449, 4950, 265, 3468, 4851, 7091,
-	760, 3278, 8026, 4898, 1888, 5929, 3448, 5460, 4866, 3726,
-	4105, 5603, 7086, 5000, 512, 1009, 1806, 6484, 4774, 3529,
-	3651, 2718, 691, 6470, 5433, 1472, 2941, 4426, 7964, 4764,
-	5847, 5636, 6794, 55, 4855, 8099, 6229, 5173, 4455, 768, 5970,
-	6850, 5219, 6461, 4393, 2184, 3999, 1395, 2575, 276, 7095,
-	7632, 6052, 773, 6951, 3742, 390, 1576, 1732, 2498, 5286,
-	2061, 7677, 6819, 675, 4538, 269, 5516, 3128, 3293, 5227,
-	3861, 701, 1036, 7780, 235, 6498, 6248, 3932, 7837, 3905,
-	4259, 3472, 7134, 3253, 4460, 3422, 1779, 5191, 1570, 6360,
-	4624, 3632, 6137, 5110, 422, 3349, 2705, 8030, 5306, 2273,
-	4190, 3215, 1422, 893, 3564, 3333, 1837, 3944, 1236, 5936,
-	4581, 6960, 7562, 4902, 1167, 4437, 5178, 5481, 4510, 6329,
-	5197, 571, 5257, 6393, 2482, 1418, 4506, 3857, 1775, 764,
-	3738, 5130, 3846, 7536, 6397, 3922, 3415, 4090, 7027, 7149,
-	607, 4649, 5551, 2713, 455, 3282, 1792, 2647, 6234, 2287,
-	2486, 7223, 5748, 1502, 5946, 808, 4674, 6173, 7197, 76, 3869,
-	3452, 1130, 4327, 5367, 1655, 4094, 3519, 7386, 2524, 7460,
-	6597, 3490, 4169, 4142, 506, 5523, 5464, 938, 5456, 6466,
-	6084, 7031, 7332, 4630, 7188, 627, 7425, 5693, 4406, 743,
-	3689, 1045, 1892, 3756, 4403, 4640, 4643, 3926, 6170, 1652,
-	4166, 6081, 1415, 7533, 4646, 2284, 5107, 3212, 5933, 5478,
-	7674, 5224, 3929, 3419, 5844, 4452, 3996, 6948, 2314, 3232,
-	3692, 6778, 3182, 7522, 4109, 6120, 4987, 4051, 1048, 7540,
-	1713, 29, 7437, 2356, 4215, 119, 1895, 4979, 3892, 4615, 5607,
-	7251, 6028, 6855, 3759, 6401, 6711, 6366, 7700, 1492, 2975,
-	7827, 7428, 3093, 753, 7790, 4870, 6991, 1245, 4662, 5696,
-	5134, 5241, 1936, 7271, 331, 7611, 3042, 4409, 3594, 2047,
-	4923, 3730, 1262, 7296, 5975, 746, 3850, 3770, 524, 1178,
-	7814, 7553, 1116, 7335, 2862, 5801, 2872, 516, 783, 8043,
-	1464, 4633, 3286, 6754, 6512, 1635, 3155, 5630, 416, 7191,
-	6772, 2856, 682, 1013, 2770, 7590, 5641, 630, 1796, 1877,
-	4466, 2738, 1141, 5602, 3725, 5459, 5928, 4897, 3277, 7090,
-	3467, 4425, 1471, 6469, 2717, 3528, 6483, 1008, 4999, 1699,
-	651, 6087, 3960, 6981, 7887, 5004, 3680, 4949, 5852, 7034,
-	459, 94, 5728, 148, 1612, 4848, 3445, 509, 688, 3613, 8120,
-	4778, 431, 5738, 4827, 5526, 4653, 1358, 735, 7059, 1862, 287,
-	7754, 5467, 161, 3166, 3380, 3533, 1313, 6548, 4769, 941,
-	5555, 7577, 3259, 475, 5916, 4686, 7620, 6600, 2170, 5982,
-	3798, 1810, 1270, 5962, 6746, 3493, 7153, 1025, 6919, 2019,
-	2826, 7947, 7652, 4172, 6382, 3357, 5037, 6488, 6672, 2805,
-	7969, 4145, 611, 6043, 2236, 7374, 6655, 7008, 1377, 3522,
-	1019, 6164, 5235, 695, 3916, 6618, 6891, 7389, 1506, 924,
-	2098, 5791, 1549, 6129, 3437, 2527, 5575, 1070, 4545, 6474,
-	6429, 5778, 8104, 7463, 5950, 1255, 1785, 6186, 6665, 4378,
-	863, 4330, 1366, 979, 6317, 3655, 5714, 3830, 8050, 5370,
-	7227, 7014, 2592, 6637, 7487, 4817, 5493, 1658, 5542, 4742,
-	7263, 2722, 2028, 8073, 4860, 4097, 5752, 5872, 6697, 3978,
-	7868, 7285, 304, 79, 2776, 2676, 7213, 2945, 5339, 1903, 4714,
-	3872, 2291, 5883, 6685, 662, 6351, 4520, 5617, 3455, 5893,
-	6541, 2988, 4430, 6021, 2995, 60, 1133, 2490, 872, 3428, 2077,
-	3201, 2458, 224, 811, 834, 7303, 3029, 5437, 3071, 3814, 8143,
-	4677, 2651, 1383, 4485, 4750, 4309, 7983, 2607, 6176, 5355,
-	2444, 198, 1476, 6193, 2347, 6799, 7200, 6238, 2119, 791,
-	1407, 4809, 1538, 2147, 3773, 7596, 721, 6578, 3620, 2540,
-	1517, 5395, 527, 8034, 3501, 7735, 401, 1154, 2157, 181, 1181,
-	7049, 4269, 7684, 5009, 4340, 2245, 3747, 7817, 5310, 717,
-	4265, 6156, 68, 2672, 6537, 7299, 2440, 6160, 1066, 975, 4738,
-	3609, 3162, 5978, 3353, 5797, 2852, 4893, 6977, 3178, 3888,
-	749, 2043, 72, 502, 3685, 5103, 3345, 6956, 3853, 2709, 6790,
-	2571, 671, 3901, 4733, 2535, 2050, 5647, 2249, 1081, 4038,
-	5652, 5997, 5148, 4926, 5114, 7996, 593, 2410, 6449, 5511,
-	8094, 3733, 5301, 3751, 1125, 6986, 6115, 3462, 778, 1265,
-	426, 5709, 3911, 3066, 5334, 218, 857, 7614, 3719, 7821, 5687,
-	2476, 2055, 8158, 2621, 3045, 3636, 1555, 377, 851, 6531,
-	5029, 447, 4412, 1667, 5314, 1675, 7892, 8111, 370, 6057,
-	3597, 6141, 3408, 1929, 6912, 4478, 1210, 906, 5244, 636,
-	4273, 3301, 8127, 1086, 4941, 3245, 1939, 3337, 171, 2087,
-	4200, 3192, 4960, 3546, 7274, 5830, 7688, 6826, 6092, 2965,
-	7172, 2503, 334, 1841, 5020, 7140, 1852, 1981, 7325, 383,
-	1248, 1870, 5013, 710, 6723, 2254, 5672, 1642, 4665, 897, 930,
-	6421, 2957, 6872, 2127, 4231, 5699, 2759, 4344, 7935, 3965,
-	7506, 999, 1737, 5137, 3568, 5090, 1967, 3707, 8015, 2468,
-	6929, 756, 1802, 2161, 2199, 3112, 5657, 127, 7355, 7793,
-	3219, 5069, 2002, 3102, 6808, 4079, 5406, 4873, 4284, 185,
-	7124, 1704, 5060, 5900, 1581, 6994, 1426, 5768, 3478, 3395,
-	5381, 2562, 1561, 2978, 6305, 1185, 7347, 4706, 4043, 3953,
-	5535, 7830, 2277, 2104, 6064, 2036, 2752, 3327, 5213, 7431,
-	2518, 7053, 1629, 656, 5785, 2404, 395, 3096, 4194, 1600,
-	5809, 3010, 5589, 3083, 2920, 6714, 1883, 3505, 2934, 4785,
-	5153, 536, 1348, 6369, 4906, 7161, 2379, 5815, 555, 1339,
-	1455, 7703, 7113, 7739, 5293, 153, 4573, 7367, 1400, 1495,
-	1171, 2261, 6254, 6905, 3003, 39, 3642, 6031, 951, 405, 5324,
-	2338, 6002, 254, 6519, 6858, 6964, 7395, 6438, 1746, 7076,
-	1592, 6277, 3762, 2111, 1158, 6106, 1617, 1106, 1947, 4004,
-	6404, 7566, 6204, 5425, 4156, 6563, 8009, 5583, 3895, 4472,
-	1521, 7901, 6557, 5119, 6942, 7808, 4618, 5940, 7862, 4803,
-	1606, 6649, 112, 1229, 5610, 7747, 5399, 8087, 99, 1222, 4527,
-	2189, 7254, 4585, 6842, 6504, 7727, 2371, 2660, 3051, 4218,
-	2208, 531, 249, 6937, 4931, 4936, 5667, 122, 3948, 1512, 3604,
-	5992, 8153, 6613, 3825, 1898, 3809, 8038, 4420, 5733, 5957,
-	4322, 4398, 4982, 1240, 6224, 3123, 2268, 5125, 4301, 323,
-	1716, 2744, 725, 3136, 438, 598, 2665, 7318, 32, 575, 5279,
-	7418, 5595, 4371, 4118, 881, 7440, 2222, 6582, 2068, 7039,
-	6880, 1824, 7637, 2359, 5261, 6730, 7843, 5049, 8179, 582,
-	2627, 4990, 7067, 3624, 4840, 4725, 8001, 3056, 6761, 4054,
-	6333, 6624, 2689, 2891, 2793, 799, 1201, 1051, 6071, 2544,
-	4594, 464, 2835, 7237, 7100, 7543, 5201, 8189, 7713, 3311,
-	1527, 4364, 548, 3185, 1147, 1542, 3148, 7453, 6454, 4223,
-	1193, 7525, 5485, 20, 1993, 3016, 4249, 1333, 106, 4112, 1327,
-	2151, 5505, 4954, 4073, 5624, 281, 6123, 4514, 4387, 3938,
-	6591, 4209, 4022, 8164, 2317, 2328, 3777, 1686, 3668, 2415,
-	2213, 5566, 3235, 4441, 6897, 6148, 2730, 1724, 7405, 2637,
-	3695, 3578, 7600, 4555, 5857, 7470, 6011, 2580, 6781, 5182,
-	6285, 2880, 6261, 7907, 3561, 2702, 5194, 7559, 3412, 1772,
-	5745, 452, 6847, 52, 1573, 273, 1033, 4535, 1567, 4256, 26,
-	7519, 6363, 4612, 1933, 7787, 521, 4920, 7383, 3866, 4627,
-	5520, 1649, 1042, 4449, 3209, 732, 8117, 3256, 3377, 6916,
-	3795, 2233, 5034, 6509, 2869, 4463, 679, 6480, 3274, 5725,
-	7884, 6682, 7210, 3425, 2985, 4482, 3026, 788, 195, 2095,
-	5232, 1782, 4542, 2589, 6314, 6694, 7260, 590, 1078, 3908,
-	1122, 374, 5684, 1926, 1672, 7732, 6575, 4262, 7681, 2849,
-	1063, 2568, 499, 1999, 2196, 3475, 7121, 6061, 7344, 5806,
-	1626, 2084, 3298, 7137, 6823, 6418, 707, 1964, 7932, 4800,
-	7898, 6501, 8084, 3601, 246, 3120, 4417, 2376, 2931, 6251,
-	5290, 6435, 5321, 5422, 6103, 1990, 3145, 3935, 5502, 6145,
-	1683, 2877, 4552, 7415, 3133, 7840, 2065, 2686, 4837, 7710,
-	4591, 1060, 5681, 704, 7341, 5318, 243, 4834, 1680, 4532,
-	1769, 1039, 7784, 3271, 3792, 6311, 3023, 3022, 3791, 7783,
-	1768, 1679, 242, 7340, 5680, 3789, 240, 238, 239, 5679, 241,
-	1767, 3790, 3143, 1681, 3131, 4835, 7896, 244, 2929, 5319,
-	2194, 7342, 3296, 705, 1076, 5682, 6573, 1061, 7208, 3024,
-	5230, 6312, 8115, 3793, 2867, 3272, 7517, 7785, 3864, 1040,
-	2700, 1770, 50, 4533, 7883, 3273, 678, 2868, 5033, 3794, 3376,
-	8116, 7259, 6313, 4541, 5231, 194, 3025, 2984, 7209, 4255,
-	4534, 272, 51, 451, 1771, 7558, 2701, 3208, 1041, 5519, 3865,
-	4919, 7786, 4611, 7518, 6102, 5320, 5289, 2930, 4416, 245,
-	8083, 7897, 4590, 4836, 2064, 3132, 4551, 1682, 5501, 3144,
-	498, 1062, 7680, 6574, 1671, 5683, 1121, 1077, 7931, 706,
-	6822, 3297, 1625, 7343, 7120, 2195, 5211, 1627, 393, 5807,
-	1559, 7345, 5533, 6062, 5404, 7122, 1579, 3476, 6927, 2197,
-	7353, 2000, 4229, 7933, 1735, 1965, 381, 708, 1640, 6419,
-	3544, 6824, 2501, 7138, 904, 3299, 3243, 2085, 445, 1673,
-	6055, 1927, 855, 5685, 2619, 375, 8092, 1123, 776, 3909, 2533,
-	1079, 5146, 591, 3886, 500, 6954, 2569, 6535, 1064, 3160,
-	2850, 179, 7682, 3745, 4263, 2145, 6576, 5393, 7733, 2635,
-	4553, 2578, 2878, 8162, 1684, 5564, 6146, 104, 5503, 279,
-	3936, 546, 3146, 1191, 1991, 1199, 4592, 7098, 7711, 2625,
-	4838, 6759, 2687, 879, 2066, 7635, 7841, 321, 3134, 7316,
-	7416, 3823, 4418, 4396, 3121, 3049, 247, 5665, 3602, 1227,
-	8085, 2187, 6502, 5581, 7899, 7806, 4801, 6275, 6104, 4002,
-	5423, 3640, 5322, 6517, 6436, 1453, 5291, 1398, 6252, 2918,
-	2932, 1346, 2377, 3040, 4921, 5973, 522, 7825, 7788, 4660,
-	1934, 117, 4613, 6853, 6364, 3230, 7520, 4049, 27, 7531, 3210,
-	5222, 4450, 5691, 1043, 4638, 1650, 3488, 5521, 6464, 4628,
-	4672, 3867, 5365, 7384, 605, 453, 6232, 5746, 2480, 1773,
-	3844, 3413, 1234, 7560, 5176, 5195, 6135, 2703, 4188, 3562,
-	6246, 4257, 4458, 1568, 2059, 4536, 3291, 1034, 2182, 274,
-	771, 1574, 4762, 53, 5171, 6848, 2605, 196, 6797, 789, 222,
-	3027, 8141, 4483, 5615, 2986, 58, 3426, 302, 7211, 4712, 6683,
-	5491, 7261, 4858, 6695, 861, 6315, 8048, 2590, 3435, 4543,
-	8102, 1783, 1375, 5233, 6889, 2096, 7650, 5035, 7967, 2234,
-	7618, 3796, 6744, 6917, 7752, 3378, 4767, 3257, 3443, 8118,
-	4825, 733, 649, 7885, 5850, 5726, 3723, 3275, 1469, 6481, 414,
-	680, 5639, 4464, 1114, 2870, 1462, 6510, 7486, 2591, 7226,
-	8049, 5713, 6316, 1365, 862, 7867, 6696, 5751, 4859, 2027,
-	7262, 5541, 5492, 1548, 2097, 1505, 6890, 3915, 5234, 1018,
-	1376, 6664, 1784, 5949, 8103, 6428, 4544, 5574, 3436, 4308,
-	4484, 2650, 8142, 3070, 3028, 833, 223, 4808, 790, 6237, 6798,
-	6192, 197, 5354, 2606, 6350, 6684, 2290, 4713, 5338, 7212,
-	2775, 303, 3200, 3427, 2489, 59, 6020, 2987, 5892, 5616, 4998,
-	6482, 2716, 1470, 3466, 3276, 5927, 3724, 1611, 5727, 458,
-	5851, 3679, 7886, 3959, 650, 3154, 6511, 3285, 1463, 782,
-	2871, 2861, 1115, 1140, 4465, 1795, 5640, 2769, 681, 6771,
-	415, 2825, 6918, 7152, 6745, 1269, 3797, 2169, 7619, 6654,
-	2235, 610, 7968, 6671, 5036, 6381, 7651, 1861, 734, 4652,
-	4826, 430, 8119, 687, 3444, 5915, 3258, 5554, 4768, 1312,
-	3379, 160, 7753, 6080, 1651, 3925, 4639, 3755, 1044, 742,
-	5692, 6947, 4451, 3418, 5223, 5477, 3211, 2283, 7532, 7459,
-	7385, 4093, 5366, 1129, 3868, 7196, 4673, 626, 4629, 7030,
-	6465, 937, 5522, 4141, 3489, 330, 1935, 5133, 4661, 6990,
-	7789, 3092, 7826, 7813, 523, 3849, 5974, 1261, 4922, 3593,
-	3041, 2355, 28, 7539, 4050, 6119, 7521, 6777, 3231, 1491,
-	6365, 6400, 6854, 7250, 4614, 4978, 118, 234, 1035, 3860,
-	3292, 5515, 4537, 6818, 2060, 4623, 1569, 1778, 4459, 7133,
-	4258, 7836, 6247, 6460, 6849, 767, 5172, 8098, 54, 5635, 4763,
-	2497, 1575, 3741, 772, 7631, 275, 1394, 2183, 7026, 3414,
-	6396, 3845, 3737, 1774, 4505, 2481, 5945, 5747, 2485, 6233,
-	1791, 454, 5550, 606, 1836, 3563, 1421, 4189, 5305, 2704, 421,
-	6136, 5256, 5196, 4509, 5177, 1166, 7561, 4580, 1235, 2792,
-	2688, 6332, 6760, 8000, 4839, 7066, 2626, 1526, 7712, 5200,
-	7099, 2834, 4593, 6070, 1200, 4370, 7417, 574, 7317, 597,
-	3135, 2743, 322, 8178, 7842, 5260, 7636, 6879, 2067, 2221,
-	880, 1723, 6147, 4440, 5565, 2414, 1685, 2327, 8163, 7906,
-	2879, 5181, 2579, 7469, 4554, 3577, 2636, 4248, 1992, 5484,
-	1192, 6453, 3147, 1146, 547, 4208, 3937, 4513, 280, 4072,
-	5504, 1326, 105, 7075, 6437, 6963, 6518, 6001, 5323, 950,
-	3641, 6562, 5424, 7565, 4003, 1105, 6105, 2110, 6276, 554,
-	2378, 4905, 1347, 5152, 2933, 1882, 2919, 3002, 6253, 1170,
-	1399, 4572, 5292, 7112, 1454, 8152, 3603, 3947, 5666, 4930,
-	248, 2207, 3050, 5124, 3122, 1239, 4397, 5956, 4419, 3808,
-	3824, 6648, 4802, 5939, 7807, 5118, 7900, 4471, 5582, 2370,
-	6503, 4584, 2188, 1221, 8086, 7746, 1228, 6871, 6420, 896,
-	1641, 2253, 709, 1869, 382, 8014, 1966, 3567, 1736, 7505,
-	7934, 2758, 4230, 3191, 2086, 3336, 3244, 1085, 3300, 635,
-	905, 1980, 7139, 1840, 2502, 2964, 6825, 5829, 3545, 2751,
-	6063, 2276, 5534, 4042, 7346, 6304, 1560, 5588, 5808, 4193,
-	394, 5784, 1628, 2517, 5212, 6807, 2001, 3218, 7354, 5656,
-	2198, 1801, 6928, 5380, 3477, 1425, 1580, 5059, 7123, 4283,
-	5405, 6976, 2851, 3352, 3161, 4737, 1065, 2439, 6536, 3900,
-	2570, 2708, 6955, 5102, 501, 2042, 3887, 1153, 7734, 8033,
-	5394, 2539, 6577, 7595, 2146, 67, 4264, 5309, 3746, 4339,
-	7683, 7048, 180, 6530, 376, 3635, 2620, 2054, 5686, 3718, 856,
-	4477, 1928, 6140, 6056, 8110, 1674, 1666, 446, 6448, 592,
-	5113, 5147, 5651, 1080, 5646, 2534, 5333, 3910, 425, 777,
-	6114, 1124, 5300, 8093
-};
-
-int a_to_i[8192] = {
-	1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 1455,
-	2910, 5820, 2263, 4526, 1779, 3558, 7116, 4663, 449, 898,
-	1796, 3592, 7184, 7567, 7857, 6349, 5173, 3525, 7050, 4795,
-	217, 434, 868, 1736, 3472, 6944, 5103, 625, 1250, 2500, 5000,
-	703, 1406, 2812, 5624, 3679, 7358, 7379, 7177, 7613, 7893,
-	6149, 5541, 3813, 7626, 7739, 6617, 5661, 2453, 4906, 1019,
-	2038, 4076, 8152, 6687, 4497, 1677, 3354, 6708, 4551, 1569,
-	3138, 6276, 5287, 3297, 6594, 5675, 2553, 5106, 587, 1174,
-	2348, 4696, 287, 574, 1148, 2296, 4592, 1615, 3230, 6460,
-	6103, 2561, 5122, 3499, 6998, 4867, 937, 1874, 3748, 7496,
-	7999, 7121, 4621, 437, 874, 1748, 3496, 6992, 4879, 945, 1890,
-	3780, 7560, 7871, 6353, 5133, 3509, 7018, 4987, 857, 1714,
-	3428, 6856, 4159, 1489, 2978, 5956, 2855, 5710, 2355, 4710,
-	355, 710, 1420, 2840, 5680, 2511, 5022, 659, 1318, 2636, 5272,
-	3231, 6462, 6099, 2569, 5138, 3467, 6934, 4995, 681, 1362,
-	2724, 5448, 3903, 7806, 6483, 5897, 3005, 6010, 2907, 5814,
-	2243, 4486, 1699, 3398, 6796, 4279, 1217, 2434, 4868, 935,
-	1870, 3740, 7480, 8159, 6673, 4493, 1717, 3434, 6868, 4103,
-	1441, 2882, 5764, 2215, 4430, 1843, 3686, 7372, 7223, 7617,
-	7725, 6645, 5701, 2341, 4682, 315, 630, 1260, 2520, 5040, 719,
-	1438, 2876, 5752, 2399, 4798, 211, 422, 844, 1688, 3376, 6752,
-	4463, 1905, 3810, 7620, 7719, 6625, 5741, 2421, 4842, 123,
-	246, 492, 984, 1968, 3936, 7872, 6191, 5617, 3661, 7322, 7323,
-	7321, 7325, 7317, 7301, 7333, 7397, 7269, 7525, 8037, 7013,
-	4965, 869, 1738, 3476, 6952, 5119, 593, 1186, 2372, 4744, 191,
-	382, 764, 1528, 3056, 6112, 2671, 5342, 3091, 6182, 5603,
-	3689, 7378, 7179, 7609, 7901, 6165, 5509, 3749, 7498, 7995,
-	7129, 4637, 405, 810, 1620, 3240, 6480, 5903, 2993, 5986,
-	2923, 5846, 2051, 4102, 1443, 2886, 5772, 2231, 4462, 1907,
-	3814, 7628, 7735, 6593, 5677, 2549, 5098, 635, 1270, 2540,
-	5080, 543, 1086, 2172, 4344, 1119, 2238, 4476, 1879, 3758,
-	7516, 7959, 7041, 4781, 245, 490, 980, 1960, 3920, 7840, 6383,
-	5233, 3405, 6810, 4251, 1177, 2354, 4708, 359, 718, 1436,
-	2872, 5744, 2383, 4766, 147, 294, 588, 1176, 2352, 4704, 367,
-	734, 1468, 2936, 5872, 2127, 4254, 1171, 2342, 4684, 311, 622,
-	1244, 2488, 4976, 847, 1694, 3388, 6776, 4447, 1809, 3618,
-	7236, 7463, 8161, 6765, 4469, 1861, 3722, 7444, 8071, 6817,
-	4333, 1141, 2282, 4564, 1543, 3086, 6172, 5527, 3713, 7426,
-	8107, 6905, 4189, 1301, 2602, 5204, 3335, 6670, 4531, 1737,
-	3474, 6948, 5095, 609, 1218, 2436, 4872, 959, 1918, 3836,
-	7672, 7775, 6417, 6029, 2741, 5482, 3963, 7926, 6211, 5417,
-	4093, 8186, 6747, 4377, 1949, 3898, 7796, 6471, 5921, 3053,
-	6106, 2587, 5174, 3523, 7046, 4771, 233, 466, 932, 1864, 3728,
-	7456, 8175, 6769, 4429, 1845, 3690, 7380, 7175, 7585, 7917,
-	6261, 5445, 3877, 7754, 6459, 6105, 2589, 5178, 3547, 7094,
-	4803, 41, 82, 164, 328, 656, 1312, 2624, 5248, 3247, 6494,
-	5907, 2953, 5906, 2955, 5910, 2947, 5894, 2979, 5958, 2851,
-	5702, 2339, 4678, 291, 582, 1164, 2328, 4656, 463, 926, 1852,
-	3704, 7408, 7247, 7473, 8141, 6709, 4549, 1573, 3146, 6292,
-	5255, 3233, 6466, 5931, 3065, 6130, 2635, 5270, 3203, 6406,
-	6051, 2793, 5586, 3595, 7190, 7555, 7849, 6397, 5205, 3333,
-	6666, 4539, 1753, 3506, 7012, 4967, 865, 1730, 3460, 6920,
-	5055, 721, 1442, 2884, 5768, 2239, 4478, 1875, 3750, 7500,
-	7991, 7105, 4653, 501, 1002, 2004, 4008, 8016, 6927, 5041,
-	717, 1434, 2868, 5736, 2431, 4862, 83, 166, 332, 664, 1328,
-	2656, 5312, 3119, 6238, 5395, 3977, 7954, 7051, 4793, 221,
-	442, 884, 1768, 3536, 7072, 4847, 113, 226, 452, 904, 1808,
-	3616, 7232, 7471, 8177, 6733, 4405, 1989, 3978, 7956, 7047,
-	4769, 237, 474, 948, 1896, 3792, 7584, 7919, 6257, 5453, 3893,
-	7786, 6523, 5977, 2845, 5690, 2523, 5046, 707, 1414, 2828,
-	5656, 2463, 4926, 979, 1958, 3916, 7832, 6303, 5265, 3213,
-	6426, 6043, 2713, 5426, 4043, 8086, 6787, 4265, 1277, 2554,
-	5108, 583, 1166, 2332, 4664, 479, 958, 1916, 3832, 7664, 7759,
-	6449, 6093, 2613, 5226, 3451, 6902, 4163, 1321, 2642, 5284,
-	3303, 6606, 5683, 2505, 5010, 651, 1302, 2604, 5208, 3359,
-	6718, 4563, 1545, 3090, 6180, 5607, 3681, 7362, 7211, 7673,
-	7773, 6421, 6021, 2725, 5450, 3899, 7798, 6467, 5929, 3069,
-	6138, 2651, 5302, 3267, 6534, 5795, 2281, 4562, 1547, 3094,
-	6188, 5623, 3649, 7298, 7339, 7417, 7261, 7445, 8069, 6821,
-	4325, 1125, 2250, 4500, 1671, 3342, 6684, 4503, 1665, 3330,
-	6660, 4519, 1761, 3522, 7044, 4775, 225, 450, 900, 1800, 3600,
-	7200, 7663, 7793, 6477, 5941, 3013, 6026, 2747, 5494, 3907,
-	7814, 6307, 5353, 3197, 6394, 5211, 3353, 6706, 4555, 1593,
-	3186, 6372, 5223, 3425, 6850, 4139, 1529, 3058, 6116, 2663,
-	5326, 3123, 6246, 5475, 3945, 7890, 6155, 5561, 3805, 7610,
-	7899, 6169, 5533, 3733, 7466, 8187, 6745, 4381, 1941, 3882,
-	7764, 6407, 6049, 2797, 5594, 3611, 7222, 7619, 7721, 6653,
-	5717, 2309, 4618, 443, 886, 1772, 3544, 7088, 4815, 49, 98,
-	196, 392, 784, 1568, 3136, 6272, 5295, 3313, 6626, 5739, 2425,
-	4850, 75, 150, 300, 600, 1200, 2400, 4800, 47, 94, 188, 376,
-	752, 1504, 3008, 6016, 2735, 5470, 3859, 7718, 6627, 5737,
-	2429, 4858, 91, 182, 364, 728, 1456, 2912, 5824, 2095, 4190,
-	1299, 2598, 5196, 3383, 6766, 4467, 1865, 3730, 7460, 8167,
-	6753, 4461, 1909, 3818, 7636, 7687, 6561, 5869, 2165, 4330,
-	1147, 2294, 4588, 1655, 3310, 6620, 5655, 2433, 4866, 939,
-	1878, 3756, 7512, 7967, 7057, 4749, 181, 362, 724, 1448, 2896,
-	5792, 2287, 4574, 1555, 3110, 6220, 5431, 4033, 8066, 6827,
-	4345, 1117, 2234, 4468, 1863, 3726, 7452, 8087, 6785, 4269,
-	1269, 2538, 5076, 519, 1038, 2076, 4152, 1503, 3006, 6012,
-	2903, 5806, 2291, 4582, 1635, 3270, 6540, 5815, 2241, 4482,
-	1707, 3414, 6828, 4343, 1089, 2178, 4356, 1959, 3918, 7836,
-	6295, 5249, 3245, 6490, 5915, 2969, 5938, 3019, 6038, 2691,
-	5382, 4003, 8006, 6947, 5097, 637, 1274, 2548, 5096, 639,
-	1278, 2556, 5112, 607, 1214, 2428, 4856, 95, 190, 380, 760,
-	1520, 3040, 6080, 2607, 5214, 3347, 6694, 4579, 1641, 3282,
-	6564, 5863, 2145, 4290, 1067, 2134, 4268, 1271, 2542, 5084,
-	535, 1070, 2140, 4280, 1247, 2494, 4988, 855, 1710, 3420,
-	6840, 4319, 1041, 2082, 4164, 1319, 2638, 5276, 3223, 6446,
-	6131, 2633, 5266, 3211, 6422, 6019, 2729, 5458, 3851, 7702,
-	6531, 5801, 2301, 4602, 1627, 3254, 6508, 6007, 2881, 5762,
-	2219, 4438, 1795, 3590, 7180, 7607, 7873, 6189, 5621, 3653,
-	7306, 7355, 7385, 7197, 7573, 7813, 6309, 5349, 3173, 6346,
-	5179, 3545, 7090, 4811, 57, 114, 228, 456, 912, 1824, 3648,
-	7296, 7343, 7409, 7245, 7477, 8133, 6693, 4581, 1637, 3274,
-	6548, 5767, 2209, 4418, 1835, 3670, 7340, 7415, 7233, 7469,
-	8181, 6725, 4389, 2021, 4042, 8084, 6791, 4257, 1261, 2522,
-	5044, 711, 1422, 2844, 5688, 2527, 5054, 723, 1446, 2892,
-	5784, 2207, 4414, 2003, 4006, 8012, 6967, 5057, 557, 1114,
-	2228, 4456, 1919, 3838, 7676, 7767, 6401, 6061, 2805, 5610,
-	3707, 7414, 7235, 7465, 8189, 6741, 4357, 1957, 3914, 7828,
-	6279, 5281, 3309, 6618, 5659, 2457, 4914, 971, 1942, 3884,
-	7768, 6431, 6033, 2701, 5402, 3995, 7990, 7107, 4649, 509,
-	1018, 2036, 4072, 8144, 6671, 4529, 1741, 3482, 6964, 5063,
-	545, 1090, 2180, 4360, 1983, 3966, 7932, 6231, 5377, 4013,
-	8026, 6939, 5017, 669, 1338, 2676, 5352, 3199, 6398, 5203,
-	3337, 6674, 4491, 1721, 3442, 6884, 4199, 1377, 2754, 5508,
-	3751, 7502, 7987, 7113, 4669, 469, 938, 1876, 3752, 7504,
-	7951, 7089, 4813, 53, 106, 212, 424, 848, 1696, 3392, 6784,
-	4271, 1265, 2530, 5060, 551, 1102, 2204, 4408, 2015, 4030,
-	8060, 6999, 4865, 941, 1882, 3764, 7528, 8063, 6993, 4877,
-	949, 1898, 3796, 7592, 7935, 6225, 5389, 4021, 8042, 7035,
-	4953, 797, 1594, 3188, 6376, 5247, 3409, 6818, 4331, 1145,
-	2290, 4580, 1639, 3278, 6556, 5783, 2177, 4354, 1963, 3926,
-	7852, 6391, 5185, 3373, 6746, 4379, 1945, 3890, 7780, 6503,
-	5985, 2925, 5850, 2075, 4150, 1475, 2950, 5900, 2999, 5998,
-	2931, 5862, 2147, 4294, 1059, 2118, 4236, 1207, 2414, 4828,
-	23, 46, 92, 184, 368, 736, 1472, 2944, 5888, 2991, 5982, 2835,
-	5670, 2531, 5062, 547, 1094, 2188, 4376, 1951, 3902, 7804,
-	6487, 5889, 2989, 5978, 2843, 5686, 2499, 4998, 675, 1350,
-	2700, 5400, 3999, 7998, 7123, 4617, 445, 890, 1780, 3560,
-	7120, 4623, 433, 866, 1732, 3464, 6928, 5007, 689, 1378, 2756,
-	5512, 3775, 7550, 8019, 6921, 5053, 725, 1450, 2900, 5800,
-	2303, 4606, 1619, 3238, 6476, 5943, 3009, 6018, 2731, 5462,
-	3843, 7686, 6563, 5865, 2173, 4346, 1115, 2230, 4460, 1911,
-	3822, 7644, 7703, 6529, 5805, 2293, 4586, 1659, 3318, 6636,
-	5751, 2369, 4738, 171, 342, 684, 1368, 2736, 5472, 3951, 7902,
-	6163, 5513, 3773, 7546, 8027, 6937, 5021, 661, 1322, 2644,
-	5288, 3327, 6654, 5715, 2313, 4626, 395, 790, 1580, 3160,
-	6320, 5327, 3121, 6242, 5483, 3961, 7922, 6219, 5433, 4061,
-	8122, 6875, 4121, 1437, 2874, 5748, 2375, 4750, 179, 358, 716,
-	1432, 2864, 5728, 2415, 4830, 19, 38, 76, 152, 304, 608, 1216,
-	2432, 4864, 943, 1886, 3772, 7544, 8031, 6929, 5005, 693,
-	1386, 2772, 5544, 3839, 7678, 7763, 6409, 6077, 2773, 5546,
-	3835, 7670, 7747, 6441, 6141, 2645, 5290, 3323, 6646, 5699,
-	2345, 4690, 267, 534, 1068, 2136, 4272, 1231, 2462, 4924, 983,
-	1966, 3932, 7864, 6367, 5137, 3469, 6938, 5019, 665, 1330,
-	2660, 5320, 3135, 6270, 5459, 3849, 7698, 6539, 5817, 2269,
-	4538, 1755, 3510, 7020, 4983, 833, 1666, 3332, 6664, 4543,
-	1745, 3490, 6980, 4903, 993, 1986, 3972, 7944, 7103, 4817, 13,
-	26, 52, 104, 208, 416, 832, 1664, 3328, 6656, 4527, 1777,
-	3554, 7108, 4647, 481, 962, 1924, 3848, 7696, 6543, 5809,
-	2253, 4506, 1691, 3382, 6764, 4471, 1857, 3714, 7428, 8103,
-	6881, 4205, 1397, 2794, 5588, 3591, 7182, 7603, 7881, 6205,
-	5589, 3589, 7178, 7611, 7897, 6173, 5525, 3717, 7434, 8123,
-	6873, 4125, 1429, 2858, 5716, 2311, 4622, 435, 870, 1740,
-	3480, 6960, 5071, 561, 1122, 2244, 4488, 1727, 3454, 6908,
-	4183, 1281, 2562, 5124, 3495, 6990, 4915, 969, 1938, 3876,
-	7752, 6463, 6097, 2573, 5146, 3483, 6966, 5059, 553, 1106,
-	2212, 4424, 1855, 3710, 7420, 7255, 7425, 8109, 6901, 4165,
-	1317, 2634, 5268, 3207, 6414, 6067, 2761, 5522, 3723, 7446,
-	8067, 6825, 4349, 1109, 2218, 4436, 1799, 3598, 7196, 7575,
-	7809, 6317, 5365, 3141, 6282, 5307, 3289, 6578, 5835, 2105,
-	4210, 1355, 2710, 5420, 4087, 8174, 6771, 4425, 1853, 3706,
-	7412, 7239, 7457, 8173, 6773, 4421, 1829, 3658, 7316, 7303,
-	7329, 7405, 7285, 7493, 7973, 7141, 4709, 357, 714, 1428,
-	2856, 5712, 2319, 4638, 403, 806, 1612, 3224, 6448, 6095,
-	2609, 5218, 3435, 6870, 4099, 1449, 2898, 5796, 2279, 4558,
-	1587, 3174, 6348, 5175, 3521, 7042, 4779, 249, 498, 996, 1992,
-	3984, 7968, 7151, 4721, 333, 666, 1332, 2664, 5328, 3087,
-	6174, 5523, 3721, 7442, 8075, 6841, 4317, 1045, 2090, 4180,
-	1287, 2574, 5148, 3479, 6958, 5107, 585, 1170, 2340, 4680,
-	319, 638, 1276, 2552, 5104, 591, 1182, 2364, 4728, 351, 702,
-	1404, 2808, 5616, 3663, 7326, 7315, 7305, 7357, 7381, 7173,
-	7589, 7909, 6245, 5477, 3941, 7882, 6203, 5593, 3613, 7226,
-	7643, 7705, 6557, 5781, 2181, 4362, 1979, 3958, 7916, 6263,
-	5441, 3885, 7770, 6427, 6041, 2717, 5434, 4059, 8118, 6851,
-	4137, 1533, 3066, 6132, 2631, 5262, 3251, 6502, 5987, 2921,
-	5842, 2059, 4118, 1411, 2822, 5644, 2487, 4974, 883, 1766,
-	3532, 7064, 4767, 145, 290, 580, 1160, 2320, 4640, 495, 990,
-	1980, 3960, 7920, 6223, 5425, 4045, 8090, 6811, 4249, 1181,
-	2362, 4724, 327, 654, 1308, 2616, 5232, 3407, 6814, 4243,
-	1161, 2322, 4644, 487, 974, 1948, 3896, 7792, 6479, 5937,
-	3021, 6042, 2715, 5430, 4035, 8070, 6819, 4329, 1149, 2298,
-	4596, 1607, 3214, 6428, 6039, 2689, 5378, 4011, 8022, 6915,
-	5033, 765, 1530, 3060, 6120, 2687, 5374, 3155, 6310, 5347,
-	3177, 6354, 5131, 3513, 7026, 4939, 825, 1650, 3300, 6600,
-	5695, 2513, 5026, 747, 1494, 2988, 5976, 2847, 5694, 2515,
-	5030, 739, 1478, 2956, 5912, 2975, 5950, 3027, 6054, 2787,
-	5574, 3619, 7238, 7459, 8169, 6781, 4437, 1797, 3594, 7188,
-	7559, 7841, 6381, 5237, 3397, 6794, 4283, 1241, 2482, 4964,
-	871, 1742, 3484, 6968, 5087, 529, 1058, 2116, 4232, 1215,
-	2430, 4860, 87, 174, 348, 696, 1392, 2784, 5568, 3631, 7262,
-	7443, 8073, 6845, 4309, 1029, 2058, 4116, 1415, 2830, 5660,
-	2455, 4910, 1011, 2022, 4044, 8088, 6815, 4241, 1165, 2330,
-	4660, 455, 910, 1820, 3640, 7280, 7503, 7985, 7117, 4661, 453,
-	906, 1812, 3624, 7248, 7439, 8113, 6861, 4149, 1477, 2954,
-	5908, 2951, 5902, 2995, 5990, 2915, 5830, 2083, 4166, 1315,
-	2630, 5260, 3255, 6510, 6003, 2889, 5778, 2187, 4374, 1923,
-	3846, 7692, 6583, 5825, 2093, 4186, 1307, 2614, 5228, 3447,
-	6894, 4211, 1353, 2706, 5412, 4071, 8142, 6707, 4553, 1597,
-	3194, 6388, 5191, 3361, 6722, 4395, 2041, 4082, 8164, 6759,
-	4449, 1901, 3802, 7604, 7879, 6177, 5613, 3701, 7402, 7291,
-	7513, 7965, 7061, 4741, 165, 330, 660, 1320, 2640, 5280, 3311,
-	6622, 5651, 2441, 4882, 907, 1814, 3628, 7256, 7455, 8081,
-	6797, 4277, 1221, 2442, 4884, 903, 1806, 3612, 7224, 7647,
-	7697, 6541, 5813, 2245, 4490, 1723, 3446, 6892, 4215, 1345,
-	2690, 5380, 4007, 8014, 6963, 5065, 573, 1146, 2292, 4584,
-	1663, 3326, 6652, 5719, 2305, 4610, 427, 854, 1708, 3416,
-	6832, 4303, 1073, 2146, 4292, 1063, 2126, 4252, 1175, 2350,
-	4700, 279, 558, 1116, 2232, 4464, 1871, 3742, 7484, 8151,
-	6657, 4525, 1781, 3562, 7124, 4615, 417, 834, 1668, 3336,
-	6672, 4495, 1713, 3426, 6852, 4135, 1505, 3010, 6020, 2727,
-	5454, 3891, 7782, 6499, 5993, 2941, 5882, 2139, 4278, 1219,
-	2438, 4876, 951, 1902, 3804, 7608, 7903, 6161, 5517, 3765,
-	7530, 8059, 7001, 4893, 917, 1834, 3668, 7336, 7423, 7249,
-	7437, 8117, 6853, 4133, 1509, 3018, 6036, 2695, 5390, 4019,
-	8038, 7011, 4969, 893, 1786, 3572, 7144, 4735, 337, 674, 1348,
-	2696, 5392, 3983, 7966, 7059, 4745, 189, 378, 756, 1512, 3024,
-	6048, 2799, 5598, 3603, 7206, 7651, 7785, 6525, 5973, 2821,
-	5642, 2491, 4982, 835, 1670, 3340, 6680, 4511, 1681, 3362,
-	6724, 4391, 2017, 4034, 8068, 6823, 4321, 1133, 2266, 4532,
-	1735, 3470, 6940, 5015, 641, 1282, 2564, 5128, 3519, 7038,
-	4947, 777, 1554, 3108, 6216, 5439, 4049, 8098, 6891, 4217,
-	1373, 2746, 5492, 3911, 7822, 6323, 5321, 3133, 6266, 5467,
-	3865, 7730, 6603, 5689, 2525, 5050, 731, 1462, 2924, 5848,
-	2079, 4158, 1491, 2982, 5964, 2871, 5742, 2419, 4838, 99, 198,
-	396, 792, 1584, 3168, 6336, 5167, 3569, 7138, 4715, 377, 754,
-	1508, 3016, 6032, 2703, 5406, 3987, 7974, 7139, 4713, 381,
-	762, 1524, 3048, 6096, 2575, 5150, 3475, 6950, 5091, 617,
-	1234, 2468, 4936, 831, 1662, 3324, 6648, 5727, 2321, 4642,
-	491, 982, 1964, 3928, 7856, 6351, 5169, 3533, 7066, 4763, 153,
-	306, 612, 1224, 2448, 4896, 1007, 2014, 4028, 8056, 7007,
-	4881, 909, 1818, 3636, 7272, 7551, 8017, 6925, 5045, 709,
-	1418, 2836, 5672, 2559, 5118, 595, 1190, 2380, 4760, 159, 318,
-	636, 1272, 2544, 5088, 623, 1246, 2492, 4984, 863, 1726, 3452,
-	6904, 4191, 1297, 2594, 5188, 3367, 6734, 4403, 1993, 3986,
-	7972, 7143, 4705, 365, 730, 1460, 2920, 5840, 2063, 4126,
-	1427, 2854, 5708, 2359, 4718, 371, 742, 1484, 2968, 5936,
-	3023, 6046, 2707, 5414, 4067, 8134, 6691, 4585, 1661, 3322,
-	6644, 5703, 2337, 4674, 299, 598, 1196, 2392, 4784, 207, 414,
-	828, 1656, 3312, 6624, 5743, 2417, 4834, 107, 214, 428, 856,
-	1712, 3424, 6848, 4143, 1521, 3042, 6084, 2599, 5198, 3379,
-	6758, 4451, 1897, 3794, 7588, 7911, 6241, 5485, 3957, 7914,
-	6267, 5465, 3869, 7738, 6619, 5657, 2461, 4922, 987, 1974,
-	3948, 7896, 6175, 5521, 3725, 7450, 8091, 6809, 4253, 1173,
-	2346, 4692, 263, 526, 1052, 2104, 4208, 1359, 2718, 5436,
-	4055, 8110, 6899, 4169, 1341, 2682, 5364, 3143, 6286, 5299,
-	3273, 6546, 5771, 2233, 4466, 1867, 3734, 7468, 8183, 6721,
-	4397, 2037, 4074, 8148, 6663, 4513, 1773, 3546, 7092, 4807,
-	33, 66, 132, 264, 528, 1056, 2112, 4224, 1199, 2398, 4796,
-	215, 430, 860, 1720, 3440, 6880, 4207, 1393, 2786, 5572, 3623,
-	7246, 7475, 8137, 6717, 4565, 1541, 3082, 6164, 5511, 3745,
-	7490, 7979, 7161, 4701, 277, 554, 1108, 2216, 4432, 1807,
-	3614, 7228, 7639, 7681, 6573, 5877, 2117, 4234, 1211, 2422,
-	4844, 119, 238, 476, 952, 1904, 3808, 7616, 7727, 6641, 5709,
-	2357, 4714, 379, 758, 1516, 3032, 6064, 2767, 5534, 3731,
-	7462, 8163, 6761, 4477, 1877, 3754, 7508, 7943, 7073, 4845,
-	117, 234, 468, 936, 1872, 3744, 7488, 7983, 7153, 4685, 309,
-	618, 1236, 2472, 4944, 783, 1566, 3132, 6264, 5471, 3857,
-	7714, 6635, 5753, 2397, 4794, 219, 438, 876, 1752, 3504, 7008,
-	4975, 881, 1762, 3524, 7048, 4799, 209, 418, 836, 1672, 3344,
-	6688, 4591, 1649, 3298, 6596, 5671, 2529, 5058, 555, 1110,
-	2220, 4440, 1823, 3646, 7292, 7511, 7937, 7085, 4853, 69, 138,
-	276, 552, 1104, 2208, 4416, 1839, 3678, 7356, 7383, 7169,
-	7597, 7925, 6213, 5413, 4069, 8138, 6715, 4569, 1565, 3130,
-	6260, 5447, 3873, 7746, 6443, 6137, 2653, 5306, 3291, 6582,
-	5827, 2089, 4178, 1291, 2582, 5164, 3575, 7150, 4723, 329,
-	658, 1316, 2632, 5264, 3215, 6430, 6035, 2697, 5394, 3979,
-	7958, 7043, 4777, 253, 506, 1012, 2024, 4048, 8096, 6895,
-	4209, 1357, 2714, 5428, 4039, 8078, 6835, 4297, 1085, 2170,
-	4340, 1095, 2190, 4380, 1943, 3886, 7772, 6423, 6017, 2733,
-	5466, 3867, 7734, 6595, 5673, 2557, 5114, 603, 1206, 2412,
-	4824, 31, 62, 124, 248, 496, 992, 1984, 3968, 7936, 7087,
-	4849, 77, 154, 308, 616, 1232, 2464, 4928, 815, 1630, 3260,
-	6520, 5983, 2833, 5666, 2539, 5078, 515, 1030, 2060, 4120,
-	1439, 2878, 5756, 2391, 4782, 243, 486, 972, 1944, 3888, 7776,
-	6511, 6001, 2893, 5786, 2203, 4406, 1987, 3974, 7948, 7095,
-	4801, 45, 90, 180, 360, 720, 1440, 2880, 5760, 2223, 4446,
-	1811, 3622, 7244, 7479, 8129, 6701, 4597, 1605, 3210, 6420,
-	6023, 2721, 5442, 3883, 7766, 6403, 6057, 2813, 5626, 3675,
-	7350, 7363, 7209, 7677, 7765, 6405, 6053, 2789, 5578, 3643,
-	7286, 7491, 7977, 7165, 4693, 261, 522, 1044, 2088, 4176,
-	1295, 2590, 5180, 3543, 7086, 4851, 73, 146, 292, 584, 1168,
-	2336, 4672, 303, 606, 1212, 2424, 4848, 79, 158, 316, 632,
-	1264, 2528, 5056, 559, 1118, 2236, 4472, 1887, 3774, 7548,
-	8023, 6913, 5037, 757, 1514, 3028, 6056, 2815, 5630, 3667,
-	7334, 7395, 7273, 7549, 8021, 6917, 5029, 741, 1482, 2964,
-	5928, 3071, 6142, 2643, 5286, 3299, 6598, 5667, 2537, 5074,
-	523, 1046, 2092, 4184, 1311, 2622, 5244, 3415, 6830, 4339,
-	1097, 2194, 4388, 2023, 4046, 8092, 6807, 4225, 1197, 2394,
-	4788, 199, 398, 796, 1592, 3184, 6368, 5231, 3441, 6882, 4203,
-	1401, 2802, 5604, 3687, 7374, 7219, 7625, 7741, 6613, 5637,
-	2469, 4938, 827, 1654, 3308, 6616, 5663, 2449, 4898, 1003,
-	2006, 4012, 8024, 6943, 5009, 653, 1306, 2612, 5224, 3455,
-	6910, 4179, 1289, 2578, 5156, 3559, 7118, 4659, 457, 914,
-	1828, 3656, 7312, 7311, 7345, 7373, 7221, 7621, 7717, 6629,
-	5733, 2405, 4810, 59, 118, 236, 472, 944, 1888, 3776, 7552,
-	7855, 6385, 5197, 3381, 6762, 4475, 1881, 3762, 7524, 8039,
-	7009, 4973, 885, 1770, 3540, 7080, 4863, 81, 162, 324, 648,
-	1296, 2592, 5184, 3375, 6750, 4371, 1929, 3858, 7716, 6631,
-	5729, 2413, 4826, 27, 54, 108, 216, 432, 864, 1728, 3456,
-	6912, 5039, 753, 1506, 3012, 6024, 2751, 5502, 3923, 7846,
-	6371, 5225, 3453, 6906, 4187, 1305, 2610, 5220, 3431, 6862,
-	4147, 1481, 2962, 5924, 3047, 6094, 2611, 5222, 3427, 6854,
-	4131, 1513, 3026, 6052, 2791, 5582, 3635, 7270, 7523, 8041,
-	7037, 4949, 773, 1546, 3092, 6184, 5631, 3665, 7330, 7403,
-	7289, 7517, 7957, 7045, 4773, 229, 458, 916, 1832, 3664, 7328,
-	7407, 7281, 7501, 7989, 7109, 4645, 485, 970, 1940, 3880,
-	7760, 6415, 6065, 2765, 5530, 3739, 7478, 8131, 6697, 4605,
-	1621, 3242, 6484, 5895, 2977, 5954, 2859, 5718, 2307, 4614,
-	419, 838, 1676, 3352, 6704, 4559, 1585, 3170, 6340, 5159,
-	3553, 7106, 4651, 505, 1010, 2020, 4040, 8080, 6799, 4273,
-	1229, 2458, 4916, 967, 1934, 3868, 7736, 6623, 5649, 2445,
-	4890, 923, 1846, 3692, 7384, 7199, 7569, 7821, 6325, 5317,
-	3109, 6218, 5435, 4057, 8114, 6859, 4153, 1501, 3002, 6004,
-	2887, 5774, 2227, 4454, 1891, 3782, 7564, 7863, 6337, 5165,
-	3573, 7146, 4731, 345, 690, 1380, 2760, 5520, 3727, 7454,
-	8083, 6793, 4285, 1237, 2474, 4948, 775, 1550, 3100, 6200,
-	5599, 3601, 7202, 7659, 7801, 6493, 5909, 2949, 5898, 3003,
-	6006, 2883, 5766, 2211, 4422, 1827, 3654, 7308, 7351, 7361,
-	7213, 7669, 7749, 6437, 6117, 2661, 5322, 3131, 6262, 5443,
-	3881, 7762, 6411, 6073, 2781, 5562, 3803, 7606, 7875, 6185,
-	5629, 3669, 7338, 7419, 7257, 7453, 8085, 6789, 4261, 1253,
-	2506, 5012, 647, 1294, 2588, 5176, 3551, 7102, 4819, 9, 18,
-	36, 72, 144, 288, 576, 1152, 2304, 4608, 431, 862, 1724, 3448,
-	6896, 4175, 1329, 2658, 5316, 3111, 6222, 5427, 4041, 8082,
-	6795, 4281, 1245, 2490, 4980, 839, 1678, 3356, 6712, 4575,
-	1553, 3106, 6212, 5415, 4065, 8130, 6699, 4601, 1629, 3258,
-	6516, 5959, 2849, 5698, 2347, 4694, 259, 518, 1036, 2072,
-	4144, 1487, 2974, 5948, 3031, 6062, 2803, 5606, 3683, 7366,
-	7203, 7657, 7805, 6485, 5893, 2981, 5962, 2875, 5750, 2371,
-	4742, 163, 326, 652, 1304, 2608, 5216, 3439, 6878, 4115, 1417,
-	2834, 5668, 2535, 5070, 563, 1126, 2252, 4504, 1695, 3390,
-	6780, 4439, 1793, 3586, 7172, 7591, 7905, 6253, 5493, 3909,
-	7818, 6331, 5337, 3101, 6202, 5595, 3609, 7218, 7627, 7737,
-	6621, 5653, 2437, 4874, 955, 1910, 3820, 7640, 7711, 6545,
-	5773, 2229, 4458, 1915, 3830, 7660, 7799, 6465, 5933, 3061,
-	6122, 2683, 5366, 3139, 6278, 5283, 3305, 6610, 5643, 2489,
-	4978, 843, 1686, 3372, 6744, 4383, 1937, 3874, 7748, 6439,
-	6113, 2669, 5338, 3099, 6198, 5571, 3625, 7250, 7435, 8121,
-	6877, 4117, 1413, 2826, 5652, 2439, 4878, 947, 1894, 3788,
-	7576, 7839, 6289, 5261, 3253, 6506, 6011, 2905, 5810, 2251,
-	4502, 1667, 3334, 6668, 4535, 1729, 3458, 6916, 5031, 737,
-	1474, 2948, 5896, 3007, 6014, 2899, 5798, 2275, 4550, 1571,
-	3142, 6284, 5303, 3265, 6530, 5803, 2297, 4594, 1611, 3222,
-	6444, 6135, 2625, 5250, 3243, 6486, 5891, 2985, 5970, 2827,
-	5654, 2435, 4870, 931, 1862, 3724, 7448, 8095, 6801, 4237,
-	1205, 2410, 4820, 7, 14, 28, 56, 112, 224, 448, 896, 1792,
-	3584, 7168, 7599, 7921, 6221, 5429, 4037, 8074, 6843, 4313,
-	1053, 2106, 4212, 1351, 2702, 5404, 3991, 7982, 7155, 4681,
-	317, 634, 1268, 2536, 5072, 527, 1054, 2108, 4216, 1375, 2750,
-	5500, 3927, 7854, 6387, 5193, 3389, 6778, 4443, 1817, 3634,
-	7268, 7527, 8033, 7021, 4981, 837, 1674, 3348, 6696, 4607,
-	1617, 3234, 6468, 5927, 3041, 6082, 2603, 5206, 3331, 6662,
-	4515, 1769, 3538, 7076, 4839, 97, 194, 388, 776, 1552, 3104,
-	6208, 5423, 4081, 8162, 6763, 4473, 1885, 3770, 7540, 8007,
-	6945, 5101, 629, 1258, 2516, 5032, 767, 1534, 3068, 6136,
-	2655, 5310, 3283, 6566, 5859, 2153, 4306, 1035, 2070, 4140,
-	1527, 3054, 6108, 2583, 5166, 3571, 7142, 4707, 361, 722,
-	1444, 2888, 5776, 2191, 4382, 1939, 3878, 7756, 6455, 6081,
-	2605, 5210, 3355, 6710, 4547, 1577, 3154, 6308, 5351, 3169,
-	6338, 5163, 3577, 7154, 4683, 313, 626, 1252, 2504, 5008, 655,
-	1310, 2620, 5240, 3423, 6846, 4307, 1033, 2066, 4132, 1511,
-	3022, 6044, 2711, 5422, 4083, 8166, 6755, 4457, 1917, 3834,
-	7668, 7751, 6433, 6125, 2677, 5354, 3195, 6390, 5187, 3369,
-	6738, 4363, 1977, 3954, 7908, 6247, 5473, 3949, 7898, 6171,
-	5529, 3741, 7482, 8155, 6681, 4509, 1685, 3370, 6740, 4359,
-	1953, 3906, 7812, 6311, 5345, 3181, 6362, 5147, 3481, 6962,
-	5067, 569, 1138, 2276, 4552, 1599, 3198, 6396, 5207, 3329,
-	6658, 4523, 1785, 3570, 7140, 4711, 353, 706, 1412, 2824,
-	5648, 2447, 4894, 915, 1830, 3660, 7320, 7327, 7313, 7309,
-	7349, 7365, 7205, 7653, 7781, 6501, 5989, 2917, 5834, 2107,
-	4214, 1347, 2694, 5388, 4023, 8046, 7027, 4937, 829, 1658,
-	3316, 6632, 5759, 2385, 4770, 235, 470, 940, 1880, 3760, 7520,
-	8047, 7025, 4941, 821, 1642, 3284, 6568, 5887, 2129, 4258,
-	1259, 2518, 5036, 759, 1518, 3036, 6072, 2783, 5566, 3795,
-	7590, 7907, 6249, 5501, 3925, 7850, 6395, 5209, 3357, 6714,
-	4571, 1561, 3122, 6244, 5479, 3937, 7874, 6187, 5625, 3677,
-	7354, 7387, 7193, 7581, 7829, 6277, 5285, 3301, 6602, 5691,
-	2521, 5042, 715, 1430, 2860, 5720, 2335, 4670, 467, 934, 1868,
-	3736, 7472, 8143, 6705, 4557, 1589, 3178, 6356, 5127, 3489,
-	6978, 4907, 1017, 2034, 4068, 8136, 6719, 4561, 1549, 3098,
-	6196, 5575, 3617, 7234, 7467, 8185, 6749, 4373, 1925, 3850,
-	7700, 6535, 5793, 2285, 4570, 1563, 3126, 6252, 5495, 3905,
-	7810, 6315, 5369, 3165, 6330, 5339, 3097, 6194, 5579, 3641,
-	7282, 7499, 7993, 7133, 4629, 389, 778, 1556, 3112, 6224,
-	5391, 4017, 8034, 7019, 4985, 861, 1722, 3444, 6888, 4223,
-	1361, 2722, 5444, 3879, 7758, 6451, 6089, 2621, 5242, 3419,
-	6838, 4291, 1065, 2130, 4260, 1255, 2510, 5020, 663, 1326,
-	2652, 5304, 3295, 6590, 5843, 2057, 4114, 1419, 2838, 5676,
-	2551, 5102, 627, 1254, 2508, 5016, 671, 1342, 2684, 5368,
-	3167, 6334, 5331, 3081, 6162, 5515, 3769, 7538, 8011, 6969,
-	5085, 533, 1066, 2132, 4264, 1279, 2558, 5116, 599, 1198,
-	2396, 4792, 223, 446, 892, 1784, 3568, 7136, 4719, 369, 738,
-	1476, 2952, 5904, 2959, 5918, 2963, 5926, 3043, 6086, 2595,
-	5190, 3363, 6726, 4387, 2025, 4050, 8100, 6887, 4193, 1389,
-	2778, 5556, 3783, 7566, 7859, 6345, 5181, 3541, 7082, 4859,
-	89, 178, 356, 712, 1424, 2848, 5696, 2351, 4702, 275, 550,
-	1100, 2200, 4400, 1999, 3998, 7996, 7127, 4609, 429, 858,
-	1716, 3432, 6864, 4111, 1457, 2914, 5828, 2087, 4174, 1331,
-	2662, 5324, 3127, 6254, 5491, 3913, 7826, 6283, 5305, 3293,
-	6586, 5851, 2073, 4146, 1483, 2966, 5932, 3063, 6126, 2675,
-	5350, 3171, 6342, 5155, 3561, 7122, 4619, 441, 882, 1764,
-	3528, 7056, 4751, 177, 354, 708, 1416, 2832, 5664, 2543, 5086,
-	531, 1062, 2124, 4248, 1183, 2366, 4732, 343, 686, 1372, 2744,
-	5488, 3919, 7838, 6291, 5257, 3261, 6522, 5979, 2841, 5682,
-	2507, 5014, 643, 1286, 2572, 5144, 3487, 6974, 5075, 521,
-	1042, 2084, 4168, 1343, 2686, 5372, 3159, 6318, 5363, 3145,
-	6290, 5259, 3257, 6514, 5963, 2873, 5746, 2379, 4758, 131,
-	262, 524, 1048, 2096, 4192, 1391, 2782, 5564, 3799, 7598,
-	7923, 6217, 5437, 4053, 8106, 6907, 4185, 1309, 2618, 5236,
-	3399, 6798, 4275, 1225, 2450, 4900, 999, 1998, 3996, 7992,
-	7135, 4625, 397, 794, 1588, 3176, 6352, 5135, 3505, 7010,
-	4971, 889, 1778, 3556, 7112, 4671, 465, 930, 1860, 3720, 7440,
-	8079, 6833, 4301, 1077, 2154, 4308, 1031, 2062, 4124, 1431,
-	2862, 5724, 2327, 4654, 499, 998, 1996, 3992, 7984, 7119,
-	4657, 461, 922, 1844, 3688, 7376, 7183, 7601, 7885, 6197,
-	5573, 3621, 7242, 7483, 8153, 6685, 4501, 1669, 3338, 6676,
-	4487, 1697, 3394, 6788, 4263, 1249, 2498, 4996, 679, 1358,
-	2716, 5432, 4063, 8126, 6867, 4105, 1469, 2938, 5876, 2119,
-	4238, 1203, 2406, 4812, 55, 110, 220, 440, 880, 1760, 3520,
-	7040, 4783, 241, 482, 964, 1928, 3856, 7712, 6639, 5745, 2381,
-	4762, 155, 310, 620, 1240, 2480, 4960, 879, 1758, 3516, 7032,
-	4959, 785, 1570, 3140, 6280, 5311, 3281, 6562, 5867, 2169,
-	4338, 1099, 2198, 4396, 2039, 4078, 8156, 6679, 4481, 1709,
-	3418, 6836, 4295, 1057, 2114, 4228, 1191, 2382, 4764, 151,
-	302, 604, 1208, 2416, 4832, 111, 222, 444, 888, 1776, 3552,
-	7104, 4655, 497, 994, 1988, 3976, 7952, 7055, 4785, 205, 410,
-	820, 1640, 3280, 6560, 5871, 2161, 4322, 1131, 2262, 4524,
-	1783, 3566, 7132, 4631, 385, 770, 1540, 3080, 6160, 5519,
-	3761, 7522, 8043, 7033, 4957, 789, 1578, 3156, 6312, 5375,
-	3153, 6306, 5355, 3193, 6386, 5195, 3385, 6770, 4427, 1849,
-	3698, 7396, 7271, 7521, 8045, 7029, 4933, 805, 1610, 3220,
-	6440, 6143, 2641, 5282, 3307, 6614, 5635, 2473, 4946, 779,
-	1558, 3116, 6232, 5407, 3985, 7970, 7147, 4729, 349, 698,
-	1396, 2792, 5584, 3599, 7198, 7571, 7817, 6333, 5333, 3077,
-	6154, 5563, 3801, 7602, 7883, 6201, 5597, 3605, 7210, 7675,
-	7769, 6429, 6037, 2693, 5386, 4027, 8054, 6979, 4905, 1021,
-	2042, 4084, 8168, 6783, 4433, 1805, 3610, 7220, 7623, 7713,
-	6637, 5749, 2373, 4746, 187, 374, 748, 1496, 2992, 5984, 2927,
-	5854, 2067, 4134, 1507, 3014, 6028, 2743, 5486, 3955, 7910,
-	6243, 5481, 3965, 7930, 6235, 5401, 3997, 7994, 7131, 4633,
-	413, 826, 1652, 3304, 6608, 5647, 2481, 4962, 875, 1750, 3500,
-	7000, 4895, 913, 1826, 3652, 7304, 7359, 7377, 7181, 7605,
-	7877, 6181, 5605, 3685, 7370, 7227, 7641, 7709, 6549, 5765,
-	2213, 4426, 1851, 3702, 7404, 7287, 7489, 7981, 7157, 4677,
-	293, 586, 1172, 2344, 4688, 271, 542, 1084, 2168, 4336, 1103,
-	2206, 4412, 2007, 4014, 8028, 6935, 4993, 685, 1370, 2740,
-	5480, 3967, 7934, 6227, 5385, 4029, 8058, 7003, 4889, 925,
-	1850, 3700, 7400, 7295, 7505, 7949, 7093, 4805, 37, 74, 148,
-	296, 592, 1184, 2368, 4736, 175, 350, 700, 1400, 2800, 5600,
-	3695, 7390, 7187, 7561, 7869, 6357, 5125, 3493, 6986, 4923,
-	985, 1970, 3940, 7880, 6207, 5585, 3597, 7194, 7579, 7833,
-	6301, 5269, 3205, 6410, 6075, 2777, 5554, 3787, 7574, 7811,
-	6313, 5373, 3157, 6314, 5371, 3161, 6322, 5323, 3129, 6258,
-	5451, 3897, 7794, 6475, 5945, 3037, 6074, 2779, 5558, 3779,
-	7558, 7843, 6377, 5245, 3413, 6826, 4347, 1113, 2226, 4452,
-	1895, 3790, 7580, 7831, 6273, 5293, 3317, 6634, 5755, 2393,
-	4786, 203, 406, 812, 1624, 3248, 6496, 5999, 2929, 5858, 2155,
-	4310, 1027, 2054, 4108, 1463, 2926, 5852, 2071, 4142, 1523,
-	3046, 6092, 2615, 5230, 3443, 6886, 4195, 1385, 2770, 5540,
-	3815, 7630, 7731, 6601, 5693, 2517, 5034, 763, 1526, 3052,
-	6104, 2591, 5182, 3539, 7078, 4835, 105, 210, 420, 840, 1680,
-	3360, 6720, 4399, 2033, 4066, 8132, 6695, 4577, 1645, 3290,
-	6580, 5831, 2081, 4162, 1323, 2646, 5292, 3319, 6638, 5747,
-	2377, 4754, 139, 278, 556, 1112, 2224, 4448, 1903, 3806, 7612,
-	7895, 6145, 5549, 3829, 7658, 7803, 6489, 5917, 2965, 5930,
-	3067, 6134, 2627, 5254, 3235, 6470, 5923, 3049, 6098, 2571,
-	5142, 3459, 6918, 5027, 745, 1490, 2980, 5960, 2879, 5758,
-	2387, 4774, 227, 454, 908, 1816, 3632, 7264, 7535, 8049, 6989,
-	4917, 965, 1930, 3860, 7720, 6655, 5713, 2317, 4634, 411, 822,
-	1644, 3288, 6576, 5839, 2097, 4194, 1387, 2774, 5548, 3831,
-	7662, 7795, 6473, 5949, 3029, 6058, 2811, 5622, 3651, 7302,
-	7331, 7401, 7293, 7509, 7941, 7077, 4837, 101, 202, 404, 808,
-	1616, 3232, 6464, 5935, 3057, 6114, 2667, 5334, 3075, 6150,
-	5539, 3817, 7634, 7691, 6585, 5853, 2069, 4138, 1531, 3062,
-	6124, 2679, 5358, 3187, 6374, 5219, 3433, 6866, 4107, 1465,
-	2930, 5860, 2151, 4302, 1075, 2150, 4300, 1079, 2158, 4316,
-	1047, 2094, 4188, 1303, 2606, 5212, 3351, 6702, 4595, 1609,
-	3218, 6436, 6119, 2657, 5314, 3115, 6230, 5379, 4009, 8018,
-	6923, 5049, 733, 1466, 2932, 5864, 2175, 4350, 1107, 2214,
-	4428, 1847, 3694, 7388, 7191, 7553, 7853, 6389, 5189, 3365,
-	6730, 4411, 2009, 4018, 8036, 7015, 4961, 877, 1754, 3508,
-	7016, 4991, 849, 1698, 3396, 6792, 4287, 1233, 2466, 4932,
-	807, 1614, 3228, 6456, 6111, 2577, 5154, 3563, 7126, 4611,
-	425, 850, 1700, 3400, 6800, 4239, 1201, 2402, 4804, 39, 78,
-	156, 312, 624, 1248, 2496, 4992, 687, 1374, 2748, 5496, 3935,
-	7870, 6355, 5129, 3517, 7034, 4955, 793, 1586, 3172, 6344,
-	5183, 3537, 7074, 4843, 121, 242, 484, 968, 1936, 3872, 7744,
-	6447, 6129, 2637, 5274, 3227, 6454, 6083, 2601, 5202, 3339,
-	6678, 4483, 1705, 3410, 6820, 4327, 1121, 2242, 4484, 1703,
-	3406, 6812, 4247, 1153, 2306, 4612, 423, 846, 1692, 3384,
-	6768, 4431, 1841, 3682, 7364, 7207, 7649, 7789, 6517, 5957,
-	2853, 5706, 2363, 4726, 323, 646, 1292, 2584, 5168, 3535,
-	7070, 4755, 137, 274, 548, 1096, 2192, 4384, 2031, 4062, 8124,
-	6871, 4097, 1453, 2906, 5812, 2247, 4494, 1715, 3430, 6860,
-	4151, 1473, 2946, 5892, 2983, 5966, 2867, 5734, 2403, 4806,
-	35, 70, 140, 280, 560, 1120, 2240, 4480, 1711, 3422, 6844,
-	4311, 1025, 2050, 4100, 1447, 2894, 5788, 2199, 4398, 2035,
-	4070, 8140, 6711, 4545, 1581, 3162, 6324, 5319, 3105, 6210,
-	5419, 4089, 8178, 6731, 4409, 2013, 4026, 8052, 6983, 4897,
-	1005, 2010, 4020, 8040, 7039, 4945, 781, 1562, 3124, 6248,
-	5503, 3921, 7842, 6379, 5241, 3421, 6842, 4315, 1049, 2098,
-	4196, 1383, 2766, 5532, 3735, 7470, 8179, 6729, 4413, 2005,
-	4010, 8020, 6919, 5025, 749, 1498, 2996, 5992, 2943, 5886,
-	2131, 4262, 1251, 2502, 5004, 695, 1390, 2780, 5560, 3807,
-	7614, 7891, 6153, 5565, 3797, 7594, 7931, 6233, 5405, 3989,
-	7978, 7163, 4697, 285, 570, 1140, 2280, 4560, 1551, 3102,
-	6204, 5591, 3585, 7170, 7595, 7929, 6237, 5397, 3973, 7946,
-	7099, 4825, 29, 58, 116, 232, 464, 928, 1856, 3712, 7424,
-	8111, 6897, 4173, 1333, 2666, 5332, 3079, 6158, 5555, 3785,
-	7570, 7819, 6329, 5341, 3093, 6186, 5627, 3673, 7346, 7371,
-	7225, 7645, 7701, 6533, 5797, 2277, 4554, 1595, 3190, 6380,
-	5239, 3393, 6786, 4267, 1273, 2546, 5092, 615, 1230, 2460,
-	4920, 991, 1982, 3964, 7928, 6239, 5393, 3981, 7962, 7067,
-	4761, 157, 314, 628, 1256, 2512, 5024, 751, 1502, 3004, 6008,
-	2911, 5822, 2259, 4518, 1763, 3526, 7052, 4791, 193, 386, 772,
-	1544, 3088, 6176, 5615, 3697, 7394, 7275, 7545, 8029, 6933,
-	4997, 677, 1354, 2708, 5416, 4095, 8190, 6739, 4361, 1981,
-	3962, 7924, 6215, 5409, 4077, 8154, 6683, 4505, 1693, 3386,
-	6772, 4423, 1825, 3650, 7300, 7335, 7393, 7277, 7541, 8005,
-	6949, 5093, 613, 1226, 2452, 4904, 1023, 2046, 4092, 8184,
-	6751, 4369, 1933, 3866, 7732, 6599, 5665, 2541, 5082, 539,
-	1078, 2156, 4312, 1055, 2110, 4220, 1367, 2734, 5468, 3863,
-	7726, 6643, 5705, 2365, 4730, 347, 694, 1388, 2776, 5552,
-	3791, 7582, 7827, 6281, 5309, 3285, 6570, 5883, 2137, 4274,
-	1227, 2454, 4908, 1015, 2030, 4060, 8120, 6879, 4113, 1421,
-	2842, 5684, 2503, 5006, 691, 1382, 2764, 5528, 3743, 7486,
-	8147, 6665, 4541, 1749, 3498, 6996, 4871, 929, 1858, 3716,
-	7432, 8127, 6865, 4109, 1461, 2922, 5844, 2055, 4110, 1459,
-	2918, 5836, 2103, 4206, 1395, 2790, 5580, 3639, 7278, 7539,
-	8009, 6973, 5077, 517, 1034, 2068, 4136, 1535, 3070, 6140,
-	2647, 5294, 3315, 6630, 5731, 2409, 4818, 11, 22, 44, 88, 176,
-	352, 704, 1408, 2816, 5632, 2479, 4958, 787, 1574, 3148, 6296,
-	5279, 3217, 6434, 6123, 2681, 5362, 3147, 6294, 5251, 3241,
-	6482, 5899, 3001, 6002, 2891, 5782, 2179, 4358, 1955, 3910,
-	7820, 6327, 5313, 3117, 6234, 5403, 3993, 7986, 7115, 4665,
-	477, 954, 1908, 3816, 7632, 7695, 6577, 5837, 2101, 4202,
-	1403, 2806, 5612, 3703, 7406, 7283, 7497, 7997, 7125, 4613,
-	421, 842, 1684, 3368, 6736, 4367, 1969, 3938, 7876, 6183,
-	5601, 3693, 7386, 7195, 7577, 7837, 6293, 5253, 3237, 6474,
-	5947, 3033, 6066, 2763, 5526, 3715, 7430, 8099, 6889, 4221,
-	1365, 2730, 5460, 3847, 7694, 6579, 5833, 2109, 4218, 1371,
-	2742, 5484, 3959, 7918, 6259, 5449, 3901, 7802, 6491, 5913,
-	2973, 5946, 3035, 6070, 2755, 5510, 3747, 7494, 7971, 7145,
-	4733, 341, 682, 1364, 2728, 5456, 3855, 7710, 6547, 5769,
-	2237, 4474, 1883, 3766, 7532, 8055, 6977, 4909, 1013, 2026,
-	4052, 8104, 6911, 4177, 1293, 2586, 5172, 3527, 7054, 4787,
-	201, 402, 804, 1608, 3216, 6432, 6127, 2673, 5346, 3179, 6358,
-	5123, 3497, 6994, 4875, 953, 1906, 3812, 7624, 7743, 6609,
-	5645, 2485, 4970, 891, 1782, 3564, 7128, 4639, 401, 802, 1604,
-	3208, 6416, 6031, 2737, 5474, 3947, 7894, 6147, 5545, 3837,
-	7674, 7771, 6425, 6045, 2709, 5418, 4091, 8182, 6723, 4393,
-	2045, 4090, 8180, 6727, 4385, 2029, 4058, 8116, 6855, 4129,
-	1517, 3034, 6068, 2759, 5518, 3763, 7526, 8035, 7017, 4989,
-	853, 1706, 3412, 6824, 4351, 1105, 2210, 4420, 1831, 3662,
-	7324, 7319, 7297, 7341, 7413, 7237, 7461, 8165, 6757, 4453,
-	1893, 3786, 7572, 7815, 6305, 5357, 3189, 6378, 5243, 3417,
-	6834, 4299, 1081, 2162, 4324, 1127, 2254, 4508, 1687, 3374,
-	6748, 4375, 1921, 3842, 7684, 6567, 5857, 2157, 4314, 1051,
-	2102, 4204, 1399, 2798, 5596, 3607, 7214, 7667, 7753, 6461,
-	6101, 2565, 5130, 3515, 7030, 4931, 809, 1618, 3236, 6472,
-	5951, 3025, 6050, 2795, 5590, 3587, 7174, 7587, 7913, 6269,
-	5461, 3845, 7690, 6587, 5849, 2077, 4154, 1499, 2998, 5996,
-	2935, 5870, 2163, 4326, 1123, 2246, 4492, 1719, 3438, 6876,
-	4119, 1409, 2818, 5636, 2471, 4942, 819, 1638, 3276, 6552,
-	5791, 2193, 4386, 2027, 4054, 8108, 6903, 4161, 1325, 2650,
-	5300, 3271, 6542, 5811, 2249, 4498, 1675, 3350, 6700, 4599,
-	1601, 3202, 6404, 6055, 2785, 5570, 3627, 7254, 7427, 8105,
-	6909, 4181, 1285, 2570, 5140, 3463, 6926, 5043, 713, 1426,
-	2852, 5704, 2367, 4734, 339, 678, 1356, 2712, 5424, 4047,
-	8094, 6803, 4233, 1213, 2426, 4852, 71, 142, 284, 568, 1136,
-	2272, 4544, 1583, 3166, 6332, 5335, 3073, 6146, 5547, 3833,
-	7666, 7755, 6457, 6109, 2581, 5162, 3579, 7158, 4675, 297,
-	594, 1188, 2376, 4752, 143, 286, 572, 1144, 2288, 4576, 1647,
-	3294, 6588, 5847, 2049, 4098, 1451, 2902, 5804, 2295, 4590,
-	1651, 3302, 6604, 5687, 2497, 4994, 683, 1366, 2732, 5464,
-	3871, 7742, 6611, 5641, 2493, 4986, 859, 1718, 3436, 6872,
-	4127, 1425, 2850, 5700, 2343, 4686, 307, 614, 1228, 2456,
-	4912, 975, 1950, 3900, 7800, 6495, 5905, 2957, 5914, 2971,
-	5942, 3011, 6022, 2723, 5446, 3875, 7750, 6435, 6121, 2685,
-	5370, 3163, 6326, 5315, 3113, 6226, 5387, 4025, 8050, 6987,
-	4921, 989, 1978, 3956, 7912, 6271, 5457, 3853, 7706, 6555,
-	5785, 2205, 4410, 2011, 4022, 8044, 7031, 4929, 813, 1626,
-	3252, 6504, 6015, 2897, 5794, 2283, 4566, 1539, 3078, 6156,
-	5559, 3777, 7554, 7851, 6393, 5213, 3349, 6698, 4603, 1625,
-	3250, 6500, 5991, 2913, 5826, 2091, 4182, 1283, 2566, 5132,
-	3511, 7022, 4979, 841, 1682, 3364, 6728, 4415, 2001, 4002,
-	8004, 6951, 5089, 621, 1242, 2484, 4968, 895, 1790, 3580,
-	7160, 4703, 273, 546, 1092, 2184, 4368, 1935, 3870, 7740,
-	6615, 5633, 2477, 4954, 795, 1590, 3180, 6360, 5151, 3473,
-	6946, 5099, 633, 1266, 2532, 5064, 575, 1150, 2300, 4600,
-	1631, 3262, 6524, 5975, 2817, 5634, 2475, 4950, 771, 1542,
-	3084, 6168, 5535, 3729, 7458, 8171, 6777, 4445, 1813, 3626,
-	7252, 7431, 8097, 6893, 4213, 1349, 2698, 5396, 3975, 7950,
-	7091, 4809, 61, 122, 244, 488, 976, 1952, 3904, 7808, 6319,
-	5361, 3149, 6298, 5275, 3225, 6450, 6091, 2617, 5234, 3403,
-	6806, 4227, 1193, 2386, 4772, 231, 462, 924, 1848, 3696, 7392,
-	7279, 7537, 8013, 6965, 5061, 549, 1098, 2196, 4392, 2047,
-	4094, 8188, 6743, 4353, 1965, 3930, 7860, 6343, 5153, 3565,
-	7130, 4635, 409, 818, 1636, 3272, 6544, 5775, 2225, 4450,
-	1899, 3798, 7596, 7927, 6209, 5421, 4085, 8170, 6779, 4441,
-	1821, 3642, 7284, 7495, 7969, 7149, 4725, 325, 650, 1300,
-	2600, 5200, 3343, 6686, 4499, 1673, 3346, 6692, 4583, 1633,
-	3266, 6532, 5799, 2273, 4546, 1579, 3158, 6316, 5367, 3137,
-	6274, 5291, 3321, 6642, 5707, 2361, 4722, 331, 662, 1324,
-	2648, 5296, 3279, 6558, 5779, 2185, 4370, 1931, 3862, 7724,
-	6647, 5697, 2349, 4698, 283, 566, 1132, 2264, 4528, 1743,
-	3486, 6972, 5079, 513, 1026, 2052, 4104, 1471, 2942, 5884,
-	2135, 4270, 1267, 2534, 5068, 567, 1134, 2268, 4536, 1759,
-	3518, 7036, 4951, 769, 1538, 3076, 6152, 5567, 3793, 7586,
-	7915, 6265, 5469, 3861, 7722, 6651, 5721, 2333, 4666, 475,
-	950, 1900, 3800, 7600, 7887, 6193, 5581, 3637, 7274, 7547,
-	8025, 6941, 5013, 645, 1290, 2580, 5160, 3583, 7166, 4691,
-	265, 530, 1060, 2120, 4240, 1167, 2334, 4668, 471, 942, 1884,
-	3768, 7536, 8015, 6961, 5069, 565, 1130, 2260, 4520, 1791,
-	3582, 7164, 4695, 257, 514, 1028, 2056, 4112, 1423, 2846,
-	5692, 2519, 5038, 755, 1510, 3020, 6040, 2719, 5438, 4051,
-	8102, 6883, 4201, 1405, 2810, 5620, 3655, 7310, 7347, 7369,
-	7229, 7637, 7685, 6565, 5861, 2149, 4298, 1083, 2166, 4332,
-	1143, 2286, 4572, 1559, 3118, 6236, 5399, 3969, 7938, 7083,
-	4857, 93, 186, 372, 744, 1488, 2976, 5952, 2863, 5726, 2323,
-	4646, 483, 966, 1932, 3864, 7728, 6607, 5681, 2509, 5018, 667,
-	1334, 2668, 5336, 3103, 6206, 5587, 3593, 7186, 7563, 7865,
-	6365, 5141, 3461, 6922, 5051, 729, 1458, 2916, 5832, 2111,
-	4222, 1363, 2726, 5452, 3895, 7790, 6515, 5961, 2877, 5754,
-	2395, 4790, 195, 390, 780, 1560, 3120, 6240, 5487, 3953, 7906,
-	6251, 5497, 3933, 7866, 6363, 5145, 3485, 6970, 5083, 537,
-	1074, 2148, 4296, 1087, 2174, 4348, 1111, 2222, 4444, 1815,
-	3630, 7260, 7447, 8065, 6829, 4341, 1093, 2186, 4372, 1927,
-	3854, 7708, 6551, 5761, 2221, 4442, 1819, 3638, 7276, 7543,
-	8001, 6957, 5109, 581, 1162, 2324, 4648, 511, 1022, 2044,
-	4088, 8176, 6735, 4401, 1997, 3994, 7988, 7111, 4641, 493,
-	986, 1972, 3944, 7888, 6159, 5553, 3789, 7578, 7835, 6297,
-	5277, 3221, 6442, 6139, 2649, 5298, 3275, 6550, 5763, 2217,
-	4434, 1803, 3606, 7212, 7671, 7745, 6445, 6133, 2629, 5258,
-	3259, 6518, 5955, 2857, 5714, 2315, 4630, 387, 774, 1548,
-	3096, 6192, 5583, 3633, 7266, 7531, 8057, 7005, 4885, 901,
-	1802, 3604, 7208, 7679, 7761, 6413, 6069, 2757, 5514, 3771,
-	7542, 8003, 6953, 5117, 597, 1194, 2388, 4776, 255, 510, 1020,
-	2040, 4080, 8160, 6767, 4465, 1869, 3738, 7476, 8135, 6689,
-	4589, 1653, 3306, 6612, 5639, 2465, 4930, 811, 1622, 3244,
-	6488, 5919, 2961, 5922, 3051, 6102, 2563, 5126, 3491, 6982,
-	4899, 1001, 2002, 4004, 8008, 6975, 5073, 525, 1050, 2100,
-	4200, 1407, 2814, 5628, 3671, 7342, 7411, 7241, 7485, 8149,
-	6661, 4517, 1765, 3530, 7060, 4743, 161, 322, 644, 1288, 2576,
-	5152, 3567, 7134, 4627, 393, 786, 1572, 3144, 6288, 5263,
-	3249, 6498, 5995, 2937, 5874, 2123, 4246, 1155, 2310, 4620,
-	439, 878, 1756, 3512, 7024, 4943, 817, 1634, 3268, 6536, 5823,
-	2257, 4514, 1771, 3542, 7084, 4855, 65, 130, 260, 520, 1040,
-	2080, 4160, 1327, 2654, 5308, 3287, 6574, 5875, 2121, 4242,
-	1163, 2326, 4652, 503, 1006, 2012, 4024, 8048, 6991, 4913,
-	973, 1946, 3892, 7784, 6527, 5969, 2829, 5658, 2459, 4918,
-	963, 1926, 3852, 7704, 6559, 5777, 2189, 4378, 1947, 3894,
-	7788, 6519, 5953, 2861, 5722, 2331, 4662, 451, 902, 1804,
-	3608, 7216, 7631, 7729, 6605, 5685, 2501, 5002, 699, 1398,
-	2796, 5592, 3615, 7230, 7635, 7689, 6589, 5845, 2053, 4106,
-	1467, 2934, 5868, 2167, 4334, 1139, 2278, 4556, 1591, 3182,
-	6364, 5143, 3457, 6914, 5035, 761, 1522, 3044, 6088, 2623,
-	5246, 3411, 6822, 4323, 1129, 2258, 4516, 1767, 3534, 7068,
-	4759, 129, 258, 516, 1032, 2064, 4128, 1519, 3038, 6076, 2775,
-	5550, 3827, 7654, 7779, 6505, 6013, 2901, 5802, 2299, 4598,
-	1603, 3206, 6412, 6071, 2753, 5506, 3755, 7510, 7939, 7081,
-	4861, 85, 170, 340, 680, 1360, 2720, 5440, 3887, 7774, 6419,
-	6025, 2749, 5498, 3931, 7862, 6339, 5161, 3581, 7162, 4699,
-	281, 562, 1124, 2248, 4496, 1679, 3358, 6716, 4567, 1537,
-	3074, 6148, 5543, 3809, 7618, 7723, 6649, 5725, 2325, 4650,
-	507, 1014, 2028, 4056, 8112, 6863, 4145, 1485, 2970, 5940,
-	3015, 6030, 2739, 5478, 3939, 7878, 6179, 5609, 3709, 7418,
-	7259, 7449, 8093, 6805, 4229, 1189, 2378, 4756, 135, 270, 540,
-	1080, 2160, 4320, 1135, 2270, 4540, 1751, 3502, 7004, 4887,
-	897, 1794, 3588, 7176, 7615, 7889, 6157, 5557, 3781, 7562,
-	7867, 6361, 5149, 3477, 6954, 5115, 601, 1202, 2404, 4808, 63,
-	126, 252, 504, 1008, 2016, 4032, 8064, 6831, 4337, 1101, 2202,
-	4404, 1991, 3982, 7964, 7063, 4737, 173, 346, 692, 1384, 2768,
-	5536, 3823, 7646, 7699, 6537, 5821, 2261, 4522, 1787, 3574,
-	7148, 4727, 321, 642, 1284, 2568, 5136, 3471, 6942, 5011, 649,
-	1298, 2596, 5192, 3391, 6782, 4435, 1801, 3602, 7204, 7655,
-	7777, 6509, 6005, 2885, 5770, 2235, 4470, 1859, 3718, 7436,
-	8119, 6849, 4141, 1525, 3050, 6100, 2567, 5134, 3507, 7014,
-	4963, 873, 1746, 3492, 6984, 4927, 977, 1954, 3908, 7816,
-	6335, 5329, 3085, 6170, 5531, 3737, 7474, 8139, 6713, 4573,
-	1557, 3114, 6228, 5383, 4001, 8002, 6955, 5113, 605, 1210,
-	2420, 4840, 127, 254, 508, 1016, 2032, 4064, 8128, 6703, 4593,
-	1613, 3226, 6452, 6087, 2593, 5186, 3371, 6742, 4355, 1961,
-	3922, 7844, 6375, 5217, 3437, 6874, 4123, 1433, 2866, 5732,
-	2407, 4814, 51, 102, 204, 408, 816, 1632, 3264, 6528, 5807,
-	2289, 4578, 1643, 3286, 6572, 5879, 2113, 4226, 1195, 2390,
-	4780, 247, 494, 988, 1976, 3952, 7904, 6255, 5489, 3917, 7834,
-	6299, 5273, 3229, 6458, 6107, 2585, 5170, 3531, 7062, 4739,
-	169, 338, 676, 1352, 2704, 5408, 4079, 8158, 6675, 4489, 1725,
-	3450, 6900, 4167, 1313, 2626, 5252, 3239, 6478, 5939, 3017,
-	6034, 2699, 5398, 3971, 7942, 7075, 4841, 125, 250, 500, 1000,
-	2000, 4000, 8000, 6959, 5105, 589, 1178, 2356, 4712, 383, 766,
-	1532, 3064, 6128, 2639, 5278, 3219, 6438, 6115, 2665, 5330,
-	3083, 6166, 5507, 3753, 7506, 7947, 7097, 4829, 21, 42, 84,
-	168, 336, 672, 1344, 2688, 5376, 4015, 8030, 6931, 5001, 701,
-	1402, 2804, 5608, 3711, 7422, 7251, 7433, 8125, 6869, 4101,
-	1445, 2890, 5780, 2183, 4366, 1971, 3942, 7884, 6199, 5569,
-	3629, 7258, 7451, 8089, 6813, 4245, 1157, 2314, 4628, 391,
-	782, 1564, 3128, 6256, 5455, 3889, 7778, 6507, 6009, 2909,
-	5818, 2267, 4534, 1731, 3462, 6924, 5047, 705, 1410, 2820,
-	5640, 2495, 4990, 851, 1702, 3404, 6808, 4255, 1169, 2338,
-	4676, 295, 590, 1180, 2360, 4720, 335, 670, 1340, 2680, 5360,
-	3151, 6302, 5267, 3209, 6418, 6027, 2745, 5490, 3915, 7830,
-	6275, 5289, 3325, 6650, 5723, 2329, 4658, 459, 918, 1836,
-	3672, 7344, 7375, 7217, 7629, 7733, 6597, 5669, 2533, 5066,
-	571, 1142, 2284, 4568, 1567, 3134, 6268, 5463, 3841, 7682,
-	6571, 5881, 2141, 4282, 1243, 2486, 4972, 887, 1774, 3548,
-	7096, 4831, 17, 34, 68, 136, 272, 544, 1088, 2176, 4352, 1967,
-	3934, 7868, 6359, 5121, 3501, 7002, 4891, 921, 1842, 3684,
-	7368, 7231, 7633, 7693, 6581, 5829, 2085, 4170, 1339, 2678,
-	5356, 3191, 6382, 5235, 3401, 6802, 4235, 1209, 2418, 4836,
-	103, 206, 412, 824, 1648, 3296, 6592, 5679, 2545, 5090, 619,
-	1238, 2476, 4952, 799, 1598, 3196, 6392, 5215, 3345, 6690,
-	4587, 1657, 3314, 6628, 5735, 2401, 4802, 43, 86, 172, 344,
-	688, 1376, 2752, 5504, 3759, 7518, 7955, 7049, 4797, 213, 426,
-	852, 1704, 3408, 6816, 4335, 1137, 2274, 4548, 1575, 3150,
-	6300, 5271, 3201, 6402, 6059, 2809, 5618, 3659, 7318, 7299,
-	7337, 7421, 7253, 7429, 8101, 6885, 4197, 1381, 2762, 5524,
-	3719, 7438, 8115, 6857, 4157, 1493, 2986, 5972, 2823, 5646,
-	2483, 4966, 867, 1734, 3468, 6936, 5023, 657, 1314, 2628,
-	5256, 3263, 6526, 5971, 2825, 5650, 2443, 4886, 899, 1798,
-	3596, 7192, 7583, 7825, 6285, 5301, 3269, 6538, 5819, 2265,
-	4530, 1739, 3478, 6956, 5111, 577, 1154, 2308, 4616, 447, 894,
-	1788, 3576, 7152, 4687, 305, 610, 1220, 2440, 4880, 911, 1822,
-	3644, 7288, 7519, 7953, 7053, 4789, 197, 394, 788, 1576, 3152,
-	6304, 5359, 3185, 6370, 5227, 3449, 6898, 4171, 1337, 2674,
-	5348, 3175, 6350, 5171, 3529, 7058, 4747, 185, 370, 740, 1480,
-	2960, 5920, 3055, 6110, 2579, 5158, 3555, 7110, 4643, 489,
-	978, 1956, 3912, 7824, 6287, 5297, 3277, 6554, 5787, 2201,
-	4402, 1995, 3990, 7980, 7159, 4673, 301, 602, 1204, 2408,
-	4816, 15, 30, 60, 120, 240, 480, 960, 1920, 3840, 7680, 6575,
-	5873, 2125, 4250, 1179, 2358, 4716, 375, 750, 1500, 3000,
-	6000, 2895, 5790, 2195, 4390, 2019, 4038, 8076, 6839, 4289,
-	1069, 2138, 4276, 1223, 2446, 4892, 919, 1838, 3676, 7352,
-	7391, 7185, 7565, 7861, 6341, 5157, 3557, 7114, 4667, 473,
-	946, 1892, 3784, 7568, 7823, 6321, 5325, 3125, 6250, 5499,
-	3929, 7858, 6347, 5177, 3549, 7098, 4827, 25, 50, 100, 200,
-	400, 800, 1600, 3200, 6400, 6063, 2801, 5602, 3691, 7382,
-	7171, 7593, 7933, 6229, 5381, 4005, 8010, 6971, 5081, 541,
-	1082, 2164, 4328, 1151, 2302, 4604, 1623, 3246, 6492, 5911,
-	2945, 5890, 2987, 5974, 2819, 5638, 2467, 4934, 803, 1606,
-	3212, 6424, 6047, 2705, 5410, 4075, 8150, 6659, 4521, 1789,
-	3578, 7156, 4679, 289, 578, 1156, 2312, 4624, 399, 798, 1596,
-	3192, 6384, 5199, 3377, 6754, 4459, 1913, 3826, 7652, 7783,
-	6497, 5997, 2933, 5866, 2171, 4342, 1091, 2182, 4364, 1975,
-	3950, 7900, 6167, 5505, 3757, 7514, 7963, 7065, 4765, 149,
-	298, 596, 1192, 2384, 4768, 239, 478, 956, 1912, 3824, 7648,
-	7791, 6513, 5965, 2869, 5738, 2427, 4854, 67, 134, 268, 536,
-	1072, 2144, 4288, 1071, 2142, 4284, 1239, 2478, 4956, 791,
-	1582, 3164, 6328, 5343, 3089, 6178, 5611, 3705, 7410, 7243,
-	7481, 8157, 6677, 4485, 1701, 3402, 6804, 4231, 1185, 2370,
-	4740, 167, 334, 668, 1336, 2672, 5344, 3183, 6366, 5139, 3465,
-	6930, 5003, 697, 1394, 2788, 5576, 3647, 7294, 7507, 7945,
-	7101, 4821, 5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560,
-	5120, 3503, 7006, 4883, 905, 1810, 3620, 7240, 7487, 8145,
-	6669, 4533, 1733, 3466, 6932, 4999, 673, 1346, 2692, 5384,
-	4031, 8062, 6995, 4873, 957, 1914, 3828, 7656, 7807, 6481,
-	5901, 2997, 5994, 2939, 5878, 2115, 4230, 1187, 2374, 4748,
-	183, 366, 732, 1464, 2928, 5856, 2159, 4318, 1043, 2086, 4172,
-	1335, 2670, 5340, 3095, 6190, 5619, 3657, 7314, 7307, 7353,
-	7389, 7189, 7557, 7845, 6373, 5221, 3429, 6858, 4155, 1497,
-	2994, 5988, 2919, 5838, 2099, 4198, 1379, 2758, 5516, 3767,
-	7534, 8051, 6985, 4925, 981, 1962, 3924, 7848, 6399, 5201,
-	3341, 6682, 4507, 1689, 3378, 6756, 4455, 1889, 3778, 7556,
-	7847, 6369, 5229, 3445, 6890, 4219, 1369, 2738, 5476, 3943,
-	7886, 6195, 5577, 3645, 7290, 7515, 7961, 7069, 4757, 133,
-	266, 532, 1064, 2128, 4256, 1263, 2526, 5052, 727, 1454, 2908,
-	5816, 2271, 4542, 1747, 3494, 6988, 4919, 961, 1922, 3844,
-	7688, 6591, 5841, 2061, 4122, 1435, 2870, 5740, 2423, 4846,
-	115, 230, 460, 920, 1840, 3680, 7360, 7215, 7665, 7757, 6453,
-	6085, 2597, 5194, 3387, 6774, 4419, 1833, 3666, 7332, 7399,
-	7265, 7533, 8053, 6981, 4901, 997, 1994, 3988, 7976, 7167,
-	4689, 269, 538, 1076, 2152, 4304, 1039, 2078, 4156, 1495,
-	2990, 5980, 2839, 5678, 2547, 5094, 611, 1222, 2444, 4888,
-	927, 1854, 3708, 7416, 7263, 7441, 8077, 6837, 4293, 1061,
-	2122, 4244, 1159, 2318, 4636, 407, 814, 1628, 3256, 6512,
-	5967, 2865, 5730, 2411, 4822, 3, 6, 12, 24, 48, 96, 192, 384,
-	768, 1536, 3072, 6144, 5551, 3825, 7650, 7787, 6521, 5981,
-	2837, 5674, 2555, 5110, 579, 1158, 2316, 4632, 415, 830, 1660,
-	3320, 6640, 5711, 2353, 4706, 363, 726, 1452, 2904, 5808,
-	2255, 4510, 1683, 3366, 6732, 4407, 1985, 3970, 7940, 7079,
-	4833, 109, 218, 436, 872, 1744, 3488, 6976, 4911, 1009, 2018,
-	4036, 8072, 6847, 4305, 1037, 2074, 4148, 1479, 2958, 5916,
-	2967, 5934, 3059, 6118, 2659, 5318, 3107, 6214, 5411, 4073,
-	8146, 6667, 4537, 1757, 3514, 7028, 4935, 801, 1602, 3204,
-	6408, 6079, 2769, 5538, 3819, 7638, 7683, 6569, 5885, 2133,
-	4266, 1275, 2550, 5100, 631, 1262, 2524, 5048, 735, 1470,
-	2940, 5880, 2143, 4286, 1235, 2470, 4940, 823, 1646, 3292,
-	6584, 5855, 2065, 4130, 1515, 3030, 6060, 2807, 5614, 3699,
-	7398, 7267, 7529, 8061, 6997, 4869, 933, 1866, 3732, 7464,
-	8191, 6737, 4365, 1973, 3946, 7892, 6151, 5537, 3821, 7642,
-	7707, 6553, 5789, 2197, 4394, 2043, 4086, 8172, 6775, 4417,
-	1837, 3674, 7348, 7367, 7201, 7661, 7797, 6469, 5925, 3045,
-	6090, 2619, 5238, 3395, 6790, 4259, 1257, 2514, 5028, 743,
-	1486, 2972, 5944, 3039, 6078, 2771, 5542, 3811, 7622, 7715,
-	6633, 5757, 2389, 4778, 251, 502, 1004, 2008, 4016, 8032,
-	7023, 4977, 845, 1690, 3380, 6760, 4479, 1873, 3746, 7492,
-	7975, 7137, 4717, 373, 746, 1492, 2984, 5968, 2831, 5662,
-	2451, 4902, 995, 1990, 3980, 7960, 7071, 4753, 141, 282, 564,
-	1128, 2256, 4512, 1775, 3550, 7100, 4823, 0
-};
-
-static int err_loc_ply[100][100];
-
-static int
-fix_section(unsigned long offset, void *data, int *syndromes_in)
-{
-	int i, j, elp_sum;
-	int syndromes[9];
-	int Matrix_a[11];
-	int Matrix_b[11];
-	int Matrix_c[12];
-	int Element[7];
-	int alpha;
-	int temp_index;
-	int data_location, rev_location;
-	int result_byte, result_bit;
-	int err_location[20];
-	int err_count;
-	int d_flg;
-	int block_length, data_length;
-
-	/* correct 4 bits in 512 bytes */
-	data_length = 4096;
-	block_length = 8191;
-
-	/*
-	  If there are no errors, just return.
-	*/
-
-	j = 0;
-
-	for (i = 0; i < 8; ++i) {
-		if (0 != syndromes_in[i]) {
-			j = 1;
-			break;
-		}
-	}
-
-	if (0 == j)
-		return 0;
-
-	/*
-	  Decode.
-	*/
-
-	memcpy((void *)syndromes, (void *)syndromes_in, sizeof(int) * 9);
-	d_flg = 0;
-
-	/* initialise table entries */
-	for (i = 0; i < 8; i++)
-		syndromes[i] = i_to_a[syndromes[i]];
-
-	Matrix_c[0] = 0;
-	Matrix_c[1] = syndromes[0];
-	err_loc_ply[0][0] = 1;
-	err_loc_ply[1][0] = 1;
-	for (i = 1; i < 8; i++) {
-		err_loc_ply[0][i] = 0;
-		err_loc_ply[1][i] = 0;
-	}
-	Matrix_a[0] = 0;
-	Matrix_a[1] = 0;
-	Matrix_b[0] = -1;
-	Matrix_b[1] = 0;
-	alpha = -1;
-
-	do {
-		/* skip even loops */
-		alpha += 2;
-		if (Matrix_c[alpha] != -1) {
-			temp_index = alpha - 2;
-			if (temp_index < 0)
-				temp_index = 0;
-			while ((Matrix_c[temp_index] == -1) && (temp_index > 0))
-				temp_index = temp_index - 2;
-			if (temp_index < 0)
-				temp_index = 0;
-
-			if (temp_index > 0) {
-				j = temp_index;
-				do {
-					j = j - 2;
-					if (j < 0)
-						j = 0;
-					if ((Matrix_c[j] != -1) &&
-					   (Matrix_b[temp_index] < Matrix_b[j]))
-						temp_index = j;
-				} while (j > 0);
-			}
-
-			if (Matrix_a[alpha] > Matrix_a[temp_index] +
-				alpha - temp_index)
-				Matrix_a[alpha + 2] = Matrix_a[alpha];
-			else
-				Matrix_a[alpha + 2] = Matrix_a[temp_index] +
-					 alpha - temp_index;
-
-			for (i = 0; i < 8; ++i)
-				err_loc_ply[alpha + 2][i] = 0;
-
-			for (i = 0; i <= Matrix_a[temp_index]; i++) {
-				if (err_loc_ply[temp_index][i] != 0)
-					err_loc_ply[alpha + 2][i +
-						alpha - temp_index] =
-					a_to_i[(Matrix_c[alpha] +
-						block_length -
-						Matrix_c[temp_index] +
-						i_to_a[err_loc_ply[temp_index]
-						[i]]) % block_length];
-			}
-
-			for (i = 0; i <= Matrix_a[alpha]; i++)
-				err_loc_ply[alpha + 2][i] ^=
-					err_loc_ply[alpha][i];
-		} else {
-			Matrix_a[alpha + 2] = Matrix_a[alpha];
-
-			for (i = 0; i <= Matrix_a[alpha]; i++)
-				err_loc_ply[alpha + 2][i] =
-					err_loc_ply[alpha][i];
-		}
-
-		Matrix_b[alpha + 2] = alpha+1 - Matrix_a[alpha + 2];
-
-		/* Form (alpha+2)th discrepancy. */
-		if (alpha < 8) {
-			if (syndromes[alpha + 1] != -1)
-				Matrix_c[alpha + 2] =
-					a_to_i[syndromes[alpha + 1]];
-			else
-				Matrix_c[alpha + 2] = 0;
-
-			for (i = 1; i <= Matrix_a[alpha + 2]; i++) {
-				if ((syndromes[alpha + 1 - i] != -1) &&
-					(err_loc_ply[alpha + 2][i] != 0))
-					Matrix_c[alpha + 2] ^=
-						a_to_i[(syndromes[alpha + 1 - i]
-						+ i_to_a[err_loc_ply[alpha + 2]
-						[i]]) % block_length];
-			}
-			Matrix_c[alpha + 2] = i_to_a[Matrix_c[alpha + 2]];
-		}
-	} while ((alpha < 7) && (Matrix_a[alpha + 2] <= 4));
-
-	alpha = alpha+2;
-	Matrix_a[7] = Matrix_a[alpha];
-	if (Matrix_a[7] <= 4) {
-		for (i = 1; i <= Matrix_a[7]; i++)
-			Element[i] = i_to_a[err_loc_ply[alpha][i]];
-
-		err_count = 0;
-		for (i = 1; i <= block_length; i++) {
-			elp_sum = 1;
-			for (j = 1; j <= Matrix_a[7]; j++)
-				if (Element[j] != -1) {
-					Element[j] = (Element[j] + j) %
-						block_length;
-					elp_sum ^= a_to_i[Element[j]];
-				}
-
-			if (!elp_sum) {
-				err_location[err_count] = block_length - i;
-				err_count++;
-			}
-		}
-
-		if (err_count == Matrix_a[7])
-			d_flg = 1;
-	}
-
-	if (d_flg == 0)
-		return -1;
-	else {
-		for (i = 0; i < err_count; i++) {
-			if (err_location[i] >= 52)
-				data_location = err_location[i] - 52;
-			else
-				data_location = err_location[i] + data_length;
-
-			if (data_location <= 4095) {
-				rev_location = 4095 - data_location;
-				result_bit = rev_location % 8;
-				result_byte = (rev_location - result_bit) / 8;
-
-				pr_notice("Corrected ECC Error: offset 0x%lx byte 0x%x bit %d\n",
-					  offset, result_byte, result_bit);
-
-				result_byte =
-					(result_byte & 0xfffffffc) |
-					((result_byte & 0x3) ^ 0x3);
-				*((unsigned char *)(data +
-						    result_byte)) ^=
-					(1 << result_bit);
-			} else {
-				rev_location = 4147 - data_location;
-				result_bit = rev_location % 8;
-				result_byte = (rev_location - result_bit) / 8;
-				pr_err("BCH byte = %d, bit = %d\n",
-				       result_byte, result_bit);
-			}
-		}
-
-		if (0 != err_count)
-			return 1;
-		else
-			return 0;
-	}
-}
-
-/*
-  ------------------------------------------------------------------------------
-  report_ecc_errors_ep501g1
-*/
-
-static int
-report_ecc_errors_ep501g1(struct mtd_info *mtd, struct nand_chip *chip,
-			  uint8_t *buffer, int page)
-{
-	unsigned long ecc_status;
-	int i;
-
-	for (i = 0; i < (mtd->writesize / 1024); ++i) {
-		ecc_status = readl(chip->IO_ADDR_R +
-				   EP501G1_NAND_1BIT_ECC0_STATUS + (i * 4));
-
-		switch (ecc_status & (3 << 12)) {
-		case 01:
-			pr_err("Correctable ECC Error: %d:0x%lx\n",
-			       i, ecc_status);
-			break;
-		case 02:
-			pr_err("Uncorrectable ECC Error: %d:0x%lx\n",
-			       i, ecc_status);
-			break;
-		}
-	}
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  report_ecc_errors_ep501g3
-*/
-
-static int
-report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
-			  uint8_t *buffer, int page)
-{
-	unsigned long bch_status;
-	int rc = 0;
-	unsigned long value;
-	int i;
-	int is_blank = 1;
-	uint8_t *data = buffer;
-	int section;
-	int syndrome;
-	unsigned long syndromes[8][8];
-
-	/* Verify 4-bit mode in the EP501G3 case. */
-	value = (READL(chip->IO_ADDR_R + EP501_NAND_CONFIG_REG) & 0x1800) >> 11;
-
-	if (1 != value) {
-		pr_err("Only 4-Bit ECC is supported.\n");
-		rc = -1;
-		goto report_ecc_errors_ep501g3_end;
-	}
-
-	/* If there are no errors, return. */
-	bch_status = READL(chip->IO_ADDR_R + EP501G1_NAND_BCH_STATUS);
-
-	if (0 == bch_status)
-		goto report_ecc_errors_ep501g3_end;
-
-	switch (mtd->writesize) {
-	case 512:
-		bch_status &= 0x1;
-		break;
-	case 2048:
-		bch_status &= 0xf;
-		break;
-	case 4096:
-		bch_status &= 0xff;
-		break;
-	default:
-		pr_err("Unexpected Page Size!\n");
-		rc = -1;
-		goto report_ecc_errors_ep501g3_end;
-	}
-
-	/* Ignore fully erased blocks. */
-	if (NULL != data) {
-		for (i = 0; i < mtd->writesize; ++i) {
-			if (0xff != *data++) {
-				is_blank = 0;
-				break;
-			}
-		}
-	}
-
-	if (0 != is_blank)
-		goto report_ecc_errors_ep501g3_end;
-
-	/* Read the syndrome registers and split them into syndromes. */
-	for (section = 0; section < 8; ++section) {
-		unsigned long address;
-		unsigned long value;
-
-		address = EP501G1_NAND_SYN_R12_S0 + (section * 0x10);
-
-		for (syndrome = 0; syndrome < ((mtd->writesize / 512) * 2);
-		     syndrome += 2, address += 4) {
-			value = READL(chip->IO_ADDR_R + address);
-			syndromes[section][syndrome] =
-				(value & 0x1fff);
-			syndromes[section][syndrome + 1] =
-				((value & 0x1fff0000) >> 16);
-		}
-	}
-
-#ifdef NOT_USED
-	/* Debug output (BCH status register and syndromes). */
-	pr_info("BCH Status Register: 0x%02lx\n", bch_status);
-
-	for (section = 0; section < 8; ++section) {
-		pr_info("Syndromes, Section %d: ", section);
-
-		for (syndrome = 0; syndrome < 8; ++syndrome)
-			pr_info("0x%04lx ",
-
-		pr_info("\n");
-	}
-#endif
-
-	for (i = 0; i < 4; ++i) {
-		if ((1 << i) == (bch_status & (1 << i))) {
-			rc = fix_section(((page * mtd->writesize) + (512 * i)),
-					 (void *)(buffer + (512 * i)),
-					 (int *)&syndromes[i]);
-
-			if (-1 == rc)
-				pr_err("Uncorrectable ECC Error: Page %d\n",
-				       page);
-		}
-	}
-
- report_ecc_errors_ep501g3_end:
-
-	return rc;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  report_ecc_errors
-*/
-
-static int
-report_ecc_errors(struct mtd_info *mtd, struct nand_chip *chip,
-		  uint8_t *buffer, int page)
-{
-	int rc = 0;
-
-	switch (lsi_nand_type) {
-	case LSI_NAND_EP501:
-		rc = report_ecc_errors_ep501(mtd, chip, buffer, page);
-		break;
-	case LSI_NAND_EP501G1:
-		rc = report_ecc_errors_ep501g1(mtd, chip, buffer, page);
-		break;
-	case LSI_NAND_EP501G3:
-		rc = report_ecc_errors_ep501g3(mtd, chip, buffer, page);
-		break;
-	default:
-		rc = -1;
-		break;
-	}
-
-	return rc;
-}
-
-
-/**
- * nand_read_page_hwecc - hardware ecc based page read function
- * @mtd:	mtd info structure
- * @chip:	nand chip info structure
- * @buf:	buffer to store read data
- *
- * Not for syndrome calculating ecc controllers which need a special oob layout
- */
-
-static int
-lsi_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
-			 uint8_t *buf, int oob_required, int page)
-{
-	int rc;
-	/*int page = 0;*/
-
-	/* Read the current page number and save it. */
-	/*page = READL(chip->IO_ADDR_R + NAND_INDEX_REG) >> 12;*/
-
-	/* read the page */
-	chip->read_buf(mtd, buf, mtd->writesize);
-
-	/* read oob data */
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-
-	/* start ECC calculations */
-	chip->ecc.calculate(mtd, NULL, NULL);
-
-	/* Read the ECC Status and see if there were any errors */
-	rc = report_ecc_errors(mtd, chip, buf, page);
-
-	/* cmd to controller to turn off CE */
-	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
-	return rc;
-}
-
-/**
- * lsi_nand_write_page_hwecc - hardware ecc based page write function
- * @mtd:	mtd info structure
- * @chip:	nand chip info structure
- * @buf:	data buffer
- */
-static int
-lsi_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
-			   const uint8_t *buf, int oob_required)
-{
-	/* write the page data */
-	chip->write_buf(mtd, buf, mtd->writesize);
-
-	/*
-	 * Write the oob data. Last 12 bytes are used by HW ECC.
-	 * Do not touch them.
-	 */
-	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize - chip->ecc.bytes);
-	return 0;
-}
-
-/**
- * lsi_nand_write_page - [REPLACEABLE] write one page
- * @mtd:	MTD device structure
- * @chip:	NAND chip descriptor
- * @buf:	the data to write
- * @page:	page number to write
- * @cached:	cached programming
- * @raw:	use _raw version of write_page
- */
-
-static int
-lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
-		    uint32_t offset, int data_len, const uint8_t *buf,
-		    int oob_required, int page, int cached, int raw)
-{
-	int status;
-
-	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
-
-	if (unlikely(raw))
-		chip->ecc.write_page_raw(mtd, chip, buf, 0);
-	else
-		chip->ecc.write_page(mtd, chip, buf, 0);
-
-	/* calculate ECC */
-	status = chip->ecc.calculate(mtd, NULL, NULL);
-
-	/* cmd to controller to turn off CE */
-	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
-
-	/*
-	 * See if operation failed and additional status checks are
-	 * available
-	 */
-	if (status & NAND_STATUS_FAIL) {
-		pr_err("ERROR: Page write failed for page 0x%x\n",
-		       page);
-
-		if (chip->errstat)
-			status = chip->errstat(mtd, chip, FL_WRITING, status,
-					       page);
-
-		return -EIO;
-	}
-
-	return 0;
-}
-
-
-/**
- * lsi_nand_read_oob_std - [REPLACABLE] the most common OOB data read function
- * @mtd:	mtd info structure
- * @chip:	nand chip info structure
- * @page:	page number to read
- * @sndcmd:	flag whether to issue read command or not
- */
-
-static int
-lsi_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
-		  int page)
-{
-	int rc;
-
-	/* send command to read oob */
-	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-
-	/* read oob data */
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-
-	/* start ECC calculations */
-	chip->ecc.calculate(mtd, NULL, NULL);
-
-	/* Read the ECC Status and see if there were any errors */
-	rc = report_ecc_errors(mtd, chip, NULL, page);
-
-	/* cmd to controller to turn off CE */
-	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
-
-	return 0;
-}
-
-/**
- * lsi_nand_write_oob_std - [REPLACABLE] the most common OOB data write
- *			      function
- * @mtd:	mtd info structure
- * @chip:	nand chip info structure
- * @page:	page number to write
- */
-
-static int
-lsi_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
-{
-	/* start OOB write */
-	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
-
-	/*
-	 * Write the oob data. Last 12 bytes are used by HW ECC.
-	 * Do not touch them.
-	 */
-	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize - chip->ecc.bytes);
-
-	/* calculate ECC */
-	chip->ecc.calculate(mtd, NULL, NULL);
-
-	/* cmd to controller to turn off CE */
-	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
-
-	return (chip->dev_ready(mtd) & NAND_STATUS_FAIL) ? -EIO : 0;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Public
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ------------------------------------------------------------------------------
-  lsi_nand_set_config
-*/
-
-int
-lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
-{
-	unsigned long config = 0;
-	unsigned long mbits;
-
-	mbits = ((chip->chipsize >> 20) * 8);
-
-	if (LSI_NAND_EP501 == lsi_nand_type) {
-		/* The EP501 only supports 512 and 2k page sizes. */
-		if (512 != mtd->writesize &&
-		    2048 != mtd->writesize)
-			return -1;
-
-		while (64 < mbits) {
-			++config; /* 0b000=64Mbit, 0b001=128Mbit, etc. */
-			mbits >>= 1;
-		}
-
-		if (512 < mtd->writesize)
-			config |= 0x100; /* large block */
-
-		config |= 0x200;	/* not write protected */
-		chip->ecc.layout = &lsi_2k_1bit_ecclayout;
-		chip->ecc.size = mtd->writesize;
-		chip->ecc.bytes = chip->ecc.layout->eccbytes;
-		chip->ecc.strength = 1;
-	} else if (LSI_NAND_EP501G1 == lsi_nand_type) {
-		/* The EP501G1 only supports 512, 2k, and 4k page sizes, */
-		if (512 != mtd->writesize &&
-		    2048 != mtd->writesize &&
-		    4096 != mtd->writesize)
-			return -1;
-
-		/* and device sizes as follows. */
-		if (512 == mtd->writesize) {
-			switch (mbits) {
-			case 64:
-				break;
-			case 128:
-				config |= 1;
-				break;
-			case 256:
-				config |= 2;
-				break;
-			case 512:
-				config |= 3;
-				break;
-			case 1024:
-				config |= 4;
-				break;
-			case 2048:
-				config |= 5;
-				break;
-			case 4096:
-				config |= 6;
-				break;
-			case 8192:
-				config |= 7;
-				 break;
-			default:
-				return -1;
-			}
-		} else {
-			switch (mbits) {
-			case 512:
-				config |= 3;
-				break;
-			case 1024:
-				config |= 4;
-				break;
-			case 2048:
-				config |= 5;
-				break;
-			case 4096:
-				config |= 6;
-				break;
-			case 8192:
-				config |= 7;
-				break;
-			case 16384:
-				break;
-			case 32768:
-				config |= 1;
-				break;
-			case 65536:
-				config |= 2;
-				break;
-			default:
-				return -1;
-			}
-		}
-
-		switch (mtd->writesize) {
-		case 512:
-			break;
-		case 2048:
-			config |= 0x1 << 8;
-			chip->ecc.layout = &lsi_2k_4bit_ecclayout;
-			break;
-		case 4096:
-			config |= 0x2 << 8;
-			chip->ecc.layout = &lsi_4k_4bit_ecclayout;
-			break;
-		default:
-			return -1;
-		}
-
-		config |= 1 << 10; /* not write protected */
-
-		config |= 1 << 11; /* 4 bit ECC */
-
-		if (512 < mtd->writesize)
-			config |= 1 << 12; /* 3 cycle row address */
-
-		chip->ecc.size = mtd->writesize;
-
-		if (mtd->oobsize == 224)
-			chip->ecc.bytes = 224 - chip->ecc.layout->eccbytes;
-		else
-			chip->ecc.bytes = chip->ecc.layout->eccbytes;
-
-		chip->ecc.strength = 4;
-
-	} else if (LSI_NAND_EP501G3 == lsi_nand_type) {
-		/* The EP501G3 only supports 2k, 4k, and 8k page sizes, */
-		if (2048 != mtd->writesize &&
-		    4096 != mtd->writesize &&
-		    8192 != mtd->writesize)
-			return -1;
-
-		/* and device sizes as follows. */
-		switch (mbits) {
-		case 512:
-			config |= 3;
-			break;
-		case 1024:
-			config |= 4;
-			break;
-		case 2048:
-			config |= 5;
-			break;
-		case 4096:
-			config |= 6;
-			break;
-		case 8192:
-			config |= 7;
-			break;
-		case 16384:
-			break;
-		case 32768:
-			config |= 1;
-			break;
-		case 65536:
-			config |= 2;
-			break;
-		default:
-			pr_err("Invalid Device Size: 0x%lx\n", mbits);
-			return -1;
-		}
-
-		switch (mtd->writesize) {
-		case 2048:
-			config |= 0x1 << 8;
-			chip->ecc.layout = &lsi_2k_4bit_ecclayout;
-			break;
-		case 4096:
-			config |= 0x2 << 8;
-			chip->ecc.layout = &lsi_4k_4bit_ecclayout;
-			break;
-#ifdef NOT_USED
-		case 8192:
-			config |= 0x3 << 8;
-			chip->ecc.layout = &lsi_8k_4bit_ecclayout;
-			break;
-#endif
-		default:
-			return -1;
-		}
-
-		config |= 1 << 10; /* not write protected */
-		config |= 1 << 13; /* 3 cycle row address */
-
-		/*
-		  2K/4bit  - 32 bytes (8192)
-		  2K/8bit  - 64 bytes (16384)
-		  2K/12bit - 80 bytes (24576)
-		  ...
-		  8K/12bit - 320 bytes (98304)
-		*/
-
-		if (mtd->oobsize < chip->ecc.layout->eccbytes) {
-			pr_err("ECC requires %d bytes, only %d are available\n",
-			       chip->ecc.layout->eccbytes, mtd->oobsize);
-			return -1;
-		}
-
-		config |= 1 << 11; /* 4 bit ECC */
-		mtd->oobavail = mtd->oobsize - chip->ecc.layout->eccbytes;
-		mtd->oobavail -= (mtd->oobavail % 4);
-		config |= (chip->ecc.layout->eccbytes / 4) << 16;
-		chip->ecc.size = mtd->writesize;
-		chip->ecc.bytes = chip->ecc.layout->eccbytes;
-		chip->ecc.strength = 4;
-	} else {
-		return -1;
-	}
-
-	WRITEL(config, chip->IO_ADDR_W + EP501_NAND_CONFIG_REG);
-
-	return 0;
-}
-
-static uint8_t
-lsi_nand_read_byte(struct mtd_info *mtd)
-{
-	struct lsi_nand_private *priv = &lsi_nand_private;
-	struct nand_chip *chip = mtd->priv;
-
-	if (priv->cur >= 0) {
-		WARN_ON(priv->cur >= MAX_READ_BUF);
-		return priv->buf[priv->cur++];
-	} else
-		return readb(chip->IO_ADDR_R);
-}
-
-static int lsi_nand_errstat
-	(struct mtd_info *mtd, struct nand_chip *chip,
-	int state, int status, int page) {
-	/* if erase failed for a block, mark it as bad block */
-	if ((FL_ERASING == chip->state) && (status & NAND_STATUS_FAIL))
-		mtd_block_markbad(mtd, page << chip->page_shift);
-
-	return status;
-}
-
-static int
-lsi_nand_init_size(struct mtd_info *mtd, struct nand_chip *chip, u8 *id_data)
-{
-	int busw, extid;
-
-	/* The 3rd id byte holds MLC / multichip data */
-	chip->cellinfo = readb(chip->IO_ADDR_R + NAND_ID4_REG);
-	/* The 4th id byte is the important one */
-	extid = readb(chip->IO_ADDR_R + NAND_ID6_REG);
-
-	/* Add workaournd for Micron MT29Fxxxxxx NAND flash */
-	if (id_data[0] == NAND_MFR_MICRON && id_data[1] == 0x48) {
-		/* Calc pagesize */
-		mtd->writesize = 1024 << (extid & 0x03);
-		extid >>= 2;
-		/*Calc oobsize */
-		mtd->oobsize = ((extid & 0x03) == 0x03) ? 218 : 224;
-		extid >>= 3;
-		/* Calc blocksize. Blocksize is multiples of 256KiB */
-		mtd->erasesize = (256 * 1024) << (extid & 0x03);
-		busw = 0;
-	} else {
-		/* Calc pagesize */
-		mtd->writesize = 1024 << (extid & 0x03);
-		extid >>= 2;
-		/* Calc oobsize */
-		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
-		extid >>= 2;
-		/* Calc blocksize. Blocksize is multiples of 64KiB */
-		mtd->erasesize = (64 * 1024) << (extid & 0x03);
-		extid >>= 2;
-		/* Get buswidth information */
-		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
-	}
-
-	lsi_nand_set_config(mtd, chip);
-
-	return busw;
-}
-
-/*
-  ----------------------------------------------------------------------
-  lsi_nand_init
-*/
-
-#define NAND_BASE 0x002000440000ULL
-#define NAND_SIZE 0x20000
-#define GPREG_BASE 0x00200040c000ULL
-#define GPREG_SIZE 0x1000
-
-static int __init
-lsi_nand_init(void)
-{
-	void *nand_base;
-	struct device_node *np = NULL;
-	struct mtd_part_parser_data ppdata;
-	static const char *part_probe_types[]
-		= { "cmdlinepart", "ofpart", NULL };
-	const u32 *reg;
-	int reglen;
-	u64 nand_address;
-	unsigned long nand_length;
-	u64 gpreg_address;
-	unsigned long gpreg_length;
-	const u32 *enabled;
-	unsigned long cr;
-	unsigned long cr_save;
-
-	memset(&ppdata, 0, sizeof(ppdata));
-
-	np = of_find_node_by_type(np, "nand");
-
-	while (np && !of_device_is_compatible(np, "acp-nand"))
-		np = of_find_node_by_type(np, "nand");
-
-	if (NULL == np) {
-		pr_err("No NAND Nodes in Device Tree\n");
-
-		return -1;
-	}
-
-	enabled = of_get_property(np, "enabled", NULL);
-
-	if (!enabled || (enabled && (0 == *enabled))) {
-		pr_err("ACP NAND Controller Isn't Enabled.\n");
-		return -ENODEV;
-	}
-
-	reg = of_get_property(np, "reg", &reglen);
-
-	if (reg && (16 == reglen)) {
-		nand_address = of_translate_address(np, reg);
-		nand_length = reg[1];
-		reg += 2;
-		gpreg_address = of_translate_address(np, reg);
-		gpreg_length = reg[1];
-		pr_info("nand_address=0x%08llx nand_length=0x%lx\n"
-			"gpreg_address=0x%08llx gpreg_length=0x%lx\n",
-			nand_address, nand_length,
-			gpreg_address, gpreg_length);
-		nand_base = ioremap(nand_address, nand_length);
-		gpreg_base = ioremap(gpreg_address, gpreg_length);
-	} else {
-		return -1;
-	}
-
-	ppdata.of_node = np;
-
-	/*
-	  Determine the Axxia system type.
-
-	  The ECC status register and mask are different on 344x, 342x, 35xx...
-	*/
-
-	if (of_machine_is_compatible("lsi,acp3500")) {
-		pecc_busy_register = (gpreg_base + 0x8c);
-		pecc_busy_mask = (1 << 20);
-	} else {
-		if (of_machine_is_compatible("lsi,acp3420")) {
-			pecc_busy_register = (gpreg_base + 0xc);
-			pecc_busy_mask = (1 << 28);
-		} else {
-			if (of_machine_is_compatible("lsi,acp3440")) {
-				pecc_busy_register = (gpreg_base + 0xc);
-				pecc_busy_mask = (1 << 28);
-			} else {
-				pr_err("Unsupported NAND Target\n");
-
-				return -1;
-			}
-		}
-	}
-
-	/*
-	  Determine the version of the controller.
-
-	  As there is not version register, see if bits 5:3 of the
-	  configuration register are writable.  There are in the EP501
-	  case and aren't in the EP501G1 case.
-	*/
-
-	cr = cr_save = READL((void *)(nand_base + NAND_CONFIG_REG));
-	cr = 0x2038;
-	WRITEL(cr, (void *)(nand_base + EP501_NAND_CONFIG_REG));
-	cr = READL((void *)nand_base + EP501_NAND_CONFIG_REG);
-	WRITEL(cr_save, (void *)(nand_base + EP501_NAND_CONFIG_REG));
-
-	if (0 == (cr & 0x2038))
-		lsi_nand_type = LSI_NAND_EP501G1;
-	else if (0x38 == (cr & 0x2038))
-		lsi_nand_type = LSI_NAND_EP501;
-	else if (0x2000 == (cr & 0x2038))
-		lsi_nand_type = LSI_NAND_EP501G3;
-	else
-		lsi_nand_type = LSI_NAND_NONE;
-
-	switch (lsi_nand_type) {
-	case LSI_NAND_EP501:
-		pr_info("EP501 NAND Controller.\n");
-		nand_cmd_ce_off = NAND_CMD_CE_OFF_501;
-		break;
-	case LSI_NAND_EP501G1:
-		pr_info("EP501G1 NAND Controller.\n");
-		nand_cmd_ce_off = NAND_CMD_CE_OFF_501G1;
-		break;
-	case LSI_NAND_EP501G3:
-		pr_info("EP501G3 NAND Controller.\n");
-		nand_cmd_ce_off = NAND_CMD_CE_OFF_501G3;
-		break;
-	default:
-		pr_info("Unknown NAND Controller!\n");
-		return -1;
-	}
-
-	/* Initialize structures */
-	memset(&lsi_nand_mtd, 0, sizeof(struct mtd_info));
-	memset(&lsi_nand_chip, 0, sizeof(struct nand_chip));
-
-	/* Link the private data with the MTD structure */
-	lsi_nand_mtd.priv = &lsi_nand_chip;
-	lsi_nand_mtd.owner = THIS_MODULE;
-	lsi_nand_mtd.name = "acp-nand";
-
-	/* init chip callbacks */
-	lsi_nand_chip.IO_ADDR_R = (void *) nand_base;
-	lsi_nand_chip.IO_ADDR_W = (void *) nand_base;
-	lsi_nand_chip.write_buf = lsi_nand_write_buf;
-	lsi_nand_chip.read_buf = lsi_nand_read_buf;
-	lsi_nand_chip.write_page = lsi_nand_write_page;
-	lsi_nand_chip.cmd_ctrl = lsi_nand_hwcontrol;
-	lsi_nand_chip.dev_ready = lsi_nand_device_ready;
-	lsi_nand_chip.cmdfunc = lsi_nand_command;
-	lsi_nand_chip.waitfunc = lsi_nand_wait;
-	lsi_nand_chip.chip_delay = 10;
-	lsi_nand_chip.bbt_options = NAND_BBT_USE_FLASH;
-	lsi_nand_chip.read_byte = lsi_nand_read_byte;
-	lsi_nand_chip.errstat = lsi_nand_errstat;
-	lsi_nand_chip.init_size = lsi_nand_init_size;
-
-	/* initialize ECC */
-	lsi_nand_chip.ecc.mode = NAND_ECC_HW;
-	lsi_nand_chip.ecc.steps = 1;
-	lsi_nand_chip.ecc.total = 12;
-	lsi_nand_chip.ecc.hwctl = lsi_nand_ecc_hwctl;
-	lsi_nand_chip.ecc.calculate = lsi_nand_ecc_calculate;
-	lsi_nand_chip.ecc.correct = lsi_nand_ecc_correct;
-	lsi_nand_chip.ecc.read_page = lsi_nand_read_page_hwecc;
-	lsi_nand_chip.ecc.write_page = lsi_nand_write_page_hwecc;
-	lsi_nand_chip.ecc.read_page_raw = lsi_nand_read_page_hwecc;
-	lsi_nand_chip.ecc.write_page_raw = lsi_nand_write_page_hwecc;
-	lsi_nand_chip.ecc.read_oob = lsi_nand_read_oob;
-	lsi_nand_chip.ecc.write_oob = lsi_nand_write_oob;
-
-	pr_err("Enabling NAND ECC...\n");
-	/* clear any existing ECC status */
-	WRITEL(0x0, lsi_nand_chip.IO_ADDR_W + NAND_INTR_STATUS_REG);
-	/* enable ECC */
-	WRITEL(0x0, lsi_nand_chip.IO_ADDR_W + NAND_INTR_EN_REG);
-
-	/*
-	  ======================================================================
-	  Timing Control
-
-	  This may need to be changed, based on the devices used.  Each field is
-	  described below.
-	*/
-
-	/*
-	  TCR0 - NAND Timing Control Register 0
-	*/
-
-	{
-		nand_timing_control_register_0_t tcr0;
-
-		/* TH [31:24] - CLE, CE & ALE hold Time */
-		tcr0.bits.th = 0x08;
-
-		/* TRP [23:16] - Read Pulse Width */
-		tcr0.bits.trp = 0x0c;
-
-		/* TWP [15:8] - Write Pulse Width */
-		tcr0.bits.twp = 0x0c;
-
-		/* TS [7:0] - Setup Time for CLE, CE & ALE */
-		tcr0.bits.ts = 0x05;
-
-		WRITEL(tcr0.raw,
-		       (lsi_nand_chip.IO_ADDR_W + NAND_TIMING1_REG));
-	}
-
-	/*
-	  TCR1 - NAND Timing Control Register 1
-	*/
-
-	{
-		nand_timing_control_register_1_t tcr1;
-
-		/* TWB [31:24] - WE Rising Edge to RY/BY Falling Edge */
-		tcr1.bits.twb = 0x1e;
-
-		/* TRR [23:16] - RY/BY Rising Edge To Read Falling Edge */
-		tcr1.bits.trr = 0x07;
-
-		/* TRH [15:8] - Read Pulse High Time */
-		tcr1.bits.trh = 0x03;
-
-		/* TWH [7:0] - Write Pulse High Time */
-		tcr1.bits.twh = 0x03;
-
-		WRITEL(tcr1.raw,
-		       (lsi_nand_chip.IO_ADDR_W + NAND_TIMING2_REG));
-	}
-
-	/*
-	  TCR2 - NAND Timing Control Register 2 (EP501G3 Only)
-	*/
-
-	{
-		nand_timing_control_register_2_t tcr2;
-
-		tcr2.bits.tccs = 0x10;
-		tcr2.bits.twhr = 0x10;
-		tcr2.bits.trhw = 0x14;
-		WRITEL(tcr2.raw,
-		       (lsi_nand_chip.IO_ADDR_W + EP501G3_NAND_TIMING2_REG));
-	}
-
-	pr_err("Searching for NAND flash...\n");
-	/* Scan to find existence of the device */
-	if (nand_scan(&lsi_nand_mtd, 1)) {
-		pr_err("nand_scan failure...\n");
-		return -ENXIO;
-	}
-
-	/* Register the partitions */
-
-	mtd_device_parse_register(&lsi_nand_mtd, part_probe_types, &ppdata,
-				  NULL, 0);
-
-	/* Return happy */
-	return 0;
-}
-
-module_init(lsi_nand_init);
-
-/*
-  ----------------------------------------------------------------------
-  lsi_nand_exit
-*/
-
-static void __exit
-lsi_nand_exit(void)
-{
-	/* Release resources, unregister device */
-	nand_release(&lsi_nand_mtd);
-}
-
-module_exit(lsi_nand_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Jay Jayatheerthan <jay.jayatheerthan@lsi.com>");
-MODULE_DESCRIPTION("MTD map driver for LSI's ACP board");
diff --git a/drivers/mtd/nand/lsi_ubootenv.c b/drivers/mtd/nand/lsi_ubootenv.c
deleted file mode 100644
index 4b52e99..0000000
--- a/drivers/mtd/nand/lsi_ubootenv.c
+++ /dev/null
@@ -1,569 +0,0 @@
-/*
- * drivers/lsi/acp/ubootenv.c
- *
- * Copyright (C) 2009 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-#include <linux/mtd/mtd.h>
-#include <linux/crc32.h>
-#include <linux/io.h>
-
-/*
-  ======================================================================
-  Data types and Macros
-  ======================================================================
-*/
-#include <asm/lsi/debug.h>
-
-/*
-  ======================================================================
-  Global Variables
-  ======================================================================
-*/
-
-static struct kobject *ubootenv_kobj;
-
-
-static unsigned long uboot_env_size = (128 * 1024);
-static unsigned long uboot_env_cs_size = (128 * 1024);
-static int uboot_env_current = -1;
-
-#define ENVIRONMENT_DATA_SIZE(size) (size - (2 * sizeof(unsigned long)))
-
-typedef struct environment {
-
-	unsigned long crc32;
-	unsigned long flags;
-	unsigned char data[];
-
-} __packed environment_t;
-
-static environment_t *environment = (environment_t *) 0;
-
-static unsigned long crc32_lut[256] = {
-
-	/*   0 -- */           0u, 1996959894u, 3993919788u, 2567524794u,
-	/*   4 -- */   124634137u, 1886057615u, 3915621685u, 2657392035u,
-	/*   8 -- */   249268274u, 2044508324u, 3772115230u, 2547177864u,
-	/*  12 -- */   162941995u, 2125561021u, 3887607047u, 2428444049u,
-	/*  16 -- */   498536548u, 1789927666u, 4089016648u, 2227061214u,
-	/*  20 -- */   450548861u, 1843258603u, 4107580753u, 2211677639u,
-	/*  24 -- */   325883990u, 1684777152u, 4251122042u, 2321926636u,
-	/*  28 -- */   335633487u, 1661365465u, 4195302755u, 2366115317u,
-	/*  32 -- */   997073096u, 1281953886u, 3579855332u, 2724688242u,
-	/*  36 -- */  1006888145u, 1258607687u, 3524101629u, 2768942443u,
-	/*  40 -- */   901097722u, 1119000684u, 3686517206u, 2898065728u,
-	/*  44 -- */   853044451u, 1172266101u, 3705015759u, 2882616665u,
-	/*  48 -- */   651767980u, 1373503546u, 3369554304u, 3218104598u,
-	/*  52 -- */   565507253u, 1454621731u, 3485111705u, 3099436303u,
-	/*  56 -- */   671266974u, 1594198024u, 3322730930u, 2970347812u,
-	/*  60 -- */   795835527u, 1483230225u, 3244367275u, 3060149565u,
-	/*  64 -- */  1994146192u,   31158534u, 2563907772u, 4023717930u,
-	/*  68 -- */  1907459465u,  112637215u, 2680153253u, 3904427059u,
-	/*  72 -- */  2013776290u,  251722036u, 2517215374u, 3775830040u,
-	/*  76 -- */  2137656763u,  141376813u, 2439277719u, 3865271297u,
-	/*  80 -- */  1802195444u,  476864866u, 2238001368u, 4066508878u,
-	/*  84 -- */  1812370925u,  453092731u, 2181625025u, 4111451223u,
-	/*  88 -- */  1706088902u,  314042704u, 2344532202u, 4240017532u,
-	/*  92 -- */  1658658271u,  366619977u, 2362670323u, 4224994405u,
-	/*  96 -- */  1303535960u,  984961486u, 2747007092u, 3569037538u,
-	/* 100 -- */  1256170817u, 1037604311u, 2765210733u, 3554079995u,
-	/* 104 -- */  1131014506u,  879679996u, 2909243462u, 3663771856u,
-	/* 108 -- */  1141124467u,  855842277u, 2852801631u, 3708648649u,
-	/* 112 -- */  1342533948u,  654459306u, 3188396048u, 3373015174u,
-	/* 116 -- */  1466479909u,  544179635u, 3110523913u, 3462522015u,
-	/* 120 -- */  1591671054u,  702138776u, 2966460450u, 3352799412u,
-	/* 124 -- */  1504918807u,  783551873u, 3082640443u, 3233442989u,
-	/* 128 -- */  3988292384u, 2596254646u,   62317068u, 1957810842u,
-	/* 132 -- */  3939845945u, 2647816111u,   81470997u, 1943803523u,
-	/* 136 -- */  3814918930u, 2489596804u,  225274430u, 2053790376u,
-	/* 140 -- */  3826175755u, 2466906013u,  167816743u, 2097651377u,
-	/* 144 -- */  4027552580u, 2265490386u,  503444072u, 1762050814u,
-	/* 148 -- */  4150417245u, 2154129355u,  426522225u, 1852507879u,
-	/* 152 -- */  4275313526u, 2312317920u,  282753626u, 1742555852u,
-	/* 156 -- */  4189708143u, 2394877945u,  397917763u, 1622183637u,
-	/* 160 -- */  3604390888u, 2714866558u,  953729732u, 1340076626u,
-	/* 164 -- */  3518719985u, 2797360999u, 1068828381u, 1219638859u,
-	/* 168 -- */  3624741850u, 2936675148u,  906185462u, 1090812512u,
-	/* 172 -- */  3747672003u, 2825379669u,  829329135u, 1181335161u,
-	/* 176 -- */  3412177804u, 3160834842u,  628085408u, 1382605366u,
-	/* 180 -- */  3423369109u, 3138078467u,  570562233u, 1426400815u,
-	/* 184 -- */  3317316542u, 2998733608u,  733239954u, 1555261956u,
-	/* 188 -- */  3268935591u, 3050360625u,  752459403u, 1541320221u,
-	/* 192 -- */  2607071920u, 3965973030u, 1969922972u,   40735498u,
-	/* 196 -- */  2617837225u, 3943577151u, 1913087877u,   83908371u,
-	/* 200 -- */  2512341634u, 3803740692u, 2075208622u,  213261112u,
-	/* 204 -- */  2463272603u, 3855990285u, 2094854071u,  198958881u,
-	/* 208 -- */  2262029012u, 4057260610u, 1759359992u,  534414190u,
-	/* 212 -- */  2176718541u, 4139329115u, 1873836001u,  414664567u,
-	/* 216 -- */  2282248934u, 4279200368u, 1711684554u,  285281116u,
-	/* 220 -- */  2405801727u, 4167216745u, 1634467795u,  376229701u,
-	/* 224 -- */  2685067896u, 3608007406u, 1308918612u,  956543938u,
-	/* 228 -- */  2808555105u, 3495958263u, 1231636301u, 1047427035u,
-	/* 232 -- */  2932959818u, 3654703836u, 1088359270u,  936918000u,
-	/* 236 -- */  2847714899u, 3736837829u, 1202900863u,  817233897u,
-	/* 240 -- */  3183342108u, 3401237130u, 1404277552u,  615818150u,
-	/* 244 -- */  3134207493u, 3453421203u, 1423857449u,  601450431u,
-	/* 248 -- */  3009837614u, 3294710456u, 1567103746u,  711928724u,
-	/* 252 -- */  3020668471u, 3272380065u, 1510334235u,  755167117u
-
-};
-
-/*
-  ======================================================================
-  Prototypes
-  ======================================================================
-*/
-
-static unsigned long ubootenv_crc32(unsigned char *, unsigned long);
-static int ubootenv_initialize(void);
-static void ubootenv_finalize(void);
-static int ubootenv_read(struct mtd_info *, size_t, void *);
-static void create_env_sysfs(void);
-/*
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_crc32
-*/
-
-static unsigned long
-ubootenv_crc32(unsigned char *start, unsigned long size)
-{
-	unsigned long crc = (unsigned long)0xffffffff, index;
-
-	DEBUG_PRINT("start=0x%lx size=0x%lx\n", (unsigned long)start, size);
-
-	for (index = 0; index < size; index++) {
-		unsigned long temp = (crc ^ *(start++)) & 0x000000ff;
-
-		crc = ((crc >> 8) & 0x00ffffff) ^ crc32_lut[temp];
-	}
-	return ~crc;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_read
-*/
-
-static int
-ubootenv_read(struct mtd_info *mtd, size_t size, void *buffer)
-{
-	int read = 0;
-	loff_t offset = 0;
-
-	DEBUG_PRINT("size=0x%x mtd->erasesize=0x%x mtd->size=0x%llx\n",
-		    size, mtd->erasesize, mtd->size);
-
-	if (0 != size % mtd->erasesize) {
-		ERROR_PRINT("size=%u/%llu is not a multiple of erasesize=%u\n",
-			    size, mtd->size, mtd->erasesize);
-		return -1;
-	}
-
-	if (size > mtd->size) {
-		ERROR_PRINT("size=%llu can't contain size=%u\n",
-			    mtd->size, size);
-		return -1;
-	}
-
-	while ((read < size) && (offset < mtd->size)) {
-		int return_code;
-		size_t bytes_read;
-
-		DEBUG_PRINT("read=0x%x size=0x%x offset=0x%llx\n",
-			    read, size, offset);
-
-		if (0 != mtd_block_isbad(mtd, offset)) {
-			offset += mtd->erasesize;
-			continue;
-		}
-
-		return_code = mtd_read(mtd, offset, mtd->erasesize,
-				       &bytes_read, (u_char *) buffer);
-
-		if (mtd->erasesize != bytes_read) {
-			ERROR_PRINT("Error Reading Environment!\n");
-			return -1;
-		}
-
-		offset += mtd->erasesize;
-		read += mtd->erasesize;
-		buffer += mtd->erasesize;
-	}
-
-	return 0;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_initialize
-*/
-
-static int
-ubootenv_initialize(void)
-{
-	environment_t *env0;
-	environment_t *env1;
-	unsigned long crc32_env0;
-	unsigned long crc32_env1;
-	struct mtd_info *mtd_env0;
-	struct mtd_info *mtd_env1;
-
-	DEBUG_PRINT("Getting MTD Devices.\n");
-
-	mtd_env0 = get_mtd_device_nm("env-0");
-	if ((struct mtd_info *)-ENODEV == mtd_env0) {
-		ERROR_PRINT(" --> Couldn't get MTD device by name!\n");
-		return -1;
-	}
-
-	mtd_env1 = get_mtd_device_nm("env-1");
-	if ((struct mtd_info *)-ENODEV == mtd_env1) {
-		ERROR_PRINT(" --> Couldn't get MTD device by name!\n");
-		return -1;
-	}
-
-	/*
-	 * If the erasesize is larger than the size of the environment,
-	 * change the environment size (so reading and writing will
-	 * work as expected) but use the original environment size to
-	 * calculate the checksum.
-	 */
-
-	if (mtd_env0->erasesize > uboot_env_size)
-		uboot_env_size = mtd_env0->erasesize;
-
-	DEBUG_PRINT("Allocating Environment Buffers.\n");
-
-	env0 = vmalloc(uboot_env_size);
-	if ((environment_t *)0 == env0) {
-		ERROR_PRINT("Unable to allocate %lu bytes\n", uboot_env_size);
-		return -1;
-	}
-
-	env1 = vmalloc(uboot_env_size);
-	if ((environment_t *) 0 == env1) {
-		ERROR_PRINT("Unable to allocate %lu bytes\n", uboot_env_size);
-		vfree((void *) env0);
-		return -1;
-	}
-
-	DEBUG_PRINT("Reading Environments.\n");
-
-	if (0 != ubootenv_read(mtd_env0, uboot_env_size, env0))
-		return -1;
-
-	if (0 != ubootenv_read(mtd_env1, uboot_env_size, env1))
-		return -1;
-
-	DEBUG_PRINT("Calculating CRC values.\n");
-	crc32_env0 = ubootenv_crc32((unsigned char *)env0->data,
-				    ENVIRONMENT_DATA_SIZE(uboot_env_cs_size));
-	crc32_env1 = ubootenv_crc32((unsigned char *)env1->data,
-				    ENVIRONMENT_DATA_SIZE(uboot_env_cs_size));
-	DEBUG_PRINT("crc32_env0=0x%lx env0->crc32=0x%lx\n",
-		    crc32_env0, env0->crc32);
-	DEBUG_PRINT("crc32_env2=0x%lx env1->crc32=0x%lx\n",
-		     crc32_env1, env1->crc32);
-	DEBUG_PRINT("Picking a Copy.\n");
-
-	if ((crc32_env0 == env0->crc32) &&
-	    (crc32_env1 != env1->crc32)) {
-		/* Use env0 */
-		DEBUG_PRINT("Using Copy 0.\n");
-		uboot_env_current = 0;
-		vfree((void *) env1);
-		environment = env0;
-	} else if ((crc32_env0 != env0->crc32) &&
-		   (crc32_env1 == env1->crc32)) {
-		/* Use env1 */
-		DEBUG_PRINT("Using Copy 1.\n");
-		uboot_env_current = 1;
-		vfree((void *) env0);
-		environment = env1;
-	} else if ((crc32_env0 != env0->crc32) &&
-		   (crc32_env1 != env1->crc32)) {
-		/* No Environment Available */
-		uboot_env_current = -1;
-		vfree((void *) env0);
-		vfree((void *) env1);
-		ERROR_PRINT("Bad CRCs: No Valid U-Boot Environment Found!\n");
-		return -1;
-	} else if (env0->flags > env1->flags) {
-		/* Use env0 */
-		DEBUG_PRINT("Using Copy 0.\n");
-		uboot_env_current = 0;
-		vfree((void *) env1);
-		environment = env0;
-	} else if (env0->flags < env1->flags) {
-		/* Use env1 */
-		DEBUG_PRINT("Using Copy 1.\n");
-		uboot_env_current = 1;
-		vfree((void *) env0);
-		environment = env1;
-	} else if (env0->flags == env1->flags) {
-		/* Use Either */
-		DEBUG_PRINT("Using Copy 0.\n");
-		uboot_env_current = 0;
-		vfree((void *) env1);
-		environment = env0;
-	} else {
-		/* No Environment Available */
-		uboot_env_current = -1;
-		vfree((void *) env0);
-		vfree((void *) env1);
-		ERROR_PRINT("Bad Flags: No Valid U-Boot Environment Found!\n");
-		return -1;
-	}
-
-	DEBUG_PRINT("Done...\n");
-	create_env_sysfs();
-
-	return 0;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_finalize
-*/
-
-static void
-ubootenv_finalize(void)
-{
-	DEBUG_PRINT("Freeing the environment.\n");
-
-	if ((void *)0 != environment)
-		vfree((void *)environment);
-
-	environment = (environment_t *)0;
-}
-
-/*
-  ======================================================================
-  Public Interface
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_get
-*/
-
-int
-ubootenv_get(const char *key, char *value)
-{
-	int return_code = -1;
-	char *string;
-
-	if (NULL == environment) {
-		ERROR_PRINT("Environment Isn't Available!\n");
-		return -1;
-	}
-
-	string = environment->data;
-
-	while (0x00 != string[0]) {
-		if (0 == strncmp(key, string, strlen(key))) {
-			char *value_ = strchr(string, '=');
-			++value_;
-			strcpy(value, value_);
-			return_code = 0;
-			break;
-		}
-
-		string += (strlen(string) + 1);
-	}
-
-	return return_code;
-}
-EXPORT_SYMBOL(ubootenv_get);
-
-/*
-  ======================================================================
-  ======================================================================
-  Sysfs Stuff
-  ======================================================================
-  ======================================================================
-*/
-
-struct bin_attribute uboot_env[100];
-
-static ssize_t read_env(struct file *filep, struct kobject *kobj,
-			struct bin_attribute *bin_attr,
-			char *buf, loff_t off, size_t size)
-{
-	int retsize = -1;
-	char *string;
-
-	if (size <= 1)
-		return 0;
-
-	if (NULL == environment) {
-		ERROR_PRINT("Environment Isn't Available!\n");
-		return -1;
-	}
-
-	string = environment->data;
-
-	while (0x00 != string[0]) {
-		if (0 == strncmp(bin_attr->attr.name,
-				 string, strlen(bin_attr->attr.name))) {
-			char *value_ = strchr(string, '=');
-			++value_;
-
-			retsize = 1 + strlcpy(buf, value_, size);
-			break;
-		}
-
-		string += (strlen(string) + 1);
-	}
-
-	return retsize;
-}
-
-static void create_env_sysfs(void)
-{
-	char *string;
-	int i = 0;
-
-	if (NULL == environment) {
-		ERROR_PRINT("Environment Isn't Available!\n");
-		return;
-	}
-
-	string = environment->data;
-
-	while (0x00 != string[0]) {
-		char *value_ = strchr(string, '=');
-		char *name = vmalloc(1 + value_ - string);
-
-		strlcpy(name, string, 1 + value_ - string);
-
-		uboot_env[i].attr.name = name;
-		uboot_env[i].attr.mode = 0400;
-		uboot_env[i].size = strlen(string) - (value_ - string);
-		uboot_env[i].read = read_env;
-
-		if (sysfs_create_bin_file(ubootenv_kobj, &uboot_env[i]))
-			ERROR_PRINT("unable to add uboot-env sysfs file\n");
-
-		string += (strlen(string) + 1);
-		i++;
-		if (i > 99) {
-			ERROR_PRINT("More than 100 uboot env variables.\n");
-			return;
-		}
-	}
-}
-
-
-static ssize_t list_env(struct device *dev,
-			struct device_attribute *attr,
-			char *buf)
-{
-	int i = 1;
-
-	while (i < uboot_env_size - 2) {
-		if (environment->data[i-1] == 0)
-			if (environment->data[i] == 0)
-				if (environment->data[i+1] == 0)
-					break;
-		i++;
-	}
-	memcpy(buf, environment->data, i);
-	return i;
-}
-
-static DEVICE_ATTR(list_env, 0444, list_env, NULL);
-
-static struct attribute *attrs[] = {
-	&dev_attr_list_env.attr,
-	NULL,
-};
-
-static struct attribute_group attr_group = {
-	.attrs = attrs,
-};
-
-
-/*
-  ======================================================================
-  ======================================================================
-  Linux Module Stuff
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_module_init
-*/
-
-int __init
-ubootenv_module_init(void)
-{
-	int retval;
-
-	DEBUG_PRINT("\n");
-	ubootenv_kobj = kobject_create_and_add("uboot-env", kernel_kobj);
-	if (!ubootenv_kobj)
-		return -ENOMEM;
-
-	/* Create the files associated with this kobject */
-	retval = sysfs_create_group(ubootenv_kobj, &attr_group);
-	if (retval)
-		goto fail;
-
-	retval = ubootenv_initialize();
-	if (retval)
-		goto fail;
-
-	return 0;
-fail:
-	kobject_put(ubootenv_kobj);
-
-	return retval;
-}
-
-module_init(ubootenv_module_init);
-
-/*
-  ----------------------------------------------------------------------
-  ubootenv_module_exit
-*/
-
-void __exit
-ubootenv_module_exit(void)
-{
-	DEBUG_PRINT("\n");
-	kobject_put(ubootenv_kobj);
-	ubootenv_finalize();
-}
-
-module_exit(ubootenv_module_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("John Jacques <john.jacques@intel.com>");
-MODULE_DESCRIPTION("Read Access of the U-Boot Environment");
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index bbf81e1..a70e9fc 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -56,7 +56,7 @@ config CX_ECAT
 	  will be called ec_bhf.
 
 source "drivers/net/ethernet/davicom/Kconfig"
-source "drivers/net/ethernet/lsi/Kconfig"
+source "drivers/net/ethernet/axxia/Kconfig"
 
 config DNET
 	tristate "Dave ethernet support (DNET)"
@@ -83,7 +83,7 @@ source "drivers/net/ethernet/ibm/Kconfig"
 source "drivers/net/ethernet/intel/Kconfig"
 source "drivers/net/ethernet/i825xx/Kconfig"
 source "drivers/net/ethernet/xscale/Kconfig"
-source "drivers/net/ethernet/lsi/Kconfig"
+source "drivers/net/ethernet/axxia/Kconfig"
 
 config JME
 	tristate "JMicron(R) PCI-Express Gigabit Ethernet support"
@@ -183,6 +183,6 @@ source "drivers/net/ethernet/wiznet/Kconfig"
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 source "drivers/net/ethernet/synopsys/Kconfig"
-source "drivers/net/ethernet/lsi/Kconfig"
+source "drivers/net/ethernet/axxia/Kconfig"
 
 endif # ETHERNET
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index 549abd8..6ae6519 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -92,4 +92,4 @@ obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
 obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/
-obj-$(CONFIG_LSI_NET) += lsi/
+obj-$(CONFIG_AXXIA_NET) += axxia/
diff --git a/drivers/net/ethernet/axxia/Kconfig b/drivers/net/ethernet/axxia/Kconfig
new file mode 100644
index 0000000..8cab802
--- /dev/null
+++ b/drivers/net/ethernet/axxia/Kconfig
@@ -0,0 +1,38 @@
+config AXXIA_NET
+	bool "INTEL Axxia ACP34XX Ethernet support"
+	select MII
+	select PHYLIB
+	help
+	  Network interface driver for INTEL Axxia's APP and AXXIA series boards.
+
+if AXXIA_NET
+
+config AXXIA_NET_NUM_RX_DESC
+	int "INTEL Axxia Network Driver: Number of receive descriptors"
+	depends on AXXIA_NET
+	default "4"
+	help
+          The number of receive descriptors to allocate.
+
+config AXXIA_NET_RX_BUF_SZ
+	int "NIC driver: Size of the receive buffer"
+	depends on AXXIA_NET
+	default "32768"
+	help
+          The size of the receive buffer.
+
+config AXXIA_NET_NUM_TX_DESC
+	int "NIC driver: Number of transmit descriptors"
+	depends on AXXIA_NET
+	default "4"
+	help
+	  The number of transmit descriptors to allocate.
+
+config AXXIA_NET_TX_BUF_SZ
+	int "NIC driver: Size of the transmit buffer"
+	depends on AXXIA_NET
+	default "32768"
+	help
+	  The size of the transmit buffer.
+
+endif # AXXIA_NET
diff --git a/drivers/net/ethernet/axxia/Makefile b/drivers/net/ethernet/axxia/Makefile
new file mode 100644
index 0000000..3739dc9
--- /dev/null
+++ b/drivers/net/ethernet/axxia/Makefile
@@ -0,0 +1,4 @@
+# Makefile for the INTEL Axxia FEMAC network interface.
+
+obj-$(CONFIG_AXXIA_NET) += axxia_acp_mdio.o
+obj-$(CONFIG_AXXIA_NET) += axxia_acp_net.o
diff --git a/drivers/net/ethernet/axxia/axxia_acp_mdio.c b/drivers/net/ethernet/axxia/axxia_acp_mdio.c
new file mode 100644
index 0000000..0195181
--- /dev/null
+++ b/drivers/net/ethernet/axxia/axxia_acp_mdio.c
@@ -0,0 +1,338 @@
+/*
+ * drivers/net/ethernet/axxia/axxia_acp_mdio.c
+ *
+ * Copyright (C) 2013 INTEL Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/irqdomain.h>
+#include <linux/skbuff.h>
+#include <linux/platform_device.h>
+
+#define BZ33327_WA
+
+/* MDIO Access */
+
+struct axxia_mdio_priv {
+	unsigned long base;
+};
+
+static struct axxia_mdio_priv *mdio_priv;
+static DEFINE_SPINLOCK(mdio_lock);
+
+#define MDIO_CONTROL_RD_DATA ((void *)(mdio_priv->base + 0x0))
+#define MDIO_STATUS_RD_DATA  ((void *)(mdio_priv->base + 0x4))
+#define MDIO_CLK_OFFSET      ((void *)(mdio_priv->base + 0x8))
+#define MDIO_CLK_PERIOD      ((void *)(mdio_priv->base + 0xc))
+
+#ifdef CONFIG_ARM
+static u32 read_reg(u32 *addr)
+{
+	return readl_relaxed((void __iomem *)addr);
+}
+
+static void write_reg(u32 *addr, u32 value)
+{
+	writel_relaxed(value, (void __iomem *)addr);
+}
+#else
+static u32 read_reg(u32 *addr)
+{
+	return in_le32((unsigned *)addr);
+}
+
+static void write_reg(u32 *addr, u32 value)
+{
+	out_le32((unsigned *)addr, (int)value);
+}
+#endif
+
+/* acp_mdio_read */
+
+int
+acp_mdio_read(unsigned long address, unsigned long offset,
+	      unsigned short *value, int clause_45)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+#if defined(BZ33327_WA)
+	/* Set the mdio_busy (status) bit. */
+	status = read_reg(MDIO_STATUS_RD_DATA);
+	status |= 0x40000000;
+	write_reg(MDIO_STATUS_RD_DATA, status);
+#endif /* BZ33327_WA */
+
+	if (clause_45 == 0) {
+		/* Write the command. */
+		command = 0x10000000;              /* op_code: read */
+		command |= (address & 0x1f) << 16; /* port_addr (tgt device) */
+		command |= (offset & 0x1f) << 21;  /* device_addr (tgt reg) */
+		write_reg(MDIO_CONTROL_RD_DATA, command);
+	} else {
+		/* Step 1: Write the address. */
+
+		/* Write the address */
+		command = 0x20000000;                    /* Clause 45 = 1 */
+		command |= 0x00000000;                   /* op_code: 0 */
+		command |= 0x04000000;                   /* interface_sel = 1 */
+		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
+							  * device_type)
+							  */
+		command |= (address & 0x1f) << 16;       /* port_addr (target
+							  * device)
+							  */
+		command |= (offset & 0xffff);            /* addr_or_data (target
+							  * register)
+							  */
+		write_reg(MDIO_CONTROL_RD_DATA, command);
+
+		/* Wait for the mdio_busy (status) bit to clear. */
+		do {
+			status = read_reg(MDIO_STATUS_RD_DATA);
+		} while (0 != (status & 0x40000000));
+
+		/* Wait for the mdio_busy (control) bit to clear. */
+		do {
+			command = read_reg(MDIO_CONTROL_RD_DATA);
+		} while (0 != (command & 0x80000000));
+
+		/* Step 2: Read the value. */
+
+		/* Set the mdio_busy (status) bit. */
+		status = read_reg(MDIO_STATUS_RD_DATA);
+		status |= 0x40000000;
+		write_reg(MDIO_STATUS_RD_DATA, status);
+
+		command = 0x20000000;                    /* Clause 45 = 1 */
+		command |= 0x10000000;                   /* op_code: read */
+		command |= 0x04000000;                   /* interface_sel = 1 */
+		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
+							  * device_type)
+							  */
+		command |= (address & 0x1f) << 16;       /* port_addr (target
+							  * device)
+							  */
+		write_reg(MDIO_CONTROL_RD_DATA, command);
+	}
+
+#if defined(BZ33327_WA)
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = read_reg(MDIO_STATUS_RD_DATA);
+	} while (0 != (status & 0x40000000));
+#endif				/* BZ33327_WA */
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = read_reg(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+	*value = (unsigned short)(command & 0xffff);
+	spin_unlock_irqrestore(&mdio_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(acp_mdio_read);
+
+/* acp_mdio_write */
+
+int
+acp_mdio_write(unsigned long address, unsigned long offset,
+	       unsigned short value, int clause_45)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+
+	/* Wait for mdio_busy (control) to be clear. */
+	do {
+		command = read_reg(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+#if defined(BZ33327_WA)
+	/* Set the mdio_busy (status) bit. */
+	status = read_reg(MDIO_STATUS_RD_DATA);
+	status |= 0x40000000;
+	write_reg(MDIO_STATUS_RD_DATA, status);
+#endif /* BZ33327_WA */
+
+	if (clause_45 == 0) {
+		/* Write the command. */
+		command = 0x08000000;              /* op_code: write */
+		command |= (address & 0x1f) << 16; /* port_addr (tgt device) */
+		command |= (offset & 0x1f) << 21;  /* device_addr (tgt reg) */
+		command |= (value & 0xffff);       /* value */
+		write_reg(MDIO_CONTROL_RD_DATA, command);
+	} else {
+		/* Step 1: Write the address. */
+
+		/* Write the address */
+		command = 0x20000000;                    /* Clause 45 = 1 */
+		command |= 0x00000000;                   /* op_code: 0 */
+		command |= 0x04000000;                   /* interface_sel = 1 */
+		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
+							  * device_type)
+							  */
+		command |= (address & 0x1f) << 16;       /* port_addr (target
+							  * device)
+							  */
+		command |= (offset & 0xffff);            /* addr_or_data (target
+							  * register)
+							  */
+		write_reg(MDIO_CONTROL_RD_DATA, command);
+
+		/* Wait for the mdio_busy (status) bit to clear. */
+		do {
+			status = read_reg(MDIO_STATUS_RD_DATA);
+		} while (0 != (status & 0x40000000));
+
+		/* Wait for the mdio_busy (control) bit to clear. */
+		do {
+			command = read_reg(MDIO_CONTROL_RD_DATA);
+		} while (0 != (command & 0x80000000));
+
+		/* Step 2: Write the value. */
+
+		/* Set the mdio_busy (status) bit. */
+		status = read_reg(MDIO_STATUS_RD_DATA);
+		status |= 0x40000000;
+		write_reg(MDIO_STATUS_RD_DATA, status);
+
+		command = 0x20000000;                    /* Clause 45 = 1 */
+		command |= 0x08000000;                   /* op_code: write */
+		command |= 0x04000000;                   /* interface_sel = 1 */
+		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
+							  * device_type)
+							  */
+		command |= (address & 0x1f) << 16;       /* port_addr (target
+							  * device)
+							  */
+		command |= (value & 0xffff);             /* addr_or_data=value*/
+		write_reg(MDIO_CONTROL_RD_DATA, command);
+	}
+
+#if defined(BZ33327_WA)
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = read_reg(MDIO_STATUS_RD_DATA);
+	} while (0 != (status & 0x40000000));
+#endif	/* BZ33327_WA */
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = read_reg(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+	spin_unlock_irqrestore(&mdio_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(acp_mdio_write);
+
+/* acp_mdio_initialize */
+
+static void
+acp_mdio_initialize(int offset, int period)
+{
+	write_reg(MDIO_CLK_OFFSET, offset);
+	write_reg(MDIO_CLK_PERIOD, period);
+
+	return;
+}
+
+/* acp_wrappers_init */
+
+int __init
+acp_mdio_init(void)
+{
+	int rc = -ENODEV;
+	struct device_node *np = NULL;
+	const u32 *field;
+	void __iomem *map;
+	u64 mdio_address;
+	u32 mdio_size;
+	u32 mdio_offset = 0;
+	u32 mdio_period = 0;
+
+	pr_info("MDIO: Initializing Axxia Wrappers.\n");
+
+	mdio_priv = kzalloc(sizeof(struct axxia_mdio_priv), GFP_KERNEL);
+	if (!mdio_priv)
+		return -ENOMEM;
+
+	np = of_find_node_by_type(np, "network");
+
+	while (np &&
+	       !of_device_is_compatible(np, "axxia,acp-femac") &&
+	       !of_device_is_compatible(np, "acp-femac"))
+		np = of_find_node_by_type(np, "network");
+
+	if (!np) {
+		pr_warn("MDIO: No compatible devices found.\n");
+		rc = -EINVAL;
+		goto error;
+	}
+
+	field = of_get_property(np, "mdio-reg", NULL);
+
+	if (!field) {
+		pr_crit("MDIO: Unable to read mdio-reg property!\n");
+		rc = -EINVAL;
+		goto error;
+	}
+
+	mdio_address = of_translate_address(np, field);
+
+	if (mdio_address == OF_BAD_ADDR) {
+		pr_crit("MDIO: of_translate_address failed!\n");
+		rc = -EINVAL;
+		goto error;
+	}
+
+	mdio_size = field[3];
+	map = ioremap(mdio_address, mdio_size);
+
+	if (!map) {
+		pr_crit("MDIO: Unable to ioremap!\n");
+		rc = -ENOMEM;
+		goto error;
+	}
+
+	mdio_priv->base = (unsigned long)map;
+	field = of_get_property(np, "mdio-clock-offset", NULL);
+
+	if (field)
+		mdio_offset = ntohl(field[0]);
+
+	field = of_get_property(np, "mdio-clock-period", NULL);
+
+	if (field)
+		mdio_period = ntohl(field[0]);
+
+	if (0 != mdio_offset && 0 != mdio_period)
+		acp_mdio_initialize(mdio_offset, mdio_period);
+
+error:
+	return rc;
+}
+
+module_init(acp_mdio_init);
+
+MODULE_AUTHOR("INTEL Corporation");
+MODULE_DESCRIPTION("Timing Test");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/axxia/axxia_acp_net.c b/drivers/net/ethernet/axxia/axxia_acp_net.c
new file mode 100644
index 0000000..d900f24
--- /dev/null
+++ b/drivers/net/ethernet/axxia/axxia_acp_net.c
@@ -0,0 +1,2000 @@
+/*
+ * drivers/net/ethernet/axxia/axxia_acp_net.c
+ *
+ * Copyright (C) 2013 INTEL Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * NOTES:
+ *
+ * 1) This driver is used by both ACP (PPC) and AXM (ARM) platforms.
+ *
+ * 2) This driver parses the DTB for driver specific settings. A few of
+ *    them can be overridden by setting environment variables in U-boot:
+ *
+ *    ethaddr - MAC address of interface, in xx:xx:xx:xx:xx:xx format
+ *
+ *    phy-addr - Specific address of PHY (0 - 0x20). If not specified,
+ *               the driver will scan the bus and will attach to the first
+ *               PHY it finds.
+ *
+ *    ad-value - PHY advertise value. Can be set to one of these or they
+ *               be OR'ed together. If not set, the driver sets the
+ *               advertised value equal to what the driver supports.
+ *
+ *               0x101 - 100/Full
+ *               0x81  - 100/Half
+ *               0x41  - 10/Full
+ *               0x21  - 10/Half
+ *
+ * 3) This driver allows the option to disable auto negotiation and manually
+ *    specify the speed and duplex setting, with the use of the device tree
+ *    variable "phy-link". Legal values for this variable are:
+ *
+ *    "auto"  - auto negotiation enabled
+ *    "100MF" - auto negotiation disabled, set to 100MB Full Duplex
+ *    "10MH"  - auto negotiation disabled, set to 100MB Half Duplex
+ *    "10MF"  - auto negotiation disabled, set to 10MB Full Duplex
+ *    "10MH"  - auto negotiation disabled, set to 10MB Half Duplex
+ *
+ *    NOTE: If the phy-link variable is not present in the device tree, or
+ *    if an invalid value is used, the driver defaults to auto negotiation
+ *    mode.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_net.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/axxia-ncr.h>
+
+#include <asm/dma.h>
+
+#include "axxia_acp_net.h"
+
+#define AXXIA_DRV_NAME           "acp-femac"
+#define AXXIA_MDIO_NAME          "acp-femac-mdio"
+#define AXXIA_DRV_VERSION        "2014-01-09"
+
+MODULE_AUTHOR("John Jacques");
+MODULE_DESCRIPTION("AXXIA ACP-FEMAC Ethernet driver");
+MODULE_LICENSE("GPL");
+
+/* ----------------------------------------------------------------------
+ * appnic_mii_read
+ *
+ * Returns -EBUSY if unsuccessful, the (short) value otherwise.
+ */
+
+static int appnic_mii_read(struct mii_bus *bus, int phy, int reg)
+{
+	unsigned short value;
+
+	/* Always returns success, so no need to check return status. */
+	acp_mdio_read(phy, reg, &value, 0);
+
+	return (int)value;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_mii_write
+ */
+
+static int appnic_mii_write(struct mii_bus *bus, int phy, int reg, u16 val)
+{
+	return acp_mdio_write(phy, reg, val, 0);
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_handle_link_change
+ *
+ * Called periodically when PHY is in polling mode.
+ */
+
+static void appnic_handle_link_change(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct phy_device *phydev = pdata->phy_dev;
+	int status_change = 0;
+	unsigned long rx_configuration;
+	unsigned long tx_configuration = 0;
+
+	rx_configuration =
+#ifdef CONFIG_ARM
+		APPNIC_RX_CONF_STRIPCRC;
+#else
+		(APPNIC_RX_CONF_STRIPCRC |
+		 APPNIC_RX_CONF_RXFCE |
+		 APPNIC_RX_CONF_TXFCE);
+#endif
+	tx_configuration =
+		(APPNIC_TX_CONF_ENABLE_SWAP_SA |
+		 APPNIC_TX_CONF_APP_CRC_ENABLE |
+		 APPNIC_TX_CONF_PAD_ENABLE);
+
+	TX_CONF_SET_IFG(tx_configuration, 0xf);
+
+	if (phydev->link) {
+		if ((pdata->speed != phydev->speed) ||
+		    (pdata->duplex != phydev->duplex)) {
+			if (phydev->duplex) {
+				rx_configuration |= APPNIC_RX_CONF_DUPLEX;
+				tx_configuration |= APPNIC_TX_CONF_DUPLEX;
+			}
+			if (phydev->speed == SPEED_100) {
+				rx_configuration |= APPNIC_RX_CONF_SPEED;
+				tx_configuration |= APPNIC_TX_CONF_SPEED;
+			}
+
+			rx_configuration |= (APPNIC_RX_CONF_ENABLE |
+					     APPNIC_RX_CONF_LINK);
+			tx_configuration |= (APPNIC_TX_CONF_LINK |
+					     APPNIC_TX_CONF_ENABLE);
+
+			pdata->speed = phydev->speed;
+			pdata->duplex = phydev->duplex;
+			status_change = 1;
+		}
+	}
+	if (phydev->link != pdata->link) {
+		if (!phydev->link) {
+			pdata->speed = 0;
+			pdata->duplex = -1;
+		}
+		pdata->link = phydev->link;
+		status_change = 1;
+	}
+
+	if (status_change) {
+		if (phydev->link) {
+			netif_carrier_on(dev);
+			netdev_info(dev, "link up (%d/%s)\n",
+				    phydev->speed,
+				    phydev->duplex == DUPLEX_FULL ?
+				    "Full" : "Half");
+		} else {
+			netif_carrier_off(dev);
+			netdev_info(dev, "link down\n");
+		}
+
+		if (rx_configuration != read_mac(APPNIC_RX_CONF))
+			write_mac(rx_configuration, APPNIC_RX_CONF);
+
+		if (tx_configuration != read_mac(APPNIC_TX_CONF))
+			write_mac(tx_configuration, APPNIC_TX_CONF);
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_mii_probe
+ */
+
+static int appnic_mii_probe(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct phy_device *phydev = NULL;
+	int ret;
+
+	if (pdata->phy_address && (pdata->phy_address < PHY_MAX_ADDR)) {
+		phydev = mdiobus_get_phy(pdata->mii_bus, pdata->phy_address);
+		if (phydev)
+			goto skip_first;
+	}
+
+	/* Find the first phy */
+	phydev = phy_find_first(pdata->mii_bus);
+	if (!phydev) {
+		pr_crit("!!! no PHY found !!!\n");
+		netdev_err(dev, " no PHY found\n");
+		return -ENODEV;
+	}
+
+skip_first:
+
+	/* Allow the option to disable auto negotiation and manually specify
+	 * the link speed and duplex setting with the use of a environment
+	 * setting.
+	 */
+
+	if (0 == pdata->phy_link_auto) {
+		phydev->autoneg = AUTONEG_DISABLE;
+		phydev->speed =
+			0 == pdata->phy_link_speed ? SPEED_10 : SPEED_100;
+		phydev->duplex =
+			0 == pdata->phy_link_duplex ? DUPLEX_HALF : DUPLEX_FULL;
+	} else {
+		phydev->autoneg = AUTONEG_ENABLE;
+	}
+
+	ret = phy_connect_direct(dev, phydev,
+				 &appnic_handle_link_change,
+				 PHY_INTERFACE_MODE_MII);
+
+	if (ret) {
+		netdev_err(dev, "Could not attach to PHY\n");
+		return ret;
+	}
+
+	phy_attached_info(phydev);
+
+	/* Mask with MAC supported features */
+	phydev->supported &= PHY_BASIC_FEATURES;
+	if (pdata->ad_value)
+		phydev->advertising = mii_adv_to_ethtool_adv_t(pdata->ad_value);
+	else
+		phydev->advertising = phydev->supported;
+
+	pdata->link = 0;
+	pdata->speed = 0;
+	pdata->duplex = -1;
+	pdata->phy_dev = phydev;
+
+	pr_info("%s: PHY initialized successfully", AXXIA_DRV_NAME);
+	return 0;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_mii_init
+ */
+
+static int appnic_mii_init(struct platform_device *pdev,
+			   struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	int i, err = -ENXIO;
+
+	pdata->mii_bus = mdiobus_alloc();
+	if (!pdata->mii_bus) {
+		err = -ENOMEM;
+		goto err_out_1;
+	}
+
+	pdata->mii_bus->name = AXXIA_MDIO_NAME;
+	snprintf(pdata->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
+		 pdev->name, pdev->id);
+	pdata->mii_bus->priv = pdata;
+	pdata->mii_bus->read = appnic_mii_read;
+	pdata->mii_bus->write = appnic_mii_write;
+	memcpy(pdata->mii_bus->irq, pdata->phy_irq, sizeof(pdata->phy_irq));
+	for (i = 0; i < PHY_MAX_ADDR; ++i)
+		pdata->mii_bus->irq[i] = PHY_POLL;
+
+	if (mdiobus_register(pdata->mii_bus)) {
+		pr_warn("%s: Error registering mii bus", AXXIA_DRV_NAME);
+		goto err_out_free_bus_2;
+	}
+
+	if (appnic_mii_probe(dev) < 0) {
+		pr_warn("%s: Error registering mii bus", AXXIA_DRV_NAME);
+		goto err_out_unregister_bus_3;
+	}
+
+	return 0;
+
+err_out_unregister_bus_3:
+	mdiobus_unregister(pdata->mii_bus);
+err_out_free_bus_2:
+	mdiobus_free(pdata->mii_bus);
+err_out_1:
+	return err;
+}
+
+/* ======================================================================
+ * NIC Interface
+ * ======================================================================
+*/
+
+#define DESCRIPTOR_GRANULARITY 64
+#define BUFFER_ALIGNMENT 64
+
+#define ALIGN64B(address) (PTR_ALIGN((address), BUFFER_ALIGNMENT))
+#define ALIGN64B_OFFSET(address) \
+	(ALIGN64B(address) - (unsigned long) (address))
+
+/*  ----- Note On Buffer Space -----
+ *
+ *  Minimum number of descriptors is 64 for the receiver and 64 for the
+ *  transmitter; therefore, 2048 bytes (16 bytes each).
+ *  This driver uses the following parameters, all of which may be set on
+ *  the command line if this drivers is used as a module.
+ *
+ *  - rx_num_desc : Number of receive descriptors. This  must be a multiple
+ *                  of 64.
+ *  - tx_num_desc : Number of transmit descriptors. This must be a multiple
+ *                  of 64.
+ *
+ *  The scheme used will be as follows:
+ *
+ *  - num_[rt]x_desc will be adjusted to be a multiple of 64 (if necessary).
+ *  - An skb (with the data area 64 byte aligned) will be allocated for each rx
+ *    descriptor.
+ */
+
+/* Receiver */
+
+int rx_num_desc = (CONFIG_AXXIA_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY);
+module_param(rx_num_desc, int, 0000);
+MODULE_PARM_DESC(rx_num_desc, "appnic : Number of receive descriptors");
+
+int rx_buf_sz = CONFIG_AXXIA_NET_RX_BUF_SZ;
+module_param(rx_buf_sz, int, 0000);
+MODULE_PARM_DESC(rx_buf_sz, "appnic : Receive buffer size");
+
+/* Transmitter */
+
+int tx_num_desc = (CONFIG_AXXIA_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY);
+module_param(tx_num_desc, int, 0000);
+MODULE_PARM_DESC(tx_num_desc, "appnic : Number of receive descriptors");
+
+int tx_buf_sz = CONFIG_AXXIA_NET_TX_BUF_SZ;
+module_param(tx_buf_sz, int, 0000);
+MODULE_PARM_DESC(tx_buf_sz, "Appnic : Receive buffer size");
+
+/* ======================================================================
+ * Utility Functions
+ * ======================================================================
+ */
+
+/* ----------------------------------------------------------------------
+ * mac_addr_valid
+ *
+ * If mac address is multicast, broadcast, or matches our mac address,
+ * it's a valid address. Otherwise, it's not.
+ */
+
+static bool mac_addr_valid(struct net_device *dev, u8 *mac_addr)
+{
+	bool is_valid = false;
+
+	if (is_multicast_ether_addr(mac_addr))
+		is_valid = true;
+	else if (is_broadcast_ether_addr(mac_addr))
+		is_valid = true;
+	else if (ether_addr_equal(mac_addr, &dev->dev_addr[0]))
+		is_valid = true;
+
+	return is_valid;
+}
+
+/* ----------------------------------------------------------------------
+ * clear_statistics
+ *
+ * NOTE: The hardware clears the statistics registers after a read.
+ */
+
+static void clear_statistics(struct appnic_device *pdata)
+{
+	/* Clear memory. */
+
+	memset((void *)&pdata->stats, 0, sizeof(struct net_device_stats));
+
+	/* Clear counters by reading them. */
+
+	/* stats.rx_packets */
+	read_mac(APPNIC_RX_STAT_PACKET_OK);
+
+	/* stats.tx_packets */
+	read_mac(APPNIC_TX_STAT_PACKET_OK);
+
+	/* stats.rx_bytes - Updated by this driver.
+	 * stats.tx_bytes - Updated by this driver.
+	 * stats.rx_errors - The sum of all RX errors available.
+	 * stats.tx_errors - The sum of all TX errors available.
+	 * stats.rx_dropped (unable to allocate skb) - Updated by the stack.
+	 * stats.tx_dropped (unable to allocate skb) - Updated by the stack.
+	 */
+
+	/* stats.multicast */
+	read_mac(APPNIC_RX_STAT_MULTICAST);
+
+	/* stats.collisions - The sum of the following driver stats. */
+	read_mac(APPNIC_TX_STATUS_LATE_COLLISION);
+	read_mac(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
+	read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
+
+	/* stats.rx_length_errors - The sum of the following driver stats. */
+	read_mac(APPNIC_RX_STAT_UNDERSIZE);
+	read_mac(APPNIC_RX_STAT_OVERSIZE);
+
+	/* stats.rx_over_errors - Not maintained by this driver. */
+
+	/* stats.rx_crc_errors */
+	read_mac(APPNIC_RX_STAT_CRC_ERROR);
+
+	/* stats.rx_frame_errors */
+	read_mac(APPNIC_RX_STAT_ALIGN_ERROR);
+
+	/* stats.rx_fifo_errors */
+	read_mac(APPNIC_RX_STAT_OVERFLOW);
+
+	/* stats.rx_missed - Not maintained by this driver.
+	 * stats.tx_aborted_errors - Not maintained by this driver.
+	 * stats.tx_carrier_errors - Not maintained by this driver.
+	 */
+
+	/* stats.tx_fifo_errors */
+	read_mac(APPNIC_TX_STAT_UNDERRUN);
+
+	/* stats.tx_heartbeat_errors - Not maintained by this driver.
+	 * stats.tx_window_errors - Not mainteaned by this driver.
+	 * stats.rx_compressed - Not maintained by this driver.
+	 * stats.tx_compressed - Not maintained by this driver.
+	 */
+}
+
+/* ----------------------------------------------------------------------
+ * get_hw_statistics
+ *
+ * NOTE: The hardware clears the statistics registers after a read.
+ */
+
+static void get_hw_statistics(struct appnic_device *pdata)
+{
+	unsigned long flags;
+	u32 rx_under;
+	u32 rx_over;
+	u32 tx_under;
+
+	/* stats.tx_packets */
+	pdata->stats.tx_packets += read_mac(APPNIC_TX_STAT_PACKET_OK);
+
+	/* stats.multicast */
+	pdata->stats.multicast += read_mac(APPNIC_RX_STAT_MULTICAST);
+
+	/* stats.collision */
+	pdata->stats.collisions += read_mac(APPNIC_TX_STATUS_LATE_COLLISION);
+	pdata->stats.collisions +=
+		read_mac(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
+	pdata->stats.collisions +=
+		read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
+
+	/* stats.rx_length_errors */
+	rx_under = read_mac(APPNIC_RX_STAT_UNDERSIZE);
+	pdata->stats.rx_length_errors += rx_under;
+	rx_over = read_mac(APPNIC_RX_STAT_OVERSIZE);
+	pdata->stats.rx_length_errors += rx_over;
+
+	/* stats.tx_fifo_errors */
+	tx_under = read_mac(APPNIC_TX_STAT_UNDERRUN);
+	pdata->stats.tx_fifo_errors += tx_under;
+
+	/* Lock this section out so the statistics maintained by the driver
+	 * don't get clobbered.
+	 */
+
+	spin_lock_irqsave(&pdata->dev_lock, flags);
+
+	pdata->stats.rx_dropped = 0;
+	pdata->stats.rx_over_errors = 0;
+
+	/* Update the cumulative rx_errors. */
+	pdata->stats.rx_errors += (rx_under + rx_over);
+
+	pdata->stats.tx_aborted_errors = 0;
+
+	/* Update the cumulative tx_errors. */
+	pdata->stats.tx_errors += tx_under;
+
+	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+}
+
+/* ----------------------------------------------------------------------
+ * queue_initialized
+ *
+ * Returns the number of descriptors that are ready to receive packets
+ * or are waiting to transmit packets.  (from tail to head).
+ */
+
+static int queue_initialized(union appnic_queue_pointer head,
+			     union appnic_queue_pointer tail,
+			     int size)
+{
+	int initialized;
+
+	/* Calculate the number of descriptors currently initialized. */
+	if (head.bits.generation_bit == tail.bits.generation_bit) {
+		/* same generation */
+		initialized = (head.bits.offset - tail.bits.offset);
+	} else {
+		/* different generation */
+		initialized = head.bits.offset +
+			(size * sizeof(struct appnic_dma_descriptor) -
+			 tail.bits.offset);
+	}
+
+	/* Number of descriptors is offset / sizeof(a descriptor). */
+	initialized /= sizeof(struct appnic_dma_descriptor);
+
+	return initialized;
+}
+
+/* ----------------------------------------------------------------------
+ * queue_uninitialzed
+ *
+ * Returns the number of unused/uninitialized descriptors. (from head to tail).
+*/
+
+static int queue_uninitialized(union appnic_queue_pointer head,
+			       union appnic_queue_pointer tail,
+			       int size)
+{
+	int allocated;
+
+	/* Calculate the number of descriptors currently unused/uninitialized */
+	if (head.bits.generation_bit == tail.bits.generation_bit)
+		/* Same generation. */
+		allocated = ((size * sizeof(struct appnic_dma_descriptor)) -
+			 head.bits.offset) + tail.bits.offset;
+	else
+		/* Different generation. */
+		allocated = tail.bits.offset - head.bits.offset;
+
+	/* Number of descriptors is offset / sizeof(a descriptor). */
+	allocated /= sizeof(struct appnic_dma_descriptor);
+
+	/* That's all. */
+	return allocated;
+}
+
+/* ----------------------------------------------------------------------
+ * queue_increment
+ */
+
+static void queue_increment(union appnic_queue_pointer *queue,
+			    int number_of_descriptors)
+{
+	queue->bits.offset += sizeof(struct appnic_dma_descriptor);
+
+	if ((number_of_descriptors * sizeof(struct appnic_dma_descriptor)) ==
+		queue->bits.offset) {
+		queue->bits.offset = 0;
+		queue->bits.generation_bit =
+			(0 == queue->bits.generation_bit) ? 1 : 0;
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * queue_decrement
+ */
+
+static void queue_decrement(union appnic_queue_pointer *queue,
+			    int number_of_descriptors)
+{
+	if (0 == queue->bits.offset) {
+		queue->bits.offset =
+			((number_of_descriptors - 1) *
+			 sizeof(struct appnic_dma_descriptor));
+		queue->bits.generation_bit =
+			(0 == queue->bits.generation_bit) ? 1 : 0;
+	} else {
+		queue->bits.offset -= sizeof(struct appnic_dma_descriptor);
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * disable_rx_tx
+ */
+
+static void disable_rx_tx(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	unsigned long tx_configuration;
+	unsigned long rx_configuration;
+
+	rx_configuration = read_mac(APPNIC_RX_CONF);
+	rx_configuration &= ~APPNIC_RX_CONF_ENABLE;
+	write_mac(rx_configuration, APPNIC_RX_CONF);
+
+	tx_configuration = read_mac(APPNIC_TX_CONF);
+	tx_configuration &= ~APPNIC_TX_CONF_ENABLE;
+
+	write_mac(tx_configuration, APPNIC_TX_CONF);
+}
+
+/* ======================================================================
+ *  Linux Network Driver Interface
+ *  ======================================================================
+*/
+
+/* ----------------------------------------------------------------------
+ * handle_transmit_interrupt
+ */
+
+static void handle_transmit_interrupt(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	union appnic_queue_pointer queue;
+
+	/* The hardware's tail pointer should be one descriptor (or more)
+	 * ahead of software's copy.
+	 */
+
+	queue = swab_queue_pointer(pdata->tx_tail);
+	while (0 < queue_initialized(queue, pdata->tx_tail_copy,
+				     pdata->tx_num_desc)) {
+		queue_increment(&pdata->tx_tail_copy, pdata->tx_num_desc);
+		queue = swab_queue_pointer(pdata->tx_tail);
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * axxianet_rx_packet
+ */
+
+static void axxianet_rx_packet(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct appnic_dma_descriptor descriptor;
+	struct sk_buff *sk_buff;
+	unsigned bytes_copied = 0;
+	unsigned error_num = 0;
+	unsigned long ok_stat = 0, overflow_stat = 0;
+	unsigned long crc_stat = 0, align_stat = 0;
+	union appnic_queue_pointer queue;
+
+	readdescriptor(((unsigned long)pdata->rx_desc +
+			pdata->rx_tail_copy.bits.offset), &descriptor);
+
+	sk_buff = netdev_alloc_skb(NULL, AXXIANET_MAX_MTU);
+
+	if ((struct sk_buff *)0 == sk_buff) {
+		pr_info_ratelimited("%s: No buffer, packet dropped.\n",
+				    AXXIA_DRV_NAME);
+		pdata->stats.rx_dropped++;
+		return;
+	} else {
+		/* Needs to be reviewed.  This fixed an aligment
+		* exception when pinging to the target from a host.
+		*/
+
+		/* Align IP on 16 byte boundaries */
+		skb_reserve(sk_buff, 2);
+	}
+
+	ok_stat = read_mac(APPNIC_RX_STAT_PACKET_OK);
+	overflow_stat = read_mac(APPNIC_RX_STAT_OVERFLOW);
+	crc_stat = read_mac(APPNIC_RX_STAT_CRC_ERROR);
+	align_stat = read_mac(APPNIC_RX_STAT_ALIGN_ERROR);
+
+	/* Copy the received packet into the skb. */
+
+	queue = swab_queue_pointer(pdata->rx_tail);
+	while (0 < queue_initialized(queue, pdata->rx_tail_copy,
+				     pdata->rx_num_desc)) {
+		if (skb_tailroom(sk_buff) >= descriptor.pdu_length) {
+			unsigned char *buffer;
+
+			buffer = skb_put(sk_buff, descriptor.pdu_length);
+			memcpy((void *)buffer,
+			       (void *)(descriptor.host_data_memory_pointer +
+				 pdata->dma_alloc_offset_rx),
+			       descriptor.pdu_length);
+		} else {
+			pr_err_ratelimited("%s: PDU overrun (%u/%u, %d)\n",
+					   AXXIA_DRV_NAME,
+					   descriptor.pdu_length,
+					   bytes_copied,
+					   descriptor.error);
+		}
+		bytes_copied += descriptor.pdu_length;
+		descriptor.data_transfer_length = pdata->rx_buf_per_desc;
+		writedescriptor(((unsigned long)pdata->rx_desc +
+					pdata->rx_tail_copy.bits.offset),
+				&descriptor);
+		if (0 != descriptor.error)
+			error_num = 1;
+		queue_increment(&pdata->rx_tail_copy, pdata->rx_num_desc);
+		if (0 != descriptor.end_of_packet)
+			break;
+		readdescriptor(((unsigned long)pdata->rx_desc +
+					pdata->rx_tail_copy.bits.offset),
+			       &descriptor);
+		queue = swab_queue_pointer(pdata->rx_tail);
+	}
+
+	if (0 == descriptor.end_of_packet) {
+		pr_err("%s: No end of packet! %lu/%lu/%lu/%lu\n",
+		       AXXIA_DRV_NAME, ok_stat, overflow_stat,
+		       crc_stat, align_stat);
+		BUG();
+		dev_kfree_skb(sk_buff);
+
+	} else if (0 == error_num) {
+		struct ethhdr *ethhdr = (struct ethhdr *)sk_buff->data;
+
+		if (mac_addr_valid(dev, &ethhdr->h_dest[0])) {
+			pdata->stats.rx_bytes += bytes_copied;
+			++pdata->stats.rx_packets;
+			sk_buff->dev = dev;
+			sk_buff->protocol = eth_type_trans(sk_buff, dev);
+
+			if (netif_receive_skb(sk_buff) == NET_RX_DROP)
+				++pdata->dropped_by_stack;
+		} else {
+			dev_kfree_skb(sk_buff);
+		}
+	} else {
+		dev_kfree_skb(sk_buff);
+
+		pdata->stats.rx_errors +=
+			(overflow_stat + crc_stat + align_stat);
+
+		if (0 != overflow_stat)
+			pdata->stats.rx_fifo_errors += overflow_stat;
+		else if (0 != crc_stat)
+			pdata->stats.rx_crc_errors += crc_stat;
+		else if (0 != align_stat)
+			pdata->stats.rx_frame_errors += align_stat;
+	}
+
+	return;
+}
+
+/* ----------------------------------------------------------------------
+ * axxianet_rx_packets
+ */
+
+static int axxianet_rx_packets(struct net_device *dev, int max)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	union appnic_queue_pointer orig_queue, new_queue;
+	int updated_head_pointer = 0;
+	int packets = 0;
+
+	new_queue.raw = pdata->rx_tail_copy.raw;
+
+	/* Receive Packets */
+
+	orig_queue = swab_queue_pointer(pdata->rx_tail);
+	while (0 < queue_initialized(orig_queue, new_queue,
+				     pdata->rx_num_desc)) {
+		struct appnic_dma_descriptor descriptor;
+
+		readdescriptor(((unsigned long)pdata->rx_desc +
+				  new_queue.bits.offset),
+				&descriptor);
+
+		if (0 != descriptor.end_of_packet) {
+			axxianet_rx_packet(dev);
+			packets++;
+			new_queue.raw = pdata->rx_tail_copy.raw;
+
+			if ((-1 != max) && (packets == max))
+				break;
+		} else {
+			queue_increment(&new_queue, pdata->rx_num_desc);
+		}
+		orig_queue = swab_queue_pointer(pdata->rx_tail);
+	}
+
+	/* Update the Head Pointer */
+
+	while (1 < queue_uninitialized(pdata->rx_head,
+				       pdata->rx_tail_copy,
+				       pdata->rx_num_desc)) {
+		struct appnic_dma_descriptor descriptor;
+
+		readdescriptor(((unsigned long)pdata->rx_desc +
+				  pdata->rx_head.bits.offset), &descriptor);
+		descriptor.data_transfer_length = pdata->rx_buf_per_desc;
+		descriptor.write = 1;
+		descriptor.pdu_length = 0;
+		descriptor.start_of_packet = 0;
+		descriptor.end_of_packet = 0;
+		descriptor.interrupt_on_completion = 1;
+		writedescriptor(((unsigned long)pdata->rx_desc +
+				   pdata->rx_head.bits.offset),
+				 &descriptor);
+		queue_increment(&pdata->rx_head, pdata->rx_num_desc);
+		updated_head_pointer = 1;
+	}
+
+	if (0 != updated_head_pointer)
+		write_mac(pdata->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
+
+	return packets;
+}
+
+/* ----------------------------------------------------------------------
+ * axxianet_poll
+ */
+
+static int axxianet_poll(struct napi_struct *napi, int budget)
+{
+	struct appnic_device *pdata =
+		container_of(napi, struct appnic_device, napi);
+	struct net_device *dev = pdata->device;
+
+	int work_done = 0;
+	unsigned long dma_interrupt_status;
+
+	do {
+		/* Acknowledge the RX interrupt. */
+		write_mac(~APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE, APPNIC_DMA_INTERRUPT_STATUS);
+
+		/* Get Rx packets. */
+		work_done += axxianet_rx_packets(dev, budget - work_done);
+
+		/* We've hit the budget limit. */
+		if (work_done == budget)
+			break;
+
+		dma_interrupt_status = read_mac(APPNIC_DMA_INTERRUPT_STATUS);
+
+	} while (RX_INTERRUPT(dma_interrupt_status));
+
+	if (work_done < budget) {
+		napi_complete(napi);
+
+		/* Re-enable receive interrupts (and preserve
+		 * the already enabled TX interrupt).
+		 */
+		write_mac((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+			   APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
+			  APPNIC_DMA_INTERRUPT_ENABLE);
+	}
+
+	return work_done;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_isr
+ */
+
+static irqreturn_t appnic_isr(int irq, void *device_id)
+{
+	struct net_device *dev = (struct net_device *)device_id;
+	struct appnic_device *pdata = netdev_priv(dev);
+	unsigned long dma_interrupt_status;
+	unsigned long dev_flags;
+	unsigned long tx_flags;
+
+	/* Acquire the lock. */
+	spin_lock_irqsave(&pdata->dev_lock, dev_flags);
+
+	/* Get the status. */
+	dma_interrupt_status = read_mac(APPNIC_DMA_INTERRUPT_STATUS);
+
+	/* NAPI - don't ack RX interrupt */
+	write_mac(APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
+		  APPNIC_DMA_INTERRUPT_STATUS);
+
+	/* Handle interrupts. */
+	if (TX_INTERRUPT(dma_interrupt_status)) {
+		/* transmition complete */
+		pdata->transmit_interrupts++;
+		spin_lock_irqsave(&pdata->tx_lock, tx_flags);
+		handle_transmit_interrupt(dev);
+		spin_unlock_irqrestore(&pdata->tx_lock, tx_flags);
+	}
+
+	if (RX_INTERRUPT(dma_interrupt_status)) {
+		pdata->receive_interrupts++;
+		if (napi_schedule_prep(&pdata->napi)) {
+			/* Disable RX interrupts and tell the
+			 * system we've got work
+			 */
+			write_mac(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
+				  APPNIC_DMA_INTERRUPT_ENABLE);
+			__napi_schedule(&pdata->napi);
+		} else {
+			write_mac(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
+				  APPNIC_DMA_INTERRUPT_ENABLE);
+		}
+	}
+
+	/* Release the lock */
+	spin_unlock_irqrestore(&pdata->dev_lock, dev_flags);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+
+/* ----------------------------------------------------------------------
+ * appnic_poll_controller
+ *
+ * Polling receive - used by netconsole and other diagnostic tools
+ * to allow network i/o with interrupts disabled.
+ */
+
+static void appnic_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	appnic_isr(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+
+#endif
+
+/* ----------------------------------------------------------------------
+ * appnic_open
+ *
+ * Opens the interface.  The interface is opened whenever ifconfig
+ * activates it.  The open method should register any system resource
+ * it needs (I/O ports, IRQ, DMA, etc.) turn on the hardware, and
+ * increment the module usage count.
+ */
+
+static int appnic_open(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	int return_code = 0;
+
+	/* Bring the PHY up. */
+	phy_start(pdata->phy_dev);
+
+	/* Enable NAPI. */
+	napi_enable(&pdata->napi);
+
+	/* Install the interrupt handlers. */
+	return_code = request_irq(dev->irq, appnic_isr, 0x00, AXXIA_DRV_NAME, dev);
+	if (0 != return_code) {
+		pr_err("%s: request_irq() failed, returned 0x%x/%d\n",
+		       AXXIA_DRV_NAME, return_code, return_code);
+		return return_code;
+	}
+
+	/* Enable interrupts. */
+	write_mac((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+		   APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
+		   APPNIC_DMA_INTERRUPT_ENABLE);
+
+	/* Let the OS know we are ready to send packets. */
+	netif_start_queue(dev);
+
+	/* That's all. */
+	return 0;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_stop
+ *
+ * Stops the interface.  The interface is stopped when it is brought
+ * down; operations performed at open time should be reversed.
+ */
+
+static int appnic_stop(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+
+	pr_info("%s: Stopping the interface.\n", AXXIA_DRV_NAME);
+
+	/* Disable interrupts. Note that disable_irq() will wait for
+	 * any interrupt handlers that are currently executing to
+	 * complete.
+	 */
+	write_mac(0, APPNIC_DMA_INTERRUPT_ENABLE);
+	disable_irq(dev->irq);
+	free_irq(dev->irq, dev);
+
+	/* Indicate to the OS that no more packets should be sent.  */
+	netif_stop_queue(dev);
+	napi_disable(&pdata->napi);
+
+	/* Stop the receiver and transmitter. */
+	disable_rx_tx(dev);
+
+	/* Bring the PHY down. */
+	if (pdata->phy_dev)
+		phy_stop(pdata->phy_dev);
+
+	/* That's all. */
+	return 0;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_hard_start_xmit
+ *
+ * The method initiates the transmission of a packet.  The full packet
+ * (protocol headers and all) is contained in a socket buffer (sk_buff)
+ * structure.
+ *
+ * ----- NOTES -----
+ *
+ * 1) This will not get called again by the kernel until it returns.
+ */
+
+static int appnic_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	int length;
+	int buf_per_desc;
+	union appnic_queue_pointer queue;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pdata->tx_lock, flags);
+
+	length = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
+
+	/* If enough transmit descriptors are available, copy and transmit. */
+
+	queue = swab_queue_pointer(pdata->tx_tail);
+	while (((length / buf_per_desc) + 1) >=
+		queue_uninitialized(pdata->tx_head,
+				    queue,
+				    pdata->tx_num_desc)) {
+		handle_transmit_interrupt(dev);
+		queue = swab_queue_pointer(pdata->tx_tail);
+	}
+
+	if (((length / buf_per_desc) + 1) <
+		queue_uninitialized(pdata->tx_head, queue,
+				    pdata->tx_num_desc)) {
+		int bytes_copied = 0;
+		struct appnic_dma_descriptor descriptor;
+
+		readdescriptor(((unsigned long)pdata->tx_desc +
+				pdata->tx_head.bits.offset), &descriptor);
+		descriptor.start_of_packet = 1;
+
+		while (bytes_copied < length) {
+			descriptor.write = 1;
+			descriptor.pdu_length = length;
+
+			if ((length - bytes_copied) > buf_per_desc) {
+				memcpy((void *)
+					(descriptor.host_data_memory_pointer +
+					 pdata->dma_alloc_offset_tx),
+				       (void *) ((unsigned long) skb->data +
+					bytes_copied),
+					buf_per_desc);
+				descriptor.data_transfer_length = buf_per_desc;
+				descriptor.end_of_packet = 0;
+				descriptor.interrupt_on_completion = 0;
+				bytes_copied += buf_per_desc;
+			} else {
+				memcpy((void *)
+					(descriptor.host_data_memory_pointer +
+					 pdata->dma_alloc_offset_tx),
+				       (void *) ((unsigned long) skb->data +
+					bytes_copied),
+					(length - bytes_copied));
+				descriptor.data_transfer_length =
+				 (length - bytes_copied);
+				descriptor.end_of_packet = 1;
+				/* Leave TX interrupts disabled. We work
+				 * the same with or w/o them. Set to "1"
+				 * if we ever want to enable them though.
+				 */
+				descriptor.interrupt_on_completion = 0;
+				bytes_copied = length;
+			}
+
+			pdata->stats.tx_bytes += bytes_copied;
+			writedescriptor(((unsigned long) pdata->tx_desc +
+				pdata->tx_head.bits.offset), &descriptor);
+			queue_increment(&pdata->tx_head, pdata->tx_num_desc);
+			readdescriptor(((unsigned long)pdata->tx_desc +
+					 pdata->tx_head.bits.offset),
+					&descriptor);
+			descriptor.start_of_packet = 0;
+		}
+
+		/* Data sync barrier. */
+		rmb();
+
+		write_mac(pdata->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
+		netif_trans_update(dev);
+
+	} else {
+		pdata->out_of_tx_descriptors++;
+		pr_err("%s: No transmit descriptors available!\n",
+		       AXXIA_DRV_NAME);
+		spin_unlock_irqrestore(&pdata->tx_lock, flags);
+		return NETDEV_TX_BUSY;
+	}
+
+	spin_unlock_irqrestore(&pdata->tx_lock, flags);
+	/* Free the socket buffer. */
+	dev_kfree_skb(skb);
+
+	return NETDEV_TX_OK;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_net_device_stats
+ *
+ * Whenever an application needs to get statistics for the interface,
+ * this method is called.  This happens, for example, when ifconfig or
+ * nstat -i is run.
+ */
+
+static struct net_device_stats *appnic_get_stats(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+
+	/* Update the statistics structure. */
+
+	get_hw_statistics(pdata);
+
+	return &pdata->stats;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_set_mac_address
+ */
+
+static int appnic_set_mac_address(struct net_device *dev, void *data)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct sockaddr *address = data;
+	unsigned long swap_source_address;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	if (!is_valid_ether_addr(address->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(dev->dev_addr, address->sa_data, ETH_ALEN);
+	memcpy(dev->perm_addr, address->sa_data, ETH_ALEN);
+
+	swap_source_address = ((address->sa_data[4]) << 8) |
+			       address->sa_data[5];
+	write_mac(swap_source_address, APPNIC_SWAP_SOURCE_ADDRESS_2);
+	swap_source_address = ((address->sa_data[2]) << 8) |
+			address->sa_data[3];
+	write_mac(swap_source_address, APPNIC_SWAP_SOURCE_ADDRESS_1);
+	swap_source_address = ((address->sa_data[0]) << 8) |
+			       address->sa_data[1];
+	write_mac(swap_source_address, APPNIC_SWAP_SOURCE_ADDRESS_0);
+	memcpy(dev->dev_addr, address->sa_data, dev->addr_len);
+
+	return 0;
+}
+
+/* ======================================================================
+ * ETHTOOL Operations
+ * ======================================================================
+ */
+
+enum {NETDEV_STATS, APPNIC_STATS};
+
+struct appnic_stats {
+	char stat_string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int stat_offset;
+};
+
+#define APPNIC_STAT(str, m) { \
+		.stat_string = str, \
+		.sizeof_stat = sizeof(((struct appnic_device *)0)->m), \
+		.stat_offset = offsetof(struct appnic_device, m) }
+
+static const struct appnic_stats appnic_gstrings_stats[] = {
+	APPNIC_STAT("rx_packets", stats.rx_packets),
+	APPNIC_STAT("tx_packets", stats.tx_packets),
+	APPNIC_STAT("rx_bytes", stats.rx_bytes),
+	APPNIC_STAT("tx_bytes", stats.tx_bytes),
+	APPNIC_STAT("rx_errors", stats.rx_errors),
+	APPNIC_STAT("tx_errors", stats.tx_errors),
+	APPNIC_STAT("rx_dropped", stats.rx_dropped),
+	APPNIC_STAT("tx_dropped", stats.tx_dropped),
+	APPNIC_STAT("multicast", stats.multicast),
+	APPNIC_STAT("collisions", stats.collisions),
+	APPNIC_STAT("rx_length_errors", stats.rx_length_errors),
+	APPNIC_STAT("rx_crc_errors", stats.rx_crc_errors),
+	APPNIC_STAT("rx_frame_errors", stats.rx_frame_errors),
+	APPNIC_STAT("rx_fifo_errors", stats.rx_fifo_errors),
+	APPNIC_STAT("tx_fifo_errors", stats.tx_fifo_errors),
+
+	APPNIC_STAT("dropped_by_stack", dropped_by_stack),
+	APPNIC_STAT("out_of_tx_descriptors", out_of_tx_descriptors),
+	APPNIC_STAT("transmit_interrupts", transmit_interrupts),
+	APPNIC_STAT("receive_interrupts", receive_interrupts),
+};
+
+#define APPNIC_GLOBAL_STATS_LEN  ARRAY_SIZE(appnic_gstrings_stats)
+#define APPNIC_STATS_LEN (APPNIC_GLOBAL_STATS_LEN)
+
+/* ----------------------------------------------------------------------
+ * appnic_get_ethtool_stats
+ */
+
+static void appnic_get_ethtool_stats(struct net_device *dev,
+				     struct ethtool_stats *stats,
+				     u64 *data)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	int i;
+	char *p = NULL;
+
+	get_hw_statistics(pdata);
+	for (i = 0; i < APPNIC_GLOBAL_STATS_LEN; i++) {
+		p = (char *) pdata + appnic_gstrings_stats[i].stat_offset;
+		data[i] = (appnic_gstrings_stats[i].sizeof_stat ==
+			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_get_strings
+ */
+
+static void appnic_get_strings(struct net_device *netdev, u32 stringset,
+			       u8 *data)
+{
+	u8 *p = data;
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < APPNIC_GLOBAL_STATS_LEN; i++) {
+			memcpy(p, appnic_gstrings_stats[i].stat_string,
+			       ETH_GSTRING_LEN);
+			p += ETH_GSTRING_LEN;
+		}
+		break;
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_get_sset_count
+ */
+
+static int appnic_get_sset_count(struct net_device *netdev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return APPNIC_STATS_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_get_drvinfo
+ */
+
+static void appnic_get_drvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, AXXIA_DRV_NAME);
+	strcpy(info->version, AXXIA_DRV_VERSION);
+	strlcpy(info->bus_info, dev_name(dev->dev.parent),
+		sizeof(info->bus_info));
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_get_settings
+ */
+
+static int appnic_get_settings(struct net_device *dev,
+			       struct ethtool_cmd *cmd)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct phy_device *phydev = pdata->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+/* Fill in the struture...  */
+
+static const struct ethtool_ops appnic_ethtool_ops = {
+	.get_drvinfo		= appnic_get_drvinfo,
+	.get_settings		= appnic_get_settings,
+	.get_ethtool_stats	= appnic_get_ethtool_stats,
+	.get_strings		= appnic_get_strings,
+	.get_sset_count		= appnic_get_sset_count,
+};
+
+/* ======================================================================
+ * Linux Module Interface.
+ * ======================================================================
+ */
+
+static const struct net_device_ops appnic_netdev_ops = {
+	.ndo_open = appnic_open,
+	.ndo_stop = appnic_stop,
+	.ndo_get_stats = appnic_get_stats,
+	.ndo_set_mac_address = appnic_set_mac_address,
+	.ndo_start_xmit = appnic_hard_start_xmit,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = appnic_poll_controller,
+#endif
+
+};
+
+/* ----------------------------------------------------------------------
+ * appnic_init
+ */
+
+int appnic_init(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	void *dma_offset;
+	int index;
+	unsigned long buf;
+	struct appnic_dma_descriptor descriptor;
+	struct sockaddr address;
+	unsigned long node_cfg;
+	int rc = 0;
+
+	/* Set FEMAC to uncached */
+	femac_uncache(pdata);
+
+	/* Reset the MAC. */
+
+	write_mac(0x80000000, APPNIC_DMA_PCI_CONTROL);
+
+	/* Allocate memory and initialize the descriptors. */
+
+	/* fixup num_[rt]x_desc. */
+
+	if (0 != (rx_num_desc % DESCRIPTOR_GRANULARITY)) {
+		pr_err("%s: rx_num_desc was not a multiple of %d.\n",
+		       AXXIA_DRV_NAME, DESCRIPTOR_GRANULARITY);
+		rc = -EINVAL;
+		goto err_param;
+	}
+
+	pdata->rx_num_desc = rx_num_desc;
+
+	if (0 != (tx_num_desc % DESCRIPTOR_GRANULARITY)) {
+		pr_err("%s: tx_num_desc was not a multiple of %d.\n",
+		       AXXIA_DRV_NAME, DESCRIPTOR_GRANULARITY);
+		rc = -EINVAL;
+		goto err_param;
+	}
+
+	pdata->tx_num_desc = tx_num_desc;
+
+	/* up [rt]x_buf_sz. Must be some multiple of 64 bytes
+	 * per descriptor.
+	 */
+
+	if (0 != (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc))) {
+		pr_err("%s: rx_buf_sz was not a multiple of %d.\n",
+		       AXXIA_DRV_NAME, (BUFFER_ALIGNMENT * rx_num_desc));
+		rc = -EINVAL;
+		goto err_param;
+	}
+
+	pdata->rx_buf_sz = rx_buf_sz;
+
+	if (0 != (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc))) {
+		pr_err("%s: tx_buf_sz was not a multiple of %d.\n",
+		       AXXIA_DRV_NAME, (BUFFER_ALIGNMENT * tx_num_desc));
+		rc = -EINVAL;
+		goto err_param;
+	}
+
+	pdata->tx_buf_sz = tx_buf_sz;
+
+	/* Allocate dma-able memory. Broken into smaller parts to keep
+	 * from allocating a single large chunk of memory, but not too
+	 * small since mappings obtained from dma_alloc_coherent() have
+	 * a minimum size of one page.
+	 */
+
+	pdata->dma_alloc_size =
+		/* The tail pointers (rx and tx) */
+		(sizeof(union appnic_queue_pointer) * 2) +
+		/* The RX descriptor ring (and padding to allow
+		 * 64 byte alignment)
+		 */
+		(sizeof(struct appnic_dma_descriptor) * pdata->rx_num_desc) +
+		(DESCRIPTOR_GRANULARITY) +
+		/* The TX descriptor ring (and padding...) */
+		(sizeof(struct appnic_dma_descriptor) * pdata->tx_num_desc) +
+		(DESCRIPTOR_GRANULARITY);
+
+	pdata->dma_alloc_size_rx =
+		/* The RX buffer (and padding...) */
+		(pdata->rx_buf_sz) + (BUFFER_ALIGNMENT);
+
+	pdata->dma_alloc_size_tx =
+		/* The TX buffer (and padding...) */
+		(pdata->tx_buf_sz) + (BUFFER_ALIGNMENT);
+
+	/* Allocate the buffers. */
+
+	rc = femac_alloc_mem_buffers(dev);
+	if (rc != 0) {
+		pr_err("%s: Can't allocate DMA-able memory!\n", AXXIA_DRV_NAME);
+		goto err_mem_buffers;
+	}
+
+	/* Initialize the tail pointers. */
+
+	dma_offset = pdata->dma_alloc;
+
+	pdata->rx_tail = (union appnic_queue_pointer *)dma_offset;
+	pdata->rx_tail_dma = (int)pdata->rx_tail - (int)pdata->dma_alloc_offset;
+	dma_offset += sizeof(union appnic_queue_pointer);
+	memset((void *)pdata->rx_tail, 0,
+	       sizeof(union appnic_queue_pointer));
+
+	pdata->tx_tail = (union appnic_queue_pointer *)dma_offset;
+	pdata->tx_tail_dma = (int)pdata->tx_tail - (int)pdata->dma_alloc_offset;
+	dma_offset += sizeof(union appnic_queue_pointer);
+	memset((void *)pdata->tx_tail, 0, sizeof(union appnic_queue_pointer));
+
+	/* Initialize the descriptor pointers. */
+
+	pdata->rx_desc = (struct appnic_dma_descriptor *)ALIGN64B(dma_offset);
+	pdata->rx_desc_dma = (int)pdata->rx_desc - (int)pdata->dma_alloc_offset;
+	dma_offset += (sizeof(struct appnic_dma_descriptor) *
+			pdata->rx_num_desc) + (DESCRIPTOR_GRANULARITY);
+	memset((void *)pdata->rx_desc, 0,
+	       (sizeof(struct appnic_dma_descriptor) * pdata->rx_num_desc));
+
+	pdata->tx_desc = (struct appnic_dma_descriptor *)ALIGN64B(dma_offset);
+	pdata->tx_desc_dma = (int)pdata->tx_desc - (int)pdata->dma_alloc_offset;
+	dma_offset += (sizeof(struct appnic_dma_descriptor) *
+			pdata->tx_num_desc) + (DESCRIPTOR_GRANULARITY);
+	memset((void *)pdata->tx_desc, 0,
+	       (sizeof(struct appnic_dma_descriptor) * pdata->tx_num_desc));
+
+	/* Initialize the buffer pointers. */
+
+	dma_offset = pdata->dma_alloc_rx;
+
+	pdata->rx_buf = (void *)ALIGN64B(dma_offset);
+	pdata->rx_buf_dma = (int)pdata->rx_buf -
+				(int)pdata->dma_alloc_offset_rx;
+	pdata->rx_buf_per_desc = pdata->rx_buf_sz / pdata->rx_num_desc;
+
+	dma_offset = pdata->dma_alloc_tx;
+
+	pdata->tx_buf = (void *)ALIGN64B(dma_offset);
+	pdata->tx_buf_dma = (int)pdata->tx_buf -
+				(int)pdata->dma_alloc_offset_tx;
+	pdata->tx_buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
+
+	/* Initialize the descriptors. */
+
+	buf = (unsigned long)pdata->rx_buf_dma;
+	for (index = 0; index < pdata->rx_num_desc; ++index) {
+		memset((void *) &descriptor, 0,
+		       sizeof(struct appnic_dma_descriptor));
+		descriptor.write = 1;
+		descriptor.interrupt_on_completion = 1;
+		descriptor.host_data_memory_pointer = buf;
+		descriptor.data_transfer_length = pdata->rx_buf_per_desc;
+
+		writedescriptor(((unsigned long)pdata->rx_desc + (index *
+				sizeof(struct appnic_dma_descriptor))),
+				&descriptor);
+
+		buf += pdata->rx_buf_per_desc;
+	}
+
+	buf = (unsigned long)pdata->tx_buf_dma;
+
+	for (index = 0; index < pdata->tx_num_desc; ++index) {
+		memset((void *) &descriptor, 0,
+		       sizeof(struct appnic_dma_descriptor));
+		descriptor.write = 1;
+		descriptor.interrupt_on_completion = 1;
+		descriptor.host_data_memory_pointer = buf;
+
+		writedescriptor(((unsigned long)pdata->tx_desc + (index *
+				 sizeof(struct appnic_dma_descriptor))),
+				&descriptor);
+
+		buf += pdata->tx_buf_per_desc;
+	}
+
+	/* Initialize the spinlocks. */
+
+	spin_lock_init(&pdata->dev_lock);
+	spin_lock_init(&pdata->tx_lock);
+
+	/* Take MAC out of reset. */
+
+	write_mac(0x0, APPNIC_RX_SOFT_RESET);
+	write_mac(0x1, APPNIC_RX_MODE);
+	write_mac(0x0, APPNIC_TX_SOFT_RESET);
+	write_mac(0x1, APPNIC_TX_MODE);
+
+	/* Set the watermark. */
+
+	ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &node_cfg);
+
+	if (0 == (0x80000000 & node_cfg))
+		write_mac(0x300a, APPNIC_TX_WATERMARK);
+	else
+		write_mac(0xc00096, APPNIC_TX_WATERMARK);
+
+	write_mac(0x1, APPNIC_TX_HALF_DUPLEX_CONF);
+	write_mac(0xffff, APPNIC_TX_TIME_VALUE_CONF);
+	write_mac(0x1, APPNIC_TX_INTERRUPT_CONTROL);
+	write_mac(0x5275, APPNIC_TX_EXTENDED_CONF);
+	write_mac(0x1, APPNIC_RX_INTERNAL_INTERRUPT_CONTROL);
+	write_mac(0x1, APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL);
+	write_mac(0x40010000, APPNIC_DMA_PCI_CONTROL);
+	write_mac(0x30000, APPNIC_DMA_CONTROL);
+#ifdef CONFIG_ARM
+	writel(0x280044,
+	       (void __iomem *)((unsigned long)pdata->dma_base + 0x60));
+	writel(0xc0,
+	       (void __iomem *)((unsigned long)pdata->dma_base + 0x64));
+#else
+	out_le32((unsigned *)pdata->dma_base + 0x60, 0x280044);
+	out_le32((unsigned *)pdata->dma_base + 0x64, 0xc0);
+#endif
+
+	/* Set the MAC address. */
+	pr_info("%s: MAC %pM\n", AXXIA_DRV_NAME, dev->dev_addr);
+
+	memcpy(&(address.sa_data[0]), dev->dev_addr, ETH_ALEN);
+	rc = appnic_set_mac_address(dev, &address);
+	if (rc != 0) {
+		pr_err("%s: Unable to set MAC address!\n", AXXIA_DRV_NAME);
+		goto err_set_mac_addr;
+	}
+
+	/* Initialize the queue pointers. */
+
+	/* Receiver. */
+
+	memset((void *)&pdata->rx_tail_copy, 0,
+	       sizeof(union appnic_queue_pointer));
+	memset((void *)&pdata->rx_head, 0,
+	       sizeof(union appnic_queue_pointer));
+
+	write_mac(pdata->rx_desc_dma, APPNIC_DMA_RX_QUEUE_BASE_ADDRESS);
+	write_mac((pdata->rx_num_desc *
+		   sizeof(struct appnic_dma_descriptor)) / 1024,
+		  APPNIC_DMA_RX_QUEUE_SIZE);
+
+	/* Indicate that all of the receive descriptors
+	 * are ready.
+	 */
+
+	pdata->rx_head.bits.offset = (pdata->rx_num_desc - 1) *
+					sizeof(struct appnic_dma_descriptor);
+	write_mac(pdata->rx_tail_dma, APPNIC_DMA_RX_TAIL_POINTER_ADDRESS);
+
+	/* N.B.
+	 *
+	 * The boot loader may have used the NIC.  If so, the
+	 * tail pointer must be read and the head pointer (and
+	 * local copy of the tail) based on it.
+	 */
+
+	pdata->rx_tail->raw =
+		  read_mac(APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY);
+	pdata->rx_tail_copy.raw = pdata->rx_tail->raw;
+	pdata->rx_head.raw = pdata->rx_tail->raw;
+	queue_decrement(&pdata->rx_head, pdata->rx_num_desc);
+	pdata->rx_head.bits.generation_bit =
+		  (0 == pdata->rx_head.bits.generation_bit) ? 1 : 0;
+	write_mac(pdata->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
+
+	/* Transmitter. */
+
+	memset((void *) &pdata->tx_tail_copy, 0,
+	       sizeof(union appnic_queue_pointer));
+	memset((void *) &pdata->tx_head, 0,
+	       sizeof(union appnic_queue_pointer));
+
+	write_mac(pdata->tx_desc_dma, APPNIC_DMA_TX_QUEUE_BASE_ADDRESS);
+	write_mac((pdata->tx_num_desc *
+		   sizeof(struct appnic_dma_descriptor)) / 1024,
+		  APPNIC_DMA_TX_QUEUE_SIZE);
+	write_mac(pdata->tx_tail_dma, APPNIC_DMA_TX_TAIL_POINTER_ADDRESS);
+
+	/* N.B.
+	 *
+	 * The boot loader may have used the NIC.  If so, the
+	 * tail pointer must be read and the head pointer (and
+	 * local copy of the tail) based on it.
+	 */
+
+	pdata->tx_tail->raw = read_mac(APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY);
+	pdata->tx_tail_copy.raw = pdata->tx_tail->raw;
+	pdata->tx_head.raw = pdata->tx_tail->raw;
+	write_mac(pdata->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
+
+	/* Clear statistics. */
+
+	clear_statistics(pdata);
+
+	/* Fill in the net_device structure. */
+
+	ether_setup(dev);
+
+	/* Setup IRQ. */
+	rc = femac_irq_setup(dev);
+	if (rc != 0) {
+		pr_err("%s: IRQ setup failed!\n", AXXIA_DRV_NAME);
+		goto err_irq_setup;
+	}
+
+	dev->netdev_ops = &appnic_netdev_ops;
+	dev->ethtool_ops = &appnic_ethtool_ops;
+	dev->features |= NETIF_F_LLTX;
+
+	memset((void *) &pdata->napi, 0, sizeof(struct napi_struct));
+	netif_napi_add(dev, &pdata->napi,
+		       axxianet_poll, AXXIANET_NAPI_WEIGHT);
+	pdata->device = dev;
+
+	return 0;
+
+err_irq_setup:
+err_set_mac_addr:
+	femac_free_mem_buffers(dev);
+err_mem_buffers:
+err_param:
+	return rc;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_probe_config_dt
+ */
+
+#ifdef CONFIG_OF
+static int appnic_probe_config_dt(struct net_device *dev,
+				  struct device_node *np)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	const u32 *field;
+	const char *mac;
+	const char *macspeed;
+#ifdef CONFIG_ARM
+	struct device_node *gp_node;
+#else
+	u64 value64;
+	u32 value32;
+#endif
+
+	if (!np)
+		return -ENODEV;
+
+#ifdef CONFIG_ARM
+	gp_node = of_find_compatible_node(NULL, NULL, "axxia,gpreg");
+	if (!gp_node) {
+		pr_err("%s: DTS is missing mode 'gpreg'\n", AXXIA_DRV_NAME);
+		return -ENODEV;
+	}
+	pdata->gpreg_base = of_iomap(gp_node, 0);
+
+	pdata->rx_base = of_iomap(np, 0);
+	pdata->tx_base = of_iomap(np, 1);
+	pdata->dma_base = of_iomap(np, 2);
+
+	pdata->tx_interrupt = irq_of_parse_and_map(np, 0);
+	pdata->rx_interrupt = irq_of_parse_and_map(np, 1);
+	pdata->dma_interrupt = irq_of_parse_and_map(np, 2);
+#else
+	field = of_get_property(np, "enabled", NULL);
+
+	if (!field || (field && (0 == *field)))
+		goto device_tree_failed;
+
+	field = of_get_property(np, "reg", NULL);
+
+	if (!field)
+		goto device_tree_failed;
+
+	value64 = of_translate_address(np, field);
+	value32 = field[3];
+	field += 2;
+	pdata->rx_base = ioremap(value64, value32);
+	value64 = of_translate_address(np, field);
+	value32 = field[3];
+	field += 2;
+	pdata->tx_base = ioremap(value64, value32);
+	value64 = of_translate_address(np, field);
+	value32 = field[3];
+	field += 2;
+	pdata->dma_base = ioremap(value64, value32);
+
+	field = of_get_property(np, "interrupts", NULL);
+	if (!field)
+		goto device_tree_failed;
+	else
+		pdata->dma_interrupt = field[0];
+#endif
+
+	field = of_get_property(np, "mdio-clock", NULL);
+	if (!field)
+		goto device_tree_failed;
+	else
+		pdata->mdio_clock = ntohl(field[0]);
+
+	field = of_get_property(np, "phy-address", NULL);
+	if (!field)
+		goto device_tree_failed;
+	else
+		pdata->phy_address = ntohl(field[0]);
+
+	field = of_get_property(np, "ad-value", NULL);
+	if (!field)
+		goto device_tree_failed;
+	else
+		pdata->ad_value = ntohl(field[0]);
+
+	macspeed = of_get_property(np, "phy-link", NULL);
+
+	if (macspeed) {
+		if (0 == strncmp(macspeed, "auto", strlen("auto"))) {
+			pdata->phy_link_auto = 1;
+		} else if (0 == strncmp(macspeed, "100MF", strlen("100MF"))) {
+			pdata->phy_link_auto = 0;
+			pdata->phy_link_speed = 1;
+			pdata->phy_link_duplex = 1;
+		} else if (0 == strncmp(macspeed, "100MH", strlen("100MH"))) {
+			pdata->phy_link_auto = 0;
+			pdata->phy_link_speed = 1;
+			pdata->phy_link_duplex = 0;
+		} else if (0 == strncmp(macspeed, "10MF", strlen("10MF"))) {
+			pdata->phy_link_auto = 0;
+			pdata->phy_link_speed = 0;
+			pdata->phy_link_duplex = 1;
+		} else if (0 == strncmp(macspeed, "10MH", strlen("10MH"))) {
+			pdata->phy_link_auto = 0;
+			pdata->phy_link_speed = 0;
+			pdata->phy_link_duplex = 0;
+		} else {
+			pr_err("Invalid phy-link value \"%s\" in DTS. Defaulting to \"auto\".\n", macspeed);
+			pdata->phy_link_auto = 1;
+		}
+	} else {
+		/* Auto is the default. */
+		pdata->phy_link_auto = 1;
+	}
+
+	mac = of_get_mac_address(np);
+	if (!mac)
+		goto device_tree_failed;
+
+	memcpy(&pdata->mac_addr[0], mac, ETH_ALEN);
+	memcpy(dev->dev_addr, mac, ETH_ALEN);
+	memcpy(dev->perm_addr, mac, ETH_ALEN);
+
+	return 0;
+
+device_tree_failed:
+	pr_err("%s: Reading Device Tree Failed\n", AXXIA_DRV_NAME);
+#ifdef CONFIG_ARM
+	iounmap(pdata->gpreg_base);
+#endif
+	iounmap(pdata->rx_base);
+	iounmap(pdata->tx_base);
+	iounmap(pdata->dma_base);
+
+	return -EINVAL;
+}
+#else
+static inline int appnic_probe_config_dt(struct net_device *dev,
+					 struct device_node *np)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_OF */
+
+/* ----------------------------------------------------------------------
+ * appnic_drv_probe
+ */
+
+static int appnic_drv_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	struct device_node *np = pdev->dev.of_node;
+	struct net_device *dev;
+	struct appnic_device *pdata;
+
+	pr_info("%s: INTEL(R) 10/100 Network Driver - version %s\n",
+		AXXIA_DRV_NAME, AXXIA_DRV_VERSION);
+
+	/* Allocate space for the device. */
+
+	dev = alloc_etherdev(sizeof(struct appnic_device));
+	if (!dev) {
+		pr_err("%s: Couldn't allocate net device.\n", AXXIA_DRV_NAME);
+		rc = -ENOMEM;
+		goto err_alloc_etherdev;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	platform_set_drvdata(pdev, dev);
+
+	pdata = netdev_priv(dev);
+
+	/* Get the physical addresses, interrupt number, etc. from the
+	 * device tree.  If no entry exists (older boot loader...) just
+	 * use the pre-devicetree method.
+	 */
+
+	rc = appnic_probe_config_dt(dev, np);
+
+	if (rc == -EINVAL) {
+		goto err_inval;
+	} else if (rc == -EINVAL) {
+#ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
+
+		/* The attempt to get device settings from the DTB failed, so
+		 * try to grab the ethernet MAC from the u-boot environment
+		 * and use hard-coded values for device base addresses.
+		 */
+
+		unsigned char ethaddr_string[20];
+
+		if (0 != ubootenv_get("ethaddr", ethaddr_string)) {
+			pr_err("%s: Could not read ethernet address!\n",
+			       AXXIA_DRV_NAME);
+			rc = -EINVAL;
+			goto err_inval;
+		} else {
+			u8 mac_address[ETH_ALEN];
+			int i = 0;
+			char *string = ethaddr_string;
+
+			while ((0 != string) && (ETH_ALEN > i)) {
+				char *value;
+				unsigned long res;
+
+				value = strsep(&string, ":");
+				if (kstrtoul(value, 16, &res))
+					return -EBUSY;
+				mac_address[i++] = (u8)res;
+			}
+
+			memcpy(dev->dev_addr, mac_address, ETH_ALEN);
+			memcpy(dev->perm_addr, mac_address, ETH_ALEN);
+			dev->addr_len = ETH_ALEN;
+
+			pr_info("%s: Using Static Addresses and Interrupts",
+				AXXIA_DRV_NAME);
+			pdata->rx_base = ioremap(0x002000480000ULL, 0x1000);
+			pdata->tx_base = ioremap(0x002000481000ULL, 0x1000);
+			pdata->dma_base = ioremap(0x002000482000ULL, 0x1000);
+			pdata->dma_interrupt = 33;
+		}
+#else
+		/* Neither dtb info nor ubootenv driver found. */
+		pr_err("%s: Could not read ethernet address!", AXXIA_DRV_NAME);
+		rc = -EINVAL;
+		goto err_inval;
+#endif
+	}
+
+#ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
+
+	{
+		unsigned char uboot_env_string[20];
+
+		/* Override ad_value with u-boot environment variable if set. */
+		if (0 == ubootenv_get("ad_value", uboot_env_string)) {
+			/* Assume ad_value is always entered as a hex value,
+			 * since u-boot defaults this value as hex.
+			 */
+			unsigned long res;
+
+			if (kstrtoul(uboot_env_string, 16, &res)) {
+				rc = -EINVAL;
+				goto err_inval;
+			}
+			pdata->ad_value = res;
+		}
+	}
+
+#endif
+
+	/* Initialize the device. */
+	rc = appnic_init(dev);
+	if (0 != rc) {
+		pr_err("%s: appnic_init() failed: %d\n", AXXIA_DRV_NAME, rc);
+		rc = -ENODEV;
+		goto err_nodev;
+	}
+
+	/* Register the device. */
+	rc = register_netdev(dev);
+	if (0 != rc) {
+		pr_err("%s: register_netdev() failed: %d\n", AXXIA_DRV_NAME, rc);
+		rc = -ENODEV;
+		goto err_nodev;
+	}
+
+	/* Initialize the PHY. */
+	rc = appnic_mii_init(pdev, dev);
+	if (rc) {
+		pr_warn("%s: Failed to initialize PHY", AXXIA_DRV_NAME);
+		rc = -ENODEV;
+		goto err_mii_init;
+	}
+
+	return 0;
+
+err_mii_init:
+	unregister_netdev(dev);
+err_nodev:
+err_inval:
+	free_netdev(dev);
+err_alloc_etherdev:
+	return rc;
+}
+
+/* ----------------------------------------------------------------------
+ * appnic_drv_remove
+ */
+
+static int appnic_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct appnic_device *pdata = NULL;
+
+	pr_info("%s: Stopping driver", AXXIA_DRV_NAME);
+
+	BUG_ON(!dev);
+	pdata = netdev_priv(dev);
+	BUG_ON(!pdata);
+	BUG_ON(!pdata->phy_dev);
+	phy_disconnect(pdata->phy_dev);
+	pdata->phy_dev = NULL;
+	mdiobus_unregister(pdata->mii_bus);
+	mdiobus_free(pdata->mii_bus);
+	platform_set_drvdata(pdev, NULL);
+	unregister_netdev(dev);
+	free_irq(dev->irq, dev);
+	femac_free_mem_buffers(dev);
+	free_netdev(dev);
+
+	iounmap(pdata->rx_base);
+	iounmap(pdata->tx_base);
+	iounmap(pdata->dma_base);
+#ifdef CONFIG_ARM
+	iounmap(pdata->gpreg_base);
+#endif
+
+	return 0;
+}
+
+static const struct of_device_id appnic_dt_ids[] = {
+	{ .compatible = "axxia,acp-femac", },
+	{ .compatible = "acp-femac", },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, appnic_dt_ids);
+
+static struct platform_driver appnic_driver = {
+	.probe = appnic_drv_probe,
+	.remove = appnic_drv_remove,
+	.driver = {
+		.name   = AXXIA_DRV_NAME,
+		.owner  = THIS_MODULE,
+		.pm     = NULL,
+		.of_match_table = appnic_dt_ids,
+	},
+};
+
+module_platform_driver(appnic_driver);
diff --git a/drivers/net/ethernet/axxia/axxia_acp_net.h b/drivers/net/ethernet/axxia/axxia_acp_net.h
new file mode 100644
index 0000000..f12f19b
--- /dev/null
+++ b/drivers/net/ethernet/axxia/axxia_acp_net.h
@@ -0,0 +1,669 @@
+/*
+ * drivers/net/ethernet/axxia/axxia_acp_net.h
+ *
+ * Copyright (C) 2013 INTEL Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#ifndef _AXXIA_ACP_NET_H
+#define _AXXIA_ACP_NET_H
+
+#ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
+extern int ubootenv_get(const char *, char *);
+#endif
+
+extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
+extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
+
+/* This is the maximum number of packets to be received every
+ * NAPI poll
+ */
+#define AXXIANET_NAPI_WEIGHT	64
+
+/* This is the maximum number of bytes that serve to hold
+ * incoming Rx data.
+ */
+#define AXXIANET_MAX_MTU		(ETH_DATA_LEN + 100) /* MTU + padding */
+
+/* Device Data Structures */
+
+struct appnic_dma_descriptor {
+
+#ifdef __LITTLE_ENDIAN
+	/* Word 0 */
+	/* 00=Fill|01=Block|10=Scatter */
+	unsigned long transfer_type:2;
+	unsigned long write:1;
+	unsigned long start_of_packet:1;
+	unsigned long end_of_packet:1;
+	unsigned long interrupt_on_completion:1;
+	unsigned long error:1;
+	/* big endian to little endian */
+	unsigned long byte_swapping_on:1;
+	unsigned long unused:24;
+
+	/* Word 1 */
+	unsigned long data_transfer_length:16;
+	unsigned long pdu_length:16;
+
+	/* Word 2 */
+	unsigned long target_memory_address;
+
+	/* Word 3 */
+	unsigned long host_data_memory_pointer;
+#else
+	/* Word 0 */
+	unsigned long unused:24;
+	/* big endian to little endian */
+	unsigned long byte_swapping_on:1;
+	unsigned long error:1;
+	unsigned long interrupt_on_completion:1;
+	unsigned long end_of_packet:1;
+	unsigned long start_of_packet:1;
+	unsigned long write:1;
+	/* 00=Fill|01=Block|10=Scatter */
+	unsigned long transfer_type:2;
+
+	/* Word 1 */
+	unsigned long pdu_length:16;
+	unsigned long data_transfer_length:16;
+
+	/* Word 2 */
+	unsigned long target_memory_address;
+
+	/* Word 3 */
+	unsigned long host_data_memory_pointer;
+#endif
+
+} __packed;
+
+union appnic_queue_pointer {
+
+	unsigned long raw;
+
+	struct {
+#ifdef __LITTLE_ENDIAN
+		unsigned long offset:20;
+		unsigned long generation_bit:1;
+		unsigned long unused:11;
+#else
+		unsigned long unused:11;
+		unsigned long generation_bit:1;
+		unsigned long offset:20;
+#endif
+	} __packed bits;
+
+} __packed;
+
+/* The appnic Device Structure */
+
+struct appnic_device {
+
+	/* net_device */
+	struct net_device *device;
+
+	/* Addresses, Interrupt, and PHY stuff. */
+	void __iomem *rx_base;
+	void __iomem *tx_base;
+	void __iomem *dma_base;
+#ifdef CONFIG_ARM
+	void __iomem *gpreg_base;
+#endif
+	unsigned long tx_interrupt;
+	unsigned long rx_interrupt;
+	unsigned long dma_interrupt;
+	unsigned long mdio_clock;
+	unsigned long phy_address;
+	unsigned long ad_value;
+	unsigned long phy_link_auto;
+	unsigned long phy_link_speed;
+	unsigned long phy_link_duplex;
+	unsigned char mac_addr[6];
+
+	/* NAPI */
+	struct napi_struct napi;
+
+	/* Statistics */
+	struct net_device_stats stats;
+	unsigned long dropped_by_stack;
+	unsigned long out_of_tx_descriptors;
+	unsigned long transmit_interrupts;
+	unsigned long receive_interrupts;
+
+	/* DMA-able memory */
+	int dma_alloc_size;
+	int dma_alloc_size_rx;
+	int dma_alloc_size_tx;
+	void *dma_alloc;
+	void *dma_alloc_rx;
+	void *dma_alloc_tx;
+	dma_addr_t dma_alloc_dma;
+	dma_addr_t dma_alloc_dma_rx;
+	dma_addr_t dma_alloc_dma_tx;
+	int dma_alloc_offset;
+	int dma_alloc_offset_rx;
+	int dma_alloc_offset_tx;
+
+	/* tail pointers */
+	volatile union appnic_queue_pointer *rx_tail;
+	dma_addr_t rx_tail_dma;
+	volatile union appnic_queue_pointer *tx_tail;
+	dma_addr_t tx_tail_dma;
+
+	/* descriptors */
+	struct appnic_dma_descriptor *rx_desc;
+	dma_addr_t rx_desc_dma;
+	unsigned rx_num_desc;
+	struct appnic_dma_descriptor *tx_desc;
+	dma_addr_t tx_desc_dma;
+	unsigned tx_num_desc;
+
+	/* buffers */
+	unsigned rx_buf_sz;
+	unsigned rx_buf_per_desc;
+	void *rx_buf;
+	dma_addr_t rx_buf_dma;
+	unsigned tx_buf_sz;
+	unsigned tx_buf_per_desc;
+	void *tx_buf;
+	dma_addr_t tx_buf_dma;
+
+	/* The local pointers */
+	union appnic_queue_pointer rx_tail_copy;
+	union appnic_queue_pointer rx_head;
+	union appnic_queue_pointer tx_tail_copy;
+	union appnic_queue_pointer tx_head;
+
+	/* Spin Lock */
+	spinlock_t dev_lock;
+	spinlock_t tx_lock;
+
+	/* PHY */
+	struct mii_bus *mii_bus;
+	struct phy_device *phy_dev;
+	int phy_irq[PHY_MAX_ADDR];
+	unsigned int link;
+	unsigned int speed;
+	unsigned int duplex;
+};
+
+/* GPREG FEMAC HPROT Register --------------------------------------- */
+
+#define GPREG_HPROT_FEMAC	((unsigned long)pdata->gpreg_base + 0x78)
+
+/* Overview
+ * --------
+ *
+ * Register offset decoding is as follows:
+ *
+ * Bit(s) Description
+ *
+ * 16:15  define the Channel.  There is only one; therefore, 00.
+ * 14:12  define the MAC within the channel.  Only one so 000.
+ * 11:10  define the register "space" as follows:
+ * 00 = fast ethernet MACmw.l 06000000 ffffffff 3200000
+ * 10 = global
+ * 11 = interrupt
+ * 9: 2  register
+ * 1: 0  always 00, 32 bit registers only.
+ *
+ * Receive registers start at the base address.  Transmit registers start
+ * at 0x20000 above the base address.  DMA start at a completely different
+ * base address (in this case 0x8000000 above the base).
+ *
+*/
+
+/* Receive Configuration -------------------------------------------- */
+
+#define APPNIC_RX_CONF		((unsigned long)pdata->rx_base + 0x004c)
+#define APPNIC_RX_CONF_ENABLE   0x0001
+/* Pass Any Packet */
+#define APPNIC_RX_CONF_PAP	0x0002
+#define APPNIC_RX_CONF_JUMBO9K  0x0008
+#define APPNIC_RX_CONF_STRIPCRC 0x0010
+/* Accept All MAC Types */
+#define APPNIC_RX_CONF_AMT	0x0020
+/* Accept Flow Control */
+#define APPNIC_RX_CONF_AFC	0x0040
+/* Enable VLAN */
+#define APPNIC_RX_CONF_VLAN	0x0200
+/* RX MAC Speed, 1=100MBS */
+#define APPNIC_RX_CONF_SPEED    0x0800
+/* 1=Duplex Mode */
+#define APPNIC_RX_CONF_DUPLEX   0x1000
+/* 1=Enable */
+#define APPNIC_RX_CONF_LINK	0x2000
+/* Determines the action taken when the FE MAC
+ * receives an Flow Control packet in FD mode.
+ */
+#define APPNIC_RX_CONF_RXFCE    0x4000
+
+/* Controls the insertion of Flow Control packets
+ * by the MAC transmitter.
+ */
+#define APPNIC_RX_CONF_TXFCE    0x8000
+
+/* Receive Stat Overflow -------------------------------------------- */
+
+#define APPNIC_RX_STAT_OVERFLOW ((unsigned long)pdata->rx_base + 0x278)
+
+/* Receive Stat Undersize ------------------------------------------- */
+
+#define APPNIC_RX_STAT_UNDERSIZE ((unsigned long)pdata->rx_base + 0x280)
+
+/* Receive Stat Oversize -------------------------------------------- */
+
+#define APPNIC_RX_STAT_OVERSIZE ((unsigned long)pdata->rx_base + 0x2b8)
+
+/* Receive Stat Multicast ------------------------------------------- */
+
+#define APPNIC_RX_STAT_MULTICAST ((unsigned long)pdata->rx_base + 0x2d0)
+
+/* Receive Stat Packet OK ------------------------------------------- */
+
+#define APPNIC_RX_STAT_PACKET_OK ((unsigned long)pdata->rx_base + 0x2c0)
+
+/* Receive Stat CRC Error ------------------------------------------- */
+
+#define APPNIC_RX_STAT_CRC_ERROR ((unsigned long)pdata->rx_base + 0x2c8)
+
+/* Receive Stat Align Error ----------------------------------------- */
+
+#define APPNIC_RX_STAT_ALIGN_ERROR ((unsigned long)pdata->rx_base + 0x2e8)
+
+/* Receive Ethernet Mode -------------------------------------------- */
+
+#define APPNIC_RX_MODE ((unsigned long)pdata->rx_base + 0x0800)
+#define APPNIC_RX_MODE_ETHERNET_MODE_ENABLE 0x00001
+
+/* Receive Soft Reset ----------------------------------------------- */
+
+#define APPNIC_RX_SOFT_RESET ((unsigned long)pdata->rx_base + 0x0808)
+#define APPNIC_RX_SOFT_RESET_MAC_0 0x00001
+
+/* Receive Internal Interrupt Control ------------------------------- */
+
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL \
+	((unsigned long)pdata->rx_base + 0xc00)
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive External Interrupt Control ------------------------------- */
+
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL \
+	((unsigned long)pdata->rx_base + 0xc04)
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0_HIGH_LOW 0x10
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive Interrupt Status ----------------------------------------- */
+
+#define APPNIC_RX_INTERRUPT_STATUS ((unsigned long)pdata->rx_base + 0xc20)
+#define APPNIC_RX_INTERRUPT_EXTERNAL_STATUS_MAC_0 0x10
+#define APPNIC_RX_INTERRUPT_INTERNAL_STATUS_MAC_0 0x1
+
+/* Transmit Watermark ----------------------------------------------- */
+
+#define APPNIC_TX_WATERMARK ((unsigned long)pdata->tx_base + 0x18)
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_ASSERT 0x8000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_DISABLE 0x4000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_HIGH 0x3f00
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_LOW 0x3f
+
+/* Swap Source Address Registers ------------------------------------ */
+
+#define APPNIC_SWAP_SOURCE_ADDRESS_2 ((unsigned long)pdata->tx_base + 0x20)
+#define APPNIC_SWAP_SOURCE_ADDRESS_1 ((unsigned long)pdata->tx_base + 0x24)
+#define APPNIC_SWAP_SOURCE_ADDRESS_0 ((unsigned long)pdata->tx_base + 0x28)
+
+/* Transmit Extended Configuration ---------------------------------- */
+
+#define APPNIC_TX_EXTENDED_CONF ((unsigned long)pdata->tx_base + 0x30)
+#define APPNIC_TX_EXTENDED_CONF_TRANSMIT_COLLISION_WATERMARK_LEVEL 0xf000
+#define APPNIC_TX_EXTENDED_CONF_EXCESSIVE_DEFFERED_PACKET_DROP 0x200
+#define APPNIC_TX_EXTENDED_CONF_JUMBO9K 0x100
+#define APPNIC_TX_EXTENDED_CONF_LATE_COLLISION_WINDOW_COUNT 0xff
+
+/* Transmit Half Duplex Configuration ------------------------------- */
+
+#define APPNIC_TX_HALF_DUPLEX_CONF ((unsigned long)pdata->tx_base + 0x34)
+#define APPNIC_TX_HALF_DUPLEX_CONF_RANDOM_SEED_VALUE 0xff
+
+/* Transmit Configuration ------------------------------------------- */
+
+#define APPNIC_TX_CONF	((unsigned long)pdata->tx_base + 0x0050)
+#define APPNIC_TX_CONF_ENABLE_SWAP_SA	0x8000
+#define APPNIC_TX_CONF_LINK		0x2000
+#define APPNIC_TX_CONF_DUPLEX		0x1000
+#define APPNIC_TX_CONF_SPEED		0x0800
+#define APPNIC_TX_CONF_XBK_RST_RX_NTX	0x0600
+#define APPNIC_TX_CONF_IFG		0x01f0
+#define APPNIC_TX_CONF_APP_CRC_ENABLE	0x0004
+#define APPNIC_TX_CONF_PAD_ENABLE	0x0002
+#define APPNIC_TX_CONF_ENABLE		0x0001
+
+#define TX_CONF_SET_IFG(tx_configuration, ifg)			\
+	do {							\
+		(tx_configuration) &= ~APPNIC_TX_CONF_IFG;	\
+		(tx_configuration) |= ((ifg & 0x1f) << 4);	\
+	} while (0)
+
+/* Transmit Time Value Configuration -------------------------------- */
+
+#define APPNIC_TX_TIME_VALUE_CONF ((unsigned long)pdata->tx_base + 0x5c)
+#define APPNIC_TX_TIME_VALUE_CONF_PAUSE_VALUE 0xffff
+
+/* Transmit Stat Underrun ------------------------------------------- */
+
+#define APPNIC_TX_STAT_UNDERRUN ((unsigned long)pdata->tx_base + 0x300)
+
+/* Transmit Stat Packet OK ------------------------------------------ */
+
+#define APPNIC_TX_STAT_PACKET_OK ((unsigned long)pdata->tx_base + 0x318)
+
+/* Transmit Stat Undersize ------------------------------------------ */
+
+#define APPNIC_TX_STAT_UNDERSIZE ((unsigned long)pdata->tx_base + 0x350)
+
+/* Transmit Status Late Collision ----------------------------------- */
+
+#define APPNIC_TX_STATUS_LATE_COLLISION ((unsigned long)pdata->tx_base + 0x368)
+
+/* Transmit Status Excessive Collision ------------------------------ */
+
+#define APPNIC_TX_STATUS_EXCESSIVE_COLLISION \
+	((unsigned long)pdata->tx_base + 0x370)
+
+/* Transmit Stat Collision Above Watermark -------------------------- */
+
+#define APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK \
+	((unsigned long)pdata->tx_base + 0x380)
+
+/* Transmit Mode ---------------------------------------------------- */
+
+#define APPNIC_TX_MODE ((unsigned long)pdata->tx_base + 0x800)
+#define APPNIC_TX_MODE_ETHERNET_MODE_ENABLE 0x1
+
+/* Transmit Soft Reset ---------------------------------------------- */
+
+#define APPNIC_TX_SOFT_RESET ((unsigned long)pdata->tx_base + 0x808)
+#define APPNIC_TX_SOFT_RESET_MAC_0 0x1
+
+/* Transmit Interrupt Control --------------------------------------- */
+
+#define APPNIC_TX_INTERRUPT_CONTROL ((unsigned long)pdata->tx_base + 0xc00)
+#define APPNIC_TX_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Transmit Interrupt Status ---------------------------------------- */
+
+#define APPNIC_TX_INTERRUPT_STATUS ((unsigned long)pdata->tx_base + 0xc20)
+#define APPNIC_TX_INTERRUPT_STATUS_MAC_0 0x1
+
+/* */
+
+#define APPNIC_DMA_PCI_CONTROL ((unsigned long)pdata->dma_base + 0x00)
+
+/* */
+
+#define APPNIC_DMA_CONTROL ((unsigned long)pdata->dma_base + 0x08)
+
+/* DMA Interrupt Status --------------------------------------------- */
+
+#define APPNIC_DMA_INTERRUPT_STATUS ((unsigned long)pdata->dma_base + 0x18)
+#define APPNIC_DMA_INTERRUPT_STATUS_RX 0x2
+#define APPNIC_DMA_INTERRUPT_STATUS_TX 0x1
+#define RX_INTERRUPT(dma_interrupt_status) \
+	(0 != (dma_interrupt_status & APPNIC_DMA_INTERRUPT_STATUS_RX))
+#define TX_INTERRUPT(dma_interrupt_status) \
+	(0 != (dma_interrupt_status & APPNIC_DMA_INTERRUPT_STATUS_TX))
+
+/* DMA Interrupt Enable --------------------------------------------- */
+
+#define APPNIC_DMA_INTERRUPT_ENABLE ((unsigned long)pdata->dma_base + 0x1c)
+#define APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE 0x2
+#define APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT 0x1
+
+/* DMA Receive Queue Base Address ----------------------------------- */
+
+#define APPNIC_DMA_RX_QUEUE_BASE_ADDRESS ((unsigned long)pdata->dma_base + 0x30)
+
+/* DMA Receive Queue Size ------------------------------------------- */
+
+#define APPNIC_DMA_RX_QUEUE_SIZE ((unsigned long)pdata->dma_base + 0x34)
+
+/* DMA Transmit Queue Base Address ---------------------------------- */
+
+#define APPNIC_DMA_TX_QUEUE_BASE_ADDRESS ((unsigned long)pdata->dma_base + 0x38)
+
+/* DMA Transmit Queue Size ------------------------------------------ */
+
+#define APPNIC_DMA_TX_QUEUE_SIZE ((unsigned long)pdata->dma_base + 0x3c)
+
+/* DMA Recevie Tail Pointer Address --------------------------------- */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_ADDRESS \
+	((unsigned long)pdata->dma_base + 0x48)
+
+/* DMA Transmit Tail Pointer Address -------------------------------- */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_ADDRESS \
+	((unsigned long)pdata->dma_base + 0x4c)
+
+/* DMA Receive Head Pointer ----------------------------------------- */
+
+#define APPNIC_DMA_RX_HEAD_POINTER	((unsigned long)pdata->dma_base + 0x50)
+#define APPNIC_DMA_RX_HEAD_POINTER_GB			0x100000
+#define APPNIC_DMA_RX_HEAD_POINTER_POINTER		0x0fffff
+
+/* DMA Receive Tail Pointer Local Copy ------------------------------ */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY	\
+	((unsigned long)pdata->dma_base + 0x54)
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_GB	0x100000
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_POINTER	0x0fffff
+
+/* DMA Transmit Head Pointer ---------------------------------------- */
+
+#define APPNIC_DMA_TX_HEAD_POINTER	((unsigned long)pdata->dma_base + 0x58)
+#define APPNIC_DMA_TX_HEAD_POINTER_GB			0x100000
+#define APPNIC_DMA_TX_HEAD_POINTER_POINTER		0x0fffff
+
+/* DMA Transmit Tail Pointer Local Copy ----------------------------- */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY	\
+	((unsigned long)pdata->dma_base + 0x5c)
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_GB	0x100000
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_POINTER	0x0fffff
+
+#ifdef CONFIG_ARM
+
+#define read_mac(address)         readl((void __iomem *)(address))
+#define write_mac(value, address) writel((value), (void __iomem *)(address))
+#else
+#define read_mac(address)         in_le32((u32 *) (address))
+#define write_mac(value, address) out_le32((u32 *) (address), (value))
+#endif /* CONFIG_ARM */
+
+#ifdef __LITTLE_ENDIAN
+static inline void
+readdescriptor(unsigned long address, struct appnic_dma_descriptor *descriptor)
+{
+	memcpy(descriptor, (void *)address,
+	       sizeof(struct appnic_dma_descriptor));
+	return;
+}
+
+static inline void
+writedescriptor(unsigned long address,
+		const struct appnic_dma_descriptor *descriptor)
+{
+	memcpy((void *)address, descriptor,
+		   sizeof(struct appnic_dma_descriptor));
+	return;
+}
+
+static inline union appnic_queue_pointer
+_swab_queue_pointer(const union appnic_queue_pointer *old_queue)
+{
+	return *old_queue;
+}
+
+static inline void
+femac_uncache(struct appnic_device *pdata)
+{
+	/* Set FEMAC to uncached */
+	writel(0x0, (void __iomem *)GPREG_HPROT_FEMAC);
+}
+
+#else
+
+static inline void
+readdescriptor(unsigned long address, struct appnic_dma_descriptor *descriptor)
+{
+	unsigned long *from = (unsigned long *) address;
+	unsigned long *to = (unsigned long *) descriptor;
+
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	return;
+}
+
+static inline void
+writedescriptor(unsigned long address,
+		const struct appnic_dma_descriptor *descriptor)
+{
+	unsigned long *to = (unsigned long *) address;
+	unsigned long *from = (unsigned long *) descriptor;
+
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	return;
+}
+
+static inline union appnic_queue_pointer
+_swab_queue_pointer(const union appnic_queue_pointer *old_queue)
+{
+	union appnic_queue_pointer new_queue;
+	new_queue.raw = swab32(old_queue->raw);
+	return new_queue;
+}
+
+static inline void
+femac_uncache(struct appnic_device *pdata) {}
+
+#endif /* ifdef __LITTLE_ENDIAN */
+
+static int
+femac_irq_setup(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+
+#ifdef CONFIG_ARM
+	dev->irq = pdata->dma_interrupt;
+#else
+	dev->irq = irq_create_mapping(NULL, pdata->dma_interrupt);
+	if (NO_IRQ == dev->irq)
+		return -EINVAL;
+
+	if (0 != irq_set_irq_type(dev->irq, IRQ_TYPE_LEVEL_HIGH))
+		return -EINVAL;
+#endif
+	return 0;
+}
+
+static inline int
+femac_alloc_mem_buffers(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct device *device = NULL;
+	int rc;
+
+#ifndef CONFIG_ARM
+	dev->dev.archdata.dma_ops = &dma_direct_ops;
+	device = &dev->dev;
+#endif
+
+	pdata->dma_alloc = (void *)dma_alloc_coherent(device,
+						      pdata->dma_alloc_size,
+						      &pdata->dma_alloc_dma,
+						      GFP_KERNEL);
+	if (pdata->dma_alloc == (void *)0) {
+		rc = -ENOMEM;
+		goto err_dma_alloc;
+	}
+
+	pdata->dma_alloc_offset = (int)pdata->dma_alloc -
+					(int)pdata->dma_alloc_dma;
+
+	pdata->dma_alloc_rx = (void *)dma_alloc_coherent(device,
+						      pdata->dma_alloc_size_rx,
+						      &pdata->dma_alloc_dma_rx,
+						      GFP_KERNEL);
+	if (pdata->dma_alloc_rx == (void *)0) {
+		rc = -ENOMEM;
+		goto err_dma_alloc_rx;
+	}
+
+	pdata->dma_alloc_offset_rx = (int)pdata->dma_alloc_rx -
+					(int)pdata->dma_alloc_dma_rx;
+
+	pdata->dma_alloc_tx = (void *)dma_alloc_coherent(device,
+						      pdata->dma_alloc_size_tx,
+						      &pdata->dma_alloc_dma_tx,
+						      GFP_KERNEL);
+
+	if (pdata->dma_alloc_tx == (void *)0) {
+		rc = -ENOMEM;
+		goto err_dma_alloc_tx;
+	}
+
+	pdata->dma_alloc_offset_tx = (int)pdata->dma_alloc_tx -
+					(int)pdata->dma_alloc_dma_tx;
+
+	return 0;
+
+err_dma_alloc_tx:
+	dma_free_coherent(device, pdata->dma_alloc_size_rx,
+			  pdata->dma_alloc_rx, pdata->dma_alloc_dma_rx);
+err_dma_alloc_rx:
+	dma_free_coherent(device, pdata->dma_alloc_size,
+			  pdata->dma_alloc, pdata->dma_alloc_dma);
+err_dma_alloc:
+	return rc;
+}
+
+static inline void
+femac_free_mem_buffers(struct net_device *dev)
+{
+	struct appnic_device *pdata = netdev_priv(dev);
+	struct device *device = NULL;
+
+#ifndef CONFIG_ARM
+	device = &dev->dev;
+#endif
+	dma_free_coherent(device, pdata->dma_alloc_size,
+			  pdata->dma_alloc, pdata->dma_alloc_dma);
+	dma_free_coherent(device, pdata->dma_alloc_size_rx,
+			  pdata->dma_alloc_rx, pdata->dma_alloc_dma_rx);
+	dma_free_coherent(device, pdata->dma_alloc_size_tx,
+			  pdata->dma_alloc_tx, pdata->dma_alloc_dma_tx);
+}
+
+#define swab_queue_pointer(pointer) \
+	_swab_queue_pointer((const union appnic_queue_pointer *) (pointer))
+
+#endif /* _AXXIA_ACP_NET_H */
diff --git a/drivers/net/ethernet/lsi/Kconfig b/drivers/net/ethernet/lsi/Kconfig
deleted file mode 100644
index a78867d..0000000
--- a/drivers/net/ethernet/lsi/Kconfig
+++ /dev/null
@@ -1,38 +0,0 @@
-config LSI_NET
-	bool "LSI ACP34XX Ethernet support"
-	select MII
-	select PHYLIB
-	help
-	  Network interface driver for LSI's APP and AXXIA series boards.
-
-if LSI_NET
-
-config LSI_NET_NUM_RX_DESC
-	int "LSI Axxia Network Driver: Number of receive descriptors"
-	depends on LSI_NET
-	default "4"
-	help
-          The number of receive descriptors to allocate.
-
-config LSI_NET_RX_BUF_SZ
-	int "NIC driver: Size of the receive buffer"
-	depends on LSI_NET
-	default "32768"
-	help
-          The size of the receive buffer.
-
-config LSI_NET_NUM_TX_DESC
-	int "NIC driver: Number of transmit descriptors"
-	depends on LSI_NET
-	default "4"
-	help
-	  The number of transmit descriptors to allocate.
-
-config LSI_NET_TX_BUF_SZ
-	int "NIC driver: Size of the transmit buffer"
-	depends on LSI_NET
-	default "32768"
-	help
-	  The size of the transmit buffer.
-
-endif # LSI_NET
diff --git a/drivers/net/ethernet/lsi/Makefile b/drivers/net/ethernet/lsi/Makefile
deleted file mode 100644
index a48a239..0000000
--- a/drivers/net/ethernet/lsi/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# Makefile for the LSI FEMAC network interface.
-
-obj-$(CONFIG_LSI_NET) += lsi_acp_mdio.o
-obj-$(CONFIG_LSI_NET) += lsi_acp_net.o
diff --git a/drivers/net/ethernet/lsi/lsi_acp_mdio.c b/drivers/net/ethernet/lsi/lsi_acp_mdio.c
deleted file mode 100644
index 7bde921..0000000
--- a/drivers/net/ethernet/lsi/lsi_acp_mdio.c
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
- * drivers/net/ethernet/lsi/lsi_acp_mdio.c
- *
- * Copyright (C) 2013 LSI Corporation.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/of.h>
-#include <asm/irq.h>
-#include <linux/io.h>
-#include <linux/of_address.h>
-#include <linux/irqdomain.h>
-#include <linux/skbuff.h>
-#include <linux/platform_device.h>
-
-#define BZ33327_WA
-
-/* MDIO Access */
-
-struct lsi_mdio_priv {
-	unsigned long base;
-};
-
-static struct lsi_mdio_priv *mdio_priv;
-static DEFINE_SPINLOCK(mdio_lock);
-
-#define MDIO_CONTROL_RD_DATA ((void *)(mdio_priv->base + 0x0))
-#define MDIO_STATUS_RD_DATA  ((void *)(mdio_priv->base + 0x4))
-#define MDIO_CLK_OFFSET      ((void *)(mdio_priv->base + 0x8))
-#define MDIO_CLK_PERIOD      ((void *)(mdio_priv->base + 0xc))
-
-#ifdef CONFIG_ARM
-static u32 read_reg(u32 *addr)
-{
-	return readl_relaxed((void __iomem *)addr);
-}
-
-static void write_reg(u32 *addr, u32 value)
-{
-	writel_relaxed(value, (void __iomem *)addr);
-}
-#else
-static u32 read_reg(u32 *addr)
-{
-	return in_le32((unsigned *)addr);
-}
-
-static void write_reg(u32 *addr, u32 value)
-{
-	out_le32((unsigned *)addr, (int)value);
-}
-#endif
-
-/* acp_mdio_read */
-
-int
-acp_mdio_read(unsigned long address, unsigned long offset,
-	      unsigned short *value, int clause_45)
-{
-	unsigned long command = 0;
-	unsigned long status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdio_lock, flags);
-#if defined(BZ33327_WA)
-	/* Set the mdio_busy (status) bit. */
-	status = read_reg(MDIO_STATUS_RD_DATA);
-	status |= 0x40000000;
-	write_reg(MDIO_STATUS_RD_DATA, status);
-#endif /* BZ33327_WA */
-
-	if (clause_45 == 0) {
-		/* Write the command. */
-		command = 0x10000000;              /* op_code: read */
-		command |= (address & 0x1f) << 16; /* port_addr (tgt device) */
-		command |= (offset & 0x1f) << 21;  /* device_addr (tgt reg) */
-		write_reg(MDIO_CONTROL_RD_DATA, command);
-	} else {
-		/* Step 1: Write the address. */
-
-		/* Write the address */
-		command = 0x20000000;                    /* Clause 45 = 1 */
-		command |= 0x00000000;                   /* op_code: 0 */
-		command |= 0x04000000;                   /* interface_sel = 1 */
-		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
-							  * device_type)
-							  */
-		command |= (address & 0x1f) << 16;       /* port_addr (target
-							  * device)
-							  */
-		command |= (offset & 0xffff);            /* addr_or_data (target
-							  * register)
-							  */
-		write_reg(MDIO_CONTROL_RD_DATA, command);
-
-		/* Wait for the mdio_busy (status) bit to clear. */
-		do {
-			status = read_reg(MDIO_STATUS_RD_DATA);
-		} while (0 != (status & 0x40000000));
-
-		/* Wait for the mdio_busy (control) bit to clear. */
-		do {
-			command = read_reg(MDIO_CONTROL_RD_DATA);
-		} while (0 != (command & 0x80000000));
-
-		/* Step 2: Read the value. */
-
-		/* Set the mdio_busy (status) bit. */
-		status = read_reg(MDIO_STATUS_RD_DATA);
-		status |= 0x40000000;
-		write_reg(MDIO_STATUS_RD_DATA, status);
-
-		command = 0x20000000;                    /* Clause 45 = 1 */
-		command |= 0x10000000;                   /* op_code: read */
-		command |= 0x04000000;                   /* interface_sel = 1 */
-		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
-							  * device_type)
-							  */
-		command |= (address & 0x1f) << 16;       /* port_addr (target
-							  * device)
-							  */
-		write_reg(MDIO_CONTROL_RD_DATA, command);
-	}
-
-#if defined(BZ33327_WA)
-	/* Wait for the mdio_busy (status) bit to clear. */
-	do {
-		status = read_reg(MDIO_STATUS_RD_DATA);
-	} while (0 != (status & 0x40000000));
-#endif				/* BZ33327_WA */
-
-	/* Wait for the mdio_busy (control) bit to clear. */
-	do {
-		command = read_reg(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	*value = (unsigned short)(command & 0xffff);
-	spin_unlock_irqrestore(&mdio_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(acp_mdio_read);
-
-/* acp_mdio_write */
-
-int
-acp_mdio_write(unsigned long address, unsigned long offset,
-	       unsigned short value, int clause_45)
-{
-	unsigned long command = 0;
-	unsigned long status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdio_lock, flags);
-
-	/* Wait for mdio_busy (control) to be clear. */
-	do {
-		command = read_reg(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-#if defined(BZ33327_WA)
-	/* Set the mdio_busy (status) bit. */
-	status = read_reg(MDIO_STATUS_RD_DATA);
-	status |= 0x40000000;
-	write_reg(MDIO_STATUS_RD_DATA, status);
-#endif /* BZ33327_WA */
-
-	if (clause_45 == 0) {
-		/* Write the command. */
-		command = 0x08000000;              /* op_code: write */
-		command |= (address & 0x1f) << 16; /* port_addr (tgt device) */
-		command |= (offset & 0x1f) << 21;  /* device_addr (tgt reg) */
-		command |= (value & 0xffff);       /* value */
-		write_reg(MDIO_CONTROL_RD_DATA, command);
-	} else {
-		/* Step 1: Write the address. */
-
-		/* Write the address */
-		command = 0x20000000;                    /* Clause 45 = 1 */
-		command |= 0x00000000;                   /* op_code: 0 */
-		command |= 0x04000000;                   /* interface_sel = 1 */
-		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
-							  * device_type)
-							  */
-		command |= (address & 0x1f) << 16;       /* port_addr (target
-							  * device)
-							  */
-		command |= (offset & 0xffff);            /* addr_or_data (target
-							  * register)
-							  */
-		write_reg(MDIO_CONTROL_RD_DATA, command);
-
-		/* Wait for the mdio_busy (status) bit to clear. */
-		do {
-			status = read_reg(MDIO_STATUS_RD_DATA);
-		} while (0 != (status & 0x40000000));
-
-		/* Wait for the mdio_busy (control) bit to clear. */
-		do {
-			command = read_reg(MDIO_CONTROL_RD_DATA);
-		} while (0 != (command & 0x80000000));
-
-		/* Step 2: Write the value. */
-
-		/* Set the mdio_busy (status) bit. */
-		status = read_reg(MDIO_STATUS_RD_DATA);
-		status |= 0x40000000;
-		write_reg(MDIO_STATUS_RD_DATA, status);
-
-		command = 0x20000000;                    /* Clause 45 = 1 */
-		command |= 0x08000000;                   /* op_code: write */
-		command |= 0x04000000;                   /* interface_sel = 1 */
-		command |= ((offset & 0x1f000000) >> 3); /* device_addr (target
-							  * device_type)
-							  */
-		command |= (address & 0x1f) << 16;       /* port_addr (target
-							  * device)
-							  */
-		command |= (value & 0xffff);             /* addr_or_data=value*/
-		write_reg(MDIO_CONTROL_RD_DATA, command);
-	}
-
-#if defined(BZ33327_WA)
-	/* Wait for the mdio_busy (status) bit to clear. */
-	do {
-		status = read_reg(MDIO_STATUS_RD_DATA);
-	} while (0 != (status & 0x40000000));
-#endif	/* BZ33327_WA */
-
-	/* Wait for the mdio_busy (control) bit to clear. */
-	do {
-		command = read_reg(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	spin_unlock_irqrestore(&mdio_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(acp_mdio_write);
-
-/* acp_mdio_initialize */
-
-static void
-acp_mdio_initialize(int offset, int period)
-{
-	write_reg(MDIO_CLK_OFFSET, offset);
-	write_reg(MDIO_CLK_PERIOD, period);
-
-	return;
-}
-
-/* acp_wrappers_init */
-
-int __init
-acp_mdio_init(void)
-{
-	int rc = -ENODEV;
-	struct device_node *np = NULL;
-	const u32 *field;
-	void __iomem *map;
-	u64 mdio_address;
-	u32 mdio_size;
-	u32 mdio_offset = 0;
-	u32 mdio_period = 0;
-
-	pr_info("MDIO: Initializing Axxia Wrappers.\n");
-
-	mdio_priv = kzalloc(sizeof(struct lsi_mdio_priv), GFP_KERNEL);
-	if (!mdio_priv)
-		return -ENOMEM;
-
-	np = of_find_node_by_type(np, "network");
-
-	while (np &&
-	       !of_device_is_compatible(np, "lsi,acp-femac") &&
-	       !of_device_is_compatible(np, "acp-femac"))
-		np = of_find_node_by_type(np, "network");
-
-	if (!np) {
-		pr_warn("MDIO: No compatible devices found.\n");
-		rc = -EINVAL;
-		goto error;
-	}
-
-	field = of_get_property(np, "mdio-reg", NULL);
-
-	if (!field) {
-		pr_crit("MDIO: Unable to read mdio-reg property!\n");
-		rc = -EINVAL;
-		goto error;
-	}
-
-	mdio_address = of_translate_address(np, field);
-
-	if (mdio_address == OF_BAD_ADDR) {
-		pr_crit("MDIO: of_translate_address failed!\n");
-		rc = -EINVAL;
-		goto error;
-	}
-
-	mdio_size = field[3];
-	map = ioremap(mdio_address, mdio_size);
-
-	if (!map) {
-		pr_crit("MDIO: Unable to ioremap!\n");
-		rc = -ENOMEM;
-		goto error;
-	}
-
-	mdio_priv->base = (unsigned long)map;
-	field = of_get_property(np, "mdio-clock-offset", NULL);
-
-	if (field)
-		mdio_offset = ntohl(field[0]);
-
-	field = of_get_property(np, "mdio-clock-period", NULL);
-
-	if (field)
-		mdio_period = ntohl(field[0]);
-
-	if (0 != mdio_offset && 0 != mdio_period)
-		acp_mdio_initialize(mdio_offset, mdio_period);
-
-error:
-	return rc;
-}
-
-module_init(acp_mdio_init);
-
-MODULE_AUTHOR("LSI Corporation");
-MODULE_DESCRIPTION("Timing Test");
-MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
deleted file mode 100644
index d6f2391..0000000
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ /dev/null
@@ -1,2000 +0,0 @@
-/*
- * drivers/net/ethernet/lsi/lsi_acp_net.c
- *
- * Copyright (C) 2013 LSI Corporation.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * NOTES:
- *
- * 1) This driver is used by both ACP (PPC) and AXM (ARM) platforms.
- *
- * 2) This driver parses the DTB for driver specific settings. A few of
- *    them can be overridden by setting environment variables in U-boot:
- *
- *    ethaddr - MAC address of interface, in xx:xx:xx:xx:xx:xx format
- *
- *    phy-addr - Specific address of PHY (0 - 0x20). If not specified,
- *               the driver will scan the bus and will attach to the first
- *               PHY it finds.
- *
- *    ad-value - PHY advertise value. Can be set to one of these or they
- *               be OR'ed together. If not set, the driver sets the
- *               advertised value equal to what the driver supports.
- *
- *               0x101 - 100/Full
- *               0x81  - 100/Half
- *               0x41  - 10/Full
- *               0x21  - 10/Half
- *
- * 3) This driver allows the option to disable auto negotiation and manually
- *    specify the speed and duplex setting, with the use of the device tree
- *    variable "phy-link". Legal values for this variable are:
- *
- *    "auto"  - auto negotiation enabled
- *    "100MF" - auto negotiation disabled, set to 100MB Full Duplex
- *    "10MH"  - auto negotiation disabled, set to 100MB Half Duplex
- *    "10MF"  - auto negotiation disabled, set to 10MB Full Duplex
- *    "10MH"  - auto negotiation disabled, set to 10MB Half Duplex
- *
- *    NOTE: If the phy-link variable is not present in the device tree, or
- *    if an invalid value is used, the driver defaults to auto negotiation
- *    mode.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/errno.h>
-#include <linux/in.h>
-#include <linux/slab.h>
-#include <linux/ioport.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/bitops.h>
-#include <linux/proc_fs.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/mii.h>
-#include <linux/phy.h>
-#include <linux/etherdevice.h>
-#include <linux/ethtool.h>
-#include <linux/skbuff.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <linux/of_net.h>
-#include <linux/dma-mapping.h>
-#include <linux/uaccess.h>
-#include <linux/io.h>
-#include <linux/lsi-ncr.h>
-
-#include <asm/dma.h>
-
-#include "lsi_acp_net.h"
-
-#define LSI_DRV_NAME           "acp-femac"
-#define LSI_MDIO_NAME          "acp-femac-mdio"
-#define LSI_DRV_VERSION        "2014-01-09"
-
-MODULE_AUTHOR("John Jacques");
-MODULE_DESCRIPTION("LSI ACP-FEMAC Ethernet driver");
-MODULE_LICENSE("GPL");
-
-/* ----------------------------------------------------------------------
- * appnic_mii_read
- *
- * Returns -EBUSY if unsuccessful, the (short) value otherwise.
- */
-
-static int appnic_mii_read(struct mii_bus *bus, int phy, int reg)
-{
-	unsigned short value;
-
-	/* Always returns success, so no need to check return status. */
-	acp_mdio_read(phy, reg, &value, 0);
-
-	return (int)value;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_mii_write
- */
-
-static int appnic_mii_write(struct mii_bus *bus, int phy, int reg, u16 val)
-{
-	return acp_mdio_write(phy, reg, val, 0);
-}
-
-/* ----------------------------------------------------------------------
- * appnic_handle_link_change
- *
- * Called periodically when PHY is in polling mode.
- */
-
-static void appnic_handle_link_change(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct phy_device *phydev = pdata->phy_dev;
-	int status_change = 0;
-	unsigned long rx_configuration;
-	unsigned long tx_configuration = 0;
-
-	rx_configuration =
-#ifdef CONFIG_ARM
-		APPNIC_RX_CONF_STRIPCRC;
-#else
-		(APPNIC_RX_CONF_STRIPCRC |
-		 APPNIC_RX_CONF_RXFCE |
-		 APPNIC_RX_CONF_TXFCE);
-#endif
-	tx_configuration =
-		(APPNIC_TX_CONF_ENABLE_SWAP_SA |
-		 APPNIC_TX_CONF_APP_CRC_ENABLE |
-		 APPNIC_TX_CONF_PAD_ENABLE);
-
-	TX_CONF_SET_IFG(tx_configuration, 0xf);
-
-	if (phydev->link) {
-		if ((pdata->speed != phydev->speed) ||
-		    (pdata->duplex != phydev->duplex)) {
-			if (phydev->duplex) {
-				rx_configuration |= APPNIC_RX_CONF_DUPLEX;
-				tx_configuration |= APPNIC_TX_CONF_DUPLEX;
-			}
-			if (phydev->speed == SPEED_100) {
-				rx_configuration |= APPNIC_RX_CONF_SPEED;
-				tx_configuration |= APPNIC_TX_CONF_SPEED;
-			}
-
-			rx_configuration |= (APPNIC_RX_CONF_ENABLE |
-					     APPNIC_RX_CONF_LINK);
-			tx_configuration |= (APPNIC_TX_CONF_LINK |
-					     APPNIC_TX_CONF_ENABLE);
-
-			pdata->speed = phydev->speed;
-			pdata->duplex = phydev->duplex;
-			status_change = 1;
-		}
-	}
-	if (phydev->link != pdata->link) {
-		if (!phydev->link) {
-			pdata->speed = 0;
-			pdata->duplex = -1;
-		}
-		pdata->link = phydev->link;
-		status_change = 1;
-	}
-
-	if (status_change) {
-		if (phydev->link) {
-			netif_carrier_on(dev);
-			netdev_info(dev, "link up (%d/%s)\n",
-				    phydev->speed,
-				    phydev->duplex == DUPLEX_FULL ?
-				    "Full" : "Half");
-		} else {
-			netif_carrier_off(dev);
-			netdev_info(dev, "link down\n");
-		}
-
-		if (rx_configuration != read_mac(APPNIC_RX_CONF))
-			write_mac(rx_configuration, APPNIC_RX_CONF);
-
-		if (tx_configuration != read_mac(APPNIC_TX_CONF))
-			write_mac(tx_configuration, APPNIC_TX_CONF);
-	}
-}
-
-/* ----------------------------------------------------------------------
- * appnic_mii_probe
- */
-
-static int appnic_mii_probe(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct phy_device *phydev = NULL;
-	int ret;
-
-	if (pdata->phy_address && (pdata->phy_address < PHY_MAX_ADDR)) {
-		phydev = mdiobus_get_phy(pdata->mii_bus, pdata->phy_address);
-		if (phydev)
-			goto skip_first;
-	}
-
-	/* Find the first phy */
-	phydev = phy_find_first(pdata->mii_bus);
-	if (!phydev) {
-		pr_crit("!!! no PHY found !!!\n");
-		netdev_err(dev, " no PHY found\n");
-		return -ENODEV;
-	}
-
-skip_first:
-
-	/* Allow the option to disable auto negotiation and manually specify
-	 * the link speed and duplex setting with the use of a environment
-	 * setting.
-	 */
-
-	if (0 == pdata->phy_link_auto) {
-		phydev->autoneg = AUTONEG_DISABLE;
-		phydev->speed =
-			0 == pdata->phy_link_speed ? SPEED_10 : SPEED_100;
-		phydev->duplex =
-			0 == pdata->phy_link_duplex ? DUPLEX_HALF : DUPLEX_FULL;
-	} else {
-		phydev->autoneg = AUTONEG_ENABLE;
-	}
-
-	ret = phy_connect_direct(dev, phydev,
-				 &appnic_handle_link_change,
-				 PHY_INTERFACE_MODE_MII);
-
-	if (ret) {
-		netdev_err(dev, "Could not attach to PHY\n");
-		return ret;
-	}
-
-	phy_attached_info(phydev);
-
-	/* Mask with MAC supported features */
-	phydev->supported &= PHY_BASIC_FEATURES;
-	if (pdata->ad_value)
-		phydev->advertising = mii_adv_to_ethtool_adv_t(pdata->ad_value);
-	else
-		phydev->advertising = phydev->supported;
-
-	pdata->link = 0;
-	pdata->speed = 0;
-	pdata->duplex = -1;
-	pdata->phy_dev = phydev;
-
-	pr_info("%s: PHY initialized successfully", LSI_DRV_NAME);
-	return 0;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_mii_init
- */
-
-static int appnic_mii_init(struct platform_device *pdev,
-			   struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	int i, err = -ENXIO;
-
-	pdata->mii_bus = mdiobus_alloc();
-	if (!pdata->mii_bus) {
-		err = -ENOMEM;
-		goto err_out_1;
-	}
-
-	pdata->mii_bus->name = LSI_MDIO_NAME;
-	snprintf(pdata->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
-		 pdev->name, pdev->id);
-	pdata->mii_bus->priv = pdata;
-	pdata->mii_bus->read = appnic_mii_read;
-	pdata->mii_bus->write = appnic_mii_write;
-	memcpy(pdata->mii_bus->irq, pdata->phy_irq, sizeof(pdata->phy_irq));
-	for (i = 0; i < PHY_MAX_ADDR; ++i)
-		pdata->mii_bus->irq[i] = PHY_POLL;
-
-	if (mdiobus_register(pdata->mii_bus)) {
-		pr_warn("%s: Error registering mii bus", LSI_DRV_NAME);
-		goto err_out_free_bus_2;
-	}
-
-	if (appnic_mii_probe(dev) < 0) {
-		pr_warn("%s: Error registering mii bus", LSI_DRV_NAME);
-		goto err_out_unregister_bus_3;
-	}
-
-	return 0;
-
-err_out_unregister_bus_3:
-	mdiobus_unregister(pdata->mii_bus);
-err_out_free_bus_2:
-	mdiobus_free(pdata->mii_bus);
-err_out_1:
-	return err;
-}
-
-/* ======================================================================
- * NIC Interface
- * ======================================================================
-*/
-
-#define DESCRIPTOR_GRANULARITY 64
-#define BUFFER_ALIGNMENT 64
-
-#define ALIGN64B(address) (PTR_ALIGN((address), BUFFER_ALIGNMENT))
-#define ALIGN64B_OFFSET(address) \
-	(ALIGN64B(address) - (unsigned long) (address))
-
-/*  ----- Note On Buffer Space -----
- *
- *  Minimum number of descriptors is 64 for the receiver and 64 for the
- *  transmitter; therefore, 2048 bytes (16 bytes each).
- *  This driver uses the following parameters, all of which may be set on
- *  the command line if this drivers is used as a module.
- *
- *  - rx_num_desc : Number of receive descriptors. This  must be a multiple
- *                  of 64.
- *  - tx_num_desc : Number of transmit descriptors. This must be a multiple
- *                  of 64.
- *
- *  The scheme used will be as follows:
- *
- *  - num_[rt]x_desc will be adjusted to be a multiple of 64 (if necessary).
- *  - An skb (with the data area 64 byte aligned) will be allocated for each rx
- *    descriptor.
- */
-
-/* Receiver */
-
-int rx_num_desc = (CONFIG_LSI_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY);
-module_param(rx_num_desc, int, 0000);
-MODULE_PARM_DESC(rx_num_desc, "appnic : Number of receive descriptors");
-
-int rx_buf_sz = CONFIG_LSI_NET_RX_BUF_SZ;
-module_param(rx_buf_sz, int, 0000);
-MODULE_PARM_DESC(rx_buf_sz, "appnic : Receive buffer size");
-
-/* Transmitter */
-
-int tx_num_desc = (CONFIG_LSI_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY);
-module_param(tx_num_desc, int, 0000);
-MODULE_PARM_DESC(tx_num_desc, "appnic : Number of receive descriptors");
-
-int tx_buf_sz = CONFIG_LSI_NET_TX_BUF_SZ;
-module_param(tx_buf_sz, int, 0000);
-MODULE_PARM_DESC(tx_buf_sz, "Appnic : Receive buffer size");
-
-/* ======================================================================
- * Utility Functions
- * ======================================================================
- */
-
-/* ----------------------------------------------------------------------
- * mac_addr_valid
- *
- * If mac address is multicast, broadcast, or matches our mac address,
- * it's a valid address. Otherwise, it's not.
- */
-
-static bool mac_addr_valid(struct net_device *dev, u8 *mac_addr)
-{
-	bool is_valid = false;
-
-	if (is_multicast_ether_addr(mac_addr))
-		is_valid = true;
-	else if (is_broadcast_ether_addr(mac_addr))
-		is_valid = true;
-	else if (ether_addr_equal(mac_addr, &dev->dev_addr[0]))
-		is_valid = true;
-
-	return is_valid;
-}
-
-/* ----------------------------------------------------------------------
- * clear_statistics
- *
- * NOTE: The hardware clears the statistics registers after a read.
- */
-
-static void clear_statistics(struct appnic_device *pdata)
-{
-	/* Clear memory. */
-
-	memset((void *)&pdata->stats, 0, sizeof(struct net_device_stats));
-
-	/* Clear counters by reading them. */
-
-	/* stats.rx_packets */
-	read_mac(APPNIC_RX_STAT_PACKET_OK);
-
-	/* stats.tx_packets */
-	read_mac(APPNIC_TX_STAT_PACKET_OK);
-
-	/* stats.rx_bytes - Updated by this driver.
-	 * stats.tx_bytes - Updated by this driver.
-	 * stats.rx_errors - The sum of all RX errors available.
-	 * stats.tx_errors - The sum of all TX errors available.
-	 * stats.rx_dropped (unable to allocate skb) - Updated by the stack.
-	 * stats.tx_dropped (unable to allocate skb) - Updated by the stack.
-	 */
-
-	/* stats.multicast */
-	read_mac(APPNIC_RX_STAT_MULTICAST);
-
-	/* stats.collisions - The sum of the following driver stats. */
-	read_mac(APPNIC_TX_STATUS_LATE_COLLISION);
-	read_mac(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
-	read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
-
-	/* stats.rx_length_errors - The sum of the following driver stats. */
-	read_mac(APPNIC_RX_STAT_UNDERSIZE);
-	read_mac(APPNIC_RX_STAT_OVERSIZE);
-
-	/* stats.rx_over_errors - Not maintained by this driver. */
-
-	/* stats.rx_crc_errors */
-	read_mac(APPNIC_RX_STAT_CRC_ERROR);
-
-	/* stats.rx_frame_errors */
-	read_mac(APPNIC_RX_STAT_ALIGN_ERROR);
-
-	/* stats.rx_fifo_errors */
-	read_mac(APPNIC_RX_STAT_OVERFLOW);
-
-	/* stats.rx_missed - Not maintained by this driver.
-	 * stats.tx_aborted_errors - Not maintained by this driver.
-	 * stats.tx_carrier_errors - Not maintained by this driver.
-	 */
-
-	/* stats.tx_fifo_errors */
-	read_mac(APPNIC_TX_STAT_UNDERRUN);
-
-	/* stats.tx_heartbeat_errors - Not maintained by this driver.
-	 * stats.tx_window_errors - Not mainteaned by this driver.
-	 * stats.rx_compressed - Not maintained by this driver.
-	 * stats.tx_compressed - Not maintained by this driver.
-	 */
-}
-
-/* ----------------------------------------------------------------------
- * get_hw_statistics
- *
- * NOTE: The hardware clears the statistics registers after a read.
- */
-
-static void get_hw_statistics(struct appnic_device *pdata)
-{
-	unsigned long flags;
-	u32 rx_under;
-	u32 rx_over;
-	u32 tx_under;
-
-	/* stats.tx_packets */
-	pdata->stats.tx_packets += read_mac(APPNIC_TX_STAT_PACKET_OK);
-
-	/* stats.multicast */
-	pdata->stats.multicast += read_mac(APPNIC_RX_STAT_MULTICAST);
-
-	/* stats.collision */
-	pdata->stats.collisions += read_mac(APPNIC_TX_STATUS_LATE_COLLISION);
-	pdata->stats.collisions +=
-		read_mac(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
-	pdata->stats.collisions +=
-		read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
-
-	/* stats.rx_length_errors */
-	rx_under = read_mac(APPNIC_RX_STAT_UNDERSIZE);
-	pdata->stats.rx_length_errors += rx_under;
-	rx_over = read_mac(APPNIC_RX_STAT_OVERSIZE);
-	pdata->stats.rx_length_errors += rx_over;
-
-	/* stats.tx_fifo_errors */
-	tx_under = read_mac(APPNIC_TX_STAT_UNDERRUN);
-	pdata->stats.tx_fifo_errors += tx_under;
-
-	/* Lock this section out so the statistics maintained by the driver
-	 * don't get clobbered.
-	 */
-
-	spin_lock_irqsave(&pdata->dev_lock, flags);
-
-	pdata->stats.rx_dropped = 0;
-	pdata->stats.rx_over_errors = 0;
-
-	/* Update the cumulative rx_errors. */
-	pdata->stats.rx_errors += (rx_under + rx_over);
-
-	pdata->stats.tx_aborted_errors = 0;
-
-	/* Update the cumulative tx_errors. */
-	pdata->stats.tx_errors += tx_under;
-
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
-}
-
-/* ----------------------------------------------------------------------
- * queue_initialized
- *
- * Returns the number of descriptors that are ready to receive packets
- * or are waiting to transmit packets.  (from tail to head).
- */
-
-static int queue_initialized(union appnic_queue_pointer head,
-			     union appnic_queue_pointer tail,
-			     int size)
-{
-	int initialized;
-
-	/* Calculate the number of descriptors currently initialized. */
-	if (head.bits.generation_bit == tail.bits.generation_bit) {
-		/* same generation */
-		initialized = (head.bits.offset - tail.bits.offset);
-	} else {
-		/* different generation */
-		initialized = head.bits.offset +
-			(size * sizeof(struct appnic_dma_descriptor) -
-			 tail.bits.offset);
-	}
-
-	/* Number of descriptors is offset / sizeof(a descriptor). */
-	initialized /= sizeof(struct appnic_dma_descriptor);
-
-	return initialized;
-}
-
-/* ----------------------------------------------------------------------
- * queue_uninitialzed
- *
- * Returns the number of unused/uninitialized descriptors. (from head to tail).
-*/
-
-static int queue_uninitialized(union appnic_queue_pointer head,
-			       union appnic_queue_pointer tail,
-			       int size)
-{
-	int allocated;
-
-	/* Calculate the number of descriptors currently unused/uninitialized */
-	if (head.bits.generation_bit == tail.bits.generation_bit)
-		/* Same generation. */
-		allocated = ((size * sizeof(struct appnic_dma_descriptor)) -
-			 head.bits.offset) + tail.bits.offset;
-	else
-		/* Different generation. */
-		allocated = tail.bits.offset - head.bits.offset;
-
-	/* Number of descriptors is offset / sizeof(a descriptor). */
-	allocated /= sizeof(struct appnic_dma_descriptor);
-
-	/* That's all. */
-	return allocated;
-}
-
-/* ----------------------------------------------------------------------
- * queue_increment
- */
-
-static void queue_increment(union appnic_queue_pointer *queue,
-			    int number_of_descriptors)
-{
-	queue->bits.offset += sizeof(struct appnic_dma_descriptor);
-
-	if ((number_of_descriptors * sizeof(struct appnic_dma_descriptor)) ==
-		queue->bits.offset) {
-		queue->bits.offset = 0;
-		queue->bits.generation_bit =
-			(0 == queue->bits.generation_bit) ? 1 : 0;
-	}
-}
-
-/* ----------------------------------------------------------------------
- * queue_decrement
- */
-
-static void queue_decrement(union appnic_queue_pointer *queue,
-			    int number_of_descriptors)
-{
-	if (0 == queue->bits.offset) {
-		queue->bits.offset =
-			((number_of_descriptors - 1) *
-			 sizeof(struct appnic_dma_descriptor));
-		queue->bits.generation_bit =
-			(0 == queue->bits.generation_bit) ? 1 : 0;
-	} else {
-		queue->bits.offset -= sizeof(struct appnic_dma_descriptor);
-	}
-}
-
-/* ----------------------------------------------------------------------
- * disable_rx_tx
- */
-
-static void disable_rx_tx(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	unsigned long tx_configuration;
-	unsigned long rx_configuration;
-
-	rx_configuration = read_mac(APPNIC_RX_CONF);
-	rx_configuration &= ~APPNIC_RX_CONF_ENABLE;
-	write_mac(rx_configuration, APPNIC_RX_CONF);
-
-	tx_configuration = read_mac(APPNIC_TX_CONF);
-	tx_configuration &= ~APPNIC_TX_CONF_ENABLE;
-
-	write_mac(tx_configuration, APPNIC_TX_CONF);
-}
-
-/* ======================================================================
- *  Linux Network Driver Interface
- *  ======================================================================
-*/
-
-/* ----------------------------------------------------------------------
- * handle_transmit_interrupt
- */
-
-static void handle_transmit_interrupt(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	union appnic_queue_pointer queue;
-
-	/* The hardware's tail pointer should be one descriptor (or more)
-	 * ahead of software's copy.
-	 */
-
-	queue = swab_queue_pointer(pdata->tx_tail);
-	while (0 < queue_initialized(queue, pdata->tx_tail_copy,
-				     pdata->tx_num_desc)) {
-		queue_increment(&pdata->tx_tail_copy, pdata->tx_num_desc);
-		queue = swab_queue_pointer(pdata->tx_tail);
-	}
-}
-
-/* ----------------------------------------------------------------------
- * lsinet_rx_packet
- */
-
-static void lsinet_rx_packet(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct appnic_dma_descriptor descriptor;
-	struct sk_buff *sk_buff;
-	unsigned bytes_copied = 0;
-	unsigned error_num = 0;
-	unsigned long ok_stat = 0, overflow_stat = 0;
-	unsigned long crc_stat = 0, align_stat = 0;
-	union appnic_queue_pointer queue;
-
-	readdescriptor(((unsigned long)pdata->rx_desc +
-			pdata->rx_tail_copy.bits.offset), &descriptor);
-
-	sk_buff = netdev_alloc_skb(NULL, LSINET_MAX_MTU);
-
-	if ((struct sk_buff *)0 == sk_buff) {
-		pr_info_ratelimited("%s: No buffer, packet dropped.\n",
-				    LSI_DRV_NAME);
-		pdata->stats.rx_dropped++;
-		return;
-	} else {
-		/* Needs to be reviewed.  This fixed an aligment
-		* exception when pinging to the target from a host.
-		*/
-
-		/* Align IP on 16 byte boundaries */
-		skb_reserve(sk_buff, 2);
-	}
-
-	ok_stat = read_mac(APPNIC_RX_STAT_PACKET_OK);
-	overflow_stat = read_mac(APPNIC_RX_STAT_OVERFLOW);
-	crc_stat = read_mac(APPNIC_RX_STAT_CRC_ERROR);
-	align_stat = read_mac(APPNIC_RX_STAT_ALIGN_ERROR);
-
-	/* Copy the received packet into the skb. */
-
-	queue = swab_queue_pointer(pdata->rx_tail);
-	while (0 < queue_initialized(queue, pdata->rx_tail_copy,
-				     pdata->rx_num_desc)) {
-		if (skb_tailroom(sk_buff) >= descriptor.pdu_length) {
-			unsigned char *buffer;
-
-			buffer = skb_put(sk_buff, descriptor.pdu_length);
-			memcpy((void *)buffer,
-			       (void *)(descriptor.host_data_memory_pointer +
-				 pdata->dma_alloc_offset_rx),
-			       descriptor.pdu_length);
-		} else {
-			pr_err_ratelimited("%s: PDU overrun (%u/%u, %d)\n",
-					   LSI_DRV_NAME,
-					   descriptor.pdu_length,
-					   bytes_copied,
-					   descriptor.error);
-		}
-		bytes_copied += descriptor.pdu_length;
-		descriptor.data_transfer_length = pdata->rx_buf_per_desc;
-		writedescriptor(((unsigned long)pdata->rx_desc +
-					pdata->rx_tail_copy.bits.offset),
-				&descriptor);
-		if (0 != descriptor.error)
-			error_num = 1;
-		queue_increment(&pdata->rx_tail_copy, pdata->rx_num_desc);
-		if (0 != descriptor.end_of_packet)
-			break;
-		readdescriptor(((unsigned long)pdata->rx_desc +
-					pdata->rx_tail_copy.bits.offset),
-			       &descriptor);
-		queue = swab_queue_pointer(pdata->rx_tail);
-	}
-
-	if (0 == descriptor.end_of_packet) {
-		pr_err("%s: No end of packet! %lu/%lu/%lu/%lu\n",
-		       LSI_DRV_NAME, ok_stat, overflow_stat,
-		       crc_stat, align_stat);
-		BUG();
-		dev_kfree_skb(sk_buff);
-
-	} else if (0 == error_num) {
-		struct ethhdr *ethhdr = (struct ethhdr *)sk_buff->data;
-
-		if (mac_addr_valid(dev, &ethhdr->h_dest[0])) {
-			pdata->stats.rx_bytes += bytes_copied;
-			++pdata->stats.rx_packets;
-			sk_buff->dev = dev;
-			sk_buff->protocol = eth_type_trans(sk_buff, dev);
-
-			if (netif_receive_skb(sk_buff) == NET_RX_DROP)
-				++pdata->dropped_by_stack;
-		} else {
-			dev_kfree_skb(sk_buff);
-		}
-	} else {
-		dev_kfree_skb(sk_buff);
-
-		pdata->stats.rx_errors +=
-			(overflow_stat + crc_stat + align_stat);
-
-		if (0 != overflow_stat)
-			pdata->stats.rx_fifo_errors += overflow_stat;
-		else if (0 != crc_stat)
-			pdata->stats.rx_crc_errors += crc_stat;
-		else if (0 != align_stat)
-			pdata->stats.rx_frame_errors += align_stat;
-	}
-
-	return;
-}
-
-/* ----------------------------------------------------------------------
- * lsinet_rx_packets
- */
-
-static int lsinet_rx_packets(struct net_device *dev, int max)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	union appnic_queue_pointer orig_queue, new_queue;
-	int updated_head_pointer = 0;
-	int packets = 0;
-
-	new_queue.raw = pdata->rx_tail_copy.raw;
-
-	/* Receive Packets */
-
-	orig_queue = swab_queue_pointer(pdata->rx_tail);
-	while (0 < queue_initialized(orig_queue, new_queue,
-				     pdata->rx_num_desc)) {
-		struct appnic_dma_descriptor descriptor;
-
-		readdescriptor(((unsigned long)pdata->rx_desc +
-				  new_queue.bits.offset),
-				&descriptor);
-
-		if (0 != descriptor.end_of_packet) {
-			lsinet_rx_packet(dev);
-			packets++;
-			new_queue.raw = pdata->rx_tail_copy.raw;
-
-			if ((-1 != max) && (packets == max))
-				break;
-		} else {
-			queue_increment(&new_queue, pdata->rx_num_desc);
-		}
-		orig_queue = swab_queue_pointer(pdata->rx_tail);
-	}
-
-	/* Update the Head Pointer */
-
-	while (1 < queue_uninitialized(pdata->rx_head,
-				       pdata->rx_tail_copy,
-				       pdata->rx_num_desc)) {
-		struct appnic_dma_descriptor descriptor;
-
-		readdescriptor(((unsigned long)pdata->rx_desc +
-				  pdata->rx_head.bits.offset), &descriptor);
-		descriptor.data_transfer_length = pdata->rx_buf_per_desc;
-		descriptor.write = 1;
-		descriptor.pdu_length = 0;
-		descriptor.start_of_packet = 0;
-		descriptor.end_of_packet = 0;
-		descriptor.interrupt_on_completion = 1;
-		writedescriptor(((unsigned long)pdata->rx_desc +
-				   pdata->rx_head.bits.offset),
-				 &descriptor);
-		queue_increment(&pdata->rx_head, pdata->rx_num_desc);
-		updated_head_pointer = 1;
-	}
-
-	if (0 != updated_head_pointer)
-		write_mac(pdata->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
-
-	return packets;
-}
-
-/* ----------------------------------------------------------------------
- * lsinet_poll
- */
-
-static int lsinet_poll(struct napi_struct *napi, int budget)
-{
-	struct appnic_device *pdata =
-		container_of(napi, struct appnic_device, napi);
-	struct net_device *dev = pdata->device;
-
-	int work_done = 0;
-	unsigned long dma_interrupt_status;
-
-	do {
-		/* Acknowledge the RX interrupt. */
-		write_mac(~APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE, APPNIC_DMA_INTERRUPT_STATUS);
-
-		/* Get Rx packets. */
-		work_done += lsinet_rx_packets(dev, budget - work_done);
-
-		/* We've hit the budget limit. */
-		if (work_done == budget)
-			break;
-
-		dma_interrupt_status = read_mac(APPNIC_DMA_INTERRUPT_STATUS);
-
-	} while (RX_INTERRUPT(dma_interrupt_status));
-
-	if (work_done < budget) {
-		napi_complete(napi);
-
-		/* Re-enable receive interrupts (and preserve
-		 * the already enabled TX interrupt).
-		 */
-		write_mac((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
-			   APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
-			  APPNIC_DMA_INTERRUPT_ENABLE);
-	}
-
-	return work_done;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_isr
- */
-
-static irqreturn_t appnic_isr(int irq, void *device_id)
-{
-	struct net_device *dev = (struct net_device *)device_id;
-	struct appnic_device *pdata = netdev_priv(dev);
-	unsigned long dma_interrupt_status;
-	unsigned long dev_flags;
-	unsigned long tx_flags;
-
-	/* Acquire the lock. */
-	spin_lock_irqsave(&pdata->dev_lock, dev_flags);
-
-	/* Get the status. */
-	dma_interrupt_status = read_mac(APPNIC_DMA_INTERRUPT_STATUS);
-
-	/* NAPI - don't ack RX interrupt */
-	write_mac(APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
-		  APPNIC_DMA_INTERRUPT_STATUS);
-
-	/* Handle interrupts. */
-	if (TX_INTERRUPT(dma_interrupt_status)) {
-		/* transmition complete */
-		pdata->transmit_interrupts++;
-		spin_lock_irqsave(&pdata->tx_lock, tx_flags);
-		handle_transmit_interrupt(dev);
-		spin_unlock_irqrestore(&pdata->tx_lock, tx_flags);
-	}
-
-	if (RX_INTERRUPT(dma_interrupt_status)) {
-		pdata->receive_interrupts++;
-		if (napi_schedule_prep(&pdata->napi)) {
-			/* Disable RX interrupts and tell the
-			 * system we've got work
-			 */
-			write_mac(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
-				  APPNIC_DMA_INTERRUPT_ENABLE);
-			__napi_schedule(&pdata->napi);
-		} else {
-			write_mac(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
-				  APPNIC_DMA_INTERRUPT_ENABLE);
-		}
-	}
-
-	/* Release the lock */
-	spin_unlock_irqrestore(&pdata->dev_lock, dev_flags);
-
-	return IRQ_HANDLED;
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-
-/* ----------------------------------------------------------------------
- * appnic_poll_controller
- *
- * Polling receive - used by netconsole and other diagnostic tools
- * to allow network i/o with interrupts disabled.
- */
-
-static void appnic_poll_controller(struct net_device *dev)
-{
-	disable_irq(dev->irq);
-	appnic_isr(dev->irq, dev);
-	enable_irq(dev->irq);
-}
-
-#endif
-
-/* ----------------------------------------------------------------------
- * appnic_open
- *
- * Opens the interface.  The interface is opened whenever ifconfig
- * activates it.  The open method should register any system resource
- * it needs (I/O ports, IRQ, DMA, etc.) turn on the hardware, and
- * increment the module usage count.
- */
-
-static int appnic_open(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	int return_code = 0;
-
-	/* Bring the PHY up. */
-	phy_start(pdata->phy_dev);
-
-	/* Enable NAPI. */
-	napi_enable(&pdata->napi);
-
-	/* Install the interrupt handlers. */
-	return_code = request_irq(dev->irq, appnic_isr, 0x00, LSI_DRV_NAME, dev);
-	if (0 != return_code) {
-		pr_err("%s: request_irq() failed, returned 0x%x/%d\n",
-		       LSI_DRV_NAME, return_code, return_code);
-		return return_code;
-	}
-
-	/* Enable interrupts. */
-	write_mac((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
-		   APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
-		   APPNIC_DMA_INTERRUPT_ENABLE);
-
-	/* Let the OS know we are ready to send packets. */
-	netif_start_queue(dev);
-
-	/* That's all. */
-	return 0;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_stop
- *
- * Stops the interface.  The interface is stopped when it is brought
- * down; operations performed at open time should be reversed.
- */
-
-static int appnic_stop(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-
-	pr_info("%s: Stopping the interface.\n", LSI_DRV_NAME);
-
-	/* Disable interrupts. Note that disable_irq() will wait for
-	 * any interrupt handlers that are currently executing to
-	 * complete.
-	 */
-	write_mac(0, APPNIC_DMA_INTERRUPT_ENABLE);
-	disable_irq(dev->irq);
-	free_irq(dev->irq, dev);
-
-	/* Indicate to the OS that no more packets should be sent.  */
-	netif_stop_queue(dev);
-	napi_disable(&pdata->napi);
-
-	/* Stop the receiver and transmitter. */
-	disable_rx_tx(dev);
-
-	/* Bring the PHY down. */
-	if (pdata->phy_dev)
-		phy_stop(pdata->phy_dev);
-
-	/* That's all. */
-	return 0;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_hard_start_xmit
- *
- * The method initiates the transmission of a packet.  The full packet
- * (protocol headers and all) is contained in a socket buffer (sk_buff)
- * structure.
- *
- * ----- NOTES -----
- *
- * 1) This will not get called again by the kernel until it returns.
- */
-
-static int appnic_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	int length;
-	int buf_per_desc;
-	union appnic_queue_pointer queue;
-	unsigned long flags;
-
-	spin_lock_irqsave(&pdata->tx_lock, flags);
-
-	length = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
-	buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
-
-	/* If enough transmit descriptors are available, copy and transmit. */
-
-	queue = swab_queue_pointer(pdata->tx_tail);
-	while (((length / buf_per_desc) + 1) >=
-		queue_uninitialized(pdata->tx_head,
-				    queue,
-				    pdata->tx_num_desc)) {
-		handle_transmit_interrupt(dev);
-		queue = swab_queue_pointer(pdata->tx_tail);
-	}
-
-	if (((length / buf_per_desc) + 1) <
-		queue_uninitialized(pdata->tx_head, queue,
-				    pdata->tx_num_desc)) {
-		int bytes_copied = 0;
-		struct appnic_dma_descriptor descriptor;
-
-		readdescriptor(((unsigned long)pdata->tx_desc +
-				pdata->tx_head.bits.offset), &descriptor);
-		descriptor.start_of_packet = 1;
-
-		while (bytes_copied < length) {
-			descriptor.write = 1;
-			descriptor.pdu_length = length;
-
-			if ((length - bytes_copied) > buf_per_desc) {
-				memcpy((void *)
-					(descriptor.host_data_memory_pointer +
-					 pdata->dma_alloc_offset_tx),
-				       (void *) ((unsigned long) skb->data +
-					bytes_copied),
-					buf_per_desc);
-				descriptor.data_transfer_length = buf_per_desc;
-				descriptor.end_of_packet = 0;
-				descriptor.interrupt_on_completion = 0;
-				bytes_copied += buf_per_desc;
-			} else {
-				memcpy((void *)
-					(descriptor.host_data_memory_pointer +
-					 pdata->dma_alloc_offset_tx),
-				       (void *) ((unsigned long) skb->data +
-					bytes_copied),
-					(length - bytes_copied));
-				descriptor.data_transfer_length =
-				 (length - bytes_copied);
-				descriptor.end_of_packet = 1;
-				/* Leave TX interrupts disabled. We work
-				 * the same with or w/o them. Set to "1"
-				 * if we ever want to enable them though.
-				 */
-				descriptor.interrupt_on_completion = 0;
-				bytes_copied = length;
-			}
-
-			pdata->stats.tx_bytes += bytes_copied;
-			writedescriptor(((unsigned long) pdata->tx_desc +
-				pdata->tx_head.bits.offset), &descriptor);
-			queue_increment(&pdata->tx_head, pdata->tx_num_desc);
-			readdescriptor(((unsigned long)pdata->tx_desc +
-					 pdata->tx_head.bits.offset),
-					&descriptor);
-			descriptor.start_of_packet = 0;
-		}
-
-		/* Data sync barrier. */
-		rmb();
-
-		write_mac(pdata->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
-		netif_trans_update(dev);
-
-	} else {
-		pdata->out_of_tx_descriptors++;
-		pr_err("%s: No transmit descriptors available!\n",
-		       LSI_DRV_NAME);
-		spin_unlock_irqrestore(&pdata->tx_lock, flags);
-		return NETDEV_TX_BUSY;
-	}
-
-	spin_unlock_irqrestore(&pdata->tx_lock, flags);
-	/* Free the socket buffer. */
-	dev_kfree_skb(skb);
-
-	return NETDEV_TX_OK;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_net_device_stats
- *
- * Whenever an application needs to get statistics for the interface,
- * this method is called.  This happens, for example, when ifconfig or
- * nstat -i is run.
- */
-
-static struct net_device_stats *appnic_get_stats(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-
-	/* Update the statistics structure. */
-
-	get_hw_statistics(pdata);
-
-	return &pdata->stats;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_set_mac_address
- */
-
-static int appnic_set_mac_address(struct net_device *dev, void *data)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct sockaddr *address = data;
-	unsigned long swap_source_address;
-
-	if (netif_running(dev))
-		return -EBUSY;
-
-	if (!is_valid_ether_addr(address->sa_data))
-		return -EADDRNOTAVAIL;
-
-	memcpy(dev->dev_addr, address->sa_data, ETH_ALEN);
-	memcpy(dev->perm_addr, address->sa_data, ETH_ALEN);
-
-	swap_source_address = ((address->sa_data[4]) << 8) |
-			       address->sa_data[5];
-	write_mac(swap_source_address, APPNIC_SWAP_SOURCE_ADDRESS_2);
-	swap_source_address = ((address->sa_data[2]) << 8) |
-			address->sa_data[3];
-	write_mac(swap_source_address, APPNIC_SWAP_SOURCE_ADDRESS_1);
-	swap_source_address = ((address->sa_data[0]) << 8) |
-			       address->sa_data[1];
-	write_mac(swap_source_address, APPNIC_SWAP_SOURCE_ADDRESS_0);
-	memcpy(dev->dev_addr, address->sa_data, dev->addr_len);
-
-	return 0;
-}
-
-/* ======================================================================
- * ETHTOOL Operations
- * ======================================================================
- */
-
-enum {NETDEV_STATS, APPNIC_STATS};
-
-struct appnic_stats {
-	char stat_string[ETH_GSTRING_LEN];
-	int sizeof_stat;
-	int stat_offset;
-};
-
-#define APPNIC_STAT(str, m) { \
-		.stat_string = str, \
-		.sizeof_stat = sizeof(((struct appnic_device *)0)->m), \
-		.stat_offset = offsetof(struct appnic_device, m) }
-
-static const struct appnic_stats appnic_gstrings_stats[] = {
-	APPNIC_STAT("rx_packets", stats.rx_packets),
-	APPNIC_STAT("tx_packets", stats.tx_packets),
-	APPNIC_STAT("rx_bytes", stats.rx_bytes),
-	APPNIC_STAT("tx_bytes", stats.tx_bytes),
-	APPNIC_STAT("rx_errors", stats.rx_errors),
-	APPNIC_STAT("tx_errors", stats.tx_errors),
-	APPNIC_STAT("rx_dropped", stats.rx_dropped),
-	APPNIC_STAT("tx_dropped", stats.tx_dropped),
-	APPNIC_STAT("multicast", stats.multicast),
-	APPNIC_STAT("collisions", stats.collisions),
-	APPNIC_STAT("rx_length_errors", stats.rx_length_errors),
-	APPNIC_STAT("rx_crc_errors", stats.rx_crc_errors),
-	APPNIC_STAT("rx_frame_errors", stats.rx_frame_errors),
-	APPNIC_STAT("rx_fifo_errors", stats.rx_fifo_errors),
-	APPNIC_STAT("tx_fifo_errors", stats.tx_fifo_errors),
-
-	APPNIC_STAT("dropped_by_stack", dropped_by_stack),
-	APPNIC_STAT("out_of_tx_descriptors", out_of_tx_descriptors),
-	APPNIC_STAT("transmit_interrupts", transmit_interrupts),
-	APPNIC_STAT("receive_interrupts", receive_interrupts),
-};
-
-#define APPNIC_GLOBAL_STATS_LEN  ARRAY_SIZE(appnic_gstrings_stats)
-#define APPNIC_STATS_LEN (APPNIC_GLOBAL_STATS_LEN)
-
-/* ----------------------------------------------------------------------
- * appnic_get_ethtool_stats
- */
-
-static void appnic_get_ethtool_stats(struct net_device *dev,
-				     struct ethtool_stats *stats,
-				     u64 *data)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	int i;
-	char *p = NULL;
-
-	get_hw_statistics(pdata);
-	for (i = 0; i < APPNIC_GLOBAL_STATS_LEN; i++) {
-		p = (char *) pdata + appnic_gstrings_stats[i].stat_offset;
-		data[i] = (appnic_gstrings_stats[i].sizeof_stat ==
-			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
-	}
-}
-
-/* ----------------------------------------------------------------------
- * appnic_get_strings
- */
-
-static void appnic_get_strings(struct net_device *netdev, u32 stringset,
-			       u8 *data)
-{
-	u8 *p = data;
-	int i;
-
-	switch (stringset) {
-	case ETH_SS_STATS:
-		for (i = 0; i < APPNIC_GLOBAL_STATS_LEN; i++) {
-			memcpy(p, appnic_gstrings_stats[i].stat_string,
-			       ETH_GSTRING_LEN);
-			p += ETH_GSTRING_LEN;
-		}
-		break;
-	}
-}
-
-/* ----------------------------------------------------------------------
- * appnic_get_sset_count
- */
-
-static int appnic_get_sset_count(struct net_device *netdev, int sset)
-{
-	switch (sset) {
-	case ETH_SS_STATS:
-		return APPNIC_STATS_LEN;
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-/* ----------------------------------------------------------------------
- * appnic_get_drvinfo
- */
-
-static void appnic_get_drvinfo(struct net_device *dev,
-			       struct ethtool_drvinfo *info)
-{
-	strcpy(info->driver, LSI_DRV_NAME);
-	strcpy(info->version, LSI_DRV_VERSION);
-	strlcpy(info->bus_info, dev_name(dev->dev.parent),
-		sizeof(info->bus_info));
-}
-
-/* ----------------------------------------------------------------------
- * appnic_get_settings
- */
-
-static int appnic_get_settings(struct net_device *dev,
-			       struct ethtool_cmd *cmd)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct phy_device *phydev = pdata->phy_dev;
-
-	if (!phydev)
-		return -ENODEV;
-
-	return phy_ethtool_gset(phydev, cmd);
-}
-
-/* Fill in the struture...  */
-
-static const struct ethtool_ops appnic_ethtool_ops = {
-	.get_drvinfo		= appnic_get_drvinfo,
-	.get_settings		= appnic_get_settings,
-	.get_ethtool_stats	= appnic_get_ethtool_stats,
-	.get_strings		= appnic_get_strings,
-	.get_sset_count		= appnic_get_sset_count,
-};
-
-/* ======================================================================
- * Linux Module Interface.
- * ======================================================================
- */
-
-static const struct net_device_ops appnic_netdev_ops = {
-	.ndo_open = appnic_open,
-	.ndo_stop = appnic_stop,
-	.ndo_get_stats = appnic_get_stats,
-	.ndo_set_mac_address = appnic_set_mac_address,
-	.ndo_start_xmit = appnic_hard_start_xmit,
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller = appnic_poll_controller,
-#endif
-
-};
-
-/* ----------------------------------------------------------------------
- * appnic_init
- */
-
-int appnic_init(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	void *dma_offset;
-	int index;
-	unsigned long buf;
-	struct appnic_dma_descriptor descriptor;
-	struct sockaddr address;
-	unsigned long node_cfg;
-	int rc = 0;
-
-	/* Set FEMAC to uncached */
-	femac_uncache(pdata);
-
-	/* Reset the MAC. */
-
-	write_mac(0x80000000, APPNIC_DMA_PCI_CONTROL);
-
-	/* Allocate memory and initialize the descriptors. */
-
-	/* fixup num_[rt]x_desc. */
-
-	if (0 != (rx_num_desc % DESCRIPTOR_GRANULARITY)) {
-		pr_err("%s: rx_num_desc was not a multiple of %d.\n",
-		       LSI_DRV_NAME, DESCRIPTOR_GRANULARITY);
-		rc = -EINVAL;
-		goto err_param;
-	}
-
-	pdata->rx_num_desc = rx_num_desc;
-
-	if (0 != (tx_num_desc % DESCRIPTOR_GRANULARITY)) {
-		pr_err("%s: tx_num_desc was not a multiple of %d.\n",
-		       LSI_DRV_NAME, DESCRIPTOR_GRANULARITY);
-		rc = -EINVAL;
-		goto err_param;
-	}
-
-	pdata->tx_num_desc = tx_num_desc;
-
-	/* up [rt]x_buf_sz. Must be some multiple of 64 bytes
-	 * per descriptor.
-	 */
-
-	if (0 != (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc))) {
-		pr_err("%s: rx_buf_sz was not a multiple of %d.\n",
-		       LSI_DRV_NAME, (BUFFER_ALIGNMENT * rx_num_desc));
-		rc = -EINVAL;
-		goto err_param;
-	}
-
-	pdata->rx_buf_sz = rx_buf_sz;
-
-	if (0 != (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc))) {
-		pr_err("%s: tx_buf_sz was not a multiple of %d.\n",
-		       LSI_DRV_NAME, (BUFFER_ALIGNMENT * tx_num_desc));
-		rc = -EINVAL;
-		goto err_param;
-	}
-
-	pdata->tx_buf_sz = tx_buf_sz;
-
-	/* Allocate dma-able memory. Broken into smaller parts to keep
-	 * from allocating a single large chunk of memory, but not too
-	 * small since mappings obtained from dma_alloc_coherent() have
-	 * a minimum size of one page.
-	 */
-
-	pdata->dma_alloc_size =
-		/* The tail pointers (rx and tx) */
-		(sizeof(union appnic_queue_pointer) * 2) +
-		/* The RX descriptor ring (and padding to allow
-		 * 64 byte alignment)
-		 */
-		(sizeof(struct appnic_dma_descriptor) * pdata->rx_num_desc) +
-		(DESCRIPTOR_GRANULARITY) +
-		/* The TX descriptor ring (and padding...) */
-		(sizeof(struct appnic_dma_descriptor) * pdata->tx_num_desc) +
-		(DESCRIPTOR_GRANULARITY);
-
-	pdata->dma_alloc_size_rx =
-		/* The RX buffer (and padding...) */
-		(pdata->rx_buf_sz) + (BUFFER_ALIGNMENT);
-
-	pdata->dma_alloc_size_tx =
-		/* The TX buffer (and padding...) */
-		(pdata->tx_buf_sz) + (BUFFER_ALIGNMENT);
-
-	/* Allocate the buffers. */
-
-	rc = femac_alloc_mem_buffers(dev);
-	if (rc != 0) {
-		pr_err("%s: Can't allocate DMA-able memory!\n", LSI_DRV_NAME);
-		goto err_mem_buffers;
-	}
-
-	/* Initialize the tail pointers. */
-
-	dma_offset = pdata->dma_alloc;
-
-	pdata->rx_tail = (union appnic_queue_pointer *)dma_offset;
-	pdata->rx_tail_dma = (int)pdata->rx_tail - (int)pdata->dma_alloc_offset;
-	dma_offset += sizeof(union appnic_queue_pointer);
-	memset((void *)pdata->rx_tail, 0,
-	       sizeof(union appnic_queue_pointer));
-
-	pdata->tx_tail = (union appnic_queue_pointer *)dma_offset;
-	pdata->tx_tail_dma = (int)pdata->tx_tail - (int)pdata->dma_alloc_offset;
-	dma_offset += sizeof(union appnic_queue_pointer);
-	memset((void *)pdata->tx_tail, 0, sizeof(union appnic_queue_pointer));
-
-	/* Initialize the descriptor pointers. */
-
-	pdata->rx_desc = (struct appnic_dma_descriptor *)ALIGN64B(dma_offset);
-	pdata->rx_desc_dma = (int)pdata->rx_desc - (int)pdata->dma_alloc_offset;
-	dma_offset += (sizeof(struct appnic_dma_descriptor) *
-			pdata->rx_num_desc) + (DESCRIPTOR_GRANULARITY);
-	memset((void *)pdata->rx_desc, 0,
-	       (sizeof(struct appnic_dma_descriptor) * pdata->rx_num_desc));
-
-	pdata->tx_desc = (struct appnic_dma_descriptor *)ALIGN64B(dma_offset);
-	pdata->tx_desc_dma = (int)pdata->tx_desc - (int)pdata->dma_alloc_offset;
-	dma_offset += (sizeof(struct appnic_dma_descriptor) *
-			pdata->tx_num_desc) + (DESCRIPTOR_GRANULARITY);
-	memset((void *)pdata->tx_desc, 0,
-	       (sizeof(struct appnic_dma_descriptor) * pdata->tx_num_desc));
-
-	/* Initialize the buffer pointers. */
-
-	dma_offset = pdata->dma_alloc_rx;
-
-	pdata->rx_buf = (void *)ALIGN64B(dma_offset);
-	pdata->rx_buf_dma = (int)pdata->rx_buf -
-				(int)pdata->dma_alloc_offset_rx;
-	pdata->rx_buf_per_desc = pdata->rx_buf_sz / pdata->rx_num_desc;
-
-	dma_offset = pdata->dma_alloc_tx;
-
-	pdata->tx_buf = (void *)ALIGN64B(dma_offset);
-	pdata->tx_buf_dma = (int)pdata->tx_buf -
-				(int)pdata->dma_alloc_offset_tx;
-	pdata->tx_buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
-
-	/* Initialize the descriptors. */
-
-	buf = (unsigned long)pdata->rx_buf_dma;
-	for (index = 0; index < pdata->rx_num_desc; ++index) {
-		memset((void *) &descriptor, 0,
-		       sizeof(struct appnic_dma_descriptor));
-		descriptor.write = 1;
-		descriptor.interrupt_on_completion = 1;
-		descriptor.host_data_memory_pointer = buf;
-		descriptor.data_transfer_length = pdata->rx_buf_per_desc;
-
-		writedescriptor(((unsigned long)pdata->rx_desc + (index *
-				sizeof(struct appnic_dma_descriptor))),
-				&descriptor);
-
-		buf += pdata->rx_buf_per_desc;
-	}
-
-	buf = (unsigned long)pdata->tx_buf_dma;
-
-	for (index = 0; index < pdata->tx_num_desc; ++index) {
-		memset((void *) &descriptor, 0,
-		       sizeof(struct appnic_dma_descriptor));
-		descriptor.write = 1;
-		descriptor.interrupt_on_completion = 1;
-		descriptor.host_data_memory_pointer = buf;
-
-		writedescriptor(((unsigned long)pdata->tx_desc + (index *
-				 sizeof(struct appnic_dma_descriptor))),
-				&descriptor);
-
-		buf += pdata->tx_buf_per_desc;
-	}
-
-	/* Initialize the spinlocks. */
-
-	spin_lock_init(&pdata->dev_lock);
-	spin_lock_init(&pdata->tx_lock);
-
-	/* Take MAC out of reset. */
-
-	write_mac(0x0, APPNIC_RX_SOFT_RESET);
-	write_mac(0x1, APPNIC_RX_MODE);
-	write_mac(0x0, APPNIC_TX_SOFT_RESET);
-	write_mac(0x1, APPNIC_TX_MODE);
-
-	/* Set the watermark. */
-
-	ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &node_cfg);
-
-	if (0 == (0x80000000 & node_cfg))
-		write_mac(0x300a, APPNIC_TX_WATERMARK);
-	else
-		write_mac(0xc00096, APPNIC_TX_WATERMARK);
-
-	write_mac(0x1, APPNIC_TX_HALF_DUPLEX_CONF);
-	write_mac(0xffff, APPNIC_TX_TIME_VALUE_CONF);
-	write_mac(0x1, APPNIC_TX_INTERRUPT_CONTROL);
-	write_mac(0x5275, APPNIC_TX_EXTENDED_CONF);
-	write_mac(0x1, APPNIC_RX_INTERNAL_INTERRUPT_CONTROL);
-	write_mac(0x1, APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL);
-	write_mac(0x40010000, APPNIC_DMA_PCI_CONTROL);
-	write_mac(0x30000, APPNIC_DMA_CONTROL);
-#ifdef CONFIG_ARM
-	writel(0x280044,
-	       (void __iomem *)((unsigned long)pdata->dma_base + 0x60));
-	writel(0xc0,
-	       (void __iomem *)((unsigned long)pdata->dma_base + 0x64));
-#else
-	out_le32((unsigned *)pdata->dma_base + 0x60, 0x280044);
-	out_le32((unsigned *)pdata->dma_base + 0x64, 0xc0);
-#endif
-
-	/* Set the MAC address. */
-	pr_info("%s: MAC %pM\n", LSI_DRV_NAME, dev->dev_addr);
-
-	memcpy(&(address.sa_data[0]), dev->dev_addr, ETH_ALEN);
-	rc = appnic_set_mac_address(dev, &address);
-	if (rc != 0) {
-		pr_err("%s: Unable to set MAC address!\n", LSI_DRV_NAME);
-		goto err_set_mac_addr;
-	}
-
-	/* Initialize the queue pointers. */
-
-	/* Receiver. */
-
-	memset((void *)&pdata->rx_tail_copy, 0,
-	       sizeof(union appnic_queue_pointer));
-	memset((void *)&pdata->rx_head, 0,
-	       sizeof(union appnic_queue_pointer));
-
-	write_mac(pdata->rx_desc_dma, APPNIC_DMA_RX_QUEUE_BASE_ADDRESS);
-	write_mac((pdata->rx_num_desc *
-		   sizeof(struct appnic_dma_descriptor)) / 1024,
-		  APPNIC_DMA_RX_QUEUE_SIZE);
-
-	/* Indicate that all of the receive descriptors
-	 * are ready.
-	 */
-
-	pdata->rx_head.bits.offset = (pdata->rx_num_desc - 1) *
-					sizeof(struct appnic_dma_descriptor);
-	write_mac(pdata->rx_tail_dma, APPNIC_DMA_RX_TAIL_POINTER_ADDRESS);
-
-	/* N.B.
-	 *
-	 * The boot loader may have used the NIC.  If so, the
-	 * tail pointer must be read and the head pointer (and
-	 * local copy of the tail) based on it.
-	 */
-
-	pdata->rx_tail->raw =
-		  read_mac(APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY);
-	pdata->rx_tail_copy.raw = pdata->rx_tail->raw;
-	pdata->rx_head.raw = pdata->rx_tail->raw;
-	queue_decrement(&pdata->rx_head, pdata->rx_num_desc);
-	pdata->rx_head.bits.generation_bit =
-		  (0 == pdata->rx_head.bits.generation_bit) ? 1 : 0;
-	write_mac(pdata->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
-
-	/* Transmitter. */
-
-	memset((void *) &pdata->tx_tail_copy, 0,
-	       sizeof(union appnic_queue_pointer));
-	memset((void *) &pdata->tx_head, 0,
-	       sizeof(union appnic_queue_pointer));
-
-	write_mac(pdata->tx_desc_dma, APPNIC_DMA_TX_QUEUE_BASE_ADDRESS);
-	write_mac((pdata->tx_num_desc *
-		   sizeof(struct appnic_dma_descriptor)) / 1024,
-		  APPNIC_DMA_TX_QUEUE_SIZE);
-	write_mac(pdata->tx_tail_dma, APPNIC_DMA_TX_TAIL_POINTER_ADDRESS);
-
-	/* N.B.
-	 *
-	 * The boot loader may have used the NIC.  If so, the
-	 * tail pointer must be read and the head pointer (and
-	 * local copy of the tail) based on it.
-	 */
-
-	pdata->tx_tail->raw = read_mac(APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY);
-	pdata->tx_tail_copy.raw = pdata->tx_tail->raw;
-	pdata->tx_head.raw = pdata->tx_tail->raw;
-	write_mac(pdata->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
-
-	/* Clear statistics. */
-
-	clear_statistics(pdata);
-
-	/* Fill in the net_device structure. */
-
-	ether_setup(dev);
-
-	/* Setup IRQ. */
-	rc = femac_irq_setup(dev);
-	if (rc != 0) {
-		pr_err("%s: IRQ setup failed!\n", LSI_DRV_NAME);
-		goto err_irq_setup;
-	}
-
-	dev->netdev_ops = &appnic_netdev_ops;
-	dev->ethtool_ops = &appnic_ethtool_ops;
-	dev->features |= NETIF_F_LLTX;
-
-	memset((void *) &pdata->napi, 0, sizeof(struct napi_struct));
-	netif_napi_add(dev, &pdata->napi,
-		       lsinet_poll, LSINET_NAPI_WEIGHT);
-	pdata->device = dev;
-
-	return 0;
-
-err_irq_setup:
-err_set_mac_addr:
-	femac_free_mem_buffers(dev);
-err_mem_buffers:
-err_param:
-	return rc;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_probe_config_dt
- */
-
-#ifdef CONFIG_OF
-static int appnic_probe_config_dt(struct net_device *dev,
-				  struct device_node *np)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	const u32 *field;
-	const char *mac;
-	const char *macspeed;
-#ifdef CONFIG_ARM
-	struct device_node *gp_node;
-#else
-	u64 value64;
-	u32 value32;
-#endif
-
-	if (!np)
-		return -ENODEV;
-
-#ifdef CONFIG_ARM
-	gp_node = of_find_compatible_node(NULL, NULL, "lsi,gpreg");
-	if (!gp_node) {
-		pr_err("%s: DTS is missing mode 'gpreg'\n", LSI_DRV_NAME);
-		return -ENODEV;
-	}
-	pdata->gpreg_base = of_iomap(gp_node, 0);
-
-	pdata->rx_base = of_iomap(np, 0);
-	pdata->tx_base = of_iomap(np, 1);
-	pdata->dma_base = of_iomap(np, 2);
-
-	pdata->tx_interrupt = irq_of_parse_and_map(np, 0);
-	pdata->rx_interrupt = irq_of_parse_and_map(np, 1);
-	pdata->dma_interrupt = irq_of_parse_and_map(np, 2);
-#else
-	field = of_get_property(np, "enabled", NULL);
-
-	if (!field || (field && (0 == *field)))
-		goto device_tree_failed;
-
-	field = of_get_property(np, "reg", NULL);
-
-	if (!field)
-		goto device_tree_failed;
-
-	value64 = of_translate_address(np, field);
-	value32 = field[3];
-	field += 2;
-	pdata->rx_base = ioremap(value64, value32);
-	value64 = of_translate_address(np, field);
-	value32 = field[3];
-	field += 2;
-	pdata->tx_base = ioremap(value64, value32);
-	value64 = of_translate_address(np, field);
-	value32 = field[3];
-	field += 2;
-	pdata->dma_base = ioremap(value64, value32);
-
-	field = of_get_property(np, "interrupts", NULL);
-	if (!field)
-		goto device_tree_failed;
-	else
-		pdata->dma_interrupt = field[0];
-#endif
-
-	field = of_get_property(np, "mdio-clock", NULL);
-	if (!field)
-		goto device_tree_failed;
-	else
-		pdata->mdio_clock = ntohl(field[0]);
-
-	field = of_get_property(np, "phy-address", NULL);
-	if (!field)
-		goto device_tree_failed;
-	else
-		pdata->phy_address = ntohl(field[0]);
-
-	field = of_get_property(np, "ad-value", NULL);
-	if (!field)
-		goto device_tree_failed;
-	else
-		pdata->ad_value = ntohl(field[0]);
-
-	macspeed = of_get_property(np, "phy-link", NULL);
-
-	if (macspeed) {
-		if (0 == strncmp(macspeed, "auto", strlen("auto"))) {
-			pdata->phy_link_auto = 1;
-		} else if (0 == strncmp(macspeed, "100MF", strlen("100MF"))) {
-			pdata->phy_link_auto = 0;
-			pdata->phy_link_speed = 1;
-			pdata->phy_link_duplex = 1;
-		} else if (0 == strncmp(macspeed, "100MH", strlen("100MH"))) {
-			pdata->phy_link_auto = 0;
-			pdata->phy_link_speed = 1;
-			pdata->phy_link_duplex = 0;
-		} else if (0 == strncmp(macspeed, "10MF", strlen("10MF"))) {
-			pdata->phy_link_auto = 0;
-			pdata->phy_link_speed = 0;
-			pdata->phy_link_duplex = 1;
-		} else if (0 == strncmp(macspeed, "10MH", strlen("10MH"))) {
-			pdata->phy_link_auto = 0;
-			pdata->phy_link_speed = 0;
-			pdata->phy_link_duplex = 0;
-		} else {
-			pr_err("Invalid phy-link value \"%s\" in DTS. Defaulting to \"auto\".\n", macspeed);
-			pdata->phy_link_auto = 1;
-		}
-	} else {
-		/* Auto is the default. */
-		pdata->phy_link_auto = 1;
-	}
-
-	mac = of_get_mac_address(np);
-	if (!mac)
-		goto device_tree_failed;
-
-	memcpy(&pdata->mac_addr[0], mac, ETH_ALEN);
-	memcpy(dev->dev_addr, mac, ETH_ALEN);
-	memcpy(dev->perm_addr, mac, ETH_ALEN);
-
-	return 0;
-
-device_tree_failed:
-	pr_err("%s: Reading Device Tree Failed\n", LSI_DRV_NAME);
-#ifdef CONFIG_ARM
-	iounmap(pdata->gpreg_base);
-#endif
-	iounmap(pdata->rx_base);
-	iounmap(pdata->tx_base);
-	iounmap(pdata->dma_base);
-
-	return -EINVAL;
-}
-#else
-static inline int appnic_probe_config_dt(struct net_device *dev,
-					 struct device_node *np)
-{
-	return -ENODEV;
-}
-#endif /* CONFIG_OF */
-
-/* ----------------------------------------------------------------------
- * appnic_drv_probe
- */
-
-static int appnic_drv_probe(struct platform_device *pdev)
-{
-	int rc = 0;
-	struct device_node *np = pdev->dev.of_node;
-	struct net_device *dev;
-	struct appnic_device *pdata;
-
-	pr_info("%s: LSI(R) 10/100 Network Driver - version %s\n",
-		LSI_DRV_NAME, LSI_DRV_VERSION);
-
-	/* Allocate space for the device. */
-
-	dev = alloc_etherdev(sizeof(struct appnic_device));
-	if (!dev) {
-		pr_err("%s: Couldn't allocate net device.\n", LSI_DRV_NAME);
-		rc = -ENOMEM;
-		goto err_alloc_etherdev;
-	}
-
-	SET_NETDEV_DEV(dev, &pdev->dev);
-	platform_set_drvdata(pdev, dev);
-
-	pdata = netdev_priv(dev);
-
-	/* Get the physical addresses, interrupt number, etc. from the
-	 * device tree.  If no entry exists (older boot loader...) just
-	 * use the pre-devicetree method.
-	 */
-
-	rc = appnic_probe_config_dt(dev, np);
-
-	if (rc == -EINVAL) {
-		goto err_inval;
-	} else if (rc == -EINVAL) {
-#ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
-
-		/* The attempt to get device settings from the DTB failed, so
-		 * try to grab the ethernet MAC from the u-boot environment
-		 * and use hard-coded values for device base addresses.
-		 */
-
-		unsigned char ethaddr_string[20];
-
-		if (0 != ubootenv_get("ethaddr", ethaddr_string)) {
-			pr_err("%s: Could not read ethernet address!\n",
-			       LSI_DRV_NAME);
-			rc = -EINVAL;
-			goto err_inval;
-		} else {
-			u8 mac_address[ETH_ALEN];
-			int i = 0;
-			char *string = ethaddr_string;
-
-			while ((0 != string) && (ETH_ALEN > i)) {
-				char *value;
-				unsigned long res;
-
-				value = strsep(&string, ":");
-				if (kstrtoul(value, 16, &res))
-					return -EBUSY;
-				mac_address[i++] = (u8)res;
-			}
-
-			memcpy(dev->dev_addr, mac_address, ETH_ALEN);
-			memcpy(dev->perm_addr, mac_address, ETH_ALEN);
-			dev->addr_len = ETH_ALEN;
-
-			pr_info("%s: Using Static Addresses and Interrupts",
-				LSI_DRV_NAME);
-			pdata->rx_base = ioremap(0x002000480000ULL, 0x1000);
-			pdata->tx_base = ioremap(0x002000481000ULL, 0x1000);
-			pdata->dma_base = ioremap(0x002000482000ULL, 0x1000);
-			pdata->dma_interrupt = 33;
-		}
-#else
-		/* Neither dtb info nor ubootenv driver found. */
-		pr_err("%s: Could not read ethernet address!", LSI_DRV_NAME);
-		rc = -EINVAL;
-		goto err_inval;
-#endif
-	}
-
-#ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
-
-	{
-		unsigned char uboot_env_string[20];
-
-		/* Override ad_value with u-boot environment variable if set. */
-		if (0 == ubootenv_get("ad_value", uboot_env_string)) {
-			/* Assume ad_value is always entered as a hex value,
-			 * since u-boot defaults this value as hex.
-			 */
-			unsigned long res;
-
-			if (kstrtoul(uboot_env_string, 16, &res)) {
-				rc = -EINVAL;
-				goto err_inval;
-			}
-			pdata->ad_value = res;
-		}
-	}
-
-#endif
-
-	/* Initialize the device. */
-	rc = appnic_init(dev);
-	if (0 != rc) {
-		pr_err("%s: appnic_init() failed: %d\n", LSI_DRV_NAME, rc);
-		rc = -ENODEV;
-		goto err_nodev;
-	}
-
-	/* Register the device. */
-	rc = register_netdev(dev);
-	if (0 != rc) {
-		pr_err("%s: register_netdev() failed: %d\n", LSI_DRV_NAME, rc);
-		rc = -ENODEV;
-		goto err_nodev;
-	}
-
-	/* Initialize the PHY. */
-	rc = appnic_mii_init(pdev, dev);
-	if (rc) {
-		pr_warn("%s: Failed to initialize PHY", LSI_DRV_NAME);
-		rc = -ENODEV;
-		goto err_mii_init;
-	}
-
-	return 0;
-
-err_mii_init:
-	unregister_netdev(dev);
-err_nodev:
-err_inval:
-	free_netdev(dev);
-err_alloc_etherdev:
-	return rc;
-}
-
-/* ----------------------------------------------------------------------
- * appnic_drv_remove
- */
-
-static int appnic_drv_remove(struct platform_device *pdev)
-{
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct appnic_device *pdata = NULL;
-
-	pr_info("%s: Stopping driver", LSI_DRV_NAME);
-
-	BUG_ON(!dev);
-	pdata = netdev_priv(dev);
-	BUG_ON(!pdata);
-	BUG_ON(!pdata->phy_dev);
-	phy_disconnect(pdata->phy_dev);
-	pdata->phy_dev = NULL;
-	mdiobus_unregister(pdata->mii_bus);
-	mdiobus_free(pdata->mii_bus);
-	platform_set_drvdata(pdev, NULL);
-	unregister_netdev(dev);
-	free_irq(dev->irq, dev);
-	femac_free_mem_buffers(dev);
-	free_netdev(dev);
-
-	iounmap(pdata->rx_base);
-	iounmap(pdata->tx_base);
-	iounmap(pdata->dma_base);
-#ifdef CONFIG_ARM
-	iounmap(pdata->gpreg_base);
-#endif
-
-	return 0;
-}
-
-static const struct of_device_id appnic_dt_ids[] = {
-	{ .compatible = "lsi,acp-femac", },
-	{ .compatible = "acp-femac", },
-	{ /* end of list */ },
-};
-MODULE_DEVICE_TABLE(of, appnic_dt_ids);
-
-static struct platform_driver appnic_driver = {
-	.probe = appnic_drv_probe,
-	.remove = appnic_drv_remove,
-	.driver = {
-		.name   = LSI_DRV_NAME,
-		.owner  = THIS_MODULE,
-		.pm     = NULL,
-		.of_match_table = appnic_dt_ids,
-	},
-};
-
-module_platform_driver(appnic_driver);
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.h b/drivers/net/ethernet/lsi/lsi_acp_net.h
deleted file mode 100644
index 9f5ae1d..0000000
--- a/drivers/net/ethernet/lsi/lsi_acp_net.h
+++ /dev/null
@@ -1,669 +0,0 @@
-/*
- * drivers/net/ethernet/lsi/lsi_acp_net.h
- *
- * Copyright (C) 2013 LSI Corporation.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.
- */
-
-#ifndef _LSI_ACP_NET_H
-#define _LSI_ACP_NET_H
-
-#ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
-extern int ubootenv_get(const char *, char *);
-#endif
-
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
-
-/* This is the maximum number of packets to be received every
- * NAPI poll
- */
-#define LSINET_NAPI_WEIGHT	64
-
-/* This is the maximum number of bytes that serve to hold
- * incoming Rx data.
- */
-#define LSINET_MAX_MTU		(ETH_DATA_LEN + 100) /* MTU + padding */
-
-/* Device Data Structures */
-
-struct appnic_dma_descriptor {
-
-#ifdef __LITTLE_ENDIAN
-	/* Word 0 */
-	/* 00=Fill|01=Block|10=Scatter */
-	unsigned long transfer_type:2;
-	unsigned long write:1;
-	unsigned long start_of_packet:1;
-	unsigned long end_of_packet:1;
-	unsigned long interrupt_on_completion:1;
-	unsigned long error:1;
-	/* big endian to little endian */
-	unsigned long byte_swapping_on:1;
-	unsigned long unused:24;
-
-	/* Word 1 */
-	unsigned long data_transfer_length:16;
-	unsigned long pdu_length:16;
-
-	/* Word 2 */
-	unsigned long target_memory_address;
-
-	/* Word 3 */
-	unsigned long host_data_memory_pointer;
-#else
-	/* Word 0 */
-	unsigned long unused:24;
-	/* big endian to little endian */
-	unsigned long byte_swapping_on:1;
-	unsigned long error:1;
-	unsigned long interrupt_on_completion:1;
-	unsigned long end_of_packet:1;
-	unsigned long start_of_packet:1;
-	unsigned long write:1;
-	/* 00=Fill|01=Block|10=Scatter */
-	unsigned long transfer_type:2;
-
-	/* Word 1 */
-	unsigned long pdu_length:16;
-	unsigned long data_transfer_length:16;
-
-	/* Word 2 */
-	unsigned long target_memory_address;
-
-	/* Word 3 */
-	unsigned long host_data_memory_pointer;
-#endif
-
-} __packed;
-
-union appnic_queue_pointer {
-
-	unsigned long raw;
-
-	struct {
-#ifdef __LITTLE_ENDIAN
-		unsigned long offset:20;
-		unsigned long generation_bit:1;
-		unsigned long unused:11;
-#else
-		unsigned long unused:11;
-		unsigned long generation_bit:1;
-		unsigned long offset:20;
-#endif
-	} __packed bits;
-
-} __packed;
-
-/* The appnic Device Structure */
-
-struct appnic_device {
-
-	/* net_device */
-	struct net_device *device;
-
-	/* Addresses, Interrupt, and PHY stuff. */
-	void __iomem *rx_base;
-	void __iomem *tx_base;
-	void __iomem *dma_base;
-#ifdef CONFIG_ARM
-	void __iomem *gpreg_base;
-#endif
-	unsigned long tx_interrupt;
-	unsigned long rx_interrupt;
-	unsigned long dma_interrupt;
-	unsigned long mdio_clock;
-	unsigned long phy_address;
-	unsigned long ad_value;
-	unsigned long phy_link_auto;
-	unsigned long phy_link_speed;
-	unsigned long phy_link_duplex;
-	unsigned char mac_addr[6];
-
-	/* NAPI */
-	struct napi_struct napi;
-
-	/* Statistics */
-	struct net_device_stats stats;
-	unsigned long dropped_by_stack;
-	unsigned long out_of_tx_descriptors;
-	unsigned long transmit_interrupts;
-	unsigned long receive_interrupts;
-
-	/* DMA-able memory */
-	int dma_alloc_size;
-	int dma_alloc_size_rx;
-	int dma_alloc_size_tx;
-	void *dma_alloc;
-	void *dma_alloc_rx;
-	void *dma_alloc_tx;
-	dma_addr_t dma_alloc_dma;
-	dma_addr_t dma_alloc_dma_rx;
-	dma_addr_t dma_alloc_dma_tx;
-	int dma_alloc_offset;
-	int dma_alloc_offset_rx;
-	int dma_alloc_offset_tx;
-
-	/* tail pointers */
-	volatile union appnic_queue_pointer *rx_tail;
-	dma_addr_t rx_tail_dma;
-	volatile union appnic_queue_pointer *tx_tail;
-	dma_addr_t tx_tail_dma;
-
-	/* descriptors */
-	struct appnic_dma_descriptor *rx_desc;
-	dma_addr_t rx_desc_dma;
-	unsigned rx_num_desc;
-	struct appnic_dma_descriptor *tx_desc;
-	dma_addr_t tx_desc_dma;
-	unsigned tx_num_desc;
-
-	/* buffers */
-	unsigned rx_buf_sz;
-	unsigned rx_buf_per_desc;
-	void *rx_buf;
-	dma_addr_t rx_buf_dma;
-	unsigned tx_buf_sz;
-	unsigned tx_buf_per_desc;
-	void *tx_buf;
-	dma_addr_t tx_buf_dma;
-
-	/* The local pointers */
-	union appnic_queue_pointer rx_tail_copy;
-	union appnic_queue_pointer rx_head;
-	union appnic_queue_pointer tx_tail_copy;
-	union appnic_queue_pointer tx_head;
-
-	/* Spin Lock */
-	spinlock_t dev_lock;
-	spinlock_t tx_lock;
-
-	/* PHY */
-	struct mii_bus *mii_bus;
-	struct phy_device *phy_dev;
-	int phy_irq[PHY_MAX_ADDR];
-	unsigned int link;
-	unsigned int speed;
-	unsigned int duplex;
-};
-
-/* GPREG FEMAC HPROT Register --------------------------------------- */
-
-#define GPREG_HPROT_FEMAC	((unsigned long)pdata->gpreg_base + 0x78)
-
-/* Overview
- * --------
- *
- * Register offset decoding is as follows:
- *
- * Bit(s) Description
- *
- * 16:15  define the Channel.  There is only one; therefore, 00.
- * 14:12  define the MAC within the channel.  Only one so 000.
- * 11:10  define the register "space" as follows:
- * 00 = fast ethernet MACmw.l 06000000 ffffffff 3200000
- * 10 = global
- * 11 = interrupt
- * 9: 2  register
- * 1: 0  always 00, 32 bit registers only.
- *
- * Receive registers start at the base address.  Transmit registers start
- * at 0x20000 above the base address.  DMA start at a completely different
- * base address (in this case 0x8000000 above the base).
- *
-*/
-
-/* Receive Configuration -------------------------------------------- */
-
-#define APPNIC_RX_CONF		((unsigned long)pdata->rx_base + 0x004c)
-#define APPNIC_RX_CONF_ENABLE   0x0001
-/* Pass Any Packet */
-#define APPNIC_RX_CONF_PAP	0x0002
-#define APPNIC_RX_CONF_JUMBO9K  0x0008
-#define APPNIC_RX_CONF_STRIPCRC 0x0010
-/* Accept All MAC Types */
-#define APPNIC_RX_CONF_AMT	0x0020
-/* Accept Flow Control */
-#define APPNIC_RX_CONF_AFC	0x0040
-/* Enable VLAN */
-#define APPNIC_RX_CONF_VLAN	0x0200
-/* RX MAC Speed, 1=100MBS */
-#define APPNIC_RX_CONF_SPEED    0x0800
-/* 1=Duplex Mode */
-#define APPNIC_RX_CONF_DUPLEX   0x1000
-/* 1=Enable */
-#define APPNIC_RX_CONF_LINK	0x2000
-/* Determines the action taken when the FE MAC
- * receives an Flow Control packet in FD mode.
- */
-#define APPNIC_RX_CONF_RXFCE    0x4000
-
-/* Controls the insertion of Flow Control packets
- * by the MAC transmitter.
- */
-#define APPNIC_RX_CONF_TXFCE    0x8000
-
-/* Receive Stat Overflow -------------------------------------------- */
-
-#define APPNIC_RX_STAT_OVERFLOW ((unsigned long)pdata->rx_base + 0x278)
-
-/* Receive Stat Undersize ------------------------------------------- */
-
-#define APPNIC_RX_STAT_UNDERSIZE ((unsigned long)pdata->rx_base + 0x280)
-
-/* Receive Stat Oversize -------------------------------------------- */
-
-#define APPNIC_RX_STAT_OVERSIZE ((unsigned long)pdata->rx_base + 0x2b8)
-
-/* Receive Stat Multicast ------------------------------------------- */
-
-#define APPNIC_RX_STAT_MULTICAST ((unsigned long)pdata->rx_base + 0x2d0)
-
-/* Receive Stat Packet OK ------------------------------------------- */
-
-#define APPNIC_RX_STAT_PACKET_OK ((unsigned long)pdata->rx_base + 0x2c0)
-
-/* Receive Stat CRC Error ------------------------------------------- */
-
-#define APPNIC_RX_STAT_CRC_ERROR ((unsigned long)pdata->rx_base + 0x2c8)
-
-/* Receive Stat Align Error ----------------------------------------- */
-
-#define APPNIC_RX_STAT_ALIGN_ERROR ((unsigned long)pdata->rx_base + 0x2e8)
-
-/* Receive Ethernet Mode -------------------------------------------- */
-
-#define APPNIC_RX_MODE ((unsigned long)pdata->rx_base + 0x0800)
-#define APPNIC_RX_MODE_ETHERNET_MODE_ENABLE 0x00001
-
-/* Receive Soft Reset ----------------------------------------------- */
-
-#define APPNIC_RX_SOFT_RESET ((unsigned long)pdata->rx_base + 0x0808)
-#define APPNIC_RX_SOFT_RESET_MAC_0 0x00001
-
-/* Receive Internal Interrupt Control ------------------------------- */
-
-#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL \
-	((unsigned long)pdata->rx_base + 0xc00)
-#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
-
-/* Receive External Interrupt Control ------------------------------- */
-
-#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL \
-	((unsigned long)pdata->rx_base + 0xc04)
-#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0_HIGH_LOW 0x10
-#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
-
-/* Receive Interrupt Status ----------------------------------------- */
-
-#define APPNIC_RX_INTERRUPT_STATUS ((unsigned long)pdata->rx_base + 0xc20)
-#define APPNIC_RX_INTERRUPT_EXTERNAL_STATUS_MAC_0 0x10
-#define APPNIC_RX_INTERRUPT_INTERNAL_STATUS_MAC_0 0x1
-
-/* Transmit Watermark ----------------------------------------------- */
-
-#define APPNIC_TX_WATERMARK ((unsigned long)pdata->tx_base + 0x18)
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_ASSERT 0x8000
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_DISABLE 0x4000
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_HIGH 0x3f00
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_LOW 0x3f
-
-/* Swap Source Address Registers ------------------------------------ */
-
-#define APPNIC_SWAP_SOURCE_ADDRESS_2 ((unsigned long)pdata->tx_base + 0x20)
-#define APPNIC_SWAP_SOURCE_ADDRESS_1 ((unsigned long)pdata->tx_base + 0x24)
-#define APPNIC_SWAP_SOURCE_ADDRESS_0 ((unsigned long)pdata->tx_base + 0x28)
-
-/* Transmit Extended Configuration ---------------------------------- */
-
-#define APPNIC_TX_EXTENDED_CONF ((unsigned long)pdata->tx_base + 0x30)
-#define APPNIC_TX_EXTENDED_CONF_TRANSMIT_COLLISION_WATERMARK_LEVEL 0xf000
-#define APPNIC_TX_EXTENDED_CONF_EXCESSIVE_DEFFERED_PACKET_DROP 0x200
-#define APPNIC_TX_EXTENDED_CONF_JUMBO9K 0x100
-#define APPNIC_TX_EXTENDED_CONF_LATE_COLLISION_WINDOW_COUNT 0xff
-
-/* Transmit Half Duplex Configuration ------------------------------- */
-
-#define APPNIC_TX_HALF_DUPLEX_CONF ((unsigned long)pdata->tx_base + 0x34)
-#define APPNIC_TX_HALF_DUPLEX_CONF_RANDOM_SEED_VALUE 0xff
-
-/* Transmit Configuration ------------------------------------------- */
-
-#define APPNIC_TX_CONF	((unsigned long)pdata->tx_base + 0x0050)
-#define APPNIC_TX_CONF_ENABLE_SWAP_SA	0x8000
-#define APPNIC_TX_CONF_LINK		0x2000
-#define APPNIC_TX_CONF_DUPLEX		0x1000
-#define APPNIC_TX_CONF_SPEED		0x0800
-#define APPNIC_TX_CONF_XBK_RST_RX_NTX	0x0600
-#define APPNIC_TX_CONF_IFG		0x01f0
-#define APPNIC_TX_CONF_APP_CRC_ENABLE	0x0004
-#define APPNIC_TX_CONF_PAD_ENABLE	0x0002
-#define APPNIC_TX_CONF_ENABLE		0x0001
-
-#define TX_CONF_SET_IFG(tx_configuration, ifg)			\
-	do {							\
-		(tx_configuration) &= ~APPNIC_TX_CONF_IFG;	\
-		(tx_configuration) |= ((ifg & 0x1f) << 4);	\
-	} while (0)
-
-/* Transmit Time Value Configuration -------------------------------- */
-
-#define APPNIC_TX_TIME_VALUE_CONF ((unsigned long)pdata->tx_base + 0x5c)
-#define APPNIC_TX_TIME_VALUE_CONF_PAUSE_VALUE 0xffff
-
-/* Transmit Stat Underrun ------------------------------------------- */
-
-#define APPNIC_TX_STAT_UNDERRUN ((unsigned long)pdata->tx_base + 0x300)
-
-/* Transmit Stat Packet OK ------------------------------------------ */
-
-#define APPNIC_TX_STAT_PACKET_OK ((unsigned long)pdata->tx_base + 0x318)
-
-/* Transmit Stat Undersize ------------------------------------------ */
-
-#define APPNIC_TX_STAT_UNDERSIZE ((unsigned long)pdata->tx_base + 0x350)
-
-/* Transmit Status Late Collision ----------------------------------- */
-
-#define APPNIC_TX_STATUS_LATE_COLLISION ((unsigned long)pdata->tx_base + 0x368)
-
-/* Transmit Status Excessive Collision ------------------------------ */
-
-#define APPNIC_TX_STATUS_EXCESSIVE_COLLISION \
-	((unsigned long)pdata->tx_base + 0x370)
-
-/* Transmit Stat Collision Above Watermark -------------------------- */
-
-#define APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK \
-	((unsigned long)pdata->tx_base + 0x380)
-
-/* Transmit Mode ---------------------------------------------------- */
-
-#define APPNIC_TX_MODE ((unsigned long)pdata->tx_base + 0x800)
-#define APPNIC_TX_MODE_ETHERNET_MODE_ENABLE 0x1
-
-/* Transmit Soft Reset ---------------------------------------------- */
-
-#define APPNIC_TX_SOFT_RESET ((unsigned long)pdata->tx_base + 0x808)
-#define APPNIC_TX_SOFT_RESET_MAC_0 0x1
-
-/* Transmit Interrupt Control --------------------------------------- */
-
-#define APPNIC_TX_INTERRUPT_CONTROL ((unsigned long)pdata->tx_base + 0xc00)
-#define APPNIC_TX_INTERRUPT_CONTROL_MAC_0 0x1
-
-/* Transmit Interrupt Status ---------------------------------------- */
-
-#define APPNIC_TX_INTERRUPT_STATUS ((unsigned long)pdata->tx_base + 0xc20)
-#define APPNIC_TX_INTERRUPT_STATUS_MAC_0 0x1
-
-/* */
-
-#define APPNIC_DMA_PCI_CONTROL ((unsigned long)pdata->dma_base + 0x00)
-
-/* */
-
-#define APPNIC_DMA_CONTROL ((unsigned long)pdata->dma_base + 0x08)
-
-/* DMA Interrupt Status --------------------------------------------- */
-
-#define APPNIC_DMA_INTERRUPT_STATUS ((unsigned long)pdata->dma_base + 0x18)
-#define APPNIC_DMA_INTERRUPT_STATUS_RX 0x2
-#define APPNIC_DMA_INTERRUPT_STATUS_TX 0x1
-#define RX_INTERRUPT(dma_interrupt_status) \
-	(0 != (dma_interrupt_status & APPNIC_DMA_INTERRUPT_STATUS_RX))
-#define TX_INTERRUPT(dma_interrupt_status) \
-	(0 != (dma_interrupt_status & APPNIC_DMA_INTERRUPT_STATUS_TX))
-
-/* DMA Interrupt Enable --------------------------------------------- */
-
-#define APPNIC_DMA_INTERRUPT_ENABLE ((unsigned long)pdata->dma_base + 0x1c)
-#define APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE 0x2
-#define APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT 0x1
-
-/* DMA Receive Queue Base Address ----------------------------------- */
-
-#define APPNIC_DMA_RX_QUEUE_BASE_ADDRESS ((unsigned long)pdata->dma_base + 0x30)
-
-/* DMA Receive Queue Size ------------------------------------------- */
-
-#define APPNIC_DMA_RX_QUEUE_SIZE ((unsigned long)pdata->dma_base + 0x34)
-
-/* DMA Transmit Queue Base Address ---------------------------------- */
-
-#define APPNIC_DMA_TX_QUEUE_BASE_ADDRESS ((unsigned long)pdata->dma_base + 0x38)
-
-/* DMA Transmit Queue Size ------------------------------------------ */
-
-#define APPNIC_DMA_TX_QUEUE_SIZE ((unsigned long)pdata->dma_base + 0x3c)
-
-/* DMA Recevie Tail Pointer Address --------------------------------- */
-
-#define APPNIC_DMA_RX_TAIL_POINTER_ADDRESS \
-	((unsigned long)pdata->dma_base + 0x48)
-
-/* DMA Transmit Tail Pointer Address -------------------------------- */
-
-#define APPNIC_DMA_TX_TAIL_POINTER_ADDRESS \
-	((unsigned long)pdata->dma_base + 0x4c)
-
-/* DMA Receive Head Pointer ----------------------------------------- */
-
-#define APPNIC_DMA_RX_HEAD_POINTER	((unsigned long)pdata->dma_base + 0x50)
-#define APPNIC_DMA_RX_HEAD_POINTER_GB			0x100000
-#define APPNIC_DMA_RX_HEAD_POINTER_POINTER		0x0fffff
-
-/* DMA Receive Tail Pointer Local Copy ------------------------------ */
-
-#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY	\
-	((unsigned long)pdata->dma_base + 0x54)
-#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_GB	0x100000
-#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_POINTER	0x0fffff
-
-/* DMA Transmit Head Pointer ---------------------------------------- */
-
-#define APPNIC_DMA_TX_HEAD_POINTER	((unsigned long)pdata->dma_base + 0x58)
-#define APPNIC_DMA_TX_HEAD_POINTER_GB			0x100000
-#define APPNIC_DMA_TX_HEAD_POINTER_POINTER		0x0fffff
-
-/* DMA Transmit Tail Pointer Local Copy ----------------------------- */
-
-#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY	\
-	((unsigned long)pdata->dma_base + 0x5c)
-#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_GB	0x100000
-#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_POINTER	0x0fffff
-
-#ifdef CONFIG_ARM
-
-#define read_mac(address)         readl((void __iomem *)(address))
-#define write_mac(value, address) writel((value), (void __iomem *)(address))
-#else
-#define read_mac(address)         in_le32((u32 *) (address))
-#define write_mac(value, address) out_le32((u32 *) (address), (value))
-#endif /* CONFIG_ARM */
-
-#ifdef __LITTLE_ENDIAN
-static inline void
-readdescriptor(unsigned long address, struct appnic_dma_descriptor *descriptor)
-{
-	memcpy(descriptor, (void *)address,
-	       sizeof(struct appnic_dma_descriptor));
-	return;
-}
-
-static inline void
-writedescriptor(unsigned long address,
-		const struct appnic_dma_descriptor *descriptor)
-{
-	memcpy((void *)address, descriptor,
-		   sizeof(struct appnic_dma_descriptor));
-	return;
-}
-
-static inline union appnic_queue_pointer
-_swab_queue_pointer(const union appnic_queue_pointer *old_queue)
-{
-	return *old_queue;
-}
-
-static inline void
-femac_uncache(struct appnic_device *pdata)
-{
-	/* Set FEMAC to uncached */
-	writel(0x0, (void __iomem *)GPREG_HPROT_FEMAC);
-}
-
-#else
-
-static inline void
-readdescriptor(unsigned long address, struct appnic_dma_descriptor *descriptor)
-{
-	unsigned long *from = (unsigned long *) address;
-	unsigned long *to = (unsigned long *) descriptor;
-
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	return;
-}
-
-static inline void
-writedescriptor(unsigned long address,
-		const struct appnic_dma_descriptor *descriptor)
-{
-	unsigned long *to = (unsigned long *) address;
-	unsigned long *from = (unsigned long *) descriptor;
-
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	return;
-}
-
-static inline union appnic_queue_pointer
-_swab_queue_pointer(const union appnic_queue_pointer *old_queue)
-{
-	union appnic_queue_pointer new_queue;
-	new_queue.raw = swab32(old_queue->raw);
-	return new_queue;
-}
-
-static inline void
-femac_uncache(struct appnic_device *pdata) {}
-
-#endif /* ifdef __LITTLE_ENDIAN */
-
-static int
-femac_irq_setup(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-
-#ifdef CONFIG_ARM
-	dev->irq = pdata->dma_interrupt;
-#else
-	dev->irq = irq_create_mapping(NULL, pdata->dma_interrupt);
-	if (NO_IRQ == dev->irq)
-		return -EINVAL;
-
-	if (0 != irq_set_irq_type(dev->irq, IRQ_TYPE_LEVEL_HIGH))
-		return -EINVAL;
-#endif
-	return 0;
-}
-
-static inline int
-femac_alloc_mem_buffers(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct device *device = NULL;
-	int rc;
-
-#ifndef CONFIG_ARM
-	dev->dev.archdata.dma_ops = &dma_direct_ops;
-	device = &dev->dev;
-#endif
-
-	pdata->dma_alloc = (void *)dma_alloc_coherent(device,
-						      pdata->dma_alloc_size,
-						      &pdata->dma_alloc_dma,
-						      GFP_KERNEL);
-	if (pdata->dma_alloc == (void *)0) {
-		rc = -ENOMEM;
-		goto err_dma_alloc;
-	}
-
-	pdata->dma_alloc_offset = (int)pdata->dma_alloc -
-					(int)pdata->dma_alloc_dma;
-
-	pdata->dma_alloc_rx = (void *)dma_alloc_coherent(device,
-						      pdata->dma_alloc_size_rx,
-						      &pdata->dma_alloc_dma_rx,
-						      GFP_KERNEL);
-	if (pdata->dma_alloc_rx == (void *)0) {
-		rc = -ENOMEM;
-		goto err_dma_alloc_rx;
-	}
-
-	pdata->dma_alloc_offset_rx = (int)pdata->dma_alloc_rx -
-					(int)pdata->dma_alloc_dma_rx;
-
-	pdata->dma_alloc_tx = (void *)dma_alloc_coherent(device,
-						      pdata->dma_alloc_size_tx,
-						      &pdata->dma_alloc_dma_tx,
-						      GFP_KERNEL);
-
-	if (pdata->dma_alloc_tx == (void *)0) {
-		rc = -ENOMEM;
-		goto err_dma_alloc_tx;
-	}
-
-	pdata->dma_alloc_offset_tx = (int)pdata->dma_alloc_tx -
-					(int)pdata->dma_alloc_dma_tx;
-
-	return 0;
-
-err_dma_alloc_tx:
-	dma_free_coherent(device, pdata->dma_alloc_size_rx,
-			  pdata->dma_alloc_rx, pdata->dma_alloc_dma_rx);
-err_dma_alloc_rx:
-	dma_free_coherent(device, pdata->dma_alloc_size,
-			  pdata->dma_alloc, pdata->dma_alloc_dma);
-err_dma_alloc:
-	return rc;
-}
-
-static inline void
-femac_free_mem_buffers(struct net_device *dev)
-{
-	struct appnic_device *pdata = netdev_priv(dev);
-	struct device *device = NULL;
-
-#ifndef CONFIG_ARM
-	device = &dev->dev;
-#endif
-	dma_free_coherent(device, pdata->dma_alloc_size,
-			  pdata->dma_alloc, pdata->dma_alloc_dma);
-	dma_free_coherent(device, pdata->dma_alloc_size_rx,
-			  pdata->dma_alloc_rx, pdata->dma_alloc_dma_rx);
-	dma_free_coherent(device, pdata->dma_alloc_size_tx,
-			  pdata->dma_alloc_tx, pdata->dma_alloc_dma_tx);
-}
-
-#define swab_queue_pointer(pointer) \
-	_swab_queue_pointer((const union appnic_queue_pointer *) (pointer))
-
-#endif /* _LSI_ACP_NET_H */
diff --git a/drivers/pci/host/axxia_pci.c b/drivers/pci/host/axxia_pci.c
index da0ae66..2bfd144 100644
--- a/drivers/pci/host/axxia_pci.c
+++ b/drivers/pci/host/axxia_pci.c
@@ -813,7 +813,7 @@ static int axxia_pcie_setup(struct axxia_pciex_port *port,
 }
 
 static const struct of_device_id axxia_pcie_match_table[] = {
-	{.compatible = "lsi,plb-pciex",},
+	{.compatible = "axxia,plb-pciex",},
 	{},
 };
 
diff --git a/drivers/pci/host/pcie-axxia.c b/drivers/pci/host/pcie-axxia.c
index 94e893a..323fbb2 100644
--- a/drivers/pci/host/pcie-axxia.c
+++ b/drivers/pci/host/pcie-axxia.c
@@ -27,7 +27,7 @@
 #include <linux/proc_fs.h>
 #include <linux/axxia-pei.h>
 #include <linux/time.h>
-#include <linux/lsi-ncr.h>
+#include <linux/axxia-ncr.h>
 #include <asm-generic/msi.h>
 
 #include "pcie-axxia.h"
@@ -137,7 +137,7 @@
 int
 axxia_is_x9(void)
 {
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5616"))
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5616"))
 		return 1;
 
 	return 0;
@@ -1779,7 +1779,7 @@ static int __exit axxia_pcie_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id axxia_pcie_of_match[] = {
-	{ .compatible = "intel,axxia-pcie", },
+	{ .compatible = "axxia,axxia-pcie", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, axxia_pcie_of_match);
diff --git a/drivers/power/reset/axxia-reset.c b/drivers/power/reset/axxia-reset.c
index 60afa8e..836bf5b 100644
--- a/drivers/power/reset/axxia-reset.c
+++ b/drivers/power/reset/axxia-reset.c
@@ -1,7 +1,7 @@
 /*
  * Reset driver for Axxia devices
  *
- * Copyright (C) 2014 LSI
+ * Copyright (C) 2018 INTEL
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -93,7 +93,7 @@ static void axxia_pm_restart(enum reboot_mode reboot_mode, const char *cmd)
 	* but for now we allow it on simulator
 	*/
 
-/*	if (of_find_compatible_node(NULL, NULL, "lsi,axm5500-amarillo")) { */
+/*	if (of_find_compatible_node(NULL, NULL, "axxia,axm5500-amarillo")) { */
 	if (1) {
 		/* Create /proc entry. */
 		if (!proc_create("driver/axxia_ddr_retention_reset",
diff --git a/drivers/rapidio/devices/Kconfig b/drivers/rapidio/devices/Kconfig
index 975e04a..e683f0c 100644
--- a/drivers/rapidio/devices/Kconfig
+++ b/drivers/rapidio/devices/Kconfig
@@ -9,4 +9,4 @@ config RAPIDIO_TSI721
 	---help---
 	  Include support for IDT Tsi721 PCI Express Serial RapidIO controller.
 
-source "drivers/rapidio/devices/lsi/Kconfig"
+source "drivers/rapidio/devices/axxia/Kconfig"
diff --git a/drivers/rapidio/devices/Makefile b/drivers/rapidio/devices/Makefile
index 148f405..b2fd580 100644
--- a/drivers/rapidio/devices/Makefile
+++ b/drivers/rapidio/devices/Makefile
@@ -6,4 +6,4 @@ obj-$(CONFIG_RAPIDIO_TSI721)	+= tsi721_mport.o
 tsi721_mport-y			:= tsi721.o
 tsi721_mport-$(CONFIG_RAPIDIO_DMA_ENGINE) += tsi721_dma.o
 obj-$(CONFIG_RAPIDIO_MPORT_CDEV) += rio_mport_cdev.o
-obj-$(CONFIG_AXXIA_RIO)         += lsi/
+obj-$(CONFIG_AXXIA_RIO)         += axxia/
diff --git a/drivers/rapidio/devices/axxia/Kconfig b/drivers/rapidio/devices/axxia/Kconfig
new file mode 100644
index 0000000..62ecbbb
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/Kconfig
@@ -0,0 +1,47 @@
+
+config AXXIA_RIO
+       bool "AXXIA Embedded SRIO Controller support"
+       depends on RAPIDIO && (ACP || ARCH_AXXIA)
+       default "n"
+       ---help---
+         Include support for RapidIO controllers for INTEL Axxia
+         devices. The Axxia devices with arm (AXM55xx) and
+         powerpc (AXM35xx) cores has the serial RapidIO
+         controllers.
+
+config RIO_MAINT_WIN_SIZE
+       hex "RIO mport maintenance window size"
+       depends on RAPIDIO
+       default "0x400000"
+       ---help---
+         Size of RAPIDIO maintenance transaction window.
+         If RapidIO LAW size in your platform is less than 0x400000,
+         you may use this option to adjust the maintenance transaction
+         window accordingly.
+
+config AXXIA_RIO_STAT
+       bool "AXXIA RIO driver statistics"
+       depends on AXXIA_RIO
+       default n
+       ---help---
+         If you say Y here, you will be able to measure and view
+         state and interrupt counters for the Axxia RapidIO
+         controller via sysfs. It provides the counters for mbox
+         messages. May add a slght cpu overhead.
+
+config AXXIA_RIO_16B_ID
+       bool "RapidIO large common transport system"
+       depends on AXXIA_RIO && (ACP && PPC)
+       default n
+       ---help---
+         Say yes here to enable use of 16 bit transport ID otherwise
+         transport ID has 8 bits. This is required only for older
+         Axxia devices (34xx). And not required for the newer AXM55xx
+         devices.
+
+config OB_DME_ENTRY_SIZE
+       int "Number of Descriptors per DME for Static allocation"
+       depends on AXXIA_RIO
+       default "4096"
+       ---help---
+         Number of Descriptors to allocate for each outbound DME.
diff --git a/drivers/rapidio/devices/axxia/Makefile b/drivers/rapidio/devices/axxia/Makefile
new file mode 100644
index 0000000..82d0236
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+obj-$(CONFIG_AXXIA_RIO)                 += axxia-rio.o axxia-rio-irq.o
+obj-$(CONFIG_AXXIA_RIO_STAT)           += axxia-rio-sysfs.o
diff --git a/drivers/rapidio/devices/axxia/axxia-rio-irq.c b/drivers/rapidio/devices/axxia/axxia-rio-irq.c
new file mode 100644
index 0000000..9ecd55d
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/axxia-rio-irq.c
@@ -0,0 +1,2842 @@
+/*
+ *   This program is free software;  you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kfifo.h>
+#include <linux/dmapool.h>
+
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include "axxia-rio.h"
+#define OB_DME_ENTRIES		(CONFIG_OB_DME_ENTRY_SIZE)
+#define LINK_DOWN_TIMEOUT	(0x4BF0)
+
+unsigned int axxia_dme_tmr_mode[2] = { AXXIA_IBDME_INTERRUPT_MODE,
+					AXXIA_IBDME_TIMER_MODE };
+static int axxia_timer_mode_setup(char *str)
+{
+	unsigned int tmr_mode[3];
+	int i;
+	(void)get_options(str, ARRAY_SIZE(tmr_mode), tmr_mode);
+	for (i = 0; i < tmr_mode[0]; i++) {
+		if (tmr_mode[i+1] > 1)
+			pr_debug("Invalid parameter value for Timer Mode\n");
+		else
+			axxia_dme_tmr_mode[i] = AXXIA_IBDME_TIMER_MODE;
+	}
+	return 1;
+}
+__setup("axm_srio_tmr_mode=", axxia_timer_mode_setup);
+
+static int axxia_int_mode_setup(char *str)
+{
+	unsigned int int_mode[3];
+	int i;
+	(void)get_options(str, ARRAY_SIZE(int_mode), int_mode);
+	for (i = 0; i < int_mode[0]; i++) {
+		if (int_mode[i+1] > 1)
+			pr_debug("Invalid param value for Interrupt Mode\n");
+		else
+			axxia_dme_tmr_mode[i] = AXXIA_IBDME_INTERRUPT_MODE;
+	}
+	return 1;
+}
+__setup("axm_srio_int_mode=", axxia_int_mode_setup);
+
+#define AXXIA_HRTIMER_DELAY	(200 * 1000UL)
+unsigned int axxia_hrtimer_delay = AXXIA_HRTIMER_DELAY;
+static int __init axxia_hrtimer_setup(char *str)
+{
+	get_option(&str, &axxia_hrtimer_delay);
+	return 1;
+}
+__setup("axm_srio_tmr_period=", axxia_hrtimer_setup);
+
+/**************************sRIO SERDES *****************************/
+u32 srio_serdes_write32(struct rio_priv *priv, u32 addr, u32 val)
+{
+	void __iomem *regaddr;
+	u32 regval = 0;
+
+	regaddr = (priv->linkdown_reset.win) +
+			APB2SER_SRIO_PHY0_CFG_OFFSET;
+	iowrite32(val, (regaddr + SERDES_CMD0_OFFSET));
+	regval = ((1<<SERDES_CMD1_VALID_SHIFT) |
+			(0x1 << SERDES_CMD1_HWRITE_SHIFT) |
+			(0x01<<SERDES_CMD1_TSHIFT_SHIFT) |
+			(0x2<<SERDES_CMD1_HSZIE_SHIFT) |
+			(0x2 << SERDES_CMD1_HTRANS_SHIFT) |
+			(addr & SERDES_CMD1_HADDR_MASK));
+	iowrite32(regval, (regaddr + SERDES_CMD1_OFFSET));
+
+	regval = 0xffffffff;
+	while (1) {
+		regval = ioread32((regaddr + SERDES_CMD1_OFFSET));
+		if (!(regval & (1 << SERDES_CMD1_VALID_SHIFT)))
+			break;
+	}
+
+	regval = ioread32((regaddr + SERDES_READDATA1_OFFSET));
+	if (regval & SERDES_READDATA1_HRESP_MASK) {
+		dev_err(priv->dev, "SerDes write Failed... Returning 0\n");
+		return 0;
+	} else
+		return 1;
+}
+
+u32 srio_serdes_read32(struct rio_priv *priv, u32 addr)
+{
+	void __iomem *regaddr;
+	u32 regval = 0;
+
+	regaddr = (priv->linkdown_reset.win) +
+			APB2SER_SRIO_PHY0_CFG_OFFSET;
+	regval = ((1<<SERDES_CMD1_VALID_SHIFT) |
+			(0x01<<SERDES_CMD1_TSHIFT_SHIFT) |
+			(0x2<<SERDES_CMD1_HSZIE_SHIFT) |
+			(0x2 << SERDES_CMD1_HTRANS_SHIFT) |
+			(addr & SERDES_CMD1_HADDR_MASK));
+
+	iowrite32(regval, (regaddr + SERDES_CMD1_OFFSET));
+	regval = 0xffffffff;
+	while (1) {
+		regval = ioread32((regaddr + SERDES_CMD1_OFFSET));
+		if ((regval & (1 << SERDES_CMD1_VALID_SHIFT)) == 0x0)
+			break;
+	}
+	regval = ioread32((regaddr + SERDES_READDATA1_OFFSET));
+	if (regval & SERDES_READDATA1_HRESP_MASK) {
+		dev_err(priv->dev, "SerDes Read Failed... Returning 0\n");
+		return 0;
+	}
+	regval = ioread32((regaddr + SERDES_READDATA0_OFFSET));
+	return regval;
+}
+
+/**************************sRIO SERDES Ends ***************************/
+static void  ib_dme_irq_handler(struct rio_irq_handler *h/*, u32 state*/);
+/****************************************************************************
+**
+** Implementation Note:
+**
+** The Message DME registers lie within the fixed page block in the RAB SRIO
+** Configuration memory.  Thus, all or almost all of its register accesses
+** do not require use of the RAB memory paging register.  On the other hand,
+** the Message descriptor registers for the ACP34xx platform do lie outside
+** of the fixed page block.  For safety, we will direct all of the accesses
+** to the Message descriptor registers (on the ACP34xx platform and the like),
+** through the RIO mport's lcread and lcwrite interfaces which use a software
+** spin lock to control access.
+**
+*****************************************************************************/
+
+static inline void __dme_dw_dbg(struct device *dev, struct rio_msg_dme *dme,
+			u32 iout, u32 dw0, u32 dw1)
+{
+	int did, mb, let;
+	char *io;
+	char *id;
+
+	if (dw0 & DME_DESC_DW0_ERROR_MASK) {
+		did = DME_DESC_DW0_GET_DST_ID(dw0);
+		let = DME_DESC_DW1_GET_LETTER(dw1);
+		mb = DME_DESC_DW1_GET_MBOX(dw1);
+		if (iout) {
+			io = "OB";
+			id = "DID";
+		} else {
+			io = "IB";
+			id = "SID";
+		}
+#if defined(CONFIG_AXXIA_RIO_STAT)
+		dme->desc_error_count++;
+#endif
+		if (dw0 & DME_DESC_DW0_RIO_ERR) {
+			dev_err(dev,
+			"%s RIO ERR: %s = %x,Type:11,mbox=%d,letter=%d\n",
+			 io, id, did, mb, let);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+			dme->desc_rio_err_count++;
+#endif
+		}
+		if (dw0 & DME_DESC_DW0_AXI_ERR) {
+			dev_err(dev,
+			"%s AXI ERR: %s = %x,Type:11,mbox=%d,letter=%d\n",
+			 io, id, did, mb, let);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+			dme->desc_axi_err_count++;
+#endif
+		}
+		if (dw0 & DME_DESC_DW0_TIMEOUT_ERR) {
+			dev_err(dev,
+			"%s TIMEOUT ERR: %s = %x,Type:11,mbox=%d,letter=%d\n",
+			 io, id, did, mb, let);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+			dme->desc_tmo_err_count++;
+#endif
+		}
+	}
+#if defined(CONFIG_AXXIA_RIO_STAT)
+	dme->desc_done_count++;
+#endif
+}
+
+#if defined(CONFIG_AXXIA_RIO_STAT)
+static void reset_state_counters(struct rio_priv *priv)
+{
+	priv->rpio_compl_count = 0;
+	priv->rpio_failed_count = 0;
+	priv->apio_compl_count = 0;
+	priv->apio_failed_count = 0;
+	priv->rio_pw_count = 0;
+	priv->rio_pw_msg_count = 0;
+}
+#endif /* defined(CONFIG_AXXIA_RIO_STAT) */
+
+/**
+ * thrd_irq_handler - Threaded interrupt handler
+ * @irq: Linux interrupt number
+ * @data: Pointer to interrupt-specific data
+ *
+ */
+static irqreturn_t thrd_irq_handler(int irq, void *data)
+{
+	struct rio_irq_handler *h = data;
+	struct rio_priv *priv = h->data;
+
+	/**
+	 * Invoke handler callback
+	 */
+	h->thrd_irq_fn(h);
+	axxia_local_config_write(priv, h->irq_enab_reg_addr, h->irq_state_mask);
+	return IRQ_HANDLED;
+}
+
+/**
+ * hw_irq_handler - RIO HW interrupt handler
+ * @irq: Linux interrupt number
+ * @data: Pointer to interrupt-specific data
+ *
+ */
+static irqreturn_t hw_irq_handler(int irq, void *data)
+{
+	struct rio_irq_handler *h = data;
+	struct rio_priv *priv = h->data;
+	u32 state;
+	/**
+	 * Get current interrupt state and clear latched state
+	 * for interrupts handled by current thread.
+	 */
+	axxia_local_config_read(priv, h->irq_state_reg_addr, &state);
+	state &= h->irq_state_mask;
+
+	if (state) {
+		axxia_local_config_write(priv, h->irq_enab_reg_addr, 0x0);
+		return IRQ_WAKE_THREAD;
+	}
+	return IRQ_NONE;
+}
+
+static irqreturn_t hw_irq_dme_handler(int irq, void *data)
+{
+	struct rio_irq_handler *h;
+	struct rio_priv *priv = data;
+
+	h = &priv->ib_dme_irq;
+	ib_dme_irq_handler(h);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * Caller must hold RAB lock
+ */
+int alloc_irq_handler(struct rio_irq_handler *h,
+		     void *data,
+		     const char *name)
+{
+	struct rio_priv *priv = data;/*mport->priv;*/
+	u32 mask;
+	int rc;
+
+	if (test_and_set_bit(RIO_IRQ_ENABLED, &h->state))
+		return -EBUSY;
+
+	h->data = data;
+	rc = request_threaded_irq(priv->irq_line,
+				  hw_irq_handler,
+				  thrd_irq_handler,
+				  IRQF_TRIGGER_NONE | IRQF_SHARED,
+				  name,
+				  (void *)h);
+	if (rc) {
+		clear_bit(RIO_IRQ_ENABLED,  &h->state);
+		h->data = NULL;
+		return rc;
+	}
+	if (h->irq_enab_reg_addr) {
+		axxia_local_config_read(priv, h->irq_enab_reg_addr, &mask);
+		mask |= h->irq_state_mask;
+		axxia_local_config_write(priv, h->irq_state_reg_addr, mask);
+		axxia_local_config_write(priv, h->irq_enab_reg_addr, mask);
+	}
+
+	return rc;
+}
+
+/**
+ * Caller must hold RAB lock
+ */
+
+void release_irq_handler(struct rio_irq_handler *h)
+{
+	struct rio_priv *priv = h->data;
+	u32 mask;
+
+	if (test_and_clear_bit(RIO_IRQ_ENABLED, &h->state)) {
+		axxia_local_config_read(priv, h->irq_enab_reg_addr, &mask);
+		mask &= ~h->irq_state_mask;
+		axxia_local_config_write(priv, h->irq_enab_reg_addr, mask);
+		free_irq(priv->irq_line, h);
+		if (h->release_fn)
+			h->release_fn(h);
+	}
+}
+
+/**
+ * MISC Indications
+ */
+#if defined(CONFIG_RAPIDIO_HOTPLUG)
+static void rio_port_down_notify(struct rio_mport *mport)
+{
+	unsigned long flags;
+	struct rio_priv *priv = mport->priv;
+
+	spin_lock_irqsave(&priv->port_lock, flags);
+	if (priv->port_notify_cb)
+		priv->port_notify_cb(mport);
+
+	spin_unlock_irqrestore(&priv->port_lock, flags);
+}
+#else
+#define rio_port_down_notify(mport)
+#endif
+
+/**
+ * __port_fatal_err - Check port error state and clear latched
+ *                    error state to enable detection of new events.
+ *
+ * @mport: Master port
+ *
+ * Returns:
+ * 1 -- port fatal error state is detected
+ * 0 -- port ok
+ */
+static inline void __misc_fatal(struct rio_mport *mport,
+				u32 misc_state)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 amast = 0;
+	u32 aslv_state = 0;
+	u32 aslv_addr = 0;
+	u32 escsr, iecsr;
+
+	dev_err(priv->dev, "*************Fatal Error************\n");
+	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &escsr);
+	axxia_local_config_read(priv, EPC_IECSR(priv->port_ndx), &iecsr);
+
+	/* clear latched state indications */
+	/* Adding I2E to preserve idle sequence select bit which is R/w */
+	axxia_local_config_write(priv, RIO_ESCSR(priv->port_ndx),
+				(escsr & (RIO_ESCSR_I2E | RIO_EXCSR_WOLR)));
+	dev_err(priv->dev, "port %d ESCSR(0x158) 0x%08x\n", priv->ndx, escsr);
+	if (iecsr & EPC_IECSR_RETE) {
+		dev_err(priv->dev, "Retry Error Threshold Exceeded\n");
+		axxia_local_config_write(priv, EPC_IECSR(priv->port_ndx),
+				(iecsr & EPC_IECSR_RETE));
+	}
+	if (misc_state & AMST_INT) {
+		axxia_local_config_read(priv, RAB_AMAST_STAT, &amast);
+		if (amast & RAB_AMAST_STAT_WRTO)
+			dev_err(priv->dev, "AMST Write Response Timeout Error\n");
+		if (amast & RAB_AMAST_STAT_RDTO)
+			dev_err(priv->dev, "AMST Read Response Timeout Error\n");
+		if (amast & RAB_AMAST_STAT_WRDE)
+			dev_err(priv->dev, "AMST Write Decode Error\n");
+		if (amast & RAB_AMAST_STAT_WRSE)
+			dev_err(priv->dev, "AMST Write Slave Error\n");
+		if (amast & RAB_AMAST_STAT_RDDE)
+			dev_err(priv->dev, "AMST Read Decode Error\n");
+		if (amast & RAB_AMAST_STAT_RDSE)
+			dev_err(priv->dev, "AMST Read Slave Error\n");
+		/* clear latched state */
+		axxia_local_config_write(priv, RAB_AMAST_STAT, amast);
+	}
+	if (misc_state & ASLV_INT) {
+		axxia_local_config_read(priv, RAB_ASLV_STAT_CMD,  &aslv_state);
+		axxia_local_config_read(priv, RAB_ASLV_STAT_ADDR, &aslv_addr);
+		if (aslv_state & RAB_ASLV_STAT_CMD_USUP) {
+			dev_err(priv->dev, "AMBA Slave Unsupported Command\n");
+			axxia_local_config_write(priv, RAB_ASLV_STAT_CMD,
+					 (aslv_state & RAB_ASLV_STAT_CMD_USUP));
+		}
+	}
+	if ((escsr & ESCSR_FATAL) ||
+	    (iecsr & EPC_IECSR_RETE) ||
+	    (misc_state & MISC_FATAL))
+		rio_port_down_notify(mport);
+}
+
+/**
+ * srio_sw_reset - Reset the SRIO (GRIO) module when it reaches a fatal
+ *                 lockup state or if it received a reset control symbol
+ */
+static void srio_sw_reset(struct rio_priv *priv)
+{
+	u32 r32;
+	u32 sval;
+
+	r32 = srio_serdes_read32(priv, SRIO_PHY_CONTROL0_OFFSET);
+	srio_serdes_write32(priv, SRIO_PHY_CONTROL0_OFFSET,
+			(r32 | priv->linkdown_reset.reg_mask));
+	while (1) {
+		sval = srio_serdes_read32(priv, SRIO_PHY_CONTROL0_OFFSET);
+		if ((sval & priv->linkdown_reset.reg_mask))
+			break;
+	}
+	srio_serdes_write32(priv, SRIO_PHY_CONTROL0_OFFSET, (r32));
+	sval = 0;
+	while (1) {
+		sval = srio_serdes_read32(priv, SRIO_PHY_CONTROL0_OFFSET);
+		if (sval == r32)
+			break;
+	}
+}
+
+/**
+ * PORT WRITE events
+ */
+/**
+ * pw_irq_handler - AXXIA port write interrupt handler
+ * @h: handler specific data
+ * @state: PW Interrupt state
+ *
+ * Handles port write interrupts.
+ */
+static void pw_irq_handler(struct rio_irq_handler *h, u32 state)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_pw_irq *pw = priv->pw_data;
+	u32 csr;
+	int noofpw;
+	u32 msg_word;
+
+	if (pw == NULL) {
+		dev_dbg(priv->dev, "Spurious port write message\n");
+		return;
+	}
+
+	axxia_local_config_read(priv, RAB_IB_PW_CSR, &csr);
+	noofpw = RAB_IB_PW_NUMWORDS(csr);
+	dev_dbg(priv->dev, "%s: noofpw %d\n", __func__, noofpw);
+	if (!(noofpw)) {
+		dev_dbg(priv->dev, "PW Spurious Port Write\n");
+		return;
+	}
+#if defined(CONFIG_AXXIA_RIO_STAT)
+	priv->rio_pw_count++;
+#endif
+	while (noofpw) {
+
+read_buff:
+		axxia_local_config_read(priv, RAB_IB_PW_DATA, &msg_word);
+		pw->msg_buffer[pw->msg_wc++] = BSWAP(msg_word);
+		if (pw->msg_wc == 4) {
+#if defined(CONFIG_AXXIA_RIO_STAT)
+			priv->rio_pw_msg_count++;
+#endif
+			/*
+			 * Pass the port-write message to RIO
+			 * core for processing
+			 */
+			rio_inb_pwrite_handler(priv->mport,
+					 (union rio_pw_msg *)pw->msg_buffer);
+			pw->msg_wc = 0;
+		}
+		noofpw--;
+		if (noofpw)
+			goto read_buff;
+
+		axxia_local_config_read(priv, RAB_IB_PW_CSR, &csr);
+		noofpw = RAB_IB_PW_NUMWORDS(csr);
+	}
+}
+
+static void axxia_rio_flush_pw(struct rio_mport *mport, int noofpw,
+			     struct rio_pw_irq *pw_data)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 dummy;
+	int x;
+
+	dev_dbg(priv->dev, "(%s): flush %d words from pwbuff\n",
+		__func__, noofpw);
+	for (x = 0; x < noofpw; x++) {
+		axxia_local_config_read(priv, RAB_IB_PW_DATA, &dummy);
+		pw_data->discard_count++;
+	}
+	pw_data->msg_wc = 0;
+}
+
+/**
+ * enable_pw - enable port-write interface unit
+ * @h: Interrupt handler specific data
+ *
+ * Caller must hold RAB lock
+ */
+static int enable_pw(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_pw_irq *pw_data;
+	u32 rval;
+	int rc = 0;
+
+	if (priv->pw_data)
+		return -EBUSY;
+
+	pw_data = kzalloc(sizeof(struct rio_pw_irq), GFP_KERNEL);
+	if (!pw_data)
+		return -ENOMEM;
+
+	axxia_local_config_read(priv, RAB_IB_PW_CSR, &rval);
+	rval |= RAB_IB_PW_EN;
+	axxia_rio_flush_pw(mport, RAB_IB_PW_NUMWORDS(rval), pw_data);
+	axxia_local_config_write(priv, RAB_IB_PW_CSR, rval);
+	priv->pw_data = pw_data;
+	return rc;
+}
+
+/**
+ * disable_pw - Disable port-write interface unit
+ * @mport: pointer to struct rio_mport
+ *
+ * Caller must hold RAB lock
+ */
+static void disable_pw(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_pw_irq *pw_data = priv->pw_data;
+	u32 rval;
+
+	if (pw_data == NULL)
+		return;
+
+	axxia_local_config_read(priv, RAB_IB_PW_CSR, &rval);
+	rval &= ~RAB_IB_PW_EN;
+	axxia_local_config_write(priv, RAB_IB_PW_CSR, rval);
+	kfree(pw_data);
+	priv->pw_data = NULL;
+}
+
+
+/**
+ * misc_irq_handler - MISC interrupt handler
+ * @h: handler specific data
+ * @state: Interrupt state
+ * Handles the Error, doorbell, Link reset request Interrupts
+ */
+static void misc_irq_handler(struct rio_irq_handler *h)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_mport *mport = priv->mport;
+	u32 misc_state;
+
+	axxia_local_config_read(priv, RAB_INTR_STAT_MISC, &misc_state);
+	/*
+	 * Handle miscellaneous 'Link (IPG) Reset Request'
+	 */
+	if (misc_state & LINK_REQ_INT)
+		srio_sw_reset(priv);
+
+	if (misc_state & PORT_WRITE_INT)
+		pw_irq_handler(h, misc_state & PORT_WRITE_INT);
+
+	if (misc_state & (IB_DB_RCV_INT | OB_DB_DONE_INT))
+		db_irq_handler(h,
+			misc_state & (IB_DB_RCV_INT | OB_DB_DONE_INT));
+	/**
+	 * Notify platform if port is broken
+	 */
+	if (misc_state & MISC_FATAL)
+		__misc_fatal(mport, misc_state);
+
+	if (misc_state & GRIO_INT)
+		dev_err(priv->dev, "GRIO Error Interrupt\n");
+		/* TODO Need further Handling */
+	if (misc_state & LL_TL_INT)
+		dev_err(priv->dev, "Logical Layer Error Interrupt\n");
+		/* TODO Need further Handling */
+	if (misc_state & UNSP_RIO_REQ_INT)
+		dev_dbg(priv->dev, "Unsupported RIO Request Received\n");
+		/* TODO Need further Handling */
+	if (misc_state & UNEXP_MSG_INT)
+		dev_dbg_ratelimited(priv->dev,
+			"Unexpected Inbound Data Message Received\n");
+		/* TODO Need further Handling */
+
+	axxia_local_config_write(priv, RAB_INTR_STAT_MISC, misc_state);
+}
+
+static void misc_release_handler(struct rio_irq_handler *h)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_mport *mport = priv->mport;
+
+	disable_pw(mport);
+}
+/**
+ * linkdown_irq_handler - Link Down interrupt Status interrupt handler
+ * @h: handler specific data
+ * @state: Interrupt state
+ */
+static void linkdown_irq_handler(struct rio_irq_handler *h/*, u32 state*/)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_mport *mport = priv->mport;
+	u32 val;
+	u32 val1;
+	u32 rstate;
+
+	__rio_local_read_config_32(mport, RAB_SRDS_STAT1, &rstate);
+	__rio_local_read_config_32(mport, RAB_SRDS_CTRL2, &val);
+	__rio_local_read_config_32(mport, RAB_SRDS_CTRL1, &val1);
+	pr_info("Link Down: RAB_SRDS STAT1 = %x CTRL1 = %x CTRL2 = %x\n",
+					rstate, val1, val);
+	while (1) {
+		axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &val);
+		if (val & 0x2) {
+			pr_info("Link up, Exiting Linkdown monitor Handler\n");
+			__rio_local_read_config_32(mport, RAB_SRDS_CTRL1, &val);
+			__rio_local_write_config_32(mport, RAB_SRDS_CTRL1,
+								(val | 0x2));
+			__rio_local_write_config_32(mport, RAB_SRDS_CTRL2,
+							LINK_DOWN_TIMEOUT);
+			break;
+		}
+	}
+	__rio_local_read_config_32(mport, RAB_SRDS_STAT1, &rstate);
+	__rio_local_read_config_32(mport, RAB_SRDS_CTRL2, &val);
+	__rio_local_read_config_32(mport, RAB_SRDS_CTRL1, &val1);
+}
+
+/**
+ * rpio_irq_handler - RPIO interrupt handler.
+ * Service Peripheral Bus bridge, RapidIO -> Peripheral bus interrupt
+ *
+ * @h: handler specific data
+ * @state: Interrupt state
+ *
+ */
+static void rpio_irq_handler(struct rio_irq_handler *h)
+{
+	struct rio_priv *priv = h->data;
+	u32 rstate;
+
+	axxia_local_config_read(priv, RAB_INTR_STAT_RPIO, &rstate);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+	if (rstate & RPIO_TRANS_COMPLETE)
+		priv->rpio_compl_count++;
+#endif
+	if (rstate &  RPIO_TRANS_FAILED) {
+		u32 rpio_stat;
+
+		axxia_local_config_read(priv, RAB_RPIO_STAT, &rpio_stat);
+		if (rpio_stat & RAB_RPIO_STAT_RSP_ERR)
+			dev_dbg(priv->dev, "RPIO AXI Response Error\n");
+		if (rpio_stat & RAB_RPIO_STAT_ADDR_MAP)
+			dev_dbg(priv->dev, "RPIO Invalid Address Mapping Error\n");
+		if (rpio_stat & RAB_RPIO_STAT_DISABLED)
+			dev_dbg(priv->dev, "RPIO Engine Not Enabled\n");
+
+		axxia_local_config_write(priv, RAB_RPIO_STAT, rpio_stat);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+		priv->rpio_failed_count++;
+#endif
+	}
+	axxia_local_config_write(priv, RAB_INTR_STAT_RPIO, rstate);
+}
+
+/**
+ * APIO
+ */
+
+/**
+ * apio_irq_handler - APIO interrupt handler.
+ * Service Peripheral Bus bridge, Peripheral bus -> RapidIO interrupt
+ *
+ * @h: handler specific data
+ * @state: Interrupt state
+ *
+ */
+static void apio_irq_handler(struct rio_irq_handler *h)
+{
+	struct rio_priv *priv = h->data;
+	u32 astate;
+
+	axxia_local_config_read(priv, RAB_INTR_STAT_APIO, &astate);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+	if (astate & APIO_TRANS_COMPLETE)
+		priv->apio_compl_count++;
+#endif
+	if (astate & APIO_TRANS_FAILED) {
+		u32 apio_stat;
+
+		axxia_local_config_read(priv, RAB_APIO_STAT, &apio_stat);
+		if (apio_stat & RAB_APIO_STAT_RQ_ERR)
+			dev_dbg(priv->dev, "APIO AXI Request Format Error\n");
+		if (apio_stat & RAB_APIO_STAT_TO_ERR)
+			dev_dbg(priv->dev, "APIO RIO Timeout Error\n");
+		if (apio_stat & RAB_APIO_STAT_RSP_ERR)
+			dev_dbg(priv->dev, "APIO RIO Response Error\n");
+		if (apio_stat & RAB_APIO_STAT_MAP_ERR)
+			dev_dbg(priv->dev, "APIO Invalid Address Mapping Error\n");
+		if (apio_stat & RAB_APIO_STAT_MAINT_DIS)
+			dev_dbg(priv->dev, "APIO Maintenance Mapping Not Enabled\n");
+		if (apio_stat & RAB_APIO_STAT_MEM_DIS)
+			dev_dbg(priv->dev, "APIO Memory Mapping Not Enabled\n");
+		if (apio_stat & RAB_APIO_STAT_DISABLED)
+			dev_dbg(priv->dev, "APIO Engine Not Enabled\n");
+		axxia_local_config_write(priv, RAB_APIO_STAT, apio_stat);
+#if defined(CONFIG_AXXIA_RIO_STAT)
+		priv->apio_failed_count++;
+#endif
+	}
+	axxia_local_config_write(priv, RAB_INTR_STAT_APIO, astate);
+}
+
+/**
+ * DOORBELL events
+ */
+
+/**
+ * axxia_rio_rx_db_int_handler - AXXIA inbound doorbell interrupt handler
+ * @mport: Master port with triggered interrupt
+ * @mask: Interrupt register data
+ *
+ * Handles inbound doorbell interrupts.  Executes a callback on received
+ * doorbell. Now called from the misc_irq thread, rio-misc-db.
+ */
+void rx_db_handler(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_dbell *dbell;
+	u32 csr, info;
+	u8 num_msg;
+	u16 src_id, db_info;
+	int found;
+
+	axxia_local_config_read(priv, RAB_IB_DB_CSR, &csr);
+	num_msg = IB_DB_CSR_NUM_MSG(csr);
+
+	for (; num_msg; num_msg--) {
+		axxia_local_config_read(priv, RAB_IB_DB_INFO, &info);
+		src_id = DBELL_SID(info);
+		db_info = DBELL_INF(info);
+
+		found = 0;
+		dev_dbg(priv->dev,
+			 "Processing doorbell, sid %4.4x info %4.4x\n",
+			src_id, db_info);
+
+		list_for_each_entry(dbell, &mport->dbells, node) {
+			if (dbell->res->start <= db_info &&
+			    (dbell->res->end >= db_info)) {
+				found = 1;
+				break;
+			}
+		}
+		if (found) {
+			/**
+			 * NOTE: dst is set to 0 since we don't have
+			 *       that value in the ACP
+			 */
+			if (dbell->dinb)
+				dbell->dinb(mport, dbell->dev_id, src_id,
+						0, db_info);
+		} else {
+			dev_dbg(priv->dev,
+				"Spurious doorbell, sid %4.4x info %4.4x\n",
+				src_id, db_info);
+		}
+	}
+}
+
+void db_irq_handler(struct rio_irq_handler *h, u32 state)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_mport *mport = priv->mport;
+
+	/**
+	 * Handle RX doorbell events
+	 */
+	if (state & IB_DB_RCV_INT)
+		rx_db_handler(mport);
+
+	/**
+	 * Check for outbound doorbell Error conditions.
+	 */
+	if (state & OB_DB_DONE_INT) {
+		int db;
+		u32 csr;
+
+		for (db = 0; db < MAX_OB_DB; db++) {
+			axxia_local_config_read(priv, RAB_OB_DB_CSR(db), &csr);
+
+			if (OB_DB_STATUS(csr) == OB_DB_STATUS_RETRY)
+				dev_dbg(priv->dev,
+				  "Rio Doorbell Retry received\n");
+			else if (OB_DB_STATUS(csr) == OB_DB_STATUS_ERROR)
+				dev_dbg(priv->dev,
+				  "Rio Doorbell send Error\n");
+			else if (OB_DB_STATUS(csr) == OB_DB_STATUS_TIMEOUT)
+				dev_dbg(priv->dev,
+				  "Rio Doorbell send Timeout\n");
+		}
+	}
+}
+
+/**
+ * OBDME Events/Outbound Messages
+ */
+
+static void release_dme(struct kref *kref)
+{
+	struct rio_msg_dme *me = container_of(kref, struct rio_msg_dme, kref);
+	struct rio_priv *priv = me->priv;
+	struct rio_msg_desc *desc;
+	int i;
+
+	if (me->desc) {
+		for (i = 0, desc = me->desc; i < me->entries; i++, desc++)
+			kfree(desc->msg_virt);
+		kfree(me->desc);
+	}
+
+	kfree(me->descriptors);
+
+	if (priv->intern_msg_desc) {
+		if (me->dres.parent)
+			release_resource(&me->dres);
+	}
+
+	kfree(me);
+}
+
+static inline struct rio_msg_dme *dme_get(struct rio_msg_dme *me)
+{
+	if (me)
+		kref_get(&me->kref);
+	return me;
+}
+
+static inline void dme_put(struct rio_msg_dme *me)
+{
+	if (me)
+		kref_put(&me->kref, release_dme);
+}
+
+static inline int check_dme(int dme_no,
+			    int *num_dmes,
+			    int *dmes_in_use,
+			    int *dmes)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (dme_no < num_dmes[i]) {
+			if (dmes[i] & (1 << dme_no)) {
+				if (dmes_in_use[i] & (1 << dme_no))
+					return -EBUSY;	/* Already allocated */
+				return 0;
+			}
+		} else {
+			dme_no -= num_dmes[i];
+		}
+	}
+
+	return -ENXIO;	/* Not available */
+}
+
+/*
+ * Enforce a DME 'choice' previously made
+ */
+static inline int select_dme(int dme_no,
+			     int *num_dmes,
+			     int *dmes_in_use,
+			     int *dmes,
+			     int value)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (dme_no < num_dmes[i]) {
+			dmes_in_use[i] &= ~(1 << dme_no);
+			dmes_in_use[i] |= (value << dme_no);
+			return 0;
+		} else {
+			dme_no -= num_dmes[i];
+		}
+	}
+
+	return -ENXIO;	/* Not available */
+}
+
+/* Selects the DME for an Mbox
+ * based on its occupancy. Two Outbound DMEs
+ * are shared among mailboxes
+ */
+static inline int choose_ob_dme_static(
+	struct rio_priv	*priv,
+	int mbox_dest,
+	int buf_sz,
+	struct rio_msg_dme **ob_dme)
+{
+	int  i, ndx, sz, min_entries = 0;
+	int  dme_no = 0, ret_dme_no = -ENXIO;
+	struct rio_msg_dme *ret_dme = NULL;
+	struct rio_tx_dme *dme_s;
+
+	/* Multi-segment vs single-segment DMEs */
+	ndx = RIO_MBOX_TO_IDX(mbox_dest);
+	switch (ndx) {
+	case 0:
+		if ((priv->num_outb_dmes[0] == 0) || (priv->outb_dmes[0] == 0))
+			return -ENXIO;
+		break;
+	case 1:
+		if ((priv->num_outb_dmes[1] == 0) || (priv->outb_dmes[1] == 0))
+			return -ENXIO;
+		dme_no += priv->num_outb_dmes[0];
+		break;
+	default:
+		dev_err(priv->dev, "Attempt to select unknown OB DME type!\n");
+		return -ENXIO;
+	}
+
+	/* Find one with fewest entries, or sufficient free entries */
+	for (i = 0; i < priv->num_outb_dmes[ndx]; i++, dme_no++) {
+		sz = RIO_OUTB_DME_TO_BUF_SIZE(priv, dme_no);
+
+		if (sz > buf_sz)
+			continue;
+
+		dme_s = &priv->ob_dme_shared[dme_no];
+
+		if (dme_s->ring_size_free > min_entries) {
+			min_entries = dme_s->ring_size_free;
+			ret_dme = dme_s->me;
+			ret_dme_no = dme_no;
+		}
+	}
+
+	(*ob_dme) = ret_dme;
+	return ret_dme_no;
+}
+
+static void release_mbox(struct kref *kref)
+{
+	struct rio_rx_mbox *mb = container_of(kref, struct rio_rx_mbox, kref);
+	struct rio_priv *priv = mb->mport->priv;
+	int letter;
+	u32 dme_no;
+
+	/* Quickly disable the engines */
+	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++) {
+		if (mb->me[letter])
+			axxia_local_config_write(priv,
+				   RAB_IB_DME_CTRL(mb->me[letter]->dme_no), 0);
+	}
+
+	/* And then release the remaining resources */
+	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++) {
+		if (mb->me[letter]) {
+			dme_no = mb->me[letter]->dme_no;
+			dme_put(mb->me[letter]);
+			select_dme(dme_no,
+					&priv->num_inb_dmes[0],
+					&priv->inb_dmes_in_use[0],
+					&priv->inb_dmes[0], 0);
+			priv->ib_dme[dme_no] = NULL;
+		}
+	}
+
+
+	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++)
+		kfree(mb->virt_buffer[letter]);
+
+	kfree(mb);
+}
+
+static inline struct rio_rx_mbox *mbox_get(struct rio_rx_mbox *mb)
+{
+	if (mb)
+		kref_get(&mb->kref);
+	return mb;
+}
+
+static inline void mbox_put(struct rio_rx_mbox *mb)
+{
+	if (mb)
+		kref_put(&mb->kref, release_mbox);
+}
+
+static int alloc_msg_descriptors(struct rio_mport *mport,
+				  struct resource *dres,
+				  int buf_sz,
+				  int entries,
+				  int need_to_init,
+				  struct rio_msg_desc **desc,
+				  struct rio_desc **descriptors)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_msg_desc *rdesc = NULL, *idesc;
+	struct rio_desc *rdescriptors = NULL;
+	int i;
+
+	if (priv->intern_msg_desc) {
+		dres->name = "DME_DESC";
+		dres->flags = ACP_RESOURCE_HW_DESC;
+		if (allocate_resource(&priv->acpres[ACP_HW_DESC_RESOURCE],
+				dres, entries,
+				priv->acpres[ACP_HW_DESC_RESOURCE].start,
+				priv->acpres[ACP_HW_DESC_RESOURCE].end,
+				0x1, NULL, NULL)) {
+			memset(dres, 0, sizeof(*dres));
+			goto err;
+		}
+	} else {
+		dres->start = 0;
+	}
+
+	rdesc = kzalloc(sizeof(struct rio_msg_desc) * entries, GFP_ATOMIC);
+	if (rdesc == NULL)
+		goto err;
+	rdescriptors = kzalloc(sizeof(struct rio_desc) * entries, GFP_ATOMIC);
+	if (rdescriptors == NULL)
+		goto err;
+
+	for (i = 0, idesc = rdesc; i < need_to_init; i++, idesc++) {
+		idesc->msg_virt = kzalloc(buf_sz, GFP_KERNEL);
+		if (!idesc->msg_virt)
+			goto err;
+		idesc->msg_phys = virt_to_phys(idesc->msg_virt);
+	}
+
+	idesc--;
+	idesc->last = DME_DESC_DW0_NXT_DESC_VALID;
+
+	(*desc) = rdesc;
+	(*descriptors) = rdescriptors;
+
+	return 0;
+
+err:
+	kfree(rdesc);
+	kfree(rdescriptors);
+	return -ENOMEM;
+}
+
+static struct rio_msg_dme *alloc_message_engine(struct rio_mport *mport,
+						int dme_no, void *dev_id,
+						int buf_sz, int entries)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_msg_dme *me = kzalloc(sizeof(struct rio_msg_dme),
+					 GFP_KERNEL);
+	int rc = 0;
+
+	if (!me)
+		return ERR_PTR(-ENOMEM);
+
+	memset(me, 0, sizeof(struct rio_msg_dme));
+
+	kref_init(&me->kref);
+	spin_lock_init(&me->lock);
+	me->priv = priv;
+	me->sz = 0;/*buf_sz;*/
+
+	rc = alloc_msg_descriptors(mport, &me->dres, buf_sz, entries,
+				entries, &me->desc, &me->descriptors);
+	if (rc < 0)
+		goto err;
+
+	me->entries = entries;
+	me->dev_id = dev_id;
+	me->write_idx = 0;
+	me->read_idx = 0;
+	me->tx_dme_tmo = 0;
+	me->dme_no = dme_no;
+
+	return me;
+
+err:
+	dme_put(me);
+	return ERR_PTR(rc);
+}
+
+/**
+ * ob_dme_msg_handler - Outbound Data message handler
+ * --- Called from OB DME irq handler thread ---
+ * @h: Pointer to interrupt-specific data
+ *
+ * Handles outbound message interrupts. Executes a callback,
+ * if available.
+ *
+ * @note:
+ * HW descriptor fetch and update may be out of order.
+ * Check state of all used descriptors and take care to not fall into
+ * any of the traps that come with this design:
+ *
+ * Due to this (possibly) out of order execution in the HW, SW ack of
+ * descriptors must be done atomically, re-enabling descriptors with
+ * completed transactions while processing finished transactions may
+ * break the ring and leave the DMA engine in a state where it doesn't
+ * process new inserted requests.
+ */
+static void  ob_dme_msg_handler(struct rio_irq_handler *h, u32 dme_no)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_mport *mport = priv->mport;
+	struct rio_msg_dme *dme = priv->ob_dme_shared[dme_no].me;
+	u32 dw0;
+	u32 dw1;
+	int mbox;
+	struct rio_tx_mbox *mb;
+	unsigned int iteration = 0;
+
+	/**
+	 * Process all completed transactions
+	 */
+ob_dme_restart:
+	while (dme->read_idx != dme->write_idx) {
+		AXXIA_RIO_SYSMEM_BARRIER();
+		dw0 = *((u32 *)DESC_TABLE_W0_MEM(dme, dme->read_idx));
+		if ((dw0 & DME_DESC_DW0_VALID) &&
+			(dw0 & DME_DESC_DW0_READY_MASK)) {
+			*((u32 *)DESC_TABLE_W0_MEM(dme, dme->read_idx))
+					= dw0 & DME_DESC_DW0_NXT_DESC_VALID;
+			dw1 = *((u32 *)DESC_TABLE_W1_MEM(dme,
+						dme->read_idx));
+			__dme_dw_dbg(priv->dev, dme, 1, dw0, dw1);
+			dme->read_idx = (dme->read_idx + 1) &
+						(dme->entries - 1);
+			mbox = (dw1 >> 2) & 0x3;
+			mb = priv->ob_mbox[mbox];
+			if (mb) {
+				if (mport->outb_msg[mbox].mcback) {
+					mb->tx_slot = (mb->tx_slot + 1)
+							%(mb->ring_size);
+					mport->outb_msg[mbox].mcback(mport,
+							mb->dev_id,
+							mbox, mb->tx_slot);
+				}
+#ifdef CONFIG_AXXIA_RIO_STAT
+				mb->compl_msg_count++;
+#endif
+			}
+			iteration++;
+		} else
+			break;
+	}
+	if (iteration) {
+		iteration = 0;
+		goto ob_dme_restart;
+	}
+}
+
+/**
+ * ob_dme_irq_handler - Outbound message interrupt handler
+ * --- Called in threaded irq handler ---
+ * @h: Pointer to interrupt-specific data
+ *
+ * Handles outbound message interrupts. Calls the
+ * msg handler if dscriptor xfer complete is set.
+ * or reports the error
+ */
+enum hrtimer_restart ob_dme_tmr_handler(struct hrtimer *hr)
+{
+	struct rio_tx_dme *obd = container_of(hr, struct rio_tx_dme, tmr);
+	struct rio_msg_dme *me = obd->me;
+	struct rio_priv *priv = me->priv;
+	struct rio_irq_handler *h = &priv->ob_dme_irq;
+	u32 dme_stat, dme_no;
+
+	dme_no = me->dme_no;
+	axxia_local_config_read(priv, RAB_OB_DME_STAT(dme_no),
+						&dme_stat);
+
+	if (dme_stat & (OB_DME_STAT_DESC_FETCH_ERR |
+				OB_DME_STAT_DESC_ERR |
+				OB_DME_STAT_DESC_UPD_ERR))
+		dev_err(priv->dev, "OB DME%d: Descriptor Error\n",
+								dme_no);
+	else {
+
+		if (dme_stat & (OB_DME_STAT_DATA_TRANS_ERR |
+				OB_DME_STAT_RESP_ERR |
+				OB_DME_STAT_RESP_TO)) {
+			if (dme_stat & OB_DME_STAT_DATA_TRANS_ERR)
+				dev_err(priv->dev, "OB DME%d: Transaction Error\n",
+								dme_no);
+			if (dme_stat & OB_DME_STAT_RESP_ERR)
+				dev_dbg_ratelimited(priv->dev,
+						"OB DME%d: Response Error\n",
+								dme_no);
+			if (dme_stat & OB_DME_STAT_RESP_TO)
+				dev_err(priv->dev, "OB DME%d: Response Timout Error\n",
+								dme_no);
+		}
+		ob_dme_msg_handler(h, dme_no);
+	}
+	axxia_local_config_write(priv, RAB_OB_DME_STAT(dme_no),
+							dme_stat);
+	hrtimer_forward_now(&obd->tmr, ktime_set(0, axxia_hrtimer_delay));
+	return HRTIMER_RESTART;
+}
+
+static int alloc_ob_dme_shared(struct rio_priv *priv,
+			struct rio_tx_dme *dme_s, int dme_no)
+{
+	int rc = 0;
+	int sz;
+	struct rio_mport *mport = priv->mport;
+	struct rio_msg_dme *me = NULL;
+	struct rio_msg_desc *desc = NULL;
+	u32 dw0, dw1, dw2, dw3;
+	u64  desc_chn_start = 0;
+	int entries = OB_DME_ENTRIES;
+	int i;
+
+	sz = RIO_OUTB_DME_TO_BUF_SIZE(priv, dme_no);
+	entries = roundup_pow_of_two(entries);
+	me = alloc_message_engine(mport,
+				dme_no, NULL, sz, entries);
+	if (IS_ERR(me)) {
+		rc = PTR_ERR(me);
+		goto err;
+	}
+
+	for (i = 0, desc = me->desc; i < entries; i++, desc++) {
+		dw0 = 0;
+		if (!priv->intern_msg_desc) {
+			dw1 = 0;
+			if (axxia_rio_is_x9()) {
+				dw0 = (u32)(desc->msg_phys >> 38) & 0x3;
+				dw0 = (u32)(dw0 << 12);
+			}
+			dw2 = (u32)(desc->msg_phys >>  8) & 0x3fffffff;
+			*((u32 *)DESC_TABLE_W0_MEM(me, i)) = dw0;
+			*((u32 *)DESC_TABLE_W1_MEM(me, i)) = dw1;
+			*((u32 *)DESC_TABLE_W2_MEM(me, i)) = dw2;
+			*((u32 *)DESC_TABLE_W3_MEM(me, i)) = 0;
+		} else {
+			dw1 = 0;
+			dw2 = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
+			__rio_local_write_config_32(mport,
+				    DESC_TABLE_W0(me->dres.start+i), dw0);
+			__rio_local_write_config_32(mport,
+				    DESC_TABLE_W1(me->dres.start+i), dw1);
+			__rio_local_write_config_32(mport,
+				    DESC_TABLE_W2(me->dres.start+i), dw2);
+			__rio_local_write_config_32(mport,
+				    DESC_TABLE_W3(me->dres.start+i), 0);
+		}
+	}
+
+
+	/**
+	* Last descriptor - make ring.
+	* Next desc table entry -> dw2.First desc address[37:36]
+	*                       -> dw3.First desc address[35:4].
+	* (desc_base + 0x10 * nr)
+	*/
+	desc--; i--;
+	dw0 |= DME_DESC_DW0_NXT_DESC_VALID;
+	if (!priv->intern_msg_desc) {
+		desc_chn_start =
+			(uintptr_t)virt_to_phys(me->descriptors);
+
+		if (axxia_rio_is_x9()) {
+			dw0  = *((u32 *)DESC_TABLE_W0_MEM(me, i));
+			dw0 |= DME_DESC_DW0_NXT_DESC_VALID;
+			dw3 = (u32)(desc_chn_start >> 38) & 0x3;
+			dw0 |= (dw3 << 14);
+		}
+		dw2  = *((u32 *)DESC_TABLE_W2_MEM(me, i));
+		if (axxia_rio_is_x9())
+			dw2 |= (desc_chn_start >> 6) & 0xc0000000;
+		else
+			dw2 |= (desc_chn_start >> 4) & 0xc0000000;
+		dw3  = desc_chn_start >> 4;
+		*((u32 *)DESC_TABLE_W0_MEM(me, i)) = dw0;
+		*((u32 *)DESC_TABLE_W2_MEM(me, i)) = dw2;
+		*((u32 *)DESC_TABLE_W3_MEM(me, i)) = dw3;
+	} else {
+		desc_chn_start = DESC_TABLE_W0(me->dres.start);
+		__rio_local_read_config_32(mport,
+				DESC_TABLE_W2(me->dres.start+i), &dw2);
+		dw2 |= ((desc_chn_start >> 8) & 0xc0000000);
+		dw3  = 0;
+		__rio_local_write_config_32(mport,
+				DESC_TABLE_W0(me->dres.start+i), dw0);
+		__rio_local_write_config_32(mport,
+				DESC_TABLE_W2(me->dres.start+i), dw2);
+		__rio_local_write_config_32(mport,
+				DESC_TABLE_W3(me->dres.start+i), dw3);
+	}
+	test_and_set_bit(RIO_DME_OPEN, &me->state);
+	dme_s->me = me;
+	dme_s->ring_size = 0x0;
+	dme_s->ring_size_free = entries;
+err:
+	return rc;
+}
+/**
+ * open_outb_mbox_static - Initialize AXXIA outbound mailbox
+ *			   using statically allocated DME descriptors.
+ *
+ * @mport: Master port implementing the outbound message unit
+ * @dev_id: Device specific pointer to pass on event
+ * @mbox_id: Mailbox to open
+ * @entries: Number of entries in the outbound mailbox ring for each letter
+ * @prio: 0..3, higher number -> lower priority.
+ *
+ * Caller must hold RAB lock
+ * If the specified mbox DME has already been opened/reserved, then we just
+ * abort out of this operation with "busy", and without changing resource
+ * allocation for the mbox DME.
+ *
+ * To increase efficiecny the Descriptors are allocated and initalized during
+ * initialization time and then kept forever to be reused.
+ *
+ * Returns:
+ * %0 if successful
+ * %-EINVAL if an argument is invalid
+ * %-ENOMEM if unable to allocate sufficient memory
+ * %-ENODEV if unable to find a DME matching the input arguments
+ */
+
+static int open_outb_mbox_static(struct rio_mport *mport,
+			void *dev_id, int mbox_id, int entries, int prio)
+{
+	int  rc = 0;
+	int  dme_no, buf_sz = 0;
+	struct rio_priv *priv = mport->priv;
+	struct rio_tx_mbox *mb;/* = priv->ob_mbox[mbox_id];*/
+	struct rio_msg_dme *me = NULL;
+	unsigned long iflags0;
+	u32 dme_ctrl, dme_stat, desc_addr, wait = 0;
+	u64  desc_chn_start = 0;
+
+	if ((mbox_id < 0) || (mbox_id > RIO_MAX_TX_MBOX) ||
+	    (entries < 2) || (entries > priv->desc_max_entries))
+		return -EINVAL;
+	if (priv->ob_mbox[mbox_id])
+		return -EINVAL;
+	mb = kzalloc(sizeof(struct rio_tx_mbox), GFP_KERNEL);
+	if (!mb)
+		return -ENOMEM;
+	spin_lock_init(&mb->lock);
+	mb->dme_no = 0xff;
+#ifdef CONFIG_AXXIA_RIO_STAT
+	mb->sent_msg_count = 0;
+	mb->compl_msg_count = 0;
+#endif
+	spin_lock_irqsave(&mb->lock, iflags0);
+
+	if (test_bit(RIO_MB_OPEN, &mb->state)) {
+		spin_unlock_irqrestore(&mb->lock, iflags0);
+		return -EINVAL;
+	}
+
+	/*
+	** Pick the OB DME that we will use for this mailbox
+	*/
+		buf_sz = RIO_MBOX_TO_BUF_SIZE(mbox_id);
+
+		dme_no = choose_ob_dme_static(priv, mbox_id, buf_sz, &me);
+		if (dme_no < 0) {
+			spin_unlock_irqrestore(&mb->lock, iflags0);
+			rc = dme_no;
+			goto err;
+		}
+		if (IS_ERR_OR_NULL(me)) {
+			spin_unlock_irqrestore(&mb->lock, iflags0);
+			rc = PTR_ERR(me);
+			goto err;
+		}
+
+		if (!test_bit(RIO_DME_MAPPED, &me->state)) {
+			do {
+				axxia_local_config_read(priv,
+					RAB_OB_DME_STAT(dme_no), &dme_stat);
+				if (wait++ > 100) {
+					rc = -EBUSY;
+					goto err;
+				}
+			} while (dme_stat & OB_DME_STAT_TRANS_PEND);
+			desc_chn_start =
+				(uintptr_t)virt_to_phys(me->descriptors);
+
+			dme_ctrl  = (prio & 0x3) << 4;
+			dme_ctrl |= (u32)((desc_chn_start >> 6) & 0xc0000000);
+			desc_addr  = (u32)desc_chn_start >> 4;
+			axxia_local_config_write(priv,
+				RAB_OB_DME_DESC_ADDR(dme_no), desc_addr);
+			axxia_local_config_write(priv, RAB_OB_DME_CTRL(dme_no),
+					dme_ctrl);
+			me->dme_ctrl = dme_ctrl;
+			me->dme_ctrl |= (DME_WAKEUP | DME_ENABLE);
+			priv->ob_dme_irq.irq_state_mask |= (1 << dme_no);
+			axxia_local_config_write(priv, RAB_INTR_STAT_ODME,
+								1<<dme_no);
+			axxia_local_config_write(priv, RAB_INTR_ENAB_ODME,
+					priv->ob_dme_irq.irq_state_mask);
+			test_and_set_bit(RIO_DME_MAPPED, &me->state);
+		}
+
+
+	mb->mport = mport;
+	mb->mbox_no = mbox_id;
+	mb->dme_no = dme_no;
+	mb->me = me;
+	mb->ring_size = entries;
+	mb->tx_slot = 0;
+	mb->dev_id = dev_id;
+	me->sz++;
+	mdelay(500); /* Delay added to ensure completion of any pending TX
+			before Transmission on this Mailbox */
+
+	if (me->sz == 1) {
+		hrtimer_init(&priv->ob_dme_shared[dme_no].tmr,
+				 CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		priv->ob_dme_shared[dme_no].tmr.function = ob_dme_tmr_handler;
+		hrtimer_start(&priv->ob_dme_shared[dme_no].tmr,
+				ktime_set(0, (axxia_hrtimer_delay)),
+					HRTIMER_MODE_REL_PINNED);
+	}
+
+	test_and_set_bit(RIO_MB_MAPPED, &mb->state);
+
+	priv->ob_dme_shared[dme_no].ring_size += entries;
+	priv->ob_dme_shared[dme_no].ring_size_free -= entries;
+
+	spin_unlock_irqrestore(&mb->lock, iflags0);
+
+#ifdef CONFIG_AXXIA_RIO_STAT
+	me->desc_done_count = 0;
+	me->desc_error_count = 0;
+	me->desc_rio_err_count = 0;
+	me->desc_axi_err_count = 0;
+	me->desc_tmo_err_count = 0;
+#endif
+	/**
+	 * Finish updating the mailbox and DME state before we go
+	 */
+	test_and_set_bit(RIO_MB_OPEN, &mb->state);
+	priv->ob_mbox[mbox_id] = mb;
+	return 0;
+
+err:
+	spin_unlock_irqrestore(&mb->lock, iflags0);
+	kfree(mb);
+	return rc;
+}
+
+
+/**
+ * release_outb_dme - Close AXXIA outbound DME engine structures
+ * @mport: Master port implementing the outbound message unit
+ * @mbox: Mailbox to close
+ *
+ * Caller must hold RAB lock
+ * Release all resources i.e. DMEs, descriptors, buffers, and so on.
+ */
+
+static void release_outb_dme(struct rio_irq_handler *h)
+{
+	struct rio_priv *priv = h->data;
+	int i;
+	struct rio_msg_dme *me;
+
+	for (i = 0; i < DME_MAX_OB_ENGINES; i++) {
+		me = priv->ob_dme_shared[i].me;
+		if (me && test_bit(RIO_DME_OPEN, &me->state)) {
+			if (test_bit(RIO_DME_MAPPED, &me->state)) {
+				axxia_local_config_write(priv,
+					RAB_OB_DME_CTRL(me->dme_no), 0);
+
+				select_dme(me->dme_no,
+					&priv->num_outb_dmes[0],
+					&priv->outb_dmes_in_use[0],
+					&priv->outb_dmes[0], 0);
+			}
+
+			dme_put(me);
+		}
+	}
+	h->data = NULL;
+}
+
+/**
+ * ib_dme_irq_handler - AXXIA inbound message interrupt handler
+ * @mport: Master port with triggered interrupt
+ * @mask: Interrupt register data
+ *
+ * Handles inbound message interrupts.  Executes a callback, if available,
+ * on received message. Reports the Error.
+ */
+static void  ib_dme_irq_handler(struct rio_irq_handler *h/*, u32 state*/)
+{
+	struct rio_priv *priv = h->data;
+	struct rio_mport *mport = priv->mport;
+	int mbox_no;
+	int letter;
+	u32 dme_mask, mask;
+ib_dme_restart:
+	axxia_local_config_read(priv, RAB_INTR_STAT_IDME, &dme_mask);
+	mask = dme_mask;
+	if (!mask)
+		return;
+	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mask);
+	/**
+	 * Inbound mbox has 4 engines, 1 per letter.
+	 * For each message engine that contributes to IRQ state,
+	 * go through all descriptors in queue that have been
+	 * written but not handled.
+	 */
+	while (dme_mask) {
+		struct rio_msg_dme *me;
+		u32 dme_stat;
+		int dme_no = __fls(dme_mask);
+
+		dme_mask ^= (1 << dme_no);
+		me = priv->ib_dme[dme_no];
+		/**
+		 * Get and clear latched state
+		 */
+		axxia_local_config_read(priv,
+					   RAB_IB_DME_STAT(dme_no), &dme_stat);
+		axxia_local_config_write(priv,
+					    RAB_IB_DME_STAT(dme_no), dme_stat);
+		if (!me)
+			continue;
+
+		mbox_no = me->mbox;
+		letter = me->letter;
+		if (!(dme_stat & 0xff))
+			continue;
+
+		if (dme_stat & (IB_DME_STAT_DESC_XFER_CPLT |
+				IB_DME_STAT_DESC_CHAIN_XFER_CPLT)) {
+			if (mport->inb_msg[mbox_no].mcback)
+				mport->inb_msg[mbox_no].mcback(mport,
+					me->dev_id, mbox_no, letter);
+		}
+
+		if (dme_stat & IB_DME_STAT_ERROR_MASK) {
+			if (dme_stat & (IB_DME_STAT_DESC_UPDATE_ERR |
+					IB_DME_STAT_DESC_ERR |
+					IB_DME_STAT_DESC_FETCH_ERR))
+				dev_err(priv->dev,
+				"IB Mbox%d Letter%d DME%d: Descriptor Error\n",
+						mbox_no, letter, dme_no);
+
+			if (dme_stat & IB_DME_STAT_DATA_TRANS_ERR)
+				dev_err(priv->dev,
+				"IB Mbox%d Letter%d DME%d: Transaction Error\n",
+						mbox_no, letter, dme_no);
+
+			if (dme_stat & IB_DME_STAT_MSG_ERR)
+				dev_err(priv->dev,
+				"IB MBOX%d Letter%d DME%d: Message Error\n",
+						mbox_no, letter, dme_no);
+
+			if (dme_stat & (IB_DME_STAT_MSG_TIMEOUT))
+				dev_err(priv->dev,
+				"IB MBOX%d Letter%d DME%d: SRIO Timeout\n",
+						mbox_no, letter, dme_no);
+		}
+
+	}
+	goto ib_dme_restart;
+}
+
+enum hrtimer_restart ib_dme_tmr_handler(struct hrtimer *hr)
+{
+	struct rio_rx_mbox *mb = container_of(hr, struct rio_rx_mbox, tmr);
+	struct rio_mport *mport = mb->mport;
+	struct rio_priv *priv = mport->priv;
+	int mbox_no;
+	int letter;
+	u32 dme_mask, mask;
+ib_dme_restart:
+	axxia_local_config_read(priv, RAB_INTR_STAT_IDME, &dme_mask);
+	dme_mask &= mb->irq_state_mask;
+	mask = dme_mask;
+	if (!mask) {
+		hrtimer_forward_now(&mb->tmr,
+				ktime_set(0, axxia_hrtimer_delay));
+		return HRTIMER_RESTART;
+	}
+	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mask);
+	/**
+	 * Inbound mbox has 4 engines, 1 per letter.
+	 * For each message engine that contributes to IRQ state,
+	 * go through all descriptors in queue that have been
+	 * written but not handled.
+	 */
+	while (dme_mask) {
+		struct rio_msg_dme *me;
+		u32 dme_stat;
+		int dme_no = __fls(dme_mask);
+
+		dme_mask ^= (1 << dme_no);
+		me = priv->ib_dme[dme_no];
+		/**
+		 * Get and clear latched state
+		 */
+		axxia_local_config_read(priv,
+					   RAB_IB_DME_STAT(dme_no), &dme_stat);
+		axxia_local_config_write(priv,
+					    RAB_IB_DME_STAT(dme_no), dme_stat);
+		if (!me)
+			continue;
+
+		mbox_no = me->mbox;
+		letter = me->letter;
+		if (!(dme_stat & 0xff))
+			continue;
+
+		if (dme_stat & (IB_DME_STAT_DESC_XFER_CPLT |
+				IB_DME_STAT_DESC_CHAIN_XFER_CPLT)) {
+			if (mport->inb_msg[mbox_no].mcback)
+				mport->inb_msg[mbox_no].mcback(mport,
+					me->dev_id, mbox_no, letter);
+		}
+
+		if (dme_stat & IB_DME_STAT_ERROR_MASK) {
+			if (dme_stat & (IB_DME_STAT_DESC_UPDATE_ERR |
+					IB_DME_STAT_DESC_ERR |
+					IB_DME_STAT_DESC_FETCH_ERR))
+				dev_err(priv->dev,
+				"IB Mbox%d Letter%d DME%d: Descriptor Error\n",
+						mbox_no, letter, dme_no);
+
+			if (dme_stat & IB_DME_STAT_DATA_TRANS_ERR)
+				dev_err(priv->dev,
+				"IB Mbox%d Letter%d DME%d: Transaction Error\n",
+						mbox_no, letter, dme_no);
+
+			if (dme_stat & IB_DME_STAT_MSG_ERR)
+				dev_err(priv->dev,
+				"IB MBOX%d Letter%d DME%d: Message Error\n",
+						mbox_no, letter, dme_no);
+
+			if (dme_stat & (IB_DME_STAT_MSG_TIMEOUT))
+				dev_err(priv->dev,
+				"IB MBOX%d Letter%d DME%d: SRIO Timeout\n",
+						mbox_no, letter, dme_no);
+		}
+
+	}
+	goto ib_dme_restart;
+}
+/**
+ * open_inb_mbox - Initialize AXXIA inbound mailbox
+ * @mport: Master port implementing the inbound message unit
+ * @dev_id: Device specific pointer to pass on event
+ * @mbox: Mailbox to open 0..(MID-1),
+ *            0..3 multi segment,
+ *            4..(MID-1) single segment
+ * @entries: Number of entries in the inbound mailbox ring
+ *
+ * Initializes buffer ring.  Sets up desciptor ring and memory
+ * for messages for all 4 letters in the mailbox.  [This means
+ * that the actual descriptor requirements are "4 * entries".]
+ *
+ * Returns %0 on success and %-EINVAL or %-ENOMEM on failure.
+ */
+static int open_inb_mbox(struct rio_mport *mport, void *dev_id,
+			 int mbox, int entries)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_irq_handler *h = NULL;
+	int i, letter;
+	int rc, buf_sz;
+	u32 irq_state_mask = 0;
+	u32 dme_ctrl;
+	struct rio_rx_mbox *mb;
+	int j;
+
+	if ((mbox < 0) || (mbox >= RIO_MAX_RX_MBOX))
+		return -EINVAL;
+
+	if ((entries < 2) || (entries > priv->desc_max_entries))
+		return -EINVAL;
+	h = &priv->ib_dme_irq;
+
+	if (priv->ib_mbox[mbox] != NULL)
+		return -EBUSY;
+
+	buf_sz = RIO_MBOX_TO_BUF_SIZE(mbox);
+
+	mb = kzalloc(sizeof(*mb), GFP_KERNEL);
+	if (!mb)
+		return -ENOMEM;
+	mb->mbox_no = mbox;
+
+	kref_init(&mb->kref);
+/* Adding 1 to entries to ensure the presence of invalid descriptor
+ * in the circular buffer, to avoid the hardware getting into an
+ * indefinite loop */
+	entries = entries+1;
+/* Rounding up to the power of two for efficient handling */
+	entries = roundup_pow_of_two(entries);
+	dev_dbg(priv->dev, "Opening inbound mbox %d with %d entries\n",
+							mbox, entries);
+	/**
+	 *  Initialize rx buffer ring
+	 */
+	mb->mport = mport;
+	mb->ring_size = entries;
+	for (i = 0; i < RIO_MSG_MAX_LETTER; i++) {
+		mb->virt_buffer[i] = kzalloc(mb->ring_size * sizeof(void *),
+								GFP_KERNEL);
+		if (!mb->virt_buffer[i]) {
+			kfree(mb);
+			return -ENOMEM;
+		}
+		mb->last_rx_slot[i] = 0;
+		mb->next_rx_slot[i] = 0;
+		for (j = 0; j < mb->ring_size; j++)
+			mb->virt_buffer[i][j] = NULL;
+	}
+
+	/**
+	 * Since we don't have the definition of letter in the generic
+	 * RIO layer, we set up IB mailboxes for all letters for each
+	 * mailbox.
+	 */
+	for (letter = 0; letter < RIO_MSG_MAX_LETTER; ++letter) {
+		int dme_no = 0;
+		struct rio_msg_dme *me = NULL;
+		struct rio_msg_desc *desc;
+		u32 dw0, dw1, dw2, dw3;
+		u64 desc_chn_start, desc_addr;
+		u32 dme_stat, wait = 0;
+		u32 buffer_size = (buf_sz > 256 ? 3 : 0);
+
+		/* Search for a free DME, so we can more efficiently map
+		 * them to the all of the mbox||letter combinations. */
+		for (i = 0, rc = -1;
+		     i < (priv->num_inb_dmes[0]+priv->num_inb_dmes[1]);
+		     i++) {
+			rc = check_dme(i, &priv->num_inb_dmes[0],
+				&priv->inb_dmes_in_use[0], &priv->inb_dmes[0]);
+			if (rc == 0) {
+				dme_no = i;
+				break;
+			}
+		}
+		if (rc < 0)
+			return rc;
+
+		me = alloc_message_engine(mport,
+					  dme_no,
+					  dev_id,
+					  buf_sz,
+					  entries);
+		if (IS_ERR(me)) {
+			rc = PTR_ERR(me);
+			goto err;
+		}
+
+		irq_state_mask |= (1 << dme_no);
+
+		do {
+			axxia_local_config_read(priv,
+						   RAB_IB_DME_STAT(me->dme_no),
+						   &dme_stat);
+			if (wait++ > 100) {
+				rc = -EBUSY;
+				goto err;
+			}
+		} while (dme_stat & IB_DME_STAT_TRANS_PEND);
+
+		mb->me[letter] = me;
+
+		dw0 = ((buffer_size & 0x3) << 4) |
+		      DME_DESC_DW0_EN_INT;
+			/*Valid bit will be set in add_inb_buffer*/
+
+		dw1 = DME_DESC_DW1_XMBOX(mbox) |
+		      DME_DESC_DW1_MBOX(mbox)  |
+		      DME_DESC_DW1_LETTER(letter);
+		dw3 = 0;		/* 0 means, next contiguous addr
+					 * Also next desc valid bit in dw0
+					 * must be zero. */
+		for (i = 0, desc = me->desc; i < entries; i++, desc++) {
+			if (!priv->intern_msg_desc) {
+				/* Reference AXX5500 Peripheral Subsystem
+				 * Multicore Reference Manual, January 2013,
+				 * Chapter 5, p. 584 */
+				if (axxia_rio_is_x9()) {
+					dw2 = (u32)(desc->msg_phys >> 8) &
+								0xc0000000;
+					dw2 = (dw2 >> 9);
+					dw1 |= dw2;
+				} else
+					dw1 |= 0;
+				dw2  = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
+				*((u32 *)DESC_TABLE_W0_MEM(me,
+						 i)) = dw0;
+				*((u32 *)DESC_TABLE_W1_MEM(me,
+						 i)) = dw1;
+				*((u32 *)DESC_TABLE_W2_MEM(me,
+						 i)) = dw2;
+				*((u32 *)DESC_TABLE_W3_MEM(me,
+						 i)) = dw3;
+			} else {
+				dw1 |= 0;
+				dw2  = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
+				__rio_local_write_config_32(mport,
+					DESC_TABLE_W0(me->dres.start+i), dw0);
+				__rio_local_write_config_32(mport,
+					DESC_TABLE_W1(me->dres.start+i), dw1);
+				__rio_local_write_config_32(mport,
+					DESC_TABLE_W2(me->dres.start+i), dw2);
+				__rio_local_write_config_32(mport,
+					DESC_TABLE_W3(me->dres.start+i), dw3);
+			}
+		}
+
+		/**
+		 * Last descriptor - make ring.
+		 * Next desc table entry -> dw2.First desc address[37:36].
+		 *                       -> dw3.First desc address[35:4].
+		 * (desc_base + 0x10 * nr)
+		 */
+		desc--; i--;
+		dw0 |= DME_DESC_DW0_NXT_DESC_VALID;
+		dw0 &= ~DME_DESC_DW0_VALID;
+		if (!priv->intern_msg_desc) {
+			desc_chn_start =
+				(uintptr_t)virt_to_phys(me->descriptors);
+			if (axxia_rio_is_x9()) {
+				dw1  = *((u32 *)DESC_TABLE_W1_MEM(me, i));
+				dw2  = (u32)(desc_chn_start >> 8) & 0xc0000000;
+				dw2  = (u32)(dw2 >> 11);
+				dw1 |= dw2;
+			}
+			dw2  = *((u32 *)DESC_TABLE_W2_MEM(me, i));
+			if (axxia_rio_is_x9())
+				dw2 |= (desc_chn_start >> 6) & 0xc0000000;
+			else
+				dw2 |= (desc_chn_start >> 4) & 0xc0000000;
+			dw3  = desc_chn_start >> 4;
+			*((u32 *)DESC_TABLE_W0_MEM(me, i)) = dw0;
+			if (axxia_rio_is_x9())
+				*((u32 *)DESC_TABLE_W1_MEM(me, i)) = dw1;
+			*((u32 *)DESC_TABLE_W2_MEM(me, i)) = dw2;
+			*((u32 *)DESC_TABLE_W3_MEM(me, i)) = dw3;
+		} else {
+			desc_chn_start = DESC_TABLE_W0(me->dres.start);
+
+			__rio_local_read_config_32(mport,
+					    DESC_TABLE_W2(me->dres.start+i),
+					    &dw2);
+			dw3  = 0;
+			dw2 |= ((desc_chn_start >> 8) & 0xc0000000);
+			__rio_local_write_config_32(mport,
+						DESC_TABLE_W0(me->dres.start+i),
+						dw0);
+			__rio_local_write_config_32(mport,
+						DESC_TABLE_W2(me->dres.start+i),
+						dw2);
+			__rio_local_write_config_32(mport,
+						DESC_TABLE_W3(me->dres.start+i),
+						dw3);
+		}
+
+		/**
+		 * Setup the DME including descriptor chain start address
+		 */
+		dme_ctrl = RAB_IB_DME_CTRL_XMBOX(mbox)    |
+			   RAB_IB_DME_CTRL_MBOX(mbox)     |
+			   RAB_IB_DME_CTRL_LETTER(letter) |
+			   DME_WAKEUP                     |
+			   DME_ENABLE;
+		dme_ctrl |= (u32)((desc_chn_start >> 6) & 0xc0000000);
+		if (axxia_rio_is_x9())
+			dme_ctrl |= (u32)((desc_chn_start >> 12) & 0x0c000000);
+		desc_addr  = (u32)desc_chn_start >> 4;
+
+		me->dme_ctrl = dme_ctrl;
+		me->letter = letter;
+		me->mbox = mbox;
+		priv->ib_dme[dme_no] = me;
+
+		axxia_local_config_write(priv,
+					RAB_IB_DME_DESC_ADDR(dme_no),
+					desc_addr);
+		axxia_local_config_write(priv,
+					RAB_IB_DME_CTRL(dme_no), dme_ctrl);
+
+#ifdef CONFIG_AXXIA_RIO_STAT
+		me->desc_done_count = 0;
+		me->desc_error_count = 0;
+		me->desc_rio_err_count = 0;
+		me->desc_axi_err_count = 0;
+		me->desc_tmo_err_count = 0;
+#endif
+		select_dme(dme_no, &priv->num_inb_dmes[0],
+			&priv->inb_dmes_in_use[0], &priv->inb_dmes[0], 1);
+	}
+
+	/**
+	* Create irq handler and enable MBOX irq
+	*/
+
+	mb->irq_state_mask = irq_state_mask;
+	h->irq_state_mask |= irq_state_mask;
+	priv->ib_mbox[mbox] = mb;
+	AXXIA_RIO_SYSMEM_BARRIER();
+	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, irq_state_mask);
+
+	if (priv->dme_mode == AXXIA_IBDME_TIMER_MODE) {
+		hrtimer_init(&mb->tmr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		mb->tmr.function = ib_dme_tmr_handler;
+		hrtimer_start(&mb->tmr, ktime_set(0, (axxia_hrtimer_delay)),
+					HRTIMER_MODE_REL_PINNED);
+	} else
+		axxia_local_config_write(priv, RAB_INTR_ENAB_IDME,
+						h->irq_state_mask);
+	return 0;
+
+err:
+	mbox_put(mb);
+	return rc;
+}
+
+/**
+ * release_inb_mbox - Close AXXIA inbound mailbox
+ * @mport: Master port implementing the inbound message unit
+ * @mbox: Mailbox to close
+ *
+ * Caller must hold RAB lock
+ * Release all resources i.e. DMEs, descriptors, buffers, and so on.
+ */
+
+static void release_inb_mbox(struct rio_irq_handler *h)
+{
+	struct rio_rx_mbox *mb = h->data;
+/*TODO*/
+	h->data = NULL;
+	mbox_put(mb);
+}
+
+void axxia_rio_port_get_state(struct rio_mport *mport, int cleanup)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 escsr, iecsr, state;
+
+	if (cleanup) {
+#if defined(CONFIG_AXXIA_RIO_STAT)
+		reset_state_counters(priv);
+#endif
+		/**
+		 * Clear latched state indications
+		 */
+		/* Miscellaneous Events */
+		axxia_local_config_read(priv, RAB_INTR_STAT_MISC, &state);
+		axxia_local_config_write(priv, RAB_INTR_STAT_MISC, state);
+		/* Outbound Message Engine */
+		axxia_local_config_read(priv, RAB_INTR_STAT_ODME, &state);
+		axxia_local_config_write(priv, RAB_INTR_STAT_ODME, state);
+		/* Inbound Message Engine */
+		axxia_local_config_read(priv, RAB_INTR_STAT_IDME, &state);
+		axxia_local_config_write(priv, RAB_INTR_STAT_IDME, state);
+		/* Axxi Bus to RIO Events */
+		axxia_local_config_read(priv, RAB_INTR_STAT_APIO, &state);
+		axxia_local_config_write(priv, RAB_INTR_STAT_APIO, state);
+		/* RIO to Axxia Bus Events */
+		axxia_local_config_read(priv, RAB_INTR_STAT_RPIO, &state);
+		axxia_local_config_write(priv, RAB_INTR_STAT_RPIO, state);
+	}
+
+	/* Master Port state */
+	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &escsr);
+	axxia_local_config_read(priv, EPC_IECSR(priv->port_ndx), &iecsr);
+
+	/* Adding I2E to preserve idle sequence select bit which is R/w */
+	axxia_local_config_write(priv, RIO_ESCSR(priv->port_ndx),
+				(escsr & (RIO_ESCSR_I2E | RIO_EXCSR_WOLR)));
+}
+
+/**
+ * RIO MPORT Driver API
+ */
+
+/**
+ * axxia_rio_port_irq_enable - Register RIO interrupt handler
+ *
+ * @mport: master port
+ * @irq: IRQ mapping from DTB
+ *
+ * Caller must hold RAB lock
+ *
+ * Returns:
+ * 0        Success
+ * <0       Failure
+ */
+int axxia_rio_port_irq_enable(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	int rc;
+
+	priv->dme_mode = axxia_dme_tmr_mode[priv->ndx];
+	/**
+	 * Clean up history
+	 * from port reset/restart
+	 */
+	axxia_rio_port_get_state(mport, 1);
+	rc = alloc_irq_handler(&priv->misc_irq, priv, "rio-misc-db");
+	if (rc)
+		goto out;
+
+	__rio_local_write_config_32(mport, RAB_SRDS_CTRL1, 0x0);
+	__rio_local_write_config_32(mport, RAB_SRDS_CTRL2,
+					/*LINK_DOWN_TIMEOUT*/0x0);
+	rc = alloc_irq_handler(&priv->linkdown_irq, priv, "rio-ld");
+	if (rc)
+		goto err1;
+	rc = alloc_irq_handler(&priv->apio_irq, priv, "rio-apio");
+	if (rc)
+		goto err2;
+
+	rc = alloc_irq_handler(&priv->rpio_irq, priv, "rio-rpio");
+	if (rc)
+		goto err3;
+	priv->ib_dme_irq.data = priv;
+	priv->ob_dme_irq.data = priv;
+
+	if (priv->dme_mode == AXXIA_IBDME_INTERRUPT_MODE) {
+		rc = request_threaded_irq(priv->irq_line,
+				hw_irq_dme_handler, NULL,
+				IRQF_TRIGGER_NONE | IRQF_SHARED,
+				"rio-mb", (void *)priv);
+		if (rc)
+			goto err4;
+
+		axxia_local_config_write(priv, RAB_INTR_ENAB_GNRL,
+				    (RAB_INTR_ENAB_GNRL_SET | IB_DME_INT_EN));
+	} else
+		axxia_local_config_write(priv, RAB_INTR_ENAB_GNRL,
+				    RAB_INTR_ENAB_GNRL_SET);
+out:
+	return rc;
+err0:
+	dev_warn(priv->dev, "RIO: unable to request irq.\n");
+	goto out;
+err4:
+	release_irq_handler(&priv->rpio_irq);
+err3:
+	release_irq_handler(&priv->apio_irq);
+err2:
+	release_irq_handler(&priv->linkdown_irq);
+err1:
+	release_irq_handler(&priv->misc_irq);
+	goto err0;
+}
+
+void axxia_rio_port_irq_disable(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	/**
+	 * Mask top level IRQs
+	 */
+	axxia_local_config_write(priv, RAB_INTR_ENAB_GNRL, 0);
+	/**
+	 * free registered handlers
+	 */
+	release_irq_handler(&priv->misc_irq);
+	release_irq_handler(&priv->ob_dme_irq);
+	release_irq_handler(&priv->ib_dme_irq);
+	release_irq_handler(&priv->apio_irq);
+	release_irq_handler(&priv->rpio_irq);
+}
+
+int axxia_rio_pw_enable(struct rio_mport *mport, int enable)
+{
+	struct rio_priv *priv = mport->priv;
+	int rc = 0;
+
+	mutex_lock(&priv->api_lock);
+	if (enable)
+		rc = enable_pw(mport);
+	else
+		disable_pw(mport);
+	mutex_unlock(&priv->api_lock);
+
+	return rc;
+}
+
+/**
+ * axxia_rio_doorbell_send - Send a doorbell message
+ *
+ * @mport: RapidIO master port info
+ * @index: ID of RapidIO interface
+ * @destid: Destination ID of target device
+ * @data: 16-bit info field of RapidIO doorbell message
+ *
+ * Sends a doorbell message.
+ *
+ * Returns %0 on success or %-EINVAL on failure.
+ *
+ * API protected by spin lock in generic rio driver.
+ */
+int axxia_rio_doorbell_send(struct rio_mport *mport,
+			    int index, u16 destid, u16 data)
+{
+	struct rio_priv *priv = mport->priv;
+	int db;
+	u32 csr;
+
+	for (db = 0; db < MAX_OB_DB; db++) {
+		axxia_local_config_read(priv, RAB_OB_DB_CSR(db), &csr);
+		if (OB_DB_STATUS(csr) == OB_DB_STATUS_DONE &&
+		    OB_DB_STATUS(csr) != OB_DB_STATUS_RETRY) {
+
+			csr = 0;
+			csr |= OB_DB_DEST_ID(destid);
+			csr |= OB_DB_PRIO(0x2); /* Good prio? */
+			csr |= OB_DB_SEND;
+			dev_dbg(priv->dev,
+			   "Send doorbell 0x%04x to destid 0x%x\n",
+				data, destid);
+			axxia_local_config_write(priv, RAB_OB_DB_INFO(db),
+						    OB_DB_INFO(data));
+			axxia_local_config_write(priv, RAB_OB_DB_CSR(db),
+						    csr);
+			break;
+		}
+	}
+	if (db == MAX_OB_DB)
+		return -EBUSY;
+
+	return 0;
+}
+
+/************/
+/* OUTBOUND */
+/************/
+/**
+ * axxia_open_outb_mbox - Initialize AXXIA outbound mailbox
+ * @mport: Master port implementing the outbound message unit
+ * @dev_id: Device specific pointer to pass on event
+ * @mbox_dme: Mailbox to open
+ * @entries: Number of entries in the outbound DME/mailbox ring for
+ *           each letter
+ *
+ * Allocates and initializes descriptors.
+ * We have N (e.g. 3) outbound mailboxes and M (e.g. 1024) message
+ * descriptors.  The message descriptors are usable by inbound and
+ * outbound message queues, at least until the point of binding.
+ * Allocation/Distribution of message descriptors is flexible and
+ * not restricted in any way other than that they must be uniquely
+ * assigned/coherent to each mailbox/DME.
+ *
+ * Allocate memory for messages.
+ * Each descriptor can hold a message of up to 4kB, though certain
+ * DMEs or mailboxes may impose further limits on the size of the
+ * messages.
+ *
+ * Returns %0 on success and %-EINVAL or %-ENOMEM on failure.
+ */
+int axxia_open_outb_mbox(
+	struct rio_mport *mport,
+	void *dev_id,
+	int mbox_dme,
+	int entries/*,
+	int prio*/)
+{
+	struct rio_priv *priv = mport->priv;
+	int rc = 0;
+
+	mutex_lock(&priv->api_lock);
+	rc = open_outb_mbox_static(mport, dev_id, mbox_dme,
+					entries, 0x0/*prio*/);
+	mutex_unlock(&priv->api_lock);
+
+	return rc;
+}
+
+/**
+ * axxia_close_outb_mbox - Shut down AXXIA outbound mailbox
+ *
+ * @mport: Master port implementing the outbound message unit
+ * @mbox_id: Mailbox to close
+ *
+ * Disables the outbound message unit, frees all buffers, and
+ * frees any other resources.
+ */
+void axxia_close_outb_mbox(struct rio_mport *mport, int mbox_id)
+{
+	struct rio_priv *priv = mport->priv;
+	int dme_no;
+	int wait_cnt = 0;
+	struct rio_msg_dme *me;
+	struct rio_tx_mbox *mb = NULL;
+
+
+	if ((mbox_id < 0) ||
+	    (mbox_id > RIO_MAX_TX_MBOX))
+		return;
+	mb = priv->ob_mbox[mbox_id];
+	if ((!mb) ||
+	    (!test_bit(RIO_MB_OPEN, &mb->state)))
+		return;
+	me = mb->me;
+
+	mutex_lock(&priv->api_lock);
+	clear_bit(RIO_MB_OPEN, &priv->ob_mbox[mbox_id]->state);
+	while (me->write_idx != me->read_idx) {
+		msleep(20);
+		wait_cnt++;
+		if (wait_cnt > 250)
+			break;
+	}
+	if (wait_cnt > 250)
+		pr_debug("Closed when outb mbox%d while transaction pending\n",
+								mbox_id);
+	priv->ob_mbox[mbox_id] = NULL;
+	dme_no = mb->dme_no;
+	mb->dme_no = 0xff;
+
+	priv->ob_dme_shared[dme_no].ring_size -=
+		mb->ring_size;
+
+	priv->ob_dme_shared[dme_no].ring_size_free +=
+		mb->ring_size;
+	mb->dev_id = NULL;
+	clear_bit(RIO_MB_MAPPED, &mb->state);
+	kfree(mb);
+	me->sz--;
+	if (!(me->sz))
+		hrtimer_cancel(&priv->ob_dme_shared[dme_no].tmr);
+	mutex_unlock(&priv->api_lock);
+}
+
+static inline struct rio_msg_desc *get_ob_desc(struct rio_mport *mport,
+						struct rio_msg_dme *mb)
+{
+	int desc_num = mb->write_idx;
+	struct rio_priv *priv = mport->priv;
+	struct rio_msg_desc *desc = &mb->desc[desc_num];
+	int nxt_write_idx = (mb->write_idx + 1) & (mb->entries - 1);
+	u32 dw0;
+
+	if (nxt_write_idx != mb->read_idx) {
+		dw0 = *((u32 *)DESC_TABLE_W0_MEM(mb, desc_num));
+		if (!(dw0 & DME_DESC_DW0_VALID))
+			return desc;
+		else
+			dev_err(priv->dev, "Tx Desc error %d\n", mb->write_idx);
+	}
+	return NULL;
+}
+
+/**
+ * axxia_add_outb_message - Add message to the AXXIA outbound message queue
+ * --- Called in net core soft IRQ with local interrupts masked ---
+ * --- And spin locked in master port net device handler        ---
+ *
+ * @mport: Master port with outbound message queue
+ * @rdev: Target of outbound message
+ * @mbox_dest: Destination mailbox
+ * @letter: TID letter
+ * @flags: 3 bit field,Critical Request Field[2] | Prio[1:0]
+ * @buffer: Message to add to outbound queue
+ * @len: Length of message
+ *
+ * Adds the @buffer message to the AXXIA outbound message queue.
+ * Returns %0 on success
+ *         %-EBUSY  on temporarily unavailable resource failure e.g. such
+ *                     as waiting for an open entry in the outbound DME
+ *                     descriptor chain
+ *         %-EAGAIN on another kind of temporarily unavailable resource
+ *                     failure
+ *         %-EINVAL on invalid argument failure.
+ *         %-ENODEV on unavailable resource failure e.g. no outbound DME
+ *                     open that matches the kind of destination mailbox
+ *         %-ENXIO  on incompatible argument failure e.g. trying to open
+ *                     a single-segment mbox when none are available on
+ *                     the platform
+ */
+int axxia_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
+			     int mbox_dest, int letter, int flags,
+			     void *buffer, size_t len/*, void *cookie*/)
+{
+	int rc = 0;
+	u32 dw0, dw1;
+	u16 destid = (rdev ? rdev->destid : mport->host_deviceid);
+	struct rio_priv *priv = mport->priv;
+	struct rio_tx_mbox *mb = priv->ob_mbox[mbox_dest];
+	struct rio_msg_dme *me;
+	struct rio_msg_desc *desc;
+	u32 dw2_r, dw2, dw0_r = 0, dw0_tmp;
+	u32 idx;
+	u32 seg;
+	u32 lock = 0;
+	u32 cp = 0;
+
+	if (!mb)
+		return -EINVAL;
+	me = mb->me;
+	if (me->sz > 1)
+		lock = 1;
+
+	/* Choose a free descriptor in a critical section */
+	if (lock)
+		spin_lock(&me->lock);
+	desc = get_ob_desc(mport, me);
+	if (!desc) {
+		rc = -EBUSY;
+		goto done;
+	}
+
+
+	/* Copy and clear rest of buffer */
+	if ((uintptr_t)buffer > PAGE_OFFSET) {
+		if ((uintptr_t)buffer & 0xFF) {
+			if (unlikely(desc->msg_virt == NULL)) {
+				rc = -ENXIO;
+				goto done;
+			}
+			memcpy(desc->msg_virt, buffer, len);
+			cp = 1;
+		}
+	} else {
+		if (copy_from_user(desc->msg_virt, buffer, len)) {
+			rc = -ENXIO;
+			goto done;
+		}
+		cp = 1;
+	}
+
+	dw0 = DME_DESC_DW0_SRC_DST_ID(destid) |
+	/*	DME_DESC_DW0_EN_INT|*/
+		DME_DESC_DW0_VALID;
+
+#if 0
+	if (!(me->write_idx % 4))
+		dw0 |=	DME_DESC_DW0_EN_INT;
+#endif
+	dw0 |= desc->last;/*DME_DESC_DW0_NXT_DESC_VALID;*/
+	seg = len;
+	if (seg < 256)
+		seg = 256;
+	seg = roundup_pow_of_two(seg) >> 7;
+	dw1 = DME_DESC_DW1_PRIO(flags) |
+		DME_DESC_DW1_CRF(flags) |
+		(fls(seg)<<18) |
+		DME_DESC_DW1_MSGLEN(len) |
+		DME_DESC_DW1_XMBOX(mbox_dest) |
+		DME_DESC_DW1_MBOX(mbox_dest) |
+		DME_DESC_DW1_LETTER(letter);
+	idx = me->write_idx;
+	if (axxia_rio_is_x9())
+		dw0_r  = *((u32 *)DESC_TABLE_W0_MEM(me, idx));
+	dw2_r  = *((u32 *)DESC_TABLE_W2_MEM(me, idx));
+	if (cp) {
+		if (axxia_rio_is_x9()) {
+			dw0_tmp = (u32)(desc->msg_phys >> 38) & 0x3;
+			dw0 |= (dw0_tmp << 12);
+		}
+		dw2 = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
+	} else {
+		if (axxia_rio_is_x9()) {
+			dw0_tmp = (u32)(virt_to_phys(buffer) >> 38) & 0x3;
+			dw0 |= (dw0_tmp << 12);
+		}
+		dw2 = (u32)(virt_to_phys(buffer) >> 8) & 0x3fffffff;
+	}
+	dw2 = (dw2_r & 0xc0000000) | dw2;
+	if (axxia_rio_is_x9())
+		dw0 |= (dw0_r & 0x0000c000);
+	me->write_idx = (me->write_idx+1) & (me->entries - 1);
+	*((u32 *)DESC_TABLE_W2_MEM(me, idx)) = dw2;
+	*((u32 *)DESC_TABLE_W1_MEM(me, idx)) = dw1;
+	AXXIA_RIO_SYSMEM_BARRIER();
+	*((u32 *)DESC_TABLE_W0_MEM(me, idx)) = dw0;
+
+	if (lock)
+		spin_unlock(&me->lock);
+	else
+		AXXIA_RIO_SYSMEM_BARRIER();
+	/* Start / Wake up - the stored state is used to avoid a Read */
+	axxia_local_config_write(priv, RAB_OB_DME_CTRL(me->dme_no),
+							me->dme_ctrl);
+
+#ifdef CONFIG_AXXIA_RIO_STAT
+	priv->ob_mbox[mbox_dest]->sent_msg_count++;
+#endif
+	return rc;
+done:
+	if (lock)
+		spin_unlock(&me->lock);
+	return rc;
+}
+
+int axxia_ml_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
+			     int mbox_dest, void *buffer, size_t len)
+{
+	return axxia_add_outb_message(mport, rdev, mbox_dest, 0, 0, buffer,
+						len/*, NULL*/);
+}
+
+/**
+ * axxia_open_inb_mbox - Initialize AXXIA inbound mailbox
+ * @mport: Master port implementing the inbound message unit
+ * @dev_id: Device specific pointer to pass on event
+ * @mbox: Mailbox to open
+ * @entries: Number of entries in the inbound mailbox ring
+ *
+ * Initializes buffer ring.  Set up descriptor ring and memory
+ * for messages for all letters in the mailbox.
+ * Returns %0 on success and %-EINVAL or %-ENOMEM on failure.
+ */
+int axxia_open_inb_mbox(struct rio_mport *mport, void *dev_id,
+			int mbox, int entries)
+{
+	struct rio_priv *priv = mport->priv;
+	int rc = 0;
+
+	mutex_lock(&priv->api_lock);
+	rc = open_inb_mbox(mport, dev_id, mbox, entries);
+	mutex_unlock(&priv->api_lock);
+
+	return rc;
+}
+
+/**
+ * axxia_close_inb_mbox - Shut down AXXIA inbound mailbox
+ * @mport: Master port implementing the inbound message unit
+ * @mbox: Mailbox to close
+ *
+ * Disables the inbound message unit, free all buffers, and
+ * frees resources.
+ */
+void axxia_close_inb_mbox(struct rio_mport *mport, int mbox)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_rx_mbox *mb;
+	u32 letter;
+	u32 dme_stat;
+	u32 dme_no;
+
+	if ((mbox < 0) || (mbox >= RIO_MAX_RX_MBOX))
+		return;
+	mutex_lock(&priv->api_lock);
+	mb = priv->ib_mbox[mbox];
+	if (mb == NULL) {
+		mutex_unlock(&priv->api_lock);
+		return;
+	}
+	priv->ib_dme_irq.irq_state_mask &= ~(mb->irq_state_mask);
+	axxia_local_config_write(priv, RAB_INTR_ENAB_IDME,
+					priv->ib_dme_irq.irq_state_mask);
+	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mb->irq_state_mask);
+	msleep(500);
+	priv->ib_mbox[mbox] = NULL;
+	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++) {
+		int wait = 0;
+
+		if (mb->me[letter]) {
+			dme_no = mb->me[letter]->dme_no;
+			do {
+				axxia_local_config_read(priv,
+					RAB_IB_DME_STAT(dme_no), &dme_stat);
+				if (wait++ > 10000)
+					break;
+			} while (dme_stat & IB_DME_STAT_TRANS_PEND);
+			if (wait > 10000)
+				dev_err(priv->dev,
+					"Closing while Transaction pending\n");
+			axxia_local_config_write(priv,
+					RAB_IB_DME_CTRL(dme_no), 0);
+		}
+	}
+	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mb->irq_state_mask);
+	mb->irq_state_mask = 0;
+	msleep(100);
+	if (priv->dme_mode == AXXIA_IBDME_TIMER_MODE)
+		hrtimer_cancel(&mb->tmr);
+	mbox_put(mb);
+	mutex_unlock(&priv->api_lock);
+}
+
+/**
+ * axxia_add_inb_buffer - Add buffer to the AXXIA inbound message queue
+ * @mport: Master port implementing the inbound message unit
+ * @mbox: Inbound mailbox number
+ * @buf: Buffer to add to inbound queue
+ *
+ * Adds the @buf buffer to the AXXIA inbound message queue.
+ *
+ * Returns %0 on success
+ *         %-EINVAL on invalid argument failure.
+ *         %-EBUSY  on temporarily unavailable resource failure e.g. such
+ *                     as waiting for a filled entry in the inbound DME
+ *                     descriptor chain
+ */
+int axxia_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_rx_mbox *mb;
+	int rc = 0;
+	struct rio_msg_dme *me;
+	struct rio_msg_desc *desc;
+	u32 dw0, dw2, dw2_r, dw1 = 0, dw1_r;
+
+	mb = (priv->ib_mbox[mbox]);
+	if (!mb)
+		return -EINVAL;
+	me = mb->me[0];
+	/* Lockless circular buffer scheme */
+	if (((me->write_idx + 1) & (me->entries - 1)) == me->read_idx)
+		goto busy;
+	if (mb->virt_buffer[0][me->write_idx]) {
+		/* TODO Need to handle this case when DME encounters error */
+		goto busy;
+	}
+
+	dw0 = *((u32 *)DESC_TABLE_W0_MEM(me, me->write_idx));
+	if (dw0 & DME_DESC_DW0_VALID) {
+		dev_dbg(priv->dev, "Filling an already valid buffer %d %x\n",
+							 me->write_idx, dw0);
+		goto busy;
+	}
+	mb->virt_buffer[0][me->write_idx] = buf;
+	if (!((uintptr_t)buf & 0xFF)) {
+		if (axxia_rio_is_x9()) {
+			dw1_r = *((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx));
+			dw2 = (u32)(virt_to_phys(buf) >> 8) & 0xc0000000;
+			dw2 = (dw2 >> 9);
+			dw1 = dw1_r & 0xff9fffff;
+			dw1 |= dw2;
+		}
+		dw2_r = *((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx));
+		dw2 = (u32)(virt_to_phys(buf) >> 8) & 0x3fffffff;
+		dw2 = (dw2_r & 0xc0000000) | dw2;
+		*((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx)) = dw2;
+		if (axxia_rio_is_x9())
+			*((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx)) = dw1;
+	} else {
+		desc = &me->desc[me->write_idx];
+		if (axxia_rio_is_x9()) {
+			dw1_r = *((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx));
+			dw2 = (u32)(desc->msg_phys >> 8) & 0xc0000000;
+			dw2 = (dw2 >> 9);
+			dw1 = dw1_r & 0xff9fffff;
+			dw1 |= dw2;
+		}
+		dw2_r = *((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx));
+		dw2 = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
+		dw2 = (dw2_r & 0xc0000000) | dw2;
+		*((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx)) = dw2;
+		if (axxia_rio_is_x9())
+			*((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx)) = dw1;
+	}
+
+	AXXIA_RIO_SYSMEM_BARRIER();
+	dw0 |= DME_DESC_DW0_VALID;
+	*((u32 *)DESC_TABLE_W0_MEM(me, me->write_idx)) = dw0;
+	AXXIA_RIO_SYSMEM_BARRIER();
+	me->write_idx = (me->write_idx + 1) & (me->entries - 1);
+/*	axxia_local_config_read(priv,
+		RAB_IB_DME_CTRL(me->dme_no), &dme_ctrl);
+	dme_ctrl |= (DME_WAKEUP | DME_ENABLE);*/
+	axxia_local_config_write(priv,
+		RAB_IB_DME_CTRL(me->dme_no), me->dme_ctrl);
+done:
+	return rc;
+busy:
+	rc = -EBUSY;
+	goto done;
+}
+
+/**
+ * axxia_get_inb_message - Fetch an inbound message from the AXXIA
+ *                         message unit
+ * @mport: Master port implementing the inbound message unit
+ * @mbox: Inbound mailbox number
+ * @letter: Inbound mailbox letter
+ * @sz: size of returned buffer
+ *
+ * Gets the next available inbound message from the inbound message queue.
+ *
+ * Returns pointer to the message on success
+ *         NULL on nothing available
+ *         IS_ERR(ptr) on failure with extra information
+ */
+void *axxia_get_inb_message(struct rio_mport *mport, int mbox, int letter,
+			    int *sz/*, int *slot, u16 *destid*/)
+{
+	struct rio_priv *priv = mport->priv;
+	struct rio_rx_mbox *mb;
+	struct rio_msg_dme *me;
+	int num_proc = 0;
+	void *buf = NULL;
+	u32 idx;
+
+	mb = (priv->ib_mbox[mbox]);
+	if (!mb)
+		return NULL;
+	me = (mb->me[letter]);
+	while (1) {
+		struct rio_msg_desc *desc = &me->desc[me->read_idx];
+		u32 dw0, dw1;
+
+		idx = me->read_idx;
+		buf = NULL;
+		*sz = 0;
+		dw0 = *((u32 *)DESC_TABLE_W0_MEM(me, idx));
+		dw1 = *((u32 *)DESC_TABLE_W1_MEM(me, idx));
+		__dme_dw_dbg(priv->dev, me, 0, dw0, dw1);
+		if ((dw0 & DME_DESC_DW0_ERROR_MASK) &&
+		    (dw0 & DME_DESC_DW0_VALID)) {
+			*((u32 *)DESC_TABLE_W0_MEM(me, idx)) =
+					(dw0 & 0xff) | DME_DESC_DW0_VALID;
+/*TODO Need to check here: May need to keep it valid for nocopy case
+ *Proper Error Handling and add_inb_buffer Required */
+			pr_err("Desc error %d\n", dw0);
+			me->read_idx = (me->read_idx + 1) & (me->entries - 1);
+			num_proc++;
+		} else if ((dw0 & DME_DESC_DW0_DONE) &&
+			   (dw0 & DME_DESC_DW0_VALID)) {
+			int seg, buf_sz;
+
+			AXXIA_RIO_SYSMEM_BARRIER();
+			seg = DME_DESC_DW1_MSGLEN_F(dw1);
+			buf_sz = DME_DESC_DW1_MSGLEN_B(seg);
+			buf = mb->virt_buffer[letter][me->read_idx];
+			if (!buf) {
+				dev_err(priv->dev, "Buffer Get Error\n");
+				goto err;
+			}
+
+			if ((uintptr_t)buf & 0xFF) {
+				AXXIA_RIO_SYSMEM_BARRIER();
+				memcpy(buf, desc->msg_virt, buf_sz);
+			}
+			mb->virt_buffer[letter][me->read_idx] = NULL;
+			*((u32 *)DESC_TABLE_W0_MEM(me, idx)) =
+					(dw0 & 0xfe);/*DME_DESC_INVALIDATE*/
+			*sz = buf_sz;
+
+			me->read_idx = (me->read_idx + 1) & (me->entries - 1);
+			num_proc++;
+			goto done;
+		} else {
+			goto done;
+		}
+	}
+
+done:
+	return buf;
+err:
+	buf = NULL;
+	goto done;
+}
+EXPORT_SYMBOL(axxia_get_inb_message);
+
+void *axxia_ml_get_inb_message(struct rio_mport *mport, int mbox)
+{
+	int sz;
+
+	return axxia_get_inb_message(mport, mbox, 0, &sz);
+}
+
+void axxia_rio_port_irq_init(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	int i;
+
+	/**
+	 * Port general error indications
+	 */
+	clear_bit(RIO_IRQ_ENABLED, &priv->misc_irq.state);
+	priv->misc_irq.irq_enab_reg_addr = RAB_INTR_ENAB_MISC;
+	priv->misc_irq.irq_state_reg_addr = RAB_INTR_STAT_MISC;
+	priv->misc_irq.irq_state_mask = AMST_INT | ASLV_INT |
+					LINK_REQ_INT;
+	priv->misc_irq.irq_state_mask |= IB_DB_RCV_INT |
+					OB_DB_DONE_INT;
+	priv->misc_irq.irq_state_mask |= PORT_WRITE_INT;
+	priv->misc_irq.irq_state_mask |=
+		GRIO_INT | LL_TL_INT |
+		UNSP_RIO_REQ_INT | UNEXP_MSG_INT;
+
+	priv->misc_irq.thrd_irq_fn = misc_irq_handler;
+	priv->misc_irq.data = NULL;
+	priv->misc_irq.release_fn = misc_release_handler;
+
+
+	/**
+	 * Deadman Monitor status interrupt
+	 */
+	clear_bit(RIO_IRQ_ENABLED, &priv->linkdown_irq.state);
+	priv->linkdown_irq.irq_enab_reg_addr = 0;
+	priv->linkdown_irq.irq_state_reg_addr = RAB_SRDS_STAT1;
+	priv->linkdown_irq.irq_state_mask = RAB_SRDS_STAT1_LINKDOWN_INT;
+	priv->linkdown_irq.thrd_irq_fn = linkdown_irq_handler;
+	priv->linkdown_irq.data = NULL;
+	priv->linkdown_irq.release_fn = NULL;
+
+	/**
+	 * Outbound messages
+	 */
+	clear_bit(RIO_IRQ_ENABLED, &priv->ob_dme_irq.state);
+	priv->ob_dme_irq.irq_enab_reg_addr = RAB_INTR_ENAB_ODME;
+	priv->ob_dme_irq.irq_state_reg_addr = RAB_INTR_STAT_ODME;
+	priv->ob_dme_irq.irq_state_mask = 0;
+/*	priv->ob_dme_irq.thrd_irq_fn = ob_dme_irq_handler;*/
+	priv->ob_dme_irq.data = NULL;
+	priv->ob_dme_irq.release_fn = release_outb_dme;
+
+	for (i = 0; i < RIO_MAX_TX_MBOX; i++)
+		priv->ob_mbox[i] = NULL;
+
+/* Pre-Allocating the Outbound DME Descriptors*/
+	i = roundup_pow_of_two(OB_DME_ENTRIES);
+	pr_info("RIO: Configuring each outbound DME with %d entries\n", i);
+/* MultiSegment DME*/
+	for (i = 0; i < priv->num_outb_dmes[0]; i++)
+		alloc_ob_dme_shared(priv, &priv->ob_dme_shared[i], i);
+/* SingleSegment DME*/
+	for (i = priv->num_outb_dmes[0];
+		i < priv->num_outb_dmes[0] + priv->num_outb_dmes[1]; i++) {
+		alloc_ob_dme_shared(priv, &priv->ob_dme_shared[i], i);
+	}
+
+	/**
+	 * Inbound messages
+	 */
+	clear_bit(RIO_IRQ_ENABLED, &priv->ib_dme_irq.state);
+	priv->ib_dme_irq.irq_enab_reg_addr = RAB_INTR_ENAB_IDME;
+	priv->ib_dme_irq.irq_state_reg_addr = RAB_INTR_STAT_IDME;
+	priv->ib_dme_irq.irq_state_mask = 0x0;/*IB_DME_INT_EN;*/
+	priv->ib_dme_irq.thrd_irq_fn = ib_dme_irq_handler;
+	priv->ib_dme_irq.data = NULL;
+	priv->ib_dme_irq.release_fn = release_inb_mbox;
+
+	for (i = 0; i < DME_MAX_IB_ENGINES; i++)
+		priv->ib_dme[i] = NULL;
+
+	for (i = 0; i < RIO_MAX_RX_MBOX; i++)
+		priv->ib_mbox[i] = NULL;
+	/**
+	 * PIO
+	 * Only when debug config
+	 */
+	clear_bit(RIO_IRQ_ENABLED, &priv->apio_irq.state);
+/*	priv->apio_irq.mport = mport;*/
+	priv->apio_irq.irq_enab_reg_addr = RAB_INTR_ENAB_APIO;
+	priv->apio_irq.irq_state_reg_addr = RAB_INTR_STAT_APIO;
+	priv->apio_irq.irq_state_mask = APIO_TRANS_FAILED;
+#ifdef CONFIG_AXXIA_RIO_STAT
+	priv->apio_irq.irq_state_mask |= APIO_TRANS_COMPLETE;
+#endif
+	priv->apio_irq.thrd_irq_fn = apio_irq_handler;
+	priv->apio_irq.data = NULL;
+	priv->apio_irq.release_fn = NULL;
+
+	clear_bit(RIO_IRQ_ENABLED, &priv->rpio_irq.state);
+	priv->rpio_irq.irq_enab_reg_addr = RAB_INTR_ENAB_RPIO;
+	priv->rpio_irq.irq_state_reg_addr = RAB_INTR_STAT_RPIO;
+	priv->rpio_irq.irq_state_mask = RPIO_TRANS_FAILED;
+#ifdef CONFIG_AXXIA_RIO_STAT
+	priv->rpio_irq.irq_state_mask |= RPIO_TRANS_COMPLETE;
+#endif
+	priv->rpio_irq.irq_state_mask = 0;
+	priv->rpio_irq.thrd_irq_fn = rpio_irq_handler;
+	priv->rpio_irq.data = NULL;
+	priv->rpio_irq.release_fn = NULL;
+
+}
+
+#if defined(CONFIG_RAPIDIO_HOTPLUG)
+int axxia_rio_port_notify_cb(struct rio_mport *mport,
+			       int enable,
+			       void (*cb)(struct rio_mport *mport))
+{
+	struct rio_priv *priv = mport->priv;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&priv->port_lock, flags);
+	if (enable) {
+		if (priv->port_notify_cb)
+			rc = -EBUSY;
+		else
+			priv->port_notify_cb = cb;
+	} else {
+		if (priv->port_notify_cb != cb)
+			rc = -EINVAL;
+		else
+			priv->port_notify_cb = NULL;
+	}
+	spin_unlock_irqrestore(&priv->port_lock, flags);
+
+	return rc;
+}
+
+int axxia_rio_port_op_state(struct rio_mport *mport)
+{
+	u32 escsr;
+
+	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &escsr);
+
+	if (escsr & RIO_ESCSR_PO)
+		return MPORT_STATE_OPERATIONAL;
+	else
+		return MPORT_STATE_DOWN;
+}
+#endif
diff --git a/drivers/rapidio/devices/axxia/axxia-rio-irq.h b/drivers/rapidio/devices/axxia/axxia-rio-irq.h
new file mode 100644
index 0000000..eea9307
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/axxia-rio-irq.h
@@ -0,0 +1,211 @@
+#ifndef __AXXIA_RIO_IRQ_H__
+#define __AXXIA_RIO_IRQ_H__
+
+/**************************sRIO SERDES *****************************/
+#define SRIO_PHY_CONTROL0_OFFSET        (0x200)
+#define APB2SER_SRIO_PHY0_CFG_OFFSET    (0x1e0)
+#define SERDES_CMD0_OFFSET              (0x0)
+#define SERDES_CMD1_OFFSET              (0x4)
+#define SERDES_READDATA0_OFFSET         (0x8)
+#define SERDES_READDATA1_OFFSET         (0xc)
+
+#define SERDES_CMD1_VALID_SHIFT         (31)
+#define SERDES_CMD1_HWRITE_SHIFT        (30)
+#define SERDES_CMD1_TSHIFT_SHIFT        (26)
+#define SERDES_CMD1_HSZIE_SHIFT         (23)
+#define SERDES_CMD1_HTRANS_SHIFT        (21)
+#define SERDES_CMD1_HADDR_MASK          (0xFFFF)
+
+#define SERDES_READDATA1_TMO_SHIFT       (2)
+#define SERDES_READDATA1_HRESP_MASK     (0x3)
+/******************************************************************/
+
+/* forward declaration */
+struct rio_priv;
+
+#define RIO_MSG_MAX_OB_MBOX_MULTI_ENTRIES  15
+#define RIO_MSG_MULTI_SIZE                 0x1000 /* 4Kb */
+#define RIO_MSG_SEG_SIZE                   0x0100 /* 256B */
+#define RIO_MSG_MAX_MSG_SIZE               RIO_MSG_MULTI_SIZE
+#define RIO_MSG_MAX_ENTRIES                1024   /* Default Max descriptor
+						     table entries for internal
+						     descriptor builds */
+#define	RIO_MBOX_TO_IDX(mid)		\
+	((mid <= RIO_MAX_RX_MBOX_4KB) ? 0 : 1)
+#define	RIO_MBOX_TO_BUF_SIZE(mid)		\
+	((mid <= RIO_MAX_RX_MBOX_4KB) ? RIO_MSG_MULTI_SIZE : RIO_MSG_SEG_SIZE)
+#define	RIO_OUTB_DME_TO_BUF_SIZE(p, did)	\
+	((did < p->num_outb_dmes[0]) ? RIO_MSG_MULTI_SIZE : RIO_MSG_SEG_SIZE)
+
+#define DME_MAX_IB_ENGINES          32
+#define     RIO_MAX_IB_DME_MSEG		32
+#define     RIO_MAX_IB_DME_SSEG	        0
+#define DME_MAX_OB_ENGINES          3
+#define     RIO_MAX_OB_DME_MSEG		2
+#define     RIO_MAX_OB_DME_SSEG	        1
+
+#define RIO_MAX_TX_MBOX             64
+#define     RIO_MAX_TX_MBOX_4KB		3
+#define     RIO_MAX_TX_MBOX_256B	63
+#define RIO_MAX_RX_MBOX             64
+#define     RIO_MAX_RX_MBOX_4KB		3
+#define     RIO_MAX_RX_MBOX_256B	63
+
+#define RIO_MSG_MAX_LETTER          4
+
+
+#define RIO_DESC_USED 0		/* Bit index for rio_msg_desc.state */
+
+struct rio_msg_desc {
+/*	unsigned long state;*/
+/*	int desc_no;*/
+	void __iomem *msg_virt;
+	dma_addr_t msg_phys;
+	int last;
+};
+
+struct rio_msg_dme {
+	spinlock_t lock;
+	unsigned long state;
+	struct kref kref;
+	struct rio_priv *priv;
+	struct resource dres;
+	int sz;
+	int entries;
+	int write_idx;
+	int read_idx;
+	int tx_dme_tmo;
+	void *dev_id;
+	int dme_no;
+	int mbox;
+	int letter;
+	u32 dme_ctrl;
+	struct rio_msg_desc *desc;
+	struct rio_desc *descriptors;
+
+#ifdef CONFIG_AXXIA_RIO_STAT
+	unsigned int desc_done_count;
+	unsigned int desc_error_count;
+	unsigned int desc_rio_err_count;
+	unsigned int desc_axi_err_count;
+	unsigned int desc_tmo_err_count;
+#endif
+} ____cacheline_internodealigned_in_smp;
+
+struct rio_rx_mbox {
+	spinlock_t lock;
+	unsigned long state;
+	int mbox_no;
+	struct kref kref;
+	struct rio_mport *mport;
+	void **virt_buffer[RIO_MSG_MAX_LETTER];
+	int last_rx_slot[RIO_MSG_MAX_LETTER];
+	int next_rx_slot[RIO_MSG_MAX_LETTER];
+	int ring_size;
+	struct rio_msg_dme *me[RIO_MSG_MAX_LETTER];
+	unsigned int irq_state_mask;
+	struct hrtimer tmr;
+};
+
+struct rio_tx_mbox {
+	spinlock_t lock;
+	unsigned long state;
+	struct rio_mport *mport;
+	int mbox_no;
+	int dme_no;
+	int ring_size;
+	struct rio_msg_dme *me;
+	void *dev_id;
+	int tx_slot;
+#ifdef CONFIG_AXXIA_RIO_STAT
+	unsigned int sent_msg_count;
+	unsigned int compl_msg_count;
+#endif
+} ____cacheline_internodealigned_in_smp;
+
+struct rio_tx_dme {
+	int	ring_size;
+	int	ring_size_free;
+	struct rio_msg_dme *me;
+	struct hrtimer tmr;
+};
+
+#define PW_MSG_WORDS (RIO_PW_MSG_SIZE/sizeof(u32))
+
+struct rio_pw_irq {
+	/* Port Write */
+	u32 discard_count;
+	u32 msg_count;
+	u32 msg_wc;
+	u32 msg_buffer[PW_MSG_WORDS];
+};
+
+#define RIO_IRQ_ENABLED 0
+#define RIO_IRQ_ACTIVE  1
+
+#define RIO_DME_MAPPED  1
+#define RIO_DME_OPEN    0
+
+#define RIO_MB_OPEN	0
+#define RIO_MB_MAPPED	1
+
+struct rio_irq_handler {
+	unsigned long state;
+/*	struct rio_mport *mport;*/
+	u32 irq_enab_reg_addr;
+	u32 irq_state_reg_addr;
+	u32 irq_state_mask;
+	void (*thrd_irq_fn)(struct rio_irq_handler *h/*, u32 state*/);
+	void (*release_fn)(struct rio_irq_handler *h);
+	void *data;
+};
+
+extern unsigned int axxia_hrtimer_delay;
+/**********************************************/
+/* *********** External Functions *********** */
+/**********************************************/
+
+void axxia_rio_port_irq_init(struct rio_mport *mport);
+void *axxia_get_inb_message(struct rio_mport *mport, int mbox, int letter,
+			      int *sz/*, int *slot, u16 *destid*/);
+int axxia_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf);
+void axxia_close_inb_mbox(struct rio_mport *mport, int mbox);
+int axxia_open_inb_mbox(struct rio_mport *mport, void *dev_id,
+			  int mbox, int entries);
+int axxia_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
+			     int mbox_dest, int letter, int flags,
+			     void *buffer, size_t len/*, void *cookie*/);
+void axxia_close_outb_mbox(struct rio_mport *mport, int mbox_id);
+int axxia_open_outb_mbox(struct rio_mport *mport, void *dev_id, int mbox_id,
+			 int entries/*, int prio*/);
+int axxia_rio_doorbell_send(struct rio_mport *mport,
+			      int index, u16 destid, u16 data);
+int axxia_rio_pw_enable(struct rio_mport *mport, int enable);
+void axxia_rio_port_get_state(struct rio_mport *mport, int cleanup);
+int axxia_rio_port_irq_enable(struct rio_mport *mport);
+void axxia_rio_port_irq_disable(struct rio_mport *mport);
+
+int axxia_ml_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
+			     int mbox_dest, void *buffer, size_t len);
+void *axxia_ml_get_inb_message(struct rio_mport *mport, int mbox);
+int alloc_irq_handler(
+	struct rio_irq_handler *h,
+	void *data,
+	const char *name);
+
+void release_mbox_resources(struct rio_priv *priv, int mbox_id);
+void release_irq_handler(struct rio_irq_handler *h);
+void db_irq_handler(struct rio_irq_handler *h, u32 state);
+extern int axxia_rio_init_sysfs(struct platform_device *dev);
+extern void axxia_rio_release_sysfs(struct platform_device *dev);
+
+#if defined(CONFIG_RAPIDIO_HOTPLUG)
+
+int axxia_rio_port_notify_cb(struct rio_mport *mport,
+			       int enable,
+			       void (*cb)(struct rio_mport *mport));
+int axxia_rio_port_op_state(struct rio_mport *mport);
+
+#endif
+
+#endif /* __AXXIA_RIO_IRQ_H__ */
diff --git a/drivers/rapidio/devices/axxia/axxia-rio-sysfs.c b/drivers/rapidio/devices/axxia/axxia-rio-sysfs.c
new file mode 100644
index 0000000..200ad9f
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/axxia-rio-sysfs.c
@@ -0,0 +1,306 @@
+/*
+ *   This program is free software;  you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.
+ */
+
+/* #define DEBUG */
+/* #define IO_OPERATIONS */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include "axxia-rio.h"
+#include "axxia-rio-irq.h"
+
+static ssize_t axxia_rio_stat_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	char *str = buf;
+	u32 reg_val = 0;
+
+	if (priv->devid  == AXXIA_DEVID_AXM55XX) {
+		str += sprintf(str, "AXM 55xx sRIO Controller");
+		switch (priv->devrev) {
+		case AXXIA_DEVREV_AXM55XX_V1_0:
+			str += sprintf(str, "Revision 0\n");
+			break;
+		case AXXIA_DEVREV_AXM55XX_V1_1:
+			str += sprintf(str, "Revision 1\n");
+			break;
+		case AXXIA_DEVREV_AXM55XX_V1_2:
+			str += sprintf(str, "Revision 2\n");
+			break;
+		default:
+			str += sprintf(str, "Revision Unknown\n");
+			break;
+		}
+	}
+
+	axxia_rio_port_get_state(mport, 0);
+	str += sprintf(str, "Master Port state:\n");
+	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &reg_val);
+	str += sprintf(str, "ESCSR (0x158) : 0x%08x\n", reg_val);
+	return str - buf;
+}
+static DEVICE_ATTR(stat, S_IRUGO, axxia_rio_stat_show, NULL);
+
+static ssize_t axxia_rio_misc_stat_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	char *str = buf;
+
+	str += sprintf(str, "RIO PIO Stat:\n");
+	str += sprintf(str, "\t Successful Count: %d\n",
+					priv->rpio_compl_count);
+	str += sprintf(str, "\t Failed Count    : %d\n",
+					priv->rpio_compl_count);
+
+	str += sprintf(str, "AXI PIO Stat:\n");
+	str += sprintf(str, "\t Successful Count: %d\n",
+					priv->apio_compl_count);
+	str += sprintf(str, "\t Failed Count    : %d\n",
+					priv->apio_compl_count);
+
+	str += sprintf(str, "Port Write Stat:\n");
+	str += sprintf(str, "\t Interrupt Count : %d\n", priv->rio_pw_count);
+	str += sprintf(str, "\t Message Count   : %d\n",
+					priv->rio_pw_msg_count);
+
+	return str - buf;
+
+}
+static DEVICE_ATTR(misc_stat, S_IRUGO,
+		   axxia_rio_misc_stat_show, NULL);
+static ssize_t axxia_rio_ib_dme_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	char *str = buf;
+	int e, j;
+	struct rio_rx_mbox *mb;
+	struct rio_msg_dme *me;
+
+	str += sprintf(str, "Inbound Mailbox (DME) counters:\n");
+	for (e = 0; e < RIO_MAX_RX_MBOX; e++) {
+		mb = priv->ib_mbox[e];
+		if (mb) {
+			for (j = 0; j < RIO_MSG_MAX_LETTER; j++) {
+				me = mb->me[j];
+				str += sprintf(str,
+					"Mbox %d Letter %d DME %d\n",
+					 mb->mbox_no, j, me->dme_no);
+				str += sprintf(str,
+					"\tNumber of Desc Done  : %d\n",
+					me->desc_done_count);
+				str += sprintf(str,
+					"\tNumber of Desc Errors: %d\n",
+					me->desc_error_count);
+				str += sprintf(str,
+					"\t\tRIO Error    : %d\n",
+					me->desc_rio_err_count);
+				str += sprintf(str,
+					"\t\tAXI Error    : %d\n",
+					me->desc_axi_err_count);
+				str += sprintf(str,
+					"\t\tTimeout Error: %d\n",
+					me->desc_tmo_err_count);
+			}
+		}
+	}
+	return str - buf;
+}
+static DEVICE_ATTR(ib_dme_stat, S_IRUGO,
+		   axxia_rio_ib_dme_show, NULL);
+
+static ssize_t axxia_rio_ob_dme_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	char *str = buf;
+	int e;
+	struct rio_msg_dme *me;
+	struct rio_tx_mbox *mb;
+
+	str += sprintf(str, "Outbound Message Engine Counters:\n");
+	for (e = 0; e < DME_MAX_OB_ENGINES; e++) {
+		me = priv->ob_dme_shared[e].me;
+		if (me) {
+			str += sprintf(str, "DME %d Enabled\n", e);
+			str += sprintf(str, "\tNumber of Desc Done  : %d\n",
+					me->desc_done_count);
+			str += sprintf(str, "\tNumber of Desc Errors: %d\n",
+					me->desc_error_count);
+			str += sprintf(str, "\t\tRIO Error    : %d\n",
+					me->desc_rio_err_count);
+			str += sprintf(str, "\t\tAXI Error    : %d\n",
+					me->desc_axi_err_count);
+			str += sprintf(str, "\t\tTimeout Error: %d\n",
+					me->desc_tmo_err_count);
+		} else
+			str += sprintf(str, "DME %d Disabled\n", e);
+	}
+	str += sprintf(str, "*********************************\n");
+	str += sprintf(str, "Outbound Mbox stats\n");
+	for (e = 0; e < RIO_MAX_TX_MBOX; e++) {
+		mb = priv->ob_mbox[e];
+		if (!mb)
+			continue;
+		if ((mb->sent_msg_count) || (mb->compl_msg_count)) {
+			if (test_bit(RIO_DME_OPEN, &mb->state))
+				str += sprintf(str, "Mailbox %d: DME %d\n",
+							e, mb->dme_no);
+			else
+				str += sprintf(str, "Mailbox %d : Closed\n",
+							e);
+			str += sprintf(str, "\tMessages sent     : %d\n",
+						mb->sent_msg_count);
+			str += sprintf(str, "\tMessages Completed: %d\n",
+						mb->compl_msg_count);
+		}
+	}
+
+	return str - buf;
+}
+static DEVICE_ATTR(ob_dme_stat, S_IRUGO,
+		   axxia_rio_ob_dme_show, NULL);
+
+static ssize_t axxia_rio_irq_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	u32 stat;
+	char *str = buf;
+
+	str += sprintf(str, "Interrupt enable bits:\n");
+	axxia_local_config_read(priv, RAB_INTR_ENAB_GNRL, &stat);
+	str += sprintf(str, "General Interrupt Enable (%p)\t%8.8x\n",
+		       (void *)RAB_INTR_ENAB_GNRL, stat);
+	axxia_local_config_read(priv, RAB_INTR_ENAB_ODME, &stat);
+	str += sprintf(str, "Outbound Message Engine  (%p)\t%8.8x\n",
+		       (void *)RAB_INTR_ENAB_ODME, stat);
+	axxia_local_config_read(priv, RAB_INTR_ENAB_IDME, &stat);
+	str += sprintf(str, "Inbound Message Engine   (%p)\t%8.8x\n",
+		       (void *)RAB_INTR_ENAB_IDME, stat);
+	axxia_local_config_read(priv, RAB_INTR_ENAB_MISC, &stat);
+	str += sprintf(str, "Miscellaneous Events     (%p)\t%8.8x\n",
+		       (void *)RAB_INTR_ENAB_MISC, stat);
+	axxia_local_config_read(priv, RAB_INTR_ENAB_APIO, &stat);
+	str += sprintf(str, "Axxia Bus to RIO Events  (%p)\t%8.8x\n",
+		       (void *)RAB_INTR_ENAB_APIO, stat);
+	axxia_local_config_read(priv, RAB_INTR_ENAB_RPIO, &stat);
+	str += sprintf(str, "RIO to Axxia Bus Events  (%p)\t%8.8x\n",
+		       (void *)RAB_INTR_ENAB_RPIO, stat);
+
+	str += sprintf(str, "OBDME : in Timer Mode, Period %9.9d nanosecond\n",
+			axxia_hrtimer_delay);
+	str += sprintf(str, "IBDME : ");
+	if (priv->dme_mode == AXXIA_IBDME_TIMER_MODE)
+		str += sprintf(str, "in Timer Mode, Period %9.9d nanosecond\n",
+			axxia_hrtimer_delay);
+	else
+		str += sprintf(str, "in Interrupt Mode\n");
+	return str - buf;
+}
+static DEVICE_ATTR(irq, S_IRUGO, axxia_rio_irq_show, NULL);
+
+static ssize_t axxia_rio_tmo_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	u32 stat;
+	char *str = buf;
+
+	str += sprintf(str, "Port Link Timeout Control Registers:\n");
+	axxia_local_config_read(priv, RIO_PLTOCCSR, &stat);
+	str += sprintf(str, "PLTOCCSR (%p)\t%8.8x\n",
+		       (void *)RIO_PLTOCCSR, stat);
+	axxia_local_config_read(priv, RIO_PRTOCCSR, &stat);
+	str += sprintf(str, "PRTOCCSR (%p)\t%8.8x\n",
+		       (void *)RIO_PRTOCCSR, stat);
+	axxia_local_config_read(priv, RAB_STAT, &stat);
+	str += sprintf(str, "RAB_STAT (%p)\t%8.8x\n",
+		       (void *)RAB_STAT, stat);
+	axxia_local_config_read(priv, RAB_APIO_STAT, &stat);
+	str += sprintf(str, "RAB_APIO_STAT (%p)\t%8.8x\n",
+		       (void *)RAB_APIO_STAT, stat);
+	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &stat);
+	str += sprintf(str, "PNESCSR (%d)\t%8.8x\n",
+		       RIO_ESCSR(priv->port_ndx), stat);
+
+	return str - buf;
+}
+static DEVICE_ATTR(tmo, S_IRUGO, axxia_rio_tmo_show, NULL);
+
+static ssize_t axxia_ib_dme_log_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct rio_mport *mport = dev_get_drvdata(dev);
+	struct rio_priv *priv = mport->priv;
+	u32 stat, log;
+	char *str = buf;
+
+	axxia_local_config_read(priv, RAB_INTR_STAT_MISC, &stat);
+	log = (stat & UNEXP_MSG_LOG) >> 24;
+	str += sprintf(str, "mbox[1:0]   %x\n", (log & 0xc0) >> 6);
+	str += sprintf(str, "letter[1:0] %x\n", (log & 0x30) >> 4);
+	str += sprintf(str, "xmbox[3:0] %x\n", log & 0x0f);
+
+	return str - buf;
+}
+static DEVICE_ATTR(dme_log, S_IRUGO, axxia_ib_dme_log_show, NULL);
+
+static struct attribute *rio_attributes[] = {
+	&dev_attr_stat.attr,
+	&dev_attr_irq.attr,
+	&dev_attr_misc_stat.attr,
+	&dev_attr_ob_dme_stat.attr,
+	&dev_attr_ib_dme_stat.attr,
+	&dev_attr_tmo.attr,
+	&dev_attr_dme_log.attr,
+	NULL
+};
+
+static struct attribute_group rio_attribute_group = {
+	.name = NULL,
+	.attrs = rio_attributes,
+};
+
+int axxia_rio_init_sysfs(struct platform_device *dev)
+{
+	return sysfs_create_group(&dev->dev.kobj, &rio_attribute_group);
+}
+void axxia_rio_release_sysfs(struct platform_device *dev)
+{
+	sysfs_remove_group(&dev->dev.kobj, &rio_attribute_group);
+}
diff --git a/drivers/rapidio/devices/axxia/axxia-rio.c b/drivers/rapidio/devices/axxia/axxia-rio.c
new file mode 100644
index 0000000..dcfe5e9
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/axxia-rio.c
@@ -0,0 +1,1885 @@
+/*
+ *   This program is free software;  you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.
+ */
+
+/* #define IODEBUG */
+/* #define EXTRA1DEBUG */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kfifo.h>
+#include <linux/dmapool.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/axxia-ncr.h>
+
+#include "axxia-rio.h"
+#include "axxia-rio-irq.h"
+
+#define USE_DME_TIMEOUT
+static DEFINE_SPINLOCK(rio_io_lock);
+
+#ifdef IODEBUG
+#define	IODP(...)	pr_info(__VA_ARGS__)
+#else
+#define	IODP(...)
+#endif
+
+#ifdef EXTRA1DEBUG
+#define	EXT1P(...)	pr_info(__VA_ARGS__)
+#else
+#define	EXT1P(...)
+#endif
+
+#define RIO_IO_READ_HOME        0x00
+#define RIO_MAINT_READ          0x01
+#define RIO_MAINT_WRITE         0x10
+#define RIO_NREAD               0x02
+#define RIO_NWRITE              0x20
+#define RIO_NWRITE_R            0x40
+#define RIO_SWRITE              0x80
+
+#define RIO_PHY_PARALLEL        0x00
+#define RIO_PHY_SERIAL          0x01
+
+int
+axxia_rio_is_x9(void)
+{
+	if (of_find_compatible_node(NULL, NULL, "axxia,axm5616"))
+		return 1;
+
+	return 0;
+}
+
+/**
+ * axxia_rapidio_board_init -
+ *   Perform board-/controller-specific initialization to support
+ *   use of RapidIO busses
+ *
+ * @dev:     [IN] RIO platform device
+ * @ndx:     [IN] Which instance of SRIOC driver needs support
+ * @port_ndx: [OUT] Which port to use for the specified controller
+ *
+ * Returns 0 on success or an error code.
+ */
+int
+axxia_rapidio_board_init(struct platform_device *dev, int dev_num,
+						int *port_ndx)
+{
+	void __iomem *gpreg_base;
+	unsigned long reg0, reg1;
+	unsigned long reg = 0;
+
+	if (!axxia_rio_is_x9()) {
+		/* Reset the RIO port id to zero for this device */
+		gpreg_base = ioremap(0x2010094000, 0x1000);
+		if (gpreg_base == NULL)
+			return -EFAULT;
+
+		reg = inl((unsigned long int)(gpreg_base + 0x60));
+
+		reg &= ~(0xf << (dev_num * 4));
+
+		outl_p(reg, (unsigned long int)(gpreg_base + 0x60));
+
+		(*port_ndx) = 0;
+
+		/* Verify that this device is actually enabled */
+		if (NULL !=
+		of_find_compatible_node(NULL, NULL, "axxia,axm5500-amarillo")) {
+#ifdef CONFIG_AXXIA_NCR
+			ncr_read(NCP_REGION_ID(0x115, 0), 0x23c, 4, &reg);
+
+			if ((reg & (1 << (21+(dev_num*4)))) == 0) {
+				dev_dbg(&dev->dev, "%s: SRIO%d link not ready\n",
+					dev->dev.of_node->full_name, dev_num);
+				return -ENXIO;
+			}
+#endif
+		}
+
+		iounmap(gpreg_base);
+	} else {
+
+		ncr_read(NCP_REGION_ID(0x115, 0), 0x184, 4, &reg0);
+		ncr_read(NCP_REGION_ID(0x115, 0), 0x18c, 4, &reg1);
+		ncr_read(NCP_REGION_ID(0x115, 0), 0x0, 4, &reg);
+
+		dev_info(&dev->dev, "%s: 0x184 = %lx 0x18c = %lx 0x0 = %lx\n",
+			dev->dev.of_node->full_name, reg0, reg1, reg);
+		if (dev_num == 0) {
+			if ((reg & (1 << 3)) == 0) {
+				dev_emerg(&dev->dev, "%s: SRIO%d link not ready\n",
+					dev->dev.of_node->full_name, dev_num);
+				return -ENXIO;
+			}
+			return 0;
+		}
+		if (dev_num == 1) {
+			if ((reg & (1 << 10)) == 0) {
+				dev_emerg(&dev->dev, "%s: SRIO%d link not ready\n",
+					dev->dev.of_node->full_name, dev_num);
+				return -ENXIO;
+			}
+			return 0;
+		}
+		return -ENXIO;
+	}
+	return 0;
+}
+
+/**
+ * NOTE:
+ *
+ * sRIO Bridge in AXXIA is what it is...
+ *
+ * - Paged access to configuration registers makes local config
+ *   read a non-atomic operation.
+ *
+ * - Big and Little Endian mode registers
+ *   Big Endian:
+ *       0x0000-0xFFFC   - RapidIO Standard Registers
+ *       0x10000-0x1FFFC - Endpoint Controller Specific Registers
+ *   Little Endian
+ *       0x20000-0x3FFFC - Peripheral Bus Bridge Specific Registers
+ *
+ * "SRIO_CONF" registers in AXXIA (e.g. page selection register)
+ * are also Little Endian.  SRIO_CONF is organized as follows:
+ *
+ * - 0x000 .. 0x7ff    Fixed mapping to SRIO/RAB endpoint controller specific
+ *                     registers equivalent to 0x20000 .. 0x207ff.  The
+ *                     RAB_APB_CSR register within this block is used to
+ *                     control the page selection of the 'paged mapping'
+ *                     block.
+ * - 0x800 .. 0xfff    Paged mapping to SRIO generic+endpoint controller
+ *                     specific registers equivalent to 0x00000 .. 0x3ffff
+ *
+ * To avoid an extra spin-lock layer in __axxia_local_config_read
+ * and __axxia_local_config_write, perform all internal driver accesses
+ * to local config registers through the generic rio driver API.
+ *
+ * Accesses through the generic driver:__rio_local_write_config_32(),
+ * __rio_local_read_config_32(), rio_mport_write_config_32() and
+ * rio_mport_read_config_32() all use spin_lock_irqsave() /
+ * spin_unlock_irqrestore(), to ensure local access restrictions.
+ *
+ */
+
+/**
+ * __axxia_local_config_read - Generate a AXXIA local config space read
+ * @priv: Master port private data
+ * @offset: Offset into configuration space
+ * @data: Value to be read into
+ *
+ * Generates a AXXIA local configuration space read.
+ * Returns %0 on success or %-EINVAL on failure.
+ */
+int axxia_local_config_read(struct rio_priv *priv,
+			    u32 offset,
+			    u32 *data)
+{
+	u32 page_sel;
+
+
+	if ((offset >= RAB_REG_BASE) &&
+	    (offset < (RAB_REG_BASE+SRIO_CONF_SPACE_SIZE_FIXED))) {
+		/*
+		 * Peripheral Bus Bridge Specific Registers
+		 * (0x2_0000-0x2_0FFC)
+		 */
+		*data = ioread32(priv->regs_win_fixed + (offset & 0x7ff));
+	} else {
+		/* Set correct page to operate on */
+		page_sel = (offset & 0x00fff800) << 5;
+		iowrite32(page_sel, priv->regs_win_fixed + RAB_APB_CSR_BASE);
+
+		if (offset < RAB_REG_BASE) {
+			/*
+			* Registers:
+			*   RapidIO Standard (0x0000-0xFFFC)
+			*   Endpoint Controller Specific (0x1_0000-0x1_FFFC)
+			*/
+			*data = ioread32be(priv->regs_win_paged +
+						(offset & 0x7ff));
+		} else if ((offset >= RAB_REG_BASE) &&
+			   (offset < SRIO_SPACE_SIZE)) {
+			/*
+			* Peripheral Bus Bridge Specific Registers
+			* (0x2_0000-0x3_FFFC)
+			*/
+			*data = ioread32(priv->regs_win_paged +
+						(offset & 0x7ff));
+		} else {
+			dev_err(priv->dev,
+				"RIO: Reading config register not specified for AXXIA (0x%8.8x)\n",
+				offset);
+		}
+	}
+
+	IODP("rio[%d]: ACR(%08x, <%08x)\n", priv->mport->id, offset, *data);
+
+	return 0;
+}
+
+/**
+ * axxia_local_config_write - Generate a AXXIA local config space write
+ * @priv: Master port private data
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be written
+ *
+ * Generates a AXXIA local configuration space write.
+ * Returns %0 on success or %-EINVAL on failure.
+ */
+int axxia_local_config_write(struct rio_priv *priv,
+				      u32 offset,
+				      u32 data)
+{
+	u32 page_sel;
+
+	if ((offset >= RAB_REG_BASE) &&
+	    (offset < (RAB_REG_BASE+SRIO_CONF_SPACE_SIZE_FIXED))) {
+		/*
+		 * Peripheral Bus Bridge Specific Registers
+		 * (0x2_0000-0x2_0FFC)
+		 */
+		iowrite32(data, priv->regs_win_fixed + (offset & 0x7ff));
+	} else {
+		/* Set correct page to operate on */
+		page_sel = (offset & 0x00fff800) << 5;
+		iowrite32(page_sel, priv->regs_win_fixed + RAB_APB_CSR_BASE);
+
+		if (offset < RAB_REG_BASE) {
+			/*
+			* Registers:
+			*   RapidIO Standard (0x0000-0xFFFC)
+			*   Endpoint Controller Specific (0x1_0000-0x1_FFFC)
+			*/
+			iowrite32be(data, priv->regs_win_paged +
+						(offset & 0x7ff));
+		} else if ((offset >= RAB_REG_BASE) &&
+			   (offset < SRIO_SPACE_SIZE)) {
+			/*
+			* Peripheral Bus Bridge Specific Registers
+			* (0x2_0000-0x3_FFFC)
+			*/
+			iowrite32(data, priv->regs_win_paged +
+						(offset & 0x7ff));
+		} else {
+			dev_err(priv->dev,
+				"RIO: Trying to write to config register not specified for AXIA (0x%8.8x)\n",
+				offset);
+		}
+	}
+
+	IODP("rio[%d]: ACW(%08x, >%08x)\n", priv->mport->id, offset, data);
+
+	return 0;
+}
+
+/**
+ * axxia_rio_local_config_read - Generate a AXXIA local config space read
+ * @mport: RapidIO master port info
+ * @index: ID of RapdiIO interface
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be read into
+ *
+ * Generates a AXXIA local configuration space read.
+ * Returns %0 on success or %-EINVAL on failure.
+ */
+static
+int axxia_rio_local_config_read(struct rio_mport *mport,
+				int index, u32 offset, int len, u32 *data)
+{
+	struct rio_priv *priv = mport->priv;
+	int rc;
+
+	if (len != sizeof(u32))
+		return -EINVAL;
+	rc = axxia_local_config_read(priv, offset, data);
+
+	return rc;
+}
+
+/**
+ * axxia_rio_local_config_write - Generate a AXXIA local config space write
+ * @mport: RapidIO master port info
+ * @index: ID of RapdiIO interface
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @data: Value to be written
+ *
+ * Generates a AXXIA local configuration space write.
+ * Returns %0 on success or %-EINVAL on failure.
+ */
+static
+int axxia_rio_local_config_write(struct rio_mport *mport,
+				 int index, u32 offset, int len, u32 data)
+{
+	struct rio_priv *priv = mport->priv;
+	int rc;
+
+	if (len != sizeof(u32))
+		return -EINVAL;
+	rc = axxia_local_config_write(priv, offset, data);
+
+	return rc;
+}
+
+/**
+ * axxia_rio_config_read - Generate a AXXIA read maintenance transaction
+ * @mport: RapidIO master port info
+ * @index: ID of RapdiIO interface
+ * @destid: Destination ID of transaction
+ * @hopcount: Number of hops to target device
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @val: Location to be read into
+ *
+ * Generates a AXXIA read maintenance transaction.
+ * Returns %0 on success or %-EINVAL on failure.
+ */
+
+static
+int axxia_rio_config_read(struct rio_mport *mport, int index,
+			  u16 destid, u8 hopcount, u32 offset,
+			  int len, u32 *val)
+{
+	struct rio_priv *priv = mport->priv;
+	struct atmu_outb *aoutb = NULL;
+	u8 *addr;
+	u32 rval = 0;
+	u32 rbar = 0, ctrl;
+	int rc = 0;
+	u32 error_code = 0;
+
+	aoutb = &priv->outb_atmu[priv->maint_win_id];
+	if (aoutb == NULL)
+		return -EINVAL;
+
+	/* 16MB maintenance windows possible */
+	/* Allow only aligned access to maintenance registers */
+	if (offset > (CONFIG_RIO_MAINT_WIN_SIZE - len) ||
+		!IS_ALIGNED(offset, len))
+		return -EINVAL;
+
+	axxia_local_config_read(priv,
+				       RAB_APIO_AMAP_CTRL(priv->maint_win_id),
+				       &ctrl);
+
+	if (TTYPE_VAL(ctrl)) { /* Not maintenance */
+		dev_err(priv->dev,
+			"(%s): Window is not setup for Maintenance operations. 0x%8.8x\n",
+			__func__, ctrl);
+		return -EINVAL;
+	}
+
+	rbar &= ~HOP_COUNT(0xff);     /* Hop Count clear */
+	rbar |= HOP_COUNT(hopcount);  /* Hop Count set */
+	axxia_local_config_write(priv,
+				 RAB_APIO_AMAP_RBAR(priv->maint_win_id),
+				 rbar);
+
+	ctrl &= ~TARGID(0xffff); /* Target id clear */
+	ctrl |= TARGID(destid);  /* Target id set */
+	axxia_local_config_write(priv,
+				 RAB_APIO_AMAP_CTRL(priv->maint_win_id),
+				 ctrl);
+
+	addr = (u8 *) aoutb->win +
+		(offset & (CONFIG_RIO_MAINT_WIN_SIZE - 1));
+
+	switch (len) {
+	case 1:
+		IN_SRIO8(addr, rval, rc);
+		break;
+	case 2:
+		IN_SRIO16(addr, rval, rc);
+		break;
+	case 4:
+		IN_SRIO32(addr, rval, rc);
+		break;
+	default:
+		rc = -EINVAL;
+	}
+
+	axxia_local_config_read(priv, 0x608, &error_code);
+	if (0 != error_code) {
+		rc = -EINVAL;
+		*val = 0xffffffffu;
+		/* clear error code */
+		axxia_local_config_write(priv,  0x608, 0);
+	}
+
+	if (rc) {
+		dev_dbg(priv->dev,
+			"axxia_rio_config_read: Error when reading\n");
+		dev_dbg(priv->dev,
+			"rio[%d]: RCR(did=%x, hc=%02x, %08x, <%08x)\n",
+			mport->id, destid, hopcount, offset, rval);
+	} else
+		*val = rval;
+
+	IODP("rio[%d]: RCR(did=%x, hc=%02x, %08x, <%08x)\n",
+		mport->id, destid, hopcount, offset, rval);
+
+	return rc;
+}
+
+/**
+ * axxia_rio_config_write - Generate a AXXIA write maintenance transaction
+ * @mport: RapidIO master port info
+ * @index: ID of RapdiIO interface
+ * @destid: Destination ID of transaction
+ * @hopcount: Number of hops to target device
+ * @offset: Offset into configuration space
+ * @len: Length (in bytes) of the maintenance transaction
+ * @val: Value to be written
+ *
+ * Generates an AXXIA write maintenance transaction.
+ * Returns %0 on success or %-EINVAL on failure.
+ */
+static
+int axxia_rio_config_write(struct rio_mport *mport, int index,
+			   u16 destid, u8 hopcount, u32 offset,
+			   int len, u32 val)
+{
+	struct rio_priv *priv = mport->priv;
+	struct atmu_outb *aoutb = NULL;
+	u8 *data;
+	u32 rbar = 0, ctrl, rval;
+	int rc = 0;
+	u32 error_code = 0;
+
+	IODP("rio[%d]: RCW(did=%x, hc=%02x, %08x, >%08x)\n",
+		mport->id, destid, hopcount, offset, val);
+
+	/* Argument validation */
+
+	aoutb = &priv->outb_atmu[priv->maint_win_id];
+	if (aoutb == NULL)
+		return -EINVAL;
+
+	/* 16MB maintenance windows possible */
+	/* Allow only aligned access to maintenance registers */
+	if (offset > (CONFIG_RIO_MAINT_WIN_SIZE - len) ||
+		!IS_ALIGNED(offset, len))
+		return -EINVAL;
+
+	axxia_local_config_read(priv,
+				RAB_APIO_AMAP_CTRL(priv->maint_win_id),
+				&ctrl);
+
+	if (TTYPE_VAL(ctrl)) { /* Not maintenance */
+		dev_err(priv->dev,
+			"(%s): Window is not setup for Maintenance operations.\n",
+			__func__);
+		rc = -EINVAL;
+		goto err;
+	}
+
+	rbar &= ~HOP_COUNT(0xff);     /* Hop Count clear */
+	rbar |= HOP_COUNT(hopcount);  /* Hop Count set */
+	axxia_local_config_write(priv,
+				 RAB_APIO_AMAP_RBAR(priv->maint_win_id),
+				 rbar);
+
+	ctrl &= ~TARGID(0xffff); /* Target id clear */
+	ctrl |= TARGID(destid);  /* Target id set */
+	axxia_local_config_write(priv,
+				 RAB_APIO_AMAP_CTRL(priv->maint_win_id),
+				 ctrl);
+	rval = val;
+	data = (u8 *) aoutb->win +
+		(offset & (CONFIG_RIO_MAINT_WIN_SIZE - 1));
+
+	switch (len) {
+	case 1:
+		OUT_SRIO8(data, rval);
+		break;
+	case 2:
+		OUT_SRIO16(data, rval);
+		break;
+	case 4:
+		OUT_SRIO32(data, rval);
+		break;
+	default:
+		rc = -EINVAL;
+	}
+
+	axxia_local_config_read(priv,  0x608, &error_code);
+	if (0 != error_code) {
+
+		dev_dbg(priv->dev,
+			"axxia_rio_config_write: Error when writing\n");
+
+		dev_dbg(priv->dev,
+			"rio[%d]: RCW(did=%x, hc=%02x, %08x, >%08x)\n",
+			mport->id, destid, hopcount, offset, val);
+
+		rc = -EINVAL;
+		/* clear error code */
+		axxia_local_config_write(priv,  0x608, 0);
+	}
+
+err:
+	return rc;
+}
+
+static inline int __flags2rio_tr_type(u32 mflags, u32 *trans_type)
+{
+	*trans_type = 0;
+	/* Set type of window */
+	if ((mflags == 0) || (mflags & RIO_NWRITE_R))
+		*trans_type = TTYPE(NRD_NWR_R); /* nread and nwrite_r */
+	else if (mflags & RIO_MAINT_WRITE)
+		*trans_type = TTYPE(MRD_MWR); /* mread and mwrite */
+	else if (mflags & RIO_NWRITE)
+		*trans_type = TTYPE(NRD_NWR); /* nread and nwrite */
+	else if (mflags & RIO_SWRITE)
+		*trans_type = TTYPE(NRD_SWR); /* nread and swrite */
+	else
+		return -EINVAL;
+	return 0;
+}
+
+#if 0
+/**
+ * axxia_rio_map_outb_mem -- Mapping outbound memory.
+ * @mport:  RapidIO master port
+ * @win:    Outbound ATMU window for this access
+ *          - obtained by calling axxia_rio_req_outb_region.
+ * @destid: Destination ID of transaction
+ * @addr:   RapidIO space start address.
+ * @res:    Mapping region phys and virt start address
+ *
+ * Return: 0 -- Success.
+ *
+ */
+static int axxia_rio_map_outb_mem(struct rio_mport *mport, u32 win,
+				u16 destid, u32 addr, u32 mflags,
+				struct rio_map_addr *res)
+{
+	struct rio_priv *priv = mport->priv;
+	struct atmu_outb *aoutb;
+	u32 rbar = 0, ctrl, trans_type;
+	unsigned long flags;
+	int rc;
+
+	rc = __flags2rio_tr_type(mflags, &trans_type);
+	if (rc < 0) {
+		dev_err(priv->dev, "(%s) invalid transaction flags %x\n",
+			__func__, mflags);
+		return rc;
+	}
+
+	spin_lock_irqsave(&rio_io_lock, flags);
+
+	aoutb = &priv->outb_atmu[win];
+	if (unlikely(win >= RIO_OUTB_ATMU_WINDOWS ||
+		     !(aoutb->in_use && aoutb->riores))) {
+		spin_unlock_irqrestore(&rio_io_lock, flags);
+		dev_err(priv->dev, "(%s) faulty ATMU window (%d, %d, %8.8x)\n",
+			__func__, win, aoutb->in_use, (u32) aoutb->riores);
+		return -EINVAL;
+	}
+	__rio_local_read_config_32(mport, RAB_APIO_AMAP_CTRL(win), &ctrl);
+
+	if (TTYPE_VAL(ctrl) != trans_type) {
+		ctrl &= ~TTYPE(0x3);
+		ctrl |= trans_type;
+	}
+	if (TTYPE_VAL(ctrl)) { /* RIO address set - Not maintenance */
+		rbar |= RIO_ADDR_BASE(addr);
+		__rio_local_write_config_32(mport,
+					    RAB_APIO_AMAP_RBAR(win),
+					    rbar);
+	}
+	ctrl &= ~TARGID(0xffff); /* Target id clear */
+	ctrl |= TARGID(destid); /* Target id set */
+	ctrl |= ENABLE_AMBA; /* Enable window */
+	__rio_local_write_config_32(mport, RAB_APIO_AMAP_CTRL(win), ctrl);
+
+	res->phys = aoutb->riores->start + RIO_ADDR_OFFSET(addr);
+	res->va = aoutb->win + RIO_ADDR_OFFSET(addr);
+
+	spin_unlock_irqrestore(&rio_io_lock, flags);
+
+	return 0;
+}
+#endif
+/**
+ * axxia_rio_req_outb_region -- Request outbound region in the
+ *                            RapidIO bus address space.
+ * @mport:  RapidIO master port
+ * @size:   The mapping region size.
+ * @name:   Resource name
+ * @flags:  Flags for mapping. 0 for using default flags.
+ * @id:     Allocated outbound ATMU window id
+ *
+ * Return: 0 -- Success.
+ *
+ * This function will reserve a memory region that may
+ * be used to create mappings from local iomem to rio space.
+ */
+static int axxia_rio_req_outb_region(struct rio_mport *mport,
+				   resource_size_t size,
+				   const char *name,
+				   u32 mflags, u32 *id)
+{
+	u32 win, reg, win_size = 0, trans_type = 0, wabar = 0;
+	struct rio_priv *priv = mport->priv;
+	struct atmu_outb *aoutb;
+	int rc = 0;
+	void __iomem *iowin;
+	struct resource *riores;
+	unsigned long flags;
+
+	if (!(is_power_of_2(size))) {
+		dev_err(priv->dev, "(%s) size is not power of 2 (%llu)\n",
+			__func__, size);
+		return -EFAULT;
+	}
+	rc = __flags2rio_tr_type(mflags, &trans_type);
+	if (rc < 0) {
+		dev_err(priv->dev, "(%s) invalid transaction flags %x\n",
+			__func__, mflags);
+		return rc;
+	}
+
+	spin_lock_irqsave(&rio_io_lock, flags);
+
+	for (win = 0; win < RIO_OUTB_ATMU_WINDOWS; win++) {
+		if (!(priv->outb_atmu[win].in_use))
+			break;
+	}
+
+	if (win == RIO_OUTB_ATMU_WINDOWS) {
+		spin_unlock_irqrestore(&rio_io_lock, flags);
+		dev_err(priv->dev,
+			"(%s) out of ATMU windows to use\n",
+			__func__);
+		return -ENOMEM;
+	}
+	aoutb = &priv->outb_atmu[win];
+	aoutb->in_use = 1;
+	aoutb->win = NULL;
+	aoutb->riores = NULL;
+
+	riores = kzalloc(sizeof(struct resource), GFP_ATOMIC);
+	if (!riores) {
+		aoutb->in_use = 0;
+		spin_unlock_irqrestore(&rio_io_lock, flags);
+		dev_err(priv->dev,
+			"(%s) failed to allocate resources\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	spin_unlock_irqrestore(&rio_io_lock, flags);
+
+	riores->name = name;
+	riores->flags = IORESOURCE_MEM;
+	if (allocate_resource(&mport->iores, riores,
+			      size, mport->iores.start,
+			      mport->iores.end, 0x400, NULL, NULL)) {
+		/* Align on 1kB boundry */
+		rc = -ENOMEM;
+		goto out_err_resource;
+	}
+
+	iowin = ioremap(riores->start, size);
+	if (!iowin) {
+		rc = -ENOMEM;
+		goto out_err_ioremap;
+	}
+
+	/* Set base address for window on PIO side */
+	if (!axxia_rio_is_x9())
+		wabar = AXI_BASE_HIGH(riores->start);
+	wabar |= AXI_BASE(riores->start);
+	__rio_local_write_config_32(mport, RAB_APIO_AMAP_ABAR(win), wabar);
+
+	if (0 == WIN_SIZE((u32)size))
+		size = 0x400u; /* make sure window size is at least 1KiB big*/
+
+
+	/* Set size of window */
+	win_size |= WIN_SIZE((u32)size);
+	__rio_local_write_config_32(mport, RAB_APIO_AMAP_SIZE(win), win_size);
+	__rio_local_read_config_32(mport, RAB_APIO_AMAP_CTRL(win), &reg);
+	reg &= ~TTYPE(0x3);
+	reg |= trans_type;
+	__rio_local_write_config_32(mport, RAB_APIO_AMAP_CTRL(win), reg);
+
+	spin_lock_irqsave(&rio_io_lock, flags);
+	aoutb->win = iowin;
+	aoutb->riores = riores;
+	spin_unlock_irqrestore(&rio_io_lock, flags);
+
+	*id = win;
+	return 0;
+
+out_err_ioremap:
+	dev_err(priv->dev, "(%s) ioremap IO-mem failed\n",
+		__func__);
+	if (release_resource(riores))
+		dev_err(priv->dev, "(%s) clean-up resource failed\n", __func__);
+out_err_resource:
+	dev_err(priv->dev, "(%s) alloc IO-mem for %s failed\n",
+		__func__, name);
+	kfree(riores);
+
+	spin_lock_irqsave(&rio_io_lock, flags);
+	aoutb->in_use = 0;
+	spin_unlock_irqrestore(&rio_io_lock, flags);
+	return rc;
+}
+
+/**
+ * axxia_rio_release_outb_region -- Unreserve outbound memory region.
+ * @mport: RapidIO master port
+ * @win:   Allocated outbound ATMU window id
+ *
+ * Disables and frees the memory resource of an outbound memory region
+ */
+static void axxia_rio_release_outb_region(struct rio_mport *mport,
+					u32 win)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 ctrl;
+	unsigned long flags;
+
+	if (unlikely(win >= RIO_OUTB_ATMU_WINDOWS))
+		return;
+
+	spin_lock_irqsave(&rio_io_lock, flags);
+
+	__rio_local_read_config_32(mport, RAB_APIO_AMAP_CTRL(win), &ctrl);
+	if (likely(priv->outb_atmu[win].in_use)) {
+		struct atmu_outb *aoutb = &priv->outb_atmu[win];
+		struct resource *riores = aoutb->riores;
+		void __iomem *iowin = aoutb->win;
+
+		__rio_local_write_config_32(mport,
+					    RAB_APIO_AMAP_CTRL(win),
+					    ctrl & ~ENABLE_AMBA);
+		aoutb->riores = NULL;
+		aoutb->win = NULL;
+
+		spin_unlock_irqrestore(&rio_io_lock, flags);
+
+		iounmap(iowin);
+		if (release_resource(riores))
+			dev_err(priv->dev, "(%s) clean-up resource failed\n",
+				__func__);
+		kfree(riores);
+
+		spin_lock_irqsave(&rio_io_lock, flags);
+		aoutb->in_use = 0;
+	}
+
+	spin_unlock_irqrestore(&rio_io_lock, flags);
+}
+
+
+/**
+ * axxia_rio_set_mport_disc_mode - Set master port discovery/eumeration mode
+ *
+ * @mport: Master port
+ *
+ */
+void axxia_rio_set_mport_disc_mode(struct rio_mport *mport)
+{
+	u32 result;
+
+	if (mport->host_deviceid >= 0) {
+		__rio_local_write_config_32(mport, RIO_GCCSR,
+					    RIO_PORT_GEN_HOST |
+					    RIO_PORT_GEN_MASTER |
+					    RIO_PORT_GEN_DISCOVERED);
+	} else {
+		__rio_local_write_config_32(mport, RIO_GCCSR,
+					    RIO_PORT_GEN_MASTER);
+		__rio_local_write_config_32(mport, RIO_DID_CSR,
+					    RIO_SET_DID(mport->sys_size,
+					    RIO_ANY_DESTID(mport->sys_size)));
+	}
+
+#ifdef EXTRA1DEBUG
+	__rio_local_read_config_32(mport, RIO_GCCSR, &result);
+	EXT1P("rio[%d]: RIO_GEN_CTL_CSR set to 0x%X for main port\n",
+		mport->id, result);
+#endif
+
+	__rio_local_write_config_32(mport, RIO_COMPONENT_TAG_CSR, 0xFFFF);
+
+#ifdef	NOT_SUPPORTED
+	/* Use the reset default setting of (0x00000000).  RAB does not
+	 * support "Accept All=1".  We would need another ID value to use
+	 * if we wanted to set the PTPN and PTE=1. */
+
+	/* Set to receive any dist ID for serial RapidIO controller. */
+	if (mport->phy_type == RIO_PHY_SERIAL)
+		__rio_local_write_config_32(mport,
+					    EPC_PNPTAACR(mport->port_ndx),
+					    0x00000000);
+#endif
+
+#ifdef CONFIG_RAPIDIO_HOTPLUG
+	if (CONFIG_RAPIDIO_SECOND_DEST_ID != DESTID_INVALID) {
+		struct rio_priv *priv = mport->priv;
+
+		result = EPC_PNADIDCSR_ADE;
+		result |= EPC_PNADIDCSR_ADID_SMALL(
+				CONFIG_RAPIDIO_SECOND_DEST_ID);
+		__rio_local_write_config_32(mport,
+					    EPC_PNADIDCSR(priv->port_ndx),
+					    result);
+		dev_dbg(priv->dev, "Port%dAltDevIdmCSR set to 0x%X\n",
+			priv->port_ndx, CONFIG_RAPIDIO_SECOND_DEST_ID);
+	}
+#else
+	/* Set the Alternate Destination ID to prevent "Machine Checks"
+	** and aid the device enumeration / discovery process later on.
+	*/
+	{
+		struct rio_priv *priv = mport->priv;
+
+		result = EPC_PNADIDCSR_ADE;
+		if (mport->sys_size)
+			result |= EPC_PNADIDCSR_ADID_LARGE(~0);
+		else
+			result |= EPC_PNADIDCSR_ADID_SMALL(~0);
+		__rio_local_write_config_32(mport,
+					    EPC_PNADIDCSR(priv->port_ndx),
+					    result);
+		dev_dbg(priv->dev, "Port%dAltDevIdmCSR set to 0x%X\n",
+			priv->port_ndx, result);
+	}
+#endif
+}
+
+/**
+ * axxia_init_port_data - HW Setup of master port
+ *
+ * @mport: Master port
+ *
+ */
+static void axxia_init_port_data(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 ccsr, data;
+
+#if defined(CONFIG_AXXIA_RIO_16B_ID)
+	__rio_local_read_config_32(mport, RAB_SRDS_CTRL0, &data);
+	__rio_local_write_config_32(mport, RAB_SRDS_CTRL0,
+				    data | RAB_SRDS_CTRL0_16B_ID);
+#endif
+	/* Probe the master port phy type */
+	__rio_local_read_config_32(mport, RIO_CCSR(priv->port_ndx), &ccsr);
+	mport->phys_rmap = (ccsr & 1) ? RIO_PHY_SERIAL : RIO_PHY_PARALLEL;
+	dev_dbg(priv->dev, "RapidIO PHY type: %s\n",
+		 (mport->phys_rmap == RIO_PHY_PARALLEL) ? "parallel" :
+		 ((mport->phys_rmap == RIO_PHY_SERIAL) ? "serial" :
+		  "unknown"));
+
+	__rio_local_read_config_32(mport, RIO_PEF_CAR, &data);
+	mport->sys_size = (data & RIO_PEF_CTLS) >> 4;
+	dev_dbg(priv->dev, "RapidIO Common Transport System size: %d\n",
+		mport->sys_size ? 65536 : 256);
+
+	__rio_local_read_config_32(mport, RIO_DEV_ID_CAR, &priv->devid);
+	__rio_local_read_config_32(mport, RIO_DEV_INFO_CAR, &priv->devrev);
+	{
+		int i;
+		static const u32 legacyids[] = {
+			AXXIA_DEVID_ACP34XX,
+			AXXIA_DEVID_ACP25XX,
+		};
+		__rio_local_read_config_32(mport, RAB_CTRL, &data);
+		priv->intern_msg_desc = (data & 0x00001000) ? 1 : 0;
+		for (i = 0; i < 2; i++) {
+			if (priv->devid == legacyids[i])
+				priv->intern_msg_desc = 1;
+		}
+		EXT1P("rio[%d]: RapidIO internal descriptors: %d (%x %x)\n",
+			mport->id, priv->intern_msg_desc, priv->devid, data);
+	}
+}
+
+/**
+ * axxia_rio_info - Log Port HW setup
+ *
+ * @dev: RIO device
+ * @ccsr: Port N Error and Command Status register
+ *
+ */
+static void axxia_rio_info(struct device *dev, u32 ccsr)
+{
+	const char *str;
+
+	if (ccsr & 1) {
+		/* Serial phy */
+		switch (ccsr >> 30) {
+		case 0:
+			str = "1";
+			break;
+		case 1:
+			str = "4";
+			break;
+		default:
+			str = "Unknown";
+			break;
+		}
+		dev_dbg(dev, "Hardware port width: %s\n", str);
+
+		switch ((ccsr >> 27) & 7) {
+		case 0:
+			str = "Single-lane 0";
+			break;
+		case 1:
+			str = "Single-lane 2";
+			break;
+		case 2:
+			str = "Four-lane";
+			break;
+		default:
+			str = "Unknown";
+			break;
+		}
+		dev_dbg(dev, "Training connection status: %s\n", str);
+	} else {
+		/* Parallel phy */
+		if (!(ccsr & 0x80000000))
+			dev_dbg(dev, "Output port operating in 8-bit mode\n");
+		if (!(ccsr & 0x08000000))
+			dev_dbg(dev, "Input port operating in 8-bit mode\n");
+	}
+}
+
+/**
+ * rio_start_port - Check the master port
+ * @mport: Master port to be checked
+ *
+ * Check the type of the master port and if it is not ready try to
+ * restart the connection.
+ */
+static int rio_start_port(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 ccsr, escsr;
+
+	/* Probe the master port phy type */
+	__rio_local_read_config_32(mport, RIO_CCSR(priv->port_ndx), &ccsr);
+	__rio_local_read_config_32(mport, RIO_ESCSR(priv->port_ndx), &escsr);
+
+	if (escsr & RIO_ESCSR_PU) {
+
+		dev_err(priv->dev,
+			"Port is not ready/restart ordered. Try to restart connection...\n");
+
+		/* Disable ports */
+		ccsr |= RIO_CCSR_PD;
+		__rio_local_write_config_32(mport, RIO_CCSR(priv->port_ndx),
+						ccsr);
+		switch (mport->phys_rmap) {
+		case RIO_PHY_SERIAL:
+			/* Set 1x lane */
+			ccsr &= ~RIO_CCSR_PWO;
+			ccsr |= RIO_CCSR_FORCE_LANE0;
+			__rio_local_write_config_32(mport,
+						RIO_CCSR(priv->port_ndx), ccsr);
+			break;
+		case RIO_PHY_PARALLEL:
+			break;
+		}
+
+		/* Enable ports */
+		ccsr &= ~RIO_CCSR_PD;
+		__rio_local_write_config_32(mport, RIO_CCSR(priv->port_ndx),
+					ccsr);
+		msleep(100);
+		__rio_local_read_config_32(mport, RIO_ESCSR(priv->port_ndx),
+					&escsr);
+		axxia_rio_info(priv->dev, ccsr);
+		if (escsr & RIO_ESCSR_PU) {
+			dev_dbg(priv->dev, "Port restart failed.\n");
+			return -ENOLINK;
+		} else {
+			dev_dbg(priv->dev, "Port restart success!\n");
+			return 0;
+		}
+	}
+
+#ifdef EXTRA1DEBUG
+	{
+		u32 hdlcsr, rabver;
+
+		__rio_local_read_config_32(mport, RIO_HOST_DID_LOCK_CSR,
+					&hdlcsr);
+		__rio_local_read_config_32(mport, RAB_VER, &rabver);
+
+		pr_info("rio[%d]: AR[%d] DIDCAR[%x]=%08x RAB_VER[%x]=%08x\n",
+			mport->id,
+			__LINE__,
+			RIO_DEV_ID_CAR, priv->devid,
+			RAB_VER, rabver);
+		pr_info("rio[%d]: AR[%d] [%x]=%08x [%x]=%08x [%x]=%08x\n",
+			mport->id,
+			__LINE__,
+			RIO_CCSR(priv->port_ndx), ccsr,
+			RIO_ESCSR(priv->port_ndx), escsr,
+			RIO_HOST_DID_LOCK_CSR, hdlcsr);
+	}
+#endif /* defined(EXTRA1DEBUG) */
+
+	dev_dbg(priv->dev, "Port is Ready\n");
+	return 0;
+}
+
+/**
+ * rio_rab_ctrl_setup - Bridge Control HW setup
+ *
+ * @mport: Master port
+ *
+ * Response Prio = request prio +1. 2) No AXI byte swap
+ * Internal (RIO Mem) DME desc access
+ * Priority based MSG arbitration
+ * RIO & AMBA PIO Enable
+ */
+static void rio_rab_ctrl_setup(struct rio_mport *mport)
+{
+	u32 rab_ctrl;
+
+	__rio_local_write_config_32(mport, AXI_TIMEOUT, 0x00001000);
+
+#ifdef USE_DME_TIMEOUT
+	__rio_local_write_config_32(mport, DME_TIMEOUT, 0xC0080000);
+#else
+	__rio_local_write_config_32(mport, DME_TIMEOUT, 0x00000000);
+#endif
+
+	rab_ctrl = 0;
+	rab_ctrl |= (1 << 12);
+	rab_ctrl |= (2 << 6);
+	rab_ctrl |= 3;
+	__rio_local_write_config_32(mport, RAB_CTRL, rab_ctrl);
+}
+
+/**
+ * rio_rab_pio_enable - Setup Peripheral Bus bridge,
+ *                      RapidIO <-> Peripheral bus, HW.
+ *
+ * @mport: Master port
+ *
+ * Enable AXI PIO + outbound nwrite/nread/maintenance
+ * Enable RIO PIO (enable rx maint port-write packet)
+ */
+static void rio_rab_pio_enable(struct rio_mport *mport)
+{
+	__rio_local_write_config_32(mport, RAB_APIO_CTRL,
+				    RAB_APIO_MAINT_MAP_EN |
+				    RAB_APIO_MEM_MAP_EN |
+				    RAB_APIO_PIO_EN);
+	__rio_local_write_config_32(mport, RAB_RPIO_CTRL, RAB_RPIO_PIO_EN);
+}
+
+/**
+ * rio_static_win_init -- Setup static ATMU window for maintenance
+ *                        access and enable doorbells
+ *
+ * @mport: Master port
+ *
+ * Returns:
+ * 0        - At success
+ * -EFAULT  - Requested outbound region can not be claimed
+ */
+int axxia_rio_static_win_init(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 ctrl;
+
+	/* Enable inbound doorbell */
+	__rio_local_write_config_32(mport, RAB_IB_DB_CSR, IB_DB_CSR_EN);
+
+	/* Configure maintenance transaction window */
+	if ((axxia_rio_req_outb_region(mport, CONFIG_RIO_MAINT_WIN_SIZE,
+				     "rio_maint_win", RIO_MAINT_WRITE,
+				     &priv->maint_win_id)) < 0)
+		goto err;
+
+	__rio_local_read_config_32(mport,
+				   RAB_APIO_AMAP_CTRL(priv->maint_win_id),
+				   &ctrl);
+	/* Enable window */
+	ctrl |= ENABLE_AMBA;
+	__rio_local_write_config_32(mport,
+				    RAB_APIO_AMAP_CTRL(priv->maint_win_id),
+				    ctrl);
+
+	return 0;
+err:
+	return -EFAULT;
+}
+
+/**
+ * axxia_rio_static_win_release -- Release static ATMU maintenance window
+ *                                 Disable doorbells
+ *
+ * @mport: Master port
+ *
+ */
+void axxia_rio_static_win_release(struct rio_mport *mport)
+{
+	struct rio_priv *priv = mport->priv;
+	u32 ibdb;
+
+	/* Disable inbound doorbell */
+	__rio_local_read_config_32(mport, RAB_IB_DB_CSR, &ibdb);
+	ibdb &= ~IB_DB_CSR_EN;
+	__rio_local_write_config_32(mport, RAB_IB_DB_CSR, ibdb);
+
+	/* Release maintenance transaction window */
+	axxia_rio_release_outb_region(mport, priv->maint_win_id);
+}
+
+/**
+ * rio_parse_dtb - Parse RapidIO platform entry
+ *
+ * @dev: RIO platform device
+ * @ndx: Which instance are we?
+ * @law_start: Local Access Window start address from DTB
+ * @law_size: Local Access Window size from DTB
+ * @regs: RapidIO registers from DTB
+ * @ob_num_dmes: Number of outbound DMEs available
+ * @outb_dmes: RapidIO outbound DMEs array available;
+ *                [0] for MSeg, [1] for SSeg
+ * @ib_num_dmes: Number of inbound DMEs available
+ * @inb_dmes: RapidIO inbound DMEs array available; 2 elements
+ * @irq: RapidIO IRQ mapping from DTB
+ *
+ * Returns:
+ * -EFAULT          At failure
+ * 0                Success
+ */
+static int rio_parse_dtb(
+	struct platform_device *dev,
+	int *ndx,
+	u64 *law_start,
+	u64 *law_size,
+	struct resource *regs,
+	int *ob_num_dmes,
+	int *outb_dmes,
+	int *ib_num_dmes,
+	int *inb_dmes,
+	int *irq,
+	struct event_regs *linkdown_reset)
+{
+	const u32 *dt_range, *cell;
+	int rlen, rc;
+	int paw, aw, sw;
+
+	if (!dev->dev.of_node) {
+		dev_err(&dev->dev, "Device OF-Node is NULL");
+		return -EFAULT;
+	}
+
+	if (!of_device_is_available(dev->dev.of_node)) {
+		EXT1P("rio[%d]: AR[%d] status = not available\n", 99, __LINE__);
+		return -ENODEV;
+	} else {
+		EXT1P("rio[%d]: AR[%d] status = available\n", 99, __LINE__);
+	}
+
+	if (of_property_read_u32(dev->dev.of_node, "index", &rlen))
+		return -ENODEV;
+	*ndx = rlen;
+
+	rc = of_address_to_resource(dev->dev.of_node, 0, regs);
+	if (rc) {
+		dev_err(&dev->dev, "Can't get %s property 'reg'\n",
+			dev->dev.of_node->full_name);
+		return -EFAULT;
+	}
+	dev_dbg(&dev->dev,
+		"Of-device full name %s\n",
+		 dev->dev.of_node->full_name);
+	dev_dbg(&dev->dev, "Regs: %pR\n", regs);
+
+	dt_range = of_get_property(dev->dev.of_node, "ranges", &rlen);
+
+	if (!dt_range) {
+		dev_err(&dev->dev, "Can't get %s property 'ranges'\n",
+			dev->dev.of_node->full_name);
+		return -EFAULT;
+	}
+
+	/* Get node address wide */
+	cell = of_get_property(dev->dev.of_node, "#address-cells", NULL);
+	if (cell)
+		aw = *cell;
+	else
+		aw = of_n_addr_cells(dev->dev.of_node);
+	if (aw > 3)			/* Anomaly in A15 build+parse */
+		aw = 2;
+	/* Get node size wide */
+	cell = of_get_property(dev->dev.of_node, "#size-cells", NULL);
+	if (cell)
+		sw = *cell;
+	else
+		sw = of_n_size_cells(dev->dev.of_node);
+	if (sw > 3)			/* Anomaly in A15 build+parse */
+		sw = 2;
+	/* Get parent address wide wide */
+	paw = of_n_addr_cells(dev->dev.of_node);
+
+	*law_start = of_read_number(dt_range + aw, paw);
+	*law_size = of_read_number(dt_range + aw + paw, sw);
+
+	dev_dbg(&dev->dev, "LAW: [mem 0x%016llx -- 0x%016llx]\n",
+		*law_start, *law_start + *law_size - 1);
+
+	outb_dmes[0] = outb_dmes[1] = 0;
+	cell = of_get_property(dev->dev.of_node, "outb-dmes", &rlen);
+	if (!cell) {
+		ob_num_dmes[0] = 2;
+		ob_num_dmes[1] = 1;
+		outb_dmes[0] = 0x00000003;
+		outb_dmes[1] = 0x00000001;
+	} else {
+		if (rlen < (4 * sizeof(int))) {
+			dev_err(&dev->dev, "Invalid %s property 'outb-dmes'\n",
+				dev->dev.of_node->full_name);
+			return -EFAULT;
+		}
+		ob_num_dmes[0] = of_read_number(cell, 1);
+		outb_dmes[0] = of_read_number(cell + 1, 1);
+		ob_num_dmes[1] = of_read_number(cell + 2, 1);
+		outb_dmes[1] = of_read_number(cell + 3, 1);
+		if (((ob_num_dmes[0])+(ob_num_dmes[1])) > DME_MAX_OB_ENGINES) {
+			dev_err(&dev->dev, "Invalid %s property 'outb-dmes'\n",
+				dev->dev.of_node->full_name);
+			return -EFAULT;
+		}
+	}
+	dev_dbg(&dev->dev, "outb-dmes: MSeg[%d]=%08x SSeg[%d]=%08x\n",
+		ob_num_dmes[0], outb_dmes[0], ob_num_dmes[1], outb_dmes[1]);
+
+	inb_dmes[0] = inb_dmes[1] = 0;
+	cell = of_get_property(dev->dev.of_node, "inb-dmes", &rlen);
+	if (!cell) {
+		ib_num_dmes[0] = DME_MAX_IB_ENGINES;
+		ib_num_dmes[1] = 0;
+		inb_dmes[0] = 0xffffffff;
+		inb_dmes[1] = 0x00000000;
+	} else {
+		if (rlen < (4 * sizeof(int))) {
+			dev_err(&dev->dev, "Invalid %s property 'inb-dmes'\n",
+				dev->dev.of_node->full_name);
+			return -EFAULT;
+		}
+		ib_num_dmes[0] = of_read_number(cell, 1);
+		inb_dmes[0] = of_read_number(cell + 1, 1);
+		ib_num_dmes[1] = of_read_number(cell + 2, 1);
+		inb_dmes[1] = of_read_number(cell + 3, 1);
+		if (((ib_num_dmes[0])+(ib_num_dmes[1])) > DME_MAX_IB_ENGINES) {
+			dev_err(&dev->dev, "Invalid %s property 'inb-dmes'\n",
+				dev->dev.of_node->full_name);
+			return -EFAULT;
+		}
+	}
+	dev_dbg(&dev->dev, "inb-dmes: MSeg[%d]=%08x SSeg[%d]=%08x\n",
+		ib_num_dmes[0], inb_dmes[0], ib_num_dmes[1], inb_dmes[1]);
+
+	*irq = irq_of_parse_and_map(dev->dev.of_node, 0);
+	dev_dbg(&dev->dev, "irq: %d\n", *irq);
+
+	memset(linkdown_reset, 0, sizeof(struct event_regs));
+	dt_range = of_get_property(dev->dev.of_node, "linkdown-reset", &rlen);
+	if (dt_range) {
+		if (rlen < (6 * sizeof(int))) {
+			dev_err(&dev->dev,
+				"Invalid %s property 'linkdown-reset'\n",
+				dev->dev.of_node->full_name);
+			return -EFAULT;
+		} else {
+			linkdown_reset->phy_reset_start =
+				of_read_number(dt_range + aw, paw);
+			linkdown_reset->phy_reset_size =
+				of_read_number(dt_range + aw + paw, sw);
+			linkdown_reset->reg_addr =
+				of_read_number(dt_range + 0, 1);
+			linkdown_reset->reg_mask =
+				of_read_number(dt_range + 1, 1);
+			linkdown_reset->in_use = 1;
+			EXT1P("rio: LDR st=%llx sz=%llx RA=%x MSK=%x iu=%d\n",
+				linkdown_reset->phy_reset_start,
+				linkdown_reset->phy_reset_size,
+				linkdown_reset->reg_addr,
+				linkdown_reset->reg_mask,
+				linkdown_reset->in_use);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * rio_ops_setup - Alloc and initiate the RIO ops struct
+ *
+ * Returns:
+ * ERR_PTR(-ENOMEM)      At failure
+ * struct rio_ops *ptr   to initialized ops data at Success
+ */
+static struct rio_ops *rio_ops_setup(void)
+{
+	struct rio_ops *ops = kzalloc(sizeof(*ops), GFP_KERNEL);
+
+	if (!ops)
+		return ERR_PTR(-ENOMEM);
+
+	ops->lcread = axxia_rio_local_config_read;
+	ops->lcwrite = axxia_rio_local_config_write;
+	ops->cread = axxia_rio_config_read;
+	ops->cwrite = axxia_rio_config_write;
+	ops->dsend = axxia_rio_doorbell_send;
+	ops->pwenable = axxia_rio_pw_enable;
+	ops->open_outb_mbox = axxia_open_outb_mbox;
+	ops->open_inb_mbox = axxia_open_inb_mbox;
+	ops->close_outb_mbox = axxia_close_outb_mbox;
+	ops->close_inb_mbox = axxia_close_inb_mbox;
+	ops->add_outb_message = axxia_ml_add_outb_message;
+	ops->add_inb_buffer = axxia_add_inb_buffer;
+	ops->get_inb_message = axxia_ml_get_inb_message;
+#ifdef CONFIG_RAPIDIO_HOTPLUG
+	ops->hotswap = axxia_rio_hotswap;
+	ops->port_notify_cb = axxia_rio_port_notify_cb;
+	ops->port_op_state = axxia_rio_port_op_state;
+#endif
+	return ops;
+}
+
+/**
+ * rio_mport_dtb_setup - Alloc and initialize the master port data
+ *                       structure with data retrieved from DTB
+ *
+ * @dev: RIO platform device
+ * @law_start: Local Access Window start address from DTB
+ * @law_size: Local Access Window size from DTB
+ * @ops: RIO ops data structure
+ *
+ * Init mport data structure
+ * Request RIO iomem resources
+ * Register doorbell and mbox resources with generic RIO driver
+
+ * Returns:
+ * -ENOMEM                 At failure
+ * struct rio_mport *ptr   to initialized mport data at Success
+ */
+static int rio_mport_dtb_setup(struct platform_device *dev,
+			       int port_ndx,
+			       u64 law_start,
+			       u64 law_size,
+			       struct rio_ops *ops,
+			       struct rio_mport **ptr)
+{
+	int rc = 0;
+	struct rio_mport *mport = kzalloc(sizeof(*mport), GFP_KERNEL);
+
+	(*ptr) = NULL;
+
+	if (!mport)
+		return -ENOMEM;
+
+	mport->index = port_ndx;
+
+	INIT_LIST_HEAD(&mport->dbells);
+	mport->iores.start = law_start;
+	mport->iores.end = law_start + law_size - 1;
+	mport->iores.flags = IORESOURCE_MEM;
+	mport->iores.name = "rio_io_win";
+	mport->iores.parent = NULL;
+	mport->iores.child = NULL;
+	mport->iores.sibling = NULL;
+
+	if (request_resource(&iomem_resource, &mport->iores) < 0) {
+		dev_err(&dev->dev,
+			"RIO: Error requesting master port region 0x%016llx-0x%016llx\n",
+			(u64)mport->iores.start, (u64)mport->iores.end);
+		kfree(mport);
+		return -ENOMEM;
+	}
+	rio_init_dbell_res(&mport->riores[RIO_DOORBELL_RESOURCE], 0, 0xffff);
+	rio_init_mbox_res(&mport->riores[RIO_INB_MBOX_RESOURCE], 0,
+			RIO_MAX_RX_MBOX);
+	rio_init_mbox_res(&mport->riores[RIO_OUTB_MBOX_RESOURCE], 0,
+			RIO_MAX_TX_MBOX);
+	sprintf(mport->name, "RIO%d mport", mport->id);
+
+	mport->ops = ops;
+	mport->phys_efptr = 0x100; /* define maybe */
+
+	(*ptr) = mport;
+	return rc;
+}
+
+/**
+ * rio_priv_dtb_setup - Alloc and initialize the master port private data
+ *                      structure with data retrieved from DTB
+ *
+ * @dev: RIO platform device
+ * @regs: RapidIO registers from DTB
+ * @mport: master port
+ * @ndx: Instance Id of the controller description
+ * @port_ndx: Port Id of the controller
+ * @numObNumDmes: override num outbound DMEs available
+ * @outb_dmes: RapidIO outbound DMEs array available; [0] for MSeg, [1] for SSeg
+ * @numIbNumDmes: override num inbound DMEs available
+ * @inb_dmes: RapidIO inbound DMEs array available; 2 elements
+ * @irq: IRQ number
+ *
+ * Init master port private data structure
+ *
+ * Returns:
+ * ERR_PTR(-ENOMEM)        At failure
+ * struct rio_priv *ptr    to initialized priv data at Success
+ */
+
+static struct rio_priv *rio_priv_dtb_setup(
+	struct platform_device *dev,
+	struct resource *regs,
+	struct rio_mport *mport,
+	int ndx,
+	int port_ndx,
+	int *num_outb_dmes,
+	int *outb_dmes,
+	int *num_inb_dmes,
+	int *inb_dmes,
+	int irq,
+	struct event_regs *linkdown_reset)
+{
+	struct rio_priv *priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	int i, rc;
+
+	if (!priv)
+		return ERR_PTR(-ENOMEM);
+
+	/* master port driver handle (bidirectional reference supported) */
+	mport->priv = priv;
+	priv->cookie = AXXIA_RIO_COOKIE;
+	priv->mport = mport;
+	priv->ndx = ndx;
+	priv->port_ndx = port_ndx;
+	mutex_init(&priv->api_lock);
+	/* Max descriptors */
+	priv->desc_max_entries = RIO_MSG_MAX_ENTRIES;
+
+	if (priv->intern_msg_desc) {
+		/* Support for alloc_message_engine() */
+		struct resource *dres = &priv->acpres[ACP_HW_DESC_RESOURCE];
+
+		memset(dres, 0, sizeof(struct resource));
+			/* 'virtual' mapping of descriptors */
+		dres->start = 0;
+		dres->end = priv->desc_max_entries - 1;
+		dres->flags = ACP_RESOURCE_HW_DESC;
+		dres->name = "rio_desc_win";
+		dres->parent = NULL;
+		dres->child = NULL;
+		dres->sibling = NULL;
+
+		if (request_resource(&iomem_resource, dres) < 0) {
+			dev_err(&dev->dev,
+				"RIO: Error requesting descriptor region 0x%016llx-0x%016llx\n",
+				(u64)dres->start, (u64)dres->end);
+			rc = -ENOMEM;
+			goto err_fixed;
+		}
+	}
+
+	/* Defined DMEs */
+	if (outb_dmes) {
+		priv->num_outb_dmes[0] = num_outb_dmes[0];
+		priv->num_outb_dmes[1] = num_outb_dmes[1];
+		priv->outb_dmes[0] = outb_dmes[0];
+		priv->outb_dmes[1] = outb_dmes[1];
+	}
+	if (inb_dmes) {
+		priv->num_inb_dmes[0] = num_inb_dmes[0];
+		priv->num_inb_dmes[1] = num_inb_dmes[1];
+		priv->inb_dmes[0] = inb_dmes[0];
+		priv->inb_dmes[1] = inb_dmes[1];
+	}
+
+	/* Interrupt handling */
+	priv->irq_line = irq;
+	axxia_rio_port_irq_init(mport);
+
+	/* Dev ptr for debug printouts */
+	priv->dev = &dev->dev;
+
+	/* Init ATMU data structures */
+	for (i = 0; i < RIO_OUTB_ATMU_WINDOWS; i++) {
+		priv->outb_atmu[i].in_use = 0;
+		priv->outb_atmu[i].riores = NULL;
+	}
+
+	/* Setup local access */
+	priv->regs_win_fixed = ioremap(regs->start, SRIO_CONF_SPACE_SIZE_FIXED);
+	if (!priv->regs_win_fixed) {
+		rc = -ENOMEM;
+		goto err_fixed;
+	}
+	priv->regs_win_paged = ioremap(regs->start + SRIO_CONF_SPACE_SIZE_FIXED,
+					SRIO_CONF_SPACE_SIZE_PAGED);
+	if (!priv->regs_win_paged) {
+		rc = -ENOMEM;
+		goto err_paged;
+	}
+	if (linkdown_reset && linkdown_reset->in_use) {
+		memcpy(&priv->linkdown_reset, linkdown_reset,
+			sizeof(struct event_regs));
+		priv->linkdown_reset.win =
+			ioremap(linkdown_reset->phy_reset_start,
+				linkdown_reset->phy_reset_size);
+		if (!priv->linkdown_reset.win) {
+			rc = -ENOMEM;
+			goto err_linkdown;
+		}
+		EXT1P("rio[%d]: LDR win=%p\n", mport->id,
+			priv->linkdown_reset.win);
+	}
+
+	return priv;
+
+err_linkdown:
+	if (priv->linkdown_reset.win)
+		iounmap(priv->linkdown_reset.win);
+	iounmap(priv->regs_win_paged);
+err_paged:
+	iounmap(priv->regs_win_fixed);
+err_fixed:
+	kfree(priv);
+	return ERR_PTR(rc);
+}
+
+/**
+ * axxia_rio_start_port - Start master port
+ *
+ * @mport: Master port
+ *
+ * Check the type of the master port and if it is not ready try to
+ * restart the connection.
+ * In hotplug mode we don't really care about connection state
+ * elsewise we give up if the port is not up.
+ *
+ * Setup HW for basic memap access support:
+ * enable AXI bridge, maintenance window, doorbells, etc..
+ */
+int axxia_rio_start_port(struct rio_mport *mport)
+{
+	int rc;
+	struct rio_priv *priv = mport->priv;
+
+	/*
+	 * Set port line request ack timout 1.5 - 3 s
+	 * Set port response timeout 1.5 - 3 s
+	 */
+	if ((priv->devid == AXXIA_DEVID_AXM55XX) &&
+		(priv->devrev == AXXIA_DEVREV_AXM55XX_V1_0)) {
+		__rio_local_write_config_32(mport, RIO_PLTOCCSR,
+					((RIO_LINK_TIMEOUT_VAL * 100) << 8));
+		__rio_local_write_config_32(mport, RIO_PRTOCCSR,
+				((RIO_RESPONSE_TIMEOUT_VAL * 100) << 8));
+	} else {
+		__rio_local_write_config_32(mport, RIO_PLTOCCSR,
+					((RIO_LINK_TIMEOUT_VAL) << 8));
+		__rio_local_write_config_32(mport, RIO_PRTOCCSR,
+					((RIO_RESPONSE_TIMEOUT_VAL) << 8));
+	}
+
+	/* Check port training state:
+	 */
+
+	rc = rio_start_port(mport);
+	if (rc < 0) {
+#ifdef CONFIG_RAPIDIO_HOTPLUG
+		dev_warn(priv->dev, "Link is down - will continue anyway\n");
+#else
+		dev_err(priv->dev, "Link is down - SRIO Init failed\n");
+		return rc;
+#endif
+	}
+
+	/* Enable memory mapped access
+	 */
+	rio_rab_ctrl_setup(mport);
+
+	rio_rab_pio_enable(mport);
+
+	/* Miscellaneous
+	 */
+	__rio_local_write_config_32(mport, RAB_OB_DME_TID_MASK,
+				    OB_DME_TID_MASK);
+
+
+	/* Setup maintenance window
+	 * Enable doorbells
+	 */
+	rc = axxia_rio_static_win_init(mport);
+
+	return rc;
+}
+
+/**
+ * axxia_rio_setup - Setup AXXIA RapidIO interface
+ * @dev: platform_device pointer
+ *
+ * Initializes AXXIA RapidIO hardware interface, configures
+ * master port with system-specific info, and registers the
+ * master port with the RapidIO subsystem.
+ *
+ * Init sequence is divided into two phases
+ * 1:
+ *    All one-time initialization: e.g. driver software structures,
+ *    work queues, tasklets, sync resources etc. are allocated and
+ *    and initialized. At this stage No HW access is possible, to avoid
+ *    race conditions, all HW accesses to local configuration space must
+ *    be handled through the generic RIO driver access functions and
+ *    these may not be used prior to init of master port data structure.
+ * 2:
+ *    Setup and try to start RapidIO master port controller HW
+ *    If the driver is built with hotplug support, the setup routine
+ *    does not require that the link is up to complete successfully,
+ *    the port may be restarted at any point later in time. Without
+ *    hotplug the setup function will fail if link tranining sequence
+ *    doesn't complete successfully.
+ *
+ * Returns:
+ * <0           Failure
+ * 0            Success
+ */
+static int axxia_rio_setup(struct platform_device *dev)
+{
+	int rc = -EFAULT;
+	struct rio_ops *ops;
+	struct rio_mport *mport;
+	struct rio_priv *priv;
+	struct resource regs;
+	u64 law_start = 0, law_size = 0;
+	int ndx = 0, irq = 0, port_ndx = 0;
+	int numObDmes[2] = { 0, }, outb_dmes[2] = { 0, };
+	int numIbDmes[2] = { 0, }, inb_dmes[2] = { 0, };
+	struct event_regs linkdown_reset = { 0, };
+#ifdef CONFIG_AXXIA_RIO_DS
+	struct axxia_rio_ds_dtb_info ds_dtb_info; /* data_streaming */
+#endif
+
+	/* Get address boundaries, etc. from DTB */
+	if (rio_parse_dtb(dev, &ndx, &law_start, &law_size, &regs,
+			  &numObDmes[0], &outb_dmes[0],
+			  &numIbDmes[0], &inb_dmes[0],
+			  &irq, &linkdown_reset))
+		return -EFAULT;
+
+	rc = axxia_rapidio_board_init(dev, ndx, &port_ndx);
+	if (rc != 0)
+		return rc;
+#ifdef CONFIG_AXXIA_RIO_DS
+	rc = axxia_parse_dtb_ds(dev, &ds_dtb_info);
+	if (rc != 0)
+		return rc;
+#endif
+	/* Alloc and Initialize driver SW data structure */
+	ops = rio_ops_setup();
+	if (IS_ERR(ops)) {
+		rc = PTR_ERR(ops);
+		goto err_ops;
+	}
+	rc = rio_mport_dtb_setup(dev, port_ndx, law_start, law_size,
+				 ops, &mport);
+	if (rc != 0)
+		goto err_port;
+	priv = rio_priv_dtb_setup(dev, &regs, mport, ndx, port_ndx,
+				  &numObDmes[0], &outb_dmes[0],
+				  &numIbDmes[0], &inb_dmes[0],
+				  irq, &linkdown_reset);
+	if (IS_ERR(priv)) {
+		rc = PTR_ERR(priv);
+		goto err_priv;
+	}
+
+	/* !!! HW access to local config space starts here !!! */
+
+	/* Get and set master port data
+	 */
+	axxia_init_port_data(mport);
+
+	/* Start port and enable basic memmap access
+	 */
+	rc = axxia_rio_start_port(mport);
+	if (rc < 0)
+		goto err_maint;
+
+	/* Hookup IRQ handlers
+	 */
+	if (axxia_rio_port_irq_enable(mport))
+		goto err_irq;
+
+	/* Hookup SYSFS support
+	 */
+	dev_set_drvdata(&dev->dev, mport);
+#ifdef CONFIG_AXXIA_RIO_STAT
+	axxia_rio_init_sysfs(dev);
+#endif
+#ifdef CONFIG_AXXIA_RIO_DS
+	/* Data_streaming */
+	if (ds_dtb_info.ds_enabled == 1) {
+		rc = axxia_cfg_ds(mport, &ds_dtb_info);
+		if (rc)
+			goto err_mport;
+		axxia_rio_ds_port_irq_init(mport);
+	}
+#endif
+	/* Register port with core driver
+	 */
+	if (rio_register_mport(mport)) {
+		dev_err(&dev->dev, "register mport failed\n");
+		goto err_mport;
+	}
+
+	/* Correct the host device id if needed
+	 */
+	{
+		u16 id = rio_local_get_device_id(mport);
+
+		EXT1P("rio[%d]: AR[%d] devid=%d hdid=%d\n",
+			mport->id, __LINE__,
+			mport->host_deviceid, rio_local_get_device_id(mport));
+		if (mport->host_deviceid < 0) {
+			if ((id != 0xFF) && (mport->sys_size == 0))
+				mport->host_deviceid = id;
+			else if ((id != 0xFFFF) && (mport->sys_size != 0))
+				mport->host_deviceid = id;
+		}
+	}
+
+	/* Any changes needed based on device id / revision ?
+	*/
+	switch (priv->devid) {
+	case AXXIA_DEVID_ACP25XX:
+		priv->outb_dmes[1] = 0x00000000;
+		break;
+	case AXXIA_DEVID_AXM55XX:
+		priv->outb_dmes[1] = 0x00000000;
+		switch (priv->devrev) {
+		case AXXIA_DEVREV_AXM55XX_V1_0:
+			pr_info(
+			"RIO: AXM 55xx sRIO Dev Rev 0 (Base DID Lock issue)\n");
+			break;
+		case AXXIA_DEVREV_AXM55XX_V1_1:
+			pr_info(
+			"RIO: AXM 55xx sRIO Device Rev 1 Controller %d\n",
+								priv->ndx);
+			break;
+		case AXXIA_DEVREV_AXM55XX_V1_2:
+			pr_info(
+			"RIO: AXM 55xx sRIO Device Rev 2 Controller %d\n",
+								priv->ndx);
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	/* And set the discovery mode for this port before we go
+	 */
+	axxia_rio_set_mport_disc_mode(mport);
+
+	EXT1P("rio[%p:%d]: priv=%p\n", mport, mport->id,
+		priv);
+	return 0;
+
+err_mport:
+	axxia_rio_port_irq_disable(mport);
+#ifdef CONFIG_AXXIA_RIO_STAT
+	axxia_rio_release_sysfs(dev);
+#endif
+err_irq:
+	axxia_rio_static_win_release(mport);
+err_maint:
+	if (priv->linkdown_reset.win)
+		iounmap(priv->linkdown_reset.win);
+	iounmap(priv->regs_win_fixed);
+	iounmap(priv->regs_win_paged);
+	kfree(priv);
+err_priv:
+	kfree(mport);
+err_port:
+	kfree(ops);
+err_ops:
+	irq_dispose_mapping(irq);
+	return rc;
+}
+
+/*
+  The probe function for RapidIO peer-to-peer network.
+*/
+static int axxia_of_rio_rpn_probe(struct platform_device *dev)
+{
+	EXT1P(KERN_INFO "Setting up RapidIO peer-to-peer network %s\n",
+	       dev->dev.of_node->full_name);
+
+	return axxia_rio_setup(dev);
+};
+
+static const struct of_device_id axxia_of_rio_rpn_ids[] = {
+	{ .compatible = "axxia, rapidio-delta", },
+	{ .compatible = "axxia,axxia-rapidio", },
+	{ .compatible = "acp, rapidio-delta", },
+	{},
+};
+
+static struct platform_driver axxia_of_rio_rpn_driver = {
+	.driver = {
+		.name = "axxia-of-rio",
+		.owner = THIS_MODULE,
+		.of_match_table = axxia_of_rio_rpn_ids,
+	},
+	.probe = axxia_of_rio_rpn_probe,
+};
+
+static __init int axxia_of_rio_rpn_init(void)
+{
+	EXT1P(KERN_INFO "Register RapidIO platform driver\n");
+	return platform_driver_register(&axxia_of_rio_rpn_driver);
+}
+
+subsys_initcall_sync(axxia_of_rio_rpn_init);
diff --git a/drivers/rapidio/devices/axxia/axxia-rio.h b/drivers/rapidio/devices/axxia/axxia-rio.h
new file mode 100644
index 0000000..ae24ef8
--- /dev/null
+++ b/drivers/rapidio/devices/axxia/axxia-rio.h
@@ -0,0 +1,620 @@
+/*
+ *   This program is free software;  you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.
+ */
+
+#ifndef _AXXIA_RIO_H_
+#define _AXXIA_RIO_H_
+
+#include <linux/device.h>
+#include <linux/of_platform.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/io.h>
+#include "axxia-rio-irq.h"
+/* Constants, Macros, etc. */
+
+#define AXXIA_RIO_SYSMEM_BARRIER()	\
+	/* Memory Barrier */	\
+	smp_mb()
+
+#define IN_SRIO8(a, v, ec)      do {            \
+	v = ioread8(a); ec = 0;  \
+	} while (0)
+#define IN_SRIO16(a, v, ec)     do {            \
+	v = ioread16be(a); ec = 0;  \
+	} while (0)
+#define IN_SRIO32(a, v, ec)     do {            \
+	v = ioread32be(a); ec = 0;  \
+	} while (0)
+
+#define OUT_SRIO8(a, v)         iowrite8(v, a)
+#define OUT_SRIO16(a, v)        iowrite16be(v, a)
+#define OUT_SRIO32(a, v)        iowrite32be(v, a)
+
+/*****************************************/
+/* *********** Byte Swapping *********** */
+/*****************************************/
+#define BSWAP(x)  __builtin_bswap32(x)     /* Use gcc built-in byte swap code */
+
+#define DESTID_INVALID (u16)(0xff)
+#define RIO_SET_DID(size, x)	(size ? (x & 0xffff) : ((x & 0x000000ff) << 16))
+
+/*******************************/
+/* *********** ACP *********** */
+/*******************************/
+#define ACP_MAX_RESOURCES       16
+#define ACP_HW_DESC_RESOURCE    0
+#define ACP_RESOURCE_HW_DESC	0x00000100
+
+
+/*****************************************/
+/* *********** ACP/AXXIA REG *********** */
+/*****************************************/
+#define SRIO_CONF_SPACE_SIZE          0x1000
+#define SRIO_CONF_SPACE_SIZE_FIXED    0x0800
+#define SRIO_CONF_SPACE_SIZE_PAGED    0x0800
+
+#define SRIO_SPACE_SIZE         0x40000      /* Total size GRIO + RAB Spaces */
+
+/* End point models & revisions */
+#define AXXIA_DEVID_ACP34XX		0x5101000a
+#define AXXIA_DEVID_ACP25XX		0x5108000a
+#define AXXIA_DEVID_AXM55XX		0x5120000a
+#define AXXIA_DEVID_AXM35XX		0x5102000a
+#define   AXXIA_DEVREV_AXM55XX_V1_0	  0x00000000
+#define   AXXIA_DEVREV_AXM55XX_V1_1	  0x80000000
+#define   AXXIA_DEVREV_AXM55XX_V1_2	  0x40000000
+
+/* End Point Controller Specific Registers (0x1_0000-0x1_FFFC) */
+#define EPC_REG_BASE            0x10000
+#define EPC_PNADIDCSR(x)        (EPC_REG_BASE + (0x100+((x)*0x80)))
+#define  EPC_PNADIDCSR_ADE	(1 << 31)
+#define  EPC_PNADIDCSR_ADID_SMALL(id)	((u32)((id) & 0x00ff) << 16)
+#define  EPC_PNADIDCSR_ADID_LARGE(id)	((u32)((id) & 0xffff) <<  0)
+#define EPC_PNPTAACR(x)	        (EPC_REG_BASE + (0x120+((x)*0x80)))
+#define EPC_IECSR(x)            (EPC_REG_BASE + (0x130+((x)*0x80)))
+#define  EPC_IECSR_RETE         0x80000000   /*WOCL*/
+
+/* Peripheral Bus Bridge Specific Registers (0x2_0000-0x3_FFFC) */
+#define RAB_REG_BASE            0x20000
+#define RAB_VER                 (RAB_REG_BASE + 0x00)
+#define RAB_APB_CSR_BASE        0x30
+#define RAB_APB_CSR             (RAB_REG_BASE + RAB_APB_CSR_BASE)
+#define RAB_CTRL                (RAB_REG_BASE + 0x08)
+#define RAB_STAT                (RAB_REG_BASE + 0x0c)
+#define AXI_TIMEOUT             (RAB_REG_BASE + 0x10)
+#define DME_TIMEOUT             (RAB_REG_BASE + 0x14)
+
+#define RAB_PIO_RESET           (RAB_REG_BASE + 0x18)
+#define  RAB_PIO_RESET_RPIO     0x00000100
+#define  RAB_PIO_RESET_APIO     0x00000001
+
+#define RAB_COOP_LOCK           (RAB_REG_BASE + 0x1C)
+#define RAB_IB_PW_CSR           (RAB_REG_BASE + 0x28)
+#define RAB_IB_PW_EN                    0x1UL
+#define RAB_IB_PW_NUMWORDS(csr) (((csr) & 0x001f0000) >> 16)
+
+#define RAB_IB_PW_DATA          (RAB_REG_BASE + 0x2C)
+
+#define RAB_RPIO_CTRL           (RAB_REG_BASE + 0x80)
+#define RAB_RPIO_PIO_EN                 0x1
+#define RAB_RPIO_RELAX_ORDER            0x2
+
+#define RAB_RPIO_STAT           (RAB_REG_BASE + 0x84)
+#define  RAB_RPIO_STAT_RSP_ERR  0x00000004
+#define  RAB_RPIO_STAT_ADDR_MAP 0x00000002
+#define  RAB_RPIO_STAT_DISABLED 0x00000001
+
+/* AXI PIO (outbound)*/
+#define RAB_APIO_CTRL           (RAB_REG_BASE + 0x180)
+#define RAB_APIO_CPP_EN                 0x8
+#define RAB_APIO_MAINT_MAP_EN           0x4
+#define RAB_APIO_MEM_MAP_EN             0x2
+#define RAB_APIO_PIO_EN                 0x1
+
+/* SRIO PHY Control */
+#define RAB_SRDS_CTRL0          (RAB_REG_BASE + 0x980)
+#define  RAB_SRDS_CTRL0_16B_ID   0x00000004
+
+#define RAB_SRDS_CTRL1          (RAB_REG_BASE + 0x984)
+#define  RAB_SRDS_CTRL1_RST      0x00000001
+
+#define RAB_SRDS_CTRL2          (RAB_REG_BASE + 0x988)
+#define RAB_SRDS_STAT0          (RAB_REG_BASE + 0x990)
+#define RAB_SRDS_STAT1          (RAB_REG_BASE + 0x994)
+#define  RAB_SRDS_STAT1_LINKDOWN_INT    0x80000000
+
+/* AW SMON control */
+#define RAB_SMON_CTRL0          (RAB_REG_BASE + 0x9A0)
+#define  RAB_SMON_CTRL0_INT_TM_OF       0x00200000
+#define  RAB_SMON_CTRL0_INT_CNT_OF      0x00020000
+#define  RAB_SMON_CTRL0_ENB             0x00000001
+
+
+/* register contains transaction type, target id */
+#define RAB_APIO_AMAP_CTRL(n)   (RAB_REG_BASE + (0x200 + (n * 0x10)))
+#define MRD_MWR                         (0x0)
+#define NRD_NWR                         (0x1)
+#define NRD_NWR_R                       (0x2)
+#define NRD_SWR                         (0x3)
+#define TTYPE(type)                     (((u32)(type) & 0x3) << 1)
+#define TTYPE_VAL(reg)                  (((reg) >> 1) & 0x3)
+#define TARGID(tid)                     (((u32)(tid) & 0xffff) << 16)
+#define ENABLE_AMBA                     (0x1UL)
+
+/* register contains the AXI window size */
+#define RAB_APIO_AMAP_SIZE(n)   (RAB_REG_BASE + (0x204 + (n * 0x10)))
+#define WIN_SIZE(size)                  (size & 0xfffffc00)
+
+/* register for AXI based address for window */
+#define RAB_APIO_AMAP_ABAR(n)		(RAB_REG_BASE + (0x208 + (n * 0x10)))
+#define AXI_BASE_HIGH(addr)             ((u32)(((u64)(addr) & 0x3f00000000ULL) \
+					 >> 32) << 22)
+#define AXI_BASE(addr)                  (((u32)(addr) & 0xfffffc00) >> 10)
+
+/* Register for RIO base address */
+#define RAB_APIO_AMAP_RBAR(n)   (RAB_REG_BASE + (0x20C + (n * 0x10)))
+#define RIO_ADDR_BASE(taddr)            (((u32)(taddr) & 0xfffffc00) >> 10)
+#define RIO_ADDR_OFFSET(taddr)          ((u32)(taddr) & 0x3ff)
+#define HOP_COUNT(hop_cnt)              (((u32)(hop_cnt) & 0xff) << 14)
+
+
+/* Other */
+#define RAB_LFC_BLOCKED         (RAB_REG_BASE + 0x964)
+#define RAB_SRDS_CTRL0          (RAB_REG_BASE + 0x980)
+
+
+/* Interrupt registers */
+#define RAB_INTR_ENAB_GNRL      (RAB_REG_BASE + 0x40)
+/* General int enable  bits */
+#define RAB_INT_OB_DB_EN        (1 << 31)
+#define EXT_INT_OB_DB_EN        (0xff << 16)
+#define MISC_INT_EN             (1 << 6)
+#define OB_DME_INT_EN           (1 << 5)
+#define IB_DME_INT_EN           (1 << 4)
+#define RPIO_INT_EN             (1 << 1)
+#define APIO_INT_EN             (1)
+
+#define RAB_INTR_ENAB_GNRL_SET  (MISC_INT_EN | RPIO_INT_EN | \
+			 APIO_INT_EN/* | OB_DME_INT_EN | IB_DME_INT_EN*/)
+
+#define RAB_INTR_STAT_GNRL      (RAB_REG_BASE + 0x60)
+/* General int status bits */
+#define RAB_INTERNAL_STAT       (1 << 31)
+#define EXT_INT_STATUS          (0xff << 16)
+#define MISC_INT                (1 << 6)
+#define OB_DME_INT              (1 << 5)
+#define IB_DME_INT              (1 << 4)
+#define RPIO_INT                (1 << 1)
+#define APIO_INT                (1)
+
+#define RAB_INTR_ENAB_APIO      (RAB_REG_BASE + 0x44)
+#define RAB_INTR_ENAB_RPIO      (RAB_REG_BASE + 0x48)
+#define RAB_INTR_ENAB_IDME      (RAB_REG_BASE + 0x54)
+#define RAB_INTR_ENAB_ODME      (RAB_REG_BASE + 0x58)
+#define RAB_INTR_ENAB_MISC      (RAB_REG_BASE + 0x5c)
+
+#define RAB_INTR_STAT_APIO      (RAB_REG_BASE + 0x64)
+
+/* Data_streaming */
+#define RAB_INTR_ENAB_ODSE      (RAB_REG_BASE + 0x2a0c)
+#define RAB_INTR_ENAB_IBDS      (RAB_REG_BASE + 0x2a04)
+#define RAB_INTR_STAT_ODSE      (RAB_REG_BASE + 0x2a18)
+#define RAB_INTR_STAT_IBSE_VSID_M (RAB_REG_BASE + 0x2a10)
+
+/* PIO int status bits */
+#define APIO_TRANS_FAILED       (1 << 8)
+#define APIO_TRANS_COMPLETE     (1)
+#define RAB_INTR_ENAB_APIO_SET  (APIO_TRANS_FAILED)
+
+#define RAB_APIO_STAT           (RAB_REG_BASE + 0x184)
+#define  RAB_APIO_STAT_RQ_ERR     0x00000040
+#define  RAB_APIO_STAT_TO_ERR     0x00000020
+#define  RAB_APIO_STAT_RSP_ERR    0x00000010
+#define  RAB_APIO_STAT_MAP_ERR    0x00000008
+#define  RAB_APIO_STAT_MAINT_DIS  0x00000004
+#define  RAB_APIO_STAT_MEM_DIS    0x00000002
+#define  RAB_APIO_STAT_DISABLED   0x00000001
+
+#define RAB_INTR_STAT_RPIO      (RAB_REG_BASE + 0x68)
+#define RPIO_TRANS_FAILED       (1 << 8)
+#define RPIO_TRANS_COMPLETE     (1)
+#define RAB_INTR_ENAB_RPIO_SET  (RPIO_TRANS_FAILED | RPIO_TRANS_COMPLETE)
+
+#define RAB_INTR_STAT_MISC      (RAB_REG_BASE + 0x7c)
+/* Misc int status bits */
+#define UNEXP_MSG_LOG           (0xff << 24)
+#define USR_INT                 (1 << 16)
+#define AMST_INT                (1 << 11)
+#define ASLV_INT                (1 << 10)
+#define LFC_INT                 (1 << 9)
+#define CO_LOCK_INT             (1 << 8)
+#define LINK_REQ_INT            (1 << 7)
+#define LL_TL_INT               (1 << 6)
+#define GRIO_INT                (1 << 5)
+#define PORT_WRITE_INT          (1 << 4)
+#define UNSP_RIO_REQ_INT        (1 << 3)
+#define UNEXP_MSG_INT           (1 << 2)
+#define OB_DB_DONE_INT          (1 << 1)
+#define IB_DB_RCV_INT           (1)
+
+/* AMBA (AXI/AHB) Master/Slave */
+#define RAB_ASLV_STAT_CMD       (RAB_REG_BASE + 0x1c0)
+#define  RAB_ASLV_STAT_CMD_USUP 0x00000001
+
+#define RAB_ASLV_STAT_ADDR      (RAB_REG_BASE + 0x1c4)
+#define RAB_AMAST_STAT          (RAB_REG_BASE + 0x1e0)
+#define  RAB_AMAST_STAT_WRTO    0x00000020
+#define  RAB_AMAST_STAT_RDTO    0x00000010
+#define  RAB_AMAST_STAT_WRDE    0x00000008
+#define  RAB_AMAST_STAT_WRSE    0x00000004
+#define  RAB_AMAST_STAT_RDDE    0x00000002
+#define  RAB_AMAST_STAT_RDSE    0x00000001
+
+
+#define MISC_FATAL (AMST_INT | ASLV_INT)
+
+#if defined(CONFIG_AXXIA_RIO_STAT)
+
+#define MISC_ERROR_INDICATION (MISC_FATAL | GRIO_INT | LL_TL_INT | \
+			       UNEXP_MSG_LOG | UNSP_RIO_REQ_INT | \
+			       UNEXP_MSG_INT)
+#define MISC_DB_EVENT (OB_DB_DONE_INT | IB_DB_RCV_INT)
+
+#else
+
+#define MISC_ERROR_INDICATION MISC_FATAL
+#define MISC_DB_EVENT IB_DB_RCV_INT
+
+#endif
+
+#define RAB_INTR_ENAB_MISC_SET  (MISC_ERROR_INDICATION | MISC_DB_EVENT)
+
+/* Inbound/Outbound int bits */
+#define RAB_INTR_ENAB_IDME_SET  (~(0UL))
+#define RAB_INTR_ENAB_ODME_SET  (0x7)
+
+
+/************************************/
+/* *********** MESSAGES *********** */
+/************************************/
+/* Outbound Doorbell */
+#define RAB_OB_DB_CSR(n)        (RAB_REG_BASE + (0x400 + (n * 0x8)))
+#define OB_DB_DEST_ID(id)               (((u32)(id) & 0xffff) << 16)
+#define OB_DB_CRF                       (1 << 6)
+#define OB_DB_PRIO(prio)                (((u32)(prio) & 0x3) << 4)
+#define OB_DB_STATUS(reg)               (((u32)(reg) & 0xe) >> 1)
+#define OB_DB_SEND                      (1)
+
+#define OB_DB_STATUS_DONE       (0)
+#define OB_DB_STATUS_RETRY      (1)
+#define OB_DB_STATUS_ERROR      (2)
+#define OB_DB_STATUS_TIMEOUT    (3)
+#define OB_DB_STATUS_PENDING    (4)
+
+#define MAX_OB_DB               (8)
+
+#define RAB_OB_DB_INFO(n)       (RAB_REG_BASE + (0x404 + (n * 0x8)))
+#define OB_DB_INFO(info)                ((u32)(info) & 0xffff)
+
+/* Inbound Doorbell */
+#define RAB_IB_DB_CSR           (RAB_REG_BASE + 0x480)
+#define IB_DB_CSR_NUM_MSG(csr)          (((u32)(csr) & 0x3f0000) >> 16)
+#define IB_DB_CSR_EN                    (1)
+
+#define RAB_IB_DB_INFO          (RAB_REG_BASE + 0x484)
+
+#define DBELL_SID(info)		(((u32)(info) & 0xffff0000) >> 16)
+#define DBELL_INF(info)		((u32)(info) & 0xffff)
+
+/* Messages */
+#define RAB_OB_DME_CTRL(e)      (RAB_REG_BASE + (0x500 + (0x10 * (e))))
+#define RAB_OB_DME_DESC_ADDR(e) (RAB_REG_BASE + (0x504 + (0x10 * (e))))
+#define RAB_OB_DME_STAT(e)      (RAB_REG_BASE + (0x508 + (0x10 * (e))))
+#define RAB_OB_DME_DESC(e)      (RAB_REG_BASE + (0x50C + (0x10 * (e))))
+#define RAB_OB_DME_TID_MASK     (RAB_REG_BASE + 0x5f0)
+
+#define RAB_INTR_STAT_ODME      (RAB_REG_BASE + 0x78)
+#define OB_DME_STAT_SLEEPING             (1 << 9)
+#define OB_DME_STAT_TRANS_PEND           (1 << 8)
+#define OB_DME_STAT_RESP_TO              (1 << 7)
+#define OB_DME_STAT_RESP_ERR             (1 << 6)
+#define OB_DME_STAT_DATA_TRANS_ERR       (1 << 5)
+#define OB_DME_STAT_DESC_UPD_ERR         (1 << 4)
+#define OB_DME_STAT_DESC_ERR             (1 << 3)
+#define OB_DME_STAT_DESC_FETCH_ERR       (1 << 2)
+#define OB_DME_STAT_DESC_XFER_CPLT       (1 << 1)
+#define OB_DME_STAT_DESC_CHAIN_XFER_CPLT (1)
+
+#define OB_DME_STAT_ERROR_MASK           0x000000FC
+#define OB_DME_TID_MASK                  0xFFFFFFFF
+
+#define RAB_IB_DME_CTRL(e)      (RAB_REG_BASE + (0x600 + (0x10 * (e))))
+#define   RAB_IB_DME_CTRL_XMBOX(m)           (((m) & 0x3c) << 6)
+#define   RAB_IB_DME_CTRL_MBOX(m)            (((m) & 0x03) << 6)
+#define   RAB_IB_DME_CTRL_LETTER(l)          (((l) & 0x03) << 4)
+#define RAB_IB_DME_DESC_ADDR(e) (RAB_REG_BASE + (0x604 + (0x10 * (e))))
+#define RAB_IB_DME_STAT(e)      (RAB_REG_BASE + (0x608 + (0x10 * (e))))
+#define RAB_IB_DME_DESC(e)      (RAB_REG_BASE + (0x60C + (0x10 * (e))))
+
+#define RAB_INTR_STAT_IDME      (RAB_REG_BASE + 0x74)
+#define IB_DME_STAT_SLEEPING             (1 << 9)
+#define IB_DME_STAT_TRANS_PEND           (1 << 8)
+#define IB_DME_STAT_MSG_TIMEOUT          (1 << 7)
+#define IB_DME_STAT_MSG_ERR              (1 << 6)
+#define IB_DME_STAT_DATA_TRANS_ERR       (1 << 5)
+#define IB_DME_STAT_DESC_UPDATE_ERR      (1 << 4)
+#define IB_DME_STAT_DESC_ERR             (1 << 3)
+#define IB_DME_STAT_DESC_FETCH_ERR       (1 << 2)
+#define IB_DME_STAT_DESC_XFER_CPLT       (1 << 1)
+#define IB_DME_STAT_DESC_CHAIN_XFER_CPLT (1)
+
+#define IB_DME_STAT_ERROR_MASK		0x000000FC
+
+#define DME_WAKEUP			(2)
+#define DME_ENABLE			(1)
+
+/* DME Message Descriptor Table */
+#define DESC_TABLE_W0_NDX(d)         (0x10 * (d))
+#define DESC_TABLE_W0_RAB_BASE(d)    (RAB_REG_BASE+0x10000+DESC_TABLE_W0_NDX(d))
+#define DESC_TABLE_W0(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0x0)
+#define DESC_TABLE_W1(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0x4)
+#define DESC_TABLE_W2(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0x8)
+#define DESC_TABLE_W3(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0xC)
+
+#define DESC_TABLE_W0_MEM_BASE(me, d)		\
+	(((u8 *)(me)->descriptors) + DESC_TABLE_W0_NDX(d))
+#define DESC_TABLE_W0_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0x0)
+#define DESC_TABLE_W1_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0x4)
+#define DESC_TABLE_W2_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0x8)
+#define DESC_TABLE_W3_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0xC)
+
+#define DME_DESC_DW0_SRC_DST_ID(id)     ((id) << 16)
+#define DME_DESC_DW0_GET_DST_ID(dw0)    (((dw0) >> 16) & 0xffff)
+#define DME_DESC_DW0_RIO_ERR            (1 << 11)
+#define DME_DESC_DW0_AXI_ERR            (1 << 10)
+#define DME_DESC_DW0_TIMEOUT_ERR        (1 << 9)
+#define DME_DESC_DW0_DONE               (1 << 8)
+#define DME_DESC_DW0_SZ_MASK            (3 << 4)
+#define DME_DESC_DW0_EN_INT             (1 << 3)
+#define DME_DESC_DW0_END_OF_CHAIN       (1 << 2)
+#define DME_DESC_DW0_NXT_DESC_VALID     (1 << 1)
+#define DME_DESC_DW0_VALID              (1)
+
+#define DESC_STATE_TO_ERRNO(s)		(s & DME_DESC_DW0_TIMEOUT_ERR ? \
+					 -ETIME : (s & (DME_DESC_DW0_RIO_ERR | \
+					 DME_DESC_DW0_AXI_ERR) ? -EPROTO : 0))
+
+#define DME_DESC_DW0_READY_MASK         0x00000F00
+#define DME_DESC_DW0_ERROR_MASK         0x00000E00
+#define DME_DESC_DW0_SEG(d)             ((d & DME_DESC_DW0_SZ_MASK) >> 4)
+#define DME_DESC_DW0_SIZE(s)            (s == 0 ? 512 : \
+					 (s == 1 ? 1024 :	\
+					  (s == 2 ? 2048 : 4096)))
+
+#define DME_DESC_DW1_PRIO(flags)        ((flags & 0x3) << 30)
+#define DME_DESC_DW1_CRF(flags)         ((flags & 0x4) << 27)
+#define DME_DESC_DW1_SEG_SIZE_256       (0x06 << 18)
+#define DME_DESC_DW1_XMBOX(m)           (((m) & 0x3c) << 2)
+#define DME_DESC_DW1_MBOX(m)            (((m) & 0x03) << 2)
+#define DME_DESC_DW1_LETTER(l)          ((l) & 0x03)
+#define DME_DESC_DW1_MSGLEN(s)          ((((s + 7) & ~7) >> 3) << 8) /* Round
+					 up and shift to make double word */
+#define DME_DESC_DW1_MSGLEN_F(d)        (((d) >> 8) & 0x3ff)
+#define DME_DESC_DW1_MSGLEN_B(ml)       ((ml) << 3) /* double words to bytes */
+#define DME_DESC_DW1_GET_LETTER(dw1)    ((dw1) & 0x03)
+#define DME_DESC_DW1_GET_MBOX(dw1)      ((dw1 >> 2) & 0x03)
+
+/***********************************/
+/* *********** RIO REG *********** */
+/***********************************/
+#define RIO_PLTOCCSR            0x120
+#define RIO_PRTOCCSR            0x124
+#define RIO_GCCSR		0x13c
+
+#define RIO_LINK_TIMEOUT_VAL		(0x40)
+#define RIO_RESPONSE_TIMEOUT_VAL	(0xfa0)
+
+#define RIO_MNT_REQ_CSR(x)      (0x140+((x)*0x20))
+#define  RIO_MNT_REQ_MASK       0x00000007
+#define  RIO_MNT_REQ_RST        0x00000003
+#define  RIO_MNT_REQ_STAT       0x00000004
+
+#define RIO_MNT_RSP_CSR(x)      (0x144+((x)*0x20))
+#define  RIO_MNT_RSP_LS         0x0000001f
+#define  RIO_MNT_RSP_AS         0x000003e0
+#define  RIO_MNT_RSP_RV         0x80000000
+
+#define RIO_ACK_STS_CSR(x)      (0x148+((x)*0x20))
+#define  RIO_ACK_STS_IA         0x1f000000
+#define  RIO_ACK_STS_OUTA       0x00001f00
+#define  RIO_ACK_STS_OBA        0x0000001f
+
+#define RIO_ESCSR(x)            (0x158+((x)*0x20))
+#define  RIO_ESCSR_I2E		 0x40000000   /*RW*/
+#define  RIO_ESCSR_OPD           0x04000000   /*WOCL*/
+#define  RIO_ESCSR_OFE           0x02000000   /*WOCL*/
+#define  RIO_ESCSR_ODE           0x01000000   /*WOCL*/
+#define  RIO_ESCSR_ORE           0x00100000   /*WOCL*/
+#define  RIO_ESCSR_OR            0x00080000   /*R*/
+#define  RIO_ESCSR_ORS           0x00040000   /*R*/
+#define  RIO_ESCSR_OEE           0x00020000   /*WOCL*/
+#define  RIO_ESCSR_OES           0x00010000   /*R--*/
+#define  RIO_ESCSR_IRS           0x00000400   /*R*/
+#define  RIO_ESCSR_IEE           0x00000200   /*WOCL*/
+#define  RIO_ESCSR_IES           0x00000100   /*R--*/
+#define  RIO_ESCSR_PWP           0x00000010   /*R*/
+#define  RIO_ESCSR_PE            0x00000004   /*WOCL*/
+#define  RIO_ESCSR_PO            0x00000002   /*R*/
+#define  RIO_ESCSR_PU            0x00000001   /*R*/
+#define  RIO_EXCSR_WOLR          (RIO_ESCSR_OPD | RIO_ESCSR_OFE | \
+				  RIO_ESCSR_ODE | RIO_ESCSR_ORE | \
+				  RIO_ESCSR_OEE | RIO_ESCSR_IEE | RIO_ESCSR_PE)
+
+#define ESCSR_FATAL (RIO_ESCSR_OFE |		\
+		     RIO_ESCSR_IES |		\
+		     RIO_ESCSR_IRS |		\
+		     RIO_ESCSR_ORS |		\
+		     RIO_ESCSR_OES)
+
+#define RIO_CCSR(x)		(0x15c+((x)*0x20))
+#define  RIO_CCSR_PW             0xc0000000   /*R*/
+#define  RIO_CCSR_IPW            0x38000000   /*R*/
+#define  RIO_CCSR_PW_MASK        0x7
+#define  RIO_CCSR_PWO_SHIFT      24
+#define  RIO_CCSR_PWO            (RIO_CCSR_PW_MASK << RIO_CCSR_PWO_SHIFT)/*R/W*/
+#define  RIO_CCSR_FORCE_LANE0    (2 << RIO_CCSR_PWO_SHIFT)
+#define  RIO_CCSR_PD             0x00800000   /*R/W*/
+#define  RIO_CCSR_OPE            0x00400000   /*R/W*/
+#define  RIO_CCSR_IPE            0x00200000   /*R/W*/
+#define  RIO_CCSR_FCP            0x00040000   /*R/W*/
+#define  RIO_CCSR_EB             0x00020000   /*R*/
+#define  RIO_CCSR_SPF            0x00000008   /*R/W*/
+#define  RIO_CCSR_PL             0x00000002   /*R/W*/
+
+#define RIO_PNPTAACR		0x10120
+
+#define AXXIA_IBDME_INTERRUPT_MODE	0x1
+#define AXXIA_IBDME_TIMER_MODE		0x2
+/*************************************/
+/* *********** Constants *********** */
+/*************************************/
+
+#define RIO_OUTB_ATMU_WINDOWS   16
+
+#define AXXIA_RIO_COOKIE	0x41734230	/* aka 'AsR0' */
+
+/***********************************/
+/* *********** STRUCTS *********** */
+/***********************************/
+struct atmu_outb {
+	void __iomem *win;
+	struct rio_atmu_regs __iomem *atmu_regs;
+	struct resource *riores;
+	int in_use;
+};
+
+struct event_regs {
+	void __iomem *win;
+	u64 phy_reset_start;
+	u64 phy_reset_size;
+	u32 reg_addr;
+	u32 reg_mask;
+	int in_use;
+};
+
+struct rio_desc {
+	u32     d0;
+	u32     d1;
+	u32     d2;
+	u32     d3;
+};
+
+struct rio_priv {
+	u32     cookie;
+
+	struct mutex api_lock;
+
+
+	struct rio_mport *mport;
+	struct device *dev;
+	int  ndx;	/* From FDT description */
+	int  port_ndx;
+	u32  devid;     /* From GRIO register */
+	u32  devrev;    /* From GRIO register */
+
+	void __iomem *regs_win_fixed;
+	void __iomem *regs_win_paged;
+
+	int maint_win_id;
+	struct atmu_outb outb_atmu[RIO_OUTB_ATMU_WINDOWS];
+	struct resource acpres[ACP_MAX_RESOURCES];
+
+	int intern_msg_desc;
+	int desc_max_entries;
+
+	/* Chip-specific DME availability */
+	int num_outb_dmes[2];	/* [0]=MSeg, [1]=Sseg */
+	int outb_dmes_in_use[2];
+	int outb_dmes[2];	/* set of defined outbound DMEs:
+				 *   [0]=MSeg, [1]=SSeg */
+	int num_inb_dmes[2];	/* [0]=MSeg, [1]=Sseg */
+	int inb_dmes_in_use[2];
+	int inb_dmes[2];	/* set of defined inbound DMEs */
+
+	struct rio_tx_dme      ob_dme_shared[DME_MAX_OB_ENGINES];
+	struct rio_tx_mbox     *ob_mbox[RIO_MAX_TX_MBOX];
+	struct rio_rx_mbox     *ib_mbox[RIO_MAX_RX_MBOX];
+	struct rio_msg_dme     *ib_dme[DME_MAX_IB_ENGINES];
+	struct rio_pw_irq *pw_data;
+	unsigned int dme_mode;
+	/* Linkdown Reset; Trigger via SRDS STAT1 */
+	struct event_regs linkdown_reset;
+
+	/* Interrupts */
+	int irq_line;
+	struct rio_irq_handler misc_irq;
+	struct rio_irq_handler linkdown_irq; /* AXM55xx+SRDS STAT1+APB2SER */
+	struct rio_irq_handler apio_irq;
+	struct rio_irq_handler rpio_irq;
+	struct rio_irq_handler ob_dme_irq;
+	struct rio_irq_handler ib_dme_irq;
+
+#ifdef CONFIG_AXXIA_RIO_STAT
+	unsigned int rpio_compl_count;
+	unsigned int rpio_failed_count;
+	unsigned int apio_compl_count;
+	unsigned int apio_failed_count;
+	unsigned int rio_pw_count;
+	unsigned int rio_pw_msg_count;
+#endif
+#ifdef CONFIG_RAPIDIO_HOTPLUG
+	/* Fatal err */
+	spinlock_t port_lock;
+	void (*port_notify_cb)(struct rio_mport *mport);
+#endif
+#ifdef CONFIG_AXXIA_RIO_DS
+	/* Data_streaming */
+	struct axxia_rio_ds_priv     ds_priv_data;
+	struct axxia_rio_ds_cfg      ds_cfg_data;
+#endif
+} ____cacheline_internodealigned_in_smp;
+
+
+/**********************************************/
+/* *********** External Functions *********** */
+/**********************************************/
+
+extern int axxia_rio_start_port(struct rio_mport *mport);
+extern void axxia_rio_set_mport_disc_mode(struct rio_mport *mport);
+extern void axxia_rio_static_win_release(struct rio_mport *mport);
+extern int axxia_rio_static_win_init(struct rio_mport *mport);
+
+extern int axxia_local_config_read(struct rio_priv *priv,
+				   u32 offset, u32 *data);
+extern int axxia_local_config_write(struct rio_priv *priv,
+				    u32 offset, u32 data);
+
+#ifdef CONFIG_RAPIDIO_HOTPLUG
+
+extern int axxia_rio_hotswap(struct rio_mport *mport, u8 flags);
+
+#endif /* CONFIG_RAPIDIO_HOTPLUG */
+
+int axxia_rio_is_x9(void);
+int axxia_rapidio_board_init(struct platform_device *dev, int devnum,
+							int *portndx);
+#endif  /* _AXXIA_RIO_H_ */
diff --git a/drivers/rapidio/devices/lsi/Kconfig b/drivers/rapidio/devices/lsi/Kconfig
deleted file mode 100644
index c31e2a1..0000000
--- a/drivers/rapidio/devices/lsi/Kconfig
+++ /dev/null
@@ -1,47 +0,0 @@
-
-config AXXIA_RIO
-       bool "LSI Embedded SRIO Controller support"
-       depends on RAPIDIO && (ACP || ARCH_AXXIA)
-       default "n"
-       ---help---
-         Include support for RapidIO controllers for LSI Axxia
-         devices. The Axxia devices with arm (AXM55xx) and
-         powerpc (AXM35xx) cores has the serial RapidIO
-         controllers.
-
-config RIO_MAINT_WIN_SIZE
-       hex "RIO mport maintenance window size"
-       depends on RAPIDIO
-       default "0x400000"
-       ---help---
-         Size of RAPIDIO maintenance transaction window.
-         If RapidIO LAW size in your platform is less than 0x400000,
-         you may use this option to adjust the maintenance transaction
-         window accordingly.
-
-config AXXIA_RIO_STAT
-       bool "AXXIA RIO driver statistics"
-       depends on AXXIA_RIO
-       default n
-       ---help---
-         If you say Y here, you will be able to measure and view
-         state and interrupt counters for the Axxia RapidIO
-         controller via sysfs. It provides the counters for mbox
-         messages. May add a slght cpu overhead.
-
-config AXXIA_RIO_16B_ID
-       bool "RapidIO large common transport system"
-       depends on AXXIA_RIO && (ACP && PPC)
-       default n
-       ---help---
-         Say yes here to enable use of 16 bit transport ID otherwise
-         transport ID has 8 bits. This is required only for older
-         Axxia devices (34xx). And not required for the newer AXM55xx
-         devices.
-
-config OB_DME_ENTRY_SIZE
-       int "Number of Descriptors per DME for Static allocation"
-       depends on AXXIA_RIO
-       default "4096"
-       ---help---
-         Number of Descriptors to allocate for each outbound DME.
diff --git a/drivers/rapidio/devices/lsi/Makefile b/drivers/rapidio/devices/lsi/Makefile
deleted file mode 100644
index 82d0236..0000000
--- a/drivers/rapidio/devices/lsi/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-#
-# Makefile for the linux kernel.
-#
-obj-$(CONFIG_AXXIA_RIO)                 += axxia-rio.o axxia-rio-irq.o
-obj-$(CONFIG_AXXIA_RIO_STAT)           += axxia-rio-sysfs.o
diff --git a/drivers/rapidio/devices/lsi/axxia-rio-irq.c b/drivers/rapidio/devices/lsi/axxia-rio-irq.c
deleted file mode 100644
index 9ecd55d..0000000
--- a/drivers/rapidio/devices/lsi/axxia-rio-irq.c
+++ /dev/null
@@ -1,2842 +0,0 @@
-/*
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/of_platform.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/kfifo.h>
-#include <linux/dmapool.h>
-
-#include <linux/io.h>
-#include <linux/uaccess.h>
-#include <linux/hrtimer.h>
-#include <linux/ktime.h>
-
-#include "axxia-rio.h"
-#define OB_DME_ENTRIES		(CONFIG_OB_DME_ENTRY_SIZE)
-#define LINK_DOWN_TIMEOUT	(0x4BF0)
-
-unsigned int axxia_dme_tmr_mode[2] = { AXXIA_IBDME_INTERRUPT_MODE,
-					AXXIA_IBDME_TIMER_MODE };
-static int axxia_timer_mode_setup(char *str)
-{
-	unsigned int tmr_mode[3];
-	int i;
-	(void)get_options(str, ARRAY_SIZE(tmr_mode), tmr_mode);
-	for (i = 0; i < tmr_mode[0]; i++) {
-		if (tmr_mode[i+1] > 1)
-			pr_debug("Invalid parameter value for Timer Mode\n");
-		else
-			axxia_dme_tmr_mode[i] = AXXIA_IBDME_TIMER_MODE;
-	}
-	return 1;
-}
-__setup("axm_srio_tmr_mode=", axxia_timer_mode_setup);
-
-static int axxia_int_mode_setup(char *str)
-{
-	unsigned int int_mode[3];
-	int i;
-	(void)get_options(str, ARRAY_SIZE(int_mode), int_mode);
-	for (i = 0; i < int_mode[0]; i++) {
-		if (int_mode[i+1] > 1)
-			pr_debug("Invalid param value for Interrupt Mode\n");
-		else
-			axxia_dme_tmr_mode[i] = AXXIA_IBDME_INTERRUPT_MODE;
-	}
-	return 1;
-}
-__setup("axm_srio_int_mode=", axxia_int_mode_setup);
-
-#define AXXIA_HRTIMER_DELAY	(200 * 1000UL)
-unsigned int axxia_hrtimer_delay = AXXIA_HRTIMER_DELAY;
-static int __init axxia_hrtimer_setup(char *str)
-{
-	get_option(&str, &axxia_hrtimer_delay);
-	return 1;
-}
-__setup("axm_srio_tmr_period=", axxia_hrtimer_setup);
-
-/**************************sRIO SERDES *****************************/
-u32 srio_serdes_write32(struct rio_priv *priv, u32 addr, u32 val)
-{
-	void __iomem *regaddr;
-	u32 regval = 0;
-
-	regaddr = (priv->linkdown_reset.win) +
-			APB2SER_SRIO_PHY0_CFG_OFFSET;
-	iowrite32(val, (regaddr + SERDES_CMD0_OFFSET));
-	regval = ((1<<SERDES_CMD1_VALID_SHIFT) |
-			(0x1 << SERDES_CMD1_HWRITE_SHIFT) |
-			(0x01<<SERDES_CMD1_TSHIFT_SHIFT) |
-			(0x2<<SERDES_CMD1_HSZIE_SHIFT) |
-			(0x2 << SERDES_CMD1_HTRANS_SHIFT) |
-			(addr & SERDES_CMD1_HADDR_MASK));
-	iowrite32(regval, (regaddr + SERDES_CMD1_OFFSET));
-
-	regval = 0xffffffff;
-	while (1) {
-		regval = ioread32((regaddr + SERDES_CMD1_OFFSET));
-		if (!(regval & (1 << SERDES_CMD1_VALID_SHIFT)))
-			break;
-	}
-
-	regval = ioread32((regaddr + SERDES_READDATA1_OFFSET));
-	if (regval & SERDES_READDATA1_HRESP_MASK) {
-		dev_err(priv->dev, "SerDes write Failed... Returning 0\n");
-		return 0;
-	} else
-		return 1;
-}
-
-u32 srio_serdes_read32(struct rio_priv *priv, u32 addr)
-{
-	void __iomem *regaddr;
-	u32 regval = 0;
-
-	regaddr = (priv->linkdown_reset.win) +
-			APB2SER_SRIO_PHY0_CFG_OFFSET;
-	regval = ((1<<SERDES_CMD1_VALID_SHIFT) |
-			(0x01<<SERDES_CMD1_TSHIFT_SHIFT) |
-			(0x2<<SERDES_CMD1_HSZIE_SHIFT) |
-			(0x2 << SERDES_CMD1_HTRANS_SHIFT) |
-			(addr & SERDES_CMD1_HADDR_MASK));
-
-	iowrite32(regval, (regaddr + SERDES_CMD1_OFFSET));
-	regval = 0xffffffff;
-	while (1) {
-		regval = ioread32((regaddr + SERDES_CMD1_OFFSET));
-		if ((regval & (1 << SERDES_CMD1_VALID_SHIFT)) == 0x0)
-			break;
-	}
-	regval = ioread32((regaddr + SERDES_READDATA1_OFFSET));
-	if (regval & SERDES_READDATA1_HRESP_MASK) {
-		dev_err(priv->dev, "SerDes Read Failed... Returning 0\n");
-		return 0;
-	}
-	regval = ioread32((regaddr + SERDES_READDATA0_OFFSET));
-	return regval;
-}
-
-/**************************sRIO SERDES Ends ***************************/
-static void  ib_dme_irq_handler(struct rio_irq_handler *h/*, u32 state*/);
-/****************************************************************************
-**
-** Implementation Note:
-**
-** The Message DME registers lie within the fixed page block in the RAB SRIO
-** Configuration memory.  Thus, all or almost all of its register accesses
-** do not require use of the RAB memory paging register.  On the other hand,
-** the Message descriptor registers for the ACP34xx platform do lie outside
-** of the fixed page block.  For safety, we will direct all of the accesses
-** to the Message descriptor registers (on the ACP34xx platform and the like),
-** through the RIO mport's lcread and lcwrite interfaces which use a software
-** spin lock to control access.
-**
-*****************************************************************************/
-
-static inline void __dme_dw_dbg(struct device *dev, struct rio_msg_dme *dme,
-			u32 iout, u32 dw0, u32 dw1)
-{
-	int did, mb, let;
-	char *io;
-	char *id;
-
-	if (dw0 & DME_DESC_DW0_ERROR_MASK) {
-		did = DME_DESC_DW0_GET_DST_ID(dw0);
-		let = DME_DESC_DW1_GET_LETTER(dw1);
-		mb = DME_DESC_DW1_GET_MBOX(dw1);
-		if (iout) {
-			io = "OB";
-			id = "DID";
-		} else {
-			io = "IB";
-			id = "SID";
-		}
-#if defined(CONFIG_AXXIA_RIO_STAT)
-		dme->desc_error_count++;
-#endif
-		if (dw0 & DME_DESC_DW0_RIO_ERR) {
-			dev_err(dev,
-			"%s RIO ERR: %s = %x,Type:11,mbox=%d,letter=%d\n",
-			 io, id, did, mb, let);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-			dme->desc_rio_err_count++;
-#endif
-		}
-		if (dw0 & DME_DESC_DW0_AXI_ERR) {
-			dev_err(dev,
-			"%s AXI ERR: %s = %x,Type:11,mbox=%d,letter=%d\n",
-			 io, id, did, mb, let);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-			dme->desc_axi_err_count++;
-#endif
-		}
-		if (dw0 & DME_DESC_DW0_TIMEOUT_ERR) {
-			dev_err(dev,
-			"%s TIMEOUT ERR: %s = %x,Type:11,mbox=%d,letter=%d\n",
-			 io, id, did, mb, let);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-			dme->desc_tmo_err_count++;
-#endif
-		}
-	}
-#if defined(CONFIG_AXXIA_RIO_STAT)
-	dme->desc_done_count++;
-#endif
-}
-
-#if defined(CONFIG_AXXIA_RIO_STAT)
-static void reset_state_counters(struct rio_priv *priv)
-{
-	priv->rpio_compl_count = 0;
-	priv->rpio_failed_count = 0;
-	priv->apio_compl_count = 0;
-	priv->apio_failed_count = 0;
-	priv->rio_pw_count = 0;
-	priv->rio_pw_msg_count = 0;
-}
-#endif /* defined(CONFIG_AXXIA_RIO_STAT) */
-
-/**
- * thrd_irq_handler - Threaded interrupt handler
- * @irq: Linux interrupt number
- * @data: Pointer to interrupt-specific data
- *
- */
-static irqreturn_t thrd_irq_handler(int irq, void *data)
-{
-	struct rio_irq_handler *h = data;
-	struct rio_priv *priv = h->data;
-
-	/**
-	 * Invoke handler callback
-	 */
-	h->thrd_irq_fn(h);
-	axxia_local_config_write(priv, h->irq_enab_reg_addr, h->irq_state_mask);
-	return IRQ_HANDLED;
-}
-
-/**
- * hw_irq_handler - RIO HW interrupt handler
- * @irq: Linux interrupt number
- * @data: Pointer to interrupt-specific data
- *
- */
-static irqreturn_t hw_irq_handler(int irq, void *data)
-{
-	struct rio_irq_handler *h = data;
-	struct rio_priv *priv = h->data;
-	u32 state;
-	/**
-	 * Get current interrupt state and clear latched state
-	 * for interrupts handled by current thread.
-	 */
-	axxia_local_config_read(priv, h->irq_state_reg_addr, &state);
-	state &= h->irq_state_mask;
-
-	if (state) {
-		axxia_local_config_write(priv, h->irq_enab_reg_addr, 0x0);
-		return IRQ_WAKE_THREAD;
-	}
-	return IRQ_NONE;
-}
-
-static irqreturn_t hw_irq_dme_handler(int irq, void *data)
-{
-	struct rio_irq_handler *h;
-	struct rio_priv *priv = data;
-
-	h = &priv->ib_dme_irq;
-	ib_dme_irq_handler(h);
-
-	return IRQ_HANDLED;
-}
-
-/**
- * Caller must hold RAB lock
- */
-int alloc_irq_handler(struct rio_irq_handler *h,
-		     void *data,
-		     const char *name)
-{
-	struct rio_priv *priv = data;/*mport->priv;*/
-	u32 mask;
-	int rc;
-
-	if (test_and_set_bit(RIO_IRQ_ENABLED, &h->state))
-		return -EBUSY;
-
-	h->data = data;
-	rc = request_threaded_irq(priv->irq_line,
-				  hw_irq_handler,
-				  thrd_irq_handler,
-				  IRQF_TRIGGER_NONE | IRQF_SHARED,
-				  name,
-				  (void *)h);
-	if (rc) {
-		clear_bit(RIO_IRQ_ENABLED,  &h->state);
-		h->data = NULL;
-		return rc;
-	}
-	if (h->irq_enab_reg_addr) {
-		axxia_local_config_read(priv, h->irq_enab_reg_addr, &mask);
-		mask |= h->irq_state_mask;
-		axxia_local_config_write(priv, h->irq_state_reg_addr, mask);
-		axxia_local_config_write(priv, h->irq_enab_reg_addr, mask);
-	}
-
-	return rc;
-}
-
-/**
- * Caller must hold RAB lock
- */
-
-void release_irq_handler(struct rio_irq_handler *h)
-{
-	struct rio_priv *priv = h->data;
-	u32 mask;
-
-	if (test_and_clear_bit(RIO_IRQ_ENABLED, &h->state)) {
-		axxia_local_config_read(priv, h->irq_enab_reg_addr, &mask);
-		mask &= ~h->irq_state_mask;
-		axxia_local_config_write(priv, h->irq_enab_reg_addr, mask);
-		free_irq(priv->irq_line, h);
-		if (h->release_fn)
-			h->release_fn(h);
-	}
-}
-
-/**
- * MISC Indications
- */
-#if defined(CONFIG_RAPIDIO_HOTPLUG)
-static void rio_port_down_notify(struct rio_mport *mport)
-{
-	unsigned long flags;
-	struct rio_priv *priv = mport->priv;
-
-	spin_lock_irqsave(&priv->port_lock, flags);
-	if (priv->port_notify_cb)
-		priv->port_notify_cb(mport);
-
-	spin_unlock_irqrestore(&priv->port_lock, flags);
-}
-#else
-#define rio_port_down_notify(mport)
-#endif
-
-/**
- * __port_fatal_err - Check port error state and clear latched
- *                    error state to enable detection of new events.
- *
- * @mport: Master port
- *
- * Returns:
- * 1 -- port fatal error state is detected
- * 0 -- port ok
- */
-static inline void __misc_fatal(struct rio_mport *mport,
-				u32 misc_state)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 amast = 0;
-	u32 aslv_state = 0;
-	u32 aslv_addr = 0;
-	u32 escsr, iecsr;
-
-	dev_err(priv->dev, "*************Fatal Error************\n");
-	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &escsr);
-	axxia_local_config_read(priv, EPC_IECSR(priv->port_ndx), &iecsr);
-
-	/* clear latched state indications */
-	/* Adding I2E to preserve idle sequence select bit which is R/w */
-	axxia_local_config_write(priv, RIO_ESCSR(priv->port_ndx),
-				(escsr & (RIO_ESCSR_I2E | RIO_EXCSR_WOLR)));
-	dev_err(priv->dev, "port %d ESCSR(0x158) 0x%08x\n", priv->ndx, escsr);
-	if (iecsr & EPC_IECSR_RETE) {
-		dev_err(priv->dev, "Retry Error Threshold Exceeded\n");
-		axxia_local_config_write(priv, EPC_IECSR(priv->port_ndx),
-				(iecsr & EPC_IECSR_RETE));
-	}
-	if (misc_state & AMST_INT) {
-		axxia_local_config_read(priv, RAB_AMAST_STAT, &amast);
-		if (amast & RAB_AMAST_STAT_WRTO)
-			dev_err(priv->dev, "AMST Write Response Timeout Error\n");
-		if (amast & RAB_AMAST_STAT_RDTO)
-			dev_err(priv->dev, "AMST Read Response Timeout Error\n");
-		if (amast & RAB_AMAST_STAT_WRDE)
-			dev_err(priv->dev, "AMST Write Decode Error\n");
-		if (amast & RAB_AMAST_STAT_WRSE)
-			dev_err(priv->dev, "AMST Write Slave Error\n");
-		if (amast & RAB_AMAST_STAT_RDDE)
-			dev_err(priv->dev, "AMST Read Decode Error\n");
-		if (amast & RAB_AMAST_STAT_RDSE)
-			dev_err(priv->dev, "AMST Read Slave Error\n");
-		/* clear latched state */
-		axxia_local_config_write(priv, RAB_AMAST_STAT, amast);
-	}
-	if (misc_state & ASLV_INT) {
-		axxia_local_config_read(priv, RAB_ASLV_STAT_CMD,  &aslv_state);
-		axxia_local_config_read(priv, RAB_ASLV_STAT_ADDR, &aslv_addr);
-		if (aslv_state & RAB_ASLV_STAT_CMD_USUP) {
-			dev_err(priv->dev, "AMBA Slave Unsupported Command\n");
-			axxia_local_config_write(priv, RAB_ASLV_STAT_CMD,
-					 (aslv_state & RAB_ASLV_STAT_CMD_USUP));
-		}
-	}
-	if ((escsr & ESCSR_FATAL) ||
-	    (iecsr & EPC_IECSR_RETE) ||
-	    (misc_state & MISC_FATAL))
-		rio_port_down_notify(mport);
-}
-
-/**
- * srio_sw_reset - Reset the SRIO (GRIO) module when it reaches a fatal
- *                 lockup state or if it received a reset control symbol
- */
-static void srio_sw_reset(struct rio_priv *priv)
-{
-	u32 r32;
-	u32 sval;
-
-	r32 = srio_serdes_read32(priv, SRIO_PHY_CONTROL0_OFFSET);
-	srio_serdes_write32(priv, SRIO_PHY_CONTROL0_OFFSET,
-			(r32 | priv->linkdown_reset.reg_mask));
-	while (1) {
-		sval = srio_serdes_read32(priv, SRIO_PHY_CONTROL0_OFFSET);
-		if ((sval & priv->linkdown_reset.reg_mask))
-			break;
-	}
-	srio_serdes_write32(priv, SRIO_PHY_CONTROL0_OFFSET, (r32));
-	sval = 0;
-	while (1) {
-		sval = srio_serdes_read32(priv, SRIO_PHY_CONTROL0_OFFSET);
-		if (sval == r32)
-			break;
-	}
-}
-
-/**
- * PORT WRITE events
- */
-/**
- * pw_irq_handler - AXXIA port write interrupt handler
- * @h: handler specific data
- * @state: PW Interrupt state
- *
- * Handles port write interrupts.
- */
-static void pw_irq_handler(struct rio_irq_handler *h, u32 state)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_pw_irq *pw = priv->pw_data;
-	u32 csr;
-	int noofpw;
-	u32 msg_word;
-
-	if (pw == NULL) {
-		dev_dbg(priv->dev, "Spurious port write message\n");
-		return;
-	}
-
-	axxia_local_config_read(priv, RAB_IB_PW_CSR, &csr);
-	noofpw = RAB_IB_PW_NUMWORDS(csr);
-	dev_dbg(priv->dev, "%s: noofpw %d\n", __func__, noofpw);
-	if (!(noofpw)) {
-		dev_dbg(priv->dev, "PW Spurious Port Write\n");
-		return;
-	}
-#if defined(CONFIG_AXXIA_RIO_STAT)
-	priv->rio_pw_count++;
-#endif
-	while (noofpw) {
-
-read_buff:
-		axxia_local_config_read(priv, RAB_IB_PW_DATA, &msg_word);
-		pw->msg_buffer[pw->msg_wc++] = BSWAP(msg_word);
-		if (pw->msg_wc == 4) {
-#if defined(CONFIG_AXXIA_RIO_STAT)
-			priv->rio_pw_msg_count++;
-#endif
-			/*
-			 * Pass the port-write message to RIO
-			 * core for processing
-			 */
-			rio_inb_pwrite_handler(priv->mport,
-					 (union rio_pw_msg *)pw->msg_buffer);
-			pw->msg_wc = 0;
-		}
-		noofpw--;
-		if (noofpw)
-			goto read_buff;
-
-		axxia_local_config_read(priv, RAB_IB_PW_CSR, &csr);
-		noofpw = RAB_IB_PW_NUMWORDS(csr);
-	}
-}
-
-static void axxia_rio_flush_pw(struct rio_mport *mport, int noofpw,
-			     struct rio_pw_irq *pw_data)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 dummy;
-	int x;
-
-	dev_dbg(priv->dev, "(%s): flush %d words from pwbuff\n",
-		__func__, noofpw);
-	for (x = 0; x < noofpw; x++) {
-		axxia_local_config_read(priv, RAB_IB_PW_DATA, &dummy);
-		pw_data->discard_count++;
-	}
-	pw_data->msg_wc = 0;
-}
-
-/**
- * enable_pw - enable port-write interface unit
- * @h: Interrupt handler specific data
- *
- * Caller must hold RAB lock
- */
-static int enable_pw(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_pw_irq *pw_data;
-	u32 rval;
-	int rc = 0;
-
-	if (priv->pw_data)
-		return -EBUSY;
-
-	pw_data = kzalloc(sizeof(struct rio_pw_irq), GFP_KERNEL);
-	if (!pw_data)
-		return -ENOMEM;
-
-	axxia_local_config_read(priv, RAB_IB_PW_CSR, &rval);
-	rval |= RAB_IB_PW_EN;
-	axxia_rio_flush_pw(mport, RAB_IB_PW_NUMWORDS(rval), pw_data);
-	axxia_local_config_write(priv, RAB_IB_PW_CSR, rval);
-	priv->pw_data = pw_data;
-	return rc;
-}
-
-/**
- * disable_pw - Disable port-write interface unit
- * @mport: pointer to struct rio_mport
- *
- * Caller must hold RAB lock
- */
-static void disable_pw(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_pw_irq *pw_data = priv->pw_data;
-	u32 rval;
-
-	if (pw_data == NULL)
-		return;
-
-	axxia_local_config_read(priv, RAB_IB_PW_CSR, &rval);
-	rval &= ~RAB_IB_PW_EN;
-	axxia_local_config_write(priv, RAB_IB_PW_CSR, rval);
-	kfree(pw_data);
-	priv->pw_data = NULL;
-}
-
-
-/**
- * misc_irq_handler - MISC interrupt handler
- * @h: handler specific data
- * @state: Interrupt state
- * Handles the Error, doorbell, Link reset request Interrupts
- */
-static void misc_irq_handler(struct rio_irq_handler *h)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_mport *mport = priv->mport;
-	u32 misc_state;
-
-	axxia_local_config_read(priv, RAB_INTR_STAT_MISC, &misc_state);
-	/*
-	 * Handle miscellaneous 'Link (IPG) Reset Request'
-	 */
-	if (misc_state & LINK_REQ_INT)
-		srio_sw_reset(priv);
-
-	if (misc_state & PORT_WRITE_INT)
-		pw_irq_handler(h, misc_state & PORT_WRITE_INT);
-
-	if (misc_state & (IB_DB_RCV_INT | OB_DB_DONE_INT))
-		db_irq_handler(h,
-			misc_state & (IB_DB_RCV_INT | OB_DB_DONE_INT));
-	/**
-	 * Notify platform if port is broken
-	 */
-	if (misc_state & MISC_FATAL)
-		__misc_fatal(mport, misc_state);
-
-	if (misc_state & GRIO_INT)
-		dev_err(priv->dev, "GRIO Error Interrupt\n");
-		/* TODO Need further Handling */
-	if (misc_state & LL_TL_INT)
-		dev_err(priv->dev, "Logical Layer Error Interrupt\n");
-		/* TODO Need further Handling */
-	if (misc_state & UNSP_RIO_REQ_INT)
-		dev_dbg(priv->dev, "Unsupported RIO Request Received\n");
-		/* TODO Need further Handling */
-	if (misc_state & UNEXP_MSG_INT)
-		dev_dbg_ratelimited(priv->dev,
-			"Unexpected Inbound Data Message Received\n");
-		/* TODO Need further Handling */
-
-	axxia_local_config_write(priv, RAB_INTR_STAT_MISC, misc_state);
-}
-
-static void misc_release_handler(struct rio_irq_handler *h)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_mport *mport = priv->mport;
-
-	disable_pw(mport);
-}
-/**
- * linkdown_irq_handler - Link Down interrupt Status interrupt handler
- * @h: handler specific data
- * @state: Interrupt state
- */
-static void linkdown_irq_handler(struct rio_irq_handler *h/*, u32 state*/)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_mport *mport = priv->mport;
-	u32 val;
-	u32 val1;
-	u32 rstate;
-
-	__rio_local_read_config_32(mport, RAB_SRDS_STAT1, &rstate);
-	__rio_local_read_config_32(mport, RAB_SRDS_CTRL2, &val);
-	__rio_local_read_config_32(mport, RAB_SRDS_CTRL1, &val1);
-	pr_info("Link Down: RAB_SRDS STAT1 = %x CTRL1 = %x CTRL2 = %x\n",
-					rstate, val1, val);
-	while (1) {
-		axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &val);
-		if (val & 0x2) {
-			pr_info("Link up, Exiting Linkdown monitor Handler\n");
-			__rio_local_read_config_32(mport, RAB_SRDS_CTRL1, &val);
-			__rio_local_write_config_32(mport, RAB_SRDS_CTRL1,
-								(val | 0x2));
-			__rio_local_write_config_32(mport, RAB_SRDS_CTRL2,
-							LINK_DOWN_TIMEOUT);
-			break;
-		}
-	}
-	__rio_local_read_config_32(mport, RAB_SRDS_STAT1, &rstate);
-	__rio_local_read_config_32(mport, RAB_SRDS_CTRL2, &val);
-	__rio_local_read_config_32(mport, RAB_SRDS_CTRL1, &val1);
-}
-
-/**
- * rpio_irq_handler - RPIO interrupt handler.
- * Service Peripheral Bus bridge, RapidIO -> Peripheral bus interrupt
- *
- * @h: handler specific data
- * @state: Interrupt state
- *
- */
-static void rpio_irq_handler(struct rio_irq_handler *h)
-{
-	struct rio_priv *priv = h->data;
-	u32 rstate;
-
-	axxia_local_config_read(priv, RAB_INTR_STAT_RPIO, &rstate);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-	if (rstate & RPIO_TRANS_COMPLETE)
-		priv->rpio_compl_count++;
-#endif
-	if (rstate &  RPIO_TRANS_FAILED) {
-		u32 rpio_stat;
-
-		axxia_local_config_read(priv, RAB_RPIO_STAT, &rpio_stat);
-		if (rpio_stat & RAB_RPIO_STAT_RSP_ERR)
-			dev_dbg(priv->dev, "RPIO AXI Response Error\n");
-		if (rpio_stat & RAB_RPIO_STAT_ADDR_MAP)
-			dev_dbg(priv->dev, "RPIO Invalid Address Mapping Error\n");
-		if (rpio_stat & RAB_RPIO_STAT_DISABLED)
-			dev_dbg(priv->dev, "RPIO Engine Not Enabled\n");
-
-		axxia_local_config_write(priv, RAB_RPIO_STAT, rpio_stat);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-		priv->rpio_failed_count++;
-#endif
-	}
-	axxia_local_config_write(priv, RAB_INTR_STAT_RPIO, rstate);
-}
-
-/**
- * APIO
- */
-
-/**
- * apio_irq_handler - APIO interrupt handler.
- * Service Peripheral Bus bridge, Peripheral bus -> RapidIO interrupt
- *
- * @h: handler specific data
- * @state: Interrupt state
- *
- */
-static void apio_irq_handler(struct rio_irq_handler *h)
-{
-	struct rio_priv *priv = h->data;
-	u32 astate;
-
-	axxia_local_config_read(priv, RAB_INTR_STAT_APIO, &astate);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-	if (astate & APIO_TRANS_COMPLETE)
-		priv->apio_compl_count++;
-#endif
-	if (astate & APIO_TRANS_FAILED) {
-		u32 apio_stat;
-
-		axxia_local_config_read(priv, RAB_APIO_STAT, &apio_stat);
-		if (apio_stat & RAB_APIO_STAT_RQ_ERR)
-			dev_dbg(priv->dev, "APIO AXI Request Format Error\n");
-		if (apio_stat & RAB_APIO_STAT_TO_ERR)
-			dev_dbg(priv->dev, "APIO RIO Timeout Error\n");
-		if (apio_stat & RAB_APIO_STAT_RSP_ERR)
-			dev_dbg(priv->dev, "APIO RIO Response Error\n");
-		if (apio_stat & RAB_APIO_STAT_MAP_ERR)
-			dev_dbg(priv->dev, "APIO Invalid Address Mapping Error\n");
-		if (apio_stat & RAB_APIO_STAT_MAINT_DIS)
-			dev_dbg(priv->dev, "APIO Maintenance Mapping Not Enabled\n");
-		if (apio_stat & RAB_APIO_STAT_MEM_DIS)
-			dev_dbg(priv->dev, "APIO Memory Mapping Not Enabled\n");
-		if (apio_stat & RAB_APIO_STAT_DISABLED)
-			dev_dbg(priv->dev, "APIO Engine Not Enabled\n");
-		axxia_local_config_write(priv, RAB_APIO_STAT, apio_stat);
-#if defined(CONFIG_AXXIA_RIO_STAT)
-		priv->apio_failed_count++;
-#endif
-	}
-	axxia_local_config_write(priv, RAB_INTR_STAT_APIO, astate);
-}
-
-/**
- * DOORBELL events
- */
-
-/**
- * axxia_rio_rx_db_int_handler - AXXIA inbound doorbell interrupt handler
- * @mport: Master port with triggered interrupt
- * @mask: Interrupt register data
- *
- * Handles inbound doorbell interrupts.  Executes a callback on received
- * doorbell. Now called from the misc_irq thread, rio-misc-db.
- */
-void rx_db_handler(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_dbell *dbell;
-	u32 csr, info;
-	u8 num_msg;
-	u16 src_id, db_info;
-	int found;
-
-	axxia_local_config_read(priv, RAB_IB_DB_CSR, &csr);
-	num_msg = IB_DB_CSR_NUM_MSG(csr);
-
-	for (; num_msg; num_msg--) {
-		axxia_local_config_read(priv, RAB_IB_DB_INFO, &info);
-		src_id = DBELL_SID(info);
-		db_info = DBELL_INF(info);
-
-		found = 0;
-		dev_dbg(priv->dev,
-			 "Processing doorbell, sid %4.4x info %4.4x\n",
-			src_id, db_info);
-
-		list_for_each_entry(dbell, &mport->dbells, node) {
-			if (dbell->res->start <= db_info &&
-			    (dbell->res->end >= db_info)) {
-				found = 1;
-				break;
-			}
-		}
-		if (found) {
-			/**
-			 * NOTE: dst is set to 0 since we don't have
-			 *       that value in the ACP
-			 */
-			if (dbell->dinb)
-				dbell->dinb(mport, dbell->dev_id, src_id,
-						0, db_info);
-		} else {
-			dev_dbg(priv->dev,
-				"Spurious doorbell, sid %4.4x info %4.4x\n",
-				src_id, db_info);
-		}
-	}
-}
-
-void db_irq_handler(struct rio_irq_handler *h, u32 state)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_mport *mport = priv->mport;
-
-	/**
-	 * Handle RX doorbell events
-	 */
-	if (state & IB_DB_RCV_INT)
-		rx_db_handler(mport);
-
-	/**
-	 * Check for outbound doorbell Error conditions.
-	 */
-	if (state & OB_DB_DONE_INT) {
-		int db;
-		u32 csr;
-
-		for (db = 0; db < MAX_OB_DB; db++) {
-			axxia_local_config_read(priv, RAB_OB_DB_CSR(db), &csr);
-
-			if (OB_DB_STATUS(csr) == OB_DB_STATUS_RETRY)
-				dev_dbg(priv->dev,
-				  "Rio Doorbell Retry received\n");
-			else if (OB_DB_STATUS(csr) == OB_DB_STATUS_ERROR)
-				dev_dbg(priv->dev,
-				  "Rio Doorbell send Error\n");
-			else if (OB_DB_STATUS(csr) == OB_DB_STATUS_TIMEOUT)
-				dev_dbg(priv->dev,
-				  "Rio Doorbell send Timeout\n");
-		}
-	}
-}
-
-/**
- * OBDME Events/Outbound Messages
- */
-
-static void release_dme(struct kref *kref)
-{
-	struct rio_msg_dme *me = container_of(kref, struct rio_msg_dme, kref);
-	struct rio_priv *priv = me->priv;
-	struct rio_msg_desc *desc;
-	int i;
-
-	if (me->desc) {
-		for (i = 0, desc = me->desc; i < me->entries; i++, desc++)
-			kfree(desc->msg_virt);
-		kfree(me->desc);
-	}
-
-	kfree(me->descriptors);
-
-	if (priv->intern_msg_desc) {
-		if (me->dres.parent)
-			release_resource(&me->dres);
-	}
-
-	kfree(me);
-}
-
-static inline struct rio_msg_dme *dme_get(struct rio_msg_dme *me)
-{
-	if (me)
-		kref_get(&me->kref);
-	return me;
-}
-
-static inline void dme_put(struct rio_msg_dme *me)
-{
-	if (me)
-		kref_put(&me->kref, release_dme);
-}
-
-static inline int check_dme(int dme_no,
-			    int *num_dmes,
-			    int *dmes_in_use,
-			    int *dmes)
-{
-	int i;
-
-	for (i = 0; i < 2; i++) {
-		if (dme_no < num_dmes[i]) {
-			if (dmes[i] & (1 << dme_no)) {
-				if (dmes_in_use[i] & (1 << dme_no))
-					return -EBUSY;	/* Already allocated */
-				return 0;
-			}
-		} else {
-			dme_no -= num_dmes[i];
-		}
-	}
-
-	return -ENXIO;	/* Not available */
-}
-
-/*
- * Enforce a DME 'choice' previously made
- */
-static inline int select_dme(int dme_no,
-			     int *num_dmes,
-			     int *dmes_in_use,
-			     int *dmes,
-			     int value)
-{
-	int i;
-
-	for (i = 0; i < 2; i++) {
-		if (dme_no < num_dmes[i]) {
-			dmes_in_use[i] &= ~(1 << dme_no);
-			dmes_in_use[i] |= (value << dme_no);
-			return 0;
-		} else {
-			dme_no -= num_dmes[i];
-		}
-	}
-
-	return -ENXIO;	/* Not available */
-}
-
-/* Selects the DME for an Mbox
- * based on its occupancy. Two Outbound DMEs
- * are shared among mailboxes
- */
-static inline int choose_ob_dme_static(
-	struct rio_priv	*priv,
-	int mbox_dest,
-	int buf_sz,
-	struct rio_msg_dme **ob_dme)
-{
-	int  i, ndx, sz, min_entries = 0;
-	int  dme_no = 0, ret_dme_no = -ENXIO;
-	struct rio_msg_dme *ret_dme = NULL;
-	struct rio_tx_dme *dme_s;
-
-	/* Multi-segment vs single-segment DMEs */
-	ndx = RIO_MBOX_TO_IDX(mbox_dest);
-	switch (ndx) {
-	case 0:
-		if ((priv->num_outb_dmes[0] == 0) || (priv->outb_dmes[0] == 0))
-			return -ENXIO;
-		break;
-	case 1:
-		if ((priv->num_outb_dmes[1] == 0) || (priv->outb_dmes[1] == 0))
-			return -ENXIO;
-		dme_no += priv->num_outb_dmes[0];
-		break;
-	default:
-		dev_err(priv->dev, "Attempt to select unknown OB DME type!\n");
-		return -ENXIO;
-	}
-
-	/* Find one with fewest entries, or sufficient free entries */
-	for (i = 0; i < priv->num_outb_dmes[ndx]; i++, dme_no++) {
-		sz = RIO_OUTB_DME_TO_BUF_SIZE(priv, dme_no);
-
-		if (sz > buf_sz)
-			continue;
-
-		dme_s = &priv->ob_dme_shared[dme_no];
-
-		if (dme_s->ring_size_free > min_entries) {
-			min_entries = dme_s->ring_size_free;
-			ret_dme = dme_s->me;
-			ret_dme_no = dme_no;
-		}
-	}
-
-	(*ob_dme) = ret_dme;
-	return ret_dme_no;
-}
-
-static void release_mbox(struct kref *kref)
-{
-	struct rio_rx_mbox *mb = container_of(kref, struct rio_rx_mbox, kref);
-	struct rio_priv *priv = mb->mport->priv;
-	int letter;
-	u32 dme_no;
-
-	/* Quickly disable the engines */
-	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++) {
-		if (mb->me[letter])
-			axxia_local_config_write(priv,
-				   RAB_IB_DME_CTRL(mb->me[letter]->dme_no), 0);
-	}
-
-	/* And then release the remaining resources */
-	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++) {
-		if (mb->me[letter]) {
-			dme_no = mb->me[letter]->dme_no;
-			dme_put(mb->me[letter]);
-			select_dme(dme_no,
-					&priv->num_inb_dmes[0],
-					&priv->inb_dmes_in_use[0],
-					&priv->inb_dmes[0], 0);
-			priv->ib_dme[dme_no] = NULL;
-		}
-	}
-
-
-	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++)
-		kfree(mb->virt_buffer[letter]);
-
-	kfree(mb);
-}
-
-static inline struct rio_rx_mbox *mbox_get(struct rio_rx_mbox *mb)
-{
-	if (mb)
-		kref_get(&mb->kref);
-	return mb;
-}
-
-static inline void mbox_put(struct rio_rx_mbox *mb)
-{
-	if (mb)
-		kref_put(&mb->kref, release_mbox);
-}
-
-static int alloc_msg_descriptors(struct rio_mport *mport,
-				  struct resource *dres,
-				  int buf_sz,
-				  int entries,
-				  int need_to_init,
-				  struct rio_msg_desc **desc,
-				  struct rio_desc **descriptors)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_msg_desc *rdesc = NULL, *idesc;
-	struct rio_desc *rdescriptors = NULL;
-	int i;
-
-	if (priv->intern_msg_desc) {
-		dres->name = "DME_DESC";
-		dres->flags = ACP_RESOURCE_HW_DESC;
-		if (allocate_resource(&priv->acpres[ACP_HW_DESC_RESOURCE],
-				dres, entries,
-				priv->acpres[ACP_HW_DESC_RESOURCE].start,
-				priv->acpres[ACP_HW_DESC_RESOURCE].end,
-				0x1, NULL, NULL)) {
-			memset(dres, 0, sizeof(*dres));
-			goto err;
-		}
-	} else {
-		dres->start = 0;
-	}
-
-	rdesc = kzalloc(sizeof(struct rio_msg_desc) * entries, GFP_ATOMIC);
-	if (rdesc == NULL)
-		goto err;
-	rdescriptors = kzalloc(sizeof(struct rio_desc) * entries, GFP_ATOMIC);
-	if (rdescriptors == NULL)
-		goto err;
-
-	for (i = 0, idesc = rdesc; i < need_to_init; i++, idesc++) {
-		idesc->msg_virt = kzalloc(buf_sz, GFP_KERNEL);
-		if (!idesc->msg_virt)
-			goto err;
-		idesc->msg_phys = virt_to_phys(idesc->msg_virt);
-	}
-
-	idesc--;
-	idesc->last = DME_DESC_DW0_NXT_DESC_VALID;
-
-	(*desc) = rdesc;
-	(*descriptors) = rdescriptors;
-
-	return 0;
-
-err:
-	kfree(rdesc);
-	kfree(rdescriptors);
-	return -ENOMEM;
-}
-
-static struct rio_msg_dme *alloc_message_engine(struct rio_mport *mport,
-						int dme_no, void *dev_id,
-						int buf_sz, int entries)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_msg_dme *me = kzalloc(sizeof(struct rio_msg_dme),
-					 GFP_KERNEL);
-	int rc = 0;
-
-	if (!me)
-		return ERR_PTR(-ENOMEM);
-
-	memset(me, 0, sizeof(struct rio_msg_dme));
-
-	kref_init(&me->kref);
-	spin_lock_init(&me->lock);
-	me->priv = priv;
-	me->sz = 0;/*buf_sz;*/
-
-	rc = alloc_msg_descriptors(mport, &me->dres, buf_sz, entries,
-				entries, &me->desc, &me->descriptors);
-	if (rc < 0)
-		goto err;
-
-	me->entries = entries;
-	me->dev_id = dev_id;
-	me->write_idx = 0;
-	me->read_idx = 0;
-	me->tx_dme_tmo = 0;
-	me->dme_no = dme_no;
-
-	return me;
-
-err:
-	dme_put(me);
-	return ERR_PTR(rc);
-}
-
-/**
- * ob_dme_msg_handler - Outbound Data message handler
- * --- Called from OB DME irq handler thread ---
- * @h: Pointer to interrupt-specific data
- *
- * Handles outbound message interrupts. Executes a callback,
- * if available.
- *
- * @note:
- * HW descriptor fetch and update may be out of order.
- * Check state of all used descriptors and take care to not fall into
- * any of the traps that come with this design:
- *
- * Due to this (possibly) out of order execution in the HW, SW ack of
- * descriptors must be done atomically, re-enabling descriptors with
- * completed transactions while processing finished transactions may
- * break the ring and leave the DMA engine in a state where it doesn't
- * process new inserted requests.
- */
-static void  ob_dme_msg_handler(struct rio_irq_handler *h, u32 dme_no)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_mport *mport = priv->mport;
-	struct rio_msg_dme *dme = priv->ob_dme_shared[dme_no].me;
-	u32 dw0;
-	u32 dw1;
-	int mbox;
-	struct rio_tx_mbox *mb;
-	unsigned int iteration = 0;
-
-	/**
-	 * Process all completed transactions
-	 */
-ob_dme_restart:
-	while (dme->read_idx != dme->write_idx) {
-		AXXIA_RIO_SYSMEM_BARRIER();
-		dw0 = *((u32 *)DESC_TABLE_W0_MEM(dme, dme->read_idx));
-		if ((dw0 & DME_DESC_DW0_VALID) &&
-			(dw0 & DME_DESC_DW0_READY_MASK)) {
-			*((u32 *)DESC_TABLE_W0_MEM(dme, dme->read_idx))
-					= dw0 & DME_DESC_DW0_NXT_DESC_VALID;
-			dw1 = *((u32 *)DESC_TABLE_W1_MEM(dme,
-						dme->read_idx));
-			__dme_dw_dbg(priv->dev, dme, 1, dw0, dw1);
-			dme->read_idx = (dme->read_idx + 1) &
-						(dme->entries - 1);
-			mbox = (dw1 >> 2) & 0x3;
-			mb = priv->ob_mbox[mbox];
-			if (mb) {
-				if (mport->outb_msg[mbox].mcback) {
-					mb->tx_slot = (mb->tx_slot + 1)
-							%(mb->ring_size);
-					mport->outb_msg[mbox].mcback(mport,
-							mb->dev_id,
-							mbox, mb->tx_slot);
-				}
-#ifdef CONFIG_AXXIA_RIO_STAT
-				mb->compl_msg_count++;
-#endif
-			}
-			iteration++;
-		} else
-			break;
-	}
-	if (iteration) {
-		iteration = 0;
-		goto ob_dme_restart;
-	}
-}
-
-/**
- * ob_dme_irq_handler - Outbound message interrupt handler
- * --- Called in threaded irq handler ---
- * @h: Pointer to interrupt-specific data
- *
- * Handles outbound message interrupts. Calls the
- * msg handler if dscriptor xfer complete is set.
- * or reports the error
- */
-enum hrtimer_restart ob_dme_tmr_handler(struct hrtimer *hr)
-{
-	struct rio_tx_dme *obd = container_of(hr, struct rio_tx_dme, tmr);
-	struct rio_msg_dme *me = obd->me;
-	struct rio_priv *priv = me->priv;
-	struct rio_irq_handler *h = &priv->ob_dme_irq;
-	u32 dme_stat, dme_no;
-
-	dme_no = me->dme_no;
-	axxia_local_config_read(priv, RAB_OB_DME_STAT(dme_no),
-						&dme_stat);
-
-	if (dme_stat & (OB_DME_STAT_DESC_FETCH_ERR |
-				OB_DME_STAT_DESC_ERR |
-				OB_DME_STAT_DESC_UPD_ERR))
-		dev_err(priv->dev, "OB DME%d: Descriptor Error\n",
-								dme_no);
-	else {
-
-		if (dme_stat & (OB_DME_STAT_DATA_TRANS_ERR |
-				OB_DME_STAT_RESP_ERR |
-				OB_DME_STAT_RESP_TO)) {
-			if (dme_stat & OB_DME_STAT_DATA_TRANS_ERR)
-				dev_err(priv->dev, "OB DME%d: Transaction Error\n",
-								dme_no);
-			if (dme_stat & OB_DME_STAT_RESP_ERR)
-				dev_dbg_ratelimited(priv->dev,
-						"OB DME%d: Response Error\n",
-								dme_no);
-			if (dme_stat & OB_DME_STAT_RESP_TO)
-				dev_err(priv->dev, "OB DME%d: Response Timout Error\n",
-								dme_no);
-		}
-		ob_dme_msg_handler(h, dme_no);
-	}
-	axxia_local_config_write(priv, RAB_OB_DME_STAT(dme_no),
-							dme_stat);
-	hrtimer_forward_now(&obd->tmr, ktime_set(0, axxia_hrtimer_delay));
-	return HRTIMER_RESTART;
-}
-
-static int alloc_ob_dme_shared(struct rio_priv *priv,
-			struct rio_tx_dme *dme_s, int dme_no)
-{
-	int rc = 0;
-	int sz;
-	struct rio_mport *mport = priv->mport;
-	struct rio_msg_dme *me = NULL;
-	struct rio_msg_desc *desc = NULL;
-	u32 dw0, dw1, dw2, dw3;
-	u64  desc_chn_start = 0;
-	int entries = OB_DME_ENTRIES;
-	int i;
-
-	sz = RIO_OUTB_DME_TO_BUF_SIZE(priv, dme_no);
-	entries = roundup_pow_of_two(entries);
-	me = alloc_message_engine(mport,
-				dme_no, NULL, sz, entries);
-	if (IS_ERR(me)) {
-		rc = PTR_ERR(me);
-		goto err;
-	}
-
-	for (i = 0, desc = me->desc; i < entries; i++, desc++) {
-		dw0 = 0;
-		if (!priv->intern_msg_desc) {
-			dw1 = 0;
-			if (axxia_rio_is_x9()) {
-				dw0 = (u32)(desc->msg_phys >> 38) & 0x3;
-				dw0 = (u32)(dw0 << 12);
-			}
-			dw2 = (u32)(desc->msg_phys >>  8) & 0x3fffffff;
-			*((u32 *)DESC_TABLE_W0_MEM(me, i)) = dw0;
-			*((u32 *)DESC_TABLE_W1_MEM(me, i)) = dw1;
-			*((u32 *)DESC_TABLE_W2_MEM(me, i)) = dw2;
-			*((u32 *)DESC_TABLE_W3_MEM(me, i)) = 0;
-		} else {
-			dw1 = 0;
-			dw2 = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
-			__rio_local_write_config_32(mport,
-				    DESC_TABLE_W0(me->dres.start+i), dw0);
-			__rio_local_write_config_32(mport,
-				    DESC_TABLE_W1(me->dres.start+i), dw1);
-			__rio_local_write_config_32(mport,
-				    DESC_TABLE_W2(me->dres.start+i), dw2);
-			__rio_local_write_config_32(mport,
-				    DESC_TABLE_W3(me->dres.start+i), 0);
-		}
-	}
-
-
-	/**
-	* Last descriptor - make ring.
-	* Next desc table entry -> dw2.First desc address[37:36]
-	*                       -> dw3.First desc address[35:4].
-	* (desc_base + 0x10 * nr)
-	*/
-	desc--; i--;
-	dw0 |= DME_DESC_DW0_NXT_DESC_VALID;
-	if (!priv->intern_msg_desc) {
-		desc_chn_start =
-			(uintptr_t)virt_to_phys(me->descriptors);
-
-		if (axxia_rio_is_x9()) {
-			dw0  = *((u32 *)DESC_TABLE_W0_MEM(me, i));
-			dw0 |= DME_DESC_DW0_NXT_DESC_VALID;
-			dw3 = (u32)(desc_chn_start >> 38) & 0x3;
-			dw0 |= (dw3 << 14);
-		}
-		dw2  = *((u32 *)DESC_TABLE_W2_MEM(me, i));
-		if (axxia_rio_is_x9())
-			dw2 |= (desc_chn_start >> 6) & 0xc0000000;
-		else
-			dw2 |= (desc_chn_start >> 4) & 0xc0000000;
-		dw3  = desc_chn_start >> 4;
-		*((u32 *)DESC_TABLE_W0_MEM(me, i)) = dw0;
-		*((u32 *)DESC_TABLE_W2_MEM(me, i)) = dw2;
-		*((u32 *)DESC_TABLE_W3_MEM(me, i)) = dw3;
-	} else {
-		desc_chn_start = DESC_TABLE_W0(me->dres.start);
-		__rio_local_read_config_32(mport,
-				DESC_TABLE_W2(me->dres.start+i), &dw2);
-		dw2 |= ((desc_chn_start >> 8) & 0xc0000000);
-		dw3  = 0;
-		__rio_local_write_config_32(mport,
-				DESC_TABLE_W0(me->dres.start+i), dw0);
-		__rio_local_write_config_32(mport,
-				DESC_TABLE_W2(me->dres.start+i), dw2);
-		__rio_local_write_config_32(mport,
-				DESC_TABLE_W3(me->dres.start+i), dw3);
-	}
-	test_and_set_bit(RIO_DME_OPEN, &me->state);
-	dme_s->me = me;
-	dme_s->ring_size = 0x0;
-	dme_s->ring_size_free = entries;
-err:
-	return rc;
-}
-/**
- * open_outb_mbox_static - Initialize AXXIA outbound mailbox
- *			   using statically allocated DME descriptors.
- *
- * @mport: Master port implementing the outbound message unit
- * @dev_id: Device specific pointer to pass on event
- * @mbox_id: Mailbox to open
- * @entries: Number of entries in the outbound mailbox ring for each letter
- * @prio: 0..3, higher number -> lower priority.
- *
- * Caller must hold RAB lock
- * If the specified mbox DME has already been opened/reserved, then we just
- * abort out of this operation with "busy", and without changing resource
- * allocation for the mbox DME.
- *
- * To increase efficiecny the Descriptors are allocated and initalized during
- * initialization time and then kept forever to be reused.
- *
- * Returns:
- * %0 if successful
- * %-EINVAL if an argument is invalid
- * %-ENOMEM if unable to allocate sufficient memory
- * %-ENODEV if unable to find a DME matching the input arguments
- */
-
-static int open_outb_mbox_static(struct rio_mport *mport,
-			void *dev_id, int mbox_id, int entries, int prio)
-{
-	int  rc = 0;
-	int  dme_no, buf_sz = 0;
-	struct rio_priv *priv = mport->priv;
-	struct rio_tx_mbox *mb;/* = priv->ob_mbox[mbox_id];*/
-	struct rio_msg_dme *me = NULL;
-	unsigned long iflags0;
-	u32 dme_ctrl, dme_stat, desc_addr, wait = 0;
-	u64  desc_chn_start = 0;
-
-	if ((mbox_id < 0) || (mbox_id > RIO_MAX_TX_MBOX) ||
-	    (entries < 2) || (entries > priv->desc_max_entries))
-		return -EINVAL;
-	if (priv->ob_mbox[mbox_id])
-		return -EINVAL;
-	mb = kzalloc(sizeof(struct rio_tx_mbox), GFP_KERNEL);
-	if (!mb)
-		return -ENOMEM;
-	spin_lock_init(&mb->lock);
-	mb->dme_no = 0xff;
-#ifdef CONFIG_AXXIA_RIO_STAT
-	mb->sent_msg_count = 0;
-	mb->compl_msg_count = 0;
-#endif
-	spin_lock_irqsave(&mb->lock, iflags0);
-
-	if (test_bit(RIO_MB_OPEN, &mb->state)) {
-		spin_unlock_irqrestore(&mb->lock, iflags0);
-		return -EINVAL;
-	}
-
-	/*
-	** Pick the OB DME that we will use for this mailbox
-	*/
-		buf_sz = RIO_MBOX_TO_BUF_SIZE(mbox_id);
-
-		dme_no = choose_ob_dme_static(priv, mbox_id, buf_sz, &me);
-		if (dme_no < 0) {
-			spin_unlock_irqrestore(&mb->lock, iflags0);
-			rc = dme_no;
-			goto err;
-		}
-		if (IS_ERR_OR_NULL(me)) {
-			spin_unlock_irqrestore(&mb->lock, iflags0);
-			rc = PTR_ERR(me);
-			goto err;
-		}
-
-		if (!test_bit(RIO_DME_MAPPED, &me->state)) {
-			do {
-				axxia_local_config_read(priv,
-					RAB_OB_DME_STAT(dme_no), &dme_stat);
-				if (wait++ > 100) {
-					rc = -EBUSY;
-					goto err;
-				}
-			} while (dme_stat & OB_DME_STAT_TRANS_PEND);
-			desc_chn_start =
-				(uintptr_t)virt_to_phys(me->descriptors);
-
-			dme_ctrl  = (prio & 0x3) << 4;
-			dme_ctrl |= (u32)((desc_chn_start >> 6) & 0xc0000000);
-			desc_addr  = (u32)desc_chn_start >> 4;
-			axxia_local_config_write(priv,
-				RAB_OB_DME_DESC_ADDR(dme_no), desc_addr);
-			axxia_local_config_write(priv, RAB_OB_DME_CTRL(dme_no),
-					dme_ctrl);
-			me->dme_ctrl = dme_ctrl;
-			me->dme_ctrl |= (DME_WAKEUP | DME_ENABLE);
-			priv->ob_dme_irq.irq_state_mask |= (1 << dme_no);
-			axxia_local_config_write(priv, RAB_INTR_STAT_ODME,
-								1<<dme_no);
-			axxia_local_config_write(priv, RAB_INTR_ENAB_ODME,
-					priv->ob_dme_irq.irq_state_mask);
-			test_and_set_bit(RIO_DME_MAPPED, &me->state);
-		}
-
-
-	mb->mport = mport;
-	mb->mbox_no = mbox_id;
-	mb->dme_no = dme_no;
-	mb->me = me;
-	mb->ring_size = entries;
-	mb->tx_slot = 0;
-	mb->dev_id = dev_id;
-	me->sz++;
-	mdelay(500); /* Delay added to ensure completion of any pending TX
-			before Transmission on this Mailbox */
-
-	if (me->sz == 1) {
-		hrtimer_init(&priv->ob_dme_shared[dme_no].tmr,
-				 CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-		priv->ob_dme_shared[dme_no].tmr.function = ob_dme_tmr_handler;
-		hrtimer_start(&priv->ob_dme_shared[dme_no].tmr,
-				ktime_set(0, (axxia_hrtimer_delay)),
-					HRTIMER_MODE_REL_PINNED);
-	}
-
-	test_and_set_bit(RIO_MB_MAPPED, &mb->state);
-
-	priv->ob_dme_shared[dme_no].ring_size += entries;
-	priv->ob_dme_shared[dme_no].ring_size_free -= entries;
-
-	spin_unlock_irqrestore(&mb->lock, iflags0);
-
-#ifdef CONFIG_AXXIA_RIO_STAT
-	me->desc_done_count = 0;
-	me->desc_error_count = 0;
-	me->desc_rio_err_count = 0;
-	me->desc_axi_err_count = 0;
-	me->desc_tmo_err_count = 0;
-#endif
-	/**
-	 * Finish updating the mailbox and DME state before we go
-	 */
-	test_and_set_bit(RIO_MB_OPEN, &mb->state);
-	priv->ob_mbox[mbox_id] = mb;
-	return 0;
-
-err:
-	spin_unlock_irqrestore(&mb->lock, iflags0);
-	kfree(mb);
-	return rc;
-}
-
-
-/**
- * release_outb_dme - Close AXXIA outbound DME engine structures
- * @mport: Master port implementing the outbound message unit
- * @mbox: Mailbox to close
- *
- * Caller must hold RAB lock
- * Release all resources i.e. DMEs, descriptors, buffers, and so on.
- */
-
-static void release_outb_dme(struct rio_irq_handler *h)
-{
-	struct rio_priv *priv = h->data;
-	int i;
-	struct rio_msg_dme *me;
-
-	for (i = 0; i < DME_MAX_OB_ENGINES; i++) {
-		me = priv->ob_dme_shared[i].me;
-		if (me && test_bit(RIO_DME_OPEN, &me->state)) {
-			if (test_bit(RIO_DME_MAPPED, &me->state)) {
-				axxia_local_config_write(priv,
-					RAB_OB_DME_CTRL(me->dme_no), 0);
-
-				select_dme(me->dme_no,
-					&priv->num_outb_dmes[0],
-					&priv->outb_dmes_in_use[0],
-					&priv->outb_dmes[0], 0);
-			}
-
-			dme_put(me);
-		}
-	}
-	h->data = NULL;
-}
-
-/**
- * ib_dme_irq_handler - AXXIA inbound message interrupt handler
- * @mport: Master port with triggered interrupt
- * @mask: Interrupt register data
- *
- * Handles inbound message interrupts.  Executes a callback, if available,
- * on received message. Reports the Error.
- */
-static void  ib_dme_irq_handler(struct rio_irq_handler *h/*, u32 state*/)
-{
-	struct rio_priv *priv = h->data;
-	struct rio_mport *mport = priv->mport;
-	int mbox_no;
-	int letter;
-	u32 dme_mask, mask;
-ib_dme_restart:
-	axxia_local_config_read(priv, RAB_INTR_STAT_IDME, &dme_mask);
-	mask = dme_mask;
-	if (!mask)
-		return;
-	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mask);
-	/**
-	 * Inbound mbox has 4 engines, 1 per letter.
-	 * For each message engine that contributes to IRQ state,
-	 * go through all descriptors in queue that have been
-	 * written but not handled.
-	 */
-	while (dme_mask) {
-		struct rio_msg_dme *me;
-		u32 dme_stat;
-		int dme_no = __fls(dme_mask);
-
-		dme_mask ^= (1 << dme_no);
-		me = priv->ib_dme[dme_no];
-		/**
-		 * Get and clear latched state
-		 */
-		axxia_local_config_read(priv,
-					   RAB_IB_DME_STAT(dme_no), &dme_stat);
-		axxia_local_config_write(priv,
-					    RAB_IB_DME_STAT(dme_no), dme_stat);
-		if (!me)
-			continue;
-
-		mbox_no = me->mbox;
-		letter = me->letter;
-		if (!(dme_stat & 0xff))
-			continue;
-
-		if (dme_stat & (IB_DME_STAT_DESC_XFER_CPLT |
-				IB_DME_STAT_DESC_CHAIN_XFER_CPLT)) {
-			if (mport->inb_msg[mbox_no].mcback)
-				mport->inb_msg[mbox_no].mcback(mport,
-					me->dev_id, mbox_no, letter);
-		}
-
-		if (dme_stat & IB_DME_STAT_ERROR_MASK) {
-			if (dme_stat & (IB_DME_STAT_DESC_UPDATE_ERR |
-					IB_DME_STAT_DESC_ERR |
-					IB_DME_STAT_DESC_FETCH_ERR))
-				dev_err(priv->dev,
-				"IB Mbox%d Letter%d DME%d: Descriptor Error\n",
-						mbox_no, letter, dme_no);
-
-			if (dme_stat & IB_DME_STAT_DATA_TRANS_ERR)
-				dev_err(priv->dev,
-				"IB Mbox%d Letter%d DME%d: Transaction Error\n",
-						mbox_no, letter, dme_no);
-
-			if (dme_stat & IB_DME_STAT_MSG_ERR)
-				dev_err(priv->dev,
-				"IB MBOX%d Letter%d DME%d: Message Error\n",
-						mbox_no, letter, dme_no);
-
-			if (dme_stat & (IB_DME_STAT_MSG_TIMEOUT))
-				dev_err(priv->dev,
-				"IB MBOX%d Letter%d DME%d: SRIO Timeout\n",
-						mbox_no, letter, dme_no);
-		}
-
-	}
-	goto ib_dme_restart;
-}
-
-enum hrtimer_restart ib_dme_tmr_handler(struct hrtimer *hr)
-{
-	struct rio_rx_mbox *mb = container_of(hr, struct rio_rx_mbox, tmr);
-	struct rio_mport *mport = mb->mport;
-	struct rio_priv *priv = mport->priv;
-	int mbox_no;
-	int letter;
-	u32 dme_mask, mask;
-ib_dme_restart:
-	axxia_local_config_read(priv, RAB_INTR_STAT_IDME, &dme_mask);
-	dme_mask &= mb->irq_state_mask;
-	mask = dme_mask;
-	if (!mask) {
-		hrtimer_forward_now(&mb->tmr,
-				ktime_set(0, axxia_hrtimer_delay));
-		return HRTIMER_RESTART;
-	}
-	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mask);
-	/**
-	 * Inbound mbox has 4 engines, 1 per letter.
-	 * For each message engine that contributes to IRQ state,
-	 * go through all descriptors in queue that have been
-	 * written but not handled.
-	 */
-	while (dme_mask) {
-		struct rio_msg_dme *me;
-		u32 dme_stat;
-		int dme_no = __fls(dme_mask);
-
-		dme_mask ^= (1 << dme_no);
-		me = priv->ib_dme[dme_no];
-		/**
-		 * Get and clear latched state
-		 */
-		axxia_local_config_read(priv,
-					   RAB_IB_DME_STAT(dme_no), &dme_stat);
-		axxia_local_config_write(priv,
-					    RAB_IB_DME_STAT(dme_no), dme_stat);
-		if (!me)
-			continue;
-
-		mbox_no = me->mbox;
-		letter = me->letter;
-		if (!(dme_stat & 0xff))
-			continue;
-
-		if (dme_stat & (IB_DME_STAT_DESC_XFER_CPLT |
-				IB_DME_STAT_DESC_CHAIN_XFER_CPLT)) {
-			if (mport->inb_msg[mbox_no].mcback)
-				mport->inb_msg[mbox_no].mcback(mport,
-					me->dev_id, mbox_no, letter);
-		}
-
-		if (dme_stat & IB_DME_STAT_ERROR_MASK) {
-			if (dme_stat & (IB_DME_STAT_DESC_UPDATE_ERR |
-					IB_DME_STAT_DESC_ERR |
-					IB_DME_STAT_DESC_FETCH_ERR))
-				dev_err(priv->dev,
-				"IB Mbox%d Letter%d DME%d: Descriptor Error\n",
-						mbox_no, letter, dme_no);
-
-			if (dme_stat & IB_DME_STAT_DATA_TRANS_ERR)
-				dev_err(priv->dev,
-				"IB Mbox%d Letter%d DME%d: Transaction Error\n",
-						mbox_no, letter, dme_no);
-
-			if (dme_stat & IB_DME_STAT_MSG_ERR)
-				dev_err(priv->dev,
-				"IB MBOX%d Letter%d DME%d: Message Error\n",
-						mbox_no, letter, dme_no);
-
-			if (dme_stat & (IB_DME_STAT_MSG_TIMEOUT))
-				dev_err(priv->dev,
-				"IB MBOX%d Letter%d DME%d: SRIO Timeout\n",
-						mbox_no, letter, dme_no);
-		}
-
-	}
-	goto ib_dme_restart;
-}
-/**
- * open_inb_mbox - Initialize AXXIA inbound mailbox
- * @mport: Master port implementing the inbound message unit
- * @dev_id: Device specific pointer to pass on event
- * @mbox: Mailbox to open 0..(MID-1),
- *            0..3 multi segment,
- *            4..(MID-1) single segment
- * @entries: Number of entries in the inbound mailbox ring
- *
- * Initializes buffer ring.  Sets up desciptor ring and memory
- * for messages for all 4 letters in the mailbox.  [This means
- * that the actual descriptor requirements are "4 * entries".]
- *
- * Returns %0 on success and %-EINVAL or %-ENOMEM on failure.
- */
-static int open_inb_mbox(struct rio_mport *mport, void *dev_id,
-			 int mbox, int entries)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_irq_handler *h = NULL;
-	int i, letter;
-	int rc, buf_sz;
-	u32 irq_state_mask = 0;
-	u32 dme_ctrl;
-	struct rio_rx_mbox *mb;
-	int j;
-
-	if ((mbox < 0) || (mbox >= RIO_MAX_RX_MBOX))
-		return -EINVAL;
-
-	if ((entries < 2) || (entries > priv->desc_max_entries))
-		return -EINVAL;
-	h = &priv->ib_dme_irq;
-
-	if (priv->ib_mbox[mbox] != NULL)
-		return -EBUSY;
-
-	buf_sz = RIO_MBOX_TO_BUF_SIZE(mbox);
-
-	mb = kzalloc(sizeof(*mb), GFP_KERNEL);
-	if (!mb)
-		return -ENOMEM;
-	mb->mbox_no = mbox;
-
-	kref_init(&mb->kref);
-/* Adding 1 to entries to ensure the presence of invalid descriptor
- * in the circular buffer, to avoid the hardware getting into an
- * indefinite loop */
-	entries = entries+1;
-/* Rounding up to the power of two for efficient handling */
-	entries = roundup_pow_of_two(entries);
-	dev_dbg(priv->dev, "Opening inbound mbox %d with %d entries\n",
-							mbox, entries);
-	/**
-	 *  Initialize rx buffer ring
-	 */
-	mb->mport = mport;
-	mb->ring_size = entries;
-	for (i = 0; i < RIO_MSG_MAX_LETTER; i++) {
-		mb->virt_buffer[i] = kzalloc(mb->ring_size * sizeof(void *),
-								GFP_KERNEL);
-		if (!mb->virt_buffer[i]) {
-			kfree(mb);
-			return -ENOMEM;
-		}
-		mb->last_rx_slot[i] = 0;
-		mb->next_rx_slot[i] = 0;
-		for (j = 0; j < mb->ring_size; j++)
-			mb->virt_buffer[i][j] = NULL;
-	}
-
-	/**
-	 * Since we don't have the definition of letter in the generic
-	 * RIO layer, we set up IB mailboxes for all letters for each
-	 * mailbox.
-	 */
-	for (letter = 0; letter < RIO_MSG_MAX_LETTER; ++letter) {
-		int dme_no = 0;
-		struct rio_msg_dme *me = NULL;
-		struct rio_msg_desc *desc;
-		u32 dw0, dw1, dw2, dw3;
-		u64 desc_chn_start, desc_addr;
-		u32 dme_stat, wait = 0;
-		u32 buffer_size = (buf_sz > 256 ? 3 : 0);
-
-		/* Search for a free DME, so we can more efficiently map
-		 * them to the all of the mbox||letter combinations. */
-		for (i = 0, rc = -1;
-		     i < (priv->num_inb_dmes[0]+priv->num_inb_dmes[1]);
-		     i++) {
-			rc = check_dme(i, &priv->num_inb_dmes[0],
-				&priv->inb_dmes_in_use[0], &priv->inb_dmes[0]);
-			if (rc == 0) {
-				dme_no = i;
-				break;
-			}
-		}
-		if (rc < 0)
-			return rc;
-
-		me = alloc_message_engine(mport,
-					  dme_no,
-					  dev_id,
-					  buf_sz,
-					  entries);
-		if (IS_ERR(me)) {
-			rc = PTR_ERR(me);
-			goto err;
-		}
-
-		irq_state_mask |= (1 << dme_no);
-
-		do {
-			axxia_local_config_read(priv,
-						   RAB_IB_DME_STAT(me->dme_no),
-						   &dme_stat);
-			if (wait++ > 100) {
-				rc = -EBUSY;
-				goto err;
-			}
-		} while (dme_stat & IB_DME_STAT_TRANS_PEND);
-
-		mb->me[letter] = me;
-
-		dw0 = ((buffer_size & 0x3) << 4) |
-		      DME_DESC_DW0_EN_INT;
-			/*Valid bit will be set in add_inb_buffer*/
-
-		dw1 = DME_DESC_DW1_XMBOX(mbox) |
-		      DME_DESC_DW1_MBOX(mbox)  |
-		      DME_DESC_DW1_LETTER(letter);
-		dw3 = 0;		/* 0 means, next contiguous addr
-					 * Also next desc valid bit in dw0
-					 * must be zero. */
-		for (i = 0, desc = me->desc; i < entries; i++, desc++) {
-			if (!priv->intern_msg_desc) {
-				/* Reference AXX5500 Peripheral Subsystem
-				 * Multicore Reference Manual, January 2013,
-				 * Chapter 5, p. 584 */
-				if (axxia_rio_is_x9()) {
-					dw2 = (u32)(desc->msg_phys >> 8) &
-								0xc0000000;
-					dw2 = (dw2 >> 9);
-					dw1 |= dw2;
-				} else
-					dw1 |= 0;
-				dw2  = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
-				*((u32 *)DESC_TABLE_W0_MEM(me,
-						 i)) = dw0;
-				*((u32 *)DESC_TABLE_W1_MEM(me,
-						 i)) = dw1;
-				*((u32 *)DESC_TABLE_W2_MEM(me,
-						 i)) = dw2;
-				*((u32 *)DESC_TABLE_W3_MEM(me,
-						 i)) = dw3;
-			} else {
-				dw1 |= 0;
-				dw2  = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
-				__rio_local_write_config_32(mport,
-					DESC_TABLE_W0(me->dres.start+i), dw0);
-				__rio_local_write_config_32(mport,
-					DESC_TABLE_W1(me->dres.start+i), dw1);
-				__rio_local_write_config_32(mport,
-					DESC_TABLE_W2(me->dres.start+i), dw2);
-				__rio_local_write_config_32(mport,
-					DESC_TABLE_W3(me->dres.start+i), dw3);
-			}
-		}
-
-		/**
-		 * Last descriptor - make ring.
-		 * Next desc table entry -> dw2.First desc address[37:36].
-		 *                       -> dw3.First desc address[35:4].
-		 * (desc_base + 0x10 * nr)
-		 */
-		desc--; i--;
-		dw0 |= DME_DESC_DW0_NXT_DESC_VALID;
-		dw0 &= ~DME_DESC_DW0_VALID;
-		if (!priv->intern_msg_desc) {
-			desc_chn_start =
-				(uintptr_t)virt_to_phys(me->descriptors);
-			if (axxia_rio_is_x9()) {
-				dw1  = *((u32 *)DESC_TABLE_W1_MEM(me, i));
-				dw2  = (u32)(desc_chn_start >> 8) & 0xc0000000;
-				dw2  = (u32)(dw2 >> 11);
-				dw1 |= dw2;
-			}
-			dw2  = *((u32 *)DESC_TABLE_W2_MEM(me, i));
-			if (axxia_rio_is_x9())
-				dw2 |= (desc_chn_start >> 6) & 0xc0000000;
-			else
-				dw2 |= (desc_chn_start >> 4) & 0xc0000000;
-			dw3  = desc_chn_start >> 4;
-			*((u32 *)DESC_TABLE_W0_MEM(me, i)) = dw0;
-			if (axxia_rio_is_x9())
-				*((u32 *)DESC_TABLE_W1_MEM(me, i)) = dw1;
-			*((u32 *)DESC_TABLE_W2_MEM(me, i)) = dw2;
-			*((u32 *)DESC_TABLE_W3_MEM(me, i)) = dw3;
-		} else {
-			desc_chn_start = DESC_TABLE_W0(me->dres.start);
-
-			__rio_local_read_config_32(mport,
-					    DESC_TABLE_W2(me->dres.start+i),
-					    &dw2);
-			dw3  = 0;
-			dw2 |= ((desc_chn_start >> 8) & 0xc0000000);
-			__rio_local_write_config_32(mport,
-						DESC_TABLE_W0(me->dres.start+i),
-						dw0);
-			__rio_local_write_config_32(mport,
-						DESC_TABLE_W2(me->dres.start+i),
-						dw2);
-			__rio_local_write_config_32(mport,
-						DESC_TABLE_W3(me->dres.start+i),
-						dw3);
-		}
-
-		/**
-		 * Setup the DME including descriptor chain start address
-		 */
-		dme_ctrl = RAB_IB_DME_CTRL_XMBOX(mbox)    |
-			   RAB_IB_DME_CTRL_MBOX(mbox)     |
-			   RAB_IB_DME_CTRL_LETTER(letter) |
-			   DME_WAKEUP                     |
-			   DME_ENABLE;
-		dme_ctrl |= (u32)((desc_chn_start >> 6) & 0xc0000000);
-		if (axxia_rio_is_x9())
-			dme_ctrl |= (u32)((desc_chn_start >> 12) & 0x0c000000);
-		desc_addr  = (u32)desc_chn_start >> 4;
-
-		me->dme_ctrl = dme_ctrl;
-		me->letter = letter;
-		me->mbox = mbox;
-		priv->ib_dme[dme_no] = me;
-
-		axxia_local_config_write(priv,
-					RAB_IB_DME_DESC_ADDR(dme_no),
-					desc_addr);
-		axxia_local_config_write(priv,
-					RAB_IB_DME_CTRL(dme_no), dme_ctrl);
-
-#ifdef CONFIG_AXXIA_RIO_STAT
-		me->desc_done_count = 0;
-		me->desc_error_count = 0;
-		me->desc_rio_err_count = 0;
-		me->desc_axi_err_count = 0;
-		me->desc_tmo_err_count = 0;
-#endif
-		select_dme(dme_no, &priv->num_inb_dmes[0],
-			&priv->inb_dmes_in_use[0], &priv->inb_dmes[0], 1);
-	}
-
-	/**
-	* Create irq handler and enable MBOX irq
-	*/
-
-	mb->irq_state_mask = irq_state_mask;
-	h->irq_state_mask |= irq_state_mask;
-	priv->ib_mbox[mbox] = mb;
-	AXXIA_RIO_SYSMEM_BARRIER();
-	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, irq_state_mask);
-
-	if (priv->dme_mode == AXXIA_IBDME_TIMER_MODE) {
-		hrtimer_init(&mb->tmr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-		mb->tmr.function = ib_dme_tmr_handler;
-		hrtimer_start(&mb->tmr, ktime_set(0, (axxia_hrtimer_delay)),
-					HRTIMER_MODE_REL_PINNED);
-	} else
-		axxia_local_config_write(priv, RAB_INTR_ENAB_IDME,
-						h->irq_state_mask);
-	return 0;
-
-err:
-	mbox_put(mb);
-	return rc;
-}
-
-/**
- * release_inb_mbox - Close AXXIA inbound mailbox
- * @mport: Master port implementing the inbound message unit
- * @mbox: Mailbox to close
- *
- * Caller must hold RAB lock
- * Release all resources i.e. DMEs, descriptors, buffers, and so on.
- */
-
-static void release_inb_mbox(struct rio_irq_handler *h)
-{
-	struct rio_rx_mbox *mb = h->data;
-/*TODO*/
-	h->data = NULL;
-	mbox_put(mb);
-}
-
-void axxia_rio_port_get_state(struct rio_mport *mport, int cleanup)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 escsr, iecsr, state;
-
-	if (cleanup) {
-#if defined(CONFIG_AXXIA_RIO_STAT)
-		reset_state_counters(priv);
-#endif
-		/**
-		 * Clear latched state indications
-		 */
-		/* Miscellaneous Events */
-		axxia_local_config_read(priv, RAB_INTR_STAT_MISC, &state);
-		axxia_local_config_write(priv, RAB_INTR_STAT_MISC, state);
-		/* Outbound Message Engine */
-		axxia_local_config_read(priv, RAB_INTR_STAT_ODME, &state);
-		axxia_local_config_write(priv, RAB_INTR_STAT_ODME, state);
-		/* Inbound Message Engine */
-		axxia_local_config_read(priv, RAB_INTR_STAT_IDME, &state);
-		axxia_local_config_write(priv, RAB_INTR_STAT_IDME, state);
-		/* Axxi Bus to RIO Events */
-		axxia_local_config_read(priv, RAB_INTR_STAT_APIO, &state);
-		axxia_local_config_write(priv, RAB_INTR_STAT_APIO, state);
-		/* RIO to Axxia Bus Events */
-		axxia_local_config_read(priv, RAB_INTR_STAT_RPIO, &state);
-		axxia_local_config_write(priv, RAB_INTR_STAT_RPIO, state);
-	}
-
-	/* Master Port state */
-	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &escsr);
-	axxia_local_config_read(priv, EPC_IECSR(priv->port_ndx), &iecsr);
-
-	/* Adding I2E to preserve idle sequence select bit which is R/w */
-	axxia_local_config_write(priv, RIO_ESCSR(priv->port_ndx),
-				(escsr & (RIO_ESCSR_I2E | RIO_EXCSR_WOLR)));
-}
-
-/**
- * RIO MPORT Driver API
- */
-
-/**
- * axxia_rio_port_irq_enable - Register RIO interrupt handler
- *
- * @mport: master port
- * @irq: IRQ mapping from DTB
- *
- * Caller must hold RAB lock
- *
- * Returns:
- * 0        Success
- * <0       Failure
- */
-int axxia_rio_port_irq_enable(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	int rc;
-
-	priv->dme_mode = axxia_dme_tmr_mode[priv->ndx];
-	/**
-	 * Clean up history
-	 * from port reset/restart
-	 */
-	axxia_rio_port_get_state(mport, 1);
-	rc = alloc_irq_handler(&priv->misc_irq, priv, "rio-misc-db");
-	if (rc)
-		goto out;
-
-	__rio_local_write_config_32(mport, RAB_SRDS_CTRL1, 0x0);
-	__rio_local_write_config_32(mport, RAB_SRDS_CTRL2,
-					/*LINK_DOWN_TIMEOUT*/0x0);
-	rc = alloc_irq_handler(&priv->linkdown_irq, priv, "rio-ld");
-	if (rc)
-		goto err1;
-	rc = alloc_irq_handler(&priv->apio_irq, priv, "rio-apio");
-	if (rc)
-		goto err2;
-
-	rc = alloc_irq_handler(&priv->rpio_irq, priv, "rio-rpio");
-	if (rc)
-		goto err3;
-	priv->ib_dme_irq.data = priv;
-	priv->ob_dme_irq.data = priv;
-
-	if (priv->dme_mode == AXXIA_IBDME_INTERRUPT_MODE) {
-		rc = request_threaded_irq(priv->irq_line,
-				hw_irq_dme_handler, NULL,
-				IRQF_TRIGGER_NONE | IRQF_SHARED,
-				"rio-mb", (void *)priv);
-		if (rc)
-			goto err4;
-
-		axxia_local_config_write(priv, RAB_INTR_ENAB_GNRL,
-				    (RAB_INTR_ENAB_GNRL_SET | IB_DME_INT_EN));
-	} else
-		axxia_local_config_write(priv, RAB_INTR_ENAB_GNRL,
-				    RAB_INTR_ENAB_GNRL_SET);
-out:
-	return rc;
-err0:
-	dev_warn(priv->dev, "RIO: unable to request irq.\n");
-	goto out;
-err4:
-	release_irq_handler(&priv->rpio_irq);
-err3:
-	release_irq_handler(&priv->apio_irq);
-err2:
-	release_irq_handler(&priv->linkdown_irq);
-err1:
-	release_irq_handler(&priv->misc_irq);
-	goto err0;
-}
-
-void axxia_rio_port_irq_disable(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	/**
-	 * Mask top level IRQs
-	 */
-	axxia_local_config_write(priv, RAB_INTR_ENAB_GNRL, 0);
-	/**
-	 * free registered handlers
-	 */
-	release_irq_handler(&priv->misc_irq);
-	release_irq_handler(&priv->ob_dme_irq);
-	release_irq_handler(&priv->ib_dme_irq);
-	release_irq_handler(&priv->apio_irq);
-	release_irq_handler(&priv->rpio_irq);
-}
-
-int axxia_rio_pw_enable(struct rio_mport *mport, int enable)
-{
-	struct rio_priv *priv = mport->priv;
-	int rc = 0;
-
-	mutex_lock(&priv->api_lock);
-	if (enable)
-		rc = enable_pw(mport);
-	else
-		disable_pw(mport);
-	mutex_unlock(&priv->api_lock);
-
-	return rc;
-}
-
-/**
- * axxia_rio_doorbell_send - Send a doorbell message
- *
- * @mport: RapidIO master port info
- * @index: ID of RapidIO interface
- * @destid: Destination ID of target device
- * @data: 16-bit info field of RapidIO doorbell message
- *
- * Sends a doorbell message.
- *
- * Returns %0 on success or %-EINVAL on failure.
- *
- * API protected by spin lock in generic rio driver.
- */
-int axxia_rio_doorbell_send(struct rio_mport *mport,
-			    int index, u16 destid, u16 data)
-{
-	struct rio_priv *priv = mport->priv;
-	int db;
-	u32 csr;
-
-	for (db = 0; db < MAX_OB_DB; db++) {
-		axxia_local_config_read(priv, RAB_OB_DB_CSR(db), &csr);
-		if (OB_DB_STATUS(csr) == OB_DB_STATUS_DONE &&
-		    OB_DB_STATUS(csr) != OB_DB_STATUS_RETRY) {
-
-			csr = 0;
-			csr |= OB_DB_DEST_ID(destid);
-			csr |= OB_DB_PRIO(0x2); /* Good prio? */
-			csr |= OB_DB_SEND;
-			dev_dbg(priv->dev,
-			   "Send doorbell 0x%04x to destid 0x%x\n",
-				data, destid);
-			axxia_local_config_write(priv, RAB_OB_DB_INFO(db),
-						    OB_DB_INFO(data));
-			axxia_local_config_write(priv, RAB_OB_DB_CSR(db),
-						    csr);
-			break;
-		}
-	}
-	if (db == MAX_OB_DB)
-		return -EBUSY;
-
-	return 0;
-}
-
-/************/
-/* OUTBOUND */
-/************/
-/**
- * axxia_open_outb_mbox - Initialize AXXIA outbound mailbox
- * @mport: Master port implementing the outbound message unit
- * @dev_id: Device specific pointer to pass on event
- * @mbox_dme: Mailbox to open
- * @entries: Number of entries in the outbound DME/mailbox ring for
- *           each letter
- *
- * Allocates and initializes descriptors.
- * We have N (e.g. 3) outbound mailboxes and M (e.g. 1024) message
- * descriptors.  The message descriptors are usable by inbound and
- * outbound message queues, at least until the point of binding.
- * Allocation/Distribution of message descriptors is flexible and
- * not restricted in any way other than that they must be uniquely
- * assigned/coherent to each mailbox/DME.
- *
- * Allocate memory for messages.
- * Each descriptor can hold a message of up to 4kB, though certain
- * DMEs or mailboxes may impose further limits on the size of the
- * messages.
- *
- * Returns %0 on success and %-EINVAL or %-ENOMEM on failure.
- */
-int axxia_open_outb_mbox(
-	struct rio_mport *mport,
-	void *dev_id,
-	int mbox_dme,
-	int entries/*,
-	int prio*/)
-{
-	struct rio_priv *priv = mport->priv;
-	int rc = 0;
-
-	mutex_lock(&priv->api_lock);
-	rc = open_outb_mbox_static(mport, dev_id, mbox_dme,
-					entries, 0x0/*prio*/);
-	mutex_unlock(&priv->api_lock);
-
-	return rc;
-}
-
-/**
- * axxia_close_outb_mbox - Shut down AXXIA outbound mailbox
- *
- * @mport: Master port implementing the outbound message unit
- * @mbox_id: Mailbox to close
- *
- * Disables the outbound message unit, frees all buffers, and
- * frees any other resources.
- */
-void axxia_close_outb_mbox(struct rio_mport *mport, int mbox_id)
-{
-	struct rio_priv *priv = mport->priv;
-	int dme_no;
-	int wait_cnt = 0;
-	struct rio_msg_dme *me;
-	struct rio_tx_mbox *mb = NULL;
-
-
-	if ((mbox_id < 0) ||
-	    (mbox_id > RIO_MAX_TX_MBOX))
-		return;
-	mb = priv->ob_mbox[mbox_id];
-	if ((!mb) ||
-	    (!test_bit(RIO_MB_OPEN, &mb->state)))
-		return;
-	me = mb->me;
-
-	mutex_lock(&priv->api_lock);
-	clear_bit(RIO_MB_OPEN, &priv->ob_mbox[mbox_id]->state);
-	while (me->write_idx != me->read_idx) {
-		msleep(20);
-		wait_cnt++;
-		if (wait_cnt > 250)
-			break;
-	}
-	if (wait_cnt > 250)
-		pr_debug("Closed when outb mbox%d while transaction pending\n",
-								mbox_id);
-	priv->ob_mbox[mbox_id] = NULL;
-	dme_no = mb->dme_no;
-	mb->dme_no = 0xff;
-
-	priv->ob_dme_shared[dme_no].ring_size -=
-		mb->ring_size;
-
-	priv->ob_dme_shared[dme_no].ring_size_free +=
-		mb->ring_size;
-	mb->dev_id = NULL;
-	clear_bit(RIO_MB_MAPPED, &mb->state);
-	kfree(mb);
-	me->sz--;
-	if (!(me->sz))
-		hrtimer_cancel(&priv->ob_dme_shared[dme_no].tmr);
-	mutex_unlock(&priv->api_lock);
-}
-
-static inline struct rio_msg_desc *get_ob_desc(struct rio_mport *mport,
-						struct rio_msg_dme *mb)
-{
-	int desc_num = mb->write_idx;
-	struct rio_priv *priv = mport->priv;
-	struct rio_msg_desc *desc = &mb->desc[desc_num];
-	int nxt_write_idx = (mb->write_idx + 1) & (mb->entries - 1);
-	u32 dw0;
-
-	if (nxt_write_idx != mb->read_idx) {
-		dw0 = *((u32 *)DESC_TABLE_W0_MEM(mb, desc_num));
-		if (!(dw0 & DME_DESC_DW0_VALID))
-			return desc;
-		else
-			dev_err(priv->dev, "Tx Desc error %d\n", mb->write_idx);
-	}
-	return NULL;
-}
-
-/**
- * axxia_add_outb_message - Add message to the AXXIA outbound message queue
- * --- Called in net core soft IRQ with local interrupts masked ---
- * --- And spin locked in master port net device handler        ---
- *
- * @mport: Master port with outbound message queue
- * @rdev: Target of outbound message
- * @mbox_dest: Destination mailbox
- * @letter: TID letter
- * @flags: 3 bit field,Critical Request Field[2] | Prio[1:0]
- * @buffer: Message to add to outbound queue
- * @len: Length of message
- *
- * Adds the @buffer message to the AXXIA outbound message queue.
- * Returns %0 on success
- *         %-EBUSY  on temporarily unavailable resource failure e.g. such
- *                     as waiting for an open entry in the outbound DME
- *                     descriptor chain
- *         %-EAGAIN on another kind of temporarily unavailable resource
- *                     failure
- *         %-EINVAL on invalid argument failure.
- *         %-ENODEV on unavailable resource failure e.g. no outbound DME
- *                     open that matches the kind of destination mailbox
- *         %-ENXIO  on incompatible argument failure e.g. trying to open
- *                     a single-segment mbox when none are available on
- *                     the platform
- */
-int axxia_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
-			     int mbox_dest, int letter, int flags,
-			     void *buffer, size_t len/*, void *cookie*/)
-{
-	int rc = 0;
-	u32 dw0, dw1;
-	u16 destid = (rdev ? rdev->destid : mport->host_deviceid);
-	struct rio_priv *priv = mport->priv;
-	struct rio_tx_mbox *mb = priv->ob_mbox[mbox_dest];
-	struct rio_msg_dme *me;
-	struct rio_msg_desc *desc;
-	u32 dw2_r, dw2, dw0_r = 0, dw0_tmp;
-	u32 idx;
-	u32 seg;
-	u32 lock = 0;
-	u32 cp = 0;
-
-	if (!mb)
-		return -EINVAL;
-	me = mb->me;
-	if (me->sz > 1)
-		lock = 1;
-
-	/* Choose a free descriptor in a critical section */
-	if (lock)
-		spin_lock(&me->lock);
-	desc = get_ob_desc(mport, me);
-	if (!desc) {
-		rc = -EBUSY;
-		goto done;
-	}
-
-
-	/* Copy and clear rest of buffer */
-	if ((uintptr_t)buffer > PAGE_OFFSET) {
-		if ((uintptr_t)buffer & 0xFF) {
-			if (unlikely(desc->msg_virt == NULL)) {
-				rc = -ENXIO;
-				goto done;
-			}
-			memcpy(desc->msg_virt, buffer, len);
-			cp = 1;
-		}
-	} else {
-		if (copy_from_user(desc->msg_virt, buffer, len)) {
-			rc = -ENXIO;
-			goto done;
-		}
-		cp = 1;
-	}
-
-	dw0 = DME_DESC_DW0_SRC_DST_ID(destid) |
-	/*	DME_DESC_DW0_EN_INT|*/
-		DME_DESC_DW0_VALID;
-
-#if 0
-	if (!(me->write_idx % 4))
-		dw0 |=	DME_DESC_DW0_EN_INT;
-#endif
-	dw0 |= desc->last;/*DME_DESC_DW0_NXT_DESC_VALID;*/
-	seg = len;
-	if (seg < 256)
-		seg = 256;
-	seg = roundup_pow_of_two(seg) >> 7;
-	dw1 = DME_DESC_DW1_PRIO(flags) |
-		DME_DESC_DW1_CRF(flags) |
-		(fls(seg)<<18) |
-		DME_DESC_DW1_MSGLEN(len) |
-		DME_DESC_DW1_XMBOX(mbox_dest) |
-		DME_DESC_DW1_MBOX(mbox_dest) |
-		DME_DESC_DW1_LETTER(letter);
-	idx = me->write_idx;
-	if (axxia_rio_is_x9())
-		dw0_r  = *((u32 *)DESC_TABLE_W0_MEM(me, idx));
-	dw2_r  = *((u32 *)DESC_TABLE_W2_MEM(me, idx));
-	if (cp) {
-		if (axxia_rio_is_x9()) {
-			dw0_tmp = (u32)(desc->msg_phys >> 38) & 0x3;
-			dw0 |= (dw0_tmp << 12);
-		}
-		dw2 = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
-	} else {
-		if (axxia_rio_is_x9()) {
-			dw0_tmp = (u32)(virt_to_phys(buffer) >> 38) & 0x3;
-			dw0 |= (dw0_tmp << 12);
-		}
-		dw2 = (u32)(virt_to_phys(buffer) >> 8) & 0x3fffffff;
-	}
-	dw2 = (dw2_r & 0xc0000000) | dw2;
-	if (axxia_rio_is_x9())
-		dw0 |= (dw0_r & 0x0000c000);
-	me->write_idx = (me->write_idx+1) & (me->entries - 1);
-	*((u32 *)DESC_TABLE_W2_MEM(me, idx)) = dw2;
-	*((u32 *)DESC_TABLE_W1_MEM(me, idx)) = dw1;
-	AXXIA_RIO_SYSMEM_BARRIER();
-	*((u32 *)DESC_TABLE_W0_MEM(me, idx)) = dw0;
-
-	if (lock)
-		spin_unlock(&me->lock);
-	else
-		AXXIA_RIO_SYSMEM_BARRIER();
-	/* Start / Wake up - the stored state is used to avoid a Read */
-	axxia_local_config_write(priv, RAB_OB_DME_CTRL(me->dme_no),
-							me->dme_ctrl);
-
-#ifdef CONFIG_AXXIA_RIO_STAT
-	priv->ob_mbox[mbox_dest]->sent_msg_count++;
-#endif
-	return rc;
-done:
-	if (lock)
-		spin_unlock(&me->lock);
-	return rc;
-}
-
-int axxia_ml_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
-			     int mbox_dest, void *buffer, size_t len)
-{
-	return axxia_add_outb_message(mport, rdev, mbox_dest, 0, 0, buffer,
-						len/*, NULL*/);
-}
-
-/**
- * axxia_open_inb_mbox - Initialize AXXIA inbound mailbox
- * @mport: Master port implementing the inbound message unit
- * @dev_id: Device specific pointer to pass on event
- * @mbox: Mailbox to open
- * @entries: Number of entries in the inbound mailbox ring
- *
- * Initializes buffer ring.  Set up descriptor ring and memory
- * for messages for all letters in the mailbox.
- * Returns %0 on success and %-EINVAL or %-ENOMEM on failure.
- */
-int axxia_open_inb_mbox(struct rio_mport *mport, void *dev_id,
-			int mbox, int entries)
-{
-	struct rio_priv *priv = mport->priv;
-	int rc = 0;
-
-	mutex_lock(&priv->api_lock);
-	rc = open_inb_mbox(mport, dev_id, mbox, entries);
-	mutex_unlock(&priv->api_lock);
-
-	return rc;
-}
-
-/**
- * axxia_close_inb_mbox - Shut down AXXIA inbound mailbox
- * @mport: Master port implementing the inbound message unit
- * @mbox: Mailbox to close
- *
- * Disables the inbound message unit, free all buffers, and
- * frees resources.
- */
-void axxia_close_inb_mbox(struct rio_mport *mport, int mbox)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_rx_mbox *mb;
-	u32 letter;
-	u32 dme_stat;
-	u32 dme_no;
-
-	if ((mbox < 0) || (mbox >= RIO_MAX_RX_MBOX))
-		return;
-	mutex_lock(&priv->api_lock);
-	mb = priv->ib_mbox[mbox];
-	if (mb == NULL) {
-		mutex_unlock(&priv->api_lock);
-		return;
-	}
-	priv->ib_dme_irq.irq_state_mask &= ~(mb->irq_state_mask);
-	axxia_local_config_write(priv, RAB_INTR_ENAB_IDME,
-					priv->ib_dme_irq.irq_state_mask);
-	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mb->irq_state_mask);
-	msleep(500);
-	priv->ib_mbox[mbox] = NULL;
-	for (letter = 0; letter < RIO_MSG_MAX_LETTER; letter++) {
-		int wait = 0;
-
-		if (mb->me[letter]) {
-			dme_no = mb->me[letter]->dme_no;
-			do {
-				axxia_local_config_read(priv,
-					RAB_IB_DME_STAT(dme_no), &dme_stat);
-				if (wait++ > 10000)
-					break;
-			} while (dme_stat & IB_DME_STAT_TRANS_PEND);
-			if (wait > 10000)
-				dev_err(priv->dev,
-					"Closing while Transaction pending\n");
-			axxia_local_config_write(priv,
-					RAB_IB_DME_CTRL(dme_no), 0);
-		}
-	}
-	axxia_local_config_write(priv, RAB_INTR_STAT_IDME, mb->irq_state_mask);
-	mb->irq_state_mask = 0;
-	msleep(100);
-	if (priv->dme_mode == AXXIA_IBDME_TIMER_MODE)
-		hrtimer_cancel(&mb->tmr);
-	mbox_put(mb);
-	mutex_unlock(&priv->api_lock);
-}
-
-/**
- * axxia_add_inb_buffer - Add buffer to the AXXIA inbound message queue
- * @mport: Master port implementing the inbound message unit
- * @mbox: Inbound mailbox number
- * @buf: Buffer to add to inbound queue
- *
- * Adds the @buf buffer to the AXXIA inbound message queue.
- *
- * Returns %0 on success
- *         %-EINVAL on invalid argument failure.
- *         %-EBUSY  on temporarily unavailable resource failure e.g. such
- *                     as waiting for a filled entry in the inbound DME
- *                     descriptor chain
- */
-int axxia_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_rx_mbox *mb;
-	int rc = 0;
-	struct rio_msg_dme *me;
-	struct rio_msg_desc *desc;
-	u32 dw0, dw2, dw2_r, dw1 = 0, dw1_r;
-
-	mb = (priv->ib_mbox[mbox]);
-	if (!mb)
-		return -EINVAL;
-	me = mb->me[0];
-	/* Lockless circular buffer scheme */
-	if (((me->write_idx + 1) & (me->entries - 1)) == me->read_idx)
-		goto busy;
-	if (mb->virt_buffer[0][me->write_idx]) {
-		/* TODO Need to handle this case when DME encounters error */
-		goto busy;
-	}
-
-	dw0 = *((u32 *)DESC_TABLE_W0_MEM(me, me->write_idx));
-	if (dw0 & DME_DESC_DW0_VALID) {
-		dev_dbg(priv->dev, "Filling an already valid buffer %d %x\n",
-							 me->write_idx, dw0);
-		goto busy;
-	}
-	mb->virt_buffer[0][me->write_idx] = buf;
-	if (!((uintptr_t)buf & 0xFF)) {
-		if (axxia_rio_is_x9()) {
-			dw1_r = *((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx));
-			dw2 = (u32)(virt_to_phys(buf) >> 8) & 0xc0000000;
-			dw2 = (dw2 >> 9);
-			dw1 = dw1_r & 0xff9fffff;
-			dw1 |= dw2;
-		}
-		dw2_r = *((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx));
-		dw2 = (u32)(virt_to_phys(buf) >> 8) & 0x3fffffff;
-		dw2 = (dw2_r & 0xc0000000) | dw2;
-		*((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx)) = dw2;
-		if (axxia_rio_is_x9())
-			*((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx)) = dw1;
-	} else {
-		desc = &me->desc[me->write_idx];
-		if (axxia_rio_is_x9()) {
-			dw1_r = *((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx));
-			dw2 = (u32)(desc->msg_phys >> 8) & 0xc0000000;
-			dw2 = (dw2 >> 9);
-			dw1 = dw1_r & 0xff9fffff;
-			dw1 |= dw2;
-		}
-		dw2_r = *((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx));
-		dw2 = (u32)(desc->msg_phys >> 8) & 0x3fffffff;
-		dw2 = (dw2_r & 0xc0000000) | dw2;
-		*((u32 *)DESC_TABLE_W2_MEM(me, me->write_idx)) = dw2;
-		if (axxia_rio_is_x9())
-			*((u32 *)DESC_TABLE_W1_MEM(me, me->write_idx)) = dw1;
-	}
-
-	AXXIA_RIO_SYSMEM_BARRIER();
-	dw0 |= DME_DESC_DW0_VALID;
-	*((u32 *)DESC_TABLE_W0_MEM(me, me->write_idx)) = dw0;
-	AXXIA_RIO_SYSMEM_BARRIER();
-	me->write_idx = (me->write_idx + 1) & (me->entries - 1);
-/*	axxia_local_config_read(priv,
-		RAB_IB_DME_CTRL(me->dme_no), &dme_ctrl);
-	dme_ctrl |= (DME_WAKEUP | DME_ENABLE);*/
-	axxia_local_config_write(priv,
-		RAB_IB_DME_CTRL(me->dme_no), me->dme_ctrl);
-done:
-	return rc;
-busy:
-	rc = -EBUSY;
-	goto done;
-}
-
-/**
- * axxia_get_inb_message - Fetch an inbound message from the AXXIA
- *                         message unit
- * @mport: Master port implementing the inbound message unit
- * @mbox: Inbound mailbox number
- * @letter: Inbound mailbox letter
- * @sz: size of returned buffer
- *
- * Gets the next available inbound message from the inbound message queue.
- *
- * Returns pointer to the message on success
- *         NULL on nothing available
- *         IS_ERR(ptr) on failure with extra information
- */
-void *axxia_get_inb_message(struct rio_mport *mport, int mbox, int letter,
-			    int *sz/*, int *slot, u16 *destid*/)
-{
-	struct rio_priv *priv = mport->priv;
-	struct rio_rx_mbox *mb;
-	struct rio_msg_dme *me;
-	int num_proc = 0;
-	void *buf = NULL;
-	u32 idx;
-
-	mb = (priv->ib_mbox[mbox]);
-	if (!mb)
-		return NULL;
-	me = (mb->me[letter]);
-	while (1) {
-		struct rio_msg_desc *desc = &me->desc[me->read_idx];
-		u32 dw0, dw1;
-
-		idx = me->read_idx;
-		buf = NULL;
-		*sz = 0;
-		dw0 = *((u32 *)DESC_TABLE_W0_MEM(me, idx));
-		dw1 = *((u32 *)DESC_TABLE_W1_MEM(me, idx));
-		__dme_dw_dbg(priv->dev, me, 0, dw0, dw1);
-		if ((dw0 & DME_DESC_DW0_ERROR_MASK) &&
-		    (dw0 & DME_DESC_DW0_VALID)) {
-			*((u32 *)DESC_TABLE_W0_MEM(me, idx)) =
-					(dw0 & 0xff) | DME_DESC_DW0_VALID;
-/*TODO Need to check here: May need to keep it valid for nocopy case
- *Proper Error Handling and add_inb_buffer Required */
-			pr_err("Desc error %d\n", dw0);
-			me->read_idx = (me->read_idx + 1) & (me->entries - 1);
-			num_proc++;
-		} else if ((dw0 & DME_DESC_DW0_DONE) &&
-			   (dw0 & DME_DESC_DW0_VALID)) {
-			int seg, buf_sz;
-
-			AXXIA_RIO_SYSMEM_BARRIER();
-			seg = DME_DESC_DW1_MSGLEN_F(dw1);
-			buf_sz = DME_DESC_DW1_MSGLEN_B(seg);
-			buf = mb->virt_buffer[letter][me->read_idx];
-			if (!buf) {
-				dev_err(priv->dev, "Buffer Get Error\n");
-				goto err;
-			}
-
-			if ((uintptr_t)buf & 0xFF) {
-				AXXIA_RIO_SYSMEM_BARRIER();
-				memcpy(buf, desc->msg_virt, buf_sz);
-			}
-			mb->virt_buffer[letter][me->read_idx] = NULL;
-			*((u32 *)DESC_TABLE_W0_MEM(me, idx)) =
-					(dw0 & 0xfe);/*DME_DESC_INVALIDATE*/
-			*sz = buf_sz;
-
-			me->read_idx = (me->read_idx + 1) & (me->entries - 1);
-			num_proc++;
-			goto done;
-		} else {
-			goto done;
-		}
-	}
-
-done:
-	return buf;
-err:
-	buf = NULL;
-	goto done;
-}
-EXPORT_SYMBOL(axxia_get_inb_message);
-
-void *axxia_ml_get_inb_message(struct rio_mport *mport, int mbox)
-{
-	int sz;
-
-	return axxia_get_inb_message(mport, mbox, 0, &sz);
-}
-
-void axxia_rio_port_irq_init(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	int i;
-
-	/**
-	 * Port general error indications
-	 */
-	clear_bit(RIO_IRQ_ENABLED, &priv->misc_irq.state);
-	priv->misc_irq.irq_enab_reg_addr = RAB_INTR_ENAB_MISC;
-	priv->misc_irq.irq_state_reg_addr = RAB_INTR_STAT_MISC;
-	priv->misc_irq.irq_state_mask = AMST_INT | ASLV_INT |
-					LINK_REQ_INT;
-	priv->misc_irq.irq_state_mask |= IB_DB_RCV_INT |
-					OB_DB_DONE_INT;
-	priv->misc_irq.irq_state_mask |= PORT_WRITE_INT;
-	priv->misc_irq.irq_state_mask |=
-		GRIO_INT | LL_TL_INT |
-		UNSP_RIO_REQ_INT | UNEXP_MSG_INT;
-
-	priv->misc_irq.thrd_irq_fn = misc_irq_handler;
-	priv->misc_irq.data = NULL;
-	priv->misc_irq.release_fn = misc_release_handler;
-
-
-	/**
-	 * Deadman Monitor status interrupt
-	 */
-	clear_bit(RIO_IRQ_ENABLED, &priv->linkdown_irq.state);
-	priv->linkdown_irq.irq_enab_reg_addr = 0;
-	priv->linkdown_irq.irq_state_reg_addr = RAB_SRDS_STAT1;
-	priv->linkdown_irq.irq_state_mask = RAB_SRDS_STAT1_LINKDOWN_INT;
-	priv->linkdown_irq.thrd_irq_fn = linkdown_irq_handler;
-	priv->linkdown_irq.data = NULL;
-	priv->linkdown_irq.release_fn = NULL;
-
-	/**
-	 * Outbound messages
-	 */
-	clear_bit(RIO_IRQ_ENABLED, &priv->ob_dme_irq.state);
-	priv->ob_dme_irq.irq_enab_reg_addr = RAB_INTR_ENAB_ODME;
-	priv->ob_dme_irq.irq_state_reg_addr = RAB_INTR_STAT_ODME;
-	priv->ob_dme_irq.irq_state_mask = 0;
-/*	priv->ob_dme_irq.thrd_irq_fn = ob_dme_irq_handler;*/
-	priv->ob_dme_irq.data = NULL;
-	priv->ob_dme_irq.release_fn = release_outb_dme;
-
-	for (i = 0; i < RIO_MAX_TX_MBOX; i++)
-		priv->ob_mbox[i] = NULL;
-
-/* Pre-Allocating the Outbound DME Descriptors*/
-	i = roundup_pow_of_two(OB_DME_ENTRIES);
-	pr_info("RIO: Configuring each outbound DME with %d entries\n", i);
-/* MultiSegment DME*/
-	for (i = 0; i < priv->num_outb_dmes[0]; i++)
-		alloc_ob_dme_shared(priv, &priv->ob_dme_shared[i], i);
-/* SingleSegment DME*/
-	for (i = priv->num_outb_dmes[0];
-		i < priv->num_outb_dmes[0] + priv->num_outb_dmes[1]; i++) {
-		alloc_ob_dme_shared(priv, &priv->ob_dme_shared[i], i);
-	}
-
-	/**
-	 * Inbound messages
-	 */
-	clear_bit(RIO_IRQ_ENABLED, &priv->ib_dme_irq.state);
-	priv->ib_dme_irq.irq_enab_reg_addr = RAB_INTR_ENAB_IDME;
-	priv->ib_dme_irq.irq_state_reg_addr = RAB_INTR_STAT_IDME;
-	priv->ib_dme_irq.irq_state_mask = 0x0;/*IB_DME_INT_EN;*/
-	priv->ib_dme_irq.thrd_irq_fn = ib_dme_irq_handler;
-	priv->ib_dme_irq.data = NULL;
-	priv->ib_dme_irq.release_fn = release_inb_mbox;
-
-	for (i = 0; i < DME_MAX_IB_ENGINES; i++)
-		priv->ib_dme[i] = NULL;
-
-	for (i = 0; i < RIO_MAX_RX_MBOX; i++)
-		priv->ib_mbox[i] = NULL;
-	/**
-	 * PIO
-	 * Only when debug config
-	 */
-	clear_bit(RIO_IRQ_ENABLED, &priv->apio_irq.state);
-/*	priv->apio_irq.mport = mport;*/
-	priv->apio_irq.irq_enab_reg_addr = RAB_INTR_ENAB_APIO;
-	priv->apio_irq.irq_state_reg_addr = RAB_INTR_STAT_APIO;
-	priv->apio_irq.irq_state_mask = APIO_TRANS_FAILED;
-#ifdef CONFIG_AXXIA_RIO_STAT
-	priv->apio_irq.irq_state_mask |= APIO_TRANS_COMPLETE;
-#endif
-	priv->apio_irq.thrd_irq_fn = apio_irq_handler;
-	priv->apio_irq.data = NULL;
-	priv->apio_irq.release_fn = NULL;
-
-	clear_bit(RIO_IRQ_ENABLED, &priv->rpio_irq.state);
-	priv->rpio_irq.irq_enab_reg_addr = RAB_INTR_ENAB_RPIO;
-	priv->rpio_irq.irq_state_reg_addr = RAB_INTR_STAT_RPIO;
-	priv->rpio_irq.irq_state_mask = RPIO_TRANS_FAILED;
-#ifdef CONFIG_AXXIA_RIO_STAT
-	priv->rpio_irq.irq_state_mask |= RPIO_TRANS_COMPLETE;
-#endif
-	priv->rpio_irq.irq_state_mask = 0;
-	priv->rpio_irq.thrd_irq_fn = rpio_irq_handler;
-	priv->rpio_irq.data = NULL;
-	priv->rpio_irq.release_fn = NULL;
-
-}
-
-#if defined(CONFIG_RAPIDIO_HOTPLUG)
-int axxia_rio_port_notify_cb(struct rio_mport *mport,
-			       int enable,
-			       void (*cb)(struct rio_mport *mport))
-{
-	struct rio_priv *priv = mport->priv;
-	unsigned long flags;
-	int rc = 0;
-
-	spin_lock_irqsave(&priv->port_lock, flags);
-	if (enable) {
-		if (priv->port_notify_cb)
-			rc = -EBUSY;
-		else
-			priv->port_notify_cb = cb;
-	} else {
-		if (priv->port_notify_cb != cb)
-			rc = -EINVAL;
-		else
-			priv->port_notify_cb = NULL;
-	}
-	spin_unlock_irqrestore(&priv->port_lock, flags);
-
-	return rc;
-}
-
-int axxia_rio_port_op_state(struct rio_mport *mport)
-{
-	u32 escsr;
-
-	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &escsr);
-
-	if (escsr & RIO_ESCSR_PO)
-		return MPORT_STATE_OPERATIONAL;
-	else
-		return MPORT_STATE_DOWN;
-}
-#endif
diff --git a/drivers/rapidio/devices/lsi/axxia-rio-irq.h b/drivers/rapidio/devices/lsi/axxia-rio-irq.h
deleted file mode 100644
index eea9307..0000000
--- a/drivers/rapidio/devices/lsi/axxia-rio-irq.h
+++ /dev/null
@@ -1,211 +0,0 @@
-#ifndef __AXXIA_RIO_IRQ_H__
-#define __AXXIA_RIO_IRQ_H__
-
-/**************************sRIO SERDES *****************************/
-#define SRIO_PHY_CONTROL0_OFFSET        (0x200)
-#define APB2SER_SRIO_PHY0_CFG_OFFSET    (0x1e0)
-#define SERDES_CMD0_OFFSET              (0x0)
-#define SERDES_CMD1_OFFSET              (0x4)
-#define SERDES_READDATA0_OFFSET         (0x8)
-#define SERDES_READDATA1_OFFSET         (0xc)
-
-#define SERDES_CMD1_VALID_SHIFT         (31)
-#define SERDES_CMD1_HWRITE_SHIFT        (30)
-#define SERDES_CMD1_TSHIFT_SHIFT        (26)
-#define SERDES_CMD1_HSZIE_SHIFT         (23)
-#define SERDES_CMD1_HTRANS_SHIFT        (21)
-#define SERDES_CMD1_HADDR_MASK          (0xFFFF)
-
-#define SERDES_READDATA1_TMO_SHIFT       (2)
-#define SERDES_READDATA1_HRESP_MASK     (0x3)
-/******************************************************************/
-
-/* forward declaration */
-struct rio_priv;
-
-#define RIO_MSG_MAX_OB_MBOX_MULTI_ENTRIES  15
-#define RIO_MSG_MULTI_SIZE                 0x1000 /* 4Kb */
-#define RIO_MSG_SEG_SIZE                   0x0100 /* 256B */
-#define RIO_MSG_MAX_MSG_SIZE               RIO_MSG_MULTI_SIZE
-#define RIO_MSG_MAX_ENTRIES                1024   /* Default Max descriptor
-						     table entries for internal
-						     descriptor builds */
-#define	RIO_MBOX_TO_IDX(mid)		\
-	((mid <= RIO_MAX_RX_MBOX_4KB) ? 0 : 1)
-#define	RIO_MBOX_TO_BUF_SIZE(mid)		\
-	((mid <= RIO_MAX_RX_MBOX_4KB) ? RIO_MSG_MULTI_SIZE : RIO_MSG_SEG_SIZE)
-#define	RIO_OUTB_DME_TO_BUF_SIZE(p, did)	\
-	((did < p->num_outb_dmes[0]) ? RIO_MSG_MULTI_SIZE : RIO_MSG_SEG_SIZE)
-
-#define DME_MAX_IB_ENGINES          32
-#define     RIO_MAX_IB_DME_MSEG		32
-#define     RIO_MAX_IB_DME_SSEG	        0
-#define DME_MAX_OB_ENGINES          3
-#define     RIO_MAX_OB_DME_MSEG		2
-#define     RIO_MAX_OB_DME_SSEG	        1
-
-#define RIO_MAX_TX_MBOX             64
-#define     RIO_MAX_TX_MBOX_4KB		3
-#define     RIO_MAX_TX_MBOX_256B	63
-#define RIO_MAX_RX_MBOX             64
-#define     RIO_MAX_RX_MBOX_4KB		3
-#define     RIO_MAX_RX_MBOX_256B	63
-
-#define RIO_MSG_MAX_LETTER          4
-
-
-#define RIO_DESC_USED 0		/* Bit index for rio_msg_desc.state */
-
-struct rio_msg_desc {
-/*	unsigned long state;*/
-/*	int desc_no;*/
-	void __iomem *msg_virt;
-	dma_addr_t msg_phys;
-	int last;
-};
-
-struct rio_msg_dme {
-	spinlock_t lock;
-	unsigned long state;
-	struct kref kref;
-	struct rio_priv *priv;
-	struct resource dres;
-	int sz;
-	int entries;
-	int write_idx;
-	int read_idx;
-	int tx_dme_tmo;
-	void *dev_id;
-	int dme_no;
-	int mbox;
-	int letter;
-	u32 dme_ctrl;
-	struct rio_msg_desc *desc;
-	struct rio_desc *descriptors;
-
-#ifdef CONFIG_AXXIA_RIO_STAT
-	unsigned int desc_done_count;
-	unsigned int desc_error_count;
-	unsigned int desc_rio_err_count;
-	unsigned int desc_axi_err_count;
-	unsigned int desc_tmo_err_count;
-#endif
-} ____cacheline_internodealigned_in_smp;
-
-struct rio_rx_mbox {
-	spinlock_t lock;
-	unsigned long state;
-	int mbox_no;
-	struct kref kref;
-	struct rio_mport *mport;
-	void **virt_buffer[RIO_MSG_MAX_LETTER];
-	int last_rx_slot[RIO_MSG_MAX_LETTER];
-	int next_rx_slot[RIO_MSG_MAX_LETTER];
-	int ring_size;
-	struct rio_msg_dme *me[RIO_MSG_MAX_LETTER];
-	unsigned int irq_state_mask;
-	struct hrtimer tmr;
-};
-
-struct rio_tx_mbox {
-	spinlock_t lock;
-	unsigned long state;
-	struct rio_mport *mport;
-	int mbox_no;
-	int dme_no;
-	int ring_size;
-	struct rio_msg_dme *me;
-	void *dev_id;
-	int tx_slot;
-#ifdef CONFIG_AXXIA_RIO_STAT
-	unsigned int sent_msg_count;
-	unsigned int compl_msg_count;
-#endif
-} ____cacheline_internodealigned_in_smp;
-
-struct rio_tx_dme {
-	int	ring_size;
-	int	ring_size_free;
-	struct rio_msg_dme *me;
-	struct hrtimer tmr;
-};
-
-#define PW_MSG_WORDS (RIO_PW_MSG_SIZE/sizeof(u32))
-
-struct rio_pw_irq {
-	/* Port Write */
-	u32 discard_count;
-	u32 msg_count;
-	u32 msg_wc;
-	u32 msg_buffer[PW_MSG_WORDS];
-};
-
-#define RIO_IRQ_ENABLED 0
-#define RIO_IRQ_ACTIVE  1
-
-#define RIO_DME_MAPPED  1
-#define RIO_DME_OPEN    0
-
-#define RIO_MB_OPEN	0
-#define RIO_MB_MAPPED	1
-
-struct rio_irq_handler {
-	unsigned long state;
-/*	struct rio_mport *mport;*/
-	u32 irq_enab_reg_addr;
-	u32 irq_state_reg_addr;
-	u32 irq_state_mask;
-	void (*thrd_irq_fn)(struct rio_irq_handler *h/*, u32 state*/);
-	void (*release_fn)(struct rio_irq_handler *h);
-	void *data;
-};
-
-extern unsigned int axxia_hrtimer_delay;
-/**********************************************/
-/* *********** External Functions *********** */
-/**********************************************/
-
-void axxia_rio_port_irq_init(struct rio_mport *mport);
-void *axxia_get_inb_message(struct rio_mport *mport, int mbox, int letter,
-			      int *sz/*, int *slot, u16 *destid*/);
-int axxia_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf);
-void axxia_close_inb_mbox(struct rio_mport *mport, int mbox);
-int axxia_open_inb_mbox(struct rio_mport *mport, void *dev_id,
-			  int mbox, int entries);
-int axxia_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
-			     int mbox_dest, int letter, int flags,
-			     void *buffer, size_t len/*, void *cookie*/);
-void axxia_close_outb_mbox(struct rio_mport *mport, int mbox_id);
-int axxia_open_outb_mbox(struct rio_mport *mport, void *dev_id, int mbox_id,
-			 int entries/*, int prio*/);
-int axxia_rio_doorbell_send(struct rio_mport *mport,
-			      int index, u16 destid, u16 data);
-int axxia_rio_pw_enable(struct rio_mport *mport, int enable);
-void axxia_rio_port_get_state(struct rio_mport *mport, int cleanup);
-int axxia_rio_port_irq_enable(struct rio_mport *mport);
-void axxia_rio_port_irq_disable(struct rio_mport *mport);
-
-int axxia_ml_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
-			     int mbox_dest, void *buffer, size_t len);
-void *axxia_ml_get_inb_message(struct rio_mport *mport, int mbox);
-int alloc_irq_handler(
-	struct rio_irq_handler *h,
-	void *data,
-	const char *name);
-
-void release_mbox_resources(struct rio_priv *priv, int mbox_id);
-void release_irq_handler(struct rio_irq_handler *h);
-void db_irq_handler(struct rio_irq_handler *h, u32 state);
-extern int axxia_rio_init_sysfs(struct platform_device *dev);
-extern void axxia_rio_release_sysfs(struct platform_device *dev);
-
-#if defined(CONFIG_RAPIDIO_HOTPLUG)
-
-int axxia_rio_port_notify_cb(struct rio_mport *mport,
-			       int enable,
-			       void (*cb)(struct rio_mport *mport));
-int axxia_rio_port_op_state(struct rio_mport *mport);
-
-#endif
-
-#endif /* __AXXIA_RIO_IRQ_H__ */
diff --git a/drivers/rapidio/devices/lsi/axxia-rio-sysfs.c b/drivers/rapidio/devices/lsi/axxia-rio-sysfs.c
deleted file mode 100644
index 200ad9f..0000000
--- a/drivers/rapidio/devices/lsi/axxia-rio-sysfs.c
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program.
- */
-
-/* #define DEBUG */
-/* #define IO_OPERATIONS */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/device.h>
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-
-#include "axxia-rio.h"
-#include "axxia-rio-irq.h"
-
-static ssize_t axxia_rio_stat_show(struct device *dev,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	char *str = buf;
-	u32 reg_val = 0;
-
-	if (priv->devid  == AXXIA_DEVID_AXM55XX) {
-		str += sprintf(str, "AXM 55xx sRIO Controller");
-		switch (priv->devrev) {
-		case AXXIA_DEVREV_AXM55XX_V1_0:
-			str += sprintf(str, "Revision 0\n");
-			break;
-		case AXXIA_DEVREV_AXM55XX_V1_1:
-			str += sprintf(str, "Revision 1\n");
-			break;
-		case AXXIA_DEVREV_AXM55XX_V1_2:
-			str += sprintf(str, "Revision 2\n");
-			break;
-		default:
-			str += sprintf(str, "Revision Unknown\n");
-			break;
-		}
-	}
-
-	axxia_rio_port_get_state(mport, 0);
-	str += sprintf(str, "Master Port state:\n");
-	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &reg_val);
-	str += sprintf(str, "ESCSR (0x158) : 0x%08x\n", reg_val);
-	return str - buf;
-}
-static DEVICE_ATTR(stat, S_IRUGO, axxia_rio_stat_show, NULL);
-
-static ssize_t axxia_rio_misc_stat_show(struct device *dev,
-				    struct device_attribute *attr,
-				    char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	char *str = buf;
-
-	str += sprintf(str, "RIO PIO Stat:\n");
-	str += sprintf(str, "\t Successful Count: %d\n",
-					priv->rpio_compl_count);
-	str += sprintf(str, "\t Failed Count    : %d\n",
-					priv->rpio_compl_count);
-
-	str += sprintf(str, "AXI PIO Stat:\n");
-	str += sprintf(str, "\t Successful Count: %d\n",
-					priv->apio_compl_count);
-	str += sprintf(str, "\t Failed Count    : %d\n",
-					priv->apio_compl_count);
-
-	str += sprintf(str, "Port Write Stat:\n");
-	str += sprintf(str, "\t Interrupt Count : %d\n", priv->rio_pw_count);
-	str += sprintf(str, "\t Message Count   : %d\n",
-					priv->rio_pw_msg_count);
-
-	return str - buf;
-
-}
-static DEVICE_ATTR(misc_stat, S_IRUGO,
-		   axxia_rio_misc_stat_show, NULL);
-static ssize_t axxia_rio_ib_dme_show(struct device *dev,
-				    struct device_attribute *attr,
-				    char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	char *str = buf;
-	int e, j;
-	struct rio_rx_mbox *mb;
-	struct rio_msg_dme *me;
-
-	str += sprintf(str, "Inbound Mailbox (DME) counters:\n");
-	for (e = 0; e < RIO_MAX_RX_MBOX; e++) {
-		mb = priv->ib_mbox[e];
-		if (mb) {
-			for (j = 0; j < RIO_MSG_MAX_LETTER; j++) {
-				me = mb->me[j];
-				str += sprintf(str,
-					"Mbox %d Letter %d DME %d\n",
-					 mb->mbox_no, j, me->dme_no);
-				str += sprintf(str,
-					"\tNumber of Desc Done  : %d\n",
-					me->desc_done_count);
-				str += sprintf(str,
-					"\tNumber of Desc Errors: %d\n",
-					me->desc_error_count);
-				str += sprintf(str,
-					"\t\tRIO Error    : %d\n",
-					me->desc_rio_err_count);
-				str += sprintf(str,
-					"\t\tAXI Error    : %d\n",
-					me->desc_axi_err_count);
-				str += sprintf(str,
-					"\t\tTimeout Error: %d\n",
-					me->desc_tmo_err_count);
-			}
-		}
-	}
-	return str - buf;
-}
-static DEVICE_ATTR(ib_dme_stat, S_IRUGO,
-		   axxia_rio_ib_dme_show, NULL);
-
-static ssize_t axxia_rio_ob_dme_show(struct device *dev,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	char *str = buf;
-	int e;
-	struct rio_msg_dme *me;
-	struct rio_tx_mbox *mb;
-
-	str += sprintf(str, "Outbound Message Engine Counters:\n");
-	for (e = 0; e < DME_MAX_OB_ENGINES; e++) {
-		me = priv->ob_dme_shared[e].me;
-		if (me) {
-			str += sprintf(str, "DME %d Enabled\n", e);
-			str += sprintf(str, "\tNumber of Desc Done  : %d\n",
-					me->desc_done_count);
-			str += sprintf(str, "\tNumber of Desc Errors: %d\n",
-					me->desc_error_count);
-			str += sprintf(str, "\t\tRIO Error    : %d\n",
-					me->desc_rio_err_count);
-			str += sprintf(str, "\t\tAXI Error    : %d\n",
-					me->desc_axi_err_count);
-			str += sprintf(str, "\t\tTimeout Error: %d\n",
-					me->desc_tmo_err_count);
-		} else
-			str += sprintf(str, "DME %d Disabled\n", e);
-	}
-	str += sprintf(str, "*********************************\n");
-	str += sprintf(str, "Outbound Mbox stats\n");
-	for (e = 0; e < RIO_MAX_TX_MBOX; e++) {
-		mb = priv->ob_mbox[e];
-		if (!mb)
-			continue;
-		if ((mb->sent_msg_count) || (mb->compl_msg_count)) {
-			if (test_bit(RIO_DME_OPEN, &mb->state))
-				str += sprintf(str, "Mailbox %d: DME %d\n",
-							e, mb->dme_no);
-			else
-				str += sprintf(str, "Mailbox %d : Closed\n",
-							e);
-			str += sprintf(str, "\tMessages sent     : %d\n",
-						mb->sent_msg_count);
-			str += sprintf(str, "\tMessages Completed: %d\n",
-						mb->compl_msg_count);
-		}
-	}
-
-	return str - buf;
-}
-static DEVICE_ATTR(ob_dme_stat, S_IRUGO,
-		   axxia_rio_ob_dme_show, NULL);
-
-static ssize_t axxia_rio_irq_show(struct device *dev,
-				struct device_attribute *attr,
-				char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	u32 stat;
-	char *str = buf;
-
-	str += sprintf(str, "Interrupt enable bits:\n");
-	axxia_local_config_read(priv, RAB_INTR_ENAB_GNRL, &stat);
-	str += sprintf(str, "General Interrupt Enable (%p)\t%8.8x\n",
-		       (void *)RAB_INTR_ENAB_GNRL, stat);
-	axxia_local_config_read(priv, RAB_INTR_ENAB_ODME, &stat);
-	str += sprintf(str, "Outbound Message Engine  (%p)\t%8.8x\n",
-		       (void *)RAB_INTR_ENAB_ODME, stat);
-	axxia_local_config_read(priv, RAB_INTR_ENAB_IDME, &stat);
-	str += sprintf(str, "Inbound Message Engine   (%p)\t%8.8x\n",
-		       (void *)RAB_INTR_ENAB_IDME, stat);
-	axxia_local_config_read(priv, RAB_INTR_ENAB_MISC, &stat);
-	str += sprintf(str, "Miscellaneous Events     (%p)\t%8.8x\n",
-		       (void *)RAB_INTR_ENAB_MISC, stat);
-	axxia_local_config_read(priv, RAB_INTR_ENAB_APIO, &stat);
-	str += sprintf(str, "Axxia Bus to RIO Events  (%p)\t%8.8x\n",
-		       (void *)RAB_INTR_ENAB_APIO, stat);
-	axxia_local_config_read(priv, RAB_INTR_ENAB_RPIO, &stat);
-	str += sprintf(str, "RIO to Axxia Bus Events  (%p)\t%8.8x\n",
-		       (void *)RAB_INTR_ENAB_RPIO, stat);
-
-	str += sprintf(str, "OBDME : in Timer Mode, Period %9.9d nanosecond\n",
-			axxia_hrtimer_delay);
-	str += sprintf(str, "IBDME : ");
-	if (priv->dme_mode == AXXIA_IBDME_TIMER_MODE)
-		str += sprintf(str, "in Timer Mode, Period %9.9d nanosecond\n",
-			axxia_hrtimer_delay);
-	else
-		str += sprintf(str, "in Interrupt Mode\n");
-	return str - buf;
-}
-static DEVICE_ATTR(irq, S_IRUGO, axxia_rio_irq_show, NULL);
-
-static ssize_t axxia_rio_tmo_show(struct device *dev,
-				struct device_attribute *attr,
-				char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	u32 stat;
-	char *str = buf;
-
-	str += sprintf(str, "Port Link Timeout Control Registers:\n");
-	axxia_local_config_read(priv, RIO_PLTOCCSR, &stat);
-	str += sprintf(str, "PLTOCCSR (%p)\t%8.8x\n",
-		       (void *)RIO_PLTOCCSR, stat);
-	axxia_local_config_read(priv, RIO_PRTOCCSR, &stat);
-	str += sprintf(str, "PRTOCCSR (%p)\t%8.8x\n",
-		       (void *)RIO_PRTOCCSR, stat);
-	axxia_local_config_read(priv, RAB_STAT, &stat);
-	str += sprintf(str, "RAB_STAT (%p)\t%8.8x\n",
-		       (void *)RAB_STAT, stat);
-	axxia_local_config_read(priv, RAB_APIO_STAT, &stat);
-	str += sprintf(str, "RAB_APIO_STAT (%p)\t%8.8x\n",
-		       (void *)RAB_APIO_STAT, stat);
-	axxia_local_config_read(priv, RIO_ESCSR(priv->port_ndx), &stat);
-	str += sprintf(str, "PNESCSR (%d)\t%8.8x\n",
-		       RIO_ESCSR(priv->port_ndx), stat);
-
-	return str - buf;
-}
-static DEVICE_ATTR(tmo, S_IRUGO, axxia_rio_tmo_show, NULL);
-
-static ssize_t axxia_ib_dme_log_show(struct device *dev,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	struct rio_mport *mport = dev_get_drvdata(dev);
-	struct rio_priv *priv = mport->priv;
-	u32 stat, log;
-	char *str = buf;
-
-	axxia_local_config_read(priv, RAB_INTR_STAT_MISC, &stat);
-	log = (stat & UNEXP_MSG_LOG) >> 24;
-	str += sprintf(str, "mbox[1:0]   %x\n", (log & 0xc0) >> 6);
-	str += sprintf(str, "letter[1:0] %x\n", (log & 0x30) >> 4);
-	str += sprintf(str, "xmbox[3:0] %x\n", log & 0x0f);
-
-	return str - buf;
-}
-static DEVICE_ATTR(dme_log, S_IRUGO, axxia_ib_dme_log_show, NULL);
-
-static struct attribute *rio_attributes[] = {
-	&dev_attr_stat.attr,
-	&dev_attr_irq.attr,
-	&dev_attr_misc_stat.attr,
-	&dev_attr_ob_dme_stat.attr,
-	&dev_attr_ib_dme_stat.attr,
-	&dev_attr_tmo.attr,
-	&dev_attr_dme_log.attr,
-	NULL
-};
-
-static struct attribute_group rio_attribute_group = {
-	.name = NULL,
-	.attrs = rio_attributes,
-};
-
-int axxia_rio_init_sysfs(struct platform_device *dev)
-{
-	return sysfs_create_group(&dev->dev.kobj, &rio_attribute_group);
-}
-void axxia_rio_release_sysfs(struct platform_device *dev)
-{
-	sysfs_remove_group(&dev->dev.kobj, &rio_attribute_group);
-}
diff --git a/drivers/rapidio/devices/lsi/axxia-rio.c b/drivers/rapidio/devices/lsi/axxia-rio.c
deleted file mode 100644
index 0ca3a95..0000000
--- a/drivers/rapidio/devices/lsi/axxia-rio.c
+++ /dev/null
@@ -1,1885 +0,0 @@
-/*
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program.
- */
-
-/* #define IODEBUG */
-/* #define EXTRA1DEBUG */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/of_platform.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/kfifo.h>
-#include <linux/dmapool.h>
-#include <linux/of_irq.h>
-#include <linux/of_address.h>
-#include <linux/io.h>
-#include <linux/uaccess.h>
-#include <linux/lsi-ncr.h>
-
-#include "axxia-rio.h"
-#include "axxia-rio-irq.h"
-
-#define USE_DME_TIMEOUT
-static DEFINE_SPINLOCK(rio_io_lock);
-
-#ifdef IODEBUG
-#define	IODP(...)	pr_info(__VA_ARGS__)
-#else
-#define	IODP(...)
-#endif
-
-#ifdef EXTRA1DEBUG
-#define	EXT1P(...)	pr_info(__VA_ARGS__)
-#else
-#define	EXT1P(...)
-#endif
-
-#define RIO_IO_READ_HOME        0x00
-#define RIO_MAINT_READ          0x01
-#define RIO_MAINT_WRITE         0x10
-#define RIO_NREAD               0x02
-#define RIO_NWRITE              0x20
-#define RIO_NWRITE_R            0x40
-#define RIO_SWRITE              0x80
-
-#define RIO_PHY_PARALLEL        0x00
-#define RIO_PHY_SERIAL          0x01
-
-int
-axxia_rio_is_x9(void)
-{
-	if (of_find_compatible_node(NULL, NULL, "lsi,axm5616"))
-		return 1;
-
-	return 0;
-}
-
-/**
- * axxia_rapidio_board_init -
- *   Perform board-/controller-specific initialization to support
- *   use of RapidIO busses
- *
- * @dev:     [IN] RIO platform device
- * @ndx:     [IN] Which instance of SRIOC driver needs support
- * @port_ndx: [OUT] Which port to use for the specified controller
- *
- * Returns 0 on success or an error code.
- */
-int
-axxia_rapidio_board_init(struct platform_device *dev, int dev_num,
-						int *port_ndx)
-{
-	void __iomem *gpreg_base;
-	unsigned long reg0, reg1;
-	unsigned long reg = 0;
-
-	if (!axxia_rio_is_x9()) {
-		/* Reset the RIO port id to zero for this device */
-		gpreg_base = ioremap(0x2010094000, 0x1000);
-		if (gpreg_base == NULL)
-			return -EFAULT;
-
-		reg = inl((unsigned long int)(gpreg_base + 0x60));
-
-		reg &= ~(0xf << (dev_num * 4));
-
-		outl_p(reg, (unsigned long int)(gpreg_base + 0x60));
-
-		(*port_ndx) = 0;
-
-		/* Verify that this device is actually enabled */
-		if (NULL !=
-		of_find_compatible_node(NULL, NULL, "lsi,axm5500-amarillo")) {
-#ifdef CONFIG_LSI_NCR
-			ncr_read(NCP_REGION_ID(0x115, 0), 0x23c, 4, &reg);
-
-			if ((reg & (1 << (21+(dev_num*4)))) == 0) {
-				dev_dbg(&dev->dev, "%s: SRIO%d link not ready\n",
-					dev->dev.of_node->full_name, dev_num);
-				return -ENXIO;
-			}
-#endif
-		}
-
-		iounmap(gpreg_base);
-	} else {
-
-		ncr_read(NCP_REGION_ID(0x115, 0), 0x184, 4, &reg0);
-		ncr_read(NCP_REGION_ID(0x115, 0), 0x18c, 4, &reg1);
-		ncr_read(NCP_REGION_ID(0x115, 0), 0x0, 4, &reg);
-
-		dev_info(&dev->dev, "%s: 0x184 = %lx 0x18c = %lx 0x0 = %lx\n",
-			dev->dev.of_node->full_name, reg0, reg1, reg);
-		if (dev_num == 0) {
-			if ((reg & (1 << 3)) == 0) {
-				dev_emerg(&dev->dev, "%s: SRIO%d link not ready\n",
-					dev->dev.of_node->full_name, dev_num);
-				return -ENXIO;
-			}
-			return 0;
-		}
-		if (dev_num == 1) {
-			if ((reg & (1 << 10)) == 0) {
-				dev_emerg(&dev->dev, "%s: SRIO%d link not ready\n",
-					dev->dev.of_node->full_name, dev_num);
-				return -ENXIO;
-			}
-			return 0;
-		}
-		return -ENXIO;
-	}
-	return 0;
-}
-
-/**
- * NOTE:
- *
- * sRIO Bridge in AXXIA is what it is...
- *
- * - Paged access to configuration registers makes local config
- *   read a non-atomic operation.
- *
- * - Big and Little Endian mode registers
- *   Big Endian:
- *       0x0000-0xFFFC   - RapidIO Standard Registers
- *       0x10000-0x1FFFC - Endpoint Controller Specific Registers
- *   Little Endian
- *       0x20000-0x3FFFC - Peripheral Bus Bridge Specific Registers
- *
- * "SRIO_CONF" registers in AXXIA (e.g. page selection register)
- * are also Little Endian.  SRIO_CONF is organized as follows:
- *
- * - 0x000 .. 0x7ff    Fixed mapping to SRIO/RAB endpoint controller specific
- *                     registers equivalent to 0x20000 .. 0x207ff.  The
- *                     RAB_APB_CSR register within this block is used to
- *                     control the page selection of the 'paged mapping'
- *                     block.
- * - 0x800 .. 0xfff    Paged mapping to SRIO generic+endpoint controller
- *                     specific registers equivalent to 0x00000 .. 0x3ffff
- *
- * To avoid an extra spin-lock layer in __axxia_local_config_read
- * and __axxia_local_config_write, perform all internal driver accesses
- * to local config registers through the generic rio driver API.
- *
- * Accesses through the generic driver:__rio_local_write_config_32(),
- * __rio_local_read_config_32(), rio_mport_write_config_32() and
- * rio_mport_read_config_32() all use spin_lock_irqsave() /
- * spin_unlock_irqrestore(), to ensure local access restrictions.
- *
- */
-
-/**
- * __axxia_local_config_read - Generate a AXXIA local config space read
- * @priv: Master port private data
- * @offset: Offset into configuration space
- * @data: Value to be read into
- *
- * Generates a AXXIA local configuration space read.
- * Returns %0 on success or %-EINVAL on failure.
- */
-int axxia_local_config_read(struct rio_priv *priv,
-			    u32 offset,
-			    u32 *data)
-{
-	u32 page_sel;
-
-
-	if ((offset >= RAB_REG_BASE) &&
-	    (offset < (RAB_REG_BASE+SRIO_CONF_SPACE_SIZE_FIXED))) {
-		/*
-		 * Peripheral Bus Bridge Specific Registers
-		 * (0x2_0000-0x2_0FFC)
-		 */
-		*data = ioread32(priv->regs_win_fixed + (offset & 0x7ff));
-	} else {
-		/* Set correct page to operate on */
-		page_sel = (offset & 0x00fff800) << 5;
-		iowrite32(page_sel, priv->regs_win_fixed + RAB_APB_CSR_BASE);
-
-		if (offset < RAB_REG_BASE) {
-			/*
-			* Registers:
-			*   RapidIO Standard (0x0000-0xFFFC)
-			*   Endpoint Controller Specific (0x1_0000-0x1_FFFC)
-			*/
-			*data = ioread32be(priv->regs_win_paged +
-						(offset & 0x7ff));
-		} else if ((offset >= RAB_REG_BASE) &&
-			   (offset < SRIO_SPACE_SIZE)) {
-			/*
-			* Peripheral Bus Bridge Specific Registers
-			* (0x2_0000-0x3_FFFC)
-			*/
-			*data = ioread32(priv->regs_win_paged +
-						(offset & 0x7ff));
-		} else {
-			dev_err(priv->dev,
-				"RIO: Reading config register not specified for AXXIA (0x%8.8x)\n",
-				offset);
-		}
-	}
-
-	IODP("rio[%d]: ACR(%08x, <%08x)\n", priv->mport->id, offset, *data);
-
-	return 0;
-}
-
-/**
- * axxia_local_config_write - Generate a AXXIA local config space write
- * @priv: Master port private data
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @data: Value to be written
- *
- * Generates a AXXIA local configuration space write.
- * Returns %0 on success or %-EINVAL on failure.
- */
-int axxia_local_config_write(struct rio_priv *priv,
-				      u32 offset,
-				      u32 data)
-{
-	u32 page_sel;
-
-	if ((offset >= RAB_REG_BASE) &&
-	    (offset < (RAB_REG_BASE+SRIO_CONF_SPACE_SIZE_FIXED))) {
-		/*
-		 * Peripheral Bus Bridge Specific Registers
-		 * (0x2_0000-0x2_0FFC)
-		 */
-		iowrite32(data, priv->regs_win_fixed + (offset & 0x7ff));
-	} else {
-		/* Set correct page to operate on */
-		page_sel = (offset & 0x00fff800) << 5;
-		iowrite32(page_sel, priv->regs_win_fixed + RAB_APB_CSR_BASE);
-
-		if (offset < RAB_REG_BASE) {
-			/*
-			* Registers:
-			*   RapidIO Standard (0x0000-0xFFFC)
-			*   Endpoint Controller Specific (0x1_0000-0x1_FFFC)
-			*/
-			iowrite32be(data, priv->regs_win_paged +
-						(offset & 0x7ff));
-		} else if ((offset >= RAB_REG_BASE) &&
-			   (offset < SRIO_SPACE_SIZE)) {
-			/*
-			* Peripheral Bus Bridge Specific Registers
-			* (0x2_0000-0x3_FFFC)
-			*/
-			iowrite32(data, priv->regs_win_paged +
-						(offset & 0x7ff));
-		} else {
-			dev_err(priv->dev,
-				"RIO: Trying to write to config register not specified for AXIA (0x%8.8x)\n",
-				offset);
-		}
-	}
-
-	IODP("rio[%d]: ACW(%08x, >%08x)\n", priv->mport->id, offset, data);
-
-	return 0;
-}
-
-/**
- * axxia_rio_local_config_read - Generate a AXXIA local config space read
- * @mport: RapidIO master port info
- * @index: ID of RapdiIO interface
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @data: Value to be read into
- *
- * Generates a AXXIA local configuration space read.
- * Returns %0 on success or %-EINVAL on failure.
- */
-static
-int axxia_rio_local_config_read(struct rio_mport *mport,
-				int index, u32 offset, int len, u32 *data)
-{
-	struct rio_priv *priv = mport->priv;
-	int rc;
-
-	if (len != sizeof(u32))
-		return -EINVAL;
-	rc = axxia_local_config_read(priv, offset, data);
-
-	return rc;
-}
-
-/**
- * axxia_rio_local_config_write - Generate a AXXIA local config space write
- * @mport: RapidIO master port info
- * @index: ID of RapdiIO interface
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @data: Value to be written
- *
- * Generates a AXXIA local configuration space write.
- * Returns %0 on success or %-EINVAL on failure.
- */
-static
-int axxia_rio_local_config_write(struct rio_mport *mport,
-				 int index, u32 offset, int len, u32 data)
-{
-	struct rio_priv *priv = mport->priv;
-	int rc;
-
-	if (len != sizeof(u32))
-		return -EINVAL;
-	rc = axxia_local_config_write(priv, offset, data);
-
-	return rc;
-}
-
-/**
- * axxia_rio_config_read - Generate a AXXIA read maintenance transaction
- * @mport: RapidIO master port info
- * @index: ID of RapdiIO interface
- * @destid: Destination ID of transaction
- * @hopcount: Number of hops to target device
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @val: Location to be read into
- *
- * Generates a AXXIA read maintenance transaction.
- * Returns %0 on success or %-EINVAL on failure.
- */
-
-static
-int axxia_rio_config_read(struct rio_mport *mport, int index,
-			  u16 destid, u8 hopcount, u32 offset,
-			  int len, u32 *val)
-{
-	struct rio_priv *priv = mport->priv;
-	struct atmu_outb *aoutb = NULL;
-	u8 *addr;
-	u32 rval = 0;
-	u32 rbar = 0, ctrl;
-	int rc = 0;
-	u32 error_code = 0;
-
-	aoutb = &priv->outb_atmu[priv->maint_win_id];
-	if (aoutb == NULL)
-		return -EINVAL;
-
-	/* 16MB maintenance windows possible */
-	/* Allow only aligned access to maintenance registers */
-	if (offset > (CONFIG_RIO_MAINT_WIN_SIZE - len) ||
-		!IS_ALIGNED(offset, len))
-		return -EINVAL;
-
-	axxia_local_config_read(priv,
-				       RAB_APIO_AMAP_CTRL(priv->maint_win_id),
-				       &ctrl);
-
-	if (TTYPE_VAL(ctrl)) { /* Not maintenance */
-		dev_err(priv->dev,
-			"(%s): Window is not setup for Maintenance operations. 0x%8.8x\n",
-			__func__, ctrl);
-		return -EINVAL;
-	}
-
-	rbar &= ~HOP_COUNT(0xff);     /* Hop Count clear */
-	rbar |= HOP_COUNT(hopcount);  /* Hop Count set */
-	axxia_local_config_write(priv,
-				 RAB_APIO_AMAP_RBAR(priv->maint_win_id),
-				 rbar);
-
-	ctrl &= ~TARGID(0xffff); /* Target id clear */
-	ctrl |= TARGID(destid);  /* Target id set */
-	axxia_local_config_write(priv,
-				 RAB_APIO_AMAP_CTRL(priv->maint_win_id),
-				 ctrl);
-
-	addr = (u8 *) aoutb->win +
-		(offset & (CONFIG_RIO_MAINT_WIN_SIZE - 1));
-
-	switch (len) {
-	case 1:
-		IN_SRIO8(addr, rval, rc);
-		break;
-	case 2:
-		IN_SRIO16(addr, rval, rc);
-		break;
-	case 4:
-		IN_SRIO32(addr, rval, rc);
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	axxia_local_config_read(priv, 0x608, &error_code);
-	if (0 != error_code) {
-		rc = -EINVAL;
-		*val = 0xffffffffu;
-		/* clear error code */
-		axxia_local_config_write(priv,  0x608, 0);
-	}
-
-	if (rc) {
-		dev_dbg(priv->dev,
-			"axxia_rio_config_read: Error when reading\n");
-		dev_dbg(priv->dev,
-			"rio[%d]: RCR(did=%x, hc=%02x, %08x, <%08x)\n",
-			mport->id, destid, hopcount, offset, rval);
-	} else
-		*val = rval;
-
-	IODP("rio[%d]: RCR(did=%x, hc=%02x, %08x, <%08x)\n",
-		mport->id, destid, hopcount, offset, rval);
-
-	return rc;
-}
-
-/**
- * axxia_rio_config_write - Generate a AXXIA write maintenance transaction
- * @mport: RapidIO master port info
- * @index: ID of RapdiIO interface
- * @destid: Destination ID of transaction
- * @hopcount: Number of hops to target device
- * @offset: Offset into configuration space
- * @len: Length (in bytes) of the maintenance transaction
- * @val: Value to be written
- *
- * Generates an AXXIA write maintenance transaction.
- * Returns %0 on success or %-EINVAL on failure.
- */
-static
-int axxia_rio_config_write(struct rio_mport *mport, int index,
-			   u16 destid, u8 hopcount, u32 offset,
-			   int len, u32 val)
-{
-	struct rio_priv *priv = mport->priv;
-	struct atmu_outb *aoutb = NULL;
-	u8 *data;
-	u32 rbar = 0, ctrl, rval;
-	int rc = 0;
-	u32 error_code = 0;
-
-	IODP("rio[%d]: RCW(did=%x, hc=%02x, %08x, >%08x)\n",
-		mport->id, destid, hopcount, offset, val);
-
-	/* Argument validation */
-
-	aoutb = &priv->outb_atmu[priv->maint_win_id];
-	if (aoutb == NULL)
-		return -EINVAL;
-
-	/* 16MB maintenance windows possible */
-	/* Allow only aligned access to maintenance registers */
-	if (offset > (CONFIG_RIO_MAINT_WIN_SIZE - len) ||
-		!IS_ALIGNED(offset, len))
-		return -EINVAL;
-
-	axxia_local_config_read(priv,
-				RAB_APIO_AMAP_CTRL(priv->maint_win_id),
-				&ctrl);
-
-	if (TTYPE_VAL(ctrl)) { /* Not maintenance */
-		dev_err(priv->dev,
-			"(%s): Window is not setup for Maintenance operations.\n",
-			__func__);
-		rc = -EINVAL;
-		goto err;
-	}
-
-	rbar &= ~HOP_COUNT(0xff);     /* Hop Count clear */
-	rbar |= HOP_COUNT(hopcount);  /* Hop Count set */
-	axxia_local_config_write(priv,
-				 RAB_APIO_AMAP_RBAR(priv->maint_win_id),
-				 rbar);
-
-	ctrl &= ~TARGID(0xffff); /* Target id clear */
-	ctrl |= TARGID(destid);  /* Target id set */
-	axxia_local_config_write(priv,
-				 RAB_APIO_AMAP_CTRL(priv->maint_win_id),
-				 ctrl);
-	rval = val;
-	data = (u8 *) aoutb->win +
-		(offset & (CONFIG_RIO_MAINT_WIN_SIZE - 1));
-
-	switch (len) {
-	case 1:
-		OUT_SRIO8(data, rval);
-		break;
-	case 2:
-		OUT_SRIO16(data, rval);
-		break;
-	case 4:
-		OUT_SRIO32(data, rval);
-		break;
-	default:
-		rc = -EINVAL;
-	}
-
-	axxia_local_config_read(priv,  0x608, &error_code);
-	if (0 != error_code) {
-
-		dev_dbg(priv->dev,
-			"axxia_rio_config_write: Error when writing\n");
-
-		dev_dbg(priv->dev,
-			"rio[%d]: RCW(did=%x, hc=%02x, %08x, >%08x)\n",
-			mport->id, destid, hopcount, offset, val);
-
-		rc = -EINVAL;
-		/* clear error code */
-		axxia_local_config_write(priv,  0x608, 0);
-	}
-
-err:
-	return rc;
-}
-
-static inline int __flags2rio_tr_type(u32 mflags, u32 *trans_type)
-{
-	*trans_type = 0;
-	/* Set type of window */
-	if ((mflags == 0) || (mflags & RIO_NWRITE_R))
-		*trans_type = TTYPE(NRD_NWR_R); /* nread and nwrite_r */
-	else if (mflags & RIO_MAINT_WRITE)
-		*trans_type = TTYPE(MRD_MWR); /* mread and mwrite */
-	else if (mflags & RIO_NWRITE)
-		*trans_type = TTYPE(NRD_NWR); /* nread and nwrite */
-	else if (mflags & RIO_SWRITE)
-		*trans_type = TTYPE(NRD_SWR); /* nread and swrite */
-	else
-		return -EINVAL;
-	return 0;
-}
-
-#if 0
-/**
- * axxia_rio_map_outb_mem -- Mapping outbound memory.
- * @mport:  RapidIO master port
- * @win:    Outbound ATMU window for this access
- *          - obtained by calling axxia_rio_req_outb_region.
- * @destid: Destination ID of transaction
- * @addr:   RapidIO space start address.
- * @res:    Mapping region phys and virt start address
- *
- * Return: 0 -- Success.
- *
- */
-static int axxia_rio_map_outb_mem(struct rio_mport *mport, u32 win,
-				u16 destid, u32 addr, u32 mflags,
-				struct rio_map_addr *res)
-{
-	struct rio_priv *priv = mport->priv;
-	struct atmu_outb *aoutb;
-	u32 rbar = 0, ctrl, trans_type;
-	unsigned long flags;
-	int rc;
-
-	rc = __flags2rio_tr_type(mflags, &trans_type);
-	if (rc < 0) {
-		dev_err(priv->dev, "(%s) invalid transaction flags %x\n",
-			__func__, mflags);
-		return rc;
-	}
-
-	spin_lock_irqsave(&rio_io_lock, flags);
-
-	aoutb = &priv->outb_atmu[win];
-	if (unlikely(win >= RIO_OUTB_ATMU_WINDOWS ||
-		     !(aoutb->in_use && aoutb->riores))) {
-		spin_unlock_irqrestore(&rio_io_lock, flags);
-		dev_err(priv->dev, "(%s) faulty ATMU window (%d, %d, %8.8x)\n",
-			__func__, win, aoutb->in_use, (u32) aoutb->riores);
-		return -EINVAL;
-	}
-	__rio_local_read_config_32(mport, RAB_APIO_AMAP_CTRL(win), &ctrl);
-
-	if (TTYPE_VAL(ctrl) != trans_type) {
-		ctrl &= ~TTYPE(0x3);
-		ctrl |= trans_type;
-	}
-	if (TTYPE_VAL(ctrl)) { /* RIO address set - Not maintenance */
-		rbar |= RIO_ADDR_BASE(addr);
-		__rio_local_write_config_32(mport,
-					    RAB_APIO_AMAP_RBAR(win),
-					    rbar);
-	}
-	ctrl &= ~TARGID(0xffff); /* Target id clear */
-	ctrl |= TARGID(destid); /* Target id set */
-	ctrl |= ENABLE_AMBA; /* Enable window */
-	__rio_local_write_config_32(mport, RAB_APIO_AMAP_CTRL(win), ctrl);
-
-	res->phys = aoutb->riores->start + RIO_ADDR_OFFSET(addr);
-	res->va = aoutb->win + RIO_ADDR_OFFSET(addr);
-
-	spin_unlock_irqrestore(&rio_io_lock, flags);
-
-	return 0;
-}
-#endif
-/**
- * axxia_rio_req_outb_region -- Request outbound region in the
- *                            RapidIO bus address space.
- * @mport:  RapidIO master port
- * @size:   The mapping region size.
- * @name:   Resource name
- * @flags:  Flags for mapping. 0 for using default flags.
- * @id:     Allocated outbound ATMU window id
- *
- * Return: 0 -- Success.
- *
- * This function will reserve a memory region that may
- * be used to create mappings from local iomem to rio space.
- */
-static int axxia_rio_req_outb_region(struct rio_mport *mport,
-				   resource_size_t size,
-				   const char *name,
-				   u32 mflags, u32 *id)
-{
-	u32 win, reg, win_size = 0, trans_type = 0, wabar = 0;
-	struct rio_priv *priv = mport->priv;
-	struct atmu_outb *aoutb;
-	int rc = 0;
-	void __iomem *iowin;
-	struct resource *riores;
-	unsigned long flags;
-
-	if (!(is_power_of_2(size))) {
-		dev_err(priv->dev, "(%s) size is not power of 2 (%llu)\n",
-			__func__, size);
-		return -EFAULT;
-	}
-	rc = __flags2rio_tr_type(mflags, &trans_type);
-	if (rc < 0) {
-		dev_err(priv->dev, "(%s) invalid transaction flags %x\n",
-			__func__, mflags);
-		return rc;
-	}
-
-	spin_lock_irqsave(&rio_io_lock, flags);
-
-	for (win = 0; win < RIO_OUTB_ATMU_WINDOWS; win++) {
-		if (!(priv->outb_atmu[win].in_use))
-			break;
-	}
-
-	if (win == RIO_OUTB_ATMU_WINDOWS) {
-		spin_unlock_irqrestore(&rio_io_lock, flags);
-		dev_err(priv->dev,
-			"(%s) out of ATMU windows to use\n",
-			__func__);
-		return -ENOMEM;
-	}
-	aoutb = &priv->outb_atmu[win];
-	aoutb->in_use = 1;
-	aoutb->win = NULL;
-	aoutb->riores = NULL;
-
-	riores = kzalloc(sizeof(struct resource), GFP_ATOMIC);
-	if (!riores) {
-		aoutb->in_use = 0;
-		spin_unlock_irqrestore(&rio_io_lock, flags);
-		dev_err(priv->dev,
-			"(%s) failed to allocate resources\n",
-			__func__);
-		return -ENOMEM;
-	}
-
-	spin_unlock_irqrestore(&rio_io_lock, flags);
-
-	riores->name = name;
-	riores->flags = IORESOURCE_MEM;
-	if (allocate_resource(&mport->iores, riores,
-			      size, mport->iores.start,
-			      mport->iores.end, 0x400, NULL, NULL)) {
-		/* Align on 1kB boundry */
-		rc = -ENOMEM;
-		goto out_err_resource;
-	}
-
-	iowin = ioremap(riores->start, size);
-	if (!iowin) {
-		rc = -ENOMEM;
-		goto out_err_ioremap;
-	}
-
-	/* Set base address for window on PIO side */
-	if (!axxia_rio_is_x9())
-		wabar = AXI_BASE_HIGH(riores->start);
-	wabar |= AXI_BASE(riores->start);
-	__rio_local_write_config_32(mport, RAB_APIO_AMAP_ABAR(win), wabar);
-
-	if (0 == WIN_SIZE((u32)size))
-		size = 0x400u; /* make sure window size is at least 1KiB big*/
-
-
-	/* Set size of window */
-	win_size |= WIN_SIZE((u32)size);
-	__rio_local_write_config_32(mport, RAB_APIO_AMAP_SIZE(win), win_size);
-	__rio_local_read_config_32(mport, RAB_APIO_AMAP_CTRL(win), &reg);
-	reg &= ~TTYPE(0x3);
-	reg |= trans_type;
-	__rio_local_write_config_32(mport, RAB_APIO_AMAP_CTRL(win), reg);
-
-	spin_lock_irqsave(&rio_io_lock, flags);
-	aoutb->win = iowin;
-	aoutb->riores = riores;
-	spin_unlock_irqrestore(&rio_io_lock, flags);
-
-	*id = win;
-	return 0;
-
-out_err_ioremap:
-	dev_err(priv->dev, "(%s) ioremap IO-mem failed\n",
-		__func__);
-	if (release_resource(riores))
-		dev_err(priv->dev, "(%s) clean-up resource failed\n", __func__);
-out_err_resource:
-	dev_err(priv->dev, "(%s) alloc IO-mem for %s failed\n",
-		__func__, name);
-	kfree(riores);
-
-	spin_lock_irqsave(&rio_io_lock, flags);
-	aoutb->in_use = 0;
-	spin_unlock_irqrestore(&rio_io_lock, flags);
-	return rc;
-}
-
-/**
- * axxia_rio_release_outb_region -- Unreserve outbound memory region.
- * @mport: RapidIO master port
- * @win:   Allocated outbound ATMU window id
- *
- * Disables and frees the memory resource of an outbound memory region
- */
-static void axxia_rio_release_outb_region(struct rio_mport *mport,
-					u32 win)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 ctrl;
-	unsigned long flags;
-
-	if (unlikely(win >= RIO_OUTB_ATMU_WINDOWS))
-		return;
-
-	spin_lock_irqsave(&rio_io_lock, flags);
-
-	__rio_local_read_config_32(mport, RAB_APIO_AMAP_CTRL(win), &ctrl);
-	if (likely(priv->outb_atmu[win].in_use)) {
-		struct atmu_outb *aoutb = &priv->outb_atmu[win];
-		struct resource *riores = aoutb->riores;
-		void __iomem *iowin = aoutb->win;
-
-		__rio_local_write_config_32(mport,
-					    RAB_APIO_AMAP_CTRL(win),
-					    ctrl & ~ENABLE_AMBA);
-		aoutb->riores = NULL;
-		aoutb->win = NULL;
-
-		spin_unlock_irqrestore(&rio_io_lock, flags);
-
-		iounmap(iowin);
-		if (release_resource(riores))
-			dev_err(priv->dev, "(%s) clean-up resource failed\n",
-				__func__);
-		kfree(riores);
-
-		spin_lock_irqsave(&rio_io_lock, flags);
-		aoutb->in_use = 0;
-	}
-
-	spin_unlock_irqrestore(&rio_io_lock, flags);
-}
-
-
-/**
- * axxia_rio_set_mport_disc_mode - Set master port discovery/eumeration mode
- *
- * @mport: Master port
- *
- */
-void axxia_rio_set_mport_disc_mode(struct rio_mport *mport)
-{
-	u32 result;
-
-	if (mport->host_deviceid >= 0) {
-		__rio_local_write_config_32(mport, RIO_GCCSR,
-					    RIO_PORT_GEN_HOST |
-					    RIO_PORT_GEN_MASTER |
-					    RIO_PORT_GEN_DISCOVERED);
-	} else {
-		__rio_local_write_config_32(mport, RIO_GCCSR,
-					    RIO_PORT_GEN_MASTER);
-		__rio_local_write_config_32(mport, RIO_DID_CSR,
-					    RIO_SET_DID(mport->sys_size,
-					    RIO_ANY_DESTID(mport->sys_size)));
-	}
-
-#ifdef EXTRA1DEBUG
-	__rio_local_read_config_32(mport, RIO_GCCSR, &result);
-	EXT1P("rio[%d]: RIO_GEN_CTL_CSR set to 0x%X for main port\n",
-		mport->id, result);
-#endif
-
-	__rio_local_write_config_32(mport, RIO_COMPONENT_TAG_CSR, 0xFFFF);
-
-#ifdef	NOT_SUPPORTED
-	/* Use the reset default setting of (0x00000000).  RAB does not
-	 * support "Accept All=1".  We would need another ID value to use
-	 * if we wanted to set the PTPN and PTE=1. */
-
-	/* Set to receive any dist ID for serial RapidIO controller. */
-	if (mport->phy_type == RIO_PHY_SERIAL)
-		__rio_local_write_config_32(mport,
-					    EPC_PNPTAACR(mport->port_ndx),
-					    0x00000000);
-#endif
-
-#ifdef CONFIG_RAPIDIO_HOTPLUG
-	if (CONFIG_RAPIDIO_SECOND_DEST_ID != DESTID_INVALID) {
-		struct rio_priv *priv = mport->priv;
-
-		result = EPC_PNADIDCSR_ADE;
-		result |= EPC_PNADIDCSR_ADID_SMALL(
-				CONFIG_RAPIDIO_SECOND_DEST_ID);
-		__rio_local_write_config_32(mport,
-					    EPC_PNADIDCSR(priv->port_ndx),
-					    result);
-		dev_dbg(priv->dev, "Port%dAltDevIdmCSR set to 0x%X\n",
-			priv->port_ndx, CONFIG_RAPIDIO_SECOND_DEST_ID);
-	}
-#else
-	/* Set the Alternate Destination ID to prevent "Machine Checks"
-	** and aid the device enumeration / discovery process later on.
-	*/
-	{
-		struct rio_priv *priv = mport->priv;
-
-		result = EPC_PNADIDCSR_ADE;
-		if (mport->sys_size)
-			result |= EPC_PNADIDCSR_ADID_LARGE(~0);
-		else
-			result |= EPC_PNADIDCSR_ADID_SMALL(~0);
-		__rio_local_write_config_32(mport,
-					    EPC_PNADIDCSR(priv->port_ndx),
-					    result);
-		dev_dbg(priv->dev, "Port%dAltDevIdmCSR set to 0x%X\n",
-			priv->port_ndx, result);
-	}
-#endif
-}
-
-/**
- * axxia_init_port_data - HW Setup of master port
- *
- * @mport: Master port
- *
- */
-static void axxia_init_port_data(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 ccsr, data;
-
-#if defined(CONFIG_AXXIA_RIO_16B_ID)
-	__rio_local_read_config_32(mport, RAB_SRDS_CTRL0, &data);
-	__rio_local_write_config_32(mport, RAB_SRDS_CTRL0,
-				    data | RAB_SRDS_CTRL0_16B_ID);
-#endif
-	/* Probe the master port phy type */
-	__rio_local_read_config_32(mport, RIO_CCSR(priv->port_ndx), &ccsr);
-	mport->phys_rmap = (ccsr & 1) ? RIO_PHY_SERIAL : RIO_PHY_PARALLEL;
-	dev_dbg(priv->dev, "RapidIO PHY type: %s\n",
-		 (mport->phys_rmap == RIO_PHY_PARALLEL) ? "parallel" :
-		 ((mport->phys_rmap == RIO_PHY_SERIAL) ? "serial" :
-		  "unknown"));
-
-	__rio_local_read_config_32(mport, RIO_PEF_CAR, &data);
-	mport->sys_size = (data & RIO_PEF_CTLS) >> 4;
-	dev_dbg(priv->dev, "RapidIO Common Transport System size: %d\n",
-		mport->sys_size ? 65536 : 256);
-
-	__rio_local_read_config_32(mport, RIO_DEV_ID_CAR, &priv->devid);
-	__rio_local_read_config_32(mport, RIO_DEV_INFO_CAR, &priv->devrev);
-	{
-		int i;
-		static const u32 legacyids[] = {
-			AXXIA_DEVID_ACP34XX,
-			AXXIA_DEVID_ACP25XX,
-		};
-		__rio_local_read_config_32(mport, RAB_CTRL, &data);
-		priv->intern_msg_desc = (data & 0x00001000) ? 1 : 0;
-		for (i = 0; i < 2; i++) {
-			if (priv->devid == legacyids[i])
-				priv->intern_msg_desc = 1;
-		}
-		EXT1P("rio[%d]: RapidIO internal descriptors: %d (%x %x)\n",
-			mport->id, priv->intern_msg_desc, priv->devid, data);
-	}
-}
-
-/**
- * axxia_rio_info - Log Port HW setup
- *
- * @dev: RIO device
- * @ccsr: Port N Error and Command Status register
- *
- */
-static void axxia_rio_info(struct device *dev, u32 ccsr)
-{
-	const char *str;
-
-	if (ccsr & 1) {
-		/* Serial phy */
-		switch (ccsr >> 30) {
-		case 0:
-			str = "1";
-			break;
-		case 1:
-			str = "4";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-		dev_dbg(dev, "Hardware port width: %s\n", str);
-
-		switch ((ccsr >> 27) & 7) {
-		case 0:
-			str = "Single-lane 0";
-			break;
-		case 1:
-			str = "Single-lane 2";
-			break;
-		case 2:
-			str = "Four-lane";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-		dev_dbg(dev, "Training connection status: %s\n", str);
-	} else {
-		/* Parallel phy */
-		if (!(ccsr & 0x80000000))
-			dev_dbg(dev, "Output port operating in 8-bit mode\n");
-		if (!(ccsr & 0x08000000))
-			dev_dbg(dev, "Input port operating in 8-bit mode\n");
-	}
-}
-
-/**
- * rio_start_port - Check the master port
- * @mport: Master port to be checked
- *
- * Check the type of the master port and if it is not ready try to
- * restart the connection.
- */
-static int rio_start_port(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 ccsr, escsr;
-
-	/* Probe the master port phy type */
-	__rio_local_read_config_32(mport, RIO_CCSR(priv->port_ndx), &ccsr);
-	__rio_local_read_config_32(mport, RIO_ESCSR(priv->port_ndx), &escsr);
-
-	if (escsr & RIO_ESCSR_PU) {
-
-		dev_err(priv->dev,
-			"Port is not ready/restart ordered. Try to restart connection...\n");
-
-		/* Disable ports */
-		ccsr |= RIO_CCSR_PD;
-		__rio_local_write_config_32(mport, RIO_CCSR(priv->port_ndx),
-						ccsr);
-		switch (mport->phys_rmap) {
-		case RIO_PHY_SERIAL:
-			/* Set 1x lane */
-			ccsr &= ~RIO_CCSR_PWO;
-			ccsr |= RIO_CCSR_FORCE_LANE0;
-			__rio_local_write_config_32(mport,
-						RIO_CCSR(priv->port_ndx), ccsr);
-			break;
-		case RIO_PHY_PARALLEL:
-			break;
-		}
-
-		/* Enable ports */
-		ccsr &= ~RIO_CCSR_PD;
-		__rio_local_write_config_32(mport, RIO_CCSR(priv->port_ndx),
-					ccsr);
-		msleep(100);
-		__rio_local_read_config_32(mport, RIO_ESCSR(priv->port_ndx),
-					&escsr);
-		axxia_rio_info(priv->dev, ccsr);
-		if (escsr & RIO_ESCSR_PU) {
-			dev_dbg(priv->dev, "Port restart failed.\n");
-			return -ENOLINK;
-		} else {
-			dev_dbg(priv->dev, "Port restart success!\n");
-			return 0;
-		}
-	}
-
-#ifdef EXTRA1DEBUG
-	{
-		u32 hdlcsr, rabver;
-
-		__rio_local_read_config_32(mport, RIO_HOST_DID_LOCK_CSR,
-					&hdlcsr);
-		__rio_local_read_config_32(mport, RAB_VER, &rabver);
-
-		pr_info("rio[%d]: AR[%d] DIDCAR[%x]=%08x RAB_VER[%x]=%08x\n",
-			mport->id,
-			__LINE__,
-			RIO_DEV_ID_CAR, priv->devid,
-			RAB_VER, rabver);
-		pr_info("rio[%d]: AR[%d] [%x]=%08x [%x]=%08x [%x]=%08x\n",
-			mport->id,
-			__LINE__,
-			RIO_CCSR(priv->port_ndx), ccsr,
-			RIO_ESCSR(priv->port_ndx), escsr,
-			RIO_HOST_DID_LOCK_CSR, hdlcsr);
-	}
-#endif /* defined(EXTRA1DEBUG) */
-
-	dev_dbg(priv->dev, "Port is Ready\n");
-	return 0;
-}
-
-/**
- * rio_rab_ctrl_setup - Bridge Control HW setup
- *
- * @mport: Master port
- *
- * Response Prio = request prio +1. 2) No AXI byte swap
- * Internal (RIO Mem) DME desc access
- * Priority based MSG arbitration
- * RIO & AMBA PIO Enable
- */
-static void rio_rab_ctrl_setup(struct rio_mport *mport)
-{
-	u32 rab_ctrl;
-
-	__rio_local_write_config_32(mport, AXI_TIMEOUT, 0x00001000);
-
-#ifdef USE_DME_TIMEOUT
-	__rio_local_write_config_32(mport, DME_TIMEOUT, 0xC0080000);
-#else
-	__rio_local_write_config_32(mport, DME_TIMEOUT, 0x00000000);
-#endif
-
-	rab_ctrl = 0;
-	rab_ctrl |= (1 << 12);
-	rab_ctrl |= (2 << 6);
-	rab_ctrl |= 3;
-	__rio_local_write_config_32(mport, RAB_CTRL, rab_ctrl);
-}
-
-/**
- * rio_rab_pio_enable - Setup Peripheral Bus bridge,
- *                      RapidIO <-> Peripheral bus, HW.
- *
- * @mport: Master port
- *
- * Enable AXI PIO + outbound nwrite/nread/maintenance
- * Enable RIO PIO (enable rx maint port-write packet)
- */
-static void rio_rab_pio_enable(struct rio_mport *mport)
-{
-	__rio_local_write_config_32(mport, RAB_APIO_CTRL,
-				    RAB_APIO_MAINT_MAP_EN |
-				    RAB_APIO_MEM_MAP_EN |
-				    RAB_APIO_PIO_EN);
-	__rio_local_write_config_32(mport, RAB_RPIO_CTRL, RAB_RPIO_PIO_EN);
-}
-
-/**
- * rio_static_win_init -- Setup static ATMU window for maintenance
- *                        access and enable doorbells
- *
- * @mport: Master port
- *
- * Returns:
- * 0        - At success
- * -EFAULT  - Requested outbound region can not be claimed
- */
-int axxia_rio_static_win_init(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 ctrl;
-
-	/* Enable inbound doorbell */
-	__rio_local_write_config_32(mport, RAB_IB_DB_CSR, IB_DB_CSR_EN);
-
-	/* Configure maintenance transaction window */
-	if ((axxia_rio_req_outb_region(mport, CONFIG_RIO_MAINT_WIN_SIZE,
-				     "rio_maint_win", RIO_MAINT_WRITE,
-				     &priv->maint_win_id)) < 0)
-		goto err;
-
-	__rio_local_read_config_32(mport,
-				   RAB_APIO_AMAP_CTRL(priv->maint_win_id),
-				   &ctrl);
-	/* Enable window */
-	ctrl |= ENABLE_AMBA;
-	__rio_local_write_config_32(mport,
-				    RAB_APIO_AMAP_CTRL(priv->maint_win_id),
-				    ctrl);
-
-	return 0;
-err:
-	return -EFAULT;
-}
-
-/**
- * axxia_rio_static_win_release -- Release static ATMU maintenance window
- *                                 Disable doorbells
- *
- * @mport: Master port
- *
- */
-void axxia_rio_static_win_release(struct rio_mport *mport)
-{
-	struct rio_priv *priv = mport->priv;
-	u32 ibdb;
-
-	/* Disable inbound doorbell */
-	__rio_local_read_config_32(mport, RAB_IB_DB_CSR, &ibdb);
-	ibdb &= ~IB_DB_CSR_EN;
-	__rio_local_write_config_32(mport, RAB_IB_DB_CSR, ibdb);
-
-	/* Release maintenance transaction window */
-	axxia_rio_release_outb_region(mport, priv->maint_win_id);
-}
-
-/**
- * rio_parse_dtb - Parse RapidIO platform entry
- *
- * @dev: RIO platform device
- * @ndx: Which instance are we?
- * @law_start: Local Access Window start address from DTB
- * @law_size: Local Access Window size from DTB
- * @regs: RapidIO registers from DTB
- * @ob_num_dmes: Number of outbound DMEs available
- * @outb_dmes: RapidIO outbound DMEs array available;
- *                [0] for MSeg, [1] for SSeg
- * @ib_num_dmes: Number of inbound DMEs available
- * @inb_dmes: RapidIO inbound DMEs array available; 2 elements
- * @irq: RapidIO IRQ mapping from DTB
- *
- * Returns:
- * -EFAULT          At failure
- * 0                Success
- */
-static int rio_parse_dtb(
-	struct platform_device *dev,
-	int *ndx,
-	u64 *law_start,
-	u64 *law_size,
-	struct resource *regs,
-	int *ob_num_dmes,
-	int *outb_dmes,
-	int *ib_num_dmes,
-	int *inb_dmes,
-	int *irq,
-	struct event_regs *linkdown_reset)
-{
-	const u32 *dt_range, *cell;
-	int rlen, rc;
-	int paw, aw, sw;
-
-	if (!dev->dev.of_node) {
-		dev_err(&dev->dev, "Device OF-Node is NULL");
-		return -EFAULT;
-	}
-
-	if (!of_device_is_available(dev->dev.of_node)) {
-		EXT1P("rio[%d]: AR[%d] status = not available\n", 99, __LINE__);
-		return -ENODEV;
-	} else {
-		EXT1P("rio[%d]: AR[%d] status = available\n", 99, __LINE__);
-	}
-
-	if (of_property_read_u32(dev->dev.of_node, "index", &rlen))
-		return -ENODEV;
-	*ndx = rlen;
-
-	rc = of_address_to_resource(dev->dev.of_node, 0, regs);
-	if (rc) {
-		dev_err(&dev->dev, "Can't get %s property 'reg'\n",
-			dev->dev.of_node->full_name);
-		return -EFAULT;
-	}
-	dev_dbg(&dev->dev,
-		"Of-device full name %s\n",
-		 dev->dev.of_node->full_name);
-	dev_dbg(&dev->dev, "Regs: %pR\n", regs);
-
-	dt_range = of_get_property(dev->dev.of_node, "ranges", &rlen);
-
-	if (!dt_range) {
-		dev_err(&dev->dev, "Can't get %s property 'ranges'\n",
-			dev->dev.of_node->full_name);
-		return -EFAULT;
-	}
-
-	/* Get node address wide */
-	cell = of_get_property(dev->dev.of_node, "#address-cells", NULL);
-	if (cell)
-		aw = *cell;
-	else
-		aw = of_n_addr_cells(dev->dev.of_node);
-	if (aw > 3)			/* Anomaly in A15 build+parse */
-		aw = 2;
-	/* Get node size wide */
-	cell = of_get_property(dev->dev.of_node, "#size-cells", NULL);
-	if (cell)
-		sw = *cell;
-	else
-		sw = of_n_size_cells(dev->dev.of_node);
-	if (sw > 3)			/* Anomaly in A15 build+parse */
-		sw = 2;
-	/* Get parent address wide wide */
-	paw = of_n_addr_cells(dev->dev.of_node);
-
-	*law_start = of_read_number(dt_range + aw, paw);
-	*law_size = of_read_number(dt_range + aw + paw, sw);
-
-	dev_dbg(&dev->dev, "LAW: [mem 0x%016llx -- 0x%016llx]\n",
-		*law_start, *law_start + *law_size - 1);
-
-	outb_dmes[0] = outb_dmes[1] = 0;
-	cell = of_get_property(dev->dev.of_node, "outb-dmes", &rlen);
-	if (!cell) {
-		ob_num_dmes[0] = 2;
-		ob_num_dmes[1] = 1;
-		outb_dmes[0] = 0x00000003;
-		outb_dmes[1] = 0x00000001;
-	} else {
-		if (rlen < (4 * sizeof(int))) {
-			dev_err(&dev->dev, "Invalid %s property 'outb-dmes'\n",
-				dev->dev.of_node->full_name);
-			return -EFAULT;
-		}
-		ob_num_dmes[0] = of_read_number(cell, 1);
-		outb_dmes[0] = of_read_number(cell + 1, 1);
-		ob_num_dmes[1] = of_read_number(cell + 2, 1);
-		outb_dmes[1] = of_read_number(cell + 3, 1);
-		if (((ob_num_dmes[0])+(ob_num_dmes[1])) > DME_MAX_OB_ENGINES) {
-			dev_err(&dev->dev, "Invalid %s property 'outb-dmes'\n",
-				dev->dev.of_node->full_name);
-			return -EFAULT;
-		}
-	}
-	dev_dbg(&dev->dev, "outb-dmes: MSeg[%d]=%08x SSeg[%d]=%08x\n",
-		ob_num_dmes[0], outb_dmes[0], ob_num_dmes[1], outb_dmes[1]);
-
-	inb_dmes[0] = inb_dmes[1] = 0;
-	cell = of_get_property(dev->dev.of_node, "inb-dmes", &rlen);
-	if (!cell) {
-		ib_num_dmes[0] = DME_MAX_IB_ENGINES;
-		ib_num_dmes[1] = 0;
-		inb_dmes[0] = 0xffffffff;
-		inb_dmes[1] = 0x00000000;
-	} else {
-		if (rlen < (4 * sizeof(int))) {
-			dev_err(&dev->dev, "Invalid %s property 'inb-dmes'\n",
-				dev->dev.of_node->full_name);
-			return -EFAULT;
-		}
-		ib_num_dmes[0] = of_read_number(cell, 1);
-		inb_dmes[0] = of_read_number(cell + 1, 1);
-		ib_num_dmes[1] = of_read_number(cell + 2, 1);
-		inb_dmes[1] = of_read_number(cell + 3, 1);
-		if (((ib_num_dmes[0])+(ib_num_dmes[1])) > DME_MAX_IB_ENGINES) {
-			dev_err(&dev->dev, "Invalid %s property 'inb-dmes'\n",
-				dev->dev.of_node->full_name);
-			return -EFAULT;
-		}
-	}
-	dev_dbg(&dev->dev, "inb-dmes: MSeg[%d]=%08x SSeg[%d]=%08x\n",
-		ib_num_dmes[0], inb_dmes[0], ib_num_dmes[1], inb_dmes[1]);
-
-	*irq = irq_of_parse_and_map(dev->dev.of_node, 0);
-	dev_dbg(&dev->dev, "irq: %d\n", *irq);
-
-	memset(linkdown_reset, 0, sizeof(struct event_regs));
-	dt_range = of_get_property(dev->dev.of_node, "linkdown-reset", &rlen);
-	if (dt_range) {
-		if (rlen < (6 * sizeof(int))) {
-			dev_err(&dev->dev,
-				"Invalid %s property 'linkdown-reset'\n",
-				dev->dev.of_node->full_name);
-			return -EFAULT;
-		} else {
-			linkdown_reset->phy_reset_start =
-				of_read_number(dt_range + aw, paw);
-			linkdown_reset->phy_reset_size =
-				of_read_number(dt_range + aw + paw, sw);
-			linkdown_reset->reg_addr =
-				of_read_number(dt_range + 0, 1);
-			linkdown_reset->reg_mask =
-				of_read_number(dt_range + 1, 1);
-			linkdown_reset->in_use = 1;
-			EXT1P("rio: LDR st=%llx sz=%llx RA=%x MSK=%x iu=%d\n",
-				linkdown_reset->phy_reset_start,
-				linkdown_reset->phy_reset_size,
-				linkdown_reset->reg_addr,
-				linkdown_reset->reg_mask,
-				linkdown_reset->in_use);
-		}
-	}
-
-	return 0;
-}
-
-/**
- * rio_ops_setup - Alloc and initiate the RIO ops struct
- *
- * Returns:
- * ERR_PTR(-ENOMEM)      At failure
- * struct rio_ops *ptr   to initialized ops data at Success
- */
-static struct rio_ops *rio_ops_setup(void)
-{
-	struct rio_ops *ops = kzalloc(sizeof(*ops), GFP_KERNEL);
-
-	if (!ops)
-		return ERR_PTR(-ENOMEM);
-
-	ops->lcread = axxia_rio_local_config_read;
-	ops->lcwrite = axxia_rio_local_config_write;
-	ops->cread = axxia_rio_config_read;
-	ops->cwrite = axxia_rio_config_write;
-	ops->dsend = axxia_rio_doorbell_send;
-	ops->pwenable = axxia_rio_pw_enable;
-	ops->open_outb_mbox = axxia_open_outb_mbox;
-	ops->open_inb_mbox = axxia_open_inb_mbox;
-	ops->close_outb_mbox = axxia_close_outb_mbox;
-	ops->close_inb_mbox = axxia_close_inb_mbox;
-	ops->add_outb_message = axxia_ml_add_outb_message;
-	ops->add_inb_buffer = axxia_add_inb_buffer;
-	ops->get_inb_message = axxia_ml_get_inb_message;
-#ifdef CONFIG_RAPIDIO_HOTPLUG
-	ops->hotswap = axxia_rio_hotswap;
-	ops->port_notify_cb = axxia_rio_port_notify_cb;
-	ops->port_op_state = axxia_rio_port_op_state;
-#endif
-	return ops;
-}
-
-/**
- * rio_mport_dtb_setup - Alloc and initialize the master port data
- *                       structure with data retrieved from DTB
- *
- * @dev: RIO platform device
- * @law_start: Local Access Window start address from DTB
- * @law_size: Local Access Window size from DTB
- * @ops: RIO ops data structure
- *
- * Init mport data structure
- * Request RIO iomem resources
- * Register doorbell and mbox resources with generic RIO driver
-
- * Returns:
- * -ENOMEM                 At failure
- * struct rio_mport *ptr   to initialized mport data at Success
- */
-static int rio_mport_dtb_setup(struct platform_device *dev,
-			       int port_ndx,
-			       u64 law_start,
-			       u64 law_size,
-			       struct rio_ops *ops,
-			       struct rio_mport **ptr)
-{
-	int rc = 0;
-	struct rio_mport *mport = kzalloc(sizeof(*mport), GFP_KERNEL);
-
-	(*ptr) = NULL;
-
-	if (!mport)
-		return -ENOMEM;
-
-	mport->index = port_ndx;
-
-	INIT_LIST_HEAD(&mport->dbells);
-	mport->iores.start = law_start;
-	mport->iores.end = law_start + law_size - 1;
-	mport->iores.flags = IORESOURCE_MEM;
-	mport->iores.name = "rio_io_win";
-	mport->iores.parent = NULL;
-	mport->iores.child = NULL;
-	mport->iores.sibling = NULL;
-
-	if (request_resource(&iomem_resource, &mport->iores) < 0) {
-		dev_err(&dev->dev,
-			"RIO: Error requesting master port region 0x%016llx-0x%016llx\n",
-			(u64)mport->iores.start, (u64)mport->iores.end);
-		kfree(mport);
-		return -ENOMEM;
-	}
-	rio_init_dbell_res(&mport->riores[RIO_DOORBELL_RESOURCE], 0, 0xffff);
-	rio_init_mbox_res(&mport->riores[RIO_INB_MBOX_RESOURCE], 0,
-			RIO_MAX_RX_MBOX);
-	rio_init_mbox_res(&mport->riores[RIO_OUTB_MBOX_RESOURCE], 0,
-			RIO_MAX_TX_MBOX);
-	sprintf(mport->name, "RIO%d mport", mport->id);
-
-	mport->ops = ops;
-	mport->phys_efptr = 0x100; /* define maybe */
-
-	(*ptr) = mport;
-	return rc;
-}
-
-/**
- * rio_priv_dtb_setup - Alloc and initialize the master port private data
- *                      structure with data retrieved from DTB
- *
- * @dev: RIO platform device
- * @regs: RapidIO registers from DTB
- * @mport: master port
- * @ndx: Instance Id of the controller description
- * @port_ndx: Port Id of the controller
- * @numObNumDmes: override num outbound DMEs available
- * @outb_dmes: RapidIO outbound DMEs array available; [0] for MSeg, [1] for SSeg
- * @numIbNumDmes: override num inbound DMEs available
- * @inb_dmes: RapidIO inbound DMEs array available; 2 elements
- * @irq: IRQ number
- *
- * Init master port private data structure
- *
- * Returns:
- * ERR_PTR(-ENOMEM)        At failure
- * struct rio_priv *ptr    to initialized priv data at Success
- */
-
-static struct rio_priv *rio_priv_dtb_setup(
-	struct platform_device *dev,
-	struct resource *regs,
-	struct rio_mport *mport,
-	int ndx,
-	int port_ndx,
-	int *num_outb_dmes,
-	int *outb_dmes,
-	int *num_inb_dmes,
-	int *inb_dmes,
-	int irq,
-	struct event_regs *linkdown_reset)
-{
-	struct rio_priv *priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	int i, rc;
-
-	if (!priv)
-		return ERR_PTR(-ENOMEM);
-
-	/* master port driver handle (bidirectional reference supported) */
-	mport->priv = priv;
-	priv->cookie = LSI_AXXIA_RIO_COOKIE;
-	priv->mport = mport;
-	priv->ndx = ndx;
-	priv->port_ndx = port_ndx;
-	mutex_init(&priv->api_lock);
-	/* Max descriptors */
-	priv->desc_max_entries = RIO_MSG_MAX_ENTRIES;
-
-	if (priv->intern_msg_desc) {
-		/* Support for alloc_message_engine() */
-		struct resource *dres = &priv->acpres[ACP_HW_DESC_RESOURCE];
-
-		memset(dres, 0, sizeof(struct resource));
-			/* 'virtual' mapping of descriptors */
-		dres->start = 0;
-		dres->end = priv->desc_max_entries - 1;
-		dres->flags = ACP_RESOURCE_HW_DESC;
-		dres->name = "rio_desc_win";
-		dres->parent = NULL;
-		dres->child = NULL;
-		dres->sibling = NULL;
-
-		if (request_resource(&iomem_resource, dres) < 0) {
-			dev_err(&dev->dev,
-				"RIO: Error requesting descriptor region 0x%016llx-0x%016llx\n",
-				(u64)dres->start, (u64)dres->end);
-			rc = -ENOMEM;
-			goto err_fixed;
-		}
-	}
-
-	/* Defined DMEs */
-	if (outb_dmes) {
-		priv->num_outb_dmes[0] = num_outb_dmes[0];
-		priv->num_outb_dmes[1] = num_outb_dmes[1];
-		priv->outb_dmes[0] = outb_dmes[0];
-		priv->outb_dmes[1] = outb_dmes[1];
-	}
-	if (inb_dmes) {
-		priv->num_inb_dmes[0] = num_inb_dmes[0];
-		priv->num_inb_dmes[1] = num_inb_dmes[1];
-		priv->inb_dmes[0] = inb_dmes[0];
-		priv->inb_dmes[1] = inb_dmes[1];
-	}
-
-	/* Interrupt handling */
-	priv->irq_line = irq;
-	axxia_rio_port_irq_init(mport);
-
-	/* Dev ptr for debug printouts */
-	priv->dev = &dev->dev;
-
-	/* Init ATMU data structures */
-	for (i = 0; i < RIO_OUTB_ATMU_WINDOWS; i++) {
-		priv->outb_atmu[i].in_use = 0;
-		priv->outb_atmu[i].riores = NULL;
-	}
-
-	/* Setup local access */
-	priv->regs_win_fixed = ioremap(regs->start, SRIO_CONF_SPACE_SIZE_FIXED);
-	if (!priv->regs_win_fixed) {
-		rc = -ENOMEM;
-		goto err_fixed;
-	}
-	priv->regs_win_paged = ioremap(regs->start + SRIO_CONF_SPACE_SIZE_FIXED,
-					SRIO_CONF_SPACE_SIZE_PAGED);
-	if (!priv->regs_win_paged) {
-		rc = -ENOMEM;
-		goto err_paged;
-	}
-	if (linkdown_reset && linkdown_reset->in_use) {
-		memcpy(&priv->linkdown_reset, linkdown_reset,
-			sizeof(struct event_regs));
-		priv->linkdown_reset.win =
-			ioremap(linkdown_reset->phy_reset_start,
-				linkdown_reset->phy_reset_size);
-		if (!priv->linkdown_reset.win) {
-			rc = -ENOMEM;
-			goto err_linkdown;
-		}
-		EXT1P("rio[%d]: LDR win=%p\n", mport->id,
-			priv->linkdown_reset.win);
-	}
-
-	return priv;
-
-err_linkdown:
-	if (priv->linkdown_reset.win)
-		iounmap(priv->linkdown_reset.win);
-	iounmap(priv->regs_win_paged);
-err_paged:
-	iounmap(priv->regs_win_fixed);
-err_fixed:
-	kfree(priv);
-	return ERR_PTR(rc);
-}
-
-/**
- * axxia_rio_start_port - Start master port
- *
- * @mport: Master port
- *
- * Check the type of the master port and if it is not ready try to
- * restart the connection.
- * In hotplug mode we don't really care about connection state
- * elsewise we give up if the port is not up.
- *
- * Setup HW for basic memap access support:
- * enable AXI bridge, maintenance window, doorbells, etc..
- */
-int axxia_rio_start_port(struct rio_mport *mport)
-{
-	int rc;
-	struct rio_priv *priv = mport->priv;
-
-	/*
-	 * Set port line request ack timout 1.5 - 3 s
-	 * Set port response timeout 1.5 - 3 s
-	 */
-	if ((priv->devid == AXXIA_DEVID_AXM55XX) &&
-		(priv->devrev == AXXIA_DEVREV_AXM55XX_V1_0)) {
-		__rio_local_write_config_32(mport, RIO_PLTOCCSR,
-					((RIO_LINK_TIMEOUT_VAL * 100) << 8));
-		__rio_local_write_config_32(mport, RIO_PRTOCCSR,
-				((RIO_RESPONSE_TIMEOUT_VAL * 100) << 8));
-	} else {
-		__rio_local_write_config_32(mport, RIO_PLTOCCSR,
-					((RIO_LINK_TIMEOUT_VAL) << 8));
-		__rio_local_write_config_32(mport, RIO_PRTOCCSR,
-					((RIO_RESPONSE_TIMEOUT_VAL) << 8));
-	}
-
-	/* Check port training state:
-	 */
-
-	rc = rio_start_port(mport);
-	if (rc < 0) {
-#ifdef CONFIG_RAPIDIO_HOTPLUG
-		dev_warn(priv->dev, "Link is down - will continue anyway\n");
-#else
-		dev_err(priv->dev, "Link is down - SRIO Init failed\n");
-		return rc;
-#endif
-	}
-
-	/* Enable memory mapped access
-	 */
-	rio_rab_ctrl_setup(mport);
-
-	rio_rab_pio_enable(mport);
-
-	/* Miscellaneous
-	 */
-	__rio_local_write_config_32(mport, RAB_OB_DME_TID_MASK,
-				    OB_DME_TID_MASK);
-
-
-	/* Setup maintenance window
-	 * Enable doorbells
-	 */
-	rc = axxia_rio_static_win_init(mport);
-
-	return rc;
-}
-
-/**
- * axxia_rio_setup - Setup AXXIA RapidIO interface
- * @dev: platform_device pointer
- *
- * Initializes AXXIA RapidIO hardware interface, configures
- * master port with system-specific info, and registers the
- * master port with the RapidIO subsystem.
- *
- * Init sequence is divided into two phases
- * 1:
- *    All one-time initialization: e.g. driver software structures,
- *    work queues, tasklets, sync resources etc. are allocated and
- *    and initialized. At this stage No HW access is possible, to avoid
- *    race conditions, all HW accesses to local configuration space must
- *    be handled through the generic RIO driver access functions and
- *    these may not be used prior to init of master port data structure.
- * 2:
- *    Setup and try to start RapidIO master port controller HW
- *    If the driver is built with hotplug support, the setup routine
- *    does not require that the link is up to complete successfully,
- *    the port may be restarted at any point later in time. Without
- *    hotplug the setup function will fail if link tranining sequence
- *    doesn't complete successfully.
- *
- * Returns:
- * <0           Failure
- * 0            Success
- */
-static int axxia_rio_setup(struct platform_device *dev)
-{
-	int rc = -EFAULT;
-	struct rio_ops *ops;
-	struct rio_mport *mport;
-	struct rio_priv *priv;
-	struct resource regs;
-	u64 law_start = 0, law_size = 0;
-	int ndx = 0, irq = 0, port_ndx = 0;
-	int numObDmes[2] = { 0, }, outb_dmes[2] = { 0, };
-	int numIbDmes[2] = { 0, }, inb_dmes[2] = { 0, };
-	struct event_regs linkdown_reset = { 0, };
-#ifdef CONFIG_AXXIA_RIO_DS
-	struct axxia_rio_ds_dtb_info ds_dtb_info; /* data_streaming */
-#endif
-
-	/* Get address boundaries, etc. from DTB */
-	if (rio_parse_dtb(dev, &ndx, &law_start, &law_size, &regs,
-			  &numObDmes[0], &outb_dmes[0],
-			  &numIbDmes[0], &inb_dmes[0],
-			  &irq, &linkdown_reset))
-		return -EFAULT;
-
-	rc = axxia_rapidio_board_init(dev, ndx, &port_ndx);
-	if (rc != 0)
-		return rc;
-#ifdef CONFIG_AXXIA_RIO_DS
-	rc = axxia_parse_dtb_ds(dev, &ds_dtb_info);
-	if (rc != 0)
-		return rc;
-#endif
-	/* Alloc and Initialize driver SW data structure */
-	ops = rio_ops_setup();
-	if (IS_ERR(ops)) {
-		rc = PTR_ERR(ops);
-		goto err_ops;
-	}
-	rc = rio_mport_dtb_setup(dev, port_ndx, law_start, law_size,
-				 ops, &mport);
-	if (rc != 0)
-		goto err_port;
-	priv = rio_priv_dtb_setup(dev, &regs, mport, ndx, port_ndx,
-				  &numObDmes[0], &outb_dmes[0],
-				  &numIbDmes[0], &inb_dmes[0],
-				  irq, &linkdown_reset);
-	if (IS_ERR(priv)) {
-		rc = PTR_ERR(priv);
-		goto err_priv;
-	}
-
-	/* !!! HW access to local config space starts here !!! */
-
-	/* Get and set master port data
-	 */
-	axxia_init_port_data(mport);
-
-	/* Start port and enable basic memmap access
-	 */
-	rc = axxia_rio_start_port(mport);
-	if (rc < 0)
-		goto err_maint;
-
-	/* Hookup IRQ handlers
-	 */
-	if (axxia_rio_port_irq_enable(mport))
-		goto err_irq;
-
-	/* Hookup SYSFS support
-	 */
-	dev_set_drvdata(&dev->dev, mport);
-#ifdef CONFIG_AXXIA_RIO_STAT
-	axxia_rio_init_sysfs(dev);
-#endif
-#ifdef CONFIG_AXXIA_RIO_DS
-	/* Data_streaming */
-	if (ds_dtb_info.ds_enabled == 1) {
-		rc = axxia_cfg_ds(mport, &ds_dtb_info);
-		if (rc)
-			goto err_mport;
-		axxia_rio_ds_port_irq_init(mport);
-	}
-#endif
-	/* Register port with core driver
-	 */
-	if (rio_register_mport(mport)) {
-		dev_err(&dev->dev, "register mport failed\n");
-		goto err_mport;
-	}
-
-	/* Correct the host device id if needed
-	 */
-	{
-		u16 id = rio_local_get_device_id(mport);
-
-		EXT1P("rio[%d]: AR[%d] devid=%d hdid=%d\n",
-			mport->id, __LINE__,
-			mport->host_deviceid, rio_local_get_device_id(mport));
-		if (mport->host_deviceid < 0) {
-			if ((id != 0xFF) && (mport->sys_size == 0))
-				mport->host_deviceid = id;
-			else if ((id != 0xFFFF) && (mport->sys_size != 0))
-				mport->host_deviceid = id;
-		}
-	}
-
-	/* Any changes needed based on device id / revision ?
-	*/
-	switch (priv->devid) {
-	case AXXIA_DEVID_ACP25XX:
-		priv->outb_dmes[1] = 0x00000000;
-		break;
-	case AXXIA_DEVID_AXM55XX:
-		priv->outb_dmes[1] = 0x00000000;
-		switch (priv->devrev) {
-		case AXXIA_DEVREV_AXM55XX_V1_0:
-			pr_info(
-			"RIO: AXM 55xx sRIO Dev Rev 0 (Base DID Lock issue)\n");
-			break;
-		case AXXIA_DEVREV_AXM55XX_V1_1:
-			pr_info(
-			"RIO: AXM 55xx sRIO Device Rev 1 Controller %d\n",
-								priv->ndx);
-			break;
-		case AXXIA_DEVREV_AXM55XX_V1_2:
-			pr_info(
-			"RIO: AXM 55xx sRIO Device Rev 2 Controller %d\n",
-								priv->ndx);
-			break;
-		default:
-			break;
-		}
-		break;
-	default:
-		break;
-	}
-
-	/* And set the discovery mode for this port before we go
-	 */
-	axxia_rio_set_mport_disc_mode(mport);
-
-	EXT1P("rio[%p:%d]: priv=%p\n", mport, mport->id,
-		priv);
-	return 0;
-
-err_mport:
-	axxia_rio_port_irq_disable(mport);
-#ifdef CONFIG_AXXIA_RIO_STAT
-	axxia_rio_release_sysfs(dev);
-#endif
-err_irq:
-	axxia_rio_static_win_release(mport);
-err_maint:
-	if (priv->linkdown_reset.win)
-		iounmap(priv->linkdown_reset.win);
-	iounmap(priv->regs_win_fixed);
-	iounmap(priv->regs_win_paged);
-	kfree(priv);
-err_priv:
-	kfree(mport);
-err_port:
-	kfree(ops);
-err_ops:
-	irq_dispose_mapping(irq);
-	return rc;
-}
-
-/*
-  The probe function for RapidIO peer-to-peer network.
-*/
-static int axxia_of_rio_rpn_probe(struct platform_device *dev)
-{
-	EXT1P(KERN_INFO "Setting up RapidIO peer-to-peer network %s\n",
-	       dev->dev.of_node->full_name);
-
-	return axxia_rio_setup(dev);
-};
-
-static const struct of_device_id axxia_of_rio_rpn_ids[] = {
-	{ .compatible = "axxia, rapidio-delta", },
-	{ .compatible = "intel,axxia-rapidio", },
-	{ .compatible = "acp, rapidio-delta", },
-	{},
-};
-
-static struct platform_driver axxia_of_rio_rpn_driver = {
-	.driver = {
-		.name = "axxia-of-rio",
-		.owner = THIS_MODULE,
-		.of_match_table = axxia_of_rio_rpn_ids,
-	},
-	.probe = axxia_of_rio_rpn_probe,
-};
-
-static __init int axxia_of_rio_rpn_init(void)
-{
-	EXT1P(KERN_INFO "Register RapidIO platform driver\n");
-	return platform_driver_register(&axxia_of_rio_rpn_driver);
-}
-
-subsys_initcall_sync(axxia_of_rio_rpn_init);
diff --git a/drivers/rapidio/devices/lsi/axxia-rio.h b/drivers/rapidio/devices/lsi/axxia-rio.h
deleted file mode 100644
index 2980e72..0000000
--- a/drivers/rapidio/devices/lsi/axxia-rio.h
+++ /dev/null
@@ -1,620 +0,0 @@
-/*
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program.
- */
-
-#ifndef _AXXIA_RIO_H_
-#define _AXXIA_RIO_H_
-
-#include <linux/device.h>
-#include <linux/of_platform.h>
-#include <linux/rio.h>
-#include <linux/rio_drv.h>
-#include <linux/interrupt.h>
-#include <linux/kfifo.h>
-#include <linux/io.h>
-#include "axxia-rio-irq.h"
-/* Constants, Macros, etc. */
-
-#define AXXIA_RIO_SYSMEM_BARRIER()	\
-	/* Memory Barrier */	\
-	smp_mb()
-
-#define IN_SRIO8(a, v, ec)      do {            \
-	v = ioread8(a); ec = 0;  \
-	} while (0)
-#define IN_SRIO16(a, v, ec)     do {            \
-	v = ioread16be(a); ec = 0;  \
-	} while (0)
-#define IN_SRIO32(a, v, ec)     do {            \
-	v = ioread32be(a); ec = 0;  \
-	} while (0)
-
-#define OUT_SRIO8(a, v)         iowrite8(v, a)
-#define OUT_SRIO16(a, v)        iowrite16be(v, a)
-#define OUT_SRIO32(a, v)        iowrite32be(v, a)
-
-/*****************************************/
-/* *********** Byte Swapping *********** */
-/*****************************************/
-#define BSWAP(x)  __builtin_bswap32(x)     /* Use gcc built-in byte swap code */
-
-#define DESTID_INVALID (u16)(0xff)
-#define RIO_SET_DID(size, x)	(size ? (x & 0xffff) : ((x & 0x000000ff) << 16))
-
-/*******************************/
-/* *********** ACP *********** */
-/*******************************/
-#define ACP_MAX_RESOURCES       16
-#define ACP_HW_DESC_RESOURCE    0
-#define ACP_RESOURCE_HW_DESC	0x00000100
-
-
-/*****************************************/
-/* *********** ACP/AXXIA REG *********** */
-/*****************************************/
-#define SRIO_CONF_SPACE_SIZE          0x1000
-#define SRIO_CONF_SPACE_SIZE_FIXED    0x0800
-#define SRIO_CONF_SPACE_SIZE_PAGED    0x0800
-
-#define SRIO_SPACE_SIZE         0x40000      /* Total size GRIO + RAB Spaces */
-
-/* End point models & revisions */
-#define AXXIA_DEVID_ACP34XX		0x5101000a
-#define AXXIA_DEVID_ACP25XX		0x5108000a
-#define AXXIA_DEVID_AXM55XX		0x5120000a
-#define AXXIA_DEVID_AXM35XX		0x5102000a
-#define   AXXIA_DEVREV_AXM55XX_V1_0	  0x00000000
-#define   AXXIA_DEVREV_AXM55XX_V1_1	  0x80000000
-#define   AXXIA_DEVREV_AXM55XX_V1_2	  0x40000000
-
-/* End Point Controller Specific Registers (0x1_0000-0x1_FFFC) */
-#define EPC_REG_BASE            0x10000
-#define EPC_PNADIDCSR(x)        (EPC_REG_BASE + (0x100+((x)*0x80)))
-#define  EPC_PNADIDCSR_ADE	(1 << 31)
-#define  EPC_PNADIDCSR_ADID_SMALL(id)	((u32)((id) & 0x00ff) << 16)
-#define  EPC_PNADIDCSR_ADID_LARGE(id)	((u32)((id) & 0xffff) <<  0)
-#define EPC_PNPTAACR(x)	        (EPC_REG_BASE + (0x120+((x)*0x80)))
-#define EPC_IECSR(x)            (EPC_REG_BASE + (0x130+((x)*0x80)))
-#define  EPC_IECSR_RETE         0x80000000   /*WOCL*/
-
-/* Peripheral Bus Bridge Specific Registers (0x2_0000-0x3_FFFC) */
-#define RAB_REG_BASE            0x20000
-#define RAB_VER                 (RAB_REG_BASE + 0x00)
-#define RAB_APB_CSR_BASE        0x30
-#define RAB_APB_CSR             (RAB_REG_BASE + RAB_APB_CSR_BASE)
-#define RAB_CTRL                (RAB_REG_BASE + 0x08)
-#define RAB_STAT                (RAB_REG_BASE + 0x0c)
-#define AXI_TIMEOUT             (RAB_REG_BASE + 0x10)
-#define DME_TIMEOUT             (RAB_REG_BASE + 0x14)
-
-#define RAB_PIO_RESET           (RAB_REG_BASE + 0x18)
-#define  RAB_PIO_RESET_RPIO     0x00000100
-#define  RAB_PIO_RESET_APIO     0x00000001
-
-#define RAB_COOP_LOCK           (RAB_REG_BASE + 0x1C)
-#define RAB_IB_PW_CSR           (RAB_REG_BASE + 0x28)
-#define RAB_IB_PW_EN                    0x1UL
-#define RAB_IB_PW_NUMWORDS(csr) (((csr) & 0x001f0000) >> 16)
-
-#define RAB_IB_PW_DATA          (RAB_REG_BASE + 0x2C)
-
-#define RAB_RPIO_CTRL           (RAB_REG_BASE + 0x80)
-#define RAB_RPIO_PIO_EN                 0x1
-#define RAB_RPIO_RELAX_ORDER            0x2
-
-#define RAB_RPIO_STAT           (RAB_REG_BASE + 0x84)
-#define  RAB_RPIO_STAT_RSP_ERR  0x00000004
-#define  RAB_RPIO_STAT_ADDR_MAP 0x00000002
-#define  RAB_RPIO_STAT_DISABLED 0x00000001
-
-/* AXI PIO (outbound)*/
-#define RAB_APIO_CTRL           (RAB_REG_BASE + 0x180)
-#define RAB_APIO_CPP_EN                 0x8
-#define RAB_APIO_MAINT_MAP_EN           0x4
-#define RAB_APIO_MEM_MAP_EN             0x2
-#define RAB_APIO_PIO_EN                 0x1
-
-/* SRIO PHY Control */
-#define RAB_SRDS_CTRL0          (RAB_REG_BASE + 0x980)
-#define  RAB_SRDS_CTRL0_16B_ID   0x00000004
-
-#define RAB_SRDS_CTRL1          (RAB_REG_BASE + 0x984)
-#define  RAB_SRDS_CTRL1_RST      0x00000001
-
-#define RAB_SRDS_CTRL2          (RAB_REG_BASE + 0x988)
-#define RAB_SRDS_STAT0          (RAB_REG_BASE + 0x990)
-#define RAB_SRDS_STAT1          (RAB_REG_BASE + 0x994)
-#define  RAB_SRDS_STAT1_LINKDOWN_INT    0x80000000
-
-/* AW SMON control */
-#define RAB_SMON_CTRL0          (RAB_REG_BASE + 0x9A0)
-#define  RAB_SMON_CTRL0_INT_TM_OF       0x00200000
-#define  RAB_SMON_CTRL0_INT_CNT_OF      0x00020000
-#define  RAB_SMON_CTRL0_ENB             0x00000001
-
-
-/* register contains transaction type, target id */
-#define RAB_APIO_AMAP_CTRL(n)   (RAB_REG_BASE + (0x200 + (n * 0x10)))
-#define MRD_MWR                         (0x0)
-#define NRD_NWR                         (0x1)
-#define NRD_NWR_R                       (0x2)
-#define NRD_SWR                         (0x3)
-#define TTYPE(type)                     (((u32)(type) & 0x3) << 1)
-#define TTYPE_VAL(reg)                  (((reg) >> 1) & 0x3)
-#define TARGID(tid)                     (((u32)(tid) & 0xffff) << 16)
-#define ENABLE_AMBA                     (0x1UL)
-
-/* register contains the AXI window size */
-#define RAB_APIO_AMAP_SIZE(n)   (RAB_REG_BASE + (0x204 + (n * 0x10)))
-#define WIN_SIZE(size)                  (size & 0xfffffc00)
-
-/* register for AXI based address for window */
-#define RAB_APIO_AMAP_ABAR(n)		(RAB_REG_BASE + (0x208 + (n * 0x10)))
-#define AXI_BASE_HIGH(addr)             ((u32)(((u64)(addr) & 0x3f00000000ULL) \
-					 >> 32) << 22)
-#define AXI_BASE(addr)                  (((u32)(addr) & 0xfffffc00) >> 10)
-
-/* Register for RIO base address */
-#define RAB_APIO_AMAP_RBAR(n)   (RAB_REG_BASE + (0x20C + (n * 0x10)))
-#define RIO_ADDR_BASE(taddr)            (((u32)(taddr) & 0xfffffc00) >> 10)
-#define RIO_ADDR_OFFSET(taddr)          ((u32)(taddr) & 0x3ff)
-#define HOP_COUNT(hop_cnt)              (((u32)(hop_cnt) & 0xff) << 14)
-
-
-/* Other */
-#define RAB_LFC_BLOCKED         (RAB_REG_BASE + 0x964)
-#define RAB_SRDS_CTRL0          (RAB_REG_BASE + 0x980)
-
-
-/* Interrupt registers */
-#define RAB_INTR_ENAB_GNRL      (RAB_REG_BASE + 0x40)
-/* General int enable  bits */
-#define RAB_INT_OB_DB_EN        (1 << 31)
-#define EXT_INT_OB_DB_EN        (0xff << 16)
-#define MISC_INT_EN             (1 << 6)
-#define OB_DME_INT_EN           (1 << 5)
-#define IB_DME_INT_EN           (1 << 4)
-#define RPIO_INT_EN             (1 << 1)
-#define APIO_INT_EN             (1)
-
-#define RAB_INTR_ENAB_GNRL_SET  (MISC_INT_EN | RPIO_INT_EN | \
-			 APIO_INT_EN/* | OB_DME_INT_EN | IB_DME_INT_EN*/)
-
-#define RAB_INTR_STAT_GNRL      (RAB_REG_BASE + 0x60)
-/* General int status bits */
-#define RAB_INTERNAL_STAT       (1 << 31)
-#define EXT_INT_STATUS          (0xff << 16)
-#define MISC_INT                (1 << 6)
-#define OB_DME_INT              (1 << 5)
-#define IB_DME_INT              (1 << 4)
-#define RPIO_INT                (1 << 1)
-#define APIO_INT                (1)
-
-#define RAB_INTR_ENAB_APIO      (RAB_REG_BASE + 0x44)
-#define RAB_INTR_ENAB_RPIO      (RAB_REG_BASE + 0x48)
-#define RAB_INTR_ENAB_IDME      (RAB_REG_BASE + 0x54)
-#define RAB_INTR_ENAB_ODME      (RAB_REG_BASE + 0x58)
-#define RAB_INTR_ENAB_MISC      (RAB_REG_BASE + 0x5c)
-
-#define RAB_INTR_STAT_APIO      (RAB_REG_BASE + 0x64)
-
-/* Data_streaming */
-#define RAB_INTR_ENAB_ODSE      (RAB_REG_BASE + 0x2a0c)
-#define RAB_INTR_ENAB_IBDS      (RAB_REG_BASE + 0x2a04)
-#define RAB_INTR_STAT_ODSE      (RAB_REG_BASE + 0x2a18)
-#define RAB_INTR_STAT_IBSE_VSID_M (RAB_REG_BASE + 0x2a10)
-
-/* PIO int status bits */
-#define APIO_TRANS_FAILED       (1 << 8)
-#define APIO_TRANS_COMPLETE     (1)
-#define RAB_INTR_ENAB_APIO_SET  (APIO_TRANS_FAILED)
-
-#define RAB_APIO_STAT           (RAB_REG_BASE + 0x184)
-#define  RAB_APIO_STAT_RQ_ERR     0x00000040
-#define  RAB_APIO_STAT_TO_ERR     0x00000020
-#define  RAB_APIO_STAT_RSP_ERR    0x00000010
-#define  RAB_APIO_STAT_MAP_ERR    0x00000008
-#define  RAB_APIO_STAT_MAINT_DIS  0x00000004
-#define  RAB_APIO_STAT_MEM_DIS    0x00000002
-#define  RAB_APIO_STAT_DISABLED   0x00000001
-
-#define RAB_INTR_STAT_RPIO      (RAB_REG_BASE + 0x68)
-#define RPIO_TRANS_FAILED       (1 << 8)
-#define RPIO_TRANS_COMPLETE     (1)
-#define RAB_INTR_ENAB_RPIO_SET  (RPIO_TRANS_FAILED | RPIO_TRANS_COMPLETE)
-
-#define RAB_INTR_STAT_MISC      (RAB_REG_BASE + 0x7c)
-/* Misc int status bits */
-#define UNEXP_MSG_LOG           (0xff << 24)
-#define USR_INT                 (1 << 16)
-#define AMST_INT                (1 << 11)
-#define ASLV_INT                (1 << 10)
-#define LFC_INT                 (1 << 9)
-#define CO_LOCK_INT             (1 << 8)
-#define LINK_REQ_INT            (1 << 7)
-#define LL_TL_INT               (1 << 6)
-#define GRIO_INT                (1 << 5)
-#define PORT_WRITE_INT          (1 << 4)
-#define UNSP_RIO_REQ_INT        (1 << 3)
-#define UNEXP_MSG_INT           (1 << 2)
-#define OB_DB_DONE_INT          (1 << 1)
-#define IB_DB_RCV_INT           (1)
-
-/* AMBA (AXI/AHB) Master/Slave */
-#define RAB_ASLV_STAT_CMD       (RAB_REG_BASE + 0x1c0)
-#define  RAB_ASLV_STAT_CMD_USUP 0x00000001
-
-#define RAB_ASLV_STAT_ADDR      (RAB_REG_BASE + 0x1c4)
-#define RAB_AMAST_STAT          (RAB_REG_BASE + 0x1e0)
-#define  RAB_AMAST_STAT_WRTO    0x00000020
-#define  RAB_AMAST_STAT_RDTO    0x00000010
-#define  RAB_AMAST_STAT_WRDE    0x00000008
-#define  RAB_AMAST_STAT_WRSE    0x00000004
-#define  RAB_AMAST_STAT_RDDE    0x00000002
-#define  RAB_AMAST_STAT_RDSE    0x00000001
-
-
-#define MISC_FATAL (AMST_INT | ASLV_INT)
-
-#if defined(CONFIG_AXXIA_RIO_STAT)
-
-#define MISC_ERROR_INDICATION (MISC_FATAL | GRIO_INT | LL_TL_INT | \
-			       UNEXP_MSG_LOG | UNSP_RIO_REQ_INT | \
-			       UNEXP_MSG_INT)
-#define MISC_DB_EVENT (OB_DB_DONE_INT | IB_DB_RCV_INT)
-
-#else
-
-#define MISC_ERROR_INDICATION MISC_FATAL
-#define MISC_DB_EVENT IB_DB_RCV_INT
-
-#endif
-
-#define RAB_INTR_ENAB_MISC_SET  (MISC_ERROR_INDICATION | MISC_DB_EVENT)
-
-/* Inbound/Outbound int bits */
-#define RAB_INTR_ENAB_IDME_SET  (~(0UL))
-#define RAB_INTR_ENAB_ODME_SET  (0x7)
-
-
-/************************************/
-/* *********** MESSAGES *********** */
-/************************************/
-/* Outbound Doorbell */
-#define RAB_OB_DB_CSR(n)        (RAB_REG_BASE + (0x400 + (n * 0x8)))
-#define OB_DB_DEST_ID(id)               (((u32)(id) & 0xffff) << 16)
-#define OB_DB_CRF                       (1 << 6)
-#define OB_DB_PRIO(prio)                (((u32)(prio) & 0x3) << 4)
-#define OB_DB_STATUS(reg)               (((u32)(reg) & 0xe) >> 1)
-#define OB_DB_SEND                      (1)
-
-#define OB_DB_STATUS_DONE       (0)
-#define OB_DB_STATUS_RETRY      (1)
-#define OB_DB_STATUS_ERROR      (2)
-#define OB_DB_STATUS_TIMEOUT    (3)
-#define OB_DB_STATUS_PENDING    (4)
-
-#define MAX_OB_DB               (8)
-
-#define RAB_OB_DB_INFO(n)       (RAB_REG_BASE + (0x404 + (n * 0x8)))
-#define OB_DB_INFO(info)                ((u32)(info) & 0xffff)
-
-/* Inbound Doorbell */
-#define RAB_IB_DB_CSR           (RAB_REG_BASE + 0x480)
-#define IB_DB_CSR_NUM_MSG(csr)          (((u32)(csr) & 0x3f0000) >> 16)
-#define IB_DB_CSR_EN                    (1)
-
-#define RAB_IB_DB_INFO          (RAB_REG_BASE + 0x484)
-
-#define DBELL_SID(info)		(((u32)(info) & 0xffff0000) >> 16)
-#define DBELL_INF(info)		((u32)(info) & 0xffff)
-
-/* Messages */
-#define RAB_OB_DME_CTRL(e)      (RAB_REG_BASE + (0x500 + (0x10 * (e))))
-#define RAB_OB_DME_DESC_ADDR(e) (RAB_REG_BASE + (0x504 + (0x10 * (e))))
-#define RAB_OB_DME_STAT(e)      (RAB_REG_BASE + (0x508 + (0x10 * (e))))
-#define RAB_OB_DME_DESC(e)      (RAB_REG_BASE + (0x50C + (0x10 * (e))))
-#define RAB_OB_DME_TID_MASK     (RAB_REG_BASE + 0x5f0)
-
-#define RAB_INTR_STAT_ODME      (RAB_REG_BASE + 0x78)
-#define OB_DME_STAT_SLEEPING             (1 << 9)
-#define OB_DME_STAT_TRANS_PEND           (1 << 8)
-#define OB_DME_STAT_RESP_TO              (1 << 7)
-#define OB_DME_STAT_RESP_ERR             (1 << 6)
-#define OB_DME_STAT_DATA_TRANS_ERR       (1 << 5)
-#define OB_DME_STAT_DESC_UPD_ERR         (1 << 4)
-#define OB_DME_STAT_DESC_ERR             (1 << 3)
-#define OB_DME_STAT_DESC_FETCH_ERR       (1 << 2)
-#define OB_DME_STAT_DESC_XFER_CPLT       (1 << 1)
-#define OB_DME_STAT_DESC_CHAIN_XFER_CPLT (1)
-
-#define OB_DME_STAT_ERROR_MASK           0x000000FC
-#define OB_DME_TID_MASK                  0xFFFFFFFF
-
-#define RAB_IB_DME_CTRL(e)      (RAB_REG_BASE + (0x600 + (0x10 * (e))))
-#define   RAB_IB_DME_CTRL_XMBOX(m)           (((m) & 0x3c) << 6)
-#define   RAB_IB_DME_CTRL_MBOX(m)            (((m) & 0x03) << 6)
-#define   RAB_IB_DME_CTRL_LETTER(l)          (((l) & 0x03) << 4)
-#define RAB_IB_DME_DESC_ADDR(e) (RAB_REG_BASE + (0x604 + (0x10 * (e))))
-#define RAB_IB_DME_STAT(e)      (RAB_REG_BASE + (0x608 + (0x10 * (e))))
-#define RAB_IB_DME_DESC(e)      (RAB_REG_BASE + (0x60C + (0x10 * (e))))
-
-#define RAB_INTR_STAT_IDME      (RAB_REG_BASE + 0x74)
-#define IB_DME_STAT_SLEEPING             (1 << 9)
-#define IB_DME_STAT_TRANS_PEND           (1 << 8)
-#define IB_DME_STAT_MSG_TIMEOUT          (1 << 7)
-#define IB_DME_STAT_MSG_ERR              (1 << 6)
-#define IB_DME_STAT_DATA_TRANS_ERR       (1 << 5)
-#define IB_DME_STAT_DESC_UPDATE_ERR      (1 << 4)
-#define IB_DME_STAT_DESC_ERR             (1 << 3)
-#define IB_DME_STAT_DESC_FETCH_ERR       (1 << 2)
-#define IB_DME_STAT_DESC_XFER_CPLT       (1 << 1)
-#define IB_DME_STAT_DESC_CHAIN_XFER_CPLT (1)
-
-#define IB_DME_STAT_ERROR_MASK		0x000000FC
-
-#define DME_WAKEUP			(2)
-#define DME_ENABLE			(1)
-
-/* DME Message Descriptor Table */
-#define DESC_TABLE_W0_NDX(d)         (0x10 * (d))
-#define DESC_TABLE_W0_RAB_BASE(d)    (RAB_REG_BASE+0x10000+DESC_TABLE_W0_NDX(d))
-#define DESC_TABLE_W0(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0x0)
-#define DESC_TABLE_W1(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0x4)
-#define DESC_TABLE_W2(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0x8)
-#define DESC_TABLE_W3(d)                (DESC_TABLE_W0_RAB_BASE(d) + 0xC)
-
-#define DESC_TABLE_W0_MEM_BASE(me, d)		\
-	(((u8 *)(me)->descriptors) + DESC_TABLE_W0_NDX(d))
-#define DESC_TABLE_W0_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0x0)
-#define DESC_TABLE_W1_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0x4)
-#define DESC_TABLE_W2_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0x8)
-#define DESC_TABLE_W3_MEM(me, d)        (DESC_TABLE_W0_MEM_BASE(me, d) + 0xC)
-
-#define DME_DESC_DW0_SRC_DST_ID(id)     ((id) << 16)
-#define DME_DESC_DW0_GET_DST_ID(dw0)    (((dw0) >> 16) & 0xffff)
-#define DME_DESC_DW0_RIO_ERR            (1 << 11)
-#define DME_DESC_DW0_AXI_ERR            (1 << 10)
-#define DME_DESC_DW0_TIMEOUT_ERR        (1 << 9)
-#define DME_DESC_DW0_DONE               (1 << 8)
-#define DME_DESC_DW0_SZ_MASK            (3 << 4)
-#define DME_DESC_DW0_EN_INT             (1 << 3)
-#define DME_DESC_DW0_END_OF_CHAIN       (1 << 2)
-#define DME_DESC_DW0_NXT_DESC_VALID     (1 << 1)
-#define DME_DESC_DW0_VALID              (1)
-
-#define DESC_STATE_TO_ERRNO(s)		(s & DME_DESC_DW0_TIMEOUT_ERR ? \
-					 -ETIME : (s & (DME_DESC_DW0_RIO_ERR | \
-					 DME_DESC_DW0_AXI_ERR) ? -EPROTO : 0))
-
-#define DME_DESC_DW0_READY_MASK         0x00000F00
-#define DME_DESC_DW0_ERROR_MASK         0x00000E00
-#define DME_DESC_DW0_SEG(d)             ((d & DME_DESC_DW0_SZ_MASK) >> 4)
-#define DME_DESC_DW0_SIZE(s)            (s == 0 ? 512 : \
-					 (s == 1 ? 1024 :	\
-					  (s == 2 ? 2048 : 4096)))
-
-#define DME_DESC_DW1_PRIO(flags)        ((flags & 0x3) << 30)
-#define DME_DESC_DW1_CRF(flags)         ((flags & 0x4) << 27)
-#define DME_DESC_DW1_SEG_SIZE_256       (0x06 << 18)
-#define DME_DESC_DW1_XMBOX(m)           (((m) & 0x3c) << 2)
-#define DME_DESC_DW1_MBOX(m)            (((m) & 0x03) << 2)
-#define DME_DESC_DW1_LETTER(l)          ((l) & 0x03)
-#define DME_DESC_DW1_MSGLEN(s)          ((((s + 7) & ~7) >> 3) << 8) /* Round
-					 up and shift to make double word */
-#define DME_DESC_DW1_MSGLEN_F(d)        (((d) >> 8) & 0x3ff)
-#define DME_DESC_DW1_MSGLEN_B(ml)       ((ml) << 3) /* double words to bytes */
-#define DME_DESC_DW1_GET_LETTER(dw1)    ((dw1) & 0x03)
-#define DME_DESC_DW1_GET_MBOX(dw1)      ((dw1 >> 2) & 0x03)
-
-/***********************************/
-/* *********** RIO REG *********** */
-/***********************************/
-#define RIO_PLTOCCSR            0x120
-#define RIO_PRTOCCSR            0x124
-#define RIO_GCCSR		0x13c
-
-#define RIO_LINK_TIMEOUT_VAL		(0x40)
-#define RIO_RESPONSE_TIMEOUT_VAL	(0xfa0)
-
-#define RIO_MNT_REQ_CSR(x)      (0x140+((x)*0x20))
-#define  RIO_MNT_REQ_MASK       0x00000007
-#define  RIO_MNT_REQ_RST        0x00000003
-#define  RIO_MNT_REQ_STAT       0x00000004
-
-#define RIO_MNT_RSP_CSR(x)      (0x144+((x)*0x20))
-#define  RIO_MNT_RSP_LS         0x0000001f
-#define  RIO_MNT_RSP_AS         0x000003e0
-#define  RIO_MNT_RSP_RV         0x80000000
-
-#define RIO_ACK_STS_CSR(x)      (0x148+((x)*0x20))
-#define  RIO_ACK_STS_IA         0x1f000000
-#define  RIO_ACK_STS_OUTA       0x00001f00
-#define  RIO_ACK_STS_OBA        0x0000001f
-
-#define RIO_ESCSR(x)            (0x158+((x)*0x20))
-#define  RIO_ESCSR_I2E		 0x40000000   /*RW*/
-#define  RIO_ESCSR_OPD           0x04000000   /*WOCL*/
-#define  RIO_ESCSR_OFE           0x02000000   /*WOCL*/
-#define  RIO_ESCSR_ODE           0x01000000   /*WOCL*/
-#define  RIO_ESCSR_ORE           0x00100000   /*WOCL*/
-#define  RIO_ESCSR_OR            0x00080000   /*R*/
-#define  RIO_ESCSR_ORS           0x00040000   /*R*/
-#define  RIO_ESCSR_OEE           0x00020000   /*WOCL*/
-#define  RIO_ESCSR_OES           0x00010000   /*R--*/
-#define  RIO_ESCSR_IRS           0x00000400   /*R*/
-#define  RIO_ESCSR_IEE           0x00000200   /*WOCL*/
-#define  RIO_ESCSR_IES           0x00000100   /*R--*/
-#define  RIO_ESCSR_PWP           0x00000010   /*R*/
-#define  RIO_ESCSR_PE            0x00000004   /*WOCL*/
-#define  RIO_ESCSR_PO            0x00000002   /*R*/
-#define  RIO_ESCSR_PU            0x00000001   /*R*/
-#define  RIO_EXCSR_WOLR          (RIO_ESCSR_OPD | RIO_ESCSR_OFE | \
-				  RIO_ESCSR_ODE | RIO_ESCSR_ORE | \
-				  RIO_ESCSR_OEE | RIO_ESCSR_IEE | RIO_ESCSR_PE)
-
-#define ESCSR_FATAL (RIO_ESCSR_OFE |		\
-		     RIO_ESCSR_IES |		\
-		     RIO_ESCSR_IRS |		\
-		     RIO_ESCSR_ORS |		\
-		     RIO_ESCSR_OES)
-
-#define RIO_CCSR(x)		(0x15c+((x)*0x20))
-#define  RIO_CCSR_PW             0xc0000000   /*R*/
-#define  RIO_CCSR_IPW            0x38000000   /*R*/
-#define  RIO_CCSR_PW_MASK        0x7
-#define  RIO_CCSR_PWO_SHIFT      24
-#define  RIO_CCSR_PWO            (RIO_CCSR_PW_MASK << RIO_CCSR_PWO_SHIFT)/*R/W*/
-#define  RIO_CCSR_FORCE_LANE0    (2 << RIO_CCSR_PWO_SHIFT)
-#define  RIO_CCSR_PD             0x00800000   /*R/W*/
-#define  RIO_CCSR_OPE            0x00400000   /*R/W*/
-#define  RIO_CCSR_IPE            0x00200000   /*R/W*/
-#define  RIO_CCSR_FCP            0x00040000   /*R/W*/
-#define  RIO_CCSR_EB             0x00020000   /*R*/
-#define  RIO_CCSR_SPF            0x00000008   /*R/W*/
-#define  RIO_CCSR_PL             0x00000002   /*R/W*/
-
-#define RIO_PNPTAACR		0x10120
-
-#define AXXIA_IBDME_INTERRUPT_MODE	0x1
-#define AXXIA_IBDME_TIMER_MODE		0x2
-/*************************************/
-/* *********** Constants *********** */
-/*************************************/
-
-#define RIO_OUTB_ATMU_WINDOWS   16
-
-#define LSI_AXXIA_RIO_COOKIE	0x41734230	/* aka 'AsR0' */
-
-/***********************************/
-/* *********** STRUCTS *********** */
-/***********************************/
-struct atmu_outb {
-	void __iomem *win;
-	struct rio_atmu_regs __iomem *atmu_regs;
-	struct resource *riores;
-	int in_use;
-};
-
-struct event_regs {
-	void __iomem *win;
-	u64 phy_reset_start;
-	u64 phy_reset_size;
-	u32 reg_addr;
-	u32 reg_mask;
-	int in_use;
-};
-
-struct rio_desc {
-	u32     d0;
-	u32     d1;
-	u32     d2;
-	u32     d3;
-};
-
-struct rio_priv {
-	u32     cookie;
-
-	struct mutex api_lock;
-
-
-	struct rio_mport *mport;
-	struct device *dev;
-	int  ndx;	/* From FDT description */
-	int  port_ndx;
-	u32  devid;     /* From GRIO register */
-	u32  devrev;    /* From GRIO register */
-
-	void __iomem *regs_win_fixed;
-	void __iomem *regs_win_paged;
-
-	int maint_win_id;
-	struct atmu_outb outb_atmu[RIO_OUTB_ATMU_WINDOWS];
-	struct resource acpres[ACP_MAX_RESOURCES];
-
-	int intern_msg_desc;
-	int desc_max_entries;
-
-	/* Chip-specific DME availability */
-	int num_outb_dmes[2];	/* [0]=MSeg, [1]=Sseg */
-	int outb_dmes_in_use[2];
-	int outb_dmes[2];	/* set of defined outbound DMEs:
-				 *   [0]=MSeg, [1]=SSeg */
-	int num_inb_dmes[2];	/* [0]=MSeg, [1]=Sseg */
-	int inb_dmes_in_use[2];
-	int inb_dmes[2];	/* set of defined inbound DMEs */
-
-	struct rio_tx_dme      ob_dme_shared[DME_MAX_OB_ENGINES];
-	struct rio_tx_mbox     *ob_mbox[RIO_MAX_TX_MBOX];
-	struct rio_rx_mbox     *ib_mbox[RIO_MAX_RX_MBOX];
-	struct rio_msg_dme     *ib_dme[DME_MAX_IB_ENGINES];
-	struct rio_pw_irq *pw_data;
-	unsigned int dme_mode;
-	/* Linkdown Reset; Trigger via SRDS STAT1 */
-	struct event_regs linkdown_reset;
-
-	/* Interrupts */
-	int irq_line;
-	struct rio_irq_handler misc_irq;
-	struct rio_irq_handler linkdown_irq; /* AXM55xx+SRDS STAT1+APB2SER */
-	struct rio_irq_handler apio_irq;
-	struct rio_irq_handler rpio_irq;
-	struct rio_irq_handler ob_dme_irq;
-	struct rio_irq_handler ib_dme_irq;
-
-#ifdef CONFIG_AXXIA_RIO_STAT
-	unsigned int rpio_compl_count;
-	unsigned int rpio_failed_count;
-	unsigned int apio_compl_count;
-	unsigned int apio_failed_count;
-	unsigned int rio_pw_count;
-	unsigned int rio_pw_msg_count;
-#endif
-#ifdef CONFIG_RAPIDIO_HOTPLUG
-	/* Fatal err */
-	spinlock_t port_lock;
-	void (*port_notify_cb)(struct rio_mport *mport);
-#endif
-#ifdef CONFIG_AXXIA_RIO_DS
-	/* Data_streaming */
-	struct axxia_rio_ds_priv     ds_priv_data;
-	struct axxia_rio_ds_cfg      ds_cfg_data;
-#endif
-} ____cacheline_internodealigned_in_smp;
-
-
-/**********************************************/
-/* *********** External Functions *********** */
-/**********************************************/
-
-extern int axxia_rio_start_port(struct rio_mport *mport);
-extern void axxia_rio_set_mport_disc_mode(struct rio_mport *mport);
-extern void axxia_rio_static_win_release(struct rio_mport *mport);
-extern int axxia_rio_static_win_init(struct rio_mport *mport);
-
-extern int axxia_local_config_read(struct rio_priv *priv,
-				   u32 offset, u32 *data);
-extern int axxia_local_config_write(struct rio_priv *priv,
-				    u32 offset, u32 data);
-
-#ifdef CONFIG_RAPIDIO_HOTPLUG
-
-extern int axxia_rio_hotswap(struct rio_mport *mport, u8 flags);
-
-#endif /* CONFIG_RAPIDIO_HOTPLUG */
-
-int axxia_rio_is_x9(void);
-int axxia_rapidio_board_init(struct platform_device *dev, int devnum,
-							int *portndx);
-#endif  /* _AXXIA_RIO_H_ */
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 88a44f7..e8855d3 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -335,11 +335,11 @@ config SPI_LP8841_RTC
 	  Say N here unless you plan to run the kernel on an ICP DAS
 	  LP-8x4x industrial computer.
 
-config SPI_LSI_ACP
-	tristate "LSI ACP34xx SPI Controller"
+config SPI_AXXIA_ACP
+	tristate "INTEL Axxia ACP34xx SPI Controller"
 	depends on PPC_OF
 	help
-	  This is the driver for the LSI SPI controller, present in
+	  This is the driver for the INTEL Axxia SPI controller, present in
 	  ACP34xx devices. The controller is essentially a AMBA pl022.
 
 config SPI_MPC52xx
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index f4943fb..ed157e2 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -11,7 +11,7 @@ obj-$(CONFIG_SPI_SPIDEV)		+= spidev.o
 obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
 
 # SPI master controller drivers (bus)
-obj-$(CONFIG_SPI_LSI_ACP)		+= spi-acp.o
+obj-$(CONFIG_SPI_AXXIA_ACP)		+= spi-acp.o
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
 obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
 obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index ad79b84b..2210f05 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -2466,7 +2466,7 @@ static int pl022_runtime_resume(struct device *dev)
 	.internal_cs_ctrl = false,
 };
 
-static struct vendor_data vendor_lsi = {
+static struct vendor_data vendor_axxia = {
 	.fifodepth = 8,
 	.max_bpw = 16,
 	.unidir = false,
@@ -2514,7 +2514,7 @@ static int pl022_runtime_resume(struct device *dev)
 		 */
 		.id	= 0x000b6022,
 		.mask	= 0x000fffff,
-		.data	= &vendor_lsi,
+		.data	= &vendor_axxia,
 	},
 	{ 0, 0 },
 };
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 91bba4f..208b10c 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1619,10 +1619,10 @@ config SERIAL_ST_ASC_CONSOLE
 	select SERIAL_CORE_CONSOLE
 
 config SERIAL_ACP
-	bool "LSI's Serial Driver for the ACP"
+	bool "INTEL Axxia's Serial Driver for the ACP"
 	select SERIAL_CORE
 	help
-	  Handles the serial ports (there are two) on LSI's ACP board
+	  Handles the serial ports (there are two) on INTEL Axxia's ACP board
 	  and the simulated serial port provided by ISS.
 
 config SERIAL_ACP_CONSOLE
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 04b4862..2d7f2d9 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_SERIAL_8250) += 8250/
 
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
-obj-$(CONFIG_SERIAL_ACP) += lsi_acp_serial.o
+obj-$(CONFIG_SERIAL_ACP) += axxia_acp_serial.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
 obj-$(CONFIG_SERIAL_PXA_NON8250) += pxa.o
 obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
diff --git a/drivers/tty/serial/axxia_acp_serial.c b/drivers/tty/serial/axxia_acp_serial.c
new file mode 100644
index 0000000..1ac3e08
--- /dev/null
+++ b/drivers/tty/serial/axxia_acp_serial.c
@@ -0,0 +1,1247 @@
+/*
+ *  drivers/tty/serial/axxia_acp_serial.c
+ *
+ *  Driver for AMBA serial ports on INTEL Axxia's PPC based ACP.
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2018 INTEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ *
+ * This is a generic driver for ARM AMBA-type serial ports.  They
+ * have a lot of 16550-like features, but are not register compatible.
+ * Note that although they do have CTS, DCD and DSR inputs, they do
+ * not have an RI input, nor do they have DTR or RTS outputs.  If
+ * required, these have to be supplied via some other means (eg, GPIO)
+ * and hooked into this driver.
+ */
+
+#if defined(CONFIG_SERIAL_ACP_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/slab.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/serial.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/io.h>
+
+#define SZ_4K (4*1024)
+#define UART_NR			2
+#define SERIAL_AMBA_MAJOR	204
+#define SERIAL_AMBA_MINOR	64
+#define SERIAL_AMBA_NR		UART_NR
+#define AMBA_ISR_PASS_LIMIT	256
+#define UART_DR_ERROR		\
+(UART011_DR_OE|UART011_DR_BE|UART011_DR_PE|UART011_DR_FE)
+#define UART_DUMMY_DR_RX	(1 << 16)
+
+#define MAX_BAUD_RATE 115200
+
+static int dt_baud_rate;
+static unsigned long per_clock;
+
+/*
+  ======================================================================
+  ======================================================================
+  A modified uart_port structure.
+  ======================================================================
+  ======================================================================
+*/
+
+struct uart_acp_port {
+	struct uart_port port;
+	irq_hw_number_t hwirq;
+	unsigned int interrupt_mask;
+	unsigned int old_status;
+	void *timer_base;
+	unsigned short ibrd;
+	unsigned short fbrd;
+};
+
+/*
+  ======================================================================
+  ======================================================================
+  Both UARTs share the same clock input, the output of the 2nd timer,
+  or timer 1, from the APB Dual Input Timers (there are two of these,
+  thus 4 timers).
+  ======================================================================
+  ======================================================================
+*/
+
+#define TIMER_LOAD		       0x00
+#define TIMER_VALUE		       0x04
+#define TIMER_CONTROL		       0x08
+#define TIMER_CONTROL_ENABLE	       0x80
+#define TIMER_CONTROL_MODE	       0x40
+#define TIMER_CONTROL_INTERRUPT_ENABLE 0x20
+#define TIMER_CONTROL_OUTPUT_MODE      0x10
+#define TIMER_CONTROL_PRESCALER	       0x0c
+#define TIMER_CONTROL_SIZE	       0x02
+#define TIMER_CONTROL_ONE_SHOT	       0x01
+#define TIMER_INTCLR		       0x0C
+#define TIMER_RIS		       0x10
+#define TIMER_MIS		       0x14
+#define TIMER_BGLOAD		       0x18
+
+/*
+  ----------------------------------------------------------------------
+  get_clock_stuff
+*/
+
+static int
+get_clock_stuff(struct uart_acp_port *port, int baud_rate)
+{
+	unsigned long ibrd;
+	unsigned long fbrd;
+
+	ibrd = per_clock / (16 * baud_rate);
+
+	/*
+	 * The following formula is from the ARM document (ARM DDI 0183E).
+	 *
+	 * Baud Rate Divisor = (Uart Clock / (16 * Baud Rate))
+	 *
+	 * Baud Rate Divisor is then split into integral and fractional
+	 * parts.  The IBRD value is simply the itegral part.  The FBRD is
+	 * calculated as follows.
+	 *
+	 * FBRD = fractional part of the Baud Rate Divisor * 64 + 0.5
+	 *
+	 * The fractional part of the Baud Rate Divisor can be represented as
+	 * follows:
+	 *
+	 *    (Uart Clock % (16 * baud_rate)) / (16 * baud_rate)
+	 *
+	 * As long as the division isn't done until the end. So, the above
+	 * "* 64 + 0.5" is the FBRD. Also note that x/y + 1/2 = (2x+y)/2y.
+	 * This *  leads to:
+	 *
+	 *    ((Uart Clock % (16 * baud_rate)) * 64 * 2 + (16 * baud_rate))
+	 *  -----------------------------------------------------------------
+	 *                     2 * (16 * baud_rate)
+	 */
+
+	port->port.uartclk = per_clock;
+
+	fbrd = port->port.uartclk % (16 * baud_rate);
+	fbrd *= 128;
+	fbrd += (16 * baud_rate);
+	fbrd /= (2 * (16 * baud_rate));
+
+	port->ibrd = (unsigned short) ibrd;
+	port->fbrd = (unsigned short) fbrd;
+
+	return 0;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Serial operations.
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ------------------------------------------------------------------------------
+  acp_serial_wac
+
+  This was added to allow an easy debugging breakpoint.
+*/
+
+static void
+acp_serial_wac(u32 *address, int character, u32 line)
+{
+	out_le32(address, character);
+}
+
+/*
+  ------------------------------------------------------------------------------
+  acp_serial_tx_empty
+*/
+
+static unsigned int
+acp_serial_tx_empty(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *) port;
+	unsigned int status =
+		in_le32((u32 *)(uap->port.membase + UART01x_FR));
+	return status &
+		(UART01x_FR_BUSY | UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_stop_tx
+*/
+
+static void
+acp_serial_stop_tx(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	uap->interrupt_mask &= ~UART011_TXIM;
+	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
+		 uap->interrupt_mask);
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_start_tx
+*/
+
+static void
+acp_serial_start_tx(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	uap->interrupt_mask |= UART011_TXIM;
+	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
+		 uap->interrupt_mask);
+}
+
+void acp_serial_stop_rx(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	uap->interrupt_mask &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|
+				 UART011_PEIM|UART011_BEIM|UART011_OEIM);
+	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
+		 uap->interrupt_mask);
+}
+
+void acp_serial_enable_ms(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	uap->interrupt_mask |=
+		UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;
+	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
+		 uap->interrupt_mask);
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_rx_chars
+*/
+
+static void
+acp_serial_rx_chars(struct uart_acp_port *uap)
+{
+	unsigned int status, ch, flag, max_count = 256;
+
+	status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
+	while ((status & UART01x_FR_RXFE) == 0 && max_count--) {
+		ch = in_le32((u32 *)(uap->port.membase + UART01x_DR)) |
+			UART_DUMMY_DR_RX;
+		flag = TTY_NORMAL;
+		uap->port.icount.rx++;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (unlikely(ch & UART_DR_ERROR)) {
+			if (ch & UART011_DR_BE) {
+				ch &= ~(UART011_DR_FE | UART011_DR_PE);
+				uap->port.icount.brk++;
+				if (uart_handle_break(&uap->port))
+					goto ignore_char;
+			} else if (ch & UART011_DR_PE)
+				uap->port.icount.parity++;
+			else if (ch & UART011_DR_FE)
+				uap->port.icount.frame++;
+			if (ch & UART011_DR_OE)
+				uap->port.icount.overrun++;
+
+			ch &= uap->port.read_status_mask;
+
+			if (ch & UART011_DR_BE)
+				flag = TTY_BREAK;
+			else if (ch & UART011_DR_PE)
+				flag = TTY_PARITY;
+			else if (ch & UART011_DR_FE)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&uap->port, ch & 255))
+			goto ignore_char;
+
+		uart_insert_char(&uap->port, ch, UART011_DR_OE, ch, flag);
+
+ignore_char:
+		status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
+	}
+	spin_unlock(&uap->port.lock);
+	tty_flip_buffer_push(&uap->port.state->port);
+	spin_lock(&uap->port.lock);
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_tx_chars
+*/
+
+static void
+acp_serial_tx_chars(struct uart_acp_port *uap)
+{
+	struct circ_buf *xmit = &uap->port.state->xmit;
+	int count;
+
+	if (uap->port.x_char) {
+		acp_serial_wac((u32 *)(uap->port.membase + UART01x_DR),
+				uap->port.x_char, __LINE__);
+		uap->port.icount.tx++;
+		uap->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {
+		acp_serial_stop_tx(&uap->port);
+		return;
+	}
+
+	count = uap->port.fifosize >> 1;
+	do {
+		acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR),
+				xmit->buf[xmit->tail], __LINE__);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		uap->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&uap->port);
+
+	if (uart_circ_empty(xmit))
+		acp_serial_stop_tx(&uap->port);
+}
+
+void acp_serial_modem_status(struct uart_acp_port *uap)
+{
+	unsigned int status, delta;
+
+	status = in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
+		UART01x_FR_MODEM_ANY;
+
+	delta = status ^ uap->old_status;
+	uap->old_status = status;
+
+	if (!delta)
+		return;
+
+	if (delta & UART01x_FR_DCD)
+		uart_handle_dcd_change(&uap->port, status & UART01x_FR_DCD);
+
+	if (delta & UART01x_FR_DSR)
+		uap->port.icount.dsr++;
+
+	if (delta & UART01x_FR_CTS)
+		uart_handle_cts_change(&uap->port, status & UART01x_FR_CTS);
+
+	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
+}
+
+/*
+  ------------------------------------------------------------------------------
+  acp_serial_isr
+*/
+
+static irqreturn_t
+acp_serial_isr(int irq, void *dev_id)
+{
+	struct uart_acp_port *uap = dev_id;
+	unsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;
+	int handled = 0;
+
+	spin_lock(&uap->port.lock);
+
+	status = in_le32((u32 *)(uap->port.membase + UART011_MIS));
+	if (status) {
+		do {
+			out_le32((u32 *)(uap->port.membase + UART011_ICR),
+				 (status &
+				  ~(UART011_TXIS|UART011_RTIS|UART011_RXIS)));
+
+			if (status & (UART011_RTIS|UART011_RXIS))
+				acp_serial_rx_chars(uap);
+			if (status & (UART011_DSRMIS|UART011_DCDMIS|
+				      UART011_CTSMIS|UART011_RIMIS))
+				acp_serial_modem_status(uap);
+			if (status & UART011_TXIS)
+				acp_serial_tx_chars(uap);
+
+			if (pass_counter-- == 0)
+				break;
+
+			status =
+				in_le32((u32 *)(uap->port.membase +
+					UART011_MIS));
+		} while (status != 0);
+		handled = 1;
+	}
+
+	spin_unlock(&uap->port.lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+unsigned int acp_serial_get_mctrl(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+	unsigned int result = 0;
+	unsigned int status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
+
+#define TIOCMBIT(uartbit, tiocmbit) do { \
+	if (status & (uartbit))		 \
+		result |= (tiocmbit);    \
+} while (0)
+	TIOCMBIT(UART01x_FR_DCD, TIOCM_CAR);
+	TIOCMBIT(UART01x_FR_DSR, TIOCM_DSR);
+	TIOCMBIT(UART01x_FR_CTS, TIOCM_CTS);
+	TIOCMBIT(UART011_FR_RI, TIOCM_RNG);
+#undef TIOCMBIT
+	return result;
+}
+
+void acp_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+	unsigned int cr;
+
+	cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
+
+#define TIOCMBIT(tiocmbit, uartbit) do { \
+	if (mctrl & tiocmbit)		 \
+		cr |= uartbit;		 \
+	else				 \
+		cr &= ~uartbit;		 \
+} while (0)
+
+	TIOCMBIT(TIOCM_RTS, UART011_CR_RTS);
+	TIOCMBIT(TIOCM_DTR, UART011_CR_DTR);
+	TIOCMBIT(TIOCM_OUT1, UART011_CR_OUT1);
+	TIOCMBIT(TIOCM_OUT2, UART011_CR_OUT2);
+	TIOCMBIT(TIOCM_LOOP, UART011_CR_LBE);
+
+#undef TIOCMBIT
+
+	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
+}
+
+void acp_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+	unsigned long flags;
+	unsigned int lcr_h;
+
+	spin_lock_irqsave(&uap->port.lock, flags);
+	lcr_h = in_le32((u32 *)(uap->port.membase + UART011_LCRH));
+	if (break_state == -1)
+		lcr_h |= UART01x_LCRH_BRK;
+	else
+		lcr_h &= ~UART01x_LCRH_BRK;
+	out_le32((u32 *)(uap->port.membase + UART011_LCRH), lcr_h);
+	spin_unlock_irqrestore(&uap->port.lock, flags);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_poll_get_char
+*/
+
+static int
+acp_serial_poll_get_char(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *) port;
+	unsigned int status;
+
+	do {
+		status = in_le32((u32 *)
+				 (uap->port.membase + UART01x_FR));
+	} while (status & UART01x_FR_RXFE);
+
+	return in_le32((u32 *) (uap->port.membase + UART01x_DR));
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_poll_put_char
+*/
+
+static void
+acp_serial_poll_put_char(struct uart_port *port, unsigned char ch)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	while (in_le32((u32 *) (uap->port.membase + UART01x_FR)) &
+	       UART01x_FR_TXFF) {
+		barrier();
+	}
+
+	acp_serial_wac((u32 *)(uap->port.membase + UART01x_DR), ch,
+			__LINE__);
+}
+#endif /* CONFIG_CONSOLE_POLL */
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_startup
+*/
+
+static int
+acp_serial_startup(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+	unsigned int cr;
+	int retval = 0;
+
+	/*
+	 * Set up the interrupt.
+	 */
+
+	uap->port.irq = irq_create_mapping(NULL, uap->hwirq);
+
+	if (NO_IRQ == uap->port.irq) {
+		pr_err("irq_create_mapping() failed!\n");
+		goto clk_dis;
+	}
+
+	retval = irq_set_irq_type(uap->port.irq, IRQ_TYPE_LEVEL_HIGH);
+
+	if (0 != retval) {
+		pr_err("set_irq_type(%d, 0x%x) failed!\n",
+			uap->port.irq, IRQ_TYPE_LEVEL_HIGH);
+		goto clk_dis;
+	}
+
+	retval = request_irq(uap->port.irq, acp_serial_isr,
+			     IRQF_DISABLED, "uart-pl011", uap);
+
+	if (retval) {
+		pr_err("request_irq(%d) failed!\n", uap->port.irq);
+		goto clk_dis;
+	}
+
+	out_le32((u32 *)(uap->port.membase + UART011_IFLS),
+		 UART011_IFLS_RX4_8|UART011_IFLS_TX4_8);
+
+	/*
+	 * Provoke TX FIFO interrupt into asserting.
+	 */
+	cr = UART01x_CR_UARTEN | UART011_CR_TXE | UART011_CR_LBE;
+	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
+	out_le32((u32 *)(uap->port.membase + UART011_FBRD), 0);
+	out_le32((u32 *)(uap->port.membase + UART011_IBRD), 1);
+	out_le32((u32 *)(uap->port.membase + UART011_LCRH), 0);
+	acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR), 0,
+			__LINE__);
+
+	while (in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
+	       UART01x_FR_BUSY)
+		barrier();
+
+	cr = UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;
+	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
+
+	/*
+	 * initialise the old status of the modem signals
+	 */
+
+	uap->old_status =
+		in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
+		UART01x_FR_MODEM_ANY;
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	spin_lock_irq(&uap->port.lock);
+	uap->interrupt_mask = UART011_RXIM | UART011_RTIM;
+	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
+		 uap->interrupt_mask);
+	spin_unlock_irq(&uap->port.lock);
+
+	return 0;
+
+ clk_dis:
+
+	return retval;
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_shutdown
+*/
+
+static void
+acp_serial_shutdown(struct uart_port *port)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+	unsigned long val;
+
+	/*
+	 * disable all interrupts
+	 */
+	spin_lock_irq(&uap->port.lock);
+	uap->interrupt_mask = 0;
+	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
+		 uap->interrupt_mask);
+	out_le32((u32 *)(uap->port.membase + UART011_ICR), 0xffff);
+	spin_unlock_irq(&uap->port.lock);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(uap->port.irq, uap);
+
+	/*
+	 * disable the port
+	 */
+	out_le32((u32 *)(uap->port.membase + UART011_CR),
+		 UART01x_CR_UARTEN | UART011_CR_TXE);
+
+	/*
+	 * disable break condition and fifos
+	 */
+	val = in_le32((u32 *)(uap->port.membase + UART011_LCRH));
+	val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);
+	out_le32((u32 *)(uap->port.membase + UART011_LCRH), val);
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_set_termios
+*/
+
+static void
+acp_serial_set_termios(struct uart_port *port, struct ktermios *termios,
+			struct ktermios *old)
+{
+	unsigned int lcr_h, old_cr;
+	unsigned long flags;
+	int baud;
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	/*
+	 * Set up the clock, and calculate the divisors.
+	 */
+
+	baud = tty_termios_baud_rate(termios);
+	get_clock_stuff(uap, baud);
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr_h = UART01x_LCRH_WLEN_5;
+		break;
+	case CS6:
+		lcr_h = UART01x_LCRH_WLEN_6;
+		break;
+	case CS7:
+		lcr_h = UART01x_LCRH_WLEN_7;
+		break;
+	default: /* CS8 */
+		lcr_h = UART01x_LCRH_WLEN_8;
+		break;
+	}
+	if (termios->c_cflag & CSTOPB)
+		lcr_h |= UART01x_LCRH_STP2;
+	if (termios->c_cflag & PARENB) {
+		lcr_h |= UART01x_LCRH_PEN;
+		if (!(termios->c_cflag & PARODD))
+			lcr_h |= UART01x_LCRH_EPS;
+	}
+	if (port->fifosize > 1)
+		lcr_h |= UART01x_LCRH_FEN;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = UART011_DR_OE | 255;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= UART011_DR_FE | UART011_DR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= UART011_DR_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= UART011_DR_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= UART011_DR_OE;
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_DR_RX;
+
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		acp_serial_enable_ms(port);
+
+	/* first, disable everything */
+	old_cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
+	out_le32((u32 *)(uap->port.membase + UART011_CR), 0);
+
+	/* Set baud rate */
+#if 1
+	out_le32((u32 *)(uap->port.membase + UART011_FBRD), uap->fbrd);
+	out_le32((u32 *)(uap->port.membase + UART011_IBRD), uap->ibrd);
+#else
+	out_le32((u32 *)(uap->port.membase + UART011_FBRD), 0x13);
+	out_le32((u32 *)(uap->port.membase + UART011_IBRD), 0x598);
+#endif
+
+	/*
+	 * ----------v----------v----------v----------v-----
+	 * NOTE: MUST BE WRITTEN AFTER UARTLCR_M & UARTLCR_L
+	 * ----------^----------^----------^----------^-----
+	 */
+	out_le32((u32 *)(uap->port.membase + UART011_LCRH), lcr_h);
+	out_le32((u32 *)(uap->port.membase + UART011_CR), old_cr);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+const char *acp_serial_type(struct uart_port *port)
+{
+	return port->type == PORT_AMBA ? "AMBA/PL011" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'
+ */
+void acp_serial_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, SZ_4K);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'
+ */
+int acp_serial_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, SZ_4K, "uart-pl011")
+		!= NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+void acp_serial_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_AMBA;
+		acp_serial_request_port(port);
+	}
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+int acp_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)
+		ret = -EINVAL;
+	if (ser->irq < 0 || ser->irq >= nr_irqs)
+		ret = -EINVAL;
+	if (ser->baud_base < 9600)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops amba_acp_pops = {
+	.tx_empty	= acp_serial_tx_empty,
+	.set_mctrl	= acp_serial_set_mctrl,
+	.get_mctrl	= acp_serial_get_mctrl,
+	.stop_tx	= acp_serial_stop_tx,
+	.start_tx	= acp_serial_start_tx,
+	.stop_rx	= acp_serial_stop_rx,
+	.enable_ms	= acp_serial_enable_ms,
+	.break_ctl	= acp_serial_break_ctl,
+	.startup	= acp_serial_startup,
+	.shutdown	= acp_serial_shutdown,
+	.set_termios	= acp_serial_set_termios,
+	.type		= acp_serial_type,
+	.release_port	= acp_serial_release_port,
+	.request_port	= acp_serial_request_port,
+	.config_port	= acp_serial_config_port,
+	.verify_port	= acp_serial_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char = acp_serial_poll_get_char,
+	.poll_put_char = acp_serial_poll_put_char,
+#endif
+};
+
+static struct uart_acp_port *acp_ports[2];
+
+#ifdef CONFIG_SERIAL_ACP_CONSOLE
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_console_putchar
+*/
+
+static void
+acp_serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_acp_port *uap = (struct uart_acp_port *)port;
+
+	while (in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
+	       UART01x_FR_TXFF) {
+		barrier();
+	}
+
+	acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR), ch,
+			__LINE__);
+}
+
+void
+acp_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_acp_port *uap = acp_ports[co->index];
+	unsigned int status, old_cr, new_cr;
+
+	/*clk_enable(uap->clk);*/
+
+	/*
+	 *	First save the CR then disable the interrupts
+	 */
+	old_cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
+	new_cr = old_cr & ~UART011_CR_CTSEN;
+	new_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
+	out_le32((u32 *)(uap->port.membase + UART011_CR), new_cr);
+
+	uart_console_write(&uap->port, s, count, acp_serial_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the TCR
+	 */
+	do {
+		status =
+			in_le32((u32 *)(u32 *)(uap->port.membase + UART01x_FR));
+	} while (status & UART01x_FR_BUSY);
+	out_le32((u32 *)(uap->port.membase + UART011_CR), old_cr);
+
+	/*clk_disable(uap->clk);*/
+}
+
+void __init
+acp_console_get_options(struct uart_acp_port *uap, int *baud,
+			int *parity, int *bits)
+{
+	if (in_le32((u32 *)(u32 *)(uap->port.membase + UART011_CR)) &
+	    UART01x_CR_UARTEN) {
+		unsigned int lcr_h, ibrd, fbrd;
+
+		lcr_h = in_le32((u32 *)(u32 *)(uap->port.membase +
+					       UART011_LCRH));
+
+		*parity = 'n';
+		if (lcr_h & UART01x_LCRH_PEN) {
+			if (lcr_h & UART01x_LCRH_EPS)
+				*parity = 'e';
+			else
+				*parity = 'o';
+		}
+
+		if ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)
+			*bits = 7;
+		else
+			*bits = 8;
+
+		ibrd = in_le32((u32 *)(u32 *)(uap->port.membase +
+					      UART011_IBRD));
+		fbrd = in_le32((u32 *)(u32 *)(uap->port.membase +
+					      UART011_FBRD));
+		*baud = (uap->port.uartclk * 4 / (64 * ibrd + fbrd));
+		*baud += 50;
+		*baud /= 10;
+		*baud *= 10;
+	}
+}
+
+int __init acp_console_setup(struct console *co, char *options)
+{
+	struct uart_acp_port *uap;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	uap = acp_ports[co->index];
+	if (!uap)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		acp_console_get_options(uap, &baud, &parity, &bits);
+
+	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver acp_serial_driver;
+static struct console acp_console = {
+	.name		= "ttyS",
+	.write		= acp_console_write,
+	.device		= uart_console_device,
+	.setup		= acp_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &acp_serial_driver,
+};
+
+static int __init
+acp_console_init(void)
+{
+	register_console(&acp_console);
+
+	return 0;
+}
+
+console_initcall(acp_console_init);
+
+#define ACP_CONSOLE	(&acp_console)
+#else
+#define ACP_CONSOLE	NULL
+#endif
+
+static struct uart_driver acp_serial_driver = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial",
+	.dev_name		= "ttyS",
+	.major			= TTY_MAJOR,
+	.minor			= 64,
+	.nr			= UART_NR,
+	.cons			= ACP_CONSOLE,
+};
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_add_ports
+*/
+
+static int
+acp_serial_add_ports(struct uart_driver *driver)
+{
+	struct uart_acp_port *uap;
+	int i, ret;
+	struct device_node *np = NULL;
+	u64 addr = 0;
+	const u32 *reg, *interrupts, *clk, *speed;
+	int baud_rate = 9600;
+	const int *enabled = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(acp_ports); ++i) {
+		if (acp_ports[i] == NULL)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(acp_ports)) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	uap = kzalloc(sizeof(struct uart_acp_port), GFP_KERNEL);
+
+	if (NULL == uap) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	np = of_find_node_by_type(np, "serial");
+
+	while (np && !of_device_is_compatible(np, "acp-uart0"))
+		np = of_find_node_by_type(np, "serial");
+
+	if (np)
+		enabled = of_get_property(np, "enabled", NULL);
+
+	if (!enabled) {
+		/*
+		  Older AXXIA U-Boot package (prior to 4.8.1.36).
+
+		  Only use UART0.  The timer registers are defined
+		  differently in the device tree.
+		*/
+		uap->timer_base = ioremap(0x002000408040ULL, 0x20);
+	} else {
+		/*
+		  Newer AXXIA U-Boot package (4.8.1.36 on).
+
+		  Only use a serial port if it is enabled.
+		*/
+
+		if (!np || (0 == *enabled)) {
+			np = NULL;
+			np = of_find_node_by_type(np, "serial");
+
+			while (np && !of_device_is_compatible(np, "acp-uart1"))
+				np = of_find_node_by_type(np, "serial");
+
+			if (np)
+				enabled = of_get_property(np, "enabled", NULL);
+		}
+
+		if (np && (0 != *enabled)) {
+			reg = of_get_property(np, "clock-reg", NULL);
+
+			if (reg) {
+				addr = of_translate_address(np, reg);
+				if (addr == OF_BAD_ADDR)
+					addr = 0;
+			}
+
+			if (addr)
+				uap->timer_base = ioremap(addr, reg[1]);
+			else {
+				pr_err("timer io address not found\n");
+				ret = -ENOMEM;
+			}
+		}
+	}
+
+	if (np) {
+		reg = of_get_property(np, "reg", NULL);
+
+		if (reg) {
+			addr = of_translate_address(np, reg);
+			if (addr == OF_BAD_ADDR)
+				addr = 0;
+		}
+
+		if (addr)
+			uap->port.membase = ioremap(addr, reg[1]);
+		else {
+			pr_err("serial io address not found\n");
+			ret = -ENOMEM;
+		}
+
+		interrupts = of_get_property(np, "interrupts", NULL);
+
+		if (interrupts)
+			uap->hwirq = interrupts[0];
+		else {
+			pr_err("serial irq not found\n");
+			uap->hwirq = 22;
+		}
+
+		clk = of_get_property(np, "clock-frequency", NULL);
+
+		if (clk && *clk)
+			per_clock = *clk;
+		else {
+			pr_err("serial clock frequency not found\n");
+			per_clock = 200000000;
+		}
+
+		speed = of_get_property(np, "current-speed", NULL);
+
+		if (speed && *speed)
+			baud_rate = *speed;
+		else {
+			pr_err("current speed not found\n");
+			baud_rate = 9600;
+		}
+	} else {
+		ret = -ENOMEM;
+	}
+
+	np = of_find_compatible_node(NULL, NULL, "axxia,acp3500");
+
+	if (NULL == np) {
+		unsigned long divisor;
+
+		/*
+		  In the 3500 case, the peripheral clock is connected
+		  directly to the UART.  If this isn't 3500, set up
+		  the second timer (which is in between the peripheral
+		  clock and the UART) and adjust per_clock
+		  accordingly.
+		*/
+
+		if (1000000 < per_clock) {
+			divisor = per_clock / 25000000;
+			per_clock = 25000000;
+		} else {
+			/* Emulation is much slower... */
+			divisor = per_clock / 3250000;
+			per_clock = 3250000;
+		}
+
+		--divisor;
+
+		if (divisor != in_le32(uap->timer_base + TIMER_LOAD)) {
+			while (0 ==
+			       (in_le32((const volatile unsigned *)
+					(uap->port.membase + UART01x_FR)) &
+				UART011_FR_TXFE))
+				;
+
+			while (0 !=
+			       (in_le32((const volatile unsigned *)
+					(uap->port.membase + UART01x_FR)) &
+				UART01x_FR_BUSY))
+				;
+
+			out_le32((uap->timer_base + TIMER_CONTROL), 0);
+			out_le32((uap->timer_base + TIMER_LOAD), divisor);
+			out_le32((uap->timer_base + TIMER_CONTROL),
+				 (TIMER_CONTROL_ENABLE |
+				  TIMER_CONTROL_MODE));
+		}
+	}
+
+	dt_baud_rate = baud_rate;
+	uap->port.iotype = UPIO_MEM;
+	uap->port.fifosize = 16;
+	uap->port.ops = &amba_acp_pops;
+	uap->port.flags = UPF_BOOT_AUTOCONF;
+	uap->port.line = i;
+	get_clock_stuff(uap, baud_rate);
+	acp_ports[i] = uap;
+	ret = uart_add_one_port(driver, &uap->port);
+
+	if (0 != ret) {
+		acp_ports[i] = NULL;
+		kfree(uap);
+	}
+
+ out:
+	return ret;
+}
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_delete_ports
+*/
+
+static int
+acp_serial_delete_ports(struct uart_driver *driver)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(acp_ports); ++i) {
+		if (NULL != acp_ports[i]) {
+			uart_remove_one_port(driver,
+					     &(acp_ports[i])->port);
+			kfree(acp_ports[i]);
+			acp_ports[i] = NULL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Linux module stuff.
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  acp_init
+*/
+
+int __init
+acp_serial_init(void)
+{
+	int ret;
+
+	pr_info("Serial: ACP Serial Driver\n");
+
+	/* Clear the ports array */
+	memset((void *) &acp_ports[0], 0,
+		sizeof(struct uart_acp_port *) * ARRAY_SIZE(acp_ports));
+
+	/* Register the driver */
+	ret = uart_register_driver(&acp_serial_driver);
+
+	if (0 != ret) {
+		pr_err("uart_register_driver() failed with %d\n", ret);
+		goto out;
+	}
+
+	/* Add ports */
+	ret = acp_serial_add_ports(&acp_serial_driver);
+
+	if (0 != ret) {
+		pr_err("acp_serial_add_ports() failed with %d\n", ret);
+		goto out;
+	}
+
+ out:
+	return ret;
+}
+module_init(acp_serial_init);
+
+/*
+  ----------------------------------------------------------------------
+  acp_serial_exit
+*/
+
+void __exit
+acp_serial_exit(void)
+{
+	acp_serial_delete_ports(&acp_serial_driver);
+	uart_unregister_driver(&acp_serial_driver);
+}
+module_exit(acp_serial_exit);
+
+MODULE_AUTHOR("INTEL Corporation");
+MODULE_DESCRIPTION("ARM AMBA serial port on PPC476 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/tty/serial/lsi_acp_serial.c b/drivers/tty/serial/lsi_acp_serial.c
deleted file mode 100644
index 9377103..0000000
--- a/drivers/tty/serial/lsi_acp_serial.c
+++ /dev/null
@@ -1,1247 +0,0 @@
-/*
- *  drivers/tty/serial/lsi_acp_serial.c
- *
- *  Driver for AMBA serial ports on LSI's PPC based ACP.
- *
- *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
- *
- *  Copyright 1999 ARM Limited
- *  Copyright (C) 2000 Deep Blue Solutions Ltd.
- *  Copyright 2009 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.
- *
- * This is a generic driver for ARM AMBA-type serial ports.  They
- * have a lot of 16550-like features, but are not register compatible.
- * Note that although they do have CTS, DCD and DSR inputs, they do
- * not have an RI input, nor do they have DTR or RTS outputs.  If
- * required, these have to be supplied via some other means (eg, GPIO)
- * and hooked into this driver.
- */
-
-#if defined(CONFIG_SERIAL_ACP_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
-#define SUPPORT_SYSRQ
-#endif
-
-#include <linux/module.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-#include <linux/console.h>
-#include <linux/sysrq.h>
-#include <linux/device.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial_core.h>
-#include <linux/serial.h>
-#include <linux/slab.h>
-#include <linux/amba/bus.h>
-#include <linux/amba/serial.h>
-#include <linux/irq.h>
-#include <linux/of.h>
-#include <linux/io.h>
-
-#define SZ_4K (4*1024)
-#define UART_NR			2
-#define SERIAL_AMBA_MAJOR	204
-#define SERIAL_AMBA_MINOR	64
-#define SERIAL_AMBA_NR		UART_NR
-#define AMBA_ISR_PASS_LIMIT	256
-#define UART_DR_ERROR		\
-(UART011_DR_OE|UART011_DR_BE|UART011_DR_PE|UART011_DR_FE)
-#define UART_DUMMY_DR_RX	(1 << 16)
-
-#define MAX_BAUD_RATE 115200
-
-static int dt_baud_rate;
-static unsigned long per_clock;
-
-/*
-  ======================================================================
-  ======================================================================
-  A modified uart_port structure.
-  ======================================================================
-  ======================================================================
-*/
-
-struct uart_acp_port {
-	struct uart_port port;
-	irq_hw_number_t hwirq;
-	unsigned int interrupt_mask;
-	unsigned int old_status;
-	void *timer_base;
-	unsigned short ibrd;
-	unsigned short fbrd;
-};
-
-/*
-  ======================================================================
-  ======================================================================
-  Both UARTs share the same clock input, the output of the 2nd timer,
-  or timer 1, from the APB Dual Input Timers (there are two of these,
-  thus 4 timers).
-  ======================================================================
-  ======================================================================
-*/
-
-#define TIMER_LOAD		       0x00
-#define TIMER_VALUE		       0x04
-#define TIMER_CONTROL		       0x08
-#define TIMER_CONTROL_ENABLE	       0x80
-#define TIMER_CONTROL_MODE	       0x40
-#define TIMER_CONTROL_INTERRUPT_ENABLE 0x20
-#define TIMER_CONTROL_OUTPUT_MODE      0x10
-#define TIMER_CONTROL_PRESCALER	       0x0c
-#define TIMER_CONTROL_SIZE	       0x02
-#define TIMER_CONTROL_ONE_SHOT	       0x01
-#define TIMER_INTCLR		       0x0C
-#define TIMER_RIS		       0x10
-#define TIMER_MIS		       0x14
-#define TIMER_BGLOAD		       0x18
-
-/*
-  ----------------------------------------------------------------------
-  get_clock_stuff
-*/
-
-static int
-get_clock_stuff(struct uart_acp_port *port, int baud_rate)
-{
-	unsigned long ibrd;
-	unsigned long fbrd;
-
-	ibrd = per_clock / (16 * baud_rate);
-
-	/*
-	 * The following formula is from the ARM document (ARM DDI 0183E).
-	 *
-	 * Baud Rate Divisor = (Uart Clock / (16 * Baud Rate))
-	 *
-	 * Baud Rate Divisor is then split into integral and fractional
-	 * parts.  The IBRD value is simply the itegral part.  The FBRD is
-	 * calculated as follows.
-	 *
-	 * FBRD = fractional part of the Baud Rate Divisor * 64 + 0.5
-	 *
-	 * The fractional part of the Baud Rate Divisor can be represented as
-	 * follows:
-	 *
-	 *    (Uart Clock % (16 * baud_rate)) / (16 * baud_rate)
-	 *
-	 * As long as the division isn't done until the end. So, the above
-	 * "* 64 + 0.5" is the FBRD. Also note that x/y + 1/2 = (2x+y)/2y.
-	 * This *  leads to:
-	 *
-	 *    ((Uart Clock % (16 * baud_rate)) * 64 * 2 + (16 * baud_rate))
-	 *  -----------------------------------------------------------------
-	 *                     2 * (16 * baud_rate)
-	 */
-
-	port->port.uartclk = per_clock;
-
-	fbrd = port->port.uartclk % (16 * baud_rate);
-	fbrd *= 128;
-	fbrd += (16 * baud_rate);
-	fbrd /= (2 * (16 * baud_rate));
-
-	port->ibrd = (unsigned short) ibrd;
-	port->fbrd = (unsigned short) fbrd;
-
-	return 0;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Serial operations.
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ------------------------------------------------------------------------------
-  acp_serial_wac
-
-  This was added to allow an easy debugging breakpoint.
-*/
-
-static void
-acp_serial_wac(u32 *address, int character, u32 line)
-{
-	out_le32(address, character);
-}
-
-/*
-  ------------------------------------------------------------------------------
-  acp_serial_tx_empty
-*/
-
-static unsigned int
-acp_serial_tx_empty(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *) port;
-	unsigned int status =
-		in_le32((u32 *)(uap->port.membase + UART01x_FR));
-	return status &
-		(UART01x_FR_BUSY | UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_stop_tx
-*/
-
-static void
-acp_serial_stop_tx(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	uap->interrupt_mask &= ~UART011_TXIM;
-	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
-		 uap->interrupt_mask);
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_start_tx
-*/
-
-static void
-acp_serial_start_tx(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	uap->interrupt_mask |= UART011_TXIM;
-	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
-		 uap->interrupt_mask);
-}
-
-void acp_serial_stop_rx(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	uap->interrupt_mask &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|
-				 UART011_PEIM|UART011_BEIM|UART011_OEIM);
-	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
-		 uap->interrupt_mask);
-}
-
-void acp_serial_enable_ms(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	uap->interrupt_mask |=
-		UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;
-	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
-		 uap->interrupt_mask);
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_rx_chars
-*/
-
-static void
-acp_serial_rx_chars(struct uart_acp_port *uap)
-{
-	unsigned int status, ch, flag, max_count = 256;
-
-	status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
-	while ((status & UART01x_FR_RXFE) == 0 && max_count--) {
-		ch = in_le32((u32 *)(uap->port.membase + UART01x_DR)) |
-			UART_DUMMY_DR_RX;
-		flag = TTY_NORMAL;
-		uap->port.icount.rx++;
-
-		/*
-		 * Note that the error handling code is
-		 * out of the main execution path
-		 */
-		if (unlikely(ch & UART_DR_ERROR)) {
-			if (ch & UART011_DR_BE) {
-				ch &= ~(UART011_DR_FE | UART011_DR_PE);
-				uap->port.icount.brk++;
-				if (uart_handle_break(&uap->port))
-					goto ignore_char;
-			} else if (ch & UART011_DR_PE)
-				uap->port.icount.parity++;
-			else if (ch & UART011_DR_FE)
-				uap->port.icount.frame++;
-			if (ch & UART011_DR_OE)
-				uap->port.icount.overrun++;
-
-			ch &= uap->port.read_status_mask;
-
-			if (ch & UART011_DR_BE)
-				flag = TTY_BREAK;
-			else if (ch & UART011_DR_PE)
-				flag = TTY_PARITY;
-			else if (ch & UART011_DR_FE)
-				flag = TTY_FRAME;
-		}
-
-		if (uart_handle_sysrq_char(&uap->port, ch & 255))
-			goto ignore_char;
-
-		uart_insert_char(&uap->port, ch, UART011_DR_OE, ch, flag);
-
-ignore_char:
-		status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
-	}
-	spin_unlock(&uap->port.lock);
-	tty_flip_buffer_push(&uap->port.state->port);
-	spin_lock(&uap->port.lock);
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_tx_chars
-*/
-
-static void
-acp_serial_tx_chars(struct uart_acp_port *uap)
-{
-	struct circ_buf *xmit = &uap->port.state->xmit;
-	int count;
-
-	if (uap->port.x_char) {
-		acp_serial_wac((u32 *)(uap->port.membase + UART01x_DR),
-				uap->port.x_char, __LINE__);
-		uap->port.icount.tx++;
-		uap->port.x_char = 0;
-		return;
-	}
-	if (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {
-		acp_serial_stop_tx(&uap->port);
-		return;
-	}
-
-	count = uap->port.fifosize >> 1;
-	do {
-		acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR),
-				xmit->buf[xmit->tail], __LINE__);
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		uap->port.icount.tx++;
-		if (uart_circ_empty(xmit))
-			break;
-	} while (--count > 0);
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&uap->port);
-
-	if (uart_circ_empty(xmit))
-		acp_serial_stop_tx(&uap->port);
-}
-
-void acp_serial_modem_status(struct uart_acp_port *uap)
-{
-	unsigned int status, delta;
-
-	status = in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
-		UART01x_FR_MODEM_ANY;
-
-	delta = status ^ uap->old_status;
-	uap->old_status = status;
-
-	if (!delta)
-		return;
-
-	if (delta & UART01x_FR_DCD)
-		uart_handle_dcd_change(&uap->port, status & UART01x_FR_DCD);
-
-	if (delta & UART01x_FR_DSR)
-		uap->port.icount.dsr++;
-
-	if (delta & UART01x_FR_CTS)
-		uart_handle_cts_change(&uap->port, status & UART01x_FR_CTS);
-
-	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
-}
-
-/*
-  ------------------------------------------------------------------------------
-  acp_serial_isr
-*/
-
-static irqreturn_t
-acp_serial_isr(int irq, void *dev_id)
-{
-	struct uart_acp_port *uap = dev_id;
-	unsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;
-	int handled = 0;
-
-	spin_lock(&uap->port.lock);
-
-	status = in_le32((u32 *)(uap->port.membase + UART011_MIS));
-	if (status) {
-		do {
-			out_le32((u32 *)(uap->port.membase + UART011_ICR),
-				 (status &
-				  ~(UART011_TXIS|UART011_RTIS|UART011_RXIS)));
-
-			if (status & (UART011_RTIS|UART011_RXIS))
-				acp_serial_rx_chars(uap);
-			if (status & (UART011_DSRMIS|UART011_DCDMIS|
-				      UART011_CTSMIS|UART011_RIMIS))
-				acp_serial_modem_status(uap);
-			if (status & UART011_TXIS)
-				acp_serial_tx_chars(uap);
-
-			if (pass_counter-- == 0)
-				break;
-
-			status =
-				in_le32((u32 *)(uap->port.membase +
-					UART011_MIS));
-		} while (status != 0);
-		handled = 1;
-	}
-
-	spin_unlock(&uap->port.lock);
-
-	return IRQ_RETVAL(handled);
-}
-
-unsigned int acp_serial_get_mctrl(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-	unsigned int result = 0;
-	unsigned int status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
-
-#define TIOCMBIT(uartbit, tiocmbit) do { \
-	if (status & (uartbit))		 \
-		result |= (tiocmbit);    \
-} while (0)
-	TIOCMBIT(UART01x_FR_DCD, TIOCM_CAR);
-	TIOCMBIT(UART01x_FR_DSR, TIOCM_DSR);
-	TIOCMBIT(UART01x_FR_CTS, TIOCM_CTS);
-	TIOCMBIT(UART011_FR_RI, TIOCM_RNG);
-#undef TIOCMBIT
-	return result;
-}
-
-void acp_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-	unsigned int cr;
-
-	cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
-
-#define TIOCMBIT(tiocmbit, uartbit) do { \
-	if (mctrl & tiocmbit)		 \
-		cr |= uartbit;		 \
-	else				 \
-		cr &= ~uartbit;		 \
-} while (0)
-
-	TIOCMBIT(TIOCM_RTS, UART011_CR_RTS);
-	TIOCMBIT(TIOCM_DTR, UART011_CR_DTR);
-	TIOCMBIT(TIOCM_OUT1, UART011_CR_OUT1);
-	TIOCMBIT(TIOCM_OUT2, UART011_CR_OUT2);
-	TIOCMBIT(TIOCM_LOOP, UART011_CR_LBE);
-
-#undef TIOCMBIT
-
-	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
-}
-
-void acp_serial_break_ctl(struct uart_port *port, int break_state)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-	unsigned long flags;
-	unsigned int lcr_h;
-
-	spin_lock_irqsave(&uap->port.lock, flags);
-	lcr_h = in_le32((u32 *)(uap->port.membase + UART011_LCRH));
-	if (break_state == -1)
-		lcr_h |= UART01x_LCRH_BRK;
-	else
-		lcr_h &= ~UART01x_LCRH_BRK;
-	out_le32((u32 *)(uap->port.membase + UART011_LCRH), lcr_h);
-	spin_unlock_irqrestore(&uap->port.lock, flags);
-}
-
-#ifdef CONFIG_CONSOLE_POLL
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_poll_get_char
-*/
-
-static int
-acp_serial_poll_get_char(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *) port;
-	unsigned int status;
-
-	do {
-		status = in_le32((u32 *)
-				 (uap->port.membase + UART01x_FR));
-	} while (status & UART01x_FR_RXFE);
-
-	return in_le32((u32 *) (uap->port.membase + UART01x_DR));
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_poll_put_char
-*/
-
-static void
-acp_serial_poll_put_char(struct uart_port *port, unsigned char ch)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	while (in_le32((u32 *) (uap->port.membase + UART01x_FR)) &
-	       UART01x_FR_TXFF) {
-		barrier();
-	}
-
-	acp_serial_wac((u32 *)(uap->port.membase + UART01x_DR), ch,
-			__LINE__);
-}
-#endif /* CONFIG_CONSOLE_POLL */
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_startup
-*/
-
-static int
-acp_serial_startup(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-	unsigned int cr;
-	int retval = 0;
-
-	/*
-	 * Set up the interrupt.
-	 */
-
-	uap->port.irq = irq_create_mapping(NULL, uap->hwirq);
-
-	if (NO_IRQ == uap->port.irq) {
-		pr_err("irq_create_mapping() failed!\n");
-		goto clk_dis;
-	}
-
-	retval = irq_set_irq_type(uap->port.irq, IRQ_TYPE_LEVEL_HIGH);
-
-	if (0 != retval) {
-		pr_err("set_irq_type(%d, 0x%x) failed!\n",
-			uap->port.irq, IRQ_TYPE_LEVEL_HIGH);
-		goto clk_dis;
-	}
-
-	retval = request_irq(uap->port.irq, acp_serial_isr,
-			     IRQF_DISABLED, "uart-pl011", uap);
-
-	if (retval) {
-		pr_err("request_irq(%d) failed!\n", uap->port.irq);
-		goto clk_dis;
-	}
-
-	out_le32((u32 *)(uap->port.membase + UART011_IFLS),
-		 UART011_IFLS_RX4_8|UART011_IFLS_TX4_8);
-
-	/*
-	 * Provoke TX FIFO interrupt into asserting.
-	 */
-	cr = UART01x_CR_UARTEN | UART011_CR_TXE | UART011_CR_LBE;
-	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
-	out_le32((u32 *)(uap->port.membase + UART011_FBRD), 0);
-	out_le32((u32 *)(uap->port.membase + UART011_IBRD), 1);
-	out_le32((u32 *)(uap->port.membase + UART011_LCRH), 0);
-	acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR), 0,
-			__LINE__);
-
-	while (in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
-	       UART01x_FR_BUSY)
-		barrier();
-
-	cr = UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;
-	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
-
-	/*
-	 * initialise the old status of the modem signals
-	 */
-
-	uap->old_status =
-		in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
-		UART01x_FR_MODEM_ANY;
-
-	/*
-	 * Finally, enable interrupts
-	 */
-	spin_lock_irq(&uap->port.lock);
-	uap->interrupt_mask = UART011_RXIM | UART011_RTIM;
-	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
-		 uap->interrupt_mask);
-	spin_unlock_irq(&uap->port.lock);
-
-	return 0;
-
- clk_dis:
-
-	return retval;
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_shutdown
-*/
-
-static void
-acp_serial_shutdown(struct uart_port *port)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-	unsigned long val;
-
-	/*
-	 * disable all interrupts
-	 */
-	spin_lock_irq(&uap->port.lock);
-	uap->interrupt_mask = 0;
-	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
-		 uap->interrupt_mask);
-	out_le32((u32 *)(uap->port.membase + UART011_ICR), 0xffff);
-	spin_unlock_irq(&uap->port.lock);
-
-	/*
-	 * Free the interrupt
-	 */
-	free_irq(uap->port.irq, uap);
-
-	/*
-	 * disable the port
-	 */
-	out_le32((u32 *)(uap->port.membase + UART011_CR),
-		 UART01x_CR_UARTEN | UART011_CR_TXE);
-
-	/*
-	 * disable break condition and fifos
-	 */
-	val = in_le32((u32 *)(uap->port.membase + UART011_LCRH));
-	val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);
-	out_le32((u32 *)(uap->port.membase + UART011_LCRH), val);
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_set_termios
-*/
-
-static void
-acp_serial_set_termios(struct uart_port *port, struct ktermios *termios,
-			struct ktermios *old)
-{
-	unsigned int lcr_h, old_cr;
-	unsigned long flags;
-	int baud;
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	/*
-	 * Set up the clock, and calculate the divisors.
-	 */
-
-	baud = tty_termios_baud_rate(termios);
-	get_clock_stuff(uap, baud);
-
-	switch (termios->c_cflag & CSIZE) {
-	case CS5:
-		lcr_h = UART01x_LCRH_WLEN_5;
-		break;
-	case CS6:
-		lcr_h = UART01x_LCRH_WLEN_6;
-		break;
-	case CS7:
-		lcr_h = UART01x_LCRH_WLEN_7;
-		break;
-	default: /* CS8 */
-		lcr_h = UART01x_LCRH_WLEN_8;
-		break;
-	}
-	if (termios->c_cflag & CSTOPB)
-		lcr_h |= UART01x_LCRH_STP2;
-	if (termios->c_cflag & PARENB) {
-		lcr_h |= UART01x_LCRH_PEN;
-		if (!(termios->c_cflag & PARODD))
-			lcr_h |= UART01x_LCRH_EPS;
-	}
-	if (port->fifosize > 1)
-		lcr_h |= UART01x_LCRH_FEN;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	/*
-	 * Update the per-port timeout.
-	 */
-	uart_update_timeout(port, termios->c_cflag, baud);
-
-	port->read_status_mask = UART011_DR_OE | 255;
-	if (termios->c_iflag & INPCK)
-		port->read_status_mask |= UART011_DR_FE | UART011_DR_PE;
-	if (termios->c_iflag & (BRKINT | PARMRK))
-		port->read_status_mask |= UART011_DR_BE;
-
-	/*
-	 * Characters to ignore
-	 */
-	port->ignore_status_mask = 0;
-	if (termios->c_iflag & IGNPAR)
-		port->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;
-	if (termios->c_iflag & IGNBRK) {
-		port->ignore_status_mask |= UART011_DR_BE;
-		/*
-		 * If we're ignoring parity and break indicators,
-		 * ignore overruns too (for real raw support).
-		 */
-		if (termios->c_iflag & IGNPAR)
-			port->ignore_status_mask |= UART011_DR_OE;
-	}
-
-	/*
-	 * Ignore all characters if CREAD is not set.
-	 */
-	if ((termios->c_cflag & CREAD) == 0)
-		port->ignore_status_mask |= UART_DUMMY_DR_RX;
-
-	if (UART_ENABLE_MS(port, termios->c_cflag))
-		acp_serial_enable_ms(port);
-
-	/* first, disable everything */
-	old_cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
-	out_le32((u32 *)(uap->port.membase + UART011_CR), 0);
-
-	/* Set baud rate */
-#if 1
-	out_le32((u32 *)(uap->port.membase + UART011_FBRD), uap->fbrd);
-	out_le32((u32 *)(uap->port.membase + UART011_IBRD), uap->ibrd);
-#else
-	out_le32((u32 *)(uap->port.membase + UART011_FBRD), 0x13);
-	out_le32((u32 *)(uap->port.membase + UART011_IBRD), 0x598);
-#endif
-
-	/*
-	 * ----------v----------v----------v----------v-----
-	 * NOTE: MUST BE WRITTEN AFTER UARTLCR_M & UARTLCR_L
-	 * ----------^----------^----------^----------^-----
-	 */
-	out_le32((u32 *)(uap->port.membase + UART011_LCRH), lcr_h);
-	out_le32((u32 *)(uap->port.membase + UART011_CR), old_cr);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-const char *acp_serial_type(struct uart_port *port)
-{
-	return port->type == PORT_AMBA ? "AMBA/PL011" : NULL;
-}
-
-/*
- * Release the memory region(s) being used by 'port'
- */
-void acp_serial_release_port(struct uart_port *port)
-{
-	release_mem_region(port->mapbase, SZ_4K);
-}
-
-/*
- * Request the memory region(s) being used by 'port'
- */
-int acp_serial_request_port(struct uart_port *port)
-{
-	return request_mem_region(port->mapbase, SZ_4K, "uart-pl011")
-		!= NULL ? 0 : -EBUSY;
-}
-
-/*
- * Configure/autoconfigure the port.
- */
-void acp_serial_config_port(struct uart_port *port, int flags)
-{
-	if (flags & UART_CONFIG_TYPE) {
-		port->type = PORT_AMBA;
-		acp_serial_request_port(port);
-	}
-}
-
-/*
- * verify the new serial_struct (for TIOCSSERIAL).
- */
-int acp_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
-{
-	int ret = 0;
-
-	if (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)
-		ret = -EINVAL;
-	if (ser->irq < 0 || ser->irq >= nr_irqs)
-		ret = -EINVAL;
-	if (ser->baud_base < 9600)
-		ret = -EINVAL;
-	return ret;
-}
-
-static struct uart_ops amba_acp_pops = {
-	.tx_empty	= acp_serial_tx_empty,
-	.set_mctrl	= acp_serial_set_mctrl,
-	.get_mctrl	= acp_serial_get_mctrl,
-	.stop_tx	= acp_serial_stop_tx,
-	.start_tx	= acp_serial_start_tx,
-	.stop_rx	= acp_serial_stop_rx,
-	.enable_ms	= acp_serial_enable_ms,
-	.break_ctl	= acp_serial_break_ctl,
-	.startup	= acp_serial_startup,
-	.shutdown	= acp_serial_shutdown,
-	.set_termios	= acp_serial_set_termios,
-	.type		= acp_serial_type,
-	.release_port	= acp_serial_release_port,
-	.request_port	= acp_serial_request_port,
-	.config_port	= acp_serial_config_port,
-	.verify_port	= acp_serial_verify_port,
-#ifdef CONFIG_CONSOLE_POLL
-	.poll_get_char = acp_serial_poll_get_char,
-	.poll_put_char = acp_serial_poll_put_char,
-#endif
-};
-
-static struct uart_acp_port *acp_ports[2];
-
-#ifdef CONFIG_SERIAL_ACP_CONSOLE
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_console_putchar
-*/
-
-static void
-acp_serial_console_putchar(struct uart_port *port, int ch)
-{
-	struct uart_acp_port *uap = (struct uart_acp_port *)port;
-
-	while (in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
-	       UART01x_FR_TXFF) {
-		barrier();
-	}
-
-	acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR), ch,
-			__LINE__);
-}
-
-void
-acp_console_write(struct console *co, const char *s, unsigned int count)
-{
-	struct uart_acp_port *uap = acp_ports[co->index];
-	unsigned int status, old_cr, new_cr;
-
-	/*clk_enable(uap->clk);*/
-
-	/*
-	 *	First save the CR then disable the interrupts
-	 */
-	old_cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
-	new_cr = old_cr & ~UART011_CR_CTSEN;
-	new_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
-	out_le32((u32 *)(uap->port.membase + UART011_CR), new_cr);
-
-	uart_console_write(&uap->port, s, count, acp_serial_console_putchar);
-
-	/*
-	 *	Finally, wait for transmitter to become empty
-	 *	and restore the TCR
-	 */
-	do {
-		status =
-			in_le32((u32 *)(u32 *)(uap->port.membase + UART01x_FR));
-	} while (status & UART01x_FR_BUSY);
-	out_le32((u32 *)(uap->port.membase + UART011_CR), old_cr);
-
-	/*clk_disable(uap->clk);*/
-}
-
-void __init
-acp_console_get_options(struct uart_acp_port *uap, int *baud,
-			int *parity, int *bits)
-{
-	if (in_le32((u32 *)(u32 *)(uap->port.membase + UART011_CR)) &
-	    UART01x_CR_UARTEN) {
-		unsigned int lcr_h, ibrd, fbrd;
-
-		lcr_h = in_le32((u32 *)(u32 *)(uap->port.membase +
-					       UART011_LCRH));
-
-		*parity = 'n';
-		if (lcr_h & UART01x_LCRH_PEN) {
-			if (lcr_h & UART01x_LCRH_EPS)
-				*parity = 'e';
-			else
-				*parity = 'o';
-		}
-
-		if ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)
-			*bits = 7;
-		else
-			*bits = 8;
-
-		ibrd = in_le32((u32 *)(u32 *)(uap->port.membase +
-					      UART011_IBRD));
-		fbrd = in_le32((u32 *)(u32 *)(uap->port.membase +
-					      UART011_FBRD));
-		*baud = (uap->port.uartclk * 4 / (64 * ibrd + fbrd));
-		*baud += 50;
-		*baud /= 10;
-		*baud *= 10;
-	}
-}
-
-int __init acp_console_setup(struct console *co, char *options)
-{
-	struct uart_acp_port *uap;
-	int baud = 9600;
-	int bits = 8;
-	int parity = 'n';
-	int flow = 'n';
-
-	/*
-	 * Check whether an invalid uart number has been specified, and
-	 * if so, search for the first available port that does have
-	 * console support.
-	 */
-	if (co->index >= UART_NR)
-		co->index = 0;
-	uap = acp_ports[co->index];
-	if (!uap)
-		return -ENODEV;
-
-	if (options)
-		uart_parse_options(options, &baud, &parity, &bits, &flow);
-	else
-		acp_console_get_options(uap, &baud, &parity, &bits);
-
-	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
-}
-
-static struct uart_driver acp_serial_driver;
-static struct console acp_console = {
-	.name		= "ttyS",
-	.write		= acp_console_write,
-	.device		= uart_console_device,
-	.setup		= acp_console_setup,
-	.flags		= CON_PRINTBUFFER,
-	.index		= -1,
-	.data		= &acp_serial_driver,
-};
-
-static int __init
-acp_console_init(void)
-{
-	register_console(&acp_console);
-
-	return 0;
-}
-
-console_initcall(acp_console_init);
-
-#define ACP_CONSOLE	(&acp_console)
-#else
-#define ACP_CONSOLE	NULL
-#endif
-
-static struct uart_driver acp_serial_driver = {
-	.owner			= THIS_MODULE,
-	.driver_name		= "serial",
-	.dev_name		= "ttyS",
-	.major			= TTY_MAJOR,
-	.minor			= 64,
-	.nr			= UART_NR,
-	.cons			= ACP_CONSOLE,
-};
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_add_ports
-*/
-
-static int
-acp_serial_add_ports(struct uart_driver *driver)
-{
-	struct uart_acp_port *uap;
-	int i, ret;
-	struct device_node *np = NULL;
-	u64 addr = 0;
-	const u32 *reg, *interrupts, *clk, *speed;
-	int baud_rate = 9600;
-	const int *enabled = NULL;
-
-	for (i = 0; i < ARRAY_SIZE(acp_ports); ++i) {
-		if (acp_ports[i] == NULL)
-			break;
-	}
-
-	if (i == ARRAY_SIZE(acp_ports)) {
-		ret = -EBUSY;
-		goto out;
-	}
-
-	uap = kzalloc(sizeof(struct uart_acp_port), GFP_KERNEL);
-
-	if (NULL == uap) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	np = of_find_node_by_type(np, "serial");
-
-	while (np && !of_device_is_compatible(np, "acp-uart0"))
-		np = of_find_node_by_type(np, "serial");
-
-	if (np)
-		enabled = of_get_property(np, "enabled", NULL);
-
-	if (!enabled) {
-		/*
-		  Older LSI U-Boot package (prior to 4.8.1.36).
-
-		  Only use UART0.  The timer registers are defined
-		  differently in the device tree.
-		*/
-		uap->timer_base = ioremap(0x002000408040ULL, 0x20);
-	} else {
-		/*
-		  Newer LSI U-Boot package (4.8.1.36 on).
-
-		  Only use a serial port if it is enabled.
-		*/
-
-		if (!np || (0 == *enabled)) {
-			np = NULL;
-			np = of_find_node_by_type(np, "serial");
-
-			while (np && !of_device_is_compatible(np, "acp-uart1"))
-				np = of_find_node_by_type(np, "serial");
-
-			if (np)
-				enabled = of_get_property(np, "enabled", NULL);
-		}
-
-		if (np && (0 != *enabled)) {
-			reg = of_get_property(np, "clock-reg", NULL);
-
-			if (reg) {
-				addr = of_translate_address(np, reg);
-				if (addr == OF_BAD_ADDR)
-					addr = 0;
-			}
-
-			if (addr)
-				uap->timer_base = ioremap(addr, reg[1]);
-			else {
-				pr_err("timer io address not found\n");
-				ret = -ENOMEM;
-			}
-		}
-	}
-
-	if (np) {
-		reg = of_get_property(np, "reg", NULL);
-
-		if (reg) {
-			addr = of_translate_address(np, reg);
-			if (addr == OF_BAD_ADDR)
-				addr = 0;
-		}
-
-		if (addr)
-			uap->port.membase = ioremap(addr, reg[1]);
-		else {
-			pr_err("serial io address not found\n");
-			ret = -ENOMEM;
-		}
-
-		interrupts = of_get_property(np, "interrupts", NULL);
-
-		if (interrupts)
-			uap->hwirq = interrupts[0];
-		else {
-			pr_err("serial irq not found\n");
-			uap->hwirq = 22;
-		}
-
-		clk = of_get_property(np, "clock-frequency", NULL);
-
-		if (clk && *clk)
-			per_clock = *clk;
-		else {
-			pr_err("serial clock frequency not found\n");
-			per_clock = 200000000;
-		}
-
-		speed = of_get_property(np, "current-speed", NULL);
-
-		if (speed && *speed)
-			baud_rate = *speed;
-		else {
-			pr_err("current speed not found\n");
-			baud_rate = 9600;
-		}
-	} else {
-		ret = -ENOMEM;
-	}
-
-	np = of_find_compatible_node(NULL, NULL, "lsi,acp3500");
-
-	if (NULL == np) {
-		unsigned long divisor;
-
-		/*
-		  In the 3500 case, the peripheral clock is connected
-		  directly to the UART.  If this isn't 3500, set up
-		  the second timer (which is in between the peripheral
-		  clock and the UART) and adjust per_clock
-		  accordingly.
-		*/
-
-		if (1000000 < per_clock) {
-			divisor = per_clock / 25000000;
-			per_clock = 25000000;
-		} else {
-			/* Emulation is much slower... */
-			divisor = per_clock / 3250000;
-			per_clock = 3250000;
-		}
-
-		--divisor;
-
-		if (divisor != in_le32(uap->timer_base + TIMER_LOAD)) {
-			while (0 ==
-			       (in_le32((const volatile unsigned *)
-					(uap->port.membase + UART01x_FR)) &
-				UART011_FR_TXFE))
-				;
-
-			while (0 !=
-			       (in_le32((const volatile unsigned *)
-					(uap->port.membase + UART01x_FR)) &
-				UART01x_FR_BUSY))
-				;
-
-			out_le32((uap->timer_base + TIMER_CONTROL), 0);
-			out_le32((uap->timer_base + TIMER_LOAD), divisor);
-			out_le32((uap->timer_base + TIMER_CONTROL),
-				 (TIMER_CONTROL_ENABLE |
-				  TIMER_CONTROL_MODE));
-		}
-	}
-
-	dt_baud_rate = baud_rate;
-	uap->port.iotype = UPIO_MEM;
-	uap->port.fifosize = 16;
-	uap->port.ops = &amba_acp_pops;
-	uap->port.flags = UPF_BOOT_AUTOCONF;
-	uap->port.line = i;
-	get_clock_stuff(uap, baud_rate);
-	acp_ports[i] = uap;
-	ret = uart_add_one_port(driver, &uap->port);
-
-	if (0 != ret) {
-		acp_ports[i] = NULL;
-		kfree(uap);
-	}
-
- out:
-	return ret;
-}
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_delete_ports
-*/
-
-static int
-acp_serial_delete_ports(struct uart_driver *driver)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(acp_ports); ++i) {
-		if (NULL != acp_ports[i]) {
-			uart_remove_one_port(driver,
-					     &(acp_ports[i])->port);
-			kfree(acp_ports[i]);
-			acp_ports[i] = NULL;
-		}
-	}
-
-	return 0;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Linux module stuff.
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  acp_init
-*/
-
-int __init
-acp_serial_init(void)
-{
-	int ret;
-
-	pr_info("Serial: ACP Serial Driver\n");
-
-	/* Clear the ports array */
-	memset((void *) &acp_ports[0], 0,
-		sizeof(struct uart_acp_port *) * ARRAY_SIZE(acp_ports));
-
-	/* Register the driver */
-	ret = uart_register_driver(&acp_serial_driver);
-
-	if (0 != ret) {
-		pr_err("uart_register_driver() failed with %d\n", ret);
-		goto out;
-	}
-
-	/* Add ports */
-	ret = acp_serial_add_ports(&acp_serial_driver);
-
-	if (0 != ret) {
-		pr_err("acp_serial_add_ports() failed with %d\n", ret);
-		goto out;
-	}
-
- out:
-	return ret;
-}
-module_init(acp_serial_init);
-
-/*
-  ----------------------------------------------------------------------
-  acp_serial_exit
-*/
-
-void __exit
-acp_serial_exit(void)
-{
-	acp_serial_delete_ports(&acp_serial_driver);
-	uart_unregister_driver(&acp_serial_driver);
-}
-module_exit(acp_serial_exit);
-
-MODULE_AUTHOR("LSI Corporation");
-MODULE_DESCRIPTION("ARM AMBA serial port on PPC476 driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/usb/dwc3/dwc3-axxia.c b/drivers/usb/dwc3/dwc3-axxia.c
index d47c46e..9395102 100644
--- a/drivers/usb/dwc3/dwc3-axxia.c
+++ b/drivers/usb/dwc3/dwc3-axxia.c
@@ -87,7 +87,7 @@ static int axxia_dwc3_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id adwc3_of_match[] = {
-	{ .compatible = "intel,axxia-dwc3", },
+	{ .compatible = "axxia,axxia-dwc3", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, adwc3_of_match);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 44e067d..7c18824b 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -3,11 +3,11 @@
 #
 comment "USB Host Controller Drivers"
 
-config LSI_USB_SW_WORKAROUND
-	bool "LSI USB SW Workaround for ACP34xx devices"
+config AXXIA_USB_SW_WORKAROUND
+	bool "INTEL Axxia USB SW Workaround for ACP34xx devices"
 	default n
 	help
-	  LSI USB SW Workaround for ACP34xx devices
+	  INTEL Axxia USB SW Workaround for ACP34xx devices
 
 config USB_C67X00_HCD
 	tristate "Cypress C67x00 HCD support"
diff --git a/drivers/usb/host/ehci-ci13612.c b/drivers/usb/host/ehci-ci13612.c
index c8468f0..526f10f 100644
--- a/drivers/usb/host/ehci-ci13612.c
+++ b/drivers/usb/host/ehci-ci13612.c
@@ -1,9 +1,9 @@
  /*
   * drivers/usb/host/ehci-ci13612.c
   *
-  * USB Host Controller Driver for LSI's ACP
+  * USB Host Controller Driver for INTEL Axxia's ACP
   *
-  * Copyright (C) 2010 LSI Inc.
+  * Copyright (C) 2018 INTEL Inc.
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
@@ -32,7 +32,7 @@
 
 static int ci13612_ehci_halt(struct ehci_hcd *ehci);
 
-#ifdef CONFIG_LSI_USB_SW_WORKAROUND
+#ifdef CONFIG_AXXIA_USB_SW_WORKAROUND
 static void ci13612_usb_setup(struct usb_hcd *hcd)
 {
 	int USB_TXFIFOTHRES, VUSB_HS_TX_BURST;
@@ -40,9 +40,9 @@ static void ci13612_usb_setup(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	u32 txfulltuning = 0;
 
-	if ((of_find_compatible_node(NULL, NULL, "lsi,acp3500")
+	if ((of_find_compatible_node(NULL, NULL, "axxia,acp3500")
 		!= NULL)
-		|| (of_find_compatible_node(NULL, NULL, "lsi,axxia35xx")
+		|| (of_find_compatible_node(NULL, NULL, "axxia,axxia35xx")
 		!= NULL)) {
 		writel(3, USB_SBUSCFG);
 		return;
@@ -82,7 +82,7 @@ static void ci13612_usb_setup(struct usb_hcd *hcd)
 static int ehci_ci13612_reinit(struct ehci_hcd *ehci)
 {
 
-#ifdef CONFIG_LSI_USB_SW_WORKAROUND
+#ifdef CONFIG_AXXIA_USB_SW_WORKAROUND
 	/* S/W workarounds are not needed in AXM55xx */
 	ci13612_usb_setup(ehci_to_hcd(ehci));
 #endif
@@ -125,7 +125,7 @@ static int ci13612_ehci_init(struct usb_hcd *hcd)
 	return retval;
 }
 
-#ifdef CONFIG_LSI_USB_SW_WORKAROUND
+#ifdef CONFIG_AXXIA_USB_SW_WORKAROUND
 /*
  * ci13612_fixup_usbcmd_rs
  *
@@ -140,9 +140,9 @@ static int ci13612_ehci_init(struct usb_hcd *hcd)
 {
 	u32 port_status;
 	/* This workaround is not applicable to 3500 */
-	if ((of_find_compatible_node(NULL, NULL, "lsi,acp3500")
+	if ((of_find_compatible_node(NULL, NULL, "axxia,acp3500")
 		!= NULL)
-		|| (of_find_compatible_node(NULL, NULL, "lsi,axxia35xx")
+		|| (of_find_compatible_node(NULL, NULL, "axxia,axxia35xx")
 		!= NULL)) {
 		return 0;
 	}
@@ -160,7 +160,7 @@ static int ci13612_ehci_init(struct usb_hcd *hcd)
 #endif
 
 
-#ifdef CONFIG_LSI_USB_SW_WORKAROUND
+#ifdef CONFIG_AXXIA_USB_SW_WORKAROUND
 /*
  * ci13612_fixup_txpburst
  *
@@ -178,9 +178,9 @@ static int ci13612_ehci_init(struct usb_hcd *hcd)
 	unsigned burst_size;
 
 	/* This workaround is not applicable to 3500 */
-	if ((of_find_compatible_node(NULL, NULL, "lsi,acp3500")
+	if ((of_find_compatible_node(NULL, NULL, "axxia,acp3500")
 		!= NULL)
-		|| (of_find_compatible_node(NULL, NULL, "lsi,axxia35xx")
+		|| (of_find_compatible_node(NULL, NULL, "axxia,axxia35xx")
 		!= NULL)) {
 		return;
 	}
@@ -204,7 +204,7 @@ static int ci13612_ehci_run(struct usb_hcd *hcd)
 		return retval;
 
 
-#ifndef CONFIG_LSI_USB_SW_WORKAROUND
+#ifndef CONFIG_AXXIA_USB_SW_WORKAROUND
 	/* Setup AMBA interface to force INCR16 busts when possible */
 	writel(3, USB_SBUSCFG);
 #endif
@@ -215,7 +215,7 @@ static int ci13612_ehci_run(struct usb_hcd *hcd)
 
 	ci13612_fixup_txpburst(ehci);
 
-#ifndef CONFIG_LSI_USB_SW_WORKAROUND
+#ifndef CONFIG_AXXIA_USB_SW_WORKAROUND
 	/* Set ITC (bits [23:16]) to zero for interrupt on every micro-frame */
 	tmp = ehci_readl(ehci, &ehci->regs->command);
 	tmp &= 0xFFFF;
@@ -282,7 +282,7 @@ static int ci13612_ehci_probe(struct platform_device *pdev)
 	}
 
 
-#ifndef CONFIG_LSI_USB_SW_WORKAROUND
+#ifndef CONFIG_AXXIA_USB_SW_WORKAROUND
 	/* Device using 32-bit addressing */
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
@@ -313,7 +313,7 @@ static int ci13612_ehci_probe(struct platform_device *pdev)
 	} else {
 		/* Set address bits [39:32] to zero */
 		writel(0x0, gpreg_base + 0x8);
-#ifndef CONFIG_LSI_USB_SW_WORKAROUND
+#ifndef CONFIG_AXXIA_USB_SW_WORKAROUND
 		/* hprot cachable and bufferable */
 		writel(0xc, gpreg_base + 0x74);
 #endif
@@ -362,7 +362,7 @@ static int ci13612_ehci_halt(struct ehci_hcd *ehci)
 static struct of_device_id ci13612_match[] = {
 	{
 		.type	= "usb",
-		.compatible = "lsi,acp-usb",
+		.compatible = "axxia,acp-usb",
 	},
 	{
 		.type	= "usb",
diff --git a/include/linux/axxia-ncr.h b/include/linux/axxia-ncr.h
new file mode 100644
index 0000000..ac209764
--- /dev/null
+++ b/include/linux/axxia-ncr.h
@@ -0,0 +1,58 @@
+/*
+ * drivers/axxia/common/version.h
+ *
+ * Copyright (C) 2018 INTEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#ifndef __DRIVERS_AXXIA_ACP_NCR_H
+#define __DRIVERS_AXXIA_ACP_NCR_H
+
+#ifndef NCP_REGION_ID
+#define NCP_REGION_ID(node, target) \
+((unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff)))
+#endif
+
+#ifndef NCP_NODE_ID
+#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
+#endif
+
+#ifndef NCP_TARGET_ID
+#define NCP_TARGET_ID(region) ((region) & 0xffff)
+#endif
+
+unsigned int ncr_register_read(unsigned int *);
+void ncr_register_write(const unsigned int, unsigned int *);
+int ncr_read(unsigned int, unsigned int, int, void *);
+int ncr_read32(unsigned int, unsigned int, unsigned int *);
+int ncr_write(unsigned int, unsigned int, int, void *);
+int ncr_write32(unsigned int, unsigned int, unsigned int);
+int ncr_read_nolock(unsigned int, unsigned int, int, void *);
+int ncr_write_nolock(unsigned int, unsigned int, int, void *);
+
+void ncr_start_trace(void);
+void ncr_stop_trace(void);
+
+ /*
+  * when defined, the RTE driver module will set/clear
+  * the ncr_reset_active flag to indicate when Axxia device
+  * reset is in progress. This flag will be checked by the
+  * kernel axxia-ncr driver and ddr_retention code.
+  */
+#ifdef CONFIG_ARCH_AXXIA_NCR_RESET_CHECK
+extern int ncr_reset_active;
+#endif
+
+#endif /*  __DRIVERS_AXXIA_ACP_NCR_H */
diff --git a/include/linux/axxia_mtc_ioctl.h b/include/linux/axxia_mtc_ioctl.h
new file mode 100644
index 0000000..c6fe463
--- /dev/null
+++ b/include/linux/axxia_mtc_ioctl.h
@@ -0,0 +1,153 @@
+#ifndef __AXXIA_MTC_IOCTLH
+#define __AXXIA_MTC_IOCTLH
+
+#include <linux/ioctl.h>
+
+#define AXXIA_MTC_IOC_MAGIC 0x49
+
+struct axxia_mtc_cfg_t {
+	unsigned int   opMode;
+	unsigned int   recMode;
+	unsigned int   clkMod;
+	unsigned int   clkSpeed;
+	unsigned int   buffMode;
+};
+
+
+
+struct axxia_mtc_tckclk_gate_t {
+	unsigned int gate_tck_test_logic_reset;
+	unsigned int gate_tck;
+};
+
+struct axxia_mtc_stats_regs_t {
+	unsigned int statsReg1;
+	unsigned int statsReg2;
+};
+
+
+struct axxia_mtc_debug_regs_t {
+	unsigned int debugReg0;
+	unsigned int debugReg1;
+	unsigned int debugReg2;
+	unsigned int debugReg3;
+	unsigned int debugReg4;
+	unsigned int debugReg5;
+};
+
+struct axxia_mtc_axi_capt_window_param_t {
+	/* TDO Capture Monitor window size in bits;
+	 0-disable 1-minitor first bit captured */
+	unsigned int	captWindowCnt;
+	/* TDO capture bit position to monitor within the window size */
+	unsigned int	captWindowMonBit0;
+	/* TDO capture bit value to monitor within the window size inverted */
+	unsigned int	captWindowMonInv0;
+	/* TDO capture bit position to monitor within the window size */
+	unsigned int	captWindowMonBit1;
+	/* TDO capture bit value to monitor within the window size inverted */
+	unsigned int	captWindowMonInv1;
+	/* TDO capture bit position to monitor within the window size */
+	unsigned int	captWindowMonBit2;
+	/* TDO capture bit value to monitor within the window size inverted */
+	unsigned int	captWindowMonInv2;
+};
+
+
+struct axxia_mtc_axi_extmem_wm_t {
+	unsigned int	highWaterMark;
+	unsigned int	lowWaterMark;
+};
+
+struct axxia_mtc_axi_master_addr_t {
+	unsigned int	strtAddrLow;
+	unsigned int	strtAddrHigh;
+	unsigned int	stopAddrLow;
+	unsigned int	stopAddrHigh;
+};
+
+struct axxia_mtc_axi_status_regs_t {
+	unsigned int axiStatusReg0;
+	unsigned int axiStatusReg1;
+	unsigned int axiStatusReg2;
+	unsigned int axiStatusReg3;
+};
+
+
+/* debug operation */
+#define MTC_DEBUG_OP           _IOWR(AXXIA_MTC_IOC_MAGIC, 0, int)
+
+/* MTC configuration */
+#define MTC_CFG                _IOW(AXXIA_MTC_IOC_MAGIC, 1, struct axxia_mtc_cfg_t)
+
+/* configure enable/disable single step */
+#define MTC_SINGLESTEP_ENABLE  _IOW(AXXIA_MTC_IOC_MAGIC, 2, int)
+
+/*enale/disbale loop mode */
+#define MTC_LOOPMODE_ENABLE    _IOW(AXXIA_MTC_IOC_MAGIC, 3, int)
+
+/* rest MTC */
+#define MTC_RESET              _IO(AXXIA_MTC_IOC_MAGIC, 4)
+
+/* config gate tck clokc */
+#define MTC_TCKCLK_GATE _IOW(AXXIA_MTC_IOC_MAGIC, 5,\
+				struct axxia_mtc_tckclk_gate_t)
+
+
+/* start/stop execution */
+#define MTC_STARTSTOP_EXEC     _IOW(AXXIA_MTC_IOC_MAGIC, 6, int)
+
+/* single step execution */
+#define MTC_SINGLESTEP_EXEC    _IO(AXXIA_MTC_IOC_MAGIC, 7)
+
+/* continue after pause execution */
+#define MTC_CONTINUE_EXEC      _IO(AXXIA_MTC_IOC_MAGIC, 8)
+
+/* read stats registers */
+#define MTC_READ_STATS  _IOR(AXXIA_MTC_IOC_MAGIC, 9,\
+					 struct axxia_mtc_stats_regs_t)
+
+/* read debug registers */
+#define MTC_READ_DEBUG  _IOR(AXXIA_MTC_IOC_MAGIC, 10,\
+					 struct axxia_mtc_debug_regs_t)
+
+
+/* enable/disable AXI master External Program Memory mode   */
+#define MTC_AXI_EXT_PRGM_MEM_ENABLE	_IOW(AXXIA_MTC_IOC_MAGIC, 11, int)
+
+/* setup external program memory capture window settings */
+#define MTC_AXI_CAPT_WINDOW_PARAM_SET	_IOW(AXXIA_MTC_IOC_MAGIC, 12,\
+				 struct axxia_mtc_axi_capt_window_param_t)
+
+/* Get external program memory capture window settings */
+#define MTC_AXI_CAPT_WINDOW_PARAM_GET	_IOR(AXXIA_MTC_IOC_MAGIC, 13,\
+			struct axxia_mtc_axi_capt_window_param_t)
+
+/* Setup AXI Master Program FIFO Watermarks */
+#define MTC_AXI_WATER_MARK_SET	 _IOW(AXXIA_MTC_IOC_MAGIC, 14,\
+			struct axxia_mtc_axi_extmem_wm_t)
+
+/* Get AXI Master Program FIFO Watermarks */
+#define MTC_AXI_WATER_MARK_GET	 _IOR(AXXIA_MTC_IOC_MAGIC, 15,\
+			struct axxia_mtc_axi_extmem_wm_t)
+
+/* Setup AXI Master Read ARPROT Value */
+#define MTC_AXI_M_ARPROT_SET	_IOW(AXXIA_MTC_IOC_MAGIC, 16, int)
+
+/* Get AXI Master Read ARPROT Value */
+#define MTC_AXI_M_ARPROT_GET	_IOR(AXXIA_MTC_IOC_MAGIC, 17, int)
+
+/* Setup AXI Master Start and Stop Addresses. */
+#define MTC_AXI_MASTER_ADDR_SET _IOW(AXXIA_MTC_IOC_MAGIC, 18,\
+				 struct axxia_mtc_axi_master_addr_t)
+
+/* Get AXI Master Start and Stop Addresses. */
+#define MTC_AXI_MASTER_ADDR_GET _IOR(AXXIA_MTC_IOC_MAGIC, 19,\
+			 struct axxia_mtc_axi_master_addr_t)
+
+/* Read AXI Status registers. */
+#define MTC_AXI_READ_STATUS _IOR(AXXIA_MTC_IOC_MAGIC, 20, \
+			struct axxia_mtc_axi_status_regs_t)
+
+
+#endif    /* __AXXIA_MTC_IOCTLH*/
diff --git a/include/linux/lsi-ncr.h b/include/linux/lsi-ncr.h
deleted file mode 100644
index 53b4138..0000000
--- a/include/linux/lsi-ncr.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * drivers/lsi/common/version.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.
- */
-
-#ifndef __DRIVERS_LSI_ACP_NCR_H
-#define __DRIVERS_LSI_ACP_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-((unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff)))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-unsigned int ncr_register_read(unsigned int *);
-void ncr_register_write(const unsigned int, unsigned int *);
-int ncr_read(unsigned int, unsigned int, int, void *);
-int ncr_read32(unsigned int, unsigned int, unsigned int *);
-int ncr_write(unsigned int, unsigned int, int, void *);
-int ncr_write32(unsigned int, unsigned int, unsigned int);
-int ncr_read_nolock(unsigned int, unsigned int, int, void *);
-int ncr_write_nolock(unsigned int, unsigned int, int, void *);
-
-void ncr_start_trace(void);
-void ncr_stop_trace(void);
-
- /*
-  * when defined, the RTE driver module will set/clear
-  * the ncr_reset_active flag to indicate when Axxia device
-  * reset is in progress. This flag will be checked by the
-  * kernel lsi-ncr driver and ddr_retention code.
-  */
-#ifdef CONFIG_ARCH_AXXIA_NCR_RESET_CHECK
-extern int ncr_reset_active;
-#endif
-
-#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/include/linux/lsi_mtc_ioctl.h b/include/linux/lsi_mtc_ioctl.h
deleted file mode 100644
index f1cd416..0000000
--- a/include/linux/lsi_mtc_ioctl.h
+++ /dev/null
@@ -1,153 +0,0 @@
-#ifndef __LSI_MTC_IOCTLH
-#define __LSI_MTC_IOCTLH
-
-#include <linux/ioctl.h>
-
-#define LSI_MTC_IOC_MAGIC 0x49
-
-struct lsi_mtc_cfg_t {
-	unsigned int   opMode;
-	unsigned int   recMode;
-	unsigned int   clkMod;
-	unsigned int   clkSpeed;
-	unsigned int   buffMode;
-};
-
-
-
-struct lsi_mtc_tckclk_gate_t {
-	unsigned int gate_tck_test_logic_reset;
-	unsigned int gate_tck;
-};
-
-struct lsi_mtc_stats_regs_t {
-	unsigned int statsReg1;
-	unsigned int statsReg2;
-};
-
-
-struct lsi_mtc_debug_regs_t {
-	unsigned int debugReg0;
-	unsigned int debugReg1;
-	unsigned int debugReg2;
-	unsigned int debugReg3;
-	unsigned int debugReg4;
-	unsigned int debugReg5;
-};
-
-struct lsi_mtc_axi_capt_window_param_t {
-	/* TDO Capture Monitor window size in bits;
-	 0-disable 1-minitor first bit captured */
-	unsigned int	captWindowCnt;
-	/* TDO capture bit position to monitor within the window size */
-	unsigned int	captWindowMonBit0;
-	/* TDO capture bit value to monitor within the window size inverted */
-	unsigned int	captWindowMonInv0;
-	/* TDO capture bit position to monitor within the window size */
-	unsigned int	captWindowMonBit1;
-	/* TDO capture bit value to monitor within the window size inverted */
-	unsigned int	captWindowMonInv1;
-	/* TDO capture bit position to monitor within the window size */
-	unsigned int	captWindowMonBit2;
-	/* TDO capture bit value to monitor within the window size inverted */
-	unsigned int	captWindowMonInv2;
-};
-
-
-struct lsi_mtc_axi_extmem_wm_t {
-	unsigned int	highWaterMark;
-	unsigned int	lowWaterMark;
-};
-
-struct lsi_mtc_axi_master_addr_t {
-	unsigned int	strtAddrLow;
-	unsigned int	strtAddrHigh;
-	unsigned int	stopAddrLow;
-	unsigned int	stopAddrHigh;
-};
-
-struct lsi_mtc_axi_status_regs_t {
-	unsigned int axiStatusReg0;
-	unsigned int axiStatusReg1;
-	unsigned int axiStatusReg2;
-	unsigned int axiStatusReg3;
-};
-
-
-/* debug operation */
-#define MTC_DEBUG_OP           _IOWR(LSI_MTC_IOC_MAGIC, 0, int)
-
-/* MTC configuration */
-#define MTC_CFG                _IOW(LSI_MTC_IOC_MAGIC, 1, struct lsi_mtc_cfg_t)
-
-/* configure enable/disable single step */
-#define MTC_SINGLESTEP_ENABLE  _IOW(LSI_MTC_IOC_MAGIC, 2, int)
-
-/*enale/disbale loop mode */
-#define MTC_LOOPMODE_ENABLE    _IOW(LSI_MTC_IOC_MAGIC, 3, int)
-
-/* rest MTC */
-#define MTC_RESET              _IO(LSI_MTC_IOC_MAGIC, 4)
-
-/* config gate tck clokc */
-#define MTC_TCKCLK_GATE _IOW(LSI_MTC_IOC_MAGIC, 5,\
-				struct lsi_mtc_tckclk_gate_t)
-
-
-/* start/stop execution */
-#define MTC_STARTSTOP_EXEC     _IOW(LSI_MTC_IOC_MAGIC, 6, int)
-
-/* single step execution */
-#define MTC_SINGLESTEP_EXEC    _IO(LSI_MTC_IOC_MAGIC, 7)
-
-/* continue after pause execution */
-#define MTC_CONTINUE_EXEC      _IO(LSI_MTC_IOC_MAGIC, 8)
-
-/* read stats registers */
-#define MTC_READ_STATS  _IOR(LSI_MTC_IOC_MAGIC, 9,\
-					 struct lsi_mtc_stats_regs_t)
-
-/* read debug registers */
-#define MTC_READ_DEBUG  _IOR(LSI_MTC_IOC_MAGIC, 10,\
-					 struct lsi_mtc_debug_regs_t)
-
-
-/* enable/disable AXI master External Program Memory mode   */
-#define MTC_AXI_EXT_PRGM_MEM_ENABLE	_IOW(LSI_MTC_IOC_MAGIC, 11, int)
-
-/* setup external program memory capture window settings */
-#define MTC_AXI_CAPT_WINDOW_PARAM_SET	_IOW(LSI_MTC_IOC_MAGIC, 12,\
-				 struct lsi_mtc_axi_capt_window_param_t)
-
-/* Get external program memory capture window settings */
-#define MTC_AXI_CAPT_WINDOW_PARAM_GET	_IOR(LSI_MTC_IOC_MAGIC, 13,\
-			struct lsi_mtc_axi_capt_window_param_t)
-
-/* Setup AXI Master Program FIFO Watermarks */
-#define MTC_AXI_WATER_MARK_SET	 _IOW(LSI_MTC_IOC_MAGIC, 14,\
-			struct lsi_mtc_axi_extmem_wm_t)
-
-/* Get AXI Master Program FIFO Watermarks */
-#define MTC_AXI_WATER_MARK_GET	 _IOR(LSI_MTC_IOC_MAGIC, 15,\
-			struct lsi_mtc_axi_extmem_wm_t)
-
-/* Setup AXI Master Read ARPROT Value */
-#define MTC_AXI_M_ARPROT_SET	_IOW(LSI_MTC_IOC_MAGIC, 16, int)
-
-/* Get AXI Master Read ARPROT Value */
-#define MTC_AXI_M_ARPROT_GET	_IOR(LSI_MTC_IOC_MAGIC, 17, int)
-
-/* Setup AXI Master Start and Stop Addresses. */
-#define MTC_AXI_MASTER_ADDR_SET _IOW(LSI_MTC_IOC_MAGIC, 18,\
-				 struct lsi_mtc_axi_master_addr_t)
-
-/* Get AXI Master Start and Stop Addresses. */
-#define MTC_AXI_MASTER_ADDR_GET _IOR(LSI_MTC_IOC_MAGIC, 19,\
-			 struct lsi_mtc_axi_master_addr_t)
-
-/* Read AXI Status registers. */
-#define MTC_AXI_READ_STATUS _IOR(LSI_MTC_IOC_MAGIC, 20, \
-			struct lsi_mtc_axi_status_regs_t)
-
-
-#endif    /* __LSI_MTC_IOCTLH*/
-- 
1.8.5.2.233.g932f7e4


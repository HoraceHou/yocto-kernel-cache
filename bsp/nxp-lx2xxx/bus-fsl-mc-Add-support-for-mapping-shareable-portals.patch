From 6e106530687ee3feffa1af4b90e05d0a1a7037eb Mon Sep 17 00:00:00 2001
From: Roy Pledge <roy.pledge@nxp.com>
Date: Fri, 26 Oct 2018 10:48:49 -0400
Subject: [PATCH 018/235] bus: fsl-mc: Add support for mapping shareable
 portals

Starting with v5 of NXP QBMan devices the hardware supports using
regular cacheable/shareable memory as the backing store for the
portals.

This patch adds support for the new portal mode by switching to
use the DPRC get object region v2 command which returns both
a base address and offset for the portal memory. The new portal
region is identified as shareable through the addition of a new
flag.

Signed-off-by: Roy Pledge <roy.pledge@nxp.com>
[Xulin: Original patch taken from NXP LSDK-19.06.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/bus/fsl-mc/dprc.c       |  3 ++-
 drivers/bus/fsl-mc/fsl-mc-bus.c | 17 +++++++++++++----
 include/linux/fsl/mc.h          | 14 +++++++++++---
 3 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/drivers/bus/fsl-mc/dprc.c b/drivers/bus/fsl-mc/dprc.c
index 9167d6ca110d..daee0dcf80c3 100644
--- a/drivers/bus/fsl-mc/dprc.c
+++ b/drivers/bus/fsl-mc/dprc.c
@@ -502,10 +502,11 @@ int dprc_get_obj_region(struct fsl_mc_io *mc_io,
 
 	/* retrieve response parameters */
 	rsp_params = (struct dprc_rsp_get_obj_region *)cmd.params;
-	region_desc->base_offset = le32_to_cpu(rsp_params->base_addr);
+	region_desc->base_offset = le32_to_cpu(rsp_params->base_offset);
 	region_desc->size = le32_to_cpu(rsp_params->size);
 	region_desc->type = rsp_params->type;
 	region_desc->flags = le32_to_cpu(rsp_params->flags);
+	region_desc->base_address = le64_to_cpu(rsp_params->base_addr);
 
 	return 0;
 }
diff --git a/drivers/bus/fsl-mc/fsl-mc-bus.c b/drivers/bus/fsl-mc/fsl-mc-bus.c
index 59c63c704b3a..21fbe5fd9b58 100644
--- a/drivers/bus/fsl-mc/fsl-mc-bus.c
+++ b/drivers/bus/fsl-mc/fsl-mc-bus.c
@@ -639,10 +639,17 @@ static int fsl_mc_device_get_mmio_regions(struct fsl_mc_device *mc_dev,
 				"dprc_get_obj_region() failed: %d\n", error);
 			goto error_cleanup_regions;
 		}
-
-		error = translate_mc_addr(mc_dev, mc_region_type,
-					  region_desc.base_offset,
-					  &regions[i].start);
+		/* Older MC only returned region offset and no base address
+		 * If base address is in the region_desc use it otherwise
+		 * revert to old mechanism
+		 */
+		if (region_desc.base_address)
+			regions[i].start = region_desc.base_address +
+					   region_desc.base_offset;
+		else
+			error = translate_mc_addr(mc_dev, mc_region_type,
+						  region_desc.base_offset,
+						  &regions[i].start);
 		if (error < 0) {
 			dev_err(parent_dev,
 				"Invalid MC offset: %#x (for %s.%d\'s region %d)\n",
@@ -656,6 +663,8 @@ static int fsl_mc_device_get_mmio_regions(struct fsl_mc_device *mc_dev,
 		regions[i].flags = IORESOURCE_IO;
 		if (region_desc.flags & DPRC_REGION_CACHEABLE)
 			regions[i].flags |= IORESOURCE_CACHEABLE;
+		if (region_desc.flags & DPRC_REGION_SHAREABLE)
+			regions[i].flags |= IORESOURCE_MEM;
 	}
 
 	mc_dev->regions = regions;
diff --git a/include/linux/fsl/mc.h b/include/linux/fsl/mc.h
index 9ccfc6bd095c..849971446afb 100644
--- a/include/linux/fsl/mc.h
+++ b/include/linux/fsl/mc.h
@@ -511,9 +511,11 @@ static inline bool is_fsl_mc_bus_dpdmai(const struct fsl_mc_device *mc_dev)
 
 /* DPRC command versioning */
 #define DPRC_CMD_BASE_VERSION			1
+#define DPRC_CMD_2ND_VERSION			2
 #define DPRC_CMD_ID_OFFSET			4
 
 #define DPRC_CMD(id)	(((id) << DPRC_CMD_ID_OFFSET) | DPRC_CMD_BASE_VERSION)
+#define DPRC_CMD_V2(id)	(((id) << DPRC_CMD_ID_OFFSET) | DPRC_CMD_2ND_VERSION)
 
 /* DPRC command IDs */
 #define DPRC_CMDID_CLOSE                        DPRC_CMD(0x800)
@@ -532,7 +534,7 @@ static inline bool is_fsl_mc_bus_dpdmai(const struct fsl_mc_device *mc_dev)
 #define DPRC_CMDID_GET_CONT_ID                  DPRC_CMD(0x830)
 #define DPRC_CMDID_GET_OBJ_COUNT                DPRC_CMD(0x159)
 #define DPRC_CMDID_GET_OBJ                      DPRC_CMD(0x15A)
-#define DPRC_CMDID_GET_OBJ_REG                  DPRC_CMD(0x15E)
+#define DPRC_CMDID_GET_OBJ_REG                  DPRC_CMD_V2(0x15E)
 #define DPRC_CMDID_SET_OBJ_IRQ                  DPRC_CMD(0x15F)
 
 struct dprc_cmd_open {
@@ -635,7 +637,7 @@ struct dprc_rsp_get_obj_region {
 	/* response word 0 */
 	__le64 pad0;
 	/* response word 1 */
-	__le32 base_addr;
+	__le32 base_offset;
 	__le32 pad1;
 	/* response word 2 */
 	__le32 size;
@@ -643,6 +645,9 @@ struct dprc_rsp_get_obj_region {
 	u8 pad2[3];
 	/* response word 3 */
 	__le32 flags;
+	__le32 pad3;
+	/* response word 4 */
+	__le64 base_addr;
 };
 
 struct dprc_cmd_set_obj_irq {
@@ -775,6 +780,7 @@ int dprc_set_obj_irq(struct fsl_mc_io *mc_io,
 /* Region flags */
 /* Cacheable - Indicates that region should be mapped as cacheable */
 #define DPRC_REGION_CACHEABLE	0x00000001
+#define DPRC_REGION_SHAREABLE	0x00000002
 
 /**
  * enum dprc_region_type - Region type
@@ -783,7 +789,8 @@ int dprc_set_obj_irq(struct fsl_mc_io *mc_io,
  */
 enum dprc_region_type {
 	DPRC_REGION_TYPE_MC_PORTAL,
-	DPRC_REGION_TYPE_QBMAN_PORTAL
+	DPRC_REGION_TYPE_QBMAN_PORTAL,
+	DPRC_REGION_TYPE_QBMAN_MEM_BACKED_PORTAL
 };
 
 /**
@@ -801,6 +808,7 @@ struct dprc_region_desc {
 	u32 size;
 	u32 flags;
 	enum dprc_region_type type;
+	u64 base_address;
 };
 
 int dprc_get_obj_region(struct fsl_mc_io *mc_io,
-- 
2.17.1


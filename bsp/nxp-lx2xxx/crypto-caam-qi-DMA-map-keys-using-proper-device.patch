From 5e03f0cce7dc2d5a84358fc1db3441649eb718cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Horia=20Geant=C4=83?= <horia.geanta@nxp.com>
Date: Wed, 6 Feb 2019 11:26:44 +0200
Subject: [PATCH 099/235] crypto: caam/qi - DMA map keys using proper device
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

keys are accessed from descriptors enqueued via Queue Interface,
thus when DMA operations are hooked to IOMMU ops, the DMA transactions
will use the ICID (Isolation Context ID) of the QI.
[Note: ICID of QI is configured by U-boot / other entity fixing up
the controller DT node before DT is passed to the kernel.]

In order to avoid IOMMU faults, DMA map the key using the controller
device instead of the Job Ring device.

Signed-off-by: Horia GeantÄƒ <horia.geanta@nxp.com>
[Xulin: Original patch taken from NXP LSDK-19.06.]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/crypto/caam/caamalg_qi.c | 24 +++++++++++++++++-------
 1 file changed, 17 insertions(+), 7 deletions(-)

diff --git a/drivers/crypto/caam/caamalg_qi.c b/drivers/crypto/caam/caamalg_qi.c
index a0d7d0d0ba3c..1e47406de26d 100644
--- a/drivers/crypto/caam/caamalg_qi.c
+++ b/drivers/crypto/caam/caamalg_qi.c
@@ -230,7 +230,7 @@ static int aead_setkey(struct crypto_aead *aead, const u8 *key,
 		memcpy(ctx->key, keys.authkey, keys.authkeylen);
 		memcpy(ctx->key + ctx->adata.keylen_pad, keys.enckey,
 		       keys.enckeylen);
-		dma_sync_single_for_device(jrdev, ctx->key_dma,
+		dma_sync_single_for_device(jrdev->parent, ctx->key_dma,
 					   ctx->adata.keylen_pad +
 					   keys.enckeylen, ctx->dir);
 		goto skip_split_key;
@@ -3043,15 +3043,18 @@ static int caam_init_common(struct caam_ctx *ctx, struct caam_alg_entry *caam,
 	}
 
 	priv = dev_get_drvdata(ctx->jrdev->parent);
-	if (priv->era >= 6 && uses_dkp)
+	if (priv->era >= 6 && uses_dkp) {
 		ctx->dir = DMA_BIDIRECTIONAL;
-	else
+		dev = ctx->jrdev->parent;
+	} else {
 		ctx->dir = DMA_TO_DEVICE;
+		dev = ctx->jrdev;
+	}
 
-	ctx->key_dma = dma_map_single(ctx->jrdev, ctx->key, sizeof(ctx->key),
+	ctx->key_dma = dma_map_single(dev, ctx->key, sizeof(ctx->key),
 				      ctx->dir);
-	if (dma_mapping_error(ctx->jrdev, ctx->key_dma)) {
-		dev_err(ctx->jrdev, "unable to map key\n");
+	if (dma_mapping_error(dev, ctx->key_dma)) {
+		dev_err(dev, "unable to map key\n");
 		caam_jr_free(ctx->jrdev);
 		return -ENOMEM;
 	}
@@ -3109,11 +3112,18 @@ static int caam_aead_init(struct crypto_aead *tfm)
 
 static void caam_exit_common(struct caam_ctx *ctx)
 {
+	struct device *dev;
+
 	caam_drv_ctx_rel(ctx->drv_ctx[ENCRYPT]);
 	caam_drv_ctx_rel(ctx->drv_ctx[DECRYPT]);
 	caam_drv_ctx_rel(ctx->drv_ctx[GIVENCRYPT]);
 
-	dma_unmap_single(ctx->jrdev, ctx->key_dma, sizeof(ctx->key), ctx->dir);
+	if (ctx->dir == DMA_BIDIRECTIONAL)
+		dev = ctx->jrdev->parent;
+	else
+		dev = ctx->jrdev;
+
+	dma_unmap_single(dev, ctx->key_dma, sizeof(ctx->key), ctx->dir);
 
 	caam_jr_free(ctx->jrdev);
 }
-- 
2.17.1


From 1ab8e3152af13eb9e12c933ad15401ac6ebd2e52 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 28 Jun 2018 15:42:08 +0800
Subject: [PATCH 108/205] remoteproc: add infrastructure to support user-space
 loading/booting

This commit comes from:
  git://git.ti.com/processor-sdk/processor-sdk-linux.git

The remoteproc infrastructure is enhanced to allow remoteproc drivers
to support userspace driven loading and booting mechanism. This is
done in preparation to allow the TI Keystone remoteproc driver to
support a userspace based loader.

A new field 'use_userspace_loader' is added to the rproc structure,
and this field is expected to be set alongside configuring the
'auto_boot' flag to false by remoteproc drivers wishing to bypass
the in-kernel loading and boot mechanism. The remoteproc core skips
looking for firmware or loading any firmware segments using these
two state flags.

The remoteproc drivers are expected to invoke rproc_boot() and
rproc_shutdown() for triggering the boot and shutdown of the remote
processor after the loading is completed and the resource table
information is published to the remoteproc driver. The resource
table is processed in-line during the rproc_boot() invocation.

The interface and implementation details to userspace is left to
the individual remoteproc drivers.

Signed-off-by: Suman Anna <s-anna@ti.com>
Signed-off-by: Sam Nelson <sam.nelson@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/remoteproc/remoteproc_core.c |   56 ++++++++++++++++++----------------
 include/linux/remoteproc.h           |    3 ++
 2 files changed, 33 insertions(+), 26 deletions(-)

diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index fa51e86..421d36e 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -1092,23 +1092,18 @@ static void rproc_resource_cleanup(struct rproc *rproc)
 
 static int rproc_start(struct rproc *rproc, const struct firmware *fw)
 {
-	struct resource_table *table, *loaded_table;
+	struct resource_table *loaded_table;
 	struct device *dev = &rproc->dev;
-	int ret, tablesz, versz;
-	const char *version;
-
-	/* look for the resource table */
-	table = rproc_find_rsc_table(rproc, fw, &tablesz);
-	if (!table) {
-		dev_err(dev, "Resource table look up failed\n");
-		return -EINVAL;
-	}
+	int ret;
 
-	/* load the ELF segments to memory */
-	ret = rproc_load_segments(rproc, fw);
-	if (ret) {
-		dev_err(dev, "Failed to load program segments: %d\n", ret);
-		return ret;
+	if (!rproc->use_userspace_loader) {
+		/* load the ELF segments to memory */
+		ret = rproc_load_segments(rproc, fw);
+		if (ret) {
+			dev_err(dev, "Failed to load program segments: %d\n",
+				ret);
+			return ret;
+		}
 	}
 
 	/*
@@ -1121,17 +1116,17 @@ static int rproc_start(struct rproc *rproc, const struct firmware *fw)
 	 */
 	loaded_table = rproc_find_loaded_rsc_table(rproc, fw);
 	if (loaded_table) {
-		memcpy(loaded_table, rproc->cached_table, tablesz);
+		memcpy(loaded_table, rproc->cached_table, rproc->tablesz);
 		rproc->table_ptr = loaded_table;
 	}
 
 	/* handle fw resources which require fw segments to be loaded*/
-	ret = rproc_handle_resources(rproc, tablesz,
+	ret = rproc_handle_resources(rproc, rproc->tablesz,
 				     rproc_post_loading_handlers);
 	if (ret) {
 		dev_err(dev, "Failed to process post-loading resources: %d\n",
 			ret);
-		goto clean_up;
+		return ret;
 	}
 
 	/* power up the remote processor */
@@ -1165,13 +1160,18 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 	struct device *dev = &rproc->dev;
 	const char *name = rproc->firmware;
 	struct resource_table *table;
-	int ret, tablesz;
+	int ret, tablesz, versz;
+	const char *version;
 
 	ret = rproc_fw_sanity_check(rproc, fw);
 	if (ret)
 		return ret;
 
-	dev_info(dev, "Booting fw image %s, size %zd\n", name, fw->size);
+	if (!rproc->use_userspace_loader)
+		dev_info(dev, "Booting fw image %s, size %zd\n",
+			 name, fw->size);
+	else
+		dev_info(dev, "Booting unspecified pre-loaded fw image\n");
 
 	/*
 	 * if enabling an IOMMU isn't relevant for this rproc, this is
@@ -1226,6 +1226,7 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 		}
 	}
 
+	rproc->tablesz = tablesz;
 	ret = rproc_start(rproc, fw);
 	if (ret)
 		goto clean_up_resources;
@@ -1447,16 +1448,19 @@ int rproc_boot(struct rproc *rproc)
 
 	dev_info(dev, "powering up %s\n", rproc->name);
 
-	/* load firmware */
-	ret = request_firmware(&firmware_p, rproc->firmware, dev);
-	if (ret < 0) {
-		dev_err(dev, "request_firmware failed: %d\n", ret);
-		goto downref_rproc;
+	if (!rproc->use_userspace_loader) {
+		/* load firmware */
+		ret = request_firmware(&firmware_p, rproc->firmware, dev);
+		if (ret < 0) {
+			dev_err(dev, "request_firmware failed: %d\n", ret);
+			goto downref_rproc;
+		}
 	}
 
 	ret = rproc_fw_boot(rproc, firmware_p);
 
-	release_firmware(firmware_p);
+	if (!rproc->use_userspace_loader)
+		release_firmware(firmware_p);
 
 downref_rproc:
 	if (ret)
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index b587a0d..6912f01 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -447,6 +447,7 @@ enum rproc_crash_type {
  * @cached_table: copy of the resource table
  * @fw_version: human readable version information extracted from f/w
  * @has_iommu: flag to indicate if remote processor is behind an MMU
+ * @use_userspace_loader: flag to denote if remoteproc is loaded by userspace
  */
 struct rproc {
 	struct list_head node;
@@ -482,6 +483,8 @@ struct rproc {
 	char *fw_version;
 	bool has_iommu;
 	bool auto_boot;
+	bool use_userspace_loader;
+	int tablesz;
 };
 
 /**
-- 
1.7.9.5


From 49838e3785c8d36b7259f05ed0543354ebd4fc28 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Thu, 8 Jun 2017 08:30:16 -0500
Subject: [PATCH 042/205] ARM: OMAP2+: timer: Ack pending interrupt during
 suspend

This commit comes from:
  git://git.ti.com/processor-sdk/processor-sdk-linux.git

It is possible that when suspending the clock event timer it will generate
an interrupt just before their suspend is completed, but after interrupts have
been disabled. In this case any pending interrupts will prevent suspend, so
ACK the timer interrupt to avoid this.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit b40cf13005a1b62f81067530db7ee4cec1791815)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/timer.c |   27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 56b42f2..468aee8 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -70,6 +70,8 @@
 
 /* Clockevent hwmod for am335x and am437x suspend */
 struct omap_hwmod *clockevent_gpt_hwmod;
+static struct irq_chip *clkev_irq_chip;
+static struct irq_desc *clkev_irq_desc;
 
 #ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 static unsigned long arch_timer_freq;
@@ -128,11 +130,32 @@ static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
 	return 0;
 }
 
+static void omap_clkevt_late_ack(void)
+{
+	if (!clkev_irq_chip)
+		return;
+
+	if (clkev_irq_chip->irq_ack)
+		clkev_irq_chip->irq_ack(&clkev_irq_desc->irq_data);
+	if (clkev_irq_chip->irq_eoi)
+		clkev_irq_chip->irq_eoi(&clkev_irq_desc->irq_data);
+
+	clkev_irq_chip->irq_unmask(&clkev_irq_desc->irq_data);
+}
+
 static void omap_clkevt_idle(struct clock_event_device *unused)
 {
 	if (!clockevent_gpt_hwmod)
 		return;
 
+	/*
+	 * It is possible for a late interrupt to be generated which will
+	 * cause a suspend failure. Let's ack it here both in the timer
+	 * and the interrupt controller to avoid this.
+	 */
+	__omap_dm_timer_write_status(&clkev, OMAP_TIMER_INT_OVERFLOW);
+	omap_clkevt_late_ack();
+
 	omap_hwmod_idle(clockevent_gpt_hwmod);
 }
 
@@ -384,6 +407,10 @@ static void __init omap2_gp_clockevent_init(int gptimer_id,
 
 		clockevent_gpt_hwmod =
 			omap_hwmod_lookup(clockevent_gpt.name);
+
+		clkev_irq_desc = irq_to_desc(clkev.irq);
+		if (clkev_irq_desc)
+			clkev_irq_chip = irq_desc_get_chip(clkev_irq_desc);
 	}
 
 	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
-- 
1.7.9.5


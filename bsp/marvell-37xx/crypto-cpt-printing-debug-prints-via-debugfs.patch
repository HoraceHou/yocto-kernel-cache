From 58d9148b837f1d77ee8a6f9120cc9b9b1d8ffff8 Mon Sep 17 00:00:00 2001
From: SrujanaChalla <schalla@marvell.com>
Date: Thu, 20 Jun 2019 17:25:57 +0530
Subject: [PATCH 313/386] crypto:cpt - printing debug prints via debugfs

Modified code to print cpt debug prints via debugfs using
Dynamic Debug feature(CONFIG_DYNAMIC_DEBUG) instead of
module parameter.

Change-Id: I6e0ee49657f6daf59e8249e628fa883749dbd4a2
Signed-off-by: SrujanaChalla <schalla@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/11338
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Lukas Bartosik <lbartosik@marvell.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 drivers/crypto/cavium/cpt/8x/Makefile         |  6 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_common.h   |  4 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_debug.c    | 76 -----------------
 drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c  |  3 -
 drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c  | 68 +++++++++++++--
 drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c  |  3 -
 drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c  | 63 +++++++++++++-
 drivers/crypto/cavium/cpt/9x/Makefile         |  2 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_debug.c    | 67 ---------------
 .../crypto/cavium/cpt/9x/cpt9x_mbox_common.c  | 41 +++++++++
 .../crypto/cavium/cpt/9x/cpt9x_mbox_common.h  |  3 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c  |  3 -
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c  | 16 +++-
 drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c  |  3 -
 drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c  | 15 +++-
 drivers/crypto/cavium/cpt/common/Makefile     |  2 +-
 drivers/crypto/cavium/cpt/common/cpt_common.h |  1 -
 drivers/crypto/cavium/cpt/common/cpt_debug.c  | 29 -------
 drivers/crypto/cavium/cpt/common/cpt_debug.h  | 30 -------
 drivers/crypto/cavium/cpt/common/cpt_reqmgr.c | 40 ++++-----
 drivers/crypto/cavium/cpt/common/cpt_ucode.c  | 84 +++++++++----------
 21 files changed, 249 insertions(+), 310 deletions(-)
 delete mode 100644 drivers/crypto/cavium/cpt/8x/cpt8x_debug.c
 delete mode 100644 drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
 delete mode 100644 drivers/crypto/cavium/cpt/common/cpt_debug.c
 delete mode 100644 drivers/crypto/cavium/cpt/common/cpt_debug.h

diff --git a/drivers/crypto/cavium/cpt/8x/Makefile b/drivers/crypto/cavium/cpt/8x/Makefile
index bbef13d8cd08..9e0cfdafa1f9 100644
--- a/drivers/crypto/cavium/cpt/8x/Makefile
+++ b/drivers/crypto/cavium/cpt/8x/Makefile
@@ -1,12 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += cptpf8x.o cptvf8x.o
 
-cptpf8x-objs := cpt8x_pf_main.o cpt8x_pf_mbox.o cpt8x_ucode.o cpt8x_pf_domain.o cpt8x_debug.o
+cptpf8x-objs := cpt8x_pf_main.o cpt8x_pf_mbox.o cpt8x_ucode.o cpt8x_pf_domain.o
 cptvf8x-objs := cpt8x_vf_main.o cpt8x_vf_mbox.o cpt8x_reqmgr.o cpt8x_algs.o
 
-ifeq ($(CONFIG_CRYPTO_DEV_OCTEONTX_CPT), m)
-	cptvf8x-objs += cpt8x_debug.o
-endif
-
 ccflags-y := -I$(src)/../common/
 ccflags-y += -I$(src)/../../../../net/ethernet/cavium/octeontx-83xx/
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_common.h b/drivers/crypto/cavium/cpt/8x/cpt8x_common.h
index 5352a53ec024..3a20f6cc4d7c 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_common.h
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_common.h
@@ -28,6 +28,7 @@
 #define cpt_device_ready(cpt) ((cpt)->flags & CPT_FLAG_DEVICE_READY)
 
 #define CPT_MBOX_MSG_TIMEOUT 2000
+#define CPT_MAX_MBOX_DATA_STR_SIZE 64
 
 /* VF-PF message opcodes */
 enum cpt_mbox_opcode {
@@ -48,7 +49,4 @@ struct cpt_mbox {
 	u64 data;/* Data         MBOX[1] */
 };
 
-void cpt8x_dump_mbox_msg(struct device *dev, struct cpt_mbox *mbox_msg,
-			 int vf_id);
-
 #endif /* __CPT8X_COMMON_H */
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c b/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c
deleted file mode 100644
index 2a80850e9b86..000000000000
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c
+++ /dev/null
@@ -1,76 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTX CPT driver
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/device.h>
-#include "cpt8x_common.h"
-
-#define MAX_RAW_DATA_STR_SIZE	64
-
-static char *get_opcode_str(int msg_opcode)
-{
-	char *str = "Unknown";
-
-	switch (msg_opcode) {
-	case CPT_MSG_VF_UP:
-		str = "UP";
-	break;
-
-	case CPT_MSG_VF_DOWN:
-		str = "DOWN";
-	break;
-
-	case CPT_MSG_READY:
-		str = "READY";
-	break;
-
-	case CPT_MSG_QLEN:
-		str = "QLEN";
-	break;
-
-	case CPT_MSG_QBIND_GRP:
-		str = "QBIND_GRP";
-	break;
-
-	case CPT_MSG_VQ_PRIORITY:
-		str = "VQ_PRIORITY";
-	break;
-
-	case CPT_MSG_PF_TYPE:
-		str = "PF_TYPE";
-	break;
-
-	case CPT_MSG_ACK:
-		str = "ACK";
-	break;
-
-	case CPT_MSG_NACK:
-		str = "NACK";
-	break;
-	}
-
-	return str;
-}
-
-void cpt8x_dump_mbox_msg(struct device *dev, struct cpt_mbox *mbox_msg,
-			 int vf_id)
-{
-	char raw_data_str[MAX_RAW_DATA_STR_SIZE];
-	char *opcode_str;
-
-	opcode_str = get_opcode_str(mbox_msg->msg);
-	hex_dump_to_buffer(mbox_msg, sizeof(struct cpt_mbox), 16, 8,
-			   raw_data_str, MAX_RAW_DATA_STR_SIZE, false);
-	if (vf_id >= 0)
-		dev_info(dev, "Receive from VF%d %s opcode raw_data %s",
-			 vf_id, opcode_str, raw_data_str);
-	else
-		dev_info(dev, "Receive from PF %s opcode raw_data %s",
-			 opcode_str, raw_data_str);
-}
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c
index b2aaeca94248..b9abe1ced258 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c
@@ -13,8 +13,6 @@
 #define DRV_NAME	"octeontx-cpt"
 #define DRV_VERSION	"1.0"
 
-DEFINE_CPT_DEBUG_PARM(debug);
-
 DEFINE_MUTEX(octeontx_cpt_devices_lock);
 LIST_HEAD(octeontx_cpt_devices);
 
@@ -226,7 +224,6 @@ static int cpt_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	pci_set_drvdata(pdev, cpt);
 	cpt->pdev = pdev;
-	cpt_set_dbg_level(debug);
 
 	err = pci_enable_device(pdev);
 	if (err) {
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c
index fd266869922b..112686af5244 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c
@@ -8,9 +8,68 @@
  * published by the Free Software Foundation.
  */
 
-#include "cpt_debug.h"
 #include "cpt8x_pf.h"
 
+static char *get_mbox_opcode_str(int msg_opcode)
+{
+	char *str = "Unknown";
+
+	switch (msg_opcode) {
+	case CPT_MSG_VF_UP:
+		str = "UP";
+	break;
+
+	case CPT_MSG_VF_DOWN:
+		str = "DOWN";
+	break;
+
+	case CPT_MSG_READY:
+		str = "READY";
+	break;
+
+	case CPT_MSG_QLEN:
+		str = "QLEN";
+	break;
+
+	case CPT_MSG_QBIND_GRP:
+		str = "QBIND_GRP";
+	break;
+
+	case CPT_MSG_VQ_PRIORITY:
+		str = "VQ_PRIORITY";
+	break;
+
+	case CPT_MSG_PF_TYPE:
+		str = "PF_TYPE";
+	break;
+
+	case CPT_MSG_ACK:
+		str = "ACK";
+	break;
+
+	case CPT_MSG_NACK:
+		str = "NACK";
+	break;
+	}
+
+	return str;
+}
+
+static void dump_mbox_msg(struct cpt_mbox *mbox_msg, int vf_id)
+{
+	char raw_data_str[CPT_MAX_MBOX_DATA_STR_SIZE];
+
+	hex_dump_to_buffer(mbox_msg, sizeof(struct cpt_mbox), 16, 8,
+			   raw_data_str, CPT_MAX_MBOX_DATA_STR_SIZE, false);
+	if (vf_id >= 0)
+		pr_debug("MBOX opcode %s received from VF%d raw_data %s",
+			 get_mbox_opcode_str(mbox_msg->msg), vf_id,
+			 raw_data_str);
+	else
+		pr_debug("MBOX opcode %s received from PF raw_data %s",
+			 get_mbox_opcode_str(mbox_msg->msg), raw_data_str);
+}
+
 static void cpt_send_msg_to_vf(struct cpt_device *cpt, int vf,
 			       struct cpt_mbox *mbx)
 {
@@ -125,8 +184,7 @@ static void cpt_handle_mbox_intr(struct cpt_device *cpt, int vf)
 	mbx.msg  = readq(cpt->reg_base + CPT_PF_VFX_MBOXX(vf, 0));
 	mbx.data = readq(cpt->reg_base + CPT_PF_VFX_MBOXX(vf, 1));
 
-	if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-		cpt8x_dump_mbox_msg(&cpt->pdev->dev, &mbx, vf);
+	dump_mbox_msg(&mbx, vf);
 
 	switch (mbx.msg) {
 	case CPT_MSG_VF_UP:
@@ -181,9 +239,7 @@ void cpt_mbox_intr_handler (struct cpt_device *cpt, int mbx)
 	u8  vf;
 
 	intr = readq(cpt->reg_base + CPT_PF_MBOX_INTX(0));
-	if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-		dev_info(&cpt->pdev->dev,
-			 "PF interrupt mbox%d mask 0x%llx\n", mbx, intr);
+	pr_debug("PF interrupt mbox%d mask 0x%llx\n", mbx, intr);
 	for (vf = 0; vf < cpt->max_vfs; vf++) {
 		if (intr & (1ULL << vf)) {
 			cpt_handle_mbox_intr(cpt, vf);
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c
index 303702e6f451..9ab4f7f3de88 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c
@@ -17,8 +17,6 @@
 #define DRV_NAME	"octeontx-cptvf"
 #define DRV_VERSION	"1.0"
 
-DEFINE_CPT_DEBUG_PARM(debug);
-
 static void vq_work_handler(unsigned long data)
 {
 	struct cptvf_wqe_info *cwqe_info = (struct cptvf_wqe_info *) data;
@@ -800,7 +798,6 @@ static int cptvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	pci_set_drvdata(pdev, cptvf);
 	cptvf->pdev = pdev;
-	cpt_set_dbg_level(debug);
 
 	err = pci_enable_device(pdev);
 	if (err) {
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c
index aaad6d29b5a4..ed8c5f10880c 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c
@@ -11,6 +11,66 @@
 #include <linux/delay.h>
 #include "cpt8x_vf.h"
 
+static char *get_mbox_opcode_str(int msg_opcode)
+{
+	char *str = "Unknown";
+
+	switch (msg_opcode) {
+	case CPT_MSG_VF_UP:
+		str = "UP";
+	break;
+
+	case CPT_MSG_VF_DOWN:
+		str = "DOWN";
+	break;
+
+	case CPT_MSG_READY:
+		str = "READY";
+	break;
+
+	case CPT_MSG_QLEN:
+		str = "QLEN";
+	break;
+
+	case CPT_MSG_QBIND_GRP:
+		str = "QBIND_GRP";
+	break;
+
+	case CPT_MSG_VQ_PRIORITY:
+		str = "VQ_PRIORITY";
+	break;
+
+	case CPT_MSG_PF_TYPE:
+		str = "PF_TYPE";
+	break;
+
+	case CPT_MSG_ACK:
+		str = "ACK";
+	break;
+
+	case CPT_MSG_NACK:
+		str = "NACK";
+	break;
+	}
+
+	return str;
+}
+
+static void dump_mbox_msg(struct cpt_mbox *mbox_msg, int vf_id)
+{
+	char raw_data_str[CPT_MAX_MBOX_DATA_STR_SIZE];
+
+	hex_dump_to_buffer(mbox_msg, sizeof(struct cpt_mbox), 16, 8,
+			   raw_data_str, CPT_MAX_MBOX_DATA_STR_SIZE, false);
+	if (vf_id >= 0)
+		pr_debug("MBOX msg %s received from VF%d raw_data %s",
+			 get_mbox_opcode_str(mbox_msg->msg), vf_id,
+			 raw_data_str);
+	else
+		pr_debug("MBOX msg %s received from PF raw_data %s",
+			 get_mbox_opcode_str(mbox_msg->msg), raw_data_str);
+}
+
 static void cptvf_send_msg_to_pf(struct cpt_vf *cptvf, struct cpt_mbox *mbx)
 {
 	/* Writing mbox(1) causes interrupt */
@@ -47,8 +107,7 @@ void cptvf_handle_mbox_intr(struct cpt_vf *cptvf)
 	mbx.msg  = readq(cptvf->reg_base + CPT_VFX_PF_MBOXX(0, 0));
 	mbx.data = readq(cptvf->reg_base + CPT_VFX_PF_MBOXX(0, 1));
 
-	if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-		cpt8x_dump_mbox_msg(&cptvf->pdev->dev, &mbx, -1);
+	dump_mbox_msg(&mbx, -1);
 
 	switch (mbx.msg) {
 	case CPT_MSG_VF_UP:
diff --git a/drivers/crypto/cavium/cpt/9x/Makefile b/drivers/crypto/cavium/cpt/9x/Makefile
index b623b98709a6..ec78385f1eee 100644
--- a/drivers/crypto/cavium/cpt/9x/Makefile
+++ b/drivers/crypto/cavium/cpt/9x/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_CRYPTO_DEV_OCTEONTX2_CPT) += cptpf9x.o cptvf9x.o
 
-common-objs := cpt9x_mbox_common.o cpt9x_debug.o
+common-objs := cpt9x_mbox_common.o
 cptpf9x-objs := cpt9x_pf_main.o  cpt9x_pf_mbox.o cpt9x_ucode.o cpt9x_quota.o ${common-objs}
 cptvf9x-objs := cpt9x_vf_main.o cpt9x_vf_mbox.o cpt9x_lf_main.o cpt9x_reqmgr.o cpt9x_algs.o cpt9x_passthrough.o
 
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c b/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
deleted file mode 100644
index f99bf8210fdd..000000000000
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
+++ /dev/null
@@ -1,67 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTX2 CPT driver
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include "cpt9x_mbox_common.h"
-
-static char *get_opcode_str(int msg_opcode)
-{
-	char *str = "Unknown";
-
-	switch (msg_opcode) {
-	case MBOX_MSG_READY:
-		str = "READY";
-	break;
-
-	case MBOX_MSG_FREE_RSRC_CNT:
-		str = "FREE_RSRC_CNT";
-	break;
-
-	case MBOX_MSG_ATTACH_RESOURCES:
-		str = "ATTACH_RESOURCES";
-	break;
-
-	case MBOX_MSG_DETACH_RESOURCES:
-		str = "DETACH_RESOURCES";
-	break;
-
-	case MBOX_MSG_MSIX_OFFSET:
-		str = "MSIX_OFFSET";
-	break;
-
-	case MBOX_MSG_CPT_RD_WR_REGISTER:
-		str = "RD_WR_REGISTER";
-	break;
-
-	case MBOX_MSG_CPT_SET_CRYPTO_GRP:
-		str = "SET_CRYPTO_GRP";
-	break;
-
-	case MBOX_MSG_GET_ENG_GRP_NUM:
-		str = "GET_ENG_GRP_NUM";
-	break;
-	}
-
-	return str;
-}
-
-void cpt9x_dump_mbox_msg(struct device *dev, struct mbox_msghdr *msg, int size)
-{
-	char *opcode_str;
-	u16 pf_id, vf_id;
-
-	opcode_str = get_opcode_str(msg->id);
-	pf_id = (msg->pcifunc >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;
-	vf_id = (msg->pcifunc >> RVU_PFVF_FUNC_SHIFT) & RVU_PFVF_FUNC_MASK;
-
-	dev_info(dev, "Receive %s opcode (PF%d/VF%d), size %d, rc %d",
-		 opcode_str, pf_id, vf_id, size, msg->rc);
-	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 2, msg, size,
-		       false);
-}
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.c b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.c
index c72bd3541cc6..109db9adf031 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.c
@@ -62,6 +62,47 @@ static inline struct free_rsrcs_rsp *get_limits(struct pci_dev *pdev)
 	return &cptvf->limits;
 }
 
+char *cpt_get_mbox_opcode_str(int msg_opcode)
+{
+	char *str = "Unknown";
+
+	switch (msg_opcode) {
+	case MBOX_MSG_READY:
+		str = "READY";
+	break;
+
+	case MBOX_MSG_FREE_RSRC_CNT:
+		str = "FREE_RSRC_CNT";
+	break;
+
+	case MBOX_MSG_ATTACH_RESOURCES:
+		str = "ATTACH_RESOURCES";
+	break;
+
+	case MBOX_MSG_DETACH_RESOURCES:
+		str = "DETACH_RESOURCES";
+	break;
+
+	case MBOX_MSG_MSIX_OFFSET:
+		str = "MSIX_OFFSET";
+	break;
+
+	case MBOX_MSG_CPT_RD_WR_REGISTER:
+		str = "RD_WR_REGISTER";
+	break;
+
+	case MBOX_MSG_CPT_SET_CRYPTO_GRP:
+		str = "SET_CRYPTO_GRP";
+	break;
+
+	case MBOX_MSG_GET_ENG_GRP_NUM:
+		str = "GET_ENG_GRP_NUM";
+	break;
+	}
+
+	return str;
+}
+
 int cpt_send_mbox_msg(struct pci_dev *pdev)
 {
 	struct otx2_mbox *mbox = get_mbox(pdev);
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
index fa8443cf9ef0..21bc21c798a6 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
@@ -61,7 +61,6 @@ int cpt_read_af_reg(struct pci_dev *pdev, u64 reg, u64 *val);
 int cpt_write_af_reg(struct pci_dev *pdev, u64 reg, u64 val);
 
 int cpt_send_mbox_msg(struct pci_dev *pdev);
-void cpt9x_dump_mbox_msg(struct device *dev, struct mbox_msghdr *msg,
-			 int size);
+char *cpt_get_mbox_opcode_str(int msg_opcode);
 
 #endif /* __CPT9X_MBOX_COMMON_H */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
index db7d45baa657..91e592b6b554 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
@@ -15,8 +15,6 @@
 #define DRV_NAME	"octeontx2-cpt"
 #define DRV_VERSION	"1.0"
 
-DEFINE_CPT_DEBUG_PARM(debug);
-
 void cptpf_enable_vf_flr_intrs(struct cptpf_dev *cptpf)
 {
 	/* Clear interrupt if any */
@@ -521,7 +519,6 @@ static int cptpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	cptpf->pdev = pdev;
 	cptpf->crypto_eng_grp = INVALID_CRYPTO_ENG_GRP;
 	cptpf->max_vfs = pci_sriov_get_totalvfs(pdev);
-	cpt_set_dbg_level(debug);
 
 	err = pcim_enable_device(pdev);
 	if (err) {
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
index 66e90eaa56b1..6ac4a83ffeb0 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
@@ -11,6 +11,18 @@
 #include "rvu_reg.h"
 #include "cpt9x_mbox_common.h"
 
+static void dump_mbox_msg(struct mbox_msghdr *msg, int size)
+{
+	u16 pf_id, vf_id;
+
+	pf_id = (msg->pcifunc >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;
+	vf_id = (msg->pcifunc >> RVU_PFVF_FUNC_SHIFT) & RVU_PFVF_FUNC_MASK;
+
+	pr_debug("MBOX opcode %s received from (PF%d/VF%d), size %d, rc %d",
+		 cpt_get_mbox_opcode_str(msg->id), pf_id, vf_id, size, msg->rc);
+	print_hex_dump_debug("", DUMP_PREFIX_OFFSET, 16, 2, msg, size, false);
+}
+
 static int forward_to_af(struct cptpf_dev *cptpf, struct cptvf_info *vf,
 			 struct mbox_msghdr *req, int size)
 {
@@ -357,9 +369,7 @@ void cptpf_afpf_mbox_handler(struct work_struct *work)
 			fwd->ver = msg->ver;
 			fwd->rc = msg->rc;
 		} else {
-			if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-				cpt9x_dump_mbox_msg(&cptpf->pdev->dev, msg,
-						    size);
+			dump_mbox_msg(msg, size);
 			switch (msg->id) {
 			case MBOX_MSG_READY:
 				cptpf->pf_id =
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c
index 24cd85264984..476a5a21fd78 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c
@@ -16,8 +16,6 @@
 #define DRV_NAME	"octeontx2-cptvf"
 #define DRV_VERSION	"1.0"
 
-DEFINE_CPT_DEBUG_PARM(debug);
-
 static void cptvf_enable_pfvf_mbox_intrs(struct cptvf_dev *cptvf)
 {
 	/* Clear interrupt if any */
@@ -143,7 +141,6 @@ static int cptvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	pci_set_drvdata(pdev, cptvf);
 	cptvf->pdev = pdev;
-	cpt_set_dbg_level(debug);
 
 	err = pcim_enable_device(pdev);
 	if (err) {
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
index 97e5dd69f649..897015a5c1e5 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
@@ -12,6 +12,18 @@
 #include "otx2_reg.h"
 #include "rvu_reg.h"
 
+static void dump_mbox_msg(struct mbox_msghdr *msg, int size)
+{
+	u16 pf_id, vf_id;
+
+	pf_id = (msg->pcifunc >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;
+	vf_id = (msg->pcifunc >> RVU_PFVF_FUNC_SHIFT) & RVU_PFVF_FUNC_MASK;
+
+	pr_debug("MBOX opcode %s received from (PF%d/VF%d), size %d, rc %d",
+		 cpt_get_mbox_opcode_str(msg->id), pf_id, vf_id, size, msg->rc);
+	print_hex_dump_debug("", DUMP_PREFIX_OFFSET, 16, 2, msg, size, false);
+}
+
 irqreturn_t cptvf_pfvf_mbox_intr(int irq, void *arg)
 {
 	struct cptvf_dev *cptvf = (struct cptvf_dev *) arg;
@@ -70,8 +82,7 @@ void cptvf_pfvf_mbox_handler(struct work_struct *work)
 			goto error;
 		}
 
-		if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-			cpt9x_dump_mbox_msg(&cptvf->pdev->dev, msg, size);
+		dump_mbox_msg(msg, size);
 
 		offset = msg->next_msgoff;
 		switch (msg->id) {
diff --git a/drivers/crypto/cavium/cpt/common/Makefile b/drivers/crypto/cavium/cpt/common/Makefile
index c15bf696c490..1757d35e68b0 100644
--- a/drivers/crypto/cavium/cpt/common/Makefile
+++ b/drivers/crypto/cavium/cpt/common/Makefile
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_CRYPTO_DEV_CPT) += cpt_common.o
 
-cpt_common-objs := cpt_ucode.o cpt_reqmgr.o cpt_algs.o cpt_debug.o
\ No newline at end of file
+cpt_common-objs := cpt_ucode.o cpt_reqmgr.o cpt_algs.o
diff --git a/drivers/crypto/cavium/cpt/common/cpt_common.h b/drivers/crypto/cavium/cpt/common/cpt_common.h
index 03b7ec6c5330..1d14187d15f1 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_common.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_common.h
@@ -14,7 +14,6 @@
 #include <linux/pci.h>
 #include <linux/types.h>
 #include <linux/module.h>
-#include "cpt_debug.h"
 
 /* Maximum request size in bytes */
 #define CPT_MAX_REQ_SIZE	65535
diff --git a/drivers/crypto/cavium/cpt/common/cpt_debug.c b/drivers/crypto/cavium/cpt/common/cpt_debug.c
deleted file mode 100644
index 5533417428f7..000000000000
--- a/drivers/crypto/cavium/cpt/common/cpt_debug.c
+++ /dev/null
@@ -1,29 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Marvell CPT common code
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/printk.h>
-#include "cpt_debug.h"
-
-static int debug_level;
-
-void cpt_set_dbg_level(int level)
-{
-	if (level >= (2*CPT_DBG_MAX_LEVEL-2))
-		debug_level = -1;
-	else
-		debug_level = level;
-}
-EXPORT_SYMBOL_GPL(cpt_set_dbg_level);
-
-int cpt_is_dbg_level_en(int level)
-{
-	return (debug_level & level);
-}
-EXPORT_SYMBOL_GPL(cpt_is_dbg_level_en);
diff --git a/drivers/crypto/cavium/cpt/common/cpt_debug.h b/drivers/crypto/cavium/cpt/common/cpt_debug.h
deleted file mode 100644
index 2c11a74edfa4..000000000000
--- a/drivers/crypto/cavium/cpt/common/cpt_debug.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- * Marvell CPT common code
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __CPT_DEBUG_H
-#define __CPT_DEBUG_H
-
-#define DEFINE_CPT_DEBUG_PARM(name) \
-static int name; \
-module_param(name, uint, 0000); \
-MODULE_PARM_DESC(name, \
-"Debug level (0=disabled, 1=mbox msgs, 2=enc/dec reqs, 4=engine grps, >6=all)")
-
-enum {
-	CPT_DBG_MBOX_MSGS	= 0x0001, /* Mailbox mesages */
-	CPT_DBG_ENC_DEC_REQS	= 0x0002, /* Encryption/decryption requests */
-	CPT_DBG_ENGINE_GRPS	= 0x0004, /* Engine groups configuration */
-	CPT_DBG_MAX_LEVEL
-};
-
-void cpt_set_dbg_level(int level);
-int cpt_is_dbg_level_en(int level);
-
-#endif /*__CPT_DEBUG_H */
diff --git a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c
index b1aae7b3b7fa..b8698807fdad 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c
@@ -234,17 +234,12 @@ inline int process_request(struct pci_dev *pdev, struct reqmgr_ops *ops,
 	ops->fill_inst(&cptinst, info, &iq_cmd);
 
 	/* Print debug info if enabled */
-	if (cpt_is_dbg_level_en(CPT_DBG_ENC_DEC_REQS)) {
-		dump_sg_list(pdev, req);
-		dev_info(&pdev->dev, "Cpt_inst_s hexdump (%d bytes)\n",
-			 CPT_INST_SIZE);
-		print_hex_dump(KERN_INFO, "", 0, 16, 1, &cptinst,
-			       CPT_INST_SIZE, false);
-		dev_info(&pdev->dev, "Dptr hexdump (%d bytes)\n",
-			 cpt_req->dlen);
-		print_hex_dump(KERN_INFO, "", 0, 16, 1, info->in_buffer,
-			       cpt_req->dlen, false);
-	}
+	dump_sg_list(pdev, req);
+	pr_debug("Cpt_inst_s hexdump (%d bytes)\n", CPT_INST_SIZE);
+	print_hex_dump_debug("", 0, 16, 1, &cptinst, CPT_INST_SIZE, false);
+	pr_debug("Dptr hexdump (%d bytes)\n", cpt_req->dlen);
+	print_hex_dump_debug("", 0, 16, 1, info->in_buffer,
+			     cpt_req->dlen, false);
 
 	/* Send CPT command */
 	ops->send_cmd(&cptinst, 1, obj);
@@ -270,28 +265,25 @@ void dump_sg_list(struct pci_dev *pdev, struct cpt_request_info *req)
 {
 	int i;
 
-	dev_info(&pdev->dev, "Gather list size %d\n", req->incnt);
+	pr_debug("Gather list size %d\n", req->incnt);
 	for (i = 0; i < req->incnt; i++) {
-		dev_info(&pdev->dev,
-			 "Buffer %d size %d, vptr 0x%p, dmaptr 0x%p\n", i,
+		pr_debug("Buffer %d size %d, vptr 0x%p, dmaptr 0x%p\n", i,
 			 req->in[i].size, req->in[i].vptr,
 			 (void *) req->in[i].dma_addr);
-		dev_info(&pdev->dev, "Buffer hexdump (%d bytes)\n",
+		pr_debug("Buffer hexdump (%d bytes)\n",
 			 req->in[i].size);
-		print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
-			       req->in[i].vptr, req->in[i].size, false);
+		print_hex_dump_debug("", DUMP_PREFIX_NONE, 16, 1,
+				     req->in[i].vptr, req->in[i].size, false);
 	}
 
-	dev_info(&pdev->dev, "Scatter list size %d\n", req->outcnt);
+	pr_debug("Scatter list size %d\n", req->outcnt);
 	for (i = 0; i < req->outcnt; i++) {
-		dev_info(&pdev->dev,
-			 "Buffer %d size %d, vptr 0x%p, dmaptr 0x%p\n", i,
+		pr_debug("Buffer %d size %d, vptr 0x%p, dmaptr 0x%p\n", i,
 			 req->out[i].size, req->out[i].vptr,
 			 (void *) req->out[i].dma_addr);
-		dev_info(&pdev->dev, "Buffer hexdump (%d bytes)\n",
-			 req->out[i].size);
-		print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
-			       req->out[i].vptr, req->out[i].size, false);
+		pr_debug("Buffer hexdump (%d bytes)\n", req->out[i].size);
+		print_hex_dump_debug("", DUMP_PREFIX_NONE, 16, 1,
+				     req->out[i].vptr, req->out[i].size, false);
 	}
 }
 EXPORT_SYMBOL_GPL(dump_sg_list);
diff --git a/drivers/crypto/cavium/cpt/common/cpt_ucode.c b/drivers/crypto/cavium/cpt/common/cpt_ucode.c
index a501c3aed15d..d0b8f417194c 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_ucode.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_ucode.c
@@ -253,22 +253,20 @@ static void print_tar_dbg_info(struct device *dev,
 {
 	struct tar_ucode_info_t *curr;
 
-	dev_info(dev, "Tar archive filename %s", tar_filename);
-	dev_info(dev, "Tar archive pointer %p, size %ld", tar_arch->fw->data,
+	pr_debug("Tar archive filename %s", tar_filename);
+	pr_debug("Tar archive pointer %p, size %ld", tar_arch->fw->data,
 		 tar_arch->fw->size);
 	list_for_each_entry(curr, &tar_arch->ucodes, list) {
-		dev_info(dev, "Ucode filename %s", curr->ucode.filename);
-		dev_info(dev, "Ucode version string %s", curr->ucode.ver_str);
-		dev_info(dev, "Ucode version %d.%d.%d.%d",
+		pr_debug("Ucode filename %s", curr->ucode.filename);
+		pr_debug("Ucode version string %s", curr->ucode.ver_str);
+		pr_debug("Ucode version %d.%d.%d.%d",
 			 curr->ucode.ver_num.nn, curr->ucode.ver_num.xx,
 			 curr->ucode.ver_num.yy, curr->ucode.ver_num.zz);
-		dev_info(dev, "Ucode type (%d) %s", curr->ucode.type,
+		pr_debug("Ucode type (%d) %s", curr->ucode.type,
 			 get_ucode_type_str(curr->ucode.type));
-		dev_info(dev, "Ucode size %d", curr->ucode.size);
-		dev_info(dev, "Ucode ptr %p", curr->ucode_ptr);
-		dev_info(dev, "\n");
+		pr_debug("Ucode size %d", curr->ucode.size);
+		pr_debug("Ucode ptr %p\n", curr->ucode_ptr);
 	}
-	dev_info(dev, "\n");
 }
 
 static struct tar_arch_info_t *load_tar_archive(struct device *dev,
@@ -346,8 +344,7 @@ static struct tar_arch_info_t *load_tar_archive(struct device *dev,
 		tar_blk = (struct tar_blk_t *) &tar_arch->fw->data[tar_offs];
 	}
 
-	if (cpt_is_dbg_level_en(CPT_DBG_ENGINE_GRPS))
-		print_tar_dbg_info(dev, tar_arch, tar_filename);
+	print_tar_dbg_info(dev, tar_arch, tar_filename);
 	return tar_arch;
 err:
 	release_tar_archive(tar_arch);
@@ -450,16 +447,14 @@ static void print_engs_info(struct engine_group_info *eng_grp,
 
 static void print_ucode_dbg_info(struct device *dev, struct microcode *ucode)
 {
-	dev_info(dev, "\n");
-	dev_info(dev, "Ucode info");
-	dev_info(dev, "Ucode version string %s", ucode->ver_str);
-	dev_info(dev, "Ucode version %d.%d.%d.%d", ucode->ver_num.nn,
+	pr_debug("Ucode info");
+	pr_debug("Ucode version string %s", ucode->ver_str);
+	pr_debug("Ucode version %d.%d.%d.%d", ucode->ver_num.nn,
 		 ucode->ver_num.xx, ucode->ver_num.yy, ucode->ver_num.zz);
-	dev_info(dev, "Ucode type %s", get_ucode_type_str(ucode->type));
-	dev_info(dev, "Ucode size %d", ucode->size);
-	dev_info(dev, "Ucode virt address %16.16llx", (u64)ucode->align_va);
-	dev_info(dev, "Ucode phys address %16.16llx", ucode->align_dma);
-	dev_info(dev, "\n");
+	pr_debug("Ucode type %s", get_ucode_type_str(ucode->type));
+	pr_debug("Ucode size %d", ucode->size);
+	pr_debug("Ucode virt address %16.16llx", (u64)ucode->align_va);
+	pr_debug("Ucode phys address %16.16llx\n", ucode->align_dma);
 }
 
 static void print_dbg_info(struct device *dev,
@@ -473,23 +468,21 @@ static void print_dbg_info(struct device *dev,
 	u32 mask[4];
 	int i, j;
 
-	dev_info(dev, "\n");
-	dev_info(dev, "Engine groups global info");
-	dev_info(dev, "max SE %d, max IE %d, max AE %d",
+	pr_debug("Engine groups global info");
+	pr_debug("max SE %d, max IE %d, max AE %d",
 		 eng_grps->avail.max_se_cnt, eng_grps->avail.max_ie_cnt,
 		 eng_grps->avail.max_ae_cnt);
-	dev_info(dev, "free SE %d", eng_grps->avail.se_cnt);
-	dev_info(dev, "free IE %d", eng_grps->avail.ie_cnt);
-	dev_info(dev, "free AE %d", eng_grps->avail.ae_cnt);
-	dev_info(dev, "\n");
+	pr_debug("free SE %d", eng_grps->avail.se_cnt);
+	pr_debug("free IE %d", eng_grps->avail.ie_cnt);
+	pr_debug("free AE %d", eng_grps->avail.ae_cnt);
 
 	for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
 		grp = &eng_grps->grp[i];
-		dev_info(dev, "engine_group%d, state %s", i, grp->is_enabled ?
+		pr_debug("engine_group%d, state %s", i, grp->is_enabled ?
 			 "enabled" : "disabled");
 		if (grp->is_enabled) {
 			mirrored_grp = &eng_grps->grp[grp->mirror.idx];
-			dev_info(dev, "Ucode0 filename %s, version %s",
+			pr_debug("Ucode0 filename %s, version %s",
 				 grp->mirror.is_ena ?
 				 mirrored_grp->ucode[0].filename :
 				 grp->ucode[0].filename,
@@ -497,12 +490,11 @@ static void print_dbg_info(struct device *dev,
 				 mirrored_grp->ucode[0].ver_str :
 				 grp->ucode[0].ver_str);
 			if (is_2nd_ucode_used(grp))
-				dev_info(dev,
-					 "Ucode1 filename %s, version %s",
+				pr_debug("Ucode1 filename %s, version %s",
 					 grp->ucode[1].filename,
 					 grp->ucode[1].ver_str);
 			else
-				dev_info(dev, "Ucode1 not used");
+				pr_debug("Ucode1 not used");
 		}
 
 		for (j = 0; j < MAX_ENGS_PER_GRP; j++) {
@@ -510,22 +502,26 @@ static void print_dbg_info(struct device *dev,
 			if (engs->type) {
 				print_engs_info(grp, engs_info, 2*NAME_LENGTH,
 						j);
-				dev_info(dev, "Slot%d: %s", j, engs_info);
+				//dev_info(dev, "Slot%d: %s", j, engs_info);
+				pr_debug("Slot%d: %s", j, engs_info);
 				if (WARN_ON_ONCE(eng_grps->engs_num > 4 * 32))
 					return;
 				bitmap_to_arr32(mask, engs->bmap,
 						eng_grps->engs_num);
-				dev_info(dev, "Mask:  %8.8x %8.8x %8.8x %8.8x",
+				//dev_info(dev, "Mask:  %8.8x %8.8x %8.8x %8.8x",
+				pr_debug("Mask:  %8.8x %8.8x %8.8x %8.8x",
 					 mask[3], mask[2], mask[1], mask[0]);
 			} else
-				dev_info(dev, "Slot%d not used", j);
+				//dev_info(dev, "Slot%d not used", j);
+				pr_debug("Slot%d not used", j);
 		}
 		if (grp->is_enabled && eng_grps->ops.print_engines_mask) {
 			eng_grps->ops.print_engines_mask(grp, eng_grps->obj,
 						engs_mask, NAME_LENGTH);
-			dev_info(dev, "Cmask: %s", engs_mask);
+			//dev_info(dev, "Cmask: %s", engs_mask);
+			pr_debug("Cmask: %s", engs_mask);
 		}
-		dev_info(dev, "\n");
+		//dev_info(dev, "\n");
 	}
 }
 
@@ -822,8 +818,7 @@ static int ucode_load(struct device *dev, struct microcode *ucode,
 	if (ret)
 		goto err;
 
-	if (cpt_is_dbg_level_en(CPT_DBG_ENGINE_GRPS))
-		print_ucode_dbg_info(dev, ucode);
+	print_ucode_dbg_info(dev, ucode);
 err:
 	release_firmware(fw);
 	return ret;
@@ -1470,8 +1465,7 @@ static ssize_t ucode_load_store(struct device *dev,
 	if (ret)
 		goto err_unlock;
 
-	if (cpt_is_dbg_level_en(CPT_DBG_ENGINE_GRPS))
-		print_dbg_info(dev, eng_grps);
+	print_dbg_info(dev, eng_grps);
 err_unlock:
 	mutex_unlock(&eng_grps->lock);
 	return ret ? ret : count;
@@ -1606,8 +1600,7 @@ int cpt_try_create_default_eng_grps(struct pci_dev *pdev,
 			goto err;
 	}
 
-	if (cpt_is_dbg_level_en(CPT_DBG_ENGINE_GRPS))
-		print_dbg_info(&pdev->dev, eng_grps);
+	print_dbg_info(&pdev->dev, eng_grps);
 err:
 	release_tar_archive(tar_arch);
 	mutex_unlock(&eng_grps->lock);
@@ -1745,8 +1738,7 @@ int cpt_init_eng_grps(struct pci_dev *pdev, struct engine_groups *eng_grps,
 		goto err;
 	eng_grps->is_ucode_load_created = true;
 
-	if (cpt_is_dbg_level_en(CPT_DBG_ENGINE_GRPS))
-		print_dbg_info(&pdev->dev, eng_grps);
+	print_dbg_info(&pdev->dev, eng_grps);
 	return ret;
 err:
 	cpt_cleanup_eng_grps(pdev, eng_grps);
-- 
2.17.1


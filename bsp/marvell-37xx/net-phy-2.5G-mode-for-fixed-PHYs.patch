From ef9b7905c8fcf3d0a9e74acd457a59d8ffa2c695 Mon Sep 17 00:00:00 2001
From: Maxime Chevallier <maxime.chevallier@bootlin.com>
Date: Thu, 13 Dec 2018 14:31:35 +0100
Subject: [PATCH 120/386] net: phy: 2.5G mode for fixed PHYs

The CPU port on a DSA switch needs to be connected in fixed-link mode.
This mode uses an emumated PHY that exposes standard registers. However,
multiGigabit PHYs tend tu use standardised C45 registers to exposes
these modes, which aren't supported in swphy.

We could add these modes, and that will probably be done in mainline,
but in a way that is very difficult to backport. It implies reworking
the way we represent link-modes, which impacts all drivers in
net/ethernet and net/phy.

For now, add a way to simulate this feature by hardcoding the
phy_interface_modes that would need such PHYs to be emulated.

Change-Id: I31d82b60bb2fc3bb049b67f85a542d1fae1f1c00
Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
Reviewed-on: https://sj1git1.cavium.com/6488
Reviewed-by: Stefan Chulski <Stefan.Chulski@cavium.com>
Tested-by: sa_ip-sw-jenkins
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 drivers/net/phy/phy_device.c | 73 ++++++++++++++++++++++++------------
 drivers/net/phy/swphy.c      |  3 ++
 2 files changed, 52 insertions(+), 24 deletions(-)

diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index c10fc2bc9f46..5cd1c8dc3d6e 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1540,8 +1540,20 @@ int genphy_read_status(struct phy_device *phydev)
 		return err;
 
 	phydev->lp_advertising = 0;
+	/* Not upstream : For high speed modes, we would need to read C45
+	 * registers, that need to be emulated in fixed-link mode. This is
+	 * especially needed for DSA phy interfaces. A solution will be proposed
+	 * in mainline, that relies on redefinind the link mode representation,
+	 * which is very hard to backport. For now, hardcode the link parameters
+	 * directly here if we detect that the interface_mode is a high speed
+	 * one.
+	 */
 
-	if (AUTONEG_ENABLE == phydev->autoneg) {
+	if (phydev->interface == PHY_INTERFACE_MODE_2500BASEX) {
+		phydev->speed = SPEED_2500;
+		phydev->duplex = DUPLEX_FULL;
+		phydev->link = 1;
+	} else if (phydev->autoneg == AUTONEG_ENABLE) {
 		if (phydev->supported & (SUPPORTED_1000baseT_Half
 					| SUPPORTED_1000baseT_Full)) {
 			lpagb = phy_read(phydev, MII_STAT1000);
@@ -1648,32 +1660,45 @@ int genphy_config_init(struct phy_device *phydev)
 			| SUPPORTED_AUI | SUPPORTED_FIBRE |
 			SUPPORTED_BNC | SUPPORTED_Pause | SUPPORTED_Asym_Pause);
 
-	/* Do we support autonegotiation? */
-	val = phy_read(phydev, MII_BMSR);
-	if (val < 0)
-		return val;
-
-	if (val & BMSR_ANEGCAPABLE)
-		features |= SUPPORTED_Autoneg;
-
-	if (val & BMSR_100FULL)
-		features |= SUPPORTED_100baseT_Full;
-	if (val & BMSR_100HALF)
-		features |= SUPPORTED_100baseT_Half;
-	if (val & BMSR_10FULL)
-		features |= SUPPORTED_10baseT_Full;
-	if (val & BMSR_10HALF)
-		features |= SUPPORTED_10baseT_Half;
-
-	if (val & BMSR_ESTATEN) {
-		val = phy_read(phydev, MII_ESTATUS);
+	/* Not upstream : For high speed modes, we would need to read C45
+	 * registers, that need to be emulated in fixed-link mode. This is
+	 * especially needed for DSA phy interfaces. A solution will be proposed
+	 * in mainline, that relies on redefinind the link mode representation,
+	 * which is very hard to backport. For now, hardcode the link parameters
+	 * directly here if we detect that the interface_mode is a high speed
+	 * one.
+	 */
+
+	if (phydev->interface == PHY_INTERFACE_MODE_2500BASEX) {
+		features |= SUPPORTED_2500baseX_Full;
+	} else {
+		/* Do we support autonegotiation? */
+		val = phy_read(phydev, MII_BMSR);
 		if (val < 0)
 			return val;
 
-		if (val & ESTATUS_1000_TFULL)
-			features |= SUPPORTED_1000baseT_Full;
-		if (val & ESTATUS_1000_THALF)
-			features |= SUPPORTED_1000baseT_Half;
+		if (val & BMSR_ANEGCAPABLE)
+			features |= SUPPORTED_Autoneg;
+
+		if (val & BMSR_100FULL)
+			features |= SUPPORTED_100baseT_Full;
+		if (val & BMSR_100HALF)
+			features |= SUPPORTED_100baseT_Half;
+		if (val & BMSR_10FULL)
+			features |= SUPPORTED_10baseT_Full;
+		if (val & BMSR_10HALF)
+			features |= SUPPORTED_10baseT_Half;
+
+		if (val & BMSR_ESTATEN) {
+			val = phy_read(phydev, MII_ESTATUS);
+			if (val < 0)
+				return val;
+
+			if (val & ESTATUS_1000_TFULL)
+				features |= SUPPORTED_1000baseT_Full;
+			if (val & ESTATUS_1000_THALF)
+				features |= SUPPORTED_1000baseT_Half;
+		}
 	}
 
 	phydev->supported &= features;
diff --git a/drivers/net/phy/swphy.c b/drivers/net/phy/swphy.c
index 34f58f2349e9..98fbe3e0260d 100644
--- a/drivers/net/phy/swphy.c
+++ b/drivers/net/phy/swphy.c
@@ -33,6 +33,7 @@ enum {
 	SWMII_SPEED_10 = 0,
 	SWMII_SPEED_100,
 	SWMII_SPEED_1000,
+	SWMII_SPEED_2500,
 	SWMII_DUPLEX_HALF = 0,
 	SWMII_DUPLEX_FULL,
 };
@@ -77,6 +78,8 @@ static const struct swmii_regs duplex[] = {
 static int swphy_decode_speed(int speed)
 {
 	switch (speed) {
+	case 2500:
+		return SWMII_SPEED_2500;
 	case 1000:
 		return SWMII_SPEED_1000;
 	case 100:
-- 
2.17.1


From 5864b140e8e377f5699b93533627a604fd9f259a Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Tue, 19 Mar 2019 16:48:04 +0530
Subject: [PATCH 073/386] octeontx2-af: Consolidate NIX HW issue workarounds

This is a cleanup aimed to get rid of silicon variant
checks spilled over multiple places. All NIX block
related workarounds are moved to a single location.

Change-Id: I7933aa2ce6b807374466e9aa5fad457224050209
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/6265
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |  6 +--
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c | 45 ++++++++++++++-----
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   | 14 +-----
 3 files changed, 39 insertions(+), 26 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index c8ebe1c134fc..a4da3e9c50d9 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -619,10 +619,8 @@ void rvu_nix_update_link_credits(struct rvu *rvu, int blkaddr,
 void rvu_nix_update_sq_smq_mapping(struct rvu *rvu, int blkaddr, int nixlf,
 				   u16 sq, u16 smq);
 void rvu_nix_txsch_config_changed(struct nix_hw *nix_hw);
-int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
-				     struct nix_hw *nix_hw, int blkaddr);
-void rvu_nix_tx_stall_workaround_exit(struct rvu *rvu, struct nix_hw *nix_hw);
 ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 				      char __user *buffer, loff_t *ppos);
-void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr);
+int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr);
+void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw);
 #endif /* RVU_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 1fc2ee12f9ae..b8433aaa911b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -689,17 +689,14 @@ static int rvu_nix_init_tl_map(struct rvu *rvu, struct nix_hw *nix_hw, int lvl)
 	return 0;
 }
 
-int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
-				     struct nix_hw *nix_hw, int blkaddr)
+static int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
+					    struct nix_hw *nix_hw, int blkaddr)
 {
 	struct rvu_hwinfo *hw = rvu->hw;
 	struct nix_tx_stall *tx_stall;
 	struct rvu_block *block;
 	int links, err;
 
-	if (!is_rvu_9xxx_A0(rvu))
-		return 0;
-
 	tx_stall = devm_kzalloc(rvu->dev,
 				sizeof(struct nix_tx_stall), GFP_KERNEL);
 	if (!tx_stall)
@@ -784,13 +781,11 @@ int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
 	return 0;
 }
 
-void rvu_nix_tx_stall_workaround_exit(struct rvu *rvu, struct nix_hw *nix_hw)
+static void rvu_nix_tx_stall_workaround_exit(struct rvu *rvu,
+					     struct nix_hw *nix_hw)
 {
 	struct nix_tx_stall *tx_stall = nix_hw->tx_stall;
 
-	if (!is_rvu_9xxx_A0(rvu))
-		return;
-
 	if (!tx_stall)
 		return;
 
@@ -860,7 +855,7 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 	return len;
 }
 
-void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr)
+static void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr)
 {
 	/* An issue exists in A0 silicon whereby, NIX CQ may reach in CQ full
 	 * state followed by CQ hang on CQM query response from stale
@@ -876,3 +871,33 @@ void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr)
 			    BIT_ULL(43) | BIT_ULL(23) | BIT_ULL(22) | 0x100ULL);
 	}
 }
+
+int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
+{
+	int err;
+
+	if (!is_rvu_9xxx_A0(rvu))
+		return 0;
+
+	/* As per a HW errata in 9xxx A0 silicon, NIX may corrupt
+	 * internal state when conditional clocks are turned off.
+	 * Hence enable them.
+	 */
+	rvu_write64(rvu, blkaddr, NIX_AF_CFG,
+		    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
+
+	err = rvu_nix_tx_stall_workaround_init(rvu, nix_hw, blkaddr);
+	if (err)
+		return err;
+
+	rvu_nix_enable_internal_bp(rvu, blkaddr);
+	return 0;
+}
+
+void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw)
+{
+	if (!is_rvu_9xxx_A0(rvu))
+		return;
+
+	rvu_nix_tx_stall_workaround_exit(rvu, nix_hw);
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index b1106258c36b..9c7f14dacba9 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -3000,16 +3000,6 @@ int rvu_nix_init(struct rvu *rvu)
 		return 0;
 	block = &hw->block[blkaddr];
 
-	/* As per a HW errata in 9xxx A0 silicon, NIX may corrupt
-	 * internal state when conditional clocks are turned off.
-	 * Hence enable them.
-	 */
-	if (is_rvu_9xxx_A0(rvu))
-		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
-
-	rvu_nix_enable_internal_bp(rvu, blkaddr);
-
 	/* Calibrate X2P bus to check if CGX/LBK links are fine */
 	err = nix_calibrate_x2p(rvu, blkaddr);
 	if (err)
@@ -3090,7 +3080,7 @@ int rvu_nix_init(struct rvu *rvu)
 		/* Enable Channel backpressure */
 		rvu_write64(rvu, blkaddr, NIX_AF_RX_CFG, BIT_ULL(0));
 
-		err = rvu_nix_tx_stall_workaround_init(rvu, hw->nix0, blkaddr);
+		err = rvu_nix_fixes_init(rvu, hw->nix0, blkaddr);
 		if (err)
 			return err;
 	}
@@ -3127,7 +3117,7 @@ void rvu_nix_freemem(struct rvu *rvu)
 		qmem_free(rvu->dev, mcast->mce_ctx);
 		qmem_free(rvu->dev, mcast->mcast_buf);
 		mutex_destroy(&mcast->mce_lock);
-		rvu_nix_tx_stall_workaround_exit(rvu, nix_hw);
+		rvu_nix_fixes_exit(rvu, nix_hw);
 	}
 }
 
-- 
2.17.1


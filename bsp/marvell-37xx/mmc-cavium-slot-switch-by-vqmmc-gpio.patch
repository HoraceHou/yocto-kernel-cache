From de2103d9f5dd912bb20fc8a6e0b49da34f8699df Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Tue, 8 Jan 2019 14:52:17 -0800
Subject: [PATCH 348/386] mmc: cavium: slot switch by vqmmc/gpio

Octeon/OcteonTX MMC supports up to 3 mmc slots, but any
level-shifting to accommodate different signal voltages is
done by external hardware, under control of an optional
vqmmc regulator object, typically controlled by gpio.

See Documentation/devicetree/bindings/mmc/cavium-mmc.txt
for a detailed explanation of device-tree control of MMC
signals via GPIO at reset and slot-switching time.

If any mmc-slots have a vqmmc-supply property,
take it as a warning that we must switch carefully between
slots (unless they have the same vqmmc object), tri-stating
MMC signals to avoid any transient states as level-shifters
are enabled/disabled, by zeroing MIO_EMM_CFG[bus_id].

During this vqmmc-switching, care must be taken to never
completely zero MIO_EMM_CFG, as this resets the host controller,
so the "phantom" slot3 is enabled during the switch.

There's no need to list vqmmc property if all the mmc-slots
on a board run at same signal voltage, and have same width.
In this case the old behavior, enabling all probed slots in
MIO_EMM_CFG, allows faster slot-switching.

Change-Id: I6994d52a33b6f7f1911ab0f14b8639823ac20488
Signed-off-by: Peter Swain <pswain@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/8728
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../devicetree/bindings/mmc/cavium-mmc.txt    | 48 +++++++++++++++++--
 drivers/mmc/host/cavium.c                     | 31 +++++++++++-
 drivers/mmc/host/cavium.h                     |  1 +
 3 files changed, 75 insertions(+), 5 deletions(-)

diff --git a/Documentation/devicetree/bindings/mmc/cavium-mmc.txt b/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
index 60c342d9f353..f486ce44bdcb 100644
--- a/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
+++ b/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
@@ -25,10 +25,50 @@ Optional properties:
  - cavium,clk-slew     : eMMC bus pins output slew rate control
 
 Deprecated properties:
-- spi-max-frequency : use max-frequency instead
-- cavium,bus-max-width : use bus-width instead
-- power-gpios : use vmmc-supply instead
-- cavium,octeon-6130-mmc-slot : use mmc-slot instead
+ - spi-max-frequency : use max-frequency instead
+ - cavium,bus-max-width : use bus-width instead
+ - power-gpios : use vmmc-supply instead
+ - cavium,octeon-6130-mmc-slot : use mmc-slot instead
+
+GPIO control via vmmc-supply & vqmmc-supply:
+  Two types of regulator object can be specified as mmc properties,
+  typically regulator-fixed controlled by GPIO pins.
+
+  Octeon/OcteonTX chips commonly use GPIO8 as an MMC-reset pin.
+  In systems which may boot from MMC, it starts as input, and is gently
+  pulled up/down by board logic to indicate the active sense of the
+  signal. Chip reset then drives the signal in the opposite direction
+  to effect a reset of target devices.
+  Device tree should model this with a vmmc-supply regulator, gated by
+  GPIO8, so GPIO8 is driven in the non-reset direction when MMC devices
+  are probed, and held there until rmmod/shutdown/suspend.
+  This allows a warm reboot to reset the MMC devices.
+
+  Octeon/OcteonTX MMC supports up to 3 mmc slots, but any
+  level-shifting to accommodate different signal voltages is
+  done by external hardware, under control of an optional
+  vqmmc regulator object, typically controlled by GPIO.
+
+  If any mmc-slots have a vqmmc-supply property, it is taken as a warning
+  that we must switch carefully between slots (unless they have the same
+  vqmmc object), tri-stating MMC signals to avoid any transient states
+  as level-shifters are enabled/disabled.
+
+  Even when so-called bi-directional level shifters are used,
+  this technique should be employed when using different bus-widths
+  on different slots, disabling level shifters to avoid presenting
+  non-uniform impedance across DATA0-7 & CMD when non-selected
+  4-wide slots are left enabled, while accessing 8-wide targets.
+
+  Note that it's not possible to specify multiple regulators
+  controlled by same GPIO pin, but with different active state.
+  If one GPIO line is require to switch voltage/routing between
+  different mmc-slots, specify a vqmmc-supply on one slot, but
+  not the other. The regulator_disable call on leaving that slot
+  will implicitly switch the state to support the unmarked slot.
+
+  There's no need to list vqmmc-supply if all the mmc-slots on
+  a board run at same voltage, and have same width.
 
 Examples:
 	mmc_1_4: mmc@1,4 {
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 8fc197581962..be1c215b20ac 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -306,15 +306,37 @@ static bool pre_switch(struct cvm_mmc_host *host, u64 emm_switch)
 	int bus_id = get_bus_id(emm_switch);
 	struct cvm_mmc_slot *slot = host->slot[bus_id];
 	struct cvm_mmc_slot *old_slot;
+	bool same_vqmmc = false;
 
 	if (host->last_slot == bus_id)
 		return false;
 
+	/* when VQMMC is switched, tri-state CMDn over any slot change
+	 * to avoid transient states on D0-7 or CLK from level-shifters
+	 */
+	if (host->use_vqmmc) {
+		writeq(1ull << 3, host->base + MIO_EMM_CFG(host));
+		udelay(10);
+	}
+
 	if (host->last_slot >= 0 && host->slot[host->last_slot]) {
 		old_slot = host->slot[host->last_slot];
 		old_slot->cached_switch =
 		    readq(host->base + MIO_EMM_SWITCH(host));
 		old_slot->cached_rca = readq(host->base + MIO_EMM_RCA(host));
+
+		same_vqmmc = (slot->mmc->supply.vqmmc ==
+				old_slot->mmc->supply.vqmmc);
+		if (!same_vqmmc && !IS_ERR_OR_NULL(old_slot->mmc->supply.vqmmc))
+			regulator_disable(old_slot->mmc->supply.vqmmc);
+	}
+
+	if (!same_vqmmc && !IS_ERR_OR_NULL(slot->mmc->supply.vqmmc)) {
+		int e = regulator_enable(slot->mmc->supply.vqmmc);
+
+		if (e)
+			dev_err(host->dev, "mmc-slot@%d.vqmmc err %d\n",
+						bus_id, e);
 	}
 
 	host->last_slot = slot->bus_id;
@@ -327,6 +349,12 @@ static void post_switch(struct cvm_mmc_host *host, u64 emm_switch)
 	int bus_id = get_bus_id(emm_switch);
 	struct cvm_mmc_slot *slot = host->slot[bus_id];
 
+	if (host->use_vqmmc) {
+		/* enable new CMDn */
+		writeq(1ull << bus_id, host->base + MIO_EMM_CFG(host));
+		udelay(10);
+	}
+
 	writeq(slot->cached_rca, host->base + MIO_EMM_RCA(host));
 }
 
@@ -1582,7 +1610,7 @@ static int cvm_mmc_init_lowlevel(struct cvm_mmc_slot *slot)
 	struct cvm_mmc_host *host = slot->host;
 	u64 emm_switch;
 
-	/* Enable this bus slot */
+	/* Enable this bus slot. Overridden when vqmmc-switching engaged */
 	host->emm_cfg |= (1ull << slot->bus_id);
 	writeq(host->emm_cfg, slot->host->base + MIO_EMM_CFG(host));
 	udelay(10);
@@ -1763,6 +1791,7 @@ int cvm_mmc_of_slot_probe(struct device *dev, struct cvm_mmc_host *host)
 
 	host->acquire_bus(host);
 	host->slot[id] = slot;
+	host->use_vqmmc |= !IS_ERR_OR_NULL(slot->mmc->supply.vqmmc);
 	cvm_mmc_init_lowlevel(slot);
 	cvm_mmc_switch_to(slot);
 	host->release_bus(host);
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 57709dfbf306..d85b171de620 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -110,6 +110,7 @@ struct cvm_mmc_host {
 	bool use_sg;
 	bool has_ciu3;
 	bool powered;
+	bool use_vqmmc; /* must disable slots over switch */
 	bool big_dma_addr;
 	bool need_irq_handler_lock;
 	spinlock_t irq_handler_lock;
-- 
2.17.1


From f3975f0d3d27208c82248299a642f01459e02229 Mon Sep 17 00:00:00 2001
From: Vidhya Vidhyaraman <vraman@marvell.com>
Date: Thu, 16 May 2019 21:55:59 -0700
Subject: [PATCH 235/386] octeontx: Add 16ports to LBK0 device

This commit enables multiple ports on
LBK0 device in 83xx where the channels are
crossconnected as 0-1, 2-3 and vice versa
until channel 15. This enables two ODP process
to communicate with each other over LBK0 port

Change-Id: Ief2aaaa43732c1b1bdbf33d6922eabd4d8e100d4
Signed-off-by: Vidhya Vidhyaraman <vraman@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8756
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../ethernet/cavium/octeontx-83xx/lbk_main.c  | 68 +++++++++++++------
 .../ethernet/cavium/octeontx-83xx/octeontx.h  | 17 ++++-
 .../cavium/octeontx-83xx/octeontx_main.c      | 27 +++++++-
 .../cavium/octeontx-83xx/pki_config.c         |  2 +-
 .../cavium/octeontx-83xx/pkopf_main.c         | 16 ++++-
 5 files changed, 102 insertions(+), 28 deletions(-)

diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c
index 26293b510779..956571aad2aa 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c
@@ -26,7 +26,10 @@
 #define LBK_NODE_SHIFT		2
 #define LBK_DEV_PER_CPU		BIT(LBK_NODE_SHIFT)
 #define LBK_DEV_MASK		(LBK_DEV_PER_CPU - 1)
-#define LBK_MAX_PORTS		(2 * OCTTX_MAX_NODES)
+#define LBK0_MAX_PORTS      16
+#define LBK1_MAX_PORTS      1
+/* 16 ports in lbk0 device and 1 port in lbk1/lbk2 device */
+#define LBK_MAX_PORTS		(LBK0_MAX_PORTS + LBK1_MAX_PORTS)
 #define LBK_INVALID_ID		(-1)
 
 #define LBK_NUM_CHANS		64
@@ -70,7 +73,22 @@ static DEFINE_MUTEX(octeontx_lbk_lock);
 static LIST_HEAD(octeontx_lbk_devices);
 static struct octtx_lbk_port octeontx_lbk_ports[LBK_MAX_PORTS] = {
 	{.glb_port_idx = 0, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 1, .domain_id = LBK_INVALID_ID}
+	{.glb_port_idx = 1, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 2, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 3, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 4, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 5, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 6, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 7, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 8, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 9, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 10, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 11, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 12, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 13, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 14, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 15, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = 16, .domain_id = LBK_INVALID_ID}
 };
 
 /* Interface with Thunder NIC driver */
@@ -245,7 +263,7 @@ int lbk_port_start(struct octtx_lbk_port *port)
 	int rc, pkind, i;
 	struct lbkpf *lbk;
 
-	if (port->glb_port_idx == 1) {
+	if (port->glb_port_idx == LBK_PORT_PN_BASE_IDX) {
 		rc = thlbk->port_start();
 		if (rc)
 			return -EIO;
@@ -253,12 +271,11 @@ int lbk_port_start(struct octtx_lbk_port *port)
 	} else {
 		pkind = port->pkind;
 	}
+	i = port->glb_port_idx;
 	lbk = get_lbk_dev(port->node, port->ilbk);
-	for (i = 0; i < lbk->channels; i++)
-		lbk_reg_write(lbk, LBK_CH_PKIND(i), port->pkind);
+	lbk_reg_write(lbk, LBK_CH_PKIND(i), port->pkind);
 	lbk = get_lbk_dev(port->node, port->olbk);
-	for (i = 0; i < lbk->channels; i++)
-		lbk_reg_write(lbk, LBK_CH_PKIND(i), pkind);
+	lbk_reg_write(lbk, LBK_CH_PKIND(i), pkind);
 	return 0;
 }
 
@@ -267,14 +284,13 @@ int lbk_port_stop(struct octtx_lbk_port *port)
 	struct lbkpf *lbk;
 	int i;
 
-	if (port->glb_port_idx == 1)
+	if (port->glb_port_idx == LBK_PORT_PN_BASE_IDX)
 		thlbk->port_stop();
+	i = port->glb_port_idx;
 	lbk = get_lbk_dev(port->node, port->ilbk);
-	for (i = 0; i < lbk->channels; i++)
-		lbk_reg_write(lbk, LBK_CH_PKIND(i), 0);
+	lbk_reg_write(lbk, LBK_CH_PKIND(i), 0);
 	lbk = get_lbk_dev(port->node, port->olbk);
-	for (i = 0; i < lbk->channels; i++)
-		lbk_reg_write(lbk, LBK_CH_PKIND(i), 0);
+	lbk_reg_write(lbk, LBK_CH_PKIND(i), 0);
 	return 0;
 }
 
@@ -371,7 +387,8 @@ static int lbk_create_domain(u32 id, u16 domain_id,
 		port = &port_tbl[i];
 		for (j = 0; j < LBK_MAX_PORTS; j++) {
 			gport = &octeontx_lbk_ports[j];
-			if (port->glb_port_idx != gport->glb_port_idx)
+			if (LBK_PORT_GIDX_PRIM(port) !=
+					LBK_PORT_GIDX_PRIM(gport))
 				continue;
 			/* Check for conflicts with other domains. */
 			if (gport->domain_id != LBK_INVALID_ID) {
@@ -501,22 +518,29 @@ static int lbk_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* Setup LBK Port */
 	if (lbk->iconn == LBK_CONNECT_E_PKI &&
 	    lbk->oconn == LBK_CONNECT_E_PKO) {
-		port = &octeontx_lbk_ports[0];
-		port->ilbk = lbk_index_from_id(lbk->id);
-		port->olbk = lbk_index_from_id(lbk->id);
-		port->ilbk_base_chan = LBK_BASE_CHAN(port->ilbk);
-		port->ilbk_num_chans = LBK_NUM_CHANS;
-		port->olbk_base_chan = LBK_BASE_CHAN(port->olbk);
-		port->olbk_num_chans = LBK_NUM_CHANS;
+		int i;
+
+		for (i = 0; i < LBK0_MAX_PORTS; i++) {
+			/* 16 lbk0 ports at index 0-15 */
+			port = &octeontx_lbk_ports[i];
+			port->ilbk = lbk_index_from_id(lbk->id);
+			port->olbk = lbk_index_from_id(lbk->id);
+			port->ilbk_base_chan = LBK_BASE_CHAN(port->ilbk) + i;
+			/* One channel port lbk0 port */
+			port->ilbk_num_chans = 1;
+			port->olbk_base_chan = LBK_BASE_CHAN(port->olbk) + i;
+			port->olbk_num_chans = 1;
+		}
 	} else if (lbk->iconn == LBK_CONNECT_E_PKI &&
 			lbk->oconn == LBK_CONNECT_E_NIC) {
-		port = &octeontx_lbk_ports[1];
+		/* LBK1/LBK2 has one port at index 16 */
+		port = &octeontx_lbk_ports[LBK_PORT_PN_BASE_IDX];
 		port->ilbk = lbk_index_from_id(lbk->id);
 		port->ilbk_base_chan = LBK_BASE_CHAN(port->ilbk);
 		port->ilbk_num_chans = LBK_NUM_CHANS;
 	} else if (lbk->iconn == LBK_CONNECT_E_NIC &&
 			lbk->oconn == LBK_CONNECT_E_PKO) {
-		port = &octeontx_lbk_ports[1];
+		port = &octeontx_lbk_ports[LBK_PORT_PN_BASE_IDX];
 		port->olbk = lbk_index_from_id(lbk->id);
 		port->olbk_base_chan = LBK_BASE_CHAN(port->olbk);
 		port->olbk_num_chans = LBK_NUM_CHANS;
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h
index 747095a07c74..d2d0f3473705 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h
@@ -130,7 +130,18 @@ struct octtx_bgx_port {
 };
 
 /* Domain internal (LBK) port */
-#define OCTTX_MAX_LBK_PORTS 2 /* Maximum LBK ports per System */
+#define LBK_PORT_INVAL     0xFF
+/* Number of LBK1/LBK2 port */
+#define LBK_PORT_PN_MAX        1
+/* Number of LBK0 ports */
+#define LBK_PORT_PP_MAX        BIT(4)
+/* Index of LBK1/LBK2 port */
+#define LBK_PORT_PN_BASE_IDX   16
+/* Base port index of lbk0 port */
+#define LBK_PORT_PP_BASE_IDX   0
+#define LBK0_DEVICE   0
+#define LBK1_DEVICE   1
+#define OCTTX_MAX_LBK_PORTS    (LBK_PORT_PN_MAX + LBK_PORT_PP_MAX)
 
 struct octtx_lbk_port {
 	struct list_head list;
@@ -149,6 +160,10 @@ struct octtx_lbk_port {
 	void	*vnic; /* NIC port descriptor */
 };
 
+/* LBK port/peer global indexes: (8-bit peer << 8) | 8-bit port. */
+#define LBK_PORT_GIDX_FULL_GEN(_i, _k) (((_i) << 4) | (_k))
+#define LBK_PORT_GIDX_PRIM(_p) ((_p)->glb_port_idx & 0x1FF)
+
 extern atomic_t octtx_sso_reset[];
 /* Domain internal (SDP) port */
 #define OCTTX_MAX_SDP_PORTS 1 /* Maximum SDP ports per System */
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c
index 8d7667cc6281..a3c5cf28487b 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c
@@ -193,6 +193,7 @@ static ssize_t octtx_create_domain_store(struct device *dev,
 	long int bgx_port[OCTTX_MAX_BGX_PORTS];
 	long int sdp_port[OCTTX_MAX_SDP_PORTS];
 	char *errmsg = "Wrong domain specification format.";
+	long i, k;
 
 	end = kzalloc(PAGE_SIZE, GFP_KERNEL);
 	ptr = end;
@@ -274,6 +275,30 @@ static ssize_t octtx_create_domain_store(struct device *dev,
 			if (kstrtol(strim(start), 10, &lbk_port[lbk_count]))
 				goto error;
 			lbk_count++;
+		} else if (!strncmp(strim(start), "lbk", sizeof("lbk") - 1)) {
+			/* lbk:X:X - LBK port format is */
+			/* LBK<device_id>:<channel_num> */
+			temp = strsep(&start, ":");
+			if (!start)
+				goto error;
+			temp = strsep(&start, ":");
+			if (!temp)
+				goto error;
+			if (kstrtol(strim(temp), 10, &i))
+				goto error;
+			if (start) {
+				if (kstrtol(strim(start), 10, &k))
+					goto error;
+			} else {
+				k = LBK_PORT_INVAL;
+			}
+			if (i != LBK0_DEVICE && i != LBK1_DEVICE)
+				goto error;
+			if (k < LBK_PORT_PP_BASE_IDX ||
+			    k > (LBK_PORT_PP_MAX - 1))
+				goto error;
+			lbk_port[lbk_count] = LBK_PORT_GIDX_FULL_GEN(i, k);
+			lbk_count++;
 		} else if (!strncmp(start, "dpi", sizeof("dpi") - 1)) {
 			temp = strsep(&start, ":");
 			if (!start)
@@ -849,7 +874,7 @@ int octeontx_create_domain(const char *name, int type, int sso_count,
 	 */
 	domain->lbk_count = 0;
 	for (i = 0; i < lbk_count; i++) {
-		if (lbk_port[i] > 1) {
+		if (lbk_port[i] > LBK_PORT_PN_BASE_IDX) {
 			dev_err(octtx_device, "LBK invalid port g%ld\n",
 				lbk_port[i]);
 			goto error;
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c b/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
index 7982503f17c0..d25f4e9ffe13 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
@@ -114,7 +114,7 @@ int assign_pkind_lbk(struct pkipf_vf *vf, struct octtx_lbk_port *port)
 	if (vf->lbk_port[port->dom_port_idx].valid)
 		return -EEXIST;
 
-	pkind = LBK_PKIND_BASE + port->glb_port_idx;
+	pkind = LBK_PKIND_BASE + LBK_PORT_GIDX_PRIM(port);
 
 	if (pkind > (LBK_PKIND_BASE + MAX_LBK_PKIND))
 		return -EINVAL;
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/pkopf_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/pkopf_main.c
index 158a12231b0e..ca867fab3030 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/pkopf_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/pkopf_main.c
@@ -94,9 +94,18 @@ static int pko_get_sdp_mac(int sdp, int lmac)
 	return lmac;
 }
 
-static int pko_get_lbk_chan(int lbk, int chan)
+static int pko_get_lbk_chan(int lbk_base_chan, int lbk_port)
 {
-	return LBK_CHAN_BASE + (LBK_CHAN_RANGE * lbk) + chan;
+	int chan;
+
+	/* lbk0 ports are 0-15 and are cross connected in PKO channels */
+	/* i.e channel 0 connected to 1 and vice versa and so on until */
+	/* channel 15 */
+	if (lbk_port < LBK_PORT_PN_BASE_IDX)
+		chan = (lbk_port & 0x1) ? (lbk_port - 1) : (lbk_port + 1);
+	else /* lbk1/lbk2 port is connected to base channel id */
+		chan = lbk_base_chan;
+	return chan;
 }
 
 static int pko_get_lbk_mac(int lbk)
@@ -459,7 +468,8 @@ static int pko_pf_create_domain(u32 id, u16 domain_id, u32 pko_vf_count,
 				mac_num = pko_get_lbk_mac(
 						lbk_port[port_idx].olbk);
 				chan = pko_get_lbk_chan(
-						lbk_port[port_idx].olbk, 0);
+				lbk_port[port_idx].olbk_base_chan,
+				lbk_port[port_idx].glb_port_idx);
 				mac_mode = 0;
 				port_idx++;
 			} else {
-- 
2.17.1


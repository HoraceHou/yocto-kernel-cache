From 948324dd54bbb34472153f5ecad6e8af72c7fb6a Mon Sep 17 00:00:00 2001
From: SrujanaChalla <schalla@marvell.com>
Date: Tue, 2 Jul 2019 16:36:00 +0530
Subject: [PATCH 321/386] crypto:cpt - allow user to set LFs for kernel VF
 driver

This patch will create a sysfs entry which can be used to change/set
the number of CPT LFs for CPT kernel VF driver.

Tested these changes by running kernel ipsec on 24 cores by setting
variable number of lfs through sysfs entry,
For example:
echo 4 >/sys/bus/pci/drivers/octeontx2-cpt/#BDF/kvf_limits
echo 1 >/sys/bus/pci/drivers/octeontx2-cpt/#BDF/sriov_numvfs

Change-Id: I04844d3f2540d64a33c694c7262e7de37b0340e8
Signed-off-by: SrujanaChalla <schalla@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/11920
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Lukas Bartosik <lbartosik@marvell.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 drivers/crypto/cavium/cpt/9x/cpt9x_pf.h      |  6 ++
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c | 91 +++++++++++++++++---
 2 files changed, 87 insertions(+), 10 deletions(-)

diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h b/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h
index 8cf2a7007fff..f660705322c2 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h
@@ -30,6 +30,11 @@ struct cpt_limits {
 	struct quotas *cpt;
 };
 
+struct cpt_kvf_limits {
+	struct device_attribute kvf_limits_attr;
+	int lfs_num; /* Number of LFs allocated for kernel VF driver */
+};
+
 struct cptpf_dev {
 	void __iomem *reg_base;		/* CPT PF registers start address */
 	void __iomem *afpf_mbox_base;	/* PF-AF mbox start address */
@@ -40,6 +45,7 @@ struct cptpf_dev {
 	struct free_rsrcs_rsp limits;   /* Maximum limits for all VFs and PF */
 	struct cpt_limits vf_limits;	/* Limits for each VF */
 	struct engine_groups eng_grps;	/* Engine groups information */
+	struct cpt_kvf_limits kvf_limits; /* Kernel vf limits */
 
 	/* AF <=> PF mbox */
 	struct otx2_mbox	afpf_mbox;
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
index 91e592b6b554..91b88a5f31d2 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
@@ -353,7 +353,7 @@ static void cpt_destroy_sysfs_vf_limits(struct cptpf_dev *cptpf)
 
 static int cpt_alloc_vf_limits(struct cptpf_dev *cptpf)
 {
-	int avail_lfs, lfs_per_vf;
+	int avail_lfs, lfs_per_vf, kvf_lfs;
 	int i, ret, online_cpus;
 
 	mutex_init(&cptpf->vf_limits.lock);
@@ -371,15 +371,21 @@ static int cpt_alloc_vf_limits(struct cptpf_dev *cptpf)
 	}
 
 	avail_lfs = cptpf->vf_limits.cpt->max_sum;
-	online_cpus = num_online_cpus();
-	if (avail_lfs < online_cpus) {
-		dev_err(&cptpf->pdev->dev,
-			"CPT LFs num %d < than required for kernel crypto %d",
-			avail_lfs, online_cpus);
-		ret = -ENOENT;
-		goto error;
+	if (cptpf->kvf_limits.lfs_num) {
+		avail_lfs -= cptpf->kvf_limits.lfs_num;
+		kvf_lfs = cptpf->kvf_limits.lfs_num;
+	} else {
+		online_cpus = num_online_cpus();
+		if (avail_lfs < online_cpus) {
+			dev_err(&cptpf->pdev->dev,
+				"CPT LFs %d < required for kernel crypto %d",
+				avail_lfs, online_cpus);
+			ret = -ENOENT;
+			goto error;
+		}
+		avail_lfs -= online_cpus;
+		kvf_lfs = online_cpus;
 	}
-	avail_lfs -= online_cpus;
 
 	lfs_per_vf = cptpf->enabled_vfs == 1 ?
 		     1 : avail_lfs / (cptpf->enabled_vfs - 1);
@@ -391,7 +397,7 @@ static int cpt_alloc_vf_limits(struct cptpf_dev *cptpf)
 		goto error;
 	}
 
-	cptpf->vf_limits.cpt->a[0].val = online_cpus;
+	cptpf->vf_limits.cpt->a[0].val = kvf_lfs;
 	for (i = 1; i < cptpf->enabled_vfs; i++)
 		cptpf->vf_limits.cpt->a[i].val = lfs_per_vf;
 	return 0;
@@ -439,6 +445,64 @@ static int cpt_create_sysfs_vf_limits(struct cptpf_dev *cptpf)
 	return ret;
 }
 
+static void cpt_destroy_sysfs_kvf_limits(struct pci_dev *pdev)
+{
+	struct cptpf_dev *cptpf = pci_get_drvdata(pdev);
+
+	device_remove_file(&pdev->dev, &cptpf->kvf_limits.kvf_limits_attr);
+}
+static ssize_t cpt_kvf_limits_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct cpt_kvf_limits *kvf_limits;
+
+	kvf_limits = container_of(attr, struct cpt_kvf_limits, kvf_limits_attr);
+
+	return sprintf(buf, "%d\n", kvf_limits->lfs_num);
+}
+
+static ssize_t cpt_kvf_limits_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct cptpf_dev *cptpf;
+	int lfs_num;
+
+	cptpf = container_of(attr, struct cptpf_dev,
+			     kvf_limits.kvf_limits_attr);
+	if (kstrtoint(buf, 0, &lfs_num)) {
+		dev_err(&cptpf->pdev->dev,
+			"lfs count %d must be in range [1 - %d]", lfs_num,
+			num_online_cpus());
+		return -EINVAL;
+	}
+	if (lfs_num < 1 || lfs_num > num_online_cpus()) {
+		dev_err(&cptpf->pdev->dev,
+			"lfs count %d must be in range [1 - %d]", lfs_num,
+			num_online_cpus());
+		return -EINVAL;
+	}
+	cptpf->kvf_limits.lfs_num = lfs_num;
+
+	return count;
+}
+
+static int cpt_create_sysfs_kvf_limits(struct pci_dev *pdev)
+{
+	struct cptpf_dev *cptpf = pci_get_drvdata(pdev);
+	int ret;
+
+	cptpf->kvf_limits.kvf_limits_attr.show = cpt_kvf_limits_show;
+	cptpf->kvf_limits.kvf_limits_attr.store = cpt_kvf_limits_store;
+	cptpf->kvf_limits.kvf_limits_attr.attr.name = "kvf_limits";
+	cptpf->kvf_limits.kvf_limits_attr.attr.mode = 0664;
+
+	sysfs_attr_init(&cptpf->kvf_limits.kvf_limits_attr);
+	ret = device_create_file(&pdev->dev,
+				 &cptpf->kvf_limits.kvf_limits_attr);
+	return ret;
+}
+
 static int cpt_is_pf_usable(struct cptpf_dev *cptpf)
 {
 	u64 rev;
@@ -632,8 +696,13 @@ static int cptpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (err)
 		goto cpt_err_unregister_interrupts;
 
+	err = cpt_create_sysfs_kvf_limits(pdev);
+	if (err)
+		goto cpt_err_cleanup_eng_grps;
 	return 0;
 
+cpt_err_cleanup_eng_grps:
+	cpt_cleanup_eng_grps(pdev, &cptpf->eng_grps);
 cpt_err_unregister_interrupts:
 	cptpf_disable_vfpf_mbox_intrs(cptpf);
 	cptpf_disable_afpf_mbox_intrs(cptpf);
@@ -663,6 +732,8 @@ static void cptpf_remove(struct pci_dev *pdev)
 
 	/* Disable SRIOV */
 	pci_disable_sriov(pdev);
+	/* Delete sysfs entry created for kernel VF limits */
+	cpt_destroy_sysfs_kvf_limits(pdev);
 	/* Cleanup engine groups */
 	cpt_cleanup_eng_grps(pdev, &cptpf->eng_grps);
 	/* Disable VF-PF interrupts */
-- 
2.17.1


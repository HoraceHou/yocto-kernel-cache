From d465f10e1eaf2466e2bff6560e8472d74458349b Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Fri, 17 May 2019 09:29:20 +0200
Subject: [PATCH 262/386] telephony: mvebu_phone: introduce Marvell drivers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This drivers were originally imported from LKv3.10.

There are 2 types of telephony controllers in Marvel SoCs:
    - 2-channel TDM (TDM2C, available e.g. in A38X)
    - Multi-channel TDM (TDMMC, available e.g. in A8k/AXP)
This patch adds support of both controllers.

Both drivers use SLIC (Subscriber Line Interface Card) as the physical
Interface. SLIC requires its own drivers external drivers. In order
to ensure control path communication via TAL (Telephony Adaptation
Layer), a generic SPI device driver is added. It can work with
various models of SLIC's and provides a low-level communication
interface.

The general structure of the code is the following:
+¦¦ drivers
    +¦¦ telephony
            +¦¦ mvebu_phone
                    +¦¦ mv_phone_dev.c
                    +¦¦ mv_phone_spi.c
                    +¦¦ slic
                    +¦¦ tal
                    +¦¦ tdm2c
                    +¦¦ tdmmc

mv_phone_dev.c: main TDM driver, which initializes desired type
                of controller, depending on DT description
mv_phone_spi.c: SLIC SPI device driver
slic: glue layer between Marvell phone and SLIC drivers
tal: Telephony Adaptation Layer
tdm2c: TDM 2-channel support
tdmmc: TDM multi-channel support

Change-Id: I9d89f1e89d8239c1a2c80a6da27f7b6ca91b1d29
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: https://sj1git1.cavium.com/9894
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Stefan Chulski <Stefan.Chulski@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../bindings/telephony/mvebu-phone.txt        |   87 ++
 drivers/Kconfig                               |    2 +
 drivers/Makefile                              |    1 +
 drivers/telephony/Kconfig                     |   32 +
 drivers/telephony/Makefile                    |    5 +
 drivers/telephony/mvebu_phone/Kconfig         |   19 +
 drivers/telephony/mvebu_phone/Makefile        |   35 +
 drivers/telephony/mvebu_phone/mv_phone.h      |  235 ++++
 drivers/telephony/mvebu_phone/mv_phone_dev.c  | 1125 +++++++++++++++++
 drivers/telephony/mvebu_phone/mv_phone_spi.c  |  135 ++
 .../telephony/mvebu_phone/slic/drv_dxt_if.c   |   95 ++
 .../telephony/mvebu_phone/slic/drv_dxt_if.h   |   27 +
 .../telephony/mvebu_phone/slic/silabs_if.c    |   74 ++
 .../telephony/mvebu_phone/slic/silabs_if.h    |   29 +
 .../telephony/mvebu_phone/slic/zarlink_if.c   |   69 +
 .../telephony/mvebu_phone/slic/zarlink_if.h   |   28 +
 drivers/telephony/mvebu_phone/tal/tal.c       |  123 ++
 drivers/telephony/mvebu_phone/tal/tal.h       |   77 ++
 drivers/telephony/mvebu_phone/tal/tal_dev.c   |  257 ++++
 drivers/telephony/mvebu_phone/tal/tal_dev.h   |   27 +
 drivers/telephony/mvebu_phone/tdm2c/tdm2c.c   | 1022 +++++++++++++++
 drivers/telephony/mvebu_phone/tdm2c/tdm2c.h   |  270 ++++
 drivers/telephony/mvebu_phone/tdmmc/tdmmc.c   | 1066 ++++++++++++++++
 drivers/telephony/mvebu_phone/tdmmc/tdmmc.h   |  355 ++++++
 .../mvebu_phone/telephony_user_guide.txt      |  183 +++
 include/linux/miscdevice.h                    |    2 +
 26 files changed, 5380 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/telephony/mvebu-phone.txt
 create mode 100644 drivers/telephony/Kconfig
 create mode 100644 drivers/telephony/Makefile
 create mode 100644 drivers/telephony/mvebu_phone/Kconfig
 create mode 100644 drivers/telephony/mvebu_phone/Makefile
 create mode 100644 drivers/telephony/mvebu_phone/mv_phone.h
 create mode 100644 drivers/telephony/mvebu_phone/mv_phone_dev.c
 create mode 100644 drivers/telephony/mvebu_phone/mv_phone_spi.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/drv_dxt_if.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/drv_dxt_if.h
 create mode 100644 drivers/telephony/mvebu_phone/slic/silabs_if.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/silabs_if.h
 create mode 100644 drivers/telephony/mvebu_phone/slic/zarlink_if.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/zarlink_if.h
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal.c
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal.h
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal_dev.c
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal_dev.h
 create mode 100644 drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
 create mode 100644 drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
 create mode 100644 drivers/telephony/mvebu_phone/tdmmc/tdmmc.c
 create mode 100644 drivers/telephony/mvebu_phone/tdmmc/tdmmc.h
 create mode 100644 drivers/telephony/mvebu_phone/telephony_user_guide.txt

diff --git a/Documentation/devicetree/bindings/telephony/mvebu-phone.txt b/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
new file mode 100644
index 000000000000..c5008e2bf906
--- /dev/null
+++ b/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
@@ -0,0 +1,87 @@
+* mvebu (Armada 38x/XP/80x0) TDM telephony controller
+
+Required properties:
+
+- compatible:
+  "marvell,armada-380-tdm" for Armada 38x platforms
+  "marvell,armada-xp-tdm" for Armada AXP platforms
+  "marvell,armada-a8k-tdm" for Armada 80x0 platforms
+
+- reg: physical base address of the controller and length of memory mapped
+  region (named "tdm_regs").
+  With "marvell,armada-380-tdm" two other regions are required:
+  first of those is dedicated for Audio PLL Configuration registers
+  (named "pll_regs") and the second one ("dco_div") - for register
+  where DCO post-divider for PLL output is set.
+
+- interrupts - TDM controller interrupt
+
+- clocks: phandle for internal gate clock
+
+- clock-names: name associated to the clocks: "gateclk"
+
+Optional properties:
+
+- pclk-freq-mhz: internal pclk frequency. If not set, the driver uses
+  default value of 8 MHz
+
+- use-pclk-external: chooses SLIC as an external pclk source
+
+- daisy-chain-mode: chooses SPI to work in daisy-chain mode
+
+Example:
+
+tdm@b0000 {
+	compatible = "marvell,armada-380-tdm";
+	reg = <0xb0000 0x5000>, <0x18400 0xc>, <0x18730 0x4>;
+	reg-names = "tdm_regs", "pll_regs", "dco_div";
+	interrupts = <0 27 0x4>;
+	clocks = <&gateclk 25>;
+	clock-names = "gateclk";
+	pclk-freq-mhz = <8>;
+};
+
+In case an external SLIC is used, there is a need of instantiating it as
+a slave SPI device under one of SPI busses (please refer to:
+Documentation/devicetree/bindings/spi/spi-bus.txt)
+
+Required properties:
+
+- compatible: "mv_slic" for Armada 38x platforms
+
+- reg: SLIC slave spi device interface chip select number
+
+- spi-max-frequency: SLIC slave spi device interface max clock
+  frequency
+
+Zarlink/Silabs SLIC devices require also following properties:
+
+- spi-1byte-cs - switch CS every single byte transferred
+
+- spi-cpol - active-low clk
+
+- spi-cpha - accept data on clk trailing edge
+
+Optional property:
+
+- slic-id - logical ID of SPI device from range 0 - 31. If not used,
+  the driver will set it to '0'. If more than one SLIC device is
+  used, this property is obligatory for proper operation.
+
+spi1: spi@10680 {
+	pinctrl-0 = <&spi1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	slic@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "mv_slic";
+		reg = <0>; /* Chip select 0 */
+		spi-max-frequency = <3000000>;
+		spi-1byte-cs;
+		spi-cpol;
+		spi-cpha;
+		slic-id = <1>;
+	};
+};
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 95b9ccc08165..c550dec5e225 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -189,6 +189,8 @@ source "drivers/perf/Kconfig"
 
 source "drivers/ras/Kconfig"
 
+source "drivers/telephony/Kconfig"
+
 source "drivers/thunderbolt/Kconfig"
 
 source "drivers/android/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index e5f14a6077ed..382a035d1ce3 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -150,6 +150,7 @@ obj-$(CONFIG_VHOST)		+= vhost/
 obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
+obj-$(CONFIG_PHONE)		+= telephony/
 
 obj-$(CONFIG_MAILBOX)		+= mailbox/
 obj-$(CONFIG_HWSPINLOCK)	+= hwspinlock/
diff --git a/drivers/telephony/Kconfig b/drivers/telephony/Kconfig
new file mode 100644
index 000000000000..092e996730d3
--- /dev/null
+++ b/drivers/telephony/Kconfig
@@ -0,0 +1,32 @@
+#
+# Telephony device configuration
+#
+
+menuconfig PHONE
+	bool "Telephony devices support"
+	default y
+	---help---
+	  Say Y here to get to see options for hardware telephony devices.
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if PHONE
+
+config MVEBU_PHONE
+	bool "Mvebu TDM Telephony"
+	depends on ARCH_MVEBU
+	---help---
+	  This driver supports the TDM-based telephony interface
+	  units in the following Marvell SoC families:
+	  1. ARMADA-370.
+	  2. ARMADA-375.
+	  3. ARMADA-38x.
+	  4. ARMADA-XP.
+	  5. ARMADA-7k/8k.
+
+if MVEBU_PHONE
+	source "drivers/telephony/mvebu_phone/Kconfig"
+endif
+
+endif # PHONE
diff --git a/drivers/telephony/Makefile b/drivers/telephony/Makefile
new file mode 100644
index 000000000000..ed4c70bfb83a
--- /dev/null
+++ b/drivers/telephony/Makefile
@@ -0,0 +1,5 @@
+#
+# linux/drivers/telephony/Makefile
+#
+
+obj-$(CONFIG_MVEBU_PHONE)		+= mvebu_phone/
diff --git a/drivers/telephony/mvebu_phone/Kconfig b/drivers/telephony/mvebu_phone/Kconfig
new file mode 100644
index 000000000000..40a50cb4a4d6
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/Kconfig
@@ -0,0 +1,19 @@
+
+config MV_TDM_EXT_STATS
+	bool "Enable legacy TDM extended statistics"
+	depends on MACH_ARMADA_38X
+	default y
+	---help---
+	  Choosing this option will export
+	  extended statistics to procfs.
+	  This is relevant only for the
+	  legacy TDM unit.
+
+config MV_PHONE_SPI_DEBUG
+	bool "Enable SLIC SPI debug"
+	default n
+	---help---
+	  Choosing this option will enable
+	  printing debug information
+	  about all data sent to and from
+	  SLIC device via SPI interface.
diff --git a/drivers/telephony/mvebu_phone/Makefile b/drivers/telephony/mvebu_phone/Makefile
new file mode 100644
index 000000000000..a1c0f5772437
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/Makefile
@@ -0,0 +1,35 @@
+#
+# Makefile for mvebu_phone Marvell telephony driver
+#
+
+CPU_ARCH    = ARM
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+ccflags-y := -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+ccflags-y += -I$(srctree)/drivers/telephony/mvebu_phone
+
+# MAIN COMPONENTS
+PHONE_OBJS = mv_phone_dev.o
+PHONE_OBJS += mv_phone_spi.o
+
+# TAL
+PHONE_OBJS += tal/tal.o
+PHONE_OBJS += tal/tal_dev.o
+
+# SLIC
+PHONE_OBJS += slic/drv_dxt_if.o
+PHONE_OBJS += slic/silabs_if.o
+PHONE_OBJS += slic/zarlink_if.o
+
+# TDM2C support
+PHONE_OBJS += tdm2c/tdm2c.o
+
+# TDMMC support
+PHONE_OBJS += tdmmc/tdmmc.o
+
+mv_phone-objs := $(PHONE_OBJS)
+obj-y := mv_phone.o
diff --git a/drivers/telephony/mvebu_phone/mv_phone.h b/drivers/telephony/mvebu_phone/mv_phone.h
new file mode 100644
index 000000000000..a93e25b35b06
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone.h
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _MV_PHONE_H_
+#define _MV_PHONE_H_
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mbus.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include "tdm2c/tdm2c.h"
+#include "tdmmc/tdmmc.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+
+/* Core DivClk Control Register */
+
+/* DCO clock apply/reset bits */
+#define DCO_CLK_DIV_MOD_OFFS			24
+#define DCO_CLK_DIV_APPLY_MASK			(0x1 << DCO_CLK_DIV_MOD_OFFS)
+#define DCO_CLK_DIV_RESET_OFFS			25
+#define DCO_CLK_DIV_RESET_MASK			(0x1 << DCO_CLK_DIV_RESET_OFFS)
+
+/* DCO clock ratio is 24Mhz/x */
+#define DCO_CLK_DIV_RATIO_OFFS			26
+#define DCO_CLK_DIV_RATIO_MASK			0xfc000000
+#define DCO_CLK_DIV_RATIO_8M			(0x3 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_4M			(0x6 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_2M			(0xc << DCO_CLK_DIV_RATIO_OFFS)
+
+/* TDM PLL configuration registers */
+#define TDM_PLL_CONF_REG0			0x0
+#define TDM_PLL_FB_CLK_DIV_OFFSET		10
+#define TDM_PLL_FB_CLK_DIV_MASK			0x7fc00
+
+#define TDM_PLL_CONF_REG1			0x4
+#define TDM_PLL_FREQ_OFFSET_MASK		0xffff
+#define TDM_PLL_FREQ_OFFSET_VALID		0x00010000
+#define TDM_PLL_SW_RESET			0x80000000
+
+#define TDM_PLL_CONF_REG2			0x8
+#define TDM_PLL_POSTDIV_MASK			0x7f
+
+/* TDM control/SPI registers used for suspend/resume */
+#define TDM_CTRL_REGS_NUM			36
+#define TDM_SPI_REGS_OFFSET			0x3100
+#define TDM_SPI_REGS_NUM			16
+
+/* Structures and enums */
+enum mv_phone_unit_type {
+	MV_TDM_UNIT_NONE,
+	MV_TDM_UNIT_TDM2C,
+	MV_TDM_UNIT_TDMMC
+};
+
+enum mv_phone_band_mode {
+	MV_NARROW_BAND = 0,
+	MV_WIDE_BAND,
+};
+
+enum mv_phone_pcm_format {
+	MV_PCM_FORMAT_1BYTE = 1,
+	MV_PCM_FORMAT_2BYTES = 2,
+	MV_PCM_FORMAT_4BYTES = 4
+};
+
+enum mv_phone_frame_ts {
+	MV_FRAME_32TS = 32,
+	MV_FRAME_64TS = 64,
+	MV_FRAME_128TS = 128
+};
+
+enum mv_phone_spi_mode {
+	MV_SPI_MODE_DIRECT = 0,
+	MV_SPI_MODE_DAISY_CHAIN = 1
+};
+
+struct mv_phone_extended_stats {
+	u32 int_rx_count;
+	u32 int_tx_count;
+	u32 int_rx0_count;
+	u32 int_tx0_count;
+	u32 int_rx1_count;
+	u32 int_tx1_count;
+	u32 int_rx0_miss;
+	u32 int_tx0_miss;
+	u32 int_rx1_miss;
+	u32 int_tx1_miss;
+	u32 pcm_restart_count;
+};
+
+struct mv_phone_intr_info {
+	u8 *tdm_rx_buff;
+	u8 *tdm_tx_buff;
+	u32 int_type;
+	u8 cs;
+	u8 data;
+};
+
+struct mv_phone_params {
+	enum mv_phone_pcm_format pcm_format;
+	u16 pcm_slot[32];
+	u8 sampling_period;
+	u16 total_channels;
+};
+
+struct mv_phone_dev {
+	void __iomem *tdm_base;
+	void __iomem *pll_base;
+	void __iomem *dco_div_reg;
+	struct mv_phone_params *tdm_params;
+	enum mv_phone_unit_type tdm_type;
+	struct platform_device *parent;
+	struct device_node *np;
+	struct clk *clk;
+	struct clk *axi_clk;
+	u32 pclk_freq_mhz;
+	u8 irq_count;
+	int irq[3];
+	spinlock_t lock;
+
+	/* Used to preserve TDM registers across suspend/resume */
+	u32 tdm_ctrl_regs[TDM_CTRL_REGS_NUM];
+	u32 tdm_spi_regs[TDM_SPI_REGS_NUM];
+	u32 tdm_spi_mux_reg;
+	u32 tdm_mbus_config_reg;
+	u32 tdm_misc_reg;
+
+	struct device *dev;
+
+	/* Transmit buffers */
+	u8 *rx_buff;
+	u8 *tx_buff;
+	int buff_size;
+
+	/* Transmit statistics */
+	struct proc_dir_entry *tdm_stats;
+	u32 rx_miss;
+	u32 tx_miss;
+	u32 rx_over;
+	u32 tx_under;
+
+	/* TDM operation flags */
+	bool tdm_init;
+	bool test_enable;
+	bool pcm_enable;
+	bool pcm_stop_flag;
+	bool pcm_stop_status;
+	int pcm_start_stop_state;
+	bool pcm_is_stopping;
+	u32 pcm_stop_fail;
+	bool use_tdm_ext_stats;
+
+	/* TDM2C SPI operation mode */
+	bool tdm2c_daisy_chain_mode;
+	/* TDM2C PCLK source */
+	bool use_pclk_external;
+
+	/* TDMMC silicon revision */
+	enum tdmmc_ip_version tdmmc_ip_ver;
+};
+
+/* This enumerator defines the Marvell Units ID */
+enum mv_phone_slic_unit_type {
+	SLIC_EXTERNAL_ID,
+	SLIC_ZARLINK_ID,
+	SLIC_SILABS_ID,
+	SLIC_LANTIQ_ID
+};
+
+enum mv_phone_spi_type {
+	SPI_TYPE_FLASH = 0,
+	SPI_TYPE_SLIC_ZARLINK_SILABS,
+	SPI_TYPE_SLIC_LANTIQ,
+	SPI_TYPE_SLIC_ZSI,
+	SPI_TYPE_SLIC_ISI
+};
+
+enum mv_phone_board_slic_type {
+	MV_BOARD_SLIC_DISABLED,
+	MV_BOARD_SLIC_SSI_ID, /* Lantiq Integrated SLIC */
+	MV_BOARD_SLIC_ISI_ID, /* Silicon Labs ISI Bus */
+	MV_BOARD_SLIC_ZSI_ID, /* Zarlink ZSI Bus */
+	MV_BOARD_SLIC_EXTERNAL_ID /* Cross vendor external SLIC */
+};
+
+/* Helper macros and routines */
+static inline void mv_phone_set_bit(void __iomem *addr, u32 bit_mask)
+{
+	writel(readl(addr) | bit_mask, addr);
+}
+
+static inline void mv_phone_reset_bit(void __iomem *addr, u32 bit_mask)
+{
+	writel(readl(addr) & ~bit_mask, addr);
+}
+
+/* MV Phone */
+u32 mv_phone_get_slic_board_type(void);
+void mv_phone_spi_write(u16 line_id, u8 *cmd_buff, u8 cmd_size,
+			u8 *data_buff, u8 data_size, u32 spi_type);
+void mv_phone_spi_read(u16 line_id, u8 *cmd_buff, u8 cmd_size,
+		       u8 *data_buff, u8 data_size, u32 spi_type);
+void mv_phone_intr_enable(u8 device_id);
+void mv_phone_intr_disable(u8 device_id);
+
+/* TDM2C */
+int tdm2c_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdm_params,
+	       enum mv_phone_frame_ts frame_ts,
+	       bool spi_daisy_chain_mode,
+	       bool use_pclk_external);
+int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info);
+void tdm2c_ext_stats_get(struct mv_phone_extended_stats *tdm_ext_stats);
+
+/* TDMMC */
+int tdmmc_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdm_params,
+	       enum mv_phone_frame_ts frame_ts,
+	       enum tdmmc_ip_version tdmmc_ip_ver);
+int tdmmc_intr_low(struct mv_phone_intr_info *tdm_intr_info);
+
+#endif /* _MV_PHONE_H_ */
diff --git a/drivers/telephony/mvebu_phone/mv_phone_dev.c b/drivers/telephony/mvebu_phone/mv_phone_dev.c
new file mode 100644
index 000000000000..302ad52fe6bd
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone_dev.c
@@ -0,0 +1,1125 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <slic/drv_dxt_if.h>
+#include <slic/silabs_if.h>
+#include <slic/zarlink_if.h>
+#include <tal/tal.h>
+#include <tal/tal_dev.h>
+#include "mv_phone.h"
+
+#define DRV_NAME "mvebu_phone"
+
+/* TDM Interrupt Service Routine */
+static irqreturn_t tdm_if_isr(int irq, void *dev_id);
+
+/* Rx/Tx Tasklets  */
+static void tdm2c_if_pcm_rx_process(unsigned long arg);
+static void tdmmc_if_pcm_rx_process(unsigned long arg);
+static void tdm2c_if_pcm_tx_process(unsigned long arg);
+static void tdmmc_if_pcm_tx_process(unsigned long arg);
+static void tdm2c_if_reset_channels(unsigned long arg);
+
+/* Globals */
+static struct mv_phone_dev *priv;
+static DECLARE_TASKLET(tdm2c_if_rx_tasklet, tdm2c_if_pcm_rx_process, 0);
+static DECLARE_TASKLET(tdmmc_if_rx_tasklet, tdmmc_if_pcm_rx_process, 0);
+static DECLARE_TASKLET(tdm2c_if_tx_tasklet, tdm2c_if_pcm_tx_process, 0);
+static DECLARE_TASKLET(tdmmc_if_tx_tasklet, tdmmc_if_pcm_tx_process, 0);
+static DECLARE_TASKLET(tdm2c_if_reset_tasklet, tdm2c_if_reset_channels, 0);
+
+/* Statistic printout in userspace via /proc/tdm */
+static int mv_phone_status_show(struct seq_file *m, void *v)
+{
+	struct mv_phone_extended_stats tdm_ext_stats;
+
+	seq_printf(m, "tdm_init:	%u\n", priv->tdm_init);
+	seq_printf(m, "rx_miss:		%u\n", priv->rx_miss);
+	seq_printf(m, "tx_miss:		%u\n", priv->tx_miss);
+	seq_printf(m, "rx_over:		%u\n", priv->rx_over);
+	seq_printf(m, "tx_under:	%u\n", priv->tx_under);
+
+	if (!priv->use_tdm_ext_stats)
+		return 0;
+
+	tdm2c_ext_stats_get(&tdm_ext_stats);
+
+	seq_puts(m, "\nTDM Extended Statistics:\n");
+	seq_printf(m, "int_rx_count	= %u\n", tdm_ext_stats.int_rx_count);
+	seq_printf(m, "int_tx_count	= %u\n", tdm_ext_stats.int_tx_count);
+	seq_printf(m, "int_rx0_count	= %u\n", tdm_ext_stats.int_rx0_count);
+	seq_printf(m, "int_tx0_count	= %u\n", tdm_ext_stats.int_tx0_count);
+	seq_printf(m, "int_rx1_count	= %u\n", tdm_ext_stats.int_rx1_count);
+	seq_printf(m, "int_tx1_count	= %u\n", tdm_ext_stats.int_tx1_count);
+	seq_printf(m, "int_rx0_miss	= %u\n", tdm_ext_stats.int_rx0_miss);
+	seq_printf(m, "int_tx0_miss	= %u\n", tdm_ext_stats.int_tx0_miss);
+	seq_printf(m, "int_tx1_miss	= %u\n", tdm_ext_stats.int_rx1_miss);
+	seq_printf(m, "int_tx1_miss	= %u\n", tdm_ext_stats.int_tx1_miss);
+	seq_printf(m, "pcm_restart_count= %u\n",
+		   tdm_ext_stats.pcm_restart_count);
+	seq_printf(m, "pcm_stop_fail	= %u\n", priv->pcm_stop_fail);
+
+	return 0;
+}
+
+static int mv_phone_status_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mv_phone_status_show, PDE_DATA(inode));
+}
+
+static const struct file_operations mv_phone_operations = {
+	.open		= mv_phone_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+/* TAL callbacks */
+
+/* PCM start */
+static void tdm2c_if_pcm_start(void)
+{
+	unsigned long flags;
+	u32 max_poll = 0;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (priv->pcm_enable) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return;
+	}
+
+	priv->pcm_enable = true;
+	if (!priv->pcm_is_stopping) {
+		priv->pcm_stop_flag = false;
+		priv->pcm_stop_status = false;
+		priv->pcm_start_stop_state = 0;
+		priv->rx_buff = NULL;
+		priv->tx_buff = NULL;
+		tdm2c_pcm_start();
+	} else {
+		priv->pcm_start_stop_state++;
+		while (priv->pcm_is_stopping && max_poll <
+		       MV_TDM_STOP_POLLING_TIMEOUT) {
+			spin_unlock_irqrestore(&priv->lock, flags);
+			mdelay(1);
+			max_poll++;
+			spin_lock_irqsave(&priv->lock, flags);
+		}
+
+		if (priv->pcm_is_stopping) {
+			/* Issue found or timeout */
+			if (tdm2c_pcm_stop_int_miss())
+				dev_dbg(priv->dev, "pcm stop issue found\n");
+			else
+				dev_dbg(priv->dev, "pcm stop timeout\n");
+
+			priv->pcm_is_stopping = false;
+			priv->pcm_stop_flag = false;
+			priv->pcm_stop_status = false;
+			priv->pcm_start_stop_state = 0;
+			priv->rx_buff = NULL;
+			priv->tx_buff = NULL;
+			tdm2c_pcm_start();
+		} else {
+			dev_dbg(priv->dev,
+				"pcm_start_stop_state(%d), max_poll=%d\n",
+				priv->pcm_start_stop_state, max_poll);
+		}
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void tdmmc_if_pcm_start(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (priv->pcm_enable) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return;
+	}
+
+	priv->pcm_enable = true;
+	priv->rx_buff = NULL;
+	priv->tx_buff = NULL;
+	tdmmc_pcm_start();
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* PCM stop */
+static void tdm2c_if_pcm_stop(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!priv->pcm_enable) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return;
+	}
+
+	priv->pcm_enable = false;
+	if (!priv->pcm_is_stopping) {
+		priv->pcm_is_stopping = true;
+		tdm2c_pcm_stop();
+	} else {
+		priv->pcm_start_stop_state--;
+		dev_dbg(priv->dev, "pcm_start_stop_state(%d)\n",
+			priv->pcm_start_stop_state);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void tdmmc_if_pcm_stop(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!priv->pcm_enable) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return;
+	}
+
+	priv->pcm_enable = false;
+	tdmmc_pcm_stop();
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* TDM low-level initialization */
+static int tdm_hw_init(struct mv_phone_params *tdm_params)
+{
+	enum mv_phone_frame_ts frame_ts;
+	int ret;
+
+	switch (priv->pclk_freq_mhz) {
+	case 8:
+		frame_ts = MV_FRAME_128TS;
+		break;
+	case 4:
+		frame_ts = MV_FRAME_64TS;
+		break;
+	case 2:
+		frame_ts = MV_FRAME_32TS;
+		break;
+	default:
+		frame_ts = MV_FRAME_128TS;
+		break;
+	}
+
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		ret = tdm2c_init(priv->tdm_base, priv->dev, tdm_params,
+				 frame_ts, priv->tdm2c_daisy_chain_mode,
+				 priv->use_pclk_external);
+
+		/* Soft reset to PCM I/F */
+		tdm2c_pcm_if_reset();
+
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		ret = tdmmc_init(priv->tdm_base, priv->dev, tdm_params,
+				 frame_ts, priv->tdmmc_ip_ver);
+
+		/* Issue SLIC reset */
+		ret |= tdmmc_reset_slic();
+
+		/* WA to stop the MCDMA gracefully after tdmmc initialization */
+		tdmmc_if_pcm_stop();
+
+		break;
+	default:
+		dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	priv->tdm_params = tdm_params;
+
+	return ret;
+}
+
+/* Main TDM initialization routine */
+int tdm_if_init(struct tal_params *tal_params)
+{
+	struct mv_phone_params tdm_params;
+	int i, irqs_requested, ret;
+
+	if (priv->tdm_init) {
+		dev_warn(priv->dev,
+			 "Marvell Telephony Driver already started...\n");
+		return 0;
+	}
+
+	dev_info(priv->dev, "Loading Marvell Telephony Driver\n");
+
+	if (!tal_params) {
+		dev_err(priv->dev, "%s: bad parameters\n", __func__);
+		return -EINVAL;
+
+	}
+
+	/* Reset operation flags */
+	priv->tdm_init = false;
+	priv->pcm_enable = false;
+	priv->pcm_is_stopping = false;
+	priv->pcm_stop_flag = false;
+	priv->pcm_stop_status = false;
+	priv->pcm_stop_fail = 0;
+
+	/* Calculate Rx/Tx buffer size(use in callbacks) */
+	priv->buff_size = (tal_params->pcm_format * tal_params->total_lines *
+			   80 * (tal_params->sampling_period/
+			   MV_TDM_BASE_SAMPLING_PERIOD));
+
+	/* Assign TDM parameters */
+	memcpy(&tdm_params, tal_params, sizeof(struct mv_phone_params));
+
+	/* TDM hardware initialization */
+	ret = tdm_hw_init(&tdm_params);
+	if (ret) {
+		dev_err(priv->dev, "%s: TDM initialization failed\n", __func__);
+		return ret;
+	}
+
+	/* Create TDM procfs statistics */
+	priv->tdm_stats = proc_mkdir("tdm", NULL);
+	if (priv->tdm_stats) {
+		if (!proc_create("tdm_stats", 0444,
+				 priv->tdm_stats, &mv_phone_operations))
+			return -ENOMEM;
+	}
+
+	/* Register TDM interrupts */
+	irqs_requested = 0;
+	for (i = 0; i < priv->irq_count; i++) {
+		ret = request_irq(priv->irq[i], tdm_if_isr, 0x0, "tdm", NULL);
+		if (ret) {
+			dev_err(priv->dev, "%s: Failed to connect irq(%d)\n",
+				__func__, priv->irq[i]);
+			goto err_irq;
+		}
+		irqs_requested++;
+	}
+
+	priv->tdm_init = true;
+
+	return 0;
+
+err_irq:
+	for (i = 0; i < irqs_requested; i++)
+		free_irq(priv->irq[i], NULL);
+
+	return ret;
+}
+
+/* Disable TDM2C PCM */
+void tdm2c_pcm_disable(void)
+{
+	u32 max_poll = 0;
+
+	tdm2c_if_pcm_stop();
+
+	while (priv->pcm_is_stopping && (max_poll <
+	       MV_TDM_STOP_POLLING_TIMEOUT)) {
+		mdelay(1);
+		max_poll++;
+	}
+
+	if (max_poll >= MV_TDM_STOP_POLLING_TIMEOUT)
+		dev_warn(priv->dev, "\n%s: Channels disabling timeout (%dms)\n",
+			 __func__, MV_TDM_STOP_POLLING_TIMEOUT);
+
+}
+
+/* Main TDM deinitialization routine */
+void tdm_if_exit(void)
+{
+	int i;
+
+	/* Check if already stopped */
+	if (!priv->pcm_enable && !priv->tdm_init)
+		return;
+
+	/* Stop PCM channels */
+	if (priv->pcm_enable) {
+		switch (priv->tdm_type) {
+		case MV_TDM_UNIT_TDM2C:
+			tdm2c_pcm_disable();
+			break;
+		case MV_TDM_UNIT_TDMMC:
+			tdmmc_if_pcm_stop();
+			break;
+		default:
+			dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+				__func__);
+		}
+	}
+
+	/* Disable TDM and release resources */
+	if (priv->tdm_init) {
+		switch (priv->tdm_type) {
+		case MV_TDM_UNIT_TDM2C:
+			tdm2c_release();
+			break;
+		case MV_TDM_UNIT_TDMMC:
+			tdmmc_release();
+			break;
+		default:
+			dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+				__func__);
+		}
+
+		/* Remove proc directory & entries */
+		remove_proc_entry("tdm_stats", priv->tdm_stats);
+		remove_proc_entry("tdm", NULL);
+
+		/* Release interrupt */
+		for (i = 0; i < priv->irq_count; i++)
+			free_irq(priv->irq[i], NULL);
+
+		priv->tdm_init = false;
+	}
+}
+
+static int tdm_if_control(int cmd, void *arg)
+{
+	switch (cmd) {
+	case TDM_DEV_TDM_TEST_MODE_ENABLE:
+		priv->test_enable = true;
+		break;
+
+	case TDM_DEV_TDM_TEST_MODE_DISABLE:
+		priv->test_enable = false;
+		break;
+
+	default:
+		return -EINVAL;
+	};
+
+	return 0;
+}
+
+static int tdm2c_if_write(u8 *buffer, int size)
+{
+	if (priv->test_enable)
+		return tdm2c_tx(buffer);
+
+	return 0;
+}
+
+static int tdmmc_if_write(u8 *buffer, int size)
+{
+	if (priv->test_enable)
+		return tdmmc_tx(buffer);
+
+	return 0;
+}
+
+static void tdm_if_stats_get(struct tal_stats *tdm_if_stats)
+{
+	if (!priv->tdm_init)
+		return;
+
+	tdm_if_stats->tdm_init = priv->tdm_init;
+	tdm_if_stats->rx_miss = priv->rx_miss;
+	tdm_if_stats->tx_miss = priv->tx_miss;
+	tdm_if_stats->rx_over = priv->rx_over;
+	tdm_if_stats->tx_under = priv->tx_under;
+
+	if (priv->use_tdm_ext_stats)
+		tdm2c_ext_stats_get(&tdm_if_stats->tdm_ext_stats);
+}
+
+static struct tal_if tdm2c_if = {
+	.pcm_start	= tdm2c_if_pcm_start,
+	.pcm_stop	= tdm2c_if_pcm_stop,
+	.init		= tdm_if_init,
+	.exit		= tdm_if_exit,
+	.control	= tdm_if_control,
+	.write		= tdm2c_if_write,
+	.stats_get	= tdm_if_stats_get,
+};
+
+static struct tal_if tdmmc_if = {
+	.pcm_start	= tdmmc_if_pcm_start,
+	.pcm_stop	= tdmmc_if_pcm_stop,
+	.init		= tdm_if_init,
+	.exit		= tdm_if_exit,
+	.control	= tdm_if_control,
+	.write		= tdmmc_if_write,
+	.stats_get	= tdm_if_stats_get,
+};
+
+/* Interrupt handling and tasklet callbacks */
+
+/* Common interrupt top-half handler */
+static irqreturn_t tdm_if_isr(int irq, void *dev_id)
+{
+	struct mv_phone_intr_info tdm_int_info;
+	struct tasklet_struct *tdm_rx_tasklet = NULL;
+	struct tasklet_struct *tdm_tx_tasklet = NULL;
+	u32 int_type;
+	int ret = 0;
+
+	/* Extract interrupt information from low level ISR */
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		ret = tdm2c_intr_low(&tdm_int_info);
+		tdm_rx_tasklet = &tdm2c_if_rx_tasklet;
+		tdm_tx_tasklet = &tdm2c_if_tx_tasklet;
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		tdmmc_intr_low(&tdm_int_info);
+		tdm_rx_tasklet = &tdmmc_if_rx_tasklet;
+		tdm_tx_tasklet = &tdmmc_if_tx_tasklet;
+		break;
+	default:
+		dev_err(&priv->parent->dev,
+			"%s: undefined TDM type\n", __func__);
+		return IRQ_NONE;
+	}
+
+	int_type = tdm_int_info.int_type;
+
+	/* Nothing to do - return */
+	if (int_type == MV_EMPTY_INT)
+		return IRQ_HANDLED;
+
+	/* Handle ZSI interrupts */
+	if (mv_phone_get_slic_board_type() == MV_BOARD_SLIC_ZSI_ID)
+		zarlink_if_zsi_interrupt();
+	/* Handle ISI interrupts */
+	else if (mv_phone_get_slic_board_type() == MV_BOARD_SLIC_ISI_ID)
+		silabs_if_isi_interrupt();
+
+	if (ret && !priv->pcm_stop_status)	{
+		priv->pcm_stop_status = true;
+
+		/*
+		 * If Rx/Tx tasklets are already scheduled,
+		 * let them do the work.
+		 */
+		if (!priv->rx_buff && !priv->tx_buff) {
+			dev_dbg(priv->dev, "Stopping the TDM\n");
+			tdm2c_if_pcm_stop();
+			priv->pcm_stop_flag = false;
+			tasklet_hi_schedule(&tdm2c_if_reset_tasklet);
+		} else {
+			dev_dbg(priv->dev, "Tasklet already running\n");
+			priv->pcm_stop_flag = true;
+		}
+	}
+
+	/* Restarting PCM, skip Rx/Tx handling */
+	if (priv->pcm_stop_status)
+		goto skip_rx_tx;
+
+	/* Support multiple interrupt handling */
+	/* RX interrupt */
+	if (int_type & MV_RX_INT) {
+		if (priv->rx_buff) {
+			priv->rx_miss++;
+			dev_dbg(priv->dev, "%s: Rx buffer not ready\n",
+				__func__);
+		} else {
+			priv->rx_buff = tdm_int_info.tdm_rx_buff;
+			/* Schedule Rx processing within SOFT_IRQ context */
+			dev_dbg(priv->dev, "%s: schedule Rx tasklet\n",
+				__func__);
+			tasklet_hi_schedule(tdm_rx_tasklet);
+		}
+	}
+
+	/* TX interrupt */
+	if (int_type & MV_TX_INT) {
+		if (priv->tx_buff) {
+			priv->tx_miss++;
+			dev_dbg(priv->dev, "%s: Tx buffer not ready\n",
+				__func__);
+		} else {
+			priv->tx_buff = tdm_int_info.tdm_tx_buff;
+			/* Schedule Tx processing within SOFT_IRQ context */
+			dev_dbg(priv->dev, "%s: schedule Tx tasklet\n",
+				__func__);
+			tasklet_hi_schedule(tdm_tx_tasklet);
+		}
+	}
+
+
+	/* TDM2CH PCM channels stop indication */
+	if ((int_type & MV_CHAN_STOP_INT) && (tdm_int_info.data == 4)) {
+		dev_dbg(priv->dev, "%s: Received MV_CHAN_STOP_INT indication\n",
+			__func__);
+		priv->pcm_is_stopping = false;
+		if (priv->pcm_start_stop_state) {
+			dev_dbg(priv->dev, "%s: Resetting controller\n",
+				__func__);
+			priv->pcm_enable = false;
+			/* Issue SW reset */
+			tasklet_hi_schedule(&tdm2c_if_reset_tasklet);
+		}
+	}
+
+skip_rx_tx:
+	/* PHONE interrupt, Lantiq specific */
+	if (int_type & MV_PHONE_INT)
+		drv_dxt_if_signal_interrupt();
+
+	/* ERROR interrupt */
+	if (int_type & MV_RX_ERROR_INT)
+		priv->rx_over++;
+
+	if (int_type & MV_TX_ERROR_INT)
+		priv->tx_under++;
+
+	return IRQ_HANDLED;
+}
+
+/* Rx tasklets */
+static void tdm2c_if_pcm_rx_process(unsigned long arg)
+{
+	unsigned long flags;
+
+	if (priv->pcm_enable) {
+		if (!priv->rx_buff) {
+			dev_warn(priv->dev, "%s: Error, empty Rx processing\n",
+				 __func__);
+			return;
+		}
+
+		/* Fill TDM Rx aggregated buffer */
+		if (tdm2c_rx(priv->rx_buff) == 0)
+			/* Dispatch Rx handler */
+			tal_mmp_rx(priv->rx_buff, priv->buff_size);
+		else
+			dev_warn(priv->dev, "%s: Could not fill Rx buffer\n",
+				 __func__);
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* Clear Rx buff for next iteration */
+	priv->rx_buff = NULL;
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if (priv->pcm_stop_flag && !priv->tx_buff) {
+		dev_dbg(priv->dev, "Stopping TDM from Rx tasklet\n");
+		tdm2c_if_pcm_stop();
+		spin_lock_irqsave(&priv->lock, flags);
+		priv->pcm_stop_flag = false;
+		spin_unlock_irqrestore(&priv->lock, flags);
+		tasklet_hi_schedule(&tdm2c_if_reset_tasklet);
+	}
+}
+
+static void tdmmc_if_pcm_rx_process(unsigned long arg)
+{
+	unsigned long flags;
+
+	if (priv->pcm_enable) {
+		if (!priv->rx_buff) {
+			dev_warn(priv->dev, "%s: Error, empty Rx processing\n",
+				 __func__);
+			return;
+		}
+
+		if (tdmmc_rx(priv->rx_buff) == 0)
+			/* Dispatch Rx handler */
+			tal_mmp_rx(priv->rx_buff, priv->buff_size);
+		else
+			dev_warn(priv->dev, "%s: could not fill Rx buffer\n",
+				 __func__);
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* Clear priv->rx_buff for next iteration */
+	priv->rx_buff = NULL;
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* Tx tasklets */
+static void tdm2c_if_pcm_tx_process(unsigned long arg)
+{
+	unsigned long flags;
+
+	if (priv->pcm_enable) {
+		if (!priv->tx_buff) {
+			dev_warn(priv->dev, "%s: Error, empty Tx processing\n",
+				 __func__);
+			return;
+		}
+
+		/* Dispatch Tx handler */
+		tal_mmp_tx(priv->tx_buff, priv->buff_size);
+
+		if (!priv->test_enable) {
+			/* Fill Tx aggregated buffer */
+			if (tdm2c_tx(priv->tx_buff) != 0)
+				dev_warn(priv->dev,
+					 "%s: Could not fill Tx buffer\n",
+					 __func__);
+		}
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* Clear Tx buff for next iteration */
+	priv->tx_buff = NULL;
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if (priv->pcm_stop_flag && !priv->rx_buff) {
+		dev_dbg(priv->dev, "Stopping TDM from Tx tasklet\n");
+		tdm2c_if_pcm_stop();
+		spin_lock_irqsave(&priv->lock, flags);
+		priv->pcm_stop_flag = false;
+		spin_unlock_irqrestore(&priv->lock, flags);
+		tasklet_hi_schedule(&tdm2c_if_reset_tasklet);
+	}
+}
+
+static void tdmmc_if_pcm_tx_process(unsigned long arg)
+{
+	unsigned long flags;
+
+	if (priv->pcm_enable) {
+		if (!priv->tx_buff) {
+			dev_warn(priv->dev, "%s: Error, empty Tx processing\n",
+				 __func__);
+			return;
+		}
+
+		/* Dispatch Tx handler */
+		tal_mmp_tx(priv->tx_buff, priv->buff_size);
+
+		if (!priv->test_enable) {
+			if (tdmmc_tx(priv->tx_buff) != 0)
+				dev_warn(priv->dev,
+					 "%s: Could not fill Tx buffer\n",
+					 __func__);
+		}
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* Clear Tx buff for next iteration */
+	priv->tx_buff = NULL;
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* TDM2C restart channel callback */
+static void tdm2c_if_reset_channels(unsigned long arg)
+{
+	u32 max_poll = 0;
+	unsigned long flags;
+
+	/* Wait for all channels to stop  */
+	while (((readl(priv->tdm_base + CH_ENABLE_REG(0)) & CH_RXTX_EN_MASK) ||
+		(readl(priv->tdm_base + CH_ENABLE_REG(1)) & CH_RXTX_EN_MASK)) &&
+		(max_poll < MV_TDM_STOP_POLLING_TIMEOUT)) {
+
+		mdelay(1);
+		max_poll++;
+	}
+
+	dev_dbg(priv->dev, "Finished polling on channels disable\n");
+	if (max_poll >= MV_TDM_STOP_POLLING_TIMEOUT) {
+		writel(0, priv->tdm_base + CH_ENABLE_REG(0));
+		writel(0, priv->tdm_base + CH_ENABLE_REG(1));
+		dev_warn(priv->dev, "\n%s: Channels disabling timeout (%dms)\n",
+			 __func__, MV_TDM_STOP_POLLING_TIMEOUT);
+		priv->pcm_stop_fail++;
+		mdelay(10);
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->pcm_is_stopping = false;
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	/* Restart channels */
+	tdm2c_if_pcm_start();
+}
+
+/* Enable device interrupts. */
+void mv_phone_intr_enable(u8 dev_id)
+{
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		tdm2c_intr_enable();
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		tdmmc_intr_enable(dev_id);
+		break;
+	default:
+		dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+			__func__);
+	}
+}
+
+/* Disable device interrupts. */
+void mv_phone_intr_disable(u8 dev_id)
+{
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		tdm2c_intr_disable();
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		tdmmc_intr_disable(dev_id);
+		break;
+	default:
+		dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+			__func__);
+	}
+}
+
+/* Get board type for SLIC unit (pre-defined). */
+u32 mv_phone_get_slic_board_type(void)
+{
+	return MV_BOARD_SLIC_DISABLED;
+}
+
+/* Configure PLL to 24MHz */
+static int mv_phone_tdm_clk_pll_config(struct platform_device *pdev)
+{
+	struct resource *mem;
+	u32 reg_val;
+	u16 freq_offset = 0x22b0;
+	u8 tdm_postdiv = 0x6, fb_clk_div = 0x1d;
+
+	if (!priv->pll_base) {
+		mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "pll_regs");
+		priv->pll_base = devm_ioremap_resource(&pdev->dev, mem);
+		if (IS_ERR(priv->pll_base))
+			return -ENOMEM;
+	}
+
+	/* Set frequency offset value to not valid and enable PLL reset */
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG1);
+	reg_val &= ~TDM_PLL_FREQ_OFFSET_VALID;
+	reg_val &= ~TDM_PLL_SW_RESET;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Update PLL parameters */
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG0);
+	reg_val &= ~TDM_PLL_FB_CLK_DIV_MASK;
+	reg_val |= (fb_clk_div << TDM_PLL_FB_CLK_DIV_OFFSET);
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG0);
+
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG2);
+	reg_val &= ~TDM_PLL_POSTDIV_MASK;
+	reg_val |= tdm_postdiv;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG2);
+
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG1);
+	reg_val &= ~TDM_PLL_FREQ_OFFSET_MASK;
+	reg_val |= freq_offset;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Disable reset */
+	reg_val |= TDM_PLL_SW_RESET;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	/* Wait 50us for PLL to lock */
+	udelay(50);
+
+	/* Restore frequency offset value validity */
+	reg_val |= TDM_PLL_FREQ_OFFSET_VALID;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	return 0;
+}
+
+/* Set DCO post divider in respect of 24MHz PLL output */
+static int mv_phone_dco_post_div_config(struct platform_device *pdev,
+					u32 pclk_freq_mhz)
+{
+	struct resource *mem;
+	u32 reg_val, pcm_clk_ratio;
+
+	if (!priv->dco_div_reg) {
+		mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "dco_div");
+		priv->dco_div_reg = devm_ioremap_resource(&pdev->dev, mem);
+		if (IS_ERR(priv->dco_div_reg))
+			return -ENOMEM;
+	}
+
+	switch (pclk_freq_mhz) {
+	case 8:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_8M;
+		break;
+	case 4:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_4M;
+		break;
+	case 2:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_2M;
+		break;
+	default:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_8M;
+		break;
+	}
+
+	/* Disable output clock */
+	reg_val = readl(priv->dco_div_reg);
+	reg_val &= ~DCO_CLK_DIV_RESET_MASK;
+	writel(reg_val, priv->dco_div_reg);
+
+	/* Set DCO source ratio */
+	reg_val = readl(priv->dco_div_reg);
+	writel((reg_val & ~DCO_CLK_DIV_RATIO_MASK) | pcm_clk_ratio,
+	       priv->dco_div_reg);
+
+	/* Reload new DCO source ratio */
+	reg_val = readl(priv->dco_div_reg);
+	reg_val |= DCO_CLK_DIV_APPLY_MASK;
+	writel(reg_val, priv->dco_div_reg);
+	mdelay(1);
+
+	reg_val = readl(priv->dco_div_reg);
+	reg_val &= ~DCO_CLK_DIV_APPLY_MASK;
+	writel(reg_val, priv->dco_div_reg);
+	mdelay(1);
+
+	/* Enable output clock */
+	reg_val = readl(priv->dco_div_reg);
+	reg_val |= DCO_CLK_DIV_RESET_MASK;
+	writel(reg_val, priv->dco_div_reg);
+
+	return 0;
+}
+
+static int mvebu_phone_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *mem;
+	int err, i;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct mv_phone_dev),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->np = np;
+
+	mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tdm_regs");
+	priv->tdm_base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(priv->tdm_base))
+		return PTR_ERR(priv->tdm_base);
+
+	priv->clk = devm_clk_get(&pdev->dev, "core");
+	if (PTR_ERR(priv->clk) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (IS_ERR(priv->clk)) {
+		dev_err(&pdev->dev, "no clock\n");
+		return PTR_ERR(priv->clk);
+	}
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	/* The following clock is only used by some SoCs */
+	priv->axi_clk = devm_clk_get(&pdev->dev, "axi");
+	if (IS_ERR(priv->axi_clk) &&
+	    PTR_ERR(priv->axi_clk) == -EPROBE_DEFER) {
+		err = -EPROBE_DEFER;
+		goto err_core_clk;
+	}
+	if (!IS_ERR(priv->axi_clk))
+		clk_prepare_enable(priv->axi_clk);
+
+	if (of_property_read_u32(np, "pclk-freq-mhz", &priv->pclk_freq_mhz) ||
+	    (priv->pclk_freq_mhz != 8 && priv->pclk_freq_mhz != 4 &&
+	     priv->pclk_freq_mhz != 2)) {
+		priv->pclk_freq_mhz = 8;
+		dev_info(&pdev->dev, "wrong pclk frequency in the DT\n");
+	}
+	dev_info(&pdev->dev, "setting pclk frequency to %d MHz\n",
+		 priv->pclk_freq_mhz);
+
+	if (of_device_is_compatible(np, "marvell,armada-380-tdm")) {
+		priv->tdm_type = MV_TDM_UNIT_TDM2C;
+		err = mv_phone_tdm_clk_pll_config(pdev);
+		err |= mv_phone_dco_post_div_config(pdev, priv->pclk_freq_mhz);
+		err |= tdm2c_set_mbus_windows(&pdev->dev, priv->tdm_base,
+					      mv_mbus_dram_info());
+		if (err < 0)
+			goto err_axi_clk;
+
+		priv->irq_count = 1;
+
+		tal_set_if(&tdm2c_if);
+	}
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-xp-tdm")) {
+		priv->tdm_type = MV_TDM_UNIT_TDMMC;
+		err = tdmmc_set_mbus_windows(&pdev->dev, priv->tdm_base);
+		if (err < 0)
+			goto err_axi_clk;
+
+		priv->irq_count = 1;
+		priv->tdmmc_ip_ver = TDMMC_REV1;
+
+		tal_set_if(&tdmmc_if);
+	}
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-a8k-tdm")) {
+		priv->tdm_type = MV_TDM_UNIT_TDMMC;
+		tdmmc_set_a8k_windows(&pdev->dev, priv->tdm_base);
+
+		priv->irq_count = 3;
+		priv->tdmmc_ip_ver = TDMMC_REV1;
+
+		tal_set_if(&tdmmc_if);
+	}
+
+	/* Obtain IRQ numbers */
+	for (i = 0; i < priv->irq_count; i++) {
+		priv->irq[i] = platform_get_irq(pdev, i);
+		if (priv->irq[i] <= 0) {
+			dev_err(&pdev->dev, "platform_get_irq %d failed\n", i);
+			err = priv->irq[i];
+			goto err_axi_clk;
+		}
+	}
+
+	if (priv->tdm_type == MV_TDM_UNIT_TDM2C) {
+		priv->use_pclk_external =
+				 of_property_read_bool(np, "use-external-pclk");
+		dev_info(&pdev->dev, "using %s pclk\n",
+			 priv->use_pclk_external ? "external" : "internal");
+
+		priv->tdm2c_daisy_chain_mode =
+				 of_property_read_bool(np, "daisy-chain-mode");
+		dev_info(&pdev->dev, "using %s SPI mode\n",
+			 priv->tdm2c_daisy_chain_mode ?
+			 "daisy-chain" : "direct");
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		priv->use_tdm_ext_stats = true;
+#endif
+	}
+
+	spin_lock_init(&priv->lock);
+	priv->dev = &pdev->dev;
+
+	return 0;
+
+err_core_clk:
+	clk_disable_unprepare(priv->clk);
+err_axi_clk:
+	clk_disable_unprepare(priv->axi_clk);
+
+	return err;
+}
+
+static int mvebu_phone_remove(struct platform_device *pdev)
+{
+	tal_set_if(NULL);
+
+	clk_disable_unprepare(priv->clk);
+	clk_disable_unprepare(priv->axi_clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int mvebu_phone_suspend(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < TDM_CTRL_REGS_NUM; i++)
+		priv->tdm_ctrl_regs[i] = readl(priv->tdm_base + i);
+
+	for (i = 0; i < TDM_SPI_REGS_NUM; i++)
+		priv->tdm_spi_regs[i] = readl(priv->tdm_base +
+					      TDM_SPI_REGS_OFFSET + i);
+
+	priv->tdm_spi_mux_reg = readl(priv->tdm_base + TDM_SPI_MUX_REG);
+	priv->tdm_mbus_config_reg = readl(priv->tdm_base + TDM_MBUS_CONFIG_REG);
+	priv->tdm_misc_reg = readl(priv->tdm_base + TDM_MISC_REG);
+
+	return 0;
+}
+
+static int mvebu_phone_resume(struct device *dev)
+{
+	struct platform_device *pdev = priv->parent;
+	int err, i;
+
+	err = tdm2c_set_mbus_windows(dev, priv->tdm_base,
+				     mv_mbus_dram_info());
+	if (err < 0)
+		return err;
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-380-tdm")) {
+		err = mv_phone_tdm_clk_pll_config(pdev);
+		err |= mv_phone_dco_post_div_config(pdev, priv->pclk_freq_mhz);
+		if (err < 0)
+			return err;
+	}
+
+	for (i = 0; i < TDM_CTRL_REGS_NUM; i++)
+		writel(priv->tdm_ctrl_regs[i], priv->tdm_base + i);
+
+	for (i = 0; i < TDM_SPI_REGS_NUM; i++)
+		writel(priv->tdm_spi_regs[i], priv->tdm_base +
+					      TDM_SPI_REGS_OFFSET + i);
+
+	writel(priv->tdm_spi_mux_reg, priv->tdm_base + TDM_SPI_MUX_REG);
+	writel(priv->tdm_mbus_config_reg, priv->tdm_base + TDM_MBUS_CONFIG_REG);
+	writel(priv->tdm_misc_reg, priv->tdm_base + TDM_MISC_REG);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops mvebu_phone_pmops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mvebu_phone_suspend, mvebu_phone_resume)
+};
+
+#define MVEBU_PHONE_PMOPS (&mvebu_phone_pmops)
+
+#else
+#define MVEBU_PHONE_PMOPS NULL
+#endif
+
+static const struct of_device_id mvebu_phone_match[] = {
+	{ .compatible = "marvell,armada-380-tdm" },
+	{ .compatible = "marvell,armada-a8k-tdm" },
+	{ .compatible = "marvell,armada-xp-tdm" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mvebu_phone_match);
+
+static struct platform_driver mvebu_phone_driver = {
+	.probe	= mvebu_phone_probe,
+	.remove	= mvebu_phone_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.of_match_table = mvebu_phone_match,
+		.owner	= THIS_MODULE,
+		.pm	= MVEBU_PHONE_PMOPS,
+	},
+};
+
+module_platform_driver(mvebu_phone_driver);
+
+MODULE_DESCRIPTION("Marvell Telephony Driver");
+MODULE_AUTHOR("Marcin Wojtas <mw@semihalf.com>");
diff --git a/drivers/telephony/mvebu_phone/mv_phone_spi.c b/drivers/telephony/mvebu_phone/mv_phone_spi.c
new file mode 100644
index 000000000000..43a4227532f2
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone_spi.c
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include <linux/spi/spi.h>
+#include "mv_phone.h"
+
+#define DRV_NAME "mvebu_phone_spi"
+
+#define MAX_SLIC_DEVICES 32
+
+/* Global array of pointers to SLIC SPI devices */
+struct spi_device *slic_devs[MAX_SLIC_DEVICES];
+
+/* Telephony register read via SPI interface. */
+void mv_phone_spi_read(u16 dev_id, u8 *cmd_buff, u8 cmd_size,
+		       u8 *data_buff, u8 data_size, u32 spi_type)
+{
+	struct spi_device *slic_spi = slic_devs[dev_id];
+	int err;
+
+#ifdef CONFIG_MV_PHONE_SPI_DEBUG
+	pr_info("%s():line(%d) Spi ID=%d dev_id=%d Spi CS=%d Spi type=%d\n",
+		__func__, __LINE__, slic_spi->master->bus_num, dev_id,
+		slic_spi->chip_select, spi_type);
+#endif
+
+	err = spi_write_then_read(slic_spi, (const void *)cmd_buff, cmd_size,
+				  (void *)data_buff, data_size);
+	if (err)
+		dev_err(&slic_spi->dev, "SPI read failed\n");
+
+#ifdef CONFIG_MV_PHONE_SPI_DEBUG
+	pr_info("CMD = 0x%x, cmd_size = 0x%x, DATA = 0x%x, data_size = 0x%x\n",
+		*cmd_buff, cmd_size, *data_buff, data_size);
+#endif
+}
+
+/* Telephony register write via SPI interface. */
+void mv_phone_spi_write(u16 dev_id, u8 *cmd_buff, u8 cmd_size,
+			u8 *data_buff, u8 data_size, u32 spi_type)
+{
+	int err;
+	struct spi_message m;
+	struct spi_device *slic_spi = slic_devs[dev_id];
+	struct spi_transfer t[2] = { { .tx_buf = (const void *)cmd_buff,
+				       .len = cmd_size, },
+				     { .tx_buf = (const void *)data_buff,
+				       .len = data_size, }, };
+
+#ifdef CONFIG_MV_PHONE_SPI_DEBUG
+	pr_info("%s():line(%d) Spi ID=%d dev_id=%d Spi CS=%d Spi type=%d\n",
+		__func__, __LINE__, slic_spi->master->bus_num, dev_id,
+		slic_spi->chip_select, spi_type);
+	pr_info("CMD = 0x%x, cmd_size = 0x%x, DATA = 0x%x, data_size = 0x%x\n",
+		*cmd_buff, cmd_size, *data_buff, data_size);
+#endif
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+
+	err = spi_sync(slic_spi, &m);
+	if (err)
+		dev_err(&slic_spi->dev, "SPI write failed\n");
+}
+
+static int mvebu_phone_spi_probe(struct spi_device *spi)
+{
+	int err;
+	u32 dev_id;
+
+	/* Obtain SLIC ID */
+	err = of_property_read_u32(spi->dev.of_node, "slic-id", &dev_id);
+	if (err == -EINVAL) {
+		/* Assign '0' ID in case the 'slic-id' property is not used */
+		dev_id = 0;
+	} else if (err) {
+		dev_err(&spi->dev, "unable to get SLIC ID\n");
+		return err;
+	} else if (dev_id >= MAX_SLIC_DEVICES) {
+		dev_err(&spi->dev, "SLIC ID (%d) exceeds maximum (%d)\n",
+			dev_id, MAX_SLIC_DEVICES - 1);
+		return -EINVAL;
+	}
+
+	/* Check if this ID wasn't used by previous devices */
+	if (slic_devs[dev_id]) {
+		dev_err(&spi->dev, "overlapping ID (%d) at bus #%d, CS #%d\n",
+			dev_id, spi->master->bus_num, spi->chip_select);
+		return -EINVAL;
+	}
+
+	slic_devs[dev_id] = spi;
+
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi setup failed\n");
+		return err;
+	}
+
+	dev_info(&spi->dev, "registered slic spi device %d at bus #%d, CS #%d",
+		 dev_id, spi->master->bus_num, spi->chip_select);
+
+	return 0;
+}
+
+static int mvebu_phone_spi_remove(struct spi_device *spi)
+{
+	return 0;
+}
+
+static const struct spi_device_id mvebu_phone_spi_ids[] = {
+	{ "mv_slic", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, mvebu_phone_spi_ids);
+
+static struct spi_driver mvebu_phone_spi_driver = {
+	.driver = {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table = mvebu_phone_spi_ids,
+	.probe	= mvebu_phone_spi_probe,
+	.remove	= mvebu_phone_spi_remove,
+};
+
+module_spi_driver(mvebu_phone_spi_driver);
+
+MODULE_DESCRIPTION("Marvell Telephony SPI Driver");
+MODULE_AUTHOR("Marcin Wojtas <mw@semihalf.com>");
diff --git a/drivers/telephony/mvebu_phone/slic/drv_dxt_if.c b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.c
new file mode 100644
index 000000000000..eac36ed64fe5
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include "drv_dxt_if.h"
+
+static int drv_dxt_spi_cs;
+static int drv_dxt_irq;
+static void *drv_dxt_irq_dev;
+static irq_handler_t drv_dxt_irq_handler;
+
+void drv_dxt_if_signal_interrupt(void)
+{
+	if (drv_dxt_irq_handler == NULL)
+		return;
+
+	drv_dxt_irq_handler(drv_dxt_irq, drv_dxt_irq_dev);
+}
+
+void drv_dxt_if_enable_irq(u32 irq)
+{
+	/* We have only one TDM channel */
+	mv_phone_intr_enable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_enable_irq);
+
+void drv_dxt_if_disable_irq(u32 irq)
+{
+	/* We have only one TDM channel */
+	mv_phone_intr_disable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_disable_irq);
+
+int drv_dxt_if_request_irq(u32 irq, irq_handler_t handler, u64 flags,
+			   const char *name, void *dev)
+{
+	drv_dxt_irq = irq;
+	drv_dxt_irq_dev = dev;
+	drv_dxt_irq_handler = handler;
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_request_irq);
+
+void drv_dxt_if_free_irq(u32 irq, void *dev)
+{
+	drv_dxt_irq_handler = NULL;
+}
+EXPORT_SYMBOL(drv_dxt_if_free_irq);
+
+void drv_dxt_if_spi_cs_set(u32 dev_no, u32 hi_lo)
+{
+	if (hi_lo == 0)
+		drv_dxt_spi_cs = dev_no;
+	else
+		drv_dxt_spi_cs = -1;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_cs_set);
+
+int drv_dxt_if_spi_ll_read_write(u8 *tx_data, u32 tx_size,
+				 u8 *rx_data, u32 rx_size)
+{
+	uint16_t *ptr;
+	int i;
+
+	if ((tx_size & 1) || (rx_size & 1)) {
+		pr_err("drv_dxt_if: SPI transfer is not word aligned!\n");
+		return 0;
+	}
+
+	ptr = (uint16_t *)tx_data;
+	for (i = 0; i < tx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	if (rx_data != NULL && rx_size != 0) {
+		mv_phone_spi_read(drv_dxt_spi_cs, tx_data, tx_size,
+				  rx_data, rx_size, SPI_TYPE_SLIC_LANTIQ);
+	} else if (tx_data != NULL && tx_size > 2) {
+		mv_phone_spi_write(drv_dxt_spi_cs, tx_data, 2, tx_data + 2,
+				   tx_size - 2, SPI_TYPE_SLIC_LANTIQ);
+	} else {
+		pr_err("drv_dxt_if: Unsupported SPI access mode!\n");
+	}
+
+	ptr = (uint16_t *)rx_data;
+	for (i = 0; i < rx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_ll_read_write);
+
diff --git a/drivers/telephony/mvebu_phone/slic/drv_dxt_if.h b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.h
new file mode 100644
index 000000000000..c2607ff845eb
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.h
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _DRV_DXT_IF_H
+#define _DRV_DXT_IF_H
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "mv_phone.h"
+
+/* Interface to drv_dxt driver */
+extern void drv_dxt_if_enable_irq(u32 irq);
+extern void drv_dxt_if_disable_irq(u32 irq);
+extern int drv_dxt_if_request_irq(u32 irq, irq_handler_t handler, u64 flags,
+				  const char *name, void *dev);
+extern void drv_dxt_if_free_irq(u32 irq, void *dev);
+extern void drv_dxt_if_spi_cs_set(u32 dev_no, u32 hi_lo);
+extern int drv_dxt_if_spi_ll_read_write(u8 *tx_data, u32 tx_size,
+					u8 *rx_data, u32 rx_size);
+extern void drv_dxt_if_signal_interrupt(void);
+
+#endif /* _DRV_DXT_IF_H */
diff --git a/drivers/telephony/mvebu_phone/slic/silabs_if.c b/drivers/telephony/mvebu_phone/slic/silabs_if.c
new file mode 100644
index 000000000000..01be96f64fa8
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/silabs_if.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include "silabs_if.h"
+
+static void (*isi_handler)(unsigned long);
+
+void silabs_if_enable_irq(u32 device)
+{
+	mv_phone_intr_enable(device);
+}
+EXPORT_SYMBOL(silabs_if_enable_irq);
+
+void silabs_if_disable_irq(u32 device)
+{
+	mv_phone_intr_disable(device);
+}
+EXPORT_SYMBOL(silabs_if_disable_irq);
+
+void silabs_if_handler_register(void *func)
+{
+	isi_handler = func;
+}
+EXPORT_SYMBOL(silabs_if_handler_register);
+
+void silabs_if_handler_unregister(void)
+{
+	isi_handler = NULL;
+}
+EXPORT_SYMBOL(silabs_if_handler_unregister);
+
+void silabs_if_isi_interrupt(void)
+{
+	if (isi_handler != NULL)
+		isi_handler(0);
+}
+EXPORT_SYMBOL(silabs_if_isi_interrupt);
+
+void silabs_if_spi_init(u32 line)
+{
+}
+EXPORT_SYMBOL(silabs_if_spi_init);
+
+void silabs_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+			u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_SILABS_ID)
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ISI);
+	else
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(silabs_if_spi_read);
+
+void silabs_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+			 u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_SILABS_ID)
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ISI);
+	else
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(silabs_if_spi_write);
diff --git a/drivers/telephony/mvebu_phone/slic/silabs_if.h b/drivers/telephony/mvebu_phone/slic/silabs_if.h
new file mode 100644
index 000000000000..5ea0a878b3ea
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/silabs_if.h
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _SILABS_IF_H_
+#define _SILABS_IF_H_
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "mv_phone.h"
+
+/* Interface to Silabs SLIC driver */
+extern void silabs_if_enable_irq(u32 device);
+extern void silabs_if_disable_irq(u32 device);
+extern void silabs_if_handler_register(void *func);
+extern void silabs_if_handler_unregister(void);
+extern void silabs_if_isi_interrupt(void);
+extern void silabs_if_spi_init(u32 line);
+extern void silabs_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+			       u8 *data, u8 data_size);
+extern void silabs_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+				u8 *data, u8 data_size);
+
+#endif /* SILABS_IF_H_ */
+
diff --git a/drivers/telephony/mvebu_phone/slic/zarlink_if.c b/drivers/telephony/mvebu_phone/slic/zarlink_if.c
new file mode 100644
index 000000000000..409f4dc6d3c7
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/zarlink_if.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include "zarlink_if.h"
+
+static void (*zsi_handler)(unsigned long);
+
+void zarlink_if_enable_irq(u32 device)
+{
+	mv_phone_intr_enable(device);
+}
+EXPORT_SYMBOL(zarlink_if_enable_irq);
+
+void zarlink_if_disable_irq(u32 device)
+{
+	mv_phone_intr_disable(device);
+}
+EXPORT_SYMBOL(zarlink_if_disable_irq);
+
+void zarlink_if_handler_register(void *func)
+{
+	zsi_handler = func;
+}
+EXPORT_SYMBOL(zarlink_if_handler_register);
+
+void zarlink_if_handler_unregister(void)
+{
+	zsi_handler = NULL;
+}
+EXPORT_SYMBOL(zarlink_if_handler_unregister);
+
+void zarlink_if_zsi_interrupt(void)
+{
+	if (zsi_handler != NULL)
+		zsi_handler(0);
+}
+EXPORT_SYMBOL(zarlink_if_zsi_interrupt);
+
+void zarlink_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+			 u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_ZARLINK_ID)
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ZSI);
+	else
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(zarlink_if_spi_read);
+
+void zarlink_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+			  u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_ZARLINK_ID)
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ZSI);
+	else
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(zarlink_if_spi_write);
diff --git a/drivers/telephony/mvebu_phone/slic/zarlink_if.h b/drivers/telephony/mvebu_phone/slic/zarlink_if.h
new file mode 100644
index 000000000000..0028dba6f2e8
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/zarlink_if.h
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _ZARLINK_IF_H_
+#define _ZARLINK_IF_H_
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "mv_phone.h"
+
+/* Interface to Zarlink SLIC driver */
+extern void zarlink_if_enable_irq(u32 device);
+extern void zarlink_if_disable_irq(u32 device);
+extern void zarlink_if_handler_register(void *func);
+extern void zarlink_if_handler_unregister(void);
+extern void zarlink_if_zsi_interrupt(void);
+extern void zarlink_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+				u8 *data, u8 data_size);
+extern void zarlink_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+				 u8 *data, u8 data_size);
+
+#endif /* _ZARLINK_IF_H_ */
+
diff --git a/drivers/telephony/mvebu_phone/tal/tal.c b/drivers/telephony/mvebu_phone/tal/tal.c
new file mode 100644
index 000000000000..1d8cd922b8ce
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal.c
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+/* Marvell Telephony Adaptation Layer */
+#include "tal.h"
+
+static struct tal_if *tal_if;
+static struct tal_mmp_ops *tal_mmp;
+
+enum tal_status tal_init(struct tal_params *tal_params,
+			 struct tal_mmp_ops *mmp_ops)
+{
+	if (!tal_params || !mmp_ops) {
+		pr_err("%s: Error, bad parameters.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	if (!mmp_ops->tal_mmp_rx_callback || !mmp_ops->tal_mmp_tx_callback) {
+		pr_err("%s: Error, MMP callbacks are missing.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	tal_mmp = mmp_ops;
+	if (tal_if && tal_if->init)
+		if (tal_if->init(tal_params) != 0)
+			return TAL_STAT_INIT_ERROR;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_init);
+
+void tal_exit(void)
+{
+	if (tal_if && tal_if->exit)
+		tal_if->exit();
+
+	tal_mmp = NULL;
+}
+EXPORT_SYMBOL(tal_exit);
+
+void tal_pcm_start(void)
+{
+	if (tal_if && tal_if->pcm_start)
+		tal_if->pcm_start();
+}
+EXPORT_SYMBOL(tal_pcm_start);
+
+void tal_pcm_stop(void)
+{
+	if (tal_if && tal_if->pcm_stop)
+		tal_if->pcm_stop();
+}
+EXPORT_SYMBOL(tal_pcm_stop);
+
+int tal_control(int cmd, void *data)
+{
+	if (tal_if && tal_if->control)
+		return tal_if->control(cmd, data);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(tal_control);
+
+enum tal_status tal_write(u8 *buffer, int size)
+{
+	if (tal_if && tal_if->write)
+		if (tal_if->write(buffer, size) != 0)
+			return TAL_STAT_BAD_PARAM;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_write);
+
+enum tal_status tal_stats_get(struct tal_stats *tal_stats)
+{
+	if (tal_stats && tal_if && tal_if->stats_get) {
+		tal_if->stats_get(tal_stats);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_stats_get);
+
+enum tal_status tal_set_if(struct tal_if *interface)
+{
+	if (interface && (!interface->init || !interface->exit ||
+			  !interface->pcm_start || !interface->pcm_stop)) {
+		pr_err("%s: Error, TAL callbacks are missing.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	tal_if = interface;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_set_if);
+
+enum tal_status tal_mmp_rx(u8 *buffer, int size)
+{
+	if (tal_mmp && tal_mmp->tal_mmp_rx_callback) {
+		tal_mmp->tal_mmp_rx_callback(buffer, size);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_mmp_rx);
+
+enum tal_status tal_mmp_tx(u8 *buffer, int size)
+{
+	if (tal_mmp && tal_mmp->tal_mmp_tx_callback) {
+		tal_mmp->tal_mmp_tx_callback(buffer, size);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_mmp_tx);
diff --git a/drivers/telephony/mvebu_phone/tal/tal.h b/drivers/telephony/mvebu_phone/tal/tal.h
new file mode 100644
index 000000000000..82edbab7c36d
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal.h
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+/* Marvell Telephony Adaptation Layer */
+
+#ifndef _TAL_H_
+#define _TAL_H_
+
+#include "mv_phone.h"
+
+/* Defines */
+#define TAL_MAX_PHONE_LINES	32
+
+/* Enumerators */
+enum tal_pcm_format {
+	TAL_PCM_FORMAT_1BYTE = 1,
+	TAL_PCM_FORMAT_2BYTES = 2,
+	TAL_PCM_FORMAT_4BYTES = 4,
+};
+
+enum tal_status {
+	TAL_STAT_OK = 0,
+	TAL_STAT_BAD_PARAM,
+	TAL_STAT_INIT_ERROR,
+};
+
+/* Structures */
+struct tal_params {
+	enum tal_pcm_format pcm_format;
+	u16 pcm_slot[TAL_MAX_PHONE_LINES];
+	u8 sampling_period;
+	u16 total_lines;
+};
+
+struct tal_stats {
+	int tdm_init;
+	u32 rx_miss;
+	u32 tx_miss;
+	u32 rx_over;
+	u32 tx_under;
+	struct mv_phone_extended_stats tdm_ext_stats;
+};
+
+struct tal_mmp_ops {
+	void (*tal_mmp_rx_callback)(u8 *rx_buff, int size);
+	void (*tal_mmp_tx_callback)(u8 *tx_buff, int size);
+};
+
+struct tal_if {
+	int (*init)(struct tal_params *tal_params);
+	void (*exit)(void);
+	void (*pcm_start)(void);
+	void (*pcm_stop)(void);
+	int (*control)(int cmd, void *data);
+	int (*write)(u8 *buffer, int size);
+	void (*stats_get)(struct tal_stats *tal_stats);
+};
+
+/* API */
+enum tal_status tal_init(struct tal_params *tal_params,
+			 struct tal_mmp_ops *mmp_ops);
+enum tal_status tal_stats_get(struct tal_stats *tal_stats);
+void tal_exit(void);
+void tal_pcm_start(void);
+void tal_pcm_stop(void);
+int tal_control(int cmd, void *data);
+
+enum tal_status tal_set_if(struct tal_if *interface);
+enum tal_status tal_mmp_rx(u8 *buffer, int size);
+enum tal_status tal_mmp_tx(u8 *buffer, int size);
+enum tal_status tal_write(u8 *buffer, int size);
+
+#endif /* _TAL_H */
diff --git a/drivers/telephony/mvebu_phone/tal/tal_dev.c b/drivers/telephony/mvebu_phone/tal/tal_dev.c
new file mode 100644
index 000000000000..a0fdb1ec3ffa
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal_dev.c
@@ -0,0 +1,257 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "tal.h"
+#include "tal_dev.h"
+
+#define	TALDEV_NAME	"tal"
+
+static DECLARE_WAIT_QUEUE_HEAD(tal_dev_wait);
+static DEFINE_SPINLOCK(tal_dev_lock);
+static unsigned char *rx_buff_p, *tx_buff_p;
+static size_t rx_buff_size, tx_buff_size;
+
+static void tal_dev_rx_callback(unsigned char *rx_buff, int size)
+{
+	unsigned long flags;
+
+	/* Save buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	rx_buff_p = rx_buff;
+	rx_buff_size = size;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	wake_up_interruptible(&tal_dev_wait);
+}
+
+static void tal_dev_tx_callback(unsigned char *tx_buff, int size)
+{
+	unsigned long flags;
+
+	/* Save buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	tx_buff_p = tx_buff;
+	tx_buff_size = size;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	wake_up_interruptible(&tal_dev_wait);
+}
+
+static struct tal_params tal_params;
+static struct tal_mmp_ops tal_mmp_ops = {
+	.tal_mmp_rx_callback	= tal_dev_rx_callback,
+	.tal_mmp_tx_callback	= tal_dev_tx_callback,
+};
+
+static ssize_t tal_dev_read(struct file *file_p, char __user *buf,
+			    size_t size, loff_t *ppos)
+{
+	unsigned long flags;
+	unsigned char *rx_buff;
+
+	/* Check if we have got the buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	rx_buff = rx_buff_p;
+	rx_buff_p = NULL;
+	size = min(rx_buff_size, size);
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	if (!rx_buff)
+		return 0;
+
+	/* Copy data to userspace */
+	if (copy_to_user(buf, rx_buff, size))
+		return -EFAULT;
+
+	return size;
+}
+
+static ssize_t tal_dev_write(struct file *file_p, const char __user *buf,
+			     size_t size, loff_t *ppos)
+{
+	unsigned long flags;
+	unsigned char *tx_buff;
+
+	/* Check if we have got the buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	tx_buff = tx_buff_p;
+	tx_buff_p = NULL;
+	size = min(tx_buff_size, size);
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	if (!tx_buff)
+		return 0;
+
+	/* Copy data from userspace */
+	if (copy_from_user(tx_buff, buf, size))
+		size = -EFAULT;
+
+	/* Pass the buffer to TAL */
+	if (tal_write(tx_buff, size) != TAL_STAT_OK)
+		return -EIO;
+
+	return size;
+}
+
+static int tal_dev_open(struct inode *inode_p, struct file *file_p)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int tal_dev_release(struct inode *inode_p, struct file *file_p)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static unsigned int tal_dev_poll(struct file *file_p, poll_table *poll_table_p)
+{
+	unsigned long flags;
+	int mask = 0;
+
+	poll_wait(file_p, &tal_dev_wait, poll_table_p);
+
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	if (rx_buff_p)
+		mask |= POLLIN | POLLRDNORM;
+	if (tx_buff_p)
+		mask |= POLLOUT | POLLWRNORM;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	return mask;
+}
+
+static long tal_dev_ioctl(struct file *file_p, unsigned int cmd,
+							unsigned long arg)
+{
+	struct tal_dev_params tal_dev_params;
+	char buffer[16];
+	long ret = 0;
+	int i;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != TAL_DEV_IOCTL_MAGIC) {
+		pr_err("%s: invalid TAL DEV Magic Num %i %i\n",
+		       __func__, _IOC_TYPE(cmd), TAL_DEV_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg,
+				 _IOC_SIZE(cmd));
+
+	if ((_IOC_DIR(cmd) & _IOC_WRITE) && !ret)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg,
+				 _IOC_SIZE(cmd));
+
+	if (ret) {
+		pr_err("%s: invalid TAL DEV access type %i from cmd %i\n",
+		       __func__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case TAL_DEV_INIT:
+		if (copy_from_user(&tal_dev_params,
+		    (void *)arg, sizeof(tal_dev_params)))
+			return -EFAULT;
+
+		tal_params.pcm_format = tal_dev_params.pcm_format;
+		tal_params.sampling_period = 10; /* ms */
+		tal_params.total_lines = tal_dev_params.total_lines;
+		for (i = 0; i < TAL_MAX_PHONE_LINES; i++)
+			tal_params.pcm_slot[i] =
+					    (i + 1) * tal_dev_params.pcm_format;
+
+		if (tal_init(&tal_params, &tal_mmp_ops) != TAL_STAT_OK)
+			return -EIO;
+
+		break;
+
+	case TAL_DEV_EXIT:
+		tal_exit();
+		break;
+
+	case TAL_DEV_PCM_START:
+		rx_buff_p = NULL;
+		tx_buff_p = NULL;
+		tal_pcm_start();
+		break;
+
+	case TAL_DEV_PCM_STOP:
+		tal_pcm_stop();
+		break;
+
+	default:
+		/* Pass ioctl to the low-level interface */
+		if (_IOC_SIZE(cmd) > sizeof(buffer))
+			return -E2BIG;
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(buffer, (void *)arg, _IOC_SIZE(cmd)))
+				return -EFAULT;
+
+		ret = tal_control(cmd, buffer);
+
+		if (_IOC_DIR(cmd) & _IOC_READ)
+			if (copy_to_user((void *)arg, buffer, _IOC_SIZE(cmd)))
+				return -EFAULT;
+
+		break;
+	}
+
+	return ret;
+}
+
+static const struct file_operations tal_dev_fops = {
+	.owner		= THIS_MODULE,
+	.read		= tal_dev_read,
+	.write		= tal_dev_write,
+	.poll		= tal_dev_poll,
+	.unlocked_ioctl	= tal_dev_ioctl,
+	.open		= tal_dev_open,
+	.release	= tal_dev_release,
+};
+
+static struct miscdevice tal_dev = {
+	.minor	= TALDEV_MINOR,
+	.name	= TALDEV_NAME,
+	.fops	= &tal_dev_fops,
+};
+
+static int __init tal_dev_init(void)
+{
+	int status;
+
+	status = misc_register(&tal_dev);
+	if (status < 0) {
+		pr_err("Failed to register TAL device!\n");
+		return status;
+	}
+
+	return 0;
+}
+
+static void __exit tal_dev_exit(void)
+{
+	misc_deregister(&tal_dev);
+}
+
+/* Module stuff */
+module_init(tal_dev_init);
+module_exit(tal_dev_exit);
+MODULE_DESCRIPTION("Marvell TAL Device Interface");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@angel.net.pl>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/tal/tal_dev.h b/drivers/telephony/mvebu_phone/tal/tal_dev.h
new file mode 100644
index 000000000000..19ec88f49326
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal_dev.h
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _TAL_DEV_H_
+#define _TAL_DEV_H_
+
+#define TAL_DEV_IOCTL_MAGIC		't'
+
+#define TAL_DEV_INIT			_IOWR(TAL_DEV_IOCTL_MAGIC, 1,\
+					      struct tal_dev_params)
+#define TAL_DEV_EXIT			_IO(TAL_DEV_IOCTL_MAGIC, 2)
+#define TAL_DEV_PCM_START		_IO(TAL_DEV_IOCTL_MAGIC, 3)
+#define TAL_DEV_PCM_STOP		_IO(TAL_DEV_IOCTL_MAGIC, 4)
+
+struct tal_dev_params {
+	unsigned char pcm_format;
+	unsigned short total_lines;
+};
+
+#define	TDM_DEV_TDM_TEST_MODE_ENABLE	_IO(TAL_DEV_IOCTL_MAGIC, 8)
+#define	TDM_DEV_TDM_TEST_MODE_DISABLE	_IO(TAL_DEV_IOCTL_MAGIC, 9)
+
+#endif /*_TAL_DEV_H_*/
diff --git a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
new file mode 100644
index 000000000000..1f6a04b36b57
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
@@ -0,0 +1,1022 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include "mv_phone.h"
+
+/* Main TDM structure definition */
+struct tdm2c_dev {
+	/* Resources */
+	void __iomem *regs;
+	struct device *dev;
+
+	/* Buffers */
+	u8 *rx_aggr_buff_virt;
+	u8 *tx_aggr_buff_virt;
+
+	/* Flags and counters */
+	u16 rx_full;
+	u16 tx_empty;
+	u8 rx_int;
+	u8 tx_int;
+	bool enable;
+	bool int_lock;
+	int chan_stop_count;
+
+	/* Parameters */
+	u8 factor;
+	enum mv_phone_pcm_format pcm_format;
+	enum mv_phone_band_mode band_mode;
+
+	/* Channels' data */
+	struct tdm2c_ch_info *ch_info[MV_TDM2C_TOTAL_CHANNELS];
+
+	/* Statistics */
+	u32 int_rx_count;
+	u32 int_tx_count;
+	u32 int_rx0_count;
+	u32 int_tx0_count;
+	u32 int_rx1_count;
+	u32 int_tx1_count;
+	u32 int_rx0_miss;
+	u32 int_tx0_miss;
+	u32 int_rx1_miss;
+	u32 int_tx1_miss;
+	u32 pcm_restart_count;
+};
+
+struct tdm2c_dev *tdm2c;
+
+static void tdm2c_daisy_chain_mode_set(void)
+{
+	while ((readl(tdm2c->regs + SPI_CTRL_REG) & SPI_STAT_MASK) ==
+	       SPI_ACTIVE)
+		continue;
+	writel((0x80 << 8) | 0, tdm2c->regs + SPI_CODEC_CMD_LO_REG);
+	writel(TRANSFER_BYTES(2) | ENDIANNESS_MSB_MODE |
+	       WR_MODE | CLK_SPEED_LO_DIV, tdm2c->regs + SPI_CODEC_CTRL_REG);
+	writel(readl(tdm2c->regs + SPI_CTRL_REG) | SPI_ACTIVE,
+	       tdm2c->regs + SPI_CTRL_REG);
+	/* Poll for ready indication */
+	while ((readl(tdm2c->regs + SPI_CTRL_REG) & SPI_STAT_MASK) ==
+	       SPI_ACTIVE)
+		continue;
+
+	dev_dbg(tdm2c->dev, "%s: Exit\n", __func__);
+}
+
+static int tdm2c_ch_init(u8 ch)
+{
+	struct tdm2c_ch_info *ch_info;
+	u32 buff;
+
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
+
+	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
+		dev_err(tdm2c->dev, "%s: channel(%d) exceeds maximum(%d)\n",
+			__func__, ch, MV_TDM2C_TOTAL_CHANNELS);
+		return -EINVAL;
+	}
+
+	tdm2c->ch_info[ch] = kmalloc(sizeof(struct tdm2c_ch_info), GFP_ATOMIC);
+	if (!tdm2c->ch_info) {
+		dev_err(tdm2c->dev, "%s: error malloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	ch_info = tdm2c->ch_info[ch];
+	ch_info->ch = ch;
+
+	/* Per channel TDM init */
+	/* Disable channel (enable in pcm start) */
+	writel(CH_DISABLE, tdm2c->regs + CH_ENABLE_REG(ch));
+	/* Set total samples and int sample */
+	writel(CONFIG_CH_SAMPLE(tdm2c->band_mode, tdm2c->factor),
+	       tdm2c->regs + CH_SAMPLE_REG(ch));
+
+	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+		/* Buffers must be 32B aligned */
+		ch_info->rx_buff_virt[buff] = dma_alloc_coherent(tdm2c->dev,
+				MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+				tdm2c->band_mode, tdm2c->factor),
+				&(ch_info->rx_buff_phys[buff]), GFP_KERNEL);
+		ch_info->rx_buff_full[buff] = BUFF_IS_EMPTY;
+
+		ch_info->tx_buff_virt[buff] = dma_alloc_coherent(tdm2c->dev,
+				MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+				tdm2c->band_mode, tdm2c->factor),
+				&(ch_info->tx_buff_phys[buff]), GFP_KERNEL);
+		ch_info->tx_buff_empty[buff] = BUFF_IS_FULL;
+
+		memset(ch_info->tx_buff_virt[buff], 0,
+				MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+						    tdm2c->band_mode,
+						    tdm2c->factor));
+
+		if (((ulong) ch_info->rx_buff_virt[buff] |
+		    ch_info->rx_buff_phys[buff] |
+		    (ulong)ch_info->tx_buff_virt[buff] |
+		    ch_info->tx_buff_phys[buff]) & 0x1f) {
+			dev_err(tdm2c->dev, "%s: unaligned buffer allocation\n",
+				__func__);
+		}
+	}
+
+	return 0;
+}
+
+static inline int tdm2c_ch_tx_low(u8 ch)
+{
+	u32 max_poll = 0;
+	struct tdm2c_ch_info *ch_info = tdm2c->ch_info[ch];
+
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
+
+	/* Count tx interrupts */
+	tdm2c->tx_int++;
+
+	if (ch_info->tx_buff_empty[ch_info->tx_curr_buff] == BUFF_IS_FULL)
+		dev_dbg(tdm2c->dev, "curr buff full for hw [MMP ok]\n");
+	else
+		dev_warn(tdm2c->dev, "curr buf is empty [MMP miss write]\n");
+
+	/* Change buffers */
+	ch_info->tx_curr_buff = MV_TDM_NEXT_BUFFER(ch_info->tx_curr_buff);
+
+	/*
+	 * Mark next buff to be transmitted by HW as empty. Give it to the HW
+	 * for next frame. The app need to write the data before HW takes it.
+	 */
+	ch_info->tx_buff_empty[ch_info->tx_curr_buff] = BUFF_IS_EMPTY;
+	dev_dbg(tdm2c->dev, "->%s clear buf(%d) for channel(%d)\n",
+		__func__, ch_info->tx_curr_buff, ch);
+
+	/* Poll on SW ownership (single check) */
+	dev_dbg(tdm2c->dev, "start poll for SW ownership\n");
+	while (((readb(tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) +
+	       TX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW) &&
+	       (max_poll < 2000)) {
+		udelay(1);
+		max_poll++;
+	}
+	if (max_poll == 2000) {
+		dev_err(tdm2c->dev, "poll timeout (~2ms)\n");
+		return -ETIME;
+	}
+
+	dev_dbg(tdm2c->dev, "ch%d, start tx buff %d\n", ch,
+		ch_info->tx_curr_buff);
+
+	/* Set TX buff address (must be 32 byte aligned) */
+	writel(ch_info->tx_buff_phys[ch_info->tx_curr_buff],
+	       tdm2c->regs + CH_TX_ADDR_REG(ch_info->ch));
+
+	/* Set HW ownership */
+	writeb(OWN_BY_HW,
+	       tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS);
+
+	/* Enable Tx */
+	writeb(CH_ENABLE,
+	       tdm2c->regs + CH_ENABLE_REG(ch_info->ch) + TX_ENABLE_BYTE_OFFS);
+
+	/* Did we get the required amount of irqs for Tx wakeup ? */
+	if (tdm2c->tx_int < MV_TDM_INT_COUNTER)
+		return -EBUSY;
+
+	tdm2c->tx_int = 0;
+	tdm2c->tx_empty = ch_info->tx_curr_buff;
+
+	return 0;
+}
+
+static inline int tdm2c_ch_rx_low(u8 ch)
+{
+	u32 max_poll = 0;
+	struct tdm2c_ch_info *ch_info = tdm2c->ch_info[ch];
+
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
+
+	if (ch_info->rx_first)
+		ch_info->rx_first = !FIRST_INT;
+	else
+		tdm2c->rx_int++;
+
+	if (ch_info->rx_buff_full[ch_info->rx_curr_buff] == BUFF_IS_EMPTY)
+		dev_dbg(tdm2c->dev, "curr buff empty for hw [MMP ok]\n");
+	else
+		dev_warn(tdm2c->dev, "curr buf is full [MMP miss read]\n");
+
+	/*
+	 * Mark last buff that was received by HW as full. Give next buff to HW
+	 * for next frame. The app need to read the data before next irq
+	 */
+	ch_info->rx_buff_full[ch_info->rx_curr_buff] = BUFF_IS_FULL;
+
+	/* Change buffers */
+	ch_info->rx_curr_buff = MV_TDM_NEXT_BUFFER(ch_info->rx_curr_buff);
+
+	/* Poll on SW ownership (single check) */
+	dev_dbg(tdm2c->dev, "start poll for ownership\n");
+	while (((readb(tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) +
+	       RX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW) &&
+	       (max_poll < 2000)) {
+		udelay(1);
+		max_poll++;
+	}
+
+	if (max_poll == 2000) {
+		dev_err(tdm2c->dev, "poll timeout (~2ms)\n");
+		return -ETIME;
+	}
+
+	dev_dbg(tdm2c->dev, "ch%d, start rx buff %d\n", ch,
+		ch_info->rx_curr_buff);
+
+	/* Set RX buff address (must be 32 byte aligned) */
+	writel(ch_info->rx_buff_phys[ch_info->rx_curr_buff],
+	       tdm2c->regs + CH_RX_ADDR_REG(ch_info->ch));
+
+	/* Set HW ownership */
+	writeb(OWN_BY_HW,
+	       tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS);
+
+	/* Enable Rx */
+	writeb(CH_ENABLE,
+	       tdm2c->regs + CH_ENABLE_REG(ch_info->ch) + RX_ENABLE_BYTE_OFFS);
+
+	/* Did we get the required amount of irqs for Rx wakeup ? */
+	if (tdm2c->rx_int < MV_TDM_INT_COUNTER)
+		return -EBUSY;
+
+	tdm2c->rx_int = 0;
+	tdm2c->rx_full = MV_TDM_PREV_BUFFER(ch_info->rx_curr_buff, 2);
+	dev_dbg(tdm2c->dev, "buff %d is FULL for ch0/1\n", tdm2c->rx_full);
+
+	return 0;
+}
+
+static int tdm2c_ch_remove(u8 ch)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 buff;
+
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
+
+	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
+		dev_err(tdm2c->dev, "%s: channel(%d) exceeds maximum(%d)\n",
+			__func__, ch, MV_TDM2C_TOTAL_CHANNELS);
+		return -EINVAL;
+	}
+
+	ch_info = tdm2c->ch_info[ch];
+
+	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+		dma_free_coherent(tdm2c->dev,
+				  MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+				  tdm2c->band_mode, tdm2c->factor),
+				  ch_info->rx_buff_virt[buff],
+				  (dma_addr_t)ch_info->rx_buff_phys[buff]);
+		dma_free_coherent(tdm2c->dev,
+				  MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+				  tdm2c->band_mode, tdm2c->factor),
+				  ch_info->tx_buff_virt[buff],
+				  (dma_addr_t)ch_info->tx_buff_phys[buff]);
+	}
+
+	kfree(ch_info);
+
+	return 0;
+}
+
+static void tdm2c_reset(void)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 buff, ch;
+
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
+
+	/* Reset globals */
+	tdm2c->rx_int = 0;
+	tdm2c->tx_int = 0;
+	tdm2c->rx_full = BUFF_INVALID;
+	tdm2c->tx_empty = BUFF_INVALID;
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm2c->ch_info[ch];
+		ch_info->rx_first = FIRST_INT;
+		ch_info->tx_curr_buff = ch_info->rx_curr_buff = 0;
+		for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+			ch_info->rx_buff_full[buff] = BUFF_IS_EMPTY;
+			ch_info->tx_buff_empty[buff] = BUFF_IS_FULL;
+
+		}
+	}
+}
+
+int tdm2c_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdm_params,
+	       enum mv_phone_frame_ts frame_ts,
+	       bool spi_daisy_chain_mode, bool use_pclk_external)
+{
+	u32 pcm_ctrl_reg, nb_delay = 0, wb_delay = 0;
+	u32 ch_delay[4] = { 0, 0, 0, 0 };
+	int ret;
+	u8 ch;
+
+	/* Initialize or reset main structure */
+	if (!tdm2c) {
+		tdm2c = devm_kzalloc(dev, sizeof(struct tdm2c_dev), GFP_KERNEL);
+		if (!tdm2c)
+			return -ENOMEM;
+	} else {
+		memset(tdm2c, 0,  sizeof(struct tdm2c_dev));
+	}
+
+	/* Initialize remaining parameters */
+	tdm2c->regs = base;
+	tdm2c->pcm_format = tdm_params->pcm_format;
+	tdm2c->rx_full = BUFF_INVALID;
+	tdm2c->tx_empty = BUFF_INVALID;
+	tdm2c->dev = dev;
+
+	dev_info(dev, "TDM dual channel device rev 0x%x\n",
+		 readl(tdm2c->regs + TDM_REV_REG));
+
+	if (tdm_params->sampling_period > MV_TDM_MAX_SAMPLING_PERIOD)
+		/* Use base sample period(10ms) */
+		tdm2c->factor = 1;
+	else
+		tdm2c->factor =
+		    tdm_params->sampling_period / MV_TDM_BASE_SAMPLING_PERIOD;
+
+	/* Extract pcm format & band mode */
+	if (tdm2c->pcm_format == MV_PCM_FORMAT_4BYTES) {
+		tdm2c->pcm_format = MV_PCM_FORMAT_2BYTES;
+		tdm2c->band_mode = MV_WIDE_BAND;
+	} else {
+		tdm2c->band_mode = MV_NARROW_BAND;
+	}
+
+	/* Allocate aggregated buffers for data transport */
+	dev_dbg(tdm2c->dev, "allocate %d bytes for aggregated buffer\n",
+		MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+		tdm2c->band_mode, tdm2c->factor));
+	tdm2c->rx_aggr_buff_virt = alloc_pages_exact(
+			MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+			tdm2c->band_mode, tdm2c->factor), GFP_KERNEL);
+	tdm2c->tx_aggr_buff_virt = alloc_pages_exact(
+			MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+			tdm2c->band_mode, tdm2c->factor), GFP_KERNEL);
+	if (!tdm2c->rx_aggr_buff_virt || !tdm2c->tx_aggr_buff_virt) {
+		dev_err(tdm2c->dev, "%s: Error malloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* Clear buffers */
+	memset(tdm2c->rx_aggr_buff_virt, 0,
+	       MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+	       tdm2c->band_mode, tdm2c->factor));
+	memset(tdm2c->tx_aggr_buff_virt, 0,
+	       MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+	       tdm2c->band_mode, tdm2c->factor));
+
+	/* Calculate CH(0/1) Delay Control for narrow/wideband modes */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		nb_delay = ((tdm_params->pcm_slot[ch] * PCM_SLOT_PCLK) + 1);
+		/* Offset required by ZARLINK VE880 SLIC */
+		wb_delay = (nb_delay + ((frame_ts / 2) * PCM_SLOT_PCLK));
+		ch_delay[ch] = ((nb_delay << CH_RX_DELAY_OFFS) |
+				(nb_delay << CH_TX_DELAY_OFFS));
+		ch_delay[(ch + 2)] = ((wb_delay << CH_RX_DELAY_OFFS) |
+				      (wb_delay << CH_TX_DELAY_OFFS));
+	}
+
+	/* Enable TDM/SPI interface */
+	mv_phone_reset_bit(tdm2c->regs + TDM_SPI_MUX_REG, 0x00000001);
+	/* Interrupt cause is not clear on read */
+	writel(CLEAR_ON_ZERO, tdm2c->regs + INT_RESET_SELECT_REG);
+	/* All interrupt bits latched in status */
+	writel(0x3ffff, tdm2c->regs + INT_EVENT_MASK_REG);
+	/* Disable interrupts */
+	writel(0, tdm2c->regs + INT_STATUS_MASK_REG);
+	/* Clear int status register */
+	writel(0, tdm2c->regs + INT_STATUS_REG);
+
+	/* Bypass clock divider - PCM PCLK freq */
+	writel(PCM_DIV_PASS, tdm2c->regs + PCM_CLK_RATE_DIV_REG);
+
+	/* Padding on Rx completion */
+	writel(0, tdm2c->regs + DUMMY_RX_WRITE_DATA_REG);
+	writeb(readl(tdm2c->regs + SPI_GLOBAL_CTRL_REG) | SPI_GLOBAL_ENABLE,
+	       tdm2c->regs + SPI_GLOBAL_CTRL_REG);
+	/* SPI SCLK freq */
+	writel(SPI_CLK_2MHZ, tdm2c->regs + SPI_CLK_PRESCALAR_REG);
+	/* Number of timeslots (PCLK) */
+	writel((u32)frame_ts, tdm2c->regs + FRAME_TIMESLOT_REG);
+
+	if (tdm2c->band_mode == MV_NARROW_BAND) {
+		pcm_ctrl_reg = (CONFIG_PCM_CRTL |
+			 (((u8)tdm2c->pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
+
+		if (use_pclk_external)
+			pcm_ctrl_reg |= MASTER_PCLK_EXTERNAL;
+
+		/* PCM configuration */
+		writel(pcm_ctrl_reg, tdm2c->regs + PCM_CTRL_REG);
+		/* CH0 delay control register */
+		writel(ch_delay[0], tdm2c->regs + CH_DELAY_CTRL_REG(0));
+		/* CH1 delay control register */
+		writel(ch_delay[1], tdm2c->regs + CH_DELAY_CTRL_REG(1));
+	} else {		/* MV_WIDE_BAND */
+
+		pcm_ctrl_reg = (CONFIG_WB_PCM_CRTL |
+			 (((u8)tdm2c->pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
+
+		if (use_pclk_external)
+			pcm_ctrl_reg |= MASTER_PCLK_EXTERNAL;
+
+		/* PCM configuration - WB support */
+		writel(pcm_ctrl_reg, tdm2c->regs + PCM_CTRL_REG);
+		/* CH0 delay control register */
+		writel(ch_delay[0], tdm2c->regs + CH_DELAY_CTRL_REG(0));
+		/* CH1 delay control register */
+		writel(ch_delay[1], tdm2c->regs + CH_DELAY_CTRL_REG(1));
+		/* CH0 WB delay control register */
+		writel(ch_delay[2], tdm2c->regs + CH_WB_DELAY_CTRL_REG(0));
+		/* CH1 WB delay control register */
+		writel(ch_delay[3], tdm2c->regs + CH_WB_DELAY_CTRL_REG(1));
+	}
+
+	/* Issue reset to codec(s) */
+	dev_dbg(tdm2c->dev, "resetting voice unit(s)\n");
+	writel(0, tdm2c->regs + MISC_CTRL_REG);
+	mdelay(1);
+	writel(1, tdm2c->regs + MISC_CTRL_REG);
+
+	if (spi_daisy_chain_mode) {
+		/* Configure TDM to work in daisy chain mode */
+		tdm2c_daisy_chain_mode_set();
+	}
+
+	/* Initialize all HW units */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ret = tdm2c_ch_init(ch);
+		if (ret) {
+			dev_err(tdm2c->dev, "tdm2c_ch_init(%d) failed !\n", ch);
+			return ret;
+		}
+	}
+
+	/* Enable SLIC/DAA interrupt detection(before pcm is active) */
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
+
+	return 0;
+}
+
+void tdm2c_release(void)
+{
+	u8 ch;
+
+	/* Free Rx/Tx aggregated buffers */
+	free_pages_exact(tdm2c->rx_aggr_buff_virt,
+			 MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+			 tdm2c->band_mode, tdm2c->factor));
+	free_pages_exact(tdm2c->tx_aggr_buff_virt,
+			 MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format,
+			 tdm2c->band_mode, tdm2c->factor));
+
+	/* Release HW channel resources */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++)
+		tdm2c_ch_remove(ch);
+
+	/* Disable TDM/SPI interface */
+	mv_phone_set_bit(tdm2c->regs + TDM_SPI_MUX_REG, 0x00000001);
+}
+
+void tdm2c_pcm_start(void)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 ch;
+
+	/* TDM is enabled */
+	tdm2c->enable = true;
+	tdm2c->int_lock = false;
+	tdm2c->chan_stop_count = 0;
+	tdm2c_reset();
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm2c->ch_info[ch];
+
+		/* Set Tx buff */
+		writel(ch_info->tx_buff_phys[ch_info->tx_curr_buff],
+		       tdm2c->regs + CH_TX_ADDR_REG(ch));
+		writeb(OWN_BY_HW,
+		       tdm2c->regs + CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS);
+
+		/* Set Rx buff */
+		writel(ch_info->rx_buff_phys[ch_info->rx_curr_buff],
+		       tdm2c->regs + CH_RX_ADDR_REG(ch));
+		writeb(OWN_BY_HW,
+		       tdm2c->regs + CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS);
+
+	}
+
+	/* Enable Tx */
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(0) + TX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(1) + TX_ENABLE_BYTE_OFFS);
+
+	/* Enable Rx */
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(0) + RX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(1) + RX_ENABLE_BYTE_OFFS);
+
+	/* Enable Tx interrupts */
+	writel(readl(tdm2c->regs + INT_STATUS_REG) & (~(TDM_INT_TX(0) |
+	       TDM_INT_TX(1))), tdm2c->regs + INT_STATUS_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_TX(0) |
+	       TDM_INT_TX(1)), tdm2c->regs + INT_STATUS_MASK_REG);
+
+	/* Enable Rx interrupts */
+	writel((readl(tdm2c->regs + INT_STATUS_REG) & (~(TDM_INT_RX(0) |
+	       TDM_INT_RX(1)))), tdm2c->regs + INT_STATUS_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_RX(0) |
+	       TDM_INT_RX(1)), tdm2c->regs + INT_STATUS_MASK_REG);
+}
+
+void tdm2c_pcm_stop(void)
+{
+	tdm2c->enable = false;
+
+	tdm2c_reset();
+}
+
+int tdm2c_tx(u8 *tdm_tx_buff)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 ch;
+	u8 *tx_buff;
+
+	/* Sanity check */
+	if (tdm_tx_buff != tdm2c->tx_aggr_buff_virt) {
+		dev_err(tdm2c->dev, "%s: Error, invalid Tx buffer !!!\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (!tdm2c->enable) {
+		dev_err(tdm2c->dev, "%s: No active Tx channels are available\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (tdm2c->tx_empty == BUFF_INVALID) {
+		dev_err(tdm2c->dev, "%s: Tx not ready\n", __func__);
+		return -EINVAL;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm2c->ch_info[ch];
+		dev_dbg(tdm2c->dev, "ch%d: fill buf %d with %d bytes\n",
+			ch, tdm2c->tx_empty,
+			MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode,
+			tdm2c->factor));
+		ch_info->tx_buff_empty[tdm2c->tx_empty] = BUFF_IS_FULL;
+		tx_buff = tdm_tx_buff +
+			  (ch * MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+			  tdm2c->band_mode, tdm2c->factor));
+
+		/* Copy data from voice engine buffer to DMA */
+		memcpy(ch_info->tx_buff_virt[tdm2c->tx_empty], tx_buff,
+		       MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode,
+		       tdm2c->factor));
+	}
+
+	tdm2c->tx_empty = BUFF_INVALID;
+
+	return 0;
+}
+
+int tdm2c_rx(u8 *tdm_rx_buff)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 ch;
+	u8 *rx_buff;
+
+	/* Sanity check */
+	if (tdm_rx_buff != tdm2c->rx_aggr_buff_virt) {
+		dev_err(tdm2c->dev, "%s: invalid Rx buffer !!!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!tdm2c->enable) {
+		dev_err(tdm2c->dev, "%s: No active Rx channels are available\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (tdm2c->rx_full == BUFF_INVALID) {
+		dev_err(tdm2c->dev, "%s: Rx not ready\n", __func__);
+		return -EINVAL;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm2c->ch_info[ch];
+		ch_info->rx_buff_full[tdm2c->rx_full] = BUFF_IS_EMPTY;
+		dev_dbg(tdm2c->dev, "%s get Rx buffer(%d) for channel(%d)\n",
+			__func__, tdm2c->rx_full, ch);
+		rx_buff = tdm_rx_buff +
+			  (ch * MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format,
+			  tdm2c->band_mode, tdm2c->factor));
+
+		/* Copy data from DMA to voice engine buffer */
+		memcpy(rx_buff, ch_info->rx_buff_virt[tdm2c->rx_full],
+		       MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode,
+		       tdm2c->factor));
+	}
+
+	tdm2c->rx_full = BUFF_INVALID;
+
+	return 0;
+}
+
+int tdm2c_pcm_stop_int_miss(void)
+{
+	u32 status_reg, mask_reg, status_stop_int;
+	u32 status_mask = 0, int_mask = 0;
+
+	status_reg = readl(tdm2c->regs + INT_STATUS_REG);
+	mask_reg = readl(tdm2c->regs + INT_STATUS_MASK_REG);
+
+	/* Refer only to unmasked bits */
+	status_stop_int = status_reg & mask_reg;
+
+	if (status_stop_int & TX_UNDERFLOW_BIT(1)) {
+		status_mask |= TX_UNDERFLOW_BIT(1);
+		int_mask |= TDM_INT_TX(1);
+	}
+
+	if (status_stop_int & TX_UNDERFLOW_BIT(0)) {
+		status_mask |= TX_UNDERFLOW_BIT(0);
+		int_mask |= TDM_INT_TX(0);
+	}
+
+	if (status_stop_int & RX_OVERFLOW_BIT(1)) {
+		status_mask |= RX_OVERFLOW_BIT(1);
+		int_mask |= TDM_INT_RX(1);
+	}
+
+	if (status_stop_int & RX_OVERFLOW_BIT(0)) {
+		status_mask |= TX_UNDERFLOW_BIT(0);
+		int_mask |= TDM_INT_RX(0);
+	}
+
+	if (int_mask != 0) {
+		dev_err(tdm2c->dev, "No Stop Interrupt: STATUS=%x,MASK=%x\n",
+			status_reg, mask_reg);
+		writel(~(status_mask), tdm2c->regs + INT_STATUS_REG);
+		writel(readl(tdm2c->regs + INT_STATUS_MASK_REG) & (~(int_mask)),
+		       tdm2c->regs + INT_STATUS_MASK_REG);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Low level TDM interrupt service routine */
+int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
+{
+	u32 status_reg, mask_reg, status_and_mask;
+	int ret = 0;
+	int int_tx_miss = -1;
+	int int_rx_miss = -1;
+	u8 ch;
+
+	/* Read Status & mask registers */
+	status_reg = readl(tdm2c->regs + INT_STATUS_REG);
+	mask_reg = readl(tdm2c->regs + INT_STATUS_MASK_REG);
+	dev_dbg(tdm2c->dev, "CAUSE(0x%x), MASK(0x%x)\n", status_reg, mask_reg);
+
+	/* Refer only to unmasked bits */
+	status_and_mask = status_reg & mask_reg;
+
+	/* Reset params */
+	tdm_intr_info->tdm_rx_buff = NULL;
+	tdm_intr_info->tdm_tx_buff = NULL;
+	tdm_intr_info->int_type = MV_EMPTY_INT;
+	tdm_intr_info->cs = MV_TDM_CS;
+
+	/* Handle SLIC/DAA int */
+	if (status_and_mask & SLIC_INT_BIT) {
+		dev_dbg(tdm2c->dev, "Phone interrupt !!!\n");
+		tdm_intr_info->int_type |= MV_PHONE_INT;
+	}
+
+	if (status_and_mask & DMA_ABORT_BIT) {
+		dev_err(tdm2c->dev,
+			"DMA data abort. Address: 0x%08x, Info: 0x%08x\n",
+			readl(tdm2c->regs + DMA_ABORT_ADDR_REG),
+			readl(tdm2c->regs + DMA_ABORT_INFO_REG));
+		tdm_intr_info->int_type |= MV_DMA_ERROR_INT;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		/* Give next buff to TDM and set curr buff as empty */
+		if ((status_and_mask & TX_BIT(ch)) && tdm2c->enable &&
+		    !tdm2c->int_lock) {
+			dev_dbg(tdm2c->dev, "Tx interrupt(ch%d)\n", ch);
+
+			tdm2c->int_tx_count++;
+			if (ch == 0) {
+				tdm2c->int_tx0_count++;
+				if (tdm2c->int_tx0_count <=
+				    tdm2c->int_tx1_count) {
+					int_tx_miss = 0;
+					tdm2c->int_tx0_miss++;
+				}
+			} else {
+				tdm2c->int_tx1_count++;
+				if (tdm2c->int_tx1_count <
+				    tdm2c->int_tx0_count) {
+					int_tx_miss = 1;
+					tdm2c->int_tx1_miss++;
+				}
+			}
+
+			/* 0 -> Tx is done for both channels */
+			if (tdm2c_ch_tx_low(ch) == 0) {
+				dev_dbg(tdm2c->dev,
+					"Assign Tx aggregate buffer\n");
+				tdm_intr_info->tdm_tx_buff =
+						       tdm2c->tx_aggr_buff_virt;
+				tdm_intr_info->int_type |= MV_TX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		if ((status_and_mask & RX_BIT(ch)) && tdm2c->enable &&
+		    !tdm2c->int_lock) {
+			dev_dbg(tdm2c->dev, "Rx interrupt(ch%d)\n", ch);
+
+			tdm2c->int_rx_count++;
+			if (ch == 0) {
+				tdm2c->int_rx0_count++;
+				if (tdm2c->int_rx0_count <=
+				    tdm2c->int_rx1_count) {
+					int_rx_miss = 0;
+					tdm2c->int_rx0_miss++;
+				}
+			} else {
+				tdm2c->int_rx1_count++;
+				if (tdm2c->int_rx1_count <
+				    tdm2c->int_rx0_count) {
+					int_rx_miss = 1;
+					tdm2c->int_rx1_miss++;
+				}
+			}
+
+			/* 0 -> Rx is done for both channels */
+			if (tdm2c_ch_rx_low(ch) == 0) {
+				dev_dbg(tdm2c->dev,
+					"Assign Rx aggregate buffer\n");
+				tdm_intr_info->tdm_rx_buff =
+						       tdm2c->rx_aggr_buff_virt;
+				tdm_intr_info->int_type |= MV_RX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		if (status_and_mask & TX_UNDERFLOW_BIT(ch)) {
+
+			dev_dbg(tdm2c->dev, "Tx underflow(ch%d)\n", ch);
+			if (tdm2c->enable) {
+				dev_dbg(tdm2c->dev, "Tx underflow ERROR\n");
+				tdm_intr_info->int_type |= MV_TX_ERROR_INT;
+				if (!(status_and_mask & TX_BIT(ch))) {
+					ret = -1;
+					/* 0 -> Tx is done for both channels */
+					if (tdm2c_ch_tx_low(ch) == 0) {
+						dev_dbg(tdm2c->dev,
+						   "Add Tx aggregate buffer\n");
+						tdm_intr_info->tdm_tx_buff =
+						       tdm2c->tx_aggr_buff_virt;
+						tdm_intr_info->int_type |=
+								      MV_TX_INT;
+					}
+				}
+			} else {
+				dev_dbg(tdm2c->dev, "Expected Tx underflow\n");
+				tdm_intr_info->int_type |= MV_CHAN_STOP_INT;
+				/* Update number of channels already stopped */
+				tdm_intr_info->data = ++tdm2c->chan_stop_count;
+				writel(readl(tdm2c->regs + INT_STATUS_MASK_REG)
+				       & (~(TDM_INT_TX(ch))),
+				       tdm2c->regs + INT_STATUS_MASK_REG);
+			}
+		}
+
+
+		if (status_and_mask & RX_OVERFLOW_BIT(ch)) {
+			dev_dbg(tdm2c->dev, "Rx overflow(ch%d)\n", ch);
+			if (tdm2c->enable) {
+				dev_dbg(tdm2c->dev, "Rx overflow ERROR\n");
+				tdm_intr_info->int_type |= MV_RX_ERROR_INT;
+				if (!(status_and_mask & RX_BIT(ch))) {
+					ret = -1;
+					/* 0 -> Rx is done for both channels */
+					if (tdm2c_ch_rx_low(ch) == 0) {
+						dev_dbg(tdm2c->dev,
+						   "Add Rx aggregate buffer\n");
+						tdm_intr_info->tdm_rx_buff =
+						       tdm2c->rx_aggr_buff_virt;
+						tdm_intr_info->int_type |=
+								      MV_RX_INT;
+					}
+				}
+			} else {
+				dev_dbg(tdm2c->dev, "Expected Rx overflow\n");
+				tdm_intr_info->int_type |= MV_CHAN_STOP_INT;
+				/* Update number of channels already stopped */
+				tdm_intr_info->data = ++tdm2c->chan_stop_count;
+				writel(readl(tdm2c->regs + INT_STATUS_MASK_REG)
+				       & (~(TDM_INT_RX(ch))),
+				       tdm2c->regs + INT_STATUS_MASK_REG);
+			}
+		}
+	}
+
+	/* clear TDM interrupts */
+	writel(~status_reg, tdm2c->regs + INT_STATUS_REG);
+
+	/* Check if interrupt was missed -> restart */
+	if  (int_tx_miss != -1)  {
+		dev_err(tdm2c->dev, "Missing Tx Interrupt Detected ch%d!!!\n",
+			int_tx_miss);
+		if (int_tx_miss)
+			tdm2c->int_tx1_count = tdm2c->int_tx0_count;
+		else
+			tdm2c->int_tx0_count  = (tdm2c->int_tx1_count + 1);
+		ret = -1;
+	}
+
+	if  (int_rx_miss != -1)  {
+		dev_err(tdm2c->dev, "Missing Rx Interrupt Detected ch%d!!!\n",
+			int_rx_miss);
+		if (int_rx_miss)
+			tdm2c->int_rx1_count = tdm2c->int_rx0_count;
+		else
+			tdm2c->int_rx0_count  = (tdm2c->int_rx1_count + 1);
+		ret = -1;
+	}
+
+	if (ret == -1) {
+		tdm2c->int_lock = true;
+		tdm2c->pcm_restart_count++;
+	}
+
+	return ret;
+}
+
+void tdm2c_intr_enable(void)
+{
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
+}
+
+void tdm2c_intr_disable(void)
+{
+	u32 val = ~TDM_INT_SLIC;
+
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) & val),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
+}
+
+void tdm2c_pcm_if_reset(void)
+{
+	/* SW PCM reset assert */
+	mv_phone_reset_bit(tdm2c->regs + TDM_MISC_REG, 0x00000001);
+
+	mdelay(10);
+
+	/* SW PCM reset de-assert */
+	mv_phone_set_bit(tdm2c->regs + TDM_MISC_REG, 0x00000001);
+
+	/* Wait a bit more - might be fine tuned */
+	mdelay(50);
+
+	dev_dbg(tdm2c->dev, "%s: Exit\n", __func__);
+}
+
+/* Debug routines */
+void tdm2c_reg_dump(u32 offset)
+{
+	dev_info(tdm2c->dev, "0x%05x: %08x\n", offset,
+		 readl(tdm2c->regs + offset));
+}
+
+void tdm2c_regs_dump(void)
+{
+	u8 i;
+	struct tdm2c_ch_info *ch_info;
+
+	dev_info(tdm2c->dev, "TDM Control:\n");
+	tdm2c_reg_dump(TDM_SPI_MUX_REG);
+	tdm2c_reg_dump(INT_RESET_SELECT_REG);
+	tdm2c_reg_dump(INT_STATUS_MASK_REG);
+	tdm2c_reg_dump(INT_STATUS_REG);
+	tdm2c_reg_dump(INT_EVENT_MASK_REG);
+	tdm2c_reg_dump(PCM_CTRL_REG);
+	tdm2c_reg_dump(TIMESLOT_CTRL_REG);
+	tdm2c_reg_dump(PCM_CLK_RATE_DIV_REG);
+	tdm2c_reg_dump(FRAME_TIMESLOT_REG);
+	tdm2c_reg_dump(DUMMY_RX_WRITE_DATA_REG);
+	tdm2c_reg_dump(MISC_CTRL_REG);
+	dev_info(tdm2c->dev, "TDM Channel Control:\n");
+	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
+		tdm2c_reg_dump(CH_DELAY_CTRL_REG(i));
+		tdm2c_reg_dump(CH_SAMPLE_REG(i));
+		tdm2c_reg_dump(CH_DBG_REG(i));
+		tdm2c_reg_dump(CH_TX_CUR_ADDR_REG(i));
+		tdm2c_reg_dump(CH_RX_CUR_ADDR_REG(i));
+		tdm2c_reg_dump(CH_ENABLE_REG(i));
+		tdm2c_reg_dump(CH_BUFF_OWN_REG(i));
+		tdm2c_reg_dump(CH_TX_ADDR_REG(i));
+		tdm2c_reg_dump(CH_RX_ADDR_REG(i));
+	}
+	dev_info(tdm2c->dev, "TDM interrupts:\n");
+	tdm2c_reg_dump(INT_EVENT_MASK_REG);
+	tdm2c_reg_dump(INT_STATUS_MASK_REG);
+	tdm2c_reg_dump(INT_STATUS_REG);
+	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
+		dev_info(tdm2c->dev, "ch%d info:\n", i);
+		ch_info = tdm2c->ch_info[i];
+		dev_info(tdm2c->dev, "RX buffs:\n");
+		dev_info(tdm2c->dev, "buff0: virt=%p phys=%p\n",
+			 ch_info->rx_buff_virt[0],
+			 (u32 *)(ch_info->rx_buff_phys[0]));
+		dev_info(tdm2c->dev, "buff1: virt=%p phys=%p\n",
+			 ch_info->rx_buff_virt[1],
+			 (u32 *)(ch_info->rx_buff_phys[1]));
+		dev_info(tdm2c->dev, "TX buffs:\n");
+		dev_info(tdm2c->dev, "buff0: virt=%p phys=%p\n",
+			 ch_info->tx_buff_virt[0],
+			 (u32 *)(ch_info->tx_buff_phys[0]));
+		dev_info(tdm2c->dev, "buff1: virt=%p phys=%p\n",
+			 ch_info->tx_buff_virt[1],
+			 (u32 *)(ch_info->tx_buff_phys[1]));
+	}
+}
+
+void tdm2c_ext_stats_get(struct mv_phone_extended_stats *tdm_ext_stats)
+{
+	tdm_ext_stats->int_rx_count = tdm2c->int_rx_count;
+	tdm_ext_stats->int_tx_count = tdm2c->int_tx_count;
+	tdm_ext_stats->int_rx0_count = tdm2c->int_rx0_count;
+	tdm_ext_stats->int_tx0_count = tdm2c->int_tx0_count;
+	tdm_ext_stats->int_rx1_count = tdm2c->int_rx1_count;
+	tdm_ext_stats->int_tx1_count = tdm2c->int_tx1_count;
+	tdm_ext_stats->int_rx0_miss = tdm2c->int_rx0_miss;
+	tdm_ext_stats->int_tx0_miss = tdm2c->int_tx0_miss;
+	tdm_ext_stats->int_rx1_miss = tdm2c->int_rx1_miss;
+	tdm_ext_stats->int_tx1_miss = tdm2c->int_tx1_miss;
+	tdm_ext_stats->pcm_restart_count = tdm2c->pcm_restart_count;
+}
+
+/* Initialize decoding windows */
+int tdm2c_set_mbus_windows(struct device *dev, void __iomem *regs,
+			   const struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	if (!dram) {
+		dev_err(dev, "no mbus dram info\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < TDM_MBUS_MAX_WIN; i++) {
+		writel(0, regs + TDM_WIN_CTRL_REG(i));
+		writel(0, regs + TDM_WIN_BASE_REG(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+
+		/* Write size, attributes and target id to control register */
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+			regs + TDM_WIN_CTRL_REG(i));
+		/* Write base address to base register */
+		writel(cs->base, regs + TDM_WIN_BASE_REG(i));
+	}
+
+	return 0;
+}
diff --git a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
new file mode 100644
index 000000000000..8e330f8c386e
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _TDM2C_H_
+#define _TDM2C_H_
+
+/************************************************/
+/*        TDM to Mbus Bridge Register Map       */
+/************************************************/
+#define TDM_SPI_MUX_REG		0x4000
+#define TDM_MBUS_CONFIG_REG	0x4010
+#define TDM_MISC_REG		0x4070
+
+/* TDM Control Register Map */
+#define PCM_CTRL_REG		0x00
+#define TIMESLOT_CTRL_REG	0x04
+#define FRAME_TIMESLOT_REG	0x38
+#define PCM_CLK_RATE_DIV_REG	0x3c
+#define INT_EVENT_MASK_REG	0x40
+#define INT_STATUS_MASK_REG	0x48
+#define INT_RESET_SELECT_REG	0x4c
+#define INT_STATUS_REG		0x50
+#define DUMMY_RX_WRITE_DATA_REG 0x54
+#define MISC_CTRL_REG		0x58
+#define TDM_REV_REG		0x74
+#define DMA_ABORT_ADDR_REG	0x80
+#define DMA_ABORT_INFO_REG	0x84
+
+#define CH_WB_DELAY_CTRL_REG(ch)(0x88 | ((ch) << 2))
+#define CH_DELAY_CTRL_REG(ch)	(0x08 | ((ch) << 2))
+#define CH_SAMPLE_REG(ch)	(0x30 | ((ch) << 2))
+#define CH_DBG_REG(ch)		(0x78 | ((ch) << 2))
+#define CH_TX_CUR_ADDR_REG(ch)	(0x60 | ((ch) << 3))
+#define CH_RX_CUR_ADDR_REG(ch)	(0x64 | ((ch) << 3))
+#define CH_ENABLE_REG(ch)	(((ch) + 1) << 4)
+#define CH_RXTX_EN_MASK		0x101
+#define CH_BUFF_OWN_REG(ch)	(0x04 | (((ch) + 1) << 4))
+#define CH_TX_ADDR_REG(ch)	(0x08 | (((ch) + 1) << 4))
+#define CH_RX_ADDR_REG(ch)	(0x0c | (((ch) + 1) << 4))
+
+#define PCM_DIV_PASS	(1 << 6)
+
+/* PCM_CTRL_REG bits */
+#define MASTER_PCLK_OFFS	0
+#define MASTER_PCLK_TDM		(0 << MASTER_PCLK_OFFS)
+#define MASTER_PCLK_EXTERNAL	(1 << MASTER_PCLK_OFFS)
+#define MASTER_FS_OFFS		1
+#define MASTER_FS_TDM		(0 << MASTER_FS_OFFS)
+#define DATA_POLAR_OFFS		2
+#define DATA_POLAR_NEG		(0 << DATA_POLAR_OFFS)
+#define FS_POLAR_OFFS		3
+#define FS_POLAR_NEG		(0 << FS_POLAR_OFFS)
+#define INVERT_FS_OFFS		4
+#define INVERT_FS_HI		(0 << INVERT_FS_OFFS)
+#define FS_TYPE_OFFS		5
+#define FS_TYPE_SHORT		(0 << FS_TYPE_OFFS)
+#define PCM_SAMPLE_SIZE_OFFS	6
+#define CH_DELAY_OFFS		8
+#define CH_DELAY_ENABLE		(3 << CH_DELAY_OFFS)
+#define CH_QUALITY_OFFS		10
+#define CH_QUALITY_DISABLE	(0 << CH_QUALITY_OFFS)
+#define QUALITY_POLARITY_OFFS	12
+#define QUALITY_POLARITY_NEG	(0 << QUALITY_POLARITY_OFFS)
+#define QUALITY_TYPE_OFFS	13
+#define QUALITY_TYPE_TIME_SLOT	(0 << QUALITY_TYPE_OFFS)
+#define CS_CTRL_OFFS		15
+#define CS_CTRL_DONT_CARE	(0 << CS_CTRL_OFFS)
+#define CS_CTRL			(1 << CS_CTRL_OFFS)
+#define WIDEBAND_OFFS		16
+#define WIDEBAND_OFF		(0 << WIDEBAND_OFFS)
+#define WIDEBAND_ON		(3 << WIDEBAND_OFFS)
+#define PERF_GBUS_OFFS		31
+#define PERF_GBUS_TWO_ACCESS	(1 << PERF_GBUS_OFFS)
+
+/* CH_SAMPLE_REG bits */
+#define TOTAL_CNT_OFFS		0
+#define INT_CNT_OFFS		8
+
+/* CH_BUFF_OWN_REG bits */
+#define RX_OWN_BYTE_OFFS	0
+#define TX_OWN_BYTE_OFFS	1
+#define OWNER_MASK		1
+#define OWN_BY_HW		1
+
+/* CH_ENABLE_REG bits */
+#define RX_ENABLE_BYTE_OFFS	0
+#define TX_ENABLE_BYTE_OFFS	1
+#define CH_ENABLE		1
+#define CH_DISABLE		0
+
+/* INT_STATUS_REG bits */
+#define RX_OVERFLOW_BIT(ch)	(1 << (0 + ((ch) * 2)))
+#define TX_UNDERFLOW_BIT(ch)	(1 << (1 + ((ch) * 2)))
+#define RX_BIT(ch)		(1 << (4 + ((ch) * 2)))
+#define TX_BIT(ch)		(1 << (5 + ((ch) * 2)))
+#define RX_IDLE_BIT(ch)		(1 << (8 + ((ch) * 2)))
+#define TX_IDLE_BIT(ch)		(1 << (9 + ((ch) * 2)))
+#define DMA_ABORT_BIT		(1 << 16)
+#define SLIC_INT_BIT		(1 << 17)
+
+/* TDU_INTR_SET_RESET bits */
+#define CLEAR_MODE_OFFS		0
+#define CLEAR_ON_ZERO		(0 << CLEAR_MODE_OFFS)
+
+/* CH_DELAY_CTRL_REG bits */
+#define CH_RX_DELAY_OFFS	0
+#define CH_TX_DELAY_OFFS	16
+
+/* SPI Register Map */
+#define SPI_CLK_PRESCALAR_REG	0x3100
+#define SPI_GLOBAL_CTRL_REG	0x3104
+#define SPI_CTRL_REG		0x3108
+#define SPI_CODEC_CMD_LO_REG	0x3130
+#define SPI_CODEC_CMD_HI_REG	0x3134
+#define SPI_CODEC_CTRL_REG	0x3138
+#define SPI_CODEC_READ_DATA_REG	0x313c
+
+/* SPI CLK_PRESCALAR_REG bits */
+#define SPI_CLK_2MHZ	0x2A64  /* refers to tclk = 200MHz */
+
+/* SPI_CTRL_REG bits */
+#define SPI_STAT_OFFS	10
+#define SPI_STAT_MASK	(1 << SPI_STAT_OFFS)
+#define SPI_ACTIVE	(1 << SPI_STAT_OFFS)
+
+/* SPI_GLOBAL_CTRL_REG bits */
+#define SPI_GLOBAL_ENABLE_OFFS	0
+#define SPI_GLOBAL_ENABLE	(1 << SPI_GLOBAL_ENABLE_OFFS)
+
+/* SPI_CODEC_CTRL_REG bits */
+#define TRANSFER_BYTES_OFFS	0
+#define TRANSFER_BYTES(count)	((count-1) << TRANSFER_BYTES_OFFS)
+#define ENDIANNESS_MODE_OFFS	2
+#define ENDIANNESS_MSB_MODE	(0 << ENDIANNESS_MODE_OFFS)
+#define RD_WR_MODE_OFFS		3
+#define WR_MODE			(0 << RD_WR_MODE_OFFS)
+#define RD_MODE			(1 << RD_WR_MODE_OFFS)
+#define READ_BYTES_OFFS		4
+#define READ_1_BYTE		(0 << READ_BYTES_OFFS)
+#define READ_2_BYTE		(1 << READ_BYTES_OFFS)
+#define CLK_SPEED_OFFS		5
+#define CLK_SPEED_LO_DIV	(0 << CLK_SPEED_OFFS)
+
+/* TDM Address Decoding */
+#define TDM_MBUS_MAX_WIN	4
+#define TDM_WIN_CTRL_REG(win)	(0x4030 + (win<<4))
+#define TDM_WIN_BASE_REG(win)	(0x4034 + (win<<4))
+
+/* Defines */
+#define SAMPLES_BUFF_SIZE(band_mode, factor)  \
+	 ((band_mode == MV_NARROW_BAND) ? (factor * 80) : (factor * 160))
+
+#define MV_TDM_CH_BUFF_SIZE(pcm_format, band_mode, factor)	\
+	(pcm_format == MV_PCM_FORMAT_2BYTES ?			\
+	(2 * SAMPLES_BUFF_SIZE(band_mode, factor)) :		\
+	SAMPLES_BUFF_SIZE(band_mode, factor))
+
+#define MV_TDM_AGGR_BUFF_SIZE(pcm_format, band_mode, factor)	\
+	(2 * MV_TDM_CH_BUFF_SIZE(pcm_format, band_mode, factor))
+#define MV_TDM2C_TOTAL_CHANNELS			2
+#define MV_TDM_INT_COUNTER			2
+#define MV_TDM_MAX_SAMPLING_PERIOD		30	/* ms */
+#define MV_TDM_BASE_SAMPLING_PERIOD		10	/* ms */
+#define MV_TDM_TOTAL_CH_SAMPLES			80	/* samples */
+#define MV_TDM_STOP_POLLING_TIMEOUT		30	/* ms */
+
+/* TDM IRQ types */
+#define MV_EMPTY_INT		0
+#define MV_RX_INT		0x00000001
+#define	MV_TX_INT		0x00000002
+#define	MV_PHONE_INT		0x00000004
+#define	MV_RX_ERROR_INT		0x00000008
+#define	MV_TX_ERROR_INT		0x00000010
+#define MV_DMA_ERROR_INT	0x00000020
+#define MV_CHAN_STOP_INT	0x00000040
+#define MV_ERROR_INT		(MV_RX_ERROR_INT | MV_TX_ERROR_INT |\
+				 MV_DMA_ERROR_INT)
+
+/* PCM SLOT configuration */
+#define PCM_SLOT_PCLK	8
+
+#define TDM_INT_SLIC	(DMA_ABORT_BIT | SLIC_INT_BIT)
+#define TDM_INT_TX(ch)	(TX_UNDERFLOW_BIT(ch) | TX_BIT(ch) | TX_IDLE_BIT(ch))
+#define TDM_INT_RX(ch)	(RX_OVERFLOW_BIT(ch) | RX_BIT(ch) | RX_IDLE_BIT(ch))
+
+/* TDM Registers Configuration */
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_PCM_CRTL (MASTER_PCLK_EXTERNAL | MASTER_FS_TDM |		\
+			 DATA_POLAR_NEG | FS_POLAR_NEG | INVERT_FS_HI |	\
+			 FS_TYPE_SHORT | CH_DELAY_ENABLE |		\
+			 CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG |	\
+			 QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |	\
+			 WIDEBAND_OFF | PERF_GBUS_TWO_ACCESS)
+
+#else
+#define CONFIG_PCM_CRTL (MASTER_PCLK_TDM | MASTER_FS_TDM |		\
+			 DATA_POLAR_NEG | FS_POLAR_NEG | INVERT_FS_HI |	\
+			 FS_TYPE_SHORT | CH_DELAY_ENABLE |		\
+			 CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG |	\
+			 QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |	\
+			 WIDEBAND_OFF | PERF_GBUS_TWO_ACCESS)
+#endif
+
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_WB_PCM_CRTL (MASTER_PCLK_EXTERNAL | MASTER_FS_TDM |	\
+			    DATA_POLAR_NEG | FS_POLAR_NEG |		\
+			    INVERT_FS_HI | FS_TYPE_SHORT	 |	\
+			    CH_DELAY_ENABLE | CH_QUALITY_DISABLE |	\
+			    QUALITY_POLARITY_NEG |			\
+			    QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |\
+			    WIDEBAND_ON | PERF_GBUS_TWO_ACCESS)
+#else
+#define CONFIG_WB_PCM_CRTL (MASTER_PCLK_TDM | MASTER_FS_TDM |		\
+			    DATA_POLAR_NEG | FS_POLAR_NEG |		\
+			    INVERT_FS_HI | FS_TYPE_SHORT |		\
+			    CH_DELAY_ENABLE | CH_QUALITY_DISABLE |	\
+			    QUALITY_POLARITY_NEG |			\
+			    QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |\
+			    WIDEBAND_ON | PERF_GBUS_TWO_ACCESS)
+#endif
+
+#define CONFIG_CH_SAMPLE(bandMode, factor)	\
+	((SAMPLES_BUFF_SIZE(bandMode, factor)<<TOTAL_CNT_OFFS) |	\
+	(INT_SAMPLE<<INT_CNT_OFFS))
+
+/* Defines */
+#define INT_SAMPLE			2
+#define BUFF_IS_FULL			1
+#define BUFF_IS_EMPTY			0
+#define FIRST_INT			1
+#define TOTAL_BUFFERS			2
+#define MV_TDM_NEXT_BUFFER(buf)		((buf + 1) % TOTAL_BUFFERS)
+#define MV_TDM_PREV_BUFFER(buf, step)	((TOTAL_BUFFERS + buf - step) %	\
+					 TOTAL_BUFFERS)
+#define MV_TDM_CS			0
+#define BUFF_INVALID			-1
+
+/* TDM channel info structure */
+struct tdm2c_ch_info {
+	u8 ch;
+	u8 *rx_buff_virt[TOTAL_BUFFERS];
+	u8 *tx_buff_virt[TOTAL_BUFFERS];
+	dma_addr_t rx_buff_phys[TOTAL_BUFFERS];
+	dma_addr_t tx_buff_phys[TOTAL_BUFFERS];
+	u8 rx_buff_full[TOTAL_BUFFERS];
+	u8 tx_buff_empty[TOTAL_BUFFERS];
+	u8 rx_curr_buff;
+	u8 tx_curr_buff;
+	u8 rx_first;
+};
+
+/* APIs */
+void tdm2c_release(void);
+int tdm2c_pcm_stop_int_miss(void);
+void tdm2c_pcm_start(void);
+void tdm2c_pcm_stop(void);
+int tdm2c_tx(u8 *tdmTxBuff);
+int tdm2c_rx(u8 *tdmRxBuff);
+void tdm2c_regs_dump(void);
+void tdm2c_intr_enable(void);
+void tdm2c_intr_disable(void);
+void tdm2c_pcm_if_reset(void);
+int tdm2c_set_mbus_windows(struct device *dev, void __iomem *regs,
+			   const struct mbus_dram_target_info *dram);
+
+#endif /* _TDM2C_H_ */
diff --git a/drivers/telephony/mvebu_phone/tdmmc/tdmmc.c b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.c
new file mode 100644
index 000000000000..04a904936435
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.c
@@ -0,0 +1,1066 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include "mv_phone.h"
+
+/* Globals */
+static struct tdmmc_dram_entry def_dpram_entry = {
+					0, 0, 0x1, 0x1, 0, 0, 0x1, 0, 0, 0, 0 };
+static struct tdmmc_dev *tdmmc;
+
+static void tdmmc_desc_init(u32 chan, u32 index, u32 buff_size)
+{
+	/* Associate data buffers to descriptors physBuffPtr */
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[index] + chan))->phys_buff_ptr =
+			(u32) (tdmmc->rx_buff_phys[index] + (chan * buff_size));
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[index] + chan))->phys_buff_ptr =
+			 (u32)(tdmmc->tx_buff_phys[index] + (chan * buff_size));
+
+	/* Build cyclic descriptors chain for each channel */
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[index] + chan))->phys_next_desc_ptr =
+		       (u32)(tdmmc->rx_desc_phys[((index + 1) % TOTAL_CHAINS)] +
+		       (chan * sizeof(struct tdmmc_mcdma_rx_desc)));
+
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[index] + chan))->phys_next_desc_ptr =
+		       (u32)(tdmmc->tx_desc_phys[((index + 1) % TOTAL_CHAINS)] +
+		       (chan * sizeof(struct tdmmc_mcdma_tx_desc)));
+
+	/* Set Byte_Count/Buffer_Size Rx descriptor fields */
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[index] + chan))->byte_cnt = 0;
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[index] + chan))->buff_size = buff_size;
+
+	/* Set Shadow_Byte_Count/Byte_Count Tx descriptor fields */
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[index] + chan))->shadow_byte_cnt = buff_size;
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[index] + chan))->byte_cnt = buff_size;
+
+	/* Set Command/Status Rx/Tx descriptor fields */
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[index] + chan))->cmd_status =
+						 (CONFIG_MCDMA_DESC_CMD_STATUS);
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[index] + chan))->cmd_status =
+						 (CONFIG_MCDMA_DESC_CMD_STATUS);
+}
+
+static void tdmmc_desc_chain_build(void)
+{
+	u32 chan, index, buff_size;
+
+	/* Calculate single Rx/Tx buffer size */
+	buff_size = (tdmmc->sample_size * MV_TDM_TOTAL_CH_SAMPLES *
+		     tdmmc->sampling_coeff);
+
+	/* Initialize descriptors fields */
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		for (index = 0; index < TOTAL_CHAINS; index++)
+			tdmmc_desc_init(chan, index, buff_size);
+	}
+}
+
+static void tdmmc_mcdma_mcsc_start(void)
+{
+	u32 chan;
+	dma_addr_t rx_desc_phys_addr, tx_desc_phys_addr;
+
+	tdmmc_desc_chain_build();
+
+	/* Set current Rx/Tx descriptors  */
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		rx_desc_phys_addr = tdmmc->rx_desc_phys[0] +
+				    (chan * sizeof(struct tdmmc_mcdma_rx_desc));
+		tx_desc_phys_addr = tdmmc->tx_desc_phys[0] +
+				    (chan * sizeof(struct tdmmc_mcdma_tx_desc));
+		writel(rx_desc_phys_addr,
+		       tdmmc->regs + MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan));
+		writel(tx_desc_phys_addr,
+		       tdmmc->regs + MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan));
+	}
+
+	/* Restore MCDMA Rx/Tx control registers */
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		/* Set RMCCx */
+		writel(CONFIG_RMCCx,
+		       tdmmc->regs + MCDMA_RECEIVE_CONTROL_REG(chan));
+
+		/* Set TMCCx */
+		writel(CONFIG_TMCCx,
+		       tdmmc->regs + MCDMA_TRANSMIT_CONTROL_REG(chan));
+	}
+
+	/* Set Rx/Tx periodical interrupts */
+	if (tdmmc->ip_ver == TDMMC_REV0)
+		writel(CONFIG_VOICE_PERIODICAL_INT_CONTROL_WA,
+		       tdmmc->regs + VOICE_PERIODICAL_INT_CONTROL_REG);
+	else
+		writel(CONFIG_VOICE_PERIODICAL_INT_CONTROL,
+		       tdmmc->regs + VOICE_PERIODICAL_INT_CONTROL_REG);
+
+	/* MCSC Global Tx Enable */
+	if (!tdmmc->tdm_enable)
+		mv_phone_set_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+				 MCSC_GLOBAL_CONFIG_TXEN_MASK);
+
+	/* Enable MCSC-Tx & MCDMA-Rx */
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		/* Enable Tx in TMCCx */
+		if (!tdmmc->tdm_enable)
+			mv_phone_set_bit(tdmmc->regs +
+					 MCSC_CHx_TRANSMIT_CONFIG_REG(chan),
+					 MTCRx_ET_MASK);
+
+		/* Enable Rx in: MCRDPx */
+		mv_phone_set_bit(tdmmc->regs + MCDMA_RECEIVE_CONTROL_REG(chan),
+				 MCDMA_ERD_MASK);
+	}
+
+	/* MCSC Global Rx Enable */
+	if (!tdmmc->tdm_enable)
+		mv_phone_set_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+				 MCSC_GLOBAL_CONFIG_RXEN_MASK);
+
+	/* Enable MCSC-Rx & MCDMA-Tx */
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		/* Enable Rx in RMCCx */
+		if (!tdmmc->tdm_enable)
+			mv_phone_set_bit(tdmmc->regs +
+					 MCSC_CHx_RECEIVE_CONFIG_REG(chan),
+					 MRCRx_ER_MASK);
+
+		/* Enable Tx in MCTDPx */
+		mv_phone_set_bit(tdmmc->regs + MCDMA_TRANSMIT_CONTROL_REG(chan),
+				 MCDMA_TXD_MASK);
+	}
+
+	/* Disable Rx/Tx return to half */
+	mv_phone_reset_bit(tdmmc->regs + FLEX_TDM_CONFIG_REG,
+			   (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	udelay(200);
+}
+
+static void tdmmc_mcdma_mcsc_abort(void)
+{
+	u32 chan;
+
+	/* Abort MCSC/MCDMA in case we got here from tdmmc_release() */
+	if (!tdmmc->tdm_enable) {
+		/* Clear MCSC Rx/Tx channel enable */
+		for (chan = 0; chan < tdmmc->total_channels; chan++) {
+			mv_phone_reset_bit(tdmmc->regs +
+					   MCSC_CHx_RECEIVE_CONFIG_REG(chan),
+					   MRCRx_ER_MASK);
+			mv_phone_reset_bit(tdmmc->regs +
+					   MCSC_CHx_TRANSMIT_CONFIG_REG(chan),
+					   MTCRx_ET_MASK);
+		}
+
+		/* MCSC Global Rx/Tx Disable */
+		mv_phone_reset_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+				   MCSC_GLOBAL_CONFIG_RXEN_MASK);
+		mv_phone_reset_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+				   MCSC_GLOBAL_CONFIG_TXEN_MASK);
+	}
+}
+
+static void tdmmc_mcdma_clear_rx_desc(u32 next_rx_buff, u32 chan)
+{
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[next_rx_buff] + chan))->phys_next_desc_ptr = 0;
+	((struct tdmmc_mcdma_rx_desc *)
+	 (tdmmc->rx_desc_virt[next_rx_buff] + chan))->cmd_status =
+							  (LAST_BIT | OWNER);
+}
+
+static void tdmmc_mcdma_clear_tx_desc(u32 next_tx_buff, u32 chan)
+{
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[next_tx_buff] + chan))->phys_next_desc_ptr = 0;
+	((struct tdmmc_mcdma_tx_desc *)
+	 (tdmmc->tx_desc_virt[next_tx_buff] + chan))->cmd_status =
+							  (LAST_BIT | OWNER);
+}
+
+static void tdmmc_mcdma_stop(void)
+{
+	u32 index, chan, max_poll;
+	u32 curr_rx_desc, curr_tx_desc, next_tx_buff = 0, next_rx_buff = 0;
+
+	/***************************/
+	/*    Stop MCDMA - Rx/Tx   */
+	/***************************/
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		curr_rx_desc = readl(tdmmc->regs +
+				     MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (curr_rx_desc == (tdmmc->rx_desc_phys[index] +
+			    (chan * (sizeof(struct tdmmc_mcdma_rx_desc))))) {
+				next_rx_buff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			dev_err(tdmmc->dev,
+				"%s: No Rx descriptor match for chan(%d)\n",
+				__func__, chan);
+			break;
+		}
+
+		tdmmc_mcdma_clear_rx_desc(next_rx_buff, chan);
+	}
+
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		curr_tx_desc = readl(tdmmc->regs +
+				     MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (curr_tx_desc == (tdmmc->tx_desc_phys[index] +
+			    (chan * (sizeof(struct tdmmc_mcdma_tx_desc))))) {
+				next_tx_buff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			dev_err(tdmmc->dev,
+				"%s: No Tx descriptor match for chan(%d)\n",
+				__func__, chan);
+			return;
+		}
+
+		tdmmc_mcdma_clear_tx_desc(next_tx_buff, chan);
+	}
+
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		max_poll = 0;
+		while ((max_poll < MAX_POLL_USEC) &&
+		       (readl(tdmmc->regs + MCDMA_TRANSMIT_CONTROL_REG(chan)) &
+		       MCDMA_TXD_MASK)) {
+			udelay(1);
+			max_poll++;
+		}
+
+		if (max_poll >= MAX_POLL_USEC) {
+			dev_err(tdmmc->dev,
+				"%s: MCDMA TXD polling timeout(ch%d)\n",
+				__func__, chan);
+			return;
+		}
+
+		max_poll = 0;
+		while ((max_poll < MAX_POLL_USEC) &&
+		       (readl(tdmmc->regs + MCDMA_RECEIVE_CONTROL_REG(chan)) &
+		       MCDMA_ERD_MASK)) {
+			udelay(1);
+			max_poll++;
+		}
+
+		if (max_poll >= MAX_POLL_USEC) {
+			dev_err(tdmmc->dev,
+				"%s: MCDMA ERD polling timeout(ch%d)\n",
+				__func__, chan);
+			return;
+		}
+	}
+
+	/* Disable Rx/Tx periodical interrupts */
+	writel(0xffffffff, tdmmc->regs + VOICE_PERIODICAL_INT_CONTROL_REG);
+
+	/* Enable Rx/Tx return to half */
+	mv_phone_set_bit(tdmmc->regs + FLEX_TDM_CONFIG_REG,
+			 (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	udelay(200);
+
+	/* Manual reset to channel-balancing mechanism */
+	mv_phone_set_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+			 MCSC_GLOBAL_CONFIG_MAI_MASK);
+	udelay(1);
+}
+
+void tdmmc_intr_enable(u8 device_id)
+{
+}
+
+void tdmmc_intr_disable(u8 device_id)
+{
+}
+
+void tdmmc_show(void)
+{
+	u32 index;
+
+	/* Dump data buffers & descriptors addresses */
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		dev_dbg(tdmmc->dev, "Rx Buff(%d): virt = 0x%lx, phys = 0x%lx\n",
+			index, (ulong)tdmmc->rx_buff_virt[index],
+			(ulong)tdmmc->rx_buff_phys[index]);
+		dev_dbg(tdmmc->dev, "Tx Buff(%d): virt = 0x%lx, phys = 0x%lx\n",
+			index, (ulong)tdmmc->tx_buff_virt[index],
+			(ulong)tdmmc->tx_buff_phys[index]);
+		dev_dbg(tdmmc->dev, "Rx Desc(%d): virt = 0x%lx, phys = 0x%lx\n",
+			index, (ulong)tdmmc->rx_desc_virt[index],
+			(ulong) tdmmc->rx_desc_phys[index]);
+		dev_dbg(tdmmc->dev, "Tx Desc(%d): virt = 0x%lx, phys = 0x%lx\n",
+			index, (ulong)tdmmc->tx_desc_virt[index],
+			(ulong)tdmmc->tx_desc_phys[index]);
+	}
+}
+
+int tdmmc_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdm_params,
+	       enum mv_phone_frame_ts frame_ts,
+	       enum tdmmc_ip_version tdmmc_ip_ver)
+{
+	struct tdmmc_dram_entry *act_dpram_entry;
+	u32 buff_size, chan, total_rx_desc_size, total_tx_desc_size;
+	u32 max_poll, clk_sync_ctrl_reg, count;
+	u16 pcm_slot, index;
+	int ret;
+
+	/* Initialize or reset main structure */
+	if (!tdmmc) {
+		tdmmc = devm_kzalloc(dev, sizeof(struct tdmmc_dev), GFP_KERNEL);
+		if (!tdmmc)
+			return -ENOMEM;
+	} else {
+		memset(tdmmc, 0,  sizeof(struct tdmmc_dev));
+	}
+
+	/* Initialize remaining parameters */
+	tdmmc->regs = base;
+	tdmmc->tdm_enable = false;
+	tdmmc->pcm_enable = false;
+	tdmmc->total_channels = tdm_params->total_channels;
+	tdmmc->prev_rx = 0;
+	tdmmc->next_tx = 0;
+	tdmmc->ip_ver = tdmmc_ip_ver;
+	tdmmc->dev = dev;
+
+	/* Check parameters */
+	if ((tdm_params->total_channels > MV_TDMMC_TOTAL_CHANNELS) ||
+	    (tdm_params->sampling_period > MV_TDM_MAX_SAMPLING_PERIOD)) {
+		dev_err(tdmmc->dev, "%s: Error, bad parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Extract sampling period coefficient */
+	tdmmc->sampling_coeff = (tdm_params->sampling_period /
+				 MV_TDM_BASE_SAMPLING_PERIOD);
+
+	tdmmc->sample_size = tdm_params->pcm_format;
+
+	/* Calculate single Rx/Tx buffer size */
+	buff_size = (tdmmc->sample_size * MV_TDM_TOTAL_CH_SAMPLES *
+		     tdmmc->sampling_coeff);
+
+	/* Allocate non-cached data buffers for all channels */
+	dev_dbg(tdmmc->dev,
+		"%s: allocate 0x%x for data buffers total channels = %d\n",
+		__func__, (buff_size * tdmmc->total_channels),
+		tdmmc->total_channels);
+
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		tdmmc->rx_buff_virt[index] = dma_alloc_coherent(tdmmc->dev,
+					      buff_size * tdmmc->total_channels,
+					      &tdmmc->rx_buff_phys[index],
+					      GFP_KERNEL);
+		tdmmc->tx_buff_virt[index] = dma_alloc_coherent(tdmmc->dev,
+					      buff_size * tdmmc->total_channels,
+					      &tdmmc->tx_buff_phys[index],
+					      GFP_KERNEL);
+
+		if (!tdmmc->rx_buff_virt[index] ||
+		    !tdmmc->tx_buff_virt[index]) {
+			ret = -ENOMEM;
+			goto err_buff_virt;
+		}
+	}
+
+	/* Allocate non-cached MCDMA Rx/Tx descriptors */
+	total_rx_desc_size = tdmmc->total_channels *
+			     sizeof(struct tdmmc_mcdma_rx_desc);
+	total_tx_desc_size = tdmmc->total_channels *
+			     sizeof(struct tdmmc_mcdma_tx_desc);
+
+	dev_dbg(dev, "%s: allocate %dB for Rx/Tx descriptors\n",
+		__func__, total_tx_desc_size);
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		tdmmc->rx_desc_virt[index] = dma_alloc_coherent(tdmmc->dev,
+						    total_rx_desc_size,
+						    &tdmmc->rx_desc_phys[index],
+						    GFP_KERNEL);
+		tdmmc->tx_desc_virt[index] = dma_alloc_coherent(tdmmc->dev,
+						    total_tx_desc_size,
+						    &tdmmc->tx_desc_phys[index],
+						    GFP_KERNEL);
+
+		if (!tdmmc->rx_desc_virt[index] ||
+		    !tdmmc->tx_desc_virt[index]) {
+			ret = -ENOMEM;
+			goto err_mcdma_desc;
+		}
+
+		/* Check descriptors alignment */
+		if (((ulong) tdmmc->rx_desc_virt[index] |
+		    (ulong)tdmmc->tx_desc_virt[index]) &
+		    (sizeof(struct tdmmc_mcdma_rx_desc) - 1)) {
+			dev_err(tdmmc->dev,
+				"%s: unaligned MCDMA Rx/Tx descriptors\n",
+				__func__);
+			ret = -ENOMEM;
+			goto err_mcdma_desc;
+		}
+	}
+
+	/* Poll MCDMA for reset completion */
+	max_poll = 0;
+	while ((max_poll < MAX_POLL_USEC) &&
+	       !(readl(tdmmc->regs + MCDMA_GLOBAL_CONTROL_REG) &
+	       MCDMA_RID_MASK)) {
+		udelay(1);
+		max_poll++;
+	}
+
+	if (max_poll >= MAX_POLL_USEC) {
+		dev_err(tdmmc->dev, "MCDMA reset completion timeout\n");
+		ret = -ETIME;
+		goto err_mcdma_desc;
+	}
+
+	/* Poll MCSC for RAM initialization done */
+	if (!(readl(tdmmc->regs + MCSC_GLOBAL_INT_CAUSE_REG) &
+	    MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK)) {
+		max_poll = 0;
+		while ((max_poll < MAX_POLL_USEC) &&
+		       !(readl(tdmmc->regs + MCSC_GLOBAL_INT_CAUSE_REG) &
+		       MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK)) {
+			udelay(1);
+			max_poll++;
+		}
+
+		if (max_poll >= MAX_POLL_USEC) {
+			dev_err(tdmmc->dev,
+				"MCDMA RAM initialization timeout\n");
+			ret = -ETIME;
+			goto err_mcdma_desc;
+		}
+	}
+
+	/***************************************************************/
+	/* MCDMA Configuration(use default MCDMA linked-list settings) */
+	/***************************************************************/
+	/* Set Rx Service Queue Arbiter Weight Register */
+	writel((readl(tdmmc->regs + RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG) &
+	       ~(0x1f << 24)),
+	       tdmmc->regs + RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG);
+
+	/* Set Tx Service Queue Arbiter Weight Register */
+	writel((readl(tdmmc->regs + TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG) &
+	       ~(0x1f << 24)),
+	       tdmmc->regs + TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG);
+
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		/* Set RMCCx */
+		writel(CONFIG_RMCCx,
+		       tdmmc->regs + MCDMA_RECEIVE_CONTROL_REG(chan));
+
+		/* Set TMCCx */
+		writel(CONFIG_TMCCx,
+		       tdmmc->regs + MCDMA_TRANSMIT_CONTROL_REG(chan));
+	}
+
+	/**********************/
+	/* MCSC Configuration */
+	/**********************/
+	/* Disable Rx/Tx channel balancing & Linear mode fix */
+	mv_phone_set_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+			 MCSC_GLOBAL_CONFIG_TCBD_MASK);
+
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		writel(CONFIG_MRCRx,
+		       tdmmc->regs + MCSC_CHx_RECEIVE_CONFIG_REG(chan));
+		writel(CONFIG_MTCRx,
+		       tdmmc->regs + MCSC_CHx_TRANSMIT_CONFIG_REG(chan));
+	}
+
+	/* Enable RX/TX linear byte swap, only in linear mode */
+	if (tdm_params->pcm_format == MV_PCM_FORMAT_1BYTE)
+		writel((readl(tdmmc->regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG) &
+		       (~CONFIG_LINEAR_BYTE_SWAP)),
+		       tdmmc->regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG);
+	else
+		writel((readl(tdmmc->regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG) |
+		       CONFIG_LINEAR_BYTE_SWAP),
+		       tdmmc->regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG);
+
+	/***********************************************/
+	/* Shared Bus to Crossbar Bridge Configuration */
+	/***********************************************/
+	/* Set Timeout Counter Register */
+	writel((readl(tdmmc->regs + TIME_OUT_COUNTER_REG) |
+	       TIME_OUT_THRESHOLD_COUNT_MASK),
+	       tdmmc->regs + TIME_OUT_COUNTER_REG);
+
+	/*************************************************/
+	/* Time Division Multiplexing(TDM) Configuration */
+	/*************************************************/
+	act_dpram_entry = kmalloc(sizeof(struct tdmmc_dram_entry), GFP_KERNEL);
+	if (!act_dpram_entry) {
+		ret = -EINVAL;
+		goto err_mcdma_desc;
+	}
+
+	memcpy(act_dpram_entry, &def_dpram_entry,
+	       sizeof(struct tdmmc_dram_entry));
+
+	/* Set repeat mode bits for (tdmmc->sample_size > 1) */
+	act_dpram_entry->rpt =
+			  ((tdmmc->sample_size == MV_PCM_FORMAT_1BYTE) ? 0 : 1);
+
+	/* Reset all Rx/Tx DPRAM entries to default value */
+	for (index = 0; index < (2 * MV_TDM_MAX_HALF_DPRAM_ENTRIES); index++) {
+		writel(*((u32 *) act_dpram_entry),
+		       tdmmc->regs + FLEX_TDM_RDPR_REG(index));
+		writel(*((u32 *) act_dpram_entry),
+		       tdmmc->regs + FLEX_TDM_TDPR_REG(index));
+	}
+
+	/* Set active Rx/Tx DPRAM entries */
+	for (chan = 0; chan < tdmmc->total_channels; chan++) {
+		/* Same time slot number for both Rx & Tx */
+		pcm_slot = tdm_params->pcm_slot[chan];
+
+		/* Verify time slot is within frame boundries */
+		if (pcm_slot >= frame_ts) {
+			dev_err(tdmmc->dev,
+				"Time slot(%d) exceeded maximum(%d)\n",
+				pcm_slot, frame_ts);
+			ret = -ETIME;
+			goto err_dpram;
+		}
+
+		/* Verify time slot is aligned to sample size */
+		if ((tdmmc->sample_size > MV_PCM_FORMAT_1BYTE) &&
+		    (pcm_slot & 1)) {
+			dev_err(tdmmc->dev,
+				"Time slot(%d) unaligned to PCM sample size\n",
+				pcm_slot);
+			ret = -EINVAL;
+			goto err_dpram;
+		}
+
+		/* Update relevant DPRAM fields */
+		act_dpram_entry->ch = chan;
+		act_dpram_entry->mask = 0xff;
+
+		/* Extract physical DPRAM entry id */
+		index = ((tdmmc->sample_size == MV_PCM_FORMAT_1BYTE) ?
+			 pcm_slot : (pcm_slot / 2));
+
+		/* DPRAM low half */
+		writel(*((u32 *) act_dpram_entry),
+		       tdmmc->regs + FLEX_TDM_RDPR_REG(index));
+		writel(*((u32 *) act_dpram_entry),
+		       tdmmc->regs + FLEX_TDM_TDPR_REG(index));
+
+		/* DPRAM high half(mirroring DPRAM low half) */
+		act_dpram_entry->mask = 0;
+		writel(*((u32 *) act_dpram_entry),
+		       tdmmc->regs + FLEX_TDM_RDPR_REG(
+		       (MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+		writel(*((u32 *) act_dpram_entry),
+		       tdmmc->regs + FLEX_TDM_TDPR_REG(
+		       (MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+
+		/* WideBand mode */
+		if (tdmmc->sample_size == MV_PCM_FORMAT_4BYTES) {
+			index = (index + (frame_ts / tdmmc->sample_size));
+			/* DPRAM low half */
+			act_dpram_entry->mask = 0xff;
+			writel(*((u32 *) act_dpram_entry),
+			       tdmmc->regs + FLEX_TDM_RDPR_REG(index));
+			writel(*((u32 *) act_dpram_entry),
+			       tdmmc->regs + FLEX_TDM_TDPR_REG(index));
+
+			/* DPRAM high half(mirroring DPRAM low half) */
+			act_dpram_entry->mask = 0;
+			writel(*((u32 *) act_dpram_entry),
+			       tdmmc->regs + FLEX_TDM_RDPR_REG(
+			       (MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+			writel(*((u32 *) act_dpram_entry),
+			       tdmmc->regs + FLEX_TDM_TDPR_REG(
+			       (MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+		}
+	}
+
+	/* Fill last Tx/Rx DPRAM entry('LAST'=1) */
+	act_dpram_entry->mask = 0;
+	act_dpram_entry->ch = 0;
+	act_dpram_entry->last = 1;
+
+	/* Index for last entry */
+	if (tdmmc->sample_size == MV_PCM_FORMAT_1BYTE)
+		index = (frame_ts - 1);
+	else
+		index = ((frame_ts / 2) - 1);
+
+	/* Low half */
+	writel(*((u32 *) act_dpram_entry),
+	       tdmmc->regs + FLEX_TDM_TDPR_REG(index));
+	writel(*((u32 *) act_dpram_entry),
+	       tdmmc->regs + FLEX_TDM_RDPR_REG(index));
+
+	/* High half */
+	writel(*((u32 *) act_dpram_entry),
+	       tdmmc->regs + FLEX_TDM_TDPR_REG(
+	       (MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+	writel(*((u32 *) act_dpram_entry),
+	       tdmmc->regs + FLEX_TDM_RDPR_REG(
+	       (MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+
+	/* Set TDM_CLK_AND_SYNC_CONTROL register */
+	clk_sync_ctrl_reg = readl(tdmmc->regs + TDM_CLK_AND_SYNC_CONTROL_REG);
+	clk_sync_ctrl_reg &=
+		 ~(TDM_TX_FSYNC_OUT_ENABLE_MASK | TDM_RX_FSYNC_OUT_ENABLE_MASK |
+		 TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK);
+	clk_sync_ctrl_reg |= CONFIG_TDM_CLK_AND_SYNC_CONTROL;
+	writel(clk_sync_ctrl_reg, tdmmc->regs + TDM_CLK_AND_SYNC_CONTROL_REG);
+
+	/* Set TDM TCR register */
+	writel((readl(tdmmc->regs + FLEX_TDM_CONFIG_REG) |
+	       CONFIG_FLEX_TDM_CONFIG),
+	       tdmmc->regs + FLEX_TDM_CONFIG_REG);
+
+	/**********************************************************************/
+	/* Time Division Multiplexing(TDM) Interrupt Controller Configuration */
+	/**********************************************************************/
+	/* Clear TDM cause and mask registers */
+	writel(0, tdmmc->regs + COMM_UNIT_TOP_MASK_REG);
+	writel(0, tdmmc->regs + TDM_MASK_REG);
+	writel(0, tdmmc->regs + COMM_UNIT_TOP_CAUSE_REG);
+	writel(0, tdmmc->regs + TDM_CAUSE_REG);
+
+	/* Clear MCSC cause and mask registers(except InitDone bit) */
+	writel(0, tdmmc->regs + MCSC_GLOBAL_INT_MASK_REG);
+	writel(0, tdmmc->regs + MCSC_EXTENDED_INT_MASK_REG);
+	writel(MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK,
+	       tdmmc->regs + MCSC_GLOBAL_INT_CAUSE_REG);
+	writel(0, tdmmc->regs + MCSC_EXTENDED_INT_CAUSE_REG);
+
+	/* Set output sync counter bits for FS */
+	count = frame_ts * 8;
+	writel(((count << TDM_SYNC_BIT_RX_OFFS) & TDM_SYNC_BIT_RX_MASK) |
+	       (count & TDM_SYNC_BIT_TX_MASK),
+	       tdmmc->regs + TDM_OUTPUT_SYNC_BIT_COUNT_REG);
+
+	tdmmc_show();
+
+	/* Enable PCM */
+	tdmmc_pcm_start();
+
+	/* Mark TDM I/F as enabled */
+	tdmmc->tdm_enable = true;
+
+	/* Enable PCLK */
+	writel((readl(tdmmc->regs + TDM_DATA_DELAY_AND_CLK_CTRL_REG) |
+	       CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL),
+	       tdmmc->regs + TDM_DATA_DELAY_AND_CLK_CTRL_REG);
+
+	/* Enable TEN for Rev0 controllers */
+	if (tdmmc->ip_ver == TDMMC_REV0)
+		mv_phone_set_bit(tdmmc->regs + FLEX_TDM_CONFIG_REG,
+				 TDM_TEN_MASK);
+
+	dev_dbg(tdmmc->dev, "%s: Exit\n", __func__);
+
+	kfree(act_dpram_entry);
+	return 0;
+
+err_dpram:
+	kfree(act_dpram_entry);
+err_mcdma_desc:
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		if (tdmmc->rx_desc_virt[index])
+			dma_free_coherent(tdmmc->dev, total_rx_desc_size,
+					  tdmmc->rx_desc_virt[index],
+					  tdmmc->rx_desc_phys[index]);
+		if (tdmmc->tx_desc_virt[index])
+			dma_free_coherent(tdmmc->dev, total_tx_desc_size,
+					  tdmmc->tx_desc_virt[index],
+					  tdmmc->tx_desc_phys[index]);
+	}
+err_buff_virt:
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		if (tdmmc->rx_buff_phys[index])
+			dma_free_coherent(tdmmc->dev, buff_size,
+					  tdmmc->rx_buff_virt[index],
+					  tdmmc->rx_buff_phys[index]);
+		if (tdmmc->tx_buff_phys[index])
+			dma_free_coherent(tdmmc->dev, buff_size,
+					  tdmmc->tx_buff_virt[index],
+					  tdmmc->tx_buff_phys[index]);
+	}
+
+	return ret;
+}
+
+void tdmmc_release(void)
+{
+	u32 buff_size, total_rx_desc_size, total_tx_desc_size, index;
+
+	if (tdmmc->tdm_enable) {
+
+		/* Mark TDM I/F as disabled */
+		tdmmc->tdm_enable = false;
+
+		tdmmc_pcm_stop();
+
+		tdmmc_mcdma_mcsc_abort();
+
+		udelay(10);
+		mv_phone_reset_bit(tdmmc->regs + MCSC_GLOBAL_CONFIG_REG,
+				   MCSC_GLOBAL_CONFIG_MAI_MASK);
+
+		/* Disable TEN for Rev0 Controllers */
+		if (tdmmc->ip_ver == TDMMC_REV0)
+			mv_phone_reset_bit(tdmmc->regs + FLEX_TDM_CONFIG_REG,
+					   TDM_TEN_MASK);
+
+		/* Disable PCLK */
+		mv_phone_reset_bit(tdmmc->regs +
+				   TDM_DATA_DELAY_AND_CLK_CTRL_REG,
+				   (TX_CLK_OUT_ENABLE_MASK |
+				    RX_CLK_OUT_ENABLE_MASK));
+
+		/* Calculate total Rx/Tx buffer size */
+		buff_size = (tdmmc->sample_size * MV_TDM_TOTAL_CH_SAMPLES *
+			     tdmmc->sampling_coeff * tdmmc->total_channels);
+
+		/* Calculate total MCDMA Rx/Tx descriptors chain size */
+		total_rx_desc_size = tdmmc->total_channels *
+				     sizeof(struct tdmmc_mcdma_rx_desc);
+		total_tx_desc_size = tdmmc->total_channels *
+				     sizeof(struct tdmmc_mcdma_tx_desc);
+
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Release Rx/Tx data buffers */
+			dma_free_coherent(tdmmc->dev, buff_size,
+					  tdmmc->rx_buff_virt[index],
+					  tdmmc->rx_buff_phys[index]);
+			dma_free_coherent(tdmmc->dev, buff_size,
+					  tdmmc->tx_buff_virt[index],
+					  tdmmc->tx_buff_phys[index]);
+
+			/* Release MCDMA Rx/Tx descriptors */
+			dma_free_coherent(tdmmc->dev, total_rx_desc_size,
+					  tdmmc->rx_desc_virt[index],
+					  tdmmc->rx_desc_phys[index]);
+			dma_free_coherent(tdmmc->dev, total_tx_desc_size,
+					  tdmmc->tx_desc_virt[index],
+					  tdmmc->tx_desc_phys[index]);
+		}
+	}
+}
+
+void tdmmc_pcm_start(void)
+{
+	u32 mask_reg;
+
+	if (!tdmmc->pcm_enable) {
+
+		/* Mark PCM I/F as enabled  */
+		tdmmc->pcm_enable = true;
+
+		tdmmc_mcdma_mcsc_start();
+
+		/* Clear TDM cause and mask registers */
+		writel(0, tdmmc->regs + COMM_UNIT_TOP_MASK_REG);
+		writel(0, tdmmc->regs + TDM_MASK_REG);
+		writel(0, tdmmc->regs + COMM_UNIT_TOP_CAUSE_REG);
+		writel(0, tdmmc->regs + TDM_CAUSE_REG);
+
+		/* Clear MCSC cause and mask registers(except InitDone bit) */
+		writel(0, tdmmc->regs + MCSC_GLOBAL_INT_MASK_REG);
+		writel(0, tdmmc->regs + MCSC_EXTENDED_INT_MASK_REG);
+		writel(MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK,
+		       tdmmc->regs + MCSC_GLOBAL_INT_CAUSE_REG);
+		writel(0, tdmmc->regs + MCSC_EXTENDED_INT_CAUSE_REG);
+
+		/* Enable unit interrupts */
+		mask_reg = readl(tdmmc->regs + TDM_MASK_REG);
+		writel(mask_reg | CONFIG_TDM_CAUSE, tdmmc->regs + TDM_MASK_REG);
+		writel(CONFIG_COMM_UNIT_TOP_MASK,
+		       tdmmc->regs + COMM_UNIT_TOP_MASK_REG);
+
+		/* Enable TDM */
+		if (tdmmc->ip_ver == TDMMC_REV1)
+			mv_phone_set_bit(tdmmc->regs + FLEX_TDM_CONFIG_REG,
+					 TDM_TEN_MASK);
+	}
+}
+
+void tdmmc_pcm_stop(void)
+{
+	u32 buff_size, index;
+
+	if (tdmmc->pcm_enable) {
+		/* Mark PCM I/F as disabled  */
+		tdmmc->pcm_enable = false;
+
+		/* Clear TDM cause and mask registers */
+		writel(0, tdmmc->regs + COMM_UNIT_TOP_MASK_REG);
+		writel(0, tdmmc->regs + TDM_MASK_REG);
+		writel(0, tdmmc->regs + COMM_UNIT_TOP_CAUSE_REG);
+		writel(0, tdmmc->regs + TDM_CAUSE_REG);
+
+		/* Clear MCSC cause and mask registers(except InitDone bit) */
+		writel(0, tdmmc->regs + MCSC_GLOBAL_INT_MASK_REG);
+		writel(0, tdmmc->regs + MCSC_EXTENDED_INT_MASK_REG);
+		writel(MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK, tdmmc->regs +
+		       MCSC_GLOBAL_INT_CAUSE_REG);
+		writel(0, tdmmc->regs + MCSC_EXTENDED_INT_CAUSE_REG);
+
+		tdmmc_mcdma_stop();
+
+		/* Calculate total Rx/Tx buffer size */
+		buff_size = (tdmmc->sample_size * MV_TDM_TOTAL_CH_SAMPLES *
+			     tdmmc->sampling_coeff * tdmmc->total_channels);
+
+		/* Clear Rx buffers */
+		for (index = 0; index < TOTAL_CHAINS; index++)
+			memset(tdmmc->rx_buff_virt[index], 0, buff_size);
+
+		/* Disable TDM */
+		if (tdmmc->ip_ver == TDMMC_REV1)
+			mv_phone_reset_bit(tdmmc->regs + FLEX_TDM_CONFIG_REG,
+					   TDM_TEN_MASK);
+	}
+}
+
+int tdmmc_tx(u8 *tdm_tx_buff)
+{
+	u32 buff_size, index;
+	u8 tmp;
+
+	/* Calculate total Tx buffer size */
+	buff_size = (tdmmc->sample_size * MV_TDM_TOTAL_CH_SAMPLES *
+		     tdmmc->sampling_coeff * tdmmc->total_channels);
+
+	if (tdmmc->ip_ver == TDMMC_REV0) {
+		if (tdmmc->sample_size > MV_PCM_FORMAT_1BYTE) {
+			dev_dbg(tdmmc->dev,
+				"Linear mode (Tx): swapping bytes\n");
+			for (index = 0; index < buff_size; index += 2) {
+				tmp = tdm_tx_buff[index];
+				tdm_tx_buff[index] = tdm_tx_buff[index+1];
+				tdm_tx_buff[index+1] = tmp;
+			}
+			dev_dbg(tdmmc->dev,
+				"Linear mode (Tx): swapping bytes...done.\n");
+		}
+	}
+
+	return 0;
+}
+
+int tdmmc_rx(u8 *tdm_rx_buff)
+{
+	u32 buff_size, index;
+	u8 tmp;
+
+	/* Calculate total Rx buffer size */
+	buff_size = (tdmmc->sample_size * MV_TDM_TOTAL_CH_SAMPLES *
+		     tdmmc->sampling_coeff * tdmmc->total_channels);
+
+	if (tdmmc->ip_ver == TDMMC_REV0) {
+		if (tdmmc->sample_size > MV_PCM_FORMAT_1BYTE) {
+			dev_dbg(tdmmc->dev,
+				"Linear mode (Rx): swapping bytes\n");
+			for (index = 0; index < buff_size; index += 2) {
+				tmp = tdm_rx_buff[index];
+				tdm_rx_buff[index] = tdm_rx_buff[index+1];
+				tdm_rx_buff[index+1] = tmp;
+			}
+			dev_dbg(tdmmc->dev,
+				"Linear mode (Rx): swapping bytes...done.\n");
+		}
+	}
+
+	return 0;
+}
+
+/* Low level TDM interrupt service routine */
+int tdmmc_intr_low(struct mv_phone_intr_info *tdm_intr_info)
+{
+	u32 cause_reg, mask_reg, cause_and_mask, curr_desc, int_ack_bits = 0;
+	u8 index;
+
+	/* Read TDM cause & mask registers */
+	cause_reg = readl(tdmmc->regs + TDM_CAUSE_REG);
+	mask_reg = readl(tdmmc->regs + TDM_MASK_REG);
+
+	dev_dbg(tdmmc->dev, "%s: Cause register = 0x%x, Mask register = 0x%x\n",
+		__func__, cause_reg, mask_reg);
+
+	/* Refer only to unmasked bits */
+	cause_and_mask = cause_reg & mask_reg;
+
+	/* Reset ISR params */
+	tdm_intr_info->tdm_rx_buff = NULL;
+	tdm_intr_info->tdm_tx_buff = NULL;
+	tdm_intr_info->int_type = MV_EMPTY_INT;
+
+	/* Return in case TDM is disabled */
+	if (!tdmmc->tdm_enable) {
+		dev_dbg(tdmmc->dev,
+			"%s: TDM is disabled - quit low lever ISR\n", __func__);
+		writel(~int_ack_bits, tdmmc->regs + TDM_CAUSE_REG);
+		return 0;
+	}
+
+	/* Handle TDM Error/s */
+	if (cause_and_mask & TDM_ERROR_INT) {
+		dev_err(tdmmc->dev, "TDM Error: TDM_CAUSE_REG = 0x%x\n",
+			cause_reg);
+		int_ack_bits |= (int_ack_bits & TDM_ERROR_INT);
+	}
+
+	if (cause_and_mask & (TDM_TX_INT | TDM_RX_INT)) {
+		/*
+		 * MCDMA current Tx desc. pointer is unreliable,
+		 * thus, checking Rx desc. pointer only.
+		 */
+		curr_desc = readl(tdmmc->regs +
+				  MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(0));
+		dev_dbg(tdmmc->dev, "%s: current descriptor = 0x%x\n", __func__,
+			curr_desc);
+
+		/* Handle Tx */
+		if (cause_and_mask & TDM_TX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (curr_desc == tdmmc->rx_desc_phys[index]) {
+					tdmmc->next_tx = NEXT_BUFF(index);
+					break;
+				}
+			}
+			dev_dbg(tdmmc->dev,
+				"%s: TX interrupt (next_tx_buff = %d\n",
+				__func__, tdmmc->next_tx);
+			tdm_intr_info->tdm_tx_buff =
+					    tdmmc->tx_buff_virt[tdmmc->next_tx];
+			tdm_intr_info->int_type |= MV_TX_INT;
+			int_ack_bits |= TDM_TX_INT;
+		}
+
+		/* Handle Rx */
+		if (cause_and_mask & TDM_RX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (curr_desc == tdmmc->rx_desc_phys[index]) {
+					tdmmc->prev_rx = PREV_BUFF(index);
+					break;
+				}
+			}
+			dev_dbg(tdmmc->dev,
+				"%s: RX interrupt (prev_rx_buff = %d)\n",
+				__func__, tdmmc->prev_rx);
+			tdm_intr_info->tdm_rx_buff =
+					    tdmmc->rx_buff_virt[tdmmc->prev_rx];
+			tdm_intr_info->int_type |= MV_RX_INT;
+			int_ack_bits |= TDM_RX_INT;
+		}
+	}
+
+	/* Clear TDM interrupts */
+	writel(~int_ack_bits, tdmmc->regs + TDM_CAUSE_REG);
+
+	return 0;
+}
+
+int tdmmc_reset_slic(void)
+{
+	/* Enable SLIC reset */
+	mv_phone_reset_bit(tdmmc->regs + TDM_CLK_AND_SYNC_CONTROL_REG,
+			   TDM_PROG_TDM_SLIC_RESET_MASK);
+
+	udelay(60);
+
+	/* Release SLIC reset */
+	mv_phone_set_bit(tdmmc->regs + TDM_CLK_AND_SYNC_CONTROL_REG,
+			 TDM_PROG_TDM_SLIC_RESET_MASK);
+
+	return 0;
+}
+
+/* Initialize decoding windows */
+int tdmmc_set_mbus_windows(struct device *dev, void __iomem *regs)
+{
+	const struct mbus_dram_target_info *dram = mv_mbus_dram_info();
+	u32 win_protect, win_enable;
+	int i;
+
+	if (!dram) {
+		dev_err(dev, "no mbus dram info\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < COMM_UNIT_MBUS_MAX_WIN; i++) {
+		writel(0, regs + COMM_UNIT_WIN_CTRL_REG(i));
+		writel(0, regs + COMM_UNIT_WIN_SIZE_REG(i));
+		writel(0, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+	}
+
+	win_enable = 0xff;
+	win_protect = 0;
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+
+		writel((cs->base & 0xffff0000) |
+		       (cs->mbus_attr << 8) |
+		       dram->mbus_dram_target_id,
+		       regs + COMM_UNIT_WIN_CTRL_REG(i));
+
+		writel((cs->size - 1) & 0xffff0000,
+		       regs + COMM_UNIT_WIN_SIZE_REG(i));
+
+		writel(win_enable, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+		win_protect |= 3 << (2 * i);
+	}
+
+	/* Configure an extra window for PCIE0 */
+	writel(0x8000e804, regs + COMM_UNIT_WIN_CTRL_REG(i));
+	writel(0x1fff0000, regs + COMM_UNIT_WIN_SIZE_REG(i));
+	writel(win_enable, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+	win_protect |= 3 << (2 * i);
+
+	writel(win_protect, regs + COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG);
+
+	return 0;
+}
+
+/* Initialize decoding windows for Armada 8k SoC */
+int tdmmc_set_a8k_windows(struct device *dev, void __iomem *regs)
+{
+	int i;
+
+	for (i = 0; i < COMM_UNIT_MBUS_MAX_WIN; i++) {
+		writel(0xce00, regs + COMM_UNIT_WIN_CTRL_REG(i));
+		writel(0xffff0000, regs + COMM_UNIT_WIN_SIZE_REG(i));
+		if (i > 0)
+			writel(0x0, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+	}
+
+	return 0;
+}
diff --git a/drivers/telephony/mvebu_phone/tdmmc/tdmmc.h b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.h
new file mode 100644
index 000000000000..2af6d92beb78
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.h
@@ -0,0 +1,355 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _TDMMC_H_
+#define _TDMMC_H_
+
+/****************************************************************/
+/*	Time Division Multiplexing Interrupt Controller		*/
+/****************************************************************/
+#define COMM_UNIT_TOP_CAUSE_REG			0x8C00
+#define TDM_CAUSE_REG				0x8C40
+#define COMM_UNIT_TOP_MASK_REG			0x8C80
+#define VOICE_PERIODICAL_INT_CONTROL_REG	0x8C90
+#define TDM_MASK_REG				0x8CC0
+
+/* COMM_UNIT_TOP_CAUSE_REG bits */
+#define TDM_SUM_INT_OFFS		6
+#define TDM_SUM_INT_MASK		(1 << TDM_SUM_INT_OFFS)
+#define MCSC_SUM_INT_OFFS		28
+#define MCSC_SUM_INT_MASK		(1 << MCSC_SUM_INT_OFFS)
+
+/* TDM_CAUSE_REG bits */
+#define FLEX_TDM_RX_SYNC_LOSS_OFFS	3
+#define FLEX_TDM_RX_SYNC_LOSS_MASK	(1 << FLEX_TDM_RX_SYNC_LOSS_OFFS)
+#define FLEX_TDM_TX_SYNC_LOSS_OFFS	7
+#define FLEX_TDM_TX_SYNC_LOSS_MASK	(1 << FLEX_TDM_TX_SYNC_LOSS_OFFS)
+#define RX_VOICE_INT_PULSE_OFFS		8
+#define RX_VOICE_INT_PULSE_MASK		(1 << RX_VOICE_INT_PULSE_OFFS)
+#define TX_VOICE_INT_PULSE_OFFS		9
+#define TX_VOICE_INT_PULSE_MASK		(1 << TX_VOICE_INT_PULSE_OFFS)
+#define COMM_UNIT_PAR_ERR_SUM_OFFS	18
+#define COMM_UNIT_PAR_ERR_SUM_MASK	(1 << COMM_UNIT_PAR_ERR_SUM_OFFS)
+#define TDM_RX_PAR_ERR_SUM_OFFS		19
+#define TDM_RX_PAR_ERR_SUM_MASK		(1 << TDM_RX_PAR_ERR_SUM_OFFS)
+#define TDM_TX_PAR_ERR_SUM_OFFS		20
+#define TDM_TX_PAR_ERR_SUM_MASK		(1 << TDM_TX_PAR_ERR_SUM_OFFS)
+#define MCSC_PAR_ERR_SUM_OFFS		21
+#define MCSC_PAR_ERR_SUM_MASK		(1 << MCSC_PAR_ERR_SUM_OFFS)
+#define MCDMA_PAR_ERR_SUM_OFFS		22
+#define MCDMA_PAR_ERR_SUM_MASK		(1 << MCDMA_PAR_ERR_SUM_OFFS)
+
+/*  VOICE_PERIODICAL_INT_CONTROL_REG bits  */
+#define RX_VOICE_INT_CNT_REF_OFFS	0
+#define RX_VOICE_INT_CNT_REF_MASK	(0xff << RX_VOICE_INT_CNT_REF_OFFS)
+#define TX_VOICE_INT_CNT_REF_OFFS	8
+#define TX_VOICE_INT_CNT_REF_MASK	(0xff << TX_VOICE_INT_CNT_REF_OFFS)
+#define RX_FIRST_DELAY_REF_OFFS		16
+#define RX_FIRST_DELAY_REF_MASK		(0xff << RX_FIRST_DELAY_REF_OFFS)
+#define TX_FIRST_DELAY_REF_OFFS		24
+#define TX_FIRST_DELAY_REF_MASK		(0xff << TX_FIRST_DELAY_REF_OFFS)
+
+/* Multi-Channel Serial Controller (MCSC) */
+#define MCSC_CHx_RECEIVE_CONFIG_REG(ch)		(0x400 + (ch << 2))
+#define MCSC_CHx_TRANSMIT_CONFIG_REG(ch)	(0x1800 + (ch<<2))
+#define MCSC_GLOBAL_CONFIG_REG			0x2800
+#define MCSC_GLOBAL_INT_CAUSE_REG		0x2804
+#define MCSC_EXTENDED_INT_CAUSE_REG		0x2808
+#define MCSC_GLOBAL_INT_MASK_REG		0x280C
+#define MCSC_EXTENDED_INT_MASK_REG		0x2810
+#define MCSC_GLOBAL_CONFIG_EXTENDED_REG		0x2890
+
+/* MCSC_RECEIVE_CONFIG_REG(MRCRx) bits */
+#define MRCRx_ER_OFFS			27
+#define MRCRx_ER_MASK			(1 << MRCRx_ER_OFFS)
+#define MRCRx_RRVD_OFFS			30
+#define MRCRx_RRVD_MASK			(1 << MRCRx_RRVD_OFFS)
+#define MRCRx_MODE_OFFS			31
+#define MRCRx_MODE_MASK			(1 << MRCRx_MODE_OFFS)
+
+/* MCSC_TRANSMIT_CONFIG_REG(MTCRx) bits */
+#define MTCRx_ET_OFFS			27
+#define MTCRx_ET_MASK			(1 << MTCRx_ET_OFFS)
+#define MTCRx_TRVD_OFFS			30
+#define MTCRx_TRVD_MASK			(1 << MTCRx_TRVD_OFFS)
+#define MTCRx_MODE_OFFS			31
+#define MTCRx_MODE_MASK			(1 << MTCRx_MODE_OFFS)
+
+/* MCSC_GLOBAL_CONFIG_REG bits */
+#define MCSC_GLOBAL_CONFIG_TCBD_OFFS	20
+#define MCSC_GLOBAL_CONFIG_TCBD_MASK	(1 << MCSC_GLOBAL_CONFIG_TCBD_OFFS)
+#define MCSC_GLOBAL_CONFIG_MAI_OFFS	21
+#define MCSC_GLOBAL_CONFIG_MAI_MASK	(1 << MCSC_GLOBAL_CONFIG_MAI_OFFS)
+#define MCSC_GLOBAL_CONFIG_RXEN_OFFS	30
+#define MCSC_GLOBAL_CONFIG_RXEN_MASK	(1 << MCSC_GLOBAL_CONFIG_RXEN_OFFS)
+#define MCSC_GLOBAL_CONFIG_TXEN_OFFS	31
+#define MCSC_GLOBAL_CONFIG_TXEN_MASK	(1 << MCSC_GLOBAL_CONFIG_TXEN_OFFS)
+
+/* MCSC_GLOBAL_INT_CAUSE_REG */
+#define  MCSC_GLOBAL_INT_CAUSE_INIT_DONE_OFFS	25
+#define  MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK	\
+				(1 << MCSC_GLOBAL_INT_CAUSE_INIT_DONE_OFFS)
+
+/* MCSC_GLOBAL_CONFIG_EXTENDED_REG bits */
+#define  MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_OFFS	2
+#define  MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_MASK	\
+				(1 << MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_OFFS)
+#define  MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_OFFS	3
+#define  MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_MASK	\
+				(1 << MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_OFFS)
+
+/* Multi-Channel DMA(MCDMA) */
+#define MCDMA_RECEIVE_CONTROL_REG(ch)		(0x3000 + (ch<<2))
+#define MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(ch)	(0x4000 + (ch<<2))
+#define MCDMA_GLOBAL_CONTROL_REG		0x4400
+#define RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG	0x4408
+#define MCDMA_TRANSMIT_CONTROL_REG(ch)		(0x5000 + (ch<<2))
+#define MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(ch)	(0x7000 + (ch<<2))
+#define TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG	0x7408
+
+/* MCDMA_RECEIVE_CONTROL_REG bits */
+#define MCDMA_RBSZ_16BYTE		0x1
+
+#define MCDMA_BLMR_OFFS			2
+#define MCDMA_BLMR_MASK			(1 << MCDMA_BLMR_OFFS)
+#define MCDMA_ERD_OFFS			6
+#define MCDMA_ERD_MASK			(1 << MCDMA_ERD_OFFS)
+
+/* MCDMA_GLOBAL_CONTROL_REG bits */
+#define MCDMA_RID_OFFS			1
+#define MCDMA_RID_MASK			(1 << MCDMA_RID_OFFS)
+
+/* MCDMA_TRANSMIT_CONTROL_REG bits */
+#define MCDMA_FSIZE_1BLK		0x1
+#define MCDMA_TBSZ_OFFS			8
+#define MCDMA_TBSZ_16BYTE		(0x1 << MCDMA_TBSZ_OFFS)
+#define MCDMA_BLMT_OFFS			10
+#define MCDMA_BLMT_MASK			(1 << MCDMA_BLMT_OFFS)
+#define MCDMA_TXD_OFFS			17
+#define MCDMA_TXD_MASK			(1 << MCDMA_TXD_OFFS)
+
+/* Time Division Multiplexing(TDM) */
+#define FLEX_TDM_TDPR_REG(entry)		(0x8000 + (entry<<2))
+#define FLEX_TDM_RDPR_REG(entry)		(0x8400 + (entry<<2))
+#define FLEX_TDM_CONFIG_REG			0x8808
+#define TDM_CLK_AND_SYNC_CONTROL_REG		0x881C
+#define TDM_OUTPUT_SYNC_BIT_COUNT_REG		0x8C8C
+#define TDM_DATA_DELAY_AND_CLK_CTRL_REG		0x8CD0
+
+/* TDM_CLK_AND_SYNC_CONTROL_REG bits */
+#define TDM_TX_FSYNC_OUT_ENABLE_OFFS	0
+#define TDM_TX_FSYNC_OUT_ENABLE_MASK	(1 << TDM_TX_FSYNC_OUT_ENABLE_OFFS)
+#define TDM_RX_FSYNC_OUT_ENABLE_OFFS	1
+#define TDM_RX_FSYNC_OUT_ENABLE_MASK	(1 << TDM_RX_FSYNC_OUT_ENABLE_OFFS)
+#define TDM_TX_CLK_OUT_ENABLE_OFFS	2
+#define TDM_TX_CLK_OUT_ENABLE_MASK	(1 << TDM_TX_CLK_OUT_ENABLE_OFFS)
+#define TDM_RX_CLK_OUT_ENABLE_OFFS	3
+#define TDM_RX_CLK_OUT_ENABLE_MASK	(1 << TDM_RX_CLK_OUT_ENABLE_OFFS)
+#define TDM_REFCLK_DIVIDER_BYPASS_OFFS	20
+#define TDM_REFCLK_DIVIDER_BYPASS_MASK	(3 << TDM_REFCLK_DIVIDER_BYPASS_OFFS)
+#define TDM_OUT_CLK_SRC_CTRL_OFFS	24
+#define TDM_OUT_CLK_SRC_CTRL_AFTER_DIV	(1 << TDM_OUT_CLK_SRC_CTRL_OFFS)
+#define TDM_PROG_TDM_SLIC_RESET_OFFS	31
+#define TDM_PROG_TDM_SLIC_RESET_MASK	(1 << TDM_PROG_TDM_SLIC_RESET_OFFS)
+
+/* FLEX_TDM_CONFIG_REG bits */
+#define TDM_RR2HALF_OFFS		15
+#define TDM_RR2HALF_MASK		(1 << TDM_RR2HALF_OFFS)
+#define TDM_TR2HALF_OFFS		16
+#define TDM_TR2HALF_MASK		(1 << TDM_TR2HALF_OFFS)
+#define TDM_SE_OFFS			20
+#define TDM_SE_MASK			(1 << TDM_SE_OFFS)
+#define TDM_COMMON_RX_TX_OFFS		23
+#define TDM_COMMON_RX_TX_MASK		(1 << TDM_COMMON_RX_TX_OFFS)
+#define TSD_OFFS			25
+#define TSD_NO_DELAY			(0 << TSD_OFFS)
+#define RSD_OFFS			27
+#define RSD_NO_DELAY			(0 << RSD_OFFS)
+#define TDM_TEN_OFFS			31
+#define TDM_TEN_MASK			(1 << TDM_TEN_OFFS)
+
+/* TDM_OUTPUT_SYNC_BIT_COUNT_REG bits */
+#define TDM_SYNC_BIT_TX_OFFS		0
+#define TDM_SYNC_BIT_TX_MASK		(0xffff << TDM_SYNC_BIT_TX_OFFS)
+#define TDM_SYNC_BIT_RX_OFFS		16
+#define TDM_SYNC_BIT_RX_MASK		(0xffff << TDM_SYNC_BIT_RX_OFFS)
+
+/* TDM_DATA_DELAY_AND_CLK_CTRL_REG bits */
+#define TX_CLK_OUT_ENABLE_OFFS		0
+#define TX_CLK_OUT_ENABLE_MASK		(1 << TX_CLK_OUT_ENABLE_OFFS)
+#define RX_CLK_OUT_ENABLE_OFFS		1
+#define RX_CLK_OUT_ENABLE_MASK		(1 << RX_CLK_OUT_ENABLE_OFFS)
+
+/************************************************/
+/*	Shared Bus to Crossbar Bridge		*/
+/************************************************/
+#define COMM_UNIT_MBUS_MAX_WIN			12
+
+#define COMM_UNIT_WIN_CTRL_REG(win)		(0x8A00 + (win<<3))
+#define COMM_UNIT_WIN_SIZE_REG(win)		(0x8A04 + (win<<3))
+#define COMM_UNIT_WIN_ENABLE_REG(win)		(0x8B04 + (win<<2))
+#define COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG	0x8B00
+#define TIME_OUT_COUNTER_REG			0x8ADC
+
+/* TIME_OUT_COUNTER_REG bits */
+#define	TIME_OUT_THRESHOLD_COUNT_OFFS		16
+#define	TIME_OUT_THRESHOLD_COUNT_MASK		\
+				(0xffff << TIME_OUT_THRESHOLD_COUNT_OFFS)
+
+/* Defines */
+#define MV_TDMMC_TOTAL_CHANNELS			32
+#define MV_TDM_MAX_HALF_DPRAM_ENTRIES		128
+
+/* IRQ types */
+#define TDM_TX_INT				TX_VOICE_INT_PULSE_MASK
+#define TDM_RX_INT				RX_VOICE_INT_PULSE_MASK
+#define TDM_ERROR_INT \
+	(FLEX_TDM_RX_SYNC_LOSS_MASK | FLEX_TDM_TX_SYNC_LOSS_MASK |	\
+	 COMM_UNIT_PAR_ERR_SUM_MASK | TDM_RX_PAR_ERR_SUM_MASK |		\
+	 TDM_TX_PAR_ERR_SUM_MASK | MCSC_PAR_ERR_SUM_MASK |		\
+	 MCDMA_PAR_ERR_SUM_MASK)
+
+/* MCDMA Descriptor Command/Status Bits */
+#define	LAST_BIT	0x00010000
+#define	FIRST_BIT	0x00020000
+#define	AUTO_MODE	0x40000000
+#define	OWNER		0x80000000
+
+/* MCDMA */
+#define CONFIG_MCDMA_DESC_CMD_STATUS	(FIRST_BIT | AUTO_MODE | OWNER)
+#define CONFIG_RMCCx			(MCDMA_RBSZ_16BYTE | MCDMA_BLMR_MASK)
+#define CONFIG_TMCCx \
+	(MCDMA_FSIZE_1BLK | MCDMA_TBSZ_16BYTE | MCDMA_BLMT_MASK)
+
+/* MCSC */
+#define CONFIG_MRCRx			(MRCRx_RRVD_MASK | MRCRx_MODE_MASK)
+#define CONFIG_MTCRx			(MTCRx_TRVD_MASK | MTCRx_MODE_MASK)
+#define CONFIG_LINEAR_BYTE_SWAP \
+	(MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_MASK |	\
+	MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_MASK)
+/* TDM */
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	\
+	(TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK |	\
+	TDM_REFCLK_DIVIDER_BYPASS_MASK)
+#else
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	\
+	(TDM_REFCLK_DIVIDER_BYPASS_MASK | TDM_OUT_CLK_SRC_CTRL_AFTER_DIV)
+#endif
+
+#define CONFIG_VOICE_PERIODICAL_INT_CONTROL \
+	(((MV_TDM_TOTAL_CH_SAMPLES) << RX_VOICE_INT_CNT_REF_OFFS) |	\
+	((MV_TDM_TOTAL_CH_SAMPLES) << TX_VOICE_INT_CNT_REF_OFFS) |	\
+	(2 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
+#define CONFIG_VOICE_PERIODICAL_INT_CONTROL_WA \
+	(((MV_TDM_TOTAL_CH_SAMPLES - 1) << RX_VOICE_INT_CNT_REF_OFFS) |	\
+	((MV_TDM_TOTAL_CH_SAMPLES - 1) << TX_VOICE_INT_CNT_REF_OFFS) |	\
+	(2 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
+#define CONFIG_TDM_CAUSE \
+	(TDM_RX_INT | TDM_TX_INT)
+#define CONFIG_COMM_UNIT_TOP_MASK \
+	(TDM_SUM_INT_MASK | MCSC_SUM_INT_MASK)
+#define CONFIG_FLEX_TDM_CONFIG \
+	(TDM_SE_MASK | TDM_COMMON_RX_TX_MASK | TSD_NO_DELAY | RSD_NO_DELAY)
+#define	CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL \
+	(TX_CLK_OUT_ENABLE_MASK | RX_CLK_OUT_ENABLE_MASK)
+
+/* Defines */
+#define TOTAL_CHAINS		2
+#define CONFIG_RBSZ		16
+#define NEXT_BUFF(buff)		((buff + 1) % TOTAL_CHAINS)
+#define PREV_BUFF(buff)		(buff == 0 ? (TOTAL_CHAINS - 1) : (buff - 1))
+#define MAX_POLL_USEC		100000	/* 100ms */
+#define COMM_UNIT_SW_RST	(1 << 5)
+#define OLD_INT_WA_BIT		(1 << 15)
+#define MV_TDM_PCM_CLK_8MHZ	1
+
+/* Enums */
+enum tdmmc_ip_version {
+	TDMMC_REV0 = 0,
+	TDMMC_REV1
+};
+
+/* Structures */
+struct tdmmc_mcdma_rx_desc {
+	u32 cmd_status;
+	u16 byte_cnt;
+	u16 buff_size;
+	u32 phys_buff_ptr;
+	u32 phys_next_desc_ptr;
+};
+
+struct tdmmc_mcdma_tx_desc {
+	u32 cmd_status;
+	u16 shadow_byte_cnt;
+	u16 byte_cnt;
+	u32 phys_buff_ptr;
+	u32 phys_next_desc_ptr;
+};
+
+struct tdmmc_dram_entry {
+	u32 mask:8;
+	u32 ch:8;
+	u32 mgs:2;
+	u32 byte:1;
+	u32 strb:2;
+	u32 elpb:1;
+	u32 tbs:1;
+	u32 rpt:2;
+	u32 last:1;
+	u32 ftint:1;
+	u32 reserved31_27:5;
+};
+
+/* Main TDM structure definition */
+struct tdmmc_dev {
+	/* Resources */
+	void __iomem *regs;
+	struct device *dev;
+
+	/* Silicon revision */
+	enum tdmmc_ip_version ip_ver;
+
+	/* Buffers */
+	u8 *rx_buff_virt[TOTAL_CHAINS];
+	u8 *tx_buff_virt[TOTAL_CHAINS];
+	dma_addr_t rx_buff_phys[TOTAL_CHAINS];
+	dma_addr_t tx_buff_phys[TOTAL_CHAINS];
+	u8 prev_rx;
+	u8 next_tx;
+
+	/* MCDMA descriptors */
+	struct tdmmc_mcdma_rx_desc *rx_desc_virt[TOTAL_CHAINS];
+	struct tdmmc_mcdma_tx_desc *tx_desc_virt[TOTAL_CHAINS];
+	dma_addr_t rx_desc_phys[TOTAL_CHAINS];
+	dma_addr_t tx_desc_phys[TOTAL_CHAINS];
+
+	/* Flags */
+	bool tdm_enable;
+	bool pcm_enable;
+
+	/* Parameters */
+	u8 sample_size;
+	u8 sampling_coeff;
+	u16 total_channels;
+};
+
+/* TDMMC APIs */
+void tdmmc_pcm_start(void);
+void tdmmc_pcm_stop(void);
+int tdmmc_tx(u8 *tdm_tx_buff);
+int tdmmc_rx(u8 *tdm_rx_buff);
+void tdmmc_show(void);
+void tdmmc_release(void);
+void tdmmc_intr_enable(u8 device_id);
+void tdmmc_intr_disable(u8 device_id);
+int tdmmc_reset_slic(void);
+int tdmmc_set_mbus_windows(struct device *dev, void __iomem *regs);
+int tdmmc_set_a8k_windows(struct device *dev, void __iomem *regs);
+
+#endif /* _TDMMC_H_ */
+
diff --git a/drivers/telephony/mvebu_phone/telephony_user_guide.txt b/drivers/telephony/mvebu_phone/telephony_user_guide.txt
new file mode 100644
index 000000000000..8467019f566e
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/telephony_user_guide.txt
@@ -0,0 +1,183 @@
+TDM Telephony
+==============
+
+Introduction
+------------
+There are 2 telephony controllers in Marvell SoCs:
+	- 2-channel TDM (TDM2C, available in A380)
+	- Multi-channel TDM (TDMMC, available in A8k)
+
+In order to use telephony drivers the following SW modules are required
+(Explanation will be provided later is this document):
+
+	- Linux Kernel Image with telephony support
+	- Linux Kernel device-tree with telephony support
+	- SLIC (Subscriber line interface card) Linux Kernel module
+	- Demo user-space application (mv-voice-tool)
+
+Linux Image
+-----------
+arch/arm/configs/mvebu_v7_lsp_defconfig
+arch/arm64/confgs/mvebu_v8_lsp_defconfig
+enable usage of both TDM2C and TDMMC, proper operation mode is fully
+determined by Device Tree entry.
+
+Device-tree
+------------
+Refer to: Documentation/devicetree/bindings/telephony/mvebu-phone.txt
+
+SLIC
+----
+The LSP release contains pre-compiled Kernel modules for supported SLIC devices,
+located in: rootfs/lib/modules/slic/:
+
+	- Silabs SLICs:
+		- silabs-si3217x.ko
+		- silabs-si3226x.ko
+	- Zarlink SLICs:
+		- zarlink-ve792.ko
+		- zarlink-ve880.ko
+		- zarlink-ve886.ko
+		- zarlink-ve888.ko
+		- zarlink-ve890.ko
+
+The corresponding Kernel module should be inserted after boot using::
+
+	> insmod <Kernel_module_name>
+
+For example::
+
+	> insmod silabs-si3226x.ko
+
+
+mv-voice-tool
+-------------
+User-space application which communicates via ioctl with the telephony driver.
+The application is located in the LSP release (rootfs/usr/local/voice-tool).
+mv-voice-tool must suit the SLIC which is used:
+
+	+-----------------------+-----------------------+
+	| SLIC			| mv-voice-tool		|
+	+=======================+=======================+
+	| silabs-si3226x.ko	| mv_voice_tool-si3217x	|
+	+-----------------------+-----------------------+
+	| silabs-si3217x.ko	| mv_voice_tool-si3217x	|
+	+-----------------------+-----------------------+
+	| zarlink-ve792.ko	| mv_voice_tool-ve792	|
+	+-----------------------+-----------------------+
+	| zarlink-ve880.ko	| mv_voice_tool-ve880	|
+	+-----------------------+-----------------------+
+	| zarlink-ve886.ko	| mv_voice_tool-ve886	|
+	+-----------------------+-----------------------+
+	| zarlink-ve888.ko	| mv_voice_tool-ve888	|
+	+-----------------------+-----------------------+
+	| zarlink-ve890.ko	| mv_voice_tool-ve890	|
+	+-----------------------+-----------------------+
+
+
+In order to run mv-voice tool, run the following command::
+
+	> ./mv_voice_tool-<version>
+
+Example for connecting 2 phones using mv-voice-tool::
+
+	> ./mv_voice_tool-si3226x
+
+	>>  Please enter total lines number: 2
+	>>  Please enter PCM sample size(1/2/4): 1
+
+	!!! Remember to start phone devices before performing any action !!!
+
+	Marvell Voice Tool (Silabs Edition):
+	0. Read from SLIC register
+	1. Write to SLIC register
+	2. Start ring
+	3. Stop ring
+	4. Start/Stop HW Dial tone
+	5. Start SW Dial tone
+	6. Self echo on local phone
+	7. Loopback two local phones
+	8. Digital Loopback
+	9. Channel balancing
+	c. Config TDM PCLK
+	m. Multiple local phone pairs loopback
+	t. Start Phone devices
+	u. Stop Phone devices
+	a. Analog Loopback
+	b. record from phone and replay
+	y. Loopback two local phones endlessly for Abacus
+	z. Loopback two local phones for Abacus
+	q. Quit
+
+	>>  Please select option: t
+	[   33.542089] mvebu_phone f47a0000.tdm: Loading Marvell Telephony Driver
+	[   33.570432] ioctl: SILABS_MOD_IOX_CTRL_IF
+	[   33.574470] ioctl: SILABS_MOD_IOX_DEVICE_INIT
+	[   33.578866] ioctl: SILABS_MOD_IOX_CHAN_INIT
+	[   33.583076] ioctl: SILABS_MOD_IOX_CHAN_INIT
+	[   33.587286] ioctl: SILABS_MOD_IOX_CHAN_INIT
+	[   33.591495] ioctl: SILABS_MOD_IOX_CHAN_INIT
+	[   33.595699] ioctl: SILABS_MOD_IOX_CTRL_IF
+	[   33.599734] ioctl: SILABS_MOD_IOX_CHAN_OP
+	[   34.103808] ioctl: SILABS_MOD_IOX_CHAN_OP
+	[   34.607878] ioctl: SILABS_MOD_IOX_CHAN_ALL
+	[   34.612191] Si3226x: Channel 0 : Type = PROSLIC
+	[   34.616917] Si3226x: Channel 1 : Type = PROSLIC
+	[   34.621585] Si3226x: Channel 0 : Chip Type 28
+	[   34.625971] Si3226x: Channel 0 : Chip Rev 3
+	[   34.630289] Si3226x: Channel 1 : Chip Type 28
+	[   34.634672] Si3226x: Channel 1 : Chip Rev 3
+	[   34.639379] Si3226x: loading patch: 08132013
+	[   34.758946] Si3226x: loading patch: 08132013
+	[   35.270230] Si3226x: VBAT @ 50ms = 59.111 v
+	[   35.336159] Si3226x: VBAT Up = 59.111 v
+	[   35.403180] Si3226x: VBAT @ 50ms = 59.635 v
+	[   35.469114] Si3226x: VBAT Up = 59.845 v
+	[   36.141300] ioctl: SILABS_MOD_IOX_CHAN_ALL
+	[   36.145419] Si3226x: Starting LB Cal on channel 0
+	[   38.262691] Si3226x: Starting LB Cal on channel 1
+	[   40.379965] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.393731] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.405775] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.432049] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.439158] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.453907] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.467656] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.479694] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.505975] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.513090] ioctl: SILABS_MOD_IOX_CHAN_SETUP
+	[   40.527837] ioctl: SILABS_MOD_IOX_PCM_TS_SETUP
+	[   40.532526] ioctl: SILABS_MOD_IOX_CHAN_LINE_FEED
+	[   40.537281] ioctl: SILABS_MOD_IOX_PCM_TS_SETUP
+	[   40.541969] ioctl: SILABS_MOD_IOX_CHAN_LINE_FEED
+	[   40.546724] ioctl: SILABS_MOD_IOX_CHAN_OP
+	[   40.551030] ioctl: SILABS_MOD_IOX_CHAN_OP
+	[   40.555294] ioctl: SILABS_MOD_IOX_CHAN_OP
+	[   40.559328] Si3226x: PCMStart
+	[   40.562425] ioctl: SILABS_MOD_IOX_CHAN_OP
+	[   40.566459] Si3226x: PCMStart
+
+	Marvell Voice Tool (Silabs Edition):
+	0. Read from SLIC register
+	1. Write to SLIC register
+	2. Start ring
+	3. Stop ring
+	4. Start/Stop HW Dial tone
+	5. Start SW Dial tone
+	6. Self echo on local phone
+	7. Loopback two local phones
+	8. Digital Loopback
+	9. Channel balancing
+	c. Config TDM PCLK
+	m. Multiple local phone pairs loopback
+	t. Start Phone devices
+	u. Stop Phone devices
+	a. Analog Loopback
+	b. record from phone and replay
+	y. Loopback two local phones endlessly for Abacus
+	z. Loopback two local phones for Abacus
+	q. Quit
+
+	>>  Please select option: 7
+	>>  Enter line #0: 1
+	>>  Enter line #1: 0
diff --git a/include/linux/miscdevice.h b/include/linux/miscdevice.h
index 3247a3dc7934..4e2405e871ef 100644
--- a/include/linux/miscdevice.h
+++ b/include/linux/miscdevice.h
@@ -21,6 +21,8 @@
 #define APOLLO_MOUSE_MINOR	7	/* unused */
 #define PC110PAD_MINOR		9	/* unused */
 /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
+#define SLICDEV_MINOR		73	/* Marvell SLIC control device */
+#define TALDEV_MINOR		74	/* Marvell TAL device */
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define APM_MINOR_DEV		134
-- 
2.17.1


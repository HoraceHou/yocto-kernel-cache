From 5b3181aeda190f105ec07c2805c7574cca97cbac Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Fri, 7 Jun 2019 11:31:04 +0530
Subject: [PATCH 283/386] octeontx2-af: Update workarounds for hardware issues

Few hardware issues from 96xx A0 are not fixed in
95xx A0 silicon. This patch applies workarounds of
non fixed 96xx A0's hw issues to 95xx A0.

Change-Id: I8b0a3483a158c9b3c02c8ba5aee8cfa3a37c9e66
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/10630
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |  4 ++--
 .../net/ethernet/marvell/octeontx2/af/rvu.h   | 11 +++++++++-
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c | 22 +++++++++++++------
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   |  4 ++--
 .../ethernet/marvell/octeontx2/af/rvu_npc.c   |  4 ++--
 .../ethernet/marvell/octeontx2/af/rvu_sso.c   |  2 +-
 6 files changed, 32 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index e28962e6b91b..609718b31907 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -67,7 +67,7 @@ static void rvu_setup_hw_capabilities(struct rvu *rvu)
 	hw->cap.nix_shaping = true;
 	hw->cap.nix_tx_link_bp = true;
 
-	if ((is_rvu_9xxx_A0(rvu))) {
+	if (is_rvu_96xx_A0(rvu) || is_rvu_95xx_A0(rvu)) {
 		hw->cap.nix_fixed_txschq_mapping = true;
 		hw->cap.nix_txsch_per_cgx_lmac = 4;
 		hw->cap.nix_txsch_per_lbk_lmac = 132;
@@ -1050,7 +1050,7 @@ static int rvu_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,
 {
 	u64 val;
 
-	if (block->type == BLKTYPE_TIM && is_rvu_9xxx_A0(rvu))
+	if (block->type == BLKTYPE_TIM && is_rvu_96xx_A0(rvu))
 		return rvu_lf_lookup_tim_errata(rvu, block, pcifunc, slot);
 
 	val = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 83dacfb61620..c9ce6a4f934e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -22,6 +22,7 @@
 
 /* Subsystem Device ID */
 #define PCI_SUBSYS_DEVID_96XX                  0xB200
+#define PCI_SUBSYS_DEVID_95XX                  0xB200
 
 /* PCI BAR nos */
 #define	PCI_AF_REG_BAR_NUM			0
@@ -470,7 +471,7 @@ static inline u64 rvupf_read64(struct rvu *rvu, u64 offset)
 	return readq(rvu->pfreg_base + offset);
 }
 
-static inline bool is_rvu_9xxx_A0(struct rvu *rvu)
+static inline bool is_rvu_96xx_A0(struct rvu *rvu)
 {
 	struct pci_dev *pdev = rvu->pdev;
 
@@ -478,6 +479,14 @@ static inline bool is_rvu_9xxx_A0(struct rvu *rvu)
 		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
 }
 
+static inline bool is_rvu_95xx_A0(struct rvu *rvu)
+{
+	struct pci_dev *pdev = rvu->pdev;
+
+	return (pdev->revision == 0x10) &&
+		(pdev->subsystem_device == PCI_SUBSYS_DEVID_95XX);
+}
+
 /* Function Prototypes
  * RVU
  */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index 5ecc1a7f3a9d..aac1c52a30f9 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -892,7 +892,7 @@ static void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr)
 	 * CQ context. To avoid such condition, enable internal backpressure
 	 * with BP_TEST registers.
 	 */
-	if (is_rvu_9xxx_A0(rvu)) {
+	if (is_rvu_96xx_A0(rvu)) {
 		/* Enable internal backpressure on pipe_stg0 */
 		rvu_write64(rvu, blkaddr, NIX_AF_RQM_BP_TEST,
 			    BIT_ULL(51) | BIT_ULL(23) | BIT_ULL(22) | 0x100ULL);
@@ -907,15 +907,19 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	int err;
 	u64 cfg;
 
-	if (!is_rvu_9xxx_A0(rvu))
+	if (!is_rvu_96xx_A0(rvu) && !is_rvu_95xx_A0(rvu))
 		return 0;
 
-	/* As per a HW errata in 9xxx A0 silicon, NIX may corrupt
+	/* As per a HW errata in 96xx A0 silicon, NIX may corrupt
 	 * internal state when conditional clocks are turned off.
 	 * Hence enable them.
 	 */
-	rvu_write64(rvu, blkaddr, NIX_AF_CFG,
-		    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
+	if (is_rvu_95xx_A0(rvu))
+		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x40ULL);
+	else
+		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
+			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
 
 	/* Set chan/link to backpressure TL3 instead of TL2 */
 	rvu_write64(rvu, blkaddr, NIX_AF_PSE_CHANNEL_LEVEL, 0x01);
@@ -928,17 +932,21 @@ int rvu_nix_fixes_init(struct rvu *rvu, struct nix_hw *nix_hw, int blkaddr)
 	cfg &= ~BIT_ULL(15);
 	rvu_write64(rvu, blkaddr, NIX_AF_SQM_DBG_CTL_STATUS, cfg);
 
+	rvu_nix_enable_internal_bp(rvu, blkaddr);
+
+	if (!is_rvu_96xx_A0(rvu))
+		return 0;
+
 	err = rvu_nix_tx_stall_workaround_init(rvu, nix_hw, blkaddr);
 	if (err)
 		return err;
 
-	rvu_nix_enable_internal_bp(rvu, blkaddr);
 	return 0;
 }
 
 void rvu_nix_fixes_exit(struct rvu *rvu, struct nix_hw *nix_hw)
 {
-	if (!is_rvu_9xxx_A0(rvu))
+	if (!is_rvu_96xx_A0(rvu))
 		return;
 
 	rvu_nix_tx_stall_workaround_exit(rvu, nix_hw);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 40c7837dab98..ccba4bc78091 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -131,10 +131,10 @@ static void nix_rx_sync(struct rvu *rvu, int blkaddr)
 	if (err)
 		dev_err(rvu->dev, "NIX RX software sync failed\n");
 
-	/* As per a HW errata in 9xxx A0 silicon, HW may clear SW_SYNC[ENA]
+	/* As per a HW errata in 96xx A0 silicon, HW may clear SW_SYNC[ENA]
 	 * bit too early. Hence wait for 50us more.
 	 */
-	if (is_rvu_9xxx_A0(rvu))
+	if (is_rvu_96xx_A0(rvu))
 		usleep_range(50, 60);
 }
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
index 3c1e073c708d..5bc0a8243e4b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c
@@ -1015,7 +1015,7 @@ static void npc_load_mkex_profile(struct rvu *rvu, int blkaddr)
 			 * parse nibble enable configuration has to be
 			 * identical for both Rx and Tx interfaces.
 			 */
-			if (is_rvu_9xxx_A0(rvu) &&
+			if (is_rvu_96xx_A0(rvu) &&
 			    mcam_kex->keyx_cfg[NIX_INTF_RX] !=
 			    mcam_kex->keyx_cfg[NIX_INTF_TX])
 				goto load_default;
@@ -1379,7 +1379,7 @@ int rvu_npc_init(struct rvu *rvu)
 	/* Due to an errata (35786) in A0 pass silicon, parse nibble enable
 	 * configuration has to be identical for both Rx and Tx interfaces.
 	 */
-	if (!is_rvu_9xxx_A0(rvu))
+	if (!is_rvu_96xx_A0(rvu))
 		nibble_ena = (1ULL << 19) - 1;
 	rvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX),
 			((keyz & 0x3) << 32) | nibble_ena);
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
index a2b6af6232f6..7d1d8463f4c0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_sso.c
@@ -377,7 +377,7 @@ int rvu_sso_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
 	 * TAQ buffer used by HWGRP when HWGRP is reset. Use SW routine to
 	 * drain it manually.
 	 */
-	if (is_rvu_9xxx_A0(rvu))
+	if (is_rvu_96xx_A0(rvu))
 		rvu_sso_ggrp_taq_flush(rvu, pcifunc, lf, slot, ssow_lf, blkaddr,
 				       ssow_blkaddr);
 
-- 
2.17.1


From 0c376e0b184b1c25f316dccc4e7e28b8d0fce9b3 Mon Sep 17 00:00:00 2001
From: Kiran Kumar K <kirankumark@marvell.com>
Date: Fri, 29 Mar 2019 13:10:44 +0530
Subject: [PATCH 127/386] octeontx2-af: Add rss flow key tunnel types

This pacth will add support to use UDP data for flow key hash
index calculation when user enable tunnel protocols like VXLAN,
GENEVE and GTPU.
The ideas is to consider only VNI values, when user specify
tunnel protocols like VXLAN, GENEVE, GTPU without UDP for flow
key alg. If your specifiy UDP also along with tunnel protocols,
then consider UDP data also for flow key hash index calculation.

With this patch we have added support for tunnel ptotocols like
VXLAN, GENEVE, GTPU.

The new flags can be used in the following way for alg index
calculation.
IPV4 + VXLAN ==> IPV4 + VXLAN(VNI) will be used.
IPV4 + UDP + VXLAN ==> IPV4 + UDP (non tunnel) + UDP_VXLAN(SPORT +
DPORT for tunnel) + VXLAN(VNI) will be used.
Same way it will be applied to all tunnel protocols.
IPV4 + GENEVE ==> IPV4 + GENEVE(VNI)
IPV4 + UDP + GENEVE ==> IPV4 + UDP + UDP_VXLAN(sport+dport)+
VXLAN(VNI)

Change-Id: I4408a17edde6072e7a042956c3f818cdd162fe02
Signed-off-by: Kiran Kumar K <kirankumark@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/6635
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/mbox.h  |  4 ++
 .../net/ethernet/marvell/octeontx2/af/npc.h   |  3 +
 .../ethernet/marvell/octeontx2/af/rvu_nix.c   | 66 +++++++++++++++----
 3 files changed, 61 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
index b1065f9a17c1..3975fff5bea2 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/mbox.h
@@ -657,6 +657,10 @@ struct nix_rss_flowkey_cfg {
 #define NIX_FLOW_KEY_TYPE_GENEVE   BIT(8)
 #define NIX_FLOW_KEY_TYPE_ETH_DMAC BIT(9)
 #define NIX_FLOW_KEY_TYPE_IPV6_EXT BIT(10)
+#define NIX_FLOW_KEY_TYPE_GTPU       BIT(11)
+#define NIX_FLOW_KEY_TYPE_UDP_VXLAN  BIT(12)
+#define NIX_FLOW_KEY_TYPE_UDP_GENEVE BIT(13)
+#define NIX_FLOW_KEY_TYPE_UDP_GTPU   BIT(14)
 	u32	flowkey_cfg; /* Flowkey types selected */
 	u8	group;       /* RSS context or group */
 };
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/npc.h b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
index c61acba70d42..2dc5a6f726ba 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/npc.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/npc.h
@@ -57,6 +57,9 @@ enum npc_kpu_lc_ltype {
 /* Don't modify Ltypes upto SCTP, otherwise it will
  * effect flow tag calculation and thus RSS.
  */
+/* Dont change values of UDP_VXLAN(12) and UDP_GENEVE(13), otherwise it
+ * will effect flow tag calculation and thus RSS
+ */
 enum npc_kpu_ld_ltype {
 	NPC_LT_LD_TCP = 1,
 	NPC_LT_LD_UDP,
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 61fc36b7e320..4aaa47abdbe1 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -2286,6 +2286,7 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 	struct nix_rx_flowkey_alg *field;
 	struct nix_rx_flowkey_alg tmp;
 	u32 key_type, valid_key;
+	u8 udp_tu_data;
 
 	if (!alg)
 		return -EINVAL;
@@ -2314,6 +2315,7 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 
 	keyoff_marker = 0; max_key_off = 0; group_member = 0;
 	nr_field = 0; key_off = 0; field_marker = 1;
+	udp_tu_data = 0;
 	field = &tmp; max_bit_pos = fls(flow_cfg);
 	for (idx = 0;
 	     idx < max_bit_pos && nr_field < FIELDS_PER_ALG &&
@@ -2324,13 +2326,13 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 		if (field_marker)
 			memset(&tmp, 0, sizeof(tmp));
 
+		field_marker = true;
+		keyoff_marker = true;
 		switch (key_type) {
 		case NIX_FLOW_KEY_TYPE_PORT:
 			field->sel_chan = true;
 			/* This should be set to 1, when SEL_CHAN is set */
 			field->bytesm1 = 1;
-			field_marker = true;
-			keyoff_marker = true;
 			break;
 		case NIX_FLOW_KEY_TYPE_IPV4:
 			field->lid = NPC_LID_LC;
@@ -2338,7 +2340,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->hdr_offset = 12; /* SIP offset */
 			field->bytesm1 = 7; /* SIP + DIP, 8 bytes */
 			field->ltype_mask = 0xF; /* Match only IPv4 */
-			field_marker = true;
 			keyoff_marker = false;
 			break;
 		case NIX_FLOW_KEY_TYPE_IPV6:
@@ -2347,8 +2348,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->hdr_offset = 8; /* SIP offset */
 			field->bytesm1 = 31; /* SIP + DIP, 32 bytes */
 			field->ltype_mask = 0xF; /* Match only IPv6 */
-			field_marker = true;
-			keyoff_marker = true;
 			break;
 		case NIX_FLOW_KEY_TYPE_TCP:
 		case NIX_FLOW_KEY_TYPE_UDP:
@@ -2376,8 +2375,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 					valid_key = true;
 					group_member = false;
 				}
-				field_marker = true;
-				keyoff_marker = true;
 			} else {
 				field_marker = false;
 				keyoff_marker = false;
@@ -2389,7 +2386,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->lid = NPC_LID_LD;
 			field->bytesm1 = 2;
 			field->ltype_mask = 0xF;
-			field_marker = true;
 			keyoff_marker = false;
 			if (key_type == NIX_FLOW_KEY_TYPE_NVGRE && valid_key) {
 				field->hdr_offset = 4; /* VSID offset */
@@ -2417,8 +2413,6 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->bytesm1 = 5; /* DMAC 6 Byte */
 			field->ltype_match = NPC_LT_LA_ETHER;
 			field->ltype_mask = 0xF;
-			field_marker = true;
-			keyoff_marker = true;
 			break;
 		case NIX_FLOW_KEY_TYPE_IPV6_EXT:
 			field->lid = NPC_LID_LC;
@@ -2426,8 +2420,56 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field->bytesm1 = 0; /* 1 Byte ext hdr*/
 			field->ltype_match = NPC_LT_LC_IP6_EXT;
 			field->ltype_mask = 0xF;
-			field_marker = true;
-			keyoff_marker = true;
+			break;
+		case NIX_FLOW_KEY_TYPE_GTPU:
+			field->lid = NPC_LID_LD;
+			field->hdr_offset = 12; /* UDP + hdr */
+			field->bytesm1 = 3; /* 4 bytes VNI*/
+			field->ltype_match = NPC_LT_LD_UDP_GTPU;
+			field->ltype_mask = 0xF;
+			break;
+		case NIX_FLOW_KEY_TYPE_UDP_VXLAN:
+		case NIX_FLOW_KEY_TYPE_UDP_GENEVE:
+			field->lid = NPC_LID_LD;
+			field->hdr_offset = 0; /* UDP data */
+			field->bytesm1 = 3; /* 4 bytes SPORT +  DPORT*/
+			field->ltype_mask = 0xF;
+			field_marker = false;
+			keyoff_marker = false;
+			BUILD_BUG_ON(NPC_LT_LD_UDP_VXLAN != 12);
+			BUILD_BUG_ON(NPC_LT_LD_UDP_GENEVE != 13);
+			/* Only VXLAN enabled */
+			if (key_type == NIX_FLOW_KEY_TYPE_UDP_VXLAN &&
+			    valid_key) {
+				field->ltype_match |= NPC_LT_LD_UDP_VXLAN;
+				udp_tu_data |= (1 << 0);
+			}
+
+			/* Only GENEVE enabled */
+			if (key_type == NIX_FLOW_KEY_TYPE_UDP_GENEVE &&
+			    valid_key) {
+				field->ltype_match |= NPC_LT_LD_UDP_GENEVE;
+				udp_tu_data |= (1 << 1);
+			}
+
+			if (key_type == NIX_FLOW_KEY_TYPE_UDP_GENEVE) {
+				valid_key = true;
+				field_marker = true;
+				keyoff_marker = true;
+				/* Both VXLAN and GENEVE enabled, just
+				 * update the ltype mask to match both
+				 * VXLAN and GENEVE
+				 */
+				if (udp_tu_data == 0x3)
+					field->ltype_mask = 0xE;
+			}
+			break;
+		case NIX_FLOW_KEY_TYPE_UDP_GTPU:
+			field->lid = NPC_LID_LD;
+			field->hdr_offset = 0; /* UDP data */
+			field->bytesm1 = 3; /* 4 bytes SPORT +  DPORT*/
+			field->ltype_match = NPC_LT_LD_UDP_GTPU;
+			field->ltype_mask = 0xF;
 			break;
 		}
 		field->ena = 1;
-- 
2.17.1


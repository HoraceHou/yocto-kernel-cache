From 4f98c52dca697848c2e3182db158a8ca8f9b638e Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Thu, 14 Mar 2019 21:51:41 -0700
Subject: [PATCH 050/386] mmc: cavium: drop obsolete Octeon version

replaced long ago with unified octeon/octeontx code

Change-Id: I49b068130e455b2434cbf9a985b55ea864abb24b
Signed-off-by: Peter Swain <pswain@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/5719
Reviewed-by: Chandrakala Chavva <Chandrakala.Chavva@cavium.com>
Tested-by: sa_ip-sw-jenkins
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 drivers/mmc/host/Kconfig              |  10 -
 drivers/mmc/host/Makefile             |   2 -
 drivers/mmc/host/cavium_mmc.h         | 346 --------------------------
 drivers/mmc/host/octeon_platdrv_mmc.c | 213 ----------------
 4 files changed, 571 deletions(-)
 delete mode 100644 drivers/mmc/host/cavium_mmc.h
 delete mode 100644 drivers/mmc/host/octeon_platdrv_mmc.c

diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 693978499d5d..0581c199c996 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -387,16 +387,6 @@ config MMC_SDHCI_ST
 	  If you have a controller with this interface, say Y or M here.
 	  If unsure, say N.
 
-config MMC_OCTEON
-	tristate "Cavium OCTEON SD/MMC Card Interface support"
-	depends on CAVIUM_OCTEON_SOC
-	help
-	  This selects Cavium OCTEON SD/MMC card Interface.
-	  If you have an OCTEON board with a Multimedia Card slot,
-	  say Y or M here.
-
-	  If unsure, say N.
-
 config MMC_OMAP
 	tristate "TI OMAP Multimedia Card Interface support"
 	depends on ARCH_OMAP
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index b1da9b6eb1c2..85dc1322c3de 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -23,8 +23,6 @@ obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 obj-$(CONFIG_MMC_MTK)		+= mtk-sd.o
-octeon_mmc-objs := cavium_core_mmc.o octeon_platdrv_mmc.o
-obj-$(CONFIG_MMC_OCTEON)	+= octeon_mmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_OMAP_HS)	+= omap_hsmmc.o
 obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.o
diff --git a/drivers/mmc/host/cavium_mmc.h b/drivers/mmc/host/cavium_mmc.h
deleted file mode 100644
index 481cb0e8293f..000000000000
--- a/drivers/mmc/host/cavium_mmc.h
+++ /dev/null
@@ -1,346 +0,0 @@
-/*
- * Driver for MMC and SSD cards for Cavium OCTEON and ThunderX SOCs.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2012-2016 Cavium Inc.
- */
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <linux/mmc/host.h>
-#include <linux/of.h>
-#include <linux/scatterlist.h>
-#include <linux/semaphore.h>
-
-#define CAVIUM_MAX_MMC		4
-
-#define MIO_EMM_DMA_CFG		0x00
-#define MIO_EMM_DMA_ADR		0x08
-
-#define MIO_EMM_CFG		0x00
-#define MIO_EMM_SWITCH		0x48
-#define MIO_EMM_DMA		0x50
-#define MIO_EMM_CMD		0x58
-#define MIO_EMM_RSP_STS		0x60
-#define MIO_EMM_RSP_LO		0x68
-#define MIO_EMM_RSP_HI		0x70
-#define MIO_EMM_INT		0x78
-#define MIO_EMM_INT_EN		0x80
-#define MIO_EMM_WDOG		0x88
-#define MIO_EMM_SAMPLE		0x90
-#define MIO_EMM_STS_MASK	0x98
-#define MIO_EMM_RCA		0xa0
-#define MIO_EMM_BUF_IDX		0xe0
-#define MIO_EMM_BUF_DAT		0xe8
-
-struct cvm_mmc_host {
-	struct device *dev;
-	void __iomem *base;
-	void __iomem *dma_base;
-	u64 emm_cfg;
-	u64 n_minus_one;	/* OCTEON II workaround location */
-	int last_slot;
-	struct clk *clk;
-	int sys_freq;
-
-	struct mmc_request *current_req;
-	struct sg_mapping_iter smi;
-	bool dma_active;
-
-	struct gpio_desc *global_pwr_gpiod;
-
-	struct cvm_mmc_slot *slot[CAVIUM_MAX_MMC];
-
-	void (*acquire_bus)(struct cvm_mmc_host *);
-	void (*release_bus)(struct cvm_mmc_host *);
-	void (*int_enable)(struct cvm_mmc_host *, u64);
-	/* required on some MIPS models */
-	void (*dmar_fixup)(struct cvm_mmc_host *, struct mmc_command *,
-			   struct mmc_data *, u64);
-	void (*dmar_fixup_done)(struct cvm_mmc_host *);
-};
-
-struct cvm_mmc_slot {
-	struct mmc_host *mmc;		/* slot-level mmc_core object */
-	struct cvm_mmc_host *host;	/* common hw for all slots */
-
-	u64 clock;
-	unsigned int sclock;
-
-	u64 cached_switch;
-	u64 cached_rca;
-
-	unsigned int cmd_cnt;		/* sample delay */
-	unsigned int dat_cnt;		/* sample delay */
-
-	int bus_width;
-	int bus_id;
-};
-
-struct cvm_mmc_cr_type {
-	u8 ctype;
-	u8 rtype;
-};
-
-struct cvm_mmc_cr_mods {
-	u8 ctype_xor;
-	u8 rtype_xor;
-};
-
-/* Bitfield definitions */
-
-union mio_emm_cmd {
-	u64 val;
-	struct mio_emm_cmd_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64 :2;
-		u64 bus_id:2;
-		u64 cmd_val:1;
-		u64 :3;
-		u64 dbuf:1;
-		u64 offset:6;
-		u64 :6;
-		u64 ctype_xor:2;
-		u64 rtype_xor:3;
-		u64 cmd_idx:6;
-		u64 arg:32;
-#else
-		u64 arg:32;
-		u64 cmd_idx:6;
-		u64 rtype_xor:3;
-		u64 ctype_xor:2;
-		u64 :6;
-		u64 offset:6;
-		u64 dbuf:1;
-		u64 :3;
-		u64 cmd_val:1;
-		u64 bus_id:2;
-		u64 :2;
-#endif
-	} s;
-};
-
-union mio_emm_dma {
-	u64 val;
-	struct mio_emm_dma_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64 :2;
-		u64 bus_id:2;
-		u64 dma_val:1;
-		u64 sector:1;
-		u64 dat_null:1;
-		u64 thres:6;
-		u64 rel_wr:1;
-		u64 rw:1;
-		u64 multi:1;
-		u64 block_cnt:16;
-		u64 card_addr:32;
-#else
-		u64 card_addr:32;
-		u64 block_cnt:16;
-		u64 multi:1;
-		u64 rw:1;
-		u64 rel_wr:1;
-		u64 thres:6;
-		u64 dat_null:1;
-		u64 sector:1;
-		u64 dma_val:1;
-		u64 bus_id:2;
-		u64 :2;
-#endif
-	} s;
-};
-
-union mio_emm_dma_cfg {
-	u64 val;
-	struct mio_emm_dma_cfg_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64 en:1;
-		u64 rw:1;
-		u64 clr:1;
-		u64 :1;
-		u64 swap32:1;
-		u64 swap16:1;
-		u64 swap8:1;
-		u64 endian:1;
-		u64 size:20;
-		u64 adr:36;
-#else
-		u64 adr:36;
-		u64 size:20;
-		u64 endian:1;
-		u64 swap8:1;
-		u64 swap16:1;
-		u64 swap32:1;
-		u64 :1;
-		u64 clr:1;
-		u64 rw:1;
-		u64 en:1;
-#endif
-	} s;
-};
-
-union mio_emm_io_ctl {
-	u64 val;
-	struct mio_emm_io_ctl_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64:60;
-		u64 drive:2;
-		u64:1;
-		u64 slew:1;
-#else
-		u64 slew:1;
-		u64:1;
-		u64 drive:2;
-		u64:60;
-#endif
-	} s;
-};
-
-union mio_emm_int {
-	u64 val;
-	struct mio_emm_int_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64:56;
-		u64 ncb_flt:1;
-		u64 switch_err:1;
-		u64 switch_done:1;
-		u64 dma_err:1;
-		u64 cmd_err:1;
-		u64 dma_done:1;
-		u64 cmd_done:1;
-		u64 buf_done:1;
-#else
-		u64 buf_done:1;
-		u64 cmd_done:1;
-		u64 dma_done:1;
-		u64 cmd_err:1;
-		u64 dma_err:1;
-		u64 switch_done:1;
-		u64 switch_err:1;
-		u64 ncb_flt:1;
-		u64:56;
-#endif
-	} s;
-};
-
-union mio_emm_rsp_sts {
-	u64 val;
-	struct mio_emm_rsp_sts_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64 :2;
-		u64 bus_id:2;
-		u64 cmd_val:1;
-		u64 switch_val:1;
-		u64 dma_val:1;
-		u64 dma_pend:1;
-		u64 :27;
-		u64 dbuf_err:1;
-		u64 :4;
-		u64 dbuf:1;
-		u64 blk_timeout:1;
-		u64 blk_crc_err:1;
-		u64 rsp_busybit:1;
-		u64 stp_timeout:1;
-		u64 stp_crc_err:1;
-		u64 stp_bad_sts:1;
-		u64 stp_val:1;
-		u64 rsp_timeout:1;
-		u64 rsp_crc_err:1;
-		u64 rsp_bad_sts:1;
-		u64 rsp_val:1;
-		u64 rsp_type:3;
-		u64 cmd_type:2;
-		u64 cmd_idx:6;
-		u64 cmd_done:1;
-#else
-		u64 cmd_done:1;
-		u64 cmd_idx:6;
-		u64 cmd_type:2;
-		u64 rsp_type:3;
-		u64 rsp_val:1;
-		u64 rsp_bad_sts:1;
-		u64 rsp_crc_err:1;
-		u64 rsp_timeout:1;
-		u64 stp_val:1;
-		u64 stp_bad_sts:1;
-		u64 stp_crc_err:1;
-		u64 stp_timeout:1;
-		u64 rsp_busybit:1;
-		u64 blk_crc_err:1;
-		u64 blk_timeout:1;
-		u64 dbuf:1;
-		u64 :4;
-		u64 dbuf_err:1;
-		u64 :27;
-		u64 dma_pend:1;
-		u64 dma_val:1;
-		u64 switch_val:1;
-		u64 cmd_val:1;
-		u64 bus_id:2;
-		u64 :2;
-#endif
-	} s;
-};
-
-union mio_emm_sample {
-	u64 val;
-	struct mio_emm_sample_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64 :38;
-		u64 cmd_cnt:10;
-		u64 :6;
-		u64 dat_cnt:10;
-#else
-		u64 dat_cnt:10;
-		u64 :6;
-		u64 cmd_cnt:10;
-		u64 :38;
-#endif
-	} s;
-};
-
-union mio_emm_switch {
-	u64 val;
-	struct mio_emm_switch_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-		u64 :2;
-		u64 bus_id:2;
-		u64 switch_exe:1;
-		u64 switch_err0:1;
-		u64 switch_err1:1;
-		u64 switch_err2:1;
-		u64 :7;
-		u64 hs_timing:1;
-		u64 :5;
-		u64 bus_width:3;
-		u64 :4;
-		u64 power_class:4;
-		u64 clk_hi:16;
-		u64 clk_lo:16;
-#else
-		u64 clk_lo:16;
-		u64 clk_hi:16;
-		u64 power_class:4;
-		u64 :4;
-		u64 bus_width:3;
-		u64 :5;
-		u64 hs_timing:1;
-		u64 :7;
-		u64 switch_err2:1;
-		u64 switch_err1:1;
-		u64 switch_err0:1;
-		u64 switch_exe:1;
-		u64 bus_id:2;
-		u64 :2;
-#endif
-	} s;
-};
-
-/* Protoypes */
-irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id);
-int cvm_mmc_slot_probe(struct device *dev, struct cvm_mmc_host *host);
-int cvm_mmc_slot_remove(struct cvm_mmc_slot *slot);
-extern const struct mmc_host_ops cvm_mmc_ops;
diff --git a/drivers/mmc/host/octeon_platdrv_mmc.c b/drivers/mmc/host/octeon_platdrv_mmc.c
deleted file mode 100644
index 59b73fb930a8..000000000000
--- a/drivers/mmc/host/octeon_platdrv_mmc.c
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Driver for MMC and SSD cards for Cavium OCTEON SOCs.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2012-2016 Cavium Inc.
- */
-#include <linux/gpio/consumer.h>
-#include <linux/interrupt.h>
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/slot-gpio.h>
-#include <linux/module.h>
-#include <linux/of_platform.h>
-#include <asm/octeon/octeon.h>
-#include "cavium_mmc.h"
-
-#define DRV_NAME "octeon_mmc"
-
-#define CVMX_MIO_BOOT_CTL CVMX_ADD_IO_SEG(0x00011800000000D0ull)
-
-extern void l2c_lock_mem_region(u64 start, u64 len);
-extern void l2c_unlock_mem_region(u64 start, u64 len);
-
-static void octeon_mmc_acquire_bus(struct cvm_mmc_host *host)
-{
-	/* Switch the MMC controller onto the bus. */
-	down(&octeon_bootbus_sem);
-	writeq(0, (void __iomem *)CVMX_MIO_BOOT_CTL);
-}
-
-static void octeon_mmc_release_bus(struct cvm_mmc_host *host)
-{
-	up(&octeon_bootbus_sem);
-}
-
-static void octeon_mmc_int_enable(struct cvm_mmc_host *host, u64 val)
-{
-	writeq(val, host->base + MIO_EMM_INT);
-	writeq(val, host->base + MIO_EMM_INT_EN);
-}
-
-static void octeon_mmc_dmar_fixup(struct cvm_mmc_host *host,
-				  struct mmc_command *cmd,
-				  struct mmc_data *data,
-				  u64 addr)
-{
-	if (cmd->opcode != MMC_WRITE_MULTIPLE_BLOCK)
-		return;
-	if (data->blksz * data->blocks <= 1024)
-		return;
-
-	host->n_minus_one = addr + (data->blksz * data->blocks) - 1024;
-	l2c_lock_mem_region(host->n_minus_one, 512);
-}
-
-static void octeon_mmc_dmar_fixup_done(struct cvm_mmc_host *host)
-{
-	if (!host->n_minus_one)
-		return;
-	l2c_unlock_mem_region(host->n_minus_one, 512);
-	host->n_minus_one = 0;
-}
-
-static int octeon_mmc_probe(struct platform_device *pdev)
-{
-	struct device_node *cn, *node = pdev->dev.of_node;
-	struct cvm_mmc_host *host;
-	struct resource	*res;
-	void __iomem *base;
-	int mmc_irq[9];
-	int i, ret = 0;
-	u64 val;
-
-	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
-	if (!host)
-		return -ENOMEM;
-
-	host->dev = &pdev->dev;
-	host->acquire_bus = octeon_mmc_acquire_bus;
-	host->release_bus = octeon_mmc_release_bus;
-	host->int_enable = octeon_mmc_int_enable;
-	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) ||
-	    OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
-		host->dmar_fixup = octeon_mmc_dmar_fixup;
-		host->dmar_fixup_done = octeon_mmc_dmar_fixup_done;
-	}
-
-	host->sys_freq = octeon_get_io_clock_rate();
-
-	/* First one is EMM second DMA */
-	for (i = 0; i < 2; i++) {
-		mmc_irq[i] = platform_get_irq(pdev, i);
-		if (mmc_irq[i] < 0)
-			return mmc_irq[i];
-	}
-	host->last_slot = -1;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Platform resource[0] is missing\n");
-		return -ENXIO;
-	}
-	base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(base))
-		return PTR_ERR(base);
-	host->base = (void __iomem *)base;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	if (!res) {
-		dev_err(&pdev->dev, "Platform resource[1] is missing\n");
-		return -EINVAL;
-	}
-	base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(base))
-		return PTR_ERR(base);
-	host->dma_base = (void __iomem *)base;
-
-	/*
-	 * Clear out any pending interrupts that may be left over from
-	 * bootloader.
-	 */
-	val = readq(host->base + MIO_EMM_INT);
-	writeq(val, host->base + MIO_EMM_INT);
-
-	ret = devm_request_irq(&pdev->dev, mmc_irq[0],
-			       cvm_mmc_interrupt, 0, DRV_NAME, host);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Error: devm_request_irq %d\n",
-			mmc_irq[0]);
-		return ret;
-	}
-
-	host->global_pwr_gpiod = devm_gpiod_get_optional(&pdev->dev, "power",
-							 GPIOD_OUT_HIGH);
-	if (IS_ERR(host->global_pwr_gpiod)) {
-		dev_err(&pdev->dev, "Invalid power GPIO\n");
-		return PTR_ERR(host->global_pwr_gpiod);
-	}
-
-	platform_set_drvdata(pdev, host);
-
-	for_each_child_of_node(node, cn) {
-		struct platform_device *slot_pdev;
-
-		slot_pdev = of_platform_device_create(cn, NULL, &pdev->dev);
-		ret = cvm_mmc_slot_probe(&slot_pdev->dev, host);
-		if (ret) {
-			dev_err(&pdev->dev, "Error populating slots\n");
-			gpiod_set_value_cansleep(host->global_pwr_gpiod, 0);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int octeon_mmc_remove(struct platform_device *pdev)
-{
-	union mio_emm_dma_cfg dma_cfg;
-	struct cvm_mmc_host *host = platform_get_drvdata(pdev);
-	int i;
-
-	for (i = 0; i < CAVIUM_MAX_MMC; i++)
-		if (host->slot[i])
-			cvm_mmc_slot_remove(host->slot[i]);
-
-	dma_cfg.val = readq(host->dma_base + MIO_EMM_DMA_CFG);
-	dma_cfg.s.en = 0;
-	writeq(dma_cfg.val, host->dma_base + MIO_EMM_DMA_CFG);
-
-	gpiod_set_value_cansleep(host->global_pwr_gpiod, 0);
-
-	return 0;
-}
-
-static const struct of_device_id octeon_mmc_match[] = {
-	{
-		.compatible = "cavium,octeon-6130-mmc",
-	},
-	{
-		.compatible = "cavium,octeon-7890-mmc",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, octeon_mmc_match);
-
-static struct platform_driver octeon_mmc_driver = {
-	.probe		= octeon_mmc_probe,
-	.remove		= octeon_mmc_remove,
-	.driver		= {
-		.name	= DRV_NAME,
-		.of_match_table = octeon_mmc_match,
-	},
-};
-
-static int __init octeon_mmc_init(void)
-{
-	return platform_driver_register(&octeon_mmc_driver);
-}
-
-static void __exit octeon_mmc_cleanup(void)
-{
-	platform_driver_unregister(&octeon_mmc_driver);
-}
-
-module_init(octeon_mmc_init);
-module_exit(octeon_mmc_cleanup);
-
-MODULE_AUTHOR("Cavium Inc. <support@cavium.com>");
-MODULE_DESCRIPTION("Low-level driver for Cavium OCTEON MMC/SSD card");
-MODULE_LICENSE("GPL");
-- 
2.17.1


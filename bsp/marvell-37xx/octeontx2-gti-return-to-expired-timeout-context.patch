From 7e27c3dd71148922e3fd9dc10e9802c686f2b46f Mon Sep 17 00:00:00 2001
From: Ashish Kalra <akalra@marvell.com>
Date: Sat, 22 Jun 2019 00:33:19 +0530
Subject: [PATCH 305/386] octeontx2: gti: return to expired timeout context.

Add support for returning to expired timeout kernel/user context
via EL3.

Currently, this GTI watchdog support is in-compatible with
CONFIG_UNMAP_KERNEL_AT_EL0 when invoked from expired user contexts.

Basically, when we do the exception return from EL3 to EL2,
and the kernel is unmapped, there is an instruction abort and as
there are no trampoline vectors setup for Current EL with SPx
exceptions, so these aborts are recursive and cause the machine
to hang.

In contrast when GTI CWD FIQ occurs while kernel context is active,
there is no issue to do an exception return from EL3 to EL2
as kernel is already mapped in and TTBR1_EL(1/2) and VBAR_EL(1/2)
are already correctly setup.

Change-Id: I01749fa08feeff23fc50d49ecad22c032b798c53
Signed-off-by: Ashish Kalra <akalra@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/11454
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Stefan Chulski <Stefan.Chulski@cavium.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 arch/arm64/kernel/entry.S              | 99 ++++++++++++++++++++++++--
 drivers/soc/marvell/gti/gti.c          | 16 +----
 drivers/soc/marvell/gti/gti.h          |  3 +-
 drivers/soc/marvell/gti/gti_watchdog.c | 20 ++----
 4 files changed, 102 insertions(+), 36 deletions(-)

diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
index 634df447a875..2162fa53eed9 100644
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@ -157,7 +157,11 @@ alternative_cb_end
 #endif
 	.endm
 
+#ifdef CONFIG_GTI_WATCHDOG
+	.macro	kernel_entry, el, regsize = 64, exc_el3 = 0
+#else
 	.macro	kernel_entry, el, regsize = 64
+#endif
 	.if	\regsize == 32
 	mov	w0, w0				// zero upper 32 bits of x0
 	.endif
@@ -204,7 +208,10 @@ alternative_cb_end
 	.endif /* \el == 0 */
 
 #ifdef CONFIG_GTI_WATCHDOG
-	.if	\el == 3
+	.if 	\exc_el3 == 0
+	mrs	x22, elr_el1
+	mrs	x23, spsr_el1
+	.else
 	/*
 	 * load elr, spsr in case of simulated exception return from
 	 * elr_el12, spsr_el12 which are used as scratch registers
@@ -214,12 +221,10 @@ alternative_cb_end
 	 */
 	mrs	x22, S3_5_C4_C0_1
 	mrs	x23, S3_5_C4_C0_0
-	.else
-#endif
+	.endif	/* \exc_el3 == 0 */
+#else
 	mrs	x22, elr_el1
 	mrs	x23, spsr_el1
-#ifdef CONFIG_GTI_WATCHDOG
-	.endif	/* \el == 3 */
 #endif
 	stp	lr, x21, [sp, #S_LR]
 
@@ -284,7 +289,11 @@ alternative_else_nop_endif
 	*/
 	.endm
 
-	.macro	kernel_exit, el
+#ifdef CONFIG_GTI_WATCHDOG
+	.macro  kernel_exit, el, exc_el3 = 0
+#else
+	.macro  kernel_exit, el
+#endif
 	.if	\el != 0
 	disable_daif
 
@@ -381,14 +390,35 @@ alternative_insn eret, nop, ARM64_UNMAP_KERNEL_AT_EL0
 #ifdef CONFIG_UNMAP_KERNEL_AT_EL0
 	bne	4f
 	msr	far_el1, x30
+#ifdef CONFIG_GTI_WATCHDOG
+	.if	\exc_el3 == 0
+	tramp_alias	x30, tramp_exit_native
+	.else
+	tramp_alias	x30, tramp_exit_native_el3
+	.endif
+#else
 	tramp_alias	x30, tramp_exit_native
+#endif
 	br	x30
 4:
+#ifdef CONFIG_GTI_WATCHDOG
+	.if	\exc_el3 == 0
+	tramp_alias	x30, tramp_exit_compat
+	.else
+	tramp_alias	x30, tramp_exit_compat_el3
+	.endif
+#else
 	tramp_alias	x30, tramp_exit_compat
+#endif
 	br	x30
 #endif
+#ifdef CONFIG_GTI_WATCHDOG
+	.elseif	\exc_el3 == 0
+	eret
+#else
 	.else
 	eret
+#endif
 	.endif
 	.endm
 
@@ -914,6 +944,7 @@ el0_error_naked:
 ENDPROC(el0_error)
 
 #ifdef CONFIG_GTI_WATCHDOG
+
 .globl el1_nmi_callback
 el1_nmi_callback:
        /*
@@ -921,9 +952,37 @@ el1_nmi_callback:
         * exception entry and pstate are loaded from ELR_ELx and SPSR_ELx.
         */
        sub     sp, sp, #S_FRAME_SIZE
-       kernel_entry 3
+       mrs     x8, S3_5_C13_C0_1               // contextidr_el12
+       cbnz    x8, el2_context_entry
+       kernel_entry 0, 64, 1
+       b       invoke_callback
+el2_context_entry:
+       kernel_entry 1, 64, 1
+invoke_callback:
        mov     x0, sp
        bl      nmi_kernel_callback
+       cbnz    x8, el2_context_exit
+       kernel_exit 0, 1
+       b       ret_back_to_el3
+el2_context_exit:
+       kernel_exit 1, 1
+ret_back_to_el3:
+       /*
+        * We return back to the interrupted context via EL3,
+        * as we need to do cleanup in ATF before restoring
+        * interrupted context such as dropping lock and
+        * do interrupt completion, etc.
+        */
+       mov     x0, #0xc04                      // #0xc2000c04
+       mov     x7, #0x0                        // #0
+       movk    x0, #0xc200, lsl #16
+       mov     x6, #0x0                        // #0
+       mov     x5, #0x0                        // #0
+       mov     x4, #0x0                        // #0
+       mov     x3, #0x0                        // #0
+       mov     x1, #0x0                        // #0
+       smc     #0x0
+
 #endif
 
 /*
@@ -1123,14 +1182,30 @@ alternative_insn isb, nop, ARM64_WORKAROUND_QCOM_FALKOR_E1003
 	ret
 	.endm
 
+#ifdef CONFIG_GTI_WATCHDOG
+	.macro tramp_exit, regsize = 64, exc_el3 = 0
+#else
 	.macro tramp_exit, regsize = 64
+#endif
 	adr	x30, tramp_vectors
 	msr	vbar_el1, x30
 	tramp_unmap_kernel	x30
 	.if	\regsize == 64
 	mrs	x30, far_el1
 	.endif
+#ifdef CONFIG_GTI_WATCHDOG
+	.if \exc_el3 == 0
+	eret
+	.else
+	/*
+	 * Cannot do an eret here as we have not
+	 * entered from a real exception.
+	 */
+	b	ret_back_to_el3
+	.endif
+#else
 	eret
+#endif
 	.endm
 
 	.align	11
@@ -1156,6 +1231,16 @@ ENTRY(tramp_exit_compat)
 	tramp_exit	32
 END(tramp_exit_compat)
 
+#ifdef CONFIG_GTI_WATCHDOG
+ENTRY(tramp_exit_native_el3)
+	tramp_exit	64, 1
+END(tramp_exit_native_el3)
+
+ENTRY(tramp_exit_compat_el3)
+	tramp_exit	32, 1
+END(tramp_exit_compat_el3)
+#endif
+
 	.ltorg
 	.popsection				// .entry.tramp.text
 #ifdef CONFIG_RANDOMIZE_BASE
diff --git a/drivers/soc/marvell/gti/gti.c b/drivers/soc/marvell/gti/gti.c
index 5980f793d006..7c3d7845d95f 100644
--- a/drivers/soc/marvell/gti/gti.c
+++ b/drivers/soc/marvell/gti/gti.c
@@ -9,17 +9,15 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/arm-smccc.h>
 #include <linux/cpu.h>
 #include <linux/nmi.h>
 #include <linux/module.h>
 #include <linux/irq.h>
+#include <linux/interrupt.h>
 #include <linux/sched/debug.h>
 
 #include "gti.h"
 
-#define GTI_CWD_WDOG_POKE(a) (0x50000ll + 8ll * ((a) & 0x3f))
-
 /* Kernel exception simulation wrapper for the NMI callback */
 void nmi_kernel_callback_other_cpus(void *unused)
 {
@@ -60,15 +58,7 @@ void nmi_kernel_callback(struct pt_regs *regs)
 	}
 
 	/*
-	 * FIXME: Add a new SMC interface to clear a per-core watchdog.
-	 * Also, importantly add support for recovery here and return to the
-	 * interrupted state via el3.
+	 * Return to the interrupted state via el3 and attempt
+	 * application recovery.
 	 */
-	for (;;) {
-		/* Poke the Watchdog */
-		if (g_gti_devmem) {
-			writeq(0, g_gti_devmem +
-				GTI_CWD_WDOG_POKE(raw_smp_processor_id()));
-		}
-	}
 }
diff --git a/drivers/soc/marvell/gti/gti.h b/drivers/soc/marvell/gti/gti.h
index 18ac17cd783b..c1b52588a921 100644
--- a/drivers/soc/marvell/gti/gti.h
+++ b/drivers/soc/marvell/gti/gti.h
@@ -10,8 +10,9 @@
 
 #define OCTEONTX_INSTALL_WDOG           0xc2000c01
 #define OCTEONTX_REMOVE_WDOG            0xc2000c02
+#define OCTEONTX_START_WDOG		0xc2000c03
+#define OCTEONTX_RESTORE_WDOG_CTXT	0xc2000c04
 
 /* Kernel exception simulation wrapper for the NMI callback */
 extern void el1_nmi_callback(void);
 void nmi_kernel_callback(struct pt_regs *regs);
-extern void __iomem *g_gti_devmem;
diff --git a/drivers/soc/marvell/gti/gti_watchdog.c b/drivers/soc/marvell/gti/gti_watchdog.c
index b77e48938762..63d276433613 100644
--- a/drivers/soc/marvell/gti/gti_watchdog.c
+++ b/drivers/soc/marvell/gti/gti_watchdog.c
@@ -55,7 +55,6 @@ struct set_watchdog_args {
 };
 
 static unsigned long g_mmio_base;
-void __iomem *g_gti_devmem;
 
 static void cleanup_gti_watchdog(void)
 {
@@ -81,15 +80,12 @@ static int gti_wdog_close(struct inode *inode, struct file *file)
 
 void install_gti_cwd_wdog_secondary_cores(void *arg)
 {
-	struct set_watchdog_args *watchdog_args =
-		(struct set_watchdog_args *)arg;
 	struct arm_smccc_res res;
 
 	pr_info("Installing GTI CWD on CPU %d\n", raw_smp_processor_id());
 
-	arm_smccc_smc(OCTEONTX_INSTALL_WDOG, (uintptr_t)&el1_nmi_callback,
-		smp_processor_id(), watchdog_args->watchdog_timeout_ms,
-		watchdog_args->core_mask, 0, 0, 0, &res);
+	arm_smccc_smc(OCTEONTX_INSTALL_WDOG, smp_processor_id(),
+		 0, 0, 0, 0, 0, 0, &res);
 
 	if (!res.a0)
 		pr_warn("Failed to install watchdog handler on core %d : %ld\n",
@@ -116,11 +112,9 @@ void install_gti_cwd_wdog_all_cores(struct set_watchdog_args *watchdog_args)
 	 * enables the interrupts.
 	 */
 
-	pr_info("Setting and enable wdog timer on core %d\n", nr_cpu_ids);
-
-	arm_smccc_smc(OCTEONTX_INSTALL_WDOG, (uintptr_t)&el1_nmi_callback,
-		nr_cpu_ids, watchdog_args->watchdog_timeout_ms,
-		watchdog_args->core_mask, 0, 0, 0, &res);
+	arm_smccc_smc(OCTEONTX_START_WDOG, (uintptr_t)&el1_nmi_callback,
+		watchdog_args->watchdog_timeout_ms, watchdog_args->core_mask,
+		0, 0, 0, 0, &res);
 
 	if (!res.a0)
 		pr_warn("Failed to install watchdog handler on core %d : %ld\n",
@@ -223,10 +217,6 @@ static int gti_wdog_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	end = pci_resource_end(pdev, GTI_PF_BAR0);
 	g_mmio_base = start;
 
-	g_gti_devmem = pcim_iomap(pdev, GTI_PF_BAR0, 0);
-	if (!g_gti_devmem)
-		dev_warn(&pdev->dev, "Could not ioremap gti device memory\n");
-
 	err = misc_register(&gti_wdog_miscdevice);
 	if (err != 0) {
 		dev_err(&pdev->dev, "Failed to register misc device\n");
-- 
2.17.1


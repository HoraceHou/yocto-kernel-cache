From dc86906d19992187b7d46d1e1b667f2af5a7d54c Mon Sep 17 00:00:00 2001
From: Christina Jacob <cjacob@marvell.com>
Date: Tue, 26 Mar 2019 11:18:30 +0530
Subject: [PATCH 077/386] octeontx2-af : Patch to prevent redundant message
 from pf to af.

Prevents queuing multiple work for the same mailbox message.
Situation occurs when pf sends a second message to af that
has to be handled by a different mailbox while another
mailbox message is being processed.

Change-Id: Ibefcd448662165c4482c3d100ff1ce689fb8152f
Signed-off-by: Christina Jacob <cjacob@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/6332
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.c   | 38 +++++++++++++++----
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |  2 +
 2 files changed, 33 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index f3efb6837264..334f84a97343 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -1589,12 +1589,12 @@ static void __rvu_mbox_handler(struct rvu_work *mwork, int type)
 
 	/* Process received mbox messages */
 	req_hdr = mdev->mbase + mbox->rx_start;
-	if (req_hdr->num_msgs == 0)
+	if (mw->num_msgs == 0)
 		return;
 
 	offset = mbox->rx_start + ALIGN(sizeof(*req_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < req_hdr->num_msgs; id++) {
+	for (id = 0; id < mw->num_msgs; id++) {
 		msg = mdev->mbase + offset;
 
 		/* Set which PF/VF sent this message based on mbox IRQ */
@@ -1627,7 +1627,12 @@ static void __rvu_mbox_handler(struct rvu_work *mwork, int type)
 				 err, otx2_mbox_id2name(msg->id),
 				 msg->id, devid);
 	}
+		/* mbox messages in the same direction to be handled by same
+		 * mailbox occurs serially. So write to mw->num_msgs happens
+		 * only after the previous context is done with it.
+		 */
 
+	mw->num_msgs = 0;
 	/* Send mbox responses to VF/PF */
 	otx2_mbox_msg_send(mbox, devid);
 }
@@ -1672,14 +1677,14 @@ static void __rvu_mbox_up_handler(struct rvu_work *mwork, int type)
 	mdev = &mbox->dev[devid];
 
 	rsp_hdr = mdev->mbase + mbox->rx_start;
-	if (rsp_hdr->num_msgs == 0) {
+	if (mw->up_num_msgs == 0) {
 		dev_warn(rvu->dev, "mbox up handler: num_msgs = 0\n");
 		return;
 	}
 
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+	for (id = 0; id < mw->up_num_msgs; id++) {
 		msg = mdev->mbase + offset;
 
 		if (msg->id >= MBOX_MSG_MAX) {
@@ -1709,6 +1714,11 @@ static void __rvu_mbox_up_handler(struct rvu_work *mwork, int type)
 		offset = mbox->rx_start + msg->next_msgoff;
 		mdev->msgs_acked++;
 	}
+		/* mbox messages in the same direction to be handled by same
+		 * mailbox occurs serially. So write to mw->up_num_msgs
+		 * happens only after the previous context is done with it.
+		 */
+	mw->up_num_msgs = 0;
 
 	otx2_mbox_reset(mbox, devid);
 }
@@ -1846,14 +1856,28 @@ static void rvu_queue_work(struct mbox_wq_info *mw, int first,
 		mbox = &mw->mbox;
 		mdev = &mbox->dev[i];
 		hdr = mdev->mbase + mbox->rx_start;
-		if (hdr->num_msgs)
-			queue_work(mw->mbox_wq, &mw->mbox_wrk[i].work);
 
+		/*The hdr->num_msgs is set to zero immediately in the interrupt
+		 * handler to  ensure that it holds a correct value next time
+		 * when the interrupt handler is called.
+		 * pf->mbox.num_msgs holds the data for use in pfaf_mbox_handler
+		 * pf>mbox.up_num_msgs holds the data for use in
+		 * pfaf_mbox_up_handler.
+		 */
+
+		if (hdr->num_msgs) {
+			mw->num_msgs = hdr->num_msgs;
+			hdr->num_msgs = 0;
+			queue_work(mw->mbox_wq, &mw->mbox_wrk[i].work);
+		}
 		mbox = &mw->mbox_up;
 		mdev = &mbox->dev[i];
 		hdr = mdev->mbase + mbox->rx_start;
-		if (hdr->num_msgs)
+		if (hdr->num_msgs) {
+			mw->up_num_msgs = hdr->num_msgs;
+			hdr->num_msgs = 0;
 			queue_work(mw->mbox_wq, &mw->mbox_wrk_up[i].work);
+		}
 	}
 }
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index a4da3e9c50d9..28159e93f26f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -352,6 +352,8 @@ struct mbox_wq_info {
 	struct rvu_work *mbox_wrk_up;
 
 	struct workqueue_struct *mbox_wq;
+	int num_msgs;
+	int up_num_msgs;
 };
 
 struct rvu_fwdata {
-- 
2.17.1


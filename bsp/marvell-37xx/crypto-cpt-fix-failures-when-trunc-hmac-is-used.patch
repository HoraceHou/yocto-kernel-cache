From d3afec469f7d1ecb120bc5fd05645fd7cbf96a78 Mon Sep 17 00:00:00 2001
From: Lukasz Bartosik <lbartosik@marvell.com>
Date: Thu, 25 Apr 2019 12:30:37 +0200
Subject: [PATCH 189/386] crypto: cpt - fix failures when trunc hmac is used

Fix failures in authenc(hmac, ecb(null)) mode when truncated
hmac is used. This is workaround which should be removed
when ucode provides support for null cipher in FC.

Change-Id: Ibdd64106cdd5dcdfb6d971b1e6f6299beec3729e
Signed-off-by: Lukasz Bartosik <lbartosik@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/8060
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Srujana Challa <schalla@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c      | 13 +++++++++++++
 drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c      | 13 +++++++++++++
 drivers/crypto/cavium/cpt/common/cpt_algs.c      | 16 ++++++++++++++++
 .../crypto/cavium/cpt/common/cpt_algs_internal.h |  1 +
 drivers/crypto/cavium/cpt/common/cpt_common.h    |  1 +
 drivers/crypto/cavium/cpt/common/cpt_hw_types.h  | 16 ++++++++++++++++
 6 files changed, 60 insertions(+)

diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c b/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c
index 37ec802746e3..8f18048f3063 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c
@@ -73,6 +73,19 @@ static int cpt8x_process_ccode(struct pci_dev *pdev,
 	case CPT_8X_COMP_E_GOOD:
 		/* Check microcode completion code */
 		if (ecode.s.ccode) {
+			/* If requested hmac is truncated and ucode returns
+			 * s/g write length error then we report success
+			 * because ucode writes as many bytes of calculated
+			 * hmac as available in gather buffer and reports
+			 * s/g write length error if number of bytes in gather
+			 * buffer is less than full hmac size.
+			 */
+			if (req->is_trunc_hmac &&
+			    ecode.s.ccode == ERR_SCATTER_GATHER_WRITE_LENGTH) {
+				*res_code = 0;
+				break;
+			}
+
 			dev_err(&pdev->dev,
 				"Request failed with software error code 0x%x\n",
 				ecode.s.ccode);
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c b/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c
index 7229c6a73043..09ed0dea760f 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c
@@ -72,6 +72,19 @@ static int cpt9x_process_ccode(struct pci_dev *pdev,
 		 * when completion code is CPT_COMP_E::GOOD
 		 */
 		if (cpt_status->s9x.uc_compcode) {
+			/* If requested hmac is truncated and ucode returns
+			 * s/g write length error then we report success
+			 * because ucode writes as many bytes of calculated
+			 * hmac as available in gather buffer and reports
+			 * s/g write length error if number of bytes in gather
+			 * buffer is less than full hmac size.
+			 */
+			if (req->is_trunc_hmac && cpt_status->s9x.uc_compcode
+			    == ERR_SCATTER_GATHER_WRITE_LENGTH) {
+				*res_code = 0;
+				break;
+			}
+
 			dev_err(&pdev->dev,
 				"Request failed with software error code 0x%x\n",
 				cpt_status->s9x.uc_compcode);
diff --git a/drivers/crypto/cavium/cpt/common/cpt_algs.c b/drivers/crypto/cavium/cpt/common/cpt_algs.c
index 2d48481544a0..bd41ade6a092 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_algs.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_algs.c
@@ -285,6 +285,7 @@ static inline int cvm_enc_dec(struct ablkcipher_request *req, u32 enc)
 	req_info->callback = (void *)cvm_callback;
 	req_info->areq = &req->base;
 	req_info->req_type = ENC_DEC_REQ;
+	req_info->is_trunc_hmac = false;
 	if (!ops->cpt_get_kcrypto_eng_grp_num)
 		return -EFAULT;
 	req_info->ctrl.s.grp = ops->cpt_get_kcrypto_eng_grp_num(pdev);
@@ -544,24 +545,36 @@ static int cvm_aead_set_authsize(struct crypto_aead *tfm,
 		if (authsize != SHA1_DIGEST_SIZE &&
 		    authsize != SHA1_TRUNC_DIGEST_SIZE)
 			return -EINVAL;
+
+		if (authsize == SHA1_TRUNC_DIGEST_SIZE)
+			ctx->is_trunc_hmac = true;
 		break;
 
 	case SHA256:
 		if (authsize != SHA256_DIGEST_SIZE &&
 		    authsize != SHA256_TRUNC_DIGEST_SIZE)
 			return -EINVAL;
+
+		if (authsize == SHA256_TRUNC_DIGEST_SIZE)
+			ctx->is_trunc_hmac = true;
 		break;
 
 	case SHA384:
 		if (authsize != SHA384_DIGEST_SIZE &&
 		    authsize != SHA384_TRUNC_DIGEST_SIZE)
 			return -EINVAL;
+
+		if (authsize == SHA384_TRUNC_DIGEST_SIZE)
+			ctx->is_trunc_hmac = true;
 		break;
 
 	case SHA512:
 		if (authsize != SHA512_DIGEST_SIZE &&
 		    authsize != SHA512_TRUNC_DIGEST_SIZE)
 			return -EINVAL;
+
+		if (authsize == SHA512_TRUNC_DIGEST_SIZE)
+			ctx->is_trunc_hmac = true;
 		break;
 
 	case MAC_NULL:
@@ -957,6 +970,8 @@ static inline u32 create_hmac_ctx_hdr(struct aead_request *req, u32 *argcnt,
 	req_info->ctrl.s.se_req = SE_CORE_REQ;
 	req_info->req.opcode.s.major = MAJOR_OP_HMAC |
 				 DMA_MODE_FLAG(DMA_GATHER_SCATTER);
+	req_info->is_trunc_hmac = ctx->is_trunc_hmac;
+
 	req_info->req.opcode.s.minor = 0;
 	req_info->req.param1 = ctx->auth_key_len;
 	req_info->req.param2 = ctx->mac_type << 8;
@@ -1126,6 +1141,7 @@ u32 cvm_aead_enc_dec(struct aead_request *req, u8 reg_type, u8 enc)
 	req_info->areq = &req->base;
 	req_info->req_type = reg_type;
 	req_info->is_enc = enc;
+	req_info->is_trunc_hmac = false;
 
 	switch (reg_type) {
 	case AEAD_ENC_DEC_REQ:
diff --git a/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h b/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h
index 2ae0817aed55..54257ccc441d 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h
@@ -194,6 +194,7 @@ struct cvm_aead_ctx {
 	u8 cipher_type;
 	u8 mac_type;
 	u8 key_type;
+	u8 is_trunc_hmac;
 };
 
 #endif /*__CPT_ALGS_INTERNAL_H_*/
diff --git a/drivers/crypto/cavium/cpt/common/cpt_common.h b/drivers/crypto/cavium/cpt/common/cpt_common.h
index 64d16ab36d6c..03b7ec6c5330 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_common.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_common.h
@@ -204,6 +204,7 @@ struct cpt_request_info {
 	u8 outcnt; /* Number of output buffers */
 	u8 req_type; /* Type of request */
 	u8 is_enc; /* Is a request an encryption request */
+	u8 is_trunc_hmac; /* Is truncated hmac used */
 };
 
 struct cpt_info_buffer {
diff --git a/drivers/crypto/cavium/cpt/common/cpt_hw_types.h b/drivers/crypto/cavium/cpt/common/cpt_hw_types.h
index 907ff6b7ec12..252cf14ca276 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_hw_types.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_hw_types.h
@@ -169,6 +169,22 @@
 #define CPT_LF_Q_GRP_PTR                (0x120ull)
 #define CPT_LF_NQX(a)                   (0x400ull | (u64)(a) << 3)
 
+/**
+ * Enumeration cpt_ucode_error_code_e
+ *
+ * Enumerates ucode errors
+ */
+enum cpt_ucode_error_code_e {
+	NO_ERROR = 0x00,
+	ERR_OPCODE_UNSUPPORTED = 0x01,
+
+	/* Scatter gather */
+	ERR_SCATTER_GATHER_WRITE_LENGTH = 0x02,
+	ERR_SCATTER_GATHER_LIST = 0x03,
+	ERR_SCATTER_GATHER_NOT_SUPPORTED = 0x04,
+
+};
+
 /**
  * Enumeration cpt_8x_comp_e
  *
-- 
2.17.1


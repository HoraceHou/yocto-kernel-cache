From c0a859e24122a1196d994bed11cd9117f0c28b8c Mon Sep 17 00:00:00 2001
From: Christina Jacob <cjacob@marvell.com>
Date: Tue, 26 Mar 2019 15:29:46 +0530
Subject: [PATCH 079/386] octeontx2-pf: Fixing redundant message from af to pf.

We are using the same interrupt line for mailbox communications in both
up and down directions. When there are two mailbox messages in the same
direction that has to be handled by different mboxes, in cases where
the processing of first message is mid way and interrupt handler gets
invoked on a second message, another work is queued for the first message
again as the num_msgs is not set to zero yet.
Fixing this by introducing another variable that would get updated
inside interrupt handler and setting num_msgs to zero inside interrupt
handler itself.

Change-Id: Ia3a404b312369f8f0f6252236a6cb76ac9364e4c
Signed-off-by: Christina Jacob <cjacob@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/6334
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../marvell/octeontx2/nic/otx2_common.h       |  7 +-
 .../ethernet/marvell/octeontx2/nic/otx2_pf.c  | 82 +++++++++++++------
 .../ethernet/marvell/octeontx2/nic/otx2_vf.c  | 24 ++++--
 3 files changed, 78 insertions(+), 35 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
index f9c2d2e03f57..e00d8f95f6d7 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
@@ -101,8 +101,11 @@ struct  mbox {
 	struct otx2_mbox	mbox_up;
 	struct work_struct	mbox_up_wrk;
 	struct otx2_nic		*pfvf;
-	void *bbuf_base; /* Bounce buffer for mbox memory */
-	atomic_t		lock; /* serialize mailbox access */
+	void			*bbuf_base; /* Bounce buffer for mbox memory */
+	atomic_t		lock;	/* serialize mailbox access */
+	int			num_msgs; /*mbox number of messages*/
+	int			up_num_msgs;/* mbox_up number of messages*/
+
 };
 
 struct otx2_hw {
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
index ddeb3fd51180..951b0eed6e5e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
@@ -58,15 +58,34 @@ static void otx2_queue_work(struct mbox *mw, struct workqueue_struct *mbox_wq,
 		mdev = &mbox->dev[i];
 		otx2_sync_mbox_bbuf(mbox, i);
 		hdr = mdev->mbase + mbox->rx_start;
-		if (hdr->num_msgs)
-			queue_work(mbox_wq, &mw[i].mbox_wrk);
+		/*The hdr->num_msgs is set to zero immediately in the interrupt
+		 * handler to  ensure that it holds a correct value next time
+		 * when the interrupt handler is called.
+		 * pf->mbox.num_msgs holds the data for use in pfaf_mbox_handler
+		 * pf>mbox.up_num_msgs holds the data for use in
+		 * pfaf_mbox_up_handler.
+		 */
+		if (hdr->num_msgs) {
+			mw->num_msgs = hdr->num_msgs;
+			hdr->num_msgs = 0;
+			memset(mbox->hwbase + mbox->rx_start, 0,
+			       ALIGN(sizeof(struct mbox_hdr), sizeof(u64)));
 
+			queue_work(mbox_wq, &mw[i].mbox_wrk);
+		}
 		mbox = &mw->mbox_up;
 		mdev = &mbox->dev[i];
 		otx2_sync_mbox_bbuf(mbox, i);
 		hdr = mdev->mbase + mbox->rx_start;
-		if (hdr->num_msgs)
+		if (hdr->num_msgs) {
+			mw->up_num_msgs = hdr->num_msgs;
+			hdr->num_msgs = 0;
+			memset(mbox->hwbase + mbox->rx_start, 0,
+			       ALIGN(sizeof(struct mbox_hdr), sizeof(u64)));
+
 			queue_work(mbox_wq, &mw[i].mbox_up_wrk);
+		}
+
 	}
 }
 
@@ -165,10 +184,10 @@ static int otx2_forward_vf_mbox_msgs(struct otx2_nic *pf,
 
 static void otx2_pfvf_mbox_handler(struct work_struct *work)
 {
+	struct mbox_msghdr *msg = NULL;
 	int offset, vf_idx, id, err;
 	struct otx2_mbox_dev *mdev;
 	struct mbox_hdr *req_hdr;
-	struct mbox_msghdr *msg;
 	struct otx2_mbox *mbox;
 	struct mbox *vf_mbox;
 	struct otx2_nic *pf;
@@ -176,17 +195,16 @@ static void otx2_pfvf_mbox_handler(struct work_struct *work)
 	vf_mbox = container_of(work, struct mbox, mbox_wrk);
 	pf = vf_mbox->pfvf;
 	vf_idx = vf_mbox - pf->mbox_pfvf;
-
 	vf_mbox = &pf->mbox_pfvf[0];
 	mbox = &vf_mbox->mbox;
 	mdev = &mbox->dev[vf_idx];
 	req_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (req_hdr->num_msgs == 0 || req_hdr->msg_size == 0)
+	if (vf_mbox->num_msgs == 0)
 		return;
 
 	offset = ALIGN(sizeof(*req_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < req_hdr->num_msgs; id++) {
+	for (id = 0; id < vf_mbox->num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + mbox->rx_start +
 					     offset);
 
@@ -198,7 +216,11 @@ static void otx2_pfvf_mbox_handler(struct work_struct *work)
 		msg->pcifunc |= (vf_idx + 1) & RVU_PFVF_FUNC_MASK;
 		offset = msg->next_msgoff;
 	}
-
+	/* mbox messages in the same direction to be handled by same
+	 * mailbox occurs serially. So write to vf_mbox->num_msgs
+	 * happens only after the previous context is done with it.
+	 */
+	vf_mbox->num_msgs = 0;
 	err = otx2_forward_vf_mbox_msgs(pf, mbox, MBOX_DIR_PFAF, vf_idx);
 	if (err)
 		goto inval_msg;
@@ -211,29 +233,26 @@ static void otx2_pfvf_mbox_handler(struct work_struct *work)
 
 static void otx2_pfvf_mbox_up_handler(struct work_struct *work)
 {
+	struct mbox *vf_mbox = container_of(work, struct mbox, mbox_up_wrk);
+	struct otx2_nic *pf = vf_mbox->pfvf;
 	struct otx2_mbox_dev *mdev;
+	int offset, id, vf_idx = 0;
 	struct mbox_hdr *rsp_hdr;
 	struct mbox_msghdr *msg;
 	struct otx2_mbox *mbox;
-	int offset, id, vf_idx;
-	struct mbox *vf_mbox;
-	struct otx2_nic *pf;
 
-	vf_mbox = container_of(work, struct mbox, mbox_up_wrk);
-	pf = vf_mbox->pfvf;
 	vf_idx = vf_mbox - pf->mbox_pfvf;
-
 	vf_mbox = &pf->mbox_pfvf[0];
 	mbox = &vf_mbox->mbox_up;
 	mdev = &mbox->dev[vf_idx];
 
-	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (rsp_hdr->num_msgs == 0)
+	if (vf_mbox->up_num_msgs == 0)
 		return;
 
+	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+	for (id = 0; id < vf_mbox->up_num_msgs; id++) {
 		msg = mdev->mbase + offset;
 
 		if (msg->id >= MBOX_MSG_MAX) {
@@ -264,6 +283,11 @@ static void otx2_pfvf_mbox_up_handler(struct work_struct *work)
 		offset = mbox->rx_start + msg->next_msgoff;
 		mdev->msgs_acked++;
 	}
+	/* mbox messages in the same direction to be handled by same
+	 * mailbox occurs serially. So write to vf_mbox->up_num_msgs
+	 * happens only after the previous context is done with it.
+	 */
+	vf_mbox->up_num_msgs = 0;
 
 	otx2_mbox_reset(mbox, vf_idx);
 }
@@ -533,19 +557,23 @@ static void otx2_pfaf_mbox_handler(struct work_struct *work)
 	mbox = &af_mbox->mbox;
 	mdev = &mbox->dev[0];
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (rsp_hdr->num_msgs == 0)
+	if (af_mbox->num_msgs == 0)
 		return;
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 	pf = af_mbox->pfvf;
 
-	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+	for (id = 0; id < af_mbox->num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 		devid = msg->pcifunc & RVU_PFVF_FUNC_MASK;
 		otx2_process_pfaf_mbox_msg(pf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
 		mdev->msgs_acked++;
 	}
-
+	/* mbox messages in the same direction to be handled by same
+	 * mailbox occurs serially. So write to af_mbox->num_msgs
+	 * happens only after the previous context is done with it.
+	 */
+	af_mbox->num_msgs = 0;
 	otx2_mbox_reset(mbox, 0);
 
 	if (devid)
@@ -645,19 +673,19 @@ static void otx2_pfaf_mbox_up_handler(struct work_struct *work)
 {
 	struct mbox *af_mbox = container_of(work, struct mbox, mbox_up_wrk);
 	struct otx2_mbox *mbox = &af_mbox->mbox_up;
-	struct otx2_nic *pf = af_mbox->pfvf;
 	struct otx2_mbox_dev *mdev = &mbox->dev[0];
+	struct otx2_nic *pf = af_mbox->pfvf;
+	int offset, id, devid = 0;
 	struct mbox_hdr *rsp_hdr;
 	struct mbox_msghdr *msg;
-	int offset, id, devid;
 
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (rsp_hdr->num_msgs == 0)
+	if (af_mbox->up_num_msgs == 0)
 		return;
 
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+	for (id = 0; id < af_mbox->up_num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 
 		devid = msg->pcifunc & RVU_PFVF_FUNC_MASK;
@@ -666,7 +694,11 @@ static void otx2_pfaf_mbox_up_handler(struct work_struct *work)
 			otx2_process_mbox_msg_up(pf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
 	}
-
+	/* mbox messages in the same direction to be handled by same
+	 * mailbox occurs serially. So write to af_mbox->up_num_msgs
+	 * happens only after the previous context is done with it.
+	 */
+	af_mbox->up_num_msgs = 0;
 	if (devid) {
 		otx2_forward_vf_mbox_msgs(pf, &pf->mbox.mbox_up,
 					  MBOX_DIR_PFVF_UP, devid - 1);
diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
index 1d145fbe4fa5..e6efc0ba8fb1 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
@@ -102,11 +102,11 @@ static void otx2vf_vfaf_mbox_handler(struct work_struct *work)
 	mbox = &af_mbox->mbox;
 	mdev = &mbox->dev[0];
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (rsp_hdr->num_msgs == 0)
+	if (af_mbox->num_msgs == 0)
 		return;
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+	for (id = 0; id < af_mbox->num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 		otx2vf_process_vfaf_mbox_msg(af_mbox->pfvf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
@@ -176,12 +176,12 @@ static void otx2vf_vfaf_mbox_up_handler(struct work_struct *work)
 	mdev = &mbox->dev[0];
 
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (rsp_hdr->num_msgs == 0)
+	if (vf_mbox->up_num_msgs == 0)
 		return;
 
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+	for (id = 0; id < vf_mbox->up_num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 		otx2vf_process_mbox_msg_up(vf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
@@ -206,18 +206,26 @@ static irqreturn_t otx2vf_vfaf_mbox_intr_handler(int irq, void *vf_irq)
 	otx2_sync_mbox_bbuf(mbox, 0);
 
 	hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (hdr->num_msgs)
+	if (hdr->num_msgs) {
+		vf->mbox.num_msgs = hdr->num_msgs;
+		hdr->num_msgs = 0;
+		memset(mbox->hwbase + mbox->rx_start, 0,
+		       ALIGN(sizeof(struct mbox_hdr), sizeof(u64)));
 		queue_work(vf->mbox_wq, &vf->mbox.mbox_wrk);
-
+	}
 	/* Check for PF => VF notification messages */
 	mbox = &vf->mbox.mbox_up;
 	mdev = &mbox->dev[0];
 	otx2_sync_mbox_bbuf(mbox, 0);
 
 	hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	if (hdr->num_msgs)
+	if (hdr->num_msgs) {
+		vf->mbox.up_num_msgs = hdr->num_msgs;
+		hdr->num_msgs = 0;
+		memset(mbox->hwbase + mbox->rx_start, 0,
+		       ALIGN(sizeof(struct mbox_hdr), sizeof(u64)));
 		queue_work(vf->mbox_wq, &vf->mbox.mbox_up_wrk);
-
+	}
 	/* Clear the IRQ */
 	otx2_write64(vf, RVU_VF_INT, BIT_ULL(0));
 
-- 
2.17.1


From 71653d3246885be6feb79decc815e7fd22fc1168 Mon Sep 17 00:00:00 2001
From: Grzegorz Jaszczyk <jaz@semihalf.com>
Date: Tue, 16 Apr 2019 16:30:51 +0200
Subject: [PATCH 155/386] net: mvpp2: move the section which reads hw version
 after clock init

Access to hw register should be done after all clocks are enabled.
Before this patch in normal circumstances everything works well but in some
it lead to race condition resulting with rcu stall.

The gated clock used for mvpp2 is also shared with axim and because the
axim is treat as AMBA device during it initialization the clock can be
enabled and then disabled. Disabling of mentioned clock happens e.g. after
5s - deferred device timeout in amba bus.

Due to that when the boot time increased (e.g. due to nand bad block
management which can take several seconds) the amba deferred retry func
was scheduled which disabled the clk (the clk was registered only for
AMBA since mvpp2 probe wasn't performed yet).

Performing clock init before any register access in mvpp2 solves the issue
since the second clock consumer is registered (increasing clk count) and
amba driver will not be able to really disable it.

Change-Id: I0ab80d6c2d20750d7a4c1a2343e31c7a1528ce3d
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-on: https://sj1git1.cavium.com/7866
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Marcin Wojtas <marcin@marvell.com>
Reviewed-by: Stefan Chulski <Stefan.Chulski@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/mvpp2/mvpp2_main.c   | 20 +++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index c8a012a4aa43..7ed66813cfb6 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@ -7091,16 +7091,6 @@ static int mvpp2_probe(struct platform_device *pdev)
 		priv->swth_base[i] = base + i * addr_space_sz;
 	}
 
-	if (priv->hw_version != MVPP21) {
-		if (mvpp2_read(priv, MVPP2_VER_ID_REG) == MVPP2_VER_PP23)
-			priv->hw_version = MVPP23;
-	}
-
-	if (priv->hw_version == MVPP21)
-		priv->max_port_rxqs = 8;
-	else
-		priv->max_port_rxqs = 32;
-
 	if (dev_of_node(&pdev->dev)) {
 		priv->pp_clk = devm_clk_get(&pdev->dev, "pp_clk");
 		if (IS_ERR(priv->pp_clk))
@@ -7159,6 +7149,16 @@ static int mvpp2_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	if (priv->hw_version != MVPP21) {
+		if (mvpp2_read(priv, MVPP2_VER_ID_REG) == MVPP2_VER_PP23)
+			priv->hw_version = MVPP23;
+	}
+
+	if (priv->hw_version == MVPP21)
+		priv->max_port_rxqs = 8;
+	else
+		priv->max_port_rxqs = 32;
+
 	priv->custom_dma_mask = false;
 	if (priv->hw_version != MVPP21) {
 		/* If dma_mask points to coherent_dma_mask, setting both will
-- 
2.17.1


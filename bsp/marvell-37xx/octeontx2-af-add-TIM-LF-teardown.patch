From 011082015ac8f643f3d3282eee47f9a79a36263b Mon Sep 17 00:00:00 2001
From: Stanislaw Kardach <skardach@marvell.com>
Date: Sat, 25 May 2019 14:20:06 -0400
Subject: [PATCH 257/386] octeontx2-af: add TIM LF teardown

TIM LF teardown was missing from the code which resulted in LF mapping
registers not being cleared.

Change-Id: I71b4fbf2c70fef6ddaa997270aae93b1fb5e3d05
Signed-off-by: Stanislaw Kardach <skardach@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/9956
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/af/rvu.c   |  2 ++
 .../net/ethernet/marvell/octeontx2/af/rvu.h   |  1 +
 .../ethernet/marvell/octeontx2/af/rvu_tim.c   | 26 +++++++++++++++----
 3 files changed, 24 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
index 42a7ff518615..e28962e6b91b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.c
@@ -2093,6 +2093,8 @@ static void rvu_blklf_teardown(struct rvu *rvu, u16 pcifunc, u8 blkaddr)
 			rvu_sso_lf_teardown(rvu, pcifunc, lf, slot);
 		else if (block->addr == BLKADDR_SSOW)
 			rvu_ssow_lf_teardown(rvu, pcifunc, lf, slot);
+		else if (block->addr == BLKADDR_TIM)
+			rvu_tim_lf_teardown(rvu, pcifunc, lf, slot);
 
 		err = rvu_lf_reset(rvu, block, lf);
 		if (err) {
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index 4a80a25ab80d..ae12c3362d68 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -618,6 +618,7 @@ void rvu_cpt_unregister_interrupts(struct rvu *rvu);
 
 /* TIM APIs */
 int rvu_tim_init(struct rvu *rvu);
+int rvu_tim_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot);
 int rvu_lf_lookup_tim_errata(struct rvu *rvu, struct rvu_block *block,
 		u16 pcifunc, int slot);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
index 677453fca2e8..d0ea06f0e23a 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_tim.c
@@ -36,10 +36,14 @@ static inline u64 get_tenns_clk(void)
 	return tsc;
 }
 
-static void rvu_tim_disable_lf(struct rvu *rvu, int lf, int blkaddr)
+static int rvu_tim_disable_lf(struct rvu *rvu, int lf, int blkaddr)
 {
 	u64 regval;
 
+	regval = rvu_read64(rvu, blkaddr, TIM_AF_RINGX_CTL1(lf));
+	if ((regval & TIM_AF_RINGX_CTL1_ENA) == 0)
+		return TIM_AF_RING_ALREADY_DISABLED;
+
 	/* Clear TIM_AF_RING(0..255)_CTL1[ENA]. */
 	regval = rvu_read64(rvu, blkaddr, TIM_AF_RINGX_CTL1(lf));
 	regval &= ~TIM_AF_RINGX_CTL1_ENA;
@@ -51,6 +55,7 @@ static void rvu_tim_disable_lf(struct rvu *rvu, int lf, int blkaddr)
 	 */
 	rvu_poll_reg(rvu, blkaddr, TIM_AF_RINGX_CTL1(lf),
 			TIM_AF_RINGX_CTL1_RCF_BUSY, true);
+	return 0;
 }
 
 int rvu_lf_lookup_tim_errata(struct rvu *rvu, struct rvu_block *block,
@@ -131,6 +136,8 @@ int rvu_mbox_handler_tim_lf_free(struct rvu *rvu,
 	if (lf < 0)
 		return TIM_AF_LF_INVALID;
 
+	rvu_tim_lf_teardown(rvu, pcifunc, lf, req->ring);
+
 	return 0;
 }
 
@@ -270,7 +277,6 @@ int rvu_mbox_handler_tim_disable_ring(struct rvu *rvu,
 {
 	u16 pcifunc = req->hdr.pcifunc;
 	int lf, blkaddr;
-	u64 regval;
 
 	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_TIM, pcifunc);
 	if (blkaddr < 0)
@@ -280,12 +286,22 @@ int rvu_mbox_handler_tim_disable_ring(struct rvu *rvu,
 	if (lf < 0)
 		return TIM_AF_LF_INVALID;
 
-	regval = rvu_read64(rvu, blkaddr, TIM_AF_RINGX_CTL1(lf));
-	if ((regval & TIM_AF_RINGX_CTL1_ENA) == 0)
-		return TIM_AF_RING_ALREADY_DISABLED;
+	return rvu_tim_disable_lf(rvu, lf, blkaddr);
+}
 
+int rvu_tim_lf_teardown(struct rvu *rvu, u16 pcifunc, int lf, int slot)
+{
+	int blkaddr;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_TIM, pcifunc);
+	if (blkaddr < 0)
+		return TIM_AF_LF_INVALID;
+
+	/* Ensure TIM ring is disabled prior to clearing the mapping */
 	rvu_tim_disable_lf(rvu, lf, blkaddr);
 
+	rvu_write64(rvu, blkaddr, TIM_AF_RINGX_GMCTL(lf), 0);
+
 	return 0;
 }
 
-- 
2.17.1


From 73b5f344ac7c6cc2c044d217042181c32516960e Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Tue, 8 Jan 2019 14:52:17 -0800
Subject: [PATCH 347/386] mmc: cavium: reorganize before vqmmc switching

Code motion to allow the upcoming vqmmc-switching commit
to fit nicely. No change to actual operation, except to
correct  several IS_ERR() to IS_ERR_OR_NULL() which
would have segfaulted in the NULL case.

The do_switch() & cvm_mmc_switch_to() functions were
becoming unwieldly, and about to become more so, when
vqmmc-switching is introduced.

- mode_switch() does the low level EMM_MMC_SWITCH change
- pre_switch() prepares for a slot switch, notes if it's
  needed
- post_switch() performs final actions, if a slot switch
  was needed

Some code has moved from cvm_mmc_switch_to() to do_switch()
and now happens on every invocation, including probe-time,
but will have no effect on post-probe runtime

Change-Id: Ic4643ba03ad0a22abe2f5ed9e260f9ee1c821a70
Signed-off-by: Peter Swain <pswain@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/12799
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../devicetree/bindings/mmc/cavium-mmc.txt    |  10 +-
 drivers/mmc/host/cavium.c                     | 119 ++++++++++--------
 drivers/mmc/host/cavium.h                     |   3 +-
 3 files changed, 71 insertions(+), 61 deletions(-)

diff --git a/Documentation/devicetree/bindings/mmc/cavium-mmc.txt b/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
index 580fe086638b..60c342d9f353 100644
--- a/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
+++ b/Documentation/devicetree/bindings/mmc/cavium-mmc.txt
@@ -17,8 +17,8 @@ Required properties:
  - clocks : phandle
 
 Optional properties:
- - for cd, bus-width and additional generic mmc parameters
-   please refer to mmc.txt within this directory
+ - for cd, bus-width, vmmc-supply, vqmmc-supply, and additional generic
+   mmc parameters please refer to mmc.txt within this directory
  - cavium,cmd-clk-skew : number of coprocessor clocks before sampling command
  - cavium,dat-clk-skew : number of coprocessor clocks before sampling data
  - cavium,drv-strength : eMMC bus pin output drive strength
@@ -42,7 +42,8 @@ Examples:
 			compatible = "mmc-slot";
 			reg = <0>;
 			vmmc-supply = <&mmc_supply_3v3>;
-			max-frequency = <42000000>;
+			vqmmc-supply = <&vqmmc_3v3>;
+			max-frequency = <52000000>;
 			bus-width = <4>;
 			cap-sd-highspeed;
 		};
@@ -51,7 +52,8 @@ Examples:
 			compatible = "mmc-slot";
 			reg = <1>;
 			vmmc-supply = <&mmc_supply_3v3>;
-			max-frequency = <42000000>;
+			vqmmc-supply = <&vqmmc_1v8>;
+			max-frequency = <100000000>;
 			bus-width = <8>;
 			cap-mmc-highspeed;
 			non-removable;
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 13e1270d3731..8fc197581962 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -140,22 +140,6 @@ bool cvm_is_mmc_timing_ddr(struct cvm_mmc_slot *slot)
 		return false;
 }
 
-bool cvm_is_mmc(struct cvm_mmc_slot *slot)
-{
-	switch (slot->mmc->ios.timing) {
-	case MMC_TIMING_LEGACY:
-		/* before CSD read, can we know SD-vs-eMMC? */
-		return true;
-	case MMC_TIMING_MMC_HS:
-	case MMC_TIMING_MMC_DDR52:
-	case MMC_TIMING_MMC_HS200:
-	case MMC_TIMING_MMC_HS400:
-		return true;
-	default: /* SD-card modes */
-		return false;
-	}
-}
-
 static void cvm_mmc_set_timing(struct cvm_mmc_slot *slot)
 {
 	if (is_mmc_8xxx(slot->host))
@@ -298,14 +282,14 @@ static void check_switch_errors(struct cvm_mmc_host *host)
 		dev_err(host->dev, "Switch bus width error\n");
 }
 
-static void clear_bus_id(u64 *reg)
+static inline void clear_bus_id(u64 *reg)
 {
 	u64 bus_id_mask = GENMASK_ULL(61, 60);
 
 	*reg &= ~bus_id_mask;
 }
 
-static void set_bus_id(u64 *reg, int bus_id)
+static inline void set_bus_id(u64 *reg, int bus_id)
 {
 	clear_bus_id(reg);
 	*reg |= FIELD_PREP(GENMASK(61, 60), bus_id);
@@ -316,43 +300,82 @@ static int get_bus_id(u64 reg)
 	return FIELD_GET(GENMASK_ULL(61, 60), reg);
 }
 
+/* save old slot details, switch power */
+static bool pre_switch(struct cvm_mmc_host *host, u64 emm_switch)
+{
+	int bus_id = get_bus_id(emm_switch);
+	struct cvm_mmc_slot *slot = host->slot[bus_id];
+	struct cvm_mmc_slot *old_slot;
+
+	if (host->last_slot == bus_id)
+		return false;
+
+	if (host->last_slot >= 0 && host->slot[host->last_slot]) {
+		old_slot = host->slot[host->last_slot];
+		old_slot->cached_switch =
+		    readq(host->base + MIO_EMM_SWITCH(host));
+		old_slot->cached_rca = readq(host->base + MIO_EMM_RCA(host));
+	}
+
+	host->last_slot = slot->bus_id;
+
+	return true;
+}
+
+static void post_switch(struct cvm_mmc_host *host, u64 emm_switch)
+{
+	int bus_id = get_bus_id(emm_switch);
+	struct cvm_mmc_slot *slot = host->slot[bus_id];
+
+	writeq(slot->cached_rca, host->base + MIO_EMM_RCA(host));
+}
+
+static inline void mode_switch(struct cvm_mmc_host *host, u64 emm_switch)
+{
+	u64 rsp_sts;
+	int retries = 100;
+
+	writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
+
+	/* wait for the switch to finish */
+	do {
+		rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
+		if (!(rsp_sts & MIO_EMM_RSP_STS_SWITCH_VAL))
+			break;
+		udelay(10);
+	} while (--retries);
+}
+
 /*
  * We never set the switch_exe bit since that would interfere
  * with the commands send by the MMC core.
  */
 static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 {
-	int retries = 100;
-	u64 rsp_sts;
 	int bus_id = get_bus_id(emm_switch);
 	struct cvm_mmc_slot *slot = host->slot[bus_id];
+	bool slot_changed = pre_switch(host, emm_switch);
 
 	/*
 	 * Modes setting only taken from slot 0. Work around that hardware
 	 * issue by first switching to slot 0.
 	 */
 	if (bus_id) {
-		clear_bus_id(&emm_switch);
-		writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
-		set_bus_id(&emm_switch, bus_id);
+		u64 switch0 = emm_switch;
+
+		clear_bus_id(&switch0);
+		mode_switch(host, switch0);
 	}
-	writeq(emm_switch, host->base + MIO_EMM_SWITCH(host));
 
-	/* wait for the switch to finish */
-	do {
-		rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
-		if (!(rsp_sts & MIO_EMM_RSP_STS_SWITCH_VAL))
-			break;
-		udelay(10);
-	} while (--retries);
+	mode_switch(host, emm_switch);
 
 	check_switch_errors(host);
 
-	if (slot) {
-		if (emm_switch & MIO_EMM_SWITCH_CLK)
-			slot->cmd6_pending = false;
-		slot->cached_switch = emm_switch;
-	}
+	if (slot_changed)
+		post_switch(host, emm_switch);
+	slot->cached_switch = emm_switch;
+	if (emm_switch & MIO_EMM_SWITCH_CLK)
+		slot->cmd6_pending = false;
 }
 
 /* need to change hardware state to match software requirements? */
@@ -421,29 +444,15 @@ static void cvm_mmc_reset_bus(struct cvm_mmc_slot *slot)
 static void cvm_mmc_switch_to(struct cvm_mmc_slot *slot)
 {
 	struct cvm_mmc_host *host = slot->host;
-	struct cvm_mmc_slot *old_slot;
-	u64 emm_switch;
 
 	if (slot->bus_id == host->last_slot)
 		return;
 
-	if (host->last_slot >= 0 && host->slot[host->last_slot]) {
-		old_slot = host->slot[host->last_slot];
-		old_slot->cached_switch = readq(host->base + MIO_EMM_SWITCH(host));
-		old_slot->cached_rca = readq(host->base + MIO_EMM_RCA(host));
-	}
-
-	writeq(slot->cached_rca, host->base + MIO_EMM_RCA(host));
-	emm_switch = slot->cached_switch;
-
-
-	do_switch(host, emm_switch);
+	do_switch(host, slot->cached_switch);
 	host->powered = true;
 
 	emmc_io_drive_setup(slot);
 	cvm_mmc_configure_delay(slot);
-
-	host->last_slot = slot->bus_id;
 }
 
 static void do_read(struct cvm_mmc_slot *slot, struct mmc_request *req,
@@ -1331,7 +1340,7 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 			cvm_mmc_reset_bus(slot);
 			if (host->global_pwr_gpiod)
 				host->set_shared_power(host, 0);
-			else if (!IS_ERR(mmc->supply.vmmc))
+			else if (!IS_ERR_OR_NULL(mmc->supply.vmmc))
 				mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
 			host->powered = false;
 		}
@@ -1345,7 +1354,7 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	if (ios->power_mode == MMC_POWER_UP) {
 		if (host->global_pwr_gpiod)
 			host->set_shared_power(host, 1);
-		else if (!IS_ERR(mmc->supply.vmmc))
+		else if (!IS_ERR_OR_NULL(mmc->supply.vmmc))
 			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);
 	}
 
@@ -1573,7 +1582,7 @@ static int cvm_mmc_init_lowlevel(struct cvm_mmc_slot *slot)
 	struct cvm_mmc_host *host = slot->host;
 	u64 emm_switch;
 
-	/* Enable this bus slot. */
+	/* Enable this bus slot */
 	host->emm_cfg |= (1ull << slot->bus_id);
 	writeq(host->emm_cfg, slot->host->base + MIO_EMM_CFG(host));
 	udelay(10);
@@ -1636,7 +1645,7 @@ static int cvm_mmc_of_parse(struct device *dev, struct cvm_mmc_slot *slot)
 	 * Legacy Octeon firmware has no regulator entry, fall-back to
 	 * a hard-coded voltage to get a sane OCR.
 	 */
-	if (IS_ERR(mmc->supply.vmmc))
+	if (IS_ERR_OR_NULL(mmc->supply.vmmc))
 		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 
 	/* Common MMC bindings */
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 2c3cd006926e..57709dfbf306 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -108,8 +108,8 @@ struct cvm_mmc_host {
 	int sys_freq;
 
 	bool use_sg;
-
 	bool has_ciu3;
+	bool powered;
 	bool big_dma_addr;
 	bool need_irq_handler_lock;
 	spinlock_t irq_handler_lock;
@@ -117,7 +117,6 @@ struct cvm_mmc_host {
 
 	struct gpio_desc *global_pwr_gpiod;
 	atomic_t shared_power_users;
-	bool powered;
 
 	struct cvm_mmc_slot *slot[CAVIUM_MAX_MMC];
 	struct platform_device *slot_pdev[CAVIUM_MAX_MMC];
-- 
2.17.1


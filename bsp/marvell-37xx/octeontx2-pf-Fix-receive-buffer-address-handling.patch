From 87915aee10d458968d406316ffc1848f145f09f5 Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Wed, 20 Mar 2019 18:19:43 +0530
Subject: [PATCH 065/386] octeontx2-pf: Fix receive buffer address handling

For packets spanning across multiple buffers, except
for the first one rest all buffer start addresses are
incorrectly set at 'payload start - 128' bytes. This
patch fixes that and also got rid off 'apad' based
address adjustments. Since APAD is disabled HW will
always DMA the packet from 0th offset, so this is not
needed.

Change-Id: If432623103559a367d1cd67410ab0175f763f35c
Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/6106
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/nic/otx2_txrx.c   | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
index 652ade01d7b5..0f8a9ae8acca 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_txrx.c
@@ -167,18 +167,17 @@ static void otx2_skb_add_frag(struct otx2_nic *pfvf,
 	struct page *page;
 	void *va;
 
-	iova -= OTX2_HEAD_ROOM;
 	va = phys_to_virt(otx2_iova_to_phys(pfvf->iommu_domain, iova));
 	page = virt_to_page(va);
 	skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
 			va - page_address(page), len, RCV_FRAG_LEN);
 
-	dma_unmap_page_attrs(pfvf->dev, iova, RCV_FRAG_LEN,
+	dma_unmap_page_attrs(pfvf->dev, iova - OTX2_HEAD_ROOM, RCV_FRAG_LEN,
 			     DMA_FROM_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
 }
 
 static inline struct sk_buff *
-otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len, int apad)
+otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len)
 {
 	struct sk_buff *skb;
 	void *va;
@@ -191,10 +190,10 @@ otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len, int apad)
 		return NULL;
 	}
 
-	skb_reserve(skb, apad + OTX2_HEAD_ROOM);
+	skb_reserve(skb, OTX2_HEAD_ROOM);
 	skb_put(skb, len);
 
-	dma_unmap_page_attrs(pfvf->dev, iova - apad, RCV_FRAG_LEN,
+	dma_unmap_page_attrs(pfvf->dev, iova, RCV_FRAG_LEN,
 			     DMA_FROM_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
 	prefetch(skb->data);
 	return skb;
@@ -272,8 +271,7 @@ static void otx2_rcv_pkt_handler(struct otx2_nic *pfvf,
 			 * bytes after which packet data starts.
 			 */
 			if (!skb) {
-				skb = otx2_get_rcv_skb(pfvf, *iova,
-						       len, *iova & 0x07);
+				skb = otx2_get_rcv_skb(pfvf, *iova, len);
 				/* check if data starts at some nonzero offset
 				 * from the start of the buffer.  For now the
 				 * only possible offset is 8 bytes in the case
-- 
2.17.1


From e56633a5ac43400ba714b895aece2faafe8c8275 Mon Sep 17 00:00:00 2001
From: Vidhya Vidhyaraman <Vidhya.Raman@cavium.com>
Date: Wed, 26 Jun 2019 16:16:01 -0700
Subject: [PATCH 314/386] octeontx: Add four ports on LBK1/2 device

This commit enables creation of four ports on LBK1 and
LBK2 device. These four ports enables four bidirectional
traffic paths between four ODP processes and four Linux kernel
interfaces

Change-Id: Id4f4bc3619e55240e9218ca741edb66a644a47d4
Signed-off-by: Vidhya Vidhyaraman <Vidhya.Raman@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/11552
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[RH: Original patch taken from marvell 88F3720 board support SDK 10.0-PR2003]
Signed-off-by: Ruiqiang Hao <Ruiqiang.Hao@windriver.com>
---
 .../ethernet/cavium/octeontx-83xx/lbk_main.c  | 73 ++++++++------
 .../ethernet/cavium/octeontx-83xx/octeontx.h  |  2 +-
 .../cavium/octeontx-83xx/octeontx_main.c      |  3 +-
 .../cavium/octeontx-83xx/pki_config.c         |  2 +-
 drivers/net/ethernet/cavium/thunder/nic.h     |  1 +
 .../net/ethernet/cavium/thunder/nic_main.c    | 79 +++++++++------
 .../net/ethernet/cavium/thunder/nicvf_main.c  | 95 ++-----------------
 7 files changed, 105 insertions(+), 150 deletions(-)

diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c
index 3fd5391f9690..67f724a3e234 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/lbk_main.c
@@ -27,7 +27,8 @@
 #define LBK_DEV_PER_CPU		BIT(LBK_NODE_SHIFT)
 #define LBK_DEV_MASK		(LBK_DEV_PER_CPU - 1)
 #define LBK0_MAX_PORTS      16
-#define LBK1_MAX_PORTS      1
+#define LBK1_MAX_PORTS      4
+#define LBK2_MAX_PORTS      4
 /* 16 ports in lbk0 device and 1 port in lbk1/lbk2 device */
 #define LBK_MAX_PORTS		(LBK0_MAX_PORTS + LBK1_MAX_PORTS)
 #define LBK_INVALID_ID		(-1)
@@ -72,23 +73,32 @@ struct lbkpf {
 static DEFINE_MUTEX(octeontx_lbk_lock);
 static LIST_HEAD(octeontx_lbk_devices);
 static struct octtx_lbk_port octeontx_lbk_ports[LBK_MAX_PORTS] = {
-	{.glb_port_idx = 0, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 1, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 2, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 3, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 4, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 5, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 6, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 7, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 8, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 9, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 10, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 11, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 12, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 13, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 14, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 15, .domain_id = LBK_INVALID_ID},
-	{.glb_port_idx = 16, .domain_id = LBK_INVALID_ID}
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 1, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 2, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 3, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 4, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 5, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 6, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 7, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 8, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 9, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 10,
+		.domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 11,
+		.domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 12,
+		.domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 13,
+		.domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 14,
+		.domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PP_BASE_IDX + 15,
+		.domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PN_BASE_IDX, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PN_BASE_IDX + 1, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PN_BASE_IDX + 2, .domain_id = LBK_INVALID_ID},
+	{.glb_port_idx = LBK_PORT_PN_BASE_IDX + 3, .domain_id = LBK_INVALID_ID}
 };
 
 /* Interface with Thunder NIC driver */
@@ -263,12 +273,14 @@ int lbk_port_start(struct octtx_lbk_port *port)
 	int rc, pkind, i;
 	struct lbkpf *lbk;
 
-	if (port->glb_port_idx == LBK_PORT_PN_BASE_IDX) {
+	if (port->glb_port_idx >= LBK_PORT_PN_BASE_IDX) {
 		rc = thlbk->port_start();
 		if (rc)
 			return -EIO;
+		/* LBK channel to set PKIND for LBK1/2 port */
+		i = port->glb_port_idx % LBK_PORT_PN_BASE_IDX;
+		/* All LBK1/2 ports use same PKIND */
 		pkind = thlbk->get_port_pkind();
-		i = 0; /* LBK channel to set PKIND for LBK1/2 port */
 	} else {
 		pkind = port->pkind;
 		/* LBK channel to set PKIND for LBK0 port */
@@ -482,6 +494,7 @@ static int lbk_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct lbkpf *lbk;
 	u64 ioaddr;
 	int err, node;
+	int i;
 
 	/* Setup LBK Device */
 	lbk = devm_kzalloc(dev, sizeof(*lbk), GFP_KERNEL);
@@ -537,16 +550,20 @@ static int lbk_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	} else if (lbk->iconn == LBK_CONNECT_E_PKI &&
 			lbk->oconn == LBK_CONNECT_E_NIC) {
 		/* LBK1/LBK2 has one port at index 16 */
-		port = &octeontx_lbk_ports[LBK_PORT_PN_BASE_IDX];
-		port->ilbk = lbk_index_from_id(lbk->id);
-		port->ilbk_base_chan = LBK_BASE_CHAN(port->ilbk);
-		port->ilbk_num_chans = LBK_NUM_CHANS;
+		for (i = 0; i < LBK1_MAX_PORTS; i++) {
+			port = &octeontx_lbk_ports[LBK_PORT_PN_BASE_IDX + i];
+			port->ilbk = lbk_index_from_id(lbk->id);
+			port->ilbk_base_chan = LBK_BASE_CHAN(port->ilbk) + i;
+			port->ilbk_num_chans = 1;
+		}
 	} else if (lbk->iconn == LBK_CONNECT_E_NIC &&
 			lbk->oconn == LBK_CONNECT_E_PKO) {
-		port = &octeontx_lbk_ports[LBK_PORT_PN_BASE_IDX];
-		port->olbk = lbk_index_from_id(lbk->id);
-		port->olbk_base_chan = LBK_BASE_CHAN(port->olbk);
-		port->olbk_num_chans = LBK_NUM_CHANS;
+		for (i = 0; i < LBK2_MAX_PORTS; i++) {
+			port = &octeontx_lbk_ports[LBK_PORT_PN_BASE_IDX + i];
+			port->olbk = lbk_index_from_id(lbk->id);
+			port->olbk_base_chan = LBK_BASE_CHAN(port->olbk) + i;
+			port->olbk_num_chans = 1;
+		}
 	} else {
 		/* LBK:NIC-to-NIC is not used.*/
 		return 0;
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h
index 785f941d5ff4..dbf2cf863579 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx.h
@@ -132,7 +132,7 @@ struct octtx_bgx_port {
 /* Domain internal (LBK) port */
 #define LBK_PORT_INVAL     0xFF
 /* Number of LBK1/LBK2 port */
-#define LBK_PORT_PN_MAX        1
+#define LBK_PORT_PN_MAX        4
 /* Number of LBK0 ports */
 #define LBK_PORT_PP_MAX        BIT(4)
 /* Index of LBK1/LBK2 port */
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c
index 9568ddf613b8..283dee2ae06d 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/octeontx_main.c
@@ -877,7 +877,8 @@ int octeontx_create_domain(const char *name, int type, int sso_count,
 	 */
 	domain->lbk_count = 0;
 	for (i = 0; i < lbk_count; i++) {
-		if (lbk_port[i] > LBK_PORT_PN_BASE_IDX) {
+		if (lbk_port[i] > LBK_PORT_PN_BASE_IDX +
+				LBK_PORT_PN_MAX - 1) {
 			dev_err(octtx_device, "LBK invalid port g%ld\n",
 				lbk_port[i]);
 			goto error;
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c b/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
index 37d4abebe436..1e32341a024d 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
@@ -9,7 +9,7 @@
 #include "pki.h"
 
 #define MAX_BGX_PKIND	16
-#define MAX_LBK_PKIND	16
+#define MAX_LBK_PKIND	19
 #define MAX_SDP_PKIND	16
 
 #define BGX_PKIND_BASE	1
diff --git a/drivers/net/ethernet/cavium/thunder/nic.h b/drivers/net/ethernet/cavium/thunder/nic.h
index d5d6207f79fe..173670b19af6 100644
--- a/drivers/net/ethernet/cavium/thunder/nic.h
+++ b/drivers/net/ethernet/cavium/thunder/nic.h
@@ -553,6 +553,7 @@ struct set_loopback {
 #define NIC_PORT_CTX_DATAPLANE	1 /* Data plane */
 
 #define LBK_IF_IDX	0xff /* LBK virtual port index */
+#define NUM_LBK_IFS 4    /* Number of LBK netdevices in kernel */
 
 struct port_context {
 	u8    msg;
diff --git a/drivers/net/ethernet/cavium/thunder/nic_main.c b/drivers/net/ethernet/cavium/thunder/nic_main.c
index 00bdbc12f2ac..e916227e962a 100644
--- a/drivers/net/ethernet/cavium/thunder/nic_main.c
+++ b/drivers/net/ethernet/cavium/thunder/nic_main.c
@@ -72,7 +72,7 @@ struct nicpf {
 	u8			num_vec;
 	bool			irq_allocated[NIC_PF_MSIX_VECTORS];
 	char			irq_name[NIC_PF_MSIX_VECTORS][20];
-	int			lbk_vf;
+	int			lbk_vf[NUM_LBK_IFS];
 };
 
 /* Supported devices */
@@ -188,7 +188,8 @@ EXPORT_SYMBOL(nic_bgx_port_ctx_set);
 
 #define LBK_PKIND 15
 
-static u8 lbk_link_up;
+static u8 lbk_link_up[NUM_LBK_IFS];
+static u8 bgx_lmac_cnt;
 
 static int nic_get_lbk_port_pkind(void)
 {
@@ -211,16 +212,16 @@ struct thunder_lbk_com_s thunder_lbk_com = {
 };
 EXPORT_SYMBOL(thunder_lbk_com);
 
-static void nic_lbk_link_update(struct nicpf *nic)
+static void nic_lbk_link_update(struct nicpf *nic, int vf_idx)
 {
 	union nic_mbx mbx = {};
-	u8 vf = nic->lbk_vf;
+	int vf = nic->lbk_vf[vf_idx - bgx_lmac_cnt];
 
 	if (nic->mbx_lock[vf])
 		return;
 
 	mbx.link_status.msg = NIC_MBOX_MSG_BGX_LINK_CHANGE;
-	if (lbk_link_up) {
+	if (lbk_link_up[vf_idx - bgx_lmac_cnt]) {
 		nic->link[vf] = true;
 		nic->duplex[vf] = 1;
 		nic->speed[vf] = 1000;
@@ -246,24 +247,35 @@ static void nic_create_lbk_interface(struct nicpf *nic)
 {
 	u64 lmac_credit;
 	u16 sdevid;
+	int i, num_lbk_ifs, numvfs;
 
 	pci_read_config_word(nic->pdev, PCI_SUBSYSTEM_ID, &sdevid);
 	if (sdevid != PCI_SUBSYS_DEVID_83XX_NIC_PF)
 		return;
-	nic->num_vf_en++; /* Additional vf for LBK */
 
-	nic->lbk_vf = nic->num_vf_en - 1;
-	lmac_credit = nic_reg_read(nic, NIC_PF_LMAC_0_7_CREDIT +
+	numvfs = pci_sriov_get_totalvfs(nic->pdev);
+
+	if (nic->num_vf_en + NUM_LBK_IFS <= numvfs)
+		num_lbk_ifs = NUM_LBK_IFS;
+	else
+		num_lbk_ifs = numvfs - nic->num_vf_en;
+
+	for (i = 0; i < num_lbk_ifs; i++) {
+		nic->num_vf_en++; /* Additional vf for LBK */
+
+		nic->lbk_vf[i] = nic->num_vf_en - 1;
+		lmac_credit = nic_reg_read(nic, NIC_PF_LMAC_0_7_CREDIT +
 			(NIC_LBK_PKIO_LMAC * 8));
 
-	lmac_credit = (1ull << 1); /* channel credit enable */
-	lmac_credit |= (0x1ff << 2); /* Max outstanding pkt count */
-	lmac_credit |= (((16 * 1024 - NIC_HW_MAX_FRS) / 16) << 12);
+		lmac_credit = (1ull << 1); /* channel credit enable */
+		lmac_credit |= (0x1ff << 2); /* Max outstanding pkt count */
+		lmac_credit |= (((16 * 1024 - NIC_HW_MAX_FRS) / 16) << 12);
 
-	nic_reg_write(nic, NIC_PF_LMAC_0_7_CREDIT +
+		nic_reg_write(nic, NIC_PF_LMAC_0_7_CREDIT +
 			(NIC_LBK_PKIO_LMAC * 8), lmac_credit);
-	/* LBK link is always up. */
-	lbk_link_up = 1;
+		/* LBK link is always up. */
+		lbk_link_up[i] = 1;
+	}
 }
 
 /* Responds to VF's READY message with VF's
@@ -280,7 +292,7 @@ static void nic_mbx_send_ready(struct nicpf *nic, int vf)
 	mbx.nic_cfg.vf_id = vf;
 
 	mbx.nic_cfg.tns_mode = NIC_TNS_BYPASS_MODE;
-	if (vf < nic->num_vf_en && vf != nic->lbk_vf) {
+	if (vf < nic->num_vf_en && vf < nic->lbk_vf[0]) {
 
 		bgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
 		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
@@ -289,7 +301,7 @@ static void nic_mbx_send_ready(struct nicpf *nic, int vf)
 			ether_addr_copy((u8 *)&mbx.nic_cfg.mac_addr, mac);
 	}
 	mbx.nic_cfg.sqs_mode = (vf >= nic->num_vf_en) ? true : false;
-	mbx.nic_cfg.lbk_mode = (vf == nic->lbk_vf) ? true : false;
+	mbx.nic_cfg.lbk_mode = (vf >= nic->lbk_vf[0]) ? true : false;
 	mbx.nic_cfg.node_id = nic->node;
 
 	mbx.nic_cfg.loopback_supported = vf < nic->num_vf_en;
@@ -452,6 +464,7 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 			nic->vf_lmac_map[next_bgx_lmac++] =
 						NIC_SET_VF_LMAC_MAP(bgx, lmac);
 		nic->num_vf_en += lmac_cnt;
+		bgx_lmac_cnt = nic->num_vf_en;
 
 		/* Program LMAC credits */
 		lmac_credit = (1ull << 1); /* channel credit enable */
@@ -602,9 +615,9 @@ static void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg)
 	u8  qset, rq_idx = 0;
 
 	vnic = cfg->vf_id;
-	if (vnic == nic->lbk_vf) {
+	if (vnic >= nic->lbk_vf[0]) {
 		lmac = NIC_LBK_PKIO_LMAC;
-		chan = NIC_LBK_CHAN_BASE + NIC_LBK_PKIO * hw->chans_per_lbk;
+		chan = NIC_LBK_CHAN_BASE + NIC_LBK_PKIO + (vnic - bgx_lmac_cnt);
 	} else {
 		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);
 		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);
@@ -761,9 +774,9 @@ static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
 	else
 		pqs_vnic = vnic;
 
-	if (vnic == nic->lbk_vf) {
+	if (vnic >= nic->lbk_vf[0]) {
 		lmac = NIC_LBK_PKIO_LMAC;
-		chan = NIC_LBK_CHAN_BASE + NIC_LBK_PKIO * hw->chans_per_lbk;
+		chan = NIC_LBK_CHAN_BASE + NIC_LBK_PKIO + (vnic - bgx_lmac_cnt);
 	} else {
 		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);
 		lmac =
@@ -813,7 +826,8 @@ static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
 	if (hw->tl1_per_bgx)
 		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), chan);
 	else
-		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), 0);
+		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3),
+			      (vnic - bgx_lmac_cnt));
 
 	/* Enable backpressure on the channel */
 	nic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (chan << 3), 1);
@@ -1124,7 +1138,7 @@ static void nic_pause_frame(struct nicpf *nic, int vf, struct pfc *cfg)
 	struct pfc pfc;
 	union nic_mbx mbx = {};
 
-	if (vf >= nic->num_vf_en)
+	if (vf >= nic->lbk_vf[0])
 		return;
 	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
 	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
@@ -1149,7 +1163,7 @@ static void nic_config_timestamp(struct nicpf *nic, int vf, struct set_ptp *ptp)
 	u8 lmac, bgx_idx;
 	u64 pkind_val, pkind_idx;
 
-	if (vf >= nic->num_vf_en)
+	if (vf >= nic->lbk_vf[0])
 		return;
 
 	bgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
@@ -1268,7 +1282,7 @@ static void nic_handle_mbx_intr(struct nicpf *nic, int vf)
 			ret = -1; /* NACK */
 			break;
 		}
-		if (vf == nic->lbk_vf) {
+		if (vf >= nic->lbk_vf[0]) {
 			ret = 0;
 			break;
 		}
@@ -1278,7 +1292,7 @@ static void nic_handle_mbx_intr(struct nicpf *nic, int vf)
 		bgx_set_lmac_mac(nic->node, bgx, lmac, mbx.mac.mac_addr);
 		break;
 	case NIC_MBOX_MSG_SET_MAX_FRS:
-		if (vf == nic->lbk_vf)
+		if (vf >= nic->lbk_vf[0])
 			break;
 		ret = nic_update_hw_frs(nic, mbx.frs.max_frs,
 					mbx.frs.vf_id);
@@ -1295,7 +1309,7 @@ static void nic_handle_mbx_intr(struct nicpf *nic, int vf)
 		break;
 	case NIC_MBOX_MSG_CFG_DONE:
 		/* Last message of VF config msg sequence */
-		if (vf == nic->lbk_vf)
+		if (vf >= nic->lbk_vf[0])
 			nic->vf_enabled[vf] = true;
 		else
 			nic_enable_vf(nic, vf, true);
@@ -1307,7 +1321,7 @@ static void nic_handle_mbx_intr(struct nicpf *nic, int vf)
 				nic->vf_sqs[vf][i] = NIC_VF_UNASSIGNED;
 		}
 		nic->pqs_vf[vf] = NIC_VF_UNASSIGNED;
-		if (vf == nic->lbk_vf)
+		if (vf >= nic->lbk_vf[0])
 			nic->vf_enabled[vf] = false;
 		else
 			nic_enable_vf(nic, vf, false);
@@ -1559,9 +1573,9 @@ static void nic_poll_for_link(struct work_struct *work)
 		if (!nic->vf_enabled[vf])
 			continue;
 
-		if (vf == nic->lbk_vf) {
-			if (lbk_link_up != nic->link[vf])
-				nic_lbk_link_update(nic);
+		if (vf >= nic->lbk_vf[0]) {
+			if (lbk_link_up[vf - bgx_lmac_cnt] != nic->link[vf])
+				nic_lbk_link_update(nic, vf);
 			continue;
 		}
 
@@ -1707,7 +1721,10 @@ static int nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 	nic->node = nic_get_node_id(pdev);
-	nic->lbk_vf = -1; /* Default No lbk interface assigned*/
+	nic->lbk_vf[0] = -1; /* Default No lbk interface assigned*/
+	nic->lbk_vf[1] = -1; /* Default No lbk interface assigned*/
+	nic->lbk_vf[2] = -1; /* Default No lbk interface assigned*/
+	nic->lbk_vf[3] = -1; /* Default No lbk interface assigned*/
 
 	/* Get HW capability info */
 	nic_get_hw_info(nic);
diff --git a/drivers/net/ethernet/cavium/thunder/nicvf_main.c b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
index 9dbccd2223f8..a8ec0b9c0d78 100644
--- a/drivers/net/ethernet/cavium/thunder/nicvf_main.c
+++ b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
@@ -76,6 +76,7 @@ MODULE_PARM_DESC(cpi_alg,
 		 "PFC algorithm (0=none, 1=VLAN, 2=VLAN16, 3=IP Diffserv)");
 
 static struct net_device *netdev_lbk0;
+static struct net_device *netdev_lbkx[4];
 static struct net_device *netdev_ethx[NIC_MAX_PKIND];
 
 /* workqueue for handling kernel ndo_set_rx_mode() calls */
@@ -776,49 +777,6 @@ static inline void nicvf_set_rxtstamp(struct nicvf *nic, struct sk_buff *skb)
 	__skb_pull(skb, 8);
 }
 
-static struct net_device *rcv_pkt_reroute(struct net_device *netdev,
-					  struct sk_buff *skb,
-					  struct nicvf **nic)
-{
-	struct nicvf *snic = *nic;
-	struct pkt_tmhdr *tmh;
-	u8 ifx;
-
-	/* Drop packets coming from BGX interfaces.*/
-	if (!snic->lbk_mode)
-		return NULL;
-	/* Use Tunnelling Meta Header (TMH) to determine the destination
-	 * interface. The current implementation of packet routing assumes,
-	 * that TMH is located at the beginning (prepending) of the packet.
-	 * NOTE: Routing customization is possible here.
-	 * The default routing -- packets go ethX pointed by tmh.dmac[5].
-	 * This needs be be coordinated with the Dataplane program.
-	 */
-	tmh = (struct pkt_tmhdr *)skb->data;
-	ifx = tmh->dmac[5];
-	if (ntohs(tmh->etype) != PKT_TMH_TYPE ||
-	    (ifx >= NIC_MAX_PKIND && ifx != LBK_IF_IDX))
-		return NULL;
-
-	/* Strip TMH, if requested.*/
-	if (tmh->flags & PKT_TMH_FLAG_STRIP)
-		skb_pull(skb, sizeof(struct pkt_tmhdr));
-
-	/* Do not change SKB and netdev, if packet goes to lbk0.*/
-	if (ifx == LBK_IF_IDX)
-		return netdev;
-
-	netdev = netdev_ethx[ifx];
-	snic = netdev_priv(netdev);
-	/* Drop packet, if destination interface belongs to Linux context.*/
-	if (snic->port_ctx == NIC_PORT_CTX_LINUX)
-		return NULL;
-	/* Update SKB and netdev.*/
-	skb->dev = netdev;
-	*nic = snic;
-	return netdev;
-}
-
 static void nicvf_rcv_pkt_handler(struct net_device *netdev,
 				  struct napi_struct *napi,
 				  struct cqe_rx_t *cqe_rx,
@@ -862,13 +820,6 @@ static void nicvf_rcv_pkt_handler(struct net_device *netdev,
 	if (err)
 		goto drop;
 
-	/* Reroute RX packets, if interface belongs to Dataplane. */
-	if (nic->port_ctx == NIC_PORT_CTX_DATAPLANE) {
-		/* Reroute packets arriving from LBK to ethX or lbk0. */
-		netdev = rcv_pkt_reroute(netdev, skb, &nic);
-		if (!netdev)
-			goto drop;
-	}
 	nicvf_set_rxtstamp(nic, skb);
 	nicvf_set_rxhash(netdev, cqe_rx, skb);
 
@@ -1324,33 +1275,6 @@ static int nicvf_register_misc_interrupt(struct nicvf *nic)
 	return 0;
 }
 
-static struct net_device *snd_pkt_reroute(struct net_device *netdev,
-					  struct sk_buff *skb,
-					  struct nicvf **nic)
-{
-	struct pkt_tmhdr *tmh;
-
-	if (!netdev_lbk0)
-		return NULL;
-	/* Add and initialize Tunnelling Meta Header (TMH),
-	 * if not already present.
-	 * NOTE: Usage of TMH needs to be coordinated with Dataplane program,
-	 * which processes this packet.
-	 */
-	tmh = (struct pkt_tmhdr *)skb->data;
-	if (ntohs(tmh->etype) != PKT_TMH_TYPE) {
-		tmh = (struct pkt_tmhdr *)skb_push(skb,
-						   sizeof(struct pkt_tmhdr));
-		tmh->dmac[5] = (*nic)->port_dp_idx;
-		tmh->etype = htons(PKT_TMH_TYPE);
-		tmh->flags = 0;
-	}
-	/* Update SKB and netdev.*/
-	*nic = netdev_priv(netdev_lbk0);
-	skb->dev = netdev_lbk0;
-	return netdev_lbk0;
-}
-
 static netdev_tx_t nicvf_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct nicvf *nic = netdev_priv(netdev);
@@ -1364,15 +1288,6 @@ static netdev_tx_t nicvf_xmit(struct sk_buff *skb, struct net_device *netdev)
 		dev_kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}
-	/* Reroute packets from ethX, if interface belongs to Dataplane.*/
-	if (nic->port_ctx == NIC_PORT_CTX_DATAPLANE) {
-		/* Use LBK media */
-		netdev = snd_pkt_reroute(netdev, skb, &nic);
-		if (!netdev) {
-			dev_kfree_skb(skb);
-			return NETDEV_TX_OK;
-		}
-	}
 	snic = nic;
 	qid = skb_get_queue_mapping(skb);
 
@@ -2211,6 +2126,7 @@ static int nicvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	long   i;
 	u16    sdevid;
 	struct cavium_ptp *ptp_clock;
+	static int lbk_index;
 
 	ptp_clock = cavium_ptp_get();
 	if (IS_ERR(ptp_clock)) {
@@ -2344,7 +2260,8 @@ static int nicvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	spin_lock_init(&nic->rx_mode_wq_lock);
 
 	if (nic->lbk_mode) {
-		if (dev_alloc_name(netdev, "lbk%d") < 0)
+		sprintf(netdev->name,  "lbk%d", lbk_index++);
+		if (dev_alloc_name(netdev, netdev->name) < 0)
 			goto err_unregister_interrupts;
 		netdev->hw_features &= ~NETIF_F_LOOPBACK;
 	}
@@ -2358,7 +2275,9 @@ static int nicvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	nicvf_set_ethtool_ops(netdev);
 
 	if (nic->lbk_mode) {
-		netdev_lbk0 = netdev;
+		err = kstrtol(netdev->name + 3, 10, &i); /* lbkX */
+		if (!err && i < 4)
+			netdev_lbkx[i] = netdev;
 		nic->port_ctx = NIC_PORT_CTX_DATAPLANE;
 		nic->port_dp_idx = LBK_IF_IDX;
 	} else {
-- 
2.17.1


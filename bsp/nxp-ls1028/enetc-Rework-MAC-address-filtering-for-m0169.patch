From c9889aac3896f8d36aa5b3b975aed71baac0c94c Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@nxp.com>
Date: Thu, 8 Feb 2018 10:34:24 +0200
Subject: [PATCH 104/706] enetc: Rework MAC address filtering for m0169

Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
(cherry picked from commit 929a56952c61caa9018c3169d9bed4307e400c9f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.h  |   5 +-
 .../net/ethernet/freescale/enetc/enetc_cbdr.c | 138 +++++++++++++-----
 .../net/ethernet/freescale/enetc/enetc_hw.h   |  11 +-
 .../net/ethernet/freescale/enetc/enetc_pf.c   |  23 +--
 .../net/ethernet/freescale/enetc/enetc_pf.h   |   6 +-
 5 files changed, 130 insertions(+), 53 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index b3b0940d66be..dea7dd4e5f97 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -151,8 +151,6 @@ struct enetc_si {
 
 	struct net_device *ndev; /* back ref. */
 
-	struct enetc_mac_filter mac_filter[ENETC_MAC_ADDR_FILT_CNT];
-
 	struct enetc_cbdr cbd_ring;
 
 	int num_rx_rings; /* how many rings are available in the SI */
@@ -237,7 +235,8 @@ struct net_device_stats *enetc_get_stats(struct net_device *ndev);
 void enetc_set_ethtool_ops(struct net_device *ndev);
 
 /* control buffer descriptor ring (CBDR) */
-void enetc_sync_mac_filters(struct enetc_si *si, int si_idx);
+void enetc_sync_mac_filters(struct enetc_si *si, struct enetc_mac_filter *tbl,
+			    int si_idx);
 int enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,
 		       int index);
 int enetc_set_rss_table(struct enetc_si *si, u16 *table, int len);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
index cd0a70410525..39822311ba41 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
@@ -117,54 +117,122 @@ static int enetc_send_cmd(struct enetc_si *si, struct enetc_cbd *cbd,
 	return ENETC_CMD_OK;
 }
 
-/* MAC Address Filter Table Entry Set Descriptor */
-void enetc_sync_mac_filters(struct enetc_si *si, int si_idx)
+static void enetc_clear_mac_flt_entry(struct enetc_si *si, int index)
 {
-	struct enetc_mac_filter *f = si->mac_filter;
 	struct enetc_cbd cbd;
 	bool async = false;
-	int i, ret;
+	int ret;
 
-	for (i = si_idx; i < si_idx + MADDR_TYPE; i++, f++) {
-		bool enable = !!f->mac_addr_cnt;
-		bool em = (f->mac_addr_cnt == 1); /* exact match */
-		bool mc = (i == MC); /* mcast filter */
+	memset(&cbd, 0, sizeof(cbd));
 
-		WARN_ON(i - si_idx > ENETC_MAC_FILT_PER_SI);
+	cbd.cls = 1;
+	cbd.status_flags = ENETC_CBD_FLAGS_SF;
+	if (async)
+		cbd.status_flags |= ENETC_CBD_FLAGS_IE;
 
-		memset(&cbd, 0, sizeof(cbd));
+	cbd.index = cpu_to_le16(index);
 
-		/* fill up the "set" descriptor */
-		cbd.cls = 1;
-		cbd.status_flags = ENETC_CBD_FLAGS_SF;
-		if (async)
-			cbd.status_flags |= ENETC_CBD_FLAGS_IE;
-		cbd.index = cpu_to_le16(i);
-		cbd.opt[3] = cpu_to_le32(si_idx);
-		cbd.opt[0] = cpu_to_le32((mc ? BIT(1) : 0) |
-					 (em ? BIT(0) : 0));
-		if (enable)
-			cbd.opt[0] |= BIT(31);
+	ret = enetc_send_cmd(si, &cbd, async);
+	if (ret) {
+		pr_err("MAC filter clear failed (%d)!\n", ret);
+		WARN_ON(1);
+	}
+}
 
-		if (em) {
-			u16 upper = ntohs(*(const u16 *)f->mac_addr);
-			u32 lower = ntohl(*(const u32 *)(f->mac_addr + 2));
+static void enetc_set_mac_flt_entry(struct enetc_si *si, int index,
+				    char *mac_addr, int si_map)
+{
+	struct enetc_cbd cbd;
+	bool async = false;
+	u16 upper;
+	u32 lower;
+	int ret;
 
-			cbd.addr[0] = cpu_to_le32(lower);
-			cbd.addr[1] = cpu_to_le16(upper);
-		} else {
-			u32 *hash = (u32 *)f->mac_hash_table;
+	memset(&cbd, 0, sizeof(cbd));
 
-			cbd.addr[0] = cpu_to_le32(*(u32 *)hash);
-			cbd.addr[1] = cpu_to_le32(*(u32 *)(hash + 1));
+	/* fill up the "set" descriptor */
+	cbd.cls = 1;
+	cbd.status_flags = ENETC_CBD_FLAGS_SF;
+	if (async)
+		cbd.status_flags |= ENETC_CBD_FLAGS_IE;
+
+	cbd.index = cpu_to_le16(index);
+	cbd.opt[3] = cpu_to_le32(si_map);
+	/* enable entry */
+	cbd.opt[0] = cpu_to_le32(BIT(31));
+
+	upper = ntohs(*(const u16 *)mac_addr);
+	lower = ntohl(*(const u32 *)(mac_addr + 2));
+	cbd.addr[0] = cpu_to_le32(lower);
+	cbd.addr[1] = cpu_to_le16(upper);
+
+	ret = enetc_send_cmd(si, &cbd, async);
+	if (ret) {
+		pr_err("MAC filter update failed (%d)!\n", ret);
+		WARN_ON(1);
+		// TODO: fallback to promisc mode
+	}
+}
+
+static void enetc_clear_mac_ht_flt(struct enetc_hw *hw, bool mc)
+{
+	if (mc) {
+		enetc_wr(hw, ENETC_MMHFTR0, 0);
+		enetc_wr(hw, ENETC_MMHFTR1, 0);
+	} else {
+		enetc_wr(hw, ENETC_UMHFTR0, 0);
+		enetc_wr(hw, ENETC_UMHFTR1, 0);
+	}
+}
+
+static void enetc_set_mac_ht_flt(struct enetc_hw *hw, u32 *hash, bool mc)
+{
+	if (mc) {
+		enetc_wr(hw, ENETC_MMHFTR0, *hash);
+		enetc_wr(hw, ENETC_MMHFTR1, *(hash + 1));
+	} else {
+		enetc_wr(hw, ENETC_UMHFTR0, *hash);
+		enetc_wr(hw, ENETC_UMHFTR1, *(hash + 1));
+	}
+}
+
+/* MAC Address Filter Table Entry Set Descriptor */
+void enetc_sync_mac_filters(struct enetc_si *si, struct enetc_mac_filter *tbl,
+			    int si_idx)
+{
+	struct enetc_mac_filter *f;
+	int i, pos;
+
+	if (!enetc_si_is_pf(si)) {
+		pr_err("VFs not allowed to change MAC addr filters!\n");
+		return;
+	}
+
+	f = &tbl[si_idx * MADDR_TYPE];
+	pos = EMETC_MAC_ADDR_FILT_RES + si_idx;
+
+	for (i = 0; i < MADDR_TYPE; i++, f++) {
+		bool em = (f->mac_addr_cnt == 1) && (i == UC);
+		bool clear = !f->mac_addr_cnt;
+		bool mc = (i == MC);
+
+		if (clear) {
+			if (!mc)
+				enetc_clear_mac_flt_entry(si, pos);
+
+			enetc_clear_mac_ht_flt(&si->hw, mc);
+			continue;
 		}
 
-		ret = enetc_send_cmd(si, &cbd, async);
-		if (ret) {
-			pr_err("MAC filter update failed (%d)!", ret);
-			WARN_ON(1);
-			// TODO: fallback to promisc mode
+		/* exact match filter */
+		if (em) {
+			enetc_set_mac_flt_entry(si, pos, f->mac_addr,
+						BIT(si_idx));
+			continue;
 		}
+
+		/* hash table filter */
+		enetc_set_mac_ht_flt(&si->hw, (u32 *)f->mac_hash_table, mc);
 	}
 }
 
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
index 4868db9a5e51..bab7e8b900ee 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
@@ -94,6 +94,14 @@ static inline u32 enetc_vsi_set_msize(u32 size)
 #define ENETC_SICAPR0	0x900
 #define ENETC_SICAPR1	0x904
 
+// FIXME: Temp hash filter registers, for m0169 (BG v88).
+// These moved to the Port reg block in the latest BG.
+// Use these temporarily, only for PF level MAC filtering.
+#define ENETC_UMHFTR0	0x1010
+#define ENETC_UMHFTR1	0x1014
+#define ENETC_MMHFTR0	0x1018
+#define ENETC_MMHFTR1	0x101c
+
 #define ENETC_PSIIER	0xa00
 #define ENETC_PSIIER_MR_MASK	GENMASK(2, 1)
 #define ENETC_PSIIDR	0xa10
@@ -313,9 +321,8 @@ union enetc_rx_bd {
 #define ENETC_RXBD_FLAG_VLAN	BIT(9)
 
 #define ENETC_MAC_ADDR_FILT_CNT	8 /* # of supported entries per port */
+#define EMETC_MAC_ADDR_FILT_RES	3 /* # of reserved entries at the beginning */
 #define ENETC_MAX_NUM_VFS	2
-#define ENETC_MAC_FILT_PER_SI	(ENETC_MAC_ADDR_FILT_CNT / \
-				(ENETC_MAX_NUM_VFS + 1))
 
 struct enetc_cbd {
 	union {
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
index 922e7ce63e26..cec730ccc779 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
@@ -118,6 +118,7 @@ static void enetc_add_mac_addr_ht_filter(struct enetc_mac_filter *filter,
 static void enetc_pf_set_rx_mode(struct net_device *ndev)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	struct enetc_pf *pf = enetc_si_priv(priv->si);
 	struct enetc_hw *hw = &priv->si->hw;
 	bool uprom = false, mprom = false;
 	struct enetc_mac_filter *filter;
@@ -139,36 +140,36 @@ static void enetc_pf_set_rx_mode(struct net_device *ndev)
 	/* first 2 filter entries belong to PF */
 	if (!uprom) {
 		/* Update unicast filters */
-		filter = &priv->si->mac_filter[UC];
+		filter = &pf->mac_filter[UC];
 		enetc_reset_mac_addr_filter(filter);
 
 		em = (netdev_uc_count(ndev) == 1);
 		netdev_for_each_uc_addr(ha, ndev) {
-			if (em)
+			if (em) {
 				enetc_add_mac_addr_em_filter(filter, ha->addr);
-			else
-				enetc_add_mac_addr_ht_filter(filter, ha->addr);
+				break;
+			}
+
+			enetc_add_mac_addr_ht_filter(filter, ha->addr);
 		}
 	}
 
 	if (!mprom) {
 		/* Update multicast filters */
-		filter = &priv->si->mac_filter[MC];
+		filter = &pf->mac_filter[MC];
 		enetc_reset_mac_addr_filter(filter);
 
-		em = (netdev_mc_count(ndev) == 1);
 		netdev_for_each_mc_addr(ha, ndev) {
 			if (!is_multicast_ether_addr(ha->addr))
 				continue;
-			if (em)
-				enetc_add_mac_addr_em_filter(filter, ha->addr);
-			else
-				enetc_add_mac_addr_ht_filter(filter, ha->addr);
+
+			enetc_add_mac_addr_ht_filter(filter, ha->addr);
 		}
 	}
 
 	if (!uprom || !mprom)
-		enetc_sync_mac_filters(priv->si, 0); /* update PF entries */
+		/* update PF entries */
+		enetc_sync_mac_filters(pf->si, pf->mac_filter, 0);
 
 	psipmr |= enetc_port_rd(hw, ENETC_PSIPMR) &
 		  ~(ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0));
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.h b/drivers/net/ethernet/freescale/enetc/enetc_pf.h
index b7c32100f5f7..37bde5905e8b 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.h
@@ -34,14 +34,16 @@
 
 #include "enetc.h"
 
-#define ENETC_MAX_VF_CNT_PER_PF	2
+#define ENETC_MAX_NUM_MAC_FLT	((ENETC_MAX_NUM_VFS + 1) * MADDR_TYPE)
 
 struct enetc_pf {
 	struct enetc_si *si;
 	int num_vfs; /* number of active VFs, after sriov_init */
 	int total_vfs; /* max number of VFs, set for PF at probe */
 
-	struct enetc_msg_swbd rxmsg[ENETC_MAX_VF_CNT_PER_PF];
+	struct enetc_mac_filter mac_filter[ENETC_MAX_NUM_MAC_FLT];
+
+	struct enetc_msg_swbd rxmsg[ENETC_MAX_NUM_VFS];
 	struct work_struct msg_task;
 	char msg_int_name[IFNAMSIZ + 8];
 };
-- 
2.17.1


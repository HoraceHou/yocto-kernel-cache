From 67496506dc7ef18d75f72a03f0702995b5c11973 Mon Sep 17 00:00:00 2001
From: Alison Wang <alison.wang@nxp.com>
Date: Tue, 9 Oct 2018 14:57:42 +0800
Subject: [PATCH 335/706] drm: hdp: add support for LS1028A (MCU2) DP PHY

This patch adds support for LS1028A (MCU2) DP PHY.

Signed-off-by: Oliver Brown <oliver.brown@nxp.com>
Signed-off-by: Alison Wang <alison.wang@nxp.com>
(cherry picked from commit 9bc9d7cf8a431fa8c29bf1b518c7b009a0332bd6)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/gpu/drm/imx/hdp/API_AFE_mcu2_dp.c | 363 +++++++++++++---------
 drivers/gpu/drm/imx/hdp/Makefile          |   2 +-
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h |   4 +
 drivers/gpu/drm/imx/hdp/imx-dp.c          | 360 ++++++++++++++++-----
 drivers/gpu/drm/imx/hdp/imx-dp.h          |   6 +-
 drivers/gpu/drm/imx/hdp/imx-hdmi.c        |   6 +-
 drivers/gpu/drm/imx/hdp/imx-hdmi.h        |   2 +-
 drivers/gpu/drm/imx/hdp/imx-hdp.c         |  83 +++--
 drivers/gpu/drm/imx/hdp/imx-hdp.h         |  12 +-
 9 files changed, 602 insertions(+), 236 deletions(-)

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_mcu2_dp.c b/drivers/gpu/drm/imx/hdp/API_AFE_mcu2_dp.c
index da747d3cc73a..d69ca85495a0 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_mcu2_dp.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_mcu2_dp.c
@@ -34,15 +34,11 @@ u8 AFE_check_rate_supported(ENUM_AFE_LINK_RATE rate)
 	}
 }
 
-static void AFE_WriteReg(state_struct *state, ENUM_AFE_LINK_RATE link_rate,
-			 unsigned int addr,
-			 unsigned int val1_6,
-			 unsigned int val2_1,
-			 unsigned int val2_4,
-			 unsigned int val2_7,
-			 unsigned int val3_2,
-			 unsigned int val4_3,
-			 unsigned int val5_4)
+static void afe_write_reg(state_struct *state, ENUM_AFE_LINK_RATE link_rate,
+			  unsigned int addr, unsigned int val1_6,
+			  unsigned int val2_1, unsigned int val2_4,
+			  unsigned int val2_7, unsigned int val3_2,
+			  unsigned int val4_3, unsigned int val5_4)
 {
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
@@ -72,18 +68,19 @@ static void AFE_WriteReg(state_struct *state, ENUM_AFE_LINK_RATE link_rate,
 	}
 }
 
-void phy_cfg_24mhz(state_struct *state, int num_lanes)
+static void phy_cfg_24mhz(state_struct *state, int num_lanes)
 {
 	int k;
 
 	for (k = 0; k < num_lanes; k++) {
-		Afe_write(state, XCVR_DIAG_LANE_FCM_EN_MGN_TMR | (k << 9), 0x0090);
+		Afe_write(state, XCVR_DIAG_LANE_FCM_EN_MGN_TMR | (k << 9),
+			  0x0090);
 		Afe_write(state, TX_RCVDET_EN_TMR | (k << 9), 0x0960);
 		Afe_write(state, TX_RCVDET_ST_TMR | (k << 9), 0x0030);
 	}
 }
 
-void phy_cfg_27mhz(state_struct *state, int num_lanes)
+static void phy_cfg_27mhz(state_struct *state, int num_lanes)
 {
 	int k;
 
@@ -112,15 +109,18 @@ void phy_cfg_27mhz(state_struct *state, int num_lanes)
 	for (k = 0; k < num_lanes; k++) {
 		Afe_write(state, XCVR_PSM_CAL_TMR | (k << 9), 0x016D);
 		Afe_write(state, XCVR_PSM_A0IN_TMR | (k << 9), 0x016D);
-		Afe_write(state, XCVR_DIAG_LANE_FCM_EN_MGN_TMR | (k << 9), 0x00A2);
-		Afe_write(state, TX_DIAG_BGREF_PREDRV_DELAY | (k << 9), 0x0097);
+		Afe_write(state, XCVR_DIAG_LANE_FCM_EN_MGN_TMR | (k << 9),
+			  0x00A2);
+		Afe_write(state, TX_DIAG_BGREF_PREDRV_DELAY | (k << 9),
+			  0x0097);
 		Afe_write(state, TX_RCVDET_EN_TMR | (k << 9), 0x0A8C);
 		Afe_write(state, TX_RCVDET_ST_TMR | (k << 9), 0x0036);
 	}
 }
 
-void phy_cfg_dp_pll0_24mhz(state_struct *state, int num_lanes,
-			   ENUM_AFE_LINK_RATE link_rate)
+static void phy_cfg_dp_pll0_24mhz(state_struct *state,
+				  int num_lanes,
+				  ENUM_AFE_LINK_RATE link_rate)
 {
 	volatile u16 rdata;
 	int k;
@@ -193,26 +193,35 @@ void phy_cfg_dp_pll0_24mhz(state_struct *state, int num_lanes,
 
 	Afe_write(state, CMN_PLL0_VCOCAL_INIT_TMR, 0x00F0);
 	Afe_write(state, CMN_PLL0_VCOCAL_ITER_TMR, 0x0018);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_VCOCAL_START, 0x30B9, 0x3087, 0x3096, 0x30B4, 0x30B9, 0x3087, 0x30B4);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_INTDIV, 0x0086, 0x00B3, 0x00CA, 0x00E0, 0x0086, 0x00B3, 0x00E0);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_FRACDIV, 0xF915, 0xF6C7, 0x75A1, 0xF479, 0xF915, 0xF6C7, 0xF479);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_HIGH_THR, 0x0022, 0x002D, 0x0033, 0x0038, 0x0022, 0x002D, 0x0038);
+	afe_write_reg(state, link_rate, CMN_PLL0_VCOCAL_START,
+		      0x30B9, 0x3087, 0x3096, 0x30B4, 0x30B9, 0x3087, 0x30B4);
+	afe_write_reg(state, link_rate, CMN_PLL0_INTDIV,
+		      0x0086, 0x00B3, 0x00CA, 0x00E0, 0x0086, 0x00B3, 0x00E0);
+	afe_write_reg(state, link_rate, CMN_PLL0_FRACDIV,
+		      0xF915, 0xF6C7, 0x75A1, 0xF479, 0xF915, 0xF6C7, 0xF479);
+	afe_write_reg(state, link_rate, CMN_PLL0_HIGH_THR,
+		      0x0022, 0x002D, 0x0033, 0x0038, 0x0022, 0x002D, 0x0038);
 
 #ifdef SSC_ON_INIT
 	/* Following register writes enable SSC on PHY's initialization */
-	AFE_WriteReg(state, link_rate, CMN_PLL0_SS_CTRL1, 0x0140, 0x01AB, 0x01E0, 0x0204, 0x0140, 0x01AB, 0x0204);
+	afe_write_reg(state, link_rate, CMN_PLL0_SS_CTRL1,
+		      0x0140, 0x01AB, 0x01E0, 0x0204, 0x0140, 0x01AB, 0x0204);
 	Afe_write(state, CMN_PLL0_SS_CTRL2, 0x7F03);
 #endif
 	Afe_write(state, CMN_PLL0_DSM_DIAG, 0x0020);
-	AFE_WriteReg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL, 0x0000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x1000);
+	afe_write_reg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL,
+		      0x0000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x1000);
 	Afe_write(state, CMN_DIAG_PLL0_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBH_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBL_OVRD, 0x0000);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE, 0x0006, 0x0007, 0x0007, 0x0007, 0x0006, 0x0007, 0x0007);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE,
+		      0x0006, 0x0007, 0x0007, 0x0007, 0x0006, 0x0007, 0x0007);
 	Afe_write(state, CMN_DIAG_PLL0_CP_TUNE, 0x0045);
 	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x0100, 0x0001, 0x0001, 0x0001, 0x0100, 0x0001, 0x0001);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x0007, 0x0001, 0x0001, 0x0001, 0x0007, 0x0001, 0x0001);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE1,
+		      0x0100, 0x0001, 0x0001, 0x0001, 0x0100, 0x0001, 0x0001);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE2,
+		     0x0007, 0x0001, 0x0001, 0x0001, 0x0007, 0x0001, 0x0001);
 
 	for (k = 0; k < num_lanes; k = k + 1) {
 		rdata = Afe_read(state, (XCVR_DIAG_PLLDRC_CTRL | (k << 9)));
@@ -239,7 +248,8 @@ void phy_cfg_dp_pll0_24mhz(state_struct *state, int num_lanes,
 	}
 }
 
-void phy_cfg_dp_pll0_27mhz(state_struct *state, int num_lanes,
+void phy_cfg_dp_pll0_27mhz(state_struct *state,
+			   int num_lanes,
 			   ENUM_AFE_LINK_RATE link_rate)
 {
 	u16 rdata;
@@ -311,25 +321,35 @@ void phy_cfg_dp_pll0_27mhz(state_struct *state, int num_lanes,
 
 	Afe_write(state, CMN_PLL0_VCOCAL_INIT_TMR, 0x010E);
 	Afe_write(state, CMN_PLL0_VCOCAL_ITER_TMR, 0x001B);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_VCOCAL_START, 0x30B9, 0x3087, 0x3096, 0x30B4, 0x30B9, 0x3087, 0x30B4);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_INTDIV, 0x0077, 0x009F, 0x00B3, 0x00C7, 0x0077, 0x009F, 0x00C7);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_FRACDIV, 0xF9DA, 0xF7CD, 0xF6C7, 0xF5C1, 0xF9DA, 0xF7CD, 0xF5C1);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_HIGH_THR, 0x001E, 0x0028, 0x002D, 0x0032, 0x001E, 0x0028, 0x0032);
+	afe_write_reg(state, link_rate, CMN_PLL0_VCOCAL_START,
+		      0x30B9, 0x3087, 0x3096, 0x30B4, 0x30B9, 0x3087, 0x30B4);
+	afe_write_reg(state, link_rate, CMN_PLL0_INTDIV,
+		      0x0077, 0x009F, 0x00B3, 0x00C7, 0x0077, 0x009F, 0x00C7);
+	afe_write_reg(state, link_rate, CMN_PLL0_FRACDIV,
+		      0xF9DA, 0xF7CD, 0xF6C7, 0xF5C1, 0xF9DA, 0xF7CD, 0xF5C1);
+	afe_write_reg(state, link_rate, CMN_PLL0_HIGH_THR,
+		      0x001E, 0x0028, 0x002D, 0x0032, 0x001E, 0x0028, 0x0032);
 #ifdef SSC_ON_INIT
 	/* Following register writes enable SSC on PHY's initialization */
-	AFE_WriteReg(state, link_rate, CMN_PLL0_SS_CTRL1, 0x0152, 0x01C2, 0x01FB, 0x0233, 0x0152, 0x01C2, 0x0233);
+	afe_write_reg(state, link_rate, CMN_PLL0_SS_CTRL1,
+		      0x0152, 0x01C2, 0x01FB, 0x0233, 0x0152, 0x01C2, 0x0233);
 	Afe_write(state, CMN_PLL0_SS_CTRL2, 0x6B04);
 #endif
 	Afe_write(state, CMN_PLL0_DSM_DIAG, 0x0020);
-	AFE_WriteReg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL, 0x0000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x1000);
+	afe_write_reg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL,
+		      0x0000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x1000);
 	Afe_write(state, CMN_DIAG_PLL0_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBH_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBL_OVRD, 0x0000);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE, 0x0006, 0x0007, 0x0007, 0x0007, 0x0006, 0x0007, 0x0007);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_CP_TUNE, 0x0043, 0x0043, 0x0043, 0x0042, 0x0043, 0x0043, 0x0042);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE,
+		      0x0006, 0x0007, 0x0007, 0x0007, 0x0006, 0x0007, 0x0007);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_CP_TUNE,
+		      0x0043, 0x0043, 0x0043, 0x0042, 0x0043, 0x0043, 0x0042);
 	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x0100, 0x0001, 0x0001, 0x0001, 0x0100, 0x0001, 0x0001);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x0007, 0x0001, 0x0001, 0x0001, 0x0007, 0x0001, 0x0001);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE1,
+		      0x0100, 0x0001, 0x0001, 0x0001, 0x0100, 0x0001, 0x0001);
+	afe_write_reg(state, link_rate, CMN_DIAG_PLL0_PTATIS_TUNE2,
+		      0x0007, 0x0001, 0x0001, 0x0001, 0x0007, 0x0001, 0x0001);
 
 	for (k = 0; k < num_lanes; k = k + 1) {
 		rdata = Afe_read(state, (XCVR_DIAG_PLLDRC_CTRL | (k << 9)));
@@ -350,11 +370,11 @@ void phy_cfg_dp_pll0_27mhz(state_struct *state, int num_lanes,
 		default:
 			break;
 		}
-	Afe_write(state, (XCVR_DIAG_PLLDRC_CTRL | (k << 9)), rdata);
+		Afe_write(state, (XCVR_DIAG_PLLDRC_CTRL | (k << 9)), rdata);
 	}
 }
 
-void phy_cfg_dp_ln(state_struct *state, int num_lanes)
+static void phy_cfg_dp_ln(state_struct *state, int num_lanes)
 {
 	u16 rdata;
 	int k;
@@ -388,104 +408,105 @@ void phy_cfg_dp_ln(state_struct *state, int num_lanes)
 	}
 }
 
-void aux_cfg(state_struct *state)
+static void aux_cfg_t28hpc(state_struct *state)
 {
+#ifdef DEBUG
+	unsigned short rdata;
+#endif
+	Afe_write(state, TX_DIG_CTRL_REG_2, 36);
+
 	Afe_write(state, TX_ANA_CTRL_REG_2, 0x0100);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_2, 0x0300);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_3, 0x0000);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_1, 0x2008);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_1, 0x2018);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_1, 0xA018);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_2, 0x030C);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_5, 0x0000);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_4, 0x1001);
+	cdn_usleep(150);
 	Afe_write(state, TX_ANA_CTRL_REG_1, 0xA098);
+	cdn_usleep(5000);
 	Afe_write(state, TX_ANA_CTRL_REG_1, 0xA198);
+	cdn_usleep(5000);
 	Afe_write(state, TX_ANA_CTRL_REG_2, 0x030d);
+	cdn_usleep(5000);
 	Afe_write(state, TX_ANA_CTRL_REG_2, 0x030f);
+	cdn_usleep(5000);
+
+#ifdef DEBUG
+	rdata = Afe_read(state, TX_ANA_CTRL_REG_1);
+	pr_info("TX_ANA_CTRL_REG_1 %x)\n", rdata);
+	rdata = Afe_read(state, TX_ANA_CTRL_REG_2);
+	pr_info("TX_ANA_CTRL_REG_2 %x)\n", rdata);
+	rdata = Afe_read(state, TX_ANA_CTRL_REG_3);
+	pr_info("TX_ANA_CTRL_REG_3 %x)\n", rdata);
+	rdata = Afe_read(state, TX_ANA_CTRL_REG_4);
+	pr_info("TX_ANA_CTRL_REG_4 %x)\n", rdata);
+	rdata = Afe_read(state, TX_ANA_CTRL_REG_5);
+	pr_info("TX_ANA_CTRL_REG_5 %x)\n", rdata);
+#endif
 }
 
-void AFE_init(state_struct *state, int num_lanes,
-	      ENUM_AFE_LINK_RATE link_rate)
+void afe_init_t28hpc(state_struct *state,
+		     int num_lanes,
+		     ENUM_AFE_LINK_RATE link_rate)
 {
+	u16 val;
+	const int phy_reset_workaround = 0;
+
 	const REFCLK_FREQ refclk = REFCLK_27MHZ;
-	volatile u16 val;
 
 	if (AFE_check_rate_supported(link_rate) == 0) {
-		pr_info("%s *E: Selected link rate not supported: 0x%x\n",
-			__func__, link_rate);
+		pr_err("%s: Selected link rate not supported: 0x%x\n",
+		       __func__, link_rate);
 		return;
 	}
 
-#if FPGA
-	volatile unsigned short temp;
-
-	/* 1.    Assert
-	   a.    Iddq_Enable_pad  = 1’b0       // reg12[27] */
-
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp & (~(1<<27));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* b.    Pll_ats_eanble = 1’b0 //reg12[29] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp & (~(1<<29));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* 2.    Assert all Reset pads to Low
-	   a.    Tap_trst_n = 1’b0 //reg12[3] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp & (~(1<<3));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* b.    Apb_preset_n = 1’b0 //reg12[2] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp & (~(1<<2));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* c.    Chip_rst_b = 1’b0 reg12[0] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp & (~(1<<0));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* d.    Phy_reset_n = 1’b0 //reg12[1] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp & (~(1<<1));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* 3.    Assert Chipmode[2:0] = 3’b000 reg11[2:0] */
-	cdn_apb_read(0xc000b<<2, &temp);
-	temp = temp & (~(7<<0));
-	cdn_apb_write(0xc000b<<2, temp);
-
-	/* 4.    Assert Sel_Tap[1:0]= 2’b00  //reg11[4:3]; */
-	cdn_apb_read(0xc000b<<2, &temp);
-	temp = temp & (~(3<<3));
-	cdn_apb_write(0xc000b<<2, temp);
-
-	/* 5.    Assert
-	   a.    After 100ns, Apb_preset_n = 1’b1 //reg12[2] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp | ((1<<2));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* b.    After 100ns, Chip_reset_b = 1’b1 // Reg12[0] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp | ((1<<0));
-	cdn_apb_write(0xc000c<<2, temp);
-
-	/* c.    After 100ns, Tap_trst_n = 1’b1 //reg12[3] */
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp | ((1<<3));
-	cdn_apb_write(0xc000c<<2, temp);
-#endif
+	if (phy_reset_workaround) {
+		int k;
+		uint32_t reg_val;
+		/* enable PHY isolation mode only for CMN */
+		/* register PHY_PMA_ISOLATION_CTRL */
+		Afe_write(state, 0xC81F, 0xD000);
+
+		/* set cmn_pll0_clk_datart1_div/cmn_pll0_clk_datart0_div
+		 * dividers
+		 */
+		/* register PHY_PMA_ISO_PLL_CTRL1 */
+		reg_val = Afe_read(state, 0xC812);
+		reg_val &= 0xFF00;
+		reg_val |= 0x0012;
+		Afe_write(state, 0xC812, reg_val);
+
+		/* assert PHY reset from isolation register */
+		/* register PHY_ISO_CMN_CTRL */
+		Afe_write(state, 0xC010, 0x0000);
+
+		/* assert PMA CMN reset */
+		/* register PHY_PMA_ISO_CMN_CTRL */
+		Afe_write(state, 0xC810, 0x0000);
+
+		for (k = 0; k < num_lanes; k++) {
+			/* register XCVR_DIAG_BIDI_CTRL */
+			Afe_write(state, 0x40E8 | (k << 9), 0x00FF);
+		}
+	}
 
 	val = Afe_read(state, PHY_PMA_CMN_CTRL1);
 	val = val & 0xFFF7;
 	val = val | 0x0008;
 	Afe_write(state, PHY_PMA_CMN_CTRL1, val);
 
-	Afe_write(state, CMN_DIAG_PLL0_TEST_MODE, 0x0020);
+	Afe_write(state, CMN_DIAG_PLL0_TEST_MODE, 0x0022);
 	Afe_write(state, CMN_PSM_CLK_CTRL, 0x0016);
 
 	if (refclk == REFCLK_24MHZ) {
@@ -494,24 +515,54 @@ void AFE_init(state_struct *state, int num_lanes,
 	} else if (refclk == REFCLK_27MHZ) {
 		phy_cfg_27mhz(state, num_lanes);
 		phy_cfg_dp_pll0_27mhz(state, num_lanes, link_rate);
-	} else {
-		pr_err("%s *E: Incorrect value of the refclk: %0d\n",
-		       __func__, refclk);
-	}
+	} else
+		pr_info("%s *E: Incorrect value of the refclk: %0d\n",
+			__func__, refclk);
 
 	val = Afe_read(state, PHY_PMA_CMN_CTRL1);
 	val = val & 0xFF8F;
-	Afe_write(state, PHY_PMA_CMN_CTRL1, val);
-	val = Afe_read(state, CMN_DIAG_ACYA);
-	Afe_write(state, CMN_DIAG_ACYA, 0x0100);
+	/* for single ended reference clock on the cmn_ref_clk_int pin:
+	 * PHY_PMA_CMN_CTRL1[6:4]=3'b011
+	 * val |= 0x0030;
+	 */
 
-	/* signal-ended reference clock */
-	/*
-	val = Afe_read(state, PHY_PMA_CMN_CTRL1);
-	val = val & 0xFF8F;
-	val = val | 0x0030;
+	/* for differential clock on the refclk_p and refclk_m off chip pins:
+	 * PHY_PMA_CMN_CTRL1[6:4]=3'b000
+	 * val = val | 0x0030;
+	 */
+	val = val | 0x0000; /* select external reference */
 	Afe_write(state, PHY_PMA_CMN_CTRL1, val);
-	*/
+
+	/* for differential clock on the refclk_p and refclk_m off chip pins:
+	 * CMN_DIAG_ACYA[8]=1'b1
+	 */
+	Afe_write(state, CMN_DIAG_ACYA /*0x01FF*/, 0x0100);
+
+	if (phy_reset_workaround) {
+		int k;
+		/* Deassert PHY reset*/
+		/* register PHY_ISO_CMN_CTRL */
+		Afe_write(state, 0xC010, 0x0001);
+		/* register PHY_PMA_ISO_CMN_CTRL */
+		Afe_write(state, 0xC810, 0x0003);
+		for (k = 0; k < num_lanes; k++) {
+			/* register XCVR_PSM_RCTRL */
+			Afe_write(state, 0x4001 | (k << 9), 0xFEFC);
+		}
+		/* Assert cmn_macro_pwr_en */
+		/* register PHY_PMA_ISO_CMN_CTRL */
+		Afe_write(state, 0xC810, 0x0013);
+
+		/* wait for cmn_macro_pwr_en_ack */
+		/* PHY_PMA_ISO_CMN_CTRL */
+		while (!(Afe_read(state, 0xC810) & (1 << 5)))
+			;
+
+		/* wait for cmn_ready */
+		/* PHY_PMA_CMN_CTRL1 */
+		while (!(Afe_read(state, 0xC800) & (1 << 0)))
+			;
+	}
 
 	if (state->edp != 0)
 		Afe_write(state, CMN_DIAG_CAL_CTRL, 0x0001);
@@ -520,24 +571,17 @@ void AFE_init(state_struct *state, int num_lanes,
 
 	/* Configure PHY in A2 Mode */
 	Afe_write(state, PHY_HDP_MODE_CTRL, 0x0004);
-
-#if FPGA
-	/* Assert  Phy_reset_n = 1’b1 */
-
-	cdn_apb_read(0xc000c<<2, &temp);
-	temp = temp | ((1<<1));
-	cdn_apb_write(0xc000c<<2, temp);
-#endif
-
 }
 
-void AFE_power(state_struct *state, int num_lanes,
-	       ENUM_AFE_LINK_RATE link_rate)
+void afe_power_t28hpc(state_struct *state,
+		      int num_lanes,
+		      ENUM_AFE_LINK_RATE link_rate)
 {
-	volatile uint16_t val;
+	unsigned short val;
+	int i = 0;
 
 	if (AFE_check_rate_supported(link_rate) == 0) {
-		pr_err("%s *E: Selected link rate not supported: 0x%x\n",
+		pr_err("%s() *E: Selected link rate not supported: 0x%x\n",
 		       __func__, link_rate);
 		return;
 	}
@@ -553,19 +597,60 @@ void AFE_power(state_struct *state, int num_lanes,
 	do {
 		val = Afe_read(state, PHY_HDP_MODE_CTRL);
 		val = val >> 6;
-	} while ((val & 1) == 0);
+		if (i++ % 10000 == 0)
+			pr_info("Wait for A2 ACK\n");
+	} while ((val & 1) ==  0);
 
-	/* Configure PHY in A0 mode (PHY must be in the A0 power state
-	 * in order to transmit data)
+	/* Configure PHY in A0 mode (PHY must be in the A0 power
+	 * state in order to transmit data)
 	 */
 	Afe_write(state, PHY_HDP_MODE_CTRL, 0x0101);
-
 	/* Wait for A2 ACK (PHY_HDP_MODE_CTL [4] = 1’b1) */
 	do {
 		val = Afe_read(state, PHY_HDP_MODE_CTRL);
 		val = val >> 4;
-	} while ((val & 1) == 0);
+		if (i++ % 10000 == 0)
+			pr_info("Wait for A2 ACK again\n");
+	} while ((val & 1) ==  0);
+
+	aux_cfg_t28hpc(state);
+}
+
+void AFE_init(state_struct *state, int num_lanes,
+	      ENUM_AFE_LINK_RATE link_rate)
+{
+	/*
+	 * Internal reg Addr 2 controls line for link rate
+	 * B16 (0x8----) enables control from regs / otherway dummy phy is
+	 * controlled by state on the lines (This fearure is left for legacy
+	 * test compatibility
+	 */
+	if (AFE_check_rate_supported(link_rate) == 0) {
+		pr_info("%s *E: Selected link rate not supported: 0x%x\n",
+		       __func__, link_rate);
+		return;
+	}
+
+	switch (link_rate) {
+	case AFE_LINK_RATE_1_6:
+		Afe_write(state, 2, 0x8000);
+		break;
+	case AFE_LINK_RATE_2_7:
+		Afe_write(state, 2, 0x8001);
+		break;
+	case AFE_LINK_RATE_5_4:
+		Afe_write(state, 2, 0x8002);
+		break;
+	case AFE_LINK_RATE_8_1:
+		Afe_write(state, 2, 0x8004);
+		break;
+	default:
+		break;
+	}
+}
 
-	aux_cfg(state);
+void AFE_power(state_struct *state, int num_lanes,
+	       ENUM_AFE_LINK_RATE link_rate)
+{
 
 }
diff --git a/drivers/gpu/drm/imx/hdp/Makefile b/drivers/gpu/drm/imx/hdp/Makefile
index 896024443d9e..d267a2696906 100644
--- a/drivers/gpu/drm/imx/hdp/Makefile
+++ b/drivers/gpu/drm/imx/hdp/Makefile
@@ -3,4 +3,4 @@ obj-$(CONFIG_DRM_IMX_HDP) += imx-hdp.o \
 			imx-dp.o imx-hdmi.o \
 			API_AFE_ss28fdsoi_kiran_hdmitx.o \
 			ss28fdsoi_hdmitx_table.o \
-			API_AFE_dummy_dp.o
+			API_AFE_mcu2_dp.o
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h
index e00d6238b166..f799e6baf343 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h
@@ -62,8 +62,12 @@ void Afe_write(state_struct *state, u32 offset, u16 val);
 u16 Afe_read(state_struct *state, u32 offset);
 void AFE_init(state_struct *state, int num_lanes,
 	      ENUM_AFE_LINK_RATE link_rate);
+void afe_init_t28hpc(state_struct *state, int num_lanes,
+	      ENUM_AFE_LINK_RATE link_rate);
 void AFE_power(state_struct *state, int num_lanes,
 	       ENUM_AFE_LINK_RATE link_rate);
+void afe_power_t28hpc(state_struct *state, int num_lanes,
+	       ENUM_AFE_LINK_RATE link_rate);
 void set_field_value(reg_field_t *reg_field, u32 value);
 int set_reg_value(reg_field_t reg_field);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.c b/drivers/gpu/drm/imx/hdp/imx-dp.c
index 330f6af2cfb1..6e327c92c1bd 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.c
@@ -21,7 +21,7 @@
 #ifdef DEBUG_FW_LOAD
 void dp_fw_load(state_struct *state)
 {
-	printk("Loading DP Firmware\n");
+	DRM_INFO("Loading dp firmware\n");
 	CDN_API_LoadFirmware(state,
 		(u8 *)mhdp_iram0_get_ptr(),
 		mhdp_iram0_get_size(),
@@ -30,42 +30,50 @@ void dp_fw_load(state_struct *state)
 }
 #endif
 
-int dp_fw_init(state_struct *state, u32 core_rate)
+int dp_fw_init(state_struct *state)
 {
 	u8 echo_msg[] = "echo test";
 	u8 echo_resp[sizeof(echo_msg) + 1];
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
+	u32 core_rate;
 	int ret;
 	u8 resp;
 	u16 ver, verlib;
 
+	core_rate = clk_get_rate(hdp->clks.clk_core);
+
 	/* configure the clock */
 	CDN_API_SetClock(state, core_rate/1000000);
 
 	cdn_apb_write(state, APB_CTRL << 2, 0);
+	DRM_INFO("Started firmware!\n");
 
 	ret = CDN_API_CheckAlive_blocking(state);
 	if (ret != 0) {
 		DRM_ERROR("CDN_API_CheckAlive failed - check firmware!\n");
 		return -ENXIO;
 	}
+	DRM_INFO("CDN_API_CheckAlive returned ret = %d\n", ret);
 
 	CDN_API_General_getCurVersion(state, &ver, &verlib);
-	printk("FIRMWARE VERSION: %d, LIB VERSION: %d\n", ver, verlib);
+	DRM_INFO("Firmware version: %d, Lib version: %d\n", ver, verlib);
 
 	/* turn on IP activity */
 	ret = CDN_API_MainControl_blocking(state, 1, &resp);
+	DRM_INFO("CDN_API_MainControl_blocking (ret = %d resp = %u)\n",
+		ret, resp);
 
 	ret = CDN_API_General_Test_Echo_Ext_blocking(state, echo_msg, echo_resp,
 		sizeof(echo_msg), CDN_BUS_TYPE_APB);
+	if (strncmp(echo_msg, echo_resp, sizeof(echo_msg)) != 0) {
+		DRM_ERROR("CDN_API_General_Test_Echo_Ext_blocking - ");
+		DRM_ERROR("echo test failed, check firmware!\n");
+		return -ENXIO;
+	}
 
 	return 0;
 }
 
-static const struct of_device_id scfg_device_ids[] = {
-	{ .compatible = "fsl,ls1028a-scfg", },
-	{}
-};
-
 int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format,
 		int color_depth)
 {
@@ -73,25 +81,15 @@ int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format,
 	int max_link_rate = hdp->link_rate;
 	int num_lanes = 4;
 	int ret;
-	struct device_node *scfg_node;
-	void __iomem *scfg_base = NULL;
 
-	scfg_node = of_find_matching_node(NULL, scfg_device_ids);
-	if (scfg_node)
-		scfg_base = of_iomap(scfg_node, 0);
-
-	iowrite32(0, scfg_base + EDP_PHY_RESET);
+	/* reset phy */
+	imx_hdp_call(hdp, phy_reset, 0);
 
 	/* PHY initialization while phy reset pin is active */
 	AFE_init(state, num_lanes, (ENUM_AFE_LINK_RATE)max_link_rate);
 
-#ifdef arch_imx
-	/* In this point the phy reset should be deactivated */
-	hdp_phy_reset(1);
-#endif
-
-	iowrite32(0x1, scfg_base + EDP_PHY_RESET);
-	iounmap(scfg_base);
+	imx_hdp_call(hdp, phy_reset, 1);
+	DRM_INFO("deasserted reset\n");
 
 	/* PHY power set */
 	AFE_power(state, num_lanes, (ENUM_AFE_LINK_RATE)max_link_rate);
@@ -102,6 +100,165 @@ int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format,
 	return true;
 }
 
+#ifdef DEBUG
+void print_header(void)
+{
+	/*       "0x00000000: 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f"*/
+	DRM_INFO("          : 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n"
+		 );
+	DRM_INFO("-----------------------------------------------------------\n"
+		 );
+}
+
+void print_bytes(unsigned int addr, unsigned char *buf, unsigned int size)
+{
+	int i, index = 0;
+	char line[160];
+
+	if (((size + 11) * 3) > sizeof(line))
+		return;
+
+	index += sprintf(line, "0x%08x:", addr);
+	for (i = 0; i < size; i++)
+		index += sprintf(&line[index], " %02x", buf[i]);
+	DRM_INFO("%s\n", line);
+
+}
+
+int dump_dpcd(state_struct *state)
+{
+	int ret;
+
+	DPTX_Read_DPCD_response resp_dpcd;
+
+	print_header();
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x0, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x100, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x200, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x210, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x220, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x700, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x710, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x720, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+
+	ret = CDN_API_DPTX_Read_DPCD_blocking(state, 0x10, 0x730, &resp_dpcd,
+					      CDN_BUS_TYPE_APB);
+	if (ret) {
+		DRM_INFO("_debug: function returned with status %d\n", ret);
+		return -1;
+	}
+
+	print_bytes(resp_dpcd.addr, resp_dpcd.buff, resp_dpcd.size);
+	return 0;
+}
+#endif
+
+int dp_get_training_status(state_struct *state)
+{
+	uint32_t evt;
+	uint8_t eventId;
+	uint8_t HPDevents;
+
+	do {
+		do {
+			CDN_API_Get_Event(state, &evt);
+			if (evt != 0)
+				DRM_DEBUG("_Get_Event %d\n", evt);
+		} while ((evt & 2) == 0);
+		CDN_API_DPTX_ReadEvent_blocking(state, &eventId, &HPDevents);
+		DRM_DEBUG("ReadEvent  ID = %d HPD = %d\n", eventId, HPDevents);
+
+		switch (eventId) {
+		case 0x01:
+			DRM_INFO("INFO: Full link training started\n");
+			break;
+		case 0x02:
+			DRM_INFO("INFO: Fast link training started\n");
+			break;
+		case 0x04:
+			DRM_INFO("INFO: Clock recovery phase finished\n");
+			break;
+		case 0x08:
+			DRM_INFO("INFO: Channel equalization phase finished ");
+			DRM_INFO("(last part meaning training finished)\n");
+			break;
+		case 0x10:
+			DRM_INFO("INFO: Fast link training finished\n");
+			break;
+		case 0x20:
+			DRM_ERROR("ERROR: Clock recovery phase failed\n");
+			return -1;
+		case 0x40:
+			DRM_ERROR("ERROR: Channel equalization phase failed\n");
+			return -1;
+		case 0x80:
+			DRM_ERROR("ERROR: Fast link training failed\n");
+			return -1;
+		default:
+			DRM_ERROR("ERROR: Invalid ID:%x\n", eventId);
+			return -1;
+		}
+	} while (eventId != 0x08 && eventId != 0x10);
+
+	return 0;
+}
+
 /* Max Link Rate: 06h (1.62Gbps), 0Ah (2.7Gbps), 14h (5.4Gbps),
  * 1Eh (8.1Gbps)--N/A
  */
@@ -111,6 +268,7 @@ void dp_mode_set(state_struct *state,
 			int color_depth,
 			int max_link_rate)
 {
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
 	int ret;
 
 	/* Set Host capabilities */
@@ -126,10 +284,10 @@ void dp_mode_set(state_struct *state,
 	u8 force_max_preemph = 0;
 	/* Supported test patterns mask */
 	u8 supp_test_patterns = 0x0F;
-	/* AUX training? */
+	/* Full link training */
 	u8 no_aux_training = 0;
 	/* Lane mapping */
-	u8 lane_mapping = 0x1B; /*  we have 4 lane, so it's OK */
+	u8 lane_mapping = hdp->lane_mapping; /*  we have 4 lane, so it's OK */
 	/* Extended Host capabilities */
 	u8 ext_host_cap = 1;
 	/* Bits per sub-pixel */
@@ -142,72 +300,84 @@ void dp_mode_set(state_struct *state,
 	u8 transfer_unit = 64;
 	VIC_SYMBOL_RATE sym_rate;
 	S_LINK_STAT rls;
-	u32 evt;
-	u8 eventId;
-	u8 HPDevents;
+	u8 link_rate;
+
+	if (hdp->is_edp) {
+		/* eDP uses device tree link rate and number of lanes */
+		link_rate = hdp->edp_link_rate;
+		num_lanes = hdp->edp_num_lanes;
+
+		/* use the eDP supported rates */
+		switch (max_link_rate) {
+		case AFE_LINK_RATE_1_6:
+			sym_rate = RATE_1_6;
+			break;
+		case AFE_LINK_RATE_2_1:
+			sym_rate = RATE_2_1;
+			break;
+		case AFE_LINK_RATE_2_4:
+			sym_rate = RATE_2_4;
+			break;
+		case AFE_LINK_RATE_2_7:
+			sym_rate = RATE_2_7;
+			break;
+		case AFE_LINK_RATE_3_2:
+			sym_rate = RATE_3_2;
+			break;
+		case AFE_LINK_RATE_4_3:
+			sym_rate = RATE_4_3;
+			break;
+		case AFE_LINK_RATE_5_4:
+			sym_rate = RATE_5_4;
+			break;
+			/*case AFE_LINK_RATE_8_1: sym_rate = RATE_8_1; break; */
+		default:
+			sym_rate = RATE_1_6;
+		}
+	} else {
+		link_rate = max_link_rate;
+
+		switch (max_link_rate) {
+		case 0x0a:
+			sym_rate = RATE_2_7;
+			break;
+		case 0x14:
+			sym_rate = RATE_5_4;
+			break;
+		default:
+			sym_rate = RATE_1_6;
+		}
+	}
 
 	CDN_API_DPTX_SetDbg_blocking(state, DPTX_DBG_SET_PWR_SKIP_SLEEP);
 
 	ret = CDN_API_DPTX_SetHostCap_blocking(state,
-		max_link_rate,
+		link_rate,
 		(num_lanes & 0x7) | ((ssc & 1) << 3) | ((scrambler & 1) << 4),
 		(max_vswing & 0x3) | ((force_max_vswing & 1) << 4),
 		(max_preemph & 0x3) | ((force_max_preemph & 1) << 4),
 		supp_test_patterns,
-		no_aux_training, //fast link training
+		no_aux_training,
 		lane_mapping,
 		ext_host_cap
 		);
+	DRM_INFO("CDN_API_DPTX_SetHostCap_blocking (ret = %d)\n", ret);
 
 	ret = CDN_API_DPTX_TrainingControl_blocking(state, 1);
 
-	do {
-		do {
-			CDN_API_Get_Event(state, &evt);
-		} while ((evt & 2) == 0);
-
-		CDN_API_DPTX_ReadEvent_blocking(state, &eventId, &HPDevents);
-		switch (eventId) {
-		case 0x01:
-			printk("INFO: Full link training started\n");
-			break;
-		case 0x02:
-			printk("INFO: Fast link training started\n");
-			break;
-		case 0x04:
-			printk("INFO: Clock recovery phase finished\n");
-			break;
-		case 0x08:
-			printk("INFO: Channel equalization phase finished (this is last part meaning training finished)\n");
-			break;
-		case 0x10:
-			printk("INFO: Fast link training finished\n");
-			break;
-		case 0x20:
-			printk("ERROR: Clock recovery phase failed\n");
-			break;;
-		case 0x40:
-			printk("ERROR: Channel equalization phase failed\n");
-			break;
-		case 0x80:
-			printk("ERROR: Fast link training failed\n");
-			break;
-		default:
-			printk("ERROR: Invalid ID:0x%.4X\n", eventId);
-			break;
-		}
-	} while (eventId != 0x08 && eventId != 0x10);
+	ret = dp_get_training_status(state);
 
 	ret = CDN_API_DPTX_ReadLinkStat_blocking(state, &rls);
-	printk("INFO: Get Read Link Status (ret = %d resp:\n"
-	       "rate: %d, lanes: %d\n"
-	       "vswing 0..3: %d %d %d\n"
-	       "preemp 0..3: %d %d %d\n",
-	       ret, rls.rate, rls.lanes,
-	       rls.swing[0], rls.swing[1], rls.swing[2],
-	       rls.preemphasis[0], rls.preemphasis[1], rls.preemphasis[2]);
+	DRM_INFO("INFO: Get Read Link Status (ret = %d) resp: rate: %d, ",
+		 ret, rls.rate);
+	DRM_INFO("lanes: %d, vswing 0..3: %d %d %d, preemp 0..3: %d %d %d\n",
+		 rls.lanes, rls.swing[0], rls.swing[1], rls.swing[2],
+		 rls.preemphasis[0], rls.preemphasis[1], rls.preemphasis[2]);
 
 	switch (rls.rate) {
+	case 0x06:
+		sym_rate = RATE_1_6;
+		break;
 	case 0x0a:
 		sym_rate = RATE_2_7;
 		break;
@@ -215,9 +385,12 @@ void dp_mode_set(state_struct *state,
 		sym_rate = RATE_5_4;
 		break;
 	default:
-		sym_rate = RATE_1_6;
+		break;
 	}
 
+#ifdef DEBUG
+	dump_dpcd(state);
+#endif
 	ret = CDN_API_DPTX_Set_VIC_blocking(state,
 		mode,
 		bits_per_subpixel,
@@ -228,9 +401,11 @@ void dp_mode_set(state_struct *state,
 		bt_type,
 		transfer_unit
 		);
+	DRM_INFO("CDN_API_DPTX_Set_VIC_blocking (ret = %d)\n", ret);
 
 	/* Set video on */
 	ret = CDN_API_DPTX_SetVideo_blocking(state, 1);
+	DRM_INFO("CDN_API_DPTX_SetVideo_blocking (ret = %d)\n", ret);
 
 	udelay(1000);
 }
@@ -256,7 +431,7 @@ int dp_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)
 		ret = CDN_API_DPTX_Read_EDID_blocking(state, 1, 1, &edidResp);
 		break;
 	default:
-		pr_warn("EDID block %x read not support\n", block);
+		DRM_WARN("EDID block %x read not support\n", block);
 	}
 
 	memcpy(buf, edidResp.buff, 128);
@@ -268,3 +443,40 @@ void dp_get_hpd_state(state_struct *state, u8 *hpd)
 {
 	CDN_API_DPTX_GetHpdStatus_blocking(state, hpd);
 }
+
+int dp_phy_init_t28hpc(state_struct *state,
+		       struct drm_display_mode *mode,
+		       int format,
+		       int color_depth)
+{
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
+	int max_link_rate = hdp->link_rate;
+	int num_lanes = 4;
+	int ret;
+
+	/* reset phy */
+	imx_hdp_call(hdp, phy_reset, 0);
+
+	if (hdp->is_edp) {
+		max_link_rate = hdp->edp_link_rate;
+		num_lanes = hdp->edp_num_lanes;
+	}
+
+	/* PHY initialization while phy reset pin is active */
+	afe_init_t28hpc(state, num_lanes, (ENUM_AFE_LINK_RATE)max_link_rate);
+	DRM_INFO("AFE_init\n");
+
+	/* In this point the phy reset should be deactivated */
+	imx_hdp_call(hdp, phy_reset, 1);
+	DRM_INFO("deasserted reset\n");
+
+	/* PHY power set */
+	afe_power_t28hpc(state, num_lanes, (ENUM_AFE_LINK_RATE)max_link_rate);
+	DRM_INFO("AFE_power exit\n");
+
+	/* Video off */
+	ret = CDN_API_DPTX_SetVideo_blocking(state, 0);
+	DRM_INFO("CDN_API_DPTX_SetVideo_blocking (ret = %d)\n", ret);
+
+	return true;
+}
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.h b/drivers/gpu/drm/imx/hdp/imx-dp.h
index f8265a85e9fa..0a664413b6e0 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.h
@@ -8,7 +8,7 @@
 #define _IMX_DP_H_
 
 void dp_fw_load(state_struct *state);
-int dp_fw_init(state_struct *state, u32 rate);
+int dp_fw_init(state_struct *state);
 void dp_mode_set(state_struct *state,
 		 struct drm_display_mode *mode,
 		 int format, int color_depth,
@@ -17,6 +17,10 @@ int dp_phy_init(state_struct *state,
 		struct drm_display_mode *mode,
 		int format,
 		int color_depth);
+int dp_phy_init_t28hpc(state_struct *state,
+		       struct drm_display_mode *mode,
+		       int format,
+		       int color_depth);
 int dp_get_edid_block(void *data, u8 *buf, u32 block, size_t len);
 void dp_get_hpd_state(state_struct *state, u8 *hpd);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.c b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
index f60c3b57f9b8..269e279b5df7 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
@@ -22,13 +22,17 @@ void hdmi_fw_load(state_struct *state)
 		hdmitx_dram0_get_size());
 }
 
-int hdmi_fw_init(state_struct *state, u32 core_rate)
+int hdmi_fw_init(state_struct *state)
 {
 	u8 echo_msg[] = "echo test";
 	u8 echo_resp[sizeof(echo_msg) + 1];
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
+	u32 core_rate;
 	int ret;
 	u8 sts;
 
+	core_rate = clk_get_rate(hdp->clks.clk_core);
+
 	/* configure the clock */
 	CDN_API_SetClock(state, core_rate/1000000);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.h b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
index ab938a4f4693..a4c8f8e37aec 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
@@ -7,7 +7,7 @@
 #ifndef _IMX_HDMI_H_
 #define _IMX_HDMI_H_
 void hdmi_fw_load(state_struct *state);
-int hdmi_fw_init(state_struct *state, u32 rate);
+int hdmi_fw_init(state_struct *state);
 int hdmi_phy_init(state_struct *state, struct drm_display_mode *mode,
 		  int format, int color_depth);
 void hdmi_mode_set(state_struct *state, struct drm_display_mode *mode,
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index 38cf4a3d7ede..0a93ac7c3054 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -11,6 +11,7 @@
 #include <linux/component.h>
 #include <linux/mfd/syscon.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/of_device.h>
 
 #include "imx-hdp.h"
@@ -18,6 +19,8 @@
 #include "imx-dp.h"
 #include "../imx-drm.h"
 
+#define EDP_PHY_RESET	0x230
+
 struct drm_display_mode *g_mode;
 
 static struct drm_display_mode edid_cea_modes[] = {
@@ -55,6 +58,18 @@ static inline struct imx_hdp *enc_to_imx_hdp(struct drm_encoder *e)
 	return container_of(e, struct imx_hdp, encoder);
 }
 
+static void imx_hdp_state_init(struct imx_hdp *hdp)
+{
+	state_struct *state = &hdp->state;
+
+	memset(state, 0, sizeof(state_struct));
+	mutex_init(&state->mutex);
+
+	state->mem = &hdp->mem;
+	state->rw = hdp->rw;
+	state->edp = hdp->is_edp;
+}
+
 #ifdef arch_imx
 static void imx_hdp_plmux_config(struct imx_hdp *hdp, struct drm_display_mode *mode)
 {
@@ -70,23 +85,7 @@ static void imx_hdp_plmux_config(struct imx_hdp *hdp, struct drm_display_mode *m
 
 	writel(val, hdp->mem.ss_base + CSR_PIXEL_LINK_MUX_CTL);
 }
-#endif
-
-static void imx_hdp_state_init(struct imx_hdp *hdp)
-{
-	state_struct *state = &hdp->state;
-
-	memset(state, 0, sizeof(state_struct));
-	mutex_init(&state->mutex);
-
-	state->mem.regs_base = hdp->regs_base;
-#ifdef arch_imx
-	state->mem.ss_base = hdp->ss_base;
-#endif
-	state->rw = hdp->rw;
-}
 
-#ifdef arch_imx
 void hdp_phy_reset(u8 reset)
 {
 	sc_err_t sciErr;
@@ -128,6 +127,23 @@ static void clk_set_root(struct imx_hdp *hdp)
 }
 #endif
 
+static const struct of_device_id scfg_device_ids[] = {
+	{ .compatible = "fsl,ls1028a-scfg", },
+	{}
+};
+
+void ls1028a_phy_reset(u8 reset)
+{
+	struct device_node *scfg_node;
+	void __iomem *scfg_base = NULL;
+
+	scfg_node = of_find_matching_node(NULL, scfg_device_ids);
+	if (scfg_node)
+		scfg_base = of_iomap(scfg_node, 0);
+
+	iowrite32(reset, scfg_base + EDP_PHY_RESET);
+}
+
 static void hdp_ipg_clock_set_rate(struct imx_hdp *hdp)
 {
 #ifdef arch_imx
@@ -788,9 +804,10 @@ static struct hdp_ops ls1028a_dp_ops = {
 	.fw_load = dp_fw_load,
 #endif
 	.fw_init = dp_fw_init,
-	.phy_init = dp_phy_init,
+	.phy_init = dp_phy_init_t28hpc,
 	.mode_set = dp_mode_set,
 	.get_edid_block = dp_get_edid_block,
+	.phy_reset = ls1028a_phy_reset,
 };
 
 static struct hdp_devtype ls1028a_dp_devtype = {
@@ -937,6 +954,36 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	hdp->load_fw = devtype->load_fw;
 	hdp->is_hdmi = devtype->is_hdmi;
+
+	hdp->is_edp = of_property_read_bool(pdev->dev.of_node, "fsl,edp");
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+				       "lane_mapping",
+				       &hdp->lane_mapping);
+	if (ret) {
+		hdp->lane_mapping = 0x1b;
+		dev_warn(dev, "Failed to get lane_mapping - using default\n");
+	}
+	dev_info(dev, "lane_mapping 0x%02x\n", hdp->lane_mapping);
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+				       "edp_link_rate",
+				       &hdp->edp_link_rate);
+	if (ret) {
+		hdp->edp_link_rate = 0;
+		dev_warn(dev, "Failed to get dp_link_rate - using default\n");
+	}
+	dev_info(dev, "edp_link_rate 0x%02x\n", hdp->edp_link_rate);
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+				       "edp_num_lanes",
+				       &hdp->edp_num_lanes);
+	if (ret) {
+		hdp->edp_num_lanes = 4;
+		dev_warn(dev, "Failed to get dp_num_lanes - using default\n");
+	}
+	dev_info(dev, "dp_num_lanes 0x%02x\n", hdp->edp_num_lanes);
+
 	hdp->ops = devtype->ops;
 	hdp->rw = devtype->rw;
 	hdp->bpc = 8;
@@ -957,7 +1004,7 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	imx_hdp_call(hdp, fw_load, &hdp->state);
 	core_rate = clk_get_rate(hdp->clks.clk_core);
 
-	ret = imx_hdp_call(hdp, fw_init, &hdp->state, core_rate);
+	ret = imx_hdp_call(hdp, fw_init, &hdp->state);
 	if (ret < 0) {
 		DRM_ERROR("Failed to initialise HDP firmware\n");
 		return ret;
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index 8c669fb6a7e5..da2780ee66be 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -70,13 +70,18 @@
 
 struct hdp_ops {
 	void (*fw_load)(state_struct *state);
-	int (*fw_init)(state_struct *state, u32 rate);
+	int (*fw_init)(state_struct *state);
 	int (*phy_init)(state_struct *state, struct drm_display_mode *mode,
 			int format, int color_depth);
 	void (*mode_set)(state_struct *state, struct drm_display_mode *mode,
 			 int format, int color_depth, int max_link);
 	int (*get_edid_block)(void *data, u8 *buf, u32 block, size_t len);
 	void (*get_hpd_state)(state_struct *state, u8 *hpd);
+#ifdef CONFIG_ARCH_LAYERSCAPE
+	void (*phy_reset)(u8 reset);
+#else
+	void (*phy_reset)(sc_ipc_t ipcHndl, struct hdp_mem *mem, u8 reset);
+#endif
 };
 
 struct hdp_devtype {
@@ -164,6 +169,11 @@ struct imx_hdp {
 	u8 load_fw;
 	u8 is_hdmi;
 
+	u8 is_edp;
+	u32 lane_mapping;
+	u32 edp_link_rate;
+	u32 edp_num_lanes;
+
 	struct mutex mutex;		/* for state below and previous_mode */
 	enum drm_connector_force force;	/* mutex-protected force state */
 
-- 
2.17.1


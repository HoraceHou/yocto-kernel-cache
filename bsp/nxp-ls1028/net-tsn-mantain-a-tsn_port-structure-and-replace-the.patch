From 6296abcfd6208cf3a647a88be9f70f9a7870295a Mon Sep 17 00:00:00 2001
From: Po Liu <Po.Liu@nxp.com>
Date: Thu, 3 Jan 2019 17:32:40 +0800
Subject: [PATCH 427/706] net:tsn: mantain a tsn_port structure and replace the
 net_device tsn_ops

This would remove the tsn_ops in the net_device.
And the tsn_port would include all the tsn devices status and configure.

Signed-off-by: Po Liu <Po.Liu@nxp.com>
(cherry picked from commit d8f3f65d8ed9733b80ba014625f3e9e815ccada0)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.h  |   6 +-
 .../net/ethernet/freescale/enetc/enetc_pf.c   |   7 +-
 .../net/ethernet/freescale/enetc/enetc_tsn.c  |  92 +++--
 drivers/net/ethernet/mscc/felix_board.c       |  41 +-
 drivers/net/ethernet/mscc/ocelot.c            |  29 --
 drivers/net/ethernet/mscc/ocelot.h            |   5 +-
 drivers/net/ethernet/mscc/tsn_switch.h        |   1 +
 include/linux/netdevice.h                     |   6 -
 include/net/tsn.h                             |  19 +
 net/tsn/genl_tsn.c                            | 356 +++++++++++-------
 10 files changed, 344 insertions(+), 218 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index 74e50ab3aa62..b95690accc42 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -268,9 +268,11 @@ int enetc_get_rss_table(struct enetc_si *si, u32 *table, int count);
 int enetc_set_rss_table(struct enetc_si *si, const u32 *table, int count);
 
 #ifdef CONFIG_ENETC_TSN
-void enetc_tsn_init(struct enetc_si *si);
+void enetc_tsn_pf_init(struct net_device *netdev, struct pci_dev *pdev);
+void enetc_tsn_pf_deinit(struct net_device *netdev);
 #else
-#define enetc_tsn_init(si) (void)0
+#define enetc_tsn_pf_init(netdev, pdev) (void)0
+#define enetc_tsn_pf_deinit(netdev) (void)0
 #endif
 
 /* PTP driver exports */
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
index 2ff809235089..60898aef5075 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
@@ -787,12 +787,12 @@ static int enetc_pf_probe(struct pci_dev *pdev,
 		goto err_alloc_msix;
 	}
 
-	enetc_tsn_init(si);
-
 	err = register_netdev(ndev);
 	if (err)
 		goto err_reg_netdev;
 
+	enetc_tsn_pf_init(ndev, pdev);
+
 	err = enetc_setup_irqs(priv);
 	if (err)
 		goto err_setup_irq;
@@ -836,6 +836,9 @@ static void enetc_pf_remove(struct pci_dev *pdev)
 	priv = netdev_priv(si->ndev);
 	netif_info(priv, drv, si->ndev, "%s v%s remove\n",
 		   enetc_drv_name, enetc_drv_ver);
+
+	enetc_tsn_pf_deinit(si->ndev);
+
 	unregister_netdev(si->ndev);
 
 	if (pdev->dev.of_node && of_phy_is_fixed_link(pdev->dev.of_node))
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
index 300e5053a41a..99a8e36fccae 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
@@ -1793,30 +1793,6 @@ static int enetc_get_tsd(struct net_device *ndev, struct tsn_tsd_status *tts)
 	return 0;
 }
 
-static struct tsn_ops enetc_tsn_ops = {
-	.get_capability = enetc_tsn_get_capability,
-	.qbv_set = enetc_qbv_set,
-	.qbv_get = enetc_qbv_get,
-	.qbv_get_status = enetc_qbv_get_status,
-	.cb_streamid_set = enetc_cb_streamid_set,
-	.cb_streamid_get = enetc_cb_streamid_get,
-	.cb_streamid_counters_get = enetc_cb_streamid_counters_get,
-	.qci_sfi_set = enetc_qci_sfi_set,
-	.qci_sfi_get = enetc_qci_sfi_get,
-	.qci_sfi_counters_get = enetc_qci_sfi_counters_get,
-	.qci_sgi_set = enetc_qci_sgi_set,
-	.qci_sgi_get = enetc_qci_sgi_get,
-	.qci_sgi_status_get = enetc_qci_sgi_status_get,
-	.qci_fmi_set = enetc_qci_fmi_set,
-	.qci_fmi_get = enetc_qci_fmi_get,
-	.qbu_set = enetc_qbu_set,
-	.qbu_get = enetc_qbu_get,
-	.cbs_set = enetc_set_cbs,
-	.cbs_get = enetc_get_cbs,
-	.tsd_set = enetc_set_tsd,
-	.tsd_get = enetc_get_tsd,
-};
-
 static u32 get_ndev_speed(struct net_device *netdev)
 {
 	struct ethtool_link_ksettings ksettings;
@@ -1875,12 +1851,12 @@ static void enetc_qbv_init(struct enetc_hw *hw)
 	enetc_port_wr(hw, ENETC_PMR, (enetc_port_rd(hw, ENETC_PMR) & (~0xf00)) | 0x200);
 }
 
-void enetc_tsn_init(struct enetc_si *si)
+void enetc_tsn_init(struct net_device *ndev)
 {
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	struct enetc_si *si = priv->si;
 	u32 capability = 0;
 
-	si->ndev->tsn_ops = &enetc_tsn_ops;
-
 	capability = __enetc_tsn_get_cap(si);
 
 	if (capability & TSN_CAP_CBS)
@@ -1894,4 +1870,66 @@ void enetc_tsn_init(struct enetc_si *si)
 
 	dev_info(&si->pdev->dev, "%s: setup done\n", __func__);
 }
+
+void enetc_tsn_deinit(struct net_device *ndev)
+{
+	return;
+}
+
+static struct tsn_ops enetc_tsn_ops_full = {
+	.device_init = enetc_tsn_init,
+	.device_deinit = enetc_tsn_deinit,
+	.get_capability = enetc_tsn_get_capability,
+	.qbv_set = enetc_qbv_set,
+	.qbv_get = enetc_qbv_get,
+	.qbv_get_status = enetc_qbv_get_status,
+	.cb_streamid_set = enetc_cb_streamid_set,
+	.cb_streamid_get = enetc_cb_streamid_get,
+	.cb_streamid_counters_get = enetc_cb_streamid_counters_get,
+	.qci_sfi_set = enetc_qci_sfi_set,
+	.qci_sfi_get = enetc_qci_sfi_get,
+	.qci_sfi_counters_get = enetc_qci_sfi_counters_get,
+	.qci_sgi_set = enetc_qci_sgi_set,
+	.qci_sgi_get = enetc_qci_sgi_get,
+	.qci_sgi_status_get = enetc_qci_sgi_status_get,
+	.qci_fmi_set = enetc_qci_fmi_set,
+	.qci_fmi_get = enetc_qci_fmi_get,
+	.qbu_set = enetc_qbu_set,
+	.qbu_get = enetc_qbu_get,
+	.cbs_set = enetc_set_cbs,
+	.cbs_get = enetc_get_cbs,
+	.tsd_set = enetc_set_tsd,
+	.tsd_get = enetc_get_tsd,
+};
+
+static struct tsn_ops enetc_tsn_ops_part = {
+	.device_init = enetc_tsn_init,
+	.device_deinit = enetc_tsn_deinit,
+	.get_capability = enetc_tsn_get_capability,
+	.cb_streamid_set = enetc_cb_streamid_set,
+	.cb_streamid_get = enetc_cb_streamid_get,
+	.cb_streamid_counters_get = enetc_cb_streamid_counters_get,
+	.qci_sfi_set = enetc_qci_sfi_set,
+	.qci_sfi_get = enetc_qci_sfi_get,
+	.qci_sfi_counters_get = enetc_qci_sfi_counters_get,
+	.qci_sgi_set = enetc_qci_sgi_set,
+	.qci_sgi_get = enetc_qci_sgi_get,
+	.qci_sgi_status_get = enetc_qci_sgi_status_get,
+	.qci_fmi_set = enetc_qci_fmi_set,
+	.qci_fmi_get = enetc_qci_fmi_get,
+};
+
+void enetc_tsn_pf_init(struct net_device *netdev, struct pci_dev *pdev)
+{
+	int port = pdev->devfn & 0x7;
+	if (port == 1 || port == 3)
+		tsn_port_register(netdev, &enetc_tsn_ops_part, (u16)pdev->bus->number);
+	else
+		tsn_port_register(netdev, &enetc_tsn_ops_full, (u16)pdev->bus->number);
+}
+
+void enetc_tsn_pf_deinit(struct net_device *netdev)
+{
+	tsn_port_unregister(netdev);
+}
 #endif	/* #if IS_ENABLED(CONFIG_ENETC_TSN) */
diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
index 4658c1512996..f6fea53d215a 100644
--- a/drivers/net/ethernet/mscc/felix_board.c
+++ b/drivers/net/ethernet/mscc/felix_board.c
@@ -13,6 +13,7 @@
 #include <net/sock.h>
 
 #include "ocelot.h"
+#include "tsn_switch.h"
 
 static const char felix_driver_string[] = "Felix Switch Driver";
 #define DRV_VERSION "0.2"
@@ -37,6 +38,31 @@ static struct pci_device_id felix_ids[] = {
 };
 MODULE_DEVICE_TABLE(pci, felix_ids);
 
+#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
+const struct tsn_ops switch_tsn_ops = {
+	.qbv_set			= switch_qbv_set,
+	.qbv_get			= switch_qbv_get,
+	.qbv_get_status			= switch_qbv_get_status,
+	.qbu_set			= switch_qbu_set,
+	.cb_streamid_set		= switch_cb_streamid_set,
+	.cb_streamid_get		= switch_cb_streamid_get,
+	.cb_streamid_counters_get	= switch_cb_streamid_counters_get,
+	.qci_sfi_set			= switch_qci_sfi_set,
+	.qci_sfi_get			= switch_qci_sfi_get,
+	.qci_sfi_counters_get		= switch_qci_sfi_counters_get,
+	.qci_sgi_set			= switch_qci_sgi_set,
+	.qci_sgi_get			= switch_qci_sgi_get,
+	.qci_sgi_status_get		= switch_qci_sgi_status_get,
+	.qci_fmi_set			= switch_qci_fmi_set,
+	.qci_fmi_get			= switch_qci_fmi_get,
+	.cbs_set			= switch_cbs_set,
+	.ct_set				= switch_cut_thru_set,
+	.cbgen_set			= switch_seq_gen_set,
+	.cbrec_set			= switch_seq_rec_set,
+	.pcpmap_set			= switch_pcp_map_set,
+};
+#endif
+
 /* Mimic the order of ocelot_target */
 static struct resource felix_switch_res[] = {
 	{
@@ -326,7 +352,9 @@ static void felix_release_ports(struct ocelot_port **ports)
 
 		unregister_netdev(ports[i]->dev);
 		free_netdev(ports[i]->dev);
-
+#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
+		tsn_port_unregister(ports[i]->dev);
+#endif
 		if (phy_is_pseudo_fixed_link(phydev)) {
 			dn = phydev->mdio.dev.of_node;
 			/* decr refcnt: of_phy_register_fixed_link */
@@ -343,8 +371,9 @@ static void felix_release_ports(struct ocelot_port **ports)
 	}
 }
 
-static int felix_ports_init(struct ocelot *ocelot)
+static int felix_ports_init(struct pci_dev *pdev)
 {
+	struct ocelot *ocelot = pci_get_drvdata(pdev);
 	struct device_node *np = ocelot->dev->of_node;
 	struct device_node *phy_node = NULL;
 	struct device_node *portnp = NULL;
@@ -436,6 +465,12 @@ static int felix_ports_init(struct ocelot *ocelot)
 			dev_err(ocelot->dev, "failed to probe ports\n");
 			goto release_ports;
 		}
+
+#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
+		tsn_port_register(ocelot->ports[port]->dev, (struct tsn_ops *)&switch_tsn_ops,
+				(u16)pdev->bus->number + GROUP_OFFSET_SWITCH);
+#endif
+
 		/* register xmit handler for external ports */
 		if (ndev && port != FELIX_EXT_CPU_PORT_ID)
 			felix_register_xmit_handler(ocelot->ports[port], ndev);
@@ -534,7 +569,7 @@ static int felix_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	regmap_field_write(ocelot->regfields[SYS_RESET_CFG_CORE_ENA], 1);
 
-	err = felix_ports_init(ocelot);
+	err = felix_ports_init(pdev);
 	if (err)
 		goto err_ports_init;
 
diff --git a/drivers/net/ethernet/mscc/ocelot.c b/drivers/net/ethernet/mscc/ocelot.c
index a8feb56f2b35..e63f3a7e1898 100644
--- a/drivers/net/ethernet/mscc/ocelot.c
+++ b/drivers/net/ethernet/mscc/ocelot.c
@@ -21,7 +21,6 @@
 #include <net/switchdev.h>
 
 #include "ocelot.h"
-#include "tsn_switch.h"
 
 /* MAC table entry types.
  * ENTRYTYPE_NORMAL is subject to aging.
@@ -1336,31 +1335,6 @@ static const struct switchdev_ops ocelot_port_switchdev_ops = {
 	.switchdev_port_obj_del		= ocelot_port_obj_del,
 };
 
-#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
-const struct tsn_ops switch_tsn_ops = {
-	.qbv_set			= switch_qbv_set,
-	.qbv_get			= switch_qbv_get,
-	.qbv_get_status			= switch_qbv_get_status,
-	.qbu_set			= switch_qbu_set,
-	.cb_streamid_set		= switch_cb_streamid_set,
-	.cb_streamid_get		= switch_cb_streamid_get,
-	.cb_streamid_counters_get	= switch_cb_streamid_counters_get,
-	.qci_sfi_set			= switch_qci_sfi_set,
-	.qci_sfi_get			= switch_qci_sfi_get,
-	.qci_sfi_counters_get		= switch_qci_sfi_counters_get,
-	.qci_sgi_set			= switch_qci_sgi_set,
-	.qci_sgi_get			= switch_qci_sgi_get,
-	.qci_sgi_status_get		= switch_qci_sgi_status_get,
-	.qci_fmi_set			= switch_qci_fmi_set,
-	.qci_fmi_get			= switch_qci_fmi_get,
-	.cbs_set			= switch_cbs_set,
-	.ct_set				= switch_cut_thru_set,
-	.cbgen_set			= switch_seq_gen_set,
-	.cbrec_set			= switch_seq_rec_set,
-	.pcpmap_set			= switch_pcp_map_set,
-};
-#endif
-
 static int ocelot_port_bridge_join(struct ocelot_port *ocelot_port,
 				   struct net_device *bridge)
 {
@@ -1639,9 +1613,6 @@ int ocelot_probe_port(struct ocelot *ocelot, u8 port,
 	dev->netdev_ops = &ocelot_port_netdev_ops;
 	dev->ethtool_ops = &ocelot_ethtool_ops;
 	dev->switchdev_ops = &ocelot_port_switchdev_ops;
-#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
-	dev->tsn_ops = &switch_tsn_ops;
-#endif
 
 	dev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
diff --git a/drivers/net/ethernet/mscc/ocelot.h b/drivers/net/ethernet/mscc/ocelot.h
index a494b1b5d250..0e143736ea47 100644
--- a/drivers/net/ethernet/mscc/ocelot.h
+++ b/drivers/net/ethernet/mscc/ocelot.h
@@ -14,7 +14,6 @@
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <net/tsn.h>
-
 #include "ocelot_ana.h"
 #include "ocelot_dev.h"
 #include "ocelot_dev_gmii.h"
@@ -555,9 +554,9 @@ struct ocelot_port {
 	u8 vlan_aware;
 
 	u64 *stats;
-
+#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
 	u8 cbs_weight[MSCC_QOS_PRIO_MAX];
-
+#endif
 	/* cpu frame injection handler */
 	netdev_tx_t (*cpu_inj_handler)(struct sk_buff *skb, struct ocelot_port *port);
 	void *cpu_inj_handler_data;
diff --git a/drivers/net/ethernet/mscc/tsn_switch.h b/drivers/net/ethernet/mscc/tsn_switch.h
index 0e656aa4d02d..842a6ac0b87d 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.h
+++ b/drivers/net/ethernet/mscc/tsn_switch.h
@@ -7,6 +7,7 @@
 
 #ifndef _MSCC_FELIX_SWITCH_TSN_H_
 #define _MSCC_FELIX_SWITCH_TSN_H_
+#include <net/tsn.h>
 
 #define TRUE 1
 #define FALSE 0
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index becf3680fd67..b187153cd3c2 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -43,9 +43,6 @@
 #ifdef CONFIG_DCB
 #include <net/dcbnl.h>
 #endif
-#ifdef CONFIG_TSN
-#include <net/tsn.h>
-#endif
 #include <net/netprio_cgroup.h>
 #include <net/xdp.h>
 
@@ -1983,9 +1980,6 @@ struct net_device {
 
 #ifdef CONFIG_DCB
 	const struct dcbnl_rtnl_ops *dcbnl_ops;
-#endif
-#ifdef CONFIG_TSN
-	const struct tsn_ops *tsn_ops;
 #endif
 	u8			num_tc;
 	struct netdev_tc_txq	tc_to_txq[TC_MAX_QUEUE];
diff --git a/include/net/tsn.h b/include/net/tsn.h
index 4945cf0afbec..50a032b1f48f 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -7,6 +7,8 @@
 #include <uapi/linux/tsn.h>
 
 struct tsn_ops {
+	void (*device_init)(struct net_device *ndev);
+	void (*device_deinit)(struct net_device *ndev);
 	u32 (*get_capability)(struct net_device *ndev);
 	/* Qbv standard */
 	int (*qbv_set)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
@@ -61,4 +63,21 @@ struct tsn_ops {
 	int (*pcpmap_set)(struct net_device *, bool enable);
 };
 
+enum ethdev_type {
+	TSN_SWITCH,
+	TSN_ENDPOINT,
+};
+
+#define GROUP_OFFSET_SWITCH 256
+
+struct tsn_port {
+	u16 groupid;
+	struct tsn_ops *tsnops;
+	struct net_device *netdev;
+	struct list_head list;
+	enum ethdev_type type;
+};
+
+int tsn_port_register(struct net_device *netdev, struct tsn_ops *tsnops, u16 groupid);
+void tsn_port_unregister(struct net_device *netdev);
 #endif
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index 635ab0d1d2b0..845ade383423 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -55,6 +55,8 @@
 /* the netlink family */
 static struct genl_family tsn_family;
 
+LIST_HEAD(port_list);
+
 enum TSN_REPLY_VALUE {
 	TSN_SUCCESS = 0,
 	TSN_NODEVOPS,
@@ -406,36 +408,45 @@ static int tsn_simple_reply(struct genl_info *info, u32 cmd, char *portname, s32
 	return tsn_send_reply(rep_skb, info);
 }
 
-int tsn_init_check(struct genl_info *info, struct net_device **ndev)
+struct tsn_port *tsn_init_check(struct genl_info *info, struct net_device **ndev)
 {
 	struct nlattr *na;
 	char *portname;
 	struct net_device *netdev;
+	struct tsn_port *port;
+	bool tsn_found = false;
 
 	na = info->attrs[TSN_ATTR_IFNAME];
 	if (!na) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, "no portname", -TSN_ATTRERR);
-		return -EINVAL;
+		return NULL;
 	}
 
 	portname = (char *)nla_data(na);
 	netdev = __dev_get_by_name(genl_info_net(info), portname);
 	if (!netdev) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
-		return -EOPNOTSUPP;
+		return NULL;
 	}
 
-	pr_info("tsn: cmd_cb_streamid_set : netdev index is %d name is %s\n",
+	pr_info("%s: netdev index is %d name is %s\n", __func__,
 			netdev->ifindex, netdev->name);
 
-	if (!netdev->tsn_ops) {
+	list_for_each_entry(port, &port_list, list) {
+		if (port->netdev == netdev) {
+			tsn_found = true;
+			break;
+		}
+	}
+
+	if (!tsn_found) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
-		return -EOPNOTSUPP;
+		return NULL;
 	}
 
 	*ndev = netdev;
 
-	return 0;
+	return port;
 }
 
 static int cmd_cb_streamid_set(struct genl_info *info)
@@ -448,12 +459,13 @@ static int cmd_cb_streamid_set(struct genl_info *info)
 	struct net_device *netdev;
 	struct tsn_cb_streamid sidconf;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	tsnops = netdev->tsn_ops;
+	tsnops = port->tsnops;
 
 	memset(&sidconf, 0, sizeof(struct tsn_cb_streamid));
 
@@ -570,12 +582,13 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 	struct tsn_cb_streamid sidconf;
 	struct tsn_cb_streamid_counters sidcounts;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return -EINVAL;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	tsnops = netdev->tsn_ops;
+	tsnops = port->tsnops;
 
 	memset(&sidconf, 0, sizeof(struct tsn_cb_streamid));
 	memset(&sidcounts, 0, sizeof(struct tsn_cb_streamid_counters));
@@ -728,12 +741,13 @@ static int cmd_qci_sfi_set(struct genl_info *info)
 	struct net_device *netdev;
 	struct tsn_qci_psfp_sfi_conf sficonf;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	tsnops = netdev->tsn_ops;
+	tsnops = port->tsnops;
 
 	memset(&sficonf, 0, sizeof(struct tsn_qci_psfp_sfi_conf));
 
@@ -834,10 +848,13 @@ static int cmd_qci_sfi_get(struct genl_info *info)
 	struct tsn_qci_psfp_sfi_conf sficonf;
 	struct tsn_qci_psfp_sfi_counters sficount;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	genlhdr = info->genlhdr;
 
@@ -856,8 +873,6 @@ static int cmd_qci_sfi_get(struct genl_info *info)
 
 	sfi_handle = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_INDEX]);
 
-	tsnops = netdev->tsn_ops;
-
 	memset(&sficonf, 0, sizeof(struct tsn_qci_psfp_sfi_conf));
 	memset(&sficount, 0, sizeof(struct tsn_qci_psfp_sfi_counters));
 
@@ -942,10 +957,13 @@ static int cmd_qci_sfi_counters_get(struct genl_info *info)
 	struct genlmsghdr *genlhdr;
 	struct tsn_qci_psfp_sfi_counters sficount;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	genlhdr = info->genlhdr;
 
@@ -964,8 +982,6 @@ static int cmd_qci_sfi_counters_get(struct genl_info *info)
 
 	sfi_handle = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_INDEX]);
 
-	tsnops = netdev->tsn_ops;
-
 	memset(&sficount, 0, sizeof(struct tsn_qci_psfp_sfi_counters));
 	if (!tsnops->qci_sfi_counters_get) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
@@ -1028,12 +1044,13 @@ static int cmd_qci_sgi_set(struct genl_info *info)
 	struct tsn_qci_psfp_gcl *gcl = NULL;
 	u16 sgi_handle = 0;
 	u16 listcount = 0;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	tsnops = netdev->tsn_ops;
+	tsnops = port->tsnops;
 
 	memset(&sgi, 0, sizeof(struct tsn_qci_psfp_sgi_conf));
 
@@ -1205,10 +1222,13 @@ static int cmd_qci_sgi_get(struct genl_info *info)
 	const struct tsn_ops *tsnops;
 	u16 sgi_handle;
 	u8 listcount, i;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -1234,8 +1254,6 @@ static int cmd_qci_sgi_get(struct genl_info *info)
 	/* Get config data from device */
 	genlhdr = info->genlhdr;
 
-	tsnops = netdev->tsn_ops;
-
 	memset(&sgiadmin, 0, sizeof(struct tsn_qci_psfp_sgi_conf));
 
 	if (!tsnops->qci_sgi_get) {
@@ -1383,10 +1401,13 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 	u16 sgi_handle;
 	u8 listcount;
 	int valid, i;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -1412,8 +1433,6 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 	/* Get status data from device */
 	genlhdr = info->genlhdr;
 
-	tsnops = netdev->tsn_ops;
-
 	memset(&sgistat, 0, sizeof(struct tsn_psfp_sgi_status));
 
 	if (!tsnops->qci_sgi_status_get) {
@@ -1551,12 +1570,13 @@ static int cmd_qci_fmi_set(struct genl_info *info)
 	struct tsn_qci_psfp_fmi fmiconf;
 	const struct tsn_ops *tsnops;
 	bool enable = 0;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	tsnops = netdev->tsn_ops;
+	tsnops = port->tsnops;
 
 	memset(&fmiconf, 0, sizeof(struct tsn_qci_psfp_fmi));
 
@@ -1644,10 +1664,13 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	struct tsn_qci_psfp_fmi_counters counters;
 	const struct tsn_ops *tsnops;
 	struct genlmsghdr *genlhdr;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QCI_FMI])
 		return -EINVAL;
@@ -1666,8 +1689,6 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	index = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_INDEX]);
 
 	/* Get data from device */
-	tsnops = netdev->tsn_ops;
-
 	memset(&fmiconf, 0, sizeof(struct tsn_qci_psfp_fmi));
 	memset(&counters, 0, sizeof(struct tsn_qci_psfp_fmi_counters));
 
@@ -1745,15 +1766,15 @@ static int cmd_qbv_set(struct genl_info *info)
 	struct net_device *netdev;
 	struct tsn_qbv_conf qbvconfig;
 	const struct tsn_ops *tsnops;
-
 	struct tsn_qbv_entry *gatelist = NULL;
 	int count = 0;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	tsnops = netdev->tsn_ops;
+	tsnops = port->tsnops;
 
 	memset(&qbvconfig, 0, sizeof(struct tsn_qbv_conf));
 
@@ -1870,14 +1891,15 @@ static int cmd_qbv_get(struct genl_info *info)
 	struct genlmsghdr *genlhdr;
 	struct tsn_qbv_conf qbvconf;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	genlhdr = info->genlhdr;
+	tsnops = port->tsnops;
 
-	tsnops = netdev->tsn_ops;
+	genlhdr = info->genlhdr;
 
 	memset(&qbvconf, 0, sizeof(struct tsn_qbv_conf));
 
@@ -1970,14 +1992,15 @@ static int cmd_qbv_status_get(struct genl_info *info)
 	struct genlmsghdr *genlhdr;
 	struct tsn_qbv_status qbvstatus;
 	const struct tsn_ops *tsnops;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	genlhdr = info->genlhdr;
+	tsnops = port->tsnops;
 
-	tsnops = netdev->tsn_ops;
+	genlhdr = info->genlhdr;
 
 	memset(&qbvstatus, 0, sizeof(struct tsn_qbv_status));
 
@@ -2089,10 +2112,13 @@ static int tsn_cbs_set(struct sk_buff *skb, struct genl_info *info)
 	const struct tsn_ops *tsnops;
 	int ret;
 	u8 tc, bw;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBS]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2101,9 +2127,6 @@ static int tsn_cbs_set(struct sk_buff *skb, struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_CBS];
 
-
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->cbs_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2155,18 +2178,19 @@ static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
 	int ret;
 	struct genlmsghdr *genlhdr;
 	u8 tc;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBS]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->cbs_get) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2224,10 +2248,13 @@ static int cmd_qbu_set(struct genl_info *info)
 	const struct tsn_ops *tsnops;
 	int ret;
 	u8 preemptable = 0;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QBU]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2247,8 +2274,6 @@ static int cmd_qbu_set(struct genl_info *info)
 	else
 		pr_info("Disable Qbu since no preemptable TSN_QBU_ATTR_ADMIN_STATE config!\n");
 
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->qbu_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
@@ -2283,16 +2308,17 @@ static int cmd_qbu_get_status(struct genl_info *info)
 	int ret;
 	struct genlmsghdr *genlhdr;
 	struct tsn_preempt_status pps;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	/* Get status data from device */
 	genlhdr = info->genlhdr;
 
-	tsnops = netdev->tsn_ops;
-
 	memset(&pps, 0, sizeof(struct tsn_preempt_status));
 
 	if (!tsnops->qbu_get) {
@@ -2348,12 +2374,15 @@ static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
 	const struct tsn_ops *tsnops;
 	struct tsn_tsd tsd;
 	int ret;
+	struct tsn_port *port;
 
-	memset(&tsd, 0, sizeof(struct tsn_tsd));
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	tsnops = port->tsnops;
+
+	memset(&tsd, 0, sizeof(struct tsn_tsd));
 
 	if (!info->attrs[TSN_ATTR_TSD]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2364,16 +2393,10 @@ static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
 
 	ret = NLA_PARSE_NESTED(ntsd, TSN_TSD_ATTR_MAX, na, tsd_policy);
 	if (ret) {
-		printk("tsn: parse value TSN_TSD_ATTR_MAX error.");
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
-	if (!netdev->tsn_ops)
-		return -EINVAL;
-
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->tsd_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
@@ -2387,18 +2410,17 @@ static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
 		}
 
 		if (!tsd.period) {
-			printk("tsn: parse value TSN_TSD_ATTR_PERIOD error.");
-				tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-				return -EINVAL;
+			tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+			return -EINVAL;
 		}
 
 		if (ntsd[TSN_TSD_ATTR_MAX_FRM_NUM])
 			tsd.maxFrameNum = nla_get_u32(ntsd[TSN_TSD_ATTR_MAX_FRM_NUM]);
 
 		if (ntsd[TSN_TSD_ATTR_SYN_IMME])
-			tsd.syn_flag = 2; // Cycle timer begins immediately.
+			tsd.syn_flag = 2;
 		else
-			tsd.syn_flag = 1; // TSD enable and Cycle timer will begin at the first frame coming.
+			tsd.syn_flag = 1;
 
 		tsd.enable = true;
 	}
@@ -2423,18 +2445,19 @@ static int tsn_tsd_get(struct sk_buff *skb, struct genl_info *info)
 	int ret;
 	struct genlmsghdr *genlhdr;
 	struct tsn_tsd_status tts;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_TSD]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->tsd_get) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2497,10 +2520,13 @@ static int tsn_ct_set(struct sk_buff *skb, struct genl_info *info)
 	const struct tsn_ops *tsnops;
 	int ret;
 	u8 queue_stat;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CT]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2509,9 +2535,6 @@ static int tsn_ct_set(struct sk_buff *skb, struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_CT];
 
-
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->ct_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2543,10 +2566,13 @@ static int tsn_cbgen_set(struct sk_buff *skb, struct genl_info *info)
 	int ret;
 	u32 index;
 	struct tsn_seq_gen_conf sg_conf;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBGEN]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2555,9 +2581,6 @@ static int tsn_cbgen_set(struct sk_buff *skb, struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_CBGEN];
 
-
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->cbgen_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2596,10 +2619,13 @@ static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 	int ret;
 	u32 index;
 	struct tsn_seq_rec_conf sr_conf;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBREC]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2608,9 +2634,6 @@ static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_CBREC];
 
-
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->cbrec_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2646,10 +2669,13 @@ static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
 	const struct tsn_ops *tsnops;
 	int ret;
 	bool enable = 0;
+	struct tsn_port *port;
 
-	ret = tsn_init_check(info, &netdev);
-	if (ret)
-		return ret;
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_PCPMAP]) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
@@ -2658,9 +2684,6 @@ static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_PCPMAP];
 
-
-	tsnops = netdev->tsn_ops;
-
 	if (!tsnops->pcpmap_set) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -1;
@@ -2757,20 +2780,6 @@ static const struct genl_ops tsnnl_ops[] = {
 		.policy		= tsn_cmd_policy,
 		.flags		= GENL_ADMIN_PERM,
 	},
-#if 0
-	{
-		.cmd		= TSN_CMD_QCI_SGI_SET_LIST,
-		.doit		= tsn_qci_sgi_list_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SGI_GET_LIST,
-		.doit		= tsn_qci_sgi_list_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-#endif
 	{
 		.cmd		= TSN_CMD_QCI_SGI_GET_STATUS,
 		.doit		= tsn_qci_sgi_status_get,
@@ -2866,6 +2875,61 @@ static struct genl_family tsn_family = {
 #endif
 };
 
+int tsn_port_register(struct net_device *netdev, struct tsn_ops *tsnops, u16 groupid)
+{
+	struct tsn_port *port;
+
+	if (list_empty(&port_list)) {
+		INIT_LIST_HEAD(&port_list);
+	} else {
+		list_for_each_entry(port, &port_list, list) {
+			if (port->netdev == netdev) {
+				pr_info("TSN device already registered!\n");
+				return -1;
+			}
+		}
+	}
+
+	port = kzalloc(sizeof(struct tsn_port), GFP_KERNEL);
+	if (!port)
+		return -1;
+
+	port->netdev = netdev;
+	port->groupid = groupid;
+	port->tsnops = tsnops;
+
+	if (groupid < GROUP_OFFSET_SWITCH)
+		port->type = TSN_ENDPOINT;
+	else
+		port->type = TSN_SWITCH;
+
+	list_add_tail(&port->list, &port_list);
+
+	if (tsnops && tsnops->device_init)
+		port->tsnops->device_init(netdev);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(tsn_port_register);
+
+void tsn_port_unregister(struct net_device *netdev)
+{
+	struct tsn_port *p;
+
+	list_for_each_entry(p, &port_list, list) {
+		if (p->netdev == netdev) {
+			if (p && p->tsnops->device_deinit)
+				p->tsnops->device_deinit(netdev);
+			list_del(&p->list);
+			kfree(p);
+			break;
+		}
+	}
+}
+
+EXPORT_SYMBOL(tsn_port_unregister);
+
 static int __init tsn_genetlink_init(void)
 {
 	int ret;
-- 
2.17.1


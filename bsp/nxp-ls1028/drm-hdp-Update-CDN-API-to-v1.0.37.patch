From 3746e1bb885b32361b5e0d130f88035728933c42 Mon Sep 17 00:00:00 2001
From: Alison Wang <alison.wang@nxp.com>
Date: Tue, 15 May 2018 11:24:13 +0800
Subject: [PATCH 260/706] drm: hdp: Update CDN API to v1.0.37

This patch updates CDN API to v1.0.37.

Signed-off-by: Alison Wang <alison.wang@nxp.com>
(cherry picked from commit bdbb85a09e3a581700bf33b5ff5cc684cbf3fba0)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c     | 239 +++++++++++++-----
 drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h     |   1 +
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h     |  16 ++
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c    |  32 +++
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h    |  33 ++-
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.c |  32 +++
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.h |  14 +
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c  |   1 +
 .../gpu/drm/imx/hdp/cdn_hdp/general_handler.h |   1 +
 drivers/gpu/drm/imx/hdp/cdn_hdp/opcodes.h     |   1 +
 drivers/gpu/drm/imx/hdp/cdn_hdp/util.h        |   3 +
 drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h   |   4 +
 12 files changed, 308 insertions(+), 69 deletions(-)

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c
index 95f9ebd95e6f..a88521da3c4e 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c
@@ -18,22 +18,54 @@
 #include "API_AFE_mcu1_dp.h"
 #include "./cdn_hdp/all.h"
 
+u8 AFE_check_rate_supported(ENUM_AFE_LINK_RATE rate)
+{
+	switch (rate) {
+	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
+	case AFE_LINK_RATE_2_7:
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
+	case AFE_LINK_RATE_5_4:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
 static void AFE_WriteReg(state_struct *state, ENUM_AFE_LINK_RATE link_rate,
-				u32 addr, u32 val1_6, u32 val2_7, u32 val5_4)
+			 unsigned int addr,
+			 unsigned int val1_6,
+			 unsigned int val2_1,
+			 unsigned int val2_4,
+			 unsigned int val2_7,
+			 unsigned int val3_2,
+			 unsigned int val4_3,
+			 unsigned int val5_4)
 {
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
 		Afe_write(state, addr, val1_6);
 		break;
-
+	case AFE_LINK_RATE_2_1:
+		Afe_write(state, addr, val2_1);
+		break;
+	case AFE_LINK_RATE_2_4:
+		Afe_write(state, addr, val2_4);
+		break;
 	case AFE_LINK_RATE_2_7:
 		Afe_write(state, addr, val2_7);
 		break;
-
+	case AFE_LINK_RATE_3_2:
+		Afe_write(state, addr, val3_2);
+		break;
+	case AFE_LINK_RATE_4_3:
+		Afe_write(state, addr, val4_3);
+		break;
 	case AFE_LINK_RATE_5_4:
 		Afe_write(state, addr, val5_4);
 		break;
-
 	case AFE_LINK_RATE_8_1:	/* Not used in MCU1 */
 	default:
 		pr_err("Warning. Unsupported Link Rate!\n");
@@ -52,43 +84,6 @@ void phy_cfg_24mhz(state_struct *state, int num_lanes)
 	}
 }
 
-/* Valid for 24 MHz only */
-void phy_cfg_dp_cmn_pll0(state_struct *state, int num_lanes)
-{
-	int k;
-	volatile u16 rdata;
-
-	Afe_write(state, PHY_HDP_CLK_CTL, 0x2405);
-	Afe_write(state, CMN_PLL0_INTDIV, 0x0086);
-	Afe_write(state, CMN_PLL0_FRACDIV, 0xF915);
-	Afe_write(state, CMN_PLL0_HIGH_THR, 0x0022);
-	Afe_write(state, CMN_PLL0_SS_CTRL1, 0x0140);
-	rdata = Afe_read(state, CMN_DIAG_HSCLK_SEL);
-	rdata = rdata & 0xFFFC;
-	rdata = rdata | 0x0001;
-	Afe_write(state, CMN_DIAG_HSCLK_SEL, rdata);
-	for (k = 0; k < num_lanes; k = k + 1) {
-		rdata = Afe_read(state, (XCVR_DIAG_HSCLK_SEL | (k << 9)));
-		rdata = rdata & 0xCFFF;
-		rdata = rdata | 0x1000;
-		Afe_write(state, (XCVR_DIAG_HSCLK_SEL | (k << 9)), rdata);
-	}
-	Afe_write(state, CMN_PLL0_VCOCAL_START, 0x3061);
-	Afe_write(state, CMN_PLLSM0_USER_DEF_CTRL, 0x0000);
-	Afe_write(state, CMN_DIAG_PLL0_V2I_TUNE, 0x0006);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x008c);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x002e);
-	Afe_write(state, CMN_DIAG_PLL0_CP_TUNE, 0x0026);
-	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
-	Afe_write(state, CMN_PLL0_VCOCAL_INIT_TMR, 0x00F0);
-	Afe_write(state, CMN_PLL0_VCOCAL_ITER_TMR, 0x0018);
-	Afe_write(state, CMN_PLL0_SS_CTRL2, 0x7F03);
-	Afe_write(state, CMN_PLL0_DSM_DIAG, 0x0020);
-	Afe_write(state, CMN_DIAG_PLL0_OVRD, 0x0000);
-	Afe_write(state, CMN_DIAG_PLL0_FBH_OVRD, 0x0000);
-	Afe_write(state, CMN_DIAG_PLL0_FBL_OVRD, 0x0000);
-}
-
 /* Valid for 24 MHz only */
 void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
 {
@@ -100,14 +95,16 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
 	case AFE_LINK_RATE_2_7:
 		rdata = rdata | 0x2400;
 		break;
-
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
 	case AFE_LINK_RATE_5_4:
 		rdata = rdata | 0x1200;
 		break;
-
 	case AFE_LINK_RATE_8_1:	/* nNot used in MCU1 */
 	default:
 		pr_err("Warning. Unsupported Link Rate!\n");
@@ -119,14 +116,16 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 	rdata = rdata & 0xFFCC;
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
 	case AFE_LINK_RATE_2_7:
 		rdata = rdata | 0x0011;
 		break;
-
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
 	case AFE_LINK_RATE_5_4:
 		rdata = rdata | 0x0000;
 		break;
-
 	case AFE_LINK_RATE_8_1:	/* Not used in MCU1 */
 	default:
 		pr_err("Warning. Unsupported Link Rate!\n");
@@ -138,14 +137,16 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 		rdata = rdata & 0xCFFF;
 		switch (link_rate) {
 		case AFE_LINK_RATE_1_6:
+		case AFE_LINK_RATE_2_1:
+		case AFE_LINK_RATE_2_4:
 		case AFE_LINK_RATE_2_7:
 			rdata = rdata | 0x1000;
 			break;
-
+		case AFE_LINK_RATE_3_2:
+		case AFE_LINK_RATE_4_3:
 		case AFE_LINK_RATE_5_4:
 			rdata = rdata | 0x0000;
 			break;
-
 		case AFE_LINK_RATE_8_1:	/* Not used in MCU1 */
 		default:
 			pr_err("Warning. Unsupported Link Rate!\n");
@@ -153,38 +154,43 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 		}
 		Afe_write(state, (XCVR_DIAG_HSCLK_SEL | (k << 9)), rdata);
 	}
-	AFE_WriteReg(state, link_rate, CMN_PLL0_VCOCAL_START, 0x3061, 0x30D0, 0x30D0);
-	AFE_WriteReg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL, 0x0000, 0x1000,
-		     0x1000);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE, 0x0006, 0x0007, 0x0007);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x008C);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x002E);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_CP_TUNE, 0x0026, 0x0029, 0x0029);
-	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
 	Afe_write(state, CMN_PLL0_VCOCAL_INIT_TMR, 0x00F0);
 	Afe_write(state, CMN_PLL0_VCOCAL_ITER_TMR, 0x0018);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_INTDIV, 0x0086, 0x00E0, 0x00E0);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_FRACDIV, 0xF915, 0xF479, 0xF479);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_HIGH_THR, 0x0022, 0x0038, 0x0038);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_SS_CTRL1, 0x0140, 0x0204, 0x0204);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_VCOCAL_START, 0x3061, 0x3092, 0x30B3, 0x30D0, 0x3061, 0x3092, 0x30D0);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_INTDIV, 0x0086, 0x00B3, 0x00CA, 0x00E0, 0x0086, 0x00B3, 0x00E0);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_FRACDIV, 0xF917, 0xF6C7, 0x75A1, 0xF479, 0xF917, 0xF6C7, 0xF479);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_HIGH_THR, 0x0022, 0x002D, 0x0033, 0x0038, 0x0022, 0x002D, 0x0038);
+#ifdef SSC_ON_INIT
+	/* Following register writes enable SSC on PHY's initialization */
+	AFE_WriteReg(state, link_rate, CMN_PLL0_SS_CTRL1, 0x0140, 0x01AB, 0x01E0, 0x0204, 0x0140, 0x01AB, 0x0204);
 	Afe_write(state, CMN_PLL0_SS_CTRL2, 0x7F03);
+#endif
 	Afe_write(state, CMN_PLL0_DSM_DIAG, 0x0020);
+	AFE_WriteReg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL, 0x0000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x1000);
 	Afe_write(state, CMN_DIAG_PLL0_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBH_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBL_OVRD, 0x0000);
+	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE, 0x0006, 0x0007, 0x0007, 0x0007, 0x0006, 0x0007, 0x0007);
+	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_CP_TUNE, 0x0026, 0x0029, 0x0029, 0x0029, 0x0026, 0x0029, 0x0029);
+	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
+	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x008C);
+	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x002E);
+
 	for (k = 0; k < num_lanes; k = k + 1) {
 		rdata = Afe_read(state, (XCVR_DIAG_PLLDRC_CTRL | (k << 9)));
 		rdata = rdata & 0x8FFF;
 		switch (link_rate) {
 		case AFE_LINK_RATE_1_6:
+		case AFE_LINK_RATE_2_1:
+		case AFE_LINK_RATE_2_4:
 		case AFE_LINK_RATE_2_7:
 			rdata = rdata | 0x2000;
 			break;
-
+		case AFE_LINK_RATE_3_2:
+		case AFE_LINK_RATE_4_3:
 		case AFE_LINK_RATE_5_4:
 			rdata = rdata | 0x1000;
 			break;
-
 		case AFE_LINK_RATE_8_1:	/* Not used in MCU1 */
 		default:
 			pr_err("Warning. Unsupported Link Rate!\n");
@@ -197,13 +203,25 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 void phy_cfg_dp_ln(state_struct *state, int num_lanes)
 {
 	int k;
+	u16 rdata;
 
 	for (k = 0; k < num_lanes; k = k + 1) {
 		Afe_write(state, (XCVR_PSM_RCTRL | (k << 9)), 0xBEFC);
-		Afe_write(state, (TX_PSC_A0 | (k << 9)), 0x6799);
-		Afe_write(state, (TX_PSC_A1 | (k << 9)), 0x6798);
-		Afe_write(state, (TX_PSC_A2 | (k << 9)), 0x0098);
-		Afe_write(state, (TX_PSC_A3 | (k << 9)), 0x0098);
+		if (state->edp == 0) {
+			Afe_write(state, (TX_PSC_A0 | (k << 9)), 0x6799);
+			Afe_write(state, (TX_PSC_A1 | (k << 9)), 0x6798);
+			Afe_write(state, (TX_PSC_A2 | (k << 9)), 0x0098);
+			Afe_write(state, (TX_PSC_A3 | (k << 9)), 0x0098);
+		} else {
+			Afe_write(state, (TX_PSC_A0 | (k << 9)), 0x279B);
+			Afe_write(state, (TX_PSC_A1 | (k << 9)), 0x2798);
+			Afe_write(state, (TX_PSC_A2 | (k << 9)), 0x0098);
+			Afe_write(state, (TX_PSC_A3 | (k << 9)), 0x0098);
+			rdata = Afe_read(state, (TX_DIAG_TX_DRV | (k << 9)));
+			rdata &= 0x0600;	/* keep bits related to programmable boost */
+			rdata |= 0x00C0;
+			Afe_write(state, (TX_DIAG_TX_DRV | (k << 9)), rdata);
+		}
 	}
 }
 
@@ -222,7 +240,7 @@ u16 aux_cal_cfg(state_struct *state, u16 prev_calib_code)
 	txpd_adj_calib_code = Afe_read(state, CMN_TXPD_ADJ_CTRL);
 
 	new_calib_code = ((txpu_calib_code + txpd_calib_code) / 2)
-	    + txpu_adj_calib_code + txpd_adj_calib_code;
+		+ txpu_adj_calib_code + txpd_adj_calib_code;
 
 	if (new_calib_code != prev_calib_code) {
 		rdata = Afe_read(state, TX_ANA_CTRL_REG_1);
@@ -271,6 +289,7 @@ void aux_cfg(state_struct *state)
 	Afe_write(state, TX_ANA_CTRL_REG_2, 0x030F);
 	mdelay(5);
 
+	rdata = Afe_read(state, TX_ANA_CTRL_REG_1);
 	pr_info("TX_ANA_CTRL_REG_1 %x)\n", rdata);
 	rdata = Afe_read(state, TX_ANA_CTRL_REG_2);
 	pr_info("TX_ANA_CTRL_REG_2 %x)\n", rdata);
@@ -286,6 +305,76 @@ void AFE_init(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
 {
 	volatile u16 val;
 
+	if (AFE_check_rate_supported(link_rate) == 0) {
+		pr_info("AFE_init() *E: Selected link rate not supported: 0x%x\n", link_rate);
+		return;
+	}
+#if FPGA
+	volatile unsigned short temp;
+
+	//1.    Assert
+	//a.    Iddq_Enable_pad  = 1’b0       // reg12[27]
+
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp & (~(1<<27));
+	cdn_apb_write(0xc000c<<2, temp);
+
+	//b.    Pll_ats_eanble = 1’b0 //reg12[29]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp & (~(1<<29));
+	cdn_apb_write(0xc000c<<2, temp);
+
+	//2.    Assert all Reset pads to Low
+	//a.    Tap_trst_n = 1’b0 //reg12[3]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp & (~(1<<3));
+	cdn_apb_write(0xc000c<<2, temp);
+
+	//b.    Apb_preset_n = 1’b0 //reg12[2]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp & (~(1<<2));
+	cdn_apb_write(0xc000c<<2, temp);
+
+	//c.    Chip_rst_b = 1’b0 reg12[0]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp & (~(1<<0));
+	cdn_apb_write(0xc000c<<2, temp);
+
+	//d.    Phy_reset_n = 1’b0 //reg12[1]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp & (~(1<<1));
+	cdn_apb_write(0xc000c<<2, temp);
+
+	//3.    Assert Chipmode[2:0] = 3’b000 reg11[2:0]
+	cdn_apb_read(0xc000b<<2, &temp);
+	temp = temp & (~(7<<0));
+	cdn_apb_write(0xc000b<<2, temp);
+
+	//4.    Assert Sel_Tap[1:0]= 2’b00  //reg11[4:3];
+	cdn_apb_read(0xc000b<<2, &temp);
+	temp = temp & (~(3<<3));
+	cdn_apb_write(0xc000b<<2, temp);
+
+	//5.    Assert
+	//a.    After 100ns, Apb_preset_n = 1’b1 //reg12[2]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp | ((1<<2));
+	cdn_apb_write(0xc000c<<2, temp);
+
+
+	//b.    After 100ns, Chip_reset_b = 1’b1 // Reg12[0]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp | ((1<<0));
+	cdn_apb_write(0xc000c<<2, temp);
+
+
+	//c.    After 100ns, Tap_trst_n = 1’b1 //reg12[3]
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp | ((1<<3));
+	cdn_apb_write(0xc000c<<2, temp);
+
+#endif
+
 	val = Afe_read(state, PHY_PMA_CMN_CTRL1);
 	val = val & 0xFFF7;
 	val = val | 0x0008;
@@ -303,18 +392,34 @@ void AFE_init(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
 	val = val | 0x0030;
 	Afe_write(state, PHY_PMA_CMN_CTRL1, val);
 
+	if (state->edp != 0)
+		Afe_write(state, CMN_DIAG_CAL_CTRL, 0x0001);
+
 	phy_cfg_dp_ln(state, num_lanes);
 
 	/* Configure PHY in A2 Mode */
 	Afe_write(state, PHY_HDP_MODE_CTRL, 0x0004);
 
+#if FPGA
+	//Assert  Phy_reset_n = 1’b1
+
+	cdn_apb_read(0xc000c<<2, &temp);
+	temp = temp | ((1<<1));
+	cdn_apb_write(0xc000c<<2, temp);
+#endif
 }
 
-void AFE_power(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
+void AFE_power(state_struct *state, int num_lanes,
+	       ENUM_AFE_LINK_RATE link_rate)
 {
 	static u16 prev_calib_code;
 	volatile u16 val;
 
+	if (AFE_check_rate_supported(link_rate) == 0) {
+		pr_info("%s *E: Selected link rate not supported: 0x%x\n", __func__, link_rate);
+		return;
+	}
+
 	Afe_write(state, TX_DIAG_ACYA_0, 1);
 	Afe_write(state, TX_DIAG_ACYA_1, 1);
 	Afe_write(state, TX_DIAG_ACYA_2, 1);
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h
index 21f021f4be28..5e2f818bba4f 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h
@@ -48,6 +48,7 @@
 #define CMN_DIAG_PLL0_PTATIS_TUNE2 0x01C9
 #define CMN_DIAG_PLL0_CP_TUNE 0x01C6
 #define CMN_DIAG_PER_CAL_ADJ 0x01EC
+#define CMN_DIAG_CAL_CTRL 0x01ED
 #define CMN_DIAG_PLL0_LF_PROG 0x01C7
 #define CMN_PLL0_VCOCAL_INIT_TMR 0x0084
 #define CMN_PLL0_VCOCAL_ITER_TMR 0x0085
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h
index 732b097d3f28..e00d6238b166 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AFE.h
@@ -21,11 +21,26 @@
 
 typedef enum {
 	AFE_LINK_RATE_1_6 = 0x6,
+	AFE_LINK_RATE_2_1 = 0x8,
+	AFE_LINK_RATE_2_4 = 0x9,
 	AFE_LINK_RATE_2_7 = 0xA,
+	AFE_LINK_RATE_3_2 = 0xC,
+	AFE_LINK_RATE_4_3 = 0x10,
 	AFE_LINK_RATE_5_4 = 0x14,
 	AFE_LINK_RATE_8_1 = 0x1A,
 } ENUM_AFE_LINK_RATE;
 
+/*
+ * Some of the PHY programming sequences
+ * depend on the reference clock frequency.
+ * Variable of this type is used to control
+ * the programming flow.
+ */
+typedef enum {
+	REFCLK_24MHZ,
+	REFCLK_27MHZ
+} REFCLK_FREQ;
+
 typedef enum {
 	CLK_RATIO_1_1,
 	CLK_RATIO_5_4,
@@ -42,6 +57,7 @@ typedef struct {
 	u8 msb;
 } reg_field_t;
 
+unsigned char AFE_check_rate_supported(ENUM_AFE_LINK_RATE rate);
 void Afe_write(state_struct *state, u32 offset, u16 val);
 u16 Afe_read(state_struct *state, u32 offset);
 void AFE_init(state_struct *state, int num_lanes,
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c
index d761356cf07c..e071e736f661 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c
@@ -100,6 +100,8 @@ CDN_API_STATUS CDN_API_DPTX_SetHostCap(state_struct *state, u8 maxLinkRate,
 				       u8 fastLinkTraining,
 				       u8 laneMapping, u8 enchanced)
 {
+	// fifth bit of lanesCount_SSC is used to declare eDP.
+	state->edp = ((lanesCount_SSC >> 5) & 1);
 	if (!state->running) {
 		if (!internal_apb_available(state))
 			return CDN_BSY;
@@ -173,6 +175,36 @@ CDN_API_STATUS CDN_API_DPTX_Control_blocking(state_struct *state, u32 mode)
 	internal_block_function(CDN_API_DPTX_Control(state, mode));
 }
 
+CDN_API_STATUS CDN_API_DPTX_EDP_Training(state_struct *state,
+					 u8 mode, ENUM_AFE_LINK_RATE linkRate,
+					 u8 rateId)
+{
+	if (AFE_check_rate_supported(linkRate) == 0)
+		return CDN_ERROR_NOT_SUPPORTED;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_DP_TX,
+				      DPTX_EDP_RATE_TRAINING, 3,
+				      1, mode,
+				      1, (u8)linkRate,
+				      1, rateId);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	internal_process_messages(state);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_DPTX_EDP_Training_blocking(state_struct *state, u8 mode,
+						  ENUM_AFE_LINK_RATE linkRate,
+						  u8 rateId)
+{
+	internal_block_function(CDN_API_DPTX_EDP_Training(state, mode,
+							  linkRate, rateId));
+}
+
 CDN_API_STATUS CDN_API_DPTX_Write_DPCD(state_struct *state, u32 numOfBytes,
 				       u32 addr, u8 *buff,
 				       DPTX_Write_DPCD_response *resp,
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h
index 7457c47920d0..f6acc04a6619 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h
@@ -17,8 +17,9 @@
 #ifndef _API_DPTX_H_
 #define _API_DPTX_H_
 
-# include "API_General.h"
-# include "vic_table.h"
+#include "API_General.h"
+#include "vic_table.h"
+#include "API_AFE.h"
 
 #define MAX_NUM_OF_EVENTS 4
 
@@ -244,6 +245,34 @@ CDN_API_STATUS CDN_API_DPTX_Control(state_struct *state, u32 mode);
  */
 CDN_API_STATUS CDN_API_DPTX_Control_blocking(state_struct *state, u32 mode);
 
+/**
+  * \brief Performs Fast Link Training, using LINK_RATE_SET DPCD register.
+  * \param [in] mode - 0 to stop training, 1 to start it, 2 to restart it.
+  * \param [in] linkRate - Link Rate to be used for training.
+  * \param [in] rateId - index of selected Link Rate in DPCd registers.
+  *
+  * Performs Fast Link Training, selecting Link Rate using LINK_RATE_SET DPCD
+  * register, characteristic to Embedded DisplayPort (eDP) v1.4 standard.
+  * If requested link rate is not supported by DPTX, function will return error
+  * code CDN_ERROR_NOT_SUPPORTED, and will take no further action.
+  * rateId is used to select, which Link Rate supported by sink (enumerated in
+  * SUPPORTED_LINK_RATES DPCD registers) is equal to rate requested. This value
+  * will be written to first 3 bits of LINK_RATE_SET DPCD registers. Allowed
+  * range is 0-7. If it is not known beforehand, SUPPORTED_LINK_RATES DPCD
+  * registers may be read by an upper layer, and then used to determine the
+  * correct value to use.
+  */
+CDN_API_STATUS CDN_API_DPTX_EDP_Training(state_struct *state, u8 mode,
+					 ENUM_AFE_LINK_RATE linkRate,
+					 u8 rateId);
+
+/**
+ * blocking version of #CDN_API_DPTX_EDP_Training
+ */
+CDN_API_STATUS CDN_API_DPTX_EDP_Training_blocking(state_struct *state, u8 mode,
+						  ENUM_AFE_LINK_RATE linkRate,
+						  u8 rateId);
+
 /**
   * \brief send DPX_ENABLE_EVENT command
   */
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.c
index 7d0da38ef53d..bab6ceb0ca31 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.c
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.c
@@ -15,6 +15,7 @@
  */
 
 #include "API_General.h"
+#include "util.h"
 #include "address.h"
 #include "apb_cfg.h"
 #include "opcodes.h"
@@ -439,3 +440,34 @@ CDN_API_STATUS CDN_API_General_Phy_Test_Access_blocking(state_struct *state,
 {
 	internal_block_function(CDN_API_General_Phy_Test_Access(state, resp));
 }
+
+CDN_API_STATUS CDN_API_General_GetHpdState(state_struct *state, u8 *hpd_state)
+{
+	CDN_API_STATUS ret;
+	*hpd_state = 0;
+
+	if (!state->running) {
+		if (!internal_apb_available(state))
+			return CDN_BSY;
+
+		internal_tx_mkfullmsg(state, MB_MODULE_ID_GENERAL, GENERAL_GET_HPD_STATE, 0);
+		state->bus_type = CDN_BUS_TYPE_APB;
+		state->rxEnable = 1;
+		return CDN_STARTED;
+	}
+
+	internal_process_messages(state);
+	ret = internal_test_rx_head(state, MB_MODULE_ID_GENERAL,
+				    GENERAL_GET_HPD_STATE);
+	if (ret != CDN_OK)
+		return ret;
+
+	internal_readmsg(state, 1, 1, hpd_state);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_GetHpdState_blocking(state_struct *state, u8 *hpd_state)
+{
+	internal_block_function(CDN_API_General_GetHpdState(state, hpd_state));
+}
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.h
index c5de04b49a49..15ec2358d312 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_General.h
@@ -211,4 +211,18 @@ CDN_API_STATUS CDN_API_General_Phy_Test_Access(state_struct *state, u8 *resp);
 CDN_API_STATUS CDN_API_General_Phy_Test_Access_blocking(state_struct *state,
 							u8 *resp);
 
+/**
+ * Read HPD state to check if plug is inserted or not.
+ * @param state [out] Pointer to variable where state will be stored.
+ *  Bit 0: 0 - plug not inserted, 1 - plug inserted.
+ *  Bits 1..7: reserved.
+ * @return status
+ */
+CDN_API_STATUS CDN_API_General_GetHpdState(state_struct *state, u8 *hpd_state);
+
+/**
+ * \breif blocking version of #CDN_API_General_GetHpdState
+ */
+CDN_API_STATUS CDN_API_General_GetHpdState_blocking(state_struct *state, u8 *hpd_state);
+
 #endif
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c
index 6369b75cc403..596a4679f8c1 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c
@@ -22,6 +22,7 @@
 #include "address.h"
 #include "source_car.h"
 #include "source_vif.h"
+#include "general_handler.h"
 
 CDN_API_STATUS CDN_API_HDMITX_DDC_READ(state_struct *state,
 				       HDMITX_TRANS_DATA *data_in,
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/general_handler.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/general_handler.h
index 1171f6185b45..d6eb2b9844c3 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/general_handler.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/general_handler.h
@@ -38,6 +38,7 @@
 #define GENERAL_WRITE_REGISTER          0x05
 #define GENERAL_WRITE_FIELD             0x06
 #define GENERAL_READ_REGISTER           0x07
+#define GENERAL_GET_HPD_STATE           0x11
 
 #define GENERAL_TEST_TRNG_SIMPLE        0xF0
 
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/opcodes.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/opcodes.h
index 2c97891b0ef7..8980b76d946b 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/opcodes.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/opcodes.h
@@ -41,6 +41,7 @@
 #define DPTX_SET_LINK_BREAK_POINT        0x0F
 #define DPTX_FORCE_LANES                0x10
 #define DPTX_HPD_STATE                             0x11
+#define DPTX_EDP_RATE_TRAINING		0x12
 #define DPTX_DBG_SET                               0xF0
 #define DP_TX_OPCODE_READ_I2C_REQUEST              0xA5
 #define DP_TX_OPCODE_WRITE_I2C_REQUEST             0xA6
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h
index 89d920143940..6f30fe65ce34 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h
@@ -61,6 +61,8 @@ typedef enum {
 	CDN_CEC_ERR_RX_FAILED,
     /** Operation aborted. */
 	CDN_CEC_ERR_ABORT,
+    /** All Logical Addresses are in use. */
+	CDN_CEC_ERR_ALL_LA_IN_USE,
 } CDN_API_STATUS;
 
 typedef enum {
@@ -123,6 +125,7 @@ typedef struct {
 	u8 running;
 	CDN_BUS_TYPE bus_type;
 	u32 tmp;
+	u32 edp; /* use eDP */
 
 	struct mutex mutex;	//mutex may replace running
 	struct hdp_mem mem;
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h
index b43219986ec6..9adbf2756e4e 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h
@@ -65,7 +65,11 @@ typedef enum {
 
 typedef enum {
 	RATE_1_6 = 162,
+	RATE_2_1 = 216,
+	RATE_2_4 = 243,
 	RATE_2_7 = 270,
+	RATE_3_2 = 324,
+	RATE_4_3 = 432,
 	RATE_5_4 = 540,
 	RATE_8_1 = 810,
 } VIC_SYMBOL_RATE;
-- 
2.17.1


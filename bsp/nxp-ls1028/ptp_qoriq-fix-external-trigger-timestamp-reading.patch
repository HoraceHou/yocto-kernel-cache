From 928790613a260dea33ffedc186e9182a7a10cf93 Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@nxp.com>
Date: Thu, 27 Dec 2018 13:19:03 +0800
Subject: [PATCH 448/706] ptp_qoriq: fix external trigger timestamp reading

Added a function to read latest external trigger timestamp
and to clean timestamp FIFO. External trigger timestamp FIFO
should be cleaned before enabling external trigger interrupt.
Otherwise, the newer timestamp will be discarded if the FIFO
overflows.

Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
(cherry picked from commit 3112fed2302e118f4d59d5a33cb5cdbf7a587c94)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/ptp/ptp_qoriq.c       | 46 +++++++++++++++++++++++++++++++----
 include/linux/fsl/ptp_qoriq.h |  2 ++
 2 files changed, 43 insertions(+), 5 deletions(-)

diff --git a/drivers/ptp/ptp_qoriq.c b/drivers/ptp/ptp_qoriq.c
index 5dd7c5208edf..24ec13edb85b 100644
--- a/drivers/ptp/ptp_qoriq.c
+++ b/drivers/ptp/ptp_qoriq.c
@@ -90,6 +90,39 @@ static void set_fipers(struct qoriq_ptp *qoriq_ptp)
 		    qoriq_ptp->tmr_fiper2);
 }
 
+/* Caller must hold qoriq_ptp->lock. */
+static int extts_read_clean(struct qoriq_ptp *qoriq_ptp,
+			    int index, u32 *lo, u32 *hi)
+{
+	struct qoriq_ptp_registers *regs = &qoriq_ptp->regs;
+	void __iomem *reg_etts_l;
+	void __iomem *reg_etts_h;
+	u32 valid;
+
+	switch (index) {
+	case 0:
+		valid = ETS1_VLD;
+		reg_etts_l = &regs->etts_regs->tmr_etts1_l;
+		reg_etts_h = &regs->etts_regs->tmr_etts1_h;
+		break;
+	case 1:
+		valid = ETS2_VLD;
+		reg_etts_l = &regs->etts_regs->tmr_etts2_l;
+		reg_etts_h = &regs->etts_regs->tmr_etts2_h;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Read latest extts, and drop all others to clean FIFO */
+	while (qoriq_read(qoriq_ptp, &regs->ctrl_regs->tmr_stat) & valid) {
+		*lo = qoriq_read(qoriq_ptp, reg_etts_l);
+		*hi = qoriq_read(qoriq_ptp, reg_etts_h);
+	}
+
+	return 0;
+}
+
 /*
  * Interrupt service routine
  */
@@ -106,8 +139,9 @@ irqreturn_t ptp_qoriq_isr(int irq, void *priv)
 
 	if (val & ETS1) {
 		ack |= ETS1;
-		hi = qoriq_read(qoriq_ptp, &regs->etts_regs->tmr_etts1_h);
-		lo = qoriq_read(qoriq_ptp, &regs->etts_regs->tmr_etts1_l);
+		spin_lock(&qoriq_ptp->lock);
+		extts_read_clean(qoriq_ptp, 0, &lo, &hi);
+		spin_unlock(&qoriq_ptp->lock);
 		event.type = PTP_CLOCK_EXTTS;
 		event.index = 0;
 		event.timestamp = ((u64) hi) << 32;
@@ -117,8 +151,9 @@ irqreturn_t ptp_qoriq_isr(int irq, void *priv)
 
 	if (val & ETS2) {
 		ack |= ETS2;
-		hi = qoriq_read(qoriq_ptp, &regs->etts_regs->tmr_etts2_h);
-		lo = qoriq_read(qoriq_ptp, &regs->etts_regs->tmr_etts2_l);
+		spin_lock(&qoriq_ptp->lock);
+		extts_read_clean(qoriq_ptp, 1, &lo, &hi);
+		spin_unlock(&qoriq_ptp->lock);
 		event.type = PTP_CLOCK_EXTTS;
 		event.index = 1;
 		event.timestamp = ((u64) hi) << 32;
@@ -265,7 +300,7 @@ int ptp_qoriq_enable(struct ptp_clock_info *ptp,
 	struct qoriq_ptp *qoriq_ptp = container_of(ptp, struct qoriq_ptp, caps);
 	struct qoriq_ptp_registers *regs = &qoriq_ptp->regs;
 	unsigned long flags;
-	u32 bit, mask;
+	u32 bit, mask, lo, hi;
 
 	switch (rq->type) {
 	case PTP_CLK_REQ_EXTTS:
@@ -280,6 +315,7 @@ int ptp_qoriq_enable(struct ptp_clock_info *ptp,
 			return -EINVAL;
 		}
 		spin_lock_irqsave(&qoriq_ptp->lock, flags);
+		extts_read_clean(qoriq_ptp, rq->extts.index, &lo, &hi);
 		mask = qoriq_read(qoriq_ptp, &regs->ctrl_regs->tmr_temask);
 		if (on)
 			mask |= bit;
diff --git a/include/linux/fsl/ptp_qoriq.h b/include/linux/fsl/ptp_qoriq.h
index 0393dd06a781..49dc65b7d5d2 100644
--- a/include/linux/fsl/ptp_qoriq.h
+++ b/include/linux/fsl/ptp_qoriq.h
@@ -120,6 +120,8 @@ struct qoriq_ptp_registers {
 /* Bit definitions for the TMR_STAT register */
 #define STAT_VEC_SHIFT        (0) /* Timer general purpose status vector */
 #define STAT_VEC_MASK         (0x3f)
+#define ETS1_VLD              (1<<24)
+#define ETS2_VLD              (1<<25)
 
 /* Bit definitions for the TMR_PRSC register */
 #define PRSC_OCK_SHIFT        (0) /* Output clock division/prescale factor. */
-- 
2.17.1


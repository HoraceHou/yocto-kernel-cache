From 4e08f3e1aac2c1b478ffce685a6e6bfab3d40cf4 Mon Sep 17 00:00:00 2001
From: Alison Wang <alison.wang@nxp.com>
Date: Tue, 9 Oct 2018 14:24:43 +0800
Subject: [PATCH 332/706] drm: hdp: remove CDN vic table

This patch removes CDN vic table and replaces with drm_display_mode.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Alison Wang <alison.wang@nxp.com>
(cherry picked from commit 8bb9032db1ee1ad7793480694afac9cb92f9a706)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c  |  16 +-
 .../imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h  |   5 +-
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.c     |  21 ++-
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.h     |   4 +-
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_Audio.h   |   1 -
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c    | 151 ++++++------------
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h    |   6 +-
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c  | 133 +++++++++------
 drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.h  |   4 +-
 drivers/gpu/drm/imx/hdp/cdn_hdp/Makefile      |   3 +-
 drivers/gpu/drm/imx/hdp/cdn_hdp/all.h         |   1 -
 drivers/gpu/drm/imx/hdp/cdn_hdp/util.h        |  45 ++++++
 drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.c   |  38 -----
 drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h   | 114 -------------
 drivers/gpu/drm/imx/hdp/imx-dp.c              |  20 ++-
 drivers/gpu/drm/imx/hdp/imx-dp.h              |  10 +-
 drivers/gpu/drm/imx/hdp/imx-hdmi.c            |  17 +-
 drivers/gpu/drm/imx/hdp/imx-hdmi.h            |   6 +-
 drivers/gpu/drm/imx/hdp/imx-hdp.c             | 110 +++++--------
 drivers/gpu/drm/imx/hdp/imx-hdp.h             |  15 +-
 20 files changed, 297 insertions(+), 423 deletions(-)
 delete mode 100644 drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.c
 delete mode 100644 drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
index fa264c2faf40..286706ee53dd 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
@@ -14,6 +14,7 @@
  ******************************************************************************
  */
 
+#include <drm/drmP.h>
 #include <linux/io.h>
 #include "API_AFE_ss28fdsoi_kiran_hdmitx.h"
 #include "ss28fdsoi_hdmitx_table.h"
@@ -74,15 +75,18 @@ int get_table_row(const u32 *array, u32 table_rows,
 	return i;
 }
 
-int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode, int bpp,
-		VIC_PXL_ENCODING_FORMAT format)
+int phy_cfg_hdp_ss28fdsoi(state_struct *state,
+					int num_lanes,
+					struct drm_display_mode *mode,
+					int bpp,
+					VIC_PXL_ENCODING_FORMAT format)
 {
 	const int phy_reset_workaround = 0;
 	u32 vco_freq_khz;
 	unsigned char i;
 	u32 row, feedback_factor;
 	uint32_t reg_val;
-	int pixel_freq_khz = vic_table[vicMode][PIXEL_FREQ_KHZ];
+	int pixel_freq_khz = mode->clock;
 	uint32_t character_clock_ratio_num = 1;
 	uint32_t character_clock_ratio_den = 1;
 	int character_freq_khz;
@@ -144,9 +148,9 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 	charge_pump_gain.msb = 8;
 	charge_pump_gain.lsb = 0;
 
-	pr_info
-	    ("phy_cfg_hdp() num_lanes: %0d, vicMode: %0d, color depth: %0d-bit, encoding: %0d\n",
-	     num_lanes, vicMode, bpp, format);
+	DRM_INFO("phy_cfg_hdp() num_lanes: %0d, mode:%dx%dp%d, ",
+		 num_lanes, mode->hdisplay, mode->vdisplay, mode->vrefresh);
+	DRM_INFO("color depth: %0d-bit, encoding: %0d\n", bpp, format);
 
 	/* register PHY_PMA_ISOLATION_CTRL enable PHY isolation mode only for CMN */
 	if (phy_reset_workaround) {
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h
index 92b0e4b3dba3..04d45e81b8fc 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h
@@ -19,8 +19,9 @@
 
 #include "./cdn_hdp/all.h"
 
-int phy_cfg_hdp_ss28fdsoi(state_struct * state, int num_lanes,
-				VIC_MODES vicMode, int bpp, VIC_PXL_ENCODING_FORMAT format);
+int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
+			  struct drm_display_mode *mode, int bpp,
+			  VIC_PXL_ENCODING_FORMAT format);
 int hdmi_tx_kiran_power_configuration_seq(state_struct *state, int num_lanes);
 int get_table_row_match_column(const u32 *array, u32 table_rows,
 			       u32 table_cols, u32 start_row,
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.c
index a38a702736ca..8c6e2a816490 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.c
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.c
@@ -17,14 +17,15 @@
 #include "API_AVI.h"
 #include "API_Infoframe.h"
 
-CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_Set_AVI(state_struct *state,
+			       struct drm_display_mode *mode,
 			       VIC_PXL_ENCODING_FORMAT colorMode,
 			       BT_TYPE ITUver)
 {
-	u32 active_slot = vic_table[vicMode][H_BLANK];
-	u32 line_width = vic_table[vicMode][H_TOTAL];
+	u32 active_slot = mode->htotal - mode->hdisplay;
+	u32 line_width = mode->htotal;
 	u32 Hactive = line_width - active_slot + 1;
-	u32 Vactive = vic_table[vicMode][V_ACTIVE] + 1;
+	u32 Vactive = mode->hdisplay + 1;
 
 	u32 Hactive_l = Hactive - 256 * ((u32) Hactive / 256);
 	u32 Hactive_h = Hactive / 256;
@@ -83,11 +84,17 @@ CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, VIC_MODES vicMode,
 	 * Active Format Aspec Ratio:
 	 * Same As Picture = 0x8 4:3(Center)=0x9 16:9=0xA 14:9=0xB
 	 */
-	packet_R = vic_table[vicMode][VIC_R3_0];
+	if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3)
+		packet_R = 9;
+	else if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9)
+		packet_R = 0xa;
+	else
+		packet_R = 8;
+
 	/* Video Code (CEA) */
-	packet_VIC = vic_table[vicMode][VIC];
+	packet_VIC = drm_match_cea_mode(mode);
 	/* Pixel Repetition 0 ... 9 (1-10) */
-	packet_PR = vic_table[vicMode][VIC_PR];
+	packet_PR = 0;
 
 	if (colorMode == PXL_RGB)
 		packet_Y = 0;
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.h
index 186f29e3dd42..b52fad0b7bb6 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_AVI.h
@@ -17,10 +17,10 @@
 #ifndef API_AVI_H_
 #define API_AVI_H_
 
-#include "vic_table.h"
 #include "API_General.h"
 
-CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_Set_AVI(state_struct *state,
+			       struct drm_display_mode *mode,
 			       VIC_PXL_ENCODING_FORMAT colorMode,
 			       BT_TYPE ITUver);
 
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_Audio.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_Audio.h
index dd5d487e4f20..02126f0d7ec2 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_Audio.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_Audio.h
@@ -18,7 +18,6 @@
 #define API_AUDIO_H_
 
 #include "API_General.h"
-#include "vic_table.h"
 /**
  * \addtogroup AUDIO_API
  * \{
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c
index bcd2a265abe5..220c39b0e55b 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.c
@@ -388,56 +388,8 @@ CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(state_struct *state,
 				(state, LinkeventId, HPDevents));
 }
 
-#define NUM_OF_SUPPORTED_PIXEL_FREQ 25
-
-u32 CDN_API_Get_PIXEL_FREQ_KHZ_ClosetVal(u32 val, CDN_PROTOCOL_TYPE protocol)
-{
-	u32 supportedVals[NUM_OF_SUPPORTED_PIXEL_FREQ];
-	int i;
-	int minI;
-
-	u32 minVal;
-
-	supportedVals[0] = 24719;
-	supportedVals[1] = 25000;
-	supportedVals[2] = 25175;
-	supportedVals[3] = 25200;
-	supportedVals[4] = 27000;
-	supportedVals[5] = 32358;
-	supportedVals[6] = 33750;
-	supportedVals[7] = 38250;
-	supportedVals[8] = 54000;
-	supportedVals[9] = 74250;
-	supportedVals[10] = 108000;
-	supportedVals[11] = 148500;
-	supportedVals[12] = 138750;
-	supportedVals[13] = 104750;
-	supportedVals[14] = 102500;
-	supportedVals[15] = 82000;
-	supportedVals[16] = 78500;
-	supportedVals[17] = 63500;
-	supportedVals[18] = 40000;
-	supportedVals[19] = 59340;
-	supportedVals[20] = 35000;
-	supportedVals[21] = 72000;
-	supportedVals[22] = 47000;
-	supportedVals[23] = 22250;
-	supportedVals[24] = 30750;
-
-	minVal = abs(val - supportedVals[0]);
-	minI = 0;
-	for (i = 1; i < NUM_OF_SUPPORTED_PIXEL_FREQ; i++) {
-		if (abs(val - supportedVals[i]) < minVal) {
-
-			minVal = abs(val - supportedVals[i]);
-			minI = i;
-		}
-	}
-
-	return supportedVals[minI];
-}
-
-CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state,
+				    struct drm_display_mode *mode,
 				    int bitsPerPixel,
 				    VIC_NUM_OF_LANES NumOfLanes,
 				    VIC_SYMBOL_RATE rate,
@@ -479,7 +431,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 		bitsPerPixelCalc = bitsPerPixel * 3;
 
 	/* KHz */
-	pixelClockFreq = vic_table[vicMode][PIXEL_FREQ_KHZ];
+	pixelClockFreq = mode->clock;
 
 	/* KHz */
 	min_link_rate = rate * 995;
@@ -508,21 +460,14 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 		val2 = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
 		val2_f = val2 / (NumOfLanes * min_link_rate * 8);
 		val2 /= NumOfLanes * min_link_rate * 8;
-
-		/*
-		pr_info("val=%d, val_f=%d, val2=%d, val2_f=%d\n", val, val_f,
-		       val2, val2_f);
-		*/
 	}
 
 	/* calculate the fixed valid symbols */
 	val = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
 	val /= NumOfLanes * rate * 8;
 
-	if (val > 64) {
-		printk("CDN_ERROR_NOT_SUPPORTED val: %d\n", val);
+	if (val > 64)
 		return CDN_ERROR_NOT_SUPPORTED;
-	}
 
 	DP_FRAMER_TU_Param = (TU_SIZE_reg << 8) + val + (1 << 15);
 
@@ -539,63 +484,55 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 	lineThresh += 2;
 
 	DP_FRAMER_SP_Param =
-	    (vic_table[vicMode][I_P] == INTERLACED ? 4 : 0) +
-	    (vic_table[vicMode][HSYNC_POL] == ACTIVE_LOW ? 2 : 0) +
-	    (vic_table[vicMode][VSYNC_POL] == ACTIVE_LOW ? 1 : 0);
+		((mode->flags & DRM_MODE_FLAG_INTERLACE) ? 4 : 0) +
+		((mode->flags & DRM_MODE_FLAG_NHSYNC) ? 2 : 0) +
+		((mode->flags & DRM_MODE_FLAG_NVSYNC) ? 1 : 0);
 	DP_FRONT_BACK_PORCH_Param =
-	    vic_table[vicMode][BACK_PORCH] +
-	    (vic_table[vicMode][FRONT_PORCH] << 16);
+		mode->htotal - mode->hsync_end +
+		((mode->hsync_start - mode->hdisplay) << 16);
+
+	DP_BYTE_COUNT_Param = mode->hdisplay * (bitsPerPixelCalc) / 8;
 
-	DP_BYTE_COUNT_Param =
-	    vic_table[vicMode][H_ACTIVE] * (bitsPerPixelCalc) / 8;
 	MSA_HORIZONTAL_0_Param =
-	    vic_table[vicMode][H_TOTAL] +
-	    ((vic_table[vicMode][HSYNC] +
-	      vic_table[vicMode][BACK_PORCH]) << 16);
+	    mode->htotal + ((mode->htotal - mode->hsync_start) << 16);
+
 	MSA_HORIZONTAL_1_Param =
-	    vic_table[vicMode][HSYNC] +
-	    ((vic_table[vicMode][HSYNC_POL] ==
-	      ACTIVE_LOW ? 0 : 1) << 15) + (vic_table[vicMode][H_ACTIVE] << 16);
+	    mode->hsync_end - mode->hsync_start +
+	    ((mode->flags & DRM_MODE_FLAG_NHSYNC ? 1 : 0) << 15) +
+	    (mode->hdisplay << 16);
 
 	MSA_VERTICAL_0_Param =
-	    (vic_table[vicMode][I_P] == INTERLACED ?
-	     ((vic_table[vicMode][V_TOTAL] /
-	       2)) : vic_table[vicMode][V_TOTAL]) +
-	    ((vic_table[vicMode][VSYNC] + vic_table[vicMode][SOF]) << 16);
+	    (mode->flags & DRM_MODE_FLAG_INTERLACE ?
+	     (mode->vtotal / 2) : mode->vtotal) +
+	    ((mode->vtotal - mode->vsync_start) << 16);
+
 	MSA_VERTICAL_1_Param =
-	    (vic_table[vicMode][VSYNC] +
-	     ((vic_table[vicMode][VSYNC_POL] ==
-	       ACTIVE_LOW ? 0 : 1) << 15)) + ((vic_table[vicMode][I_P] ==
-					       INTERLACED ?
-					       vic_table[vicMode][V_ACTIVE] /
-					       2 : vic_table[vicMode][V_ACTIVE])
-					      << 16);
-	DP_HORIZONTAL_ADDR_Param =
-	    ((vic_table[vicMode][H_TOTAL] -
-	      vic_table[vicMode][H_BLANK]) << 16) +
-	    (vic_table[vicMode][H_BLANK] - vic_table[vicMode][FRONT_PORCH] -
-	     vic_table[vicMode][BACK_PORCH]);
+	    (mode->vsync_end - mode->vsync_start +
+		 ((mode->flags & DRM_MODE_FLAG_NVSYNC ? 1 : 0) << 15)) +
+		((mode->flags & DRM_MODE_FLAG_INTERLACE ?
+		  mode->vdisplay / 2 : mode->vdisplay) << 16);
+
+	DP_HORIZONTAL_ADDR_Param = (mode->hdisplay << 16) + mode->hsync;
+
 	DP_VERTICAL_0_ADDR_Param =
-	    (vic_table[vicMode][I_P] ==
-	     INTERLACED ? (((vic_table[vicMode][V_TOTAL]) / 2)) :
-	     vic_table[vicMode][V_TOTAL]) - (vic_table[vicMode][VSYNC] +
-					     vic_table[vicMode][SOF] +
-					     vic_table[vicMode][TYPE_EOF]) +
-	    ((vic_table[vicMode][VSYNC] + vic_table[vicMode][SOF]) << 16);
+	    (mode->flags & DRM_MODE_FLAG_INTERLACE ?
+	     (mode->vtotal / 2) : mode->vtotal) -
+	    (mode->vtotal - mode->vdisplay) +
+	    ((mode->vtotal - mode->vsync_start) << 16);
+
 	DP_VERTICAL_1_ADDR_Param =
-	    (vic_table[vicMode][I_P] ==
-	     INTERLACED ? (((vic_table[vicMode][V_TOTAL]) / 2)) :
-	     vic_table[vicMode][V_TOTAL]);
+	    mode->flags & DRM_MODE_FLAG_INTERLACE ?
+	    (mode->vtotal / 2) : mode->vtotal;
 
-	if (vic_table[vicMode][I_P] == INTERLACED)
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
 		BND_HSYNC2VSYNC_Param = 0x3020;
 	else
 		BND_HSYNC2VSYNC_Param = 0x2000;
 
-	if (vic_table[vicMode][HSYNC_POL] == ACTIVE_LOW)
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 		HSYNC2VSYNC_POL_CTRL_Param |= F_HPOL(1);
 
-	if (vic_table[vicMode][VSYNC_POL] == ACTIVE_LOW)
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 		HSYNC2VSYNC_POL_CTRL_Param |= F_VPOL(1);
 
 	switch (bitsPerPixel) {
@@ -666,13 +603,14 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 
 	};
 
-	oddEvenV_Total = vic_table[vicMode][V_TOTAL] % 2;
+	oddEvenV_Total = mode->vtotal % 2;
 	oddEvenV_Total = 1 - oddEvenV_Total;
 	oddEvenV_Total = oddEvenV_Total << 8;
 	MSA_MISC_Param =
 	    ((tempForMisc * 2) + (32 * tempForMisc2) +
 	     ((pxlencformat == Y_ONLY ? 1 : 0) << 14) +
-	     ((oddEvenV_Total) * (vic_table[vicMode][I_P])));
+	     ((oddEvenV_Total) *
+	      (mode->flags & DRM_MODE_FLAG_INTERLACE ? 1 : 0)));
 
 	/* 420 has different parameters, enable VSS SDP */
 	if (pxlencformat == YCBCR_4_2_0)
@@ -777,8 +715,9 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 		ret =
 		    CDN_API_DPTX_Write_Field(state, BASE_DPTX_STREAM, DP_VB_ID,
 					     2, 1,
-					     ((vic_table[vicMode][I_P] ==
-					       INTERLACED ? 1 : 0) << 2));
+					     ((mode->flags &
+					       DRM_MODE_FLAG_INTERLACE ? 1 : 0)
+					      << 2));
 		break;
 	case 17:
 		ret =
@@ -811,7 +750,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 }
 
 CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
-					     VIC_MODES vicMode,
+					     struct drm_display_mode *mode,
 					     int bitsPerPixel,
 					     VIC_NUM_OF_LANES NumOfLanes,
 					     VIC_SYMBOL_RATE rate,
@@ -821,7 +760,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
 					     BT_TYPE bt_type, int TU)
 {
 	internal_block_function(CDN_API_DPTX_Set_VIC
-				(state, vicMode, bitsPerPixel, NumOfLanes, rate,
+				(state, mode, bitsPerPixel, NumOfLanes, rate,
 				 pxlencformat, steroVidAttr, bt_type, TU));
 }
 
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h
index f6acc04a6619..b4c371078300 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_DPTX.h
@@ -18,7 +18,6 @@
 #define _API_DPTX_H_
 
 #include "API_General.h"
-#include "vic_table.h"
 #include "API_AFE.h"
 
 #define MAX_NUM_OF_EVENTS 4
@@ -301,7 +300,8 @@ CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(state_struct *state,
 /**
  * \brief set vic mode according to vic table, the input are video parameters
  */
-CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state,
+				    struct drm_display_mode *mode,
 				    int bitsPerPixel,
 				    VIC_NUM_OF_LANES NumOfLanes,
 				    VIC_SYMBOL_RATE rate,
@@ -313,7 +313,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
  * blocking version of #CDN_API_DPTX_Set_VIC
  */
 CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
-					     VIC_MODES vicMode,
+					     struct drm_display_mode *mode,
 					     int bitsPerPixel,
 					     VIC_NUM_OF_LANES NumOfLanes,
 					     VIC_SYMBOL_RATE rate,
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c
index 8baa4189e126..c51a41c20c6b 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.c
@@ -241,62 +241,90 @@ CDN_API_STATUS CDN_API_HDMITX_Init_blocking(state_struct *state)
 }
 
 CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
-					      VIC_MODES vicMode, int bpp,
+					      struct drm_display_mode *mode,
+					      int bpp,
 					      VIC_PXL_ENCODING_FORMAT format)
 {
 	CDN_API_STATUS ret;
 	GENERAL_Read_Register_response resp;
-	u32 vsync_lines = vic_table[vicMode][VSYNC];
-	u32 eof_lines = vic_table[vicMode][TYPE_EOF];
-	u32 sof_lines = vic_table[vicMode][SOF];
-	u32 hblank = vic_table[vicMode][H_BLANK];
-	u32 hactive = vic_table[vicMode][H_TOTAL] - hblank;
-	u32 vblank = vsync_lines + eof_lines + sof_lines;
-	u32 vactive = vic_table[vicMode][V_TOTAL] - vblank;
-	u32 hfront = vic_table[vicMode][FRONT_PORCH];
-	u32 hback = vic_table[vicMode][BACK_PORCH];
+	u32 vsync_lines = mode->vsync_end - mode->vsync_start;
+	u32 eof_lines = mode->vsync_start - mode->vdisplay;
+	u32 sof_lines = mode->vtotal - mode->vsync_end;
+	u32 hblank = mode->htotal - mode->hdisplay;
+	u32 hactive = mode->hdisplay;
+	u32 vblank = mode->vtotal - mode->vdisplay;
+	u32 vactive = mode->vdisplay;
+	u32 hfront = mode->hsync_start - mode->hdisplay;
+	u32 hback = mode->htotal - mode->hsync_end;
 	u32 vfront = eof_lines;
 	u32 hsync = hblank - hfront - hback;
 	u32 vsync = vsync_lines;
 	u32 vback = sof_lines;
-	u32 v_h_polarity = ((vic_table[vicMode][HSYNC_POL] == ACTIVE_LOW) ? F_HPOL(0) : F_HPOL(1)) + ((vic_table[vicMode][VSYNC_POL] == ACTIVE_LOW) ? F_VPOL(0) : F_VPOL(1));	/* bit invert ??? Sandor */
+	u32 v_h_polarity = ((mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : 1) +
+			   ((mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : 2);
 
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (SCHEDULER_H_SIZE << 2),
-						    (hactive << 16) + hblank);
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (SCHEDULER_V_SIZE << 2),
-						    (vactive << 16) + vblank);
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (HDTX_SIGNAL_FRONT_WIDTH <<
-						     2),
-						    (vfront << 16) + hfront);
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (HDTX_SIGNAL_SYNC_WIDTH <<
-						     2), (vsync << 16) + hsync);
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (HDTX_SIGNAL_BACK_WIDTH <<
-						     2), (vback << 16) + hback);
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_VIF +
-						    (HSYNC2VSYNC_POL_CTRL << 2),
-						    v_h_polarity);
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (SCHEDULER_H_SIZE << 2),
+						      (hactive << 16) + hblank);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (SCHEDULER_V_SIZE << 2),
+						      (vactive << 16) + vblank);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_SIGNAL_FRONT_WIDTH
+						       << 2),
+						      (vfront << 16) + hfront);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_SIGNAL_SYNC_WIDTH <<
+						       2),
+						      (vsync << 16) + hsync);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_SIGNAL_BACK_WIDTH <<
+						       2),
+						      (vback << 16) + hback);
+	if (ret != CDN_OK)
+		return ret;
+
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_VIF +
+						      (HSYNC2VSYNC_POL_CTRL <<
+						       2),
+						      v_h_polarity);
+	if (ret != CDN_OK)
+		return ret;
 
 	/* Reset Data Enable */
-	CDN_API_General_Read_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-					       (HDTX_CONTROLLER << 2), &resp);
+	ret = CDN_API_General_Read_Register_blocking(state,
+						     ADDR_SOURCE_MHL_HD +
+						     (HDTX_CONTROLLER << 2),
+						     &resp);
+	if (ret != CDN_OK)
+		return ret;
 
 	/* reset data enable */
 	resp.val = resp.val & (~(F_DATA_EN(1)));
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (HDTX_CONTROLLER << 2),
-						    resp.val);
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_CONTROLLER << 2),
+						      resp.val);
+	if (ret != CDN_OK)
+		return ret;
 
 	/* set bpp */
 	resp.val = resp.val & (~(F_VIF_DATA_WIDTH(3)));
@@ -342,17 +370,22 @@ CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
 		break;
 	}
 
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (HDTX_CONTROLLER << 2),
-						    resp.val);
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_CONTROLLER << 2),
+						      resp.val);
+	if (ret != CDN_OK)
+		return ret;
 
 	/* set data enable */
 	resp.val = resp.val | (F_DATA_EN(1));
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
-						    (HDTX_CONTROLLER << 2),
-						    resp.val);
+	ret = CDN_API_General_Write_Register_blocking(state,
+						      ADDR_SOURCE_MHL_HD +
+						      (HDTX_CONTROLLER << 2),
+						      resp.val);
+	if (ret != CDN_OK)
+		return ret;
+
 	return ret;
 }
 
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.h
index 12063cf9ef3c..c06c04bb5eca 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/API_HDMITX.h
@@ -19,7 +19,6 @@
 
 #include "API_General.h"
 #include "hdmi.h"
-#include "vic_table.h"
 
 /**
  * \addtogroup HDMI_TX_API
@@ -117,7 +116,8 @@ CDN_API_STATUS CDN_API_HDMITX_Init_blocking(state_struct *state);
  * \returns status
  */
 CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
-					      VIC_MODES vicMode, int bpp,
+					      struct drm_display_mode *mode,
+					      int bpp,
 					      VIC_PXL_ENCODING_FORMAT format);
 
 /**
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/Makefile b/drivers/gpu/drm/imx/hdp/cdn_hdp/Makefile
index 98301bcc3fb0..d6cfcba40120 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/Makefile
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/Makefile
@@ -8,5 +8,4 @@ obj-$(CONFIG_DRM_IMX_HDP) += \
 	API_HDMI_Audio.o \
 	API_Infoframe.o \
 	API_DPTX.o \
-	util.o \
-	vic_table.o
+	util.o
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/all.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/all.h
index c6794f8ff97b..c790d8fea347 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/all.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/all.h
@@ -28,5 +28,4 @@
 #include "source_car.h"
 #include "source_phy.h"
 #include "source_vif.h"
-#include "vic_table.h"
 #include "util.h"
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h
index 40856635e842..3072cc9f8b59 100644
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h
+++ b/drivers/gpu/drm/imx/hdp/cdn_hdp/util.h
@@ -19,6 +19,8 @@
 
 #include <linux/delay.h>
 #include <linux/mutex.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_edid.h>
 
 /**
  * \addtogroup GENERAL_API
@@ -76,6 +78,49 @@ typedef enum {
 	CDN_BUS_TYPE_SAPB = 1
 } CDN_BUS_TYPE;
 
+typedef enum {
+	NUM_OF_LANES_1 = 1,
+	NUM_OF_LANES_2 = 2,
+	NUM_OF_LANES_4 = 4,
+} VIC_NUM_OF_LANES;
+
+typedef enum {
+	RATE_1_6 = 162,
+	RATE_2_1 = 216,
+	RATE_2_4 = 243,
+	RATE_2_7 = 270,
+	RATE_3_2 = 324,
+	RATE_4_3 = 432,
+	RATE_5_4 = 540,
+	RATE_8_1 = 810,
+} VIC_SYMBOL_RATE;
+
+typedef enum {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+} VIC_PXL_ENCODING_FORMAT;
+
+typedef enum {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+} VIC_COLOR_DEPTH;
+
+typedef enum {
+	STEREO_VIDEO_LEFT = 0x0,
+	STEREO_VIDEO_RIGHT = 0x1,
+} STEREO_VIDEO_ATTR;
+
+typedef enum {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+} BT_TYPE;
+
 typedef struct {
     /** apb write status */
 	enum tx_status_enum {
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.c b/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.c
deleted file mode 100644
index ce520cd9ab0d..000000000000
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
- * All rights reserved worldwide.
- *
- * Copyright 2017-2018 NXP
- *
- * SPDX-License-Identifier: BSD-3-Clause
- *
- ******************************************************************************
- *
- * This file was auto-generated. Do not edit it manually.
- *
- ******************************************************************************
- *
- * vic_table.c
- *
- ******************************************************************************
- */
-#include "vic_table.h"
-
-const unsigned int vic_table[VIC_MODE_COUNT][27] = {
-	{858, 720, 138, 62, 16, 60, 525, 480, 45, 6, 9, 30, 59, 27000,
-	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 3,
-	 8, 0},
-	{1650, 1280, 370, 40, 110, 220, 750, 720, 30, 5, 5, 20, 60, 74250,
-	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535, 65535,
-	 4, 8, 0},
-	{2200, 1920, 280, 44, 88, 148, 1125, 1080, 45, 5, 4,
-	 36, 60, 148500, PROGRESSIVE, ACTIVE_HIGH,
-	 ACTIVE_HIGH, 1, 65535, 1, 46, 65535, 65535, 16, 8, 0},
-	{4400, 3840, 560, 88, 176, 296, 2250, 2160, 90, 10, 8, 72, 60,
-	 594000, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
-	 285, 97, 8, 0},
-	{4400, 3840, 560, 88, 176, 296, 2250, 2160, 90, 10, 8, 72, 30,
-	 297000, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
-	 285, 95, 8, 0},
-};
diff --git a/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h b/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h
deleted file mode 100644
index 9adbf2756e4e..000000000000
--- a/drivers/gpu/drm/imx/hdp/cdn_hdp/vic_table.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
- * All rights reserved worldwide.
- *
- * Copyright 2017-2018 NXP
- *
- * SPDX-License-Identifier: BSD-3-Clause
- *
- ******************************************************************************
- *
- * This file was auto-generated. Do not edit it manually.
- *
- ******************************************************************************
- *
- * vic_table.h
- *
- ******************************************************************************
- */
-
-#ifndef VIC_TABLE_H_
-#define VIC_TABLE_H_
-
-#define PROGRESSIVE 0
-#define INTERLACED 1
-
-#define ACTIVE_LOW 0
-#define ACTIVE_HIGH 1
-
-typedef enum {
-	H_TOTAL,
-	H_ACTIVE,
-	H_BLANK,
-	HSYNC,
-	FRONT_PORCH,
-	BACK_PORCH,
-	/* H_FREQ_KHZ, */
-	V_TOTAL,
-	V_ACTIVE,
-	V_BLANK,
-	VSYNC,
-	TYPE_EOF,
-	SOF,
-	V_FREQ_HZ,
-	PIXEL_FREQ_KHZ,
-	I_P,
-	HSYNC_POL,
-	VSYNC_POL,
-	START_OF_F0,
-	START_OF_F1,
-	VSYNC_START_INTERLACED_F0,
-	VSYNC_END_INTERLACED_F0,
-	VSYNC_START_INTERLACED_F1,
-	VSYNC_END_INTERLACED_F1,
-	VIC,
-	VIC_R3_0,
-	VIC_PR,
-} MSA_PARAM;
-
-typedef enum {
-	NUM_OF_LANES_1 = 1,
-	NUM_OF_LANES_2 = 2,
-	NUM_OF_LANES_4 = 4,
-} VIC_NUM_OF_LANES;
-
-typedef enum {
-	RATE_1_6 = 162,
-	RATE_2_1 = 216,
-	RATE_2_4 = 243,
-	RATE_2_7 = 270,
-	RATE_3_2 = 324,
-	RATE_4_3 = 432,
-	RATE_5_4 = 540,
-	RATE_8_1 = 810,
-} VIC_SYMBOL_RATE;
-
-typedef enum {
-	PXL_RGB = 0x1,
-	YCBCR_4_4_4 = 0x2,
-	YCBCR_4_2_2 = 0x4,
-	YCBCR_4_2_0 = 0x8,
-	Y_ONLY = 0x10,
-} VIC_PXL_ENCODING_FORMAT;
-
-typedef enum {
-	BCS_6 = 0x1,
-	BCS_8 = 0x2,
-	BCS_10 = 0x4,
-	BCS_12 = 0x8,
-	BCS_16 = 0x10,
-} VIC_COLOR_DEPTH;
-
-typedef enum {
-	STEREO_VIDEO_LEFT = 0x0,
-	STEREO_VIDEO_RIGHT = 0x1,
-} STEREO_VIDEO_ATTR;
-
-typedef enum {
-	BT_601 = 0x0,
-	BT_709 = 0x1,
-} BT_TYPE;
-
-typedef enum {
-	VIC_MODE_3_59_94Hz,
-	VIC_MODE_4_60Hz,
-	VIC_MODE_16_60Hz,
-	VIC_MODE_97_60Hz,
-	VIC_MODE_95_30Hz,
-	VIC_MODE_COUNT
-} VIC_MODES;
-
-extern const unsigned int vic_table[VIC_MODE_COUNT][27];
-
-#endif
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.c b/drivers/gpu/drm/imx/hdp/imx-dp.c
index f0ba55a2a39b..330f6af2cfb1 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.c
@@ -66,8 +66,12 @@ static const struct of_device_id scfg_device_ids[] = {
 	{}
 };
 
-void dp_phy_init(state_struct *state, int num_lanes, int max_link_rate, int tmp)
+int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format,
+		int color_depth)
 {
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
+	int max_link_rate = hdp->link_rate;
+	int num_lanes = 4;
 	int ret;
 	struct device_node *scfg_node;
 	void __iomem *scfg_base = NULL;
@@ -94,10 +98,18 @@ void dp_phy_init(state_struct *state, int num_lanes, int max_link_rate, int tmp)
 
 	/* Video off */
 	ret = CDN_API_DPTX_SetVideo_blocking(state, 0);
+
+	return true;
 }
 
-/* Max Link Rate: 06h (1.62Gbps), 0Ah (2.7Gbps), 14h (5.4Gbps), 1Eh (8.1Gbps)--N/A */
-void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int max_link_rate)
+/* Max Link Rate: 06h (1.62Gbps), 0Ah (2.7Gbps), 14h (5.4Gbps),
+ * 1Eh (8.1Gbps)--N/A
+ */
+void dp_mode_set(state_struct *state,
+			struct drm_display_mode *mode,
+			int format,
+			int color_depth,
+			int max_link_rate)
 {
 	int ret;
 
@@ -207,7 +219,7 @@ void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int
 	}
 
 	ret = CDN_API_DPTX_Set_VIC_blocking(state,
-		vic,
+		mode,
 		bits_per_subpixel,
 		num_lanes,
 		sym_rate,
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.h b/drivers/gpu/drm/imx/hdp/imx-dp.h
index 651d541685f7..f8265a85e9fa 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.h
@@ -9,8 +9,14 @@
 
 void dp_fw_load(state_struct *state);
 int dp_fw_init(state_struct *state, u32 rate);
-void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int max_link_rate);
-void dp_phy_init(state_struct *state, int num_lanes, int max_link_rate, int tmp);
+void dp_mode_set(state_struct *state,
+		 struct drm_display_mode *mode,
+		 int format, int color_depth,
+		 int max_link_rate);
+int dp_phy_init(state_struct *state,
+		struct drm_display_mode *mode,
+		int format,
+		int color_depth);
 int dp_get_edid_block(void *data, u8 *buf, u32 block, size_t len);
 void dp_get_hpd_state(state_struct *state, u8 *hpd);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.c b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
index a95f54fc021c..6cd82965dd8b 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
@@ -50,12 +50,14 @@ int hdmi_fw_init(state_struct *state, u32 core_rate)
 	return 0;
 }
 
-void hdmi_phy_init(state_struct *state, int vic, int format, int color_depth)
+int hdmi_phy_init(state_struct *state, struct drm_display_mode *mode,
+		  int format, int color_depth)
 {
 	int ret;
 
 	/* Configure PHY */
-	character_freq_khz = phy_cfg_hdp_ss28fdsoi(state, 4, vic, color_depth, format);
+	character_freq_khz = phy_cfg_hdp_ss28fdsoi(state, 4, mode,
+						   color_depth, format);
 
 #ifdef arch_imx
 	hdp_phy_reset(1);
@@ -68,9 +70,12 @@ void hdmi_phy_init(state_struct *state, int vic, int format, int color_depth)
 		F_SOURCE_PHY_LANE0_SWAP(3) | F_SOURCE_PHY_LANE1_SWAP(0) |
 		F_SOURCE_PHY_LANE2_SWAP(1) | F_SOURCE_PHY_LANE3_SWAP(2) |
 		F_SOURCE_PHY_COMB_BYPASS(0) | F_SOURCE_PHY_20_10(1));
+
+	return true;
 }
 
-void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, int temp)
+void hdmi_mode_set(state_struct *state, struct drm_display_mode *mode,
+		   int format, int color_depth, int temp)
 {
 	int ret;
 	GENERAL_Read_Register_response regresp;
@@ -80,7 +85,7 @@ void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, in
 	/* Mode = 0 - DVI, 1 - HDMI1.4, 2 HDMI 2.0 */
 	HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE ptype = 1;
 
-	if (vic == VIC_MODE_97_60Hz)
+	if (drm_match_cea_mode(mode) == VIC_MODE_97_60Hz)
 		ptype = 2;
 
 	ret = CDN_API_HDMITX_Init_blocking(state);
@@ -88,9 +93,9 @@ void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, in
 	/* Set HDMI TX Mode */
 	ret = CDN_API_HDMITX_Set_Mode_blocking(state, ptype, character_freq_khz);
 
-	ret = CDN_API_Set_AVI(state, vic, format, bw_type);
+	ret = CDN_API_Set_AVI(state, mode, format, bw_type);
 
-	ret =  CDN_API_HDMITX_SetVic_blocking(state, vic, color_depth, format);
+	ret =  CDN_API_HDMITX_SetVic_blocking(state, mode, color_depth, format);
 
 	/* adjust the vsync/hsync polarity */
 	CDN_API_General_Read_Register_blocking(
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.h b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
index 322d6b70befd..ab938a4f4693 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
@@ -8,8 +8,10 @@
 #define _IMX_HDMI_H_
 void hdmi_fw_load(state_struct *state);
 int hdmi_fw_init(state_struct *state, u32 rate);
-void hdmi_phy_init(state_struct *state, int vic, int format, int color_depth);
-void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, int max_link);
+int hdmi_phy_init(state_struct *state, struct drm_display_mode *mode,
+		  int format, int color_depth);
+void hdmi_mode_set(state_struct *state, struct drm_display_mode *mode,
+		   int format, int color_depth, int temp);
 int hdmi_get_edid_block(void *data, u8 *buf, u32 block, size_t len);
 void hdmi_get_hpd_state(state_struct *state, u8 *hpd);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index bc34d563379f..87bfe196a378 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -20,7 +20,7 @@
 
 struct drm_display_mode *g_mode;
 
-static const struct drm_display_mode edid_cea_modes[] = {
+static struct drm_display_mode edid_cea_modes[] = {
 	/* 3 - 720x480@60Hz */
 	{ DRM_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
 		   798, 858, 0, 480, 489, 495, 525, 0,
@@ -444,28 +444,8 @@ static int imx_hdp_deinit(struct imx_hdp *hdp)
 	return ret;
 }
 
-static int imx_get_vic_index(struct drm_display_mode *mode)
-{
-	int i;
-
-	for (i = 0; i < VIC_MODE_COUNT; i++) {
-		if (mode->hdisplay == vic_table[i][H_ACTIVE] &&
-			mode->vdisplay == vic_table[i][V_ACTIVE] &&
-			mode->clock == vic_table[i][PIXEL_FREQ_KHZ]) {
-				printk("VIC_MODE %d: hdisplay: %d, vdisplay: %d, clock: %d\n",
-					i, mode->hdisplay, mode->vdisplay, mode->clock);
-				return i;
-		}
-	}
-	/* Default 1080p60 */
-	printk(KERN_INFO "default vic 2\n");
-	return 2;
-}
-
 static void imx_hdp_mode_setup(struct imx_hdp *hdp, struct drm_display_mode *mode)
 {
-	int dp_vic;
-
 	dp_pixel_clock_set_rate(hdp);
 	dp_pixel_clock_enable(hdp);
 
@@ -473,9 +453,11 @@ static void imx_hdp_mode_setup(struct imx_hdp *hdp, struct drm_display_mode *mod
 	imx_hdp_plmux_config(hdp, mode);
 #endif
 
-	dp_vic = imx_get_vic_index(mode);
+	imx_hdp_call(hdp, mode_set, &hdp->state, mode,
+		     hdp->format, hdp->bpc, hdp->link_rate);
 
-	imx_hdp_call(hdp, mode_set, &hdp->state, dp_vic, 1, 8, hdp->link_rate);
+	/* Get vic of CEA-861 */
+	hdp->vic = drm_match_cea_mode(mode);
 }
 
 static int imx_hdp_cable_plugin(struct imx_hdp *hdp)
@@ -957,6 +939,38 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	hdp->is_hdmi = devtype->is_hdmi;
 	hdp->ops = devtype->ops;
 	hdp->rw = devtype->rw;
+	hdp->bpc = 8;
+	hdp->format = PXL_RGB;
+
+	imx_hdp_state_init(hdp);
+
+	hdp->link_rate = AFE_LINK_RATE_5_4;
+
+	hdp->dual_mode = false;
+
+	dp_clock_init(hdp);
+
+	hdp_ipg_clock_set_rate(hdp);
+
+	dp_ipg_clock_enable(hdp);
+
+	imx_hdp_call(hdp, fw_load, &hdp->state);
+	core_rate = clk_get_rate(hdp->clks.clk_core);
+
+	ret = imx_hdp_call(hdp, fw_init, &hdp->state, core_rate);
+	if (ret < 0) {
+		DRM_ERROR("Failed to initialise HDP firmware\n");
+		return ret;
+	}
+
+	/* Pixel Format - 1 RGB, 2 YCbCr 444, 3 YCbCr 420 */
+	/* bpp (bits per subpixel) - 8 24bpp, 10 30bpp, 12 36bpp, 16 48bpp */
+	ret = imx_hdp_call(hdp, phy_init, &hdp->state, &edid_cea_modes[2],
+			   hdp->format, hdp->bpc);
+	if (ret < 0) {
+		DRM_ERROR("Failed to initialise HDP PHY\n");
+		return ret;
+	}
 
 	/* encoder */
 	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);
@@ -997,56 +1011,6 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	dev_set_drvdata(dev, hdp);
 
-	imx_hdp_state_init(hdp);
-
-#ifdef arch_imx
-	sciErr = sc_ipc_getMuID(&hdp->mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		pr_err("Cannot obtain MU ID\n");
-		return -EINVAL;
-	}
-
-	sciErr = sc_ipc_open(&hdp->ipcHndl, hdp->mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
-		return -EINVAL;
-	}
-#endif
-
-	hdp->link_rate = AFE_LINK_RATE_5_4;
-
-	hdp->dual_mode = false;
-
-#ifdef arch_imx
-	dp_pixel_link_config(hdp);
-#endif
-	dp_clock_init(hdp);
-
-	hdp_ipg_clock_set_rate(hdp);
-
-	dp_ipg_clock_enable(hdp);
-
-	/* Pixel Format - 1 RGB, 2 YCbCr 444, 3 YCbCr 420 */
-	/* bpp (bits per subpixel) - 8 24bpp, 10 30bpp, 12 36bpp, 16 48bpp */
-#ifdef arch_imx
-	hdp_phy_reset(0);
-#endif
-
-	imx_hdp_call(hdp, fw_load, &hdp->state);
-	core_rate = clk_get_rate(hdp->clks.clk_core);
-
-	ret = imx_hdp_call(hdp, fw_init, &hdp->state, core_rate);
-	if (ret < 0) {
-		DRM_ERROR("Failed to initialise HDP firmware\n");
-		return ret;
-	}
-
-	if (hdp->is_hdmi == true)
-		/* default set hdmi to 1080p60 mode */
-		imx_hdp_call(hdp, phy_init, &hdp->state, 2, 1, 8);
-	else
-		imx_hdp_call(hdp, phy_init, &hdp->state, 4, hdp->link_rate, 0);
-
 #ifdef hdp_irq
 	ret = devm_request_threaded_irq(dev, irq,
 					NULL, imx_hdp_irq_handler,
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index c297aa649f3d..2d00d0eba73f 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -46,6 +46,9 @@
 #define CSR_HDP_TX_CTRL_CTRL0		0x08
 #define CSR_HDP_TX_CTRL_CTRL1		0x0c
 
+#define VIC_MODE_96_50Hz 96
+#define VIC_MODE_97_60Hz 97
+
 /**
  * imx_hdp_call - Calls a struct imx hdp_operations operation on
  *	an entity
@@ -62,11 +65,16 @@
 	(!(hdp) ? -ENODEV : (((hdp)->ops && (hdp)->ops->operation) ?	\
 	 (hdp)->ops->operation(args) : -ENOIOCTLCMD))
 
+#define state_to_imx_hdp(env) \
+	container_of(env, struct imx_hdp, state)
+
 struct hdp_ops {
 	void (*fw_load)(state_struct *state);
 	int (*fw_init)(state_struct *state, u32 rate);
-	void (*phy_init)(state_struct *state, int vic, int format, int color_depth);
-	void (*mode_set)(state_struct *state, int vic, int format, int color_depth, int max_link);
+	int (*phy_init)(state_struct *state, struct drm_display_mode *mode,
+			int format, int color_depth);
+	void (*mode_set)(state_struct *state, struct drm_display_mode *mode,
+			 int format, int color_depth, int max_link);
 	int (*get_edid_block)(void *data, u8 *buf, u32 block, size_t len);
 	void (*get_hpd_state)(state_struct *state, u8 *hpd);
 };
@@ -177,7 +185,10 @@ struct imx_hdp {
 	struct hdp_rw_func *rw;
 	struct hdp_clks clks;
 	state_struct state;
+	int vic;
 
+	int bpc;
+	VIC_PXL_ENCODING_FORMAT format;
 };
 
 int imx_hdpaux_init(struct device *dev,	struct imx_hdp *dp);
-- 
2.17.1


From 54b9d454aecd250d319a237d739813b5507e5dc0 Mon Sep 17 00:00:00 2001
From: Po Liu <Po.Liu@nxp.com>
Date: Thu, 27 Dec 2018 13:19:23 +0800
Subject: [PATCH 428/706] tsn: checkpatch fix

Signed-off-by: Po Liu <Po.Liu@nxp.com>
(cherry picked from commit fcb22b2a159c8c361ba7fc8a3bc49308ae534de3)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 include/net/tsn.h        |  49 +-
 include/uapi/linux/tsn.h | 250 +++++-----
 net/tsn/Kconfig          |   2 +-
 net/tsn/genl_tsn.c       | 973 ++++++++++++++++++++++-----------------
 4 files changed, 717 insertions(+), 557 deletions(-)

diff --git a/include/net/tsn.h b/include/net/tsn.h
index 50a032b1f48f..18c4f440fb25 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -14,36 +14,36 @@ struct tsn_ops {
 	int (*qbv_set)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
 	int (*qbv_get)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
 	int (*qbv_get_status)(struct net_device *ndev,
-							struct tsn_qbv_status *qbvstat);
+				struct tsn_qbv_status *qbvstat);
 	int (*cb_streamid_set)(struct net_device *ndev, u32 index,
-							bool enable, struct tsn_cb_streamid *sid);
+				bool enable, struct tsn_cb_streamid *sid);
 	int (*cb_streamid_get)(struct net_device *ndev, u32 index,
-							struct tsn_cb_streamid *sid);
+				struct tsn_cb_streamid *sid);
 	int (*cb_streamid_counters_get)(struct net_device *ndev, u32 index,
-							struct tsn_cb_streamid_counters *sidcounter);
+				struct tsn_cb_streamid_counters *sidcounter);
 	int (*qci_get_maxcap)(struct net_device *ndev,
-							struct tsn_qci_psfp_stream_param *qcicapa);
+				struct tsn_qci_psfp_stream_param *qcicapa);
 	int (*qci_sfi_set)(struct net_device *ndev, u32 index, bool enable,
-							struct tsn_qci_psfp_sfi_conf *sficonf);
+				struct tsn_qci_psfp_sfi_conf *sficonf);
 	/* return: 0 stream filter instance not valid
 	 * 1 stream filter instance valid
 	 * -1 error happened
 	 */
 	int (*qci_sfi_get)(struct net_device *ndev, u32 index,
-						struct tsn_qci_psfp_sfi_conf *sficonf);
+				struct tsn_qci_psfp_sfi_conf *sficonf);
 	int (*qci_sfi_counters_get)(struct net_device *ndev, u32 index,
-								struct tsn_qci_psfp_sfi_counters *sficounter);
+				struct tsn_qci_psfp_sfi_counters *sficounter);
 	int (*qci_sgi_set)(struct net_device *ndev, u32 index,
-							struct tsn_qci_psfp_sgi_conf *sgiconf);
+				struct tsn_qci_psfp_sgi_conf *sgiconf);
 	int (*qci_sgi_get)(struct net_device *ndev, u32 index,
-							struct tsn_qci_psfp_sgi_conf *sgiconf);
+				struct tsn_qci_psfp_sgi_conf *sgiconf);
 	int (*qci_sgi_status_get)(struct net_device *ndev, u16 index,
-							struct tsn_psfp_sgi_status *sgistat);
+				struct tsn_psfp_sgi_status *sgistat);
 	int (*qci_fmi_set)(struct net_device *ndev, u32 index, bool enable,
-							struct tsn_qci_psfp_fmi *fmi);
+				struct tsn_qci_psfp_fmi *fmi);
 	int (*qci_fmi_get)(struct net_device *ndev, u32 index,
-							struct tsn_qci_psfp_fmi *fmi,
-							struct tsn_qci_psfp_fmi_counters *counters);
+				struct tsn_qci_psfp_fmi *fmi,
+				struct tsn_qci_psfp_fmi_counters *counters);
 	int (*cbs_set)(struct net_device *ndev, u8 tc, u8 bw);
 	int (*cbs_get)(struct net_device *ndev, u8 tc);
 	/* To set a 8 bits vector shows 8 traffic classes
@@ -52,15 +52,15 @@ struct tsn_ops {
 	int (*qbu_set)(struct net_device *ndev, u8 ptvector);
 	/* To get port preemtion status */
 	int (*qbu_get)(struct net_device *ndev,
-						struct tsn_preempt_status *preemptstat);
-	int (*tsd_set)(struct net_device *, struct tsn_tsd *);
-	int (*tsd_get)(struct net_device *, struct tsn_tsd_status *);
-	int (*ct_set)(struct net_device *, u8 cut_thru);
-	int (*cbgen_set)(struct net_device *, u32 index,
-			 struct tsn_seq_gen_conf *);
-	int (*cbrec_set)(struct net_device *, u32 index,
-			 struct tsn_seq_rec_conf *);
-	int (*pcpmap_set)(struct net_device *, bool enable);
+				struct tsn_preempt_status *preemptstat);
+	int (*tsd_set)(struct net_device *ndev, struct tsn_tsd *tsd);
+	int (*tsd_get)(struct net_device *ndev, struct tsn_tsd_status *stats);
+	int (*ct_set)(struct net_device *ndev, u8 cut_thru);
+	int (*cbgen_set)(struct net_device *ndev, u32 index,
+			 struct tsn_seq_gen_conf *seqgen);
+	int (*cbrec_set)(struct net_device *ndev, u32 index,
+			 struct tsn_seq_rec_conf *seqrec);
+	int (*pcpmap_set)(struct net_device *ndev, bool enable);
 };
 
 enum ethdev_type {
@@ -78,6 +78,7 @@ struct tsn_port {
 	enum ethdev_type type;
 };
 
-int tsn_port_register(struct net_device *netdev, struct tsn_ops *tsnops, u16 groupid);
+int tsn_port_register(struct net_device *netdev,
+				struct tsn_ops *tsnops, u16 groupid);
 void tsn_port_unregister(struct net_device *netdev);
 #endif
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
index a7b638654f64..f23bd62aa29c 100644
--- a/include/uapi/linux/tsn.h
+++ b/include/uapi/linux/tsn.h
@@ -323,7 +323,7 @@ struct tsn_preempt_status {
 	 * the framePreemptionAdminStatus parameter and PreemptionPriority
 	 * for the traffic class. Bit-7 is the highest priority traffic class
 	 * and the bit-0 is the lowest priority traffic class.
-	 * The bit is express (0) and is preemptable (1).
+	 * The bit is express (0) and is preemptible (1).
 	 */
 	uint8_t admin_state;
 	/* The value of the holdAdvance parameter for the port in nanoseconds.
@@ -364,7 +364,7 @@ enum tsn_tx_mode  {
 };
 
 #define QUEUE_TX_MASK ((1 << TX_MODE_STRICT) | (1 << TX_MODE_CBS) \
-						| (1 << TX_MODE_ETS) | (1 << TX_MODE_VENDOR_DEFINE))
+			| (1 << TX_MODE_ETS) | (1 << TX_MODE_VENDOR_DEFINE))
 
 struct cbs_status {
 	uint8_t delta_bw; /* percentage, 0~100 */
@@ -417,30 +417,32 @@ enum tsn_cb_streamid_type {
 	STREAMID_IP,
 };
 
-/* When instantiating an instance of the Null Stream identification function 8021CB(6.4)
- * for a particular input Stream, the managed objects in the following subsections
- * serve as the tsnStreamIdParameters managed object 8021CB claus(9.1.1.7).
+/* When instantiating an instance of the Null Stream identification function
+ * 8021CB(6.4) for a particular input Stream, the managed objects in the
+ * following subsections serve as the tsnStreamIdParameters managed object
+ * 8021CB claus(9.1.1.7).
  */
 struct tsn_cb_null_streamid {
-
-	/* tsnCpeNullDownDestMac. Specifies the destination_address that identifies
-	 * a packet in an Enhanced Internal Sublayer Service (EISS) indication primitive,
-	 * to the Null Stream identification function.
+	/* tsnCpeNullDownDestMac. Specifies the destination_address that
+	 * identifies a packet in an Enhanced Internal Sublayer Service (EISS)
+	 * indication primitive, to the Null Stream identification function.
 	 */
 	uint64_t dmac;
 
 	/* tsnCpeNullDownTagged. It can take the following values:
-	 * 1 tagged: A frame must have a VLAN tag to be recognized as belonging to the Stream.
-	 * 2 priority: A frame must be untagged, or have a VLAN tag with a VLAN ID = 0 to be
-	 * recognized as belonging to the Stream.
-	 * 3 all: A frame is recognized as belonging to the Stream whether tagged or not.
+	 * 1 tagged: A frame must have a VLAN tag to be recognized as belonging
+	 * to the Stream.
+	 * 2 priority: A frame must be untagged, or have a VLAN tag with a VLAN
+	 * ID = 0 to be recognized as belonging to the Stream.
+	 * 3 all: A frame is recognized as belonging to the Stream whether
+	 * tagged or not.
 	 */
 	uint8_t tagged;
 
-	/* tsnCpeNullDownVlan. Specifies the vlan_identifier parameter that identifies
-	 * a packet in an EISS indication primitive to the Null Stream identification
-	 * function. A value of 0 indicates that the vlan_identifier parameter is ignored
-	 * on EISS indication primitives.
+	/* tsnCpeNullDownVlan. Specifies the vlan_identifier parameter that
+	 * identifies a packet in an EISS indication primitive to the Null
+	 * Stream identification function. A value of 0 indicates that the vlan
+	 * _identifier parameter is ignored on EISS indication primitives.
 	 */
 	uint16_t vid;
 };
@@ -478,41 +480,43 @@ struct tsn_cb_ip_streamid {
 
 /* 802.1CB stream identify table clause 9.1 */
 struct tsn_cb_streamid {
-	/* The objects in a given entry of the Stream identity table are used to
-	 * control packets whose stream_handle subparameter is equal to the entryâ€™s
-	 * tsnStreamIdHandle object.
+	/* The objects in a given entry of the Stream identity table are used
+	 * to control packets whose stream_handle subparameter is equal to the
+	 * entry tsnStreamIdHandle object.
 	 */
 	int32_t handle;
 
-	/* The list of ports on which an in-facing Stream identification function
-	 * in the output (towards the system forwarding function) direction
-	 * Only Active Destination MAC and VLAN Stream identification (or nothing)
-	 * can be configured.
+	/* The list of ports on which an in-facing Stream identification
+	 * function in the output (towards the system forwarding function)
+	 * direction Only Active Destination MAC and VLAN Stream identification
+	 * (or nothing) can be configured.
 	 */
 	uint32_t ifac_oport;
 
-	/* The list of ports on which an out-facing Stream identification function
-	 * in the output (towards the physical interface) direction.
-	 * Only Active Destination MAC and VLAN Stream identification (or nothing)
-	 * can be configured.
+	/* The list of ports on which an out-facing Stream identification
+	 * function in the output (towards the physical interface) direction.
+	 * Only Active Destination MAC and VLAN Stream identification
+	 * (or nothing) can be configured.
 	 */
 	uint32_t ofac_oport;
 
-	/* The list of ports on which an in-facing Stream identification function
-	 * in the input (coming from the system forwarding function) direction
+	/* The list of ports on which an in-facing Stream identification
+	 * function in the input (coming from the system forwarding function)
+	 * direction
 	 */
 	uint32_t ifac_iport;
 
-	/* The list of ports on which an out-facing Stream identification function
-	 * in the input (coming from the physical interface) direction.
+	/* The list of ports on which an out-facing Stream identification
+	 * function in the input (coming from the physical interface) direction
+	 * .
 	 */
 	uint32_t ofac_iport;
 
-	/* An enumerated value indicating the method used to identify packets belonging
-	 * to the Stream.
-	 * The Organizationally Unique Identifier (OUI) or Company Identifier (CID) to
-	 * identify the organization defining the enumerated type should be:
-	 * 00-80-C2
+	/* An enumerated value indicating the method used to identify packets
+	 * belonging to the Stream.
+	 * The Organizationally Unique Identifier (OUI) or Company Identifier
+	 * (CID) to identify the organization defining the enumerated type
+	 * should be: 00-80-C2
 	 * 1: null stream identification
 	 * 2: source mac and vlan stream identification
 	 * 3: activ destination mac and vlan stream identification
@@ -520,9 +524,9 @@ struct tsn_cb_streamid {
 	 */
 	uint8_t type;
 
-	/* tsnStreamIdParameters The number of controlling parameters for a Stream
-	 * identification method, their types and values, are specific to the
-	 * tsnStreamIdIdentificationType
+	/* tsnStreamIdParameters The number of controlling parameters for a
+	 * Stream identification method, their types and values, are specific
+	 * to the tsnStreamIdIdentificationType
 	 */
 	union {
 		struct tsn_cb_null_streamid nid;
@@ -532,9 +536,10 @@ struct tsn_cb_streamid {
 	} para;
 };
 
-/* Following counters are instantiated for each port on which the Stream identification
- * function (6.2) is configured. The counters are indexed by port number, facing
- * (in-facing or out-facing), and stream_handle value (tsnStreamIdHandle, 9.1.1.1).
+/* Following counters are instantiated for each port on which the Stream
+ * identification function (6.2) is configured. The counters are indexed by
+ * port number, facing (in-facing or out-facing), and stream_handle value
+ * (tsnStreamIdHandle, 9.1.1.1).
  */
 struct tsn_cb_streamid_counters {
 	struct {
@@ -551,29 +556,32 @@ struct tsn_cb_streamid_counters {
 /* 802.1Qci Stream Parameter Table, read from port */
 struct tsn_qci_psfp_stream_param {
 	/* MaxStreamFilterInstances.
-	 * The maximum number of Stream Filter instances supported by this Bridge component.
+	 * The maximum number of Stream Filter instances supported by this
+	 * Bridge component.
 	 */
 	int32_t max_sf_instance;
 
 	/* MaxStreamGateInstances
-	 * The maximum number of Stream Gate instances supported by this Bridge component.
+	 * The maximum number of Stream Gate instances supported by this Bridge
+	 * component.
 	 */
 	int32_t max_sg_instance;
 
 	/* MaxFlowMeterInstances
-	 * The maximum number of Flow Meter instances supported by this Bridge component.
+	 * The maximum number of Flow Meter instances supported by this Bridge
+	 * component.
 	 */
 	int32_t max_fm_instance;
 
 	/* SupportedListMax
-	 * The maximum value supported by this Bridge component of the AdminControlListLength and
-	 * OperControlListLength parameters.
+	 * The maximum value supported by this Bridge component of the
+	 * AdminControlListLength and OperControlListLength parameters.
 	 */
 	int32_t supported_list_max;
 };
 
 /* 802.1Qci Stream Filter Instance Table, counters part only. */
-struct tsn_qci_psfp_sfi_counters{
+struct tsn_qci_psfp_sfi_counters {
 	/* The MatchingFramesCount counter counts received frames that match
 	 * this stream filter.
 	 */
@@ -626,21 +634,22 @@ struct tsn_qci_psfp_sfi_conf {
 	 */
 	uint32_t stream_gate_instance_id;
 
-	/* The filter specifications. The actions specified in a filter specification
-	 * can result in a frame passing or failing the specified filter. Frames that
-	 * fail a filter are discarded.
+	/* The filter specifications. The actions specified in a filter
+	 * specification can result in a frame passing or failing the specified
+	 * filter. Frames that fail a filter are discarded.
 	 */
 	struct {
-		/* The MaximumSDUSize parameter specifies the maximum allowed frame size
-		 * for the stream. Any frame exceeding this value will be dropped.  A
-		 * value of 0 denote that the MaximumSDUSize filter is disabled for this
-		 * stream.
+		/* The MaximumSDUSize parameter specifies the maximum allowed
+		 * frame size for the stream. Any frame exceeding this value
+		 * will be dropped.  A value of 0 denote that the MaximumSDUSize
+		 * filter is disabled for this stream.
 		 */
 		uint16_t maximum_sdu_size;
 
-		/* The FlowMeterInstanceID parameter contains the index of an entry in
-		 * the Flow Meter Table.  A value of -1 denotes that no flow meter is
-		 * assigned; zero or positive values denote flow meter IDs.
+		/* The FlowMeterInstanceID parameter contains the index of an
+		 * entry in the Flow Meter Table.  A value of -1 denotes that
+		 * no flow meter is assigned; zero or positive values denote
+		 * flow meter IDs.
 		 */
 		int32_t flow_meter_instance_id;
 	} stream_filter;
@@ -660,7 +669,7 @@ struct tsn_qci_psfp_sfi_conf {
 };
 
 /* 802.1Qci Stream Gate Control List Entry. */
-struct tsn_qci_psfp_gcl{
+struct tsn_qci_psfp_gcl {
 	/* The GateState parameter specifies a desired state, open (true) or
 	 * closed (false), for the stream gate.
 	 */
@@ -685,41 +694,45 @@ struct tsn_qci_psfp_gcl{
 
 /* 802.1Qci Stream Gate Admin/Operation common list control parameters */
 struct tsn_qci_sg_control {
-	/* The administrative/operation value of the GateStates parameter for the stream
-	 * gate.  A value of false indicates closed; a value of true indicates
-	 * open.
+	/* The administrative/operation value of the GateStates parameter
+	 * for the stream gate.  A value of false indicates closed;
+	 * a value of true indicates open.
 	 */
 	bool gate_states;
 
-	/* The administrative/operation value of the ListMax parameter for the gate. The
-	 * integer value indicates the number of entries (TLVs) in the
-	 * AdminControlList/OperControlList.
+	/* The administrative/operation value of the ListMax parameter for the
+	 * gate. The integer value indicates the number of entries (TLVs) in
+	 * the AdminControlList/OperControlList.
 	 */
 	uint8_t control_list_length;
 
-	/* The administrative/operation value of the CycleTime parameter for the
-	 * gate.  The value is an unsigned integer number of nanoseconds.
+	/* The administrative/operation value of the CycleTime parameter for
+	 * the gate.  The value is an unsigned integer number of nanoseconds.
 	 */
 	uint32_t cycle_time;
 
-	/* The administrative/operation value of the CycleTimeExtension parameter for the
-	 * gate.  The value is an unsigned integer number of nanoseconds.
+	/* The administrative/operation value of the CycleTimeExtension
+	 * parameter for the gate.  The value is an unsigned integer number
+	 * of nanoseconds.
 	 */
 	uint32_t cycle_time_extension;
 
-	/* The administrative/operation value of the BaseTime parameter for the gate.  The
-	 * value is a representation of a PTPtime value, consisting of a 48-bit
-	 * integer number of seconds and a 32-bit integer number of nanoseconds.
+	/* The administrative/operation value of the BaseTime parameter for the
+	 * gate.  The value is a representation of a PTPtime value, consisting
+	 * of a 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
 	 */
 	ptptime_t base_time;
 
-	/* The administrative/operation value of the IPV parameter for the gate.  A value
-	 * of -1 denotes the null value; zero or positive values denote internal
-	 * priority values.
+	/* The administrative/operation value of the IPV parameter for the gate.
+	 * A value of -1 denotes the null value; zero or positive values denote
+	 * internal priority values.
 	 */
 	int8_t init_ipv;
 
-	/* control_list contend the gate control list of administrative/operation */
+	/* control_list contend the gate control list of
+	 * administrative/operation
+	 */
 	struct tsn_qci_psfp_gcl *gcl;
 };
 
@@ -758,8 +771,9 @@ struct tsn_qci_psfp_sgi_conf {
 	bool block_octets_exceeded_enable;
 
 	/* The GateClosedDueToOctetsExceeded object contains a Boolean value
-	 * that indicates whether, if the GateClosedDueToOctetsExceeded function
-	 * is enabled, all frames are to be discarded (TRUE) or not (FALSE).
+	 * that indicates whether, if the GateClosedDueToOctetsExceeded
+	 * function is enabled, all frames are to be discarded (TRUE) or not
+	 * (FALSE).
 	 */
 	bool block_octets_exceeded;
 };
@@ -782,9 +796,10 @@ struct tsn_psfp_sgi_status {
 	 */
 	uint32_t tick_granularity;
 
-	/* The current time, in PTPtime, as maintained by the local system.  The
-	 * value is a representation of a PTPtime value, consisting of a 48-bit
-	 * integer number of seconds and a 32-bit integer number of nanoseconds.
+	/* The current time, in PTPtime, as maintained by the local system.
+	 * The value is a representation of a PTPtime value, consisting of a
+	 * 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
 	 */
 	ptptime_t current_time;
 
@@ -843,14 +858,14 @@ struct tsn_qci_psfp_fmi {
 	bool drop_on_yellow;
 
 	/* The FlowMeterMarkAllFramesRedEnable parameter contains a Boolean
-	 * value that indicates whether the MarkAllFramesRed function is enabled
-	 * (TRUE) or disabled (FALSE).
+	 * value that indicates whether the MarkAllFramesRed function
+	 * is enabled (TRUE) or disabled (FALSE).
 	 */
 	bool mark_red_enable;
 
-	/* The FlowMeterMarkAllFramesRed parameter contains a Boolean value that
-	 * indicates whether, if the MarkAllFramesRed function is enabled, all
-	 * frames are to be discarded (TRUE) or not (FALSE).
+	/* The FlowMeterMarkAllFramesRed parameter contains a Boolean value
+	 * that indicates whether, if the MarkAllFramesRed function is enabled,
+	 * all frames are to be discarded (TRUE) or not (FALSE).
 	 */
 	bool mark_red;
 };
@@ -881,7 +896,8 @@ struct tsn_seq_rec_conf {
 
 /* An entry for gate control list */
 struct tsn_qbv_entry {
-	/* Octet represent the gate states for the corresponding traffic classes
+	/* Octet represent the gate states for the corresponding traffic
+	 * classes.
 	 * The MS bit corresponds to traffic class 7.
 	 * The LS bit to traffic class 0.
 	 * A bit value of 0 indicates closed;
@@ -897,19 +913,21 @@ struct tsn_qbv_entry {
 
 /* The administrative/operation time and gate list */
 struct tsn_qbv_basic {
-	/* The administrative/operation value of the GateStates parameter for the Port.
-	 * The bits of the octet represent the gate states for the corresponding
-	 * traffic classes; the MS bit corresponds to traffic class 7, the LS
-	 * bit to traffic class 0. A bit value of 0 indicates closed; a bit
-	 * value of 1 indicates open. The value of this object MUST be retained
+	/* The administrative/operation value of the GateStates parameter for
+	 * the Port.
+	 * The bits of the octet represent the gate states for the
+	 * corresponding traffic classes; the MS bit corresponds to traffic
+	 * class 7, the LS bit to traffic class 0. A bit value of 0 indicates
+	 * closed; a bit value of 1 indicates open.
+	 * The value of this object MUST be retained
 	 * across reinitializations of the management system.
 	 */
 	uint8_t gate_states;
 
-	/* The administrative/operation value of the ListMax parameter for the port. The
-	 * integer value indicates the number of entries (TLVs) in the
-	 * AdminControlList. The value of this object MUST be retained across
-	 * reinitializations of the management system.
+	/* The administrative/operation value of the ListMax parameter for the
+	 * port. The integer value indicates the number of entries (TLVs) in
+	 * the AdminControlList. The value of this object MUST be retained
+	 * across reinitializations of the management system.
 	 */
 	uint32_t control_list_length;
 
@@ -921,17 +939,19 @@ struct tsn_qbv_basic {
 	 */
 	uint32_t cycle_time;
 
-	/* The administrative/operation value of the CycleTimeExtension parameter for the
-	 * Port. The value is an unsigned integer number of nanoseconds. The
-	 * value of this object MUST be retained across reinitializations of the
-	 * management system.
+	/* The administrative/operation value of the CycleTimeExtension
+	 * parameter for the Port. The value is an unsigned integer number of
+	 * nanoseconds.
+	 * The value of this object MUST be retained across reinitializations
+	 * of the management system.
 	 */
 
 	uint32_t cycle_time_extension;
 
-	/* The administrative/operation value of the BaseTime parameter for the Port.  The
-	 * value is a representation of a PTPtime value, consisting of a 48-bit
-	 * integer number of seconds and a 32-bit integer number of nanoseconds.
+	/* The administrative/operation value of the BaseTime parameter for the
+	 * Port.  The value is a representation of a PTPtime value, consisting
+	 * of a 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
 	 * The value of this object MUST be retained across reinitializations of
 	 * the management system.
 	 */
@@ -946,10 +966,12 @@ struct tsn_qbv_basic {
 struct tsn_qbv_conf {
 	/* The GateEnabled parameter determines whether traffic scheduling is
 	 * active (true) or inactive (false).  The value of this object MUST be
-	 * retained across reinitializations of the management system. */
+	 * retained across reinitializations of the management system.
+	 */
 	bool gate_enabled;
 
-	/* The maxsdu parameter denoting the maximum SDU size supported by the queue.
+	/* The maxsdu parameter denoting the maximum SDU size supported by the
+	 * queue.
 	 */
 	uint32_t maxsdu;
 
@@ -981,9 +1003,10 @@ struct tsn_qbv_status {
 	 */
 	uint32_t tick_granularity;
 
-	/* The current time, in PTPtime, as maintained by the local system.  The
-	 * value is a representation of a PTPtime value, consisting of a 48-bit
-	 * integer number of seconds and a 32-bit integer number of nanoseconds.
+	/* The current time, in PTPtime, as maintained by the local system.
+	 * The value is a representation of a PTPtime value, consisting of a
+	 * 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
 	 */
 	ptptime_t  current_time;
 
@@ -1015,13 +1038,15 @@ struct tsn_tsd {
 	/* The cycle time, in units of microsecond(us)*/
 	uint32_t period;
 
-	/* The maximum number of frames which could be transmitted on one cycle.
-	 *  The exceeding frames will be transmitted on next cycle.*/
+	/* The maximum number of frames which could be transmitted on one cycle
+	 *  The exceeding frames will be transmitted on next cycle.
+	 */
 	uint32_t maxFrameNum;
 
 	/* Specify the time of the first cycle begins.
 	 *      1:  begin when the queue get the first frame to transmit.
-	 *      2:  begin immediately at the end of setting function.*/
+	 *      2:  begin immediately at the end of setting function.
+	 */
 	uint32_t syn_flag;
 };
 
@@ -1035,4 +1060,3 @@ struct tsn_tsd_status {
 };
 
 #endif /* _UAPI_GENL_TSN_H */
-
diff --git a/net/tsn/Kconfig b/net/tsn/Kconfig
index 04f1b99857b1..9f22807a74c9 100644
--- a/net/tsn/Kconfig
+++ b/net/tsn/Kconfig
@@ -2,7 +2,7 @@ config TSN
 	bool "802.1 Time-Sensitive Networking support"
 	default n
 	depends on VLAN_8021Q && PTP_1588_CLOCK
-	---help---
+	help
 	  This enables support for TSN(time sensitive networking)
 	  TSN features include:
 		802.1Qav:
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index 845ade383423..ade526de9d83 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -1,36 +1,5 @@
-/*
- * Copyright 2017-2018 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the above-listed copyright holders nor the
- *       names of any contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/* Copyright 2017-2018 NXP */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -42,17 +11,9 @@
 #include <linux/version.h>
 #include <net/tsn.h>
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 12, 0)
-#define NLA_PARSE_NESTED(a, b, c, d) nla_parse_nested(a, b, c, d)
-#else
 #define NLA_PARSE_NESTED(a, b, c, d) nla_parse_nested(a, b, c, d, NULL)
-#endif
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 6, 7)
-#define NLA_PUT_U64(a, b, c) nla_put_u64(a, b, c)
-#else
 #define NLA_PUT_U64(a, b, c) nla_put_u64_64bit(a, b, c, NLA_U64)
-#endif
-/* the netlink family */
+
 static struct genl_family tsn_family;
 
 LIST_HEAD(port_list);
@@ -68,9 +29,9 @@ static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
 	[TSN_CMD_ATTR_MESG]		= { .type = NLA_STRING },
 	[TSN_CMD_ATTR_DATA]		= { .type = NLA_S32 },
 	[TSN_ATTR_IFNAME]		= { .type = NLA_STRING },
-	[TSN_ATTR_PORT_NUMBER]	= { .type = NLA_U8 },
+	[TSN_ATTR_PORT_NUMBER]		= { .type = NLA_U8 },
 	[TSN_ATTR_QBV]			= { .type = NLA_NESTED },
-	[TSN_ATTR_STREAM_IDENTIFY] = { .type = NLA_NESTED },
+	[TSN_ATTR_STREAM_IDENTIFY]	= { .type = NLA_NESTED },
 	[TSN_ATTR_QCI_SP]		= { .type = NLA_NESTED },
 	[TSN_ATTR_QCI_SFI]		= { .type = NLA_NESTED },
 	[TSN_ATTR_QCI_SGI]		= { .type = NLA_NESTED },
@@ -79,9 +40,9 @@ static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
 	[TSN_ATTR_TSD]			= { .type = NLA_NESTED },
 	[TSN_ATTR_QBU]			= { .type = NLA_NESTED },
 	[TSN_ATTR_CT]			= { .type = NLA_NESTED },
-	[TSN_ATTR_CBGEN]                = { .type = NLA_NESTED },
-	[TSN_ATTR_CBREC]                = { .type = NLA_NESTED },
-	[TSN_ATTR_PCPMAP]               = { .type = NLA_NESTED },
+	[TSN_ATTR_CBGEN]		= { .type = NLA_NESTED },
+	[TSN_ATTR_CBREC]		= { .type = NLA_NESTED },
+	[TSN_ATTR_PCPMAP]		= { .type = NLA_NESTED },
 };
 
 static const struct nla_policy ct_policy[TSN_CT_ATTR_MAX + 1] = {
@@ -89,18 +50,18 @@ static const struct nla_policy ct_policy[TSN_CT_ATTR_MAX + 1] = {
 };
 
 static const struct nla_policy cbgen_policy[TSN_CBGEN_ATTR_MAX + 1] = {
-	[TSN_CBGEN_ATTR_INDEX]	        = { .type = NLA_U32 },
+	[TSN_CBGEN_ATTR_INDEX]		= { .type = NLA_U32 },
 	[TSN_CBGEN_ATTR_PORT_MASK]	= { .type = NLA_U8 },
 	[TSN_CBGEN_ATTR_SPLIT_MASK]	= { .type = NLA_U8 },
 	[TSN_CBGEN_ATTR_SEQ_LEN]	= { .type = NLA_U8 },
-	[TSN_CBGEN_ATTR_SEQ_NUM]        = { .type = NLA_U32 },
+	[TSN_CBGEN_ATTR_SEQ_NUM]	= { .type = NLA_U32 },
 };
 
 static const struct nla_policy cbrec_policy[TSN_CBREC_ATTR_MAX + 1] = {
-	[TSN_CBREC_ATTR_INDEX]          = { .type = NLA_U32 },
+	[TSN_CBREC_ATTR_INDEX]		= { .type = NLA_U32 },
 	[TSN_CBREC_ATTR_SEQ_LEN]	= { .type = NLA_U8 },
-	[TSN_CBREC_ATTR_HIS_LEN]        = { .type = NLA_U8 },
-	[TSN_CBREC_ATTR_TAG_POP_EN]     = { .type = NLA_FLAG },
+	[TSN_CBREC_ATTR_HIS_LEN]	= { .type = NLA_U8 },
+	[TSN_CBREC_ATTR_TAG_POP_EN]	= { .type = NLA_FLAG },
 };
 
 static const struct nla_policy pcpmap_policy[TSN_PCPMAP_ATTR_MAX + 1] = {
@@ -108,16 +69,16 @@ static const struct nla_policy pcpmap_policy[TSN_PCPMAP_ATTR_MAX + 1] = {
 };
 
 static const struct nla_policy qbu_policy[TSN_QBU_ATTR_MAX + 1] = {
-	[TSN_QBU_ATTR_ADMIN_STATE] 		= { .type = NLA_U8 },
-	[TSN_QBU_ATTR_HOLD_ADVANCE] 	= { .type = NLA_U32},
-	[TSN_QBU_ATTR_RELEASE_ADVANCE] 	= { .type = NLA_U32},
-	[TSN_QBU_ATTR_ACTIVE]			= { .type = NLA_FLAG},
-	[TSN_QBU_ATTR_HOLD_REQUEST] 	= { .type = NLA_U8},
+	[TSN_QBU_ATTR_ADMIN_STATE]	= { .type = NLA_U8 },
+	[TSN_QBU_ATTR_HOLD_ADVANCE]	= { .type = NLA_U32},
+	[TSN_QBU_ATTR_RELEASE_ADVANCE]	= { .type = NLA_U32},
+	[TSN_QBU_ATTR_ACTIVE]		= { .type = NLA_FLAG},
+	[TSN_QBU_ATTR_HOLD_REQUEST]	= { .type = NLA_U8},
 };
 
 static const struct nla_policy cbs_policy[TSN_CBS_ATTR_MAX + 1] = {
 	[TSN_CBS_ATTR_TC_INDEX]		= { .type = NLA_U8},
-	[TSN_CBS_ATTR_BW]			= { .type = NLA_U8},
+	[TSN_CBS_ATTR_BW]		= { .type = NLA_U8},
 };
 
 static const struct nla_policy tsd_policy[TSN_TSD_ATTR_MAX + 1] = {
@@ -132,17 +93,17 @@ static const struct nla_policy tsd_policy[TSN_TSD_ATTR_MAX + 1] = {
 
 static const struct nla_policy qbv_policy[TSN_QBV_ATTR_MAX + 1] = {
 	[TSN_QBV_ATTR_ADMINENTRY]	= {	.type = NLA_NESTED},
-	[TSN_QBV_ATTR_OPERENTRY] = { .type = NLA_NESTED},
-	[TSN_QBV_ATTR_ENABLE] 	= { .type = NLA_FLAG},
-	[TSN_QBV_ATTR_DISABLE]	= { .type = NLA_FLAG},
-	[TSN_QBV_ATTR_CONFIGCHANGE] = { .type = NLA_FLAG},
-	[TSN_QBV_ATTR_CONFIGCHANGETIME] = { .type = NLA_U64},
+	[TSN_QBV_ATTR_OPERENTRY]	= { .type = NLA_NESTED},
+	[TSN_QBV_ATTR_ENABLE]		= { .type = NLA_FLAG},
+	[TSN_QBV_ATTR_DISABLE]		= { .type = NLA_FLAG},
+	[TSN_QBV_ATTR_CONFIGCHANGE]	= { .type = NLA_FLAG},
+	[TSN_QBV_ATTR_CONFIGCHANGETIME]	= { .type = NLA_U64},
 	[TSN_QBV_ATTR_MAXSDU]		= { .type = NLA_U32},
-	[TSN_QBV_ATTR_GRANULARITY] 	= { .type = NLA_U32},
-	[TSN_QBV_ATTR_CURRENTTIME] 	= { .type = NLA_U64},
-	[TSN_QBV_ATTR_CONFIGPENDING] = {.type = NLA_FLAG},
-	[TSN_QBV_ATTR_CONFIGCHANGEERROR] = { .type = NLA_U64},
-	[TSN_QBV_ATTR_LISTMAX] 	= { .type = NLA_U32},
+	[TSN_QBV_ATTR_GRANULARITY]	= { .type = NLA_U32},
+	[TSN_QBV_ATTR_CURRENTTIME]	= { .type = NLA_U64},
+	[TSN_QBV_ATTR_CONFIGPENDING]	= {.type = NLA_FLAG},
+	[TSN_QBV_ATTR_CONFIGCHANGEERROR]	= { .type = NLA_U64},
+	[TSN_QBV_ATTR_LISTMAX]		= { .type = NLA_U32},
 };
 
 static const struct nla_policy qbv_ctrl_policy[TSN_QBV_ATTR_CTRL_MAX + 1] = {
@@ -161,8 +122,8 @@ static const struct nla_policy qbv_entry_policy[TSN_QBV_ATTR_ENTRY_MAX + 1] = {
 };
 
 static const struct nla_policy cb_streamid_policy[TSN_STREAMID_ATTR_MAX + 1] = {
-	[TSN_STREAMID_ATTR_INDEX] 	= { .type = NLA_U32},
-	[TSN_STREAMID_ATTR_ENABLE] 	= { .type = NLA_FLAG},
+	[TSN_STREAMID_ATTR_INDEX]	= { .type = NLA_U32},
+	[TSN_STREAMID_ATTR_ENABLE]	= { .type = NLA_FLAG},
 	[TSN_STREAMID_ATTR_DISABLE]	= { .type = NLA_FLAG},
 	[TSN_STREAMID_ATTR_STREAM_HANDLE]	= { .type = NLA_S32},
 	[TSN_STREAMID_ATTR_IFOP]	= { .type = NLA_U32},
@@ -172,10 +133,10 @@ static const struct nla_policy cb_streamid_policy[TSN_STREAMID_ATTR_MAX + 1] = {
 	[TSN_STREAMID_ATTR_TYPE]	= { .type = NLA_U8},
 	[TSN_STREAMID_ATTR_NDMAC]	= { .type = NLA_U64},
 	[TSN_STREAMID_ATTR_NTAGGED]	= { .type = NLA_U8},
-	[TSN_STREAMID_ATTR_NVID]		= { .type = NLA_U16},
+	[TSN_STREAMID_ATTR_NVID]	= { .type = NLA_U16},
 	[TSN_STREAMID_ATTR_SMAC]	= { .type = NLA_U64},
 	[TSN_STREAMID_ATTR_STAGGED]	= { .type = NLA_U8},
-	[TSN_STREAMID_ATTR_SVID]		= { .type = NLA_U16},
+	[TSN_STREAMID_ATTR_SVID]	= { .type = NLA_U16},
 	[TSN_STREAMID_ATTR_COUNTERS_PSI] = { .type = NLA_U64},
 	[TSN_STREAMID_ATTR_COUNTERS_PSO] = { .type = NLA_U64},
 	[TSN_STREAMID_ATTR_COUNTERS_PSPPI] = { .type = NLA_U64},
@@ -186,40 +147,30 @@ static const struct nla_policy qci_sfi_policy[TSN_QCI_SFI_ATTR_MAX + 1] = {
 	[TSN_QCI_SFI_ATTR_INDEX]		= { .type = NLA_U32},
 	[TSN_QCI_SFI_ATTR_ENABLE]		= { .type = NLA_FLAG},
 	[TSN_QCI_SFI_ATTR_DISABLE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SFI_ATTR_STREAM_HANDLE] = { .type = NLA_S32},
-	[TSN_QCI_SFI_ATTR_PRIO_SPEC] 	= { .type = NLA_S8},
+	[TSN_QCI_SFI_ATTR_STREAM_HANDLE]	= { .type = NLA_S32},
+	[TSN_QCI_SFI_ATTR_PRIO_SPEC]		= { .type = NLA_S8},
 	[TSN_QCI_SFI_ATTR_GATE_ID]		= { .type = NLA_U32},
-	[TSN_QCI_SFI_ATTR_FILTER_TYPE]	= { .type = NLA_U8},
+	[TSN_QCI_SFI_ATTR_FILTER_TYPE]		= { .type = NLA_U8},
 	[TSN_QCI_SFI_ATTR_FLOW_ID]		= { .type = NLA_S32},
 	[TSN_QCI_SFI_ATTR_MAXSDU]		= { .type = NLA_U16},
-	[TSN_QCI_SFI_ATTR_COUNTERS]		= { .len = sizeof(struct tsn_qci_psfp_sfi_counters)},
+	[TSN_QCI_SFI_ATTR_COUNTERS]		= {
+		.len = sizeof(struct tsn_qci_psfp_sfi_counters)},
 	[TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE]	= { .type = NLA_FLAG},
 	[TSN_QCI_SFI_ATTR_OVERSIZE]		= { .type = NLA_FLAG},
 };
 
-#if 0
-static const struct nla_policy qci_sfi_counters_policy[TSN_QCI_SFI_ATTR_COUNT_MAX + 1] = {
-	[TSN_QCI_SFI_ATTR_MATCH]		= { .type = NLA_U64},
-	[TSN_QCI_SFI_ATTR_PASS]			= { .type = NLA_U64},
-	[TSN_QCI_SFI_ATTR_DROP]			= { .type = NLA_U64},
-	[TSN_QCI_SFI_ATTR_SDU_DROP]		= { .type = NLA_U64},
-	[TSN_QCI_SFI_ATTR_SDU_PASS]		= { .type = NLA_U64},
-	[TSN_QCI_SFI_ATTR_RED]			= { .type = NLA_U64},
-};
-#endif
-
 static const struct nla_policy qci_sgi_policy[] = {
 	[TSN_QCI_SGI_ATTR_INDEX]		= { .type = NLA_U32},
 	[TSN_QCI_SGI_ATTR_ENABLE]		= { .type = NLA_FLAG},
 	[TSN_QCI_SGI_ATTR_DISABLE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_CONFCHANGE]	= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_IRXEN]		= { .type = NLA_FLAG},		/* Invalid rx enable*/
+	[TSN_QCI_SGI_ATTR_CONFCHANGE]		= { .type = NLA_FLAG},
+	[TSN_QCI_SGI_ATTR_IRXEN]		= { .type = NLA_FLAG},
 	[TSN_QCI_SGI_ATTR_IRX]			= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_OEXEN]		= { .type = NLA_FLAG},		/* Octet exceed enable */
+	[TSN_QCI_SGI_ATTR_OEXEN]		= { .type = NLA_FLAG},
 	[TSN_QCI_SGI_ATTR_OEX]			= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_ADMINENTRY]	= { .type = NLA_NESTED},
-	[TSN_QCI_SGI_ATTR_OPERENTRY]	= { .type = NLA_NESTED},
-	[TSN_QCI_SGI_ATTR_CCTIME]		= { .type = NLA_U64},	/* config change time */
+	[TSN_QCI_SGI_ATTR_ADMINENTRY]		= { .type = NLA_NESTED},
+	[TSN_QCI_SGI_ATTR_OPERENTRY]		= { .type = NLA_NESTED},
+	[TSN_QCI_SGI_ATTR_CCTIME]		= { .type = NLA_U64},
 	[TSN_QCI_SGI_ATTR_TICKG]		= { .type = NLA_U32},
 	[TSN_QCI_SGI_ATTR_CUTIME]		= { .type = NLA_U64},
 	[TSN_QCI_SGI_ATTR_CPENDING]		= { .type = NLA_FLAG},
@@ -227,17 +178,17 @@ static const struct nla_policy qci_sgi_policy[] = {
 };
 
 static const struct nla_policy qci_sgi_ctrl_policy[] = {
-	[TSN_SGI_ATTR_CTRL_INITSTATE]	= { .type = NLA_FLAG},
+	[TSN_SGI_ATTR_CTRL_INITSTATE]		= { .type = NLA_FLAG},
 	[TSN_SGI_ATTR_CTRL_LEN]			= { .type = NLA_U8},
 	[TSN_SGI_ATTR_CTRL_CYTIME]		= { .type = NLA_U32},
-	[TSN_SGI_ATTR_CTRL_CYTIMEEX]	= { .type = NLA_U32},
+	[TSN_SGI_ATTR_CTRL_CYTIMEEX]		= { .type = NLA_U32},
 	[TSN_SGI_ATTR_CTRL_BTIME]		= { .type = NLA_U64},
 	[TSN_SGI_ATTR_CTRL_INITIPV]		= { .type = NLA_S8},
-	[TSN_SGI_ATTR_CTRL_GCLENTRY]	= { .type = NLA_NESTED},
+	[TSN_SGI_ATTR_CTRL_GCLENTRY]		= { .type = NLA_NESTED},
 };
 
 static const struct nla_policy qci_sgi_gcl_policy[] = {
-	[TSN_SGI_ATTR_GCL_GATESTATE]	= { .type = NLA_FLAG},
+	[TSN_SGI_ATTR_GCL_GATESTATE]		= { .type = NLA_FLAG},
 	[TSN_SGI_ATTR_GCL_IPV]			= { .type = NLA_S8},
 	[TSN_SGI_ATTR_GCL_INTERVAL]		= { .type = NLA_U32},
 	[TSN_SGI_ATTR_GCL_OCTMAX]		= { .type = NLA_U32},
@@ -256,10 +207,12 @@ static const struct nla_policy qci_fmi_policy[] = {
 	[TSN_QCI_FMI_ATTR_DROPYL]	= { .type = NLA_FLAG},
 	[TSN_QCI_FMI_ATTR_MAREDEN]	= { .type = NLA_FLAG},
 	[TSN_QCI_FMI_ATTR_MARED]	= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_COUNTERS]	= { .len = sizeof(struct tsn_qci_psfp_fmi_counters)},
+	[TSN_QCI_FMI_ATTR_COUNTERS]	= {
+		.len = sizeof(struct tsn_qci_psfp_fmi_counters)},
 };
 
-static int tsn_prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp, size_t size)
+static int tsn_prepare_reply(struct genl_info *info, u8 cmd,
+			     struct sk_buff **skbp, size_t size)
 {
 	struct sk_buff *skb;
 	void *reply;
@@ -318,7 +271,8 @@ static int cmd_attr_echo_message(struct genl_info *info)
 
 	size = nla_total_size(strlen(msg) + 1);
 
-	ret = tsn_prepare_reply(info, TSN_CMD_REPLY, &rep_skb, size + NLMSG_ALIGN(MAX_USER_SIZE));
+	ret = tsn_prepare_reply(info, TSN_CMD_REPLY, &rep_skb,
+				size + NLMSG_ALIGN(MAX_USER_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -352,7 +306,8 @@ static int cmd_attr_echo_data(struct genl_info *info)
 	/* send back */
 	size = nla_total_size(sizeof(s32));
 
-	ret = tsn_prepare_reply(info, TSN_CMD_REPLY, &rep_skb, size + NLMSG_ALIGN(MAX_USER_SIZE));
+	ret = tsn_prepare_reply(info, TSN_CMD_REPLY, &rep_skb,
+				size + NLMSG_ALIGN(MAX_USER_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -370,19 +325,16 @@ static int cmd_attr_echo_data(struct genl_info *info)
 
 static int tsn_echo_cmd(struct sk_buff *skb, struct genl_info *info)
 {
-	if (info->attrs[TSN_CMD_ATTR_MESG]) {
-		pr_info("tsn get attr TSN_CMD_ATTR_MESG in tsn_echo_cmd\n");
+	if (info->attrs[TSN_CMD_ATTR_MESG])
 		return cmd_attr_echo_message(info);
-	} else if (info->attrs[TSN_CMD_ATTR_DATA]) {
-		pr_info("tsn get attr TSN_CMD_ATTR_DATA in tsn_echo_cmd\n");
+	else if (info->attrs[TSN_CMD_ATTR_DATA])
 		return cmd_attr_echo_data(info);
-	}
 
-	pr_info("tsn get no attr in tsn_echo_cmd\n");
 	return -EINVAL;
 }
 
-static int tsn_simple_reply(struct genl_info *info, u32 cmd, char *portname, s32 retvalue)
+static int tsn_simple_reply(struct genl_info *info, u32 cmd,
+			    char *portname, s32 retvalue)
 {
 	struct sk_buff *rep_skb;
 	size_t size;
@@ -392,7 +344,8 @@ static int tsn_simple_reply(struct genl_info *info, u32 cmd, char *portname, s32
 	size = nla_total_size(strlen(portname) + 1);
 	size += nla_total_size(sizeof(s32));
 
-	ret = tsn_prepare_reply(info, cmd, &rep_skb, size + NLMSG_ALIGN(MAX_USER_SIZE));
+	ret = tsn_prepare_reply(info, cmd,
+				&rep_skb, size + NLMSG_ALIGN(MAX_USER_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -408,7 +361,8 @@ static int tsn_simple_reply(struct genl_info *info, u32 cmd, char *portname, s32
 	return tsn_send_reply(rep_skb, info);
 }
 
-struct tsn_port *tsn_init_check(struct genl_info *info, struct net_device **ndev)
+struct tsn_port *tsn_init_check(struct genl_info *info,
+				struct net_device **ndev)
 {
 	struct nlattr *na;
 	char *portname;
@@ -418,20 +372,19 @@ struct tsn_port *tsn_init_check(struct genl_info *info, struct net_device **ndev
 
 	na = info->attrs[TSN_ATTR_IFNAME];
 	if (!na) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, "no portname", -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 "no portname", -TSN_ATTRERR);
 		return NULL;
 	}
 
 	portname = (char *)nla_data(na);
 	netdev = __dev_get_by_name(genl_info_net(info), portname);
 	if (!netdev) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return NULL;
 	}
 
-	pr_info("%s: netdev index is %d name is %s\n", __func__,
-			netdev->ifindex, netdev->name);
-
 	list_for_each_entry(port, &port_list, list) {
 		if (port->netdev == netdev) {
 			tsn_found = true;
@@ -440,7 +393,8 @@ struct tsn_port *tsn_init_check(struct genl_info *info, struct net_device **ndev
 	}
 
 	if (!tsn_found) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return NULL;
 	}
 
@@ -474,10 +428,10 @@ static int cmd_cb_streamid_set(struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_STREAM_IDENTIFY];
 
-	ret = NLA_PARSE_NESTED(sid, TSN_STREAMID_ATTR_MAX, na, cb_streamid_policy);
-	if (ret) {
+	ret = NLA_PARSE_NESTED(sid, TSN_STREAMID_ATTR_MAX,
+			       na, cb_streamid_policy);
+	if (ret)
 		return -EINVAL;
-	}
 
 	if (!sid[TSN_STREAMID_ATTR_INDEX])
 		return -EINVAL;
@@ -508,9 +462,12 @@ static int cmd_cb_streamid_set(struct genl_info *info)
 			return -EINVAL;
 		}
 
-		sidconf.para.nid.dmac = nla_get_u64(sid[TSN_STREAMID_ATTR_NDMAC]);
-		sidconf.para.nid.tagged = nla_get_u8(sid[TSN_STREAMID_ATTR_NTAGGED]);
-		sidconf.para.nid.vid = nla_get_u16(sid[TSN_STREAMID_ATTR_NVID]);
+		sidconf.para.nid.dmac =
+			nla_get_u64(sid[TSN_STREAMID_ATTR_NDMAC]);
+		sidconf.para.nid.tagged =
+			nla_get_u8(sid[TSN_STREAMID_ATTR_NTAGGED]);
+		sidconf.para.nid.vid =
+			nla_get_u16(sid[TSN_STREAMID_ATTR_NVID]);
 		break;
 	case STREAMID_SMAC_VLAN:
 		/* TODO: not supportted yet */
@@ -520,21 +477,26 @@ static int cmd_cb_streamid_set(struct genl_info *info)
 			return -EINVAL;
 		}
 
-		sidconf.para.sid.smac = nla_get_u64(sid[TSN_STREAMID_ATTR_SMAC]);
-		sidconf.para.sid.tagged = nla_get_u8(sid[TSN_STREAMID_ATTR_STAGGED]);
-		sidconf.para.sid.vid = nla_get_u16(sid[TSN_STREAMID_ATTR_SVID]);
+		sidconf.para.sid.smac =
+			nla_get_u64(sid[TSN_STREAMID_ATTR_SMAC]);
+		sidconf.para.sid.tagged =
+			nla_get_u8(sid[TSN_STREAMID_ATTR_STAGGED]);
+		sidconf.para.sid.vid =
+			nla_get_u16(sid[TSN_STREAMID_ATTR_SVID]);
 		break;
 	case STREAMID_DMAC_VLAN:
 
 	case STREAMID_IP:
 
 	default:
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (sid[TSN_STREAMID_ATTR_STREAM_HANDLE])
-		sidconf.handle = nla_get_s32(sid[TSN_STREAMID_ATTR_STREAM_HANDLE]);
+		sidconf.handle =
+			nla_get_s32(sid[TSN_STREAMID_ATTR_STREAM_HANDLE]);
 
 	if (sid[TSN_STREAMID_ATTR_IFOP])
 		sidconf.ifac_oport = nla_get_u32(sid[TSN_STREAMID_ATTR_IFOP]);
@@ -547,7 +509,8 @@ static int cmd_cb_streamid_set(struct genl_info *info)
 
 loaddev:
 	if (!tsnops->cb_streamid_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -EOPNOTSUPP;
 	}
 
@@ -598,7 +561,8 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_STREAM_IDENTIFY];
 
-	ret = NLA_PARSE_NESTED(sid, TSN_STREAMID_ATTR_MAX, na, cb_streamid_policy);
+	ret = NLA_PARSE_NESTED(sid, TSN_STREAMID_ATTR_MAX,
+			       na, cb_streamid_policy);
 	if (ret)
 		return -EINVAL;
 
@@ -608,19 +572,23 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 	sid_index = nla_get_u32(sid[TSN_STREAMID_ATTR_INDEX]);
 
 	if (!tsnops->cb_streamid_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
+		ret = -EINVAL;
+		goto exit;
 	} else {
 		valid = tsnops->cb_streamid_get(netdev, sid_index, &sidconf);
 		if (valid < 0) {
-			tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+			tsn_simple_reply(info, TSN_CMD_REPLY,
+					 netdev->name, -TSN_DEVRETERR);
 			return -1;
 		}
 	}
 
 	/* send back */
 	genlhdr = info->genlhdr;
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
+				NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -633,12 +601,13 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 
 	nla_put_u32(rep_skb, TSN_STREAMID_ATTR_INDEX, sid_index);
 
-	if (valid == 1)
+	if (valid == 1) {
 		nla_put_flag(rep_skb, TSN_STREAMID_ATTR_ENABLE);
-	else if (valid == 0)
+	} else if (valid == 0) {
 		nla_put_flag(rep_skb, TSN_STREAMID_ATTR_DISABLE);
-	else {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+	} else {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		goto err;
 	}
 
@@ -653,38 +622,53 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 
 	switch (sidconf.type) {
 	case STREAMID_NULL:
-		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_NDMAC, sidconf.para.nid.dmac);
-		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_NVID, sidconf.para.nid.vid);
-		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_NTAGGED, sidconf.para.nid.tagged);
+		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_NDMAC,
+			    sidconf.para.nid.dmac);
+		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_NVID,
+			    sidconf.para.nid.vid);
+		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_NTAGGED,
+			   sidconf.para.nid.tagged);
 		break;
 	case STREAMID_SMAC_VLAN:
-		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_SMAC, sidconf.para.sid.smac);
-		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_SVID, sidconf.para.sid.vid);
-		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_STAGGED, sidconf.para.sid.tagged);
+		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_SMAC,
+			    sidconf.para.sid.smac);
+		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_SVID,
+			    sidconf.para.sid.vid);
+		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_STAGGED,
+			   sidconf.para.sid.tagged);
 		break;
 	case STREAMID_DMAC_VLAN:
 	case STREAMID_IP:
 	default:
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		goto err;
 	}
 
-	if (tsnops->cb_streamid_counters_get == NULL) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+	if (!tsnops->cb_streamid_counters_get) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		goto err;
 	} else {
-		ret = tsnops->cb_streamid_counters_get(netdev, sid_index, &sidcounts);
+		ret = tsnops->cb_streamid_counters_get(netdev,
+							sid_index,
+							&sidcounts);
 		if (ret < 0) {
-			tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+			tsn_simple_reply(info, TSN_CMD_REPLY,
+					 netdev->name, -TSN_DEVRETERR);
 			goto err;
 		}
 	}
 
-	NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSI, sidcounts.per_stream.input);
-	NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSO, sidcounts.per_stream.output);
+	NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSI,
+		    sidcounts.per_stream.input);
+	NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSO,
+		    sidcounts.per_stream.output);
 	for (i = 0; i < 32; i++) {
-		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSPPI, sidcounts.per_streamport[i].input);
-		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSPPO, sidcounts.per_streamport[i].output);
+		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSPPI,
+			    sidcounts.per_streamport[i].input);
+		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSPPO,
+			    sidcounts.per_streamport[i].output);
 	}
 
 	nla_nest_end(rep_skb, sidattr);
@@ -703,7 +687,7 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 
 err:
 	nlmsg_free(rep_skb);
-
+exit:
 	return ret;
 }
 
@@ -722,7 +706,8 @@ static int cmb_cb_streamid_counters_get(struct genl_info *info)
 	return 0;
 }
 
-static int tsn_cb_streamid_counters_get(struct sk_buff *skb, struct genl_info *info)
+static int tsn_cb_streamid_counters_get(struct sk_buff *skb,
+					struct genl_info *info)
 {
 	if (info->attrs[TSN_ATTR_IFNAME]) {
 		cmb_cb_streamid_counters_get(info);
@@ -767,42 +752,49 @@ static int cmd_qci_sfi_set(struct genl_info *info)
 
 	sfi_handle = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_INDEX]);
 
-	if (sfi[TSN_QCI_SFI_ATTR_ENABLE])
+	if (sfi[TSN_QCI_SFI_ATTR_ENABLE]) {
 		enable = true;
-	else if (sfi[TSN_QCI_SFI_ATTR_DISABLE]) {
+	} else if (sfi[TSN_QCI_SFI_ATTR_DISABLE]) {
 		enable = false;
 		goto loaddrive;
 	} else {
 		pr_err("tsn: must provde ENABLE or DISABLE attribute.\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (!sfi[TSN_QCI_SFI_ATTR_GATE_ID]) {
 		pr_err("tsn: must provide stream gate index\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (!sfi[TSN_QCI_SFI_ATTR_STREAM_HANDLE])
 		sficonf.stream_handle_spec = -1;
 	else
-		sficonf.stream_handle_spec = nla_get_s32(sfi[TSN_QCI_SFI_ATTR_STREAM_HANDLE]);
+		sficonf.stream_handle_spec =
+			nla_get_s32(sfi[TSN_QCI_SFI_ATTR_STREAM_HANDLE]);
 
 	if (!sfi[TSN_QCI_SFI_ATTR_PRIO_SPEC])
 		sficonf.priority_spec = -1;
 	else
-		sficonf.priority_spec = nla_get_s8(sfi[TSN_QCI_SFI_ATTR_PRIO_SPEC]);
+		sficonf.priority_spec =
+			nla_get_s8(sfi[TSN_QCI_SFI_ATTR_PRIO_SPEC]);
 
-	sficonf.stream_gate_instance_id = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_GATE_ID]);
+	sficonf.stream_gate_instance_id =
+			nla_get_u32(sfi[TSN_QCI_SFI_ATTR_GATE_ID]);
 
 	if (sfi[TSN_QCI_SFI_ATTR_MAXSDU])
-		sficonf.stream_filter.maximum_sdu_size = nla_get_u16(sfi[TSN_QCI_SFI_ATTR_MAXSDU]);
+		sficonf.stream_filter.maximum_sdu_size =
+			nla_get_u16(sfi[TSN_QCI_SFI_ATTR_MAXSDU]);
 	else
 		sficonf.stream_filter.maximum_sdu_size = 0;
 
 	if (sfi[TSN_QCI_SFI_ATTR_FLOW_ID])
-		sficonf.stream_filter.flow_meter_instance_id = nla_get_s32(sfi[TSN_QCI_SFI_ATTR_FLOW_ID]);
+		sficonf.stream_filter.flow_meter_instance_id =
+			nla_get_s32(sfi[TSN_QCI_SFI_ATTR_FLOW_ID]);
 	else
 		sficonf.stream_filter.flow_meter_instance_id = -1;
 
@@ -814,13 +806,15 @@ static int cmd_qci_sfi_set(struct genl_info *info)
 
 loaddrive:
 	if (!tsnops->qci_sfi_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
 	}
 
 	tsnops->qci_sfi_set(netdev, sfi_handle, enable, &sficonf);
 
-	if (tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS))
+	if (tsn_simple_reply(info, TSN_CMD_REPLY,
+			     netdev->name, TSN_SUCCESS))
 		return -1;
 
 	return 0;
@@ -863,10 +857,10 @@ static int cmd_qci_sfi_get(struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_QCI_SFI];
 
-	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX, na, qci_sfi_policy);
-	if (ret) {
+	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX,
+			       na, qci_sfi_policy);
+	if (ret)
 		return -EINVAL;
-	}
 
 	if (!sfi[TSN_QCI_SFI_ATTR_INDEX])
 		return -EINVAL;
@@ -877,20 +871,24 @@ static int cmd_qci_sfi_get(struct genl_info *info)
 	memset(&sficount, 0, sizeof(struct tsn_qci_psfp_sfi_counters));
 
 	if (!tsnops->qci_sfi_get || !tsnops->qci_sfi_counters_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
+		ret = -EINVAL;
+		goto exit;
 	} else {
 		valid = tsnops->qci_sfi_get(netdev, sfi_handle, &sficonf);
 
 		if (valid < 0) {
-			tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+			tsn_simple_reply(info, TSN_CMD_REPLY,
+					 netdev->name, -TSN_DEVRETERR);
 			return -1;
 		}
 
 		tsnops->qci_sfi_counters_get(netdev, sfi_handle, &sficount);
 	}
 
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -899,7 +897,8 @@ static int cmd_qci_sfi_get(struct genl_info *info)
 
 	sfiattr = nla_nest_start(rep_skb, TSN_ATTR_QCI_SFI);
 	if (!sfiattr) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		ret = -EINVAL;
 		goto err;
 	}
@@ -911,28 +910,36 @@ static int cmd_qci_sfi_get(struct genl_info *info)
 	else
 		nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_DISABLE);
 
-	nla_put_s32(rep_skb, TSN_QCI_SFI_ATTR_STREAM_HANDLE, sficonf.stream_handle_spec);
-	nla_put_s8(rep_skb, TSN_QCI_SFI_ATTR_PRIO_SPEC, sficonf.priority_spec);
-	nla_put_u32(rep_skb, TSN_QCI_SFI_ATTR_GATE_ID, sficonf.stream_gate_instance_id);
+	nla_put_s32(rep_skb, TSN_QCI_SFI_ATTR_STREAM_HANDLE,
+		    sficonf.stream_handle_spec);
+	nla_put_s8(rep_skb, TSN_QCI_SFI_ATTR_PRIO_SPEC,
+		   sficonf.priority_spec);
+	nla_put_u32(rep_skb, TSN_QCI_SFI_ATTR_GATE_ID,
+		    sficonf.stream_gate_instance_id);
 
 	if (sficonf.stream_filter.maximum_sdu_size)
-		nla_put_u16(rep_skb, TSN_QCI_SFI_ATTR_MAXSDU, sficonf.stream_filter.maximum_sdu_size);
+		nla_put_u16(rep_skb, TSN_QCI_SFI_ATTR_MAXSDU,
+			    sficonf.stream_filter.maximum_sdu_size);
 	if (sficonf.stream_filter.flow_meter_instance_id >= 0)
-		nla_put_s32(rep_skb, TSN_QCI_SFI_ATTR_FLOW_ID, sficonf.stream_filter.flow_meter_instance_id);
+		nla_put_s32(rep_skb, TSN_QCI_SFI_ATTR_FLOW_ID,
+			    sficonf.stream_filter.flow_meter_instance_id);
 
 	if (sficonf.block_oversize_enable)
 		nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE);
 	if (sficonf.block_oversize)
 		nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_OVERSIZE);
 
-	nla_put(rep_skb, TSN_QCI_SFI_ATTR_COUNTERS, sizeof(struct tsn_qci_psfp_sfi_counters), &sficount);
+	nla_put(rep_skb, TSN_QCI_SFI_ATTR_COUNTERS,
+		sizeof(struct tsn_qci_psfp_sfi_counters), &sficount);
 
 	nla_nest_end(rep_skb, sfiattr);
 
 	return tsn_send_reply(rep_skb, info);
 err:
 	nlmsg_free(rep_skb);
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, -TSN_ATTRERR);
+exit:
 	return ret;
 }
 
@@ -972,10 +979,10 @@ static int cmd_qci_sfi_counters_get(struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_QCI_SFI];
 
-	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX, na, qci_sfi_policy);
-	if (ret) {
+	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX,
+			       na, qci_sfi_policy);
+	if (ret)
 		return -EINVAL;
-	}
 
 	if (!sfi[TSN_QCI_SFI_ATTR_INDEX])
 		return -EINVAL;
@@ -984,17 +991,20 @@ static int cmd_qci_sfi_counters_get(struct genl_info *info)
 
 	memset(&sficount, 0, sizeof(struct tsn_qci_psfp_sfi_counters));
 	if (!tsnops->qci_sfi_counters_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = tsnops->qci_sfi_counters_get(netdev, sfi_handle, &sficount);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
 
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
+				NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -1011,7 +1021,8 @@ static int cmd_qci_sfi_counters_get(struct genl_info *info)
 
 	tsnops->qci_sfi_counters_get(netdev, sfi_handle, &sficount);
 
-	nla_put(rep_skb, TSN_QCI_SFI_ATTR_COUNTERS, sizeof(struct tsn_qci_psfp_sfi_counters), &sficount);
+	nla_put(rep_skb, TSN_QCI_SFI_ATTR_COUNTERS,
+		sizeof(struct tsn_qci_psfp_sfi_counters), &sficount);
 
 	nla_nest_end(rep_skb, sfiattr);
 
@@ -1055,21 +1066,25 @@ static int cmd_qci_sgi_set(struct genl_info *info)
 	memset(&sgi, 0, sizeof(struct tsn_qci_psfp_sgi_conf));
 
 	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_QCI_SGI];
 
-	ret = NLA_PARSE_NESTED(sgia, TSN_QCI_SGI_ATTR_MAX, na, qci_sgi_policy);
+	ret = NLA_PARSE_NESTED(sgia, TSN_QCI_SGI_ATTR_MAX,
+			       na, qci_sgi_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (sgia[TSN_QCI_SGI_ATTR_ENABLE] && sgia[TSN_QCI_SGI_ATTR_DISABLE]) {
 		pr_err("tsn: enable or disable?\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -1;
 	}
 
@@ -1105,62 +1120,74 @@ static int cmd_qci_sgi_set(struct genl_info *info)
 		int count = 0;
 
 		na = sgia[TSN_QCI_SGI_ATTR_ADMINENTRY];
-		ret = NLA_PARSE_NESTED(admin, TSN_SGI_ATTR_CTRL_MAX, na, qci_sgi_ctrl_policy);
+		ret = NLA_PARSE_NESTED(admin, TSN_SGI_ATTR_CTRL_MAX,
+				       na, qci_sgi_ctrl_policy);
 
 		/* Other parameters in admin control */
 		if (admin[TSN_SGI_ATTR_CTRL_INITSTATE])
 			sgi.admin.gate_states = 1;
 
 		if (admin[TSN_SGI_ATTR_CTRL_CYTIME])
-			sgi.admin.cycle_time = nla_get_u32(admin[TSN_SGI_ATTR_CTRL_CYTIME]);
+			sgi.admin.cycle_time =
+				nla_get_u32(admin[TSN_SGI_ATTR_CTRL_CYTIME]);
 
 		if (admin[TSN_SGI_ATTR_CTRL_CYTIMEEX])
-			sgi.admin.cycle_time_extension = nla_get_u32(admin[TSN_SGI_ATTR_CTRL_CYTIMEEX]);
+			sgi.admin.cycle_time_extension =
+				nla_get_u32(admin[TSN_SGI_ATTR_CTRL_CYTIMEEX]);
 
 		if (admin[TSN_SGI_ATTR_CTRL_BTIME])
-			sgi.admin.base_time = nla_get_u64(admin[TSN_SGI_ATTR_CTRL_BTIME]);
+			sgi.admin.base_time =
+				nla_get_u64(admin[TSN_SGI_ATTR_CTRL_BTIME]);
 
 		if (admin[TSN_SGI_ATTR_CTRL_INITIPV])
-			sgi.admin.init_ipv = nla_get_s8(admin[TSN_SGI_ATTR_CTRL_INITIPV]);
+			sgi.admin.init_ipv =
+				nla_get_s8(admin[TSN_SGI_ATTR_CTRL_INITIPV]);
 		else
 			sgi.admin.init_ipv = -1;
 
 		if (admin[TSN_SGI_ATTR_CTRL_LEN]) {
-			sgi.admin.control_list_length = nla_get_u8(admin[TSN_SGI_ATTR_CTRL_LEN]);
+			sgi.admin.control_list_length =
+				nla_get_u8(admin[TSN_SGI_ATTR_CTRL_LEN]);
 			listcount = sgi.admin.control_list_length;
 		}
 
-		if (!listcount) {
-			pr_info("tsn: no TSN_SGI_ATTR_CTRL_LEN attribute, length is 0\n");
+		if (!listcount)
 			goto loaddev;
-		}
 
-		gcl = (struct tsn_qci_psfp_gcl *)kmalloc(listcount *
-					 sizeof(struct tsn_qci_psfp_gcl), GFP_KERNEL);
+		gcl = kmalloc_array(listcount, sizeof(*gcl), GFP_KERNEL);
 
 		memset(gcl, 0, listcount * sizeof(struct tsn_qci_psfp_gcl));
 
-		/* Check the whole admin attrs, checkout the TSN_SGI_ATTR_CTRL_GCLENTRY attributes */
+		/* Check the whole admin attrs,
+		 * checkout the TSN_SGI_ATTR_CTRL_GCLENTRY attributes
+		 */
 		nla_for_each_nested(entry, na, rem) {
 			struct nlattr *gcl_entry[TSN_SGI_ATTR_GCL_MAX + 1];
+			struct nlattr *ti, *om;
 
 			if (nla_type(entry) != TSN_SGI_ATTR_CTRL_GCLENTRY)
 				continue;
 
 			/* parse each TSN_SGI_ATTR_CTRL_GCLENTRY */
-			ret = NLA_PARSE_NESTED(gcl_entry, TSN_SGI_ATTR_GCL_MAX, entry, qci_sgi_gcl_policy);
+			ret = NLA_PARSE_NESTED(gcl_entry, TSN_SGI_ATTR_GCL_MAX,
+					       entry, qci_sgi_gcl_policy);
 			/* Parse gate control list */
 			if (gcl_entry[TSN_SGI_ATTR_GCL_GATESTATE])
 				(gcl + count)->gate_state = 1;
 
 			if (gcl_entry[TSN_SGI_ATTR_GCL_IPV])
-				(gcl + count)->ipv = nla_get_s8(gcl_entry[TSN_SGI_ATTR_GCL_IPV]);
+				(gcl + count)->ipv =
+				 nla_get_s8(gcl_entry[TSN_SGI_ATTR_GCL_IPV]);
 
-			if (gcl_entry[TSN_SGI_ATTR_GCL_INTERVAL])
-				(gcl + count)->time_interval = nla_get_u32(gcl_entry[TSN_SGI_ATTR_GCL_INTERVAL]);
+			if (gcl_entry[TSN_SGI_ATTR_GCL_INTERVAL]) {
+				ti = gcl_entry[TSN_SGI_ATTR_GCL_INTERVAL];
+				(gcl + count)->time_interval = nla_get_u32(ti);
+			}
 
-			if (gcl_entry[TSN_SGI_ATTR_GCL_OCTMAX])
-				(gcl + count)->octet_max = nla_get_u32(gcl_entry[TSN_SGI_ATTR_GCL_OCTMAX]);
+			if (gcl_entry[TSN_SGI_ATTR_GCL_OCTMAX]) {
+				om = gcl_entry[TSN_SGI_ATTR_GCL_OCTMAX];
+				(gcl + count)->octet_max = nla_get_u32(om);
+			}
 
 			count++;
 
@@ -1169,33 +1196,35 @@ static int cmd_qci_sgi_set(struct genl_info *info)
 		}
 
 		if (count < listcount) {
-			tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-			pr_err("tsn: gate list count less than TSN_SGI_ATTR_CTRL_LEN\n");
-			if (gcl != NULL)
-				kfree(gcl);
+			tsn_simple_reply(info, TSN_CMD_REPLY,
+					 netdev->name, -TSN_ATTRERR);
+			pr_err("tsn: count less than TSN_SGI_ATTR_CTRL_LEN\n");
+			kfree(gcl);
 			return -EINVAL;
 		}
 
-	} else
+	} else {
 		pr_info("tsn: no admin list parameters setting\n");
+	}
 
 loaddev:
 	if (!tsnops->qci_sgi_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
-		if (gcl != NULL)
-			kfree(gcl);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
+		kfree(gcl);
 		return -EINVAL;
 	}
 
 	sgi.admin.gcl = gcl;
 
 	ret = tsnops->qci_sgi_set(netdev, sgi_handle, &sgi);
-	if (gcl != NULL)
-		kfree(gcl);
+	kfree(gcl);
 	if (!ret)
-		return tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+		return tsn_simple_reply(info, TSN_CMD_REPLY,
+					netdev->name, TSN_SUCCESS);
 
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, -TSN_DEVRETERR);
 	return -1;
 }
 
@@ -1231,21 +1260,23 @@ static int cmd_qci_sgi_get(struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input \n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: no sgi handle input\n");
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_QCI_SGI];
 
-	ret = NLA_PARSE_NESTED(sgi, TSN_QCI_SGI_ATTR_MAX, na, qci_sgi_policy);
-	if (ret) {
+	ret = NLA_PARSE_NESTED(sgi, TSN_QCI_SGI_ATTR_MAX,
+			       na, qci_sgi_policy);
+	if (ret)
 		return -EINVAL;
-	}
 
 	if (!sgi[TSN_QCI_SGI_ATTR_INDEX]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input \n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: no sgi handle input\n");
 		return -EINVAL;
 	}
 
@@ -1257,18 +1288,21 @@ static int cmd_qci_sgi_get(struct genl_info *info)
 	memset(&sgiadmin, 0, sizeof(struct tsn_qci_psfp_sgi_conf));
 
 	if (!tsnops->qci_sgi_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = tsnops->qci_sgi_get(netdev, sgi_handle, &sgiadmin);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -1;
 	}
 
 	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -1311,18 +1345,22 @@ static int cmd_qci_sgi_get(struct genl_info *info)
 	if (sgiadmin.admin.gate_states)
 		nla_put_flag(rep_skb, TSN_SGI_ATTR_CTRL_INITSTATE);
 
-	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIME, sgiadmin.admin.cycle_time);
+	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIME,
+		    sgiadmin.admin.cycle_time);
 
-	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIMEEX, sgiadmin.admin.cycle_time_extension);
-	NLA_PUT_U64(rep_skb, TSN_SGI_ATTR_CTRL_BTIME, sgiadmin.admin.base_time);
-	nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_INITIPV, sgiadmin.admin.init_ipv);
+	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIMEEX,
+		    sgiadmin.admin.cycle_time_extension);
+	NLA_PUT_U64(rep_skb, TSN_SGI_ATTR_CTRL_BTIME,
+		    sgiadmin.admin.base_time);
+	nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_INITIPV,
+		   sgiadmin.admin.init_ipv);
 
 	listcount = sgiadmin.admin.control_list_length;
 	if (!listcount)
 		goto out1;
 
 	if (!sgiadmin.admin.gcl) {
-		pr_err("error: list lenghth is not zero, but no gate control list\n");
+		pr_err("error: no gate control list\n");
 		ret = -TSN_DEVRETERR;
 		goto err;
 	}
@@ -1334,8 +1372,8 @@ static int cmd_qci_sgi_get(struct genl_info *info)
 		s8 ipv;
 		u32 ti, omax;
 
-		if ((gcl + i) == NULL) {
-			pr_err("error: list count larger than gate list buffer can get\n");
+		if (!(gcl + i)) {
+			pr_err("error: list count too big\n");
 			ret = -TSN_DEVRETERR;
 			kfree(sgiadmin.admin.gcl);
 			goto err;
@@ -1410,21 +1448,23 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input \n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: no sgi handle input\n");
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_QCI_SGI];
 
-	ret = NLA_PARSE_NESTED(sgi, TSN_QCI_SGI_ATTR_MAX, na, qci_sgi_policy);
-	if (ret) {
+	ret = NLA_PARSE_NESTED(sgi, TSN_QCI_SGI_ATTR_MAX,
+			       na, qci_sgi_policy);
+	if (ret)
 		return -EINVAL;
-	}
 
 	if (!sgi[TSN_QCI_SGI_ATTR_INDEX]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input \n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: no sgi handle input\n");
 		return -EINVAL;
 	}
 
@@ -1436,18 +1476,21 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 	memset(&sgistat, 0, sizeof(struct tsn_psfp_sgi_status));
 
 	if (!tsnops->qci_sgi_status_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	valid = tsnops->qci_sgi_status_get(netdev, sgi_handle, &sgistat);
 	if (valid < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -1;
 	}
 
 	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -1467,10 +1510,14 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 	else
 		nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_DISABLE);
 
-	nla_put_u32(rep_skb, TSN_QCI_SGI_ATTR_TICKG, sgistat.tick_granularity);
-	NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CCTIME, sgistat.config_change_time);
-	NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CUTIME, sgistat.current_time);
-	NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CCERROR, sgistat.config_change_error);
+	nla_put_u32(rep_skb, TSN_QCI_SGI_ATTR_TICKG,
+		    sgistat.tick_granularity);
+	NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CCTIME,
+		    sgistat.config_change_time);
+	NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CUTIME,
+		    sgistat.current_time);
+	NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CCERROR,
+		    sgistat.config_change_error);
 
 	if (sgistat.config_pending)
 		nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_CPENDING);
@@ -1483,19 +1530,23 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 	if (sgistat.oper.gate_states)
 		nla_put_flag(rep_skb, TSN_SGI_ATTR_CTRL_INITSTATE);
 
-	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIME, sgistat.oper.cycle_time);
+	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIME,
+		    sgistat.oper.cycle_time);
 
-	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIMEEX, sgistat.oper.cycle_time_extension);
-	NLA_PUT_U64(rep_skb, TSN_SGI_ATTR_CTRL_BTIME, sgistat.oper.base_time);
-	nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_INITIPV, sgistat.oper.init_ipv);
+	nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIMEEX,
+		    sgistat.oper.cycle_time_extension);
+	NLA_PUT_U64(rep_skb, TSN_SGI_ATTR_CTRL_BTIME,
+		    sgistat.oper.base_time);
+	nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_INITIPV,
+		   sgistat.oper.init_ipv);
 
 	/* Loop list */
 	listcount = sgistat.oper.control_list_length;
 	if (!listcount)
 		goto out1;
 
-	if (sgistat.oper.gcl == NULL) {
-		pr_err("error: list lenghth is not zero, but no gate control list\n");
+	if (!sgistat.oper.gcl) {
+		pr_err("error: list lenghth is not zero!\n");
 		ret = -TSN_DEVRETERR;
 		goto err;
 	}
@@ -1507,8 +1558,8 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 		s8 ipv;
 		u32 ti, omax;
 
-		if ((gcl + i) == NULL) {
-			pr_err("error: list count larger than gate list buffer can get\n");
+		if (!(gcl + i)) {
+			pr_err("error: list count too big\n");
 			ret = -TSN_DEVRETERR;
 			kfree(sgistat.oper.gcl);
 			goto err;
@@ -1529,8 +1580,6 @@ static int cmd_qci_sgi_status_get(struct genl_info *info)
 		nla_put_u32(rep_skb, TSN_SGI_ATTR_GCL_INTERVAL, ti);
 		nla_put_u32(rep_skb, TSN_SGI_ATTR_GCL_OCTMAX, omax);
 
-		pr_info("tsn: gate: %d  ipv: %d  time: %d octet: %d\n", (gcl + i)->gate_state, ipv, ti, omax);
-
 		/* End operation entry down 3 */
 		nla_nest_end(rep_skb, sglattr);
 	}
@@ -1631,13 +1680,15 @@ static int cmd_qci_fmi_set(struct genl_info *info)
 loaddev:
 
 	if (!tsnops->qci_fmi_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
 	}
 
 	tsnops->qci_fmi_set(netdev, index, enable, &fmiconf);
 
-	if (tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS))
+	if (tsn_simple_reply(info, TSN_CMD_REPLY,
+			     netdev->name, TSN_SUCCESS))
 		return -1;
 
 	return 0;
@@ -1677,7 +1728,8 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 
 	na = info->attrs[TSN_ATTR_QCI_FMI];
 
-	ret = NLA_PARSE_NESTED(fmi, TSN_QCI_FMI_ATTR_MAX, na, qci_fmi_policy);
+	ret = NLA_PARSE_NESTED(fmi, TSN_QCI_FMI_ATTR_MAX,
+			       na, qci_fmi_policy);
 	if (ret) {
 		pr_info("tsn: parse value TSN_QCI_FMI_ATTR_MAX  error.");
 		return -EINVAL;
@@ -1693,7 +1745,8 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	memset(&counters, 0, sizeof(struct tsn_qci_psfp_fmi_counters));
 
 	if (!tsnops->qci_fmi_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
 	}
 
@@ -1702,7 +1755,8 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	genlhdr = info->genlhdr;
 
 	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -1743,7 +1797,8 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	return tsn_send_reply(rep_skb, info);
 
 	nlmsg_free(rep_skb);
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, -TSN_ATTRERR);
 	return -1;
 }
 
@@ -1760,7 +1815,9 @@ static int tsn_qci_fmi_get(struct sk_buff *skb, struct genl_info *info)
 static int cmd_qbv_set(struct genl_info *info)
 {
 	struct nlattr *na, *na1;
-	struct nlattr *qbv_table, *qbv[TSN_QBV_ATTR_MAX + 1], *qbvctrl[TSN_QBV_ATTR_CTRL_MAX + 1];
+	struct nlattr *qbv_table;
+	struct nlattr *qbv[TSN_QBV_ATTR_MAX + 1];
+	struct nlattr *qbvctrl[TSN_QBV_ATTR_CTRL_MAX + 1];
 	int rem;
 	int ret = 0;
 	struct net_device *netdev;
@@ -1784,42 +1841,45 @@ static int cmd_qbv_set(struct genl_info *info)
 	na = info->attrs[TSN_ATTR_QBV];
 
 	ret = NLA_PARSE_NESTED(qbv, TSN_QBV_ATTR_MAX, na, qbv_policy);
-	if (ret) {
+	if (ret)
 		return -EINVAL;
-	}
 
-	if (qbv[TSN_QBV_ATTR_ENABLE]) {
+	if (qbv[TSN_QBV_ATTR_ENABLE])
 		qbvconfig.gate_enabled = 1;
-	} else {
+	else
 		goto setdrive;
-	}
 
-	if (qbv[TSN_QBV_ATTR_CONFIGCHANGE]) {
+	if (qbv[TSN_QBV_ATTR_CONFIGCHANGE])
 		qbvconfig.config_change = 1;
-	}
 
 	if (!qbv[TSN_QBV_ATTR_ADMINENTRY]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -1;
 	}
 
 	na1 = qbv[TSN_QBV_ATTR_ADMINENTRY];
-	NLA_PARSE_NESTED(qbvctrl, TSN_QBV_ATTR_CTRL_MAX, na1, qbv_ctrl_policy);
+	NLA_PARSE_NESTED(qbvctrl, TSN_QBV_ATTR_CTRL_MAX,
+			 na1, qbv_ctrl_policy);
 
 	if (qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIME]) {
-		qbvconfig.admin.cycle_time = nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIME]);
+		qbvconfig.admin.cycle_time =
+			nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIME]);
 	}
 
 	if (qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIMEEXT]) {
-		qbvconfig.admin.cycle_time_extension = nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIMEEXT]);
+		qbvconfig.admin.cycle_time_extension =
+			nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIMEEXT]);
 	}
 
 	if (qbvctrl[TSN_QBV_ATTR_CTRL_BASETIME]) {
-		qbvconfig.admin.base_time = nla_get_u64(qbvctrl[TSN_QBV_ATTR_CTRL_BASETIME]);
+		qbvconfig.admin.base_time =
+			nla_get_u64(qbvctrl[TSN_QBV_ATTR_CTRL_BASETIME]);
 	}
 
 	if (qbvctrl[TSN_QBV_ATTR_CTRL_GATESTATE]) {
-		qbvconfig.admin.gate_states = nla_get_u8(qbvctrl[TSN_QBV_ATTR_CTRL_GATESTATE]);
+		qbvconfig.admin.gate_states =
+			nla_get_u8(qbvctrl[TSN_QBV_ATTR_CTRL_GATESTATE]);
 	}
 
 	if (qbvctrl[TSN_QBV_ATTR_CTRL_LISTCOUNT]) {
@@ -1829,7 +1889,9 @@ static int cmd_qbv_set(struct genl_info *info)
 
 		qbvconfig.admin.control_list_length = listcount;
 
-		gatelist = (struct tsn_qbv_entry *)kmalloc(listcount * sizeof(struct tsn_qbv_entry), GFP_KERNEL);
+		gatelist = kmalloc_array(listcount,
+					 sizeof(*gatelist),
+					 GFP_KERNEL);
 
 		nla_for_each_nested(qbv_table, na1, rem) {
 			struct nlattr *qbv_entry[TSN_QBV_ATTR_ENTRY_MAX + 1];
@@ -1837,36 +1899,40 @@ static int cmd_qbv_set(struct genl_info *info)
 			if (nla_type(qbv_table) != TSN_QBV_ATTR_CTRL_LISTENTRY)
 				continue;
 
-			ret = NLA_PARSE_NESTED(qbv_entry, TSN_QBV_ATTR_ENTRY_MAX, qbv_table, qbv_entry_policy);
-			if (ret) {
+			ret = NLA_PARSE_NESTED(qbv_entry,
+					       TSN_QBV_ATTR_ENTRY_MAX,
+					       qbv_table, qbv_entry_policy);
+			if (ret)
 				return -EINVAL;
-			}
 
-			(gatelist + count)->gate_state = nla_get_u8(qbv_entry[TSN_QBV_ATTR_ENTRY_GC]);
-			(gatelist + count)->time_interval = nla_get_u32(qbv_entry[TSN_QBV_ATTR_ENTRY_TM]);
+			(gatelist + count)->gate_state =
+				nla_get_u8(qbv_entry[TSN_QBV_ATTR_ENTRY_GC]);
+			(gatelist + count)->time_interval =
+				nla_get_u32(qbv_entry[TSN_QBV_ATTR_ENTRY_TM]);
 			count++;
 			if (count > listcount)
 				break;
 		}
 	}
 
-	if (gatelist != NULL)
+	if (gatelist)
 		qbvconfig.admin.control_list = gatelist;
 
 setdrive:
 	if (!tsnops->qbv_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		goto err;
 	}
 
 	ret = tsnops->qbv_set(netdev, &qbvconfig);
 
 	/* send back */
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 
 err:
-	if (gatelist != NULL)
-		kfree(gatelist);
+	kfree(gatelist);
 
 	return ret;
 }
@@ -1904,17 +1970,20 @@ static int cmd_qbv_get(struct genl_info *info)
 	memset(&qbvconf, 0, sizeof(struct tsn_qbv_conf));
 
 	if (!tsnops->qbv_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = tsnops->qbv_get(netdev, &qbvconf);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return ret;
 	}
 
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -1927,17 +1996,20 @@ static int cmd_qbv_get(struct genl_info *info)
 
 	qbvadminattr = nla_nest_start(rep_skb, TSN_QBV_ATTR_ADMINENTRY);
 
-	if (qbvconf.admin.control_list != NULL) {
-		/* TODO: should add a nested attribute wrap the admin/oper para list */
+	if (qbvconf.admin.control_list) {
 		len = qbvconf.admin.control_list_length;
 		nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_LISTCOUNT, len);
 
 		for (i = 0; i < len; i++) {
 			struct nlattr *qbv_table;
-			u8 gs = (qbvconf.admin.control_list + i)->gate_state;
-			u32 tp = (qbvconf.admin.control_list + i)->time_interval;
+			u8 gs;
+			u32 tp;
+
+			gs = (qbvconf.admin.control_list + i)->gate_state;
+			tp = (qbvconf.admin.control_list + i)->time_interval;
 
-			qbv_table = nla_nest_start(rep_skb, TSN_QBV_ATTR_CTRL_LISTENTRY);
+			qbv_table = nla_nest_start(rep_skb,
+						   TSN_QBV_ATTR_CTRL_LISTENTRY);
 
 			nla_put_u32(rep_skb, TSN_QBV_ATTR_ENTRY_ID, i);
 			nla_put_u8(rep_skb, TSN_QBV_ATTR_ENTRY_GC, gs);
@@ -1946,21 +2018,26 @@ static int cmd_qbv_get(struct genl_info *info)
 		}
 
 		if (qbvconf.admin.gate_states)
-			nla_put_u8(rep_skb, TSN_QBV_ATTR_CTRL_GATESTATE, qbvconf.admin.gate_states);
+			nla_put_u8(rep_skb, TSN_QBV_ATTR_CTRL_GATESTATE,
+				   qbvconf.admin.gate_states);
 
 		if (qbvconf.admin.cycle_time)
-			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIME, qbvconf.admin.cycle_time);
+			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIME,
+				    qbvconf.admin.cycle_time);
 
 		if (qbvconf.admin.cycle_time_extension)
-			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIMEEXT, qbvconf.admin.cycle_time_extension);
+			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIMEEXT,
+				    qbvconf.admin.cycle_time_extension);
 
 		if (qbvconf.admin.base_time)
-			NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME, qbvconf.admin.base_time);
+			NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME,
+				    qbvconf.admin.base_time);
 
 		kfree(qbvconf.admin.control_list);
 
-	} else
+	} else {
 		pr_info("tsn: error get administrator data.");
+	}
 
 	nla_nest_end(rep_skb, qbvadminattr);
 
@@ -2005,17 +2082,20 @@ static int cmd_qbv_status_get(struct genl_info *info)
 	memset(&qbvstatus, 0, sizeof(struct tsn_qbv_status));
 
 	if (!tsnops->qbv_get_status) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = tsnops->qbv_get_status(netdev, &qbvstatus);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return ret;
 	}
 
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -2028,15 +2108,19 @@ static int cmd_qbv_status_get(struct genl_info *info)
 
 	qbvoperattr = nla_nest_start(rep_skb, TSN_QBV_ATTR_OPERENTRY);
 
-	if (qbvstatus.oper.control_list != NULL) {
+	if (qbvstatus.oper.control_list) {
 		len = qbvstatus.oper.control_list_length;
 		nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_LISTCOUNT, len);
 		for (i = 0; i < len; i++) {
 			struct nlattr *qbv_table;
-			u8 gs = (qbvstatus.oper.control_list + i)->gate_state;
-			u32 tp = (qbvstatus.oper.control_list + i)->time_interval;
+			u8 gs;
+			u32 tp;
 
-			qbv_table = nla_nest_start(rep_skb, TSN_QBV_ATTR_CTRL_LISTENTRY);
+			gs = (qbvstatus.oper.control_list + i)->gate_state;
+			tp = (qbvstatus.oper.control_list + i)->time_interval;
+
+			qbv_table = nla_nest_start(rep_skb,
+						   TSN_QBV_ATTR_CTRL_LISTENTRY);
 
 			nla_put_u32(rep_skb, TSN_QBV_ATTR_ENTRY_ID, i);
 			nla_put_u8(rep_skb, TSN_QBV_ATTR_ENTRY_GC, gs);
@@ -2045,16 +2129,20 @@ static int cmd_qbv_status_get(struct genl_info *info)
 		}
 
 		if (qbvstatus.oper.gate_states)
-			nla_put_u8(rep_skb, TSN_QBV_ATTR_CTRL_GATESTATE, qbvstatus.oper.gate_states);
+			nla_put_u8(rep_skb, TSN_QBV_ATTR_CTRL_GATESTATE,
+				   qbvstatus.oper.gate_states);
 
 		if (qbvstatus.oper.cycle_time)
-			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIME, qbvstatus.oper.cycle_time);
+			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIME,
+				    qbvstatus.oper.cycle_time);
 
 		if (qbvstatus.oper.cycle_time_extension)
-			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIMEEXT, qbvstatus.oper.cycle_time_extension);
+			nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIMEEXT,
+				    qbvstatus.oper.cycle_time_extension);
 
 		if (qbvstatus.oper.base_time)
-			NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME, qbvstatus.oper.base_time);
+			NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME,
+				    qbvstatus.oper.base_time);
 
 		kfree(qbvstatus.oper.control_list);
 	} else {
@@ -2064,22 +2152,27 @@ static int cmd_qbv_status_get(struct genl_info *info)
 	nla_nest_end(rep_skb, qbvoperattr);
 
 	if (qbvstatus.config_change_time)
-		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGETIME, qbvstatus.config_change_time);
+		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGETIME,
+			    qbvstatus.config_change_time);
 
 	if (qbvstatus.tick_granularity)
-		nla_put_u32(rep_skb, TSN_QBV_ATTR_GRANULARITY, qbvstatus.tick_granularity);
+		nla_put_u32(rep_skb, TSN_QBV_ATTR_GRANULARITY,
+			    qbvstatus.tick_granularity);
 
 	if (qbvstatus.current_time)
-		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CURRENTTIME, qbvstatus.current_time);
+		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CURRENTTIME,
+			    qbvstatus.current_time);
 
 	if (qbvstatus.config_pending)
 		nla_put_flag(rep_skb, TSN_QBV_ATTR_CONFIGPENDING);
 
 	if (qbvstatus.config_change_error)
-		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGEERROR, qbvstatus.config_change_error);
+		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGEERROR,
+			    qbvstatus.config_change_error);
 
 	if (qbvstatus.supported_list_max)
-		nla_put_u32(rep_skb, TSN_QBV_ATTR_LISTMAX, qbvstatus.supported_list_max);
+		nla_put_u32(rep_skb, TSN_QBV_ATTR_LISTMAX,
+			    qbvstatus.supported_list_max);
 
 	nla_nest_end(rep_skb, qbv);
 
@@ -2090,17 +2183,17 @@ static int cmd_qbv_status_get(struct genl_info *info)
 
 static int tsn_qbv_status_get(struct sk_buff *skb, struct genl_info *info)
 {
-	if (info->attrs[TSN_ATTR_IFNAME]) {
+	if (info->attrs[TSN_ATTR_IFNAME])
 		cmd_qbv_status_get(info);
-	}
+
 	return 0;
 }
 
 static int tsn_qbv_get(struct sk_buff *skb, struct genl_info *info)
 {
-	if (info->attrs[TSN_ATTR_IFNAME]) {
+	if (info->attrs[TSN_ATTR_IFNAME])
 		cmd_qbv_get(info);
-	}
+
 	return 0;
 }
 
@@ -2121,50 +2214,58 @@ static int tsn_cbs_set(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBS]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_CBS];
 
 	if (!tsnops->cbs_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = NLA_PARSE_NESTED(cbsa, TSN_CBS_ATTR_MAX, na, cbs_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (!cbsa[TSN_CBS_ATTR_TC_INDEX]) {
-		pr_err("tsn: no TSN_CBS_ATTR_TC_INDEX input \n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: no TSN_CBS_ATTR_TC_INDEX input\n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 	tc = nla_get_u8(cbsa[TSN_CBS_ATTR_TC_INDEX]);
 
-
 	if (!cbsa[TSN_CBS_ATTR_BW]) {
-		pr_err("tsn: no TSN_CBS_ATTR_BW input \n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: no TSN_CBS_ATTR_BW input\n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	bw = nla_get_u8(cbsa[TSN_CBS_ATTR_BW]);
 	if (bw > 100) {
-		pr_err("tsn: TSN_CBS_ATTR_BW isn't in the range of 0~100 \n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: TSN_CBS_ATTR_BW isn't in the range of 0~100\n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	ret = tsnops->cbs_set(netdev, tc, bw);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 	return 0;
 }
 
@@ -2187,12 +2288,14 @@ static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBS]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (!tsnops->cbs_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
@@ -2200,7 +2303,8 @@ static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
 	ret = NLA_PARSE_NESTED(cbsa, TSN_CBS_ATTR_MAX, na, cbs_policy);
 	if (ret) {
 		pr_err("tsn: parse value TSN_CBS_ATTR_MAX error.");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2209,7 +2313,7 @@ static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
 
 	/* Form netlink reply data */
 	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
-			NLMSG_ALIGN(MAX_ATTR_SIZE));
+				NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -2221,8 +2325,9 @@ static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
 		return -EMSGSIZE;
 
 	if (!cbsa[TSN_CBS_ATTR_TC_INDEX]) {
-		pr_err("tsn: must to specify the TSN_CBS_ATTR_TC_INDEX attribute\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		pr_err("tsn: must to specify the TSN_CBS_ATTR_TC_INDEX\n");
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 	tc = nla_get_u8(cbsa[TSN_CBS_ATTR_TC_INDEX]);
@@ -2230,7 +2335,8 @@ static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
 	ret = tsnops->cbs_get(netdev, tc);
 	if (ret < 0) {
 		pr_err("tsn: cbs_get return error\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2247,7 +2353,7 @@ static int cmd_qbu_set(struct genl_info *info)
 	struct net_device *netdev;
 	const struct tsn_ops *tsnops;
 	int ret;
-	u8 preemptable = 0;
+	u8 preemptible = 0;
 	struct tsn_port *port;
 
 	port = tsn_init_check(info, &netdev);
@@ -2257,7 +2363,8 @@ static int cmd_qbu_set(struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_QBU]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2265,36 +2372,38 @@ static int cmd_qbu_set(struct genl_info *info)
 
 	ret = NLA_PARSE_NESTED(qbua, TSN_QBU_ATTR_MAX, na, qbu_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (qbua[TSN_QBU_ATTR_ADMIN_STATE])
-		preemptable = nla_get_u8(qbua[TSN_QBU_ATTR_ADMIN_STATE]);
+		preemptible = nla_get_u8(qbua[TSN_QBU_ATTR_ADMIN_STATE]);
 	else
-		pr_info("Disable Qbu since no preemptable TSN_QBU_ATTR_ADMIN_STATE config!\n");
+		pr_info("No preemptible TSN_QBU_ATTR_ADMIN_STATE config!\n");
 
 	if (!tsnops->qbu_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
 	}
 
-	ret = tsnops->qbu_set(netdev, preemptable);
+	ret = tsnops->qbu_set(netdev, preemptible);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
 
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 	return 0;
 }
 
 static int tsn_qbu_set(struct sk_buff *skb, struct genl_info *info)
 {
-	pr_info("tsn_qbu_set receive message\n");
-	if (info->attrs[TSN_ATTR_IFNAME]) {
+	if (info->attrs[TSN_ATTR_IFNAME])
 		return cmd_qbu_set(info);
-	}
 
 	return -1;
 }
@@ -2322,18 +2431,21 @@ static int cmd_qbu_get_status(struct genl_info *info)
 	memset(&pps, 0, sizeof(struct tsn_preempt_status));
 
 	if (!tsnops->qbu_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = tsnops->qbu_get(netdev, &pps);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -1;
 	}
 
 	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -2358,10 +2470,8 @@ static int cmd_qbu_get_status(struct genl_info *info)
 
 static int tsn_qbu_get_status(struct sk_buff *skb, struct genl_info *info)
 {
-	pr_info("tsn_qbu_get_status receive message\n");
-	if (info->attrs[TSN_ATTR_IFNAME]) {
+	if (info->attrs[TSN_ATTR_IFNAME])
 		return cmd_qbu_get_status(info);
-	}
 
 	return -1;
 }
@@ -2385,7 +2495,8 @@ static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
 	memset(&tsd, 0, sizeof(struct tsn_tsd));
 
 	if (!info->attrs[TSN_ATTR_TSD]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2393,29 +2504,32 @@ static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
 
 	ret = NLA_PARSE_NESTED(ntsd, TSN_TSD_ATTR_MAX, na, tsd_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (!tsnops->tsd_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
 	}
 
 	if (nla_get_flag(ntsd[TSN_TSD_ATTR_DISABLE])) {
 		tsd.enable = false;
 	} else {
-		if (ntsd[TSN_TSD_ATTR_PERIOD]) {
+		if (ntsd[TSN_TSD_ATTR_PERIOD])
 			tsd.period = nla_get_u32(ntsd[TSN_TSD_ATTR_PERIOD]);
-		}
 
 		if (!tsd.period) {
-			tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+			tsn_simple_reply(info, TSN_CMD_REPLY,
+					 netdev->name, -TSN_ATTRERR);
 			return -EINVAL;
 		}
 
 		if (ntsd[TSN_TSD_ATTR_MAX_FRM_NUM])
-			tsd.maxFrameNum = nla_get_u32(ntsd[TSN_TSD_ATTR_MAX_FRM_NUM]);
+			tsd.maxFrameNum =
+				nla_get_u32(ntsd[TSN_TSD_ATTR_MAX_FRM_NUM]);
 
 		if (ntsd[TSN_TSD_ATTR_SYN_IMME])
 			tsd.syn_flag = 2;
@@ -2427,11 +2541,13 @@ static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
 
 	ret = tsnops->tsd_set(netdev, &tsd);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
 
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 	return 0;
 }
 
@@ -2454,27 +2570,32 @@ static int tsn_tsd_get(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_TSD]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	if (!tsnops->tsd_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = tsnops->tsd_get(netdev, &tts);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -1;
 	}
 
 	na = info->attrs[TSN_ATTR_TSD];
 
-	ret = NLA_PARSE_NESTED(tsda, TSN_TSD_ATTR_MAX, na, tsd_policy);
+	ret = NLA_PARSE_NESTED(tsda, TSN_TSD_ATTR_MAX,
+			       na, tsd_policy);
 	if (ret) {
 		pr_err("tsn: parse value TSN_TSD_ATTR_MAX error.");
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2483,7 +2604,7 @@ static int tsn_tsd_get(struct sk_buff *skb, struct genl_info *info)
 
 	/* Form netlink reply data */
 	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
-			NLMSG_ALIGN(MAX_ATTR_SIZE));
+				NLMSG_ALIGN(MAX_ATTR_SIZE));
 	if (ret < 0)
 		return ret;
 
@@ -2529,20 +2650,24 @@ static int tsn_ct_set(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CT]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_CT];
 
 	if (!tsnops->ct_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
-	ret = NLA_PARSE_NESTED(cta, TSN_CT_ATTR_MAX, na, ct_policy);
+	ret = NLA_PARSE_NESTED(cta, TSN_CT_ATTR_MAX,
+			       na, ct_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2550,10 +2675,13 @@ static int tsn_ct_set(struct sk_buff *skb, struct genl_info *info)
 
 	ret = tsnops->ct_set(netdev, queue_stat);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 	return 0;
 }
 
@@ -2575,20 +2703,24 @@ static int tsn_cbgen_set(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBGEN]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_CBGEN];
 
 	if (!tsnops->cbgen_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
-	ret = NLA_PARSE_NESTED(cbgena, TSN_CBGEN_ATTR_MAX, na, cbgen_policy);
+	ret = NLA_PARSE_NESTED(cbgena, TSN_CBGEN_ATTR_MAX,
+			       na, cbgen_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2602,14 +2734,16 @@ static int tsn_cbgen_set(struct sk_buff *skb, struct genl_info *info)
 
 	ret = tsnops->cbgen_set(netdev, index, &sg_conf);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 	return 0;
 }
 
-
 static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *na;
@@ -2628,20 +2762,24 @@ static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_CBREC]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_CBREC];
 
 	if (!tsnops->cbrec_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
-	ret = NLA_PARSE_NESTED(cbreca, TSN_CBREC_ATTR_MAX, na, cbrec_policy);
+	ret = NLA_PARSE_NESTED(cbreca, TSN_CBREC_ATTR_MAX,
+			       na, cbrec_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
@@ -2654,10 +2792,13 @@ static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 
 	ret = tsnops->cbrec_set(netdev, index, &sr_conf);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 	return 0;
 }
 
@@ -2678,31 +2819,37 @@ static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
 	tsnops = port->tsnops;
 
 	if (!info->attrs[TSN_ATTR_PCPMAP]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	na = info->attrs[TSN_ATTR_PCPMAP];
 
 	if (!tsnops->pcpmap_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
 		return -1;
 	}
 
 	ret = NLA_PARSE_NESTED(pcpmapa, TSN_PCPMAP_ATTR_MAX,
 			       na, pcpmap_policy);
 	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
 		return -EINVAL;
 	}
 
 	enable = nla_get_flag(pcpmapa[TSN_PCPMAP_ATTR_ENABLE]);
 	ret = tsnops->pcpmap_set(netdev, enable);
 	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
 		return -EINVAL;
 	}
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
 
 	return 0;
 }
@@ -2861,21 +3008,16 @@ static const struct genl_ops tsnnl_ops[] = {
 };
 
 static struct genl_family tsn_family = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
-	.id			= GENL_ID_GENERATE,
-#endif
-/*	.hdrsize	= NLMSG_ALIGN(MAX_USER_SIZE),*/
 	.name		= TSN_GENL_NAME,
 	.version	= TSN_GENL_VERSION,
 	.maxattr	= TSN_CMD_ATTR_MAX,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 	.module		= THIS_MODULE,
 	.ops		= tsnnl_ops,
 	.n_ops		= ARRAY_SIZE(tsnnl_ops),
-#endif
 };
 
-int tsn_port_register(struct net_device *netdev, struct tsn_ops *tsnops, u16 groupid)
+int tsn_port_register(struct net_device *netdev,
+		      struct tsn_ops *tsnops, u16 groupid)
 {
 	struct tsn_port *port;
 
@@ -2890,7 +3032,7 @@ int tsn_port_register(struct net_device *netdev, struct tsn_ops *tsnops, u16 gro
 		}
 	}
 
-	port = kzalloc(sizeof(struct tsn_port), GFP_KERNEL);
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
 	if (!port)
 		return -1;
 
@@ -2910,7 +3052,6 @@ int tsn_port_register(struct net_device *netdev, struct tsn_ops *tsnops, u16 gro
 
 	return 0;
 }
-
 EXPORT_SYMBOL(tsn_port_register);
 
 void tsn_port_unregister(struct net_device *netdev)
@@ -2927,7 +3068,6 @@ void tsn_port_unregister(struct net_device *netdev)
 		}
 	}
 }
-
 EXPORT_SYMBOL(tsn_port_unregister);
 
 static int __init tsn_genetlink_init(void)
@@ -2936,11 +3076,8 @@ static int __init tsn_genetlink_init(void)
 
 	pr_info("tsn generic netlink module v%d init...\n", TSN_GENL_VERSION);
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 10, 0)
-	ret = genl_register_family_with_ops(&tsn_family, tsnnl_ops);
-#else
 	ret = genl_register_family(&tsn_family);
-#endif
+
 	if (ret != 0) {
 		pr_info("failed to init tsn generic netlink example module\n");
 		return ret;
@@ -2954,12 +3091,10 @@ static void __exit tsn_genetlink_exit(void)
 	int ret;
 
 	ret = genl_unregister_family(&tsn_family);
-	if (ret != 0) {
+	if (ret != 0)
 		pr_info("failed to unregister family:%i\n", ret);
-	}
 }
 
 module_init(tsn_genetlink_init);
 module_exit(tsn_genetlink_exit);
 MODULE_LICENSE("GPL");
-
-- 
2.17.1


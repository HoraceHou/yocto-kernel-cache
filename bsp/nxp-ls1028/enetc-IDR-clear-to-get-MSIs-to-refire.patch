From 87ba9a2747a1b54714f2ec151fe12d72f29dd732 Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@nxp.com>
Date: Tue, 19 Dec 2017 18:58:07 +0200
Subject: [PATCH 095/706] enetc: IDR clear to get MSIs to refire

This issue became apparent with simulator model M0168, after a
ENETC simulator model fix targetting the interrupt handling
mechanism.

Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
(cherry picked from commit 0a3a9c14bdd1bf098a8d379c57c1a2812d2bd451)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c  | 20 +++++++++++++++++++
 .../net/ethernet/freescale/enetc/enetc_hw.h   |  2 ++
 2 files changed, 22 insertions(+)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index 84c4e586ddd1..ffb765229271 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -55,6 +55,13 @@ static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 static irqreturn_t enetc_msix(int irq, void *data)
 {
 	struct napi_struct *napi = data;
+	struct enetc_int_vector
+		*v = container_of(napi, struct enetc_int_vector, napi);
+	struct enetc_ndev_priv *priv = netdev_priv(v->tx_ring.ndev);
+
+	/* disable interrupts */
+	enetc_txbdr_wr(&priv->si->hw, v->tx_ring.index, ENETC_TBIER, 0);
+	enetc_rxbdr_wr(&priv->si->hw, v->rx_ring.index, ENETC_RBIER, 0);
 
 	napi_schedule(napi);
 
@@ -240,6 +247,7 @@ static int enetc_poll(struct napi_struct *napi, int budget)
 {
 	struct enetc_int_vector
 		*v = container_of(napi, struct enetc_int_vector, napi);
+	struct enetc_ndev_priv *priv = netdev_priv(v->tx_ring.ndev);
 	bool complete = true;
 	int work_done;
 
@@ -254,6 +262,11 @@ static int enetc_poll(struct napi_struct *napi, int budget)
 
 	napi_complete_done(napi, work_done);
 
+	enetc_txbdr_wr(&priv->si->hw, v->tx_ring.index, ENETC_TBIER,
+		       ENETC_TBIER_TXFIE);
+	enetc_rxbdr_wr(&priv->si->hw, v->rx_ring.index, ENETC_RBIER,
+		       ENETC_RBIER_RXTIE);
+
 	return work_done;
 }
 
@@ -279,6 +292,8 @@ static void enetc_unmap_tx_buff(struct enetc_bdr *tx_ring,
 static bool enetc_clean_tx_ring(struct enetc_bdr *tx_ring)
 {
 	struct net_device *ndev = tx_ring->ndev;
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	struct enetc_hw *hw = &priv->si->hw;
 	int tx_frm_cnt = 0, tx_byte_cnt = 0;
 	struct enetc_tx_swbd *tx_swbd;
 	bool frame_cleaned = false;
@@ -302,6 +317,8 @@ static bool enetc_clean_tx_ring(struct enetc_bdr *tx_ring)
 			}
 		} while (!frame_cleaned);
 
+		enetc_wr(hw, ENETC_SITXIDR, BIT(tx_ring->index));
+
 		tx_frm_cnt++;
 
 		if (!tx_swbd->skb)
@@ -417,6 +434,8 @@ static void enetc_get_offloads(struct enetc_bdr *rx_ring,
 static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 			       struct napi_struct *napi, int work_limit)
 {
+	struct enetc_ndev_priv *priv = netdev_priv(rx_ring->ndev);
+	struct enetc_hw *hw = &priv->si->hw;
 	int rx_frm_cnt = 0, rx_byte_cnt = 0;
 	int cleaned_cnt, i;
 
@@ -441,6 +460,7 @@ static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 		if (!bd_status)
 			break;
 
+		enetc_wr(hw, ENETC_SIRXIDR, BIT(rx_ring->index));
 		dma_rmb(); /* for readig other rxbd fields */
 		size = le16_to_cpu(rxbd->r.buf_len);
 		skb = enetc_map_rx_buff_to_skb(rx_ring, i, size);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
index 2fef0b489d22..493729393577 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
@@ -97,6 +97,8 @@ static inline u32 enetc_vsi_set_msize(u32 size)
 #define ENETC_PSIIER	0xa00
 #define ENETC_PSIIER_MR_MASK	GENMASK(2, 1)
 #define ENETC_PSIIDR	0xa10
+#define ENETC_SITXIDR	0xa18
+#define ENETC_SIRXIDR	0xa1c
 #define ENETC_SIMSIVR	0xa20
 
 #define ENETC_SIMSITRV(n) (0xB00 + (n) * 0x4)
-- 
2.17.1


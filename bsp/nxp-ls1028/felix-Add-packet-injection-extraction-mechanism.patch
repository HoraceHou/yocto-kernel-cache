From ce1aee7c7db90c757694c6676bc70ba1288c02cc Mon Sep 17 00:00:00 2001
From: Catalin Horghidan <catalin.horghidan@nxp.com>
Date: Fri, 16 Nov 2018 12:42:09 +0200
Subject: [PATCH 347/706] felix: Add packet injection extraction mechanism

This mechanism allows a faster alternative to send/receive frames
than current Ocelot implementation based on register access.
The new mechanism is based on the Felix capability to allow
frames tagged with a 32-byte header to bypass the switch frame
analyzer on xmit. For receive, we use another Felix capability
that enables to forward all frames to the CPU port and have
the frames tagged with 32-byte header from which we can extract
the source port.

Signed-off-by: Catalin Horghidan <catalin.horghidan@nxp.com>
(cherry picked from commit 05f342c8dea14568eca476ffa82edb10b19c2001)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/mscc/felix_board.c | 202 +++++++++++++++++++++++-
 drivers/net/ethernet/mscc/ocelot.c      |   7 +-
 drivers/net/ethernet/mscc/ocelot.h      |   8 +
 3 files changed, 211 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
index 62f0a4525d9d..24bf17b86f2f 100644
--- a/drivers/net/ethernet/mscc/felix_board.c
+++ b/drivers/net/ethernet/mscc/felix_board.c
@@ -10,6 +10,7 @@
 #include <linux/phy_fixed.h>
 #include <linux/phy.h>
 #include <linux/of_mdio.h>
+#include <net/sock.h>
 
 #include "ocelot.h"
 
@@ -17,8 +18,8 @@ static const char felix_driver_string[] = "Felix Switch Driver";
 #define DRV_VERSION "0.2"
 static const char felix_driver_version[] = DRV_VERSION;
 
-#define FELIX_MAX_NUM_PHY_PORTS	6
-#define FELIX_EXT_CPU_PORT_ID	5
+#define FELIX_MAX_NUM_PHY_PORTS	5
+#define FELIX_EXT_CPU_PORT_ID	4
 #define PORT_RES_START		(SYS + 1)
 
 #define PCI_DEVICE_ID_FELIX_PF5	0xEEF0
@@ -26,6 +27,10 @@ static const char felix_driver_version[] = DRV_VERSION;
 /* Switch register block BAR */
 #define FELIX_SWITCH_BAR	4
 
+/* pair PCI device */
+char *pair_eth = "\0";
+module_param(pair_eth, charp, 0000);
+
 static struct pci_device_id felix_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FELIX_PF5) },
 	{ 0, }
@@ -109,6 +114,171 @@ static void __iomem *regs;
 
 int felix_chip_init(struct ocelot *ocelot);
 
+static inline void felix_set_xfh_field(u32 *efh, u8 bit, u8 w, u16 v)
+{
+	u8 wi = bit >> 5;
+	u8 bi = 32 - (bit - wi * 32 + w);
+	u32 val = *(efh + wi);
+
+	v = v & GENMASK(w - 1, 0);
+	*(efh + wi) = val | htonl(v << bi);
+}
+
+static inline u32 felix_get_xfh_field(u32 *efh, u8 bit, u8 w)
+{
+	u8 wi = bit >> 5;
+	u8 bi = 32 - (bit - wi * 32 + w);
+
+	return (ntohl(*(efh + wi)) >> bi) & GENMASK(w - 1, 0);
+}
+
+#define FELIX_IFH_FIELD(name, bit, w) \
+static inline void felix_set_ifh_##name(u32 *ifh, u16 v) \
+{ \
+	felix_set_xfh_field(ifh, bit, w, v); \
+}
+
+#define FELIX_EFH_FIELD(name, bit, w) \
+static inline u32 felix_get_efh_##name(u32 *efh) \
+{ \
+	return felix_get_xfh_field(efh, bit, w); \
+}
+
+#define FELIX_XFH_LEN 16
+
+/* Felix 128bit-value frame injection header:
+ *
+ * bit 127: bypass the analyzer processing
+ * bit 56-61: destination port mask
+ * bit 28-29: pop_cnt: 3 disables all rewriting of the frame
+ * bit 20-27: cpu extraction queue mask
+ */
+FELIX_IFH_FIELD(bypass, 127, 1)
+FELIX_IFH_FIELD(dstp, 56, 6)
+FELIX_IFH_FIELD(srcp, 43, 4)
+FELIX_IFH_FIELD(popcnt, 28, 2)
+FELIX_IFH_FIELD(cpuq, 20, 8)
+
+#define FELIX_IFH_INJ_POP_CNT_DISABLE 3
+
+/* Felix 128bit-value frame extraction header */
+
+/* bit 43-45: source port id */
+FELIX_EFH_FIELD(srcp, 43, 4)
+
+static void felix_tx_hdr_set(struct sk_buff *skb, struct ocelot_port *port)
+{
+	u32 *ifh = skb_push(skb, FELIX_XFH_LEN);
+	u16 *hdel = skb_push(skb, 2);
+	struct ethhdr *ethh = skb_push(skb, ETH_HLEN);
+
+	/* fill frame injection header */
+	ether_addr_copy(ethh->h_dest, port->dev->dev_addr);
+	eth_zero_addr(ethh->h_source);
+	ethh->h_proto = htons(0x8880);
+	*hdel = htons(0x000A);
+
+	memset(ifh, 0x0, FELIX_XFH_LEN);
+	felix_set_ifh_bypass(ifh, 1);
+	felix_set_ifh_dstp(ifh, BIT(port->chip_port));
+	felix_set_ifh_srcp(ifh, FELIX_EXT_CPU_PORT_ID);
+	felix_set_ifh_popcnt(ifh, FELIX_IFH_INJ_POP_CNT_DISABLE);
+	felix_set_ifh_cpuq(ifh, 0xff);
+}
+
+static void felix_rx_hdr_extract(struct sk_buff *skb, struct frame_info *info)
+{
+	char *efh;
+
+	/* ETH_HLEN bytes were already pulled by receivig driver */
+	efh = skb_pull(skb, 2);
+
+	info->port = felix_get_efh_srcp((u32 *)efh);
+	/* TODO: set traffic class from header */
+
+	/* pull cpu extraction header */
+	skb_pull(skb, FELIX_XFH_LEN);
+}
+
+static rx_handler_result_t felix_frm_ext_handler(struct sk_buff **pskb)
+{
+	struct frame_info info = {0};
+	struct sk_buff *skb = *pskb;
+	struct ocelot_port *port;
+	struct net_device *ndev;
+	struct ocelot *ocelot;
+	int err;
+
+	ndev = skb->dev;
+	felix_rx_hdr_extract(skb, &info);
+
+	/* frame for a CPU port */
+	if (info.port >= FELIX_EXT_CPU_PORT_ID)
+		return RX_HANDLER_PASS;
+
+	ocelot = rcu_dereference(ndev->rx_handler_data);
+
+	port = ocelot->ports[info.port];
+	skb->dev = port->dev;
+	err = netif_rx(skb);
+
+	return RX_HANDLER_CONSUMED;
+}
+
+static netdev_tx_t felix_cpu_inj_handler(struct sk_buff *skb,
+					 struct ocelot_port *port)
+{
+	struct net_device *ndev = port->cpu_inj_handler_data;
+
+	if (!netif_running(ndev)) {
+		return NETDEV_TX_BUSY;
+	}
+
+	if (unlikely(skb_headroom(skb) < FELIX_XFH_LEN)) {
+		struct sk_buff *skb_orig = skb;
+		skb = skb_realloc_headroom(skb, FELIX_XFH_LEN);
+
+		/* TODO: free skb in non irq context */
+		if (!skb) {
+			dev_kfree_skb_any(skb_orig);
+			return NETDEV_TX_OK;
+		}
+
+		if (skb_orig->sk)
+			skb_set_owner_w(skb, skb_orig->sk);
+
+		skb_copy_queue_mapping(skb, skb_orig);
+		skb->priority = skb_orig->priority;
+#ifdef CONFIG_NET_SCHED
+		skb->tc_index = skb_orig->tc_index;
+#endif
+		dev_consume_skb_any(skb_orig);
+	}
+
+	/* add cpu injection header */
+	felix_tx_hdr_set(skb, port);
+
+	skb->dev = ndev;
+	dev_queue_xmit(skb);
+
+	return NETDEV_TX_OK;
+}
+
+static void felix_register_xmit_handler(struct ocelot_port *port,
+				      struct net_device *ndev)
+{
+	struct ocelot *ocelot = port->ocelot;
+
+	/* set packet injection handler */
+	port->cpu_inj_handler = &felix_cpu_inj_handler;
+	port->cpu_inj_handler_data = ndev;
+	/* register rx handler */
+	rtnl_lock();
+	if (!netdev_is_rx_handler_busy(ndev))
+		netdev_rx_handler_register(ndev, felix_frm_ext_handler, ocelot);
+	rtnl_unlock();
+}
+
 static struct regmap *felix_io_init(struct ocelot *ocelot, u8 target)
 {
 	void __iomem *target_regs;
@@ -131,6 +301,7 @@ static struct regmap *felix_io_init(struct ocelot *ocelot, u8 target)
 static void felix_release_ports(struct ocelot_port **ports)
 {
 	struct phy_device *phydev;
+	struct net_device *ndev;
 	struct device_node *dn;
 	int i;
 
@@ -159,6 +330,12 @@ static void felix_release_ports(struct ocelot_port **ports)
 		}
 		phy_device_free(phydev); /* decr refcnt: of_find_phy_device */
 		ports[i]->phy = NULL;
+		if (ports[i]->cpu_inj_handler_data) {
+			ndev = ports[i]->cpu_inj_handler_data;
+			rtnl_lock();
+			netdev_rx_handler_unregister(ndev);
+			rtnl_unlock();
+		}
 	}
 }
 
@@ -170,10 +347,12 @@ static int felix_ports_init(struct ocelot *ocelot)
 	struct phy_device *phydev = NULL;
 	struct resource *felix_res;
 	void __iomem *port_regs;
-	u32 port, totalp = 0;
+	struct net_device *ndev;
+	u32 port;
 	int err;
 
-	ocelot->num_cpu_ports = 1; /* 1 port on the switch, two groups */
+	ocelot->num_cpu_ports = 1;
+	ocelot->cpu_port_id = FELIX_EXT_CPU_PORT_ID;
 	ocelot->num_phys_ports = FELIX_MAX_NUM_PHY_PORTS;
 	ocelot->ports = devm_kcalloc(ocelot->dev, ocelot->num_phys_ports,
 				     sizeof(struct ocelot_port *), GFP_KERNEL);
@@ -183,6 +362,10 @@ static int felix_ports_init(struct ocelot *ocelot)
 	if (err)
 		return err;
 
+	ndev = NULL;
+	if (pair_eth)
+		ndev = dev_get_by_name(&init_net, pair_eth);
+
 	for_each_available_child_of_node(np, portnp) {
 		if (!portnp || !portnp->name ||
 		    of_node_cmp(portnp->name, "port") ||
@@ -234,12 +417,17 @@ static int felix_ports_init(struct ocelot *ocelot)
 			phy_is_pseudo_fixed_link(phydev)
 			? "fixed-link" : phydev->drv->name);
 
+		/* TODO: probe only if its not CPU port */
 		err = ocelot_probe_port(ocelot, port, port_regs, phydev);
 		if (err) {
 			dev_err(ocelot->dev, "failed to probe ports\n");
 			goto release_ports;
 		}
-		totalp++;
+		/* register xmit handler for external ports */
+		if (ndev && port <= FELIX_EXT_CPU_PORT_ID)
+			felix_register_xmit_handler(ocelot->ports[port], ndev);
+		/* TODO: check if FL phy require phy_start */
+		phy_start(phydev);
 	}
 
 	return 0;
@@ -339,6 +527,10 @@ static int felix_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	ocelot_write(ocelot, QSYS_EXT_CPU_CFG_EXT_CPUQ_MSK_M |
 		     QSYS_EXT_CPU_CFG_EXT_CPU_PORT(FELIX_EXT_CPU_PORT_ID),
 		     QSYS_EXT_CPU_CFG);
+	/* long prefix frame tagging */
+	ocelot_write_rix(ocelot, SYS_PORT_MODE_INCL_XTR_HDR(3) |
+			 SYS_PORT_MODE_INCL_INJ_HDR(3), SYS_PORT_MODE,
+			 FELIX_EXT_CPU_PORT_ID);
 
 	register_netdevice_notifier(&ocelot_netdevice_nb);
 
diff --git a/drivers/net/ethernet/mscc/ocelot.c b/drivers/net/ethernet/mscc/ocelot.c
index f83761c61f51..fc69bbfcf38a 100644
--- a/drivers/net/ethernet/mscc/ocelot.c
+++ b/drivers/net/ethernet/mscc/ocelot.c
@@ -548,6 +548,10 @@ static int ocelot_port_xmit(struct sk_buff *skb, struct net_device *dev)
 	u8 grp = 0; /* Send everything on CPU group 0 */
 	unsigned int i, count, last;
 
+	/* defer frame xmit to cpu inject handler */
+	if (port->cpu_inj_handler)
+		return port->cpu_inj_handler(skb, port);
+
 	val = ocelot_read(ocelot, QS_INJ_STATUS);
 	if (!(val & QS_INJ_STATUS_FIFO_RDY(BIT(grp))) ||
 	    (val & QS_INJ_STATUS_WMARK_REACHED(BIT(grp))))
@@ -1622,6 +1626,7 @@ int ocelot_probe_port(struct ocelot *ocelot, u8 port,
 	dev->dev_addr[ETH_ALEN - 1] += port;
 	ocelot_mact_learn(ocelot, PGID_CPU, dev->dev_addr, ocelot_port->pvid,
 			  ENTRYTYPE_LOCKED);
+	dev->needed_headroom = XFH_LONG_PREFIX_LEN;
 
 	err = register_netdev(dev);
 	if (err) {
@@ -1643,7 +1648,7 @@ EXPORT_SYMBOL(ocelot_probe_port);
 int ocelot_init(struct ocelot *ocelot)
 {
 	u32 port;
-	int i, cpu = ocelot->num_phys_ports;
+	int i, cpu = ocelot->cpu_port_id;
 	char queue_name[32];
 
 	ocelot->lags = devm_kcalloc(ocelot->dev, ocelot->num_phys_ports,
diff --git a/drivers/net/ethernet/mscc/ocelot.h b/drivers/net/ethernet/mscc/ocelot.h
index 7152c4cff485..1bd784c5a9a6 100644
--- a/drivers/net/ethernet/mscc/ocelot.h
+++ b/drivers/net/ethernet/mscc/ocelot.h
@@ -38,6 +38,9 @@
 
 #define IFH_LEN 4
 
+/* Length for long prefix header used for frame injection/extraction */
+#define XFH_LONG_PREFIX_LEN 32
+
 struct frame_info {
 	u32 len;
 	u16 port;
@@ -491,6 +494,7 @@ struct ocelot {
 
 	u8 num_phys_ports;
 	u8 num_cpu_ports;
+	u8 cpu_port_id;
 	struct ocelot_port **ports;
 
 	u32 *lags;
@@ -529,6 +533,10 @@ struct ocelot_port {
 	u8 vlan_aware;
 
 	u64 *stats;
+
+	/* cpu frame injection handler */
+	netdev_tx_t (*cpu_inj_handler)(struct sk_buff *skb, struct ocelot_port *port);
+	void *cpu_inj_handler_data;
 };
 
 u32 __ocelot_read_ix(struct ocelot *ocelot, u32 reg, u32 offset);
-- 
2.17.1


From a0ae27ec8da26875fc13fe1f851c492f43e4eecc Mon Sep 17 00:00:00 2001
From: Razvan Stefanescu <razvan.stefanescu@nxp.com>
Date: Wed, 20 Jun 2018 12:01:53 +0300
Subject: [PATCH 193/706] net: mscc: Add Felix support

Add support for Felix l2switch reusing code from Ocelot.

Felix is probed over PCI. Switch ports are connected to fixed-links
phys.

Signed-off-by: Razvan Stefanescu <razvan.stefanescu@nxp.com>
(cherry picked from commit 69467cd77c4a47923c7b286e57aded9f75e33599)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/mscc/Kconfig       |   8 +
 drivers/net/ethernet/mscc/Makefile      |   3 +
 drivers/net/ethernet/mscc/felix_board.c | 324 ++++++++++++++++++
 drivers/net/ethernet/mscc/felix_regs.c  | 416 ++++++++++++++++++++++++
 4 files changed, 751 insertions(+)
 create mode 100644 drivers/net/ethernet/mscc/felix_board.c
 create mode 100644 drivers/net/ethernet/mscc/felix_regs.c

diff --git a/drivers/net/ethernet/mscc/Kconfig b/drivers/net/ethernet/mscc/Kconfig
index 36c84625d54e..d54804b518cf 100644
--- a/drivers/net/ethernet/mscc/Kconfig
+++ b/drivers/net/ethernet/mscc/Kconfig
@@ -27,4 +27,12 @@ config MSCC_OCELOT_SWITCH_OCELOT
 	  This driver supports the Ocelot network switch device as present on
 	  the Ocelot SoCs.
 
+config MSCC_FELIX_SWITCH
+	tristate "FELIX switch driver"
+	depends on MSCC_OCELOT_SWITCH
+	depends on PCI
+	help
+	  This driver supports the Felix network switch device, connected as a
+	  PCI device.
+
 endif # NET_VENDOR_MICROSEMI
diff --git a/drivers/net/ethernet/mscc/Makefile b/drivers/net/ethernet/mscc/Makefile
index acb89be8e094..409de26b23e0 100644
--- a/drivers/net/ethernet/mscc/Makefile
+++ b/drivers/net/ethernet/mscc/Makefile
@@ -2,3 +2,6 @@
 obj-$(CONFIG_MSCC_OCELOT_SWITCH) += mscc_ocelot_common.o
 mscc_ocelot_common-y := ocelot.o ocelot_io.o
 obj-$(CONFIG_MSCC_OCELOT_SWITCH_OCELOT) += ocelot_board.o ocelot_regs.o
+
+obj-$(CONFIG_MSCC_FELIX_SWITCH) += mscc_felix.o
+mscc_felix-y := felix_regs.o felix_board.o
diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
new file mode 100644
index 000000000000..9a40f67d1e46
--- /dev/null
+++ b/drivers/net/ethernet/mscc/felix_board.c
@@ -0,0 +1,324 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Felix Switch driver
+ *
+ * Copyright (c) 2018 NXP
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/phy_fixed.h>
+#include <linux/phy.h>
+
+#include "ocelot.h"
+
+static const char felix_driver_string[] = "Felix Switch Driver";
+#define DRV_VERSION "0.2"
+static const char felix_driver_version[] = DRV_VERSION;
+
+#define NUM_PHY_PORTS		6
+#define PORT_RES_START		(SYS + 1)
+
+#define PCI_DEVICE_ID_FELIX_PF5	0xEEF0
+
+/* Switch register block BAR */
+#define FELIX_SWITCH_BAR	4
+
+static struct pci_device_id felix_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FELIX_PF5) },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, felix_ids);
+
+/* Mimic the order of ocelot_target */
+static struct resource felix_switch_res[] = {
+	{
+		/* Nothing here */
+	},
+	{
+		.start = 0x0280000,
+		.end = 0x028ffff,
+		.name = "ana",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0080000,
+		.end = 0x00800ff,
+		.name = "qs",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0200000,
+		.end = 0x021ffff,
+		.name = "qsys",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0030000,
+		.end = 0x003ffff,
+		.name = "rew",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0010000,
+		.end = 0x001ffff,
+		.name = "sys",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0100000,
+		.end = 0x010ffff,
+		.name = "port0",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0110000,
+		.end = 0x011ffff,
+		.name = "port1",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0120000,
+		.end = 0x012ffff,
+		.name = "port2",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0130000,
+		.end = 0x013ffff,
+		.name = "port3",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0140000,
+		.end = 0x014ffff,
+		.name = "port4",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0x0150000,
+		.end = 0x015ffff,
+		.name = "port5",
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static void __iomem *regs;
+
+int felix_chip_init(struct ocelot *ocelot);
+
+static struct regmap *felix_io_init(struct ocelot *ocelot, u8 target)
+{
+	void __iomem *target_regs;
+	struct regmap_config felix_regmap_config = {
+		.reg_bits	= 32,
+		.val_bits	= 32,
+		.reg_stride	= 4,
+	};
+
+	felix_regmap_config.name = felix_switch_res[target].name;
+	target_regs = devm_ioremap_resource(ocelot->dev,
+					    &felix_switch_res[target]);
+	if (IS_ERR(target_regs))
+		return ERR_CAST(target_regs);
+
+	return devm_regmap_init_mmio(ocelot->dev, target_regs,
+				     &felix_regmap_config);
+}
+
+static struct phy_device *felix_fixed_phy_register(struct device *dev)
+{
+	struct phy_device *fixed_phy;
+	struct fixed_phy_status status = {
+			.link = 1,
+			.speed = 1000,
+			.duplex = 1,
+	};
+
+	fixed_phy = fixed_phy_register(PHY_POLL, &status, -1, NULL);
+	if (!fixed_phy || IS_ERR(fixed_phy)) {
+		dev_err(dev, "error trying to register fixed PHY\n");
+		fixed_phy = NULL;
+	}
+	phy_start(fixed_phy);
+
+	return fixed_phy;
+}
+
+static int felix_ports_init(struct ocelot *ocelot)
+{
+	struct phy_device *fixed_phy;
+	void __iomem *port_regs;
+	int port;
+	int err;
+
+	for (port = 0; port < ocelot->num_phys_ports; port++) {
+		port_regs = devm_ioremap_resource(ocelot->dev,
+				&felix_switch_res[PORT_RES_START + port]);
+		if (IS_ERR(port_regs)) {
+			dev_err(ocelot->dev,
+				"failed to map registers for port %d\n", port);
+			goto release_ports;
+		}
+
+		fixed_phy = felix_fixed_phy_register(ocelot->dev);
+		if (!fixed_phy)
+			goto release_ports;
+
+		err = ocelot_probe_port(ocelot, port, port_regs, fixed_phy);
+		if (err) {
+			dev_err(ocelot->dev, "failed to probe port %d\n", port);
+			goto release_ports;
+		}
+	}
+
+	return 0;
+
+release_ports:
+	for (port--; port >= 0; port--) {
+		unregister_netdev(ocelot->ports[port]->dev);
+		free_netdev(ocelot->ports[port]->dev);
+	}
+
+	return err;
+}
+
+static int felix_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct ocelot *ocelot;
+	resource_size_t offset;
+	size_t len;
+	int timeout;
+	int i, err;
+
+	err = pci_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "device enable failed\n");
+		return err;
+	}
+
+	/* set up for high or low dma */
+	err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (err) {
+		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+		if (err) {
+			dev_err(&pdev->dev,
+				"DMA configuration failed: 0x%x\n", err);
+			goto err_dma;
+		}
+	}
+
+	offset = pci_resource_start(pdev, FELIX_SWITCH_BAR);
+
+	pci_set_master(pdev);
+
+	ocelot = kzalloc(sizeof(*ocelot), GFP_KERNEL);
+	if (!ocelot) {
+		err = -ENOMEM;
+		goto err_alloc_ocelot;
+	}
+
+	pci_set_drvdata(pdev, ocelot);
+	ocelot->dev = &pdev->dev;
+
+	len = pci_resource_len(pdev, FELIX_SWITCH_BAR);
+	if (len == 0) {
+		err = -EINVAL;
+		goto err_resource_len;
+	}
+
+	regs = pci_iomap(pdev, FELIX_SWITCH_BAR, len);
+	if (!regs) {
+		err = -ENXIO;
+		dev_err(&pdev->dev, "ioremap() failed\n");
+		goto err_iomap;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(felix_switch_res); i++)
+		if (felix_switch_res[i].flags == IORESOURCE_MEM) {
+			felix_switch_res[i].start += offset;
+			felix_switch_res[i].end += offset;
+		}
+
+	for (i = ANA; i <= SYS; i++) {
+		struct regmap *target;
+
+		target = felix_io_init(ocelot, i);
+		if (IS_ERR(target))
+			return PTR_ERR(target);
+
+		ocelot->targets[i] = target;
+	}
+
+	err = felix_chip_init(ocelot);
+	if (err)
+		goto err_chip_init;
+
+	ocelot_write(ocelot, SYS_RAM_INIT_RAM_INIT, SYS_RAM_INIT);
+
+	timeout = 50000;
+	while (ocelot_read(ocelot, SYS_RAM_INIT) && --timeout)
+		udelay(1); /* busy wait for memory init */
+	if (timeout == 0)
+		dev_err(&pdev->dev, "Timeout waiting for memory to initialize\n");
+
+	regmap_field_write(ocelot->regfields[SYS_RESET_CFG_CORE_ENA], 1);
+
+	ocelot->num_cpu_ports = 1; /* 1 port on the switch, two groups */
+	ocelot->num_phys_ports = NUM_PHY_PORTS;
+	ocelot->ports = devm_kcalloc(&pdev->dev, ocelot->num_phys_ports,
+				     sizeof(struct ocelot_port *), GFP_KERNEL);
+
+	ocelot_init(ocelot);
+
+	err = felix_ports_init(ocelot);
+	if (err)
+		goto err_ports_init;
+
+	register_netdevice_notifier(&ocelot_netdevice_nb);
+
+	dev_info(&pdev->dev, "%s - version %s probed\n", felix_driver_string,
+		 felix_driver_version);
+	return 0;
+
+err_ports_init:
+err_chip_init:
+	pci_iounmap(pdev, regs);
+err_iomap:
+err_resource_len:
+	kfree(ocelot);
+err_alloc_ocelot:
+err_dma:
+	pci_disable_device(pdev);
+
+	return err;
+}
+
+static void felix_pci_remove(struct pci_dev *pdev)
+{
+	struct ocelot *ocelot;
+
+	unregister_netdevice_notifier(&ocelot_netdevice_nb);
+
+	ocelot = pci_get_drvdata(pdev);
+
+	ocelot_deinit(ocelot);
+	pci_iounmap(pdev, regs);
+	kfree(ocelot);
+	pci_disable_device(pdev);
+	pr_debug("%s - version %s removed\n", felix_driver_string,
+		 felix_driver_version);
+}
+
+static struct pci_driver felix_pci_driver = {
+	.name = "mscc_felix",
+	.id_table = felix_ids,
+	.probe = felix_pci_probe,
+	.remove = felix_pci_remove,
+};
+
+module_pci_driver(felix_pci_driver);
+
+MODULE_DESCRIPTION("Felix switch driver");
+MODULE_AUTHOR("Razvan Stefanescu <razvan.stefanescu@nxp.com>");
+MODULE_LICENSE("Dual MIT/GPL");
diff --git a/drivers/net/ethernet/mscc/felix_regs.c b/drivers/net/ethernet/mscc/felix_regs.c
new file mode 100644
index 000000000000..11e9fdd1360d
--- /dev/null
+++ b/drivers/net/ethernet/mscc/felix_regs.c
@@ -0,0 +1,416 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Microsemi Ocelot Switch driver
+ *
+ * Copyright (c) 2017 Microsemi Corporation
+ */
+#include "ocelot.h"
+
+static const u32 felix_ana_regmap[] = {
+	REG(ANA_ADVLEARN,                  0x0089a0),
+	REG(ANA_VLANMASK,                  0x0089a4),
+	REG(ANA_PORT_B_DOMAIN,             0x0089a8),
+	REG(ANA_ANAGEFIL,                  0x0089ac),
+	REG(ANA_ANEVENTS,                  0x0089b0),
+	REG(ANA_STORMLIMIT_BURST,          0x0089b4),
+	REG(ANA_STORMLIMIT_CFG,            0x0089b8),
+	REG(ANA_ISOLATED_PORTS,            0x0089c8),
+	REG(ANA_COMMUNITY_PORTS,           0x0089cc),
+	REG(ANA_AUTOAGE,                   0x0089d0),
+	REG(ANA_MACTOPTIONS,               0x0089d4),
+	REG(ANA_LEARNDISC,                 0x0089d8),
+	REG(ANA_AGENCTRL,                  0x0089dc),
+	REG(ANA_MIRRORPORTS,               0x0089e0),
+	REG(ANA_EMIRRORPORTS,              0x0089e4),
+	REG(ANA_FLOODING,                  0x0089e8),
+	REG(ANA_FLOODING_IPMC,             0x008a08),
+	REG(ANA_SFLOW_CFG,                 0x008a0c),
+	REG(ANA_PORT_MODE,                 0x008a28),
+	REG(ANA_CUT_THRU_CFG,              0x008a48),
+	REG(ANA_PGID_PGID,                 0x008400),
+	REG(ANA_TABLES_ANMOVED,            0x007f1c),
+	REG(ANA_TABLES_MACHDATA,           0x007f20),
+	REG(ANA_TABLES_MACLDATA,           0x007f24),
+	REG(ANA_TABLES_STREAMDATA,         0x007f28),
+	REG(ANA_TABLES_MACACCESS,          0x007f2c),
+	REG(ANA_TABLES_MACTINDX,           0x007f30),
+	REG(ANA_TABLES_VLANACCESS,         0x007f34),
+	REG(ANA_TABLES_VLANTIDX,           0x007f38),
+	REG(ANA_TABLES_ISDXACCESS,         0x007f3c),
+	REG(ANA_TABLES_ISDXTIDX,           0x007f40),
+	REG(ANA_TABLES_ENTRYLIM,           0x007f00),
+	REG(ANA_TABLES_PTP_ID_HIGH,        0x007f44),
+	REG(ANA_TABLES_PTP_ID_LOW,         0x007f48),
+	REG(ANA_TABLES_STREAMACCESS,       0x007f4c),
+	REG(ANA_TABLES_STREAMTIDX,         0x007f50),
+	REG(ANA_TABLES_SEQ_HISTORY,        0x007f54),
+	REG(ANA_TABLES_SEQ_MASK,           0x007f58),
+	REG(ANA_TABLES_SFID_MASK,          0x007f5c),
+	REG(ANA_TABLES_SFIDACCESS,         0x007f60),
+	REG(ANA_TABLES_SFIDTIDX,           0x007f64),
+	REG(ANA_MSTI_STATE,                0x008600),
+	REG(ANA_OAM_UPM_LM_CNT,            0x008000),
+	REG(ANA_SG_ACCESS_CTRL,            0x008a64),
+	REG(ANA_SG_CONFIG_REG_1,           0x007fb0),
+	REG(ANA_SG_CONFIG_REG_2,           0x007fb4),
+	REG(ANA_SG_CONFIG_REG_3,           0x007fb8),
+	REG(ANA_SG_CONFIG_REG_4,           0x007fbc),
+	REG(ANA_SG_CONFIG_REG_5,           0x007fc0),
+	REG(ANA_SG_GCL_GS_CONFIG,          0x007f80),
+	REG(ANA_SG_GCL_TI_CONFIG,          0x007f90),
+	REG(ANA_SG_STATUS_REG_1,           0x008980),
+	REG(ANA_SG_STATUS_REG_2,           0x008984),
+	REG(ANA_SG_STATUS_REG_3,           0x008988),
+	REG(ANA_PORT_VLAN_CFG,             0x007800),
+	REG(ANA_PORT_DROP_CFG,             0x007804),
+	REG(ANA_PORT_QOS_CFG,              0x007808),
+	REG(ANA_PORT_VCAP_CFG,             0x00780c),
+	REG(ANA_PORT_VCAP_S1_KEY_CFG,      0x007810),
+	REG(ANA_PORT_VCAP_S2_CFG,          0x00781c),
+	REG(ANA_PORT_PCP_DEI_MAP,          0x007820),
+	REG(ANA_PORT_CPU_FWD_CFG,          0x007860),
+	REG(ANA_PORT_CPU_FWD_BPDU_CFG,     0x007864),
+	REG(ANA_PORT_CPU_FWD_GARP_CFG,     0x007868),
+	REG(ANA_PORT_CPU_FWD_CCM_CFG,      0x00786c),
+	REG(ANA_PORT_PORT_CFG,             0x007870),
+	REG(ANA_PORT_POL_CFG,              0x007874),
+	REG(ANA_PORT_PTP_CFG,              0x007878),
+	REG(ANA_PORT_PTP_DLY1_CFG,         0x00787c),
+	REG(ANA_PORT_PTP_DLY2_CFG,         0x007880),
+	REG(ANA_PORT_SFID_CFG,             0x007884),
+	REG(ANA_PFC_PFC_CFG,               0x008800),
+	REG(ANA_PFC_PFC_TIMER,             0x008804),
+	REG(ANA_IPT_OAM_MEP_CFG,           0x007000),
+	REG(ANA_IPT_IPT,                   0x007004),
+	REG(ANA_PPT_PPT,                   0x007fd0),
+	REG(ANA_FID_MAP_FID_MAP,           0x000000),
+	REG(ANA_AGGR_CFG,                  0x008a68),
+	REG(ANA_CPUQ_CFG,                  0x008a6c),
+	REG(ANA_CPUQ_CFG2,                 0x008a70),
+	REG(ANA_CPUQ_8021_CFG,             0x008a74),
+	REG(ANA_DSCP_CFG,                  0x008ab4),
+	REG(ANA_DSCP_REWR_CFG,             0x008bb4),
+	REG(ANA_VCAP_RNG_TYPE_CFG,         0x008bf4),
+	REG(ANA_VCAP_RNG_VAL_CFG,          0x008c14),
+	REG(ANA_VRAP_CFG,                  0x008c34),
+	REG(ANA_VRAP_HDR_DATA,             0x008c38),
+	REG(ANA_VRAP_HDR_MASK,             0x008c3c),
+	REG(ANA_DISCARD_CFG,               0x008c40),
+	REG(ANA_FID_CFG,                   0x008c44),
+	REG(ANA_POL_PIR_CFG,               0x004000),
+	REG(ANA_POL_CIR_CFG,               0x004004),
+	REG(ANA_POL_MODE_CFG,              0x004008),
+	REG(ANA_POL_PIR_STATE,             0x00400c),
+	REG(ANA_POL_CIR_STATE,             0x004010),
+	REG(ANA_POL_STATE,                 0x004014),
+	REG(ANA_POL_FLOWC,                 0x008c48),
+	REG(ANA_POL_HYST,                  0x008cb4),
+	REG(ANA_POL_MISC_CFG,              0x008c94),
+};
+
+static const u32 felix_qs_regmap[] = {
+	REG(QS_XTR_GRP_CFG,                0x000000),
+	REG(QS_XTR_RD,                     0x000008),
+	REG(QS_XTR_FRM_PRUNING,            0x000010),
+	REG(QS_XTR_FLUSH,                  0x000018),
+	REG(QS_XTR_DATA_PRESENT,           0x00001c),
+	REG(QS_XTR_CFG,                    0x000020),
+	REG(QS_INJ_GRP_CFG,                0x000024),
+	REG(QS_INJ_WR,                     0x00002c),
+	REG(QS_INJ_CTRL,                   0x000034),
+	REG(QS_INJ_STATUS,                 0x00003c),
+	REG(QS_INJ_ERR,                    0x000040),
+	REG(QS_INH_DBG,                    0x000048),
+};
+
+static const u32 felix_qsys_regmap[] = {
+	REG(QSYS_PORT_MODE,                0x00f460),
+	REG(QSYS_SWITCH_PORT_MODE,         0x00f480),
+	REG(QSYS_STAT_CNT_CFG,             0x00f49c),
+	REG(QSYS_EEE_CFG,                  0x00f4a0),
+	REG(QSYS_EEE_THRES,                0x00f4b8),
+	REG(QSYS_IGR_NO_SHARING,           0x00f4bc),
+	REG(QSYS_EGR_NO_SHARING,           0x00f4c0),
+	REG(QSYS_SW_STATUS,                0x00f4c4),
+	REG(QSYS_EXT_CPU_CFG,              0x00f4e0),
+	REG(QSYS_PAD_CFG,                  0x00f4e4),
+	REG(QSYS_CPU_GROUP_MAP,            0x00f4e8),
+	REG(QSYS_QMAP,                     0x00f4ec),
+	REG(QSYS_ISDX_SGRP,                0x00f000),
+	REG(QSYS_TIMED_FRAME_ENTRY,        0x00e000),
+	REG(QSYS_TFRM_MISC,                0x00f50c),
+	REG(QSYS_TFRM_PORT_DLY,            0x00f510),
+	REG(QSYS_TFRM_TIMER_CFG_1,         0x00f514),
+	REG(QSYS_TFRM_TIMER_CFG_2,         0x00f518),
+	REG(QSYS_TFRM_TIMER_CFG_3,         0x00f51c),
+	REG(QSYS_TFRM_TIMER_CFG_4,         0x00f520),
+	REG(QSYS_TFRM_TIMER_CFG_5,         0x00f524),
+	REG(QSYS_TFRM_TIMER_CFG_6,         0x00f528),
+	REG(QSYS_TFRM_TIMER_CFG_7,         0x00f52c),
+	REG(QSYS_TFRM_TIMER_CFG_8,         0x00f530),
+	REG(QSYS_RED_PROFILE,              0x00f534),
+	REG(QSYS_RES_QOS_MODE,             0x00f574),
+	REG(QSYS_RES_CFG,                  0x00c000),
+	REG(QSYS_RES_STAT,                 0x00c004),
+	REG(QSYS_EGR_DROP_MODE,            0x00f578),
+	REG(QSYS_EQ_CTRL,                  0x00f57c),
+	REG(QSYS_EVENTS_CORE,              0x00f580),
+	REG(QSYS_QMAXSDU_CFG_0,            0x00f584),
+	REG(QSYS_QMAXSDU_CFG_1,            0x00f5a0),
+	REG(QSYS_QMAXSDU_CFG_2,            0x00f5bc),
+	REG(QSYS_QMAXSDU_CFG_3,            0x00f5d8),
+	REG(QSYS_QMAXSDU_CFG_4,            0x00f5f4),
+	REG(QSYS_QMAXSDU_CFG_5,            0x00f610),
+	REG(QSYS_QMAXSDU_CFG_6,            0x00f62c),
+	REG(QSYS_QMAXSDU_CFG_7,            0x00f648),
+	REG(QSYS_PREEMPTION_CFG,           0x00f664),
+	REG(QSYS_CIR_CFG,                  0x000000),
+	REG(QSYS_EIR_CFG,                  0x000004),
+	REG(QSYS_SE_CFG,                   0x000008),
+	REG(QSYS_SE_DWRR_CFG,              0x00000c),
+	REG(QSYS_SE_CONNECT,               0x00003c),
+	REG(QSYS_SE_DLB_SENSE,             0x000040),
+	REG(QSYS_CIR_STATE,                0x000044),
+	REG(QSYS_EIR_STATE,                0x000048),
+	REG(QSYS_SE_STATE,                 0x00004c),
+	REG(QSYS_HSCH_MISC_CFG,            0x00f67c),
+	REG(QSYS_TAG_CONFIG,               0x00f680),
+	REG(QSYS_TAS_PARAM_CFG_CTRL,       0x00f698),
+	REG(QSYS_PORT_MAX_SDU,             0x00f69c),
+	REG(QSYS_PARAM_CFG_REG_1,          0x00f440),
+	REG(QSYS_PARAM_CFG_REG_2,          0x00f444),
+	REG(QSYS_PARAM_CFG_REG_3,          0x00f448),
+	REG(QSYS_PARAM_CFG_REG_4,          0x00f44c),
+	REG(QSYS_PARAM_CFG_REG_5,          0x00f450),
+	REG(QSYS_GCL_CFG_REG_1,            0x00f454),
+	REG(QSYS_GCL_CFG_REG_2,            0x00f458),
+	REG(QSYS_PARAM_STATUS_REG_1,       0x00f400),
+	REG(QSYS_PARAM_STATUS_REG_2,       0x00f404),
+	REG(QSYS_PARAM_STATUS_REG_3,       0x00f408),
+	REG(QSYS_PARAM_STATUS_REG_4,       0x00f40c),
+	REG(QSYS_PARAM_STATUS_REG_5,       0x00f410),
+	REG(QSYS_PARAM_STATUS_REG_6,       0x00f414),
+	REG(QSYS_PARAM_STATUS_REG_7,       0x00f418),
+	REG(QSYS_PARAM_STATUS_REG_8,       0x00f41c),
+	REG(QSYS_PARAM_STATUS_REG_9,       0x00f420),
+	REG(QSYS_GCL_STATUS_REG_1,         0x00f424),
+	REG(QSYS_GCL_STATUS_REG_2,         0x00f428),
+};
+
+static const u32 felix_rew_regmap[] = {
+	REG(REW_PORT_VLAN_CFG,             0x000000),
+	REG(REW_TAG_CFG,                   0x000004),
+	REG(REW_PORT_CFG,                  0x000008),
+	REG(REW_DSCP_CFG,                  0x00000c),
+	REG(REW_PCP_DEI_QOS_MAP_CFG,       0x000010),
+	REG(REW_PTP_CFG,                   0x000050),
+	REG(REW_PTP_DLY1_CFG,              0x000054),
+	REG(REW_RED_TAG_CFG,               0x000058),
+	REG(REW_DSCP_REMAP_DP1_CFG,        0x000410),
+	REG(REW_DSCP_REMAP_CFG,            0x000510),
+	REG(REW_STAT_CFG,                  0x000610),
+	REG(REW_REW_STICKY,                0x000614),
+	REG(REW_PPT,                       0x000400),
+};
+
+static const u32 felix_sys_regmap[] = {
+	REG(SYS_RESET_CFG,                 0x000e00),
+	REG(SYS_SR_ETYPE_CFG,              0x000e04),
+	REG(SYS_VLAN_ETYPE_CFG,            0x000e08),
+	REG(SYS_PORT_MODE,                 0x000e0c),
+	REG(SYS_FRONT_PORT_MODE,           0x000e2c),
+	REG(SYS_FRM_AGING,                 0x000e44),
+	REG(SYS_STAT_CFG,                  0x000e48),
+	REG(SYS_SW_STATUS,                 0x000e4c),
+	REG(SYS_MISC_CFG,                  0x000e68),
+	REG(SYS_REW_MAC_HIGH_CFG,          0x000e6c),
+	REG(SYS_REW_MAC_LOW_CFG,           0x000e84),
+	REG(SYS_TIMESTAMP_OFFSET,          0x000e9c),
+	REG(SYS_PAUSE_CFG,                 0x000ea0),
+	REG(SYS_PAUSE_TOT_CFG,             0x000ebc),
+	REG(SYS_ATOP,                      0x000ec0),
+	REG(SYS_ATOP_TOT_CFG,              0x000edc),
+	REG(SYS_MAC_FC_CFG,                0x000ee0),
+	REG(SYS_MMGT,                      0x000ef8),
+	REG(SYS_MMGT_FAST,                 0x000efc),
+	REG(SYS_EVENTS_DIF,                0x000f00),
+	REG(SYS_EVENTS_CORE,               0x000f10),
+	REG(SYS_CNT,                       0x000000),
+	REG(SYS_PTP_STATUS,                0x000f14),
+	REG(SYS_PTP_TXSTAMP,               0x000f18),
+	REG(SYS_PTP_NXT,                   0x000f1c),
+	REG(SYS_PTP_CFG,                   0x000f20),
+	REG(SYS_RAM_INIT,                  0x000f24),
+	REG(SYS_CM_ADDR,                   0x000f28),
+	REG(SYS_CM_DATA_WR,                0x000f2c),
+	REG(SYS_CM_DATA_RD,                0x000f30),
+	REG(SYS_CM_OP,                     0x000f34),
+};
+
+static const u32 *felix_regmap[] = {
+	[ANA] = felix_ana_regmap,
+	[QS] = felix_qs_regmap,
+	[QSYS] = felix_qsys_regmap,
+	[REW] = felix_rew_regmap,
+	[SYS] = felix_sys_regmap,
+};
+
+static const struct reg_field felix_regfields[] = {
+	[ANA_ADVLEARN_VLAN_CHK] = REG_FIELD(ANA_ADVLEARN, 6, 6),
+	[ANA_ADVLEARN_LEARN_MIRROR] = REG_FIELD(ANA_ADVLEARN, 0, 5),
+	[ANA_ANEVENTS_FLOOD_DISCARD] = REG_FIELD(ANA_ANEVENTS, 30, 30),
+	[ANA_ANEVENTS_MSTI_DROP] = REG_FIELD(ANA_ANEVENTS, 29, 29),
+	[ANA_ANEVENTS_ACLKILL] = REG_FIELD(ANA_ANEVENTS, 28, 28),
+	[ANA_ANEVENTS_ACLUSED] = REG_FIELD(ANA_ANEVENTS, 27, 27),
+	[ANA_ANEVENTS_AUTOAGE] = REG_FIELD(ANA_ANEVENTS, 26, 26),
+	[ANA_ANEVENTS_VS2TTL1] = REG_FIELD(ANA_ANEVENTS, 25, 25),
+	[ANA_ANEVENTS_STORM_DROP] = REG_FIELD(ANA_ANEVENTS, 24, 24),
+	[ANA_ANEVENTS_LEARN_DROP] = REG_FIELD(ANA_ANEVENTS, 23, 23),
+	[ANA_ANEVENTS_AGED_ENTRY] = REG_FIELD(ANA_ANEVENTS, 22, 22),
+	[ANA_ANEVENTS_CPU_LEARN_FAILED] = REG_FIELD(ANA_ANEVENTS, 21, 21),
+	[ANA_ANEVENTS_AUTO_LEARN_FAILED] = REG_FIELD(ANA_ANEVENTS, 20, 20),
+	[ANA_ANEVENTS_LEARN_REMOVE] = REG_FIELD(ANA_ANEVENTS, 19, 19),
+	[ANA_ANEVENTS_AUTO_LEARNED] = REG_FIELD(ANA_ANEVENTS, 18, 18),
+	[ANA_ANEVENTS_AUTO_MOVED] = REG_FIELD(ANA_ANEVENTS, 17, 17),
+	[ANA_ANEVENTS_DROPPED] = REG_FIELD(ANA_ANEVENTS, 16, 16),
+	[ANA_ANEVENTS_CLASSIFIED_DROP] = REG_FIELD(ANA_ANEVENTS, 15, 15),
+	[ANA_ANEVENTS_CLASSIFIED_COPY] = REG_FIELD(ANA_ANEVENTS, 14, 14),
+	[ANA_ANEVENTS_VLAN_DISCARD] = REG_FIELD(ANA_ANEVENTS, 13, 13),
+	[ANA_ANEVENTS_FWD_DISCARD] = REG_FIELD(ANA_ANEVENTS, 12, 12),
+	[ANA_ANEVENTS_MULTICAST_FLOOD] = REG_FIELD(ANA_ANEVENTS, 11, 11),
+	[ANA_ANEVENTS_UNICAST_FLOOD] = REG_FIELD(ANA_ANEVENTS, 10, 10),
+	[ANA_ANEVENTS_DEST_KNOWN] = REG_FIELD(ANA_ANEVENTS, 9, 9),
+	[ANA_ANEVENTS_BUCKET3_MATCH] = REG_FIELD(ANA_ANEVENTS, 8, 8),
+	[ANA_ANEVENTS_BUCKET2_MATCH] = REG_FIELD(ANA_ANEVENTS, 7, 7),
+	[ANA_ANEVENTS_BUCKET1_MATCH] = REG_FIELD(ANA_ANEVENTS, 6, 6),
+	[ANA_ANEVENTS_BUCKET0_MATCH] = REG_FIELD(ANA_ANEVENTS, 5, 5),
+	[ANA_ANEVENTS_CPU_OPERATION] = REG_FIELD(ANA_ANEVENTS, 4, 4),
+	[ANA_ANEVENTS_DMAC_LOOKUP] = REG_FIELD(ANA_ANEVENTS, 3, 3),
+	[ANA_ANEVENTS_SMAC_LOOKUP] = REG_FIELD(ANA_ANEVENTS, 2, 2),
+	[ANA_ANEVENTS_SEQ_GEN_ERR_0] = REG_FIELD(ANA_ANEVENTS, 1, 1),
+	[ANA_ANEVENTS_SEQ_GEN_ERR_1] = REG_FIELD(ANA_ANEVENTS, 0, 0),
+	[ANA_TABLES_MACACCESS_B_DOM] = REG_FIELD(ANA_TABLES_MACACCESS, 16, 16),
+	[ANA_TABLES_MACTINDX_BUCKET] = REG_FIELD(ANA_TABLES_MACTINDX, 11, 12),
+	[ANA_TABLES_MACTINDX_M_INDEX] = REG_FIELD(ANA_TABLES_MACTINDX, 0, 10),
+	[QSYS_TIMED_FRAME_ENTRY_TFRM_VLD] = REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 19, 19),
+	[QSYS_TIMED_FRAME_ENTRY_TFRM_FP] = REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 7, 18),
+	[QSYS_TIMED_FRAME_ENTRY_TFRM_PORTNO] = REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 4, 6),
+	[QSYS_TIMED_FRAME_ENTRY_TFRM_TM_SEL] = REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 1, 3),
+	[QSYS_TIMED_FRAME_ENTRY_TFRM_TM_T] = REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 0, 0),
+	[SYS_RESET_CFG_CORE_ENA] = REG_FIELD(SYS_RESET_CFG, 0, 0),
+};
+
+static const struct ocelot_stat_layout felix_stats_layout[] = {
+	{ .name = "rx_octets", .offset = 0x00, },
+	{ .name = "rx_unicast", .offset = 0x01, },
+	{ .name = "rx_multicast", .offset = 0x02, },
+	{ .name = "rx_broadcast", .offset = 0x03, },
+	{ .name = "rx_shorts", .offset = 0x04, },
+	{ .name = "rx_fragments", .offset = 0x05, },
+	{ .name = "rx_jabbers", .offset = 0x06, },
+	{ .name = "rx_crc_align_errs", .offset = 0x07, },
+	{ .name = "rx_sym_errs", .offset = 0x08, },
+	{ .name = "rx_frames_below_65_octets", .offset = 0x09, },
+	{ .name = "rx_frames_65_to_127_octets", .offset = 0x0A, },
+	{ .name = "rx_frames_128_to_255_octets", .offset = 0x0B, },
+	{ .name = "rx_frames_256_to_511_octets", .offset = 0x0C, },
+	{ .name = "rx_frames_512_to_1023_octets", .offset = 0x0D, },
+	{ .name = "rx_frames_1024_to_1526_octets", .offset = 0x0E, },
+	{ .name = "rx_frames_over_1526_octets", .offset = 0x0F, },
+	{ .name = "rx_pause", .offset = 0x10, },
+	{ .name = "rx_control", .offset = 0x11, },
+	{ .name = "rx_longs", .offset = 0x12, },
+	{ .name = "rx_classified_drops", .offset = 0x13, },
+	{ .name = "rx_red_prio_0", .offset = 0x14, },
+	{ .name = "rx_red_prio_1", .offset = 0x15, },
+	{ .name = "rx_red_prio_2", .offset = 0x16, },
+	{ .name = "rx_red_prio_3", .offset = 0x17, },
+	{ .name = "rx_red_prio_4", .offset = 0x18, },
+	{ .name = "rx_red_prio_5", .offset = 0x19, },
+	{ .name = "rx_red_prio_6", .offset = 0x1A, },
+	{ .name = "rx_red_prio_7", .offset = 0x1B, },
+	{ .name = "rx_yellow_prio_0", .offset = 0x1C, },
+	{ .name = "rx_yellow_prio_1", .offset = 0x1D, },
+	{ .name = "rx_yellow_prio_2", .offset = 0x1E, },
+	{ .name = "rx_yellow_prio_3", .offset = 0x1F, },
+	{ .name = "rx_yellow_prio_4", .offset = 0x20, },
+	{ .name = "rx_yellow_prio_5", .offset = 0x21, },
+	{ .name = "rx_yellow_prio_6", .offset = 0x22, },
+	{ .name = "rx_yellow_prio_7", .offset = 0x23, },
+	{ .name = "rx_green_prio_0", .offset = 0x24, },
+	{ .name = "rx_green_prio_1", .offset = 0x25, },
+	{ .name = "rx_green_prio_2", .offset = 0x26, },
+	{ .name = "rx_green_prio_3", .offset = 0x27, },
+	{ .name = "rx_green_prio_4", .offset = 0x28, },
+	{ .name = "rx_green_prio_5", .offset = 0x29, },
+	{ .name = "rx_green_prio_6", .offset = 0x2A, },
+	{ .name = "rx_green_prio_7", .offset = 0x2B, },
+	{ .name = "tx_octets", .offset = 0x80, },
+	{ .name = "tx_unicast", .offset = 0x81, },
+	{ .name = "tx_multicast", .offset = 0x82, },
+	{ .name = "tx_broadcast", .offset = 0x83, },
+	{ .name = "tx_collision", .offset = 0x84, },
+	{ .name = "tx_drops", .offset = 0x85, },
+	{ .name = "tx_pause", .offset = 0x86, },
+	{ .name = "tx_frames_below_65_octets", .offset = 0x87, },
+	{ .name = "tx_frames_65_to_127_octets", .offset = 0x88, },
+	{ .name = "tx_frames_128_255_octets", .offset = 0x89, },
+	{ .name = "tx_frames_256_511_octets", .offset = 0x8A, },
+	{ .name = "tx_frames_512_1023_octets", .offset = 0x8B, },
+	{ .name = "tx_frames_1024_1526_octets", .offset = 0x8C, },
+	{ .name = "tx_frames_over_1526_octets", .offset = 0x8D, },
+	{ .name = "tx_yellow_prio_0", .offset = 0x8E, },
+	{ .name = "tx_yellow_prio_1", .offset = 0x8F, },
+	{ .name = "tx_yellow_prio_2", .offset = 0x90, },
+	{ .name = "tx_yellow_prio_3", .offset = 0x91, },
+	{ .name = "tx_yellow_prio_4", .offset = 0x92, },
+	{ .name = "tx_yellow_prio_5", .offset = 0x93, },
+	{ .name = "tx_yellow_prio_6", .offset = 0x94, },
+	{ .name = "tx_yellow_prio_7", .offset = 0x95, },
+	{ .name = "tx_green_prio_0", .offset = 0x96, },
+	{ .name = "tx_green_prio_1", .offset = 0x97, },
+	{ .name = "tx_green_prio_2", .offset = 0x98, },
+	{ .name = "tx_green_prio_3", .offset = 0x99, },
+	{ .name = "tx_green_prio_4", .offset = 0x9A, },
+	{ .name = "tx_green_prio_5", .offset = 0x9B, },
+	{ .name = "tx_green_prio_6", .offset = 0x9C, },
+	{ .name = "tx_green_prio_7", .offset = 0x9D, },
+	{ .name = "tx_aged", .offset = 0x9E, },
+	{ .name = "drop_local", .offset = 0x100, },
+	{ .name = "drop_tail", .offset = 0x101, },
+	{ .name = "drop_yellow_prio_0", .offset = 0x102, },
+	{ .name = "drop_yellow_prio_1", .offset = 0x103, },
+	{ .name = "drop_yellow_prio_2", .offset = 0x104, },
+	{ .name = "drop_yellow_prio_3", .offset = 0x105, },
+	{ .name = "drop_yellow_prio_4", .offset = 0x106, },
+	{ .name = "drop_yellow_prio_5", .offset = 0x107, },
+	{ .name = "drop_yellow_prio_6", .offset = 0x108, },
+	{ .name = "drop_yellow_prio_7", .offset = 0x109, },
+	{ .name = "drop_green_prio_0", .offset = 0x10A, },
+	{ .name = "drop_green_prio_1", .offset = 0x10B, },
+	{ .name = "drop_green_prio_2", .offset = 0x10C, },
+	{ .name = "drop_green_prio_3", .offset = 0x10D, },
+	{ .name = "drop_green_prio_4", .offset = 0x10E, },
+	{ .name = "drop_green_prio_5", .offset = 0x10F, },
+	{ .name = "drop_green_prio_6", .offset = 0x110, },
+	{ .name = "drop_green_prio_7", .offset = 0x111, },
+};
+
+int felix_chip_init(struct ocelot *ocelot)
+{
+	int ret;
+
+	ocelot->map = felix_regmap;
+	ocelot->stats_layout = felix_stats_layout;
+	ocelot->num_stats = ARRAY_SIZE(felix_stats_layout);
+	ocelot->shared_queue_sz = 128 * 1024;
+
+	ret = ocelot_regfields_init(ocelot, felix_regfields);
+	if (ret)
+		return ret;
+
+	eth_random_addr(ocelot->base_mac);
+	ocelot->base_mac[5] &= 0xf0;
+	return 0;
+}
+EXPORT_SYMBOL(felix_chip_init);
-- 
2.17.1


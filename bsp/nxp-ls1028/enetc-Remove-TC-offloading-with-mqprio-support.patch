From 1cda934b4343fbd9687899cd61969dccdacd94a4 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@nxp.com>
Date: Wed, 24 Oct 2018 18:09:58 +0300
Subject: [PATCH 468/706] enetc: Remove TC offloading with mqprio support

Temporarily remove this feature as it needs to be re-validated,
and to sync with the upstream driver (which also doesn't include this
feature).

Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
(cherry picked from commit 32d5e571e50172a834aa4c3fb5904b93e8d78c17)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c  | 78 +------------------
 drivers/net/ethernet/freescale/enetc/enetc.h  | 12 +--
 .../net/ethernet/freescale/enetc/enetc_pf.c   |  1 -
 .../net/ethernet/freescale/enetc/enetc_vf.c   |  1 -
 4 files changed, 4 insertions(+), 88 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index 3bfd0a8e2c6e..a4bca12d08b5 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -43,15 +43,9 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	struct enetc_bdr *tx_ring;
-	int count, prio;
+	int count;
 
-	if (ndev->num_tc) {
-		/* Choose the TX BD ring based on the skb's priority mapping */
-		prio = netdev_get_prio_tc_map(ndev, skb->priority);
-		tx_ring = priv->tx_ring[prio];
-	} else {
-		tx_ring = priv->tx_ring[skb->queue_mapping];
-	}
+	tx_ring = priv->tx_ring[skb->queue_mapping];
 
 	if (enetc_bd_unused(tx_ring) < ENETC_FREE_TXBD_NEEDED) {
 		netif_stop_subqueue(ndev, tx_ring->index);
@@ -1303,7 +1297,7 @@ int enetc_open(struct net_device *ndev)
 
 	enetc_setup_bdrs(priv);
 
-	err = netif_set_real_num_tx_queues(ndev, ENETC_DEFAULT_NUM_TXQS);
+	err = netif_set_real_num_tx_queues(ndev, priv->num_tx_rings);
 	if (err)
 		goto err_set_queues;
 
@@ -1363,72 +1357,6 @@ int enetc_close(struct net_device *ndev)
 	return 0;
 }
 
-int enetc_setup_tc(struct net_device *ndev, enum tc_setup_type type,
-		   void *type_data)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct tc_mqprio_qopt *mqprio = type_data;
-	struct enetc_bdr *tx_ring;
-	int i;
-	u8 num_tc;
-	u32 val;
-
-	if (type != TC_SETUP_MQPRIO)
-		return -EOPNOTSUPP;
-
-	mqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;
-	num_tc = mqprio->num_tc;
-
-	if (!num_tc) {
-		netdev_reset_tc(ndev);
-		netif_set_real_num_tx_queues(ndev, ENETC_TXQ_PER_TC);
-
-		/* Reset all ring priorities to 0 */
-		for (i = 0; i < priv->num_tx_rings; i++) {
-			tx_ring = priv->tx_ring[i];
-			val = enetc_txbdr_rd(&priv->si->hw, tx_ring->index,
-					     ENETC_TBMR);
-			val &= ~ENETC_TBMR_PRIO_MASK;
-			enetc_txbdr_wr(&priv->si->hw, tx_ring->index,
-				       ENETC_TBMR, val);
-		}
-
-		return 0;
-	}
-
-	/* Check if we have enough BD rings available to accommodate all TCs */
-	if (num_tc > priv->num_tx_rings) {
-		netdev_err(ndev, "Max %d traffic classes supported\n",
-			   priv->num_tx_rings);
-		return -EINVAL;
-	}
-
-	/* For the moment, we use only one BD ring per TC.
-	 *
-	 * Configure num_tc BD rings with increasing priorities.
-	 */
-	for (i = 0; i < num_tc; i++) {
-		tx_ring = priv->tx_ring[i];
-		val = enetc_txbdr_rd(&priv->si->hw, tx_ring->index, ENETC_TBMR);
-		/* Clear the old priority and set the new one */
-		val &= ~ENETC_TBMR_PRIO_MASK;
-		val |= ENETC_TBMR_PRIO_SET(i);
-		enetc_txbdr_wr(&priv->si->hw, tx_ring->index, ENETC_TBMR, val);
-	}
-
-	/* Reset the number of netdev queues based on the TC count */
-	netif_set_real_num_tx_queues(ndev, num_tc * ENETC_TXQ_PER_TC);
-
-	netdev_set_num_tc(ndev, num_tc);
-
-	/* Each TC is associated with ENETC_TXQ_PER_TC netdev queues */
-	for (i = 0; i < num_tc; i++)
-		netdev_set_tc_queue(ndev, i, ENETC_TXQ_PER_TC,
-				    i * ENETC_TXQ_PER_TC);
-
-	return 0;
-}
-
 struct net_device_stats *enetc_get_stats(struct net_device *ndev)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index 581d77357f49..323816cc8049 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -172,15 +172,7 @@ static inline bool enetc_si_is_pf(struct enetc_si *si)
 	return !!(si->hw.port);
 }
 
-#define ENETC_MAX_TCS		8
-#define ENETC_TXQ_PER_TC	num_online_cpus()
-#define ENETC_MAX_NUM_TXQS	(ENETC_MAX_TCS * ENETC_TXQ_PER_TC)
-
-#ifdef CONFIG_ENETC_TSN
-#define ENETC_DEFAULT_NUM_TXQS 8
-#else
-#define ENETC_DEFAULT_NUM_TXQS ENETC_TXQ_PER_TC
-#endif
+#define ENETC_MAX_NUM_TXQS	8
 
 struct enetc_int_vector {
 	void __iomem *rbier;
@@ -255,8 +247,6 @@ struct net_device_stats *enetc_get_stats(struct net_device *ndev);
 int enetc_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 int enetc_set_features(struct net_device *ndev,
 		       netdev_features_t features);
-int enetc_setup_tc(struct net_device *ndev, enum tc_setup_type type,
-		   void *type_data);
 /* ethtool */
 void enetc_set_ethtool_ops(struct net_device *ndev);
 
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
index 9f43e22278cf..d35bfa9853a0 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
@@ -638,7 +638,6 @@ static const struct net_device_ops enetc_ndev_ops = {
 	.ndo_set_vf_vlan	= enetc_pf_set_vf_vlan,
 	.ndo_set_vf_spoofchk	= enetc_pf_set_vf_spoofchk,
 	.ndo_set_features	= enetc_pf_set_features,
-	.ndo_setup_tc		= enetc_setup_tc,
 	.ndo_do_ioctl		= enetc_ioctl,
 };
 
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_vf.c b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
index 8606213b3057..440b0f200876 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_vf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
@@ -104,7 +104,6 @@ static const struct net_device_ops enetc_ndev_ops = {
 	.ndo_start_xmit		= enetc_xmit,
 	.ndo_get_stats		= enetc_get_stats,
 	.ndo_set_mac_address	= enetc_vf_set_mac_addr,
-	.ndo_setup_tc		= enetc_setup_tc,
 	.ndo_do_ioctl		= enetc_ioctl,
 };
 
-- 
2.17.1


From bfa44f2aefe750ecb2c9e2803c75865fcc24ae74 Mon Sep 17 00:00:00 2001
From: Po Liu <Po.Liu@nxp.com>
Date: Tue, 18 Dec 2018 16:48:59 +0800
Subject: [PATCH 420/706] enetc-tsn: remove some tsn cbdr get status
 information

Include Qbv/Qci, expose to application layer

Signed-off-by: Po Liu <Po.Liu@nxp.com>
(cherry picked from commit 4944cb63fc0c6ec991e50b2c3053803afac67928)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../net/ethernet/freescale/enetc/enetc_tsn.c  | 28 ++++---------------
 include/net/tsn.h                             |  3 +-
 include/uapi/linux/tsn.h                      | 11 ++++++++
 net/tsn/genl_tsn.c                            | 25 ++++++++++-------
 4 files changed, 34 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
index 3e7d67f5ec25..300e5053a41a 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
@@ -328,11 +328,8 @@ int enetc_qbv_get(struct net_device *ndev, struct tsn_qbv_conf *admin_conf)
 	cbdr->addr[1] = upper_32_bits(dma);
 	cbdr->cmd = 1;
 	cbdr->cls = BDCR_CMD_PORT_GCL;
-	DUMP_CBDR(cbdr);
 	xmit_cbdr(priv->si, curr_cbd);
 	dma_unmap_single(&priv->si->pdev->dev, dma, data_size, DMA_FROM_DEVICE);
-	DUMP_CBDR(cbdr);
-	DUMP_DATA((char *)gcl_data, data_size);
 
 	/* since cbdr already passed to free, below could be get wrong */
 	admin_len = le16_to_cpu(gcl_query->admin_list_len);
@@ -437,18 +434,13 @@ int enetc_qbv_get_status(struct net_device *ndev,
 	cbdr->addr[1] = upper_32_bits(dma);
 	cbdr->cmd = 1;
 	cbdr->cls = BDCR_CMD_PORT_GCL;
-	DUMP_CBDR(cbdr);
 	xmit_cbdr(priv->si, curr_cbd);
 	dma_unmap_single(&priv->si->pdev->dev, dma, data_size, DMA_FROM_DEVICE);
-	DUMP_CBDR(cbdr);
-	DUMP_DATA((char *)gcl_data, data_size);
 
 	/* since cbdr already passed to free, below could be get wrong */
 	admin_len = le16_to_cpu(gcl_query->admin_list_len);
 	oper_len = le16_to_cpu(gcl_query->oper_list_len);
 
-	gce += admin_len;
-
 	if (enetc_rd(&priv->si->hw, QBV_PTGAGLSR_OFFSET) &
 						QBV_CFG_PEND_MASK) {
 		status->config_pending = true;
@@ -492,9 +484,8 @@ int enetc_qbv_get_status(struct net_device *ndev,
 	}
 
 	for (i = 0; i < oper_len; i++) {
-		struct gce *temp_gce = gce + i;
+		struct gce *temp_gce = gce + maxlen + i;
 		struct tsn_qbv_entry *temp_entry = oper_basic->control_list + i;
-
 		temp_entry->gate_state = temp_gce->gate;
 		temp_entry->time_interval = le32_to_cpu(temp_gce->period);
 	}
@@ -708,7 +699,6 @@ int enetc_cb_streamid_get(struct net_device *ndev, u32 index,
 		/* VID Match. If set (b1) then the VID must match, otherwise
 		 * any VID is considered a match.
 		*/
-		/* if (si_data->vid_vidm_tg & ENETC_CBDR_SID_VIDM) */
 		streamid->para.nid.vid =
 				le16_to_cpu(si_data->vid_vidm_tg & ENETC_CBDR_SID_VID_MASK);
 		streamid->para.nid.tagged =
@@ -720,7 +710,6 @@ int enetc_cb_streamid_get(struct net_device *ndev, u32 index,
 		/* VID Match. If set (b1) then the VID must match, otherwise
 		 * any VID is considered a match.
 		 */
-		/* if (si_data->vid_vidm_tg & ENETC_CBDR_SID_VIDM) */
 		streamid->para.sid.vid =
 				le16_to_cpu(si_data->vid_vidm_tg & ENETC_CBDR_SID_VID_MASK);
 		streamid->para.sid.tagged =
@@ -729,7 +718,7 @@ int enetc_cb_streamid_get(struct net_device *ndev, u32 index,
 
 	streamid->handle = le32_to_cpu(si_data->stream_handle);
 	streamid->ifac_iport = le32_to_cpu(si_data->input_ports);
-	valid = si_data->en;
+	valid = si_data->en ? 1 : 0;
 
 	memset(cbdr, 0, sizeof(*cbdr));
 	kfree(si_data);
@@ -845,7 +834,6 @@ int enetc_qci_sfi_get(struct net_device *ndev, u32 index,
 	cbdr->status_flags = 0x80;
 
 	xmit_cbdr(priv->si, curr_cbd);
-	DUMP_CBDR(cbdr);
 
 	sfi_config = &cbdr->sfi_conf;
 	if (sfi_config->sthm & 0x80)
@@ -929,10 +917,7 @@ int enetc_qci_sfi_counters_get(struct net_device *ndev, u32 index,
 	dma_size = cpu_to_le16(data_size);
 	cbdr->length = dma_size;
 
-	DUMP_CBDR(cbdr);
 	xmit_cbdr(priv->si, curr_cbd);
-	DUMP_CBDR(cbdr);
-	DUMP_DATA((char *)sfi_counter_data, data_size);
 
 	counters->matching_frames_count =
 			((u64)le32_to_cpu(sfi_counter_data->matchh) << 32)
@@ -1485,7 +1470,8 @@ int enetc_qci_fmi_set(struct net_device *ndev, u32 index, bool enable,
 
 /* CBD Class 10: Flow Meter Instance Query Descriptor - Short Format */
 int enetc_qci_fmi_get(struct net_device *ndev, u32 index,
-						struct tsn_qci_psfp_fmi *tsn_qci_fmi)
+						struct tsn_qci_psfp_fmi *tsn_qci_fmi,
+						struct tsn_qci_psfp_fmi_counters *counters)
 {
 	struct enetc_cbd *cbdr;
 	struct fmi_conf *fmi_config;
@@ -1503,9 +1489,7 @@ int enetc_qci_fmi_get(struct net_device *ndev, u32 index,
 	cbdr->cls = BDCR_CMD_FLOW_METER;
 	cbdr->status_flags = 0x80;
 
-	DUMP_CBDR(cbdr);
 	xmit_cbdr(priv->si, curr_cbd);
-	DUMP_CBDR(cbdr);
 
 	fmi_config = &cbdr->fmi_conf;
 	if (fmi_config->cir) {
@@ -1564,11 +1548,11 @@ int enetc_qci_fmi_get(struct net_device *ndev, u32 index,
 	dma_size = cpu_to_le16(data_size);
 	cbdr->length = dma_size;
 
-	DUMP_CBDR(cbdr);
 	xmit_cbdr(priv->si, curr_cbd);
-	DUMP_CBDR(cbdr);
 	DUMP_DATA((char *)fmi_counter_data, data_size);
 
+	memcpy(counters, fmi_counter_data, sizeof(*counters));
+
 	return 0;
 }
 
diff --git a/include/net/tsn.h b/include/net/tsn.h
index 96456fc52db3..4945cf0afbec 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -40,7 +40,8 @@ struct tsn_ops {
 	int (*qci_fmi_set)(struct net_device *ndev, u32 index, bool enable,
 							struct tsn_qci_psfp_fmi *fmi);
 	int (*qci_fmi_get)(struct net_device *ndev, u32 index,
-							struct tsn_qci_psfp_fmi *fmi);
+							struct tsn_qci_psfp_fmi *fmi,
+							struct tsn_qci_psfp_fmi_counters *counters);
 	int (*cbs_set)(struct net_device *ndev, u8 tc, u8 bw);
 	int (*cbs_get)(struct net_device *ndev, u8 tc);
 	/* To set a 8 bits vector shows 8 traffic classes
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
index 8f939172f8fa..a7b638654f64 100644
--- a/include/uapi/linux/tsn.h
+++ b/include/uapi/linux/tsn.h
@@ -235,6 +235,7 @@ enum {
 	TSN_QCI_FMI_ATTR_DROPYL,
 	TSN_QCI_FMI_ATTR_MAREDEN,
 	TSN_QCI_FMI_ATTR_MARED,
+	TSN_QCI_FMI_ATTR_COUNTERS,
 	__TSN_QCI_FMI_ATTR_MAX,
 	TSN_QCI_FMI_ATTR_MAX = __TSN_QCI_FMI_ATTR_MAX - 1,
 };
@@ -852,7 +853,17 @@ struct tsn_qci_psfp_fmi {
 	 * frames are to be discarded (TRUE) or not (FALSE).
 	 */
 	bool mark_red;
+};
 
+struct tsn_qci_psfp_fmi_counters {
+	uint64_t bytecount;
+	uint64_t drop;
+	uint64_t dr0_green;
+	uint64_t dr1_green;
+	uint64_t dr2_yellow;
+	uint64_t remark_yellow;
+	uint64_t dr3_red;
+	uint64_t remark_red;
 };
 
 struct tsn_seq_gen_conf {
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index b69d5f2aeb38..635ab0d1d2b0 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -254,6 +254,7 @@ static const struct nla_policy qci_fmi_policy[] = {
 	[TSN_QCI_FMI_ATTR_DROPYL]	= { .type = NLA_FLAG},
 	[TSN_QCI_FMI_ATTR_MAREDEN]	= { .type = NLA_FLAG},
 	[TSN_QCI_FMI_ATTR_MARED]	= { .type = NLA_FLAG},
+	[TSN_QCI_FMI_ATTR_COUNTERS]	= { .len = sizeof(struct tsn_qci_psfp_fmi_counters)},
 };
 
 static int tsn_prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp, size_t size)
@@ -640,13 +641,13 @@ static int cmd_cb_streamid_get(struct genl_info *info)
 	switch (sidconf.type) {
 	case STREAMID_NULL:
 		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_NDMAC, sidconf.para.nid.dmac);
-		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_NTAGGED, sidconf.para.nid.vid);
-		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_NVID, sidconf.para.nid.tagged);
+		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_NVID, sidconf.para.nid.vid);
+		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_NTAGGED, sidconf.para.nid.tagged);
 		break;
 	case STREAMID_SMAC_VLAN:
 		NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_SMAC, sidconf.para.sid.smac);
-		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_STAGGED, sidconf.para.sid.vid);
-		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_SVID, sidconf.para.sid.tagged);
+		nla_put_u16(rep_skb, TSN_STREAMID_ATTR_SVID, sidconf.para.sid.vid);
+		nla_put_u8(rep_skb, TSN_STREAMID_ATTR_STAGGED, sidconf.para.sid.tagged);
 		break;
 	case STREAMID_DMAC_VLAN:
 	case STREAMID_IP:
@@ -1640,6 +1641,7 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	int ret;
 	struct net_device *netdev;
 	struct tsn_qci_psfp_fmi fmiconf;
+	struct tsn_qci_psfp_fmi_counters counters;
 	const struct tsn_ops *tsnops;
 	struct genlmsghdr *genlhdr;
 
@@ -1667,13 +1669,14 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	tsnops = netdev->tsn_ops;
 
 	memset(&fmiconf, 0, sizeof(struct tsn_qci_psfp_fmi));
+	memset(&counters, 0, sizeof(struct tsn_qci_psfp_fmi_counters));
 
 	if (!tsnops->qci_fmi_get) {
 		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
 		return -EINVAL;
 	}
 
-	tsnops->qci_fmi_get(netdev, index, &fmiconf);
+	tsnops->qci_fmi_get(netdev, index, &fmiconf, &counters);
 
 	genlhdr = info->genlhdr;
 
@@ -1711,6 +1714,9 @@ static int cmd_qci_fmi_get(struct genl_info *info)
 	if (fmiconf.mark_red)
 		nla_put_flag(rep_skb, TSN_QCI_FMI_ATTR_MAREDEN);
 
+	nla_put(rep_skb, TSN_QCI_FMI_ATTR_COUNTERS,
+		sizeof(struct tsn_qci_psfp_fmi_counters), &counters);
+
 	nla_nest_end(rep_skb, fmiattr);
 
 	return tsn_send_reply(rep_skb, info);
@@ -1931,10 +1937,11 @@ static int cmd_qbv_get(struct genl_info *info)
 
 		kfree(qbvconf.admin.control_list);
 
-		nla_nest_end(rep_skb, qbvadminattr);
 	} else
 		pr_info("tsn: error get administrator data.");
 
+	nla_nest_end(rep_skb, qbvadminattr);
+
 	if (qbvconf.gate_enabled)
 		nla_put_flag(rep_skb, TSN_QBV_ATTR_ENABLE);
 	else
@@ -1950,7 +1957,6 @@ static int cmd_qbv_get(struct genl_info *info)
 
 	tsn_send_reply(rep_skb, info);
 
-	nlmsg_free(rep_skb);
 	return ret;
 }
 
@@ -2028,12 +2034,12 @@ static int cmd_qbv_status_get(struct genl_info *info)
 			NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME, qbvstatus.oper.base_time);
 
 		kfree(qbvstatus.oper.control_list);
-
-		nla_nest_end(rep_skb, qbvoperattr);
 	} else {
 		pr_info("tsn: error get operation list data.");
 	}
 
+	nla_nest_end(rep_skb, qbvoperattr);
+
 	if (qbvstatus.config_change_time)
 		NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGETIME, qbvstatus.config_change_time);
 
@@ -2056,7 +2062,6 @@ static int cmd_qbv_status_get(struct genl_info *info)
 
 	tsn_send_reply(rep_skb, info);
 
-	nlmsg_free(rep_skb);
 	return ret;
 }
 
-- 
2.17.1


From a6f172b8effaaec4ea5ec58a160cd8965525433b Mon Sep 17 00:00:00 2001
From: Camelia Groza <camelia.groza@nxp.com>
Date: Fri, 15 Jun 2018 12:39:32 +0300
Subject: [PATCH 174/706] enetc: enable TC offloading with mqprio

Add support to configure multiple prioritised TX traffic classes with mqprio.

Configure one BD ring per TC for the moment, and one netdev queue per
CPU per TC.

Signed-off-by: Camelia Groza <camelia.groza@nxp.com>
(cherry picked from commit e88bd028146d70ca7491adf94d18e7338ebc94e7)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c  | 76 ++++++++++++++++++-
 drivers/net/ethernet/freescale/enetc/enetc.h  |  2 +
 .../net/ethernet/freescale/enetc/enetc_pf.c   |  1 +
 .../net/ethernet/freescale/enetc/enetc_vf.c   |  1 +
 4 files changed, 78 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index d46dda731d07..a94556fb204a 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -91,11 +91,17 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	struct enetc_bdr *tx_ring;
-	int count;
+	int count, prio;
 
 	// TODO: guard against runt (invalid) packets (?)
 
-	tx_ring = priv->tx_ring[skb->queue_mapping];
+	if (ndev->num_tc) {
+		/* Choose the TX BD ring based on the skb's priority mapping */
+		prio = netdev_get_prio_tc_map(ndev, skb->priority);
+		tx_ring = priv->tx_ring[prio];
+	} else {
+		tx_ring = priv->tx_ring[skb->queue_mapping];
+	}
 
 	if (enetc_bd_unused(tx_ring) < ENETC_FREE_TXBD_NEEDED) {
 		// TODO: check h/w index (CISR) for more acurate status
@@ -1202,6 +1208,72 @@ int enetc_close(struct net_device *ndev)
 	return 0;
 }
 
+int enetc_setup_tc(struct net_device *ndev, enum tc_setup_type type,
+		   void *type_data)
+{
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	struct tc_mqprio_qopt *mqprio = type_data;
+	struct enetc_bdr *tx_ring;
+	int i;
+	u8 num_tc;
+	u32 val;
+
+	if (type != TC_SETUP_MQPRIO)
+		return -EOPNOTSUPP;
+
+	mqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;
+	num_tc = mqprio->num_tc;
+
+	if (!num_tc) {
+		netdev_reset_tc(ndev);
+		netif_set_real_num_tx_queues(ndev, ENETC_TXQ_PER_TC);
+
+		/* Reset all ring priorities to 0 */
+		for (i = 0; i < priv->num_tx_rings; i++) {
+			tx_ring = priv->tx_ring[i];
+			val = enetc_txbdr_rd(&priv->si->hw, tx_ring->index,
+					     ENETC_TBMR);
+			val &= ~ENETC_TBMR_PRIO_MASK;
+			enetc_txbdr_wr(&priv->si->hw, tx_ring->index,
+				       ENETC_TBMR, val);
+		}
+
+		return 0;
+	}
+
+	/* Check if we have enough BD rings available to accommodate all TCs */
+	if (num_tc > priv->num_tx_rings) {
+		netdev_err(ndev, "Max %d traffic classes supported\n",
+			   priv->num_tx_rings);
+		return -EINVAL;
+	}
+
+	/* For the moment, we use only one BD ring per TC.
+	 *
+	 * Configure num_tc BD rings with increasing priorities.
+	 */
+	for (i = 0; i < num_tc; i++) {
+		tx_ring = priv->tx_ring[i];
+		val = enetc_txbdr_rd(&priv->si->hw, tx_ring->index, ENETC_TBMR);
+		/* Clear the old priority and set the new one */
+		val &= ~ENETC_TBMR_PRIO_MASK;
+		val |= ENETC_TBMR_PRIO_SET(i);
+		enetc_txbdr_wr(&priv->si->hw, tx_ring->index, ENETC_TBMR, val);
+	}
+
+	/* Reset the number of netdev queues based on the TC count */
+	netif_set_real_num_tx_queues(ndev, num_tc * ENETC_TXQ_PER_TC);
+
+	netdev_set_num_tc(ndev, num_tc);
+
+	/* Each TC is associated with ENETC_TXQ_PER_TC netdev queues */
+	for (i = 0; i < num_tc; i++)
+		netdev_set_tc_queue(ndev, i, ENETC_TXQ_PER_TC,
+				    i * ENETC_TXQ_PER_TC);
+
+	return 0;
+}
+
 struct net_device_stats *enetc_get_stats(struct net_device *ndev)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index 288c3c96c79f..6578020a26c4 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -236,6 +236,8 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev);
 struct net_device_stats *enetc_get_stats(struct net_device *ndev);
 int enetc_set_features(struct net_device *ndev,
 		       netdev_features_t features);
+int enetc_setup_tc(struct net_device *ndev, enum tc_setup_type type,
+		   void *type_data);
 /* ethtool */
 void enetc_set_ethtool_ops(struct net_device *ndev);
 
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
index a16313189783..6b1f3645ead6 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
@@ -654,6 +654,7 @@ static const struct net_device_ops enetc_ndev_ops = {
 	.ndo_set_vf_vlan	= enetc_pf_set_vf_vlan,
 	.ndo_set_vf_spoofchk	= enetc_pf_set_vf_spoofchk,
 	.ndo_set_features	= enetc_pf_set_features,
+	.ndo_setup_tc		= enetc_setup_tc,
 };
 
 static void enetc_pf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_vf.c b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
index 93d18bf4f634..b389eca22a08 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_vf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
@@ -138,6 +138,7 @@ static const struct net_device_ops enetc_ndev_ops = {
 	.ndo_start_xmit		= enetc_xmit,
 	.ndo_get_stats		= enetc_get_stats,
 	.ndo_set_mac_address	= enetc_vf_set_mac_addr,
+	.ndo_setup_tc		= enetc_setup_tc,
 };
 
 static void enetc_vf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
-- 
2.17.1


From 1fa9091cd4a5760df9db434ecb168a66716c4a53 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Horia=20Geant=C4=83?= <horia.geanta@nxp.com>
Date: Tue, 31 Jul 2018 12:42:54 +0300
Subject: [PATCH 577/706] crypto: caam/jr - fix S/G table passing SMMU 4K page
 boundary
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

According to CAAM RM, crypto engine reads 4 S/G entries at a time,
even if the S/G table has fewer entries; it's the responsibility of the
user / programmer to make sure this HW behaviour has no side effect.

The driver does not take care of this currently, leading to SMMU faults
when the S/G table is passing the 4k page boundary and only the first
page is DMA mapped.

Fix this by always rounding up the number of S/G table entries to be a
multiple of 4.

Note: ablkcipher with IV generation code is not fixed; this is dead code
and shall be removed in near future.

Signed-off-by: Horia GeantÄƒ <horia.geanta@nxp.com>
(cherry picked from commit a495f95682c2b1b78f455b913586b25a4f54a61a)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/crypto/caam/caamalg.c | 30 ++++++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index b1e12c7cff45..013869cf8827 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -1267,8 +1267,16 @@ static struct aead_edesc *aead_edesc_alloc(struct aead_request *req,
 		}
 	}
 
+	/*
+	 * HW reads 4 S/G entries at a time; make sure the reads don't go beyond
+	 * the end of the table by allocating more S/G entries.
+	 */
 	sec4_sg_len = mapped_src_nents > 1 ? mapped_src_nents : 0;
-	sec4_sg_len += mapped_dst_nents > 1 ? mapped_dst_nents : 0;
+	if (mapped_dst_nents > 1)
+		sec4_sg_len += ALIGN(mapped_dst_nents, 4);
+	else
+		sec4_sg_len = ALIGN(sec4_sg_len, 4);
+
 	sec4_sg_bytes = sec4_sg_len * sizeof(struct sec4_sg_entry);
 
 	/* allocate space for base edesc and hw desc commands, link tables */
@@ -1536,7 +1544,25 @@ static struct ablkcipher_edesc *ablkcipher_edesc_alloc(struct ablkcipher_request
 
 	sec4_sg_ents = 1 + mapped_src_nents;
 	dst_sg_idx = sec4_sg_ents;
-	sec4_sg_ents += mapped_dst_nents > 1 ? mapped_dst_nents : 0;
+
+	/*
+	 * HW reads 4 S/G entries at a time; make sure the reads don't go beyond
+	 * the end of the table by allocating more S/G entries. Logic:
+	 * if (src != dst && output S/G)
+	 *     pad output S/G, if needed
+	 * else if (src == dst && S/G)
+	 *     overlapping S/Gs; pad one of them
+	 * else if (input S/G) ...
+	 *     pad input S/G, if needed
+	 */
+	if (mapped_dst_nents > 1)
+		sec4_sg_ents += ALIGN(mapped_dst_nents, 4);
+	else if ((req->src == req->dst) && (mapped_src_nents > 1))
+		sec4_sg_ents = max(ALIGN(sec4_sg_ents, 4),
+				   1 + ALIGN(mapped_src_nents, 4));
+	else
+		sec4_sg_ents = ALIGN(sec4_sg_ents, 4);
+
 	sec4_sg_bytes = sec4_sg_ents * sizeof(struct sec4_sg_entry);
 
 	/*
-- 
2.17.1


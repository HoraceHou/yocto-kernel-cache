From 33f482dad7b617cd9145989f0737f4145cdf712a Mon Sep 17 00:00:00 2001
From: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
Date: Mon, 26 Nov 2018 05:11:24 +0800
Subject: [PATCH 386/706] support TSN driver on switch device

Support Qbv, Qbu, stream identify, Qci, cut through and
802.1cb on switch device.
Using netlink interface to configure it.

Signed-off-by: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
(cherry picked from commit 24efb4c646611f64bc4e8829de9b1f0a51f451c5)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/mscc/Makefile      |    2 +-
 drivers/net/ethernet/mscc/felix_board.c |   10 +-
 drivers/net/ethernet/mscc/felix_regs.c  |   36 +
 drivers/net/ethernet/mscc/ocelot.c      |   23 +
 drivers/net/ethernet/mscc/ocelot.h      |   69 ++
 drivers/net/ethernet/mscc/ocelot_ana.h  |   21 +
 drivers/net/ethernet/mscc/tsn_switch.c  | 1011 +++++++++++++++++++++++
 include/net/tsn.h                       |    5 +
 include/uapi/linux/tsn.h                |   52 ++
 net/tsn/genl_tsn.c                      |  196 ++++-
 10 files changed, 1420 insertions(+), 5 deletions(-)
 create mode 100644 drivers/net/ethernet/mscc/tsn_switch.c

diff --git a/drivers/net/ethernet/mscc/Makefile b/drivers/net/ethernet/mscc/Makefile
index 409de26b23e0..1ca2366220eb 100644
--- a/drivers/net/ethernet/mscc/Makefile
+++ b/drivers/net/ethernet/mscc/Makefile
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: (GPL-2.0 OR MIT)
 obj-$(CONFIG_MSCC_OCELOT_SWITCH) += mscc_ocelot_common.o
-mscc_ocelot_common-y := ocelot.o ocelot_io.o
+mscc_ocelot_common-y := ocelot.o ocelot_io.o tsn_switch.o
 obj-$(CONFIG_MSCC_OCELOT_SWITCH_OCELOT) += ocelot_board.o ocelot_regs.o
 
 obj-$(CONFIG_MSCC_FELIX_SWITCH) += mscc_felix.o
diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
index 24bf17b86f2f..25b79c149b99 100644
--- a/drivers/net/ethernet/mscc/felix_board.c
+++ b/drivers/net/ethernet/mscc/felix_board.c
@@ -20,7 +20,7 @@ static const char felix_driver_version[] = DRV_VERSION;
 
 #define FELIX_MAX_NUM_PHY_PORTS	5
 #define FELIX_EXT_CPU_PORT_ID	4
-#define PORT_RES_START		(SYS + 1)
+#define PORT_RES_START		(DEVCPU_PTP + 1)
 
 #define PCI_DEVICE_ID_FELIX_PF5	0xEEF0
 
@@ -72,6 +72,12 @@ static struct resource felix_switch_res[] = {
 		.name = "sys",
 		.flags = IORESOURCE_MEM,
 	},
+	{
+		.start = 0x0090000,
+		.end = 0x00900ff,
+		.name = "devcpu_ptp",
+		.flags = IORESOURCE_MEM,
+	},
 	{
 		.start = 0x0100000,
 		.end = 0x010ffff,
@@ -495,7 +501,7 @@ static int felix_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 			felix_switch_res[i].end += offset;
 		}
 
-	for (i = ANA; i <= SYS; i++) {
+	for (i = ANA; i <= DEVCPU_PTP; i++) {
 		struct regmap *target;
 
 		target = felix_io_init(ocelot, i);
diff --git a/drivers/net/ethernet/mscc/felix_regs.c b/drivers/net/ethernet/mscc/felix_regs.c
index aead5dfb4437..145ea9b34d2b 100644
--- a/drivers/net/ethernet/mscc/felix_regs.c
+++ b/drivers/net/ethernet/mscc/felix_regs.c
@@ -248,12 +248,22 @@ static const u32 felix_sys_regmap[] = {
 //	REG(SYS_CM_OP,                     0x000f34),
 };
 
+static const u32 felix_devcpu_ptp_regmap[] = {
+	REG(DEVCPU_PTP_PINS,		   0x000000),
+	REG(DEVCPU_PTP_CFG,		   0x0000a0),
+	REG(DEVCPU_PTP_CUR_NSF,		   0x0000bc),
+	REG(DEVCPU_PTP_CUR_NSEC,           0x0000c0),
+	REG(DEVCPU_PTP_CUR_SEC_LSB,        0x0000c4),
+	REG(DEVCPU_PTP_CUR_SEC_MSB,        0x0000c8),
+};
+
 static const u32 *felix_regmap[] = {
 	[ANA] = felix_ana_regmap,
 	[QS] = felix_qs_regmap,
 	[QSYS] = felix_qsys_regmap,
 	[REW] = felix_rew_regmap,
 	[SYS] = felix_sys_regmap,
+	[DEVCPU_PTP] = felix_devcpu_ptp_regmap,
 };
 
 static const struct reg_field felix_regfields[] = {
@@ -304,6 +314,32 @@ static const struct reg_field felix_regfields[] = {
 	[QSYS_TIMED_FRAME_ENTRY_TFRM_TM_T] =
 		REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 0, 0),
 	[SYS_RESET_CFG_CORE_ENA] = REG_FIELD(SYS_RESET_CFG, 0, 0),
+	[SYS_RESET_CFG_MEM_ENA] = REG_FIELD(SYS_RESET_CFG, 1, 1),
+	[SYS_RESET_CFG_MEM_INIT] = REG_FIELD(SYS_RESET_CFG, 0, 0),
+	[ANA_TABLES_STREAMDATA_SFID_0] =
+		REG_FIELD(ANA_TABLES_STREAMDATA, 0, 7),
+	[ANA_TABLES_STREAMDATA_SFID_VALID_0] =
+		REG_FIELD(ANA_TABLES_STREAMDATA, 8, 8),
+	[ANA_TABLES_SFIDTIDX_SFID_INDEX_0] =
+		REG_FIELD(ANA_TABLES_SFIDTIDX, 0, 7),
+	[ANA_SG_ACCESS_CTRL_CONFIG_CHANGE_0] =
+		REG_FIELD(ANA_SG_ACCESS_CTRL, 28, 28),
+	[ANA_SG_ACCESS_CTRL_SGID_0] =
+		REG_FIELD(ANA_SG_ACCESS_CTRL, 0, 7),
+	[ANA_SG_CONFIG_REG_3_GATE_ENABLE_0] =
+		REG_FIELD(ANA_SG_CONFIG_REG_3, 20, 20),
+	[QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0] =
+		REG_FIELD(QSYS_TAS_PARAM_CFG_CTRL, 0, 7),
+	[QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM_0] =
+		REG_FIELD(QSYS_GCL_STATUS_REG_1, 0, 5),
+	[QSYS_GCL_CFG_REG_1_GATE_STATE_0] =
+		REG_FIELD(QSYS_GCL_CFG_REG_1, 8, 15),
+	[QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM_0] =
+		REG_FIELD(QSYS_GCL_CFG_REG_1, 0, 5),
+	[QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE_0] =
+		REG_FIELD(QSYS_TAS_PARAM_CFG_CTRL, 16, 16),
+	[QSYS_TAG_CONFIG_ENABLE_0] = REG_FIELD(QSYS_TAG_CONFIG, 0, 0),
+	[SYS_STAT_CFG_STAT_VIEW_0] = REG_FIELD(SYS_STAT_CFG, 0, 9),
 };
 
 static const struct ocelot_stat_layout felix_stats_layout[] = {
diff --git a/drivers/net/ethernet/mscc/ocelot.c b/drivers/net/ethernet/mscc/ocelot.c
index fc69bbfcf38a..1e061c97a204 100644
--- a/drivers/net/ethernet/mscc/ocelot.c
+++ b/drivers/net/ethernet/mscc/ocelot.c
@@ -1340,6 +1340,28 @@ static const struct switchdev_ops ocelot_port_switchdev_ops = {
 	.switchdev_port_obj_del		= ocelot_port_obj_del,
 };
 
+const struct tsn_ops switch_tsn_ops = {
+	.qbv_set			= switch_qbv_set,
+	.qbv_get			= switch_qbv_get,
+	.qbv_get_status			= switch_qbv_get_status,
+	.qbu_set			= switch_qbu_set,
+	.cb_streamid_set		= switch_cb_streamid_set,
+	.cb_streamid_get		= switch_cb_streamid_get,
+	.cb_streamid_counters_get	= switch_cb_streamid_counters_get,
+	.qci_sfi_set			= switch_qci_sfi_set,
+	.qci_sfi_get			= switch_qci_sfi_get,
+	.qci_sfi_counters_get		= switch_qci_sfi_counters_get,
+	.qci_sgi_set			= switch_qci_sgi_set,
+	.qci_sgi_get			= switch_qci_sgi_get,
+	.qci_sgi_status_get		= switch_qci_sgi_status_get,
+	.qci_fmi_set			= switch_qci_fmi_set,
+	.qci_fmi_get			= switch_qci_fmi_get,
+	.cbs_set			= switch_cbs_set,
+	.ct_set				= switch_cut_thru_set,
+	.cbgen_set			= switch_seq_gen_set,
+	.cbrec_set			= switch_seq_rec_set,
+};
+
 static int ocelot_port_bridge_join(struct ocelot_port *ocelot_port,
 				   struct net_device *bridge)
 {
@@ -1618,6 +1640,7 @@ int ocelot_probe_port(struct ocelot *ocelot, u8 port,
 	dev->netdev_ops = &ocelot_port_netdev_ops;
 	dev->ethtool_ops = &ocelot_ethtool_ops;
 	dev->switchdev_ops = &ocelot_port_switchdev_ops;
+	dev->tsn_ops = &switch_tsn_ops;
 
 	dev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
diff --git a/drivers/net/ethernet/mscc/ocelot.h b/drivers/net/ethernet/mscc/ocelot.h
index 1bd784c5a9a6..2fa1a9870364 100644
--- a/drivers/net/ethernet/mscc/ocelot.h
+++ b/drivers/net/ethernet/mscc/ocelot.h
@@ -13,9 +13,11 @@
 #include <linux/if_vlan.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
+#include <net/tsn.h>
 
 #include "ocelot_ana.h"
 #include "ocelot_dev.h"
+#include "ocelot_dev_gmii.h"
 #include "ocelot_hsio.h"
 #include "ocelot_qsys.h"
 #include "ocelot_rew.h"
@@ -24,6 +26,10 @@
 
 #define PGID_AGGR    64
 #define PGID_SRC     80
+#define TRUE 1
+#define FALSE 0
+#define SUCCESS 1
+#define FAILED 0
 
 /* Reserved PGIDs */
 #define PGID_CPU     (PGID_AGGR - 5)
@@ -41,6 +47,11 @@
 /* Length for long prefix header used for frame injection/extraction */
 #define XFH_LONG_PREFIX_LEN 32
 
+#define SWITCH_TAS_GCL_MAX 64
+#define SWITCH_TAS_CT_MAX 1000000000
+#define SWITCH_TAS_CT_MIN 100
+#define SWITCH_TAS_CTE_MAX 999999999
+
 struct frame_info {
 	u32 len;
 	u16 port;
@@ -70,6 +81,7 @@ enum ocelot_target {
 	QSYS,
 	REW,
 	SYS,
+	DEVCPU_PTP,
 	HSIO,
 	TARGET_MAX,
 };
@@ -336,6 +348,12 @@ enum ocelot_reg {
 //	SYS_CM_DATA_RD,
 //	SYS_CM_OP,
 	SYS_CM_DATA,
+	DEVCPU_PTP_PINS = DEVCPU_PTP << TARGET_OFFSET,
+	DEVCPU_PTP_CFG,
+	DEVCPU_PTP_CUR_NSF,
+	DEVCPU_PTP_CUR_NSEC,
+	DEVCPU_PTP_CUR_SEC_LSB,
+	DEVCPU_PTP_CUR_SEC_MSB,
 	HSIO_PLL5G_CFG0 = HSIO << TARGET_OFFSET,
 	HSIO_PLL5G_CFG1,
 	HSIO_PLL5G_CFG2,
@@ -456,6 +474,19 @@ enum ocelot_regfield {
 	SYS_RESET_CFG_CORE_ENA,
 	SYS_RESET_CFG_MEM_ENA,
 	SYS_RESET_CFG_MEM_INIT,
+	ANA_TABLES_STREAMDATA_SFID_0,
+	ANA_TABLES_STREAMDATA_SFID_VALID_0,
+	ANA_TABLES_SFIDTIDX_SFID_INDEX_0,
+	ANA_SG_ACCESS_CTRL_CONFIG_CHANGE_0,
+	ANA_SG_ACCESS_CTRL_SGID_0,
+	ANA_SG_CONFIG_REG_3_GATE_ENABLE_0,
+	QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0,
+	QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM_0,
+	QSYS_GCL_CFG_REG_1_GATE_STATE_0,
+	QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM_0,
+	QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE_0,
+	QSYS_TAG_CONFIG_ENABLE_0,
+	SYS_STAT_CFG_STAT_VIEW_0,
 	REGFIELD_MAX
 };
 
@@ -534,6 +565,8 @@ struct ocelot_port {
 
 	u64 *stats;
 
+	u8 cbs_weight[MSCC_QOS_PRIO_MAX];
+
 	/* cpu frame injection handler */
 	netdev_tx_t (*cpu_inj_handler)(struct sk_buff *skb, struct ocelot_port *port);
 	void *cpu_inj_handler_data;
@@ -580,4 +613,40 @@ int ocelot_probe_port(struct ocelot *ocelot, u8 port,
 
 extern struct notifier_block ocelot_netdevice_nb;
 
+int switch_qbv_set(struct net_device *ndev,
+		   struct tsn_qbv_conf *shaper_config);
+int switch_qbv_get(struct net_device *ndev,
+		   struct tsn_qbv_conf *shaper_config);
+int switch_qbv_get_status(struct net_device *ndev,
+			  struct tsn_qbv_status *qbvstatus);
+int switch_cut_thru_set(struct net_device *ndev, u8 cut_thru);
+int switch_cbs_set(struct net_device *ndev, u8 tc, u8 bw);
+int switch_qbu_set(struct net_device *ndev, u8 preemptable);
+int switch_cb_streamid_get(struct net_device *ndev, u32 index,
+			   struct tsn_cb_streamid *streamid);
+int switch_cb_streamid_set(struct net_device *ndev, u32 index,
+			   bool enable, struct tsn_cb_streamid *streamid);
+int switch_qci_sfi_get(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_sfi_conf *sfi);
+int switch_qci_sfi_set(struct net_device *ndev, u32 index,
+		       bool enable, struct tsn_qci_psfp_sfi_conf *sfi);
+int switch_cb_streamid_counters_get(struct net_device *ndev, u32 index,
+				    struct tsn_cb_streamid_counters *s_counters);
+int switch_qci_sfi_counters_get(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_sfi_counters *sfi_counters);
+int switch_qci_sgi_set(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_sgi_conf *sgi_conf);
+int switch_qci_sgi_get(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_sgi_conf *sgi_conf);
+int switch_qci_sgi_status_get(struct net_device *ndev, u16 index,
+			      struct tsn_psfp_sgi_status *sgi_status);
+int switch_qci_fmi_set(struct net_device *ndev, u32 index,
+		       bool enable, struct tsn_qci_psfp_fmi *fmi);
+int switch_qci_fmi_get(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_fmi *fmi);
+int switch_seq_gen_set(struct net_device *ndev, u32 index,
+		       struct tsn_seq_gen_conf *sg_conf);
+int switch_seq_rec_set(struct net_device *ndev, u32 index,
+		       struct tsn_seq_rec_conf *sr_conf);
+
 #endif
diff --git a/drivers/net/ethernet/mscc/ocelot_ana.h b/drivers/net/ethernet/mscc/ocelot_ana.h
index 841c6ec22b64..523673238380 100644
--- a/drivers/net/ethernet/mscc/ocelot_ana.h
+++ b/drivers/net/ethernet/mscc/ocelot_ana.h
@@ -227,6 +227,12 @@
 #define ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(x)             ((x) & GENMASK(1, 0))
 #define ANA_TABLES_SFIDACCESS_SFID_TBL_CMD_M              GENMASK(1, 0)
 
+#define SFIDACCESS_CMD_IDLE                             0
+#define SFIDACCESS_CMD_READ                             1
+#define SFIDACCESS_CMD_WRITE                            2
+#define SFIDACCESS_CMD_INIT                             3
+
+
 #define ANA_TABLES_SFIDTIDX_SGID_VALID                    BIT(26)
 #define ANA_TABLES_SFIDTIDX_SGID(x)                       (((x) << 18) & GENMASK(25, 18))
 #define ANA_TABLES_SFIDTIDX_SGID_M                        GENMASK(25, 18)
@@ -255,12 +261,22 @@
 #define ANA_SG_CONFIG_REG_3_INIT_IPS(x)                   (((x) << 24) & GENMASK(27, 24))
 #define ANA_SG_CONFIG_REG_3_INIT_IPS_M                    GENMASK(27, 24)
 #define ANA_SG_CONFIG_REG_3_INIT_IPS_X(x)                 (((x) & GENMASK(27, 24)) >> 24)
+#define ANA_SG_CONFIG_REG_3_IPV_VALID                     BIT(27)
+#define ANA_SG_CONFIG_REG_3_IPV_INVALID(x)		  (((x) << 27) & GENMASK(27, 27))
+#define ANA_SG_CONFIG_REG_3_INIT_IPV(x)                   (((x) << 24) & GENMASK(26, 24))
+#define ANA_SG_CONFIG_REG_3_INIT_IPV_M                    GENMASK(26, 24)
+#define ANA_SG_CONFIG_REG_3_INIT_IPV_X(x)                 (((x) & GENMASK(26, 24)) >> 24)
+
 #define ANA_SG_CONFIG_REG_3_INIT_GATE_STATE               BIT(28)
 
 #define ANA_SG_GCL_GS_CONFIG_RSZ                          0x4
 
 #define ANA_SG_GCL_GS_CONFIG_IPS(x)                       ((x) & GENMASK(3, 0))
 #define ANA_SG_GCL_GS_CONFIG_IPS_M                        GENMASK(3, 0)
+#define ANA_SG_GCL_GS_CONFIG_IPV_VALID                    BIT(3)
+#define ANA_SG_GCL_GS_CONFIG_IPV(x)                       ((x) & GENMASK(2, 0))
+#define ANA_SG_GCL_GS_CONFIG_IPV_M                        GENMASK(2, 0)
+
 #define ANA_SG_GCL_GS_CONFIG_GATE_STATE                   BIT(4)
 
 #define ANA_SG_GCL_TI_CONFIG_RSZ                          0x4
@@ -271,6 +287,11 @@
 #define ANA_SG_STATUS_REG_3_IPS(x)                        (((x) << 20) & GENMASK(23, 20))
 #define ANA_SG_STATUS_REG_3_IPS_M                         GENMASK(23, 20)
 #define ANA_SG_STATUS_REG_3_IPS_X(x)                      (((x) & GENMASK(23, 20)) >> 20)
+#define ANA_SG_STATUS_REG_3_IPV_VALID                     BIT(23)
+#define ANA_SG_STATUS_REG_3_IPV(x)                        (((x) << 20) & GENMASK(22, 20))
+#define ANA_SG_STATUS_REG_3_IPV_M                         GENMASK(22, 20)
+#define ANA_SG_STATUS_REG_3_IPV_X(x)                      (((x) & GENMASK(22, 20)) >> 20)
+
 #define ANA_SG_STATUS_REG_3_CONFIG_PENDING                BIT(24)
 
 #define ANA_PORT_VLAN_CFG_GSZ                             0x100
diff --git a/drivers/net/ethernet/mscc/tsn_switch.c b/drivers/net/ethernet/mscc/tsn_switch.c
new file mode 100644
index 000000000000..b5a9ae7d837b
--- /dev/null
+++ b/drivers/net/ethernet/mscc/tsn_switch.c
@@ -0,0 +1,1011 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR MIT)
+ *
+ * TSN_SWITCH driver
+ *
+ * Copyright 2018 NXP
+ */
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/sys_soc.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/phy.h>
+#include "ocelot.h"
+
+/* Round x divided by y to nearest higher integer. x and y are integers */
+#define MSCC_DIV_ROUND_UP(x, y) (((x) + (y) - 1) / (y))
+#define SE_IX_PORT 64
+#ifndef MIN
+#define MIN(x, y) ((x) < (y) ? (x) : (y))
+#endif
+#ifndef MAX
+#define MAX(x, y) ((x) > (y) ? (x) : (y))
+#endif
+
+static void ocelot_port_rmwl(struct ocelot_port *port, u32 val, u32 mask, u32 reg)
+{
+	u32 cur = ocelot_port_readl(port, reg);
+	ocelot_port_writel(port, (cur & (~mask)) | val, reg);
+}
+
+static int qos_port_tas_gcl_set(struct net_device *ndev,
+				struct ocelot *ocelot, const u8 gcl_ix,
+				struct tsn_qbv_entry *control_list,
+				const bool dry_run)
+{
+	netdev_dbg(ndev, "%s: gcl_ix %u gate_state 0x%02x time_interval %u dry_run %d\n",
+		   __func__, gcl_ix, control_list->gate_state,
+		   control_list->time_interval, dry_run);
+	if (gcl_ix > (SWITCH_TAS_GCL_MAX - 1)) {
+		netdev_info(ndev, "Invalid gcl ix %u\n", gcl_ix);
+		return -EINVAL;
+	}
+	if (!control_list->time_interval ||
+	    (control_list->time_interval > 1000000000)) {
+		netdev_info(ndev, "Invalid time_interval %u\n",
+			    control_list->time_interval);
+		return -EINVAL;
+	}
+	if (dry_run)
+		return 0;
+
+	ocelot_write(ocelot,
+		     QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM(gcl_ix) |
+		     QSYS_GCL_CFG_REG_1_GATE_STATE(control_list->gate_state),
+		     QSYS_GCL_CFG_REG_1);
+
+	ocelot_write(ocelot,
+		     control_list->time_interval,
+		     QSYS_GCL_CFG_REG_2);
+
+	return 0;
+}
+
+int switch_qbv_set(struct net_device *ndev, struct tsn_qbv_conf *shaper_config)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	int  i, count;
+	struct tsn_qbv_basic *admin_basic = &shaper_config->admin;
+	struct tsn_qbv_entry *control_list = admin_basic->control_list;
+	u32 base_time_nsec = admin_basic->base_time & 0xffffffff;
+	u64 base_time_sec = admin_basic->base_time >> 32;
+	u64 cur_time;
+	u32 val;
+
+	shaper_config->config_change = 1;
+	netdev_dbg(ndev, "%s: gate_enabled %d admin_gate_states 0x%02x admin_control_list_length %u admin_cycle_time %u admin_cycle_time_extension %u admin_base_time %llu config_change %d ",
+		   __func__, shaper_config->gate_enabled,
+		   admin_basic->gate_states,
+		   admin_basic->control_list_length,
+		   admin_basic->cycle_time,
+		   admin_basic->cycle_time_extension,
+		   admin_basic->base_time, shaper_config->config_change);
+
+	if (admin_basic->control_list_length > SWITCH_TAS_GCL_MAX) {
+		netdev_info(ndev, "Invalid admin_control_list_length %u\n",
+			    admin_basic->control_list_length);
+		return -EINVAL;
+	}
+
+	if ((admin_basic->cycle_time < SWITCH_TAS_CT_MIN) ||
+	    (admin_basic->cycle_time > SWITCH_TAS_CT_MAX)) {
+		netdev_info(ndev, "Invalid admin_cycle_time %u ns\n",
+			    admin_basic->cycle_time);
+		return -EINVAL;
+	}
+	if (admin_basic->cycle_time_extension > SWITCH_TAS_CTE_MAX) {
+		netdev_info(ndev, "Invalid admin_cycle_time_extension %u\n",
+			    admin_basic->cycle_time_extension);
+		return -EINVAL;
+	}
+	if (base_time_nsec > 999999999) {
+		netdev_info(ndev, "Invalid admin_base_time.tv_nsec %u\n",
+			    base_time_nsec);
+		return -EINVAL;
+	}
+
+	cur_time = ocelot_read(ocelot, DEVCPU_PTP_CUR_SEC_MSB);
+	cur_time = cur_time << 32;
+	cur_time += ocelot_read(ocelot, DEVCPU_PTP_CUR_SEC_LSB);
+
+	if (base_time_sec < cur_time) {
+		base_time_sec = cur_time;
+		base_time_nsec = ocelot_read(ocelot, DEVCPU_PTP_CUR_NSEC);
+	}
+
+	/* Select port */
+	ocelot_rmw(ocelot,
+		   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM(port->chip_port),
+		   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_M,
+		   QSYS_TAS_PARAM_CFG_CTRL);
+
+	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);
+	if (val & QSYS_PARAM_STATUS_REG_8_CONFIG_PENDING) {
+		ocelot_rmw_rix(ocelot, 0, QSYS_TAG_CONFIG_ENABLE,
+			       QSYS_TAG_CONFIG, port->chip_port);
+	}
+
+	ocelot_rmw_rix(ocelot,
+		    (shaper_config->gate_enabled ? QSYS_TAG_CONFIG_ENABLE : 0) |
+		    QSYS_TAG_CONFIG_INIT_GATE_STATE(admin_basic->gate_states) |
+		    QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES(0xff) |
+		    QSYS_TAG_CONFIG_LINK_SPEED(0x1),
+		    QSYS_TAG_CONFIG_ENABLE |
+		    QSYS_TAG_CONFIG_INIT_GATE_STATE_M |
+		    QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES_M |
+		    QSYS_TAG_CONFIG_LINK_SPEED_M,
+		    QSYS_TAG_CONFIG,
+		    port->chip_port);
+
+	ocelot_write_rix(ocelot, shaper_config->maxsdu,
+			  QSYS_PORT_MAX_SDU, port->chip_port);
+	/* TODO: add queue max SDU set */
+
+	if (shaper_config->gate_enabled && shaper_config->config_change) {
+		ocelot_write(ocelot, base_time_nsec,
+			     QSYS_PARAM_CFG_REG_1);
+
+		ocelot_write(ocelot, base_time_sec & GENMASK(31, 0),
+			     QSYS_PARAM_CFG_REG_2);
+
+		ocelot_write(ocelot,
+			     QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(base_time_sec >> 32) |
+			     QSYS_PARAM_CFG_REG_3_LIST_LENGTH(admin_basic->control_list_length),
+			     QSYS_PARAM_CFG_REG_3);
+		ocelot_write(ocelot, admin_basic->cycle_time,
+			     QSYS_PARAM_CFG_REG_4);
+
+		ocelot_write(ocelot,
+			     admin_basic->cycle_time_extension,
+			     QSYS_PARAM_CFG_REG_5);
+
+		for (i = 0; i < admin_basic->control_list_length; i++) {
+			qos_port_tas_gcl_set(ndev, ocelot, i,
+					     control_list, 0);
+			control_list++;
+		}
+
+		/* Start configuration change */
+		ocelot_rmw(ocelot,
+			   QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,
+			   QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,
+			   QSYS_TAS_PARAM_CFG_CTRL);
+
+		count = 0;
+		do { /* Wait until configuration change is complete */
+			msleep(20);
+			count++;
+			if (count == 100) {
+				netdev_err(ndev, "Config change timeout on chip_port %u\n", port->chip_port);
+				return -ETIMEDOUT;
+			}
+		} while (ocelot_read(ocelot, QSYS_TAS_PARAM_CFG_CTRL) &
+			 QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE);
+	}
+	return 0;
+}
+
+int switch_qbv_get(struct net_device *ndev, struct tsn_qbv_conf *shaper_config)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 val, reg;
+	int i;
+	u8 p_num = port->chip_port;
+	u32 base_timel;
+	u32 base_timeh;
+	struct tsn_qbv_basic *admin = &shaper_config->admin;
+	struct tsn_qbv_entry *list;
+
+	ocelot_field_write(ocelot,
+			   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0, p_num);
+
+	val = ocelot_read(ocelot, QSYS_TAG_CONFIG);
+	if (val & QSYS_TAG_CONFIG_ENABLE)
+		shaper_config->gate_enabled = TRUE;
+	else
+		shaper_config->gate_enabled = FALSE;
+
+	admin->gate_states = QSYS_TAG_CONFIG_INIT_GATE_STATE_X(val);
+
+	base_timel = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_1);
+	base_timeh = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_2);
+	reg = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_3);
+	admin->base_time = base_timeh | (((u64)QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(reg)) << 32);
+	admin->base_time = (admin->base_time << 32) | base_timel;
+
+	admin->control_list_length = QSYS_PARAM_CFG_REG_3_LIST_LENGTH_X(reg);
+
+	admin->cycle_time = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_4);
+	admin->cycle_time_extension = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_5);
+
+	list = (struct tsn_qbv_entry *)kmalloc(admin->control_list_length *
+			sizeof(struct tsn_qbv_entry), GFP_KERNEL);
+	admin->control_list = list;
+
+	for (i = 0; i < admin->control_list_length; i++) {
+		ocelot_field_write(ocelot,
+				   QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM_0, i);
+		list->time_interval = ocelot_read(ocelot, QSYS_GCL_CFG_REG_2);
+		reg = ocelot_read(ocelot, QSYS_GCL_CFG_REG_1);
+		list->gate_state = QSYS_GCL_CFG_REG_1_GATE_STATE_X(reg);
+
+		list++;
+	}
+
+	return 0;
+}
+
+void get_operparam(struct ocelot *ocelot, struct tsn_qbv_basic *oper)
+{
+	u32 base_timel;
+	u32 base_timeh;
+	u32 val;
+	struct tsn_qbv_entry *glist;
+	int i;
+
+	base_timel = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_1);
+	base_timeh = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_2);
+	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_3);
+	oper->base_time = base_timeh;
+	oper->base_time += ((u64)QSYS_PARAM_STATUS_REG_3_BASE_TIME_SEC_MSB(val)) << 32;
+	oper->base_time = (oper->base_time << 32) | base_timel;
+
+	oper->control_list_length = QSYS_PARAM_STATUS_REG_3_LIST_LENGTH_X(val);
+	oper->cycle_time = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_4);
+	oper->cycle_time_extension = ocelot_read(ocelot,
+						 QSYS_PARAM_STATUS_REG_5);
+
+	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);
+	oper->gate_states = QSYS_PARAM_STATUS_REG_8_OPER_GATE_STATE_X(val);
+
+	glist = (struct tsn_qbv_entry *)kmalloc(oper->control_list_length *
+		sizeof(struct tsn_qbv_entry), GFP_KERNEL);
+
+	oper->control_list = glist;
+
+	for (i = 0; i < oper->control_list_length; i++) {
+		ocelot_field_write(ocelot,
+				   QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM_0, i);
+		val = ocelot_read(ocelot, QSYS_GCL_STATUS_REG_2);
+		oper->control_list->time_interval = val;
+		val = ocelot_read(ocelot, QSYS_GCL_STATUS_REG_1);
+		glist->gate_state = QSYS_GCL_STATUS_REG_1_GATE_STATE_X(val);
+
+		glist++;
+	}
+}
+
+int switch_qbv_get_status(struct net_device *ndev,
+			  struct tsn_qbv_status *qbvstatus)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	struct tsn_qbv_basic *oper = &qbvstatus->oper;
+	u8 p_num = port->chip_port;
+	u32 val;
+
+	ocelot_field_write(ocelot, QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0, p_num);
+
+	qbvstatus->supported_list_max = 64;
+
+	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);
+	if (val & QSYS_PARAM_STATUS_REG_8_CONFIG_PENDING)
+		qbvstatus->config_pending = TRUE;
+	else
+		qbvstatus->config_pending = FALSE;
+
+	qbvstatus->config_change_time = ocelot_read(ocelot,
+						    QSYS_PARAM_STATUS_REG_7);
+	qbvstatus->config_change_time += ((u64)QSYS_PARAM_STATUS_REG_8_CFG_CHG_TIME_SEC_MSB(val)) << 32;
+	qbvstatus->config_change_time = (qbvstatus->config_change_time << 32) |
+					ocelot_read(ocelot,
+						    QSYS_PARAM_STATUS_REG_6);
+
+	qbvstatus->config_change_error = ocelot_read(ocelot,
+						     QSYS_PARAM_STATUS_REG_9);
+
+	get_operparam(ocelot, oper);
+
+	return 0;
+}
+
+int switch_cut_thru_set(struct net_device *ndev, u8 cut_thru)
+{
+	struct ocelot_port *ocelot_port = netdev_priv(ndev);
+	struct ocelot *ocelot = ocelot_port->ocelot;
+	ocelot_write_rix(ocelot, cut_thru, ANA_CUT_THRU_CFG,
+			 ocelot_port->chip_port);
+
+	return 0;
+}
+
+
+int qos_shaper_conf_set(struct net_device *ndev, u32 port_ix)
+{
+	struct ocelot_port *ocelot_port = netdev_priv(ndev);
+	struct ocelot *ocelot = ocelot_port->ocelot;
+	u32 cbs = 0;
+	u32 cir = 0;
+
+	switch (ndev->phydev->speed) {
+	case SPEED_10:
+		cir = 10000000;
+		break;
+	case SPEED_100:
+		cir = 100000000;
+		break;
+	case SPEED_1000:
+		cir = 1000000000;
+		break;
+	case SPEED_2500:
+		cir = 2500000000;
+		break;
+	}
+
+	cir = MSCC_DIV_ROUND_UP(cir, 100);  /* Rate unit is 100 kbps */
+	cir = (cir ? cir : 1);                    /* Avoid using zero rate */
+	cbs = MSCC_DIV_ROUND_UP(cbs, 4096); /* Burst unit is 4kB */
+	cbs = (cbs ? cbs : 1);                    /* Avoid using zero burst size */
+	cir = MIN(GENMASK(15, 0), cir);
+	cbs = MIN(GENMASK(6, 0), cbs);
+
+	ocelot_write_gix(ocelot,
+			 QSYS_CIR_CFG_CIR_RATE(cir) |
+			 QSYS_CIR_CFG_CIR_BURST(cbs),
+			 QSYS_CIR_CFG,
+			 port_ix);
+
+	return 0;
+}
+
+int switch_cbs_set(struct net_device *ndev, u8 tc, u8 bw)
+{
+	struct ocelot_port *ocelot_port = netdev_priv(ndev);
+	struct ocelot *ocelot = ocelot_port->ocelot;
+	u8 *weight = ocelot_port->cbs_weight;
+	int i;
+	u8 w_min = 100;
+	u32 c_max = 1 << 5;
+
+	qos_shaper_conf_set(ndev, SE_IX_PORT + ocelot_port->chip_port);
+
+	ocelot_rmw_gix(ocelot,
+		       QSYS_SE_CFG_SE_DWRR_CNT(7) |
+		       QSYS_SE_CFG_SE_AVB_ENA,
+		       QSYS_SE_CFG_SE_DWRR_CNT_M |
+		       QSYS_SE_CFG_SE_AVB_ENA,
+		       QSYS_SE_CFG,
+		       SE_IX_PORT + ocelot_port->chip_port);
+
+	weight[tc] = bw;
+	for (i = 0; i < NUM_MSCC_QOS_PRIO; i++) {
+		if (weight[i])
+			/* Find the lowest weight */
+			w_min = MIN(w_min, weight[i]);
+	}
+	for (i = 0; i < NUM_MSCC_QOS_PRIO; i++) {
+		if (weight[i]) {
+			u32 c = (((c_max << 4) * w_min / weight[i]) + 8) >> 4;
+			c = MAX(1, c) - 1;
+			ocelot_write_ix(ocelot, c,
+					QSYS_SE_DWRR_CFG,
+					SE_IX_PORT + ocelot_port->chip_port,
+					i);
+		} else {
+			ocelot_write_ix(ocelot, 0,
+					QSYS_SE_DWRR_CFG,
+					SE_IX_PORT + ocelot_port->chip_port,
+					i);
+		}
+	}
+
+	return 0;
+}
+
+int switch_qbu_set(struct net_device *ndev, u8 preemptable)
+{
+	struct ocelot_port *ocelot_port = netdev_priv(ndev);
+	struct ocelot *ocelot = ocelot_port->ocelot;
+
+	ocelot_port_rmwl(ocelot_port,
+		   DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA |
+		   DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA,
+		   DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA |
+		   DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA,
+		   DEV_GMII_MM_CONFIG_ENABLE_CONFIG);
+
+	ocelot_rmw_rix(ocelot,
+		       QSYS_PREEMPTION_CFG_P_QUEUES(preemptable),
+		       QSYS_PREEMPTION_CFG_P_QUEUES_M,
+		       QSYS_PREEMPTION_CFG,
+		       ocelot_port->chip_port);
+
+	return 0;
+}
+
+/* Qci */
+int switch_cb_streamid_get(struct net_device *ndev, u32 index,
+			   struct tsn_cb_streamid *streamid)
+{
+	struct ocelot_port *ocelot_port = netdev_priv(ndev);
+	struct ocelot *ocelot = ocelot_port->ocelot;
+
+	u32 m_index = index / 4;
+	u32 bucket =  index % 4;
+	u32 val, dst, reg;
+	u64 dmac;
+	u32 ldmac, hdmac;
+
+	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
+			   bucket);
+	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
+			   m_index);
+
+	/*READ command MACACCESS.VALID(11 bit) must be 0 */
+	ocelot_write(ocelot,
+		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ) |
+		     0 << 11, ANA_TABLES_MACACCESS);
+
+	val = ocelot_read(ocelot, ANA_TABLES_MACACCESS);
+	dst = (val & ANA_TABLES_MACACCESS_DEST_IDX_M) >> 3;
+	reg = ocelot_read_rix(ocelot, ANA_PGID_PGID, dst);
+	streamid->ofac_oport = ANA_PGID_PGID_PGID(reg);
+
+	/*Get the entry's MAC address and VLAN id*/
+	ldmac = ocelot_read(ocelot, ANA_TABLES_MACLDATA);
+	val = ocelot_read(ocelot, ANA_TABLES_MACHDATA);
+	val &= 0x1fffffff;
+	hdmac = val & 0xffff;
+	dmac = hdmac;
+	dmac = (dmac << 32) | ldmac;
+	streamid->para.nid.dmac = dmac;
+
+	streamid->para.nid.vid = ANA_TABLES_MACHDATA_VID_X(val);
+
+	val = ocelot_read(ocelot, ANA_TABLES_STREAMDATA);
+	if (!(val & ANA_TABLES_STREAMDATA_SFID_VALID))
+		return -EINVAL;
+
+	streamid->handle = ANA_TABLES_STREAMDATA_SFID(val);
+
+	return 0;
+}
+u32 lookup_pgid(u32 mask, struct ocelot *ocelot)
+{
+	int i;
+	u32 val, port_mask;
+
+	for (i = 0; i < PGID_AGGR; i++) {
+		val = ocelot_read_rix(ocelot, ANA_PGID_PGID, i);
+		port_mask = ANA_PGID_PGID_PGID(val);
+		if (mask == port_mask)
+			return i;
+	}
+	if (i == PGID_AGGR)
+		return PGID_UC;
+
+	return 0;
+}
+int switch_cb_streamid_set(struct net_device *ndev, u32 index, bool enable,
+			   struct tsn_cb_streamid *streamid)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 macl, mach;
+	u16 vid;
+	u64 mac;
+	u32 dst_idx;
+	int sfid, ssid;
+
+	if (streamid->type == 1) {
+		if (enable == TRUE) {
+			netdev_dbg(ndev, "index=%d mac=0x%llx vid=0x%x ssid=%d sfid=%d dst=%d\n",
+				   index, streamid->para.nid.dmac,
+				   streamid->para.nid.vid, streamid->ssid,
+				   streamid->handle,
+				   port->chip_port);
+
+			mac = streamid->para.nid.dmac;
+			macl = mac & 0xffffffff;
+			mach = (mac >> 32) & 0xffff;
+			vid = streamid->para.nid.vid;
+			ocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);
+			ocelot_write(ocelot, ANA_TABLES_MACHDATA_VID(vid) |
+					ANA_TABLES_MACHDATA_MACHDATA(mach),
+					ANA_TABLES_MACHDATA);
+
+			sfid = streamid->handle;
+			ssid = streamid->ssid;
+			ocelot_write(ocelot,
+				     ((sfid >= 0) ? ANA_TABLES_STREAMDATA_SFID_VALID : 0) |
+				     ((sfid >= 0) ? ANA_TABLES_STREAMDATA_SFID(sfid) : 0) |
+				     ((ssid >= 0) ? ANA_TABLES_STREAMDATA_SSID_VALID : 0) |
+				     ((ssid >= 0) ? ANA_TABLES_STREAMDATA_SSID(ssid) : 0),
+				     ANA_TABLES_STREAMDATA);
+
+			dst_idx = port->chip_port;
+			ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
+				     ANA_TABLES_MACACCESS_ENTRYTYPE(1) |
+				     ANA_TABLES_MACACCESS_DEST_IDX(dst_idx) |
+				     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_LEARN),
+				     ANA_TABLES_MACACCESS);
+	}
+		else
+			netdev_info(ndev, "disable stream set\n");
+		return 0;
+	} else
+		return -EINVAL;
+
+}
+
+int switch_qci_sfi_get(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_sfi_conf *sfi)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 val, reg, fmeter_id, max_sdu;
+
+	ocelot_field_write(ocelot, ANA_TABLES_SFIDTIDX_SFID_INDEX_0, index);
+
+	ocelot_write(ocelot,
+		     ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_READ),
+		     ANA_TABLES_SFIDACCESS);
+
+	val = ocelot_read(ocelot, ANA_TABLES_SFIDTIDX);
+	if (!(val & ANA_TABLES_SFIDTIDX_SGID_VALID))
+		return -EINVAL;
+
+	sfi->stream_gate_instance_id = ANA_TABLES_SFIDTIDX_SGID_X(val);
+	fmeter_id = ANA_TABLES_SFIDTIDX_POL_IDX_X(val);
+	sfi->stream_filter.flow_meter_instance_id = fmeter_id;
+
+	reg = ocelot_read(ocelot, ANA_TABLES_SFIDACCESS);
+	max_sdu = ANA_TABLES_SFIDACCESS_MAX_SDU_LEN_X(reg);
+	sfi->stream_filter.maximum_sdu_size  = max_sdu;
+
+	if (reg & ANA_TABLES_SFIDACCESS_IGR_PRIO_MATCH_ENA)
+		sfi->priority_spec = ANA_TABLES_SFIDACCESS_IGR_PRIO_X(reg);
+	else
+		netdev_info(ndev, "priority not enable\n");
+
+	return 0;
+}
+
+int switch_qci_sfi_set(struct net_device *ndev, u32 index, bool enable,
+		       struct tsn_qci_psfp_sfi_conf *sfi)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 igr_prio = sfi->priority_spec;
+	u16 sgid  = sfi->stream_gate_instance_id;
+	u16 pol_idx = sfi->stream_filter.flow_meter_instance_id;
+	u16 max_sdu_len = sfi->stream_filter.maximum_sdu_size;
+
+	netdev_dbg(ndev, "sfid=%d prio=%d sgid=%d pol_idx=%d\n",
+		   index, igr_prio, sgid, pol_idx);
+
+	ocelot_write(ocelot, ANA_TABLES_SFIDTIDX_SGID_VALID |
+		     ANA_TABLES_SFIDTIDX_SGID(sgid) |
+		     ANA_TABLES_SFIDTIDX_POL_ENA |
+		     ANA_TABLES_SFIDTIDX_POL_IDX(pol_idx) |
+		     ANA_TABLES_SFIDTIDX_SFID_INDEX(index),
+		     ANA_TABLES_SFIDTIDX);
+
+	ocelot_write(ocelot,
+		     ((igr_prio >= 0) ? ANA_TABLES_SFIDACCESS_IGR_PRIO_MATCH_ENA : 0) |
+		     ANA_TABLES_SFIDACCESS_IGR_PRIO(igr_prio) |
+		     ANA_TABLES_SFIDACCESS_MAX_SDU_LEN(max_sdu_len) |
+		     ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_WRITE),
+		     ANA_TABLES_SFIDACCESS);
+
+	return 0;
+}
+
+int switch_cb_streamid_counters_get(struct net_device *ndev, u32 index,
+				    struct tsn_cb_streamid_counters *s_counters)
+{
+	return 0;
+}
+
+int switch_qci_sfi_counters_get(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_sfi_counters *sfi_counters)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 sfid = index;
+	u32 match, not_pass, not_pass_sdu, red;
+
+	ocelot_field_write(ocelot, SYS_STAT_CFG_STAT_VIEW_0, sfid);
+	match = ocelot_read_gix(ocelot, SYS_CNT, 0x200);
+	not_pass = ocelot_read_gix(ocelot, SYS_CNT, 0x201);
+	not_pass_sdu = ocelot_read_gix(ocelot, SYS_CNT, 0x202);
+	red = ocelot_read_gix(ocelot, SYS_CNT, 0x203);
+
+	sfi_counters->matching_frames_count = match;
+	sfi_counters->not_passing_frames_count = not_pass;
+	sfi_counters->not_passing_sdu_count = not_pass_sdu;
+	sfi_counters->red_frames_count  =  red;
+
+	sfi_counters->passing_frames_count = match - not_pass;
+	sfi_counters->passing_sdu_count = match - not_pass - not_pass_sdu;
+
+	return 0;
+}
+
+void write_list(struct ocelot *ocelot,
+		struct tsn_qci_psfp_gcl *gcl, uint32_t num)
+{
+	int i;
+	u32 time_sum = 0;
+
+	for (i = 0; i < num; i++) {
+		ocelot_write_rix(ocelot,
+				 ANA_SG_GCL_GS_CONFIG_IPS((gcl->ipv < 0) ? 0 : gcl->ipv + 8) |
+				 (gcl->gate_state ? ANA_SG_GCL_GS_CONFIG_GATE_STATE : 0),
+				 ANA_SG_GCL_GS_CONFIG, i);
+
+		time_sum += gcl->time_interval;
+		ocelot_write_rix(ocelot, time_sum, ANA_SG_GCL_TI_CONFIG, i);
+
+		gcl++;
+	}
+}
+
+int switch_qci_sgi_set(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_sgi_conf *sgi_conf)
+{
+	int count;
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	struct tsn_qci_sg_control *admin_list = &sgi_conf->admin;
+	u32 sgid = index;
+	u32 list_length = sgi_conf->admin.control_list_length;
+	u32 cycle_time = sgi_conf->admin.cycle_time;
+	u32 cycle_time_ex = sgi_conf->admin.cycle_time_extension;
+	u32 l_basetime = sgi_conf->admin.base_time & 0x00000000ffffffff;
+	u64 h_basetime = (sgi_conf->admin.base_time & 0xffffffff00000000) >> 32;
+	u64 cur_time;
+
+	/*configure SGID*/
+	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_SGID_0, sgid);
+
+	netdev_info(ndev, "sgid=%d ate_enabled=%d control_list_length=%d cycle_time=0x%x l_basetime=0x%x initipv=%d\n",
+		    sgid, sgi_conf->gate_enabled,
+		    sgi_conf->admin.control_list_length,
+		    cycle_time, l_basetime,
+		    sgi_conf->admin.init_ipv);
+
+	/*Enable SG*/
+	if (sgi_conf->gate_enabled == FALSE) {
+		ocelot_field_write(ocelot,
+				   ANA_SG_CONFIG_REG_3_GATE_ENABLE_0, 0);
+		return 0;
+	}
+	/*admin parameters*/
+	cur_time = ocelot_read(ocelot, DEVCPU_PTP_CUR_SEC_MSB);
+	cur_time = cur_time << 32;
+	cur_time += ocelot_read(ocelot, DEVCPU_PTP_CUR_SEC_LSB);
+	if (h_basetime < cur_time) {
+		h_basetime = cur_time;
+		l_basetime = ocelot_read(ocelot, DEVCPU_PTP_CUR_NSEC);
+	}
+
+	ocelot_write(ocelot, l_basetime, ANA_SG_CONFIG_REG_1);
+	ocelot_write(ocelot, h_basetime, ANA_SG_CONFIG_REG_2);
+	if (sgi_conf->admin.init_ipv >= 0)
+		ocelot_write(ocelot, ANA_SG_CONFIG_REG_3_IPV_VALID |
+			     ANA_SG_CONFIG_REG_3_INIT_IPV(sgi_conf->admin.init_ipv) |
+			     ANA_SG_CONFIG_REG_3_GATE_ENABLE |
+			     ANA_SG_CONFIG_REG_3_LIST_LENGTH(list_length) |
+			     sgi_conf->admin.gate_states << 28 |
+			     ANA_SG_CONFIG_REG_3_BASE_TIME_SEC_MSB(h_basetime >> 32),
+			     ANA_SG_CONFIG_REG_3);
+	else
+		ocelot_write(ocelot, ANA_SG_CONFIG_REG_3_IPV_INVALID(0) |
+			     ANA_SG_CONFIG_REG_3_INIT_IPV(sgi_conf->admin.init_ipv) |
+			     ANA_SG_CONFIG_REG_3_GATE_ENABLE |
+			     ANA_SG_CONFIG_REG_3_LIST_LENGTH(list_length) |
+			     sgi_conf->admin.gate_states << 28 |
+			     ANA_SG_CONFIG_REG_3_BASE_TIME_SEC_MSB(h_basetime >> 32),
+			     ANA_SG_CONFIG_REG_3);
+
+	ocelot_write(ocelot, cycle_time, ANA_SG_CONFIG_REG_4);
+	ocelot_write(ocelot, cycle_time_ex, ANA_SG_CONFIG_REG_5);
+
+	write_list(ocelot, admin_list->gcl, list_length);
+
+	/*CONG_CHANGE TO 1*/
+	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_CONFIG_CHANGE_0, 1);
+
+	count = 0;
+	do { /* Wait until configuration change is complete */
+		msleep(20);
+		count++;
+		if (count == 100) {
+			netdev_err(ndev, "SGI Config change timeout\n");
+			return -ETIMEDOUT;
+		}
+	} while (ocelot_read(ocelot, ANA_SG_ACCESS_CTRL) &
+		 ANA_SG_ACCESS_CTRL_CONFIG_CHANGE);
+
+	return SUCCESS;
+}
+
+void get_list(struct ocelot *ocelot, struct tsn_qci_psfp_gcl *gcl, uint32_t num)
+{
+	int i;
+	u16 val;
+	u32 time = 0;
+	u32 reg;
+
+	for (i = 0; i < num; i++) {
+		val = ocelot_read_rix(ocelot, ANA_SG_GCL_GS_CONFIG, i);
+		if (val & ANA_SG_GCL_GS_CONFIG_GATE_STATE)
+			gcl->gate_state = TRUE;
+		else
+			gcl->gate_state = FALSE;
+
+		if (val & ANA_SG_GCL_GS_CONFIG_IPV_VALID)
+			gcl->ipv = ANA_SG_GCL_GS_CONFIG_IPV(val);
+		else
+			gcl->ipv = 0;
+
+		reg = ocelot_read_rix(ocelot, ANA_SG_GCL_TI_CONFIG, i);
+		gcl->time_interval = (reg - time);
+		time = reg;
+
+		gcl++;
+	}
+}
+
+int switch_qci_sgi_get(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_sgi_conf *sgi_conf)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	struct tsn_qci_sg_control *admin  = &sgi_conf->admin;
+	struct tsn_qci_psfp_gcl *glist;
+
+	u32 val, reg;
+	u32 list_num;
+
+	val = ocelot_read(ocelot, ANA_SG_CONFIG_REG_1);
+	reg = ocelot_read(ocelot, ANA_SG_CONFIG_REG_2);
+	admin->base_time = reg;
+	admin->base_time = (admin->base_time << 32) | val;
+
+	admin->cycle_time = ocelot_read(ocelot,  ANA_SG_CONFIG_REG_4);
+	admin->cycle_time_extension = ocelot_read(ocelot, ANA_SG_CONFIG_REG_5);
+
+	val = ocelot_read(ocelot, ANA_SG_CONFIG_REG_3);
+
+	if (val & ANA_SG_CONFIG_REG_3_IPV_VALID)
+		admin->init_ipv = ANA_SG_CONFIG_REG_3_INIT_IPV_X(val);
+	else
+		netdev_info(ndev, "IPV specified  in bits [0:2] is not used or invalid");
+
+	admin->control_list_length = ANA_SG_CONFIG_REG_3_LIST_LENGTH_X(val);
+	list_num = admin->control_list_length;
+
+	glist = (struct tsn_qci_psfp_gcl *)kmalloc(list_num *
+			sizeof(struct tsn_qci_psfp_gcl), GFP_KERNEL);
+	admin->gcl = glist;
+
+	get_list(ocelot, glist, list_num);
+
+	return 0;
+}
+
+int switch_qci_sgi_status_get(struct net_device *ndev, u16 index,
+			      struct tsn_psfp_sgi_status *sgi_status)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 val, reg;
+
+	/*SET SGID*/
+	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_SGID_0, index);
+
+	val = ocelot_read(ocelot, ANA_SG_STATUS_REG_1);
+	reg = ocelot_read(ocelot, ANA_SG_STATUS_REG_2);
+	sgi_status->config_change_time = reg;
+	sgi_status->config_change_time = sgi_status->config_change_time << 32 |
+					 val;
+
+	val = ocelot_read(ocelot, ANA_SG_STATUS_REG_3);
+	if (val & ANA_SG_STATUS_REG_3_CONFIG_PENDING)
+		sgi_status->config_pending  = TRUE;
+	else
+		sgi_status->config_pending = FALSE;
+
+	if (val & ANA_SG_STATUS_REG_3_GATE_STATE)
+		sgi_status->oper.gate_states  =  TRUE;
+	else
+		sgi_status->oper.gate_states  =  FALSE;
+	/*bit 3 encoding 0:IPV [0:2]is invalid . 1:IPV[0:2] is valid*/
+	if (val & ANA_SG_STATUS_REG_3_IPV_VALID)
+		sgi_status->oper.init_ipv  = ANA_SG_STATUS_REG_3_IPV_X(val);
+	else
+		sgi_status->oper.init_ipv = 0;
+
+	return 0;
+}
+
+int switch_qci_fmi_set(struct net_device *ndev, u32 index,
+		       bool enable, struct tsn_qci_psfp_fmi *fmi)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 cir = 0, cbs = 0, pir = 0, pbs = 0;
+	u32 cir_ena = 0;
+	u32 pbs_max = 0, cbs_max = 0;
+	bool cir_discard = 0, pir_discard = 0;
+
+	pir = fmi->eir;
+	pbs = fmi->ebs;
+
+	if (!fmi->drop_on_yellow) {
+		cir_ena = 1;
+	}
+
+	if (cir_ena) {
+		cir = fmi->cir;
+		cbs = fmi->cbs;
+		if (cir == 0 && cbs == 0) {
+			cir_discard = 1;
+		} else {
+			cir = MSCC_DIV_ROUND_UP(cir, 100);
+			cir *= 3;  /* Rate unit is 33 1/3 kbps */
+			cbs = MSCC_DIV_ROUND_UP(cbs, 4096);
+			cbs = (cbs ? cbs : 1);
+			cbs_max = 60;
+			if (fmi->cf)
+				pir += fmi->cir;
+		}
+	}
+	if (pir == 0 && pbs == 0) {
+		pir_discard = 1;
+	} else {
+		pir = MSCC_DIV_ROUND_UP(pir, 100);
+		pir *= 3;  /* Rate unit is 33 1/3 kbps */
+		pbs = MSCC_DIV_ROUND_UP(pbs, 4096);
+		pbs = (pbs ? pbs : 1);
+		pbs_max = 60;
+	}
+	pir = MIN(GENMASK(15, 0), pir);
+	cir = MIN(GENMASK(15, 0), cir);
+	pbs = MIN(pbs_max, pbs);
+	cbs = MIN(cbs_max, cbs);
+
+	ocelot_write_gix(ocelot, (ANA_POL_MODE_CFG_IPG_SIZE(20) |
+			 ANA_POL_MODE_CFG_FRM_MODE(1) |
+			 (fmi->cf ? ANA_POL_MODE_CFG_DLB_COUPLED : 0) |
+			 (cir_ena ? ANA_POL_MODE_CFG_CIR_ENA : 0) |
+			 ANA_POL_MODE_CFG_OVERSHOOT_ENA),
+			 ANA_POL_MODE_CFG, index);
+
+	ocelot_write_gix(ocelot, ANA_POL_PIR_CFG_PIR_RATE(pir) |
+			 ANA_POL_PIR_CFG_PIR_BURST(pbs),
+			 ANA_POL_PIR_CFG, index);
+
+	ocelot_write_gix(ocelot,
+			 (pir_discard ? GENMASK(22, 0) : 0),
+			 ANA_POL_PIR_STATE, index);
+
+	ocelot_write_gix(ocelot, ANA_POL_CIR_CFG_CIR_RATE(cir) |
+			 ANA_POL_CIR_CFG_CIR_BURST(cbs),
+			 ANA_POL_CIR_CFG, index);
+
+	ocelot_write_gix(ocelot,
+			 (cir_discard ? GENMASK(22, 0) : 0),
+			 ANA_POL_CIR_STATE, index);
+
+	return 0;
+}
+
+int switch_qci_fmi_get(struct net_device *ndev, u32 index,
+		       struct tsn_qci_psfp_fmi *fmi)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 val, reg;
+
+	if (index <= 64)
+		index += 64;
+
+	val = ocelot_read_gix(ocelot, ANA_POL_PIR_CFG, index);
+	reg = ocelot_read_gix(ocelot, ANA_POL_CIR_CFG, index);
+
+	fmi->eir = ANA_POL_PIR_CFG_PIR_RATE_X(val);
+	fmi->ebs = ANA_POL_PIR_CFG_PIR_BURST(val);
+	fmi->cir = ANA_POL_CIR_CFG_CIR_RATE_X(reg);
+	fmi->cbs = ANA_POL_CIR_CFG_CIR_BURST(reg);
+	if (!(fmi->eir | fmi->ebs | fmi->cir | fmi->cbs))
+		fmi->mark_red = TRUE;
+	else
+		fmi->mark_red = FALSE;
+
+	val = ocelot_read_gix(ocelot, ANA_POL_MODE_CFG, index);
+	if (val & ANA_POL_MODE_CFG_DLB_COUPLED)
+		fmi->cf = TRUE;
+	else
+		fmi->cf = FALSE;
+	if (val & ANA_POL_MODE_CFG_CIR_ENA)
+		fmi->drop_on_yellow = FALSE;
+	else
+		fmi->drop_on_yellow = TRUE;
+
+	return 0;
+}
+
+int switch_seq_gen_set(struct net_device *ndev, u32 index,
+		  struct tsn_seq_gen_conf *sg_conf)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u8 iport_mask = sg_conf->iport_mask;
+	u8 split_mask = sg_conf->split_mask;
+	u8 seq_len = sg_conf->seq_len;
+	u32 seq_num = sg_conf->seq_num;
+
+	netdev_dbg(ndev, "iport_mask=0x%x split_mask=0x%x seq_len=%d seq_num=%d\n",
+		   sg_conf->iport_mask, sg_conf->split_mask,
+		   sg_conf->seq_len, sg_conf->seq_num);
+	ocelot_write(ocelot,
+		     ANA_TABLES_SEQ_MASK_SPLIT_MASK(split_mask) |
+		     ANA_TABLES_SEQ_MASK_INPUT_PORT_MASK(iport_mask),
+		     ANA_TABLES_SEQ_MASK);
+	ocelot_write(ocelot,
+		     ANA_TABLES_STREAMTIDX_S_INDEX(index) |
+		     ANA_TABLES_STREAMTIDX_STREAM_SPLIT |
+		     ANA_TABLES_STREAMTIDX_SEQ_SPACE_LOG2(seq_len),
+		     ANA_TABLES_STREAMTIDX);
+
+	ocelot_write(ocelot,
+		     ANA_TABLES_STREAMACCESS_GEN_REC_SEQ_NUM(seq_num) |
+		     ANA_TABLES_STREAMACCESS_SEQ_GEN_REC_ENA |
+		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(0x2),
+		     ANA_TABLES_STREAMACCESS);
+
+	return 0;
+}
+
+int switch_seq_rec_set(struct net_device *ndev, u32 index,
+		  struct tsn_seq_rec_conf *sr_conf)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u8 seq_len = sr_conf->seq_len;
+	u8 hislen = sr_conf->his_len;
+
+	netdev_dbg(ndev, "seq_len=%d hislen=%d rtag_pop_en=%d\n",
+		   sr_conf->seq_len, sr_conf->his_len,
+		   sr_conf->rtag_pop_en);
+
+	ocelot_rmw_rix(ocelot, 1, ANA_PORT_MODE_REDTAG_PARSE_CFG,
+		       ANA_PORT_MODE, port->chip_port);
+
+	ocelot_write(ocelot,
+		     ANA_TABLES_STREAMTIDX_S_INDEX(index) |
+		     ANA_TABLES_STREAMTIDX_FORCE_SF_BEHAVIOUR |
+		     ANA_TABLES_STREAMTIDX_SEQ_HISTORY_LEN(hislen) |
+		     ANA_TABLES_STREAMTIDX_RESET_ON_ROGUE |
+		     (sr_conf->rtag_pop_en ?
+		      ANA_TABLES_STREAMTIDX_REDTAG_POP : 0) |
+		     ANA_TABLES_STREAMTIDX_SEQ_SPACE_LOG2(seq_len),
+		     ANA_TABLES_STREAMTIDX);
+
+	ocelot_write(ocelot,
+		     ANA_TABLES_STREAMACCESS_SEQ_GEN_REC_ENA |
+		     ANA_TABLES_STREAMACCESS_GEN_REC_TYPE |
+		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(0x2),
+		     ANA_TABLES_STREAMACCESS);
+
+	return 0;
+}
diff --git a/include/net/tsn.h b/include/net/tsn.h
index b85485e7b13c..1513a921bfd6 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -52,6 +52,11 @@ struct tsn_ops {
 						struct tsn_preempt_status *preemptstat);
 	int (*tsd_set)(struct net_device *, struct tsn_tsd *);
 	int (*tsd_get)(struct net_device *, struct tsn_tsd_status *);
+	int (*ct_set)(struct net_device *, u8 cut_thru);
+	int (*cbgen_set)(struct net_device *, u32 index,
+			 struct tsn_seq_gen_conf *);
+	int (*cbrec_set)(struct net_device *, u32 index,
+			 struct tsn_seq_rec_conf *);
 };
 
 #endif
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
index fc7a910b250e..636e6f2d7ac9 100644
--- a/include/uapi/linux/tsn.h
+++ b/include/uapi/linux/tsn.h
@@ -13,6 +13,8 @@
 #define MAX_ENTRY_SIZE 2048
 #define MAX_ENTRY_NUMBER 128
 #define MAX_IFNAME_COUNT 64
+#define NUM_MSCC_QOS_PRIO 8
+#define MSCC_QOS_PRIO_MAX (NUM_MSCC_QOS_PRIO - 1)
 
 enum tsn_capability {
 	TSN_CAP_QBV = 0x1,
@@ -54,6 +56,9 @@ enum {
 	TSN_CMD_QAV_GET_CBS,
 	TSN_CMD_TSD_SET,
 	TSN_CMD_TSD_GET,
+	TSN_CMD_CT_SET,
+	TSN_CMD_CBGEN_SET,
+	TSN_CMD_CBREC_SET,
 	TSN_CMD_ECHO,			/* user->kernel request/get-response */
 	TSN_CMD_REPLY,			/* kernel->user event */
 	__TSN_CMD_MAX,
@@ -76,6 +81,9 @@ enum {
 	TSN_ATTR_CBS,			/* credit-based shaper */
 	TSN_ATTR_TSD,			/* Time Specific Departure */
 	TSN_ATTR_QBU,			/* preemption */
+	TSN_ATTR_CT,			/* cut through */
+	TSN_ATTR_CBGEN,			/* 802.1CB sequence generate */
+	TSN_ATTR_CBREC,			/* 802.1CB sequence recover */
 	__TSN_CMD_ATTR_MAX,
 };
 #define TSN_CMD_ATTR_MAX (__TSN_CMD_ATTR_MAX - 1)
@@ -118,6 +126,7 @@ enum {
 	TSN_STREAMID_ATTR_ENABLE,
 	TSN_STREAMID_ATTR_DISABLE,
 	TSN_STREAMID_ATTR_STREAM_HANDLE,
+	TSN_STREAMID_ATTR_SSID,
 	TSN_STREAMID_ATTR_IFOP,
 	TSN_STREAMID_ATTR_OFOP,
 	TSN_STREAMID_ATTR_IFIP,
@@ -268,6 +277,34 @@ enum {
 	TSN_QBV_ATTR_ENTRY_MAX = __TSN_QBV_ATTR_ENTRY_MAX - 1,
 };
 
+enum {
+	TSN_CT_ATTR_UNSPEC,
+	TSN_CT_ATTR_QUEUE_STATE,
+	__TSN_CT_ATTR_MAX,
+	TSN_CT_ATTR_MAX = __TSN_CT_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_CBGEN_ATTR_UNSPEC,
+	TSN_CBGEN_ATTR_INDEX,
+	TSN_CBGEN_ATTR_PORT_MASK,
+	TSN_CBGEN_ATTR_SPLIT_MASK,
+	TSN_CBGEN_ATTR_SEQ_LEN,
+	TSN_CBGEN_ATTR_SEQ_NUM,
+	__TSN_CBGEN_ATTR_MAX,
+	TSN_CBGEN_ATTR_MAX = __TSN_CBGEN_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_CBREC_ATTR_UNSPEC,
+	TSN_CBREC_ATTR_INDEX,
+	TSN_CBREC_ATTR_SEQ_LEN,
+	TSN_CBREC_ATTR_HIS_LEN,
+	TSN_CBREC_ATTR_TAG_POP_EN,
+	__TSN_CBREC_ATTR_MAX,
+	TSN_CBREC_ATTR_MAX = __TSN_CBREC_ATTR_MAX - 1,
+};
+
 #define ptptime_t uint64_t
 
 #define MAX_QUEUE_CNT 8
@@ -438,6 +475,8 @@ struct tsn_cb_streamid {
 	 */
 	int32_t handle;
 
+	int32_t ssid;
+
 	/* The list of ports on which an in-facing Stream identification function
 	 * in the output (towards the system forwarding function) direction
 	 * Only Active Destination MAC and VLAN Stream identification (or nothing)
@@ -810,6 +849,19 @@ struct tsn_qci_psfp_fmi {
 
 };
 
+struct tsn_seq_gen_conf {
+	uint8_t iport_mask;
+	uint8_t split_mask;
+	uint8_t seq_len;
+	uint32_t seq_num;
+};
+
+struct tsn_seq_rec_conf {
+	uint8_t seq_len;
+	uint8_t his_len;
+	bool rtag_pop_en;
+};
+
 /* An entry for gate control list */
 struct tsn_qbv_entry {
 	/* Octet represent the gate states for the corresponding traffic classes
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index 33a7c960cd94..fc079a0c36a4 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -75,7 +75,29 @@ static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
 	[TSN_ATTR_QCI_FMI]		= { .type = NLA_NESTED },
 	[TSN_ATTR_CBS]			= { .type = NLA_NESTED },
 	[TSN_ATTR_TSD]			= { .type = NLA_NESTED },
-	[TSN_ATTR_QBU]			= {	.type = NLA_NESTED },
+	[TSN_ATTR_QBU]			= { .type = NLA_NESTED },
+	[TSN_ATTR_CT]			= { .type = NLA_NESTED },
+	[TSN_ATTR_CBGEN]                = { .type = NLA_NESTED },
+	[TSN_ATTR_CBREC]                = { .type = NLA_NESTED },
+};
+
+static const struct nla_policy ct_policy[TSN_CT_ATTR_MAX + 1] = {
+	[TSN_CT_ATTR_QUEUE_STATE]	= { .type = NLA_U8 }
+};
+
+static const struct nla_policy cbgen_policy[TSN_CBGEN_ATTR_MAX + 1] = {
+	[TSN_CBGEN_ATTR_INDEX]	        = { .type = NLA_U32 },
+	[TSN_CBGEN_ATTR_PORT_MASK]	= { .type = NLA_U8 },
+	[TSN_CBGEN_ATTR_SPLIT_MASK]	= { .type = NLA_U8 },
+	[TSN_CBGEN_ATTR_SEQ_LEN]	= { .type = NLA_U8 },
+	[TSN_CBGEN_ATTR_SEQ_NUM]        = { .type = NLA_U32 },
+};
+
+static const struct nla_policy cbrec_policy[TSN_CBREC_ATTR_MAX + 1] = {
+	[TSN_CBREC_ATTR_INDEX]          = { .type = NLA_U32 },
+	[TSN_CBREC_ATTR_SEQ_LEN]	= { .type = NLA_U8 },
+	[TSN_CBREC_ATTR_HIS_LEN]        = { .type = NLA_U8 },
+	[TSN_CBREC_ATTR_TAG_POP_EN]     = { .type = NLA_FLAG },
 };
 
 static const struct nla_policy qbu_policy[TSN_QBU_ATTR_MAX + 1] = {
@@ -136,6 +158,7 @@ static const struct nla_policy cb_streamid_policy[TSN_STREAMID_ATTR_MAX + 1] = {
 	[TSN_STREAMID_ATTR_ENABLE] 	= { .type = NLA_FLAG},
 	[TSN_STREAMID_ATTR_DISABLE]	= { .type = NLA_FLAG},
 	[TSN_STREAMID_ATTR_STREAM_HANDLE]	= { .type = NLA_S32},
+	[TSN_STREAMID_ATTR_SSID]	= { .type = NLA_S32},
 	[TSN_STREAMID_ATTR_IFOP]	= { .type = NLA_U32},
 	[TSN_STREAMID_ATTR_OFOP]	= { .type = NLA_U32},
 	[TSN_STREAMID_ATTR_IFIP]	= { .type = NLA_U32},
@@ -507,6 +530,8 @@ static int cmd_cb_streamid_set(struct genl_info *info)
 	if (sid[TSN_STREAMID_ATTR_STREAM_HANDLE])
 		sidconf.handle = nla_get_s32(sid[TSN_STREAMID_ATTR_STREAM_HANDLE]);
 
+	if (sid[TSN_STREAMID_ATTR_SSID])
+		sidconf.ssid = nla_get_s32(sid[TSN_STREAMID_ATTR_SSID]);
 	if (sid[TSN_STREAMID_ATTR_IFOP])
 		sidconf.ifac_oport = nla_get_u32(sid[TSN_STREAMID_ATTR_IFOP]);
 	if (sid[TSN_STREAMID_ATTR_OFOP])
@@ -2463,6 +2488,155 @@ static int tsn_tsd_get(struct sk_buff *skb, struct genl_info *info)
 	return tsn_send_reply(rep_skb, info);
 }
 
+static int tsn_ct_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct nlattr *cta[TSN_CT_ATTR_MAX + 1];
+	struct net_device *netdev;
+	const struct tsn_ops *tsnops;
+	int ret;
+	u8 queue_stat;
+
+	ret = tsn_init_check(info, &netdev);
+	if (ret)
+		return ret;
+
+	if (!info->attrs[TSN_ATTR_CT]) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	na = info->attrs[TSN_ATTR_CT];
+
+
+	tsnops = netdev->tsn_ops;
+
+	if (!tsnops->ct_set) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		return -1;
+	}
+
+	ret = NLA_PARSE_NESTED(cta, TSN_CT_ATTR_MAX, na, ct_policy);
+	if (ret) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	queue_stat = nla_get_u8(cta[TSN_CT_ATTR_QUEUE_STATE]);
+
+	ret = tsnops->ct_set(netdev, queue_stat);
+	if (ret < 0) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		return -EINVAL;
+	}
+	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+	return 0;
+}
+
+static int tsn_cbgen_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct nlattr *cbgena[TSN_CBGEN_ATTR_MAX + 1];
+	struct net_device *netdev;
+	const struct tsn_ops *tsnops;
+	int ret;
+	u32 index;
+	struct tsn_seq_gen_conf sg_conf;
+
+	ret = tsn_init_check(info, &netdev);
+	if (ret)
+		return ret;
+
+	if (!info->attrs[TSN_ATTR_CBGEN]) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	na = info->attrs[TSN_ATTR_CBGEN];
+
+
+	tsnops = netdev->tsn_ops;
+
+	if (!tsnops->cbgen_set) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		return -1;
+	}
+
+	ret = NLA_PARSE_NESTED(cbgena, TSN_CBGEN_ATTR_MAX, na, cbgen_policy);
+	if (ret) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	index = nla_get_u32(cbgena[TSN_CBGEN_ATTR_INDEX]);
+
+	memset(&sg_conf, 0, sizeof(struct tsn_seq_gen_conf));
+	sg_conf.iport_mask = nla_get_u8(cbgena[TSN_CBGEN_ATTR_PORT_MASK]);
+	sg_conf.split_mask = nla_get_u8(cbgena[TSN_CBGEN_ATTR_SPLIT_MASK]);
+	sg_conf.seq_len = nla_get_u8(cbgena[TSN_CBGEN_ATTR_SEQ_LEN]);
+	sg_conf.seq_num = nla_get_u32(cbgena[TSN_CBGEN_ATTR_SEQ_NUM]);
+
+	ret = tsnops->cbgen_set(netdev, index, &sg_conf);
+	if (ret < 0) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		return -EINVAL;
+	}
+	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+	return 0;
+}
+
+
+static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct nlattr *cbreca[TSN_CBREC_ATTR_MAX + 1];
+	struct net_device *netdev;
+	const struct tsn_ops *tsnops;
+	int ret;
+	u32 index;
+	struct tsn_seq_rec_conf sr_conf;
+
+	ret = tsn_init_check(info, &netdev);
+	if (ret)
+		return ret;
+
+	if (!info->attrs[TSN_ATTR_CBREC]) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	na = info->attrs[TSN_ATTR_CBREC];
+
+
+	tsnops = netdev->tsn_ops;
+
+	if (!tsnops->cbrec_set) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		return -1;
+	}
+
+	ret = NLA_PARSE_NESTED(cbreca, TSN_CBREC_ATTR_MAX, na, cbrec_policy);
+	if (ret) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	index = nla_get_u32(cbreca[TSN_CBREC_ATTR_INDEX]);
+
+	memset(&sr_conf, 0, sizeof(struct tsn_seq_rec_conf));
+	sr_conf.seq_len = nla_get_u8(cbreca[TSN_CBREC_ATTR_SEQ_LEN]);
+	sr_conf.his_len = nla_get_u8(cbreca[TSN_CBREC_ATTR_HIS_LEN]);
+	sr_conf.rtag_pop_en = nla_get_flag(cbreca[TSN_CBREC_ATTR_TAG_POP_EN]);
+
+	ret = tsnops->cbrec_set(netdev, index, &sr_conf);
+	if (ret < 0) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		return -EINVAL;
+	}
+	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+	return 0;
+}
+
 static const struct genl_ops tsnnl_ops[] = {
 	{
 		.cmd		= TSN_CMD_ECHO,
@@ -2604,6 +2778,24 @@ static const struct genl_ops tsnnl_ops[] = {
 		.policy		= tsn_cmd_policy,
 		.flags		= GENL_ADMIN_PERM,
 	},
+	{
+		.cmd		= TSN_CMD_CT_SET,
+		.doit		= tsn_ct_set,
+		.policy		= tsn_cmd_policy,
+		.flags		= GENL_ADMIN_PERM,
+	},
+	{
+		.cmd		= TSN_CMD_CBGEN_SET,
+		.doit		= tsn_cbgen_set,
+		.policy		= tsn_cmd_policy,
+		.flags		= GENL_ADMIN_PERM,
+	},
+	{
+		.cmd		= TSN_CMD_CBREC_SET,
+		.doit		= tsn_cbrec_set,
+		.policy		= tsn_cmd_policy,
+		.flags		= GENL_ADMIN_PERM,
+	},
 };
 
 static struct genl_family tsn_family = {
-- 
2.17.1


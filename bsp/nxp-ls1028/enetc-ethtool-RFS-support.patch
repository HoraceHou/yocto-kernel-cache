From 93655ef86f94e860b093449d486dbca9123cb397 Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@freescale.com>
Date: Thu, 19 Oct 2017 16:52:21 +0300
Subject: [PATCH 068/706] enetc: ethtool RFS support

Supports flow types ip4, udp/tcp and ether.
Current sim apparently supports only ether at this time though.

Signed-off-by: Alex Marginean <alexandru.marginean@freescale.com>
(cherry picked from commit 804eef4142d72087b8093c0f2412f65e5c03e48b)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c  |  32 +++-
 drivers/net/ethernet/freescale/enetc/enetc.h  |  10 ++
 .../net/ethernet/freescale/enetc/enetc_cbdr.c |  37 ++++
 .../ethernet/freescale/enetc/enetc_ethtool.c  | 158 +++++++++++++++++-
 .../net/ethernet/freescale/enetc/enetc_hw.h   |  31 +++-
 5 files changed, 265 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index 807c8cccedb6..c3a04638d099 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -526,10 +526,13 @@ static void enetc_get_si_caps(struct enetc_ndev_priv *priv)
 	 */
 	priv->si->num_rx_rings = (val >> 16) & 0xff;
 	priv->si->num_tx_rings = val & 0xff;
+	priv->si->num_fs_entries = enetc_rd(hw, ENETC_SIRFSCAPR) & 0x7f;
 }
 
 static void enetc_sw_init(struct enetc_ndev_priv *priv)
 {
+	struct enetc_si *si = priv->si;
+
 	enetc_get_si_caps(priv);
 
 	priv->tx_bd_count = 1024; //TODO: use defines for defaults
@@ -542,8 +545,11 @@ static void enetc_sw_init(struct enetc_ndev_priv *priv)
 				   priv->si->num_tx_rings);
 	priv->num_int_vectors = priv->num_rx_rings;
 
+	priv->cls_rules = kcalloc(si->num_fs_entries, sizeof(*priv->cls_rules),
+				  GFP_KERNEL);
+
 	/* si specific */
-	priv->si->cbd_ring.bd_count = 64; //TODO: use defines for defaults
+	si->cbd_ring.bd_count = 64; //TODO: use defines for defaults
 }
 
 static int enetc_alloc_txbdr(struct enetc_bdr *txr)
@@ -1271,6 +1277,25 @@ static void enetc_port_setup_primary_mac_address(struct enetc_si *si)
 	}
 }
 
+static void enetc_port_alloc_rfs(struct enetc_si *si)
+{
+	struct enetc_hw *hw = &si->hw;
+	int num_entries, vf_entries, i;
+
+	/* split RFS entries between functions */
+	num_entries = enetc_port_rd(hw, ENETC_PRFSCAPR) & 0xf;
+	num_entries = 32 * (1 << num_entries);
+	vf_entries = num_entries / (si->total_vfs + 1);
+
+	for (i = 0; i < si->total_vfs; i++)
+		enetc_port_wr(hw, ENETC_PSIRFSCFGR(i + 1), vf_entries);
+	enetc_port_wr(hw, ENETC_PSIRFSCFGR(0),
+		      num_entries - vf_entries * si->total_vfs);
+
+	/* enable RFS on port */
+	enetc_port_wr(hw, ENETC_PRFSMR, ENETC_PRFSMR_RFSE);
+}
+
 static void enetc_port_alloc_rings(struct enetc_si *si)
 {
 	struct enetc_hw *hw = &si->hw;
@@ -1295,6 +1320,9 @@ static void enetc_configure_port(struct enetc_si *si)
 	/* split up rings between functions */
 	enetc_port_alloc_rings(si);
 
+	/* split up RFS entries */
+	enetc_port_alloc_rfs(si);
+
 	/* fix-up primary MAC addresses, if not set already */
 	enetc_port_setup_primary_mac_address(si);
 
@@ -1495,12 +1523,14 @@ static int enetc_pci_probe(struct pci_dev *pdev,
 static void enetc_pci_remove(struct pci_dev *pdev)
 {
 	struct enetc_si *si = pci_get_drvdata(pdev);
+	struct enetc_ndev_priv *priv = netdev_priv(si->ndev);
 	struct enetc_hw *hw = &si->hw;
 
 	dev_info(&pdev->dev, "enetc_pci_remove()\n");
 
 	unregister_netdev(si->ndev);
 
+	kfree(priv->cls_rules);
 	enetc_free_msix(netdev_priv(si->ndev));
 
 	free_netdev(si->ndev);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index 312b984b5090..6e35174eb1f9 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -119,6 +119,7 @@ struct enetc_si {
 
 	int num_rx_rings; /* how many rings are available in the SI */
 	int num_tx_rings;
+	int num_fs_entries;
 };
 
 #define ENETC_MAX_NUM_TXQS	8
@@ -131,6 +132,11 @@ struct enetc_int_vector {
 	struct enetc_bdr rx_ring;
 };
 
+struct enetc_cls_rule {
+	struct ethtool_rx_flow_spec fs;
+	bool used;
+};
+
 struct enetc_ndev_priv {
 	struct net_device *ndev;
 	struct device *dev; /* dma-mapping device */
@@ -146,8 +152,12 @@ struct enetc_ndev_priv {
 
 	struct enetc_bdr *tx_ring[16];
 	struct enetc_bdr *rx_ring[16];
+
+	struct enetc_cls_rule *cls_rules;
 };
 
 void enetc_set_ethtool_ops(struct net_device *ndev);
 
 void enetc_sync_mac_filters(struct enetc_si *si, int si_idx);
+int enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,
+		       int index);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
index 1ed32c5988f2..3edeca24e524 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
@@ -130,3 +130,40 @@ void enetc_sync_mac_filters(struct enetc_si *si, int si_idx)
 		}
 	}
 }
+
+/* Set entry in RFS table */
+int enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,
+		       int index)
+{
+	struct enetc_cbd cbd = {.cmd = 0};
+	bool async = false;
+	dma_addr_t dma;
+	int err;
+
+	/* fill up the "set" descriptor */
+	cbd.cmd = 0;
+	cbd.cls = 4;
+	cbd.index = cpu_to_le16(index);
+	cbd.length = cpu_to_le16(sizeof(*rfse));
+	cbd.opt[3] = cpu_to_le32(0); /* SI */
+
+	dma = dma_map_single(&si->pdev->dev, rfse, cbd.length,
+			     DMA_TO_DEVICE);
+	if (dma_mapping_error(&si->pdev->dev, dma)) {
+		netdev_err(si->ndev, "DMA mapping of RFS entry failed!\n");
+		return -ENOMEM;
+	}
+
+	cbd.addr[0] = (u32)dma;
+	cbd.addr[1] = (u32)(dma >> 32);
+
+	if (async)
+		cbd.status_flags |= ENETC_CBD_FLAGS_IE;
+
+	err = enetc_send_cmd(si, &cbd, async);
+	if (err)
+		netdev_err(si->ndev, "FS entry add failed (%d)!", err);
+	dma_unmap_single(&si->pdev->dev, dma, cbd.length, DMA_TO_DEVICE);
+
+	return err;
+}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c b/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
index 99fcf4b2e74a..ee821336d071 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
@@ -50,7 +50,7 @@ static void enetc_get_regs(struct net_device *ndev, struct ethtool_regs *regs,
 		PR_REG(hw, SIMSIRRV(i));
 	}
 
-	PR_REG(hw, SICCAPR);
+	PR_REG(hw, PRFSCAPR);
 	/** Tx BDR dump */
 	for (i = 0; i < priv->num_tx_rings; i++) {
 		PR_BDR_REG(hw, tx, i, TBMR);
@@ -147,12 +147,168 @@ static void enetc_get_ethtool_stats(struct net_device *ndev,
 		data[i] = enetc_rd64(hw, enetc_si_counters[i].reg);
 }
 
+/* current HW spec does byte reversal on everything including MAC addresses */
+static void ether_addr_copy_swap(u8 *dst, const u8 *src)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+		dst[i] = src[5 - i];
+}
+
+static int enetc_set_cls_entry(struct enetc_si *si,
+			       struct ethtool_rx_flow_spec *fs, bool en)
+{
+	struct ethtool_tcpip4_spec *l4ip4_h, *l4ip4_m;
+	struct ethtool_usrip4_spec *l3ip4_h, *l3ip4_m;
+	struct ethhdr *eth_h, *eth_m;
+	struct enetc_cmd_rfse rfse = { {0} };
+
+	if (!en)
+		goto done;
+
+	switch (fs->flow_type & 0xff) {
+	case TCP_V4_FLOW:
+		l4ip4_h = &fs->h_u.tcp_ip4_spec;
+		l4ip4_m = &fs->m_u.tcp_ip4_spec;
+		goto l4ip4;
+	case UDP_V4_FLOW:
+		l4ip4_h = &fs->h_u.udp_ip4_spec;
+		l4ip4_m = &fs->m_u.udp_ip4_spec;
+		goto l4ip4;
+	case SCTP_V4_FLOW:
+		l4ip4_h = &fs->h_u.sctp_ip4_spec;
+		l4ip4_m = &fs->m_u.sctp_ip4_spec;
+l4ip4:
+		rfse.sip_h[0] = ntohl(l4ip4_h->ip4src);
+		rfse.sip_m[0] = ntohl(l4ip4_m->ip4src);
+		rfse.dip_h[0] = ntohl(l4ip4_h->ip4dst);
+		rfse.dip_m[0] = ntohl(l4ip4_m->ip4dst);
+		rfse.sport_h = ntohs(l4ip4_h->psrc);
+		rfse.sport_m = ntohs(l4ip4_m->psrc);
+		rfse.dport_h = ntohs(l4ip4_h->pdst);
+		rfse.dport_m = ntohs(l4ip4_m->pdst);
+		if (l4ip4_m->tos)
+			netdev_warn(si->ndev, "ToS field is not supported and was ignored\n");
+		rfse.ethtype_h = 0x0800; /* IPv4 */
+		rfse.ethtype_m = 0xffff;
+		break;
+	case IP_USER_FLOW:
+		l3ip4_h = &fs->h_u.usr_ip4_spec;
+		l3ip4_m = &fs->m_u.usr_ip4_spec;
+
+		rfse.sip_h[0] = ntohl(l3ip4_h->ip4src);
+		rfse.sip_m[0] = ntohl(l3ip4_m->ip4src);
+		rfse.dip_h[0] = ntohl(l3ip4_h->ip4dst);
+		rfse.dip_m[0] = ntohl(l3ip4_m->ip4dst);
+		if (l3ip4_m->tos)
+			netdev_warn(si->ndev, "ToS field is not supported and was ignored\n");
+		rfse.ethtype_h = 0x0800; /* IPv4 */
+		rfse.ethtype_m = 0xffff;
+		break;
+	case ETHER_FLOW:
+		eth_h = &fs->h_u.ether_spec;
+		eth_m = &fs->m_u.ether_spec;
+
+		ether_addr_copy_swap(rfse.smac_h, eth_h->h_source);
+		ether_addr_copy_swap(rfse.smac_m, eth_m->h_source);
+		ether_addr_copy_swap(rfse.dmac_h, eth_h->h_dest);
+		ether_addr_copy_swap(rfse.dmac_m, eth_m->h_dest);
+		rfse.ethtype_h = ntohs(eth_h->h_proto);
+		rfse.ethtype_m = ntohs(eth_m->h_proto);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	rfse.mode |= ENETC_RFSE_EN;
+	if (fs->ring_cookie != RX_CLS_FLOW_DISC) {
+		rfse.mode |= ENETC_RFSE_MODE_BD;
+		rfse.result = fs->ring_cookie;
+	}
+done:
+	return enetc_set_fs_entry(si, &rfse, fs->location);
+}
+
+static int enetc_get_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *rxnfc,
+			   u32 *rule_locs)
+{
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	int i, j;
+
+	switch (rxnfc->cmd) {
+	case ETHTOOL_GRXRINGS:
+		rxnfc->data = priv->num_rx_rings;
+		break;
+	case ETHTOOL_GRXCLSRLCNT:
+		/* total number of entries */
+		rxnfc->data = priv->si->num_fs_entries;
+		/* number of entries in use */
+		rxnfc->rule_cnt = 0;
+		for (i = 0; i < priv->si->num_fs_entries; i++)
+			if (priv->cls_rules[i].used)
+				rxnfc->rule_cnt++;
+		break;
+	case ETHTOOL_GRXCLSRULE:
+		/* get entry x */
+		rxnfc->fs = priv->cls_rules[rxnfc->fs.location].fs;
+		break;
+	case ETHTOOL_GRXCLSRLALL:
+		/* total number of entries */
+		rxnfc->data = priv->si->num_fs_entries;
+		/* array of indexes of used entries */
+		j = 0;
+		for (i = 0; i < priv->si->num_fs_entries; i++) {
+			if (!priv->cls_rules[i].used)
+				continue;
+			if (j == rxnfc->rule_cnt)
+				return -EMSGSIZE;
+			rule_locs[j++] = i;
+		}
+		/* number of entries in use */
+		rxnfc->rule_cnt = j;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int enetc_set_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *rxnfc)
+{
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	int err;
+
+	switch (rxnfc->cmd) {
+	case ETHTOOL_SRXCLSRLINS:
+		err = enetc_set_cls_entry(priv->si, &rxnfc->fs, true);
+		if (err)
+			return err;
+		priv->cls_rules[rxnfc->fs.location].fs = rxnfc->fs;
+		priv->cls_rules[rxnfc->fs.location].used = 1;
+		break;
+	case ETHTOOL_SRXCLSRLDEL:
+		err = enetc_set_cls_entry(priv->si, &rxnfc->fs, false);
+		if (err)
+			return err;
+		priv->cls_rules[rxnfc->fs.location].used = 0;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
 const struct ethtool_ops enetc_ethtool_ops = {
 	.get_regs_len = enetc_get_reglen,
 	.get_regs = enetc_get_regs,
 	.get_sset_count = enetc_get_sset_count,
 	.get_strings = enetc_get_strings,
 	.get_ethtool_stats = enetc_get_ethtool_stats,
+	.get_rxnfc = enetc_get_rxnfc,
+	.set_rxnfc = enetc_set_rxnfc,
 };
 
 void enetc_set_ethtool_ops(struct net_device *ndev)
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
index a51a31276625..b0ec1f56065c 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
@@ -39,7 +39,7 @@
 #define ENETC_SIMSITRV(n) (0xB00 + (n) * 0x4)
 #define ENETC_SIMSIRRV(n) (0xB80 + (n) * 0x4)
 
-#define ENETC_SICCAPR	0x1200
+#define ENETC_SIRFSCAPR	0x1200
 
 /** SI BDR sub-blocks, n = 0..7 */
 enum enetc_bdr_type {TX, RX};
@@ -99,6 +99,11 @@ enum enetc_bdr_type {TX, RX};
 #define ENETC_PVCFGR_SET_TXBDR(val)	((val) & 0xff)
 #define ENETC_PVCFGR_SET_RXBDR(val)	(((val) & 0xff) << 16)
 
+#define ENETC_PRFSMR		0x01800
+#define ENETC_PRFSMR_RFSE	BIT(31)
+#define ENETC_PRFSCAPR		0x01804
+#define ENETC_PSIRFSCFGR(n)	(0x01814 + (n) * 4) /* n = SI index */
+
 #define ENETC_PM0_CMD_CFG	0x08008
 #define ENETC_PM0_TX_EN		BIT(31)
 #define ENETC_PM0_RX_EN		BIT(30)
@@ -210,3 +215,27 @@ struct enetc_cbd {
 #define ENETC_CBD_FLAGS_SF	BIT(7) /* short format */
 #define ENETC_CBD_FLAGS_IE	BIT(6) /* interrupt enable */
 #define ENETC_CBD_STATUS_MASK	0xf
+
+struct enetc_cmd_rfse {
+	u8 smac_h[6];
+	u8 smac_m[6];
+	u8 dmac_h[6];
+	u8 dmac_m[6];
+	u32 sip_h[4];
+	u32 sip_m[4];
+	u32 dip_h[4];
+	u32 dip_m[4];
+	u16 ethtype_h;
+	u16 ethtype_m;
+	u16 sport_h;
+	u16 sport_m;
+	u16 dport_h;
+	u16 dport_m;
+	u16 vlan_h;
+	u16 vlan_m;
+	u16 result;
+	u16 mode;
+};
+
+#define ENETC_RFSE_EN	BIT(15)
+#define ENETC_RFSE_MODE_BD	2
-- 
2.17.1


From ada6997b0a0c7225ad460d8befb34079676e3b42 Mon Sep 17 00:00:00 2001
From: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
Date: Mon, 11 Mar 2019 18:17:27 +0800
Subject: [PATCH 661/706] mscc: switch: configuration param get

Add Qbu status get, Qbv status get, stream identification and mac
table get, 802.1cb configuration param get.

Signed-off-by: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
(cherry picked from commit f17737d37d1608e99d95ef2735eaff82e198279b)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/mscc/felix_board.c |   2 +
 drivers/net/ethernet/mscc/tsn_switch.c  | 166 ++++++++++++++++++------
 drivers/net/ethernet/mscc/tsn_switch.h  |   3 +
 include/net/tsn.h                       |   2 +
 include/uapi/linux/tsn.h                |  28 ++++
 net/tsn/genl_tsn.c                      | 102 +++++++++++++++
 6 files changed, 260 insertions(+), 43 deletions(-)

diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
index 7c5f03408ff0..be935bfc8c46 100644
--- a/drivers/net/ethernet/mscc/felix_board.c
+++ b/drivers/net/ethernet/mscc/felix_board.c
@@ -42,6 +42,7 @@ const struct tsn_ops switch_tsn_ops = {
 	.qbv_get			= switch_qbv_get,
 	.qbv_get_status			= switch_qbv_get_status,
 	.qbu_set			= switch_qbu_set,
+	.qbu_get                        = switch_qbu_get,
 	.cb_streamid_set		= switch_cb_streamid_set,
 	.cb_streamid_get		= switch_cb_streamid_get,
 	.cb_streamid_counters_get	= switch_cb_streamid_counters_get,
@@ -57,6 +58,7 @@ const struct tsn_ops switch_tsn_ops = {
 	.ct_set				= switch_cut_thru_set,
 	.cbgen_set			= switch_seq_gen_set,
 	.cbrec_set			= switch_seq_rec_set,
+	.cb_get				= switch_cb_get,
 	.pcpmap_set			= switch_pcp_map_set,
 	.dscp_set			= switch_dscp_set,
 };
diff --git a/drivers/net/ethernet/mscc/tsn_switch.c b/drivers/net/ethernet/mscc/tsn_switch.c
index e31d5ee4591a..c28c9247ff73 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.c
+++ b/drivers/net/ethernet/mscc/tsn_switch.c
@@ -292,6 +292,7 @@ int switch_qbv_get_status(struct net_device *ndev,
 	struct tsn_qbv_basic *oper = &qbvstatus->oper;
 	u8 p_num = port->chip_port;
 	u32 val;
+	ptptime_t cur_time;
 
 	ocelot_field_write(ocelot, QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0, p_num);
 
@@ -313,6 +314,11 @@ int switch_qbv_get_status(struct net_device *ndev,
 	qbvstatus->config_change_error = ocelot_read(ocelot,
 						     QSYS_PARAM_STATUS_REG_9);
 
+	cur_time = ocelot_read(ocelot, PTP_CUR_SEC_MSB);
+	cur_time = cur_time << 32;
+	cur_time += ocelot_read(ocelot, PTP_CUR_SEC_LSB);
+	cur_time = (cur_time << 32) | ocelot_read(ocelot, PTP_CUR_NSEC);
+	qbvstatus->current_time = cur_time;
 	get_operparam(ocelot, oper);
 
 	return 0;
@@ -451,6 +457,27 @@ int switch_qbu_set(struct net_device *ndev, u8 preemptable)
 	return 0;
 }
 
+int switch_qbu_get(struct net_device *ndev, struct tsn_preempt_status *c)
+{
+	struct ocelot_port *ocelot_port = netdev_priv(ndev);
+	struct ocelot *ocelot = ocelot_port->ocelot;
+	u32 val;
+
+	val = ocelot_read_rix(ocelot,
+			      QSYS_PREEMPTION_CFG,
+			      ocelot_port->chip_port);
+
+	c->admin_state = QSYS_PREEMPTION_CFG_P_QUEUES(val);
+	c->hold_advance = QSYS_PREEMPTION_CFG_HOLD_ADVANCE_X(val);
+
+	val = ocelot_port_readl(ocelot_port,
+				DEV_GMII_MM_STATISTICS_MM_STATUS);
+	c->preemption_active =
+		DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STATUS & val;
+
+	return 0;
+}
+
 /* Qci */
 int switch_cb_streamid_get(struct net_device *ndev, u32 index,
 			   struct tsn_cb_streamid *streamid)
@@ -464,6 +491,7 @@ int switch_cb_streamid_get(struct net_device *ndev, u32 index,
 	u64 dmac;
 	u32 ldmac, hdmac;
 
+	streamid->type = 1;
 	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
 			   bucket);
 	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
@@ -471,8 +499,8 @@ int switch_cb_streamid_get(struct net_device *ndev, u32 index,
 
 	/*READ command MACACCESS.VALID(11 bit) must be 0 */
 	ocelot_write(ocelot,
-		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ) |
-		     0 << 11, ANA_TABLES_MACACCESS);
+		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ) ,
+		     ANA_TABLES_MACACCESS);
 
 	val = ocelot_read(ocelot, ANA_TABLES_MACACCESS);
 	dst = (val & ANA_TABLES_MACACCESS_DEST_IDX_M) >> 3;
@@ -494,7 +522,7 @@ int switch_cb_streamid_get(struct net_device *ndev, u32 index,
 	if (!(val & ANA_TABLES_STREAMDATA_SFID_VALID))
 		return -EINVAL;
 
-	streamid->handle = ANA_TABLES_STREAMDATA_SFID(val);
+	streamid->handle = ANA_TABLES_STREAMDATA_SSID_X(val);
 
 	return 0;
 }
@@ -524,46 +552,64 @@ int switch_cb_streamid_set(struct net_device *ndev, u32 index, bool enable,
 	u64 mac;
 	u32 dst_idx;
 	int sfid, ssid;
+	u32 m_index = index / 4;
+	u32 bucket =  index % 4;
 
-	if (streamid->type == 1) {
-		if (enable == TRUE) {
-			netdev_dbg(ndev, "index=%d mac=0x%llx vid=0x%x sfid=%d dst=%d\n",
-				   index, streamid->para.nid.dmac,
-				   streamid->para.nid.vid,
-				   streamid->handle,
-				   port->chip_port);
-
-			mac = streamid->para.nid.dmac;
-			macl = mac & 0xffffffff;
-			mach = (mac >> 32) & 0xffff;
-			vid = streamid->para.nid.vid;
-			ocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);
-			ocelot_write(ocelot, ANA_TABLES_MACHDATA_VID(vid) |
-					ANA_TABLES_MACHDATA_MACHDATA(mach),
-					ANA_TABLES_MACHDATA);
-
-			sfid = streamid->handle * 2;
-			ssid = streamid->handle;
-			ocelot_write(ocelot,
-				     ((sfid >= 0) ? ANA_TABLES_STREAMDATA_SFID_VALID : 0) |
-				     ((sfid >= 0) ? ANA_TABLES_STREAMDATA_SFID(sfid) : 0) |
-				     ((ssid >= 0) ? ANA_TABLES_STREAMDATA_SSID_VALID : 0) |
-				     ((ssid >= 0) ? ANA_TABLES_STREAMDATA_SSID(ssid) : 0),
-				     ANA_TABLES_STREAMDATA);
-
-			dst_idx = port->chip_port;
-			ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
-				     ANA_TABLES_MACACCESS_ENTRYTYPE(1) |
-				     ANA_TABLES_MACACCESS_DEST_IDX(dst_idx) |
-				     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_LEARN),
-				     ANA_TABLES_MACACCESS);
-	}
-		else
-			netdev_info(ndev, "disable stream set\n");
-		return 0;
-	} else
+	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
+			   bucket);
+	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
+			   m_index);
+	if (streamid->type != 1)
 		return -EINVAL;
 
+	if (enable == TRUE) {
+		netdev_dbg(ndev, "index=%d mac=0x%llx vid=0x%x sfid=%d dst=%d\n",
+			   index, streamid->para.nid.dmac,
+			   streamid->para.nid.vid,
+			   streamid->handle,
+			   port->chip_port);
+
+		mac = streamid->para.nid.dmac;
+		macl = mac & 0xffffffff;
+		mach = (mac >> 32) & 0xffff;
+		vid = streamid->para.nid.vid;
+		ocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);
+		ocelot_write(ocelot, ANA_TABLES_MACHDATA_VID(vid) |
+			     ANA_TABLES_MACHDATA_MACHDATA(mach),
+			     ANA_TABLES_MACHDATA);
+
+		sfid = streamid->handle * 2;
+		ssid = streamid->handle;
+		ocelot_write(ocelot,
+			     ANA_TABLES_STREAMDATA_SFID_VALID |
+			     ANA_TABLES_STREAMDATA_SFID(sfid) |
+			     ANA_TABLES_STREAMDATA_SSID_VALID |
+			     ANA_TABLES_STREAMDATA_SSID(ssid),
+			     ANA_TABLES_STREAMDATA);
+
+		dst_idx = port->chip_port;
+		ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
+			     ANA_TABLES_MACACCESS_ENTRYTYPE(1) |
+			     ANA_TABLES_MACACCESS_DEST_IDX(dst_idx) |
+			     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_WRITE),
+			     ANA_TABLES_MACACCESS);
+	} else {
+		netdev_info(ndev, "disable stream set\n");
+		mac = streamid->para.nid.dmac;
+		macl = mac & 0xffffffff;
+		mach = (mac >> 32) & 0xffff;
+		vid = streamid->para.nid.vid;
+		ocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);
+		ocelot_write(ocelot, ANA_TABLES_MACHDATA_VID(vid) |
+			     ANA_TABLES_MACHDATA_MACHDATA(mach),
+			     ANA_TABLES_MACHDATA);
+
+		ocelot_write(ocelot,
+			     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_FORGET),
+			     ANA_TABLES_MACACCESS);
+	}
+
+	return 0;
 }
 
 int switch_qci_sfi_get(struct net_device *ndev, u32 index,
@@ -604,7 +650,7 @@ int switch_qci_sfi_set(struct net_device *ndev, u32 index, bool enable,
 {
 	struct ocelot_port *port = netdev_priv(ndev);
 	struct ocelot *ocelot = port->ocelot;
-	u32 igr_prio = sfi->priority_spec;
+	int igr_prio = sfi->priority_spec;
 	u16 sgid  = sfi->stream_gate_instance_id;
 	u16 pol_idx = sfi->stream_filter.flow_meter_instance_id;
 	u16 max_sdu_len = sfi->stream_filter.maximum_sdu_size;
@@ -981,10 +1027,12 @@ int switch_seq_gen_set(struct net_device *ndev, u32 index,
 	netdev_dbg(ndev, "iport_mask=0x%x split_mask=0x%x seq_len=%d seq_num=%d\n",
 		   sg_conf->iport_mask, sg_conf->split_mask,
 		   sg_conf->seq_len, sg_conf->seq_num);
+
 	ocelot_write(ocelot,
 		     ANA_TABLES_SEQ_MASK_SPLIT_MASK(split_mask) |
 		     ANA_TABLES_SEQ_MASK_INPUT_PORT_MASK(iport_mask),
 		     ANA_TABLES_SEQ_MASK);
+
 	ocelot_write(ocelot,
 		     ANA_TABLES_STREAMTIDX_S_INDEX(index) |
 		     ANA_TABLES_STREAMTIDX_STREAM_SPLIT |
@@ -994,7 +1042,7 @@ int switch_seq_gen_set(struct net_device *ndev, u32 index,
 	ocelot_write(ocelot,
 		     ANA_TABLES_STREAMACCESS_GEN_REC_SEQ_NUM(seq_num) |
 		     ANA_TABLES_STREAMACCESS_SEQ_GEN_REC_ENA |
-		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(0x2),
+		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(SFIDACCESS_CMD_WRITE),
 		     ANA_TABLES_STREAMACCESS);
 
 	return 0;
@@ -1028,12 +1076,44 @@ int switch_seq_rec_set(struct net_device *ndev, u32 index,
 	ocelot_write(ocelot,
 		     ANA_TABLES_STREAMACCESS_SEQ_GEN_REC_ENA |
 		     ANA_TABLES_STREAMACCESS_GEN_REC_TYPE |
-		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(0x2),
+		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(SFIDACCESS_CMD_WRITE),
 		     ANA_TABLES_STREAMACCESS);
 
 	return 0;
 }
 
+int switch_cb_get(struct net_device *ndev, u32 index, struct tsn_cb_status *c)
+{
+	u32 val;
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+
+	ocelot_write(ocelot,
+		     ANA_TABLES_STREAMTIDX_S_INDEX(index),
+		     ANA_TABLES_STREAMTIDX);
+
+	ocelot_write(ocelot,
+		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(SFIDACCESS_CMD_READ),
+		     ANA_TABLES_STREAMACCESS);
+
+	val = ocelot_read(ocelot, ANA_TABLES_STREAMACCESS);
+	c->gen_rec = (ANA_TABLES_STREAMACCESS_GEN_REC_TYPE & val) >> 2;
+	c->seq_num = ANA_TABLES_STREAMACCESS_GEN_REC_SEQ_NUM_X(val);
+
+	val = ocelot_read(ocelot, ANA_TABLES_STREAMTIDX);
+	c->err = ANA_TABLES_STREAMTIDX_SEQ_GEN_ERR_STATUS_X(val);
+	c->his_len = ANA_TABLES_STREAMTIDX_SEQ_HISTORY_LEN_X(val);
+	c->seq_len = ANA_TABLES_STREAMTIDX_SEQ_SPACE_LOG2(val);
+
+	val = ocelot_read(ocelot, ANA_TABLES_SEQ_MASK);
+	c->split_mask = ANA_TABLES_SEQ_MASK_SPLIT_MASK_X(val);
+	c->iport_mask = ANA_TABLES_SEQ_MASK_INPUT_PORT_MASK(val);
+
+	c->seq_his = ocelot_read(ocelot, ANA_TABLES_SEQ_HISTORY);
+
+	return 0;
+}
+
 int switch_pcp_map_set(struct net_device *ndev, bool enable)
 {
 	struct ocelot_port *port = netdev_priv(ndev);
diff --git a/drivers/net/ethernet/mscc/tsn_switch.h b/drivers/net/ethernet/mscc/tsn_switch.h
index 8c3d04d051ae..9b2521060a3a 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.h
+++ b/drivers/net/ethernet/mscc/tsn_switch.h
@@ -28,6 +28,7 @@ int switch_qbv_get_status(struct net_device *ndev,
 int switch_cut_thru_set(struct net_device *ndev, u8 cut_thru);
 int switch_cbs_set(struct net_device *ndev, u8 tc, u8 bw);
 int switch_qbu_set(struct net_device *ndev, u8 preemptable);
+int switch_qbu_get(struct net_device *ndev, struct tsn_preempt_status *c);
 int switch_cb_streamid_get(struct net_device *ndev, u32 index,
 			   struct tsn_cb_streamid *streamid);
 int switch_cb_streamid_set(struct net_device *ndev, u32 index,
@@ -55,6 +56,8 @@ int switch_seq_gen_set(struct net_device *ndev, u32 index,
 		       struct tsn_seq_gen_conf *sg_conf);
 int switch_seq_rec_set(struct net_device *ndev, u32 index,
 		       struct tsn_seq_rec_conf *sr_conf);
+int switch_cb_get(struct net_device *ndev, u32 index,
+		  struct tsn_cb_status  *c);
 int switch_pcp_map_set(struct net_device *ndev, bool enable);
 int switch_dscp_set(struct net_device *ndev, bool enable, const u8 dscp_ix,
 		    struct tsn_qos_switch_dscp_conf *c);
diff --git a/include/net/tsn.h b/include/net/tsn.h
index 3bfd4d6b9f28..bcfb33637265 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -60,6 +60,8 @@ struct tsn_ops {
 			 struct tsn_seq_gen_conf *seqgen);
 	int (*cbrec_set)(struct net_device *ndev, u32 index,
 			 struct tsn_seq_rec_conf *seqrec);
+	int (*cb_get)(struct net_device *ndev, u32 index,
+		      struct tsn_cb_status  *c);
 	int (*pcpmap_set)(struct net_device *ndev, bool enable);
 	int (*dscp_set)(struct net_device *ndev, bool enable,
 			const u8 dscp_ix,
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
index d86219c956c4..c074bee3390e 100644
--- a/include/uapi/linux/tsn.h
+++ b/include/uapi/linux/tsn.h
@@ -59,6 +59,7 @@ enum {
 	TSN_CMD_CT_SET,
 	TSN_CMD_CBGEN_SET,
 	TSN_CMD_CBREC_SET,
+	TSN_CMD_CBSTAT_GET,
 	TSN_CMD_PCPMAP_SET,
 	TSN_CMD_DSCP_SET,
 	TSN_CMD_ECHO,			/* user->kernel request/get-response */
@@ -86,6 +87,7 @@ enum {
 	TSN_ATTR_CT,			/* cut through */
 	TSN_ATTR_CBGEN,			/* 802.1CB sequence generate */
 	TSN_ATTR_CBREC,			/* 802.1CB sequence recover */
+	TSN_ATTR_CBSTAT,                 /* 802.1CB status */
 	TSN_ATTR_PCPMAP,		/* map queue number to PCP tag */
 	TSN_ATTR_DSCP,
 	__TSN_CMD_ATTR_MAX,
@@ -309,6 +311,21 @@ enum {
 	TSN_CBREC_ATTR_MAX = __TSN_CBREC_ATTR_MAX - 1,
 };
 
+enum {
+	TSN_CBSTAT_ATTR_UNSPEC,
+	TSN_CBSTAT_ATTR_INDEX,
+	TSN_CBSTAT_ATTR_GEN_REC,
+	TSN_CBSTAT_ATTR_ERR,
+	TSN_CBSTAT_ATTR_SEQ_NUM,
+	TSN_CBSTAT_ATTR_SEQ_LEN,
+	TSN_CBSTAT_ATTR_SPLIT_MASK,
+	TSN_CBSTAT_ATTR_PORT_MASK,
+	TSN_CBSTAT_ATTR_HIS_LEN,
+	TSN_CBSTAT_ATTR_SEQ_HIS,
+	__TSN_CBSTAT_ATTR_MAX,
+	TSN_CBSTAT_ATTR_MAX = __TSN_CBSTAT_ATTR_MAX - 1,
+};
+
 enum {
 	TSN_PCPMAP_ATTR_UNSPEC,
 	TSN_PCPMAP_ATTR_ENABLE,
@@ -906,6 +923,17 @@ struct tsn_seq_rec_conf {
 	bool rtag_pop_en;
 };
 
+struct tsn_cb_status {
+	uint8_t gen_rec;
+	uint8_t err;
+	uint32_t seq_num;
+	uint8_t seq_len;
+	uint8_t split_mask;
+	uint8_t iport_mask;
+	uint8_t his_len;
+	uint32_t seq_his;
+};
+
 /* An entry for gate control list */
 struct tsn_qbv_entry {
 	/* Octet represent the gate states for the corresponding traffic
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index 8c35d60d01d0..6d671ee10279 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -42,6 +42,7 @@ static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
 	[TSN_ATTR_CT]			= { .type = NLA_NESTED },
 	[TSN_ATTR_CBGEN]		= { .type = NLA_NESTED },
 	[TSN_ATTR_CBREC]		= { .type = NLA_NESTED },
+	[TSN_ATTR_CBSTAT]               = { .type = NLA_NESTED },
 	[TSN_ATTR_PCPMAP]		= { .type = NLA_NESTED },
 	[TSN_ATTR_DSCP]                 = { .type = NLA_NESTED },
 };
@@ -65,6 +66,18 @@ static const struct nla_policy cbrec_policy[TSN_CBREC_ATTR_MAX + 1] = {
 	[TSN_CBREC_ATTR_TAG_POP_EN]	= { .type = NLA_FLAG },
 };
 
+static const struct nla_policy cbstat_policy[TSN_CBSTAT_ATTR_MAX + 1] = {
+	[TSN_CBSTAT_ATTR_INDEX]         = { .type = NLA_U32 },
+	[TSN_CBSTAT_ATTR_GEN_REC]       = { .type = NLA_U8 },
+	[TSN_CBSTAT_ATTR_ERR]		= { .type = NLA_U8 },
+	[TSN_CBSTAT_ATTR_SEQ_NUM]       = { .type = NLA_U32 },
+	[TSN_CBSTAT_ATTR_SEQ_LEN]       = { .type = NLA_U8 },
+	[TSN_CBSTAT_ATTR_SPLIT_MASK]    = { .type = NLA_U8 },
+	[TSN_CBSTAT_ATTR_PORT_MASK]	= { .type = NLA_U8 },
+	[TSN_CBSTAT_ATTR_HIS_LEN]       = { .type = NLA_U8 },
+	[TSN_CBSTAT_ATTR_SEQ_HIS]       = { .type = NLA_U32 },
+};
+
 static const struct nla_policy pcpmap_policy[TSN_PCPMAP_ATTR_MAX + 1] = {
 	[TSN_PCPMAP_ATTR_ENABLE]	= { .type = NLA_FLAG},
 };
@@ -2918,6 +2931,87 @@ static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 	return 0;
 }
 
+static int tsn_cbstatus_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct nlattr *cba[TSN_CBSTAT_ATTR_MAX + 1];
+	struct nlattr *cbattr;
+	struct net_device *netdev;
+	const struct tsn_ops *tsnops;
+	struct sk_buff *rep_skb;
+	int ret;
+	unsigned int index;
+	struct genlmsghdr *genlhdr;
+	struct tsn_cb_status cbstat;
+	struct tsn_port *port;
+
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
+
+	/* Get status data from device */
+	genlhdr = info->genlhdr;
+
+	memset(&cbstat, 0, sizeof(struct tsn_cb_status));
+
+	if (!tsnops->cb_get) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
+		return -1;
+	}
+
+	na = info->attrs[TSN_ATTR_CBSTAT];
+	ret = NLA_PARSE_NESTED(cba, TSN_CBSTAT_ATTR_MAX,
+			       na, cbstat_policy);
+	if (ret) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	index = nla_get_u32(cba[TSN_CBSTAT_ATTR_INDEX]);
+
+	ret = tsnops->cb_get(netdev, index, &cbstat);
+	if (ret < 0) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
+		return -1;
+	}
+
+	/* Form netlink reply data */
+	ret = tsn_prepare_reply(info, genlhdr->cmd,
+				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
+	if (ret < 0)
+		return ret;
+
+	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
+		return -EMSGSIZE;
+
+	cbattr = nla_nest_start(rep_skb, TSN_ATTR_CBSTAT);
+	if (!cbattr)
+		return -EMSGSIZE;
+
+	if (nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_GEN_REC, cbstat.gen_rec) ||
+	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_ERR, cbstat.err) ||
+	    nla_put_u32(rep_skb, TSN_CBSTAT_ATTR_SEQ_NUM,
+			cbstat.seq_num) ||
+	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_SEQ_LEN, cbstat.seq_len) ||
+	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_SPLIT_MASK,
+		       cbstat.split_mask) ||
+	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_PORT_MASK,
+		       cbstat.iport_mask) ||
+	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_HIS_LEN, cbstat.his_len) ||
+	    nla_put_u32(rep_skb, TSN_CBSTAT_ATTR_SEQ_HIS,
+			cbstat.seq_his))
+		return -EMSGSIZE;
+
+	nla_nest_end(rep_skb, cbattr);
+
+	return tsn_send_reply(rep_skb, info);
+}
+
 static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *na;
@@ -3174,6 +3268,14 @@ static const struct genl_ops tsnnl_ops[] = {
 		.policy		= tsn_cmd_policy,
 		.flags		= GENL_ADMIN_PERM,
 	},
+	{
+		.cmd		= TSN_CMD_CBSTAT_GET,
+		.doit		= tsn_cbstatus_get,
+		.policy		= tsn_cmd_policy,
+		.flags		= GENL_ADMIN_PERM,
+	},
+
+
 	{
 		.cmd		= TSN_CMD_PCPMAP_SET,
 		.doit		= tsn_pcpmap_set,
-- 
2.17.1


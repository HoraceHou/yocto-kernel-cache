From 858e5265f319f421d17ded2f6a1bdd9d3d980914 Mon Sep 17 00:00:00 2001
From: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
Date: Fri, 7 Dec 2018 22:39:14 +0800
Subject: [PATCH 398/706] switch: TSN: Map PCP to QoS class

Map the frame's PCP values to a QoS class, streams from outside
can be identified with different queues.

Signed-off-by: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
(cherry picked from commit e0ca0874ef65e63774b5c554c2462cd5c9af1a90)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/mscc/ocelot.c     |  1 +
 drivers/net/ethernet/mscc/tsn_switch.c | 23 +++++++++++
 drivers/net/ethernet/mscc/tsn_switch.h |  1 +
 include/net/tsn.h                      |  1 +
 include/uapi/linux/tsn.h               |  9 ++++
 net/tsn/genl_tsn.c                     | 57 ++++++++++++++++++++++++++
 6 files changed, 92 insertions(+)

diff --git a/drivers/net/ethernet/mscc/ocelot.c b/drivers/net/ethernet/mscc/ocelot.c
index 0766ac3601cb..19f7c0d99707 100644
--- a/drivers/net/ethernet/mscc/ocelot.c
+++ b/drivers/net/ethernet/mscc/ocelot.c
@@ -1362,6 +1362,7 @@ const struct tsn_ops switch_tsn_ops = {
 	.ct_set				= switch_cut_thru_set,
 	.cbgen_set			= switch_seq_gen_set,
 	.cbrec_set			= switch_seq_rec_set,
+	.pcpmap_set			= switch_pcp_map_set,
 };
 #endif
 
diff --git a/drivers/net/ethernet/mscc/tsn_switch.c b/drivers/net/ethernet/mscc/tsn_switch.c
index 0ba6a4f5adc2..e70e672f446c 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.c
+++ b/drivers/net/ethernet/mscc/tsn_switch.c
@@ -1011,3 +1011,26 @@ int switch_seq_rec_set(struct net_device *ndev, u32 index,
 
 	return 0;
 }
+
+int switch_pcp_map_set(struct net_device *ndev, bool enable)
+{
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	int i;
+
+	ocelot_rmw_gix(ocelot,
+		       (enable ? ANA_PORT_QOS_CFG_QOS_PCP_ENA : 0),
+		       ANA_PORT_QOS_CFG_QOS_PCP_ENA,
+		       ANA_PORT_QOS_CFG,
+		       port->chip_port);
+
+	for (i = 0; i < NUM_MSCC_QOS_PRIO; i++) {
+		ocelot_rmw_ix(ocelot,
+			      ANA_PORT_PCP_DEI_MAP_QOS_PCP_DEI_VAL(i),
+			      ANA_PORT_PCP_DEI_MAP_QOS_PCP_DEI_VAL_M,
+			      ANA_PORT_PCP_DEI_MAP,
+			      port->chip_port, i);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/mscc/tsn_switch.h b/drivers/net/ethernet/mscc/tsn_switch.h
index 3b882afff88d..008e54934016 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.h
+++ b/drivers/net/ethernet/mscc/tsn_switch.h
@@ -53,5 +53,6 @@ int switch_seq_gen_set(struct net_device *ndev, u32 index,
 		       struct tsn_seq_gen_conf *sg_conf);
 int switch_seq_rec_set(struct net_device *ndev, u32 index,
 		       struct tsn_seq_rec_conf *sr_conf);
+int switch_pcp_map_set(struct net_device *ndev, bool enable);
 
 #endif
diff --git a/include/net/tsn.h b/include/net/tsn.h
index 1513a921bfd6..96456fc52db3 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -57,6 +57,7 @@ struct tsn_ops {
 			 struct tsn_seq_gen_conf *);
 	int (*cbrec_set)(struct net_device *, u32 index,
 			 struct tsn_seq_rec_conf *);
+	int (*pcpmap_set)(struct net_device *, bool enable);
 };
 
 #endif
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
index d1cec731d49f..8f939172f8fa 100644
--- a/include/uapi/linux/tsn.h
+++ b/include/uapi/linux/tsn.h
@@ -59,6 +59,7 @@ enum {
 	TSN_CMD_CT_SET,
 	TSN_CMD_CBGEN_SET,
 	TSN_CMD_CBREC_SET,
+	TSN_CMD_PCPMAP_SET,
 	TSN_CMD_ECHO,			/* user->kernel request/get-response */
 	TSN_CMD_REPLY,			/* kernel->user event */
 	__TSN_CMD_MAX,
@@ -84,6 +85,7 @@ enum {
 	TSN_ATTR_CT,			/* cut through */
 	TSN_ATTR_CBGEN,			/* 802.1CB sequence generate */
 	TSN_ATTR_CBREC,			/* 802.1CB sequence recover */
+	TSN_ATTR_PCPMAP,		/* map queue number to PCP tag */
 	__TSN_CMD_ATTR_MAX,
 };
 #define TSN_CMD_ATTR_MAX (__TSN_CMD_ATTR_MAX - 1)
@@ -304,6 +306,13 @@ enum {
 	TSN_CBREC_ATTR_MAX = __TSN_CBREC_ATTR_MAX - 1,
 };
 
+enum {
+	TSN_PCPMAP_ATTR_UNSPEC,
+	TSN_PCPMAP_ATTR_ENABLE,
+	__TSN_PCPMAP_ATTR_MAX,
+	TSN_PCPMAP_ATTR_MAX = __TSN_PCPMAP_ATTR_MAX - 1,
+};
+
 #define ptptime_t uint64_t
 
 #define MAX_QUEUE_CNT 8
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index ff6dff42a143..dc18c9ed5c4e 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -79,6 +79,7 @@ static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
 	[TSN_ATTR_CT]			= { .type = NLA_NESTED },
 	[TSN_ATTR_CBGEN]                = { .type = NLA_NESTED },
 	[TSN_ATTR_CBREC]                = { .type = NLA_NESTED },
+	[TSN_ATTR_PCPMAP]               = { .type = NLA_NESTED },
 };
 
 static const struct nla_policy ct_policy[TSN_CT_ATTR_MAX + 1] = {
@@ -100,6 +101,10 @@ static const struct nla_policy cbrec_policy[TSN_CBREC_ATTR_MAX + 1] = {
 	[TSN_CBREC_ATTR_TAG_POP_EN]     = { .type = NLA_FLAG },
 };
 
+static const struct nla_policy pcpmap_policy[TSN_PCPMAP_ATTR_MAX + 1] = {
+	[TSN_PCPMAP_ATTR_ENABLE]	= { .type = NLA_FLAG},
+};
+
 static const struct nla_policy qbu_policy[TSN_QBU_ATTR_MAX + 1] = {
 	[TSN_QBU_ATTR_ADMIN_STATE] 		= { .type = NLA_U8 },
 	[TSN_QBU_ATTR_HOLD_ADVANCE] 	= { .type = NLA_U32},
@@ -2634,6 +2639,52 @@ static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
 	return 0;
 }
 
+static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct nlattr *pcpmapa[TSN_PCPMAP_ATTR_MAX + 1];
+	struct net_device *netdev;
+	const struct tsn_ops *tsnops;
+	int ret;
+	bool enable = 0;
+
+	ret = tsn_init_check(info, &netdev);
+	if (ret)
+		return ret;
+
+	if (!info->attrs[TSN_ATTR_PCPMAP]) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	na = info->attrs[TSN_ATTR_PCPMAP];
+
+
+	tsnops = netdev->tsn_ops;
+
+	if (!tsnops->pcpmap_set) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_NODEVOPS);
+		return -1;
+	}
+
+	ret = NLA_PARSE_NESTED(pcpmapa, TSN_PCPMAP_ATTR_MAX,
+			       na, pcpmap_policy);
+	if (ret) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	enable = nla_get_flag(pcpmapa[TSN_PCPMAP_ATTR_ENABLE]);
+	ret = tsnops->pcpmap_set(netdev, enable);
+	if (ret < 0) {
+		tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_DEVRETERR);
+		return -EINVAL;
+	}
+	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, TSN_SUCCESS);
+
+	return 0;
+}
+
 static const struct genl_ops tsnnl_ops[] = {
 	{
 		.cmd		= TSN_CMD_ECHO,
@@ -2793,6 +2844,12 @@ static const struct genl_ops tsnnl_ops[] = {
 		.policy		= tsn_cmd_policy,
 		.flags		= GENL_ADMIN_PERM,
 	},
+	{
+		.cmd		= TSN_CMD_PCPMAP_SET,
+		.doit		= tsn_pcpmap_set,
+		.policy		= tsn_cmd_policy,
+		.flags		= GENL_ADMIN_PERM,
+	},
 };
 
 static struct genl_family tsn_family = {
-- 
2.17.1


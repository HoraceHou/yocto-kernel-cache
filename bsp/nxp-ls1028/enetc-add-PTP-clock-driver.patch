From 4eb320eb6890715b7229b0d822c751da8a3ee8be Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@nxp.com>
Date: Mon, 30 Jul 2018 12:21:09 +0800
Subject: [PATCH 180/706] enetc: add PTP clock driver

This patch is to add PTP clock driver for ENETC
1588 timer module. The 1588 timer module interfaces
to up to an unlimited number of 10/100/1000 or 10G
ethernet MACs, providing current time, alarm, and
fiper support.

Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
(cherry picked from commit 6bf912bafe8b03a4567410f05519822393947f4f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/Kconfig  |  13 +
 drivers/net/ethernet/freescale/enetc/Makefile |   3 +
 .../net/ethernet/freescale/enetc/enetc_ptp.c  | 368 ++++++++++++++++++
 .../net/ethernet/freescale/enetc/enetc_ptp.h  |  51 +++
 4 files changed, 435 insertions(+)
 create mode 100644 drivers/net/ethernet/freescale/enetc/enetc_ptp.c
 create mode 100644 drivers/net/ethernet/freescale/enetc/enetc_ptp.h

diff --git a/drivers/net/ethernet/freescale/enetc/Kconfig b/drivers/net/ethernet/freescale/enetc/Kconfig
index 201fcfd3e5a6..610797fdb78f 100644
--- a/drivers/net/ethernet/freescale/enetc/Kconfig
+++ b/drivers/net/ethernet/freescale/enetc/Kconfig
@@ -10,6 +10,19 @@ config FSL_ENETC_VF
 	---help---
 	  TBD
 
+config FSL_ENETC_PTP_CLOCK
+	tristate "ENETC PTP clock driver"
+	depends on FSL_ENETC || FSL_ENETC_VF
+	select PTP_1588_CLOCK
+	---help---
+	  This driver adds support for using the ENETC 1588 timer
+	  as a PTP clock. This clock is only useful if your PTP
+	  programs are getting hardware time stamps on the PTP Ethernet
+	  packets using the SO_TIMESTAMPING API.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called fsl-enetc-ptp.
+
 if FSL_ENETC
 
 config ENETC_TSN
diff --git a/drivers/net/ethernet/freescale/enetc/Makefile b/drivers/net/ethernet/freescale/enetc/Makefile
index dbecaf2b3793..aaa8032a2492 100644
--- a/drivers/net/ethernet/freescale/enetc/Makefile
+++ b/drivers/net/ethernet/freescale/enetc/Makefile
@@ -13,3 +13,6 @@ fsl-enetc-vf-$(CONFIG_FSL_ENETC_VF) += enetc.o enetc_cbdr.o \
 				       enetc_ethtool.o
 fsl-enetc-vf-objs := enetc_vf.o $(fsl-enetc-vf-y)
 endif
+
+obj-$(CONFIG_FSL_ENETC_PTP_CLOCK) += fsl-enetc-ptp.o
+fsl-enetc-ptp-$(CONFIG_FSL_ENETC_PTP_CLOCK) += enetc_ptp.o
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_ptp.c b/drivers/net/ethernet/freescale/enetc/enetc_ptp.c
new file mode 100644
index 000000000000..3054bc05e6fc
--- /dev/null
+++ b/drivers/net/ethernet/freescale/enetc/enetc_ptp.c
@@ -0,0 +1,368 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright 2018 NXP */
+
+#include <linux/module.h>
+#include <linux/ptp_clock_kernel.h>
+
+#include "enetc_ptp.h"
+
+struct enetc_ptp_config {
+	u32	ck_sel;
+	u32	tclk_period;
+	u32	tmr_add;
+	u32	tmr_prsc;
+	u32	tmr_fiper1;
+	u32	tmr_fiper2;
+	u32	tmr_fiper3;
+};
+
+struct enetc_ptp {
+	void __iomem *regs;
+	struct ptp_clock *clock;
+	struct ptp_clock_info caps;
+	struct enetc_ptp_config *config;
+	spinlock_t lock; /* protects regs */
+};
+
+int enetc_phc_index;
+
+static u64 tmr_cnt_read(struct enetc_ptp *ptp)
+{
+	u64 ns;
+	u32 lo, hi;
+
+	lo = enetc_rd_reg(ptp->regs + TMR_CNT_L);
+	hi = enetc_rd_reg(ptp->regs + TMR_CNT_H);
+	ns = (u64)hi << 32;
+	ns |= lo;
+	return ns;
+}
+
+static void tmr_cnt_write(struct enetc_ptp *ptp, u64 ns)
+{
+	u32 hi = ns >> 32;
+	u32 lo = ns & 0xffffffff;
+
+	enetc_wr_reg(ptp->regs + TMR_CNT_L, lo);
+	enetc_wr_reg(ptp->regs + TMR_CNT_H, hi);
+}
+
+static void set_alarm(struct enetc_ptp *ptp)
+{
+	u64 ns;
+	u32 lo, hi;
+
+	ns = tmr_cnt_read(ptp) + 1500000000ULL;
+	ns = div_u64(ns, 1000000000UL) * 1000000000ULL;
+	ns -= ptp->config->tclk_period;
+	hi = ns >> 32;
+	lo = ns & 0xffffffff;
+	enetc_wr_reg(ptp->regs + TMR_ALARM_1_L, lo);
+	enetc_wr_reg(ptp->regs + TMR_ALARM_1_H, hi);
+}
+
+static void set_fipers(struct enetc_ptp *ptp)
+{
+	set_alarm(ptp);
+	enetc_wr_reg(ptp->regs + TMR_FIPER_1, ptp->config->tmr_fiper1);
+	enetc_wr_reg(ptp->regs + TMR_FIPER_2, ptp->config->tmr_fiper2);
+	enetc_wr_reg(ptp->regs + TMR_FIPER_3, ptp->config->tmr_fiper3);
+}
+
+static int enetc_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+	u64 adj, diff;
+	u32 tmr_add;
+	int neg_adj = 0;
+	struct enetc_ptp *ptp_timer = container_of(ptp, struct enetc_ptp, caps);
+
+	if (scaled_ppm < 0) {
+		neg_adj = 1;
+		scaled_ppm = -scaled_ppm;
+	}
+	tmr_add = ptp_timer->config->tmr_add;
+	adj = tmr_add;
+
+	/* calculate diff as adj*(scaled_ppm/65536)/1000000
+	 * and round() to the nearest integer
+	 */
+	adj *= scaled_ppm;
+	diff = div_u64(adj, 8000000);
+	diff = (diff >> 13) + ((diff >> 12) & 1);
+
+	tmr_add = neg_adj ? tmr_add - diff : tmr_add + diff;
+
+	enetc_wr_reg(ptp_timer->regs + TMR_ADD, tmr_add);
+
+	return 0;
+}
+
+static int enetc_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	s64 now;
+	unsigned long flags;
+	struct enetc_ptp *ptp_timer = container_of(ptp, struct enetc_ptp, caps);
+
+	spin_lock_irqsave(&ptp_timer->lock, flags);
+
+	now = tmr_cnt_read(ptp_timer);
+	now += delta;
+	tmr_cnt_write(ptp_timer, now);
+	set_fipers(ptp_timer);
+
+	spin_unlock_irqrestore(&ptp_timer->lock, flags);
+
+	return 0;
+}
+
+static int enetc_ptp_gettime(struct ptp_clock_info *ptp,
+			     struct timespec64 *ts)
+{
+	u64 ns;
+	unsigned long flags;
+	struct enetc_ptp *ptp_timer = container_of(ptp, struct enetc_ptp, caps);
+
+	spin_lock_irqsave(&ptp_timer->lock, flags);
+
+	ns = tmr_cnt_read(ptp_timer);
+
+	spin_unlock_irqrestore(&ptp_timer->lock, flags);
+
+	*ts = ns_to_timespec64(ns);
+
+	return 0;
+}
+
+static int enetc_ptp_settime(struct ptp_clock_info *ptp,
+			     const struct timespec64 *ts)
+{
+	u64 ns;
+	unsigned long flags;
+	struct enetc_ptp *ptp_timer = container_of(ptp, struct enetc_ptp, caps);
+
+	ns = timespec64_to_ns(ts);
+
+	spin_lock_irqsave(&ptp_timer->lock, flags);
+
+	tmr_cnt_write(ptp_timer, ns);
+	set_fipers(ptp_timer);
+
+	spin_unlock_irqrestore(&ptp_timer->lock, flags);
+
+	return 0;
+}
+
+static int enetc_ptp_enable(struct ptp_clock_info *ptp,
+			    struct ptp_clock_request *rq, int on)
+{
+	struct enetc_ptp *ptp_timer = container_of(ptp, struct enetc_ptp, caps);
+	unsigned long flags;
+	u32 bit, mask;
+
+	switch (rq->type) {
+	case PTP_CLK_REQ_EXTTS:
+		switch (rq->extts.index) {
+		case 0:
+			bit = ETS1EN;
+			break;
+		case 1:
+			bit = ETS2EN;
+			break;
+		default:
+			return -EINVAL;
+		}
+		spin_lock_irqsave(&ptp_timer->lock, flags);
+		mask = enetc_rd_reg(ptp_timer->regs + TMR_TEMASK);
+		if (on)
+			mask |= bit;
+		else
+			mask &= ~bit;
+		enetc_wr_reg(ptp_timer->regs + TMR_TEMASK, mask);
+		spin_unlock_irqrestore(&ptp_timer->lock, flags);
+		return 0;
+
+	case PTP_CLK_REQ_PPS:
+		spin_lock_irqsave(&ptp_timer->lock, flags);
+		mask = enetc_rd_reg(ptp_timer->regs + TMR_TEMASK);
+		if (on)
+			mask |= PP1EN;
+		else
+			mask &= ~PP1EN;
+		enetc_wr_reg(ptp_timer->regs + TMR_TEMASK, mask);
+		spin_unlock_irqrestore(&ptp_timer->lock, flags);
+		return 0;
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static struct ptp_clock_info enetc_ptp_caps = {
+	.owner		= THIS_MODULE,
+	.name		= "ENETC PTP clock",
+	.max_adj	= 512000,
+	.n_alarm	= 2,
+	.n_ext_ts	= 2,
+	.n_per_out	= 3,
+	.n_pins		= 0,
+	.pps		= 1,
+	.adjfine	= enetc_ptp_adjfine,
+	.adjtime	= enetc_ptp_adjtime,
+	.gettime64	= enetc_ptp_gettime,
+	.settime64	= enetc_ptp_settime,
+	.enable		= enetc_ptp_enable,
+};
+
+static void enetc_ptp_init(struct enetc_ptp *ptp)
+{
+	u32 tclk = ptp->config->tclk_period;
+	u32 ck_sel = ptp->config->ck_sel;
+	u32 tmr_ctrl;
+	unsigned long flags;
+
+	tmr_ctrl = (tclk & TCLK_PERIOD_MASK) << TCLK_PERIOD_SHIFT |
+		   (ck_sel & CK_SEL_MASK);
+	tmr_ctrl |= FRD | FS;
+
+	spin_lock_irqsave(&ptp->lock, flags);
+
+	enetc_wr_reg(ptp->regs + TMR_CTRL, tmr_ctrl);
+	enetc_wr_reg(ptp->regs + TMR_ADD, ptp->config->tmr_add);
+	enetc_wr_reg(ptp->regs + TMR_PRSC, ptp->config->tmr_prsc);
+	enetc_wr_reg(ptp->regs + TMR_FIPER_1, ptp->config->tmr_fiper1);
+	enetc_wr_reg(ptp->regs + TMR_FIPER_2, ptp->config->tmr_fiper2);
+	enetc_wr_reg(ptp->regs + TMR_FIPER_3, ptp->config->tmr_fiper3);
+	set_alarm(ptp);
+
+	enetc_wr_reg(ptp->regs + TMR_CTRL, tmr_ctrl | TE);
+
+	spin_unlock_irqrestore(&ptp->lock, flags);
+}
+
+/* Reference clock frequency:	400MHz
+ * Nominal frequency:		200MHz
+ */
+static struct enetc_ptp_config ptp_config = {
+	.ck_sel = 1,
+	.tclk_period = 5,
+	.tmr_add = 0x80000000,
+	.tmr_prsc = 2,
+	.tmr_fiper1 = 999999995,
+	.tmr_fiper2 = 99995,
+	.tmr_fiper3 = 99995,
+};
+
+static int enetc_ptp_probe(struct pci_dev *pdev,
+			   const struct pci_device_id *ent)
+{
+	struct enetc_ptp *ptp;
+	int err, len;
+
+	err = pci_enable_device_mem(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "device enable failed\n");
+		return err;
+	}
+
+	/* set up for high or low dma */
+	err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (err) {
+		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+		if (err) {
+			dev_err(&pdev->dev,
+				"DMA configuration failed: 0x%x\n", err);
+			goto err_dma;
+		}
+	}
+
+	err = pci_request_mem_regions(pdev, KBUILD_MODNAME);
+	if (err) {
+		dev_err(&pdev->dev, "pci_request_regions failed err=%d\n", err);
+		goto err_pci_mem_reg;
+	}
+
+	pci_set_master(pdev);
+
+	ptp = kzalloc(sizeof(*ptp), GFP_KERNEL);
+	if (!ptp) {
+		err = -ENOMEM;
+		goto err_alloc_ptp;
+	}
+
+	len = pci_resource_len(pdev, ENETC_BAR_REGS);
+
+	spin_lock_init(&ptp->lock);
+
+	ptp->regs = ioremap(pci_resource_start(pdev, ENETC_BAR_REGS), len);
+	if (!ptp->regs) {
+		err = -ENXIO;
+		dev_err(&pdev->dev, "ioremap() failed\n");
+		goto err_ioremap;
+	}
+
+	ptp->config = &ptp_config;
+
+	enetc_ptp_init(ptp);
+
+	ptp->caps = enetc_ptp_caps;
+
+	ptp->clock = ptp_clock_register(&ptp->caps, &pdev->dev);
+	if (IS_ERR(ptp->clock)) {
+		err = PTR_ERR(ptp->clock);
+		goto err_no_clock;
+	}
+
+	enetc_phc_index = ptp_clock_index(ptp->clock);
+
+	pci_set_drvdata(pdev, ptp);
+
+	return 0;
+
+err_no_clock:
+	iounmap(ptp->regs);
+err_ioremap:
+	kfree(ptp);
+err_alloc_ptp:
+	pci_release_mem_regions(pdev);
+err_pci_mem_reg:
+err_dma:
+	pci_disable_device(pdev);
+
+	return err;
+}
+
+static void enetc_ptp_remove(struct pci_dev *pdev)
+{
+	struct enetc_ptp *ptp = pci_get_drvdata(pdev);
+
+	enetc_wr_reg(ptp->regs + TMR_TEVENT, 0);
+	enetc_wr_reg(ptp->regs + TMR_CTRL, 0);
+
+	enetc_phc_index = -1;
+	ptp_clock_unregister(ptp->clock);
+
+	iounmap(ptp->regs);
+	kfree(ptp);
+
+	pci_release_mem_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+static const struct pci_device_id enetc_ptp_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PTP) },
+	{ 0, } /* End of table. */
+};
+MODULE_DEVICE_TABLE(pci, enetc_ptp_id_table);
+
+static struct pci_driver enetc_ptp_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = enetc_ptp_id_table,
+	.probe = enetc_ptp_probe,
+	.remove = enetc_ptp_remove,
+};
+module_pci_driver(enetc_ptp_driver);
+
+MODULE_DESCRIPTION("ENETC PTP clock driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_ptp.h b/drivers/net/ethernet/freescale/enetc/enetc_ptp.h
new file mode 100644
index 000000000000..e745ae204037
--- /dev/null
+++ b/drivers/net/ethernet/freescale/enetc/enetc_ptp.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright 2018 NXP */
+
+#include "enetc.h"
+
+#define ENETC_DEV_ID_PTP	0xee02
+
+/* Registers definition */
+#define TMR_ID			0x0
+#define TMR_ID_2		0x4
+#define TMR_CTRL		0x80
+#define TMR_TEVENT		0x84
+#define TMR_TEMASK		0x88
+#define TMR_MSIVEC		0x8c
+#define TMR_STAT		0x94
+#define TMR_CNT_H		0x98
+#define TMR_CNT_L		0x9c
+#define TMR_ADD			0xa0
+#define TMR_ACC			0xa4
+#define TMR_PRSC		0xa8
+#define TMR_ECTRL		0xac
+#define TMR_OFF_H		0xb0
+#define TMR_OFF_L		0xb4
+#define TMR_ALARM_1_H		0xb8
+#define TMR_ALARM_1_L		0xbc
+#define TMR_ALARM_2_H		0xc0
+#define TMR_ALARM_2_L		0xc4
+#define TMR_FIPER_1		0xd0
+#define TMR_FIPER_2		0xd4
+#define TMR_FIPER_3		0xd8
+#define TMR_ETTS_1_H		0xe0
+#define TMR_ETTS_1_L		0xe4
+#define TMR_ETTS_2_H		0xe8
+#define TMR_ETTS_2_L		0xec
+#define TMR_CUR_TIME_H		0xf0
+#define TMR_CUR_TIME_L		0xf4
+
+/* Bits definition for the TMR_CTRL register */
+#define FS			BIT(28)
+#define FRD			BIT(14)
+#define TE			BIT(2)
+#define TCLK_PERIOD_MASK	0x3ff
+#define TCLK_PERIOD_SHIFT	16
+#define CK_SEL_MASK		0x3
+
+/* Bits definition for the TMR_TEMASK register */
+#define ETS2EN                BIT(25)
+#define ETS1EN                BIT(24)
+#define PP1EN                 BIT(7)
+#define PP2EN                 BIT(6)
+#define PP3EN                 BIT(5)
-- 
2.17.1


From 34692d43635e1163b34859bc662c5bdcb7c87ac0 Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@nxp.com>
Date: Mon, 1 Oct 2018 17:04:36 +0300
Subject: [PATCH 315/706] enetc-mdio: drive ENETC MDIO from the PCI PF driver

Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
(cherry picked from commit deb942cd2b15b1ebd6b5cc93f0293a02262fa479)
(cherry picked from commit 68b73f601a4a89d0060719453a8b12e5787db14e)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../arm64/boot/dts/freescale/fsl-ls1028a.dtsi |  13 +-
 drivers/net/ethernet/freescale/Kconfig        |   3 +-
 drivers/net/ethernet/freescale/enetc_mdio.c   |  11 ++
 drivers/net/ethernet/freescale/xgmac_mdio.c   | 123 ++++++++----------
 drivers/net/ethernet/freescale/xgmac_mdio.h   |  18 +++
 5 files changed, 88 insertions(+), 80 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/xgmac_mdio.h

diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi
index ebc69ecfc9c6..82e2cfc7b4dc 100755
--- a/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1028a.dtsi
@@ -594,8 +594,11 @@
 			enetc_port2: pci@0,2 {
 				reg = <0x000200 0 0 0 0>;
 			};
-			pci@0,3 {
+			mdio0: pci@0,3 {
 				reg = <0x000300 0 0 0 0>;
+				device_type = "mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
 			};
 			pci@0,4 {
 				reg = <0x000400 0 0 0 0>;
@@ -641,14 +644,6 @@
 			};
 		};
 
-		mdio0: mdio@1f8101c00 {
-			compatible = "fsl,enetc-mdio";
-			device_type = "mdio";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			reg = <0x1 0xf8101c00 0x0 0x2c>;
-		};
-
 		can0: can@2180000 {
 			compatible = "fsl,ls1028ar1-flexcan", "fsl,lx2160ar1-flexcan";
 			reg = <0x0 0x2180000 0x0 0x10000>;
diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index be3b5ed56904..a95aee889247 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -98,8 +98,9 @@ config GIANFAR
 config FSL_ENETC_MDIO
 	tristate "External MDIO PCI endpoint for ENETC"
 	depends on PCI
+	select FSL_XGMAC_MDIO
 	---help---
-	  TBD
+	  Supports MDIO as an integrated PCI endpoint, on SoCs with ENETC.
 
 source "drivers/net/ethernet/freescale/dpaa/Kconfig"
 source "drivers/net/ethernet/freescale/enetc/Kconfig"
diff --git a/drivers/net/ethernet/freescale/enetc_mdio.c b/drivers/net/ethernet/freescale/enetc_mdio.c
index d80bcea58b83..6eab721467ce 100644
--- a/drivers/net/ethernet/freescale/enetc_mdio.c
+++ b/drivers/net/ethernet/freescale/enetc_mdio.c
@@ -34,6 +34,7 @@
 
 #include <linux/module.h>
 #include <linux/pci.h>
+#include "xgmac_mdio.h"
 
 #define ENETC_MDIO_DEV_ID	0xee01
 #define ENETC_DRV_NAME_STR "ENETC MDIO driver"
@@ -41,6 +42,9 @@
 static int enetc_mdio_probe(struct pci_dev *pdev,
 			    const struct pci_device_id *ent)
 {
+	const struct xgmac_mdio_cfg cfg = {
+		.bus_name = "Freescale ENETC MDIO Bus",
+	};
 	int err;
 
 	err = pci_enable_device_mem(pdev);
@@ -57,8 +61,14 @@ static int enetc_mdio_probe(struct pci_dev *pdev,
 
 	pci_set_master(pdev);
 
+	err = xgmac_mdio_probe(&pdev->dev, &pdev->resource[0], &cfg);
+	if (err)
+		goto err_xgmac_probe;
+
 	return 0;
 
+err_xgmac_probe:
+	pci_release_mem_regions(pdev);
 err_pci_mem_reg:
 	pci_disable_device(pdev);
 
@@ -67,6 +77,7 @@ static int enetc_mdio_probe(struct pci_dev *pdev,
 
 void enetc_mdio_remove(struct pci_dev *pdev)
 {
+	xgmac_mdio_remove(dev_get_drvdata(&pdev->dev));
 	pci_release_mem_regions(pdev);
 	pci_disable_device(pdev);
 }
diff --git a/drivers/net/ethernet/freescale/xgmac_mdio.c b/drivers/net/ethernet/freescale/xgmac_mdio.c
index 5a160adcf81d..f0f8f9e1b95e 100644
--- a/drivers/net/ethernet/freescale/xgmac_mdio.c
+++ b/drivers/net/ethernet/freescale/xgmac_mdio.c
@@ -11,15 +11,14 @@
  * kind, whether express or implied.
  */
 
-#include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/phy.h>
-#include <linux/mdio.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/of_mdio.h>
+#include "xgmac_mdio.h"
 
 /* Number of microseconds to wait for a register to respond */
 #define TIMEOUT	1000
@@ -50,16 +49,6 @@ struct tgec_mdio_controller {
 #define MDIO_DATA(x)		(x & 0xffff)
 #define MDIO_DATA_BSY		BIT(31)
 
-struct mdio_fsl_priv {
-	void __iomem *map;
-	struct	fsl_mdio_regs __iomem *mdio_base;
-	bool	is_little_endian;
-};
-
-struct xgmac_mdio_data {
-	unsigned int regs_offset;
-};
-
 static u32 xgmac_read32(void __iomem *regs,
 			bool is_little_endian)
 {
@@ -248,84 +237,43 @@ static int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
 	return value;
 }
 
-static const struct of_device_id xgmac_mdio_match[] = {
-	{
-		.compatible = "fsl,fman-xmdio",
-		.data = &(struct xgmac_mdio_data) {
-			.regs_offset = offsetof(struct tgec_mdio_controller, regs),
-		},
-	},
-	{
-		.compatible = "fsl,fman-memac-mdio",
-		.data = &(struct xgmac_mdio_data) {
-			.regs_offset = offsetof(struct tgec_mdio_controller, regs),
-		},
-	},
-	{
-		.compatible = "fsl,enetc-mdio",
-		.data = &(struct xgmac_mdio_data) {
-			.regs_offset = 0,
-		},
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, xgmac_mdio_match);
 
-static int xgmac_mdio_probe(struct platform_device *pdev)
+int xgmac_mdio_probe(struct device *dev, struct resource *res,
+		     const struct xgmac_mdio_cfg *cfg)
 {
-	const struct of_device_id *id =
-		of_match_device(xgmac_mdio_match, &pdev->dev);
-	struct device_node *np = pdev->dev.of_node;
-	const struct xgmac_mdio_data *data;
-	struct mii_bus *bus;
-	struct resource res;
 	struct mdio_fsl_priv *priv;
+	struct mii_bus *bus;
 	int ret;
 
-	if (!id) {
-		dev_err(&pdev->dev, "Failed to match device\n");
-		return -ENODEV;
-	}
-
-	data = id->data;
-
-	dev_info(&pdev->dev, "found %s compatible node\n", id->compatible);
-
-	ret = of_address_to_resource(np, 0, &res);
-	if (ret) {
-		dev_err(&pdev->dev, "could not obtain address\n");
-		return ret;
-	}
-
 	bus = mdiobus_alloc_size(sizeof(struct mdio_fsl_priv));
 	if (!bus)
 		return -ENOMEM;
 
-	bus->name = "Freescale XGMAC MDIO Bus";
+	bus->name = cfg->bus_name;
 	bus->read = xgmac_mdio_read;
 	bus->write = xgmac_mdio_write;
-	bus->parent = &pdev->dev;
-	snprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res.start);
+	bus->parent = dev;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%llx",
+		 (unsigned long long)res->start);
 
 	/* Set the PHY base address */
 	priv = bus->priv;
-	priv->map = of_iomap(np, 0);
+	priv->map = ioremap(res->start, resource_size(res));
 	if (!priv->map) {
 		ret = -ENOMEM;
 		goto err_ioremap;
 	}
 
-	priv->mdio_base = priv->map + data->regs_offset;
-	priv->is_little_endian = of_property_read_bool(pdev->dev.of_node,
+	priv->mdio_base = priv->map + cfg->regs_offset;
+	priv->is_little_endian = of_property_read_bool(dev->of_node,
 						       "little-endian");
-
-	ret = of_mdiobus_register(bus, np);
+	ret = of_mdiobus_register(bus, dev->of_node);
 	if (ret) {
-		dev_err(&pdev->dev, "cannot register MDIO bus\n");
+		dev_err(dev, "cannot register MDIO bus\n");
 		goto err_registration;
 	}
 
-	platform_set_drvdata(pdev, bus);
+	dev_set_drvdata(dev, bus);
 
 	return 0;
 
@@ -337,10 +285,10 @@ static int xgmac_mdio_probe(struct platform_device *pdev)
 
 	return ret;
 }
+EXPORT_SYMBOL(xgmac_mdio_probe);
 
-static int xgmac_mdio_remove(struct platform_device *pdev)
+int xgmac_mdio_remove(struct mii_bus *bus)
 {
-	struct mii_bus *bus = platform_get_drvdata(pdev);
 	struct mdio_fsl_priv *priv = bus->priv;
 
 	mdiobus_unregister(bus);
@@ -349,14 +297,49 @@ static int xgmac_mdio_remove(struct platform_device *pdev)
 
 	return 0;
 }
+EXPORT_SYMBOL(xgmac_mdio_remove);
+
+static const struct of_device_id xgmac_mdio_match[] = {
+	{
+		.compatible = "fsl,fman-xmdio",
+	},
+	{
+		.compatible = "fsl,fman-memac-mdio",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, xgmac_mdio_match);
+
+static int xgmac_mdio_of_probe(struct platform_device *pdev)
+{
+	const struct xgmac_mdio_cfg cfg = {
+		.regs_offset = offsetof(struct tgec_mdio_controller, regs),
+		.bus_name = "Freescale XGMAC MDIO Bus",
+	};
+	struct resource res;
+	int ret;
+
+	ret = of_address_to_resource(pdev->dev.of_node, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not obtain address\n");
+		return ret;
+	}
+
+	return xgmac_mdio_probe(&pdev->dev, &res, &cfg);
+}
+
+static int xgmac_mdio_of_remove(struct platform_device *pdev)
+{
+	return xgmac_mdio_remove(dev_get_drvdata(&pdev->dev));
+}
 
 static struct platform_driver xgmac_mdio_driver = {
 	.driver = {
 		.name = "fsl-fman_xmdio",
 		.of_match_table = xgmac_mdio_match,
 	},
-	.probe = xgmac_mdio_probe,
-	.remove = xgmac_mdio_remove,
+	.probe = xgmac_mdio_of_probe,
+	.remove = xgmac_mdio_of_remove,
 };
 
 module_platform_driver(xgmac_mdio_driver);
diff --git a/drivers/net/ethernet/freescale/xgmac_mdio.h b/drivers/net/ethernet/freescale/xgmac_mdio.h
new file mode 100644
index 000000000000..eb4ce4e23a3d
--- /dev/null
+++ b/drivers/net/ethernet/freescale/xgmac_mdio.h
@@ -0,0 +1,18 @@
+#include <linux/kernel.h>
+#include <linux/mdio.h>
+
+struct mdio_fsl_priv {
+	void __iomem *map;
+	struct	fsl_mdio_regs __iomem *mdio_base;
+	bool	is_little_endian;
+};
+
+struct xgmac_mdio_cfg {
+	unsigned int regs_offset;
+	const char *bus_name;
+};
+
+int xgmac_mdio_probe(struct device *dev, struct resource *res,
+		     const struct xgmac_mdio_cfg *cfg);
+
+int xgmac_mdio_remove(struct mii_bus *bus);
-- 
2.17.1


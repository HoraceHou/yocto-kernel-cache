From ba849b47e3879de579ed1cc91d89de5e9d94f8c3 Mon Sep 17 00:00:00 2001
From: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
Date: Fri, 8 Mar 2019 10:00:13 +0800
Subject: [PATCH 659/706] mscc: switch: add DSCP set

Set DSCP of QoS tag in frames to map different traffic class
and DPL in switch.

Signed-off-by: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
(cherry picked from commit ba16c092e85465717364512bc6beb8c117aa31a5)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/mscc/felix_board.c |  1 +
 drivers/net/ethernet/mscc/tsn_switch.c  | 55 +++++++++++++++++++
 drivers/net/ethernet/mscc/tsn_switch.h  |  3 +-
 include/net/tsn.h                       |  3 +
 include/uapi/linux/tsn.h                | 20 +++++++
 net/tsn/genl_tsn.c                      | 73 +++++++++++++++++++++++++
 6 files changed, 154 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
index 8e9d99f21f71..7c5f03408ff0 100644
--- a/drivers/net/ethernet/mscc/felix_board.c
+++ b/drivers/net/ethernet/mscc/felix_board.c
@@ -58,6 +58,7 @@ const struct tsn_ops switch_tsn_ops = {
 	.cbgen_set			= switch_seq_gen_set,
 	.cbrec_set			= switch_seq_rec_set,
 	.pcpmap_set			= switch_pcp_map_set,
+	.dscp_set			= switch_dscp_set,
 };
 #endif
 
diff --git a/drivers/net/ethernet/mscc/tsn_switch.c b/drivers/net/ethernet/mscc/tsn_switch.c
index 515c31ecef3a..e31d5ee4591a 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.c
+++ b/drivers/net/ethernet/mscc/tsn_switch.c
@@ -20,6 +20,8 @@
 /* Round x divided by y to nearest higher integer. x and y are integers */
 #define MSCC_DIV_ROUND_UP(x, y) (((x) + (y) - 1) / (y))
 #define SE_IX_PORT 64
+#define MSCC_QOS_DSCP_MAX 63
+#define MSCC_QOS_DP_MAX 1
 #ifndef MIN
 #define MIN(x, y) ((x) < (y) ? (x) : (y))
 #endif
@@ -1056,3 +1058,56 @@ int switch_pcp_map_set(struct net_device *ndev, bool enable)
 
 	return 0;
 }
+
+int switch_dscp_set(struct net_device *ndev,
+		    bool enable,
+		    const u8 dscp_ix,
+		    struct tsn_qos_switch_dscp_conf *c)
+{
+
+	struct ocelot_port *port = netdev_priv(ndev);
+	struct ocelot *ocelot = port->ocelot;
+	u32 val, ri = dscp_ix;
+
+	c->dscp = 0;
+	c->trust = 1;
+	c->remark = 0;
+
+	if (dscp_ix > MSCC_QOS_DSCP_MAX) {
+		netdev_info(ndev, "%s: Invalid dscp_ix %u\n",
+			    __func__, dscp_ix);
+		return -EINVAL;
+	}
+	if (c->cos > MSCC_QOS_PRIO_MAX) {
+		netdev_info(ndev, "%s: Invalid cos %d\n",
+			    __func__, c->cos);
+		return -EINVAL;
+	}
+	if (c->dpl > MSCC_QOS_DP_MAX) {
+		netdev_info(ndev, "%s: Invalid dpl %d\n",
+			    __func__, c->dpl);
+		return -EINVAL;
+	}
+	if (c->dscp > MSCC_QOS_DSCP_MAX) {
+		netdev_info(ndev, "%s: Invalid dscp %d\n",
+			    __func__, c->dscp);
+		return -EINVAL;
+	}
+
+	ocelot_rmw_gix(ocelot,
+		       (enable ? ANA_PORT_QOS_CFG_QOS_DSCP_ENA : 0) |
+		       (c->dscp ? ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA : 0),
+		       ANA_PORT_QOS_CFG_QOS_DSCP_ENA |
+		       ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA,
+		       ANA_PORT_QOS_CFG,
+		       port->chip_port);
+
+	val = (c->dpl ? ANA_DSCP_CFG_DP_DSCP_VAL : 0) |
+	       ANA_DSCP_CFG_QOS_DSCP_VAL(c->cos) |
+	       ANA_DSCP_CFG_DSCP_TRANSLATE_VAL(c->dscp) |
+	       (c->trust ? ANA_DSCP_CFG_DSCP_TRUST_ENA : 0) |
+	       (c->remark ? ANA_DSCP_CFG_DSCP_REWR_ENA : 0);
+
+	ocelot_write_rix(ocelot, val, ANA_DSCP_CFG, ri);
+	return 0;
+}
diff --git a/drivers/net/ethernet/mscc/tsn_switch.h b/drivers/net/ethernet/mscc/tsn_switch.h
index 842a6ac0b87d..8c3d04d051ae 100644
--- a/drivers/net/ethernet/mscc/tsn_switch.h
+++ b/drivers/net/ethernet/mscc/tsn_switch.h
@@ -56,5 +56,6 @@ int switch_seq_gen_set(struct net_device *ndev, u32 index,
 int switch_seq_rec_set(struct net_device *ndev, u32 index,
 		       struct tsn_seq_rec_conf *sr_conf);
 int switch_pcp_map_set(struct net_device *ndev, bool enable);
-
+int switch_dscp_set(struct net_device *ndev, bool enable, const u8 dscp_ix,
+		    struct tsn_qos_switch_dscp_conf *c);
 #endif
diff --git a/include/net/tsn.h b/include/net/tsn.h
index 18c4f440fb25..3bfd4d6b9f28 100644
--- a/include/net/tsn.h
+++ b/include/net/tsn.h
@@ -61,6 +61,9 @@ struct tsn_ops {
 	int (*cbrec_set)(struct net_device *ndev, u32 index,
 			 struct tsn_seq_rec_conf *seqrec);
 	int (*pcpmap_set)(struct net_device *ndev, bool enable);
+	int (*dscp_set)(struct net_device *ndev, bool enable,
+			const u8 dscp_ix,
+			struct tsn_qos_switch_dscp_conf *c);
 };
 
 enum ethdev_type {
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
index f23bd62aa29c..d86219c956c4 100644
--- a/include/uapi/linux/tsn.h
+++ b/include/uapi/linux/tsn.h
@@ -60,6 +60,7 @@ enum {
 	TSN_CMD_CBGEN_SET,
 	TSN_CMD_CBREC_SET,
 	TSN_CMD_PCPMAP_SET,
+	TSN_CMD_DSCP_SET,
 	TSN_CMD_ECHO,			/* user->kernel request/get-response */
 	TSN_CMD_REPLY,			/* kernel->user event */
 	__TSN_CMD_MAX,
@@ -86,6 +87,7 @@ enum {
 	TSN_ATTR_CBGEN,			/* 802.1CB sequence generate */
 	TSN_ATTR_CBREC,			/* 802.1CB sequence recover */
 	TSN_ATTR_PCPMAP,		/* map queue number to PCP tag */
+	TSN_ATTR_DSCP,
 	__TSN_CMD_ATTR_MAX,
 };
 #define TSN_CMD_ATTR_MAX (__TSN_CMD_ATTR_MAX - 1)
@@ -314,6 +316,16 @@ enum {
 	TSN_PCPMAP_ATTR_MAX = __TSN_PCPMAP_ATTR_MAX - 1,
 };
 
+enum {
+	TSN_DSCP_ATTR_UNSPEC,
+	TSN_DSCP_ATTR_DISABLE,
+	TSN_DSCP_ATTR_INDEX,
+	TSN_DSCP_ATTR_COS,
+	TSN_DSCP_ATTR_DPL,
+	__TSN_DSCP_ATTR_MAX,
+	TSN_DSCP_ATTR_MAX = __TSN_DSCP_ATTR_MAX - 1,
+};
+
 #define ptptime_t uint64_t
 
 #define MAX_QUEUE_CNT 8
@@ -1059,4 +1071,12 @@ struct tsn_tsd_status {
 	uint32_t loss_steps;
 };
 
+struct tsn_qos_switch_dscp_conf {
+	bool trust;
+	u8 cos;
+	u8 dpl;
+	bool remark;
+	u8 dscp; /* New ingress translated DSCP value */
+};
+
 #endif /* _UAPI_GENL_TSN_H */
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
index 49bc331d9720..8c35d60d01d0 100644
--- a/net/tsn/genl_tsn.c
+++ b/net/tsn/genl_tsn.c
@@ -43,6 +43,7 @@ static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
 	[TSN_ATTR_CBGEN]		= { .type = NLA_NESTED },
 	[TSN_ATTR_CBREC]		= { .type = NLA_NESTED },
 	[TSN_ATTR_PCPMAP]		= { .type = NLA_NESTED },
+	[TSN_ATTR_DSCP]                 = { .type = NLA_NESTED },
 };
 
 static const struct nla_policy ct_policy[TSN_CT_ATTR_MAX + 1] = {
@@ -211,6 +212,13 @@ static const struct nla_policy qci_fmi_policy[] = {
 		.len = sizeof(struct tsn_qci_psfp_fmi_counters)},
 };
 
+static const struct nla_policy dscp_policy[] = {
+	[TSN_DSCP_ATTR_INDEX]		= { .type = NLA_U32},
+	[TSN_DSCP_ATTR_DISABLE]		= { .type = NLA_FLAG},
+	[TSN_DSCP_ATTR_COS]		= { .type = NLA_U32},
+	[TSN_DSCP_ATTR_DPL]		= { .type = NLA_U32},
+};
+
 static int tsn_prepare_reply(struct genl_info *info, u8 cmd,
 			     struct sk_buff **skbp, size_t size)
 {
@@ -2962,6 +2970,65 @@ static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
 	return 0;
 }
 
+static int tsn_dscp_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	struct nlattr *dscpa[TSN_DSCP_ATTR_MAX + 1];
+	struct net_device *netdev;
+	const struct tsn_ops *tsnops;
+	int ret;
+	bool enable = 0;
+	struct tsn_port *port;
+	int dscp_ix;
+	struct tsn_qos_switch_dscp_conf dscp_conf;
+
+	port = tsn_init_check(info, &netdev);
+	if (!port)
+		return -ENODEV;
+
+	tsnops = port->tsnops;
+
+	if (!info->attrs[TSN_ATTR_DSCP]) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	na = info->attrs[TSN_ATTR_DSCP];
+
+	if (!tsnops->dscp_set) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_NODEVOPS);
+		return -1;
+	}
+
+	ret = NLA_PARSE_NESTED(dscpa, TSN_DSCP_ATTR_MAX,
+			       na, dscp_policy);
+	if (ret) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_ATTRERR);
+		return -EINVAL;
+	}
+
+	enable = 1;
+	if (dscpa[TSN_DSCP_ATTR_DISABLE])
+		enable = 0;
+	dscp_ix = nla_get_u32(dscpa[TSN_DSCP_ATTR_INDEX]);
+	dscp_conf.cos = nla_get_u32(dscpa[TSN_DSCP_ATTR_COS]);
+	dscp_conf.dpl = nla_get_u32(dscpa[TSN_DSCP_ATTR_DPL]);
+	ret = tsnops->dscp_set(netdev, enable, dscp_ix, &dscp_conf);
+	if (ret < 0) {
+		tsn_simple_reply(info, TSN_CMD_REPLY,
+				 netdev->name, -TSN_DEVRETERR);
+		return -EINVAL;
+	}
+
+	tsn_simple_reply(info, TSN_CMD_REPLY,
+			 netdev->name, TSN_SUCCESS);
+
+	return 0;
+}
+
 static const struct genl_ops tsnnl_ops[] = {
 	{
 		.cmd		= TSN_CMD_ECHO,
@@ -3113,6 +3180,12 @@ static const struct genl_ops tsnnl_ops[] = {
 		.policy		= tsn_cmd_policy,
 		.flags		= GENL_ADMIN_PERM,
 	},
+	{
+		.cmd		= TSN_CMD_DSCP_SET,
+		.doit		= tsn_dscp_set,
+		.policy		= tsn_cmd_policy,
+		.flags		= GENL_ADMIN_PERM,
+	},
 };
 
 static struct genl_family tsn_family = {
-- 
2.17.1


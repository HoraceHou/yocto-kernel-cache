From a2629b948ab37fbc2cede9681ff5eec1807a96ef Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@nxp.com>
Date: Tue, 16 Oct 2018 10:49:02 +0300
Subject: [PATCH 353/706] enetc: Cleanup updates for register names and other;
 sync w/ latest enetc driver

Merges following from unified_branch:
enetc: Replace obsolete Tx BDR index register names with current RM ones
(cherry picked from commit "5c805e1ae54c7ca1c8f93a11f388398bba56a881")
enetc: Replace obsolete CBDR index register names with current RM ones
(cherry picked from commit "ccfc4562333017a3bf7ffa624256688040a9689f")
enetc_tsn: Replace obsolete CBDR index register names with current RM ones
(cherry picked from commit "f19c7b41613e47a7ce3e6d47f7a2708118671636")
enetc: Clean up SI register block
(cherry picked from commit "fd863618f2ee3175c50902e63db014c8a04d93ab")
enetc: Clean up Port and Global register blocks
(cherry picked from commit "ff86e9566e469301496413b8e463e9cf4f7031ef")
enetc: Cleanup enetc_hw.h accessors, fix code style issue
(cherry picked from commit "e57e99ba3914cf2c79b60ce9ea2f09c81055b2e8")
enetc: Fix remaining obvious codestyle issues
(cherry picked from commit "757174336860c634a3728dddee1fcea7aa3d859c")

Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
(cherry picked from commit 36313287eb29d8d4a8d8899f0c7e6624e4b9e238)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c  |  14 +-
 drivers/net/ethernet/freescale/enetc/enetc.h  |   6 +-
 .../net/ethernet/freescale/enetc/enetc_cbdr.c |   6 +-
 .../ethernet/freescale/enetc/enetc_ethtool.c  |   6 +-
 .../net/ethernet/freescale/enetc/enetc_hw.h   | 136 ++++++++----------
 .../net/ethernet/freescale/enetc/enetc_pf.c   |   9 +-
 .../net/ethernet/freescale/enetc/enetc_tsn.c  |  24 ++--
 7 files changed, 91 insertions(+), 110 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index 7c21893f6bd6..b0d33b338fb9 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -77,7 +77,6 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
 	}
 
 	if (enetc_bd_unused(tx_ring) < ENETC_FREE_TXBD_NEEDED) {
-		// TODO: check h/w index (CISR) for more acurate status
 		netif_stop_subqueue(ndev, tx_ring->index);
 		return NETDEV_TX_BUSY;
 	}
@@ -89,7 +88,6 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
 	}
 
 	if (enetc_bd_unused(tx_ring) < ENETC_FREE_TXBD_NEEDED)
-		// TODO: check h/w index (CISR) for more acurate status
 		netif_stop_subqueue(ndev, tx_ring->index);
 
 	return NETDEV_TX_OK;
@@ -245,7 +243,7 @@ static int enetc_map_tx_buffs(struct enetc_bdr *tx_ring, struct sk_buff *skb,
 	if (debug)
 		enetc_dbg_print_skb(skb, TX);
 	/* let H/W know BD ring has been updated */
-	enetc_wr_reg(tx_ring->tcir, i); /* includes wmb() */
+	enetc_wr_reg(tx_ring->tpir, i); /* includes wmb() */
 
 	return count;
 
@@ -315,7 +313,7 @@ static void enetc_unmap_tx_buff(struct enetc_bdr *tx_ring,
 
 static int enetc_bd_ready_count(struct enetc_bdr *tx_ring, int ci)
 {
-	int pi = enetc_rd_reg(tx_ring->tcisr) & ENETC_TBCISR_IDX_MASK;
+	int pi = enetc_rd_reg(tx_ring->tcir) & ENETC_TBCIR_IDX_MASK;
 
 	return pi >= ci ? pi - ci : tx_ring->bd_count - ci + pi;
 }
@@ -977,14 +975,14 @@ static void enetc_setup_cbdr(struct enetc_hw *hw, struct enetc_cbdr *cbdr)
 	enetc_wr(hw, ENETC_SICBDRBAR1, upper_32_bits(cbdr->bd_dma_base));
 	enetc_wr(hw, ENETC_SICBDRLENR, ENETC_RTBLENR_LEN(cbdr->bd_count));
 
+	enetc_wr(hw, ENETC_SICBDRPIR, 0);
 	enetc_wr(hw, ENETC_SICBDRCIR, 0);
-	enetc_wr(hw, ENETC_SICBDRCISR, 0);
 
 	/* enable ring */
 	enetc_wr(hw, ENETC_SICBDRMR, BIT(31));
 
+	cbdr->pir = hw->reg + ENETC_SICBDRPIR;
 	cbdr->cir = hw->reg + ENETC_SICBDRCIR;
-	cbdr->cisr = hw->reg + ENETC_SICBDRCISR;
 }
 
 static void enetc_clear_cbdr(struct enetc_hw *hw)
@@ -1105,8 +1103,8 @@ static void enetc_setup_txbdr(struct enetc_hw *hw, struct enetc_bdr *tx_ring)
 	enetc_txbdr_wr(hw, idx, ENETC_TBLENR,
 		       ENETC_RTBLENR_LEN(tx_ring->bd_count));
 
+	enetc_txbdr_wr(hw, idx, ENETC_TBPIR, 0);
 	enetc_txbdr_wr(hw, idx, ENETC_TBCIR, 0);
-	enetc_txbdr_wr(hw, idx, ENETC_TBCISR, 0);
 
 	/* enable Tx ints by setting pkt thr to 1 */
 	enetc_txbdr_wr(hw, idx, ENETC_TBICIR0, ENETC_TBICIR0_ICEN | 0x1);
@@ -1123,8 +1121,8 @@ static void enetc_setup_txbdr(struct enetc_hw *hw, struct enetc_bdr *tx_ring)
 	/* enable ring */
 	enetc_txbdr_wr(hw, idx, ENETC_TBMR, tbmr);
 
+	tx_ring->tpir = hw->reg + ENETC_BDR(TX, idx, ENETC_TBPIR);
 	tx_ring->tcir = hw->reg + ENETC_BDR(TX, idx, ENETC_TBCIR);
-	tx_ring->tcisr = hw->reg + ENETC_BDR(TX, idx, ENETC_TBCISR);
 	tx_ring->idr = hw->reg + ENETC_SITXIDR;
 }
 
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index 46f1e73a6420..0c0a0f9a717a 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -48,7 +48,7 @@ struct enetc_bdr {
 	struct net_device *ndev;
 	void *bd_base; /* points to Rx or Tx BD ring */
 	union {
-		void __iomem *tcir;
+		void __iomem *tpir;
 		void __iomem *rcir;
 	};
 	u16 index;
@@ -60,7 +60,7 @@ struct enetc_bdr {
 		struct enetc_rx_swbd *rx_swbd;
 	};
 	union {
-		void __iomem *tcisr; /* Tx */
+		void __iomem *tcir; /* Tx */
 		int next_to_alloc; /* Rx */
 	};
 	void __iomem *idr; /* Interrupt Detect Register pointer */
@@ -87,8 +87,8 @@ static inline int enetc_bd_unused(struct enetc_bdr *bdr)
 /* Control BD ring */
 struct enetc_cbdr {
 	void *bd_base; /* points to Rx or Tx BD ring */
+	void __iomem *pir;
 	void __iomem *cir;
-	void __iomem *cisr;
 
 	int bd_count; /* # of BDs */
 	int next_to_use;
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
index c9b69ab807b1..df9ea297fa4a 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
@@ -11,7 +11,7 @@ static void enetc_clean_cbdr(struct enetc_si *si)
 
 	i = ring->next_to_clean;
 
-	while (enetc_rd_reg(ring->cisr) != i) {
+	while (enetc_rd_reg(ring->cir) != i) {
 		dest_cbd = ENETC_CBD(*ring, i);
 		status = dest_cbd->status_flags & ENETC_CBD_STATUS_MASK;
 		if (status)
@@ -54,10 +54,10 @@ static int enetc_send_cmd(struct enetc_si *si, struct enetc_cbd *cbd)
 
 	ring->next_to_use = i;
 	/* let H/W know BD ring has been updated */
-	enetc_wr_reg(ring->cir, i);
+	enetc_wr_reg(ring->pir, i);
 
 	do {
-		if (enetc_rd_reg(ring->cisr) == i)
+		if (enetc_rd_reg(ring->cir) == i)
 			break;
 		udelay(10); /* cannot sleep, rtnl_lock() */
 		timeout -= 10;
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c b/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
index f5a9a2520b6f..b6c8a9d8ce78 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
@@ -7,14 +7,14 @@
 
 static const u32 enetc_si_regs[] = {
 	ENETC_SIMR, ENETC_SIPMAR0, ENETC_SIPMAR1, ENETC_SICBDRMR,
-	ENETC_SICBDRSR,	ENETC_SICBDRBAR0, ENETC_SICBDRBAR1, ENETC_SICBDRCIR,
-	ENETC_SICBDRCISR, ENETC_SICBDRLENR, ENETC_SICAPR0, ENETC_SICAPR1,
+	ENETC_SICBDRSR,	ENETC_SICBDRBAR0, ENETC_SICBDRBAR1, ENETC_SICBDRPIR,
+	ENETC_SICBDRCIR, ENETC_SICBDRLENR, ENETC_SICAPR0, ENETC_SICAPR1,
 	ENETC_SIUEFDCR
 };
 
 static const u32 enetc_txbdr_regs[] = {
 	ENETC_TBMR, ENETC_TBSR, ENETC_TBBAR0, ENETC_TBBAR1,
-	ENETC_TBCIR, ENETC_TBCISR, ENETC_TBLENR, ENETC_TBIER
+	ENETC_TBPIR, ENETC_TBCIR, ENETC_TBLENR, ENETC_TBIER
 };
 
 static const u32 enetc_rxbdr_regs[] = {
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
index 275c6f95fa20..ed817ee58dfb 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
@@ -10,25 +10,21 @@
 /* ENETC register block BAR */
 #define ENETC_BAR_REGS	0
 
-/* SI regs, offset: 0h */
+/** SI regs, offset: 0h */
 #define ENETC_SIMR	0
 #define ENETC_SIMR_EN	BIT(31)
 #define ENETC_SIMR_RSSE	BIT(0)
-
-#define ENETC_SICTRL	0x18
-#define ENETC_SICTRH	0x1c
+#define ENETC_SICTR0	0x18
+#define ENETC_SICTR1	0x1c
 #define ENETC_SIPCAPR0	0x20
 #define ENETC_SIPCAPR0_RSS	BIT(8)
 #define ENETC_SIPCAPR1	0x24
 #define ENETC_SITGTGR	0x30
-
 #define ENETC_SIRBGCR	0x38
-
-/* Cache attribute registers for transactions initiated by ENETC */
+/* cache attribute registers for transactions initiated by ENETC */
 #define ENETC_SICAR0	0x40
 #define ENETC_SICAR1	0x44
 #define ENETC_SICAR2	0x48
-
 /*
  * rd snoop, no alloc
  * wr snoop, no alloc, partial cache line update for BDs and full cache line
@@ -38,26 +34,23 @@
 #define ENETC_SICAR_WR_COHERENT	0x00006727
 #define ENETC_SICAR_MSI	0x00300030 /* rd/wr device, no snoop, no alloc */
 
-#define ENETC_SICTR0	0x18
-#define ENETC_SICTR1	0x1c
-
 #define ENETC_SIPMAR0	0x80
 #define ENETC_SIPMAR1	0x84
 
 /* VF-PF Message passing */
-#define ENETC_DEFAULT_MSG_SIZE	1024
+#define ENETC_DEFAULT_MSG_SIZE	1024	/* and max size */
+/* msg size encoding: default and max msg value of 1024B encoded as 0 */
 static inline u32 enetc_vsi_set_msize(u32 size)
 {
 	return size < ENETC_DEFAULT_MSG_SIZE ? size >> 5 : 0;
 }
-
 #define ENETC_PSIMSGRR	0x204
 #define ENETC_PSIMSGRR_MR_MASK	GENMASK(2, 1)
 #define ENETC_PSIMSGRR_MR(n) BIT((n) + 1) /* n = VSI index */
 #define ENETC_PSIVMSGRCVAR0(n)	(0x210 + (n) * 0x8) /* n = VSI index */
 #define ENETC_PSIVMSGRCVAR1(n)	(0x214 + (n) * 0x8)
 
-#define ENETC_VSIMSGSR	0x204
+#define ENETC_VSIMSGSR	0x204	/* RO */
 #define ENETC_VSIMSGSR_MB	BIT(0)
 #define ENETC_VSIMSGSR_MS	BIT(1)
 #define ENETC_VSIMSGSNDAR0	0x210
@@ -82,8 +75,8 @@ static inline u32 enetc_vsi_set_msize(u32 size)
 #define ENETC_SICBDRSR		0x804	/* RO */
 #define ENETC_SICBDRBAR0	0x810
 #define ENETC_SICBDRBAR1	0x814
-#define ENETC_SICBDRCIR		0x818
-#define ENETC_SICBDRCISR	0x81c
+#define ENETC_SICBDRPIR		0x818
+#define ENETC_SICBDRCIR		0x81c
 #define ENETC_SICBDRLENR	0x820
 
 #define ENETC_SICAPR0	0x900
@@ -108,12 +101,11 @@ static inline u32 enetc_vsi_set_msize(u32 size)
 enum enetc_bdr_type {TX, RX};
 #define ENETC_BDR_OFF(i)	((i) * 0x200)
 #define ENETC_BDR(t, i, r)	(0x8000 + (t) * 0x100 + ENETC_BDR_OFF(i) + (r))
-/*** RX BDR reg offsets */
+/* RX BDR reg offsets */
 #define ENETC_RBMR	0
 #define ENETC_RBMR_BDS	BIT(2)
 #define ENETC_RBMR_VTE	BIT(5)
 #define ENETC_RBMR_EN	BIT(31)
-
 #define ENETC_RBSR	0x4
 #define ENETC_RBBSR	0x8
 #define ENETC_RBCIR	0xc
@@ -127,20 +119,20 @@ enum enetc_bdr_type {TX, RX};
 #define ENETC_RBICIR0	0xa8
 #define ENETC_RBICIR0_ICEN	BIT(31)
 
-/*** TX BDR reg offsets */
+/* TX BDR reg offsets */
 #define ENETC_TBMR	0
 #define ENETC_TBSR_BUSY	BIT(0)
 #define ENETC_TBMR_VIH	BIT(9)
 #define ENETC_TBMR_PRIO_MASK		GENMASK(2, 0)
 #define ENETC_TBMR_PRIO_SET(val)	val
-
+#define ENETC_TBMR_EN	BIT(31)
 #define ENETC_TBSR	0x4
 #define ENETC_TBBAR0	0x10
 #define ENETC_TBBAR1	0x14
-#define ENETC_TBCIR	0x18
-#define ENETC_TBCISR	0x1c
+#define ENETC_TBPIR	0x18
+#define ENETC_TBCIR	0x1c
+#define ENETC_TBCIR_IDX_MASK	0xffff
 #define ENETC_TBLENR	0x20
-#define ENETC_TBCISR_IDX_MASK	0xffff
 #define ENETC_TBIER	0xa0
 #define ENETC_TBIER_TXTIE	BIT(0)
 #define ENETC_TBIDR	0xa4
@@ -148,39 +140,34 @@ enum enetc_bdr_type {TX, RX};
 #define ENETC_TBICIR0_ICEN	BIT(31)
 
 #define ENETC_RTBLENR_LEN(n)	((n) & ~0x7)
-#define ENETC_TBMR_EN	BIT(31)
 
 /* Port regs, offset: 1_0000h */
-#define ENETC_PORT_BASE	0x10000
-#define ENETC_PMR	0x00000
+#define ENETC_PORT_BASE		0x10000
+#define ENETC_PMR		0x0000
 #define ENETC_PMR_EN	GENMASK(18, 16)
-#define ENETC_PSR	0x00004 /* RO */
-#define ENETC_PSIPMR	0x00018
+#define ENETC_PSR		0x0004 /* RO */
+#define ENETC_PSIPMR		0x0018
 #define ENETC_PSIPMR_SET_UP(n)	BIT(n) /* n = SI index */
 #define ENETC_PSIPMR_SET_MP(n)	BIT((n) + 16)
-#define ENETC_PSIPVMR	0x0001c
+#define ENETC_PSIPVMR		0x001c
 #define ENETC_VLAN_PROMISC_MAP_ALL	0x7
 #define ENETC_PSIPVMR_SET_VP(simap)	((simap) & 0x7)
 #define ENETC_PSIPVMR_SET_VUTA(simap)	(((simap) & 0x7) << 16)
-#define ENETC_PSIPMAR0(n)	(0x00100 + (n) * 0x8) /* n = SI index */
-#define ENETC_PSIPMAR1(n)	(0x00104 + (n) * 0x8)
+#define ENETC_PSIPMAR0(n)	(0x0100 + (n) * 0x8) /* n = SI index */
+#define ENETC_PSIPMAR1(n)	(0x0104 + (n) * 0x8)
 #define ENETC_PVCLCTR		0x0208
 #define ENETC_VLAN_TYPE_C	BIT(0)
 #define ENETC_VLAN_TYPE_S	BIT(1)
 #define ENETC_PVCLCTR_OVTPIDL(bmp)	((bmp) & 0xff) /* VLAN_TYPE */
-
-#define ENETC_PSIVLANR(n)	(0x00240 + (n) * 4) /* n = SI index */
+#define ENETC_PSIVLANR(n)	(0x0240 + (n) * 4) /* n = SI index */
 #define ENETC_PSIVLAN_EN	BIT(31)
 #define ENETC_PSIVLAN_SET_QOS(val)	((u32)(val) << 12)
-
-#define ENETC_PTXMBAR	0x00608
-
-#define ENETC_PCAPR0	0x00900
+#define ENETC_PTXMBAR		0x0608
+#define ENETC_PCAPR0		0x0900
 #define ENETC_PCAPR0_RXBDR(val)	((val) >> 24)
 #define ENETC_PCAPR0_TXBDR(val)	(((val) >> 16) & 0xff)
-#define ENETC_PCAPR1	0x00904
-
-#define ENETC_PSICFGR0(n)	(0x00940 + (n) * 0xc)  /* n = SI index */
+#define ENETC_PCAPR1		0x0904
+#define ENETC_PSICFGR0(n)	(0x0940 + (n) * 0xc)  /* n = SI index */
 #define ENETC_PSICFGR0_SET_TXBDR(val)	((val) & 0xff)
 #define ENETC_PSICFGR0_SET_RXBDR(val)	(((val) & 0xff) << 16)
 #define ENETC_PSICFGR0_SPE	BIT(11)
@@ -189,53 +176,45 @@ enum enetc_bdr_type {TX, RX};
 #define ENETC_PSICFGR0_ASE	BIT(15)
 #define ENETC_PSICFGR0_SIVC(bmp)	(((bmp) & 0xff) << 24) /* VLAN_TYPE */
 
+#define ENETC_PTCCBSR0(n)	(0x1110 + (n) * 8) /* n = 0 to 7*/
+#define ENETC_PTCCBSR1(n)	(0x1114 + (n) * 8) /* n = 0 to 7*/
 #define ENETC_RSSHASH_KEY_SIZE	40
-#define ENETC_PRSSK(n)		(0x01410 + (n) * 4) /* n = [0..9] */
-
-#define ENETC_PSIVLANFMR	0x01700
+#define ENETC_PRSSK(n)		(0x1410 + (n) * 4) /* n = [0..9] */
+#define ENETC_PSIVLANFMR	0x1700
 #define ENETC_PSIVLANFMR_VS	BIT(0)
-
-#define ENETC_PRFSMR		0x01800
+#define ENETC_PRFSMR		0x1800
 #define ENETC_PRFSMR_RFSE	BIT(31)
-#define ENETC_PFPMR			0x01900
+#define ENETC_PRFSCAPR		0x1804
+#define ENETC_PSIRFSCFGR(n)	(0x1814 + (n) * 4) /* n = SI index */
+#define ENETC_PFPMR		0x1900
 #define ENETC_PFPMR_PMACE	BIT(1)
 #define ENETC_PFPMR_MWLM	BIT(0)
-#define ENETC_MMCSR		0x1F00
+#define ENETC_PSIUMHFR0(n, err)	(((err) ? 0x1d08 : 0x1d00) + (n) * 0x10)
+#define ENETC_PSIUMHFR1(n)	(0x1d04 + (n) * 0x10)
+#define ENETC_PSIMMHFR0(n, err)	(((err) ? 0x1d00 : 0x1d08) + (n) * 0x10)
+#define ENETC_PSIMMHFR1(n)	(0x1d0c + (n) * 0x10)
+#define ENETC_PSIVHFR0(n)	(0x1e00 + (n) * 8) /* n = SI index */
+#define ENETC_PSIVHFR1(n)	(0x1e04 + (n) * 8) /* n = SI index */
+#define ENETC_MMCSR		0x1f00
 #define ENETC_MMCSR_ME		BIT(16)
+#define ENETC_PTCMSDUR(n)	(0x2020 + (n) * 4) /* n = TC index [0..7] */
 
-#define ENETC_PRFSCAPR		0x01804
-#define ENETC_PSIRFSCFGR(n)	(0x01814 + (n) * 4) /* n = SI index */
-
-#define ENETC_PTCMSDUR(n)	(0x02020 + (n) * 4) /* n = TC index [0..7] */
-
-#define ENETC_PM0_CMD_CFG	0x08008
+#define ENETC_PM0_CMD_CFG	0x8008
+#define ENETC_PM1_CMD_CFG	0x9008
 #define ENETC_PM0_TX_EN		BIT(0)
 #define ENETC_PM0_RX_EN		BIT(1)
 #define ENETC_PM0_PROMISC	BIT(4)
 #define ENETC_PM0_CMD_XGLP	BIT(10)
 #define ENETC_PM0_CMD_TXP	BIT(11)
 #define ENETC_PM0_CMD_PHY_TX_EN	BIT(15)
-#define ENETC_PM0_CMD_SFD   BIT(21)
-#define ENETC_PM1_CMD_CFG	0x09008
-
-#define ENETC_PM0_MAXFRM	0x08014
+#define ENETC_PM0_CMD_SFD	BIT(21)
+#define ENETC_PM0_MAXFRM	0x8014
 #define ENETC_SET_TX_MTU(val)	((val) << 16)
 #define ENETC_SET_MAXFRM(val)	((val) & 0xffff)
-
-#define ENETC_PM0_IF_MODE	0x08300
+#define ENETC_PM0_IF_MODE	0x8300
 #define ENETC_PMO_IFM_RG	BIT(2)
 #define ENETC_PM0_IFM_RLP	(BIT(5) | BIT(11))
 
-#define ENETC_PSIUMHFR0(n, err)	(((err) ? 0x01d08 : 0x01d00) + (n) * 0x10)
-#define ENETC_PSIUMHFR1(n)	(0x01d04 + (n) * 0x10)
-#define ENETC_PSIMMHFR0(n, err)	(((err) ? 0x01d00 : 0x01d08) + (n) * 0x10)
-#define ENETC_PSIMMHFR1(n)	(0x01d0c + (n) * 0x10)
-
-#define ENETC_PSIVHFR0(n)	(0x01e00 + (n) * 8) /* n = SI index */
-#define ENETC_PSIVHFR1(n)	(0x01e04 + (n) * 8) /* n = SI index */
-#define ENETC_PTCCBSR0(n)   (0x1110 + (n) * 8) /* n = 0 to 7*/
-#define ENETC_PTCCBSR1(n)   (0x1114 + (n) * 8) /* n = 0 to 7*/
-
 /* MAC counters */
 #define ENETC_PM0_REOCT		0x8100
 #define ENETC_PM0_RALN		0x8110
@@ -295,10 +274,10 @@ enum enetc_bdr_type {TX, RX};
 #define ENETC_PMFDVFR		0x1784
 #define ENETC_PBFDVFR		0x1788
 
-/* Global regs, offset: 2_0000h */
-#define ENETC_GLOBAL_BASE		0x20000
-#define ENETC_G_EIPBRR0		0x00bf8
-#define ENETC_G_EIPBRR1		0x00bfc
+/** Global regs, offset: 2_0000h */
+#define ENETC_GLOBAL_BASE	0x20000
+#define ENETC_G_EIPBRR0		0x0bf8
+#define ENETC_G_EIPBRR1		0x0bfc
 
 /* PCI device info */
 struct enetc_hw {
@@ -313,18 +292,19 @@ struct enetc_hw {
 /* general register accessors */
 #define enetc_rd_reg(reg)	ioread32((reg))
 #define enetc_wr_reg(reg, val)	iowrite32((val), (reg))
-#define enetc_rd(hw, off)	enetc_rd_reg((hw)->reg + (off))
-#define enetc_wr(hw, off, val)	enetc_wr_reg((hw)->reg + (off), val)
 #ifdef ioread64
-#define enetc_rd_reg64(reg)		ioread64((reg))
+#define enetc_rd_reg64(reg)	ioread64((reg))
 #else
 /* using this to read out stats on 32b systems */
 static inline u64 enetc_rd_reg64(void __iomem *reg)
 {
-	return __le64_to_cpu(*(u64*)reg);
+	return __le64_to_cpu(*(u64 *)reg);
 }
 #endif
-#define enetc_wr_reg64(reg)		iowrite64((val), (reg))
+#define enetc_wr_reg64(reg)	iowrite64((val), (reg))
+
+#define enetc_rd(hw, off)		enetc_rd_reg((hw)->reg + (off))
+#define enetc_wr(hw, off, val)		enetc_wr_reg((hw)->reg + (off), val)
 #define enetc_rd64(hw, off)		enetc_rd_reg64((hw)->reg + (off))
 #define enetc_wr64(hw, off, val)	enetc_wr_reg64((hw)->reg + (off), val)
 /* port register accessors - PF only */
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
index 59ed61ba695d..2ff809235089 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
@@ -352,13 +352,16 @@ static void enetc_set_loopback(struct net_device *ndev, bool en)
 	reg = enetc_port_rd(hw, ENETC_PM0_IF_MODE);
 	if (reg & ENETC_PMO_IFM_RG) {
 		/* RGMII mode */
-		reg = en ? reg | ENETC_PM0_IFM_RLP : reg & ~ENETC_PM0_IFM_RLP;
+		reg = (reg & ~ENETC_PM0_IFM_RLP) |
+		      (en ? ENETC_PM0_IFM_RLP : 0);
 		enetc_port_wr(hw, ENETC_PM0_IF_MODE, reg);
 	} else {
 		/* assume SGMII mode */
 		reg = enetc_port_rd(hw, ENETC_PM0_CMD_CFG);
-		reg = en ? reg | ENETC_PM0_CMD_XGLP : reg & ~ENETC_PM0_CMD_XGLP;
-		reg = en ? reg & ~ENETC_PM0_CMD_PHY_TX_EN : reg | ENETC_PM0_CMD_PHY_TX_EN;
+		reg = (reg & ~ENETC_PM0_CMD_XGLP) |
+		      (en ? ENETC_PM0_CMD_XGLP : 0);
+		reg = (reg & ~ENETC_PM0_CMD_PHY_TX_EN) |
+		      (en ? ENETC_PM0_CMD_PHY_TX_EN : 0);
 		enetc_port_wr(hw, ENETC_PM0_CMD_CFG, reg);
 		enetc_port_wr(hw, ENETC_PM1_CMD_CFG, reg);
 	}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
index f8308b4fcbdf..ba70d160ae11 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
@@ -53,7 +53,7 @@ static int alloc_cbdr(struct enetc_si *si, struct enetc_cbd **curr_cbd)
 	return i;
 }
 
-/* Transmit the BD control ring by writing the ccir register.
+/* Transmit the BD control ring by writing the pir register.
  * Update the counters maintained by software.
  */
 static int xmit_cbdr(struct enetc_si *si, int i)
@@ -66,12 +66,12 @@ static int xmit_cbdr(struct enetc_si *si, int i)
 
 	ring->next_to_use = i;
 	/* let H/W know BD ring has been updated */
-	enetc_wr_reg(ring->cir, i);
+	enetc_wr_reg(ring->pir, i);
 
 	timeout = ENETC_CBDR_TIMEOUT;
 
 	do {
-		if (enetc_rd_reg(ring->cisr) == i)
+		if (enetc_rd_reg(ring->cir) == i)
 			break;
 		udelay(10);
 		timeout -= 10;
@@ -84,7 +84,7 @@ static int xmit_cbdr(struct enetc_si *si, int i)
 #endif
 	nc = ring->next_to_clean;
 
-	while (enetc_rd_reg(ring->cisr) != nc) {
+	while (enetc_rd_reg(ring->cir) != nc) {
 		dest_cbd = ENETC_CBD(*ring, nc);
 		if (dest_cbd->status_flags & ENETC_CBD_STATUS_MASK)
 			WARN_ON(1);
@@ -223,8 +223,8 @@ int enetc_qbv_set(struct net_device *ndev, struct tsn_qbv_conf *admin_conf)
 	gcl_config->acl_len = cpu_to_le16(gcl_len);
 
 	if (!admin_basic->base_time) {
-		gcl_data->btl = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTRL));
-		gcl_data->bth = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTRH));
+		gcl_data->btl = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR0));
+		gcl_data->bth = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR1));
 	} else {
 		gcl_data->btl = cpu_to_le32(lower_32_bits(admin_basic->base_time));
 		gcl_data->bth = cpu_to_le32(upper_32_bits(admin_basic->base_time));
@@ -470,8 +470,8 @@ int enetc_qbv_get_status(struct net_device *ndev,
 	status->tick_granularity = enetc_rd(&priv->si->hw, ENETC_SITGTGR);
 
 	/* current time */
-	temp = ((u64)enetc_rd(&priv->si->hw, ENETC_SICTRH)) << 32;
-	status->current_time = enetc_rd(&priv->si->hw, ENETC_SICTRL) + temp;
+	temp = ((u64)enetc_rd(&priv->si->hw, ENETC_SICTR1)) << 32;
+	status->current_time = enetc_rd(&priv->si->hw, ENETC_SICTR0) + temp;
 
 	status->supported_list_max = maxlen;
 
@@ -1097,8 +1097,8 @@ int enetc_qci_sgi_set(struct net_device *ndev, u32 index,
 	}
 
 	if (!tsn_qci_sgi->admin.base_time) {
-		sgcl_data->btl = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTRL));
-		sgcl_data->bth = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTRH));
+		sgcl_data->btl = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR0));
+		sgcl_data->bth = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR1));
 	} else {
 		sgcl_data->bth = cpu_to_le32(upper_32_bits(tsn_qci_sgi->admin.base_time));
 		sgcl_data->btl = cpu_to_le32(lower_32_bits(tsn_qci_sgi->admin.base_time));
@@ -1403,8 +1403,8 @@ int enetc_qci_sgi_status_get(struct net_device *ndev, u16 index,
 	status->tick_granularity = enetc_rd(&priv->si->hw, ENETC_SITGTGR);
 
 	/* current time */
-	temp = ((u64)enetc_rd(&priv->si->hw, ENETC_SICTRH)) << 32;
-	status->current_time = enetc_rd(&priv->si->hw, ENETC_SICTRL) + temp;
+	temp = ((u64)enetc_rd(&priv->si->hw, ENETC_SICTR1)) << 32;
+	status->current_time = enetc_rd(&priv->si->hw, ENETC_SICTR0) + temp;
 
 	memset(cbdr_sgi, 0, sizeof(*cbdr_sgi));
 
-- 
2.17.1


From 53fac9ba2314adc23229c60a0f1b51d6c1d4ce74 Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@nxp.com>
Date: Mon, 24 Dec 2018 13:37:38 +0800
Subject: [PATCH 442/706] ptp_qoriq: convert to use qoriq_ptp_init()

Moved QorIQ PTP clock initialization into new function
qoriq_ptp_init(). This function could also be reused
by ENETC PTP drvier which is a PCI driver for same 1588
timer IP.

Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
(cherry picked from commit 80a52e0dab87ed4092b97332094bb820bad10a6e)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/ptp/ptp_qoriq.c       | 115 ++++++++++++++++++----------------
 include/linux/fsl/ptp_qoriq.h |   2 +
 2 files changed, 62 insertions(+), 55 deletions(-)

diff --git a/drivers/ptp/ptp_qoriq.c b/drivers/ptp/ptp_qoriq.c
index 2cc2532683d4..cb99db641d87 100644
--- a/drivers/ptp/ptp_qoriq.c
+++ b/drivers/ptp/ptp_qoriq.c
@@ -417,24 +417,17 @@ static int qoriq_ptp_auto_config(struct qoriq_ptp *qoriq_ptp,
 	return 0;
 }
 
-static int qoriq_ptp_probe(struct platform_device *dev)
+int qoriq_ptp_init(struct device *dev, struct qoriq_ptp *qoriq_ptp,
+		   void __iomem *base, const struct ptp_clock_info caps)
 {
-	struct device_node *node = dev->dev.of_node;
-	struct qoriq_ptp *qoriq_ptp;
+	struct device_node *node = dev->of_node;
 	struct qoriq_ptp_registers *regs;
 	struct timespec64 now;
-	int err = -ENOMEM;
-	u32 tmr_ctrl;
 	unsigned long flags;
-	void __iomem *base;
-
-	qoriq_ptp = kzalloc(sizeof(*qoriq_ptp), GFP_KERNEL);
-	if (!qoriq_ptp)
-		goto no_memory;
-
-	err = -EINVAL;
+	u32 tmr_ctrl;
 
-	qoriq_ptp->caps = ptp_qoriq_caps;
+	qoriq_ptp->base = base;
+	qoriq_ptp->caps = caps;
 
 	if (of_property_read_u32(node, "fsl,cksel", &qoriq_ptp->cksel))
 		qoriq_ptp->cksel = DEFAULT_CKSEL;
@@ -454,44 +447,9 @@ static int qoriq_ptp_probe(struct platform_device *dev)
 		pr_warn("device tree node missing required elements, try automatic configuration\n");
 
 		if (qoriq_ptp_auto_config(qoriq_ptp, node))
-			goto no_config;
-	}
-
-	err = -ENODEV;
-
-	qoriq_ptp->irq = platform_get_irq(dev, 0);
-
-	if (qoriq_ptp->irq < 0) {
-		pr_err("irq not in device tree\n");
-		goto no_node;
-	}
-	if (request_irq(qoriq_ptp->irq, ptp_qoriq_isr,
-			IRQF_SHARED, DRIVER, qoriq_ptp)) {
-		pr_err("request_irq failed\n");
-		goto no_node;
-	}
-
-	qoriq_ptp->rsrc = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (!qoriq_ptp->rsrc) {
-		pr_err("no resource\n");
-		goto no_resource;
-	}
-	if (request_resource(&iomem_resource, qoriq_ptp->rsrc)) {
-		pr_err("resource busy\n");
-		goto no_resource;
-	}
-
-	spin_lock_init(&qoriq_ptp->lock);
-
-	base = ioremap(qoriq_ptp->rsrc->start,
-		       resource_size(qoriq_ptp->rsrc));
-	if (!base) {
-		pr_err("ioremap ptp registers failed\n");
-		goto no_ioremap;
+			return -EINVAL;
 	}
 
-	qoriq_ptp->base = base;
-
 	if (of_device_is_compatible(node, "fsl,fman-ptp-timer")) {
 		qoriq_ptp->regs.ctrl_regs = base + FMAN_CTRL_REGS_OFFSET;
 		qoriq_ptp->regs.alarm_regs = base + FMAN_ALARM_REGS_OFFSET;
@@ -511,6 +469,7 @@ static int qoriq_ptp_probe(struct platform_device *dev)
 	  (qoriq_ptp->tclk_period & TCLK_PERIOD_MASK) << TCLK_PERIOD_SHIFT |
 	  (qoriq_ptp->cksel & CKSEL_MASK) << CKSEL_SHIFT;
 
+	spin_lock_init(&qoriq_ptp->lock);
 	spin_lock_irqsave(&qoriq_ptp->lock, flags);
 
 	regs = &qoriq_ptp->regs;
@@ -524,12 +483,59 @@ static int qoriq_ptp_probe(struct platform_device *dev)
 
 	spin_unlock_irqrestore(&qoriq_ptp->lock, flags);
 
-	qoriq_ptp->clock = ptp_clock_register(&qoriq_ptp->caps, &dev->dev);
-	if (IS_ERR(qoriq_ptp->clock)) {
-		err = PTR_ERR(qoriq_ptp->clock);
-		goto no_clock;
-	}
+	qoriq_ptp->clock = ptp_clock_register(&qoriq_ptp->caps, dev);
+	if (IS_ERR(qoriq_ptp->clock))
+		return PTR_ERR(qoriq_ptp->clock);
+
 	qoriq_ptp->phc_index = ptp_clock_index(qoriq_ptp->clock);
+	return 0;
+}
+
+static int qoriq_ptp_probe(struct platform_device *dev)
+{
+	struct device *ptp_dev = &dev->dev;
+	struct qoriq_ptp *qoriq_ptp;
+	void __iomem *base;
+	int err = -ENOMEM;
+
+	qoriq_ptp = kzalloc(sizeof(*qoriq_ptp), GFP_KERNEL);
+	if (!qoriq_ptp)
+		goto no_memory;
+
+	err = -ENODEV;
+
+	qoriq_ptp->irq = platform_get_irq(dev, 0);
+
+	if (qoriq_ptp->irq < 0) {
+		pr_err("irq not in device tree\n");
+		goto no_node;
+	}
+	if (request_irq(qoriq_ptp->irq, ptp_qoriq_isr,
+			IRQF_SHARED, DRIVER, qoriq_ptp)) {
+		pr_err("request_irq failed\n");
+		goto no_node;
+	}
+
+	qoriq_ptp->rsrc = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!qoriq_ptp->rsrc) {
+		pr_err("no resource\n");
+		goto no_resource;
+	}
+	if (request_resource(&iomem_resource, qoriq_ptp->rsrc)) {
+		pr_err("resource busy\n");
+		goto no_resource;
+	}
+
+	base = ioremap(qoriq_ptp->rsrc->start,
+		       resource_size(qoriq_ptp->rsrc));
+	if (!base) {
+		pr_err("ioremap ptp registers failed\n");
+		goto no_ioremap;
+	}
+
+	err = qoriq_ptp_init(ptp_dev, qoriq_ptp, base, ptp_qoriq_caps);
+	if (err)
+		goto no_clock;
 
 	platform_set_drvdata(dev, qoriq_ptp);
 
@@ -541,7 +547,6 @@ static int qoriq_ptp_probe(struct platform_device *dev)
 	release_resource(qoriq_ptp->rsrc);
 no_resource:
 	free_irq(qoriq_ptp->irq, qoriq_ptp);
-no_config:
 no_node:
 	kfree(qoriq_ptp);
 no_memory:
diff --git a/include/linux/fsl/ptp_qoriq.h b/include/linux/fsl/ptp_qoriq.h
index d0835ecff626..f933a39ebc0e 100644
--- a/include/linux/fsl/ptp_qoriq.h
+++ b/include/linux/fsl/ptp_qoriq.h
@@ -173,5 +173,7 @@ int ptp_qoriq_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts);
 int ptp_qoriq_settime(struct ptp_clock_info *ptp, const struct timespec64 *ts);
 int ptp_qoriq_enable(struct ptp_clock_info *ptp,
 		     struct ptp_clock_request *rq, int on);
+int qoriq_ptp_init(struct device *dev, struct qoriq_ptp *qoriq_ptp,
+		   void __iomem *base, const struct ptp_clock_info caps);
 
 #endif
-- 
2.17.1


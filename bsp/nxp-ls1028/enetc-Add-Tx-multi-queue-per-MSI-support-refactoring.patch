From ec3f24b6c31c0fa1775b671cde8a0fbdf7c9d445 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@nxp.com>
Date: Thu, 19 Jul 2018 15:27:03 +0300
Subject: [PATCH 176/706] enetc: Add Tx multi queue per MSI support,
 refactoring

Reduce number of MSIX lines to one per cpu while still
supporting multiple (up to 8) Tx queues, i.e. for mqprio
tc offload.

Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
(cherry picked from commit fc32ea016b688ea944b34f1985477ab2436edebd)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/enetc.c  | 157 +++++++++++++-----
 drivers/net/ethernet/freescale/enetc/enetc.h  |  13 +-
 .../net/ethernet/freescale/enetc/enetc_hw.h   |  17 +-
 .../net/ethernet/freescale/enetc/enetc_msg.c  |   4 +-
 .../net/ethernet/freescale/enetc/enetc_pf.c   |  24 +--
 .../net/ethernet/freescale/enetc/enetc_vf.c   |  23 +--
 6 files changed, 131 insertions(+), 107 deletions(-)

diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
index 9934e9bcb4ee..86b948bda015 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc.c
@@ -74,11 +74,14 @@ static void enetc_dbg_print_skb(struct sk_buff *skb, int type)
 static irqreturn_t enetc_msix(int irq, void *data)
 {
 	struct enetc_int_vector	*v = data;
+	int i;
 
 	/* disable interrupts */
-	enetc_wr_reg(v->tbier, 0);
 	enetc_wr_reg(v->rbier, 0);
 
+	for_each_set_bit(i, &v->tx_rings_map, v->count_tx_rings)
+		enetc_wr_reg(v->tbier_base + ENETC_BDR_OFF(i), 0);
+
 	napi_schedule_irqoff(&v->napi);
 
 	return IRQ_HANDLED;
@@ -295,8 +298,11 @@ static int enetc_poll(struct napi_struct *napi, int budget)
 		*v = container_of(napi, struct enetc_int_vector, napi);
 	bool complete = true;
 	int work_done;
+	int i;
 
-	enetc_clean_tx_ring(&v->tx_ring);
+	// TODO: Add Tx ring budget (cleanup limit)
+	for (i = 0; i < v->count_tx_rings; i++)
+		enetc_clean_tx_ring(&v->tx_ring[i]);
 
 	work_done = enetc_clean_rx_ring(&v->rx_ring, napi, budget);
 	if (work_done == budget)
@@ -308,9 +314,12 @@ static int enetc_poll(struct napi_struct *napi, int budget)
 	napi_complete_done(napi, work_done);
 
 	/* enable interrupts */
-	enetc_wr_reg(v->tbier, ENETC_TBIER_TXTIE);
 	enetc_wr_reg(v->rbier, ENETC_RBIER_RXTIE);
 
+	for_each_set_bit(i, &v->tx_rings_map, v->count_tx_rings)
+		enetc_wr_reg(v->tbier_base + ENETC_BDR_OFF(i),
+			     ENETC_TBIER_TXTIE);
+
 	return work_done;
 }
 
@@ -949,6 +958,26 @@ static void enetc_configure_si(struct enetc_ndev_priv *priv)
 
 }
 
+void enetc_init_si_rings_params(struct enetc_ndev_priv *priv)
+{
+	struct enetc_si *si = priv->si;
+	int cpus = num_online_cpus();
+
+	priv->tx_bd_count = 1024; //TODO: use defines for defaults
+	priv->rx_bd_count = 1024;
+
+	/* Enable all available TX rings in order to configure as many
+	 * priorities as possible, when needed.
+	 * TODO: Make # of TX rings run-time configurable
+	 */
+	priv->num_rx_rings = min_t(int, cpus, si->num_rx_rings);
+	priv->num_tx_rings = si->num_tx_rings;
+	priv->bdr_int_num = cpus;
+
+	/* SI specific */
+	si->cbd_ring.bd_count = 64; //TODO: use defines for defaults
+}
+
 int enetc_alloc_si_resources(struct enetc_ndev_priv *priv)
 {
 	struct enetc_si *si = priv->si;
@@ -1075,11 +1104,12 @@ static void enetc_setup_bdrs(struct enetc_ndev_priv *priv)
 int enetc_setup_irqs(struct enetc_ndev_priv *priv)
 {
 	struct pci_dev *pdev = priv->si->pdev;
-	int i, err;
+	int i, j, err;
 
 	for (i = 0; i < priv->bdr_int_num; i++) {
 		int irq = pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i);
-		struct enetc_int_vector *v = &priv->int_vector[i];
+		struct enetc_int_vector *v = priv->int_vector[i];
+		int entry = ENETC_BDR_INT_BASE_IDX + i;
 		struct enetc_hw *hw = &priv->si->hw;
 
 		sprintf(v->name, "%s-rxtx%d", priv->ndev->name, i);
@@ -1089,18 +1119,24 @@ int enetc_setup_irqs(struct enetc_ndev_priv *priv)
 			goto irq_err;
 		}
 
-		v->tbier = hw->reg + ENETC_BDR(TX, i, ENETC_TBIER);
+		v->tbier_base = hw->reg + ENETC_BDR(TX, 0, ENETC_TBIER);
 		v->rbier = hw->reg + ENETC_BDR(RX, i, ENETC_RBIER);
 
-		enetc_configure_hw_vector(hw, ENETC_BDR_INT_BASE_IDX + i);
+		enetc_wr(hw, ENETC_SIMSIRRV(i), entry);
+
+		for (j = 0; j < v->count_tx_rings; j++) {
+			int idx = v->tx_ring[j].index;
+
+			enetc_wr(hw, ENETC_SIMSITRV(idx), entry);
+		}
 	}
 
 	return 0;
 
 irq_err:
-	while (i-- > 0)
+	while (i--)
 		free_irq(pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i),
-			 &priv->int_vector[i]);
+			 priv->int_vector[i]);
 
 	return err;
 }
@@ -1112,7 +1148,7 @@ void enetc_free_irqs(struct enetc_ndev_priv *priv)
 
 	for (i = 0; i < priv->bdr_int_num; i++)
 		free_irq(pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i),
-			 &priv->int_vector[i]);
+			 priv->int_vector[i]);
 }
 
 static void enetc_enable_interrupts(struct enetc_ndev_priv *priv)
@@ -1120,12 +1156,15 @@ static void enetc_enable_interrupts(struct enetc_ndev_priv *priv)
 	int i;
 
 	/* enable Tx & Rx event indication */
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		enetc_txbdr_wr(&priv->si->hw, i,
-			       ENETC_TBIER, ENETC_TBIER_TXTIE);
+	for (i = 0; i < priv->num_rx_rings; i++) {
 		enetc_rxbdr_wr(&priv->si->hw, i,
 			       ENETC_RBIER, ENETC_RBIER_RXTIE);
 	}
+
+	for (i = 0; i < priv->num_tx_rings; i++) {
+		enetc_txbdr_wr(&priv->si->hw, i,
+			       ENETC_TBIER, ENETC_TBIER_TXTIE);
+	}
 }
 
 static void enetc_disable_interrupts(struct enetc_ndev_priv *priv)
@@ -1136,11 +1175,14 @@ static void enetc_disable_interrupts(struct enetc_ndev_priv *priv)
 	for (i = 0; i < priv->bdr_int_num; i++) {
 		int irq = pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i);
 
-		enetc_txbdr_wr(&priv->si->hw, i, ENETC_TBIER, 0);
-		enetc_rxbdr_wr(&priv->si->hw, i, ENETC_RBIER, 0);
-
 		synchronize_irq(irq);
 	}
+
+	for (i = 0; i < priv->num_tx_rings; i++)
+		enetc_txbdr_wr(&priv->si->hw, i, ENETC_TBIER, 0);
+
+	for (i = 0; i < priv->num_rx_rings; i++)
+		enetc_rxbdr_wr(&priv->si->hw, i, ENETC_RBIER, 0);
 }
 
 int enetc_open(struct net_device *ndev)
@@ -1169,7 +1211,7 @@ int enetc_open(struct net_device *ndev)
 		goto err_set_queues;
 
 	for (i = 0; i < priv->bdr_int_num; i++)
-		napi_enable(&priv->int_vector[i].napi);
+		napi_enable(&priv->int_vector[i]->napi);
 
 	enetc_enable_interrupts(priv);
 
@@ -1197,8 +1239,8 @@ int enetc_close(struct net_device *ndev)
 	enetc_disable_interrupts(priv);
 
 	for (i = 0; i < priv->bdr_int_num; i++) {
-		napi_synchronize(&priv->int_vector[i].napi);
-		napi_disable(&priv->int_vector[i].napi);
+		napi_synchronize(&priv->int_vector[i]->napi);
+		napi_disable(&priv->int_vector[i]->napi);
 	}
 
 	enetc_free_rxtx_rings(priv);
@@ -1306,11 +1348,9 @@ static int enetc_set_rss(struct net_device *ndev, int en)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	struct enetc_hw *hw = &priv->si->hw;
-	int cpus;
 	u32 reg;
 
-	cpus = min_t(int, num_online_cpus(), priv->si->num_rx_rings);
-	enetc_wr(hw, ENETC_SIRBGCR, cpus);
+	enetc_wr(hw, ENETC_SIRBGCR, priv->num_rx_rings);
 
 	reg = enetc_rd(hw, ENETC_SIMR);
 	reg &= ~ENETC_SIMR_RSSE;
@@ -1334,7 +1374,8 @@ int enetc_set_features(struct net_device *ndev,
 int enetc_alloc_msix(struct enetc_ndev_priv *priv)
 {
 	struct pci_dev *pdev = priv->si->pdev;
-	int i, n, nvec;
+	int size, v_tx_rings;
+	int i, n, err, nvec;
 
 	nvec = ENETC_BDR_INT_BASE_IDX + priv->bdr_int_num;
 	/* allocate MSIX for both messaging and Rx/Tx interrupts */
@@ -1346,25 +1387,44 @@ int enetc_alloc_msix(struct enetc_ndev_priv *priv)
 	if (n != nvec)
 		return -EPERM;
 
-	priv->int_vector = kcalloc(priv->bdr_int_num,
-				   sizeof(struct enetc_int_vector), GFP_KERNEL);
-	if (!priv->int_vector) {
-		pci_free_irq_vectors(pdev);
-		return -ENOMEM;
-	}
+	/* # of tx rings per int vector */
+	v_tx_rings = priv->num_tx_rings / priv->bdr_int_num;
+	size = sizeof(struct enetc_int_vector) +
+	       sizeof(struct enetc_bdr) * v_tx_rings;
 
 	for (i = 0; i < priv->bdr_int_num; i++) {
-		struct enetc_int_vector *v = &priv->int_vector[i];
+		struct enetc_int_vector *v;
 		struct enetc_bdr *bdr;
+		int j;
 
-		netif_napi_add(priv->ndev, &v->napi, enetc_poll, 64);
+		v = kzalloc(size, GFP_KERNEL);
+		if (!v) {
+			err = -ENOMEM;
+			goto fail;
+		}
 
-		bdr = &v->tx_ring;
-		bdr->index = i;
-		bdr->ndev = priv->ndev;
-		bdr->dev = priv->dev;
-		bdr->bd_count = priv->tx_bd_count;
-		priv->tx_ring[i] = bdr;
+		priv->int_vector[i] = v;
+
+		netif_napi_add(priv->ndev, &v->napi, enetc_poll, 64);
+		v->count_tx_rings = v_tx_rings;
+
+		for (j = 0; j < v_tx_rings; j++) {
+			int idx;
+
+			/* default tx ring mapping policy */
+			if (priv->bdr_int_num == ENETC_MAX_BDR_INT)
+				idx = 2 * j + i; /* 2 CPUs */
+			else
+				idx = j + i * v_tx_rings; /* default */
+
+			__set_bit(idx, &v->tx_rings_map);
+			bdr = &v->tx_ring[j];
+			bdr->index = idx;
+			bdr->ndev = priv->ndev;
+			bdr->dev = priv->dev;
+			bdr->bd_count = priv->tx_bd_count;
+			priv->tx_ring[idx] = bdr;
+		}
 
 		bdr = &v->rx_ring;
 		bdr->index = i;
@@ -1375,6 +1435,14 @@ int enetc_alloc_msix(struct enetc_ndev_priv *priv)
 	}
 
 	return 0;
+
+fail:
+	while (i--)
+		kfree(priv->int_vector[i]);
+
+	pci_free_irq_vectors(pdev);
+
+	return err;
 }
 
 void enetc_free_msix(struct enetc_ndev_priv *priv)
@@ -1382,14 +1450,21 @@ void enetc_free_msix(struct enetc_ndev_priv *priv)
 	int i;
 
 	for (i = 0; i < priv->bdr_int_num; i++) {
-		struct enetc_int_vector *v = &priv->int_vector[i];
+		struct enetc_int_vector *v = priv->int_vector[i];
 
-		priv->tx_ring[v->tx_ring.index] = NULL;
-		priv->rx_ring[v->rx_ring.index] = NULL;
 		netif_napi_del(&v->napi);
 	}
 
-	kfree(priv->int_vector);
+	for (i = 0; i < priv->num_rx_rings; i++)
+		priv->rx_ring[i] = NULL;
+
+	for (i = 0; i < priv->num_tx_rings; i++)
+		priv->tx_ring[i] = NULL;
+
+	for (i = 0; i < priv->bdr_int_num; i++) {
+		kfree(priv->int_vector[i]);
+		priv->int_vector[i] = NULL;
+	}
 
 	/* disable all MSIX for this device */
 	pci_free_irq_vectors(priv->si->pdev);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
index 6578020a26c4..0f772683a93d 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc.h
@@ -166,13 +166,15 @@ static inline bool enetc_si_is_pf(struct enetc_si *si)
 #define ENETC_MAX_NUM_TXQS	(ENETC_MAX_TCS * ENETC_TXQ_PER_TC)
 
 struct enetc_int_vector {
-	void __iomem *tbier;
 	void __iomem *rbier;
+	void __iomem *tbier_base;
+	unsigned long tx_rings_map;
+	int count_tx_rings;
 	struct napi_struct napi;
 	char name[IFNAMSIZ + 8];
 
-	struct enetc_bdr tx_ring ____cacheline_aligned_in_smp;
-	struct enetc_bdr rx_ring;
+	struct enetc_bdr rx_ring ____cacheline_aligned_in_smp;
+	struct enetc_bdr tx_ring[0];
 };
 
 struct enetc_cls_rule {
@@ -180,13 +182,15 @@ struct enetc_cls_rule {
 	bool used;
 };
 
+#define ENETC_MAX_BDR_INT	2 /* fixed to max # of available cpus */
+
 struct enetc_ndev_priv {
 	struct net_device *ndev;
 	struct device *dev; /* dma-mapping device */
 	struct enetc_si *si;
 
 	int bdr_int_num; /* number of Rx/Tx ring interrupts */
-	struct enetc_int_vector *int_vector;
+	struct enetc_int_vector *int_vector[ENETC_MAX_BDR_INT];
 	u16 num_rx_rings, num_tx_rings;
 	u16 rx_bd_count, tx_bd_count;
 
@@ -227,6 +231,7 @@ void enetc_free_msix(struct enetc_ndev_priv *priv);
 int enetc_setup_irqs(struct enetc_ndev_priv *priv);
 void enetc_free_irqs(struct enetc_ndev_priv *priv);
 void enetc_get_si_caps(struct enetc_si *si);
+void enetc_init_si_rings_params(struct enetc_ndev_priv *priv);
 int enetc_alloc_si_resources(struct enetc_ndev_priv *priv);
 void enetc_free_si_resources(struct enetc_ndev_priv *priv);
 
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
index 90b11c8a5d5b..44717bbffe53 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
@@ -126,7 +126,8 @@ static inline u32 enetc_vsi_set_msize(u32 size)
 
 /** SI BDR sub-blocks, n = 0..7 */
 enum enetc_bdr_type {TX, RX};
-#define ENETC_BDR(type, n, off)	(0x8000 + (type) * 0x100 + (n) * 0x200 + (off))
+#define ENETC_BDR_OFF(i)	((i) * 0x200)
+#define ENETC_BDR(t, i, r)	(0x8000 + (t) * 0x100 + ENETC_BDR_OFF(i) + (r))
 /*** RX BDR reg offsets */
 #define ENETC_RBMR	0
 #define ENETC_RBMR_VTE	BIT(5)
@@ -492,20 +493,6 @@ static inline void enetc_get_primary_mac_addr(struct enetc_hw *hw, u8 *addr)
 /* base index for Rx/Tx interrupts */
 #define ENETC_BDR_INT_BASE_IDX	1
 
-static inline void enetc_configure_hw_vector(struct enetc_hw *hw, int entry)
-{
-	if (entry >= ENETC_BDR_INT_BASE_IDX) {
-		/* TODO: Only queue pairs supported for now */
-		int idx = entry - ENETC_BDR_INT_BASE_IDX;
-
-		enetc_wr(hw, ENETC_SIMSITRV(idx), entry);
-		enetc_wr(hw, ENETC_SIMSIRRV(idx), entry);
-	} else {
-		/* configure SI interrupt */
-		enetc_wr(hw, ENETC_SIMSIVR, entry);
-	}
-}
-
 /* Messaging */
 
 /* Command completion status */
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_msg.c b/drivers/net/ethernet/freescale/enetc/enetc_msg.c
index fb6f2702f4e3..9ae4312116ad 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_msg.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_msg.c
@@ -194,8 +194,8 @@ int enetc_msg_psi_init(struct enetc_pf *pf)
 		return err;
 	}
 
-	/* set a single IRQ entry for PSI message receive notification */
-	enetc_configure_hw_vector(&si->hw, ENETC_SI_INT_IDX);
+	/* set one IRQ entry for PSI message receive notification (SI int) */
+	enetc_wr(&si->hw, ENETC_SIMSIVR, ENETC_SI_INT_IDX);
 
 	/* initialize PSI mailbox */
 	INIT_WORK(&pf->msg_task, enetc_msg_task);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
index 6b1f3645ead6..8308074d3a93 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
@@ -690,28 +690,6 @@ static void enetc_pf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
 	enetc_get_primary_mac_addr(&si->hw, ndev->dev_addr);
 }
 
-static void enetc_pf_sw_init(struct enetc_ndev_priv *priv)
-{
-	struct enetc_si *si = priv->si;
-
-	priv->tx_bd_count = 1024; //TODO: use defines for defaults
-	priv->rx_bd_count = 1024;
-
-	/* Enable all available TX rings in order to configure as many
-	 * priorities as possible, when needed.
-	 *
-	 * Enable all RX rings as well since the numbers of RX/TX rings are
-	 * assumed equal for now.
-	 */
-	priv->num_rx_rings = si->num_rx_rings;
-	priv->num_tx_rings = si->num_tx_rings;
-	 // TODO: fixed to Rx/TX pair, make configurable
-	priv->bdr_int_num = priv->num_rx_rings;
-
-	/* SI specific */
-	si->cbd_ring.bd_count = 64; //TODO: use defines for defaults
-}
-
 static int enetc_pf_probe(struct pci_dev *pdev,
 			  const struct pci_device_id *ent)
 {
@@ -753,7 +731,7 @@ static int enetc_pf_probe(struct pci_dev *pdev,
 
 	priv = netdev_priv(ndev);
 
-	enetc_pf_sw_init(priv);
+	enetc_init_si_rings_params(priv);
 
 	err = enetc_alloc_si_resources(priv);
 	if (err) {
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_vf.c b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
index b389eca22a08..b0cbd3e39e50 100644
--- a/drivers/net/ethernet/freescale/enetc/enetc_vf.c
+++ b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
@@ -173,27 +173,6 @@ static void enetc_vf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
 	enetc_get_primary_mac_addr(&si->hw, ndev->dev_addr);
 }
 
-static void enetc_vf_sw_init(struct enetc_ndev_priv *priv)
-{
-	struct enetc_si *si = priv->si;
-
-	priv->tx_bd_count = 1024; //TODO: use defines for defaults
-	priv->rx_bd_count = 1024;
-
-	/* Enable all available TX rings in order to configure as many
-	 * priorities as possible, when needed.
-	 *
-	 * Enable all RX rings as well since the numbers of RX/TX rings are
-	 * assumed equal for now.
-	 */
-	priv->num_rx_rings = si->num_rx_rings;
-	priv->num_tx_rings = si->num_tx_rings;
-	priv->bdr_int_num = priv->num_rx_rings; /* int for each Tx/Rx pairs */
-
-	/* SI specific */
-	si->cbd_ring.bd_count = 64; //TODO: use defines for defaults
-}
-
 static int enetc_vf_probe(struct pci_dev *pdev,
 			  const struct pci_device_id *ent)
 {
@@ -223,7 +202,7 @@ static int enetc_vf_probe(struct pci_dev *pdev,
 
 	priv = netdev_priv(ndev);
 
-	enetc_vf_sw_init(priv);
+	enetc_init_si_rings_params(priv);
 
 	err = enetc_alloc_si_resources(priv);
 	if (err) {
-- 
2.17.1


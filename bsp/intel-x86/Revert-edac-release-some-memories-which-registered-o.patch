From 554a9c949e20ea24b72cd9e72f4a16f8dae77bd6 Mon Sep 17 00:00:00 2001
From: Yongxin Liu <yongxin.liu@windriver.com>
Date: Thu, 3 Jan 2019 10:44:02 +0000
Subject: [PATCH 1/2] Revert "edac: release some memories which registered or
 not to the driver subsystem."

This reverts commit 4e51fc97f16baabaf1de1c8b6daf1483ac971274.
It uses dimm_info/csrow_info after they have been freed in
dimm_attr-release()/csrow_attr_release().

Signed-off-by: Yongxin Liu <yongxin.liu@windriver.com>
---
 drivers/edac/edac_mc.c       | 37 -------------------------------------
 drivers/edac/edac_mc.h       |  9 ---------
 drivers/edac/edac_mc_sysfs.c |  8 +-------
 3 files changed, 1 insertion(+), 53 deletions(-)

diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 281066e..7d3edd7 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -305,40 +305,6 @@ static void _edac_mc_free(struct mem_ctl_info *mci)
 	kfree(mci);
 }
 
-static void _edac_mc_free_unregister(struct mem_ctl_info *mci)
-{
-	int i, chn, row;
-	struct csrow_info *csr;
-	const unsigned int tot_dimms = mci->tot_dimms;
-	const unsigned int tot_channels = mci->num_cschannel;
-	const unsigned int tot_csrows = mci->nr_csrows;
-
-	if (mci->dimms) {
-		for (i = 0; i < tot_dimms; i++) {
-			struct dimm_info *dimm = mci->dimms[i];
-
-			/* Only expose populated DIMMs */
-			if (!dimm->nr_pages)
-				kfree(mci->dimms[i]);
-		}
-		kfree(mci->dimms);
-	}
-	if (mci->csrows) {
-		for (row = 0; row < tot_csrows; row++) {
-			csr = mci->csrows[row];
-			if (csr && !nr_pages_per_csrow(csr)) {
-				if (csr->channels) {
-					for (chn = 0; chn < tot_channels; chn++)
-						kfree(csr->channels[chn]);
-					kfree(csr->channels);
-				}
-				kfree(csr);
-			}
-		}
-		kfree(mci->csrows);
-	}
-}
-
 struct mem_ctl_info *edac_mc_alloc(unsigned mc_num,
 				   unsigned n_layers,
 				   struct edac_mc_layer *layers,
@@ -548,9 +514,6 @@ void edac_mc_free(struct mem_ctl_info *mci)
 		return;
 	}
 
-	/*the unregistered mci intstance is freed here*/
-	_edac_mc_free_unregister(mci);
-
 	/* the mci instance is freed here, when the sysfs object is dropped */
 	edac_unregister_sysfs(mci);
 }
diff --git a/drivers/edac/edac_mc.h b/drivers/edac/edac_mc.h
index 138f42d..4165e15 100644
--- a/drivers/edac/edac_mc.h
+++ b/drivers/edac/edac_mc.h
@@ -259,13 +259,4 @@ void edac_mc_handle_error(const enum hw_event_mc_err_type type,
  */
 extern char *edac_op_state_to_string(int op_state);
 
-/**
- * nr_pages_per_csrow()  - Calculate the nr_pages of csrow contains
- *
- * @csrow: pointer to a struct csrow_info structure
- *
- * Returns: returns the int nr_pages.
- */
-extern int nr_pages_per_csrow(struct csrow_info *csrow);
-
 #endif				/* _EDAC_MC_H_ */
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index 4405b02..20374b8 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -390,7 +390,7 @@ static const struct attribute_group *csrow_dev_groups[] = {
 	NULL
 };
 
-int nr_pages_per_csrow(struct csrow_info *csrow)
+static inline int nr_pages_per_csrow(struct csrow_info *csrow)
 {
 	int chan, nr_pages = 0;
 
@@ -399,7 +399,6 @@ int nr_pages_per_csrow(struct csrow_info *csrow)
 
 	return nr_pages;
 }
-EXPORT_SYMBOL(nr_pages_per_csrow);
 
 /* Create a CSROW object under specifed edac_mc_device */
 static int edac_create_csrow_object(struct mem_ctl_info *mci,
@@ -454,17 +453,12 @@ static int edac_create_csrow_objects(struct mem_ctl_info *mci)
 static void edac_delete_csrow_objects(struct mem_ctl_info *mci)
 {
 	int i;
-	int chn;
 	struct csrow_info *csrow;
-	const unsigned int tot_channels = mci->num_cschannel;
 
 	for (i = mci->nr_csrows - 1; i >= 0; i--) {
 		csrow = mci->csrows[i];
 		if (!nr_pages_per_csrow(csrow))
 			continue;
-		for (chn = 0; chn < tot_channels; chn++)
-			kfree(csrow->channels[chn]);
-		kfree(csrow->channels);
 		device_unregister(&mci->csrows[i]->dev);
 	}
 }
-- 
2.7.4


From c4fafc85b8bb70de3627e8567cc89c7e5a186fb2 Mon Sep 17 00:00:00 2001
From: Xianzhong <xianzhong.li@nxp.com>
Date: Wed, 18 Jul 2018 00:53:11 +0800
Subject: [PATCH 4158/5242] MGS-3904 gpu: integrate vivante 6.2.4.p2 driver

commit  9cf57dfb97a1de919f9271a1b24a0f73172b1713 from
https://source.codeaurora.org/external/imx/linux-imx.git

version upgrade from 6.2.4.p1.150331 to 6.2.4.p2.163672

fixed gpu kernel panic for CONFIG_ARM64_SW_TTBR0_PAN,
support frequency query for gpu shader and core.

Signed-off-by: Xianzhong <xianzhong.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/gpu-viv/Kbuild                         |    2 +
 .../hal/kernel/arch/gc_hal_kernel_context.c        |    2 +-
 .../hal/kernel/arch/gc_hal_kernel_hardware.c       |  306 +++++++++-
 .../hal/kernel/arch/gc_hal_kernel_hardware.h       |   20 +
 .../hal/kernel/archvg/gc_hal_kernel_hardware_vg.c  |    2 +
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     |  204 +++++--
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |    2 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |   12 +-
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |    2 +
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c   |    1 +
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |   65 +-
 .../gpu-viv/hal/kernel/gc_hal_kernel_metadata.h    |   88 ---
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c |   26 +-
 .../gpu-viv/hal/kernel/gc_hal_kernel_security.c    |    2 +
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c  |    1 +
 .../gpu-viv/hal/kernel/inc/gc_feature_database.h   |   30 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |   42 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  245 ++++----
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |   16 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h  |    2 +
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_drm.h    |    1 -
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h   |    2 +
 .../gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h    |    2 +
 .../hal/kernel/inc/gc_hal_eglplatform_type.h       |    2 +
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |    2 +
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h  |   90 +--
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |   81 +--
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h    |   40 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_metadata.h   |  118 ++++
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |    6 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h |    2 +
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_resource.h   |    2 +
 .../hal/kernel/inc/gc_hal_security_interface.h     |    8 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h |    2 +
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |   65 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |    6 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h     |   30 +-
 .../default/gc_hal_kernel_allocator_dma.c          |   65 +-
 .../default/gc_hal_kernel_allocator_dmabuf.c       |   45 +-
 .../default/gc_hal_kernel_allocator_gfp.c          |  291 ++++++---
 .../default/gc_hal_kernel_allocator_reserved_mem.c |   33 +-
 .../default/gc_hal_kernel_allocator_user_memory.c  |  150 ++++-
 .../freescale/gc_hal_kernel_allocator_cma.c        |   64 +-
 .../hal/os/linux/kernel/gc_hal_kernel_allocator.c  |   80 +++
 .../hal/os/linux/kernel/gc_hal_kernel_allocator.h  |   22 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  126 ++++
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |   16 +-
 .../hal/os/linux/kernel/gc_hal_kernel_drm.c        |    1 +
 .../hal/os/linux/kernel/gc_hal_kernel_linux.c      |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |   22 +
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c |  619 +++++++-------------
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h |    7 +-
 .../freescale/gc_hal_kernel_platform_imx.c         |  221 ++++---
 .../mxc/gpu-viv/hal/security_v1/gc_hal_ta_mmu.c    |   16 +-
 .../security_v1/os/emulator/gc_hal_ta_emulator.c   |    6 +-
 56 files changed, 2069 insertions(+), 1258 deletions(-)
 delete mode 100644 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_metadata.h
 create mode 100644 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_metadata.h

diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index cf795c6..653461c 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -126,8 +126,10 @@ OBJS += $(ARCH_KERNEL_DIR)/gc_hal_kernel_recorder.o
 endif
 
 ifneq ($(CONFIG_ARM64),)
+ifeq ($(CONFIG_ANDROID),)
 VIVANTE_ENABLE_VG=0
 endif
+endif
 
 ifeq ($(VIVANTE_ENABLE_VG), 1)
 OBJS +=\
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
index 5293dea..618d1d4 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
@@ -2525,7 +2525,7 @@
 
     if (halti5)
     {
-        index += _State(Context, index, 0x14920 >> 2, 0x00000000, 7, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x14920 >> 2, 0x03012000, 7, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x14940 >> 2, 0x00000000, 7, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x14960 >> 2, 0x00000000, 7, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x14980 >> 2, 0x00000000, 7, gcvFALSE, gcvFALSE);
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
index 19373b0..ec9de84de 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
@@ -1751,7 +1751,9 @@
  22:22) + 1))))))) << (0 ? 22:22)))));
 #endif
 
-    if (gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_64K_L2_CACHE) == gcvFALSE)
+    hardware->hasL2Cache = gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_64K_L2_CACHE);
+
+    if (!hardware->hasL2Cache)
     {
         gcmkONERROR(gckOS_WriteRegisterEx(Os,
                                           Core,
@@ -1865,6 +1867,7 @@
         gcmkONERROR(gckOS_AllocateNonPagedMemory(
             hardware->os,
             gcvFALSE,
+            gcvALLOC_FLAG_CONTIGUOUS,
             &hardware->pagetableArray.size,
             &hardware->pagetableArray.physical,
             &hardware->pagetableArray.logical
@@ -1875,6 +1878,12 @@
             hardware->pagetableArray.logical,
             &hardware->pagetableArray.address
             ));
+
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            hardware->os,
+            hardware->pagetableArray.address,
+            &hardware->pagetableArray.address
+            ));
     }
 
     /* Return pointer to the gckHARDWARE object. */
@@ -2966,6 +2975,81 @@
     return status;
 }
 
+/* Atomic version of Execute, for IRQ routine. */
+static gceSTATUS
+gckHARDWARE_AtomicExecute(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 Address,
+    IN gctSIZE_T Bytes
+    )
+{
+    gctUINT32 control;
+
+    /* Enable all events. */
+    gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00014, ~0U);
+
+    /* Write address register. */
+    gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00654, Address);
+
+    /* Build control register. */
+    control = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 16:16) - (0 ? 16:16) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 16:16) - (0 ?
+ 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ?
+ 16:16) - (0 ? 16:16) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 16:16) - (0 ?
+ 16:16) + 1))))))) << (0 ? 16:16)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 15:0) - (0 ? 15:0) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ?
+ 15:0))) | (((gctUINT32) ((gctUINT32) ((Bytes + 7) >> 3) & ((gctUINT32) ((((1 ?
+ 15:0) - (0 ? 15:0) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ?
+ 15:0)));
+
+    /* Set big endian */
+    if (Hardware->bigEndian)
+    {
+        control |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 21:20) - (0 ? 21:20) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 21:20) - (0 ?
+ 21:20) + 1))))))) << (0 ? 21:20))) | (((gctUINT32) (0x2 & ((gctUINT32) ((((1 ?
+ 21:20) - (0 ? 21:20) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 21:20) - (0 ?
+ 21:20) + 1))))))) << (0 ? 21:20)));
+    }
+
+    /* Make sure writing to command buffer and previous AHB register is done. */
+    gckOS_MemoryBarrier(Hardware->os, gcvNULL);
+
+    /* Write control register. */
+    switch (Hardware->options.secureMode)
+    {
+    case gcvSECURE_NONE:
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00658, control);
+        break;
+    case gcvSECURE_IN_NORMAL:
+
+#if defined(__KERNEL__)
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00658, control);
+#endif
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x003A4, control);
+
+        break;
+#if gcdENABLE_TRUST_APPLICATION
+    case gcvSECURE_IN_TA:
+        /* Send message to TA. */
+        gckKERNEL_SecurityStartCommand(Hardware->kernel, Address, (gctUINT32)Bytes);
+        break;
+#endif
+    default:
+        break;
+    }
+
+    /* Increase execute count. */
+    Hardware->executeCount++;
+
+    /* Record last execute address. */
+    Hardware->lastExecuteAddress = Address;
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
 /*******************************************************************************
 **
 **  gckHARDWARE_WaitLink
@@ -3032,7 +3116,7 @@
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
     gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
-    useL2 = gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_64K_L2_CACHE);
+    useL2 = Hardware->hasL2Cache;
 
     /* Compute number of bytes required. */
     if (useL2)
@@ -3596,6 +3680,7 @@
         {
             gctPHYS_ADDR_T phys;
             gckOS_GetPhysicalAddress(Hardware->os, Logical, &phys);
+            gckOS_CPUPhysicalToGPUPhysical(Hardware->os, phys, &phys);
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                            "0x%08x: EVENT %d", phys, Event);
         }
@@ -4356,6 +4441,8 @@
         gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, Logical, &physical));
     }
 
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Hardware->os, physical, &physical));
+
     gcmkSAFECASTPHYSADDRT(address, physical);
 
     /* For old MMU, get GPU address according to baseAddress. */
@@ -4390,6 +4477,42 @@
     return status;
 }
 
+static void
+_ResumeWaitLinkFE(
+    gckHARDWARE Hardware
+    )
+{
+    gctUINT32 resume;
+    gctUINT32 bytes;
+    gctUINT32 idle;
+
+    /* Make sure FE is idle. */
+    do
+    {
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00004,
+                             &idle);
+    }
+    while (idle != 0x7FFFFFFF);
+
+    gckOS_ReadRegisterEx(Hardware->os,
+                         Hardware->core,
+                         0x00664,
+                         &resume);
+
+    gckOS_ReadRegisterEx(Hardware->os,
+                         Hardware->core,
+                         0x00664,
+                         &resume);
+
+    /* Determine the wait-link command size. */
+    bytes = Hardware->hasL2Cache ? 24 : 16;
+
+    /* Start Command Parser. */
+    gckHARDWARE_AtomicExecute(Hardware, resume, bytes);
+}
+
 /*******************************************************************************
 **
 **  gckHARDWARE_Interrupt
@@ -4437,11 +4560,15 @@
          * That means, only need return ERROR when both FEs reports ERROR.
          */
         /* Read AQIntrAcknowledge register. */
-        gcmkONERROR(
-            gckOS_ReadRegisterEx(Hardware->os,
-                                 Hardware->core,
-                                 0x00010,
-                                 &data));
+        status = gckOS_ReadRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00010,
+                                      &data);
+
+        if (gcmIS_ERROR(status))
+        {
+            goto OnError;
+        }
 
         if (data == 0)
         {
@@ -4453,6 +4580,13 @@
 #if gcdINTERRUPT_STATISTIC
             gckOS_AtomClearMask(Hardware->pendingEvent, data);
 #endif
+            if (data & (1 << 29))
+            {
+                /* Event ID 29 is not a normal event, but for invalidating pipe. */
+                _ResumeWaitLinkFE(Hardware);
+                data &= ~(1 << 29);
+            }
+
             /* Inform gckEVENT of the interrupt. */
             status = gckEVENT_Interrupt(eventObj, data);
         }
@@ -4796,6 +4930,8 @@
         /* Convert the logical address into physical address. */
         gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, Logical, &physical));
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Hardware->os, physical, &physical));
+
         gcmkSAFECASTPHYSADDRT(address, physical);
 
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
@@ -4915,6 +5051,9 @@
                 gcmkONERROR(
                     gckOS_GetPhysicalAddress(Hardware->os, safeLogical, &physical));
 
+                gcmkVERIFY_OK(
+                    gckOS_CPUPhysicalToGPUPhysical(Hardware->os, physical, &physical));
+
                 address = (gctUINT32)(physical & 0xFFFFFFFF);
                 extSafeAddress = (gctUINT32)(physical >> 32);
 
@@ -5656,10 +5795,15 @@
         }
     }
 
+    reserveBytes += 8;
+
     /* Convert logical address into physical address. */
     gcmkONERROR(
         gckOS_GetPhysicalAddress(Hardware->os, MtlbAddress, &physical));
 
+    gcmkVERIFY_OK(
+        gckOS_CPUPhysicalToGPUPhysical(Hardware->os, physical, &physical));
+
     config  = (gctUINT32)(physical & 0xFFFFFFFF);
     extMtlb = (gctUINT32)(physical >> 32);
 
@@ -5672,6 +5816,9 @@
     gcmkONERROR(
         gckOS_GetPhysicalAddress(Hardware->os, SafeAddress, &physical));
 
+    gcmkVERIFY_OK(
+        gckOS_CPUPhysicalToGPUPhysical(Hardware->os, physical, &physical));
+
     address = (gctUINT32)(physical & 0xFFFFFFFF);
     extSafeAddress = (gctUINT32)(physical >> 32);
 
@@ -5844,6 +5991,30 @@
             }
         }
 
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 31:27) - (0 ? 31:27) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 31:27) - (0 ?
+ 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
+ 31:27) - (0 ? 31:27) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 31:27) - (0 ?
+ 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 15:0) - (0 ? 15:0) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ?
+ 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E12) & ((gctUINT32) ((((1 ? 15:0) - (0 ?
+ 15:0) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ?
+ 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 25:16) - (0 ? 25:16) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 25:16) - (0 ?
+ 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
+ 25:16) - (0 ? 25:16) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 25:16) - (0 ?
+ 25:16) + 1))))))) << (0 ? 25:16)));
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 16:16) - (0 ? 16:16) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 16:16) - (0 ?
+ 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
+ 16:16) - (0 ? 16:16) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 16:16) - (0 ?
+ 16:16) + 1))))))) << (0 ? 16:16)));
+
         do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  31:27) - (0 ? 31:27) + 1) == 32) ? ~0U : (~(~0U << ((1 ? 31:27) - (0 ?
  31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
@@ -6185,11 +6356,23 @@
         /* Get physical address of this command buffer segment. */
         gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, buffer, &physical));
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            Hardware->os,
+            physical,
+            &physical
+            ));
+
         gcmkSAFECASTPHYSADDRT(address, physical);
 
         /* Get physical address of Master TLB. */
         gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, MtlbLogical, &physical));
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            Hardware->os,
+            physical,
+            &physical
+            ));
+
         gcmkSAFECASTPHYSADDRT(config, physical);
 
         config |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
@@ -12109,11 +12292,19 @@
     {
         gctUINT32 mmuBytes;
         gctPHYS_ADDR_T physical = 0;
+        gctUINT32 flags = gcvALLOC_FLAG_CONTIGUOUS;
+
+#if defined(CONFIG_ZONE_DMA32)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+        flags |= gcvALLOC_FLAG_4GB_ADDR;
+#endif
+#endif
 
         /* Allocate mmu command buffer within 32bit space */
         gcmkONERROR(gckOS_AllocateNonPagedMemory(
             os,
             gcvFALSE,
+            flags,
             &Hardware->mmuFuncBytes,
             &Hardware->mmuFuncPhysical,
             &Hardware->mmuFuncLogical
@@ -12125,9 +12316,16 @@
             &physical
             ));
 
-        if (physical & 0xFFFFFFFF00000000ULL)
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            os,
+            physical,
+            &physical
+            ));
+
+        if (!(flags & gcvALLOC_FLAG_4GB_ADDR) && (physical & 0xFFFFFFFF00000000ULL))
         {
-            gcmkFATAL("%s(%d): Command buffer physical address (0x%llx) for MMU setup exceeds 32bits",
+            gcmkFATAL("%s(%d): Command buffer physical address (0x%llx) for MMU setup exceeds 32bits, "
+                      "please rebuild kernel with CONFIG_ZONE_DMA32=y.",
                       __FUNCTION__, __LINE__, physical);
         }
 
@@ -12185,6 +12383,7 @@
         gcmkONERROR(gckOS_AllocateNonPagedMemory(
             os,
             gcvFALSE,
+            gcvALLOC_FLAG_CONTIGUOUS,
             &Hardware->auxFuncBytes,
             &Hardware->auxFuncPhysical,
             &Hardware->auxFuncLogical
@@ -12196,6 +12395,12 @@
             &physical
             ));
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            os,
+            physical,
+            &physical
+            ));
+
         gcmkSAFECASTPHYSADDRT(Hardware->auxFuncAddress, physical);
 
         gcmkONERROR(gckMMU_FillFlatMapping(
@@ -13711,4 +13916,87 @@
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckHARDWARE_EnterQueryClock(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT64 *McStart,
+    OUT gctUINT64 *ShStart
+    )
+{
+    gceSTATUS status;
+    gctUINT64 mcStart, shStart;
+
+    gcmkONERROR(gckOS_GetTime(&mcStart));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+
+    *McStart = mcStart;
+
+    if (Hardware->core <= gcvCORE_3D_MAX)
+    {
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, 0xFFU << 24));
+
+        gcmkONERROR(gckOS_GetTime(&shStart));
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, 0x4U << 24));
+
+        *ShStart = shStart;
+    }
+
+OnError:
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_ExitQueryClock(
+    IN gckHARDWARE Hardware,
+    IN gctUINT64 McStart,
+    IN gctUINT64 ShStart,
+    OUT gctUINT32 *McClk,
+    OUT gctUINT32 *ShClk
+    )
+{
+    gceSTATUS status;
+    gctUINT64 mcEnd, shEnd;
+    gctUINT32 mcCycle, shCycle;
+    gctUINT64 mcFreq, shFreq = 0;
+
+    gcmkONERROR(gckOS_GetTime(&mcEnd));
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00438, &mcCycle));
+
+    if (mcCycle == 0)
+    {
+        gcmkONERROR(gcvSTATUS_GENERIC_IO);
+    }
+
+    /* cycle = (gctUINT64)cycle * 1000000 / (end - start); */
+    mcFreq = ((gctUINT64)mcCycle * ((1000000U << 12) / (gctUINT32)(mcEnd - McStart))) >> 12;
+
+    *McClk = (gctUINT32)mcFreq;
+
+    if (Hardware->core <= gcvCORE_3D_MAX)
+    {
+        gcmkONERROR(gckOS_GetTime(&shEnd));
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &shCycle));
+
+        if (!shCycle)
+        {
+            /*TODO: [VIV] Query SH cycle not support for old chips */
+            *ShClk = *McClk;
+            return gcvSTATUS_OK;
+        }
+
+        if (!ShStart)
+        {
+            gcmkONERROR(gcvSTATUS_GENERIC_IO);
+        }
+
+        shFreq = ((gctUINT64)shCycle * ((1000000U << 12) / (gctUINT32)(shEnd - ShStart))) >> 12;
+    }
+
+    *ShClk = (gctUINT32)shFreq;
+
+OnError:
+    return status;
+}
+
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
index 5dd2c25..e1e7de6 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
@@ -215,6 +215,9 @@ struct _gckHARDWARE
     gctUINT32                   minFscaleValue;
     gctUINT                     waitCount;
 
+    gctUINT32                   mcClk;
+    gctUINT32                   shClk;
+
     gctPOINTER                  pendingEvent;
 
     /* Function used by gckHARDWARE. */
@@ -238,6 +241,7 @@ struct _gckHARDWARE
 
     gctPOINTER                  featureDatabase;
     gctBOOL                     hasAsyncFe;
+    gctBOOL                     hasL2Cache;
 
     gcsHARDWARE_SIGNATURE       signature;
 
@@ -335,6 +339,22 @@ struct _gckHARDWARE
     IN OUT gctUINT32 * Bytes
     );
 
+gceSTATUS
+gckHARDWARE_EnterQueryClock(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT64 *McStart,
+    OUT gctUINT64 *ShStart
+    );
+
+gceSTATUS
+gckHARDWARE_ExitQueryClock(
+    IN gckHARDWARE Hardware,
+    IN gctUINT64 McStart,
+    IN gctUINT64 ShStart,
+    OUT gctUINT32 *McClk,
+    OUT gctUINT32 *ShClk
+    );
+
 #define gcmkWRITE_MEMORY(logical, data) \
     do { \
     gcmkVERIFY_OK(gckOS_WriteMemory(os, logical, data)); \
diff --git a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c
index a4f7f7f..cf007fd 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c
@@ -1229,6 +1229,8 @@
                 ));
         }
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Hardware->os, physical, &physical));
+
         gcmkSAFECASTPHYSADDRT(address, physical);
 
         /* Return hardware specific address. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 2cdc21f..ba3347a 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -82,6 +82,7 @@
 {
     gcmDEFINE2TEXT(gcvHAL_QUERY_VIDEO_MEMORY),
     gcmDEFINE2TEXT(gcvHAL_QUERY_CHIP_IDENTITY),
+    gcmDEFINE2TEXT(gcvHAL_QUERY_CHIP_FREQUENCY),
     gcmDEFINE2TEXT(gcvHAL_ALLOCATE_NON_PAGED_MEMORY),
     gcmDEFINE2TEXT(gcvHAL_FREE_NON_PAGED_MEMORY),
     gcmDEFINE2TEXT(gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY),
@@ -303,6 +304,8 @@
             &physical
             ));
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, physical, &physical));
+
         gcmkSAFECASTPHYSADDRT(address, physical);
 
         gcmkONERROR(gckMMU_FlatMapping(mmu, address, 1));
@@ -850,6 +853,13 @@
         Kernel->monitorTimerStop = gcvTRUE;
     }
 
+    if (Kernel->monitorTimer)
+    {
+        /* Stop and destroy monitor timer. */
+        gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->monitorTimer));
+        gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->monitorTimer));
+    }
+
 #if gcdENABLE_VG
     if (Kernel->vg)
     {
@@ -936,12 +946,6 @@
     }
 #endif
 
-    if (Kernel->monitorTimer)
-    {
-        gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->monitorTimer));
-        gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->monitorTimer));
-    }
-
     /* Mark the gckKERNEL object as unknown. */
     Kernel->object.type = gcvOBJ_UNKNOWN;
 
@@ -1911,6 +1915,93 @@
     return status;
 }
 
+static gceSTATUS
+gckKERNEL_CacheOperation(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 ProcessID,
+    IN gctUINT32 Node,
+    IN gceCACHEOPERATION Operation,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    )
+{
+    gceSTATUS status;
+    gckVIDMEM_NODE nodeObject = gcvNULL;
+    gcuVIDMEM_NODE_PTR node = gcvNULL;
+    void *memHandle;
+
+    gcmkHEADER_ARG("Kernel=%p pid=%u Node=%u op=%d Logical=%p Bytes=0x%lx",
+                   Kernel, ProcessID, Node, Operation, Logical, Bytes);
+
+    gcmkONERROR(gckVIDMEM_HANDLE_Lookup(Kernel,
+                                        ProcessID,
+                                        Node,
+                                        &nodeObject));
+
+    node = nodeObject->node;
+
+    if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+    {
+        static gctBOOL printed;
+
+        if (!printed)
+        {
+            printed = gcvTRUE;
+            gcmkPRINT("[galcore]: %s: Flush Video Memory", __FUNCTION__);
+        }
+
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+    else
+    {
+        memHandle = node->Virtual.physical;
+    }
+
+    switch (Operation)
+    {
+    case gcvCACHE_FLUSH:
+        /* Clean and invalidate the cache. */
+        status = gckOS_CacheFlush(Kernel->os,
+                                  ProcessID,
+                                  memHandle,
+                                  gcvINVALID_PHYSICAL_ADDRESS,
+                                  Logical,
+                                  Bytes);
+        break;
+    case gcvCACHE_CLEAN:
+        /* Clean the cache. */
+        status = gckOS_CacheClean(Kernel->os,
+                                  ProcessID,
+                                  memHandle,
+                                  gcvINVALID_PHYSICAL_ADDRESS,
+                                  Logical,
+                                  Bytes);
+        break;
+    case gcvCACHE_INVALIDATE:
+        /* Invalidate the cache. */
+        status = gckOS_CacheInvalidate(Kernel->os,
+                                       ProcessID,
+                                       memHandle,
+                                       gcvINVALID_PHYSICAL_ADDRESS,
+                                       Logical,
+                                       Bytes);
+        break;
+
+    case gcvCACHE_MEMORY_BARRIER:
+        status = gckOS_MemoryBarrier(Kernel->os, Logical);
+        break;
+
+    default:
+        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+        break;
+    }
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
 gceSTATUS
 gckKERNEL_WaitFence(
     IN gckKERNEL Kernel,
@@ -2150,7 +2241,6 @@
     gcskSECURE_CACHE_PTR cache;
     gctPOINTER logical;
 #endif
-    gctUINT64 paddr = gcvINVALID_ADDRESS;
 #if !USE_NEW_LINUX_SIGNAL
     gctSIGNAL   signal;
 #endif
@@ -2209,6 +2299,12 @@
                 &Interface->u.QueryChipIdentity));
         break;
 
+    case gcvHAL_QUERY_CHIP_FREQUENCY:
+        /* Query chip clock. */
+        Interface->u.QueryChipFrequency.mcClk = Kernel->hardware->mcClk;
+        Interface->u.QueryChipFrequency.shClk = Kernel->hardware->shClk;
+        break;
+
     case gcvHAL_MAP_MEMORY:
         physical = gcmINT2PTR(Interface->u.MapMemory.physical);
 
@@ -2254,6 +2350,7 @@
             gckOS_AllocateNonPagedMemory(
                 Kernel->os,
                 FromUser,
+                gcvALLOC_FLAG_CONTIGUOUS,
                 &bytes,
                 &physical,
                 &logical));
@@ -2486,11 +2583,10 @@
         }
         else
         {
-	    gctUINT32 i;
+            gctUINT32 i;
+
             if (Interface->u.Commit.count > 1 && Interface->engine == gcvENGINE_RENDER)
             {
-                gctUINT32 i;
-
                 for (i = 0; i < Interface->u.Commit.count; i++)
                 {
                     gceHARDWARE_TYPE type = Interface->hardwareType;
@@ -2531,7 +2627,6 @@
 
             if (Interface->u.Commit.count > 1 && Interface->engine == gcvENGINE_RENDER)
             {
-
                 for (i = 1; i < Interface->u.Commit.count; i++)
                 {
                     gceHARDWARE_TYPE type = Interface->hardwareType;
@@ -2568,22 +2663,24 @@
                 }
             }
 
-	    for (i = 0; i < Interface->u.Commit.count; i++) {
-		    gceHARDWARE_TYPE type = Interface->hardwareType;
-		    gckKERNEL kernel = Device->map[type].kernels[i];
-
-		    if  ((kernel->hardware->options.gpuProfiler == gcvTRUE) &&
-		         (kernel->profileEnable == gcvTRUE)) {
-			    gcmkONERROR(gckCOMMAND_Stall(kernel->command, gcvTRUE));
+            for (i = 0; i < Interface->u.Commit.count; i++)
+            {
+                gceHARDWARE_TYPE type = Interface->hardwareType;
+                gckKERNEL kernel = Device->map[type].kernels[i];
 
-			    if (kernel->command->currContext) {
-				    gcmkONERROR(gckHARDWARE_UpdateContextProfile(
-							    kernel->hardware,
-							    kernel->command->currContext));
-			    }
-		    }
-	    }
+                if  ((kernel->hardware->options.gpuProfiler == gcvTRUE) &&
+                     (kernel->profileEnable == gcvTRUE))
+                {
+                    gcmkONERROR(gckCOMMAND_Stall(kernel->command, gcvTRUE));
 
+                    if (kernel->command->currContext)
+                    {
+                        gcmkONERROR(gckHARDWARE_UpdateContextProfile(
+                                    kernel->hardware,
+                                    kernel->command->currContext));
+                    }
+                }
+            }
         }
         gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->device->commitMutex));
         commitMutexAcquired = gcvFALSE;
@@ -2913,48 +3010,15 @@
         break;
 
     case gcvHAL_CACHE:
-
         logical = gcmUINT64_TO_PTR(Interface->u.Cache.logical);
-
         bytes = (gctSIZE_T) Interface->u.Cache.bytes;
-        switch(Interface->u.Cache.operation)
-        {
-        case gcvCACHE_FLUSH:
-            /* Clean and invalidate the cache. */
-            status = gckOS_CacheFlush(Kernel->os,
-                                      processID,
-                                      physical,
-                                      paddr,
-                                      logical,
-                                      bytes);
-            break;
-        case gcvCACHE_CLEAN:
-            /* Clean the cache. */
-            status = gckOS_CacheClean(Kernel->os,
-                                      processID,
-                                      physical,
-                                      paddr,
-                                      logical,
-                                      bytes);
-            break;
-        case gcvCACHE_INVALIDATE:
-            /* Invalidate the cache. */
-            status = gckOS_CacheInvalidate(Kernel->os,
-                                           processID,
-                                           physical,
-                                           paddr,
-                                           logical,
-                                           bytes);
-            break;
 
-        case gcvCACHE_MEMORY_BARRIER:
-            status = gckOS_MemoryBarrier(Kernel->os,
-                                         logical);
-            break;
-        default:
-            status = gcvSTATUS_INVALID_ARGUMENT;
-            break;
-        }
+        gcmkONERROR(gckKERNEL_CacheOperation(Kernel,
+                                             processID,
+                                             Interface->u.Cache.node,
+                                             Interface->u.Cache.operation,
+                                             logical,
+                                             bytes));
         break;
 
     case gcvHAL_TIMESTAMP:
@@ -3635,6 +3699,8 @@
             /* Map the logical address to a DMA address. */
             gcmkONERROR(
                 gckOS_GetPhysicalAddress(Kernel->os, *Data, &slot->dma));
+
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, slot->dma, &slot->dma));
         }
 
         /* Move slot to head of list. */
@@ -3743,6 +3809,8 @@
             /* Map the logical address to a DMA address. */
             gcmkONERROR(
                 gckOS_GetPhysicalAddress(Kernel->os, *Data, &slot->dma));
+
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, slot->dma, &slot->dma));
         }
 
         /* Save time stamp. */
@@ -3798,6 +3866,8 @@
             gcmkONERROR(
                 gckOS_GetPhysicalAddress(Kernel->os, *Data, &slot->dma));
 
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, slot->dma, &slot->dma));
+
             if (hash->nextHash != gcvNULL)
             {
                 gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_KERNEL,
@@ -3845,6 +3915,8 @@
             /* Map the logical address to a DMA address. */
             gcmkONERROR(
                 gckOS_GetPhysicalAddress(Kernel->os, *Data, &slot->dma));
+
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, slot->dma, &slot->dma));
         }
     }
 #endif
@@ -4534,6 +4606,7 @@
         gcmkONERROR(gckOS_AllocateNonPagedMemory(
             os,
             InUserSpace,
+            gcvALLOC_FLAG_CONTIGUOUS,
             &bytes,
             &buffer->physical,
             &logical
@@ -5864,6 +5937,7 @@
         gcmkONERROR(gckOS_AllocateNonPagedMemory(
             Os,
             gcvFALSE,
+            gcvALLOC_FLAG_CONTIGUOUS,
             &pageSize,
             &fence->physical,
             &fence->logical
@@ -6408,6 +6482,8 @@
                 logical,
                 &phys
                 ));
+
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, phys, &phys));
         }
 
         phys &= ~pageMask;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 9dac34d..63a1089 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -60,7 +60,7 @@
 #include "gc_hal_kernel_hardware.h"
 #include "gc_hal_driver.h"
 #include "gc_hal_kernel_mutex.h"
-#include "gc_hal_kernel_metadata.h"
+#include "gc_hal_metadata.h"
 
 #if gcdENABLE_VG
 #include "gc_hal_kernel_vg.h"
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index a9cb300..5a336cb 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -148,7 +148,13 @@
     gcmkONERROR(gckOS_GetPhysicalAddress(
         Command->os,
         Command->logical,
-       &physical
+        &physical
+        ));
+
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+        Command->os,
+        physical,
+        &physical
         ));
 
     gcmkSAFECASTPHYSADDRT(Command->physical, physical);
@@ -602,6 +608,8 @@
 
         gckOS_GetPhysicalAddress(Command->os, entry, &physical);
 
+        gckOS_CPUPhysicalToGPUPhysical(Command->os, physical, &physical);
+
         gcmkPRINT("Kernel command buffer %d\n", i);
 
         gcmkSAFECASTPHYSADDRT(address, physical);
@@ -1132,6 +1140,7 @@
             gcmkONERROR(gckOS_AllocateNonPagedMemory(
                 os,
                 gcvFALSE,
+                gcvALLOC_FLAG_CONTIGUOUS,
                 &pageSize,
                 &command->queues[i].physical,
                 &command->queues[i].logical
@@ -1991,6 +2000,7 @@
         commandBufferLogical,
         &commandBufferPhysical
         ));
+
 #else
     /* Get the physical address. */
     gcmkONERROR(gckOS_UserLogicalToPhysical(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index 6167212..6c30ceb 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -1187,6 +1187,8 @@
 
         gcmkERR_BREAK(gckOS_GetPhysicalAddress(Command->os, logical, &paddr));
 
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Command->os, paddr, &paddr));
+
         gcmkSAFECASTPHYSADDRT(address, paddr);
 
         /* Set return values. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
index f526793..77d2750 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
@@ -2031,6 +2031,7 @@ static gcmINLINE int _GetArgumentSize(
         if (Type != gcvDUMP_BUFFER_FROM_USER)
         {
             gcmkVERIFY_OK(gckOS_GetPhysicalAddress(Os, Buffer, &physical));
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Os, physical, &physical));
             gcmkSAFECASTPHYSADDRT(address, physical);
         }
         else
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index 03bd3c7..fb3a994 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -2038,62 +2038,6 @@
     IN gctUINT32 Data
     )
 {
-    gcmkHEADER_ARG("Event=0x%x Data=0x%x", Event, Data);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
-
-    if (Data & 0x20000000)
-    {
-        gctUINT32 resume;
-        gctUINT32 bytes;
-        gctUINT32 idle;
-        gctUINT32 pageSize = Event->kernel->command->pageSize;
-        Data &= ~0x20000000;
-
-        {
-            /* Make sure FE is idle. */
-            do
-            {
-                gcmkVERIFY_OK(gckOS_ReadRegisterEx(
-                    Event->os,
-                    Event->kernel->core,
-                    0x4,
-                    &idle));
-            }
-            while (idle != 0x7FFFFFFF);
-
-            gcmkVERIFY_OK(gckOS_ReadRegisterEx(
-                    Event->os,
-                    Event->kernel->core,
-                    0x664,
-                    &resume));
-
-            gcmkVERIFY_OK(gckOS_ReadRegisterEx(
-                    Event->os,
-                    Event->kernel->core,
-                    0x664,
-                    &resume));
-
-            gcmkVERIFY_OK(gckHARDWARE_WaitLink(
-                    Event->kernel->hardware,
-                    gcvNULL,
-                    ~0U,
-                    resume & (pageSize - 1),
-                    &bytes,
-                    gcvNULL,
-                    gcvNULL
-                    ));
-
-            /* Start Command Parser. */
-            gcmkVERIFY_OK(gckHARDWARE_Execute(
-                Event->kernel->hardware,
-                resume,
-                bytes
-                ));
-        }
-    }
-
     /* Combine current interrupt status with pending flags. */
     gckOS_AtomSetMask(Event->pending, Data);
 
@@ -2106,16 +2050,17 @@
         {
             if ((Data & (1 << j)))
             {
-                gcmkVERIFY_OK(gckOS_AtomDecrement(Event->os,
-                                                  Event->interruptCount,
-                                                  &oldValue));
+                gckOS_AtomDecrement(
+                    Event->os,
+                    Event->interruptCount,
+                    &oldValue
+                    );
             }
         }
     }
 #endif
 
     /* Success. */
-    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_metadata.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_metadata.h
deleted file mode 100644
index 55dd823..0000000
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_metadata.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/****************************************************************************
-*
-*    The MIT License (MIT)
-*
-*    Copyright (c) 2014 - 2018 Vivante Corporation
-*
-*    Permission is hereby granted, free of charge, to any person obtaining a
-*    copy of this software and associated documentation files (the "Software"),
-*    to deal in the Software without restriction, including without limitation
-*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-*    and/or sell copies of the Software, and to permit persons to whom the
-*    Software is furnished to do so, subject to the following conditions:
-*
-*    The above copyright notice and this permission notice shall be included in
-*    all copies or substantial portions of the Software.
-*
-*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-*    DEALINGS IN THE SOFTWARE.
-*
-*****************************************************************************
-*
-*    The GPL License (GPL)
-*
-*    Copyright (C) 2014 - 2018 Vivante Corporation
-*
-*    This program is free software; you can redistribute it and/or
-*    modify it under the terms of the GNU General Public License
-*    as published by the Free Software Foundation; either version 2
-*    of the License, or (at your option) any later version.
-*
-*    This program is distributed in the hope that it will be useful,
-*    but WITHOUT ANY WARRANTY; without even the implied warranty of
-*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*    GNU General Public License for more details.
-*
-*    You should have received a copy of the GNU General Public License
-*    along with this program; if not, write to the Free Software Foundation,
-*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-*
-*****************************************************************************
-*
-*    Note: This software is released under dual MIT and GPL licenses. A
-*    recipient may use this file under the terms of either the MIT license or
-*    GPL License. If you wish to use only one license not the other, you can
-*    indicate your decision by deleting one of the above license notices in your
-*    version of this file.
-*
-*****************************************************************************/
-
-#ifndef __gc_hal_kernel_metadata_h_
-#define __gc_hal_kernel_metadata_h_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Macro to combine four characters into a Charcater Code. */
-#define __FOURCC(a, b, c, d) \
-    ((uint32_t)(a) | ((uint32_t)(b) << 8) | ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))
-
-#define VIV_VIDMEM_METADATA_MAGIC __FOURCC('v', 'i', 'v', 'm')
-
-/* Metadata for cross-device fd share with additional (ts) info. */
-typedef struct _VIV_VIDMEM_METADATA
-{
-    uint32_t magic;
-
-    int32_t  ts_fd;
-    void *   ts_dma_buf;
-
-    uint32_t fc_enabled;
-    uint32_t fc_value;
-    uint32_t fc_value_upper;
-
-    uint32_t compressed;
-    uint32_t compress_format;
-} _VIV_VIDMEM_METADATA;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __gc_hal_kernel_metadata_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
index d78e78b..95f4b56 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
@@ -638,6 +638,8 @@
 
     gcmkONERROR(gckOS_GetPhysicalAddress(Os, stlb->logical, &stlb->physBase));
 
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Os, stlb->physBase, &stlb->physBase));
+
 #if gcdUSE_MMU_EXCEPTION
     _FillPageTable(stlb->logical, stlb->size / 4, gcdMMU_STLB_EXCEPTION);
 #else
@@ -910,6 +912,11 @@
                 newStlbChunk->logical,
                 &physical));
 
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+                Mmu->os,
+                physical,
+                &physical));
+
             gcmkSAFECASTPHYSADDRT(newStlbChunk->physBase, physical);
 
             if (newStlbChunk->physBase & (gcdMMU_STLB_64K_SIZE - 1))
@@ -1176,6 +1183,10 @@
                 area->pageTableLogical,
                 &physical));
 
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Mmu->os,
+                physical,
+                &physical));
+
     gcmkSAFECASTPHYSADDRT(address, physical);
 
     /* Grab the mutex. */
@@ -1438,6 +1449,12 @@
                 &gpuPhysical
                 ));
 
+            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+                mmu->os,
+                gpuPhysical,
+                &gpuPhysical
+                ));
+
             gcmkSAFECASTPHYSADDRT(gpuAddress, gpuPhysical);
 
             gcmkONERROR(gckMMU_FlatMapping(mmu, gpuAddress, 1));
@@ -1534,11 +1551,18 @@
         &mmu->safePageLogical
         ));
 
-    gcmkONERROR(gckOS_GetPhysicalAddress(os,
+    gcmkONERROR(gckOS_GetPhysicalAddress(
+        os,
         mmu->safePageLogical,
         &gpuPhysical
         ));
 
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+        os,
+        gpuPhysical,
+        &gpuPhysical
+        ));
+
     gcmkSAFECASTPHYSADDRT(mmu->safeAddress, gpuPhysical);
 
     gckOS_ZeroMemory(mmu->safePageLogical, mmu->safePageSize);
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c
index 6c169a2..abf5485 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c
@@ -195,6 +195,7 @@
 
 #if defined(LINUX)
     gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os, Buffer, &physical));
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, physical, &physical));
     gcmkSAFECASTPHYSADDRT(address, physical);
 
     iface.u.Execute.command_buffer = (gctUINT32 *)address;
@@ -236,6 +237,7 @@
 
 #if defined(LINUX)
     gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os, PhysicalArray, &physical));
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Kernel->os, physical, &physical));
     gcmkSAFECASTPHYSADDRT(address, physical);
     iface.u.MapMemory.physicals = (gctUINT32 *)address;
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
index 93a914c..44a1bb0 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
@@ -326,6 +326,7 @@ gceSTATUS gckVGKERNEL_Dispatch(
         gcmkERR_BREAK(gckOS_AllocateNonPagedMemory(
             Kernel->os,
             gcvTRUE,
+            gcvALLOC_FLAG_CONTIGUOUS,
             &bytes,
             &physical,
             &logical
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_feature_database.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_feature_database.h
index be74a97..19c7cc68 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_feature_database.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_feature_database.h
@@ -53,7 +53,7 @@
 *****************************************************************************/
 
 
-/*Auto created on 2018-05-02 10:01*/
+/*Auto created on 2018-05-16 12:13*/
 #ifndef _gc_feature_database_h_
 #define _gc_feature_database_h_
 
@@ -8810,8 +8810,8 @@
         0x0, /* PatchVersion */
         0x1, /* FormalRelease */
         0x4, /* gcFEATURE_VALUE_Streams */
-        0x20, /* gcFEATURE_VALUE_TempRegisters */
-        0x40, /* gcFEATURE_VALUE_ThreadCount */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x80, /* gcFEATURE_VALUE_ThreadCount */
         0x8, /* gcFEATURE_VALUE_VertexCacheSize */
         0x1, /* gcFEATURE_VALUE_NumShaderCores */
         0x1, /* gcFEATURE_VALUE_NumPixelPipes */
@@ -9270,8 +9270,8 @@
         0x0, /* PatchVersion */
         0x1, /* FormalRelease */
         0x4, /* gcFEATURE_VALUE_Streams */
-        0x20, /* gcFEATURE_VALUE_TempRegisters */
-        0x40, /* gcFEATURE_VALUE_ThreadCount */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x80, /* gcFEATURE_VALUE_ThreadCount */
         0x8, /* gcFEATURE_VALUE_VertexCacheSize */
         0x1, /* gcFEATURE_VALUE_NumShaderCores */
         0x1, /* gcFEATURE_VALUE_NumPixelPipes */
@@ -9730,8 +9730,8 @@
         0x4, /* PatchVersion */
         0x1, /* FormalRelease */
         0x4, /* gcFEATURE_VALUE_Streams */
-        0x20, /* gcFEATURE_VALUE_TempRegisters */
-        0x40, /* gcFEATURE_VALUE_ThreadCount */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x80, /* gcFEATURE_VALUE_ThreadCount */
         0x8, /* gcFEATURE_VALUE_VertexCacheSize */
         0x1, /* gcFEATURE_VALUE_NumShaderCores */
         0x1, /* gcFEATURE_VALUE_NumPixelPipes */
@@ -10190,8 +10190,8 @@
         0x7, /* PatchVersion */
         0x0, /* FormalRelease */
         0x4, /* gcFEATURE_VALUE_Streams */
-        0x20, /* gcFEATURE_VALUE_TempRegisters */
-        0x40, /* gcFEATURE_VALUE_ThreadCount */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x80, /* gcFEATURE_VALUE_ThreadCount */
         0x8, /* gcFEATURE_VALUE_VertexCacheSize */
         0x1, /* gcFEATURE_VALUE_NumShaderCores */
         0x1, /* gcFEATURE_VALUE_NumPixelPipes */
@@ -10650,8 +10650,8 @@
         0x7, /* PatchVersion */
         0x1, /* FormalRelease */
         0x4, /* gcFEATURE_VALUE_Streams */
-        0x20, /* gcFEATURE_VALUE_TempRegisters */
-        0x40, /* gcFEATURE_VALUE_ThreadCount */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x80, /* gcFEATURE_VALUE_ThreadCount */
         0x8, /* gcFEATURE_VALUE_VertexCacheSize */
         0x1, /* gcFEATURE_VALUE_NumShaderCores */
         0x1, /* gcFEATURE_VALUE_NumPixelPipes */
@@ -11110,8 +11110,8 @@
         0x9, /* PatchVersion */
         0x1, /* FormalRelease */
         0x4, /* gcFEATURE_VALUE_Streams */
-        0x20, /* gcFEATURE_VALUE_TempRegisters */
-        0x40, /* gcFEATURE_VALUE_ThreadCount */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x80, /* gcFEATURE_VALUE_ThreadCount */
         0x8, /* gcFEATURE_VALUE_VertexCacheSize */
         0x1, /* gcFEATURE_VALUE_NumShaderCores */
         0x1, /* gcFEATURE_VALUE_NumPixelPipes */
@@ -49321,7 +49321,7 @@
         0x100, /* gcFEATURE_VALUE_VIP_SRAM_SIZE */
         0x2, /* gcFEATURE_VALUE_TPEngine_CoreCount */
         0x400, /* gcFEATURE_VALUE_AXI_SRAM_SIZE */
-        0x3, /* gcFEATURE_VALUE_NN_INIMAGE_OFFSET_BITS */
+        0x4, /* gcFEATURE_VALUE_NN_INIMAGE_OFFSET_BITS */
         0x1, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -68189,3 +68189,5 @@
     return gcvNULL;
 }
 #endif /* _gc_feature_database_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index 6cde22d..3438052 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -76,18 +76,18 @@
 
 /* Alignment with a non-power of two value. */
 #define gcmALIGN_NP2(n, align) \
-( \
+(\
     ((n) + (align) - 1) - (((n) + (align) - 1) % (align)) \
 )
 
 /* Alignment with a power of two value. */
 #define gcmALIGN(n, align) \
-( \
+(\
     ((n) + ((align) - 1)) & ~((align) - 1) \
 )
 
 #define gcmALIGN_BASE(n, align) \
-( \
+(\
     ((n) & ~((align) - 1)) \
 )
 
@@ -96,12 +96,12 @@
 \******************************************************************************/
 
 #define gcmSIZEOF(a) \
-( \
+(\
     (gctSIZE_T) (sizeof(a)) \
 )
 
 #define gcmCOUNTOF(a) \
-( \
+(\
     sizeof(a) / sizeof(a[0]) \
 )
 
@@ -118,22 +118,22 @@
         gckKERNEL_DeleteName(kernel, gcmALL_TO_UINT32(na))
 
 #define gcmALL_TO_UINT32(t) \
-( \
+(\
     (gctUINT32) (gctUINTPTR_T) (t)\
 )
 
 #define gcmPTR_TO_UINT64(p) \
-( \
+(\
     (gctUINT64) (gctUINTPTR_T) (p)\
 )
 
 #define gcmUINT64_TO_PTR(u) \
-( \
+(\
     (gctPOINTER) (gctUINTPTR_T) (u)\
 )
 
 #define gcmUINT64_TO_TYPE(u, t) \
-( \
+(\
     (t) (gctUINTPTR_T) (u)\
 )
 
@@ -457,6 +457,7 @@
 gckOS_AllocateNonPagedMemory(
     IN gckOS Os,
     IN gctBOOL InUserSpace,
+    IN gctUINT32 Flag,
     IN OUT gctSIZE_T * Bytes,
     OUT gctPHYS_ADDR * Physical,
     OUT gctPOINTER * Logical
@@ -573,6 +574,20 @@
     IN gctUINT32 Data
     );
 
+#ifdef __QNXNTO__
+static gcmINLINE gceSTATUS
+gckOS_WriteMemory(
+    IN gckOS Os,
+    IN gctPOINTER Address,
+    IN gctUINT32 Data
+    )
+{
+    /* Write memory. */
+    *(gctUINT32 *)Address = Data;
+    return gcvSTATUS_OK;
+}
+
+#else
 /* Write data to a 32-bit memory location. */
 gceSTATUS
 gckOS_WriteMemory(
@@ -580,6 +595,7 @@
     IN gctPOINTER Address,
     IN gctUINT32 Data
     );
+#endif
 
 /* Map physical memory into the process space. */
 gceSTATUS
@@ -1813,9 +1829,9 @@
 gckKERNEL_QueryVidMemPoolNodes(
     gckKERNEL            Kernel,
     gcePOOL              Pool,
-    gctUINT32          * TotalSize,     /* sum of the sizes of the contiguous blocks (i.e. total memory used at current time) : to be filled by the called function */
-    gcsContiguousBlock * MemoryBlocks,  /* previously allocated by the calling function : to be filled by the called function */
-    gctUINT32            NumMaxBlocks,  /* provided by the calling function */
+    gctUINT32          * TotalSize, /* sum of the sizes of the contiguous blocks (i.e. total memory used at current time) : to be filled by the called function */
+    gcsContiguousBlock * MemoryBlocks, /* previously allocated by the calling function : to be filled by the called function */
+    gctUINT32            NumMaxBlocks, /* provided by the calling function */
     gctUINT32          * NumBlocks      /* actual number of contiguous blocks : to be filled by the called function */
     );
 
@@ -2825,3 +2841,5 @@ typedef gceSTATUS (* gctINTERRUPT_HANDLER)(
 #endif
 
 #endif /* __gc_hal_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index 3c4897c..bf7a264 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -119,7 +119,7 @@
 { \
     if(Obj->sharedLock != gcvNULL)\
     {\
-        (gcoOS_AcquireMutex( \
+        (gcoOS_AcquireMutex(\
                      gcvNULL, Obj->sharedLock, gcvINFINITE));\
     }\
 }
@@ -145,85 +145,88 @@
 #if gcdSYNC
 #define gcPLS_INITIALIZER \
 { \
-    gcvNULL,         /* gcoOS object.      */ \
-    gcvNULL,         /* gcoHAL object.     */ \
-    0,               /* internalSize       */ \
-    gcvNULL,         /* internalPhysical   */ \
-    gcvNULL,         /* internalLogical    */ \
-    0,               /* externalSize       */ \
-    gcvNULL,         /* externalPhysical   */ \
-    gcvNULL,         /* externalLogical    */ \
-    0,               /* contiguousSize     */ \
-    gcvNULL,         /* contiguousPhysical */ \
-    gcvNULL,         /* contiguousLogical  */ \
-    gcvNULL,         /* eglDisplayInfo     */ \
-    gcvNULL,         /* eglSurfaceInfo     */ \
+    gcvNULL, /* gcoOS object.      */ \
+    gcvNULL, /* gcoHAL object.     */ \
+    0, /* internalSize       */ \
+    gcvNULL, /* internalPhysical   */ \
+    gcvNULL, /* internalLogical    */ \
+    0, /* externalSize       */ \
+    gcvNULL, /* externalPhysical   */ \
+    gcvNULL, /* externalLogical    */ \
+    0, /* contiguousSize     */ \
+    gcvNULL, /* contiguousPhysical */ \
+    gcvNULL, /* contiguousLogical  */ \
+    gcvNULL, /* eglDisplayInfo     */ \
+    gcvNULL, /* eglSurfaceInfo     */ \
     gcvSURF_A8R8G8B8,/* eglConfigFormat    */ \
-    gcvNULL,         /* reference          */ \
-    0,               /* processID          */ \
-    0,               /* threadID           */ \
-    gcvFALSE,        /* exiting            */ \
-    gcvFALSE,        /* Special flag for NP2 texture. */ \
-    gcvNULL,         /* destructor         */ \
-    gcvNULL,         /* accessLock         */ \
-    gcvNULL,         /* GL FE compiler lock*/ \
-    gcvNULL,         /* CL FE compiler lock*/ \
+    gcvNULL, /* reference          */ \
+    0, /* processID          */ \
+    0, /* threadID           */ \
+    gcvFALSE, /* exiting            */ \
+    gcvFALSE, /* Special flag for NP2 texture. */ \
+    gcvFALSE, /* device open.       */ \
+    gcvNULL, /* destructor         */ \
+    gcvNULL, /* accessLock         */ \
+    gcvNULL, /* GL FE compiler lock*/ \
+    gcvNULL, /* CL FE compiler lock*/ \
     gcvPATCH_NOTINIT,/* global patchID     */ \
-    gcvNULL,         /* global fenceID*/ \
+    gcvNULL, /* global fenceID*/ \
 }
 #else
 #define gcPLS_INITIALIZER \
 { \
-    gcvNULL,         /* gcoOS object.      */ \
-    gcvNULL,         /* gcoHAL object.     */ \
-    0,               /* internalSize       */ \
-    gcvNULL,         /* internalPhysical   */ \
-    gcvNULL,         /* internalLogical    */ \
-    0,               /* externalSize       */ \
-    gcvNULL,         /* externalPhysical   */ \
-    gcvNULL,         /* externalLogical    */ \
-    0,               /* contiguousSize     */ \
-    gcvNULL,         /* contiguousPhysical */ \
-    gcvNULL,         /* contiguousLogical  */ \
-    gcvNULL,         /* eglDisplayInfo     */ \
-    gcvNULL,         /* eglSurfaceInfo     */ \
+    gcvNULL, /* gcoOS object.      */ \
+    gcvNULL, /* gcoHAL object.     */ \
+    0, /* internalSize       */ \
+    gcvNULL, /* internalPhysical   */ \
+    gcvNULL, /* internalLogical    */ \
+    0, /* externalSize       */ \
+    gcvNULL, /* externalPhysical   */ \
+    gcvNULL, /* externalLogical    */ \
+    0, /* contiguousSize     */ \
+    gcvNULL, /* contiguousPhysical */ \
+    gcvNULL, /* contiguousLogical  */ \
+    gcvNULL, /* eglDisplayInfo     */ \
+    gcvNULL, /* eglSurfaceInfo     */ \
     gcvSURF_A8R8G8B8,/* eglConfigFormat    */ \
-    gcvNULL,         /* reference          */ \
-    0,               /* processID          */ \
-    0,               /* threadID           */ \
-    gcvFALSE,        /* exiting            */ \
-    gcvFALSE,        /* Special flag for NP2 texture. */ \
-    gcvNULL,         /* destructor         */ \
-    gcvNULL,         /* accessLock         */ \
-    gcvNULL,         /* GL FE compiler lock*/ \
-    gcvNULL,         /* CL FE compiler lock*/ \
+    gcvNULL, /* reference          */ \
+    0, /* processID          */ \
+    0, /* threadID           */ \
+    gcvFALSE, /* exiting            */ \
+    gcvFALSE, /* Special flag for NP2 texture. */ \
+    gcvFALSE, /* device open.       */ \
+    gcvNULL, /* destructor         */ \
+    gcvNULL, /* accessLock         */ \
+    gcvNULL, /* GL FE compiler lock*/ \
+    gcvNULL, /* CL FE compiler lock*/ \
     gcvPATCH_NOTINIT,/* global patchID     */ \
 }
 #endif
 #else
 #define gcPLS_INITIALIZER \
 { \
-    gcvNULL,         /* gcoOS object.      */ \
-    gcvNULL,         /* gcoHAL object.     */ \
-    0,               /* internalSize       */ \
-    gcvNULL,         /* internalPhysical   */ \
-    gcvNULL,         /* internalLogical    */ \
-    0,               /* externalSize       */ \
-    gcvNULL,         /* externalPhysical   */ \
-    gcvNULL,         /* externalLogical    */ \
-    0,               /* contiguousSize     */ \
-    gcvNULL,         /* contiguousPhysical */ \
-    gcvNULL,         /* contiguousLogical  */ \
-    gcvNULL,         /* eglDisplayInfo     */ \
-    gcvNULL,         /* eglSurfaceInfo     */ \
+    gcvNULL, /* gcoOS object.      */ \
+    gcvNULL, /* gcoHAL object.     */ \
+    0, /* internalSize       */ \
+    gcvNULL, /* internalPhysical   */ \
+    gcvNULL, /* internalLogical    */ \
+    0, /* externalSize       */ \
+    gcvNULL, /* externalPhysical   */ \
+    gcvNULL, /* externalLogical    */ \
+    0, /* contiguousSize     */ \
+    gcvNULL, /* contiguousPhysical */ \
+    gcvNULL, /* contiguousLogical  */ \
+    gcvNULL, /* eglDisplayInfo     */ \
+    gcvNULL, /* eglSurfaceInfo     */ \
     gcvSURF_A8R8G8B8,/* eglConfigFormat    */ \
-    gcvNULL,         /* reference          */ \
-    0,               /* processID          */ \
-    0,               /* threadID           */ \
-    gcvFALSE,        /* exiting            */ \
-    gcvFALSE,        /* Special flag for NP2 texture. */ \
-    gcvNULL,         /* destructor        */ \
-    gcvNULL,         /* accessLock        */ \
+    gcvNULL, /* reference          */ \
+    0, /* processID          */ \
+    0, /* threadID           */ \
+    gcvFALSE, /* exiting            */ \
+    gcvFALSE, /* Special flag for NP2 texture. */ \
+    gcvFALSE, /* device open.       */ \
+    gcvNULL, /* destructor        */ \
+    gcvNULL, /* accessLock        */ \
 }
 #endif
 
@@ -2352,6 +2355,9 @@ gceSTATUS gcoOS_HexStrToInt(
     /* sRGB format. */
     gctBOOL                     sRGB;
 
+    /* How GPU read from big-endian host memory */
+    gceENDIAN_HINT              endian;
+
     /* Format components. */
     gcuPIXEL_FORMAT_CLASS       u;
 
@@ -2440,7 +2446,10 @@ gceSTATUS gcoOS_HexStrToInt(
     IN gcoSURF Surface,
     OUT gctUINT32 * Node,
     OUT gcePOOL * Pool,
-    OUT gctSIZE_T_PTR Bytes
+    OUT gctSIZE_T_PTR Bytes,
+    OUT gctUINT32 * TsNode,
+    OUT gcePOOL * TsPool,
+    OUT gctSIZE_T_PTR TsBytes
     );
 
 /* Set the color type of the surface. */
@@ -2946,6 +2955,12 @@ gceSTATUS gcoOS_HexStrToInt(
     OUT gcoSURF * Surface
     );
 
+gceSTATUS
+gcoSURF_UpdateMetadata(
+    IN gcoSURF Surface,
+    IN gctINT TsFD
+    );
+
 #define MAX_SURF_MIX_SRC_NUM 64
 gceSTATUS
 gcoSURF_MixSurfacesCPU(
@@ -4609,7 +4624,7 @@ gceSTATUS gcoOS_HexStrToInt(
             gcoOS_Verify(verifyStatus); \
             if (verifyStatus != gcvSTATUS_OK) \
             { \
-                gcmTRACE( \
+                gcmTRACE(\
                     gcvLEVEL_ERROR, \
                     "gcmVERIFY_OK(%d): function returned %d", \
                     __LINE__, verifyStatus \
@@ -4624,7 +4639,7 @@ gceSTATUS gcoOS_HexStrToInt(
             gceSTATUS verifyStatus = func; \
             if (verifyStatus != gcvSTATUS_OK) \
             { \
-                gcmkTRACE( \
+                gcmkTRACE(\
                     gcvLEVEL_ERROR, \
                     "gcmkVERIFY_OK(%d): function returned %d", \
                     __LINE__, verifyStatus \
@@ -5137,7 +5152,7 @@ gceSTATUS gcoOS_HexStrToInt(
         CommandBuffer->lastLoadStateCount   = Count
 
 #   define gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address) \
-        gcmASSERT( \
+        gcmASSERT(\
             (gctUINT) (Memory  - gcmUINT64_TO_TYPE(CommandBuffer->lastLoadStatePtr, gctUINT32_PTR) - 1) \
             == \
             (gctUINT) (Address - CommandBuffer->lastLoadStateAddress) \
@@ -5246,7 +5261,7 @@ gceSTATUS gcoOS_HexStrToInt(
 
 #define gcmBEGINSTATEBUFFER(Hardware, CommandBuffer, StateDelta, Memory, ReserveSize) \
 { \
-    gcmONERROR(gcoBUFFER_Reserve( \
+    gcmONERROR(gcoBUFFER_Reserve(\
         Hardware->engine[CurrentEngine].buffer, ReserveSize, gcvTRUE, gcvCOMMAND_3D, &CommandBuffer \
         )); \
     \
@@ -5261,7 +5276,7 @@ gceSTATUS gcoOS_HexStrToInt(
 { \
     gcmENDSECUREUSER(); \
     \
-    gcmASSERT( \
+    gcmASSERT(\
         gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT8_PTR) + ReserveSize \
         == \
          (gctUINT8_PTR) Memory \
@@ -5280,9 +5295,9 @@ gceSTATUS gcoOS_HexStrToInt(
     gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count); \
     \
     *Memory++ \
-        = gcmSETFIELDVALUE(0, AQ_COMMAND_LOAD_STATE_COMMAND, OPCODE,  LOAD_STATE) \
-        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, FLOAT,   FixedPoint) \
-        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, COUNT,   Count) \
+        = gcmSETFIELDVALUE(0, AQ_COMMAND_LOAD_STATE_COMMAND, OPCODE, LOAD_STATE) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, FLOAT, FixedPoint) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, COUNT, Count) \
         | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, ADDRESS, Address); \
     \
     gcmSKIPSECUREUSER(); \
@@ -5308,7 +5323,7 @@ gceSTATUS gcoOS_HexStrToInt(
     \
     *Memory++ = __temp_data32__; \
     \
-    gcoHARDWARE_UpdateDelta( \
+    gcoHARDWARE_UpdateDelta(\
         StateDelta, Address, 0, __temp_data32__ \
         ); \
     \
@@ -5328,7 +5343,7 @@ gceSTATUS gcoOS_HexStrToInt(
     \
     *Memory++ = __temp_data32__; \
     \
-    gcoHARDWARE_UpdateDelta( \
+    gcoHARDWARE_UpdateDelta(\
         StateDelta, Address, Mask, __temp_data32__ \
         ); \
     \
@@ -5395,7 +5410,7 @@ gceSTATUS gcoOS_HexStrToInt(
 
 #define gcmSETSEMASTALLPIPE(StateDelta, CommandBuffer, Memory, Data) \
 { \
-    gcmSETSINGLECTRLSTATE(StateDelta, CommandBuffer, Memory, gcvFALSE, AQSemaphoreRegAddrs, Data); \
+    gcmSETSINGLECTRLSTATE(StateDelta, CommandBuffer, Memory, gcvFALSE, 0x0E02, Data); \
     \
     *Memory++ = gcmSETFIELDVALUE(0, STALL_COMMAND, OPCODE, STALL); \
     \
@@ -5423,8 +5438,8 @@ gceSTATUS gcoOS_HexStrToInt(
 #define gcmSETSTARTDECOMMAND(Memory, Count) \
 { \
     *Memory++ \
-        = gcmSETFIELDVALUE(0, AQ_COMMAND_START_DE_COMMAND, OPCODE,     START_DE) \
-        | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, COUNT,      Count) \
+        = gcmSETFIELDVALUE(0, AQ_COMMAND_START_DE_COMMAND, OPCODE, START_DE) \
+        | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, COUNT, Count) \
         | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, DATA_COUNT, 0); \
     \
     *Memory++ = 0xDEADDEED; \
@@ -5450,7 +5465,7 @@ gceSTATUS gcoOS_HexStrToInt(
     }\
     else \
     {\
-        gcmONERROR(gcoBUFFER_StartTEMPCMDBUF( \
+        gcmONERROR(gcoBUFFER_StartTEMPCMDBUF(\
             Hardware->engine[CurrentEngine].buffer, &CommandBuffer \
             ));\
         \
@@ -5496,7 +5511,7 @@ gceSTATUS gcoOS_HexStrToInt(
     }                                                                           \
     else                                                                        \
     {                                                                           \
-        gcmONERROR(gcoBUFFER_StartTEMPCMDBUF(                                   \
+        gcmONERROR(gcoBUFFER_StartTEMPCMDBUF(\
             Hardware->engine[CurrentEngine].buffer, &CommandBuffer              \
             ));                                                                 \
                                                                                 \
@@ -5514,9 +5529,9 @@ gceSTATUS gcoOS_HexStrToInt(
     gcmASSERT((gctUINT32)Count <= 1024); \
     \
     *Memory++ \
-        = gcmSETFIELDVALUE(0, AQ_COMMAND_LOAD_STATE_COMMAND, OPCODE,  LOAD_STATE) \
-        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, FLOAT,   FixedPoint) \
-        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, COUNT,   Count) \
+        = gcmSETFIELDVALUE(0, AQ_COMMAND_LOAD_STATE_COMMAND, OPCODE, LOAD_STATE) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, FLOAT, FixedPoint) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, COUNT, Count) \
         | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, ADDRESS, Address); \
     \
     gcmSKIPSECUREUSER(); \
@@ -5536,7 +5551,7 @@ gceSTATUS gcoOS_HexStrToInt(
     \
     *Memory++ = __temp_data32__; \
     \
-    gcoHARDWARE_UpdateDelta( \
+    gcoHARDWARE_UpdateDelta(\
         StateDelta, Address, 0, __temp_data32__ \
         ); \
     \
@@ -5554,7 +5569,7 @@ gceSTATUS gcoOS_HexStrToInt(
     \
     *Memory++ = __temp_data32__; \
     \
-    gcoHARDWARE_UpdateDelta( \
+    gcoHARDWARE_UpdateDelta(\
         StateDelta, Address, Mask, __temp_data32__ \
         ); \
     \
@@ -5617,7 +5632,7 @@ gceSTATUS gcoOS_HexStrToInt(
 
 #define gcmSETSEMASTALLPIPE_NEW(StateDelta, CommandBuffer, Memory, Data) \
 { \
-    gcmSETSINGLECTRLSTATE_NEW(StateDelta, CommandBuffer, Memory, gcvFALSE, AQSemaphoreRegAddrs, Data); \
+    gcmSETSINGLECTRLSTATE_NEW(StateDelta, CommandBuffer, Memory, gcvFALSE, 0x0E02, Data); \
     \
     *Memory++ = gcmSETFIELDVALUE(0, STALL_COMMAND, OPCODE, STALL); \
     \
@@ -5633,8 +5648,8 @@ gceSTATUS gcoOS_HexStrToInt(
 #define gcmSETSTARTDECOMMAND_NEW(CommandBuffer, Memory, Count) \
 { \
     *Memory++ \
-        = gcmSETFIELDVALUE(0, AQ_COMMAND_START_DE_COMMAND, OPCODE,     START_DE) \
-        | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, COUNT,      Count) \
+        = gcmSETFIELDVALUE(0, AQ_COMMAND_START_DE_COMMAND, OPCODE, START_DE) \
+        | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, COUNT, Count) \
         | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, DATA_COUNT, 0); \
     \
     *Memory++ = 0xDEADDEED; \
@@ -5751,7 +5766,7 @@ gceSTATUS gcoOS_HexStrToInt(
 
 #define gcmBEGINSTATEBUFFER_FAST(Hardware, CommandBuffer, Memory, ReserveSize) \
 { \
-    gcmONERROR(gcoBUFFER_Reserve( \
+    gcmONERROR(gcoBUFFER_Reserve(\
     Hardware->engine[gcvENGINE_RENDER].buffer, ReserveSize, gcvTRUE, &CommandBuffer \
         )); \
     \
@@ -5768,7 +5783,7 @@ gceSTATUS gcoOS_HexStrToInt(
     }\
     else \
     {\
-        gcmONERROR(gcoBUFFER_StartTEMPCMDBUF( \
+        gcmONERROR(gcoBUFFER_StartTEMPCMDBUF(\
             Hardware->engine[gcvENGINE_RENDER].buffer, &CommandBuffer \
             ));\
         \
@@ -5811,8 +5826,8 @@ gceSTATUS gcoOS_HexStrToInt(
     if (ChipModel == gcv2000 && (ChipRevision == 0x5118 || ChipRevision == 0x5140)) \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 256; \
         PsConstMax   = 64; \
         ConstMax     = 320; \
@@ -5820,8 +5835,8 @@ gceSTATUS gcoOS_HexStrToInt(
     else if (NumConstants == 320) \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 256; \
         PsConstMax   = 64; \
         ConstMax     = 320; \
@@ -5830,8 +5845,8 @@ gceSTATUS gcoOS_HexStrToInt(
     else if (NumConstants > 256 && ChipModel == gcv1000) \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 256; \
         PsConstMax   = 64; \
         ConstMax     = 320; \
@@ -5839,8 +5854,8 @@ gceSTATUS gcoOS_HexStrToInt(
     else if (NumConstants > 256) \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 256; \
         PsConstMax   = 256; \
         ConstMax     = 512; \
@@ -5848,8 +5863,8 @@ gceSTATUS gcoOS_HexStrToInt(
     else if (NumConstants == 256) \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 256; \
         PsConstMax   = 256; \
         ConstMax     = 512; \
@@ -5857,8 +5872,8 @@ gceSTATUS gcoOS_HexStrToInt(
     else \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 168; \
         PsConstMax   = 64; \
         ConstMax     = 232; \
@@ -5873,13 +5888,13 @@ gceSTATUS gcoOS_HexStrToInt(
         UnifiedConst = gcvTRUE; \
         if (Halti5Avail) \
         { \
-            VsConstBase  = gcregGpipeUniformsRegAddrs; \
-            PsConstBase  = gcregPixelUniformsRegAddrs; \
+            VsConstBase  = 0xD000; \
+            PsConstBase  = 0xD800; \
         } \
         else \
         {\
-            VsConstBase  = gcregSHUniformsRegAddrs; \
-            PsConstBase  = gcregSHUniformsRegAddrs; \
+            VsConstBase  = 0xC000; \
+            PsConstBase  = 0xC000; \
         }\
         if ((ChipModel == gcv880) && ((ChipRevision & 0xfff0) == 0x5120)) \
         { \
@@ -5899,8 +5914,8 @@ gceSTATUS gcoOS_HexStrToInt(
         if (ChipModel == gcv2000 && (ChipRevision == 0x5118 || ChipRevision == 0x5140)) \
         { \
             UnifiedConst = gcvFALSE; \
-            VsConstBase  = AQVertexShaderConstRegAddrs; \
-            PsConstBase  = AQPixelShaderConstRegAddrs; \
+            VsConstBase  = 0x1400; \
+            PsConstBase  = 0x1C00; \
             VsConstMax   = 256; \
             PsConstMax   = 64; \
             ConstMax     = 320; \
@@ -5908,8 +5923,8 @@ gceSTATUS gcoOS_HexStrToInt(
         else \
         { \
             UnifiedConst = gcvFALSE; \
-            VsConstBase  = AQVertexShaderConstRegAddrs; \
-            PsConstBase  = AQPixelShaderConstRegAddrs; \
+            VsConstBase  = 0x1400; \
+            PsConstBase  = 0x1C00; \
             VsConstMax   = 256; \
             PsConstMax   = 256; \
             ConstMax     = 512; \
@@ -5918,8 +5933,8 @@ gceSTATUS gcoOS_HexStrToInt(
     else \
     { \
         UnifiedConst = gcvFALSE; \
-        VsConstBase  = AQVertexShaderConstRegAddrs; \
-        PsConstBase  = AQPixelShaderConstRegAddrs; \
+        VsConstBase  = 0x1400; \
+        PsConstBase  = 0x1C00; \
         VsConstMax   = 168; \
         PsConstMax   = 64; \
         ConstMax     = 232; \
@@ -6001,3 +6016,5 @@ gceSTATUS gcoOS_HexStrToInt(
 #endif
 
 #endif /* __gc_hal_base_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index 69ffbc4..cf5267f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -86,6 +86,7 @@
     /* Generic query. */
     gcvHAL_QUERY_VIDEO_MEMORY,
     gcvHAL_QUERY_CHIP_IDENTITY,
+    gcvHAL_QUERY_CHIP_FREQUENCY,
 
     /* Contiguous memory. */
     gcvHAL_ALLOCATE_NON_PAGED_MEMORY,
@@ -94,8 +95,8 @@
     gcvHAL_FREE_CONTIGUOUS_MEMORY,
 
     /* Video memory allocation. */
-    gcvHAL_ALLOCATE_VIDEO_MEMORY,           /* Enforced alignment. */
-    gcvHAL_ALLOCATE_LINEAR_VIDEO_MEMORY,    /* No alignment. */
+    gcvHAL_ALLOCATE_VIDEO_MEMORY, /* Enforced alignment. */
+    gcvHAL_ALLOCATE_LINEAR_VIDEO_MEMORY, /* No alignment. */
     gcvHAL_RELEASE_VIDEO_MEMORY,
 
     /* Physical-to-logical mapping. */
@@ -226,6 +227,7 @@
      */
     gcvHAL_GET_GRAPHIC_BUFFER_FD,
 
+
     gcvHAL_SET_VIDEO_MEMORY_METADATA,
 
     /* Connect a video node to an OS native fd. */
@@ -455,6 +457,13 @@
         /* gcvHAL_QUERY_CHIP_IDENTITY */
         gcsHAL_QUERY_CHIP_IDENTITY      QueryChipIdentity;
 
+        struct _gcsHAL_QUERY_CHIP_FREQUENCY
+        {
+            OUT gctUINT32               mcClk;
+            OUT gctUINT32               shClk;
+        }
+        QueryChipFrequency;
+
         /* gcvHAL_MAP_MEMORY */
         struct _gcsHAL_MAP_MEMORY
         {
@@ -1244,6 +1253,7 @@
         }
         GetGraphicBufferFd;
 
+
         struct _gcsHAL_VIDEO_MEMORY_METADATA
         {
             /* Allocated video memory. */
@@ -1363,3 +1373,5 @@
 #endif
 
 #endif /* __gc_hal_driver_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
index 9dc4afd..4fd5d01 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
@@ -298,3 +298,5 @@
 #endif
 
 #endif /* __gc_hal_driver_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_drm.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_drm.h
index cb59f81..97ba6f8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_drm.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_drm.h
@@ -52,7 +52,6 @@
 *
 *****************************************************************************/
 
-
 #ifndef __VIVNATE_DRM_H__
 #define __VIVNATE_DRM_H__
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
index aad72e7..b8c9ffa 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
@@ -121,3 +121,5 @@
 
 #endif /* __gc_hal_dump_h_ */
 
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
index 1dbdd4c..7d2a6fa 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
@@ -585,3 +585,5 @@
 
 #endif /* __gc_hal_eglplatform_h_ */
 
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
index a86708e..c35cab5 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
@@ -322,3 +322,5 @@
 #endif
 
 #endif /* __gc_hal_eglplatform_type_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index 531cb4c..7a20987 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -2968,3 +2968,5 @@ typedef gceSTATUS (* gctSPLIT_DRAW_FUNC_PTR)(
 #endif
 
 #endif /* __gc_hal_engine_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
index 13c79c5..9bbbe05 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
@@ -136,33 +136,33 @@
 */
 typedef enum _gceVGCMD
 {
-    gcvVGCMD_END,                        /*  0: GCCMD_TS_OPCODE_END           */
-    gcvVGCMD_CLOSE,                      /*  1: GCCMD_TS_OPCODE_CLOSE         */
-    gcvVGCMD_MOVE,                       /*  2: GCCMD_TS_OPCODE_MOVE          */
-    gcvVGCMD_MOVE_REL,                   /*  3: GCCMD_TS_OPCODE_MOVE_REL      */
-    gcvVGCMD_LINE,                       /*  4: GCCMD_TS_OPCODE_LINE          */
-    gcvVGCMD_LINE_REL,                   /*  5: GCCMD_TS_OPCODE_LINE_REL      */
-    gcvVGCMD_QUAD,                       /*  6: GCCMD_TS_OPCODE_QUADRATIC     */
-    gcvVGCMD_QUAD_REL,                   /*  7: GCCMD_TS_OPCODE_QUADRATIC_REL */
-    gcvVGCMD_CUBIC,                      /*  8: GCCMD_TS_OPCODE_CUBIC         */
-    gcvVGCMD_CUBIC_REL,                  /*  9: GCCMD_TS_OPCODE_CUBIC_REL     */
-    gcvVGCMD_BREAK,                      /* 10: GCCMD_TS_OPCODE_BREAK         */
-    gcvVGCMD_HLINE,                      /* 11: ******* R E S E R V E D *******/
-    gcvVGCMD_HLINE_REL,                  /* 12: ******* R E S E R V E D *******/
-    gcvVGCMD_VLINE,                      /* 13: ******* R E S E R V E D *******/
-    gcvVGCMD_VLINE_REL,                  /* 14: ******* R E S E R V E D *******/
-    gcvVGCMD_SQUAD,                      /* 15: ******* R E S E R V E D *******/
-    gcvVGCMD_SQUAD_REL,                  /* 16: ******* R E S E R V E D *******/
-    gcvVGCMD_SCUBIC,                     /* 17: ******* R E S E R V E D *******/
-    gcvVGCMD_SCUBIC_REL,                 /* 18: ******* R E S E R V E D *******/
-    gcvVGCMD_SCCWARC,                    /* 19: ******* R E S E R V E D *******/
-    gcvVGCMD_SCCWARC_REL,                /* 20: ******* R E S E R V E D *******/
-    gcvVGCMD_SCWARC,                     /* 21: ******* R E S E R V E D *******/
-    gcvVGCMD_SCWARC_REL,                 /* 22: ******* R E S E R V E D *******/
-    gcvVGCMD_LCCWARC,                    /* 23: ******* R E S E R V E D *******/
-    gcvVGCMD_LCCWARC_REL,                /* 24: ******* R E S E R V E D *******/
-    gcvVGCMD_LCWARC,                     /* 25: ******* R E S E R V E D *******/
-    gcvVGCMD_LCWARC_REL,                 /* 26: ******* R E S E R V E D *******/
+    gcvVGCMD_END, /*  0: 0x00           */
+    gcvVGCMD_CLOSE, /*  1: 0x01         */
+    gcvVGCMD_MOVE, /*  2: 0x02          */
+    gcvVGCMD_MOVE_REL, /*  3: 0x03      */
+    gcvVGCMD_LINE, /*  4: 0x04          */
+    gcvVGCMD_LINE_REL, /*  5: 0x05      */
+    gcvVGCMD_QUAD, /*  6: 0x06     */
+    gcvVGCMD_QUAD_REL, /*  7: 0x07 */
+    gcvVGCMD_CUBIC, /*  8: 0x08         */
+    gcvVGCMD_CUBIC_REL, /*  9: 0x09     */
+    gcvVGCMD_BREAK, /* 10: 0x0A         */
+    gcvVGCMD_HLINE, /* 11: ******* R E S E R V E D *******/
+    gcvVGCMD_HLINE_REL, /* 12: ******* R E S E R V E D *******/
+    gcvVGCMD_VLINE, /* 13: ******* R E S E R V E D *******/
+    gcvVGCMD_VLINE_REL, /* 14: ******* R E S E R V E D *******/
+    gcvVGCMD_SQUAD, /* 15: ******* R E S E R V E D *******/
+    gcvVGCMD_SQUAD_REL, /* 16: ******* R E S E R V E D *******/
+    gcvVGCMD_SCUBIC, /* 17: ******* R E S E R V E D *******/
+    gcvVGCMD_SCUBIC_REL, /* 18: ******* R E S E R V E D *******/
+    gcvVGCMD_SCCWARC, /* 19: ******* R E S E R V E D *******/
+    gcvVGCMD_SCCWARC_REL, /* 20: ******* R E S E R V E D *******/
+    gcvVGCMD_SCWARC, /* 21: ******* R E S E R V E D *******/
+    gcvVGCMD_SCWARC_REL, /* 22: ******* R E S E R V E D *******/
+    gcvVGCMD_LCCWARC, /* 23: ******* R E S E R V E D *******/
+    gcvVGCMD_LCCWARC_REL, /* 24: ******* R E S E R V E D *******/
+    gcvVGCMD_LCWARC, /* 25: ******* R E S E R V E D *******/
+    gcvVGCMD_LCWARC_REL, /* 26: ******* R E S E R V E D *******/
 
     /* The width of the command recognized by the hardware on bits. */
     gcvVGCMD_WIDTH = 5,
@@ -171,27 +171,27 @@
     gcvVGCMD_MASK = (1 << gcvVGCMD_WIDTH) - 1,
 
     /* Command modifiers. */
-    gcvVGCMD_H_MOD   = 1 << gcvVGCMD_WIDTH,  /* =  32 */
-    gcvVGCMD_V_MOD   = 2 << gcvVGCMD_WIDTH,  /* =  64 */
-    gcvVGCMD_S_MOD   = 3 << gcvVGCMD_WIDTH,  /* =  96 */
-    gcvVGCMD_ARC_MOD = 4 << gcvVGCMD_WIDTH,  /* = 128 */
+    gcvVGCMD_H_MOD   = 1 << gcvVGCMD_WIDTH, /* =  32 */
+    gcvVGCMD_V_MOD   = 2 << gcvVGCMD_WIDTH, /* =  64 */
+    gcvVGCMD_S_MOD   = 3 << gcvVGCMD_WIDTH, /* =  96 */
+    gcvVGCMD_ARC_MOD = 4 << gcvVGCMD_WIDTH, /* = 128 */
 
     /* Emulated LINE commands. */
-    gcvVGCMD_HLINE_EMUL     = gcvVGCMD_H_MOD | gcvVGCMD_LINE,        /* =  36 */
-    gcvVGCMD_HLINE_EMUL_REL = gcvVGCMD_H_MOD | gcvVGCMD_LINE_REL,    /* =  37 */
-    gcvVGCMD_VLINE_EMUL     = gcvVGCMD_V_MOD | gcvVGCMD_LINE,        /* =  68 */
-    gcvVGCMD_VLINE_EMUL_REL = gcvVGCMD_V_MOD | gcvVGCMD_LINE_REL,    /* =  69 */
+    gcvVGCMD_HLINE_EMUL     = gcvVGCMD_H_MOD | gcvVGCMD_LINE, /* =  36 */
+    gcvVGCMD_HLINE_EMUL_REL = gcvVGCMD_H_MOD | gcvVGCMD_LINE_REL, /* =  37 */
+    gcvVGCMD_VLINE_EMUL     = gcvVGCMD_V_MOD | gcvVGCMD_LINE, /* =  68 */
+    gcvVGCMD_VLINE_EMUL_REL = gcvVGCMD_V_MOD | gcvVGCMD_LINE_REL, /* =  69 */
 
     /* Emulated SMOOTH commands. */
-    gcvVGCMD_SQUAD_EMUL      = gcvVGCMD_S_MOD | gcvVGCMD_QUAD,       /* = 102 */
-    gcvVGCMD_SQUAD_EMUL_REL  = gcvVGCMD_S_MOD | gcvVGCMD_QUAD_REL,   /* = 103 */
-    gcvVGCMD_SCUBIC_EMUL     = gcvVGCMD_S_MOD | gcvVGCMD_CUBIC,      /* = 104 */
-    gcvVGCMD_SCUBIC_EMUL_REL = gcvVGCMD_S_MOD | gcvVGCMD_CUBIC_REL,  /* = 105 */
+    gcvVGCMD_SQUAD_EMUL      = gcvVGCMD_S_MOD | gcvVGCMD_QUAD, /* = 102 */
+    gcvVGCMD_SQUAD_EMUL_REL  = gcvVGCMD_S_MOD | gcvVGCMD_QUAD_REL, /* = 103 */
+    gcvVGCMD_SCUBIC_EMUL     = gcvVGCMD_S_MOD | gcvVGCMD_CUBIC, /* = 104 */
+    gcvVGCMD_SCUBIC_EMUL_REL = gcvVGCMD_S_MOD | gcvVGCMD_CUBIC_REL, /* = 105 */
 
     /* Emulation ARC commands. */
-    gcvVGCMD_ARC_LINE     = gcvVGCMD_ARC_MOD | gcvVGCMD_LINE,        /* = 132 */
-    gcvVGCMD_ARC_LINE_REL = gcvVGCMD_ARC_MOD | gcvVGCMD_LINE_REL,    /* = 133 */
-    gcvVGCMD_ARC_QUAD     = gcvVGCMD_ARC_MOD | gcvVGCMD_QUAD,        /* = 134 */
+    gcvVGCMD_ARC_LINE     = gcvVGCMD_ARC_MOD | gcvVGCMD_LINE, /* = 132 */
+    gcvVGCMD_ARC_LINE_REL = gcvVGCMD_ARC_MOD | gcvVGCMD_LINE_REL, /* = 133 */
+    gcvVGCMD_ARC_QUAD     = gcvVGCMD_ARC_MOD | gcvVGCMD_QUAD, /* = 134 */
     gcvVGCMD_ARC_QUAD_REL = gcvVGCMD_ARC_MOD | gcvVGCMD_QUAD_REL     /* = 135 */
 }
 gceVGCMD;
@@ -774,7 +774,7 @@ gctUINT8 gcoVG_PackColorComponent(
 gcoVG_Destroy(
     IN gcoVG Vg
 #if gcdGC355_PROFILER
-    ,
+,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth
@@ -863,7 +863,7 @@ gctUINT8 gcoVG_PackColorComponent(
 gcoVG_FlushMask(
     IN gcoVG Vg
 #if gcdGC355_PROFILER
-    ,
+,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth
@@ -1316,3 +1316,5 @@ gctUINT8 gcoVG_PackColorComponent(
 #endif
 
 #endif  /* __gc_hal_vg_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index 5b5dfd5..168594b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -513,8 +513,9 @@
     gcvFEATURE_FENCE,
     gcvFEATURE_PE_DEPTH_ONLY_OQFIX,
     gcvFEATURE_VG_RESOLUTION_8K,
-    gcvFEATURE_IMAGE_LS_NO_FULLMASK_FIX, 
+    gcvFEATURE_IMAGE_LS_NO_FULLMASK_FIX,
     gcvFEATURE_PE_TILE_CACHE_FLUSH_FIX,
+
     /* Insert features above this comment only. */
     gcvFEATURE_COUNT                /* Not a feature. */
 }
@@ -618,9 +619,9 @@
 /* CPU cache operations */
 typedef enum _gceCACHEOPERATION
 {
-    gcvCACHE_CLEAN      = 0x01,     /* Flush CPU cache to mem */
-    gcvCACHE_INVALIDATE = 0x02,     /* Invalidte CPU cache */
-    gcvCACHE_FLUSH      = gcvCACHE_CLEAN  | gcvCACHE_INVALIDATE,    /* Both flush & invalidate */
+    gcvCACHE_CLEAN      = 0x01, /* Flush CPU cache to mem */
+    gcvCACHE_INVALIDATE = 0x02, /* Invalidte CPU cache */
+    gcvCACHE_FLUSH      = gcvCACHE_CLEAN  | gcvCACHE_INVALIDATE, /* Both flush & invalidate */
     gcvCACHE_MEMORY_BARRIER = 0x04
 }
 gceCACHEOPERATION;
@@ -647,23 +648,24 @@
     gcvSURF_NUM_TYPES, /* Make sure this is the last one! */
 
     /* Combinations. */
+    gcvSURF_CMA_LIMIT               = 0x80000000,
     gcvSURF_NO_TILE_STATUS          = 0x100,
-    gcvSURF_NO_VIDMEM               = 0x200,    /* Used to allocate surfaces with no underlying vidmem node.
+    gcvSURF_NO_VIDMEM               = 0x200, /* Used to allocate surfaces with no underlying vidmem node.
                                                    In Android, vidmem node is allocated by another process. */
-    gcvSURF_CACHEABLE               = 0x400,    /* Used to allocate a cacheable surface */
-    gcvSURF_TILE_RLV_FENCE          = 0x800,    /* create texture fence as tile */
-    gcvSURF_TILE_STATUS_DIRTY       = 0x1000,   /* Init tile status to all dirty */
+    gcvSURF_CACHEABLE               = 0x400, /* Used to allocate a cacheable surface */
+    gcvSURF_TILE_RLV_FENCE          = 0x800, /* create texture fence as tile */
+    gcvSURF_TILE_STATUS_DIRTY       = 0x1000, /* Init tile status to all dirty */
     gcvSURF_LINEAR                  = 0x2000,
-    gcvSURF_CREATE_AS_TEXTURE       = 0x4000,   /* create it as a texture */
-    gcvSURF_PROTECTED_CONTENT       = 0x8000,   /* create it as content protected */
-    gcvSURF_CREATE_AS_DISPLAYBUFFER = 0x10000,  /*create it as a display buffer surface */
-    gcvSURF_CONTIGUOUS              = 0x20000,  /*create it as contiguous */
-    gcvSURF_NO_COMPRESSION          = 0x40000,  /* Create it as no compression, valid on when it has tile status. */
-    gcvSURF_DEC                     = 0x80000,  /* Surface is DEC compressed */
+    gcvSURF_CREATE_AS_TEXTURE       = 0x4000, /* create it as a texture */
+    gcvSURF_PROTECTED_CONTENT       = 0x8000, /* create it as content protected */
+    gcvSURF_CREATE_AS_DISPLAYBUFFER = 0x10000, /*create it as a display buffer surface */
+    gcvSURF_CONTIGUOUS              = 0x20000, /*create it as contiguous */
+    gcvSURF_NO_COMPRESSION          = 0x40000, /* Create it as no compression, valid on when it has tile status. */
+    gcvSURF_DEC                     = 0x80000, /* Surface is DEC compressed */
     gcvSURF_NO_HZ                   = 0x100000,
     gcvSURF_3D                      = 0x200000, /* It's 3d surface */
     gcvSURF_DMABUF_EXPORTABLE       = 0x400000, /* master node can be exported as dma-buf fd */
-    gcvSURF_CMA_LIMIT               = 0x800000,
+    gcvSURF_CACHE_MODE_128          = 0x800000,
 
     gcvSURF_TEXTURE_LINEAR               = gcvSURF_TEXTURE
                                          | gcvSURF_LINEAR,
@@ -928,6 +930,8 @@
     gcvSURF_A12L12,
     gcvSURF_A16L16,
 
+    gcvSURF_A8L8_1_A8R8G8B8,
+
     /* Bump formats. */
     gcvSURF_L6V5U5              = 1000,
     gcvSURF_V8U8,
@@ -1290,21 +1294,21 @@
 {
     /* Porter-Duff blending modes.                   */
     /*                         Fsrc      Fdst        */
-    gcvBLEND_CLEAR = 0,     /* 0         0           */
-    gcvBLEND_SRC,           /* 1         0           */
-    gcvBLEND_DST,           /* 0         1           */
-    gcvBLEND_SRC_OVER_DST,  /* 1         1 - Asrc    */
-    gcvBLEND_DST_OVER_SRC,  /* 1 - Adst  1           */
-    gcvBLEND_SRC_IN_DST,    /* Adst      0           */
-    gcvBLEND_DST_IN_SRC,    /* 0         Asrc        */
-    gcvBLEND_SRC_OUT_DST,   /* 1 - Adst  0           */
-    gcvBLEND_DST_OUT_SRC,   /* 0         1 - Asrc    */
-    gcvBLEND_SRC_ATOP_DST,  /* Adst      1 - Asrc    */
-    gcvBLEND_DST_ATOP_SRC,  /* 1 - Adst  Asrc        */
-    gcvBLEND_SRC_XOR_DST,   /* 1 - Adst  1 - Asrc    */
+    gcvBLEND_CLEAR = 0, /* 0         0           */
+    gcvBLEND_SRC, /* 1         0           */
+    gcvBLEND_DST, /* 0         1           */
+    gcvBLEND_SRC_OVER_DST, /* 1         1 - Asrc    */
+    gcvBLEND_DST_OVER_SRC, /* 1 - Adst  1           */
+    gcvBLEND_SRC_IN_DST, /* Adst      0           */
+    gcvBLEND_DST_IN_SRC, /* 0         Asrc        */
+    gcvBLEND_SRC_OUT_DST, /* 1 - Adst  0           */
+    gcvBLEND_DST_OUT_SRC, /* 0         1 - Asrc    */
+    gcvBLEND_SRC_ATOP_DST, /* Adst      1 - Asrc    */
+    gcvBLEND_DST_ATOP_SRC, /* 1 - Adst  Asrc        */
+    gcvBLEND_SRC_XOR_DST, /* 1 - Adst  1 - Asrc    */
 
     /* Special blending modes.                       */
-    gcvBLEND_SET,           /* DST = 1               */
+    gcvBLEND_SET, /* DST = 1               */
     gcvBLEND_SUB            /* DST = DST * (1 - SRC) */
 }
 gceSURF_BLEND_MODE;
@@ -1574,21 +1578,22 @@
 /* Endian hints. */
 typedef enum _gceENDIAN_HINT
 {
-    gcvENDIAN_NO_SWAP = 0,
-    gcvENDIAN_SWAP_WORD,
-    gcvENDIAN_SWAP_DWORD
+    gcvENDIAN_NO_SWAP    = 0,
+    gcvENDIAN_SWAP_WORD  = 1,
+    gcvENDIAN_SWAP_DWORD = 2,
+    gcvENDIAN_SWAP_QWORD = 3,
 }
 gceENDIAN_HINT;
 
 /* Tiling modes. */
 typedef enum _gceTILING
 {
-    gcvINVALIDTILED = 0x0,        /* Invalid tiling */
+    gcvINVALIDTILED = 0x0, /* Invalid tiling */
     /* Tiling basic modes enum'ed in power of 2. */
-    gcvLINEAR      = 0x1,         /* No    tiling. */
-    gcvTILED       = 0x2,         /* 4x4   tiling. */
-    gcvSUPERTILED  = 0x4,         /* 64x64 tiling. */
-    gcvMINORTILED  = 0x8,         /* 2x2   tiling. */
+    gcvLINEAR      = 0x1, /* No    tiling. */
+    gcvTILED       = 0x2, /* 4x4   tiling. */
+    gcvSUPERTILED  = 0x4, /* 64x64 tiling. */
+    gcvMINORTILED  = 0x8, /* 2x2   tiling. */
 
     /* Tiling special layouts. */
     gcvTILING_SPLIT_BUFFER = 0x10,
@@ -2112,6 +2117,8 @@
 /* Can be exported as dmabuf-fd */
 #define gcvALLOC_FLAG_DMABUF_EXPORTABLE     0x00000010
 
+#define gcvALLOC_FLAG_4GB_ADDR              0x00000020
+
 /* Do not try slow pools (gcvPOOL_VIRTUAL/gcvPOOL_CONTIGUOUS) */
 #define gcvALLOC_FLAG_FAST_POOLS            0x00000100
 
@@ -2177,3 +2184,5 @@
 #endif
 
 #endif /* __gc_hal_enum_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
index 51a1d8d..0adf62f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
@@ -191,7 +191,7 @@
 #if USE_LOCAL_MEMORY_POOL
 #define gcmMEM_DeclareFSMemPool(Type, TypeName, Prefix) \
 gceSTATUS \
-Prefix##_Allocate##TypeName( \
+Prefix##_Allocate##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type **                    Pointer \
     ) \
@@ -200,7 +200,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_CAllocate##TypeName( \
+Prefix##_CAllocate##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type **                    Pointer \
     ) \
@@ -214,7 +214,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName( \
+Prefix##_Free##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type *                    Pointer \
     ) \
@@ -227,7 +227,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName##List( \
+Prefix##_Free##TypeName##List(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type *                    FirstPointer, \
     Type *                    LastPointer \
@@ -242,7 +242,7 @@
 
 #define gcmMEM_DeclareVSMemPool(Type, TypeName, Prefix) \
 gceSTATUS \
-Prefix##_Allocate##TypeName( \
+Prefix##_Allocate##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Size \
@@ -256,7 +256,7 @@
 } \
  \
 gceSTATUS \
- Prefix##_CAllocate##TypeName( \
+ Prefix##_CAllocate##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Size \
@@ -271,7 +271,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName( \
+Prefix##_Free##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type *                    Pointer \
     ) \
@@ -285,7 +285,7 @@
 
 #define gcmMEM_DeclareAFSMemPool(Type, TypeName, Prefix) \
 gceSTATUS \
-Prefix##_Allocate##TypeName( \
+Prefix##_Allocate##TypeName(\
     gcsMEM_AFS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Count \
@@ -299,7 +299,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_CAllocate##TypeName( \
+Prefix##_CAllocate##TypeName(\
     gcsMEM_AFS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Count \
@@ -314,7 +314,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName( \
+Prefix##_Free##TypeName(\
     gcsMEM_AFS_MEM_POOL        MemPool, \
     Type *                    Pointer \
     ) \
@@ -330,7 +330,7 @@
 
 #define gcmMEM_DeclareFSMemPool(Type, TypeName, Prefix) \
 gceSTATUS \
-Prefix##_Allocate##TypeName( \
+Prefix##_Allocate##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type **                    Pointer \
     ) \
@@ -345,7 +345,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_CAllocate##TypeName( \
+Prefix##_CAllocate##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type **                    Pointer \
     ) \
@@ -361,7 +361,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName( \
+Prefix##_Free##TypeName(\
     gcsMEM_FS_MEM_POOL        MemPool, \
     Type *                    Pointer \
     ) \
@@ -375,7 +375,7 @@
 
 #define gcmMEM_DeclareVSMemPool(Type, TypeName, Prefix) \
 gceSTATUS \
-Prefix##_Allocate##TypeName( \
+Prefix##_Allocate##TypeName(\
     gcsMEM_VS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Size \
@@ -391,7 +391,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_CAllocate##TypeName( \
+Prefix##_CAllocate##TypeName(\
     gcsMEM_VS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Size \
@@ -408,7 +408,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName( \
+Prefix##_Free##TypeName(\
     gcsMEM_VS_MEM_POOL        MemPool, \
     Type *                    Pointer \
     ) \
@@ -422,7 +422,7 @@
 
 #define gcmMEM_DeclareAFSMemPool(Type, TypeName, Prefix) \
 gceSTATUS \
-Prefix##_Allocate##TypeName( \
+Prefix##_Allocate##TypeName(\
     gcsMEM_AFS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Count \
@@ -438,7 +438,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_CAllocate##TypeName( \
+Prefix##_CAllocate##TypeName(\
     gcsMEM_AFS_MEM_POOL        MemPool, \
     Type **                    Pointer, \
     gctUINT                    Count \
@@ -455,7 +455,7 @@
 } \
  \
 gceSTATUS \
-Prefix##_Free##TypeName( \
+Prefix##_Free##TypeName(\
     gcsMEM_AFS_MEM_POOL        MemPool, \
     Type *                    Pointer \
     ) \
@@ -562,3 +562,5 @@
 
 #endif /* (gcdENABLE_3D || gcdENABLE_VG) */
 #endif /* __gc_hal_mem_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_metadata.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_metadata.h
new file mode 100644
index 0000000..c617e4f
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_metadata.h
@@ -0,0 +1,118 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2018 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2018 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+
+#ifndef __gc_hal_kernel_metadata_h_
+#define __gc_hal_kernel_metadata_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Macro to combine four characters into a Character Code. */
+#define __FOURCC(a, b, c, d) \
+    ((uint32_t)(a) | ((uint32_t)(b) << 8) | ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))
+
+#define VIV_VIDMEM_METADATA_MAGIC __FOURCC('v', 'i', 'v', 'm')
+
+/* Compressed format now was defined same as dec400d, should be general. */
+typedef enum _VIV_COMPRESS_FMT
+{
+    _VIV_CFMT_ARGB8 = 0,
+    _VIV_CFMT_XRGB8,
+    _VIV_CFMT_AYUV,
+    _VIV_CFMT_UYVY,
+    _VIV_CFMT_YUY2,
+    _VIV_CFMT_YUV_ONLY,
+    _VIV_CFMT_UV_MIX,
+    _VIV_CFMT_ARGB4,
+    _VIV_CFMT_XRGB4,
+    _VIV_CFMT_A1R5G5B5,
+    _VIV_CFMT_X1R5G5B5,
+    _VIV_CFMT_R5G6B5,
+    _VIV_CFMT_Z24S8,
+    _VIV_CFMT_Z24,
+    _VIV_CFMT_Z16,
+    _VIV_CFMT_A2R10G10B10,
+    _VIV_CFMT_BAYER,
+    _VIV_CFMT_SIGNED_BAYER,
+    _VIV_CFMT_VAA16,
+    _VIV_CFMT_S8,
+
+    _VIV_CFMT_MAX,
+} _VIV_COMPRESS_FMT;
+
+/* Metadata for cross-device fd share with additional (ts) info. */
+typedef struct _VIV_VIDMEM_METADATA
+{
+    uint32_t magic;
+
+    int32_t  ts_fd;
+    void *   ts_dma_buf;
+
+    uint32_t fc_enabled;
+    uint32_t fc_value;
+    uint32_t fc_value_upper;
+
+    uint32_t compressed;
+    uint32_t compress_format;
+} _VIV_VIDMEM_METADATA;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_kernel_metadata_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index 4a11200..73e98a9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -276,7 +276,7 @@
 #       endif
 /*
     gcdDEBUG_OPTION_NONE_TEXTURE
-        When set to 1, the type of texture will be set to AQ_TEXTURE_SAMPLE_MODE_TYPE_NONE.
+        When set to 1, the type of texture will be set to 0x0.
 */
 #ifndef gcdDEBUG_OPTION_NONE_TEXTURE
 #           define gcdDEBUG_OPTION_NONE_TEXTURE                 0
@@ -762,7 +762,7 @@
 
 /*
     gcdENABLE_INFINITE_SPEED_HW
-            enable the Infinte HW , this is for 2D openVG
+            enable the Infinte HW, this is for 2D openVG
 */
 #ifndef gcdENABLE_INFINITE_SPEED_HW
 #   define gcdENABLE_INFINITE_SPEED_HW          0
@@ -1402,3 +1402,5 @@
 
 
 #endif /* __gc_hal_options_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index 2ee13d9..38f4270 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -682,7 +682,7 @@
 #endif
 
 #if gcdENDIAN_BIG
-#define BIG_ENDIAN_TRANS_INT(x) ((gctUINT32)( \
+#define BIG_ENDIAN_TRANS_INT(x) ((gctUINT32)(\
         (((gctUINT32)(x) & (gctUINT32)0x000000FFUL) << 24) | \
         (((gctUINT32)(x) & (gctUINT32)0x0000FF00UL) << 8)  | \
         (((gctUINT32)(x) & (gctUINT32)0x00FF0000UL) >> 8)  | \
@@ -1171,3 +1171,5 @@ struct _gcoPROFILER
 #endif
 
 #endif /* __gc_hal_profiler_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
index 24c260f..df842af 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
@@ -275,3 +275,5 @@
 #endif
 
 #endif /* __gc_hal_rename_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_resource.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_resource.h
index e8ff2a7..0164222 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_resource.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_resource.h
@@ -65,3 +65,5 @@
 #endif
 
 #endif /* __gc_hal_resource_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h
index db76826..346dac9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h
@@ -64,11 +64,11 @@
 typedef enum kernel_packet_command {
     KERNEL_START_COMMAND,
     KERNEL_SUBMIT,
-    KERNEL_MAP_MEMORY,                    /* */
+    KERNEL_MAP_MEMORY, /* */
     KERNEL_UNMAP_MEMORY,
-    KERNEL_ALLOCATE_SECRUE_MEMORY,        /*! Security memory management. */
+    KERNEL_ALLOCATE_SECRUE_MEMORY, /*! Security memory management. */
     KERNEL_FREE_SECURE_MEMORY,
-    KERNEL_EXECUTE,                       /* Execute a command buffer. */
+    KERNEL_EXECUTE, /* Execute a command buffer. */
     KERNEL_DUMP_MMU_EXCEPTION,
     KERNEL_HANDLE_MMU_EXCEPTION,
     KERNEL_READ_MMU_EXCEPTION,
@@ -182,3 +182,5 @@ enum {
 };
 
 #endif
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
index 2c48772..94a1d3e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
@@ -131,3 +131,5 @@
 
 #endif /*__gc_hal_statistics_h_ */
 
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index f2d3d2a..8d2a4eb 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -73,6 +73,7 @@
 #include "vadefs.h"
 #elif defined(__QNXNTO__)
 #define _QNX_SOURCE
+#include <stdlib.h>
 #include <stdint.h>
 #include <stddef.h>
 #else
@@ -83,12 +84,10 @@
 #endif
 
 #ifdef _WIN32
-#pragma warning(disable:4127)   /* Conditional expression is constant (do { }
-                                ** while(0)). */
+#pragma warning(disable:4127)   /* Conditional expression is constant (do { } while(0)). */
 #pragma warning(disable:4100)   /* Unreferenced formal parameter. */
 #pragma warning(disable:4204)   /* Non-constant aggregate initializer (C99). */
-#pragma warning(disable:4131)   /* Uses old-style declarator (for Bison and
-                                ** Flex generated files). */
+#pragma warning(disable:4131)   /* Uses old-style declarator. */
 #pragma warning(disable:4206)   /* Translation unit is empty. */
 #pragma warning(disable:4214)   /* Nonstandard extension used :
                                 ** bit field types other than int. */
@@ -148,7 +147,7 @@
 #define gcdDEBUG_CODE           (1 << 5)
 #define gcdDEBUG_STACK          (1 << 6)
 
-#define gcmIS_DEBUG(flag)       ( gcdDEBUG & (flag | gcdDEBUG_ALL) )
+#define gcmIS_DEBUG(flag)       (gcdDEBUG & (flag | gcdDEBUG_ALL) )
 
 #ifndef gcdDEBUG
 #if (defined(DBG) && DBG) || defined(DEBUG) || defined(_DEBUG)
@@ -402,7 +401,7 @@
 
 /* Macro to combine four characters into a Charcater Code. */
 #define gcmCC(c1, c2, c3, c4) \
-( \
+(\
     (char) (c1) \
     | \
     ((char) (c2) <<  8) \
@@ -415,7 +414,7 @@
 #define gcmPRINTABLE(c)         ((((c) >= ' ') && ((c) <= '}')) ? ((c) != '%' ?  (c) : ' ') : ' ')
 
 #define gcmCC_PRINT(cc) \
-    gcmPRINTABLE((char) ( (cc)        & 0xFF)), \
+    gcmPRINTABLE((char) ((cc)        & 0xFF)), \
     gcmPRINTABLE((char) (((cc) >>  8) & 0xFF)), \
     gcmPRINTABLE((char) (((cc) >> 16) & 0xFF)), \
     gcmPRINTABLE((char) (((cc) >> 24) & 0xFF))
@@ -570,7 +569,7 @@
 **      field   Name of field within register.
 */
 #define gcmFIELDMASK(reg, field) \
-( \
+(\
     __gcmALIGN(__gcmMASK(reg##_##field), reg##_##field) \
 )
 
@@ -587,7 +586,7 @@
 **      field   Name of field within register.
 */
 #define gcmGETFIELD(data, reg, field) \
-( \
+(\
     ((((gctUINT32) (data)) >> __gcmSTART(reg##_##field)) \
         & __gcmMASK(reg##_##field)) \
 )
@@ -606,7 +605,7 @@
 **      value   Value for field.
 */
 #define gcmSETFIELD(data, reg, field, value) \
-( \
+(\
     (((gctUINT32) (data)) \
         & ~__gcmALIGN(__gcmMASK(reg##_##field), reg##_##field)) \
         |  __gcmALIGN((gctUINT32) (value) \
@@ -628,7 +627,7 @@
 **      value   Name of the value within the field.
 */
 #define gcmSETFIELDVALUE(data, reg, field, value) \
-( \
+(\
     (((gctUINT32) (data)) \
         & ~__gcmALIGN(__gcmMASK(reg##_##field), reg##_##field)) \
         |  __gcmALIGN(reg##_##field##_##value \
@@ -647,8 +646,8 @@
 **      field   Name of field within register.
 */
 #define gcmGETMASKEDFIELDMASK(reg, field) \
-( \
-    gcmSETFIELD(0, reg,          field, ~0U) | \
+(\
+    gcmSETFIELD(0, reg, field, ~0U) | \
     gcmSETFIELD(0, reg, MASK_ ## field, ~0U)   \
 )
 
@@ -665,8 +664,8 @@
 **      value   Value for field.
 */
 #define gcmSETMASKEDFIELD(reg, field, value) \
-( \
-    gcmSETFIELD     (~0U, reg,          field, value) & \
+(\
+    gcmSETFIELD     (~0U, reg, field, value) & \
     gcmSETFIELDVALUE(~0U, reg, MASK_ ## field, ENABLED) \
 )
 
@@ -683,8 +682,8 @@
 **      value   Value for field.
 */
 #define gcmSETMASKEDFIELDVALUE(reg, field, value) \
-( \
-    gcmSETFIELDVALUE(~0U, reg,          field, value) & \
+(\
+    gcmSETFIELDVALUE(~0U, reg, field, value) & \
     gcmSETFIELDVALUE(~0U, reg, MASK_ ## field, ENABLED) \
 )
 
@@ -703,7 +702,7 @@
 **      value   Name of the value within the field.
 */
 #define gcmVERIFYFIELDVALUE(data, reg, field, value) \
-( \
+(\
     (((gctUINT32) (data)) >> __gcmSTART(reg##_##field) & \
                              __gcmMASK(reg##_##field)) \
         == \
@@ -715,30 +714,30 @@
 */
 
 #define __gcmSTARTBIT(Field) \
-    ( 1 ? Field )
+    (1 ? Field )
 
 #define __gcmBITSIZE(Field) \
-    ( 0 ? Field )
+    (0 ? Field )
 
 #define __gcmBITMASK(Field) \
-( \
+(\
     (1 << __gcmBITSIZE(Field)) - 1 \
 )
 
 #define gcmGETBITS(Value, Type, Field) \
-( \
-    ( ((Type) (Value)) >> __gcmSTARTBIT(Field) ) \
+(\
+    (((Type) (Value)) >> __gcmSTARTBIT(Field) ) \
     & \
     __gcmBITMASK(Field) \
 )
 
 #define gcmSETBITS(Value, Type, Field, NewValue) \
-( \
-    ( ((Type) (Value)) \
+(\
+    (((Type) (Value)) \
     & ~(__gcmBITMASK(Field) << __gcmSTARTBIT(Field)) \
     ) \
     | \
-    ( ( ((Type) (NewValue)) \
+    ((((Type) (NewValue)) \
       & __gcmBITMASK(Field) \
       ) << __gcmSTARTBIT(Field) \
     ) \
@@ -757,7 +756,7 @@
 */
 
 #define gcmISINREGRANGE(Address, Name) \
-( \
+(\
     ((Address & (~0U << Name ## _LSB)) == (Name ## _Address >> 2)) \
 )
 
@@ -792,12 +791,12 @@
 **      p       Pointer value.
 */
 #define gcmPTR2INT(p) \
-( \
+(\
     (gctUINTPTR_T) (p) \
 )
 
 #define gcmPTR2INT32(p) \
-( \
+(\
     (gctUINT32)(gctUINTPTR_T) (p) \
 )
 
@@ -813,7 +812,7 @@
 */
 
 #define gcmINT2PTR(i) \
-( \
+(\
     (gctPOINTER) (gctUINTPTR_T)(i) \
 )
 
@@ -829,7 +828,7 @@
 **      field   Field name.
 */
 #define gcmOFFSETOF(s, field) \
-( \
+(\
     gcmPTR2INT32(& (((struct s *) 0)->field)) \
 )
 
@@ -859,7 +858,7 @@
 #if defined(__GNUC__) && !defined(__KERNEL__)
 #  define gcmBSWAP32(x)     __builtin_bswap32(x)
 #else
-#  define gcmBSWAP32(x) ((gctUINT32)( \
+#  define gcmBSWAP32(x) ((gctUINT32)(\
         (((gctUINT32)(x) & (gctUINT32)0x000000FFUL) << 24) | \
         (((gctUINT32)(x) & (gctUINT32)0x0000FF00UL) << 8)  | \
         (((gctUINT32)(x) & (gctUINT32)0x00FF0000UL) >> 8)  | \
@@ -1032,3 +1031,5 @@ struct _gckQUEUE
 #endif
 
 #endif /* __gc_hal_types_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index 35d66f6..1191597e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -62,8 +62,10 @@
 
 #define gcvVERSION_PATCH        4
 
-#define gcvVERSION_BUILD     150331
+#define gcvVERSION_BUILD     163672
 
-#define gcvVERSION_STRING    "6.2.4.p1.150331"
+#define gcvVERSION_STRING    "6.2.4.p2.163672"
 
 #endif /* __gc_hal_version_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
index 83328c3..12d28b3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
@@ -121,7 +121,7 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 #define gcmkIS_ERROR(status)        (status < 0)
 
 #define gcmALIGNDOWN(n, align) \
-( \
+(\
     (n) & ~((align) - 1) \
 )
 
@@ -130,7 +130,7 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 
 
 #define gcmIS_NAN(x) \
-( \
+(\
     ((* (gctUINT32_PTR) &(x)) & 0x7FFFFFFF) == 0x7FFFFFFF \
 )
 
@@ -160,7 +160,7 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
     status = Function; \
     if (gcmIS_ERROR(status)) \
     { \
-        gcmTRACE( \
+        gcmTRACE(\
             gcvLEVEL_ERROR, \
             "gcmERR_GOTO: status=%d @ line=%d in function %s.\n", \
             status, __LINE__, __FUNCTION__ \
@@ -170,9 +170,9 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 
 #if gcvDEBUG || gcdFORCE_MESSAGES
 #   define gcmVERIFY_BOOLEAN(Expression) \
-        gcmASSERT( \
-            ( (Expression) == gcvFALSE ) || \
-            ( (Expression) == gcvTRUE  )    \
+        gcmASSERT(\
+            ((Expression) == gcvFALSE ) || \
+            ((Expression) == gcvTRUE  )    \
             )
 #else
 #   define gcmVERIFY_BOOLEAN(Expression)
@@ -192,7 +192,7 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 **      value   Value for field.
 */
 #define gcmVERIFYFIELDFIT(reg, field, value) \
-    gcmASSERT( \
+    gcmASSERT(\
         (value) <= gcmFIELDMAX(reg, field) \
         )
 /*******************************************************************************
@@ -207,9 +207,9 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 **      field   Name of field within register.
 */
 #define gcmFIELDMAX(reg, field) \
-( \
+(\
     (gctUINT32) \
-        ( \
+        (\
         (__gcmGETSIZE(reg##_##field) == 32) \
                 ?  ~0U \
                 : (~(~0U << __gcmGETSIZE(reg##_##field))) \
@@ -250,28 +250,28 @@ typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
 \******************************************************************************/
 
 #define gcmKB2BYTES(Kilobyte) \
-( \
+(\
     (Kilobyte) << 10 \
 )
 
 #define gcmMB2BYTES(Megabyte) \
-( \
+(\
     (Megabyte) << 20 \
 )
 
 #define gcmMAT(Matrix, Row, Column) \
-( \
+(\
     (Matrix) [(Row) * 3 + (Column)] \
 )
 
 #define gcmMAKE2CHAR(Char1, Char2) \
-( \
+(\
     ((gctUINT16) (gctUINT8) (Char1) << 0) | \
     ((gctUINT16) (gctUINT8) (Char2) << 8) \
 )
 
 #define gcmMAKE4CHAR(Char1, Char2, Char3, Char4) \
-( \
+(\
     ((gctUINT32)(gctUINT8) (Char1) <<  0) | \
     ((gctUINT32)(gctUINT8) (Char2) <<  8) | \
     ((gctUINT32)(gctUINT8) (Char3) << 16) | \
@@ -914,3 +914,5 @@ typedef gceSTATUS (* gctINTERRUPT_HANDLER)(
 #endif
 
 #endif /* __gc_hal_h_ */
+
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c
index 5aeeaaf..bed5f6d 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c
@@ -157,6 +157,7 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
     )
 {
     gceSTATUS status;
+    u32 gfp = GFP_KERNEL | gcdNOWARN;
     gcsDMA_PRIV_PTR allocatorPriv = (gcsDMA_PRIV_PTR)Allocator->privateData;
 
     struct mdl_dma_priv *mdlPriv=gcvNULL;
@@ -165,21 +166,29 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
     gcmkHEADER_ARG("Mdl=%p NumPages=0x%zx Flags=0x%x", Mdl, NumPages, Flags);
 
     gcmkONERROR(gckOS_Allocate(os, sizeof(struct mdl_dma_priv), (gctPOINTER *)&mdlPriv));
+    mdlPriv->kvaddr = gcvNULL;
+
+#if defined(CONFIG_ZONE_DMA32) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+    if (Flags & gcvALLOC_FLAG_4GB_ADDR)
+    {
+        gfp |= __GFP_DMA32;
+    }
+#endif
 
     mdlPriv->kvaddr
 #if defined CONFIG_ARM64
-        = dma_alloc_coherent(_GetDevice(os), NumPages * PAGE_SIZE, &mdlPriv->dmaHandle, GFP_KERNEL | gcdNOWARN);
+        = dma_alloc_coherent(_GetDevice(os), NumPages * PAGE_SIZE, &mdlPriv->dmaHandle, gfp);
 #elif defined CONFIG_MIPS || defined CONFIG_CPU_CSKYV2 || defined CONFIG_PPC
-        = dma_alloc_coherent(gcvNULL, NumPages * PAGE_SIZE, &mdlPriv->dmaHandle, GFP_KERNEL | gcdNOWARN);
+        = dma_alloc_coherent(gcvNULL, NumPages * PAGE_SIZE, &mdlPriv->dmaHandle, gfp);
 #else
-        = dma_alloc_writecombine(gcvNULL, NumPages * PAGE_SIZE,  &mdlPriv->dmaHandle, GFP_KERNEL | gcdNOWARN);
+        = dma_alloc_writecombine(gcvNULL, NumPages * PAGE_SIZE,  &mdlPriv->dmaHandle, gfp);
 #endif
 
 #ifdef CONFLICT_BETWEEN_BASE_AND_PHYS
     if ((os->device->baseAddress & 0x80000000) != (mdlPriv->dmaHandle & 0x80000000))
     {
         mdlPriv->dmaHandle = (mdlPriv->dmaHandle & ~0x80000000)
-                            | (os->device->baseAddress & 0x80000000);
+                           | (os->device->baseAddress & 0x80000000);
     }
 #endif
 
@@ -243,8 +252,10 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
-    page = phys_to_page (mdlPriv->dmaHandle);
+#if !defined(phys_to_page)
+    page = virt_to_page(mdlPriv->kvaddr);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+    page = phys_to_page(mdlPriv->dmaHandle);
 #else
     page = phys_to_page(dma_to_phys(&Allocator->os->device->platform->device->dev, mdlPriv->dmaHandle));
 #endif
@@ -306,9 +317,10 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
 _DmaMmap(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
+    IN gctBOOL Cacheable,
     IN gctSIZE_T skipPages,
     IN gctSIZE_T numPages,
-    INOUT struct vm_area_struct *vma
+    IN struct vm_area_struct *vma
     )
 {
     struct mdl_dma_priv *mdlPriv = (struct mdl_dma_priv*)Mdl->priv;
@@ -325,7 +337,7 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
             vma->vm_start,
             (mdlPriv->dmaHandle >> PAGE_SHIFT) + skipPages,
             numPages << PAGE_SHIFT,
-            gcmkNONPAGED_MEMROY_PROT(vma->vm_page_prot)) < 0)
+            pgprot_writecombine(vma->vm_page_prot)) < 0)
 #else
     /* map kernel memory to user space.. */
     if (dma_mmap_writecombine(gcvNULL,
@@ -352,7 +364,7 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
 _DmaUnmapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctPOINTER Logical,
+    IN PLINUX_MDL_MAP MdlMap,
     IN gctUINT32 Size
     )
 {
@@ -363,7 +375,7 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
-    if (vm_munmap((unsigned long)Logical, Size) < 0)
+    if (vm_munmap((unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
                 gcvLEVEL_WARNING, gcvZONE_OS,
@@ -373,7 +385,7 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
     }
 #else
     down_write(&current->mm->mmap_sem);
-    if (do_munmap(current->mm, (unsigned long)Logical, Size) < 0)
+    if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
                 gcvLEVEL_WARNING, gcvZONE_OS,
@@ -389,8 +401,8 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
 _DmaMapUser(
     gckALLOCATOR Allocator,
     PLINUX_MDL Mdl,
-    gctBOOL Cacheable,
-    OUT gctPOINTER * UserLogical
+    PLINUX_MDL_MAP MdlMap,
+    gctBOOL Cacheable
     )
 {
     gctPOINTER userLogical = gcvNULL;
@@ -439,8 +451,6 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
         struct vm_area_struct *vma = find_vma(current->mm, (unsigned long)userLogical);
         if (vma == gcvNULL)
         {
-            up_write(&current->mm->mmap_sem);
-
             gcmkTRACE_ZONE(
                 gcvLEVEL_INFO, gcvZONE_OS,
                 "%s(%d): find_vma error",
@@ -450,9 +460,11 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
             gcmkERR_BREAK(gcvSTATUS_OUT_OF_RESOURCES);
         }
 
-        gcmkERR_BREAK(_DmaMmap(Allocator, Mdl, 0, Mdl->numPages, vma));
+        gcmkERR_BREAK(_DmaMmap(Allocator, Mdl, Cacheable, 0, Mdl->numPages, vma));
 
-        *UserLogical = userLogical;
+        MdlMap->vmaAddr = userLogical;
+        MdlMap->cacheable = gcvFALSE;
+        MdlMap->vma = vma;
     }
     while (gcvFALSE);
     up_write(&current->mm->mmap_sem);
@@ -498,6 +510,18 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
     IN gceCACHEOPERATION Operation
     )
 {
+    switch (Operation)
+    {
+    case gcvCACHE_CLEAN:
+    case gcvCACHE_FLUSH:
+        _MemoryBarrier();
+        break;
+    case gcvCACHE_INVALIDATE:
+        break;
+    default:
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
     return gcvSTATUS_OK;
 }
 
@@ -578,7 +602,12 @@ static int gc_dma_usage_show(struct seq_file* m, void* data)
      * DMA allocator is only used for NonPaged memory
      * when NO_DMA_COHERENT is not defined.
      */
-    allocator->capability = gcvALLOC_FLAG_DMABUF_EXPORTABLE;
+    allocator->capability = gcvALLOC_FLAG_CONTIGUOUS
+                          | gcvALLOC_FLAG_DMABUF_EXPORTABLE
+#if defined(CONFIG_ZONE_DMA32) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+                          | gcvALLOC_FLAG_4GB_ADDR
+#endif
+                          ;
 
     *Allocator = allocator;
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c
index d07743b..5f0e7b4 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c
@@ -74,7 +74,7 @@
 {
     struct dma_buf            * dmabuf;
     struct dma_buf_attachment * attachment;
-    struct sg_table           * sgtable;
+    struct sg_table           * sgt;
     unsigned long             * pagearray;
 
     int                         npages;
@@ -262,7 +262,7 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
     buf_desc->dmabuf = dmabuf;
     buf_desc->pagearray = pagearray;
     buf_desc->attachment = attachment;
-    buf_desc->sgtable = sgt;
+    buf_desc->sgt = sgt;
 
     /* Record in buffer list to support debugfs. */
     buf_desc->npages = npages;
@@ -313,7 +313,7 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
     list_del(&buf_desc->list);
     mutex_unlock(&priv->lock);
 
-    dma_buf_unmap_attachment(buf_desc->attachment, buf_desc->sgtable, DMA_BIDIRECTIONAL);
+    dma_buf_unmap_attachment(buf_desc->attachment, buf_desc->sgt, DMA_BIDIRECTIONAL);
 
     dma_buf_detach(buf_desc->dmabuf, buf_desc->attachment);
 
@@ -328,12 +328,12 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
 _DmabufUnmapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctPOINTER Logical,
+    IN PLINUX_MDL_MAP MdlMap,
     IN gctUINT32 Size
     )
 {
     gcsDMABUF *buf_desc = Mdl->priv;
-    gctINT8_PTR userLogical = Logical;
+    gctINT8_PTR userLogical = MdlMap->vmaAddr;
 
     if (unlikely(current->mm == gcvNULL))
     {
@@ -341,7 +341,7 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
         return;
     }
 
-    userLogical -= buf_desc->sgtable->sgl->offset;
+    userLogical -= buf_desc->sgt->sgl->offset;
     vm_munmap((unsigned long)userLogical, Mdl->numPages << PAGE_SHIFT);
 }
 
@@ -349,8 +349,8 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
 _DmabufMapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctBOOL Cacheable,
-    OUT gctPOINTER * UserLogical
+    IN PLINUX_MDL_MAP MdlMap,
+    IN gctBOOL Cacheable
     )
 {
     gcsDMABUF *buf_desc = Mdl->priv;
@@ -368,7 +368,7 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
     {
         gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
     }
-    userLogical += buf_desc->sgtable->sgl->offset;
+    userLogical += buf_desc->sgt->sgl->offset;
 
     /* To make sure the mapping is created. */
     if (access_ok(VERIFY_READ, userLogical, 4))
@@ -379,12 +379,13 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
         (void)mem;
     }
 
-    *UserLogical = (gctPOINTER)userLogical;
+    MdlMap->vmaAddr = (gctPOINTER)userLogical;
+    MdlMap->cacheable = Cacheable;
 
 OnError:
     if (gcmIS_ERROR(status) && userLogical)
     {
-        _DmabufUnmapUser(Allocator, Mdl, userLogical, Mdl->numPages << PAGE_SHIFT);
+        _DmabufUnmapUser(Allocator, Mdl, MdlMap, Mdl->numPages << PAGE_SHIFT);
     }
     return status;
 }
@@ -422,6 +423,28 @@ static int dma_buf_info_show(struct seq_file* m, void* data)
     IN gceCACHEOPERATION Operation
     )
 {
+    gcsDMABUF *buf_desc = Mdl->priv;
+    struct sg_table *sgt = buf_desc->sgt;
+    enum dma_data_direction dir;
+
+    switch (Operation)
+    {
+    case gcvCACHE_CLEAN:
+        dir = DMA_TO_DEVICE;
+        dma_sync_sg_for_device(galcore_device, sgt->sgl, sgt->nents, dir);
+        break;
+    case gcvCACHE_FLUSH:
+        dir = DMA_BIDIRECTIONAL;
+        dma_sync_sg_for_device(galcore_device, sgt->sgl, sgt->nents, dir);
+        break;
+    case gcvCACHE_INVALIDATE:
+        dir = DMA_FROM_DEVICE;
+        dma_sync_sg_for_cpu(galcore_device, sgt->sgl, sgt->nents, dir);
+        break;
+    default:
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
     return gcvSTATUS_OK;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c
index 20a1633..c76431b 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c
@@ -68,31 +68,44 @@
 
 #define gcdDISCRETE_PAGES 0
 
-struct gfp_priv
+struct gfp_alloc
 {
     atomic_t low;
     atomic_t high;
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION (2,6,24)
+struct sg_table
+{
+    struct scatterlist *sgl;
+    unsigned int nents;
+    unsigned int orig_nents;
+};
+#endif
+
 struct gfp_mdl_priv
 {
+    int contiguous;
+
     union
     {
         /* Pointer to a array of pages. */
-        struct page *       contiguousPages;
-        /* Pointer to a array of pointers to page. */
-        struct page **      nonContiguousPages;
-    };
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-    gctBOOL                 exact;
-#endif
-
-    gctBOOL                 cacheable;
+        struct
+        {
+            struct page *contiguousPages;
+            dma_addr_t dma_addr;
+            int exact;
+        };
 
-    gcsPLATFORM *           platform;
+        struct
+        {
+            /* Pointer to a array of pointers to page. */
+            struct page **nonContiguousPages;
+            struct sg_table sgt;
+        };
+    };
 
-    gctBOOL                 contiguous;
+    gcsPLATFORM * platform;
 };
 
 /******************************************************************************\
@@ -103,7 +116,7 @@ static int gc_usage_show(struct seq_file* m, void* data)
 {
     gcsINFO_NODE *node = m->private;
     gckALLOCATOR Allocator = node->device;
-    struct gfp_priv *priv = Allocator->privateData;
+    struct gfp_alloc *priv = Allocator->privateData;
     long long low  = (long long)atomic_read(&priv->low);
     long long high = (long long)atomic_read(&priv->high);
 
@@ -181,14 +194,12 @@ static int gc_usage_show(struct seq_file* m, void* data)
 
 static struct page **
 _NonContiguousAlloc(
-    IN gctUINT32 NumPages
+    IN gctUINT32 NumPages,
+    IN gctUINT32 Gfp
     )
 {
     struct page ** pages;
     struct page *p;
-#if gcdDISCRETE_PAGES
-    struct page *l;
-#endif
     gctINT i, size;
 
     gcmkHEADER_ARG("NumPages=%u", NumPages);
@@ -220,7 +231,7 @@ static int gc_usage_show(struct seq_file* m, void* data)
 
     for (i = 0; i < NumPages; i++)
     {
-        p = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN);
+        p = alloc_page(Gfp);
 
         if (!p)
         {
@@ -235,10 +246,10 @@ static int gc_usage_show(struct seq_file* m, void* data)
             if (page_to_pfn(pages[i-1]) == page_to_pfn(p)-1)
             {
                 /* Replaced page. */
-                l = p;
+                struct page *l = p;
 
                 /* Allocate a page which is not contiguous to previous one. */
-                p = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_NOWARN);
+                p = alloc_page(Gfp);
 
                 /* Give replaced page back. */
                 __free_page(l);
@@ -273,33 +284,40 @@ static int gc_usage_show(struct seq_file* m, void* data)
 {
     gceSTATUS status;
     gctUINT i;
+    u32 gfp = GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN;
     gctBOOL contiguous = Flags & gcvALLOC_FLAG_CONTIGUOUS;
-#ifdef gcdSYS_FREE_MEMORY_LIMIT
-    struct sysinfo temsysinfo;
-#endif
 
-    struct gfp_priv *priv = (struct gfp_priv *)Allocator->privateData;
+    struct gfp_alloc *priv = (struct gfp_alloc *)Allocator->privateData;
     struct gfp_mdl_priv *mdlPriv = gcvNULL;
+    int result;
     int low = 0;
     int high = 0;
 
     gcmkHEADER_ARG("Allocator=%p Mdl=%p NumPages=%zu Flags=0x%x", Allocator, Mdl, NumPages, Flags);
 
 #ifdef gcdSYS_FREE_MEMORY_LIMIT
-    si_meminfo(&temsysinfo);
-
     if (Flags & gcvALLOC_FLAG_MEMLIMIT)
     {
-        if ( (temsysinfo.freeram < NumPages) || ((temsysinfo.freeram-NumPages) < gcdSYS_FREE_MEMORY_LIMIT) )
+        struct sysinfo temsysinfo;
+        si_meminfo(&temsysinfo);
+
+        if ((temsysinfo.freeram < NumPages) || ((temsysinfo.freeram-NumPages) < gcdSYS_FREE_MEMORY_LIMIT))
         {
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
     }
 #endif
 
-    gcmkONERROR(gckOS_Allocate(Allocator->os, sizeof(struct gfp_mdl_priv), (gctPOINTER *)&mdlPriv));
+    mdlPriv = kzalloc(sizeof(struct gfp_mdl_priv), GFP_KERNEL | __GFP_NORETRY);
 
-    memset(mdlPriv, 0, sizeof(struct gfp_mdl_priv));
+#if defined(CONFIG_ZONE_DMA32) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+    if (Flags & gcvALLOC_FLAG_4GB_ADDR)
+    {
+        /* remove __GFP_HIGHMEM bit, add __GFP_DMA32 bit */
+        gfp &= ~__GFP_HIGHMEM;
+        gfp |= __GFP_DMA32;
+    }
+#endif
 
     if (contiguous)
     {
@@ -308,11 +326,14 @@ static int gc_usage_show(struct seq_file* m, void* data)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
         void *addr = NULL;
 
-        addr = alloc_pages_exact(bytes, GFP_KERNEL | gcdNOWARN | __GFP_NORETRY);
+        addr = alloc_pages_exact(bytes, (gfp & ~__GFP_HIGHMEM) | __GFP_NORETRY);
 
         mdlPriv->contiguousPages = addr ? virt_to_page(addr) : gcvNULL;
 
-        mdlPriv->exact = gcvTRUE;
+        if (mdlPriv->contiguousPages)
+        {
+            mdlPriv->exact = gcvTRUE;
+        }
 #endif
 
         if (mdlPriv->contiguousPages == gcvNULL)
@@ -325,12 +346,8 @@ static int gc_usage_show(struct seq_file* m, void* data)
                 goto OnError;
             }
 
-            mdlPriv->contiguousPages =
-                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN, order);
+            mdlPriv->contiguousPages = alloc_pages(gfp, order);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-            mdlPriv->exact = gcvFALSE;
-#endif
         }
 
         if (mdlPriv->contiguousPages == gcvNULL)
@@ -338,6 +355,26 @@ static int gc_usage_show(struct seq_file* m, void* data)
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
 
+        mdlPriv->dma_addr = dma_map_page(galcore_device,
+                mdlPriv->contiguousPages, 0, NumPages * PAGE_SIZE,
+                DMA_TO_DEVICE);
+
+        if (!mdlPriv->dma_addr)
+        {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+            if (mdlPriv->exact)
+            {
+                free_pages_exact(page_address(mdlPriv->contiguousPages), bytes);
+            }
+            else
+#endif
+            {
+                __free_pages(mdlPriv->contiguousPages, get_order(bytes));
+            }
+
+            gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+
 #if defined(CONFIG_X86)
         if (!PageHighMem(mdlPriv->contiguousPages))
         {
@@ -350,13 +387,48 @@ static int gc_usage_show(struct seq_file* m, void* data)
     }
     else
     {
-        mdlPriv->nonContiguousPages = _NonContiguousAlloc(NumPages);
+        mdlPriv->nonContiguousPages = _NonContiguousAlloc(NumPages, gfp);
 
         if (mdlPriv->nonContiguousPages == gcvNULL)
         {
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+        result = sg_alloc_table_from_pages(&mdlPriv->sgt,
+                    mdlPriv->nonContiguousPages, NumPages, 0,
+                    NumPages << PAGE_SHIFT, GFP_KERNEL);
+
+#else
+        result = alloc_sg_list_from_pages(&mdlPriv->sgt.sgl,
+                    mdlPriv->nonContiguousPages, NumPages, 0,
+                    NumPages << PAGE_SHIFT, &mdlPriv->sgt.nents);
+
+        mdlPriv->sgt.orig_nents = mdlPriv->sgt.nents;
+#endif
+        if (result < 0)
+        {
+            _NonContiguousFree(mdlPriv->nonContiguousPages, NumPages);
+            gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+
+        result = dma_map_sg(galcore_device,
+                    mdlPriv->sgt.sgl, mdlPriv->sgt.nents, DMA_TO_DEVICE);
+
+        if (result != mdlPriv->sgt.nents)
+        {
+            _NonContiguousFree(mdlPriv->nonContiguousPages, NumPages);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined (ARCH_HAS_SG_CHAIN) || defined (CONFIG_ARCH_HAS_SG_CHAIN))
+            sg_free_table(&mdlPriv->sgt);
+#else
+            kfree(mdlPriv->sgt.sgl);
+#endif
+            gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+
 #if defined(CONFIG_X86)
         if (set_pages_array_wc(mdlPriv->nonContiguousPages, NumPages))
         {
@@ -387,28 +459,10 @@ static int gc_usage_show(struct seq_file* m, void* data)
 
         if (PageHighMem(page))
         {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
-            void *vaddr = kmap_atomic(page);
-#else
-            void *vaddr = kmap_atomic(page, KM_USER0);
-#endif
-
-            gcmkVERIFY_OK(gckOS_CacheFlush(
-                Allocator->os, _GetProcessID(), gcvNULL, phys, vaddr, PAGE_SIZE
-                ));
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
-            kunmap_atomic(vaddr);
-#else
-            kunmap_atomic(vaddr, KM_USER0);
-#endif
             high++;
         }
         else
         {
-            gcmkVERIFY_OK(gckOS_CacheFlush(
-                Allocator->os, _GetProcessID(), gcvNULL, phys, page_address(page), PAGE_SIZE
-                ));
             low++;
         }
     }
@@ -426,7 +480,7 @@ static int gc_usage_show(struct seq_file* m, void* data)
 OnError:
     if (mdlPriv)
     {
-        gcmkOS_SAFE_FREE(Allocator->os, mdlPriv);
+        kfree(mdlPriv);
     }
 
     gcmkFOOTER();
@@ -512,11 +566,29 @@ static int gc_usage_show(struct seq_file* m, void* data)
 {
     gctINT i;
     struct page * page;
-    struct gfp_priv *priv = (struct gfp_priv *)Allocator->privateData;
+    struct gfp_alloc *priv = (struct gfp_alloc *)Allocator->privateData;
     struct gfp_mdl_priv *mdlPriv = Mdl->priv;
     int low  = 0;
     int high = 0;
 
+    if (Mdl->contiguous)
+    {
+        dma_unmap_page(galcore_device, mdlPriv->dma_addr,
+                Mdl->numPages << PAGE_SHIFT, DMA_TO_DEVICE);
+    }
+    else
+    {
+        dma_unmap_sg(galcore_device, mdlPriv->sgt.sgl, mdlPriv->sgt.nents,
+                DMA_TO_DEVICE);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined (ARCH_HAS_SG_CHAIN) || defined (CONFIG_ARCH_HAS_SG_CHAIN))
+        sg_free_table(&mdlPriv->sgt);
+#else
+        kfree(mdlPriv->sgt.sgl);
+#endif
+    }
+
     for (i = 0; i < Mdl->numPages; i++)
     {
         if (Mdl->contiguous)
@@ -572,16 +644,17 @@ static int gc_usage_show(struct seq_file* m, void* data)
         _NonContiguousFree(mdlPriv->nonContiguousPages, Mdl->numPages);
     }
 
-    gcmkOS_SAFE_FREE(Allocator->os, Mdl->priv);
+    kfree(Mdl->priv);
 }
 
 static gceSTATUS
 _GFPMmap(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
+    IN gctBOOL Cacheable,
     IN gctSIZE_T skipPages,
     IN gctSIZE_T numPages,
-    INOUT struct vm_area_struct *vma
+    IN struct vm_area_struct *vma
     )
 {
     struct gfp_mdl_priv *mdlPriv = (struct gfp_mdl_priv*)Mdl->priv;
@@ -591,7 +664,8 @@ static int gc_usage_show(struct seq_file* m, void* data)
     gcmkHEADER_ARG("Allocator=%p Mdl=%p vma=%p", Allocator, Mdl, vma);
 
     vma->vm_flags |= gcdVM_FLAGS;
-    if (mdlPriv->cacheable == gcvFALSE)
+
+    if (Cacheable == gcvFALSE)
     {
         vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
     }
@@ -659,13 +733,11 @@ static int gc_usage_show(struct seq_file* m, void* data)
 _GFPUnmapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctPOINTER Logical,
+    IN PLINUX_MDL_MAP MdlMap,
     IN gctUINT32 Size
     )
 {
-    struct gfp_mdl_priv *mdlPriv = (struct gfp_mdl_priv*)Mdl->priv;
-
-    mdlPriv->cacheable = gcvFALSE;
+    MdlMap->cacheable = gcvFALSE;
 
     if (unlikely(current->mm == gcvNULL))
     {
@@ -674,7 +746,7 @@ static int gc_usage_show(struct seq_file* m, void* data)
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
-    if (vm_munmap((unsigned long)Logical, Size) < 0)
+    if (vm_munmap((unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
                 gcvLEVEL_WARNING, gcvZONE_OS,
@@ -684,7 +756,7 @@ static int gc_usage_show(struct seq_file* m, void* data)
     }
 #else
     down_write(&current->mm->mmap_sem);
-    if (do_munmap(current->mm, (unsigned long)Logical, Size) < 0)
+    if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
                 gcvLEVEL_WARNING, gcvZONE_OS,
@@ -694,14 +766,16 @@ static int gc_usage_show(struct seq_file* m, void* data)
     }
     up_write(&current->mm->mmap_sem);
 #endif
+
+    MdlMap->vma = NULL;
 }
 
 static gceSTATUS
 _GFPMapUser(
     gckALLOCATOR Allocator,
     PLINUX_MDL Mdl,
-    gctBOOL Cacheable,
-    OUT gctPOINTER * UserLogical
+    PLINUX_MDL_MAP MdlMap,
+    gctBOOL Cacheable
     )
 {
     gctPOINTER userLogical = gcvNULL;
@@ -751,7 +825,6 @@ static int gc_usage_show(struct seq_file* m, void* data)
     down_write(&current->mm->mmap_sem);
     do
     {
-        struct gfp_mdl_priv *mdlPriv = (struct gfp_mdl_priv*)Mdl->priv;
         struct vm_area_struct *vma = find_vma(current->mm, (unsigned long)userLogical);
 
         if (vma == gcvNULL)
@@ -765,25 +838,16 @@ static int gc_usage_show(struct seq_file* m, void* data)
             gcmkERR_BREAK(gcvSTATUS_OUT_OF_RESOURCES);
         }
 
-        /* mdlPriv->cacheable must be used under protection of mdl->mapMutex. */
-        mdlPriv->cacheable = Cacheable;
-        gcmkERR_BREAK(_GFPMmap(Allocator, Mdl, 0, Mdl->numPages, vma));
+        gcmkERR_BREAK(_GFPMmap(Allocator, Mdl, Cacheable, 0, Mdl->numPages, vma));
+        MdlMap->vma = vma;
     }
     while (gcvFALSE);
     up_write(&current->mm->mmap_sem);
 
     if (gcmIS_SUCCESS(status))
     {
-        gcmkONERROR(gckOS_CacheFlush(
-            Allocator->os,
-            _GetProcessID(),
-            Mdl,
-            gcvINVALID_ADDRESS,
-            userLogical,
-            Mdl->numPages * PAGE_SIZE
-            ));
-
-        *UserLogical = userLogical;
+        MdlMap->vmaAddr = userLogical;
+        MdlMap->cacheable = Cacheable;
     }
 
 OnError:
@@ -891,6 +955,60 @@ static int gc_usage_show(struct seq_file* m, void* data)
     IN gceCACHEOPERATION Operation
     )
 {
+    struct gfp_mdl_priv *mdlPriv = Mdl->priv;
+    enum dma_data_direction dir;
+
+    switch (Operation)
+    {
+    case gcvCACHE_CLEAN:
+        dir = DMA_TO_DEVICE;
+
+        if (mdlPriv->contiguous)
+        {
+            dma_sync_single_for_device(galcore_device,
+                    mdlPriv->dma_addr, Mdl->numPages << PAGE_SHIFT, dir);
+        }
+        else
+        {
+            dma_sync_sg_for_device(galcore_device,
+                    mdlPriv->sgt.sgl, mdlPriv->sgt.nents, dir);
+        }
+
+        break;
+    case gcvCACHE_FLUSH:
+        dir = DMA_BIDIRECTIONAL;
+
+        if (mdlPriv->contiguous)
+        {
+            dma_sync_single_for_device(galcore_device,
+                    mdlPriv->dma_addr, Mdl->numPages << PAGE_SHIFT, dir);
+        }
+        else
+        {
+            dma_sync_sg_for_device(galcore_device,
+                    mdlPriv->sgt.sgl, mdlPriv->sgt.nents, dir);
+        }
+
+        break;
+    case gcvCACHE_INVALIDATE:
+        dir = DMA_FROM_DEVICE;
+
+        if (mdlPriv->contiguous)
+        {
+            dma_sync_single_for_cpu(galcore_device,
+                    mdlPriv->dma_addr, Mdl->numPages << PAGE_SHIFT, dir);
+        }
+        else
+        {
+            dma_sync_sg_for_cpu(galcore_device,
+                    mdlPriv->sgt.sgl, mdlPriv->sgt.nents, dir);
+        }
+
+        break;
+    default:
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
     return gcvSTATUS_OK;
 }
 
@@ -959,12 +1077,12 @@ static int gc_usage_show(struct seq_file* m, void* data)
 {
     gceSTATUS status;
     gckALLOCATOR allocator = gcvNULL;
-    struct gfp_priv *priv = gcvNULL;
+    struct gfp_alloc *priv = gcvNULL;
 
     gcmkONERROR(
         gckALLOCATOR_Construct(Os, &GFPAllocatorOperations, &allocator));
 
-    priv = kzalloc(sizeof(struct gfp_priv), GFP_KERNEL | gcdNOWARN);
+    priv = kzalloc(sizeof(struct gfp_alloc), GFP_KERNEL | gcdNOWARN);
 
     if (!priv)
     {
@@ -986,6 +1104,9 @@ static int gc_usage_show(struct seq_file* m, void* data)
                           | gcvALLOC_FLAG_MEMLIMIT
                           | gcvALLOC_FLAG_ALLOC_ON_FAULT
                           | gcvALLOC_FLAG_DMABUF_EXPORTABLE
+#if defined(CONFIG_ZONE_DMA32) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+                          | gcvALLOC_FLAG_4GB_ADDR
+#endif
                           ;
 
 #if defined(gcdEMULATE_SECURE_ALLOCATOR)
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c
index 52518c1..a39042f 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c
@@ -216,9 +216,10 @@ static int reserved_mem_show(struct seq_file* m, void* data)
 reserved_mem_mmap(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
+    IN gctBOOL Cacheable,
     IN gctSIZE_T skipPages,
     IN gctSIZE_T numPages,
-    INOUT struct vm_area_struct *vma
+    IN struct vm_area_struct *vma
     )
 {
     struct reserved_mem *res = (struct reserved_mem*)Mdl->priv;
@@ -255,7 +256,7 @@ static int reserved_mem_show(struct seq_file* m, void* data)
 reserved_mem_unmap_user(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctPOINTER Logical,
+    IN PLINUX_MDL_MAP MdlMap,
     IN gctUINT32 Size
     )
 {
@@ -263,13 +264,13 @@ static int reserved_mem_show(struct seq_file* m, void* data)
         return;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
-    if (vm_munmap((unsigned long)Logical, (unsigned long)Size) < 0)
+    if (vm_munmap((unsigned long)MdlMap->vmaAddr, (unsigned long)Size) < 0)
     {
         printk("%s: vm_munmap failed\n", __func__);
     }
 #else
     down_write(&current->mm->mmap_sem);
-    if (do_munmap(current->mm, (unsigned long)Logical, (unsigned long)Size) < 0)
+    if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr, (unsigned long)Size) < 0)
     {
         printk("%s: do_munmap failed\n", __func__);
     }
@@ -281,8 +282,8 @@ static int reserved_mem_show(struct seq_file* m, void* data)
 reserved_mem_map_user(
     gckALLOCATOR Allocator,
     PLINUX_MDL Mdl,
-    gctBOOL Cacheable,
-    OUT gctPOINTER *UserLogical
+    PLINUX_MDL_MAP MdlMap,
+    gctBOOL Cacheable
     )
 {
     struct reserved_mem *res = (struct reserved_mem*)Mdl->priv;
@@ -333,9 +334,11 @@ static int reserved_mem_show(struct seq_file* m, void* data)
             gcmkERR_BREAK(gcvSTATUS_OUT_OF_RESOURCES);
         }
 
-        gcmkERR_BREAK(reserved_mem_mmap(Allocator, Mdl, 0, Mdl->numPages, vma));
+        gcmkERR_BREAK(reserved_mem_mmap(Allocator, Mdl, gcvFALSE, 0, Mdl->numPages, vma));
 
-        *UserLogical = userLogical;
+        MdlMap->vmaAddr = userLogical;
+        MdlMap->cacheable = gcvFALSE;
+        MdlMap->vma = vma;
     }
     while (gcvFALSE);
     up_write(&current->mm->mmap_sem);
@@ -359,6 +362,7 @@ static int reserved_mem_show(struct seq_file* m, void* data)
     struct reserved_mem *res = Mdl->priv;
     void *vaddr;
 
+    /* Should never run here now. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
     vaddr = memremap(res->start, res->size, MEMREMAP_WC);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
@@ -401,6 +405,19 @@ static int reserved_mem_show(struct seq_file* m, void* data)
     IN gceCACHEOPERATION Operation
     )
 {
+    /* Always WC or UC, safe to use mb. */
+    switch (Operation)
+    {
+    case gcvCACHE_CLEAN:
+    case gcvCACHE_FLUSH:
+        _MemoryBarrier();
+        break;
+    case gcvCACHE_INVALIDATE:
+        break;
+    default:
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
     return gcvSTATUS_OK;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c
index 690d202..223533d 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c
@@ -55,6 +55,7 @@
 
 #include "gc_hal_kernel_linux.h"
 #include "gc_hal_kernel_allocator.h"
+#include <linux/scatterlist.h>
 
 #include <linux/slab.h>
 #include <linux/pagemap.h>
@@ -68,6 +69,15 @@ enum um_desc_type
     UM_PFN_MAP,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION (2,6,24)
+struct sg_table
+{
+    struct scatterlist *sgl;
+    unsigned int nents;
+    unsigned int orig_nents;
+};
+#endif
+
 /* Descriptor of a user memory imported. */
 struct um_desc
 {
@@ -79,7 +89,11 @@ struct um_desc
         unsigned long physical;
 
         /* UM_PAGE_MAP. */
-        struct page **pages;
+        struct
+        {
+            struct page **pages;
+            struct sg_table sgt;
+        };
 
         /* UM_PFN_MAP. */
         struct
@@ -92,6 +106,7 @@ struct um_desc
     /* contiguous chunks, does not include padding pages. */
     int chunk_count;
 
+    unsigned long vm_flags;
     unsigned long user_vaddr;
     size_t size;
     unsigned long offset;
@@ -109,7 +124,7 @@ static int import_physical_map(struct um_desc *um, unsigned long phys)
 }
 
 static int import_page_map(struct um_desc *um,
-                unsigned long addr, size_t page_count)
+                unsigned long addr, size_t page_count, size_t size)
 {
     int i;
     int result;
@@ -162,10 +177,48 @@ static int import_page_map(struct um_desc *um,
         }
     }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+    result = sg_alloc_table_from_pages(&um->sgt, pages, page_count,
+                    addr & ~PAGE_MASK, size, GFP_KERNEL | gcdNOWARN);
+
+#else
+    result = alloc_sg_list_from_pages(&um->sgt.sgl, pages, page_count,
+                    addr & ~PAGE_MASK, size, &um->sgt.nents);
+
+    um->sgt.orig_nents = um->sgt.nents;
+#endif
+    if (unlikely(result < 0))
+    {
+        printk("[galcore]: %s: sg_alloc_table_from_pages failed\n", __FUNCTION__);
+        goto error;
+    }
+
+    result = dma_map_sg(galcore_device, um->sgt.sgl, um->sgt.nents, DMA_TO_DEVICE);
+    if (unlikely(result != um->sgt.nents))
+    {
+        printk("[galcore]: %s: dma_map_sg failed\n", __FUNCTION__);
+        goto error;
+    }
+
     um->type = UM_PAGE_MAP;
     um->pages = pages;
 
     return 0;
+
+error:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+    sg_free_table(&um->sgt);
+#else
+    kfree(um->sgt.sgl);
+#endif
+
+    if (um->pages)
+    {
+        kfree(um->pages);
+    }
+    return result;
 }
 
 
@@ -283,7 +336,8 @@ static int import_pfn_map(struct um_desc *um,
     )
 {
     gceSTATUS status = gcvSTATUS_OK;
-    int pfn_map = 0;
+    unsigned long vm_flags = 0;
+    struct vm_area_struct *vma = NULL;
     unsigned long start, end, memory;
     int result = 0;
 
@@ -327,17 +381,18 @@ static int import_pfn_map(struct um_desc *um,
 
     if (memory)
     {
-        struct vm_area_struct *vma = NULL;
         unsigned long vaddr = memory;
 
         for (i = 0; i < pageCount; i++)
         {
             u32 data;
-            get_user(data, (u32 *)((memory & PAGE_MASK) + PAGE_SIZE * i));
-            put_user(data, (u32 *)((memory & PAGE_MASK) + PAGE_SIZE * i));
+
+            get_user(data, (u32 *)vaddr);
+            put_user(data, (u32 *)vaddr);
+            vaddr += PAGE_SIZE;
         }
 
-        vma = find_vma(current->mm, vaddr);
+        vma = find_vma(current->mm, memory);
 
         if (!vma)
         {
@@ -345,7 +400,12 @@ static int import_pfn_map(struct um_desc *um,
             gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
         }
 
-        pfn_map = !!(vma->vm_flags & VM_PFNMAP);
+#ifdef CONFIG_ARM
+        /* coherent cache in case vivt or vipt-aliasing cache. */
+        __cpuc_flush_user_range(memory, memory + Size, vma->vm_flags);
+#endif
+
+        vm_flags = vma->vm_flags;
         vaddr = vma->vm_end;
 
         while (vaddr < memory + Size)
@@ -358,7 +418,7 @@ static int import_pfn_map(struct um_desc *um,
                 gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
             }
 
-            if (!!(vma->vm_flags & VM_PFNMAP) != pfn_map)
+            if ((vma->vm_flags & VM_PFNMAP) != (vm_flags & VM_PFNMAP))
             {
                 /* Can not support different map type: both PFN and PAGE detected. */
                 gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
@@ -374,13 +434,13 @@ static int import_pfn_map(struct um_desc *um,
     }
     else
     {
-        if (pfn_map)
+        if (vm_flags & VM_PFNMAP)
         {
             result = import_pfn_map(UserMemory, memory, pageCount);
         }
         else
         {
-            result = import_page_map(UserMemory, memory, pageCount);
+            result = import_page_map(UserMemory, memory, pageCount, Size);
         }
     }
 
@@ -397,20 +457,7 @@ static int import_pfn_map(struct um_desc *um,
         gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
     }
 
-    if (UserMemory->type == UM_PAGE_MAP)
-    {
-        for (i = 0; i < pageCount; i++)
-        {
-            gctUINT32 phys = page_to_phys(UserMemory->pages[i]);
-
-            /* Flush(clean) the data cache. */
-            gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                        phys,
-                        (gctPOINTER)(memory & PAGE_MASK) + i*PAGE_SIZE,
-                        PAGE_SIZE);
-        }
-    }
-
+    UserMemory->vm_flags = vm_flags;
     UserMemory->user_vaddr = (unsigned long)Memory;
     UserMemory->size  = Size;
     UserMemory->offset = (Physical != gcvINVALID_PHYSICAL_ADDRESS)
@@ -476,6 +523,15 @@ static void release_page_map(struct um_desc *um)
 {
     int i;
 
+    dma_unmap_sg(galcore_device, um->sgt.sgl, um->sgt.nents, DMA_TO_DEVICE);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+    sg_free_table(&um->sgt);
+#else
+    kfree(um->sgt.sgl);
+#endif
+
     for (i = 0; i < um->pageCount; i++)
     {
         if (!PageReserved(um->pages[i]))
@@ -551,13 +607,14 @@ static void release_pfn_map(struct um_desc *um)
 _UserMemoryMapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctBOOL Cacheable,
-    OUT gctPOINTER * UserLogical
+    IN PLINUX_MDL_MAP MdlMap,
+    IN gctBOOL Cacheable
     )
 {
     struct um_desc *userMemory = Mdl->priv;
 
-    *UserLogical = (gctPOINTER)userMemory->user_vaddr;
+    MdlMap->vmaAddr = (gctPOINTER)userMemory->user_vaddr;
+    MdlMap->cacheable = gcvTRUE;
 
     return gcvSTATUS_OK;
 }
@@ -566,7 +623,7 @@ static void release_pfn_map(struct um_desc *um)
 _UserMemoryUnmapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctPOINTER Logical,
+    IN PLINUX_MDL_MAP MdlMap,
     IN gctUINT32 Size
     )
 {
@@ -582,7 +639,6 @@ static void release_pfn_map(struct um_desc *um)
 {
     /* Kernel doesn't acess video memory. */
     return gcvSTATUS_NOT_SUPPORTED;
-
 }
 
 static gceSTATUS
@@ -606,6 +662,40 @@ static void release_pfn_map(struct um_desc *um)
     IN gceCACHEOPERATION Operation
     )
 {
+    struct um_desc *um = Mdl->priv;
+    enum dma_data_direction dir;
+
+    if (um->type != UM_PAGE_MAP)
+    {
+        _MemoryBarrier();
+        return gcvSTATUS_OK;
+    }
+
+#ifdef CONFIG_ARM
+    /* coherent cache in case vivt or vipt-aliasing cache. */
+    __cpuc_flush_user_range(um->user_vaddr,
+                            um->user_vaddr + um->size, um->vm_flags);
+#endif
+
+    switch (Operation)
+    {
+    case gcvCACHE_CLEAN:
+        dir = DMA_TO_DEVICE;
+        dma_sync_sg_for_device(galcore_device, um->sgt.sgl, um->sgt.nents, dir);
+        break;
+    case gcvCACHE_FLUSH:
+        dir = DMA_BIDIRECTIONAL;
+        dma_sync_sg_for_device(galcore_device, um->sgt.sgl, um->sgt.nents, dir);
+        break;
+    case gcvCACHE_INVALIDATE:
+        dir = DMA_FROM_DEVICE;
+        dma_sync_sg_for_cpu(galcore_device, um->sgt.sgl, um->sgt.nents, dir);
+        break;
+    default:
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
+
     return gcvSTATUS_OK;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
index 6e787c9..f3f770a 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
@@ -62,7 +62,6 @@
 #include <asm/atomic.h>
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
-#include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 
 #define _GC_OBJ_ZONE    gcvZONE_OS
@@ -137,6 +136,7 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
     )
 {
     gceSTATUS status;
+    u32 gfp = GFP_KERNEL | gcdNOWARN;
     gcsCMA_PRIV_PTR priv = (gcsCMA_PRIV_PTR)Allocator->privateData;
 
     struct mdl_cma_priv *mdl_priv=gcvNULL;
@@ -159,10 +159,17 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
     gcmkONERROR(gckOS_Allocate(os, sizeof(struct mdl_cma_priv), (gctPOINTER *)&mdl_priv));
     mdl_priv->kvaddr = gcvNULL;
 
+#if defined(CONFIG_ZONE_DMA32) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+    if (Flags & gcvALLOC_FLAG_4GB_ADDR)
+    {
+        gfp |= __GFP_DMA32;
+    }
+#endif
+
     mdl_priv->kvaddr = dma_alloc_writecombine(&os->device->platform->device->dev,
             NumPages * PAGE_SIZE,
             &mdl_priv->physical,
-            GFP_KERNEL | gcdNOWARN);
+            gfp);
 
     if (mdl_priv->kvaddr == gcvNULL)
     {
@@ -220,8 +227,10 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
-    page = phys_to_page (mdlPriv->physical);
+#if !defined(phys_to_page)
+    page = virt_to_page(mdlPriv->kvaddr);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+    page = phys_to_page(mdlPriv->physical);
 #else
     page = phys_to_page(dma_to_phys(&Allocator->os->device->platform->device->dev, mdl_priv->physical));
 #endif
@@ -276,9 +285,10 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
 _CMAFSLMmap(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
+    IN gctBOOL Cacheable,
     IN gctSIZE_T skipPages,
     IN gctSIZE_T numPages,
-    INOUT struct vm_area_struct *vma
+    IN struct vm_area_struct *vma
     )
 {
     gckOS os = Allocator->os;
@@ -323,7 +333,7 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
 _CMAFSLUnmapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctPOINTER Logical,
+    IN PLINUX_MDL_MAP MdlMap,
     IN gctUINT32 Size
     )
 {
@@ -334,7 +344,7 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
-    if (vm_munmap((unsigned long)Logical, Size) < 0)
+    if (vm_munmap((unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
                 gcvLEVEL_WARNING, gcvZONE_OS,
@@ -344,7 +354,7 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
     }
 #else
     down_write(&current->mm->mmap_sem);
-    if (do_munmap(current->mm, (unsigned long)Logical, Size) < 0)
+    if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
                 gcvLEVEL_WARNING, gcvZONE_OS,
@@ -360,8 +370,8 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
 _CMAFSLMapUser(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
-    IN gctBOOL Cacheable,
-    OUT gctPOINTER * UserLogical
+    IN PLINUX_MDL_MAP MdlMap,
+    IN gctBOOL Cacheable
     )
 {
     gctPOINTER userLogical = gcvNULL;
@@ -419,25 +429,14 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
             gcmkERR_BREAK(gcvSTATUS_OUT_OF_RESOURCES);
         }
 
-        gcmkERR_BREAK(_CMAFSLMmap(Allocator, Mdl, 0, Mdl->numPages, vma));
+        gcmkERR_BREAK(_CMAFSLMmap(Allocator, Mdl, Cacheable, 0, Mdl->numPages, vma));
+        MdlMap->vmaAddr = userLogical;
+        MdlMap->cacheable = Cacheable;
+        MdlMap->vma = vma;
     }
     while (gcvFALSE);
     up_write(&current->mm->mmap_sem);
 
-    if (gcmIS_SUCCESS(status))
-    {
-        gcmkONERROR(gckOS_CacheFlush(
-            Allocator->os,
-            _GetProcessID(),
-            Mdl,
-            gcvINVALID_ADDRESS,
-            userLogical,
-            Mdl->numPages * PAGE_SIZE
-            ));
-
-        *UserLogical = userLogical;
-    }
-
 OnError:
     if (gcmIS_ERROR(status) && userLogical)
     {
@@ -479,6 +478,18 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
     IN gceCACHEOPERATION Operation
     )
 {
+    switch (Operation)
+    {
+    case gcvCACHE_CLEAN:
+    case gcvCACHE_FLUSH:
+        _MemoryBarrier();
+        break;
+    case gcvCACHE_INVALIDATE:
+        break;
+    default:
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
     return gcvSTATUS_OK;
 }
 
@@ -559,6 +570,9 @@ static int gc_cma_usage_show(struct seq_file* m, void* data)
 
     allocator->capability = gcvALLOC_FLAG_CONTIGUOUS
                           | gcvALLOC_FLAG_DMABUF_EXPORTABLE
+#if defined(CONFIG_ZONE_DMA32) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+                          | gcvALLOC_FLAG_4GB_ADDR
+#endif
                           ;
 
 #if defined(CONFIG_ARM64)
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
index 85b52d5..0eee490 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
@@ -178,3 +178,83 @@
     return gcvSTATUS_OK;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION (3,6,0) \
+    || (!defined (ARCH_HAS_SG_CHAIN) && !defined (CONFIG_ARCH_HAS_SG_CHAIN))
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
+static inline void sg_set_page(struct scatterlist *sg, struct page *page,
+                   unsigned int len, unsigned int offset)
+{
+    sg->page = page;
+    sg->offset = offset;
+    sg->length = len;
+}
+
+static inline void sg_mark_end(struct scatterlist *sg)
+{
+    (void)sg;
+}
+#  endif
+
+int
+alloc_sg_list_from_pages(
+    struct scatterlist **sgl,
+    struct page **pages,
+    unsigned int  n_pages,
+    unsigned long offset,
+    unsigned long size,
+    unsigned int  *nents
+    )
+{
+    unsigned int chunks;
+    unsigned int i;
+    unsigned int cur_page;
+    struct scatterlist *s;
+
+    chunks = 1;
+
+    for (i = 1; i < n_pages; ++i)
+    {
+        if (page_to_pfn(pages[i]) != page_to_pfn(pages[i - 1]) + 1)
+        {
+            ++chunks;
+        }
+    }
+
+    s = kzalloc(sizeof(struct scatterlist) * chunks, GFP_KERNEL);
+    if (unlikely(!s))
+    {
+        return -ENOMEM;
+    }
+
+    *sgl = s;
+    *nents = chunks;
+
+    cur_page = 0;
+
+    for (i = 0; i < chunks; i++, s++)
+    {
+        unsigned long chunk_size;
+        unsigned int j;
+
+        for (j = cur_page + 1; j < n_pages; j++)
+        {
+            if (page_to_pfn(pages[j]) != page_to_pfn(pages[j - 1]) + 1)
+            {
+                break;
+            }
+        }
+
+        chunk_size = ((j - cur_page) << PAGE_SHIFT) - offset;
+        sg_set_page(s, pages[cur_page], min(size, chunk_size), offset);
+        size -= chunk_size;
+        offset = 0;
+        cur_page = j;
+    }
+
+    sg_mark_end(s - 1);
+
+    return 0;
+}
+#endif
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
index 30690f9..81801c7 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
@@ -153,9 +153,10 @@
     (*Mmap)(
         IN gckALLOCATOR Allocator,
         IN PLINUX_MDL Mdl,
+        IN gctBOOL Cacheable,
         IN gctSIZE_T skipPages,
         IN gctSIZE_T numPages,
-        INOUT struct vm_area_struct *vma
+        IN struct vm_area_struct *vma
         );
 
     /**************************************************************************
@@ -186,8 +187,8 @@
     (*MapUser)(
         IN gckALLOCATOR Allocator,
         IN PLINUX_MDL Mdl,
-        IN gctBOOL Cacheable,
-        OUT gctPOINTER * UserLogical
+        IN PLINUX_MDL_MAP MdlMap,
+        IN gctBOOL Cacheable
         );
 
     /**************************************************************************
@@ -215,7 +216,7 @@
     (*UnmapUser)(
         IN gckALLOCATOR Allocator,
         IN PLINUX_MDL Mdl,
-        IN gctPOINTER Logical,
+        IN PLINUX_MDL_MAP MdlMap,
         IN gctUINT32 Size
         );
 
@@ -524,6 +525,19 @@
     return status;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION (3,6,0) \
+    || (!defined (ARCH_HAS_SG_CHAIN) && !defined (CONFIG_ARCH_HAS_SG_CHAIN))
+int
+alloc_sg_list_from_pages(
+    struct scatterlist **sgl,
+    struct page **pages,
+    unsigned int  n_pages,
+    unsigned long offset,
+    unsigned long size,
+    unsigned int  *nents
+    );
+#endif
+
 /*
     How to implement customer allocator
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index c69dd5c..5543d1d 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -70,6 +70,10 @@
 
 extern gcTA globalTA[16];
 
+gceSTATUS
+gckGALDEVICE_QueryFrequency( IN gckGALDEVICE Device);
+
+
 /******************************************************************************\
 ******************************** Debugfs Support *******************************
 \******************************************************************************/
@@ -692,6 +696,42 @@ static int gc_dump_trigger_write(const char __user *buf, size_t count, void* dat
     return strtoint_from_user(buf, count, &dumpCore);
 }
 
+static int gc_clk_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckGALDEVICE device = node->device;
+    gctUINT i;
+
+    gckGALDEVICE_QueryFrequency(device);
+
+    for (i = gcvCORE_MAJOR; i < gcvCORE_COUNT; i++)
+    {
+        if (device->kernels[i])
+        {
+            gckHARDWARE hardware = device->kernels[i]->hardware;
+
+#if gcdENABLE_VG
+            if (i == gcvCORE_VG)
+            {
+                continue;
+            }
+#endif
+
+            if (hardware->mcClk)
+            {
+                seq_printf(m, "gpu%d mc clock: %d HZ.\n", i, hardware->mcClk);
+            }
+
+            if (hardware->shClk)
+            {
+                seq_printf(m, "gpu%d sh clock: %d HZ.\n", i, hardware->shClk);
+            }
+        }
+    }
+
+    return 0;
+}
+
 static gcsINFO InfoList[] =
 {
     {"info", gc_info_show},
@@ -702,6 +742,7 @@ static int gc_dump_trigger_write(const char __user *buf, size_t count, void* dat
     {"version", gc_version_show},
     {"vidmem", gc_vidmem_show, gc_vidmem_write},
     {"dump_trigger", gc_dump_trigger_show, gc_dump_trigger_write},
+    {"clk", gc_clk_show},
 };
 
 static gceSTATUS
@@ -2056,6 +2097,89 @@ static irqreturn_t isrRoutineVG(int irq, void *ctxt)
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckGALDEVICE_QueryFrequency(
+    IN gckGALDEVICE Device
+    )
+{
+    gctUINT64 mcStart[gcvCORE_COUNT], shStart[gcvCORE_COUNT];
+    gctUINT32 mcClk[gcvCORE_COUNT], shClk[gcvCORE_COUNT];
+    gckHARDWARE hardware = gcvNULL;
+    gceSTATUS status;
+    gctUINT i;
+
+    gcmkHEADER_ARG("Device=0x%p", Device);
+
+    for (i = gcvCORE_MAJOR; i < gcvCORE_COUNT; i++)
+    {
+#if gcdENABLE_VG
+        if (i == gcvCORE_VG)
+        {
+            continue;
+        }
+#endif
+
+        if (Device->kernels[i])
+        {
+            hardware = Device->kernels[i]->hardware;
+
+            mcStart[i] = shStart[i] = 0;
+
+            if (Device->args.powerManagement)
+            {
+                gcmkONERROR(gckHARDWARE_SetPowerManagement(
+                    hardware, gcvFALSE
+                    ));
+            }
+
+            gcmkONERROR(gckHARDWARE_SetPowerManagementState(
+                hardware, gcvPOWER_ON_AUTO
+                ));
+
+            gckHARDWARE_EnterQueryClock(hardware,
+                                        &mcStart[i], &shStart[i]);
+        }
+    }
+
+    gcmkONERROR(gckOS_Delay(Device->os, 50));
+
+    for (i = gcvCORE_MAJOR; i < gcvCORE_COUNT; i++)
+    {
+        mcClk[i] = shClk[i] = 0;
+
+#if gcdENABLE_VG
+        if (i == gcvCORE_VG)
+        {
+            continue;
+        }
+#endif
+
+        if (Device->kernels[i] && mcStart[i])
+        {
+            hardware = Device->kernels[i]->hardware;
+
+            if (Device->args.powerManagement)
+            {
+                gcmkONERROR(gckHARDWARE_SetPowerManagement(
+                    hardware, gcvTRUE
+                    ));
+            }
+
+            gckHARDWARE_ExitQueryClock(hardware,
+                                       mcStart[i], shStart[i],
+                                       &mcClk[i], &shClk[i]);
+
+            hardware->mcClk = mcClk[i];
+            hardware->shClk = shClk[i];
+        }
+    }
+
+OnError:
+    gcmkFOOTER_NO();
+
+    return status;
+}
+
 /*******************************************************************************
 **
 **  gckGALDEVICE_Start
@@ -2090,6 +2214,8 @@ static irqreturn_t isrRoutineVG(int irq, void *ctxt)
     /* Start the kernel thread. */
     gcmkONERROR(gckGALDEVICE_Start_Threads(Device));
 
+    gcmkONERROR(gckGALDEVICE_QueryFrequency(Device));
+
     for (i = 0; i < gcvCORE_COUNT; i++)
     {
         if (i == gcvCORE_VG)
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index b701738..b76b118 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -76,9 +76,9 @@
 #define USE_MSI     1
 #endif
 
-static struct class* gpuClass;
+static struct class* gpuClass = NULL;
 
-static gcsPLATFORM *platform;
+static gcsPLATFORM *platform = NULL;
 
 static gckGALDEVICE galDevice;
 
@@ -870,6 +870,8 @@ static void drv_exit(void)
 int viv_drm_remove(struct device *dev);
 #endif
 
+struct device *galcore_device = NULL;
+
 #if USE_LINUX_PCIE
 static int gpu_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 #else /* USE_LINUX_PCIE */
@@ -881,6 +883,8 @@ static int gpu_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 #endif /* USE_LINUX_PCIE */
 {
     int ret = -ENODEV;
+    static u64 dma_mask = ~0ULL;
+
     gcsMODULE_PARAMETERS moduleParam = {
         .irqLine            = irqLine,
         .registerMemBase    = registerMemBase,
@@ -916,8 +920,12 @@ static int gpu_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
     memcpy(moduleParam.registerBases, registerBases, gcmSIZEOF(gctUINT) * gcvCORE_COUNT);
     memcpy(moduleParam.registerSizes, registerSizes, gcmSIZEOF(gctUINT) * gcvCORE_COUNT);
     memcpy(moduleParam.chipIDs, chipIDs, gcmSIZEOF(gctUINT) * gcvCORE_COUNT);
-    moduleParam.compression = compression;
+    moduleParam.compression = (compression == -1) ? gcvCOMPRESSION_OPTION_DEFAULT : (gceCOMPRESSION_OPTION)compression;
     platform->device = pdev;
+    galcore_device = &pdev->dev;
+
+    galcore_device->dma_mask = &dma_mask;
+
 #if USE_LINUX_PCIE
     if (pci_enable_device(pdev)) {
         printk(KERN_ERR "galcore: pci_enable_device() failed.\n");
@@ -1018,6 +1026,8 @@ static void gpu_remove(struct pci_dev *pdev)
     gcmkFOOTER_NO();
     return;
 #else
+    galcore_device->dma_mask = NULL;
+    galcore_device = NULL;
     gcmkFOOTER_NO();
     return 0;
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_drm.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_drm.c
index b4846cb..7e8e8a8 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_drm.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_drm.c
@@ -284,6 +284,7 @@ static int viv_ioctl_gem_unlock(struct drm_device *drm, void *data,
     {
         gcmkONERROR(gcvSTATUS_NOT_FOUND);
     }
+    drm_gem_object_unreference_unlocked(gem_obj);
     viv_obj = container_of(gem_obj, struct viv_gem_object, base);
 
     memset(&iface, 0, sizeof(iface));
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
index bcda2c1..5efa3d4 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
@@ -463,12 +463,6 @@
 {
     gceSTATUS status;
 
-    gcmkHEADER_ARG("Kernel=%p Notification=%d Data=%d",
-                   Kernel, Notification, Data);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
-
     /* Dispatch on notifcation. */
     switch (Notification)
     {
@@ -477,8 +471,7 @@
 #if COMMAND_PROCESSOR_VERSION > 1
         status = gckINTERRUPT_Notify(Kernel->interrupt, Data);
 #else
-        status = gckHARDWARE_Interrupt(Kernel->hardware,
-                                       Data);
+        status = gckHARDWARE_Interrupt(Kernel->hardware, Data);
 #endif
         break;
 
@@ -488,7 +481,6 @@
     }
 
     /* Success. */
-    gcmkFOOTER();
     return status;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
index f1ae2b1..b613b08 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -148,6 +148,8 @@
 #   endif
 #endif
 
+extern struct device *galcore_device;
+
 /******************************************************************************\
 ********************************** Structures **********************************
 \******************************************************************************/
@@ -332,6 +334,26 @@ struct _gckOS
 #endif
 }
 
+static inline void
+_MemoryBarrier(
+    void
+    )
+{
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+    dsb();
+#else
+    mb();
+#endif
+}
+
+static inline void
+_Barrier(
+    void
+    )
+{
+    barrier();
+}
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
 static inline int
 is_vmalloc_addr(
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index 4b0a2ff..0209e9f 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -94,7 +94,7 @@
     do { \
         if (unlikely(!!(x))) \
         { \
-            gcmkPRINT("[galcore]: BUG ON @ %s(%d)", __func__, __LINE__); \
+            printk("[galcore]: BUG ON @ %s(%d)\n", __func__, __LINE__); \
             dump_stack(); \
         } \
     } while (0)
@@ -457,111 +457,6 @@
     }
 }
 
-#if !gcdCACHE_FUNCTION_UNIMPLEMENTED && defined(CONFIG_OUTER_CACHE)
-static inline gceSTATUS
-outer_func(
-    gceCACHEOPERATION Type,
-    unsigned long Start,
-    unsigned long End
-    )
-{
-    switch (Type)
-    {
-        case gcvCACHE_CLEAN:
-            outer_clean_range(Start, End);
-            break;
-        case gcvCACHE_INVALIDATE:
-            outer_inv_range(Start, End);
-            break;
-        case gcvCACHE_FLUSH:
-            outer_flush_range(Start, End);
-            break;
-        default:
-            return gcvSTATUS_INVALID_ARGUMENT;
-            break;
-    }
-    return gcvSTATUS_OK;
-}
-
-/*******************************************************************************
-**  _HandleOuterCache
-**
-**  Handle the outer cache for the specified addresses.
-**
-**  ARGUMENTS:
-**
-**      gckOS Os
-**          Pointer to gckOS object.
-**
-**      gctPOINTER Physical
-**          Physical address to flush.
-**
-**      gctPOINTER Logical
-**          Logical address to flush.
-**
-**      gctSIZE_T Bytes
-**          Size of the address range in bytes to flush.
-**
-**      gceOUTERCACHE_OPERATION Type
-**          Operation need to be execute.
-*/
-gceSTATUS
-_HandleOuterCache(
-    IN gckOS Os,
-    IN gctUINT32 Physical,
-    IN gctPOINTER Logical,
-    IN gctSIZE_T Bytes,
-    IN gceCACHEOPERATION Type
-    )
-{
-    gceSTATUS status;
-    gctPHYS_ADDR_T paddr;
-    gctPOINTER vaddr;
-    gctUINT32 offset, bytes, left;
-
-    gcmkHEADER_ARG("Os=0x%X Logical=0x%X Bytes=%lu",
-                   Os, Logical, Bytes);
-
-    if (Physical != gcvINVALID_ADDRESS)
-    {
-        /* Non paged memory or gcvPOOL_USER surface */
-        paddr = (unsigned long) Physical;
-        gcmkONERROR(outer_func(Type, paddr, paddr + Bytes));
-    }
-    else
-    {
-        /* Non contiguous virtual memory */
-        vaddr = Logical;
-        left = Bytes;
-
-        while (left)
-        {
-            /* Handle (part of) current page. */
-            offset = (gctUINTPTR_T)vaddr & ~PAGE_MASK;
-
-            bytes = gcmMIN(left, PAGE_SIZE - offset);
-
-            gcmkONERROR(_QueryProcessPageTable(vaddr, &paddr));
-            gcmkONERROR(outer_func(Type, paddr, paddr + bytes));
-
-            vaddr = (gctUINT8_PTR)vaddr + bytes;
-            left -= bytes;
-        }
-    }
-
-    mb();
-
-    /* Success. */
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
-
-OnError:
-    /* Return the status. */
-    gcmkFOOTER();
-    return status;
-}
-#endif
-
 
 static gceSTATUS
 _ShrinkMemory(
@@ -1122,8 +1017,8 @@
 
         gcmkONERROR(
             allocator->ops->MapUser(allocator,
-                                    mdl, gcvFALSE,
-                                    &mdlMap->vmaAddr));
+                                    mdl, mdlMap,
+                                    gcvFALSE));
     }
 
     mutex_unlock(&mdl->mapsMutex);
@@ -1256,8 +1151,8 @@
 
         BUG_ON(!allocator || !allocator->ops->UnmapUser);
 
-        allocator->ops->UnmapUser(allocator, mdl,
-                mdlMap->vmaAddr, mdl->numPages * PAGE_SIZE);
+        allocator->ops->UnmapUser(allocator, mdl, mdlMap,
+                mdl->numPages * PAGE_SIZE);
 
         gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
 
@@ -1332,6 +1227,9 @@
 **      gctBOOL InUserSpace
 **          gcvTRUE if the pages need to be mapped into user space.
 **
+**      gctUINT32 Flag
+**          Allocation attribute.
+**
 **      gctSIZE_T * Bytes
 **          Pointer to a variable that holds the number of bytes to allocate.
 **
@@ -1352,6 +1250,7 @@
 gckOS_AllocateNonPagedMemory(
     IN gckOS Os,
     IN gctBOOL InUserSpace,
+    IN gctUINT32 Flag,
     IN OUT gctSIZE_T * Bytes,
     OUT gctPHYS_ADDR * Physical,
     OUT gctPOINTER * Logical
@@ -1364,7 +1263,6 @@
     gctPOINTER addr;
     gceSTATUS status = gcvSTATUS_NOT_SUPPORTED;
     gckALLOCATOR allocator;
-    gctUINT32 flag = gcvALLOC_FLAG_CONTIGUOUS;
 
     gcmkHEADER_ARG("Os=0x%X InUserSpace=%d *Bytes=%lu",
                    Os, InUserSpace, gcmOPT_VALUE(Bytes));
@@ -1389,9 +1287,12 @@
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
+    gcmkASSERT(Flag & gcvALLOC_FLAG_CONTIGUOUS);
+
     if (Os->allocatorLimitMarker)
     {
-        flag |= gcvALLOC_FLAG_CMA_LIMIT;
+        Flag |= gcvALLOC_FLAG_CMA_LIMIT;
+        Flag |= gcvALLOC_FLAG_CMA_PREEMPT;
     }
 
     /* Walk all allocators. */
@@ -1399,25 +1300,34 @@
     {
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
                        "%s(%d) flag = %x allocator->capability = %x",
-                        __FUNCTION__, __LINE__, flag, allocator->capability);
+                        __FUNCTION__, __LINE__, Flag, allocator->capability);
 
 #ifndef NO_DMA_COHERENT
         /* Point to dma coherent allocator. */
         if (strcmp(allocator->name, "dma"))
         {
-            if (((flag & allocator->capability) != flag) ||
+            /*!VIV:
+             * For historical issue, we force allocate all non-paged memory from
+             * dma coherent pool when it is not disabled.
+             *
+             * The code below changes the scheme a little: force allocate
+             * non-paged memory whose size is larger than 1 pages, can try other
+             * allocators otherwise. This is to save memory usage of dma
+             * coherent pool.
+             */
+            if (((Flag & allocator->capability) != Flag) ||
                 (numPages > 1))
             {
                 continue;
             }
         }
 #else
-        if ((flag & allocator->capability) != flag)
+        if ((Flag & allocator->capability) != Flag)
         {
             continue;
         }
 #endif
-        status = allocator->ops->Alloc(allocator, mdl, numPages, flag);
+        status = allocator->ops->Alloc(allocator, mdl, numPages, Flag);
 
         if (gcmIS_SUCCESS(status))
         {
@@ -1449,7 +1359,7 @@
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
 
-        gcmkONERROR(allocator->ops->MapUser(allocator, mdl, gcvFALSE, &mdlMap->vmaAddr));
+        gcmkONERROR(allocator->ops->MapUser(allocator, mdl, mdlMap, gcvFALSE));
 
         *Logical = mdlMap->vmaAddr;
     }
@@ -1684,40 +1594,53 @@ gceSTATUS gckOS_FreeNonPagedMemory(
     OUT gctUINT32 * Data
     )
 {
-    unsigned long flags;
+    if (in_irq())
+    {
+        spin_lock(&Os->registerAccessLock);
+
+        if (unlikely(Os->clockStates[Core] == gcvFALSE))
+        {
+            spin_unlock(&Os->registerAccessLock);
 
-    spin_lock_irqsave(&Os->registerAccessLock, flags);
+            /*
+             * Read register when power off:
+             * 1. In shared IRQ, read register may be called and that's not our irq.
+             */
+            return gcvSTATUS_GENERIC_IO;
+        }
 
-    if (unlikely(Os->clockStates[Core] == gcvFALSE))
+        *Data = readl((gctUINT8 *)Os->device->registerBases[Core] + Address);
+        spin_unlock(&Os->registerAccessLock);
+    }
+    else
     {
-        spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+        unsigned long flags;
 
-        /*
-         * Read register when power off:
-         * 1. In shared IRQ, read register may be called and that's not our irq.
-         * 2. In non-irq context, register access should not be called,
-         *    otherwise it's driver bug.
-         */
-        if (!in_irq())
+        spin_lock_irqsave(&Os->registerAccessLock, flags);
+
+        if (unlikely(Os->clockStates[Core] == gcvFALSE))
         {
-            gcmkPRINT("[galcore]: %s(%d) GPU[%d] external clock off",
-                      __func__, __LINE__, Core);
+            spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+
+            /*
+             * Read register when power off:
+             * 2. In non-irq context, register access should not be called,
+             *    otherwise it's driver bug.
+             */
+            printk(KERN_ERR "[galcore]: %s(%d) GPU[%d] external clock off",
+                   __func__, __LINE__, Core);
             gcmkBUG_ON(1);
+            return gcvSTATUS_GENERIC_IO;
         }
 
-        return gcvSTATUS_GENERIC_IO;
-    }
-
-    *Data = readl((gctUINT8 *)Os->device->registerBases[Core] + Address);
-    spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+        *Data = readl((gctUINT8 *)Os->device->registerBases[Core] + Address);
+        spin_unlock_irqrestore(&Os->registerAccessLock, flags);
 
 #if gcdDUMP_AHB_ACCESS
-    if (!in_irq())
-    {
         /* Dangerous to print in interrupt context, skip. */
         gcmkPRINT("@[RD %d] %08x %08x", Core, Address, *Data);
-    }
 #endif
+    }
 
     /* Success. */
     return gcvSTATUS_OK;
@@ -1762,32 +1685,51 @@ gceSTATUS gckOS_FreeNonPagedMemory(
     IN gctUINT32 Data
     )
 {
-    unsigned long flags;
+    if (in_irq())
+    {
+        spin_lock(&Os->registerAccessLock);
 
-    spin_lock_irqsave(&Os->registerAccessLock, flags);
+        if (unlikely(Os->clockStates[Core] == gcvFALSE))
+        {
+            spin_unlock(&Os->registerAccessLock);
 
-    if (unlikely(Os->clockStates[Core] == gcvFALSE))
-    {
-        spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+            printk(KERN_ERR "[galcore]: %s(%d) GPU[%d] external clock off",
+                   __func__, __LINE__, Core);
 
-        gcmkPRINT("[galcore]: %s(%d) GPU[%d] external clock off",
-                  __func__, __LINE__, Core);
+            /* Driver bug: register write when clock off. */
+            gcmkBUG_ON(1);
+            return gcvSTATUS_GENERIC_IO;
+        }
 
-        /* Driver bug: register write when clock off. */
-        gcmkBUG_ON(1);
-        return gcvSTATUS_GENERIC_IO;
+        writel(Data, (gctUINT8 *)Os->device->registerBases[Core] + Address);
+        spin_unlock(&Os->registerAccessLock);
     }
+    else
+    {
+        unsigned long flags;
 
-    writel(Data, (gctUINT8 *)Os->device->registerBases[Core] + Address);
-    spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+        spin_lock_irqsave(&Os->registerAccessLock, flags);
+
+        if (unlikely(Os->clockStates[Core] == gcvFALSE))
+        {
+            spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+
+            printk(KERN_ERR "[galcore]: %s(%d) GPU[%d] external clock off",
+                      __func__, __LINE__, Core);
+
+            /* Driver bug: register write when clock off. */
+            gcmkBUG_ON(1);
+            return gcvSTATUS_GENERIC_IO;
+        }
+
+        writel(Data, (gctUINT8 *)Os->device->registerBases[Core] + Address);
+        spin_unlock_irqrestore(&Os->registerAccessLock, flags);
 
 #if gcdDUMP_AHB_ACCESS
-    if (!in_irq())
-    {
         /* Dangerous to print in interrupt context, skip. */
         gcmkPRINT("@[WR %d] %08x %08x", Core, Address, Data);
-    }
 #endif
+    }
 
     /* Success. */
     return gcvSTATUS_OK;
@@ -1964,8 +1906,6 @@ gceSTATUS gckOS_GetPageSize(
             _GetPhysicalAddressProcess(Os, Logical, processID, Address));
     }
 
-    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Os, *Address, Address));
-
     /* Success. */
     gcmkFOOTER_ARG("*Address=%p", *Address);
     return gcvSTATUS_OK;
@@ -2525,17 +2465,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     OUT gctUINT32_PTR OldValue
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Target=0x%X NewValue=%u", Os, Target, NewValue);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(OldValue != gcvNULL);
-
     /* Exchange the pair of 32-bit values. */
     *OldValue = (gctUINT32) atomic_xchg((atomic_t *) Target, (int) NewValue);
-
-    /* Success. */
-    gcmkFOOTER_ARG("*OldValue=%u", *OldValue);
     return gcvSTATUS_OK;
 }
 
@@ -2571,17 +2502,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     OUT gctPOINTER * OldValue
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Target=0x%X NewValue=0x%X", Os, Target, NewValue);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(OldValue != gcvNULL);
-
     /* Exchange the pair of pointers. */
     *OldValue = (gctPOINTER)(gctUINTPTR_T) atomic_xchg((atomic_t *) Target, (int)(gctUINTPTR_T) NewValue);
-
-    /* Success. */
-    gcmkFOOTER_ARG("*OldValue=0x%X", *OldValue);
     return gcvSTATUS_OK;
 }
 
@@ -2609,18 +2531,12 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     )
 {
     gctUINT32 oval, nval;
-
-    gcmkHEADER_ARG("Atom=0x%0x", Atom);
-    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
-
     do
     {
         oval = atomic_read((atomic_t *) Atom);
         nval = oval | Mask;
     }
     while (atomic_cmpxchg((atomic_t *) Atom, oval, nval) != oval);
-
-    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
 
@@ -2649,9 +2565,6 @@ gceSTATUS gckOS_UserLogicalToPhysical(
 {
     gctUINT32 oval, nval;
 
-    gcmkHEADER_ARG("Atom=0x%0x", Atom);
-    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
-
     do
     {
         oval = atomic_read((atomic_t *) Atom);
@@ -2659,7 +2572,6 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     }
     while (atomic_cmpxchg((atomic_t *) Atom, oval, nval) != oval);
 
-    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
 
@@ -2780,17 +2692,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     OUT gctINT32_PTR Value
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Atom=0x%0x", Os, Atom);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
-
     /* Return the current value of atom. */
     *Value = atomic_read((atomic_t *) Atom);
-
-    /* Success. */
-    gcmkFOOTER_ARG("*Value=%d", *Value);
     return gcvSTATUS_OK;
 }
 
@@ -2822,17 +2725,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     IN gctINT32 Value
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Atom=0x%0x Value=%d", Os, Atom);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
-
     /* Set the current value of atom. */
     atomic_set((atomic_t *) Atom, Value);
-
-    /* Success. */
-    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
 
@@ -2862,17 +2756,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     OUT gctINT32_PTR Value
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Atom=0x%0x", Os, Atom);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
-
     /* Increment the atom. */
     *Value = atomic_inc_return((atomic_t *) Atom) - 1;
-
-    /* Success. */
-    gcmkFOOTER_ARG("*Value=%d", *Value);
     return gcvSTATUS_OK;
 }
 
@@ -2902,17 +2787,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     OUT gctINT32_PTR Value
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Atom=0x%0x", Os, Atom);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
-
     /* Decrement the atom. */
     *Value = atomic_dec_return((atomic_t *) Atom) + 1;
-
-    /* Success. */
-    gcmkFOOTER_ARG("*Value=%d", *Value);
     return gcvSTATUS_OK;
 }
 
@@ -3074,24 +2950,8 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     IN gctPOINTER Address
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Address=0x%X", Os, Address);
+    _MemoryBarrier();
 
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-
-#if gcdNONPAGED_MEMORY_BUFFERABLE \
-    && defined (CONFIG_ARM) \
-    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
-    /* drain write buffer */
-    dsb();
-
-    /* drain outer cache's write buffer? */
-#else
-    mb();
-#endif
-
-    /* Success. */
-    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
 
@@ -3393,7 +3253,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
-        status = allocator->ops->MapUser(allocator, mdl, Cacheable, &mdlMap->vmaAddr);
+        status = allocator->ops->MapUser(allocator, mdl, mdlMap, Cacheable);
 
         if (gcmIS_ERROR(status))
         {
@@ -3717,7 +3577,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
                 allocator->ops->UnmapUser(
                     allocator,
                     mdl,
-                    mdlMap->vmaAddr,
+                    mdlMap,
                     mdl->numPages * PAGE_SIZE);
 
                 mdlMap->vmaAddr = gcvNULL;
@@ -3787,6 +3647,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     /* Same as non-paged memory for now. */
     gcmkONERROR(gckOS_AllocateNonPagedMemory(Os,
                                              InUserSpace,
+                                             gcvALLOC_FLAG_CONTIGUOUS,
                                              Bytes,
                                              Physical,
                                              Logical));
@@ -4513,6 +4374,55 @@ gceSTATUS gckOS_UserLogicalToPhysical(
 /*******************************************************************************
 ********************************* Cache Control ********************************
 *******************************************************************************/
+static gceSTATUS
+_CacheOperation(
+    IN gckOS Os,
+    IN gctUINT32 ProcessID,
+    IN gctPHYS_ADDR Handle,
+    IN gctPHYS_ADDR_T Physical,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes,
+    IN gceCACHEOPERATION Operation
+    )
+{
+    PLINUX_MDL mdl = (PLINUX_MDL)Handle;
+    PLINUX_MDL_MAP mdlMap;
+    gckALLOCATOR allocator;
+
+    if (!mdl || !mdl->allocator)
+    {
+        gcmkPRINT("[galcore]: %s: Logical=%p no mdl", __FUNCTION__, Logical);
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
+    allocator = mdl->allocator;
+
+    if (allocator->ops->Cache)
+    {
+        mutex_lock(&mdl->mapsMutex);
+
+        mdlMap = FindMdlMap(mdl, ProcessID);
+
+        mutex_unlock(&mdl->mapsMutex);
+
+        if (mdlMap == gcvNULL)
+        {
+            return gcvSTATUS_INVALID_ARGUMENT;
+        }
+
+        if (mdlMap->cacheable)
+        {
+            allocator->ops->Cache(allocator,
+                mdl, Logical, Physical, Bytes, Operation);
+
+            return gcvSTATUS_OK;
+        }
+    }
+
+    _MemoryBarrier();
+
+    return gcvSTATUS_OK;
+}
 
 /*******************************************************************************
 **  gckOS_CacheClean
@@ -4572,7 +4482,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     IN gctSIZE_T Bytes
     )
 {
-    gcsPLATFORM * platform;
+    gceSTATUS status;
 
     gcmkHEADER_ARG("Os=0x%X ProcessID=%d Handle=0x%X Logical=%p Bytes=%lu",
                    Os, ProcessID, Handle, Logical, Bytes);
@@ -4582,61 +4492,14 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
 
-    platform = Os->device->platform;
-
-    if (platform && platform->ops->cache)
-    {
-        platform->ops->cache(
-            platform,
-            ProcessID,
-            Handle,
-            Physical,
-            Logical,
-            Bytes,
-            gcvCACHE_CLEAN
-            );
-
-        /* Success. */
-        gcmkFOOTER_NO();
-        return gcvSTATUS_OK;
-    }
-
-#if !gcdCACHE_FUNCTION_UNIMPLEMENTED
-#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-
-#if defined (CONFIG_ARM)
-    /* Inner cache. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
-    dmac_map_area(Logical, Bytes, DMA_TO_DEVICE);
-#      else
-    dmac_clean_range(Logical, Logical + Bytes);
-#      endif
-
-#elif defined(CONFIG_ARM64)
-    __dma_map_area(Logical, Bytes, DMA_TO_DEVICE);
-#endif
-
-#if defined(CONFIG_OUTER_CACHE)
-    /* Outer cache. */
-    _HandleOuterCache(Os, Physical, Logical, Bytes, gcvCACHE_CLEAN);
-#endif
+    gcmkONERROR(_CacheOperation(Os, ProcessID,
+                                Handle, Physical, Logical, Bytes,
+                                gcvCACHE_CLEAN));
 
-#elif defined(CONFIG_MIPS)
-    dma_cache_wback((unsigned long) Logical, Bytes);
-#elif defined(CONFIG_PPC)
-    flush_dcache_range((unsigned long)Logical, (unsigned long)Logical + Bytes);
-#else
-    dma_sync_single_for_device(
-              gcvNULL,
-              (dma_addr_t)Physical,
-              Bytes,
-              DMA_TO_DEVICE);
-#endif
-#endif
+OnError:
+    gcmkFOOTER();
+    return status;
 
-    /* Success. */
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
 }
 
 /*******************************************************************************
@@ -4673,7 +4536,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     IN gctSIZE_T Bytes
     )
 {
-    gcsPLATFORM * platform;
+    gceSTATUS status;
 
     gcmkHEADER_ARG("Os=0x%X ProcessID=%d Handle=0x%X Logical=%p Bytes=%lu",
                    Os, ProcessID, Handle, Logical, Bytes);
@@ -4683,60 +4546,13 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
 
-    platform = Os->device->platform;
-
-    if (platform && platform->ops->cache)
-    {
-        platform->ops->cache(
-            platform,
-            ProcessID,
-            Handle,
-            Physical,
-            Logical,
-            Bytes,
-            gcvCACHE_INVALIDATE
-            );
-
-        /* Success. */
-        gcmkFOOTER_NO();
-        return gcvSTATUS_OK;
-    }
-
-#if !gcdCACHE_FUNCTION_UNIMPLEMENTED
-#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-
-#if defined (CONFIG_ARM)
-    /* Inner cache. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
-    dmac_unmap_area(Logical, Bytes, DMA_FROM_DEVICE);
-#      else
-    dmac_inv_range(Logical, Logical + Bytes);
-#      endif
-#elif defined(CONFIG_ARM64)
-    __dma_unmap_area(Logical, Bytes, DMA_FROM_DEVICE);
-#endif
+    gcmkONERROR(_CacheOperation(Os, ProcessID,
+                                Handle, Physical, Logical, Bytes,
+                                gcvCACHE_INVALIDATE));
 
-#if defined(CONFIG_OUTER_CACHE)
-    /* Outer cache. */
-    _HandleOuterCache(Os, Physical, Logical, Bytes, gcvCACHE_INVALIDATE);
-#endif
-
-#elif defined(CONFIG_MIPS)
-    dma_cache_inv((unsigned long) Logical, Bytes);
-#elif defined(CONFIG_PPC)
-    flush_dcache_range((unsigned long)Logical, (unsigned long)Logical + Bytes);
-#else
-    dma_sync_single_for_device(
-              gcvNULL,
-              (dma_addr_t)Physical,
-              Bytes,
-              DMA_FROM_DEVICE);
-#endif
-#endif
-
-    /* Success. */
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
+OnError:
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
@@ -4773,7 +4589,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     IN gctSIZE_T Bytes
     )
 {
-    gcsPLATFORM * platform;
+    gceSTATUS status;
 
     gcmkHEADER_ARG("Os=0x%X ProcessID=%d Handle=0x%X Logical=%p Bytes=%lu",
                    Os, ProcessID, Handle, Logical, Bytes);
@@ -4783,61 +4599,13 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
 
-    platform = Os->device->platform;
-
-    if (platform && platform->ops->cache)
-    {
-        platform->ops->cache(
-            platform,
-            ProcessID,
-            Handle,
-            Physical,
-            Logical,
-            Bytes,
-            gcvCACHE_FLUSH
-            );
-
-        /* Success. */
-        gcmkFOOTER_NO();
-        return gcvSTATUS_OK;
-    }
-
-#if !gcdCACHE_FUNCTION_UNIMPLEMENTED
-#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-#if defined (CONFIG_ARM)
-    /* Inner cache. */
-    dmac_flush_range(Logical, Logical + Bytes);
-#elif defined (CONFIG_ARM64)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
-    __dma_flush_area(Logical, Bytes);
-#else
-    __dma_flush_range(Logical, Logical + Bytes);
-#endif
-#endif
-
-#if defined(CONFIG_OUTER_CACHE)
-    /* Outer cache. */
-    _HandleOuterCache(Os, Physical, Logical, Bytes, gcvCACHE_FLUSH);
-#endif
+    gcmkONERROR(_CacheOperation(Os, ProcessID,
+                                Handle, Physical, Logical, Bytes,
+                                gcvCACHE_FLUSH));
 
-#elif defined(CONFIG_MIPS)
-    dma_cache_wback_inv((unsigned long) Logical, Bytes);
-#elif defined(CONFIG_PPC)
-    flush_dcache_range((unsigned long)Logical, (unsigned long)Logical + Bytes);
-#elif defined(CONFIG_X86)
-    wbinvd_on_all_cpus();
-#else
-    dma_sync_single_for_device(
-              gcvNULL,
-              (dma_addr_t)Physical,
-              Bytes,
-              DMA_BIDIRECTIONAL);
-#endif
-#endif
-
-    /* Success. */
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
+OnError:
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
@@ -5385,18 +5153,6 @@ gceSTATUS gckOS_UserLogicalToPhysical(
 
     clockChange = (Clock != Os->clockStates[Core]);
 
-    if (clockChange)
-    {
-        unsigned long flags;
-
-        spin_lock_irqsave(&Os->registerAccessLock, flags);
-
-        /* Record clock states, ahead. */
-        Os->clockStates[Core] = Clock;
-
-        spin_unlock_irqrestore(&Os->registerAccessLock, flags);
-    }
-
     if (powerChange && (Power == gcvTRUE))
     {
         if (platform && platform->ops->setPower)
@@ -5409,10 +5165,32 @@ gceSTATUS gckOS_UserLogicalToPhysical(
 
     if (clockChange)
     {
+        unsigned long flags;
+
+        if (!Clock)
+        {
+            spin_lock_irqsave(&Os->registerAccessLock, flags);
+
+            /* Record clock off, ahead. */
+            Os->clockStates[Core] = gcvFALSE;
+
+            spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+        }
+
         if (platform && platform->ops->setClock)
         {
             gcmkVERIFY_OK(platform->ops->setClock(platform, Core, Clock));
         }
+
+        if (Clock)
+        {
+            spin_lock_irqsave(&Os->registerAccessLock, flags);
+
+            /* Record clock on, behind. */
+            Os->clockStates[Core] = gcvTRUE;
+
+            spin_unlock_irqrestore(&Os->registerAccessLock, flags);
+        }
     }
 
     if (powerChange && (Power == gcvFALSE))
@@ -7334,6 +7112,7 @@ gceSTATUS gckOS_UserLogicalToPhysical(
     gcmkONERROR(gckOS_AllocateNonPagedMemory(
         Os,
         gcvFALSE,
+        gcvALLOC_FLAG_CONTIGUOUS,
         &bytes,
         PageArrayPhysical,
         PageArrayLogical
@@ -7606,8 +7385,10 @@ static int fd_release(struct inode *inode, struct file *file)
     )
 {
     PLINUX_MDL mdl;
+    PLINUX_MDL_MAP mdlMap;
     gckALLOCATOR allocator;
     gceSTATUS status = gcvSTATUS_OK;
+    gctBOOL cacheable = gcvFALSE;
 
     if (!Physical)
     {
@@ -7622,7 +7403,17 @@ static int fd_release(struct inode *inode, struct file *file)
         gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
     }
 
-    gcmkONERROR(allocator->ops->Mmap(allocator, mdl, skipPages, numPages, Vma));
+    mutex_lock(&mdl->mapsMutex);
+
+    mdlMap = FindMdlMap(mdl, _GetProcessID());
+    if (mdlMap)
+    {
+        cacheable = mdlMap->cacheable;
+    }
+
+    mutex_unlock(&mdl->mapsMutex);
+
+    gcmkONERROR(allocator->ops->Mmap(allocator, mdl, cacheable, skipPages, numPages, Vma));
 
 OnError:
     return status;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
index 57cd01a..46bbe76 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -62,9 +62,14 @@
 struct _LINUX_MDL_MAP
 {
     gctINT                  pid;
-    gctPOINTER              vmaAddr;
+
+    /* map references. */
     gctUINT32               count;
 
+    struct vm_area_struct * vma;
+    gctPOINTER              vmaAddr;
+    gctBOOL                 cacheable;
+
     struct list_head        link;
 };
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx.c
index 1d59805..25805f3 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx.c
@@ -124,17 +124,6 @@
 #  define gcdFSL_CONTIGUOUS_SIZE (4 << 20)
 #endif
 
-#if defined(CONFIG_PM_OPP)
-typedef enum _gceGOVERN_MODE
-{
-    OVERDRIVE,
-    NOMINAL,
-    UNDERDRIVE,
-    GOVERN_COUNT
-}
-gceGOVERN_MODE;
-#endif
-
 static int initgpu3DMinClock = 1;
 module_param(initgpu3DMinClock, int, 0644);
 
@@ -380,6 +369,22 @@ struct gpu_clk
 };
 
 #if defined(CONFIG_PM_OPP)
+typedef enum _GOVERN_MODE
+{
+    OVERDRIVE,
+    NOMINAL,
+    UNDERDRIVE,
+    GOVERN_COUNT
+}
+GOVERN_MODE;
+
+static const char *govern_modes[] =
+{
+    "overdrive",
+    "nominal",
+    "underdrive"
+};
+
 struct gpu_govern
 {
     unsigned long core_clk_freq[GOVERN_COUNT];
@@ -421,101 +426,76 @@ struct imx_priv
 static struct imx_priv imxPriv;
 
 #if defined(CONFIG_PM_OPP)
-static ssize_t gpu_mode_show(struct device_driver *dev, char *buf)
+static ssize_t gpu_govern_show(struct device_driver *dev, char *buf)
 {
     struct imx_priv *priv = &imxPriv;
-    char buffer[512];
-    char mode[16] = "undefined\n";
     int i;
+    ssize_t len;
 
-    unsigned long core_freq = 0;
-    unsigned long shader_freq = 0;
+    unsigned long core_freq;
+    unsigned long shader_freq;
 
-    snprintf(buf, 512, "GPU support %d modes\n", priv->imx_gpu_govern.num_modes);
+    len = sprintf(buf, "GPU support %d modes\n", priv->imx_gpu_govern.num_modes);
 
-    for(i = 0;i<priv->imx_gpu_govern.num_modes;i++)
+    for (i = 0; i < priv->imx_gpu_govern.num_modes; i++)
     {
-        switch(i){
-            case OVERDRIVE:
-                core_freq = priv->imx_gpu_govern.core_clk_freq[i];
-                shader_freq = priv->imx_gpu_govern.shader_clk_freq[i];
-                snprintf(buffer, 512, "overdrive:\tcore_clk frequency: %ld\tshader_clk frequency: %ld\n", core_freq,shader_freq);
-                strcat(buf,buffer);
-                if(OVERDRIVE == priv->imx_gpu_govern.current_mode)
-                    strcpy(mode,"overdrive\n");
-                break;
-            case NOMINAL:
-                core_freq = priv->imx_gpu_govern.core_clk_freq[i];
-                shader_freq = priv->imx_gpu_govern.shader_clk_freq[i];
-                snprintf(buffer, 512, "nominal:\tcore_clk frequency: %ld\tshader_clk frequency: %ld\n", core_freq,shader_freq);
-                strcat(buf,buffer);
-                if(NOMINAL == priv->imx_gpu_govern.current_mode)
-                    strcpy(mode,"nominal\n");
-                break;
-            case UNDERDRIVE:
-                core_freq = priv->imx_gpu_govern.core_clk_freq[i];
-                shader_freq = priv->imx_gpu_govern.shader_clk_freq[i];
-                snprintf(buffer, 512, "underdrive:\tcore_clk frequency: %ld\tshader_clk frequency: %ld\n", core_freq,shader_freq);
-                strcat(buf,buffer);
-                if(UNDERDRIVE == priv->imx_gpu_govern.current_mode)
-                    strcpy(mode,"underdrive\n");
-                break;
-            default:
-                strcpy(mode,"undefined\n");
-                break;
-        }
+        core_freq   = priv->imx_gpu_govern.core_clk_freq[i];
+        shader_freq = priv->imx_gpu_govern.shader_clk_freq[i];
+
+        len += sprintf(buf + len,
+            "%s:\tcore_clk frequency: %lu\tshader_clk frequency: %lu\n",
+            govern_modes[i], core_freq, shader_freq);
     }
-    strcat(buf,"Currently GPU runs on mode ");
-    strcat(buf,mode);
-    return strlen(buf);
+
+    len += sprintf(buf + len, "Currently GPU runs on mode %s\n",
+        govern_modes[priv->imx_gpu_govern.current_mode]);
+
+    return len;
 }
 
-static ssize_t gpu_mode_store(struct device_driver *dev, const char *buf, size_t count)
+static ssize_t gpu_govern_store(struct device_driver *dev, const char *buf, size_t count)
 {
     unsigned long core_freq = 0;
     unsigned long shader_freq = 0;
     struct imx_priv *priv = &imxPriv;
     int core = gcvCORE_MAJOR;
+    int i;
 
-    do{
-        if(strstr(buf,"overdrive"))
-        {
-            core_freq = priv->imx_gpu_govern.core_clk_freq[OVERDRIVE];
-            shader_freq = priv->imx_gpu_govern.shader_clk_freq[OVERDRIVE];
-            priv->imx_gpu_govern.current_mode = OVERDRIVE;
-            break;
-        }
-        if(strstr(buf,"nominal"))
-        {
-            core_freq = priv->imx_gpu_govern.core_clk_freq[NOMINAL];
-            shader_freq = priv->imx_gpu_govern.shader_clk_freq[NOMINAL];
-            priv->imx_gpu_govern.current_mode = NOMINAL;
-            break;
-        }
-        if(strstr(buf,"underdrive"))
+    for (i = 0; i < GOVERN_COUNT; i++)
+    {
+        if (strstr(buf, govern_modes[i]))
         {
-            core_freq = priv->imx_gpu_govern.core_clk_freq[UNDERDRIVE];
-            shader_freq = priv->imx_gpu_govern.shader_clk_freq[UNDERDRIVE];
-            priv->imx_gpu_govern.current_mode = UNDERDRIVE;
             break;
         }
-    }while(0);
+    }
 
-    while(core != gcvCORE_3D_MAX)
+    if (i == GOVERN_COUNT)
     {
-        struct clk* clk_core = priv->imx_gpu_clks[core].clk_core;
+        return count;
+    }
+
+    core_freq   = priv->imx_gpu_govern.core_clk_freq[i];
+    shader_freq = priv->imx_gpu_govern.shader_clk_freq[i];
+    priv->imx_gpu_govern.current_mode = i;
+
+    for (core = gcvCORE_MAJOR; core <= gcvCORE_3D_MAX; core++)
+    {
+        struct clk* clk_core   = priv->imx_gpu_clks[core].clk_core;
         struct clk* clk_shader = priv->imx_gpu_clks[core].clk_shader;
-        if(clk_core != NULL && clk_shader != NULL && core_freq != 0 && shader_freq != 0)
+
+        if (clk_core != NULL && clk_shader != NULL &&
+            core_freq != 0 && shader_freq != 0)
         {
-            clk_set_rate(clk_core,core_freq);
-            clk_set_rate(clk_shader,shader_freq);
+            clk_set_rate(clk_core, core_freq);
+            clk_set_rate(clk_shader, shader_freq);
         }
-        core++;
     }
+
     return count;
 }
 
-static DRIVER_ATTR_RW(gpu_mode);
+static DRIVER_ATTR_RW(gpu_govern);
+
 
 int init_gpu_opp_table(struct device *dev)
 {
@@ -523,17 +503,22 @@ int init_gpu_opp_table(struct device *dev)
     const __be32 *val;
     int nr;
     int ret = 0;
-    int govern = 0;
-    int tuple_count = 0;
+    int i;
     struct imx_priv *priv = &imxPriv;
+
     priv->imx_gpu_govern.num_modes = 0;
     priv->imx_gpu_govern.current_mode = OVERDRIVE;
 
     prop = of_find_property(dev->of_node, "operating-points", NULL);
-    if (!prop)
+    if (!prop) {
+	dev_err(dev, "operating-points missing. Frequency scaling will not work\n");
         return -ENODEV;
-    if (!prop->value)
+    }
+
+    if (!prop->value) {
+	dev_err(dev, "operating-points invalid. Frequency scaling will not work\n");
         return -ENODATA;
+    }
 
     /*
      * Each OPP is a set of tuples consisting of frequency and
@@ -544,48 +529,51 @@ int init_gpu_opp_table(struct device *dev)
         dev_err(dev, "%s: Invalid OPP list\n", __func__);
         return -EINVAL;
     }
-    tuple_count = nr;
+
     val = prop->value;
-    while (nr > 0) {
-        unsigned long core_freq,core_volt,shader_freq,shader_volt;
+
+    for (i = 0; nr > 0 && i < GOVERN_COUNT; nr -= 4)
+    {
+        unsigned long core_freq, core_volt, shader_freq, shader_volt;
+
         core_freq = be32_to_cpup(val++) * 1000;
         core_volt = be32_to_cpup(val++);
-        if(nr == 2)
+
+        if (nr == 2)
         {
             shader_freq = core_freq;
             shader_volt = core_volt;
         }
-        else{
+        else
+        {
             shader_freq = be32_to_cpup(val++) * 1000;
             shader_volt = be32_to_cpup(val++);
         }
 
-        /*We only register core_clk frequency*/
+        /* We only register core_clk frequency */
         if (dev_pm_opp_add(dev, core_freq, core_volt))
         {
             dev_warn(dev, "%s: Failed to add OPP %ld\n",
                  __func__, core_freq);
-            nr -= 4;
             continue;
         }
 
-        priv->imx_gpu_govern.core_clk_freq[govern] = core_freq;
-        priv->imx_gpu_govern.shader_clk_freq[govern] = shader_freq;
-        govern++;
-        priv->imx_gpu_govern.num_modes++;
-        if(govern == GOVERN_COUNT)
-            break;
+        priv->imx_gpu_govern.core_clk_freq[i]   = core_freq;
+        priv->imx_gpu_govern.shader_clk_freq[i] = shader_freq;
 
-        nr -= 4;
+        i++;
     }
+
+    priv->imx_gpu_govern.num_modes = i;
     priv->imx_gpu_govern.dev = dev;
 
-    if(priv->imx_gpu_govern.num_modes > 0)
+    if (priv->imx_gpu_govern.num_modes > 0)
     {
-        ret = driver_create_file(dev->driver, &driver_attr_gpu_mode);
+        ret = driver_create_file(dev->driver, &driver_attr_gpu_govern);
         if (ret)
-            dev_err(dev, "create gpu_mode attr failed (%d)\n", ret);
+            dev_err(dev, "create gpu_govern attr failed (%d)\n", ret);
     }
+
     return ret;
 }
 
@@ -593,16 +581,21 @@ int remove_gpu_opp_table(void)
 {
     struct imx_priv *priv = &imxPriv;
     struct device* dev = priv->imx_gpu_govern.dev;
-    int govern = 0;
-    while(govern != priv->imx_gpu_govern.num_modes)
+    int i = 0;
+
+    for (i = 0; i < priv->imx_gpu_govern.num_modes; i++)
     {
         unsigned long core_freq;
-        core_freq = priv->imx_gpu_govern.core_clk_freq[govern];
-        dev_pm_opp_remove(dev,core_freq);
-        govern++;
+
+        core_freq = priv->imx_gpu_govern.core_clk_freq[i];
+        dev_pm_opp_remove(dev, core_freq);
+    }
+
+    if (i > 0)
+    {
+        driver_remove_file(dev->driver, &driver_attr_gpu_govern);
     }
-    if(priv->imx_gpu_govern.num_modes > 0)
-        driver_remove_file(dev->driver, &driver_attr_gpu_mode);
+
     return 0;
 }
 #endif
@@ -893,18 +886,6 @@ static int patch_param(struct platform_device *pdev,
 #endif
         patch_param_imx6(pdev, args);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
-    if(args->compression == -1)
-    {
-        const u32 *property;
-        args->compression = gcvCOMPRESSION_OPTION_DEFAULT;
-        property = of_get_property(pdev->dev.of_node, "depth-compression", NULL);
-        if (property && *property == 0)
-        {
-            args->compression &= ~gcvCOMPRESSION_OPTION_DEPTH;
-        }
-    }
-#endif
     res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phys_baseaddr");
 
     if (res && !args->baseAddress && !args->physSize) {
@@ -1159,7 +1140,9 @@ static inline int get_power(struct device *pdev)
 #endif
 
 #if defined(CONFIG_PM_OPP)
-    init_gpu_opp_table(pdev);
+    ret = init_gpu_opp_table(pdev);
+    if (ret)
+	dev_err(pdev, "OPP init failed!\n");
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
diff --git a/drivers/mxc/gpu-viv/hal/security_v1/gc_hal_ta_mmu.c b/drivers/mxc/gpu-viv/hal/security_v1/gc_hal_ta_mmu.c
index fda0493..396712e 100644
--- a/drivers/mxc/gpu-viv/hal/security_v1/gc_hal_ta_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/security_v1/gc_hal_ta_mmu.c
@@ -223,9 +223,9 @@
     gcmkONERROR(gctaOS_GetPhysicalAddress(Os, stlb->logical, &stlb->physBase));
 
 #if gcdUSE_MMU_EXCEPTION
-    _FillPageTable(stlb->logical, stlb->size / 4, gcdMMU_STLB_EXCEPTION);
+    _FillPageTable(stlb->logical, (gctUINT32)stlb->size / 4, gcdMMU_STLB_EXCEPTION);
 #else
-    gctaOS_ZeroMemory(stlb->logical, stlb->size);
+    gctaOS_ZeroMemory(stlb->logical, (gctUINT32)stlb->size);
 #endif
 
     *Stlb = stlb;
@@ -273,15 +273,15 @@
         ));
 
 #if gcdUSE_MMU_EXCEPTION
-    _FillPageTable(mmu->mtlbLogical, mmu->mtlbBytes / 4, gcdMMU_STLB_EXCEPTION);
+    _FillPageTable(mmu->mtlbLogical, (gctUINT32)mmu->mtlbBytes / 4, gcdMMU_STLB_EXCEPTION);
 #else
-    gctaOS_ZeroMemory(mmu->mtlbLogical, mmu->mtlbBytes);
+    gctaOS_ZeroMemory(mmu->mtlbLogical, (gctUINT32)mmu->mtlbBytes);
 #endif
 
     /* Allocate a array to store stlbs. */
-    gcmkONERROR(gctaOS_Allocate(mmu->mtlbBytes, &mmu->stlbs));
+    gcmkONERROR(gctaOS_Allocate((gctUINT32)mmu->mtlbBytes, &mmu->stlbs));
 
-    gctaOS_ZeroMemory((gctUINT8_PTR)mmu->stlbs, mmu->mtlbBytes);
+    gctaOS_ZeroMemory((gctUINT8_PTR)mmu->stlbs, (gctUINT32)mmu->mtlbBytes);
 
     /* Allocate security safe page. */
     gcmkONERROR(gctaOS_AllocateSecurityMemory(
@@ -291,7 +291,7 @@
         &mmu->safePagePhysical
         ));
 
-    gctaOS_ZeroMemory((gctUINT8_PTR)mmu->safePageLogical, bytes);
+    gctaOS_ZeroMemory((gctUINT8_PTR)mmu->safePageLogical, (gctUINT32)bytes);
 
     /* Allocate non security safe page. */
     gcmkONERROR(gctaOS_AllocateSecurityMemory(
@@ -301,7 +301,7 @@
         &mmu->nonSecureSafePagePhysical
         ));
 
-    gctaOS_ZeroMemory((gctUINT8_PTR)mmu->nonSecureSafePageLogical, bytes);
+    gctaOS_ZeroMemory((gctUINT8_PTR)mmu->nonSecureSafePageLogical, (gctUINT32)bytes);
 
     /* gcmkONERROR(gctaOS_CreateMutex(TA->os, &mmu->mutex)); */
 
diff --git a/drivers/mxc/gpu-viv/hal/security_v1/os/emulator/gc_hal_ta_emulator.c b/drivers/mxc/gpu-viv/hal/security_v1/os/emulator/gc_hal_ta_emulator.c
index b5dac8d..bd2fcba 100644
--- a/drivers/mxc/gpu-viv/hal/security_v1/os/emulator/gc_hal_ta_emulator.c
+++ b/drivers/mxc/gpu-viv/hal/security_v1/os/emulator/gc_hal_ta_emulator.c
@@ -136,7 +136,7 @@ struct _gctaOS {
 {
     gceSTATUS status;
 
-    gcmkONERROR(gckOS_AllocateNonPagedMemory(Os->os, gcvFALSE, Bytes, (gctPHYS_ADDR *)Physical, Logical));
+    gcmkONERROR(gckOS_AllocateNonPagedMemory(Os->os, gcvFALSE, gcvALLOC_FLAG_CONTIGUOUS, Bytes, (gctPHYS_ADDR *)Physical, Logical));
 
     return gcvSTATUS_OK;
 
@@ -166,7 +166,7 @@ struct _gctaOS {
 {
     gceSTATUS status;
 
-    gcmkONERROR(gckOS_AllocateNonPagedMemory(Os->os, gcvFALSE, Bytes, (gctPHYS_ADDR *)Physical, Logical));
+    gcmkONERROR(gckOS_AllocateNonPagedMemory(Os->os, gcvFALSE, gcvALLOC_FLAG_CONTIGUOUS, Bytes, (gctPHYS_ADDR *)Physical, Logical));
 
     return gcvSTATUS_OK;
 
@@ -215,6 +215,8 @@ struct _gctaOS {
 
     gcmkONERROR(gckOS_GetPhysicalAddress(Os->os, Logical, &physical));
 
+    gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Os->os, physical, &physical));
+
     *Physical = (gctUINT32)physical;
 
     return gcvSTATUS_OK;
-- 
1.7.9.5


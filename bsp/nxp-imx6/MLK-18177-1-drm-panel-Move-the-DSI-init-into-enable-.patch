From 5c28e9b4f30a4af6c61714b7d37b5a1a88594e95 Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Thu, 12 Apr 2018 16:29:21 +0300
Subject: [PATCH 3658/5242] MLK-18177-1: drm/panel: Move the DSI init into
 enable stage

commit  dc0e8e59578a84ec513c467d2f30f2902d33728c from
https://source.codeaurora.org/external/imx/linux-imx.git

Currently, the DSI panel init sequence is made in the prepare function,
right after the reset pin is asserted. This implies that at this moment,
the DSI host needs to be enabled. If the DSI host is enabled during
panel prepare, there will be DSI signal on the DSI lanes during the
panel reset, which is wrong.

In order to not to have any signal on the DSI data lanes during reset,
the reset sequence must be separated from the init sequence, so move the
init into enable function and leave the reset into the prepare function.

Also:
- removed the calls to panel_disable and panel_unprepare from
  panel_remove, since the panel should be already disabled when this call
  is made
- fixed the call ordering to panel_disable and panel_unprepare from
  rad_panel_shutdown function

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/panel/panel-raydium-rm67191.c |  116 ++++++++++++-------------
 1 file changed, 57 insertions(+), 59 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-raydium-rm67191.c b/drivers/gpu/drm/panel/panel-raydium-rm67191.c
index 6331fef..3be2412 100644
--- a/drivers/gpu/drm/panel/panel-raydium-rm67191.c
+++ b/drivers/gpu/drm/panel/panel-raydium-rm67191.c
@@ -239,25 +239,61 @@ static int color_format_from_dsi_format(enum mipi_dsi_pixel_format format)
 static int rad_panel_prepare(struct drm_panel *panel)
 {
 	struct rad_panel *rad = to_rad_panel(panel);
-	struct mipi_dsi_device *dsi = rad->dsi;
-	struct device *dev = &dsi->dev;
-	int color_format = color_format_from_dsi_format(dsi->format);
-	int ret;
 
 	if (rad->prepared)
 		return 0;
 
-	DRM_DEV_DEBUG_DRIVER(dev, "\n");
-
 	if (rad->reset != NULL) {
-		gpiod_set_value(rad->reset, 1);
-		usleep_range(10000, 15000);
 		gpiod_set_value(rad->reset, 0);
 		usleep_range(5000, 10000);
 		gpiod_set_value(rad->reset, 1);
 		usleep_range(20000, 25000);
 	}
 
+	rad->prepared = true;
+
+	return 0;
+}
+
+static int rad_panel_unprepare(struct drm_panel *panel)
+{
+	struct rad_panel *rad = to_rad_panel(panel);
+	struct device *dev = &rad->dsi->dev;
+
+	if (!rad->prepared)
+		return 0;
+
+	if (rad->enabled) {
+		DRM_DEV_ERROR(dev, "Panel still enabled!\n");
+		return -EPERM;
+	}
+
+	if (rad->reset != NULL) {
+		gpiod_set_value(rad->reset, 0);
+		usleep_range(10000, 15000);
+	}
+
+	rad->prepared = false;
+
+	return 0;
+}
+
+static int rad_panel_enable(struct drm_panel *panel)
+{
+	struct rad_panel *rad = to_rad_panel(panel);
+	struct mipi_dsi_device *dsi = rad->dsi;
+	struct device *dev = &dsi->dev;
+	int color_format = color_format_from_dsi_format(dsi->format);
+	int ret;
+
+	if (rad->enabled)
+		return 0;
+
+	if (!rad->prepared) {
+		DRM_DEV_ERROR(dev, "Panel not prepared!\n");
+		return -EPERM;
+	}
+
 	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
 
 	ret = rad_panel_push_cmd_list(dsi);
@@ -328,7 +364,10 @@ static int rad_panel_prepare(struct drm_panel *panel)
 		goto fail;
 	}
 
-	rad->prepared = true;
+	rad->backlight->props.power = FB_BLANK_UNBLANK;
+	backlight_update_status(rad->backlight);
+
+	rad->enabled = true;
 
 	return 0;
 
@@ -339,69 +378,33 @@ static int rad_panel_prepare(struct drm_panel *panel)
 	return ret;
 }
 
-static int rad_panel_unprepare(struct drm_panel *panel)
+static int rad_panel_disable(struct drm_panel *panel)
 {
 	struct rad_panel *rad = to_rad_panel(panel);
 	struct mipi_dsi_device *dsi = rad->dsi;
 	struct device *dev = &dsi->dev;
 	int ret;
 
-	if (!rad->prepared)
+	if (!rad->enabled)
 		return 0;
 
-	DRM_DEV_DEBUG_DRIVER(dev, "\n");
-
 	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
 
 	ret = mipi_dsi_dcs_set_display_off(dsi);
-	if (ret < 0)
+	if (ret < 0) {
 		DRM_DEV_ERROR(dev, "Failed to set display OFF (%d)\n", ret);
+		return ret;
+	}
 
 	usleep_range(5000, 10000);
 
 	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
-	if (ret < 0)
+	if (ret < 0) {
 		DRM_DEV_ERROR(dev, "Failed to enter sleep mode (%d)\n", ret);
-
-	usleep_range(10000, 15000);
-
-	if (rad->reset != NULL) {
-		gpiod_set_value(rad->reset, 0);
-		usleep_range(10000, 15000);
+		return ret;
 	}
 
-	rad->prepared = false;
-
-	return 0;
-}
-
-static int rad_panel_enable(struct drm_panel *panel)
-{
-	struct rad_panel *rad = to_rad_panel(panel);
-	struct device *dev = &rad->dsi->dev;
-
-	if (rad->enabled)
-		return 0;
-
-	DRM_DEV_DEBUG_DRIVER(dev, "\n");
-
-	rad->backlight->props.power = FB_BLANK_UNBLANK;
-	backlight_update_status(rad->backlight);
-
-	rad->enabled = true;
-
-	return 0;
-}
-
-static int rad_panel_disable(struct drm_panel *panel)
-{
-	struct rad_panel *rad = to_rad_panel(panel);
-	struct device *dev = &rad->dsi->dev;
-
-	if (!rad->enabled)
-		return 0;
-
-	DRM_DEV_DEBUG_DRIVER(dev, "\n");
+	usleep_range(10000, 15000);
 
 	rad->backlight->props.power = FB_BLANK_POWERDOWN;
 	backlight_update_status(rad->backlight);
@@ -620,11 +623,6 @@ static int rad_panel_remove(struct mipi_dsi_device *dsi)
 	struct device *dev = &dsi->dev;
 	int ret;
 
-	ret = rad_panel_unprepare(&rad->base);
-	ret |= rad_panel_disable(&rad->base);
-	if (ret < 0)
-		DRM_DEV_ERROR(dev, "Failed to disable panel (%d)\n", ret);
-
 	ret = mipi_dsi_detach(dsi);
 	if (ret < 0)
 		DRM_DEV_ERROR(dev, "Failed to detach from host (%d)\n",
@@ -642,8 +640,8 @@ static void rad_panel_shutdown(struct mipi_dsi_device *dsi)
 {
 	struct rad_panel *rad = mipi_dsi_get_drvdata(dsi);
 
-	rad_panel_unprepare(&rad->base);
 	rad_panel_disable(&rad->base);
+	rad_panel_unprepare(&rad->base);
 }
 
 static const struct of_device_id rad_of_match[] = {
-- 
1.7.9.5


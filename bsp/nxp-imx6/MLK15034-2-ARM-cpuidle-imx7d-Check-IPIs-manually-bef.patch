From e2bf16f14eac3b27a9c843a90cc471dc19929313 Mon Sep 17 00:00:00 2001
From: Leonard Crestez <leonard.crestez@nxp.com>
Date: Tue, 4 Jul 2017 20:52:26 +0300
Subject: [PATCH 3645/5242] MLK15034-2: ARM: cpuidle imx7d: Check IPIs
 manually before LPI

commit  2563a079ca60d2e3671aaaee447ab5962092ab48 from
https://source.codeaurora.org/external/imx/linux-imx.git

The GPC will wake us on peripheral interrupts but not IPIs. So check
them manually by reading the GIC's GICD_SPENDSGIR* registers and
aborting idle if something is pending.

We do this only for the last cpu and after taking the required locks.
We know that at this stage the other cpu is in WFI itself or waiting for
the imx_pen_lock and can't trigger any additional IPIs. This means that
the check is not racy.

This fixes occasional lost IPIs causing tasks to get stuck in the
TASK_WAKING 'W' state for long periods. This eventually manifested as
rcu stalls.

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/cpuidle-imx7d.c |   26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/arch/arm/mach-imx/cpuidle-imx7d.c b/arch/arm/mach-imx/cpuidle-imx7d.c
index 37d12b1..d19d76e 100644
--- a/arch/arm/mach-imx/cpuidle-imx7d.c
+++ b/arch/arm/mach-imx/cpuidle-imx7d.c
@@ -84,6 +84,9 @@ struct imx7_cpuidle_pm_info {
 static void (*imx7d_wfi_in_iram_fn)(void __iomem *iram_vbase);
 static struct imx7_cpuidle_pm_info *cpuidle_pm_info;
 
+/* Mapped for the kernel, unlike cpuidle_pm_info->gic_dist_base.vbase */
+static void __iomem *imx7d_cpuidle_gic_base;
+
 static void imx_pen_lock(int cpu)
 {
 	if (cpu == 0) {
@@ -122,6 +125,16 @@ static int imx7d_idle_finish(unsigned long val)
 	return 0;
 }
 
+static bool imx7d_gic_sgis_pending(void)
+{
+	void __iomem *sgip_base = imx7d_cpuidle_gic_base + 0x1f20;
+
+	return (readl_relaxed(sgip_base + 0x0) |
+		readl_relaxed(sgip_base + 0x4) |
+		readl_relaxed(sgip_base + 0x8) |
+		readl_relaxed(sgip_base + 0xc));
+}
+
 static int imx7d_enter_low_power_idle(struct cpuidle_device *dev,
 			    struct cpuidle_driver *drv, int index)
 {
@@ -141,6 +154,16 @@ static int imx7d_enter_low_power_idle(struct cpuidle_device *dev,
 		cpu_pm_enter();
 		if (atomic_inc_return(&master_lpi) == num_online_cpus() &&
 			cpuidle_pm_info->last_cpu == -1) {
+			/*
+			 * GPC will not wake on SGIs so check for them
+			 * manually here. At this point we know the other cpu
+			 * is in wfi or waiting for the lock and can't send
+			 * any additional IPIs.
+			 */
+			if (imx7d_gic_sgis_pending()) {
+				index = -1;
+				goto skip_lpi_flow;
+			}
 			imx_gpcv2_set_lpm_mode(WAIT_UNCLOCKED);
 			imx_gpcv2_set_cpu_power_gate_in_idle(true);
 			cpu_cluster_pm_enter();
@@ -162,6 +185,7 @@ static int imx7d_enter_low_power_idle(struct cpuidle_device *dev,
 		if (cpuidle_pm_info->last_cpu == dev->cpu)
 			cpuidle_pm_info->last_cpu = -1;
 
+skip_lpi_flow:
 		cpu_pm_exit();
 		imx_pen_unlock(dev->cpu);
 	}
@@ -308,6 +332,8 @@ int __init imx7d_cpuidle_init(void)
 	cpuidle_pm_info->gic_dist_base.vbase =
 		(void __iomem *)IMX_IO_P2V(MX7D_GIC_BASE_ADDR);
 
+	imx7d_cpuidle_gic_base = ioremap(MX7D_GIC_BASE_ADDR, MX7D_GIC_SIZE);
+
 	imx7d_enable_rcosc();
 
 	/* code size should include cpuidle_pm_info size */
-- 
1.7.9.5


From 716f678a8b0eb55be7a143695c73943ea3ebce82 Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Thu, 29 Mar 2018 11:36:43 +0800
Subject: [PATCH 3558/5242] MLK-17938: pxp: pxp will hang when output height
 is 8

commit  bcf745002f1efd0446ff6d18116baf5ec0e4cb30 from
https://source.codeaurora.org/external/imx/linux-imx.git

When output height is eight, yscale of ps engine will be
over two, it not support by pxp.

According to pxp doc, a factor greater than 2 is not
supported with the bilinear filter. so correct it when
this case happen in order to ensure that pxp will be
not hang up.

Reviewed-by: Robby.cai <robby.cai@nxp.com>
Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/dma/pxp/pxp_dma_v3.c  |   28 +++++++++++++++++++++++++++-
 drivers/dma/pxp/regs-pxp_v3.h |    2 ++
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/drivers/dma/pxp/pxp_dma_v3.c b/drivers/dma/pxp/pxp_dma_v3.c
index b470dba..95680c9 100644
--- a/drivers/dma/pxp/pxp_dma_v3.c
+++ b/drivers/dma/pxp/pxp_dma_v3.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -2306,6 +2306,19 @@ static uint32_t ps_calc_scaling(struct pxp_pixmap *input,
 		}
 		scale.xscale = input->crop.width * 0x1000 /
 				(output->crop.width * decx);
+
+		/* A factor greater than 2 is not supported
+		 * with the bilinear filter, so correct it in
+		 * driver
+		 */
+		if (((scale.xscale >> BP_PXP_PS_SCALE_OFFSET) & 0x3) > 2) {
+			scale.xscale &= (~(0x3 << BP_PXP_PS_SCALE_OFFSET));
+			scale.xscale |= (0x2 << BP_PXP_PS_SCALE_OFFSET);
+			pr_warn("%s: scale.xscale is larger than 2, forcing to 2"
+					"input w/h=(%d,%d), output w/h=(%d, %d)\n",
+					__func__, input->crop.width, input->crop.height,
+					output->crop.width, output->crop.height);
+		}
 	} else {
 		if (!is_yuv(input->format) ||
 		    (is_yuv(input->format) == is_yuv(output->format)) ||
@@ -2343,6 +2356,19 @@ static uint32_t ps_calc_scaling(struct pxp_pixmap *input,
 		}
 		scale.yscale = input->crop.height * 0x1000 /
 				(output->crop.height * decy);
+
+		/* A factor greater than 2 is not supported
+		 * with the bilinear filter, so correct it in
+		 * driver
+		 */
+		if (((scale.yscale >> BP_PXP_PS_SCALE_OFFSET) & 0x3) > 2) {
+			scale.yscale &= (~(0x3 << BP_PXP_PS_SCALE_OFFSET));
+			scale.yscale |= (0x2 << BP_PXP_PS_SCALE_OFFSET);
+			pr_warn("%s: scale.yscale is larger than 2, forcing to 2"
+					"input w/h=(%d,%d), output w/h=(%d, %d)\n",
+					__func__, input->crop.width, input->crop.height,
+					output->crop.width, output->crop.height);
+		}
 	} else {
 		if ((input->crop.height > 1) && (output->crop.height > 1))
 			scale.yscale = (input->crop.height - 1) * 0x1000 /
diff --git a/drivers/dma/pxp/regs-pxp_v3.h b/drivers/dma/pxp/regs-pxp_v3.h
index 15a4811..80e310b 100644
--- a/drivers/dma/pxp/regs-pxp_v3.h
+++ b/drivers/dma/pxp/regs-pxp_v3.h
@@ -456,6 +456,8 @@
 #define BF_PXP_PS_SCALE_XSCALE(v)  \
         (((v) << 0) & BM_PXP_PS_SCALE_XSCALE)
 
+#define BP_PXP_PS_SCALE_OFFSET	12
+
 #define HW_PXP_PS_OFFSET	(0x00000120)
 
 #define BP_PXP_PS_OFFSET_RSVD2      28
-- 
1.7.9.5


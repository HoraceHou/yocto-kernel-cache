From b00f5d0cf88a7ad9abe0993a96f613f6e88ad670 Mon Sep 17 00:00:00 2001
From: Haibo Chen <haibo.chen@nxp.com>
Date: Mon, 13 Aug 2018 11:37:38 +0800
Subject: [PATCH 4429/5242] MLK-19201 mmc: sdhci-esdhc-imx: remove the 100MHz
 limitation for Strobe DLL

commit  d29d339aa6b4f5c660413cf6d38489a9ba44a628 from
https://source.codeaurora.org/external/imx/linux-imx.git

For some eMMC, after switch to HS400ES mode, it need to config the strobe
dll target dealy even if the clock is 50MHZ or 25MHz, otherwise will meet
CMD index/crc error when send CMD13 to check the switch status. Take
imx8MM-EVK board as example, without this patch, it will meet:

[    2.473915] IRQ status 0x000a8001
[    2.473930] the mmc send status get -84
[    2.473934] mmc2: mmc_select_hs400es failed, error -84
[    2.473938] mmc2: error -84 whilst initialising MMC card

And we also meet some customer require to let eMMC work at 80MHz HS400ES
mode, so here remove the 100MHz limitation for Strobe DLL target delay
setting.

Signed-off-by: Haibo Chen <haibo.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc-imx.c |   63 ++++++++++++++++--------------------
 1 file changed, 28 insertions(+), 35 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index 5da8836..af35798 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -175,9 +175,6 @@
 /* The IP has Host Controller Interface for Command Queuing */
 #define ESDHC_FLAG_CQHCI               BIT(16)
 
-/* A clock frequency higher than this rate requires strobe dll control */
-#define ESDHC_STROBE_DLL_CLK_FREQ	100000000
-
 static struct mmc_host *wifi_mmc_host;
 void wifi_card_detect(bool on)
 {
@@ -1013,8 +1010,6 @@ static int esdhc_change_pinstate(struct sdhci_host *host,
  * edge of data_strobe line. Due to the time delay between CLK line and
  * data_strobe line, if the delay time is larger than one clock cycle,
  * then CLK and data_strobe line will be misaligned, read error shows up.
- * So when the CLK is higher than 100MHz, each clock cycle is short enough,
- * host should configure the delay target.
  */
 static void esdhc_set_strobe_dll(struct sdhci_host *host)
 {
@@ -1023,40 +1018,38 @@ static void esdhc_set_strobe_dll(struct sdhci_host *host)
 	u32 v;
 	u32 strobe_delay;
 
-	if (host->mmc->actual_clock > ESDHC_STROBE_DLL_CLK_FREQ) {
-		/* disable clock before enabling strobe dll */
-		writel(readl(host->ioaddr + ESDHC_VENDOR_SPEC) &
-		       ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,
-		       host->ioaddr + ESDHC_VENDOR_SPEC);
+	/* disable clock before enabling strobe dll */
+	writel(readl(host->ioaddr + ESDHC_VENDOR_SPEC) &
+	       ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,
+	       host->ioaddr + ESDHC_VENDOR_SPEC);
 
-		/* force a reset on strobe dll */
-		writel(ESDHC_STROBE_DLL_CTRL_RESET,
-			host->ioaddr + ESDHC_STROBE_DLL_CTRL);
-		/* clear the reset bit on strobe dll before any setting */
-		writel(0, host->ioaddr + ESDHC_STROBE_DLL_CTRL);
+	/* force a reset on strobe dll */
+	writel(ESDHC_STROBE_DLL_CTRL_RESET,
+		host->ioaddr + ESDHC_STROBE_DLL_CTRL);
+	/* clear the reset bit on strobe dll before any setting */
+	writel(0, host->ioaddr + ESDHC_STROBE_DLL_CTRL);
 
-		/*
-		 * enable strobe dll ctrl and adjust the delay target
-		 * for the uSDHC loopback read clock
-		 */
-		if (imx_data->boarddata.strobe_dll_delay_target)
-			strobe_delay = imx_data->boarddata.strobe_dll_delay_target;
-		else
-			strobe_delay = ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_DEFAULT;
-		v = ESDHC_STROBE_DLL_CTRL_ENABLE |
-			ESDHC_STROBE_DLL_CTRL_SLV_UPDATE_INT_DEFAULT |
-			(strobe_delay << ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_SHIFT);
-		writel(v, host->ioaddr + ESDHC_STROBE_DLL_CTRL);
-		/* wait 5us to make sure strobe dll status register stable */
-		udelay(5);
-		v = readl(host->ioaddr + ESDHC_STROBE_DLL_STATUS);
-		if (!(v & ESDHC_STROBE_DLL_STS_REF_LOCK))
-			dev_warn(mmc_dev(host->mmc),
-				"warning! HS400 strobe DLL status REF not lock!\n");
-		if (!(v & ESDHC_STROBE_DLL_STS_SLV_LOCK))
+	/*
+	 * enable strobe dll ctrl and adjust the delay target
+	 * for the uSDHC loopback read clock
+	 */
+	if (imx_data->boarddata.strobe_dll_delay_target)
+		strobe_delay = imx_data->boarddata.strobe_dll_delay_target;
+	else
+		strobe_delay = ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_DEFAULT;
+	v = ESDHC_STROBE_DLL_CTRL_ENABLE |
+		ESDHC_STROBE_DLL_CTRL_SLV_UPDATE_INT_DEFAULT |
+		(strobe_delay << ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_SHIFT);
+	writel(v, host->ioaddr + ESDHC_STROBE_DLL_CTRL);
+	/* wait 5us to make sure strobe dll status register stable */
+	udelay(5);
+	v = readl(host->ioaddr + ESDHC_STROBE_DLL_STATUS);
+	if (!(v & ESDHC_STROBE_DLL_STS_REF_LOCK))
+		dev_warn(mmc_dev(host->mmc),
+			"warning! HS400 strobe DLL status REF not lock!\n");
+	if (!(v & ESDHC_STROBE_DLL_STS_SLV_LOCK))
 			dev_warn(mmc_dev(host->mmc),
 				"warning! HS400 strobe DLL status SLV not lock!\n");
-	}
 }
 
 static void esdhc_reset_tuning(struct sdhci_host *host)
-- 
1.7.9.5


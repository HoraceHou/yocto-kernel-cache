From dd58c6f51d7c4a2065802543ca3d4996e62a2db5 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Wed, 16 Nov 2016 01:38:22 +0800
Subject: [PATCH 1271/5242] MLK-13455 ARM: imx: need to wait apll ready before
 operating MMDC on i.mx7ulp

commit  e4c275d8feae13f70a70e597012c5eb2c26bd7eb from
https://source.codeaurora.org/external/imx/linux-imx.git

When resume from VLPS mode on i.MX7ULP, APLL is NOT
valid yet, but MMDC clock is from APLL, so need to
wait for it valid before operating MMDC.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/mx7ulp.h          |    8 +++++---
 arch/arm/mach-imx/pm-imx7ulp.c      |   24 ++++++++++++++++++------
 arch/arm/mach-imx/suspend-imx7ulp.S |   31 +++++++++++++++++--------------
 3 files changed, 40 insertions(+), 23 deletions(-)

diff --git a/arch/arm/mach-imx/mx7ulp.h b/arch/arm/mach-imx/mx7ulp.h
index ecefde5..de4f1e0 100644
--- a/arch/arm/mach-imx/mx7ulp.h
+++ b/arch/arm/mach-imx/mx7ulp.h
@@ -14,10 +14,12 @@
 #define MX7ULP_IO_P2V(x)                  IMX_IO_P2V(x)
 #define MX7ULP_IO_ADDRESS(x)              IOMEM(MX7ULP_IO_P2V(x))
 
-#define MX7ULP_AIPS1_BASE_ADDR		0x40a00000
-#define MX7ULP_AIPS1_SIZE		0x400000
-#define MX7ULP_AIPS2_BASE_ADDR		0x41000000
+#define MX7ULP_AIPS1_BASE_ADDR		0x40300000
+#define MX7ULP_AIPS1_SIZE		0x100000
+#define MX7ULP_AIPS2_BASE_ADDR		0x40a00000
 #define MX7ULP_AIPS2_SIZE		0x400000
+#define MX7ULP_AIPS3_BASE_ADDR		0x41000000
+#define MX7ULP_AIPS3_SIZE		0x100000
 #define MX7ULP_PCC3_BASE_ADDR		0x40b30000
 #define MX7ULP_PCC3_SIZE		0x1000
 #define MX7ULP_SCG1_BASE_ADDR		0x403e0000
diff --git a/arch/arm/mach-imx/pm-imx7ulp.c b/arch/arm/mach-imx/pm-imx7ulp.c
index a492c0e..633a16b 100644
--- a/arch/arm/mach-imx/pm-imx7ulp.c
+++ b/arch/arm/mach-imx/pm-imx7ulp.c
@@ -239,6 +239,7 @@ struct imx7ulp_cpu_pm_info {
 	phys_addr_t resume_addr; /* The physical resume address for asm code */
 	u32 pm_info_size; /* Size of pm_info. */
 	struct imx7ulp_pm_base sim_base;
+	struct imx7ulp_pm_base scg1_base;
 	struct imx7ulp_pm_base mmdc_base;
 	struct imx7ulp_pm_base mmdc_io_base;
 	u32 scg1[16];
@@ -259,6 +260,7 @@ struct imx7ulp_cpu_pm_info {
 static struct map_desc imx7ulp_pm_io_desc[] __initdata = {
 	imx_map_entry(MX7ULP, AIPS1, MT_DEVICE),
 	imx_map_entry(MX7ULP, AIPS2, MT_DEVICE),
+	imx_map_entry(MX7ULP, AIPS3, MT_DEVICE),
 };
 
 static void imx7ulp_scg1_save(void)
@@ -525,12 +527,10 @@ void __init imx7ulp_pm_map_io(void)
 	 * Make sure the AIPS1 virtual address has a mapping in the
 	 * IRAM page table.
 	 */
-	for (i = 0; i < 4; i++) {
-		j = ((IMX_IO_P2V(MX7ULP_AIPS1_BASE_ADDR + i * 0x100000) >> 20) << 2) / 4;
-		*((unsigned long *)iram_tlb_base_addr + j) =
-			((MX7ULP_AIPS1_BASE_ADDR + i * 0x100000) & 0xFFF00000) |
-			TT_ATTRIB_NON_CACHEABLE_1M;
-	}
+	j = ((IMX_IO_P2V(MX7ULP_AIPS1_BASE_ADDR) >> 20) << 2) / 4;
+	*((unsigned long *)iram_tlb_base_addr + j) =
+		((MX7ULP_AIPS1_BASE_ADDR) & 0xFFF00000) |
+		TT_ATTRIB_NON_CACHEABLE_1M;
 	/*
 	 * Make sure the AIPS2 virtual address has a mapping in the
 	 * IRAM page table.
@@ -541,6 +541,14 @@ void __init imx7ulp_pm_map_io(void)
 			((MX7ULP_AIPS2_BASE_ADDR + i * 0x100000) & 0xFFF00000) |
 			TT_ATTRIB_NON_CACHEABLE_1M;
 	}
+	/*
+	 * Make sure the AIPS3 virtual address has a mapping in the
+	 * IRAM page table.
+	 */
+	j = ((IMX_IO_P2V(MX7ULP_AIPS3_BASE_ADDR) >> 20) << 2) / 4;
+	*((unsigned long *)iram_tlb_base_addr + j) =
+		((MX7ULP_AIPS3_BASE_ADDR) & 0xFFF00000) |
+		TT_ATTRIB_NON_CACHEABLE_1M;
 }
 
 void __init imx7ulp_pm_common_init(const struct imx7ulp_pm_socdata
@@ -620,6 +628,10 @@ void __init imx7ulp_pm_common_init(const struct imx7ulp_pm_socdata
 	pm_info->sim_base.vbase = (void __iomem *)
 				IMX_IO_P2V(MX7ULP_SIM_BASE_ADDR);
 
+	pm_info->scg1_base.pbase = MX7ULP_SCG1_BASE_ADDR;
+	pm_info->scg1_base.vbase = (void __iomem *)
+				IMX_IO_P2V(MX7ULP_SCG1_BASE_ADDR);
+
 	pm_info->mmdc_base.pbase = MX7ULP_MMDC_BASE_ADDR;
 	pm_info->mmdc_base.vbase = (void __iomem *)
 				IMX_IO_P2V(MX7ULP_MMDC_BASE_ADDR);
diff --git a/arch/arm/mach-imx/suspend-imx7ulp.S b/arch/arm/mach-imx/suspend-imx7ulp.S
index b6ecea0..04dbff3 100644
--- a/arch/arm/mach-imx/suspend-imx7ulp.S
+++ b/arch/arm/mach-imx/suspend-imx7ulp.S
@@ -46,17 +46,19 @@
 #define PM_INFO_PM_INFO_SIZE_OFFSET		0x14
 #define PM_INFO_PM_INFO_SIM_PBASE_OFFSET	0x18
 #define PM_INFO_PM_INFO_SIM_VBASE_OFFSET	0x1c
-#define PM_INFO_PM_INFO_MMDC_PBASE_OFFSET	0x20
-#define PM_INFO_PM_INFO_MMDC_VBASE_OFFSET	0x24
-#define PM_INFO_PM_INFO_MMDC_IO_PBASE_OFFSET	0x28
-#define PM_INFO_PM_INFO_MMDC_IO_VBASE_OFFSET	0x2c
-#define PM_INFO_PM_INFO_SCG1_VAL_OFFSET		0x30
-#define PM_INFO_MX7ULP_TTBR1_V_OFFSET		0x70
-#define PM_INFO_MMDC_IO_NUM_OFFSET		0x74
-#define PM_INFO_MMDC_IO_VAL_OFFSET		0x78
+#define PM_INFO_PM_INFO_SCG1_PBASE_OFFSET	0x20
+#define PM_INFO_PM_INFO_SCG1_VBASE_OFFSET	0x24
+#define PM_INFO_PM_INFO_MMDC_PBASE_OFFSET	0x28
+#define PM_INFO_PM_INFO_MMDC_VBASE_OFFSET	0x2c
+#define PM_INFO_PM_INFO_MMDC_IO_PBASE_OFFSET	0x30
+#define PM_INFO_PM_INFO_MMDC_IO_VBASE_OFFSET	0x34
+#define PM_INFO_PM_INFO_SCG1_VAL_OFFSET		0x38
+#define PM_INFO_MX7ULP_TTBR1_V_OFFSET		0x78
+#define PM_INFO_MMDC_IO_NUM_OFFSET		0x7c
+#define PM_INFO_MMDC_IO_VAL_OFFSET		0x80
 /* below offsets depends on MX7ULP_MAX_MMDC_IO_NUM(36) definition */
-#define PM_INFO_MMDC_NUM_OFFSET			0x198
-#define PM_INFO_MMDC_VAL_OFFSET			0x19c
+#define PM_INFO_MMDC_NUM_OFFSET			0x1a0
+#define PM_INFO_MMDC_VAL_OFFSET			0x1a4
 
 #define DGO_GPR3	0x60
 #define DGO_GPR4	0x64
@@ -315,10 +317,11 @@ poll_dvfs_set:
 	str	r7, [r10, #DGO_GPR3]
 	str	r7, [r10, #DGO_GPR4]
 
-	ldr     r7, =100
-loop:
-	subs    r7, r7, #0x1
-	bne     loop
+	ldr	r10, [r0, #PM_INFO_PM_INFO_SCG1_VBASE_OFFSET]
+wait_apll:
+	ldr	r7, [r10, #SCG_APLLCSR]
+	ands	r7, r7, #(1 << 24)
+	beq	wait_apll
 
 	/* let DDR out of self-refresh */
 	ldr	r7, [r11, #MX7ULP_MMDC_MAPSR]
-- 
1.7.9.5


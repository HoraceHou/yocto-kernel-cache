From eddf8b72fc2d197f8923edc506e8fb5770d7998d Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Tue, 8 Nov 2016 00:03:54 +0800
Subject: [PATCH 1263/5242] MLK-13441-5 ARM: imx: add new clk types

commit  2ab065400336bf076fde73bd0186cbf42ef8d65b from
https://source.codeaurora.org/external/imx/linux-imx.git

Add below new clock types to support new SoC:

composite clk;
frac-divider;
pfdv2;
pllv4.

These clock types are for i.MX7ULP and maybe
following SoCs.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Bai Ping <ping.bai@nxp.com>
[Octavian: fix build warning by using u64 in do_div ops]
Signed-off-by: Octavian Purdila <octavian.purdila@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/clk/imx/Makefile           |    7 +-
 drivers/clk/imx/clk-composite.c    |   92 +++++++++++++++++++
 drivers/clk/imx/clk-frac-divider.c |   87 ++++++++++++++++++
 drivers/clk/imx/clk-pfdv2.c        |  168 ++++++++++++++++++++++++++++++++++
 drivers/clk/imx/clk-pllv4.c        |  178 ++++++++++++++++++++++++++++++++++++
 drivers/clk/imx/clk.h              |   25 +++++
 6 files changed, 556 insertions(+), 1 deletion(-)
 create mode 100644 drivers/clk/imx/clk-composite.c
 create mode 100644 drivers/clk/imx/clk-frac-divider.c
 create mode 100644 drivers/clk/imx/clk-pfdv2.c
 create mode 100644 drivers/clk/imx/clk-pllv4.c

diff --git a/drivers/clk/imx/Makefile b/drivers/clk/imx/Makefile
index 8c3baa7..4110df4 100644
--- a/drivers/clk/imx/Makefile
+++ b/drivers/clk/imx/Makefile
@@ -11,7 +11,12 @@ obj-y += \
 	clk-pllv1.o \
 	clk-pllv2.o \
 	clk-pllv3.o \
-	clk-pfd.o
+	clk-pfd.o \
+	clk-gate-exclusive.o \
+	clk-composite.o \
+	clk-frac-divider.o \
+	clk-pllv4.o \
+	clk-pfdv2.o
 
 obj-$(CONFIG_SOC_IMX1)   += clk-imx1.o
 obj-$(CONFIG_SOC_IMX21)  += clk-imx21.o
diff --git a/drivers/clk/imx/clk-composite.c b/drivers/clk/imx/clk-composite.c
new file mode 100644
index 0000000..2e70f78
--- /dev/null
+++ b/drivers/clk/imx/clk-composite.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+
+#include "clk.h"
+
+#define PCG_CGC		BIT(30)
+#define PCG_PCS_SHIFT	24
+#define PCG_PCS_MASK	0x7
+
+struct clk *imx_clk_composite(const char *name, const char **parent_name,
+			int num_parents, bool mux_present, bool rate_present, bool gate_present,
+			 void __iomem *reg)
+{
+	struct clk_gate *gate = NULL;
+	struct clk_mux *mux = NULL;
+	struct clk_frac_divider *div = NULL;
+	struct clk_hw *mux_hw = NULL, *div_hw = NULL, *gate_hw = NULL;
+	struct clk *clk;
+
+	/* check if the mux is present in this composite clk. */
+	if (mux_present) {
+		mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+		if (!mux) {
+			pr_err("%s: could not allocate mux clk\n", __func__);
+			return ERR_PTR(-ENOMEM);
+		}
+		mux_hw = &mux->hw;
+		/* init the mux struct */
+		mux->reg = reg;
+		mux->shift = PCG_PCS_SHIFT;
+		mux->mask = PCG_PCS_MASK;
+		mux->flags = CLK_MUX_INDEX_ONE;
+		/* mux->lock */
+	}
+
+	if (rate_present) {
+		div = kzalloc(sizeof(*div), GFP_KERNEL);
+		if (!div) {
+			pr_err("%s: counld not allocate divider clk\n", __func__);
+			kfree(mux);
+			return ERR_PTR(-ENOMEM);
+		}
+		div_hw = &div->hw;
+		/* init the div struct */
+		div->reg = reg;
+		div->mshift = 3;
+		div->mmask  = (0x1) << 3;
+		div->nshift = 0;
+		div->nmask  = 0x7;
+	}
+
+	if (gate_present) {
+		gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+		if (!gate) {
+			pr_err("%s: could not allocate gate clk\n", __func__);
+			kfree(mux);
+			kfree(div);
+			return ERR_PTR(-ENOMEM);
+		}
+		gate_hw = &gate->hw;
+		/* init the gate struct */
+		gate->reg = reg;
+		gate->bit_idx = 30;
+		/* gate->lock */
+	}
+
+	/* register the composite clk itself */
+	clk = clk_register_composite(NULL, name, parent_name, num_parents,
+				mux_hw, &clk_mux_ops, div_hw, &clk_frac_divider_ops,
+				gate_hw, &clk_gate_ops, CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE);
+
+	if (IS_ERR(clk)) {
+		kfree(mux);
+		kfree(div);
+		kfree(gate);
+	}
+
+	return clk;
+}
diff --git a/drivers/clk/imx/clk-frac-divider.c b/drivers/clk/imx/clk-frac-divider.c
new file mode 100644
index 0000000..8eec646
--- /dev/null
+++ b/drivers/clk/imx/clk-frac-divider.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/gcd.h>
+
+#include "clk.h"
+
+#define to_clk_frac_divider(_hw) container_of(_hw, struct clk_frac_divider, hw)
+
+static unsigned long clk_frac_divider_recalc_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct clk_frac_divider *fd = to_clk_frac_divider(hw);
+	u32 val, m, n;
+	u64 ret;
+
+	val = readl_relaxed(fd->reg);
+
+	m = (val & fd->mmask) >> fd->mshift;
+	n = (val & fd->nmask) >> fd->nshift;
+
+	ret = (u64)parent_rate * (m + 1);
+	do_div(ret, n + 1);
+
+	return ret;
+}
+
+static long clk_frac_divider_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct clk_frac_divider *fd = to_clk_frac_divider(hw);
+	unsigned long div;
+	unsigned maxn = (fd->nmask >> fd->nshift) + 2;
+
+	if (!rate || rate >= *parent_rate)
+		return *parent_rate;
+
+	div = gcd(*parent_rate, rate);
+
+	while ((*parent_rate / div) > maxn) {
+		div <<= 1;
+		rate <<= 1;
+	}
+
+	return rate;
+}
+
+static int clk_frac_divider_set_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long parent_rate)
+{
+	struct clk_frac_divider *fd = to_clk_frac_divider(hw);
+	unsigned long div;
+	unsigned long m, n;
+	u32 val;
+
+	div = gcd(parent_rate, rate);
+	m = rate / div - 1;
+	n = parent_rate / div - 1;
+	if (m && !n)
+		return -EINVAL;
+
+	val = readl_relaxed(fd->reg);
+	val &= ~(fd->mmask | fd->nmask);
+	val |= (m << fd->mshift) | (n << fd->nshift);
+	writel_relaxed(val, fd->reg);
+
+	return 0;
+}
+
+const struct clk_ops clk_frac_divider_ops = {
+	.recalc_rate = clk_frac_divider_recalc_rate,
+	.round_rate = clk_frac_divider_round_rate,
+	.set_rate = clk_frac_divider_set_rate,
+};
+EXPORT_SYMBOL_GPL(clk_frac_divider_ops);
diff --git a/drivers/clk/imx/clk-pfdv2.c b/drivers/clk/imx/clk-pfdv2.c
new file mode 100644
index 0000000..ba0d409
--- /dev/null
+++ b/drivers/clk/imx/clk-pfdv2.c
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+
+#include "clk.h"
+
+/**
+ * struct clk_pfdv2 - IMX PFD clock
+ * @clk_hw:	clock source
+ * @reg:	PFD register address
+ * @idx:	the index of PFD encoded in the register
+ *
+ */
+
+struct clk_pfdv2 {
+	struct clk_hw	hw;
+	void __iomem	*reg;
+	u8		idx;
+};
+
+#define to_clk_pfdv2(_hw) container_of(_hw, struct clk_pfdv2, hw)
+
+static int clk_pfd_enable(struct clk_hw *hw)
+{
+	struct clk_pfdv2 *pfd = to_clk_pfdv2(hw);
+	u32 val;
+
+	val = readl_relaxed(pfd->reg);
+	val &= ~(1 << ((pfd->idx + 1) * 8 - 1));
+	writel_relaxed(val, pfd->reg);
+
+	return 0;
+}
+
+static void clk_pfd_disable(struct clk_hw *hw)
+{
+	struct clk_pfdv2 *pfd = to_clk_pfdv2(hw);
+	u32 val;
+
+	val = readl_relaxed(pfd->reg);
+	val |= 1 << ((pfd->idx + 1) * 8 - 1);
+	writel_relaxed(val, pfd->reg);
+}
+
+static unsigned long clk_pfd_recalc_rate(struct clk_hw *hw,
+					 unsigned long parent_rate)
+{
+	struct clk_pfdv2 *pfd = to_clk_pfdv2(hw);
+	u64 tmp = parent_rate;
+	u8 frac = (readl_relaxed(pfd->reg) >> (pfd->idx * 8)) & 0x3f;
+
+	/*
+	 * The reset value of pfd field is zero, so add one to avoid div
+	 * by zero, optimize this late.
+	 */
+	if (!frac)
+		frac += 1;
+
+	tmp *= 18;
+	do_div(tmp, frac);
+
+	return tmp;
+}
+
+static long clk_pfd_round_rate(struct clk_hw *hw, unsigned long rate,
+			       unsigned long *prate)
+{
+	u64 tmp = *prate;
+	u8 frac;
+
+	tmp = tmp * 18 + rate / 2;
+	do_div(tmp, rate);
+	frac = tmp;
+	if (frac < 12)
+		frac = 12;
+	else if (frac > 35)
+		frac = 35;
+	tmp = *prate;
+	tmp *= 18;
+	do_div(tmp, frac);
+
+	return tmp;
+}
+
+static int clk_pfd_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long parent_rate)
+{
+	struct clk_pfdv2 *pfd = to_clk_pfdv2(hw);
+	u64 tmp = parent_rate;
+	u32 val;
+	u8 frac;
+
+	tmp = tmp * 18 + rate / 2;
+	do_div(tmp, rate);
+	frac = tmp;
+	if (frac < 12)
+		frac = 12;
+	else if (frac > 35)
+		frac = 35;
+
+	val = readl_relaxed(pfd->reg);
+	val &= ~(0x3f << (pfd->idx * 8));
+	val |= frac << (pfd->idx * 8);
+	writel_relaxed(val, pfd->reg);
+
+	return 0;
+}
+
+static int clk_pfd_is_enabled(struct clk_hw *hw)
+{
+	struct clk_pfdv2 *pfd = to_clk_pfdv2(hw);
+
+	if (readl_relaxed(pfd->reg) & (1 << ((pfd->idx + 1) * 8 - 1)))
+		return 0;
+
+	return 1;
+}
+
+static const struct clk_ops clk_pfdv2_ops = {
+	.enable		= clk_pfd_enable,
+	.disable	= clk_pfd_disable,
+	.recalc_rate	= clk_pfd_recalc_rate,
+	.round_rate	= clk_pfd_round_rate,
+	.set_rate	= clk_pfd_set_rate,
+	.is_enabled     = clk_pfd_is_enabled,
+};
+
+struct clk *imx_clk_pfdv2(const char *name, const char *parent_name,
+			void __iomem *reg, u8 idx)
+{
+	struct clk_pfdv2 *pfd;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	pfd = kzalloc(sizeof(*pfd), GFP_KERNEL);
+	if (!pfd)
+		return ERR_PTR(-ENOMEM);
+
+	pfd->reg = reg;
+	pfd->idx = idx;
+
+	init.name = name;
+	init.ops = &clk_pfdv2_ops;
+	init.flags = 0;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	pfd->hw.init = &init;
+
+	clk = clk_register(NULL, &pfd->hw);
+	if (IS_ERR(clk))
+		kfree(pfd);
+
+	return clk;
+}
diff --git a/drivers/clk/imx/clk-pllv4.c b/drivers/clk/imx/clk-pllv4.c
new file mode 100644
index 0000000..9c5829c
--- /dev/null
+++ b/drivers/clk/imx/clk-pllv4.c
@@ -0,0 +1,178 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+
+#include "clk.h"
+
+#define PLL_EN			BIT(0)
+#define BP_PLL_DIV		16
+#define BM_PLL_DIV		(0x7f << 16)
+#define PLL_CFG_OFFSET		0x08
+#define PLL_NUM_OFFSET		0x10
+#define PLL_DENOM_OFFSET	0x14
+
+struct clk_pllv4 {
+	struct clk_hw	hw;
+	void __iomem	*base;
+	u32		div_mask;
+	u32		div_shift;
+	u32		cfg_offset;
+	u32		num_offset;
+	u32		denom_offset;
+};
+
+#define to_clk_pllv4(__hw) container_of(__hw, struct clk_pllv4, hw)
+
+static unsigned long clk_pllv4_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct clk_pllv4 *pll = to_clk_pllv4(hw);
+	u32 mfn = readl_relaxed(pll->base + pll->num_offset);
+	u32 mfd = readl_relaxed(pll->base + pll->denom_offset);
+	u32 div = (readl_relaxed(pll->base + pll->cfg_offset)
+		& pll->div_mask) >> pll->div_shift;
+	u64 temp64 = (u64)parent_rate;
+
+	temp64 *= mfn;
+	do_div(temp64, mfd);
+
+	return (parent_rate * div) + (u32)temp64;
+}
+
+static long clk_pllv4_round_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *prate)
+{
+	unsigned long parent_rate = *prate;
+	unsigned long min_rate = parent_rate * 16;
+	unsigned long max_rate = parent_rate * 30;
+	u32 div;
+	u32 mfn, mfd = 1000000;
+	u64 temp64;
+
+	if (rate > max_rate)
+		rate = max_rate;
+	else if (rate < min_rate)
+		rate = min_rate;
+
+	div = rate / parent_rate;
+	temp64 = (u64) (rate - div * parent_rate);
+	temp64 *= mfd;
+	do_div(temp64, parent_rate);
+	mfn = temp64;
+
+	return parent_rate * div + parent_rate / mfd * mfn;
+}
+
+static int clk_pllv4_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long parent_rate)
+{
+	struct clk_pllv4 *pll = to_clk_pllv4(hw);
+	unsigned long min_rate = parent_rate * 16;
+	unsigned long max_rate = parent_rate * 30;
+	u32 val, div;
+	u32 mfn, mfd = 1000000;
+	u64 temp64;
+
+	if (rate < min_rate || rate > max_rate)
+		return -EINVAL;
+
+	div = rate / parent_rate;
+	temp64 = (u64) (rate - div * parent_rate);
+	temp64 *= mfd;
+	do_div(temp64, parent_rate);
+	mfn = temp64;
+
+	val = readl_relaxed(pll->base + pll->cfg_offset);
+	val &= ~pll->div_mask;
+	val |= div;
+	writel_relaxed(val, pll->base + pll->cfg_offset);
+	writel_relaxed(mfn, pll->base + pll->num_offset);
+	writel_relaxed(mfd, pll->base + pll->denom_offset);
+
+	return 0;
+}
+
+static int clk_pllv4_enable(struct clk_hw *hw)
+{
+	u32 val;
+	struct clk_pllv4 *pll = to_clk_pllv4(hw);
+
+	val = readl_relaxed(pll->base);
+	val |= PLL_EN;
+	writel_relaxed(val, pll->base);
+
+	return 0;
+}
+
+static void clk_pllv4_disable(struct clk_hw *hw)
+{
+	u32 val;
+	struct clk_pllv4 *pll = to_clk_pllv4(hw);
+
+	val = readl_relaxed(pll->base);
+	val &= ~PLL_EN;
+	writel_relaxed(val, pll->base);
+}
+
+static int clk_pllv4_is_enabled(struct clk_hw *hw)
+{
+	struct clk_pllv4 *pll = to_clk_pllv4(hw);
+
+	if (readl_relaxed(pll->base) & PLL_EN)
+		return 0;
+
+	return 1;
+}
+
+static const struct clk_ops clk_pllv4_ops = {
+	.recalc_rate	= clk_pllv4_recalc_rate,
+	.round_rate	= clk_pllv4_round_rate,
+	.set_rate	= clk_pllv4_set_rate,
+	.enable		= clk_pllv4_enable,
+	.disable	= clk_pllv4_disable,
+	.is_enabled	= clk_pllv4_is_enabled,
+};
+
+struct clk *imx_clk_pllv4(const char *name, const char *parent_name,
+			  void __iomem *base)
+{
+	struct clk_pllv4 *pll;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	pll->base = base;
+	pll->div_mask = BM_PLL_DIV;
+	pll->div_shift = BP_PLL_DIV;
+	pll->cfg_offset = PLL_CFG_OFFSET;
+	pll->num_offset = PLL_NUM_OFFSET;
+	pll->denom_offset = PLL_DENOM_OFFSET;
+
+	init.name = name;
+	init.ops = &clk_pllv4_ops;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		kfree(pll);
+
+	return clk;
+}
diff --git a/drivers/clk/imx/clk.h b/drivers/clk/imx/clk.h
index ea9210f..eecee5f 100644
--- a/drivers/clk/imx/clk.h
+++ b/drivers/clk/imx/clk.h
@@ -16,6 +16,7 @@
 extern struct imx_sema4_mutex *amp_power_mutex;
 extern struct imx_shared_mem *shared_mem;
 extern bool uart_from_osc;
+extern const struct clk_ops clk_frac_divider_ops;
 
 enum imx_pllv1_type {
 	IMX_PLLV1_IMX1,
@@ -46,6 +47,21 @@ enum imx_pllv3_type {
 	IMX_PLLV3_PLL2,
 };
 
+/*
+ * frac_divider, found on i.MX7ULP PCC module.
+ * the output clock of the fractional divider is:
+ * Divider output clock = Input clock * (FRAC + 1)
+ * / (DIV + 1)
+ */
+struct clk_frac_divider {
+	struct clk_hw	hw;
+	void __iomem	*reg;
+	u8		mshift;
+	u32		mmask;
+	u8		nshift;
+	u32		nmask;
+};
+
 #define MAX_SHARED_CLK_NUMBER		100
 #define SHARED_MEM_MAGIC_NUMBER		0x12345678
 #define MCC_POWER_SHMEM_NUMBER		(6)
@@ -68,6 +84,9 @@ struct imx_shared_mem {
 struct clk *imx_clk_pllv3(enum imx_pllv3_type type, const char *name,
 		const char *parent_name, void __iomem *base, u32 div_mask);
 
+struct clk *imx_clk_pllv4(const char *name,
+			  const char *parent_name, void __iomem *base);
+
 struct clk *clk_register_gate2(struct device *dev, const char *name,
 		const char *parent_name, unsigned long flags,
 		void __iomem *reg, u8 bit_idx, u8 cgr_val,
@@ -333,4 +352,10 @@ static inline int clk_on_imx6sx(void)
 	return of_machine_is_compatible("fsl,imx6sx");
 }
 
+struct clk *imx_clk_composite(const char *name, const char **parent_name,
+			      int num_parents, bool mux_present, bool rate_present,
+			      bool gate_present, void __iomem *reg);
+
+struct clk *imx_clk_pfdv2(const char *name, const char *parent_name,
+			  void __iomem *reg, u8 idx);
 #endif
-- 
1.7.9.5


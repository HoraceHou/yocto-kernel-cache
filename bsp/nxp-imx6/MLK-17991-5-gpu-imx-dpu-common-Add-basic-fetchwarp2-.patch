From 0d2b8f00ea43f56090747dc820e22615fd5a00fa Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Mon, 9 Apr 2018 17:52:57 +0800
Subject: [PATCH 3585/5242] MLK-17991-5 gpu: imx: dpu: common: Add basic
 fetchwarp2 support

commit  b89c75f0d51a617d20822d339aecba4d44961fa7 from
https://source.codeaurora.org/external/imx/linux-imx.git

Fetchwarp is a type of dpu fetch unit with the additional
warping function.  Each fetchwarp contains 8 subsidiary layers.
Fetchwarp2 can work with fetcheco2 to fetch planar YUV pixel
formats.  Also, it may fetch RGB pixel formats.  This patch
adds basic fetchwarp2 fetch unit support in the dpu common driver
so that it may fetch frames in RGB pixel formats.  YUV pixel formats
and warping function could be supported later.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/dpu/dpu-plane.c |   21 +-
 drivers/gpu/imx/dpu/Makefile        |    4 +-
 drivers/gpu/imx/dpu/dpu-common.c    |  106 +++++-
 drivers/gpu/imx/dpu/dpu-fetchwarp.c |  664 +++++++++++++++++++++++++++++++++++
 drivers/gpu/imx/dpu/dpu-prv.h       |    7 +
 include/video/dpu.h                 |   81 ++++-
 6 files changed, 852 insertions(+), 31 deletions(-)
 create mode 100644 drivers/gpu/imx/dpu/dpu-fetchwarp.c

diff --git a/drivers/gpu/drm/imx/dpu/dpu-plane.c b/drivers/gpu/drm/imx/dpu/dpu-plane.c
index 9639234..47a4fd2 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-plane.c
+++ b/drivers/gpu/drm/imx/dpu/dpu-plane.c
@@ -310,10 +310,10 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 		return -EINVAL;
 	}
 
-	if (fetchunit_has_prefetch(fd, fl) &&
-	    fetchunit_prefetch_format_supported(fd, fl, fb->format->format,
+	if (fetchunit_has_prefetch(fd, fl, NULL) &&
+	    fetchunit_prefetch_format_supported(fd, fl, NULL, fb->format->format,
 						fb->modifier) &&
-	    fetchunit_prefetch_stride_supported(fd, fl, fb->pitches[0],
+	    fetchunit_prefetch_stride_supported(fd, fl, NULL, fb->pitches[0],
 						fb->pitches[1],
 						src_w,
 						fb->format->format))
@@ -364,7 +364,8 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 	}
 
 	if (dpstate->use_prefetch &&
-	    !fetchunit_prefetch_stride_double_check(fd, fl, fb->pitches[0],
+	    !fetchunit_prefetch_stride_double_check(fd, fl, NULL,
+						    fb->pitches[0],
 						    fb->pitches[1],
 						    src_w, fb->format->format,
 						    baseaddr, uv_baseaddr)) {
@@ -629,7 +630,7 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	}
 
 	if (dpstate->use_prefetch) {
-		fetchunit_configure_prefetch(fd, fl, dplane->stream_id,
+		fetchunit_configure_prefetch(fd, fl, NULL, dplane->stream_id,
 					     src_w, src_h, src_x, src_y,
 					     fb->pitches[0], fb->format->format,
 					     fb->modifier,
@@ -637,12 +638,12 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 					     prefetch_start,
 					     aux_prefetch_start);
 		if (prefetch_start || aux_prefetch_start)
-			fetchunit_enable_prefetch(fd, fl);
+			fetchunit_enable_prefetch(fd, fl, NULL);
 
-		fetchunit_reg_update_prefetch(fd, fl);
+		fetchunit_reg_update_prefetch(fd, fl, NULL);
 
 		if (prefetch_start || aux_prefetch_start) {
-			fetchunit_prefetch_first_frame_handle(fd, fl);
+			fetchunit_prefetch_first_frame_handle(fd, fl, NULL);
 
 			if (!need_modeset && is_overlay)
 				framegen_wait_for_frame_counter_moving(fg);
@@ -650,8 +651,8 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 
 		dev_dbg(dev, "[PLANE:%d:%s] use prefetch\n",
 					plane->base.id, plane->name);
-	} else if (fetchunit_has_prefetch(fd, fl)) {
-		fetchunit_disable_prefetch(fd, fl);
+	} else if (fetchunit_has_prefetch(fd, fl, NULL)) {
+		fetchunit_disable_prefetch(fd, fl, NULL);
 
 		dev_dbg(dev, "[PLANE:%d:%s] bypass prefetch\n",
 					plane->base.id, plane->name);
diff --git a/drivers/gpu/imx/dpu/Makefile b/drivers/gpu/imx/dpu/Makefile
index 02be627..9d02625 100644
--- a/drivers/gpu/imx/dpu/Makefile
+++ b/drivers/gpu/imx/dpu/Makefile
@@ -2,5 +2,5 @@ obj-$(CONFIG_IMX_DPU_CORE) += imx-dpu-core.o
 
 imx-dpu-core-objs := dpu-common.o dpu-constframe.o dpu-disengcfg.o \
 		     dpu-extdst.o dpu-fetchdecode.o dpu-fetcheco.o \
-		     dpu-framegen.o dpu-fetchlayer.o dpu-hscaler.o \
-		     dpu-layerblend.o dpu-tcon.o dpu-vscaler.o
+		     dpu-fetchlayer.o dpu-fetchwarp.o dpu-framegen.o \
+		     dpu-hscaler.o dpu-layerblend.o dpu-tcon.o dpu-vscaler.o
diff --git a/drivers/gpu/imx/dpu/dpu-common.c b/drivers/gpu/imx/dpu/dpu-common.c
index 88cc532..b9328c5 100644
--- a/drivers/gpu/imx/dpu/dpu-common.c
+++ b/drivers/gpu/imx/dpu/dpu-common.c
@@ -180,6 +180,12 @@ static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
 static const unsigned long fl_pec_ofss_v1[] = {0xba0, 0xbb0};
 static const unsigned long fl_pec_ofss_v2[] = {0xac0};
 
+/* Fetch Warp Unit */
+static const unsigned long fw_ofss_v1[] = {0x8400};
+static const unsigned long fw_ofss_v2[] = {0x6400};
+static const unsigned long fw_pec_ofss_v1[] = {0xb40};
+static const unsigned long fw_pec_ofss_v2[] = {0xa60};
+
 /* Horizontal Scaler Unit */
 static const unsigned long hs_ofss_v1[] = {0xbc00, 0xd000, 0x3000};
 static const unsigned long hs_ofss_v2[] = {0x9000, 0x9c00, 0x3000};
@@ -318,6 +324,23 @@ static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
 	.dprc_ids = fl_dprc_ids,
 };
 
+static const struct dpu_unit fws_v1 = {
+	.name = "FetchWarp",
+	.num = ARRAY_SIZE(fw_ids),
+	.ids = fw_ids,
+	.pec_ofss = fw_pec_ofss_v1,
+	.ofss = fw_ofss_v1,
+};
+
+static const struct dpu_unit fws_v2 = {
+	.name = "FetchWarp",
+	.num = ARRAY_SIZE(fw_ids),
+	.ids = fw_ids,
+	.pec_ofss = fw_pec_ofss_v2,
+	.ofss = fw_ofss_v2,
+	.dprc_ids = fw_dprc_ids,
+};
+
 static const struct dpu_unit hss_v1 = {
 	.name = "HScaler",
 	.num = ARRAY_SIZE(hs_ids),
@@ -507,6 +530,7 @@ static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
 	.fes = &fes_v1,
 	.fgs = &fgs_v1,
 	.fls = &fls_v1,
+	.fws = &fws_v1,
 	.hss = &hss_v1,
 	.lbs = &lbs_v1,
 	.tcons = &tcons_v1,
@@ -532,6 +556,7 @@ static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
 	.fes = &fes_v2,
 	.fgs = &fgs_v2,
 	.fls = &fls_v2,
+	.fws = &fws_v2,
 	.hss = &hss_v2,
 	.lbs = &lbs_v2,
 	.tcons = &tcons_v2,
@@ -594,30 +619,38 @@ u32 dpu_vproc_get_vscale_cap(u32 cap_mask)
 EXPORT_SYMBOL_GPL(dpu_vproc_get_vscale_cap);
 
 bool fetchunit_has_prefetch(struct dpu_fetchdecode *fd,
-			    struct dpu_fetchlayer *fl)
+			    struct dpu_fetchlayer *fl,
+			    struct dpu_fetchwarp *fw)
 {
 	if (fd)
 		return fetchdecode_has_prefetch(fd);
-	else
+	else if (fl)
 		return fetchlayer_has_prefetch(fl);
+	else
+		return fetchwarp_has_prefetch(fw);
 }
 EXPORT_SYMBOL_GPL(fetchunit_has_prefetch);
 
 bool fetchunit_prefetch_format_supported(struct dpu_fetchdecode *fd,
 					 struct dpu_fetchlayer *fl,
+					 struct dpu_fetchwarp *fw,
 					 u32 format, u64 modifier)
 {
 	if (fd)
 		return fetchdecode_prefetch_format_supported(fd,
 							format, modifier);
-	else
+	else if (fl)
 		return fetchlayer_prefetch_format_supported(fl,
 							format, modifier);
+	else
+		return fetchwarp_prefetch_format_supported(fw,
+							format, modifier);
 }
 EXPORT_SYMBOL_GPL(fetchunit_prefetch_format_supported);
 
 bool fetchunit_prefetch_stride_supported(struct dpu_fetchdecode *fd,
 					 struct dpu_fetchlayer *fl,
+					 struct dpu_fetchwarp *fw,
 					 unsigned int stride,
 					 unsigned int uv_stride,
 					 unsigned int width,
@@ -626,14 +659,18 @@ bool fetchunit_prefetch_stride_supported(struct dpu_fetchdecode *fd,
 	if (fd)
 		return fetchdecode_prefetch_stride_supported(fd,
 					stride, uv_stride, width, format);
-	else
+	else if (fl)
 		return fetchlayer_prefetch_stride_supported(fl,
 					stride, width, format);
+	else
+		return fetchwarp_prefetch_stride_supported(fw,
+					stride, width, format);
 }
 EXPORT_SYMBOL_GPL(fetchunit_prefetch_stride_supported);
 
 bool fetchunit_prefetch_stride_double_check(struct dpu_fetchdecode *fd,
 					    struct dpu_fetchlayer *fl,
+					    struct dpu_fetchwarp *fw,
 					    unsigned int stride,
 					    unsigned int uv_stride,
 					    unsigned int width,
@@ -644,14 +681,18 @@ bool fetchunit_prefetch_stride_double_check(struct dpu_fetchdecode *fd,
 	if (fd)
 		return fetchdecode_prefetch_stride_double_check(fd, stride,
 			uv_stride, width, format, baseaddr, uv_baseaddr);
-	else
+	else if (fl)
 		return fetchlayer_prefetch_stride_double_check(fl, stride,
 						width, format, baseaddr);
+	else
+		return fetchwarp_prefetch_stride_double_check(fw, stride,
+						width, format, baseaddr);
 }
 EXPORT_SYMBOL_GPL(fetchunit_prefetch_stride_double_check);
 
 void fetchunit_configure_prefetch(struct dpu_fetchdecode *fd,
 				  struct dpu_fetchlayer *fl,
+				  struct dpu_fetchwarp *fw,
 				  unsigned int stream_id,
 				  unsigned int width, unsigned int height,
 				  unsigned int x_offset, unsigned int y_offset,
@@ -664,50 +705,66 @@ void fetchunit_configure_prefetch(struct dpu_fetchdecode *fd,
 					x_offset, y_offset, stride,
 					format, modifier, baddr, uv_baddr,
 					start, aux_start);
-	else
+	else if (fl)
 		fetchlayer_configure_prefetch(fl, stream_id, width, height,
 					x_offset, y_offset, stride,
 					format, modifier, baddr, start);
+	else
+		fetchwarp_configure_prefetch(fw, stream_id, width, height,
+					x_offset, y_offset, stride,
+					format, modifier, baddr, start);
 }
 EXPORT_SYMBOL_GPL(fetchunit_configure_prefetch);
 
 void fetchunit_enable_prefetch(struct dpu_fetchdecode *fd,
-			       struct dpu_fetchlayer *fl)
+			       struct dpu_fetchlayer *fl,
+			       struct dpu_fetchwarp *fw)
 {
 	if (fd)
 		fetchdecode_enable_prefetch(fd);
-	else
+	else if (fl)
 		fetchlayer_enable_prefetch(fl);
+	else
+		fetchwarp_enable_prefetch(fw);
 }
 EXPORT_SYMBOL_GPL(fetchunit_enable_prefetch);
 
 void fetchunit_reg_update_prefetch(struct dpu_fetchdecode *fd,
-				   struct dpu_fetchlayer *fl)
+				   struct dpu_fetchlayer *fl,
+				   struct dpu_fetchwarp *fw)
 {
 	if (fd)
 		fetchdecode_reg_update_prefetch(fd);
-	else
+	else if (fl)
 		fetchlayer_reg_update_prefetch(fl);
+	else
+		fetchwarp_reg_update_prefetch(fw);
 }
 EXPORT_SYMBOL_GPL(fetchunit_reg_update_prefetch);
 
 void fetchunit_prefetch_first_frame_handle(struct dpu_fetchdecode *fd,
-					   struct dpu_fetchlayer *fl)
+					   struct dpu_fetchlayer *fl,
+					   struct dpu_fetchwarp *fw)
 {
 	if (fd)
 		fetchdecode_prefetch_first_frame_handle(fd);
-	else
+	else if (fl)
 		fetchlayer_prefetch_first_frame_handle(fl);
+	else
+		fetchwarp_prefetch_first_frame_handle(fw);
 }
 EXPORT_SYMBOL_GPL(fetchunit_prefetch_first_frame_handle);
 
 void fetchunit_disable_prefetch(struct dpu_fetchdecode *fd,
-				struct dpu_fetchlayer *fl)
+				struct dpu_fetchlayer *fl,
+				struct dpu_fetchwarp *fw)
 {
 	if (fd)
 		fetchdecode_disable_prefetch(fd);
-	else
+	else if (fl)
 		fetchlayer_disable_prefetch(fl);
+	else
+		fetchwarp_disable_prefetch(fw);
 }
 EXPORT_SYMBOL_GPL(fetchunit_disable_prefetch);
 
@@ -799,6 +856,7 @@ int dpu_format_plane_height(int height, u32 format, int plane)
 	_DPU_UNITS_INIT(fe);
 	_DPU_UNITS_INIT(fg);
 	_DPU_UNITS_INIT(fl);
+	_DPU_UNITS_INIT(fw);
 	_DPU_UNITS_INIT(hs);
 	_DPU_UNITS_INIT(lb);
 	_DPU_UNITS_INIT(tcon);
@@ -842,6 +900,7 @@ static int dpu_submodules_init(struct dpu_soc *dpu,
 	const struct dpu_devtype *devtype = dpu->devtype;
 	const struct dpu_unit *fds = devtype->fds;
 	const struct dpu_unit *fls = devtype->fls;
+	const struct dpu_unit *fws = devtype->fws;
 
 	DPU_UNITS_INIT(cf);
 	DPU_UNITS_INIT(dec);
@@ -850,6 +909,7 @@ static int dpu_submodules_init(struct dpu_soc *dpu,
 	DPU_UNITS_INIT(fe);
 	DPU_UNITS_INIT(fg);
 	DPU_UNITS_INIT(fl);
+	DPU_UNITS_INIT(fw);
 	DPU_UNITS_INIT(hs);
 	DPU_UNITS_INIT(lb);
 	DPU_UNITS_INIT(tcon);
@@ -859,6 +919,7 @@ static int dpu_submodules_init(struct dpu_soc *dpu,
 	if (devtype->has_prefetch) {
 		struct dpu_fetchdecode *fd;
 		struct dpu_fetchlayer *fl;
+		struct dpu_fetchwarp *fw;
 		struct dprc *dprc;
 		int i;
 
@@ -885,6 +946,18 @@ static int dpu_submodules_init(struct dpu_soc *dpu,
 			fetchlayer_get_dprc(fl, dprc);
 			dpu_fl_put(fl);
 		}
+
+		for (i = 0; i < fws->num; i++) {
+			dprc = dprc_lookup_by_phandle(dpu->dev,
+						      "fsl,dpr-channels",
+						      fws->dprc_ids[i]);
+			if (!dprc)
+				return -EPROBE_DEFER;
+
+			fw = dpu_fw_get(dpu, fw_ids[i]);
+			fetchwarp_get_dprc(fw, dprc);
+			dpu_fw_put(fw);
+		}
 	}
 
 	return 0;
@@ -1425,11 +1498,15 @@ static irqreturn_t dpu_dpr1_irq_handler(int irq, void *desc)
 {
 	struct dpu_soc *dpu = desc;
 	const struct dpu_unit *fds = dpu->devtype->fds;
+	const struct dpu_unit *fws = dpu->devtype->fws;
 	int i;
 
 	for (i = 0; i < fds->num; i++)
 		fetchdecode_prefetch_irq_handle(dpu->fd_priv[i]);
 
+	for (i = 0; i < fws->num; i++)
+		fetchwarp_prefetch_irq_handle(dpu->fw_priv[i]);
+
 	return IRQ_HANDLED;
 }
 
@@ -1725,6 +1802,7 @@ static int dpu_probe(struct platform_device *pdev)
 	DPU_UNITS_ADDR_DBG(fe);
 	DPU_UNITS_ADDR_DBG(fg);
 	DPU_UNITS_ADDR_DBG(fl);
+	DPU_UNITS_ADDR_DBG(fw);
 	DPU_UNITS_ADDR_DBG(hs);
 	DPU_UNITS_ADDR_DBG(lb);
 	DPU_UNITS_ADDR_DBG(tcon);
diff --git a/drivers/gpu/imx/dpu/dpu-fetchwarp.c b/drivers/gpu/imx/dpu/dpu-fetchwarp.c
new file mode 100644
index 0000000..fef6713
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-fetchwarp.c
@@ -0,0 +1,664 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include <video/imx8-prefetch.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_STATUS		0x8
+#define BASEADDRESS(n)			(0x10 + (n) * 0x28)
+#define SOURCEBUFFERATTRIBUTES(n)	(0x14 + (n) * 0x28)
+#define SOURCEBUFFERDIMENSION(n)	(0x18 + (n) * 0x28)
+#define COLORCOMPONENTBITS(n)		(0x1C + (n) * 0x28)
+#define COLORCOMPONENTSHIFT(n)		(0x20 + (n) * 0x28)
+#define LAYEROFFSET(n)			(0x24 + (n) * 0x28)
+#define CLIPWINDOWOFFSET(n)		(0x28 + (n) * 0x28)
+#define CLIPWINDOWDIMENSIONS(n)		(0x2C + (n) * 0x28)
+#define CONSTANTCOLOR(n)		(0x30 + (n) * 0x28)
+#define LAYERPROPERTY(n)		(0x34 + (n) * 0x28)
+#define FRAMEDIMENSIONS			0x150
+#define FRAMERESAMPLING			0x154
+#define WARPCONTROL			0x158
+#define ARBSTARTX			0x15c
+#define ARBSTARTY			0x160
+#define ARBDELTA			0x164
+#define FIRPOSITIONS			0x168
+#define FIRCOEFFICIENTS			0x16c
+#define CONTROL				0x170
+#define TRIGGERENABLE			0x174
+#define SHDLDREQ(lm)			((lm) & 0xFF)
+#define CONTROLTRIGGER			0x178
+#define START				0x17c
+#define FETCHTYPE			0x180
+#define BURSTBUFFERPROPERTIES		0x184
+#define STATUS				0x188
+#define HIDDENSTATUS			0x18c
+
+struct dpu_fetchwarp {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	bool pin_off;
+	struct dpu_soc *dpu;
+	fetchtype_t fetchtype;
+	/* see DPU_PLANE_SRC_xxx */
+	unsigned int stream_id;
+	struct dprc *dprc;
+};
+
+static inline u32 dpu_fw_read(struct dpu_fetchwarp *fw, unsigned int offset)
+{
+	return readl(fw->base + offset);
+}
+
+static inline void dpu_fw_write(struct dpu_fetchwarp *fw, u32 value,
+				unsigned int offset)
+{
+	writel(value, fw->base + offset);
+}
+
+static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
+{
+	return (r << 24) | (g << 16) | (b << 8) | a;
+}
+
+static inline u32 yuv_color(u8 y, u8 u, u8 v)
+{
+	return (y << 24) | (u << 16) | (v << 8);
+}
+
+void fetchwarp_shden(struct dpu_fetchwarp *fw, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_fw_write(fw, val, STATICCONTROL);
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_shden);
+
+void fetchwarp_baddr_autoupdate(struct dpu_fetchwarp *fw, u8 layer_mask)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, STATICCONTROL);
+	val &= ~BASEADDRESSAUTOUPDATE_MASK;
+	val |= BASEADDRESSAUTOUPDATE(layer_mask);
+	dpu_fw_write(fw, val, STATICCONTROL);
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_baddr_autoupdate);
+
+void fetchwarp_shdldreq_sticky(struct dpu_fetchwarp *fw, u8 layer_mask)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, STATICCONTROL);
+	val &= ~SHDLDREQSTICKY_MASK;
+	val |= SHDLDREQSTICKY(layer_mask);
+	dpu_fw_write(fw, val, STATICCONTROL);
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_shdldreq_sticky);
+
+void fetchwarp_set_burstlength(struct dpu_fetchwarp *fw, dma_addr_t baddr,
+			       bool use_prefetch)
+{
+	struct dpu_soc *dpu = fw->dpu;
+	unsigned int burst_size, burst_length;
+	u32 val;
+
+	if (use_prefetch) {
+		/*
+		 * address TKT343664:
+		 * fetch unit base address has to align to burst size
+		 */
+		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = min(burst_size, 128U);
+		burst_length = burst_size / 8;
+	} else {
+		burst_length = 16;
+	}
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, BURSTBUFFERMANAGEMENT);
+	val &= ~SETBURSTLENGTH_MASK;
+	val |= SETBURSTLENGTH(burst_length);
+	dpu_fw_write(fw, val, BURSTBUFFERMANAGEMENT);
+	mutex_unlock(&fw->mutex);
+
+	dev_dbg(dpu->dev, "FetchWarp%d burst length is %u\n",
+							fw->id, burst_length);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_set_burstlength);
+
+void fetchwarp_baseaddress(struct dpu_fetchwarp *fw, unsigned int index,
+			   dma_addr_t paddr)
+{
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, paddr, BASEADDRESS(index));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_baseaddress);
+
+void fetchwarp_source_bpp(struct dpu_fetchwarp *fw, unsigned int index,
+			  int bpp)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, SOURCEBUFFERATTRIBUTES(index));
+	val &= ~0x3f0000;
+	val |= BITSPERPIXEL(bpp);
+	dpu_fw_write(fw, val, SOURCEBUFFERATTRIBUTES(index));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_source_bpp);
+
+void fetchwarp_source_stride(struct dpu_fetchwarp *fw, unsigned int index,
+			     unsigned int width, int bpp, unsigned int stride,
+			     dma_addr_t baddr, bool use_prefetch)
+{
+	unsigned int burst_size;
+	u32 val;
+
+	if (use_prefetch) {
+		/*
+		 * address TKT343664:
+		 * fetch unit base address has to align to burst size
+		 */
+		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = min(burst_size, 128U);
+
+		stride = width * (bpp >> 3);
+		/*
+		 * address TKT339017:
+		 * fixup for burst size vs stride mismatch
+		 */
+		stride = round_up(stride, burst_size);
+	}
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, SOURCEBUFFERATTRIBUTES(index));
+	val &= ~0xffff;
+	val |= STRIDE(stride);
+	dpu_fw_write(fw, val, SOURCEBUFFERATTRIBUTES(index));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_source_stride);
+
+void fetchwarp_src_buf_dimensions(struct dpu_fetchwarp *fw,
+				  unsigned int index, unsigned int w,
+				  unsigned int h)
+{
+	u32 val;
+
+	val = LINEWIDTH(w) | LINECOUNT(h);
+
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, val, SOURCEBUFFERDIMENSION(index));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_src_buf_dimensions);
+
+void fetchwarp_set_fmt(struct dpu_fetchwarp *fw, unsigned int index, u32 fmt)
+{
+	u32 val, bits, shift;
+	int i;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, LAYERPROPERTY(index));
+	val &= ~YUVCONVERSIONMODE_MASK;
+	dpu_fw_write(fw, val, LAYERPROPERTY(index));
+	mutex_unlock(&fw->mutex);
+
+	for (i = 0; i < ARRAY_SIZE(dpu_pixel_format_matrix); i++) {
+		if (dpu_pixel_format_matrix[i].pixel_format == fmt) {
+			bits = dpu_pixel_format_matrix[i].bits;
+			shift = dpu_pixel_format_matrix[i].shift;
+
+			mutex_lock(&fw->mutex);
+			dpu_fw_write(fw, bits, COLORCOMPONENTBITS(index));
+			dpu_fw_write(fw, shift, COLORCOMPONENTSHIFT(index));
+			mutex_unlock(&fw->mutex);
+			return;
+		}
+	}
+
+	WARN_ON(1);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_set_fmt);
+
+void fetchwarp_source_buffer_enable(struct dpu_fetchwarp *fw,
+				    unsigned int index)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, LAYERPROPERTY(index));
+	val |= SOURCEBUFFERENABLE;
+	dpu_fw_write(fw, val, LAYERPROPERTY(index));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_source_buffer_enable);
+
+void fetchwarp_source_buffer_disable(struct dpu_fetchwarp *fw,
+				     unsigned int index)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, LAYERPROPERTY(index));
+	val &= ~SOURCEBUFFERENABLE;
+	dpu_fw_write(fw, val, LAYERPROPERTY(index));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_source_buffer_disable);
+
+bool fetchwarp_is_enabled(struct dpu_fetchwarp *fw, unsigned int index)
+{
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, LAYERPROPERTY(index));
+	mutex_unlock(&fw->mutex);
+
+	return !!(val & SOURCEBUFFERENABLE);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_is_enabled);
+
+void fetchwarp_framedimensions(struct dpu_fetchwarp *fw, unsigned int w,
+			       unsigned int h)
+{
+	u32 val;
+
+	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
+
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, val, FRAMEDIMENSIONS);
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_framedimensions);
+
+void fetchwarp_rgb_constantcolor(struct dpu_fetchwarp *fw,
+				 u8 r, u8 g, u8 b, u8 a)
+{
+	u32 val;
+
+	val = rgb_color(r, g, b, a);
+
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, val, CONSTANTCOLOR(fw->id));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_rgb_constantcolor);
+
+void fetchwarp_yuv_constantcolor(struct dpu_fetchwarp *fw, u8 y, u8 u, u8 v)
+{
+	u32 val;
+
+	val = yuv_color(y, u, v);
+
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, val, CONSTANTCOLOR(fw->id));
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_yuv_constantcolor);
+
+void fetchwarp_controltrigger(struct dpu_fetchwarp *fw, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, val, CONTROLTRIGGER);
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_controltrigger);
+
+int fetchwarp_fetchtype(struct dpu_fetchwarp *fw, fetchtype_t *type)
+{
+	struct dpu_soc *dpu = fw->dpu;
+	u32 val;
+
+	mutex_lock(&fw->mutex);
+	val = dpu_fw_read(fw, FETCHTYPE);
+	val &= FETCHTYPE_MASK;
+	mutex_unlock(&fw->mutex);
+
+	switch (val) {
+	case FETCHTYPE__DECODE:
+		dev_dbg(dpu->dev, "FetchWarp%d with RL and RLAD decoder\n",
+				fw->id);
+		break;
+	case FETCHTYPE__LAYER:
+		dev_dbg(dpu->dev, "FetchWarp%d with fractional "
+				"plane(8 layers)\n", fw->id);
+		break;
+	case FETCHTYPE__WARP:
+		dev_dbg(dpu->dev, "FetchWarp%d with arbitrary warping and "
+				"fractional plane(8 layers)\n", fw->id);
+		break;
+	case FETCHTYPE__ECO:
+		dev_dbg(dpu->dev, "FetchWarp%d with minimum feature set for "
+				"alpha, chroma and coordinate planes\n",
+				fw->id);
+		break;
+	case FETCHTYPE__PERSP:
+		dev_dbg(dpu->dev, "FetchWarp%d with affine, perspective and "
+				"arbitrary warping\n", fw->id);
+		break;
+	case FETCHTYPE__ROT:
+		dev_dbg(dpu->dev, "FetchWarp%d with affine and arbitrary "
+				"warping\n", fw->id);
+		break;
+	case FETCHTYPE__DECODEL:
+		dev_dbg(dpu->dev, "FetchWarp%d with RL and RLAD decoder, "
+				"reduced feature set\n", fw->id);
+		break;
+	case FETCHTYPE__LAYERL:
+		dev_dbg(dpu->dev, "FetchWarp%d with fractional "
+				"plane(8 layers), reduced feature set\n",
+				fw->id);
+		break;
+	case FETCHTYPE__ROTL:
+		dev_dbg(dpu->dev, "FetchWarp%d with affine and arbitrary "
+				"warping, reduced feature set\n", fw->id);
+		break;
+	default:
+		dev_warn(dpu->dev, "Invalid fetch type %u for FetchWarp%d\n",
+				val, fw->id);
+		return -EINVAL;
+	}
+
+	*type = val;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fetchwarp_fetchtype);
+
+unsigned int fetchwarp_get_stream_id(struct dpu_fetchwarp *fw)
+{
+	return fw->stream_id;
+}
+EXPORT_SYMBOL_GPL(fetchwarp_get_stream_id);
+
+void fetchwarp_set_stream_id(struct dpu_fetchwarp *fw, unsigned int id)
+{
+	switch (id) {
+	case DPU_PLANE_SRC_TO_DISP_STREAM0:
+	case DPU_PLANE_SRC_TO_DISP_STREAM1:
+	case DPU_PLANE_SRC_DISABLED:
+		fw->stream_id = id;
+		break;
+	default:
+		WARN_ON(1);
+	}
+}
+EXPORT_SYMBOL_GPL(fetchwarp_set_stream_id);
+
+void
+fetchwarp_configure_prefetch(struct dpu_fetchwarp *fw, unsigned int stream_id,
+			     unsigned int width, unsigned int height,
+			     unsigned int x_offset, unsigned int y_offset,
+			     unsigned int stride, u32 format, u64 modifier,
+			     unsigned long baddr, bool start)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_configure(fw->dprc,
+			stream_id, width, height, x_offset, y_offset, stride,
+			format, modifier, baddr, 0, start, false);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_configure_prefetch);
+
+void fetchwarp_enable_prefetch(struct dpu_fetchwarp *fw)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_enable(fw->dprc);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_enable_prefetch);
+
+void fetchwarp_disable_prefetch(struct dpu_fetchwarp *fw)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_disable(fw->dprc);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_disable_prefetch);
+
+void fetchwarp_reg_update_prefetch(struct dpu_fetchwarp *fw)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_reg_update(fw->dprc);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_reg_update_prefetch);
+
+void fetchwarp_prefetch_first_frame_handle(struct dpu_fetchwarp *fw)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_first_frame_handle(fw->dprc);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_prefetch_first_frame_handle);
+
+void fetchwarp_prefetch_irq_handle(struct dpu_fetchwarp *fw)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_irq_handle(fw->dprc);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_prefetch_irq_handle);
+
+void fetchwarp_prefetch_enable_first_frame_irq(struct dpu_fetchwarp *fw)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return;
+
+	dprc_enable_ctrl_done_irq(fw->dprc);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_prefetch_enable_first_frame_irq);
+
+bool fetchwarp_has_prefetch(struct dpu_fetchwarp *fw)
+{
+	return !!fw->dprc;
+}
+EXPORT_SYMBOL_GPL(fetchwarp_has_prefetch);
+
+bool fetchwarp_prefetch_format_supported(struct dpu_fetchwarp *fw,
+					 u32 format, u64 modifier)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return false;
+
+	return dprc_format_supported(fw->dprc, format, modifier);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_prefetch_format_supported);
+
+bool fetchwarp_prefetch_stride_supported(struct dpu_fetchwarp *fw,
+					 unsigned int stride,
+					 unsigned int width,
+					 u32 format)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return false;
+
+	return dprc_stride_supported(fw->dprc, stride, 0, width, format);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_prefetch_stride_supported);
+
+bool fetchwarp_prefetch_stride_double_check(struct dpu_fetchwarp *fw,
+					    unsigned int stride,
+					    unsigned int width,
+					    u32 format,
+					    dma_addr_t baseaddr)
+{
+	if (WARN_ON(!fw || !fw->dprc))
+		return false;
+
+	return dprc_stride_double_check(fw->dprc, stride, 0, width, format,
+					baseaddr, 0);
+}
+EXPORT_SYMBOL_GPL(fetchwarp_prefetch_stride_double_check);
+
+void fetchwarp_pin_off(struct dpu_fetchwarp *fw)
+{
+	fw->pin_off = true;
+}
+EXPORT_SYMBOL_GPL(fetchwarp_pin_off);
+
+void fetchwarp_unpin_off(struct dpu_fetchwarp *fw)
+{
+	fw->pin_off = false;
+}
+EXPORT_SYMBOL_GPL(fetchwarp_unpin_off);
+
+bool fetchwarp_is_pinned_off(struct dpu_fetchwarp *fw)
+{
+	return fw->pin_off;
+}
+EXPORT_SYMBOL_GPL(fetchwarp_is_pinned_off);
+
+struct dpu_fetchwarp *dpu_fw_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_fetchwarp *fw;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fw_ids); i++)
+		if (fw_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fw_ids))
+		return ERR_PTR(-EINVAL);
+
+	fw = dpu->fw_priv[i];
+
+	mutex_lock(&fw->mutex);
+
+	if (fw->inuse) {
+		fw = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fw->inuse = true;
+out:
+	mutex_unlock(&fw->mutex);
+
+	return fw;
+}
+EXPORT_SYMBOL_GPL(dpu_fw_get);
+
+void dpu_fw_put(struct dpu_fetchwarp *fw)
+{
+	mutex_lock(&fw->mutex);
+
+	fw->inuse = false;
+
+	mutex_unlock(&fw->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fw_put);
+
+void _dpu_fw_init(struct dpu_soc *dpu, unsigned int id)
+{
+	struct dpu_fetchwarp *fw;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fw_ids); i++)
+		if (fw_ids[i] == id)
+			break;
+
+	if (WARN_ON(i == ARRAY_SIZE(fw_ids)))
+		return;
+
+	fw = dpu->fw_priv[i];
+
+	fetchwarp_baddr_autoupdate(fw, 0x0);
+	fetchwarp_shden(fw, true);
+	fetchwarp_shdldreq_sticky(fw, 0xFF);
+	for (i = 0; i < DPU_FRAC_PLANE_LAYER_NUM; i++)
+		fetchwarp_source_buffer_disable(fw, i);
+
+	mutex_lock(&fw->mutex);
+	dpu_fw_write(fw, SETNUMBUFFERS(16) | SETBURSTLENGTH(16),
+			BURSTBUFFERMANAGEMENT);
+	mutex_unlock(&fw->mutex);
+}
+
+int dpu_fw_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_fetchwarp *fw;
+	int i, ret;
+
+	fw = devm_kzalloc(dpu->dev, sizeof(*fw), GFP_KERNEL);
+	if (!fw)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(fw_ids); i++)
+		if (fw_ids[i] == id)
+			break;
+
+	dpu->fw_priv[i] = fw;
+
+	fw->pec_base = devm_ioremap(dpu->dev, base, SZ_16);
+	if (!fw->pec_base)
+		return -ENOMEM;
+
+	fw->base = devm_ioremap(dpu->dev, base, SZ_512);
+	if (!fw->base)
+		return -ENOMEM;
+
+	fw->dpu = dpu;
+	fw->id = id;
+
+	mutex_init(&fw->mutex);
+
+	ret = fetchwarp_fetchtype(fw, &fw->fetchtype);
+	if (ret < 0)
+		return ret;
+
+	_dpu_fw_init(dpu, id);
+
+	return 0;
+}
+
+void fetchwarp_get_dprc(struct dpu_fetchwarp *fw, void *data)
+{
+	if (WARN_ON(!fw))
+		return;
+
+	fw->dprc = data;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-prv.h b/drivers/gpu/imx/dpu/dpu-prv.h
index d3569dc..48fcf9f 100644
--- a/drivers/gpu/imx/dpu/dpu-prv.h
+++ b/drivers/gpu/imx/dpu/dpu-prv.h
@@ -188,6 +188,7 @@ struct dpu_devtype {
 	const struct dpu_unit *fes;
 	const struct dpu_unit *fgs;
 	const struct dpu_unit *fls;
+	const struct dpu_unit *fws;
 	const struct dpu_unit *hss;
 	const struct dpu_unit *lbs;
 	const struct dpu_unit *tcons;
@@ -240,6 +241,7 @@ struct dpu_soc {
 	struct dpu_fetcheco	*fe_priv[4];
 	struct dpu_framegen	*fg_priv[2];
 	struct dpu_fetchlayer	*fl_priv[2];
+	struct dpu_fetchwarp	*fw_priv[1];
 	struct dpu_hscaler	*hs_priv[3];
 	struct dpu_layerblend	*lb_priv[7];
 	struct dpu_tcon		*tcon_priv[2];
@@ -262,6 +264,7 @@ struct dpu_soc {
 _DECLARE_DPU_UNIT_INIT_FUNC(fe);
 _DECLARE_DPU_UNIT_INIT_FUNC(fg);
 _DECLARE_DPU_UNIT_INIT_FUNC(fl);
+_DECLARE_DPU_UNIT_INIT_FUNC(fw);
 _DECLARE_DPU_UNIT_INIT_FUNC(hs);
 _DECLARE_DPU_UNIT_INIT_FUNC(lb);
 _DECLARE_DPU_UNIT_INIT_FUNC(tcon);
@@ -278,6 +281,7 @@ struct dpu_soc {
 DECLARE_DPU_UNIT_INIT_FUNC(fe);
 DECLARE_DPU_UNIT_INIT_FUNC(fg);
 DECLARE_DPU_UNIT_INIT_FUNC(fl);
+DECLARE_DPU_UNIT_INIT_FUNC(fw);
 DECLARE_DPU_UNIT_INIT_FUNC(hs);
 DECLARE_DPU_UNIT_INIT_FUNC(lb);
 DECLARE_DPU_UNIT_INIT_FUNC(tcon);
@@ -285,6 +289,7 @@ struct dpu_soc {
 
 void fetchdecode_get_dprc(struct dpu_fetchdecode *fd, void *data);
 void fetchlayer_get_dprc(struct dpu_fetchlayer *fl, void *data);
+void fetchwarp_get_dprc(struct dpu_fetchwarp *fw, void *data);
 
 static const unsigned int cf_ids[] = {0, 1, 4, 5};
 static const unsigned int dec_ids[] = {0, 1};
@@ -293,6 +298,7 @@ struct dpu_soc {
 static const unsigned int fe_ids[] = {0, 1, 2, 9};
 static const unsigned int fg_ids[] = {0, 1};
 static const unsigned int fl_ids[] = {0, 1};
+static const unsigned int fw_ids[] = {2};
 static const unsigned int hs_ids[] = {4, 5, 9};
 static const unsigned int lb_ids[] = {0, 1, 2, 3, 4, 5, 6};
 static const unsigned int tcon_ids[] = {0, 1};
@@ -300,6 +306,7 @@ struct dpu_soc {
 
 static const unsigned int fd_dprc_ids[] = {3, 4};
 static const unsigned int fl_dprc_ids[] = {2};
+static const unsigned int fw_dprc_ids[] = {5};
 
 struct dpu_pixel_format {
 	u32 pixel_format;
diff --git a/include/video/dpu.h b/include/video/dpu.h
index ddcd147..5da768d 100644
--- a/include/video/dpu.h
+++ b/include/video/dpu.h
@@ -638,6 +638,68 @@ bool fetchlayer_prefetch_stride_double_check(struct dpu_fetchlayer *fl,
 struct dpu_fetchlayer *dpu_fl_get(struct dpu_soc *dpu, int id);
 void dpu_fl_put(struct dpu_fetchlayer *fl);
 
+/* Fetch Warp Unit */
+struct dpu_fetchwarp;
+void fetchwarp_shden(struct dpu_fetchwarp *fw, bool enable);
+void fetchwarp_baddr_autoupdate(struct dpu_fetchwarp *fw, u8 layer_mask);
+void fetchwarp_shdldreq_sticky(struct dpu_fetchwarp *fw, u8 layer_mask);
+void fetchwarp_set_burstlength(struct dpu_fetchwarp *fw, dma_addr_t baddr,
+			       bool use_prefetch);
+void fetchwarp_baseaddress(struct dpu_fetchwarp *fw, unsigned int index,
+			   dma_addr_t paddr);
+void fetchwarp_source_bpp(struct dpu_fetchwarp *fw, unsigned int index,
+			  int bpp);
+void fetchwarp_source_stride(struct dpu_fetchwarp *fw, unsigned int index,
+			     unsigned int width, int bpp, unsigned int stride,
+			     dma_addr_t baddr, bool use_prefetch);
+void fetchwarp_src_buf_dimensions(struct dpu_fetchwarp *fw,
+				  unsigned int index, unsigned int w,
+				  unsigned int h);
+void fetchwarp_set_fmt(struct dpu_fetchwarp *fw, unsigned int index, u32 fmt);
+void fetchwarp_source_buffer_enable(struct dpu_fetchwarp *fw,
+				    unsigned int index);
+void fetchwarp_source_buffer_disable(struct dpu_fetchwarp *fw,
+				     unsigned int index);
+bool fetchwarp_is_enabled(struct dpu_fetchwarp *fw, unsigned int index);
+void fetchwarp_framedimensions(struct dpu_fetchwarp *fw, unsigned int w,
+			       unsigned int h);
+void fetchwarp_rgb_constantcolor(struct dpu_fetchwarp *fw,
+				 u8 r, u8 g, u8 b, u8 a);
+void fetchwarp_yuv_constantcolor(struct dpu_fetchwarp *fw, u8 y, u8 u, u8 v);
+void fetchwarp_controltrigger(struct dpu_fetchwarp *fw, bool trigger);
+int fetchwarp_fetchtype(struct dpu_fetchwarp *fw, fetchtype_t *type);
+unsigned int fetchwarp_get_stream_id(struct dpu_fetchwarp *fw);
+void fetchwarp_set_stream_id(struct dpu_fetchwarp *fw, unsigned int id);
+void
+fetchwarp_configure_prefetch(struct dpu_fetchwarp *fw, unsigned int stream_id,
+			     unsigned int width, unsigned int height,
+			     unsigned int x_offset, unsigned int y_offset,
+			     unsigned int stride, u32 format, u64 modifier,
+			     unsigned long baddr, bool start);
+void fetchwarp_enable_prefetch(struct dpu_fetchwarp *fw);
+void fetchwarp_disable_prefetch(struct dpu_fetchwarp *fw);
+void fetchwarp_reg_update_prefetch(struct dpu_fetchwarp *fw);
+void fetchwarp_prefetch_first_frame_handle(struct dpu_fetchwarp *fw);
+void fetchwarp_prefetch_irq_handle(struct dpu_fetchwarp *fw);
+void fetchwarp_prefetch_enable_first_frame_irq(struct dpu_fetchwarp *fw);
+bool fetchwarp_has_prefetch(struct dpu_fetchwarp *fw);
+bool fetchwarp_prefetch_format_supported(struct dpu_fetchwarp *fw,
+					 u32 format, u64 modifier);
+bool fetchwarp_prefetch_stride_supported(struct dpu_fetchwarp *fw,
+					 unsigned int stride,
+					 unsigned int width,
+					 u32 format);
+bool fetchwarp_prefetch_stride_double_check(struct dpu_fetchwarp *fw,
+					    unsigned int stride,
+					    unsigned int width,
+					    u32 format,
+					    dma_addr_t baseaddr);
+void fetchwarp_pin_off(struct dpu_fetchwarp *fw);
+void fetchwarp_unpin_off(struct dpu_fetchwarp *fw);
+bool fetchwarp_is_pinned_off(struct dpu_fetchwarp *fw);
+struct dpu_fetchwarp *dpu_fw_get(struct dpu_soc *dpu, int id);
+void dpu_fw_put(struct dpu_fetchwarp *fw);
+
 /* Frame Generator Unit */
 struct dpu_framegen;
 void framegen_enable(struct dpu_framegen *fg);
@@ -740,18 +802,22 @@ void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
 u32 dpu_vproc_get_vscale_cap(u32 cap_mask);
 
 bool fetchunit_has_prefetch(struct dpu_fetchdecode *fd,
-			    struct dpu_fetchlayer *fl);
+			    struct dpu_fetchlayer *fl,
+			    struct dpu_fetchwarp *fw);
 bool fetchunit_prefetch_format_supported(struct dpu_fetchdecode *fd,
 					 struct dpu_fetchlayer *fl,
+					 struct dpu_fetchwarp *fw,
 					 u32 format, u64 modifier);
 bool fetchunit_prefetch_stride_supported(struct dpu_fetchdecode *fd,
 					 struct dpu_fetchlayer *fl,
+					 struct dpu_fetchwarp *fw,
 					 unsigned int stride,
 					 unsigned int uv_stride,
 					 unsigned int width,
 					 u32 format);
 bool fetchunit_prefetch_stride_double_check(struct dpu_fetchdecode *fd,
 					    struct dpu_fetchlayer *fl,
+					    struct dpu_fetchwarp *fw,
 					    unsigned int stride,
 					    unsigned int uv_stride,
 					    unsigned int width,
@@ -760,6 +826,7 @@ bool fetchunit_prefetch_stride_double_check(struct dpu_fetchdecode *fd,
 					    dma_addr_t uv_baseaddr);
 void fetchunit_configure_prefetch(struct dpu_fetchdecode *fd,
 				  struct dpu_fetchlayer *fl,
+				  struct dpu_fetchwarp *fw,
 				  unsigned int stream_id,
 				  unsigned int width, unsigned int height,
 				  unsigned int x_offset, unsigned int y_offset,
@@ -767,13 +834,17 @@ void fetchunit_configure_prefetch(struct dpu_fetchdecode *fd,
 				  unsigned long baddr, unsigned long uv_baddr,
 				  bool start, bool aux_start);
 void fetchunit_enable_prefetch(struct dpu_fetchdecode *fd,
-			       struct dpu_fetchlayer *fl);
+			       struct dpu_fetchlayer *fl,
+			       struct dpu_fetchwarp *fw);
 void fetchunit_reg_update_prefetch(struct dpu_fetchdecode *fd,
-				   struct dpu_fetchlayer *fl);
+				   struct dpu_fetchlayer *fl,
+				   struct dpu_fetchwarp *fw);
 void fetchunit_prefetch_first_frame_handle(struct dpu_fetchdecode *fd,
-					   struct dpu_fetchlayer *fl);
+					   struct dpu_fetchlayer *fl,
+					   struct dpu_fetchwarp *fw);
 void fetchunit_disable_prefetch(struct dpu_fetchdecode *fd,
-				struct dpu_fetchlayer *fl);
+				struct dpu_fetchlayer *fl,
+				struct dpu_fetchwarp *fw);
 
 /* dpu blit engine */
 struct dpu_bliteng;
-- 
1.7.9.5


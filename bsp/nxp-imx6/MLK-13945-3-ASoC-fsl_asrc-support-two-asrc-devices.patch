From 5a5b35f99670603ef86d9a0a60e46283513f6993 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@freescale.com>
Date: Wed, 5 Jul 2017 15:29:40 +0800
Subject: [PATCH 2059/5242] MLK-13945-3: ASoC: fsl_asrc: support two asrc
 devices

commit  337c730036daecccf05634ae15b2f449989529c6 from
https://source.codeaurora.org/external/imx/linux-imx.git

In imx8qm, there is two asrc devices, so using global structure
"miscdevice" will cause error. Each instance should have their
own structure.

Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
Reviewed-by: Daniel Baluta <daniel.baluta@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_asrc.c     |    8 ++++++++
 sound/soc/fsl/fsl_asrc.h     |    3 +++
 sound/soc/fsl/fsl_asrc_m2m.c |   29 +++++++++++++++--------------
 3 files changed, 26 insertions(+), 14 deletions(-)

diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c
index 4e132ee..14c62e9 100644
--- a/sound/soc/fsl/fsl_asrc.c
+++ b/sound/soc/fsl/fsl_asrc.c
@@ -1063,18 +1063,26 @@ static int fsl_asrc_probe(struct platform_device *pdev)
 
 	if (of_device_is_compatible(np, "fsl,imx35-asrc")) {
 		asrc_priv->channel_bits = 3;
+		strncpy(asrc_priv->name, "mxc_asrc",
+				sizeof(asrc_priv->name) - 1);
 		clk_map[IN] = input_clk_map_imx35;
 		clk_map[OUT] = output_clk_map_imx35;
 	} else if (of_device_is_compatible(np, "fsl,imx53-asrc")) {
 		asrc_priv->channel_bits = 4;
+		strncpy(asrc_priv->name, "mxc_asrc",
+				sizeof(asrc_priv->name) - 1);
 		clk_map[IN] = input_clk_map_imx53;
 		clk_map[OUT] = output_clk_map_imx53;
 	} else if (of_device_is_compatible(np, "fsl,imx8qm-asrc0")) {
 		asrc_priv->channel_bits = 4;
+		strncpy(asrc_priv->name, "mxc_asrc",
+				sizeof(asrc_priv->name) - 1);
 		clk_map[IN] = input_clk_map_imx8_0;
 		clk_map[OUT] = output_clk_map_imx8_0;
 	} else if (of_device_is_compatible(np, "fsl,imx8qm-asrc1")) {
 		asrc_priv->channel_bits = 4;
+		strncpy(asrc_priv->name, "mxc_asrc1",
+				sizeof(asrc_priv->name) - 1);
 		clk_map[IN] = input_clk_map_imx8_1;
 		clk_map[OUT] = output_clk_map_imx8_1;
 	}
diff --git a/sound/soc/fsl/fsl_asrc.h b/sound/soc/fsl/fsl_asrc.h
index a2c5be9..3a1530d 100644
--- a/sound/soc/fsl/fsl_asrc.h
+++ b/sound/soc/fsl/fsl_asrc.h
@@ -14,6 +14,7 @@
 #define _FSL_ASRC_H
 
 #include <uapi/linux/mxc_asrc.h>
+#include <linux/miscdevice.h>
 
 #define IN	0
 #define OUT	1
@@ -362,6 +363,7 @@ struct fsl_asrc {
 
 	struct snd_pcm_substream *substream[2];
 	struct fsl_asrc_pair *pair[ASRC_PAIR_MAX_NUM];
+	struct miscdevice asrc_miscdev;
 	unsigned int channel_bits;
 	unsigned int channel_avail;
 	unsigned int pair_streams;
@@ -370,6 +372,7 @@ struct fsl_asrc {
 	int asrc_width;
 
 	u32 regcache_cfg;
+	char name[20];
 };
 
 #define DRV_NAME "fsl-asrc-dai"
diff --git a/sound/soc/fsl/fsl_asrc_m2m.c b/sound/soc/fsl/fsl_asrc_m2m.c
index 3e5431e..14877b4 100644
--- a/sound/soc/fsl/fsl_asrc_m2m.c
+++ b/sound/soc/fsl/fsl_asrc_m2m.c
@@ -29,11 +29,6 @@ struct fsl_asrc_m2m {
 	spinlock_t lock;
 };
 
-static struct miscdevice asrc_miscdev = {
-	.name	= "mxc_asrc",
-	.minor	= MISC_DYNAMIC_MINOR,
-};
-
 static void fsl_asrc_get_status(struct fsl_asrc_pair *pair,
 				struct asrc_status_flags *flags)
 {
@@ -766,7 +761,8 @@ static long fsl_asrc_ioctl_flush(struct fsl_asrc_pair *pair, void __user *user)
 
 static long fsl_asrc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct fsl_asrc_pair *pair = file->private_data;
+	struct miscdevice *asrc_miscdev = file->private_data;
+	struct fsl_asrc_pair *pair = dev_get_drvdata(asrc_miscdev->this_device);
 	struct fsl_asrc *asrc_priv = pair->asrc_priv;
 	void __user *user = (void __user *)arg;
 	long ret = 0;
@@ -806,7 +802,8 @@ static long fsl_asrc_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 
 static int fsl_asrc_open(struct inode *inode, struct file *file)
 {
-	struct fsl_asrc *asrc_priv = dev_get_drvdata(asrc_miscdev.this_device);
+	struct miscdevice *asrc_miscdev = file->private_data;
+	struct fsl_asrc *asrc_priv = dev_get_drvdata(asrc_miscdev->parent);
 	struct device *dev = &asrc_priv->pdev->dev;
 	struct fsl_asrc_pair *pair;
 	struct fsl_asrc_m2m *m2m;
@@ -836,7 +833,7 @@ static int fsl_asrc_open(struct inode *inode, struct file *file)
 
 	spin_lock_init(&m2m->lock);
 
-	file->private_data = pair;
+	dev_set_drvdata(asrc_miscdev->this_device, pair);
 
 	pm_runtime_get_sync(dev);
 
@@ -849,7 +846,8 @@ static int fsl_asrc_open(struct inode *inode, struct file *file)
 
 static int fsl_asrc_close(struct inode *inode, struct file *file)
 {
-	struct fsl_asrc_pair *pair = file->private_data;
+	struct miscdevice *asrc_miscdev = file->private_data;
+	struct fsl_asrc_pair *pair = dev_get_drvdata(asrc_miscdev->this_device);
 	struct fsl_asrc_m2m *m2m = pair->private;
 	struct fsl_asrc *asrc_priv = pair->asrc_priv;
 	struct device *dev = &asrc_priv->pdev->dev;
@@ -887,7 +885,6 @@ static int fsl_asrc_close(struct inode *inode, struct file *file)
 	kfree(m2m);
 	kfree(pair);
 	spin_unlock_irqrestore(&asrc_priv->lock, lock_flags);
-	file->private_data = NULL;
 
 	pm_runtime_put_sync(dev);
 
@@ -906,20 +903,24 @@ static int fsl_asrc_m2m_init(struct fsl_asrc *asrc_priv)
 	struct device *dev = &asrc_priv->pdev->dev;
 	int ret;
 
-	asrc_miscdev.fops = &asrc_fops,
-	ret = misc_register(&asrc_miscdev);
+	asrc_priv->asrc_miscdev.fops = &asrc_fops;
+	asrc_priv->asrc_miscdev.parent = dev;
+	asrc_priv->asrc_miscdev.name = asrc_priv->name;
+	asrc_priv->asrc_miscdev.minor = MISC_DYNAMIC_MINOR;
+	ret = misc_register(&asrc_priv->asrc_miscdev);
 	if (ret) {
 		dev_err(dev, "failed to register char device %d\n", ret);
 		return ret;
 	}
-	dev_set_drvdata(asrc_miscdev.this_device, asrc_priv);
 
 	return 0;
 }
 
 static int fsl_asrc_m2m_remove(struct platform_device *pdev)
 {
-	misc_deregister(&asrc_miscdev);
+	struct fsl_asrc *asrc_priv = dev_get_drvdata(&pdev->dev);
+
+	misc_deregister(&asrc_priv->asrc_miscdev);
 	return 0;
 }
 
-- 
1.7.9.5


From aa50fce4b2950ea28d8eb4d28c943d60ab84ad26 Mon Sep 17 00:00:00 2001
From: ming_qian <ming.qian@nxp.com>
Date: Tue, 25 Sep 2018 16:39:36 +0800
Subject: [PATCH 4733/5242] MLK-19688-3: refactor and cleanup vpu encoder
 driver

commit  2c369d49889c43534b7701b2fa905371fa38339f from
https://source.codeaurora.org/external/imx/linux-imx.git

1.move the definition of reg fw base to dts
2.rm unused vpu clock setting

Signed-off-by: ming_qian <ming.qian@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi      |    4 +-
 .../boot/dts/freescale/fsl-imx8qm-mek-domu.dts     |    1 +
 arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi      |    1 +
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c        |  105 +++++++++-----------
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h        |    3 +-
 5 files changed, 52 insertions(+), 62 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi
index d6086c9..acd48f3 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi
@@ -3282,10 +3282,8 @@
 		rpc-region = <&encoder_rpc>;
 		reg = <0x0 0x2d000000 0x0 0x1000000>;
 		reg-names = "vpu_regs";
-		clocks = <&clk IMX8QXP_VPU_ENC_CLK>;
-		clock-names = "vpu_encoder_clk";
-		assigned-clocks = <&clk IMX8QXP_VPU_ENC_CLK>;
 		power-domains = <&pd_vpu_enc>;
+		reg-fw-base = <0x50000>;
 		status = "disabled";
 	};
 	imx_rpmsg: imx_rpmsg {
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts b/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts
index 1a6d199..33cc440 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts
@@ -231,6 +231,7 @@
 			reg = <0x0 0x2d000000 0x0 0x1000000>;
 			reg-names = "vpu_regs";
 			power-domains = <&pd_vpu_enc>;
+			reg-fw-addr = <0x90000 0xa0000>;
 			status = "disabled";
 		};
 
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi
index 6b17aa9..c83f463 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi
@@ -196,6 +196,7 @@
 		reg = <0x0 0x2d000000 0x0 0x1000000>;
 		reg-names = "vpu_regs";
 		power-domains = <&pd_vpu_enc>;
+		reg-fw-addr = <0x90000 0xa0000>;
 		status = "disabled";
 	};
 
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index 6dcbdc9..0474a5a 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -113,6 +113,11 @@ static void vpu_log_cmd(u_int32 cmdid, u_int32 ctxid)
 				cmd2str[cmdid], ctxid);
 }
 
+static void write_enc_reg(struct vpu_dev *dev, u32 val, off_t reg)
+{
+	writel(val, dev->regs_enc + reg);
+}
+
 /*
  * v4l2 ioctl() operation
  *
@@ -1594,11 +1599,21 @@ static void release_queue_data(struct vpu_ctx *ctx)
 		vb2_queue_release(&This->vb2_q);
 }
 
+static int set_vpu_fw_addr(struct vpu_dev *dev, struct core_device *core_dev)
+{
+	if (!dev || !core_dev)
+		return -EINVAL;
+
+	write_enc_reg(dev, core_dev->m0_p_fw_space_phy, core_dev->reg_fw_base);
+	write_enc_reg(dev, 0x0, core_dev->reg_fw_base + 4);
+
+	return 0;
+}
+
 static int vpu_firmware_download(struct vpu_dev *This, u_int32 core_id)
 {
 	unsigned char *image;
 	unsigned int FW_Size = 0;
-	void *csr_offset, *csr_cpuwait;
 	int ret = 0;
 	char *p = This->core_dev[core_id].m0_p_fw_space_vir;
 
@@ -1625,30 +1640,9 @@ static int vpu_firmware_download(struct vpu_dev *This, u_int32 core_id)
 			image,
 			FW_Size
 			);
-	if (This->plat_type == IMX8QM) { //encoder use core 1,2
-		if (core_id == 0) {
-			p[16] = IMX8QM;
-			p[17] = core_id + 1;
-			csr_offset = ioremap(0x2d090000, 4);
-			writel(This->core_dev[core_id].m0_p_fw_space_phy, csr_offset);
-			csr_cpuwait = ioremap(0x2d090004, 4);
-			writel(0x0, csr_cpuwait);
-		} else {
-			p[16] = IMX8QM;
-			p[17] = core_id + 1;
-			csr_offset = ioremap(0x2d0a0000, 4);
-			writel(This->core_dev[core_id].m0_p_fw_space_phy, csr_offset);
-			csr_cpuwait = ioremap(0x2d0a0004, 4);
-			writel(0x0, csr_cpuwait);
-		}
-	} else {
-		p[16] = IMX8QXP;
-		p[17] = core_id + 1;
-		csr_offset = ioremap(0x2d050000, 4);
-		writel(This->core_dev[core_id].m0_p_fw_space_phy, csr_offset);
-		csr_cpuwait = ioremap(0x2d050004, 4);
-		writel(0x0, csr_cpuwait);
-	}
+	p[16] = This->plat_type;
+	p[17] = core_id + 1;
+	set_vpu_fw_addr(This, &This->core_dev[core_id]);
 
 	return ret;
 }
@@ -1962,14 +1956,8 @@ static void vpu_reset(struct vpu_dev *This)
 static int vpu_enable_hw(struct vpu_dev *This)
 {
 	vpu_dbg(LVL_INFO, "%s()\n", __func__);
-#if 0
-	This->vpu_clk = clk_get(&This->plat_dev->dev, "vpu_encoder_clk");
-	if (IS_ERR(This->vpu_clk)) {
-		vpu_dbg(LVL_ERR, "vpu_clk get error\n");
-		return -ENOENT;
-	}
-#endif
 	vpu_setup(This);
+
 	return 0;
 }
 
@@ -1977,14 +1965,9 @@ static void vpu_disable_hw(struct vpu_dev *This)
 {
 	vpu_reset(This);
 	if (This->regs_base) {
-		devm_iounmap(&This->plat_dev->dev,
-				This->regs_base);
-	}
-#if 0
-	if (This->vpu_clk) {
-		clk_put(This->vpu_clk);
+		iounmap(This->regs_base);
+		This->regs_base = NULL;
 	}
-#endif
 }
 
 static int get_platform_info_by_core_type(struct vpu_dev *dev, u32 core_type)
@@ -2017,6 +2000,7 @@ static int parse_dt_info(struct vpu_dev *dev, struct device_node *np)
 	struct device_node *reserved_node = NULL;
 	struct resource reserved_res;
 	u_int32 core_type;
+	u32 i;
 
 	if (!dev || !np)
 		return -EINVAL;
@@ -2059,6 +2043,18 @@ static int parse_dt_info(struct vpu_dev *dev, struct device_node *np)
 	dev->core_dev[0].m0_rpc_phy = reserved_res.start;
 	dev->core_dev[1].m0_rpc_phy = reserved_res.start + SHARED_SIZE;
 
+	for (i = 0; i < dev->core_num; i++) {
+		u32 val;
+
+		ret = of_property_read_u32_index(np, "reg-fw-base", i, &val);
+		if (ret) {
+			vpu_dbg(LVL_ERR,
+				"find reg-fw-base for core[%d] fail\n", i);
+			return ret;
+		}
+		dev->core_dev[i].reg_fw_base = val;
+	}
+
 	return 0;
 }
 
@@ -2217,6 +2213,17 @@ static int vpu_probe(struct platform_device *pdev)
 	dev->generic_dev = get_device(&pdev->dev);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		vpu_dbg(LVL_ERR, "Missing platform resource data\n");
+		ret = -EINVAL;
+		goto error_put_dev;
+	}
+	dev->regs_enc = devm_ioremap_resource(dev->generic_dev, res);
+	if (!dev->regs_enc) {
+		vpu_dbg(LVL_ERR, "couldn't map encoder reg\n");
+		ret = PTR_ERR(dev->regs_enc);
+		goto error_put_dev;
+	}
 	dev->regs_base = ioremap(ENC_REG_BASE, 0x1000000);
 	if (!dev->regs_base) {
 		vpu_dbg(LVL_ERR, "%s could not map regs_base\n", __func__);
@@ -2365,7 +2372,6 @@ static int vpu_suspend(struct device *dev)
 static int vpu_resume(struct device *dev)
 {
 	struct vpu_dev *vpudev = (struct vpu_dev *)dev_get_drvdata(dev);
-	void *csr_offset, *csr_cpuwait;
 	struct core_device *core_dev;
 	u_int32 i;
 
@@ -2381,24 +2387,7 @@ static int vpu_resume(struct device *dev)
 			reset_vpu_core_dev(core_dev);
 		} else {
 			/*resume*/
-			if (vpudev->plat_type == IMX8QXP) {
-				csr_offset = ioremap(0x2d050000, 4);
-				writel(core_dev->m0_p_fw_space_phy, csr_offset);
-				csr_cpuwait = ioremap(0x2d050004, 4);
-				writel(0x0, csr_cpuwait);
-			} else {
-				if (i == 0) {
-					csr_offset = ioremap(0x2d090000, 4);
-					writel(core_dev->m0_p_fw_space_phy, csr_offset);
-					csr_cpuwait = ioremap(0x2d090004, 4);
-					writel(0x0, csr_cpuwait);
-				} else {
-					csr_offset = ioremap(0x2d0a0000, 4);
-					writel(core_dev->m0_p_fw_space_phy, csr_offset);
-					csr_cpuwait = ioremap(0x2d0a0004, 4);
-					writel(0x0, csr_cpuwait);
-				}
-			}
+			set_vpu_fw_addr(vpudev, core_dev);
 			/*wait for firmware resotre done*/
 			if (!wait_for_completion_timeout(&core_dev->start_cmp, msecs_to_jiffies(1000))) {
 				vpu_dbg(LVL_ERR, "error: wait for vpu encoder resume done timeout!\n");
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
index 598a2ab..891b09f4 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
@@ -211,6 +211,7 @@ struct core_device {
 	struct vpu_ctx *ctx[VPU_MAX_NUM_STREAMS];
 	struct shared_addr shared_mem;
 	u32 id;
+	off_t reg_fw_base;
 	struct device *generic_dev;
 };
 struct vpu_dev {
@@ -220,8 +221,8 @@ struct vpu_dev {
 	struct platform_device *plat_dev;
 	struct clk *clk_m0;
 	struct firmware *m0_pfw;
-	struct clk *vpu_clk;
 	void __iomem *regs_base;
+	void __iomem *regs_enc;
 	struct mutex dev_mutex;
 	struct core_device core_dev[2];
 	u_int32 plat_type;
-- 
1.7.9.5


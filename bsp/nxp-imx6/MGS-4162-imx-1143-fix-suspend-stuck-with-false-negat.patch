From be3135fdd99300b923ea1f0b578312160d5553e7 Mon Sep 17 00:00:00 2001
From: Xianzhong <xianzhong.li@nxp.com>
Date: Wed, 22 Aug 2018 17:23:15 +0800
Subject: [PATCH 4434/5242] MGS-4162 [#imx-1143] fix suspend stuck with false
 negative

commit  b25b36232fab9513d8daafe090e84a32b44fb3bd from
https://source.codeaurora.org/external/imx/linux-imx.git

While investigating MLK-18894 ran a large number of suspend iterations
on imx6qp-sdb with rc2 kernel. After ~6 hours it hung while suspending
devices and sysrq-T showed the following trace for rtcwake:

The gckHARDWARE_SetPowerManagementState function seems hung waiting for
gckHARDWARE_QueryIdle. Inside the gckHARDWARE_QueryIdle there is a check
which looks like this:
rtcwake         D    0  7090    561 0x00000001
[<809d5fc8>] (__schedule) from [<809d6380>] (schedule+0x48/0xb0)
[<809d6380>] (schedule) from [<809d9d3c>] (schedule_hrtimeout_range_clock+0xc8/0x13c)
[<809d9d3c>] (schedule_hrtimeout_range_clock) from [<809d9df0>] (schedule_hrtimeout+0x20/0x28)
[<809d9df0>] (schedule_hrtimeout) from [<807168c4>] (gckOS_Delay.part.3+0x64/0x6c)
[<807168c4>] (gckOS_Delay.part.3) from [<8071813c>] (gckOS_Delay+0x18/0x20)
[<8071813c>] (gckOS_Delay) from [<8073f08c>] (gckHARDWARE_SetPowerManagementState+0x838/0xb70)
[<8073f08c>] (gckHARDWARE_SetPowerManagementState) from [<8071df18>] (gpu_suspend+0x74/0xe4)
[<8071df18>] (gpu_suspend) from [<804fb9e8>] (dpm_run_callback+0x3c/0xdc)

/* Test if address is inside the last WAIT/LINK sequence. */
if ((address >= Hardware->lastWaitLink)
&& (address <= Hardware->lastWaitLink + 16)

Stepping through using the debugger (screenshot attached) this function
seems to return non-idle with both address lastWaitLink and being equal
to 0xFFFFFFF0. As far as I can tell the intention seems to be that the
check should pass but 0xFFFFFFF0 + 16 overflows back to zero so the
second part of the check fails because 0xFFFFFFF0 is not less than or
equal to 0.

Adding some prints to GPU code it seems that it's normal for these
values to be >0xFFFFe000. When they (randomly) hit 0xFFFFFFF0 exactly
the idle check will incorrectly fail and suspend will hang.

Actually, it is wrong when address reach to Hardware->lastWaitLink + 16,
because the address shall be either Hardware->lastWaitLink(wait command)
or Hardware->lastWaitLink + 8 (link command).

Fix the end address offset with 8 or 16 (extra 8 bytes for L2 flush).

Signed-off-by: Xianzhong <xianzhong.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../hal/kernel/arch/gc_hal_kernel_hardware.c       |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
index ec9de84de..32c58b9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
@@ -9178,7 +9178,7 @@
 
             /* Test if address is inside the last WAIT/LINK sequence. */
             if ((address >= Hardware->lastWaitLink)
-            &&  (address <= Hardware->lastWaitLink + 16)
+            &&  (address <= Hardware->lastWaitLink + (Hardware->hasL2Cache ? 16 : 8))
             )
             {
                 /* FE is in last WAIT/LINK and the pipe is idle. */
-- 
1.7.9.5


From 1c3a54a08604f322c4b793ed9a55d3cacb6e4d6c Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Thu, 27 Jul 2017 21:47:51 +0800
Subject: [PATCH 2300/5242] MLK-16013-21 staging: typec: tcpm: handle pd
 message send failure

commit  d332e35efc7e96549866fc82b14c8a8e25eb9d05 from
https://source.codeaurora.org/external/imx/linux-imx.git

If the PD message send failed, we need to do soft reset, further if
soft reset failed, we have to start a hard reset.

Reviewed-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/typec/tcpm.c |   17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/drivers/usb/typec/tcpm.c b/drivers/usb/typec/tcpm.c
index 917744d..8854455 100644
--- a/drivers/usb/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -1913,6 +1913,7 @@ static int tcpm_pd_send_control(struct tcpm_port *port,
 static bool tcpm_send_queued_message(struct tcpm_port *port)
 {
 	enum pd_msg_request queued_message;
+	int ret = 0;
 
 	do {
 		queued_message = port->queued_message;
@@ -1920,25 +1921,31 @@ static bool tcpm_send_queued_message(struct tcpm_port *port)
 
 		switch (queued_message) {
 		case PD_MSG_CTRL_WAIT:
-			tcpm_pd_send_control(port, PD_CTRL_WAIT);
+			ret = tcpm_pd_send_control(port, PD_CTRL_WAIT);
 			break;
 		case PD_MSG_CTRL_REJECT:
-			tcpm_pd_send_control(port, PD_CTRL_REJECT);
+			ret = tcpm_pd_send_control(port, PD_CTRL_REJECT);
 			break;
 		case PD_MSG_CTRL_NOT_SUPP:
-			tcpm_pd_send_control(port, PD_CTRL_NOT_SUPP);
+			ret = tcpm_pd_send_control(port, PD_CTRL_NOT_SUPP);
 			break;
 		case PD_MSG_DATA_SINK_CAP:
-			tcpm_pd_send_sink_caps(port);
+			ret = tcpm_pd_send_sink_caps(port);
 			break;
 		case PD_MSG_DATA_SOURCE_CAP:
-			tcpm_pd_send_source_caps(port);
+			ret = tcpm_pd_send_source_caps(port);
 			break;
 		default:
 			break;
 		}
 	} while (port->queued_message != PD_MSG_NONE);
 
+	if (ret) {
+		tcpm_set_state(port, SOFT_RESET_SEND, 0);
+		tcpm_log(port, "TCPM sending message failure!");
+		return false;
+	}
+
 	if (port->delayed_state != INVALID_STATE) {
 		if (time_is_after_jiffies(port->delayed_runtime)) {
 			mod_delayed_work(port->wq, &port->state_machine,
-- 
1.7.9.5


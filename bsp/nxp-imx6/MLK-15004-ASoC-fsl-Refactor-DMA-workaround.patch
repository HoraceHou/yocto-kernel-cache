From db8bcaebfa4eafefa9c80c326ae4a26b36f15341 Mon Sep 17 00:00:00 2001
From: Daniel Baluta <daniel.baluta@nxp.com>
Date: Tue, 11 Jul 2017 16:06:58 +0300
Subject: [PATCH 2114/5242] MLK-15004: ASoC: fsl: Refactor DMA workaround

commit  4061b985fd8d4cdddf2a5c01989d07178a896adf from
https://source.codeaurora.org/external/imx/linux-imx.git

Commit 2f756e7aa8840 ("ASoC: fsl_esai: esai workaround for imx8qxp
Rev1") introduced a workaround for ESAI.

Because the same workaround needs to be done for SPDIF, we refactor
GPT handling in order to avoid code duplication.

Notice that we isolate code related to workaround into
fsl_dma_workaround so that only few lines of code from ESAI/SPDIF
are modified. Thus when the hardware issue will be fixed there will
be very little things to revert in our modules.

Reviewed-by: Shengjiu Wang <shengjiu.wang@nxp.com>
Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/Makefile             |    3 +-
 sound/soc/fsl/fsl_dma_workaround.c |  254 +++++++++++++++++++++++++++++++
 sound/soc/fsl/fsl_dma_workaround.h |  102 +++++++++++++
 sound/soc/fsl/fsl_esai.c           |  295 ++----------------------------------
 4 files changed, 371 insertions(+), 283 deletions(-)
 create mode 100644 sound/soc/fsl/fsl_dma_workaround.c
 create mode 100644 sound/soc/fsl/fsl_dma_workaround.h

diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index cbd90bf..cbfafa1 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -14,12 +14,13 @@ obj-$(CONFIG_SND_SOC_P1022_RDK) += snd-soc-p1022-rdk.o
 # Freescale SSI/DMA/SAI/SPDIF Support
 snd-soc-fsl-acm-objs := fsl_acm.o
 snd-soc-fsl-asrc-objs := fsl_asrc.o fsl_asrc_dma.o
+snd-soc-fsl-dma-workaround-objs := fsl_dma_workaround.o
 snd-soc-fsl-hifi4-objs := fsl_hifi4.o
 snd-soc-fsl-sai-objs := fsl_sai.o
 snd-soc-fsl-ssi-y := fsl_ssi.o
 snd-soc-fsl-ssi-$(CONFIG_DEBUG_FS) += fsl_ssi_dbg.o
 snd-soc-fsl-spdif-objs := fsl_spdif.o
-snd-soc-fsl-esai-objs := fsl_esai.o
+snd-soc-fsl-esai-objs := fsl_esai.o fsl_dma_workaround.o
 snd-soc-fsl-utils-objs := fsl_utils.o
 snd-soc-fsl-dma-objs := fsl_dma.o
 snd-soc-fsl-rpmsg-i2s-objs := fsl_rpmsg_i2s.o
diff --git a/sound/soc/fsl/fsl_dma_workaround.c b/sound/soc/fsl/fsl_dma_workaround.c
new file mode 100644
index 0000000..22ccef7
--- /dev/null
+++ b/sound/soc/fsl/fsl_dma_workaround.c
@@ -0,0 +1,254 @@
+/*
+ * fsl_dma_workaround.c - DMA workaround bits
+ *
+ * Copyright (C) 2017 NXP
+ *
+ * Author: Daniel Baluta <daniel.baluta@nxp.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#include <linux/slab.h>
+#include "fsl_acm.h"
+#include "fsl_dma_workaround.h"
+
+int gpt_events[2][2] = {
+	{ESAI0_IPD_ESAI_TX_B, ESAI0_IPD_ESAI_RX_B},
+	{SPDIF0_DRQ1_SPDIF_B, SPDIF0_DRQ0_SPDIF_B},
+};
+
+/*
+ * configure_gpt_dma - configures GPT DMA for a given audio interface
+ * @substream:	PCM substream
+ * @info: DMA workaround specific info
+ *
+ */
+int configure_gpt_dma(struct snd_pcm_substream *substream,
+		      struct fsl_dma_workaround_info *info)
+{
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+	if (tx) {
+		writel_relaxed(gpt_events[info->iface][0],
+			       info->base_acm + GPT0_CAPIN1_SEL_OFF);
+		writel_relaxed(gpt_events[info->iface][0],
+			       info->base_acm + GPT1_CAPIN1_SEL_OFF);
+
+		writel(le32_to_cpu(info->tcd_sw[0].vtcd->saddr),
+				info->base_edma_gpt1 + EDMA_TCD_SADDR);
+		writel(le32_to_cpu(info->tcd_sw[0].vtcd->daddr),
+				info->base_edma_gpt1 + EDMA_TCD_DADDR);
+		writew(le16_to_cpu(info->tcd_sw[0].vtcd->attr),
+				info->base_edma_gpt1 + EDMA_TCD_ATTR);
+		writew(le16_to_cpu(info->tcd_sw[0].vtcd->soff),
+				info->base_edma_gpt1 + EDMA_TCD_SOFF);
+		writel(le32_to_cpu(info->tcd_sw[0].vtcd->nbytes),
+				info->base_edma_gpt1 + EDMA_TCD_NBYTES);
+		writel(le32_to_cpu(info->tcd_sw[0].vtcd->slast),
+				info->base_edma_gpt1 + EDMA_TCD_SLAST);
+		writew(le16_to_cpu(info->tcd_sw[0].vtcd->citer),
+				info->base_edma_gpt1 + EDMA_TCD_CITER);
+		writew(le16_to_cpu(info->tcd_sw[0].vtcd->biter),
+				info->base_edma_gpt1 + EDMA_TCD_BITER);
+		writew(le16_to_cpu(info->tcd_sw[0].vtcd->doff),
+				info->base_edma_gpt1 + EDMA_TCD_DOFF);
+		writel(le32_to_cpu(info->tcd_sw[0].vtcd->dlast_sga),
+				info->base_edma_gpt1 + EDMA_TCD_DLAST_SGA);
+		writew(le16_to_cpu(info->tcd_sw[0].vtcd->csr),
+				info->base_edma_gpt1 + EDMA_TCD_CSR);
+
+		writel(0x0, info->base_edma_gpt1 + EDMA_CH_SBR);
+		writel(0x1, info->base_edma_gpt1 + EDMA_CH_CSR);
+
+		/* configure this gpt for dma tx */
+		writel_relaxed(0x8, info->base_gpt0 + GPT_IR);
+		writel_relaxed(0x7<<12, info->base_gpt0 + GPT_PR);
+		writel_relaxed(0x20441, info->base_gpt0 + GPT_CR);
+
+		/* configure this gpt for dma tx request clear */
+		writel_relaxed(0x8, info->base_gpt1 + GPT_IR);
+		writel_relaxed(0x7<<12, info->base_gpt1 + GPT_PR);
+		writel_relaxed(0x10441, info->base_gpt1 + GPT_CR);
+
+	} else {
+		writel_relaxed(gpt_events[info->iface][1],
+				info->base_acm + GPT2_CAPIN1_SEL_OFF);
+		writel_relaxed(gpt_events[info->iface][1],
+				info->base_acm + GPT3_CAPIN1_SEL_OFF);
+
+		writel(le32_to_cpu(info->tcd_sw[2].vtcd->saddr),
+				info->base_edma_gpt3 + EDMA_TCD_SADDR);
+		writel(le32_to_cpu(info->tcd_sw[2].vtcd->daddr),
+				info->base_edma_gpt3 + EDMA_TCD_DADDR);
+		writew(le16_to_cpu(info->tcd_sw[2].vtcd->attr),
+				info->base_edma_gpt3 + EDMA_TCD_ATTR);
+		writew(le16_to_cpu(info->tcd_sw[2].vtcd->soff),
+				info->base_edma_gpt3 + EDMA_TCD_SOFF);
+		writel(le32_to_cpu(info->tcd_sw[2].vtcd->nbytes),
+				info->base_edma_gpt3 + EDMA_TCD_NBYTES);
+		writel(le32_to_cpu(info->tcd_sw[2].vtcd->slast),
+				info->base_edma_gpt3 + EDMA_TCD_SLAST);
+		writew(le16_to_cpu(info->tcd_sw[2].vtcd->citer),
+				info->base_edma_gpt3 + EDMA_TCD_CITER);
+		writew(le16_to_cpu(info->tcd_sw[2].vtcd->biter),
+				info->base_edma_gpt3 + EDMA_TCD_BITER);
+		writew(le16_to_cpu(info->tcd_sw[2].vtcd->doff),
+				info->base_edma_gpt3 + EDMA_TCD_DOFF);
+		writel(le32_to_cpu(info->tcd_sw[2].vtcd->dlast_sga),
+				info->base_edma_gpt3 + EDMA_TCD_DLAST_SGA);
+		writew(le16_to_cpu(info->tcd_sw[2].vtcd->csr),
+				info->base_edma_gpt3 + EDMA_TCD_CSR);
+
+		writel(0x0, info->base_edma_gpt3 + EDMA_CH_SBR);
+		writel(0x1, info->base_edma_gpt3 + EDMA_CH_CSR);
+
+		/* configure this gpt for dma rx */
+		writel_relaxed(0x8, info->base_gpt2 + GPT_IR);
+		writel_relaxed(0x7<<12, info->base_gpt2 + GPT_PR);
+		writel_relaxed(0x20441, info->base_gpt2 + GPT_CR);
+
+		/* configure this gpt for dma rx request clear*/
+		writel_relaxed(0x8, info->base_gpt3 + GPT_IR);
+		writel_relaxed(0x7<<12, info->base_gpt3 + GPT_PR);
+		writel_relaxed(0x10441, info->base_gpt3 + GPT_CR);
+
+	}
+
+	return 0;
+}
+
+
+int clear_gpt_dma(struct snd_pcm_substream *substream,
+			 struct fsl_dma_workaround_info *info)
+{
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	u32 val;
+
+	if (tx) {
+		val = readl(info->base_edma_gpt1 + EDMA_CH_CSR);
+		val &= ~0x1;
+		writel(val, info->base_edma_gpt1 + EDMA_CH_CSR);
+
+		/* disable gpt */
+		writel_relaxed(0, info->base_gpt0 + GPT_IR);
+		writel_relaxed(0, info->base_gpt0 + GPT_PR);
+		writel_relaxed(0, info->base_gpt0 + GPT_CR);
+
+		writel_relaxed(0, info->base_gpt1 + GPT_IR);
+		writel_relaxed(0, info->base_gpt1 + GPT_PR);
+		writel_relaxed(0, info->base_gpt1 + GPT_CR);
+
+	} else {
+		val = readl(info->base_edma_gpt3 + EDMA_CH_CSR);
+		val &= ~0x1;
+		writel(val, info->base_edma_gpt3 + EDMA_CH_CSR);
+
+		/* disable gpt */
+		writel_relaxed(0, info->base_gpt2 + GPT_IR);
+		writel_relaxed(0, info->base_gpt2 + GPT_PR);
+		writel_relaxed(0, info->base_gpt2 + GPT_CR);
+
+		writel_relaxed(0, info->base_gpt3 + GPT_IR);
+		writel_relaxed(0, info->base_gpt3 + GPT_PR);
+		writel_relaxed(0, info->base_gpt3 + GPT_CR);
+	}
+
+	return 0;
+}
+
+struct fsl_dma_workaround_info *
+fsl_dma_workaround_alloc_info(const char *pool_name, struct device *dma_dev,
+			      const char *base_acm_compat, int iface)
+{
+	struct fsl_dma_workaround_info *info;
+	int *buffer;
+	int i;
+
+	info = devm_kzalloc(dma_dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return ERR_PTR(-ENOMEM);
+
+	info->tcd_pool = dma_pool_create(pool_name, dma_dev,
+					 sizeof(struct fsl_edma3_hw_tcd),
+					 32, 0);
+
+	info->buf.area = dma_alloc_writecombine(dma_dev, 0x1000,
+						&info->buf.addr, GFP_KERNEL);
+
+	buffer = (int *)info->buf.area;
+	buffer[0] = 0x8;
+
+	info->tcd_sw[0].vtcd = dma_pool_alloc(info->tcd_pool,
+			GFP_ATOMIC, &info->tcd_sw[0].ptcd);
+	info->tcd_sw[1].vtcd = dma_pool_alloc(info->tcd_pool,
+			GFP_ATOMIC, &info->tcd_sw[1].ptcd);
+	info->tcd_sw[2].vtcd = dma_pool_alloc(info->tcd_pool,
+			GFP_ATOMIC, &info->tcd_sw[2].ptcd);
+	info->tcd_sw[3].vtcd = dma_pool_alloc(info->tcd_pool,
+			GFP_ATOMIC, &info->tcd_sw[3].ptcd);
+
+	for (i = 0; i < 4; i++) {
+		info->tcd_sw[i].vtcd->saddr = info->buf.addr;
+		info->tcd_sw[i].vtcd->attr  = 0x0202;
+		info->tcd_sw[i].vtcd->soff  = 0x0;
+		info->tcd_sw[i].vtcd->nbytes = 0x4;
+		info->tcd_sw[i].vtcd->slast     = 0x0;
+		info->tcd_sw[i].vtcd->citer     = 0x1;
+		info->tcd_sw[i].vtcd->biter     = 0x1;
+		info->tcd_sw[i].vtcd->doff      = 0x0;
+		info->tcd_sw[i].vtcd->csr       = 0x10;
+	}
+
+	info->tcd_sw[0].vtcd->daddr = GPT5_ADDR + GPT_SR;
+	info->tcd_sw[1].vtcd->daddr = GPT6_ADDR + GPT_SR;
+	info->tcd_sw[2].vtcd->daddr = GPT7_ADDR + GPT_SR;
+	info->tcd_sw[3].vtcd->daddr = GPT8_ADDR + GPT_SR;
+
+	info->tcd_sw[0].vtcd->dlast_sga =
+				info->tcd_sw[1].ptcd;
+	info->tcd_sw[1].vtcd->dlast_sga =
+				info->tcd_sw[0].ptcd;
+	info->tcd_sw[2].vtcd->dlast_sga =
+				info->tcd_sw[3].ptcd;
+	info->tcd_sw[3].vtcd->dlast_sga =
+				info->tcd_sw[2].ptcd;
+
+	info->base_gpt0 = ioremap(GPT5_ADDR, SZ_64K);
+	info->base_gpt1 = ioremap(GPT6_ADDR, SZ_64K);
+	info->base_gpt2 = ioremap(GPT7_ADDR, SZ_64K);
+	info->base_gpt3 = ioremap(GPT8_ADDR, SZ_64K);
+
+	info->base_edma_gpt1 = ioremap(EDMA_GPT6_ADDR, SZ_64K);
+	info->base_edma_gpt3 = ioremap(EDMA_GPT8_ADDR, SZ_64K);
+
+	info->base_acm = of_iomap(of_find_compatible_node(
+				NULL, NULL, base_acm_compat), 0);
+
+	info->iface = iface;
+	return info;
+}
+
+void fsl_dma_workaround_free_info(struct fsl_dma_workaround_info *info,
+				  struct device *dma_dev)
+{
+	dma_free_writecombine(dma_dev,
+			      0x1000,
+			      info->buf.area,
+			      info->buf.addr);
+
+	dma_pool_free(info->tcd_pool,
+		      info->tcd_sw[0].vtcd,
+		      info->tcd_sw[0].ptcd);
+	dma_pool_free(info->tcd_pool,
+		      info->tcd_sw[1].vtcd,
+		      info->tcd_sw[1].ptcd);
+	dma_pool_free(info->tcd_pool,
+		      info->tcd_sw[2].vtcd,
+		      info->tcd_sw[2].ptcd);
+	dma_pool_free(info->tcd_pool,
+		      info->tcd_sw[3].vtcd,
+		      info->tcd_sw[3].ptcd);
+
+	dma_pool_destroy(info->tcd_pool);
+}
diff --git a/sound/soc/fsl/fsl_dma_workaround.h b/sound/soc/fsl/fsl_dma_workaround.h
new file mode 100644
index 0000000..0602817
--- /dev/null
+++ b/sound/soc/fsl/fsl_dma_workaround.h
@@ -0,0 +1,102 @@
+/*
+ * fsl_dma_workaround.h - EDMA bits useful for DMA workaround
+ *
+ * Copyright (C) 2017 NXP
+ *
+ * Author: Daniel Baluta <daniel.baluta@nxp.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef _FSL_DMA_WORKAROUND_H
+#define _FSL_DMA_WORKAROUND_H
+
+#include <sound/pcm.h>
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#define EDMA_CH_CSR			0x00
+#define EDMA_CH_ES			0x04
+#define EDMA_CH_INT			0x08
+#define EDMA_CH_SBR			0x0C
+#define EDMA_CH_PRI			0x10
+#define EDMA_TCD_SADDR			0x20
+#define EDMA_TCD_SOFF			0x24
+#define EDMA_TCD_ATTR			0x26
+#define EDMA_TCD_NBYTES			0x28
+#define EDMA_TCD_SLAST			0x2C
+#define EDMA_TCD_DADDR			0x30
+#define EDMA_TCD_DOFF			0x34
+#define EDMA_TCD_CITER_ELINK		0x36
+#define EDMA_TCD_CITER			0x36
+#define EDMA_TCD_DLAST_SGA		0x38
+#define EDMA_TCD_CSR			0x3C
+#define EDMA_TCD_BITER_ELINK		0x3E
+#define EDMA_TCD_BITER			0x3E
+
+#define GPT_CR				0x00
+#define GPT_PR				0x04
+#define GPT_SR				0x08
+#define GPT_IR				0x0C
+
+#define GPT5_ADDR			0x590b0000
+#define GPT6_ADDR			0x590c0000
+#define GPT7_ADDR			0x590d0000
+#define GPT8_ADDR			0x590e0000
+
+#define EDMA_GPT6_ADDR			0x59360000
+#define EDMA_GPT8_ADDR			0x59380000
+
+#define FSL_DMA_WORKAROUND_ESAI		0
+#define FSL_DMA_WORKAROUND_SPDIF	1
+
+struct fsl_edma3_hw_tcd {
+	__le32	saddr;
+	__le16	soff;
+	__le16	attr;
+	__le32	nbytes;
+	__le32	slast;
+	__le32	daddr;
+	__le16	doff;
+	__le16	citer;
+	__le32	dlast_sga;
+	__le16	csr;
+	__le16	biter;
+};
+
+struct fsl_edma3_sw_tcd {
+	dma_addr_t			ptcd;
+	struct fsl_edma3_hw_tcd		*vtcd;
+};
+
+struct fsl_dma_workaround_info {
+	struct fsl_edma3_sw_tcd	tcd_sw[4];
+	struct dma_pool	*tcd_pool;
+	struct snd_dma_buffer buf;
+	void __iomem *base_gpt0;
+	void __iomem *base_gpt1;
+	void __iomem *base_gpt2;
+	void __iomem *base_gpt3;
+	void __iomem *base_edma_gpt1;
+	void __iomem *base_edma_gpt3;
+	void __iomem *base_acm;
+	int iface;
+};
+
+int configure_gpt_dma(struct snd_pcm_substream *substream,
+		      struct fsl_dma_workaround_info *info);
+
+int clear_gpt_dma(struct snd_pcm_substream *substream,
+		  struct fsl_dma_workaround_info *info);
+
+struct fsl_dma_workaround_info *
+fsl_dma_workaround_alloc_info(const char *pool_name, struct device *dma_dev,
+			      const char *base_acm_compat, int iface);
+
+void fsl_dma_workaround_free_info(struct fsl_dma_workaround_info *info,
+				  struct device *dma_dev);
+#endif /* _FSL_EDMA_H */
diff --git a/sound/soc/fsl/fsl_esai.c b/sound/soc/fsl/fsl_esai.c
index 9133eeb..925b05e 100644
--- a/sound/soc/fsl/fsl_esai.c
+++ b/sound/soc/fsl/fsl_esai.c
@@ -20,63 +20,13 @@
 #include "fsl_esai.h"
 #include "fsl_acm.h"
 #include "imx-pcm.h"
+#include "fsl_dma_workaround.h"
 
 #define FSL_ESAI_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
 				SNDRV_PCM_FMTBIT_S16_LE | \
 				SNDRV_PCM_FMTBIT_S20_3LE | \
 				SNDRV_PCM_FMTBIT_S24_LE)
 
-#define EDMA_CH_CSR			0x00
-#define EDMA_CH_ES			0x04
-#define EDMA_CH_INT			0x08
-#define EDMA_CH_SBR			0x0C
-#define EDMA_CH_PRI			0x10
-#define EDMA_TCD_SADDR			0x20
-#define EDMA_TCD_SOFF			0x24
-#define EDMA_TCD_ATTR			0x26
-#define EDMA_TCD_NBYTES			0x28
-#define EDMA_TCD_SLAST			0x2C
-#define EDMA_TCD_DADDR			0x30
-#define EDMA_TCD_DOFF			0x34
-#define EDMA_TCD_CITER_ELINK		0x36
-#define EDMA_TCD_CITER			0x36
-#define EDMA_TCD_DLAST_SGA		0x38
-#define EDMA_TCD_CSR			0x3C
-#define EDMA_TCD_BITER_ELINK		0x3E
-#define EDMA_TCD_BITER			0x3E
-
-#define GPT_CR				0x00
-#define GPT_PR				0x04
-#define GPT_SR				0x08
-#define GPT_IR				0x0C
-
-#define GPT5_ADDR			0x590b0000
-#define GPT6_ADDR			0x590c0000
-#define GPT7_ADDR			0x590d0000
-#define GPT8_ADDR			0x590e0000
-
-#define EDMA_GPT6_ADDR			0x59360000
-#define EDMA_GPT8_ADDR			0x59380000
-
-struct fsl_edma3_hw_tcd {
-	__le32	saddr;
-	__le16	soff;
-	__le16	attr;
-	__le32	nbytes;
-	__le32	slast;
-	__le32	daddr;
-	__le16	doff;
-	__le16	citer;
-	__le32	dlast_sga;
-	__le16	csr;
-	__le16	biter;
-};
-
-struct fsl_edma3_sw_tcd {
-	dma_addr_t			ptcd;
-	struct fsl_edma3_hw_tcd		*vtcd;
-};
-
 struct fsl_esai_soc_data {
 	bool imx;
 	bool dma_workaround;
@@ -116,17 +66,8 @@ struct fsl_esai {
 	struct clk *extalclk;
 	struct clk *fsysclk;
 	struct clk *spbaclk;
-	struct fsl_edma3_sw_tcd	tcd_sw[4];
-	struct dma_pool	*tcd_pool;
-	struct snd_dma_buffer buf;
 	const struct fsl_esai_soc_data *soc;
-	void __iomem *base_gpt0;
-	void __iomem *base_gpt1;
-	void __iomem *base_gpt2;
-	void __iomem *base_gpt3;
-	void __iomem *base_edma_gpt1;
-	void __iomem *base_edma_gpt3;
-	void __iomem *base_acm;
+	struct fsl_dma_workaround_info *dma_info;
 	u32 fifo_depth;
 	u32 slot_width;
 	u32 slots;
@@ -669,142 +610,6 @@ static int fsl_esai_startup(struct snd_pcm_substream *substream,
 	return ret;
 }
 
-static int configure_gpt_dma(struct snd_pcm_substream *substream,
-			      struct snd_soc_dai *dai)
-{
-	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	struct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);
-
-	if (tx) {
-		writel_relaxed(ESAI0_IPD_ESAI_TX_B,
-				esai_priv->base_acm + GPT0_CAPIN1_SEL_OFF);
-		writel_relaxed(ESAI0_IPD_ESAI_TX_B,
-				esai_priv->base_acm + GPT1_CAPIN1_SEL_OFF);
-
-		writel(le32_to_cpu(esai_priv->tcd_sw[0].vtcd->saddr),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_SADDR);
-		writel(le32_to_cpu(esai_priv->tcd_sw[0].vtcd->daddr),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_DADDR);
-		writew(le16_to_cpu(esai_priv->tcd_sw[0].vtcd->attr),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_ATTR);
-		writew(le16_to_cpu(esai_priv->tcd_sw[0].vtcd->soff),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_SOFF);
-		writel(le32_to_cpu(esai_priv->tcd_sw[0].vtcd->nbytes),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_NBYTES);
-		writel(le32_to_cpu(esai_priv->tcd_sw[0].vtcd->slast),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_SLAST);
-		writew(le16_to_cpu(esai_priv->tcd_sw[0].vtcd->citer),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_CITER);
-		writew(le16_to_cpu(esai_priv->tcd_sw[0].vtcd->biter),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_BITER);
-		writew(le16_to_cpu(esai_priv->tcd_sw[0].vtcd->doff),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_DOFF);
-		writel(le32_to_cpu(esai_priv->tcd_sw[0].vtcd->dlast_sga),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_DLAST_SGA);
-		writew(le16_to_cpu(esai_priv->tcd_sw[0].vtcd->csr),
-				esai_priv->base_edma_gpt1 + EDMA_TCD_CSR);
-
-		writel(0x0, esai_priv->base_edma_gpt1 + EDMA_CH_SBR);
-		writel(0x1, esai_priv->base_edma_gpt1 + EDMA_CH_CSR);
-
-		/* configure this gpt for dma tx*/
-		writel_relaxed(0x8, esai_priv->base_gpt0 + GPT_IR);
-		writel_relaxed(0x7<<12, esai_priv->base_gpt0 + GPT_PR);
-		writel_relaxed(0x20441, esai_priv->base_gpt0 + GPT_CR);
-
-		/* configure this gpt for dma tx request clearn*/
-		writel_relaxed(0x8, esai_priv->base_gpt1 + GPT_IR);
-		writel_relaxed(0x7<<12, esai_priv->base_gpt1 + GPT_PR);
-		writel_relaxed(0x10441, esai_priv->base_gpt1 + GPT_CR);
-
-	} else {
-		writel_relaxed(ESAI0_IPD_ESAI_RX_B,
-				esai_priv->base_acm + GPT2_CAPIN1_SEL_OFF);
-		writel_relaxed(ESAI0_IPD_ESAI_RX_B,
-				esai_priv->base_acm + GPT3_CAPIN1_SEL_OFF);
-
-		writel(le32_to_cpu(esai_priv->tcd_sw[2].vtcd->saddr),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_SADDR);
-		writel(le32_to_cpu(esai_priv->tcd_sw[2].vtcd->daddr),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_DADDR);
-		writew(le16_to_cpu(esai_priv->tcd_sw[2].vtcd->attr),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_ATTR);
-		writew(le16_to_cpu(esai_priv->tcd_sw[2].vtcd->soff),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_SOFF);
-		writel(le32_to_cpu(esai_priv->tcd_sw[2].vtcd->nbytes),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_NBYTES);
-		writel(le32_to_cpu(esai_priv->tcd_sw[2].vtcd->slast),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_SLAST);
-		writew(le16_to_cpu(esai_priv->tcd_sw[2].vtcd->citer),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_CITER);
-		writew(le16_to_cpu(esai_priv->tcd_sw[2].vtcd->biter),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_BITER);
-		writew(le16_to_cpu(esai_priv->tcd_sw[2].vtcd->doff),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_DOFF);
-		writel(le32_to_cpu(esai_priv->tcd_sw[2].vtcd->dlast_sga),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_DLAST_SGA);
-		writew(le16_to_cpu(esai_priv->tcd_sw[2].vtcd->csr),
-				esai_priv->base_edma_gpt3 + EDMA_TCD_CSR);
-
-		writel(0x0, esai_priv->base_edma_gpt3 + EDMA_CH_SBR);
-		writel(0x1, esai_priv->base_edma_gpt3 + EDMA_CH_CSR);
-
-		/* configure this gpt for dma tx*/
-		writel_relaxed(0x8, esai_priv->base_gpt2 + GPT_IR);
-		writel_relaxed(0x7<<12, esai_priv->base_gpt2 + GPT_PR);
-		writel_relaxed(0x20441, esai_priv->base_gpt2 + GPT_CR);
-
-		/* configure this gpt for dma tx request clearn*/
-		writel_relaxed(0x8, esai_priv->base_gpt3 + GPT_IR);
-		writel_relaxed(0x7<<12, esai_priv->base_gpt3 + GPT_PR);
-		writel_relaxed(0x10441, esai_priv->base_gpt3 + GPT_CR);
-
-	}
-
-	return 0;
-}
-
-
-static int clear_gpt_dma(struct snd_pcm_substream *substream,
-			      struct snd_soc_dai *dai)
-{
-	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	struct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);
-	u32 val;
-
-	if (tx) {
-		val = readl(esai_priv->base_edma_gpt1 + EDMA_CH_CSR);
-		val &= ~0x1;
-		writel(val, esai_priv->base_edma_gpt1 + EDMA_CH_CSR);
-
-		/* disable gpt */
-		writel_relaxed(0, esai_priv->base_gpt0 + GPT_IR);
-		writel_relaxed(0, esai_priv->base_gpt0 + GPT_PR);
-		writel_relaxed(0, esai_priv->base_gpt0 + GPT_CR);
-
-		writel_relaxed(0, esai_priv->base_gpt1 + GPT_IR);
-		writel_relaxed(0, esai_priv->base_gpt1 + GPT_PR);
-		writel_relaxed(0, esai_priv->base_gpt1 + GPT_CR);
-
-	} else {
-		val = readl(esai_priv->base_edma_gpt3 + EDMA_CH_CSR);
-		val &= ~0x1;
-		writel(val, esai_priv->base_edma_gpt3 + EDMA_CH_CSR);
-
-		/* disable gpt */
-		writel_relaxed(0, esai_priv->base_gpt2 + GPT_IR);
-		writel_relaxed(0, esai_priv->base_gpt2 + GPT_PR);
-		writel_relaxed(0, esai_priv->base_gpt2 + GPT_CR);
-
-		writel_relaxed(0, esai_priv->base_gpt3 + GPT_IR);
-		writel_relaxed(0, esai_priv->base_gpt3 + GPT_PR);
-		writel_relaxed(0, esai_priv->base_gpt3 + GPT_CR);
-	}
-
-	return 0;
-}
-
-
 static int fsl_esai_hw_params(struct snd_pcm_substream *substream,
 			      struct snd_pcm_hw_params *params,
 			      struct snd_soc_dai *dai)
@@ -819,7 +624,7 @@ static int fsl_esai_hw_params(struct snd_pcm_substream *substream,
 	int ret;
 
 	if (esai_priv->soc->dma_workaround)
-		configure_gpt_dma(substream,  dai);
+		configure_gpt_dma(substream, esai_priv->dma_info);
 
 	/* Override slot_width if being specifically set */
 	if (esai_priv->slot_width)
@@ -946,7 +751,7 @@ static int fsl_esai_hw_free(struct snd_pcm_substream *substream,
 	struct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(cpu_dai);
 
 	if (esai_priv->soc->dma_workaround)
-		clear_gpt_dma(substream,  cpu_dai);
+		clear_gpt_dma(substream,  esai_priv->dma_info);
 
 	return 0;
 }
@@ -1213,8 +1018,6 @@ static int fsl_esai_probe(struct platform_device *pdev)
 	int irq, ret;
 	u32 buffer_size;
 	unsigned long irqflag = 0;
-	int *buffer;
-	int i;
 
 	esai_priv = devm_kzalloc(&pdev->dev, sizeof(*esai_priv), GFP_KERNEL);
 	if (!esai_priv)
@@ -1357,66 +1160,13 @@ static int fsl_esai_probe(struct platform_device *pdev)
 	if (of_property_read_u32(np, "fsl,dma-buffer-size", &buffer_size))
 		buffer_size = IMX_ESAI_DMABUF_SIZE;
 
-	/*workaround for esai issue in imx8qxp*/
-	if (esai_priv->soc->dma_workaround) {
-		esai_priv->tcd_pool = dma_pool_create("tcd_pool_esai",
-					&esai_priv->pdev->dev,
-				sizeof(struct fsl_edma3_hw_tcd), 32, 0);
-
-		esai_priv->buf.area = dma_alloc_writecombine(
-					&esai_priv->pdev->dev,
-					0x1000,
-					&esai_priv->buf.addr, GFP_KERNEL);
-
-		buffer = (int *)esai_priv->buf.area;
-		buffer[0] = 0x8;
-
-		esai_priv->tcd_sw[0].vtcd = dma_pool_alloc(esai_priv->tcd_pool,
-				GFP_ATOMIC, &esai_priv->tcd_sw[0].ptcd);
-		esai_priv->tcd_sw[1].vtcd = dma_pool_alloc(esai_priv->tcd_pool,
-				GFP_ATOMIC, &esai_priv->tcd_sw[1].ptcd);
-		esai_priv->tcd_sw[2].vtcd = dma_pool_alloc(esai_priv->tcd_pool,
-				GFP_ATOMIC, &esai_priv->tcd_sw[2].ptcd);
-		esai_priv->tcd_sw[3].vtcd = dma_pool_alloc(esai_priv->tcd_pool,
-				GFP_ATOMIC, &esai_priv->tcd_sw[3].ptcd);
-
-		for (i = 0; i < 4; i++) {
-			esai_priv->tcd_sw[i].vtcd->saddr = esai_priv->buf.addr;
-			esai_priv->tcd_sw[i].vtcd->attr  = 0x0202;
-			esai_priv->tcd_sw[i].vtcd->soff  = 0x0;
-			esai_priv->tcd_sw[i].vtcd->nbytes = 0x4;
-			esai_priv->tcd_sw[i].vtcd->slast     = 0x0;
-			esai_priv->tcd_sw[i].vtcd->citer     = 0x1;
-			esai_priv->tcd_sw[i].vtcd->biter     = 0x1;
-			esai_priv->tcd_sw[i].vtcd->doff      = 0x0;
-			esai_priv->tcd_sw[i].vtcd->csr       = 0x10;
-		}
-
-		esai_priv->tcd_sw[0].vtcd->daddr = GPT5_ADDR + GPT_SR;
-		esai_priv->tcd_sw[1].vtcd->daddr = GPT6_ADDR + GPT_SR;
-		esai_priv->tcd_sw[2].vtcd->daddr = GPT7_ADDR + GPT_SR;
-		esai_priv->tcd_sw[3].vtcd->daddr = GPT8_ADDR + GPT_SR;
-
-		esai_priv->tcd_sw[0].vtcd->dlast_sga =
-					esai_priv->tcd_sw[1].ptcd;
-		esai_priv->tcd_sw[1].vtcd->dlast_sga =
-					esai_priv->tcd_sw[0].ptcd;
-		esai_priv->tcd_sw[2].vtcd->dlast_sga =
-					esai_priv->tcd_sw[3].ptcd;
-		esai_priv->tcd_sw[3].vtcd->dlast_sga =
-					esai_priv->tcd_sw[2].ptcd;
-
-		esai_priv->base_gpt0 = ioremap(GPT5_ADDR, SZ_64K);
-		esai_priv->base_gpt1 = ioremap(GPT6_ADDR, SZ_64K);
-		esai_priv->base_gpt2 = ioremap(GPT7_ADDR, SZ_64K);
-		esai_priv->base_gpt3 = ioremap(GPT8_ADDR, SZ_64K);
-
-		esai_priv->base_edma_gpt1 = ioremap(EDMA_GPT6_ADDR, SZ_64K);
-		esai_priv->base_edma_gpt3 = ioremap(EDMA_GPT8_ADDR, SZ_64K);
-
-		esai_priv->base_acm = of_iomap(of_find_compatible_node(
-					NULL, NULL, "nxp,imx8qm-acm"), 0);
-	}
+	/* workaround for esai issue in imx8qxp */
+	if (esai_priv->soc->dma_workaround)
+		esai_priv->dma_info =
+			fsl_dma_workaround_alloc_info("tcd_pool_esai",
+						      &pdev->dev,
+						      "nxp,imx8qm-acm",
+						      FSL_DMA_WORKAROUND_ESAI);
 
 	ret = imx_pcm_platform_register(&pdev->dev);
 	if (ret)
@@ -1429,27 +1179,8 @@ static int fsl_esai_remove(struct platform_device *pdev)
 {
 	struct fsl_esai *esai_priv = dev_get_drvdata(&pdev->dev);
 
-	if (esai_priv->soc->dma_workaround) {
-		dma_free_writecombine(&esai_priv->pdev->dev,
-				0x1000,
-				esai_priv->buf.area,
-				esai_priv->buf.addr);
-
-		dma_pool_free(esai_priv->tcd_pool,
-				esai_priv->tcd_sw[0].vtcd,
-				esai_priv->tcd_sw[0].ptcd);
-		dma_pool_free(esai_priv->tcd_pool,
-				esai_priv->tcd_sw[1].vtcd,
-				esai_priv->tcd_sw[1].ptcd);
-		dma_pool_free(esai_priv->tcd_pool,
-				esai_priv->tcd_sw[2].vtcd,
-				esai_priv->tcd_sw[2].ptcd);
-		dma_pool_free(esai_priv->tcd_pool,
-				esai_priv->tcd_sw[3].vtcd,
-				esai_priv->tcd_sw[3].ptcd);
-
-		dma_pool_destroy(esai_priv->tcd_pool);
-	}
+	if (esai_priv->soc->dma_workaround)
+		fsl_dma_workaround_free_info(esai_priv->dma_info, &pdev->dev);
 
 	return 0;
 }
-- 
1.7.9.5


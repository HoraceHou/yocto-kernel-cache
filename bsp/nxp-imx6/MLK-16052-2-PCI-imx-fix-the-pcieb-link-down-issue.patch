From 868b9c26f47b12ce1501d545539ac3e71d33f0da Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Thu, 27 Jul 2017 15:58:27 +0800
Subject: [PATCH 2243/5242] MLK-16052-2 PCI: imx: fix the pcieb link down
 issue

commit  45ab6ee2a29bb881a51899aebe604a957104a57a from
https://source.codeaurora.org/external/imx/linux-imx.git

The calibration value of PCIEA is mandatory required
by PCIEB on iMX8QM.

The RSTs of the PCIEA would be cleared when the PDs
of PCIEA are turned off.
The calibration value of PCIEA would be lost when the
RSTs of PCIEA are cleared.
So, the RSTs of PCIEA should be asserted when enable
the PCIEB port. Otherwise, PCIEB wouldn't be functional.

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/controller/dwc/pci-imx6.c |   29 ++++++++++++++++-------------
 1 file changed, 16 insertions(+), 13 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index 7baf98e..205b6ac 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -406,6 +406,7 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 {
 	struct device *dev = imx6_pcie->pci->dev;
 	u32 val;
+	int i;
 
 	switch (imx6_pcie->variant) {
 	case IMX6SX:
@@ -435,19 +436,21 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 		regmap_update_bits(imx6_pcie->reg_src, 0x2c, BIT(2), BIT(2));
 		break;
 	case IMX8QM:
-		val = IMX8QM_CSR_PCIEA_OFFSET + imx6_pcie->ctrl_id * SZ_64K;
-		regmap_update_bits(imx6_pcie->iomuxc_gpr,
-				val + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
-				IMX8QM_CTRL_BUTTON_RST_N,
-				IMX8QM_CTRL_BUTTON_RST_N);
-		regmap_update_bits(imx6_pcie->iomuxc_gpr,
-				val + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
-				IMX8QM_CTRL_PERST_N,
-				IMX8QM_CTRL_PERST_N);
-		regmap_update_bits(imx6_pcie->iomuxc_gpr,
-				val + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
-				IMX8QM_CTRL_POWER_UP_RST_N,
-				IMX8QM_CTRL_POWER_UP_RST_N);
+		for (i = 0; i <= imx6_pcie->ctrl_id; i++) {
+			val = IMX8QM_CSR_PCIEA_OFFSET + i * SZ_64K;
+			regmap_update_bits(imx6_pcie->iomuxc_gpr,
+					val + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
+					IMX8QM_CTRL_BUTTON_RST_N,
+					IMX8QM_CTRL_BUTTON_RST_N);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr,
+					val + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
+					IMX8QM_CTRL_PERST_N,
+					IMX8QM_CTRL_PERST_N);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr,
+					val + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
+					IMX8QM_CTRL_POWER_UP_RST_N,
+					IMX8QM_CTRL_POWER_UP_RST_N);
+		}
 		break;
 	case IMX8MQ:
 		if (imx6_pcie->ctrl_id == 0)
-- 
1.7.9.5


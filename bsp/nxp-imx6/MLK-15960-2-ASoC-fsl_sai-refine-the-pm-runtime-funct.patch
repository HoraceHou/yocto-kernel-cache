From 13ffc8bc847223a47d8b81a28a1a9c9c0a6d083c Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@freescale.com>
Date: Wed, 12 Jul 2017 18:00:58 +0800
Subject: [PATCH 2122/5242] MLK-15960-2: ASoC: fsl_sai: refine the pm runtime
 function

commit  b207758848fce35f20944f198ac4398fd1d6efcc from
https://source.codeaurora.org/external/imx/linux-imx.git

In imx8qm/imx8qxp, the power domain of IP is enabled when
pm_runtime_get_sync() is called, and disabled when pm_runtime
_put_sync() is called. when power domain is disabled, the value
of registers will lost, so we need to use the regcache_sync()
to restore the registers in fsl_sai_runtime_resume.

Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_sai.c |   19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 08741d8..e3bd095 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -702,8 +702,6 @@ static int fsl_sai_startup(struct snd_pcm_substream *substream,
 	else
 		sai->is_stream_opened[tx] = true;
 
-	pm_runtime_get_sync(cpu_dai->dev);
-
 	ret = clk_prepare_enable(sai->bus_clk);
 	if (ret) {
 		dev_err(dev, "failed to enable bus clock: %d\n", ret);
@@ -739,7 +737,6 @@ static void fsl_sai_shutdown(struct snd_pcm_substream *substream,
 				   FSL_SAI_CR3_TRCE_MASK, 0);
 		clk_disable_unprepare(sai->bus_clk);
 		sai->is_stream_opened[tx] = false;
-		pm_runtime_put_sync(cpu_dai->dev);
 	}
 }
 
@@ -1104,6 +1101,8 @@ static int fsl_sai_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 
+	regcache_cache_only(sai->regmap, true);
+
 	ret = devm_snd_soc_register_component(&pdev->dev, &fsl_component,
 			&fsl_sai_dai, 1);
 	if (ret)
@@ -1122,19 +1121,31 @@ static int fsl_sai_probe(struct platform_device *pdev)
 static int fsl_sai_runtime_resume(struct device *dev)
 {
 	struct fsl_sai *sai = dev_get_drvdata(dev);
+	unsigned char offset = sai->soc->reg_offset;
 
 	request_bus_freq(BUS_FREQ_AUDIO);
 
 	if (sai->soc->flags & SAI_FLAG_PMQOS)
 		pm_qos_add_request(&sai->pm_qos_req,
 				PM_QOS_CPU_DMA_LATENCY, 0);
-	return 0;
+
+	regcache_cache_only(sai->regmap, false);
+	regcache_mark_dirty(sai->regmap);
+
+	regmap_write(sai->regmap, FSL_SAI_TCSR(offset), FSL_SAI_CSR_SR);
+	regmap_write(sai->regmap, FSL_SAI_RCSR(offset), FSL_SAI_CSR_SR);
+	usleep_range(1000, 2000);
+	regmap_write(sai->regmap, FSL_SAI_TCSR(offset), 0);
+	regmap_write(sai->regmap, FSL_SAI_RCSR(offset), 0);
+	return regcache_sync(sai->regmap);
 }
 
 static int fsl_sai_runtime_suspend(struct device *dev)
 {
 	struct fsl_sai *sai = dev_get_drvdata(dev);
 
+	regcache_cache_only(sai->regmap, true);
+
 	release_bus_freq(BUS_FREQ_AUDIO);
 
 	if (sai->soc->flags & SAI_FLAG_PMQOS)
-- 
1.7.9.5


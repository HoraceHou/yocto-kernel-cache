From 76237d84278a982ebe8ae957a45c8e90675f7642 Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Wed, 31 Oct 2018 14:09:48 +0800
Subject: [PATCH 4970/5242] MLK-20149 VPU: Adjust suspend and resume strategy
 for vpu decoder

commit  2495007f9e8ab0b4ec5996cbc2b713d1aa007f5f from
https://source.codeaurora.org/external/imx/linux-imx.git

Adjust suspend and resume strategy for vpu decoder to handle different
cases

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi      |    2 +-
 .../dts/freescale/fsl-imx8qm-mek-domu-dpu1.dts     |    2 +-
 .../boot/dts/freescale/fsl-imx8qm-mek-domu.dts     |    2 +-
 arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi      |    2 +-
 drivers/mxc/vpu-decoder-b0/vpu_b0.c                |   70 ++++++++++++++------
 5 files changed, 55 insertions(+), 23 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi
index 65ca3b1..8be64e05 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8dx.dtsi
@@ -183,7 +183,7 @@
 
 	mu_m0: mu_m0@2d000000 {
 		compatible = "fsl,imx8-mu0-vpu-m0";
-		reg = <0x0 0x2d000000 0x0 0x10000>;
+		reg = <0x0 0x2d000000 0x0 0x20000>;
 		interrupts = <GIC_SPI 469 IRQ_TYPE_LEVEL_HIGH>;
 		fsl,vpu_ap_mu_id = <16>;
 		status = "okay";
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu-dpu1.dts b/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu-dpu1.dts
index 438c04e..c58fb76 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu-dpu1.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu-dpu1.dts
@@ -197,7 +197,7 @@
 
 		mu_m0: mu_m0@2d000000 {
 			compatible = "fsl,imx8-mu0-vpu-m0";
-			reg = <0x0 0x2d000000 0x0 0x10000>;
+			reg = <0x0 0x2d000000 0x0 0x20000>;
 			interrupts = <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>;
 			fsl,vpu_ap_mu_id = <16>;
 			status = "okay";
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts b/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts
index 53ad2df..4865d7d 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8qm-mek-domu.dts
@@ -220,7 +220,7 @@
 
 		mu_m0: mu_m0@2d000000 {
 			compatible = "fsl,imx8-mu0-vpu-m0";
-			reg = <0x0 0x2d000000 0x0 0x10000>;
+			reg = <0x0 0x2d000000 0x0 0x20000>;
 			interrupts = <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>;
 			fsl,vpu_ap_mu_id = <16>;
 			status = "okay";
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi
index aff0102..27b9ff8 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8qm.dtsi
@@ -160,7 +160,7 @@
 
 	mu_m0: mu_m0@2d000000 {
 		compatible = "fsl,imx8-mu0-vpu-m0";
-		reg = <0x0 0x2d000000 0x0 0x10000>;
+		reg = <0x0 0x2d000000 0x0 0x20000>;
 		interrupts = <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>;
 		fsl,vpu_ap_mu_id = <16>;
 		status = "okay";
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index ce397af..9d39e36 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -3336,35 +3336,67 @@ static int vpu_suspend(struct device *dev)
 	return 0;
 }
 
-static int vpu_resume(struct device *dev)
+static bool is_vpu_poweroff(struct vpu_dev *vpudev)
 {
-	struct vpu_dev *vpudev = (struct vpu_dev *)dev_get_drvdata(dev);
-	int ret = 0;
+	void *mu_cr_addr;
+	u_int32 mu_cr;
 
-	pm_runtime_get_sync(vpudev->generic_dev);
+	if (!vpudev)
+		return false;
 
-	vpu_enable_hw(vpudev);
+	mu_cr_addr = vpudev->mu_base_virtaddr + 0x10000 + 0x24;
+	mu_cr = readl_relaxed(mu_cr_addr);
+
+	if (mu_cr == 0)// it mean M0+ is already power off/on
+		return true;
+	else
+		return false;
 
+}
+
+static int resume_vpu_register(struct vpu_dev *vpudev)
+{
+	if (!vpudev)
+		return -EINVAL;
+
+	vpu_enable_hw(vpudev);
 	MU_Init(vpudev->mu_base_virtaddr);
 	MU_EnableRxFullInt(vpudev->mu_base_virtaddr, 0);
 
-	if (vpudev->hang_mask == vpudev->instance_mask) {
-		/*no instance is active before suspend, do reset*/
-		vpudev->fw_is_ready = false;
-		vpudev->firmware_started = false;
+	return 0;
+}
 
-		rpc_init_shared_memory(&vpudev->shared_mem, vpudev->m0_rpc_phy - vpudev->m0_p_fw_space_phy, vpudev->m0_rpc_virt, SHARED_SIZE);
-		rpc_set_system_cfg_value(vpudev->shared_mem.pSharedInterface, VPU_REG_BASE);
-	} else {
-		/*resume*/
-		enable_csr_reg(vpudev);
-		/*wait for firmware resotre done*/
-		if (!wait_for_completion_timeout(&vpudev->start_cmp, msecs_to_jiffies(1000))) {
-			vpu_dbg(LVL_ERR, "error: wait for vpu decoder resume done timeout!\n");
-			ret = -1;
-		}
+static int resume_from_vpu_poweroff(struct vpu_dev *vpudev)
+{
+	int ret = 0;
+
+	enable_csr_reg(vpudev);
+	/*wait for firmware resotre done*/
+	if (!wait_for_completion_timeout(&vpudev->start_cmp, msecs_to_jiffies(1000))) {
+		vpu_dbg(LVL_ERR, "error: wait for vpu decoder resume done timeout!\n");
+		ret = -1;
 	}
 
+	return ret;
+}
+
+static int vpu_resume(struct device *dev)
+{
+	struct vpu_dev *vpudev = (struct vpu_dev *)dev_get_drvdata(dev);
+	int ret = 0;
+
+	pm_runtime_get_sync(vpudev->generic_dev);
+
+	resume_vpu_register(vpudev);
+
+	if (vpudev->fw_is_ready == false)
+		return 0;
+
+	if (is_vpu_poweroff(vpudev))
+		ret = resume_from_vpu_poweroff(vpudev);
+	else if (vpudev->hang_mask != vpudev->instance_mask)
+		swreset_vpu_firmware(vpudev);
+
 	pm_runtime_put_sync(vpudev->generic_dev);
 
 	return ret;
-- 
1.7.9.5


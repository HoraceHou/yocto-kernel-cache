From 87be22ea46a5215a491d4a05f25ea1e935dd24f9 Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Fri, 15 Jun 2018 11:37:59 +0800
Subject: [PATCH 4118/5242] MLK-17921-2 staging: typec: tcpm: add qos for PD
 transfer

commit  f6f814d5cbeaf5c31ee088538af1ae20c7b9e1b5 from
https://source.codeaurora.org/external/imx/linux-imx.git

TCPCI based typec port controller needs very strict low latency
on i2c transfer, this patch is to improve this by adding qos and
high bus handling in tcpm during PD session setup.

Acked-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/typec/tcpm.c |   35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/drivers/usb/typec/tcpm.c b/drivers/usb/typec/tcpm.c
index 7dac973..4401db5 100644
--- a/drivers/usb/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -29,6 +29,8 @@
 #include <linux/usb/tcpm.h>
 #include <linux/usb/typec.h>
 #include <linux/workqueue.h>
+#include <linux/busfreq-imx.h>
+#include <linux/pm_qos.h>
 
 #define FOREACH_STATE(S)			\
 	S(INVALID_STATE),			\
@@ -321,6 +323,7 @@ struct tcpm_port {
 
 	/* Send response timer */
 	struct hrtimer snd_res_timer;
+	struct pm_qos_request pm_qos_req;
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;
@@ -3515,6 +3518,33 @@ static void run_state_machine(struct tcpm_port *port)
 	}
 }
 
+static void tcpm_qos_active(struct tcpm_port *port, bool on)
+{
+	enum tcpm_state idle_state;
+
+	if (port->typec_caps.type == TYPEC_PORT_UFP)
+		idle_state = SNK_UNATTACHED;
+	else if (port->typec_caps.type == TYPEC_PORT_DFP)
+		idle_state = SNK_UNATTACHED;
+	else if (port->typec_caps.type == TYPEC_PORT_DRP)
+		idle_state = DRP_TOGGLING;
+	else
+		return;
+
+	if ((port->prev_state == SNK_READY || port->prev_state == SRC_READY ||
+	     port->prev_state == idle_state) && on) {
+		/* Hold high bus before leave those states */
+		request_bus_freq(BUS_FREQ_HIGH);
+		pm_qos_add_request(&port->pm_qos_req,
+				   PM_QOS_CPU_DMA_LATENCY, 0);
+	} else if ((port->state == SNK_READY || port->state == SRC_READY ||
+		    port->state == idle_state) && !on) {
+		/* Release high bus after enter those states */
+		pm_qos_remove_request(&port->pm_qos_req);
+		release_bus_freq(BUS_FREQ_HIGH);
+	}
+}
+
 static void tcpm_state_machine_work(struct work_struct *work)
 {
 	struct tcpm_port *port = container_of(work, struct tcpm_port,
@@ -3537,6 +3567,7 @@ static void tcpm_state_machine_work(struct work_struct *work)
 		port->delayed_state = INVALID_STATE;
 	}
 
+	tcpm_qos_active(port, true);
 	/*
 	 * Continue running as long as we have (non-delayed) state changes
 	 * to make.
@@ -3548,6 +3579,7 @@ static void tcpm_state_machine_work(struct work_struct *work)
 			tcpm_send_queued_message(port);
 	} while (port->state != prev_state && !port->delayed_state);
 
+	tcpm_qos_active(port, false);
 done:
 	port->state_machine_running = false;
 	mutex_unlock(&port->lock);
@@ -4305,6 +4337,9 @@ static void tcpm_init(struct tcpm_port *port)
 
 	tcpm_reset_port(port);
 
+	request_bus_freq(BUS_FREQ_HIGH);
+	pm_qos_add_request(&port->pm_qos_req, PM_QOS_CPU_DMA_LATENCY, 0);
+
 	tcpm_set_state(port, tcpm_default_state(port), 0);
 
 	_tcpm_cc_change(port, cc1, cc2);
-- 
1.7.9.5


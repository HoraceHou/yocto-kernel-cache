From cc0d47b205b4adaf2c6d2b2d70d4edc475d947fb Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Mon, 18 Sep 2017 10:27:29 +0800
Subject: [PATCH 4523/5242] MLK-19413-12 gpu: imx: dpu: framegen: Add helper
 framegen_syncmode() support

commit  a8b8606463c01603c27fca614649be5d5d989ae1 from
https://source.codeaurora.org/external/imx/linux-imx.git

This patch adds helper framegen_syncmode() support so that callers may
control the sync mode of a framegen.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/imx/dpu/dpu-framegen.c |   68 +++++++++++++++++++++++++++---------
 include/video/dpu.h                |   12 +++++++
 2 files changed, 63 insertions(+), 17 deletions(-)

diff --git a/drivers/gpu/imx/dpu/dpu-framegen.c b/drivers/gpu/imx/dpu/dpu-framegen.c
index 06c1d2f..581b155 100644
--- a/drivers/gpu/imx/dpu/dpu-framegen.c
+++ b/drivers/gpu/imx/dpu/dpu-framegen.c
@@ -25,16 +25,6 @@
 
 #define FGSTCTRL		0x8
 #define FGSYNCMODE_MASK		0x6
-typedef enum {
-	/* No side-by-side synchronization. */
-	FGSYNCMODE__OFF = 0,
-	/* Framegen is master. */
-	FGSYNCMODE__MASTER = 1 << 1,
-	/* Runs in cyclic synchronization mode. */
-	FGSYNCMODE__SLAVE_CYC = 2 << 1,
-	/* Runs in one time synchronization mode. */
-	FGSYNCMODE__SLAVE_ONCE = 3 << 1,
-} fgsyncmode_t;
 #define HTCFG1			0xC
 #define HTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
 #define HACT(n)			((n) & 0x3FFF)
@@ -228,6 +218,40 @@ static void dpu_pixel_link_set_mst_addr(int dpu_id, int stream_id, int mst_addr)
 	sc_ipc_close(mu_id);
 }
 
+/* FIXME: set dc sync mode for pixel link in a proper manner */
+static void dpu_pixel_link_set_dc_sync_mode(int dpu_id, bool enable)
+{
+	sc_err_t sciErr;
+	sc_ipc_t ipcHndl = 0;
+	u32 mu_id;
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("Cannot obtain MU ID\n");
+		return;
+	}
+
+	sciErr = sc_ipc_open(&ipcHndl, mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
+		return;
+	}
+
+	if (dpu_id == 0) {
+		sciErr = sc_misc_set_control(ipcHndl,
+						SC_R_DC_0, SC_C_MODE, enable);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_MODE sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+	} else if (dpu_id == 1) {
+		sciErr = sc_misc_set_control(ipcHndl,
+						SC_R_DC_1, SC_C_MODE, enable);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_MODE sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+	}
+
+	sc_ipc_close(mu_id);
+}
+
 void framegen_enable(struct dpu_framegen *fg)
 {
 	struct dpu_soc *dpu = fg->dpu;
@@ -264,6 +288,22 @@ void framegen_shdtokgen(struct dpu_framegen *fg)
 }
 EXPORT_SYMBOL_GPL(framegen_shdtokgen);
 
+void framegen_syncmode(struct dpu_framegen *fg, fgsyncmode_t mode)
+{
+	struct dpu_soc *dpu = fg->dpu;
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGSTCTRL);
+	val &= ~FGSYNCMODE_MASK;
+	val |= mode;
+	dpu_fg_write(fg, val, FGSTCTRL);
+	mutex_unlock(&fg->mutex);
+
+	dpu_pixel_link_set_dc_sync_mode(dpu->id, mode != FGSYNCMODE__OFF);
+}
+EXPORT_SYMBOL_GPL(framegen_syncmode);
+
 void
 framegen_cfg_videomode(struct dpu_framegen *fg, struct drm_display_mode *m,
 		       bool encoder_type_has_tmds, bool encoder_type_has_lvds)
@@ -560,7 +600,6 @@ struct dpu_framegen *dpu_aux_fg_peek(struct dpu_framegen *fg)
 void _dpu_fg_init(struct dpu_soc *dpu, unsigned int id)
 {
 	struct dpu_framegen *fg;
-	u32 val;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(fg_ids); i++)
@@ -572,12 +611,7 @@ void _dpu_fg_init(struct dpu_soc *dpu, unsigned int id)
 
 	fg = dpu->fg_priv[i];
 
-	mutex_lock(&fg->mutex);
-	val = dpu_fg_read(fg, FGSTCTRL);
-	val &= ~FGSYNCMODE_MASK;
-	val |= FGSYNCMODE__OFF;
-	dpu_fg_write(fg, val, FGSTCTRL);
-	mutex_unlock(&fg->mutex);
+	framegen_syncmode(fg, FGSYNCMODE__OFF);
 }
 
 int dpu_fg_init(struct dpu_soc *dpu, unsigned int id,
diff --git a/include/video/dpu.h b/include/video/dpu.h
index 307f496..edd66f3 100644
--- a/include/video/dpu.h
+++ b/include/video/dpu.h
@@ -278,6 +278,17 @@ enum dpu_irq {
 } fetchtype_t;
 
 typedef enum {
+	/* No side-by-side synchronization. */
+	FGSYNCMODE__OFF = 0,
+	/* Framegen is master. */
+	FGSYNCMODE__MASTER = 1 << 1,
+	/* Runs in cyclic synchronization mode. */
+	FGSYNCMODE__SLAVE_CYC = 2 << 1,
+	/* Runs in one time synchronization mode. */
+	FGSYNCMODE__SLAVE_ONCE = 3 << 1,
+} fgsyncmode_t;
+
+typedef enum {
 	FGDM__BLACK,
 	/* Constant Color Background is shown. */
 	FGDM__CONSTCOL,
@@ -594,6 +605,7 @@ void fetchwarp_rgb_constantcolor(struct dpu_fetchunit *fu,
 void framegen_enable(struct dpu_framegen *fg);
 void framegen_disable(struct dpu_framegen *fg);
 void framegen_shdtokgen(struct dpu_framegen *fg);
+void framegen_syncmode(struct dpu_framegen *fg, fgsyncmode_t mode);
 void
 framegen_cfg_videomode(struct dpu_framegen *fg, struct drm_display_mode *m,
 		       bool encoder_type_has_tmds, bool encoder_type_has_lvds);
-- 
1.7.9.5


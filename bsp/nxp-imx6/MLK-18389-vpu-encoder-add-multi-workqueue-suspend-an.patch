From 46faa513fef6841136de160a78c139376e603b70 Mon Sep 17 00:00:00 2001
From: GuoRui <rui.guo_4@nxp.com>
Date: Wed, 23 May 2018 15:33:52 +0800
Subject: [PATCH 3874/5242] MLK-18389:vpu encoder add multi-workqueue suspend
 and resume

commit  da32813359bcee8d6c53e7e287a9594ea8e99d2c from
https://source.codeaurora.org/external/imx/linux-imx.git

    create multi workqueue for vpu encoder
    add suspend and resume code to encoder driver
    add wait resume done in decoder resume function
    solve coverity issue: 3520461 Out-of-bounds read

Signed-off-by: GuoRui <rui.guo_4@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/vpu_b0.c         |   18 ++-
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c |  194 ++++++++++++++++++++-------
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h |    8 ++
 3 files changed, 169 insertions(+), 51 deletions(-)

diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index 74b8fed..9834d43 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -1953,7 +1953,7 @@ static int vpu_next_free_instance(struct vpu_dev *dev)
 	return idx;
 }
 
-void send_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
+static void send_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
 {
 	u_int32 ret;
 
@@ -1962,7 +1962,7 @@ void send_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
 		vpu_dbg(LVL_ERR, "There is no memory for msg fifo, ret=%d\n", ret);
 }
 
-bool receive_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
+static bool receive_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
 {
 	u_int32 ret;
 
@@ -2953,11 +2953,12 @@ static void v4l2_vpu_send_snapshot(struct vpu_dev *dev)
 	int strIdx = (~dev->hang_mask) & (dev->instance_mask);
 	/*figure out the first available instance*/
 	for (i = 0; i < VPU_MAX_NUM_STREAMS; i++) {
-		if (CHECK_BIT(strIdx, i))
-		  break;
+		if (CHECK_BIT(strIdx, i)) {
+			strIdx = i;
+			break;
+		}
 	}
 
-	strIdx = i;
 	v4l2_vpu_send_cmd(dev->ctx[strIdx], strIdx, VID_API_CMD_SNAPSHOT, 0, NULL);
 }
 
@@ -2971,7 +2972,7 @@ static int vpu_suspend(struct device *dev)
 		v4l2_vpu_send_snapshot(vpudev);
 
 		if (!wait_for_completion_timeout(&vpudev->snap_done_cmp, msecs_to_jiffies(1000))) {
-			vpu_dbg(LVL_ERR, "error: wait for snapdone event timeouti\n");
+			vpu_dbg(LVL_ERR, "error: wait for vpu decoder snapdone event timeout!\n");
 			return -1;
 		}
 	}
@@ -3005,6 +3006,11 @@ static int vpu_resume(struct device *dev)
 		writel(vpudev->m0_p_fw_space_phy, csr_offset);
 		csr_cpuwait = ioremap(0x2d040004, 4);
 		writel(0x0, csr_cpuwait);
+		/*wait for firmware resotre done*/
+		if (!wait_for_completion_timeout(&vpudev->start_cmp, msecs_to_jiffies(1000))) {
+			vpu_dbg(LVL_ERR, "error: wait for vpu decoder resume done timeout!\n");
+			return -1;
+		}
 	}
 	return 0;
 }
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index ae1224d..1768a61 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -1193,6 +1193,30 @@ static int vpu_next_free_instance(struct vpu_dev *dev)
 	return idx;
 }
 
+static void send_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
+{
+	u_int32 ret;
+
+	ret = kfifo_in(&ctx->msg_fifo, msg, sizeof(struct event_msg));
+	if (ret != sizeof(struct event_msg))
+		vpu_dbg(LVL_ERR, "There is no memory for msg fifo, ret=%d\n", ret);
+}
+
+static bool receive_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
+{
+	u_int32 ret;
+
+	if (kfifo_len(&ctx->msg_fifo) >= sizeof(*msg)) {
+		ret = kfifo_out(&ctx->msg_fifo, msg, sizeof(*msg));
+		if (ret != sizeof(*msg)) {
+			vpu_dbg(LVL_ERR, "kfifo_out has error, ret=%d\n", ret);
+			return false;
+		} else
+			return true;
+	} else
+		return false;
+}
+
 extern u_int32 rpc_MediaIPFW_Video_message_check_encoder(struct shared_addr *This);
 static void vpu_msg_run_work(struct work_struct *work)
 {
@@ -1203,13 +1227,30 @@ static void vpu_msg_run_work(struct work_struct *work)
 
 	while (rpc_MediaIPFW_Video_message_check_encoder(This) == API_MSG_AVAILABLE) {
 		rpc_receive_msg_buf_encoder(This, &msg);
+		mutex_lock(&dev->dev_mutex);
 		ctx = dev->ctx[msg.idx];
-		vpu_api_event_handler(ctx, msg.idx, msg.msgid, msg.msgdata);
+		if (ctx != NULL) {
+			mutex_lock(&ctx->instance_mutex);
+			if (!ctx->ctx_released) {
+				send_msg_queue(ctx, &msg);
+				queue_work(ctx->instance_wq, &ctx->instance_work);
+			}
+			mutex_unlock(&ctx->instance_mutex);
+		}
+		mutex_unlock(&dev->dev_mutex);
 	}
 	if (rpc_MediaIPFW_Video_message_check_encoder(This) == API_MSG_BUFFER_ERROR)
 		vpu_dbg(LVL_ERR, "MSG num is too big to handle");
 
 }
+static void vpu_msg_instance_work(struct work_struct *work)
+{
+	struct vpu_ctx *ctx = container_of(work, struct vpu_ctx, instance_work);
+	struct event_msg msg;
+
+	while (receive_msg_queue(ctx, &msg))
+		vpu_api_event_handler(ctx, msg.idx, msg.msgid, msg.msgdata);
+}
 
 static int vpu_queue_setup(struct vb2_queue *vq,
 		unsigned int *buf_count,
@@ -1501,11 +1542,28 @@ static int v4l2_open(struct file *filp)
 	ctrls_setup_encoder(ctx);
 	ctx->fh.ctrl_handler = &ctx->ctrl_handler;
 
+	ctx->instance_wq = alloc_workqueue("vpu_instance", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
+	if (!ctx->instance_wq) {
+		vpu_dbg(LVL_ERR, "error: %s unable to alloc workqueue for ctx\n", __func__);
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+	INIT_WORK(&ctx->instance_work, vpu_msg_instance_work);
+
+	mutex_init(&ctx->instance_mutex);
+	if (kfifo_alloc(&ctx->msg_fifo,
+				sizeof(struct event_msg) * VID_API_MESSAGE_LIMIT,
+				GFP_KERNEL)) {
+		vpu_dbg(LVL_ERR, "fail to alloc fifo when open\n");
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
 	dev->ctx[idx] = ctx;
 	ctx->b_firstseq = true;
 	ctx->start_flag = true;
 	ctx->forceStop = false;
 	ctx->firmware_stopped = false;
+	ctx->ctx_released = false;
 	init_queue_data(ctx);
 	init_waitqueue_head(&ctx->buffer_wq_output);
 	init_waitqueue_head(&ctx->buffer_wq_input);
@@ -1567,6 +1625,10 @@ static int v4l2_open(struct file *filp)
 	pm_runtime_put_sync(dev->generic_dev);
 	kfree(ctx);
 	return ret;
+err_alloc:
+	pm_runtime_put_sync(dev->generic_dev);
+	kfree(ctx);
+	return ret;
 }
 
 static int v4l2_release(struct file *filp)
@@ -1623,6 +1685,17 @@ static int v4l2_release(struct file *filp)
 				ctx->actFrame.virt_addr,
 				ctx->actFrame.phy_addr
 				);
+	mutex_lock(&ctx->instance_mutex);
+	ctx->ctx_released = true;
+	kfifo_free(&ctx->msg_fifo);
+	destroy_workqueue(ctx->instance_wq);
+	mutex_unlock(&ctx->instance_mutex);
+	mutex_lock(&dev->dev_mutex);
+	if (!(dev->hang_mask & (1 << ctx->str_index))) // judge the path is hang or not, if hang, don't clear
+		clear_bit(ctx->str_index, &dev->instance_mask);
+	dev->ctx[ctx->str_index] = NULL;
+	mutex_unlock(&dev->dev_mutex);
+
 	pm_runtime_put_sync(dev->generic_dev);
 	kfree(ctx);
 	return 0;
@@ -1705,7 +1778,7 @@ static int v4l2_mmap(struct file *filp, struct vm_area_struct *vma)
 	.ioctl_ops = &v4l2_encoder_ioctl_ops,
 	.vfl_dir = VFL_DIR_M2M,
 };
-#if 0
+#if 1
 static int set_vpu_pwr(sc_ipc_t ipcHndl,
 		sc_pm_power_mode_t pm
 		)
@@ -1715,64 +1788,34 @@ static int set_vpu_pwr(sc_ipc_t ipcHndl,
 
 	vpu_dbg(LVL_INFO, "%s()\n", __func__);
 	if (!ipcHndl) {
-		vpu_dbg(LVL_ERR, "--- set_vpu_pwr no IPC handle\n");
+		vpu_dbg(LVL_ERR, "error: --- set_vpu_pwr no IPC handle\n");
 		goto set_vpu_pwrexit;
 	}
 
-	// Power on or off PID0, ENC
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID0, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID0,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID1, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID1,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID2, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID2,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID3, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID3,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID4, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID4,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID5, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID5,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID6, pm);
+	// Power on or off VPU, ENC and MU1
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU, pm);
 	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID6,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID7, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID7,%d) SCI error! (%d)\n", sciErr, pm);
+		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU,%d) SCI error! (%d)\n", sciErr, pm);
 		goto set_vpu_pwrexit;
 	}
 #ifdef TEST_BUILD
 	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_ENC, pm);
 	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_ENC,%d) SCI error! (%d)\n", sciErr, pm);
+		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_ENC,%d) SCI error! (%d)\n", sciErr, pm);
 		goto set_vpu_pwrexit;
 	}
 #else
 	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_ENC_0, pm);
 	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "--- sc_pm_set_resource_power_mode(SC_R_VPU_ENC_0,%d) SCI error! (%d)\n", sciErr, pm);
+		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_ENC_0,%d) SCI error! (%d)\n", sciErr, pm);
 		goto set_vpu_pwrexit;
 	}
 #endif
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_MU_1, pm);
+	if (sciErr != SC_ERR_NONE) {
+		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_MU_1,%d) SCI error! (%d)\n", sciErr, pm);
+		goto set_vpu_pwrexit;
+	}
 
 	rv = 0;
 
@@ -1787,16 +1830,17 @@ static void vpu_set_power(struct vpu_dev *dev, bool on)
 	if (on) {
 		ret = set_vpu_pwr(dev->mu_ipcHandle, SC_PM_PW_MODE_ON);
 		if (ret)
-			vpu_dbg(LVL_ERR, "failed to power on\n");
+			vpu_dbg(LVL_ERR, "error: failed to power on\n");
 		pm_runtime_get_sync(dev->generic_dev);
 	} else {
 		pm_runtime_put_sync_suspend(dev->generic_dev);
 		ret = set_vpu_pwr(dev->mu_ipcHandle, SC_PM_PW_MODE_OFF);
 		if (ret)
-			vpu_dbg(LVL_ERR, "failed to power off\n");
+			vpu_dbg(LVL_ERR, "error: failed to power off\n");
 	}
 }
 #endif
+
 static void vpu_setup(struct vpu_dev *This)
 {
 	uint32_t read_data = 0;
@@ -2037,13 +2081,73 @@ static int vpu_runtime_resume(struct device *dev)
 	return 0;
 }
 
+#define CHECK_BIT(var, pos) (((var) >> (pos)) & 1)
+
+static void v4l2_vpu_send_snapshot(struct vpu_dev *dev)
+{
+	int i = 0;
+	int strIdx = (~dev->hang_mask) & (dev->instance_mask);
+	/*figure out the first available instance*/
+	for (i = 0; i < VPU_MAX_NUM_STREAMS; i++) {
+		if (CHECK_BIT(strIdx, i)) {
+			strIdx = i;
+			break;
+		}
+	}
+
+	v4l2_vpu_send_cmd(dev->ctx[strIdx], strIdx, GTB_ENC_CMD_SNAPSHOT, 0, NULL);
+}
+
 static int vpu_suspend(struct device *dev)
 {
+	struct vpu_dev *vpudev = (struct vpu_dev *)dev_get_drvdata(dev);
+
+	if (vpudev->hang_mask != vpudev->instance_mask) {
+
+		/*if there is an available device, send snapshot command to firmware*/
+		v4l2_vpu_send_snapshot(vpudev);
+
+		if (!wait_for_completion_timeout(&vpudev->snap_done_cmp, msecs_to_jiffies(1000))) {
+			vpu_dbg(LVL_ERR, "error: wait for vpu encoder snapdone event timeout!\n");
+			return -1;
+		}
+	}
+
+	vpu_set_power(vpudev, false);
+
 	return 0;
 }
 
 static int vpu_resume(struct device *dev)
 {
+	struct vpu_dev *vpudev = (struct vpu_dev *)dev_get_drvdata(dev);
+	void *csr_offset, *csr_cpuwait;
+
+	vpu_set_power(vpudev, true);
+	vpu_enable_hw(vpudev);
+
+	MU_Init(vpudev->mu_base_virtaddr);
+	MU_EnableRxFullInt(vpudev->mu_base_virtaddr, 0);
+
+	if (vpudev->hang_mask == vpudev->instance_mask) {
+		/*no instance is active before suspend, do reset*/
+		vpudev->fw_is_ready = false;
+		vpudev->firmware_started = false;
+
+		rpc_init_shared_memory_encoder(&vpudev->shared_mem, vpudev->m0_rpc_phy - vpudev->m0_p_fw_space_phy, vpudev->m0_rpc_virt, SHARED_SIZE);
+		rpc_set_system_cfg_value_encoder(vpudev->shared_mem.pSharedInterface, VPU_REG_BASE);
+	} else {
+		/*resume*/
+		csr_offset = ioremap(0x2d050000, 4);
+		writel(vpudev->m0_p_fw_space_phy, csr_offset);
+		csr_cpuwait = ioremap(0x2d050004, 4);
+		writel(0x0, csr_cpuwait);
+		/*wait for firmware resotre done*/
+		if (!wait_for_completion_timeout(&vpudev->start_cmp, msecs_to_jiffies(1000))) {
+			vpu_dbg(LVL_ERR, "error: wait for vpu encoder resume done timeout!\n");
+			return -1;
+		}
+	}
 	return 0;
 }
 
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
index 2c6f446..42d5fbd 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
@@ -32,6 +32,7 @@
 #include <soc/imx8/sc/sci.h>
 #include <linux/mx8_mu.h>
 #include <media/v4l2-event.h>
+#include <linux/kfifo.h>
 #include "vpu_encoder_rpc.h"
 
 extern unsigned int vpu_dbg_level_encoder;
@@ -184,9 +185,11 @@ struct vpu_dev {
 	bool fw_is_ready;
 	bool firmware_started;
 	struct completion start_cmp;
+	struct completion snap_done_cmp;
 	struct workqueue_struct *workqueue;
 	struct work_struct msg_work;
 	unsigned long instance_mask;
+	unsigned long hang_mask; //this is used to deal with hang issue to reset firmware
 	sc_ipc_t mu_ipcHandle;
 	struct clk *vpu_clk;
 	void __iomem *mu_base_virtaddr;
@@ -216,11 +219,16 @@ struct vpu_ctx {
 
 	int str_index;
 	struct queue_data q_data[2];
+	struct kfifo msg_fifo;
+	struct mutex instance_mutex;
+	struct work_struct instance_work;
+	struct workqueue_struct *instance_wq;
 	struct completion completion;
 	struct completion stop_cmp;
 	bool b_firstseq;
 	bool start_flag;
 	bool firmware_stopped;
+	bool ctx_released;
 	bool forceStop;
 	wait_queue_head_t buffer_wq_output;
 	wait_queue_head_t buffer_wq_input;
-- 
1.7.9.5


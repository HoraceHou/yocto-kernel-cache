From 11045ccf573112ff4dd7d292d530fde31495eacd Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Wed, 28 Nov 2018 16:54:08 +0800
Subject: [PATCH 5228/5242] MLK-20486 drm/imx: ldb: Cleanup enc&conn in
 ->unbind() if necessary

commit  bab01e65805ce38ddfba06ee91c26bbace474be2 from
https://source.codeaurora.org/external/imx/linux-imx.git

When the master imx-drm-core binding fails, component_bind_all()
in imx-drm-core ->bind() callback will unbind all bound components
first and then call drm_mode_config_cleanup().  Since the encoder
and connector(located in imx_ldb.imx_ldb_channel) are freed after
the ldb ->unbind() callback, drm_mode_config_cleanup() would
accidentally access the freed encoder and connector again.  To fix
this issue, we should cleanup the encoder and connector, i.e.,
remove them from the global encoder and connector lists, in the
->unbind() callback, so that, drm_mode_config_cleanup() won't find
them again in the lists.  However, we have to make sure they exist
before the cleanup in the ->unbind() callback, because imx-drm-core
->unbind() calls drm_mode_config_cleanup() first and then unbinds
all components via component_unbind_all().  Moreover, the connector
isn't created at the first place if a bridge exists, so the check
before the cleanup makes sense for this reason as well.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
(cherry picked from commit 6d3fd1316d67ff0e62fae4067b61fd3f2809dfa5)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/imx-ldb.c |    8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/gpu/drm/imx/imx-ldb.c b/drivers/gpu/drm/imx/imx-ldb.c
index 72e612a6..aa51b73 100644
--- a/drivers/gpu/drm/imx/imx-ldb.c
+++ b/drivers/gpu/drm/imx/imx-ldb.c
@@ -1482,6 +1482,14 @@ static void imx_ldb_unbind(struct device *dev, struct device *master,
 		if (channel->panel)
 			drm_panel_detach(channel->panel);
 
+		/* make sure the connector exists, and then cleanup */
+		if (channel->connector.dev)
+			imx_drm_connector_destroy(&channel->connector);
+
+		/* make sure the encoder exists, and then cleanup */
+		if (channel->encoder.dev)
+			imx_drm_encoder_destroy(&channel->encoder);
+
 		kfree(channel->edid);
 		i2c_put_adapter(channel->ddc);
 	}
-- 
1.7.9.5


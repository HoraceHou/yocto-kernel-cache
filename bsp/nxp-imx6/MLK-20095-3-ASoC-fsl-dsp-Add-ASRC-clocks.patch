From da13893f937301e0f01b8b6509e943f4b12f8258 Mon Sep 17 00:00:00 2001
From: Daniel Baluta <daniel.baluta@nxp.com>
Date: Tue, 27 Nov 2018 10:44:13 +0200
Subject: [PATCH 5224/5242] MLK-20095-3: ASoC: fsl: dsp: Add ASRC clocks

commit  51a120cf6df11dcf7276c48c479676a8496553ce from
https://source.codeaurora.org/external/imx/linux-imx.git

We enable the ASRC clocks from CPU side. We only need
the following clocks: "mem", "ipg" and "asrc0..3".

Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
Reviewed-by: Shengjiu Wang <shengjiu.wang@nxp.com>
(cherry picked from commit 586297d7d5855cf75e25f629ca495b8ac5c1bb96)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_dsp_cpu.c |   47 +++++++++++++++++++++++++++++++++++++++++--
 sound/soc/fsl/fsl_dsp_cpu.h |    5 +++++
 2 files changed, 50 insertions(+), 2 deletions(-)

diff --git a/sound/soc/fsl/fsl_dsp_cpu.c b/sound/soc/fsl/fsl_dsp_cpu.c
index c203b70..4903deb3 100644
--- a/sound/soc/fsl/fsl_dsp_cpu.c
+++ b/sound/soc/fsl/fsl_dsp_cpu.c
@@ -47,7 +47,8 @@ static void dsp_audio_shutdown(struct snd_pcm_substream *substream,
 static int dsp_audio_probe(struct platform_device *pdev)
 {
 	struct fsl_dsp_audio *dsp_audio;
-	int ret;
+	int i, ret;
+	char tmp[16];
 
 	dsp_audio = devm_kzalloc(&pdev->dev, sizeof(*dsp_audio), GFP_KERNEL);
 	if (dsp_audio == NULL)
@@ -73,6 +74,27 @@ static int dsp_audio_probe(struct platform_device *pdev)
 		dsp_audio->m_clk = NULL;
 	}
 
+	dsp_audio->asrc_mem_clk = devm_clk_get(&pdev->dev, "mem");
+	if (IS_ERR(dsp_audio->asrc_mem_clk)) {
+		dev_err(&pdev->dev, "failed to get mem clock\n");
+		dsp_audio->asrc_mem_clk = NULL;
+	}
+
+	dsp_audio->asrc_ipg_clk = devm_clk_get(&pdev->dev, "ipg");
+	if (IS_ERR(dsp_audio->asrc_ipg_clk)) {
+		dev_err(&pdev->dev, "failed to get ipg clock\n");
+		dsp_audio->asrc_ipg_clk = NULL;
+	}
+
+	for (i = 0; i < ASRC_CLK_MAX_NUM; i++) {
+		sprintf(tmp, "asrck_%x", i);
+		dsp_audio->asrck_clk[i] = devm_clk_get(&pdev->dev, tmp);
+		if (IS_ERR(dsp_audio->asrck_clk[i])) {
+			dev_err(&pdev->dev, "failed to get %s clock\n", tmp);
+			dsp_audio->asrck_clk[i] = NULL;
+		}
+	}
+
 	pm_runtime_enable(&pdev->dev);
 
 	/* now register audio DSP platform driver */
@@ -100,7 +122,7 @@ static int dsp_audio_remove(struct platform_device *pdev)
 static int dsp_runtime_resume(struct device *dev)
 {
 	struct fsl_dsp_audio *dsp_audio = dev_get_drvdata(dev);
-	int ret;
+	int i, ret;
 
 	ret = clk_prepare_enable(dsp_audio->bus_clk);
 	if (ret) {
@@ -114,13 +136,34 @@ static int dsp_runtime_resume(struct device *dev)
 		return ret;
 	}
 
+	ret = clk_prepare_enable(dsp_audio->asrc_mem_clk);
+	if (ret < 0)
+		dev_err(dev, "Failed to enable asrc_mem_clk ret = %d\n", ret);
+
+	ret = clk_prepare_enable(dsp_audio->asrc_ipg_clk);
+	if (ret < 0)
+		dev_err(dev, "Failed to enable asrc_ipg_clk ret = %d\n", ret);
+
+	for (i = 0; i < ASRC_CLK_MAX_NUM; i++) {
+		ret = clk_prepare_enable(dsp_audio->asrck_clk[i]);
+		if (ret < 0)
+			dev_err(dev, "failed to prepare arc clk %d\n", i);
+	}
+
 	return ret;
 }
 
 static int dsp_runtime_suspend(struct device *dev)
 {
+	int i;
 	struct fsl_dsp_audio *dsp_audio = dev_get_drvdata(dev);
 
+	for (i = 0; i < ASRC_CLK_MAX_NUM; i++)
+		clk_disable_unprepare(dsp_audio->asrck_clk[i]);
+
+	clk_disable_unprepare(dsp_audio->asrc_ipg_clk);
+	clk_disable_unprepare(dsp_audio->asrc_mem_clk);
+
 	clk_disable_unprepare(dsp_audio->m_clk);
 	clk_disable_unprepare(dsp_audio->bus_clk);
 
diff --git a/sound/soc/fsl/fsl_dsp_cpu.h b/sound/soc/fsl/fsl_dsp_cpu.h
index ef28138..a6c1043 100644
--- a/sound/soc/fsl/fsl_dsp_cpu.h
+++ b/sound/soc/fsl/fsl_dsp_cpu.h
@@ -8,10 +8,15 @@
 #ifndef __FSL_DSP_CPU_H
 #define __FSL_DSP_CPU_H
 
+#define ASRC_CLK_MAX_NUM 4
+
 struct fsl_dsp_audio {
 	struct platform_device *pdev;
 	struct clk *bus_clk;
 	struct clk *m_clk;
+	struct clk *asrc_mem_clk;
+	struct clk *asrc_ipg_clk;
+	struct clk *asrck_clk[ASRC_CLK_MAX_NUM];
 };
 
 #endif /*__FSL_DSP_CPU_H*/
-- 
1.7.9.5


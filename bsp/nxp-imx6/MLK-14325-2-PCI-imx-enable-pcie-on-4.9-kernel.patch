From a8e1ae3e04dc013943db9a18093ca8ba5aeb368c Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Tue, 7 Mar 2017 09:11:12 +0800
Subject: [PATCH 1550/5242] MLK-14325-2 PCI: imx: enable pcie on 4.9 kernel

commit  6f5524e5929606095f68bca65a07e57c168024f7 from
https://source.codeaurora.org/external/imx/linux-imx.git

- Do not return error when the GEN2 link negatiation
is failed. Because that the limitation maybe caused
by the remote GEN1 EP device.
- Move the power saving codes to the proper place
after the link is down.
Otherwise, system would hang when link is down.

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/controller/dwc/pci-imx6.c |   47 +++++++++++++++++----------------
 1 file changed, 24 insertions(+), 23 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index c8a4911..bc2f4ad 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -487,9 +487,10 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 	if (gpio_is_valid(imx6_pcie->reset_gpio)) {
 		gpio_set_value_cansleep(imx6_pcie->reset_gpio,
 					imx6_pcie->gpio_active_high);
-		msleep(100);
+		mdelay(20);
 		gpio_set_value_cansleep(imx6_pcie->reset_gpio,
 					!imx6_pcie->gpio_active_high);
+		mdelay(20);
 	}
 
 	switch (imx6_pcie->variant) {
@@ -501,28 +502,28 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				   IMX6Q_GPR1_PCIE_SW_RST, 0);
 
-		usleep_range(200, 500);
+		udelay(200);
 
 		/* Configure the PHY when 100Mhz external OSC is used as input clock */
 		if (!imx6_pcie->ext_osc)
 			break;
 
 		mdelay(4);
-		pcie_phy_read(pci->dbi_base, SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO, &val);
+		pcie_phy_read(imx6_pcie, SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO, &val);
 		/* MPLL_MULTIPLIER [8:2] */
 		val &= ~(0x7F << 2);
 		val |= (0x19 << 2);
 		/* MPLL_MULTIPLIER_OVRD [9:9] */
 		val |= (0x1 << 9);
-		pcie_phy_write(pci->dbi_base, SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO, val);
+		pcie_phy_write(imx6_pcie, SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO, val);
 		mdelay(4);
 
-		pcie_phy_read(pci->dbi_base, SSP_CR_SUP_DIG_ATEOVRD, &val);
+		pcie_phy_read(imx6_pcie, SSP_CR_SUP_DIG_ATEOVRD, &val);
 		/* ref_clkdiv2 [0:0] */
 		val &= ~0x1;
 		/* ateovrd_en [2:2] */
 		val |=  0x4;
-		pcie_phy_write(pci->dbi_base, SSP_CR_SUP_DIG_ATEOVRD, val);
+		pcie_phy_write(imx6_pcie, SSP_CR_SUP_DIG_ATEOVRD, val);
 		mdelay(4);
 
 		break;
@@ -673,20 +674,6 @@ static int imx6_pcie_wait_for_link(struct imx6_pcie *imx6_pcie)
 		dw_pcie_readl_dbi(pci, PCIE_PHY_DEBUG_R0),
 		dw_pcie_readl_dbi(pci, PCIE_PHY_DEBUG_R1));
 
-	if (!IS_ENABLED(CONFIG_PCI_IMX6_COMPLIANCE_TEST)) {
-		clk_disable_unprepare(imx6_pcie->pcie);
-		if (!imx6_pcie->ext_osc)
-			clk_disable_unprepare(imx6_pcie->pcie_bus);
-		clk_disable_unprepare(imx6_pcie->pcie_phy);
-		if (imx6_pcie->variant == IMX6SX)
-			clk_disable_unprepare(imx6_pcie->pcie_inbound_axi);
-		release_bus_freq(BUS_FREQ_HIGH);
-		if (imx6_pcie->pcie_phy_regulator != NULL)
-			regulator_disable(imx6_pcie->pcie_phy_regulator);
-		if (imx6_pcie->pcie_bus_regulator != NULL)
-			regulator_disable(imx6_pcie->pcie_bus_regulator);
-	}
-
 	return -ETIMEDOUT;
 }
 
@@ -702,7 +689,7 @@ static int imx6_pcie_wait_for_speed_change(struct imx6_pcie *imx6_pcie)
 		/* Test if the speed change finished. */
 		if (!(tmp & PORT_LOGIC_SPEED_CHANGE))
 			return 0;
-		usleep_range(100, 1000);
+		udelay(100);
 	}
 
 	dev_err(dev, "Speed change timeout\n");
@@ -766,8 +753,7 @@ static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
 
 			ret = imx6_pcie_wait_for_speed_change(imx6_pcie);
 			if (ret) {
-				dev_err(dev, "Failed to bring link up!\n");
-				goto err_reset_phy;
+				dev_info(dev, "Roll back to GEN1 link!\n");
 			}
 		}
 
@@ -790,6 +776,21 @@ static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
 		dw_pcie_readl_dbi(pci, PCIE_PHY_DEBUG_R0),
 		dw_pcie_readl_dbi(pci, PCIE_PHY_DEBUG_R1));
 	imx6_pcie_reset_phy(imx6_pcie);
+
+	if (!IS_ENABLED(CONFIG_PCI_IMX6_COMPLIANCE_TEST)) {
+		clk_disable_unprepare(imx6_pcie->pcie);
+		if (!imx6_pcie->ext_osc)
+			clk_disable_unprepare(imx6_pcie->pcie_bus);
+		clk_disable_unprepare(imx6_pcie->pcie_phy);
+		if (imx6_pcie->variant == IMX6SX)
+			clk_disable_unprepare(imx6_pcie->pcie_inbound_axi);
+		release_bus_freq(BUS_FREQ_HIGH);
+		if (imx6_pcie->pcie_phy_regulator != NULL)
+			regulator_disable(imx6_pcie->pcie_phy_regulator);
+		if (imx6_pcie->pcie_bus_regulator != NULL)
+			regulator_disable(imx6_pcie->pcie_bus_regulator);
+	}
+
 	return ret;
 }
 
-- 
1.7.9.5


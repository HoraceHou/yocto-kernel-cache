From c60b89c0068e437cdb8907f39e11833862b932f1 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Thu, 15 Jun 2017 16:45:29 +0800
Subject: [PATCH 1895/5242] MLK-15092 reset: gpio-reset: add post reset delay

commit  1dbaf3a2c4bbeb9278640c4e9bc0045378379ea3 from
https://source.codeaurora.org/external/imx/linux-imx.git

Some devices need to wait for some milliseconds after reset, so add
post reset delay in the gpio-reset chip.

The post reset delay is optional.

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/reset/gpio-reset.txt       |    1 +
 drivers/reset/gpio-reset.c                         |   12 ++++++++++++
 2 files changed, 13 insertions(+)

diff --git a/Documentation/devicetree/bindings/reset/gpio-reset.txt b/Documentation/devicetree/bindings/reset/gpio-reset.txt
index bca5348..7d45d8b8 100644
--- a/Documentation/devicetree/bindings/reset/gpio-reset.txt
+++ b/Documentation/devicetree/bindings/reset/gpio-reset.txt
@@ -14,6 +14,7 @@ Required properties:
 Optional properties:
 - reset-delay-us: delay in microseconds. The gpio reset line will be asserted for
                   this duration to reset.
+- reset-post-delay-ms: delay in milliseconds to wait after reset.
 - initially-in-reset: boolean. If not set, the initial state should be a
                       deasserted reset line. If this property exists, the
                       reset line should be kept in reset.
diff --git a/drivers/reset/gpio-reset.c b/drivers/reset/gpio-reset.c
index 3049b22..9dc768a 100644
--- a/drivers/reset/gpio-reset.c
+++ b/drivers/reset/gpio-reset.c
@@ -21,6 +21,7 @@ struct gpio_reset_data {
 	unsigned int gpio;
 	bool active_low;
 	s32 delay_us;
+	s32 post_delay_ms;
 };
 
 static void gpio_reset_set(struct reset_controller_dev *rcdev, int asserted)
@@ -47,6 +48,10 @@ static int gpio_reset(struct reset_controller_dev *rcdev, unsigned long id)
 	udelay(drvdata->delay_us);
 	gpio_reset_set(rcdev, 0);
 
+	if (drvdata->post_delay_ms < 0)
+		return 0;
+
+	msleep(drvdata->post_delay_ms);
 	return 0;
 }
 
@@ -116,6 +121,13 @@ static int gpio_reset_probe(struct platform_device *pdev)
 	else if (drvdata->delay_us < 0)
 		dev_warn(&pdev->dev, "reset delay too high\n");
 
+	/* It is optional.
+	 * Some devices need some milliseconds to wait after reset.
+	 */
+	ret = of_property_read_u32(np, "reset-post-delay-ms", &drvdata->post_delay_ms);
+	if (ret < 0)
+		drvdata->post_delay_ms = -1;
+
 	initially_in_reset = of_property_read_bool(np, "initially-in-reset");
 	if (drvdata->active_low ^ initially_in_reset)
 		gpio_flags = GPIOF_OUT_INIT_HIGH;
-- 
1.7.9.5


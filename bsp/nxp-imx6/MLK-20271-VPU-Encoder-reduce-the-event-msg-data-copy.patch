From a6359bdac06f2ab1678d4632d7b38d40af44a9b8 Mon Sep 17 00:00:00 2001
From: ming_qian <ming.qian@nxp.com>
Date: Thu, 8 Nov 2018 09:21:47 +0800
Subject: [PATCH 5084/5242] MLK-20271:VPU Encoder:reduce the event msg data
 copy

commit  d89e81d6e0af7c1b157d15f1db11e3a6624f9191 from
https://source.codeaurora.org/external/imx/linux-imx.git

Signed-off-by: ming_qian <ming.qian@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-encoder-b0/Makefile             |    1 +
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c     |  178 ++++++++++-------
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h     |    7 +-
 drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h |    7 +
 drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c    |   54 +++++-
 drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.h    |   13 +-
 drivers/mxc/vpu-encoder-b0/vpu_event_msg.c      |  236 +++++++++++++++++++++++
 drivers/mxc/vpu-encoder-b0/vpu_event_msg.h      |   35 ++++
 8 files changed, 445 insertions(+), 86 deletions(-)
 create mode 100644 drivers/mxc/vpu-encoder-b0/vpu_event_msg.c
 create mode 100644 drivers/mxc/vpu-encoder-b0/vpu_event_msg.h

diff --git a/drivers/mxc/vpu-encoder-b0/Makefile b/drivers/mxc/vpu-encoder-b0/Makefile
index ccce55a..bb4d7a6 100644
--- a/drivers/mxc/vpu-encoder-b0/Makefile
+++ b/drivers/mxc/vpu-encoder-b0/Makefile
@@ -7,6 +7,7 @@ EXTRA_CFLAGS += $(DEFINES)
 obj-y = vpu-encoder.o
 vpu-encoder-objs = vpu_encoder_b0.o \
 	vpu_encoder_ctrl.o \
+	vpu_event_msg.o \
 	vpu_encoder_rpc.o
 
 clean:
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index e148b6f..4d1bc4c 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -49,6 +49,7 @@
 #include "vpu_encoder_b0.h"
 #include "vpu_encoder_ctrl.h"
 #include "vpu_encoder_config.h"
+#include "vpu_event_msg.h"
 
 struct vpu_frame_info {
 	struct list_head list;
@@ -1394,7 +1395,8 @@ static void show_codec_configure(pMEDIAIP_ENC_PARAM param)
 			"QP", param->uInitSliceQP);
 }
 
-static void show_firmware_version(struct core_device *core_dev)
+static void show_firmware_version(struct core_device *core_dev,
+				unsigned int level)
 {
 	pENC_RPC_HOST_IFACE pSharedInterface;
 
@@ -1403,7 +1405,7 @@ static void show_firmware_version(struct core_device *core_dev)
 
 	pSharedInterface = core_dev->shared_mem.pSharedInterface;
 
-	vpu_dbg(LVL_ALL, "vpu encoder firmware version is %d.%d.%d\n",
+	vpu_dbg(level, "vpu encoder firmware version is %d.%d.%d\n",
 			(pSharedInterface->FWVersion & 0x00ff0000) >> 16,
 			(pSharedInterface->FWVersion & 0x0000ff00) >> 8,
 			pSharedInterface->FWVersion & 0x000000ff);
@@ -1526,7 +1528,7 @@ static int configure_codec(struct vpu_ctx *ctx)
 	pEncExpertModeParam->Calib.cb_base = ctx->encoder_stream.phy_addr;
 	pEncExpertModeParam->Calib.cb_size = ctx->encoder_stream.size;
 
-	show_firmware_version(ctx->core_dev);
+	show_firmware_version(ctx->core_dev, LVL_INFO);
 	memcpy(enc_param, &attr->param, sizeof(attr->param));
 	vpu_ctx_send_cmd(ctx, GTB_ENC_CMD_CONFIGURE_CODEC, 0, NULL);
 	vpu_dbg(LVL_INFO, "send command GTB_ENC_CMD_CONFIGURE_CODEC\n");
@@ -2459,30 +2461,6 @@ static int vpu_mu_init(struct core_device *core_dev)
 	return ret;
 }
 
-static void send_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
-{
-	u_int32 ret;
-
-	ret = kfifo_in(&ctx->msg_fifo, msg, sizeof(struct event_msg));
-	if (ret != sizeof(struct event_msg))
-		vpu_dbg(LVL_ERR, "There is no memory for msg fifo, ret=%d\n", ret);
-}
-
-static bool receive_msg_queue(struct vpu_ctx *ctx, struct event_msg *msg)
-{
-	u_int32 ret;
-
-	if (kfifo_len(&ctx->msg_fifo) >= sizeof(*msg)) {
-		ret = kfifo_out(&ctx->msg_fifo, msg, sizeof(*msg));
-		if (ret != sizeof(*msg)) {
-			vpu_dbg(LVL_ERR, "kfifo_out has error, ret=%d\n", ret);
-			return false;
-		} else
-			return true;
-	} else
-		return false;
-}
-
 static struct vpu_ctx *get_ctx_by_index(struct core_device *core, int index)
 {
 	struct vpu_ctx *ctx = NULL;
@@ -2512,46 +2490,106 @@ static struct vpu_ctx *get_ctx_by_index(struct core_device *core, int index)
 	return ctx;
 }
 
+static int process_ctx_msg(struct vpu_ctx *ctx, struct msg_header *header)
+{
+	int ret = 0;
+	struct vpu_event_msg *msg = NULL;
+	u32 *pdata = NULL;
+
+	if (!ctx || !header)
+		return -EINVAL;
+
+	if (ctx->ctx_released)
+		return -EINVAL;
+
+	msg = get_idle_msg(ctx);
+	if (!msg) {
+		vpu_err("get idle msg fail\n");
+		return -ENOMEM;
+	}
+
+	msg->idx = header->idx;
+	msg->msgid = header->msgid;
+	msg->number = header->msgnum;
+	pdata = msg->data;
+	ret = 0;
+	if (msg->number > ARRAY_SIZE(msg->data)) {
+		ret = alloc_msg_ext_buffer(msg, header->msgnum);
+		pdata = msg->ext_data;
+	}
+	rpc_read_msg_array(&ctx->core_dev->shared_mem, pdata, msg->number);
+	if (ret) {
+		put_idle_msg(ctx, msg);
+		return ret;
+	}
+
+	push_back_event_msg(ctx, msg);
+
+	return ret;
+}
+
+static int process_msg(struct core_device *core)
+{
+	struct msg_header header;
+	struct vpu_ctx *ctx = NULL;
+	int ret;
+
+	ret = rpc_get_msg_header(&core->shared_mem, &header);
+	if (ret)
+		return ret;
+
+	if (header.idx >= ARRAY_SIZE(core->ctx)) {
+		vpu_err("msg idx(%d) is out of range\n", header.idx);
+		return -EINVAL;
+	}
+
+	mutex_lock(&core->vdev->dev_mutex);
+	ctx = get_ctx_by_index(core, header.idx);
+	if (ctx != NULL) {
+		process_ctx_msg(ctx, &header);
+		queue_work(ctx->instance_wq, &ctx->instance_work);
+	} else {
+		vpu_err("msg[%d] of ctx[%d] is missed\n",
+				header.msgid, header.idx);
+		rpc_read_msg_array(&core->shared_mem, NULL, header.msgnum);
+	}
+	mutex_unlock(&core->vdev->dev_mutex);
+
+	return 0;
+}
+
 extern u_int32 rpc_MediaIPFW_Video_message_check_encoder(struct shared_addr *This);
 static void vpu_msg_run_work(struct work_struct *work)
 {
 	struct core_device *dev = container_of(work, struct core_device, msg_work);
-	struct vpu_ctx *ctx;
-	struct event_msg msg;
+	/*struct vpu_ctx *ctx;*/
+	/*struct event_msg msg;*/
 	struct shared_addr *This = &dev->shared_mem;
 
 	while (rpc_MediaIPFW_Video_message_check_encoder(This) == API_MSG_AVAILABLE) {
-		rpc_receive_msg_buf_encoder(This, &msg);
-		if (msg.idx >= ARRAY_SIZE(dev->ctx)) {
-			vpu_err("msg idx(%d) is out of range\n", msg.idx);
-			continue;
-		}
-		mutex_lock(&dev->vdev->dev_mutex);
-		ctx = get_ctx_by_index(dev, msg.idx);
-		if (ctx != NULL) {
-			mutex_lock(&ctx->instance_mutex);
-			if (!ctx->ctx_released) {
-				send_msg_queue(ctx, &msg);
-				queue_work(ctx->instance_wq, &ctx->instance_work);
-			}
-			mutex_unlock(&ctx->instance_mutex);
-		} else {
-			vpu_err("msg[%d] of ctx[%d] is missed\n",
-					msg.msgid, msg.idx);
-		}
-		mutex_unlock(&dev->vdev->dev_mutex);
+		process_msg(dev);
 	}
 	if (rpc_MediaIPFW_Video_message_check_encoder(This) == API_MSG_BUFFER_ERROR)
 		vpu_dbg(LVL_ERR, "MSG num is too big to handle");
 
 }
+
 static void vpu_msg_instance_work(struct work_struct *work)
 {
 	struct vpu_ctx *ctx = container_of(work, struct vpu_ctx, instance_work);
-	struct event_msg msg;
+	struct vpu_event_msg *msg;
 
-	while (receive_msg_queue(ctx, &msg))
-		vpu_api_event_handler(ctx, msg.msgid, msg.msgdata);
+	while (1) {
+		msg = pop_event_msg(ctx);
+		if (!msg)
+			break;
+		if (msg->ext_data)
+			vpu_api_event_handler(ctx, msg->msgid, msg->ext_data);
+		else
+			vpu_api_event_handler(ctx, msg->msgid, msg->data);
+
+		put_idle_msg(ctx, msg);
+	}
 }
 
 static int vpu_queue_setup(struct vb2_queue *vq,
@@ -2866,6 +2904,7 @@ static int download_vpu_firmware(struct vpu_dev *dev,
 
 	core_dev->fw_is_ready = true;
 	clear_core_hang(core_dev);
+	show_firmware_version(core_dev, LVL_ALL);
 exit:
 	return ret;
 }
@@ -3043,23 +3082,21 @@ static void uninit_vpu_ctx(struct vpu_ctx *ctx)
 	if (!ctx)
 		return;
 
-	mutex_lock(&ctx->instance_mutex);
 	if (ctx->instance_wq) {
 		cancel_work_sync(&ctx->instance_work);
 		destroy_workqueue(ctx->instance_wq);
 		ctx->instance_wq = NULL;
 	}
+	cleanup_ctx_msg_queue(ctx);
+	mutex_lock(&ctx->instance_mutex);
 	free_encoder_stream(ctx);
 
-	kfifo_free(&ctx->msg_fifo);
 	ctx->ctx_released = true;
 	mutex_unlock(&ctx->instance_mutex);
 }
 
 static int init_vpu_ctx(struct vpu_ctx *ctx)
 {
-	int ret;
-
 	INIT_WORK(&ctx->instance_work, vpu_msg_instance_work);
 	ctx->instance_wq = alloc_workqueue("vpu_instance",
 				WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
@@ -3068,13 +3105,7 @@ static int init_vpu_ctx(struct vpu_ctx *ctx)
 		return -ENOMEM;
 	}
 
-	ret = kfifo_alloc(&ctx->msg_fifo,
-			sizeof(struct event_msg) * VID_API_MESSAGE_LIMIT,
-			GFP_KERNEL);
-	if (ret) {
-		vpu_dbg(LVL_ERR, "fail to alloc fifo when open\n");
-		goto error;
-	}
+	init_ctx_msg_queue(ctx);
 
 	init_queue_data(ctx);
 	init_completion(&ctx->stop_cmp);
@@ -3083,9 +3114,6 @@ static int init_vpu_ctx(struct vpu_ctx *ctx)
 	ctx->core_dev->ctx[ctx->str_index] = ctx;
 
 	return 0;
-error:
-	uninit_vpu_ctx(ctx);
-	return ret;
 }
 
 static ssize_t show_instance_info(struct device *dev,
@@ -3229,6 +3257,11 @@ static ssize_t show_instance_info(struct device *dev,
 				"latency(ms):%ld\n", latency);
 	}
 
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			"total event msg obj count:%ld\n", vpu_attr->msg_count);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			"total msg ext data count:%lld\n",
+			get_total_ext_data_number());
 	if (!vpu_attr->core->ctx[vpu_attr->index])
 		num += snprintf(buf + num, PAGE_SIZE - num,
 			"<instance has been released>\n");
@@ -3273,13 +3306,23 @@ static ssize_t show_core_info(struct device *dev,
 			"max instance num:%d\n",
 			core->supported_instance_count);
 	num += snprintf(buf + num, PAGE_SIZE - num,
-			"fw info         :0x%02x 0x%02x\n", fw[16], fw[17]);
-	num += snprintf(buf + num, PAGE_SIZE - num,
 			"fw_is_ready     :%d\n", core->fw_is_ready);
 	num += snprintf(buf + num, PAGE_SIZE - num,
 			"firmware_started:%d\n", core->firmware_started);
 	num += snprintf(buf + num, PAGE_SIZE - num,
 			"hang            :%d\n", core->hang);
+	if (core->fw_is_ready) {
+		pENC_RPC_HOST_IFACE iface = core->shared_mem.pSharedInterface;
+
+		num += snprintf(buf + num, PAGE_SIZE - num,
+			"firmware version:%d.%d.%d\n",
+			(iface->FWVersion & 0x00ff0000) >> 16,
+			(iface->FWVersion & 0x0000ff00) >> 8,
+			iface->FWVersion & 0x000000ff);
+		num += snprintf(buf + num, PAGE_SIZE - num,
+			"fw info         :0x%02x 0x%02x\n", fw[16], fw[17]);
+	}
+
 	return num;
 }
 
@@ -3774,7 +3817,6 @@ static int init_vpu_core_dev(struct core_device *core_dev)
 	if (!core_dev)
 		return -EINVAL;
 
-	mutex_init(&core_dev->core_mutex);
 	mutex_init(&core_dev->cmd_mutex);
 	init_completion(&core_dev->start_cmp);
 	init_completion(&core_dev->snap_done_cmp);
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
index ad1226d..e0d8a9e 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
@@ -227,6 +227,7 @@ struct vpu_attr {
 	MEDIAIP_ENC_PARAM param;
 
 	unsigned long ts_start[2];
+	unsigned long msg_count;
 
 	bool created;
 };
@@ -241,7 +242,7 @@ struct core_device {
 	u32 rpc_buf_size;
 	u32 print_buf_size;
 	u32 rpc_actual_size;
-	struct mutex core_mutex;
+
 	struct mutex cmd_mutex;
 	bool fw_is_ready;
 	bool firmware_started;
@@ -314,7 +315,6 @@ struct vpu_ctx {
 	int str_index;
 	unsigned long status;
 	struct queue_data q_data[2];
-	struct kfifo msg_fifo;
 	struct mutex instance_mutex;
 	struct work_struct instance_work;
 	struct workqueue_struct *instance_wq;
@@ -329,6 +329,9 @@ struct vpu_ctx {
 
 	struct completion stop_cmp;
 	bool power_status;
+
+	struct list_head msg_q;
+	struct list_head idle_q;
 };
 
 #define LVL_DEBUG	4
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h
index 5504a12..bbca6e8 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h
@@ -1,6 +1,9 @@
 /*
  * Copyright(c) 2018 NXP. All rights reserved.
  *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
  * vpu_encoder_config.h
  *
  * Author Ming Qian<ming.qian@nxp.com>
@@ -27,4 +30,8 @@
 #define VPU_TAIL_SERACH_SIZE		32
 #define VPU_STRM_END_PATTERN		{0x0, 0x0, 0x1, 0xb}
 
+#define MSG_DATA_DEFAULT_SIZE		256
+#define MSG_DEFAULT_COUNT		4
+#define MSG_COUNT_THD			16
+
 #endif
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c
index 5530a80..ecd9e9b 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c
@@ -53,6 +53,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/errno.h>
 #include "vpu_encoder_rpc.h"
 
 void rpc_init_shared_memory_encoder(struct shared_addr *This,
@@ -288,22 +289,55 @@ static void rpc_update_msg_buffer_ptr_encoder(BUFFER_DESCRIPTOR_TYPE *pMsgDesc)
 	pMsgDesc->rptr = uReadPtr;
 }
 
-void rpc_receive_msg_buf_encoder(struct shared_addr *This, struct event_msg *msg)
+u32 rpc_read_msg_u32(struct shared_addr *shared_mem)
 {
-	unsigned int i;
-	pENC_RPC_HOST_IFACE pSharedInterface = (pENC_RPC_HOST_IFACE)This->shared_mem_vir;
-	BUFFER_DESCRIPTOR_TYPE *pMsgDesc = &pSharedInterface->StreamMsgBufferDesc;
-	u_int32 msgword = *((u_int32 *)(This->msg_mem_vir+pMsgDesc->rptr - pMsgDesc->start));
+	u32 msgword;
+	u32 *ptr = NULL;
+	pENC_RPC_HOST_IFACE iface = NULL;
+	BUFFER_DESCRIPTOR_TYPE *msg_buf = NULL;
+
+	if (!shared_mem)
+		return 0;
+
+	iface = shared_mem->pSharedInterface;
+	msg_buf = &iface->StreamMsgBufferDesc;
+	ptr = shared_mem->msg_mem_vir + msg_buf->rptr - msg_buf->start;
+	rpc_update_msg_buffer_ptr_encoder(msg_buf);
+	msgword = *ptr;
+
+	return msgword;
+}
+
+int rpc_read_msg_array(struct shared_addr *shared_mem, u32 *buf, u32 number)
+{
+	int i;
+	u32 val;
 
+	if (!shared_mem)
+		return -EINVAL;
+
+	for (i = 0; i < number; i++) {
+		val = rpc_read_msg_u32(shared_mem);
+		if (buf)
+			buf[i] = val;
+	}
+
+	return 0;
+}
+
+int rpc_get_msg_header(struct shared_addr *shared_mem, struct msg_header *msg)
+{
+	u32 msgword;
+
+	if (!shared_mem || !msg)
+		return -EINVAL;
+
+	msgword = rpc_read_msg_u32(shared_mem);
 	msg->idx = ((msgword & 0xff000000) >> 24);
 	msg->msgnum = ((msgword & 0x00ff0000) >> 16);
 	msg->msgid = ((msgword & 0x00003fff) >> 0);
-	rpc_update_msg_buffer_ptr_encoder(pMsgDesc);
 
-	for (i = 0; i < msg->msgnum; i++) {
-		msg->msgdata[i] = *((u_int32 *)(This->msg_mem_vir+pMsgDesc->rptr - pMsgDesc->start));
-		rpc_update_msg_buffer_ptr_encoder(pMsgDesc);
-	}
+	return 0;
 }
 
 static void *phy_to_virt(u_int32 src, unsigned long long offset)
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.h
index b77d5b6..934b542 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.h
@@ -92,11 +92,10 @@ struct shared_addr {
 	unsigned long long base_offset;
 };
 
-struct event_msg {
-	u_int32 idx;
-	u_int32 msgnum;
-	u_int32 msgid;
-	u_int32 msgdata[LOCAL_MSG_NUM];
+struct msg_header {
+	u32 idx;
+	u32 msgnum;
+	u32 msgid;
 };
 
 void rpc_init_shared_memory_encoder(struct shared_addr *This,
@@ -110,7 +109,9 @@ void rpc_send_cmd_buf_encoder(struct shared_addr *This,
 		u_int32 cmdid,
 		u_int32 cmdnum,
 		u_int32 *local_cmddata);
-void rpc_receive_msg_buf_encoder(struct shared_addr *This, struct event_msg *msg);
+u32 rpc_read_msg_u32(struct shared_addr *shared_mem);
+int rpc_read_msg_array(struct shared_addr *shared_mem, u32 *buf, u32 number);
+int rpc_get_msg_header(struct shared_addr *shared_mem, struct msg_header *msg);
 
 pMEDIAIP_ENC_YUV_BUFFER_DESC rpc_get_yuv_buffer_desc(
 		struct shared_addr *shared_mem, int index);
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c b/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c
new file mode 100644
index 0000000..d62af1e
--- /dev/null
+++ b/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright(c) 2018 NXP. All rights reserved.
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * vpu_event_msg.c
+ *
+ * Author Ming Qian<ming.qian@nxp.com>
+ */
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+
+#include "vpu_encoder_b0.h"
+#include "vpu_event_msg.h"
+
+static atomic64_t total_ext_data = ATOMIC64_INIT(0);
+
+static struct vpu_event_msg *alloc_event_msg(void)
+{
+	struct vpu_event_msg *msg = NULL;
+
+	msg = vzalloc(sizeof(*msg));
+
+	return msg;
+}
+
+static void free_event_msg(struct vpu_event_msg *msg)
+{
+	if (!msg)
+		return;
+
+	free_msg_ext_buffer(msg);
+	vfree(msg);
+}
+
+static void set_msg_count(struct vpu_ctx *ctx, unsigned long count)
+{
+	struct vpu_attr *attr = get_vpu_ctx_attr(ctx);
+
+	if (attr)
+		attr->msg_count = count;
+}
+
+static void inc_msg_count(struct vpu_ctx *ctx)
+{
+	struct vpu_attr *attr = get_vpu_ctx_attr(ctx);
+
+	if (attr)
+		attr->msg_count++;
+}
+
+static void dec_msg_count(struct vpu_ctx *ctx)
+{
+	struct vpu_attr *attr = get_vpu_ctx_attr(ctx);
+
+	if (attr)
+		attr->msg_count--;
+}
+
+static bool is_msg_count_full(struct vpu_ctx *ctx)
+{
+	struct vpu_attr *attr = get_vpu_ctx_attr(ctx);
+
+	if (!attr)
+		return false;
+	if (attr->msg_count > MSG_COUNT_THD)
+		return true;
+	return false;
+}
+
+void cleanup_ctx_msg_queue(struct vpu_ctx *ctx)
+{
+	struct vpu_event_msg *msg;
+	struct vpu_event_msg *tmp;
+
+	WARN_ON(!ctx);
+
+	mutex_lock(&ctx->instance_mutex);
+	list_for_each_entry_safe(msg, tmp, &ctx->msg_q, list) {
+		list_del_init(&msg->list);
+		vpu_dbg(LVL_WARN, "drop core[%d] ctx[%d] msg:[%d]\n",
+				ctx->core_dev->id, ctx->str_index, msg->msgid);
+		free_event_msg(msg);
+		dec_msg_count(ctx);
+	}
+
+	list_for_each_entry_safe(msg, tmp, &ctx->idle_q, list) {
+		list_del_init(&msg->list);
+		free_event_msg(msg);
+		dec_msg_count(ctx);
+	}
+	mutex_unlock(&ctx->instance_mutex);
+}
+
+static int increase_idle_msg(struct vpu_ctx *ctx, u32 count)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		struct vpu_event_msg *msg = alloc_event_msg();
+
+		if (!msg)
+			continue;
+		list_add_tail(&msg->list, &ctx->idle_q);
+		inc_msg_count(ctx);
+	}
+
+	return 0;
+}
+
+int init_ctx_msg_queue(struct vpu_ctx *ctx)
+{
+	WARN_ON(!ctx);
+	if (!ctx)
+		return -EINVAL;
+
+	mutex_lock(&ctx->instance_mutex);
+
+	set_msg_count(ctx, 0);
+	INIT_LIST_HEAD(&ctx->msg_q);
+	INIT_LIST_HEAD(&ctx->idle_q);
+	increase_idle_msg(ctx, MSG_DEFAULT_COUNT);
+
+	mutex_unlock(&ctx->instance_mutex);
+
+	return 0;
+}
+
+struct vpu_event_msg *get_idle_msg(struct vpu_ctx *ctx)
+{
+	struct vpu_event_msg *msg = NULL;
+
+	WARN_ON(!ctx);
+
+	mutex_lock(&ctx->instance_mutex);
+	if (list_empty(&ctx->idle_q))
+		increase_idle_msg(ctx, 1);
+
+	msg = list_first_entry(&ctx->idle_q, struct vpu_event_msg, list);
+	if (msg)
+		list_del_init(&msg->list);
+
+	mutex_unlock(&ctx->instance_mutex);
+
+	return msg;
+}
+
+void put_idle_msg(struct vpu_ctx *ctx, struct vpu_event_msg *msg)
+{
+	WARN_ON(!ctx);
+
+	if (!ctx || !msg)
+		return;
+
+	free_msg_ext_buffer(msg);
+
+	mutex_lock(&ctx->instance_mutex);
+	if (is_msg_count_full(ctx)) {
+		free_event_msg(msg);
+		dec_msg_count(ctx);
+	} else {
+		list_add_tail(&msg->list, &ctx->idle_q);
+	}
+	mutex_unlock(&ctx->instance_mutex);
+}
+
+struct vpu_event_msg *pop_event_msg(struct vpu_ctx *ctx)
+{
+	struct vpu_event_msg *msg = NULL;
+
+	WARN_ON(!ctx);
+
+	mutex_lock(&ctx->instance_mutex);
+	if (list_empty(&ctx->msg_q))
+		goto exit;
+
+	msg = list_first_entry(&ctx->msg_q, struct vpu_event_msg, list);
+	if (msg)
+		list_del_init(&msg->list);
+
+exit:
+	mutex_unlock(&ctx->instance_mutex);
+	return msg;
+}
+
+void push_back_event_msg(struct vpu_ctx *ctx, struct vpu_event_msg *msg)
+{
+	WARN_ON(!ctx);
+
+	if (!ctx || !msg)
+		return;
+
+	mutex_lock(&ctx->instance_mutex);
+	list_add_tail(&msg->list, &ctx->msg_q);
+	mutex_unlock(&ctx->instance_mutex);
+}
+
+int alloc_msg_ext_buffer(struct vpu_event_msg *msg, u32 number)
+{
+	WARN_ON(!msg);
+
+	if (!msg || !number)
+		return -EINVAL;
+
+	msg->ext_data = vzalloc(number * sizeof(u32));
+	if (!msg->ext_data)
+		return -ENOMEM;
+	msg->number = number;
+
+	atomic64_add(number, &total_ext_data);
+	vpu_dbg(LVL_DEBUG, "++++alloc %d msg ext data: %lld\n",
+			number, get_total_ext_data_number());
+
+	return 0;
+}
+
+void free_msg_ext_buffer(struct vpu_event_msg *msg)
+{
+	WARN_ON(!msg);
+
+	if (!msg || !msg->ext_data)
+		return;
+
+	atomic64_sub(msg->number, &total_ext_data);
+	vfree(msg->ext_data);
+	msg->ext_data = NULL;
+	vpu_dbg(LVL_DEBUG, "----free %d msg ext data: %lld\n",
+			msg->number, get_total_ext_data_number());
+}
+
+long long get_total_ext_data_number(void)
+{
+	return atomic64_read(&total_ext_data);
+}
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_event_msg.h b/drivers/mxc/vpu-encoder-b0/vpu_event_msg.h
new file mode 100644
index 0000000..cc02956
--- /dev/null
+++ b/drivers/mxc/vpu-encoder-b0/vpu_event_msg.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright(c) 2018 NXP. All rights reserved.
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * vpu_event_msg.h
+ *
+ * Author Ming Qian<ming.qian@nxp.com>
+ */
+#ifndef _VPU_EVENT_MSG_H
+#define _VPU_EVENT_MSG_H
+
+#include "vpu_encoder_config.h"
+
+struct vpu_event_msg {
+	struct list_head list;
+	u32 idx;
+	u32 msgid;
+	u32 number;
+	u32 data[MSG_DATA_DEFAULT_SIZE];
+	u32 *ext_data;
+};
+
+int init_ctx_msg_queue(struct vpu_ctx *ctx);
+void cleanup_ctx_msg_queue(struct vpu_ctx *ctx);
+struct vpu_event_msg *get_idle_msg(struct vpu_ctx *ctx);
+void put_idle_msg(struct vpu_ctx *ctx, struct vpu_event_msg *msg);
+struct vpu_event_msg *pop_event_msg(struct vpu_ctx *ctx);
+void push_back_event_msg(struct vpu_ctx *ctx, struct vpu_event_msg *msg);
+int alloc_msg_ext_buffer(struct vpu_event_msg *msg, u32 number);
+void free_msg_ext_buffer(struct vpu_event_msg *msg);
+long long get_total_ext_data_number(void);
+
+#endif
-- 
1.7.9.5


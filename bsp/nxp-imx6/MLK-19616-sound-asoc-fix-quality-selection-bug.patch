From 889781793a633b78118d148f5340beeca342d7ba Mon Sep 17 00:00:00 2001
From: Cosmin-Gabriel Samoila <cosmin.samoila@nxp.com>
Date: Tue, 18 Sep 2018 16:35:16 +0300
Subject: [PATCH 4684/5242] MLK-19616 sound: asoc: fix quality selection bug
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit  3afb3d9fc6a7588787e002fad9a865607f0c27b1 from
https://source.codeaurora.org/external/imx/linux-imx.git

The quality selection bitfield is represented as following:
 * Medium»      0 0 0
 * High»»       0 0 1
 * Very Low 2»  1 0 0
 * Very Low 1»  1 0 1
 * Very Low 0»  1 1 0
 * Low» »       1 1 1

One might notice that from High to Very Low 2 quality there is
a gap of 2 (010 and 011) are missing. In the previous implementation
of amixer control, when you are selecting other quality than
the default mode, the value will always jump from High to Low
with a 2 step and will not be able to go back to a previous value.
The solution was to add two "N/A" undefined values in the
selection texts since those two values are marked as reserved
in the micfil RM.
The alternative was to write custom get and put functions to
only do the translation but the aproach in this patch is easier
to understand and less error prone.

Signed-off-by: Cosmin-Gabriel Samoila <cosmin.samoila@nxp.com>
Reviewed-by: Daniel Baluta <daniel.baluta@nxp.com>
(cherry picked from commit 976f005b20ddc12c7fe0ce60edd99e5fb9400d21)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_micfil.c |   39 ++-------------------------------------
 1 file changed, 2 insertions(+), 37 deletions(-)

diff --git a/sound/soc/fsl/fsl_micfil.c b/sound/soc/fsl/fsl_micfil.c
index 9c6a4ae..40563d4 100644
--- a/sound/soc/fsl/fsl_micfil.c
+++ b/sound/soc/fsl/fsl_micfil.c
@@ -98,6 +98,7 @@ struct fsl_micfil_soc_data {
  */
 static const char * const micfil_quality_select_texts[] = {
 	"Medium", "High",
+	"N/A", "N/A",
 	"VLow2", "VLow1",
 	"VLow0", "Low",
 };
@@ -145,42 +146,6 @@ struct fsl_micfil_soc_data {
 			micfil_hwvad_noise_decimation),
 };
 
-static int set_quality(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int *item = ucontrol->value.enumerated.item;
-	struct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);
-	int val = snd_soc_enum_item_to_val(e, item[0]);
-	int ret;
-
-	switch (val) {
-	case 0:
-	case 1:
-		micfil->quality = val;
-		break;
-	case 2:
-	case 3:
-	case 4:
-	case 5:
-		micfil->quality = val + 2;
-		break;
-	default:
-		dev_err(comp->dev, "Undefined value %d\n", val);
-		return -EINVAL;
-	}
-
-	ret = snd_soc_component_update_bits(comp,
-					    REG_MICFIL_CTRL2,
-					    MICFIL_CTRL2_QSEL_MASK,
-					    micfil->quality << MICFIL_CTRL2_QSEL_SHIFT);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
 static int hwvad_put_init_mode(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
@@ -548,7 +513,7 @@ static int hwvad_get_zcd_adj(struct snd_kcontrol *kcontrol,
 	SOC_SINGLE_RANGE("CH8 Gain", REG_MICFIL_OUT_CTRL,
 			 MICFIL_OUTGAIN_CHX_SHIFT(7), 0x0, 0xF, 0),
 	SOC_ENUM_EXT("MICFIL Quality Select", fsl_micfil_enum[0],
-		     snd_soc_get_enum_double, set_quality),
+		     snd_soc_get_enum_double, snd_soc_put_enum_double),
 	SOC_ENUM_EXT("HWVAD Initialization Mode", fsl_micfil_enum[1],
 		     hwvad_get_init_mode, hwvad_put_init_mode),
 	SOC_ENUM_EXT("HWVAD High-Pass Filter", fsl_micfil_enum[2],
-- 
1.7.9.5


From 39fa60e3e4590e8a0239d5f39288965833dfce4b Mon Sep 17 00:00:00 2001
From: Bai Ping <ping.bai@nxp.com>
Date: Fri, 14 Sep 2018 17:19:20 +0800
Subject: [PATCH 4656/5242] MLK-19589-01 ARM: imx: add imx6ulz basic support

commit  c5846906daf7680ffdfb7f8a95d49448a52de9f6 from
https://source.codeaurora.org/external/imx/linux-imx.git

The i.MX6ULZ is new SOC of the i.MX6 series. it
is SW compatile with i.MX6ULL, so most of the code
can be reuse from i.MX6ULL. To maximum the SW reuse,
i.MX6ULZ don't have an independent SOC id in anamix.
so a dummy ID is used to identify it.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/anatop.c      |   17 ++++++++++++++++-
 arch/arm/mach-imx/cpu.c         |    6 +++---
 arch/arm/mach-imx/mach-imx6ul.c |    1 +
 arch/arm/mach-imx/mxc.h         |    7 +++++--
 4 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-imx/anatop.c b/arch/arm/mach-imx/anatop.c
index 9a6beb4..e295d55 100644
--- a/arch/arm/mach-imx/anatop.c
+++ b/arch/arm/mach-imx/anatop.c
@@ -207,8 +207,9 @@ void __init imx_init_revision_from_anatop(void)
 {
 	struct device_node *np;
 	void __iomem *anatop_base;
+	void __iomem *src_base;
 	unsigned int revision;
-	u32 digprog;
+	u32 digprog, sbmr2 = 0;
 	u16 offset = ANADIG_DIGPROG;
 	u8 major_part, minor_part;
 
@@ -222,6 +223,20 @@ void __init imx_init_revision_from_anatop(void)
 	digprog = readl_relaxed(anatop_base + offset);
 	iounmap(anatop_base);
 
+	if ((digprog >> 16) == MXC_CPU_IMX6ULL) {
+		np = of_find_compatible_node(NULL, NULL, "fsl,imx6ul-src");
+		if (np) {
+			src_base = of_iomap(np, 0);
+			WARN_ON(!src_base);
+			sbmr2 = readl_relaxed(src_base + 0x1c);
+			iounmap(src_base);
+		}
+		if (sbmr2 & (1 << 6)) {
+			digprog &= ~(0xff << 16);
+			digprog |= (MXC_CPU_IMX6ULZ << 16);
+		}
+	}
+
 	/*
 	 * On i.MX7D digprog value match linux version format, so
 	 * it needn't map again and we can use register value directly.
diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index d8128f73..3fe42e3 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -141,15 +141,15 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6SLL:
 		soc_id = "i.MX6SLL";
 		break;
+	case MXC_CPU_IMX6ULZ:
+		soc_id = "i.MX6ULZ";
+		break;
 	case MXC_CPU_IMX7D:
 		soc_id = "i.MX7D";
 		break;
 	case MXC_CPU_IMX7ULP:
 		soc_id = "i.MX7ULP";
 		break;
-	case MXC_CPU_IMX7ULP:
-		soc_id = "i.MX7ULP";
-		break;
 	default:
 		soc_id = "Unknown";
 	}
diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c
index 851034d..99eb8ad 100644
--- a/arch/arm/mach-imx/mach-imx6ul.c
+++ b/arch/arm/mach-imx/mach-imx6ul.c
@@ -210,6 +210,7 @@ static void __init imx6ul_map_io(void)
 static const char * const imx6ul_dt_compat[] __initconst = {
 	"fsl,imx6ul",
 	"fsl,imx6ull",
+	"fsl,imx6ulz",
 	NULL,
 };
 
diff --git a/arch/arm/mach-imx/mxc.h b/arch/arm/mach-imx/mxc.h
index f162e82..95e7c3e6 100644
--- a/arch/arm/mach-imx/mxc.h
+++ b/arch/arm/mach-imx/mxc.h
@@ -41,6 +41,7 @@
 #define MXC_CPU_IMX6UL		0x64
 #define MXC_CPU_IMX6ULL		0x65
 #define MXC_CPU_IMX6SLL		0x67
+#define MXC_CPU_IMX6ULZ		0x6B
 #define MXC_CPU_IMX7D		0x72
 #define MXC_CPU_IMX7ULP		0xff /* TBD */
 
@@ -84,7 +85,8 @@ static inline bool cpu_is_imx6ul(void)
 
 static inline bool cpu_is_imx6ull(void)
 {
-	return __mxc_cpu_type == MXC_CPU_IMX6ULL;
+	return __mxc_cpu_type == MXC_CPU_IMX6ULL ||
+		__mxc_cpu_type == MXC_CPU_IMX6ULZ;
 }
 
 static inline bool cpu_is_imx6sll(void)
@@ -105,7 +107,8 @@ static inline bool cpu_is_imx6(void)
 		__mxc_cpu_type == MXC_CPU_IMX6SX ||
 		__mxc_cpu_type == MXC_CPU_IMX6UL ||
 		__mxc_cpu_type == MXC_CPU_IMX6ULL ||
-		__mxc_cpu_type == MXC_CPU_IMX6SLL;
+		__mxc_cpu_type == MXC_CPU_IMX6SLL ||
+		__mxc_cpu_type == MXC_CPU_IMX6ULZ;
 }
 
 static inline bool cpu_is_imx7d(void)
-- 
1.7.9.5


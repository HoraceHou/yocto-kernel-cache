From c62fe5d2a89b47de77b1362bf061aff92a44c4a0 Mon Sep 17 00:00:00 2001
From: Zhou Peng <eagle.zhou@nxp.com>
Date: Thu, 17 May 2018 15:01:28 +0800
Subject: [PATCH 3818/5242] MLK-18301-4 - [i.MX8MM/Hantro]: Enable hantro vpu
 on mscale 845S platform

commit  1a0e5c49fad04e53b0ff2c8bc28f173573b9866f from
https://source.codeaurora.org/external/imx/linux-imx.git

h1 encoder code refine

Signed-off-by: Zhou Peng <eagle.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/hantro_845_h1/hx280enc.c |  626 ++++++++++++++--------------------
 1 file changed, 252 insertions(+), 374 deletions(-)

diff --git a/drivers/mxc/hantro_845_h1/hx280enc.c b/drivers/mxc/hantro_845_h1/hx280enc.c
index e824356..7a9d908 100755
--- a/drivers/mxc/hantro_845_h1/hx280enc.c
+++ b/drivers/mxc/hantro_845_h1/hx280enc.c
@@ -1,4 +1,4 @@
-/* 
+/*
  * Encoder device driver (kernel module)
  *
  * Copyright (c) 2013-2017, VeriSilicon Inc.
@@ -28,7 +28,7 @@
 #include <linux/module.h>
 /* needed for __init,__exit directives */
 #include <linux/init.h>
-/* needed for remap_page_range 
+/* needed for remap_page_range
 	SetPageReserved
 	ClearPageReserved
 */
@@ -109,25 +109,24 @@
 #define HX280ENC_BUF_SIZE           0
 
 unsigned long base_port = INTEGRATOR_LOGIC_MODULE0_BASE;
-int irq = VP_PB_INT_LT;
+static int irq = VP_PB_INT_LT;
 
 /* module_param(name, type, perm) */
-module_param(base_port, ulong, 0);
-module_param(irq, int, 0);
+module_param(base_port, ulong, 0644);
+module_param(irq, int, 0644);
 
 /* and this is our MAJOR; use 0 for dynamic allocation (recommended)*/
-static int hx280enc_major = 0;
+static int hx280enc_major;
 
 /* here's all the must remember stuff */
-typedef struct
-{
-    char *buffer;
-    unsigned int buffsize;
-    unsigned long iobaseaddr;
-    unsigned int iosize;
-    volatile u8 *hwregs;
-    unsigned int irq;
-    struct fasync_struct *async_queue;
+typedef struct {
+	char *buffer;
+	unsigned int buffsize;
+	unsigned long iobaseaddr;
+	unsigned int iosize;
+	volatile u8 *hwregs;
+	unsigned int irq;
+	struct fasync_struct *async_queue;
 } hx280enc_t;
 
 /* dynamic allocation? */
@@ -135,59 +134,58 @@
 
 static int ReserveIO(void);
 static void ReleaseIO(void);
-static void ResetAsic(hx280enc_t * dev);
+static void ResetAsic(hx280enc_t *dev);
 
 #ifdef HX280ENC_DEBUG
 static void dump_regs(unsigned long data);
 #endif
 
 /* IRQ handler */
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
 static irqreturn_t hx280enc_isr(int irq, void *dev_id, struct pt_regs *regs);
 #else
 static irqreturn_t hx280enc_isr(int irq, void *dev_id);
 #endif
 
 /* VM operations */
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28))
 static struct page *hx280enc_vm_nopage(struct vm_area_struct *vma,
-                                       unsigned long address, int *type)
+				unsigned long address, int *type)
 {
-    PDEBUG("hx280enc_vm_nopage: problem with mem access\n");
-    return NOPAGE_SIGBUS;   /* send a SIGBUS */
+	PDEBUG("hx280enc_vm_nopage: problem with mem access\n");
+	return NOPAGE_SIGBUS;   /* send a SIGBUS */
 }
 #elif(LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0))
-static int hx280enc_vm_fault(struct vm_area_struct *vma,
-                                      struct vm_fault *vmf)
+static int hx280enc_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
-    PDEBUG("hx280enc_vm_fault: problem with mem access\n");
-    return VM_FAULT_SIGBUS; /* send a SIGBUS */
+	PDEBUG("hx280enc_vm_fault: problem with mem access\n");
+	return VM_FAULT_SIGBUS; /* send a SIGBUS */
 }
 #else
 static int hx280enc_vm_fault(struct vm_fault *vmf)
 {
-    PDEBUG("hx280enc_vm_fault: problem with mem access\n");
-    return VM_FAULT_SIGBUS; /* send a SIGBUS */
+	PDEBUG("hx280enc_vm_fault: problem with mem access\n");
+	return VM_FAULT_SIGBUS; /* send a SIGBUS */
 }
 #endif
 
 static void hx280enc_vm_open(struct vm_area_struct *vma)
 {
-    PDEBUG("hx280enc_vm_open:\n");
+	PDEBUG("hx280enc_vm_open:\n");
 }
 
 static void hx280enc_vm_close(struct vm_area_struct *vma)
 {
-    PDEBUG("hx280enc_vm_close:\n");
+	PDEBUG("hx280enc_vm_close:\n");
 }
 
 static struct vm_operations_struct hx280enc_vm_ops = {
-  open:hx280enc_vm_open,
-  close:hx280enc_vm_close,
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
-  nopage:hx280enc_vm_nopage,
+open:hx280enc_vm_open,
+close:hx280enc_vm_close,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28))
+nopage:hx280enc_vm_nopage,
 #else
-  fault:hx280enc_vm_fault,
+fault:hx280enc_vm_fault,
 #endif
 };
 
@@ -195,86 +193,46 @@ static void hx280enc_vm_close(struct vm_area_struct *vma)
 #ifndef VSI
 static int hantro_h1_clk_enable(struct device *dev)
 {
-#if 0
-	clk_prepare(hantro_clk_g1);
-	clk_enable(hantro_clk_g1);
-	clk_prepare(hantro_clk_g2);
-	clk_enable(hantro_clk_g2);
-	clk_prepare(hantro_clk_bus);
-	clk_enable(hantro_clk_bus);
-#else
 	clk_prepare(hantro_clk_h1);
 	clk_enable(hantro_clk_h1);
 	clk_prepare(hantro_clk_h1_bus);
 	clk_enable(hantro_clk_h1_bus);
-#endif
 	return 0;
 }
 
 static int hantro_h1_clk_disable(struct device *dev)
 {
-#if 0
-
-	if (hantro_clk_g1) {
-		clk_disable(hantro_clk_g1);
-		clk_unprepare(hantro_clk_g1);
+	if (hantro_clk_h1) {
+		clk_disable(hantro_clk_h1);
+		clk_unprepare(hantro_clk_h1);
 	}
-	if (hantro_clk_g2) {
-		clk_disable(hantro_clk_g2);
-		clk_unprepare(hantro_clk_g2);
+	if (hantro_clk_h1_bus) {
+		clk_disable(hantro_clk_h1_bus);
+		clk_unprepare(hantro_clk_h1_bus);
 	}
-	if (hantro_clk_bus) {
-		clk_disable(hantro_clk_bus);
-		clk_unprepare(hantro_clk_bus);
-	}
-#else
-if (hantro_clk_h1) {
-	clk_disable(hantro_clk_h1);
-	clk_unprepare(hantro_clk_h1);
-}
-if (hantro_clk_h1_bus) {
-	clk_disable(hantro_clk_h1_bus);
-	clk_unprepare(hantro_clk_h1_bus);
-}
-#endif
 	return 0;
 }
 
 static int hantro_h1_ctrlblk_reset(struct device *dev)
 {
-#if 0
 	volatile u8 *iobase;
+	u32 val;
 
-	//config G1/G2
-	hantro_clk_enable(dev);
+	//config H1
+	hantro_h1_clk_enable(dev);
 	iobase = (volatile u8 *)ioremap_nocache(BLK_CTL_BASE, 0x10000);
-	iowrite32(0x3, iobase);  //VPUMIX G1/G2 block soft reset  control
-	iowrite32(0x3, iobase+4); //VPUMIX G1/G2 block clock enable control
-	iowrite32(0xFFFFFFFF, iobase + 0x8); // all G1 fuse dec enable
-	iowrite32(0xFFFFFFFF, iobase + 0xC); // all G1 fuse pp enable
-	iowrite32(0xFFFFFFFF, iobase + 0x10); // all G2 fuse dec enable
-	iounmap(iobase);
-	hantro_clk_disable(dev);
-#else
-        volatile u8 *iobase;
-        u32 val;
-
-        //config H1
-        hantro_h1_clk_enable(dev);
-        iobase = (volatile u8 *)ioremap_nocache(BLK_CTL_BASE, 0x10000);
 
-        val=ioread32(iobase);
-        val|=0x4;
-        iowrite32(val, iobase); // release soft reset
+	val = ioread32(iobase);
+	val |= 0x4;
+	iowrite32(val, iobase); // release soft reset
 
-        val=ioread32(iobase+0x4);
-        val|=0x4;
-        iowrite32(val, iobase + 0x4); // enable clock
+	val = ioread32(iobase+0x4);
+	val |= 0x4;
+	iowrite32(val, iobase + 0x4); // enable clock
 
-        iowrite32(0xFFFFFFFF, iobase + 0x14); // H1 fuse encoder enable
-        iounmap(iobase);
-        hantro_h1_clk_disable(dev);
-#endif
+	iowrite32(0xFFFFFFFF, iobase + 0x14); // H1 fuse encoder enable
+	iounmap(iobase);
+	hantro_h1_clk_disable(dev);
 	return 0;
 }
 
@@ -286,108 +244,105 @@ static int hantro_h1_ctrlblk_reset(struct device *dev)
 
 static int hx280enc_mmap(struct file *filp, struct vm_area_struct *vma)
 {
-    int result = -EINVAL;
+	int result = -EINVAL;
 
-    result = -EINVAL;
+	result = -EINVAL;
 
-    vma->vm_ops = &hx280enc_vm_ops;
+	vma->vm_ops = &hx280enc_vm_ops;
 
-    return result;
+	return result;
 }
 
-static long hx280enc_ioctl(struct file *filp,
-                          unsigned int cmd, unsigned long arg)
+static long hx280enc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    int err = 0;
-
-    PDEBUG("ioctl cmd 0x%08ux\n", cmd);
-    /*
-     * extract the type and number bitfields, and don't encode
-     * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
-     */
-    if(_IOC_TYPE(cmd) != HX280ENC_IOC_MAGIC)
-        return -ENOTTY;
-    if(_IOC_NR(cmd) > HX280ENC_IOC_MAXNR)
-        return -ENOTTY;
-
-    /*
-     * the direction is a bitmask, and VERIFY_WRITE catches R/W
-     * transfers. `Type' is user-oriented, while
-     * access_ok is kernel-oriented, so the concept of "read" and
-     * "write" is reversed
-     */
-    if(_IOC_DIR(cmd) & _IOC_READ)
-        err = !access_ok(VERIFY_WRITE, (void *) arg, _IOC_SIZE(cmd));
-    else if(_IOC_DIR(cmd) & _IOC_WRITE)
-        err = !access_ok(VERIFY_READ, (void *) arg, _IOC_SIZE(cmd));
-    if(err)
-        return -EFAULT;
-
-    switch (cmd)
-    {
-    case HX280ENC_IOCGHWOFFSET:
-        __put_user(hx280enc_data.iobaseaddr, (unsigned long *) arg);
-        break;
-
-    case HX280ENC_IOCGHWIOSIZE:
-        __put_user(hx280enc_data.iosize, (unsigned int *) arg);
-        break;
-    }
-    return 0;
+	int err = 0;
+
+	PDEBUG("ioctl cmd 0x%X\n", cmd);
+	/*
+	* extract the type and number bitfields, and don't encode
+	* wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+	*/
+	if (_IOC_TYPE(cmd) != HX280ENC_IOC_MAGIC)
+		return -ENOTTY;
+	if (_IOC_NR(cmd) > HX280ENC_IOC_MAXNR)
+		return -ENOTTY;
+
+	/*
+	* the direction is a bitmask, and VERIFY_WRITE catches R/W
+	* transfers. `Type' is user-oriented, while
+	* access_ok is kernel-oriented, so the concept of "read" and
+	* "write" is reversed
+	*/
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *) arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *) arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
+
+	switch (cmd)	{
+	case HX280ENC_IOCGHWOFFSET:
+		__put_user(hx280enc_data.iobaseaddr, (unsigned long *) arg);
+		break;
+	case HX280ENC_IOCGHWIOSIZE:
+		__put_user(hx280enc_data.iosize, (unsigned int *) arg);
+	break;
+	}
+	return 0;
 }
 
 static int hx280enc_open(struct inode *inode, struct file *filp)
 {
-    int result = 0;
-    hx280enc_t *dev = &hx280enc_data;
+	int result = 0;
+	hx280enc_t *dev = &hx280enc_data;
 
-    filp->private_data = (void *) dev;
+	filp->private_data = (void *) dev;
 
 #ifndef VSI
 	hantro_h1_clk_enable(hantro_h1_dev);
 	pm_runtime_get_sync(hantro_h1_dev);
 #endif
 
-    PDEBUG("dev opened\n");
-    return result;
+	PDEBUG("dev opened\n");
+	return result;
 }
 
 static int hx280enc_fasync(int fd, struct file *filp, int mode)
 {
-    hx280enc_t *dev = (hx280enc_t *) filp->private_data;
+	hx280enc_t *dev = (hx280enc_t *) filp->private_data;
 
-    PDEBUG("fasync called\n");
+	PDEBUG("fasync called\n");
 
-    return fasync_helper(fd, filp, mode, &dev->async_queue);
+	return fasync_helper(fd, filp, mode, &dev->async_queue);
 }
 
 static int hx280enc_release(struct inode *inode, struct file *filp)
 {
 #ifdef HX280ENC_DEBUG
-    hx280enc_t *dev = (hx280enc_t *) filp->private_data;
+	hx280enc_t *dev = (hx280enc_t *) filp->private_data;
 
-    dump_regs((unsigned long) dev); /* dump the regs */
+	dump_regs((unsigned long) dev); /* dump the regs */
 #endif
 
-    /* remove this filp from the asynchronusly notified filp's */
-    hx280enc_fasync(-1, filp, 0);
+	/* remove this filp from the asynchronusly notified filp's */
+	hx280enc_fasync(-1, filp, 0);
 
 #ifndef VSI
 	pm_runtime_put_sync(hantro_h1_dev);
 	hantro_h1_clk_disable(hantro_h1_dev);
 #endif
 
-    PDEBUG("dev closed\n");
-    return 0;
+	PDEBUG("dev closed\n");
+	return 0;
 }
 
 /* VFS methods */
 static struct file_operations hx280enc_fops = {
-  mmap:hx280enc_mmap,
-  open:hx280enc_open,
-  release:hx280enc_release,
-  unlocked_ioctl:hx280enc_ioctl,
-  fasync:hx280enc_fasync,
+mmap:hx280enc_mmap,
+open:hx280enc_open,
+release:hx280enc_release,
+unlocked_ioctl:hx280enc_ioctl,
+fasync:hx280enc_fasync,
 };
 
 #ifndef VSI
@@ -396,74 +351,59 @@ static int hx280enc_init(void)
 static int __init hx280enc_init(void)
 #endif
 {
-    int result;
-
-    PDEBUG(KERN_INFO "hx280enc: module init - base_port=0x%08lx irq=%i\n",
-           base_port, irq);
-
-    hx280enc_data.iobaseaddr = base_port;
-    hx280enc_data.iosize = ENC_IO_SIZE;
-    hx280enc_data.irq = irq;
-    hx280enc_data.async_queue = NULL;
-    hx280enc_data.hwregs = NULL;
-
-    result = register_chrdev(hx280enc_major, "hx280enc", &hx280enc_fops);
-    if(result < 0)
-    {
-        PDEBUG(KERN_INFO "hx280enc: unable to get major <%d>\n",
-               hx280enc_major);
-        return result;
-    }
-    else if(result != 0)    /* this is for dynamic major */
-    {
-        hx280enc_major = result;
-    }
-
-    result = ReserveIO();
-    if(result < 0)
-    {
-        goto err;
-    }
-
-    ResetAsic(&hx280enc_data);  /* reset hardware */
-
-    /* get the IRQ line */
-    if(irq != -1)
-    {
-        result = request_irq(irq, hx280enc_isr,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
-                             SA_INTERRUPT | SA_SHIRQ,
+	int result;
+
+	PDEBUG(KERN_INFO "hx280enc: module init - base_port=0x%08lx irq=%i\n",
+	base_port, irq);
+
+	hx280enc_data.iobaseaddr = base_port;
+	hx280enc_data.iosize = ENC_IO_SIZE;
+	hx280enc_data.irq = irq;
+	hx280enc_data.async_queue = NULL;
+	hx280enc_data.hwregs = NULL;
+
+	result = register_chrdev(hx280enc_major, "hx280enc", &hx280enc_fops);
+	if (result < 0) {
+		PDEBUG(KERN_INFO "hx280enc: unable to get major <%d>\n", hx280enc_major);
+		return result;
+	} else if (result != 0)    /* this is for dynamic major */
+		hx280enc_major = result;
+
+	result = ReserveIO();
+	if (result < 0)
+		goto err;
+
+	ResetAsic(&hx280enc_data);  /* reset hardware */
+
+	/* get the IRQ line */
+	if (irq != -1) {
+		result = request_irq(irq, hx280enc_isr,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+					SA_INTERRUPT | SA_SHIRQ,
 #else
-                             IRQF_DISABLED | IRQF_SHARED,
+					IRQF_DISABLED | IRQF_SHARED,
 #endif
-                             "hx280enc", (void *) &hx280enc_data);
-        if(result == -EINVAL)
-        {
-            PDEBUG(KERN_ERR "hx280enc: Bad irq number or handler\n");
-            ReleaseIO();
-            goto err;
-        }
-        else if(result == -EBUSY)
-        {
-            PDEBUG(KERN_ERR "hx280enc: IRQ <%d> busy, change your config\n",
-                   hx280enc_data.irq);
-            ReleaseIO();
-            goto err;
-        }
-    }
-    else
-    {
-        PDEBUG(KERN_INFO "hx280enc: IRQ not in use!\n");
-    }
-
-    printk(KERN_INFO "hx280enc: module inserted. Major <%d>\n", hx280enc_major);
-
-    return 0;
-
-  err:
-    unregister_chrdev(hx280enc_major, "hx280enc");
-    PDEBUG(KERN_ERR "hx280enc: module not inserted\n");
-    return result;
+					"hx280enc", (void *) &hx280enc_data);
+		if (result == -EINVAL) {
+			PDEBUG(KERN_ERR "hx280enc: Bad irq number or handler\n");
+			ReleaseIO();
+			goto err;
+		} else if (result == -EBUSY) {
+			PDEBUG(KERN_ERR "hx280enc: IRQ <%d> busy, change your config\n",
+			hx280enc_data.irq);
+			ReleaseIO();
+			goto err;
+		}
+	} else
+		PDEBUG(KERN_INFO "hx280enc: IRQ not in use!\n");
+
+	pr_info("hx280enc: module inserted. Major <%d>\n", hx280enc_major);
+	return 0;
+
+err:
+	unregister_chrdev(hx280enc_major, "hx280enc");
+	PDEBUG(KERN_ERR "hx280enc: module not inserted\n");
+	return result;
 }
 
 #ifndef VSI
@@ -472,21 +412,17 @@ static void hx280enc_cleanup(void)
 static void __exit hx280enc_cleanup(void)
 #endif
 {
-    writel(0, hx280enc_data.hwregs + 0x38); /* disable HW */
-    writel(0, hx280enc_data.hwregs + 0x04); /* clear enc IRQ */
-
-    /* free the encoder IRQ */
-    if(hx280enc_data.irq != -1)
-    {
-        free_irq(hx280enc_data.irq, (void *) &hx280enc_data);
-    }
+	writel(0, hx280enc_data.hwregs + 0x38); /* disable HW */
+	writel(0, hx280enc_data.hwregs + 0x04); /* clear enc IRQ */
 
-    ReleaseIO();
+	/* free the encoder IRQ */
+	if (hx280enc_data.irq != -1)
+		free_irq(hx280enc_data.irq, (void *) &hx280enc_data);
 
-    unregister_chrdev(hx280enc_major, "hx280enc");
+	ReleaseIO();
+	unregister_chrdev(hx280enc_major, "hx280enc");
 
-    PDEBUG(KERN_INFO "hx280enc: module removed\n");
-    return;
+	PDEBUG(KERN_INFO "hx280enc: module removed\n");
 }
 
 #ifdef VSI
@@ -495,136 +431,113 @@ static void __exit hx280enc_cleanup(void)
 #endif
 static int ReserveIO(void)
 {
-    long int hwid;
-
-    if(!request_mem_region
-       (hx280enc_data.iobaseaddr, hx280enc_data.iosize, "hx280enc"))
-    {
-        PDEBUG(KERN_INFO "hx280enc: failed to reserve HW regs\n");
-        return -EBUSY;
-    }
-
-    hx280enc_data.hwregs =
-        (volatile u8 *) ioremap_nocache(hx280enc_data.iobaseaddr,
-                                        hx280enc_data.iosize);
+	long int hwid;
 
-    if(hx280enc_data.hwregs == NULL)
-    {
-        PDEBUG(KERN_INFO "hx280enc: failed to ioremap HW regs\n");
-        ReleaseIO();
-        return -EBUSY;
-    }
-
-    hwid = readl(hx280enc_data.hwregs);
+	if (!request_mem_region(hx280enc_data.iobaseaddr, hx280enc_data.iosize, "hx280enc")) {
+		PDEBUG(KERN_INFO "hx280enc: failed to reserve HW regs\n");
+		return -EBUSY;
+	}
+	hx280enc_data.hwregs = (volatile u8 *) ioremap_nocache(hx280enc_data.iobaseaddr, hx280enc_data.iosize);
+	if (hx280enc_data.hwregs == NULL)	{
+		PDEBUG(KERN_INFO "hx280enc: failed to ioremap HW regs\n");
+		ReleaseIO();
+		return -EBUSY;
+	}
 
+	hwid = readl(hx280enc_data.hwregs);
 #if 1
-    /* check for encoder HW ID */
-    if((((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID1 >> 16) & 0xFFFF)) &&
-       (((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID2 >> 16) & 0xFFFF)) &&
-       (((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID3 >> 16) & 0xFFFF)) &&
-       (((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID4 >> 16) & 0xFFFF)) &&
-       (((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID5 >> 16) & 0xFFFF)))
-    {
-        PDEBUG(KERN_ERR "hx280enc: HW not found at 0x%08lx\n",
-               hx280enc_data.iobaseaddr);
+	/* check for encoder HW ID */
+	if ((((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID1 >> 16) & 0xFFFF)) &&
+		(((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID2 >> 16) & 0xFFFF)) &&
+		(((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID3 >> 16) & 0xFFFF)) &&
+		(((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID4 >> 16) & 0xFFFF)) &&
+		(((hwid >> 16) & 0xFFFF) != ((ENC_HW_ID5 >> 16) & 0xFFFF))) {
+		PDEBUG(KERN_ERR "hx280enc: HW not found at 0x%08lx\n", hx280enc_data.iobaseaddr);
 #ifdef HX280ENC_DEBUG
-        dump_regs((unsigned long) &hx280enc_data);
+		dump_regs((unsigned long) &hx280enc_data);
 #endif
-        ReleaseIO();
-        return -EBUSY;
-    }
+		ReleaseIO();
+		return -EBUSY;
+	}
 #endif
-    PDEBUG(KERN_INFO
-           "hx280enc: HW at base <0x%08lx> with ID <0x%08lx>\n",
-           hx280enc_data.iobaseaddr, hwid);
-
-    return 0;
+	PDEBUG(KERN_INFO "hx280enc: HW at base <0x%08lx> with ID <0x%08lx>\n", hx280enc_data.iobaseaddr, hwid);
+	return 0;
 }
 
 static void ReleaseIO(void)
 {
-    if(hx280enc_data.hwregs)
-        iounmap((void *) hx280enc_data.hwregs);
-    release_mem_region(hx280enc_data.iobaseaddr, hx280enc_data.iosize);
+	if (hx280enc_data.hwregs)
+		iounmap((void *) hx280enc_data.hwregs);
+	release_mem_region(hx280enc_data.iobaseaddr, hx280enc_data.iosize);
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
 irqreturn_t hx280enc_isr(int irq, void *dev_id, struct pt_regs *regs)
 #else
 irqreturn_t hx280enc_isr(int irq, void *dev_id)
 #endif
 {
-    hx280enc_t *dev = (hx280enc_t *) dev_id;
-    u32 irq_status;
-    u32 is_write1_clr;
-
-    irq_status = readl(dev->hwregs + 0x04);
-
-    /* BASE_HWFuse2 = 0x4a0; HWCFGIrqClearSupport = 0x00800000 */
-    is_write1_clr = (readl(dev->hwregs + 0x4a0) & 0x00800000);
-
-    if(irq_status & 0x01)
-    {
-
-        /* clear enc IRQ and slice ready interrupt bit */
-        if (is_write1_clr)
-            writel(irq_status & (0x101), dev->hwregs + 0x04);
-        else
-            writel(irq_status & (~0x101), dev->hwregs + 0x04);
-
-        /* Handle slice ready interrupts. The reference implementation
-         * doesn't signal slice ready interrupts to EWL.
-         * The EWL will poll the slices ready register value. */
-        if ((irq_status & 0x1FE) == 0x100)
-        {
-            PDEBUG("Slice ready IRQ handled!\n");
-            return IRQ_HANDLED;
-        }
-
-        /* All other interrupts will be signaled to EWL. */
-        if(dev->async_queue)
-            kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
-        else
-        {
-            PDEBUG(KERN_WARNING
-                   "hx280enc: IRQ received w/o anybody waiting for it!\n");
-        }
-
-        PDEBUG("IRQ handled!\n");
-        return IRQ_HANDLED;
-    }
-    else
-    {
-        PDEBUG("IRQ received, but NOT handled!\n");
-        return IRQ_NONE;
-    }
-
+	hx280enc_t *dev = (hx280enc_t *) dev_id;
+	u32 irq_status;
+	u32 is_write1_clr;
+
+	irq_status = readl(dev->hwregs + 0x04);
+
+	/* BASE_HWFuse2 = 0x4a0; HWCFGIrqClearSupport = 0x00800000 */
+	is_write1_clr = (readl(dev->hwregs + 0x4a0) & 0x00800000);
+
+	if (irq_status & 0x01) {
+		/* clear enc IRQ and slice ready interrupt bit */
+		if (is_write1_clr)
+			writel(irq_status & (0x101), dev->hwregs + 0x04);
+		else
+			writel(irq_status & (~0x101), dev->hwregs + 0x04);
+
+		/* Handle slice ready interrupts. The reference implementation
+		* doesn't signal slice ready interrupts to EWL.
+		* The EWL will poll the slices ready register value. */
+		if ((irq_status & 0x1FE) == 0x100) {
+			PDEBUG("Slice ready IRQ handled!\n");
+			return IRQ_HANDLED;
+		}
+
+		/* All other interrupts will be signaled to EWL. */
+		if (dev->async_queue)
+			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+		else {
+			PDEBUG(KERN_WARNING
+			"hx280enc: IRQ received w/o anybody waiting for it!\n");
+		}
+
+		PDEBUG("IRQ handled!\n");
+		return IRQ_HANDLED;
+	} else {
+		PDEBUG("IRQ received, but NOT handled!\n");
+		return IRQ_NONE;
+	}
 }
 
-static void ResetAsic(hx280enc_t * dev)
+static void ResetAsic(hx280enc_t *dev)
 {
-    int i;
+	int i;
 
-    writel(0, dev->hwregs + 0x38);
+	writel(0, dev->hwregs + 0x38);
+
+	for (i = 4; i < dev->iosize; i += 4)
+		writel(0, dev->hwregs + i);
 
-    for(i = 4; i < dev->iosize; i += 4)
-    {
-        writel(0, dev->hwregs + i);
-    }
 }
 
 #ifdef HX280ENC_DEBUG
 static void dump_regs(unsigned long data)
 {
-    hx280enc_t *dev = (hx280enc_t *) data;
-    int i;
-
-    PDEBUG("Reg Dump Start\n");
-    for(i = 0; i < dev->iosize; i += 4)
-    {
-        PDEBUG("\toffset %02X = %08X\n", i, readl(dev->hwregs + i));
-    }
-    PDEBUG("Reg Dump End\n");
+	hx280enc_t *dev = (hx280enc_t *) data;
+	int i;
+
+	PDEBUG("Reg Dump Start\n");
+	for (i = 0; i < dev->iosize; i += 4)
+		PDEBUG("\toffset %02X = %08X\n", i, readl(dev->hwregs + i));
+	PDEBUG("Reg Dump End\n");
 }
 #endif
 
@@ -651,59 +564,25 @@ static int hantro_h1_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "irq_hantro_h1");
-	if(irq < 0){
+	if (irq < 0) {
 		pr_err("hantro h1: not find valid irq\n");
 		return -ENODEV;
 	}
 
 	hantro_clk_h1 = clk_get(&pdev->dev, "clk_hantro_h1");
 	if (IS_ERR(hantro_clk_h1)) {
-		pr_err("hantro h1: get clock failed, %p \n",hantro_clk_h1);
+		pr_err("hantro h1: get clock failed, %p\n", hantro_clk_h1);
 		err = -ENXIO;
 		goto error;
 	}
 	hantro_clk_h1_bus = clk_get(&pdev->dev, "clk_hantro_h1_bus");
 	if (IS_ERR(hantro_clk_h1_bus)) {
-		pr_err("hantro h1: get bus clock failed, %p \n",hantro_clk_h1_bus);
+		pr_err("hantro h1: get bus clock failed, %p\n", hantro_clk_h1_bus);
 		err = -ENXIO;
 		goto error;
-	}    
+	}
 
-	//pr_debug("hantro: h1 clock: 0x%lX \n", clk_get_rate(hantro_clk_h1));
-#if 0 //eagle for temporary debug on zebu 
-{
-  //set 0x303a00f8 with 0x3fff to power up all the domain 
-  volatile u8* pd_regs;
-  int val1, val2, val3, val4;;
-  //request_mem_region(0x303a00f8, 0x100,"hx280enc");
-
-  pd_regs = (volatile u8 *) ioremap_nocache(0x303A0000, 0x100);
-  printk("power up all domain: set pd_regs(%p) with 0x3fff \n",pd_regs+0xF8);	
-  val1=readl(pd_regs+0xF8);	
-  writel(0x3fff, pd_regs+0xF8);
-  val2=readl(pd_regs+0xF8);
-  printk("%p : old: 0x%X, new: 0x%X \n",pd_regs+0xF8,val1,val2);	
-  //release_mem_region(0x303a00f8, 0x100);
-//1  printk("fill 0xEC with 0x0000ffff \n");
-//1  writel(0x0000ffff,pd_regs+0xEC);
-  iounmap((void *) pd_regs);
-
-
-pd_regs = (volatile u8 *) ioremap_nocache(0x38300000, 0x40000);
-val1=readl(pd_regs);	
-val2=readl(pd_regs+0x10000);
-val3=readl(pd_regs+0x20000);
-val4=readl(pd_regs+0x30000);
-printk("%p : 0x38300000: 0x%X, 0x38310000: 0x%X, 0x38320000: 0x%X, 0x38330000: 0x%X \n",pd_regs,val1,val2,val3,val4); 
-
-printk("H1 fuse enable \n");
-iowrite32(0x4, pd_regs + 0x30000); // release soft reset
-iowrite32(0x4, pd_regs + 0x30004); // enable clock
-iowrite32(0xFFFFFFFF, pd_regs + 0x30014); // H1 fuse encoder enable
-
-iounmap((void *) pd_regs);
-}
-#endif
+	PDEBUG("hantro: h1 clock: 0x%lX, 0x%lX\n", clk_get_rate(hantro_clk_h1), clk_get_rate(hantro_clk_h1_bus));
 
 	hantro_h1_clk_enable(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
@@ -823,6 +702,5 @@ static void __exit hantro_h1_exit(void)
 module_init(hantro_h1_init);
 module_exit(hantro_h1_exit);
 
-
 #endif
 
-- 
1.7.9.5


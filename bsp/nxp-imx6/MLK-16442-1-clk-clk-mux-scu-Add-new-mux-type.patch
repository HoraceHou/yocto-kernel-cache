From 02744891ebfce8e2670e43311e5412d16ec8b3a4 Mon Sep 17 00:00:00 2001
From: Adriana Reus <adriana.reus@nxp.com>
Date: Mon, 11 Sep 2017 10:44:58 +0300
Subject: [PATCH 2592/5242] MLK-16442-1: clk: clk-mux-scu: Add new mux type.

commit  e4aff55805751d552529a16f4568660534ec0036 from
https://source.codeaurora.org/external/imx/linux-imx.git

Display clocks can choose their parrent between various clock sources
(ex pll1, pll2, bypass).

This patch adds a new mux type that uses the underlying support in scfw
to set/get a parent.

(BuildInfo: SCFW 9e9f6ec6, IMX-MKIMAGE 0, ATF 0)

Signed-off-by: Adriana Reus <adriana.reus@nxp.com>
Reviewed by: Ranjani Vaidyanathan <Ranjani.vaidyanathan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/clk/imx/clk-imx8.h    |   13 +++++++
 drivers/clk/imx/clk-mux-scu.c |   79 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 92 insertions(+)

diff --git a/drivers/clk/imx/clk-imx8.h b/drivers/clk/imx/clk-imx8.h
index f191fd4..9459ecf 100644
--- a/drivers/clk/imx/clk-imx8.h
+++ b/drivers/clk/imx/clk-imx8.h
@@ -45,6 +45,10 @@ struct clk *clk_register_mux_gpr_scu(struct device *dev, const char *name,
 		const char **parents, int num_parents, spinlock_t *lock,
 		sc_rsrc_t rsrc_id, sc_ctrl_t gpr_id);
 
+struct clk *clk_register_mux2_scu(struct device *dev, const char *name,
+		const char **parents, int num_parents, unsigned long flags,
+		sc_rsrc_t rsrc_id, sc_pm_clk_t clk_type);
+
 static inline struct clk *imx_clk_fixed(const char *name, int rate)
 {
 	return clk_register_fixed_rate(NULL, name, NULL, 0, rate);
@@ -81,6 +85,15 @@ static inline struct clk *imx_clk_mux_gpr_scu(const char *name, const char **par
 			 &imx_ccm_lock, rsrc_id, gpr_id);
 }
 
+static inline struct clk *imx_clk_mux2_scu(const char *name,
+		const char **parents, int num_parents, sc_rsrc_t rsrc_id,
+		sc_pm_clk_t clk_type)
+{
+	return clk_register_mux2_scu(NULL, name, parents, num_parents,
+				     CLK_SET_RATE_NO_REPARENT, rsrc_id,
+				     clk_type);
+}
+
 static inline void imx_clk_set_rate(struct clk *clk, unsigned long rate)
 {
 	int ret = clk_set_rate(clk, rate);
diff --git a/drivers/clk/imx/clk-mux-scu.c b/drivers/clk/imx/clk-mux-scu.c
index 45a1c95..7c0fe89 100644
--- a/drivers/clk/imx/clk-mux-scu.c
+++ b/drivers/clk/imx/clk-mux-scu.c
@@ -56,8 +56,15 @@ struct clk_mux_gpr_scu {
 	sc_ctrl_t	gpr_id;
 };
 
+struct clk_mux2_scu {
+	struct clk_hw	hw;
+	sc_rsrc_t	rsrc_id;
+	sc_pm_clk_t	clk_type;
+};
+
 #define to_clk_mux_scu(_hw) container_of(_hw, struct clk_mux_scu, hw)
 #define to_clk_mux_gpr_scu(_hw) container_of(_hw, struct clk_mux_gpr_scu, hw)
+#define to_clk_mux2_scu(_hw) container_of(_hw, struct clk_mux2_scu, hw)
 
 /* Get the power domain associated with the clock from the device tree. */
 static void populate_mux_pd(struct clk_mux_scu *clk)
@@ -354,3 +361,75 @@ struct clk *clk_register_mux_gpr_scu(struct device *dev, const char *name,
 
 	return clk;
 }
+
+static u8 clk_mux2_scu_get_parent(struct clk_hw *hw)
+{
+	struct clk_mux2_scu *mux = to_clk_mux2_scu(hw);
+	sc_pm_clk_parent_t parent;
+	sc_err_t ret;
+
+	if (!ccm_ipc_handle)
+		return -EBUSY;
+
+	ret = sc_pm_get_clock_parent(ccm_ipc_handle, mux->rsrc_id,
+				     mux->clk_type, &parent);
+	if (ret != SC_ERR_NONE)
+		return -EINVAL;
+
+	return (u8)parent;
+}
+
+static int clk_mux2_scu_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux2_scu *mux = to_clk_mux2_scu(hw);
+	sc_err_t ret;
+
+	if (!ccm_ipc_handle)
+		return -EBUSY;
+
+	ret = sc_pm_set_clock_parent(ccm_ipc_handle, mux->rsrc_id,
+				     mux->clk_type, index);
+	if (ret != SC_ERR_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct clk_ops clk_mux2_scu_ops = {
+	.get_parent = clk_mux2_scu_get_parent,
+	.set_parent = clk_mux2_scu_set_parent,
+};
+
+
+struct clk *clk_register_mux2_scu(struct device *dev, const char *name,
+				  const char **parents, int num_parents,
+				  unsigned long flags, sc_rsrc_t rsrc_id,
+				  sc_pm_clk_t clk_type)
+{
+	struct clk_mux2_scu *mux;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	if (rsrc_id >= SC_R_LAST)
+		return ERR_PTR(-EINVAL);
+
+	mux = kzalloc(sizeof(struct clk_mux2_scu), GFP_KERNEL);
+	if (!mux)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_mux2_scu_ops;
+	init.parent_names = parents;
+	init.num_parents = num_parents;
+	init.flags = flags;
+
+	mux->hw.init = &init;
+	mux->rsrc_id = rsrc_id;
+	mux->clk_type = clk_type;
+
+	clk = clk_register(NULL, &mux->hw);
+	if (IS_ERR(clk))
+		kfree(mux);
+
+	return clk;
+}
-- 
1.7.9.5


From 8612795a7348d4be06fe6fa146371b68e4e2d239 Mon Sep 17 00:00:00 2001
From: ming_qian <ming.qian@nxp.com>
Date: Mon, 19 Nov 2018 16:53:41 +0800
Subject: [PATCH 5168/5242] MLK-20379:VPU Encoder:periodically check whether
 the instance is hang

commit  0c54e97eea6181931cdb061337405e860878e3b6 from
https://source.codeaurora.org/external/imx/linux-imx.git

1. reset firmware if core is hang the next time you open it.
2. add mb() before rpc_update_cmd_buffer_ptr_encoder

Signed-off-by: ming_qian <ming.qian@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c     |  410 ++++++++++++++++++++---
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h     |    8 +
 drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h |    4 +-
 drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c    |    2 +
 drivers/mxc/vpu-encoder-b0/vpu_event_msg.c      |    1 -
 5 files changed, 370 insertions(+), 55 deletions(-)

diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index 62f50d1..a5e3a40 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -62,6 +62,7 @@ struct vpu_frame_info {
 };
 
 unsigned int vpu_dbg_level_encoder = LVL_WARN;
+static unsigned int reset_on_hang;
 
 static char *mu_cmp[] = {
 	"fsl,imx8-mu1-vpu-m0",
@@ -104,6 +105,11 @@ struct vpu_frame_info {
 	ITEM_NAME(VID_API_ENC_EVENT_RESERVED)
 };
 
+static int wait_for_start_done(struct core_device *core, int resume);
+static void wait_for_stop_done(struct vpu_ctx *ctx);
+static int sw_reset_firmware(struct core_device *core, int resume);
+static void reset_fw_statistic(struct vpu_attr *attr);
+
 static char *get_event_str(u32 event)
 {
 	if (event >= VID_API_ENC_EVENT_RESERVED)
@@ -1155,18 +1161,6 @@ static int request_eos(struct vpu_ctx *ctx)
 	return 0;
 }
 
-static void clear_ctx_hang_status(struct vpu_ctx *ctx)
-{
-	if (test_bit(VPU_ENC_STATUS_STOP_DONE, &ctx->status))
-		clear_bit(VPU_ENC_STATUS_HANG, &ctx->status);
-}
-
-static bool is_ctx_hang(struct vpu_ctx *ctx)
-{
-	clear_ctx_hang_status(ctx);
-	return test_bit(VPU_ENC_STATUS_HANG, &ctx->status);
-}
-
 static int set_core_force_release(struct core_device *core)
 {
 	int i;
@@ -1183,11 +1177,47 @@ static int set_core_force_release(struct core_device *core)
 	return 0;
 }
 
+static void clear_start_status(struct vpu_ctx *ctx)
+{
+	if (!ctx)
+		return;
+
+	clear_bit(VPU_ENC_STATUS_CONFIGURED, &ctx->status);
+	clear_bit(VPU_ENC_STATUS_START_SEND, &ctx->status);
+	clear_bit(VPU_ENC_STATUS_START_DONE, &ctx->status);
+}
+
+static void clear_stop_status(struct vpu_ctx *ctx)
+{
+	if (!ctx)
+		return;
+
+	clear_bit(VPU_ENC_STATUS_STOP_REQ, &ctx->status);
+	clear_bit(VPU_ENC_STATUS_STOP_SEND, &ctx->status);
+	clear_bit(VPU_ENC_STATUS_STOP_DONE, &ctx->status);
+	clear_bit(VPU_ENC_STATUS_EOS_SEND, &ctx->status);
+}
+
+static void reset_core_on_hang(struct core_device *core)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < core->supported_instance_count; i++)
+		clear_start_status(core->ctx[i]);
+
+	ret = sw_reset_firmware(core, 1);
+	if (ret)
+		vpu_err("reset core[%d] on hang fail\n", core->id);
+}
+
 static int set_core_hang(struct core_device *core)
 {
-	set_core_force_release(core);
 	core->hang = true;
 
+	if (reset_on_hang)
+		reset_core_on_hang(core);
+
 	return 0;
 }
 
@@ -1203,16 +1233,12 @@ static void wait_for_stop_done(struct vpu_ctx *ctx)
 {
 	WARN_ON(!ctx);
 
-	if (is_ctx_hang(ctx))
-		return;
 	if (!test_bit(VPU_ENC_STATUS_START_SEND, &ctx->status))
 		return;
 	if (test_bit(VPU_ENC_STATUS_STOP_DONE, &ctx->status))
 		return;
 
 	wait_for_completion_timeout(&ctx->stop_cmp, msecs_to_jiffies(500));
-	if (!test_bit(VPU_ENC_STATUS_STOP_DONE, &ctx->status))
-		set_bit(VPU_ENC_STATUS_HANG, &ctx->status);
 }
 
 static int v4l2_ioctl_encoder_cmd(struct file *file,
@@ -1265,11 +1291,9 @@ static int v4l2_ioctl_streamon(struct file *file,
 	}
 
 	ret = vb2_streamon(&q_data->vb2_q, i);
-	if (!ret && i == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
-		clear_bit(VPU_ENC_STATUS_STOP_SEND, &ctx->status);
-		clear_bit(VPU_ENC_STATUS_STOP_DONE, &ctx->status);
-		clear_bit(VPU_ENC_STATUS_EOS_SEND, &ctx->status);
-	}
+	if (!ret && i == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		clear_stop_status(ctx);
+
 	return ret;
 }
 
@@ -1349,18 +1373,22 @@ static void vpu_ctx_send_cmd(struct vpu_ctx *ctx, uint32_t cmdid,
 				cmdid, cmdnum, local_cmddata);
 }
 
+static void set_core_fw_status(struct core_device *core, bool status)
+{
+	core->fw_is_ready = status;
+}
+
 static int reset_vpu_core_dev(struct core_device *core_dev)
 {
 	if (!core_dev)
 		return -EINVAL;
 
-	core_dev->fw_is_ready = false;
+	set_core_fw_status(core_dev, false);
 	core_dev->firmware_started = false;
 
 	return 0;
 }
 
-static int wait_for_start_done(struct core_device *core, int resume);
 static int sw_reset_firmware(struct core_device *core, int resume)
 {
 	int ret = 0;
@@ -1376,6 +1404,7 @@ static int sw_reset_firmware(struct core_device *core, int resume)
 		set_core_hang(core);
 		return -EINVAL;
 	}
+	core->reset_times++;
 
 	return 0;
 }
@@ -1383,10 +1412,20 @@ static int sw_reset_firmware(struct core_device *core, int resume)
 static int process_core_hang(struct core_device *core)
 {
 	int ret;
+	int i;
+	int instance_count = 0;
 
 	if (!core->hang)
 		return 0;
 
+	for (i = 0; i < core->supported_instance_count; i++) {
+		if (core->ctx[i])
+			instance_count++;
+	}
+
+	if (instance_count)
+		return -EBUSY;
+
 	ret = sw_reset_firmware(core, 0);
 	if (ret)
 		return ret;
@@ -1461,7 +1500,8 @@ static void show_firmware_version(struct core_device *core_dev,
 
 	pSharedInterface = core_dev->shared_mem.pSharedInterface;
 
-	vpu_dbg(level, "vpu encoder firmware version is %d.%d.%d\n",
+	vpu_dbg(level, "vpu encoder core[%d] firmware version is %d.%d.%d\n",
+			core_dev->id,
 			(pSharedInterface->FWVersion & 0x00ff0000) >> 16,
 			(pSharedInterface->FWVersion & 0x0000ff00) >> 8,
 			pSharedInterface->FWVersion & 0x000000ff);
@@ -1624,6 +1664,7 @@ static int do_configure_codec(struct vpu_ctx *ctx)
 	pEncExpertModeParam->Calib.cb_size = ctx->encoder_stream.size;
 
 	show_firmware_version(ctx->core_dev, LVL_INFO);
+	reset_fw_statistic(attr);
 	memcpy(enc_param, &attr->param, sizeof(attr->param));
 	vpu_ctx_send_cmd(ctx, GTB_ENC_CMD_CONFIGURE_CODEC, 0, NULL);
 	vpu_dbg(LVL_INFO, "send command GTB_ENC_CMD_CONFIGURE_CODEC\n");
@@ -2102,6 +2143,8 @@ static int submit_input_and_encode(struct vpu_ctx *ctx)
 
 	if (test_bit(VPU_ENC_STATUS_STOP_SEND, &ctx->status))
 		goto exit;
+	if (!test_bit(VPU_ENC_STATUS_START_DONE, &ctx->status))
+		goto exit;
 
 	if (update_yuv_addr(ctx)) {
 		vpu_ctx_send_cmd(ctx, GTB_ENC_CMD_FRAME_ENCODE, 0, NULL);
@@ -2424,12 +2467,9 @@ static int handle_event_stop_done(struct vpu_ctx *ctx)
 
 	process_stream_output(ctx);
 
+	clear_start_status(ctx);
 	complete(&ctx->stop_cmp);
 
-	clear_bit(VPU_ENC_STATUS_CONFIGURED, &ctx->status);
-	clear_bit(VPU_ENC_STATUS_START_SEND, &ctx->status);
-	clear_bit(VPU_ENC_STATUS_START_DONE, &ctx->status);
-
 	return 0;
 }
 
@@ -2574,6 +2614,8 @@ static void vpu_core_start_done(struct core_device *core)
 	get_core_supported_instance_count(core);
 	core->firmware_started = true;
 	complete(&core->start_cmp);
+
+	show_firmware_version(core, LVL_ALL);
 }
 
 //This code is added for MU
@@ -3132,9 +3174,8 @@ static int download_vpu_firmware(struct vpu_dev *dev,
 		goto exit;
 	}
 
-	core_dev->fw_is_ready = true;
+	set_core_fw_status(core_dev, true);
 	clear_core_hang(core_dev);
-	show_firmware_version(core_dev, LVL_ALL);
 exit:
 	return ret;
 }
@@ -3185,7 +3226,9 @@ static struct core_device *find_proper_core(struct vpu_dev *dev)
 	for (i = 0; i < dev->core_num; i++) {
 		struct core_device *core_dev = &dev->core_dev[i];
 
-		process_core_hang(core_dev);
+		ret = process_core_hang(core_dev);
+		if (ret)
+			continue;
 
 		ret = download_vpu_firmware(dev, core_dev);
 		if (ret)
@@ -3307,18 +3350,23 @@ static void uninit_vpu_ctx_fh(struct vpu_ctx *ctx)
 	mutex_unlock(&ctx->instance_mutex);
 }
 
+static void cancel_vpu_ctx(struct vpu_ctx *ctx)
+{
+	cancel_work_sync(&ctx->instance_work);
+	cleanup_ctx_msg_queue(ctx);
+}
+
 static void uninit_vpu_ctx(struct vpu_ctx *ctx)
 {
 	if (!ctx)
 		return;
 
 	clear_bit(VPU_ENC_STATUS_INITIALIZED, &ctx->status);
+	cancel_vpu_ctx(ctx);
 	if (ctx->instance_wq) {
-		cancel_work_sync(&ctx->instance_work);
 		destroy_workqueue(ctx->instance_wq);
 		ctx->instance_wq = NULL;
 	}
-	cleanup_ctx_msg_queue(ctx);
 	mutex_lock(&ctx->instance_mutex);
 	free_encoder_stream(ctx);
 
@@ -3347,12 +3395,27 @@ static int init_vpu_ctx(struct vpu_ctx *ctx)
 	return 0;
 }
 
+static int show_queue_buffer_info(struct queue_data *queue, char *buf, u32 size)
+{
+	int i;
+	int num = 0;
+
+	for (i = 0; i < queue->vb2_q.num_buffers; i++) {
+		struct vb2_buffer *vb = queue->vb2_q.bufs[i];
+
+		num += snprintf(buf + num, size - num, " %d", vb->state);
+	}
+
+	return num;
+}
+
 static ssize_t show_instance_info(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
 	struct vpu_attr *vpu_attr;
 	struct vpu_dev *vpudev;
 	struct vpu_statistic *statistic;
+	struct vpu_ctx *ctx;
 	pMEDIAIP_ENC_PARAM param;
 	int i;
 	int num = 0;
@@ -3496,6 +3559,24 @@ static ssize_t show_instance_info(struct device *dev,
 	num += snprintf(buf + num, PAGE_SIZE - num,
 			"total msg ext data count:%lld\n",
 			get_total_ext_data_number());
+	mutex_lock(&vpudev->dev_mutex);
+	ctx = get_vpu_attr_ctx(vpu_attr);
+	if (ctx) {
+		num += snprintf(buf + num, PAGE_SIZE - num, "OUTPUT:");
+		num += show_queue_buffer_info(&ctx->q_data[V4L2_SRC],
+						buf + num, PAGE_SIZE - num);
+		num += snprintf(buf + num, PAGE_SIZE - num, "    CAPTURE:");
+		num += show_queue_buffer_info(&ctx->q_data[V4L2_DST],
+						buf + num, PAGE_SIZE - num);
+		num += snprintf(buf + num, PAGE_SIZE - num, "\n");
+		num += snprintf(buf + num, PAGE_SIZE - num,
+				"frozen count:%d\n", ctx->frozen_count);
+		num += snprintf(buf + num, PAGE_SIZE - num,
+				"status:0x%lx\n", ctx->status);
+		if (test_bit(VPU_ENC_STATUS_HANG, &ctx->status))
+			num += snprintf(buf + num, PAGE_SIZE - num, "<hang>\n");
+	}
+	mutex_unlock(&vpudev->dev_mutex);
 	if (!vpu_attr->core->ctx[vpu_attr->index])
 		num += snprintf(buf + num, PAGE_SIZE - num,
 			"<instance has been released>\n");
@@ -3545,6 +3626,10 @@ static ssize_t show_core_info(struct device *dev,
 			"firmware_started:%d\n", core->firmware_started);
 	num += snprintf(buf + num, PAGE_SIZE - num,
 			"hang            :%d\n", core->hang);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			"reset times     :%ld\n", core->reset_times);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			"heartbeat       :%02x\n", core->vdev->heartbeat);
 	if (core->fw_is_ready) {
 		pENC_RPC_HOST_IFACE iface = core->shared_mem.pSharedInterface;
 
@@ -3593,12 +3678,100 @@ static ssize_t show_memory_info(struct device *dev,
 }
 DEVICE_ATTR(meminfo, 0444, show_memory_info, NULL);
 
+static ssize_t show_buffer_info(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct vpu_dev *vdev = dev_get_drvdata(dev);
+	int num = 0;
+	int i;
+	int j;
+
+	mutex_lock(&vdev->dev_mutex);
+	num += snprintf(buf + num, PAGE_SIZE - num, "vpu encoder buffers:\t");
+	num += snprintf(buf + num, PAGE_SIZE - num, "(");
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:dequeued,", VB2_BUF_STATE_DEQUEUED);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:preparing,", VB2_BUF_STATE_PREPARING);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:prepared,", VB2_BUF_STATE_PREPARED);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:queued,", VB2_BUF_STATE_QUEUED);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:requeueing,", VB2_BUF_STATE_REQUEUEING);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:active,", VB2_BUF_STATE_ACTIVE);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:done,", VB2_BUF_STATE_DONE);
+	num += snprintf(buf + num, PAGE_SIZE - num,
+			" %d:error", VB2_BUF_STATE_ERROR);
+	num += snprintf(buf + num, PAGE_SIZE - num, ")\n");
+
+	for (i = 0; i < vdev->core_num; i++) {
+		struct core_device *core = &vdev->core_dev[i];
+
+		if (!core->supported_instance_count)
+			continue;
+
+		num += snprintf(buf + num, PAGE_SIZE - num, "core[%d]\n", i);
+		for (j = 0; j < core->supported_instance_count; j++) {
+			struct vpu_ctx *ctx = core->ctx[j];
+
+			if (!ctx)
+				continue;
+			num += snprintf(buf + num, PAGE_SIZE - num,
+					"\t[%d]: ", j);
+			num += snprintf(buf + num,
+					PAGE_SIZE - num, "OUTPUT:");
+			num += show_queue_buffer_info(&ctx->q_data[V4L2_SRC],
+							buf + num,
+							PAGE_SIZE - num);
+			num += snprintf(buf + num,
+					PAGE_SIZE - num, "    CAPTURE:");
+			num += show_queue_buffer_info(&ctx->q_data[V4L2_DST],
+							buf + num,
+							PAGE_SIZE - num);
+			num += snprintf(buf + num, PAGE_SIZE - num, "\n");
+		}
+	}
+	mutex_unlock(&vdev->dev_mutex);
+
+	return num;
+}
+DEVICE_ATTR(buffer, 0444, show_buffer_info, NULL);
+
+static void reset_fw_statistic(struct vpu_attr *attr)
+{
+	int i;
+
+	if (!attr)
+		return;
+
+	for (i = 0; i <= GTB_ENC_CMD_RESERVED; i++) {
+		if (i == GTB_ENC_CMD_FIRM_RESET)
+			continue;
+		attr->statistic.cmd[i] = 0;
+	}
+	for (i = 0; i <= VID_API_ENC_EVENT_RESERVED; i++)
+		attr->statistic.event[i] = 0;
+	attr->statistic.current_cmd = GTB_ENC_CMD_NOOP;
+	attr->statistic.current_event = VID_API_EVENT_UNDEFINED;
+}
+
+static void reset_statistic(struct vpu_attr *attr)
+{
+	if (!attr)
+		return;
+
+	memset(&attr->statistic, 0, sizeof(attr->statistic));
+}
+
 static int init_vpu_attr(struct vpu_attr *attr)
 {
 	if (!attr || !attr->core)
 		return -EINVAL;
 
-	memset(&attr->statistic, 0, sizeof(attr->statistic));
+	reset_statistic(attr);
 	memset(&attr->param, 0, sizeof(attr->param));
 	attr->pid = current->pid;
 	attr->tgid = current->tgid;
@@ -3617,14 +3790,12 @@ static int release_instance(struct vpu_ctx *ctx)
 	if (!ctx || !ctx->dev)
 		return -EINVAL;
 
+	if (!test_bit(VPU_ENC_STATUS_CLOSED, &ctx->status))
+		return 0;
 	if (!test_bit(VPU_ENC_STATUS_FORCE_RELEASE, &ctx->status)) {
-		if (!test_bit(VPU_ENC_STATUS_CLOSED, &ctx->status))
-			return 0;
 		if (test_bit(VPU_ENC_STATUS_START_SEND, &ctx->status) &&
 			!test_bit(VPU_ENC_STATUS_STOP_DONE, &ctx->status))
 			return -EINVAL;
-		if (is_ctx_hang(ctx))
-			return -EINVAL;
 	}
 
 	dev = ctx->dev;
@@ -3652,6 +3823,8 @@ static int try_to_release_idle_instance(struct vpu_dev *dev)
 		return -EINVAL;
 
 	for (i = 0; i < dev->core_num; i++) {
+		if (dev->core_dev[i].hang)
+			set_core_force_release(&dev->core_dev[i]);
 		for (j = 0; j < dev->core_dev[i].supported_instance_count; j++)
 			release_instance(dev->core_dev[i].ctx[j]);
 	}
@@ -3669,6 +3842,16 @@ struct vpu_attr *get_vpu_ctx_attr(struct vpu_ctx *ctx)
 	return &ctx->core_dev->attr[ctx->str_index];
 }
 
+struct vpu_ctx *get_vpu_attr_ctx(struct vpu_attr *attr)
+{
+	WARN_ON(!attr || !attr->core);
+
+	if (attr->index >= attr->core->supported_instance_count)
+		return NULL;
+
+	return attr->core->ctx[attr->index];
+}
+
 static int vpu_enc_v4l2_open(struct file *filp)
 {
 	struct video_device *vdev = video_devdata(filp);
@@ -4078,6 +4261,118 @@ static int release_vpu_attrs(struct core_device *core)
 	return 0;
 }
 
+static int is_ctx_frozen(struct vpu_ctx *ctx)
+{
+	int is_frozen = 1;
+	int i;
+	struct vpu_attr *attr = get_vpu_ctx_attr(ctx);
+
+	for (i = 0; i < GTB_ENC_CMD_RESERVED; i++) {
+		if (attr->statistic.cmd[i] != ctx->sts.cmd[i])
+			is_frozen = 0;
+		ctx->sts.cmd[i] = attr->statistic.cmd[i];
+	}
+
+	for (i = 0; i < VID_API_ENC_EVENT_RESERVED; i++) {
+		if (attr->statistic.event[i] != ctx->sts.event[i])
+			is_frozen = 0;
+		ctx->sts.event[i] = attr->statistic.event[i];
+	}
+
+	if (ctx->sts.cmd[GTB_ENC_CMD_FRAME_ENCODE] ==
+			ctx->sts.event[VID_API_ENC_EVENT_FRAME_DONE])
+		is_frozen = 0;
+
+	if (ctx->sts.cmd[GTB_ENC_CMD_CONFIGURE_CODEC] >
+			ctx->sts.event[VID_API_ENC_EVENT_MEM_REQUEST])
+		is_frozen = 1;
+	if (ctx->sts.cmd[GTB_ENC_CMD_STREAM_START] >
+			ctx->sts.event[VID_API_ENC_EVENT_START_DONE])
+		is_frozen = 1;
+	if (ctx->sts.cmd[GTB_ENC_CMD_STREAM_STOP] >
+			ctx->sts.event[VID_API_ENC_EVENT_STOP_DONE])
+		is_frozen = 1;
+
+	return is_frozen;
+}
+
+static bool check_vpu_ctx_is_hang(struct vpu_ctx *ctx)
+{
+	if (is_ctx_frozen(ctx))
+		ctx->frozen_count++;
+	else
+		ctx->frozen_count = 0;
+
+	if (ctx->frozen_count > VPU_ENC_HANG_THD) {
+		set_bit(VPU_ENC_STATUS_HANG, &ctx->status);
+		ctx->frozen_count = VPU_ENC_HANG_THD;
+	} else if (ctx->frozen_count == 0) {
+		clear_bit(VPU_ENC_STATUS_HANG, &ctx->status);
+	}
+
+	if (test_bit(VPU_ENC_STATUS_HANG, &ctx->status))
+		return true;
+
+	return false;
+}
+
+static void check_vpu_core_is_hang(struct core_device *core)
+{
+	int i;
+	unsigned int instance_count = 0;
+	unsigned int hang_count = 0;
+
+	for (i = 0; i < core->supported_instance_count; i++) {
+		if (!core->ctx[i])
+			continue;
+
+		if (check_vpu_ctx_is_hang(core->ctx[i]))
+			hang_count++;
+		instance_count++;
+	}
+
+	if (!instance_count)
+		return;
+	if (hang_count == instance_count)
+		set_core_hang(core);
+	else
+		clear_core_hang(core);
+}
+
+static void handle_vpu_core_watchdog(struct core_device *core)
+{
+	if (!core->fw_is_ready)
+		return;
+	if (core->suspend)
+		return;
+	if (core->snapshot)
+		return;
+
+	check_vpu_core_is_hang(core);
+}
+
+static void vpu_watchdog_handler(struct work_struct *work)
+{
+	struct delayed_work *dwork;
+	struct vpu_dev *vdev;
+	int i;
+
+	if (!work)
+		return;
+
+	dwork = to_delayed_work(work);
+	vdev = container_of(dwork, struct vpu_dev, watchdog);
+
+	mutex_lock(&vdev->dev_mutex);
+	for (i = 0; i < vdev->core_num; i++)
+		handle_vpu_core_watchdog(&vdev->core_dev[i]);
+	vdev->heartbeat++;
+	mutex_unlock(&vdev->dev_mutex);
+
+	schedule_delayed_work(&vdev->watchdog,
+			msecs_to_jiffies(VPU_WATCHDOG_INTERVAL_MS));
+}
+
 static int init_vpu_core_dev(struct core_device *core_dev)
 {
 	int ret;
@@ -4177,6 +4472,16 @@ static int uninit_vpu_core_dev(struct core_device *core_dev)
 	return 0;
 }
 
+static void init_vpu_watchdog(struct vpu_dev *vdev)
+{
+	if (!vdev)
+		return;
+
+	INIT_DELAYED_WORK(&vdev->watchdog, vpu_watchdog_handler);
+	schedule_delayed_work(&vdev->watchdog,
+			msecs_to_jiffies(VPU_WATCHDOG_INTERVAL_MS));
+}
+
 static int vpu_probe(struct platform_device *pdev)
 {
 	struct vpu_dev *dev;
@@ -4242,7 +4547,6 @@ static int vpu_probe(struct platform_device *pdev)
 	vpu_enable_hw(dev);
 
 	mutex_init(&dev->dev_mutex);
-	mutex_lock(&dev->dev_mutex);
 	for (i = 0; i < dev->core_num; i++) {
 		dev->core_dev[i].id = i;
 		dev->core_dev[i].generic_dev = get_device(dev->generic_dev);
@@ -4251,19 +4555,18 @@ static int vpu_probe(struct platform_device *pdev)
 		if (ret)
 			goto error_init_core;
 	}
-	mutex_unlock(&dev->dev_mutex);
 	pm_runtime_put_sync(&pdev->dev);
 
 	device_create_file(&pdev->dev, &dev_attr_meminfo);
+	device_create_file(&pdev->dev, &dev_attr_buffer);
+	init_vpu_watchdog(dev);
 	vpu_dbg(LVL_ALL, "VPU Encoder registered\n");
 
 	return 0;
 
 error_init_core:
-	mutex_lock(&dev->dev_mutex);
 	for (i = 0; i < dev->core_num; i++)
 		uninit_vpu_core_dev(&dev->core_dev[i]);
-	mutex_unlock(&dev->dev_mutex);
 
 	pm_runtime_put_sync(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -4291,11 +4594,11 @@ static int vpu_remove(struct platform_device *pdev)
 	struct vpu_dev *dev = platform_get_drvdata(pdev);
 	u_int32 i;
 
+	cancel_delayed_work_sync(&dev->watchdog);
+	device_remove_file(&pdev->dev, &dev_attr_buffer);
 	device_remove_file(&pdev->dev, &dev_attr_meminfo);
-	mutex_lock(&dev->dev_mutex);
 	for (i = 0; i < dev->core_num; i++)
 		uninit_vpu_core_dev(&dev->core_dev[i]);
-	mutex_unlock(&dev->dev_mutex);
 
 	vpu_disable_hw(dev);
 	pm_runtime_disable(&pdev->dev);
@@ -4309,6 +4612,8 @@ static int vpu_remove(struct platform_device *pdev)
 		dev->generic_dev = NULL;
 	}
 
+	vpu_dbg(LVL_ALL, "VPU Encoder removed\n");
+
 	return 0;
 }
 
@@ -4334,8 +4639,6 @@ static int is_core_activated(struct core_device *core)
 
 static int is_need_shapshot(struct vpu_ctx *ctx)
 {
-	if (is_ctx_hang(ctx))
-		return 0;
 	if (!test_bit(VPU_ENC_STATUS_INITIALIZED, &ctx->status))
 		return 0;
 	if (!test_bit(VPU_ENC_STATUS_CONFIGURED, &ctx->status))
@@ -4361,12 +4664,10 @@ static int vpu_snapshot(struct vpu_ctx *ctx)
 	vpu_ctx_send_cmd(ctx, GTB_ENC_CMD_SNAPSHOT, 0, NULL);
 	ret = wait_for_completion_timeout(&ctx->core_dev->snap_done_cmp,
 						msecs_to_jiffies(1000));
-	if (!ret) {
+	if (!ret)
 		vpu_err("error:wait for snapdone event timeout!\n");
-		return -EINVAL;
-	}
-
-	ctx->core_dev->snapshot = true;
+	else
+		ctx->core_dev->snapshot = true;
 
 	return 0;
 }
@@ -4579,5 +4880,8 @@ static int vpu_enc_resume(struct device *dev)
 MODULE_LICENSE("GPL");
 
 module_param(vpu_dbg_level_encoder, int, 0644);
-MODULE_PARM_DESC(vpu_dbg_level_encoder, "Debug level (0-2)");
+MODULE_PARM_DESC(vpu_dbg_level_encoder, "Debug level (0-4)");
+
+module_param(reset_on_hang, int, 0644);
+MODULE_PARM_DESC(reset_on_hang, "reset on hang (0-1)");
 
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
index b065078..11209ae 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
@@ -268,6 +268,7 @@ struct core_device {
 	bool hang;
 	struct device_attribute core_attr;
 	char name[64];
+	unsigned long reset_times;
 };
 
 struct vpu_dev {
@@ -283,6 +284,9 @@ struct vpu_dev {
 	u_int32 plat_type;
 	u_int32 core_num;
 	bool hw_enable;
+
+	struct delayed_work watchdog;
+	u8 heartbeat;
 };
 
 struct buffer_addr {
@@ -333,6 +337,9 @@ struct vpu_ctx {
 
 	struct list_head msg_q;
 	struct list_head idle_q;
+
+	struct vpu_statistic sts;
+	unsigned int frozen_count;
 };
 
 #define LVL_DEBUG	4
@@ -355,5 +362,6 @@ struct vpu_ctx {
 #define vpu_err(fmt, arg...)	vpu_dbg(LVL_ERR, fmt, ##arg)
 
 struct vpu_attr *get_vpu_ctx_attr(struct vpu_ctx *ctx);
+struct vpu_ctx *get_vpu_attr_ctx(struct vpu_attr *attr);
 
 #endif
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h
index bbca6e8..7d2dc1d 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_config.h
@@ -31,7 +31,9 @@
 #define VPU_STRM_END_PATTERN		{0x0, 0x0, 0x1, 0xb}
 
 #define MSG_DATA_DEFAULT_SIZE		256
-#define MSG_DEFAULT_COUNT		4
 #define MSG_COUNT_THD			16
 
+#define VPU_WATCHDOG_INTERVAL_MS	1000
+#define VPU_ENC_HANG_THD		15
+
 #endif
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c
index ecd9e9b..f670a94 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_rpc.c
@@ -212,6 +212,8 @@ static void rpc_update_cmd_buffer_ptr_encoder(BUFFER_DESCRIPTOR_TYPE *pCmdDesc)
 {
 	u_int32 uWritePtr;
 
+	/*avoid sw reset fail*/
+	mb();
 	uWritePtr = pCmdDesc->wptr + 4;
 	if (uWritePtr >= pCmdDesc->end)
 		uWritePtr = pCmdDesc->start;
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c b/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c
index d62af1e..4768dc7 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_event_msg.c
@@ -121,7 +121,6 @@ int init_ctx_msg_queue(struct vpu_ctx *ctx)
 	set_msg_count(ctx, 0);
 	INIT_LIST_HEAD(&ctx->msg_q);
 	INIT_LIST_HEAD(&ctx->idle_q);
-	increase_idle_msg(ctx, MSG_DEFAULT_COUNT);
 
 	mutex_unlock(&ctx->instance_mutex);
 
-- 
1.7.9.5


From 338f3cb119236ae28fe1fe53cc9f2e84945165ff Mon Sep 17 00:00:00 2001
From: Zhou Peng-B04994 <eagle.zhou@nxp.com>
Date: Fri, 20 Oct 2017 13:06:34 +0800
Subject: [PATCH 2674/5242] MLK-16671-1 - [i.MX8QXP/Malone]: Add vpu malone
 decoder driver

commit  9e15be7678dec74f34002082c25ab195206280ea from
https://source.codeaurora.org/external/imx/linux-imx.git

Integrate amphion release kernel functions

Signed-off-by: Zhou Peng-B04994 <eagle.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-malone/Kconfig                     |   20 +
 drivers/mxc/vpu-malone/Makefile                    |  197 ++
 .../DecKLib/Control/DecKernelLibHWControl.c        |  326 ++++
 .../DecKLib/Control/DecKernelLibHWControl.h        |  175 ++
 .../DecKLib/Control/DecKernelLibHWIsr.c            |  467 +++++
 .../Malone_Firmware/DecKLib/Incl/DecKernelLib.h    |  121 ++
 .../vpu-malone/Malone_Firmware/DecKLib/Incl/mvd.h  |  157 ++
 .../Malone_Firmware/DecKLib/Incl/mvd_reg_map.h     | 1676 ++++++++++++++++
 .../Malone_Firmware/DecKLib/Incl/mvd_sif_control.h |  975 ++++++++++
 .../Malone_Firmware/DecKLib/Incl/mvd_types.h       |  132 ++
 .../DecKLib/KernelIF/DecKernelLib.c                |  152 ++
 .../DecKLib/KernelIF/DecKernelLibCfg.h             |   95 +
 .../DecKLib/KernelIF/DecKernelLibPrivate.c         |  171 ++
 .../DecKLib/KernelIF/DecKernelLibPrivate.h         |   69 +
 .../mxc/vpu-malone/Malone_Firmware/Incl/basetype.h |  343 ++++
 .../Malone_Firmware/Incl/mediaip_fw_defines.h      |  249 +++
 .../Malone_Firmware/Incl/mediaip_fw_types.h        | 1991 ++++++++++++++++++++
 drivers/mxc/vpu-malone/Malone_Firmware/Incl/pal.h  |  337 ++++
 .../vpu-malone/Malone_Firmware/Incl/status_codes.h |   99 +
 .../vpu-malone/Malone_Firmware/Incl/trace_types.h  |  261 +++
 .../Malone_Firmware/PAL/Incl/pal_linux_map.h       |  149 ++
 .../Malone_Firmware/PAL/Incl/pal_types.h           |  170 ++
 drivers/mxc/vpu-malone/Malone_Firmware/PAL/pal.c   |  772 ++++++++
 drivers/mxc/vpu-malone/VPU_debug.h                 |   95 +
 drivers/mxc/vpu-malone/VPU_regdef.h                |   57 +
 drivers/mxc/vpu-malone/mxc_vpu-malone.c            | 1205 ++++++++++++
 include/linux/mxc_vpu-malone.h                     |   49 +
 27 files changed, 10510 insertions(+)
 create mode 100755 drivers/mxc/vpu-malone/Kconfig
 create mode 100755 drivers/mxc/vpu-malone/Makefile
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.c
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWIsr.c
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/DecKernelLib.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_reg_map.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_sif_control.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_types.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLib.c
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibCfg.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.c
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/Incl/basetype.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_defines.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_types.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/Incl/pal.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/Incl/status_codes.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/Incl/trace_types.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_linux_map.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_types.h
 create mode 100755 drivers/mxc/vpu-malone/Malone_Firmware/PAL/pal.c
 create mode 100755 drivers/mxc/vpu-malone/VPU_debug.h
 create mode 100755 drivers/mxc/vpu-malone/VPU_regdef.h
 create mode 100755 drivers/mxc/vpu-malone/mxc_vpu-malone.c
 create mode 100755 include/linux/mxc_vpu-malone.h

diff --git a/drivers/mxc/vpu-malone/Kconfig b/drivers/mxc/vpu-malone/Kconfig
new file mode 100755
index 0000000..3ba5c561
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Kconfig
@@ -0,0 +1,20 @@
+#
+# Codec configuration
+#
+
+menu "MXC VPU(Video Processing Unit) MALONE support"
+
+config MXC_VPU_MALONE
+	  tristate "Support for MXC VPU(Video Processing Unit) MALONE"
+	  default y
+	---help---
+	  The VPU codec device provides codec function for H.265/H.264/MPEG4/H.263 etc.
+
+config MXC_VPU_MALONE_DEBUG
+	bool "MXC VPU MALONE debugging"
+	depends on MXC_VPU_MALONE != n
+	help
+	  This is an option for the developers; most people should
+	  say N here.  This enables MXC VPU driver debugging.
+
+endmenu
diff --git a/drivers/mxc/vpu-malone/Makefile b/drivers/mxc/vpu-malone/Makefile
new file mode 100755
index 0000000..86af231
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Makefile
@@ -0,0 +1,197 @@
+#
+# Makefile for VPU driver.
+#
+
+MALONE_ROOT = $(srctree)/drivers/mxc/vpu-malone/Malone_Firmware
+
+#---------------------------------------------------------------------------
+# Header Include Paths
+
+MALONE_KERN_HEADER = \
+	      -I$(MALONE_ROOT)/DecKLib/KernelIF \
+	      -I$(MALONE_ROOT)/DecKLib/Control \
+	      -I$(MALONE_ROOT)/DecKLib/Incl
+
+SYS_HEADER = -I$(MALONE_ROOT)/Incl \
+	     -I$(MALONE_ROOT)/PAL/Incl \
+	     -I$(srctree)/drivers/mxc/vpu-malone
+
+MALONE_KERN_HEADER += $(SYS_HEADER)
+
+
+#---------------------------------------------------------------------------
+# Actual Source and Library control
+
+MAL_KERN_OBJECTS = \
+		Malone_Firmware/DecKLib/KernelIF/DecKernelLib.o \
+		Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.o \
+		Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.o \
+		Malone_Firmware/DecKLib/Control/DecKernelLibHWIsr.o 
+
+MAL_KERN_OBJECTS += Malone_Firmware/PAL/pal.o
+
+#---------------------------------------------------------------------------
+# Build flags
+
+DEFINES = -D DTV_GATHER_PERF_METRICS \
+		  -D MVD_DTV_USERDATA \
+		  -D MVD_WAIT_BOB_INACTIVE \
+		  -D DECLIB_FORCE_HW_STOP \
+		  -D MVD_NO_BSDMA_SAFETY_MARGIN \
+		  -D MVD_CQ_ENABLE_REFILL \
+		  -D MVD_SPP_HW_GOULOMB \
+		  -D SVC_SFA_ADD_ERROR_CHECKING \
+		  -D MVC_SFA_ADD_ERROR_CHECKING \
+		  -D SVC_SPP_SAVE_CTX_PER_VCL_NAL \
+		  -D MVD_CQ_CQSR \
+		  -D AVC_SUPPORT_THRU_MVC \
+		  -D MVC_ERROR_CONTROL_INSERT_SKIP_START_CONTROLS \
+		  -D DECLIB_CTX_FLUSH_AFTER_SAVE \
+		  -D DECLIB_SERVICE_EOS \
+		  -D MVD_PERF_MEASURE \
+		  -D VC1_ENABLED \
+		  -D HEVC_ENABLED \
+		  -D HEVC_CM_WORKAROUND \
+		  -D HEVC_NEW_OUTPUT_TRIGGER \
+		  -D HEVC_ALL_PICS_REF \
+		  -D HEVC_SCAL_LIST_USE_YCRCB_XREF \
+		  -D HEVC_SFA_ADD_ERROR_CHECKING \
+		  -D MVD_DFE_DBG \
+		  -D HEVC_JVT_MODEL=100 \
+		  -D PAL_CLOCK_API \
+		  -D SVC_ADDITIONAL_DEBUG \
+		  -D DIAG_SUPPORT_ENABLED \
+		  -D ENABLE_PERF_TIMER \
+		  -D FW_API_VERSION=19 \
+		  -D GLOBAL_USE_RUN_TIME_CFG \
+		  -D ENABLE_TRACE_IN_RELEASE=0 \
+		  -D YES=1 \
+		  -D NO=0 \
+		  -D NONE=0 \
+		  -D NUP=1 \
+		  -D UCOS=2 \
+		  -D UCOS3=3 \
+		  -D RTOS=0 \
+		  -D USE_DECODER \
+		  -D ARM=0 \
+		  -D MIPS=1 \
+		  -D X86=2 \
+		  -D OR1K=3 \
+		  -D CPU=0 \
+		  -D NO_AL=0 \
+		  -D CNXT_KAL=1 \
+		  -D NXP_OSAL=2 \
+		  -D OSAL=0 \
+		  -D ARM926=0 \
+		  -D ARMR5=1 \
+		  -D ARMA53=2 \
+		  -D ARM_CPU_TYPE=2 \
+		  -D ADS=0 \
+		  -D RVDS=1 \
+		  -D GNU_MIPS=2 \
+		  -D GNU_MIPS_LNX=3 \
+		  -D GNU_ARM=4 \
+		  -D GNU_ARM_SOURCERY=5 \
+		  -D GNU_X86=6 \
+		  -D WIN_X86=7 \
+		  -D DS5=8 \
+		  -D GNU_OR32=9 \
+		  -D GNU_ARM_LINARO=10 \
+		  -D GNU_OR1K=11 \
+		  -D TOOLSET=10 \
+		  -D NO_DEBUG=0 \
+		  -D BUILD_DEBUG=1 \
+		  -D ARRAY_DEBUG=2 \
+		  -D FULL_DEBUG=3 \
+		  -D DEBUG_CAPS=0 \
+		  -D GENTB_PLATFORM=0 \
+		  -D WIN_LIB=1 \
+		  -D GEN_TB_ENC=2 \
+		  -D TARGET_PLATFORM=0 \
+		  -D VIDEO_TRANS=0 \
+		  -D GTB_TRANS=1 \
+		  -D GTB_DEC=2 \
+		  -D WINDSOR_LIB=3 \
+		  -D GTB_ENC=4 \
+		  -D MEDIA_DEC=5 \
+		  -D MEDIA_LIB=6 \
+                  -D VPU_TEST_APP=7 \
+		  -D TARGET_APP=7 \
+		  -D PAL_CLOCK_API \
+		  -D SVC_ADDITIONAL_DEBUG \
+		  -D DIAG_SUPPORT_ENABLED \
+		  -D ENABLE_PERF_TIMER \
+		  -D FW_API_VERSION=19 \
+		  -D GLOBAL_USE_RUN_TIME_CFG \
+		  -D DISABLE_TRACE \
+		  -D ENABLE_TRACE_IN_RELEASE=0 \
+		  -D YES=1 \
+		  -D NO=0 \
+		  -D NONE=0 \
+		  -D NUP=1 \
+		  -D UCOS=2 \
+		  -D UCOS3=3 \
+		  -D RTOS=0 \
+		  -D USE_DECODER \
+		  -D CHIP=0 \
+		  -D EMULATION=1 \
+		  -D HAPS=2 \
+		  -D SIMULATION=3 \
+		  -D CMODEL=4 \
+		  -D TARGET_LEVEL=0 \
+		  -D SVC_DISABLED=0 \
+		  -D SVC_ENABLED=1 \
+		  -D SVC_SUPPORT=0 \
+		  -D MVC_DISABLED=0 \
+		  -D MVC_ENABLED=1 \
+		  -D MVC_SUPPORT=1 \
+		  -D SFA_DISABLED=0 \
+		  -D SFA_ENABLED=1 \
+		  -D SFA_SUPPORT=1 \
+		  -D CNXT_HW=0 \
+		  -D NXP_HW=1 \
+		  -D HWLIB=1 \
+		  -D DTV=0 \
+		  -D STB=1 \
+		  -D PLAYMODE=0 \
+		  -D STANDARD=0 \
+		  -D REBOOT=1 \
+		  -D BOOT_ARCH=0 \
+		  -D TBPLAYER_FLOW_CHANGE_ON_REF_FRMS \
+		  -D PULSAR_MERGE \
+		  -D FSLCACHE_ENABLED \
+		  -D DECLIB_ENABLE_DFE -D DECLIB_ENABLE_DBE \
+		  -D DECLIB_ENABLE_DCP -D MVD_DCP_DYNAMIC_CONFIG \
+		  -D DECLIB_4K_SUPPORTED -D HEVC_LEVEL_5PT0_SUPPORT \
+		  -D PLAYER_LOCAL_THREAD \
+		  -D DECLIB_ISR_IN_THREAD_CTX \
+		  -D JPG_ENABLED \
+		  -D JPGD_AUTO_DOWN_SCALE \
+		  -D SPARK_ENABLED \
+		  -D RV_ENABLED \
+		  -D VP6_ENABLED \
+		  -D VP8_ENABLED \
+		  -D JPG_DPV_ENABLED \
+		  -D MALONE_64BIT_ADDR \
+		  -D DISABLE_TRACE
+
+MALONE_KERN_DEFINEFLAGS = $(DEFINES)
+MALONE_KERN_DEFINEFLAGS += -D VPU_KERNEL_BUILD
+
+EXTRA_CFLAGS += $(MALONE_KERN_DEFINEFLAGS)
+EXTRA_CFLAGS += $(MALONE_KERN_HEADER)
+
+ifeq ($(CONFIG_MXC_VPU_MALONE_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
+
+obj-$(CONFIG_MXC_VPU_MALONE) = decoder.o
+
+decoder-objs = mxc_vpu-malone.o \
+	       $(MAL_KERN_OBJECTS)
+
+cmd_files := $(foreach f,$(decoder-objs),$(dir $(f)).$(notdir $(f)).cmd)
+clean:
+	rm -rf $(decoder-objs) $(cmd_files) *.o .*.cmd modules.builtin modules.order
+
+
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.c b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.c
new file mode 100755
index 0000000..7861d54
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.c
@@ -0,0 +1,326 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Author    : Media IP FW team ( Belfast and Shanghai )
+  File name : DecLibHWControl.c
+  Notes     : Processes commands from decoder lib scheduler
+              Establishes context for and makes calls to
+              the base decoders
+              This file provides the hardware facing aspect to
+              the interface. It is part of a group with
+              DecLibStreamControl.c which provides the
+              HW funtionality
+
+ ******************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header Files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "basetype.h"
+#include "mediaip_fw_types.h"
+#include "pal.h"
+
+#include "mvd_types.h"
+#include "mvd_reg_map.h"
+#include "mvd_sif_control.h"
+
+#include "DecKernelLibPrivate.h"
+#include "DecKernelLibHWControl.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Extern Function Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+extern MEDIAIP_IRQ_RETCODE mvd_kernel_hw_primary_isr ( u_int32 irq_val );
+extern MEDIAIP_IRQ_RETCODE mvd_kernel_hw_secondary_isr ( u_int32 irq_val );
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Private Function Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Variables
+/////////////////////////////////////////////////////////////////////////////////;
+
+extern DEC_KERNEL_LIB              gDecKernelLib;
+       MALONE_KERNEL_HW_SESSION    gMvdKernelHw[(DECODERLIB_MAX_MALONES + 1)];
+       pMALONE_KERNEL_HW_SESSION   pgMVDKernelHw;
+
+u_int32                    gMaloneList[(DECODERLIB_MAX_MALONES + 1)] = { MALONE_HW_1,
+#if DECODERLIB_MAX_MALONES > 1
+                                                                         MALONE_HW_2,
+#endif
+                                                                         MALONE_SW };
+
+static u_int32      uSWMaloneRegSpace[2048];   /* Until we are sure we have eliminated register access */
+                                               /* for functions using the 'SW Malone', point them here */
+
+extern u_int32      uDecLibIrqPin[DECODERLIB_MAX_MALONES][0x2];
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Code
+/////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_control_init                                         //
+//                                                                                //
+//  DESCRIPTION: Perform all HW initialisation and shared structure setup         //
+//                                                                                //
+//  INPUTS:      uMaloneID - The ID of the Malone for which the info is to        //
+//                           be restored                                          //
+//               pCtxArea  - Pointer to area of memory from which data is to be   //
+//                           read                                                 //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void mvd_kernel_hw_control_init ( DECODERLIB_KERNEL_CFG * pCfg )
+{
+  /* Init the handles                             */
+  /* This sets up the reg pointers so do it first */
+  mvd_kernel_hw_init_handles ( pCfg,
+                               TRUE );
+  
+  /* Default global pointers to a 1st Malone focus  */
+  mvd_kernel_hw_set_focus ( MALONE_HW_1, &pgMVDKernelHw  );
+
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_set_malone_instance                                  //
+//                                                                                //
+//  DESCRIPTION: Look for the most appropriate Malone instance to service         //
+//               the command for a specified stream                               //
+//                                                                                //
+//  INPUTS:      uStrId   - The Stream ID                                         //
+//               bSWCmd   - is the command to be carried out for this stream      //
+//                          capable of being handled without using the HW engine? //
+//               uHWIndex - HW Index suggested by scheduler                       //
+//               bUseSch  - Set to guarantee scheduler suggested unit is used     //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     The most suitable Malone ID to be used                           //
+//                                                                                //
+//  NOTES:       This function must return a value.                               //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+u_int32 mvd_kernel_hw_set_malone_instance ( u_int32 uStrId,
+                                            bool    bSWCmd,
+                                            u_int32 uHWIndex,
+                                            bool    bUseSch
+                                          )
+{
+  u_int32 uIdx      = 0;
+
+  if ( bUseSch )
+  {
+    return uHWIndex;
+  }
+
+  for ( uIdx = 0; uIdx < gDecKernelLib.uNumMalones; uIdx++ )
+  {
+    /* Even if there is no command active, this is a valid check as */
+    /* it avoids need for a context change if it matches            */
+    if ( gMvdKernelHw[uIdx].uStrID == uStrId )
+    {
+      return uIdx;
+    }
+  }
+
+  if ( bSWCmd ) return MALONE_SW;
+
+  /* Look for free Malone - this function should not be called */
+  /* unless this is a SW command or there is a free Malone     */
+
+  for ( uIdx = 0; uIdx < gDecKernelLib.uNumMalones; uIdx++ )
+  {
+    /* Even if there is no command active, this is a valid check as */
+    /* it avoids need for a context change if it matches            */
+    if ( gMvdKernelHw[uIdx].eState == MALONE_INACTIVE )
+    {
+      break;
+    }
+  }
+
+  /* Do not assign this stream and do NOT make it active yet */
+  /* Only make this malone active when the command is issued */
+  /* This is necessary so we we can trigger context switches */
+
+  /* We should set the global pointer though so calls to sif */
+  /* etc can get correct functions!!                         */
+
+  mvd_kernel_hw_set_focus ( uIdx, &pgMVDKernelHw );
+
+  return uIdx;
+
+}
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_set_focus                                            //
+//                                                                                //
+//  DESCRIPTION: Changes focus to the selected Malone HW unit                     //
+//                                                                                //
+//  INPUTS:      uMaloneID - The ID of the Malone                                 //
+//                                                                                //
+//  OUTPUTS:     ppMVDHw   - Pointer to a HW session structure for the specified  //
+//                           Malone                                               //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       Only makes sense in multi-malone configs                         //
+//                                                                                //
+//  CONTEXT:     This function may be called from any context                     //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void mvd_kernel_hw_set_focus ( u_int32 uMaloneID, pMALONE_KERNEL_HW_SESSION * ppMVDHw )
+{
+  *ppMVDHw = ( MALONE_KERNEL_HW_SESSION * )&gMvdKernelHw[uMaloneID];
+}
+
+
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_init_handles                                         //
+//                                                                                //
+//  DESCRIPTION: Initialise the HW session handles                                //
+//                                                                                //
+//  INPUTS:      pCfg      - A pointer to the DecLib Config structure             //
+//               bSoftInit - If set, the FW pointers get established - leave      //
+//                           FALSE when restarting from a snapshot                //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void mvd_kernel_hw_init_handles ( DECODERLIB_KERNEL_CFG * pCfg,
+                                  bool                    bSoftInit
+                                )
+{
+  u_int32            uIdx;
+  pMALONE_KERNEL_HW_SESSION pMVDHw;
+  MvdHwRegMap       *pMvdReg;
+
+  for ( uIdx = 0; uIdx < (gDecKernelLib.uNumMalones + 1); uIdx++ )
+  {
+    /* If we have set up all the HW handles then move to the SW */
+    /* handle and set it up                                     */
+    if ( uIdx == gDecKernelLib.uNumMalones ) uIdx = DECODERLIB_MAX_MALONES;
+    
+    pMVDHw                 = &gMvdKernelHw[uIdx];
+    
+    if ( bSoftInit )
+    {
+      pMVDHw->eState       = MALONE_INACTIVE;
+      pMVDHw->uStrID       = 0;
+      pMVDHw->uForceFIQ    = 0;
+      pMVDHw->uForceDFEFIQ = 0;
+
+      /* Malone ID that the instance uses, normally fixed... */
+      pMVDHw->uMaloneID    = gMaloneList[uIdx];
+    }
+
+    if ( pMVDHw->uMaloneID == DECODERLIB_MAX_MALONES )
+    {
+      pMvdReg = ( MvdHwRegMap * )uSWMaloneRegSpace;
+    }
+    else if ( pMVDHw->uMaloneID == MALONE_HW_2 )
+    {
+      pMvdReg = ( MvdHwRegMap * ) ( pCfg->uMaloneBaseAddr[0x1] + pCfg->uMaloneHifOffset[0x1] );
+    }
+    else
+    {
+      pMvdReg = ( MvdHwRegMap * ) ( pCfg->uMaloneBaseAddr[0x0] + pCfg->uMaloneHifOffset[0x0] );
+    }
+
+    if ( pMVDHw->uMaloneID == MALONE_SW )
+    {
+      pMVDHw->msd_regp      = ( MvdHwRegMap     * )pMvdReg;
+      pMVDHw->hif_regp      = ( MvdHwRegHifMap  * )pMvdReg;
+      pMVDHw->sif_regp      = ( MvdHwRegSifMap  * )pMvdReg;
+      pMVDHw->ctx_regp      = ( MvdHwRegCtxMap  * )pMvdReg;
+      pMVDHw->rsb_regp      = ( MvdHwReg        * )pMvdReg;
+      pMVDHw->rpr_regp      = ( MvdHwRegRprMap  * )pMvdReg;
+      pMVDHw->spp_regp      = ( MvdHwRegSppMap  * )pMvdReg;
+      pMVDHw->avc_regp      = ( MvdHwRegH264Map * )pMvdReg;
+      pMVDHw->mp2d_regp     = ( MvdHwRegMp2dMap * )pMvdReg;
+      pMVDHw->avsd_regp     = ( MvdHwRegAvsdMap * )pMvdReg;
+      pMVDHw->aspd_regp     = ( MvdHwRegAspdMap * )pMvdReg;
+      pMVDHw->vc1d_regp     = ( MvdHwRegVc1dMap * )pMvdReg;
+      pMVDHw->jpgd_regp     = ( MvdHwRegAspdMap * )pMvdReg;
+      pMVDHw->rvid_regp     = ( MvdHwRegRvidMap * )pMvdReg;
+      pMVDHw->hevc_regp     = ( MvdHwRegHevcMap * )pMvdReg;
+      pMVDHw->on2d_regp     = ( MvdHwRegOn2dMap * )pMvdReg;
+      pMVDHw->cq_regp       = ( MvdHwRegCqMap   * )pMvdReg;
+      pMVDHw->rc4_regp      = ( MvdHwRegRC4Map  * )pMvdReg;
+      pMVDHw->dfe_regp      = ( MvdHwRegDfeMap  * )pMvdReg;
+      pMVDHw->dbe_regp[0x0] = ( MvdHwRegDbeMap  * )pMvdReg;
+      pMVDHw->dbe_regp[0x1] = ( MvdHwRegDbeMap  * )pMvdReg;
+
+    }
+    else
+    {
+      pMVDHw->msd_regp       = pMvdReg;
+      pMVDHw->hif_regp       = &( pMvdReg->HifMap.hif_map );
+      pMVDHw->sif_regp       = &( pMvdReg->SifMap.sif_map );
+      pMVDHw->ctx_regp       = &( pMvdReg->CtxMap.ctx_map );
+      pMVDHw->rpr_regp       = &( pMvdReg->RprMap.rpr_map );
+      pMVDHw->spp_regp       = &( pMvdReg->SppMap.spp_map );
+      pMVDHw->avc_regp       = &( pMvdReg->DecMap.h264_map );
+      pMVDHw->mp2d_regp      = &( pMvdReg->DecMap.mp2d_map );
+      pMVDHw->aspd_regp      = &( pMvdReg->DecMap.aspd_map );
+      pMVDHw->avsd_regp      = &( pMvdReg->DecMap.avsd_map );
+      pMVDHw->vc1d_regp      = &( pMvdReg->DecMap.vc1d_map );
+      pMVDHw->jpgd_regp      = &( pMvdReg->DecMap.aspd_map );
+      pMVDHw->on2d_regp      = &( pMvdReg->DecMap.on2d_map );
+      pMVDHw->rvid_regp      = &( pMvdReg->DecMap.rvid_map );
+      pMVDHw->hevc_regp      = &( pMvdReg->DecMap.hevc_map );
+      pMVDHw->bbd_regp       = &( pMvdReg->BbdMap.bbd_map );
+      pMVDHw->cq_regp        = &( pMvdReg->CqMap.cq_map );
+      pMVDHw->rc4_regp       = &( pMvdReg->RC4Map.RC4_map );
+      pMVDHw->dfe_regp       = &( pMvdReg->DcpMap.dfe_map );
+      pMVDHw->dbe_regp[0x0]  = &( pMvdReg->DcpMap.dbe_map[0x0] );
+      pMVDHw->dbe_regp[0x1]  = &( pMvdReg->DcpMap.dbe_map[0x1] );
+
+      if ( pMVDHw->uMaloneID == MALONE_HW_2 )
+      {
+        pMVDHw->rsb_regp = ( MvdHwReg * ) pCfg->uMaloneBaseAddr[0x1]  ;
+      }
+      else
+      {
+        pMVDHw->rsb_regp = ( MvdHwReg * ) pCfg->uMaloneBaseAddr[0x0] ;
+      }
+    }
+  }
+}
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.h
new file mode 100755
index 0000000..4ef9b0f
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWControl.h
@@ -0,0 +1,175 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        DecLibHWControl.h
+  Description:
+
+ **************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#ifndef _DECODER_LIB_HW_CONTROL_H_
+#define _DECODER_LIB_HW_CONTROL_H_
+
+#include "mvd_types.h"
+#include "mvd_reg_map.h"
+#include "DecKernelLib.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+#define MALONE_HW_1 0                         /* Identifiers for the Malone units     */
+#define MALONE_HW_2 1
+#define MALONE_SW   DECODERLIB_MAX_MALONES    /* Sw Malone does not exist! Simply a   */
+                                              /* control structure for carrying out   */
+                                              /* commands which do not need a HW unit */
+#define MALONE_SW_IRQ 0xdeaf
+                                              
+#define DECODERLIB_ISR_QU_SIZE          ( DECODERLIB_MAX_MALONES * 4 )
+#define DECODERLIB_SECONDARY_ISR_EVENT  0x80000000
+#define DECODERLIB_EVENT_MASK           0x7FFFFFFF
+
+#define DECODERLIB_FORCEIRQ_BIT_SET( uVal )     (( uVal & 0x1 ) << 30 )
+#define DECODERLIB_FORCEIRQ_BIT_GET( uVal )     (( uVal >> 30 ) & 0x1 )
+#define DECODERLIB_FORCEDFEIRQ_BIT_SET( uVal )  (( uVal & 0x1 ) << 29 )
+#define DECODERLIB_FORCEDFEIRQ_BIT_GET( uVal )  (( uVal >> 29 ) & 0x1 )                                              
+                                              
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Types
+/////////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////
+// Decoder Library HW State
+
+typedef enum
+{
+  MALONE_INACTIVE  = 0,
+  MALONE_ACTIVE,
+  MALONE_BE_ACTIVE
+
+} MALONE_STATE;
+
+//////////////////////////////////////////////////////////////
+// Decoder Library HW Control Context Info
+
+typedef struct
+{
+
+  MALONE_STATE eState;
+  u_int32      uStrID;
+
+  u_int32      uForceFIQ;
+  u_int32      uForceDFEFIQ;
+  u_int32      uChipVer;                /* Hold "malone" version to be filled in from Malone HW register   */
+  u_int32      uChipMnrVer;             /* Hold "malone" minor version to be filled in from Malone HW register   */
+  u_int32      uChipSubVer;             /* Hold metal version to be filled in by higher level control      */
+  u_int32      uHWFeatures;
+  u_int32      uForceCacheFlush;        /* Cache reset issue workaround purpose for Kronos and Fusion RevA */
+  u_int32      bPreparser;              /* Set TRUE to indicate a preparser is in place                    */
+  u_int32      bCQ;                     /* Set TRUE to indicate a command queue is in place                */
+  u_int32      bDCP;                    /* Set TRUE to indicate unit can operate in decoupled mode         */
+  u_int32      uNumDBEs;                /* Indicates the number of decoupled back ends available           */
+  u_int32      bFBC;                    /* Set TRUE to indicate Frame buffer Compression support           */
+  u_int32      uRSBSize;
+  u_int32      uMaloneID;
+  u_int32      bPixIf;
+  u_int32      bXBUS;
+
+  u_int32      uCQProcType[DECODERLIB_MAX_CQ_PER_MALONE]; /* Specifies what type of processing each of the CQ units is doing */
+
+  MALONE_STATE eDFEState;                                 /* If the front end of the HW is active in isolation - specifies state */
+  u_int8       usDFEStrID;                                /* If the front end of the HW is active in isolation - specifies       */
+                                                          /* which stream is assigned                                            */
+
+  u_int32      uDmaMemSize;
+  void       * pDmaMemArea;  
+                                                          
+  MvdHwRegMap     * msd_regp;
+  MvdHwRegHifMap  * hif_regp;
+  MvdHwRegSifMap  * sif_regp;
+  MvdHwRegCtxMap  * ctx_regp;
+  MvdHwReg        * rsb_regp;
+  MvdHwRegRprMap  * rpr_regp;
+  MvdHwRegSppMap  * spp_regp;
+  MvdHwRegH264Map * avc_regp;
+  MvdHwRegMp2dMap * mp2d_regp;
+  MvdHwRegAvsdMap * avsd_regp;
+  MvdHwRegAspdMap * aspd_regp;
+  MvdHwRegVc1dMap * vc1d_regp;
+  MvdHwRegAspdMap * jpgd_regp;
+  MvdHwRegOn2dMap * on2d_regp;
+  MvdHwRegRvidMap * rvid_regp;
+  MvdHwRegHevcMap * hevc_regp;
+  MvdHwRegBbdMap  * bbd_regp;
+  MvdHwRegDbgMap  * dbg_regp;
+  MvdHwRegCqMap   * cq_regp;
+  MvdHwRegRC4Map  * rc4_regp;
+  MvdHwRegDfeMap  * dfe_regp;
+  MvdHwRegDbeMap  * dbe_regp[DECODERLIB_MAX_DBE_UNITS];
+
+} MALONE_KERNEL_HW_SESSION, *pMALONE_KERNEL_HW_SESSION;
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Function definitions
+/////////////////////////////////////////////////////////////////////////////////
+
+
+void mvd_kernel_hw_control_init ( DECODERLIB_KERNEL_CFG * pCfg );
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_set_focus                                            //
+//                                                                                //
+//  DESCRIPTION: Changes focus to the selected Malone HW unit                     //
+//                                                                                //
+//  INPUTS:      uMaloneID - The ID of the Malone                                 //
+//                                                                                //
+//  OUTPUTS:     ppMVDHw   - Pointer to a HW session structure for the specified  //
+//                           Malone                                               //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       Only makes sense in multi-malone configs                         //
+//                                                                                //
+//  CONTEXT:     This function may be called from any context                     //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void mvd_kernel_hw_set_focus ( u_int32 uMaloneID, pMALONE_KERNEL_HW_SESSION * ppMVDHw );
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_init_handles                                       //
+//                                                                                //
+//  DESCRIPTION: Initialise the HW session handles                                //
+//                                                                                //
+//  INPUTS:      pCfg      - A pointer to the DecLib Config structure             //
+//               bSoftInit - If set, the FW pointers get established - leave      //
+//                           FALSE when restarting from a snapshot                //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void mvd_kernel_hw_init_handles ( DECODERLIB_KERNEL_CFG * pCfg,
+                                  bool             bSoftInit );
+
+#endif /* _DECODER_LIB_HW_CONTROL_H_ */
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWIsr.c b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWIsr.c
new file mode 100755
index 0000000..efb356f
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Control/DecKernelLibHWIsr.c
@@ -0,0 +1,467 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd 
+                All rights reserved.               
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  File name : DecLibHWIsr.c
+  Notes     : Provides the HW Interrupt Service Routines
+
+ *******************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header Files
+/////////////////////////////////////////////////////////////////////////////////
+ 
+#include "basetype.h"
+#include "mediaip_fw_types.h"           
+#include "pal.h"
+
+#include "mvd.h"
+#include "mvd_types.h"
+#include "mvd_reg_map.h"
+#include "mvd_sif_control.h"
+
+#include "DecKernelLibHWControl.h"
+#include "DecKernelLibPrivate.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Variables                                                            
+/////////////////////////////////////////////////////////////////////////////////
+
+extern pMALONE_KERNEL_HW_SESSION pgMVDKernelHw;                       
+extern u_int32                   uMvdKernelIrqPin[DECODERLIB_MAX_MALONES][0x2]; 
+extern DEC_KERNEL_LIB            gDecKernelLib;
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Macros                                                            
+/////////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Private Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+void  mvd_kernel_hw_isr_event ( u_int32   uMaloneIdx,
+                                u_int32 * puIrqStatus );
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Extern Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Code                                                     
+/////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_hw_sesh_isr                                                  // 
+//                                                                                //
+//  DESCRIPTION: Malone HW ISR                                                    // 
+//                                                                                //
+//  INPUTS:      irq_val - Identification Parameter from which source of call     //
+//                         may be ascertained                                     //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     MEDIAIP_IRQ_RETCODE                                              //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function may be called from any context                     //
+//               Since it is an isr, that may be strange but it can be called to  //
+//               handle SW commands in thread context only                        //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+#define CTX_DBG(x)
+
+MEDIAIP_IRQ_RETCODE mvd_kernel_hw_primary_isr ( u_int32 irq_val )
+{
+  u_int32        sif_irq_status[0x3] = { 0x0 };
+  u_int32        uActMaloneID, uData;
+#if ( TARGET_APP == GTB_DEC ) || ( TARGET_APP == MEDIA_DEC ) || ( TARGET_APP == VIDEO_TRANS ) || ( TARGET_APP == GTB_TRANS )
+  u_int32        uIrqTarget0, uIrqTarget1;
+#endif
+  u_int32        uForceFIQ = 0, uForceDFEFIQ = 0; 
+
+  /* Future Proof... */
+  /* If we have two levels of interrupt or we process interrupts in thread context */
+  /* we need to save and restore HW focus                                          */
+  pMALONE_KERNEL_HW_SESSION pLocMVDHw = pgMVDKernelHw;  
+   
+  /* Work out which Malone instance caused this isr and set HW focus accordingly   */
+
+#if ( TARGET_APP == GTB_DEC ) || ( TARGET_APP == MEDIA_DEC ) || ( TARGET_APP == VIDEO_TRANS ) || ( TARGET_APP == GTB_TRANS )
+
+  pal_int_get_irq_line ( uMvdKernelIrqPin[0x0][0x0],
+                         &uIrqTarget0
+                       );
+  pal_int_get_irq_line ( uMvdKernelIrqPin[0x0][0x1],
+                         &uIrqTarget1
+                       );
+
+  uActMaloneID = ( irq_val == MALONE_SW_IRQ )                              ? MALONE_SW   :
+                 (( irq_val == uIrqTarget0 ) | ( irq_val == uIrqTarget1 )) ? MALONE_HW_1 :     
+                 MALONE_HW_2;
+
+#else
+
+  uActMaloneID = ( irq_val == MALONE_SW_IRQ )                                                            ? MALONE_SW   :
+                 (( irq_val == uMvdKernelIrqPin[0x0][0x0] ) | ( irq_val == uMvdKernelIrqPin[0x0][0x1] )) ? MALONE_HW_1 :     
+                 MALONE_HW_2;
+
+#endif
+
+  mvd_kernel_hw_set_focus ( uActMaloneID, &pgMVDKernelHw );
+  
+  MVD_REG_READ( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->msd_data0_reg, uData );
+  
+  MVD_REG_WRITE( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->msd_data0_reg, 0 );
+  
+  uForceFIQ    = ( uData & 0x1 ) ? 1 : 0;
+  uForceDFEFIQ = ( uData & 0x2 ) ? 1 : 0;
+  
+  if ( uActMaloneID != MALONE_SW )
+  {  
+    u_int32 uClearVal;
+    
+    /* Break down sif IRQ sources */
+    MVD_REG_READ( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr_status, sif_irq_status[0x0] );
+    MVD_REG_READ( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] );
+    MVD_REG_READ( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr3_status, sif_irq_status[0x2] );
+
+    pal_trace( DECODER_TL_INFO, "mvd_kernel_hw_primary_isr(%d): opening sif_irq_status  = 0x%x\n", irq_val, sif_irq_status[0x0]);
+    pal_trace( DECODER_TL_INFO, "mvd_kernel_hw_primary_isr(%d): opening sif_irq_status[0x1] = 0x%x\n", irq_val, sif_irq_status[0x1]);
+    pal_trace( DECODER_TL_INFO, "mvd_kernel_hw_primary_isr(%d): opening sif_irq_status[0x2] = 0x%x\n", irq_val, sif_irq_status[0x2]);
+
+    /* Clear the interrupt bits we're going to handle here */
+
+#ifdef FW_PES_PARSE_AS_FIQ
+    
+    uClearVal = sif_irq_status[0x0] & ( MSD_SIF_INTR_BSDMA_BIT      |
+                                        MSD_SIF_INTR_FORCE_EXIT_BIT |
+                                        MSD_SIF_INTR_DISPQ_PULL_BIT |
+                                        MSD_SIF_INTR_SEMAPHORE_BIT  |
+                                        MSD_SIF_INTR_IMAGE_DONE_BIT |
+                                        MSD_SIF_INTR_SLICE_DONE_BIT |
+                                        MSD_SIF_INTR_FORCE_ENTRY_BIT 
+                                      );
+
+    MVD_REG_WRITE( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr_status, uClearVal );
+    
+#else
+
+    uClearVal = sif_irq_status[0x0] & ( MSD_SIF_INTR_BSDMA_BIT       |
+                                        MSD_SIF_INTR_PES_BIT         |
+                                        MSD_SIF_INTR_SCODE_FOUND_BIT |
+                                        MSD_SIF_INTR_DISPQ_PULL_BIT  |
+                                        MSD_SIF_INTR_SEMAPHORE_BIT   |
+                                        MSD_SIF_INTR_IMAGE_DONE_BIT  |
+                                        MSD_SIF_INTR_SLICE_DONE_BIT  |
+                                        MSD_SIF_INTR_FORCE_ENTRY_BIT
+                                      );
+
+    MVD_REG_WRITE( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr_status, uClearVal );
+    
+#endif /* FW_PES_PARSE_AS_FIQ */
+
+    /* Read it back to ensure write has made it to Malone        */
+    MVD_REG_READ( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr_status, uClearVal );
+    
+    /* Also re-clear the INTC bit which brought us in here since */
+    /* it will have been reset.                                  */
+    pal_int_clear ( irq_val,
+                    TRUE 
+                  );
+
+#ifdef FW_PARSE_PES
+#ifdef FW_PES_PARSE_AS_FIQ
+
+    /* Pes FW handling done at higher level         */
+    /* Re-maps the force-exit ISR as the startcode  */
+    
+    /* TODO-KMC */
+    /* Does this mean a normal engine startcode is mapped as a force-exit? I guess it does */
+    /* So if we were parsing PES as an FIQ we would not actually be in this function if it */
+    /* were a PES startcode and so the below event must be a normal startcode?             */
+    
+    if ( sif_irq_status[0x0] & MSD_SIF_INTR_FORCE_EXIT_BIT )
+    {
+      sif_irq_status[0x0] |= MSD_SIF_INTR_SCODE_FOUND_BIT;
+    }
+#else
+    /* PES isr */
+    if ( sif_irq_status[0x0] & MSD_SIF_INTR_SCODE_FOUND_BIT )
+    {
+      u_int32 scode_status;
+    
+      MVD_REG_READ( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->bs2rbsp_status, scode_status );
+      
+      if ( scode_status & MSD_SIF_BS2RBSP_GOT_PESSCODE )
+      {
+        sesh_pes_isr ( irq_val );
+      }
+    
+      /* If it was just a PES startcode, then don't tell the engine  */
+      /* that there was a startcode, as will get handled later       */
+      if (( scode_status & MSD_SIF_BS2RBSP_GOT_SCODE ) == 0 )
+      {
+        sif_irq_status[0x0] &= ~(MSD_SIF_INTR_SCODE_FOUND_BIT);
+      }
+    }
+#endif
+#endif
+
+    if ( sif_irq_status[0x1] & ( MSD_SIF_INTR2_CSC_BIT ) )
+    {      
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] & ( MSD_SIF_INTR2_CSC_BIT ) );   
+    }
+
+    if ( sif_irq_status[0x1] & ( MSD_SIF_INTR2_CQ_BIT ) )
+    {      
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] & ( MSD_SIF_INTR2_CQ_BIT ) );   
+    }
+
+    if ( sif_irq_status[0x1] & ( MSD_SIF_INTR2_DFE_DONE_BIT ) )
+    {
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] & ( MSD_SIF_INTR2_DFE_DONE_BIT ) );
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] & ( MSD_SIF_INTR2_DFE_SLC_DONE_BIT ) );      
+    }
+
+    if ( sif_irq_status[0x1] & MSD_SIF_INTR2_DFE_SLC_DONE_BIT )
+    {      
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] & ( MSD_SIF_INTR2_DFE_SLC_DONE_BIT ) ); 
+    }  
+
+    if ( sif_irq_status[0x2] & MSD_SIF_INTR3_DBE0_CQ_BIT )
+    {      
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr3_status, sif_irq_status[0x2] & ( MSD_SIF_INTR3_DBE0_CQ_BIT ) );   
+    }
+ 
+    if ( sif_irq_status[0x2] & MSD_SIF_INTR3_DBE1_CQ_BIT )
+    {      
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr3_status, sif_irq_status[0x2] & ( MSD_SIF_INTR3_DBE1_CQ_BIT ) );        
+    }
+
+    if ( sif_irq_status[0x2] & 
+         ( MSD_SIF_INTR3_DBE0_DONE_BIT | MSD_SIF_INTR3_DBE1_DONE_BIT | MSD_SIF_INTR3_DBE0_SLC_DONE_BIT | MSD_SIF_INTR3_DBE1_SLC_DONE_BIT )
+       )
+    {
+      u_int32 uMask = ( MSD_SIF_INTR3_DBE0_DONE_BIT | 
+                        MSD_SIF_INTR3_DBE1_DONE_BIT | 
+                        MSD_SIF_INTR3_DBE0_SLC_DONE_BIT | 
+                        MSD_SIF_INTR3_DBE1_SLC_DONE_BIT 
+                      );
+      
+      MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr3_status, sif_irq_status[0x2] & uMask );
+    }
+  }
+  else /* We wish to process a command without accessing HW */
+  {
+    sif_irq_status[0x0] = 0;
+  }
+    
+  pal_trace( DECODER_TL_DEBUG, "-> mvd_kernel_hw_primary_isr( ) : uForceFIQ = 0x%x\n", uForceFIQ );     
+
+  /* Decode engine IRQs */
+  if (( uActMaloneID == MALONE_SW )    ||
+      ( uForceFIQ )     ||
+      ( uForceDFEFIQ )  ||
+      ( sif_irq_status[0x0] & ( MSD_SIF_INTR_IMAGE_DONE_BIT | MSD_SIF_INTR_SLICE_DONE_BIT | MSD_SIF_INTR_SCODE_FOUND_BIT | MSD_SIF_INTR_FORCE_ENTRY_BIT | MSD_SIF_INTR_BSDMA_BIT )) ||
+      ( sif_irq_status[0x1] & ( MSD_SIF_INTR2_CSC_BIT       | MSD_SIF_INTR2_DFE_DONE_BIT  | MSD_SIF_INTR2_DFE_SLC_DONE_BIT | MSD_SIF_INTR2_CQ_BIT )) ||  
+      ( sif_irq_status[0x2] & ( MSD_SIF_INTR3_DBE0_DONE_BIT | MSD_SIF_INTR3_DBE1_DONE_BIT | MSD_SIF_INTR3_DBE0_SLC_DONE_BIT | MSD_SIF_INTR3_DBE1_SLC_DONE_BIT | MSD_SIF_INTR3_DBE0_CQ_BIT | MSD_SIF_INTR3_DBE1_CQ_BIT ))
+     )
+  {
+    pal_trace ( DECODER_TL_DEBUG, 
+                "-> mvd_kernel_hw_primary_isr( ) : sif_irq_status[0x0] = 0x%x : sif_irq_status[0x1] = 0x%x : sif_irq_status[0x2] = 0x%x : uForceFIQ  = 0x%x\n",
+                sif_irq_status[0x0], 
+                sif_irq_status[0x1], 
+                sif_irq_status[0x2], 
+                uForceFIQ
+              );
+
+    /* Only pass events not serviced inline in this isr */
+            
+    sif_irq_status[0x0] &= ( MSD_SIF_INTR_IMAGE_DONE_BIT | MSD_SIF_INTR_SLICE_DONE_BIT | MSD_SIF_INTR_SCODE_FOUND_BIT | MSD_SIF_INTR_FORCE_ENTRY_BIT | MSD_SIF_INTR_BSDMA_BIT );
+    sif_irq_status[0x1] &= ( MSD_SIF_INTR2_CSC_BIT       | MSD_SIF_INTR2_DFE_DONE_BIT  | MSD_SIF_INTR2_DFE_SLC_DONE_BIT | MSD_SIF_INTR2_CQ_BIT);  
+    sif_irq_status[0x2] &= ( MSD_SIF_INTR3_DBE0_DONE_BIT | MSD_SIF_INTR3_DBE1_DONE_BIT | MSD_SIF_INTR3_DBE0_SLC_DONE_BIT | MSD_SIF_INTR3_DBE1_SLC_DONE_BIT | MSD_SIF_INTR3_DBE0_CQ_BIT | MSD_SIF_INTR3_DBE1_CQ_BIT );
+
+    /* When passing to thread - explicitly set that a force irq has been set */
+    /* so that the thread function knows after which interrupt it can reset  */
+    /* pMVDHw->uForceFIQ                                                     */
+    
+    sif_irq_status[0x0] |= DECODERLIB_FORCEIRQ_BIT_SET( uForceFIQ );
+    sif_irq_status[0x0] |= DECODERLIB_FORCEDFEIRQ_BIT_SET( uForceDFEFIQ );
+    
+    if (( sif_irq_status[0x0] ) ||
+        ( sif_irq_status[0x1] ) ||
+        ( sif_irq_status[0x2] )
+       )
+    {
+      mvd_kernel_hw_isr_event ( uActMaloneID,
+                                sif_irq_status );
+    }
+  }
+
+  /* Future Proof - Restore pgMVDKernelHw */
+  pgMVDKernelHw = pLocMVDHw;
+  
+  return MEDIAIP_FW_STATUS_OK;
+
+}
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    mvd_kernel_hw_secondary_isr                                        // 
+//                                                                                //
+//  DESCRIPTION: Malone HW ISR 2                                                  // 
+//                                                                                //
+//  INPUTS:      irq_val - Identification Parameter from which source of call     //
+//                         may be ascertained                                     //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     MEDIAIP_IRQ_RETCODE                                              //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function may be called from any context                     //
+//               Since it is an isr, that may be strange but it can be called to  //
+//               handle SW commands in thread context only                        //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_IRQ_RETCODE mvd_kernel_hw_secondary_isr ( u_int32 irq_val )
+{
+  u_int32 uActMaloneID;
+  u_int32 uTemp;
+  u_int32 sif_irq_status[0x3] = { 0x0 };
+#if ( TARGET_APP == GTB_DEC ) || ( TARGET_APP == MEDIA_DEC ) || ( TARGET_APP == VIDEO_TRANS ) || ( TARGET_APP == GTB_TRANS )
+  u_int32 uIrqTarget0, uIrqTarget1;
+#endif
+ 
+  /* Future Proof... */
+  /* If we have two levels of interrupt we need to save and restore HW focus    */
+  pMALONE_KERNEL_HW_SESSION pLocMVDHw = pgMVDKernelHw;  
+ 
+  /* Work out which Malone instance cause this isr and set HW focus accordingly */  
+
+#if ( TARGET_APP == GTB_DEC ) || ( TARGET_APP == MEDIA_DEC ) || ( TARGET_APP == VIDEO_TRANS ) || ( TARGET_APP == GTB_TRANS )
+
+  pal_int_get_irq_line ( uMvdKernelIrqPin[0x0][0x0],
+                         &uIrqTarget0
+                       );
+  pal_int_get_irq_line ( uMvdKernelIrqPin[0x0][0x1],
+                         &uIrqTarget1
+                       );
+
+  uActMaloneID = ( irq_val == MALONE_SW_IRQ )                              ? MALONE_SW   :
+                 (( irq_val == uIrqTarget0 ) | ( irq_val == uIrqTarget1 )) ? MALONE_HW_1 :     
+                 MALONE_HW_2;
+
+#else
+
+  uActMaloneID = ( irq_val == MALONE_SW_IRQ )                                                            ? MALONE_SW   :
+                 (( irq_val == uMvdKernelIrqPin[0x0][0x0] ) | ( irq_val == uMvdKernelIrqPin[0x0][0x1] )) ? MALONE_HW_1 :     
+                 MALONE_HW_2;
+
+#endif
+
+  mvd_kernel_hw_set_focus ( uActMaloneID, &pgMVDKernelHw );
+  
+  if ( uActMaloneID != MALONE_SW )
+  {  
+    /* Break down sif IRQ sources      */
+    APB_REG_READ( pgMVDKernelHw->sif_regp->intr_status, sif_irq_status[0x0] );
+    
+    /* Clear those we will handle here */
+    MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SIF*/, pgMVDKernelHw->sif_regp->intr_status, sif_irq_status[0x0] & MSD_SIF_INTR2_EXTENSION_BIT_2 );
+   
+    /* Read it back to ensure write has made it to Malone        */
+    /* Using uActMaloneID as read dsetination as it is no longer */
+    /* required                                                  */
+    APB_REG_READ( pgMVDKernelHw->sif_regp->intr_status, uTemp );
+    
+    /* Also re-clear the INTC bit which brought us in here since */
+    /* it will have been reset.                                  */
+    pal_int_clear ( irq_val,
+                    TRUE );
+
+    if ( sif_irq_status[0x0] & MSD_SIF_INTR2_EXTENSION_BIT_2 ) 
+    {       
+      /* Break down extension IRQ sources */
+      APB_REG_READ( pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1]);
+    
+      /* Clear those we will handle here  */
+      MVD_REG_WRITE( pgMVDKernelHw, DECLIB_DBG_REG_SIF, pgMVDKernelHw->sif_regp->intr2_status, sif_irq_status[0x1] & ( MSD_SIF_CTRL2_SPP_SCODE_INTR_ENAB_BIT |
+                                                                                                                 MSD_SIF_CTRL2_SPP_PESSC_INTR_ENAB_BIT |
+                                                                                                                 MSD_SIF_CTRL2_SPP_BSDMA_INTR_ENAB_BIT ));
+
+      /* Bugzilla 237 - PES Interupt enable inadvertantly set through a RMW of sif_regp->control */
+      if ( sif_irq_status[0x1] & MSD_SIF_CTRL2_SPP_PESSC_INTR_ENAB_BIT )
+      {
+        u_int32 pes_status;
+
+        APB_REG_READ ( pgMVDKernelHw->spp_regp->pes_status, pes_status );
+
+        if ( MSD_SIF_PES_STATUS_GET_STATE( pes_status ) == pes_WaitClear )
+        {
+          /* Pending DTS/PTS looks like it is locked out reception of another startcode */
+          MVD_REG_WRITE( pgMVDKernelHw, 0x0 /*DECLIB_DBG_REG_SPP*/, pgMVDKernelHw->spp_regp->pes_ctrl, 0x0 );
+        }
+      }
+
+      sif_irq_status[0x0] |= DECODERLIB_SECONDARY_ISR_EVENT;
+
+      mvd_kernel_hw_isr_event ( uActMaloneID,
+                                sif_irq_status );
+      
+    }
+    
+    /* What other interrupts might we wish to handle in a seperate context? */
+    /* Only PES is known so far                                             */
+     
+  }  
+
+  /* Future Proof - Restore pgMVDKernelHw */
+  pgMVDKernelHw = pLocMVDHw;
+
+  return MEDIAIP_FW_STATUS_OK;
+
+}  
+
+////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    internal_decoder_kernel_lib_isr_event                        //
+//                                                                            //
+//  DESCRIPTION: Callback function for base decoder to schedule the           //
+//               processing of the isr in thread context                      //
+//                                                                            //
+//  INPUTS:      None                                                         //
+//                                                                            //
+//  OUTPUTS:     None                                                         //
+//                                                                            //
+//  RETURNS:     None                                                         //
+//                                                                            //
+//  NOTES:       Will be called in ISR or thread context by base decoders     //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+
+void  mvd_kernel_hw_isr_event ( u_int32            uMaloneIdx,
+                                u_int32 *          puIrqStatus )
+{
+  DECODER_KERNEL_LIB_ISR_EVENT_DATA sData;
+  
+  sData.uMalIdx         = uMaloneIdx;
+  sData.uIrqStatus[0x0] = puIrqStatus[0x0];
+  sData.uIrqStatus[0x1] = puIrqStatus[0x1];
+  sData.uIrqStatus[0x2] = puIrqStatus[0x2];
+  
+  gDecKernelLib.pfCallback[uMaloneIdx] ( &sData );
+  
+}
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/DecKernelLib.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/DecKernelLib.h
new file mode 100755
index 0000000..b924aa4
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/DecKernelLib.h
@@ -0,0 +1,121 @@
+/////////////////////////////////////////////////////////////////////////////////
+/// @author    Copyright (c) 2015 Amphion Semiconductor Ltd
+/////////////////////////////////////////////////////////////////////////////////
+// The code contained herein is licensed under the GNU General Public
+// License. You may obtain a copy of the GNU General Public License
+// Version 2 or later at the following locations:
+//
+// http://www.opensource.org/licenses/gpl-license.html
+// http://www.gnu.org/copyleft/gpl.html
+////////////////////////////////////////////////////////////////////////////////
+//
+/// @file      DecLib.h
+/// @brief     Main DecLib public header file
+/// @ingroup   DecLib
+/// @defgroup  DecLib DecLib API
+/// @{
+///            Decoder Library API level - Exported header file
+///            called by the Player level and passing data back
+///            via registered callbacks
+/// @}
+//
+/////////////////////////////////////////////////////////////////////////////////
+// $Id:
+/////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "basetype.h"
+#include "mediaip_fw_types.h"
+#include "pal.h"
+#include "DecKernelLibCfg.h"
+
+#ifndef _DECODER_KLIB_H_
+#define _DECODER_KLIB_H_
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+#define DECLIB_FSID_INVALID         0xbad
+
+#define DECLIB_DBG_SESSION_STATE    0x1
+#define DECLIB_DBG_DECODER_STATE    0x2
+#define DECLIB_DBG_SYNTAX_ELEMENT   0x4
+#define DECLIB_DBG_REG_ACCESS       0x8
+#define DECLIB_DBG_CQ_FIFO          0x10
+
+#define DECLIB_DBG_REG_HIF          0x1
+#define DECLIB_DBG_REG_SIF          0x2
+#define DECLIB_DBG_REG_CTX          0x4
+#define DECLIB_DBG_REG_RPR          0x8
+#define DECLIB_DBG_REG_SPP          0x10
+#define DECLIB_DBG_REG_DEC          0x20
+#define DECLIB_DBG_REG_CQ           0x40
+#define DECLIB_DBG_REG_RSB          0x80
+#define DECLIB_DBG_REG_DFE          0x80
+
+#ifdef MVD_DIAG_LOG_REG_ACCESS
+#define DECLIB_DBG_MASK             0x1F
+#define DECLIB_DBG_REG_MASK         0x1FF
+#else
+#define DECLIB_DBG_MASK             0x7
+#define DECLIB_DBG_REG_MASK         0x0
+#endif
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Types
+/////////////////////////////////////////////////////////////////////////////////
+
+typedef struct
+{
+  u_int32 uMalIdx;
+  u_int32 uIrqStatus[0x3];
+
+} DECODER_KERNEL_LIB_ISR_EVENT_DATA;
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Function definitions
+/////////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////
+/// Decoder Event info callback
+
+typedef void ( * DecKernelLib_Isr_Callback_t )( DECODER_KERNEL_LIB_ISR_EVENT_DATA *ptEventData );
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Configuration Type
+/////////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////
+/// DecoderLib Configuration structure
+
+typedef struct
+{
+  /* Malone hardware details */
+  u_int32                         uNumMalones;
+  u_int32                         uMaloneHifOffset[DECODERLIB_MAX_MALONES];
+  uint_addr                       uMaloneBaseAddr[DECODERLIB_MAX_MALONES];
+  u_int32                         uMaloneIrqPin[DECODERLIB_MAX_MALONES][0x2];
+  u_int32                         uNumDPVUnits;        /* 0 or 1 - could infer this from base address but for clarity */
+  uint_addr                       uDPVBaseAddr;
+  u_int32                         uDPVIrqPin;
+} DECODERLIB_KERNEL_CFG, * pDECODERLIB_KERNEL_CFG;
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Function Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS decoder_kernel_lib_init ( DECODERLIB_KERNEL_CFG * pCfg );
+
+MEDIAIP_FW_STATUS decoder_kernel_lib_term ( void );
+
+MEDIAIP_FW_STATUS decoder_kernel_lib_register_isr_callback ( u_int32 uMalIdx,
+                                                             DecKernelLib_Isr_Callback_t pfCallback );
+
+
+#endif /* _DECODER_KLIB_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd.h
new file mode 100755
index 0000000..956f69e
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd.h
@@ -0,0 +1,157 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Author    : Media IP FW team
+  File name : mvd.h
+  Notes     : Replaces misnamed "global.h"
+
+ ***********************************************/
+
+#ifndef _MVD_H_
+#define _MVD_H_
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "basetype.h"
+#include "DecKernelLibCfg.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Variables
+/////////////////////////////////////////////////////////////////////////////////
+extern u_int32 uMvdKernelIrqPin[DECODERLIB_MAX_MALONES][0x2];
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////
+// Register access model
+//
+
+///////////////////////////////////////////////////
+// This is the option used for most builds
+
+#ifndef MVD_DEBUG_REG_ACCESS
+#if TARGET_LEVEL == CMODEL
+  extern u_int32 dec_model_malone_reg_write ( u_int32 * puRegAddr, u_int32   uWrtData );
+  extern u_int32 dec_model_malone_reg_read  ( u_int32 * puRegAddr, u_int32   uReadData );
+  
+	#define APB_REGISTER_WRITE(a,b) dec_model_malone_reg_write ( ( u_int32 * )a, ( u_int32  )b )
+  #define APB_REGISTER_READ(a,b)  b = *a; dec_model_malone_reg_read  ( ( u_int32 * )a, ( u_int32  )b ) 
+  #define APB_REG_WRITE(a,b)      dec_model_malone_reg_write ( ( u_int32 * )&a, ( u_int32  )b )
+  #define APB_REG_READ(a,b)       b = a; dec_model_malone_reg_read  ( ( u_int32 * )&a,  ( u_int32 )b ) 
+#else  
+
+
+
+#if 0
+#include "VPU_debug.h"
+//static u_int32 c;
+
+#define APB_REGISTER_WRITE(a,b) c = b; *a = c; printk("write reg 0x%p, val 0x%x, in %s\n", a, c, __FUNCTION__)
+#define APB_REGISTER_READ(a,b)  c = *a; b = c; printk("read reg 0x%p, val 0x%x, in %s\n", a, c, __FUNCTION__)
+#define APB_REG_WRITE(a,b)      c = b; a = c; printk("write reg 0x%p, val 0x%x, in %s\n", &a, c, __FUNCTION__)
+#define APB_REG_READ(a,b)       c = a; b = c; printk("read reg 0x%p, val 0x%x, in %s\n", &a, c, __FUNCTION__)
+#else
+
+  #define APB_REGISTER_WRITE(a,b) *a = b
+  #define APB_REGISTER_READ(a,b)  b = *a
+  #define APB_REG_WRITE(a,b)      a = b
+  #define APB_REG_READ(a,b)       b = a
+#endif  
+
+#endif
+#else
+  // Store reg acesses in simple debug array for dumping from debugger
+  extern void decoderlib_debug_reg( volatile u_int32 * puRegAddr, u_int32 uVal);
+  #define APB_REGISTER_WRITE(a,b) *a = b
+  #define APB_REGISTER_READ(a,b)  b = *a
+  #define APB_REG_WRITE(a,b)      decoderlib_debug_reg(( u_int32 * )&a,b)
+  #define APB_REG_READ(a,b)       b = a
+#endif
+
+
+#ifdef MVD_DIAG_LOG_REG_ACCESS
+
+#define DIAG_CQ_ID DECLIB_DBG_REG_CQ
+
+extern void    decoderlib_dbg_core_log_write ( volatile u_int32 * puRegAddr, u_int32 uVal, void * pMVDHw, u_int32 uAuxData, bool bActive );
+extern void    decoderlib_dbg_core_log_read  ( volatile u_int32 * puRegAddr, u_int32 *puVal, void * pMVDHw, u_int32 uAuxData, bool bActive );
+extern u_int32 decoderlib_dbg_get_reg_mask ( u_int32 uStrIdx );
+
+#define MVD_REG_WRITE(pMvdHw,aux,addr,val)     decoderlib_dbg_core_log_write ( ( u_int32 * )&addr, val, ( void * )pMvdHw, aux, gbLogRegAccessActive )
+#define MVD_REG_READ(pMvdHw,aux,addr,val)      decoderlib_dbg_core_log_read  ( ( u_int32 * )&addr, &val, ( void * )pMvdHw, 0x0, gbLogRegAccessActive )
+#define MVD_ADDRESS_WRITE(pMvdHw,aux,addr,val) decoderlib_dbg_core_log_write ( ( u_int32 * )addr, val, ( void * )pMvdHw, aux, gbLogRegAccessActive )
+#define MVD_ADDRESS_READ(pMvdHw,aux,addr,val)  decoderlib_dbg_core_log_read  ( ( u_int32 * )addr,  &val, ( void * )pMvdHw, 0x0, gbLogRegAccessActive )
+
+#else
+
+#define MVD_REG_WRITE(pMvdHw,aux,addr,val)     APB_REG_WRITE(addr,val)
+#define MVD_REG_READ(pMvdHw,aux,addr,val)      APB_REG_READ(addr,val)
+#define MVD_ADDRESS_WRITE(pMvdHw,aux,addr,val) APB_REGISTER_WRITE(addr,val)
+#define MVD_ADDRESS_READ(pMvdHw,aux,addr,val)  APB_REGISTER_READ(addr,val)
+
+#endif /* MVD_DIAG_LOG_REG_WRITES */
+
+#define APB_REGISTER_POLL(s,p,v,m)
+#define APB_SEEK_EVENT(e)
+#define APB_REG_SET(a,m,b)  ((a)) = ((((a)) & ~(m)) | ((b) & (m)))
+
+///////////////////////////
+// System functions
+//
+
+///////////////////////////
+// MULT_U(a,b)
+//
+// a * b
+
+#define MULT_U(a,b) (a)*(b)
+
+///////////////////////////
+// LDIV_MOD_U(a,b)
+//
+// a / b,  mod = a % b
+
+#define LDIV_MOD_U(a,b,mod) (a)/(b), mod = (a)%(b)
+
+///////////////////////////
+// MEMORY_BLOCK_COPY(a,b,c,d)
+//
+// a : int - 1 for load, 0: store
+// b : int - size of transfer in bytes
+// c : void * - source address
+// d : void * - destination address
+
+#define MEMORY_BLOCK_COPY(a,b,c,d) pal_memcpy(d,c,b)
+
+//////////////////////////////////////////////////
+// Implementation running defines
+//
+
+#define FORCE_DECODE_HANDLE_IRQ   { \
+                                    pgCtrlMVDHw->uForceFIQ = 1; \
+                                    if ( pgCtrlMVDHw->uMaloneID == 0 ) \
+                                    { \
+                                      pal_int_set ( uDecLibIrqPin[0x0][0x0] ); \
+                                    } \
+                                    else \
+                                    {  \
+                                      pal_int_set ( uDecLibIrqPin[0x1][0x0] ); \
+                                    } \
+                                  }
+
+#endif /* _MVD_H_ */
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_reg_map.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_reg_map.h
new file mode 100755
index 0000000..5464cd2
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_reg_map.h
@@ -0,0 +1,1676 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Author    : VCodec FW team
+  File name : mvd_reg_map.h
+  Function  : Register map file
+
+ ************************************************/
+
+#ifndef _MVD_REG_MAP_H_
+#define _MVD_REG_MAP_H_
+
+/////////////////////////////////////////////////////////////////
+// HIF address index
+//
+
+typedef struct MvdHwRegHifMapTag
+{
+  // 0x00 --> 0x0f
+  MvdHwReg control;
+  MvdHwReg status;
+  MvdHwReg config;
+  MvdHwReg config2;
+  MvdHwReg test;
+  MvdHwReg host_interrupt_enable;
+  MvdHwReg interrupt_status;
+  MvdHwReg fast_interrupt_enable;
+  MvdHwReg dq_unused[4];
+  MvdHwReg security;
+  MvdHwReg format_disable;
+  MvdHwReg system_data;
+  MvdHwReg spp_security;
+  // 0x10 --> 0x1f
+  MvdHwReg dfe_security;
+  MvdHwReg hif_unused[15];
+
+  // the rest are not used
+  // MvdHwReg unused_0x60[96];
+
+} MvdHwRegHifMap;
+
+
+/////////////////////////////////////////////////////////////////
+// SIF address index
+//
+
+typedef struct MvdHwRegSifMapTag
+{
+  // 0x00 --> 0x0f
+  MvdHwReg semaphore_read;      // R
+  MvdHwReg intr_mask_read;      // R
+  MvdHwReg semaphore_set;       // W
+  MvdHwReg semaphore_clr;       // W
+  MvdHwReg intr_mask_set;       // W
+  MvdHwReg intr_mask_clr;       // W
+  MvdHwReg host_data0_reg;      // R
+  MvdHwReg msd_data0_reg;       // R/W
+  MvdHwReg host_data1_reg;      // R
+  MvdHwReg msd_data1_reg;       // R/W
+  MvdHwReg frame_active_count;
+  MvdHwReg slice_active_count;
+  MvdHwReg rbsp_bytes_count;
+  MvdHwReg sib_wait_count;
+  MvdHwReg dpb_read_count;
+  MvdHwReg mpr_wait_count;
+  // 0x10 --> 0x1f
+  MvdHwReg intr3_control;       // W/R
+  MvdHwReg dpb_fs_size;         // R/W
+  MvdHwReg dpb_frm_size;        // R/W
+  MvdHwReg dpb_fs_size_ext;     // R/W
+  MvdHwReg rsb_mprr_mprc_base;  // R/W
+  MvdHwReg rsb_bsd_dbfc_base;   // R/W
+  MvdHwReg rsb_pwt_pxd_base;    // R/W
+  MvdHwReg frm_dangling;        // W
+  MvdHwReg rsb_dfe_base;        // R/W
+  MvdHwReg dpb_lut_load;        // W
+  MvdHwReg bbb_crc;             // R
+  MvdHwReg load_dpb_numb;       // W
+  MvdHwReg dpb_frm_size_ext;    // R/W
+  MvdHwReg dec_status;          // R
+  MvdHwReg mbq_full_count;
+  MvdHwReg mbq_empty_count;
+  // 0x20 --> 0x2f
+  MvdHwReg dispq_push[16];
+  // 0x30 --> 0x3f
+  MvdHwReg intr3_status;
+  MvdHwReg intr3_force;
+  MvdHwReg bs2rbsp_status;      // R
+  MvdHwReg bs2rbsp_feed_control;// W/R
+  MvdHwReg bs2rbsp_scode;       // R
+  MvdHwReg bs2rbsp_scdctrl;     // W/R
+  MvdHwReg rpr_wr_uv_offset;
+  MvdHwReg dispd_cnt_tag;       // R
+  MvdHwReg frame_request;       // R
+  MvdHwReg intr2_control;       // W/R
+  MvdHwReg intr2_status;        // R/W
+  MvdHwReg intr2_force;
+  MvdHwReg control;             // W/R
+  MvdHwReg intr_status;         // R/W
+  MvdHwReg intr_force;
+  MvdHwReg soft_reset;          // W
+  // 0x40 --> 0x4f
+  MvdHwReg pes_setup;           // W/R
+  MvdHwReg pes_status;          // W/R
+  MvdHwReg pes_ctrl;            // W
+  MvdHwReg pes_set_state;       // W
+  MvdHwReg pes_peek_data;       // R
+  MvdHwReg pes_read_data;       // R
+  MvdHwReg pes_pts;             // R
+  MvdHwReg pes_dts;             // R
+  MvdHwReg bs_read;             // R
+  MvdHwReg dpbmc_setup;         // W
+  MvdHwReg dpbmc_crc_data;      // R
+  MvdHwReg rsb_ctrl_stat;
+  MvdHwReg ext_rsb_base;
+  MvdHwReg ext_xfr_param;
+  MvdHwReg vmif_rsb_arb_ctrl;
+  MvdHwReg vmif_stride;
+
+  // 0x50 --> 0x5f
+  MvdHwReg vmif_uv_offset;
+  MvdHwReg vmif_options;
+  MvdHwReg vmif_base_offset;
+  MvdHwReg vmif_mbi_cache;
+  MvdHwReg lmem_config;
+  MvdHwReg qp_acc;
+  MvdHwReg vmif_mbi_xmem;
+  MvdHwReg vmif_4kcache_stride;
+  MvdHwReg dpbmc_setup2;
+  MvdHwReg rpr_rd_uv_offset;
+  MvdHwReg slow_feed_wt_val;
+  MvdHwReg unused_0x5b;
+  MvdHwReg unused_0x5c;
+  MvdHwReg dpbmc_crc2_data;     // R
+  MvdHwReg errgen_config;       // W
+  MvdHwReg errgen_seeds;        // W
+  // 0x60 --> 0x6f
+  MvdHwReg bsdma_command;
+  MvdHwReg bsdma_options;
+  MvdHwReg bsdma_status;
+  MvdHwReg bsdma_des;
+  MvdHwReg bsdma_bwp;
+  MvdHwReg bsdma_brp;
+  MvdHwReg bsdma_bsa;
+  MvdHwReg bsdma_bea;
+  MvdHwReg bsdma_blw;
+  MvdHwReg bsdma_bup;
+  MvdHwReg bsdma_peek;
+  MvdHwReg bsdma_bhw;
+  MvdHwReg bsdma_trc;
+  MvdHwReg bsdma_ext_options;
+  MvdHwReg bsdma_lvl;
+  MvdHwReg unused_0x6f;
+  // 0x70 --> 0x7f
+  // MvdHwReg unused_16[16];
+} MvdHwRegSifMap;
+
+/////////////////////////////////////////////////////////////////
+// Context Reg Map
+//
+
+#define MVD_CTX_POC_RESTORE_WORDS     62
+
+typedef struct MvdHwRegCtxMapTag
+{
+  // 0x00 --> 0x0f
+  MvdHwReg ctx_command;
+  MvdHwReg ctx_next_sf;
+  MvdHwReg ctx_spp_command;
+  MvdHwReg align_7[4];
+  MvdHwReg ctx_status;
+  MvdHwReg align_8[8];
+
+  // 0x10 --> 0x1f
+  MvdHwReg ctx_addr_spp[16];    /*  PreParser (if it is configured in) */
+//  MvdHwReg align_9[4];
+
+  // 0x20 --> 0x2f
+  MvdHwReg ctx_addr_bbb[2];     /* Active BBB                          */
+  MvdHwReg align_10[14];
+
+  // 0x30 --> 0x3f
+  MvdHwReg ctx_addr_bsi[13];    /* SCD/PES/FIFO                        */
+  MvdHwReg align_11[3];
+
+  // 0x40 --> 0x7f
+  MvdHwReg h264_poc_restore[MVD_CTX_POC_RESTORE_WORDS];
+  MvdHwReg unused_poc[64-MVD_CTX_POC_RESTORE_WORDS];
+
+} MvdHwRegCtxMap;
+
+
+/////////////////////////////////////////////////////////////////
+// Resampler Reg Map
+//
+
+typedef struct MvdHwRegRprMapTag
+{
+  // 0x0 --> 0xf
+  MvdHwReg rpr_status_addr;   // R
+  MvdHwReg rpr_ctl_start;
+  MvdHwReg rpr_in_size;
+  MvdHwReg rpr_out_size;
+  MvdHwReg rpr_fill_value;
+  MvdHwReg rpr_ax_ini_y;
+  MvdHwReg rpr_ax_ini_uv;
+  MvdHwReg rpr_ax_inc;
+  MvdHwReg rpr_iuyl_num_y;
+  MvdHwReg rpr_iuyl_num_uv;
+  MvdHwReg rpr_iuyl_inc;
+  MvdHwReg rpr_options_addr;
+  MvdHwReg csc_status;
+  MvdHwReg csc_ctrl_start;
+  MvdHwReg csc_fs_size;
+  MvdHwReg csc_fs_idc;
+  MvdHwReg csc_fs_stride;
+  MvdHwReg rpr_rd_fs_stride;
+  MvdHwReg rpr_wr_fs_stride;
+  MvdHwReg dpv_status;
+  MvdHwReg dpv_ctrl_start;
+  MvdHwReg dpv_fs_size;
+  MvdHwReg dpv_init_val;
+  MvdHwReg dpv_crc_val;
+
+  // approx 1KB space not used (1KB - rpr register)
+  // MsdHwReg unused_0x90[240];
+
+} MvdHwRegRprMap;
+
+/////////////////////////////////////////////////////////////////
+// RC4 Decryption Reg Map
+//
+
+typedef struct MvdHwRegRC4MapTag
+{
+
+  MvdHwReg Key0Word0;
+  MvdHwReg Key0Word1;
+  MvdHwReg Key0Word2;
+  MvdHwReg Key0Word3;
+  MvdHwReg Key1Word0;
+  MvdHwReg Key1Word1;
+  MvdHwReg Key1Word2;
+  MvdHwReg Key1Word3;
+  MvdHwReg RC4Enable;
+  MvdHwReg unused_rc4_0[12-9];
+  MvdHwReg RC4Ctx0;
+  MvdHwReg RC4Ctx1;
+  MvdHwReg RC4Ctx2;
+  MvdHwReg unused_rc4_1;
+
+} MvdHwRegRC4Map;
+
+
+/////////////////////////////////////////////////////////////////
+// Black Bar Detector Reg Map
+//
+/*-- BBD registers (common to all formats)                            */
+
+typedef struct MvdHwRegBbdMapTag
+{
+  MvdHwReg bbd_cfg_ctrl;
+  MvdHwReg bbd_logo_width;
+  MvdHwReg bbd_pix_thr;
+  MvdHwReg bbd_s_thr_row;
+  MvdHwReg bbd_p_thr_row;
+  MvdHwReg bbd_s_thr_logo_row;
+  MvdHwReg bbd_p_thr_logo_row;
+  MvdHwReg bbd_s_thr_col;
+  MvdHwReg bbd_p_thr_col;
+  MvdHwReg bbd_chr_thr;
+  MvdHwReg bbd_excl_win_mb;
+  MvdHwReg unused;
+  MvdHwReg bbd_hor_active;
+  MvdHwReg bbd_ver_active;
+  MvdHwReg bbd_logo_active;
+  MvdHwReg bbd_botprev_active;
+  MvdHwReg bbd_min_col_proj;
+  MvdHwReg bbd_min_row_proj;
+
+
+} MvdHwRegBbdMap;
+
+/////////////////////////////////////////////////////////////////
+// Debug Reg Map
+//
+
+typedef struct MvdHwRegDbgMapTag
+{
+  // 0x0 --> 0x1f
+  union
+  {
+    MvdHwReg msk0_lo;
+    MvdHwReg fifo0;
+    MvdHwReg status0;
+  } fifo0_up;
+  union
+  {
+    MvdHwReg msk0_hi;
+    MvdHwReg fifo1;
+    MvdHwReg status1;
+  } fifo1_up;
+  union
+  {
+    MvdHwReg msk1_lo;
+    MvdHwReg fifo2;
+    MvdHwReg status2;
+  } fifo2_up;
+  union
+  {
+    MvdHwReg msk1_hi;
+    MvdHwReg fifo3;
+    MvdHwReg status3;
+  } fifo3_up;
+  union
+  {
+    MvdHwReg msk2_lo;
+    MvdHwReg fifo4;
+    MvdHwReg status4;
+  } fifo4_up;
+  union
+  {
+    MvdHwReg msk2_hi;
+    MvdHwReg fifo5;
+    MvdHwReg status5;
+  } fifo5_up;
+  union
+  {
+    MvdHwReg mode;
+    MvdHwReg fifo6;
+    MvdHwReg status6;
+  } fifo6_up;
+  union
+  {
+    MvdHwReg unused2;
+    MvdHwReg fifo7;
+    MvdHwReg status7;
+  } fifo7_up;
+  union
+  {
+    MvdHwReg crc0;
+    MvdHwReg fifo8;
+    MvdHwReg status8;
+  } crc0_up;
+  union
+  {
+    MvdHwReg crc1;
+    MvdHwReg fifo9;
+    MvdHwReg status9;
+  } crc1_up;
+  union
+  {
+    MvdHwReg crc2;
+    MvdHwReg fifo10;
+    MvdHwReg status10;
+  } crc2_up;
+  union
+  {
+    MvdHwReg crc3;
+    MvdHwReg fifo11;
+    MvdHwReg status11;
+  } crc3_up;
+  union
+  {
+    MvdHwReg crc4;
+    MvdHwReg fifo12;
+    MvdHwReg status12;
+  } crc4_up;
+  union
+  {
+    MvdHwReg crc5;
+    MvdHwReg fifo13;
+    MvdHwReg status13;
+  } crc5_up;
+  union
+  {
+    MvdHwReg crc6;
+    MvdHwReg fifo14;
+    MvdHwReg status14;
+  } crc6_up;
+  union
+  {
+    MvdHwReg crc7;
+    MvdHwReg clr_crc;
+    MvdHwReg fifo15;
+    MvdHwReg status15;
+  } crc7_up;
+  union
+  {
+    MvdHwReg crc8;
+    MvdHwReg fifo16;
+    MvdHwReg status16;
+  } crc8_up;
+  union
+  {
+    MvdHwReg crc9;
+    MvdHwReg fifo17;
+    MvdHwReg status17;
+  } crc9_up;
+  union
+  {
+    MvdHwReg crc10;
+  } crc10_up;
+  union
+  {
+    MvdHwReg crc11;
+  } crc11_up;
+
+  MvdHwReg crc12;
+  MvdHwReg crc13;
+  MvdHwReg crc14;
+  MvdHwReg dbg_unused_31to23[9];
+
+} MvdHwRegDbgMap;
+
+/////////////////////////////////////////////////////////////////
+//Command Queues Reg Map
+//
+
+typedef struct MvdHwRegCqMapTag
+{
+
+  MvdHwReg cq_status;
+  MvdHwReg cq_grp;
+  MvdHwReg cq_clr;
+  MvdHwReg cq_data;
+  MvdHwReg cq_data_last;
+  MvdHwReg cq_data_mask;
+  MvdHwReg cq_data_test;
+  MvdHwReg cq_opts;
+  MvdHwReg cq_push;
+  MvdHwReg cq_dummy;
+  MvdHwReg cq_cmdq_base;
+  MvdHwReg cq_cmdq_amax;
+  MvdHwReg cq_cmdq_wptr;
+  MvdHwReg cq_cmdq_rptr;
+  MvdHwReg cq_cmdq_level;
+  MvdHwReg cq_rdq_base;
+  MvdHwReg cq_rdq_amax;
+  MvdHwReg cq_rdq_wptr;
+  MvdHwReg cq_rdq_rptr;
+  MvdHwReg cq_rdq_level;
+  MvdHwReg cq_poll_param;
+  MvdHwReg cq_grp_level;
+  MvdHwReg cq_exec;
+  MvdHwReg cq_lwm;
+  MvdHwReg cq_dataq_base;
+  MvdHwReg cq_dataq_amax;
+  MvdHwReg cq_dataq_rptr;
+  MvdHwReg cq_special_en;
+  MvdHwReg cq_wdata_opt;
+  MvdHwReg cq_sgrp_base_addr;
+  MvdHwReg cq_sgrp_num_cmds;
+  MvdHwReg cq_status2;
+
+} MvdHwRegCqMap;
+
+
+/////////////////////////////////////////////////////////////////
+// Stream Preparser Reg Map
+//
+
+typedef struct MvdHwRegSppMapTag
+{
+  // 0x0 --> 0x07
+  MvdHwReg bbb_showbits;        // R
+  MvdHwReg bbb_status;          // R
+  MvdHwReg config;              // W/R
+  MvdHwReg bs2rbsp_status;      // R
+  MvdHwReg bs2rbsp_feed_control;// W/R
+  MvdHwReg bs2rbsp_scode;       // R
+  MvdHwReg bs2rbsp_scdctrl;     // W/R
+  MvdHwReg bbb_crc;             // R
+
+  // 0x08 --> 0x0f
+  MvdHwReg pes_setup;           // W/R
+  MvdHwReg pes_status;          // W/R
+  MvdHwReg pes_ctrl;            // W
+  MvdHwReg pes_set_state;       // W
+  MvdHwReg pes_peek_data;       // R
+  MvdHwReg pes_read_data;       // R
+  MvdHwReg pes_pts;             // R
+  MvdHwReg pes_dts;             // R
+
+  // 0x10 --> 0x1f
+  MvdHwReg bsdma_command;
+  MvdHwReg bsdma_options;
+  MvdHwReg bsdma_status;
+  MvdHwReg bsdma_des;
+  MvdHwReg bsdma_bwp;
+  MvdHwReg bsdma_brp;
+  MvdHwReg bsdma_bsa;
+  MvdHwReg bsdma_bea;
+  MvdHwReg bsdma_blw;
+  MvdHwReg bsdma_bup;
+  MvdHwReg bsdma_peek;
+  MvdHwReg bsdma_bhw;
+  MvdHwReg bsdma_trc;
+  MvdHwReg bsdma_ext_options;
+  MvdHwReg bsdma_lvl;
+  MvdHwReg unused_0x1f;
+
+  // 0x20 --> 0x3f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+
+  // 0x40 --> 0x4f
+  MvdHwReg egd_ue;
+  MvdHwReg egd_se;
+  MvdHwReg egd_me_intra;
+  MvdHwReg egd_me_inter;
+  MvdHwReg data_reg;            /* R/W */
+  MvdHwReg num_bits_pulled;     /* R   */
+  MvdHwReg bit_puller;
+  MvdHwReg unused_spp1[16-7];
+
+  // 0x50 --> 0x5f
+  MvdHwReg Key0Word0;
+  MvdHwReg Key0Word1;
+  MvdHwReg Key0Word2;
+  MvdHwReg Key0Word3;
+  MvdHwReg Key1Word0;
+  MvdHwReg Key1Word1;
+  MvdHwReg Key1Word2;
+  MvdHwReg Key1Word3;
+  MvdHwReg RC4Enable;
+  MvdHwReg unused_rc4_0[12-9];
+  MvdHwReg RC4Ctx0;
+  MvdHwReg RC4Ctx1;
+  MvdHwReg RC4Ctx2;
+  MvdHwReg unused_rc4_1;
+
+} MvdHwRegSppMap;
+
+/////////////////////////////////////////////////////////////////
+// Stream Frame Buffer Compression Reg Map
+//
+
+typedef struct MvdHwRegFbcMapTag
+{
+  // 0x0 --> 0x0f
+  MvdHwReg fbc_start;
+  MvdHwReg fbc_config;
+  MvdHwReg fbc_param1;
+  MvdHwReg fbc_param2;
+  MvdHwReg fbc_ctb_tile_px4;
+  MvdHwReg fbc_ctb_tile_py4;
+  MvdHwReg fbc_ctb_tile_px8;
+  MvdHwReg fbc_ctb_tile_py8;
+  MvdHwReg fbc_ctb_tile_px9_y10;
+  MvdHwReg fbc_ot_offset;
+  MvdHwReg fbc_field_offset;
+  MvdHwReg fbc_uv_offset;
+  MvdHwReg fbc_field_list;
+  MvdHwReg fbc_luma_pad_list;
+  MvdHwReg fbc_chroma_pad_list;
+  MvdHwReg fbc_write_count;
+  MvdHwReg fbc_read_count_0;
+  MvdHwReg fbc_read_count_1;
+  MvdHwReg fbc_write_chksum;
+  MvdHwReg fbc_read_chksum_0;
+  MvdHwReg fbc_read_chksum_1;
+  MvdHwReg fbc_param3;
+  MvdHwReg fbc_fs_height;
+  MvdHwReg fbc_read_dbg_gen;
+  MvdHwReg fbc_read_dbg_blk;
+  MvdHwReg fbd_ot_offset;
+  MvdHwReg fbd_fld_offset;
+  MvdHwReg fbd_uv_offset;
+  MvdHwReg fbc_unused[62-28];
+  MvdHwReg unused_fbc_0[2];
+} MvdHwRegFbcMap;
+
+
+/////////////////////////////////////////////////////////////////
+// Decoupled Front End Register Map
+// ( 1K incl debug registers )
+
+typedef struct MvdHwRegDfeMapTag
+{
+  // 0x0 --> 0x07
+  MvdHwReg bbb_showbits;        // R
+  MvdHwReg bbb_status;          // R
+  MvdHwReg config;              // W/R
+  MvdHwReg bs2rbsp_status;      // R
+  MvdHwReg bs2rbsp_feed_control;// W/R
+  MvdHwReg bs2rbsp_scode;       // R
+  MvdHwReg bs2rbsp_scdctrl;     // W/R
+  MvdHwReg bbb_crc;             // R
+
+  // 0x08 --> 0x0f
+  MvdHwReg pes_setup;           // W/R
+  MvdHwReg pes_status;          // W/R
+  MvdHwReg pes_ctrl;            // W
+  MvdHwReg pes_set_state;       // W
+  MvdHwReg pes_peek_data;       // R
+  MvdHwReg pes_read_data;       // R
+  MvdHwReg pes_pts;             // R
+  MvdHwReg pes_dts;             // R
+
+  // 0x10 --> 0x1f
+  MvdHwReg bsdma_command;
+  MvdHwReg bsdma_options;
+  MvdHwReg bsdma_status;
+  MvdHwReg bsdma_des;
+  MvdHwReg bsdma_bwp;
+  MvdHwReg bsdma_brp;
+  MvdHwReg bsdma_bsa;
+  MvdHwReg bsdma_bea;
+  MvdHwReg bsdma_blw;
+  MvdHwReg bsdma_bup;
+  MvdHwReg bsdma_peek;
+  MvdHwReg bsdma_bhw;
+  MvdHwReg bsdma_trc;
+  MvdHwReg bsdma_ext_options;
+  MvdHwReg bsdma_lvl;
+  MvdHwReg unused_0x1f;
+
+  /* BSD address, 0x20 --> 0x5f */
+  MvdHwReg bsd_options;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_ctb_coord;
+  MvdHwReg bsd_slice_start;
+  MvdHwReg bsd_dec_param1;
+  MvdHwReg bsd_dec_param2;
+  MvdHwReg bsd_dec_ctb_cnt;
+  MvdHwReg bsd_dec_err_ctb_cnt;
+  MvdHwReg bsd_dec_ctb_qp_sum;
+
+  MvdHwReg Unused_9;
+  MvdHwReg Unused_A;
+
+  MvdHwReg bsd_ue;
+  MvdHwReg bsd_se;
+  MvdHwReg Unused_D;
+  MvdHwReg Unused_E;
+  MvdHwReg bsd_data;
+
+  MvdHwReg Unused_10;
+  MvdHwReg bsd_ctb_tile_px4;
+  MvdHwReg bsd_ctb_tile_py4;
+  MvdHwReg bsd_ctb_tile_px8;
+  MvdHwReg bsd_ctb_tile_py8;
+  MvdHwReg bsd_ctb_tile_px9_y10;
+  MvdHwReg bsd_sc_list_usage;
+  MvdHwReg bsd_sc_list_base;
+  MvdHwReg bsd_sc_list_idx[4];
+  MvdHwReg bsd_ei_flags_mask;
+  MvdHwReg bsd_bit_puller;
+  MvdHwReg bsd_is_trailing;
+  MvdHwReg bsd_bbb_status;
+
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+
+  /* 0x60 --> 0x6f */
+  MvdHwReg Key0Word0;
+  MvdHwReg Key0Word1;
+  MvdHwReg Key0Word2;
+  MvdHwReg Key0Word3;
+  MvdHwReg Key1Word0;
+  MvdHwReg Key1Word1;
+  MvdHwReg Key1Word2;
+  MvdHwReg Key1Word3;
+  MvdHwReg RC4Enable;
+  MvdHwReg unused_rc4_0[12-9];
+  MvdHwReg RC4Ctx0;
+  MvdHwReg RC4Ctx1;
+  MvdHwReg RC4Ctx2;
+  MvdHwReg unused_rc4_1;
+
+  /* 0x70-0x7f */
+  MvdHwReg dfe_ctx_cmd;
+  MvdHwReg unused_dfe_ctx_1;
+  MvdHwReg dfe_ctx_addr_bbb[2];     /* Active BBB                          */
+  MvdHwReg unused_dfe_ctx_2[12];
+
+  /* 0x80 --> 0x8f */
+  MvdHwReg dfe_ctx_addr_bsi[13];    /* SCD/PES/FIFO                        */
+  MvdHwReg unused_dfe_ctx_3[3];
+
+  /* 0x90 --> 0x9F */
+  MvdHwReg dfe_img_cfg;
+  MvdHwReg dfe_slice_cfg;
+  MvdHwReg dfe_frm_size;
+  MvdHwReg dfe_status;
+  MvdHwReg dfe_frm_act_count;
+  MvdHwReg dfe_slice_act_count;
+  MvdHwReg dfe_rbsp_bytes_count;
+  MvdHwReg dfe_sib_wait_count;
+  MvdHwReg dfe_bsd_wait_count;
+  MvdHwReg unused_dfe[16-9];
+
+  /* 0xA0 -> 0xBF */
+  MvdHwRegCqMap DFECQ;
+
+  /* 0xC0 -> 0xDF */
+  MvdHwReg unused_0xc0_0xdf[32];
+
+  /* 0xE0 -> 0xFF */
+  MvdHwReg dfe_dbg[32];
+
+} MvdHwRegDfeMap;
+
+/////////////////////////////////////////////////////////////////
+// Decoupled Back End Register Map
+// ( 4K incl debug registers )
+
+typedef struct MvdHwRegDbeMapTag
+{
+
+  /* TOP address, 0x00 --> 0x3f */
+  MvdHwReg image_config;            // R/W
+  MvdHwReg slice_config;            // R/W
+  MvdHwReg top_ctb_tile_info;       // R/W
+  MvdHwReg mbi_wr_base;             // R/W
+  MvdHwReg mbi_rd_base;             // R/W
+
+  MvdHwReg dec_cfg;                 // R/W             Addr in CQ : 0x605
+  MvdHwReg dbg_cfg;                 // R/W
+  MvdHwReg dbf1_cfg;                // R/W
+  MvdHwReg dbf2_cfg;                // R/W
+  MvdHwReg dbe_frm_size;            // R/W
+  MvdHwReg prb_pack_base;           // R/W
+  MvdHwReg prb_bin_cfg;             // R/W
+  MvdHwReg dcp_bin_cfg;             // R/W
+
+  MvdHwReg unused_top[64-13];
+
+  /* DBE address, 0x40 --> 0x7F */
+  MvdHwReg dbe_status;                 // R
+  MvdHwReg dbe_frm_act_count;          // R
+  MvdHwReg dbe_slice_act_count;        // R
+  MvdHwReg dbe_wait_count;             // R
+  MvdHwReg dbe_fetch_crc;              // R
+  MvdHwReg dbe_mpr_prx_wait;           // R
+  MvdHwReg dbe_pxd_prx_wait;           // R
+  MvdHwReg dbe_fch_plq_wait;           // R
+  MvdHwReg dbe_pxd_plq_wait;           // R
+  MvdHwReg dbe_mpr_wait_count;         // R
+  MvdHwReg dbe_fch_words_count;        // R
+  MvdHwReg unused_dbe[64-11];
+
+  /* MPR address, 0x80 --> 0xBF */
+  MvdHwReg mpr_config;
+  MvdHwReg mpr_slice_param;
+
+  MvdHwReg Unused_82_9F[30];
+
+  MvdHwReg mpr_list[32];
+
+  MvdHwReg Unused_0xC0_FF[64];
+
+  /* CQ address, 0x100 --> 0x11F */
+  MvdHwRegCqMap DBECQ;
+  MvdHwReg Unused_0x120_13F[32];
+
+  MvdHwReg Unused_0x140_17F[64];
+
+  MvdHwReg mpr_dbg;
+  MvdHwReg pxd_dbg;
+  MvdHwReg dbf_dbg;
+  
+  /* Not quite sure what debug is in here */
+  MvdHwReg Unused_DbeDbg[61];
+
+  MvdHwReg Unused_0x1C0_1FF[64];
+
+} MvdHwRegDbeMap;
+
+
+/////////////////////////////////////////////////////////////////
+// H.264 Reg Map
+//
+
+typedef struct MvdHwRegH264MapTag
+{
+  //------- TOP address, 0x00 --> 0x3f
+  MvdHwReg options;                 // R/W
+  MvdHwReg mbi_wr_base;             // R/W
+  MvdHwReg mbi_rd_base;             // R/W
+  MvdHwReg bli_wr_base;             // R/W
+  MvdHwReg bli_wr_stride;           // R/W
+  MvdHwReg unused_top[64-5];
+  //------- BSD address, 0x40 --> 0x7f
+  // 0x40 --> 0x4f
+  MvdHwReg bsd_dec_options;         // W/R
+  MvdHwReg bsd_dec_status;          // R
+  MvdHwReg bsd_curr_coord;
+  MvdHwReg bsd_slice_start;
+  MvdHwReg bsd_slice_param1;
+  MvdHwReg bsd_slice_param2;
+  MvdHwReg qm_dec_start;
+  MvdHwReg qm_dec_status;
+  MvdHwReg qm_load_start;
+  MvdHwReg qm_load_value;
+  MvdHwReg bsd_pwt_dec;             // W
+  MvdHwReg bsd_egd_ue;
+  MvdHwReg bsd_egd_se;
+  MvdHwReg bsd_egd_me_intra;
+  MvdHwReg bsd_egd_me_inter;
+  MvdHwReg bsd_data_reg;            // R/W
+  // 0x50 --> 0x5f
+  MvdHwReg ibb_buf_mode;
+  MvdHwReg ibb_buf_ctrl;
+  MvdHwReg ibb_buf_status;
+  MvdHwReg bsd_image_init;
+  MvdHwReg unused_bsd_0[4];
+  MvdHwReg bsd_pause;
+  MvdHwReg unused_bsd[16-9-4];
+  MvdHwReg bsd_err_mask;
+  MvdHwReg bsd_bit_puller;
+  MvdHwReg bsd_is_trailing;
+  MvdHwReg bsd_bbb_status;          // R
+  // 0x60 --> 0x7f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+  //------- MPR/PXD address
+  // 0x80 --> 0x9f
+  MvdHwReg mpr_top_poc;
+  MvdHwReg mpr_bot_poc;
+  MvdHwReg unused_mpr[32-2];
+  // 0xa0 --> 0xbf
+  MvdHwReg mpr_list[32];
+  //------- DBF address
+  // 0xc0 --> 0xff
+  MvdHwReg unused_dbf[64];
+  // 0x100 --> 0x1bf not used
+  MvdHwReg unsued_spare_128[128];
+  MvdHwReg bsd_debug;
+  MvdHwReg pxd_debug;
+  MvdHwReg arb_wr_debug;
+  MvdHwReg arb_rd_debug;
+  MvdHwReg arb_mbi_debug;
+  MvdHwReg unsued_spare[59];
+
+} MvdHwRegH264Map;
+
+/////////////////////////////////////////////////////////////////
+// VC-1 Reg Map
+//
+
+typedef struct MvdHwRegVc1dMapTag
+{
+  //------- TOP address, 0x00 --> 0x3f
+  MvdHwReg unused_gen64[64];
+  //-- BSP address, 0x40 --> 0x7f
+  // 0x40 --> 0x5f
+  union
+  {
+    MvdHwReg bsp_byte_align;
+    MvdHwReg bsp_getbits[32];
+  } get_bits;
+  // 0x60 --> 0x6f
+  MvdHwReg bsp_status;
+  MvdHwReg bsp_control;
+  MvdHwReg bsp_showbits;
+  MvdHwReg bsp_showbitsflipped;
+  MvdHwReg bsp_ignorebbblevel;
+  MvdHwReg unused_bsp11[11];
+  // 0x70 --> 0x7f
+  MvdHwReg bsp_hdrvlc_ptype;
+  MvdHwReg bsp_hdrvlc_pptype;
+  MvdHwReg bsp_hdrvlc_mvrange;
+  MvdHwReg bsp_hdrvlc_mvmode;
+  MvdHwReg bsp_hdrvlc_mvmode2;
+  MvdHwReg bsp_hdrvlc_dmvrange;
+  MvdHwReg bsp_hdrvlc_bppmode;
+  MvdHwReg bsp_hdrvlc_bppvlc2;
+  MvdHwReg bsp_hdrvlc_bppvlc6;
+  MvdHwReg bsp_hdrvlc_bfract;
+  MvdHwReg bsp_hdrvlc_refdist;
+  MvdHwReg unused_bsp5[5];
+  // 0x80 --> 0x8f
+  MvdHwReg spr_general;
+  MvdHwReg spr_stream_format1;
+  MvdHwReg spr_coded_size;
+  MvdHwReg spr_stream_format2;
+  MvdHwReg spr_entrypoint1;
+  MvdHwReg spr_range_map;
+  MvdHwReg spr_frame_type;
+  MvdHwReg spr_recon_control;
+  MvdHwReg spr_mv_control;
+  MvdHwReg spr_int_comp_fwd_topnorm;
+  MvdHwReg spr_ref_bfraction;
+  MvdHwReg spr_blk_control;
+  MvdHwReg spr_trans_data;
+  MvdHwReg spr_vop_dquant;
+  MvdHwReg spr_curref_frm_id;
+  MvdHwReg spr_curdisp_frm_id;
+  // 0x90 --> 0x9f
+  MvdHwReg spr_fwdref_frm_id;
+  MvdHwReg spr_bwdref_frm_id;
+  MvdHwReg spr_fieldref_ctrl_id;
+  MvdHwReg spr_auxfrmctrl;
+  MvdHwReg spr_imgstruct;
+  MvdHwReg spr_alt_frame_type;
+  MvdHwReg spr_int_comp_fwd_bot;
+  MvdHwReg spr_int_comp_bwd_top;
+  MvdHwReg spr_int_comp_bwd_bot;
+  MvdHwReg unused_spr7[7];
+  // 0xa0 --> 0xbf
+  MvdHwReg unused_spr32[32];
+  // 0xc0 --> 0xcf
+  MvdHwReg mbd_status;
+  MvdHwReg mbd_frm_start;
+  MvdHwReg mbd_fwdebug;
+  MvdHwReg mbd_mbqdebug;
+  MvdHwReg mbd_mprdebug;
+  MvdHwReg mbd_masdebug;
+  MvdHwReg mbd_bppdebug;
+  MvdHwReg mbd_dpbmcdebug;
+  MvdHwReg mbd_gendebug;
+  MvdHwReg mbd_fw_rw;
+  MvdHwReg unused_6[6];
+  // 0xd0 --> 0xdf
+  MvdHwReg mbd_error_control;
+  MvdHwReg unused_mbd15[15];
+  // 0xe0 --> 0xff;
+  MvdHwReg unused_mbd32[32];
+  //------- BPP address
+  // 0x100 --> 0x10f
+  MvdHwReg bpp_control_status;
+  MvdHwReg bpp_datain_status;
+  MvdHwReg bpp_datain_value;
+  MvdHwReg bpp_datain_possize;
+  MvdHwReg bpp_bcachetag0;
+  MvdHwReg bpp_bcachetag1;
+  MvdHwReg bpp_bcachetag2;
+  MvdHwReg unused_0x107[9];
+  // 0x110 --> 0x1bf not used
+  MvdHwReg unsued_spare[176];
+
+} MvdHwRegVc1dMap;
+
+/////////////////////////////////////////////////////////////////
+// MPEG-2 Reg Map
+//
+
+typedef struct MvdHwRegMp2dMapTag
+{
+  //------- TOP address, 0x00 --> 0x3f
+  // 0x00 --> 0x3f
+  MvdHwReg top_seq_param;
+  MvdHwReg top_frame_ptr;
+  MvdHwReg top_pic_start;
+  MvdHwReg unused_top[64-3];
+  //------- BSD address, 0x40 --> 0x7f
+  // 0x40 --> 0x5f
+  MvdHwReg bsd_show_bits;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_bbb_status;
+  MvdHwReg bsd_qm_status;
+  MvdHwReg bsd_qm_load;
+  MvdHwReg bsd_pic_param;
+  MvdHwReg bsd_slice_start;
+  MvdHwReg bsd_curr_mbcoord;
+  MvdHwReg unused_bsd[32-8];
+  // 0x60 --> 0x7f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+  // 0x80 --> 0xff
+  MvdHwReg unused_128[128];
+  //------- DBF address
+  // 0x100 --> 0x17f
+  MvdHwReg unused_dbf16[16];
+  MvdHwReg dbf_ctrl0;
+  MvdHwReg dbf_ctrl1;
+  MvdHwReg dbf_ctrl2;
+  MvdHwReg dbf_ctrl3;
+  MvdHwReg unused_dbf[128-20];
+  //------ DEBUG address
+  // 0x180 --> 0x1bf
+  MvdHwReg debug_bsd;
+  MvdHwReg debug_pxd_idct;
+  MvdHwReg debug_wr_arbiter;
+  MvdHwReg debug_rd_arbiter;
+  MvdHwReg unused_debug[64-4];
+
+} MvdHwRegMp2dMap;
+
+/////////////////////////////////////////////////////////////////
+// AVS Reg Map
+//
+
+//  `define AVSD_APB_ADDR_TOP_PREFIX      3'h1  // 0x40
+//  `define AVSD_APB_ADDR_BSD_PREFIX      3'h0  // 0x00
+//  `define AVSD_APB_ADDR_MPR_PREFIX      3'h2  // 0x80
+#define MVD_AVSD_TOP_MIN_ADDR            0x00
+#define MVD_AVSD_BSD_MIN_ADDR            0x40
+#define MVD_AVSD_MPR_MIN_ADDR            0x80
+
+//-- Top level Register address
+#define MVD_AVSD_TOP_SEQ_PARAM_ADDR      0x00  // W/R, Chroma422
+#define MVD_AVSD_TOP_FRAME_PTR_ADDR      0x01  // W/R, cur_dec_ptr, bwd_ref_ptr, fwd_ref_ptr
+#define MVD_AVSD_TOP_PICT_START_ADDR     0x02  // W/R, is_2nd_fld, top_fild_1st, coding_type, pict_struct
+#define MVD_AVSD_TOP_PICT_PARAM_ADDR     0x03  // W/R
+
+//-- BSD Register address
+#define MVD_AVSD_BSD_SHOW_BITS_ADDR      0x40  // R, show available bits (up to 31), lsb aligned
+#define MVD_AVSD_BSD_DEC_STATUS_ADDR     0x41  // R, returns {1'b0, vld_mb_y, 1'b0, vld_mb_x, VldState, vld_error, img_in_prog, slice_in_prog}
+#define MVD_AVSD_BSD_BBB_STATUS_ADDR     0x42  // R, returns {6'd0, bits_ei_flag, bbb_underflow, 6'd0, bbb_is_stuffing, bits_ended, 10'd0, num_bits_in_bbb}
+#define MVD_AVSD_BSD_SCEPB_CTRL_ADDR     0x43  // W/R, {scepb_disab, scepb_delay}
+#define MVD_AVSD_BSD_EGDUE_START_ADDR    0x44  // R, start UE decode, [0]: ready in 3 ticks, [1]: out of range(dec not performed)
+#define MVD_AVSD_BSD_EGDSE_START_ADDR    0x45  // R, start SE decode, [0]: ready in 3 ticks, [1]: out of range(dec not performed)
+#define MVD_AVSD_BSD_SLC_START_ADDR      0x46  // W/R, {24'd0, vld_recover, vld_new_mbrow}
+#define MVD_AVSD_BSD_CURR_MBCOORD_ADDR   0x47  // R/W
+#define MVD_AVSD_BSD_EGD_VALUE_ADDR      0x48  // R, exp-golumn decode value
+#define MVD_AVSD_BSD_ERRCHK_MASK_ADDR    0x49  // R/W
+#define MVD_AVSD_BSD_ERROR_STAT_ADDR     0x4a  // R, cleard at start of a slice
+
+#define MVD_AVSD_BSD_BYTE_ALIGN_ADDR     0x60
+#define MVD_AVSD_BSD_GETBITS_MIN_ADDR    0x60  // MVD_AVSD_BSD_ALIGN_BYTE_ADDR
+#define MVD_AVSD_BSD_GETBITS_MAX_ADDR    0x7f  // 31 bits
+
+//-- MPR register address
+#define MVD_AVSD_MPR_WT_PARAM0_ADDR      0x80  // R/W
+#define MVD_AVSD_MPR_WT_PARAM1_ADDR      0x81  // R/W
+#define MVD_AVSD_MPR_WT_PARAM2_ADDR      0x82  // R/W
+#define MVD_AVSD_MPR_WT_PARAM3_ADDR      0x83  // R/W
+#define MVD_AVSD_MPR_BWD_DIST_ADDR       0x84  // when P picture, use bwd0,1 as fwd0,1
+#define MVD_AVSD_MPR_FWD_DIST_ADDR       0x85  // when P picture, use fwd0,1 as fwd2,3
+#define MVD_AVSD_MPR_REF01_DIST_ADDR     0x86
+#define MVD_AVSD_MPR_REF23_DIST_ADDR     0x87
+#define MVD_AVSD_MPR_BWD_DISTIDX_ADDR    0x88  // when P picture, use bwd0,1 as fwd0,1
+#define MVD_AVSD_MPR_FWD_DISTIDX_ADDR    0x89  // when P picture, use fwd0,1 as fwd2,3
+#define MVD_AVSD_MPR_REF01_DISTIDX_ADDR  0x8a
+#define MVD_AVSD_MPR_REF23_DISTIDX_ADDR  0x8b
+#define MVD_AVSD_MPR_CONFIG_OPTS_ADDR    0x8c
+
+typedef struct MvdHwRegAvsdMapTag {
+  //------- TOP address, 0x00 --> 0x3f
+  // 0x00 --> 0x3f
+  MvdHwReg top_seq_param;
+  MvdHwReg top_frame_ptr;
+  MvdHwReg top_pict_start;
+  MvdHwReg top_pict_param;
+  MvdHwReg unused_top[64-4];
+  //------- BSD address, 0x40 --> 0x7f
+  // 0x40 --> 0x5f
+  MvdHwReg bsd_show_bits;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_bbb_status;
+  MvdHwReg bsd_scepb_ctrl;
+  MvdHwReg bsd_egdue_start;
+  MvdHwReg bsd_egdse_start;
+  MvdHwReg bsd_slc_start;
+  MvdHwReg bsd_curr_mbcoord;
+  MvdHwReg bsd_egd_value;
+  MvdHwReg bsd_errchk_mask;
+  MvdHwReg bsd_error_stat;
+  MvdHwReg bsd_qp_delta_uv;
+  MvdHwReg bsd_wqm1_low;
+  MvdHwReg bsd_wqm1_high;
+  MvdHwReg bsd_wqm2_low;
+  MvdHwReg bsd_wqm2_high;
+  MvdHwReg bsd_qp_ctr;
+  MvdHwReg unused_bsd[32-17];
+  //MvdHwReg unused_bsd[32-11];
+  // 0x60 --> 0x7f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+  //------- MPR address
+  // 0x80 --> 0xbf
+  MvdHwReg mpr_wt_param[4];
+  MvdHwReg mpr_bwd_dist;
+  MvdHwReg mpr_fwd_dist;
+  MvdHwReg mpr_ref01_dist;
+  MvdHwReg mpr_ref23_dist;
+  MvdHwReg mpr_bwd_distidx;
+  MvdHwReg mpr_fwd_distidx;
+  MvdHwReg mpr_ref01_distidx;
+  MvdHwReg mpr_ref23_distidx;
+  MvdHwReg mpr_config_opts;
+  MvdHwReg unused_mpr[64-13];
+  // 0xc0 --> 0x1bf not used
+  MvdHwReg unsued_spare[256];
+
+} MvdHwRegAvsdMap;
+
+/////////////////////////////////////////////////////////////////
+// ASPD/DIVX/JPEG Reg Map
+//
+
+//`define ASPD_APB_ADDR_TOP_PREFIX      3'h0     // 0x00
+//`define ASPD_APB_ADDR_BSD_PREFIX      3'h1     // 0x40
+//`define ASPD_APB_ADDR_MPR_PREFIX      3'h2     // 0x80
+//`define ASPD_APB_ADDR_PXD_PREFIX      3'h3     // 0xc0
+//`define ASPD_APB_ADDR_DBF_PREFIX      3'h4     // 0x100
+#define MVD_ASPD_TOP_MIN_ADDR            0x00
+#define MVD_ASPD_BSD_MIN_ADDR            0x40
+#define MVD_ASPD_MPR_MIN_ADDR            0x80
+#define MVD_ASPD_DBF_MIN_ADDR            0x100
+
+//-- Top level Register address
+#define MVD_ASPD_TOP_IMG_START_ADDR      0x00
+#define MVD_ASPD_TOP_VO_PARAM_ADDR       0x01
+#define MVD_ASPD_TOP_FRAME_PTR_ADDR      0x02   // W/R, cur_dec_ptr, bwd_ref_ptr, fwd_ref_ptr
+#define MVD_ASPD_TOP_VPARAM1_ADDR        0x03
+#define MVD_ASPD_TOP_VPARAM2_ADDR        0x04
+#define MVD_ASPD_TOP_VPARAM3_ADDR        0x05
+#define MVD_ASPD_TOP_VO_PARAM_EXT_ADDR   0x06
+
+//-- BSD Register address
+#define MVD_ASPD_BSD_SHOW_BITS_ADDR      0x40   // R, show available bits (up to 31), lsb aligned
+#define MVD_ASPD_BSD_DEC_STATUS_ADDR     0x41   // R, returns {1'b0, vld_mb_y, 1'b0, vld_mb_x, VldState, vld_error, img_in_prog, slice_in_prog}
+#define MVD_ASPD_BSD_BBB_STATUS_ADDR     0x42   // R, returns {6'd0, bits_ei_flag, bbb_underflow, 6'd0, bbb_is_stuffing, bits_ended, 10'd0, num_bits_in_bbb}
+#define MVD_ASPD_BSD_SLC_START_ADDR      0x46   // W/R, {24'd0, vld_recover, vld_new_mbrow}
+#define MVD_ASPD_BSD_CURR_MBCOORD_ADDR   0x47   // R/W
+#define MVD_ASPD_BSD_OPTIONS_ADDR        0x49   // R/W
+
+// JPEG DC Predictor registers
+#define MVD_ASPB_BSD_JPEG_CTX0_ADDR      0x4a   // R/W, must be backup when doing multiple JPEG images
+#define MVD_ASPB_BSD_JPEG_CTX1_ADDR      0x4b   // R/W, must be backup when doing multiple JPEG images
+
+#define MVD_ASPD_BSD_BYTE_ALIGN_ADDR     0x60
+#define MVD_ASPD_BSD_GETBITS_MIN_ADDR    0x60   // MVD_ASPD_BSD_ALIGN_BYTE_ADDR
+#define MVD_ASPD_BSD_GETBITS_MAX_ADDR    0x7f   // 31 bits
+
+//-- MPR GMC register address
+#define MVD_ASPD_GMC_ATLUM_X0_ADDR       0x90   // R/W, atlum->X0, 18 bits, signed
+#define MVD_ASPD_GMC_ATLUM_Y0_ADDR       0x91   // R/W, atlum->Y0, 18 bits, signed
+#define MVD_ASPD_GMC_ATLUM_YXXX_ADDR     0x92   // R/W, {atlum->YX, atlum->XX}, 16 bits each, signed
+#define MVD_ASPD_GMC_ATLUM_XYYY_ADDR     0x93   // R/W, {atlum->XY, atlum->YY}, 16 bits each, signed
+#define MVD_ASPD_GMC_ATCHR_X0_ADDR       0x94   // R/W, atchr->X0, 28 bits, signed
+#define MVD_ASPD_GMC_ATCHR_Y0_ADDR       0x95   // R/W, atchr->Y0, 28 bits, signed
+#define MVD_ASPD_GMC_ATCHR_YXXX_ADDR     0x96   // R/W, {atchr->YX, atchr->XX}, 16 bits each, signed
+#define MVD_ASPD_GMC_ATCHR_XYYY_ADDR     0x97   // R/W, {atchr->XY, atchr->YY}, 16 bits each, signed
+#define MVD_ASPD_GMC_PARAM_ADDR          0x98   // R/W, {5'd0, fcode_gmc, 6'd0, warp_accuracy, 3'd0, atchr_shift, 3'd0, atlum_shift}
+
+#define MVD_ASPD_MPR_OPTS_ADDR           0x99   // R/W  {26'b0,mpr_opts}
+
+#define ASPD_PXD_STATUS_ADDR             0xc0
+#define ASPD_PXD_QM_CTRL_ADDR            0xc1
+#define ASPD_PXD_WR_QMDATA_ADDR          0xc2
+
+//-- DBF registers -- these are the same as those for MP2D
+#define MVD_ASPD_DBF_CTRL0_ADDR          0x110  // Kevin Lim's POSTP_DEBLK_CTRL0
+#define MVD_ASPD_DBF_CTRL1_ADDR          0x111  // Kevin Lim's POSTP_DEBLK_CTRL1
+#define MVD_ASPD_DBF_CTRL2_ADDR          0x112  // Kevin Lim's POSTP_DEBLK_CTRL2
+#define MVD_ASPD_DBF_CTRL3_ADDR          0x113  // Kevin Lim's POSTP_DEBLK_CTRL3
+
+typedef struct MvdHwRegAspdMapTag
+{
+  //------- TOP address, 0x00 --> 0x3f
+  // 0x00 --> 0x3f
+  MvdHwReg top_img_start;
+  MvdHwReg top_vo_param;
+  MvdHwReg top_frame_ptr;
+  MvdHwReg top_vparam1;
+  MvdHwReg top_vparam2;
+  MvdHwReg top_vparam3;
+  MvdHwReg top_vo_param_ext;
+  MvdHwReg top_vparam4;
+  MvdHwReg top_vparam5;
+  MvdHwReg unused_top[64-9];
+  //------- BSD address, 0x40 --> 0x7f
+  // 0x40 --> 0x5f
+  MvdHwReg bsd_show_bits;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_bbb_status;
+  MvdHwReg bsd_scepb_ctrl;
+  MvdHwReg unused_0x04;
+  MvdHwReg unused_0x05;
+  MvdHwReg bsd_slc_start;
+  MvdHwReg bsd_curr_mbcoord;
+  MvdHwReg unused_0x08;
+  MvdHwReg bsd_options;
+  MvdHwReg bsd_jpeg_ctx0;
+  MvdHwReg bsd_jpeg_ctx1;
+  MvdHwReg unused_bsd[32-12];
+  // 0x60 --> 0x7f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+  //------- MPR/PXD/GMC address
+  // 0x80 --> 0xbf
+  MvdHwReg unused_mpr16[16];
+  MvdHwReg gmc_atlum_x0;
+  MvdHwReg gmc_atlum_y0;
+  MvdHwReg gmc_atlum_yxxx;
+  MvdHwReg gmc_atlum_xyyy;
+  MvdHwReg gmc_atchr_x0;
+  MvdHwReg gmc_atchr_y0;
+  MvdHwReg gmc_atchr_yxxx;
+  MvdHwReg gmc_atchr_xyyy;
+  MvdHwReg gmc_param;
+  MvdHwReg mpr_opts;
+  MvdHwReg unused_mpr38[64-16-10];
+  // 0xc0 --> 0xff
+  MvdHwReg pxd_qm_status;
+  MvdHwReg pxd_qm_ctrl;
+  MvdHwReg pxd_qm_data;
+  MvdHwReg unused_pxd61[61];
+  //------- DBF address
+  // 0x100 --> 0x17f
+  MvdHwReg unused_dbf16[16];
+  MvdHwReg dbf_ctrl0;
+  MvdHwReg dbf_ctrl1;
+  MvdHwReg dbf_ctrl2;
+  MvdHwReg dbf_ctrl3;
+  MvdHwReg unused_dbf108[108];
+  // 0x180 --> 0x1bf not used
+  MvdHwReg dbg_a;
+  MvdHwReg dbg_b;
+  MvdHwReg dbg_arb_wr;
+  MvdHwReg dbg_arb_rd;
+  MvdHwReg dbg_arb_mbi;
+  MvdHwReg unsued_spare[59];
+
+} MvdHwRegAspdMap;
+
+/////////////////////////////////////////////////////////////////
+// On2 Reg Map
+//
+
+typedef struct MvdHwRegOn2dMapTag {
+  //------- TOP address, 0x00 --> 0x3f
+  // 0x00 --> 0x3f
+  MvdHwReg top_img_start;
+  MvdHwReg top_param1;
+  MvdHwReg top_frame_ptr;
+  MvdHwReg top_param2;
+  MvdHwReg top_param3;
+  MvdHwReg top_param4;
+  MvdHwReg top_param5;
+  MvdHwReg top_param6;
+  MvdHwReg top_param7;
+  MvdHwReg top_param8;
+  MvdHwReg top_param9;
+  MvdHwReg top_param10;
+  MvdHwReg top_param11;
+  MvdHwReg top_param12;
+  MvdHwReg top_param13;
+  MvdHwReg top_param14;
+  MvdHwReg top_param15;
+  MvdHwReg top_param16;
+  MvdHwReg top_param17;
+  MvdHwReg top_param18;
+  MvdHwReg top_param19;
+  MvdHwReg top_param20;
+  MvdHwReg top_param21;
+  MvdHwReg top_param22;
+  MvdHwReg top_param23;
+  MvdHwReg top_param24;
+  MvdHwReg top_param25;
+  MvdHwReg top_param26;
+  MvdHwReg unused_top[64-28];
+
+  //------- BSD address, 0x40 --> 0x7f
+  // 0x40 --> 0x5f
+  MvdHwReg bsd_show_bits;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_bbb_status;
+  MvdHwReg unused_0x03;
+  MvdHwReg bsd_mbd_status;
+  MvdHwReg unused_0x05;
+  MvdHwReg bsd_slc_start;
+  MvdHwReg bsd_curr_mbcoord;
+  MvdHwReg unused_0x08;
+  MvdHwReg bsd_options;
+  MvdHwReg bsd_arith_config;
+  MvdHwReg unused_0x0B;
+  MvdHwReg bsd_scan_start;
+  MvdHwReg bsd_scan_data;
+  MvdHwReg bsd_prob_start;
+  MvdHwReg bsd_prob_data;
+  MvdHwReg bsd_prob_status;
+  MvdHwReg unused_0x11;
+  MvdHwReg unused_0x12;
+  MvdHwReg unused_0x13;
+  MvdHwReg unused_0x14;
+  MvdHwReg unused_0x15;
+  MvdHwReg unused_0x16;
+  MvdHwReg unused_0x17;
+  MvdHwReg debug_status;
+  MvdHwReg debug_data0;
+  MvdHwReg debug_data1;
+  MvdHwReg unused_bsd[32-27];
+  // 0x60 --> 0x7f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+  // the rest are not used
+} MvdHwRegOn2dMap;
+
+/////////////////////////////////////////////////////////////////
+// RVid Reg Map
+//
+
+typedef struct MvdHwRegRvidMapTag
+{
+  //------- TOP address, 0x00 --> 0x3f
+  // 0x00 --> 0x3f
+  MvdHwReg top_img_start;
+  MvdHwReg top_param1;
+  MvdHwReg top_frame_ptr;
+  MvdHwReg top_param2;
+  MvdHwReg top_param3;
+  MvdHwReg top_param4;
+  MvdHwReg unused_top[64-6];
+
+  //------- BSD address, 0x40 --> 0x7f
+  // 0x40 --> 0x5f
+  MvdHwReg bsd_show_bits;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_bbb_status;
+  MvdHwReg unused_0x03;
+  MvdHwReg bsd_mbd_status;
+  MvdHwReg unused_0x05;
+  MvdHwReg bsd_slc_start;
+  MvdHwReg bsd_curr_mbcoord;
+  MvdHwReg unused_0x08;
+  MvdHwReg bsd_options;
+  MvdHwReg bsd_rsb_missing;
+  MvdHwReg bsd_mb_qp;
+  MvdHwReg unused_bsd[32-12];
+  // 0x60 --> 0x7f
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+  // the rest are not used
+} MvdHwRegRvidMap;
+
+/////////////////////////////////////////////////////////////////
+// HEVC Reg Map
+//
+
+typedef struct MvdHwRegHevcMapTag
+{
+
+  /* TOP address, 0x00 --> 0x3f */
+  MvdHwReg image_config;            // R/W
+  MvdHwReg slice_config;            // R/W
+  MvdHwReg top_ctb_tile_info;       // R/W
+  MvdHwReg mbi_wr_base;             // R/W
+  MvdHwReg mbi_rd_base;             // R/W
+
+  MvdHwReg dec_cfg;                 // R/W
+  MvdHwReg dbg_cfg;                 // R/W
+  MvdHwReg dbf1_cfg;                // R/W
+  MvdHwReg dbf2_cfg;                // R/W
+  MvdHwReg dbe_frm_size;            // R/W
+  MvdHwReg prb_pack_base;           // R/W
+  MvdHwReg prb_bin_cfg;             // R/W
+  MvdHwReg dcp_bin_cfg;             // R/W
+
+  MvdHwReg unused_top[64-13];
+
+  /* BSD address, 0x40 --> 0x7f */
+  MvdHwReg bsd_options;
+  MvdHwReg bsd_dec_status;
+  MvdHwReg bsd_ctb_coord;
+  MvdHwReg bsd_slice_start;
+  MvdHwReg bsd_dec_param1;
+  MvdHwReg bsd_dec_param2;
+  MvdHwReg bsd_dec_ctb_cnt;
+  MvdHwReg bsd_dec_err_ctb_cnt;
+  MvdHwReg bsd_dec_ctb_qp_sum;
+
+  MvdHwReg bsd_plq_levels;
+  MvdHwReg Unused_A;
+
+  MvdHwReg bsd_ue;
+  MvdHwReg bsd_se;
+  MvdHwReg Unused_D;
+  MvdHwReg Unused_E;
+  MvdHwReg bsd_data;
+
+  MvdHwReg Unused_10;
+  MvdHwReg bsd_ctb_tile_px4;
+  MvdHwReg bsd_ctb_tile_py4;
+  MvdHwReg bsd_ctb_tile_px8;
+  MvdHwReg bsd_ctb_tile_py8;
+  MvdHwReg bsd_ctb_tile_px9_y10;
+  MvdHwReg bsd_sc_list_usage;
+  MvdHwReg bsd_sc_list_base;
+  MvdHwReg bsd_sc_list_idx[4];
+  MvdHwReg bsd_ei_flags_mask;
+  MvdHwReg bsd_bit_puller;
+  MvdHwReg bsd_is_trailing;
+  MvdHwReg bsd_bbb_status;
+
+  union
+  {
+    MvdHwReg bsd_byte_align;
+    MvdHwReg bsd_getbits[32];
+  } get_bits;
+
+  /* MPR address, 0x80 --> 0xBF */
+  MvdHwReg mpr_config;
+  MvdHwReg mpr_slice_param;
+
+  MvdHwReg Unused_82_9F[30];
+
+  MvdHwReg mpr_list[32];
+
+  MvdHwReg Unused_0xC0_FF[64];
+
+  /* dfe address, 0x100 --> 0x103 */
+  MvdHwReg dfe_status;
+  MvdHwReg dfe_num_pr_bits;
+  MvdHwReg dfe_row_crc;
+  MvdHwReg dfe_num_bins_used;
+  MvdHwReg Unused_DFE[60];
+
+  MvdHwReg Unused_0x140_17F[64];
+
+  MvdHwReg mpr_dbg;
+  MvdHwReg pxd_dbg;
+  MvdHwReg dbf_dbg;
+  MvdHwReg wr_arb_dbg; 
+  MvdHwReg rd_arb_dbg;
+  MvdHwReg mbi_rd_arb_dbg;
+  MvdHwReg mbi_wr_arb_dbg;
+  MvdHwReg Unused_DBG[64-7];
+
+} MvdHwRegHevcMap;
+
+///////////////////////////////////////////////////////////////////////////////////////
+// Top address mapping struct
+//
+// The base decoder address to be passed should be that of the HIF registers
+// not the RSB registers
+//
+// Minor non-backwards compatible address map change between Kronos
+// and Krome...
+
+/* *********************************************************** */
+/* Kronos                                                      */
+/*                                                             */
+/* MvdHwReg       hif[1024];                                   */
+/* MvdHwReg       sif[128];                                    */
+/* MvdHwReg       ctx[128];                                    */
+/* MvdHwReg       rpr[32];                                     */
+/* MvdHwReg       unused[32];                                  */
+/* MvdHwReg       bbd[32];       -- BL only --                 */
+/* MvdHwReg       dbg[32];       -- EL only --                 */
+/* MvdHwReg       spp[128];                                    */
+/* MvdHwReg       dec[512-64];                                 */
+/*                                                             */
+/* *********************************************************** */
+
+/* *********************************************************** */
+/* Krome                                                       */
+/*                                                             */
+/* Base Malone:                    Enhancement Malone          */
+/*                                                             */
+/* MvdHwReg       hif[1024];       MvdHwReg       hif[1024];   */
+/* MvdHwReg       sif[128];        MvdHwReg       sif[128];    */
+/* MvdHwReg       ctx[128];        MvdHwReg       ctx[128];    */
+/* MvdHwReg       rpr[32];         MvdHwReg       rpr[32];     */
+/* MvdHwReg       unused[32];      MvdHwReg       unused[32];  */
+/* MvdHwReg       bbd[32];         MvdHwReg       dbg[32];     */
+/* MvdHwReg       cq[32];          MvdHwReg       cq[32];      */
+/* MvdHwReg       spp[128];        MvdHwReg       spp[128];    */
+/* MvdHwReg       dec[512-64];     MvdHwReg       dec[512-64]; */
+/*                                                             */
+/* *********************************************************** */
+
+typedef struct MvdHwRegMapTag
+{
+  //------------- 8KB MSD address -------------
+  /* 4KB HIF address space */
+  union
+  {
+    MvdHwReg       hif[1024];
+    MvdHwRegHifMap hif_map;
+  } HifMap;
+
+  /* 0.5KB SIF address space */
+  union
+  {
+    MvdHwReg       sif[128];
+    MvdHwRegSifMap sif_map;
+  } SifMap;
+
+  /* 0.5KB CTX address space */
+  union
+  {
+    MvdHwReg       ctx[128];
+    MvdHwRegCtxMap ctx_map;
+  } CtxMap;
+
+  /* 128 B RPR address space */
+  union
+  {
+    MvdHwReg       rpr[32];
+    MvdHwRegRprMap rpr_map;
+  } RprMap;
+
+  /* 128 B RC4 address space */
+  union
+  {
+    MvdHwReg       RC4[32];
+    MvdHwRegRC4Map RC4_map;
+  } RC4Map;
+
+  /* 128 B DBG address space */
+  union
+  {
+    MvdHwReg       dbg[32];
+    MvdHwRegDbgMap dbg_map;
+  } DbgMap;
+
+  /* 128 B CQ address space */
+  union
+  {
+    MvdHwReg       cq[32];
+    MvdHwRegCqMap  cq_map;
+    MvdHwRegDbgMap dbg_map;
+  } CqMap;
+
+  /* 0.5KB SPP address space */
+  union
+  {
+    MvdHwReg       spp[128];
+    MvdHwRegSppMap spp_map;
+  } SppMap;
+
+  /* 1.75KB decoder address space */
+  union
+  {
+    MvdHwReg        dec[512-64];
+    MvdHwRegH264Map h264_map;
+    MvdHwRegVc1dMap vc1d_map;
+    MvdHwRegMp2dMap mp2d_map;
+    MvdHwRegAvsdMap avsd_map;
+    MvdHwRegAspdMap aspd_map;
+    MvdHwRegRvidMap rvid_map;
+    MvdHwRegOn2dMap on2d_map;
+    MvdHwRegHevcMap hevc_map;
+  } DecMap;
+
+  /* 0.25kB BBD address space */
+  union
+  {
+    MvdHwReg        bbd[64];
+    MvdHwRegBbdMap  bbd_map;
+    MvdHwRegDbgMap  dbg_map;
+  } BbdMap;
+
+  /* 4KB Decoupled unit space */
+  union
+  {
+    MvdHwReg        dcp[1024];
+    MvdHwRegDfeMap  dfe_map;
+    MvdHwRegDbeMap  dbe_map[2];
+  } DcpMap;
+
+  /* 0.25 KB FBC address space */
+  union
+  {
+    MvdHwReg        fbc[64];
+    MvdHwRegFbcMap  fbc_map;
+  } FbcMap;
+
+  /* 3.75 KB Special address */
+  MvdHwReg spc[1024 - 64];
+
+} MvdHwRegMap;
+
+///////////////////////////////////////////////////////////////////////////////////////
+// DPV address map
+//
+
+typedef struct
+{
+  MvdHwReg YFrameCRC;
+  MvdHwReg YTopFieldCRC;
+  MvdHwReg YBotFieldCRC;
+  MvdHwReg UVFrameCRC;
+  MvdHwReg UVTopFieldCRC;
+  MvdHwReg UVBotFieldCRC;
+
+} MvdHwRegA3CRCRegMap;
+
+
+typedef struct
+{
+  MvdHwReg YWordLower;
+  MvdHwReg UWordLower;
+  MvdHwReg VWordLower;
+  MvdHwReg YWordUpper;
+  MvdHwReg UWordUpper;
+  MvdHwReg VWordUpper;
+
+} MvdHwRegMD5RegMap;
+
+typedef struct
+{
+  MvdHwReg YFrameCRC;
+  MvdHwReg UFrameCRC;
+  MvdHwReg VFrameCRC;
+
+} MvdHwRegHashCRCRegMap;
+
+typedef struct
+{
+  MvdHwReg YCheckSum;
+  MvdHwReg UCheckSum;
+  MvdHwReg VCheckSum;
+
+} MvdHwRegHashChkSumRegMap;
+
+typedef struct
+{                                         //DCSN_CFG_BASE_MMIO | 0x1FC000  => 0xE07FC000
+  MvdHwReg Control;
+  MvdHwReg Status;
+  MvdHwReg DTLReadCalib;
+  MvdHwReg CropTopLeft;
+  MvdHwReg CropBotRight;
+  MvdHwReg LumaBase;
+  MvdHwReg ChromaBase;
+
+  union
+  {
+    MvdHwReg                 Digest[0x6];
+    MvdHwRegA3CRCRegMap      A3CRC;
+    MvdHwRegMD5RegMap        MD5;
+    MvdHwRegHashCRCRegMap    HashCRC;
+    MvdHwRegHashChkSumRegMap HashCheckSum;
+
+  } DigestMap0;
+
+  MvdHwReg Stride;
+
+  /* For code readability - this is added as a union       */
+  /* but in fact the registers are valid only in MD5 mode  */
+  union
+  {
+    MvdHwReg                 Digest[0x6];
+    MvdHwRegA3CRCRegMap      A3CRC;
+    MvdHwRegMD5RegMap        MD5;
+    MvdHwRegHashCRCRegMap    HashCRC;
+    MvdHwRegHashChkSumRegMap HashCheckSum;
+
+  } DigestMap1;
+
+  MvdHwReg Scratch[0x4];
+
+} MvdHwDPVRegMap;
+
+#endif /* _MVD_REG_MAP_H_ */
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_sif_control.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_sif_control.h
new file mode 100755
index 0000000..80dc48d
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_sif_control.h
@@ -0,0 +1,975 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        mvd_sif_control.h
+  Description:     Malone system interface
+  Notes:
+
+ ****************************************************/
+
+#ifndef _MVD_SIF_CONTROL_H_
+#define _MVD_SIF_CONTROL_H_
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+// SIF data range definitions
+#define MSD_SIF_FS_KBYTES_BITS(r)                         (((r)&0xFFFF0000)>>16)
+#define MSD_SIF_FRAME_SIZE_MB_BITS(r)                     ((r)&0xFFFF)
+#define MSD_PUT_SIF_FRAME_SIZE_MB_BITS(w)                 ((w)&0xFFFF)
+#define MSD_PUT_SIF_FS_KBYTES_BITS(w)                     (((w)&0xFFFF)<<16)
+
+#define MSD_PUT_FRAME_WIDTH_MB_BITS(w)                    ((w)&0xFF)
+#define MSD_PUT_FRAME_HEIGHT_MB_BITS(w)                   (((w)&0xFF)<<8)
+#define MSD_PUT_FRAME_SIZE_MB_BITS(w)                     (((w)&0xFFFF)<<16)
+
+#define MSD_DPB_IN_KBYTES_BITS(r)                         ((r)&0xFFFF)
+
+#define MPD_SIF_DISP_Q_CNT_BITS(r)                        ((r)&0xFF)
+#define MPD_SIF_DISP_Q_FULL_BITS(r)                       ((r>>8)&0x1)
+#define MPD_SIF_DISP_Q_REQ_BIT(r)                         ((r>>16)&0x1)
+
+#define MPD_SIF_DISP_Q_PUSH_FS_IDC_BITS(w)                ((w)&0x1F)
+#define MPD_SIF_DISP_Q_PUSH_SPS_IDC_BITS(w)               (((w)&0x7)<<16)
+#define MPD_SIF_DISP_Q_PUSH_DANG_FIELD_BIT(w)             (((w)&0x1)<<19)
+#define MPD_SIF_DISP_Q_PUSH_FIELD_MODE_BIT(w)             (((w)&0x2)<<19)
+#define MPD_SIF_DISP_Q_PUSH_BOT_FIRST_BIT(w)              (((w)&0x1)<<21)
+#define MPD_SIF_DISP_Q_PUSH_SKIP_PIC_BITS(w)              (((w)&0x3)<<22)
+#define MPD_SIF_DISP_Q_SYS_DATA_BITS(w)                   (((w)&0xFF)<<24)
+
+#define MPD_SIF_DISP_Q_PUSH_CRC_MODE_BIT(w)               (((w)&0x1)<<20)
+
+#define MPD_SIF_FS_PACK_UNIT_BITS(r)                      ((r)&0x7)
+#define MPD_SIF_FS_BASE_UNIT_BITS(r)                      ((r>>12)&0x7)
+#define MPD_SIF_SYS_DATA_EDGE_BIT(r)                      ((r>>16)&0x1)
+#define MPD_SIF_BS_SYNC_USED_BIT(r)                       ((r>>17)&0x1)
+
+#define MPD_SIF_SYS_DATA_BITS(r)                          ((r)&0xFF)
+
+#define MPD_SIF_FRAME_DEC_IRQ_POS                         1
+#define MPD_SIF_SLICE_DEC_IRQ_POS                         2
+#define MPD_SIF_START_CODE_IRQ_POS                        3
+#define MPD_SIF_SEMAPHORE_IRQ_BIT(r)                      ((r)&0x1)
+#define MPD_SIF_FRAME_DEC_IRQ_BIT(r)                      (((r)&0x2)>>1)
+#define MPD_SIF_SLICE_DEC_IRQ_BIT(r)                      (((r)&0x4)>>2)
+#define MPD_SIF_START_CODE_IRQ_BIT(r)                     (((r)&0x8)>>3)
+
+
+#define MSD_SIF_QPULL_IRQ_BIT(r)                          (((r)&0x10)>>4)
+#define MSD_SIF_QPULL_SHIFT                               4
+#define MSD_SIF_QPULL_MASK                                0x10
+#define MPD_SIF_BSDMA_IRQ_BIT(r)                          (((r)&0x80)>>7)
+#define PUT_MSD_STREAM_ID(w)                              ((w)&0xF)
+#define PUT_MSD_FORMAT(w)                                 (((w)&0x3)<<4)
+
+// Sempahore reg bits
+#define FRAME_DISPLAYED_BITS(r)                           ((r)&0x1)
+
+// MSD_SIF_DPB_FS_SIZE_ADDR
+#define MSD_SIF_DPB_FS_WIDTH_IN_MB_POS        0
+#define MSD_SIF_DPB_FS_WIDTH_IN_MB_SIZE       8
+#define MSD_SIF_DPB_FS_WIDTH_IN_MB_MASK       0xff
+#define MSD_SIF_DPB_FS_HEIGHT_IN_MB_POS       8
+#define MSD_SIF_DPB_FS_HEIGHT_IN_MB_SIZE      8
+#define MSD_SIF_DPB_FS_HEIGHT_IN_MB_MASK      0xff
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_POS        16
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_SIZE       14
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_MASK       0x3fff
+#define MSD_SIF_DPB_FS_SIZE_WIDTH_INMBS_GET(val) ((val>>MSD_SIF_DPB_FS_WIDTH_IN_MB_POS)&MSD_SIF_DPB_FS_WIDTH_IN_MB_MASK)
+#define MSD_SIF_DPB_FS_SIZE_HEIGHT_INMBS_GET(val) ((val>>MSD_SIF_DPB_FS_HEIGHT_IN_MB_POS)&MSD_SIF_DPB_FS_HEIGHT_IN_MB_MASK)
+#define MSD_SIF_DPB_FS_SIZE_KBYTES(val) ((val>>MSD_SIF_DPB_FS_SIZE_KBYTES_POS)&MSD_SIF_DPB_FS_SIZE_KBYTES_MASK)
+
+// MSD_SIF_DPB_FS_SIZE_EXT_ADDR
+#define MSD_SIF_DPB_FS_WIDTH_IN_MB_EXT_POS            0
+#define MSD_SIF_DPB_FS_WIDTH_IN_MB_EXT_SIZE           2
+#define MSD_SIF_DPB_FS_WIDTH_IN_MB_EXT_MASK           0x3
+#define MSD_SIF_DPB_FS_HEIGHT_IN_MB_EXT_POS           2
+#define MSD_SIF_DPB_FS_HEIGHT_IN_MB_EXT_SIZE          2
+#define MSD_SIF_DPB_FS_HEIGHT_IN_MB_EXT_MASK          0x3
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_EXT_POS            4
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_EXT_SIZE           3
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_EXT_MASK           0x7
+#define MSD_SIF_DPB_FS_SIZE_WIDTH_INMBS_EXT_GET(val)  ((val>>MSD_SIF_DPB_FS_WIDTH_IN_MB_POS)&MSD_SIF_DPB_FS_WIDTH_IN_MB_EXT_MASK)
+#define MSD_SIF_DPB_FS_SIZE_HEIGHT_INMBS_EXT_GET(val) ((val>>MSD_SIF_DPB_FS_HEIGHT_IN_MB_POS)&MSD_SIF_DPB_FS_HEIGHT_IN_MB_EXT_MASK)
+#define MSD_SIF_DPB_FS_SIZE_KBYTES_EXT(val)           ((val>>MSD_SIF_DPB_FS_SIZE_KBYTES_POS)&MSD_SIF_DPB_FS_SIZE_KBYTES_MASK)
+
+//MSD_SIF_DPB_FRM_SIZE_ADDR
+#define MSD_SIF_DPB_FRM_WIDTH_IN_MB_POS        0
+#define MSD_SIF_DPB_FRM_WIDTH_IN_MB_SIZE       8
+#define MSD_SIF_DPB_FRM_WIDTH_IN_MB_MASK       0xff
+#define MSD_SIF_DPB_FRM_HEIGHT_IN_MB_POS       8
+#define MSD_SIF_DPB_FRM_HEIGHT_IN_MB_SIZE      8
+#define MSD_SIF_DPB_FRM_HEIGHT_IN_MB_MASK      0xff
+#define MSD_SIF_DPB_FRM_SIZE_MBS_POS          16
+#define MSD_SIF_DPB_FRM_SIZE_MBS_SIZE         16
+#define MSD_SIF_DPB_FRM_SIZE_MBS_MASK          0xffff
+#define MSD_SIF_DPB_FRM_SIZE_INMBS(val)      ((val>>MSD_SIF_DPB_FRM_SIZE_MBS_POS)&MSD_SIF_DPB_FRM_SIZE_MBS_MASK)
+#define MSD_SIF_DPB_FRM_WIDTH_INMBS_GET(val) ((val>>MSD_SIF_DPB_FRM_WIDTH_IN_MB_POS)&MSD_SIF_DPB_FRM_WIDTH_IN_MB_MASK)
+#define MSD_SIF_DPB_FRM_HEIGHT_INMBS_GET(val) ((val>>MSD_SIF_DPB_FRM_HEIGHT_IN_MB_POS)&MSD_SIF_DPB_FRM_HEIGHT_IN_MB_MASK)
+
+//MSD_SIF_DPB_FRM_SIZE_EXT_ADDR
+#define MSD_SIF_DPB_FRM_WIDTH_IN_MB_EXT_POS        0
+#define MSD_SIF_DPB_FRM_WIDTH_IN_MB_EXT_SIZE       1
+#define MSD_SIF_DPB_FRM_WIDTH_IN_MB_EXT_MASK       0x1
+#define MSD_SIF_DPB_FRM_HEIGHT_IN_MB_EXT_POS       1
+#define MSD_SIF_DPB_FRM_HEIGHT_IN_MB_EXT_SIZE      1
+#define MSD_SIF_DPB_FRM_HEIGHT_IN_MB_EXT_MASK      0x1
+#define MSD_SIF_DPB_FRM_SIZE_MBS_EXT_POS           2
+#define MSD_SIF_DPB_FRM_SIZE_MBS_EXT_SIZE          3
+#define MSD_SIF_DPB_FRM_SIZE_MBS_EXT_MASK          0x7
+#define MSD_SIF_DPB_FRM_SIZE_INMBS_EXT(val)       ((val>>MSD_SIF_DPB_FRM_SIZE_MBS_POS)&MSD_SIF_DPB_FRM_WIDTH_IN_MB_EXT_MASK)
+#define MSD_SIF_DPB_FRM_WIDTH_INMBS_EXT_GET(val)  ((val>>MSD_SIF_DPB_FRM_WIDTH_IN_MB_POS)&MSD_SIF_DPB_FRM_HEIGHT_IN_MB_EXT_MASK)
+#define MSD_SIF_DPB_FRM_HEIGHT_INMBS_EXT_GET(val) ((val>>MSD_SIF_DPB_FRM_HEIGHT_IN_MB_POS)&MSD_SIF_DPB_FRM_SIZE_MBS_EXT_MASK)
+#define MSD_PUT_FRAME_WIDTH_MB_EXT_BITS(val)      (((val>>8)&MSD_SIF_DPB_FRM_WIDTH_IN_MB_EXT_MASK)<<MSD_SIF_DPB_FRM_WIDTH_IN_MB_EXT_POS)
+#define MSD_PUT_FRAME_HEIGHT_MB_EXT_BITS(val)     (((val>>8)&MSD_SIF_DPB_FRM_HEIGHT_IN_MB_EXT_MASK)<<MSD_SIF_DPB_FRM_HEIGHT_IN_MB_EXT_POS)
+#define MSD_PUT_FRAME_SIZE_MB_EXT_BITS(val)       (((val>>16)&MSD_SIF_DPB_FRM_SIZE_MBS_EXT_MASK)<<MSD_SIF_DPB_FRM_SIZE_MBS_EXT_POS)
+
+
+//MSD_SIF_DPB_FS_SETTING_ADDR
+#define MSD_SIF_FS_PACK_UNIT_POS              0
+#define MSD_SIF_FS_PACK_UNIT_SIZE             3
+#define MSD_SIF_FS_PACK_UNIT(val)             ((val>>MSD_SIF_FS_PACK_UNIT_POS)&0x7)
+#define MSD_SIF_FS_PACK_WIDTH_POS             4
+#define MSD_SIF_FS_PACK_WIDTH_SIZE            3
+#define MSD_SIF_FS_PACK_ID                    (1<<8)
+#define MSD_SIF_FRM_SYNC_EDGE                 (1<<16)
+#define MSD_SIF_BS_SYNC_USED                  (1<<17)
+#define MSD_SIF_FS_BASE_UNIT_POS              12
+#define MSD_SIF_FS_BASE_UNIT(val)             ((val>>MSD_SIF_FS_BASE_UNIT_POS)&0x7)
+
+// Standard pack unit sizes
+#define SIF_SPB_BASE_UNITS_1KBYTES            0x4
+#define SIF_SPB_BASE_UNITS_2KBYTES            0x5
+#define SIF_SPB_BASE_UNITS_4KBYTES            0x6
+#define SIF_SPB_BASE_UNITS_8KBYTES            0x7
+
+//MSD_SIF_DPB_OFFSET_ADDR
+//MSD_SIF_FRM_SYNC_DATA_ADDR
+//MSD_SIF_FRM_DANGLING_ADDR
+
+//MSD_SIF_DPB_CONFIG_ADDR
+#define MSD_SIF_DPB_LUT_ENAB               (1<<0)
+#define MSD_SIF_DPB_LUT_ADDR_MSB           (1<<1)
+#define MSD_SIF_DPB_USE_FS_IDC             (1<<2)
+#define MSD_SIF_DPB_RSHIFT_CA_POS              3
+#define MSD_SIF_DPB_RSHIFT_CA_SIZE             3
+
+//MSD_SIF_DPB_LUT_LOAD_ADDR
+#define MSD_SIF_DPB_LUT_VALUE_POS                0
+#define MSD_SIF_DPB_LUT_VALUE_SIZE              20
+#define MSD_SIF_DPB_LUT_ADDR_POS                24
+#define MSD_SIF_DPB_LUT_ADDR_SIZE                6
+
+//MSD_SIF_LOAD_DPB_NUMB_ADDR
+#define MSD_SIF_LOAD_DPB_NUMB_NUMB_POS         0
+#define MSD_SIF_LOAD_DPB_NUMB_NUMB_SIZE        5
+#define MSD_SIF_LOAD_DPB_NUMB_NUMB(val)        ((val>>MSD_SIF_LOAD_DPB_NUMB_NUMB_POS)&0x1f)
+#define MSD_SIF_LOAD_DPB_NUMB_SID_POS          12
+#define MSD_SIF_LOAD_DPB_NUMB_SID_SIZE         4
+
+//MSD_SIF_DEC_STATUS_ADDR
+#define MSD_SIF_DEC_STATUS_SLC_PROG_POS             0
+#define MSD_SIF_DEC_STATUS_SLC_PROG_SIZE            1
+#define MSD_SIF_DEC_STATUS_SLC_PROG(val)            ((val>>MSD_SIF_DEC_STATUS_SLC_PROG_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_IMG_PROG_POS             1
+#define MSD_SIF_DEC_STATUS_IMG_PROG_SIZE            1
+#define MSD_SIF_DEC_STATUS_IMG_PROG(val)            ((val>>MSD_SIF_DEC_STATUS_IMG_PROG_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_FRM_PROG_POS             2
+#define MSD_SIF_DEC_STATUS_FRM_PROG_SIZE            1
+#define MSD_SIF_DEC_STATUS_FRM_PROG(val)            ((val>>MSD_SIF_DEC_STATUS_FRM_PROG_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_VPMD_BUSY_POS            3
+#define MSD_SIF_DEC_STATUS_VPMD_BUSY_SIZE           1
+#define MSD_SIF_DEC_STATUS_VPMD_BUSY(val)           ((val>>MSD_SIF_DEC_STATUS_VPMD_BUSY_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_VDBF_BUSY_POS            4
+#define MSD_SIF_DEC_STATUS_VDBF_BUSY_SIZE           1
+#define MSD_SIF_DEC_STATUS_VDBF_BUSY(val)           ((val>>MSD_SIF_DEC_STATUS_VDBF_BUSY_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_XOB_IDLE_POS             5
+#define MSD_SIF_DEC_STATUS_XOB_IDLE_SIZE            1
+#define MSD_SIF_DEC_STATUS_XOB_IDLE(val)            ((val>>MSD_SIF_DEC_STATUS_XOB_IDLE_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_DPBMC_IDLE_POS           6
+#define MSD_SIF_DEC_STATUS_DPBMC_IDLE_SIZE          1
+#define MSD_SIF_DEC_STATUS_DPBMC_IDLE(val)          ((val>>MSD_SIF_DEC_STATUS_DPBMC_IDLE_POS)&0x1)
+
+#define MSD_SIF_DEC_STATUS_BS_EMPTY_POS             7
+#define MSD_SIF_DEC_STATUS_BS_EMPTY_SIZE            1
+#define MSD_SIF_DEC_STATUS_BS_EMPTY(val)            ((val>>MSD_SIF_DEC_STATUS_BS_EMPTY_POS)&0x1)
+
+/* From Kronos Rev.B */
+#define MSD_SIF_DEC_STATUS_MBQ_STAT_POS             8
+#define MSD_SIF_DEC_STATUS_MBQ_STAT_SIZE            2
+#define MSD_SIF_DEC_STATUS_MBQ_STAT(val)            ((val>>MSD_SIF_DEC_STATUS_MBQ_STAT_POS)&0x3)
+
+#define MSD_SIF_DEC_STATUS_MPR_FIFO_POS             10
+#define MSD_SIF_DEC_STATUS_MPR_FIFO_SIZE            6
+
+#define MSD_SIF_DEC_STATUS_MPR_FIFOS_NEMPTY_POS     16
+#define MSD_SIF_DEC_STATUS_MPR_FIFOS_NEMPTY_SIZE    1
+
+#define MSD_SIF_DEC_STATUS_VMIF_CLSET_IDLE_POS      17
+#define MSD_SIF_DEC_STATUS_VMIF_CLSET_IDLE_SIZE     2
+
+#define MSD_SIF_DEC_STATUS_PIXIF_IDLE_POS           19
+#define MSD_SIF_DEC_STATUS_PIXIF_IDLE_SIZE          1
+
+#define MSD_SIF_DEC_STATUS_MBIWR_TAGFIFO_EMPTY_POS  22
+#define MSD_SIF_DEC_STATUS_MBIWR_TAGFIFO_EMPTY_SIZE 1
+#define MSD_SIF_DEC_STATUS_MBIWR_TAGFIFO_EMPTY(val) ((val>>MSD_SIF_DEC_STATUS_MBIWR_TAGFIFO_EMPTY_POS)&0x1)
+
+
+//MSD_SIF_BS2RBSP_STATUS_ADDR   6'h32   // R, bs2rbsp status  -- [bs_sync frm_sync_data] got_start_code, nal_unit_done, buf_level
+// BSD data range definitions
+#define MSD_SIF_BS2RBSP_GOT_START_CODE_BITS(r) ((r)&0x1)
+#define MSD_SIF_BS2RBSP_NAL_UNIT_DONE_BIT(r)   (((r)&0x2)>>1)
+#define MSD_SIF_BS2RBSP_CBUF_LEVEL_BITS(r)     (((r)&0x1FC)>>2)
+#define MSD_SIF_BS2RBSP_GOT_START_CODE_MASK    0x1
+#define MSD_SIF_BS2RBSP_GOT_SCODE              (1<<0)
+#define MSD_SIF_BS2RBSP_NALU_FINISH            (1<<1)
+#define MSD_SIF_BS2RBSP_EMPTY                  (1<<2)
+#define MSD_SIF_BS2RBSP_BUF_LEVEL_POS          3
+#define MSD_SIF_BS2RBSP_BUF_LEVEL_SIZE         4
+#define MSD_SIF_BS2RBSP_BUF_LEVEL(val)         ((val>>MSD_SIF_BS2RBSP_BUF_LEVEL_POS)&0xf)
+#define MSD_SIF_BS2RBSP_GOT_PESSCODE           1<<8
+#define MSD_SIF_BS2RBSP_SCD_LEVEL_POS          10
+#define MSD_SIF_BS2RBSP_SCD_LEVEL_MASK         0x3
+#define MSD_SIF_BS2RBSP_3RD_BTYE_POS           12
+#define MSD_SIF_BS2RBSP_3RD_BTYE_MASK          0xFF
+#define MSD_SIF_BS2RBSP_SCD_DIS_POS            20
+#define MSD_SIF_BS2RBSP_SCD_DIS_MASK           0x1
+#define MSD_SIF_BS2RBSP_LONG_SCODE_POS         21
+#define MSD_SIF_BS2RBSP_LONG_SCODE_MASK        0x1
+#define MSD_SIF_BS2RBSP_SHORT_SYNC_POS         22
+#define MSD_SIF_BS2RBSP_SHORT_SYNC_MASK        0x1
+
+#define MSD_SIF_BS2RBSP_SCD_LEVEL(val)         ((val >> MSD_SIF_BS2RBSP_SCD_LEVEL_POS ) & MSD_SIF_BS2RBSP_SCD_LEVEL_MASK )
+#define MSD_SIF_BS2RBSP_SCD_3RD_BTYE(val)      ((val >> MSD_SIF_BS2RBSP_3RD_BTYE_POS ) & MSD_SIF_BS2RBSP_3RD_BTYE_MASK )
+#define MSD_SIF_BS2RBSP_SCD_DIS(val)           ((val >> MSD_SIF_BS2RBSP_SCD_DIS_POS ) & MSD_SIF_BS2RBSP_SCD_DIS_MASK )
+#define MSD_SIF_BS2RBSP_LONG_SCODE(val)        ((val >> MSD_SIF_BS2RBSP_LONG_SCODE_POS ) & MSD_SIF_BS2RBSP_LONG_SCODE_MASK )
+#define MSD_SIF_BS2RBSP_SHORT_SYNC(val)        ((val >> MSD_SIF_BS2RBSP_SHORT_SYNC_POS ) & MSD_SIF_BS2RBSP_SHORT_SYNC_MASK )
+
+//MSD_SIF_BS2RBSP_FEED_ADDR
+#define MSD_SIF_BS2RBSP_FEED_CTRL              (1<<0)  // W: RBSP feed start & stop control,
+#define MSD_SIF_BS2RBSP_NAL_EI_FLAG            (1<<1)  // R only, on nalu bases, cleared by HW at start of nalu,
+#define MSD_SIF_BS2RBSP_FEED_STOP              ((~MSD_SIF_BS2RBSP_FEED_CTRL)&1)
+
+//MSD_SIF_BS2RBSP_SCODE_ADDR
+#define MSD_SIF_BS2RBSP_START_CODE_POS        0
+#define MSD_SIF_BS2RBSP_START_CODE_SIZE       8
+#define MSD_SIF_BS2RBSP_START_CODE(val)       ((val>>MSD_SIF_BS2RBSP_START_CODE_POS)&0xff)
+#define MSD_SIF_RS2RBSP_SHORT_SC_POS          8
+#define MSD_SIF_RS2RBSP_SHORT_SC_SIZE         1
+#define MSD_SIF_RS2RBSP_SHORT_SC_FLAG(val)    ((val>>MSD_SIF_RS2RBSP_SHORT_SC_POS)&0x1)
+#define MSD_SIF_BS2RBSP_SYNC_DATA_POS         16
+#define MSD_SIF_BS2RBSP_SYNC_DATA(val)        ((val & 0xff0000) >> MSD_SIF_BS2RBSP_SYNC_DATA_POS)
+#define MSD_SIF_BS2RBSP_SYNC_DATA_SET(val)    ((val<<MSD_SIF_BS2RBSP_SYNC_DATA_POS) & 0xff0000)
+
+#define MSD_SIF_BS2RBSP_SYNC_DATA_SIZE        8
+#define MSD_SIF_BS2RBSP_SYNC_DATA_PTSDTSFLAGS_POS 0
+#define MSD_SIF_BS2RBSP_SYNC_DATA_DTS_POS 2
+#define MSD_SIF_BS2RBSP_SYNC_DATA_PTS_POS 3
+#define MSD_SIF_BS2RBSP_SYNC_DATA_ERR_POS 7
+#define MSD_SIF_BS2RBSP_SYNC_DATA_ERR (1<<MSD_SIF_BS2RBSP_SYNC_DATA_ERR_POS)
+#define MSD_SIF_BS2RBSP_SYNC_FLAG             (1<<24)     // 0 if bs_sync_used is set to '0'
+
+//MSD_SIF_BS2RBSP_SCDCTRL_ADDR
+#define MSD_SIF_BS2RBSP_SCDCTRL_EXPLICIT_CTRL_POS               0
+#define MSD_SIF_BS2RBSP_SCDCTRL_ERR_SLCMRG_POS                  3
+#define MSD_SIF_BS2RBSP_SCDCTRL_DETECT_JPEG_MARKERS_POS         5
+#define MSD_SIF_BS2RBSP_SCDCTRL_STOP_SLICE_ON_SYNC_POS          6
+#define MSD_SIF_BS2RBSP_SCDCTRL_USE_OLD_EMUL_PREVENT_POS        7
+#define MSD_SIF_BS2RBSP_SCDCTRL_SCODE_DETECT_DISABLE_PERIOD_POS 8
+#define MSD_SIF_BS2RBSP_SCDCTRL_EXPLICIT_CTRL       (1<<MSD_SIF_BS2RBSP_SCDCTRL_EXPLICIT_CTRL_POS)
+#define MSD_SIF_BS2RBSP_SCDCTRL_ERR_SLCMRG          (1<<MSD_SIF_BS2RBSP_SCDCTRL_ERR_SLCMRG_POS)
+#define MSD_SIF_BS2RBSP_SCDCTRL_DETECT_JPEG_MARKERS (1<<MSD_SIF_BS2RBSP_SCDCTRL_DETECT_JPEG_MARKERS_POS)
+#define MSD_SIF_BS2RBSP_SCDCTRL_STOP_SLICE_ON_SYNC  (1<<MSD_SIF_BS2RBSP_SCDCTRL_STOP_SLICE_ON_SYNC_POS)
+
+//MSD_SIF_CTRL_STATUS_ADDR
+#define MSD_SIF_CTRL_SEMAPHORE_INTR_BIT        (1<<0)  // Read Only, '1'
+#define MSD_SIF_CTRL_IMAGE_INTR_ENAB_BIT       (1<<1)
+#define MSD_SIF_CTRL_SLICE_INTR_ENAB_BIT       (1<<2)
+#define MSD_SIF_CTRL_SCODE_INTR_ENAB_BIT       (1<<3)
+#define MSD_SIF_CTRL_QPULL_INTR_ENAB_BIT       (1<<4)
+#define MSD_SIF_CTRL_DTLERR_INTR_ENAB_BIT      (1<<5)  // Took over FORCE_ENTRY bit as not needed in status
+#define MSD_SIF_CTRL_PESSC_INTR_ENAB_BIT       (1<<6)  // Took over FORCE_ENTRY bit as not needed in status
+#define MSD_SIF_CTRL_BSDMA_INTR_ENAB_BIT       (1<<7)
+#define MSD_SIF_CTRL_MP2D_SLC_MERGE_BIT        (1<<8)
+#define MSD_SIF_CTRL_BS2RBSP_ENAB_BIT          (1<<9)
+#define MSD_SIF_CTRL_SCODE_IN_FEED_BIT         (1<<10)
+#define MSD_SIF_CTRL_SLC_RESYNC_DISAB_BIT      (1<<11)
+#define MSD_SIF_CTRL_ALT_IRQ_CLR_BIT           (1<<12)
+#define MSD_SIF_CTRL_ASPD_SSC_ENAB_BIT         (1<<13) // SPD short start code enable
+#define MSD_SIF_CTRL_BBB_RSCMD_DISAB_BIT       (1<<14) // BBB read-sensitive command disable - if set, BBB get_bits and exp-golumb commands require write first
+#define MSD_SIF_CTRL_RSBXFR_INTR_ENAB_BIT      (1<<15)
+#define MSD_SIF_CTRL_IRQ_SELECT_BITS_SHIFT     (16)
+
+//MSD_SIF_INTR_STATUS_ADDR
+#define MSD_SIF_INTR_SEMAPHORE_BIT             (1<<0)   // Controlled by semaphore interrupt mask, cannot be disabled or forced
+#define MSD_SIF_INTR_IMAGE_DONE_BIT            (1<<1)
+#define MSD_SIF_INTR_SLICE_DONE_BIT            (1<<2)
+#define MSD_SIF_INTR_SCODE_FOUND_BIT           (1<<3)
+#define MSD_SIF_INTR_DISPQ_PULL_BIT            (1<<4)
+#define MSD_SIF_INTR_FORCE_ENTRY_BIT           (1<<5)   // Always enabled
+#define MSD_SIF_INTR_PES_BIT                   (1<<6)
+#define MSD_SIF_INTR_BSDMA_BIT                 (1<<7)
+#define MSD_SIF_INTR_FORCE_EXIT_BIT            (1<<8)   // Always enabled
+#define MSD_SIF_INTR_DTL_ERR_BIT               (1<<9)
+#define MSD_SIF_INTR2_EXTENSION_BITS           (3<<10)  // Always Enabled
+#define MSD_SIF_INTR2_EXTENSION_BIT_1          (1<<10)  // Always Enabled
+#define MSD_SIF_INTR2_EXTENSION_BIT_2          (1<<11)  // Always Enabled
+#define MSD_SIF_INTR3_EXTENSION_BITS           (3<<12)  // Always Enabled
+#define MSD_SIF_INTR3_EXTENSION_BIT_1          (1<<12)  // Always Enabled
+#define MSD_SIF_INTR3_EXTENSION_BIT_2          (1<<13)  // Always Enabled
+#define MSD_SIF_INTR_RSBXFR_DONE_BIT           (1<<15)
+
+//MSD_SIF_CTRL2_STATUS_ADDR
+#define MSD_SIF_CTRL2_IRQ_MASK                 0x80000000
+#define MSD_SIF_CTRL2_RPR_DONE_INTR_ENAB_BIT   ((1<<4)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_BSD_DONE_BIT             ((1<<5)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_SPP_SCODE_INTR_ENAB_BIT  ((1<<6)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_SPP_PESSC_INTR_ENAB_BIT  ((1<<7)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_SPP_BSDMA_INTR_ENAB_BIT  ((1<<8)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_CSC_DONE_ENAB_BIT        ((1<<9) |MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_CQ_ENAB_BIT              ((1<<10)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_DFE_DONE_ENAB_BIT        ((1<<13)|MSD_SIF_CTRL2_IRQ_MASK)
+#define MSD_SIF_CTRL2_DFE_SLC_DONE_ENAB_BIT    ((1<<14)|MSD_SIF_CTRL2_IRQ_MASK)
+
+//MSD_SIF_INTR2_STATUS_ADDR
+#define MSD_SIF_INTR2_RPR_BIT                  (1<<4)
+#define MSD_SIF_INTR2_SPP_SCODE_FOUND_BIT      (1<<6)
+#define MSD_SIF_INTR2_SPP_PESSC_FOUND_BIT      (1<<7)
+#define MSD_SIF_INTR2_SPP_BSDMA_BIT            (1<<8)
+#define MSD_SIF_INTR2_CSC_BIT                  (1<<9)
+#define MSD_SIF_INTR2_CQ_BIT                   (1<<10)
+#define MSD_SIF_INTR2_DFE_DONE_BIT             (1<<13)
+#define MSD_SIF_INTR2_DFE_SLC_DONE_BIT         (1<<14)
+
+//MSD_SIF_CTRL3_STATUS_ADDR
+#define MSD_SIF_CTRL3_IRQ_MASK                 0x40000000
+#define MSD_SIF_CTRL3_DBE0_CQ_ENAB_BIT         ((1<<0)|MSD_SIF_CTRL3_IRQ_MASK)
+#define MSD_SIF_CTRL3_DBE1_CQ_ENAB_BIT         ((1<<1)|MSD_SIF_CTRL3_IRQ_MASK)
+#define MSD_SIF_CTRL3_DBE0_DONE_ENAB_BIT       ((1<<4)|MSD_SIF_CTRL3_IRQ_MASK)
+#define MSD_SIF_CTRL3_DBE1_DONE_ENAB_BIT       ((1<<5)|MSD_SIF_CTRL3_IRQ_MASK)
+#define MSD_SIF_CTRL3_DBE0_SLC_DONE_ENAB_BIT   ((1<<8)|MSD_SIF_CTRL3_IRQ_MASK)
+#define MSD_SIF_CTRL3_DBE1_SLC_DONE_ENAB_BIT   ((1<<9)|MSD_SIF_CTRL3_IRQ_MASK)
+
+//MSD_SIF_INTR3_STATUS_ADDR
+#define MSD_SIF_INTR3_DBE0_CQ_BIT              (1<<0)
+#define MSD_SIF_INTR3_DBE1_CQ_BIT              (1<<1)
+#define MSD_SIF_INTR3_DBE0_DONE_BIT            (1<<4)
+#define MSD_SIF_INTR3_DBE1_DONE_BIT            (1<<5)
+#define MSD_SIF_INTR3_DBE0_SLC_DONE_BIT        (1<<8)
+#define MSD_SIF_INTR3_DBE1_SLC_DONE_BIT        (1<<9)
+
+//MSD_SIF_RESET_COMMAND_ADDR
+#define MSD_SIF_RESET_DEC_ENGINE_BIT           (1<<0)
+#define MSD_SIF_RESET_BS_INBUF_BIT             (1<<1)
+#define MSD_SIF_RESET_DISP_QUEUE_BIT           (1<<2)
+#define MSD_SIF_RESET_DTL_CACHE_BIT            (1<<3)
+#define MSD_SIF_RESET_SLICE_BIT                (1<<4)
+#define MSD_SIF_RESET_SPP_BIT                  (1<<5)
+#define MSD_SIF_RESET_DTL_4K_CACHE_BIT         (1<<6)    /* TODO - useme */
+#define MSD_SIF_RESET_DBE_BIT                  (1<<7)
+#define MSD_SIF_RESET_DFE_BIT                  (1<<8)
+
+//MSD_CTX_NEXT_SF_ADDR
+#define MSD_CTX_NEXT_BS_IDC_POS       0
+#define MSD_CTX_NEXT_BS_IDC_MASK      0xF
+#define MSD_CTX_NEXT_FORMAT_POS       4
+#define MSD_CTX_NEXT_FORMAT_MASK      0x1F
+
+// PES control
+//volatile u_int32  pes_setup;
+#define MSD_SIF_PES_SETUP_STRMID_POS              0
+#define MSD_SIF_PES_SETUP_SET_STRMID(id)          ((id&0xff)<<MSD_SIF_PES_SETUP_STRMID_POS)
+#define MSD_SIF_PES_SETUP_STRMIDMASK_POS          8
+#define MSD_SIF_PES_SETUP_SET_STRMIDMASK(mask)    ((mask&0xff)<<MSD_SIF_PES_SETUP_STRMIDMASK_POS)
+#define MSD_SIF_PES_SETUP_PESIRQEN_POS            16
+#define MSD_SIF_PES_SETUP_PESIRQEN                (1<<MSD_SIF_PES_SETUP_PESIRQEN_POS)
+#define MSD_SIF_PES_SETUP_WAITPESHDR_POS          17
+#define MSD_SIF_PES_SETUP_WAITPESHDR              (1<<MSD_SIF_PES_SETUP_WAITPESHDR_POS)
+#define MSD_SIF_PES_SETUP_ERRORMODE_POS           18
+#define MSD_SIF_PES_SETUP_SET_ERRORMODE(type)     ((type&0x3)<<MSD_SIF_PES_SETUP_ERRORMODE_POS)
+#define MSD_SIF_PES_SETUP_ERRORMODE_NONE          0x0
+#define MSD_SIF_PES_SETUP_ERRORMODE_EIFLAG        0x2
+#define MSD_SIF_PES_SETUP_ERRORMODE_DISCONMARK    0x1
+#define MSD_SIF_PES_SETUP_PESEN_POS               20
+#define MSD_SIF_PES_SETUP_PESEN                   (1<<MSD_SIF_PES_SETUP_PESEN_POS)
+#define MSD_SIF_PES_SETUP_CHKPKTLEN_POS           21
+#define MSD_SIF_PES_SETUP_CHKPKTLEN               (1<<MSD_SIF_PES_SETUP_CHKPKTLEN_POS)
+#define MSD_SIF_PES_SETUP_SYNC_ALWAYS_POS         22
+#define MSD_SIF_PES_SETUP_SYNC_ALWAYS             (1<<MSD_SIF_PES_SETUP_SYNC_ALWAYS_POS)
+#define MSD_SIF_PES_SETUP_HOLD_DODGY_PTS_POS      23
+#define MSD_SIF_PES_SETUP_HOLD_DODGY_PTS          (1<<MSD_SIF_PES_SETUP_HOLD_DODGY_PTS_POS)
+// Optionally disallow match inside PKT, to support artificial streams that do not have emulation prevention bytes
+#define MSD_SIF_PES_SETUP_ENFORCE_PKTLEN_POS      24
+#define MSD_SIF_PES_SETUP_ENFORCE_PKTLEN          (1<<MSD_SIF_PES_SETUP_ENFORCE_PKTLEN_POS)
+
+//volatile u_int32  pes_status;
+#define MSD_SIF_PES_STATUS_STATE_POS              0
+#define MSD_SIF_PES_STATUS_GET_STATE(status)      ((status>>MSD_SIF_PES_STATUS_STATE_POS)&0x3f)
+#define MSD_SIF_PES_STATUS_EVENT_POS              6
+#define MSD_SIF_PES_STATUS_GET_EVENT(status)      ((status>>MSD_SIF_PES_STATUS_EVENT_POS)&0x3)
+#define MSD_SIF_PES_STATUS_PTS_PRESENT 0x2
+#define MSD_SIF_PES_STATUS_PTSDTS_PRESENT 0x3
+#define MSD_SIF_PES_STATUS_ERROR_PRESENT 0x1
+#define MSD_SIF_PES_STATUS_TOPDTS_POS             8
+#define MSD_SIF_PES_STATUS_GET_TOPDTS(status)      ((status>>MSD_SIF_PES_STATUS_TOPDTS_POS)&0x1)
+#define MSD_SIF_PES_STATUS_SET_TOPDTS(status)      ((status & 1) << MSD_SIF_PES_STATUS_TOPDTS_POS)
+#define MSD_SIF_PES_STATUS_TOPPTS_POS             9
+#define MSD_SIF_PES_STATUS_GET_TOPPTS(status)      ((status>>MSD_SIF_PES_STATUS_TOPPTS_POS)&0x1)
+#define MSD_SIF_PES_STATUS_SET_TOPPTS(status)      ((status & 1) << MSD_SIF_PES_STATUS_TOPPTS_POS)
+#define MSD_SIF_PES_STATUS_STALLED_POS            10
+#define MSD_SIF_PES_STATUS_GET_STALLED(status)    ((status>>MSD_SIF_PES_STATUS_STALLED_POS)&0x1)
+#define MSD_SIF_PES_STATUS_STREAM_ID_MASK          0xFF
+#define MSD_SIF_PES_STATUS_STREAM_ID_POS           12
+#define MSD_SIF_PES_STATUS_GET_STREAMID(status)    ((status>>MSD_SIF_PES_STATUS_STREAM_ID_POS)&MSD_SIF_PES_STATUS_STREAM_ID_MASK)
+#define MSD_SIF_PES_STATUS_TIMEBASE_ID_MASK        0x7
+#define MSD_SIF_PES_STATUS_TIMEBASE_ID_POS         12
+#define MSD_SIF_PES_STATUS_GET_TIMEBASE(status)    ((status>>MSD_SIF_PES_STATUS_TIMEBASE_ID_POS)&MSD_SIF_PES_STATUS_TIMEBASE_ID_MASK)
+#define MSD_SIF_PES_STATUS_PARITY_MASK             0x1
+#define MSD_SIF_PES_STATUS_PARITY_POS              15
+#define MSD_SIF_PES_STATUS_GET_PARITY(status)      ((status>>MSD_SIF_PES_STATUS_PARITY_POS)&MSD_SIF_PES_STATUS_PARITY_MASK)
+
+typedef enum
+{
+  pes_Seek        =  4, // 6'b0001_00, // Wait for initial start pes start code
+  pes_DumpPrefix  =  8, // 6'b0010_00, // Dumping the 0x00_00_01. Move on when get the 0x01
+  pes_DumpStrmID  = 12, // 6'b0011_00, // Dumping the 0x00_00_01. Move on when get the 0x01
+  pes_WaitClear   = 16, // 6'b0100_00, // Stalled waiting for firmware to clear the previous PTS
+  pes_PackLenH    = 20, // 6'b0101_00, //
+  pes_PackLenL    = 24, // 6'b0110_00, //
+  pes_Discon_0    = 28, // 6'b0111_00, // Output 0x00 from internally generates discontinuity
+  pes_Discon_1    = 32, // 6'b1000_00, // Output 0x00
+  pes_Discon_2    = 36, // 6'b1001_00, // Output 0x01
+  pes_Discon_3    = 40, // 6'b1010_00, // Output 0xB4
+  pes_ParseFW     = 60, // 6'b1111_00, // Just let firmware read the data one at a time
+  pes_Flags1      =  1, // 6'b0000_01,
+  pes_Flags2      =  5, // 6'b0001_01,
+  pes_HdrLen      =  9, // 6'b0010_01,
+  pes_PTS1        =  3, // 6'b0000_11,
+  pes_PTS2        =  7, // 6'b0001_11,
+  pes_PTS3        = 11, // 6'b0010_11,
+  pes_PTS4        = 15, // 6'b0011_11,
+  pes_PTS5        = 19, // 6'b0100_11,
+  pes_DTS1        = 23, // 6'b0101_11,
+  pes_DTS2        = 27, // 6'b0110_11,
+  pes_DTS3        = 31, // 6'b0111_11,
+  pes_DTS4        = 35, // 6'b1000_11,
+  pes_DTS5        = 39, // 6'b1001_11,
+  pes_DumpHdr     = 43, // 6'b1010_11, // Skipping over remainder of headre
+  pes_PayloadSync = 45, // 6'b1011_01, // Outputting first payload byte to SCD
+  pes_Payload     = 49  // 6'b1100_01  // Outputting payload to SCD
+
+} PES_STATE;
+
+// BSDMA Control
+//volatile u_int32 bsdma_command;
+#define MSD_SIF_BSDMA_CMND_START              0x1
+#define MSD_SIF_BSDMA_CMND_FETCHSTRDESC       0x2
+#define MSD_SIF_BSDMA_CMND_STOP               0x4
+#define MSD_SIF_BSDMA_CMND_CLEAR              0x8
+#define MSD_SIF_BSDMA_CMND_FORCE_DESC_UPDATE  0x10
+#define MSD_SIF_BSDMA_CMND_FORCE_CALC_LEVEL   0x20
+
+//volatile u_int32 bsdma_options;
+#define MSD_SIF_BSDMA_OPT_ENABLE  0x1
+#define MSD_SIF_BSDMA_OPT_PERIEN  0x2
+#define MSD_SIF_BSDMA_OPT_OFLIRQEN  0x4
+#define MSD_SIF_BSDMA_OPT_DISCONEN  0x8
+#define MSD_SIF_BSDMA_OPT_DESCUPPER_POS  4
+#define MSD_SIF_BSDMA_OPT_LOCBUFSIZE_POS  8
+#define MSD_SIF_BSDMA_OPT_LOCBUFOFFSET_POS  16
+#define MSD_SIF_BSDMA_OPT_DEBUG_FEED (1<<24)
+#define MSD_SIF_BSDMA_OPT_BURST      (1<<25)
+
+#define MSD_SIF_BSDMA_OPT_SAFEREADMARGIN_POS 26
+#define MSD_SIF_BSDMA_OPT_TRACEBACK_POS  28
+#define MSD_BSDMA_STRIDE_END_IRQ_P0S         30     // Interrupt when all data read
+#define MSD_BSDMA_STRIDE_END_IRQ (1<<MSD_BSDMA_STRIDE_END_IRQ_P0S)
+#define MSD_BSDMA_STRIDE_DONE_IRQ_POS        31   // Interrupt when all data used
+#define MSD_BSDMA_STRIDE_DONE_IRQ ((u_int32)(1<<MSD_BSDMA_STRIDE_DONE_IRQ_POS))
+
+
+#define MSD_SIF_BSDMA_OPT_0B_SAFEMARGIN (0<<MSD_SIF_BSDMA_OPT_SAFEREADMARGIN_POS)
+#define MSD_SIF_BSDMA_OPT_128B_SAFEMARGIN (1<<MSD_SIF_BSDMA_OPT_SAFEREADMARGIN_POS)
+#define MSD_SIF_BSDMA_OPT_2KB_SAFEMARGIN (2<<MSD_SIF_BSDMA_OPT_SAFEREADMARGIN_POS)
+#define MSD_SIF_BSDMA_OPT_32KB_SAFEMARGIN (3<<MSD_SIF_BSDMA_OPT_SAFEREADMARGIN_POS)
+
+#define MSD_SIF_BSDMA_OPT_TRACEBACK_0     (0<<MSD_SIF_BSDMA_OPT_TRACEBACK_POS)
+#define MSD_SIF_BSDMA_OPT_TRACEBACK_16K   (1<<MSD_SIF_BSDMA_OPT_TRACEBACK_POS)
+#define MSD_SIF_BSDMA_OPT_TRACEBACK_256K  (2<<MSD_SIF_BSDMA_OPT_TRACEBACK_POS)
+#define MSD_SIF_BSDMA_OPT_TRACEBACK_4M    (3<<MSD_SIF_BSDMA_OPT_TRACEBACK_POS)
+
+/* Constant defines on the 160/128 64-bit words of IBB memory    */
+/* Split between the BSDMA stream buffer and the H.264 IBB usage */
+#define IBBBUF_SIZE        128
+#define IBBBUF_SIZE_LARGE  160
+#define BSDMA_IBBBUF_USAGE  16
+
+//volatile u_int32 bsdma_status;
+#define MSD_SIF_BSDMA_STATUS_CB_LEVEL    (0xFF)
+#define MSD_SIF_BSDMA_STATUS_NMEMWORDS   (0x1f<<8)
+#define MSD_SIF_BSDMA_STATUS_BELOW_LWM   (0x1<<13)   //  Currently below Low Water Mark
+#define MSD_SIF_BSDMA_STATUS_BELOW_LWMH  (0x1<<14)   //  Below Low Water Mark since last cleared
+#define MSD_SIF_BSDMA_STATUS_BUFOFLOW    (0x1<<15)
+#define MSD_SIF_BSDMA_STATUS_DMA_STATE   (0x1F<<16)
+#define MSD_SIF_BSDMA_STATUS_MCX_STATE   (0x3F<<21)
+#define MSD_SIF_BSDMA_STATUS_RQ_STATE    (0x1<<27)
+#define MSD_SIF_BSDMA_STATUS_ABOVE_HWM   (0x1<<28)   //  Currently above High Water Mark
+#define MSD_SIF_BSDMA_STATUS_ABOVE_HWMH  (0x1<<29)   //  Above High Water Mark since last cleared
+#define MSD_SIF_BSDMA_STATUS_STRIDE_END  (0x1<<30)   //  all data fed
+#define MSD_SIF_BSDMA_STATUS_STRIDE_DONE ((u_int32)(0x1<<31))   //  all data used
+
+#define MSD_SIF_BSDMA_EXTOPT_LOOPBIT_POS    0x0
+#define MSD_SIF_BSDMA_EXTOPT_CB_MIN_POS     3
+#define MSD_SIF_BSDMA_EXTOPT_REQ_8          (1<<10)
+#define MSD_SIF_BSDMA_EXTOPT_SINGLE_STRIDE  (1<<11)
+#define MSD_SIF_BSDMA_EXTOPT_INIT_IRQ       (1<<12)
+#define MSD_SIF_BSDMA_EXTOPT_MIN_UPDATES    (1<<13)
+#define MSD_SIF_BSDMA_EXTOPT_CHECK_WPTR     (1<<14)
+
+//volatile u_int32 bsdma_ext_options;
+#define MSD_SIF_BSDMA_EXTOPT_LOOPBIT_SET(w) ((w&0x7)<<MSD_SIF_BSDMA_EXTOPT_LOOPBIT_POS)
+#define MSD_SIF_BSDMA_EXTOPT_LOOPBIT_GET(r) ((r>>MSD_SIF_BSDMA_EXTOPT_LOOPBIT_POS)&0x7)
+#define MSD_SIF_BSDMA_EXTOPT_SINGLESHOTEXITMODE MSD_SIF_BSDMA_EXTOPT_SINGLE_STRIDE
+
+// This define is used only when FW controls how close the RP can get to the WP
+// For pecos we are assuming at least two full burst of distance
+//#define BSDMA_WP_AHEAD_OF_RP_MARGIN (2*16*8)
+#define BSDMA_WP_AHEAD_OF_RP_MARGIN (8*16*8)
+#define BSDMA_DESC_REAL_ADDR(x) (x&0xfffffff)
+#define BSDMA_DESC_WRAP_ADDR(x) (x&0xf0000000)
+#define BSDMA_DESC_NOPARITY_MASK 0xfffffffe
+
+
+#define MSD_FORMAT_H264          (0x1  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_VC1           (0x2  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_MP2           (0x3  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_AVS           (0x4  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_ASP           (0x5  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_JPG           (0xD  <<MSD_CTX_NEXT_FORMAT_POS) // Uses aspd HW and ext. format flag
+#define MSD_FORMAT_RV8           (0x6  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_RV9           (0xE  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_VP6           (0x7  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_VP8           (0xF  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_VP3           (0x7  <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_HEVC          (0x10 <<MSD_CTX_NEXT_FORMAT_POS)
+#define MSD_FORMAT_NULL          (0x0  <<MSD_CTX_NEXT_FORMAT_POS)
+
+//MSD_SIF_DPBMC_SETUP_ADDR
+#define MSD_SIF_DPBMC_SET_CRC_TYPE(datasrc,datatype) (((0x3&datatype)<<2)|(datasrc&0x3))
+
+#define MSD_SIF_DPBMC_CLEAR_CRC2_TYPE_MASK            0xFF0FFFFF
+#define MSD_SIF_DPBMC_SET_CRC2_TYPE(datasrc,datatype) (((0x3&datatype)<<22)|((datasrc&0x3)<<20))
+// Alternate method of setup
+
+#define MSD_SIF_DPBMC_CLEAR_CRC2_MAJOR_MINOR_TYPE_MASK 0x87CFFFFF
+#define MSD_SIF_DPBMC_SET_CRC2_TYPE_MAJOR(datatype)    (( 0x3 & datatype ) << 20 )
+#define MSD_SIF_DPBMC_SET_CRC2_TYPE_MINOR(datasrc)     (( 0xf & datasrc ) << 27 )
+#define MSD_SIF_DPBMC_GET_CRC2_TYPE_MAJOR(datatype)    (( datatype >> 20 ) & 0x3 )
+#define MSD_SIF_DPBMC_GET_CRC2_TYPE_MINOR(datasrc)     (( datasrc  >> 27)  & 0xf )
+#define MSD_SIF_DPBMC_SET_CRC_ALT_TYPE_MAJOR(datatype) (( 0x3 & datatype ) << 2 )
+#define MSD_SIF_DPBMC_SET_CRC_ALT_TYPE_MINOR(datasrc)  (( 0xf & datasrc ) << 23 )
+#define MSD_SIF_DPBMC_SET_CRC_USE_ALT_TYPE(use)        (( use & 0x1 ) << 22 )
+
+#define MSD_SIF_DPBMC_CRC_RDDATA_TYPE   0x0
+#define MSD_SIF_DPBMC_CRC_WRDATA_TYPE   0x1
+#define MSD_SIF_DPBMC_CRC_RDADDR_TYPE   0x2
+#define MSD_SIF_DPBMC_CRC_WRADDR_TYPE   0x3
+#define MSD_SIF_DPBMC_CRC_BPP_SRCTYPE   0x3
+#define MSD_SIF_DPBMC_CRC_MBI_SRCTYPE   0x2
+#define MSD_SIF_DPBMC_CRC_PIXEL_SRCTYPE 0x0
+
+#define MSD_SIF_DPBMC_CRC_ALT_DBE1_SRCTYPE      0xf
+#define MSD_SIF_DPBMC_CRC_ALT_TES_SRCTYPE       0xe
+#define MSD_SIF_DPBMC_CRC_ALT_DFE_SRCTYPE       0xd
+#define MSD_SIF_DPBMC_CRC_ALT_MPSDBF_UV_SRCTYPE 0xc
+#define MSD_SIF_DPBMC_CRC_ALT_SVC_RSMP_SRCTYPE  0xb
+#define MSD_SIF_DPBMC_CRC_ALT_SVC_META_SRCTYPE  0xa
+#define MSD_SIF_DPBMC_CRC_ALT_MBQ_SRCTYPE       0x9
+#define MSD_SIF_DPBMC_CRC_ALT_CSC_SRCTYPE       0x8
+#define MSD_SIF_DPBMC_CRC_ALT_RPR_SRCTYPE       0x7
+#define MSD_SIF_DPBMC_CRC_ALT_MPSDBF_SRCTYPE    0x6
+#define MSD_SIF_DPBMC_CRC_ALT_MBI_SRCTYPE       0x5
+#define MSD_SIF_DPBMC_CRC_ALT_MX12_SRCTYPE      0x4
+#define MSD_SIF_DPBMC_CRC_ALT_MX34_SRCTYPE      0x3
+#define MSD_SIF_DPBMC_CRC_ALT_RSB_SRCTYPE       0x2
+#define MSD_SIF_DPBMC_CRC_ALT_MCX_SRCTYPE       0x1
+#define MSD_SIF_DPBMC_CRC_ALT_BSD_SRCTYPE       0x0
+
+#define MSD_SIF_DPBMC_OUTSTAND_REQ_POS 4
+#define MSD_SIF_DPBMC_OUTSTAND_REQ_MASK 0x7
+#define MSD_SIF_DPBMC_SET_OUTSTAND_REQ(num_req) ((num_req&MSD_SIF_DPBMC_OUTSTAND_REQ_MASK)<<MSD_SIF_DPBMC_OUTSTAND_REQ_POS)
+#define MSD_SIF_DPBMC_OUTSTAND_WR_REQ_POS 7
+#define MSD_SIF_DPBMC_OUTSTAND_WR_REQ_MASK 0x3
+#define MSD_SIF_DPBMC_SET_OUTSTAND_WR_REQ(num_req) ((num_req&MSD_SIF_DPBMC_OUTSTAND_WR_REQ_MASK)<<MSD_SIF_DPBMC_OUTSTAND_WR_REQ_POS)
+#define MSD_SIF_DPBMC_DBFAL_MODE_POS 9
+#define MSD_SIF_DPBMC_DBFAL_MODE_MASK 0x3
+#define MSD_SIF_DPBMC_SET_DBFAL_MODE(num_req) ((num_req&MSD_SIF_DPBMC_DBFAL_MODE_MASK)<<MSD_SIF_DPBMC_DBFAL_MODE_POS)
+#define MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH_POS  0x0
+#define MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH_MASK 0x1
+#define MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH(a) ((a&MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH_MASK)<<MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH_POS)
+#define MSD_SIF_DPBMC_SET_CLR_CHROMA_DPATH (~(MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH_MASK << MSD_SIF_DPBMC_SET_USE_CHROMA_DPATH_POS))
+
+
+// VMIF MBI CACHE
+#define MSD_VMIF_MBI_CACHE_RDCLR_POS       0
+#define MSD_VMIF_MBI_CACHE_RDCLR_MASK      0x7
+#define MSD_VMIF_MBI_CACHE_RDDIS_POS       3
+#define MSD_VMIF_MBI_CACHE_RDDIS_MASK      0x7
+#define MSD_VMIF_MBI_CACHE_RDSCLR_DIS_POS  6
+#define MSD_VMIF_MBI_CACHE_RDSCLR_DIS_MASK 0x7
+#define MSD_VMIF_MBI_CACHE_WRCLR_POS       9
+#define MSD_VMIF_MBI_CACHE_WRCLR_MASK      0x7
+#define MSD_VMIF_MBI_CACHE_WRDIS_POS       12
+#define MSD_VMIF_MBI_CACHE_WRDIS_MASK      0x7
+#define MSD_VMIF_MBI_CACHE_WRFLSH_POS      15
+#define MSD_VMIF_MBI_CACHE_WRFLSH_MASK     0x7
+
+#define MSD_VMIF_MBI_CACHE_SET_RDCLR(w)      ((w&MSD_VMIF_MBI_CACHE_RDCLR_MASK)<<MSD_VMIF_MBI_CACHE_RDCLR_POS)
+#define MSD_VMIF_MBI_CACHE_SET_RDDIS(w)      ((w&MSD_VMIF_MBI_CACHE_RDDIS_MASK)<<MSD_VMIF_MBI_CACHE_RDDIS_POS)
+#define MSD_VMIF_MBI_CACHE_SET_RDSCLR_DIS(w) ((w&MSD_VMIF_MBI_CACHE_RDSCLR_DIS_MASK)<<MSD_VMIF_MBI_CACHE_RDSCLR_DIS_POS)
+#define MSD_VMIF_MBI_CACHE_SET_WRCLR(w)      ((w&MSD_VMIF_MBI_CACHE_WRCLR_MASK)<<MSD_VMIF_MBI_CACHE_WRCLR_POS)
+#define MSD_VMIF_MBI_CACHE_SET_WRDIS(w)      ((w&MSD_VMIF_MBI_CACHE_WRDIS_MASK)<<MSD_VMIF_MBI_CACHE_WRDIS_POS)
+#define MSD_VMIF_MBI_CACHE_SET_WRFLSH(w)     ((w&MSD_SIF_DPBMC_OUTSTAND_WR_REQ_MASK)<<MSD_VMIF_MBI_CACHE_WRFLSH_POS)
+
+
+// DPBMC SETUP 2
+#define MSD_SIF_DPBMC_SET_OUTSTAND_MBIRD_MASK 0x3
+#define MSD_SIF_DPBMC_SET_OUTSTAND_MBIRD_POS  14
+#define MSD_VMIF_MPSAL_MODE_DISOB_BIT        13
+#define MSD_VMIF_MPSAL_MODE_REQ16_BIT        10
+#define MSD_VMIF_MPSAL_MODE_16PIX_POS         9
+//      MSD_SIF_COUNT_STRB_SEL_BITS          8:1
+#define MSD_SIF_COUNT_RD_CMD_STRB_SEL        7
+#define MSD_SIF_COUNT_WR_CMD_STRB_SEL        6
+#define MSD_SIF_COUNT_WR_STRB_SEL            5
+#define MSD_SIF_COUNT_RD_STRB_SEL            4
+#define MSD_SIF_COUNT_UV_RD_STRB_SEL         3
+#define MSD_SIF_COUNT_RSMP_RD_STRB_SEL       2
+#define MSD_SIF_COUNT_RSMP_MBMETA_STRB_SEL   1
+#define MSD_SIF_COUNT_MBI_RD_STRB_SEL        0
+
+#define MSD_SIF_COUNT_STRB_SEL_MASK          0x1
+#define MSD_SIF_COUNT_STRB_SET_USE_RD_CMD_STRB(a)      (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_RD_CMD_STRB_SEL       )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_WR_CMD_STRB(a)      (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_WR_CMD_STRB_SEL       )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_WR_STRB(a)          (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_WR_STRB_SEL           )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_RD_STRB(a)          (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_RD_STRB_SEL           )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_UV_RD_STRB(a)       (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_UV_RD_STRB_SEL        )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_RSMP_RD_STRB(a)     (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_RSMP_RD_STRB_SEL      )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_RSMP_MBMETA_STRB(a) (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_RSMP_MBMETA_STRB_SEL  )<<1)
+#define MSD_SIF_COUNT_STRB_SET_USE_MBI_RD_STRB(a)      (((a&MSD_SIF_COUNT_STRB_SEL_MASK)         <<MSD_SIF_COUNT_MBI_RD_STRB_SEL       )<<1)
+#define MSD_SIF_DPBMC_SET_OUTSTAND_MBIRD(a)            ((a&MSD_SIF_DPBMC_SET_OUTSTAND_MBIRD_MASK)<<MSD_SIF_DPBMC_SET_OUTSTAND_MBIRD_POS)
+
+
+#define MSD_DPBMC_DPBCOH_POS          9
+#define MSD_DPBMC_DPBCOH_MASK         0x1
+#define MSD_DPBMC_DPBCOH_SET(a) ((a&MSD_DPBMC_DPBCOH_MASK)<<MSD_DPBMC_DPBCOH_POS)
+#define MSD_DPBMC_MBICOH_POS          10
+#define MSD_DPBMC_MBICOH_MASK         0x1
+#define MSD_DPBMC_MBICOH_SET(a) ((a&MSD_DPBMC_MBICOH_MASK)<<MSD_DPBMC_MBICOH_POS)
+#define MSD_DPBMC_RSBCOH_POS          11
+#define MSD_DPBMC_RSBCOH_MASK         0x1
+#define MSD_DPBMC_RSBCOH_SET(a) ((a&MSD_DPBMC_RSBCOH_MASK)<<MSD_DPBMC_RSBCOH_POS)
+#define MSD_SIF_DPBMC_BASE_UNIT_POS   12
+#define MSD_SIF_DPBMC_BASE_UNIT_MASK 0x7
+#define MSD_SIF_DPBMC_SET_BASE_UNIT(base) ((base&MSD_SIF_DPBMC_BASE_UNIT_MASK)<<MSD_SIF_DPBMC_BASE_UNIT_POS)
+#define MSD_DPBMC_INT_WAIT_IDLE_POS   15
+#define MSD_DPBMC_INT_WAIT_IDLE_MASK  0x1
+#define MSD_DPBMC_INT_WAIT_IDLE_SET(a) ((a&MSD_DPBMC_INT_WAIT_IDLE_MASK)<<MSD_DPBMC_INT_WAIT_IDLE_POS)
+#define MSD_DPBMC_SC_INT_WAIT_IDLE_SET_POS      31
+#define MSD_DPBMC_SC_INT_WAIT_IDLE_SET_MASK     0x1
+#define MSD_DPBMC_SC_INT_WAIT_IDLE_SET(a) ((a&MSD_DPBMC_SC_INT_WAIT_IDLE_SET_MASK)<<MSD_DPBMC_SC_INT_WAIT_IDLE_SET_POS)
+#define MSD_DPBMC_ARB_MCX_POS         16
+#define MSD_DPBMC_ARB_MCX_MASK        0x1
+#define MSD_DPBMC_ARB_MCX_SET(a) ((a&MSD_DPBMC_ARB_MCX_MASK)<<MSD_DPBMC_ARB_MCX_POS)
+#define MSD_DPBMC_ARB_MCX_CLR(a) (~((a&MSD_DPBMC_ARB_MCX_MASK)<<MSD_DPBMC_ARB_MCX_POS))
+#define MSD_DPBMC_ARB_BSDMA_POS       17
+#define MSD_DPBMC_ARB_BSDMA_MASK      0x1
+#define MSD_DPBMC_ARB_BSDMA_SET(a) ((a&MSD_DPBMC_ARB_BSDMA_MASK)<<MSD_DPBMC_ARB_BSDMA_POS)
+#define MSD_DPBMC_ARB_BSDMA_CLR(a) (~((a&MSD_DPBMC_ARB_BSDMA_MASK)<<MSD_DPBMC_ARB_BSDMA_POS))
+#define MSD_DPBMC_DIS_CRC_AUTO_RESET_POS   19
+#define MSD_DPBMC_DIS_CRC_AUTO_RESET_MASK  0x1
+#define MSD_DPBMC_DIS_CRC_AUTO_RESET_SET(a) ((a&MSD_DPBMC_DIS_CRC_AUTO_RESET_MASK)<<MSD_DPBMC_DIS_CRC_AUTO_RESET_POS)
+#define MSD_DPBMC_DIS_CRC_AUTO_RESET_CLR(a) (~((a&MSD_DPBMC_DIS_CRC_AUTO_RESET_MASK)<<MSD_DPBMC_DIS_CRC_AUTO_RESET_POS))
+
+// Local memory configuration (power down)
+#define MSD_SIF_LMEM_CONFIG_PD_MASK    0x1
+#define MSD_SIF_LMEM_CONFIG_PD_CCHE0_POS 0
+#define MSD_SIF_LMEM_CONFIG_PD_RSB_POS   1
+#define MSD_SIF_LMEM_CONFIG_PD_AVSD_POS  2
+#define MSD_SIF_LMEM_CONFIG_PD_MPGD_POS  3
+#define MSD_SIF_LMEM_CONFIG_PD_VC1D_POS  4
+#define MSD_SIF_LMEM_CONFIG_PD_AVCD_POS  5
+#define MSD_SIF_LMEM_CONFIG_PD_COMM_POS  6
+#define MSD_SIF_LMEM_CONFIG_PD_RPR_POS   7
+#define MSD_SIF_LMEM_CONFIG_PD_CCHE1_POS 14
+#define MSD_SIF_LMEM_CONFIG_PD_HEVD_POS  15
+#define MSD_SIF_LMEM_CONFIG_PD_VMIF_POS  17
+
+#define MSD_SIF_LMEM_CONFIG_SET_PD_CCHE0(a)   ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_CCHE0_POS )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_RSB(a)     ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_RSB_POS   )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_AVSD(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_AVSD_POS  )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_MPGD(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_MPGD_POS  )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_VC1D(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_VC1D_POS  )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_AVCD(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_AVCD_POS  )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_COMM(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_COMM_POS  )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_RPR(a)     ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_RPR_POS   )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_CCHE1(a)   ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_CCHE1_POS )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_HEVD(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_HEVD_POS  )
+#define MSD_SIF_LMEM_CONFIG_SET_PD_VMIF(a)    ((a&MSD_SIF_LMEM_CONFIG_PD_MASK) <<MSD_SIF_LMEM_CONFIG_PD_VMIF_POS  )
+
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_CCHE0(a) (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_CCHE0_POS )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_RSB(a)   (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_RSB_POS   )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_AVSD(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_AVSD_POS  )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_MPGD(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_MPGD_POS  )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_VC1D(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_VC1D_POS  )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_AVCD(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_AVCD_POS  )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_COMM(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_COMM_POS  )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_RPR(a)   (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_RPR_POS   )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_CCHE1(a) (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_CCHE1_POS )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_HEVD(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_HEVD_POS  )))
+#define MSD_SIF_LMEM_CONFIG_RESET_PD_VMIF(a)  (a & (~(MSD_SIF_LMEM_CONFIG_PD_MASK << MSD_SIF_LMEM_CONFIG_PD_VMIF_POS  )))
+
+
+
+// Row-store buffer control
+//--------------------------
+// MSD_SIF_RSB_CTRL_STAT_ADDR (0x6e) //0x1b8
+#define MSD_SIF_RSB_SWITCH_REGION_ACCESS_POS    0x0
+#define MSD_SIF_RSB_SWITCH_REGION_ACCESS_MASK   0x1
+#define MSD_SIF_RSB_SWITCH_REGION_ACCESS_GET(r) (( r >> MSD_SIF_RSB_SWITCH_REGION_ACCESS_POS ) & MSD_SIF_RSB_SWITCH_REGION_ACCESS_MASK )
+#define MSD_SIF_RSB_SWITCH_REGION_ACCESS_SET(w) (( w & MSD_SIF_RSB_SWITCH_REGION_ACCESS_MASK ) << MSD_SIF_RSB_SWITCH_REGION_ACCESS_POS )
+#define MSD_SIF_RSB_INT_BASE_ADDR_SET(a) ((0x1fff & a)<<0) // 12:0
+#define MSD_SIF_RSB_XFR_XNUM_MASK        ((0xff )<<13)
+#define MSD_SIF_RSB_XFR_XNUM_SET(a)      ((0xff & a )<<13) //20:13
+#define MSD_SIF_RSB_XFR_YNUM_MASK        ((0x7 )<<21)   // 23:21
+#define MSD_SIF_RSB_XFR_YNUM_SET(a)      ((0x7 & a)<<21)   // 23:21
+#define MSD_SIF_RSB_SPLIT_FACTOR_MASK    ((0x3 )<<24)  //25:24
+#define MSD_SIF_RSB_SPLIT_FACTOR_SET(a)  ((0x3 & a)<<24)  //25:24
+#define MSD_SIF_RSB_XFR_MODE_MASK        ((0x3 )<<26)  //27:26
+#define MSD_SIF_RSB_XFR_MODE_SET(a)      ((0x3 & a)<<26)  //27:26
+#define MSD_SIF_RSB_XFR_START_MASK       ((0x1 )<<28) //28
+#define MSD_SIF_RSB_XFR_START_SET(a)     ((0x1 & a)<<28) //28
+#define MSD_SIF_RSB_APB_ACC_EN_MASK      ((0x1 )<<31) //31
+#define MSD_SIF_RSB_APB_ACC_EN_SET(a)    ((0x1 & a)<<31) //31
+
+#define MSD_SIF_RSB_XFR_PROG_GET(a)      (( a >>29) & 0x1) //29
+#define MSD_SIF_RSB_XFR_DONE_GET(a)      (( a >>30) & 0x1) //30
+#define MSD_SIF_RSB_XFR_MODE_GET(a)      (( a >>26) & 0x3) //27:26
+
+
+// Ancillary RSB transfer defines
+//-------------------------------
+#define MSD_SIF_RSB_INT_BASE_ADDR_MASK   0x1FFFF
+
+//MSD_SIF_EXT_RSB_BASE_ADDR (0X6f) //0x1bc
+#define MSD_SIF_EXT_RSB_BASE_ADDR_SET(a)  (a & 0xffffff) // 31:3
+//MSD_SIF_EXT_XFR_PARAMS_ADDR (0x70) 0x1c0
+#define MSD_SIF_EXT_XFR_PARAM_TF_TYPE_MASK   ((0x3) <<30 ) //31:30  0:2DLU; 1:2DCR 2:MINF 3:1DTF ;
+#define MSD_SIF_EXT_XFR_PARAM_TF_TYPE(a)     ((a & 0x3) <<30 ) //31:30  0:2DLU; 1:2DCR 2:MINF 3:1DTF ;
+#define MSD_SIF_EXT_XFR_PARAM_TYPE_GET(a)    (( a >>30) & 0x3) //31:30
+// 2D transferred
+#define MSD_SIF_EXT_XFR_PARAM_FIELD_FRAME_MASK ((0x01)<<29) //29 : field 1 ; 0 frame
+#define MSD_SIF_EXT_XFR_PARAM_TOP_ROW_POS_MASK ((0x7ff)<<18) // row position in frame of top row of data in the transfer
+#define MSD_SIF_EXT_XFR_PARAM_COL_LFT_POS_MASK ((0xff )<<10) // collumn position in frame of left-most word in the transfer
+#define MSD_SIF_EXT_XFR_PARAM_NUM_ROW_MASK     ((0x1f )<<5)  // number of rows in a tile to be transferred
+#define MSD_SIF_EXT_XFR_PARAM_NUM_PER_ROW_MASK ((0x3) <<0)  // number of words per row in a tile to be transferred
+
+#define MSD_SIF_EXT_XFR_PARAM_FIELD_FRAME(a) ((a & 0x01)<<29) //29 : field 1 ; 0 frame
+#define MSD_SIF_EXT_XFR_PARAM_TOP_ROW_POS(a) ((a & 0x7ff)<<18) // row position in frame of top row of data in the transfer
+#define MSD_SIF_EXT_XFR_PARAM_COL_LFT_POS(a) ((a & 0xff )<<10) // collumn position in frame of left-most word in the transfer
+#define MSD_SIF_EXT_XFR_PARAM_NUM_ROW(a)     ((a & 0x1f )<<5)  // number of rows in a tile to be transferred
+#define MSD_SIF_EXT_XFR_PARAM_NUM_PER_ROW(a) ((a & 0x3) <<0)  // number of words per row in a tile to be transferred
+// 1D transferred
+#define MSD_SIF_EXT_XFR_PARAM_NUM_WORDS_MASK ((0x1fff)<<0) // number of words to be transferred under 1D
+#define MSD_SIF_EXT_XFR_PARAM_NUM_WORDS(a)   ((a & 0x1fff)<<0) // number of words to be transferred under 1D
+#define MSD_SIF_EXT_XFR_BASE_ADDR_SET(a)  ( a & 0xffffff) // 31:3
+
+#define MSD_SIF_PWT_BASE_ADDR_POS           0x0
+#define MSD_SIF_PWT_BASE_ADDR_MASK          0x3FFF
+#define MSD_SIF_PXD_BASE_ADDR_POS           0x10
+#define MSD_SIF_PXD_BASE_ADDR_MASK          0x3FFF
+
+#define MSD_SIF_PUT_PWT_BASE(w)        (( w & MSD_SIF_PWT_BASE_ADDR_MASK ) << MSD_SIF_PWT_BASE_ADDR_POS )
+#define MSD_SIF_PUT_PXD_BASE(w)        (( w & MSD_SIF_PXD_BASE_ADDR_MASK ) << MSD_SIF_PXD_BASE_ADDR_POS )
+
+#define MSD_SIF_BSD_BASE_ADDR_POS           0x0
+#define MSD_SIF_BSD_BASE_ADDR_MASK          0x3FFF
+#define MSD_SIF_DBFC_BASE_ADDR_POS          0x10
+#define MSD_SIF_DBFC_BASE_ADDR_MASK         0x3FFF
+#define MSD_SIF_RSB_USE_APB_OFF_POS         0x1F
+#define MSD_SIF_RSB_USE_APB_OFF_MASK        0x1
+
+#define MSD_SIF_PUT_BSD_BASE(w)        (( w & MSD_SIF_BSD_BASE_ADDR_MASK ) << MSD_SIF_BSD_BASE_ADDR_POS )
+#define MSD_SIF_PUT_DBFC_BASE(w)       (( w & MSD_SIF_DBFC_BASE_ADDR_MASK ) << MSD_SIF_DBFC_BASE_ADDR_POS )
+#define MSD_SIF_PUT_RSB_USE_APB(w)     (( w & MSD_SIF_RSB_USE_APB_OFF_MASK ) << MSD_SIF_RSB_USE_APB_OFF_POS )
+
+#define MSD_SIF_MPRR_BASE_ADDR_POS          0x0
+#define MSD_SIF_MPRR_BASE_ADDR_MASK         0x3FFF
+#define MSD_SIF_MPRC_BASE_ADDR_POS          0x10
+#define MSD_SIF_MPRC_BASE_ADDR_MASK         0x3FFF
+
+#define MSD_SIF_PUT_MPRR_BASE(w)       (( w & MSD_SIF_MPRR_BASE_ADDR_MASK ) << MSD_SIF_MPRR_BASE_ADDR_POS )
+#define MSD_SIF_PUT_MPRC_BASE(w)       (( w & MSD_SIF_MPRC_BASE_ADDR_MASK ) << MSD_SIF_MPRC_BASE_ADDR_POS )
+
+
+/* MVD VMIF Options */
+#define MSD_VMIF_TAG_ACK_ON_FLUSH_POS         0
+#define MSD_VMIF_MAX_RD_REQ_SIZE_POS          1
+#define MSD_VMIF_CACHE_ENAB_POS               3
+#define MSD_VMIF_CACHE_RST_STAT_POS           4
+#define MSD_VMIF_SPLIT_READS_POS              5
+#define MSD_VMIF_SPLIT_WRITES_POS             6
+#define MSD_VMIF_FS_OFFSET_8PIX_POS           7
+#define MSD_VMIF_FS_OFFSET_CHROMA_8PIX_POS    8
+#define MSD_VMIF_CACHE_16WAY_MODE_POS         9
+#define MSD_VMIF_SCALE_MODE_POS               10
+#define MSD_VMIF_RSB_EXT_CACHE_ENAB           11
+#define MSD_VMIF_MAX_RD_SIZE_CONFIG_POS       12
+#define MSD_VMIF_MBI_RD_BUS_ENAB_POS          13
+#define MSD_VMIF_CACHE_DIS_AUTO_RST_POS       15
+#define MSD_VMIF_MBI_WR_BUS_ENAB_POS          16
+
+#define MSD_VMIF_DISABLE_BIT_POS              18
+#define MSD_VMIF_USE_RPR_STRIDES_POS          19
+#define MSD_VMIF_DBG_SEL_POS                  20
+#define MSD_VMIF_USE_4K_CACHE_CTRL_POS        23
+#define MSD_VMIF_4K_CACHE_ENAB_POS            24
+#define MSD_VMIF_4K_CACHE_RST_STAT_POS        25
+#define MSD_VMIF_4K_CACHE_DIS_AUTO_RST_POS    26
+#define MSD_VMIF_PACK_FORMAT_POS              27
+#define MSD_VMIF_CACHE_MODE_POS               28
+#define MSD_VMIF_MPSAL_POS                    30
+#define MSD_VMIF_CLR_FSBA_POS                 31
+
+/* Extension : MVD VMIF Options */
+/* With the introduction of Pixif some of thee bits have been re-used */
+#define MSD_VMIF_USE_FBC_RPR_MASK             0x08000000             /* Bit 27      */
+#define MSD_VMIF_USE_FBC_RPR_POS              27
+
+#define MSD_VMIF_USE_MBI_RD_RPR_POS           13
+#define MSD_VMIF_USE_MBI_RD_CSC_POS           14
+#define MSD_VMIF_USE_MBI_RD_MASK              0x0006000              /* Bits 14: 13 */
+
+#define MSD_VMIF_USE_MBI_WR_RPR_POS           23
+#define MSD_VMIF_USE_MBI_WR_CSC_POS           24
+#define MSD_VMIF_USE_MBI_WR_JPG_DBF_POS       25
+#define MSD_VMIF_USE_MBI_WR_MP2_VC1_POS       26
+#define MSD_VMIF_USE_MBI_WR_MASK              0x7800000              /* Bits 26: 23 */
+
+#define MSD_VMIF_MAX_RD_128                0
+#define MSD_VMIF_MAX_RD_256                1
+#define MSD_VMIF_MAX_RD_512                2
+
+/* MVD VMIF RSB ERT ARBITER CONTROL */
+
+#define MSD_VMIF_RSB_CLIENT_DBF            0x0
+#define MSD_VMIF_RSB_CLIENT_MPR            0x1
+#define MSD_VMIF_RSB_CLIENT_PXD            0x2
+#define MSD_VMIF_RSB_CLIENT_BSD            0x3
+#define MSD_VMIF_RSB_CLIENT_PWT            0x4
+#define MSD_VMIF_RSB_CLIENT_HUF            0x5
+#define MSD_VMIF_RSB_CLIENT_MTL            0x6
+#define MSD_VMIF_RSB_CLIENT_APB            0x7
+#define MSD_VMIF_RSB_CLIENT_XFR            0x8
+#define MSD_VMIF_RSB_CLIENT_BBD            0x9
+#define MSD_VMIF_RSB_CLIENT_CQ             0xa
+#define MSD_VMIF_RSB_CLIENT_BOB            0xb
+#define MSD_VMIF_RSB_CLIENT_DFE            0xb   /* Yes this is deliberately the same - they replace the other in certain core configs */
+#define MSD_VMIF_RSB_CLIENT_CQBE           0xc
+
+#define MVD_RSB_ARB_CLIENT_MASK            0xFFFF
+#define MVD_RSB_ARB_READ_CLIENT_SHIFT      0x10
+
+/* RSB Defines */
+
+#define MSD_RSB_XFR_TYPE_LUMA    0x0
+#define MSD_RSB_XFR_TYPE_CHROMA  0x1
+#define MSD_RSB_XFR_TYPE_MBINFO  0x2
+#define MSD_RSB_XFR_TYPE_DATA    0x3
+
+#define MSD_RSB_MODE_ONCHIP_TOEXT    0x0 // direct is chip to ext ; is chip transaction with ext ;
+#define MSD_RSB_MODE_OFFCHIP_TOEXT   0x1 // direct is OFF chip to ext ; is off RSB transaction with ext ; off RSB is usable ; on chip not used
+#define MSD_RSB_MODE_ONCHIP_FREXT    0x2 // direct is ext to chip ; is chip transaction with ext ;
+#define MSD_RSB_MODE_OFFCHIP_FREXT   0x3 // direct is ext to off RSB ; is off RSB transaction with ext ;off RSB is usable ; on chip not used
+#define MSD_RSB_APB_ACC_EN_BIT       0x80000000
+
+
+/* MSD RPR Defines */
+#define MSD_RPR_SIZE_WIDTH_POS         0
+#define MSD_RPR_SIZE_HEIGHT_POS       16
+#define MSD_RPR_SIZE_WIDTH_MASK   0x3fff //14 bits
+
+#define MSD_RPR_FILL_VALUE_Y_POS       0
+#define MSD_RPR_FILL_VALUE_U_POS       8
+#define MSD_RPR_FILL_VALUE_V_POS      16
+#define MSD_RPR_FILL_VALUE_MASK     0xff  // 8bits
+
+#define MSD_RPR_CTRL_START_POS         0
+#define MSD_RPR_CTL_FILL_MODE_POS      1
+#define MSD_RPR_CTL_ROUNDING_POS       2
+#define MSD_RPR_CTL_H_PRIME_M_POS      8
+#define MSD_RPR_CTL_V_PRIME_N_POS     12
+#define MSD_RPR_CTL_PRIME_MASK       0xf
+#define MSD_RPR_CTL_IN_FS_IDC_POS     16
+#define MSD_RPR_CTL_OUT_FS_IDC_POS    24
+#define MSD_RPR_CTL_FS_IDC_MASK     0x1f
+
+#define MSD_RPR_CTRL_START_BIT         1
+
+#define MSD_RPR_STATUS_IN_PROG_POS    29
+
+
+/* Decoupled data packing */
+/* Pack Base Set */
+#define MSD_SIF_PLQ_PACK_ADDR_MASK        0xFFFFFFFF
+#define MSD_SIF_PLQ_PACK_ADDR_SHIFT       0x0
+
+#define MSD_SIF_SET_PLQ_PACK_ADDR( w )    (( w & MSD_SIF_PLQ_WRPACK_ADDR_MASK ) << MSD_SIF_PLQ_WRPACK_ADDR_SHIFT )
+
+/* PRB Bin configuration */
+#define MSD_SIF_PLQ_BIN_SIZE_MASK        0x3FFFFF
+#define MSD_SIF_PLQ_BIN_SIZE_SHIFT       0x0
+#define MSD_SIF_PLQ_NUM_BINS_MASK        0x3FF
+#define MSD_SIF_PLQ_NUM_BINS_SHIFT       0x16
+
+#define MSD_SIF_SET_PLQ_BIN_SIZE( w )    (( w & MSD_SIF_PLQ_BIN_SIZE_MASK ) << MSD_SIF_PLQ_BIN_SIZE_SHIFT )
+#define MSD_SIF_SET_PLQ_NUM_BINS( w )    (( w & MSD_SIF_PLQ_NUM_BINS_MASK ) << MSD_SIF_PLQ_NUM_BINS_SHIFT )
+
+/* DCP Bin configuration */
+#define MSD_SIF_DCP_START_BINDEX_MASK    0x3FF
+#define MSD_SIF_DCP_START_BINDEX_SHIFT   0x0
+#define MSD_SIF_DCP_NUM_BINS_MASK        0x3FF
+#define MSD_SIF_DCP_NUM_BINS_SHIFT       0xA
+
+#define MSD_SIF_SET_DCP_START_BINDEX( w )(( w & MSD_SIF_DCP_START_BINDEX_MASK ) << MSD_SIF_DCP_START_BINDEX_SHIFT )
+#define MSD_SIF_SET_DCP_NUM_BINS( w )    (( w & MSD_SIF_DCP_NUM_BINS_MASK     ) << MSD_SIF_DCP_NUM_BINS_SHIFT     )
+
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Function Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+#endif /* _MVD_SIF_CONTROL_H_ */
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_types.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_types.h
new file mode 100755
index 0000000..ccd93d3
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/Incl/mvd_types.h
@@ -0,0 +1,132 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd 
+                All rights reserved.               
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Author    : MediaIP FW Team
+  File name : mvd_types.h
+  Function  : Used as a home for generic MVD base decoder
+              types
+
+ ***************************************************/
+
+#ifndef _MVD_TYPES_H_
+#define _MVD_TYPES_H_
+
+#include "basetype.h"
+
+///////////////////////////////////////////////////////
+// tAuxCRCData
+
+typedef struct
+{
+  u_int32 uDpbCRC2;
+  u_int32 uBSCRC;
+  u_int32 uCRC0;
+  u_int32 uCRC1;
+  u_int32 uCRC2;
+  u_int32 uCRC3;
+  u_int32 uCRC4;
+  u_int32 uCRC5;
+  u_int32 uCRC6;
+  u_int32 uCRC7;
+  
+} tAuxCRCData, *ptAuxCRCData;
+
+///////////////////////////////////////////////////////
+// tAuxCRC2Data
+
+typedef struct
+{
+  u_int32 uCRC8;
+  u_int32 uCRC9;
+  u_int32 uCRC10;
+  u_int32 uCRC11;
+  u_int32 uCRC12;
+  u_int32 uCRC13;
+  u_int32 uCRC14;
+  
+} tAuxCRC2Data, *ptAuxCRC2Data;
+
+#define MVD_TRUE       0x1UL
+#define MVD_FALSE      0x0UL
+
+typedef float          MvdFloat;           // fVariableName,   *pfPointerName
+typedef double         MvdDouble;          // dVariableName,   *pdPointerName
+
+typedef volatile u_int32  MvdHwReg;  // rVariableName,   *prPointerName
+typedef volatile u_int32 *MvdHwAddr;
+
+/* ************** */
+/*  Debug arrays  */
+/* ************** */
+typedef struct
+{              
+  int32 index;
+  int32 array[512];
+} DBG_ARRAY_512;  
+
+typedef struct
+{              
+  int32 index;
+  int32 array[1024];
+} DBG_ARRAY_1024;  
+
+typedef struct
+{              
+  int32 index;
+  int32 array[2048];
+} DBG_ARRAY_2048;  
+
+typedef struct
+{              
+  int32 index;
+  int32 array[4096];
+} DBG_ARRAY_4096;
+
+///////////////////////////////////////////////////////
+// Metadata structs
+
+///////////////////////////////////////////////////////
+// TimeStamp Metadata
+
+typedef struct
+{              
+  u_int32   uPTS;
+  u_int32   uDTS;
+  u_int32   uPESFlags;
+  bool      bValid;
+
+} tMVD_METADATA_TS, *ptMVD_METADATA_TS;
+
+///////////////////////////////////////////////////////
+// Pic Struct Metadata
+
+typedef struct
+{              
+  u_int32 uDummy;
+  bool    bValid;
+  
+} tMVD_METADATA_PIC_STRUCT, *ptMVD_METADATA_PIC_STRUCT;
+
+///////////////////////////////////////////////////////
+// UData Metadata
+
+typedef struct
+{
+  bool     bValid;
+  void *   pUDataMemChunk;
+  u_int32  uWrPtr;
+  
+} tMVD_METADATA_UDATA, *ptMVD_METADATA_UDATA;
+
+#endif /* _MVD_TYPES_H_ */
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLib.c b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLib.c
new file mode 100755
index 0000000..ca7d70b
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLib.c
@@ -0,0 +1,152 @@
+/***************************************************
+   Copyright (c) 2015 Amphion Semiconductor Ltd 
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        DecoderLib.c
+  Description:     Decoder Library API level
+  Author:          Media IP FW team (Belfast & Shanghai)
+
+ ****************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "basetype.h"
+#include "mediaip_fw_types.h"
+#include "pal.h"
+#include "DecKernelLib.h"
+#include "DecKernelLibPrivate.h"
+#include "DecKernelLibCfg.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Variables
+/////////////////////////////////////////////////////////////////////////////////
+
+DEC_KERNEL_LIB gDecKernelLib = { 0x0 };
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Code
+/////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    decoder_kernel_lib_init                                          //
+//                                                                                //
+//  DESCRIPTION: This function initialises the decoder library                    //
+//               to be called from kernel space                                   //
+//               It's only purpose is to post interrupts via callback to a queue  //
+//               for processing in userspace                                      //
+//                                                                                //
+//  INPUTS:      pCfg - Pointer to a static configuration structure for the       //
+//                      library                                                   //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     MEDIAIP_FW_STATUS_                                               //
+//                  OK             - Success.                                     //
+//                  ALREADY_INIT   - This function has already been called and no //
+//                                   subsequent call to decoderlib_term made      //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS decoder_kernel_lib_init ( DECODERLIB_KERNEL_CFG * pCfg )
+{
+  MEDIAIP_FW_STATUS eRetCode = MEDIAIP_FW_STATUS_OK;
+
+  if ( gDecKernelLib.bInit == FALSE )
+  {
+    gDecKernelLib.bInit = TRUE;
+
+    /* Make all necessary init calls */
+    internal_decoder_kernel_lib_init ( pCfg );
+  }
+  else
+  {
+    eRetCode = MEDIAIP_FW_STATUS_ALREADY_INIT;
+  }
+
+  return eRetCode;
+
+}
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    decoderlib_register_event_callback                               //
+//                                                                                //
+//  DESCRIPTION: This function registers a handler for reporting decoder events   //
+//                                                                                //
+//  INPUTS:      hHandle - handle for the stream with which to register the       //
+//                         callbacks                                              //
+//               pfCallback -  Function ponter to be executed when a decoder      //
+//                             event is raised                                    //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     MEDIAIP_FW_STATUS_                                               //
+//                  OK             - Success.                                     //
+//                  BAD_HANDLE     - hHandle is not a valid decoder library       //
+//                                   handle                                       //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     Unknown if there are any constraints here as yet                 //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS decoder_kernel_lib_register_isr_callback ( u_int32                     uMalIdx,
+                                                             DecKernelLib_Isr_Callback_t pfCallback )
+{
+
+  if ( gDecKernelLib.bInit == FALSE )
+  {
+    pal_trace( DECODER_TL_WARNING, "DECODER_LIB: decoder_kernel_lib_register_isr_callback : Invalid Malone\n", uMalIdx );
+
+    return MEDIAIP_FW_STATUS_BAD_HANDLE;
+  }
+
+  internal_decoder_kernel_lib_register_isr_callback ( uMalIdx,
+                                                      pfCallback );
+
+  return MEDIAIP_FW_STATUS_OK;
+
+}
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    decoderlib_term                                                  //
+//                                                                                //
+//  DESCRIPTION: Deinitialises decode library                                     //
+//                                                                                //
+//  INPUTS:      None                                                             //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     MEDIAIP_FW_STATUS_                                               //
+//                  OK             - Success.                                     //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS decoder_kernel_lib_term ( )
+{
+  MEDIAIP_FW_STATUS eRetCode = MEDIAIP_FW_STATUS_OK;
+
+  gDecKernelLib.bInit = FALSE;
+
+  return eRetCode;
+
+}
+
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibCfg.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibCfg.h
new file mode 100755
index 0000000..8cee711
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibCfg.h
@@ -0,0 +1,95 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        DecLibCfg.h
+  Description:     Decoder Library Configuration
+  Author:          Media IP FW team (Belfast & Shanghai)
+
+ *******************************************************/
+
+#ifndef _DECODER_LIB_CFG_H_
+#define _DECODER_LIB_CFG_H_
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#ifndef VPU_KERNEL_BUILD
+#include "video_subsystem.h"
+#endif
+#include "mediaip_fw_types.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+/* Local defines cast to those in global cfg file */
+#define   DECODERLIB_MAX_MALONES           MEDIAIP_MAX_NUM_MALONES
+#define   DECODERLIB_MAX_DBE_UNITS         0x2
+
+/* These don't really need to be passed in the cfg methinks... */
+#define   DECODERLIB_NUM_STREAMS           NUM_DECODER_STREAMS
+#define   DECODERLIB_MAX_NUM_FRAMES        MAX_NUM_FRAMES_PER_STREAM
+#if HEVC_JVT_MODEL < 92
+#define   DECODERLIB_MAX_MBI_FRAMES        0x12
+#else
+#define   DECODERLIB_MAX_MBI_FRAMES        0x11
+#endif
+#define   DECODERLIB_MAX_DFE_AREAS         0x1
+#define   DECODERLIB_MAX_NUM_OVLP_FRMS     1
+#define   DECODERLIB_METADATA_AREA_NULL    0xFF
+#define   DECODERLIB_NUM_EVENTS_PER_STREAM 4
+#define   DECODERLIB_NUM_CMDS_PER_STREAM   4
+
+#define   DECODERLIB_MAX_MVC_DPID          1
+#define   DECODERLIB_MAX_MVC_TARGET_VIEWS  2
+#define   DECODERLIB_MAX_MVC_VIEWS         4
+
+#define   DECODERLIB_MAX_DPVS                0x1
+#define   DECODERLIB_PIXIF_MAX_UPIX_TARGETS  0x2
+#define   DECODERLIB_PIXIF_MAX_FBC_TARGETS   0x2
+#define   DECODERLIB_MAX_STREAM_LEVELS       DECODERLIB_MAX_MVC_VIEWS
+
+
+#define   DECODERLIB_MAX_STR_BUFFERS       DECODERLIB_MAX_STREAM_LEVELS
+#define   DECODERLIB_RC4_CONTEXT_VALS      66
+
+#if ( TARGET_LEVEL == HAPS ) || ( TARGET_LEVEL == SIMULATION )
+#define   DECODERLIB_NUM_DBG_FIFOS 26
+#else
+#define   DECODERLIB_NUM_DBG_FIFOS 1
+#endif
+
+#ifdef DECLIB_ENABLE_DCP
+#define   DECODERLIB_MAX_CQ_PER_MALONE     0x3
+#else
+#define   DECODERLIB_MAX_CQ_PER_MALONE     0x1
+#endif
+
+// Enable processing of PAFF streams
+// If defined Field frame storage choice is made at a picture level
+// otherwise it is made as a sequence level
+//#define PIXIF_STORE_AS_PAFF
+
+//-------------------------------------------------
+// Some options for testing different HW Configs
+//-------------------------------------------------
+//#define FSLCACHE0_BYPASS
+#define ALLOW_CHROMA_DP
+#define ALLOW_MPS_ALIGN
+#define ALLOW_OFFSET_FS
+//#define FORCE_UNCACHED_8x8
+//-------------------------------------------------
+
+#endif /* _DECODER_LIB_CFG_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.c b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.c
new file mode 100755
index 0000000..1aee235
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.c
@@ -0,0 +1,171 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        DecoderLibPrivate.c
+  Description:     Decoder Library API level
+  Author:          Kyle McAdoo - Media IP FW Team ( Belfast & Shanghai )
+
+ ***************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "basetype.h"
+#include "mediaip_fw_types.h"
+#include "pal.h"
+#include "DecKernelLibPrivate.h"
+#include "DecKernelLibHWControl.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Variables
+/////////////////////////////////////////////////////////////////////////////////
+
+u_int32                            uMvdKernelIrqPin[DECODERLIB_MAX_MALONES][0x2];
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Extern function prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+extern DEC_KERNEL_LIB              gDecKernelLib;
+extern MALONE_KERNEL_HW_SESSION    gMvdKernelHw[(DECODERLIB_MAX_MALONES + 1)];
+
+extern MEDIAIP_IRQ_RETCODE mvd_kernel_hw_primary_isr ( u_int32 irq_val );
+extern MEDIAIP_IRQ_RETCODE mvd_kernel_hw_secondary_isr ( u_int32 irq_val );
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Code
+/////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    internal_decoder_kernel_lib_init                                 //
+//                                                                                //
+//  DESCRIPTION: This function initialises the decoder library                    //
+//               more notes to follow when it works...                            //
+//                                                                                //
+//  INPUTS:      None                                                             //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     MEDIAIP_FW_STATUS_                                               //
+//                  OK             - Success.                                     //
+//                  BAD_PARAMETER  - Configuration structure not initialised      //
+//                  ALREADY_INIT   -                                              //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     This function must be called from non-interrupt context          //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS internal_decoder_kernel_lib_init ( DECODERLIB_KERNEL_CFG * pCfg )
+{
+  MEDIAIP_FW_STATUS RetCode = MEDIAIP_FW_STATUS_OK;
+
+  /* Parse interrupt config */
+  internal_decoder_kernel_lib_parse_cfg ( pCfg,
+                                          FALSE );
+
+  /* Setup hardware view of Malone */
+  mvd_kernel_hw_control_init ( pCfg );                                          
+                                          
+  return RetCode;
+}
+
+////////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    internal_decoder_kernel_lib_register_isr_callback                //
+//                                                                                //
+//  DESCRIPTION: This function registers handlers for event processing            //
+//               more notes to follow when it works...                            //
+//                                                                                //
+//  INPUTS:      hHandle - handle for the stream with which to register the       //
+//                         callbacks                                              //
+//               pfCallback -  Function ponter to be executed when a decoder      //
+//                             event is raised                                    //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       None.                                                            //
+//                                                                                //
+//  CONTEXT:     Unknown if there are any constraints here as yet                 //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void internal_decoder_kernel_lib_register_isr_callback ( u_int32                     uMalIdx,
+                                                         DecKernelLib_Isr_Callback_t pfCallback
+                                                       )
+{
+  gDecKernelLib.pfCallback[uMalIdx] = pfCallback;
+}
+
+///////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    internal_decoder_kernel_lib_parse_cfg                            //
+//                                                                                //
+//  DESCRIPTION: Update DecoderLib structs with info from the configuration       //
+//                                                                                //
+//  INPUTS:      pCfg   - The DecLib configuration                                //
+//               bCheck - A control variable which allows prints on changes in    //
+//                                                                                //
+//  OUTPUTS:     None.                                                            //
+//                                                                                //
+//  RETURNS:     None.                                                            //
+//                                                                                //
+//  NOTES:       Set bCheck in snapshot restarts to see what may be different     //
+//               in the configuration of the generation and restart platforms     //
+//                                                                                //
+//  CONTEXT:     Call from thread context                                         //
+//                                                                                //
+////////////////////////////////////////////////////////////////////////////////////
+
+void internal_decoder_kernel_lib_parse_cfg ( DECODERLIB_KERNEL_CFG * pCfg,
+                                             bool             bCheck
+                                           )
+{
+  PAL_PFNISR        pFnDecodeIsr;
+  u_int32           uMalIdx;
+
+  gDecKernelLib.uNumMalones = pCfg->uNumMalones;
+
+  for ( uMalIdx = 0x0; uMalIdx < gDecKernelLib.uNumMalones; uMalIdx++ )
+  {
+    uMvdKernelIrqPin[uMalIdx][0x0] = pCfg->uMaloneIrqPin[uMalIdx][0x0];
+    uMvdKernelIrqPin[uMalIdx][0x1] = pCfg->uMaloneIrqPin[uMalIdx][0x1];
+  }
+
+  /* Finally claim the interrupts */
+  pFnDecodeIsr = ( PAL_PFNISR )mvd_kernel_hw_primary_isr;
+  pal_int_register ( uMvdKernelIrqPin[0x0][0x0], pFnDecodeIsr, FALSE );
+  pFnDecodeIsr = ( PAL_PFNISR )mvd_kernel_hw_secondary_isr;
+
+  /* This is a safety check in case a lazy player does not setup the second irq */
+  if ( uMvdKernelIrqPin[0x0][0x0] != uMvdKernelIrqPin[0x0][0x1] )
+  {
+    pal_int_register ( uMvdKernelIrqPin[0x0][0x1], pFnDecodeIsr, FALSE );
+  }
+
+  if ( gDecKernelLib.uNumMalones > 0x1 )
+  {
+    pFnDecodeIsr = ( PAL_PFNISR )mvd_kernel_hw_primary_isr;
+    pal_int_register ( uMvdKernelIrqPin[0x1][0x0], pFnDecodeIsr, FALSE );
+    pFnDecodeIsr = ( PAL_PFNISR )mvd_kernel_hw_secondary_isr;
+
+    if ( uMvdKernelIrqPin[0x1][0x0] != uMvdKernelIrqPin[0x1][0x1] )
+    {
+      pal_int_register ( uMvdKernelIrqPin[0x1][0x1], pFnDecodeIsr, FALSE );
+    }
+  }
+}
+
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.h b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.h
new file mode 100755
index 0000000..a3dd00f
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/DecKLib/KernelIF/DecKernelLibPrivate.h
@@ -0,0 +1,69 @@
+/***************************************************
+   Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        DecKernelPrivate.h
+  Description:     Decoder Library Private header file - not
+                   for inclusion by code outside of decoder lib.
+  Author:          Media IP FW team (Belfast & Shanghai)
+
+ *******************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "DecKernelLib.h"
+
+/* Include NO other files here */
+
+#ifndef _DECODER_KERN_LIB_PRIV_H_
+#define _DECODER_KERN_LIB_PRIV_H_
+
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Global Structures
+/////////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////
+// DecoderLib Context structure
+
+typedef struct decoderlib_inst
+{
+  bool                            bInit;
+  u_int32                         uNumMalones;
+  /* One per Malone, kernel lib only has concept of Malone hardware, not */
+  /* the individual streams running on it!                                */
+  DecKernelLib_Isr_Callback_t     pfCallback[DECODERLIB_MAX_MALONES]; 
+
+} DEC_KERNEL_LIB;
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Function Prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS internal_decoder_kernel_lib_init ( DECODERLIB_KERNEL_CFG * pCfg );
+
+void internal_decoder_kernel_lib_register_isr_callback ( u_int32                     uMalIdx,
+                                                         DecKernelLib_Isr_Callback_t pfCallback
+                                                       );
+
+ void internal_decoder_kernel_lib_parse_cfg ( DECODERLIB_KERNEL_CFG * pCfg,
+                                              bool             bCheck
+                                            );
+                                                       
+#endif /* _DECODER_KERN_LIB_PRIV_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/Incl/basetype.h b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/basetype.h
new file mode 100755
index 0000000..a90567c
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/basetype.h
@@ -0,0 +1,343 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd 
+                All rights reserved.               
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+  Filename:        basetype.h
+  Description:     Public header file for use in all FW
+  Author:          Media IP FW team (Belfast)
+ 
+ ************************************************/
+
+#ifndef _BASETYPE_H_
+#define _BASETYPE_H_
+#ifndef VPU_KERNEL_BUILD
+#include <stdint.h>
+#include <stdio.h>
+#else
+#include <linux/types.h>
+#include <linux/kernel.h>
+#endif
+
+#ifdef WIN32
+#if _MSC_VER
+typedef unsigned __int64    u_int64;
+#else
+typedef unsigned long long  u_int64;
+#endif
+#else
+typedef unsigned long long  u_int64;
+#endif
+
+#ifdef MALONE_64BIT_ADDR
+typedef uint64_t       uint_addr;
+#else
+typedef uint32_t       uint_addr;
+#endif
+
+typedef uint32_t       u_int32;
+typedef uint16_t       u_int16;
+typedef uint8_t        u_int8;
+
+//Alignment Macro
+#define ALIGN_SIZE(x)    (((x)+sizeof(u_int32) - 1)/(sizeof(u_int32)))
+
+#ifdef WIN32
+#if _MSC_VER
+typedef signed __int64      int64;
+#else
+typedef signed long long    int64;
+#endif
+#else
+typedef signed long long    int64;
+#endif
+
+typedef int32_t         int32;
+typedef int16_t         int16;
+typedef int8_t          int8;
+typedef unsigned char       BYTE;
+
+// XXX:TAS  No idea what all this ifdefing is about
+//          should just need the C++ ifdef
+#ifndef HOST_BUILD
+#ifndef COREPLAY_API 
+#ifndef _MSC_VER
+#ifndef VPU_KERNEL_BUILD
+typedef unsigned int        bool;
+#endif
+#endif
+#else
+#ifndef _MSC_VER
+typedef unsigned int        bool;
+#endif
+#endif
+#else
+  #ifndef __cplusplus
+    // bool is defined in cpp
+    typedef unsigned int        bool;
+  #endif /* __cplusplus */
+#endif
+
+typedef unsigned char       BOOLEAN;
+
+#define VOID_PARAMS         void
+
+#define INT32               int32
+
+#define UINT8              u_int8
+#define UINT16             u_int16
+#define UINT32             u_int32
+#define UINT64             u_int64
+#ifdef _MSC_VER
+#define BOOL               int
+#else
+#define BOOL               bool
+#endif
+#define SINT8              int8
+#define SINT16             int16
+#define SINT32             int32
+#ifdef WIN32
+#define SINT64             int64
+#define SINT64_MIN         (-9223372036854775807i64 - 1i64)
+#else
+#define SINT64             int64
+#define SINT64_MIN         (-9223372036854775807LL - 1LL)
+#endif
+
+#ifndef VPU_KERNEL_BUILD
+#define SUCCESS 0
+#define FAILURE -1 
+#endif
+
+#ifdef __cplusplus
+#ifndef FALSE
+  #define FALSE 0
+#endif  
+#ifndef TRUE
+  #define TRUE  1
+#endif  
+#else  // 'C'
+#ifndef false
+  #define false 0
+#endif  
+#ifndef true
+  #define true  1
+#endif  
+
+#ifndef FALSE
+  #define FALSE 0
+#endif  
+#ifndef TRUE
+  #define TRUE  1
+#endif  
+#endif
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef OKAY
+#define	OKAY 0
+#endif
+
+#ifndef ZERO
+#define	ZERO 0
+#endif
+
+// Define more error types as used - 1st is generic
+#define MEDIAIP_ERROR_FLAG        1
+#define MEDIAIP_END_ES            2
+#define MEDIAIP_DECODER_EXIT      3
+#define MEDIAIP_ENCODER_EXIT      4
+#define MEDIAIP_VC1D_NOFREEFRAMES 5
+#define MEDIAIP_DECODER_SKIP      6
+
+/* Alignment macros - align address to a specific byte alignment */
+#define MEDIAIP_ALIGN_16(addr)  addr = (addr + (( 0x1 << 0x4 )  - 0x1 ) ) & ~((( 0x1 << 0x4 )  - 0x1 ))
+#define MEDIAIP_ALIGN_32(addr)  addr = (addr + (( 0x1 << 0x5 )  - 0x1 ) ) & ~((( 0x1 << 0x5 )  - 0x1 ))
+#define MEDIAIP_ALIGN_64(addr)  addr = (addr + (( 0x1 << 0x6 )  - 0x1 ) ) & ~((( 0x1 << 0x6 )  - 0x1 ))
+#define MEDIAIP_ALIGN_128(addr)  addr = (addr + (( 0x1 << 0x7 )  - 0x1 ) ) & ~((( 0x1 << 0x7 )  - 0x1 ))
+#define MEDIAIP_ALIGN_256(addr)  addr = (addr + (( 0x1 << 0x8 )  - 0x1 ) ) & ~((( 0x1 << 0x8 )  - 0x1 ))
+#define MEDIAIP_ALIGN_512(addr)  addr = (addr + (( 0x1 << 0x9 )  - 0x1 ) ) & ~((( 0x1 << 0x9 )  - 0x1 ))
+
+/* used when declaring single bitfields
+*/
+#define FLAG                      1
+
+#ifndef WIN32
+ #if CPU == MIPS
+  #define DOUBLE_ALIGN __attribute__((aligned(8)))
+  #define SECTION(sec) __attribute__ ((section (#sec)))
+  #define ALIGNED(ali) __attribute__ ((aligned (ali)))
+ #else
+   #define DOUBLE_ALIGN
+ #endif
+#endif // win32
+/* We need to stop defining ARM and use only CPU == ARM !!! */
+/* Lose all #ifdef ARM from code                            */
+
+/* - Only for RCVCT */
+#ifdef __CC_ARM
+  #define ALIGN_8_u_int8      __align(8) u_int8
+  #define ALIGN_8_u_int16     __align(8) u_int16
+  #define ALIGN_8_u_int32     __align(8) u_int32
+  #define ALIGN_256_u_int16   __align(256) u_int16
+  #define ALIGN_256_u_int32   __align(256) u_int32
+  #define ALIGN_1024_u_int32  __align(1024) u_int32
+  #define ALIGN_1024_u_int64  __align(1024) u_int64
+  #define ALIGN_1024          __align(1024)
+#else
+/* All others? */
+  #define ALIGN_8_u_int8      u_int8 __attribute__((aligned(8)))
+  #define ALIGN_8_u_int16     u_int16 __attribute__((aligned(8)))
+  #define ALIGN_8_u_int32     u_int32 __attribute__((aligned(8)))  
+  #define ALIGN_256_u_int16   u_int16 __attribute__((aligned(256)))
+  #define ALIGN_256_u_int32   u_int32 __attribute__((aligned(256)))
+  #define ALIGN_1024_u_int32  u_int32 __attribute__((aligned(1024)))
+  #define ALIGN_1024_u_int64  u_int64 __attribute__((aligned(1024)))
+  #define ALIGN_1024          __attribute__((aligned(1024)))
+#endif
+
+#ifndef COREPLAY_API
+#if RTOS == UCOS
+
+/* Additions for uCOS */
+
+typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
+typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
+typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
+typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
+typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
+typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
+typedef float          FP32;                     /* Single precision floating point                    */
+typedef double         FP64;                     /* Double precision floating point                    */
+
+typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
+typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (PSR = 32 bits) */
+
+#define UBYTE          INT8U                     /* ... to uC/OS V1.xx.  Not actually needed for ...   */
+#define WORD           INT16S                    /* ... uC/OS-II.                                      */
+#define UWORD          INT16U
+#define LONG           INT32S
+#define ULONG          INT32U
+
+#endif
+
+typedef signed short int   SHORT;   /* Signed   16 bit quantity  */
+typedef unsigned short     USHORT;
+
+#endif /* COREPLAY_API */
+
+/****************************************************************************/
+/*                                                                          */
+/* Hardware register access macros                                          */
+/*                                                                          */
+/****************************************************************************/
+
+#define RMO(y) \
+      ( ((y) & 0x00000001) ?  0 : \
+      ( ((y) & 0x00000002) ?  1 : \
+      ( ((y) & 0x00000004) ?  2 : \
+      ( ((y) & 0x00000008) ?  3 : \
+      ( ((y) & 0x00000010) ?  4 : \
+      ( ((y) & 0x00000020) ?  5 : \
+      ( ((y) & 0x00000040) ?  6 : \
+      ( ((y) & 0x00000080) ?  7 : \
+      ( ((y) & 0x00000100) ?  8 : \
+      ( ((y) & 0x00000200) ?  9 : \
+      ( ((y) & 0x00000400) ? 10 : \
+      ( ((y) & 0x00000800) ? 11 : \
+      ( ((y) & 0x00001000) ? 12 : \
+      ( ((y) & 0x00002000) ? 13 : \
+      ( ((y) & 0x00004000) ? 14 : \
+      ( ((y) & 0x00008000) ? 15 : \
+      ( ((y) & 0x00010000) ? 16 : \
+      ( ((y) & 0x00020000) ? 17 : \
+      ( ((y) & 0x00040000) ? 18 : \
+      ( ((y) & 0x00080000) ? 19 : \
+      ( ((y) & 0x00100000) ? 20 : \
+      ( ((y) & 0x00200000) ? 21 : \
+      ( ((y) & 0x00400000) ? 22 : \
+      ( ((y) & 0x00800000) ? 23 : \
+      ( ((y) & 0x01000000) ? 24 : \
+      ( ((y) & 0x02000000) ? 25 : \
+      ( ((y) & 0x04000000) ? 26 : \
+      ( ((y) & 0x08000000) ? 27 : \
+      ( ((y) & 0x10000000) ? 28 : \
+      ( ((y) & 0x20000000) ? 29 : \
+      ( ((y) & 0x40000000) ? 30 : \
+      ( ((y) & 0x80000000) ? 31 : 0 ))))))))))))))))))))))))))))))))
+
+/*
+ * Access macros used to get, set/clear bits within a hardware register.
+ * These macros *do not* perform any automatic shifting of bits and are
+ * meant to be used with bit definitions which include their encoded bit
+ * position within the register definition (e.g. an enable bit).
+ */
+
+#ifdef VSIM_ENV
+  UINT32  MEDIAIP_GET(UINT32,UINT32);
+  void    MEDIAIP_SET(UINT32,UINT32,UINT32);
+  #define MEDIAIP_PUT(reg,mask,val)	{ \
+								VSimAPI_WriteRegister((UINT32) reg, val); \
+          }
+  UINT32  MEDIAIP_SM_GET(volatile UINT32 *);
+  void    MEDIAIP_SM_SET(volatile UINT32 *, UINT32, UINT32 );
+  void    MEDIAIP_SM_PUT(volatile UINT32 *, UINT32 );
+
+#else
+
+  #define MEDIAIP_GET(reg,mask)      (*(LPREG)(reg) & (mask))
+  #define MEDIAIP_SET(reg,mask,val)  (*(LPREG)(reg)) = ((*(LPREG)(reg) & ~(mask)) | ((val) & (mask)))
+  #define MEDIAIP_PUT(reg,val)       (*(LPREG)(reg)) = (val)
+  #define MEDIAIP_SM_GET(x)          (*(x))
+  #define MEDIAIP_SM_SET(a,b,c)      (*(a)) = (((*(a)) & ~(b)) | ((c) & (b)))
+  #define MEDIAIP_SM_PUT(a,b)        (*(a)) = (b)
+
+// IDJ: Consider using this?
+// No- there are only a few instances where this would make a difference.
+//efine MEDIAIP_SET(reg,mask,val)  (*(LPREG)(reg)) = ((~(mask) ? 0 : (*(LPREG)(reg) & ~(mask))) | ((val) & (mask)))
+
+#endif
+
+/*
+ * Access macros used to get & set a numerical value within a hardware
+ * register.  These macros perform automatic shifting (based on the mask)
+ * of the numerical value used.  These macros are useful for setting a
+ * numerical value into a multi-bit contiguous field within a register.
+ */
+#define MEDIAIP_GET_VAL(reg,mask)           ((*(LPREG)(reg) & (mask)) >> RMO(mask))
+#define MEDIAIP_SET_VAL(reg,mask,val)       (*(LPREG)(reg)) =                     \
+                   ((*(LPREG)(reg) & ~(mask)) | (((unsigned long)(val) << RMO(mask)) & (mask)))
+
+#define MEDIAIP_REGWRITE(reg,val)    *((LPREG)(reg)) = (val)
+#define MEDIAIP_REGREAD(reg)         *((LPREG)(reg))
+
+
+#define MEDIAIP_SET_REG(reg,mask,val)    reg = ((reg & ~(mask)) | ((val) & (mask)))
+#define MEDIAIP_GET_REG(reg,mask)        reg & mask
+
+typedef unsigned long   HW_DWORD;      /* was u_int32; */
+typedef unsigned short  HW_WORD;       /* was u_int16; */
+typedef unsigned char   HW_BYTE;       /* was u_int8; */
+typedef unsigned int    HW_BOOL;       /* was bool; */
+typedef void            HW_VOID;
+
+typedef volatile u_int32 *LPREG;
+
+#ifdef __CC_ARM
+#define FUNC_INLINE	__inline
+#else
+#define FUNC_INLINE	inline
+#endif
+
+#endif /* _BASETYPE_H_ */
+
+/* End of File */
+
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_defines.h b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_defines.h
new file mode 100755
index 0000000..ed825ce
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_defines.h
@@ -0,0 +1,249 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        mediaip_fw_defines.h
+  Description:     Contains general definitions for
+                   module based architecture
+  Author:          Media IP FW team - Belfast
+
+  TODO-KMC - Should remove this file!!
+ **************************************************/
+
+#ifndef _MEDIAIP_FW_DEFINES_H_
+#define _MEDIAIP_FW_DEFINES_H_
+
+/* In use MACROS for use by types shared across modules                                        */
+/* When adding new modules, endeavour to maintain the same 'position' as that suggested by the */
+/* module's position in the MEDIAIP_FW_HANDLE_TYPE enumeration - see Modules/Public/handle.h   */
+
+#define IN_USE_DECODER   ( 1 << 0x0 )
+#define IN_USE_ENCODER   ( 1 << 0x1 )
+#define IN_USE_IMG_PORT  ( 1 << 0x2 )
+#define IN_USE_DISPLAY   ( 1 << 0x3 )
+#define IN_USE_VAMUX     ( 1 << 0x4 )
+#define IN_USE_VIPP      ( 1 << 0x5 )
+#define IN_USE_SYS_API   ( 1 << 0x10 )
+
+/////////////////////////////////////////////////
+// Frame Store Display Data make-up
+
+// Read
+#define FRAME_STORE_DISP_DATA_FSID(r)                  ((r>>0)&0x3f)
+#define FRAME_STORE_DISP_DATA_RPT_FIRST_FLD(r)         ((r>>15)&0x1)	  // IDJ: Pass RFF (borrow a bit from unused base addr field)
+#define FRAME_STORE_DISP_DATA_SPS_IDC_BITS(r)          ((r>>16)&0x7)
+#define FRAME_STORE_DISP_DATA_DANG_FIELD_BIT(r)        ((r>>19)&0x1)
+#define FRAME_STORE_DISP_DATA_FIELD_MODE_BIT(r)        ((r>>20)&0x1)
+#define FRAME_STORE_DISP_DATA_BOT_FIRST_BIT(r)         ((r>>21)&0x1)
+#define FRAME_STORE_DISP_DATA_SKIP_PIC_BITS(r)         ((r>>22)&0x3)
+#define FRAME_STORE_DISP_DATA_SYS_DATA_BITS(r)         ((r>>24)&0xFF)
+#define FRAME_STORE_DISP_DATA_FRAME_BADDR(r)           ((r>>0)&0x7FFF)
+#define FRAME_STORE_DATAFIELDS(a)				               (a&0xffff8000)	// IDJ - bit 15 used above
+
+// Write
+#define FRAME_STORE_DISP_DATA_PUT_FSID(a)                  ((a&0x3f) << 0)
+#define FRAME_STORE_DISP_DATA_PUT_FRAME_BADDR(a)			     ((a&0x7fff) << 0)
+#define FRAME_STORE_DISP_DATA_PUT_DUPLC_FRAME_SENT(a)      ((a&0x1) << 14)	 // RayC/JKD: but used to control when duplicate frames are sent
+#define FRAME_STORE_DISP_DATA_PUT_DUPLC_FRAME_SENT_GET(a)  ((a>>14)&0x1)
+#define FRAME_STORE_DISP_DATA_PUT_RPT_FIRST_FIELD(a)       ((a&0x1) << 15)	 // IDJ Borrow a bit from BADDR field (not used)
+#define FRAME_STORE_DISP_DATA_PUT_DISP_PARAM_ID(a)         ((a&0x7) << 16)
+#define FRAME_STORE_DISP_DATA_PUT_DANGLING_FIELD(a)        ((a&0x1) << 19)
+#define FRAME_STORE_DISP_DATA_PUT_FIELD_MODE(a)            ((a&0x1) << 20)
+#define FRAME_STORE_DISP_DATA_PUT_BOT_FIELD_FIRST(a)       ((a&0x1) << 21)
+#define FRAME_STORE_DISP_DATA_PUT_TOP_SKIPPED(a)           ((a&0x1) << 22)
+#define FRAME_STORE_DISP_DATA_PUT_BOT_SKIPPED(a)           ((a&0x1) << 23)
+#define FRAME_STORE_DISP_DATA_PUT_SYS_DATA(a)              ((a&0xff) << 24)
+
+#define NUM_DISP_PUSHES_MASK   0xFF00
+#define NUM_DISP_PUSHES_POS     8
+#define NUM_DISP_PUSHES_SET(x) (x<<NUM_DISP_PUSHES_POS)
+#define NUM_DISP_PUSHES_GET(x)  ( (x&NUM_DISP_PUSHES_MASK) >> NUM_DISP_PUSHES_POS)
+
+/////////////////////////////////////////////////
+// Display Params
+
+#define DISP_INFO_USER_DATA_ATTACHED_MASK 0x1
+#define DISP_INFO_USER_DATA_ATTACHED_POS 0
+#define DISP_INFO_GET_USER_DATA_ATTACHED(x) ((x&DISP_INFO_USER_DATA_ATTACHED_MASK)>>DISP_INFO_USER_DATA_ATTACHED_POS)
+#define DISP_INFO_USER_DATA_MASK 0xFFFF
+#define DISP_INFO_USER_DATA_POS   16
+#define DISP_INFO_GET_USER_DATA(x) ((x>>DISP_INFO_USER_DATA_POS)&DISP_INFO_USER_DATA_MASK)
+
+// uScanFormat defines
+
+#define DISP_SCAN_FORMAT_INTERLACED      0x0
+#define DISP_SCAN_FORMAT_PROGRESSIVE     0x1
+#define DISP_SCAN_FORMAT_VALID_GET(r)    (r&0x1)
+#define DISP_SCAN_FORMAT_GET(r)          ((r&0x2)>>1)
+#define DISP_SCAN_FORMAT_VALID_SET(r)    ((r&0x1)<<0)
+#define DISP_SCAN_FORMAT_SET(r)          ((r&0x1)<<1)
+
+/////////////////////////////////////////////////
+// General defines - base on Stream descriptor for Pecos
+
+#define STOP_IMMEDIATE               0x0
+#define STOP_COMPLETE_DISPLAY        0x1
+
+#define FORMAT_VC1	                 0x2
+#define FORMAT_MPEG2                 0x1
+#define FORMAT_MPEG4                 0x0
+#define FORMAT_MPEG2_DBEN            0x1
+#define FORMAT_MPEG2_DBDRNGEN        0x2
+
+#define STREAM_MODE_ES               0x1
+#define STREAM_MODE_PES              0x0
+
+#define DELIVERY_MODE_TSP_DIRECT     0x0
+#define DELIVERY_MODE_BSP            0x1
+#define DELIVERY_MODE_BSDMA          0x2
+
+// Buffer Indices
+#define SD_BUFIND_ESBUF_MASK         0xFF
+#define SD_BUFIND_ESBUF_SHIFT        0
+#define SD_BUFIND_STC_MASK           0x30000
+#define SD_BUFIND_STC_SHIFT          16
+#define SD_BUFIND_ESBUF_GET(x)       ((x&SD_BUFIND_ESBUF_MASK)>>SD_BUFIND_ESBUF_SHIFT)
+#define SD_BUFIND_STC_GET(x)         ((x&SD_BUFIND_STC_MASK)>>SD_BUFIND_STC_SHIFT)
+
+#define UD_ORDER_DECODE              0x1
+#define UD_ORDER_DISPLAY             0x2
+#define UD_ORDER_DECODEANDDISPLAY    0x3
+
+#define PRINT_UART4(a,b,c,d)
+#define PRINT_UART5(a,b,c,d,e)
+
+#define DISPLAY_ASPECT_RATIO_4_3     0x2
+#define DISPLAY_ASPECT_RATIO_16_9    0x3
+
+
+/////////////////////////////////////////////////
+// PTS capture descriptor flags
+#define PTS_DESCRIPTOR_PTS_LO                          0x00000000
+#define PTS_DESCRIPTOR_DTS_LO                          0x00000004
+#define PTS_DESCRIPTOR_FLAGS                           0x00000008
+#define PTS_DESCRIPTOR_WRAP_COUNT                      0x00000009
+#define PTS_DESCRIPTOR_TIMEBASE_ID                     0x0000000A
+#define PTS_DESCRIPTOR_MATURITY_ADDRESS                0x0000000C
+
+#define PTS_DESCRIPTOR_FLAG_PTS_HI_MASK                0x00000001
+#define PTS_DESCRIPTOR_FLAG_PTS_HI_BIT                 0
+#define PTS_DESCRIPTOR_FLAG_DTS_HI_MASK                0x00000002
+#define PTS_DESCRIPTOR_FLAG_DTS_HI_BIT                 1
+#define PTS_DESCRIPTOR_FLAG_STC_PARITY_MASK            0x00000004
+#define PTS_DESCRIPTOR_FLAG_STC_PARITY_BIT             2
+#define PTS_DESCRIPTOR_FLAG_PENDING_MASK               0x00000008
+#define PTS_DESCRIPTOR_FLAG_PENDING_BIT                3
+#define PTS_DESCRIPTOR_FLAG_PESERROR_MASK              0x00000010
+#define PTS_DESCRIPTOR_FLAG_PESERROR_BIT               4
+
+#define PTS_DESCRIPTOR_FLAG_ADDRESS_WRAP_COUNT_BIT     8
+#define PTS_DESCRIPTOR_FLAG_ADDRESS_WRAP_COUNT_MASK    0x0000FF00
+#define PTS_DESCRIPTOR_FLAG_TIMEBASE_ID_BIT            16
+#define PTS_DESCRIPTOR_FLAG_TIMEBASE_ID_MASK           0x000F0000
+#define PTS_DESCRIPTOR_FLAG_AVC_TAG_BIT                24
+#define PTS_DESCRIPTOR_FLAG_AVC_TAG_MASK               0xFF000000
+
+// PTS debug descriptor extensions
+#define PTS_DESCRIPTOR_DEBUG                           0x00000010
+#define PTS_DESCRIPTOR_DEBUG_PTS_DTS                   0x00000010
+#define PTS_DESCRIPTOR_DEBUG_STC_SNAPSHOT              0x00000014
+#define PTS_DESCRIPTOR_DEBUG_DIFFERENCE                0x00000018
+#define PTS_DESCRIPTOR_DEBUG_FLAGS                     0x0000001C
+
+#define PTS_DESCRIPTOR_DEBUG_FLAG_NO_PTS               0x00000001
+#define PTS_DESCRIPTOR_DEBUG_FLAG_NO_STC               0x00000002
+#define PTS_DESCRIPTOR_DEBUG_FLAG_IS_DTS               0x00000004
+#define PTS_DESCRIPTOR_DEBUG_FLAG_RUNNING              0x00000008
+#define PTS_DESCRIPTOR_DEBUG_FLAG_INSANE               0x00000010
+#define PTS_DESCRIPTOR_DEBUG_FLAG_STC_B                0x00000020
+#define PTS_DESCRIPTOR_DEBUG_FLAG_STC_CURRENT          0x00000040
+#define PTS_DESCRIPTOR_DEBUG_FLAG_TIMEBASE_MISMATCH    0x00000080
+#define PTS_DESCRIPTOR_DEBUG_FLAG_LATE                 0x00000100
+#define PTS_DESCRIPTOR_DEBUG_FLAG_EARLY                0x00000200
+#define PTS_DESCRIPTOR_DEBUG_FLAG_VERY_LATE            0x00000100
+
+/////////////////////////////////////////////////
+// Tag descriptor defines
+// Flag definitions
+#define TAGLIST_SEI_PIC_STRUCT_FLAG_MASK       0x1
+#define TAGLIST_SEI_PIC_STRUCT_FLAG_SHIFT      0
+#define TAGLIST_SEI_FRAME_FREEZE_FLAG_MASK     0x2
+#define TAGLIST_SEI_FRAME_FREEZE_FLAG_SHIFT    1
+#define TAGLIST_SEI_FRAME_RELEASE_FLAG_MASK    0x4
+#define TAGLIST_SEI_FRAME_RELEASE_FLAG_SHIFT   2
+#define TAGLIST_SEI_SKIP_FLAG_MASK             0x8
+#define TAGLIST_SEI_SKIP_FLAG_SHIFT            3
+
+//////////////////////////////////////////////////////////////
+// Frame status ~ TEMP
+#define  FRAME_INUSE_BYIPP           0x1
+#define  FRAME_FREE                  0x0
+
+//////////////////////////////////////////////////////////////
+// Scan format ~ TEMP
+#define SCAN_FORMAT_INTERLACED      0x0
+#define SCAN_FORMAT_PROGRESSIVE     0x1
+#define SCAN_FORMAT_VALID_GET(r)    (r&0x1)
+#define SCAN_FORMAT_GET(r)          ((r&0x2)>>1)
+#define SCAN_FORMAT_VALID_SET(r)    ((r&0x1)<<0)
+#define SCAN_FORMAT_SET(r)          ((r&0x1)<<1)
+
+//////////////////////////////////////////////////////////////
+// Internal System Control Defines
+
+#define NO_INTERNAL_CONTROL          0xFF
+#define SFD_INTERNAL_CONTROL         0x1
+#define AUTORECOVER_INTERNAL_CONTROL 0x2
+
+//////////////////////////////////////////////////////////////
+// SVC specific defines
+#define MEDIAIP_MAX_SVC_DID          0x3
+#define MEDIAIP_MAX_SVC_STR_BUFFERS  0x3
+
+//////////////////////////////////////////////////////////////
+// Malone specific defines
+#define MEDIAIP_MAX_NUM_MALONES         0x2
+#define MEDIAIP_MAX_NUM_MALONE_IRQ_PINS 0x2
+
+#define MEDIAIP_MAX_NUM_FSLCACHES     0x4
+
+//////////////////////////////////////////////////////////////
+// Windsor specific defines
+#define MEDIAIP_MAX_NUM_WINDSORS         0x1
+#define MEDIAIP_MAX_NUM_WINDSOR_IRQ_PINS 0x2
+
+//////////////////////////////////////////////////////////////
+// Subsystem specific defines
+#define MEDIAIP_MAX_NUM_IRQ_PINS        0x10
+#define MEDIAIP_MAX_NUM_CMD_IRQ_PINS    0x2
+#define MEDIAIP_MAX_NUM_MSG_IRQ_PINS    0x1
+#define MEDIAIP_MAX_NUM_TIMER_IRQ_PINS  0x4
+#define MEDIAIP_MAX_NUM_TIMER_IRQ_SLOTS 0x4
+
+#define SUBSYSTEM_CFG_MAGIC_COOKIE      0xB0B1B2B3
+
+//////////////////////////////////////////////////////////////
+// Max supported picture resolution, except H.264 and JPEG
+
+#define MEDIAIP_MAX_PIC_WIDTH  2048
+#define MEDIAIP_MAX_PIC_HEIGHT 2048
+
+//////////////////////////////////////////////////////////////
+// Encoder user data programming vals
+
+#define MEDIAIP_ENC_USER_DATA_WORDS        16
+#define MEDIAIP_ENC_USER_DATA_BYTES        ( MEDIAIP_ENC_USER_DATA_WORDS << 2 )
+
+
+
+#endif /* _MEDIAIP_FW_DEFINES_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_types.h b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_types.h
new file mode 100755
index 0000000..98ff577
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/mediaip_fw_types.h
@@ -0,0 +1,1991 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        mediaip_fw_types.h
+  Description:     Contains structure definitions common
+                   to multiple modules / layers
+  Author:          Media IP FW team - Belfast / Shanghai
+
+ ****************************************************/
+
+#ifndef _MEDIAIP_FW_TYPES_H_
+#define _MEDIAIP_FW_TYPES_H_
+
+#include "basetype.h"
+#include "mediaip_fw_defines.h"
+
+//////////////////////////////////////////////////////////////
+// Generic Stream format
+
+typedef enum
+{
+  MEDIA_IP_FMT_NULL        = 0x0,
+  MEDIA_IP_FMT_AVC         = 0x1,
+  MEDIA_IP_FMT_VC1         = 0x2,
+  MEDIA_IP_FMT_MP2         = 0x3,
+  MEDIA_IP_FMT_AVS         = 0x4,
+  MEDIA_IP_FMT_ASP         = 0x5,
+  MEDIA_IP_FMT_JPG         = 0x6,
+  MEDIA_IP_FMT_RV          = 0x7,
+  MEDIA_IP_FMT_VP6         = 0x8,
+  MEDIA_IP_FMT_SPK         = 0x9,
+  MEDIA_IP_FMT_VP8         = 0xA,
+  MEDIA_IP_FMT_MVC         = 0xB,
+  MEDIA_IP_FMT_VP3         = 0xC,
+  MEDIA_IP_FMT_HEVC        = 0xD,
+  MEDIA_IP_FMT_AUTO_DETECT = 0xAD00,
+  MEDIA_IP_FMT_ALL         = (int)0xAAAAAAAA,
+  MEDIA_IP_FMT_UNSUPPORTED = (int)0xFFFFFFFF,
+  MEDIA_IP_FMT_LAST = MEDIA_IP_FMT_UNSUPPORTED
+
+} MEDIA_IP_FORMAT;
+
+//////////////////////////////////////////////////////////////
+// Generic picture Structure
+
+typedef enum
+{
+  MEDIAIP_TOP_FIELD,
+  MEDIAIP_BOT_FIELD,
+  MEDIAIP_TWO_FIELDS,
+  MEDIAIP_FRAME_PICTURE
+
+} MEDIAIP_PIC_STRUCT;
+
+//////////////////////////////////////////////////////////////
+// Generic picture type
+
+typedef enum
+{
+  MEDIAIP_I_PICTYPE = 1,
+  MEDIAIP_P_PICTYPE,
+  MEDIAIP_B_PICTYPE,
+  MEDIAIP_UNDEF_PICTYPE
+
+} MEDIAIP_PIC_TYPE;
+
+//////////////////////////////////////////////////////////////
+// Stream Layer
+
+typedef enum
+{
+  MEDIAIP_BASE_LAYER = 0,
+  MEDIAIP_ENHANCEMENT_LAYER
+
+} MEDIAIP_LAYER;
+
+//////////////////////////////////////////////////////////////
+// Display module - sync state
+
+typedef enum
+{
+  DISP_SYNC_UNINITIALISED = 0,
+  DISP_SYNC_ACQUIRING,
+  DISP_SYNC_ACQUIRED,
+  DISP_SYNC_LOST,
+  DISP_SYNC_LOST_INVALID,
+  DISP_SYNC_LOST_INSANE
+
+} MEDIAIP_DISP_SYNC_STATE;
+
+//////////////////////////////////////////////////////////////
+// PES HW state
+
+typedef enum
+{
+  PES_STATE_NORMAL = 0,
+  PES_STATE_PTS_BACKTOBACK,
+  PES_STATE_PTS_WITH_SLICE,
+  PES_STATE_PTS_WITH_PIC
+
+} MEDIAIP_PES_STATE;
+
+//////////////////////////////////////////////////////////////
+// Playback mode
+
+typedef enum
+{
+  MEDIAIP_PLAYMODE_CONNECTIVITY = 0,
+  MEDIAIP_PLAYMODE_BROADCAST,
+  MEDIAIP_PLAYMODE_BROADCAST_DSS,
+  MEDIAIP_PLAYMODE_LAST = MEDIAIP_PLAYMODE_BROADCAST_DSS
+
+} MEDIA_IP_PLAYMODE;
+
+//////////////////////////////////////////////////////////////
+// System mode
+
+typedef enum
+{
+  MEDIAIP_SYSMODE_DTV = 0,
+  MEDIAIP_SYSMODE_STB,
+  MEDIAIP_SYSMODE_LAST = MEDIAIP_SYSMODE_STB
+
+} MEDIA_IP_SYSMODE;
+
+//////////////////////////////////////////////////////////////
+// Encoder Output Info
+typedef struct
+{
+  u_int32    uStrIndex;
+  BOOL       bLastFrame;
+  BOOL       bEndOfGOP;
+  u_int32    uEsStruct;
+  u_int32    uMsbPTS;
+  u_int32    uPTS;
+  u_int32    uVesSize;
+  u_int32    uCbFrmStartAddr;
+
+} MEDIAIP_ENCODER_OUTPUT_INFO;
+
+//////////////////////////////////////////////////////////////
+// YUV Output Info
+
+#ifndef HOST_BUILD
+#ifndef _MSC_VER
+typedef enum
+{
+  YUV420 = 0x0,
+  YUV422,
+  YUV400
+
+} MEDIAIP_FW_FRAME_FMT;
+#endif // _MSC_VER
+#endif
+
+//////////////////////////////////////////////////////////////
+// Frame Display info
+
+typedef struct
+{
+  u_int32 top_field_first;
+  u_int32 repeat_first_field;
+  u_int32 disp_vert_res;
+  u_int32 disp_horiz_res;
+  u_int32 centre_vert_offset;
+  u_int32 centre_horiz_offset;
+
+} MEDIAIP_PIC_DISP_INFO;
+
+//////////////////////////////////////////////////////////////
+// Frame info
+
+typedef struct
+{
+  MEDIAIP_PIC_TYPE pic_type;
+  u_int32          pic_struct;
+  u_int32          pic_st_addr;
+  u_int32          last_pic_npf;
+  u_int32          user_data_avail;
+  u_int32          frame_store_id;
+  u_int32          uPercentInErr;
+  u_int32          view_id;         /* H264 MVC */
+  u_int32          uVOIdx;          /* H264 MVC */
+#if MVC_SUPPORT == MVC_ENABLED
+  u_int32          uViewId;
+#endif
+  u_int32          uSkipInProg;
+
+} MEDIAIP_PIC_INFO;
+
+//////////////////////////////////////////////////////////////
+// Memory request type enum
+
+typedef enum
+{
+  MEDIAIP_FRAME_REQ = 0,
+  MEDIAIP_MBI_REQ,
+  MEDIAIP_DCP_REQ,
+  MEDIAIP_REQ_LAST = MEDIAIP_DCP_REQ
+
+} MEDIAIP_MEM_REQ;
+
+//////////////////////////////////////////////////////////////
+// Memory request ctrl
+
+typedef struct
+{
+  u_int32          uLayerIdx;
+  MEDIAIP_MEM_REQ  eType;
+
+} MEDIAIP_MEM_REQ_CTRL, *pMEDIAIP_MEM_REQ_CTRL;
+
+//////////////////////////////////////////////////////////////
+// Memory release ctrl
+
+typedef struct
+{
+  u_int32          uLayerIdx;
+  u_int32          uFSIdx;
+  MEDIAIP_MEM_REQ  eType;
+
+} MEDIAIP_MEM_REL_CTRL, *pMEDIAIP_MEM_REL_CTRL;
+
+////////////////////////////////////////////////////////
+// Media IP mem alloc struct
+
+typedef struct
+{
+  MEDIAIP_MEM_REQ  eType;
+  u_int32          uLayerIdx;
+
+  u_int32          uFSHandle;
+  u_int32          uBaseAddr;
+  u_int32          uStride;
+  u_int32          uChromaOffset;
+
+} MEDIAIP_MEM_ALLOC_CTRL, *pMEDIAIP_MEM_ALLOC_CTRL;
+
+//////////////////////////////////////////////////////////////
+// Decoder metrics info
+
+typedef struct
+{
+  u_int32 uDpbmcCrc;
+  u_int32 uFrameActiveCount;
+  u_int32 uSliceActiveCount;
+  u_int32 uRbspBytesCount;
+  u_int32 uSibWaitCount;
+  u_int32 uDpbReadCount;
+  u_int32 uMprWaitCount;
+  u_int32 uBBBCrc;
+  u_int32 uAccQP;
+  u_int32 uCacheStat;
+  u_int32 uCRCSkip;
+  u_int32 uCRCDrop;
+  BOOL    bCRCValid;
+
+  u_int32 uBaseDpbMcCrc;
+  u_int32 uByteStreamCrc;
+
+  u_int32 uCRC0;
+  u_int32 uCRC1;
+  u_int32 uCRC2;
+  u_int32 uCRC3;
+  u_int32 uCRC4;
+  u_int32 uCRC5;
+  u_int32 uCRC6;
+  u_int32 uCRC7;
+  u_int32 uCRC8;
+  u_int32 uCRC9;
+  u_int32 uCRC10;
+  u_int32 uCRC11;
+  u_int32 uCRC12;
+  u_int32 uCRC13;
+  u_int32 uCRC14;
+
+  u_int32 mbq_full;
+  u_int32 mbq_empty;
+  u_int32 slice_cnt;
+  u_int32 mb_count;
+
+  u_int32 uTotalTime_us;
+  u_int32 uTotalFwTime_us;
+
+  u_int32 uSTCAtFrameDone;
+
+  u_int32 uProcIaccTotRdCnt;
+  u_int32 uProcDaccTotRdCnt;
+  u_int32 uProcDaccTotWrCnt;
+  u_int32 uProcDaccRegRdCnt;
+  u_int32 uProcDaccRegWrCnt;
+  u_int32 uProcDaccRngRdCnt;
+  u_int32 uProcDaccRngWrCnt;
+
+} MEDIAIP_DEC_METRICS_INFO, *pMEDIAIP_DEC_METRICS_INFO;
+
+//////////////////////////////////////////////////////////////
+// GOP info
+
+typedef struct
+{
+  u_int32 closed_gop;
+  u_int32 broken_link;
+
+} MEDIAIP_GOP_INFO;
+
+//////////////////////////////////////////////////////////////
+// Stream frequency
+
+typedef enum
+{
+  MEDIAIP_FR_UNKNOWN  = 0,
+  MEDIAIP_FR_23_97_HZ = 1,
+  MEDIAIP_FR_24_HZ    = 2,
+  MEDIAIP_FR_25_HZ    = 3,
+  MEDIAIP_FR_29_97_HZ = 4,
+  MEDIAIP_FR_30_HZ    = 5,
+  MEDIAIP_FR_50_HZ    = 6,
+  MEDIAIP_FR_59_94_HZ = 7,
+  MEDIAIP_FR_60_HZ    = 8,
+  MEDIAIP_FR_7P992_HZ = 9,
+  MEDIAIP_FR_8_HZ     = 10,
+  MEDIAIP_FR_8P33_HZ  = 11,
+  MEDIAIP_FR_9P99_HZ  = 12,
+  MEDIAIP_FR_10_HZ    = 13,
+  MEDIAIP_FR_11P988_HZ= 14,
+  MEDIAIP_FR_12_HZ    = 15,
+  MEDIAIP_FR_12P5_HZ  = 16,
+  MEDIAIP_FR_14P985_HZ= 17,
+  MEDIAIP_FR_15_HZ    = 18
+
+} MEDIAIP_OUTPUT_FREQ;
+
+//////////////////////////////////////////////////////////////
+// Scan info
+
+typedef enum
+{
+  MEDIAIP_PROGRESSIVE,
+  MEDIAIP_INTERLACE
+
+} MEDIAIP_SCAN_INFO;
+
+//////////////////////////////////////////////////////////////
+// Pipeline type enumeration
+
+typedef enum
+{
+  MEDIAIP_VIDEO_DECODE_PIPELINE = 0x0,
+  MEDIAIP_VIDEO_ENCODE_PIPELINE,
+  MEDIAIP_VIDEO_TRANSCODE_PIPELINE,
+  MEDIAIP_VIDEO_TRANSDISP_PIPELINE,
+  MEDIAIP_VIDEO_NULL_PIPELINE
+
+} MEDIAIP_VIDEO_PIPELINE_TYPE;
+
+//////////////////////////////////////////////////////////////
+// Decode info
+
+/* TODO-KMC */
+/* Why do these structures break the protocol in case used for naming ? */
+
+typedef enum
+{
+   MediaIPFW_DEC_CodingTypeI = 1,
+   MediaIPFW_DEC_CodingTypeP,
+   MediaIPFW_DEC_CodingTypeAny,
+   MediaIPFW_DEC_CodingTypeIP,
+   MediaIPFW_DEC_CodingTypeSkip,
+   MediaIPFW_DEC_CodingTypeLast
+
+} MediaIPFW_DEC_CodingType;
+
+//////////////////////////////////////////////////////////////
+// Decode Command Mode
+
+typedef enum
+{
+  MediaIPFW_DEC_ModeSplit = 0,
+  MediaIPFW_DEC_ModeNoSplit
+
+} MediaIPFW_DEC_Mode;
+
+//////////////////////////////////////////////////////////////
+// Tag structures
+
+typedef enum
+{
+  TAG_FREE = 0,
+  TAG_IN_USE
+
+} TAG_STATUS;
+
+typedef struct
+{
+
+  u_int32 pts;             //  TSP aspect of the structure
+  u_int32 dts;
+  u_int32 pts_flags;
+#ifdef PES_INPUT_ENABLE
+#else
+  u_int32 maturity_address;
+#endif
+  u_int32 scode_loc;      // Possibly this variable could be combined with maturity_address
+                          // They are the same thing, but come from very different places
+  BOOL    bValid;
+
+} DEMUX_INFO, *pDEMUX_INFO;
+
+// This struct is AVC specific - needs to be generic or at least cast as generic
+typedef struct
+{
+
+  u_int32 sei_flags;        // Display aspect
+  u_int32 sei_pic_struct;
+
+} DISP_INFO, *pDISP_INFO;
+
+typedef struct
+{
+  u_int32 fs_idc;
+  u_int32 uUseFrameCRC;
+  u_int32 uBotFirst;
+  u_int32 uTopData[2];
+  u_int32 uBotData[2];
+  u_int32 uReported;
+
+  u_int32 uDpbmcCRC;    // Internal MC interface CRC
+  u_int32 uBsCRC;       // Byte Stream CRC
+
+  u_int32 uDPBLevel;   // DPB Level at frame start
+
+  u_int16 fs_is_used;
+  u_int16 Monochrome;
+
+  u_int32 control;
+
+} CRC_INFO, *pCRC_INFO;
+
+typedef struct
+{
+  u_int32 frame_size_inmbs;   // {Size[15:0],Height[7:0],Width[7:0]}
+  u_int32 bs_ib_empty;
+  u_int32 frm_dec_active;
+  u_int32 slc_dec_active;
+  u_int32 stc_at_decode;
+  u_int32 stc_at_display;
+  u_int32 num_slc_overlapped;
+  u_int32 num_mb_overlapped;
+  u_int32 luma_address;
+  u_int32 cpb_min_level;
+  u_int32 rbsp_byte_count;
+  u_int32 dpb_read_count;
+  u_int32 mpr_wait_count;
+  u_int32 slice_count;
+  u_int16 drm_pull_count;
+  u_int16 drm_pap_pts_cnt;
+  u_int16 drm_pap_skip_cnt;
+  u_int16 drm_pap_dang_cnt;
+
+} PERF_INFO, *pPERF_INFO;
+
+typedef struct
+{
+  u_int32 uNumSlices;
+  u_int32 uSumQP;
+
+}QMETER_INFO, *pQMETER_INFO;
+
+typedef struct
+{
+
+  DEMUX_INFO  TspInfo;
+  DISP_INFO   DispInfo;
+  CRC_INFO    CRCInfo;
+  TAG_STATUS  Status;          // General info on the structure - free or taken...
+  QMETER_INFO QMeterInfo;
+  u_int32     uPercentMBInErr;
+#ifdef PERF_DEBUG
+  PERF_INFO   PerfInfo;
+#endif
+
+} TAG, *pTAG;
+
+typedef struct
+{
+
+  u_int32 uLastTSP;
+  u_int32 uLastNonTSP;
+  u_int32 uInUse;
+
+} TAG_CTRL, *pTAG_CTRL;
+
+
+// Film Grain technology support
+typedef struct
+{
+  BOOL    bFGS_Flag;
+  u_int32 log2_scale_factor;
+  u_int32 pic_order_count;
+  u_int32 pic_order_offset;
+  u_int16 fgs_lut[3][256];
+
+}USERDATA_FILMGRAIN_CONTROL;
+
+#define DIAG_ARRAY_SIZE 26
+
+typedef struct
+{
+
+  int32    nAvcDiagState;
+  int32    nTSPDiagState;
+  u_int32  uFailurePt;
+  u_int32  uFailData[4];
+  int32    nLastCall;
+  int32    nDecodeBegan;
+  int32    nEngStart;
+  u_int32  uLastStart;
+  int32    DPBCount;
+  int32    DPBAnomaly;
+  int32    DPBAnomalyCnt;
+  int32    nEntryIndex;
+  int32    nEntryArray[DIAG_ARRAY_SIZE];
+  int32    nExitIndex;
+  int32    nExitArray[DIAG_ARRAY_SIZE];
+
+} DiagInfo, *pDiagInfo;
+
+
+////////////////////////////////////////////////////////
+// Frame store structure -
+// Common to multiple modules will hold all information
+// which needs to be transferred between any two modules
+// in relation to a picture buffer
+
+typedef struct mediaip_fw_frame_store
+{
+  struct mediaip_fw_frame_store * pNext;     // Not entirely sure I need this - we will see as the architecture evolves...
+
+  /* Frame store description */
+  u_int32 uBaseAddr;                         // Base Address - Luma base for a image store, address for MBI or BLI
+  u_int32 uChromaOffset;
+  u_int32 uPitch;
+  u_int32 uDimsMBs;
+
+  // Module usage
+  u_int32 uModUsage;                         // 1 bit set for each module that considers this frame store to be in use by it
+                                             // For a real time display / transcode situation this could be more than 2
+
+  // Last Frame flag
+  BOOL bLastFrame;                           // Flag to indicate whether this is the last frame store decoded by the decoder.
+                                             // Important when stopping a transcode pipeline or reaching the last frame of a bitstream
+                                             // so that we can tell the encoder not to expect any more frames and hence empty it's
+                                             // pipeline.
+
+  // Display params
+  u_int32 uDispData;                         // Bottom field first etc - normally to be filled in by decode module
+
+  // Frame store
+  u_int32 uFSID;                             // An ID used to cross reference with a local structure - filled in by the capture unit, decoder or
+                                             // image capture unit, etc
+
+  pTAG    pFSTag;                            // A pointer to a tag for the frame store - normally allocated by the decoder so that unit should
+                                             // set the pointer
+
+  USERDATA_FILMGRAIN_CONTROL ud_filmgrain;   // Filmgrain support structure
+
+  // Want to give anything that may be managed by the resource layer a generic resource tag!
+  // Until I can be bothered working out how to do this I will go with the 3 below...
+
+  u_int8  uDynBuffType;                      // What is the buffer type of the currently allocayted frame store
+                                             // Could be worked out from uFSInternBufNum - Remember if we have to
+                                             // hold a frames over a channel change not all uDynBuffType members
+                                             // will be the same in each stream's group of frame stores
+
+  u_int8  uFSInternBufStart;
+  u_int8  uFSInternBufNum;
+
+} MEDIAIP_FW_FRAME_STORE;
+
+typedef MEDIAIP_FW_FRAME_STORE  MEDIAIP_FW_ENCODER_REF_FRAME_STORE;
+typedef MEDIAIP_FW_FRAME_STORE  MEDIAIP_FW_ENCODER_FRAME_ACT_STORE;
+
+
+////////////////////////////////////////////////////////
+// MetaData store structure -
+// Defines an area which may be passed to a base module for its own internal use
+
+typedef struct
+{
+  u_int32 uMetadataBase;
+  u_int32 uMetadataSize;
+
+} MEDIAIP_FW_METADATA_STORE, *pMEDIAIP_FW_METADATA_STORE;
+
+////////////////////////////////////////////////////////
+// Stream Frequency enumeration -
+
+
+typedef enum {
+
+                STREAM_FR_UNKNOWN  = 0,
+                STREAM_FR_23_97_HZ = 1,
+                STREAM_FR_24_HZ    = 2,
+                STREAM_FR_25_HZ    = 3,
+                STREAM_FR_29_97_HZ = 4,
+                STREAM_FR_30_HZ    = 5,
+                STREAM_FR_50_HZ    = 6,
+                STREAM_FR_59_94_HZ = 7,
+                STREAM_FR_60_HZ    = 8
+
+             } STREAM_SCAN_FREQ;
+
+////////////////////////////////////////////////////////
+// Digital Encode Mode ( at the tv encoder)
+
+typedef enum {
+                MODE_240p        = 0x0,
+                MODE_240i        = 0x1,
+                MODE_480p        = 0x2,
+                MODE_NTSC        = 0x3,
+                MODE_PALp        = 0x4,
+                MODE_PAL         = 0x5,
+                MODE_720p        = 0x6,
+                MODE_720p_50Hz   = 0x7,
+                MODE_720i        = 0x8,
+                MODE_720i_25Hz   = 0x9,
+                MODE_720i_50Hz   = 0xa,
+                MODE_720i_60Hz   = 0xb,
+                MODE_1080p       = 0xc,
+                MODE_1080p_25Hz  = 0xd,
+                MODE_1080i       = 0xe,
+                MODE_1080i_25Hz  = 0xf,
+                MODE_2Kp         = 0x10,
+                MODE_1080p_24Hz  = 0x11,
+                MODE_UNKNOWN     = 0xff
+
+             } TV_ENC_MODE;
+
+////////////////////////////////////////////////////////
+// Stream Display parameters
+
+typedef struct
+{
+  u_int32              uTargetLevel;
+  u_int32              uHorDecodeRes;
+  u_int32              uVerDecodeRes;
+  u_int32              uHorDispRes;
+  u_int32              uVerDispRes;
+  u_int32              uDispWidthMBs;
+  u_int32              uDispHeightMBs;
+  u_int32              uBufWidthMBs;
+  u_int32              uBufHeightMBs;
+  u_int32              uAspectRatio;
+  u_int32              uSizeMBs;
+  u_int32              uYUVFmt;
+  u_int32              uScanFormat;
+  STREAM_SCAN_FREQ     sFreq;
+  u_int32              uNumRefFrms;
+  u_int32              uNumDPBFrms;
+  u_int32              uNumDFEAreas;
+  u_int32              uProfLevelIDC;
+  MEDIAIP_OUTPUT_FREQ  eOutputFreq;
+  MEDIAIP_SCAN_INFO    eScanInfo;
+  u_int32              uAR;
+  u_int32              uColorDesc;
+  u_int32              uBitDepthLuma;
+  u_int32              uBitDepthChroma;
+  u_int32              uNumViews;
+  u_int32              uViewList;
+
+} MEDIAIP_FW_STREAM_DISPLAY_PARAMS;
+
+
+////////////////////////////////////////////////////////
+// Frame decoded parameters
+
+typedef struct
+{
+  BOOL                 bTopFieldFirst;
+  BOOL                 bRepeatFirstField;
+  MEDIAIP_PIC_TYPE     ePicType;
+  MEDIAIP_PIC_STRUCT   ePicStruct;
+
+  u_int32              uFSHandle;
+
+  u_int32              uPicStartAddr;
+  u_int32              uPercentMBsInErr;
+
+  u_int32              uPTSLo;
+  u_int32              uPTSHi;
+  BOOL                 bPTSValid;
+
+  BOOL                 bQMeterValid;
+  u_int32              uQMeter;
+  BOOL                 bGopBitRateAvail;
+  u_int32              uGopBitRate;
+
+  u_int32              bTemporalRef;
+
+  u_int32              uBbdHorActive;
+  u_int32              uBbdVerActive;
+  u_int32              uBbdLogoActive;
+  u_int32              uBbdBotPrev;
+  u_int32              uBbdMinColPrj;
+  u_int32              uBbdMinRowPrj;
+
+  u_int32              uFSBaseAddr;
+  BOOL                 bDangling;
+  BOOL                 bTopFieldPresent;
+
+  /* Only for RealVideo RPR */
+  u_int32              uRprPicWidth;
+  u_int32              uRprPicHeight;
+
+  /* Only for DivX3         */
+  u_int32              uFrameRate;
+
+  /* For decode time yuv gathering */
+  u_int32              ulTopLumBaseAddr;
+  u_int32              ulTopChrBaseAddr;
+  u_int32              ulBotLumBaseAddr;
+  u_int32              ulBotChrBaseAddr;
+
+  u_int32              ulStride;
+
+  void *               pAltView;
+  u_int32              uMVCTargetViewIdx;
+} MEDIAIP_FW_FRAME_DEC_PARAMS , *pMEDIAIP_FW_FRAME_DEC_PARAMS;
+
+////////////////////////////////////////////////////////
+// SVC Seq parameters
+
+typedef struct
+{
+  u_int32                          uNumValidLayers;
+  MEDIAIP_FW_STREAM_DISPLAY_PARAMS tLayerParams[MEDIAIP_MAX_SVC_DID];
+
+} MEDIAIP_FW_SVC_STREAM_PARAMS;
+
+//////////////////////////////////////////////////////////////
+// IRQ Event data
+
+typedef struct
+{
+  void *  pMVDHw;
+  u_int32 uIrqStatus[0x3];
+
+} MEDIAIP_FW_IRQ_DATA, *pMEDIAIP_FW_IRQ_DATA;
+
+
+//////////////////////////////////////////////////////////////
+// CMD Event data
+
+typedef struct
+{
+  u_int32 uCmdData;
+
+}MEDIAIP_FW_CMD_DATA, *pMEDIAIP_FW_CMD_DATA;
+
+//////////////////////////////////////////////////////////////
+// Callback Request Data
+
+typedef struct
+{
+  u_int32 uReason;
+
+}MEDIAIP_FW_CBACK_DATA, *pMEDIAIP_FW_CBACK_DATA;
+
+////////////////////////////////////////////////////////
+// Interface descriptor
+// Generic descriptor type as initially defined by Tempest
+// module
+
+typedef struct
+{
+
+  volatile u_int32 address;
+  volatile u_int32 parameters;
+
+} INTERFACE_DESCRIPTOR_TYPE, *pINTERFACE_DESCRIPTOR_TYPE;
+
+////////////////////////////////////////////////////////
+// Buffer descriptor
+// Generic buffer descriptor as initially defined by Tempest
+// module
+
+typedef struct
+{
+  u_int32 descriptor_number;
+  u_int32 descriptor_size;
+  u_int32 descriptor_ptr;
+
+} BUFFER_TBL_DESCRIPTOR, *BUFFER_TBL_DESCRIPTOR_PTR;
+
+////////////////////////////////////////////////////////
+// Buffer descriptor
+// Generic buffer descriptor as initially defined by Tempest
+// module
+
+typedef struct
+{
+  u_int32 wptr;
+  u_int32 rptr;
+  u_int32 start;
+  u_int32 end;
+
+} BUFFER_DESCRIPTOR_TYPE, *pBUFFER_DESCRIPTOR_TYPE;
+
+////////////////////////////////////////////////////////
+// Stream Buffer descriptor
+// Specific buffer descriptor for stream data
+
+typedef struct
+{
+  volatile u_int32 wptr;
+  volatile u_int32 rptr;
+  volatile u_int32 start;
+  volatile u_int32 end;
+  volatile u_int32 LWM;
+
+} STREAM_BUFFER_DESCRIPTOR_TYPE, *pSTREAM_BUFFER_DESCRIPTOR_TYPE;
+
+#ifdef TCODE_API_TEST
+// Defined specific for PCI ,for its access unit is 64 bits
+typedef struct
+{
+  volatile u_int32 wptr;
+  volatile u_int32 wptr_res;
+  volatile u_int32 rptr;
+  volatile u_int32 rptr_res;
+  volatile u_int32 start;
+  volatile u_int32 end;
+
+} BUF_DES_PCI_SHARE_TYPE, BUF_DES_PCI_SHARE_TYPE_PTR;
+
+#endif
+////////////////////////////////////////////////////////
+// Stream Buffer descriptor
+// Buffer descriptor as used by the encoder
+// module
+
+typedef struct
+{
+
+  u_int32 stream_index;
+  u_int32 stream_buffer_size;
+  u_int32 stream_buffer_base;
+
+} STREAM_BUFFER_DESCRIPTOR, *STREAM_BUFFER_DESCRIPTOR_PTR;
+
+typedef STREAM_BUFFER_DESCRIPTOR MEDIAIP_FW_ENCODER_STREAM_BUFFER_DESC;
+
+////////////////////////////////////////////////////////
+// PTS debug descriptor
+// This descriptor is as initially defined by Tempest
+// module
+
+typedef struct
+{
+  volatile u_int32 pts_lo;
+  volatile u_int32 stc_lo;
+  volatile   int32 error;
+  volatile u_int32 flags;
+
+} PTS_DEBUG_DESCRIPTOR_TYPE, *pPTS_DEBUG_DESCRIPTOR_TYPE;
+
+////////////////////////////////////////////////////////
+// PTS descriptor
+// This descriptor is as initially defined by Tempest
+// module
+
+typedef struct
+{
+  volatile u_int32 pts_lo;
+  volatile u_int32 dts_lo;
+  volatile   int32 flags;
+  volatile u_int32 maturity_addr;
+
+} PTS_DESCRIPTOR_TYPE, *pPTS_DESCRIPTOR_TYPE;
+
+//////////////////////////////////////////////////////////////
+// Video Stream Status structure
+//
+// Note : I am putting this in the communal include file because we may wish to let
+// module base FW update such a structure directly as opposed to sending messages
+// back to the public FW level...
+// We may also wish to lump all module's status into this one structure
+
+// Why are these volatiles? Should consider removing their volatility!!...
+typedef struct
+{
+  //////////////////////
+  // Pipeline variables
+  volatile u_int32 run;
+  volatile u_int32 pause;
+
+  //////////////////////
+  // Decoder variables
+  volatile u_int32 mpeg_format;
+  volatile u_int32 DSS;
+  volatile u_int32 native_sd;
+  volatile u_int32 stop;
+  volatile u_int32 stop_pending;
+  volatile u_int32 stream_terminate_type;
+  volatile u_int32 ES;
+  volatile u_int32 PAL;
+  volatile u_int32 CRC;
+  volatile u_int32 update_offset;
+  volatile u_int32 pcr_sent;
+  volatile u_int32 PVRMode;
+  volatile u_int32 malone_mp2_dbdrng_en;
+  volatile u_int32 uWaitFlush;
+
+  volatile u_int32 pvr_type;    /* These are new - need to be fixed */
+  volatile u_int32 valid_frame_mask;
+
+  //////////////////////
+  // Display variables
+  volatile u_int32 force_interlace;
+  volatile u_int32 sync_stc;
+  volatile int32   nTrinityDisc;
+  volatile u_int32 uTrinityDiscPCRLo;
+  volatile u_int32 display_mode_status;
+  volatile u_int32 sync;
+
+} MEDIAIP_FW_STREAM_STATUS, *MEDIAIP_FW_STREAM_STATUS_PTR;
+
+//////////////////////////////////////////////////////////////
+// Stream Descriptor Structure
+//
+// Currently this is basically the stream descriptor structure
+// from the decoder FW interface with the host SW
+// This needs to evolve to suit our needs better
+#if ( TARGET_PLATFORM == GENTB_PLATFORM )
+
+typedef struct
+{
+  volatile u_int32 Control;
+  volatile u_int32 Buffer_Indices;
+  volatile u_int32 Message_Filter;
+  volatile u_int32 Extended_Message_Filter;
+  volatile u_int32 Tempest_Command_Filter;
+  volatile u_int32 Status;
+  volatile u_int32 Bitstream_Error;
+  volatile u_int32 Skip_Count;
+  volatile u_int32 Repeat_Count;
+  volatile u_int32 Frame_Count;
+  volatile u_int32 Bitstream_Timeout;
+  volatile u_int32 Max_Frame_Dpb_Size;                     // For dynamic frame allocation this actually means the start of the allocated memory
+  volatile u_int32 Decode_Buffer_Count;                    // For dynamic frame allocation this actually means the size of allocated memory
+  volatile u_int32 Buffer_Pitch;                           // For dynamic frame allocation this actually means the memory controller tile width
+  volatile INTERFACE_DESCRIPTOR_TYPE DPB_Base_Address_dec; // For dynamic frame allocation this actually means the MB info address
+  volatile u_int32 PTS_DTS_Offset;
+  volatile u_int32 Internal_PTS_Delay;
+  volatile u_int32 Sync_Window_Start;
+  volatile u_int32 Sync_Window_End;
+  volatile u_int32 Sync_Sanity_Limit;
+  volatile u_int32 trick_speed;
+  INTERFACE_DESCRIPTOR_TYPE user_data_desc;
+
+  INTERFACE_DESCRIPTOR_TYPE  FrameStoreDesc;
+  INTERFACE_DESCRIPTOR_TYPE  frame_buffer_control_desc;
+
+  INTERFACE_DESCRIPTOR_TYPE  pvr_command_list_desc;
+  volatile u_int32           Pad[2];
+
+  pPTS_DESCRIPTOR_TYPE       pts_table_desc;
+  pPTS_DEBUG_DESCRIPTOR_TYPE pts_debug_table_desc;
+
+  volatile u_int32           PVR_Control;
+  volatile u_int32           RAI;
+
+  // For PecosB onwards this is the security control word
+  volatile u_int32           security_control;
+  // Status variables for a stream
+  volatile u_int32           sd_changed_control;
+  volatile u_int32           ud_type_mask;
+  MEDIAIP_FW_STREAM_STATUS   stream_status;
+
+#if TARGET_APP == VIDEO_TRANS
+  volatile u_int32 FrameStoreCount;
+  // Second set of image buffers ( only required in a dual MC situation )
+  volatile u_int32 FrameStoreCount2;
+  volatile INTERFACE_DESCRIPTOR_TYPE  FrameStoreDesc2;
+
+  // Encoder Reference buffers
+  volatile u_int32 EncRefCount;
+  volatile INTERFACE_DESCRIPTOR_TYPE  EncRefDesc;
+
+  // Encoder Image Activity buffers
+  volatile u_int32 EncActCount;
+  volatile INTERFACE_DESCRIPTOR_TYPE  EncActDesc;
+
+  // Stream buffer descriptor index - for encoder and decoder
+  volatile u_int32                    uDecStrmBufIdx;          // Current decode FW expects that the buffer used will match the SDIndex
+  volatile u_int32                    uEncOutBufIdx;
+
+  // Only enc, vamux interDesc used at present to pass params
+  volatile INTERFACE_DESCRIPTOR_TYPE  uDecParamSet;
+  volatile INTERFACE_DESCRIPTOR_TYPE  uEncParamSet;
+  volatile INTERFACE_DESCRIPTOR_TYPE  uVamuxParamSet;
+
+  // Hardware Interface to system layer
+  INTERFACE_DESCRIPTOR_TYPE           system_config_desc;
+
+#ifdef TCODE_API_TEST
+  volatile INTERFACE_DESCRIPTOR_TYPE  uBitRateDispSet;
+#endif
+
+  volatile u_int32                    streamdes_id;
+
+#else
+
+#if PLAYMODE == STB
+  volatile u_int32                    streamdes_id;
+#endif
+#endif
+
+} STREAM_DESCRIPTOR, *STREAM_DESCRIPTOR_PTR;
+
+#else
+
+typedef struct
+{
+  volatile u_int32 Control;                   // 0
+  volatile u_int32 Buffer_Indices;
+  volatile u_int32 Message_Filter;
+  volatile u_int32 Extended_Message_Filter;
+  volatile u_int32 Tempest_Command_Filter;
+  volatile u_int32 Status;
+  volatile u_int32 Bitstream_Error;
+  volatile u_int32 Skip_Count;
+  volatile u_int32 Repeat_Count;
+  volatile u_int32 Frame_Count;
+  volatile u_int32 Bitstream_Timeout;
+  volatile u_int32 Max_Frame_Dpb_Size;
+  volatile u_int32 Buffer_Pitch;
+  volatile u_int32 Decode_Buffer_Count;
+  volatile u_int32 PTS_DTS_Offset;
+  volatile u_int32 Internal_PTS_Delay;
+  volatile u_int32 Sync_Window_Start;
+  volatile u_int32 Sync_Window_End;
+  volatile u_int32 Sync_Sanity_Limit;
+  volatile u_int32 trick_speed;                 // 20
+
+  // Image buffers
+  volatile u_int32 FrameStoreCount;
+  volatile INTERFACE_DESCRIPTOR_TYPE  FrameStoreDesc;
+
+  // Second set of image buffers ( only required in a dual MC situation )
+  volatile u_int32 FrameStoreCount2;
+  volatile INTERFACE_DESCRIPTOR_TYPE  FrameStoreDesc2;
+
+  // Encoder Reference buffers
+  volatile u_int32 EncRefCount;
+  volatile INTERFACE_DESCRIPTOR_TYPE  EncRefDesc;
+
+  // Encoder Image Activity buffers
+  volatile u_int32 EncActCount;                       // 30
+  volatile INTERFACE_DESCRIPTOR_TYPE  EncActDesc;
+
+  // Stream buffer descriptor index - for encoder and decoder
+  volatile u_int32                    uDecStrmBufIdx;          // Current decode FW expects that the buffer used will match the SDIndex
+  volatile u_int32                    uEncOutBufIdx;
+
+  // Only enc, vamux interDesc used at present to pass params
+  volatile INTERFACE_DESCRIPTOR_TYPE  uDecParamSet;
+  volatile INTERFACE_DESCRIPTOR_TYPE  uEncParamSet;
+  volatile INTERFACE_DESCRIPTOR_TYPE  uVamuxParamSet;
+
+  INTERFACE_DESCRIPTOR_TYPE           user_data_desc;
+  INTERFACE_DESCRIPTOR_TYPE           frame_buffer_attribute_desc;     // Address of the attribute table used by the display process
+                                                                       // Who fills this in?? Do I give a shite in module architecture?
+  INTERFACE_DESCRIPTOR_TYPE           frame_buffer_control_desc;
+  BUFFER_DESCRIPTOR_TYPE              pvr_command_list_desc;
+  pPTS_DESCRIPTOR_TYPE                pts_table_desc;
+  pPTS_DEBUG_DESCRIPTOR_TYPE          pts_debug_table_desc;
+
+  // Hardware Interface to system layer
+  INTERFACE_DESCRIPTOR_TYPE           system_config_desc;
+
+  // Status variables for a stream
+  volatile u_int32                    sd_changed_control;
+  MEDIAIP_FW_STREAM_STATUS            stream_status;
+
+  volatile u_int32                    RAI;
+
+
+#ifdef DRM_AV_SYNC_DEBUG
+  volatile u_int32 DRMPath_Take_Snapshot;                                // Only used when DRM_AV_SYNC_DEBUG defined but included
+  volatile u_int32 DRMPath_Snapshot_Addr;                                // in all builds to enable more transparent api
+  volatile u_int32 DRMPath_Snapshot_Index;                               // operations
+#endif
+
+#ifdef TCODE_API_TEST
+  volatile INTERFACE_DESCRIPTOR_TYPE  uBitRateDispSet;
+#endif
+
+  volatile u_int32                    streamdes_id;
+
+  /* Following have been removed from official descriptor area
+  INTERFACE_DESCRIPTOR_TYPE  sps_td;
+  INTERFACE_DESCRIPTOR_TYPE  pps_td;
+  INTERFACE_DESCRIPTOR_TYPE  spds_td;
+  */
+
+} STREAM_DESCRIPTOR, *STREAM_DESCRIPTOR_PTR;
+
+#endif
+
+#define  CRC_DEBUG_NUM  1024
+#define  PERF_DEBUG_NUM 2048  // 68secs
+#define  CRC_FRAME      0
+#define  CRC_FIELD_TOP  1
+#define  CRC_FIELD_BOT  3
+
+typedef struct
+{
+
+  u_int32 abort_type;
+  u_int32 mode;
+  u_int32 link_reg;
+  u_int32 stack_pointer;
+
+}ExceptionDesc, pExceptionDesc;
+
+#ifndef VIDEO_SOFTWARE
+/* Structure below needs to be in shared memory header file for SW apps */
+typedef enum
+{
+  MVDDecoderOK = 0x0,
+  MVDDecoderServiceIrq,
+  MVDDecoderCmdPending,
+  MVDDecoderFWLoop,
+  MVDDecoderHWActive,
+  MVDDecoderHWActiveStreamStall,
+  MVDDecoderHWActiveMemStall,
+  MVDDecoderFWHWDeadlock,
+  MVDDecoderFWHWAutoRec,
+  MVDDecoderHWBSDMAIssue,
+  MVDDecoderUnknown,
+  MVDDecoderLast = MVDDecoderUnknown
+
+} MEDIAIP_FW_DECODER_STATUS;
+
+#endif
+
+typedef struct
+
+{
+
+  u_int32 size;               // Size of this structure
+  u_int32 index;              // Current index into array
+  u_int32 loops;              // Number of times we looped
+  u_int32 num_frames;         // Number of frames in a loop
+  u_int32 frame_size_inmbs;   // {Size[15:0],Height[7:0],Width[7:0]}
+
+  u_int32 not_first_time;
+  u_int32 prev_vsync_count;
+  u_int32 worst_frame;
+  u_int32 loop_key;           // Value used to decide when stream has looped
+  u_int32 skip_start;
+
+
+  u_int32 luma_mismatches;    //
+  u_int32 chroma_mismatches;  //
+  u_int32 dpbmc_mismatches;   //
+  u_int32 bs_mismatches;      //
+  u_int32 skip_count;         //
+  u_int32 repeat_count;       //
+  u_int32 loop_lu_crc;        // Merge of CRCs
+  u_int32 loop_ch_crc;        // Merge of CRCs
+
+  // Most recent captured Info
+  u_int32 crc_type[PERF_DEBUG_NUM];
+  u_int32 idr_pic[PERF_DEBUG_NUM];
+  u_int32 poc[PERF_DEBUG_NUM];
+  u_int32 luma_crc[PERF_DEBUG_NUM];
+  u_int32 chroma_crc[PERF_DEBUG_NUM];
+  u_int32 dpbmc_crc[PERF_DEBUG_NUM];          // Only valid for BBV & above
+  u_int32 bs_crc[PERF_DEBUG_NUM];             // Only valid for BBV & above
+
+  // Mismatches & skips
+  u_int32 luma_mismatch[PERF_DEBUG_NUM];
+  u_int32 chroma_mismatch[PERF_DEBUG_NUM];
+  u_int32 dpbmc_mismatch[PERF_DEBUG_NUM];     // Only valid for BBV & above
+  u_int32 bs_mismatch[PERF_DEBUG_NUM];        // Only valid for BBV & above
+
+  u_int32 mismatch_fs_idc[32];
+  u_int32 skip[PERF_DEBUG_NUM];
+  u_int32 repeat[PERF_DEBUG_NUM];
+
+
+  // Performance metrics & the associated CRCs for first loop
+  u_int32 crc_type_l0[PERF_DEBUG_NUM];
+  u_int32 idr_pic_l0[PERF_DEBUG_NUM];
+  u_int32 poc_l0[PERF_DEBUG_NUM];
+  u_int32 luma_crc_l0[PERF_DEBUG_NUM];
+  u_int32 chroma_crc_l0[PERF_DEBUG_NUM];
+  u_int32 dpbmc_crc_l0[PERF_DEBUG_NUM];       // Only valid for BBV & above
+  u_int32 bs_crc_l0[PERF_DEBUG_NUM];          // Only valid for BBV & above
+
+  // Max of metrics
+  u_int32 max_slc_dec_active;
+  u_int32 max_dpb_read_count;
+  u_int32 max_mpr_wait_count;
+  u_int32 max_rbsp_byte_count;
+  u_int32 max_bs_ib_empty;
+  u_int32 max_slice_count;
+  u_int32 max_mb_overlapped;
+  u_int32 min_stc_diff;
+  u_int32 max_frm_dec_active;
+  u_int32 max_frm_dec_active_2;
+  u_int32 max_frm_dec_active_4;
+  u_int32 max_frm_dec_active_8;
+
+  // Max of metrics assiciated with worst frame
+  u_int32 mfda_bs_ib_empty;
+  u_int32 mfda_mpr_wait_count;
+  u_int32 mfda_dpb_read_count;
+  u_int32 mfda_rbsp_byte_count;
+  u_int32 mfda_slice_count;
+  u_int32 mfda_slc_dec_active;
+  u_int32 mfda_mb_overlapped;
+
+  // Will effectively be averages
+  u_int32 Av_frm_dec_active;
+  u_int32 Av_slc_dec_active;
+  u_int32 Av_mpr_wait_count;
+  u_int32 Av_dpb_read_count;
+  u_int32 Av_rbsp_byte_count;
+  u_int32 Av_bs_ib_empty;
+  u_int32 Av_slice_count;
+  u_int32 Av_mb_overlapped;
+
+  u_int32 stc_diff[PERF_DEBUG_NUM];
+  u_int32 frm_dec_active[PERF_DEBUG_NUM];
+  u_int32 bs_ib_empty[PERF_DEBUG_NUM];
+  u_int32 slc_dec_active[PERF_DEBUG_NUM];
+  u_int32 num_slc_overlapped[PERF_DEBUG_NUM]; // Only valid for BBV & above
+  u_int32 num_mb_overlapped[PERF_DEBUG_NUM];  // Only valid for BBV & above
+  u_int32 cpb_min_level[PERF_DEBUG_NUM];
+  u_int32 rbsp_byte_count[PERF_DEBUG_NUM];
+  u_int32 dpb_read_count[PERF_DEBUG_NUM];
+  u_int32 mpr_wait_count[PERF_DEBUG_NUM];
+  u_int16 drm_pull_count[PERF_DEBUG_NUM];
+  u_int16 drm_pap_pts_cnt[PERF_DEBUG_NUM];
+  u_int16 drm_pap_skip_cnt[PERF_DEBUG_NUM];
+  u_int16 drm_pap_dang_cnt[PERF_DEBUG_NUM];
+
+  u_int32 initial_dpb_level[PERF_DEBUG_NUM];  // DPB level at frame start
+
+} PerfDebug;
+
+typedef struct
+
+{
+
+  u_int32 loops;              // Number of times we looped
+  u_int32 loop_frames;        // Number of frames in a loop
+  u_int32 num_frames;         // Position in current loop
+  u_int32 loop_dpbmc_crc;     // Merge of CRCs
+  u_int32 loop_stream_crc;    // Merge of CRCs
+  u_int32 LoopCyCntD1024;     // Sum of frm_dec_active/1024
+  u_int32 MaxDecActive;       // Max frm_dec_active
+  u_int32 not_first_time;
+  u_int32 first_crc;
+  u_int32 WorstFrame;
+
+} DecDebug;
+
+
+///////////////////////////////////////////
+// System Configuration structure
+
+typedef struct
+{
+  u_int32 uCfgCookie;
+
+  u_int32 uNumMalones;
+  u_int32 uMaloneBaseAddress[MEDIAIP_MAX_NUM_MALONES];
+  u_int32 uHifOffset[MEDIAIP_MAX_NUM_MALONES];
+  u_int32 uMaloneIrqPin[MEDIAIP_MAX_NUM_MALONES][MEDIAIP_MAX_NUM_MALONE_IRQ_PINS];
+  u_int32 uMaloneIrqTarget[MEDIAIP_MAX_NUM_MALONES][MEDIAIP_MAX_NUM_MALONE_IRQ_PINS];
+
+  u_int32 uNumWindsors;
+  u_int32 uWindsorBaseAddress[MEDIAIP_MAX_NUM_WINDSORS];
+  u_int32 uWindsorIrqPin[MEDIAIP_MAX_NUM_WINDSORS][MEDIAIP_MAX_NUM_WINDSOR_IRQ_PINS];
+  u_int32 uWindsorIrqTarget[MEDIAIP_MAX_NUM_WINDSORS][MEDIAIP_MAX_NUM_WINDSOR_IRQ_PINS];
+
+  u_int32 uCmdIrqPin[MEDIAIP_MAX_NUM_CMD_IRQ_PINS];
+  u_int32 uCmdIrqTarget[MEDIAIP_MAX_NUM_CMD_IRQ_PINS];
+
+  u_int32 uMsgIrqPin[MEDIAIP_MAX_NUM_MSG_IRQ_PINS];
+  u_int32 uMsgIrqTarget[MEDIAIP_MAX_NUM_MSG_IRQ_PINS];
+
+  u_int32 uSysClkFreq;
+  u_int32 uNumTimers;
+  u_int32 uTimerBaseAddr;
+  u_int32 uTimerIrqPin[MEDIAIP_MAX_NUM_TIMER_IRQ_PINS];
+  u_int32 uTimerIrqTarget[MEDIAIP_MAX_NUM_TIMER_IRQ_PINS];
+  u_int32 uTimerSlots[MEDIAIP_MAX_NUM_TIMER_IRQ_SLOTS];
+
+  u_int32 uGICBaseAddr;
+  u_int32 uUartBaseAddr;
+
+  u_int32 uDPVBaseAddr;
+  u_int32 uDPVIrqPin;
+  u_int32 uDPVIrqTarget;
+
+  u_int32 uPixIfBaseAddr;
+
+  u_int32 pal_trace_level;
+  u_int32 pal_trace_destination;
+
+  u_int32 pal_trace_level1;
+  u_int32 pal_trace_destination1;
+
+  u_int32 uHeapBase;
+  u_int32 uHeapSize;
+
+  u_int32 uFSLCacheBaseAddr;
+
+} MEDIAIP_FW_SYSTEM_CONFIG, *pMEDIAIP_FW_SYSTEM_CONFIG;
+
+
+///////////////////////////////////////////
+// Encoder types to be globally used across
+// all encode / transcode apps and components
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_FMT
+
+typedef  enum
+{
+  MEDIAIP_ENC_FMT_H264 = 0,
+  MEDIAIP_ENC_FMT_VC1,
+  MEDIAIP_ENC_FMT_MPEG2,
+  MEDIAIP_ENC_FMT_MPEG4SP,
+  MEDIAIP_ENC_FMT_H263,
+  MEDIAIP_ENC_FMT_MPEG1,
+  MEDIAIP_ENC_FMT_SHORT_HEADER,
+  MEDIAIP_ENC_FMT_NULL
+
+} MEDIAIP_ENC_FMT;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_PROFILE
+
+typedef enum
+{
+  MEDIAIP_ENC_PROF_MPEG2_SP = 0,
+  MEDIAIP_ENC_PROF_MPEG2_MP,
+  MEDIAIP_ENC_PROF_MPEG2_HP,
+  MEDIAIP_ENC_PROF_H264_BP,
+  MEDIAIP_ENC_PROF_H264_MP,
+  MEDIAIP_ENC_PROF_H264_HP,
+  MEDIAIP_ENC_PROF_MPEG4_SP,
+  MEDIAIP_ENC_PROF_MPEG4_ASP,
+  MEDIAIP_ENC_PROF_VC1_SP,
+  MEDIAIP_ENC_PROF_VC1_MP,
+  MEDIAIP_ENC_PROF_VC1_AP
+
+} MEDIAIP_ENC_PROFILE;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_CONFIG_CODEC_PARAMETER
+
+typedef struct
+{
+  MEDIAIP_ENC_FMT      eCodecMode;
+  MEDIAIP_ENC_PROFILE  eProfile;
+  u_int32              uReserved[2];
+
+} MEDIAIP_ENC_CONFIG_CODEC_PARAMETER, *pMEDIAIP_ENC_CONFIG_CODEC_PARAMETER;  //8 words
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_PIXEL_FORMAT
+
+typedef enum
+{
+  MEDIAIP_ENC_PLANAR = 0,
+  MEDIAIP_ENC_SEMIPLANAR
+
+} MEDIAIP_ENC_PIXEL_FORMAT;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_CHROMA_FMT
+
+typedef  enum
+{
+  MODE_420=0,
+  MODE_422,
+  MODE_444
+
+} MEDIAIP_ENC_CHROMA_FMT;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_FRAME_STRUCT
+
+typedef struct
+{
+  u_int32  uSrcFieldModeForDsa;
+  u_int32  uDstFieldModeForEnc;
+  u_int32  uReserved[2];
+
+} MEDIAIP_ENC_FRAME_STRUCT, *pMEDIAIP_ENC_FRAME_STRUCT;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_FRAME_DIMENSIONS
+
+typedef struct
+{
+  /* Input picture features */
+  u_int32    uSrcWidth;
+  u_int32    uSrcHeight;
+  u_int32    uYStride;
+  u_int32    uUVStride;
+
+  /* Clipping information   */
+  u_int32    uClipFlag;     /*Note: 0: don't clip, 1: clip.   encode only a part of input frame      */
+  u_int32    uOffset_x;
+  u_int32    uOffset_y;
+  u_int32    uClipPicWidth;
+  u_int32    uClipPicHeight;
+
+  /* Output picture features */
+  u_int32    uDstWidth;
+  u_int32    uDstHeight;
+  u_int32    uTileMode;     /* 0: scan raster mode  1: tile mode.                                     */
+  u_int32    uTileWidth;    /* Note: In tile mode, uYStride should be calculated depend on uTileWidth */
+  u_int32    uTileHeight;
+
+} MEDIAIP_ENC_FRAME_DIMENSIONS, *pMEDIAIP_ENC_FRAME_DIMENSIONS;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_BITRATE_MODE
+
+typedef enum
+{
+  MEDIAIP_ENC_BITRATECONTROLMODE_VBR          = 0x00000001,
+  MEDIAIP_ENC_BITRATECONTROLMODE_CBR          = 0x00000002,
+  MEDIAIP_ENC_BITRATECONTROLMODE_CONSTANT_QP  = 0x00000004   /* Only in debug mode */
+
+} MEDIAIP_ENC_BITRATE_MODE, *pMEDIAIP_ENC_BITRATE_MODE;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_BITRATE_CONTROL
+
+typedef struct
+{
+  MEDIAIP_ENC_BITRATE_MODE  eBitRateMode;
+  u_int32                   uTargetBitrate;
+  u_int32                   uMaxBitRate;
+  u_int32                   uMinBitRate;      /* Requested by Windsor, for soft encoder, it is useless */
+  u_int32                   uSliceQP;
+
+} MEDIAIP_ENC_BITRATE_CONTROL, *pMEDIAIP_ENC_BITRATE_CONTROL;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_GOP_STRUCTURE
+
+typedef struct
+{
+  u_int32 uFrameRateNum;
+  u_int32 uFrameRateDen;
+  u_int32 uIFrameInterval;
+  u_int32 uGopBLength;       /* How many B frames between I or P frames,  max is 4 for Windsor */
+  u_int32 uLowLatencyMode;   /* Switch off scene change mode, no B frame, only in VBR Mode     */
+  /* TODO-KMC */
+  /* Remove the crap below */
+  u_int32 reserved[3];
+
+} MEDIAIP_ENC_GOP_STRUCTURE, *pMEDIAIP_ENC_GOP_STRUCTURE;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_STREAM_PARAMETER
+
+typedef struct
+{
+  MEDIAIP_ENC_CHROMA_FMT        eVideoFormat;
+  MEDIAIP_ENC_PIXEL_FORMAT      ePixelFormat;
+
+  MEDIAIP_ENC_GOP_STRUCTURE     mGOPStructure;
+  MEDIAIP_ENC_FRAME_STRUCT      mFrameStructure;
+  MEDIAIP_ENC_FRAME_DIMENSIONS  mFrameSize;
+  MEDIAIP_ENC_BITRATE_CONTROL   mBitRateControl;
+  u_int32                       uExpertModeEnable;    /* Enable expert mode            */
+  u_int32                       uMemChunkAddr;        /* Start address of memory chunk */
+  u_int32                       uMemChunkSize;        /* Size of memory chunk          */
+  u_int32                       uStreamFinish;
+  /* TODO-KMC */
+  /* Remove the crap below */
+  u_int32                       reserved[64 - 40];
+
+} MEDIAIP_ENC_STREAM_PARAMETER, *pMEDIAIP_ENC_STREAM_PARAMETER;
+
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_YUV_BUFFER_DESC
+
+typedef struct
+{
+  u_int32   uFrameID;
+  u_int32   uLumaBase;
+  u_int32   uChromaBase;
+  u_int32   uParamIdx;
+
+} MEDIAIP_ENC_YUV_BUFFER_DESC, *pMEDIAIP_ENC_YUV_BUFFER_DESC;
+
+///////////////////////////////////////////
+// eMEDIAIP_ENC_PIC_TYPE
+
+typedef  enum
+{
+  MEDIAIP_ENC_PIC_TYPE_B_FRAME = 0,
+  MEDIAIP_ENC_PIC_TYPE_P_FRAME,
+  MEDIAIP_ENC_PIC_TYPE_I_FRAME,
+  MEDIAIP_ENC_PIC_TYPE_IDR_FRAME,
+  MEDIAIP_ENC_PIC_TYPE_BI_FRAME
+
+} MEDIAIP_ENC_PIC_TYPE, *pMEDIAIP_ENC_PIC_TYPE;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_PIC_TYPE
+
+typedef struct
+{
+  u_int32              uFrameID;
+  u_int32              uPicEncodDone;
+  MEDIAIP_ENC_PIC_TYPE ePicType;
+  u_int32              uSkippedFrame;
+  u_int32              uErrorFlag;
+  u_int32              uPSNR;
+  u_int32              uFlushDone;
+  u_int32              uMBy;
+  u_int32              uMBx;
+  u_int32              uFrameSize;
+  u_int32              uFrameEncTtlFrmCycles;
+  u_int32              uFrameEncTtlSlcCycles;
+  u_int32              uFrameEncTtlEncCycles;
+  u_int32              uFrameEncTtlHmeCycles;
+  u_int32              uFrameEncTtlDsaCycles;
+  u_int32              uFrameEncFwCycles;
+  u_int32              uFrameCrc;
+  u_int32              uNumInterrupts_1;
+  u_int32              uNumInterrupts_2;
+  u_int32              uH264POC;
+  u_int32              uRefInfo;
+  u_int32              uPicNum;
+  u_int32              uPicActivity;
+  u_int32              uSceneChange;
+  u_int32              uMBStats;
+  u_int32              uEncCacheCount0;
+  u_int32              uEncCacheCount1;
+  u_int32              uMtlWrStrbCnt;
+  u_int32              uMtlRdStrbCnt;
+  u_int32              uStrBuffWrPtr;
+  u_int32              uDiagnosticEvents;
+  u_int32              uProcIaccTotRdCnt;
+  u_int32              uProcDaccTotRdCnt;
+  u_int32              uProcDaccTotWrCnt;
+  u_int32              uProcDaccRegRdCnt;
+  u_int32              uProcDaccRegWrCnt;
+  u_int32              uProcDaccRngRdCnt;
+  u_int32              uProcDaccRngWrCnt;
+
+} MEDIAIP_ENC_PIC_INFO, *pMEDIAIP_ENC_PIC_INFO;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_DSA_INFO
+
+typedef struct
+{
+  u_int32  uHeight;
+  u_int32  uWidth;
+  u_int32  uCropWidth;
+  u_int32  uCropHeight;
+  u_int32  uCropPixelXOffset;
+  u_int8 * pImgBuffer;
+  u_int32  uStride;
+  u_int32  uOffset2Chroma;
+  u_int32  uOffset2Decimate;
+
+} MEDIAIP_ENC_DSA_INFO, *pMEDIAIP_ENC_DSA_INFO;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_PIC_PARAM_UPD
+
+typedef struct
+{
+  /* Each bit indicate corresponding parameter should be updated */
+  u_int32    uMaskflag;
+
+  /* ENC_GOP_STRUCTURE variables            */
+  u_int32    uFrameRateNum;
+  u_int32    uFrameRateDen;
+
+  /* MEDIAIP_ENC_FRAME_STRUCT variables     */
+  u_int32    uSrcFieldModeForDsa;
+  u_int32    uDstFieldModeForEnc;
+
+  /* MEDIAIP_ENC_FRAME_DIMENSIONS variables */
+  u_int32    uSrcWidth;
+  u_int32    uSrcHeight;
+  u_int32    uYStride;
+  u_int32    uUVStride;
+  u_int32    uOffset_x;
+  u_int32    uOffset_y;
+  u_int32    uClipPicWidth;
+  u_int32    uClipPicHeight;
+  u_int32    uDstWidth;
+  u_int32    uDstHeight;
+  u_int32    uIFrameInterval;
+  u_int32    uGopBLength;
+  u_int32    uLowLatencyMode;
+
+  /* MEDIAIP_ENC_BITRATE_CONTROL  variables */
+  MEDIAIP_ENC_BITRATE_MODE  eBitRateMode;
+  u_int32                   uTargetBitrate;
+  u_int32                   uMaxBitRate;
+  u_int32                   uMinBitRate;
+  u_int32                   uSliceQP;
+  u_int32                   uReserved[32-23];
+
+} MEDIAIP_ENC_PIC_PARAM_UPD, *pMEDIAIP_ENC_PIC_PARAM_UPD;
+
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_CALIB_PARAMS
+//
+// Encoder Hardware calibration parameters
+
+typedef struct
+{
+  u_int32 use_ame;
+
+  u_int32 cme_mvx_max;
+  u_int32 cme_mvy_max;
+  u_int32 ame_prefresh_y0;
+  u_int32 ame_prefresh_y1;
+  u_int32 fme_min_sad;
+  u_int32 cme_min_sad;
+
+  u_int32 fme_pred_int_weight;
+  u_int32 fme_pred_hp_weight;
+  u_int32 fme_pred_qp_weight;
+  u_int32 fme_cost_weight;
+  u_int32 fme_act_thold;
+  u_int32 fme_sad_thold;
+  u_int32 fme_zero_sad_thold;
+
+  u_int32 fme_lrg_mvx_lmt;
+  u_int32 fme_lrg_mvy_lmt;
+  u_int32 fme_force_mode;
+  u_int32 fme_force4mvcost;
+  u_int32 fme_force2mvcost;
+
+  u_int32 h264_inter_thrd;
+
+  u_int32 i16x16_mode_cost;
+  u_int32 i4x4_mode_lambda;
+  u_int32 i8x8_mode_lambda;
+
+  u_int32 inter_mod_mult;
+  u_int32 inter_sel_mult;
+  u_int32 inter_bid_cost;
+  u_int32 inter_bwd_cost;
+  u_int32 inter_4mv_cost;
+  int32   one_mv_i16_cost;
+  int32   one_mv_i4x4_cost;
+  int32   one_mv_i8x8_cost;
+  int32   two_mv_i16_cost;
+  int32   two_mv_i4x4_cost;
+  int32   two_mv_i8x8_cost;
+  int32   four_mv_i16_cost;
+  int32   four_mv_i4x4_cost;
+  int32   four_mv_i8x8_cost;
+
+  u_int32 intra_pred_enab;
+  u_int32 intra_chr_pred;
+  u_int32 intra16_pred;
+  u_int32 intra4x4_pred;
+  u_int32 intra8x8_pred;
+
+  u_int32 cb_base;
+  u_int32 cb_size;
+  u_int32 cb_head_room;
+
+  u_int32 mem_page_width;
+  u_int32 mem_page_height;
+  u_int32 mem_total_size;
+  u_int32 mem_chunk_addr;
+  u_int32 mem_chunk_size;
+  u_int32 mem_y_stride;
+  u_int32 mem_uv_stride;
+
+  u_int32 split_wr_enab;
+  u_int32 split_wr_req_size;
+  u_int32 split_rd_enab;
+  u_int32 split_rd_req_size;
+
+} MEDIAIP_ENC_CALIB_PARAMS, *pMEDIAIP_ENC_CALIB_PARAMS;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_CONFIG_PARAMS
+//
+// Stream-specific configuration parameters
+
+typedef struct
+{
+  u_int32 ParamChange;
+
+  u_int32 start_frame;                // These variables are for debugging purposes only
+  u_int32 end_frame;
+
+  u_int32 userdata_enable;
+  u_int32 userdata_id[4];
+  u_int32 userdata_message[MEDIAIP_ENC_USER_DATA_WORDS];
+  u_int32 userdata_length;
+
+  u_int32 h264_profile_idc;
+  u_int32 h264_level_idc;
+  u_int32 h264_au_delimiter;          // Enable the use of Access Unit Delimiters
+  u_int32 h264_seq_end_code;          // Enable the use of Sequence End Codes
+  u_int32 h264_recovery_points;       // Enable the use of Recovery Points (must be with a fixed GOP structure)
+  u_int32 h264_vui_parameters;        // Enable the use of VUI parameters (for rate control purposes)
+  u_int32 h264_aspect_ratio_present;
+  u_int32 h264_aspect_ratio_sar_width;
+  u_int32 h264_aspect_ratio_sar_height;
+  u_int32 h264_overscan_present;
+  u_int32 h264_video_type_present;
+  u_int32 h264_video_format;
+  u_int32 h264_video_full_range;
+  u_int32 h264_video_colour_descriptor;
+  u_int32 h264_video_colour_primaries;
+  u_int32 h264_video_transfer_char;
+  u_int32 h264_video_matrix_coeff;
+  u_int32 h264_chroma_loc_info_present;
+  u_int32 h264_chroma_loc_type_top;
+  u_int32 h264_chroma_loc_type_bot;
+  u_int32 h264_timing_info_present;
+  u_int32 h264_buffering_period_present;
+  u_int32 h264_low_delay_hrd_flag;
+
+  u_int32 aspect_ratio;
+  u_int32 test_mode;                  // Automated firmware test mode
+  u_int32 dsa_test_mode;              // Automated test mode for the DSA.
+  u_int32 fme_test_mode;              // Automated test mode for the fme
+
+  u_int32 cbr_row_mode;               //0: FW mode; 1: HW mode
+  u_int32 windsor_mode;               //0: normal mode; 1: intra only mode; 2: intra+0MV mode
+  u_int32 encode_mode;                // H264, VC1, MPEG2, DIVX
+  u_int32 frame_width;                // display width
+  u_int32 frame_height;               // display height
+  u_int32 enc_frame_width;            // encoding width, should be 16-pix align
+  u_int32 enc_frame_height;           // encoding height, should be 16-pix aligned for progressive and 32-pix aligned for interlace
+  u_int32 frame_rate_num;
+  u_int32 frame_rate_den;
+
+  u_int32 vi_field_source;              // vi input source is frame or field
+  u_int32 vi_frame_width;
+  u_int32 vi_frame_height;
+  u_int32 crop_frame_width;
+  u_int32 crop_frame_height;
+  u_int32 crop_x_start_posn;
+  u_int32 crop_y_start_posn;
+  u_int32 mode422;
+  u_int32 mode_yuy2;
+  u_int32 dsa_luma_en;
+  u_int32 dsa_chroma_en;
+  u_int32 dsa_ext_hfilt_en;
+  u_int32 dsa_di_en;
+  u_int32 dsa_di_top_ref;
+  u_int32 dsa_vertf_disable;   // disable the vertical filter.
+  u_int32 dsa_disable_pwb;
+  u_int32 dsa_hor_phase;
+  u_int32 dsa_ver_phase;
+
+  u_int32 dsa_iac_enable;      // IAC / DSA cannot operate independently in FW so this variable controls
+  u_int32 iac_sc_threshold;
+  u_int32 iac_vm_threshold;
+  u_int32 iac_skip_mode;
+  u_int32 iac_grp_width;
+  u_int32 iac_grp_height;
+
+  u_int32 rate_control_mode;
+  u_int32 rate_control_resolution;
+  u_int32 buffer_size;
+  u_int32 buffer_level_init;
+  u_int32 buffer_I_bit_budget;
+
+  u_int32 top_field_first;
+
+  u_int32 intra_lum_qoffset;
+  u_int32 intra_chr_qoffset;
+  u_int32 inter_lum_qoffset;
+  u_int32 inter_chr_qoffset;
+  u_int32 use_def_scaling_mtx;
+
+  u_int32 inter_8x8_enab;
+  u_int32 inter_4x4_enab;
+
+  u_int32 fme_enable_qpel;
+  u_int32 fme_enable_hpel;
+  u_int32 fme_nozeromv;               // can force the FME not to do the (0,0) search.
+  u_int32 fme_predmv_en;
+  u_int32 fme_pred_2mv4mv;
+  u_int32 fme_smallsadthresh;
+
+  u_int32 ame_en_lmvc;
+  u_int32 ame_x_mult;
+  u_int32 cme_enable_4mv;             // Enable the use of 4MV partitioning
+  u_int32 cme_enable_1mv;
+  u_int32 hme_enable_16x8mv;
+  u_int32 hme_enable_8x16mv;
+  u_int32 cme_mv_weight;              // CME motion vector decisions are made by combining these
+  u_int32 cme_mv_cost;                // cost and weight variables
+  u_int32 ame_mult_mv;
+  u_int32 ame_shift_mv;
+
+  u_int32 hme_forceto1mv_en;
+  u_int32 hme_2mv_cost;               // the cost of choosing a 2MV mode over 1MV.
+  u_int32 hme_pred_mode;
+  u_int32 hme_sc_rnge;
+  u_int32 hme_sw_rnge;
+
+  // for windsor pes , add by fulin
+  u_int32 output_format;     // 0: output ES; 1: output PES
+  u_int32 timestamp_enab;    // 0: have timestamps in all frame; 1: have timestamps in I and P frame; 2: have timestamps only in I frame
+  u_int32 initial_PTS_enab;  // if enabled , use following value,else compute by fw
+  u_int32 initial_PTS;       // the initial value of PTS in the first frame (ms)
+
+} MEDIAIP_ENC_CONFIG_PARAMS, *pMEDIAIP_ENC_CONFIG_PARAMS;
+
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_STATIC_PARAMS
+//
+// Static parameters ( may change at the GOP level )
+
+typedef struct
+{
+  u_int32 ParamChange;
+
+  u_int32 gop_length;
+
+  u_int32 rate_control_bitrate;
+  u_int32 rate_control_bitrate_min;
+  u_int32 rate_control_bitrate_max;
+  u_int32 rate_control_content_models;
+  u_int32 rate_control_iframe_maxsize; // Maximum size of I frame generated by BPM in comparison to ideal (/4)
+  u_int32 rate_control_qp_init;
+  u_int32 rate_control_islice_qp;
+  u_int32 rate_control_pslice_qp;
+  u_int32 rate_control_bslice_qp;
+
+  u_int32 adaptive_quantization;      // Enable the use of activity measures from VIPP in QP assignment
+  u_int32 aq_variance;
+  u_int32 cost_optimization;          // Enable picture/frame level adjustments of the cost parameters by FW.
+  u_int32 fdlp_mode;                  // Frequency-domain low-pass filter control, 0: off, 1-4: specific, 5: adaptive
+  u_int32 enable_isegbframes;         // Enable the use of B frames in the first segment of a GOP
+  u_int32 enable_adaptive_keyratio;   // Enable the use of an adaptive I to P/B ratio (aims to reduce distortion)
+  u_int32 keyratio_imin;              // Clamps applied to picture size ratios
+  u_int32 keyratio_imax;
+  u_int32 keyratio_pmin;
+  u_int32 keyratio_pmax;
+  u_int32 keyratio_bmin;
+  u_int32 keyratio_bmax;
+  int32   keyratio_istep;
+  int32   keyratio_pstep;
+  int32   keyratio_bstep;
+
+  u_int32 enable_paff;                // Enable Picture Adaptive Frame/Field
+  u_int32 enable_b_frame_ref;         // Enable B frame as references
+  u_int32 enable_adaptive_gop;        // Enable an adaptive GOP structure
+  u_int32 enable_closed_gop;          // Enable a closed GOP structure
+                                      // i.e. if enabled, the first consecutive B frames following
+                                      // an I frame in each GOP will be intra or backwards only coded
+                                      // and do not rely on previous reference pictures.
+  u_int32 open_gop_refresh_freq;      // Controls the insertion of closed GOP's (or IDR GOP's in H.264)
+  u_int32 enable_adaptive_sc;         // Enable adaptive scene change GOP structure (0:off, 1:adaptive, 2:IDR)
+  u_int32 enable_fade_detection;      // Enable fade detection and associated motion estimation restrictions
+  int32   fade_detection_threshold;   // Threshold at which the activity slope indicates a possible fading event
+  u_int32 enable_repeat_b;            // Enalbe the repeated B frame mode at CBR
+
+} MEDIAIP_ENC_STATIC_PARAMS, *pMEDIAIP_ENC_STATIC_PARAMS;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_DYN_PARAMS
+//
+// Dynamic parameters (may change at the frame level)
+
+typedef struct
+{
+  u_int32 ParamChange;
+
+  u_int32 rows_per_slice;
+
+  u_int32 mbaff_enable;                // Macroblock adaptive frame/field enable
+  u_int32 dbf_enable;                  // Enable the deblocking filter
+
+  u_int32 field_source;                // progressive/interlaced control
+  u_int32 gop_b_length;                // Number of B frames between anchor frames
+                                      //  (only to be changed at a GOP segment boundary)
+  u_int32 mb_group_size;               // Number of macroblocks normally assigned to a group
+                                      // (implications for performance, interrupts and rate control)
+
+  u_int32 cbr_rows_per_group;
+
+  u_int32 skip_enable;                 // Enable the use of skipped macroblocks
+
+  u_int32 pts_bits_0_to_31;            // TO BE REMOVED...
+  u_int32 pts_bit_32;
+
+  u_int32 rm_expsv_cff;
+  u_int32 const_ipred;
+  int32 chr_qp_offset;
+  u_int32 intra_mb_qp_offset;
+
+  u_int32 h264_cabac_init_method;
+  u_int32 h264_cabac_init_idc;
+  u_int32 h264_cabac_enable;                 // Main and stream
+
+  int32 alpha_c0_offset_div2;
+  int32 beta_offset_div2;
+
+  u_int32 intra_prefresh_y0; // for setting intra limits for prog refresh.
+  u_int32 intra_prefresh_y1;
+
+  u_int32 dbg_dump_rec_src;
+
+} MEDIAIP_ENC_DYN_PARAMS, *pMEDIAIP_ENC_DYN_PARAMS;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_EXPERT_MODE_PARAM
+
+typedef struct
+{
+  MEDIAIP_ENC_CALIB_PARAMS   Calib;
+  MEDIAIP_ENC_CONFIG_PARAMS  Config;
+  MEDIAIP_ENC_STATIC_PARAMS  Static;
+  MEDIAIP_ENC_DYN_PARAMS     Dynamic;
+} MEDIAIP_ENC_EXPERT_MODE_PARAM, *pMEDIAIP_ENC_EXPERT_MODE_PARAM;
+
+///////////////////////////////////////////
+// MEDIAIP_ENC_PARAM
+
+typedef struct
+{
+  MEDIAIP_ENC_FMT           eCodecMode;
+  MEDIAIP_ENC_PROFILE       eProfile;
+
+  u_int32                   uMemChunkAddr;
+  u_int32                   uMemChunkSize;
+
+  u_int32                   uFrameRate;
+  u_int32                   uSrcStride;
+  u_int32                   uSrcWidth;
+  u_int32                   uSrcHeight;
+  u_int32                   uSrcOffset_x;
+  u_int32                   uSrcOffset_y;
+  u_int32                   uSrcCropWidth;
+  u_int32                   uSrcCropHeight;
+  u_int32                   uOutWidth;
+  u_int32                   uOutHeight;
+  u_int32                   uIFrameInterval;
+  u_int32                   uGopBLength;
+  u_int32                   uLowLatencyMode;
+
+  MEDIAIP_ENC_BITRATE_MODE  eBitRateMode;
+  u_int32                   uTargetBitrate;
+  u_int32                   uMaxBitRate;
+  u_int32                   uMinBitRate;
+  u_int32                   uInitSliceQP;
+
+} MEDIAIP_ENC_PARAM, *pMEDIAIP_ENC_PARAM;
+
+#endif /* _MEDIAIP_FW_TYPES_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/Incl/pal.h b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/pal.h
new file mode 100755
index 0000000..66c2141
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/pal.h
@@ -0,0 +1,337 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+  Filename    :    pal.h
+  Description :    Public header file for the
+                   Platform Abstraction Layer
+  Author:          Media IP FW team (Belfast)
+
+ ***************************************************/
+
+#ifndef _PAL_H_
+#define _PAL_H_
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header Files
+/////////////////////////////////////////////////////////////////////////////////
+
+#ifndef VPU_KERNEL_BUILD
+#include "stdio.h"
+#include "video_subsystem.h"
+#include "pal_os_al.h"
+/* For va_list */
+#include <stdarg.h>
+#endif
+#include "basetype.h"
+#include "pal_types.h"
+
+#if ( TARGET_APP == VPU_TEST_APP )
+/* thread, semaphore and queue funcitons */
+#include "pal_linux_map.h"
+#endif
+
+/* For buffer descriptor */
+#include "mediaip_fw_types.h"
+
+/* For va_list */
+#include <stdarg.h>
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Function prototypes
+/////////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////
+// Initialisation Functions
+//
+
+#if RTOS == NONE
+
+MEDIAIP_FW_STATUS pal_initialise ( psPALConfig pconfig );
+
+#else
+
+void pal_early_initialise ( void );
+
+MEDIAIP_FW_STATUS pal_initialise ( void );
+
+#endif
+
+//////////////////////////////////////////////////
+// Assert function
+//
+void pal_assert_impl(u_int32 uAssertPC, u_int32 uAssertInfo);
+
+///////////////////////////////////////////////////
+// Critical section functions
+//
+
+MEDIAIP_FW_STATUS pal_critical_section_begin ( PAL_CRIT_STATE *pState );
+
+MEDIAIP_FW_STATUS pal_critical_section_end ( PAL_CRIT_STATE PreviousState );
+
+///////////////////////////////////////////////////
+// Interrupt Functions
+//
+
+MEDIAIP_FW_STATUS pal_int_register ( u_int32     dwIntID,
+                                     PAL_PFNISR  pfnHandler,
+                                     BOOL        bFIQ );
+
+MEDIAIP_FW_STATUS pal_int_enable ( u_int32 dwIntID );
+
+void pal_int_set ( u_int32 dwIntID );
+
+#if  ( TARGET_PLATFORM == GENTB_PLATFORM ) || ( TARGET_PLATFORM == GEN_TB_ENC ) || ( TARGET_PLATFORM == WIN_LIB )
+
+void pal_int_clear ( u_int32 dwIntID,
+                     BOOL    bDirect );
+
+MEDIAIP_FW_STATUS pal_int_get_irq_line ( u_int32 uFWIrq,
+                                         u_int32 *puIrqLine );
+
+#else
+
+void pal_int_clear ( u_int32 dwIntID );
+
+#endif
+
+void pal_int_clear_host ( u_int32 dwIntID );
+
+
+///////////////////////////////////////////////////
+// Processor Cache Control Functions
+//
+
+MEDIAIP_FW_STATUS pal_clean_d_cache ( void );
+
+MEDIAIP_FW_STATUS pal_disable_d_cache ( void );
+
+void              pal_wait_for_interrupt ( void );
+
+///////////////////////////////////////////////////
+// Malone Cache Control Functions
+//
+void pal_set_malone_cache ( u_int32 uMalID );
+
+///////////////////////////////////////////////////
+// C Runtime Wrappers
+//
+
+MEDIAIP_FW_STATUS pal_memcpy ( void *pDest,
+                               const void *pSrc,
+                               u_int32 uSize );
+
+void pal_memset ( void *pDest, int32 nChar, u_int32 uCount );
+
+BOOL pal_memcompare ( void *pArea1, void *pArea2, u_int32 uSizeInWords );
+
+///////////////////////////////////////////////////
+// Hardware Timer Service APIs
+//
+
+MEDIAIP_FW_STATUS pal_timer_create ( PAL_PFNTIMER     pfnCallback,
+                                     void *           pUserData,
+                                     PAL_TIMER_ID *   pTimer );
+
+MEDIAIP_FW_STATUS pal_timer_destroy( PAL_TIMER_ID Timer );
+
+///////////////////////////////////////////////////
+// Perf Counter APIs
+//
+
+MEDIAIP_FW_STATUS pal_perf_counter_create ( const char *  pszName,
+                                            PAL_PERF_ID * pPCId );
+
+MEDIAIP_FW_STATUS pal_perf_counter_destroy ( PAL_PERF_ID PCId );
+
+MEDIAIP_FW_STATUS pal_perf_counter_start ( PAL_PERF_ID PCId );
+
+MEDIAIP_FW_STATUS pal_perf_counter_stop ( PAL_PERF_ID PCId );
+
+MEDIAIP_FW_STATUS pal_perf_counter_pause_control ( PAL_PERF_ID PCId , bool bStartPause);
+
+MEDIAIP_FW_STATUS pal_perf_counter_read ( PAL_PERF_ID PerfId,
+                                          u_int32 *   puCountVal );
+
+///////////////////////////////////////////////////
+// Trace / Error / Message log functions
+//
+
+/* Error logging */
+#if !(DEBUG_CAPS == FULL_DEBUG ) && (ENABLE_TRACE_IN_RELEASE == NO)
+
+/* Non-debug case */
+MEDIAIP_FW_STATUS pal_error_log ( u_int32 uError );
+
+#else
+
+/* Debug case - wrap in macros so that we can add file and line number automatically */
+#ifdef _MSC_VER
+int pal_debug_error_log (
+#else
+MEDIAIP_FW_STATUS pal_debug_error_log (
+#endif
+                  u_int32 uError,
+                  char    *pszFile,
+                  int32   nLineNum );
+#ifndef _MSC_VER
+#define pal_error_log(x) pal_debug_error_log((x), __FILE__, __LINE__)
+#endif // _MSC_VER
+#endif
+
+/* Size of trace print buffer        */
+#define FW_PRT_BUFF_SIZE       512
+
+#ifdef DISABLE_TRACE
+/* Declare pal_trace as an empty statement and cast to void to avoid a "no-effect" warning. */
+/* This soaks up the trailing semi-colon and avoids leaving them dangling.                  */
+#define pal_trace(...) (void)(0)
+#else
+#if ( TARGET_APP == VPU_TEST_APP )
+#ifdef NXP_MX_REAL_TARGET
+#define pal_trace(flags, fmt, arg...) dprintf(LVL_FUNC, fmt, ## arg)
+#else
+void pal_trace ( u_int32 uFlags, const char *psz_format, ...);
+#endif
+#else
+void pal_trace ( u_int32 uFlags, const char *psz_format, ...);
+#endif
+#endif
+
+int pal_vsnprintf ( char *str, int size, const char *format, va_list args );
+
+int pal_sprintf ( char *str, int size, const char *psz_format, ...);
+
+#ifdef PAL_DEBUG_LOG
+void pal_debug_log ( u_int32 uCode );
+#else
+#define pal_debug_log(...) (void)(0)
+#endif
+
+MEDIAIP_FW_STATUS pal_trace_set_level ( u_int32               uLevel,
+                                        BOOL                  bTimestamp,
+                                        MEDIAIP_TRACE_FLAGS * pFlags );
+
+MEDIAIP_FW_STATUS pal_trace_set_module_flag ( u_int32               uModuleID,
+                                              BOOL                  bEnable,
+                                              MEDIAIP_TRACE_FLAGS * pFlags );
+
+MEDIAIP_FW_STATUS pal_trace_is_module_enabled ( u_int32  uModuleID,
+                                                BOOL   * pbEnabled );
+
+void pal_checkpoint_str(char *pMsg );
+void pal_checkpoint_hex(unsigned uData);
+#define CHECKPOINT_STR pal_checkpoint_str
+#define CHECKPOINT_HEX pal_checkpoint_hex
+
+
+///////////////////////////////////////////////////
+// Clock functions - often very platform specific
+//
+
+#ifdef PAL_CLOCK_API
+
+MEDIAIP_FW_STATUS pal_malone_clock_reg_init ( void );
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_common ( bool bEnable );
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_avc ( bool bEnable );
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_vc1 ( bool bEnable );
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_mpg ( bool bEnable );
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_avs ( bool bEnable );
+
+#endif /* PAL_CLOCK_API */
+
+///////////////////////////////////////////////////
+// Miscellaneous functions
+//
+
+void pal_fatal_exit_internal ( u_int32 uCosmicConstant,
+                               char  * pszFilename,
+                               int     iLineNum );
+
+//#define pal_fatal_exit(x)    pal_fatal_exit_internal((x), __FILE__, __LINE__)
+#ifdef VPU_KERNEL_BUILD
+#define pal_fatal_exit(x)    while (1) {printk("pal_fatal_exit in %s file %s line %d\n", __FUNCTION__, __FILE__, __LINE__);}
+#else
+#define pal_fatal_exit(x)    while (1) {printf("pal_fatal_exit in %s file %s line %d\n", __FUNCTION__, __FILE__, __LINE__);}
+#endif
+
+
+
+u_int32 pal_find_highest_bit ( u_int32 uValue );
+
+extern u_int32 _return_pc ( void );
+
+#define pal_return_pc _return_pc
+
+u_int32 pal_get_fw_base ( void );
+
+u_int32 pal_get_target_version ( void );
+
+///////////////////////////////////////////////////
+// Memory management abstraction functions
+//
+#if ( TARGET_APP == VPU_TEST_APP )
+/* sPALMemDesc Added by NXP for their PAL implementation */
+typedef struct {
+	u_int32 size;
+	u_int32 phy_addr;
+	uint_addr virt_addr;
+#ifdef USE_ION
+	int32 ion_buf_fd;
+#endif
+} sPALMemDesc, *psPALMemDesc;
+
+MEDIAIP_FW_STATUS pal_get_phy_buf(psPALMemDesc pbuf);
+MEDIAIP_FW_STATUS pal_free_phy_buf(psPALMemDesc pbuf);
+#endif
+
+u_int32 pal_va2pa ( u_int32 * pAddr );
+
+u_int32 * pal_return_uncached_addr ( u_int32 * puAddress );
+
+u_int32 * pal_return_cacheable_addr ( u_int32 * puAddress );
+
+u_int32 * pal_return_mmu_bypass_addr ( u_int32 * puAddress );
+
+u_int32 pal_read_uncached ( u_int32 * puAddress );
+
+#if RTOS != NONE
+/* Need to add in the prototypes for the PAL ftns which invoke an OS */
+/* Abstraction layer call                                            */
+
+#include "pal_os_al.h"
+
+#endif
+
+///////////////////////////////////////////////////
+// Miscellaneous macros
+//
+
+#ifdef PERF_MEASURE_ENABLE_ENC
+u_int32 GetCountVal();
+u_int32 SetCountVal(u_int32 CountVal);
+#endif
+
+#if ( TARGET_APP == VPU_TEST_APP )
+#define INT_ID_MALONE_LOW 0
+#define INT_ID_MALONE_HI 1
+#define INT_ID_MAX 2
+extern PAL_PFNISR int_handlers[INT_ID_MAX];
+#endif
+
+#endif /* _PAL_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/Incl/status_codes.h b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/status_codes.h
new file mode 100755
index 0000000..cc53a56
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/status_codes.h
@@ -0,0 +1,99 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd 
+                All rights reserved.               
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+  Filename    : status_codes.h
+  Description : Public header file for FW & SW status codes
+                including those used by relevant abstraction layers
+  Author      : Kyle McAdoo
+ 
+ *****************************************************/
+
+#ifndef _STATUS_CODES_H_
+#define _STATUS_CODES_H_
+
+typedef enum
+{
+   /*   0  0x00  */   MEDIAIP_FW_STATUS_OK = 0,
+   /*   1  0x01  */   MEDIAIP_FW_STATUS_ALREADY_INIT,
+   /*   2  0x02  */   MEDIAIP_FW_STATUS_NOT_INIT,
+   /*   3  0x03  */   MEDIAIP_FW_STATUS_INTERNAL_ERROR,
+   /*   4  0x04  */   MEDIAIP_FW_STATUS_BAD_HANDLE,
+   /*   5  0x05  */   MEDIAIP_FW_STATUS_BAD_PARAMETER,
+   /*   6  0x06  */   MEDIAIP_FW_STATUS_BAD_LENGTH,
+   /*   7  0x07  */   MEDIAIP_FW_STATUS_BAD_UNIT,
+   /*   8  0x08  */   MEDIAIP_FW_STATUS_RESOURCE_ERROR,
+   /*   9  0x09  */   MEDIAIP_FW_STATUS_CLOSED_HANDLE,
+   /*  10  0x0A  */   MEDIAIP_FW_STATUS_TIMEOUT,
+   /*  11  0x0B  */   MEDIAIP_FW_STATUS_NOT_ATTACHED,
+   /*  12  0x0C  */   MEDIAIP_FW_STATUS_NOT_SUPPORTED,
+   /*  13  0x0D  */   MEDIAIP_FW_STATUS_REOPENED_HANDLE,
+   /*  14  0x0E  */   MEDIAIP_FW_STATUS_INVALID,
+   /*  15  0x0F  */   MEDIAIP_FW_STATUS_DESTROYED,
+   /*  16  0x10  */   MEDIAIP_FW_STATUS_DISCONNECTED,
+   /*  17  0x11  */   MEDIAIP_FW_STATUS_BUSY,
+   /*  18  0x12  */   MEDIAIP_FW_STATUS_IN_USE,
+   /*  19  0x13  */   MEDIAIP_FW_STATUS_CANCELLED,
+   /*  20  0x14  */   MEDIAIP_FW_STATUS_UNDEFINED,
+   /*  21  0x15  */   MEDIAIP_FW_STATUS_UNKNOWN,
+   /*  22  0x16  */   MEDIAIP_FW_STATUS_NOT_FOUND,
+   /*  23  0x17  */   MEDIAIP_FW_STATUS_NOT_AVAILABLE,
+   /*  24  0x18  */   MEDIAIP_FW_STATUS_NOT_COMPATIBLE,
+   /*  25  0x19  */   MEDIAIP_FW_STATUS_NOT_IMPLEMENTED,
+   /*  26  0x1A  */   MEDIAIP_FW_STATUS_EMPTY,
+   /*  27  0x1B  */   MEDIAIP_FW_STATUS_FULL,
+   /*  28  0x1C  */   MEDIAIP_FW_STATUS_FAILURE,
+   /*  29  0x1D  */   MEDIAIP_FW_STATUS_ALREADY_ATTACHED,
+   /*  30  0x1E  */   MEDIAIP_FW_STATUS_ALREADY_DONE,
+   /*  31  0x1F  */   MEDIAIP_FW_STATUS_ASLEEP,
+   /*  32  0x20  */   MEDIAIP_FW_STATUS_BAD_ATTACHMENT,
+   /*  33  0x21  */   MEDIAIP_FW_STATUS_BAD_COMMAND,
+   /*  34  0x22  */   MEDIAIP_FW_STATUS_INT_HANDLED,
+   /*  35  0x23  */   MEDIAIP_FW_STATUS_INT_NOT_HANDLED,
+   /*  36  0x24  */   MEDIAIP_FW_STATUS_NOT_SET,
+   /*  37  0x25  */   MEDIAIP_FW_STATUS_NOT_HOOKED,
+   /*  38  0x26  */   MEDIAIP_FW_STATUS_COMPLETE,
+   /*  39  0x27  */   MEDIAIP_FW_STATUS_INVALID_NODE,
+   /*  40  0x28  */   MEDIAIP_FW_STATUS_DUPLICATE_NODE,
+   /*  41  0x29  */   MEDIAIP_FW_STATUS_HARDWARE_NOT_FOUND,
+   /*  42  0x2A  */   MEDIAIP_FW_STATUS_ILLEGAL_OPERATION,
+   /*  43  0x2B  */   MEDIAIP_FW_STATUS_INCOMPATIBLE_FORMATS,
+   /*  44  0x2C  */   MEDIAIP_FW_STATUS_INVALID_DEVICE,
+   /*  45  0x2D  */   MEDIAIP_FW_STATUS_INVALID_EDGE,
+   /*  46  0x2E  */   MEDIAIP_FW_STATUS_INVALID_NUMBER,
+   /*  47  0x2F  */   MEDIAIP_FW_STATUS_INVALID_STATE,
+   /*  48  0x30  */   MEDIAIP_FW_STATUS_INVALID_TYPE,
+   /*  49  0x31  */   MEDIAIP_FW_STATUS_STOPPED,
+   /*  50  0x32  */   MEDIAIP_FW_STATUS_SUSPENDED,
+   /*  51  0x33  */   MEDIAIP_FW_STATUS_TERMINATED,
+   /*  52  0x34  */   MEDIAIP_FW_STATUS_FRAMESTORE_NOT_HANDLED,
+   /* Last Entry */   MEDIAIP_FW_STATUS_CODE_LAST = MEDIAIP_FW_STATUS_FRAMESTORE_NOT_HANDLED
+} MEDIAIP_FW_STATUS;
+
+#if RTOS != NONE
+
+#if OSAL == CNXT_KAL
+#include "cnxt_kal_status_codes.h"
+typedef MEDIAIP_OSAL_STATUS CNXT_IRQ_RETCODE;
+typedef MEDIAIP_FW_STATUS MEDIAIP_IRQ_RETCODE;
+#endif
+
+#if OSAL == NXP_OSAL
+#include "nxp_osal_status_codes.h"
+typedef MEDIAIP_OSAL_STATUS MEDIAIP_IRQ_RETCODE; 
+#endif
+
+#else
+typedef MEDIAIP_FW_STATUS MEDIAIP_IRQ_RETCODE; 
+#endif
+
+#endif /* _STATUS_CODES_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/Incl/trace_types.h b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/trace_types.h
new file mode 100755
index 0000000..18a3cb3
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/Incl/trace_types.h
@@ -0,0 +1,261 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd 
+                All rights reserved.               
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+ Filename    : trace_types.h
+ Description : Public header file containing type definitions and labels
+               related to debug trace functions
+ Author      : Dave Wilson
+               Modified for Transcode FW by K McAdoo (from version 1.41)
+               This is no longer only for RTOS builds
+ ************************************************/
+
+#ifndef _TRACE_TYPES_H_
+#define _TRACE_TYPES_H_
+
+#include "basetype.h"
+
+/* Flag indicating a fatal error - top bit of error_num */
+#define MEDIAIP_ERROR_FATAL              0x80000000
+#define MEDIAIP_ERROR_WARNING            0x00000000
+
+/* Flags for trace levels */
+#define MEDIAIP_TRACE_MASK_MODULE        0x0FFFFFFF
+#define MEDIAIP_TRACE_MASK_LEVEL         0x70000000
+#define MEDIAIP_TRACE_MASK_TIMESTAMP     0x80000000
+
+#define MEDIAIP_TRACE_SHIFT_LEVEL        28
+#define MEDIAIP_TRACE_SHIFT_TIMESTAMP    31
+
+#define MEDIAIP_TRACE_LEVEL_NEVER        0x00000000
+#define MEDIAIP_TRACE_LEVEL_1            0x10000000
+#define MEDIAIP_TRACE_LEVEL_2            0x20000000
+#define MEDIAIP_TRACE_LEVEL_3            0x30000000
+#define MEDIAIP_TRACE_LEVEL_4            0x40000000
+#define MEDIAIP_TRACE_LEVEL_5            0x50000000
+#define MEDIAIP_TRACE_LEVEL_6            0x60000000
+#define MEDIAIP_TRACE_LEVEL_ALWAYS       0x70000000
+
+/* Disable the timestamp */
+#define MEDIAIP_TRACE_NO_TIMESTAMP       0x80000000
+
+/* Module identifiers */
+#define MEDIAIP_TRACE_DECODER            0x00000001
+#define MEDIAIP_TRACE_DISPLAY            0x00000002
+#define MEDIAIP_TRACE_ENCODER            0x00000003
+#define MEDIAIP_TRACE_HANDLE             0x00000004
+#define MEDIAIP_TRACE_IMGPORT            0x00000005
+#define MEDIAIP_TRACE_PAL                0x00000006
+#define MEDIAIP_TRACE_KAL                0x00000006
+#define MEDIAIP_TRACE_MEMMOVE            0x00000007
+#define MEDIAIP_TRACE_QUEUE              0x00000008
+#define MEDIAIP_TRACE_VAMUX              0x00000009
+
+/* Control Layer identifiers          */
+#define MEDIAIP_TRACE_VIDEO_LAYER        0x00000050
+#define MEDIAIP_TRACE_SYSTEM_LAYER       0x00000051
+#define MEDIAIP_TRACE_PROC_LAYER         0x00000052
+#define MEDIAIP_TRACE_API_LAYER          0x00000053
+
+/* Additional IDs for application use */
+#define MEDIAIP_TRACE_APPLICATION        0x00000060
+#define MEDIAIP_TRACE_TEST               0x00000061
+
+/* The upper supported value of a trace module identifier. Make sure that
+   there are no trace IDs defined above this value since it is used to
+   determine the amount of storage required for trace flags! */
+#define MEDIAIP_TRACE_MAX                0x0000009F
+
+/* ID indicating that message should be displayed regardless of the
+   modules which are currently enabled. */
+#define MEDIAIP_TRACE_ANY                0x00000000
+
+/* Trace message color codes */
+
+#define MEDIAIP_TRACE_FG_LIGHT_BLUE            "\033[1;34m"
+#define MEDIAIP_TRACE_FG_LIGHT_GREEN           "\033[1;32m"
+#define MEDIAIP_TRACE_FG_LIGHT_CYAN            "\033[1;36m"
+#define MEDIAIP_TRACE_FG_LIGHT_RED             "\033[1;31m"
+#define MEDIAIP_TRACE_FG_WHITE                 "\033[1;37m"
+#define MEDIAIP_TRACE_FG_NORMAL                MEDIAIP_TRACE_FG_WHITE
+#define MEDIAIP_TRACE_BG_GRAY                  "\033[0;47m"
+#define MEDIAIP_TRACE_BG_BLACK                 "\033[0;40m"
+
+/* The number of 32bit words needed to store our trace flags */
+#define MEDIAIP_TRACE_FLAGS_WORDS ((MEDIAIP_TRACE_MAX+31)/32)
+
+/* Data structure used to store trace flags */
+typedef struct
+{
+
+  u_int32 Flags[MEDIAIP_TRACE_FLAGS_WORDS];
+
+} MEDIAIP_TRACE_FLAGS;
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// Module / Application and System Trace level definitions
+
+#define DECODER_TL_CATASTROPHE  (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define DECODER_TL_SEVERE       (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_DECODER)
+#define DECODER_TL_ERROR        (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_DECODER)
+#define DECODER_TL_WARNING      (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_DECODER)
+#define DECODER_TL_FUNC         (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_DECODER)
+#define DECODER_TL_INFO         (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_DECODER)
+#define DECODER_TL_VERBOSE      (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_DECODER)
+#define DECODER_TL_DEBUG        (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_DECODER)
+
+#define DISPLAY_TL_CATASTROPHE  (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define DISPLAY_TL_SEVERE       (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_DISPLAY)
+#define DISPLAY_TL_ERROR        (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_DISPLAY)
+#define DISPLAY_TL_WARNING      (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_DISPLAY)
+#define DISPLAY_TL_FUNC         (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_DISPLAY)
+#define DISPLAY_TL_INFO         (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_DISPLAY)
+#define DISPLAY_TL_VERBOSE      (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_DISPLAY)
+#define DISPLAY_TL_DEBUG        (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_DISPLAY)
+
+#define ENCODER_TL_CATASTROPHE  (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define ENCODER_TL_SEVERE       (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ENCODER)
+#define ENCODER_TL_ERROR        (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_ENCODER)
+#define ENCODER_TL_WARNING      (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_ENCODER)
+#define ENCODER_TL_FUNC         (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_ENCODER)
+#define ENCODER_TL_INFO         (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_ENCODER)
+#define ENCODER_TL_VERBOSE      (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_ENCODER)
+#define ENCODER_TL_DEBUG        (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_ENCODER)
+
+#define HANDLE_TL_CATASTROPHE   (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define HANDLE_TL_SEVERE        (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_HANDLE)
+#define HANDLE_TL_ERROR         (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_HANDLE)
+#define HANDLE_TL_WARNING       (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_HANDLE)
+#define HANDLE_TL_FUNC          (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_HANDLE)
+#define HANDLE_TL_INFO          (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_HANDLE)
+#define HANDLE_TL_VERBOSE       (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_HANDLE)
+#define HANDLE_TL_DEBUG         (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_HANDLE)
+
+#define IMGPORT_TL_CATASTROPHE  (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define IMGPORT_TL_SEVERE       (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_IMGPORT)
+#define IMGPORT_TL_ERROR        (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_IMGPORT)
+#define IMGPORT_TL_WARNING      (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_IMGPORT)
+#define IMGPORT_TL_FUNC         (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_IMGPORT)
+#define IMGPORT_TL_INFO         (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_IMGPORT)
+#define IMGPORT_TL_VERBOSE      (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_IMGPORT)
+#define IMGPORT_TL_DEBUG        (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_IMGPORT)
+
+#define KAL_TL_CATASTROPHE      (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define KAL_TL_SEVERE           (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_KAL)
+#define KAL_TL_ERROR            (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_KAL)
+#define KAL_TL_WARNING          (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_KAL)
+#define KAL_TL_FUNC             (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_KAL)
+#define KAL_TL_INFO             (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_KAL)
+#define KAL_TL_VERBOSE          (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_KAL)
+#define KAL_TL_DEBUG            (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_KAL)
+
+#define PAL_TL_CATASTROPHE      (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define PAL_TL_SEVERE           (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_PAL)
+#define PAL_TL_ERROR            (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_PAL)
+#define PAL_TL_WARNING          (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_PAL)
+#define PAL_TL_FUNC             (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_PAL)
+#define PAL_TL_INFO             (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_PAL)
+#define PAL_TL_VERBOSE          (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_PAL)
+#define PAL_TL_DEBUG            (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_PAL)
+
+#define MEMMOVE_TL_CATASTROPHE  (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define MEMMOVE_TL_SEVERE       (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_MEMMOVE)
+#define MEMMOVE_TL_ERROR        (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_MEMMOVE)
+#define MEMMOVE_TL_WARNING      (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_MEMMOVE)
+#define MEMMOVE_TL_FUNC         (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_MEMMOVE)
+#define MEMMOVE_TL_INFO         (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_MEMMOVE)
+#define MEMMOVE_TL_VERBOSE      (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_MEMMOVE)
+#define MEMMOVE_TL_DEBUG        (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_MEMMOVE)
+
+#define QUEUE_TL_CATASTROPHE    (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define QUEUE_TL_SEVERE         (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_QUEUE)
+#define QUEUE_TL_ERROR          (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_QUEUE)
+#define QUEUE_TL_WARNING        (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_QUEUE)
+#define QUEUE_TL_FUNC           (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_QUEUE)
+#define QUEUE_TL_INFO           (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_QUEUE)
+#define QUEUE_TL_VERBOSE        (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_QUEUE)
+#define QUEUE_TL_DEBUG          (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_QUEUE)
+
+#define VAMUX_TL_CATASTROPHE    (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define VAMUX_TL_SEVERE         (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_VAMUX)
+#define VAMUX_TL_ERROR          (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_VAMUX)
+#define VAMUX_TL_WARNING        (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_VAMUX)
+#define VAMUX_TL_FUNC           (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_VAMUX)
+#define VAMUX_TL_INFO           (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_VAMUX)
+#define VAMUX_TL_VERBOSE        (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_VAMUX)
+#define VAMUX_TL_DEBUG          (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_VAMUX)
+
+#define VIDEO_TL_CATASTROPHE    (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define VIDEO_TL_SEVERE         (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_VIDEO_LAYER)
+#define VIDEO_TL_ERROR          (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_VIDEO_LAYER)
+#define VIDEO_TL_WARNING        (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_VIDEO_LAYER)
+#define VIDEO_TL_FUNC           (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_VIDEO_LAYER)
+#define VIDEO_TL_INFO           (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_VIDEO_LAYER)
+#define VIDEO_TL_VERBOSE        (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_VIDEO_LAYER)
+#define VIDEO_TL_DEBUG          (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_VIDEO_LAYER)
+
+#define SYSTEM_TL_CATASTROPHE   (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define SYSTEM_TL_SEVERE        (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_SYSTEM_LAYER)
+#define SYSTEM_TL_ERROR         (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_SYSTEM_LAYER)
+#define SYSTEM_TL_WARNING       (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_SYSTEM_LAYER)
+#define SYSTEM_TL_FUNC          (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_SYSTEM_LAYER)
+#define SYSTEM_TL_INFO          (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_SYSTEM_LAYER)
+#define SYSTEM_TL_VERBOSE       (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_SYSTEM_LAYER)
+#define SYSTEM_TL_DEBUG         (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_SYSTEM_LAYER)
+
+#define PROC_TL_CATASTROPHE     (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define PROC_TL_SEVERE          (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_PROC_LAYER)
+#define PROC_TL_ERROR           (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_PROC_LAYER)
+#define PROC_TL_WARNING         (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_PROC_LAYER)
+#define PROC_TL_FUNC            (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_PROC_LAYER)
+#define PROC_TL_INFO            (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_PROC_LAYER)
+#define PROC_TL_VERBOSE         (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_PROC_LAYER)
+#define PROC_TL_DEBUG           (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_PROC_LAYER)
+
+#define API_TL_CATASTROPHE      (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define API_TL_SEVERE           (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_API_LAYER)
+#define API_TL_ERROR            (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_API_LAYER)
+#define API_TL_WARNING          (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_API_LAYER)
+#define API_TL_FUNC             (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_API_LAYER)
+#define API_TL_INFO             (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_API_LAYER)
+#define API_TL_VERBOSE          (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_API_LAYER)
+#define API_TL_DEBUG            (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_API_LAYER)
+
+#define APP_TL_CATASTROPHE      (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define APP_TL_SEVERE           (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_APPLICATION)
+#define APP_TL_ERROR            (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_APPLICATION)
+#define APP_TL_WARNING          (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_APPLICATION)
+#define APP_TL_FUNC             (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_APPLICATION)
+#define APP_TL_INFO             (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_APPLICATION)
+#define APP_TL_VERBOSE          (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_APPLICATION)
+#define APP_TL_DEBUG            (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_APPLICATION)
+
+#define TEST_TL_CATASTROPHE     (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_ANY)
+#define TEST_TL_SEVERE          (MEDIAIP_TRACE_LEVEL_ALWAYS | MEDIAIP_TRACE_TEST)
+#define TEST_TL_ERROR           (MEDIAIP_TRACE_LEVEL_6      | MEDIAIP_TRACE_TEST)
+#define TEST_TL_WARNING         (MEDIAIP_TRACE_LEVEL_5      | MEDIAIP_TRACE_TEST)
+#define TEST_TL_FUNC            (MEDIAIP_TRACE_LEVEL_4      | MEDIAIP_TRACE_TEST)
+#define TEST_TL_INFO            (MEDIAIP_TRACE_LEVEL_3      | MEDIAIP_TRACE_TEST)
+#define TEST_TL_VERBOSE         (MEDIAIP_TRACE_LEVEL_2      | MEDIAIP_TRACE_TEST)
+#define TEST_TL_DEBUG           (MEDIAIP_TRACE_LEVEL_1      | MEDIAIP_TRACE_TEST)
+
+#if RTOS != NONE
+#if OSAL == CNXT_KAL
+
+typedef MEDIAIP_TRACE_FLAGS CNXT_TRACE_FLAGS;
+
+#endif /* OSAL == CNXT_KAL */
+#endif /* RTOS != NOOS */
+
+#endif /* _TRACE_TYPES_H_ */
+
+
+/* End of file */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_linux_map.h b/drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_linux_map.h
new file mode 100755
index 0000000..8e65630
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_linux_map.h
@@ -0,0 +1,149 @@
+/***********************************************
+ * Copyright (c) 2015 Amphion Semiconductor Ltd *
+ ***********************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+ *
+ * Filename:        pal_linux_map.h
+ * Description:     Maps the abstraction layer type from the
+ *                  PAL to Linux defines, though a variation of CNXT KAL 
+ *						for implementing NXP PAL implementaiton layer
+ * Author:          Media IP FW team (Belfast)
+ *
+ ******************************************************************************
+ * $Id: 
+ ******************************************************************************/
+
+/* Note : At the moment I have done no real comparison and merge of the 
+          different abstarction layers supported in the PAL layer so this
+          file is simply a direct map - currently its only ftn is to 
+          remove compiler warnings and to get the code structure correct for
+          the future
+*/
+
+#ifndef _PAL_LINUX_MAP_H_
+#define _PAL_LINUX_MAP_H_
+
+#include "status_codes.h"
+
+/*******************/
+/* Resource Limits */
+/*******************/
+
+#if 0
+/* Maximum length of an OS object name string */
+#define PAL_MAX_OBJ_NAME_LENGTH   CNXT_KAL_MAX_OBJ_NAME_LENGTH
+#endif
+
+#define PAL_NO_WAIT               0
+#define PAL_WAIT_FOREVER          ((u_int32)-1)
+
+#if 0
+/* Macro to assign task priority based on RTOS */
+#define PAL_THREAD_PRIO(Prio, UCOS_Prio) CNXT_KAL_THREAD_PRIO(Prio, UCOS_Prio)
+         
+/* Task Priority Limits. */
+#define PAL_DEFAULT_PRIORITY    CNXT_KAL_DEFAULT_PRIORITY 
+#define PAL_MAX_THREAD_PRIORITY CNXT_KAL_MAX_THREAD_PRIORITY
+#define PAL_MIN_THREAD_PRIORITY CNXT_KAL_MIN_THREAD_PRIORITY
+#endif
+
+/* Object identifiers, KAL originated */
+typedef u_int32        CNXT_QUEUE_ID;
+typedef u_int32        CNXT_THREAD_ID;
+typedef u_int32        CNXT_SEM_ID;
+typedef u_int32        CNXT_MUTEX_ID;
+typedef u_int32        CNXT_POOL_ID;
+typedef u_int16        CNXT_EVENTS;
+typedef u_int32        CNXT_TICK_ID;
+typedef u_int32        CNXT_TIMER_ID;
+typedef bool           CNXT_CRIT_STATE;
+
+#define  PAL_QUEUE_ID   CNXT_QUEUE_ID    
+#define  PAL_THREAD_ID  CNXT_THREAD_ID 
+#define  PAL_SEM_ID     CNXT_SEM_ID    
+#define  PAL_POOL_ID    CNXT_POOL_ID   
+#define  PAL_EVENTS     CNXT_EVENTS    
+#define  PAL_TICK_ID    CNXT_TICK_ID   
+#define  PAL_TIMER_ID   CNXT_TIMER_ID  
+#define  PAL_CRIT_STATE CNXT_CRIT_STATE
+
+
+typedef enum
+{
+  PAL_CB_LOW_PRIORITY,
+  PAL_CB_LOW_PRIORITY_NO_BLOCK,
+  PAL_CB_HIGH_PRIORITY,
+  PAL_CB_HIGH_PRIORITY_NO_BLOCK,
+  PAL_CB_PRIORITY_LAST = PAL_CB_HIGH_PRIORITY_NO_BLOCK
+} PAL_CB_PRIORITY;
+
+#define PAL_PFNTHREAD         PFNTHREAD
+#define PAL_PFNISR            PFNISR
+#define PAL_PFNTHREADCALLBACK PFNTHREADCALLBACK
+typedef void             (*PFNTHREAD)(int, void **);
+typedef MEDIAIP_FW_STATUS (*PFNISR)(u_int32);
+typedef void             (*PFNTHREADCALLBACK)(u_int32, u_int32, void *);
+
+
+
+
+
+/*****************************************************************/
+/** PAL functions exporting OS abstraction layer functionality  **/
+/*****************************************************************/
+
+MEDIAIP_FW_STATUS pal_thread_create ( PAL_PFNTHREAD  pfnEntryPoint,
+                                      int            nArgC,
+                                      void           **ppArgV,
+                                      u_int32        uStackSize,
+                                      u_int8         uPrio,
+                                      const char     *pszName,
+                                      PAL_THREAD_ID  *pId );
+
+MEDIAIP_FW_STATUS pal_thread_terminate ( PAL_THREAD_ID *pId );
+
+MEDIAIP_FW_STATUS pal_make_async_thread_callback (
+                                                   PAL_PFNTHREADCALLBACK pfnCallback, 
+                                                   PAL_CB_PRIORITY Priority, 
+                                                   u_int32 uParam1, 
+                                                   u_int32 uParam2, 
+                                                   void *pData );
+                                                    
+
+                                                    
+
+////////////////////////////////////////////////////////////////////////////////
+// Semaphore functions
+////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS pal_sem_create (  u_int32 uInitialValue,
+		const char *pszName,
+		PAL_SEM_ID *pSem);                                                    
+                                                    
+////////////////////////////////////////////////////////////////////////////////
+// Queue functions
+////////////////////////////////////////////////////////////////////////////////
+
+MEDIAIP_FW_STATUS pal_qu_create ( unsigned int nMaxElements, 
+                                  const char *pszName, 
+                                  PAL_QUEUE_ID *pQuId );
+
+MEDIAIP_FW_STATUS pal_qu_destroy ( PAL_QUEUE_ID QuId );
+
+MEDIAIP_FW_STATUS pal_qu_send ( PAL_QUEUE_ID QuId, 
+                                void         *pMessage );
+
+MEDIAIP_FW_STATUS pal_qu_receive ( PAL_QUEUE_ID QuId, 
+                                   u_int32      uTimeoutMs, 
+                                   void         *pMessage );
+
+
+#endif /* _PAL_CNXT_KAL_MAP_H_ */
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_types.h b/drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_types.h
new file mode 100755
index 0000000..0177427
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/PAL/Incl/pal_types.h
@@ -0,0 +1,170 @@
+/***************************************************
+  Copyright (c) 2015 Amphion Semiconductor Ltd
+                All rights reserved.
+ ***************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+
+  Filename:        pal_types.h
+  Description:     Public header file for PAL type definitions
+                   Common between all platforms
+  Author:          Media IP FW team (Belfast)
+
+ ****************************************************/
+
+#ifndef _PAL_TYPES_H_
+#define _PAL_TYPES_H_
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Header Files
+/////////////////////////////////////////////////////////////////////////////////
+
+#include "basetype.h"
+#include "status_codes.h"
+#include "trace_types.h"
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Macros
+/////////////////////////////////////////////////////////////////////////////////
+
+// Define the magic cookie
+#define PAL_CONFIG_MAGIC        0x434C4150      // "PALC", little endian
+
+// Values for pal_trace_destination
+#define PAL_TRACE_TO_DEVNULL      0
+#define PAL_TRACE_TO_UART         1
+#define PAL_TRACE_TO_MESSAGE      2
+#define PAL_TRACE_TO_CIRCULARBUF  3
+
+#if ( TARGET_PLATFORM == GENTB_PLATFORM ) || ( TARGET_PLATFORM == WIN_LIB ) || ( TARGET_PLATFORM == GEN_TB_ENC )
+
+#define PAL_CONFIG_MAX_IRQS          0x12
+#define PAL_CONFIG_MAX_MALONES       0x2
+#define PAL_CONFIG_MAX_WINDSORS      0x1
+#define PAL_CONFIG_MAX_TIMER_IRQS    0x4
+#define PAL_CONFIG_MAX_TIMER_SLOTS   0x4
+
+/* Define the entry locations in the irq vector */
+#define PAL_IRQ_MALONE0_LOW      0x0
+#define PAL_IRQ_MALONE0_HI       0x1
+#define PAL_IRQ_MALONE1_LOW      0x2
+#define PAL_IRQ_MALONE1_HI       0x3
+#define PAL_IRQ_WINDSOR_LOW      0x4
+#define PAL_IRQ_WINDSOR_HI       0x5
+#define PAL_IRQ_HOST_CMD_LO      0x6
+#define PAL_IRQ_HOST_CMD_HI      0x7
+#define PAL_IRQ_HOST_MSG         0x9
+#define PAL_IRQ_DPV              0xA
+#define PAL_IRQ_TIMER_0          0xE
+#define PAL_IRQ_TIMER_1          0xF
+#define PAL_IRQ_TIMER_2          0x10
+#define PAL_IRQ_TIMER_3          0x11
+
+#else
+
+#define PAL_CONFIG_MAX_INITS    4               // Number of init slots
+#define PAL_CONFIG_MAX_IRQS     2               // Number of incoming irq lines supported
+
+#endif /* TARGET_PLATFORM == TB_PLATFORM */
+
+/////////////////////////////////////////////////////////////////////////////////
+//  Structure definitions
+/////////////////////////////////////////////////////////////////////////////////
+
+#if OSAL == NO_AL
+/* Function pointer types */
+typedef u_int32  PAL_TIMER_ID;
+typedef u_int32  PAL_CRIT_STATE;
+
+typedef MEDIAIP_IRQ_RETCODE (*PAL_PFNISR)(u_int32);
+typedef void                (*PAL_PFNTIMER)(PAL_TIMER_ID, void *);
+
+#endif
+
+typedef u_int32  PAL_PERF_ID;
+
+/////////////////////////////////////////////////////////////////////////////////
+//  PAL Configuration structure
+
+#if ( TARGET_PLATFORM == GENTB_PLATFORM ) || ( TARGET_PLATFORM == WIN_LIB ) || ( TARGET_PLATFORM == GEN_TB_ENC )
+
+typedef struct _PALConfig
+{
+  u_int32             uPalConfigMagicCookie;
+
+  u_int32             uGICBaseAddr;
+  u_int32             uIrqLines[PAL_CONFIG_MAX_IRQS];
+  u_int32             uIrqTarget[PAL_CONFIG_MAX_IRQS];
+
+  u_int32             uUartBaseAddr;
+
+  u_int32             uSysClkFreq;
+  u_int32             uNumTimers;
+  u_int32             uTimerBaseAddr;
+  u_int32             uTimerSlots[PAL_CONFIG_MAX_TIMER_SLOTS];
+
+  /* Do we need this in the PAL config? Only for checking mmu setup  */
+  /* perhaps - otherwise its more naturtal home is in the DECLIB_CFG */
+  /* structure                                                       */
+  u_int32             uNumMalones;
+  u_int32             uMaloneBaseAddr[PAL_CONFIG_MAX_MALONES];
+  u_int32             uHifOffset[PAL_CONFIG_MAX_MALONES];
+
+  u_int32             uNumWindsors;
+  u_int32             uWindsorBaseAddr[PAL_CONFIG_MAX_WINDSORS];
+
+  u_int32             uDPVBaseAddr;
+  u_int32             uPixIfAddr;
+
+  u_int32             pal_trace_level;
+//  u_int32             pal_trace_destination;
+//  u_int32             pal_trace_CBDescAddr[3];		// 3 separate circular buffers for PAL_TRACE_TO_CIRCULARBUF
+   						                                    // 0: normal  1: irq  2: fiq
+  u_int32             uHeapBase;
+  u_int32             uHeapSize;
+
+  u_int32             uFSLCacheBaseAddr;
+
+} sPALConfig, *psPALConfig;
+
+#else
+
+typedef struct _PALConfig
+{
+  u_int32             pal_config_magic_cookie;
+  u_int32             cmd_irq_line[PAL_CONFIG_MAX_IRQS];
+  u_int32             cmd_irq_clear_addr[PAL_CONFIG_MAX_INITS];
+  u_int32             cmd_irq_clear_mask[PAL_CONFIG_MAX_INITS];
+  u_int32             cmd_irq_clear_val[PAL_CONFIG_MAX_INITS];
+  u_int32             msg_irq_init_addr[PAL_CONFIG_MAX_INITS];
+  u_int32             msg_irq_init_mask[PAL_CONFIG_MAX_INITS];
+  u_int32             msg_irq_init_val[PAL_CONFIG_MAX_INITS];
+  u_int32             msg_irq_raise_addr;
+  u_int32             msg_irq_raise_mask;
+  u_int32             msg_irq_raise_val;
+  u_int32             uart_init_addr[PAL_CONFIG_MAX_INITS];
+  u_int32             uart_init_mask[PAL_CONFIG_MAX_INITS];
+  u_int32             uart_init_val[PAL_CONFIG_MAX_INITS];
+  u_int32             uart_check_addr;
+  u_int32             uart_check_mask;
+  u_int32             uart_check_val;
+  u_int32             uart_put_addr;
+  u_int32             pal_trace_level;
+  u_int32             pal_trace_destination;
+  MEDIAIP_TRACE_FLAGS pal_trace_flags;         // Currently 5 words
+  u_int32             pal_trace_CBDescAddr[3];		// 3 separate circular buffers for PAL_TRACE_TO_CIRCULARBUF
+   						                                    // 0: normal  1: irq  2: fiq
+} sPALConfig, *psPALConfig;
+
+#endif /*  TARGET_PLATFORM == TB_PLATFORM */
+
+
+#endif /* _PAL_TYPES_H_ */
+
+
+/* End of File */
diff --git a/drivers/mxc/vpu-malone/Malone_Firmware/PAL/pal.c b/drivers/mxc/vpu-malone/Malone_Firmware/PAL/pal.c
new file mode 100755
index 0000000..ae7f21e
--- /dev/null
+++ b/drivers/mxc/vpu-malone/Malone_Firmware/PAL/pal.c
@@ -0,0 +1,772 @@
+/***************************************************
+ *   Copyright (c) 2015 Amphion Semiconductor Ltd
+ *   All rights reserved.
+ ****************************************************
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ ****************************************************
+ *
+ *   Filename    :    pal.c
+ *   Description :    Code implementing Platform Abstraction Layer
+ *         
+ *   Author      :    Media IP FW team (Belfast)
+ *
+ ****************************************************/
+
+/////////////////////////////////////////////////////////////////////////////////
+////  Header Files
+///////////////////////////////////////////////////////////////////////////////////
+
+#ifndef VPU_KERNEL_BUILD
+#include <string.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/errno.h>
+#include "VPU_io.h"
+#else
+#undef ARM
+#undef SUCCESS
+#include <linux/io.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+
+#endif
+#include "pal.h"
+#include "VPU_regdef.h"
+#include "VPU_debug.h"
+#include "mvd.h"
+
+
+///////////////////////////////////////////////////////////////////////////////////
+////  External Function Prototypes
+///////////////////////////////////////////////////////////////////////////////////
+
+// The function declared in pal.h is set to be empty 
+// and need to be defined later
+
+//volatile u_int32    guPlayerFlag[MEDIA_PLAYER_NUM_STREAMS];
+
+#ifdef VPU_KERNEL_BUILD
+extern void __iomem *vpu_base;
+#define VPU_REG_WR(reg, val) writel(val, vpu_base + reg)
+#define VPU_REG_RD(reg) readl(vpu_base + reg)
+#else
+#define VPU_REG_WR(reg, val) VpuWriteReg(reg, val)
+#define VPU_REG_RD(reg) VpuReadReg(reg)
+#endif
+
+PAL_PFNISR int_handlers[INT_ID_MAX];
+
+#ifdef ENABLE_CRIT_SECTIONS
+static int ulCriticalNesting = 0;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////////////
+// Assert function, implementation to be defined but we want to use this to trap logical errors
+//
+bool gbAssertExit = FALSE;
+void pal_assert_impl(u_int32 uAssertPC, u_int32 uAssertInfo)
+{
+	/* AssertInfo could be the offset address of the calling function or something else? */
+	while(gbAssertExit==FALSE)
+	{
+		/* wait to allow debug */
+	}
+}
+
+
+MEDIAIP_FW_STATUS pal_critical_section_begin ( PAL_CRIT_STATE *pState )
+{
+#ifdef ENABLE_CRIT_SECTIONS
+	//ENTER_FUNC();
+	if(ulCriticalNesting>0)
+	  dprintf(LVL_FUNC, "Nested %d\n", ulCriticalNesting);
+	// FIXME: might need MFD_HIF_MSD_REG_HOST_INTERRUPT_ENABLE 0x1000
+	*pState = VPU_REG_RD((DEC_MFD_XREG_SLV_BASE + MFD_HIF + MFD_HIF_MSD_REG_FAST_INTERRUPT_ENABLE));
+	VPU_REG_WR((DEC_MFD_XREG_SLV_BASE + MFD_HIF + MFD_HIF_MSD_REG_FAST_INTERRUPT_ENABLE), *pState & ~0x20);
+	//dprintf(LVL_FUNC, "save to State 0x%lx, expect 0x20 outside irq or 0 inside irq\n", *pState);
+	ulCriticalNesting++;
+#endif
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_critical_section_end ( PAL_CRIT_STATE PreviousState )
+{
+#ifdef ENABLE_CRIT_SECTIONS
+	ulCriticalNesting--;
+	//ENTER_FUNC();
+	//dprintf(LVL_FUNC, "Nest %d\n", ulCriticalNesting);
+	//dprintf(LVL_FUNC, "restore from State 0x%lx, expect 0x20 outside irq or 0 inside irq\n", PreviousState);
+	VPU_REG_WR((DEC_MFD_XREG_SLV_BASE + MFD_HIF + MFD_HIF_MSD_REG_FAST_INTERRUPT_ENABLE), PreviousState);
+#endif  
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_int_register ( u_int32     dwIntID,
+		PAL_PFNISR  pfnHandler,
+		BOOL        bFIQ )
+{
+	ENTER_FUNC();
+	if (pfnHandler == NULL)
+		return MEDIAIP_FW_STATUS_BAD_PARAMETER;
+
+	if (dwIntID == PAL_IRQ_MALONE0_LOW) {
+		int_handlers[INT_ID_MALONE_LOW] = pfnHandler;
+	} else if (dwIntID == PAL_IRQ_MALONE0_HI) {
+		int_handlers[INT_ID_MALONE_HI] = pfnHandler;
+	} else {
+		err_msg("wrong dwIntID 0x%x\n", dwIntID);
+		return MEDIAIP_FW_STATUS_INT_NOT_HANDLED;
+	}
+	dprintf(LVL_FUNC, "pal pfnHandler 0x%p\n", pfnHandler);
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+
+MEDIAIP_FW_STATUS pal_int_enable ( u_int32 dwIntID )
+{
+	ENTER_FUNC();
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+void pal_int_set ( u_int32 dwIntID )
+{
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "dwIntID %d\n", dwIntID);
+
+	if (dwIntID != PAL_IRQ_MALONE0_LOW) {
+		err_msg("ERROR: not PAL_IRQ_MALONE0_LOW!!!\n");
+		EXIT_FUNC();
+		return;
+	}
+
+	VPU_REG_WR((DEC_MFD_XREG_SLV_BASE + MFD_SIF + MFD_SIF_INTR_FORCE), 0x100);
+
+	EXIT_FUNC();
+}
+
+void pal_int_clear ( u_int32 dwIntID,
+		BOOL    bDirect )
+{
+	ENTER_FUNC();
+}
+
+MEDIAIP_FW_STATUS pal_int_get_irq_line ( u_int32 uFWIrq,
+		u_int32 *puIrqLine )
+{
+	ENTER_FUNC();
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_memcpy ( void *pDest,
+		const void *pSrc,
+		u_int32 uSize )
+{
+	ENTER_FUNC();
+	if (pDest == NULL || pSrc == NULL)
+		return MEDIAIP_FW_STATUS_BAD_PARAMETER;
+
+	memcpy(pDest, pSrc, uSize);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+void pal_memset ( void *pDest, int32 nChar, u_int32 uCount )
+{
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "pDest 0x%p, nChar %d, uCount %d\n", pDest, nChar, uCount);
+	if (pDest == NULL)
+		return;
+
+	memset(pDest, nChar, uCount);
+}
+
+BOOL pal_memcompare ( void *pArea1, void *pArea2, u_int32 uSizeInWords )
+{
+	u_int32 i;
+	u_int32 *ptr0, *ptr1;
+	u_int32 uChange;
+
+	ENTER_FUNC();
+	if (pArea1 == NULL || pArea2 == NULL)
+		return FALSE;
+
+	ptr0 = ( u_int32 * ) pArea1;
+	ptr1 = ( u_int32 * ) pArea2;
+
+	for ( i = 0, uChange = 0; ( i < uSizeInWords ) && ( uChange == 0 ); i++ )
+	{
+		if ( ptr0[i] != ptr1[i] )
+		{
+			uChange = 1;
+		}
+	}
+
+	return ( uChange ) ? TRUE : FALSE;
+}
+
+MEDIAIP_FW_STATUS pal_timer_create ( PAL_PFNTIMER     pfnCallback,
+		void *           pUserData,
+		PAL_TIMER_ID *   pTimer )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_timer_destroy( PAL_TIMER_ID Timer )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    pal_memalloc                                                 //
+//                                                                            //
+//  DESCRIPTION:                                                              //
+//     allocates size bytes and returns a pointer to the allocated  memory.   //
+//     The memory is not cleared.                                             //
+//                                                                            //
+//  INPUT PARAMETERS:                                                         //
+//     uSize      - Size of memory in bytes to alloc                          //
+//                                                                            //
+//  OUTPUT PARAMETERS:                                                        //
+//                                                                            //
+//  RETURN VALUES:                                                            //
+//                                                                            //
+//  NOTES:                                                                    //
+//                                                                            //
+//  CONTEXT:                                                                  //
+//     This function may be called from any context                           //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+#ifndef VPU_KERNEL_BUILD
+
+void * pal_memalloc ( size_t uSize )
+{
+  void * pPtr = malloc ( uSize );
+  
+  return pPtr;
+}
+#endif
+////////////////////////////////////////////////////////////////////////////////
+//  FUNCTION:    pal_memfree                                                  //
+//                                                                            //
+//  DESCRIPTION:                                                              //
+//     frees the memory space pointed to by ptr, which must have been         //
+//     returned by a previous call to malloc(), calloc() or realloc().        // 
+//     Otherwise, or if free(ptr) has already  been called before, undefined  //
+//     behaviour occurs. If ptr is NULL, no operation is performed.           //
+//                                                                            //
+//                                                                            //
+//  INPUT PARAMETERS:                                                         //
+//     pPtr      - Pointer to memory to free                                  //
+//                                                                            //
+//  OUTPUT PARAMETERS:                                                        //
+//                                                                            //
+//  RETURN VALUES:                                                            //
+//                                                                            //
+//  NOTES:                                                                    //
+//                                                                            //
+//  CONTEXT:                                                                  //
+//     This function may be called from any context                           //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+#ifndef VPU_KERNEL_BUILD
+
+void pal_memfree ( void * pPtr )
+{
+  free ( pPtr );
+}
+#endif
+u_int32 pal_find_highest_bit ( u_int32 uValue )
+{
+	u_int32 mask = 0x80000000;
+	u_int32 ret = 31;
+
+	ENTER_FUNC();
+
+	while (mask && ((uValue & mask) == 0)) {
+		mask >>= 1;
+		ret--;
+	}
+
+	return ret;
+}
+
+MEDIAIP_FW_STATUS pal_perf_counter_create ( const char *  pszName,
+		PAL_PERF_ID * pPCId )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_perf_counter_destroy ( PAL_PERF_ID PCId )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_perf_counter_start ( PAL_PERF_ID PCId )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+
+MEDIAIP_FW_STATUS pal_perf_counter_pause_control ( PAL_PERF_ID PCId , bool bStartPause)
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_perf_counter_read ( PAL_PERF_ID PerfId,
+		u_int32 *   puCountVal )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_malone_clock_reg_init ( void )
+{
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+static void mfd_clock_enable(unsigned int mask, bool bEnable)
+{
+	if (bEnable)
+		VPU_REG_WR((DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL + MFD_BLK_CTRL_MFD_SYS_CLOCK_ENABLE_SET), mask);
+	else
+		VPU_REG_WR((DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL + MFD_BLK_CTRL_MFD_SYS_CLOCK_ENABLE_CLR), mask);
+}
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_common ( bool bEnable )
+{
+	ENTER_FUNC();
+	mfd_clock_enable(0x10, bEnable);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_avc ( bool bEnable )
+{
+	ENTER_FUNC();
+	mfd_clock_enable(0x1, bEnable);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_vc1 ( bool bEnable )
+{
+	ENTER_FUNC();
+	mfd_clock_enable(0x2, bEnable);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_mpg ( bool bEnable )
+{
+	ENTER_FUNC();
+	mfd_clock_enable(0x4, bEnable);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_malone_clock_enable_avs ( bool bEnable )
+{
+	ENTER_FUNC();
+	mfd_clock_enable(0x8, bEnable);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+u_int32 pal_get_target_version ( void )
+{
+	return 0;
+}
+
+#ifndef VPU_KERNEL_BUILD
+MEDIAIP_FW_STATUS pal_get_phy_buf(psPALMemDesc pbuf)
+{
+	vpu_mem_desc mem_desc = {0};
+	int ret;
+
+	ENTER_FUNC();
+
+	mem_desc.size = pbuf->size;
+	ret = IOGetPhyMem(&mem_desc);
+	if (ret) {
+		err_msg("Unable to obtain physical mem\n");
+		return MEDIAIP_FW_STATUS_RESOURCE_ERROR;
+	}
+
+	if (IOGetVirtMem(&mem_desc) == -1) {
+		err_msg("Unable to obtain virtual mem\n");
+		IOFreePhyMem(&mem_desc);
+		return MEDIAIP_FW_STATUS_RESOURCE_ERROR;
+	}
+
+	pbuf->phy_addr = mem_desc.phy_addr;
+	pbuf->virt_addr = mem_desc.virt_uaddr;
+#ifdef USE_ION
+	pbuf->ion_buf_fd = mem_desc.ion_buf_fd;
+#endif
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_free_phy_buf(psPALMemDesc pbuf)
+{
+	vpu_mem_desc mem_desc = {0};
+
+	ENTER_FUNC();
+
+	mem_desc.size = pbuf->size;
+	mem_desc.phy_addr = pbuf->phy_addr;
+	mem_desc.virt_uaddr = pbuf->virt_addr;
+#ifdef USE_ION
+	mem_desc.ion_buf_fd = pbuf->ion_buf_fd;
+#endif
+
+	IOFreeVirtMem(&mem_desc);
+	IOFreePhyMem(&mem_desc);
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+#endif
+
+u_int32 pal_va2pa ( u_int32 * pAddr )
+{
+	/* CAUTION: pAddr shall be physical address already*/
+	dprintf(LVL_FUNC, "pAddr 0x%p shall be physical!!!\n", pAddr);
+	return (u_int32)(uint_addr)pAddr;
+}
+
+u_int32 * pal_return_uncached_addr ( u_int32 * puAddress )
+{
+	dprintf(LVL_FUNC, "puAddress 0x%p\n", puAddress);
+	return puAddress;
+}
+
+u_int32 * pal_return_cacheable_addr ( u_int32 * puAddress )
+{
+	dprintf(LVL_FUNC, "puAddress 0x%p\n", puAddress);
+	return puAddress;
+}
+
+u_int32 pal_read_uncached ( u_int32 * puAddress )
+{
+	dprintf(LVL_FUNC, "puAddress 0x%p\n", puAddress);
+
+	if (puAddress == NULL)
+		return MEDIAIP_FW_STATUS_BAD_PARAMETER;
+
+	return (*puAddress);
+}
+
+int pal_vsnprintf ( char *str, int size, const char *format, va_list args )
+{
+	ENTER_FUNC();
+	return 0;
+}
+
+int pal_sprintf ( char *str, int size, const char *psz_format, ...)
+{
+	ENTER_FUNC();
+	return 0;
+}
+
+static void mfd_cache_clock_enable(unsigned int enable)
+{
+	ENTER_FUNC();
+	VPU_REG_WR((SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL + SCB_BLK_CTRL_SCB_CLK_ENABLE_SET),enable);
+}
+
+void pal_set_malone_cache ( u_int32 uMalID )
+{
+	ENTER_FUNC();
+	mfd_cache_clock_enable(0xE);
+}
+
+#define MAX_QUEUE_NUM 10
+static PAL_QUEUE_ID gQuId = 0;
+
+MEDIAIP_FW_STATUS pal_sem_create (  u_int32 uInitialValue,
+		const char *pszName,
+		PAL_SEM_ID *pSem)
+{
+	/* CAUTION: if in use */
+	ENTER_FUNC();
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+#ifdef VPU_KERNEL_BUILD
+
+static struct kfifo irq_fifo[MAX_QUEUE_NUM];
+static spinlock_t irq_lock[MAX_QUEUE_NUM];
+static struct task_struct *msg_thread;
+static wait_queue_head_t irq_wq[MAX_QUEUE_NUM];
+
+MEDIAIP_FW_STATUS pal_thread_create ( PAL_PFNTHREAD  pfnEntryPoint,
+		int        nArgC,
+		void       **ppArgV,
+		u_int32    uStackSize,
+		u_int8     uPrio,
+		const char *pszName,
+		PAL_THREAD_ID  *pId )
+{
+	typedef int (*INTFUNC)(void *);
+
+	/* CAUTION: shall not enter twice due to global msg_thread */
+	ENTER_FUNC();
+	//struct task_struct *msg_thread;
+	msg_thread = kthread_run((INTFUNC)pfnEntryPoint , NULL, pszName);
+	if(IS_ERR( msg_thread ))
+		return MEDIAIP_FW_STATUS_FAILURE;
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_thread_terminate ( PAL_THREAD_ID *pId )
+{
+	ENTER_FUNC();
+
+	kthread_stop(msg_thread);
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_create ( unsigned int nMaxElements,
+		const char *pszName,
+		PAL_QUEUE_ID *pQuId )
+{
+	/* CAUTION: message length shall be 4 * sizeof(uint_addr) */
+	ENTER_FUNC();
+	*pQuId = gQuId;
+	spin_lock_init(&irq_lock[*pQuId]);
+	init_waitqueue_head(&irq_wq[*pQuId]);
+	if(kfifo_alloc(&irq_fifo[*pQuId],
+				nMaxElements * 4 * sizeof(uint_addr),
+				GFP_KERNEL))
+	{
+		err_msg("fail to alloc fifo in pal\n");
+		return MEDIAIP_FW_STATUS_FAILURE;
+	}
+
+	gQuId++;
+	if( MAX_QUEUE_NUM == gQuId)
+		gQuId=0;
+	dprintf(LVL_FUNC, "create QuId:%d\n",
+			*pQuId
+			);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_destroy ( PAL_QUEUE_ID QuId )
+{
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "destory QuId:%d\n",
+			QuId
+			);
+	kfifo_free(&irq_fifo[QuId]);
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_send ( PAL_QUEUE_ID QuId,
+		void         *pMessage)
+{
+	u_int32 retval;
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "QuId %d\n", QuId);
+
+	/* CAUTION: if message is not 4 * sizeof(uint_addr) */
+	retval = kfifo_in_locked(&irq_fifo[QuId], pMessage, 4 * sizeof(uint_addr),&irq_lock[QuId]);
+	dprintf(LVL_FUNC, "message send: 0x%llx, 0x%llx, 0x%llx, 0x%llx\n", *(uint_addr *)pMessage, *((uint_addr *)pMessage+1), *((uint_addr *)pMessage+2), *((uint_addr *)pMessage+3));
+	if(retval != 4*sizeof(uint_addr))
+		return MEDIAIP_FW_STATUS_FAILURE;
+	wake_up(&irq_wq[QuId]);
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_receive ( PAL_QUEUE_ID QuId,
+		u_int32      uTimeoutMs,
+		void         *pMessage )
+{
+	u_int32 retval;
+
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "QuId %d\n", QuId);
+/*	while (kfifo_len(&irq_fifo) < sizeof(*pMessage)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();
+	}*/
+	if(!wait_event_interruptible_timeout(irq_wq[QuId],
+			kfifo_len(&irq_fifo[QuId])>=4*sizeof(uint_addr)
+			/* || kthread_should_stop() */,
+			//uTimeoutMs
+			msecs_to_jiffies(uTimeoutMs)
+			))
+	{
+		dprintf(LVL_FUNC, "timeout %d ms\n", uTimeoutMs);
+		return MEDIAIP_FW_STATUS_TIMEOUT;
+	}
+	//if(kthread_should_stop())
+	//	return MEDIAIP_FW_STATUS_STOPPED;
+
+	if (kfifo_len(&irq_fifo[QuId])>=4*sizeof(uint_addr))
+	{
+		retval = kfifo_out_locked(&irq_fifo[QuId], pMessage, 4*sizeof(uint_addr),&irq_lock[QuId]);
+		dprintf(LVL_FUNC, "message receive: 0x%llx, 0x%llx, 0x%llx, 0x%llx\n", *(uint_addr *)pMessage, *((uint_addr *)pMessage+1), *((uint_addr *)pMessage+2), *((uint_addr *)pMessage+3));
+	}
+	else
+	{
+		dprintf(LVL_FUNC, "ERROR interrupted by a signal!!\n");
+	}
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+#else
+
+#define FN_MSG_FIFO "/dev/shm/vpu_msg_fifo"
+static char fn_fifo[MAX_QUEUE_NUM][64] = {0};
+static int fd_send[MAX_QUEUE_NUM] = {0};
+static int fd_receive[MAX_QUEUE_NUM] = {0};
+
+MEDIAIP_FW_STATUS pal_thread_create ( PAL_PFNTHREAD  pfnEntryPoint,
+		int        nArgC,
+		void       **ppArgV,
+		u_int32    uStackSize,
+		u_int8     uPrio,
+		const char *pszName,
+		PAL_THREAD_ID  *pId )
+{
+	int err;
+	pthread_t msg_tid;
+
+	ENTER_FUNC();
+	err = pthread_create(&msg_tid, NULL, (void *)pfnEntryPoint, NULL);
+	if (err)
+		return MEDIAIP_FW_STATUS_FAILURE;
+
+	*pId = msg_tid;
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_thread_terminate ( PAL_THREAD_ID *pId )
+{
+	pthread_t msg_tid = *pId;
+
+	ENTER_FUNC();
+
+	if (msg_tid == 0)
+		return MEDIAIP_FW_STATUS_BAD_PARAMETER;
+
+	pthread_cancel(msg_tid);
+	pthread_join(msg_tid, NULL);
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_create ( unsigned int nMaxElements,
+		const char *pszName,
+		PAL_QUEUE_ID *pQuId )
+{
+	/* CAUTION: message length shall be 4 * sizeof(uint_addr) */
+	ENTER_FUNC();
+	*pQuId = gQuId;
+	sprintf(fn_fifo[gQuId], "%s%d", FN_MSG_FIFO, gQuId);
+	if(access(fn_fifo[gQuId], F_OK) == -1)
+	{
+		if(mkfifo(fn_fifo[gQuId], 0777))
+		{
+			err_msg("failed to alloc fifo %s in pal\n", fn_fifo[gQuId]);
+			return MEDIAIP_FW_STATUS_FAILURE;
+		}
+		dprintf(LVL_FUNC, "created fifo %s\n", fn_fifo[gQuId]);
+	} else {
+		dprintf(LVL_FUNC, "exist fifo %s\n", fn_fifo[gQuId]);
+	}
+
+	gQuId++;
+	if( MAX_QUEUE_NUM == gQuId)
+		gQuId=0;
+	dprintf(LVL_FUNC, "create QuId:%d\n",
+			*pQuId
+			);
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_destroy ( PAL_QUEUE_ID QuId )
+{
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "destory QuId:%d\n",
+			QuId
+			);
+	if (fd_send[QuId]) {
+		close(fd_send[QuId]);
+		fd_send[QuId] = 0;
+	}
+	if (fd_receive[QuId]) {
+		close(fd_receive[QuId]);
+		fd_receive[QuId] = 0;
+	}
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_send ( PAL_QUEUE_ID QuId,
+		void         *pMessage)
+{
+	u_int32 retval;
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "QuId %d\n", QuId);
+
+	/* CAUTION: if message is not 4 * sizeof(uint_addr) */
+	if (fd_send[QuId] == 0) {
+		fd_send[QuId] = open(fn_fifo[QuId], O_WRONLY);
+		if (fd_send[QuId] == -1) {
+			err_msg("failed to open fifo %s to send\n", fn_fifo[QuId]);
+			return MEDIAIP_FW_STATUS_FAILURE;
+		} else {
+			dprintf(LVL_FUNC, "opened fifo %s to send\n", fn_fifo[QuId]);
+		}
+	}
+	retval = write(fd_send[QuId], pMessage, 4 * sizeof(uint_addr));
+	if(retval != 4*sizeof(uint_addr))
+	{
+		err_msg("%s\n", strerror(errno));
+		return MEDIAIP_FW_STATUS_FAILURE;
+	}
+	dprintf(LVL_FUNC, "message send: 0x%lx, 0x%lx, 0x%lx, 0x%lx\n", *(uint_addr *)pMessage, *((uint_addr *)pMessage+1), *((uint_addr *)pMessage+2), *((uint_addr *)pMessage+3));
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+
+MEDIAIP_FW_STATUS pal_qu_receive ( PAL_QUEUE_ID QuId,
+		u_int32      uTimeoutMs,
+		void         *pMessage )
+{
+	u_int32 retval;
+
+	ENTER_FUNC();
+	dprintf(LVL_FUNC, "QuId %d\n", QuId);
+	// TODO: time out case
+	if (fd_receive[QuId] == 0) {
+		fd_receive[QuId] = open(fn_fifo[QuId], O_RDONLY);
+		if (fd_receive[QuId] == -1) {
+			err_msg("failed to open fifo %s to receive\n", fn_fifo[QuId]);
+			return MEDIAIP_FW_STATUS_FAILURE;
+		} else {
+			dprintf(LVL_FUNC, "opened fifo %s to receive\n", fn_fifo[QuId]);
+		}
+	}
+	retval = read(fd_receive[QuId], pMessage, 4*sizeof(uint_addr));
+	if(retval != 4*sizeof(uint_addr))
+	{
+		err_msg("%s\n", strerror(errno));
+		return MEDIAIP_FW_STATUS_FAILURE;
+	}
+	dprintf(LVL_FUNC, "message receive: 0x%lx, 0x%lx, 0x%lx, 0x%lx\n", *(uint_addr *)pMessage, *((uint_addr *)pMessage+1), *((uint_addr *)pMessage+2), *((uint_addr *)pMessage+3));
+
+	return MEDIAIP_FW_STATUS_OK;
+}
+#endif
+
diff --git a/drivers/mxc/vpu-malone/VPU_debug.h b/drivers/mxc/vpu-malone/VPU_debug.h
new file mode 100755
index 0000000..1b2fd26
--- /dev/null
+++ b/drivers/mxc/vpu-malone/VPU_debug.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2017 NXP
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file vpu_debug.h
+ *
+ * @brief VPU debug definition
+ *
+ * @ingroup VPU
+ */
+
+#ifndef __VPU_DEBUG_H
+#define __VPU_DEBUG_H
+
+
+
+#define LVL_NOPRINT 0
+#define LVL_ISR 2
+#define LVL_CRI 3
+#define LVL_FUNC 5
+#define LVL_PRINTALL 10
+
+
+
+#ifdef VPU_KERNEL_BUILD
+
+#include <linux/io.h>
+
+//#define vpu_lib_dbg_level LVL_PRINTALL
+
+#define vpu_lib_dbg_level LVL_NOPRINT
+
+#define err_msg(fmt, arg...) do { if (vpu_lib_dbg_level > LVL_NOPRINT) \
+	printk("[ERR]\t%s:%d " fmt,  __FILE__, __LINE__, ## arg); else \
+	printk("[ERR]\t" fmt, ## arg); \
+	} while (0)
+#define info_msg(fmt, arg...) do { if (vpu_lib_dbg_level > LVL_NOPRINT) \
+	printk("[INFO]\t%s:%d " fmt,  __FILE__, __LINE__, ## arg); else \
+	printk("[INFO]\t" fmt, ## arg); \
+	} while (0)
+#define warn_msg(fmt, arg...) do { if (vpu_lib_dbg_level > LVL_NOPRINT) \
+	printk("[WARN]\t%s:%d " fmt,  __FILE__, __LINE__, ## arg); else \
+	printk("[WARN]\t" fmt, ## arg); \
+	} while (0)
+
+#define dprintf(level, fmt, arg...) do {if (level <= vpu_lib_dbg_level) printk("[DEBUG]\t%s " fmt, __FUNCTION__, ## arg);} while(0)
+
+
+
+#define ENTER_FUNC() dprintf(LVL_FUNC, "enter %s()\n", __func__)
+#define EXIT_FUNC() dprintf(LVL_FUNC, "exit %s()\n", __func__)
+
+#else
+
+#include <stdio.h>
+
+#include "VPU_lib.h"
+
+
+//#define vpu_lib_dbg_level LVL_PRINTALL
+
+#define vpu_lib_dbg_level LVL_CRI
+
+#define err_msg(fmt, arg...) do { if (vpu_lib_dbg_level > LVL_NOPRINT) \
+	printf("[ERR]\t%s:%d " fmt,  __FILE__, __LINE__, ## arg); else \
+	printf("[ERR]\t" fmt, ## arg); \
+	} while (0)
+#define info_msg(fmt, arg...) do { if (vpu_lib_dbg_level > LVL_NOPRINT) \
+	printf("[INFO]\t%s:%d " fmt,  __FILE__, __LINE__, ## arg); else \
+	printf("[INFO]\t" fmt, ## arg); \
+	} while (0)
+#define warn_msg(fmt, arg...) do { if (vpu_lib_dbg_level > LVL_NOPRINT) \
+	printf("[WARN]\t%s:%d " fmt,  __FILE__, __LINE__, ## arg); else \
+	printf("[WARN]\t" fmt, ## arg); \
+	} while (0)
+
+//#define dprintf(level, fmt, arg...) do {if (level <= vpu_lib_dbg_level) printf("[DEBUG]\t%s " fmt, __FUNCTION__, ## arg);} while(0)
+#define dprintf(level, fmt, arg...) do { if (vpu_lib_dbg_level >= level) printf("[DEBUG]\t%s:%d " fmt, __FILE__, __LINE__, ## arg); } while (0)
+
+#define ENTER_FUNC() dprintf(LVL_FUNC, "enter %s()\n", __func__)
+#define EXIT_FUNC() dprintf(LVL_FUNC, "exit %s()\n", __func__)
+
+#endif
+
+#endif
diff --git a/drivers/mxc/vpu-malone/VPU_regdef.h b/drivers/mxc/vpu-malone/VPU_regdef.h
new file mode 100755
index 0000000..7408009
--- /dev/null
+++ b/drivers/mxc/vpu-malone/VPU_regdef.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// vpu_regdef.h
+//
+// Description: 
+//
+// Register definition
+//
+// Authors:
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef __VPU_REGDEF_H__
+#define __VPU_REGDEF_H__
+
+#define SCB_XREG_SLV_BASE                               0x00000000
+#define SCB_SCB_BLK_CTRL                                0x00070000
+#define SCB_BLK_CTRL_XMEM_RESET_SET                     0x00000090
+#define SCB_BLK_CTRL_CACHE_RESET_SET                    0x000000A0
+#define SCB_BLK_CTRL_CACHE_RESET_CLR                    0x000000A4
+#define SCB_BLK_CTRL_SCB_CLK_ENABLE_SET                 0x00000100
+
+#define XMEM_CONTROL                                    0x00041000
+
+#define DEC_MFD_XREG_SLV_BASE                           0x00180000
+
+#define MFD_HIF                                         0x0001C000
+#define MFD_HIF_MSD_REG_HOST_INTERRUPT_ENABLE           0x00000014
+#define MFD_HIF_MSD_REG_INTERRUPT_STATUS                0x00000018
+#define MFD_HIF_MSD_REG_FAST_INTERRUPT_ENABLE           0x0000001C
+#define MFD_SIF                                         0x0001D000
+#define MFD_SIF_CTRL_STATUS                             0x000000F0
+#define MFD_SIF_INTR_STATUS                             0x000000F4
+#define MFD_SIF_INTR_FORCE                              0x000000F8
+#define MFD_MCX                                         0x00020800
+
+#define MFD_BLK_CTRL                                    0x00030000
+#define MFD_BLK_CTRL_MFD_SYS_RESET_SET                  0x00000000
+#define MFD_BLK_CTRL_MFD_SYS_RESET_CLR                  0x00000004
+#define MFD_BLK_CTRL_MFD_SYS_CLOCK_ENABLE_SET           0x00000100
+#define MFD_BLK_CTRL_MFD_SYS_CLOCK_ENABLE_CLR           0x00000104
+
+#endif //__VPU_REGDEF_H__
diff --git a/drivers/mxc/vpu-malone/mxc_vpu-malone.c b/drivers/mxc/vpu-malone/mxc_vpu-malone.c
new file mode 100755
index 0000000..e5a4825
--- /dev/null
+++ b/drivers/mxc/vpu-malone/mxc_vpu-malone.c
@@ -0,0 +1,1205 @@
+/*
+ * Copyright 2017 NXP
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_vpu-malone.c
+ *
+ * @brief VPU system initialization and file operation implementation
+ *
+ * @ingroup VPU
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/stat.h>
+#include <linux/platform_device.h>
+#include <linux/kdev_t.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/fsl_devices.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/regulator/consumer.h>
+#include <linux/page-flags.h>
+#include <linux/mm_types.h>
+#include <linux/types.h>
+#include <linux/memblock.h>
+#include <linux/memory.h>
+#include <linux/version.h>
+#include <asm/page.h>
+
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sizes.h>
+
+#include <linux/busfreq-imx.h>
+#include <linux/clk.h>
+#include <linux/genalloc.h>
+#include <linux/mxc_vpu-malone.h>
+#include <linux/of.h>
+#include <linux/reset.h>
+
+#include <soc/imx8/sc/svc/pm/api.h>
+#include <soc/imx8/sc/ipc.h>
+
+#include "VPU_regdef.h"
+#include "pal.h"
+#include "mvd.h"
+#include "DecKernelLib.h"
+
+struct vpu_priv {
+	struct fasync_struct *async_queue;
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
+	struct mutex lock;
+};
+
+/* To track the allocated memory buffer */
+struct memalloc_record {
+	struct list_head list;
+	struct vpu_mem_desc mem;
+};
+
+static LIST_HEAD(head);
+
+static int vpu_major;
+static struct class *vpu_class;
+static struct vpu_priv vpu_data;
+static u8 open_count;
+static struct clk *vpu_clk;
+static struct vpu_mem_desc share_mem = { 0 };
+static struct vpu_mem_desc vshare_mem = { 0 };
+
+void __iomem *vpu_base;
+static u32 phy_vpu_base_addr;
+static int vpu_dec_irq;
+static int vpu_dec_fiq;
+
+static struct device *vpu_dev;
+
+/* implement the blocking ioctl */
+static int irq_status;
+static wait_queue_head_t vpu_queue;
+
+static int vpu_clk_usercount;
+static atomic_t clk_cnt_from_ioc = ATOMIC_INIT(0);
+
+static sc_ipc_t ipcHndl;
+
+#define ISR_EVENT_QU_SIZE 64
+
+static PAL_QUEUE_ID gIsrEventQu;
+static DECODER_KERNEL_LIB_ISR_EVENT_DATA gIsrEventData[ISR_EVENT_QU_SIZE];
+static u32 uIsrEventQuWrIdx = 0;
+static DECODERLIB_KERNEL_CFG gtKernelCfg;
+
+#define	READ_REG(x)		readl_relaxed(vpu_base + x)
+#define	WRITE_REG(val, x)	writel_relaxed(val, vpu_base + x)
+
+static void vpu_reset(void)
+{
+#if 0
+	int ret;
+
+	ret = device_reset(vpu_dev);
+#endif
+}
+
+/*!
+ * Private function to change the power mode of VPU to pm
+ * @return status  0 success.
+ */
+static int setVPUPwr(sc_ipc_t ipcHndl,
+                     sc_pm_power_mode_t pm
+                     )
+{
+	int rv = -1;
+	sc_err_t sciErr;
+
+	dev_dbg(vpu_dev, "enter %s()\n", __FUNCTION__);
+	if (!ipcHndl)
+	{
+		dev_err(vpu_dev, "--- setVPUPwr no IPC handle\n");
+		goto setVPUPwrExit;
+	}
+
+	/* Power on or off PID0, DEC, ENC */
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID0, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID0,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	/* FIXME: no need of PID1-7? */
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID1, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID1,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl,SC_R_VPU_PID2, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID2,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID3, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID3,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID4, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID4,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID5, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID5,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID6, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID6,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_PID7, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_PID7,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_DEC_0, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_DEC,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_ENC_0, pm);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_set_resource_power_mode(SC_R_VPU_ENC,%d) SCI error! (%d)\n", pm, sciErr);
+		goto setVPUPwrExit;
+	}
+
+	rv = 0;
+
+setVPUPwrExit:
+	return (rv);
+}
+
+#if 0
+/*!
+ * Private function to return the power mode of VPU
+ * @return <0 if there were errors.
+ */
+static sc_pm_power_mode_t getVPUPwr(sc_ipc_t ipcHndl)
+{
+	sc_pm_power_mode_t rv = -1;
+	sc_err_t sciErr;
+
+	if (!ipcHndl)
+	{
+		dev_err(vpu_dev, "--- getVPUPwr no IPC handle\n");
+		return (rv);
+	}
+
+	sciErr = sc_pm_get_resource_power_mode(ipcHndl, SC_R_VPU_PID0, &rv);
+	if (sciErr != SC_ERR_NONE)
+	{
+		dev_err(vpu_dev, "--- sc_pm_get_resource_power_mode(SC_R_VPU_PID0) SCI error! (%d)\n", sciErr);
+		rv = -1;
+	}
+
+	return (rv);
+}
+#endif
+
+static long vpu_power_get(bool on)
+{
+	return 0;
+}
+
+static void vpu_power_up(bool on)
+{
+	int err;
+
+	if (on) {
+		err = setVPUPwr(ipcHndl, SC_PM_PW_MODE_ON);
+		if (err)
+			dev_err(vpu_dev, "failed to power on\n");
+		pm_runtime_get_sync(vpu_dev);
+		/* TODO: before or after clk enable? */
+		clk_set_rate(vpu_clk, 600000000);
+	} else {
+		pm_runtime_put_sync_suspend(vpu_dev);
+		err = setVPUPwr(ipcHndl, SC_PM_PW_MODE_OFF);
+		if (err)
+			dev_err(vpu_dev, "failed to power off\n");
+	}
+}
+
+#define VM_RESERVED 0
+
+/*!
+ * Private function to alloc dma buffer
+ * @return status  0 success.
+ */
+static int vpu_alloc_dma_buffer(struct vpu_mem_desc *mem)
+{
+	mem->cpu_addr = dma_alloc_coherent(vpu_dev, PAGE_ALIGN(mem->size),
+			       &mem->phy_addr,
+			       GFP_DMA | GFP_KERNEL);
+	dev_dbg(vpu_dev, "[ALLOC] mem alloc cpu_addr = 0x%p\n", mem->cpu_addr);
+	if (mem->cpu_addr == NULL) {
+		dev_err(vpu_dev, "Physical memory allocation error!\n");
+		return -1;
+	}
+	return 0;
+}
+
+/*!
+ * Private function to free dma buffer
+ */
+static void vpu_free_dma_buffer(struct vpu_mem_desc *mem)
+{
+	if (mem->cpu_addr != NULL) {
+		dma_free_coherent(vpu_dev, PAGE_ALIGN(mem->size),
+				  mem->cpu_addr, mem->phy_addr);
+	}
+}
+
+/*!
+ * Private function to free buffers
+ * @return status  0 success.
+ */
+static int vpu_free_buffers(void)
+{
+	struct memalloc_record *rec, *n;
+	struct vpu_mem_desc mem;
+
+	list_for_each_entry_safe(rec, n, &head, list) {
+		mem = rec->mem;
+		if (mem.cpu_addr != NULL) {
+			vpu_free_dma_buffer(&mem);
+			dev_dbg(vpu_dev, "[FREE] freed paddr=0x%08llX\n", mem.phy_addr);
+			/* delete from list */
+			list_del(&rec->list);
+			kfree(rec);
+		}
+	}
+
+	return 0;
+}
+
+static inline void vpu_worker_callback(struct work_struct *w)
+{
+	struct vpu_priv *dev = container_of(w, struct vpu_priv,
+				work);
+
+	if (dev->async_queue)
+		kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+
+	irq_status = 1;
+
+	wake_up_interruptible(&vpu_queue);
+}
+
+#if 0
+/*!
+ * @brief vpu interrupt handler
+ */
+static irqreturn_t vpu_ipi_irq_handler(int irq, void *dev_id)
+{
+	struct vpu_priv *dev = dev_id;
+
+	queue_work(dev->workqueue, &dev->work);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*!
+ * @brief vpu fiq handler
+ */
+static irqreturn_t vpu_dec_fiq_handler(int irq, void *dev_id)
+{
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+  /* NXP using this bit in pal_int_enable() which is FORCE_EXIT, not hanlded within the ISR routing itself */
+	WRITE_REG(0x100, DEC_MFD_XREG_SLV_BASE + MFD_SIF + MFD_SIF_INTR_STATUS);
+
+	int_handlers[INT_ID_MALONE_LOW](uMvdKernelIrqPin[0][0]);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * @brief vpu irq handler
+ */
+static irqreturn_t vpu_dec_irq_handler(int irq, void *dev_id)
+{
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	int_handlers[INT_ID_MALONE_HI](uMvdKernelIrqPin[0][1]);
+
+	return IRQ_HANDLED;
+}
+
+static int vpu_isr_event_qu_init(void)
+{
+	int ret;
+
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	ret = pal_qu_create(ISR_EVENT_QU_SIZE,
+			NULL,
+			&gIsrEventQu);
+
+	return ret;
+}
+
+static int vpu_isr_event_qu_send(DECODER_KERNEL_LIB_ISR_EVENT_DATA *pIsrEventData)
+{
+	int ret;
+	uint_addr ulMsg[4];
+
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	mutex_lock(&vpu_data.lock);
+
+	/* Need to take care of copying over the data */
+	gIsrEventData[uIsrEventQuWrIdx] = *pIsrEventData;
+
+	/* Fill message */
+	ulMsg[0] = (uint_addr)&gIsrEventData[uIsrEventQuWrIdx];
+	ulMsg[1] = 0;
+	ulMsg[2] = 0;
+	ulMsg[3] = 0;
+
+	uIsrEventQuWrIdx++;
+	if (uIsrEventQuWrIdx == ISR_EVENT_QU_SIZE) uIsrEventQuWrIdx = 0;
+
+	ret = pal_qu_send (gIsrEventQu,
+			ulMsg);
+
+	mutex_unlock(&vpu_data.lock);
+
+	dev_dbg(vpu_dev, "leave %s\n", __FUNCTION__);
+	return ret;
+}
+
+static int vpu_isr_event_qu_receive(DECODER_KERNEL_LIB_ISR_EVENT_DATA *pIsrEventData)
+{
+	int ret;
+	uint_addr uMsg[4];
+
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	ret = pal_qu_receive(gIsrEventQu,
+			1000,
+			uMsg);
+
+	if (ret == MEDIAIP_FW_STATUS_OK)
+		*pIsrEventData = *(DECODER_KERNEL_LIB_ISR_EVENT_DATA *)uMsg[0];
+
+	dev_dbg(vpu_dev, "leave %s\n", __FUNCTION__);
+	return ret;
+}
+
+static int vpu_isr_event_qu_uninit(void)
+{
+	int ret;
+
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	ret = pal_qu_destroy(gIsrEventQu);
+
+	return ret;
+}
+
+static void vpu_isr_event_callback(DECODER_KERNEL_LIB_ISR_EVENT_DATA *ptEventData)
+{
+	int err;
+
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	err = vpu_isr_event_qu_send(ptEventData); 
+	if (err)
+		dev_err(vpu_dev, "failed to send isr event\n");
+
+	dev_dbg(vpu_dev, "leave %s\n", __FUNCTION__);
+}
+
+static void vpu_set_kernel_cfg(pDECODERLIB_KERNEL_CFG ptKernelCfg)
+{
+	ptKernelCfg->uNumMalones = 1;
+
+	ptKernelCfg->uMaloneBaseAddr[0]   = (uint_addr)(vpu_base + 0x180000);
+	ptKernelCfg->uMaloneHifOffset[0]  = 0x1C000;
+
+	/* Pass Decoder a PAL index, not an actual GIC position */
+	/* The PAL will take care of the rest                   */
+	ptKernelCfg->uMaloneIrqPin[0][0x0] = PAL_IRQ_MALONE0_LOW;
+	ptKernelCfg->uMaloneIrqPin[0][0x1] = PAL_IRQ_MALONE0_HI;
+
+	ptKernelCfg->uDPVBaseAddr   = 0;
+	ptKernelCfg->uDPVIrqPin     = 0;
+}
+
+static void vpu_prepare(void)
+{
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	WRITE_REG(0x1, SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL + SCB_BLK_CTRL_SCB_CLK_ENABLE_SET);
+	WRITE_REG(0xffffffff, SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL + SCB_BLK_CTRL_XMEM_RESET_SET);
+
+	WRITE_REG(0xE, SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL + SCB_BLK_CTRL_SCB_CLK_ENABLE_SET);
+	WRITE_REG(0x7, SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL + SCB_BLK_CTRL_CACHE_RESET_SET);
+
+	WRITE_REG(0x1f, DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL + MFD_BLK_CTRL_MFD_SYS_CLOCK_ENABLE_SET);
+	WRITE_REG(0xffffffff, DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL + MFD_BLK_CTRL_MFD_SYS_RESET_SET);
+
+	WRITE_REG(0x102, XMEM_CONTROL);
+}
+
+static void vpu_unprepare(void)
+{
+	dev_dbg(vpu_dev, "enter %s\n", __FUNCTION__);
+
+	WRITE_REG(0x7, SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL + SCB_BLK_CTRL_CACHE_RESET_CLR);
+	WRITE_REG(0xffffffff, DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL + MFD_BLK_CTRL_MFD_SYS_RESET_CLR);
+}
+
+/*!
+ * @brief open function for vpu file operation
+ *
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_open(struct inode *inode, struct file *filp)
+{
+	u32 mu_id;
+	int err;
+
+	mutex_lock(&vpu_data.lock);
+
+	if (open_count++ == 0) {
+		err = sc_ipc_getMuID(&mu_id);;
+		if(err != SC_ERR_NONE)
+		{
+			dev_err(vpu_dev, "--- sc_ipc_getMuID() cannot obtain mu id SCI error! (%d)\n", err);
+			return -EFAULT;
+		}
+
+		err = sc_ipc_open(&ipcHndl, mu_id);
+		if(err != SC_ERR_NONE)
+		{
+			dev_err(vpu_dev, "--- sc_ipc_getMuID() cannot open MU channel to SCU error! (%d)\n", err);
+			return -EFAULT;
+		}
+		vpu_power_up(true);
+		clk_prepare_enable(vpu_clk);
+		vpu_prepare();
+		err = vpu_isr_event_qu_init();
+		if(err)
+		{
+			dev_err(vpu_dev, "failed to init isr event qu\n");
+			return -EFAULT;
+		}
+		vpu_set_kernel_cfg(&gtKernelCfg);
+		decoder_kernel_lib_init(&gtKernelCfg);
+		decoder_kernel_lib_register_isr_callback(0, &vpu_isr_event_callback);
+
+#if 0
+		WRITE_REG(0x1000, DEC_MFD_XREG_SLV_BASE + MFD_HIF + 0x014);
+		WRITE_REG(0x20, DEC_MFD_XREG_SLV_BASE + MFD_HIF + 0x01C);
+		WRITE_REG(0x1000, DEC_MFD_XREG_SLV_BASE + MFD_SIF + MFD_SIF_CTRL_STATUS);
+		pal_int_set(PAL_IRQ_MALONE0_LOW);
+#endif
+	} else {
+		dev_err(vpu_dev, "open more than once is forbidden now\n");
+	}
+
+	filp->private_data = (void *)(&vpu_data);
+
+	mutex_unlock(&vpu_data.lock);
+
+	return 0;
+}
+
+/*!
+ * @brief IO ctrl function for vpu file operation
+ * @param cmd IO ctrl command
+ * @return  0 on success or negative error code on error
+ */
+
+#ifdef VPU_KERNEL_DBG_ISR
+int guDbgIsrArray[1024][3] ;
+int guDbgIsrArrayWrtIdx = 0 ;
+#endif
+
+static long vpu_ioctl(struct file *filp, u_int cmd,
+		     u_long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case VPU_IOC_PHYMEM_ALLOC:
+		{
+			struct memalloc_record *rec;
+
+			rec = kzalloc(sizeof(*rec), GFP_KERNEL);
+			if (!rec)
+				return -ENOMEM;
+
+			ret = copy_from_user(&(rec->mem),
+					     (struct vpu_mem_desc *)arg,
+					     sizeof(struct vpu_mem_desc));
+			if (ret) {
+				kfree(rec);
+				return -EFAULT;
+			}
+
+			dev_dbg(vpu_dev, "[ALLOC] mem alloc size = 0x%x\n",
+				 rec->mem.size);
+
+			ret = vpu_alloc_dma_buffer(&(rec->mem));
+			if (ret == -1) {
+				kfree(rec);
+				dev_err(vpu_dev,
+					"Physical memory allocation error!\n");
+				break;
+			}
+			ret = copy_to_user((void __user *)arg, &(rec->mem),
+					   sizeof(struct vpu_mem_desc));
+			if (ret) {
+				kfree(rec);
+				ret = -EFAULT;
+				break;
+			}
+
+			mutex_lock(&vpu_data.lock);
+			list_add(&rec->list, &head);
+			mutex_unlock(&vpu_data.lock);
+
+			break;
+		}
+	case VPU_IOC_PHYMEM_FREE:
+		{
+			struct memalloc_record *rec, *n;
+			struct vpu_mem_desc vpu_mem;
+
+			ret = copy_from_user(&vpu_mem,
+					     (struct vpu_mem_desc *)arg,
+					     sizeof(struct vpu_mem_desc));
+			if (ret)
+				return -EACCES;
+
+			dev_dbg(vpu_dev, "[FREE] mem freed cpu_addr = 0x%p\n",
+				 vpu_mem.cpu_addr);
+			if (vpu_mem.cpu_addr != NULL)
+				vpu_free_dma_buffer(&vpu_mem);
+
+			mutex_lock(&vpu_data.lock);
+			list_for_each_entry_safe(rec, n, &head, list) {
+				if (rec->mem.cpu_addr == vpu_mem.cpu_addr) {
+					/* delete from list */
+					list_del(&rec->list);
+					kfree(rec);
+					break;
+				}
+			}
+			mutex_unlock(&vpu_data.lock);
+
+			break;
+		}
+	case VPU_IOC_WAIT4INT:
+		{
+			DECODER_KERNEL_LIB_ISR_EVENT_DATA IsrEventData;
+
+			ret = vpu_isr_event_qu_receive(&IsrEventData);
+			if (ret) 
+            {
+				dev_info(vpu_dev, "no isr event\n");
+				ret = -EFAULT;
+				break;
+			}
+#ifdef VPU_KERNEL_DBG_ISR
+      else
+      {
+        dev_dbg(vpu_dev, "isr events= %x %x %x\n", IsrEventData.uIrqStatus[0],IsrEventData.uIrqStatus[1], IsrEventData.uIrqStatus[2]);
+      }
+
+      guDbgIsrArray[guDbgIsrArrayWrtIdx][0] = IsrEventData.uIrqStatus[0];
+      guDbgIsrArray[guDbgIsrArrayWrtIdx][1] = IsrEventData.uIrqStatus[1];
+      guDbgIsrArray[guDbgIsrArrayWrtIdx][2] = IsrEventData.uIrqStatus[2];      
+      guDbgIsrArrayWrtIdx++;
+      guDbgIsrArrayWrtIdx = (guDbgIsrArrayWrtIdx==1024) ? 0 : guDbgIsrArrayWrtIdx;
+#endif
+        
+			ret = copy_to_user((void __user *)arg, &IsrEventData, sizeof(DECODER_KERNEL_LIB_ISR_EVENT_DATA));
+      
+			if (ret)
+				ret = -EFAULT;
+#if 0
+			u_long timeout = (u_long) arg;
+			if (!wait_event_interruptible_timeout
+			    (vpu_queue, irq_status != 0,
+			     msecs_to_jiffies(timeout))) {
+				dev_warn(vpu_dev, "VPU blocking: timeout.\n");
+				ret = -ETIME;
+			} else if (signal_pending(current)) {
+				dev_warn(vpu_dev, "Other interrupt received.\n");
+				ret = -ERESTARTSYS;
+			} else
+				irq_status = 0;
+#endif
+			break;
+		}
+	case VPU_IOC_CLKGATE_SETTING:
+		{
+			u32 clkgate_en;
+
+			if (get_user(clkgate_en, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (clkgate_en) {
+				clk_prepare_enable(vpu_clk);
+				atomic_inc(&clk_cnt_from_ioc);
+			} else {
+				clk_disable_unprepare(vpu_clk);
+				atomic_dec(&clk_cnt_from_ioc);
+			}
+
+			break;
+		}
+	case VPU_IOC_GET_SHARE_MEM:
+		{
+			mutex_lock(&vpu_data.lock);
+			if (share_mem.cpu_addr != NULL) {
+				ret = copy_to_user((void __user *)arg,
+						   &share_mem,
+						   sizeof(struct vpu_mem_desc));
+				mutex_unlock(&vpu_data.lock);
+				break;
+			} else {
+				if (copy_from_user(&share_mem,
+						   (struct vpu_mem_desc *)arg,
+						 sizeof(struct vpu_mem_desc))) {
+					mutex_unlock(&vpu_data.lock);
+					return -EFAULT;
+				}
+				if (vpu_alloc_dma_buffer(&share_mem) == -1)
+					ret = -EFAULT;
+				else {
+					if (copy_to_user((void __user *)arg,
+							 &share_mem,
+							 sizeof(struct
+								vpu_mem_desc)))
+						ret = -EFAULT;
+				}
+			}
+			mutex_unlock(&vpu_data.lock);
+			break;
+		}
+	case VPU_IOC_REQ_VSHARE_MEM:
+		{
+			mutex_lock(&vpu_data.lock);
+			if (vshare_mem.cpu_addr != NULL) {
+				ret = copy_to_user((void __user *)arg,
+						   &vshare_mem,
+						   sizeof(struct vpu_mem_desc));
+				mutex_unlock(&vpu_data.lock);
+				break;
+			} else {
+				if (copy_from_user(&vshare_mem,
+						   (struct vpu_mem_desc *)arg,
+						   sizeof(struct
+							  vpu_mem_desc))) {
+					mutex_unlock(&vpu_data.lock);
+					return -EFAULT;
+				}
+				/* vmalloc shared memory if not allocated */
+				if (!vshare_mem.cpu_addr)
+					vshare_mem.cpu_addr =
+					    vmalloc_user(vshare_mem.size);
+				if (copy_to_user
+				     ((void __user *)arg, &vshare_mem,
+				     sizeof(struct vpu_mem_desc)))
+					ret = -EFAULT;
+			}
+			mutex_unlock(&vpu_data.lock);
+			break;
+		}
+	case VPU_IOC_SYS_SW_RESET:
+		{
+			vpu_reset();
+			break;
+		}
+	case VPU_IOC_LOCK_DEV:
+		{
+			u32 lock_en;
+
+			if (get_user(lock_en, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (lock_en)
+				mutex_lock(&vpu_data.lock);
+			else
+				mutex_unlock(&vpu_data.lock);
+
+			break;
+		}
+	default:
+		{
+			dev_err(vpu_dev, "No such IOCTL, cmd is %d\n", cmd);
+			ret = -EINVAL;
+			break;
+		}
+	}
+	return ret;
+}
+
+/*!
+ * @brief Release function for vpu file operation
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_release(struct inode *inode, struct file *filp)
+{
+	int i;
+	unsigned long timeout;
+	int err;
+
+	mutex_lock(&vpu_data.lock);
+
+	if (open_count > 0 && !(--open_count)) {
+
+		/* Wait for vpu go to idle state */
+		clk_prepare_enable(vpu_clk);
+		timeout = jiffies + HZ;
+		/* checking busy */
+		while (0) {
+			msleep(1);
+			if (time_after(jiffies, timeout)) {
+				dev_warn(vpu_dev, "VPU timeout during release\n");
+				break;
+			}
+		}
+
+		/* Clean up interrupt */
+#if 0
+		cancel_work_sync(&vpu_data.work);
+		flush_workqueue(vpu_data.workqueue);
+		irq_status = 0;
+#endif
+
+		/* reset if busy */
+		if (0) {
+			vpu_reset();
+		}
+		clk_disable_unprepare(vpu_clk);
+
+		vpu_free_buffers();
+
+		/* Free shared memory when vpu device is idle */
+		vpu_free_dma_buffer(&share_mem);
+		share_mem.cpu_addr = NULL;
+		vfree(vshare_mem.cpu_addr);
+		vshare_mem.cpu_addr = NULL;
+
+		vpu_clk_usercount = atomic_read(&clk_cnt_from_ioc);
+		for (i = 0; i < vpu_clk_usercount; i++) {
+			clk_disable_unprepare(vpu_clk);
+			atomic_dec(&clk_cnt_from_ioc);
+		}
+
+		err = vpu_isr_event_qu_uninit();
+		if (err)
+			dev_err(vpu_dev, "failed to uninit isr event qu\n");
+		vpu_unprepare();
+		clk_disable_unprepare(vpu_clk);
+		vpu_power_up(false);
+		sc_ipc_close(ipcHndl);
+	}
+	mutex_unlock(&vpu_data.lock);
+
+	return 0;
+}
+
+/*!
+ * @brief fasync function for vpu file operation
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_fasync(int fd, struct file *filp, int mode)
+{
+	struct vpu_priv *dev = (struct vpu_priv *)filp->private_data;
+	return fasync_helper(fd, filp, mode, &dev->async_queue);
+}
+
+/*!
+ * @brief memory map function of harware registers for vpu file operation
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_map_hwregs(struct file *fp, struct vm_area_struct *vm)
+{
+	unsigned long pfn;
+
+	vm->vm_flags |= VM_IO | VM_RESERVED;
+	/*
+	 * Since vpu registers have been mapped with ioremap() at probe
+	 * which L_PTE_XN is 1, and the same physical address must be
+	 * mapped multiple times with same type, so set L_PTE_XN to 1 here.
+	 * Otherwise, there may be unexpected result in video codec.
+	 */
+	vm->vm_page_prot = pgprot_noncached(vm->vm_page_prot);
+	pfn = phy_vpu_base_addr >> PAGE_SHIFT;
+	dev_dbg(vpu_dev, "size=0x%x, page no.=0x%x\n",
+		 (int)(vm->vm_end - vm->vm_start), (int)pfn);
+	return remap_pfn_range(vm, vm->vm_start, pfn, vm->vm_end - vm->vm_start,
+			       vm->vm_page_prot) ? -EAGAIN : 0;
+}
+
+/*!
+ * @brief memory map function of memory for vpu file operation
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_map_dma_mem(struct file *fp, struct vm_area_struct *vm)
+{
+	int request_size;
+	request_size = vm->vm_end - vm->vm_start;
+
+	dev_dbg(vpu_dev, "start=0x%x, pgoff=0x%x, size=0x%x\n",
+		 (unsigned int)(vm->vm_start), (unsigned int)(vm->vm_pgoff),
+		 request_size);
+
+	vm->vm_flags |= VM_IO | VM_RESERVED;
+	vm->vm_page_prot = pgprot_writecombine(vm->vm_page_prot);
+
+	return remap_pfn_range(vm, vm->vm_start, vm->vm_pgoff,
+			       request_size, vm->vm_page_prot) ? -EAGAIN : 0;
+
+}
+
+/* !
+ * @brief memory map function of vmalloced share memory
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_map_vshare_mem(struct file *fp, struct vm_area_struct *vm)
+{
+	int ret = -EINVAL;
+
+	ret = remap_vmalloc_range(vm, (void *)(vm->vm_pgoff << PAGE_SHIFT), 0);
+	vm->vm_flags |= VM_IO;
+
+	return ret;
+}
+/*!
+ * @brief memory map interface for vpu file operation
+ * @return  0 on success or negative error code on error
+ */
+static int vpu_mmap(struct file *fp, struct vm_area_struct *vm)
+{
+	u64 offset;
+
+	offset = (u64)((s64)vshare_mem.cpu_addr >> PAGE_SHIFT);
+
+	if (vm->vm_pgoff && (vm->vm_pgoff == offset))
+		return vpu_map_vshare_mem(fp, vm);
+	else if (vm->vm_pgoff)
+		return vpu_map_dma_mem(fp, vm);
+	else
+		return vpu_map_hwregs(fp, vm);
+}
+
+const struct file_operations vpu_fops = {
+	.owner = THIS_MODULE,
+	.open = vpu_open,
+	.unlocked_ioctl = vpu_ioctl,
+	.release = vpu_release,
+	.fasync = vpu_fasync,
+	.mmap = vpu_mmap,
+};
+
+/*!
+ * This function is called by the driver framework to initialize the vpu device.
+ * @param   dev The device structure for the vpu passed in by the framework.
+ * @return   0 on success or negative error code on error
+ */
+static int vpu_dev_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct device *temp_class;
+	struct resource *res;
+
+	vpu_dev = &pdev->dev;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vpu_regs");
+	if (!res) {
+		dev_err(vpu_dev, "vpu: unable to get vpu base addr\n");
+		return -ENODEV;
+	}
+	phy_vpu_base_addr = res->start;
+	vpu_base = devm_ioremap_resource(vpu_dev, res);
+
+	vpu_major = register_chrdev(vpu_major, "mxc_vpu_malone", &vpu_fops);
+	if (vpu_major < 0) {
+		dev_err(vpu_dev, "vpu: unable to get a major for VPU\n");
+		err = -EBUSY;
+		goto error;
+	}
+
+	vpu_class = class_create(THIS_MODULE, "mxc_vpu_malone");
+	if (IS_ERR(vpu_class)) {
+		err = PTR_ERR(vpu_class);
+		goto err_out_chrdev;
+	}
+
+	temp_class = device_create(vpu_class, NULL, MKDEV(vpu_major, 0),
+				   NULL, "mxc_vpu_malone");
+	if (IS_ERR(temp_class)) {
+		err = PTR_ERR(temp_class);
+		goto err_out_class;
+	}
+
+	vpu_clk = clk_get(&pdev->dev, "vpu_clk");
+	if (IS_ERR(vpu_clk)) {
+		err = -ENOENT;
+		goto err_out_class;
+	}
+
+	vpu_dec_irq = platform_get_irq_byname(pdev, "dec_irq");
+	if (vpu_dec_irq < 0) {
+		dev_err(vpu_dev, "dec_irq is not found\n");
+		err = -ENXIO;
+		goto err_out_class;
+	}
+	err = devm_request_threaded_irq(vpu_dev, vpu_dec_irq, vpu_dec_irq_handler,
+			NULL, 0, "VPU DEC IRQ", (void*)(&vpu_data));
+	if (err < 0) {
+		dev_err(vpu_dev, "failed to request irq for dec_irq\n");
+		goto err_out_class;
+	}
+
+	vpu_dec_fiq = platform_get_irq_byname(pdev, "dec_fiq");
+	if (vpu_dec_fiq < 0) {
+		dev_err(vpu_dev, "dec_fiq is not found\n");
+		err = -ENXIO;
+		goto err_out_class;
+	}
+	err = devm_request_threaded_irq(vpu_dev, vpu_dec_fiq, vpu_dec_fiq_handler,
+			NULL, 0, "VPU DEC FIQ", (void*)(&vpu_data));
+	if (err < 0)
+		dev_err(vpu_dev, "failed to request irq for dec_fiq\n");
+
+	if (vpu_power_get(true)) {
+		dev_err(vpu_dev, "failed to get vpu power\n");
+		goto err_out_class;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	vpu_data.workqueue = create_workqueue("vpu_wq");
+	INIT_WORK(&vpu_data.work, vpu_worker_callback);
+	mutex_init(&vpu_data.lock);
+	dev_info(vpu_dev, "VPU initialized\n");
+
+	goto out;
+
+err_out_class:
+	device_destroy(vpu_class, MKDEV(vpu_major, 0));
+	class_destroy(vpu_class);
+err_out_chrdev:
+	unregister_chrdev(vpu_major, "mxc_vpu_malone");
+error:
+	devm_iounmap(vpu_dev, vpu_base);
+out:
+	return err;
+}
+
+static int vpu_dev_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	devm_free_irq(&pdev->dev, vpu_dec_irq, &vpu_data);
+	devm_free_irq(&pdev->dev, vpu_dec_fiq, &vpu_data);
+	cancel_work_sync(&vpu_data.work);
+	flush_workqueue(vpu_data.workqueue);
+	destroy_workqueue(vpu_data.workqueue);
+
+	devm_iounmap(&pdev->dev, vpu_base);
+
+	vpu_power_get(false);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int vpu_suspend(struct device *dev)
+{
+	int i;
+	unsigned long timeout;
+
+	mutex_lock(&vpu_data.lock);
+	if (open_count != 0) {
+		/* Wait for vpu go to idle state, suspect vpu cannot be changed
+		   to idle state after about 1 sec */
+		timeout = jiffies + HZ;
+		clk_prepare_enable(vpu_clk);
+		/* checking busy */
+		while (0) {
+			msleep(1);
+			if (time_after(jiffies, timeout)) {
+				clk_disable_unprepare(vpu_clk);
+				mutex_unlock(&vpu_data.lock);
+				return -EAGAIN;
+			}
+		}
+		clk_disable_unprepare(vpu_clk);
+
+		/* Make sure clock is disabled before suspend */
+		vpu_clk_usercount = atomic_read(&clk_cnt_from_ioc);
+		for (i = 0; i < vpu_clk_usercount; i++) {
+			clk_disable_unprepare(vpu_clk);
+		}
+
+		clk_prepare_enable(vpu_clk);
+		/* Save registers */
+		clk_disable_unprepare(vpu_clk);
+
+		/* If VPU is working before suspend, disable
+		 * regulator to make usecount right. */
+		vpu_power_up(false);
+	}
+
+	mutex_unlock(&vpu_data.lock);
+	return 0;
+}
+
+static int vpu_resume(struct device *dev)
+{
+	int i;
+
+	mutex_lock(&vpu_data.lock);
+	if (open_count != 0) {
+		/* If VPU is working before suspend, enable
+		 * regulator to make usecount right. */
+		vpu_power_up(true);
+
+		clk_prepare_enable(vpu_clk);
+
+		/* Restore registers */
+
+		clk_disable_unprepare(vpu_clk);
+
+		/* Recover vpu clock */
+		for (i = 0; i < vpu_clk_usercount; i++) {
+			clk_prepare_enable(vpu_clk);
+		}
+	}
+
+	mutex_unlock(&vpu_data.lock);
+	return 0;
+}
+
+static int vpu_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static int vpu_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static const struct dev_pm_ops vpu_pm_ops = {
+	SET_RUNTIME_PM_OPS(vpu_runtime_suspend, vpu_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(vpu_suspend, vpu_resume)
+};
+
+#else
+#define	vpu_suspend	NULL
+#define	vpu_resume	NULL
+#endif				/* !CONFIG_PM */
+
+static const struct of_device_id vpu_of_match[] = {
+	{ .compatible = "nxp,imx8qm-vpu", },
+	{ .compatible = "nxp,imx8qxp-vpu", },
+	{/* sentinel */}
+};
+MODULE_DEVICE_TABLE(of, vpu_of_match);
+
+/*! Driver definition
+ *
+ */
+static struct platform_driver mxcvpu_driver = {
+	.driver = {
+		   .name = "mxc_vpu_malone",
+		   .of_match_table = vpu_of_match,
+#ifdef CONFIG_PM
+		   .pm = &vpu_pm_ops,
+#endif
+		   },
+	.probe = vpu_dev_probe,
+	.remove = vpu_dev_remove,
+};
+
+static int __init vpu_init(void)
+{
+	int ret = platform_driver_register(&mxcvpu_driver);
+
+	init_waitqueue_head(&vpu_queue);
+
+	return ret;
+}
+
+static void __exit vpu_exit(void)
+{
+	if (vpu_major > 0) {
+		device_destroy(vpu_class, MKDEV(vpu_major, 0));
+		class_destroy(vpu_class);
+		unregister_chrdev(vpu_major, "mxc_vpu_malone");
+		vpu_major = 0;
+	}
+
+	/* reset VPU state */
+	vpu_power_up(true);
+	clk_prepare_enable(vpu_clk);
+	vpu_reset();
+	clk_disable_unprepare(vpu_clk);
+	vpu_power_up(false);
+
+	clk_put(vpu_clk);
+
+	platform_driver_unregister(&mxcvpu_driver);
+	return;
+}
+
+MODULE_AUTHOR("NXP");
+MODULE_DESCRIPTION("Linux VPU driver for NXP i.MX/MXC");
+MODULE_LICENSE("GPL");
+
+module_init(vpu_init);
+module_exit(vpu_exit);
diff --git a/include/linux/mxc_vpu-malone.h b/include/linux/mxc_vpu-malone.h
new file mode 100755
index 0000000..8214157
--- /dev/null
+++ b/include/linux/mxc_vpu-malone.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2017 NXP
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup VPU Video Processor Unit Driver
+ */
+
+/*!
+ * @file linux/mxc_vpu-malone.h
+ *
+ * @brief VPU system initialization and file operation definition
+ *
+ * @ingroup VPU
+ */
+
+#ifndef __LINUX_MXC_VPU_MALONE_H__
+#define __LINUX_MXC_VPU_MALONE_H__
+
+#include <linux/fs.h>
+
+struct vpu_mem_desc {
+	u32 size;
+	dma_addr_t phy_addr;
+	void *cpu_addr;		/* cpu address to free the dma mem */
+	u64 virt_uaddr;		/* virtual user space address */
+};
+
+#define VPU_IOC_MAGIC  'V'
+
+#define VPU_IOC_PHYMEM_ALLOC	_IO(VPU_IOC_MAGIC, 0)
+#define VPU_IOC_PHYMEM_FREE	_IO(VPU_IOC_MAGIC, 1)
+#define VPU_IOC_WAIT4INT	_IO(VPU_IOC_MAGIC, 2)
+#define VPU_IOC_CLKGATE_SETTING	_IO(VPU_IOC_MAGIC, 3)
+#define VPU_IOC_REQ_VSHARE_MEM	_IO(VPU_IOC_MAGIC, 4)
+#define VPU_IOC_SYS_SW_RESET	_IO(VPU_IOC_MAGIC, 5)
+#define VPU_IOC_GET_SHARE_MEM   _IO(VPU_IOC_MAGIC, 6)
+#define VPU_IOC_LOCK_DEV	_IO(VPU_IOC_MAGIC, 7)
+
+#endif
-- 
1.7.9.5


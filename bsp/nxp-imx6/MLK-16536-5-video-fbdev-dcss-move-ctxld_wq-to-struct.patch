From 2188cc644886d505f24fd20a9842b3af89948aa6 Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@nxp.com>
Date: Wed, 20 Sep 2017 17:41:43 +0800
Subject: [PATCH 2579/5242] MLK-16536-5 video: fbdev: dcss: move 'ctxld_wq' to
 'struct ctxld_fifo'

commit  7a5e4d62c8e8262410f35ebe707b8df815f4fddb from
https://source.codeaurora.org/external/imx/linux-imx.git

The 'ctxld_wq' is more closely related to 'struct ctxld_info'
structure. So moving its definition to this structure is more
reasonable.

Signed-off-by: Fancy Fang <chen.fang@nxp.com>
Reviewed-by: Robby Cai <robby.cai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxc/imx_dcss.c |   12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/video/fbdev/mxc/imx_dcss.c b/drivers/video/fbdev/mxc/imx_dcss.c
index a66861f..812ceca 100644
--- a/drivers/video/fbdev/mxc/imx_dcss.c
+++ b/drivers/video/fbdev/mxc/imx_dcss.c
@@ -267,6 +267,7 @@ struct ctxld_fifo {
 	DECLARE_KFIFO_PTR(fifo, struct ctxld_unit);
 	struct scatterlist sgl[1];
 	uint32_t sgl_num;
+	struct workqueue_struct *ctxld_wq;
 	/* synchronization in two points:
 	 * a. simutanous fifo commits
 	 * b. queue waiting for cfifo flush
@@ -328,7 +329,6 @@ struct dcss_info {
 	struct regulator *power;
 	struct ctxld_fifo cfifo;
 	struct task_struct *handler;
-	struct workqueue_struct *ctxld_wq;
 	struct dcss_pixmap *output;
 	struct dcss_channels chans;	/* maximum 3 channels
 					 * TODO: better change to layer
@@ -2363,7 +2363,7 @@ static int commit_to_fifo(uint32_t channel,
 		atomic_set(&info->flush, 1);
 		spin_unlock(&cfifo->cqueue.lock);
 		/* Wait fifo flush empty to avoid fifo wrap */
-		flush_workqueue(info->ctxld_wq);
+		flush_workqueue(cfifo->ctxld_wq);
 		spin_lock(&cfifo->cqueue.lock);
 		atomic_set(&info->flush, 0);
 		kfifo_reset(&cfifo->fifo);
@@ -2384,7 +2384,7 @@ static int commit_to_fifo(uint32_t channel,
 	/* queue the work to workqueue */
 	cc->data = info;
 	INIT_WORK(&cc->work, dcss_ctxld_config);
-	queue_work(info->ctxld_wq, &cc->work);
+	queue_work(cfifo->ctxld_wq, &cc->work);
 
 	return 0;
 }
@@ -2751,7 +2751,7 @@ static int dcss_pan_display(struct fb_var_screeninfo *var,
 	/* TODO: blocking mode */
 	if (likely(!var->reserved[2]))
 		/* make pan display synchronously */
-		flush_workqueue(info->ctxld_wq);
+		flush_workqueue(info->cfifo.ctxld_wq);
 
 	return 0;
 }
@@ -3119,8 +3119,8 @@ static int dcss_info_init(struct dcss_info *info)
 		goto out;
 	}
 
-	info->ctxld_wq = alloc_ordered_workqueue("ctxld-wq", WQ_FREEZABLE);
-	if (!info->ctxld_wq) {
+	info->cfifo.ctxld_wq = alloc_ordered_workqueue("ctxld-wq", WQ_FREEZABLE);
+	if (!info->cfifo.ctxld_wq) {
 		dev_err(&pdev->dev, "allocate ctxld wq failed\n");
 		ret = -EINVAL;
 		goto free_cfifo;
-- 
1.7.9.5


From d8ba869687f93856cb4b677b91364023c1cf46fd Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Mon, 12 Nov 2018 13:45:09 +0800
Subject: [PATCH 5142/5242] MLK-20321 VPU: Adjust reset strategy for vpu
 decoder

commit  4b9a6c460178d22c17f5da945d8a1fea2f5c4efb from
https://source.codeaurora.org/external/imx/linux-imx.git

Adjust reset strategy for vpu decoder

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/vpu_b0.c |   84 ++++++++++++++++++++++-------------
 drivers/mxc/vpu-decoder-b0/vpu_b0.h |    2 +-
 2 files changed, 55 insertions(+), 31 deletions(-)

diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index aab700f..5c4e0e7 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -61,7 +61,9 @@
 static void v4l2_vpu_send_cmd(struct vpu_ctx *ctx, uint32_t idx, uint32_t cmdid, uint32_t cmdnum, uint32_t *local_cmddata);
 static int add_scode(struct vpu_ctx *ctx, u_int32 uStrBufIdx, VPU_PADDING_SCODE_TYPE eScodeType, bool bUpdateWr);
 static void v4l2_update_stream_addr(struct vpu_ctx *ctx, uint32_t uStrBufIdx);
-static int swreset_vpu_firmware(struct vpu_dev *dev);
+static int swreset_vpu_firmware(struct vpu_dev *dev, u_int32 idx);
+static int find_first_available_instance(struct vpu_dev *dev);
+#define CHECK_BIT(var, pos) (((var) >> (pos)) & 1)
 
 static char *cmd2str[] = {
 	"VID_API_CMD_NULL",   /*0x0*/
@@ -885,7 +887,14 @@ static int v4l2_ioctl_streamon(struct file *file,
 	} else
 		vpu_dbg(LVL_ERR, "error: %s() return ret=%d\n", __func__, ret);
 
-	return ret;
+	if (ctx->hang_status) {
+		vpu_dbg(LVL_ERR, "%s(): not succeed and some instance are blocked\n", __func__);
+		return -EINVAL;
+	} else if (ctx->firmware_stopped) {
+		vpu_dbg(LVL_ERR, "%s(): not succeed and firmware is stopped\n", __func__);
+		return -EINVAL;
+	} else
+		return ret;
 }
 
 static int v4l2_ioctl_streamoff(struct file *file,
@@ -922,12 +931,10 @@ static int v4l2_ioctl_streamoff(struct file *file,
 
 			wake_up_interruptible(&ctx->buffer_wq);
 			if (!wait_for_completion_timeout(&ctx->completion, msecs_to_jiffies(1000))) {
-				mutex_lock(&ctx->dev->dev_mutex);
-				set_bit(ctx->str_index, &ctx->dev->hang_mask);
-				mutex_unlock(&ctx->dev->dev_mutex);
-
-				vpu_dbg(LVL_ERR, "the path id:%d firmware hang after send VID_API_CMD_ABORT, stopped(%d), finished(%d), eos_added(%d)\n", ctx->str_index,
-					ctx->firmware_stopped, ctx->firmware_finished, ctx->eos_stop_added);
+				ctx->hang_status = true;
+				vpu_dbg(LVL_ERR, "the path id:%d firmware hang after send VID_API_CMD_ABORT, stopped(%d), finished(%d), eos_added(%d)\n",
+						ctx->str_index, ctx->firmware_stopped,
+						ctx->firmware_finished, ctx->eos_stop_added);
 			}
 			vpu_dbg(LVL_INFO, "receive abort done\n");
 		}
@@ -936,7 +943,7 @@ static int v4l2_ioctl_streamoff(struct file *file,
 	ret = vb2_streamoff(&q_data->vb2_q,
 			i);
 
-	if (ctx->dev->hang_mask & (1 << ctx->str_index)) {
+	if (ctx->hang_status) {
 		vpu_dbg(LVL_ERR, "%s(): not succeed and some instance are blocked\n", __func__);
 		return -EINVAL;
 	} else if (ctx->firmware_stopped) {
@@ -2198,7 +2205,7 @@ static int release_hang_instance(struct vpu_dev *dev)
 		return -EINVAL;
 
 	for (i = 0; i < VPU_MAX_NUM_STREAMS; i++)
-		if (!dev->ctx[i]) {
+		if (dev->ctx[i]) {
 			kfree(dev->ctx[i]);
 			dev->ctx[i] = NULL;
 		}
@@ -2206,26 +2213,36 @@ static int release_hang_instance(struct vpu_dev *dev)
 	return 0;
 }
 
+static int get_reset_index(struct vpu_dev *dev)
+{
+	int idx;
+
+	for (idx = 0; idx < VPU_MAX_NUM_STREAMS; idx++)
+		if (CHECK_BIT(dev->instance_mask, idx))
+			break;
+
+	return idx;
+}
+
 /*
  * Add judge to find if it has available path to decode, if all
  * path hang, reset vpu and then get one index
  */
 static int vpu_next_free_instance(struct vpu_dev *dev)
 {
-	int count = 0;
-	unsigned long hang_mask = dev->hang_mask;
 	int idx;
 
-	while (hang_mask) {
-		if (hang_mask & 1)
-			count++;
-		hang_mask >>= 1;
-	}
-	if (count == VPU_MAX_NUM_STREAMS) {
+	if (dev->hang_mask == dev->instance_mask
+			&& dev->instance_mask != 0) {
+		idx = get_reset_index(dev);
+		if (idx < 0 || idx >= VPU_MAX_NUM_STREAMS)
+			return -EBUSY;
+		else {
+			swreset_vpu_firmware(dev, idx);
+			release_hang_instance(dev);
+		}
 		dev->hang_mask = 0;
 		dev->instance_mask = 0;
-		swreset_vpu_firmware(dev);
-		release_hang_instance(dev);
 	}
 
 	idx = ffz(dev->instance_mask);
@@ -2794,6 +2811,7 @@ static int v4l2_open(struct file *filp)
 	ctx->ctx_released = false;
 	ctx->b_dis_reorder = false;
 	ctx->start_code_bypass = false;
+	ctx->hang_status = false;
 	ctx->pSeqinfo = kzalloc(sizeof(MediaIPFW_Video_SeqInfo), GFP_KERNEL);
 	if (!ctx->pSeqinfo) {
 		vpu_dbg(LVL_ERR, "error: pSeqinfo alloc fail\n");
@@ -2913,9 +2931,7 @@ static int v4l2_release(struct file *filp)
 		vpu_dbg(LVL_INFO, "v4l2_release() - send VID_API_CMD_STOP\n");
 		v4l2_vpu_send_cmd(ctx, ctx->str_index, VID_API_CMD_STOP, 0, NULL);
 		if (!wait_for_completion_timeout(&ctx->stop_cmp, msecs_to_jiffies(1000))) {
-			mutex_lock(&dev->dev_mutex);
-			set_bit(ctx->str_index, &dev->hang_mask);
-			mutex_unlock(&dev->dev_mutex);
+			ctx->hang_status = true;
 			vpu_dbg(LVL_ERR, "the path id:%d firmware hang after send VID_API_CMD_STOP\n", ctx->str_index);
 		}
 	} else {
@@ -2971,10 +2987,14 @@ static int v4l2_release(struct file *filp)
 
 	pm_runtime_put_sync(ctx->dev->generic_dev);
 
-	if (!(dev->hang_mask & (1 << ctx->str_index))) { // judge the path is hang or not, if hang, don't clear
+	if (!ctx->hang_status) { // judge the path is hang or not, if hang, don't clear
 		clear_bit(ctx->str_index, &dev->instance_mask);
 		dev->ctx[ctx->str_index] = NULL;
 		kfree(ctx);
+	} else {
+		mutex_lock(&dev->dev_mutex);
+		set_bit(ctx->str_index, &dev->hang_mask);
+		mutex_unlock(&dev->dev_mutex);
 	}
 	return 0;
 }
@@ -3099,14 +3119,14 @@ static void vpu_disable_hw(struct vpu_dev *This)
 	vpu_reset(This);
 }
 
-static int swreset_vpu_firmware(struct vpu_dev *dev)
+static int swreset_vpu_firmware(struct vpu_dev *dev, u_int32 idx)
 {
 	int ret = 0;
 
 	vpu_dbg(LVL_WARN, "SWRESET: swreset_vpu_firmware\n");
 	dev->firmware_started = false;
 
-	v4l2_vpu_send_cmd(dev->ctx[0], 0, VID_API_CMD_FIRM_RESET, 0, NULL);
+	v4l2_vpu_send_cmd(dev->ctx[idx], 0, VID_API_CMD_FIRM_RESET, 0, NULL);
 
 	wait_for_completion(&dev->start_cmp);
 	dev->firmware_started = true;
@@ -3420,8 +3440,6 @@ static int vpu_runtime_resume(struct device *dev)
 	return 0;
 }
 
-#define CHECK_BIT(var, pos) (((var) >> (pos)) & 1)
-
 static int find_first_available_instance(struct vpu_dev *dev)
 {
 	int strIdx, i;
@@ -3518,6 +3536,7 @@ static int vpu_resume(struct device *dev)
 {
 	struct vpu_dev *vpudev = (struct vpu_dev *)dev_get_drvdata(dev);
 	int ret = 0;
+	u_int32 idx;
 
 	pm_runtime_get_sync(vpudev->generic_dev);
 
@@ -3528,8 +3547,13 @@ static int vpu_resume(struct device *dev)
 
 	if (is_vpu_poweroff(vpudev))
 		ret = resume_from_vpu_poweroff(vpudev);
-	else if (vpudev->hang_mask != vpudev->instance_mask)
-		swreset_vpu_firmware(vpudev);
+	else if (vpudev->hang_mask != vpudev->instance_mask) {
+		idx = get_reset_index(vpudev);
+		if (idx < VPU_MAX_NUM_STREAMS)
+			swreset_vpu_firmware(vpudev, idx);
+		else
+			return -EINVAL;
+	}
 
 	pm_runtime_put_sync(vpudev->generic_dev);
 
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.h b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
index 73ee889..b9159cb 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.h
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
@@ -49,7 +49,6 @@
 #define MMAP_BUF_TYPE_SHIFT 28
 #define MMAP_BUF_TYPE_MASK 0xF0000000
 #define M0_BOOT_SIZE 0x1000000
-#define M0_PRINT_OFFSET 0x500000
 #define DCP_SIZE 0x3000000
 #define MAX_BUFFER_SIZE 0x800000
 #define UDATA_BUFFER_SIZE 0x1000
@@ -272,6 +271,7 @@ struct vpu_ctx {
 	bool eos_stop_added;
 	bool ctx_released;
 	bool start_code_bypass;
+	bool hang_status;
 	wait_queue_head_t buffer_wq;
 	void *dpb_dma_virt;
 	u_int32 uSize;
-- 
1.7.9.5


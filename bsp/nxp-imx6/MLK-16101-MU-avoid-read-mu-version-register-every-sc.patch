From fc4341282e9dfa20e6c1fe1814253352215a3638 Mon Sep 17 00:00:00 2001
From: Frank Li <Frank.Li@nxp.com>
Date: Fri, 28 Jul 2017 15:10:28 -0500
Subject: [PATCH 2257/5242] MLK-16101 MU: avoid read mu version register every
 scu call

commit  d2ff82c73b5a2527de5f1f4763a0e90063b0eac0 from
https://source.codeaurora.org/external/imx/linux-imx.git

Generally read mu registers will take about 225ns.
Overall scu_clk_enable function takes about 8000ns to 150000ns.
Although read version register just take 3% time,
it is not necessary to read version register every time.

Signed-off-by: Frank Li <Frank.Li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/mu/mx8_mu.c |   18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/drivers/soc/imx/mu/mx8_mu.c b/drivers/soc/imx/mu/mx8_mu.c
index 7409c2c..894c8fc 100644
--- a/drivers/soc/imx/mu/mx8_mu.c
+++ b/drivers/soc/imx/mu/mx8_mu.c
@@ -9,6 +9,7 @@
 #include <linux/io.h>
 #include <linux/mx8_mu.h>
 
+static int version;
 
 /*!
  * This function sets the Flag n of the MU.
@@ -21,7 +22,7 @@ int32_t MU_SetFn(void __iomem *base, uint32_t Fn)
 	if (reg > 0)
 		return -EINVAL;
 
-	offset = unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)
+	offset = unlikely(version == MU_VER_ID_V10)
 			  ? MU_V10_ACR_OFFSET1 : MU_ACR_OFFSET1;
 
 	reg = readl_relaxed(base + offset);
@@ -40,7 +41,7 @@ uint32_t MU_ReadStatus(void __iomem *base)
 {
 	uint32_t reg, offset;
 
-	offset = unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)
+	offset = unlikely(version == MU_VER_ID_V10)
 			  ? MU_V10_ASR_OFFSET1 : MU_ASR_OFFSET1;
 
 	reg = readl_relaxed(base + offset);
@@ -55,7 +56,7 @@ void MU_EnableRxFullInt(void __iomem *base, uint32_t index)
 {
 	uint32_t reg, offset;
 
-	offset = unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)
+	offset = unlikely(version == MU_VER_ID_V10)
 			  ? MU_V10_ACR_OFFSET1 : MU_ACR_OFFSET1;
 
 	reg = readl_relaxed(base + offset);
@@ -71,7 +72,7 @@ void MU_EnableGeneralInt(void __iomem *base, uint32_t index)
 {
 	uint32_t reg, offset;
 
-	offset = unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)
+	offset = unlikely(version == MU_VER_ID_V10)
 			  ? MU_V10_ACR_OFFSET1 : MU_ACR_OFFSET1;
 
 	reg = readl_relaxed(base + offset);
@@ -87,7 +88,7 @@ void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg)
 {
 	uint32_t mask = MU_SR_TE0_MASK1 >> regIndex;
 
-	if (unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)) {
+	if (unlikely(version == MU_VER_ID_V10)) {
 		/* Wait TX register to be empty. */
 		while (!(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask))
 			;
@@ -109,7 +110,7 @@ void MU_ReceiveMsg(void __iomem *base, uint32_t regIndex, uint32_t *msg)
 {
 	uint32_t mask = MU_SR_RF0_MASK1 >> regIndex;
 
-	if (unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)) {
+	if (unlikely(version == MU_VER_ID_V10)) {
 		/* Wait RX register to be full. */
 		while (!(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask))
 			;
@@ -129,9 +130,10 @@ void MU_Init(void __iomem *base)
 {
 	uint32_t reg, offset;
 
-	offset = unlikely((readl_relaxed(base) >> 16) == MU_VER_ID_V10)
-			  ? MU_V10_ACR_OFFSET1 : MU_ACR_OFFSET1;
+	version = readl_relaxed(base) >> 16;
 
+	offset = unlikely(version == MU_VER_ID_V10)
+			  ? MU_V10_ACR_OFFSET1 : MU_ACR_OFFSET1;
 
 	reg = readl_relaxed(base + offset);
 	/* Clear GIEn, RIEn, TIEn, GIRn and ABFn. */
-- 
1.7.9.5


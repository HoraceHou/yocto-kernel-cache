From 93bd29d2b1d94b9ad739494bcc57c000ab21ef02 Mon Sep 17 00:00:00 2001
From: Franck LENORMAND <franck.lenormand@nxp.com>
Date: Fri, 9 Nov 2018 18:21:35 +0100
Subject: [PATCH 5187/5242] MLK-20314: drivers: crypto: caam: alg: Enable GCM
 for newer LP CAAM

commit  fbcd6a0f3a5b09232c86a82ee2c609a60e643da3 from
https://source.codeaurora.org/external/imx/linux-imx.git

The iMX6 platform does not support fardware GCM, more
recent iMX does so we enable it.

Signed-off-by: Franck LENORMAND <franck.lenormand@nxp.com>
(cherry picked from commit 2a4e35399f37caff111d420866a9d4beb494e2e9)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/crypto/caam/caamalg.c |   40 ++++++++++++++++++++++++++++++++++++----
 1 file changed, 36 insertions(+), 4 deletions(-)

diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index 834a6fa..738113e 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -3653,6 +3653,33 @@ static void caam_aead_alg_init(struct caam_aead_alg *t_alg)
 	alg->exit = caam_aead_exit;
 }
 
+static bool caam_aes_support_gcm(const struct caam_drv_private *priv,
+				 u32 aes_vid, u32 aes_rn)
+{
+	/*
+	 * For ERA 10 and later, bit 9 of the AESA_VERSION register should be
+	 * used to detect presence of GCM.
+	 * For ERA 9 and earlier, the AESRNs 8, 9, and 10 with AESVID=3 all
+	 * have GCM.
+	 */
+	if (priv->era < 10) {
+		if (aes_vid == CHA_ID_LS_AES_LP) {
+			/* Only specific RN support GCM */
+			if (aes_rn >= 8)
+				return true;
+			else
+				return false;
+		} else {
+			/* AES HP support GCM */
+			return true;
+		}
+
+	} else {
+		/* We do not support ERA 10 for now */
+		return false;
+	}
+}
+
 static int __init caam_algapi_init(void)
 {
 	struct device_node *dev_node;
@@ -3661,6 +3688,7 @@ static int __init caam_algapi_init(void)
 	struct caam_drv_private *priv;
 	int i = 0, err = 0;
 	u32 cha_vid, cha_inst, des_inst, aes_inst, md_inst, arc4_inst;
+	u32 cha_rn;
 	unsigned int md_limit = SHA512_DIGEST_SIZE;
 	bool registered = false;
 
@@ -3709,9 +3737,11 @@ static int __init caam_algapi_init(void)
 		i = priv->first_jr_index;
 		cha_vid = rd_reg32(&priv->jr[i]->perfmon.cha_id_ls);
 		cha_inst = rd_reg32(&priv->jr[i]->perfmon.cha_num_ls);
+		cha_rn = rd_reg32(&priv->jr[i]->perfmon.cha_rev_ls);
 	} else {
 		cha_vid = rd_reg32(&priv->ctrl->perfmon.cha_id_ls);
 		cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+		cha_rn = rd_reg32(&priv->ctrl->perfmon.cha_rev_ls);
 	}
 	des_inst = (cha_inst & CHA_ID_LS_DES_MASK) >> CHA_ID_LS_DES_SHIFT;
 	aes_inst = (cha_inst & CHA_ID_LS_AES_MASK) >> CHA_ID_LS_AES_SHIFT;
@@ -3811,11 +3841,13 @@ static int __init caam_algapi_init(void)
 				continue;
 
 		/*
-		 * Check support for AES algorithms not available
-		 * on LP devices.
+		 * If we try to register gcm aes, check it is supported.
 		 */
-		if ((cha_vid & CHA_ID_LS_AES_MASK) == CHA_ID_LS_AES_LP)
-			if (alg_aai == OP_ALG_AAI_GCM)
+		if (c1_alg_sel == OP_ALG_ALGSEL_AES &&
+		    alg_aai == OP_ALG_AAI_GCM)
+			if (!caam_aes_support_gcm(priv,
+						  cha_vid & CHA_ID_LS_AES_MASK,
+						  cha_rn & CHA_ID_LS_AES_MASK))
 				continue;
 
 		/*
-- 
1.7.9.5


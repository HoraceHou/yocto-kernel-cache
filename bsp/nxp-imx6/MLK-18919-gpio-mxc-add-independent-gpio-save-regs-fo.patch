From e6e247783039d3cf12a4349a5492ec58a9935db2 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Mon, 16 Jul 2018 15:11:17 +0800
Subject: [PATCH 4165/5242] MLK-18919 gpio: mxc: add independent gpio save
 regs for noirq suspend/resume

commit  1fee453256891d23dc2e054b51c852670d4d98b6 from
https://source.codeaurora.org/external/imx/linux-imx.git

In system resume phase, the runtime resume will be called
after noirq resume, and the GPIO could be operated between
the noirq resume phase and the runtime resume phase, current
implementation of noirq suspend/resume shares same save
regs array with runtime suspend/resume, the GPIO operation
will be overwritten by runtime resume using old save regs
array, so adding independent gpio save regs for noirq
suspend/resume ONLY, and use noirq suspend/resume callback
instead of sharing runtime suspend/resume callback.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Reviewed-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpio/gpio-mxc.c |   59 ++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 58 insertions(+), 1 deletion(-)

diff --git a/drivers/gpio/gpio-mxc.c b/drivers/gpio/gpio-mxc.c
index 8b03ae5..7f57274 100644
--- a/drivers/gpio/gpio-mxc.c
+++ b/drivers/gpio/gpio-mxc.c
@@ -57,6 +57,7 @@ struct mxc_gpio_port {
 	struct device *dev;
 	u32 both_edges;
 	int saved_reg[6];
+	int suspend_saved_reg[6];
 	bool gpio_ranges;
 };
 
@@ -637,6 +638,62 @@ static int __maybe_unused mxc_gpio_runtime_resume(struct device *dev)
 	return 0;
 }
 
+static int __maybe_unused mxc_gpio_noirq_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mxc_gpio_port *port = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int ret;
+
+	if (mxc_gpio_hwtype == IMX21_GPIO)
+		return 0;
+
+	ret = clk_prepare_enable(port->clk);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&port->gc.bgpio_lock, flags);
+	port->suspend_saved_reg[0] = readl(port->base + GPIO_ICR1);
+	port->suspend_saved_reg[1] = readl(port->base + GPIO_ICR2);
+	port->suspend_saved_reg[2] = readl(port->base + GPIO_IMR);
+	port->suspend_saved_reg[3] = readl(port->base + GPIO_GDIR);
+	port->suspend_saved_reg[4] = readl(port->base + GPIO_EDGE_SEL);
+	port->suspend_saved_reg[5] = readl(port->base + GPIO_DR);
+	spin_unlock_irqrestore(&port->gc.bgpio_lock, flags);
+
+	clk_disable_unprepare(port->clk);
+
+	return 0;
+}
+
+static int __maybe_unused mxc_gpio_noirq_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mxc_gpio_port *port = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int ret;
+
+	if (mxc_gpio_hwtype == IMX21_GPIO)
+		return 0;
+
+	ret = clk_prepare_enable(port->clk);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&port->gc.bgpio_lock, flags);
+	writel(port->suspend_saved_reg[0], port->base + GPIO_ICR1);
+	writel(port->suspend_saved_reg[1], port->base + GPIO_ICR2);
+	writel(port->suspend_saved_reg[2], port->base + GPIO_IMR);
+	writel(port->suspend_saved_reg[3], port->base + GPIO_GDIR);
+	writel(port->suspend_saved_reg[4], port->base + GPIO_EDGE_SEL);
+	writel(port->suspend_saved_reg[5], port->base + GPIO_DR);
+	spin_unlock_irqrestore(&port->gc.bgpio_lock, flags);
+
+	clk_disable_unprepare(port->clk);
+
+	return 0;
+}
+
 static int __maybe_unused mxc_gpio_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -663,7 +720,7 @@ static int __maybe_unused mxc_gpio_resume(struct device *dev)
 
 static const struct dev_pm_ops mxc_gpio_dev_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(mxc_gpio_suspend, mxc_gpio_resume)
-	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(mxc_gpio_runtime_suspend, mxc_gpio_runtime_resume)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(mxc_gpio_noirq_suspend, mxc_gpio_noirq_resume)
 	SET_RUNTIME_PM_OPS(mxc_gpio_runtime_suspend,
 			mxc_gpio_runtime_resume, NULL)
 };
-- 
1.7.9.5


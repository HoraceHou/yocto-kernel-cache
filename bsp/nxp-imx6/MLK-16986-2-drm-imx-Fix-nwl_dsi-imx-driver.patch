From e054e0dc6bc3dfc4fa4f7f1427f574b9d6556c98 Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Tue, 5 Dec 2017 09:34:14 +0200
Subject: [PATCH 2994/5242] MLK-16986-2: drm/imx: Fix nwl_dsi-imx driver

commit  42047bd0d30dc1bf09e159add29b97458de8b3fb from
https://source.codeaurora.org/external/imx/linux-imx.git

Since the ADV7535 can change the DSI lanes used in mode_set, we need to
set up the Mixel PHY speed again, in enable() function, so that we will
take into account the new DSI lanes.

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Reviewed-by: Laurentiu Palcu <laurentiu.palcu@nxp.com
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/nwl_dsi-imx.c |   25 ++++++++++++++++++++++++-
 1 file changed, 24 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/imx/nwl_dsi-imx.c b/drivers/gpu/drm/imx/nwl_dsi-imx.c
index 0d19649..b03b13f 100644
--- a/drivers/gpu/drm/imx/nwl_dsi-imx.c
+++ b/drivers/gpu/drm/imx/nwl_dsi-imx.c
@@ -87,6 +87,7 @@ struct imx_mipi_dsi {
 	u32 pxl2dpi_reg;
 
 	unsigned long			bit_clk;
+	unsigned long			pix_clk;
 	u32				phyref_rate;
 	u32				instance;
 	u32				sync_pol;
@@ -465,6 +466,7 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 	const struct of_device_id *of_id = of_match_device(imx_nwl_dsi_dt_ids,
 							   dev);
 	const struct devtype *devtype = of_id->data;
+	unsigned long bit_clk;
 	int ret;
 
 	if (dsi->enabled)
@@ -472,6 +474,25 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 
 	DRM_DEV_INFO(dev, "id = %s\n", (dsi->instance)?"DSI1":"DSI0");
 
+	/*
+	 * TODO: we are doing this here, because the ADV7535 which is a drm
+	 * bridge, may change the DSI parameters in mode_set. One of the
+	 * changed parameter is DSI lanes, which affects the PHY settings.
+	 * This is why, we need run this function again, here, in order
+	 * to correctly set-up the PHY. Since we can't do anything here, we
+	 * will ignore it's status.
+	 * In the future, maybe it will be best to move the PHY handling
+	 * into the DSI host driver.
+	 */
+	bit_clk = nwl_dsi_get_bit_clock(dsi->next_bridge, dsi->pix_clk);
+	if (bit_clk != dsi->bit_clk) {
+		mixel_phy_mipi_set_phy_speed(dsi->phy,
+			bit_clk,
+			dsi->phyref_rate,
+			false);
+		dsi->bit_clk = bit_clk;
+	}
+
 	imx_nwl_dsi_set_clocks(dsi, true);
 
 	ret = devtype->poweron(dsi);
@@ -563,8 +584,10 @@ static int imx_nwl_try_phy_speed(struct imx_mipi_dsi *dsi,
 			mode->clock);
 		DRM_DEV_ERROR(dev, "PHY_REF clk: %u, bit clk: %lu\n",
 			dsi->phyref_rate, bit_clk);
-	} else
+	} else {
 		dsi->bit_clk = bit_clk;
+		dsi->pix_clk = pixclock;
+	}
 
 	return ret;
 }
-- 
1.7.9.5


From 06414b1548e61363aec3f854975d48892f1afdf5 Mon Sep 17 00:00:00 2001
From: Han Xu <han.xu@nxp.com>
Date: Fri, 31 Aug 2018 15:05:39 -0500
Subject: [PATCH 4508/5242] MLK-19425: mtd: fsl-flexspi: fix flexspi runtime
 pm re-entrance issue

commit  af7058aa2f1a3c4b8257e8456f836738c048a8ec from
https://source.codeaurora.org/external/imx/linux-imx.git

move the runtime pm get/put functions from nor_setup/nor_setup_last to
probe function to avoid runtime pm re-entrance issue.

Signed-off-by: Han Xu <han.xu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mtd/spi-nor/fsl-flexspi.c |   41 ++++++++++++++++---------------------
 1 file changed, 18 insertions(+), 23 deletions(-)

diff --git a/drivers/mtd/spi-nor/fsl-flexspi.c b/drivers/mtd/spi-nor/fsl-flexspi.c
index 1deb0e5..2bd1580 100644
--- a/drivers/mtd/spi-nor/fsl-flexspi.c
+++ b/drivers/mtd/spi-nor/fsl-flexspi.c
@@ -945,13 +945,6 @@ static int fsl_flexspi_nor_setup(struct fsl_flexspi *flex)
 {
 	void __iomem *base = flex->iobase;
 	u32 reg;
-	int ret;
-
-	ret = pm_runtime_get_sync(flex->dev);
-	if (ret < 0) {
-		dev_err(flex->dev, "Failed to enable clock %d\n", __LINE__);
-		return ret;
-	}
 
 	/* Reset the module */
 	writel(FLEXSPI_MCR0_SWRST_MASK, base + FLEXSPI_MCR0);
@@ -975,9 +968,6 @@ static int fsl_flexspi_nor_setup(struct fsl_flexspi *flex)
 	/* enable the interrupt */
 	writel(FLEXSPI_INTEN_IPCMDDONE_MASK, flex->iobase + FLEXSPI_INTEN);
 
-	pm_runtime_mark_last_busy(flex->dev);
-	pm_runtime_put_autosuspend(flex->dev);
-
 	return 0;
 }
 
@@ -986,12 +976,6 @@ static int fsl_flexspi_nor_setup_last(struct fsl_flexspi *flex)
 	unsigned long rate = flex->clk_rate;
 	int ret;
 
-	ret = pm_runtime_get_sync(flex->dev);
-	if (ret < 0) {
-		dev_err(flex->dev, "Failed to enable clock %d\n", __LINE__);
-		return ret;
-	}
-
 	/* disable and unprepare clock to avoid glitch pass to controller */
 	fsl_flexspi_clk_disable_unprep(flex);
 
@@ -1009,9 +993,6 @@ static int fsl_flexspi_nor_setup_last(struct fsl_flexspi *flex)
 	/* Init for AHB read */
 	fsl_flexspi_init_ahb_read(flex);
 
-	pm_runtime_mark_last_busy(flex->dev);
-	pm_runtime_put_autosuspend(flex->dev);
-
 	return 0;
 }
 
@@ -1249,7 +1230,7 @@ static int fsl_flexspi_probe(struct platform_device *pdev)
 	if (ret)
 		flex->ddr_smp = 0;
 
-	/* enable the clock */
+	/* enable the rpm*/
 	ret = fsl_flexspi_init_rpm(flex);
 	if (ret) {
 		dev_err(dev, "can not enable the clock\n");
@@ -1260,19 +1241,27 @@ static int fsl_flexspi_probe(struct platform_device *pdev)
 	ret = platform_get_irq(pdev, 0);
 	if (ret < 0) {
 		dev_err(dev, "failed to get the irq: %d\n", ret);
-		goto clk_failed;
+		goto rpm_failed;
 	}
 
 	ret = devm_request_irq(dev, ret,
 			fsl_flexspi_irq_handler, 0, pdev->name, flex);
 	if (ret) {
 		dev_err(dev, "failed to request irq: %d\n", ret);
-		goto clk_failed;
+		goto rpm_failed;
+	}
+
+	/* enable the clock*/
+	ret = pm_runtime_get_sync(flex->dev);
+	if (ret < 0) {
+		dev_err(flex->dev, "Failed to enable clock %d\n", __LINE__);
+		goto rpm_failed;
 	}
 
+
 	ret = fsl_flexspi_nor_setup(flex);
 	if (ret)
-		goto clk_failed;
+		goto rpm_failed;
 
 	if (of_get_property(np, "fsl,qspi-has-second-chip", NULL))
 		flex->has_second_chip = true;
@@ -1358,6 +1347,9 @@ static int fsl_flexspi_probe(struct platform_device *pdev)
 	if (ret)
 		goto last_init_failed;
 
+	pm_runtime_mark_last_busy(flex->dev);
+	pm_runtime_put_autosuspend(flex->dev);
+
 	/* indicate the controller has been initialized */
 	flex->flags |= FLEXSPI_INITILIZED;
 
@@ -1372,6 +1364,9 @@ static int fsl_flexspi_probe(struct platform_device *pdev)
 	}
 mutex_failed:
 	mutex_destroy(&flex->lock);
+rpm_failed:
+	pm_runtime_dont_use_autosuspend(flex->dev);
+	pm_runtime_disable(flex->dev);
 clk_failed:
 	dev_err(dev, "Freescale FlexSPI probe failed\n");
 	return ret;
-- 
1.7.9.5


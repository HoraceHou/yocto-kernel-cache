From ad5ec135b2dfece3e0c56d448b72bd96ae61a1b6 Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Wed, 17 Oct 2018 12:01:36 +0800
Subject: [PATCH 5000/5242] MLK-19957-2: ISI: remove hardware reset for isi

commit  cf1c9d340ec06288cfff4743ee7bbd162177c000 from
https://source.codeaurora.org/external/imx/linux-imx.git

Power off some resource of ISI can't really hardware reset
ISI, because all eight ISI channels share one hardware reset.
For example, if we enable ISI channel 0 and 1 in dts and only
power off and on channel0 domain, it will not really reset and
the value of channel0 register will not change.

Hardware reset was introduced for fixing ISI can't receive data
from CI_PI after system boot in QXP A0 and this is fixed in new
version QXP B0, so remove HW reset in driver.

Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
(cherry picked from commit df9da83f82c94ca578303b45c60fb17da2d9d1aa)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/mxc-isi-hw.c |   60 ------------------------------
 1 file changed, 60 deletions(-)

diff --git a/drivers/media/platform/imx8/mxc-isi-hw.c b/drivers/media/platform/imx8/mxc-isi-hw.c
index 0c592a6..0d100cb 100644
--- a/drivers/media/platform/imx8/mxc-isi-hw.c
+++ b/drivers/media/platform/imx8/mxc-isi-hw.c
@@ -186,63 +186,6 @@ void mxc_isi_channel_set_m2m_src_addr(struct mxc_isi_dev *mxc_isi,
 	writel(paddr->y, mxc_isi->regs + CHNL_IN_BUF_ADDR);
 }
 
-void mxc_isi_channel_hw_reset(struct mxc_isi_dev *mxc_isi)
-{
-	sc_ipc_t ipcHndl;
-	sc_err_t sciErr;
-	uint32_t mu_id, ch_id, i;
-	uint8_t chan_mask = 0, temp_mask;
-	struct device_node *parent, *node;
-
-	sciErr = sc_ipc_getMuID(&mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		pr_err("Cannot obtain MU ID\n");
-		return;
-	}
-
-	sciErr = sc_ipc_open(&ipcHndl, mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
-		return;
-	}
-
-	parent = of_get_parent(mxc_isi->pdev->dev.of_node);
-	if (!parent) {
-		dev_err(&mxc_isi->pdev->dev, "get parent device fail\n");
-		return;
-	}
-
-	for_each_available_child_of_node(parent, node) {
-		if (!strcmp(node->name, ISI_OF_NODE_NAME)) {
-			ch_id = of_alias_get_id(node, "isi");
-			chan_mask |= 1 << ch_id;
-		}
-	}
-
-	temp_mask = chan_mask;
-	for (i = 0; i < 8; i++) {
-		if (chan_mask & 0x1) {
-			sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_ISI_CH0 + i, SC_PM_PW_MODE_OFF);
-			if (sciErr != SC_ERR_NONE)
-				pr_err("power on ISI%d failed! (sciError = %d)\n", i, sciErr);
-		}
-		chan_mask >>= 1;
-	}
-
-	chan_mask = temp_mask;
-	for (i = 0; i < 8; i++) {
-		if (chan_mask & 0x1) {
-			sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_ISI_CH0 + i, SC_PM_PW_MODE_ON);
-			if (sciErr != SC_ERR_NONE)
-				pr_err("power off ISI%d failed! (sciError = %d)\n", i, sciErr);
-		}
-		chan_mask >>= 1;
-	}
-
-	udelay(500);
-	sc_ipc_close(mu_id);
-}
-
 void mxc_isi_channel_sw_reset(struct mxc_isi_dev *mxc_isi)
 {
 	u32 val;
@@ -573,9 +516,6 @@ void mxc_isi_channel_init(struct mxc_isi_dev *mxc_isi)
 {
 	u32 val;
 
-	/* hw reset */
-	mxc_isi_channel_hw_reset(mxc_isi);
-
 	/* sw reset */
 	mxc_isi_channel_sw_reset(mxc_isi);
 
-- 
1.7.9.5


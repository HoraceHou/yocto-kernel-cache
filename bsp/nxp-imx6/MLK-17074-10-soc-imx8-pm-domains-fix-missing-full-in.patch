From 06d0653ad62feac05ddf19a4bbc555eaa7bc08f0 Mon Sep 17 00:00:00 2001
From: Dong Aisheng <aisheng.dong@nxp.com>
Date: Mon, 27 Nov 2017 20:12:36 +0800
Subject: [PATCH 2965/5242] MLK-17074-10 soc: imx8: pm-domains: fix missing
 full intialization for root domain nodes

commit  d594822cf80a57cbf7e98b7ad3b909a6c57c999f from
https://source.codeaurora.org/external/imx/linux-imx.git

Current power domain driver only setup all domain callbacks during second
level power domains intialization. However, there're also some root power
domain nodes having valid SC resource handler which may be used by device
as well. Missing to setup them may result in some features lost on these
domains.
e.g.
pd_dc0: PD_DC_0 {
	compatible = "nxp,imx8-pd";
	reg = <SC_R_DC_0>;
	#power-domain-cells = <0>;
	#address-cells = <1>;
	#size-cells = <0>;
	...
}

Reviewed-by: Frank Li <frank.li@nxp.com>
Reviewed-by: Ranjani Vaidyanathan <Ranjani.Vaidyanathan@nxp.com>
Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>

During 4.14 rebase added dynamic allocation of genpd.states, required by
upstream commit 59d65b73a23c ("PM / Domains: Make genpd state allocation dynamic")

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/pm-domains.c |   37 ++++++++++++++++++++++---------------
 1 file changed, 22 insertions(+), 15 deletions(-)

diff --git a/drivers/soc/imx/pm-domains.c b/drivers/soc/imx/pm-domains.c
index 23257b3..cb4d414 100644
--- a/drivers/soc/imx/pm-domains.c
+++ b/drivers/soc/imx/pm-domains.c
@@ -219,6 +219,24 @@ struct syscore_ops imx8_pm_domains_syscore_ops = {
 	.resume = imx8_pm_domains_resume,
 };
 
+static void imx8_pd_setup(struct imx8_pm_domain *pd)
+{
+	pd->pd.states = kzalloc(2 * sizeof(struct genpd_power_state), GFP_KERNEL);
+	BUG_ON(!pd->pd.states);
+
+	pd->pd.power_off = imx8_pd_power_off;
+	pd->pd.power_on = imx8_pd_power_on;
+	pd->pd.attach_dev = imx8_attach_dev;
+	pd->pd.detach_dev = imx8_detach_dev;
+
+	pd->pd.states[0].power_off_latency_ns = 25000;
+	pd->pd.states[0].power_on_latency_ns =  25000;
+	pd->pd.states[1].power_off_latency_ns = 2500000;
+	pd->pd.states[1].power_on_latency_ns =  2500000;
+
+	pd->pd.state_count = 2;
+}
+
 static int __init imx8_add_pm_domains(struct device_node *parent,
 					struct generic_pm_domain *genpd_parent)
 {
@@ -244,17 +262,7 @@ static int __init imx8_add_pm_domains(struct device_node *parent,
 			imx8_pd->rsrc_id = rsrc_id;
 
 		if (imx8_pd->rsrc_id != SC_R_LAST) {
-			imx8_pd->pd.power_off = imx8_pd_power_off;
-			imx8_pd->pd.power_on = imx8_pd_power_on;
-			imx8_pd->pd.attach_dev = imx8_attach_dev;
-			imx8_pd->pd.detach_dev = imx8_detach_dev;
-
-			imx8_pd->pd.states[0].power_off_latency_ns = 25000;
-			imx8_pd->pd.states[0].power_on_latency_ns =  25000;
-			imx8_pd->pd.states[1].power_off_latency_ns = 2500000;
-			imx8_pd->pd.states[1].power_on_latency_ns =  2500000;
-
-			imx8_pd->pd.state_count = 2;
+			imx8_pd_setup(imx8_pd);
 
 			if (of_property_read_bool(np, "early_power_on")
 				&& index < (sizeof(early_power_on_rsrc) /
@@ -311,10 +319,9 @@ static int __init imx8_init_pm_domains(void)
 		if (!of_property_read_u32(np, "reg", &rsrc_id))
 			imx8_pd->rsrc_id = rsrc_id;
 
-		if (imx8_pd->rsrc_id != SC_R_LAST) {
-			imx8_pd->pd.power_off = imx8_pd_power_off;
-			imx8_pd->pd.power_on = imx8_pd_power_on;
-		}
+		if (imx8_pd->rsrc_id != SC_R_LAST)
+			imx8_pd_setup(imx8_pd);
+
 		INIT_LIST_HEAD(&imx8_pd->clks);
 
 		pm_genpd_init(&imx8_pd->pd, NULL, true);
-- 
1.7.9.5


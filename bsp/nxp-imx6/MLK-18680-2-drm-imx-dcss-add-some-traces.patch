From f36f0897ce09ab5932ccc39e5b4d086c09aed041 Mon Sep 17 00:00:00 2001
From: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Date: Mon, 25 Jun 2018 13:50:30 +0300
Subject: [PATCH 4077/5242] MLK-18680-2: drm: imx: dcss: add some traces

commit  881e1d14d9dde7adf275045b28bb6f594a864e6d from
https://source.codeaurora.org/external/imx/linux-imx.git

This patch will add traces for the following events:
 * CTXLD arm, completion and kick;
 * VBLANKs;
 * atomic flushes;
 * plane updates (printing the DPR buffer base address);

These will allow us to measure and analyze where bottlenecks are:
application or driver.

Signed-off-by: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/dcss/dcss-crtc.c |    7 +++++++
 drivers/gpu/imx/dcss/dcss-ctxld.c    |   12 ++++++++++++
 drivers/gpu/imx/dcss/dcss-dpr.c      |    2 ++
 3 files changed, 21 insertions(+)

diff --git a/drivers/gpu/drm/imx/dcss/dcss-crtc.c b/drivers/gpu/drm/imx/dcss/dcss-crtc.c
index 6a23f06..ad8d585 100644
--- a/drivers/gpu/drm/imx/dcss/dcss-crtc.c
+++ b/drivers/gpu/drm/imx/dcss/dcss-crtc.c
@@ -28,6 +28,9 @@
 #include "imx-drm.h"
 #include "dcss-crtc.h"
 
+#define TRACE_FLUSH	0
+#define TRACE_VBLANK	1
+
 struct dcss_crtc {
 	struct device *dev;
 	struct drm_crtc		base;
@@ -155,6 +158,8 @@ static void dcss_crtc_atomic_flush(struct drm_crtc *crtc,
 						   base);
 	struct dcss_soc *dcss = dev_get_drvdata(dcss_crtc->dev->parent);
 
+	dcss_trace_module(TRACE_DRM_CRTC, TRACE_FLUSH);
+
 	if (dcss_dtg_is_enabled(dcss))
 		dcss_ctxld_enable(dcss);
 }
@@ -286,6 +291,8 @@ static irqreturn_t dcss_crtc_irq_handler(int irq, void *dev_id)
 	struct dcss_crtc *dcss_crtc = dev_id;
 	struct dcss_soc *dcss = dev_get_drvdata(dcss_crtc->dev->parent);
 
+	dcss_trace_module(TRACE_DRM_CRTC, TRACE_VBLANK);
+
 	if (dcss_ctxld_is_flushed(dcss))
 		drm_crtc_handle_vblank(&dcss_crtc->base);
 
diff --git a/drivers/gpu/imx/dcss/dcss-ctxld.c b/drivers/gpu/imx/dcss/dcss-ctxld.c
index a42a969..076c427 100644
--- a/drivers/gpu/imx/dcss/dcss-ctxld.c
+++ b/drivers/gpu/imx/dcss/dcss-ctxld.c
@@ -65,6 +65,10 @@
 #define CTXLD_SB_CTX_ENTRIES		(CTXLD_SB_LP_CTX_ENTRIES + \
 					 CTXLD_SB_HP_CTX_ENTRIES)
 
+#define TRACE_ARM			(1LL << 48)
+#define TRACE_IRQ			(2LL << 48)
+#define TRACE_KICK			(3LL << 48)
+
 static struct dcss_debug_reg ctxld_debug_reg[] = {
 	DCSS_DBG_REG(DCSS_CTXLD_CONTROL_STATUS),
 	DCSS_DBG_REG(DCSS_CTXLD_DB_BASE_ADDR),
@@ -141,6 +145,8 @@ static irqreturn_t dcss_ctxld_irq_handler(int irq, void *data)
 	    !(irq_status & CTXLD_ENABLE) && priv->in_use) {
 		priv->in_use = false;
 
+		dcss_trace_module(TRACE_CTXLD,
+				  TRACE_IRQ | (priv->current_ctx ^ 1));
 
 		if (priv->dcss->dcss_disable_callback) {
 			struct dcss_dtg_priv *dtg = priv->dcss->dtg_priv;
@@ -325,6 +331,10 @@ static int __dcss_ctxld_enable(struct dcss_ctxld_priv *ctxld)
 	dcss_writel(sb_base, ctxld->ctxld_reg + DCSS_CTXLD_SB_BASE_ADDR);
 	dcss_writel(sb_count, ctxld->ctxld_reg + DCSS_CTXLD_SB_COUNT);
 
+	dcss_trace_module(TRACE_CTXLD,
+			  TRACE_ARM | db_cnt | (sb_count << 16) |
+			  ((u64)ctxld->current_ctx << 32));
+
 	/* enable the context loader */
 	dcss_set(CTXLD_ENABLE, ctxld->ctxld_reg + DCSS_CTXLD_CONTROL_STATUS);
 
@@ -369,6 +379,8 @@ void dcss_ctxld_kick(struct dcss_soc *dcss)
 	struct dcss_ctxld_priv *ctxld = dcss->ctxld_priv;
 	unsigned long flags;
 
+	dcss_trace_module(TRACE_CTXLD, TRACE_KICK);
+
 	spin_lock_irqsave(&ctxld->lock, flags);
 	if (ctxld->armed) {
 		ctxld->armed = false;
diff --git a/drivers/gpu/imx/dcss/dcss-dpr.c b/drivers/gpu/imx/dcss/dcss-dpr.c
index 50bb921..7df0b9d 100644
--- a/drivers/gpu/imx/dcss/dcss-dpr.c
+++ b/drivers/gpu/imx/dcss/dcss-dpr.c
@@ -311,6 +311,8 @@ void dcss_dpr_addr_set(struct dcss_soc *dcss, int ch_num, u32 luma_base_addr,
 {
 	struct dcss_dpr_ch *ch = &dcss->dpr_priv->ch[ch_num];
 
+	dcss_trace_module(TRACE_DPR, ((u64)ch_num << 32) | luma_base_addr);
+
 	if (ch->use_dtrc) {
 		luma_base_addr = 0x0;
 		chroma_base_addr = 0x10000000;
-- 
1.7.9.5


From e06bee1fd23955630549c28e57fdbb0392bdef1a Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Fri, 8 Dec 2017 16:21:33 +0200
Subject: [PATCH 3057/5242] MLK-17047-2: drm/imx: Fix suspend/resume for
 nwl_dsi-imx

commit  afed4bac77851a823c6d3043351fda99091ae324 from
https://source.codeaurora.org/external/imx/linux-imx.git

This patch addresses two issues:
1. Always request/release bus_freq, not just on suspend/resume routines
2. Check if the driver is running when doing a suspend, so that we won't
enable it by mistake on resume.

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/nwl_dsi-imx.c |   21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/imx/nwl_dsi-imx.c b/drivers/gpu/drm/imx/nwl_dsi-imx.c
index cf2ad9c..1dc5c6b 100644
--- a/drivers/gpu/drm/imx/nwl_dsi-imx.c
+++ b/drivers/gpu/drm/imx/nwl_dsi-imx.c
@@ -93,6 +93,7 @@ struct imx_mipi_dsi {
 	u32				sync_pol;
 	u32				power_on_delay;
 	bool				enabled;
+	bool				suspended;
 };
 
 struct clk_config {
@@ -508,6 +509,8 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 		usleep_range(min_sleep, max_sleep);
 	}
 
+	request_bus_freq(BUS_FREQ_HIGH);
+
 	imx_nwl_dsi_set_clocks(dsi, true);
 
 	ret = devtype->poweron(dsi);
@@ -535,6 +538,8 @@ static void imx_nwl_dsi_disable(struct imx_mipi_dsi *dsi)
 
 	imx_nwl_dsi_set_clocks(dsi, false);
 
+	release_bus_freq(BUS_FREQ_HIGH);
+
 	dsi->enabled = false;
 }
 
@@ -956,12 +961,14 @@ static int imx_nwl_dsi_remove(struct platform_device *pdev)
 static int imx_nwl_suspend(struct device *dev)
 {
 	struct imx_mipi_dsi *dsi = dev_get_drvdata(dev);
-	bool enabled = dsi->enabled;
 
-	if (enabled && dsi->next_bridge)
+	if (!dsi->enabled)
+		return 0;
+
+	if (dsi->next_bridge)
 		drm_bridge_disable(dsi->next_bridge);
 	imx_nwl_dsi_disable(dsi);
-	release_bus_freq(BUS_FREQ_HIGH);
+	dsi->suspended = true;
 
 	return 0;
 }
@@ -969,12 +976,14 @@ static int imx_nwl_suspend(struct device *dev)
 static int imx_nwl_resume(struct device *dev)
 {
 	struct imx_mipi_dsi *dsi = dev_get_drvdata(dev);
-	bool enabled = dsi->enabled;
 
-	request_bus_freq(BUS_FREQ_HIGH);
+	if (!dsi->suspended)
+		return 0;
+
 	imx_nwl_dsi_enable(dsi);
-	if (!enabled && dsi->next_bridge)
+	if (dsi->next_bridge)
 		drm_bridge_enable(dsi->next_bridge);
+	dsi->suspended = false;
 
 	return 0;
 }
-- 
1.7.9.5


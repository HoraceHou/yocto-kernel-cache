From 76910e514d5fd0a22aa42a5f159bd984edf6aa7c Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Fri, 26 Oct 2018 15:30:34 +0800
Subject: [PATCH 4951/5242] MLK-20099-2 PCI: imx: use ext osc as pcie refclk
 on 8mm

commit  36e0b62e9c29eab8f5e6c7dd08c2f470b228d28b from
https://source.codeaurora.org/external/imx/linux-imx.git

Use the external osc as the pcie refclk on 8mm evk board.
- Do not turn off the over ride of rc's clkreq#, when
L1SS is not enabled.
NOTE: L1SS_EN would be set at both RC and EP by
pcie_config_aspm_link when the L1SS is supported
by the link.

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/controller/dwc/pci-imx6.c |   53 ++++++++++++++++++---------------
 1 file changed, 29 insertions(+), 24 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index 7a40ed2..771cc7c 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -277,6 +277,8 @@ struct imx_pcie {
 #define IMX8MQ_PCIE_CTRL_APPS_CLK_REQ		BIT(4)
 #define IMX8MQ_PCIE_CTRL_APPS_EN		BIT(6)
 #define IMX8MQ_PCIE_CTRL_APPS_TURNOFF		BIT(11)
+#define IMX8MQ_PCIE_L1SUB_CTRL1_REG_OFFSET	0x170
+#define IMX8MQ_PCIE_L1SUB_CTRL1_REG_EN_MASK	0xF
 
 #define IMX8MQ_GPC_PGC_CPU_0_1_MAPPING_OFFSET	0xEC
 #define IMX8MQ_GPC_PU_PGC_SW_PUP_REQ_OFFSET	0xF8
@@ -1618,7 +1620,6 @@ static int imx_pcie_establish_link(struct imx_pcie *imx_pcie)
 
 static int imx_pcie_host_init(struct pcie_port *pp)
 {
-	u32 val;
 	int ret;
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 	struct imx_pcie *imx_pcie = to_imx_pcie(pci);
@@ -1637,28 +1638,6 @@ static int imx_pcie_host_init(struct pcie_port *pp)
 		ret = imx_pcie_establish_link(imx_pcie);
 		if (ret < 0)
 			return ret;
-		if (!IS_ENABLED(CONFIG_RC_MODE_IN_EP_RC_SYS)) {
-			/*
-			 * Disable the over ride after link up.
-			 * Let the the CLK_REQ# controlled by HW L1SS
-			 * automatically.
-			 */
-			switch (imx_pcie->variant) {
-			case IMX8MQ:
-			case IMX8MM:
-				if (imx_pcie->ctrl_id == 0)
-					val = IOMUXC_GPR14;
-				else
-					val = IOMUXC_GPR16;
-
-				regmap_update_bits(imx_pcie->iomuxc_gpr, val,
-					IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN,
-					0);
-				break;
-			default:
-				break;
-			}
-		}
 
 		if (IS_ENABLED(CONFIG_PCI_MSI))
 			dw_pcie_msi_init(pp);
@@ -2272,7 +2251,7 @@ static int imx_pcie_probe(struct platform_device *pdev)
 	struct resource *res, reserved_res;
 	struct device_node *reserved_node, *node = dev->of_node;
 	int ret;
-	u16 val;
+	u32 val;
 
 	imx_pcie = devm_kzalloc(dev, sizeof(*imx_pcie), GFP_KERNEL);
 	if (!imx_pcie)
@@ -2785,6 +2764,32 @@ static int imx_pcie_probe(struct platform_device *pdev)
 			}
 			return ret;
 		}
+		/*
+		 * If the L1SS is enabled,
+		 * disable the over ride after link up.
+		 * Let the the CLK_REQ# controlled by HW L1SS
+		 * automatically.
+		 */
+		switch (imx_pcie->variant) {
+		case IMX8MQ:
+		case IMX8MM:
+			val = readl(pci->dbi_base +
+					IMX8MQ_PCIE_L1SUB_CTRL1_REG_OFFSET);
+			if (val & IMX8MQ_PCIE_L1SUB_CTRL1_REG_EN_MASK) {
+				if (imx_pcie->ctrl_id == 0)
+					val = IOMUXC_GPR14;
+				else
+					val = IOMUXC_GPR16;
+
+				regmap_update_bits(imx_pcie->iomuxc_gpr, val,
+					IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN,
+					0);
+			}
+			break;
+		default:
+			break;
+		}
+
 		if (IS_ENABLED(CONFIG_RC_MODE_IN_EP_RC_SYS)
 				&& (imx_pcie->hard_wired == 0))
 			imx_pcie_regions_setup(&pdev->dev);
-- 
1.7.9.5


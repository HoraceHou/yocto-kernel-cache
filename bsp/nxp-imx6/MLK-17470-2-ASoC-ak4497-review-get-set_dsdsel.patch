From 89cfdf072185520bacb9008b8d9767703a509c0a Mon Sep 17 00:00:00 2001
From: Viorel Suman <viorel.suman@nxp.com>
Date: Thu, 1 Feb 2018 11:33:27 +0200
Subject: [PATCH 3407/5242] MLK-17470-2: ASoC: ak4497: review get/set_dsdsel

commit  2c74c508321d24efbe2c88e1de16c113e4d87f47 from
https://source.codeaurora.org/external/imx/linux-imx.git

With commit 69201427e188 ("MLK-17470: ASoC: ak4497: automatically select dsdsel
in driver") the "ak4497_priv.nDSDSel" field might not reflect the real dsdsel
option. In order to simplify the approach and avoid future inconsistencies the
field is removed and dsdsel option is read/stored directly to/from codec
registers. Aside of this a missing dsdsel option for 22.5792MHz is introduced
in "ak4497_set_dsdsel" method, now this method being fully compatible with
commit 69201427e188 ("MLK-17470: ASoC: ak4497: automatically select dsdsel in
driver").

Signed-off-by: Viorel Suman <viorel.suman@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/codecs/ak4497.c |   32 ++++++++++++++++++++++----------
 1 file changed, 22 insertions(+), 10 deletions(-)

diff --git a/sound/soc/codecs/ak4497.c b/sound/soc/codecs/ak4497.c
index 1eb6d40..a184755 100644
--- a/sound/soc/codecs/ak4497.c
+++ b/sound/soc/codecs/ak4497.c
@@ -37,7 +37,6 @@ struct ak4497_priv {
 	struct regmap *regmap;
 	int fs1;	/* Sampling Frequency */
 	int nBickFreq;	/* 0: 48fs for 24bit,  1: 64fs or more for 32bit */
-	int nDSDSel;
 	int nTdmSds;
 	int pdn_gpio;
 	int mute_gpio;
@@ -170,9 +169,15 @@ static int ak4497_get_dsdsel(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_value  *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
-	struct ak4497_priv *ak4497 = snd_soc_codec_get_drvdata(codec);
+	u8 dsdsel0, dsdsel1;
+
+	dsdsel0 = snd_soc_read(codec, AK4497_06_DSD1);
+	dsdsel0 &= AK4497_DSDSEL0;
 
-	ucontrol->value.enumerated.item[0] = ak4497->nDSDSel;
+	dsdsel1 = snd_soc_read(codec, AK4497_09_DSD2);
+	dsdsel1 &= AK4497_DSDSEL1;
+
+	ucontrol->value.enumerated.item[0] = ((dsdsel1 << 1) | dsdsel0);
 
 	return 0;
 }
@@ -181,19 +186,27 @@ static int ak4497_set_dsdsel(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_value  *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
-	struct ak4497_priv *ak4497 = snd_soc_codec_get_drvdata(codec);
-
-	ak4497->nDSDSel = ucontrol->value.enumerated.item[0];
+	unsigned int dsdsel = ucontrol->value.enumerated.item[0];
 
-	if (ak4497->nDSDSel == 0) { /* 2.8224MHz */
+	switch (dsdsel) {
+	case 0: /* 2.8224MHz */
 		snd_soc_update_bits(codec, AK4497_06_DSD1, 0x01, 0x00);
 		snd_soc_update_bits(codec, AK4497_09_DSD2, 0x01, 0x00);
-	} else if (ak4497->nDSDSel == 1) { /* 5.6448MHz */
+		break;
+	case 1:  /* 5.6448MHz */
 		snd_soc_update_bits(codec, AK4497_06_DSD1, 0x01, 0x01);
 		snd_soc_update_bits(codec, AK4497_09_DSD2, 0x01, 0x00);
-	} else { /* 11.2896MHz */
+		break;
+	case 2: /* 11.2896MHz */
 		snd_soc_update_bits(codec, AK4497_06_DSD1, 0x01, 0x00);
 		snd_soc_update_bits(codec, AK4497_09_DSD2, 0x01, 0x01);
+		break;
+	case 3: /* 22.5792MHz */
+		snd_soc_update_bits(codec, AK4497_06_DSD1, 0x01, 0x01);
+		snd_soc_update_bits(codec, AK4497_09_DSD2, 0x01, 0x01);
+		break;
+	default:
+		return -EINVAL;
 	}
 
 	return 0;
@@ -873,7 +886,6 @@ static int ak4497_probe(struct snd_soc_codec *codec)
 
 	ak4497->fs1 = 48000;
 	ak4497->nBickFreq = 1;
-	ak4497->nDSDSel = 0;
 	ak4497->nTdmSds = 0;
 
 	return ret;
-- 
1.7.9.5


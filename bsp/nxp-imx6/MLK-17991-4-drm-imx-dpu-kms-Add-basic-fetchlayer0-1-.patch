From 2b564f4b8051dec7717bf0d27c9cc21720770873 Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Mon, 9 Apr 2018 17:35:29 +0800
Subject: [PATCH 3584/5242] MLK-17991-4 drm/imx: dpu: kms: Add basic
 fetchlayer0/1 support

commit  f710ad2fafa38df325f6e9a64664cd422a04692b from
https://source.codeaurora.org/external/imx/linux-imx.git

This patch adds the first subsidiary layer0(out of layer0 to layer7)
support for the fetchlayer0/1 fetch units to be the backend of DRM plane.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/dpu/dpu-crtc.c  |  133 +++++++++++++++--------
 drivers/gpu/drm/imx/dpu/dpu-kms.c   |  166 ++++++++++++++++++-----------
 drivers/gpu/drm/imx/dpu/dpu-plane.c |  201 +++++++++++++++++++++++------------
 drivers/gpu/drm/imx/dpu/dpu-plane.h |   64 ++++++++++-
 drivers/gpu/imx/dpu/dpu-common.c    |   15 ++-
 drivers/gpu/imx/dpu/dpu-prv.h       |    5 +
 include/video/dpu.h                 |    9 +-
 7 files changed, 411 insertions(+), 182 deletions(-)

diff --git a/drivers/gpu/drm/imx/dpu/dpu-crtc.c b/drivers/gpu/drm/imx/dpu/dpu-crtc.c
index 31482ef..01332be 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-crtc.c
+++ b/drivers/gpu/drm/imx/dpu/dpu-crtc.c
@@ -340,14 +340,15 @@ static void dpu_crtc_atomic_begin(struct drm_crtc *crtc,
 		struct dpu_plane *dplane;
 		struct drm_plane *plane;
 		struct dpu_plane_res *res;
-		struct dpu_fetchdecode *fd;
-		struct dpu_fetcheco *fe;
-		struct dpu_hscaler *hs;
-		struct dpu_vscaler *vs;
+		struct dpu_fetchdecode *fd = NULL;
+		struct dpu_fetchlayer *fl = NULL;
+		struct dpu_fetcheco *fe = NULL;
+		struct dpu_hscaler *hs = NULL;
+		struct dpu_vscaler *vs = NULL;
 		struct dpu_layerblend *lb;
 		struct dpu_extdst *ed;
 		extdst_src_sel_t ed_src;
-		int fd_id, lb_id;
+		int fu_id, lb_id, fu_type;
 		bool crtc_disabling_on_primary = false;
 
 		old_dpstate = old_dcstate->dpu_plane_states[i];
@@ -358,26 +359,39 @@ static void dpu_crtc_atomic_begin(struct drm_crtc *crtc,
 		dplane = to_dpu_plane(plane_state->plane);
 		res = &dplane->grp->res;
 
-		fd_id = source_to_id(old_dpstate->source);
-		if (fd_id < 0)
+		fu_type = source_to_type(old_dpstate->source);
+		fu_id = source_to_id(old_dpstate->source);
+		if (fu_id < 0)
 			return;
 
+		switch (fu_type) {
+		case DPU_PLANE_SRC_FD:
+			fd = res->fd[fu_id];
+			break;
+		case DPU_PLANE_SRC_FL:
+			fl = res->fl[fu_id];
+			break;
+		default:
+			WARN_ON(1);
+			return;
+		}
+
 		lb_id = blend_to_id(old_dpstate->blend);
 		if (lb_id < 0)
 			return;
 
-		fd = res->fd[fd_id];
 		lb = res->lb[lb_id];
 
-		fe = fetchdecode_get_fetcheco(fd);
-		hs = fetchdecode_get_hscaler(fd);
-		vs = fetchdecode_get_vscaler(fd);
-
 		layerblend_pixengcfg_clken(lb, CLKEN__DISABLE);
-		hscaler_pixengcfg_clken(hs, CLKEN__DISABLE);
-		vscaler_pixengcfg_clken(vs, CLKEN__DISABLE);
-		hscaler_mode(hs, SCALER_NEUTRAL);
-		vscaler_mode(vs, SCALER_NEUTRAL);
+		if (fd) {
+			fe = fetchdecode_get_fetcheco(fd);
+			hs = fetchdecode_get_hscaler(fd);
+			vs = fetchdecode_get_vscaler(fd);
+			hscaler_pixengcfg_clken(hs, CLKEN__DISABLE);
+			vscaler_pixengcfg_clken(vs, CLKEN__DISABLE);
+			hscaler_mode(hs, SCALER_NEUTRAL);
+			vscaler_mode(vs, SCALER_NEUTRAL);
+		}
 		if (old_dpstate->is_top) {
 			ed = res->ed[dplane->stream_id];
 			ed_src = dplane->stream_id ?
@@ -391,16 +405,24 @@ static void dpu_crtc_atomic_begin(struct drm_crtc *crtc,
 			crtc_disabling_on_primary = true;
 
 		if (crtc_disabling_on_primary && old_dpstate->use_prefetch) {
-			fetchdecode_pin_off(fd);
-			if (fetcheco_is_enabled(fe))
-				fetcheco_pin_off(fe);
+			if (fd) {
+				fetchdecode_pin_off(fd);
+				if (fetcheco_is_enabled(fe))
+					fetcheco_pin_off(fe);
+			} else if (fl)
+				fetchlayer_pin_off(fl);
 		} else {
-			fetchdecode_source_buffer_disable(fd);
-			fetchdecode_pixengcfg_dynamic_src_sel(fd,
+			if (fd) {
+				fetchdecode_source_buffer_disable(fd);
+				fetchdecode_pixengcfg_dynamic_src_sel(fd,
 								FD_SRC_DISABLE);
-			fetcheco_source_buffer_disable(fe);
-			fetchdecode_unpin_off(fd);
-			fetcheco_unpin_off(fe);
+				fetcheco_source_buffer_disable(fe);
+				fetchdecode_unpin_off(fd);
+				fetcheco_unpin_off(fe);
+			} else if (fl) {
+				fetchlayer_source_buffer_disable(fl, 0);
+				fetchlayer_unpin_off(fl);
+			}
 		}
 	}
 }
@@ -453,11 +475,12 @@ static void dpu_crtc_atomic_flush(struct drm_crtc *crtc,
 		struct drm_plane_state *plane_state;
 		struct dpu_plane *dplane;
 		struct dpu_plane_res *res;
-		struct dpu_fetchdecode *fd;
+		struct dpu_fetchdecode *fd = NULL;
+		struct dpu_fetchlayer *fl = NULL;
 		struct dpu_fetcheco *fe;
 		struct dpu_hscaler *hs;
 		struct dpu_vscaler *vs;
-		int fd_id;
+		int fu_id, fu_type;
 
 		old_dpstate = old_dcstate->dpu_plane_states[i];
 		if (!old_dpstate)
@@ -467,26 +490,50 @@ static void dpu_crtc_atomic_flush(struct drm_crtc *crtc,
 		dplane = to_dpu_plane(plane_state->plane);
 		res = &dplane->grp->res;
 
-		fd_id = source_to_id(old_dpstate->source);
-		if (fd_id < 0)
+		fu_type = source_to_type(old_dpstate->source);
+		fu_id = source_to_id(old_dpstate->source);
+		if (fu_id < 0)
 			return;
 
-		fd = res->fd[fd_id];
-		if (!fetchdecode_is_enabled(fd) ||
-		     fetchdecode_is_pinned_off(fd))
-			fetchdecode_set_stream_id(fd, DPU_PLANE_SRC_DISABLED);
-
-		fe = fetchdecode_get_fetcheco(fd);
-		if (!fetcheco_is_enabled(fe) || fetcheco_is_pinned_off(fe))
-			fetcheco_set_stream_id(fe, DPU_PLANE_SRC_DISABLED);
-
-		hs = fetchdecode_get_hscaler(fd);
-		if (!hscaler_is_enabled(hs))
-			hscaler_set_stream_id(hs, DPU_PLANE_SRC_DISABLED);
+		switch (fu_type) {
+		case DPU_PLANE_SRC_FD:
+			fd = res->fd[fu_id];
+			break;
+		case DPU_PLANE_SRC_FL:
+			fl = res->fl[fu_id];
+			break;
+		default:
+			WARN_ON(1);
+			return;
+		}
 
-		vs = fetchdecode_get_vscaler(fd);
-		if (!vscaler_is_enabled(vs))
-			vscaler_set_stream_id(vs, DPU_PLANE_SRC_DISABLED);
+		if (fd) {
+			if (!fetchdecode_is_enabled(fd) ||
+			     fetchdecode_is_pinned_off(fd))
+				fetchdecode_set_stream_id(fd,
+							DPU_PLANE_SRC_DISABLED);
+
+			fe = fetchdecode_get_fetcheco(fd);
+			if (!fetcheco_is_enabled(fe) ||
+			     fetcheco_is_pinned_off(fe))
+				fetcheco_set_stream_id(fe,
+							DPU_PLANE_SRC_DISABLED);
+
+			hs = fetchdecode_get_hscaler(fd);
+			if (!hscaler_is_enabled(hs))
+				hscaler_set_stream_id(hs,
+							DPU_PLANE_SRC_DISABLED);
+
+			vs = fetchdecode_get_vscaler(fd);
+			if (!vscaler_is_enabled(vs))
+				vscaler_set_stream_id(vs,
+							DPU_PLANE_SRC_DISABLED);
+		} else if (fl) {
+			if (!fetchlayer_is_enabled(fl, 0) ||
+			     fetchlayer_is_pinned_off(fl))
+				fetchlayer_set_stream_id(fl,
+							DPU_PLANE_SRC_DISABLED);
+		}
 	}
 }
 
diff --git a/drivers/gpu/drm/imx/dpu/dpu-kms.c b/drivers/gpu/drm/imx/dpu/dpu-kms.c
index f155967..02aee21 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-kms.c
+++ b/drivers/gpu/drm/imx/dpu/dpu-kms.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -135,111 +135,153 @@ static int dpu_atomic_sort_planes_per_crtc(struct drm_crtc_state *crtc_state,
 	struct drm_framebuffer *fb;
 	struct dpu_fetchdecode *fd;
 	struct dpu_fetcheco *fe;
+	struct dpu_fetchlayer *fl;
 	struct dpu_hscaler *hs;
 	struct dpu_vscaler *vs;
 	unsigned int sid, src_sid;
-	int i, j, k;
-	int fd_id;
-	u32 cap_mask, fe_mask, hs_mask, vs_mask;
+	unsigned int num_planes;
+	int i, j, k, l, m;
+	int fu_id, fu_type;
+	int total_asrc_num;
+	u32 src_a_mask, cap_mask, fe_mask, hs_mask, vs_mask;
+	bool need_fetcheco, need_hscaler, need_vscaler;
+	bool fmt_is_yuv;
 
 	/* for active planes only */
 	for (i = 0; i < n; i++) {
 		dpstate = to_dpu_plane_state(states[i]);
 		dplane = to_dpu_plane(states[i]->plane);
 		fb = states[i]->fb;
+		num_planes = drm_format_num_planes(fb->format->format);
+		fmt_is_yuv = drm_format_is_yuv(fb->format->format);
 		grp = dplane->grp;
 		sid = dplane->stream_id;
 
+		need_fetcheco = (num_planes > 1);
+		need_hscaler = (states[i]->src_w >> 16 != states[i]->crtc_w);
+		need_vscaler = (states[i]->src_h >> 16 != states[i]->crtc_h);
+
+		total_asrc_num = 0;
+		src_a_mask = grp->src_a_mask;
+		fe_mask = 0;
+		hs_mask = 0;
+		vs_mask = 0;
+
+		for (l = 0; l < (sizeof(grp->src_a_mask) * 8); l++) {
+			if (grp->src_a_mask & BIT(l))
+				total_asrc_num++;
+		}
+
 		/* assign source */
 		mutex_lock(&grp->mutex);
-		for (k = 0; k < grp->hw_plane_num; k++) {
-			/* already used by others? */
-			if (grp->src_mask & BIT(k))
-				continue;
+		for (k = 0; k < total_asrc_num; k++) {
+			m = ffs(src_a_mask) - 1;
 
-			fd_id = source_to_id(sources[k]);
+			fu_type = source_to_type(sources[m]);
+			fu_id = source_to_id(sources[m]);
 
-			fd = grp->res.fd[fd_id];
+			switch (fu_type) {
+			case DPU_PLANE_SRC_FL:
+				fl = grp->res.fl[fu_id];
 
-			/* avoid on-the-fly/hot migration */
-			src_sid = fetchdecode_get_stream_id(fd);
-			if (src_sid && src_sid != BIT(sid))
-				continue;
-
-			cap_mask = fetchdecode_get_vproc_mask(fd);
+				if (fmt_is_yuv || need_fetcheco ||
+				    need_hscaler || need_vscaler)
+					goto next;
 
-			if (drm_format_num_planes(fb->format->format) > 1) {
-				fe = fetchdecode_get_fetcheco(fd);
+				/* avoid on-the-fly/hot migration */
+				src_sid = fetchlayer_get_stream_id(fl);
+				if (src_sid && src_sid != BIT(sid))
+					goto next;
+				break;
+			case DPU_PLANE_SRC_FD:
+				fd = grp->res.fd[fu_id];
 
 				/* avoid on-the-fly/hot migration */
-				src_sid = fetcheco_get_stream_id(fe);
+				src_sid = fetchdecode_get_stream_id(fd);
 				if (src_sid && src_sid != BIT(sid))
-					continue;
+					goto next;
 
-				/* fetch unit has the fetcheco capability? */
-				if (!dpu_vproc_has_fetcheco_cap(cap_mask))
-					continue;
+				cap_mask = fetchdecode_get_vproc_mask(fd);
 
-				fe_mask = dpu_vproc_get_fetcheco_cap(cap_mask);
+				if (need_fetcheco) {
+					fe = fetchdecode_get_fetcheco(fd);
 
-				/* fetcheco available? */
-				if (grp->src_use_vproc_mask & fe_mask)
-					continue;
+					/* avoid on-the-fly/hot migration */
+					src_sid = fetcheco_get_stream_id(fe);
+					if (src_sid && src_sid != BIT(sid))
+						goto next;
 
-				grp->src_use_vproc_mask |= fe_mask;
-			}
+					/* fetch unit has the fetcheco cap? */
+					if (!dpu_vproc_has_fetcheco_cap(cap_mask))
+						goto next;
 
-			if (states[i]->src_w >> 16 != states[i]->crtc_w) {
-				hs = fetchdecode_get_hscaler(fd);
+					fe_mask =
+					   dpu_vproc_get_fetcheco_cap(cap_mask);
 
-				/* avoid on-the-fly/hot migration */
-				src_sid = hscaler_get_stream_id(hs);
-				if (src_sid && src_sid != BIT(sid))
-					continue;
+					/* fetcheco available? */
+					if (grp->src_use_vproc_mask & fe_mask)
+						goto next;
+				}
 
-				/* fetch unit has the hscale capability? */
-				if (!dpu_vproc_has_hscale_cap(cap_mask))
-					continue;
+				if (need_hscaler) {
+					hs = fetchdecode_get_hscaler(fd);
 
-				hs_mask = dpu_vproc_get_hscale_cap(cap_mask);
+					/* avoid on-the-fly/hot migration */
+					src_sid = hscaler_get_stream_id(hs);
+					if (src_sid && src_sid != BIT(sid))
+						goto next;
 
-				/* hscaler available? */
-				if (grp->src_use_vproc_mask & hs_mask)
-					continue;
+					/* fetch unit has the hscale cap */
+					if (!dpu_vproc_has_hscale_cap(cap_mask))
+						goto next;
 
-				grp->src_use_vproc_mask |= hs_mask;
-			}
+					hs_mask =
+					     dpu_vproc_get_hscale_cap(cap_mask);
 
-			if (states[i]->src_h >> 16 != states[i]->crtc_h) {
-				vs = fetchdecode_get_vscaler(fd);
+					/* hscaler available? */
+					if (grp->src_use_vproc_mask & hs_mask)
+						goto next;
+				}
 
-				/* avoid on-the-fly/hot migration */
-				src_sid = vscaler_get_stream_id(vs);
-				if (src_sid && src_sid != BIT(sid))
-					continue;
+				if (need_vscaler) {
+					vs = fetchdecode_get_vscaler(fd);
 
-				/* fetch unit has the vscale capability? */
-				if (!dpu_vproc_has_vscale_cap(cap_mask))
-					continue;
+					/* avoid on-the-fly/hot migration */
+					src_sid = vscaler_get_stream_id(vs);
+					if (src_sid && src_sid != BIT(sid))
+						goto next;
 
-				vs_mask = dpu_vproc_get_vscale_cap(cap_mask);
+					/* fetch unit has the vscale cap? */
+					if (!dpu_vproc_has_vscale_cap(cap_mask))
+						goto next;
 
-				/* vscaler available? */
-				if (grp->src_use_vproc_mask & vs_mask)
-					continue;
+					vs_mask =
+					     dpu_vproc_get_vscale_cap(cap_mask);
 
-				grp->src_use_vproc_mask |= vs_mask;
+					/* vscaler available? */
+					if (grp->src_use_vproc_mask & vs_mask)
+						goto next;
+				}
+				break;
+			default:
+				return -EINVAL;
 			}
 
-			grp->src_mask |= BIT(k);
+			grp->src_a_mask &= ~BIT(m);
+			grp->src_use_vproc_mask |= fe_mask | hs_mask | vs_mask;
 			break;
+next:
+			src_a_mask &= ~BIT(m);
+			fe_mask = 0;
+			hs_mask = 0;
+			vs_mask = 0;
 		}
 		mutex_unlock(&grp->mutex);
 
-		if (k == grp->hw_plane_num)
+		if (k == total_asrc_num)
 			return -EINVAL;
 
-		dpstate->source = sources[k];
+		dpstate->source = sources[m];
 
 		/* assign stage and blend */
 		if (sid) {
@@ -460,7 +502,7 @@ static int dpu_drm_atomic_check(struct drm_device *dev,
 	for (i = 0; i < MAX_DPU_PLANE_GRP; i++) {
 		if (grp[i]) {
 			mutex_lock(&grp[i]->mutex);
-			grp[i]->src_mask = 0;
+			grp[i]->src_a_mask = ~grp[i]->src_na_mask;
 			grp[i]->src_use_vproc_mask = 0;
 			mutex_unlock(&grp[i]->mutex);
 		}
diff --git a/drivers/gpu/drm/imx/dpu/dpu-plane.c b/drivers/gpu/drm/imx/dpu/dpu-plane.c
index 937c973..9639234 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-plane.c
+++ b/drivers/gpu/drm/imx/dpu/dpu-plane.c
@@ -195,11 +195,12 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 	struct dpu_plane_state *dpstate = to_dpu_plane_state(state);
 	struct drm_crtc_state *crtc_state;
 	struct drm_framebuffer *fb = state->fb;
-	struct dpu_fetchdecode *fd;
+	struct dpu_fetchdecode *fd = NULL;
+	struct dpu_fetchlayer *fl = NULL;
 	dma_addr_t baseaddr, uv_baseaddr = 0;
 	u32 src_w = state->src_w >> 16, src_h = state->src_h >> 16,
 	    src_x = state->src_x >> 16, src_y = state->src_y >> 16;
-	int bpp, fd_id;
+	int bpp, fu_id, fu_type;
 
 	/* pure software check */
 	if (plane->type != DRM_PLANE_TYPE_PRIMARY)
@@ -293,19 +294,29 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 		break;
 	}
 
-	fd_id = source_to_id(dpstate->source);
-	if (fd_id < 0)
+	fu_type = source_to_type(dpstate->source);
+	fu_id = source_to_id(dpstate->source);
+	if (fu_id < 0)
 		return -EINVAL;
 
-	fd = res->fd[fd_id];
+	switch (fu_type) {
+	case DPU_PLANE_SRC_FD:
+		fd = res->fd[fu_id];
+		break;
+	case DPU_PLANE_SRC_FL:
+		fl = res->fl[fu_id];
+		break;
+	default:
+		return -EINVAL;
+	}
 
-	if (fetchdecode_has_prefetch(fd) &&
-	    fetchdecode_prefetch_format_supported(fd, fb->format->format,
-						  fb->modifier) &&
-	    fetchdecode_prefetch_stride_supported(fd, fb->pitches[0],
-						  fb->pitches[1],
-						  src_w,
-						  fb->format->format))
+	if (fetchunit_has_prefetch(fd, fl) &&
+	    fetchunit_prefetch_format_supported(fd, fl, fb->format->format,
+						fb->modifier) &&
+	    fetchunit_prefetch_stride_supported(fd, fl, fb->pitches[0],
+						fb->pitches[1],
+						src_w,
+						fb->format->format))
 		dpstate->use_prefetch = true;
 	else
 		dpstate->use_prefetch = false;
@@ -353,10 +364,10 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 	}
 
 	if (dpstate->use_prefetch &&
-	    !fetchdecode_prefetch_stride_double_check(fd, fb->pitches[0],
-						      fb->pitches[1],
-						      src_w, fb->format->format,
-						      baseaddr, uv_baseaddr)) {
+	    !fetchunit_prefetch_stride_double_check(fd, fl, fb->pitches[0],
+						    fb->pitches[1],
+						    src_w, fb->format->format,
+						    baseaddr, uv_baseaddr)) {
 		if (fb->modifier)
 			return -EINVAL;
 
@@ -380,7 +391,8 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	struct dpu_plane_state *dpstate = to_dpu_plane_state(state);
 	struct drm_framebuffer *fb = state->fb;
 	struct dpu_plane_res *res = &dplane->grp->res;
-	struct dpu_fetchdecode *fd;
+	struct dpu_fetchdecode *fd = NULL;
+	struct dpu_fetchlayer *fl = NULL;
 	struct dpu_fetcheco *fe = NULL;
 	struct dpu_hscaler *hs = NULL;
 	struct dpu_vscaler *vs = NULL;
@@ -393,8 +405,9 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	dpu_block_id_t fe_id, vs_id = ID_NONE, hs_id;
 	lb_sec_sel_t lb_src = dpstate->source;
 	unsigned int src_w, src_h, src_x, src_y;
-	int bpp, fd_id, lb_id;
+	int bpp, fu_id, lb_id, fu_type;
 	bool need_fetcheco = false, need_hscaler = false, need_vscaler = false;
+	bool need_fetchdecode = false, need_fetchlayer = false;
 	bool prefetch_start = false, aux_prefetch_start = false;
 	bool need_modeset;
 	bool is_overlay = plane->type == DRM_PLANE_TYPE_OVERLAY;
@@ -408,15 +421,29 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 
 	need_modeset = drm_atomic_crtc_needs_modeset(state->crtc->state);
 
-	fd_id = source_to_id(dpstate->source);
-	if (fd_id < 0)
+	fu_type = source_to_type(dpstate->source);
+	fu_id = source_to_id(dpstate->source);
+	if (fu_id < 0)
+		return;
+
+	switch (fu_type) {
+	case DPU_PLANE_SRC_FD:
+		need_fetchdecode = true;
+		fd = res->fd[fu_id];
+		break;
+	case DPU_PLANE_SRC_FL:
+		need_fetchlayer = true;
+		fl = res->fl[fu_id];
+		break;
+	default:
+		WARN_ON(1);
 		return;
+	}
 
 	lb_id = blend_to_id(dpstate->blend);
 	if (lb_id < 0)
 		return;
 
-	fd = res->fd[fd_id];
 	lb = res->lb[lb_id];
 
 	src_w = state->src_w >> 16;
@@ -424,25 +451,27 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	src_x = state->src_x >> 16;
 	src_y = state->src_y >> 16;
 
-	if (fetchdecode_need_fetcheco(fd, fb->format->format)) {
-		need_fetcheco = true;
-		fe = fetchdecode_get_fetcheco(fd);
-		if (IS_ERR(fe))
-			return;
-	}
+	if (need_fetchdecode) {
+		if (fetchdecode_need_fetcheco(fd, fb->format->format)) {
+			need_fetcheco = true;
+			fe = fetchdecode_get_fetcheco(fd);
+			if (IS_ERR(fe))
+				return;
+		}
 
-	if (src_w != state->crtc_w) {
-		need_hscaler = true;
-		hs = fetchdecode_get_hscaler(fd);
-		if (IS_ERR(hs))
-			return;
-	}
+		if (src_w != state->crtc_w) {
+			need_hscaler = true;
+			hs = fetchdecode_get_hscaler(fd);
+			if (IS_ERR(hs))
+				return;
+		}
 
-	if (src_h != state->crtc_h) {
-		need_vscaler = true;
-		vs = fetchdecode_get_vscaler(fd);
-		if (IS_ERR(vs))
-			return;
+		if (src_h != state->crtc_h) {
+			need_vscaler = true;
+			vs = fetchdecode_get_vscaler(fd);
+			if (IS_ERR(vs))
+				return;
+		}
 	}
 
 	switch (fb->format->format) {
@@ -463,24 +492,56 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	if (need_fetcheco)
 		uv_baseaddr = drm_plane_state_to_uvbaseaddr(state);
 
-	if (dpstate->use_prefetch &&
-	    (fetchdecode_get_stream_id(fd) == DPU_PLANE_SRC_DISABLED ||
-	     need_modeset))
-		prefetch_start = true;
-
-	fetchdecode_set_burstlength(fd, baseaddr, dpstate->use_prefetch);
-	fetchdecode_source_bpp(fd, bpp);
-	fetchdecode_source_stride(fd, src_w, bpp, fb->pitches[0], baseaddr,
-							dpstate->use_prefetch);
-	fetchdecode_src_buf_dimensions(fd, src_w, src_h);
-	fetchdecode_set_fmt(fd, fb->format->format);
-	fetchdecode_source_buffer_enable(fd);
-	fetchdecode_framedimensions(fd, src_w, src_h);
-	fetchdecode_baseaddress(fd, baseaddr);
-	fetchdecode_set_stream_id(fd, dplane->stream_id ?
-					DPU_PLANE_SRC_TO_DISP_STREAM1 :
-					DPU_PLANE_SRC_TO_DISP_STREAM0);
-	fetchdecode_unpin_off(fd);
+	if (dpstate->use_prefetch) {
+		if (need_fetchdecode &&
+		    (fetchdecode_get_stream_id(fd) == DPU_PLANE_SRC_DISABLED ||
+		     need_modeset))
+			prefetch_start = true;
+
+		if (need_fetchlayer &&
+		    (fetchlayer_get_stream_id(fl) == DPU_PLANE_SRC_DISABLED ||
+		     need_modeset))
+			prefetch_start = true;
+	}
+
+	if (need_fetchdecode) {
+		fetchdecode_set_burstlength(fd, baseaddr,
+					dpstate->use_prefetch);
+		fetchdecode_source_bpp(fd, bpp);
+		fetchdecode_source_stride(fd, src_w, bpp, fb->pitches[0],
+					baseaddr, dpstate->use_prefetch);
+		fetchdecode_src_buf_dimensions(fd, src_w, src_h);
+		fetchdecode_set_fmt(fd, fb->format->format);
+		fetchdecode_source_buffer_enable(fd);
+		fetchdecode_framedimensions(fd, src_w, src_h);
+		fetchdecode_baseaddress(fd, baseaddr);
+		fetchdecode_set_stream_id(fd, dplane->stream_id ?
+						DPU_PLANE_SRC_TO_DISP_STREAM1 :
+						DPU_PLANE_SRC_TO_DISP_STREAM0);
+		fetchdecode_unpin_off(fd);
+
+		dev_dbg(dev, "[PLANE:%d:%s] fetchdecode-0x%02x\n",
+					plane->base.id, plane->name, fu_id);
+	}
+
+	if (need_fetchlayer) {
+		fetchlayer_set_burstlength(fl, baseaddr, dpstate->use_prefetch);
+		fetchlayer_source_bpp(fl, 0, bpp);
+		fetchlayer_source_stride(fl, 0, src_w, bpp, fb->pitches[0],
+					 baseaddr, dpstate->use_prefetch);
+		fetchlayer_src_buf_dimensions(fl, 0, src_w, src_h);
+		fetchlayer_set_fmt(fl, 0, fb->format->format);
+		fetchlayer_source_buffer_enable(fl, 0);
+		fetchlayer_framedimensions(fl, src_w, src_h);
+		fetchlayer_baseaddress(fl, 0, baseaddr);
+		fetchlayer_set_stream_id(fl, dplane->stream_id ?
+						DPU_PLANE_SRC_TO_DISP_STREAM1 :
+						DPU_PLANE_SRC_TO_DISP_STREAM0);
+		fetchlayer_unpin_off(fl);
+
+		dev_dbg(dev, "[PLANE:%d:%s] fetchlayer-0x%02x\n",
+					plane->base.id, plane->name, fu_id);
+	}
 
 	if (need_fetcheco) {
 		fe_id = fetcheco_get_block_id(fe);
@@ -512,7 +573,9 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 		dev_dbg(dev, "[PLANE:%d:%s] fetcheco-0x%02x\n",
 					plane->base.id, plane->name, fe_id);
 	} else {
-		fetchdecode_pixengcfg_dynamic_src_sel(fd, FD_SRC_DISABLE);
+		if (fd)
+			fetchdecode_pixengcfg_dynamic_src_sel(fd,
+								FD_SRC_DISABLE);
 	}
 
 	/* vscaler comes first */
@@ -566,20 +629,20 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	}
 
 	if (dpstate->use_prefetch) {
-		fetchdecode_configure_prefetch(fd, dplane->stream_id,
-					       src_w, src_h, src_x, src_y,
-					       fb->pitches[0], fb->format->format,
-					       fb->modifier,
-					       baseaddr, uv_baseaddr,
-					       prefetch_start,
-					       aux_prefetch_start);
+		fetchunit_configure_prefetch(fd, fl, dplane->stream_id,
+					     src_w, src_h, src_x, src_y,
+					     fb->pitches[0], fb->format->format,
+					     fb->modifier,
+					     baseaddr, uv_baseaddr,
+					     prefetch_start,
+					     aux_prefetch_start);
 		if (prefetch_start || aux_prefetch_start)
-			fetchdecode_enable_prefetch(fd);
+			fetchunit_enable_prefetch(fd, fl);
 
-		fetchdecode_reg_update_prefetch(fd);
+		fetchunit_reg_update_prefetch(fd, fl);
 
 		if (prefetch_start || aux_prefetch_start) {
-			fetchdecode_prefetch_first_frame_handle(fd);
+			fetchunit_prefetch_first_frame_handle(fd, fl);
 
 			if (!need_modeset && is_overlay)
 				framegen_wait_for_frame_counter_moving(fg);
@@ -587,8 +650,8 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 
 		dev_dbg(dev, "[PLANE:%d:%s] use prefetch\n",
 					plane->base.id, plane->name);
-	} else if (fetchdecode_has_prefetch(fd)) {
-		fetchdecode_disable_prefetch(fd);
+	} else if (fetchunit_has_prefetch(fd, fl)) {
+		fetchunit_disable_prefetch(fd, fl);
 
 		dev_dbg(dev, "[PLANE:%d:%s] bypass prefetch\n",
 					plane->base.id, plane->name);
diff --git a/drivers/gpu/drm/imx/dpu/dpu-plane.h b/drivers/gpu/drm/imx/dpu/dpu-plane.h
index b5214c5..9854672 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-plane.h
+++ b/drivers/gpu/drm/imx/dpu/dpu-plane.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -20,6 +20,12 @@
 
 #define MAX_DPU_PLANE_GRP	(MAX_CRTC / 2)
 
+enum dpu_plane_src_type {
+	DPU_PLANE_SRC_FL,
+	DPU_PLANE_SRC_FW,
+	DPU_PLANE_SRC_FD,
+};
+
 struct dpu_plane {
 	struct drm_plane	base;
 	struct dpu_plane_grp	*grp;
@@ -50,7 +56,10 @@ struct dpu_plane_state {
 				       LB_PRIM_SEL__LAYERBLEND3,
 				       LB_PRIM_SEL__LAYERBLEND4,
 				       LB_PRIM_SEL__LAYERBLEND5};
-static const lb_sec_sel_t sources[] = {LB_SEC_SEL__FETCHDECODE0,
+/* FIXME: Correct the source entries for subsidiary layers. */
+static const lb_sec_sel_t sources[] = {LB_SEC_SEL__FETCHLAYER0,
+				       LB_SEC_SEL__FETCHLAYER1,
+				       LB_SEC_SEL__FETCHDECODE0,
 				       LB_SEC_SEL__FETCHDECODE1,
 				       LB_SEC_SEL__FETCHDECODE2,
 				       LB_SEC_SEL__FETCHDECODE3};
@@ -69,13 +78,45 @@ static inline struct dpu_plane *to_dpu_plane(struct drm_plane *plane)
 	return container_of(plane_state, struct dpu_plane_state, base);
 }
 
+static inline int source_to_type(lb_sec_sel_t source)
+{
+	switch (source) {
+	case LB_SEC_SEL__FETCHLAYER0:
+	case LB_SEC_SEL__FETCHLAYER1:
+		return DPU_PLANE_SRC_FL;
+	case LB_SEC_SEL__FETCHDECODE0:
+	case LB_SEC_SEL__FETCHDECODE1:
+	case LB_SEC_SEL__FETCHDECODE2:
+	case LB_SEC_SEL__FETCHDECODE3:
+		return DPU_PLANE_SRC_FD;
+	default:
+		break;
+	}
+
+	WARN_ON(1);
+	return -EINVAL;
+}
+
 static inline int source_to_id(lb_sec_sel_t source)
 {
-	int i;
+	int i, offset = 0;
+	int type = source_to_type(source);
 
 	for (i = 0; i < ARRAY_SIZE(sources); i++) {
-		if (source == sources[i])
+		if (source == sources[i]) {
+			if (type == DPU_PLANE_SRC_FD) {
+				while (offset < ARRAY_SIZE(sources)) {
+					if (source_to_type(sources[offset]) ==
+					    type)
+						break;
+					offset++;
+				}
+
+				i -= offset;
+			}
+
 			return i;
+		}
 	}
 
 	WARN_ON(1);
@@ -95,6 +136,21 @@ static inline int blend_to_id(dpu_block_id_t blend)
 	return -EINVAL;
 }
 
+static inline bool drm_format_is_yuv(uint32_t format)
+{
+	switch (format) {
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
 struct dpu_plane *dpu_plane_init(struct drm_device *drm,
 				 unsigned int possible_crtcs,
 				 unsigned int stream_id,
diff --git a/drivers/gpu/imx/dpu/dpu-common.c b/drivers/gpu/imx/dpu/dpu-common.c
index 256495e..88cc532 100644
--- a/drivers/gpu/imx/dpu/dpu-common.c
+++ b/drivers/gpu/imx/dpu/dpu-common.c
@@ -515,6 +515,7 @@ static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
 	.intsteer_map = intsteer_map_v1,
 	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v1),
 	.unused_irq = unused_irq_v1,
+	.plane_src_na_mask = 0xffffffc0,
 	.has_capture = true,
 	.has_prefetch = false,
 	.pixel_link_quirks = false,
@@ -541,6 +542,7 @@ static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
 	.unused_irq = unused_irq_v2,
 	.sw2hw_irq_map = sw2hw_irq_map_v2,
 	.sw2hw_block_id_map = sw2hw_block_id_map_v2,
+	.plane_src_na_mask = 0xffffffc2,
 	.has_capture = false,
 	.has_prefetch = true,
 	.pixel_link_quirks = true,
@@ -1042,6 +1044,7 @@ static int dpu_get_plane_resource(struct dpu_soc *dpu,
 				  struct dpu_plane_res *res)
 {
 	const struct dpu_unit *fds = dpu->devtype->fds;
+	const struct dpu_unit *fls = dpu->devtype->fls;
 	const struct dpu_unit *lbs = dpu->devtype->lbs;
 	struct dpu_plane_grp *grp = plane_res_to_grp(res);
 	int i;
@@ -1067,6 +1070,11 @@ static int dpu_get_plane_resource(struct dpu_soc *dpu,
 			return PTR_ERR(res->fe[i]);
 		grp->hw_plane_fetcheco_num = ARRAY_SIZE(res->fe);
 	}
+	for (i = 0; i < fls->num; i++) {
+		res->fl[i] = dpu_fl_get(dpu, i);
+		if (IS_ERR(res->fl[i]))
+			return PTR_ERR(res->fl[i]);
+	}
 	/* HScaler could be shared with capture. */
 	if (display_plane_video_proc) {
 		for (i = 0; i < ARRAY_SIZE(res->hs); i++) {
@@ -1091,7 +1099,7 @@ static int dpu_get_plane_resource(struct dpu_soc *dpu,
 		grp->hw_plane_vscaler_num = ARRAY_SIZE(res->vs);
 	}
 
-	grp->hw_plane_num = fds->num;
+	grp->hw_plane_num = fds->num + fls->num;
 
 	return 0;
 }
@@ -1117,6 +1125,10 @@ static void dpu_put_plane_resource(struct dpu_plane_res *res)
 		if (!IS_ERR_OR_NULL(res->fe[i]))
 			dpu_fe_put(res->fe[i]);
 	}
+	for (i = 0; i < ARRAY_SIZE(res->fl); i++) {
+		if (!IS_ERR_OR_NULL(res->fl[i]))
+			dpu_fl_put(res->fl[i]);
+	}
 	for (i = 0; i < ARRAY_SIZE(res->hs); i++) {
 		if (!IS_ERR_OR_NULL(res->hs[i]))
 			dpu_hs_put(res->hs[i]);
@@ -1167,6 +1179,7 @@ static int dpu_add_client_devices(struct dpu_soc *dpu)
 	else
 		memcpy(reg, &client_reg[2], reg_size);
 
+	plane_grp->src_na_mask = devtype->plane_src_na_mask;
 	plane_grp->id = id / client_num;
 	plane_grp->has_vproc = display_plane_video_proc;
 
diff --git a/drivers/gpu/imx/dpu/dpu-prv.h b/drivers/gpu/imx/dpu/dpu-prv.h
index 9edd05d1..d3569dc 100644
--- a/drivers/gpu/imx/dpu/dpu-prv.h
+++ b/drivers/gpu/imx/dpu/dpu-prv.h
@@ -198,6 +198,11 @@ struct dpu_devtype {
 	const unsigned long *unused_irq;
 	const unsigned int *sw2hw_irq_map;	/* NULL means linear */
 	const unsigned int *sw2hw_block_id_map;	/* NULL means linear */
+	/*
+	 * index:     0         1       2   3   4   5
+	 * source: fl0(sub0) fl1(sub0) fd0 fd1 fd2 fd3
+	 */
+	const u32 plane_src_na_mask;
 	bool has_capture;
 	bool has_prefetch;
 	bool pixel_link_quirks;
diff --git a/include/video/dpu.h b/include/video/dpu.h
index ef010d6..ddcd147 100644
--- a/include/video/dpu.h
+++ b/include/video/dpu.h
@@ -806,12 +806,14 @@ void  dpu_be_configure_prefetch(struct dpu_bliteng *dpu_be,
 #define DPU_PLANE_SRC_DISABLED		0
 
 #define MAX_FD_NUM	4
+#define MAX_FL_NUM	2
 #define MAX_LB_NUM	7
 struct dpu_plane_res {
 	struct dpu_constframe	*cf[2];
 	struct dpu_extdst	*ed[2];
 	struct dpu_fetchdecode	*fd[MAX_FD_NUM];
 	struct dpu_fetcheco	*fe[2];
+	struct dpu_fetchlayer	*fl[MAX_FL_NUM];
 	struct dpu_framegen	*fg[2];
 	struct dpu_hscaler	*hs[2];
 	struct dpu_layerblend	*lb[MAX_LB_NUM];
@@ -832,11 +834,12 @@ struct dpu_plane_grp {
 	bool			has_vproc;
 	/*
 	 * used when assigning plane source
-	 * index:    0   1   2   3
-	 * source: fd0 fd1 fd2 fd3
+	 * index:     0         1       2   3   4   5
+	 * source: fl0(sub0) fl1(sub0) fd0 fd1 fd2 fd3
 	 */
 	struct mutex		mutex;
-	u32			src_mask;
+	u32			src_a_mask;
+	u32			src_na_mask;
 	u32			src_use_vproc_mask;
 };
 
-- 
1.7.9.5


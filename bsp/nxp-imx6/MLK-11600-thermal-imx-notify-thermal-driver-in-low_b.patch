From a50e622ac7160de280e04d20433c51364128d528 Mon Sep 17 00:00:00 2001
From: Bai Ping <b51503@freescale.com>
Date: Tue, 22 Sep 2015 21:46:59 +0800
Subject: [PATCH 0478/5242] MLK-11600 thermal: imx: notify thermal driver in
 low_bus_freq_mode

commit  64e708f5a414771e7e1d712dd3522214dc534474 from
https://source.codeaurora.org/external/imx/linux-imx.git

As thermal sensor alarm function needs PLL3 to be always on, but low power
idle needs all PLLs to be off, they are exclusive. Low power idle is only enabled
when system staying at low bus mode which means the overall system power consumption
is NOT high, thermal alarm function can be disabled in this mode to allow low power
idle to be entered, and thermal sensor will still use polling mechanism to monitor
the system temperature. Add busfreq notify to achieve this goal.
(this patch is copied from commit  dd3d1e6c6ff0)

Also unregister the busfreq_notifier when the thermal driver is removed.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/thermal/imx_thermal.c |   67 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 66 insertions(+), 1 deletion(-)

diff --git a/drivers/thermal/imx_thermal.c b/drivers/thermal/imx_thermal.c
index 636f9b5..8fd3de8 100644
--- a/drivers/thermal/imx_thermal.c
+++ b/drivers/thermal/imx_thermal.c
@@ -1,7 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0
 //
-// Copyright 2013 Freescale Semiconductor, Inc.
+// Copyright 2013-2016 Freescale Semiconductor, Inc.
 
+#include <linux/busfreq-imx.h>
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
 #include <linux/cpu_cooling.h>
@@ -217,10 +218,13 @@ struct imx_thermal_data {
 	bool irq_enabled;
 	int irq;
 	struct clk *thermal_clk;
+	struct mutex mutex;
 	const struct thermal_soc_data *socdata;
 	const char *temp_grade;
 };
 
+static struct imx_thermal_data *imx_thermal_data;
+
 static void imx_set_panic_temp(struct imx_thermal_data *data,
 			       int panic_temp)
 {
@@ -265,6 +269,7 @@ static int imx_get_temp(struct thermal_zone_device *tz, int *temp)
 	bool wait;
 	u32 val;
 
+	mutex_lock(&data->mutex);
 	if (data->mode == THERMAL_DEVICE_ENABLED) {
 		/* Check if a measurement is currently in progress */
 		regmap_read(map, soc_data->temp_data, &val);
@@ -275,6 +280,7 @@ static int imx_get_temp(struct thermal_zone_device *tz, int *temp)
 		 * temperature sensor, enable measurements, take a reading,
 		 * disable measurements, power off the temperature sensor.
 		 */
+		clk_prepare_enable(data->thermal_clk);
 		regmap_write(map, soc_data->sensor_ctrl + REG_CLR,
 			    soc_data->power_down_mask);
 		regmap_write(map, soc_data->sensor_ctrl + REG_SET,
@@ -297,9 +303,11 @@ static int imx_get_temp(struct thermal_zone_device *tz, int *temp)
 			     soc_data->measure_temp_mask);
 		regmap_write(map, soc_data->sensor_ctrl + REG_SET,
 			     soc_data->power_down_mask);
+		clk_disable_unprepare(data->thermal_clk);
 	}
 
 	if ((val & soc_data->temp_valid_mask) == 0) {
+		mutex_unlock(&data->mutex);
 		dev_dbg(&tz->device, "temp measurement never finished\n");
 		return -EAGAIN;
 	}
@@ -336,6 +344,7 @@ static int imx_get_temp(struct thermal_zone_device *tz, int *temp)
 		data->irq_enabled = true;
 		enable_irq(data->irq);
 	}
+	mutex_unlock(&data->mutex);
 
 	return 0;
 }
@@ -668,6 +677,52 @@ static irqreturn_t imx_thermal_alarm_irq_thread(int irq, void *dev)
 };
 MODULE_DEVICE_TABLE(of, of_imx_thermal_match);
 
+static int thermal_notifier_event(struct notifier_block *this,
+					unsigned long event, void *ptr)
+{
+	const struct thermal_soc_data *soc_data = imx_thermal_data->socdata;
+	struct regmap *map = imx_thermal_data->tempmon;
+
+	mutex_lock(&imx_thermal_data->mutex);
+
+	switch (event) {
+	/*
+	 * In low_bus_freq_mode, the thermal sensor auto measurement
+	 * can be disabled to low the power consumption.
+	 */
+	case LOW_BUSFREQ_ENTER:
+		regmap_write(map, soc_data->sensor_ctrl + REG_CLR,
+			     soc_data->measure_temp_mask);
+		regmap_write(map, soc_data->sensor_ctrl + REG_SET,
+			     soc_data->power_down_mask);
+		imx_thermal_data->mode = THERMAL_DEVICE_DISABLED;
+		disable_irq(imx_thermal_data->irq);
+		clk_disable_unprepare(imx_thermal_data->thermal_clk);
+		break;
+
+	/* Enabled thermal auto measurement when exiting low_bus_freq_mode */
+	case LOW_BUSFREQ_EXIT:
+		clk_prepare_enable(imx_thermal_data->thermal_clk);
+		regmap_write(map, soc_data->sensor_ctrl + REG_CLR,
+			     soc_data->power_down_mask);
+		regmap_write(map, soc_data->sensor_ctrl + REG_SET,
+			     soc_data->measure_temp_mask);
+		imx_thermal_data->mode = THERMAL_DEVICE_ENABLED;
+		enable_irq(imx_thermal_data->irq);
+		break;
+
+	default:
+		break;
+	}
+	mutex_unlock(&imx_thermal_data->mutex);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block thermal_notifier = {
+	.notifier_call = thermal_notifier_event,
+};
+
 static int imx_thermal_probe(struct platform_device *pdev)
 {
 	struct imx_thermal_data *data;
@@ -678,6 +733,7 @@ static int imx_thermal_probe(struct platform_device *pdev)
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
+	imx_thermal_data = data;
 
 	map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "fsl,tempmon");
 	if (IS_ERR(map)) {
@@ -797,6 +853,7 @@ static int imx_thermal_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	mutex_init(&data->mutex);
 	data->tz = thermal_zone_device_register("imx_thermal_zone",
 						IMX_TRIP_NUM,
 						BIT(IMX_TRIP_PASSIVE), data,
@@ -851,6 +908,10 @@ static int imx_thermal_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/* register the busfreq notifier called in low bus freq */
+	if (data->socdata->version != TEMPMON_IMX7)
+		register_busfreq_notifier(&thermal_notifier);
+
 	return 0;
 }
 
@@ -865,6 +926,10 @@ static int imx_thermal_remove(struct platform_device *pdev)
 	if (!IS_ERR(data->thermal_clk))
 		clk_disable_unprepare(data->thermal_clk);
 
+	/* unregister the busfreq notifier called in low bus freq */
+	if (data->socdata->version != TEMPMON_IMX7)
+		unregister_busfreq_notifier(&thermal_notifier);
+
 	thermal_zone_device_unregister(data->tz);
 	cpufreq_cooling_unregister(data->cdev[0]);
 	devfreq_cooling_unregister(data->cdev[1]);
-- 
1.7.9.5


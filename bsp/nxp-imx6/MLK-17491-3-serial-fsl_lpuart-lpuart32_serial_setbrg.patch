From 6d6e7dee1200e2262fea30a2d6a3f4add5f59c52 Mon Sep 17 00:00:00 2001
From: Dong Aisheng <aisheng.dong@nxp.com>
Date: Tue, 5 Sep 2017 17:06:29 +0800
Subject: [PATCH 3308/5242] MLK-17491-3 serial: fsl_lpuart:
 lpuart32_serial_setbrg cleanup and handle error

commit  59c06c361f0e39d3f8c8331fe98d97c795d664b1 from
https://source.codeaurora.org/external/imx/linux-imx.git

1) Add code comments for the algorithm idea
2) code cleanups
3) Give a warn one find unacceptable baud rate difference of more
than 3%

No function level change.

Acked-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/fsl_lpuart.c |   29 ++++++++++++++++++++++++-----
 1 file changed, 24 insertions(+), 5 deletions(-)

diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index 3907e72..7bd16d8 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -1795,21 +1795,35 @@ static void lpuart32_shutdown(struct uart_port *port)
 	u32 sbr, osr, baud_diff, tmp_osr, tmp_sbr, tmp_diff, tmp;
 	u32 clk = sport->port.uartclk;
 
+	/*
+	 * The idea is to use the best OSR (over-sampling rate) possible.
+	 * Note, OSR is typically hard-set to 16 in other LPUART instantiations.
+	 * Loop to find the best OSR value possible, one that generates minimum
+	 * baud_diff iterate through the rest of the supported values of OSR.
+	 *
+	 * Calculation Formula:
+	 *  Baud Rate = baud clock / ((OSR+1) Ã— SBR)
+	 */
 	baud_diff = baudrate;
 	osr = 0;
 	sbr = 0;
+
 	for (tmp_osr = 4; tmp_osr <= 32; tmp_osr++) {
+		/* calculate the temporary sbr value  */
 		tmp_sbr = (clk / (baudrate * tmp_osr));
 		if (tmp_sbr == 0)
 			tmp_sbr = 1;
 
-		/*calculate difference in actual buad w/ current values */
-		tmp_diff = (clk / (tmp_osr * tmp_sbr));
-		tmp_diff = tmp_diff - baudrate;
+		/*
+		 * calculate the baud rate difference based on the temporary
+		 * osr and sbr values
+		 */
+		tmp_diff = clk / (tmp_osr * tmp_sbr) - baudrate;
 
 		/* select best values between sbr and sbr+1 */
-		if (tmp_diff > (baudrate - (clk / (tmp_osr * (tmp_sbr + 1))))) {
-			tmp_diff = baudrate - (clk / (tmp_osr * (tmp_sbr + 1)));
+		tmp = clk / (tmp_osr * (tmp_sbr + 1));
+		if (tmp_diff > (baudrate - tmp)) {
+			tmp_diff = baudrate - tmp;
 			tmp_sbr++;
 		}
 
@@ -1823,6 +1837,11 @@ static void lpuart32_shutdown(struct uart_port *port)
 		}
 	}
 
+	/* handle baudrate outside acceptable rate */
+	if (baud_diff > ((baudrate / 100) * 3))
+		dev_warn(sport->port.dev,
+			 "unacceptable baud rate difference of more than 3%%\n");
+
 	tmp = lpuart32_read(&sport->port, UARTBAUD);
 
 	if ((osr > 3) && (osr < 8))
-- 
1.7.9.5


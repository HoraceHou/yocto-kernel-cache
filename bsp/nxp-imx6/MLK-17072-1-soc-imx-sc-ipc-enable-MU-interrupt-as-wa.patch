From 9b97a487f605bc1618c17f11811a8a1b9595f99a Mon Sep 17 00:00:00 2001
From: Robin Gong <yibin.gong@nxp.com>
Date: Mon, 4 Dec 2017 14:57:13 +0800
Subject: [PATCH 2972/5242] MLK-17072-1: soc: imx: sc: ipc: enable MU
 interrupt as wakeup source

commit  76b924d9e511120948ca54d52273e5acfcf7c388 from
https://source.codeaurora.org/external/imx/linux-imx.git

Currently, kernel still can be wakeup-ed by MU even without enabling it
as a wakeup source. That's because of MU never off in suspend and scfw
can wakeup A53 if MU interrupt not disabled or masked in GIC. But in a
corner case that the MU interrupt coming after suspend_device_irqs, MU
interrupt will be masked by below code in handle_fasteoi_irq:

  if (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {
	desc->istate |= IRQS_PENDING;
	mask_irq(desc);
	goto out;
  }
Thus, next MU interrupt after kernel suspend can't wakeup A53 since it's
masked in GIC and scfw can't see the 'wakeup' interrupt to power up A53.
But from kernel view, that's ok since MU interrupt not set to a wakeup
source. Enable MU as a wakeup source to follow the normal kernel wakeup
device/source flow.

Signed-off-by: Robin Gong <yibin.gong@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/sc/main/ipc.c |    6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/soc/imx/sc/main/ipc.c b/drivers/soc/imx/sc/main/ipc.c
index 665b8e9..40ddf2f 100644
--- a/drivers/soc/imx/sc/main/ipc.c
+++ b/drivers/soc/imx/sc/main/ipc.c
@@ -316,6 +316,12 @@ int __init imx8_mu_init(void)
 			err);
 	}
 
+	err = irq_set_irq_wake(irq, 1);
+	if (err) {
+		pr_info("set mu irq wake up error %d.\n", err);
+		return err;
+	}
+
 	if (!scu_mu_init) {
 		uint32_t i;
 
-- 
1.7.9.5


From cdd1eb75785780b987070e14a226591b512c36a0 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Fri, 1 Dec 2017 14:27:39 +0800
Subject: [PATCH 3048/5242] MLK-17133-01 tty: serial: lpuart: only enable
 wakeup interrupt when wakeup enabled

commit  c3112f5694da68efb66f0e3aed1fdbbd4fbeb4bd from
https://source.codeaurora.org/external/imx/linux-imx.git

Current driver suppose system disable irq when wakeup is not enabled
like below follow, so it always enable the wakeup interrupt in .suspend_noirq().
	dpm_suspend_noirq()
		device_wakeup_arm_wake_irqs()
			if (device_may_wakeup(wirq->dev))
				enable_irq_wake(wirq->irq);
					irq_set_irq_wake(irq, 1);
		suspend_device_irqs();
			if (irqd_is_wakeup_set(&desc->irq_data))
				__disable_irq(desc);
		device_suspend_noirq(dev);
		...

But in i.MX8x chips, the gic-v3 chip->irq_disable() is not implemented,
so the device's irq line is not masked in noirq stage. Then lpuart interrupt
can wake up system even if it is not enabled as wakeup source.

To avoid the issue, only enable wakeup interrupt when it is enabled as
wakeup source.

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Reviewed-by: Robin Gong <yibin.gong@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/fsl_lpuart.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index b37397d..b03fa82 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -2567,8 +2567,9 @@ static int lpuart_suspend_noirq(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct lpuart_port *sport = platform_get_drvdata(pdev);
+	bool irq_wake = irqd_is_wakeup_set(irq_get_irq_data(sport->port.irq));
 
-	serial_lpuart_enable_wakeup(sport, true);
+	serial_lpuart_enable_wakeup(sport, !!irq_wake);
 
 	clk_disable(sport->ipg_clk);
 	pinctrl_pm_select_sleep_state(dev);
-- 
1.7.9.5


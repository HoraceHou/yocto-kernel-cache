From 159c9c0aea8e3cd06a70cca0d8ddc20505ab9700 Mon Sep 17 00:00:00 2001
From: Zhou Peng-B04994 <eagle.zhou@nxp.com>
Date: Mon, 26 Jun 2017 13:02:28 +0800
Subject: [PATCH 2004/5242] MLK-15132-5 : Enable Hantro decoder on i.MX8MQ

commit  b51672b112c17da6cccb2608e48e3d372e502355 from
https://source.codeaurora.org/external/imx/linux-imx.git

Fix vpu decoder timeout issue:
Enable clock before config VPUMIX registers
Replace IMX8MQ_CLK_VPU_BUS_DIV with IMX8MQ_CLK_VPU_DEC_ROOT

Signed-off-by: Zhou Peng-B04994 <eagle.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi |    2 +-
 drivers/mxc/hantro/hantrodec.c                |   89 ++++++++-----------------
 2 files changed, 28 insertions(+), 63 deletions(-)
 mode change 100644 => 100755 arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi

diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
old mode 100644
new mode 100755
index 0007609..273c24b
--- a/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
@@ -596,7 +596,7 @@
 		reg-names = "regs_hantro";
 		interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
 		interrupt-names = "irq_hantro_g1", "irq_hantro_g2";
-		clocks = <&clk IMX8MQ_CLK_VPU_G1_ROOT>, <&clk IMX8MQ_CLK_VPU_G2_ROOT>, <&clk IMX8MQ_CLK_VPU_BUS_DIV>;
+		clocks = <&clk IMX8MQ_CLK_VPU_G1_ROOT>, <&clk IMX8MQ_CLK_VPU_G2_ROOT>, <&clk IMX8MQ_CLK_VPU_DEC_ROOT>;
 		clock-names = "clk_hantro_g1", "clk_hantro_g2", "clk_hantro_bus";
 		assigned-clocks = <&clk IMX8MQ_CLK_VPU_G1_SRC>, <&clk IMX8MQ_CLK_VPU_G2_SRC>, <&clk IMX8MQ_CLK_VPU_BUS_SRC>;
 		assigned-clock-parents = <&clk IMX8MQ_VPU_PLL_OUT>, <&clk IMX8MQ_VPU_PLL_OUT>, <&clk IMX8MQ_SYS1_PLL_800M>;
diff --git a/drivers/mxc/hantro/hantrodec.c b/drivers/mxc/hantro/hantrodec.c
index 3307abb..28a4dc4 100755
--- a/drivers/mxc/hantro/hantrodec.c
+++ b/drivers/mxc/hantro/hantrodec.c
@@ -404,7 +404,7 @@ int GetDecCoreID(hantrodec_t *dev, struct file* filp,
       break;
     }
   }
-  printk("GetDecCoreID=%d\n",core_id);
+  PDEBUG("GetDecCoreID=%d\n",core_id);
   return core_id;
 }
 
@@ -458,15 +458,17 @@ long ReserveDecoder(hantrodec_t *dev, struct file* filp, unsigned long format) {
 #if 1
   if(IS_G1(dev->hw_id[Core]))
   	{
-	  if (0 == hantrodec_choose_core(1)) 
-	    printk("G1 is reserved\n");
+	  if (0 == hantrodec_choose_core(1)) {
+	    PDEBUG("G1 is reserved\n");
+      }
 	  else
 	  	return -1;
   	}
   else
   	{
-      if (0 == hantrodec_choose_core(0))
-        printk("G2 is reserved\n");
+      if (0 == hantrodec_choose_core(0)){
+        PDEBUG("G2 is reserved\n");
+      }
 	  else
 	  	return -1;
   	}
@@ -1846,27 +1848,28 @@ static int hantro_dev_probe(struct platform_device *pdev)
         err = -ENOENT;
         goto error;
     }
-#if 1 //1 eagle : temporary code for zebu
+#if 1 //eagle : config code for bringup
 {
-    //#define CLK_RATE  (600000000)    //600MHZ
-#define CLKG1_RATE  (600000000)    //600MHZ
-#define CLKG2_RATE  (300000000)    //300MHZ
     int ret;
     volatile u8* iobase;
 
-    /*
-    mw 0x303a00f8 0x100
-    mw 0x38320000 0x3			// BLK_SFT_RSTN_CSR	0x00	VPUMIX G1/G2 block soft reset  control
-    mw 0x38320004 0x3			// BLK_CLK_EN_CSR	0x04	VPUMIX G1/G2 block clock enable control
-    */
-#if 0  //only needed by zebu
-    printk("will set 0x303a00f8 and 0x303a00EC \r\n");
-    iobase = (volatile u8 *) ioremap_nocache(0x303a0000,0x10000);
-    iowrite32(0x100,iobase+0xf8);
-    //iobase[0xf8]=0x100;
-    iowrite32(0x0000ffffl, iobase+0xEC);
-    iounmap(iobase);
-#endif
+    //printk("enable g1 and g2 clock  \r\n");
+    ret=clk_prepare(hantro_clk_g1);
+    //printk("prepare g1 ret: %d \r\n",ret);
+    ret=clk_enable(hantro_clk_g1);
+    //printk("enable g1 ret: %d \r\n",ret);
+    ret=clk_prepare(hantro_clk_g2);
+    //printk("prepare g2 ret: %d \r\n",ret);
+    ret=clk_enable(hantro_clk_g2);
+    //printk("enable g2 ret: %d \r\n",ret);
+    ret=clk_prepare(hantro_clk_bus);
+    //printk("prepare hantro bus ret: %d \r\n",ret);
+    ret=clk_enable(hantro_clk_bus);
+    //printk("enable hantro bus ret: %d \r\n",ret);
+    //printk("g1 clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_g1));
+    //printk("g2 clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_g2));
+    //printk("hantro bus clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_bus));
+
     //printk("will set 0x3832000X, reset g1 and g2 \r\n");
     iobase = (volatile u8 *) ioremap_nocache(0x38320000,0x10000);
     //iobase[0]=0x3;
@@ -1885,14 +1888,14 @@ static int hantro_dev_probe(struct platform_device *pdev)
         //printk("g2 fuse after set : 0x%X \n",val);    
         // G1 use, set to 1; G2 use, set to 0, choose the one you are using
 
-#if 0
+        /*
         //iowrite32(0x1, iobase + 0x14);  // VPUMIX only use G1
         val=ioread32(iobase + 0x14);
         printk("vpumix before set: 0x%X \n",val);  
         iowrite32(0x0, iobase + 0x14); // VPUMIX only use G2
         val=ioread32(iobase + 0x14);
         printk("vpumix after set: 0x%X \n",val);  
-#endif
+        */
     }
     iounmap(iobase);  
     //printk("enable hantro power \r\n");
@@ -1900,44 +1903,6 @@ static int hantro_dev_probe(struct platform_device *pdev)
     //  ret=pm_runtime_get_sync(hantro_dev);
     //  printk("turn power ret: %d \r\n",ret);
 
-#if 0
-    clk_prepare(hantro_clk_g1);
-    ret=clk_set_rate(hantro_clk_g1,CLKG1_RATE);
-    printk("set g1 rate: %d , ret: %d \r\n",CLKG1_RATE,ret);
-    clk_unprepare(hantro_clk_g1);
-
-    clk_prepare(hantro_clk_g2);
-    ret=clk_set_rate(hantro_clk_g2,CLKG2_RATE);
-    printk("set g2 rate: %d , ret: %d \r\n",CLKG2_RATE,ret);
-    clk_unprepare(hantro_clk_g2);
-#endif
-
-    //printk("enable g1 and g2 clock  \r\n");
-    ret=clk_prepare(hantro_clk_g1);
-    //printk("prepare g1 ret: %d \r\n",ret);
-    ret=clk_enable(hantro_clk_g1);
-    //printk("enable g1 ret: %d \r\n",ret);
-    ret=clk_prepare(hantro_clk_g2);
-    //printk("prepare g2 ret: %d \r\n",ret);
-    ret=clk_enable(hantro_clk_g2);
-    //printk("enable g2 ret: %d \r\n",ret);
-    ret=clk_prepare(hantro_clk_bus);
-    //printk("prepare hantro bus ret: %d \r\n",ret);
-    ret=clk_enable(hantro_clk_bus);
-    //printk("enable hantro bus ret: %d \r\n",ret);
-    //printk("g1 clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_g1));
-    //printk("g2 clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_g2));
-    //printk("hantro bus clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_bus));
-
-#if 0
-    printk("set g1 rate: %d , ret: %d \r\n",CLKG1_RATE,ret);
-    ret=clk_set_rate(hantro_clk_g1,CLKG1_RATE);
-    printk("set g2 rate: %d , ret: %d \r\n",CLKG2_RATE,ret);
-    ret=clk_set_rate(hantro_clk_g2,CLKG2_RATE);
-    printk("g1 clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_g1));
-    printk("g2 clk: get rate: %d \r\n",(int)clk_get_rate(hantro_clk_g2));
-#endif
-
 }
 
     if((ulong)reg_base!=multicorebase[0]){
-- 
1.7.9.5


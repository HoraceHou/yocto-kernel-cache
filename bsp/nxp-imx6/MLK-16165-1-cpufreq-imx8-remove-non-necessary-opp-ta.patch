From a1fd1bc7a5fe470b2675ced3aa45d3d3c263dc25 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Fri, 25 Aug 2017 13:03:23 +0800
Subject: [PATCH 2442/5242] MLK-16165-1 cpufreq: imx8: remove non-necessary
 opp table initialization

commit  4cd2fd537cec06d3f72a15b897269c3e70b9dee2 from
https://source.codeaurora.org/external/imx/linux-imx.git

For i.MX8QM/8QXP, suspend freq can use policy->max after cpu
freq table is validated, so no need to get OPP number and MAX
frequency for suspend freq now, also add necessary resource free
when probe failed.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/cpufreq/imx8-cpufreq.c |   92 ++++++++++++----------------------------
 1 file changed, 28 insertions(+), 64 deletions(-)

diff --git a/drivers/cpufreq/imx8-cpufreq.c b/drivers/cpufreq/imx8-cpufreq.c
index 5f9a50a..5a45b7d 100644
--- a/drivers/cpufreq/imx8-cpufreq.c
+++ b/drivers/cpufreq/imx8-cpufreq.c
@@ -29,8 +29,6 @@ struct imx8_cpufreq {
 struct imx8_cpufreq cluster_freq[MAX_CLUSTER_NUM];
 static struct cpufreq_frequency_table *freq_table[MAX_CLUSTER_NUM];
 static unsigned int transition_latency[MAX_CLUSTER_NUM];
-static unsigned int suspend_freq[MAX_CLUSTER_NUM];
-static bool free_opp;
 struct device *cpu_dev;
 
 static int imx8_set_target(struct cpufreq_policy *policy, unsigned int index)
@@ -70,10 +68,6 @@ static int imx8_cpufreq_init(struct cpufreq_policy *policy)
 
 	policy->clk = cluster_freq[cluster_id].cpu_clk;
 	policy->cur = clk_get_rate(cluster_freq[cluster_id].cpu_clk) / 1000;
-	policy->suspend_freq = suspend_freq[cluster_id];
-
-	pr_info("%s: cluster %d running at freq %d MHz\n",
-		__func__, cluster_id, policy->cur / 1000);
 	/*
 	 * The driver only supports the SMP configuartion where all processors
 	 * share the clock and voltage and clock.
@@ -87,6 +81,11 @@ static int imx8_cpufreq_init(struct cpufreq_policy *policy)
 	}
 
 	policy->cpuinfo.transition_latency = transition_latency[cluster_id];
+	policy->suspend_freq = policy->max;
+
+	pr_info("%s: cluster %d running at freq %d MHz, suspend freq %d MHz\n",
+		__func__, cluster_id, policy->cur / 1000,
+		policy->suspend_freq / 1000);
 
 	return ret;
 }
@@ -107,8 +106,9 @@ static int imx8_cpufreq_init(struct cpufreq_policy *policy)
 static int imx8_cpufreq_probe(struct platform_device *pdev)
 {
 	struct device_node *np;
-	int num, ret = 0;
+	int ret = 0;
 	int i, cluster_id;
+	struct device *first_cpu_dev = NULL;
 
 	cpu_dev = get_cpu_device(0);
 
@@ -137,46 +137,20 @@ static int imx8_cpufreq_probe(struct platform_device *pdev)
 		goto put_node;
 	}
 
-	/*
-	 * We expect an OPP table supplied by platform.
-	 * Just, in case the platform did not supply the OPP
-	 * table, it will try to get it.
-	 */
-	num = dev_pm_opp_get_opp_count(cpu_dev);
-	if (num < 0) {
-		ret = dev_pm_opp_of_add_table(cpu_dev);
-		if (ret < 0) {
-			dev_err(cpu_dev, "failed to init OPP table: %d\n", ret);
-			goto put_node;
-		}
-
-		/* Because we have added the OPPs here, we must free them */
-		free_opp = true;
-
-		num = dev_pm_opp_get_opp_count(cpu_dev);
-		if (num < 0) {
-			ret = num;
-			dev_err(cpu_dev, "no OPP table is found: %d\n", ret);
-			goto out_free_opp;
-		}
-	}
-
 	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table[cluster_id]);
 	if (ret) {
 		dev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);
-		goto put_node;
+		goto out_free_opp;
 	}
 
 	if (of_property_read_u32(np, "clock-latency", &transition_latency[cluster_id]))
 		transition_latency[cluster_id] = CPUFREQ_ETERNAL;
 
-	/* use MAX freq to suspend */
-	suspend_freq[cluster_id] = freq_table[cluster_id][num - 1].frequency;
-
 	/* init next cluster if there is */
 	for (i = 1; i < num_online_cpus(); i++) {
 		if (topology_physical_package_id(i) == topology_physical_package_id(0))
 			continue;
+		first_cpu_dev = cpu_dev;
 		cpu_dev = get_cpu_device(i);
 		if (!cpu_dev) {
 			pr_err("failed to get cpu device %d\n", i);
@@ -195,31 +169,13 @@ static int imx8_cpufreq_probe(struct platform_device *pdev)
 		if (IS_ERR(cluster_freq[cluster_id].cpu_clk)) {
 			dev_err(cpu_dev, "failed to get cluster %d clock\n", cluster_id);
 			ret = -ENOENT;
-			goto out_free_opp;
+			goto put_node;
 		}
 
-		/*
-		 * We expect an OPP table supplied by platform.
-		 * Just, in case the platform did not supply the OPP
-		 * table, it will try to get it.
-		 */
-		num = dev_pm_opp_get_opp_count(cpu_dev);
-		if (num < 0) {
-			ret = dev_pm_opp_of_add_table(cpu_dev);
-			if (ret < 0) {
-				dev_err(cpu_dev, "failed to init OPP table: %d\n", ret);
-				goto put_node;
-			}
-
-			/* Because we have added the OPPs here, we must free them */
-			free_opp = true;
-
-			num = dev_pm_opp_get_opp_count(cpu_dev);
-			if (num < 0) {
-				ret = num;
-				dev_err(cpu_dev, "no OPP table is found: %d\n", ret);
-				goto out_free_opp;
-			}
+		ret = dev_pm_opp_of_add_table(cpu_dev);
+		if (ret < 0) {
+			dev_err(cpu_dev, "failed to init OPP table: %d\n", ret);
+			goto put_node;
 		}
 
 		ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table[cluster_id]);
@@ -230,19 +186,27 @@ static int imx8_cpufreq_probe(struct platform_device *pdev)
 
 		if (of_property_read_u32(np, "clock-latency", &transition_latency[cluster_id]))
 			transition_latency[cluster_id] = CPUFREQ_ETERNAL;
-
-		/* use MAX freq to suspend */
-		suspend_freq[cluster_id] = freq_table[cluster_id][num - 1].frequency;
 		break;
 	}
 
 	ret = cpufreq_register_driver(&imx8_cpufreq_driver);
-	if (ret)
+	if (ret) {
 		dev_err(cpu_dev, "failed register driver: %d\n", ret);
+		if (cluster_id > 0 && first_cpu_dev != NULL) {
+			dev_pm_opp_free_cpufreq_table(first_cpu_dev, &freq_table[0]);
+			dev_pm_opp_of_remove_table(first_cpu_dev);
+		}
+		goto free_freq_table;
+	}
+
+	of_node_put(np);
+
+	return 0;
 
+free_freq_table:
+	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster_id]);
 out_free_opp:
-	if (free_opp)
-		dev_pm_opp_of_remove_table(cpu_dev);
+	dev_pm_opp_of_remove_table(cpu_dev);
 put_node:
 	of_node_put(np);
 	return ret;
-- 
1.7.9.5


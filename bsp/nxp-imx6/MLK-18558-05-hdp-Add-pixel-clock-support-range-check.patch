From 6243139f52f97147be60bf093aa07b1b540e7d4a Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Wed, 13 Jun 2018 15:40:39 +0800
Subject: [PATCH 4012/5242] MLK-18558-05: hdp: Add pixel clock support range
 check

commit  a02fe1fc6fd0f9e05d30ec436085c8a8fd15221e from
https://source.codeaurora.org/external/imx/linux-imx.git

Add hdmi pixel clock support range check for imx8m.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c |   15 +++++++++++++++
 drivers/gpu/drm/imx/hdp/imx-hdmi.h              |    1 +
 drivers/gpu/drm/imx/hdp/imx-hdp.c               |    9 +++++++++
 drivers/gpu/drm/imx/hdp/imx-hdp.h               |    1 +
 4 files changed, 26 insertions(+)

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
index afce326..c84837c2 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
@@ -49,6 +49,21 @@
 #include "API_AFE_t28hpc_hdmitx.h"
 #include "t28hpc_hdmitx_table.h"
 
+/* check pixel clock rate in
+ * Table 8. HDMI TX pixel clock */
+int pixel_clock_range_t28hpc(struct drm_display_mode *mode)
+{
+	int i, row, rate;
+
+	row = T28HPC_HDMITX_CLOCK_CONTROL_TABLE_ROWS_PIXEL_OUT;
+	for (i = 0; i < row; i++) {
+		   rate = t28hpc_hdmitx_clock_control_table_pixel_out[i][T8_PIXEL_CLK_FREQ_KHZ];
+		   if (rate == mode->clock)
+			   return 1;
+	}
+	return 0;
+}
+
 int phy_cfg_hdp_t28hpc(state_struct *state,
 				int num_lanes,
 				struct drm_display_mode *mode,
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.h b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
index 595b383..3d53117 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
@@ -28,5 +28,6 @@ void hdmi_mode_set_t28hpc(state_struct *state,
 int hdmi_get_hpd_state(state_struct *state, u8 *hpd);
 int hdmi_write_hdr_metadata(state_struct *state,
 			    union hdmi_infoframe *hdr_infoframe);
+int pixel_clock_range_t28hpc(struct drm_display_mode *mode);
 
 #endif
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index e0c3339..c768557 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -633,6 +633,7 @@ static int imx_hdp_connector_get_modes(struct drm_connector *connector)
 					     connector);
 	enum drm_mode_status mode_status = MODE_OK;
 	struct drm_cmdline_mode *cmdline_mode;
+	int ret;
 
 	cmdline_mode = &connector->cmdline_mode;
 
@@ -648,6 +649,12 @@ static int imx_hdp_connector_get_modes(struct drm_connector *connector)
 	else if (!hdp->is_4kp60 && mode->clock > 297000)
 		return MODE_CLOCK_HIGH;
 
+	ret = imx_hdp_call(hdp, pixel_clock_range, mode);
+	if (ret == 0) {
+		DRM_DEBUG("pixel clock %d out of range\n", mode->clock);
+		return MODE_CLOCK_RANGE;
+	}
+
 	/* 4096x2160 is not supported now */
 	if (mode->hdisplay > 3840)
 		return MODE_BAD_HVALUE;
@@ -655,6 +662,7 @@ static int imx_hdp_connector_get_modes(struct drm_connector *connector)
 	if (mode->vdisplay > 2160)
 		return MODE_BAD_VVALUE;
 
+
 	return mode_status;
 }
 
@@ -957,6 +965,7 @@ static int imx8qm_hdp_swrite(struct hdp_mem *mem, unsigned int addr, unsigned in
 	.get_edid_block = hdmi_get_edid_block,
 	.get_hpd_state = hdmi_get_hpd_state,
 	.write_hdr_metadata = hdmi_write_hdr_metadata,
+	.pixel_clock_range = pixel_clock_range_t28hpc,
 };
 
 static struct hdp_devtype imx8mq_hdmi_devtype = {
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index 7a1dfd1..ffc5f21 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -106,6 +106,7 @@ struct hdp_ops {
 	int (*pixel_clock_enable)(struct hdp_clks *clks);
 	void (*pixel_clock_disable)(struct hdp_clks *clks);
 	void (*pixel_clock_set_rate)(struct hdp_clks *clks);
+	int (*pixel_clock_range)(struct drm_display_mode *mode);
 };
 
 struct hdp_devtype {
-- 
1.7.9.5


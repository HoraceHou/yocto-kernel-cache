From 9035ba70746615d0c8b9ea926e458695513493b3 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Thu, 12 Oct 2017 21:34:11 +0800
Subject: [PATCH 2631/5242] MLK-16546-2 soc: imx: pm-domains: support early
 power on resource after resume

commit  58d98d3d5219b73f2232829b75cdde5e33cf63ca from
https://source.codeaurora.org/external/imx/linux-imx.git

On i.MX8QM/8QXP, for some resources which act as irq chip
etc., they need to be powered on earlier than device resume
phase, as they need to access registers, common power domain
resume is too late, so add syscore resume callback in pm
domain driver, for those resources with "early_power_on"
property set, they will be powered on at syscore resume phase,
by default, it supports 10 resources, and can be increased
if needed.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Reviewed-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/pm-domains.c |   34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/soc/imx/pm-domains.c b/drivers/soc/imx/pm-domains.c
index 8509c8b..5626315 100644
--- a/drivers/soc/imx/pm-domains.c
+++ b/drivers/soc/imx/pm-domains.c
@@ -26,12 +26,17 @@
 #include <linux/pm_runtime.h>
 #include <linux/pm_clock.h>
 #include <linux/slab.h>
+#include <linux/syscore_ops.h>
 
 #include <soc/imx8/sc/sci.h>
 
 #include "pm-domain-imx8.h"
 
 static sc_ipc_t pm_ipc_handle;
+static sc_rsrc_t early_power_on_rsrc[] = {
+	SC_R_LAST, SC_R_LAST, SC_R_LAST, SC_R_LAST, SC_R_LAST,
+	SC_R_LAST, SC_R_LAST, SC_R_LAST, SC_R_LAST, SC_R_LAST,
+};
 
 static int imx8_pd_power(struct generic_pm_domain *domain, bool power_on)
 {
@@ -202,10 +207,32 @@ static void imx8_detach_dev(struct generic_pm_domain *genpd, struct device *dev)
 	}
 }
 
+static void imx8_pm_domains_resume(void)
+{
+	sc_err_t sci_err = SC_ERR_NONE;
+	int i;
+
+	for (i = 0; i < (sizeof(early_power_on_rsrc) /
+		sizeof(sc_rsrc_t)); i++) {
+		if (early_power_on_rsrc[i] != SC_R_LAST) {
+			sci_err = sc_pm_set_resource_power_mode(pm_ipc_handle,
+				early_power_on_rsrc[i], SC_PM_PW_MODE_ON);
+			if (sci_err != SC_ERR_NONE)
+				pr_err("fail to power on resource %d\n",
+					early_power_on_rsrc[i]);
+		}
+	}
+}
+
+struct syscore_ops imx8_pm_domains_syscore_ops = {
+	.resume = imx8_pm_domains_resume,
+};
+
 static int __init imx8_add_pm_domains(struct device_node *parent,
 					struct generic_pm_domain *genpd_parent)
 {
 	struct device_node *np;
+	int index = 0;
 
 	for_each_child_of_node(parent, np) {
 		struct imx8_pm_domain *imx8_pd;
@@ -231,6 +258,12 @@ static int __init imx8_add_pm_domains(struct device_node *parent,
 			imx8_pd->pd.dev_ops.stop = imx8_pd_dev_stop;
 			imx8_pd->pd.attach_dev = imx8_attach_dev;
 			imx8_pd->pd.detach_dev = imx8_detach_dev;
+
+			if (of_property_read_bool(np, "early_power_on")
+				&& index < (sizeof(early_power_on_rsrc) /
+				sizeof(sc_rsrc_t))) {
+				early_power_on_rsrc[index++] = imx8_pd->rsrc_id;
+			}
 		}
 		INIT_LIST_HEAD(&imx8_pd->clks);
 		pm_genpd_init(&imx8_pd->pd, NULL, true);
@@ -296,6 +329,7 @@ static int __init imx8_init_pm_domains(void)
 	}
 
 	sci_err = sc_ipc_open(&pm_ipc_handle, mu_id);
+	register_syscore_ops(&imx8_pm_domains_syscore_ops);
 
 	return 0;
 }
-- 
1.7.9.5


From ef13f3c1b391e668cf9673500a79ae2ef456d61c Mon Sep 17 00:00:00 2001
From: Viorel Suman <viorel.suman@nxp.com>
Date: Wed, 3 May 2017 10:16:02 +0300
Subject: [PATCH 1734/5242] ASoC: fsl_sai: handle slave mode per TX/RX
 direction

commit  1665bb01d1485150598a235313deca9ca68ee800 from
https://source.codeaurora.org/external/imx/linux-imx.git

The SAI interface can be a clock supplier or consummer
as function of stream direction, ie when interacting
with I2S XTOR. Removed FSL_SAI_RFR define as it is now
referred as FSL_SAI_RFR0.

Signed-off-by: Viorel Suman <viorel.suman@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_sai.c |   18 +++++++++---------
 sound/soc/fsl/fsl_sai.h |    3 +--
 2 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 6912f58..695a1fb 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -300,7 +300,7 @@ static int fsl_sai_set_dai_fmt_tr(struct snd_soc_dai *cpu_dai,
 		return -EINVAL;
 	}
 
-	sai->is_slave_mode = false;
+	sai->slave_mode[tx] = false;
 
 	/* DAI clock master masks */
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
@@ -309,14 +309,14 @@ static int fsl_sai_set_dai_fmt_tr(struct snd_soc_dai *cpu_dai,
 		val_cr4 |= FSL_SAI_CR4_FSD_MSTR;
 		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
-		sai->is_slave_mode = true;
+		sai->slave_mode[tx] = true;
 		break;
 	case SND_SOC_DAIFMT_CBS_CFM:
 		val_cr2 |= FSL_SAI_CR2_BCD_MSTR;
 		break;
 	case SND_SOC_DAIFMT_CBM_CFS:
 		val_cr4 |= FSL_SAI_CR4_FSD_MSTR;
-		sai->is_slave_mode = true;
+		sai->slave_mode[tx] = true;
 		break;
 	default:
 		return -EINVAL;
@@ -357,7 +357,7 @@ static int fsl_sai_set_bclk(struct snd_soc_dai *dai, bool tx, u32 freq)
 	int ret = 0;
 
 	/* Don't apply to slave mode */
-	if (sai->is_slave_mode)
+	if (sai->slave_mode[tx])
 		return 0;
 
 	for (id = 0; id < FSL_SAI_MCLK_MAX; id++) {
@@ -452,7 +452,7 @@ static int fsl_sai_hw_params(struct snd_pcm_substream *substream,
 	if (sai->slot_width)
 		slot_width = sai->slot_width;
 
-	if (!sai->is_slave_mode) {
+	if (!sai->slave_mode[tx]) {
 		ret = fsl_sai_set_bclk(cpu_dai, tx,
 				slots * slot_width * params_rate(params));
 		if (ret)
@@ -488,7 +488,7 @@ static int fsl_sai_hw_params(struct snd_pcm_substream *substream,
 	 * error.
 	 */
 
-	if (!sai->is_slave_mode) {
+	if (!sai->slave_mode[tx]) {
 		if (!sai->synchronous[TX] && sai->synchronous[RX] && !tx) {
 			regmap_update_bits(sai->regmap, FSL_SAI_TCR4,
 				FSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,
@@ -517,7 +517,7 @@ static int fsl_sai_hw_params(struct snd_pcm_substream *substream,
 	 * error.
 	 */
 
-	if (!sai->is_slave_mode) {
+	if (!sai->slave_mode[tx]) {
 		if (!sai->synchronous[TX] && sai->synchronous[RX] && !tx) {
 			regmap_update_bits(sai->regmap, FSL_SAI_TCR4,
 				FSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,
@@ -575,7 +575,7 @@ static int fsl_sai_hw_free(struct snd_pcm_substream *substream,
 	struct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
-	if (!sai->is_slave_mode &&
+	if (!sai->slave_mode[tx] &&
 			sai->mclk_streams & BIT(substream->stream)) {
 		clk_disable_unprepare(sai->mclk_clk[sai->mclk_id[tx]]);
 		sai->mclk_streams &= ~BIT(substream->stream);
@@ -670,7 +670,7 @@ static int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,
 			 * This is a hardware bug, and will be fix in the
 			 * next sai version.
 			 */
-			if (!sai->is_slave_mode) {
+			if (!sai->slave_mode[tx]) {
 				/* Software Reset for both Tx and Rx */
 				regmap_write(sai->regmap,
 					     FSL_SAI_TCSR, FSL_SAI_CSR_SR);
diff --git a/sound/soc/fsl/fsl_sai.h b/sound/soc/fsl/fsl_sai.h
index ab1b103..2e9ddf6 100644
--- a/sound/soc/fsl/fsl_sai.h
+++ b/sound/soc/fsl/fsl_sai.h
@@ -36,7 +36,6 @@
 #define FSL_SAI_RDR1    0xa4 /* SAI Receive Data */
 #define FSL_SAI_RFR0    0xc0 /* SAI Receive FIFO */
 #define FSL_SAI_RFR1    0xc4 /* SAI Receive FIFO */
-#define FSL_SAI_RFR	0xc0 /* SAI Receive FIFO */
 #define FSL_SAI_RMR	0xe0 /* SAI Receive Mask */
 
 #define FSL_SAI_xCSR(tx)	(tx ? FSL_SAI_TCSR : FSL_SAI_RCSR)
@@ -157,7 +156,7 @@ struct fsl_sai {
 	struct clk *bus_clk;
 	struct clk *mclk_clk[FSL_SAI_MCLK_MAX];
 
-	bool is_slave_mode;
+	bool slave_mode[2];
 	bool is_lsb_first;
 	bool is_dsp_mode;
 	bool sai_on_imx;
-- 
1.7.9.5


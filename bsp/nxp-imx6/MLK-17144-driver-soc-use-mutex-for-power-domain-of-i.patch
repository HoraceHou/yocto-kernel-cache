From a7515fa428e9fb621af7a991779b35955cfd169e Mon Sep 17 00:00:00 2001
From: Bai Ping <ping.bai@nxp.com>
Date: Mon, 11 Dec 2017 12:51:23 +0800
Subject: [PATCH 3064/5242] MLK-17144 driver: soc: use mutex for power domain
 of imx8mq

commit  d8e0438e0c044d2ce060461bba5b8ffe6c088be1 from
https://source.codeaurora.org/external/imx/linux-imx.git

In current gpc-psci.c file, the irqchip driver and gpc power
domain driver use the same spinlock to prevent concurrent
access to the GPC module. But actually, the irq and power domain
are two seperated function and controlled by different registers.

when using the same spinlock for these two funcition, in some corner
case the system will be deadlock if the spinlock is already acquired
by the power domain, but the power domain on/off is interrupted by
timer IRQ. So adding a mutex for power domain driver.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Reviewed-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/gpc-psci.c |    9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/drivers/soc/imx/gpc-psci.c b/drivers/soc/imx/gpc-psci.c
index 49ad145..701a708 100644
--- a/drivers/soc/imx/gpc-psci.c
+++ b/drivers/soc/imx/gpc-psci.c
@@ -50,6 +50,7 @@ enum imx_gpc_pm_domain_state {
 #define to_imx_gpc_pm_domain(_genpd) container_of(_genpd, struct imx_gpc_pm_domain, pd)
 
 static DEFINE_SPINLOCK(gpc_psci_lock);
+static DEFINE_MUTEX(gpc_pd_mutex);
 
 static void imx_gpc_psci_irq_unmask(struct irq_data *d)
 {
@@ -216,10 +217,10 @@ static int imx_gpc_pd_power_on(struct generic_pm_domain *domain)
 			clk_prepare_enable(pd->clks[index]);
 	}
 
-	spin_lock(&gpc_psci_lock);
+	mutex_lock(&gpc_pd_mutex);
 	arm_smccc_smc(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN, pd->gpc_domain_id,
 		      GPC_PD_STATE_ON, 0, 0, 0, 0, &res);
-	spin_unlock(&gpc_psci_lock);
+	mutex_unlock(&gpc_pd_mutex);
 
 	return 0;
 }
@@ -230,10 +231,10 @@ static int imx_gpc_pd_power_off(struct generic_pm_domain *domain)
 	struct arm_smccc_res res;
 	int index, ret = 0;
 
-	spin_lock(&gpc_psci_lock);
+	mutex_lock(&gpc_pd_mutex);
 	arm_smccc_smc(FSL_SIP_GPC, FSL_SIP_CONFIG_GPC_PM_DOMAIN, pd->gpc_domain_id,
 		      GPC_PD_STATE_OFF, 0, 0, 0, 0, &res);
-	spin_unlock(&gpc_psci_lock);
+	mutex_unlock(&gpc_pd_mutex);
 
 	/* power off the external supply */
 	if (!IS_ERR(pd->reg)) {
-- 
1.7.9.5


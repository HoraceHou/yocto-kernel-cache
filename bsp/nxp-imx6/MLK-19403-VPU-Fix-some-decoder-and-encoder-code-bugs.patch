From 9fc048f168fdf0c641456e343384aca2dab54caa Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Thu, 30 Aug 2018 17:49:26 +0800
Subject: [PATCH 4484/5242] MLK-19403 VPU: Fix some decoder and encoder code
 bugs

commit  547c03ef5656aaed682e18fa3ef6ac071704dfc9 from
https://source.codeaurora.org/external/imx/linux-imx.git

Fix some decoder and encoder code bugs as follows:
- change vpu_stop_streaming to prevent deleting repeated entry
- reduce wait time for encoder from 5s to 1s
- change vpu_suspend to correct the calling of vpu_set_power() function
- change vpu_next_free_instance() to depart QM from QXP

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
(cherry picked from commit 77a85c0fdeecac5042147d4e842e6a60240a745e)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/vpu_b0.c         |    4 +++
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c |   36 ++++++++++++++++-----------
 2 files changed, 25 insertions(+), 15 deletions(-)

diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index e560121..f5987c6 100755
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -2186,12 +2186,15 @@ static int vpu_start_streaming(struct vb2_queue *q,
 static void vpu_stop_streaming(struct vb2_queue *q)
 {
 	struct queue_data *This = (struct queue_data *)q->drv_priv;
+#if 0
 	struct vb2_data_req *p_data_req = NULL;
 	struct vb2_data_req *p_temp;
+#endif
 	struct vb2_buffer *vb;
 
 	vpu_dbg(LVL_INFO, "%s() is called\n", __func__);
 	down(&This->drv_q_lock);
+#if 0
 	if (!list_empty(&This->drv_q)) {
 		list_for_each_entry_safe(p_data_req, p_temp, &This->drv_q, list) {
 			vpu_dbg(LVL_INFO, "%s(%d) - list_del(%p)\n",
@@ -2201,6 +2204,7 @@ static void vpu_stop_streaming(struct vb2_queue *q)
 			list_del(&p_data_req->list);
 		}
 	}
+#endif
 	if (!list_empty(&q->queued_list))
 		list_for_each_entry(vb, &q->queued_list, queued_entry) {
 			if (vb->state == VB2_BUF_STATE_ACTIVE)
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index c57cdf5..3b8c369 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -875,9 +875,9 @@ static bool update_yuv_addr(struct vpu_ctx *ctx, u_int32 uStrIdx)
 	while (1) {
 		if (!wait_event_interruptible_timeout(ctx->buffer_wq_input,
 				(!list_empty(&This->drv_q)) || ctx->forceStop,
-				msecs_to_jiffies(5000))) {
+				msecs_to_jiffies(1000))) {
 			if (!ctx->forceStop)
-				vpu_dbg(LVL_ERR, " warn: yuv wait_event_interruptible_timeout wait 5s timeout\n");
+				vpu_dbg(LVL_ERR, " warn: yuv wait_event_interruptible_timeout wait 1s timeout\n");
 			else
 				break;
 		}
@@ -959,9 +959,9 @@ static void report_stream_done(struct vpu_ctx *ctx,  MEDIAIP_ENC_PIC_INFO *pEncP
 	while (1) {
 		if (!wait_event_interruptible_timeout(ctx->buffer_wq_output,
 				(!list_empty(&This->drv_q)),
-				msecs_to_jiffies(5000))) {
+				msecs_to_jiffies(1000))) {
 			if (!ctx->forceStop)
-				vpu_dbg(LVL_ERR, " warn: stream wait_event_interruptible_timeout wait 5s timeout\n");
+				vpu_dbg(LVL_ERR, " warn: stream wait_event_interruptible_timeout wait 1s timeout\n");
 			else
 				break;
 		}
@@ -1286,14 +1286,22 @@ static int vpu_next_free_instance(struct vpu_dev *dev, struct vpu_ctx *ctx)
 	int idx0 = hweight32(dev->core_dev[0].instance_mask);
 	int idx1 = hweight32(dev->core_dev[1].instance_mask);
 
-	if (idx0 <= idx1 && idx0 < VPU_MAX_NUM_STREAMS) {
-		idx = ffz(dev->core_dev[0].instance_mask);
-		ctx->core_id = 0;
-	} else if (idx1 < VPU_MAX_NUM_STREAMS) {
-		idx = ffz(dev->core_dev[1].instance_mask);
-		ctx->core_id = 1;
-	} else
-		return -EBUSY;
+	if (dev->plat_type == IMX8QM) {
+		if (idx0 <= idx1 && idx0 < VPU_MAX_NUM_STREAMS) {
+			idx = ffz(dev->core_dev[0].instance_mask);
+			ctx->core_id = 0;
+		} else if (idx1 < VPU_MAX_NUM_STREAMS) {
+			idx = ffz(dev->core_dev[1].instance_mask);
+			ctx->core_id = 1;
+		} else
+			return -EBUSY;
+	} else {
+		if (idx0 < VPU_MAX_NUM_STREAMS) {
+			idx = ffz(dev->core_dev[0].instance_mask);
+			ctx->core_id = 0;
+		} else
+			return -EBUSY;
+	}
 
 	return idx;
 }
@@ -2297,7 +2305,6 @@ static int vpu_suspend(struct device *dev)
 		core_num = 1;
 
 	for (i = 0; i < core_num; i++) {
-		vpu_set_power(vpudev, false, i);
 		core_dev = &vpudev->core_dev[i];
 		if (core_dev->hang_mask != core_dev->instance_mask) {
 
@@ -2309,10 +2316,9 @@ static int vpu_suspend(struct device *dev)
 				return -1;
 			}
 		}
+		vpu_set_power(vpudev, false, i);
 	}
 
-//	vpu_set_power(vpudev, false);
-
 	return 0;
 }
 
-- 
1.7.9.5


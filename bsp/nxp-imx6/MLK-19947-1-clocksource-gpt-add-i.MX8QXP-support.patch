From 1a1acf1c02c65f79a7f4a72d41be40aa0a789ced Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Tue, 16 Oct 2018 11:15:06 +0800
Subject: [PATCH 4917/5242] MLK-19947-1 clocksource: gpt: add i.MX8QXP support

commit  d9d79b6d150dfdfce48107bae84723140e4db6af from
https://source.codeaurora.org/external/imx/linux-imx.git

i.MX8QXP will use GPT timer as platform broadcast time for waking
up CPUs when cluster is off, GPT timer needs to be probed after
clock driver ready, and GPT suspend is at syscore suspend phase,
to make the clock & power management as well as GPT save/restore
easy, all these things are done in TF-A.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Acked-by: Leonard Crestez <leonard.crestez@nxp.com>
Reviewed-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/clocksource/Kconfig         |    2 +-
 drivers/clocksource/timer-imx-gpt.c |   20 ++++++++++++++++++++
 2 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 277fff3..345ee63 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -592,7 +592,7 @@ config H8300_TPU
 
 config CLKSRC_IMX_GPT
 	bool "Clocksource using i.MX GPT" if COMPILE_TEST
-	depends on ARM && CLKDEV_LOOKUP
+	depends on (ARM || ARM64) && CLKDEV_LOOKUP
 	select CLKSRC_MMIO
 
 config CLKSRC_IMX_TPM
diff --git a/drivers/clocksource/timer-imx-gpt.c b/drivers/clocksource/timer-imx-gpt.c
index 9c14de6..15fa1a9 100644
--- a/drivers/clocksource/timer-imx-gpt.c
+++ b/drivers/clocksource/timer-imx-gpt.c
@@ -141,21 +141,25 @@ static u64 notrace mxc_read_sched_clock(void)
 	return sched_clock_reg ? readl_relaxed(sched_clock_reg) : 0;
 }
 
+#ifndef CONFIG_ARM64
 static struct delay_timer imx_delay_timer;
 
 static unsigned long imx_read_current_timer(void)
 {
 	return readl_relaxed(sched_clock_reg);
 }
+#endif
 
 static int __init mxc_clocksource_init(struct imx_timer *imxtm)
 {
 	unsigned int c = clk_get_rate(imxtm->clk_per);
 	void __iomem *reg = imxtm->base + imxtm->gpt->reg_tcn;
 
+#ifndef CONFIG_ARM64
 	imx_delay_timer.read_current_timer = &imx_read_current_timer;
 	imx_delay_timer.freq = c;
 	register_current_timer_delay(&imx_delay_timer);
+#endif
 
 	sched_clock_reg = reg;
 
@@ -529,6 +533,19 @@ static int __init imx6dl_timer_init_dt(struct device_node *np)
 	return mxc_timer_init_dt(np, GPT_TYPE_IMX6DL);
 }
 
+#ifdef CONFIG_ARM64
+static int __init imx8qxp_timer_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx8qxp-gpt");
+	if (!np)
+		return -ENOENT;
+
+	return mxc_timer_init_dt(np, GPT_TYPE_IMX6DL);
+}
+#endif
+
 TIMER_OF_DECLARE(imx1_timer, "fsl,imx1-gpt", imx1_timer_init_dt);
 TIMER_OF_DECLARE(imx21_timer, "fsl,imx21-gpt", imx21_timer_init_dt);
 TIMER_OF_DECLARE(imx27_timer, "fsl,imx27-gpt", imx21_timer_init_dt);
@@ -544,3 +561,6 @@ static int __init imx6dl_timer_init_dt(struct device_node *np)
 TIMER_OF_DECLARE(imx6sx_timer, "fsl,imx6sx-gpt", imx6dl_timer_init_dt);
 TIMER_OF_DECLARE(imx6ul_timer, "fsl,imx6ul-gpt", imx6dl_timer_init_dt);
 TIMER_OF_DECLARE(mx7d_timer, "fsl,imx7d-gpt", imx6dl_timer_init_dt);
+#ifdef CONFIG_ARM64
+subsys_initcall(imx8qxp_timer_init);
+#endif
-- 
1.7.9.5


From 176551dc03f610e6f60feb84a6b474932cea6fa8 Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Tue, 5 Dec 2017 18:36:02 +0200
Subject: [PATCH 2995/5242] MLK-16986-3: drm/imx: Add a delay to enable
 function in nwl_dsi-imx

commit  e80a9cc5a195194e878dbfad1bd5456c05d0a752 from
https://source.codeaurora.org/external/imx/linux-imx.git

To allow the PLL to become stable before enabling the clocks, we may
need a delay. This patch adds a new property to specify this delay from
DTS file.

Reviewed-by: Laurentiu Palcu <laurentiu.palcu@nxp.com
Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/display/imx/dsi_nwl.txt    |    3 +++
 .../dts/freescale/fsl-imx8mq-evk-lcdif-adv7535.dts |    1 +
 drivers/gpu/drm/imx/nwl_dsi-imx.c                  |   18 +++++++++++++++++-
 3 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt b/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt
index 76441b2..f37ddfe 100644
--- a/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt
+++ b/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt
@@ -46,6 +46,9 @@ Optional properties:
 			signal; can be <0> for LOW (negative) or <1> for HIGH
 			(positive) polarity; default value is <0>, when this
 			property is ommited
+- pwr-delay		delay used in enable, before enabling the clocks; this is
+			useful when the PLL needs some time to become stable;
+			this value represents milliseconds
 
 Example:
 	mipi_dsi1: mipi_dsi {
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk-lcdif-adv7535.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk-lcdif-adv7535.dts
index 133ace3c..36069c3 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk-lcdif-adv7535.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk-lcdif-adv7535.dts
@@ -73,6 +73,7 @@
 	status = "okay";
 	as_bridge;
 	sync-pol = <1>;
+	pwr-delay = <10>;
 
 	port@1 {
 		mipi_dsi_in: endpoint {
diff --git a/drivers/gpu/drm/imx/nwl_dsi-imx.c b/drivers/gpu/drm/imx/nwl_dsi-imx.c
index b03b13f..cf2ad9c 100644
--- a/drivers/gpu/drm/imx/nwl_dsi-imx.c
+++ b/drivers/gpu/drm/imx/nwl_dsi-imx.c
@@ -91,6 +91,7 @@ struct imx_mipi_dsi {
 	u32				phyref_rate;
 	u32				instance;
 	u32				sync_pol;
+	u32				power_on_delay;
 	bool				enabled;
 };
 
@@ -466,7 +467,7 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 	const struct of_device_id *of_id = of_match_device(imx_nwl_dsi_dt_ids,
 							   dev);
 	const struct devtype *devtype = of_id->data;
-	unsigned long bit_clk;
+	unsigned long bit_clk, min_sleep, max_sleep;
 	int ret;
 
 	if (dsi->enabled)
@@ -493,6 +494,20 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 		dsi->bit_clk = bit_clk;
 	}
 
+	/*
+	 * On some systems we need to wait some time before enabling the
+	 * phy_ref clock, in order to allow the parent PLL to become stable
+	 */
+	if (dsi->power_on_delay > 20) {
+		msleep(dsi->power_on_delay);
+	} else if (dsi->power_on_delay > 0) {
+		max_sleep = dsi->power_on_delay * 1000;
+		min_sleep = 1000;
+		if (max_sleep > 6000)
+			min_sleep = max_sleep - 5000;
+		usleep_range(min_sleep, max_sleep);
+	}
+
 	imx_nwl_dsi_set_clocks(dsi, true);
 
 	ret = devtype->poweron(dsi);
@@ -771,6 +786,7 @@ static int imx_nwl_dsi_parse_of(struct device *dev, bool as_bridge)
 	dsi->pxl2dpi_reg = devtype->pxl2dpi_reg;
 
 	of_property_read_u32(np, "sync-pol", &dsi->sync_pol);
+	of_property_read_u32(np, "pwr-delay", &dsi->power_on_delay);
 
 	/* Look for optional regmaps */
 	dsi->csr = syscon_regmap_lookup_by_phandle(np, "csr");
-- 
1.7.9.5


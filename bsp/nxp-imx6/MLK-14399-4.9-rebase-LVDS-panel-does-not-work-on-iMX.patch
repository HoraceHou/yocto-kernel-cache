From 3d077172c459261101c29ec436295a389af494b6 Mon Sep 17 00:00:00 2001
From: Cristina Ciocan <cristina-mihaela.ciocan@nxp.com>
Date: Thu, 9 Mar 2017 20:13:17 +0200
Subject: [PATCH 1559/5242] MLK-14399: 4.9 rebase: LVDS panel does not work on
 iMX6SX Auto

commit  929d75b54be6a4652e81ad6a77065c8e17151839 from
https://source.codeaurora.org/external/imx/linux-imx.git

The LCDIF driver fails at boot time because it cannot read display timings
from device tree. This is a fake error because the LCDIF DT node contains a
display device property which leads to the display driver that also provides
the timings.

This fake error case has been introduced by
commit 5443a75ed038 ("MLK-14283: dts: fix DE polarity for lcdif") and
commit 56412d6a83d8 ("MLK-13996: lcdif: Use DE polarity specified in DTS")
which fixed DE polarity panel differences for different boards.

This patch adds support for choosing a particular video mode from the ones
provided by the display driver, thus also fixing the DE polarity issue
initially fixed by the above mentioned 2 patches.

Signed-off-by: Cristina Ciocan <cristina-mihaela.ciocan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/display/mxsfb.txt          |   49 ++++++++++++++++++++
 arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dts           |    1 +
 drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c        |   25 +++++++---
 drivers/video/fbdev/mxsfb.c                        |   28 ++++++++++-
 4 files changed, 94 insertions(+), 9 deletions(-)

diff --git a/Documentation/devicetree/bindings/display/mxsfb.txt b/Documentation/devicetree/bindings/display/mxsfb.txt
index 472e1ea..77c873e 100644
--- a/Documentation/devicetree/bindings/display/mxsfb.txt
+++ b/Documentation/devicetree/bindings/display/mxsfb.txt
@@ -44,6 +44,12 @@ Required properties:
 - interrupts:	Should contain LCDIF interrupts
 - display:	phandle to display node (see below for details)
 
+Optional properties:
+- disp-dev: Display device driver name
+- disp-videomode: Display device video mode name; this is used if the panel
+  supports multiple video modes, in order to chose the right one (see below for
+  examples)
+
 * display node
 
 Required properties:
@@ -84,3 +90,46 @@ lcdif@80030000 {
 		};
 	};
 };
+
+Examples - optional properties:
+
+Snippet from imx7d-sdb-mipi-dsi.dts:
+
+&lcdif {
+	disp-dev = "mipi_dsi_samsung";
+	disp-videomode = "TRUULY-WVGA-SYNC-LOW";
+};
+
+&mipi_dsi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mipi_dsi_reset>;
+	lcd_panel = "TRULY-WVGA-TFT3P5581E";
+	resets = <&mipi_dsi_reset>;
+	status = "okay";
+};
+
+In the above example, the panel supports 2 video modes (snippet from
+drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c):
+
+#define ACTIVE_HIGH_NAME	"TRUULY-WVGA-SYNC-HIGH"
+#define ACTIVE_LOW_NAME		"TRUULY-WVGA-SYNC-LOW"
+
+static struct fb_videomode truly_lcd_modedb[] = {
+	{
+		ACTIVE_HIGH_NAME, 50, 480, 854, 41042,
+		40, 60,
+		3, 3,
+		8, 4,
+		0x0,
+		FB_VMODE_NONINTERLACED,
+		0,
+	}, {
+		ACTIVE_LOW_NAME, 50, 480, 854, 41042,
+		40, 60,
+		3, 3,
+		8, 4,
+		FB_SYNC_OE_LOW_ACT,
+		FB_VMODE_NONINTERLACED,
+		0,
+	},
+};
diff --git a/arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dts b/arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dts
index bbfca36..327d976 100644
--- a/arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dts
+++ b/arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dts
@@ -19,6 +19,7 @@
 
 &lcdif {
 	disp-dev = "mipi_dsi_samsung";
+	disp-videomode = "TRUULY-WVGA-SYNC-LOW";
 };
 
 &mipi_dsi {
diff --git a/drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c b/drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c
index d6052bc..155e849 100644
--- a/drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c
+++ b/drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c
@@ -128,15 +128,26 @@ static void parse_variadic(int n, u8 *buf, ...)
 
 static int hx8363bl_brightness;
 
+#define ACTIVE_HIGH_NAME	"TRUULY-WVGA-SYNC-HIGH"
+#define ACTIVE_LOW_NAME		"TRUULY-WVGA-SYNC-LOW"
+
 static struct fb_videomode truly_lcd_modedb[] = {
 	{
-	 "TRUULY-WVGA", 50, 480, 854, 41042,
-	 40, 60,
-	 3, 3,
-	 8, 4,
-	 0x0,
-	 FB_VMODE_NONINTERLACED,
-	 0,
+		ACTIVE_HIGH_NAME, 50, 480, 854, 41042,
+		40, 60,
+		3, 3,
+		8, 4,
+		0x0,
+		FB_VMODE_NONINTERLACED,
+		0,
+	}, {
+		ACTIVE_LOW_NAME, 50, 480, 854, 41042,
+		40, 60,
+		3, 3,
+		8, 4,
+		FB_SYNC_OE_LOW_ACT,
+		FB_VMODE_NONINTERLACED,
+		0,
 	},
 };
 
diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c
index 663f1e6..a9baa4e 100644
--- a/drivers/video/fbdev/mxsfb.c
+++ b/drivers/video/fbdev/mxsfb.c
@@ -233,6 +233,8 @@ struct mxsfb_layer {
 	struct mxsfb_info	*fbi;
 };
 
+#define NAME_LEN	32
+
 struct mxsfb_info {
 	struct platform_device *pdev;
 	struct clk *clk_pix;
@@ -254,12 +256,14 @@ struct mxsfb_info {
 	struct completion flip_complete;
 	int cur_blank;
 	int restore_blank;
-	char disp_dev[32];
+	char disp_dev[NAME_LEN];
 	struct mxc_dispdrv_handle *dispdrv;
 	int id;
 	struct fb_var_screeninfo var;
 	struct pm_qos_request pm_qos_req;
 
+	char disp_videomode[NAME_LEN];
+
 #ifdef CONFIG_FB_MXC_OVERLAY
 	struct mxsfb_layer overlay;
 #endif
@@ -1276,7 +1280,7 @@ static int mxsfb_init_fbinfo_dt(struct fb_info *fb_info)
 	struct device_node *display_np;
 	struct device_node *timings_np;
 	struct display_timings *timings = NULL;
-	const char *disp_dev;
+	const char *disp_dev, *disp_videomode;
 	u32 width;
 	int i;
 	int ret = 0;
@@ -1324,6 +1328,13 @@ static int mxsfb_init_fbinfo_dt(struct fb_info *fb_info)
 	ret = of_property_read_string(np, "disp-dev", &disp_dev);
 	if (!ret) {
 		memcpy(host->disp_dev, disp_dev, strlen(disp_dev));
+
+		if (!of_property_read_string(np, "disp-videomode",
+					    &disp_videomode)) {
+			memcpy(host->disp_videomode, disp_videomode,
+			       strlen(disp_videomode));
+		}
+
 		/* Timing is from encoder driver */
 		goto put_display_node;
 	}
@@ -1438,7 +1449,20 @@ static int mxsfb_dispdrv_init(struct platform_device *pdev,
 	memcpy(disp_dev, host->disp_dev, strlen(host->disp_dev));
 	disp_dev[strlen(host->disp_dev)] = '\0';
 
+	/* Use videomode name from dtb, if any given */
+	if (host->disp_videomode) {
+		setting.dft_mode_str = kmalloc(NAME_LEN, GFP_KERNEL);
+		if (setting.dft_mode_str) {
+			memset(setting.dft_mode_str, 0x0, NAME_LEN);
+			memcpy(setting.dft_mode_str, host->disp_videomode,
+			       strlen(host->disp_videomode));
+		}
+	}
+
 	host->dispdrv = mxc_dispdrv_gethandle(disp_dev, &setting);
+
+	kfree(setting.dft_mode_str);
+
 	if (IS_ERR(host->dispdrv)) {
 		if (PTR_ERR(host->dispdrv) == -EPROBE_DEFER)
 			return PTR_ERR(host->dispdrv);
-- 
1.7.9.5


From b1559130576e35c9d35024c1e74f4c3b798e1612 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Tue, 19 Sep 2017 12:09:01 +0800
Subject: [PATCH 2549/5242] MLK-16485 PCI: imx6: Defer probing if
 .of_get_named_gpio() returns -EPROBE_DEFER

commit  db40e0aac6dba8e26d7f712df826e93b553becc5 from
https://source.codeaurora.org/external/imx/linux-imx.git

Driver should do defer probing if .of_get_named_gpio() returns -EPROBE_DEFER.
And moving epdev_on regulator to be common for all platforms.

(BuildInfo: SCFW 3e70523d, IMX-MKIMAGE 0, ATF 0)

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Reviewed-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/controller/dwc/pci-imx6.c |   27 ++++++++++++++++++---------
 1 file changed, 18 insertions(+), 9 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index 31924c6..1df10b3 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -1821,6 +1821,8 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev, "unable to get clkreq gpio\n");
 			return ret;
 		}
+	} else if (imx6_pcie->clkreq_gpio == -EPROBE_DEFER) {
+		return imx6_pcie->clkreq_gpio;
 	}
 
 	imx6_pcie->dis_gpio = of_get_named_gpio(node, "disable-gpio", 0);
@@ -1831,6 +1833,8 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev, "unable to get disable gpio\n");
 			return ret;
 		}
+	} else if (imx6_pcie->dis_gpio == -EPROBE_DEFER) {
+		return imx6_pcie->dis_gpio;
 	}
 
 	imx6_pcie->power_on_gpio = of_get_named_gpio(node, "power-on-gpio", 0);
@@ -1843,6 +1847,8 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev, "unable to get power-on gpio\n");
 			return ret;
 		}
+	} else if (imx6_pcie->power_on_gpio == -EPROBE_DEFER) {
+		return imx6_pcie->power_on_gpio;
 	}
 
 	imx6_pcie->reset_gpio = of_get_named_gpio(node, "reset-gpio", 0);
@@ -1862,6 +1868,18 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 		return imx6_pcie->reset_gpio;
 	}
 
+	imx6_pcie->epdev_on = devm_regulator_get(&pdev->dev, "epdev_on");
+	if (IS_ERR(imx6_pcie->epdev_on)) {
+		if (PTR_ERR(imx6_pcie->epdev_on) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(dev, "no ep regulator found\n");
+		imx6_pcie->epdev_on = NULL;
+	} else {
+		ret = regulator_enable(imx6_pcie->epdev_on);
+		if (ret)
+			dev_err(dev, "failed to enable the epdev_on regulator\n");
+	}
+
 	/* Fetch clocks */
 	imx6_pcie->pcie_phy = devm_clk_get(dev, "pcie_phy");
 	if (IS_ERR(imx6_pcie->pcie_phy)) {
@@ -1970,15 +1988,6 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 				"pcie clock source missing or invalid\n");
 			return PTR_ERR(imx6_pcie->pcie_inbound_axi);
 		}
-
-		imx6_pcie->epdev_on = devm_regulator_get(&pdev->dev,
-							 "epdev_on");
-		if (IS_ERR(imx6_pcie->epdev_on))
-			return -EPROBE_DEFER;
-
-		ret = regulator_enable(imx6_pcie->epdev_on);
-		if (ret)
-			dev_err(dev, "failed to enable the epdev_on regulator\n");
 	} else {
 		imx6_pcie->iomuxc_gpr =
 		 syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
-- 
1.7.9.5


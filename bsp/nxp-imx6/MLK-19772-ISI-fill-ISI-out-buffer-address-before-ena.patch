From fc428b28d4a25796775c18a9031b5a94ea9077ed Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Sat, 29 Sep 2018 11:54:03 +0800
Subject: [PATCH 4775/5242] MLK-19772: ISI: fill ISI out buffer address before
 enabling ISI channel

commit  b7551b4b5e58d4f5b8480f611252792c495c31ec from
https://source.codeaurora.org/external/imx/linux-imx.git

1. Before enabling ISI channel, driver need to fill its out buffer
address, so correct this sequence

2. Because ISI use ping-pong buffer and write data to memory with
BUF1->BUF2->BUF1... sequence. If it finish with BUF1 and user start
a new capture process, it will start with BUF2. This will lead the
buffer ready for being read is not equal to buffer written by ISI.So
HW reset ISI, in order to confirm it start with BUF1.

Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
(cherry picked from commit 794ce0cb7d7f129fb46f5d6f38e82cc1e7f2a367)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/mxc-isi-cap.c |    4 +--
 drivers/media/platform/imx8/mxc-isi-hw.c  |   42 +++++++++++++++++++++++------
 2 files changed, 36 insertions(+), 10 deletions(-)

diff --git a/drivers/media/platform/imx8/mxc-isi-cap.c b/drivers/media/platform/imx8/mxc-isi-cap.c
index 7c5f7d4..4498793 100644
--- a/drivers/media/platform/imx8/mxc-isi-cap.c
+++ b/drivers/media/platform/imx8/mxc-isi-cap.c
@@ -957,8 +957,8 @@ static int mxc_isi_cap_streamon(struct file *file, void *priv,
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	mxc_isi_channel_enable(mxc_isi);
 	ret = vb2_ioctl_streamon(file, priv, type);
+	mxc_isi_channel_enable(mxc_isi);
 	mxc_isi_pipeline_enable(mxc_isi, 1);
 
 	return ret;
@@ -972,9 +972,9 @@ static int mxc_isi_cap_streamoff(struct file *file, void *priv,
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
+	mxc_isi_pipeline_enable(mxc_isi, 0);
 	mxc_isi_channel_disable(mxc_isi);
 	ret = vb2_ioctl_streamoff(file, priv, type);
-	mxc_isi_pipeline_enable(mxc_isi, 0);
 
 	return ret;
 }
diff --git a/drivers/media/platform/imx8/mxc-isi-hw.c b/drivers/media/platform/imx8/mxc-isi-hw.c
index 98e8421..f773141 100644
--- a/drivers/media/platform/imx8/mxc-isi-hw.c
+++ b/drivers/media/platform/imx8/mxc-isi-hw.c
@@ -190,7 +190,9 @@ void mxc_isi_channel_hw_reset(struct mxc_isi_dev *mxc_isi)
 {
 	sc_ipc_t ipcHndl;
 	sc_err_t sciErr;
-	uint32_t mu_id;
+	uint32_t mu_id, ch_id, i;
+	uint8_t chan_mask = 0, temp_mask;
+	struct device_node *parent, *node;
 
 	sciErr = sc_ipc_getMuID(&mu_id);
 	if (sciErr != SC_ERR_NONE) {
@@ -204,16 +206,40 @@ void mxc_isi_channel_hw_reset(struct mxc_isi_dev *mxc_isi)
 		return;
 	}
 
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_ISI_CH0, SC_PM_PW_MODE_OFF);
-	if (sciErr != SC_ERR_NONE)
-		pr_err("sc_misc_MIPI reset failed! (sciError = %d)\n", sciErr);
+	parent = of_get_parent(mxc_isi->pdev->dev.of_node);
+	if (!parent) {
+		dev_err(&mxc_isi->pdev->dev, "get parent device fail\n");
+		return;
+	}
 
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_ISI_CH0, SC_PM_PW_MODE_ON);
-	if (sciErr != SC_ERR_NONE)
-		pr_err("sc_misc_MIPI reset failed! (sciError = %d)\n", sciErr);
+	for_each_available_child_of_node(parent, node) {
+		if (!strcmp(node->name, ISI_OF_NODE_NAME)) {
+			ch_id = of_alias_get_id(node, "isi");
+			chan_mask |= 1 << ch_id;
+		}
+	}
 
-	udelay(500);
+	temp_mask = chan_mask;
+	for (i = 0; i < 8; i++) {
+		if (chan_mask & 0x1) {
+			sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_ISI_CH0 + i, SC_PM_PW_MODE_OFF);
+			if (sciErr != SC_ERR_NONE)
+				pr_err("power on ISI%d failed! (sciError = %d)\n", i, sciErr);
+		}
+		chan_mask >>= 1;
+	}
 
+	chan_mask = temp_mask;
+	for (i = 0; i < 8; i++) {
+		if (chan_mask & 0x1) {
+			sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_ISI_CH0 + i, SC_PM_PW_MODE_ON);
+			if (sciErr != SC_ERR_NONE)
+				pr_err("power off ISI%d failed! (sciError = %d)\n", i, sciErr);
+		}
+		chan_mask >>= 1;
+	}
+
+	udelay(500);
 	sc_ipc_close(mu_id);
 }
 
-- 
1.7.9.5


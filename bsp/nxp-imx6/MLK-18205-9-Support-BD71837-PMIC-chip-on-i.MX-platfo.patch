From 1411fbcb43730329b954d4163a8d9d6363284f4f Mon Sep 17 00:00:00 2001
From: "Haoran.Wang" <elven.wang@nxp.com>
Date: Mon, 5 Feb 2018 16:26:29 +0800
Subject: [PATCH 3728/5242] MLK-18205-9 Support BD71837 PMIC chip on i.MX
 platforms

commit  61200c69256f46f3129b264e830df562440152e2 from
https://source.codeaurora.org/external/imx/linux-imx.git

Signed-off-by: Haoran.Wang <elven.wang@nxp.com>
Signed-off-by: Robin Gong <yibin.gong@nxp.com>
Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
(cherry picked from commit 37f67d291e74a3428310cb5c98f556411042f810)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mfd/Kconfig                    |    8 +
 drivers/mfd/Makefile                   |    1 +
 drivers/mfd/bd71837.c                  |  308 +++++++++++
 drivers/regulator/bd71837-regulator.c  |  925 +++++++++++++++++++++++---------
 drivers/regulator/userspace-consumer.c |   53 ++
 drivers/regulator/virtual.c            |   38 ++
 include/linux/mfd/bd71837.h            |  413 ++++++++++++++
 7 files changed, 1501 insertions(+), 245 deletions(-)
 create mode 100644 drivers/mfd/bd71837.c
 create mode 100644 include/linux/mfd/bd71837.h

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 36cb500..81521d7 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1841,6 +1841,14 @@ config MFD_STM32_TIMERS
 	  for PWM and IIO Timer. This driver allow to share the
 	  registers between the others drivers.
 
+config MFD_BD71837
+	bool "BD71837 Power Management chip"
+	depends on I2C=y
+	select MFD_CORE
+	help
+	  if you say yes here you get support for the BD71837
+	  Power Management chips.
+
 menu "Multimedia Capabilities Port drivers"
 	depends on ARCH_SA1100
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index a9d0096..bdad98f 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -231,4 +231,5 @@ obj-$(CONFIG_MFD_STM32_TIMERS) 	+= stm32-timers.o
 obj-$(CONFIG_MFD_MXS_LRADC)     += mxs-lradc.o
 obj-$(CONFIG_MFD_SC27XX_PMIC)	+= sprd-sc27xx-spi.o
 obj-$(CONFIG_RAVE_SP_CORE)	+= rave-sp.o
+obj-$(CONFIG_MFD_BD71837)       += bd71837.o
 
diff --git a/drivers/mfd/bd71837.c b/drivers/mfd/bd71837.c
new file mode 100644
index 0000000..1f24d07
--- /dev/null
+++ b/drivers/mfd/bd71837.c
@@ -0,0 +1,308 @@
+/*
+ * @file bd71837.c  --  ROHM BD71837MWV mfd driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ * @author: cpham2403@gmail.com
+ * Copyright 2017.
+ */
+#define DEBUG
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/bd71837.h>
+
+/* Default enable debug message All Level */
+unsigned int bd71837_debug_mask = BD71837_DBG0;
+
+/** @brief bd71837 irq resource */
+static struct resource pmic_resources[] = {
+	// irq# 0
+	{
+		.start	= BD71837_IRQ,
+		.end	= BD71837_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/** @brief bd71837 multi function cells */
+static struct mfd_cell bd71837_mfd_cells[] = {
+	{
+		.name = "bd71837-pmic",
+		.num_resources = ARRAY_SIZE(pmic_resources),
+		.resources = &pmic_resources[0],
+	},
+};
+
+/** @brief bd71837 irqs */
+static const struct regmap_irq bd71837_irqs[] = {
+	[BD71837_IRQ] = {
+		.mask = BD71837_INT_MASK,
+		.reg_offset = 0,
+	},
+};
+
+/** @brief bd71837 irq chip definition */
+static struct regmap_irq_chip bd71837_irq_chip = {
+	.name = "bd71837",
+	.irqs = bd71837_irqs,
+	.num_irqs = ARRAY_SIZE(bd71837_irqs),
+	.num_regs = 1,
+	.irq_reg_stride = 1,
+	.status_base = BD71837_REG_IRQ,
+	.mask_base = BD71837_REG_MIRQ,
+	.mask_invert = true,
+	// .ack_base = BD71837_REG_IRQ,
+};
+
+/** @brief bd71837 irq initialize
+ *  @param bd71837 bd71837 device to init
+ *  @param bdinfo platform init data
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd71837_irq_init(struct bd71837 *bd71837, struct bd71837_board *bdinfo)
+{
+	int irq;
+	int ret = 0;
+
+	if (!bdinfo) {
+		dev_warn(bd71837->dev, "No interrupt support, no pdata\n");
+		return -EINVAL;
+	}
+
+	dev_info(bd71837->dev, "gpio_intr = %d \n", bdinfo->gpio_intr);
+	irq = gpio_to_irq(bdinfo->gpio_intr);
+
+	bd71837->chip_irq = irq;
+	dev_info(bd71837->dev, "chip_irq=%d \n", bd71837->chip_irq);
+	ret = regmap_add_irq_chip(bd71837->regmap, bd71837->chip_irq,
+		IRQF_ONESHOT | IRQF_TRIGGER_FALLING, bdinfo->irq_base,
+		&bd71837_irq_chip, &bd71837->irq_data);
+	if (ret < 0) {
+		dev_warn(bd71837->dev, "Failed to add irq_chip %d\n", ret);
+	}
+	return ret;
+}
+
+/** @brief bd71837 irq initialize
+ *  @param bd71837 bd71837 device to init
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd71837_irq_exit(struct bd71837 *bd71837)
+{
+	if (bd71837->chip_irq > 0)
+		regmap_del_irq_chip(bd71837->chip_irq, bd71837->irq_data);
+	return 0;
+}
+
+/** @brief check whether volatile register
+ *  @param dev kernel device pointer
+ *  @param reg register index
+ */
+static bool is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	// struct bd71837 *bd71837 = dev_get_drvdata(dev);
+
+	/*
+	 * Caching all regulator registers.
+	 */
+	return true;
+}
+
+/** @brief regmap configures */
+static const struct regmap_config bd71837_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_reg = is_volatile_reg,
+	.max_register = BD71837_MAX_REGISTER - 1,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id bd71837_of_match[] = {
+	{ .compatible = "rohm,bd71837", .data = (void *)0},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bd71837_of_match);
+
+
+/** @brief parse device tree data of bd71837
+ *  @param client client object provided by system
+ *  @param chip_id return chip id back to caller
+ *  @return board initialize data
+ */
+static struct bd71837_board *bd71837_parse_dt(struct i2c_client *client,
+						int *chip_id)
+{
+	struct device_node *np = client->dev.of_node;
+	struct bd71837_board *board_info;
+	unsigned int prop;
+	const struct of_device_id *match;
+	int r = 0;
+
+	match = of_match_device(bd71837_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	chip_id  = (int *)match->data;
+
+	board_info = devm_kzalloc(&client->dev, sizeof(*board_info),
+			GFP_KERNEL);
+	if (!board_info) {
+		dev_err(&client->dev, "Failed to allocate pdata\n");
+		return NULL;
+	}
+
+	board_info->gpio_intr = of_get_named_gpio(np, "gpio_intr", 0);
+	if (!gpio_is_valid(board_info->gpio_intr)) {
+		dev_err(&client->dev, "no pmic intr pin available\n");
+		goto err_intr;
+	}
+
+	r = of_property_read_u32(np, "irq_base", &prop);
+	if (!r) {
+		board_info->irq_base = prop;
+	} else {
+		board_info->irq_base = -1;
+	}
+
+	return board_info;
+
+err_intr:
+	devm_kfree(&client->dev, board_info);
+	return NULL;
+}
+#endif
+
+/** @brief probe bd71837 device
+ *  @param i2c client object provided by system
+ *  @param id chip id
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd71837_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct bd71837 *bd71837;
+	struct bd71837_board *pmic_plat_data;
+	struct bd71837_board *of_pmic_plat_data = NULL;
+	int chip_id = id->driver_data;
+	int ret = 0;
+
+	pmic_plat_data = dev_get_platdata(&i2c->dev);
+
+	if (!pmic_plat_data && i2c->dev.of_node) {
+		pmic_plat_data = bd71837_parse_dt(i2c, &chip_id);
+		of_pmic_plat_data = pmic_plat_data;
+	}
+
+	if (!pmic_plat_data)
+		return -EINVAL;
+
+	bd71837 = kzalloc(sizeof(struct bd71837), GFP_KERNEL);
+	if (bd71837 == NULL)
+		return -ENOMEM;
+
+	bd71837->of_plat_data = of_pmic_plat_data;
+	i2c_set_clientdata(i2c, bd71837);
+	bd71837->dev = &i2c->dev;
+	bd71837->i2c_client = i2c;
+	bd71837->id = chip_id;
+	mutex_init(&bd71837->io_mutex);
+
+	bd71837->regmap = devm_regmap_init_i2c(i2c, &bd71837_regmap_config);
+	if (IS_ERR(bd71837->regmap)) {
+		ret = PTR_ERR(bd71837->regmap);
+		dev_err(&i2c->dev, "regmap initialization failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = bd71837_reg_read(bd71837, BD71837_REG_REV);
+	if (ret < 0) {
+		dev_err(bd71837->dev, "%s(): Read BD71837_REG_DEVICE failed!\n", __func__);
+		goto err;
+	}
+	dev_info(bd71837->dev, "Device ID=0x%X\n", ret);
+
+	bd71837_irq_init(bd71837, of_pmic_plat_data);
+
+	ret = mfd_add_devices(bd71837->dev, -1,
+			      bd71837_mfd_cells, ARRAY_SIZE(bd71837_mfd_cells),
+			      NULL, 0,
+			      regmap_irq_get_domain(bd71837->irq_data));
+	if (ret < 0)
+		goto err;
+
+	return ret;
+
+err:
+	mfd_remove_devices(bd71837->dev);
+	kfree(bd71837);
+	return ret;
+}
+
+/** @brief remove bd71837 device
+ *  @param i2c client object provided by system
+ *  @return 0
+ */
+static int bd71837_i2c_remove(struct i2c_client *i2c)
+{
+	struct bd71837 *bd71837 = i2c_get_clientdata(i2c);
+
+	bd71837_irq_exit(bd71837);
+	mfd_remove_devices(bd71837->dev);
+	kfree(bd71837);
+
+	return 0;
+}
+
+static const struct i2c_device_id bd71837_i2c_id[] = {
+	{ "bd71837", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bd71837_i2c_id);
+
+static struct i2c_driver bd71837_i2c_driver = {
+	.driver = {
+		.name = "bd71837",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(bd71837_of_match),
+	},
+	.probe = bd71837_i2c_probe,
+	.remove = bd71837_i2c_remove,
+	.id_table = bd71837_i2c_id,
+};
+
+static int __init bd71837_i2c_init(void)
+{
+	return i2c_add_driver(&bd71837_i2c_driver);
+}
+/* init early so consumer devices can complete system boot */
+subsys_initcall(bd71837_i2c_init);
+
+static void __exit bd71837_i2c_exit(void)
+{
+	i2c_del_driver(&bd71837_i2c_driver);
+}
+module_exit(bd71837_i2c_exit);
+
+MODULE_AUTHOR("Cong Pham <cpham2403@gmail.com>");
+MODULE_DESCRIPTION("BD71837 chip multi-function driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/bd71837-regulator.c b/drivers/regulator/bd71837-regulator.c
index 6eae4d04..4b04fb1 100644
--- a/drivers/regulator/bd71837-regulator.c
+++ b/drivers/regulator/bd71837-regulator.c
@@ -1,7 +1,17 @@
-// SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2018 ROHM Semiconductors
-// bd71837-regulator.c ROHM BD71837MWV regulator driver
-
+/*
+ * @file bd71837-regulator.c ROHM BD71837MWV regulator driver
+ *
+ * @author: cpham2403@gmail.com
+ * Copyright 2017.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ */
+#define DEBUG
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -16,11 +26,23 @@
 #include <linux/mfd/bd71837.h>
 #include <linux/regulator/of_regulator.h>
 
+#define BD71837_DVS_BUCK_NUM		4	/* Buck 1/2/3/4 support DVS */
+#define BD71837_DVS_RUN_IDLE_SUSP	3
+#define BD71837_DVS_RUN_IDLE		2
+#define BD71837_DVS_RUN				1
+
+struct bd71837_buck_dvs {
+	u32 voltage[BD71837_DVS_RUN_IDLE_SUSP];
+};
+
+/** @brief bd71837 regulator type */
 struct bd71837_pmic {
-	struct regulator_desc descs[BD71837_REGULATOR_CNT];
-	struct bd71837 *mfd;
-	struct platform_device *pdev;
-	struct regulator_dev *rdev[BD71837_REGULATOR_CNT];
+	struct regulator_desc descs[BD71837_REGULATOR_CNT];	/**< regulator description to system */
+	struct bd71837 *mfd;									/**< parent device */
+	struct device *dev;										/**< regulator kernel device */
+	struct regulator_dev *rdev[BD71837_REGULATOR_CNT];		/**< regulator device of system */
+	struct bd71837_buck_dvs buck_dvs[BD71837_DVS_BUCK_NUM];			/**< buck1/2 dvs */
+	int	reg_index;
 };
 
 /*
@@ -31,56 +53,35 @@ struct bd71837_pmic {
  * 10: 2.50mV/usec	10mV 4uS
  * 11: 1.25mV/usec	10mV 8uS
  */
-static int bd71837_buck1234_set_ramp_delay(struct regulator_dev *rdev,
-					   int ramp_delay)
+static int bd71837_buck1234_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
 {
 	struct bd71837_pmic *pmic = rdev_get_drvdata(rdev);
 	struct bd71837 *mfd = pmic->mfd;
 	int id = rdev->desc->id;
-	unsigned int ramp_value = BUCK_RAMPRATE_10P00MV;
+	unsigned int ramp_value = BUCK1_RAMPRATE_10P00MV;
 
-	dev_dbg(&(pmic->pdev->dev), "Buck[%d] Set Ramp = %d\n", id + 1,
-		ramp_delay);
+	dev_dbg(pmic->dev, "Buck[%d] Set Ramp = %d\n", id + 1, ramp_delay);
 	switch (ramp_delay) {
 	case 1 ... 1250:
-		ramp_value = BUCK_RAMPRATE_1P25MV;
+		ramp_value = BUCK1_RAMPRATE_1P25MV;
 		break;
 	case 1251 ... 2500:
-		ramp_value = BUCK_RAMPRATE_2P50MV;
+		ramp_value = BUCK1_RAMPRATE_2P50MV;
 		break;
 	case 2501 ... 5000:
-		ramp_value = BUCK_RAMPRATE_5P00MV;
+		ramp_value = BUCK1_RAMPRATE_5P00MV;
 		break;
 	case 5001 ... 10000:
-		ramp_value = BUCK_RAMPRATE_10P00MV;
+		ramp_value = BUCK1_RAMPRATE_10P00MV;
 		break;
 	default:
-		ramp_value = BUCK_RAMPRATE_10P00MV;
-		dev_err(&pmic->pdev->dev,
-			"%s: ramp_delay: %d not supported, setting 10000mV//us\n",
+		ramp_value = BUCK1_RAMPRATE_10P00MV;
+		dev_err(pmic->dev, "%s: ramp_delay: %d not supported, setting 10000mV//us\n",
 			rdev->desc->name, ramp_delay);
 	}
 
 	return regmap_update_bits(mfd->regmap, BD71837_REG_BUCK1_CTRL + id,
-				  BUCK_RAMPRATE_MASK, ramp_value << 6);
-}
-
-/* Bucks 1 to 4 support DVS. PWM mode is used when voltage is changed.
- * Bucks 5 to 8 and LDOs can use PFM and must be disabled when voltage
- * is changed. Hence we return -EBUSY for these if voltage is changed
- * when BUCK/LDO is enabled.
- */
-static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
-						    unsigned int sel)
-{
-	int ret;
-
-	ret = regulator_is_enabled_regmap(rdev);
-	if (!ret)
-		ret = regulator_set_voltage_sel_regmap(rdev, sel);
-	else if (ret == 1)
-		ret = -EBUSY;
-	return ret;
+			BUCK1_RAMPRATE_MASK, ramp_value << 6);
 }
 
 static struct regulator_ops bd71837_ldo_regulator_ops = {
@@ -88,17 +89,15 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 	.disable = regulator_disable_regmap,
 	.is_enabled = regulator_is_enabled_regmap,
 	.list_voltage = regulator_list_voltage_linear_range,
-	.set_voltage_sel = bd71837_set_voltage_sel_restricted,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
 	.get_voltage_sel = regulator_get_voltage_sel_regmap,
 };
 
-static struct regulator_ops bd71837_ldo_regulator_nolinear_ops = {
+static struct regulator_ops bd71837_fixed_regulator_ops = {
 	.enable = regulator_enable_regmap,
 	.disable = regulator_disable_regmap,
 	.is_enabled = regulator_is_enabled_regmap,
-	.list_voltage = regulator_list_voltage_table,
-	.set_voltage_sel = bd71837_set_voltage_sel_restricted,
-	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.list_voltage = regulator_list_voltage_linear,
 };
 
 static struct regulator_ops bd71837_buck_regulator_ops = {
@@ -106,17 +105,7 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 	.disable = regulator_disable_regmap,
 	.is_enabled = regulator_is_enabled_regmap,
 	.list_voltage = regulator_list_voltage_linear_range,
-	.set_voltage_sel = bd71837_set_voltage_sel_restricted,
-	.get_voltage_sel = regulator_get_voltage_sel_regmap,
-	.set_voltage_time_sel = regulator_set_voltage_time_sel,
-};
-
-static struct regulator_ops bd71837_buck_regulator_nolinear_ops = {
-	.enable = regulator_enable_regmap,
-	.disable = regulator_disable_regmap,
-	.is_enabled = regulator_is_enabled_regmap,
-	.list_voltage = regulator_list_voltage_table,
-	.set_voltage_sel = bd71837_set_voltage_sel_restricted,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
 	.get_voltage_sel = regulator_get_voltage_sel_regmap,
 	.set_voltage_time_sel = regulator_set_voltage_time_sel,
 };
@@ -137,8 +126,8 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
  * 0.70 to 1.30V (10mV step)
  */
 static const struct regulator_linear_range bd71837_buck1234_voltage_ranges[] = {
-	REGULATOR_LINEAR_RANGE(700000, 0x00, 0x3C, 10000),
-	REGULATOR_LINEAR_RANGE(1300000, 0x3D, 0x3F, 0),
+	REGULATOR_LINEAR_RANGE(700000,  0x00, 0x3C, 10000),
+	REGULATOR_LINEAR_RANGE(1300000,  0x3D, 0x3F, 0),
 };
 
 /*
@@ -161,6 +150,7 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 
 /*
  * BUCK7
+ * 1.605V to 1.995V ()
  * 000 = 1.605V
  * 001 = 1.695V
  * 010 = 1.755V
@@ -170,8 +160,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
  * 110 = 1.95V
  * 111 = 1.995V
  */
-static const unsigned int buck_7_volts[] = {
-	1605000, 1695000, 1755000, 1800000, 1845000, 1905000, 1950000, 1995000
+static const struct regulator_linear_range bd71837_buck7_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1605000, 0x00, 0x01, 90000),
+	REGULATOR_LINEAR_RANGE(1755000, 0x02, 0x03, 45000),
+	REGULATOR_LINEAR_RANGE(1845000, 0x04, 0x05, 60000),
+	REGULATOR_LINEAR_RANGE(1950000, 0x06, 0x07, 45000),
 };
 
 /*
@@ -179,8 +172,8 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
  * 0.8V to 1.40V (step 10mV)
  */
 static const struct regulator_linear_range bd71837_buck8_voltage_ranges[] = {
-	REGULATOR_LINEAR_RANGE(800000, 0x00, 0x3C, 10000),
-	REGULATOR_LINEAR_RANGE(1400000, 0x3D, 0x3F, 0),
+	REGULATOR_LINEAR_RANGE(800000,  0x00, 0x3C, 10000),
+	REGULATOR_LINEAR_RANGE(1400000,  0x3D, 0x3F, 0),
 };
 
 /*
@@ -192,14 +185,6 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 };
 
 /*
- * LDO2
- * 0.8 or 0.9V
- */
-const unsigned int ldo_2_volts[] = {
-	900000, 800000
-};
-
-/*
  * LDO3
  * 1.8 to 3.3V (100mV step)
  */
@@ -221,7 +206,7 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
  * 1.8 to 3.3V (100mV step)
  */
 static const struct regulator_linear_range bd71837_ldo5_voltage_ranges[] = {
-	REGULATOR_LINEAR_RANGE(1800000, 0x00, 0x0F, 100000),
+	REGULATOR_LINEAR_RANGE(1800000,  0x00, 0x0F, 100000),
 };
 
 /*
@@ -229,7 +214,7 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
  * 0.9 to 1.8V (100mV step)
  */
 static const struct regulator_linear_range bd71837_ldo6_voltage_ranges[] = {
-	REGULATOR_LINEAR_RANGE(900000, 0x00, 0x09, 100000),
+	REGULATOR_LINEAR_RANGE(900000,  0x00, 0x09, 100000),
 	REGULATOR_LINEAR_RANGE(1800000, 0x0A, 0x0F, 0),
 };
 
@@ -243,9 +228,7 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 
 static const struct regulator_desc bd71837_regulators[] = {
 	{
-		.name = "buck1",
-		.of_match = of_match_ptr("BUCK1"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK1",
 		.id = BD71837_BUCK1,
 		.ops = &bd71837_buck1234_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -255,13 +238,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK1_VOLT_RUN,
 		.vsel_mask = BUCK1_RUN_MASK,
 		.enable_reg = BD71837_REG_BUCK1_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK1_SEL|BUCK1_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck2",
-		.of_match = of_match_ptr("BUCK2"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK2",
 		.id = BD71837_BUCK2,
 		.ops = &bd71837_buck1234_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -271,13 +252,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK2_VOLT_RUN,
 		.vsel_mask = BUCK2_RUN_MASK,
 		.enable_reg = BD71837_REG_BUCK2_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK2_SEL|BUCK2_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck3",
-		.of_match = of_match_ptr("BUCK3"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK3",
 		.id = BD71837_BUCK3,
 		.ops = &bd71837_buck1234_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -287,14 +266,12 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK3_VOLT_RUN,
 		.vsel_mask = BUCK3_RUN_MASK,
 		.enable_reg = BD71837_REG_BUCK3_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK3_SEL|BUCK3_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck4",
-		.of_match = of_match_ptr("BUCK4"),
-		.regulators_node = of_match_ptr("regulators"),
-			.id = BD71837_BUCK4,
+		.name = "BUCK4",
+		.id = BD71837_BUCK4,
 		.ops = &bd71837_buck1234_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
 		.n_voltages = BD71837_BUCK4_VOLTAGE_NUM,
@@ -303,13 +280,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK4_VOLT_RUN,
 		.vsel_mask = BUCK4_RUN_MASK,
 		.enable_reg = BD71837_REG_BUCK4_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK4_SEL|BUCK4_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck5",
-		.of_match = of_match_ptr("BUCK5"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK5",
 		.id = BD71837_BUCK5,
 		.ops = &bd71837_buck_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -319,13 +294,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK5_VOLT,
 		.vsel_mask = BUCK5_MASK,
 		.enable_reg = BD71837_REG_BUCK5_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK5_SEL|BUCK5_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck6",
-		.of_match = of_match_ptr("BUCK6"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK6",
 		.id = BD71837_BUCK6,
 		.ops = &bd71837_buck_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -335,28 +308,25 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK6_VOLT,
 		.vsel_mask = BUCK6_MASK,
 		.enable_reg = BD71837_REG_BUCK6_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK6_SEL|BUCK6_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck7",
-		.of_match = of_match_ptr("BUCK7"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK7",
 		.id = BD71837_BUCK7,
-		.ops = &bd71837_buck_regulator_nolinear_ops,
+		.ops = &bd71837_buck_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
-		.volt_table = &buck_7_volts[0],
-		.n_voltages = ARRAY_SIZE(buck_7_volts),
+		.n_voltages = BD71837_BUCK7_VOLTAGE_NUM,
+		.linear_ranges = bd71837_buck7_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(bd71837_buck7_voltage_ranges),
 		.vsel_reg = BD71837_REG_BUCK7_VOLT,
 		.vsel_mask = BUCK7_MASK,
 		.enable_reg = BD71837_REG_BUCK7_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK7_SEL|BUCK7_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "buck8",
-		.of_match = of_match_ptr("BUCK8"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "BUCK8",
 		.id = BD71837_BUCK8,
 		.ops = &bd71837_buck_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -366,13 +336,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_BUCK8_VOLT,
 		.vsel_mask = BUCK8_MASK,
 		.enable_reg = BD71837_REG_BUCK8_CTRL,
-		.enable_mask = BD71837_BUCK_EN,
+		.enable_mask = BUCK8_SEL|BUCK8_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "ldo1",
-		.of_match = of_match_ptr("LDO1"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO1",
 		.id = BD71837_LDO1,
 		.ops = &bd71837_ldo_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -382,29 +350,26 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_LDO1_VOLT,
 		.vsel_mask = LDO1_MASK,
 		.enable_reg = BD71837_REG_LDO1_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO1_SEL|LDO1_EN,
 		.owner = THIS_MODULE,
 	},
+	/*
+	 * LDO2 0.9V
+	 * Fixed voltage
+	 */
 	{
-		.name = "ldo2",
-		.of_match = of_match_ptr("LDO2"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO2",
 		.id = BD71837_LDO2,
-		.ops = &bd71837_ldo_regulator_nolinear_ops,
+		.ops = &bd71837_fixed_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
-		.volt_table = &ldo_2_volts[0],
-		.vsel_reg = BD71837_REG_LDO2_VOLT,
-		.vsel_mask = LDO2_MASK,
-		.n_voltages = ARRAY_SIZE(ldo_2_volts),
 		.n_voltages = BD71837_LDO2_VOLTAGE_NUM,
+		.min_uV = 900000,
 		.enable_reg = BD71837_REG_LDO2_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO2_SEL|LDO2_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "ldo3",
-		.of_match = of_match_ptr("LDO3"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO3",
 		.id = BD71837_LDO3,
 		.ops = &bd71837_ldo_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -414,13 +379,11 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_LDO3_VOLT,
 		.vsel_mask = LDO3_MASK,
 		.enable_reg = BD71837_REG_LDO3_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO3_SEL|LDO3_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "ldo4",
-		.of_match = of_match_ptr("LDO4"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO4",
 		.id = BD71837_LDO4,
 		.ops = &bd71837_ldo_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -430,49 +393,39 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_LDO4_VOLT,
 		.vsel_mask = LDO4_MASK,
 		.enable_reg = BD71837_REG_LDO4_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO4_SEL|LDO4_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "ldo5",
-		.of_match = of_match_ptr("LDO5"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO5",
 		.id = BD71837_LDO5,
 		.ops = &bd71837_ldo_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
 		.n_voltages = BD71837_LDO5_VOLTAGE_NUM,
 		.linear_ranges = bd71837_ldo5_voltage_ranges,
 		.n_linear_ranges = ARRAY_SIZE(bd71837_ldo5_voltage_ranges),
-		/* LDO5 is supplied by buck6 */
-		.supply_name = "buck6",
 		.vsel_reg = BD71837_REG_LDO5_VOLT,
 		.vsel_mask = LDO5_MASK,
 		.enable_reg = BD71837_REG_LDO5_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO5_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "ldo6",
-		.of_match = of_match_ptr("LDO6"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO6",
 		.id = BD71837_LDO6,
 		.ops = &bd71837_ldo_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
 		.n_voltages = BD71837_LDO6_VOLTAGE_NUM,
 		.linear_ranges = bd71837_ldo6_voltage_ranges,
 		.n_linear_ranges = ARRAY_SIZE(bd71837_ldo6_voltage_ranges),
-		/* LDO6 is supplied by buck7 */
-		.supply_name = "buck7",
 		.vsel_reg = BD71837_REG_LDO6_VOLT,
 		.vsel_mask = LDO6_MASK,
 		.enable_reg = BD71837_REG_LDO6_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO6_EN,
 		.owner = THIS_MODULE,
 	},
 	{
-		.name = "ldo7",
-		.of_match = of_match_ptr("LDO7"),
-		.regulators_node = of_match_ptr("regulators"),
+		.name = "LDO7",
 		.id = BD71837_LDO7,
 		.ops = &bd71837_ldo_regulator_ops,
 		.type = REGULATOR_VOLTAGE,
@@ -482,159 +435,641 @@ static int bd71837_set_voltage_sel_restricted(struct regulator_dev *rdev,
 		.vsel_reg = BD71837_REG_LDO7_VOLT,
 		.vsel_mask = LDO7_MASK,
 		.enable_reg = BD71837_REG_LDO7_VOLT,
-		.enable_mask = BD71837_LDO_EN,
+		.enable_mask = LDO7_EN,
 		.owner = THIS_MODULE,
 	},
 };
 
-struct reg_init {
+#ifdef CONFIG_OF
+
+static struct of_regulator_match bd71837_matches[] = {
+	{ .name = "buck1",	},
+	{ .name = "buck2",	},
+	{ .name = "buck3",	},
+	{ .name = "buck4",	},
+	{ .name = "buck5",	},
+	{ .name = "buck6",	},
+	{ .name = "buck7",	},
+	{ .name = "buck8",	},
+	{ .name = "ldo1",	},
+	{ .name = "ldo2",	},
+	{ .name = "ldo3",	},
+	{ .name = "ldo4",	},
+	{ .name = "ldo5",	},
+	{ .name = "ldo6",	},
+	{ .name = "ldo7",	},
+};
+
+/**@brief parse bd71837 regulator device tree
+ * @param pdev platform device of bd71837 regulator
+ * @param bd71837_reg_matches return regualtor matches
+ * @retval 0 parse success
+ * @retval NULL parse fail
+ */
+static int bd71837_parse_dt_reg_data(
+		struct platform_device *pdev,
+		struct of_regulator_match **reg_matches)
+{
+	// struct bd71837 *bd71837 = dev_get_drvdata(pdev->dev.parent);
+	struct device_node *np, *regulators;
+	struct of_regulator_match *matches;
+	int ret, count;
+
+	np = of_node_get(pdev->dev.parent->of_node);
+	regulators = of_find_node_by_name(np, "regulators");
+	if (!regulators) {
+		dev_err(&pdev->dev, "regulator node not found\n");
+		return -EINVAL;
+	}
+
+	count = ARRAY_SIZE(bd71837_matches);
+	matches = bd71837_matches;
+
+	ret = of_regulator_match(&pdev->dev, regulators, matches, count);
+	of_node_put(regulators);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Error parsing regulator init data: %d\n",
+			ret);
+		return ret;
+	}
+
+	*reg_matches = matches;
+
+	return 0;
+}
+#else
+static inline int bd71837_parse_dt_reg_data(
+			struct platform_device *pdev,
+			struct of_regulator_match **reg_matches)
+{
+	*reg_matches = NULL;
+	return 0;
+}
+#endif
+
+/** @brief retrive out32k output value */
+static ssize_t show_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct bd71837_pmic *pmic = dev_get_drvdata(dev);
+	int o;
+
+	o = bd71837_reg_read(pmic->mfd, BD71837_REG_OUT32K);
+	o = (o & OUT32K_EN) != 0;
+
+	return sprintf(buf, "%d\n", o);
+}
+
+/** @brief set o output value */
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct bd71837_pmic *pmic = dev_get_drvdata(dev);
+	int o, r;
+
+	if (sscanf(buf, "%d", &o) < 1) {
+		return -EINVAL;
+	}
+
+	if (o != 0) {
+		o = OUT32K_EN;
+	}
+	r = bd71837_update_bits(pmic->mfd, BD71837_REG_OUT32K, OUT32K_EN, o);
+	if (r < 0) {
+		return r;
+	}
+	return count;
+}
+
+/** @brief list all supported values */
+static ssize_t available_values(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0 1 \n");
+}
+
+/** @brief directly set raw value to chip register, format: 'register value' */
+static ssize_t bd71837_sysfs_set_registers(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf,
+					   size_t count)
+{
+	struct bd71837_pmic *pmic = dev_get_drvdata(dev);
+	ssize_t ret = 0;
 	unsigned int reg;
-	unsigned int mask;
+	unsigned int val;
+
+	ret = sscanf(buf, "%x %x", &reg, &val);
+	if (ret < 1) {
+		pmic->reg_index = -1;
+		dev_err(pmic->dev, "registers set: <reg> <value>\n");
+		return count;
+	}
+
+	if (ret == 1 && reg < BD71837_MAX_REGISTER) {
+		pmic->reg_index = reg;
+		dev_info(pmic->dev, "registers set: reg=0x%x\n", reg);
+		return count;
+	}
+
+	if (reg > BD71837_MAX_REGISTER) {
+		dev_err(pmic->dev, "reg=%d out of Max=%d\n", reg, BD71837_MAX_REGISTER);
+		return -EINVAL;
+	}
+	dev_info(pmic->dev, "registers set: reg=0x%x, val=0x%x\n", reg, val);
+	ret = bd71837_reg_write(pmic->mfd, reg, val);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+/** @brief print value of chip register, format: 'register=value' */
+static ssize_t bd71837_sysfs_print_reg(struct bd71837_pmic *pmic,
+				       u8 reg,
+				       char *buf)
+{
+	int ret = bd71837_reg_read(pmic->mfd, reg);
+	if (ret < 0)
+		return sprintf(buf, "%#.2x=error %d\n", reg, ret);
+	return sprintf(buf, "[0x%.2X] = %.2X\n", reg, ret);
+}
+
+/** @brief show all raw values of chip register, format per line: 'register=value' */
+static ssize_t bd71837_sysfs_show_registers(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct bd71837_pmic *pmic = dev_get_drvdata(dev);
+	ssize_t ret = 0;
+	int i;
+
+	dev_info(pmic->dev, "register: index[0x%x]\n", pmic->reg_index);
+	if (pmic->reg_index >= 0) {
+		ret += bd71837_sysfs_print_reg(pmic, pmic->reg_index, buf + ret);
+	} else {
+		for (i = 0; i < BD71837_MAX_REGISTER; i++) {
+			ret += bd71837_sysfs_print_reg(pmic, i, buf + ret);
+		}
+	}
+	return ret;
+}
+
+static DEVICE_ATTR(out32k_value, S_IWUSR | S_IRUGO, show_value, set_value);
+static DEVICE_ATTR(available_value, S_IWUSR | S_IRUGO, available_values, NULL);
+static DEVICE_ATTR(registers, S_IWUSR | S_IRUGO,
+		bd71837_sysfs_show_registers, bd71837_sysfs_set_registers);
+
+/** @brief device sysfs attribute table, about o */
+static struct attribute *clk_attributes[] = {
+	&dev_attr_out32k_value.attr,
+	&dev_attr_available_value.attr,
+	&dev_attr_registers.attr,
+	NULL
 };
 
+static const struct attribute_group clk_attr_group = {
+	.attrs	= clk_attributes,
+};
+
+/*----------------------------------------------------------------------*/
+#ifdef CONFIG_OF
+/** @brief buck1/2 dvs enable/voltage from device tree
+ * @param pdev platfrom device pointer
+ * @param buck_dvs pointer
+ * @return void
+ */
+static void of_bd71837_buck_dvs(struct platform_device *pdev, struct bd71837_buck_dvs *buck_dvs)
+{
+	struct device_node *pmic_np;
+
+	pmic_np = of_node_get(pdev->dev.parent->of_node);
+	if (!pmic_np) {
+		dev_err(&pdev->dev, "could not find pmic sub-node\n");
+		return;
+	}
+
+	if (of_get_property(pmic_np, "bd71837,pmic-buck1-uses-i2c-dvs", NULL)) {
+		if (of_property_read_u32_array(pmic_np,
+							"bd71837,pmic-buck1-dvs-voltage",
+							&buck_dvs[0].voltage[0], BD71837_DVS_RUN_IDLE_SUSP)) {
+			dev_err(&pdev->dev, "buck1 voltages not specified\n");
+		}
+	}
+
+	if (of_get_property(pmic_np, "bd71837,pmic-buck2-uses-i2c-dvs", NULL)) {
+		if (of_property_read_u32_array(pmic_np,
+							"bd71837,pmic-buck2-dvs-voltage",
+						&buck_dvs[1].voltage[0], BD71837_DVS_RUN_IDLE)) {
+			dev_err(&pdev->dev, "buck2 voltages not specified\n");
+		}
+	}
+
+	if (of_get_property(pmic_np, "bd71837,pmic-buck3-uses-i2c-dvs", NULL)) {
+		if (of_property_read_u32_array(pmic_np,
+							"bd71837,pmic-buck3-dvs-voltage",
+						&buck_dvs[2].voltage[0], BD71837_DVS_RUN)) {
+			dev_err(&pdev->dev, "buck3 voltages not specified\n");
+		}
+	}
+	if (of_get_property(pmic_np, "bd71837,pmic-buck4-uses-i2c-dvs", NULL)) {
+		if (of_property_read_u32_array(pmic_np,
+							"bd71837,pmic-buck4-dvs-voltage",
+						&buck_dvs[3].voltage[0], BD71837_DVS_RUN)) {
+			dev_err(&pdev->dev, "buck4 voltages not specified\n");
+		}
+	}
+}
+#else
+static void of_bd71837_buck_dvs(struct platform_device *pdev, struct bd71837_buck_dvs *buck_dvs)
+{
+	buck_dvs[0].voltage[0] = BUCK1_RUN_DEFAULT;
+	buck_dvs[0].voltage[1] = BUCK1_IDLE_DEFAULT;
+	buck_dvs[0].voltage[2] = BUCK1_SUSP_DEFAULT;
+	buck_dvs[1].voltage[0] = BUCK2_RUN_DEFAULT;
+	buck_dvs[1].voltage[1] = BUCK2_IDLE_DEFAULT;
+	buck_dvs[1].voltage[2] = 0; /* Not supported */
+	buck_dvs[2].voltage[0] = BUCK3_RUN_DEFAULT;
+	buck_dvs[2].voltage[1] = 0; /* Not supported */
+	buck_dvs[2].voltage[2] = 0; /* Not supported */
+	buck_dvs[3].voltage[0] = BUCK4_RUN_DEFAULT;
+	buck_dvs[3].voltage[1] = 0; /* Not supported */
+	buck_dvs[3].voltage[2] = 0; /* Not supported */
+}
+#endif
+
+static int bd71837_buck1234_dvs_init(struct bd71837_pmic *pmic)
+{
+	struct bd71837 *bd71837 = pmic->mfd;
+	struct bd71837_buck_dvs *buck_dvs = &pmic->buck_dvs[0];
+	int i, ret, val, selector = 0;
+	u8 reg_run, reg_idle, reg_susp;
+	u8 reg_run_msk, reg_idle_msk, reg_susp_msk;
+
+	for (i = 0; i < BD71837_DVS_BUCK_NUM; i++, buck_dvs++) {
+		switch (i) {
+		case 0:
+		default:
+			reg_run = BD71837_REG_BUCK1_VOLT_RUN;
+			reg_run_msk = BUCK1_RUN_MASK;
+			reg_idle = BD71837_REG_BUCK1_VOLT_IDLE;
+			reg_idle_msk = BUCK1_IDLE_MASK;
+			reg_susp = BD71837_REG_BUCK1_VOLT_SUSP;
+			reg_susp_msk = BUCK1_SUSP_MASK;
+			break;
+		case 1:
+			reg_run = BD71837_REG_BUCK2_VOLT_RUN;
+			reg_run_msk = BUCK2_RUN_MASK;
+			reg_idle = BD71837_REG_BUCK2_VOLT_IDLE;
+			reg_idle_msk = BUCK2_IDLE_MASK;
+			reg_susp = 0;
+			break;
+		case 2:
+			reg_run = BD71837_REG_BUCK3_VOLT_RUN;
+			reg_run_msk = BUCK3_RUN_MASK;
+			reg_idle = 0;
+			reg_susp = 0;
+			break;
+		case 3:
+			reg_run = BD71837_REG_BUCK4_VOLT_RUN;
+			reg_run_msk = BUCK4_RUN_MASK;
+			reg_idle = 0;
+			reg_susp = 0;
+			break;
+		}
+
+		dev_dbg(pmic->dev, "Buck%d: DVS Run-Idle-Susp[%d - %d - %d].\n", i+1, buck_dvs->voltage[0], buck_dvs->voltage[1], buck_dvs->voltage[2]);
+		if (reg_run > 0) {
+			selector = regulator_map_voltage_iterate(pmic->rdev[i], buck_dvs->voltage[0], buck_dvs->voltage[0]);
+			if (selector < 0) {
+				dev_dbg(pmic->dev, "%s(): not found selector for Run voltage [%d]\n", __func__, buck_dvs->voltage[0]);
+			} else {
+				val = (selector & reg_run_msk);
+				ret = bd71837_reg_write(bd71837, reg_run, val);
+				if (ret < 0)
+					return ret;
+			}
+		}
+		if (reg_idle > 0) {
+			selector = regulator_map_voltage_iterate(pmic->rdev[i], buck_dvs->voltage[1], buck_dvs->voltage[1]);
+			if (selector < 0) {
+				dev_dbg(pmic->dev, "%s(): not found selector for Idle voltage [%d]\n", __func__, buck_dvs->voltage[1]);
+			} else {
+				val = (selector & reg_idle_msk);
+				ret = bd71837_reg_write(bd71837, reg_idle, val);
+				if (ret < 0)
+					return ret;
+			}
+		}
+		if (reg_susp > 0) {
+			selector = regulator_map_voltage_iterate(pmic->rdev[i], buck_dvs->voltage[2], buck_dvs->voltage[2]);
+			if (selector < 0) {
+				dev_dbg(pmic->dev, "%s(): not found selector for Susp voltage [%d]\n", __func__, buck_dvs->voltage[2]);
+			} else {
+				val = (selector & reg_susp_msk);
+				ret = bd71837_reg_write(bd71837, reg_susp, val);
+				if (ret < 0)
+					return ret;
+			}
+		}
+	}
+	return 0;
+}
+
+/**@brief bd71837 pmic interrupt
+ * @param irq system irq
+ * @param pwrsys bd71837 power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ */
+static irqreturn_t bd71837_pmic_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd71837 *mfd = dev_get_drvdata(dev->parent);
+	// struct bd71837_power *pwr = dev_get_drvdata(dev);
+	int reg;
+
+	bd71837_debug(BD71837_DBG0, "bd71837_pmic_interrupt() in.\n");
+
+	reg = bd71837_reg_read(mfd, BD71837_REG_IRQ);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	if (reg & IRQ_SWRST) {
+		bd71837_debug(BD71837_DBG0, "IRQ_SWRST\n");
+	}
+	if (reg & IRQ_PWRON_S) {
+		bd71837_debug(BD71837_DBG0, "IRQ_PWRON_S\n");
+	}
+	if (reg & IRQ_PWRON_L) {
+		bd71837_debug(BD71837_DBG0, "IRQ_PWRON_L\n");
+	}
+	if (reg & IRQ_PWRON) {
+		bd71837_debug(BD71837_DBG0, "IRQ_PWRON\n");
+	}
+	if (reg & IRQ_WDOG) {
+		bd71837_debug(BD71837_DBG0, "IRQ_WDOG\n");
+	}
+	if (reg & IRQ_ON_REQ) {
+		bd71837_debug(BD71837_DBG0, "IRQ_ON_REQ\n");
+	}
+	if (reg & IRQ_STBY_REQ) {
+		bd71837_debug(BD71837_DBG0, "IRQ_STBY_REQ\n");
+	}
+
+	reg = bd71837_reg_write(mfd, BD71837_REG_IRQ, reg);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	return IRQ_HANDLED;
+}
+
+/**@brief probe bd71837 regulator device
+ @param pdev bd71837 regulator platform device
+ @retval 0 success
+ @retval negative fail
+*/
 static int bd71837_probe(struct platform_device *pdev)
 {
 	struct bd71837_pmic *pmic;
 	struct bd71837_board *pdata;
-	struct regulator_config config = { 0 };
-	struct reg_init pmic_regulator_inits[] = {
-		{
-			.reg = BD71837_REG_BUCK1_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK2_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK3_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK4_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK5_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK6_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK7_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_BUCK8_CTRL,
-			.mask = BD71837_BUCK_SEL,
-		}, {
-			.reg = BD71837_REG_LDO1_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}, {
-			.reg = BD71837_REG_LDO2_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}, {
-			.reg = BD71837_REG_LDO3_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}, {
-			.reg = BD71837_REG_LDO4_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}, {
-			.reg = BD71837_REG_LDO5_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}, {
-			.reg = BD71837_REG_LDO6_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}, {
-			.reg = BD71837_REG_LDO7_VOLT,
-			.mask = BD71837_LDO_SEL,
-		}
-	};
-
-	int i, err;
+	struct regulator_config config = {};
+	struct bd71837 *bd71837 = dev_get_drvdata(pdev->dev.parent);
+	struct of_regulator_match *matches = NULL;
+	int i = 0, err, irq = 0, ret = 0;
 
-	pmic = devm_kzalloc(&pdev->dev, sizeof(struct bd71837_pmic),
-			    GFP_KERNEL);
-	if (!pmic)
+	pmic = kzalloc(sizeof(*pmic), GFP_KERNEL);
+	if (!pmic) {
+		dev_err(&pdev->dev, "Memory allocation failed for pmic\n");
 		return -ENOMEM;
+	}
 
-	memcpy(pmic->descs, bd71837_regulators, sizeof(pmic->descs));
+	memcpy(pmic->descs, bd71837_regulators,	sizeof(pmic->descs));
 
-	pmic->pdev = pdev;
-	pmic->mfd = dev_get_drvdata(pdev->dev.parent);
+	pmic->dev = &pdev->dev;
+	pmic->mfd = bd71837;
+	platform_set_drvdata(pdev, pmic);
+	pdata = dev_get_platdata(bd71837->dev);
 
-	if (!pmic->mfd) {
-		dev_err(&pdev->dev, "No MFD driver data\n");
-		err = -EINVAL;
-		goto err;
+	if (!pdata && bd71837->dev->of_node) {
+		bd71837_parse_dt_reg_data(pdev,	&matches);
+		if (matches == NULL) {
+			dev_err(&pdev->dev, "Platform data not found\n");
+			return -EINVAL;
+		}
 	}
-	platform_set_drvdata(pdev, pmic);
-	pdata = dev_get_platdata(pmic->mfd->dev);
+
+	/* Get buck dvs parameters */
+	of_bd71837_buck_dvs(pdev, &pmic->buck_dvs[0]);
 
 	/* Register LOCK release */
-	err = regmap_update_bits(pmic->mfd->regmap, BD71837_REG_REGLOCK,
-				 (REGLOCK_PWRSEQ | REGLOCK_VREG), 0);
-	if (err) {
-		dev_err(&pmic->pdev->dev, "Failed to unlock PMIC (%d)\n", err);
+	err = bd71837_reg_write(bd71837, BD71837_REG_REGLOCK, 0x0);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to write LOCK register(%d)\n", err);
+		goto err;
+	}
+	/* Enable LDO5 */
+	err = bd71837_set_bits(bd71837, BD71837_REG_LDO5_VOLT, LDO5_EN);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to enable LDO5 register(%d)\n", err);
+		goto err;
+	}
+	/* Enable LDO6 */
+	err = bd71837_set_bits(bd71837, BD71837_REG_LDO6_VOLT, LDO6_EN);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to enable LDO6 register(%d)\n", err);
+		goto err;
+	}
+	/* Enable LDO7 */
+	err = bd71837_set_bits(bd71837, BD71837_REG_LDO7_VOLT, LDO7_EN);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to enable LDO7 register(%d)\n", err);
 		goto err;
-	} else {
-		dev_dbg(&pmic->pdev->dev, "%s: Unlocked lock register 0x%x\n",
-			__func__, BD71837_REG_REGLOCK);
 	}
 
-	for (i = 0; i < ARRAY_SIZE(pmic_regulator_inits); i++) {
-
+	for (i = 0; i < BD71837_REGULATOR_CNT; i++) {
+		struct regulator_init_data *init_data;
 		struct regulator_desc *desc;
 		struct regulator_dev *rdev;
 
 		desc = &pmic->descs[i];
+		desc->name = bd71837_matches[i].name;
 
-		if (pdata)
-			config.init_data = pdata->init_data[i];
+		if (pdata) {
+			init_data = pdata->init_data[i];
+		} else {
+			init_data = matches[i].init_data;
+		}
 
-		config.dev = pdev->dev.parent;
+		config.dev = pmic->dev;
+		config.init_data = init_data;
 		config.driver_data = pmic;
-		config.regmap = pmic->mfd->regmap;
+		config.regmap = bd71837->regmap;
+		config.of_node = matches[i].of_node;
+		dev_info(config.dev, "regulator register name '%s'\n", desc->name);
 
-		rdev = devm_regulator_register(&pdev->dev, desc, &config);
+		rdev = regulator_register(desc, &config);
 		if (IS_ERR(rdev)) {
-			dev_err(pmic->mfd->dev,
+			dev_err(bd71837->dev,
 				"failed to register %s regulator\n",
 				desc->name);
 			err = PTR_ERR(rdev);
 			goto err;
 		}
-		/* Regulator register gets the regulator constraints and
-		 * applies them (set_machine_constraints). This should have
-		 * turned the control register(s) to correct values and we
-		 * can now switch the control from PMIC state machine to the
-		 * register interface
-		 */
-		err = regmap_update_bits(pmic->mfd->regmap,
-					 pmic_regulator_inits[i].reg,
-					 pmic_regulator_inits[i].mask,
-					 0xFFFFFFFF);
-		if (err) {
-			dev_err(&pmic->pdev->dev,
-				"Failed to write BUCK/LDO SEL bit for (%s)\n",
-				desc->name);
-			goto err;
-		}
-
 		pmic->rdev[i] = rdev;
 	}
 
+	/* Init sysfs registers */
+	pmic->reg_index = -1;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &clk_attr_group);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to create attribute group: %d\n", err);
+		goto err;
+	}
+
+	/* Init Buck1/2/3/4 dvs */
+	err = bd71837_buck1234_dvs_init(pmic);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to buck12 dvs: %d\n", err);
+		goto err;
+	}
+
+	/* Add Interrupt */
+	irq  = platform_get_irq(pdev, 0); // get irq number
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+			bd71837_pmic_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/* Un-mask IRQ Interrupt */
+	ret = bd71837_reg_write(bd71837, BD71837_REG_MIRQ, 0);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Write Un-mask 'BD71837_REG_MIRQ': failed!\n");
+		ret = -EIO;
+		goto err;
+	}
+
 	return 0;
 
 err:
+	while (--i >= 0)
+		regulator_unregister(pmic->rdev[i]);
+
+	kfree(pmic);
 	return err;
 }
 
-static struct platform_driver bd71837_regulator = {
+/**@brief remove bd71837 regulator device
+ @param pdev bd71837 regulator platform device
+ @return 0
+*/
+static int __exit bd71837_remove(struct platform_device *pdev)
+{
+	struct bd71837_pmic *pmic = platform_get_drvdata(pdev);
+	int i;
+
+	sysfs_remove_group(&pdev->dev.kobj, &clk_attr_group);
+
+	for (i = 0; i < BD71837_REGULATOR_CNT; i++)
+		regulator_unregister(pmic->rdev[i]);
+
+	kfree(pmic);
+	return 0;
+}
+
+static struct platform_driver bd71837_driver = {
 	.driver = {
 		.name = "bd71837-pmic",
 		.owner = THIS_MODULE,
 	},
 	.probe = bd71837_probe,
+	.remove = bd71837_remove,
 };
 
-module_platform_driver(bd71837_regulator);
+/**@brief module initialize function */
+static int __init bd71837_init(void)
+{
+	return platform_driver_register(&bd71837_driver);
+}
+subsys_initcall(bd71837_init);
+
+/**@brief module deinitialize function */
+static void __exit bd71837_cleanup(void)
+{
+	platform_driver_unregister(&bd71837_driver);
+}
+module_exit(bd71837_cleanup);
 
-MODULE_AUTHOR("Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>");
+MODULE_AUTHOR("Cong Pham <cpham2403@gmail.com>");
 MODULE_DESCRIPTION("BD71837 voltage regulator driver");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bd71837-pmic");
+
+/*-------------------------------------------------------*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#define PROCFS_NAME 		"bd71837"
+#define BD71837_REV			"BD71837 Driver: Rev002\n"
+
+#define BD71837_BUF_SIZE	1024
+static char procfs_buffer[BD71837_BUF_SIZE];
+/**
+ * This function is called then the /proc file is read
+ *
+ */
+static int onetime;
+static ssize_t bd71837_proc_read (struct file *file, char __user *buffer, size_t count, loff_t *data)
+{
+	int ret = 0, error = 0;
+	if (onetime == 0) {
+		onetime = 1;
+		memset(procfs_buffer, 0, BD71837_BUF_SIZE);
+		sprintf(procfs_buffer, "%s", BD71837_REV);
+		ret = strlen(procfs_buffer);
+		error = copy_to_user(buffer, procfs_buffer, strlen(procfs_buffer));
+	} else {
+		//Clear for next time
+		onetime = 0;
+	}
+	return (error != 0) ? 0 : ret;
+}
+
+static ssize_t bd71837_proc_write (struct file *file, const char __user *buffer, size_t count, loff_t *data)
+{
+	sscanf(buffer, "0x%x", &bd71837_debug_mask);
+	printk("bd71837: bd71837_debug_mask=0x%08x\n", bd71837_debug_mask);
+	return count;
+}
+
+static const struct file_operations bd71837_proc_fops = {
+	.owner		= THIS_MODULE,
+	.read		= bd71837_proc_read,
+	.write		= bd71837_proc_write,
+};
+
+/**
+ *This function is called when the module is loaded
+ *
+ */
+int bd71837_revision_init(void)
+{
+	struct proc_dir_entry *bd71837_proc_entry;
+
+	/* create the /proc/bd71837 */
+	bd71837_proc_entry = proc_create(PROCFS_NAME, 0644, NULL, &bd71837_proc_fops);
+	if (bd71837_proc_entry == NULL) {
+		printk("Error: Could not initialize /proc/%s\n", PROCFS_NAME);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+module_init(bd71837_revision_init);
+/*-------------------------------------------------------*/
diff --git a/drivers/regulator/userspace-consumer.c b/drivers/regulator/userspace-consumer.c
index 765acc1..9d6c079 100644
--- a/drivers/regulator/userspace-consumer.c
+++ b/drivers/regulator/userspace-consumer.c
@@ -22,6 +22,8 @@
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/userspace-consumer.h>
+#include <linux/of.h>
+#include <linux/regulator/of_regulator.h>
 #include <linux/slab.h>
 
 struct userspace_consumer_data {
@@ -105,6 +107,39 @@ static ssize_t reg_set_state(struct device *dev, struct device_attribute *attr,
 	.attrs	= attributes,
 };
 
+#if defined(CONFIG_OF)
+static struct regulator_userspace_consumer_data*
+	of_get_uc_config(struct device *dev, struct device_node *np)
+{
+	struct regulator_userspace_consumer_data *ucd;
+	int r;
+
+	ucd = devm_kzalloc(dev, sizeof(struct regulator_userspace_consumer_data)
+				+ sizeof(struct regulator_bulk_data),
+				GFP_KERNEL);
+	if (ucd == NULL)
+		return NULL;
+
+	r = of_property_read_string(np, "uc-name", &ucd->name);
+	if (r) {
+		goto err;
+	}
+
+	ucd->num_supplies = 1;
+	ucd->supplies = (struct regulator_bulk_data *)&ucd[1];
+
+	r = of_property_read_string(np, "suck-supply", &ucd->supplies->supply);
+	if (r) {
+		goto err;
+	}
+	return ucd;
+
+err:
+	devm_kfree(dev, ucd);
+	return NULL;
+}
+#endif
+
 static int regulator_userspace_consumer_probe(struct platform_device *pdev)
 {
 	struct regulator_userspace_consumer_data *pdata;
@@ -112,6 +147,11 @@ static int regulator_userspace_consumer_probe(struct platform_device *pdev)
 	int ret;
 
 	pdata = dev_get_platdata(&pdev->dev);
+#if defined(CONFIG_OF)
+	if (!pdata && pdev->dev.of_node) {
+		pdata = of_get_uc_config(&pdev->dev, pdev->dev.of_node);
+	}
+#endif
 	if (!pdata)
 		return -EINVAL;
 
@@ -151,6 +191,8 @@ static int regulator_userspace_consumer_probe(struct platform_device *pdev)
 	drvdata->enabled = pdata->init_on;
 	platform_set_drvdata(pdev, drvdata);
 
+	dev_info(&pdev->dev, "attached: %s\n", drvdata->name);
+
 	return 0;
 
 err_enable:
@@ -171,11 +213,22 @@ static int regulator_userspace_consumer_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id uc_of_match[] = {
+	{ .compatible = "userspace_consumer", },
+	{},
+};
+#endif
+
 static struct platform_driver regulator_userspace_consumer_driver = {
 	.probe		= regulator_userspace_consumer_probe,
 	.remove		= regulator_userspace_consumer_remove,
 	.driver		= {
 		.name		= "reg-userspace-consumer",
+		.owner		= THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(uc_of_match),
+#endif
 	},
 };
 
diff --git a/drivers/regulator/virtual.c b/drivers/regulator/virtual.c
index a6f1c7a..115b9b3 100644
--- a/drivers/regulator/virtual.c
+++ b/drivers/regulator/virtual.c
@@ -15,8 +15,11 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regulator/of_regulator.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/of.h>
+
 
 struct virtual_consumer_data {
 	struct mutex lock;
@@ -285,9 +288,22 @@ static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
 	.attrs	= regulator_virtual_attributes,
 };
 
+static const char *of_get_virt_regulator_config(struct device *dev, struct device_node *np)
+{
+	const char *reg_id;
+	int r;
+
+	r = of_property_read_string(np, "virtual-supply", &reg_id);
+	if (r) {
+		return NULL;
+	}
+	return reg_id;
+}
+
 static int regulator_virtual_probe(struct platform_device *pdev)
 {
 	char *reg_id = dev_get_platdata(&pdev->dev);
+	struct device_node *np = pdev->dev.of_node;
 	struct virtual_consumer_data *drvdata;
 	int ret;
 
@@ -296,6 +312,15 @@ static int regulator_virtual_probe(struct platform_device *pdev)
 	if (drvdata == NULL)
 		return -ENOMEM;
 
+	if (np) {
+		reg_id = (char *)of_get_virt_regulator_config(&pdev->dev, np);
+	}
+
+	if (reg_id == NULL) {
+		dev_err(&pdev->dev, "Fail to get reg_id");
+		return -EINVAL;
+	}
+
 	mutex_init(&drvdata->lock);
 
 	drvdata->regulator = devm_regulator_get(&pdev->dev, reg_id);
@@ -318,6 +343,8 @@ static int regulator_virtual_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, drvdata);
 
+	dev_info(&pdev->dev, "attached: %s\n", reg_id);
+
 	return 0;
 }
 
@@ -330,14 +357,25 @@ static int regulator_virtual_remove(struct platform_device *pdev)
 	if (drvdata->enabled)
 		regulator_disable(drvdata->regulator);
 
+	platform_set_drvdata(pdev, NULL);
+
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id regulator_virtual_of_match[] = {
+	{ .compatible = "regulator-virtual", },
+	{},
+};
+#endif
+
 static struct platform_driver regulator_virtual_consumer_driver = {
 	.probe		= regulator_virtual_probe,
 	.remove		= regulator_virtual_remove,
 	.driver		= {
 		.name		= "reg-virt-consumer",
+		.owner		= THIS_MODULE,
+		.of_match_table = of_match_ptr(regulator_virtual_of_match),
 	},
 };
 
diff --git a/include/linux/mfd/bd71837.h b/include/linux/mfd/bd71837.h
new file mode 100644
index 0000000..3cd51f3
--- /dev/null
+++ b/include/linux/mfd/bd71837.h
@@ -0,0 +1,413 @@
+/**
+ * @file bd71837.h  ROHM BD71837MWV header file
+ *
+ * Copyright 2017
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ * @author cpham2403@gmail.com
+ */
+
+#ifndef __LINUX_MFD_BD71837_H
+#define __LINUX_MFD_BD71837_H
+
+#include <linux/regmap.h>
+
+enum {
+	BD71837_BUCK1	=	0,
+	BD71837_BUCK2,
+	BD71837_BUCK3,
+	BD71837_BUCK4,
+	BD71837_BUCK5,
+	BD71837_BUCK6,
+	BD71837_BUCK7,
+	BD71837_BUCK8,
+	// General Purpose
+	BD71837_LDO1,
+	BD71837_LDO2,
+	BD71837_LDO3,
+	BD71837_LDO4,
+	BD71837_LDO5,
+	BD71837_LDO6,
+	BD71837_LDO7,
+	BD71837_REGULATOR_CNT,
+};
+
+#define BD71837_SUPPLY_STATE_ENABLED    0x1
+
+#define BD71837_BUCK1_VOLTAGE_NUM	0x40
+#define BD71837_BUCK2_VOLTAGE_NUM	0x40
+#define BD71837_BUCK3_VOLTAGE_NUM	0x40
+#define BD71837_BUCK4_VOLTAGE_NUM	0x40
+
+#define BD71837_BUCK5_VOLTAGE_NUM	0x08
+#define BD71837_BUCK6_VOLTAGE_NUM	0x04
+#define BD71837_BUCK7_VOLTAGE_NUM	0x08
+#define BD71837_BUCK8_VOLTAGE_NUM	0x40
+
+#define BD71837_LDO1_VOLTAGE_NUM	0x04
+#define BD71837_LDO2_VOLTAGE_NUM	0x02
+#define BD71837_LDO3_VOLTAGE_NUM	0x10
+#define BD71837_LDO4_VOLTAGE_NUM	0x10
+#define BD71837_LDO5_VOLTAGE_NUM	0x10
+#define BD71837_LDO6_VOLTAGE_NUM	0x10
+#define BD71837_LDO7_VOLTAGE_NUM	0x10
+
+enum {
+	BD71837_REG_REV                = 0x00,
+	BD71837_REG_SWRESET            = 0x01,
+	BD71837_REG_I2C_DEV            = 0x02,
+	BD71837_REG_PWRCTRL0           = 0x03,
+	BD71837_REG_PWRCTRL1           = 0x04,
+	BD71837_REG_BUCK1_CTRL         = 0x05,
+	BD71837_REG_BUCK2_CTRL         = 0x06,
+	BD71837_REG_BUCK3_CTRL         = 0x07,
+	BD71837_REG_BUCK4_CTRL         = 0x08,
+	BD71837_REG_BUCK5_CTRL         = 0x09,
+	BD71837_REG_BUCK6_CTRL         = 0x0A,
+	BD71837_REG_BUCK7_CTRL         = 0x0B,
+	BD71837_REG_BUCK8_CTRL         = 0x0C,
+	BD71837_REG_BUCK1_VOLT_RUN     = 0x0D,
+	BD71837_REG_BUCK1_VOLT_IDLE    = 0x0E,
+	BD71837_REG_BUCK1_VOLT_SUSP    = 0x0F,
+	BD71837_REG_BUCK2_VOLT_RUN     = 0x10,
+	BD71837_REG_BUCK2_VOLT_IDLE    = 0x11,
+	BD71837_REG_BUCK3_VOLT_RUN     = 0x12,
+	BD71837_REG_BUCK4_VOLT_RUN     = 0x13,
+	BD71837_REG_BUCK5_VOLT         = 0x14,
+	BD71837_REG_BUCK6_VOLT         = 0x15,
+	BD71837_REG_BUCK7_VOLT         = 0x16,
+	BD71837_REG_BUCK8_VOLT         = 0x17,
+	BD71837_REG_LDO1_VOLT          = 0x18,
+	BD71837_REG_LDO2_VOLT          = 0x19,
+	BD71837_REG_LDO3_VOLT          = 0x1A,
+	BD71837_REG_LDO4_VOLT          = 0x1B,
+	BD71837_REG_LDO5_VOLT          = 0x1C,
+	BD71837_REG_LDO6_VOLT          = 0x1D,
+	BD71837_REG_LDO7_VOLT          = 0x1E,
+	BD71837_REG_TRANS_COND0        = 0x1F,
+	BD71837_REG_TRANS_COND1        = 0x20,
+	BD71837_REG_VRFAULTEN          = 0x21,
+	BD71837_REG_MVRFLTMASK0        = 0x22,
+	BD71837_REG_MVRFLTMASK1        = 0x23,
+	BD71837_REG_MVRFLTMASK2        = 0x24,
+	BD71837_REG_RCVCFG             = 0x25,
+	BD71837_REG_RCVNUM             = 0x26,
+	BD71837_REG_PWRONCONFIG0       = 0x27,
+	BD71837_REG_PWRONCONFIG1       = 0x28,
+	BD71837_REG_RESETSRC           = 0x29,
+	BD71837_REG_MIRQ               = 0x2A,
+	BD71837_REG_IRQ                = 0x2B,
+	BD71837_REG_IN_MON             = 0x2C,
+	BD71837_REG_POW_STATE          = 0x2D,
+	BD71837_REG_OUT32K             = 0x2E,
+	BD71837_REG_REGLOCK            = 0x2F,
+	BD71837_REG_OTPVER             = 0xFF,
+	BD71837_MAX_REGISTER		   = 0x100,
+};
+
+/* BD71837_REG_BUCK1_CTRL bits */
+#define BUCK1_RAMPRATE_MASK		0xC0
+#define BUCK1_RAMPRATE_10P00MV	0x0
+#define BUCK1_RAMPRATE_5P00MV	0x1
+#define BUCK1_RAMPRATE_2P50MV	0x2
+#define BUCK1_RAMPRATE_1P25MV	0x3
+#define BUCK1_SEL				0x02
+#define BUCK1_EN				0x01
+
+/* BD71837_REG_BUCK2_CTRL bits */
+#define BUCK2_RAMPRATE_MASK		0xC0
+#define BUCK2_RAMPRATE_10P00MV	0x0
+#define BUCK2_RAMPRATE_5P00MV	0x1
+#define BUCK2_RAMPRATE_2P50MV	0x2
+#define BUCK2_RAMPRATE_1P25MV	0x3
+#define BUCK2_SEL				0x02
+#define BUCK2_EN				0x01
+
+/* BD71837_REG_BUCK3_CTRL bits */
+#define BUCK3_RAMPRATE_MASK		0xC0
+#define BUCK3_RAMPRATE_10P00MV	0x0
+#define BUCK3_RAMPRATE_5P00MV	0x1
+#define BUCK3_RAMPRATE_2P50MV	0x2
+#define BUCK3_RAMPRATE_1P25MV	0x3
+#define BUCK3_SEL				0x02
+#define BUCK3_EN				0x01
+
+/* BD71837_REG_BUCK4_CTRL bits */
+#define BUCK4_RAMPRATE_MASK		0xC0
+#define BUCK4_RAMPRATE_10P00MV	0x0
+#define BUCK4_RAMPRATE_5P00MV	0x1
+#define BUCK4_RAMPRATE_2P50MV	0x2
+#define BUCK4_RAMPRATE_1P25MV	0x3
+#define BUCK4_SEL				0x02
+#define BUCK4_EN				0x01
+
+/* BD71837_REG_BUCK5_CTRL bits */
+#define BUCK5_SEL				0x02
+#define BUCK5_EN				0x01
+
+/* BD71837_REG_BUCK6_CTRL bits */
+#define BUCK6_SEL				0x02
+#define BUCK6_EN				0x01
+
+/* BD71837_REG_BUCK7_CTRL bits */
+#define BUCK7_SEL				0x02
+#define BUCK7_EN				0x01
+
+/* BD71837_REG_BUCK8_CTRL bits */
+#define BUCK8_SEL				0x02
+#define BUCK8_EN				0x01
+
+/* BD71837_REG_BUCK1_VOLT_RUN bits */
+#define BUCK1_RUN_MASK			0x3F
+#define BUCK1_RUN_DEFAULT		0x14
+
+/* BD71837_REG_BUCK1_VOLT_SUSP bits */
+#define BUCK1_SUSP_MASK			0x3F
+#define BUCK1_SUSP_DEFAULT		0x14
+
+/* BD71837_REG_BUCK1_VOLT_IDLE bits */
+#define BUCK1_IDLE_MASK			0x3F
+#define BUCK1_IDLE_DEFAULT		0x14
+
+/* BD71837_REG_BUCK2_VOLT_RUN bits */
+#define BUCK2_RUN_MASK			0x3F
+#define BUCK2_RUN_DEFAULT		0x1E
+
+/* BD71837_REG_BUCK2_VOLT_IDLE bits */
+#define BUCK2_IDLE_MASK			0x3F
+#define BUCK2_IDLE_DEFAULT		0x14
+
+/* BD71837_REG_BUCK3_VOLT_RUN bits */
+#define BUCK3_RUN_MASK			0x3F
+#define BUCK3_RUN_DEFAULT		0x1E
+
+/* BD71837_REG_BUCK4_VOLT_RUN bits */
+#define BUCK4_RUN_MASK			0x3F
+#define BUCK4_RUN_DEFAULT		0x1E
+
+/* BD71837_REG_BUCK5_VOLT bits */
+#define BUCK5_MASK			0x07
+#define BUCK5_DEFAULT		0x02
+
+/* BD71837_REG_BUCK6_VOLT bits */
+#define BUCK6_MASK			0x03
+#define BUCK6_DEFAULT		0x03
+
+/* BD71837_REG_BUCK7_VOLT bits */
+#define BUCK7_MASK			0x07
+#define BUCK7_DEFAULT		0x03
+
+/* BD71837_REG_BUCK8_VOLT bits */
+#define BUCK8_MASK			0x3F
+#define BUCK8_DEFAULT		0x1E
+
+/* BD71837_REG_IRQ bits */
+#define IRQ_SWRST			0x40
+#define IRQ_PWRON_S			0x20
+#define IRQ_PWRON_L			0x10
+#define IRQ_PWRON			0x08
+#define IRQ_WDOG			0x04
+#define IRQ_ON_REQ			0x02
+#define IRQ_STBY_REQ		0x01
+
+/* BD71837_REG_OUT32K bits */
+#define OUT32K_EN				0x01
+
+/* BD71837 interrupt masks */
+enum {
+	BD71837_INT_MASK	=	0x7F,
+};
+/* BD71837 interrupt irqs */
+enum {
+	BD71837_IRQ		=	0x0,
+};
+
+/* BD71837_REG_LDO1_VOLT bits */
+#define LDO1_SEL				0x80
+#define LDO1_EN 				0x40
+#define LDO1_MASK				0x03
+
+/* BD71837_REG_LDO2_VOLT bits */
+#define LDO2_SEL				0x80
+#define LDO2_EN 				0x40
+
+/* BD71837_REG_LDO3_VOLT bits */
+#define LDO3_SEL				0x80
+#define LDO3_EN 				0x40
+#define LDO3_MASK				0x0F
+
+/* BD71837_REG_LDO4_VOLT bits */
+#define LDO4_SEL				0x80
+#define LDO4_EN 				0x40
+#define LDO4_MASK				0x0F
+
+/* BD71837_REG_LDO5_VOLT bits */
+#define LDO5_EN 				0x40
+#define LDO5_MASK				0x0F
+
+/* BD71837_REG_LDO6_VOLT bits */
+#define LDO6_EN 				0x40
+#define LDO6_MASK				0x0F
+
+/* BD71837_REG_LDO7_VOLT bits */
+#define LDO7_EN 				0x40
+#define LDO7_MASK				0x0F
+
+/** @brief charge state enumuration */
+enum CHG_STATE {
+	CHG_STATE_SUSPEND = 0x0,		/**< suspend state */
+	CHG_STATE_TRICKLE_CHARGE,		/**< trickle charge state */
+	CHG_STATE_PRE_CHARGE,			/**< precharge state */
+	CHG_STATE_FAST_CHARGE,			/**< fast charge state */
+	CHG_STATE_TOP_OFF,			/**< top off state */
+	CHG_STATE_DONE,				/**< charge complete */
+};
+
+struct bd71837;
+
+/**
+ * @brief Board platform data may be used to initialize regulators.
+ */
+
+struct bd71837_board {
+	struct regulator_init_data *init_data[BD71837_REGULATOR_CNT];
+	/**< regulator initialize data */
+	int	gpio_intr;		/**< gpio connected to bd71837 INTB */
+	int	irq_base;		/**< bd71837 sub irqs base #  */
+};
+
+/**
+ * @brief bd71837 sub-driver chip access routines
+ */
+
+struct bd71837 {
+	struct device *dev;
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct mutex io_mutex;
+	unsigned int id;
+
+	/* IRQ Handling */
+	int 	chip_irq;				/**< bd71837 irq to host cpu */
+	struct regmap_irq_chip_data *irq_data;
+
+	/* Client devices */
+	struct bd71837_pmic *pmic;		/**< client device regulator */
+	struct bd71837_power *power;	/**< client device battery */
+
+	struct bd71837_board *of_plat_data;
+	/**< Device node parsed board data */
+};
+
+static inline int bd71837_chip_id(struct bd71837 *bd71837)
+{
+	return bd71837->id;
+}
+
+
+/**
+ * @brief bd71837_reg_read
+ * read single register's value of bd71837
+ * @param bd71837 device to read
+ * @param reg register address
+ * @return register value if success
+ *         error number if fail
+ */
+static inline int bd71837_reg_read(struct bd71837 *bd71837, u8 reg)
+{
+	int r, val;
+
+	r = regmap_read(bd71837->regmap, reg, &val);
+	if (r < 0) {
+		return r;
+	}
+	return val;
+}
+
+/**
+ * @brief bd71837_reg_write
+ * write single register of bd71837
+ * @param bd71837 device to write
+ * @param reg register address
+ * @param val value to write
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd71837_reg_write(struct bd71837 *bd71837, u8 reg,
+		unsigned int val)
+{
+	return regmap_write(bd71837->regmap, reg, val);
+}
+
+/**
+ * @brief bd71837_set_bits
+ * set bits in one register of bd71837
+ * @param bd71837 device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+static inline int bd71837_set_bits(struct bd71837 *bd71837, u8 reg,	u8 mask)
+{
+	return regmap_update_bits(bd71837->regmap, reg, mask, mask);
+}
+
+/**
+ * @brief bd71837_clear_bits
+ * clear bits in one register of bd71837
+ * @param bd71837 device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd71837_clear_bits(struct bd71837 *bd71837, u8 reg,
+		u8 mask)
+{
+	return regmap_update_bits(bd71837->regmap, reg, mask, 0);
+}
+
+/**
+ * @brief bd71837_update_bits
+ * update bits in one register of bd71837
+ * @param bd71837 device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @param val value to update
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd71837_update_bits(struct bd71837 *bd71837, u8 reg,
+					   u8 mask, u8 val)
+{
+	return regmap_update_bits(bd71837->regmap, reg, mask, val);
+}
+
+/**
+ * @brief bd71837 platform data type
+ */
+struct bd71837_gpo_plat_data {
+	u32 drv;		///< gpo output drv
+	int gpio_base;		///< base gpio number in system
+};
+
+u8 ext_bd71837_reg_read8(u8 reg);
+int ext_bd71837_reg_write8(int reg, u8 val);
+
+#define BD71837_DBG0		0x0001
+#define BD71837_DBG1		0x0002
+#define BD71837_DBG2		0x0004
+#define BD71837_DBG3		0x0008
+
+extern unsigned int bd71837_debug_mask;
+#define bd71837_debug(debug, fmt, arg...) do { if (debug & bd71837_debug_mask) printk("BD71837:" fmt, ##arg); } while (0)
+
+#endif /* __LINUX_MFD_BD71837_H */
-- 
1.7.9.5


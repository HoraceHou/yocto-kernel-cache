From 1675b0e50794cfd0b340b0bdaed85b941da6ec6f Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@nxp.com>
Date: Wed, 9 Aug 2017 18:51:53 +0800
Subject: [PATCH 2376/5242] MLK-16197-1 video: fbdev: dcss: use non-cacheable
 mapping for cfifo buffer.

commit  9cb68649b5fc51748e97f4242ffb2bf945cf5132 from
https://source.codeaurora.org/external/imx/linux-imx.git

The kernel direct mapping for cfifo buffer is cacheable which
requires cache flush and is easier to bring in strange issue.
So use coherent dma mapping for cfifo buffer access. But the
kfifo dma sgl interface using the direct mapping to get the
phyiscal page via dma mapping virtual addr. So record fifo 'in'
for each commit which is used for context loader sb and db addr
configurations.

Signed-off-by: Fancy Fang <chen.fang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxc/imx_dcss.c |   12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/drivers/video/fbdev/mxc/imx_dcss.c b/drivers/video/fbdev/mxc/imx_dcss.c
index 92a4e7d..72adfb2 100644
--- a/drivers/video/fbdev/mxc/imx_dcss.c
+++ b/drivers/video/fbdev/mxc/imx_dcss.c
@@ -238,6 +238,7 @@ struct ctxld_commit {
 	struct list_head list;
 	struct work_struct work;
 	void *data;
+	uint32_t fifo_in;	/* kfifo's 'in' value */
 	uint32_t sb_data_len;
 	uint32_t sb_hp_data_len;
 	uint32_t db_data_len;
@@ -857,9 +858,7 @@ static int ctxld_fifo_alloc(struct device *dev,
 	}
 
 	cfifo->size = fifo_size;
-	kfifo_init(&cfifo->fifo,
-		   page_address(phys_to_page(dma_to_phys(dev, cfifo->dma_handle))),
-		   fifo_size);
+	kfifo_init(&cfifo->fifo, cfifo->vaddr, fifo_size);
 
 	/* TODO: sgl num can be changed if required */
 	cfifo->sgl_num = 1;
@@ -2404,7 +2403,7 @@ static void dcss_ctxld_config(struct work_struct *work)
 	/* configure sb buffer */
 	if (cc->sb_data_len) {
 		/* cfifo first store sb and than store db */
-		writel(phys_to_dma(&pdev->dev, sg_phys(cfifo->sgl)),
+		writel(cfifo->dma_handle + cc->fifo_in * kfifo_esize(&cfifo->fifo),
 		       info->base + chans->ctxld_addr + CTXLD_SB_BASE_ADDR);
 		writel(cc->sb_hp_data_len |
 		       (cc->sb_data_len - cc->sb_hp_data_len),
@@ -2481,6 +2480,8 @@ static int commit_to_fifo(uint32_t channel,
 
 	unit = (struct ctxld_unit *)cb->sb_addr;
 
+	cc->fifo_in = cfifo->fifo.kfifo.in & cfifo->fifo.kfifo.mask;
+
 	if (cb->sb_data_len) {
 		count = kfifo_in(&cfifo->fifo, cb->sb_addr, cb->sb_data_len);
 		if (count != cb->sb_data_len) {
@@ -2503,9 +2504,6 @@ static int commit_to_fifo(uint32_t channel,
 		cc->db_data_len = count;
 	}
 
-	/* TODO: this can be refined */
-	__dma_flush_area(cfifo->fifo.kfifo.data, cfifo->size);
-
 	ctxld_fifo_info_print(cfifo);
 
 	/* empty sb and db buffer */
-- 
1.7.9.5


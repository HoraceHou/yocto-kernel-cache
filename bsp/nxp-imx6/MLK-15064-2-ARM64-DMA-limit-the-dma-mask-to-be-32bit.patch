From 3a0ff7335a4b3701117f2e337e7a22878c9ab9e9 Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Mon, 19 Sep 2016 16:39:44 +0800
Subject: [PATCH 1946/5242] MLK-15064-2 ARM64: DMA: limit the dma mask to be
 32bit

commit  8d14f14eecbbaf951142f3bf91d843e7a0da1cc0 from
https://source.codeaurora.org/external/imx/linux-imx.git

Limit the dma mask to be 32bit, because that
the imx8 doesn't have the 64bit dma capapbility
although it is 64bit soc.

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
Reviewed-by: Frank Li <frank.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm64/mm/dma-mapping.c |   45 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 43 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c
index a5450e2..6294468 100644
--- a/arch/arm64/mm/dma-mapping.c
+++ b/arch/arm64/mm/dma-mapping.c
@@ -29,6 +29,7 @@
 #include <linux/vmalloc.h>
 #include <linux/swiotlb.h>
 #include <linux/pci.h>
+#include <linux/of.h>
 
 #include <asm/cacheflush.h>
 
@@ -332,7 +333,23 @@ static int __swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t addr)
 	return 0;
 }
 
-static const struct dma_map_ops arm64_swiotlb_dma_ops = {
+/*
+ * Some 64bit SoCs only support up to 32bit dma capability.
+ * Do quirk set here.
+ */
+static int __swiotlb_dma_supported_quirk(struct device *hwdev, u64 mask)
+{
+	if (mask > DMA_BIT_MASK(32)) {
+		pr_err("Can't support > 32 bit dma.\n");
+		return 0;
+	}
+
+	if (swiotlb)
+		return swiotlb_dma_supported(hwdev, mask);
+	return 1;
+}
+
+static struct dma_map_ops arm64_swiotlb_dma_ops = {
 	.alloc = __dma_alloc,
 	.free = __dma_free,
 	.mmap = __swiotlb_mmap,
@@ -811,7 +828,7 @@ static void __iommu_unmap_sg_attrs(struct device *dev,
 	iommu_dma_unmap_sg(dev, sgl, nelems, dir, attrs);
 }
 
-static const struct dma_map_ops iommu_dma_ops = {
+static struct dma_map_ops iommu_dma_ops = {
 	.alloc = __iommu_alloc_attrs,
 	.free = __iommu_free_attrs,
 	.mmap = __iommu_mmap_attrs,
@@ -871,6 +888,15 @@ void arch_teardown_dma_ops(struct device *dev)
 	dev->dma_ops = NULL;
 }
 
+static int iommu_dma_supported_quirk(struct device *dev, u64 mask)
+{
+	if (mask > DMA_BIT_MASK(32)) {
+		pr_err("Can't support > 32 bit dma.\n");
+		return 0;
+	}
+
+	return 1;
+}
 #else
 
 static void __iommu_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
@@ -882,6 +908,9 @@ static void __iommu_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 			const struct iommu_ops *iommu, bool coherent)
 {
+	u32 mask32;
+	struct device_node *np;
+
 	if (!dev->dma_ops)
 		dev->dma_ops = &arm64_swiotlb_dma_ops;
 
@@ -894,4 +923,16 @@ void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 		dev->dma_ops = xen_dma_ops;
 	}
 #endif
+
+	np = of_find_compatible_node(NULL, NULL, "dma-capability");
+	if (np == NULL)
+		return;
+	if (of_property_read_u32(np, "only-dma-mask32", &mask32))
+		mask32 = 0;
+	if (mask32) {
+		swiotlb_dma_ops.dma_supported = __swiotlb_dma_supported_quirk;
+#ifdef CONFIG_IOMMU_DMA
+		iommu_dma_ops.dma_supported = iommu_dma_supported_quirk;
+#endif
+	}
 }
-- 
1.7.9.5


From 6cac32643941ac4aa783fc9189fa59710bca740e Mon Sep 17 00:00:00 2001
From: Bai Ping <b51503@freescale.com>
Date: Tue, 14 Oct 2014 10:17:16 +0800
Subject: [PATCH 0506/5242] MLK-9678 arm: imx6: switch to analog bypass before
 entering DSM

commit  ad198d06b9a74b91e3d5dcb85641c5a28a56f292 from
https://source.codeaurora.org/external/imx/linux-imx.git

this patch implements the workaround for ERR005852:

ERR005852 Analog: Transition from Deep Sleep Mode to LDO Bypass
Mode may cause the slow response of the VDDARM_CAP output.

    Normally, the VDDARM_CAP supply takes only approximately 40 us
    to raise to the correct voltage when exiting from Deep Sleep(DSM)
    mode, if the LDO is enabled. If the LDO bypass mode is selected,
    the VDDARM_CAP supply voltage will drop to approximately 0V when
    entering and when exiting from DSM,even though the VDDARM_IN
    supply is already stable, the VDDARM_CAP supply will take about
    2 ms to rise to the correct voltage.

software workaround:

if internal LDO bypass, switch to analog bypass mode(0x1E), prior
to entering DSM, and then, revert to the normal bypass mode, when
exiting from DSM.

Signed-off-by: Bai Ping <b51503@freescale.com>
(cherry picked from commit e43b7ad7c9b8fa987daa539543c5060c97922eb2)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/suspend-imx6.S |   42 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/arch/arm/mach-imx/suspend-imx6.S b/arch/arm/mach-imx/suspend-imx6.S
index e34fdc3..bb3a309 100644
--- a/arch/arm/mach-imx/suspend-imx6.S
+++ b/arch/arm/mach-imx/suspend-imx6.S
@@ -77,6 +77,7 @@
 #define MX6Q_GPC_IMR3	0x10
 #define MX6Q_GPC_IMR4	0x14
 #define MX6Q_CCM_CCR	0x0
+#define MX6Q_ANATOP_CORE	0x140
 
 	.align 3
 
@@ -581,6 +582,27 @@ rbc_loop:
 	subs	r6, r6, #0x1
 	bne	rbc_loop
 
+	/*
+	 * ERR005852 Analog: Transition from Deep Sleep Mode to
+	 * LDO Bypass Mode may cause the slow response of the
+	 * VDDARM_CAP output.
+	 *
+	 * Software workaround:
+	 * if internal ldo(VDDARM) bypassed, switch to analog bypass
+	 * mode (0x1E), prio to entering DSM, and then, revert to the
+	 * normal bypass mode, when exiting from DSM.
+	 */
+	ldr	r11, [r0, #PM_INFO_MX6Q_ANATOP_V_OFFSET]
+	ldr	r10, [r11, #MX6Q_ANATOP_CORE]
+	and	r10, r10, #0x1f
+	cmp	r10, #0x1f
+	bne	ldo_check_done1
+ldo_analog_bypass:
+	ldr	r10, [r11, #MX6Q_ANATOP_CORE]
+	bic	r10, r10, #0x1f
+	orr	r10, r10, #0x1e
+	str	r10, [r11, #MX6Q_ANATOP_CORE]
+ldo_check_done1:
 	/* Zzz, enter stop mode */
 	wfi
 	nop
@@ -593,6 +615,16 @@ rbc_loop:
 	 * wakeup source, system should auto
 	 * resume, we need to restore MMDC IO first
 	 */
+	/* restore it with 0x1f if use ldo bypass mode.*/
+	ldr	r10, [r11, #MX6Q_ANATOP_CORE]
+	and	r10, r10, #0x1f
+	cmp	r10, #0x1e
+	bne	ldo_check_done2
+ldo_bypass_restore:
+	ldr	r10, [r11, #MX6Q_ANATOP_CORE]
+	orr	r10, r10, #0x1f
+	str	r10, [r11, #MX6Q_ANATOP_CORE]
+ldo_check_done2:
 	mov	r5, #0x0
 	/* check whether it supports Mega/Fast off */
 	ldr	r6, [r0, #PM_INFO_MMDC_NUM_OFFSET]
@@ -619,6 +651,16 @@ resume:
 	mcr     p15, 0, r6, c1, c0, 0
 	isb
 
+	/* restore it with 0x1f if use ldo bypass mode.*/
+	ldr	r11, [r0, #PM_INFO_MX6Q_ANATOP_P_OFFSET]
+	ldr	r7, [r11, #MX6Q_ANATOP_CORE]
+	and	r7, r7, #0x1f
+	cmp	r7, #0x1e
+	bne	ldo_check_done3
+	ldr	r7, [r11, #MX6Q_ANATOP_CORE]
+	orr	r7, r7, #0x1f
+	str	r7, [r11, #MX6Q_ANATOP_CORE]
+ldo_check_done3:
 	/* get physical resume address from pm_info. */
 	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]
 	/* clear core0's entry and parameter */
-- 
1.7.9.5


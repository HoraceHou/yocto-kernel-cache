From 548541bbd541ffc0626c8cc990cacbdaaddebb20 Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Thu, 27 Jul 2017 07:33:42 +0800
Subject: [PATCH 2296/5242] MLK-16013-17 staging: typec: tcpm: optimise cc
 toggling for drp port

commit  5e217b1604c23ffcd7eca4f677692d1ad289ff1a from
https://source.codeaurora.org/external/imx/linux-imx.git

We should only enable drp auto toggling when unattached, so add one
more parameter; when attached, we set the cc line state according to
the other end cc status.

Reviewed-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/staging/typec/tcpci.c |   85 ++++++++++++++++++++++++++++++++---------
 drivers/usb/typec/tcpm.c      |   26 ++++++++++---
 include/linux/usb/tcpm.h      |    2 +-
 3 files changed, 89 insertions(+), 24 deletions(-)

diff --git a/drivers/staging/typec/tcpci.c b/drivers/staging/typec/tcpci.c
index 9a54028..854bdd2 100644
--- a/drivers/staging/typec/tcpci.c
+++ b/drivers/staging/typec/tcpci.c
@@ -126,11 +126,11 @@ static int tcpci_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)
 }
 
 static int tcpci_start_drp_toggling(struct tcpc_dev *tcpc,
-				    enum typec_cc_status cc)
+				enum typec_cc_status cc, int attach)
 {
 	int ret;
 	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg = TCPC_ROLE_CTRL_DRP;
+	unsigned int reg = 0;
 
 	/* Handle vendor drp toggling */
 	if (tcpci->data->start_drp_toggling) {
@@ -139,20 +139,66 @@ static int tcpci_start_drp_toggling(struct tcpc_dev *tcpc,
 			return ret;
 	}
 
-	switch (cc) {
-	default:
-	case TYPEC_CC_RP_DEF:
-		reg |= (TCPC_ROLE_CTRL_RP_VAL_DEF <<
-			TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_RP_1_5:
-		reg |= (TCPC_ROLE_CTRL_RP_VAL_1_5 <<
-			TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_RP_3_0:
-		reg |= (TCPC_ROLE_CTRL_RP_VAL_3_0 <<
-			TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
+	/* Only set DRP bit for auto toggle when unattached */
+	if (attach) {
+		switch (cc) {
+		case TYPEC_CC_RP_DEF:
+			if (attach >> TYPEC_POLARITY_CC2)
+				reg |= TCPC_ROLE_CTRL_CC_RP <<
+					TCPC_ROLE_CTRL_CC2_SHIFT;
+			else if (attach >> TYPEC_POLARITY_CC1)
+				reg |= TCPC_ROLE_CTRL_CC_RP <<
+					TCPC_ROLE_CTRL_CC1_SHIFT;
+
+			reg |= (TCPC_ROLE_CTRL_RP_VAL_DEF <<
+				TCPC_ROLE_CTRL_RP_VAL_SHIFT);
+			break;
+		case TYPEC_CC_RP_1_5:
+			if (attach >> TYPEC_POLARITY_CC2)
+				reg |= TCPC_ROLE_CTRL_CC_RP <<
+					TCPC_ROLE_CTRL_CC2_SHIFT;
+			else if (attach >> TYPEC_POLARITY_CC1)
+				reg |= TCPC_ROLE_CTRL_CC_RP <<
+					TCPC_ROLE_CTRL_CC1_SHIFT;
+
+			reg |= (TCPC_ROLE_CTRL_RP_VAL_1_5 <<
+				TCPC_ROLE_CTRL_RP_VAL_SHIFT);
+			break;
+		case TYPEC_CC_RP_3_0:
+			if (attach >> TYPEC_POLARITY_CC2)
+				reg |= TCPC_ROLE_CTRL_CC_RP <<
+					TCPC_ROLE_CTRL_CC2_SHIFT;
+			else if (attach >> TYPEC_POLARITY_CC1)
+				reg |= TCPC_ROLE_CTRL_CC_RP <<
+					TCPC_ROLE_CTRL_CC1_SHIFT;
+
+			reg |= (TCPC_ROLE_CTRL_RP_VAL_3_0 <<
+				TCPC_ROLE_CTRL_RP_VAL_SHIFT);
+			break;
+		case TYPEC_CC_RD:
+			if (attach >> TYPEC_POLARITY_CC2)
+				reg |= TCPC_ROLE_CTRL_CC_RD <<
+					TCPC_ROLE_CTRL_CC2_SHIFT;
+			else if (attach >> TYPEC_POLARITY_CC1)
+				reg |= TCPC_ROLE_CTRL_CC_RD <<
+					TCPC_ROLE_CTRL_CC1_SHIFT;
+			break;
+		default:
+			break;
+		}
+
+		/* keep the un-touched cc line to be open */
+		if (attach >> TYPEC_POLARITY_CC2)
+			reg |= TCPC_ROLE_CTRL_CC_OPEN <<
+				TCPC_ROLE_CTRL_CC1_SHIFT;
+		else if (attach >> TYPEC_POLARITY_CC1)
+			reg |= TCPC_ROLE_CTRL_CC_OPEN <<
+				TCPC_ROLE_CTRL_CC2_SHIFT;
+	} else { /* Not attached */
+		if (cc == TYPEC_CC_RD)
+			reg = TCPC_ROLE_CTRL_DRP | 0xa; /* Rd */
+		else
+			reg = TCPC_ROLE_CTRL_DRP | 0x5; /* Rp */
 	}
 
 	if (cc == TYPEC_CC_RD)
@@ -164,8 +210,11 @@ static int tcpci_start_drp_toggling(struct tcpc_dev *tcpc,
 	ret = regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);
 	if (ret < 0)
 		return ret;
-	return regmap_write(tcpci->regmap, TCPC_COMMAND,
-			    TCPC_CMD_LOOK4CONNECTION);
+
+	if (!attach)
+		regmap_write(tcpci->regmap, TCPC_COMMAND,
+				TCPC_CMD_LOOK4CONNECTION);
+	return 0;
 }
 
 static enum typec_cc_status tcpci_to_typec_cc(unsigned int cc, bool sink)
diff --git a/drivers/usb/typec/tcpm.c b/drivers/usb/typec/tcpm.c
index edbc4b4..10718de 100644
--- a/drivers/usb/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -2438,13 +2438,25 @@ static int tcpm_set_charge(struct tcpm_port *port, bool charge)
 
 static bool tcpm_start_drp_toggling(struct tcpm_port *port)
 {
-	int ret;
+	int ret = 0;
+
+	tcpm_log(port, "Start DRP toggling");
 
+	/* First toggle Rp if current state is SNK_UNATTACHED */
 	if (port->tcpc->start_drp_toggling &&
-	    port->port_type == TYPEC_PORT_DRP) {
-		tcpm_log_force(port, "Start DRP toggling");
-		ret = port->tcpc->start_drp_toggling(port->tcpc,
-						     tcpm_rp_cc(port));
+		port->port_type == TYPEC_PORT_DRP) {
+		if (port->state == SRC_UNATTACHED)
+			ret = port->tcpc->start_drp_toggling(port->tcpc,
+						tcpm_rp_cc(port), 0);
+		else if (port->state == SNK_UNATTACHED)
+			ret = port->tcpc->start_drp_toggling(port->tcpc,
+						TYPEC_CC_RD, 0);
+		else if (port->state == SRC_ATTACHED)
+			ret = port->tcpc->start_drp_toggling(port->tcpc,
+				tcpm_rp_cc(port), 0x1 << port->polarity);
+		else if (port->state == SNK_ATTACHED)
+			ret = port->tcpc->start_drp_toggling(port->tcpc,
+				TYPEC_CC_RD, 0x1 << port->polarity);
 		if (!ret)
 			return true;
 	}
@@ -2510,6 +2522,8 @@ static int tcpm_src_attach(struct tcpm_port *port)
 	if (ret < 0)
 		return ret;
 
+	tcpm_start_drp_toggling(port);
+
 	ret = tcpm_set_roles(port, true, TYPEC_SOURCE, TYPEC_HOST);
 	if (ret < 0)
 		return ret;
@@ -2632,6 +2646,8 @@ static int tcpm_snk_attach(struct tcpm_port *port)
 	if (ret < 0)
 		return ret;
 
+	tcpm_start_drp_toggling(port);
+
 	ret = tcpm_set_roles(port, true, TYPEC_SINK, TYPEC_DEVICE);
 	if (ret < 0)
 		return ret;
diff --git a/include/linux/usb/tcpm.h b/include/linux/usb/tcpm.h
index 4737961..e2311ba 100644
--- a/include/linux/usb/tcpm.h
+++ b/include/linux/usb/tcpm.h
@@ -154,7 +154,7 @@ struct tcpc_dev {
 	int (*set_roles)(struct tcpc_dev *dev, bool attached,
 			 enum typec_role role, enum typec_data_role data);
 	int (*start_drp_toggling)(struct tcpc_dev *dev,
-				  enum typec_cc_status cc);
+				  enum typec_cc_status cc, int attach);
 	int (*try_role)(struct tcpc_dev *dev, int role);
 	int (*pd_transmit)(struct tcpc_dev *dev, enum tcpm_transmit_type type,
 			   const struct pd_message *msg);
-- 
1.7.9.5


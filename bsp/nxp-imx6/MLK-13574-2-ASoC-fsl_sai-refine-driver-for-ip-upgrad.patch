From 0dd838ae2afb201afcfe77f32e183fccb8c36f1c Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@freescale.com>
Date: Mon, 28 Nov 2016 13:38:13 +0800
Subject: [PATCH 1319/5242] MLK-13574-2: ASoC: fsl_sai: refine driver for ip
 upgrade

commit  337d59e9b46d09e11b673cfb605e359f50dc02ca from
https://source.codeaurora.org/external/imx/linux-imx.git

In imx7ulp1, the sai can support two TX channel and two RX
channels, So the usage need to be updated.

Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_sai.c |  157 ++++++++++++++++++++++++++++++++++++++---------
 sound/soc/fsl/fsl_sai.h |   38 ++++++++++--
 2 files changed, 160 insertions(+), 35 deletions(-)

diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 9278f6e..8c12fa0 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -9,11 +9,13 @@
 #include <linux/delay.h>
 #include <linux/dmaengine.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/of_address.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/pm_qos.h>
 #include <sound/core.h>
 #include <sound/dmaengine_pcm.h>
 #include <sound/pcm_params.h>
@@ -26,6 +28,39 @@
 #define FSL_SAI_FLAGS (FSL_SAI_CSR_SEIE |\
 		       FSL_SAI_CSR_FEIE)
 
+static struct fsl_sai_soc_data fsl_sai_vf610 = {
+	.imx = false,
+	/*dataline is mask, not index*/
+	.dataline = 0x1,
+	.fifos = 1,
+	.fifo_depth = 32,
+	.flags = 0,
+};
+
+static struct fsl_sai_soc_data fsl_sai_imx6sx = {
+	.imx = true,
+	.dataline = 0x1,
+	.fifos = 1,
+	.fifo_depth = 32,
+	.flags = 0,
+};
+
+static struct fsl_sai_soc_data fsl_sai_imx6ul = {
+	.imx = true,
+	.dataline = 0x1,
+	.fifos = 1,
+	.fifo_depth = 32,
+	.flags = 0,
+};
+
+static struct fsl_sai_soc_data fsl_sai_imx7ulp = {
+	.imx = true,
+	.dataline = 0x3,
+	.fifos = 2,
+	.fifo_depth = 16,
+	.flags = SAI_FLAG_PMQOS,
+};
+
 static const unsigned int fsl_sai_rates[] = {
 	8000, 11025, 12000, 16000, 22050,
 	24000, 32000, 44100, 48000, 64000,
@@ -504,6 +539,29 @@ static int fsl_sai_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	if (sai->soc->dataline != 0x1) {
+		switch (sai->dataline[tx]) {
+		case 0x0:
+			break;
+		case 0x1:
+			regmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),
+				FSL_SAI_CR4_FCOMB_SOFT | FSL_SAI_CR4_FCOMB_SHIFT, 0);
+			break;
+		case 0x2:
+			regmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),
+				FSL_SAI_CR4_FCOMB_SOFT | FSL_SAI_CR4_FCOMB_SHIFT,
+				FSL_SAI_CR4_FCOMB_SOFT | FSL_SAI_CR4_FCOMB_SHIFT);
+			break;
+		case 0x3:
+			regmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),
+				FSL_SAI_CR4_FCOMB_SOFT | FSL_SAI_CR4_FCOMB_SHIFT,
+				FSL_SAI_CR4_FCOMB_SOFT);
+			break;
+		default:
+			break;
+		}
+	}
+
 	regmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),
 			   FSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,
 			   val_cr4);
@@ -562,14 +620,16 @@ static int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,
 				   FSL_SAI_CSR_FRDE, FSL_SAI_CSR_FRDE);
 
 		for (i = 0; tx && i < channels; i++)
-			regmap_write(sai->regmap, FSL_SAI_TDR, 0x0);
+			regmap_write(sai->regmap, FSL_SAI_TDR0, 0x0);
 		if (tx)
 			udelay(10);
 
-		regmap_update_bits(sai->regmap, FSL_SAI_RCSR,
-				   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);
 		regmap_update_bits(sai->regmap, FSL_SAI_TCSR,
 				   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);
+		regmap_update_bits(sai->regmap, FSL_SAI_RCSR,
+				   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);
+		regmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),
+				   FSL_SAI_CSR_SE, FSL_SAI_CSR_SE);
 
 		regmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),
 				   FSL_SAI_CSR_xIE_MASK, FSL_SAI_FLAGS);
@@ -649,8 +709,8 @@ static int fsl_sai_startup(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
-	regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE,
-			   FSL_SAI_CR3_TRCE);
+	regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE0|FSL_SAI_CR3_TRCE1,
+			   FSL_SAI_CR3_TRCE(sai->dataline[tx]));
 
 	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
 			SNDRV_PCM_HW_PARAM_RATE, &fsl_sai_rate_constraints);
@@ -665,7 +725,7 @@ static void fsl_sai_shutdown(struct snd_pcm_substream *substream,
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
 	if (sai->is_stream_opened[tx]) {
-		regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE, 0);
+		regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE0 | FSL_SAI_CR3_TRCE1, 0);
 		clk_disable_unprepare(sai->bus_clk);
 		sai->is_stream_opened[tx] = false;
 		pm_runtime_put_sync(cpu_dai->dev);
@@ -695,7 +755,7 @@ static int fsl_sai_dai_probe(struct snd_soc_dai *cpu_dai)
 	regmap_write(sai->regmap, FSL_SAI_RCSR, 0);
 
 	regmap_update_bits(sai->regmap, FSL_SAI_TCR1, FSL_SAI_CR1_RFW_MASK,
-			   FSL_SAI_MAXBURST_TX * 2);
+			   sai->soc->fifo_depth - FSL_SAI_MAXBURST_TX);
 	regmap_update_bits(sai->regmap, FSL_SAI_RCR1, FSL_SAI_CR1_RFW_MASK,
 			   FSL_SAI_MAXBURST_RX - 1);
 
@@ -740,7 +800,8 @@ static int fsl_sai_dai_probe(struct snd_soc_dai *cpu_dai)
 	{FSL_SAI_TCR3, 0},
 	{FSL_SAI_TCR4, 0},
 	{FSL_SAI_TCR5, 0},
-	{FSL_SAI_TDR,  0},
+	{FSL_SAI_TDR0, 0},
+	{FSL_SAI_TDR1, 0},
 	{FSL_SAI_TMR,  0},
 	{FSL_SAI_RCR1, 0},
 	{FSL_SAI_RCR2, 0},
@@ -759,7 +820,8 @@ static bool fsl_sai_readable_reg(struct device *dev, unsigned int reg)
 	case FSL_SAI_TCR3:
 	case FSL_SAI_TCR4:
 	case FSL_SAI_TCR5:
-	case FSL_SAI_TFR:
+	case FSL_SAI_TFR0:
+	case FSL_SAI_TFR1:
 	case FSL_SAI_TMR:
 	case FSL_SAI_RCSR:
 	case FSL_SAI_RCR1:
@@ -767,8 +829,10 @@ static bool fsl_sai_readable_reg(struct device *dev, unsigned int reg)
 	case FSL_SAI_RCR3:
 	case FSL_SAI_RCR4:
 	case FSL_SAI_RCR5:
-	case FSL_SAI_RDR:
-	case FSL_SAI_RFR:
+	case FSL_SAI_RDR0:
+	case FSL_SAI_RDR1:
+	case FSL_SAI_RFR0:
+	case FSL_SAI_RFR1:
 	case FSL_SAI_RMR:
 		return true;
 	default:
@@ -781,9 +845,12 @@ static bool fsl_sai_volatile_reg(struct device *dev, unsigned int reg)
 	switch (reg) {
 	case FSL_SAI_TCSR:
 	case FSL_SAI_RCSR:
-	case FSL_SAI_TFR:
-	case FSL_SAI_RFR:
-	case FSL_SAI_RDR:
+	case FSL_SAI_TFR0:
+	case FSL_SAI_TFR1:
+	case FSL_SAI_RFR0:
+	case FSL_SAI_RFR1:
+	case FSL_SAI_RDR0:
+	case FSL_SAI_RDR1:
 		return true;
 	default:
 		return false;
@@ -799,7 +866,8 @@ static bool fsl_sai_writeable_reg(struct device *dev, unsigned int reg)
 	case FSL_SAI_TCR3:
 	case FSL_SAI_TCR4:
 	case FSL_SAI_TCR5:
-	case FSL_SAI_TDR:
+	case FSL_SAI_TDR0:
+	case FSL_SAI_TDR1:
 	case FSL_SAI_TMR:
 	case FSL_SAI_RCSR:
 	case FSL_SAI_RCR1:
@@ -828,9 +896,19 @@ static bool fsl_sai_writeable_reg(struct device *dev, unsigned int reg)
 	.cache_type = REGCACHE_FLAT,
 };
 
+static const struct of_device_id fsl_sai_ids[] = {
+	{ .compatible = "fsl,vf610-sai", .data = &fsl_sai_vf610 },
+	{ .compatible = "fsl,imx6sx-sai", .data = &fsl_sai_imx6sx },
+	{ .compatible = "fsl,imx6ul-sai", .data = &fsl_sai_imx6ul },
+	{ .compatible = "fsl,imx7ulp-sai", .data = &fsl_sai_imx7ulp },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, fsl_sai_ids);
+
 static int fsl_sai_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
 	struct fsl_sai *sai;
 	struct regmap *gpr;
 	struct resource *res;
@@ -846,11 +924,12 @@ static int fsl_sai_probe(struct platform_device *pdev)
 
 	sai->pdev = pdev;
 
-	if (of_device_is_compatible(np, "fsl,imx6sx-sai") ||
-	    of_device_is_compatible(np, "fsl,imx6ul-sai"))
-		sai->sai_on_imx = true;
+	of_id = of_match_device(fsl_sai_ids, &pdev->dev);
+	if (!of_id || !of_id->data)
+		return -EINVAL;
 
 	sai->is_lsb_first = of_property_read_bool(np, "lsb-first");
+	sai->soc = of_id->data;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(&pdev->dev, res);
@@ -882,11 +961,25 @@ static int fsl_sai_probe(struct platform_device *pdev)
 		sai->mclk_clk[i] = devm_clk_get(&pdev->dev, tmp);
 		if (IS_ERR(sai->mclk_clk[i])) {
 			dev_err(&pdev->dev, "failed to get mclk%d clock: %ld\n",
-					i + 1, PTR_ERR(sai->mclk_clk[i]));
+					i, PTR_ERR(sai->mclk_clk[i]));
 			sai->mclk_clk[i] = NULL;
 		}
 	}
 
+	/*dataline mask for rx and tx*/
+	ret = of_property_read_u32_index(np, "fsl,dataline", 0, &sai->dataline[0]);
+	if (ret)
+		sai->dataline[0] = 1;
+
+	ret = of_property_read_u32_index(np, "fsl,dataline", 1, &sai->dataline[1]);
+	if (ret)
+		sai->dataline[1] = 1;
+
+	if ((sai->dataline[0] & (~sai->soc->dataline)) || sai->dataline[1] & (~sai->soc->dataline)) {
+		dev_err(&pdev->dev, "dataline setting error, Mask is 0x%x\n", sai->soc->dataline);
+		return -EINVAL;
+	}
+
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "no irq for node %s\n", pdev->name);
@@ -942,8 +1035,8 @@ static int fsl_sai_probe(struct platform_device *pdev)
 				   MCLK_DIR(index));
 	}
 
-	sai->dma_params_rx.addr = res->start + FSL_SAI_RDR;
-	sai->dma_params_tx.addr = res->start + FSL_SAI_TDR;
+	sai->dma_params_rx.addr = res->start + FSL_SAI_RDR0;
+	sai->dma_params_tx.addr = res->start + FSL_SAI_TDR0;
 	sai->dma_params_rx.maxburst = FSL_SAI_MAXBURST_RX;
 	sai->dma_params_tx.maxburst = FSL_SAI_MAXBURST_TX;
 
@@ -959,30 +1052,34 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	if (of_property_read_u32(np, "fsl,dma-buffer-size", &buffer_size))
 		buffer_size = IMX_SAI_DMABUF_SIZE;
 
-	if (sai->sai_on_imx)
+	if (sai->soc->imx)
 		return imx_pcm_dma_init(pdev, buffer_size);
 	else
 		return devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 }
 
-static const struct of_device_id fsl_sai_ids[] = {
-	{ .compatible = "fsl,vf610-sai", },
-	{ .compatible = "fsl,imx6sx-sai", },
-	{ .compatible = "fsl,imx6ul-sai", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, fsl_sai_ids);
-
 #ifdef CONFIG_PM
 static int fsl_sai_runtime_resume(struct device *dev)
 {
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+
 	request_bus_freq(BUS_FREQ_AUDIO);
+
+	if (sai->soc->flags & SAI_FLAG_PMQOS)
+		pm_qos_add_request(&sai->pm_qos_req,
+				PM_QOS_CPU_DMA_LATENCY, 0);
 	return 0;
 }
 
 static int fsl_sai_runtime_suspend(struct device *dev)
 {
+	struct fsl_sai *sai = dev_get_drvdata(dev);
+
 	release_bus_freq(BUS_FREQ_AUDIO);
+
+	if (sai->soc->flags & SAI_FLAG_PMQOS)
+		pm_qos_remove_request(&sai->pm_qos_req);
+
 	return 0;
 }
 #endif
diff --git a/sound/soc/fsl/fsl_sai.h b/sound/soc/fsl/fsl_sai.h
index 80ccbaa..ab1b103 100644
--- a/sound/soc/fsl/fsl_sai.h
+++ b/sound/soc/fsl/fsl_sai.h
@@ -1,11 +1,12 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright 2012-2016 Freescale Semiconductor, Inc.
  */
 
 #ifndef __FSL_SAI_H
 #define __FSL_SAI_H
 
+#include <linux/pm_qos.h>
 #include <sound/dmaengine_pcm.h>
 
 #define FSL_SAI_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
@@ -20,8 +21,10 @@
 #define FSL_SAI_TCR3	0x0c /* SAI Transmit Configuration 3 */
 #define FSL_SAI_TCR4	0x10 /* SAI Transmit Configuration 4 */
 #define FSL_SAI_TCR5	0x14 /* SAI Transmit Configuration 5 */
-#define FSL_SAI_TDR	0x20 /* SAI Transmit Data */
-#define FSL_SAI_TFR	0x40 /* SAI Transmit FIFO */
+#define FSL_SAI_TDR0    0x20 /* SAI Transmit Data */
+#define FSL_SAI_TDR1    0x24 /* SAI Transmit Data */
+#define FSL_SAI_TFR0    0x40 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR1    0x44 /* SAI Transmit FIFO */
 #define FSL_SAI_TMR	0x60 /* SAI Transmit Mask */
 #define FSL_SAI_RCSR	0x80 /* SAI Receive Control */
 #define FSL_SAI_RCR1	0x84 /* SAI Receive Configuration 1 */
@@ -29,7 +32,10 @@
 #define FSL_SAI_RCR3	0x8c /* SAI Receive Configuration 3 */
 #define FSL_SAI_RCR4	0x90 /* SAI Receive Configuration 4 */
 #define FSL_SAI_RCR5	0x94 /* SAI Receive Configuration 5 */
-#define FSL_SAI_RDR	0xa0 /* SAI Receive Data */
+#define FSL_SAI_RDR0    0xa0 /* SAI Receive Data */
+#define FSL_SAI_RDR1    0xa4 /* SAI Receive Data */
+#define FSL_SAI_RFR0    0xc0 /* SAI Receive FIFO */
+#define FSL_SAI_RFR1    0xc4 /* SAI Receive FIFO */
 #define FSL_SAI_RFR	0xc0 /* SAI Receive FIFO */
 #define FSL_SAI_RMR	0xe0 /* SAI Receive Mask */
 
@@ -45,6 +51,7 @@
 
 /* SAI Transmit/Receive Control Register */
 #define FSL_SAI_CSR_TERE	BIT(31)
+#define FSL_SAI_CSR_SE		BIT(30)
 #define FSL_SAI_CSR_FR		BIT(25)
 #define FSL_SAI_CSR_SR		BIT(24)
 #define FSL_SAI_CSR_xF_SHIFT	16
@@ -81,11 +88,19 @@
 #define FSL_SAI_CR2_DIV_MASK	0xff
 
 /* SAI Transmit and Receive Configuration 3 Register */
-#define FSL_SAI_CR3_TRCE	BIT(16)
+#define FSL_SAI_CR3_TRCE0	BIT(16)
+#define FSL_SAI_CR3_TRCE1	BIT(17)
+#define FSL_SAI_CR3_TRCE(x)	(x << 16)
 #define FSL_SAI_CR3_WDFL(x)	(x)
 #define FSL_SAI_CR3_WDFL_MASK	0x1f
 
 /* SAI Transmit and Receive Configuration 4 Register */
+
+#define FSL_SAI_CR4_FCONT	BIT(28)
+#define FSL_SAI_CR4_FCOMB_SHIFT BIT(26)
+#define FSL_SAI_CR4_FCOMB_SOFT  BIT(27)
+#define FSL_SAI_CR4_FPACK_8     (0x2 << 24)
+#define FSL_SAI_CR4_FPACK_16    (0x3 << 24)
 #define FSL_SAI_CR4_FRSZ(x)	(((x) - 1) << 16)
 #define FSL_SAI_CR4_FRSZ_MASK	(0x1f << 16)
 #define FSL_SAI_CR4_SYWD(x)	(((x) - 1) << 8)
@@ -126,6 +141,16 @@
 #define FSL_SAI_MAXBURST_TX 6
 #define FSL_SAI_MAXBURST_RX 6
 
+#define SAI_FLAG_PMQOS   BIT(0)
+
+struct fsl_sai_soc_data {
+	unsigned int fifo_depth;
+	unsigned int fifos;
+	unsigned int dataline;
+	unsigned int flags;
+	bool imx;
+};
+
 struct fsl_sai {
 	struct platform_device *pdev;
 	struct regmap *regmap;
@@ -138,6 +163,7 @@ struct fsl_sai {
 	bool sai_on_imx;
 	bool synchronous[2];
 	bool is_stream_opened[2];
+	unsigned int dataline[2];
 
 	unsigned int mclk_id[2];
 	unsigned int mclk_streams;
@@ -146,6 +172,8 @@ struct fsl_sai {
 
 	struct snd_dmaengine_dai_dma_data dma_params_rx;
 	struct snd_dmaengine_dai_dma_data dma_params_tx;
+	const struct fsl_sai_soc_data *soc;
+	struct pm_qos_request pm_qos_req;
 };
 
 #define TX 1
-- 
1.7.9.5


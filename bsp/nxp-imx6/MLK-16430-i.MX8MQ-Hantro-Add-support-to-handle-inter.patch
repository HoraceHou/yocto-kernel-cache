From 189377a8b79ab31e8b26b3db5cb2b18eb8c6c6c5 Mon Sep 17 00:00:00 2001
From: Zhou Peng-B04994 <eagle.zhou@nxp.com>
Date: Mon, 11 Sep 2017 11:54:58 +0800
Subject: [PATCH 2525/5242] MLK-16430 : [i.MX8MQ/Hantro]: Add support to
 handle interrupt timeout

commit  cfc159cbe0a73526371323fac9cdabcb3c05f293 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add support to handle interrupt timeout.
decoder won't be blocked and will report timeout event to application
when no any interrupts are triggered.

Signed-off-by: Zhou Peng-B04994 <eagle.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/hantro/hantrodec.c |   27 +++++++++++++++++++++++++--
 1 file changed, 25 insertions(+), 2 deletions(-)

diff --git a/drivers/mxc/hantro/hantrodec.c b/drivers/mxc/hantro/hantrodec.c
index c06f3c7..53c0e0e 100755
--- a/drivers/mxc/hantro/hantrodec.c
+++ b/drivers/mxc/hantro/hantrodec.c
@@ -201,6 +201,7 @@
 #define DWL_CLIENT_TYPE_HEVC_DEC         12U
 
 static u32 cfg[HXDEC_MAX_CORES];
+static u32 timeout;
 
 static int hantro_clk_enable(struct device *dev)
 {
@@ -636,6 +637,15 @@ long DecRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 		for (i = HANTRO_DEC_EXT_FIRST_REG; i <= HANTRO_DEC_EXT_LAST_REG; i++)
 			dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
 #endif
+
+		if (timeout) {
+			/* Enable TIMEOUT bits in Reg[1] */
+			dec_regs[id][1] = 0x40100;
+			/* Reset HW */
+			ResetAsic(dev);
+			timeout = 0;
+		}
+
 		/* put registers to user space*/
 		/* put original registers to user space*/
 		ret = copy_to_user(Core->regs, dec_regs[id], HANTRO_DEC_ORG_REGS*4);
@@ -657,6 +667,14 @@ long DecRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 		for (i = 0; i <= HANTRO_G2_DEC_LAST_REG; i++)
 			dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
 
+		if (timeout) {
+			/* Enable TIMEOUT bits in Reg[1] */
+			dec_regs[id][1] = 0x40100;
+			/* Reset HW */
+			ResetAsic(dev);
+			timeout = 0;
+		}
+
 		/* put registers to user space*/
 		ret = copy_to_user(Core->regs, dec_regs[id], HANTRO_G2_DEC_REGS*4);
 		if (ret) {
@@ -690,12 +708,17 @@ static int CheckDecIrq(hantrodec_t *dev, int id)
 long WaitDecReadyAndRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 {
 	u32 id = Core->id;
+	long ret;
 
 	PDEBUG("wait_event_interruptible DEC[%d]\n", id);
 
-	if (wait_event_interruptible(dec_wait_queue, CheckDecIrq(dev, id))) {
+	ret = wait_event_interruptible_timeout(dec_wait_queue, CheckDecIrq(dev, id), msecs_to_jiffies(200));
+	if (ret == -ERESTARTSYS) {
 		pr_err("DEC[%d]  failed to wait_event_interruptible interrupted\n", id);
 		return -ERESTARTSYS;
+	} else if (ret == 0) {
+		pr_err("DEC[%d]  wait_event_interruptible timeout\n", id);
+		timeout = 1;
 	}
 
 	atomic_inc(&irq_tx);
@@ -1663,7 +1686,7 @@ static int hantro_dev_probe(struct platform_device *pdev)
 		err = PTR_ERR(temp_class);
 		goto err_out_class;
 	}
-
+	timeout = 0;
 	goto out;
 
 err_out_class:
-- 
1.7.9.5


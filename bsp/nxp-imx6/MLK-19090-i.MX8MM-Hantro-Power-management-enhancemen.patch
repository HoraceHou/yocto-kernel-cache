From 8a49054c1acfeb661efdc97645109f146cdc8da2 Mon Sep 17 00:00:00 2001
From: Zhou Peng <eagle.zhou@nxp.com>
Date: Tue, 31 Jul 2018 16:17:04 +0800
Subject: [PATCH 4285/5242] MLK-19090 - [i.MX8MM/Hantro]: Power management
 enhancement

commit  36289683d5bec1fc4a27c7bfb0dee7a251c68754 from
https://source.codeaurora.org/external/imx/linux-imx.git

Handle g1 and g2 power independently:
Add instance context to record which core(g1 or g2) is used
Check and power off unused core in ioctl operation

Signed-off-by: Zhou Peng <eagle.zhou@nxp.com>
(cherry picked from commit 7eba7e6bb7fef9180a18c4860230addd1c24f0c7)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/hantro_845/hantrodec_845s.c |   85 +++++++++++++++++++++++++++----
 1 file changed, 74 insertions(+), 11 deletions(-)

diff --git a/drivers/mxc/hantro_845/hantrodec_845s.c b/drivers/mxc/hantro_845/hantrodec_845s.c
index 6172030..d38025b 100755
--- a/drivers/mxc/hantro_845/hantrodec_845s.c
+++ b/drivers/mxc/hantro_845/hantrodec_845s.c
@@ -190,6 +190,14 @@
 
 static hantrodec_t hantrodec_data[HXDEC_MAX_CORES]; /* dynamic allocation? */
 
+typedef struct {
+	char inst_id;
+	char core_id;	//1:g1; 2:g2; 3:unknow
+} hantrodec_instance;
+static unsigned long instance_mask;
+#define MAX_HANTRODEC_INSTANCE 32
+static hantrodec_instance hantrodec_ctx[MAX_HANTRODEC_INSTANCE];
+
 static int ReserveIO(int);
 static void ReleaseIO(int);
 
@@ -311,6 +319,30 @@ static int hantro_power_on_disirq(hantrodec_t *hantrodev)
 	return 0;
 }
 
+static int hantro_new_instance(void)
+{
+	int idx;
+
+	spin_lock(&owner_lock);
+	if (instance_mask  == ((1UL << MAX_HANTRODEC_INSTANCE) - 1)) {
+		spin_unlock(&owner_lock);
+		return -1;
+	}
+	idx = ffz(instance_mask);
+	set_bit(idx, &instance_mask);
+	spin_unlock(&owner_lock);
+	return idx;
+}
+
+static int hantro_free_instance(int idx)
+{
+	spin_lock(&owner_lock);
+	clear_bit(idx, &instance_mask);
+	spin_unlock(&owner_lock);
+
+	return 0;
+}
+
 #ifdef CONFIG_DEVICE_THERMAL_XXX
 static int hantro_thermal_check(struct device *dev)
 {
@@ -1240,8 +1272,25 @@ static long hantrodec_ioctl(struct file *filp, unsigned int cmd, unsigned long a
 		return 0;
 	}
 	case _IOC_NR(HANTRODEC_IOCG_CORE_ID): {
+		int id;
+		hantrodec_instance *ctx = (hantrodec_instance *)filp->private_data;
+
 		PDEBUG("Get DEC Core_id, format = %li\n", arg);
-		return GetDecCoreID(arg);
+		id = GetDecCoreID(arg);
+		if ((ctx->core_id == 3) && (id >= 0)) {
+			if (id == 0) {
+				ctx->core_id = 1; //g1
+				/*power off g2*/
+				pm_runtime_put_sync(hantrodec_data[1].dev);
+				hantro_clk_disable(&hantrodec_data[1].clk);
+			} else if (id == 1) {
+				ctx->core_id = 2; //g2
+				/*power off g1*/
+				pm_runtime_put_sync(hantrodec_data[0].dev);
+				hantro_clk_disable(&hantrodec_data[0].clk);
+			}
+		}
+		return id;
 	}
 	case _IOC_NR(HANTRODEC_DEBUG_STATUS): {
 		PDEBUG("hantrodec: dec_irq     = 0x%08x\n", dec_irq);
@@ -1370,14 +1419,22 @@ static long hantrodec_ioctl32(struct file *filp, unsigned int cmd, unsigned long
 static int hantrodec_open(struct inode *inode, struct file *filp)
 {
 	int i;
+	int idx;
 
-	PDEBUG("dev opened\n");
-#if 1 // FIXME: need to identify core id
+	idx = hantro_new_instance();
+	if (idx < 0)
+		return -ENOMEM;
+
+	PDEBUG("dev opened: id: %d\n", idx);
+	hantrodec_ctx[idx].core_id = 3;  //unknow
+	hantrodec_ctx[idx].inst_id = idx;
+	filp->private_data = (void *)(&hantrodec_ctx[idx]);
+
+	/*not yet know which core id, so power on both g1 and g2 firstly*/
 	for (i = 0; i < 2; i++) {
 		hantro_clk_enable(&hantrodec_data[i].clk);
 		hantro_power_on_disirq(&hantrodec_data[i]);
 	}
-#endif
 	return 0;
 }
 
@@ -1392,9 +1449,9 @@ static int hantrodec_release(struct inode *inode, struct file *filp)
 {
 	int n;
 	//hantrodec_t *dev = &hantrodec_data;
+	hantrodec_instance *ctx = (hantrodec_instance *)filp->private_data;
 
 	PDEBUG("closing ...\n");
-#if 1 // FIXME: need to identify core id
 	for (n = 0; n < cores; n++) {
 		if (hantrodec_data[n].dec_owner == filp) {
 			PDEBUG("releasing dec Core %i lock\n", n);
@@ -1409,12 +1466,17 @@ static int hantrodec_release(struct inode *inode, struct file *filp)
 		}
 	}
 
-	pm_runtime_put_sync(hantrodec_data[0].dev);
-	hantro_clk_disable(&hantrodec_data[0].clk);
-	pm_runtime_put_sync(hantrodec_data[1].dev);
-	hantro_clk_disable(&hantrodec_data[1].clk);
-#endif
-	PDEBUG("closed\n");
+	if (ctx->core_id & 0x1) {
+		pm_runtime_put_sync(hantrodec_data[0].dev);
+		hantro_clk_disable(&hantrodec_data[0].clk);
+	}
+	if (ctx->core_id & 0x2) {
+		pm_runtime_put_sync(hantrodec_data[1].dev);
+		hantro_clk_disable(&hantrodec_data[1].clk);
+	}
+	hantro_free_instance(ctx->inst_id);
+
+	PDEBUG("closed: id: %d\n", n);
 	return 0;
 }
 
@@ -1860,6 +1922,7 @@ static int hantro_dev_probe(struct platform_device *pdev)
 #endif
 	hantrodec_data[id].timeout = 0;
 	mutex_init(&hantrodec_data[id].dev_mutex);
+	instance_mask = 0;
 
 	goto out;
 
-- 
1.7.9.5


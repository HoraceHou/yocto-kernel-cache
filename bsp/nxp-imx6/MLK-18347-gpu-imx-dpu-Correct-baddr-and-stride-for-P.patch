From cf164ce6e844f5b198178b4a9960a1442712f17b Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Thu, 17 May 2018 17:05:34 +0800
Subject: [PATCH 3876/5242] MLK-18347 gpu: imx: dpu: Correct baddr and stride
 for PRG x/y offset

commit  f986f8aea340e7d64a04792878a625837d1947a3 from
https://source.codeaurora.org/external/imx/linux-imx.git

We use PRG x/y offset to do in-micro-tile cropping for new DPR/PRG IPs.
When tile resolving is enabled by using the new IPs, the design team
indicates that DPU fetch unit base address and DPU/PRG stride need to be
calculated in the below steps:

1) prg_Baddr = dpr_Baddr
2) tmp_dpu_Baddr = prg_Baddr + prg_x_offset * bytes_per_pixel
3) tmp_burst_size = 1 << (ffs(tmp_dpu_Baddr) - 1)
   tmp_burst_size = round_up(tmp_burst_size, 8)
   burst_size = min(tmp_burst_size, 128)
4) tmp_dpu_stride = dpu_width * bytes_per_pixel
5) dpu_stride =
	round_up(tmp_dpu_stride + round_up(tmp_dpu_Baddr % 8, 8), burst_size)
6) dpu_Baddr = tmp_dpu_Baddr + prg_y_offset * dpu_stride
7) prg_stride = dpu_stride

The legacy DPR/PRG IPs and linear formats driver logic should not be
essentially touched.

This patch implements the above calculation method in the drivers
so that all valid in-micro-tile x/y cropping arguments can be supported.
Without this, at least, some cropping cases with odd x value would fail.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/dpu/dpu-plane.c   |   61 +++++++++++++++-----
 drivers/gpu/imx/dpu/dpu-fetchdecode.c |   48 ++++++++++++++--
 drivers/gpu/imx/dpu/dpu-fetchunit.c   |   59 ++++++++++++++++++--
 drivers/gpu/imx/imx8_dprc.c           |   16 +++---
 drivers/gpu/imx/imx8_prg.c            |   99 +++++++++++++++++++++++----------
 include/video/dpu.h                   |   24 +++++---
 include/video/imx8-prefetch.h         |    6 +-
 7 files changed, 245 insertions(+), 68 deletions(-)

diff --git a/drivers/gpu/drm/imx/dpu/dpu-plane.c b/drivers/gpu/drm/imx/dpu/dpu-plane.c
index 3dacc8b..1f4e3635 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-plane.c
+++ b/drivers/gpu/drm/imx/dpu/dpu-plane.c
@@ -347,7 +347,13 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 	if (fb->modifier && !dpstate->use_prefetch)
 		return -EINVAL;
 
-	/* base address alignment check */
+	/*
+	 * base address alignment check
+	 *
+	 * The (uv) base address offset introduced by PRG x/y
+	 * offset(for tile formats) would not impact the alignment
+	 * check, so we don't take the offset into consideration.
+	 */
 	baseaddr = drm_plane_state_to_baseaddr(state);
 	switch (fb->format->format) {
 	case DRM_FORMAT_YUYV:
@@ -368,8 +374,13 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 			return -EINVAL;
 		break;
 	case 16:
-		if (baseaddr & (dpstate->use_prefetch ? 0x7 : 0x1))
-			return -EINVAL;
+		if (fb->modifier) {
+			if (baseaddr & 0x1)
+				return -EINVAL;
+		} else {
+			if (baseaddr & (dpstate->use_prefetch ? 0x7 : 0x1))
+				return -EINVAL;
+		}
 		break;
 	}
 
@@ -379,16 +390,21 @@ static int dpu_plane_atomic_check(struct drm_plane *plane,
 	/* UV base address alignment check, assuming 16bpp */
 	if (drm_format_num_planes(fb->format->format) > 1) {
 		uv_baseaddr = drm_plane_state_to_uvbaseaddr(state);
-		if (uv_baseaddr & (dpstate->use_prefetch ? 0x7 : 0x1))
-			return -EINVAL;
+		if (fb->modifier) {
+			if (uv_baseaddr & 0x1)
+				return -EINVAL;
+		} else {
+			if (uv_baseaddr & (dpstate->use_prefetch ? 0x7 : 0x1))
+				return -EINVAL;
+		}
 
 		if (fb->pitches[1] > 0x10000)
 			return -EINVAL;
 	}
 
 	if (dpstate->use_prefetch &&
-	    !dprc_stride_double_check(dprc, fb->pitches[0], fb->pitches[1],
-					src_w, fb->format->format,
+	    !dprc_stride_double_check(dprc, src_w, src_x, fb->format->format,
+					fb->modifier,
 					baseaddr, uv_baseaddr)) {
 		if (fb->modifier)
 			return -EINVAL;
@@ -427,6 +443,7 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	dpu_block_id_t fe_id, vs_id = ID_NONE, hs_id;
 	lb_sec_sel_t lb_src = dpstate->source;
 	unsigned int src_w, src_h, src_x, src_y;
+	unsigned int mt_w = 0, mt_h = 0;	/* w/h in a micro-tile */
 	int bpp, lb_id;
 	bool need_fetcheco = false, need_hscaler = false, need_vscaler = false;
 	bool prefetch_start = false, aux_prefetch_start = false;
@@ -498,6 +515,20 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 		break;
 	}
 
+	switch (fb->modifier) {
+	case DRM_FORMAT_MOD_AMPHION_TILED:
+		mt_w = 8;
+		mt_h = 8;
+		break;
+	case DRM_FORMAT_MOD_VIVANTE_TILED:
+	case DRM_FORMAT_MOD_VIVANTE_SUPER_TILED:
+		mt_w = (bpp == 16) ? 8 : 4;
+		mt_h = 4;
+		break;
+	default:
+		break;
+	}
+
 	baseaddr = drm_plane_state_to_baseaddr(state);
 	if (need_fetcheco)
 		uv_baseaddr = drm_plane_state_to_uvbaseaddr(state);
@@ -507,15 +538,17 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 	     need_modeset))
 		prefetch_start = true;
 
-	fu->ops->set_burstlength(fu, baseaddr, dpstate->use_prefetch);
+	fu->ops->set_burstlength(fu, src_x, mt_w, bpp,
+				 baseaddr, dpstate->use_prefetch);
 	fu->ops->set_src_bpp(fu, bpp);
-	fu->ops->set_src_stride(fu, src_w, bpp, fb->pitches[0],
+	fu->ops->set_src_stride(fu, src_w, src_x, mt_w, bpp, fb->pitches[0],
 				baseaddr, dpstate->use_prefetch);
 	fu->ops->set_src_buf_dimensions(fu, src_w, src_h, 0, fb_is_interlaced);
 	fu->ops->set_fmt(fu, fb->format->format, fb_is_interlaced);
 	fu->ops->enable_src_buf(fu);
 	fu->ops->set_framedimensions(fu, src_w, src_h, fb_is_interlaced);
-	fu->ops->set_baseaddress(fu, baseaddr);
+	fu->ops->set_baseaddress(fu, src_w, src_x, src_y, mt_w, mt_h, bpp,
+				 baseaddr);
 	fu->ops->set_stream_id(fu, dplane->stream_id ?
 						DPU_PLANE_SRC_TO_DISP_STREAM1 :
 						DPU_PLANE_SRC_TO_DISP_STREAM0);
@@ -536,10 +569,11 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 
 		fetchdecode_pixengcfg_dynamic_src_sel(fu,
 						(fd_dynamic_src_sel_t)fe_id);
-		fe->ops->set_burstlength(fe, uv_baseaddr,
+		fe->ops->set_burstlength(fe, src_x, mt_w, bpp, uv_baseaddr,
 					 dpstate->use_prefetch);
 		fe->ops->set_src_bpp(fe, 16);
-		fe->ops->set_src_stride(fe, src_w, bpp, fb->pitches[1],
+		fe->ops->set_src_stride(fe, src_w, src_x, mt_w, bpp,
+					fb->pitches[1],
 					uv_baseaddr, dpstate->use_prefetch);
 		fe->ops->set_fmt(fe, fb->format->format, fb_is_interlaced);
 		fe->ops->set_src_buf_dimensions(fe, src_w, src_h,
@@ -547,7 +581,8 @@ static void dpu_plane_atomic_update(struct drm_plane *plane,
 						fb_is_interlaced);
 		fe->ops->set_framedimensions(fe, src_w, src_h,
 						fb_is_interlaced);
-		fe->ops->set_baseaddress(fe, uv_baseaddr);
+		fe->ops->set_baseaddress(fe, src_w, src_x, src_y / 2,
+					 mt_w, mt_h, bpp, uv_baseaddr);
 		fe->ops->enable_src_buf(fe);
 		fe->ops->set_stream_id(fe, dplane->stream_id ?
 					DPU_PLANE_SRC_TO_DISP_STREAM1 :
diff --git a/drivers/gpu/imx/dpu/dpu-fetchdecode.c b/drivers/gpu/imx/dpu/dpu-fetchdecode.c
index acfface..cbf4ca9 100644
--- a/drivers/gpu/imx/dpu/dpu-fetchdecode.c
+++ b/drivers/gpu/imx/dpu/dpu-fetchdecode.c
@@ -147,10 +147,39 @@ int fetchdecode_pixengcfg_dynamic_src_sel(struct dpu_fetchunit *fu,
 EXPORT_SYMBOL_GPL(fetchdecode_pixengcfg_dynamic_src_sel);
 
 static void
-fetchdecode_set_baseaddress(struct dpu_fetchunit *fu, dma_addr_t paddr)
+fetchdecode_set_baseaddress(struct dpu_fetchunit *fu, unsigned int width,
+			    unsigned int x_offset, unsigned int y_offset,
+			    unsigned int mt_w, unsigned int mt_h,
+			    int bpp, dma_addr_t baddr)
 {
+	unsigned int burst_size, stride;
+	bool nonzero_mod = !!mt_w;
+
+	if (nonzero_mod) {
+		/* consider PRG x offset to calculate buffer address */
+		baddr += (x_offset % mt_w) * (bpp / 8);
+
+		/*
+		 * address TKT343664:
+		 * fetch unit base address has to align to burst size
+		 */
+		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = round_up(burst_size, 8);
+		burst_size = min(burst_size, 128U);
+
+		stride = width * (bpp >> 3);
+		/*
+		 * address TKT339017:
+		 * fixup for burst size vs stride mismatch
+		 */
+		stride = round_up(stride + round_up(baddr % 8, 8), burst_size);
+
+		/* consider PRG y offset to calculate buffer address */
+		baddr += (y_offset % mt_h) * stride;
+	}
+
 	mutex_lock(&fu->mutex);
-	dpu_fu_write(fu, paddr, BASEADDRESS0);
+	dpu_fu_write(fu, baddr, BASEADDRESS0);
 	mutex_unlock(&fu->mutex);
 }
 
@@ -168,18 +197,25 @@ static void fetchdecode_set_src_bpp(struct dpu_fetchunit *fu, int bpp)
 
 static void
 fetchdecode_set_src_stride(struct dpu_fetchunit *fu,
-			   unsigned int width, int bpp, unsigned int stride,
+			   unsigned int width, unsigned int x_offset,
+			   unsigned int mt_w, int bpp, unsigned int stride,
 			   dma_addr_t baddr, bool use_prefetch)
 {
 	unsigned int burst_size;
+	bool nonzero_mod = !!mt_w;
 	u32 val;
 
 	if (use_prefetch) {
+		/* consider PRG x offset to calculate buffer address */
+		if (nonzero_mod)
+			baddr += (x_offset % mt_w) * (bpp / 8);
+
 		/*
 		 * address TKT343664:
 		 * fetch unit base address has to align to burst size
 		 */
 		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = round_up(burst_size, 8);
 		burst_size = min(burst_size, 128U);
 
 		stride = width * (bpp >> 3);
@@ -187,7 +223,11 @@ static void fetchdecode_set_src_bpp(struct dpu_fetchunit *fu, int bpp)
 		 * address TKT339017:
 		 * fixup for burst size vs stride mismatch
 		 */
-		stride = round_up(stride, burst_size);
+		if (nonzero_mod)
+			stride = round_up(stride + round_up(baddr % 8, 8),
+								burst_size);
+		else
+			stride = round_up(stride, burst_size);
 	}
 
 	mutex_lock(&fu->mutex);
diff --git a/drivers/gpu/imx/dpu/dpu-fetchunit.c b/drivers/gpu/imx/dpu/dpu-fetchunit.c
index 11b57ff..b482b2e 100644
--- a/drivers/gpu/imx/dpu/dpu-fetchunit.c
+++ b/drivers/gpu/imx/dpu/dpu-fetchunit.c
@@ -76,19 +76,26 @@ void fetchunit_shdldreq_sticky(struct dpu_fetchunit *fu, u8 layer_mask)
 }
 EXPORT_SYMBOL_GPL(fetchunit_shdldreq_sticky);
 
-void fetchunit_set_burstlength(struct dpu_fetchunit *fu, dma_addr_t baddr,
-			       bool use_prefetch)
+void fetchunit_set_burstlength(struct dpu_fetchunit *fu,
+			       unsigned int x_offset, unsigned int mt_w,
+			       int bpp, dma_addr_t baddr, bool use_prefetch)
 {
 	struct dpu_soc *dpu = fu->dpu;
 	unsigned int burst_size, burst_length;
+	bool nonzero_mod = !!mt_w;
 	u32 val;
 
 	if (use_prefetch) {
+		/* consider PRG x offset to calculate buffer address */
+		if (nonzero_mod)
+			baddr += (x_offset % mt_w) * (bpp / 8);
+
 		/*
 		 * address TKT343664:
 		 * fetch unit base address has to align to burst size
 		 */
 		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = round_up(burst_size, 8);
 		burst_size = min(burst_size, 128U);
 		burst_length = burst_size / 8;
 	} else {
@@ -107,10 +114,39 @@ void fetchunit_set_burstlength(struct dpu_fetchunit *fu, dma_addr_t baddr,
 }
 EXPORT_SYMBOL_GPL(fetchunit_set_burstlength);
 
-void fetchunit_set_baseaddress(struct dpu_fetchunit *fu, dma_addr_t paddr)
+void fetchunit_set_baseaddress(struct dpu_fetchunit *fu, unsigned int width,
+			       unsigned int x_offset, unsigned int y_offset,
+			       unsigned int mt_w, unsigned int mt_h,
+			       int bpp, dma_addr_t baddr)
 {
+	unsigned int burst_size, stride;
+	bool nonzero_mod = !!mt_w;
+
+	if (nonzero_mod) {
+		/* consider PRG x offset to calculate buffer address */
+		baddr += (x_offset % mt_w) * (bpp / 8);
+
+		/*
+		 * address TKT343664:
+		 * fetch unit base address has to align to burst size
+		 */
+		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = round_up(burst_size, 8);
+		burst_size = min(burst_size, 128U);
+
+		stride = width * (bpp >> 3);
+		/*
+		 * address TKT339017:
+		 * fixup for burst size vs stride mismatch
+		 */
+		stride = round_up(stride + round_up(baddr % 8, 8), burst_size);
+
+		/* consider PRG y offset to calculate buffer address */
+		baddr += (y_offset % mt_h) * stride;
+	}
+
 	mutex_lock(&fu->mutex);
-	dpu_fu_write(fu, paddr, BASEADDRESS(fu->sub_id));
+	dpu_fu_write(fu, baddr, BASEADDRESS(fu->sub_id));
 	mutex_unlock(&fu->mutex);
 }
 EXPORT_SYMBOL_GPL(fetchunit_set_baseaddress);
@@ -135,18 +171,25 @@ void fetchunit_set_src_bpp(struct dpu_fetchunit *fu, int bpp)
  * in bytes for one line, while bpp should be 8bits for every U or V component.
  */
 void fetchunit_set_src_stride(struct dpu_fetchunit *fu,
-			      unsigned int width, int bpp, unsigned int stride,
+			      unsigned int width, unsigned int x_offset,
+			      unsigned int mt_w, int bpp, unsigned int stride,
 			      dma_addr_t baddr, bool use_prefetch)
 {
 	unsigned int burst_size;
+	bool nonzero_mod = !!mt_w;
 	u32 val;
 
 	if (use_prefetch) {
+		/* consider PRG x offset to calculate buffer address */
+		if (nonzero_mod)
+			baddr += (x_offset % mt_w) * (bpp / 8);
+
 		/*
 		 * address TKT343664:
 		 * fetch unit base address has to align to burst size
 		 */
 		burst_size = 1 << (ffs(baddr) - 1);
+		burst_size = round_up(burst_size, 8);
 		burst_size = min(burst_size, 128U);
 
 		stride = width * (bpp >> 3);
@@ -154,7 +197,11 @@ void fetchunit_set_src_stride(struct dpu_fetchunit *fu,
 		 * address TKT339017:
 		 * fixup for burst size vs stride mismatch
 		 */
-		stride = round_up(stride, burst_size);
+		if (nonzero_mod)
+			stride = round_up(stride + round_up(baddr % 8, 8),
+								burst_size);
+		else
+			stride = round_up(stride, burst_size);
 	}
 
 	mutex_lock(&fu->mutex);
diff --git a/drivers/gpu/imx/imx8_dprc.c b/drivers/gpu/imx/imx8_dprc.c
index cf9be7e..088484e 100644
--- a/drivers/gpu/imx/imx8_dprc.c
+++ b/drivers/gpu/imx/imx8_dprc.c
@@ -372,7 +372,7 @@ void dprc_configure(struct dprc *dprc, unsigned int stream_id,
 	unsigned int prg_stride = width * info->cpp[0];
 	unsigned int bpp = 8 * info->cpp[0];
 	unsigned int preq;
-	unsigned int mt_w = 1, mt_h = 0;	/* w/h in a micro-tile */
+	unsigned int mt_w = 0, mt_h = 0;	/* w/h in a micro-tile */
 	u32 val;
 
 	if (WARN_ON(!dprc))
@@ -587,9 +587,6 @@ void dprc_configure(struct dprc *dprc, unsigned int stream_id,
 		}
 	}
 
-	if (dprc->is_blit_chan && dprc->devtype->has_fixup)
-		prg_stride = (width  + (x_offset % mt_w)) * info->cpp[0];
-
 	prg_configure(dprc->prgs[0], width, height, x_offset, y_offset,
 			prg_stride, bpp, baddr, format, modifier, start);
 	if (dprc->use_aux_prg)
@@ -758,21 +755,24 @@ bool dprc_stride_supported(struct dprc *dprc,
 EXPORT_SYMBOL_GPL(dprc_stride_supported);
 
 bool dprc_stride_double_check(struct dprc *dprc,
-			      unsigned int stride, unsigned int uv_stride,
-			      unsigned int width, u32 format,
+			      unsigned int width, unsigned int x_offset,
+			      u32 format, u64 modifier,
 			      dma_addr_t baddr, dma_addr_t uv_baddr)
 {
 	const struct dprc_format_info *info = dprc_format_info(format);
+	unsigned int bpp = 8 * info->cpp[0];
 	unsigned int prg_stride = width * info->cpp[0];
 
 	if (WARN_ON(!dprc))
 		return false;
 
-	if (!prg_stride_double_check(dprc->prgs[0], prg_stride, baddr))
+	if (!prg_stride_double_check(dprc->prgs[0], width, x_offset,
+				     bpp, modifier, prg_stride, baddr))
 		return false;
 
 	if (info->num_planes > 1 &&
-	    !prg_stride_double_check(dprc->prgs[1], prg_stride, uv_baddr))
+	    !prg_stride_double_check(dprc->prgs[1], width, x_offset,
+				     bpp, modifier, prg_stride, uv_baddr))
 		return false;
 
 	return true;
diff --git a/drivers/gpu/imx/imx8_prg.c b/drivers/gpu/imx/imx8_prg.c
index bee9476..b78aa17 100644
--- a/drivers/gpu/imx/imx8_prg.c
+++ b/drivers/gpu/imx/imx8_prg.c
@@ -136,7 +136,7 @@ void prg_configure(struct prg *prg, unsigned int width, unsigned int height,
 {
 	unsigned int burst_size;
 	unsigned int mt_w = 0, mt_h = 0;	/* w/h in a micro-tile */
-	bool is_tkt342628_case = false;
+	unsigned long _baddr;
 	u32 val;
 
 	if (WARN_ON(!prg))
@@ -145,29 +145,6 @@ void prg_configure(struct prg *prg, unsigned int width, unsigned int height,
 	if (start)
 		prg_reset(prg);
 
-	/*
-	 * address TKT343664:
-	 * fetch unit base address has to align to burst_size
-	 */
-	burst_size = 1 << (ffs(baddr) - 1);
-	burst_size = min(burst_size, 128U);
-
-	/*
-	 * address TKT339017:
-	 * fixup for burst size vs stride mismatch
-	 */
-	stride = round_up(stride, burst_size);
-
-	/*
-	 * address TKT342628(part 1):
-	 * when prg stride is less or equals to burst size,
-	 * the auxiliary prg height needs to be a half
-	 */
-	if (prg->is_auxiliary && stride <= burst_size) {
-		height /= 2;
-		is_tkt342628_case = true;
-	}
-
 	/* prg finer cropping into micro-tile block - top/left start point */
 	switch (modifier) {
 	case DRM_FORMAT_MOD_NONE:
@@ -189,11 +166,41 @@ void prg_configure(struct prg *prg, unsigned int width, unsigned int height,
 	if (prg->devtype->has_dprc_fixup && modifier) {
 		x_offset %= mt_w;
 		y_offset %= mt_h;
-		if (is_tkt342628_case)
-			y_offset /= 2;
+
+		/* consider x offset to calculate stride */
+		_baddr = baddr + (x_offset * (bits_per_pixel / 8));
 	} else {
 		x_offset = 0;
 		y_offset = 0;
+		_baddr = baddr;
+	}
+
+	/*
+	 * address TKT343664:
+	 * fetch unit base address has to align to burst_size
+	 */
+	burst_size = 1 << (ffs(_baddr) - 1);
+	burst_size = round_up(burst_size, 8);
+	burst_size = min(burst_size, 128U);
+
+	/*
+	 * address TKT339017:
+	 * fixup for burst size vs stride mismatch
+	 */
+	if (prg->devtype->has_dprc_fixup && modifier)
+		stride = round_up(stride + round_up(_baddr % 8, 8), burst_size);
+	else
+		stride = round_up(stride, burst_size);
+
+	/*
+	 * address TKT342628(part 1):
+	 * when prg stride is less or equals to burst size,
+	 * the auxiliary prg height needs to be a half
+	 */
+	if (prg->is_auxiliary && stride <= burst_size) {
+		height /= 2;
+		if (prg->devtype->has_dprc_fixup && modifier)
+			y_offset /= 2;
 	}
 
 	prg_write(prg, STRIDE(stride), PRG_STRIDE);
@@ -273,22 +280,58 @@ bool prg_stride_supported(struct prg *prg, unsigned int stride)
 EXPORT_SYMBOL_GPL(prg_stride_supported);
 
 bool prg_stride_double_check(struct prg *prg,
+			     unsigned int width, unsigned int x_offset,
+			     unsigned int bits_per_pixel, u64 modifier,
 			     unsigned int stride, dma_addr_t baddr)
 {
 	unsigned int burst_size;
+	unsigned int mt_w = 0;	/* w in a micro-tile */
+	dma_addr_t _baddr;
+
+	if (WARN_ON(!prg))
+		return false;
+
+	/* prg finer cropping into micro-tile block - top/left start point */
+	switch (modifier) {
+	case DRM_FORMAT_MOD_NONE:
+		break;
+	case DRM_FORMAT_MOD_AMPHION_TILED:
+		mt_w = 8;
+		break;
+	case DRM_FORMAT_MOD_VIVANTE_TILED:
+	case DRM_FORMAT_MOD_VIVANTE_SUPER_TILED:
+		mt_w = (bits_per_pixel == 16) ? 8 : 4;
+		break;
+	default:
+		dev_err(prg->dev, "unsupported modifier 0x%016llx\n", modifier);
+		return false;
+	}
+
+	if (prg->devtype->has_dprc_fixup && modifier) {
+		x_offset %= mt_w;
+
+		/* consider x offset to calculate stride */
+		_baddr = baddr + (x_offset * (bits_per_pixel / 8));
+	} else {
+		_baddr = baddr;
+	}
 
 	/*
 	 * address TKT343664:
 	 * fetch unit base address has to align to burst size
 	 */
-	burst_size = 1 << (ffs(baddr) - 1);
+	burst_size = 1 << (ffs(_baddr) - 1);
+	burst_size = round_up(burst_size, 8);
 	burst_size = min(burst_size, 128U);
 
 	/*
 	 * address TKT339017:
 	 * fixup for burst size vs stride mismatch
 	 */
-	stride = round_up(stride, burst_size);
+	if (prg->devtype->has_dprc_fixup && modifier)
+		stride = round_up(stride + round_up(_baddr % 8, 8), burst_size);
+	else
+		stride = round_up(stride, burst_size);
 
 	return stride < 0x10000;
 }
diff --git a/include/video/dpu.h b/include/video/dpu.h
index 60a54bc..57d24ee 100644
--- a/include/video/dpu.h
+++ b/include/video/dpu.h
@@ -432,14 +432,19 @@ enum {
 
 struct dpu_fetchunit_ops {
 	void (*set_burstlength)(struct dpu_fetchunit *fu,
-				dma_addr_t baddr, bool use_prefetch);
+				unsigned int x_offset, unsigned int mt_w,
+				int bpp, dma_addr_t baddr, bool use_prefetch);
 
-	void (*set_baseaddress)(struct dpu_fetchunit *fu, dma_addr_t paddr);
+	void (*set_baseaddress)(struct dpu_fetchunit *fu, unsigned int width,
+				unsigned int x_offset, unsigned int y_offset,
+				unsigned int mt_w, unsigned int mt_h,
+				int bpp, dma_addr_t baddr);
 
 	void (*set_src_bpp)(struct dpu_fetchunit *fu, int bpp);
 
 	void (*set_src_stride)(struct dpu_fetchunit *fu,
-			       unsigned int width, int bpp, unsigned int stride,
+			       unsigned int width, unsigned int x_offset,
+			       unsigned int mt_w, int bpp, unsigned int stride,
 			       dma_addr_t baddr, bool use_prefetch);
 
 	void (*set_src_buf_dimensions)(struct dpu_fetchunit *fu,
@@ -688,12 +693,17 @@ void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
 void fetchunit_shden(struct dpu_fetchunit *fu, bool enable);
 void fetchunit_baddr_autoupdate(struct dpu_fetchunit *fu, u8 layer_mask);
 void fetchunit_shdldreq_sticky(struct dpu_fetchunit *fu, u8 layer_mask);
-void fetchunit_set_burstlength(struct dpu_fetchunit *fu, dma_addr_t baddr,
-			       bool use_prefetch);
-void fetchunit_set_baseaddress(struct dpu_fetchunit *fu, dma_addr_t paddr);
+void fetchunit_set_burstlength(struct dpu_fetchunit *fu,
+			       unsigned int x_offset, unsigned int mt_w,
+			       int bpp, dma_addr_t baddr, bool use_prefetch);
+void fetchunit_set_baseaddress(struct dpu_fetchunit *fu, unsigned int width,
+			       unsigned int x_offset, unsigned int y_offset,
+			       unsigned int mt_w, unsigned int mt_h,
+			       int bpp, dma_addr_t baddr);
 void fetchunit_set_src_bpp(struct dpu_fetchunit *fu, int bpp);
 void fetchunit_set_src_stride(struct dpu_fetchunit *fu,
-			      unsigned int width, int bpp, unsigned int stride,
+			      unsigned int width, unsigned int x_offset,
+			      unsigned int mt_w, int bpp, unsigned int stride,
 			      dma_addr_t baddr, bool use_prefetch);
 void fetchunit_enable_src_buf(struct dpu_fetchunit *fu);
 void fetchunit_disable_src_buf(struct dpu_fetchunit *fu);
diff --git a/include/video/imx8-prefetch.h b/include/video/imx8-prefetch.h
index c89219d..edbbd17 100644
--- a/include/video/imx8-prefetch.h
+++ b/include/video/imx8-prefetch.h
@@ -40,6 +40,8 @@ void prg_configure(struct prg *prg, unsigned int width, unsigned int height,
 void prg_shadow_enable(struct prg *prg);
 bool prg_stride_supported(struct prg *prg, unsigned int stride);
 bool prg_stride_double_check(struct prg *prg,
+			     unsigned int width, unsigned int x_offset,
+			     unsigned int bits_per_pixel, u64 modifier,
 			     unsigned int stride, dma_addr_t baddr);
 void prg_set_auxiliary(struct prg *prg);
 void prg_set_primary(struct prg *prg);
@@ -65,8 +67,8 @@ bool dprc_stride_supported(struct dprc *dprc,
 			   unsigned int stride, unsigned int uv_stride,
 			   unsigned int width, u32 format);
 bool dprc_stride_double_check(struct dprc *dprc,
-			      unsigned int stride, unsigned int uv_stride,
-			      unsigned int width, u32 format,
+			      unsigned int width, unsigned int x_offset,
+			      u32 format, u64 modifier,
 			      dma_addr_t baddr, dma_addr_t uv_baddr);
 
 #endif
-- 
1.7.9.5


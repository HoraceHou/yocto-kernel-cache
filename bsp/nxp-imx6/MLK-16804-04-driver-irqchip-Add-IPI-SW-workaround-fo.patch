From 76a16d742a7caa385ae01462985ca6a26f041b3a Mon Sep 17 00:00:00 2001
From: Bai Ping <ping.bai@nxp.com>
Date: Wed, 8 Nov 2017 17:48:47 +0800
Subject: [PATCH 2787/5242] MLK-16804-04 driver: irqchip: Add IPI SW
 workaround for imx8mq

commit  108e60e0de0da2f510e5658dd325f0ebd7ffb782 from
https://source.codeaurora.org/external/imx/linux-imx.git

On i.MX8MQ, when the CPU core is in power down state,
the IPI can NOT wakeup the core anymore(ERR011171), so using the
external IRQ32 to wakeup the core in power down idle
state successfully.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Reviewed-by: Anson Huang <anson.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi |    3 ++-
 drivers/irqchip/irq-gic-v3.c                  |   18 +++++++++++++++++-
 2 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
index 272b492..52fdd82 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
@@ -70,7 +70,8 @@
 	gic: interrupt-controller@38800000 {
 		compatible = "arm,gic-v3";
 		reg = <0x0 0x38800000 0 0x10000>, /* GIC Dist */
-		      <0x0 0x38880000 0 0xC0000>; /* GICR (RD_base + SGI_base) */
+		      <0x0 0x38880000 0 0xC0000>, /* GICR (RD_base + SGI_base) */
+		      <0x0 0x30340000 0x0 0x10000>; /* IOMUXC_GPR */
 		#interrupt-cells = <3>;
 		interrupt-controller;
 		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c
index 76ea56d..c676fca 100644
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@ -63,6 +63,8 @@ struct gic_chip_data {
 static struct gic_chip_data gic_data __read_mostly;
 static DEFINE_STATIC_KEY_TRUE(supports_deactivate_key);
 
+static void __iomem *iomuxc_gpr_base;
+
 static struct gic_kvm_info gic_v3_kvm_info;
 static DEFINE_PER_CPU(bool, has_rss);
 
@@ -741,6 +743,7 @@ static void gic_send_sgi(u64 cluster_id, u16 tlist, unsigned int irq)
 static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
 {
 	int cpu;
+	u32 val;
 
 	if (WARN_ON(irq >= 16))
 		return;
@@ -757,8 +760,18 @@ static void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
 
 		tlist = gic_compute_target_list(&cpu, mask, cluster_id);
 		gic_send_sgi(cluster_id, tlist, irq);
-	}
 
+		if (iomuxc_gpr_base) {
+			/* pending the IRQ32 to wakeup the core */
+			val = readl_relaxed(iomuxc_gpr_base + 0x4);
+			val |= (1 << 12);
+			writel_relaxed(val, iomuxc_gpr_base + 0x4);
+			/* delay for a while to make sure cores wakeup done */
+			udelay(50);
+			val &= ~(1 << 12);
+			writel_relaxed(val, iomuxc_gpr_base + 0x4);
+		}
+	}
 	/* Force the above writes to ICC_SGI1R_EL1 to be executed */
 	isb();
 }
@@ -1310,6 +1323,9 @@ static int __init gic_of_init(struct device_node *node, struct device_node *pare
 		rdist_regs[i].phys_base = res.start;
 	}
 
+	/* sw workaround for IPI can't wakeup CORE ERRATA(ERR011171) on i.MX8MQ */
+	iomuxc_gpr_base = of_iomap(node, 2);
+
 	if (of_property_read_u64(node, "redistributor-stride", &redist_stride))
 		redist_stride = 0;
 
-- 
1.7.9.5


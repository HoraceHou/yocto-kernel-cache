From 222568ad850676ac909ff0c30154449fce34356e Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Thu, 22 Mar 2018 11:43:46 +0800
Subject: [PATCH 3528/5242] MLK-17889 drm/imx: dpu: crtc: Enable irqs before
 HWs are triggered in ->enable

commit  99a562eadcdc2307b404831d2a51df9275c7c9f1 from
https://source.codeaurora.org/external/imx/linux-imx.git

We should enable irqs before HWs are triggered in ->enable and then
wait for shadow loads are done, otherwise we would miss the irqs if
the irqs come right after the triggers although it's not very likely
to happen.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/dpu/dpu-crtc.c |   19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/imx/dpu/dpu-crtc.c b/drivers/gpu/drm/imx/dpu/dpu-crtc.c
index 4db43bd..31482ef 100644
--- a/drivers/gpu/drm/imx/dpu/dpu-crtc.c
+++ b/drivers/gpu/drm/imx/dpu/dpu-crtc.c
@@ -91,19 +91,23 @@ static void dpu_crtc_atomic_enable(struct drm_crtc *crtc,
 				   struct drm_crtc_state *old_crtc_state)
 {
 	struct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc);
+	struct dpu_plane *dplane = to_dpu_plane(crtc->primary);
+	struct dpu_plane_res *res = &dplane->grp->res;
+	struct dpu_extdst *plane_ed = res->ed[dplane->stream_id];
 	unsigned long ret;
 
 	drm_crtc_vblank_on(crtc);
 
+	enable_irq(dpu_crtc->safety_shdld_irq);
+	enable_irq(dpu_crtc->content_shdld_irq);
+	enable_irq(dpu_crtc->dec_shdld_irq);
+
 	framegen_enable_clock(dpu_crtc->fg);
+	extdst_pixengcfg_sync_trigger(plane_ed);
 	extdst_pixengcfg_sync_trigger(dpu_crtc->ed);
 	framegen_shdtokgen(dpu_crtc->fg);
 	framegen_enable(dpu_crtc->fg);
 
-	enable_irq(dpu_crtc->safety_shdld_irq);
-	enable_irq(dpu_crtc->content_shdld_irq);
-	enable_irq(dpu_crtc->dec_shdld_irq);
-
 	ret = wait_for_completion_timeout(&dpu_crtc->safety_shdld_done, HZ);
 	if (ret == 0)
 		dev_warn(dpu_crtc->dev,
@@ -418,12 +422,11 @@ static void dpu_crtc_atomic_flush(struct drm_crtc *crtc,
 	if (!crtc->state->active && !old_crtc_state->active)
 		return;
 
-	if (!need_modeset)
+	if (!need_modeset) {
 		enable_irq(dpu_crtc->content_shdld_irq);
 
-	extdst_pixengcfg_sync_trigger(ed);
+		extdst_pixengcfg_sync_trigger(ed);
 
-	if (!need_modeset) {
 		ret = wait_for_completion_timeout(&dpu_crtc->content_shdld_done,
 						  HZ);
 		if (ret == 0)
@@ -441,6 +444,8 @@ static void dpu_crtc_atomic_flush(struct drm_crtc *crtc,
 
 			crtc->state->event = NULL;
 		}
+	} else if (!crtc->state->active) {
+		extdst_pixengcfg_sync_trigger(ed);
 	}
 
 	for (i = 0; i < dpu_crtc->hw_plane_num; i++) {
-- 
1.7.9.5


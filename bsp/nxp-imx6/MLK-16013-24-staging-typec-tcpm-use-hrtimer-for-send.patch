From 726abb908b58702cc8b2690a0fda047cde082174 Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Thu, 27 Jul 2017 22:43:52 +0800
Subject: [PATCH 2303/5242] MLK-16013-24 staging: typec: tcpm: use hrtimer for
 send response

commit  9cd3840e866fe90d0e020cd2252476f9359eec40 from
https://source.codeaurora.org/external/imx/linux-imx.git

As the sender response timer have very small margin(25~30ms), so
use a hrtimer to handle it.

Reviewed-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/typec/tcpm.c |   31 +++++++++++++++++++++++++++----
 1 file changed, 27 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/typec/tcpm.c b/drivers/usb/typec/tcpm.c
index 627f308..c14b383 100644
--- a/drivers/usb/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -10,6 +10,7 @@
 #include <linux/device.h>
 #include <linux/jiffies.h>
 #include <linux/kernel.h>
+#include <linux/ktime.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/power_supply.h>
@@ -318,6 +319,9 @@ struct tcpm_port {
 	/* Deadline in jiffies to exit src_try_wait state */
 	unsigned long max_wait;
 
+	/* Send response timer */
+	struct hrtimer snd_res_timer;
+
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;
 	struct mutex logbuffer_lock;	/* log buffer access lock */
@@ -1527,6 +1531,7 @@ static void tcpm_pd_data_request(struct tcpm_port *port,
 			port->negotiated_rev = rev;
 
 		port->sink_request = le32_to_cpu(msg->payload[0]);
+		hrtimer_cancel(&port->snd_res_timer);
 		tcpm_set_state(port, SRC_NEGOTIATE_CAPABILITIES, 0);
 		break;
 	case PD_DATA_SINK_CAP:
@@ -1595,6 +1600,7 @@ static void tcpm_pd_ctrl_request(struct tcpm_port *port,
 			tcpm_queue_message(port, PD_MSG_DATA_SINK_CAP);
 			break;
 		default:
+			hrtimer_cancel(&port->snd_res_timer);
 			tcpm_set_state(port, SOFT_RESET_SEND, 0);
 			break;
 		}
@@ -1637,6 +1643,7 @@ static void tcpm_pd_ctrl_request(struct tcpm_port *port,
 	case PD_CTRL_NOT_SUPP:
 		switch (port->state) {
 		case SNK_NEGOTIATE_CAPABILITIES:
+			hrtimer_cancel(&port->snd_res_timer);
 			/* USB PD specification, Figure 8-43 */
 			if (port->explicit_contract)
 				next_state = SNK_READY;
@@ -1675,6 +1682,7 @@ static void tcpm_pd_ctrl_request(struct tcpm_port *port,
 		switch (port->state) {
 		case SNK_NEGOTIATE_CAPABILITIES:
 			port->pps_data.active = false;
+			hrtimer_cancel(&port->snd_res_timer);
 			tcpm_set_state(port, SNK_TRANSITION_SINK, 0);
 			break;
 		case SNK_NEGOTIATE_PPS_CAPABILITIES:
@@ -2782,6 +2790,16 @@ static enum typec_pwr_opmode tcpm_get_pwr_opmode(enum typec_cc_status cc)
 	}
 }
 
+static enum hrtimer_restart tcpm_sender_res_handle(struct hrtimer *data)
+{
+	struct tcpm_port *port = container_of(data, struct tcpm_port,
+							snd_res_timer);
+
+	tcpm_log_force(port, "Sender response timeout!");
+	tcpm_set_state(port, HARD_RESET_SEND, 0);
+	return HRTIMER_NORESTART;
+}
+
 static void run_state_machine(struct tcpm_port *port)
 {
 	int ret;
@@ -2915,8 +2933,9 @@ static void run_state_machine(struct tcpm_port *port)
 			/* port->hard_reset_count = 0; */
 			port->caps_count = 0;
 			port->pd_capable = true;
-			tcpm_set_state_cond(port, hard_reset_state(port),
-					    PD_T_SEND_SOURCE_CAP);
+			hrtimer_start(&port->snd_res_timer,
+				ms_to_ktime(PD_T_SENDER_RESPONSE),
+						HRTIMER_MODE_REL);
 		}
 		break;
 	case SRC_NEGOTIATE_CAPABILITIES:
@@ -3134,8 +3153,9 @@ static void run_state_machine(struct tcpm_port *port)
 			/* Let the Source send capabilities again. */
 			tcpm_set_state(port, SNK_WAIT_CAPABILITIES, 0);
 		} else {
-			tcpm_set_state_cond(port, hard_reset_state(port),
-					    PD_T_SENDER_RESPONSE);
+			hrtimer_start(&port->snd_res_timer,
+					ms_to_ktime(PD_T_SENDER_RESPONSE),
+					HRTIMER_MODE_REL);
 		}
 		break;
 	case SNK_NEGOTIATE_PPS_CAPABILITIES:
@@ -4719,6 +4739,9 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 		}
 	}
 
+	hrtimer_init(&port->snd_res_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	port->snd_res_timer.function = tcpm_sender_res_handle;
+
 	mutex_lock(&port->lock);
 	tcpm_init(port);
 	mutex_unlock(&port->lock);
-- 
1.7.9.5


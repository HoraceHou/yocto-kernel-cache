From 13b943a606696d07736e47340f2a1af16661ab46 Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Tue, 30 Jan 2018 16:04:58 +0800
Subject: [PATCH 3402/5242] MLK-17489-2: imx hdp: merge CDN api 1.0.36 code

commit  a4035121e52bf4fe5b860aa4b2cf0b63ba8c7606 from
https://source.codeaurora.org/external/imx/linux-imx.git

Merge Cadence HDMI API 1.0.36 code.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c          |  160 +++++++++++-------
 drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h          |    3 +
 .../drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c   |  178 +++++++++++++++-----
 drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c    |   95 ++++++++++-
 4 files changed, 333 insertions(+), 103 deletions(-)

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c
index e437120..be26590 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.c
@@ -35,7 +35,7 @@
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  ******************************************************************************
  *
@@ -48,22 +48,54 @@
 #include "API_AFE_mcu1_dp.h"
 #include "../../../../mxc/hdp/all.h"
 
+u8 AFE_check_rate_supported(ENUM_AFE_LINK_RATE rate)
+{
+	switch (rate) {
+	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
+	case AFE_LINK_RATE_2_7:
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
+	case AFE_LINK_RATE_5_4:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
 static void AFE_WriteReg(state_struct *state, ENUM_AFE_LINK_RATE link_rate,
-				u32 addr, u32 val1_6, u32 val2_7, u32 val5_4)
+			 unsigned int addr,
+			 unsigned int val1_6,
+			 unsigned int val2_1,
+			 unsigned int val2_4,
+			 unsigned int val2_7,
+			 unsigned int val3_2,
+			 unsigned int val4_3,
+			 unsigned int val5_4)
 {
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
 		Afe_write(state, addr, val1_6);
 		break;
-
+	case AFE_LINK_RATE_2_1:
+		Afe_write(state, addr, val2_1);
+		break;
+	case AFE_LINK_RATE_2_4:
+		Afe_write(state, addr, val2_4);
+		break;
 	case AFE_LINK_RATE_2_7:
 		Afe_write(state, addr, val2_7);
 		break;
-
+	case AFE_LINK_RATE_3_2:
+		Afe_write(state, addr, val3_2);
+		break;
+	case AFE_LINK_RATE_4_3:
+		Afe_write(state, addr, val4_3);
+		break;
 	case AFE_LINK_RATE_5_4:
 		Afe_write(state, addr, val5_4);
 		break;
-
 	case AFE_LINK_RATE_8_1:	/* Not used in MCU1 */
 	default:
 		pr_err("Warning. Unsupported Link Rate!\n");
@@ -83,43 +115,6 @@ void phy_cfg_24mhz(state_struct *state, int num_lanes)
 }
 
 /* Valid for 24 MHz only */
-void phy_cfg_dp_cmn_pll0(state_struct *state, int num_lanes)
-{
-	int k;
-	volatile u16 rdata;
-
-	Afe_write(state, PHY_HDP_CLK_CTL, 0x2405);
-	Afe_write(state, CMN_PLL0_INTDIV, 0x0086);
-	Afe_write(state, CMN_PLL0_FRACDIV, 0xF915);
-	Afe_write(state, CMN_PLL0_HIGH_THR, 0x0022);
-	Afe_write(state, CMN_PLL0_SS_CTRL1, 0x0140);
-	rdata = Afe_read(state, CMN_DIAG_HSCLK_SEL);
-	rdata = rdata & 0xFFFC;
-	rdata = rdata | 0x0001;
-	Afe_write(state, CMN_DIAG_HSCLK_SEL, rdata);
-	for (k = 0; k < num_lanes; k = k + 1) {
-		rdata = Afe_read(state, (XCVR_DIAG_HSCLK_SEL | (k << 9)));
-		rdata = rdata & 0xCFFF;
-		rdata = rdata | 0x1000;
-		Afe_write(state, (XCVR_DIAG_HSCLK_SEL | (k << 9)), rdata);
-	}
-	Afe_write(state, CMN_PLL0_VCOCAL_START, 0x3061);
-	Afe_write(state, CMN_PLLSM0_USER_DEF_CTRL, 0x0000);
-	Afe_write(state, CMN_DIAG_PLL0_V2I_TUNE, 0x0006);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x008c);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x002e);
-	Afe_write(state, CMN_DIAG_PLL0_CP_TUNE, 0x0026);
-	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
-	Afe_write(state, CMN_PLL0_VCOCAL_INIT_TMR, 0x00F0);
-	Afe_write(state, CMN_PLL0_VCOCAL_ITER_TMR, 0x0018);
-	Afe_write(state, CMN_PLL0_SS_CTRL2, 0x7F03);
-	Afe_write(state, CMN_PLL0_DSM_DIAG, 0x0020);
-	Afe_write(state, CMN_DIAG_PLL0_OVRD, 0x0000);
-	Afe_write(state, CMN_DIAG_PLL0_FBH_OVRD, 0x0000);
-	Afe_write(state, CMN_DIAG_PLL0_FBL_OVRD, 0x0000);
-}
-
-/* Valid for 24 MHz only */
 void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
 {
 	int k;
@@ -130,10 +125,14 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
 	case AFE_LINK_RATE_2_7:
 		rdata = rdata | 0x2400;
 		break;
 
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
 	case AFE_LINK_RATE_5_4:
 		rdata = rdata | 0x1200;
 		break;
@@ -149,10 +148,14 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 	rdata = rdata & 0xFFCC;
 	switch (link_rate) {
 	case AFE_LINK_RATE_1_6:
+	case AFE_LINK_RATE_2_1:
+	case AFE_LINK_RATE_2_4:
 	case AFE_LINK_RATE_2_7:
 		rdata = rdata | 0x0011;
 		break;
 
+	case AFE_LINK_RATE_3_2:
+	case AFE_LINK_RATE_4_3:
 	case AFE_LINK_RATE_5_4:
 		rdata = rdata | 0x0000;
 		break;
@@ -168,10 +171,14 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 		rdata = rdata & 0xCFFF;
 		switch (link_rate) {
 		case AFE_LINK_RATE_1_6:
+		case AFE_LINK_RATE_2_1:
+		case AFE_LINK_RATE_2_4:
 		case AFE_LINK_RATE_2_7:
 			rdata = rdata | 0x1000;
 			break;
 
+		case AFE_LINK_RATE_3_2:
+		case AFE_LINK_RATE_4_3:
 		case AFE_LINK_RATE_5_4:
 			rdata = rdata | 0x0000;
 			break;
@@ -183,34 +190,39 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 		}
 		Afe_write(state, (XCVR_DIAG_HSCLK_SEL | (k << 9)), rdata);
 	}
-	AFE_WriteReg(state, link_rate, CMN_PLL0_VCOCAL_START, 0x3061, 0x30D0, 0x30D0);
-	AFE_WriteReg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL, 0x0000, 0x1000,
-		     0x1000);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE, 0x0006, 0x0007, 0x0007);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x008C);
-	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x002E);
-	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_CP_TUNE, 0x0026, 0x0029, 0x0029);
-	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
 	Afe_write(state, CMN_PLL0_VCOCAL_INIT_TMR, 0x00F0);
 	Afe_write(state, CMN_PLL0_VCOCAL_ITER_TMR, 0x0018);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_INTDIV, 0x0086, 0x00E0, 0x00E0);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_FRACDIV, 0xF915, 0xF479, 0xF479);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_HIGH_THR, 0x0022, 0x0038, 0x0038);
-	AFE_WriteReg(state, link_rate, CMN_PLL0_SS_CTRL1, 0x0140, 0x0204, 0x0204);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_VCOCAL_START, 0x3061, 0x3092, 0x30B3, 0x30D0, 0x3061, 0x3092, 0x30D0);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_INTDIV, 0x0086, 0x00B3, 0x00CA, 0x00E0, 0x0086, 0x00B3, 0x00E0);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_FRACDIV, 0xF917, 0xF6C7, 0x75A1, 0xF479, 0xF917, 0xF6C7, 0xF479);
+	AFE_WriteReg(state, link_rate, CMN_PLL0_HIGH_THR, 0x0022, 0x002D, 0x0033, 0x0038, 0x0022, 0x002D, 0x0038);
+#ifdef SSC_ON_INIT
+	AFE_WriteReg(state, link_rate, CMN_PLL0_SS_CTRL1, 0x0140, 0x01AB, 0x01E0, 0x0204, 0x0140, 0x01AB, 0x0204);
 	Afe_write(state, CMN_PLL0_SS_CTRL2, 0x7F03);
+#endif
 	Afe_write(state, CMN_PLL0_DSM_DIAG, 0x0020);
+	AFE_WriteReg(state, link_rate, CMN_PLLSM0_USER_DEF_CTRL, 0x0000, 0x1000, 0x1000, 0x1000, 0x0000, 0x1000, 0x1000);
 	Afe_write(state, CMN_DIAG_PLL0_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBH_OVRD, 0x0000);
 	Afe_write(state, CMN_DIAG_PLL0_FBL_OVRD, 0x0000);
+	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_V2I_TUNE, 0x0006, 0x0007, 0x0007, 0x0007, 0x0006, 0x0007, 0x0007);
+	AFE_WriteReg(state, link_rate, CMN_DIAG_PLL0_CP_TUNE, 0x0026, 0x0029, 0x0029, 0x0029, 0x0026, 0x0029, 0x0029);
+	Afe_write(state, CMN_DIAG_PLL0_LF_PROG, 0x0008);
+	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE1, 0x008C);
+	Afe_write(state, CMN_DIAG_PLL0_PTATIS_TUNE2, 0x002E);
 	for (k = 0; k < num_lanes; k = k + 1) {
 		rdata = Afe_read(state, (XCVR_DIAG_PLLDRC_CTRL | (k << 9)));
 		rdata = rdata & 0x8FFF;
 		switch (link_rate) {
 		case AFE_LINK_RATE_1_6:
+		case AFE_LINK_RATE_2_1:
+		case AFE_LINK_RATE_2_4:
 		case AFE_LINK_RATE_2_7:
 			rdata = rdata | 0x2000;
 			break;
 
+		case AFE_LINK_RATE_3_2:
+		case AFE_LINK_RATE_4_3:
 		case AFE_LINK_RATE_5_4:
 			rdata = rdata | 0x1000;
 			break;
@@ -227,12 +239,25 @@ void phy_cfg_dp_pll0(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link
 void phy_cfg_dp_ln(state_struct *state, int num_lanes)
 {
 	int k;
+	u16 rdata;
+
 	for (k = 0; k < num_lanes; k = k + 1) {
 		Afe_write(state, (XCVR_PSM_RCTRL | (k << 9)), 0xBEFC);
-		Afe_write(state, (TX_PSC_A0 | (k << 9)), 0x6799);
-		Afe_write(state, (TX_PSC_A1 | (k << 9)), 0x6798);
-		Afe_write(state, (TX_PSC_A2 | (k << 9)), 0x0098);
-		Afe_write(state, (TX_PSC_A3 | (k << 9)), 0x0098);
+		if (state->edp == 0) {
+			Afe_write(state, (TX_PSC_A0 | (k << 9)), 0x6799);
+			Afe_write(state, (TX_PSC_A1 | (k << 9)), 0x6798);
+			Afe_write(state, (TX_PSC_A2 | (k << 9)), 0x0098);
+			Afe_write(state, (TX_PSC_A3 | (k << 9)), 0x0098);
+		} else {
+			Afe_write(state, (TX_PSC_A0 | (k << 9)), 0x279B);
+			Afe_write(state, (TX_PSC_A1 | (k << 9)), 0x2798);
+			Afe_write(state, (TX_PSC_A2 | (k << 9)), 0x0098);
+			Afe_write(state, (TX_PSC_A3 | (k << 9)), 0x0098);
+			rdata = Afe_read(state, TX_DIAG_TX_DRV | (k << 9));
+			rdata &= 0x0600;	/* keep bits related to programmable boost */
+			rdata |= 0x00C0;
+			Afe_write(state, (TX_DIAG_TX_DRV | (k << 9)), rdata);
+		}
 	}
 }
 
@@ -315,6 +340,12 @@ void AFE_init(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
 {
 	volatile u16 val;
 
+	if (AFE_check_rate_supported(link_rate) == 0) {
+		pr_info
+		    ("AFE_init() *E: Selected link rate not supported: 0x%x\n",
+		     link_rate);
+		return;
+	}
 	val = Afe_read(state, PHY_PMA_CMN_CTRL1);
 	val = val & 0xFFF7;
 	val = val | 0x0008;
@@ -332,18 +363,27 @@ void AFE_init(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
 	val = val | 0x0030;
 	Afe_write(state, PHY_PMA_CMN_CTRL1, val);
 
+	if (state->edp != 0)
+		Afe_write(state, CMN_DIAG_CAL_CTRL, 0x0001);
+
 	phy_cfg_dp_ln(state, num_lanes);
 
 	/* Configure PHY in A2 Mode */
 	Afe_write(state, PHY_HDP_MODE_CTRL, 0x0004);
-
 }
 
-void AFE_power(state_struct *state, int num_lanes, ENUM_AFE_LINK_RATE link_rate)
+void AFE_power(state_struct *state, int num_lanes,
+	       ENUM_AFE_LINK_RATE link_rate)
 {
 	static u16 prev_calib_code;
 
 	volatile u16 val;
+	if (AFE_check_rate_supported(link_rate) == 0) {
+		pr_info
+		    ("AFE_power() *E: Selected link rate not supported: 0x%x\n",
+		     link_rate);
+		return;
+	}
 
 	Afe_write(state, TX_DIAG_ACYA_0, 1);
 	Afe_write(state, TX_DIAG_ACYA_1, 1);
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h
index 2b49548..1813c4f 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_mcu1_dp.h
@@ -35,6 +35,8 @@
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
+ * Copyright 2017-2018 NXP
+ *
  ******************************************************************************
  *
  * API_AFE_mcu1_dp.h
@@ -76,6 +78,7 @@
 #define CMN_DIAG_PLL0_PTATIS_TUNE2 0x01C9
 #define CMN_DIAG_PLL0_CP_TUNE 0x01C6
 #define CMN_DIAG_PER_CAL_ADJ 0x01EC
+#define CMN_DIAG_CAL_CTRL 0x01ED
 #define CMN_DIAG_PLL0_LF_PROG 0x01C7
 #define CMN_PLL0_VCOCAL_INIT_TMR 0x0084
 #define CMN_PLL0_VCOCAL_ITER_TMR 0x0085
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
index be58b46..1802e73 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
@@ -35,7 +35,7 @@
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  ******************************************************************************
  *
@@ -48,8 +48,7 @@
 #include "API_AFE_ss28fdsoi_kiran_hdmitx.h"
 #include "ss28fdsoi_hdmitx_table.h"
 
-static int inside(u32 value, u32 left_sharp_corner,
-		  u32 right_sharp_corner)
+static int inside(u32 value, u32 left_sharp_corner, u32 right_sharp_corner)
 {
 	if (value < left_sharp_corner)
 		return 0;
@@ -67,8 +66,6 @@ int get_table_row_match_column(const u32 *array, u32 table_rows,
 	u32 value;
 	for (idx_rows = start_row; idx_rows < table_rows; idx_rows++) {
 		for (idx_cols = 0; idx_cols < table_cols; idx_cols++) {
-		/*	pr_info("get_table_row_match_column: TAG row: %0d, col: %0d, value: %0d\n",
-			     idx_rows, idx_cols, *((array + idx_rows * table_cols) + idx_cols)); */
 			if (idx_cols == column_to_search) {
 				value =
 				    *((array + idx_rows * table_cols) +
@@ -93,8 +90,10 @@ int get_table_row(const u32 *array, u32 table_rows,
 					       column_to_search, column_value);
 		if (i + 1) {
 			if (inside(variable_in_range,
-			     *((array + i * table_cols) + range_min_column),
-			     *((array + i * table_cols) + range_max_column))) {
+				   *((array + i * table_cols) +
+				     range_min_column),
+				   *((array + i * table_cols) +
+				     range_max_column))) {
 				break;
 			}
 			i++;
@@ -105,8 +104,9 @@ int get_table_row(const u32 *array, u32 table_rows,
 	return i;
 }
 
-int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode, int bpp,
-		VIC_PXL_ENCODING_FORMAT format)
+int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
+			  VIC_MODES vicMode, int bpp,
+			  VIC_PXL_ENCODING_FORMAT format)
 {
 	const int phy_reset_workaround = 0;
 	u32 vco_freq_khz;
@@ -180,14 +180,14 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 	     num_lanes, vicMode, bpp, format);
 
 	/* register PHY_PMA_ISOLATION_CTRL
-	enable PHY isolation mode only for CMN */
+	 * enable PHY isolation mode only for CMN */
 	if (phy_reset_workaround) {
 		Afe_write(state, 0xC81F, 0xD000);
 		reg_val = Afe_read(state, 0xC812);
-	    reg_val &= 0xFF00;
-	    reg_val |= 0x0012;
+		reg_val &= 0xFF00;
+		reg_val |= 0x0012;
 		/* set cmn_pll0_clk_datart1_div/cmn_pll0_clk_datart0_div dividers */
-	    Afe_write(state, 0xC812, reg_val);
+		Afe_write(state, 0xC812, reg_val);
 		/* register PHY_ISO_CMN_CTRL */
 		Afe_write(state, 0xC010, 0x0000);	/* assert PHY reset from isolation register */
 		/* register PHY_PMA_ISO_CMN_CTRL */
@@ -201,7 +201,7 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 		 * Describing Task phy_cfg_hdp
 		 * ------------------------------------------------------------*/
 		/* register PHY_PMA_CMN_CTRL1 */
-	    for (i = 0; i < num_lanes; i++)
+		for (i = 0; i < num_lanes; i++)
 			Afe_write(state, 0x40E8 | (i << 9), 0x007F);
 	}
 	/* register CMN_DIAG_PLL0_TEST_MODE */
@@ -316,7 +316,9 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 		    ("Pixel clock frequency (%u kHz) not supported for this color depth (%0d-bit), row=%d\n",
 		     ftemp, bpp, row);
 	}
-	character_freq_khz = pixel_freq_khz * character_clock_ratio_num / character_clock_ratio_den;
+	character_freq_khz =
+	    pixel_freq_khz * character_clock_ratio_num /
+	    character_clock_ratio_den;
 	ftemp = character_freq_khz;
 	pr_info("Character clock frequency: %u kHz.\n", ftemp);
 
@@ -345,8 +347,7 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 	set_field_value(&cmnda_hs_clk_1_sel,
 			ss28fdsoi_hdmitx_clock_control_table[row]
 			[CMNDA_HS_CLK_1_SEL]);
-	set_field_value(&tx_subrate,
-			ss28fdsoi_hdmitx_clock_control_table[row]
+	set_field_value(&tx_subrate, ss28fdsoi_hdmitx_clock_control_table[row]
 			[HSCLK_DIV_TX_SUB_RATE]);
 	set_field_value(&vco_ring_select,
 			ss28fdsoi_hdmitx_clock_control_table[row]
@@ -357,27 +358,27 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 
 	/* Display parameters (informative message) */
 	pr_info("set_field_value() cmnda_pll0_hs_sym_div_sel : 0x%X\n",
-	       cmnda_pll0_hs_sym_div_sel.value);
+		cmnda_pll0_hs_sym_div_sel.value);
 	pr_info("set_field_value() cmnda_pll0_ip_div         : 0x%02X\n",
-	       cmnda_pll0_ip_div.value);
+		cmnda_pll0_ip_div.value);
 	pr_info("set_field_value() cmnda_pll0_fb_div_low     : 0x%03X\n",
-	       cmnda_pll0_fb_div_low.value);
+		cmnda_pll0_fb_div_low.value);
 	pr_info("set_field_value() cmnda_pll0_fb_div_high    : 0x%03X\n",
-	       cmnda_pll0_fb_div_high.value);
+		cmnda_pll0_fb_div_high.value);
 	pr_info("set_field_value() cmn_ref_clk_dig_div       : 0x%X\n",
-	       cmn_ref_clk_dig_div.value);
+		cmn_ref_clk_dig_div.value);
 	pr_info("set_field_value() divider_scaler            : 0x%X\n",
-	       divider_scaler.value);
+		divider_scaler.value);
 	pr_info("set_field_value() cmnda_hs_clk_0_sel        : %0d\n",
-	       cmnda_hs_clk_0_sel.value);
+		cmnda_hs_clk_0_sel.value);
 	pr_info("set_field_value() cmnda_hs_clk_1_sel        : %0d\n",
-	       cmnda_hs_clk_1_sel.value);
+		cmnda_hs_clk_1_sel.value);
 	pr_info("set_field_value() tx_subrate                : %0d\n",
-	       tx_subrate.value);
+		tx_subrate.value);
 	pr_info("set_field_value() vco_ring_select           : %0d\n",
-	       vco_ring_select.value);
+		vco_ring_select.value);
 	pr_info("set_field_value() pll_feedback_divider_total: %0d\n",
-	       pll_feedback_divider_total.value);
+		pll_feedback_divider_total.value);
 
 	vco_freq_khz =
 	    pixel_freq_khz * pll_feedback_divider_total.value /
@@ -423,17 +424,17 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 
 	/* Display parameters (informative message) */
 	pr_info("set_field_value() voltage_to_current_coarse : 0x%X\n",
-	       voltage_to_current_coarse.value);
+		voltage_to_current_coarse.value);
 	pr_info("set_field_value() voltage_to_current        : 0x%X\n",
-	       voltage_to_current.value);
+		voltage_to_current.value);
 	pr_info("set_field_value() ndac_ctrl                 : 0x%X\n",
-	       ndac_ctrl.value);
+		ndac_ctrl.value);
 	pr_info("set_field_value() pmos_ctrl                 : 0x%02X\n",
-	       pmos_ctrl.value);
+		pmos_ctrl.value);
 	pr_info("set_field_value() ptat_ndac_ctrl            : 0x%02X\n",
-	       ptat_ndac_ctrl.value);
+		ptat_ndac_ctrl.value);
 	pr_info("set_field_value() charge_pump_gain          : 0x%03X\n",
-	       charge_pump_gain.value);
+		charge_pump_gain.value);
 
 	/* ---------------------------------------------------------------
 	 * Describing Task phy_cfg_hdmi_pll0_0pt5736
@@ -560,14 +561,14 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 		}
 	}
 	for (i = 0; i < num_lanes; i++) {
-			/* register TX_PSC_A0 */
-			Afe_write(state, 0x4100 | (i << 9), 0x6791);
-			/* register TX_PSC_A1 */
-			Afe_write(state, 0x4101 | (i << 9), 0x6790);
-			/* register TX_PSC_A2 */
-			Afe_write(state, 0x4102 | (i << 9), 0x0090);
-			/* register TX_PSC_A3 */
-			Afe_write(state, 0x4103 | (i << 9), 0x0090);
+		/* register TX_PSC_A0 */
+		Afe_write(state, 0x4100 | (i << 9), 0x6791);
+		/* register TX_PSC_A1 */
+		Afe_write(state, 0x4101 | (i << 9), 0x6790);
+		/* register TX_PSC_A2 */
+		Afe_write(state, 0x4102 | (i << 9), 0x0090);
+		/* register TX_PSC_A3 */
+		Afe_write(state, 0x4103 | (i << 9), 0x0090);
 	}
 
 	/* register PHY_HDP_MODE_CTL */
@@ -576,6 +577,93 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, VIC_MODES vicMode,
 
 }
 
+static void arc_power_up(state_struct *state)
+{
+	pr_info("arc_power_up()\n");
+
+	/* register CMN_RXCAL_OVRD */
+	Afe_write(state, 0x5025, 0x0001);
+}
+
+static void arc_calibrate(state_struct *state)
+{
+	uint16_t txpu_calib_code;
+	uint16_t txpd_calib_code;
+	uint16_t txpu_adj_calib_code;
+	uint16_t txpd_adj_calib_code;
+	uint16_t prev_calib_code;
+	uint16_t new_calib_code;
+	uint16_t rdata;
+
+	pr_info("aux_cal_cfg() ARC programming\n");
+	/* register TX_DIG_CTRL_REG_2 */
+	prev_calib_code = Afe_read(state, 0x5024);
+	/* register CMN_TXPUCAL_CTRL */
+	txpu_calib_code = Afe_read(state, 0x00E0);
+	/* register CMN_TXPDCAL_CTRL */
+	txpd_calib_code = Afe_read(state, 0x00F0);
+	/* register CMN_TXPU_ADJ_CTRL */
+	txpu_adj_calib_code = Afe_read(state, 0x0108);
+	/* register CMN_TXPD_ADJ_CTRL */
+	txpd_adj_calib_code = Afe_read(state, 0x010c);
+
+	new_calib_code = ((txpu_calib_code + txpd_calib_code) / 2)
+	    + txpu_adj_calib_code + txpd_adj_calib_code;
+
+	if (new_calib_code != prev_calib_code) {
+		/* register TX_ANA_CTRL_REG_1 */
+		rdata = Afe_read(state, 0x5020);
+		rdata &= 0xDFFF;
+		/* register TX_ANA_CTRL_REG_1 */
+		Afe_write(state, 0x5020, rdata);
+		/* register TX_DIG_CTRL_REG_2 */
+		Afe_write(state, 0x5024, new_calib_code);
+		mdelay(10);
+		rdata |= 0x2000;
+		/* register TX_ANA_CTRL_REG_1 */
+		Afe_write(state, 0x5020, rdata);
+		udelay(150);
+	}
+}
+
+static void arc_config(state_struct *state)
+{
+	pr_info("arc_config() ARC programming\n");
+
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x0100);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x0300);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_3 */
+	Afe_write(state, 0x5026, 0x0000);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2008);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2018);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2098);
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x030C);
+	/* register TX_ANA_CTRL_REG_5 */
+	Afe_write(state, 0x5029, 0x0000);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_4 */
+	Afe_write(state, 0x5027, 0x4001);
+	mdelay(5);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2198);
+	mdelay(5);
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x030D);
+	udelay(100);
+	Afe_write(state, 0x5021, 0x030F);
+}
+
 int hdmi_tx_kiran_power_configuration_seq(state_struct *state, int num_lanes)
 {
 	/* Configure the power state. */
@@ -583,6 +671,12 @@ int hdmi_tx_kiran_power_configuration_seq(state_struct *state, int num_lanes)
 	/* PHY_DP_MODE_CTL */
 	while (!(Afe_read(state, 0xC008) & (1 << 6))) ;
 
+#ifdef __ARC_CONFIG__
+	arc_power_up();
+	arc_calibrate();
+	arc_config();
+#endif
+
 	/* PHY_DP_MODE_CTL */
 	Afe_write(state, 0xC008, (((0x0F << num_lanes) & 0x0F) << 12) | 0x0001);
 
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
index 9141c11..c6c7035 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
@@ -35,7 +35,7 @@
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  ******************************************************************************
  *
@@ -1824,6 +1824,93 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 
 }
 
+static void arc_power_up(state_struct *state)
+{
+	pr_info("arc_power_up()\n");
+
+	/* register CMN_RXCAL_OVRD */
+	Afe_write(state, 0x5025, 0x0001);
+}
+
+static void arc_calibrate(state_struct *state)
+{
+	uint16_t txpu_calib_code;
+	uint16_t txpd_calib_code;
+	uint16_t txpu_adj_calib_code;
+	uint16_t txpd_adj_calib_code;
+	uint16_t prev_calib_code;
+	uint16_t new_calib_code;
+	uint16_t rdata;
+
+	pr_info("aux_cal_cfg() ARC programming\n");
+	/* register TX_DIG_CTRL_REG_2 */
+	prev_calib_code = Afe_read(state, 0x5024);
+	/* register CMN_TXPUCAL_CTRL */
+	txpu_calib_code = Afe_read(state, 0x00E0);
+	/* register CMN_TXPDCAL_CTRL */
+	txpd_calib_code = Afe_read(state, 0x00F0);
+	/* register CMN_TXPU_ADJ_CTRL */
+	txpu_adj_calib_code = Afe_read(state, 0x0108);
+	/* register CMN_TXPD_ADJ_CTRL */
+	txpd_adj_calib_code = Afe_read(state, 0x010c);
+
+	new_calib_code = ((txpu_calib_code + txpd_calib_code) / 2)
+		+ txpu_adj_calib_code + txpd_adj_calib_code;
+
+	if (new_calib_code != prev_calib_code) {
+		/* register TX_ANA_CTRL_REG_1 */
+		rdata = Afe_read(state, 0x5020);
+		rdata &= 0xDFFF;
+		/* register TX_ANA_CTRL_REG_1 */
+		Afe_write(state, 0x5020, rdata);
+		/* register TX_DIG_CTRL_REG_2 */
+		Afe_write(state, 0x5024, new_calib_code);
+		mdelay(10);
+		rdata |= 0x2000;
+		/* register TX_ANA_CTRL_REG_1 */
+		Afe_write(state, 0x5020, rdata);
+		udelay(150);
+	}
+}
+
+static void arc_config(state_struct *state)
+{
+	pr_info("arc_config() ARC programming\n");
+
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x0100);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x0300);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_3 */
+	Afe_write(state, 0x5026, 0x0000);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2008);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2018);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2098);
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x030C);
+	/* register TX_ANA_CTRL_REG_5 */
+	Afe_write(state, 0x5029, 0x0000);
+	udelay(100);
+	/* register TX_ANA_CTRL_REG_4 */
+	Afe_write(state, 0x5027, 0x4001);
+	mdelay(5);
+	/* register TX_ANA_CTRL_REG_1 */
+	Afe_write(state, 0x5020, 0x2198);
+	mdelay(5);
+	/* register TX_ANA_CTRL_REG_2 */
+	Afe_write(state, 0x5021, 0x030D);
+	udelay(100);
+	Afe_write(state, 0x5021, 0x030F);
+}
+
 int hdmi_tx_t28hpc_power_config_seq(state_struct *state, int num_lanes)
 {
 	unsigned char k;
@@ -1839,6 +1926,12 @@ int hdmi_tx_t28hpc_power_config_seq(state_struct *state, int num_lanes)
 	while (!(Afe_read(state, 0xC008) & (1 << 6)))
 		;
 
+#ifdef __ARC_CONFIG__
+	arc_power_up(state);
+	arc_calibrate(state);
+	arc_config(state);
+#endif
+
 	/* PHY_DP_MODE_CTL */
 	Afe_write(state, 0xC008, (((0x0F << num_lanes) & 0x0F) << 12) | 0x0101);
 
-- 
1.7.9.5


From 6dd40000d2006a3999ada0101ebaab7e8e685008 Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Tue, 29 May 2018 15:30:04 +0800
Subject: [PATCH 3885/5242] MLK-18421 VPU: Refine the eos progress for vpu
 decoder

commit  c81699e82d00c49fcff3469b2072b67dc4c6fbb8 from
https://source.codeaurora.org/external/imx/linux-imx.git

simplify the current design about EOS handling:
	- add_eos() is called only in V4L2_DEC_CMD_STOP, and no any block for
	application
	- stream_feed_complete: removed
	- firmware_finished: simplified and reserved only for debug
	- eos_stop_added: simplified and reserved only for debug
avoid abort hang(h264/hevc) in corner case

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/vpu_b0.c |  123 ++++++++++++++---------------------
 drivers/mxc/vpu-decoder-b0/vpu_b0.h |    1 -
 2 files changed, 49 insertions(+), 75 deletions(-)

diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index 9834d43..52a222a 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -156,15 +156,19 @@ static void vpu_log_cmd(u_int32 cmdid, u_int32 ctxid)
 	else
 		vpu_dbg(LVL_INFO, "send cmd: %s ctx id:%d\n", cmd2str[cmdid], ctxid);
 }
-#ifdef DEBUG
-static void vpu_log_stat(u_int32 status, u_int32 bufferid, u_int32 ctxid)
+
+static void vpu_log_buffer_state(struct vpu_ctx *ctx)
 {
-	if (status > sizeof(bufstat)-1)
-		vpu_dbg(LVL_INFO, "buffer status: 0x%X, buffer id:%d ctx id:%d\n", status, bufferid, ctxid);
-	else
-		vpu_dbg(LVL_INFO, "buffer status: %s, buffer id:%d ctx id:%d\n", bufstat[status], bufferid, ctxid);
+	struct vb2_data_req *p_data_req;
+	int i;
+
+	for (i = 0; i < VPU_MAX_BUFFER; i++) {
+		p_data_req = &ctx->q_data[V4L2_DST].vb2_reqs[i];
+		if (p_data_req->vb2_buf != NULL)
+			vpu_dbg(LVL_INFO, "ctx: %d, buffer[%d] status: %s\n", ctx->str_index, i, bufstat[p_data_req->status]);
+	}
 }
-#endif
+
 static int find_buffer_id(struct vpu_ctx *ctx, u_int32 addr)
 {
 	struct vb2_data_req *p_data_req;
@@ -769,23 +773,10 @@ static int v4l2_ioctl_decoder_cmd(struct file *file,
 	case V4L2_DEC_CMD_STOP: {
 		vpu_dbg(LVL_INFO, "receive V4L2_DEC_CMD_STOP\n");
 		if (!ctx->firmware_stopped)	{
-			// All stream has been fed to the decoder, now wait for a VID_API_EVENT_FIFO_LOW
-			// to signify that the decoder has consumed all stream data.
-			// ctx->stream_feed_complete is set to indicate that on the next VID_API_EVENT_FIFO_LOW
-			// the driver should respond by inserting an EOS
-			ctx->stream_feed_complete = true;
-			vpu_dbg(LVL_INFO, "END OF STREAM FED - waiting for VID_API_EVENT_FIFO_LOW\n");
-
-			ctx->stream_feed_complete = true;
-			vpu_dbg(LVL_ALL, "END OF STREAM FED - waiting for VID_API_EVENT_FIFO_LOW\n");
-			if (!wait_for_completion_timeout(&ctx->eos_cmp, msecs_to_jiffies(2000))) {
-				vpu_dbg(LVL_ERR, "wait FIFO LOW timeout, insert eos directly\n");
-				ctx->eos_stop_added = true;
-				ctx->stream_feed_complete = false;
-				v4l2_update_stream_addr(ctx, 0);
-				add_eos(ctx, 0);
-			}
-
+			vpu_dbg(LVL_INFO, "insert eos directly\n");
+			ctx->eos_stop_added = true;
+			v4l2_update_stream_addr(ctx, 0);
+			add_eos(ctx, 0);
 		} else	{
 			vpu_dbg(LVL_ERR, "Firmware already stopped !\n");
 		}
@@ -817,6 +808,9 @@ static int v4l2_ioctl_streamon(struct file *file,
 		q_data = &ctx->q_data[V4L2_DST];
 	else
 		return -EINVAL;
+
+	ctx->firmware_finished = false;
+
 	ret = vb2_streamon(&q_data->vb2_q,	i);
 	if (i == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
 		wake_up_interruptible(&ctx->buffer_wq);
@@ -845,14 +839,11 @@ static int v4l2_ioctl_streamoff(struct file *file,
 		return -EINVAL;
 
 	if (i == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
-		if (ctx->firmware_stopped || ctx->firmware_finished || ctx->eos_stop_added) {
-			vpu_dbg(LVL_ERR, "v4l2_ioctl_streamoff() - IGNORE - stopped(%d), finished(%d), eos_added(%d), feed_complete(%d)\n",
-					ctx->firmware_stopped, ctx->firmware_finished, ctx->eos_stop_added, ctx->stream_feed_complete);
+		if (ctx->firmware_stopped) {
+			vpu_dbg(LVL_ERR, "v4l2_ioctl_streamoff() - IGNORE - stopped(%d), finished(%d), eos_added(%d)\n",
+					ctx->firmware_stopped, ctx->firmware_finished, ctx->eos_stop_added);
 		} else {
 			ctx->wait_rst_done = true;
-			if (ctx->stream_feed_complete == true)
-				vpu_dbg(LVL_ERR, "v4l2_ioctl_streamoff() - EOS won't be inserted by driver\n");
-			ctx->stream_feed_complete = false;
 			vpu_dbg(LVL_INFO, "v4l2_ioctl_streamoff(): send VID_API_CMD_ABORT\n");
 
 			v4l2_vpu_send_cmd(ctx, ctx->str_index, VID_API_CMD_ABORT, 0, NULL);
@@ -862,7 +853,9 @@ static int v4l2_ioctl_streamoff(struct file *file,
 				mutex_lock(&ctx->dev->dev_mutex);
 				set_bit(ctx->str_index, &ctx->dev->hang_mask);
 				mutex_unlock(&ctx->dev->dev_mutex);
-				vpu_dbg(LVL_ERR, "the path id:%d firmware hang after send VID_API_CMD_ABORT\n", ctx->str_index);
+
+				vpu_dbg(LVL_ERR, "the path id:%d firmware hang after send VID_API_CMD_ABORT, stopped(%d), finished(%d), eos_added(%d)\n", ctx->str_index,
+					ctx->firmware_stopped, ctx->firmware_finished, ctx->eos_stop_added);
 			}
 			vpu_dbg(LVL_INFO, "receive abort done\n");
 		}
@@ -871,8 +864,13 @@ static int v4l2_ioctl_streamoff(struct file *file,
 	ret = vb2_streamoff(&q_data->vb2_q,
 			i);
 
-	if (ctx->dev->hang_mask & (1 << ctx->str_index))
+	if (ctx->dev->hang_mask & (1 << ctx->str_index)) {
+		vpu_dbg(LVL_ERR, "%s(): failed and some instance are blocked\n", __func__);
+		return -EINVAL;
+	} else if (ctx->firmware_stopped) {
+		vpu_dbg(LVL_ERR, "%s(): failed and firmware is stopped\n", __func__);
 		return -EINVAL;
+	}
 	else
 		return ret;
 }
@@ -1244,10 +1242,8 @@ static void v4l2_transfer_buffer_to_firmware(struct queue_data *This, struct vb2
 	if (ctx->start_flag == true) {
 		transfer_buffer_to_firmware(ctx, data_mapped, buffer_size, This->vdec_std);
 #ifdef HANDLE_EOS
-		if (vb->planes[0].bytesused < vb->planes[0].length) {
-			vpu_dbg(LVL_INFO, "v4l2_transfer_buffer_to_firmware - set stream_feed_complete - DEBUG 1\n")
-			ctx->stream_feed_complete = true;
-		}
+		if (vb->planes[0].bytesused < vb->planes[0].length)
+			vpu_dbg(LVL_INFO, "v4l2_transfer_buffer_to_firmware - set stream_feed_complete - DEBUG 1\n");
 #endif
 		v4l2_vpu_send_cmd(ctx, ctx->str_index, VID_API_CMD_START, 0, NULL);
 		down(&This->drv_q_lock);
@@ -1358,10 +1354,8 @@ static void v4l2_update_stream_addr(struct vpu_ctx *ctx, uint32_t uStrBufIdx)
 			return;
 		}
 #ifdef HANDLE_EOS
-		if (buffer_size < p_data_req->vb2_buf->planes[0].length) {
-			vpu_dbg(LVL_INFO, "v4l2_transfer_buffer_to_firmware - set stream_feed_complete - DEBUG 2\n")
-			ctx->stream_feed_complete = true;
-		}
+		if (buffer_size < p_data_req->vb2_buf->planes[0].length)
+			vpu_dbg(LVL_INFO, "v4l2_transfer_buffer_to_firmware - set stream_feed_complete - DEBUG 2\n");
 #endif
 		list_del(&p_data_req->list);
 		vb2_buffer_done(p_data_req->vb2_buf,
@@ -1460,6 +1454,7 @@ static void vpu_api_event_handler(struct vpu_ctx *ctx, u_int32 uStrIdx, u_int32
 	case VID_API_EVENT_STOPPED: {
 		vpu_dbg(LVL_INFO, "receive VID_API_EVENT_STOPPED\n");
 		ctx->firmware_stopped = true;
+		complete(&ctx->completion);//reduce possibility of abort hang if decoder enter stop automatically
 		complete(&ctx->stop_cmp);
 		}
 		break;
@@ -1597,9 +1592,10 @@ static void vpu_api_event_handler(struct vpu_ctx *ctx, u_int32 uStrIdx, u_int32
 			while (1) {
 				if (!wait_event_interruptible_timeout(ctx->buffer_wq,
 							((ctx->wait_rst_done == true) || (wait_right_buffer(This) == true)),
-							msecs_to_jiffies(5000)))
+							msecs_to_jiffies(5000))) {
 					vpu_dbg(LVL_ERR, " warn: wait_event_interruptible_timeout wait 5s timeout\n");
-				else
+					vpu_log_buffer_state(ctx);
+				} else
 					break;
 			}
 #endif
@@ -1720,32 +1716,13 @@ static void vpu_api_event_handler(struct vpu_ctx *ctx, u_int32 uStrIdx, u_int32
 	case VID_API_EVENT_CHUNK_DECODED:
 		break;
 	case VID_API_EVENT_FIFO_LOW: {
-		struct vpu_dev *dev = ctx->dev;
 		u_int32 uStrBufIdx = 0; //use buffer 0 for the stream
-		pSTREAM_BUFFER_DESCRIPTOR_TYPE pStrBufDesc;
 
 		if (ctx->buffer_null == true) {
 			vpu_dbg(LVL_INFO, "frame already released !!!!!!!!!!!!!!!!!\n");
 			break;
 		}
-		pStrBufDesc = dev->regs_base + DEC_MFD_XREG_SLV_BASE + MFD_MCX + MFD_MCX_OFF * ctx->str_index;
-		if (ctx->stream_feed_complete) {
-			vpu_dbg(LVL_INFO, "%s - VID_API_EVENT_FIFO_LOW - Before wptr(%x) rptr(%x) start(%x) end(%x) uStrIdx(%d)\n",
-				__func__, pStrBufDesc->wptr, pStrBufDesc->rptr, pStrBufDesc->start, pStrBufDesc->end, uStrIdx);
-			vpu_dbg(LVL_INFO, "VID_API_EVENT_FIFO_LOW - ctx->stream_feed_complete = true - add_eos\n");
-			// Indicate stop added so that we respond on a FINISHED event
-			ctx->eos_stop_added = true;
-			// Set ctx->stream_feed_complete = false so that we don't try
-			// to insert another EOS on the next VID_API_EVENT_FIFO_LOW event
-			ctx->stream_feed_complete = false;
-			v4l2_update_stream_addr(ctx, uStrBufIdx);
-			add_eos(ctx, 0);
-			complete(&ctx->eos_cmp);
-			vpu_dbg(LVL_INFO, "%s - VID_API_EVENT_FIFO_LOW - After wptr(%x) rptr(%x) start(%x) end(%x) uStrIdx(%d)\n",
-				__func__, pStrBufDesc->wptr, pStrBufDesc->rptr, pStrBufDesc->start, pStrBufDesc->end, uStrIdx);
-		} else {
-			v4l2_update_stream_addr(ctx, uStrBufIdx);
-		}
+		v4l2_update_stream_addr(ctx, uStrBufIdx);
 	} break;
 	case VID_API_EVENT_FIFO_HIGH:
 		break;
@@ -1821,17 +1798,14 @@ static void vpu_api_event_handler(struct vpu_ctx *ctx, u_int32 uStrIdx, u_int32
 			.type = V4L2_EVENT_EOS
 		};
 
-		if (ctx->eos_stop_added) {
-			if (ctx->firmware_finished == false) {
-				vpu_dbg(LVL_INFO, "receive VID_API_EVENT_FINISHED\n");
-				ctx->firmware_finished = true;
-				v4l2_event_queue_fh(&ctx->fh, &ev); //notfiy app stream eos reached
-			} else	{
-				vpu_dbg(LVL_ERR, "receive VID_API_EVENT_FINISHED when ctx->firmware_finished == true - IGNORE\n");
-			}
-		} else {
-			vpu_dbg(LVL_ERR, "receive VID_API_EVENT_FINISHED before eos_stop_added set - IGNORE\n");
-		}
+		if (ctx->eos_stop_added == false)
+			vpu_dbg(LVL_ERR, "warning: receive VID_API_EVENT_FINISHED before eos_stop_added set\n");
+		if (ctx->firmware_finished == true)
+			vpu_dbg(LVL_ERR, "warning: receive VID_API_EVENT_FINISHED when firmware_finished == true\n");
+		ctx->firmware_finished = true;
+		vpu_dbg(LVL_INFO, "receive VID_API_EVENT_FINISHED and notfiy app eos\n");
+		v4l2_event_queue_fh(&ctx->fh, &ev); //notfiy app stream eos reached
+
 	}	break;
 	default:
 		break;
@@ -2366,7 +2340,6 @@ static int v4l2_open(struct file *filp)
 	ctx->firmware_stopped = false;
 	ctx->firmware_finished = false;
 	ctx->eos_stop_added    = false;
-	ctx->stream_feed_complete = false;
 	ctx->buffer_null = true; //this flag is to judge whether the buffer is null is not, it is used for the workaround that when send stop command still can receive buffer ready event, and true means buffer is null, false not
 	ctx->ctx_released = false;
 	ctx->pSeqinfo = kzalloc(sizeof(MediaIPFW_Video_SeqInfo), GFP_KERNEL);
@@ -2467,6 +2440,8 @@ static int v4l2_release(struct file *filp)
 			mutex_unlock(&dev->dev_mutex);
 			vpu_dbg(LVL_ERR, "the path id:%d firmware hang after send VID_API_CMD_STOP\n", ctx->str_index);
 		}
+	} else {
+		vpu_dbg(LVL_ALL, "v4l2_release() - stopped(%d): skip VID_API_CMD_STOP\n", ctx->firmware_stopped);
 	}
 
 	release_queue_data(ctx);
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.h b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
index 37ee131..daebb8c 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.h
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
@@ -236,7 +236,6 @@ struct vpu_ctx {
 	bool buffer_null;
 	bool firmware_stopped;
 	bool firmware_finished;
-	bool stream_feed_complete;
 	bool eos_stop_added;
 	bool ctx_released;
 	wait_queue_head_t buffer_wq;
-- 
1.7.9.5


From 995f484515e9847f715bf0470b937c51338a6145 Mon Sep 17 00:00:00 2001
From: Leonard Crestez <leonard.crestez@nxp.com>
Date: Fri, 23 Mar 2018 17:50:00 +0200
Subject: [PATCH 1398/5242] regulator: core: Adjust supplies for bypassed
 regulators

commit  6ff91fa30322ec24f31ff6994a367aa1579f4aa8 from
https://source.codeaurora.org/external/imx/linux-imx.git

When a regulator is in bypass mode it's output is equal to it's supply
and it can't do any adjustment. Deal with all set_voltage calls by
propagating them upwards.

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/regulator/core.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index bcf7aa1..7623528 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2983,6 +2983,16 @@ static int _regulator_do_set_suspend_voltage(struct regulator_dev *rdev,
 	return 0;
 }
 
+static bool _regulator_is_bypass(struct regulator_dev *rdev)
+{
+	bool bypassed = false;
+
+	if (rdev->desc->ops->get_bypass)
+		rdev->desc->ops->get_bypass(rdev, &bypassed);
+
+	return bypassed;
+}
+
 static inline bool _regulator_should_adjust_supply(struct regulator_dev *rdev)
 {
 	/* Check for adjustable supply */
@@ -2994,6 +3004,8 @@ static inline bool _regulator_should_adjust_supply(struct regulator_dev *rdev)
 	/* Check for need to adjust supply */
 	if (rdev->desc->min_dropout_uV)
 		return true;
+	if (_regulator_is_bypass(rdev))
+		return true;
 	if (!(rdev->desc->ops->get_voltage || rdev->desc->ops->get_voltage_sel))
 		return true;
 
-- 
1.7.9.5


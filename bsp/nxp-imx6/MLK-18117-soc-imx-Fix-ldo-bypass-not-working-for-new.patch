From eaa7a8bf4b73481b622d91f5141c7e7be61e8c2a Mon Sep 17 00:00:00 2001
From: Leonard Crestez <leonard.crestez@nxp.com>
Date: Wed, 25 Apr 2018 15:00:43 +0300
Subject: [PATCH 3648/5242] MLK-18117 soc: imx: Fix ldo-bypass not working for
 new bindings

commit  b511f42defd5de588ae5dd67735e721b0b6ec17a from
https://source.codeaurora.org/external/imx/linux-imx.git

With new bindings the PU regulator is fetched much later, after
imx_gpc_probe is complete. So hack the imx_pgc_power_domain_probe
function to check for fsl,ldo-bypass at this point.

This issue only actually affects imx6qp because on other SOCs with a
vddpu regulator is it disabled on boot and settings are copied from
vddsoc on first enable, see commit 64dd7300a334 ("MLK-11407-3:
regulator: anatop: force vddpu to use same voltage level as vddsoc")

On imx6qp however disabling the PU regulator is not allowed because of
hardware errata.

Fixes: 94e8d6daea9a ("MLK-11407-1 soc: imx: gpc: enable PU bypass")

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Reviewed-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/gpc.c |   10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 7e070a1..ff37f8a 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -293,6 +293,8 @@ static int imx_pgc_parse_dt(struct device *dev, struct imx_pm_domain *domain)
 	return imx_pgc_get_clocks(dev, domain);
 }
 
+static void imx_gpc_handle_ldobypass(struct platform_device *pdev);
+
 static int imx_pgc_power_domain_probe(struct platform_device *pdev)
 {
 	struct imx_pm_domain *domain = pdev->dev.platform_data;
@@ -319,6 +321,10 @@ static int imx_pgc_power_domain_probe(struct platform_device *pdev)
 
 	device_link_add(dev, dev->parent, DL_FLAG_AUTOREMOVE);
 
+	/* Mark PU regulator as bypass */
+	if (pdev->id == 1)
+		imx_gpc_handle_ldobypass(to_platform_device(pdev->dev.parent));
+
 	return 0;
 
 genpd_err:
@@ -653,6 +659,8 @@ static int imx_gpc_probe(struct platform_device *pdev)
 					  of_id_data->num_domains);
 		if (ret)
 			return ret;
+
+		imx_gpc_handle_ldobypass(pdev);
 	} else {
 		struct imx_pm_domain *domain;
 		struct platform_device *pd_pdev;
@@ -705,8 +713,6 @@ static int imx_gpc_probe(struct platform_device *pdev)
 		}
 	}
 
-	imx_gpc_handle_ldobypass(pdev);
-
 	if (of_machine_is_compatible("fsl,imx6sx")) {
 		struct regulator *pcie_reg;
 
-- 
1.7.9.5


From 8c179dcb2a9f2ad56f9e71d87cbd0108bd154f83 Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Mon, 5 Dec 2016 13:38:22 +0800
Subject: [PATCH 1913/5242] MLK-15001-10 gpu: Add dpu base driver

commit  aacdf9525049a8c5296d7e4ac99c3a92142938ab from
https://source.codeaurora.org/external/imx/linux-imx.git

DPU is the display processing unit embedded in i.MX8qm and i.MX8qxp.
It was originally designed by Fujitsu.
The first revision has capture controller, display controller and blit engine.
The second revision is a lite one and has display controller and blit engine.
This patch adds a base driver for DPU, which provides a thin register wrapper,
interrurpt support and client platform device register for the upper layer to
use.  Currently, the driver only supports the display controller at the pixel
processing level and only the fetchdecodes are supported/tested as the fetch
units.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../bindings/display/imx/fsl-imx-drm.txt           |   70 ++
 drivers/gpu/Makefile                               |    1 +
 drivers/gpu/dpu/Kconfig                            |    9 +
 drivers/gpu/dpu/Makefile                           |    5 +
 drivers/gpu/dpu/dpu-common.c                       | 1293 ++++++++++++++++++++
 drivers/gpu/dpu/dpu-constframe.c                   |  202 +++
 drivers/gpu/dpu/dpu-disengcfg.c                    |  138 +++
 drivers/gpu/dpu/dpu-extdst.c                       |  485 ++++++++
 drivers/gpu/dpu/dpu-fetchdecode.c                  |  503 ++++++++
 drivers/gpu/dpu/dpu-fetchlayer.c                   |  295 +++++
 drivers/gpu/dpu/dpu-framegen.c                     |  366 ++++++
 drivers/gpu/dpu/dpu-layerblend.c                   |  383 ++++++
 drivers/gpu/dpu/dpu-prv.h                          |  233 ++++
 drivers/gpu/dpu/dpu-tcon.c                         |  233 ++++
 drivers/video/Kconfig                              |    1 +
 include/video/dpu.h                                |  526 ++++++++
 16 files changed, 4743 insertions(+)
 create mode 100644 drivers/gpu/dpu/Kconfig
 create mode 100644 drivers/gpu/dpu/Makefile
 create mode 100644 drivers/gpu/dpu/dpu-common.c
 create mode 100644 drivers/gpu/dpu/dpu-constframe.c
 create mode 100644 drivers/gpu/dpu/dpu-disengcfg.c
 create mode 100644 drivers/gpu/dpu/dpu-extdst.c
 create mode 100644 drivers/gpu/dpu/dpu-fetchdecode.c
 create mode 100644 drivers/gpu/dpu/dpu-fetchlayer.c
 create mode 100644 drivers/gpu/dpu/dpu-framegen.c
 create mode 100644 drivers/gpu/dpu/dpu-layerblend.c
 create mode 100644 drivers/gpu/dpu/dpu-prv.h
 create mode 100644 drivers/gpu/dpu/dpu-tcon.c
 create mode 100644 include/video/dpu.h

diff --git a/Documentation/devicetree/bindings/display/imx/fsl-imx-drm.txt b/Documentation/devicetree/bindings/display/imx/fsl-imx-drm.txt
index 5bf77f6..cb5e6c1 100644
--- a/Documentation/devicetree/bindings/display/imx/fsl-imx-drm.txt
+++ b/Documentation/devicetree/bindings/display/imx/fsl-imx-drm.txt
@@ -108,6 +108,76 @@ prg@21cc000 {
 		 <&clks IMX6QDL_CLK_PRG0_AXI>;
 	clock-names = "ipg", "axi";
 	fsl,pres = <&pre1>, <&pre2>, <&pre3>;
+
+Freescale i.MX DPU
+====================
+
+Required properties:
+- compatible: Should be "fsl,<chip>-dpu"
+- reg: should be register base and length as documented in the
+  datasheet
+- intsteer: phandle pointing to interrupt steer.
+- interrupts, interrupt-names: Should contain interrupts and names as
+  documented in the datasheet.
+- clocks, clock-names: phandles to the DPU clocks described in
+  Documentation/devicetree/bindings/clock/clock-bindings.txt
+  The following clocks are expected on i.MX8qm and i.MX8qxp:
+           "pll0" - PLL clock for display interface 0
+           "pll1" - PLL clock for display interface 1
+           "disp0" - pixel clock for display interface 0
+           "disp1" - pixel clock for display interface 1
+  The needed clock numbers for each are documented in
+  Documentation/devicetree/bindings/clock/imx8qm-clock.txt, and in
+  Documentation/devicetree/bindings/clock/imx8qxp-clock.txt.
+- power-domains: phandle pointing to power domain.
+Optional properties:
+- port@[0-1]: Port nodes with endpoint definitions as defined in
+  Documentation/devicetree/bindings/media/video-interfaces.txt.
+  ports 0 and 1 should correspond to display interface 0 and
+  display interface 1, respectively.
+
+example:
+
+dpu: dpu@56180000 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	compatible = "fsl,imx8qm-dpu";
+	reg = <0x0 0x56180000 0x0 0x40000>;
+	intsteer = <&dpu1_intsteer>;
+	interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+	interrupt-names = "irq_common",
+			  "irq_stream0a",
+			  "irq_stream0b",
+			  "irq_stream1a",
+			  "irq_stream1b",
+			  "irq_reserved0",
+			  "irq_reserved1",
+			  "irq_blit";
+	clocks = <&clk IMX8QM_DC0_PLL0_CLK>,
+		 <&clk IMX8QM_DC0_PLL1_CLK>,
+		 <&clk IMX8QM_DC0_DISP0_CLK>,
+		 <&clk IMX8QM_DC0_DISP1_CLK>;
+	clock-names = "pll0", "pll1", "disp0", "disp1";
+	power-domains = <&pd_dc0>;
+
+	dpu1_disp1: port@1 {
+		reg = <1>;
+
+		dpu1_disp1_lvds0: lvds0-endpoint {
+			remote-endpoint = <&ldb1_lvds0>;
+		};
+
+		dpu1_disp1_lvds1: lvds1-endpoint {
+			remote-endpoint = <&ldb1_lvds1>;
+		};
+	};
 };
 
 Parallel display support
diff --git a/drivers/gpu/Makefile b/drivers/gpu/Makefile
index e9ed439..3dc8f3f 100644
--- a/drivers/gpu/Makefile
+++ b/drivers/gpu/Makefile
@@ -4,3 +4,4 @@
 obj-$(CONFIG_TEGRA_HOST1X)	+= host1x/
 obj-y			+= drm/ vga/
 obj-$(CONFIG_IMX_IPUV3_CORE)	+= ipu-v3/
+obj-$(CONFIG_IMX_DPU_CORE)	+= dpu/
diff --git a/drivers/gpu/dpu/Kconfig b/drivers/gpu/dpu/Kconfig
new file mode 100644
index 0000000..1a1f5a9
--- /dev/null
+++ b/drivers/gpu/dpu/Kconfig
@@ -0,0 +1,9 @@
+config IMX_DPU_CORE
+	tristate "i.MX DPU core support"
+	depends on ARCH_FSL_IMX8QM || ARCH_FSL_IMX8QXP
+	depends on RESET_CONTROLLER
+	select GENERIC_IRQ_CHIP
+	help
+	  Choose this if you have a Freescale i.MX8QM or i.MX8QXP system and
+	  want to use the Display Processing Unit. This option only enables
+	  DPU base support.
diff --git a/drivers/gpu/dpu/Makefile b/drivers/gpu/dpu/Makefile
new file mode 100644
index 0000000..df07880
--- /dev/null
+++ b/drivers/gpu/dpu/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_IMX_DPU_CORE) += imx-dpu-core.o
+
+imx-dpu-core-objs := dpu-common.o dpu-constframe.o dpu-disengcfg.o \
+		     dpu-extdst.o dpu-fetchdecode.o dpu-framegen.o \
+		     dpu-fetchlayer.o dpu-layerblend.o dpu-tcon.o
diff --git a/drivers/gpu/dpu/dpu-common.c b/drivers/gpu/dpu/dpu-common.c
new file mode 100644
index 0000000..0f47ff9
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-common.c
@@ -0,0 +1,1293 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <soc/imx8/sc/sci.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define DPU_CM_REG_DEFINE1(name1, name2)		\
+static inline u32 name1(const struct cm_reg_ofs *ofs)	\
+{							\
+	return ofs->name2;				\
+}
+
+#define DPU_CM_REG_DEFINE2(name1, name2)		\
+static inline u32 name1(const struct cm_reg_ofs *ofs,	\
+			unsigned int n)			\
+{							\
+	return ofs->name2 + (4 * n);			\
+}
+
+DPU_CM_REG_DEFINE1(IPIDENTIFIER, ipidentifier);
+
+#define DESIGNDELIVERYID_MASK		0xF0U
+#define DESIGNDELIVERYID_SHIFT		4U
+
+#define DESIGNMATURITYLEVEL_MASK	0xF00U
+#define DESIGNMATURITYLEVEL_SHIFT	8U
+enum design_maturity_level {
+	/* Pre feasibility study. */
+	DESIGNMATURITYLEVEL__PREFS	= 1 << DESIGNMATURITYLEVEL_SHIFT,
+	/* Feasibility study. */
+	DESIGNMATURITYLEVEL__FS		= 2 << DESIGNMATURITYLEVEL_SHIFT,
+	/* Functionality complete. */
+	DESIGNMATURITYLEVEL__R0		= 3 << DESIGNMATURITYLEVEL_SHIFT,
+	/* Verification complete. */
+	DESIGNMATURITYLEVEL__R1		= 4 << DESIGNMATURITYLEVEL_SHIFT,
+};
+
+#define IPEVOLUTION_MASK		0xF000U
+#define IPEVOLUTION_SHIFT		12U
+
+#define IPFEATURESET_MASK		0xF0000U
+#define IPFEATURESET_SHIFT		16U
+enum ip_feature_set {
+	/* Minimal functionality (Eco). */
+	IPFEATURESET__E = 1 << IPFEATURESET_SHIFT,
+	/* Reduced functionality (Light). */
+	IPFEATURESET__L = 2 << IPFEATURESET_SHIFT,
+	/* Advanced functionality (Plus). */
+	IPFEATURESET__P = 4 << IPFEATURESET_SHIFT,
+	/* Extensive functionality (eXtensive). */
+	IPFEATURESET__X = 5 << IPFEATURESET_SHIFT,
+};
+
+#define IPAPPLICATION_MASK		0xF00000U
+#define IPAPPLICATION_SHIFT		20U
+enum ip_application {
+	/* Blit Engine only. */
+	IPAPPLICATION__B = 1 << IPAPPLICATION_SHIFT,
+	/* Blit Engine and Display Controller. */
+	IPAPPLICATION__D = 2 << IPAPPLICATION_SHIFT,
+	/* Display Controller only (with direct capture). */
+	IPAPPLICATION__V = 3 << IPAPPLICATION_SHIFT,
+	/*
+	 * Blit Engine, Display Controller (with direct capture),
+	 * Capture Controller (buffered capture) and Drawing Engine.
+	 */
+	IPAPPLICATION__G = 4 << IPAPPLICATION_SHIFT,
+	/* Display Controller only. */
+	IPAPPLICATION__C = 5 << IPAPPLICATION_SHIFT,
+};
+
+#define IPCONFIGURATION_MASK		0xF000000U
+#define IPCONFIGURATION_SHIFT		24U
+enum ip_configuration {
+	/* Graphics core only (Module). */
+	IPCONFIGURATION__M = 1 << IPCONFIGURATION_SHIFT,
+	/* Subsystem including a graphics core (System). */
+	IPCONFIGURATION__S = 2 << IPCONFIGURATION_SHIFT,
+};
+
+#define IPFAMILY_MASK			0xF0000000U
+#define IPFAMILY_SHIFT			28U
+enum ip_family {
+	/* IMXDPU building block generation 2010. */
+	IPFAMILY__IMXDPU2010 = 0,
+	/* IMXDPU building block generation 2012. */
+	IPFAMILY__IMXDPU2012 = 1 << IPFAMILY_SHIFT,
+	/* IMXDPU building block generation 2013. */
+	IPFAMILY__IMXDPU2013 = 2 << IPFAMILY_SHIFT,
+};
+
+DPU_CM_REG_DEFINE1(LOCKUNLOCK, lockunlock);
+DPU_CM_REG_DEFINE1(LOCKSTATUS, lockstatus);
+DPU_CM_REG_DEFINE2(USERINTERRUPTMASK, userinterruptmask);
+DPU_CM_REG_DEFINE2(INTERRUPTENABLE, interruptenable);
+DPU_CM_REG_DEFINE2(INTERRUPTPRESET, interruptpreset);
+DPU_CM_REG_DEFINE2(INTERRUPTCLEAR, interruptclear);
+DPU_CM_REG_DEFINE2(INTERRUPTSTATUS, interruptstatus);
+DPU_CM_REG_DEFINE2(USERINTERRUPTENABLE, userinterruptenable);
+DPU_CM_REG_DEFINE2(USERINTERRUPTPRESET, userinterruptpreset);
+DPU_CM_REG_DEFINE2(USERINTERRUPTCLEAR, userinterruptclear);
+DPU_CM_REG_DEFINE2(USERINTERRUPTSTATUS, userinterruptstatus);
+DPU_CM_REG_DEFINE1(GENERALPURPOSE, generalpurpose);
+
+static inline u32 dpu_cm_read(struct dpu_soc *dpu, unsigned int offset)
+{
+	return readl(dpu->cm_reg + offset);
+}
+
+static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
+				unsigned int offset)
+{
+	writel(value, dpu->cm_reg + offset);
+}
+
+/* Constant Frame Unit */
+static const unsigned long cf_ofss[] = {0x4400, 0x5400, 0x4c00, 0x5c00};
+static const unsigned long cf_pec_ofss_v1[] = {0x980, 0xa00, 0x9c0, 0xa40};
+static const unsigned long cf_pec_ofss_v2[] = {0x960, 0x9e0, 0x9a0, 0xa20};
+
+/* Display Engine Configuration Unit */
+static const unsigned long dec_ofss_v1[] = {0x10000, 0x10020};
+static const unsigned long dec_ofss_v2[] = {0xb400, 0xb420};
+
+/* External Destination Unit */
+static const unsigned long ed_ofss[] = {0x4800, 0x5800, 0x5000, 0x6000};
+static const unsigned long ed_pec_ofss_v1[] = {0x9a0, 0xa20, 0x9e0, 0xa60};
+static const unsigned long ed_pec_ofss_v2[] = {0x980, 0xa00, 0x9c0, 0xa40};
+
+/* Fetch Decode Unit */
+static const unsigned long fd_ofss_v1[] = {0x8c00, 0x9800, 0x7400, 0x7c00};
+static const unsigned long fd_ofss_v2[] = {0x6c00, 0x7800};
+static const unsigned long fd_pec_ofss_v1[] = {0xb60, 0xb80, 0xb00, 0xb20};
+static const unsigned long fd_pec_ofss_v2[] = {0xa80, 0xaa0};
+
+/* Frame Generator Unit */
+static const unsigned long fg_ofss_v1[] = {0x10c00, 0x12800};
+static const unsigned long fg_ofss_v2[] = {0xb800, 0xd400};
+
+/* Fetch Layer Unit */
+static const unsigned long fl_ofss_v1[] = {0xa400, 0xac00};
+static const unsigned long fl_ofss_v2[] = {0x8400};
+static const unsigned long fl_pec_ofss_v1[] = {0xba0, 0xbb0};
+static const unsigned long fl_pec_ofss_v2[] = {0xac0};
+
+/* Layer Blend Unit */
+static const unsigned long lb_ofss_v1[] = {0xdc00, 0xe000, 0xe400, 0xe800,
+					   0xec00, 0xf000, 0xf400};
+static const unsigned long lb_ofss_v2[] = {0xa400, 0xa800, 0xac00, 0xb000};
+static const unsigned long lb_pec_ofss_v1[] = {0xd00, 0xd20, 0xd40, 0xd60,
+					       0xd80, 0xda0, 0xdc0};
+static const unsigned long lb_pec_ofss_v2[] = {0xba0, 0xbc0, 0xbe0, 0xc00};
+
+/* Timing Controller Unit */
+static const unsigned long tcon_ofss_v1[] = {0x12000, 0x13c00};
+static const unsigned long tcon_ofss_v2[] = {0xcc00, 0xe800};
+
+static const struct dpu_unit cfs_v1 = {
+	.name = "ConstFrame",
+	.num = ARRAY_SIZE(cf_ids),
+	.ids = cf_ids,
+	.pec_ofss = cf_pec_ofss_v1,
+	.ofss = cf_ofss,
+};
+
+static const struct dpu_unit cfs_v2 = {
+	.name = "ConstFrame",
+	.num = ARRAY_SIZE(cf_ids),
+	.ids = cf_ids,
+	.pec_ofss = cf_pec_ofss_v2,
+	.ofss = cf_ofss,
+};
+
+static const struct dpu_unit decs_v1 = {
+	.name = "DisEngCfg",
+	.num = ARRAY_SIZE(dec_ids),
+	.ids = dec_ids,
+	.pec_ofss = NULL,
+	.ofss = dec_ofss_v1,
+};
+
+static const struct dpu_unit decs_v2 = {
+	.name = "DisEngCfg",
+	.num = ARRAY_SIZE(dec_ids),
+	.ids = dec_ids,
+	.pec_ofss = NULL,
+	.ofss = dec_ofss_v2,
+};
+
+static const struct dpu_unit eds_v1 = {
+	.name = "ExtDst",
+	.num = ARRAY_SIZE(ed_ids),
+	.ids = ed_ids,
+	.pec_ofss = ed_pec_ofss_v1,
+	.ofss = ed_ofss,
+};
+
+static const struct dpu_unit eds_v2 = {
+	.name = "ExtDst",
+	.num = ARRAY_SIZE(ed_ids),
+	.ids = ed_ids,
+	.pec_ofss = ed_pec_ofss_v2,
+	.ofss = ed_ofss,
+};
+
+static const struct dpu_unit fds_v1 = {
+	.name = "FetchDecode",
+	.num = ARRAY_SIZE(fd_ids),
+	.ids = fd_ids,
+	.pec_ofss = fd_pec_ofss_v1,
+	.ofss = fd_ofss_v1,
+};
+
+static const struct dpu_unit fds_v2 = {
+	.name = "FetchDecode",
+	.num = 2,
+	.ids = fd_ids,
+	.pec_ofss = fd_pec_ofss_v2,
+	.ofss = fd_ofss_v2,
+};
+
+static const struct dpu_unit fgs_v1 = {
+	.name = "FrameGen",
+	.num = ARRAY_SIZE(fg_ids),
+	.ids = fg_ids,
+	.pec_ofss = NULL,
+	.ofss = fg_ofss_v1,
+};
+
+static const struct dpu_unit fgs_v2 = {
+	.name = "FrameGen",
+	.num = ARRAY_SIZE(fg_ids),
+	.ids = fg_ids,
+	.pec_ofss = NULL,
+	.ofss = fg_ofss_v2,
+};
+
+static const struct dpu_unit fls_v1 = {
+	.name = "FetchLayer",
+	.num = ARRAY_SIZE(fl_ids),
+	.ids = fl_ids,
+	.pec_ofss = fl_pec_ofss_v1,
+	.ofss = fl_ofss_v1,
+};
+
+static const struct dpu_unit fls_v2 = {
+	.name = "FetchLayer",
+	.num = 1,
+	.ids = fl_ids,
+	.pec_ofss = fl_pec_ofss_v2,
+	.ofss = fl_ofss_v2,
+};
+
+static const struct dpu_unit lbs_v1 = {
+	.name = "LayerBlend",
+	.num = ARRAY_SIZE(lb_ids),
+	.ids = lb_ids,
+	.pec_ofss = lb_pec_ofss_v1,
+	.ofss = lb_ofss_v1,
+};
+
+static const struct dpu_unit lbs_v2 = {
+	.name = "LayerBlend",
+	.num = 4,
+	.ids = lb_ids,
+	.pec_ofss = lb_pec_ofss_v2,
+	.ofss = lb_ofss_v2,
+};
+
+static const struct dpu_unit tcons_v1 = {
+	.name = "TCon",
+	.num = ARRAY_SIZE(tcon_ids),
+	.ids = tcon_ids,
+	.pec_ofss = NULL,
+	.ofss = tcon_ofss_v1,
+};
+
+static const struct dpu_unit tcons_v2 = {
+	.name = "TCon",
+	.num = ARRAY_SIZE(tcon_ids),
+	.ids = tcon_ids,
+	.pec_ofss = NULL,
+	.ofss = tcon_ofss_v2,
+};
+
+static const struct cm_reg_ofs cm_reg_ofs_v1 = {
+	.ipidentifier = 0,
+	.lockunlock = 0x80,
+	.lockstatus = 0x84,
+	.userinterruptmask = 0x88,
+	.interruptenable = 0x94,
+	.interruptpreset = 0xa0,
+	.interruptclear = 0xac,
+	.interruptstatus = 0xb8,
+	.userinterruptenable = 0x100,
+	.userinterruptpreset = 0x10c,
+	.userinterruptclear = 0x118,
+	.userinterruptstatus = 0x124,
+	.generalpurpose = 0x200,
+};
+
+static const struct cm_reg_ofs cm_reg_ofs_v2 = {
+	.ipidentifier = 0,
+	.lockunlock = 0x40,
+	.lockstatus = 0x44,
+	.userinterruptmask = 0x48,
+	.interruptenable = 0x50,
+	.interruptpreset = 0x58,
+	.interruptclear = 0x60,
+	.interruptstatus = 0x68,
+	.userinterruptenable = 0x80,
+	.userinterruptpreset = 0x88,
+	.userinterruptclear = 0x90,
+	.userinterruptstatus = 0x98,
+	.generalpurpose = 0x100,
+};
+
+static const unsigned int intsteer_map_v1[] = {
+	/*  0    1    2    3    4    5    6    7 */	/*  0~31: int0 */
+	  448, 449, 450,  64,  65,  66,  67,  68,
+	/*  8    9   10   11   12   13   14   15 */
+	   69,  70, 193, 194, 195, 196, 197, 320,
+	/* 16   17   18   19   20   21   22   23 */
+	  321, 322, 384, 385, 386,  NA, 323,  NA,
+	/* 24   25   26   27   28   29   30   31 */
+	  387,  71, 198,  72,  73,  74,  75,  76,
+	/* 32   33   34   35   36   37   38   39 */	/* 32~63: int1 */
+	   77,  78,  79,  80,  81, 199, 200, 201,
+	/* 40   41   42   43   44   45   46   47 */
+	  202, 203, 204, 205, 206, 207, 208, 324,
+	/* 48   49   50   51   52   53   54   55 */
+	  389,  NA,   0,   1,   2,   3,   4,  82,
+	/* 56   57   58   59   60   61   62   63 */
+	   83,  84,  85, 209, 210, 211, 212, 325,
+	/* 64   65   66 */				/*   64+: int2 */
+	  326, 390, 391,
+};
+static const unsigned long unused_irq_v1[] = {0x00a00000, 0x00020000,
+					      0xfffffff8};
+
+static const unsigned int intsteer_map_v2[] = {
+	/*  0    1    2    3    4    5    6    7 */	/*  0~31: int0 */
+	  448, 449, 450,  64,  65,  66,  67,  68,
+	/*  8    9   10   11   12   13   14   15 */
+	   69,  70, 193, 194, 195, 196, 197,  72,
+	/* 16   17   18   19   20   21   22   23 */
+	   73,  74,  75,  76,  77,  78,  79,  80,
+	/* 24   25   26   27   28   29   30   31 */
+	   81, 199, 200, 201, 202, 203, 204, 205,
+	/* 32   33   34   35   36   37   38   39 */	/*   32+: int1 */
+	  206, 207, 208,  NA,   0,   1,   2,   3,
+	/* 40   41   42   43   44   45   46   47 */
+	    4,  82,  83,  84,  85, 209, 210, 211,
+	/* 48 */
+	  212,
+};
+static const unsigned long unused_irq_v2[] = {0x00000000, 0xfffe0008};
+
+static const unsigned int sw2hw_irq_map_v2[] = {
+	/*  0    1    2    3    4    5    6    7 */
+	    0,   1,   2,   3,   4,   5,   6,   7,
+	/*  8    9   10   11   12   13   14   15 */
+	    8,   9,  10,  11,  12,  13,  14,  NA,
+	/* 16   17   18   19   20   21   22   23 */
+	   NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,
+	/* 24   25   26   27   28   29   30   31 */
+	   NA,  NA,  NA,  15,  16,  17,  18,  19,
+	/* 32   33   34   35   36   37   38   39 */
+	   20,  21,  22,  23,  24,  25,  26,  27,
+	/* 40   41   42   43   44   45   46   47 */
+	   28,  29,  30,  31,  32,  33,  34,  NA,
+	/* 48   49   50   51   52   53   54   55 */
+	   NA,  NA,  36,  37,  38,  39,  40,  41,
+	/* 56   57   58   59   60   61   62   63 */
+	   42,  43,  44,  45,  46,  47,  48,  NA,
+	/* 64   65   66 */
+	   NA,  NA,  NA,
+};
+
+/* FIXME: overkill for some N/As, revive them when needed */
+static const unsigned int sw2hw_block_id_map_v2[] = {
+	/*   0     1     2     3     4     5     6     7 */
+	  0x00,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
+	/*   8     9    10    11    12    13    14    15 */
+	    NA,   NA, 0x0a,   NA, 0x0c,   NA, 0x0e,   NA,
+	/*  16    17    18    19    20    21    22    23 */
+	  0x10,   NA, 0x12,   NA,   NA,   NA,   NA,   NA,
+	/*  24    25    26    27    28    29    30    31 */
+	    NA,   NA, 0x14,   NA, 0x16,   NA, 0x18,   NA,
+	/*  32    33    34    35    36    37    38    39 */
+	  0x1a,   NA,   NA, 0x1b, 0x1c, 0x1d,   NA,   NA,
+	/*  40    41    42    43    44    45    46    47 */
+	  0x1e, 0x1f, 0x20,   NA, 0x21, 0x22, 0x23, 0x24,
+	/*  48    49    50    51    52    53    54    55 */
+	    NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
+	/*  56    57    58    59    60    61    62    63 */
+	    NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
+	/*  64    65    66    67 */
+	    NA,   NA,   NA,   NA,
+};
+
+static const struct dpu_devtype dpu_type_v1 = {
+	.cm_ofs = 0x0,
+	.cfs = &cfs_v1,
+	.decs = &decs_v1,
+	.eds = &eds_v1,
+	.fds = &fds_v1,
+	.fgs = &fgs_v1,
+	.fls = &fls_v1,
+	.lbs = &lbs_v1,
+	.tcons = &tcons_v1,
+	.cm_reg_ofs = &cm_reg_ofs_v1,
+	.intsteer_map = intsteer_map_v1,
+	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v1),
+	.unused_irq = unused_irq_v1,
+	.has_capture = true,
+	.pixel_link_quirks = false,
+	.pixel_link_nhvsync = false,
+	.version = DPU_V1,
+};
+
+static const struct dpu_devtype dpu_type_v2 = {
+	.cm_ofs = 0x0,
+	.cfs = &cfs_v2,
+	.decs = &decs_v2,
+	.eds = &eds_v2,
+	.fds = &fds_v2,
+	.fgs = &fgs_v2,
+	.fls = &fls_v2,
+	.lbs = &lbs_v2,
+	.tcons = &tcons_v2,
+	.cm_reg_ofs = &cm_reg_ofs_v2,
+	.intsteer_map = intsteer_map_v2,
+	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v2),
+	.unused_irq = unused_irq_v2,
+	.sw2hw_irq_map = sw2hw_irq_map_v2,
+	.sw2hw_block_id_map = sw2hw_block_id_map_v2,
+	.has_capture = false,
+	.pixel_link_quirks = true,
+	.pixel_link_nhvsync = true,
+	.version = DPU_V2,
+};
+
+static const struct of_device_id dpu_dt_ids[] = {
+	{ .compatible = "fsl,imx8qm-dpu", .data = &dpu_type_v2, },
+	{ .compatible = "fsl,imx8qxp-dpu", .data = &dpu_type_v2, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, dpu_dt_ids);
+
+#define DPU_UNIT_INIT(dpu, base, unit, name, id, pec_ofs, ofs)		\
+{									\
+	int ret;							\
+	ret = dpu_##unit##_init((dpu),	(id),				\
+				(pec_ofs) ? (base) + (pec_ofs) : 0,	\
+				(base) + (ofs));			\
+	if (ret) {							\
+		dev_err((dpu)->dev, "init %s%d failed with %d\n",	\
+						(name), (id), ret);	\
+		return ret;						\
+	}								\
+}
+
+#define DPU_UNITS_INIT(unit)						\
+{									\
+	const struct dpu_unit *us = devtype->unit##s;			\
+	int i;								\
+									\
+	/* software check */						\
+	if (WARN_ON(us->num > ARRAY_SIZE(unit##_ids)))			\
+		return -EINVAL;						\
+									\
+	for (i = 0; i < us->num; i++)					\
+		DPU_UNIT_INIT(dpu, dpu_base, unit, us->name,		\
+			      us->ids[i],				\
+			      us->pec_ofss ? us->pec_ofss[i] : 0,	\
+			      us->ofss[i]);				\
+}
+
+static int dpu_submodules_init(struct dpu_soc *dpu,
+		struct platform_device *pdev, unsigned long dpu_base)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+
+	DPU_UNITS_INIT(cf);
+	DPU_UNITS_INIT(dec);
+	DPU_UNITS_INIT(ed);
+	DPU_UNITS_INIT(fd);
+	DPU_UNITS_INIT(fg);
+	DPU_UNITS_INIT(fl);
+	DPU_UNITS_INIT(lb);
+	DPU_UNITS_INIT(tcon);
+
+	return 0;
+}
+
+#define DPU_UNITS_ADDR_DBG(unit)					\
+{									\
+	const struct dpu_unit *us = devtype->unit##s;			\
+	int i;								\
+	for (i = 0; i < us->num; i++) {					\
+		if (us->pec_ofss) {					\
+			dev_dbg(&pdev->dev, "%s%d: pixengcfg @ 0x%08lx,"\
+				" unit @ 0x%08lx\n", us->name,		\
+				us->ids[i],				\
+				dpu_base + us->pec_ofss[i],		\
+				dpu_base + us->ofss[i]);		\
+		} else {						\
+			dev_dbg(&pdev->dev,				\
+				"%s%d: unit @ 0x%08lx\n", us->name,	\
+				us->ids[i], dpu_base + us->ofss[i]);	\
+		}							\
+	}								\
+}
+
+enum dpu_irq_line {
+	DPU_IRQ_LINE_CM = 0,
+	DPU_IRQ_LINE_STREAM0A = 1,
+	DPU_IRQ_LINE_STREAM1A = 3,
+	DPU_IRQ_LINE_RESERVED0 = 5,
+	DPU_IRQ_LINE_RESERVED1 = 6,
+	DPU_IRQ_LINE_BLIT = 7,
+};
+
+static inline unsigned int dpu_get_max_intsteer_num(enum dpu_irq_line irq_line)
+{
+	return 64 * (++irq_line) - 1;
+}
+
+static inline unsigned int dpu_get_min_intsteer_num(enum dpu_irq_line irq_line)
+{
+	return 64 * irq_line;
+}
+
+static void dpu_irq_handle(struct irq_desc *desc, enum dpu_irq_line irq_line)
+{
+	struct dpu_soc *dpu = irq_desc_get_handler_data(desc);
+	const struct dpu_devtype *devtype = dpu->devtype;
+	const struct cm_reg_ofs *ofs = devtype->cm_reg_ofs;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned int i, virq, min_intsteer_num, max_intsteer_num;
+	u32 status;
+
+	chained_irq_enter(chip, desc);
+
+	min_intsteer_num = dpu_get_min_intsteer_num(irq_line);
+	max_intsteer_num = dpu_get_max_intsteer_num(irq_line);
+
+	for (i = 0; i < devtype->intsteer_map_size; i++) {
+		if (devtype->intsteer_map[i] >= min_intsteer_num &&
+		    devtype->intsteer_map[i] <= max_intsteer_num) {
+			status = dpu_cm_read(dpu,
+					USERINTERRUPTSTATUS(ofs, i / 32));
+			status &= dpu_cm_read(dpu,
+					USERINTERRUPTENABLE(ofs, i / 32));
+
+			if (status & BIT(i % 32)) {
+				virq = irq_linear_revmap(dpu->domain, i);
+				if (virq) {
+					generic_handle_irq(virq);
+				}
+			}
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+#define DPU_IRQ_HANDLER_DEFINE(name1, name2)			\
+static void dpu_##name1##_irq_handler(struct irq_desc *desc)	\
+{								\
+	dpu_irq_handle(desc, DPU_IRQ_LINE_##name2);		\
+}
+
+DPU_IRQ_HANDLER_DEFINE(cm, CM)
+DPU_IRQ_HANDLER_DEFINE(stream0a, STREAM0A)
+DPU_IRQ_HANDLER_DEFINE(stream1a, STREAM1A)
+DPU_IRQ_HANDLER_DEFINE(reserved0, RESERVED0)
+DPU_IRQ_HANDLER_DEFINE(reserved1, RESERVED1)
+DPU_IRQ_HANDLER_DEFINE(blit, BLIT)
+
+int dpu_map_irq(struct dpu_soc *dpu, int irq)
+{
+	const unsigned int *sw2hw_irq_map = dpu->devtype->sw2hw_irq_map;
+	int virq, mapped_irq;
+
+	mapped_irq = sw2hw_irq_map ? sw2hw_irq_map[irq] : irq;
+	if (WARN_ON(mapped_irq == NA))
+		return -EINVAL;
+
+	virq = irq_linear_revmap(dpu->domain, mapped_irq);
+	if (!virq)
+		virq = irq_create_mapping(dpu->domain, mapped_irq);
+
+	return virq;
+}
+EXPORT_SYMBOL_GPL(dpu_map_irq);
+
+static int platform_remove_devices_fn(struct device *dev, void *unused)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
+static void platform_device_unregister_children(struct platform_device *pdev)
+{
+	device_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);
+}
+
+struct dpu_platform_reg {
+	struct dpu_client_platformdata pdata;
+	const char *name;
+};
+
+static struct dpu_platform_reg client_reg[] = {
+	{
+		/* placeholder */
+		.pdata = { },
+		.name = "imx-dpu-csi",
+	}, {
+		/* placeholder */
+		.pdata = { },
+		.name = "imx-dpu-csi",
+	}, {
+		.pdata = {
+			.stream_id = 0,
+		},
+		.name = "imx-dpu-crtc",
+	}, {
+		.pdata = {
+			.stream_id = 1,
+		},
+		.name = "imx-dpu-crtc",
+	},
+};
+
+static DEFINE_MUTEX(dpu_client_id_mutex);
+static int dpu_client_id;
+
+static int dpu_get_plane_resource(struct dpu_soc *dpu,
+				  struct dpu_plane_res *res)
+{
+	const struct dpu_unit *fds = dpu->devtype->fds;
+	const struct dpu_unit *lbs = dpu->devtype->lbs;
+	struct dpu_plane_grp *grp = plane_res_to_grp(res);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(res->cf); i++) {
+		res->cf[i] = dpu_cf_get(dpu, i);
+		if (IS_ERR(res->cf[i]))
+			return PTR_ERR(res->cf[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->ed); i++) {
+		res->ed[i] = dpu_ed_get(dpu, i);
+		if (IS_ERR(res->ed[i]))
+			return PTR_ERR(res->ed[i]);
+	}
+	for (i = 0; i < fds->num; i++) {
+		res->fd[i] = dpu_fd_get(dpu, i);
+		if (IS_ERR(res->fd[i]))
+			return PTR_ERR(res->fd[i]);
+	}
+	for (i = 0; i < lbs->num; i++) {
+		res->lb[i] = dpu_lb_get(dpu, i);
+		if (IS_ERR(res->lb[i]))
+			return PTR_ERR(res->lb[i]);
+	}
+
+	grp->hw_plane_num = fds->num;
+
+	return 0;
+}
+
+static void dpu_put_plane_resource(struct dpu_plane_res *res)
+{
+	struct dpu_plane_grp *grp = plane_res_to_grp(res);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(res->cf); i++) {
+		if (!IS_ERR_OR_NULL(res->cf[i]))
+			dpu_cf_put(res->cf[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->ed); i++) {
+		if (!IS_ERR_OR_NULL(res->ed[i]))
+			dpu_ed_put(res->ed[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->fd); i++) {
+		if (!IS_ERR_OR_NULL(res->fd[i]))
+			dpu_fd_put(res->fd[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->lb); i++) {
+		if (!IS_ERR_OR_NULL(res->lb[i]))
+			dpu_lb_put(res->lb[i]);
+	}
+
+	grp->hw_plane_num = 0;
+}
+
+static int dpu_add_client_devices(struct dpu_soc *dpu)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+	struct device *dev = dpu->dev;
+	struct dpu_platform_reg *reg;
+	struct dpu_plane_grp *plane_grp;
+	size_t client_num, reg_size;
+	int i, id, ret;
+
+	client_num = ARRAY_SIZE(client_reg);
+	if (!devtype->has_capture)
+		client_num -= 2;
+
+	reg = devm_kcalloc(dev, client_num, sizeof(*reg), GFP_KERNEL);
+	if (!reg)
+		return -ENODEV;
+
+	plane_grp = devm_kzalloc(dev, sizeof(*plane_grp), GFP_KERNEL);
+	if (!plane_grp)
+		return -ENODEV;
+
+	mutex_lock(&dpu_client_id_mutex);
+	id = dpu_client_id;
+	dpu_client_id += client_num;
+	mutex_unlock(&dpu_client_id_mutex);
+
+	reg_size = client_num * sizeof(struct dpu_platform_reg);
+	if (devtype->has_capture)
+		memcpy(reg, client_reg, reg_size);
+	else
+		memcpy(reg, &client_reg[2], reg_size);
+
+	INIT_LIST_HEAD(&plane_grp->list);
+	mutex_init(&plane_grp->lock);
+	plane_grp->id = id / client_num;
+
+	ret = dpu_get_plane_resource(dpu, &plane_grp->res);
+	if (ret)
+		goto err_get_plane_res;
+
+	for (i = 0; i < client_num; i++) {
+		struct platform_device *pdev;
+		struct device_node *of_node;
+		bool is_disp;
+
+		if (devtype->has_capture)
+			is_disp = (i / 2) ? true : false;
+		else
+			is_disp = true;
+
+		/* Associate subdevice with the corresponding port node */
+		of_node = of_graph_get_port_by_id(dev->of_node, i);
+		if (!of_node) {
+			dev_info(dev, "no port@%d node in %s, not using %s%d\n",
+				 i, dev->of_node->full_name,
+				 is_disp ? "DISP" : "CSI", i % 2);
+			continue;
+		}
+
+		if (is_disp)
+			reg[i].pdata.plane_grp = plane_grp;
+
+		pdev = platform_device_alloc(reg[i].name, id++);
+		if (!pdev) {
+			ret = -ENOMEM;
+			goto err_register;
+		}
+
+		pdev->dev.parent = dev;
+
+		reg[i].pdata.of_node = of_node;
+		ret = platform_device_add_data(pdev, &reg[i].pdata,
+					       sizeof(reg[i].pdata));
+		if (!ret)
+			ret = platform_device_add(pdev);
+		if (ret) {
+			platform_device_put(pdev);
+			goto err_register;
+		}
+	}
+
+	return 0;
+
+err_register:
+	platform_device_unregister_children(to_platform_device(dev));
+err_get_plane_res:
+	dpu_put_plane_resource(&plane_grp->res);
+
+	return ret;
+}
+
+#define IRQSTEER_CHANnCTL	0x0
+#define IRQSTEER_CHANnCTL_CH(n)	BIT(n)
+#define IRQSTEER_CHANnMASK(n)	((n) + 4)
+#define LINE_TO_MASK_OFFSET(n)	((15 - ((n) / 32)) * 4)
+#define LINE_TO_MASK_SHIFT(n)	((n) % 32)
+
+static void dpu_irq_gc_mask_set_bit(struct irq_data *d)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	struct dpu_soc *dpu = gc->domain->host_data;
+	unsigned long flags;
+	u32 mask = d->mask;
+
+	irq_gc_lock(gc);
+	spin_lock_irqsave(&dpu->intsteer_lock, flags);
+	if (++dpu->intsteer_usecount == 1)
+		/* assuming fast I/O regmap */
+		regmap_write(dpu->intsteer_regmap, IRQSTEER_CHANnCTL,
+				IRQSTEER_CHANnCTL_CH(0));
+	spin_unlock_irqrestore(&dpu->intsteer_lock, flags);
+	*ct->mask_cache |= mask;
+	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
+	irq_gc_unlock(gc);
+}
+
+static void dpu_irq_gc_mask_clr_bit(struct irq_data *d)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	struct dpu_soc *dpu = gc->domain->host_data;
+	unsigned long flags;
+	u32 mask = d->mask;
+
+	irq_gc_lock(gc);
+	spin_lock_irqsave(&dpu->intsteer_lock, flags);
+	if (!--dpu->intsteer_usecount) {
+		WARN(dpu->intsteer_usecount < 0,
+			"intsteer usecount %d is less than zero",
+			dpu->intsteer_usecount);
+		regmap_write(dpu->intsteer_regmap, IRQSTEER_CHANnCTL, 0);
+	}
+	spin_unlock_irqrestore(&dpu->intsteer_lock, flags);
+	*ct->mask_cache &= ~mask;
+	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
+	irq_gc_unlock(gc);
+}
+
+static void dpu_intsteer_enable_line(struct dpu_soc *dpu, unsigned int line)
+{
+	unsigned int offset = LINE_TO_MASK_OFFSET(line);
+	unsigned int shift = LINE_TO_MASK_SHIFT(line);
+
+	regmap_update_bits(dpu->intsteer_regmap, IRQSTEER_CHANnMASK(offset),
+			   BIT(shift), BIT(shift));
+}
+
+static int dpu_irq_init(struct dpu_soc *dpu)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+	const struct cm_reg_ofs *ofs = devtype->cm_reg_ofs;
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+	int ret, i;
+
+	for (i = 0; i < devtype->intsteer_map_size; i++) {
+		if (devtype->intsteer_map[i] == NA)
+			continue;
+
+		dpu_intsteer_enable_line(dpu, devtype->intsteer_map[i]);
+	}
+
+	dpu->domain = irq_domain_add_linear(dpu->dev->of_node,
+					    devtype->intsteer_map_size,
+					    &irq_generic_chip_ops, dpu);
+	if (!dpu->domain) {
+		dev_err(dpu->dev, "failed to add irq domain\n");
+		return -ENODEV;
+	}
+
+	ret = irq_alloc_domain_generic_chips(dpu->domain, 32, 1, "DPU",
+					     handle_level_irq, 0, 0, 0);
+	if (ret < 0) {
+		dev_err(dpu->dev, "failed to alloc generic irq chips\n");
+		irq_domain_remove(dpu->domain);
+		return ret;
+	}
+
+	for (i = 0; i < devtype->intsteer_map_size; i += 32) {
+		/* Mask and clear all interrupts */
+		dpu_cm_write(dpu, 0,
+					USERINTERRUPTENABLE(ofs, i / 32));
+		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
+					USERINTERRUPTCLEAR(ofs, i / 32));
+		dpu_cm_write(dpu, 0,
+					INTERRUPTENABLE(ofs, i / 32));
+		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
+					INTERRUPTCLEAR(ofs, i / 32));
+
+		/* Set all interrupts to user mode */
+		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
+					USERINTERRUPTMASK(ofs, i / 32));
+
+		gc = irq_get_domain_generic_chip(dpu->domain, i);
+		gc->reg_base = dpu->cm_reg;
+		gc->unused = devtype->unused_irq[i / 32];
+		ct = gc->chip_types;
+		ct->chip.irq_ack = irq_gc_ack_set_bit;
+		ct->chip.irq_mask = dpu_irq_gc_mask_clr_bit;
+		ct->chip.irq_unmask = dpu_irq_gc_mask_set_bit;
+		ct->regs.ack = USERINTERRUPTCLEAR(ofs, i / 32);
+		ct->regs.mask = USERINTERRUPTENABLE(ofs, i / 32);
+	}
+
+#define DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(name)	\
+irq_set_chained_handler_and_data(dpu->irq_##name, dpu_##name##_irq_handler, dpu)
+
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(cm);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(stream0a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(stream1a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(reserved0);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(reserved1);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(blit);
+
+	return 0;
+}
+
+static void dpu_irq_exit(struct dpu_soc *dpu)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+	unsigned int i, irq;
+
+#define DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(name)	\
+irq_set_chained_handler_and_data(dpu->irq_##name, NULL, NULL)
+
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(cm);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(stream0a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(stream1a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(reserved0);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(reserved1);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(blit);
+
+	for (i = 0; i < devtype->intsteer_map_size; i++) {
+		irq = irq_linear_revmap(dpu->domain, i);
+		if (irq)
+			irq_dispose_mapping(irq);
+	}
+
+	irq_domain_remove(dpu->domain);
+}
+
+static void dpu_debug_ip_identity(struct dpu_soc *dpu)
+{
+	struct device *dev = dpu->dev;
+	const struct cm_reg_ofs *ofs = dpu->devtype->cm_reg_ofs;
+	u32 reg;
+	int id = 0;
+
+	reg = dpu_cm_read(dpu, IPIDENTIFIER(ofs));
+
+	dev_dbg(dev, "%d) Maturatiy level:\n", ++id);
+	switch (reg & DESIGNMATURITYLEVEL_MASK) {
+	case DESIGNMATURITYLEVEL__PREFS:
+		dev_dbg(dev, "\tPre feasibility study.\n");
+		break;
+	case DESIGNMATURITYLEVEL__FS:
+		dev_dbg(dev, "\tFeasibility study.\n");
+		break;
+	case DESIGNMATURITYLEVEL__R0:
+		dev_dbg(dev, "\tFunctionality complete.\n");
+		break;
+	case DESIGNMATURITYLEVEL__R1:
+		dev_dbg(dev, "\tVerification complete.\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP feature set:\n", ++id);
+	switch (reg & IPFEATURESET_MASK) {
+	case IPFEATURESET__E:
+		dev_dbg(dev, "\tMinimal functionality (Eco).\n");
+		break;
+	case IPFEATURESET__L:
+		dev_dbg(dev, "\tReduced functionality (Light).\n");
+		break;
+	case IPFEATURESET__P:
+		dev_dbg(dev, "\tAdvanced functionality (Plus).\n");
+		break;
+	case IPFEATURESET__X:
+		dev_dbg(dev, "\tExtensive functionality (eXtensive).\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP application:\n", ++id);
+	switch (reg & IPAPPLICATION_MASK) {
+	case IPAPPLICATION__B:
+		dev_dbg(dev, "\tBlit engine only.\n");
+		break;
+	case IPAPPLICATION__D:
+		dev_dbg(dev, "\tBlit engine and display controller.\n");
+		break;
+	case IPAPPLICATION__V:
+		dev_dbg(dev, "\tDisplay controller only "
+					"(with direct capture).\n");
+		break;
+	case IPAPPLICATION__G:
+		dev_dbg(dev, "\tBlit engine, display controller "
+					"(with direct capture),\n"
+				   "\tcapture controller (buffered capture) "
+				   "and drawing engine.\n");
+		break;
+	case IPAPPLICATION__C:
+		dev_dbg(dev, "\tDisplay controller only.\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP configuration:\n", ++id);
+	switch (reg & IPCONFIGURATION_MASK) {
+	case IPCONFIGURATION__M:
+		dev_dbg(dev, "\tGraphics core only (Module).\n");
+		break;
+	case IPCONFIGURATION__S:
+		dev_dbg(dev, "\tSubsystem including a graphics core "
+							"(System).\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP family:\n", ++id);
+	switch (reg & IPFAMILY_MASK) {
+	case IPFAMILY__IMXDPU2010:
+		dev_dbg(dev, "\tBuilding block generation 2010.\n");
+		break;
+	case IPFAMILY__IMXDPU2012:
+		dev_dbg(dev, "\tBuilding block generation 2012.\n");
+		break;
+	case IPFAMILY__IMXDPU2013:
+		dev_dbg(dev, "\tBuilding block generation 2013.\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+}
+
+/* FIXME: set pixel link in a proper manner */
+static int dpu_pixel_link_config(int id)
+{
+	sc_err_t sciErr;
+	sc_ipc_t ipcHndl = 0;
+	u32 mu_id;
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("Cannot obtain MU ID\n");
+		return sciErr;
+	}
+
+	sciErr = sc_ipc_open(&ipcHndl, mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
+		return sciErr;
+	}
+
+	if (id == 0) {
+		/* Enable All Display Pixel Links */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL0 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_SYNC_CTRL0, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_SYNC_CTRL0 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL1 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_SYNC_CTRL1, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_SYNC_CTRL1 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+	} else if (id == 1) {
+		/* Enable All Display Pixel Links */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL0 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_SYNC_CTRL0, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_SYNC_CTRL0 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL1 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_SYNC_CTRL1, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_SYNC_CTRL1 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+	}
+
+	sc_ipc_close(mu_id);
+	return sciErr;
+}
+
+static int dpu_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(dpu_dt_ids, &pdev->dev);
+	struct device_node *np = pdev->dev.of_node;
+	struct dpu_soc *dpu;
+	struct resource *res;
+	unsigned long dpu_base;
+	const struct dpu_devtype *devtype;
+	int ret;
+
+	devtype = of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	dpu_base = res->start;
+
+	dpu = devm_kzalloc(&pdev->dev, sizeof(*dpu), GFP_KERNEL);
+	if (!dpu)
+		return -ENODEV;
+
+	dpu->dev = &pdev->dev;
+	dpu->devtype = devtype;
+	dpu->id = of_alias_get_id(np, "dpu");
+
+	dpu->irq_cm = platform_get_irq(pdev, 0);
+	dpu->irq_stream0a = platform_get_irq(pdev, 1);
+	dpu->irq_stream1a = platform_get_irq(pdev, 3);
+	dpu->irq_reserved0 = platform_get_irq(pdev, 5);
+	dpu->irq_reserved1 = platform_get_irq(pdev, 6);
+	dpu->irq_blit = platform_get_irq(pdev, 7);
+
+	dev_dbg(dpu->dev, "irq_cm: %d\n", dpu->irq_cm);
+	dev_dbg(dpu->dev, "irq_stream0a: %d, irq_stream1a: %d\n",
+			dpu->irq_stream0a, dpu->irq_stream1a);
+	dev_dbg(dpu->dev, "irq_reserved0: %d, irq_reserved1: %d\n",
+			dpu->irq_reserved0, dpu->irq_reserved1);
+	dev_dbg(dpu->dev, "irq_blit: %d\n", dpu->irq_blit);
+
+	if (dpu->irq_cm < 0 ||
+	    dpu->irq_stream0a < 0 || dpu->irq_stream1a < 0 ||
+	    dpu->irq_reserved0 < 0 || dpu->irq_reserved1 < 0 ||
+	    dpu->irq_blit < 0)
+		return -ENODEV;
+
+	dpu->intsteer_regmap = syscon_regmap_lookup_by_phandle(np, "intsteer");
+	if (IS_ERR(dpu->intsteer_regmap)) {
+		dev_err(dpu->dev, "failed to get intsteer regmap\n");
+		return PTR_ERR(dpu->intsteer_regmap);
+	}
+
+	spin_lock_init(&dpu->lock);
+	spin_lock_init(&dpu->intsteer_lock);
+
+	dev_dbg(dpu->dev, "Common: 0x%08lx\n", dpu_base + devtype->cm_ofs);
+	DPU_UNITS_ADDR_DBG(cf);
+	DPU_UNITS_ADDR_DBG(dec);
+	DPU_UNITS_ADDR_DBG(ed);
+	DPU_UNITS_ADDR_DBG(fd);
+	DPU_UNITS_ADDR_DBG(fg);
+	DPU_UNITS_ADDR_DBG(fl);
+	DPU_UNITS_ADDR_DBG(lb);
+	DPU_UNITS_ADDR_DBG(tcon);
+
+	dpu->cm_reg = devm_ioremap(dpu->dev, dpu_base + devtype->cm_ofs, SZ_1K);
+	if (!dpu->cm_reg)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, dpu);
+
+	ret = dpu_irq_init(dpu);
+	if (ret)
+		goto failed_irq;
+
+	ret = dpu_submodules_init(dpu, pdev, dpu_base);
+	if (ret)
+		goto failed_submodules_init;
+
+	ret = dpu_add_client_devices(dpu);
+	if (ret) {
+		dev_err(dpu->dev, "adding client devices failed with %d\n",
+					ret);
+		goto failed_add_clients;
+	}
+
+	dpu_debug_ip_identity(dpu);
+
+	if (devtype->pixel_link_quirks)
+		dpu_pixel_link_config(dpu->id);
+
+	dev_info(dpu->dev, "driver probed\n");
+
+	return 0;
+
+failed_add_clients:
+failed_submodules_init:
+	dpu_irq_exit(dpu);
+failed_irq:
+	return ret;
+}
+
+static int dpu_remove(struct platform_device *pdev)
+{
+	struct dpu_soc *dpu = platform_get_drvdata(pdev);
+
+	platform_device_unregister_children(pdev);
+	dpu_irq_exit(dpu);
+
+	return 0;
+}
+
+static struct platform_driver dpu_driver = {
+	.driver = {
+		.name = "dpu-core",
+		.of_match_table = dpu_dt_ids,
+	},
+	.probe = dpu_probe,
+	.remove = dpu_remove,
+};
+
+module_platform_driver(dpu_driver);
+
+MODULE_DESCRIPTION("i.MX DPU driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/dpu/dpu-constframe.c b/drivers/gpu/dpu/dpu-constframe.c
new file mode 100644
index 0000000..77718cd
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-constframe.c
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define FRAMEDIMENSIONS		0xC
+#define WIDTH(w)		(((w) - 1) & 0x3FFF)
+#define HEIGHT(h)		((((h) - 1) & 0x3FFF) << 16)
+#define CONSTANTCOLOR		0x10
+#define RED(r)			(((r) & 0xFF) << 24)
+#define GREEN(g)		(((g) & 0xFF) << 16)
+#define BLUE(b)			(((b) & 0xFF) << 8)
+#define ALPHA(a)		((a) & 0xFF)
+#define CONTROLTRIGGER		0x14
+#define START			0x18
+#define STATUS			0x1C
+
+static const shadow_load_req_t cf_shdlreqs[] = {
+	SHLDREQID_CONSTFRAME0, SHLDREQID_CONSTFRAME1,
+	SHLDREQID_CONSTFRAME4, SHLDREQID_CONSTFRAME5,
+};
+
+struct dpu_constframe {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+	shadow_load_req_t shdlreq;
+};
+
+static inline void dpu_cf_write(struct dpu_constframe *cf, u32 value,
+				unsigned int offset)
+{
+	writel(value, cf->base + offset);
+}
+
+void constframe_shden(struct dpu_constframe *cf, bool enable)
+{
+	u32 val;
+
+	val = enable ? SHDEN : 0;
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, STATICCONTROL);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_shden);
+
+void constframe_framedimensions(struct dpu_constframe *cf, unsigned int w,
+				unsigned int h)
+{
+	u32 val;
+
+	val = WIDTH(w) | HEIGHT(h);
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, FRAMEDIMENSIONS);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_framedimensions);
+
+void constframe_constantcolor(struct dpu_constframe *cf, unsigned int r,
+			      unsigned int g, unsigned int b, unsigned int a)
+{
+	u32 val;
+
+	val = RED(r) | GREEN(g) | BLUE(b) | ALPHA(a);
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, CONSTANTCOLOR);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_constantcolor);
+
+void constframe_controltrigger(struct dpu_constframe *cf, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, CONTROLTRIGGER);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_controltrigger);
+
+shadow_load_req_t constframe_to_shdldreq_t(struct dpu_constframe *cf)
+{
+	shadow_load_req_t t = 0;
+
+	switch (cf->id) {
+	case 0:
+		t = SHLDREQID_CONSTFRAME0;
+		break;
+	case 1:
+		t = SHLDREQID_CONSTFRAME1;
+		break;
+	case 4:
+		t = SHLDREQID_CONSTFRAME4;
+		break;
+	case 5:
+		t = SHLDREQID_CONSTFRAME5;
+		break;
+	}
+
+	return t;
+}
+EXPORT_SYMBOL_GPL(constframe_to_shdldreq_t);
+
+struct dpu_constframe *dpu_cf_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_constframe *cf;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(cf_ids); i++)
+		if (cf_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(cf_ids))
+		return ERR_PTR(-EINVAL);
+
+	cf = dpu->cf_priv[i];
+
+	mutex_lock(&cf->mutex);
+
+	if (cf->inuse) {
+		cf = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	cf->inuse = true;
+out:
+	mutex_unlock(&cf->mutex);
+
+	return cf;
+}
+EXPORT_SYMBOL_GPL(dpu_cf_get);
+
+void dpu_cf_put(struct dpu_constframe *cf)
+{
+	mutex_lock(&cf->mutex);
+
+	cf->inuse = false;
+
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_cf_put);
+
+int dpu_cf_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_constframe *cf;
+	int i;
+
+	cf = devm_kzalloc(dpu->dev, sizeof(*cf), GFP_KERNEL);
+	if (!cf)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(cf_ids); i++)
+		if (cf_ids[i] == id)
+			break;
+
+	dpu->cf_priv[i] = cf;
+
+	cf->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
+	if (!cf->pec_base)
+		return -ENOMEM;
+
+	cf->base = devm_ioremap(dpu->dev, base, SZ_32);
+	if (!cf->base)
+		return -ENOMEM;
+
+	cf->dpu = dpu;
+	cf->id = id;
+	cf->shdlreq = cf_shdlreqs[i];
+
+	mutex_init(&cf->mutex);
+
+	constframe_shden(cf, true);
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-disengcfg.c b/drivers/gpu/dpu/dpu-disengcfg.c
new file mode 100644
index 0000000..0568892
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-disengcfg.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <drm/drm_mode.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "dpu-prv.h"
+
+#define CLOCKCTRL		0x8
+typedef enum {
+	DSPCLKDIVIDE__DIV1,	/* Ext disp clk signal has pix clk freq. */
+	DSPCLKDIVIDE__DIV2,	/* Ext disp clk signal has 2x the pix clk freq. */
+} clkdivide_t;
+#define POLARITYCTRL		0xC
+#define POLHS_HIGH		BIT(0)
+#define POLVS_HIGH		BIT(1)
+#define POLEN_HIGH		BIT(2)
+#define PIXINV_INV		BIT(3)
+#define SRCSELECT		0x10
+
+struct dpu_disengcfg {
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_dec_read(struct dpu_disengcfg *dec, unsigned int offset)
+{
+	return readl(dec->base + offset);
+}
+
+static inline void dpu_dec_write(struct dpu_disengcfg *dec, u32 value,
+				 unsigned int offset)
+{
+	writel(value, dec->base + offset);
+}
+
+void disengcfg_polarity_ctrl(struct dpu_disengcfg *dec, unsigned int flags)
+{
+	const struct dpu_devtype *devtype = dec->dpu->devtype;
+	u32 val;
+
+	mutex_lock(&dec->mutex);
+	val = dpu_dec_read(dec, POLARITYCTRL);
+	if (devtype->pixel_link_nhvsync) {
+		val &= ~POLHS_HIGH;
+		val &= ~POLVS_HIGH;
+	} else {
+		if (flags & DRM_MODE_FLAG_PHSYNC)
+			val |= POLHS_HIGH;
+		if (flags & DRM_MODE_FLAG_NHSYNC)
+			val &= ~POLHS_HIGH;
+		if (flags & DRM_MODE_FLAG_PVSYNC)
+			val |= POLVS_HIGH;
+		if (flags & DRM_MODE_FLAG_NVSYNC)
+			val &= ~POLVS_HIGH;
+	}
+	dpu_dec_write(dec, val, POLARITYCTRL);
+	mutex_unlock(&dec->mutex);
+}
+EXPORT_SYMBOL_GPL(disengcfg_polarity_ctrl);
+
+struct dpu_disengcfg *dpu_dec_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_disengcfg *dec;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dec_ids); i++)
+		if (dec_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(dec_ids))
+		return ERR_PTR(-EINVAL);
+
+	dec = dpu->dec_priv[i];
+
+	mutex_lock(&dec->mutex);
+
+	if (dec->inuse) {
+		dec = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	dec->inuse = true;
+out:
+	mutex_unlock(&dec->mutex);
+
+	return dec;
+}
+EXPORT_SYMBOL_GPL(dpu_dec_get);
+
+void dpu_dec_put(struct dpu_disengcfg *dec)
+{
+	mutex_lock(&dec->mutex);
+
+	dec->inuse = false;
+
+	mutex_unlock(&dec->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_dec_put);
+
+int dpu_dec_init(struct dpu_soc *dpu, unsigned int id,
+			unsigned long unused, unsigned long base)
+{
+	struct dpu_disengcfg *dec;
+
+	dec = devm_kzalloc(dpu->dev, sizeof(*dec), GFP_KERNEL);
+	if (!dec)
+		return -ENOMEM;
+
+	dpu->dec_priv[id] = dec;
+
+	dec->base = devm_ioremap(dpu->dev, base, SZ_16);
+	if (!dec->base)
+		return -ENOMEM;
+
+	dec->dpu = dpu;
+	dec->id = id;
+	mutex_init(&dec->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-extdst.c b/drivers/gpu/dpu/dpu-extdst.c
new file mode 100644
index 0000000..fdb8572
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-extdst.c
@@ -0,0 +1,485 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_STATIC		0x8
+#define POWERDOWN			BIT(4)
+#define SYNC_MODE			BIT(8)
+#define SW_RESET			BIT(11)
+#define DIV(n)				(((n) & 0xFF) << 16)
+#define DIV_RESET			0x80
+#define PIXENGCFG_DYNAMIC		0xC
+#define PIXENGCFG_REQUEST		0x10
+#define SHDLDREQ(n)			BIT(n)
+#define SEL_SHDLDREQ			BIT(0)
+#define PIXENGCFG_TRIGGER		0x14
+#define SYNC_TRIGGER			BIT(0)
+#define TRIGGER_SEQUENCE_COMPLETE	BIT(4)
+#define PIXENGCFG_STATUS		0x18
+#define SYNC_BUSY			BIT(8)
+#define KICK_MODE			BIT(8)
+#define PERFCOUNTMODE			BIT(12)
+#define CONTROL				0xC
+#define GAMMAAPPLYENABLE		BIT(0)
+#define SOFTWAREKICK			0x10
+#define KICK				BIT(0)
+#define STATUS				0x14
+#define CNT_ERR_STS			BIT(0)
+#define CONTROLWORD			0x18
+#define CURPIXELCNT			0x1C
+static u16 get_xval(u32 pixel_cnt)
+{
+	return pixel_cnt && 0xFF;
+}
+
+static u16 get_yval(u32 pixel_cnt)
+{
+	return pixel_cnt >> 16;
+}
+#define LASTPIXELCNT			0x20
+#define PERFCOUNTER			0x24
+
+struct dpu_extdst {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_pec_ed_read(struct dpu_extdst *ed, unsigned int offset)
+{
+	return readl(ed->pec_base + offset);
+}
+
+static inline void dpu_pec_ed_write(struct dpu_extdst *ed, u32 value,
+				unsigned int offset)
+{
+	writel(value, ed->pec_base + offset);
+}
+
+static inline u32 dpu_ed_read(struct dpu_extdst *ed, unsigned int offset)
+{
+	return readl(ed->base + offset);
+}
+
+static inline void dpu_ed_write(struct dpu_extdst *ed, u32 value,
+				unsigned int offset)
+{
+	writel(value, ed->base + offset);
+}
+
+static inline bool dpu_ed_is_safety_stream(struct dpu_extdst *ed)
+{
+	if (ed->id == 4 || ed->id == 5)
+		return true;
+
+	return false;
+}
+
+static inline bool dpu_ed_src_sel_is_extsrc(extdst_src_sel_t src)
+{
+	if (src == ED_SRC_EXTSRC4 || src == ED_SRC_EXTSRC5)
+		return true;
+
+	return false;
+}
+
+void extdst_pixengcfg_shden(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_shden);
+
+void extdst_pixengcfg_powerdown(struct dpu_extdst *ed, bool powerdown)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (powerdown)
+		val |= POWERDOWN;
+	else
+		val &= ~POWERDOWN;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_powerdown);
+
+void extdst_pixengcfg_sync_mode(struct dpu_extdst *ed, ed_sync_mode_t mode)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (mode == AUTO)
+		val |= SYNC_MODE;
+	else
+		val &= ~SYNC_MODE;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_sync_mode);
+
+void extdst_pixengcfg_reset(struct dpu_extdst *ed, bool reset)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (reset)
+		val |= SW_RESET;
+	else
+		val &= ~SW_RESET;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_reset);
+
+void extdst_pixengcfg_div(struct dpu_extdst *ed, u16 div)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	val &= ~0xFF0000;
+	val |= DIV(div);
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_div);
+
+int extdst_pixengcfg_src_sel(struct dpu_extdst *ed, extdst_src_sel_t src)
+{
+	struct dpu_soc *dpu = ed->dpu;
+	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
+	u32 mapped_src;
+
+	mapped_src = block_id_map ? block_id_map[src] : src;
+	if (WARN_ON(mapped_src == NA))
+		return -EINVAL;
+
+	if (dpu_ed_is_safety_stream(ed) && dpu_ed_src_sel_is_extsrc(src)) {
+		dev_err(dpu->dev, "ExtDst%d source cannot be ExtSrc\n", ed->id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&ed->mutex);
+	dpu_pec_ed_write(ed, mapped_src, PIXENGCFG_DYNAMIC);
+	mutex_unlock(&ed->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_src_sel);
+
+void extdst_pixengcfg_sel_shdldreq(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_REQUEST);
+	val |= SEL_SHDLDREQ;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_REQUEST);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_sel_shdldreq);
+
+void extdst_pixengcfg_shdldreq(struct dpu_extdst *ed, u32 req_mask)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_REQUEST);
+	val |= req_mask;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_REQUEST);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_shdldreq);
+
+void extdst_pixengcfg_sync_trigger(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_pec_ed_write(ed, SYNC_TRIGGER, PIXENGCFG_TRIGGER);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_sync_trigger);
+
+void extdst_pixengcfg_trigger_sequence_complete(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_pec_ed_write(ed, TRIGGER_SEQUENCE_COMPLETE, PIXENGCFG_TRIGGER);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_trigger_sequence_complete);
+
+bool extdst_pixengcfg_is_sync_busy(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATUS);
+	mutex_unlock(&ed->mutex);
+
+	return val & SYNC_BUSY;
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_is_sync_busy);
+
+ed_pipeline_status_t extdst_pixengcfg_pipeline_status(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATUS);
+	mutex_unlock(&ed->mutex);
+
+	return val & 0x3;
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_pipeline_status);
+
+void extdst_shden(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_ed_write(ed, val, STATICCONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_shden);
+
+void extdst_kick_mode(struct dpu_extdst *ed, ed_kick_mode_t mode)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATICCONTROL);
+	val &= ~KICK_MODE;
+	val |= mode;
+	dpu_ed_write(ed, val, STATICCONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_kick_mode);
+
+void extdst_perfcountmode(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATICCONTROL);
+	if (enable)
+		val |= PERFCOUNTMODE;
+	else
+		val &= ~PERFCOUNTMODE;
+	dpu_ed_write(ed, val, STATICCONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_perfcountmode);
+
+void extdst_gamma_apply_enable(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, CONTROL);
+	if (enable)
+		val |= GAMMAAPPLYENABLE;
+	else
+		val &= ~GAMMAAPPLYENABLE;
+	dpu_ed_write(ed, val, CONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_gamma_apply_enable);
+
+void extdst_kick(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_ed_write(ed, KICK, SOFTWAREKICK);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_kick);
+
+void extdst_cnt_err_clear(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_ed_write(ed, CNT_ERR_STS, STATUS);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_cnt_err_clear);
+
+bool extdst_cnt_err_status(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATUS);
+	mutex_unlock(&ed->mutex);
+
+	return val & CNT_ERR_STS;
+}
+EXPORT_SYMBOL_GPL(extdst_cnt_err_status);
+
+u32 extdst_last_control_word(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, CONTROLWORD);
+	mutex_unlock(&ed->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(extdst_last_control_word);
+
+void extdst_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, CURPIXELCNT);
+	mutex_unlock(&ed->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(extdst_pixel_cnt);
+
+void extdst_last_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, LASTPIXELCNT);
+	mutex_unlock(&ed->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(extdst_last_pixel_cnt);
+
+u32 extdst_perfresult(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, PERFCOUNTER);
+	mutex_unlock(&ed->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(extdst_perfresult);
+
+struct dpu_extdst *dpu_ed_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_extdst *ed;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ed_ids); i++)
+		if (ed_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(ed_ids))
+		return ERR_PTR(-EINVAL);
+
+	ed = dpu->ed_priv[i];
+
+	mutex_lock(&ed->mutex);
+
+	if (ed->inuse) {
+		ed = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	ed->inuse = true;
+out:
+	mutex_unlock(&ed->mutex);
+
+	return ed;
+}
+EXPORT_SYMBOL_GPL(dpu_ed_get);
+
+void dpu_ed_put(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+
+	ed->inuse = false;
+
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_ed_put);
+
+int dpu_ed_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_extdst *ed;
+	int ret, i;
+
+	ed = devm_kzalloc(dpu->dev, sizeof(*ed), GFP_KERNEL);
+	if (!ed)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(ed_ids); i++)
+		if (ed_ids[i] == id)
+			break;
+
+	dpu->ed_priv[i] = ed;
+
+	ed->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_32);
+	if (!ed->pec_base)
+		return -ENOMEM;
+
+	ed->base = devm_ioremap(dpu->dev, base, SZ_64);
+	if (!ed->base)
+		return -ENOMEM;
+
+	ed->dpu = dpu;
+	ed->id = id;
+	mutex_init(&ed->mutex);
+
+	ret = extdst_pixengcfg_src_sel(ed, ED_SRC_DISABLE);
+	if (ret < 0)
+		return ret;
+
+	extdst_pixengcfg_shden(ed, true);
+	extdst_pixengcfg_powerdown(ed, false);
+	extdst_pixengcfg_sync_mode(ed, SINGLE);
+	extdst_pixengcfg_reset(ed, false);
+	extdst_pixengcfg_div(ed, DIV_RESET);
+	extdst_shden(ed, true);
+	extdst_perfcountmode(ed, false);
+	extdst_kick_mode(ed, EXTERNAL);
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-fetchdecode.c b/drivers/gpu/dpu/dpu-fetchdecode.c
new file mode 100644
index 0000000..d0eaf66
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-fetchdecode.c
@@ -0,0 +1,503 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_DYNAMIC		0x8
+#define SRC_NUM				3
+#define FD_NUM				4
+static const fd_dynamic_src_sel_t fd_srcs[FD_NUM][SRC_NUM] = {
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO0, FD_SRC_FETCHDECODE2 },
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO1, FD_SRC_FETCHDECODE3 },
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO0, FD_SRC_FETCHECO2 },
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO1, FD_SRC_FETCHECO2 },
+};
+
+#define PIXENGCFG_STATUS		0xC
+
+#define RINGBUFSTARTADDR0		0x10
+#define RINGBUFWRAPADDR0		0x14
+#define FRAMEPROPERTIES0		0x18
+#define BASEADDRESS0			0x1C
+#define SOURCEBUFFERATTRIBUTES0		0x20
+#define SOURCEBUFFERDIMENSION0		0x24
+#define COLORCOMPONENTBITS0		0x28
+#define COLORCOMPONENTSHIFT0		0x2C
+#define LAYEROFFSET0			0x30
+#define CLIPWINDOWOFFSET0		0x34
+#define CLIPWINDOWDIMENSIONS0		0x38
+#define CONSTANTCOLOR0			0x3C
+#define LAYERPROPERTY0			0x40
+#define FRAMEDIMENSIONS			0x44
+#define FRAMERESAMPLING			0x48
+#define DECODECONTROL			0x4C
+#define SOURCEBUFFERLENGTH		0x50
+#define CONTROL				0x54
+#define CONTROLTRIGGER			0x58
+#define START				0x5C
+#define FETCHTYPE			0x60
+#define DECODERSTATUS			0x64
+#define READADDRESS0			0x68
+#define BURSTBUFFERPROPERTIES		0x6C
+#define STATUS				0x70
+#define HIDDENSTATUS			0x74
+
+static const shadow_load_req_t fd_shdlreqs[] = {
+	SHLDREQID_FETCHDECODE0, SHLDREQID_FETCHDECODE1,
+	SHLDREQID_FETCHDECODE2, SHLDREQID_FETCHDECODE3,
+};
+
+struct dpu_fetchdecode {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+	fetchtype_t fetchtype;
+	shadow_load_req_t shdlreq;
+};
+
+static inline u32 dpu_pec_fd_read(struct dpu_fetchdecode *fd,
+				  unsigned int offset)
+{
+	return readl(fd->pec_base + offset);
+}
+
+static inline void dpu_pec_fd_write(struct dpu_fetchdecode *fd, u32 value,
+				    unsigned int offset)
+{
+	writel(value, fd->pec_base + offset);
+}
+
+static inline u32 dpu_fd_read(struct dpu_fetchdecode *fd, unsigned int offset)
+{
+	return readl(fd->base + offset);
+}
+
+static inline void dpu_fd_write(struct dpu_fetchdecode *fd, u32 value,
+				unsigned int offset)
+{
+	writel(value, fd->base + offset);
+}
+
+int fetchdecode_pixengcfg_dynamic_src_sel(struct dpu_fetchdecode *fd,
+					  fd_dynamic_src_sel_t src)
+{
+	int i;
+
+	mutex_lock(&fd->mutex);
+	for (i = 0; i < SRC_NUM; i++) {
+		if (fd_srcs[fd->id][i] == src) {
+			dpu_pec_fd_write(fd, src, PIXENGCFG_DYNAMIC);
+			mutex_unlock(&fd->mutex);
+			return 0;
+		}
+	}
+	mutex_unlock(&fd->mutex);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(fetchdecode_pixengcfg_dynamic_src_sel);
+
+static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
+{
+	return (r << 24) | (g << 16) | (b << 8) | a;
+}
+
+static inline u32 yuv_color(u8 y, u8 u, u8 v)
+{
+	return (y << 24) | (u << 16) | (v << 8);
+}
+
+void fetchdecode_shden(struct dpu_fetchdecode *fd, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_fd_write(fd, val, STATICCONTROL);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_shden);
+
+void fetchdecode_baddr_autoupdate(struct dpu_fetchdecode *fd, u8 layer_mask)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, STATICCONTROL);
+	val &= ~BASEADDRESSAUTOUPDATE_MASK;
+	val |= BASEADDRESSAUTOUPDATE(layer_mask);
+	dpu_fd_write(fd, val, STATICCONTROL);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_baddr_autoupdate);
+
+void fetchdecode_baseaddress(struct dpu_fetchdecode *fd, dma_addr_t paddr)
+{
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, paddr, BASEADDRESS0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_baseaddress);
+
+void fetchdecode_source_bpp(struct dpu_fetchdecode *fd, int bpp)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, SOURCEBUFFERATTRIBUTES0);
+	val &= ~0x3f0000;
+	val |= BITSPERPIXEL(bpp);
+	dpu_fd_write(fd, val, SOURCEBUFFERATTRIBUTES0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_source_bpp);
+
+void fetchdecode_source_stride(struct dpu_fetchdecode *fd, int stride)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, SOURCEBUFFERATTRIBUTES0);
+	val &= ~0xffff;
+	val |= STRIDE(stride);
+	dpu_fd_write(fd, val, SOURCEBUFFERATTRIBUTES0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_source_stride);
+
+void fetchdecode_src_buf_dimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				    unsigned int h)
+{
+	u32 val;
+
+	val = LINEWIDTH(w) | LINECOUNT(h);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, SOURCEBUFFERDIMENSION0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_src_buf_dimensions);
+
+void fetchdecode_set_fmt(struct dpu_fetchdecode *fd, u32 fmt)
+{
+	u32 bits, shift;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dpu_pixel_format_matrix); i++) {
+		if (dpu_pixel_format_matrix[i].pixel_format == fmt) {
+			bits = dpu_pixel_format_matrix[i].bits;
+			shift = dpu_pixel_format_matrix[i].shift;
+
+			mutex_lock(&fd->mutex);
+			dpu_fd_write(fd, bits, COLORCOMPONENTBITS0);
+			dpu_fd_write(fd, shift, COLORCOMPONENTSHIFT0);
+			mutex_unlock(&fd->mutex);
+			return;
+		}
+	}
+
+	WARN_ON(1);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_set_fmt);
+
+void fetchdecode_layeroffset(struct dpu_fetchdecode *fd, unsigned int x,
+			     unsigned int y)
+{
+	u32 val;
+
+	val = LAYERXOFFSET(x) | LAYERYOFFSET(y);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, LAYEROFFSET0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_layeroffset);
+
+void fetchdecode_clipoffset(struct dpu_fetchdecode *fd, unsigned int x,
+			    unsigned int y)
+{
+	u32 val;
+
+	val = CLIPWINDOWXOFFSET(x) | CLIPWINDOWYOFFSET(y);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CLIPWINDOWOFFSET0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_clipoffset);
+
+void fetchdecode_layerproperty(struct dpu_fetchdecode *fd, bool enable)
+{
+	u32 val;
+
+	if (enable)
+		val = SOURCEBUFFERENABLE | CLIPWINDOWENABLE;
+	else
+		val = 0;
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, LAYERPROPERTY0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_layerproperty);
+
+void fetchdecode_clipdimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				unsigned int h)
+{
+	u32 val;
+
+	val = CLIPWINDOWWIDTH(w) | CLIPWINDOWHEIGHT(h);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CLIPWINDOWDIMENSIONS0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_clipdimensions);
+
+void fetchdecode_framedimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				 unsigned int h)
+{
+	u32 val;
+
+	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, FRAMEDIMENSIONS);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_framedimensions);
+
+void fetchdecode_rgb_constantcolor(struct dpu_fetchdecode *fd,
+					u8 r, u8 g, u8 b, u8 a)
+{
+	u32 val;
+
+	val = rgb_color(r, g, b, a);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CONSTANTCOLOR0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_rgb_constantcolor);
+
+void fetchdecode_yuv_constantcolor(struct dpu_fetchdecode *fd, u8 y, u8 u, u8 v)
+{
+	u32 val;
+
+	val = yuv_color(y, u, v);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CONSTANTCOLOR0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_yuv_constantcolor);
+
+void fetchdecode_controltrigger(struct dpu_fetchdecode *fd, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CONTROLTRIGGER);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_controltrigger);
+
+int fetchdecode_fetchtype(struct dpu_fetchdecode *fd, fetchtype_t *type)
+{
+	struct dpu_soc *dpu = fd->dpu;
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, FETCHTYPE);
+	val &= FETCHTYPE_MASK;
+	mutex_unlock(&fd->mutex);
+
+	switch (val) {
+	case FETCHTYPE__DECODE:
+		dev_dbg(dpu->dev, "FetchDecode%d with RL and RLAD decoder\n",
+				fd->id);
+		break;
+	case FETCHTYPE__LAYER:
+		dev_dbg(dpu->dev, "FetchDecode%d with fractional "
+				"plane(8 layers)\n", fd->id);
+		break;
+	case FETCHTYPE__WARP:
+		dev_dbg(dpu->dev, "FetchDecode%d with arbitrary warping and "
+				"fractional plane(8 layers)\n", fd->id);
+		break;
+	case FETCHTYPE__ECO:
+		dev_dbg(dpu->dev, "FetchDecode%d with minimum feature set for "
+				"alpha, chroma and coordinate planes\n",
+				fd->id);
+		break;
+	case FETCHTYPE__PERSP:
+		dev_dbg(dpu->dev, "FetchDecode%d with affine, perspective and "
+				"arbitrary warping\n", fd->id);
+		break;
+	case FETCHTYPE__ROT:
+		dev_dbg(dpu->dev, "FetchDecode%d with affine and arbitrary "
+				"warping\n", fd->id);
+		break;
+	case FETCHTYPE__DECODEL:
+		dev_dbg(dpu->dev, "FetchDecode%d with RL and RLAD decoder, "
+				"reduced feature set\n", fd->id);
+		break;
+	case FETCHTYPE__LAYERL:
+		dev_dbg(dpu->dev, "FetchDecode%d with fractional "
+				"plane(8 layers), reduced feature set\n",
+				fd->id);
+		break;
+	case FETCHTYPE__ROTL:
+		dev_dbg(dpu->dev, "FetchDecode%d with affine and arbitrary "
+				"warping, reduced feature set\n", fd->id);
+		break;
+	default:
+		dev_warn(dpu->dev, "Invalid fetch type %u for FetchDecode%d\n",
+				val, fd->id);
+		return -EINVAL;
+	}
+
+	*type = val;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fetchdecode_fetchtype);
+
+shadow_load_req_t fetchdecode_to_shdldreq_t(struct dpu_fetchdecode *fd)
+{
+	shadow_load_req_t t = 0;
+
+	switch (fd->id) {
+	case 0:
+		t = SHLDREQID_FETCHDECODE0;
+		break;
+	case 1:
+		t = SHLDREQID_FETCHDECODE1;
+		break;
+	case 2:
+		t = SHLDREQID_FETCHDECODE2;
+		break;
+	case 3:
+		t = SHLDREQID_FETCHDECODE3;
+		break;
+	default:
+		break;
+	}
+
+	return t;
+}
+EXPORT_SYMBOL_GPL(fetchdecode_to_shdldreq_t);
+
+struct dpu_fetchdecode *dpu_fd_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_fetchdecode *fd;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fd_ids); i++)
+		if (fd_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fd_ids))
+		return ERR_PTR(-EINVAL);
+
+	fd = dpu->fd_priv[i];
+
+	mutex_lock(&fd->mutex);
+
+	if (fd->inuse) {
+		fd = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fd->inuse = true;
+out:
+	mutex_unlock(&fd->mutex);
+
+	return fd;
+}
+EXPORT_SYMBOL_GPL(dpu_fd_get);
+
+void dpu_fd_put(struct dpu_fetchdecode *fd)
+{
+	mutex_lock(&fd->mutex);
+
+	fd->inuse = false;
+
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fd_put);
+
+int dpu_fd_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_fetchdecode *fd;
+	int ret, i;
+
+	fd = devm_kzalloc(dpu->dev, sizeof(*fd), GFP_KERNEL);
+	if (!fd)
+		return -ENOMEM;
+
+	dpu->fd_priv[id] = fd;
+
+	fd->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
+	if (!fd->pec_base)
+		return -ENOMEM;
+
+	fd->base = devm_ioremap(dpu->dev, base, SZ_1K);
+	if (!fd->base)
+		return -ENOMEM;
+
+	fd->dpu = dpu;
+	fd->id = id;
+	for (i = 0; i < ARRAY_SIZE(fd_ids); i++) {
+		if (fd_ids[i] == id) {
+			fd->shdlreq = fd_shdlreqs[i];
+			break;
+		}
+	}
+	mutex_init(&fd->mutex);
+
+	ret = fetchdecode_pixengcfg_dynamic_src_sel(fd, FD_SRC_DISABLE);
+	if (ret < 0)
+		return ret;
+
+	ret = fetchdecode_fetchtype(fd, &fd->fetchtype);
+	if (ret < 0)
+		return ret;
+
+	fetchdecode_baddr_autoupdate(fd, 0x0);
+	fetchdecode_shden(fd, true);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, SETNUMBUFFERS(16) | SETBURSTLENGTH(16),
+			BURSTBUFFERMANAGEMENT);
+	mutex_unlock(&fd->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-fetchlayer.c b/drivers/gpu/dpu/dpu-fetchlayer.c
new file mode 100644
index 0000000..fdc8c14
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-fetchlayer.c
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_STATUS		0x8
+#define BASEADDRESS(n)			(0x10 + (n) * 0x28)
+#define SOURCEBUFFERATTRIBUTES(n)	(0x14 + (n) * 0x28)
+#define SOURCEBUFFERDIMENSION(n)	(0x18 + (n) * 0x28)
+#define COLORCOMPONENTBITS(n)		(0x1C + (n) * 0x28)
+#define COLORCOMPONENTSHIFT(n)		(0x20 + (n) * 0x28)
+#define LAYEROFFSET(n)			(0x24 + (n) * 0x28)
+#define CLIPWINDOWOFFSET(n)		(0x28 + (n) * 0x28)
+#define CLIPWINDOWDIMENSIONS(n)		(0x2C + (n) * 0x28)
+#define CONSTANTCOLOR(n)		(0x30 + (n) * 0x28)
+#define LAYERPROPERTY(n)		(0x34 + (n) * 0x28)
+#define FRAMEDIMENSIONS			0x150
+#define FRAMERESAMPLING			0x154
+#define CONTROL				0x158
+#define TRIGGERENABLE			0x15C
+#define SHDLDREQ(lm)			((lm) & 0xFF)
+#define CONTROLTRIGGER			0x160
+#define START				0x164
+#define FETCHTYPE			0x168
+#define BURSTBUFFERPROPERTIES		0x16C
+#define STATUS				0x170
+#define HIDDENSTATUS			0x174
+
+static const shadow_load_req_t fl_shdlreqs[] = {
+	SHLDREQID_FETCHLAYER0, SHLDREQID_FETCHLAYER1,
+};
+
+struct dpu_fetchlayer {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+	fetchtype_t fetchtype;
+	shadow_load_req_t shdlreq;
+};
+
+static inline u32 dpu_fl_read(struct dpu_fetchlayer *fl, unsigned int offset)
+{
+	return readl(fl->base + offset);
+}
+
+static inline void dpu_fl_write(struct dpu_fetchlayer *fl, u32 value,
+				unsigned int offset)
+{
+	writel(value, fl->base + offset);
+}
+
+static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
+{
+	return (r << 24) | (g << 16) | (b << 8) | a;
+}
+
+static inline u32 yuv_color(u8 y, u8 u, u8 v)
+{
+	return (y << 24) | (u << 16) | (v << 8);
+}
+
+void fetchlayer_shden(struct dpu_fetchlayer *fl, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fl->mutex);
+	val = dpu_fl_read(fl, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_fl_write(fl, val, STATICCONTROL);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_shden);
+
+void fetchlayer_baddr_autoupdate(struct dpu_fetchlayer *fl, u8 layer_mask)
+{
+	u32 val;
+
+	mutex_lock(&fl->mutex);
+	val = dpu_fl_read(fl, STATICCONTROL);
+	val &= ~BASEADDRESSAUTOUPDATE_MASK;
+	val |= BASEADDRESSAUTOUPDATE(layer_mask);
+	dpu_fl_write(fl, val, STATICCONTROL);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_baddr_autoupdate);
+
+void fetchlayer_framedimensions(struct dpu_fetchlayer *fl, unsigned int w,
+				unsigned int h)
+{
+	u32 val;
+
+	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, FRAMEDIMENSIONS);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_framedimensions);
+
+void fetchlayer_rgb_constantcolor(struct dpu_fetchlayer *fl,
+					u8 r, u8 g, u8 b, u8 a)
+{
+	u32 val;
+
+	val = rgb_color(r, g, b, a);
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, CONSTANTCOLOR(fl->id));
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_rgb_constantcolor);
+
+void fetchlayer_yuv_constantcolor(struct dpu_fetchlayer *fl, u8 y, u8 u, u8 v)
+{
+	u32 val;
+
+	val = yuv_color(y, u, v);
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, CONSTANTCOLOR(fl->id));
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_yuv_constantcolor);
+
+void fetchlayer_controltrigger(struct dpu_fetchlayer *fl, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, CONTROLTRIGGER);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_controltrigger);
+
+int fetchlayer_fetchtype(struct dpu_fetchlayer *fl, fetchtype_t *type)
+{
+	struct dpu_soc *dpu = fl->dpu;
+	u32 val;
+
+	mutex_lock(&fl->mutex);
+	val = dpu_fl_read(fl, FETCHTYPE);
+	val &= FETCHTYPE_MASK;
+	mutex_unlock(&fl->mutex);
+
+	switch (val) {
+	case FETCHTYPE__DECODE:
+		dev_dbg(dpu->dev, "FetchLayer%d with RL and RLAD decoder\n",
+				fl->id);
+		break;
+	case FETCHTYPE__LAYER:
+		dev_dbg(dpu->dev, "FetchLayer%d with fractional "
+				"plane(8 layers)\n", fl->id);
+		break;
+	case FETCHTYPE__WARP:
+		dev_dbg(dpu->dev, "FetchLayer%d with arbitrary warping and "
+				"fractional plane(8 layers)\n", fl->id);
+		break;
+	case FETCHTYPE__ECO:
+		dev_dbg(dpu->dev, "FetchLayer%d with minimum feature set for "
+				"alpha, chroma and coordinate planes\n",
+				fl->id);
+		break;
+	case FETCHTYPE__PERSP:
+		dev_dbg(dpu->dev, "FetchLayer%d with affine, perspective and "
+				"arbitrary warping\n", fl->id);
+		break;
+	case FETCHTYPE__ROT:
+		dev_dbg(dpu->dev, "FetchLayer%d with affine and arbitrary "
+				"warping\n", fl->id);
+		break;
+	case FETCHTYPE__DECODEL:
+		dev_dbg(dpu->dev, "FetchLayer%d with RL and RLAD decoder, "
+				"reduced feature set\n", fl->id);
+		break;
+	case FETCHTYPE__LAYERL:
+		dev_dbg(dpu->dev, "FetchLayer%d with fractional "
+				"plane(8 layers), reduced feature set\n",
+				fl->id);
+		break;
+	case FETCHTYPE__ROTL:
+		dev_dbg(dpu->dev, "FetchLayer%d with affine and arbitrary "
+				"warping, reduced feature set\n", fl->id);
+		break;
+	default:
+		dev_warn(dpu->dev, "Invalid fetch type %u for FetchLayer%d\n",
+				val, fl->id);
+		return -EINVAL;
+	}
+
+	*type = val;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fetchlayer_fetchtype);
+
+struct dpu_fetchlayer *dpu_fl_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_fetchlayer *fl;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fl_ids); i++)
+		if (fl_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fl_ids))
+		return ERR_PTR(-EINVAL);
+
+	fl = dpu->fl_priv[i];
+
+	mutex_lock(&fl->mutex);
+
+	if (fl->inuse) {
+		fl = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fl->inuse = true;
+out:
+	mutex_unlock(&fl->mutex);
+
+	return fl;
+}
+EXPORT_SYMBOL_GPL(dpu_fl_get);
+
+void dpu_fl_put(struct dpu_fetchlayer *fl)
+{
+	mutex_lock(&fl->mutex);
+
+	fl->inuse = false;
+
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fl_put);
+
+int dpu_fl_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_fetchlayer *fl;
+	int ret, i;
+
+	fl = devm_kzalloc(dpu->dev, sizeof(*fl), GFP_KERNEL);
+	if (!fl)
+		return -ENOMEM;
+
+	dpu->fl_priv[id] = fl;
+
+	fl->pec_base = devm_ioremap(dpu->dev, base, SZ_16);
+	if (!fl->pec_base)
+		return -ENOMEM;
+
+	fl->base = devm_ioremap(dpu->dev, base, SZ_512);
+	if (!fl->base)
+		return -ENOMEM;
+
+	fl->dpu = dpu;
+	fl->id = id;
+	for (i = 0; i < ARRAY_SIZE(fl_ids); i++) {
+		if (fl_ids[i] == id) {
+			fl->shdlreq = fl_shdlreqs[i];
+			break;
+		}
+	}
+	mutex_init(&fl->mutex);
+
+	ret = fetchlayer_fetchtype(fl, &fl->fetchtype);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-framegen.c b/drivers/gpu/dpu/dpu-framegen.c
new file mode 100644
index 0000000..93f000f
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-framegen.c
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define FGSTCTRL		0x8
+#define FGSYNCMODE_MASK		0x6
+typedef enum {
+	/* No side-by-side synchronization. */
+	FGSYNCMODE__OFF = 0,
+	/* Framegen is master. */
+	FGSYNCMODE__MASTER = 1 << 1,
+	/* Runs in cyclic synchronization mode. */
+	FGSYNCMODE__SLAVE_CYC = 2 << 1,
+	/* Runs in one time synchronization mode. */
+	FGSYNCMODE__SLAVE_ONCE = 3 << 1,
+} fgsyncmode_t;
+#define HTCFG1			0xC
+#define HTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
+#define HACT(n)			((n) & 0x3FFF)
+#define HTCFG2			0x10
+#define HSEN			BIT(31)
+#define HSBP(n)			((((n) - 1) & 0x3FFF) << 16)
+#define HSYNC(n)		(((n) - 1) & 0x3FFF)
+#define VTCFG1			0x14
+#define VTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
+#define VACT(n)			((n) & 0x3FFF)
+#define VTCFG2			0x18
+#define VSEN			BIT(31)
+#define VSBP(n)			((((n) - 1) & 0x3FFF) << 16)
+#define VSYNC(n)		(((n) - 1) & 0x3FFF)
+#define INTCONFIG(n)		(0x1C + 4 * (n))
+#define EN			BIT(31)
+#define ROW(n)			(((n) & 0x3FFF) << 16)
+#define COL(n)			((n) & 0x3FFF)
+#define PKICKCONFIG		0x2C
+#define SKICKCONFIG		0x30
+#define SECSTATCONFIG		0x34
+#define FGSRCR1			0x38
+#define FGSRCR2			0x3C
+#define FGSRCR3			0x40
+#define FGSRCR4			0x44
+#define FGSRCR5			0x48
+#define FGSRCR6			0x4C
+#define FGKSDR			0x50
+#define PACFG			0x54
+#define STARTX(n)		(((n) + 1) & 0x3FFF)
+#define STARTY(n)		(((((n) + 1) & 0x3FFF)) << 16)
+#define SACFG			0x58
+#define FGINCTRL		0x5C
+#define FGDM_MASK		0x7
+#define ENPRIMALPHA		BIT(3)
+#define ENSECALPHA		BIT(4)
+#define FGINCTRLPANIC		0x60
+#define FGCCR			0x64
+#define CCALPHA(a)		(((a) & 0x1) << 30)
+#define CCRED(r)		(((r) & 0x3FF) << 20)
+#define CCGREEN(g)		(((g) & 0x3FF) << 10)
+#define CCBLUE(b)		((b) & 0x3FF)
+#define FGENABLE		0x68
+#define FGEN			BIT(0)
+#define FGSLR			0x6C
+#define FGENSTS			0x70
+#define ENSTS			BIT(0)
+#define FGTIMESTAMP		0x74
+#define LINEINDEX_MASK		0x3FFF
+#define LINEINDEX_SHIFT		0
+#define FRAMEINDEX_MASK		0xFFFFC000
+#define FRAMEINDEX_SHIFT	14
+#define FGCHSTAT		0x78
+#define FGCHSTATCLR		0x7C
+#define FGSKEWMON		0x80
+#define FGSFIFOMIN		0x84
+#define FGSFIFOMAX		0x88
+#define FGSFIFOFILLCLR		0x8C
+#define FGSREPD			0x90
+#define FGSRFTD			0x94
+
+struct dpu_framegen {
+	void __iomem *base;
+	struct clk *clk_pll;
+	struct clk *clk_disp;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_fg_read(struct dpu_framegen *fg, unsigned int offset)
+{
+	return readl(fg->base + offset);
+}
+
+static inline void dpu_fg_write(struct dpu_framegen *fg, u32 value,
+				unsigned int offset)
+{
+	writel(value, fg->base + offset);
+}
+
+void framegen_enable(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, FGEN, FGENABLE);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_enable);
+
+void framegen_disable(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, 0, FGENABLE);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_disable);
+
+void framegen_shdtokgen(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, SHDTOKGEN, FGSLR);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_shdtokgen);
+
+void framegen_cfg_videomode(struct dpu_framegen *fg, struct drm_display_mode *m)
+{
+	const struct dpu_devtype *devtype = fg->dpu->devtype;
+	u32 hact, htotal, hsync, hsbp;
+	u32 vact, vtotal, vsync, vsbp;
+	u32 val;
+	unsigned long disp_clock_rate, pll_clock_rate = 0;
+
+	hact = m->crtc_hdisplay;
+	htotal = m->crtc_htotal;
+	hsync = m->crtc_hsync_end - m->crtc_hsync_start;
+	hsbp = m->crtc_htotal - m->crtc_hsync_start;
+
+	vact = m->crtc_vdisplay;
+	vtotal = m->crtc_vtotal;
+	vsync = m->crtc_vsync_end - m->crtc_vsync_start;
+	vsbp = m->crtc_vtotal - m->crtc_vsync_start;
+
+	mutex_lock(&fg->mutex);
+	/* video mode */
+	dpu_fg_write(fg, HACT(hact) | HTOTAL(htotal), HTCFG1);
+	dpu_fg_write(fg, HSYNC(hsync) | HSBP(hsbp) | HSEN, HTCFG2);
+	dpu_fg_write(fg, VACT(vact) | VTOTAL(vtotal), VTCFG1);
+	dpu_fg_write(fg, VSYNC(vsync) | VSBP(vsbp) | VSEN, VTCFG2);
+
+	/* skikconfig */
+	dpu_fg_write(fg, COL(hact - 40) | ROW(vact - 1) | EN, SKICKCONFIG);
+
+	/* primary position config */
+	dpu_fg_write(fg, STARTX(0) | STARTY(0), PACFG);
+
+	/* alpha */
+	val = dpu_fg_read(fg, FGINCTRL);
+	val &= ~(ENPRIMALPHA | ENSECALPHA);
+	dpu_fg_write(fg, val, FGINCTRL);
+
+	val = dpu_fg_read(fg, FGINCTRLPANIC);
+	val &= ~(ENPRIMALPHA | ENSECALPHA);
+	dpu_fg_write(fg, val, FGINCTRLPANIC);
+
+	/* constant color */
+	dpu_fg_write(fg, 0, FGCCR);
+	mutex_unlock(&fg->mutex);
+
+	disp_clock_rate = m->clock * 1000;
+
+	if (devtype->version == DPU_V1) {
+		/* FIXME: why the folders */
+		if (disp_clock_rate > 150000000)
+			pll_clock_rate = disp_clock_rate * 2;
+		else if (disp_clock_rate > 75000000)
+			pll_clock_rate = disp_clock_rate * 4;
+		else
+			pll_clock_rate = disp_clock_rate * 8;
+	} else if (devtype->version == DPU_V2) {
+		/* FIXME: why the hardcoded clock rate */
+		if (disp_clock_rate > 75000000)
+			pll_clock_rate = 1188000000;
+		else
+			pll_clock_rate = disp_clock_rate * 8;
+	}
+
+	clk_set_rate(fg->clk_pll, pll_clock_rate);
+	clk_set_rate(fg->clk_disp, disp_clock_rate);
+}
+EXPORT_SYMBOL_GPL(framegen_cfg_videomode);
+
+void framegen_pkickconfig(struct dpu_framegen *fg, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, PKICKCONFIG);
+	if (enable)
+		val |= EN;
+	else
+		val &= ~EN;
+	dpu_fg_write(fg, val, PKICKCONFIG);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_pkickconfig);
+
+void framegen_sacfg(struct dpu_framegen *fg, unsigned int x, unsigned int y)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, STARTX(x) | STARTY(y), SACFG);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_sacfg);
+
+void framegen_displaymode(struct dpu_framegen *fg, fgdm_t mode)
+{
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGINCTRL);
+	val &= ~FGDM_MASK;
+	val |= mode;
+	dpu_fg_write(fg, val, FGINCTRL);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_displaymode);
+
+void framegen_panic_displaymode(struct dpu_framegen *fg, fgdm_t mode)
+{
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGINCTRLPANIC);
+	val &= ~FGDM_MASK;
+	val |= mode;
+	dpu_fg_write(fg, val, FGINCTRLPANIC);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_panic_displaymode);
+
+void framegen_wait_done(struct dpu_framegen *fg)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(60);
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	do {
+		val = dpu_fg_read(fg, FGENSTS);
+	} while ((val & ENSTS) && time_before(jiffies, timeout));
+	mutex_unlock(&fg->mutex);
+
+	if (val & ENSTS)
+		dev_err(fg->dpu->dev, "failed to wait for FrameGen%d done\n",
+			fg->id);
+}
+EXPORT_SYMBOL_GPL(framegen_wait_done);
+
+void framegen_enable_clock(struct dpu_framegen *fg)
+{
+	clk_prepare_enable(fg->clk_pll);
+	clk_prepare_enable(fg->clk_disp);
+}
+EXPORT_SYMBOL_GPL(framegen_enable_clock);
+
+void framegen_disable_clock(struct dpu_framegen *fg)
+{
+	clk_disable_unprepare(fg->clk_pll);
+	clk_disable_unprepare(fg->clk_disp);
+}
+EXPORT_SYMBOL_GPL(framegen_disable_clock);
+
+struct dpu_framegen *dpu_fg_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_framegen *fg;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fg_ids); i++)
+		if (fg_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fg_ids))
+		return ERR_PTR(-EINVAL);
+
+	fg = dpu->fg_priv[i];
+
+	mutex_lock(&fg->mutex);
+
+	if (fg->inuse) {
+		fg = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fg->inuse = true;
+out:
+	mutex_unlock(&fg->mutex);
+
+	return fg;
+}
+EXPORT_SYMBOL_GPL(dpu_fg_get);
+
+void dpu_fg_put(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+
+	fg->inuse = false;
+
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fg_put);
+
+int dpu_fg_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long unused, unsigned long base)
+{
+	struct dpu_framegen *fg;
+	u32 val;
+
+	fg = devm_kzalloc(dpu->dev, sizeof(*fg), GFP_KERNEL);
+	if (!fg)
+		return -ENOMEM;
+
+	dpu->fg_priv[id] = fg;
+
+	fg->base = devm_ioremap(dpu->dev, base, SZ_256);
+	if (!fg->base)
+		return -ENOMEM;
+
+	fg->clk_pll = devm_clk_get(dpu->dev, id ? "pll1" : "pll0");
+	if (IS_ERR(fg->clk_pll))
+		return PTR_ERR(fg->clk_pll);
+
+	fg->clk_disp = devm_clk_get(dpu->dev, id ? "disp1" : "disp0");
+	if (IS_ERR(fg->clk_disp))
+		return PTR_ERR(fg->clk_disp);
+
+	fg->dpu = dpu;
+	fg->id = id;
+	mutex_init(&fg->mutex);
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGSTCTRL);
+	val &= ~FGSYNCMODE_MASK;
+	val |= FGSYNCMODE__OFF;
+	dpu_fg_write(fg, val, FGSTCTRL);
+
+	mutex_unlock(&fg->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-layerblend.c b/drivers/gpu/dpu/dpu-layerblend.c
new file mode 100644
index 0000000..ef90ee6
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-layerblend.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_DYNAMIC			0x8
+#define PIXENGCFG_DYNAMIC_PRIM_SEL_MASK		0x3F
+#define PIXENGCFG_DYNAMIC_SEC_SEL_MASK		0x3F00
+#define PIXENGCFG_DYNAMIC_SEC_SEL_SHIFT		8
+
+static const lb_prim_sel_t prim_sels[] = {
+	LB_PRIM_SEL__DISABLE,
+	LB_PRIM_SEL__BLITBLEND9,
+	LB_PRIM_SEL__CONSTFRAME0,
+	LB_PRIM_SEL__CONSTFRAME1,
+	LB_PRIM_SEL__CONSTFRAME4,
+	LB_PRIM_SEL__CONSTFRAME5,
+	LB_PRIM_SEL__MATRIX4,
+	LB_PRIM_SEL__HSCALER4,
+	LB_PRIM_SEL__VSCALER4,
+	LB_PRIM_SEL__EXTSRC4,
+	LB_PRIM_SEL__MATRIX5,
+	LB_PRIM_SEL__HSCALER5,
+	LB_PRIM_SEL__VSCALER5,
+	LB_PRIM_SEL__EXTSRC5,
+	LB_PRIM_SEL__LAYERBLEND0,
+	LB_PRIM_SEL__LAYERBLEND1,
+	LB_PRIM_SEL__LAYERBLEND2,
+	LB_PRIM_SEL__LAYERBLEND3,
+	LB_PRIM_SEL__LAYERBLEND4,
+	LB_PRIM_SEL__LAYERBLEND5,
+};
+
+#define PIXENGCFG_STATUS			0xC
+#define SHDTOKSEL				(0x3 << 3)
+#define SHDTOKSEL_SHIFT				3
+#define SHDLDSEL				(0x3 << 1)
+#define CONTROL					0xC
+#define MODE_MASK				BIT(0)
+#define BLENDCONTROL				0x10
+#define ALPHA(a)				(((a) & 0xFF) << 16)
+#define PRIM_C_BLD_FUNC__ONE_MINUS_SEC_ALPHA	0x5
+#define SEC_C_BLD_FUNC__CONST_ALPHA		(0x6 << 4)
+#define PRIM_A_BLD_FUNC__ONE_MINUS_SEC_ALPHA	(0x5 << 8)
+#define SEC_A_BLD_FUNC__ONE			(0x1 << 12)
+#define POSITION				0x14
+#define XPOS(x)					((x) & 0x7FFF)
+#define YPOS(y)					(((y) & 0x7FFF) << 16)
+#define PRIMCONTROLWORD				0x18
+#define SECCONTROLWORD				0x1C
+
+#define CONTROLWORD				0x18
+#define CURPIXELCNT				0x1C
+static u16 get_xval(u32 pixel_cnt)
+{
+	return pixel_cnt && 0xFF;
+}
+
+static u16 get_yval(u32 pixel_cnt)
+{
+	return pixel_cnt >> 16;
+}
+#define LASTPIXELCNT				0x20
+#define PERFCOUNTER				0x24
+
+struct dpu_layerblend {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_pec_lb_read(struct dpu_layerblend *lb,
+				  unsigned int offset)
+{
+	return readl(lb->pec_base + offset);
+}
+
+static inline void dpu_pec_lb_write(struct dpu_layerblend *lb, u32 value,
+				    unsigned int offset)
+{
+	writel(value, lb->pec_base + offset);
+}
+
+static inline u32 dpu_lb_read(struct dpu_layerblend *lb, unsigned int offset)
+{
+	return readl(lb->base + offset);
+}
+
+static inline void dpu_lb_write(struct dpu_layerblend *lb, u32 value,
+				unsigned int offset)
+{
+	writel(value, lb->base + offset);
+}
+
+int layerblend_pixengcfg_dynamic_prim_sel(struct dpu_layerblend *lb,
+					  lb_prim_sel_t prim)
+{
+	struct dpu_soc *dpu = lb->dpu;
+	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
+	int fixed_sels_num = ARRAY_SIZE(prim_sels) - 6;
+	int i;
+	u32 val, mapped_prim;
+
+	mutex_lock(&lb->mutex);
+	for (i = 0; i < fixed_sels_num + lb->id; i++) {
+		if (prim_sels[i] == prim) {
+			mapped_prim = block_id_map ? block_id_map[prim] : prim;
+			if (WARN_ON(mapped_prim == NA))
+				return -EINVAL;
+
+			val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
+			val &= ~PIXENGCFG_DYNAMIC_PRIM_SEL_MASK;
+			val |= mapped_prim;
+			dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
+			mutex_unlock(&lb->mutex);
+			return 0;
+		}
+	}
+	mutex_unlock(&lb->mutex);
+
+	dev_err(dpu->dev, "Invalid primary source for LayerBlend%d\n", lb->id);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(layerblend_pixengcfg_dynamic_prim_sel);
+
+void layerblend_pixengcfg_dynamic_sec_sel(struct dpu_layerblend *lb,
+					  lb_sec_sel_t sec)
+{
+	struct dpu_soc *dpu = lb->dpu;
+	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
+	u32 val, mapped_sec;
+
+	mapped_sec = block_id_map ? block_id_map[sec] : sec;
+	if (WARN_ON(mapped_sec == NA))
+		return;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
+	val &= ~PIXENGCFG_DYNAMIC_SEC_SEL_MASK;
+	val |= mapped_sec << PIXENGCFG_DYNAMIC_SEC_SEL_SHIFT;
+	dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_pixengcfg_dynamic_sec_sel);
+
+void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
+				lb_pixengcfg_clken_t clken)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
+	val &= ~CLKEN_MASK;
+	val |= clken << CLKEN_MASK_SHIFT;
+	dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_pixengcfg_clken);
+
+void layerblend_shden(struct dpu_layerblend *lb, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_lb_write(lb, val, STATICCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_shden);
+
+void layerblend_shdtoksel(struct dpu_layerblend *lb, lb_shadow_sel_t sel)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, STATICCONTROL);
+	val &= ~SHDTOKSEL;
+	val |= (sel << SHDTOKSEL_SHIFT);
+	dpu_lb_write(lb, val, STATICCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_shdtoksel);
+
+void layerblend_shdldsel(struct dpu_layerblend *lb, lb_shadow_sel_t sel)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, STATICCONTROL);
+	val &= ~SHDLDSEL;
+	val |= sel;
+	dpu_lb_write(lb, val, STATICCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_shdldsel);
+
+void layerblend_control(struct dpu_layerblend *lb, lb_mode_t mode)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, CONTROL);
+	val &= ~MODE_MASK;
+	val |= mode;
+	dpu_lb_write(lb, val, CONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_control);
+
+void layerblend_blendcontrol(struct dpu_layerblend *lb)
+{
+	u32 val;
+
+	val = ALPHA(0xff) |
+	      PRIM_C_BLD_FUNC__ONE_MINUS_SEC_ALPHA |
+	      SEC_C_BLD_FUNC__CONST_ALPHA |
+	      PRIM_A_BLD_FUNC__ONE_MINUS_SEC_ALPHA |
+	      SEC_A_BLD_FUNC__ONE;
+
+	mutex_lock(&lb->mutex);
+	dpu_lb_write(lb, val, BLENDCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_blendcontrol);
+
+void layerblend_position(struct dpu_layerblend *lb, int x, int y)
+{
+	mutex_lock(&lb->mutex);
+	dpu_lb_write(lb, XPOS(x) | YPOS(y), POSITION);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_position);
+
+u32 layerblend_last_control_word(struct dpu_layerblend *lb)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, CONTROLWORD);
+	mutex_unlock(&lb->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(layerblend_last_control_word);
+
+void layerblend_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, CURPIXELCNT);
+	mutex_unlock(&lb->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(layerblend_pixel_cnt);
+
+void layerblend_last_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, LASTPIXELCNT);
+	mutex_unlock(&lb->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(layerblend_last_pixel_cnt);
+
+u32 layerblend_perfresult(struct dpu_layerblend *lb)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, PERFCOUNTER);
+	mutex_unlock(&lb->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(layerblend_perfresult);
+
+struct dpu_layerblend *dpu_lb_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_layerblend *lb;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lb_ids); i++)
+		if (lb_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(lb_ids))
+		return ERR_PTR(-EINVAL);
+
+	lb = dpu->lb_priv[i];
+
+	mutex_lock(&lb->mutex);
+
+	if (lb->inuse) {
+		lb = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	lb->inuse = true;
+out:
+	mutex_unlock(&lb->mutex);
+
+	return lb;
+}
+EXPORT_SYMBOL_GPL(dpu_lb_get);
+
+void dpu_lb_put(struct dpu_layerblend *lb)
+{
+	mutex_lock(&lb->mutex);
+
+	lb->inuse = false;
+
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_lb_put);
+
+int dpu_lb_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_layerblend *lb;
+	int ret;
+
+	lb = devm_kzalloc(dpu->dev, sizeof(*lb), GFP_KERNEL);
+	if (!lb)
+		return -ENOMEM;
+
+	dpu->lb_priv[id] = lb;
+
+	lb->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
+	if (!lb->pec_base)
+		return -ENOMEM;
+
+	lb->base = devm_ioremap(dpu->dev, base, SZ_32);
+	if (!lb->base)
+		return -ENOMEM;
+
+	lb->dpu = dpu;
+	lb->id = id;
+	mutex_init(&lb->mutex);
+
+	ret = layerblend_pixengcfg_dynamic_prim_sel(lb, LB_PRIM_SEL__DISABLE);
+	if (ret < 0)
+		return ret;
+
+	layerblend_pixengcfg_dynamic_sec_sel(lb, LB_SEC_SEL__DISABLE);
+	layerblend_pixengcfg_clken(lb, CLKEN__AUTOMATIC);
+	layerblend_shdldsel(lb, BOTH);
+	layerblend_shdtoksel(lb, BOTH);
+	layerblend_shden(lb, true);
+
+	return 0;
+}
diff --git a/drivers/gpu/dpu/dpu-prv.h b/drivers/gpu/dpu/dpu-prv.h
new file mode 100644
index 0000000..957a010
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-prv.h
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#ifndef __DPU_PRV_H__
+#define __DPU_PRV_H__
+
+#include <drm/drm_fourcc.h>
+
+#define NA				0xDEADBEEF	/* not available */
+
+#define STATICCONTROL			0x8
+#define BASEADDRESSAUTOUPDATE(lm)	(((lm) & 0xFF) << 16)
+#define BASEADDRESSAUTOUPDATE_MASK	(0xFF << 16)
+#define SHDEN				BIT(0)
+#define BURSTBUFFERMANAGEMENT		0xC
+#define SETNUMBUFFERS(n)		((n) & 0xFF)
+#define SETBURSTLENGTH(n)		(((n) & 0x1F) << 8)
+#define LINEMODE_MASK			0x80000000U
+#define LINEMODE_SHIFT			31U
+enum linemode {
+	/*
+	 * Mandatory setting for operation in the Display Controller.
+	 * Works also for Blit Engine with marginal performance impact.
+	 */
+	LINEMODE__DISPLAY = 0,
+	/* Recommended setting for operation in the Blit Engine. */
+	LINEMODE__BLIT = 1 << LINEMODE_SHIFT,
+};
+
+#define BITSPERPIXEL(bpp)		(((bpp) & 0x3F) << 16)
+#define STRIDE(n)			(((n) - 1) & 0xFFFF)
+#define LINEWIDTH(w)			(((w) - 1) & 0x3FFF)
+#define LINECOUNT(h)			((((h) - 1) & 0x3FFF) << 16)
+#define ITUFORMAT			BIT(31)
+#define R_BITS(n)			(((n) & 0xF) << 24)
+#define G_BITS(n)			(((n) & 0xF) << 16)
+#define B_BITS(n)			(((n) & 0xF) << 8)
+#define A_BITS(n)			((n) & 0xF)
+#define R_SHIFT(n)			(((n) & 0x1F) << 24)
+#define G_SHIFT(n)			(((n) & 0x1F) << 16)
+#define B_SHIFT(n)			(((n) & 0x1F) << 8)
+#define A_SHIFT(n)			((n) & 0x1F)
+#define LAYERXOFFSET(x)			((x) & 0x7FFF)
+#define LAYERYOFFSET(y)			(((y) & 0x7FFF) << 16)
+#define CLIPWINDOWXOFFSET(x)		((x) & 0x7FFF)
+#define CLIPWINDOWYOFFSET(y)		(((y) & 0x7FFF) << 16)
+#define CLIPWINDOWWIDTH(w)		(((w) - 1) & 0x3FFF)
+#define CLIPWINDOWHEIGHT(h)		((((h) - 1) & 0x3FFF) << 16)
+#define	PALETTEENABLE			BIT(0)
+typedef enum {
+	TILE_FILL_ZERO,
+	TILE_FILL_CONSTANT,
+	TILE_PAD,
+	TILE_PAD_ZERO,
+} tilemode_t;
+#define ALPHASRCENABLE			BIT(8)
+#define ALPHACONSTENABLE		BIT(9)
+#define ALPHAMASKENABLE			BIT(10)
+#define ALPHATRANSENABLE		BIT(11)
+#define RGBALPHASRCENABLE		BIT(12)
+#define RGBALPHACONSTENABLE		BIT(13)
+#define RGBALPHAMASKENABLE		BIT(14)
+#define RGBALPHATRANSENABLE		BIT(15)
+#define PREMULCONSTRGB			BIT(16)
+typedef enum {
+	YUVCONVERSION__OFF,
+	YUVCONVERSION__ITU601,
+	YUVCONVERSION__ITU601_FR,
+	YUVCONVERSION__ITU709,
+} yuvconversion_t;
+#define GAMMAREMOVEENABLE		BIT(20)
+#define CLIPWINDOWENABLE		BIT(30)
+#define SOURCEBUFFERENABLE		BIT(31)
+#define EMPTYFRAME			BIT(31)
+#define FRAMEWIDTH(w)			(((w) - 1) & 0x3FFF)
+#define FRAMEHEIGHT(h)			((((h) - 1) & 0x3FFF) << 16)
+#define SHDTOKGEN			BIT(0)
+#define FETCHTYPE_MASK			0xF
+
+enum {
+	DPU_V1,
+	DPU_V2,
+};
+
+struct dpu_unit {
+	char *name;
+	unsigned int num;
+	const unsigned int *ids;
+	const unsigned long *pec_ofss;	/* PixEngCFG */
+	const unsigned long *ofss;
+};
+
+struct cm_reg_ofs {
+	u32 ipidentifier;
+	u32 lockunlock;
+	u32 lockstatus;
+	u32 userinterruptmask;
+	u32 interruptenable;
+	u32 interruptpreset;
+	u32 interruptclear;
+	u32 interruptstatus;
+	u32 userinterruptenable;
+	u32 userinterruptpreset;
+	u32 userinterruptclear;
+	u32 userinterruptstatus;
+	u32 generalpurpose;
+};
+
+struct dpu_devtype {
+	const unsigned long cm_ofs;	/* common */
+	const struct dpu_unit *cfs;
+	const struct dpu_unit *decs;
+	const struct dpu_unit *eds;
+	const struct dpu_unit *fds;
+	const struct dpu_unit *fgs;
+	const struct dpu_unit *fls;
+	const struct dpu_unit *lbs;
+	const struct dpu_unit *tcons;
+	const struct cm_reg_ofs *cm_reg_ofs;
+	const unsigned int *intsteer_map;
+	const unsigned int intsteer_map_size;
+	const unsigned long *unused_irq;
+	const unsigned int *sw2hw_irq_map;	/* NULL means linear */
+	const unsigned int *sw2hw_block_id_map;	/* NULL means linear */
+	bool has_capture;
+	bool pixel_link_quirks;
+	bool pixel_link_nhvsync;	/* HSYNC and VSYNC high active */
+	unsigned int version;
+};
+
+struct dpu_soc {
+	struct device		*dev;
+	const struct dpu_devtype	*devtype;
+	spinlock_t		lock;
+
+	void __iomem		*cm_reg;
+
+	int			id;
+	int			usecount;
+
+	struct regmap		*intsteer_regmap;
+	int			intsteer_usecount;
+	spinlock_t		intsteer_lock;
+	int			irq_cm;		/* irq common */
+	int			irq_stream0a;
+	int			irq_stream1a;
+	int			irq_reserved0;
+	int			irq_reserved1;
+	int			irq_blit;
+	struct irq_domain	*domain;
+
+	struct dpu_constframe	*cf_priv[4];
+	struct dpu_disengcfg	*dec_priv[2];
+	struct dpu_extdst	*ed_priv[4];
+	struct dpu_fetchdecode	*fd_priv[4];
+	struct dpu_fetchlayer	*fl_priv[2];
+	struct dpu_framegen	*fg_priv[2];
+	struct dpu_layerblend	*lb_priv[7];
+	struct dpu_tcon		*tcon_priv[2];
+};
+
+#define DECLARE_DPU_UNIT_INIT_FUNC(block)			\
+int dpu_##block##_init(struct dpu_soc *dpu, unsigned int id,	\
+			 unsigned long pec_base, unsigned long base)
+
+DECLARE_DPU_UNIT_INIT_FUNC(cf);
+DECLARE_DPU_UNIT_INIT_FUNC(dec);
+DECLARE_DPU_UNIT_INIT_FUNC(ed);
+DECLARE_DPU_UNIT_INIT_FUNC(fd);
+DECLARE_DPU_UNIT_INIT_FUNC(fg);
+DECLARE_DPU_UNIT_INIT_FUNC(fl);
+DECLARE_DPU_UNIT_INIT_FUNC(lb);
+DECLARE_DPU_UNIT_INIT_FUNC(tcon);
+
+static const unsigned int cf_ids[] = {0, 1, 4, 5};
+static const unsigned int dec_ids[] = {0, 1};
+static const unsigned int ed_ids[] = {0, 1, 4, 5};
+static const unsigned int fd_ids[] = {0, 1, 2, 3};
+static const unsigned int fg_ids[] = {0, 1};
+static const unsigned int fl_ids[] = {0, 1};
+static const unsigned int lb_ids[] = {0, 1, 2, 3, 4, 5, 6};
+static const unsigned int tcon_ids[] = {0, 1};
+
+struct dpu_pixel_format {
+	u32 pixel_format;
+	u32 bits;
+	u32 shift;
+};
+
+static const struct dpu_pixel_format dpu_pixel_format_matrix[] = {
+	{
+		DRM_FORMAT_XRGB8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(16) | G_SHIFT(8)  | B_SHIFT(0)  | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_XBGR8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(0)  | G_SHIFT(8)  | B_SHIFT(16) | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_RGBX8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(24) | G_SHIFT(16) | B_SHIFT(8)  | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_BGRX8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(8)  | G_SHIFT(16) | B_SHIFT(24) | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_RGB888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(16) | G_SHIFT(8)  | B_SHIFT(0)  | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_BGR888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(0)  | G_SHIFT(8)  | B_SHIFT(16) | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_RGB565,
+		R_BITS(5)   | G_BITS(6)   | B_BITS(5)   | A_BITS(0),
+		R_SHIFT(11) | G_SHIFT(5)  | B_SHIFT(0)  | A_SHIFT(0),
+	},
+};
+
+#endif				/* __DPU_PRV_H__ */
diff --git a/drivers/gpu/dpu/dpu-tcon.c b/drivers/gpu/dpu/dpu-tcon.c
new file mode 100644
index 0000000..8995e75
--- /dev/null
+++ b/drivers/gpu/dpu/dpu-tcon.c
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define SSQCNTS			0
+#define SSQCYCLE		0x8
+#define SWRESET			0xC
+#define TCON_CTRL		0x10
+#define BYPASS			BIT(3)
+#define RSDSINVCTRL		0x14
+#define MAPBIT3_0		0x18
+#define MAPBIT7_4		0x1C
+#define MAPBIT11_8		0x20
+#define MAPBIT15_12		0x24
+#define MAPBIT19_16		0x28
+#define MAPBIT23_20		0x2C
+#define MAPBIT27_24		0x30
+#define MAPBIT31_28		0x34
+#define MAPBIT34_32		0x38
+#define MAPBIT3_0_DUAL		0x3C
+#define MAPBIT7_4_DUAL		0x40
+#define MAPBIT11_8_DUAL		0x44
+#define MAPBIT15_12_DUAL	0x48
+#define MAPBIT19_16_DUAL	0x4C
+#define MAPBIT23_20_DUAL	0x50
+#define MAPBIT27_24_DUAL	0x54
+#define MAPBIT31_28_DUAL	0x58
+#define MAPBIT34_32_DUAL	0x5C
+#define SPGPOSON(n)		(0x60 + (n) * 16)
+#define X(n)			(((n) & 0x7FFF) << 16)
+#define Y(n)			((n) & 0x7FFF)
+#define SPGMASKON(n)		(0x64 + (n) * 16)
+#define SPGPOSOFF(n)		(0x68 + (n) * 16)
+#define SPGMASKOFF(n)		(0x6C + (n) * 16)
+#define SMXSIGS(n)		(0x120 + (n) * 8)
+#define SMXFCTTABLE(n)		(0x124 + (n) * 8)
+#define RESET_OVER_UNFERFLOW	0x180
+#define DUAL_DEBUG		0x184
+
+struct dpu_tcon {
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_tcon_read(struct dpu_tcon *tcon, unsigned int offset)
+{
+	return readl(tcon->base + offset);
+}
+
+static inline void dpu_tcon_write(struct dpu_tcon *tcon, u32 value,
+				  unsigned int offset)
+{
+	writel(value, tcon->base + offset);
+}
+
+int tcon_set_fmt(struct dpu_tcon *tcon, u32 bus_format)
+{
+	mutex_lock(&tcon->mutex);
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		dpu_tcon_write(tcon, 0x19181716, MAPBIT3_0);
+		dpu_tcon_write(tcon, 0x1d1c1b1a, MAPBIT7_4);
+		dpu_tcon_write(tcon, 0x0f0e0d0c, MAPBIT11_8);
+		dpu_tcon_write(tcon, 0x13121110, MAPBIT15_12);
+		dpu_tcon_write(tcon, 0x05040302, MAPBIT19_16);
+		dpu_tcon_write(tcon, 0x09080706, MAPBIT23_20);
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB888_1X30_PADLO:
+	case MEDIA_BUS_FMT_RGB666_1X30_PADLO:
+		dpu_tcon_write(tcon, 0x17161514, MAPBIT3_0);
+		dpu_tcon_write(tcon, 0x1b1a1918, MAPBIT7_4);
+		dpu_tcon_write(tcon, 0x0b0a1d1c, MAPBIT11_8);
+		dpu_tcon_write(tcon, 0x0f0e0d0c, MAPBIT15_12);
+		dpu_tcon_write(tcon, 0x13121110, MAPBIT19_16);
+		dpu_tcon_write(tcon, 0x03020100, MAPBIT23_20);
+		dpu_tcon_write(tcon, 0x07060504, MAPBIT27_24);
+		dpu_tcon_write(tcon, 0x00000908, MAPBIT31_28);
+		break;
+	default:
+		mutex_unlock(&tcon->mutex);
+		return -EINVAL;
+	}
+	mutex_unlock(&tcon->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tcon_set_fmt);
+
+void tcon_cfg_videomode(struct dpu_tcon *tcon, struct drm_display_mode *m)
+{
+	u32 val;
+
+	mutex_lock(&tcon->mutex);
+	val = dpu_tcon_read(tcon, TCON_CTRL);
+	val &= ~BYPASS;
+	dpu_tcon_write(tcon, val, TCON_CTRL);
+
+	/* dsp_control[0]: hsync */
+	dpu_tcon_write(tcon, X(m->hsync_start), SPGPOSON(0));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKON(0));
+
+	dpu_tcon_write(tcon, X(m->hsync_end), SPGPOSOFF(0));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKOFF(0));
+
+	dpu_tcon_write(tcon, 0x2, SMXSIGS(0));
+	dpu_tcon_write(tcon, 0x1, SMXFCTTABLE(0));
+
+	/* dsp_control[1]: vsync */
+	dpu_tcon_write(tcon, X(m->hsync_end) | Y(m->vsync_start - 1),
+								SPGPOSON(1));
+	dpu_tcon_write(tcon, 0x0, SPGMASKON(1));
+
+	dpu_tcon_write(tcon, X(m->hsync_end) | Y(m->vsync_end - 1),
+								SPGPOSOFF(1));
+	dpu_tcon_write(tcon, 0x0, SPGMASKOFF(1));
+
+	dpu_tcon_write(tcon, 0x3, SMXSIGS(1));
+	dpu_tcon_write(tcon, 0x1, SMXFCTTABLE(1));
+
+	/* dsp_control[2]: data enable */
+	/* horizontal */
+	dpu_tcon_write(tcon, 0x0, SPGPOSON(2));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKON(2));
+
+	dpu_tcon_write(tcon, X(m->hdisplay), SPGPOSOFF(2));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKOFF(2));
+
+	/* vertical */
+	dpu_tcon_write(tcon, 0x0, SPGPOSON(3));
+	dpu_tcon_write(tcon, 0x7fff0000, SPGMASKON(3));
+
+	dpu_tcon_write(tcon, Y(m->vdisplay), SPGPOSOFF(3));
+	dpu_tcon_write(tcon, 0x7fff0000, SPGMASKOFF(3));
+
+	dpu_tcon_write(tcon, 0x2c, SMXSIGS(2));
+	dpu_tcon_write(tcon, 0x8, SMXFCTTABLE(2));
+
+	/* dsp_control[3]: kachuck */
+	dpu_tcon_write(tcon, X(0xa) | Y(m->vdisplay), SPGPOSON(4));
+	dpu_tcon_write(tcon, 0x0, SPGMASKON(4));
+
+	dpu_tcon_write(tcon, X(0x2a) | Y(m->vdisplay), SPGPOSOFF(4));
+	dpu_tcon_write(tcon, 0x0, SPGMASKOFF(4));
+
+	dpu_tcon_write(tcon, 0x6, SMXSIGS(3));
+	dpu_tcon_write(tcon, 0x2, SMXFCTTABLE(3));
+	mutex_unlock(&tcon->mutex);
+}
+EXPORT_SYMBOL_GPL(tcon_cfg_videomode);
+
+struct dpu_tcon *dpu_tcon_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_tcon *tcon;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tcon_ids); i++)
+		if (tcon_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(tcon_ids))
+		return ERR_PTR(-EINVAL);
+
+	tcon = dpu->tcon_priv[i];
+
+	mutex_lock(&tcon->mutex);
+
+	if (tcon->inuse) {
+		tcon = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	tcon->inuse = true;
+out:
+	mutex_unlock(&tcon->mutex);
+
+	return tcon;
+}
+EXPORT_SYMBOL_GPL(dpu_tcon_get);
+
+void dpu_tcon_put(struct dpu_tcon *tcon)
+{
+	mutex_lock(&tcon->mutex);
+
+	tcon->inuse = false;
+
+	mutex_unlock(&tcon->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_tcon_put);
+
+int dpu_tcon_init(struct dpu_soc *dpu, unsigned int id,
+			unsigned long unused, unsigned long base)
+{
+	struct dpu_tcon *tcon;
+
+	tcon = devm_kzalloc(dpu->dev, sizeof(*tcon), GFP_KERNEL);
+	if (!tcon)
+		return -ENOMEM;
+
+	dpu->tcon_priv[id] = tcon;
+
+	tcon->base = devm_ioremap(dpu->dev, base, SZ_512);
+	if (!tcon->base)
+		return -ENOMEM;
+
+	tcon->dpu = dpu;
+	mutex_init(&tcon->mutex);
+
+	return 0;
+}
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 83d3d27..974febf 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -15,6 +15,7 @@ source "drivers/gpu/vga/Kconfig"
 
 source "drivers/gpu/host1x/Kconfig"
 source "drivers/gpu/ipu-v3/Kconfig"
+source "drivers/gpu/dpu/Kconfig"
 
 source "drivers/gpu/drm/Kconfig"
 
diff --git a/include/video/dpu.h b/include/video/dpu.h
new file mode 100644
index 0000000..4463afe
--- /dev/null
+++ b/include/video/dpu.h
@@ -0,0 +1,526 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __DRM_DPU_H__
+#define __DRM_DPU_H__
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_modes.h>
+#include <video/videomode.h>
+
+struct dpu_soc;
+
+enum dpu_irq {
+	IRQ_STORE9_SHDLOAD		= 0,
+	IRQ_STORE9_FRAMECOMPLETE	= 1,
+	IRQ_STORE9_SEQCOMPLETE		= 2,
+	IRQ_EXTDST0_SHDLOAD		= 3,
+	IRQ_EXTDST0_FRAMECOMPLETE	= 4,
+	IRQ_EXTDST0_SEQCOMPLETE		= 5,
+	IRQ_EXTDST4_SHDLOAD		= 6,
+	IRQ_EXTDST4_FRAMECOMPLETE	= 7,
+	IRQ_EXTDST4_SEQCOMPLETE		= 8,
+	IRQ_EXTDST1_SHDLOAD		= 9,
+	IRQ_EXTDST1_FRAMECOMPLETE	= 10,
+	IRQ_EXTDST1_SEQCOMPLETE		= 11,
+	IRQ_EXTDST5_SHDLOAD		= 12,
+	IRQ_EXTDST5_FRAMECOMPLETE	= 13,
+	IRQ_EXTDST5_SEQCOMPLETE		= 14,
+	IRQ_STORE4_SHDLOAD		= 15,
+	IRQ_STORE4_FRAMECOMPLETE	= 16,
+	IRQ_STORE4_SEQCOMPLETE		= 17,
+	IRQ_STORE5_SHDLOAD		= 18,
+	IRQ_STORE5_FRAMECOMPLETE	= 19,
+	IRQ_STORE5_SEQCOMPLETE		= 20,
+	IRQ_RESERVED21			= 21,
+	IRQ_HISTOGRAM4_VALID		= 22,
+	IRQ_RESERVED23			= 23,
+	IRQ_HISTOGRAM5_VALID		= 24,
+	IRQ_FRAMEDUMP0_ERROR		= 25,
+	IRQ_FRAMEDUMP1_ERROR		= 26,
+	IRQ_DISENGCFG_SHDLOAD0		= 27,
+	IRQ_DISENGCFG_FRAMECOMPLETE0	= 28,
+	IRQ_DISENGCFG_SEQCOMPLETE0	= 29,
+	IRQ_FRAMEGEN0_INT0		= 30,
+	IRQ_FRAMEGEN0_INT1		= 31,
+	IRQ_FRAMEGEN0_INT2		= 32,
+	IRQ_FRAMEGEN0_INT3		= 33,
+	IRQ_SIG0_SHDLOAD		= 34,
+	IRQ_SIG0_VALID			= 35,
+	IRQ_SIG0_ERROR			= 36,
+	IRQ_DISENGCFG_SHDLOAD1		= 37,
+	IRQ_DISENGCFG_FRAMECOMPLETE1	= 38,
+	IRQ_DISENGCFG_SEQCOMPLETE1	= 39,
+	IRQ_FRAMEGEN1_INT0		= 40,
+	IRQ_FRAMEGEN1_INT1		= 41,
+	IRQ_FRAMEGEN1_INT2		= 42,
+	IRQ_FRAMEGEN1_INT3		= 43,
+	IRQ_SIG1_SHDLOAD		= 44,
+	IRQ_SIG1_VALID			= 45,
+	IRQ_SIG1_ERROR			= 46,
+	IRQ_ITUIFC4_ERROR		= 47,
+	IRQ_ITUIFC5_ERROR		= 48,
+	IRQ_RESERVED49			= 49,
+	IRQ_CMDSEQ_ERROR		= 50,
+	IRQ_COMCTRL_SW0			= 51,
+	IRQ_COMCTRL_SW1			= 52,
+	IRQ_COMCTRL_SW2			= 53,
+	IRQ_COMCTRL_SW3			= 54,
+	IRQ_FRAMEGEN0_PRIMSYNC_ON	= 55,
+	IRQ_FRAMEGEN0_PRIMSYNC_OFF	= 56,
+	IRQ_FRAMEGEN0_SECSYNC_ON	= 57,
+	IRQ_FRAMEGEN0_SECSYNC_OFF	= 58,
+	IRQ_FRAMEGEN1_PRIMSYNC_ON	= 59,
+	IRQ_FRAMEGEN1_PRIMSYNC_OFF	= 60,
+	IRQ_FRAMEGEN1_SECSYNC_ON	= 61,
+	IRQ_FRAMEGEN1_SECSYNC_OFF	= 62,
+	IRQ_FRAMECAP4_SYNC_ON		= 63,
+	IRQ_FRAMECAP4_SYNC_OFF		= 64,
+	IRQ_CMD				= 65,
+	IRQ_FRAMECAP5_SYNC_OFF		= 66,
+};
+
+typedef enum {
+	ID_NONE		= 0x00,	/*  0 */
+	/* pixel engines */
+	ID_FETCHDECODE9	= 0x01,	/*  1 */
+	ID_FETCHPERSP9	= 0x02,	/*  2 */
+	ID_FETCHECO9	= 0x03,	/*  3 */
+	ID_ROP9		= 0x04,	/*  4 */
+	ID_CLUT9	= 0x05,	/*  5 */
+	ID_MATRIX9	= 0x06,	/*  6 */
+	ID_HSCALER9	= 0x07,	/*  7 */
+	ID_VSCALER9	= 0x08,	/*  8 */
+	ID_FILTER9	= 0x09,	/*  9 */
+	ID_BLITBLEND9	= 0x0A,	/* 10 */
+	ID_STORE9	= 0x0B,	/* 11 */
+	ID_CONSTFRAME0	= 0x0C,	/* 12 */
+	ID_EXTDST0	= 0x0D,	/* 13 */
+	ID_CONSTFRAME4	= 0x0E,	/* 14 */
+	ID_EXTDST4	= 0x0F,	/* 15 */
+	ID_CONSTFRAME1	= 0x10,	/* 16 */
+	ID_EXTDST1	= 0x11,	/* 17 */
+	ID_CONSTFRAME5	= 0x12,	/* 18 */
+	ID_EXTDST5	= 0x13,	/* 19 */
+	ID_EXTSRC4	= 0x14,	/* 20 */
+	ID_STORE4	= 0x15,	/* 21 */
+	ID_EXTSRC5	= 0x16,	/* 22 */
+	ID_STORE5	= 0x17,	/* 23 */
+	ID_FETCHDECODE2	= 0x18,	/* 24 */
+	ID_FETCHDECODE3	= 0x19,	/* 25 */
+	ID_FETCHWARP2	= 0x1A,	/* 26 */
+	ID_FETCHECO2	= 0x1B,	/* 27 */
+	ID_FETCHDECODE0	= 0x1C,	/* 28 */
+	ID_FETCHECO0	= 0x1D,	/* 29 */
+	ID_FETCHDECODE1	= 0x1E,	/* 30 */
+	ID_FETCHECO1	= 0x1F,	/* 31 */
+	ID_FETCHLAYER0	= 0x20,	/* 32 */
+	ID_FETCHLAYER1	= 0x21,	/* 33 */
+	ID_GAMMACOR4	= 0x22,	/* 34 */
+	ID_MATRIX4	= 0x23,	/* 35 */
+	ID_HSCALER4	= 0x24,	/* 36 */
+	ID_VSCALER4	= 0x25,	/* 37 */
+	ID_HISTOGRAM4	= 0x26,	/* 38 */
+	ID_GAMMACOR5	= 0x27,	/* 39 */
+	ID_MATRIX5	= 0x28,	/* 40 */
+	ID_HSCALER5	= 0x29,	/* 41 */
+	ID_VSCALER5	= 0x2A,	/* 42 */
+	ID_HISTOGRAM5	= 0x2B,	/* 43 */
+	ID_LAYERBLEND0	= 0x2C,	/* 44 */
+	ID_LAYERBLEND1	= 0x2D,	/* 45 */
+	ID_LAYERBLEND2	= 0x2E,	/* 46 */
+	ID_LAYERBLEND3	= 0x2F,	/* 47 */
+	ID_LAYERBLEND4	= 0x30,	/* 48 */
+	ID_LAYERBLEND5	= 0x31,	/* 49 */
+	ID_LAYERBLEND6	= 0x32,	/* 50 */
+	ID_EXTSRC0	= 0x33,	/* 51 */
+	ID_EXTSRC1	= 0x34,	/* 52 */
+	/* display engines */
+	ID_DISENGCFG	= 0x35,	/* 53 */
+	ID_FRAMEGEN0	= 0x36,	/* 54 */
+	ID_MATRIX0	= 0x37,	/* 55 */
+	ID_GAMMACOR0	= 0x38,	/* 56 */
+	ID_DITHER0	= 0x39,	/* 57 */
+	ID_TCON0	= 0x3A,	/* 58 */
+	ID_SIG0		= 0x3B,	/* 59 */
+	ID_FRAMEGEN1	= 0x3C,	/* 60 */
+	ID_MATRIX1	= 0x3D,	/* 61 */
+	ID_GAMMACOR1	= 0x3E,	/* 62 */
+	ID_DITHER1	= 0x3F,	/* 63 */
+	ID_TCON1	= 0x40,	/* 64 */
+	ID_SIG1		= 0x41,	/* 65 */
+	ID_FRAMECAP4	= 0x42,	/* 66 */
+	ID_FRAMECAP5	= 0x43,	/* 67 */
+} dpu_block_id_t;
+
+typedef enum {
+	ED_SRC_DISABLE		= ID_NONE,
+	ED_SRC_BLITBLEND9	= ID_BLITBLEND9,
+	ED_SRC_CONSTFRAME0	= ID_CONSTFRAME0,
+	ED_SRC_CONSTFRAME1	= ID_CONSTFRAME1,
+	ED_SRC_CONSTFRAME4	= ID_CONSTFRAME4,
+	ED_SRC_CONSTFRAME5	= ID_CONSTFRAME5,
+	ED_SRC_MATRIX4		= ID_MATRIX4,
+	ED_SRC_HSCALER4		= ID_HSCALER4,
+	ED_SRC_VSCALER4		= ID_VSCALER4,
+	/* content stream(extdst 0/1) only */
+	ED_SRC_EXTSRC4		= ID_EXTSRC4,
+	ED_SRC_MATRIX5		= ID_MATRIX5,
+	ED_SRC_HSCALER5		= ID_HSCALER5,
+	ED_SRC_VSCALER5		= ID_VSCALER5,
+	/* content stream(extdst 0/1) only */
+	ED_SRC_EXTSRC5		= ID_EXTSRC5,
+	ED_SRC_LAYERBLEND6	= ID_LAYERBLEND6,
+	ED_SRC_LAYERBLEND5	= ID_LAYERBLEND5,
+	ED_SRC_LAYERBLEND4	= ID_LAYERBLEND4,
+	ED_SRC_LAYERBLEND3	= ID_LAYERBLEND3,
+	ED_SRC_LAYERBLEND2	= ID_LAYERBLEND2,
+	ED_SRC_LAYERBLEND1	= ID_LAYERBLEND1,
+	ED_SRC_LAYERBLEND0	= ID_LAYERBLEND0,
+} extdst_src_sel_t;
+
+typedef enum {
+	SINGLE,	/* Reconfig pipeline after explicit trigger */
+	AUTO,	/* Reconfig pipeline after every kick when idle */
+} ed_sync_mode_t;
+
+typedef enum {
+	PSTATUS_EMPTY,
+	PSTATUS_RUNNING,
+	PSTATUS_RUNNING_RETRIGGERED,
+	PSTATUS_RESERVED
+} ed_pipeline_status_t;
+
+typedef enum {
+	SOFTWARE = 0,		/* kick generation by KICK field only */
+	EXTERNAL = BIT(8),	/* kick signal from external allowed */
+} ed_kick_mode_t;
+
+typedef enum {
+	SHLDREQID_FETCHDECODE9	= BIT(1),
+	SHLDREQID_FETCHPERSP9	= BIT(2),
+	SHLDREQID_FETCHECO9	= BIT(3),
+	SHLDREQID_CONSTFRAME0	= BIT(4),
+	SHLDREQID_CONSTFRAME4	= BIT(5),
+	SHLDREQID_CONSTFRAME1	= BIT(6),
+	SHLDREQID_CONSTFRAME5	= BIT(7),
+	SHLDREQID_EXTSRC4	= BIT(8),
+	SHLDREQID_EXTSRC5	= BIT(9),
+	SHLDREQID_FETCHDECODE2	= BIT(10),
+	SHLDREQID_FETCHDECODE3	= BIT(11),
+	SHLDREQID_FETCHWARP2	= BIT(12),
+	SHLDREQID_FETCHECO2	= BIT(13),
+	SHLDREQID_FETCHDECODE0	= BIT(14),
+	SHLDREQID_FETCHECO0	= BIT(15),
+	SHLDREQID_FETCHDECODE1	= BIT(16),
+	SHLDREQID_FETCHECO1	= BIT(17),
+	SHLDREQID_FETCHLAYER0	= BIT(18),
+	SHLDREQID_FETCHLAYER1	= BIT(19),
+	SHLDREQID_EXTSRC0	= BIT(20),
+	SHLDREQID_EXTSRC1	= BIT(21),
+} shadow_load_req_t;
+
+typedef enum {
+	PIXENGCFG_STATUS_SEL_DISABLE,
+	PIXENGCFG_STATUS_SEL_STORE9,
+	PIXENGCFG_STATUS_SEL_EXTDST0,
+	PIXENGCFG_STATUS_SEL_EXTDST4,
+	PIXENGCFG_STATUS_SEL_EXTDST1,
+	PIXENGCFG_STATUS_SEL_EXTDST5,
+	PIXENGCFG_STATUS_SEL_STORE4,
+	PIXENGCFG_STATUS_SEL_STORE5,
+} pixengcfg_status_sel_t;
+
+typedef enum {
+	FD_SRC_DISABLE		= ID_NONE,
+	FD_SRC_FETCHECO0	= ID_FETCHECO0,
+	FD_SRC_FETCHECO1	= ID_FETCHECO1,
+	FD_SRC_FETCHECO2	= ID_FETCHECO2,
+	FD_SRC_FETCHDECODE2	= ID_FETCHDECODE2,
+	FD_SRC_FETCHDECODE3	= ID_FETCHDECODE3,
+} fd_dynamic_src_sel_t;
+
+typedef enum {
+	/* RL and RLAD decoder */
+	FETCHTYPE__DECODE,
+	/* fractional plane(8 layers) */
+	FETCHTYPE__LAYER,
+	/* arbitrary warping and fractional plane(8 layers) */
+	FETCHTYPE__WARP,
+	/* minimum feature set for alpha, chroma and coordinate planes */
+	FETCHTYPE__ECO,
+	/* affine, perspective and arbitrary warping */
+	FETCHTYPE__PERSP,
+	/* affine and arbitrary warping */
+	FETCHTYPE__ROT,
+	/* RL and RLAD decoder, reduced feature set */
+	FETCHTYPE__DECODEL,
+	/* fractional plane(8 layers), reduced feature set */
+	FETCHTYPE__LAYERL,
+	/* affine and arbitrary warping, reduced feature set */
+	FETCHTYPE__ROTL,
+} fetchtype_t;
+
+typedef enum {
+	FGDM__BLACK,
+	/* Constant Color Background is shown. */
+	FGDM__CONSTCOL,
+	FGDM__PRIM,
+	FGDM__SEC,
+	FGDM__PRIM_ON_TOP,
+	FGDM__SEC_ON_TOP,
+	/* White color background with test pattern is shown. */
+	FGDM__TEST,
+} fgdm_t;
+
+typedef enum {
+	/* common options */
+	LB_PRIM_SEL__DISABLE		= ID_NONE,
+	LB_PRIM_SEL__BLITBLEND9		= ID_BLITBLEND9,
+	LB_PRIM_SEL__CONSTFRAME0	= ID_CONSTFRAME0,
+	LB_PRIM_SEL__CONSTFRAME1	= ID_CONSTFRAME1,
+	LB_PRIM_SEL__CONSTFRAME4	= ID_CONSTFRAME4,
+	LB_PRIM_SEL__CONSTFRAME5	= ID_CONSTFRAME5,
+	LB_PRIM_SEL__MATRIX4		= ID_MATRIX4,
+	LB_PRIM_SEL__HSCALER4		= ID_HSCALER4,
+	LB_PRIM_SEL__VSCALER4		= ID_VSCALER4,
+	LB_PRIM_SEL__EXTSRC4		= ID_EXTSRC4,
+	LB_PRIM_SEL__MATRIX5		= ID_MATRIX5,
+	LB_PRIM_SEL__HSCALER5		= ID_HSCALER5,
+	LB_PRIM_SEL__VSCALER5		= ID_VSCALER5,
+	LB_PRIM_SEL__EXTSRC5		= ID_EXTSRC5,
+	/*
+	 * special options:
+	 * layerblend(n) has n special options,
+	 * from layerblend0 to layerblend(n - 1), e.g.,
+	 * layerblend4 has 4 special options -
+	 * layerblend0/1/2/3.
+	 */
+	LB_PRIM_SEL__LAYERBLEND5	= ID_LAYERBLEND5,
+	LB_PRIM_SEL__LAYERBLEND4	= ID_LAYERBLEND4,
+	LB_PRIM_SEL__LAYERBLEND3	= ID_LAYERBLEND3,
+	LB_PRIM_SEL__LAYERBLEND2	= ID_LAYERBLEND2,
+	LB_PRIM_SEL__LAYERBLEND1	= ID_LAYERBLEND1,
+	LB_PRIM_SEL__LAYERBLEND0	= ID_LAYERBLEND0,
+} lb_prim_sel_t;
+
+typedef enum {
+	LB_SEC_SEL__DISABLE		= ID_NONE,
+	LB_SEC_SEL__FETCHDECODE2	= ID_FETCHDECODE2,
+	LB_SEC_SEL__FETCHDECODE3	= ID_FETCHDECODE3,
+	LB_SEC_SEL__FETCHWARP2		= ID_FETCHWARP2,
+	LB_SEC_SEL__FETCHDECODE0	= ID_FETCHDECODE0,
+	LB_SEC_SEL__FETCHDECODE1	= ID_FETCHDECODE1,
+	LB_SEC_SEL__MATRIX4		= ID_MATRIX4,
+	LB_SEC_SEL__HSCALER4		= ID_HSCALER4,
+	LB_SEC_SEL__VSCALER4		= ID_VSCALER4,
+	LB_SEC_SEL__MATRIX5		= ID_MATRIX5,
+	LB_SEC_SEL__HSCALER5		= ID_HSCALER5,
+	LB_SEC_SEL__VSCALER5		= ID_VSCALER5,
+	LB_SEC_SEL__FETCHLAYER0		= ID_FETCHLAYER0,
+	LB_SEC_SEL__FETCHLAYER1		= ID_FETCHLAYER1,
+} lb_sec_sel_t;
+
+typedef enum {
+	PRIMARY,	/* background plane */
+	SECONDARY,	/* foreground plane */
+	BOTH,
+} lb_shadow_sel_t;
+
+typedef enum {
+	NEUTRAL,	/* Output is same as primary input. */
+	BLEND,
+} lb_mode_t;
+
+#define CLKEN_MASK		(0x3 << 24)
+#define CLKEN_MASK_SHIFT	24
+typedef enum {
+	CLKEN__DISABLE = 0x0,
+	CLKEN__AUTOMATIC = 0x1,
+	CLKEN__FULL = 0x3,
+} lb_pixengcfg_clken_t;
+
+int dpu_map_irq(struct dpu_soc *dpu, int irq);
+
+/* Constant Frame Unit */
+struct dpu_constframe;
+void constframe_shden(struct dpu_constframe *cf, bool enable);
+void constframe_framedimensions(struct dpu_constframe *cf, unsigned int w,
+				unsigned int h);
+void constframe_constantcolor(struct dpu_constframe *cf, unsigned int r,
+			      unsigned int g, unsigned int b, unsigned int a);
+void constframe_controltrigger(struct dpu_constframe *cf, bool trigger);
+shadow_load_req_t constframe_to_shdldreq_t(struct dpu_constframe *cf);
+struct dpu_constframe *dpu_cf_get(struct dpu_soc *dpu, int id);
+void dpu_cf_put(struct dpu_constframe *cf);
+
+/* Display Engine Configuration Unit */
+struct dpu_disengcfg;
+void disengcfg_polarity_ctrl(struct dpu_disengcfg *dec, unsigned int flags);
+struct dpu_disengcfg *dpu_dec_get(struct dpu_soc *dpu, int id);
+void dpu_dec_put(struct dpu_disengcfg *dec);
+
+/* External Destination Unit */
+struct dpu_extdst;
+void extdst_pixengcfg_shden(struct dpu_extdst *ed, bool enable);
+void extdst_pixengcfg_powerdown(struct dpu_extdst *ed, bool powerdown);
+void extdst_pixengcfg_sync_mode(struct dpu_extdst *ed, ed_sync_mode_t mode);
+void extdst_pixengcfg_reset(struct dpu_extdst *ed, bool reset);
+void extdst_pixengcfg_div(struct dpu_extdst *ed, u16 div);
+int extdst_pixengcfg_src_sel(struct dpu_extdst *ed, extdst_src_sel_t src);
+void extdst_pixengcfg_sel_shdldreq(struct dpu_extdst *ed);
+void extdst_pixengcfg_shdldreq(struct dpu_extdst *ed, u32 req_mask);
+void extdst_pixengcfg_sync_trigger(struct dpu_extdst *ed);
+void extdst_pixengcfg_trigger_sequence_complete(struct dpu_extdst *ed);
+bool extdst_pixengcfg_is_sync_busy(struct dpu_extdst *ed);
+ed_pipeline_status_t extdst_pixengcfg_pipeline_status(struct dpu_extdst *ed);
+void extdst_shden(struct dpu_extdst *ed, bool enable);
+void extdst_kick_mode(struct dpu_extdst *ed, ed_kick_mode_t mode);
+void extdst_perfcountmode(struct dpu_extdst *ed, bool enable);
+void extdst_gamma_apply_enable(struct dpu_extdst *ed, bool enable);
+void extdst_kick(struct dpu_extdst *ed);
+void extdst_cnt_err_clear(struct dpu_extdst *ed);
+bool extdst_cnt_err_status(struct dpu_extdst *ed);
+u32 extdst_last_control_word(struct dpu_extdst *ed);
+void extdst_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y);
+void extdst_last_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y);
+u32 extdst_perfresult(struct dpu_extdst *ed);
+struct dpu_extdst *dpu_ed_get(struct dpu_soc *dpu, int id);
+void dpu_ed_put(struct dpu_extdst *ed);
+
+/* Fetch Decode Unit */
+struct dpu_fetchdecode;
+int fetchdecode_pixengcfg_dynamic_src_sel(struct dpu_fetchdecode *fd,
+					  fd_dynamic_src_sel_t src);
+void fetchdecode_shden(struct dpu_fetchdecode *fd, bool enable);
+void fetchdecode_baddr_autoupdate(struct dpu_fetchdecode *fd, u8 layer_mask);
+void fetchdecode_baseaddress(struct dpu_fetchdecode *fd, dma_addr_t paddr);
+void fetchdecode_source_bpp(struct dpu_fetchdecode *fd, int bpp);
+void fetchdecode_source_stride(struct dpu_fetchdecode *fd, int stride);
+void fetchdecode_src_buf_dimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				    unsigned int h);
+void fetchdecode_set_fmt(struct dpu_fetchdecode *fd, u32 fmt);
+void fetchdecode_layeroffset(struct dpu_fetchdecode *fd, unsigned int x,
+			     unsigned int y);
+void fetchdecode_clipoffset(struct dpu_fetchdecode *fd, unsigned int x,
+			    unsigned int y);
+void fetchdecode_clipdimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				unsigned int h);
+void fetchdecode_layerproperty(struct dpu_fetchdecode *fd, bool enable);
+void fetchdecode_framedimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				 unsigned int h);
+void fetchdecode_rgb_constantcolor(struct dpu_fetchdecode *fd,
+					u8 r, u8 g, u8 b, u8 a);
+void fetchdecode_yuv_constantcolor(struct dpu_fetchdecode *fd,
+					u8 y, u8 u, u8 v);
+void fetchdecode_controltrigger(struct dpu_fetchdecode *fd, bool trigger);
+int fetchdecode_fetchtype(struct dpu_fetchdecode *fd, fetchtype_t *type);
+shadow_load_req_t fetchdecode_to_shdldreq_t(struct dpu_fetchdecode *fd);
+struct dpu_fetchdecode *dpu_fd_get(struct dpu_soc *dpu, int id);
+void dpu_fd_put(struct dpu_fetchdecode *fd);
+
+/* Fetch Layer Unit */
+struct dpu_fetchlayer;
+void fetchlayer_shden(struct dpu_fetchlayer *fl, bool enable);
+void fetchlayer_baddr_autoupdate(struct dpu_fetchlayer *fl, u8 layer_mask);
+void fetchlayer_framedimensions(struct dpu_fetchlayer *fl, unsigned int w,
+				unsigned int h);
+void fetchlayer_rgb_constantcolor(struct dpu_fetchlayer *fl,
+					u8 r, u8 g, u8 b, u8 a);
+void fetchlayer_yuv_constantcolor(struct dpu_fetchlayer *fl, u8 y, u8 u, u8 v);
+void fetchlayer_controltrigger(struct dpu_fetchlayer *fl, bool trigger);
+int fetchlayer_fetchtype(struct dpu_fetchlayer *fl, fetchtype_t *type);
+struct dpu_fetchlayer *dpu_fl_get(struct dpu_soc *dpu, int id);
+void dpu_fl_put(struct dpu_fetchlayer *fl);
+
+/* Frame Generator Unit */
+struct dpu_framegen;
+void framegen_enable(struct dpu_framegen *fg);
+void framegen_disable(struct dpu_framegen *fg);
+void framegen_shdtokgen(struct dpu_framegen *fg);
+void framegen_cfg_videomode(struct dpu_framegen *fg,
+				struct drm_display_mode *m);
+void framegen_pkickconfig(struct dpu_framegen *fg, bool enable);
+void framegen_sacfg(struct dpu_framegen *fg, unsigned int x, unsigned int y);
+void framegen_displaymode(struct dpu_framegen *fg, fgdm_t mode);
+void framegen_panic_displaymode(struct dpu_framegen *fg, fgdm_t mode);
+void framegen_wait_done(struct dpu_framegen *fg);
+void framegen_enable_clock(struct dpu_framegen *fg);
+void framegen_disable_clock(struct dpu_framegen *fg);
+struct dpu_framegen *dpu_fg_get(struct dpu_soc *dpu, int id);
+void dpu_fg_put(struct dpu_framegen *fg);
+
+/* Layer Blend Unit */
+struct dpu_layerblend;
+int layerblend_pixengcfg_dynamic_prim_sel(struct dpu_layerblend *lb,
+					  lb_prim_sel_t prim);
+void layerblend_pixengcfg_dynamic_sec_sel(struct dpu_layerblend *lb,
+					  lb_sec_sel_t sec);
+void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
+				lb_pixengcfg_clken_t clken);
+void layerblend_shden(struct dpu_layerblend *lb, bool enable);
+void layerblend_shdtoksel(struct dpu_layerblend *lb, lb_shadow_sel_t sel);
+void layerblend_shdldsel(struct dpu_layerblend *lb, lb_shadow_sel_t sel);
+void layerblend_control(struct dpu_layerblend *lb, lb_mode_t mode);
+void layerblend_blendcontrol(struct dpu_layerblend *lb);
+void layerblend_position(struct dpu_layerblend *lb, int x, int y);
+u32 layerblend_last_control_word(struct dpu_layerblend *lb);
+void layerblend_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y);
+void layerblend_last_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y);
+u32 layerblend_perfresult(struct dpu_layerblend *lb);
+struct dpu_layerblend *dpu_lb_get(struct dpu_soc *dpu, int id);
+void dpu_lb_put(struct dpu_layerblend *lb);
+
+/* Timing Controller Unit */
+struct dpu_tcon;
+int tcon_set_fmt(struct dpu_tcon *tcon, u32 bus_format);
+void tcon_cfg_videomode(struct dpu_tcon *tcon, struct drm_display_mode *m);
+struct dpu_tcon *dpu_tcon_get(struct dpu_soc *dpu, int id);
+void dpu_tcon_put(struct dpu_tcon *tcon);
+
+#define MAX_FD_NUM	4
+#define MAX_LB_NUM	7
+struct dpu_plane_res {
+	struct dpu_constframe	*cf[2];
+	struct dpu_extdst	*ed[2];
+	struct dpu_fetchdecode	*fd[MAX_FD_NUM];
+	struct dpu_framegen	*fg;
+	struct dpu_layerblend	*lb[MAX_LB_NUM];
+};
+
+/*
+ * Each DPU plane can be a primary plane or an overlay plane
+ * of one of the DPU's two CRTCs.
+ */
+struct dpu_plane_grp {
+	struct dpu_plane_res	res;
+	struct list_head	list;
+	struct mutex		lock;
+	unsigned int		hw_plane_num;
+	unsigned int		id;
+};
+
+static inline struct dpu_plane_grp *plane_res_to_grp(struct dpu_plane_res *res)
+{
+	return container_of(res, struct dpu_plane_grp, res);
+}
+
+struct dpu_client_platformdata {
+	const unsigned int	stream_id;
+	struct dpu_plane_grp	*plane_grp;
+
+	struct device_node	*of_node;
+};
+#endif /* __DRM_DPU_H__ */
-- 
1.7.9.5


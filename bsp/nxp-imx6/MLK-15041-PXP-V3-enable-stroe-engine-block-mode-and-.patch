From e83b7045e0f6cc84b20f8cad62f5323b9283b9a4 Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Mon, 5 Jun 2017 10:05:20 +0800
Subject: [PATCH 1944/5242] MLK-15041: PXP-V3: enable stroe engine block mode
 and fill function

commit  4e263e9ce3be395d1a0884fa868a48f7fe6c2a14 from
https://source.codeaurora.org/external/imx/linux-imx.git

1. When pxp do rotation, fetch and store engine need block mode.
2. When use pxp store engine fill function, not only need config
store engine, but also need config fetch engine, otherwise, it
will not work.

Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/dma/pxp/pxp_dma_v3.c |   25 ++++++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/drivers/dma/pxp/pxp_dma_v3.c b/drivers/dma/pxp/pxp_dma_v3.c
index 5cc1c65..e8b5018 100644
--- a/drivers/dma/pxp/pxp_dma_v3.c
+++ b/drivers/dma/pxp/pxp_dma_v3.c
@@ -993,7 +993,6 @@ static void dump_pxp_reg2(struct pxps *pxp)
 	for (i=0; i< ((0x33C0/0x10) + 1);i++) {
 		printk("0x%08x: 0x%08x\n", 0x10*i, __raw_readl(pxp->base + 0x10*i));
 	}
-j++;
 #endif
 }
 
@@ -1372,12 +1371,16 @@ static uint32_t pxp_store_ctrl_config(struct pxp_pixmap *out, uint8_t mode,
 			ctrl.store_memory_en = 1;
 		}
 	} else {
-		if (fill_en)
+		if (fill_en) {
 			ctrl.fill_data_en = 1;
+			ctrl.wr_num_bytes = 2;
+		}
 		ctrl.store_memory_en = 1;
 	}
 
-	ctrl.block_en = 1;
+	if (out->rotate || out->flip)
+		ctrl.block_en = 1;
+
 	ctrl.ch_en = 1;
 
 	return *(uint32_t *)&ctrl;
@@ -2532,9 +2535,17 @@ static int pxp_store_config(struct pxp_pixmap *output,
 	pxp_writel(shift_ctrl, HW_PXP_INPUT_STORE_SHIFT_CTRL_CH0);
 	pxp_writel(store_size, HW_PXP_INPUT_STORE_SIZE_CH0);
 	pxp_writel(store_pitch, HW_PXP_INPUT_STORE_PITCH);
-	if (op->fill_en)
+	if (op->fill_en) {
+		uint32_t lrc;
+
+		lrc = (output->width - 1) | ((output->height - 1) << 16);
 		pxp_writel(op->fill_data, HW_PXP_INPUT_STORE_FILL_DATA_CH0);
 
+		pxp_writel(0x1, HW_PXP_INPUT_FETCH_CTRL_CH0);
+		pxp_writel(0, HW_PXP_INPUT_FETCH_ACTIVE_SIZE_ULC_CH0);
+		pxp_writel(lrc, HW_PXP_INPUT_FETCH_ACTIVE_SIZE_LRC_CH0);
+	}
+
 	offset = output->crop.y * output->pitch +
 		 output->crop.x * (output->bpp >> 3);
 	if (is_yuv(output->format == 2)) {
@@ -2618,6 +2629,7 @@ static int pxp_2d_task_config(struct pxp_pixmap *input,
 {
 	uint8_t position = 0;
 
+
 	do {
 		position = find_next_bit((unsigned long *)&nodes_used, 32, position);
 		if (position >= sizeof(uint32_t) * 8)
@@ -2778,8 +2790,11 @@ static int pxp_2d_op_handler(struct pxps *pxp)
 		if (!input->pitch)
 			return -EINVAL;
 
-		if (input->rotate || input->flip)
+		if (input->rotate || input->flip) {
 			input->flags |= IN_NEED_ROTATE_FLIP;
+			output->rotate = input->rotate;
+			output->flip = input->flip;
+		}
 
 		if (!is_yuv(input->format) != !is_yuv(output->format))
 			input->flags |= IN_NEED_CSC;
-- 
1.7.9.5


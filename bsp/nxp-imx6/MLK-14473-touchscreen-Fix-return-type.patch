From ce6a7db15edcbaf8d1b15398f2cd68542ce54542 Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Thu, 16 Mar 2017 12:20:45 +0200
Subject: [PATCH 1620/5242] MLK-14473: touchscreen: Fix return type

commit  ee6600e9d850961665c335fa67e3b287cb3692b9 from
https://source.codeaurora.org/external/imx/linux-imx.git

The touchscreen driver, max11801, which is on 12c2 bus, won't be probed
when using the hdcp specific DTS (this is disabling 12c2, since it
will acquire it for DDC communications). Since this driver won't be
probed, it will spam the dmesg with the pr_err from max11801_read_adc()
function. This function is periodically called by the battery driver. For
this reason, I removed the pr_err() call.
Also, to be noticed that the function signature is u32, but in case of an
error it will return a negative integer. In order to correctly propagate
errors, I changed the function signature to int. This is safe, since the
read value from i2c is on 16 bits (MSB and LSB on 8 bits).

Also, the function calibration_voltage is calling max11801_read_adc from
touchscreen driverm which can return negative values in case of an
error. I case of an error, just stop reading ADC data and return 0 as
voltage_data.

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/input/touchscreen/max11801_ts.c |   24 ++++++++++++------------
 drivers/power/supply/sabresd_battery.c  |   12 +++++++++---
 2 files changed, 21 insertions(+), 15 deletions(-)

diff --git a/drivers/input/touchscreen/max11801_ts.c b/drivers/input/touchscreen/max11801_ts.c
index ac9c11e..03ac81b 100644
--- a/drivers/input/touchscreen/max11801_ts.c
+++ b/drivers/input/touchscreen/max11801_ts.c
@@ -114,26 +114,28 @@ static int max11801_dcm_write_command(struct i2c_client *client, int command)
 	return i2c_smbus_write_byte(client, command);
 }
 
-static u32 max11801_dcm_sample_aux(struct i2c_client *client)
+static int max11801_dcm_sample_aux(struct i2c_client *client)
 {
 	int ret;
 	int aux = 0;
-	u32 sample_data;
+	int sample_data;
 
 	/* AUX_measurement */
 	max11801_dcm_write_command(client, AUX_measurement);
 	mdelay(5);
 	ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_AUX_MSB,
 						1, &aux_buf[0]);
-	if (ret < 1) {
-		dev_err(&client->dev, "FIFO_RD_AUX_MSB read fails\n");
+	if (ret < 0) {
+		dev_err(&client->dev, "FIFO_RD_AUX_MSB read failed (%d)\n",
+			ret);
 		return ret;
 	}
 	mdelay(5);
 	ret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_AUX_LSB,
 						1, &aux_buf[1]);
-	if (ret < 1) {
-		dev_err(&client->dev, "FIFO_RD_AUX_LSB read fails\n");
+	if (ret < 0) {
+		dev_err(&client->dev, "FIFO_RD_AUX_LSB read failed (%d)\n",
+			ret);
 		return ret;
 	}
 
@@ -149,14 +151,12 @@ static u32 max11801_dcm_sample_aux(struct i2c_client *client)
 	return sample_data;
 }
 
-u32 max11801_read_adc(void)
+int max11801_read_adc(void)
 {
-	u32 adc_data;
+	int adc_data;
 
-	if (!max11801_client) {
-		pr_err("FAIL  max11801_client not initialize\n");
-		return -1;
-	}
+	if (!max11801_client)
+		return -ENODEV;
 	adc_data = max11801_dcm_sample_aux(max11801_client);
 
 	return adc_data;
diff --git a/drivers/power/supply/sabresd_battery.c b/drivers/power/supply/sabresd_battery.c
index 042ee5b..5f479f8 100644
--- a/drivers/power/supply/sabresd_battery.c
+++ b/drivers/power/supply/sabresd_battery.c
@@ -193,7 +193,7 @@ u32 calibrate_battery_capability_percent(struct max8903_data *data)
 	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
 };
 
-extern u32 max11801_read_adc(void);
+extern int max11801_read_adc(void);
 
 static void max8903_charger_update_status(struct max8903_data *data)
 {
@@ -227,6 +227,7 @@ static void max8903_charger_update_status(struct max8903_data *data)
 u32 calibration_voltage(struct max8903_data *data)
 {
 	u32 voltage_data = 0;
+	int adc_val = 0;
 	int i;
 	int offset;
 
@@ -238,8 +239,13 @@ u32 calibration_voltage(struct max8903_data *data)
 		offset = offset_charger;
 
 	/* simple average */
-	for (i = 0; i < ADC_SAMPLE_COUNT; i++)
-		voltage_data += max11801_read_adc()-offset;
+	for (i = 0; i < ADC_SAMPLE_COUNT; i++) {
+		adc_val = max11801_read_adc();
+		/* Check if touch driver is probed */
+		if (max11801_read_adc() < 0)
+			break;
+		voltage_data += adc_val - offset;
+	}
 	voltage_data = voltage_data / ADC_SAMPLE_COUNT;
 	dev_dbg(data->dev, "volt: %d\n", voltage_data);
 
-- 
1.7.9.5


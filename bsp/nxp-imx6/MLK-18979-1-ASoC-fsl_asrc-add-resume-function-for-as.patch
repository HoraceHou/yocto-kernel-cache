From 94d747400c6fc98acc4c26ac0661b98bae893b6c Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@nxp.com>
Date: Tue, 4 Sep 2018 15:39:23 +0800
Subject: [PATCH 4547/5242] MLK-18979-1: ASoC: fsl_asrc: add resume function
 for asrc_m2m

commit  7268718ae33e53ea3be9f7e7565df5f2f6e39f91 from
https://source.codeaurora.org/external/imx/linux-imx.git

There will be "output DMA task timeout" after suspend and resume.
The reason is there is not enough data in the input FIFO.

In the fsl_asrc_start_pair function we initialize the FIFO with
zero data after pair is enabled, it looks like we add more data
to input FIFO. For example if the input buffer length is 100,
but the actual length is 100 + channel*4. so we need to do same
work in resume for the asrc pair is disabled in suspend, the
input FIFO is cleared.

Signed-off-by: Shengjiu Wang <shengjiu.wang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_asrc.c     |    3 +++
 sound/soc/fsl/fsl_asrc_m2m.c |   25 +++++++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c
index 7822232..aacefa9 100644
--- a/sound/soc/fsl/fsl_asrc.c
+++ b/sound/soc/fsl/fsl_asrc.c
@@ -1310,10 +1310,13 @@ static int fsl_asrc_suspend(struct device *dev)
 
 static int fsl_asrc_resume(struct device *dev)
 {
+	struct fsl_asrc *asrc_priv = dev_get_drvdata(dev);
 	int ret;
 
 	ret = pm_runtime_force_resume(dev);
 
+	fsl_asrc_m2m_resume(asrc_priv);
+
 	return ret;
 }
 #endif /* CONFIG_PM_SLEEP */
diff --git a/sound/soc/fsl/fsl_asrc_m2m.c b/sound/soc/fsl/fsl_asrc_m2m.c
index 2684518..9c5a2a2 100644
--- a/sound/soc/fsl/fsl_asrc_m2m.c
+++ b/sound/soc/fsl/fsl_asrc_m2m.c
@@ -1021,3 +1021,28 @@ static void fsl_asrc_m2m_suspend(struct fsl_asrc *asrc_priv)
 		spin_unlock_irqrestore(&asrc_priv->lock, lock_flags);
 	}
 }
+
+static void fsl_asrc_m2m_resume(struct fsl_asrc *asrc_priv)
+{
+	struct fsl_asrc_pair *pair;
+	struct fsl_asrc_m2m *m2m;
+	unsigned long lock_flags;
+	enum asrc_pair_index index;
+	int i, j;
+
+	for (i = 0; i < ASRC_PAIR_MAX_NUM; i++) {
+		spin_lock_irqsave(&asrc_priv->lock, lock_flags);
+		pair = asrc_priv->pair[i];
+		if (!pair || !pair->private) {
+			spin_unlock_irqrestore(&asrc_priv->lock, lock_flags);
+			continue;
+		}
+		m2m = pair->private;
+		index = pair->index;
+
+		for (j = 0; j < pair->channels * 4; j++)
+			regmap_write(asrc_priv->regmap, REG_ASRDI(index), 0);
+
+		spin_unlock_irqrestore(&asrc_priv->lock, lock_flags);
+	}
+}
-- 
1.7.9.5


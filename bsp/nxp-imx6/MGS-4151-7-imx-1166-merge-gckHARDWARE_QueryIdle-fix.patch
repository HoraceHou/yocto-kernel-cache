From c9f16ed3b754ba57e6440460ee25451b5cc1fcac Mon Sep 17 00:00:00 2001
From: Xianzhong <xianzhong.li@nxp.com>
Date: Sat, 8 Sep 2018 05:42:51 +0800
Subject: [PATCH 4598/5242] MGS-4151-7 [#imx-1166] merge gckHARDWARE_QueryIdle
 fix

commit  200afad9bebd67f9cc6e380db3cb6e2c0d76df40 from
https://source.codeaurora.org/external/imx/linux-imx.git

CL165805 fix issues in query hardware idle 1. add check for
 async fe. 2. refine code

cherry-pick patch:
6.2.4.p3-0020-CL165805-fix-issues-in-query-hardware-idle-1.-add-ch

Signed-off-by: Xianzhong <xianzhong.li@nxp.com>
(cherry picked from commit 1c85c41e09dd875f809208cc15c74dde4e7ab980)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../hal/kernel/arch/gc_hal_kernel_hardware.c       |  110 ++++++++++++--------
 1 file changed, 64 insertions(+), 46 deletions(-)

diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
index 32c58b9..9a2fd6d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
@@ -9127,10 +9127,14 @@
     )
 {
     gceSTATUS status;
-    gctUINT32 idle, address;
-    gctBOOL   isIdle;
+    gctUINT32 idle;
+#if !gcdSECURITY
+    gctUINT32 address;
+#endif
+    gctBOOL isIdle = gcvFALSE;
 
 #if gcdINTERRUPT_STATISTIC
+    gckEVENT eventObj = Hardware->kernel->eventObj;
     gctINT32 pendingInterrupt;
 #endif
 
@@ -9140,14 +9144,15 @@
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
     gcmkVERIFY_ARGUMENT(IsIdle != gcvNULL);
 
-    /* We are idle when the power is not ON. */
-    if (Hardware->chipPowerState != gcvPOWER_ON)
+    do
     {
-        isIdle = gcvTRUE;
-    }
+        /* We are idle when the power is not ON. */
+        if (Hardware->chipPowerState != gcvPOWER_ON)
+        {
+            isIdle = gcvTRUE;
+            break;
+        }
 
-    else
-    {
         /* Read idle register. */
         gcmkONERROR(
             gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00004, &idle));
@@ -9156,56 +9161,69 @@
         if ((idle | (1 << 14)) != 0x7ffffffe)
         {
             /* Something is busy. */
-            isIdle = gcvFALSE;
+            break;
         }
 
-        else
-        {
 #if gcdSECURITY
-            isIdle = gcvTRUE;
-            address = 0;
+        isIdle = gcvTRUE;
+        break;
 #else
-            /* Read the current FE address. */
-            gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
-                                             Hardware->core,
-                                             0x00664,
-                                             &address));
+        /* Read the current FE address. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00664,
+                                         &address));
 
-            gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
-                                             Hardware->core,
-                                             0x00664,
-                                             &address));
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00664,
+                                         &address));
 
-            /* Test if address is inside the last WAIT/LINK sequence. */
-            if ((address >= Hardware->lastWaitLink)
-            &&  (address <= Hardware->lastWaitLink + (Hardware->hasL2Cache ? 16 : 8))
-            )
-            {
-                /* FE is in last WAIT/LINK and the pipe is idle. */
-                isIdle = gcvTRUE;
-            }
-            else
-            {
-                /* FE is not in WAIT/LINK yet. */
-                isIdle = gcvFALSE;
-            }
-#endif
+        /* Test if address is inside the last WAIT/LINK sequence. */
+        if ((address < Hardware->lastWaitLink) ||
+            (address >= (gctUINT64)Hardware->lastWaitLink + 16))
+        {
+            /* FE is not in WAIT/LINK yet. */
+            break;
         }
-    }
+#endif
 
 #if gcdINTERRUPT_STATISTIC
-    gcmkONERROR(gckOS_AtomGet(
-        Hardware->os,
-        Hardware->kernel->eventObj->interruptCount,
-        &pendingInterrupt
-        ));
+        gcmkONERROR(gckOS_AtomGet(
+            Hardware->os,
+            eventObj->interruptCount,
+            &pendingInterrupt
+            ));
 
-    if (pendingInterrupt)
-    {
-        isIdle = gcvFALSE;
-    }
+        if (pendingInterrupt)
+        {
+            /* Pending interrupts, not idle. */
+            break;
+        }
+
+        if (Hardware->hasAsyncFe)
+        {
+            gckEVENT asyncEvent = Hardware->kernel->asyncEvent;
+
+            gcmkONERROR(gckOS_AtomGet(
+                Hardware->os,
+                asyncEvent->interruptCount,
+                &pendingInterrupt
+                ));
+
+            if (pendingInterrupt)
+            {
+                /* Pending async FE interrupts, not idle. */
+                break;
+            }
+        }
 #endif
 
+        /* Is really idle. */
+        isIdle = gcvTRUE;
+    }
+    while (gcvFALSE);
+
     *IsIdle = isIdle;
 
     /* Success. */
-- 
1.7.9.5


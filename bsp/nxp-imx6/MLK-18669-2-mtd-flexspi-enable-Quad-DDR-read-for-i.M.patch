From 3e522614409d0e63261257de08a51a9e4d1d0c8b Mon Sep 17 00:00:00 2001
From: Han Xu <han.xu@nxp.com>
Date: Fri, 22 Jun 2018 11:31:48 -0500
Subject: [PATCH 4345/5242] MLK-18669-2: mtd: flexspi: enable Quad DDR read
 for i.MX8MM FlexSPI Nor

commit  af07ee68001eb5de0355552d9d49257f871cfd85 from
https://source.codeaurora.org/external/imx/linux-imx.git

i.MX8MM MEK only supports Quad mode for flexspi nor, enable the quad ddr
mode for better performance.

Signed-off-by: Han Xu <han.xu@nxp.com>
(cherry picked from commit a0abea8ca8d493fc2861c84f1475c0eb388899ce)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mtd/spi-nor/fsl-flexspi.c |   17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/drivers/mtd/spi-nor/fsl-flexspi.c b/drivers/mtd/spi-nor/fsl-flexspi.c
index a5523eb..a636506 100644
--- a/drivers/mtd/spi-nor/fsl-flexspi.c
+++ b/drivers/mtd/spi-nor/fsl-flexspi.c
@@ -32,6 +32,9 @@
 #include <soc/imx8/sc/sci.h>
 #include <linux/pm_runtime.h>
 
+/* Board only enabled up to Quad mode, not Octal*/
+#define FLEXSPI_QUIRK_QUAD_ONLY		(1 << 0)
+
 /* runtime pm timeout */
 #define FSL_FLEXSPI_RPM_TIMEOUT 50 /* 50ms */
 
@@ -442,7 +445,7 @@ struct fsl_flexspi_devtype_data {
 	.rxfifo = 1024,
 	.txfifo = 1024,
 	.ahb_buf_size = 2048,
-	.driver_data = 0,
+	.driver_data = FLEXSPI_QUIRK_QUAD_ONLY,
 };
 
 #define FSL_FLEXSPI_MAX_CHIP	4
@@ -468,6 +471,11 @@ struct fsl_flexspi {
 	struct pm_qos_request pm_qos_req;
 };
 
+static inline int fsl_flexspi_quad_only(struct fsl_flexspi *flex)
+{
+	return flex->devtype_data->driver_data & FLEXSPI_QUIRK_QUAD_ONLY;
+}
+
 static inline void fsl_flexspi_unlock_lut(struct fsl_flexspi *flex)
 {
 	writel(FLEXSPI_LUTKEY_VALUE, flex->iobase + FLEXSPI_LUTKEY);
@@ -556,11 +564,11 @@ static void fsl_flexspi_init_lut(struct fsl_flexspi *flex)
 	/* DDR Quad Fast Read 	 */
 	} else if (op == SPINOR_OP_READ_1_1_4_D) {
 		/* read mode : 1-1-4, such as Micron N25Q256A. */
-		writel(LUT0(CMD_DDR, PAD1, op) |
+		writel(LUT0(CMD, PAD1, op) |
 		       LUT1(ADDR_DDR, PAD1, addrlen),
 		       base + FLEXSPI_LUT(lut_base));
 
-		writel(LUT0(DUMMY, PAD1, dm) |
+		writel(LUT0(DUMMY_DDR, PAD4, dm * 2) |
 		       LUT1(READ_DDR, PAD4, 0),
 		       base + FLEXSPI_LUT(lut_base + 1));
 
@@ -1302,7 +1310,8 @@ static int fsl_flexspi_probe(struct platform_device *pdev)
 		ret = of_property_read_u32(np, "spi-nor,ddr-quad-read-dummy",
 					&dummy);
 		if (!ret && dummy > 0)
-			hwcaps.mask |= SNOR_HWCAPS_READ;
+			hwcaps.mask |= fsl_flexspi_quad_only(flex) ?
+				    SNOR_HWCAPS_READ_1_1_4 :SNOR_HWCAPS_READ_1_8_8;
 		else
 			hwcaps.mask |= SNOR_HWCAPS_READ;
 
-- 
1.7.9.5


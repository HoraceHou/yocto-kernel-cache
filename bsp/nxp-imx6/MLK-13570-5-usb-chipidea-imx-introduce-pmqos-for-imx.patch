From 05cbfe01c33e3102c6a79db7952f1d16e43a3df8 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Tue, 6 Dec 2016 10:06:31 +0800
Subject: [PATCH 1343/5242] MLK-13570-5 usb: chipidea: imx: introduce pmqos
 for imx7ulp

commit  2452f593d2a53c9bf5b64768a0d13cc3a5d9c449 from
https://source.codeaurora.org/external/imx/linux-imx.git

At imx7ulp, if the system enters idle, it will close some clocks and affect
USB transfer. In order to avoid it, we request pmqos to avoid system
entering idle when the USB is in use.

Signed-off-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |   30 ++++++++++++++++++++++++++++--
 include/linux/usb/chipidea.h       |    2 ++
 2 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index fc15c3a..7b3543e 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -19,6 +19,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/regulator/consumer.h>
 #include <linux/busfreq-imx.h>
+#include <linux/pm_qos.h>
 
 #include "ci.h"
 #include "ci_hdrc_imx.h"
@@ -73,6 +74,12 @@ struct ci_hdrc_imx_platform_flag {
 	.flags = CI_HDRC_SUPPORTS_RUNTIME_PM,
 };
 
+static const struct ci_hdrc_imx_platform_flag imx7ulp_usb_data = {
+	.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |
+		CI_HDRC_IMX_EHCI_QUIRK |
+		CI_HDRC_PMQOS,
+};
+
 static const struct of_device_id ci_hdrc_imx_dt_ids[] = {
 	{ .compatible = "fsl,imx23-usb", .data = &imx23_usb_data},
 	{ .compatible = "fsl,imx28-usb", .data = &imx28_usb_data},
@@ -82,6 +89,7 @@ struct ci_hdrc_imx_platform_flag {
 	{ .compatible = "fsl,imx6sx-usb", .data = &imx6sx_usb_data},
 	{ .compatible = "fsl,imx6ul-usb", .data = &imx6ul_usb_data},
 	{ .compatible = "fsl,imx7d-usb", .data = &imx7d_usb_data},
+	{ .compatible = "fsl,imx7ulp-usb", .data = &imx7ulp_usb_data},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, ci_hdrc_imx_dt_ids);
@@ -107,6 +115,7 @@ struct ci_hdrc_imx_data {
 	struct clk *clk_ahb;
 	struct clk *clk_per;
 	/* --------------------------------- */
+	struct pm_qos_request pm_qos_req;
 };
 
 static char *imx_usb_charger_supplied_to[] = {
@@ -474,6 +483,7 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, data);
 
 	data->data = imx_platform_flag;
+	pdata.flags |= imx_platform_flag->flags;
 	data->usbmisc_data = usbmisc_get_init_data(&pdev->dev);
 	if (IS_ERR(data->usbmisc_data))
 		return PTR_ERR(data->usbmisc_data);
@@ -512,6 +522,10 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 		return ret;
 
 	request_bus_freq(BUS_FREQ_HIGH);
+	if (pdata.flags & CI_HDRC_PMQOS)
+		pm_qos_add_request(&data->pm_qos_req,
+			PM_QOS_CPU_DMA_LATENCY, 0);
+
 	ret = imx_prepare_enable_clks(&pdev->dev);
 	if (ret)
 		goto err_bus_freq;
@@ -535,7 +549,6 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 		usb_phy_init(pdata.usb_phy);
 	}
 
-	pdata.flags |= imx_platform_flag->flags;
 	if (pdata.flags & CI_HDRC_SUPPORTS_RUNTIME_PM)
 		data->supports_runtime_pm = true;
 
@@ -645,6 +658,8 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 err_clk:
 	imx_disable_unprepare_clks(&pdev->dev);
 err_bus_freq:
+	if (pdata.flags & CI_HDRC_PMQOS)
+		pm_qos_remove_request(&data->pm_qos_req);
 	release_bus_freq(BUS_FREQ_HIGH);
 	return ret;
 }
@@ -662,6 +677,8 @@ static int ci_hdrc_imx_remove(struct platform_device *pdev)
 	if (data->override_phy_control)
 		usb_phy_shutdown(data->phy);
 	imx_disable_unprepare_clks(&pdev->dev);
+	if (data->data->flags & CI_HDRC_PMQOS)
+		pm_qos_remove_request(&data->pm_qos_req);
 	release_bus_freq(BUS_FREQ_HIGH);
 	if (data->hsic_pad_regulator)
 		regulator_disable(data->hsic_pad_regulator);
@@ -692,6 +709,8 @@ static int imx_controller_suspend(struct device *dev)
 	}
 
 	imx_disable_unprepare_clks(dev);
+	if (data->data->flags & CI_HDRC_PMQOS)
+		pm_qos_remove_request(&data->pm_qos_req);
 	release_bus_freq(BUS_FREQ_HIGH);
 	data->in_lpm = true;
 
@@ -711,9 +730,12 @@ static int imx_controller_resume(struct device *dev)
 	}
 
 	request_bus_freq(BUS_FREQ_HIGH);
+	if (data->data->flags & CI_HDRC_PMQOS)
+		pm_qos_add_request(&data->pm_qos_req,
+			PM_QOS_CPU_DMA_LATENCY, 0);
 	ret = imx_prepare_enable_clks(dev);
 	if (ret)
-		return ret;
+		goto err_bus_freq;
 
 	data->in_lpm = false;
 
@@ -745,6 +767,10 @@ static int imx_controller_resume(struct device *dev)
 	imx_usbmisc_set_wakeup(data->usbmisc_data, true);
 clk_disable:
 	imx_disable_unprepare_clks(dev);
+err_bus_freq:
+	if (data->data->flags & CI_HDRC_PMQOS)
+		pm_qos_remove_request(&data->pm_qos_req);
+	release_bus_freq(BUS_FREQ_HIGH);
 	return ret;
 }
 
diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 707a595..91250f5 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -62,6 +62,8 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
 #define CI_HDRC_IMX_EHCI_QUIRK		BIT(14)
 #define CI_HDRC_IMX_IS_HSIC		BIT(15)
+/* need request pmqos during low power */
+#define CI_HDRC_PMQOS			BIT(16)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
-- 
1.7.9.5


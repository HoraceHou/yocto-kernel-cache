From 41c1457a7a4391997b61d4d540b7ed44f3b8c154 Mon Sep 17 00:00:00 2001
From: Jason Liu <jason.hui.liu@nxp.com>
Date: Fri, 16 Jun 2017 06:55:33 +0800
Subject: [PATCH 2136/5242] MLK-16005-2 arm64: tlb: add the SW workaround for
 i.MX8QM TKT340553

commit  8624c95644b5b2bb28f48effc8878f695af2ff70 from
https://source.codeaurora.org/external/imx/linux-imx.git

on i.MX8QM TO1.0, there is an issue: the bus width between A53-CCI-A72
is limited to 36bits.TLB maintenance through DVM messages over AR channel,
some bits will be forced(truncated) to zero as the followings:

ASID[15:12] is forced to 0
VA[48:45] is forced to 0
VA[44:41] is forced to 0
VA[39:36] is forced to 0

This issue will result in the TLB aintenance across the clusters not working
as expected due to some VA and ASID bits get truncated and forced to be zero.

The SW workaround is: use the vmalle1is if VA larger than 36bits or
ASID[15:12] is not zero, otherwise, we use original TLB maintenance path.

Signed-off-by: Jason Liu <jason.hui.liu@nxp.com>
Reviewed-by: Anson Huang <anson.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm64/include/asm/tlbflush.h |   41 +++++++++++++++++++++++++++++--------
 drivers/soc/imx/soc-imx8.c        |    9 +++++++-
 2 files changed, 40 insertions(+), 10 deletions(-)

diff --git a/arch/arm64/include/asm/tlbflush.h b/arch/arm64/include/asm/tlbflush.h
index dfc61d7..e04a34b 100644
--- a/arch/arm64/include/asm/tlbflush.h
+++ b/arch/arm64/include/asm/tlbflush.h
@@ -24,6 +24,7 @@
 #include <linux/sched.h>
 #include <asm/cputype.h>
 #include <asm/mmu.h>
+#include <soc/imx8/soc.h>
 
 /*
  * Raw TLBI operations.
@@ -129,8 +130,12 @@ static inline void flush_tlb_mm(struct mm_struct *mm)
 	unsigned long asid = __TLBI_VADDR(0, ASID(mm));
 
 	dsb(ishst);
-	__tlbi(aside1is, asid);
-	__tlbi_user(aside1is, asid);
+	if (TKT340553_SW_WORKAROUND && ASID(mm) >> 11) {
+		__tlbi(vmalle1is);
+	} else {
+		__tlbi(aside1is, asid);
+		__tlbi_user(aside1is, asid);
+	}
 	dsb(ish);
 }
 
@@ -140,8 +145,12 @@ static inline void flush_tlb_page(struct vm_area_struct *vma,
 	unsigned long addr = __TLBI_VADDR(uaddr, ASID(vma->vm_mm));
 
 	dsb(ishst);
-	__tlbi(vale1is, addr);
-	__tlbi_user(vale1is, addr);
+	if (TKT340553_SW_WORKAROUND && (uaddr >> 36 || (ASID(vma->vm_mm) >> 12))) {
+		__tlbi(vmalle1is);
+	} else {
+		__tlbi(vale1is, addr);
+		__tlbi_user(vale1is, addr);
+	}
 	dsb(ish);
 }
 
@@ -157,6 +166,7 @@ static inline void __flush_tlb_range(struct vm_area_struct *vma,
 {
 	unsigned long asid = ASID(vma->vm_mm);
 	unsigned long addr;
+	unsigned long mask = (1 << 20) - 1;
 
 	if ((end - start) > MAX_TLB_RANGE) {
 		flush_tlb_mm(vma->vm_mm);
@@ -165,10 +175,14 @@ static inline void __flush_tlb_range(struct vm_area_struct *vma,
 
 	start = __TLBI_VADDR(start, asid);
 	end = __TLBI_VADDR(end, asid);
+	mask <<= 24;
+
 
 	dsb(ishst);
 	for (addr = start; addr < end; addr += 1 << (PAGE_SHIFT - 12)) {
-		if (last_level) {
+		if (TKT340553_SW_WORKAROUND && (addr & mask || (ASID(vma->vm_mm) >> 12))) {
+			__tlbi(vmalle1is);
+		} else if (last_level) {
 			__tlbi(vale1is, addr);
 			__tlbi_user(vale1is, addr);
 		} else {
@@ -198,8 +212,12 @@ static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end
 	end = __TLBI_VADDR(end, 0);
 
 	dsb(ishst);
-	for (addr = start; addr < end; addr += 1 << (PAGE_SHIFT - 12))
-		__tlbi(vaae1is, addr);
+	for (addr = start; addr < end; addr += 1 << (PAGE_SHIFT - 12)) {
+		if (TKT340553_SW_WORKAROUND && addr >> 24)
+			__tlbi(vmalle1is);
+		else
+			__tlbi(vaae1is, addr);
+	}
 	dsb(ish);
 	isb();
 }
@@ -213,8 +231,13 @@ static inline void __flush_tlb_pgtable(struct mm_struct *mm,
 {
 	unsigned long addr = __TLBI_VADDR(uaddr, ASID(mm));
 
-	__tlbi(vae1is, addr);
-	__tlbi_user(vae1is, addr);
+	if (TKT340553_SW_WORKAROUND && (uaddr >> 36 || (ASID(mm) >> 12))) {
+		__tlbi(vmalle1is);
+	} else {
+		__tlbi(vae1is, addr);
+		__tlbi_user(vae1is, addr);
+	}
+
 	dsb(ish);
 }
 
diff --git a/drivers/soc/imx/soc-imx8.c b/drivers/soc/imx/soc-imx8.c
index 7373337..0e38e4a 100644
--- a/drivers/soc/imx/soc-imx8.c
+++ b/drivers/soc/imx/soc-imx8.c
@@ -134,9 +134,16 @@ static u32 imx_init_revision_from_scu(void)
 	return rev;
 }
 
+bool TKT340553_SW_WORKAROUND;
+
 static u32 imx8qm_soc_revision(void)
 {
-	return imx_init_revision_from_scu();
+	u32 rev = imx_init_revision_from_scu();
+
+	if (rev == IMX_CHIP_REVISION_1_0)
+		TKT340553_SW_WORKAROUND = true;
+
+	return rev;
 }
 
 static u32 imx8qxp_soc_revision(void)
-- 
1.7.9.5


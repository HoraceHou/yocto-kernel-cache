From 971147ce1279000c60479b546f2df395bd81109f Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Thu, 19 Jan 2017 03:59:00 +0800
Subject: [PATCH 1408/5242] MLK-13911-5 soc: scfw: imx8: add SCFW

commit  cab852f3402f30b1f61b63e6dfbc2ead45010353 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add i.MX8 SCFW API support.

Based on below commit:

(fcd0efb5f2550712bd7d27f1279e51f7f687f71d)
Fix MX8 MU driver to follow Linux coding conventions.
Remove unused functions.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Ranjani Vaidyanathan <Ranjani.Vaidyanathan@nxp.com>

Added to drivers/soc/imx instead of drivers/soc/imx8
Skipped imx8 imx_rpmsg code

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/Makefile                    |    2 +-
 drivers/soc/imx/Makefile                |    2 +
 drivers/soc/imx/mu/Makefile             |    1 +
 drivers/soc/imx/mu/mx8_mu.c             |   78 +++
 drivers/soc/imx/mu/mx8_mu.h             |   36 ++
 drivers/soc/imx/sc/Makefile             |    8 +
 drivers/soc/imx/sc/main/ipc.c           |  366 ++++++++++++++
 drivers/soc/imx/sc/main/rpc.h           |  124 +++++
 drivers/soc/imx/sc/svc/irq/rpc.h        |   53 ++
 drivers/soc/imx/sc/svc/irq/rpc_clnt.c   |   74 +++
 drivers/soc/imx/sc/svc/misc/rpc.h       |   70 +++
 drivers/soc/imx/sc/svc/misc/rpc_clnt.c  |  405 +++++++++++++++
 drivers/soc/imx/sc/svc/pad/rpc.h        |   67 +++
 drivers/soc/imx/sc/svc/pad/rpc_clnt.c   |  453 +++++++++++++++++
 drivers/soc/imx/sc/svc/pm/rpc.h         |   70 +++
 drivers/soc/imx/sc/svc/pm/rpc_clnt.c    |  415 ++++++++++++++++
 drivers/soc/imx/sc/svc/rm/rpc.h         |   82 +++
 drivers/soc/imx/sc/svc/rm/rpc_clnt.c    |  637 ++++++++++++++++++++++++
 drivers/soc/imx/sc/svc/timer/rpc.h      |   64 +++
 drivers/soc/imx/sc/svc/timer/rpc_clnt.c |  322 ++++++++++++
 include/linux/rpmsg.h                   |    2 +
 include/soc/imx8/fsl_bitaccess.h        |  129 +++++
 include/soc/imx8/imx8qm/lpcg.h          |  182 +++++++
 include/soc/imx8/imx8qxp/lpcg.h         |  182 +++++++
 include/soc/imx8/sc/ipc.h               |   71 +++
 include/soc/imx8/sc/scfw.h              |   34 ++
 include/soc/imx8/sc/sci.h               |   42 ++
 include/soc/imx8/sc/svc/irq/api.h       |  158 ++++++
 include/soc/imx8/sc/svc/misc/api.h      |  427 ++++++++++++++++
 include/soc/imx8/sc/svc/pad/api.h       |  565 +++++++++++++++++++++
 include/soc/imx8/sc/svc/pm/api.h        |  595 ++++++++++++++++++++++
 include/soc/imx8/sc/svc/rm/api.h        |  758 ++++++++++++++++++++++++++++
 include/soc/imx8/sc/svc/timer/api.h     |  282 +++++++++++
 include/soc/imx8/sc/types.h             |  824 +++++++++++++++++++++++++++++++
 34 files changed, 7579 insertions(+), 1 deletion(-)
 create mode 100644 drivers/soc/imx/mu/Makefile
 create mode 100644 drivers/soc/imx/mu/mx8_mu.c
 create mode 100644 drivers/soc/imx/mu/mx8_mu.h
 create mode 100644 drivers/soc/imx/sc/Makefile
 create mode 100644 drivers/soc/imx/sc/main/ipc.c
 create mode 100644 drivers/soc/imx/sc/main/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/irq/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/irq/rpc_clnt.c
 create mode 100644 drivers/soc/imx/sc/svc/misc/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/misc/rpc_clnt.c
 create mode 100644 drivers/soc/imx/sc/svc/pad/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/pad/rpc_clnt.c
 create mode 100644 drivers/soc/imx/sc/svc/pm/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/pm/rpc_clnt.c
 create mode 100644 drivers/soc/imx/sc/svc/rm/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/rm/rpc_clnt.c
 create mode 100644 drivers/soc/imx/sc/svc/timer/rpc.h
 create mode 100644 drivers/soc/imx/sc/svc/timer/rpc_clnt.c
 create mode 100644 include/soc/imx8/fsl_bitaccess.h
 create mode 100644 include/soc/imx8/imx8qm/lpcg.h
 create mode 100644 include/soc/imx8/imx8qxp/lpcg.h
 create mode 100644 include/soc/imx8/sc/ipc.h
 create mode 100644 include/soc/imx8/sc/scfw.h
 create mode 100644 include/soc/imx8/sc/sci.h
 create mode 100644 include/soc/imx8/sc/svc/irq/api.h
 create mode 100644 include/soc/imx8/sc/svc/misc/api.h
 create mode 100644 include/soc/imx8/sc/svc/pad/api.h
 create mode 100644 include/soc/imx8/sc/svc/pm/api.h
 create mode 100644 include/soc/imx8/sc/svc/rm/api.h
 create mode 100644 include/soc/imx8/sc/svc/timer/api.h
 create mode 100644 include/soc/imx8/sc/types.h

diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 113e884..280bec7 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -10,7 +10,7 @@ obj-$(CONFIG_ARCH_DOVE)		+= dove/
 obj-$(CONFIG_MACH_DOVE)		+= dove/
 obj-y				+= fsl/
 obj-$(CONFIG_ARCH_GEMINI)	+= gemini/
-obj-$(CONFIG_ARCH_MXC)		+= imx/
+obj-y				+= imx/
 obj-$(CONFIG_SOC_XWAY)		+= lantiq/
 obj-y				+= mediatek/
 obj-$(CONFIG_ARCH_MESON)	+= amlogic/
diff --git a/drivers/soc/imx/Makefile b/drivers/soc/imx/Makefile
index aab41a5c..49fdc3d 100644
--- a/drivers/soc/imx/Makefile
+++ b/drivers/soc/imx/Makefile
@@ -1,2 +1,4 @@
 obj-$(CONFIG_HAVE_IMX_GPC) += gpc.o
 obj-$(CONFIG_IMX7_PM_DOMAINS) += gpcv2.o
+obj-$(CONFIG_ARCH_FSL_IMX8QM) += mu/
+obj-$(CONFIG_ARCH_FSL_IMX8QM) += sc/
diff --git a/drivers/soc/imx/mu/Makefile b/drivers/soc/imx/mu/Makefile
new file mode 100644
index 0000000..922308c
--- /dev/null
+++ b/drivers/soc/imx/mu/Makefile
@@ -0,0 +1 @@
+obj-y += mx8_mu.o
diff --git a/drivers/soc/imx/mu/mx8_mu.c b/drivers/soc/imx/mu/mx8_mu.c
new file mode 100644
index 0000000..ed341d6
--- /dev/null
+++ b/drivers/soc/imx/mu/mx8_mu.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include "mx8_mu.h"
+
+
+/*!
+ * This function enables specific RX full interrupt.
+ */
+void MU_EnableRxFullInt(void __iomem *base, uint32_t index)
+{
+	uint32_t reg = readl_relaxed(base + MU_ACR_OFFSET1);
+
+	reg &= ~(MU_CR_GIRn_MASK1 | MU_CR_NMI_MASK1);
+	reg |= ~MU_CR_RIE0_MASK1 >> index;
+	writel_relaxed(reg, base + MU_ACR_OFFSET1);
+}
+
+/*!
+ * This function enables specific general purpose interrupt.
+ */
+void MU_EnableGeneralInt(void __iomem *base, uint32_t index)
+{
+	uint32_t reg = readl_relaxed(base + MU_ACR_OFFSET1);
+
+	reg &= ~(MU_CR_GIRn_MASK1 | MU_CR_NMI_MASK1);
+	reg |= MU_CR_GIE0_MASK1 >> index;
+	writel_relaxed(reg, base + MU_ACR_OFFSET1);
+}
+
+/*
+ * Wait and send message to the other core.
+ */
+void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg)
+{
+	uint32_t mask = MU_SR_TE0_MASK1 >> regIndex;
+
+	/* Wait TX register to be empty. */
+	while (!(readl_relaxed(base + MU_ASR_OFFSET1) & mask))
+		;
+	writel_relaxed(msg, base + MU_ATR0_OFFSET1  + (regIndex * 4));
+}
+
+
+/*
+ * Wait to receive message from the other core.
+ */
+void MU_ReceiveMsg(void __iomem *base, uint32_t regIndex, uint32_t *msg)
+{
+	uint32_t mask = MU_SR_RF0_MASK1 >> regIndex;
+
+	/* Wait RX register to be full. */
+	while (!(readl_relaxed(base + MU_ASR_OFFSET1) & mask))
+		;
+	*msg = readl_relaxed(base + MU_ARR0_OFFSET1 + (regIndex * 4));
+}
+
+
+
+void MU_Init(void __iomem *base)
+{
+	uint32_t reg;
+
+	reg = readl_relaxed(base + MU_ACR_OFFSET1);
+	/* Clear GIEn, RIEn, TIEn, GIRn and ABFn. */
+	reg &= ~(MU_CR_GIEn_MASK1 | MU_CR_RIEn_MASK1 | MU_CR_TIEn_MASK1
+			| MU_CR_GIRn_MASK1 | MU_CR_NMI_MASK1 | MU_CR_Fn_MASK1);
+	writel_relaxed(reg, base + MU_ACR_OFFSET1);
+}
+
+/**@}*/
+
diff --git a/drivers/soc/imx/mu/mx8_mu.h b/drivers/soc/imx/mu/mx8_mu.h
new file mode 100644
index 0000000..7d428ac
--- /dev/null
+++ b/drivers/soc/imx/mu/mx8_mu.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#define MU_ATR0_OFFSET1		0x0
+#define MU_ARR0_OFFSET1		0x10
+#define MU_ASR_OFFSET1		0x20
+#define MU_ACR_OFFSET1		0x24
+#define MU_TR_COUNT1		4
+#define MU_RR_COUNT1		4
+
+#define MU_CR_GIEn_MASK1	(0xF << 28)
+#define MU_CR_RIEn_MASK1	(0xF << 24)
+#define MU_CR_TIEn_MASK1	(0xF << 20)
+#define MU_CR_GIRn_MASK1	(0xF << 16)
+#define MU_CR_NMI_MASK1		(1 << 3)
+#define MU_CR_Fn_MASK1		0x7
+
+#define MU_SR_TE0_MASK1		(1 << 23)
+#define MU_SR_RF0_MASK1		(1 << 27)
+#define MU_CR_RIE0_MASK1	(1 << 27)
+#define MU_CR_GIE0_MASK1	(1 << 31)
+
+#define MU_TR_COUNT			4
+#define MU_RR_COUNT			4
+
+
+void MU_Init(void __iomem *base);
+void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg);
+void MU_ReceiveMsg(void __iomem *base, uint32_t regIndex, uint32_t *msg);
+void MU_EnableGeneralInt(void __iomem *base, uint32_t index);
+void MU_EnableRxFullInt(void __iomem *base, uint32_t index);
+
diff --git a/drivers/soc/imx/sc/Makefile b/drivers/soc/imx/sc/Makefile
new file mode 100644
index 0000000..851c687
--- /dev/null
+++ b/drivers/soc/imx/sc/Makefile
@@ -0,0 +1,8 @@
+obj-y += main/ipc.o
+obj-y += svc/misc/rpc_clnt.o
+obj-y += svc/pad/rpc_clnt.o
+obj-y += svc/pm/rpc_clnt.o
+obj-y += svc/rm/rpc_clnt.o
+obj-y += svc/timer/rpc_clnt.o
+obj-y += svc/irq/rpc_clnt.o
+
diff --git a/drivers/soc/imx/sc/main/ipc.c b/drivers/soc/imx/sc/main/ipc.c
new file mode 100644
index 0000000..0be0647
--- /dev/null
+++ b/drivers/soc/imx/sc/main/ipc.c
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/* Includes */
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_fdt.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <soc/imx8/sc/svc/irq/api.h>
+#include <soc/imx8/sc/ipc.h>
+#include <soc/imx8/sc/sci.h>
+
+#include "../../mu/mx8_mu.h"
+#include "rpc.h"
+
+/* Local Defines */
+#define MU_SIZE 0x10000
+
+/* Local Types */
+unsigned int scu_mu_id;
+static void __iomem *mu_base_virtaddr;
+static struct delayed_work scu_mu_work;
+static sc_ipc_t mu_ipcHandle;
+
+/* Local functions */
+
+/* Local variables */
+static uint32_t gIPCport;
+static bool scu_mu_init;
+
+DEFINE_MUTEX(scu_mu_mutex);
+
+static BLOCKING_NOTIFIER_HEAD(SCU_notifier_chain);
+
+EXPORT_SYMBOL(sc_pm_set_resource_power_mode);
+EXPORT_SYMBOL(sc_pm_get_resource_power_mode);
+EXPORT_SYMBOL(sc_pm_cpu_start);
+EXPORT_SYMBOL(sc_misc_set_control);
+EXPORT_SYMBOL(sc_pm_clock_enable);
+EXPORT_SYMBOL(sc_pm_set_clock_rate);
+/*--------------------------------------------------------------------------*/
+/* RPC command/response                                                     */
+/*--------------------------------------------------------------------------*/
+void sc_call_rpc(sc_ipc_t handle, sc_rpc_msg_t *msg, bool no_resp)
+{
+	if (in_interrupt()) {
+		pr_warn("Cannot make SC IPC calls from an interrupt context\n");
+		dump_stack();
+		return;
+	}
+	mutex_lock(&scu_mu_mutex);
+
+	sc_ipc_write(handle, msg);
+	if (!no_resp)
+		sc_ipc_read(handle, msg);
+
+	mutex_unlock(&scu_mu_mutex);
+}
+EXPORT_SYMBOL(sc_call_rpc);
+
+/*--------------------------------------------------------------------------*/
+/* Get MU base address for specified IPC channel                            */
+/*--------------------------------------------------------------------------*/
+static uint32_t *sc_ipc_get_mu_base(uint32_t id)
+{
+	uint32_t *base;
+
+	/* Check parameters */
+	if (id >= SC_NUM_IPC)
+		base = NULL;
+	else
+		base = (uint32_t *) (mu_base_virtaddr + (id * MU_SIZE));
+
+	return base;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get the MU ID used by Linux                                              */
+/*--------------------------------------------------------------------------*/
+int sc_ipc_getMuID(uint32_t *mu_id)
+{
+	if (scu_mu_init) {
+		*mu_id = scu_mu_id;
+		return SC_ERR_NONE;
+	}
+	return SC_ERR_UNAVAILABLE;
+}
+
+EXPORT_SYMBOL(sc_ipc_getMuID);
+
+/*--------------------------------------------------------------------------*/
+/* Open an IPC channel                                                      */
+/*--------------------------------------------------------------------------*/
+sc_err_t sc_ipc_requestInt(sc_ipc_t *handle, uint32_t id)
+{
+	return SC_ERR_NONE;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Open an IPC channel                                                      */
+/*--------------------------------------------------------------------------*/
+sc_err_t sc_ipc_open(sc_ipc_t *handle, uint32_t id)
+{
+	uint32_t *base;
+
+	mutex_lock(&scu_mu_mutex);
+
+	if (!scu_mu_init) {
+		mutex_unlock(&scu_mu_mutex);
+		return SC_ERR_UNAVAILABLE;
+	}
+	/* Get MU base associated with IPC channel */
+	base = sc_ipc_get_mu_base(id);
+
+	if (base == NULL) {
+		mutex_unlock(&scu_mu_mutex);
+		return SC_ERR_IPC;
+	}
+
+	*handle = (sc_ipc_t) task_pid_vnr(current);
+
+	mutex_unlock(&scu_mu_mutex);
+
+	return SC_ERR_NONE;
+}
+EXPORT_SYMBOL(sc_ipc_open);
+/*--------------------------------------------------------------------------*/
+/* Close an IPC channel                                                     */
+/*--------------------------------------------------------------------------*/
+void sc_ipc_close(sc_ipc_t handle)
+{
+	uint32_t *base;
+
+	mutex_lock(&scu_mu_mutex);
+
+	if (!scu_mu_init) {
+		mutex_unlock(&scu_mu_mutex);
+		return;
+	}
+
+	/* Get MU base associated with IPC channel */
+	base = sc_ipc_get_mu_base(gIPCport);
+
+	/* TBD ***** What needs to be done here? */
+	mutex_unlock(&scu_mu_mutex);
+}
+EXPORT_SYMBOL(sc_ipc_close);
+
+/*!
+ * This function reads a message from an IPC channel.
+ *
+ * @param[in]     ipc         id of channel read from
+ * @param[out]    data        pointer to message buffer to read
+ *
+ * This function will block if no message is available to be read.
+ */
+void sc_ipc_read(sc_ipc_t handle, void *data)
+{
+	uint32_t *base;
+	uint8_t count = 0;
+	sc_rpc_msg_t *msg = (sc_rpc_msg_t *) data;
+
+	/* Get MU base associated with IPC channel */
+	base = sc_ipc_get_mu_base(gIPCport);
+
+	if ((base == NULL) || (msg == NULL))
+		return;
+
+	/* Read first word */
+	MU_ReceiveMsg(base, 0, (uint32_t *) msg);
+	count++;
+
+	/* Check size */
+	if (msg->size > SC_RPC_MAX_MSG) {
+		*((uint32_t *) msg) = 0;
+		return;
+	}
+
+	/* Read remaining words */
+	while (count < msg->size) {
+		MU_ReceiveMsg(base, count % MU_RR_COUNT,
+				  &(msg->DATA.u32[count - 1]));
+		count++;
+	}
+}
+
+/*!
+ * This function writes a message to an IPC channel.
+ *
+ * @param[in]     ipc         id of channel to write to
+ * @param[in]     data        pointer to message buffer to write
+ *
+ * This function will block if the outgoing buffer is full.
+ */
+void sc_ipc_write(sc_ipc_t handle, void *data)
+{
+	uint32_t *base;
+	uint8_t count = 0;
+	sc_rpc_msg_t *msg = (sc_rpc_msg_t *) data;
+
+	/* Get MU base associated with IPC channel */
+	base = sc_ipc_get_mu_base(gIPCport);
+
+	if ((base == NULL) || (msg == NULL))
+		return;
+
+	/* Check size */
+	if (msg->size > SC_RPC_MAX_MSG)
+		return;
+
+	/* Write first word */
+	MU_SendMessage(base, 0, *((uint32_t *) msg));
+	count++;
+
+	/* Write remaining words */
+	while (count < msg->size) {
+		MU_SendMessage(base, count % MU_TR_COUNT, msg->DATA.u32[count - 1]);
+		count++;
+	}
+}
+
+int register_scu_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&SCU_notifier_chain, nb);
+}
+
+EXPORT_SYMBOL(register_scu_notifier);
+
+int unregister_scu_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&SCU_notifier_chain, nb);
+}
+
+EXPORT_SYMBOL(unregister_scu_notifier);
+
+static int SCU_notifier_call_chain(unsigned long val)
+{
+	return (blocking_notifier_call_chain(&SCU_notifier_chain, val, NULL) ==
+		NOTIFY_BAD) ? -EINVAL : 0;
+}
+
+static void scu_mu_work_handler(struct work_struct *work)
+{
+	uint32_t irq_status;
+	sc_err_t sciErr;
+
+	/* Figure out what caused the interrupt. */
+	sciErr = sc_irq_status(mu_ipcHandle, SC_R_MU_0A, SC_IRQ_GROUP_TEMP,
+			       &irq_status);
+
+	if (irq_status & (SC_IRQ_TEMP_PMIC0_HIGH | SC_IRQ_TEMP_PMIC1_HIGH))
+		SCU_notifier_call_chain(irq_status);
+
+	sciErr = sc_irq_status(mu_ipcHandle, SC_R_MU_0A, SC_IRQ_GROUP_RTC,
+			       &irq_status);
+
+	if (irq_status & SC_IRQ_RTC)
+		SCU_notifier_call_chain(irq_status);
+}
+
+static irqreturn_t imx8_scu_mu_isr(int irq, void *param)
+{
+	u32 irqs;
+
+	irqs = (readl_relaxed(mu_base_virtaddr + 0x20) & (0xf << 28));
+	if (irqs) {
+		/* Clear the General Interrupt */
+		writel_relaxed(irqs, mu_base_virtaddr + 0x20);
+		/* Setup a bottom-half to handle the irq work. */
+		schedule_delayed_work(&scu_mu_work, 0);
+	}
+	return IRQ_HANDLED;
+}
+
+/*Initialization of the MU code. */
+int __init imx8_mu_init(void)
+{
+	struct device_node *np;
+	u32 irq;
+	int err;
+	sc_err_t sciErr;
+
+	/*
+	 * Get the address of MU to be used for communication with the SCU
+	 */
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx8-mu");
+	if (!np) {
+		pr_info("Cannot find MU entry in device tree\n");
+		return 0;
+	}
+	mu_base_virtaddr = of_iomap(np, 0);
+	WARN_ON(!mu_base_virtaddr);
+
+	err = of_property_read_u32_index(np, "fsl,scu_ap_mu_id", 0, &scu_mu_id);
+	if (err)
+		pr_info("imx8_mu_init: Cannot get mu_id err = %d\n", err);
+
+	irq = of_irq_get(np, 0);
+
+	err = request_irq(irq, imx8_scu_mu_isr,
+			  IRQF_EARLY_RESUME, "imx8_mu_isr", NULL);
+
+	if (err) {
+		pr_info("imx8_mu_init :request_irq failed %d, err = %d\n", irq,
+			err);
+	}
+
+	if (!scu_mu_init) {
+		uint32_t i;
+
+		INIT_DELAYED_WORK(&scu_mu_work, scu_mu_work_handler);
+
+		/* Init MU */
+		MU_Init(mu_base_virtaddr);
+
+#if 1
+		/* Enable all RX interrupts */
+		for (i = 0; i < MU_RR_COUNT; i++)
+			MU_EnableGeneralInt(mu_base_virtaddr, i);
+#endif
+		gIPCport = scu_mu_id;
+		scu_mu_init = true;
+	}
+
+	sciErr = sc_ipc_open(&mu_ipcHandle, scu_mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_info("Cannot open MU channel to SCU\n");
+		return sciErr;
+	};
+
+	/* Request for the high temp interrupt. */
+	sciErr = sc_irq_enable(mu_ipcHandle, SC_R_MU_0A, SC_IRQ_GROUP_TEMP,
+			       SC_IRQ_TEMP_PMIC0_HIGH, true);
+
+	if (sciErr)
+		pr_info("Cannot request PMIC0_TEMP interrupt\n");
+
+	/* Request for the high temp interrupt. */
+	sciErr = sc_irq_enable(mu_ipcHandle, SC_R_MU_0A, SC_IRQ_GROUP_TEMP,
+			       SC_IRQ_TEMP_PMIC1_HIGH, true);
+
+	if (sciErr)
+		pr_info("Cannot request PMIC1_TEMP interrupt\n");
+
+	/* Request for the rtc alarm interrupt. */
+	sciErr = sc_irq_enable(mu_ipcHandle, SC_R_MU_0A, SC_IRQ_GROUP_RTC,
+			       SC_IRQ_RTC, true);
+
+	if (sciErr)
+		pr_info("Cannot request ALARM_RTC interrupt\n");
+
+	pr_info("*****Initialized MU\n");
+	return scu_mu_id;
+}
+
+early_initcall(imx8_mu_init);
diff --git a/drivers/soc/imx/sc/main/rpc.h b/drivers/soc/imx/sc/main/rpc.h
new file mode 100644
index 0000000..85cff23
--- /dev/null
+++ b/drivers/soc/imx/sc/main/rpc.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the RPC implementation.
+ */
+
+#ifndef _SC_RPC_H
+#define _SC_RPC_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/ipc.h>
+
+/* Defines */
+
+#define SC_RPC_VERSION          1
+
+#define SC_RPC_MAX_MSG          8
+
+#define RPC_VER(MSG)            ((MSG)->version)
+#define RPC_SIZE(MSG)           ((MSG)->size)
+#define RPC_SVC(MSG)            ((MSG)->svc)
+#define RPC_FUNC(MSG)           ((MSG)->func)
+#define RPC_R8(MSG)             ((MSG)->func)
+#define RPC_I32(MSG, IDX)       ((MSG)->DATA.i32[(IDX) / 4])
+#define RPC_I16(MSG, IDX)       ((MSG)->DATA.i16[(IDX) / 2])
+#define RPC_I8(MSG, IDX)        ((MSG)->DATA.i8[(IDX)])
+#define RPC_U32(MSG, IDX)       ((MSG)->DATA.u32[(IDX) / 4])
+#define RPC_U16(MSG, IDX)       ((MSG)->DATA.u16[(IDX) / 2])
+#define RPC_U8(MSG, IDX)        ((MSG)->DATA.u8[(IDX)])
+
+/* Types */
+
+typedef enum sc_rpc_svc_e {
+	SC_RPC_SVC_UNKNOWN = 0,
+	SC_RPC_SVC_RETURN = 1,
+	SC_RPC_SVC_PM = 2,
+	SC_RPC_SVC_RM = 3,
+	SC_RPC_SVC_TIMER = 5,
+	SC_RPC_SVC_PAD = 6,
+	SC_RPC_SVC_MISC = 7,
+	SC_RPC_SVC_IRQ = 8,
+	SC_RPC_SVC_ABORT = 9
+} sc_rpc_svc_t;
+
+typedef struct sc_rpc_msg_s {
+	uint8_t version;
+	uint8_t size;
+	uint8_t svc;
+	uint8_t func;
+	union {
+		int32_t i32[(SC_RPC_MAX_MSG - 1)];
+		int16_t i16[(SC_RPC_MAX_MSG - 1) * 2];
+		int8_t i8[(SC_RPC_MAX_MSG - 1) * 4];
+		uint32_t u32[(SC_RPC_MAX_MSG - 1)];
+		uint16_t u16[(SC_RPC_MAX_MSG - 1) * 2];
+		uint8_t u8[(SC_RPC_MAX_MSG - 1) * 4];
+	} DATA;
+} sc_rpc_msg_t;
+
+typedef enum sc_rpc_async_state_e {
+	SC_RPC_ASYNC_STATE_RD_START = 0,
+	SC_RPC_ASYNC_STATE_RD_ACTIVE = 1,
+	SC_RPC_ASYNC_STATE_RD_DONE = 2,
+	SC_RPC_ASYNC_STATE_WR_START = 3,
+	SC_RPC_ASYNC_STATE_WR_ACTIVE = 4,
+	SC_RPC_ASYNC_STATE_WR_DONE = 5,
+} sc_rpc_async_state_t;
+
+typedef struct sc_rpc_async_msg_s {
+	sc_rpc_async_state_t state;
+	uint8_t wordIdx;
+	sc_rpc_msg_t msg;
+	uint32_t timeStamp;
+} sc_rpc_async_msg_t;
+
+/* Functions */
+
+/*!
+ * This is an internal function to send an RPC message over an IPC
+ * channel. It is called by client-side SCFW API function shims.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in,out] msg         handle to a message
+ * @param[in]     no_resp     response flag
+ *
+ * If \a no_resp is false then this function waits for a response
+ * and returns the result in \a msg.
+ */
+void sc_call_rpc(sc_ipc_t ipc, sc_rpc_msg_t *msg, bool no_resp);
+
+/*!
+ * This is an internal function to dispath an RPC call that has
+ * arrived via IPC over an MU. It is called by server-side SCFW.
+ *
+ * @param[in]     mu          MU message arrived on
+ * @param[in,out] msg         handle to a message
+ *
+ * The function result is returned in \a msg.
+ */
+void sc_rpc_dispatch(sc_rsrc_t mu, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates an RPC message and forwards on to the
+ * normal RPC API.  It is used only by hypervisors.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in,out] msg         handle to a message
+ *
+ * This function decodes a message, calls macros to translate the
+ * resources, pads, addresses, partitions, memory regions, etc. and
+ * then forwards on to the hypervisors SCFW API.Return results are
+ * translated back abd placed back into the message to be returned
+ * to the original API.
+ */
+void sc_rpc_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_RPC_H */
diff --git a/drivers/soc/imx/sc/svc/irq/rpc.h b/drivers/soc/imx/sc/svc/irq/rpc.h
new file mode 100644
index 0000000..93ce7c3
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/irq/rpc.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the IRQ RPC implementation.
+ *
+ * @addtogroup IRQ_SVC
+ * @{
+ */
+
+#ifndef _SC_IRQ_RPC_H
+#define _SC_IRQ_RPC_H
+
+/* Includes */
+
+/* Defines */
+
+/* Types */
+
+/*!
+ * This type is used to indicate RPC IRQ function calls.
+ */
+typedef enum irq_func_e {
+	IRQ_FUNC_UNKNOWN = 0,	/* Unknown function */
+	IRQ_FUNC_ENABLE = 1,	/* Index for irq_enable() RPC call */
+	IRQ_FUNC_STATUS = 2,	/* Index for irq_status() RPC call */
+} irq_func_t;
+
+/* Functions */
+
+/*!
+ * This function dispatches an incoming IRQ RPC request.
+ *
+ * @param[in]     caller_pt   caller partition
+ * @param[in]     msg         pointer to RPC message
+ */
+void irq_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates and dispatches an IRQ RPC request.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     msg         pointer to RPC message
+ */
+void irq_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_IRQ_RPC_H */
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/irq/rpc_clnt.c b/drivers/soc/imx/sc/svc/irq/rpc_clnt.c
new file mode 100644
index 0000000..779be38
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/irq/rpc_clnt.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * File containing client-side RPC functions for the IRQ service. These
+ * functions are ported to clients that communicate to the SC.
+ *
+ * @addtogroup IRQ_SVC
+ * @{
+ */
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include <soc/imx8/sc/svc/irq/api.h>
+#include "../../main/rpc.h"
+#include "rpc.h"
+
+/* Local Defines */
+
+/* Local Types */
+
+/* Local Functions */
+
+sc_err_t sc_irq_enable(sc_ipc_t ipc, sc_rsrc_t resource,
+		       sc_irq_group_t group, uint32_t mask, bool enable)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_IRQ;
+	RPC_FUNC(&msg) = (uint8_t)IRQ_FUNC_ENABLE;
+	RPC_U32(&msg, 0) = mask;
+	RPC_U16(&msg, 4) = resource;
+	RPC_U8(&msg, 6) = group;
+	RPC_U8(&msg, 7) = (uint8_t)enable;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_irq_status(sc_ipc_t ipc, sc_rsrc_t resource,
+		       sc_irq_group_t group, uint32_t *status)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_IRQ;
+	RPC_FUNC(&msg) = (uint8_t)IRQ_FUNC_STATUS;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = group;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (status != NULL) {
+		*status = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/misc/rpc.h b/drivers/soc/imx/sc/svc/misc/rpc.h
new file mode 100644
index 0000000..087b6b9
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/misc/rpc.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the MISC RPC implementation.
+ *
+ * @addtogroup MISC_SVC
+ * @{
+ */
+
+#ifndef _SC_MISC_RPC_H
+#define _SC_MISC_RPC_H
+
+/* Includes */
+
+/* Defines */
+
+/* Types */
+
+/*!
+ * This type is used to indicate RPC MISC function calls.
+ */
+typedef enum misc_func_e {
+	MISC_FUNC_UNKNOWN = 0,	/* Unknown function */
+	MISC_FUNC_SET_CONTROL = 1,	/* Index for misc_set_control() RPC call */
+	MISC_FUNC_GET_CONTROL = 2,	/* Index for misc_get_control() RPC call */
+	MISC_FUNC_SET_MAX_DMA_GROUP = 4,	/* Index for misc_set_max_dma_group() RPC call */
+	MISC_FUNC_SET_DMA_GROUP = 5,	/* Index for misc_set_dma_group() RPC call */
+	MISC_FUNC_SECO_IMAGE_LOAD = 8,	/* Index for misc_seco_image_load() RPC call */
+	MISC_FUNC_SECO_AUTHENTICATE = 9,	/* Index for misc_seco_authenticate() RPC call */
+	MISC_FUNC_DEBUG_OUT = 10,	/* Index for misc_debug_out() RPC call */
+	MISC_FUNC_WAVEFORM_CAPTURE = 6,	/* Index for misc_waveform_capture() RPC call */
+	MISC_FUNC_BUILD_INFO = 15,	/* Index for misc_build_info() RPC call */
+	MISC_FUNC_UNIQUE_ID = 19,	/* Index for misc_unique_id() RPC call */
+	MISC_FUNC_SET_ARI = 3,	/* Index for misc_set_ari() RPC call */
+	MISC_FUNC_BOOT_STATUS = 7,	/* Index for misc_boot_status() RPC call */
+	MISC_FUNC_BOOT_DONE = 14,	/* Index for misc_boot_done() RPC call */
+	MISC_FUNC_OTP_FUSE_READ = 11,	/* Index for misc_otp_fuse_read() RPC call */
+	MISC_FUNC_OTP_FUSE_WRITE = 17,	/* Index for misc_otp_fuse_write() RPC call */
+	MISC_FUNC_SET_TEMP = 12,	/* Index for misc_set_temp() RPC call */
+	MISC_FUNC_GET_TEMP = 13,	/* Index for misc_get_temp() RPC call */
+	MISC_FUNC_GET_BOOT_DEV = 16,	/* Index for misc_get_boot_dev() RPC call */
+	MISC_FUNC_GET_BUTTON_STATUS = 18,	/* Index for misc_get_button_status() RPC call */
+} misc_func_t;
+
+/* Functions */
+
+/*!
+ * This function dispatches an incoming MISC RPC request.
+ *
+ * @param[in]     caller_pt   caller partition
+ * @param[in]     msg         pointer to RPC message
+ */
+void misc_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates and dispatches an MISC RPC request.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     msg         pointer to RPC message
+ */
+void misc_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_MISC_RPC_H */
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/misc/rpc_clnt.c b/drivers/soc/imx/sc/svc/misc/rpc_clnt.c
new file mode 100644
index 0000000..e1f588c
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/misc/rpc_clnt.c
@@ -0,0 +1,405 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * File containing client-side RPC functions for the MISC service. These
+ * functions are ported to clients that communicate to the SC.
+ *
+ * @addtogroup MISC_SVC
+ * @{
+ */
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include <soc/imx8/sc/svc/misc/api.h>
+#include "../../main/rpc.h"
+#include "rpc.h"
+
+/* Local Defines */
+
+/* Local Types */
+
+/* Local Functions */
+
+sc_err_t sc_misc_set_control(sc_ipc_t ipc, sc_rsrc_t resource,
+			     sc_ctrl_t ctrl, uint32_t val)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_CONTROL;
+	RPC_U32(&msg, 0) = ctrl;
+	RPC_U32(&msg, 4) = val;
+	RPC_U16(&msg, 8) = resource;
+	RPC_SIZE(&msg) = 4;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_get_control(sc_ipc_t ipc, sc_rsrc_t resource,
+			     sc_ctrl_t ctrl, uint32_t *val)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_CONTROL;
+	RPC_U32(&msg, 0) = ctrl;
+	RPC_U16(&msg, 4) = resource;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (val != NULL) {
+		*val = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_set_max_dma_group(sc_ipc_t ipc, sc_rm_pt_t pt,
+				   sc_misc_dma_group_t max)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_MAX_DMA_GROUP;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = max;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_set_dma_group(sc_ipc_t ipc, sc_rsrc_t resource,
+			       sc_misc_dma_group_t group)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_DMA_GROUP;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = group;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_image_load(sc_ipc_t ipc, uint32_t addr_src,
+				 uint32_t addr_dst, uint32_t len, bool fw)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SECO_IMAGE_LOAD;
+	RPC_U32(&msg, 0) = addr_src;
+	RPC_U32(&msg, 4) = addr_dst;
+	RPC_U32(&msg, 8) = len;
+	RPC_U8(&msg, 12) = (uint8_t)fw;
+	RPC_SIZE(&msg) = 5;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_authenticate(sc_ipc_t ipc,
+				   sc_misc_seco_auth_cmd_t cmd,
+				   uint32_t addr_meta)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SECO_AUTHENTICATE;
+	RPC_U32(&msg, 0) = addr_meta;
+	RPC_U8(&msg, 4) = cmd;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+void sc_misc_debug_out(sc_ipc_t ipc, uint8_t ch)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_DEBUG_OUT;
+	RPC_U8(&msg, 0) = ch;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	return;
+}
+
+sc_err_t sc_misc_waveform_capture(sc_ipc_t ipc, bool enable)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_WAVEFORM_CAPTURE;
+	RPC_U8(&msg, 0) = (uint8_t)enable;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+void sc_misc_build_info(sc_ipc_t ipc, uint32_t *build, uint32_t *commit)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_BUILD_INFO;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (build != NULL) {
+		*build = RPC_U32(&msg, 0);
+	}
+
+	if (commit != NULL) {
+		*commit = RPC_U32(&msg, 4);
+	}
+
+	return;
+}
+
+void sc_misc_unique_id(sc_ipc_t ipc, uint32_t *id_l, uint32_t *id_h)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_UNIQUE_ID;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (id_l != NULL) {
+		*id_l = RPC_U32(&msg, 0);
+	}
+
+	if (id_h != NULL) {
+		*id_h = RPC_U32(&msg, 4);
+	}
+
+	return;
+}
+
+sc_err_t sc_misc_set_ari(sc_ipc_t ipc, sc_rsrc_t resource,
+			 sc_rsrc_t resource_mst, uint16_t ari, bool enable)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_ARI;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U16(&msg, 2) = resource_mst;
+	RPC_U16(&msg, 4) = ari;
+	RPC_U8(&msg, 6) = (uint8_t)enable;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+void sc_misc_boot_status(sc_ipc_t ipc, sc_misc_boot_status_t status)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_BOOT_STATUS;
+	RPC_U8(&msg, 0) = status;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, true);
+
+	return;
+}
+
+sc_err_t sc_misc_boot_done(sc_ipc_t ipc, sc_rsrc_t cpu)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_BOOT_DONE;
+	RPC_U16(&msg, 0) = cpu;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_otp_fuse_read(sc_ipc_t ipc, uint32_t word, uint32_t *val)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_OTP_FUSE_READ;
+	RPC_U32(&msg, 0) = word;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (val != NULL) {
+		*val = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_otp_fuse_write(sc_ipc_t ipc, uint32_t word, uint32_t val)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_OTP_FUSE_WRITE;
+	RPC_U32(&msg, 0) = word;
+	RPC_U32(&msg, 4) = val;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_set_temp(sc_ipc_t ipc, sc_rsrc_t resource,
+			  sc_misc_temp_t temp, int16_t celsius, int8_t tenths)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_TEMP;
+	RPC_U16(&msg, 0) = resource;
+	RPC_I16(&msg, 2) = celsius;
+	RPC_U8(&msg, 4) = temp;
+	RPC_I8(&msg, 5) = tenths;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_get_temp(sc_ipc_t ipc, sc_rsrc_t resource,
+			  sc_misc_temp_t temp, int16_t * celsius,
+			  int8_t * tenths)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_TEMP;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = temp;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (celsius != NULL) {
+		*celsius = RPC_I16(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	if (tenths != NULL) {
+		*tenths = RPC_I8(&msg, 2);
+	}
+
+	return (sc_err_t)result;
+}
+
+void sc_misc_get_boot_dev(sc_ipc_t ipc, sc_rsrc_t *dev)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_BOOT_DEV;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (dev != NULL) {
+		*dev = RPC_U16(&msg, 0);
+	}
+
+	return;
+}
+
+void sc_misc_get_button_status(sc_ipc_t ipc, bool *status)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
+	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_BUTTON_STATUS;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (status != NULL) {
+		*status = RPC_U8(&msg, 0);
+	}
+
+	return;
+}
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/pad/rpc.h b/drivers/soc/imx/sc/svc/pad/rpc.h
new file mode 100644
index 0000000..ee8fe3b
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/pad/rpc.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the PAD RPC implementation.
+ *
+ * @addtogroup PAD_SVC
+ * @{
+ */
+
+#ifndef _SC_PAD_RPC_H
+#define _SC_PAD_RPC_H
+
+/* Includes */
+
+/* Defines */
+
+/* Types */
+
+/*!
+ * This type is used to indicate RPC PAD function calls.
+ */
+typedef enum pad_func_e {
+	PAD_FUNC_UNKNOWN = 0,	/* Unknown function */
+	PAD_FUNC_SET_MUX = 1,	/* Index for pad_set_mux() RPC call */
+	PAD_FUNC_GET_MUX = 6,	/* Index for pad_get_mux() RPC call */
+	PAD_FUNC_SET_GP = 2,	/* Index for pad_set_gp() RPC call */
+	PAD_FUNC_GET_GP = 7,	/* Index for pad_get_gp() RPC call */
+	PAD_FUNC_SET_WAKEUP = 4,	/* Index for pad_set_wakeup() RPC call */
+	PAD_FUNC_GET_WAKEUP = 9,	/* Index for pad_get_wakeup() RPC call */
+	PAD_FUNC_SET_ALL = 5,	/* Index for pad_set_all() RPC call */
+	PAD_FUNC_GET_ALL = 10,	/* Index for pad_get_all() RPC call */
+	PAD_FUNC_SET = 15,	/* Index for pad_set() RPC call */
+	PAD_FUNC_GET = 16,	/* Index for pad_get() RPC call */
+	PAD_FUNC_SET_GP_28FDSOI = 11,	/* Index for pad_set_gp_28fdsoi() RPC call */
+	PAD_FUNC_GET_GP_28FDSOI = 12,	/* Index for pad_get_gp_28fdsoi() RPC call */
+	PAD_FUNC_SET_GP_28FDSOI_HSIC = 3,	/* Index for pad_set_gp_28fdsoi_hsic() RPC call */
+	PAD_FUNC_GET_GP_28FDSOI_HSIC = 8,	/* Index for pad_get_gp_28fdsoi_hsic() RPC call */
+	PAD_FUNC_SET_GP_28FDSOI_COMP = 13,	/* Index for pad_set_gp_28fdsoi_comp() RPC call */
+	PAD_FUNC_GET_GP_28FDSOI_COMP = 14,	/* Index for pad_get_gp_28fdsoi_comp() RPC call */
+} pad_func_t;
+
+/* Functions */
+
+/*!
+ * This function dispatches an incoming PAD RPC request.
+ *
+ * @param[in]     caller_pt   caller partition
+ * @param[in]     msg         pointer to RPC message
+ */
+void pad_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates and dispatches an PAD RPC request.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     msg         pointer to RPC message
+ */
+void pad_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_PAD_RPC_H */
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/pad/rpc_clnt.c b/drivers/soc/imx/sc/svc/pad/rpc_clnt.c
new file mode 100644
index 0000000..90fb390
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/pad/rpc_clnt.c
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * File containing client-side RPC functions for the PAD service. These
+ * functions are ported to clients that communicate to the SC.
+ *
+ * @addtogroup PAD_SVC
+ * @{
+ */
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include <soc/imx8/sc/svc/pad/api.h>
+#include "../../main/rpc.h"
+#include "rpc.h"
+
+/* Local Defines */
+
+/* Local Types */
+
+/* Local Functions */
+
+sc_err_t sc_pad_set_mux(sc_ipc_t ipc, sc_pad_t pad,
+			uint8_t mux, sc_pad_config_t config, sc_pad_iso_t iso)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_MUX;
+	RPC_U16(&msg, 0) = pad;
+	RPC_U8(&msg, 2) = mux;
+	RPC_U8(&msg, 3) = config;
+	RPC_U8(&msg, 4) = iso;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_mux(sc_ipc_t ipc, sc_pad_t pad,
+			uint8_t *mux, sc_pad_config_t *config,
+			sc_pad_iso_t *iso)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_MUX;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (mux != NULL) {
+		*mux = RPC_U8(&msg, 0);
+	}
+
+	if (config != NULL) {
+		*config = RPC_U8(&msg, 1);
+	}
+
+	if (iso != NULL) {
+		*iso = RPC_U8(&msg, 2);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set_gp(sc_ipc_t ipc, sc_pad_t pad, uint32_t ctrl)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP;
+	RPC_U32(&msg, 0) = ctrl;
+	RPC_U16(&msg, 4) = pad;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_gp(sc_ipc_t ipc, sc_pad_t pad, uint32_t *ctrl)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (ctrl != NULL) {
+		*ctrl = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set_wakeup(sc_ipc_t ipc, sc_pad_t pad, sc_pad_wakeup_t wakeup)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_WAKEUP;
+	RPC_U16(&msg, 0) = pad;
+	RPC_U8(&msg, 2) = wakeup;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_wakeup(sc_ipc_t ipc, sc_pad_t pad, sc_pad_wakeup_t *wakeup)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_WAKEUP;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (wakeup != NULL) {
+		*wakeup = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t mux,
+			sc_pad_config_t config, sc_pad_iso_t iso, uint32_t ctrl,
+			sc_pad_wakeup_t wakeup)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_ALL;
+	RPC_U32(&msg, 0) = ctrl;
+	RPC_U16(&msg, 4) = pad;
+	RPC_U8(&msg, 6) = mux;
+	RPC_U8(&msg, 7) = config;
+	RPC_U8(&msg, 8) = iso;
+	RPC_U8(&msg, 9) = wakeup;
+	RPC_SIZE(&msg) = 4;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t *mux,
+			sc_pad_config_t *config, sc_pad_iso_t *iso,
+			uint32_t *ctrl, sc_pad_wakeup_t *wakeup)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_ALL;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (ctrl != NULL) {
+		*ctrl = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	if (mux != NULL) {
+		*mux = RPC_U8(&msg, 4);
+	}
+
+	if (config != NULL) {
+		*config = RPC_U8(&msg, 5);
+	}
+
+	if (iso != NULL) {
+		*iso = RPC_U8(&msg, 6);
+	}
+
+	if (wakeup != NULL) {
+		*wakeup = RPC_U8(&msg, 7);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set(sc_ipc_t ipc, sc_pad_t pad, uint32_t val)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET;
+	RPC_U32(&msg, 0) = val;
+	RPC_U16(&msg, 4) = pad;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get(sc_ipc_t ipc, sc_pad_t pad, uint32_t *val)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (val != NULL) {
+		*val = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
+			       sc_pad_28fdsoi_dse_t dse, sc_pad_28fdsoi_ps_t ps)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP_28FDSOI;
+	RPC_U16(&msg, 0) = pad;
+	RPC_U8(&msg, 2) = dse;
+	RPC_U8(&msg, 3) = ps;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
+			       sc_pad_28fdsoi_dse_t *dse,
+			       sc_pad_28fdsoi_ps_t *ps)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP_28FDSOI;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (dse != NULL) {
+		*dse = RPC_U8(&msg, 0);
+	}
+
+	if (ps != NULL) {
+		*ps = RPC_U8(&msg, 1);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
+				    sc_pad_28fdsoi_dse_t dse, bool hys,
+				    sc_pad_28fdsoi_pus_t pus, bool pke,
+				    bool pue)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP_28FDSOI_HSIC;
+	RPC_U16(&msg, 0) = pad;
+	RPC_U8(&msg, 2) = dse;
+	RPC_U8(&msg, 3) = pus;
+	RPC_U8(&msg, 4) = (uint8_t)hys;
+	RPC_U8(&msg, 5) = (uint8_t)pke;
+	RPC_U8(&msg, 6) = (uint8_t)pue;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
+				    sc_pad_28fdsoi_dse_t *dse, bool *hys,
+				    sc_pad_28fdsoi_pus_t *pus, bool *pke,
+				    bool *pue)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP_28FDSOI_HSIC;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (dse != NULL) {
+		*dse = RPC_U8(&msg, 0);
+	}
+
+	if (pus != NULL) {
+		*pus = RPC_U8(&msg, 1);
+	}
+
+	if (hys != NULL) {
+		*hys = RPC_U8(&msg, 2);
+	}
+
+	if (pke != NULL) {
+		*pke = RPC_U8(&msg, 3);
+	}
+
+	if (pue != NULL) {
+		*pue = RPC_U8(&msg, 4);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_set_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
+				    uint8_t compen, bool fastfrz,
+				    uint8_t rasrcp, uint8_t rasrcn,
+				    bool nasrc_sel, bool psw_ovr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP_28FDSOI_COMP;
+	RPC_U16(&msg, 0) = pad;
+	RPC_U8(&msg, 2) = compen;
+	RPC_U8(&msg, 3) = rasrcp;
+	RPC_U8(&msg, 4) = rasrcn;
+	RPC_U8(&msg, 5) = (uint8_t)fastfrz;
+	RPC_U8(&msg, 6) = (uint8_t)nasrc_sel;
+	RPC_U8(&msg, 7) = (uint8_t)psw_ovr;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pad_get_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
+				    uint8_t *compen, bool *fastfrz,
+				    uint8_t *rasrcp, uint8_t *rasrcn,
+				    bool *nasrc_sel, bool *compok,
+				    uint8_t *nasrc, bool *psw_ovr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
+	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP_28FDSOI_COMP;
+	RPC_U16(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (compen != NULL) {
+		*compen = RPC_U8(&msg, 0);
+	}
+
+	if (rasrcp != NULL) {
+		*rasrcp = RPC_U8(&msg, 1);
+	}
+
+	if (rasrcn != NULL) {
+		*rasrcn = RPC_U8(&msg, 2);
+	}
+
+	if (nasrc != NULL) {
+		*nasrc = RPC_U8(&msg, 3);
+	}
+
+	if (fastfrz != NULL) {
+		*fastfrz = RPC_U8(&msg, 4);
+	}
+
+	if (nasrc_sel != NULL) {
+		*nasrc_sel = RPC_U8(&msg, 5);
+	}
+
+	if (compok != NULL) {
+		*compok = RPC_U8(&msg, 6);
+	}
+
+	if (psw_ovr != NULL) {
+		*psw_ovr = RPC_U8(&msg, 7);
+	}
+
+	return (sc_err_t)result;
+}
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/pm/rpc.h b/drivers/soc/imx/sc/svc/pm/rpc.h
new file mode 100644
index 0000000..e83db74
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/pm/rpc.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the PM RPC implementation.
+ *
+ * @addtogroup PM_SVC
+ * @{
+ */
+
+#ifndef _SC_PM_RPC_H
+#define _SC_PM_RPC_H
+
+/* Includes */
+
+/* Defines */
+
+/* Types */
+
+/*!
+ * This type is used to indicate RPC PM function calls.
+ */
+typedef enum pm_func_e {
+	PM_FUNC_UNKNOWN = 0,	/* Unknown function */
+	PM_FUNC_SET_SYS_POWER_MODE = 19,	/* Index for pm_set_sys_power_mode() RPC call */
+	PM_FUNC_SET_PARTITION_POWER_MODE = 1,	/* Index for pm_set_partition_power_mode() RPC call */
+	PM_FUNC_GET_SYS_POWER_MODE = 2,	/* Index for pm_get_sys_power_mode() RPC call */
+	PM_FUNC_SET_RESOURCE_POWER_MODE = 3,	/* Index for pm_set_resource_power_mode() RPC call */
+	PM_FUNC_GET_RESOURCE_POWER_MODE = 4,	/* Index for pm_get_resource_power_mode() RPC call */
+	PM_FUNC_REQ_LOW_POWER_MODE = 16,	/* Index for pm_req_low_power_mode() RPC call */
+	PM_FUNC_SET_CPU_RESUME_ADDR = 17,	/* Index for pm_set_cpu_resume_addr() RPC call */
+	PM_FUNC_REQ_SYS_IF_POWER_MODE = 18,	/* Index for pm_req_sys_if_power_mode() RPC call */
+	PM_FUNC_SET_CLOCK_RATE = 5,	/* Index for pm_set_clock_rate() RPC call */
+	PM_FUNC_GET_CLOCK_RATE = 6,	/* Index for pm_get_clock_rate() RPC call */
+	PM_FUNC_CLOCK_ENABLE = 7,	/* Index for pm_clock_enable() RPC call */
+	PM_FUNC_SET_CLOCK_PARENT = 14,	/* Index for pm_set_clock_parent() RPC call */
+	PM_FUNC_GET_CLOCK_PARENT = 15,	/* Index for pm_get_clock_parent() RPC call */
+	PM_FUNC_RESET = 13,	/* Index for pm_reset() RPC call */
+	PM_FUNC_RESET_REASON = 10,	/* Index for pm_reset_reason() RPC call */
+	PM_FUNC_BOOT = 8,	/* Index for pm_boot() RPC call */
+	PM_FUNC_REBOOT = 9,	/* Index for pm_reboot() RPC call */
+	PM_FUNC_REBOOT_PARTITION = 12,	/* Index for pm_reboot_partition() RPC call */
+	PM_FUNC_CPU_START = 11,	/* Index for pm_cpu_start() RPC call */
+} pm_func_t;
+
+/* Functions */
+
+/*!
+ * This function dispatches an incoming PM RPC request.
+ *
+ * @param[in]     caller_pt   caller partition
+ * @param[in]     msg         pointer to RPC message
+ */
+void pm_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates and dispatches an PM RPC request.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     msg         pointer to RPC message
+ */
+void pm_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_PM_RPC_H */
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/pm/rpc_clnt.c b/drivers/soc/imx/sc/svc/pm/rpc_clnt.c
new file mode 100644
index 0000000..b4b651e
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/pm/rpc_clnt.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * File containing client-side RPC functions for the PM service. These
+ * functions are ported to clients that communicate to the SC.
+ *
+ * @addtogroup PM_SVC
+ * @{
+ */
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include <soc/imx8/sc/svc/pm/api.h>
+#include "../../main/rpc.h"
+#include "rpc.h"
+
+/* Local Defines */
+
+/* Local Types */
+
+/* Local Functions */
+
+sc_err_t sc_pm_set_sys_power_mode(sc_ipc_t ipc, sc_pm_power_mode_t mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_SYS_POWER_MODE;
+	RPC_U8(&msg, 0) = mode;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_partition_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
+					sc_pm_power_mode_t mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_PARTITION_POWER_MODE;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = mode;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_get_sys_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
+				  sc_pm_power_mode_t *mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_SYS_POWER_MODE;
+	RPC_U8(&msg, 0) = pt;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (mode != NULL) {
+		*mode = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				       sc_pm_power_mode_t mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_RESOURCE_POWER_MODE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = mode;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_get_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				       sc_pm_power_mode_t *mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_RESOURCE_POWER_MODE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (mode != NULL) {
+		*mode = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_req_low_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				  sc_pm_power_mode_t mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REQ_LOW_POWER_MODE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = mode;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_cpu_resume_addr(sc_ipc_t ipc, sc_rsrc_t resource,
+				   sc_faddr_t address)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_CPU_RESUME_ADDR;
+	RPC_U32(&msg, 0) = (uint32_t)(address >> 32u);
+	RPC_U32(&msg, 4) = (uint32_t)address;
+	RPC_U16(&msg, 8) = resource;
+	RPC_SIZE(&msg) = 4;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_req_sys_if_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				     sc_pm_sys_if_t sys_if,
+				     sc_pm_power_mode_t hpm,
+				     sc_pm_power_mode_t lpm)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REQ_SYS_IF_POWER_MODE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = sys_if;
+	RPC_U8(&msg, 3) = hpm;
+	RPC_U8(&msg, 4) = lpm;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_pm_clk_t clk, sc_pm_clock_rate_t *rate)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_CLOCK_RATE;
+	RPC_U32(&msg, 0) = *rate;
+	RPC_U16(&msg, 4) = resource;
+	RPC_U8(&msg, 6) = clk;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	*rate = RPC_U32(&msg, 0);
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_get_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_pm_clk_t clk, sc_pm_clock_rate_t *rate)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_CLOCK_RATE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = clk;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (rate != NULL) {
+		*rate = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_clock_enable(sc_ipc_t ipc, sc_rsrc_t resource,
+			    sc_pm_clk_t clk, bool enable, bool autog)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_CLOCK_ENABLE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = clk;
+	RPC_U8(&msg, 3) = (uint8_t)enable;
+	RPC_U8(&msg, 4) = (uint8_t)autog;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
+				sc_pm_clk_t clk, sc_pm_clk_parent_t parent)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_CLOCK_PARENT;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = clk;
+	RPC_U8(&msg, 3) = parent;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
+				sc_pm_clk_t clk, sc_pm_clk_parent_t * parent)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_CLOCK_PARENT;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = clk;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (parent != NULL) {
+		*parent = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_reset(sc_ipc_t ipc, sc_pm_reset_type_t type)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_RESET;
+	RPC_U8(&msg, 0) = type;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_reset_reason(sc_ipc_t ipc, sc_pm_reset_reason_t *reason)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_RESET_REASON;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (reason != NULL) {
+		*reason = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_boot(sc_ipc_t ipc, sc_rm_pt_t pt,
+		    sc_rsrc_t resource_cpu, sc_faddr_t boot_addr,
+		    sc_rsrc_t resource_mu, sc_rsrc_t resource_dev)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_BOOT;
+	RPC_U32(&msg, 0) = (uint32_t)(boot_addr >> 32u);
+	RPC_U32(&msg, 4) = (uint32_t)boot_addr;
+	RPC_U16(&msg, 8) = resource_cpu;
+	RPC_U16(&msg, 10) = resource_mu;
+	RPC_U16(&msg, 12) = resource_dev;
+	RPC_U8(&msg, 14) = pt;
+	RPC_SIZE(&msg) = 5;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+void sc_pm_reboot(sc_ipc_t ipc, sc_pm_reset_type_t type)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REBOOT;
+	RPC_U8(&msg, 0) = type;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, true);
+
+	return;
+}
+
+sc_err_t sc_pm_reboot_partition(sc_ipc_t ipc, sc_rm_pt_t pt,
+				sc_pm_reset_type_t type)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REBOOT_PARTITION;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = type;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_cpu_start(sc_ipc_t ipc, sc_rsrc_t resource, bool enable,
+			 sc_faddr_t address)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
+	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_CPU_START;
+	RPC_U32(&msg, 0) = (uint32_t)(address >> 32u);
+	RPC_U32(&msg, 4) = (uint32_t)address;
+	RPC_U16(&msg, 8) = resource;
+	RPC_U8(&msg, 10) = (uint8_t)enable;
+	RPC_SIZE(&msg) = 4;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/rm/rpc.h b/drivers/soc/imx/sc/svc/rm/rpc.h
new file mode 100644
index 0000000..457b018
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/rm/rpc.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the RM RPC implementation.
+ *
+ * @addtogroup RM_SVC
+ * @{
+ */
+
+#ifndef _SC_RM_RPC_H
+#define _SC_RM_RPC_H
+
+/* Includes */
+
+/* Defines */
+
+/* Types */
+
+/*!
+ * This type is used to indicate RPC RM function calls.
+ */
+typedef enum rm_func_e {
+	RM_FUNC_UNKNOWN = 0,	/* Unknown function */
+	RM_FUNC_PARTITION_ALLOC = 1,	/* Index for rm_partition_alloc() RPC call */
+	RM_FUNC_SET_CONFIDENTIAL = 31,	/* Index for rm_set_confidential() RPC call */
+	RM_FUNC_PARTITION_FREE = 2,	/* Index for rm_partition_free() RPC call */
+	RM_FUNC_GET_DID = 26,	/* Index for rm_get_did() RPC call */
+	RM_FUNC_PARTITION_STATIC = 3,	/* Index for rm_partition_static() RPC call */
+	RM_FUNC_PARTITION_LOCK = 4,	/* Index for rm_partition_lock() RPC call */
+	RM_FUNC_GET_PARTITION = 5,	/* Index for rm_get_partition() RPC call */
+	RM_FUNC_SET_PARENT = 6,	/* Index for rm_set_parent() RPC call */
+	RM_FUNC_MOVE_ALL = 7,	/* Index for rm_move_all() RPC call */
+	RM_FUNC_ASSIGN_RESOURCE = 8,	/* Index for rm_assign_resource() RPC call */
+	RM_FUNC_SET_RESOURCE_MOVABLE = 9,	/* Index for rm_set_resource_movable() RPC call */
+	RM_FUNC_SET_SUBSYS_RSRC_MOVABLE = 28,	/* Index for rm_set_subsys_rsrc_movable() RPC call */
+	RM_FUNC_SET_MASTER_ATTRIBUTES = 10,	/* Index for rm_set_master_attributes() RPC call */
+	RM_FUNC_SET_MASTER_SID = 11,	/* Index for rm_set_master_sid() RPC call */
+	RM_FUNC_SET_PERIPHERAL_PERMISSIONS = 12,	/* Index for rm_set_peripheral_permissions() RPC call */
+	RM_FUNC_IS_RESOURCE_OWNED = 13,	/* Index for rm_is_resource_owned() RPC call */
+	RM_FUNC_IS_RESOURCE_MASTER = 14,	/* Index for rm_is_resource_master() RPC call */
+	RM_FUNC_IS_RESOURCE_PERIPHERAL = 15,	/* Index for rm_is_resource_peripheral() RPC call */
+	RM_FUNC_GET_RESOURCE_INFO = 16,	/* Index for rm_get_resource_info() RPC call */
+	RM_FUNC_MEMREG_ALLOC = 17,	/* Index for rm_memreg_alloc() RPC call */
+	RM_FUNC_MEMREG_SPLIT = 29,	/* Index for rm_memreg_split() RPC call */
+	RM_FUNC_MEMREG_FREE = 18,	/* Index for rm_memreg_free() RPC call */
+	RM_FUNC_FIND_MEMREG = 30,	/* Index for rm_find_memreg() RPC call */
+	RM_FUNC_ASSIGN_MEMREG = 19,	/* Index for rm_assign_memreg() RPC call */
+	RM_FUNC_SET_MEMREG_PERMISSIONS = 20,	/* Index for rm_set_memreg_permissions() RPC call */
+	RM_FUNC_IS_MEMREG_OWNED = 21,	/* Index for rm_is_memreg_owned() RPC call */
+	RM_FUNC_GET_MEMREG_INFO = 22,	/* Index for rm_get_memreg_info() RPC call */
+	RM_FUNC_ASSIGN_PAD = 23,	/* Index for rm_assign_pad() RPC call */
+	RM_FUNC_SET_PAD_MOVABLE = 24,	/* Index for rm_set_pad_movable() RPC call */
+	RM_FUNC_IS_PAD_OWNED = 25,	/* Index for rm_is_pad_owned() RPC call */
+	RM_FUNC_DUMP = 27,	/* Index for rm_dump() RPC call */
+} rm_func_t;
+
+/* Functions */
+
+/*!
+ * This function dispatches an incoming RM RPC request.
+ *
+ * @param[in]     caller_pt   caller partition
+ * @param[in]     msg         pointer to RPC message
+ */
+void rm_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates and dispatches an RM RPC request.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     msg         pointer to RPC message
+ */
+void rm_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_RM_RPC_H */
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/rm/rpc_clnt.c b/drivers/soc/imx/sc/svc/rm/rpc_clnt.c
new file mode 100644
index 0000000..a9bb6ba
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/rm/rpc_clnt.c
@@ -0,0 +1,637 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * File containing client-side RPC functions for the RM service. These
+ * functions are ported to clients that communicate to the SC.
+ *
+ * @addtogroup RM_SVC
+ * @{
+ */
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include "../../main/rpc.h"
+#include "rpc.h"
+
+/* Local Defines */
+
+/* Local Types */
+
+/* Local Functions */
+
+sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, bool secure,
+			       bool isolated, bool restricted, bool grant,
+			       bool coherent)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_ALLOC;
+	RPC_U8(&msg, 0) = (uint8_t)secure;
+	RPC_U8(&msg, 1) = (uint8_t)isolated;
+	RPC_U8(&msg, 2) = (uint8_t)restricted;
+	RPC_U8(&msg, 3) = (uint8_t)grant;
+	RPC_U8(&msg, 4) = (uint8_t)coherent;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (pt != NULL) {
+		*pt = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_confidential(sc_ipc_t ipc, sc_rm_pt_t pt, bool retro)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_CONFIDENTIAL;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = (uint8_t)retro;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_partition_free(sc_ipc_t ipc, sc_rm_pt_t pt)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_FREE;
+	RPC_U8(&msg, 0) = pt;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_rm_did_t sc_rm_get_did(sc_ipc_t ipc)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_DID;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_rm_did_t) result;
+}
+
+sc_err_t sc_rm_partition_static(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_did_t did)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_STATIC;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = did;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_partition_lock(sc_ipc_t ipc, sc_rm_pt_t pt)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_LOCK;
+	RPC_U8(&msg, 0) = pt;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_get_partition(sc_ipc_t ipc, sc_rm_pt_t *pt)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_PARTITION;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (pt != NULL) {
+		*pt = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_parent(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_pt_t pt_parent)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_PARENT;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = pt_parent;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
+			bool move_rsrc, bool move_pads)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MOVE_ALL;
+	RPC_U8(&msg, 0) = pt_src;
+	RPC_U8(&msg, 1) = pt_dst;
+	RPC_U8(&msg, 2) = (uint8_t)move_rsrc;
+	RPC_U8(&msg, 3) = (uint8_t)move_pads;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_assign_resource(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rsrc_t resource)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_ASSIGN_RESOURCE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = pt;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_resource_movable(sc_ipc_t ipc, sc_rsrc_t resource_fst,
+				    sc_rsrc_t resource_lst, bool movable)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_RESOURCE_MOVABLE;
+	RPC_U16(&msg, 0) = resource_fst;
+	RPC_U16(&msg, 2) = resource_lst;
+	RPC_U8(&msg, 4) = (uint8_t)movable;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_subsys_rsrc_movable(sc_ipc_t ipc, sc_rsrc_t resource,
+				       bool movable)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_SUBSYS_RSRC_MOVABLE;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = (uint8_t)movable;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_master_attributes(sc_ipc_t ipc, sc_rsrc_t resource,
+				     sc_rm_spa_t sa, sc_rm_spa_t pa,
+				     bool smmu_bypass)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_MASTER_ATTRIBUTES;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = sa;
+	RPC_U8(&msg, 3) = pa;
+	RPC_U8(&msg, 4) = (uint8_t)smmu_bypass;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_master_sid(sc_ipc_t ipc, sc_rsrc_t resource, sc_rm_sid_t sid)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_MASTER_SID;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U16(&msg, 2) = sid;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
+					  sc_rm_pt_t pt, sc_rm_perm_t perm)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_PERIPHERAL_PERMISSIONS;
+	RPC_U16(&msg, 0) = resource;
+	RPC_U8(&msg, 2) = pt;
+	RPC_U8(&msg, 3) = perm;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+bool sc_rm_is_resource_owned(sc_ipc_t ipc, sc_rsrc_t resource)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_RESOURCE_OWNED;
+	RPC_U16(&msg, 0) = resource;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (bool)result;
+}
+
+bool sc_rm_is_resource_master(sc_ipc_t ipc, sc_rsrc_t resource)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_RESOURCE_MASTER;
+	RPC_U16(&msg, 0) = resource;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (bool)result;
+}
+
+bool sc_rm_is_resource_peripheral(sc_ipc_t ipc, sc_rsrc_t resource)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_RESOURCE_PERIPHERAL;
+	RPC_U16(&msg, 0) = resource;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (bool)result;
+}
+
+sc_err_t sc_rm_get_resource_info(sc_ipc_t ipc, sc_rsrc_t resource,
+				 sc_rm_sid_t *sid)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_RESOURCE_INFO;
+	RPC_U16(&msg, 0) = resource;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (sid != NULL) {
+		*sid = RPC_U16(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_memreg_alloc(sc_ipc_t ipc, sc_rm_mr_t *mr,
+			    sc_faddr_t addr_start, sc_faddr_t addr_end)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MEMREG_ALLOC;
+	RPC_U32(&msg, 0) = (uint32_t)(addr_start >> 32u);
+	RPC_U32(&msg, 4) = (uint32_t)addr_start;
+	RPC_U32(&msg, 8) = (uint32_t)(addr_end >> 32u);
+	RPC_U32(&msg, 12) = (uint32_t)addr_end;
+	RPC_SIZE(&msg) = 5;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (mr != NULL) {
+		*mr = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_memreg_split(sc_ipc_t ipc, sc_rm_mr_t mr,
+			    sc_rm_mr_t *mr_ret, sc_faddr_t addr_start,
+			    sc_faddr_t addr_end)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MEMREG_SPLIT;
+	RPC_U32(&msg, 0) = (uint32_t)(addr_start >> 32u);
+	RPC_U32(&msg, 4) = (uint32_t)addr_start;
+	RPC_U32(&msg, 8) = (uint32_t)(addr_end >> 32u);
+	RPC_U32(&msg, 12) = (uint32_t)addr_end;
+	RPC_U8(&msg, 16) = mr;
+	RPC_SIZE(&msg) = 6;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (mr_ret != NULL) {
+		*mr_ret = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_memreg_free(sc_ipc_t ipc, sc_rm_mr_t mr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MEMREG_FREE;
+	RPC_U8(&msg, 0) = mr;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_find_memreg(sc_ipc_t ipc, sc_rm_mr_t *mr,
+			   sc_faddr_t addr_start, sc_faddr_t addr_end)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_FIND_MEMREG;
+	RPC_U32(&msg, 0) = (uint32_t)(addr_start >> 32u);
+	RPC_U32(&msg, 4) = (uint32_t)addr_start;
+	RPC_U32(&msg, 8) = (uint32_t)(addr_end >> 32u);
+	RPC_U32(&msg, 12) = (uint32_t)addr_end;
+	RPC_SIZE(&msg) = 5;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	if (mr != NULL) {
+		*mr = RPC_U8(&msg, 0);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_assign_memreg(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_mr_t mr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_ASSIGN_MEMREG;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = mr;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_memreg_permissions(sc_ipc_t ipc, sc_rm_mr_t mr,
+				      sc_rm_pt_t pt, sc_rm_perm_t perm)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_MEMREG_PERMISSIONS;
+	RPC_U8(&msg, 0) = mr;
+	RPC_U8(&msg, 1) = pt;
+	RPC_U8(&msg, 2) = perm;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+bool sc_rm_is_memreg_owned(sc_ipc_t ipc, sc_rm_mr_t mr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_MEMREG_OWNED;
+	RPC_U8(&msg, 0) = mr;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (bool)result;
+}
+
+sc_err_t sc_rm_get_memreg_info(sc_ipc_t ipc, sc_rm_mr_t mr,
+			       sc_faddr_t *addr_start, sc_faddr_t *addr_end)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_MEMREG_INFO;
+	RPC_U8(&msg, 0) = mr;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (addr_start != NULL) {
+		*addr_start =
+		    ((uint64_t) RPC_U32(&msg, 0) << 32u) | RPC_U32(&msg, 4);
+	}
+
+	if (addr_end != NULL) {
+		*addr_end =
+		    ((uint64_t) RPC_U32(&msg, 8) << 32u) | RPC_U32(&msg, 12);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_assign_pad(sc_ipc_t ipc, sc_rm_pt_t pt, sc_pad_t pad)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_ASSIGN_PAD;
+	RPC_U16(&msg, 0) = pad;
+	RPC_U8(&msg, 2) = pt;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_set_pad_movable(sc_ipc_t ipc, sc_pad_t pad_fst,
+			       sc_pad_t pad_lst, bool movable)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_PAD_MOVABLE;
+	RPC_U16(&msg, 0) = pad_fst;
+	RPC_U16(&msg, 2) = pad_lst;
+	RPC_U8(&msg, 4) = (uint8_t)movable;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+bool sc_rm_is_pad_owned(sc_ipc_t ipc, sc_pad_t pad)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_PAD_OWNED;
+	RPC_U8(&msg, 0) = pad;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (bool)result;
+}
+
+void sc_rm_dump(sc_ipc_t ipc)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
+	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_DUMP;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	return;
+}
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/timer/rpc.h b/drivers/soc/imx/sc/svc/timer/rpc.h
new file mode 100644
index 0000000..42413a0
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/timer/rpc.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the TIMER RPC implementation.
+ *
+ * @addtogroup TIMER_SVC
+ * @{
+ */
+
+#ifndef _SC_TIMER_RPC_H
+#define _SC_TIMER_RPC_H
+
+/* Includes */
+
+/* Defines */
+
+/* Types */
+
+/*!
+ * This type is used to indicate RPC TIMER function calls.
+ */
+typedef enum timer_func_e {
+	TIMER_FUNC_UNKNOWN = 0,	/* Unknown function */
+	TIMER_FUNC_SET_WDOG_TIMEOUT = 1,	/* Index for timer_set_wdog_timeout() RPC call */
+	TIMER_FUNC_SET_WDOG_PRE_TIMEOUT = 12,	/* Index for timer_set_wdog_pre_timeout() RPC call */
+	TIMER_FUNC_START_WDOG = 2,	/* Index for timer_start_wdog() RPC call */
+	TIMER_FUNC_STOP_WDOG = 3,	/* Index for timer_stop_wdog() RPC call */
+	TIMER_FUNC_PING_WDOG = 4,	/* Index for timer_ping_wdog() RPC call */
+	TIMER_FUNC_GET_WDOG_STATUS = 5,	/* Index for timer_get_wdog_status() RPC call */
+	TIMER_FUNC_PT_GET_WDOG_STATUS = 13,	/* Index for timer_pt_get_wdog_status() RPC call */
+	TIMER_FUNC_SET_WDOG_ACTION = 10,	/* Index for timer_set_wdog_action() RPC call */
+	TIMER_FUNC_SET_RTC_TIME = 6,	/* Index for timer_set_rtc_time() RPC call */
+	TIMER_FUNC_GET_RTC_TIME = 7,	/* Index for timer_get_rtc_time() RPC call */
+	TIMER_FUNC_GET_RTC_SEC1970 = 9,	/* Index for timer_get_rtc_sec1970() RPC call */
+	TIMER_FUNC_SET_RTC_ALARM = 8,	/* Index for timer_set_rtc_alarm() RPC call */
+	TIMER_FUNC_SET_RTC_CALB = 11,	/* Index for timer_set_rtc_calb() RPC call */
+} timer_func_t;
+
+/* Functions */
+
+/*!
+ * This function dispatches an incoming TIMER RPC request.
+ *
+ * @param[in]     caller_pt   caller partition
+ * @param[in]     msg         pointer to RPC message
+ */
+void timer_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
+
+/*!
+ * This function translates and dispatches an TIMER RPC request.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     msg         pointer to RPC message
+ */
+void timer_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
+
+#endif				/* _SC_TIMER_RPC_H */
+
+/**@}*/
diff --git a/drivers/soc/imx/sc/svc/timer/rpc_clnt.c b/drivers/soc/imx/sc/svc/timer/rpc_clnt.c
new file mode 100644
index 0000000..badb79e
--- /dev/null
+++ b/drivers/soc/imx/sc/svc/timer/rpc_clnt.c
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * File containing client-side RPC functions for the TIMER service. These
+ * functions are ported to clients that communicate to the SC.
+ *
+ * @addtogroup TIMER_SVC
+ * @{
+ */
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include <soc/imx8/sc/svc/timer/api.h>
+#include "../../main/rpc.h"
+#include "rpc.h"
+
+/* Local Defines */
+
+/* Local Types */
+
+/* Local Functions */
+
+sc_err_t sc_timer_set_wdog_timeout(sc_ipc_t ipc, sc_timer_wdog_time_t timeout)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_WDOG_TIMEOUT;
+	RPC_U32(&msg, 0) = timeout;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_wdog_pre_timeout(sc_ipc_t ipc,
+				       sc_timer_wdog_time_t pre_timeout)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_WDOG_PRE_TIMEOUT;
+	RPC_U32(&msg, 0) = pre_timeout;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_start_wdog(sc_ipc_t ipc, bool lock)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_START_WDOG;
+	RPC_U8(&msg, 0) = (uint8_t)lock;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_stop_wdog(sc_ipc_t ipc)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_STOP_WDOG;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_ping_wdog(sc_ipc_t ipc)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_PING_WDOG;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_get_wdog_status(sc_ipc_t ipc,
+				  sc_timer_wdog_time_t *timeout,
+				  sc_timer_wdog_time_t *max_timeout,
+				  sc_timer_wdog_time_t *remaining_time)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_GET_WDOG_STATUS;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (timeout != NULL) {
+		*timeout = RPC_U32(&msg, 0);
+	}
+
+	if (max_timeout != NULL) {
+		*max_timeout = RPC_U32(&msg, 4);
+	}
+
+	if (remaining_time != NULL) {
+		*remaining_time = RPC_U32(&msg, 8);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt, bool *enb,
+				     sc_timer_wdog_time_t *timeout,
+				     sc_timer_wdog_time_t *remaining_time)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_PT_GET_WDOG_STATUS;
+	RPC_U8(&msg, 0) = pt;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (timeout != NULL) {
+		*timeout = RPC_U32(&msg, 0);
+	}
+
+	if (remaining_time != NULL) {
+		*remaining_time = RPC_U32(&msg, 4);
+	}
+
+	result = RPC_R8(&msg);
+	if (enb != NULL) {
+		*enb = RPC_U8(&msg, 8);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_wdog_action(sc_ipc_t ipc,
+				  sc_rm_pt_t pt, sc_timer_wdog_action_t action)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_WDOG_ACTION;
+	RPC_U8(&msg, 0) = pt;
+	RPC_U8(&msg, 1) = action;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_rtc_time(sc_ipc_t ipc, uint16_t year, uint8_t mon,
+			       uint8_t day, uint8_t hour, uint8_t min,
+			       uint8_t sec)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_RTC_TIME;
+	RPC_U16(&msg, 0) = year;
+	RPC_U8(&msg, 2) = mon;
+	RPC_U8(&msg, 3) = day;
+	RPC_U8(&msg, 4) = hour;
+	RPC_U8(&msg, 5) = min;
+	RPC_U8(&msg, 6) = sec;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_get_rtc_time(sc_ipc_t ipc, uint16_t *year, uint8_t *mon,
+			       uint8_t *day, uint8_t *hour, uint8_t *min,
+			       uint8_t *sec)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_GET_RTC_TIME;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (year != NULL) {
+		*year = RPC_U16(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	if (mon != NULL) {
+		*mon = RPC_U8(&msg, 2);
+	}
+
+	if (day != NULL) {
+		*day = RPC_U8(&msg, 3);
+	}
+
+	if (hour != NULL) {
+		*hour = RPC_U8(&msg, 4);
+	}
+
+	if (min != NULL) {
+		*min = RPC_U8(&msg, 5);
+	}
+
+	if (sec != NULL) {
+		*sec = RPC_U8(&msg, 6);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_get_rtc_sec1970(sc_ipc_t ipc, uint32_t *sec)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_GET_RTC_SEC1970;
+	RPC_SIZE(&msg) = 1;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	if (sec != NULL) {
+		*sec = RPC_U32(&msg, 0);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_rtc_alarm(sc_ipc_t ipc, uint16_t year, uint8_t mon,
+				uint8_t day, uint8_t hour, uint8_t min,
+				uint8_t sec)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_RTC_ALARM;
+	RPC_U16(&msg, 0) = year;
+	RPC_U8(&msg, 2) = mon;
+	RPC_U8(&msg, 3) = day;
+	RPC_U8(&msg, 4) = hour;
+	RPC_U8(&msg, 5) = min;
+	RPC_U8(&msg, 6) = sec;
+	RPC_SIZE(&msg) = 3;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_rtc_calb(sc_ipc_t ipc, int8_t count)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
+	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_RTC_CALB;
+	RPC_I8(&msg, 0) = count;
+	RPC_SIZE(&msg) = 2;
+
+	sc_call_rpc(ipc, &msg, false);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+/**@}*/
diff --git a/include/linux/rpmsg.h b/include/linux/rpmsg.h
index 9fe156d..179f1d0 100644
--- a/include/linux/rpmsg.h
+++ b/include/linux/rpmsg.h
@@ -18,6 +18,8 @@
 #include <linux/mutex.h>
 #include <linux/poll.h>
 
+#define VIRTIO_RPMSG_F_NS       0
+
 #define RPMSG_ADDR_ANY		0xFFFFFFFF
 
 struct rpmsg_device;
diff --git a/include/soc/imx8/fsl_bitaccess.h b/include/soc/imx8/fsl_bitaccess.h
new file mode 100644
index 0000000..11e71ee
--- /dev/null
+++ b/include/soc/imx8/fsl_bitaccess.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*!
+ * @file  devices/MX8/include/fsl_bitaccess.h
+ *
+ * Header file containing register access macros.
+ *
+ * \addtogroup Peripheral_access_layer (HAL) Device Peripheral Access Layer
+ *
+ * @{
+ */
+
+#ifndef _FSL_BITACCESS_H
+#define _FSL_BITACCESS_H  1
+
+/*!
+ * @addtogroup SCF Register Access Macros
+ * @{
+ */
+
+/*
+ * Macros for single instance registers
+ */
+
+#define BF_SET(reg, field)       HW_##reg##_SET(BM_##reg##_##field)
+#define BF_CLR(reg, field)       HW_##reg##_CLR(BM_##reg##_##field)
+#define BF_TOG(reg, field)       HW_##reg##_TOG(BM_##reg##_##field)
+
+#define BF_SETV(reg, field, v)   HW_##reg##_SET(BF_##reg##_##field(v))
+#define BF_CLRV(reg, field, v)   HW_##reg##_CLR(BF_##reg##_##field(v))
+#define BF_TOGV(reg, field, v)   HW_##reg##_TOG(BF_##reg##_##field(v))
+
+#define BV_FLD(reg, field, sym)  BF_##reg##_##field(BV_##reg##_##field##__##sym)
+#define BV_VAL(reg, field, sym)  BV_##reg##_##field##__##sym
+
+#define BF_RD(reg, field)        HW_##reg.B.field
+#define BF_WR(reg, field, v)     BW_##reg##_##field(v)
+
+
+/*******************************************************************************
+ * Macros to create bitfield mask, shift, and width from CMSIS definitions
+ ******************************************************************************/
+
+/* Bitfield Mask */
+#define SCF_BMSK(bit) (bit ## _MASK)
+
+/* Bitfield Left Shift */
+#define SCF_BLSH(bit) (bit ## _SHIFT)
+
+/* Bitfield Width */
+#define SCF_BWID(bit) (bit ## _WIDTH)
+
+/* Bitfield Value */
+#define SCF_BVAL(bit, val) ((val) << (SCF_BLSH(bit)))
+
+
+/*******************************************************************************
+ * Macros to set, clear, extact, and insert bitfields into register structures
+ * or local variables
+ ******************************************************************************/
+
+/* Bitfield Set */
+#define SCF_BSET(var, bit) (var |= (SCF_BMSK(bit)))
+
+/* Bitfield Clear */
+#define SCF_BCLR(var, bit) (var &= (~(SCF_BMSK(bit))))
+
+/* Bitfield Extract */
+#define SCF_BEXR(var, bit) ((var & (SCF_BMSK(bit))) >> (SCF_BLSH(bit)))
+
+/* Bitfield Insert */
+#define SCF_BINS(var, bit, val) (var = (var & (~(SCF_BMSK(bit)))) | SCF_BVAL(bit, val))
+
+
+/*******************************************************************************
+ * Macros to set, clear, extact, and insert bitfields into register structures
+ * that support SCT
+ ******************************************************************************/
+
+#ifdef EMUL
+/* Emulation does not have SCT hardware and must fallback to non-SCT definitions */
+
+/* SCT Bitfield Set */
+#define SCF_SCT_BSET(var, bit) (SCF_BSET(var, bit))
+
+/* SCT Bitfield Clear */
+#define SCF_SCT_BCLR(var, bit) (SCF_BCLR(var, bit))
+
+/* SCT Bitfield Insert */
+#define SCF_SCT_BINS(var, bit, val) (SCF_BINS(var, bit, val))
+
+#else
+/*!  @todo Port macros leverage SCT register access hardware */
+
+/* SCT Bitfield Set */
+#define SCF_SCT_BSET(var, bit) (SCF_BSET(var, bit))
+
+/* SCT Bitfield Clear */
+#define SCF_SCT_BCLR(var, bit) (SCF_BCLR(var, bit))
+
+/* SCT Bitfield Insert */
+#define SCF_SCT_BINS(var, bit, val) (SCF_BINS(var, bit, val))
+
+#endif /* EMUL */
+
+/*!
+ * @}
+ */ /* end of group SCF */
+
+/*!
+ * @}
+ */ /* end of group Peripheral_access_layer */
+
+#endif /* _FSL_BITACCESS_H */
+
+/******************************************************************************/
diff --git a/include/soc/imx8/imx8qm/lpcg.h b/include/soc/imx8/imx8qm/lpcg.h
new file mode 100644
index 0000000..6b352a5
--- /dev/null
+++ b/include/soc/imx8/imx8qm/lpcg.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _SC_LPCG_H
+#define _SC_LPCG_H
+
+/*LSIO SS */
+#define		PWM_0_LPCG		0x5D400000
+#define		PWM_1_LPCG		0x5D410000
+#define		PWM_2_LPCG		0x5D420000
+#define		PWM_3_LPCG		0x5D430000
+#define		PWM_4_LPCG		0x5D440000
+#define		PWM_5_LPCG		0x5D450000
+#define		PWM_6_LPCG		0x5D460000
+#define		PWM_7_LPCG		0x5D470000
+#define		GPIO_0_LPCG		0x5D480000
+#define		GPIO_1_LPCG		0x5D490000
+#define		GPIO_2_LPCG		0x5D4A0000
+#define		GPIO_3_LPCG		0x5D4B0000
+#define		GPIO_4_LPCG		0x5D4C0000
+#define		GPIO_5_LPCG		0x5D4D0000
+#define		GPIO_6_LPCG		0x5D4E0000
+#define		GPIO_7_LPCG		0x5D4F0000
+#define		ROMCP_LPCG		0x5D500000
+#define		FSPI_0_LPCG		0x5D520000
+#define		FSPI_1_LPCG		0x5D530000
+#define		GPT_0_LPCG		0x5D540000
+#define		GPT_1_LPCG		0x5D550000
+#define		GPT_2_LPCG		0x5D560000
+#define		GPT_3_LPCG		0x5D570000
+#define		GPT_4_LPCG		0x5D580000
+#define		OCRAM_LPCG		0x5D590000
+#define		KPP_LPCG		0x5D5A0000
+
+/* HSIO SS */
+#define		CRR_5_LPCG		0x5F0F0000
+#define		CRR_4_LPCG		0x5F0E0000
+#define		CRR_3_LPCG		0x5F0D0000
+#define		CRR_2_LPCG		0x5F0C0000
+#define		CRR_1_LPCG		0x5F0B0000
+#define		CRR_0_LPCG		0x5F0A0000
+#define		PHY_1_LPCG		0x5F090000
+#define		PHY_2_LPCG		0x5F080000
+#define		SATA_0_LPCG		0x5F070000
+#define		PCIE_B_LPCG		0x5F060000
+#define		PCIE_A_LPCG		0x5F050000
+
+/* DMA SS */
+#define		FLEX_CAN_2_LPCG		0x5ACF0000
+#define		FLEX_CAN_1_LPCG		0x5ACE0000
+#define		FLEX_CAN_0_LPCG		0x5ACD0000
+#define		FTM_1_LPCG		0x5ACB0000
+#define		FTM_0_LPCG		0x5ACA0000
+#define		ADC_1_LPCG		0x5AC90000
+#define		ADC_0_LPCG		0x5AC80000
+#define		LPI2C_4_LPCG		0x5AC40000
+#define		LPI2C_3_LPCG		0x5AC30000
+#define		LPI2C_2_LPCG		0x5AC20000
+#define		LPI2C_1_LPCG		0x5AC10000
+#define		LPI2C_0_LPCG		0x5AC00000
+#define		EMVSIM_1_LPCG		0x5A4E0000
+#define		EMVSIM_0_LPCG		0x5A4D0000
+#define		LPUART_4_LPCG		0x5A4A0000
+#define		LPUART_3_LPCG		0x5A490000
+#define		LPUART_2_LPCG		0x5A480000
+#define		LPUART_1_LPCG		0x5A470000
+#define		LPUART_0_LPCG		0x5A460000
+#define		LPSPI_3_LPCG		0x5A430000
+#define		LPSPI_2_LPCG		0x5A420000
+#define		LPSPI_1_LPCG		0x5A410000
+#define		LPSPI_0_LPCG		0x5A400000
+
+/* Display SS */
+#define		DC_0_LPCG		0x56010000
+#define		DC_1_LPCG		0x57010000
+
+/* LVDS */
+#define		DI_LVDS_0_LPCG		0x56243000
+#define		DI_LVDS_1_LPCG		0x57243000
+
+/* DI HDMI */
+#define		DI_HDMI_LPCG		0x56263000
+
+/* RX-HDMI */
+#define		RX_HDMI_LPCG		0x58263000
+
+/* MIPI CSI SS */
+#define		MIPI_CSI_0_LPCG		0x58223000
+#define		MIPI_CSI_1_LPCG		0x58243000
+
+/* Imaging SS */
+#define IMG_JPEG_ENC_LPCG		0x585F0000
+#define IMG_JPEG_DEC_LPCG		0x585D0000
+#define IMG_PXL_LINK_DC1_LPCG	0x585C0000
+#define IMG_PXL_LINK_DC0_LPCG	0x585B0000
+#define IMG_PXL_LINK_HDMI_LPCG	0x585A0000
+#define IMG_PXL_LINK_CSI0_LPCG	0x58590000
+#define IMG_PXL_LINK_CSI1_LPCG	0x58580000
+#define IMG_PDMA_7_LPCG			0x58570000
+#define IMG_PDMA_6_LPCG			0x58560000
+#define IMG_PDMA_5_LPCG			0x58550000
+#define IMG_PDMA_4_LPCG			0x58540000
+#define IMG_PDMA_3_LPCG			0x58530000
+#define IMG_PDMA_2_LPCG			0x58520000
+#define IMG_PDMA_1_LPCG			0x58510000
+#define IMG_PDMA_0_LPCG			0x58500000
+
+/* HSIO SS */
+#define HSIO_GPIO_LPCG			0x5F100000
+#define HSIO_MISC_LPCG			0x5F0F0000
+#define HSIO_SATA_CRR4_LPCG		0x5F0E0000
+#define HSIO_PCIE_X1_CRR3_LPCG	0x5F0D0000
+#define HSIO_PCIE_X2_CRR2_LPCG	0x5F0C0000
+#define HSIO_PHY_X1_CRR1_LPCG	0x5F0B0000
+#define HSIO_PHY_X2_CRR0_LPCG	0x5F0A0000
+#define HSIO_PHY_X1_LPCG		0x5F090000
+#define HSIO_PHY_X2_LPCG		0x5F080000
+#define HSIO_SATA_LPCG			0x5F070000
+#define HSIO_PCIE_X1_LPCG		0x5F060000
+#define HSIO_PCIE_X2_LPCG		0x5F050000
+
+/* M4 SS */
+#define		M4_0_I2C_LPCG		0x37630000
+#define		M4_0_LPUART_LPCG	0x37620000
+#define		M4_0_LPIT_LPCG		0x37610000
+#define		M4_1_I2C_LPCG		0x3B630000
+#define		M4_1_LPUART_LPCG	0x3B620000
+#define		M4_1_LPIT_LPCG		0x3B610000
+
+/* Audio SS */
+#define     AUD_ASRC_0_LPCG         0x59400000
+#define     AUD_ESAI_0_LPCG         0x59410000
+#define     AUD_SPDIF_0_LPCG        0x59420000
+#define     AUD_SPDIF_1_LPCG        0x59430000
+#define     AUD_SAI_0_LPCG          0x59440000
+#define     AUD_SAI_1_LPCG          0x59450000
+#define     AUD_SAI_2_LPCG          0x59460000
+#define     AUD_SAI_3_LPCG          0x59470000
+#define     AUD_HDMI_RX_SAI_0_LPCG  0x59480000
+#define     AUD_HDMI_TX_SAI_0_LPCG  0x59490000
+#define     AUD_GPT_5_LPCG          0x594B0000
+#define     AUD_GPT_6_LPCG          0x594C0000
+#define     AUD_GPT_7_LPCG          0x594D0000
+#define     AUD_GPT_8_LPCG          0x594E0000
+#define     AUD_GPT_9_LPCG          0x594F0000
+#define     AUD_GPT_10_LPCG         0x59500000
+#define     AUD_EDMA_0_LPCG         0x595f0000
+#define     AUD_ASRC_1_LPCG         0x59c00000
+#define     AUD_ESAI_1_LPCG         0x59c10000
+#define     AUD_SAI_6_LPCG          0x59c20000
+#define     AUD_SAI_7_LPCG          0x59c30000
+#define     AUD_AMIX_LPCG           0x59c40000
+#define     AUD_MQS_LPCG            0x59c50000
+#define     AUD_ACM_LPCG            0x59c60000
+#define     AUD_REC_CLK0_LPCG       0x59d00000
+#define     AUD_REC_CLK1_LPCG       0x59d10000
+#define     AUD_PLL_CLK0_LPCG       0x59d20000
+#define     AUD_PLL_CLK1_LPCG       0x59d30000
+#define     AUD_MCLKOUT0_LPCG       0x59d50000
+#define     AUD_MCLKOUT1_LPCG       0x59d60000
+#define     AUD_EDMA_1_LPCG         0x59df0000
+
+
+/* Connectivity SS */
+#define     USDHC_0_LPCG        0x5B200000
+#define     USDHC_1_LPCG        0x5B210000
+#define     USDHC_2_LPCG        0x5B220000
+#define     ENET_0_LPCG         0x5B230000
+#define     ENET_1_LPCG         0x5B240000
+#define     DTCP_LPCG           0x5B250000
+#define     MLB_LPCG            0x5B260000
+#define     USB_2_LPCG          0x5B270000
+#define     USB_3_LPCG          0x5B280000
+#define     NAND_LPCG           0x5B290000
+#define     EDMA_LPCG           0x5B2A0000
+
+
+#endif
diff --git a/include/soc/imx8/imx8qxp/lpcg.h b/include/soc/imx8/imx8qxp/lpcg.h
new file mode 100644
index 0000000..3d47aee
--- /dev/null
+++ b/include/soc/imx8/imx8qxp/lpcg.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _SC_LPCG_H
+#define _SC_LPCG_H
+
+/*LSIO SS */
+#define		PWM_0_LPCG		0x5D400000
+#define		PWM_1_LPCG		0x5D410000
+#define		PWM_2_LPCG		0x5D420000
+#define		PWM_3_LPCG		0x5D430000
+#define		PWM_4_LPCG		0x5D440000
+#define		PWM_5_LPCG		0x5D450000
+#define		PWM_6_LPCG		0x5D460000
+#define		PWM_7_LPCG		0x5D470000
+#define		GPIO_0_LPCG		0x5D480000
+#define		GPIO_1_LPCG		0x5D490000
+#define		GPIO_2_LPCG		0x5D4A0000
+#define		GPIO_3_LPCG		0x5D4B0000
+#define		GPIO_4_LPCG		0x5D4C0000
+#define		GPIO_5_LPCG		0x5D4D0000
+#define		GPIO_6_LPCG		0x5D4E0000
+#define		GPIO_7_LPCG		0x5D4F0000
+#define		FSPI_0_LPCG		0x5D520000
+#define		FSPI_1_LPCG		0x5D530000
+#define		GPT_0_LPCG		0x5D540000
+#define		GPT_1_LPCG		0x5D550000
+#define		GPT_2_LPCG		0x5D560000
+#define		GPT_3_LPCG		0x5D570000
+#define		GPT_4_LPCG		0x5D580000
+#define		OCRAM_LPCG		0x5D590000
+#define		KPP_LPCG		0x5D5A0000
+#define		ROMCP_LPCG		0x5D500000
+
+/* HSIO SS */
+#define		CRR_5_LPCG		0x5F0F0000
+#define		CRR_4_LPCG		0x5F0E0000
+#define		CRR_3_LPCG		0x5F0D0000
+#define		CRR_2_LPCG		0x5F0C0000
+#define		CRR_1_LPCG		0x5F0B0000
+#define		CRR_0_LPCG		0x5F0A0000
+#define		PHY_1_LPCG		0x5F090000
+#define		PHY_2_LPCG		0x5F080000
+#define		SATA_0_LPCG		0x5F070000
+#define		PCIE_B_LPCG		0x5F060000
+#define		PCIE_A_LPCG		0x5F050000
+
+/* DMA SS */
+#define		FLEX_CAN_2_LPCG		0x5ACF0000
+#define		FLEX_CAN_1_LPCG		0x5ACE0000
+#define		FLEX_CAN_0_LPCG		0x5ACD0000
+#define		FTM_1_LPCG		0x5ACB0000
+#define		FTM_0_LPCG		0x5ACA0000
+#define		ADC_0_LPCG		0x5AC80000
+#define		LPI2C_3_LPCG		0x5AC30000
+#define		LPI2C_2_LPCG		0x5AC20000
+#define		LPI2C_1_LPCG		0x5AC10000
+#define		LPI2C_0_LPCG		0x5AC00000
+#define		PWM_LPCG		0x5A590000
+#define		LCD_LPCG		0x5A580000
+#define		LPUART_3_LPCG		0x5A490000
+#define		LPUART_2_LPCG		0x5A480000
+#define		LPUART_1_LPCG		0x5A470000
+#define		LPUART_0_LPCG		0x5A460000
+#define		LPSPI_3_LPCG		0x5A430000
+#define		LPSPI_2_LPCG		0x5A420000
+#define		LPSPI_1_LPCG		0x5A410000
+#define		LPSPI_0_LPCG		0x5A400000
+
+/* Display SS */
+#define		DC_0_LPCG		0x56010000
+#define		DC_1_LPCG		0x57010000
+
+/* LVDS */
+#define		DI_LVDS_0_LPCG		0x56243000
+#define		DI_LVDS_1_LPCG		0x57243000
+
+/* DI HDMI */
+#define		DI_HDMI_LPCG		0x56263000
+
+/* RX-HDMI */
+#define		RX_HDMI_LPCG		0x58263000
+
+/* MIPI CSI SS */
+#define		MIPI_CSI_0_LPCG		0x58223000
+#define		MIPI_CSI_1_LPCG		0x58243000
+
+/* Display MIPI SS */
+#define		DI_MIPI_LPCG		0x56030000
+
+/* Imaging SS */
+#define IMG_JPEG_ENC_LPCG		0x585F0000
+#define IMG_JPEG_DEC_LPCG		0x585D0000
+#define IMG_PXL_LINK_DC1_LPCG	0x585C0000
+#define IMG_PXL_LINK_DC0_LPCG	0x585B0000
+#define IMG_PXL_LINK_HDMI_LPCG	0x585A0000
+#define IMG_PXL_LINK_CSI0_LPCG	0x58590000
+#define IMG_PXL_LINK_CSI1_LPCG	0x58580000
+#define IMG_PDMA_7_LPCG			0x58570000
+#define IMG_PDMA_6_LPCG			0x58560000
+#define IMG_PDMA_5_LPCG			0x58550000
+#define IMG_PDMA_4_LPCG			0x58540000
+#define IMG_PDMA_3_LPCG			0x58530000
+#define IMG_PDMA_2_LPCG			0x58520000
+#define IMG_PDMA_1_LPCG			0x58510000
+#define IMG_PDMA_0_LPCG			0x58500000
+
+/* HSIO SS */
+#define HSIO_GPIO_LPCG			0x5F100000
+#define HSIO_MISC_LPCG			0x5F0F0000
+#define HSIO_SATA_CRR4_LPCG		0x5F0E0000
+#define HSIO_PCIE_X1_CRR3_LPCG	0x5F0D0000
+#define HSIO_PCIE_X2_CRR2_LPCG	0x5F0C0000
+#define HSIO_PHY_X1_CRR1_LPCG	0x5F0B0000
+#define HSIO_PHY_X2_CRR0_LPCG	0x5F0A0000
+#define HSIO_PHY_X1_LPCG		0x5F090000
+#define HSIO_PHY_X2_LPCG		0x5F080000
+#define HSIO_SATA_LPCG			0x5F070000
+#define HSIO_PCIE_X1_LPCG		0x5F060000
+#define HSIO_PCIE_X2_LPCG		0x5F050000
+
+/* M4 SS */
+#define		M4_0_I2C_LPCG		0x37630000
+#define		M4_0_LPUART_LPCG	0x37620000
+#define		M4_0_LPIT_LPCG		0x37610000
+#define		M4_1_I2C_LPCG		0x3B630000
+#define		M4_1_LPUART_LPCG	0x3B620000
+#define		M4_1_LPIT_LPCG		0x3B610000
+
+/* Audio SS */
+#define     AUD_ASRC_0_LPCG         0x59400000
+#define     AUD_ESAI_0_LPCG         0x59410000
+#define     AUD_SPDIF_0_LPCG        0x59420000
+#define     AUD_SPDIF_1_LPCG        0x59430000
+#define     AUD_SAI_0_LPCG          0x59440000
+#define     AUD_SAI_1_LPCG          0x59450000
+#define     AUD_SAI_2_LPCG          0x59460000
+#define     AUD_SAI_3_LPCG          0x59470000
+#define     AUD_HDMI_RX_SAI_0_LPCG  0x59480000
+#define     AUD_HDMI_TX_SAI_0_LPCG  0x59490000
+#define     AUD_GPT_5_LPCG          0x594B0000
+#define     AUD_GPT_6_LPCG          0x594C0000
+#define     AUD_GPT_7_LPCG          0x594D0000
+#define     AUD_GPT_8_LPCG          0x594E0000
+#define     AUD_GPT_9_LPCG          0x594F0000
+#define     AUD_GPT_10_LPCG         0x59500000
+#define     AUD_EDMA_0_LPCG         0x595f0000
+#define     AUD_ASRC_1_LPCG         0x59c00000
+#define     AUD_ESAI_1_LPCG         0x59c10000
+#define     AUD_SAI_6_LPCG          0x59c20000
+#define     AUD_SAI_7_LPCG          0x59c30000
+#define     AUD_AMIX_LPCG           0x59c40000
+#define     AUD_MQS_LPCG            0x59c50000
+#define     AUD_ACM_LPCG            0x59c60000
+#define     AUD_REC_CLK0_LPCG       0x59d00000
+#define     AUD_REC_CLK1_LPCG       0x59d10000
+#define     AUD_PLL_CLK0_LPCG       0x59d20000
+#define     AUD_PLL_CLK1_LPCG       0x59d30000
+#define     AUD_MCLKOUT0_LPCG       0x59d50000
+#define     AUD_MCLKOUT1_LPCG       0x59d60000
+#define     AUD_EDMA_1_LPCG         0x59df0000
+
+
+/* Connectivity SS */
+#define     USDHC_0_LPCG        0x5B200000
+#define     USDHC_1_LPCG        0x5B210000
+#define     USDHC_2_LPCG        0x5B220000
+#define     ENET_0_LPCG         0x5B230000
+#define     ENET_1_LPCG         0x5B240000
+#define     DTCP_LPCG           0x5B250000
+#define     MLB_LPCG            0x5B260000
+#define     USB_2_LPCG          0x5B270000
+#define     USB_3_LPCG          0x5B280000
+#define     NAND_LPCG           0x5B290000
+#define     EDMA_LPCG           0x5B2A0000
+
+
+#endif
diff --git a/include/soc/imx8/sc/ipc.h b/include/soc/imx8/sc/ipc.h
new file mode 100644
index 0000000..d87f918
--- /dev/null
+++ b/include/soc/imx8/sc/ipc.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file for the IPC implementation.
+ */
+
+#ifndef _SC_IPC_H
+#define _SC_IPC_H
+
+/* Includes */
+
+#include <linux/thermal.h>
+#include <soc/imx8/sc/types.h>
+
+/* Defines */
+
+/* Types */
+
+/* Functions */
+
+/*!
+ * This function opens an IPC channel.
+ *
+ * @param[out]    ipc         return pointer for ipc handle
+ * @param[in]     id          id of channel to open
+ *
+ * @return Returns an error code (SC_ERR_NONE = success, SC_ERR_IPC
+ *         otherwise).
+ *
+ * The \a id parameter is implementation specific. Could be an MU
+ * address, pointer to a driver path, channel index, etc.
+ */
+sc_err_t sc_ipc_open(sc_ipc_t *ipc, sc_ipc_id_t id);
+
+/*!
+ * This function closes an IPC channel.
+ *
+ * @param[in]     ipc         id of channel to close
+ */
+void sc_ipc_close(sc_ipc_t ipc);
+
+/*!
+ * This function reads a message from an IPC channel.
+ *
+ * @param[in]     ipc         id of channel read from
+ * @param[out]    data        pointer to message buffer to read
+ *
+ * This function will block if no message is available to be read.
+ */
+void sc_ipc_read(sc_ipc_t ipc, void *data);
+
+/*!
+ * This function writes a message to an IPC channel.
+ *
+ * @param[in]     ipc         id of channel to write to
+ * @param[in]     data        pointer to message buffer to write
+ *
+ * This function will block if the outgoing buffer is full.
+ */
+void sc_ipc_write(sc_ipc_t ipc, void *data);
+
+int register_scu_notifier(struct notifier_block *nb);
+int unregister_scu_notifier(struct notifier_block *nb);
+
+#endif /* _SC_IPC_H */
+
diff --git a/include/soc/imx8/sc/scfw.h b/include/soc/imx8/sc/scfw.h
new file mode 100644
index 0000000..3c77c69
--- /dev/null
+++ b/include/soc/imx8/sc/scfw.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _SC_SCFW_H
+#define _SC_SCFW_H
+
+#include <linux/types.h>
+
+/*!
+ * This type is used to declare a handle for an IPC communication
+ * channel. Its meaning is specific to the IPC implementation.
+ */
+typedef uint32_t sc_ipc_t;
+
+/*!
+ * This type is used to declare an ID for an IPC communication
+ * channel. Its meaning is specific to the IPC implementation.
+ */
+typedef uint32_t sc_ipc_id_t;
+
+/*!
+ * This function returns the MU channel ID for this implementation
+ *
+ * @param[in]     ipc         pointer to Mu channel ID
+ * @return Returns an error code (SC_ERR_NONE = success, SC_ERR_IPC
+ *         otherwise).
+ */
+int sc_ipc_getMuID(uint32_t *mu_id);
+
+#endif
diff --git a/include/soc/imx8/sc/sci.h b/include/soc/imx8/sc/sci.h
new file mode 100644
index 0000000..004ad07
--- /dev/null
+++ b/include/soc/imx8/sc/sci.h
@@ -0,0 +1,42 @@
+/*==========================================================================*/
+/*!
+ * @file sci.h
+ *
+ * Header file containing the public System Controller Interface (SCI)
+ * definitions.
+ *
+ *
+ * @{
+ */
+/*==========================================================================*/
+
+#ifndef _SC_SCI_H
+#define _SC_SCI_H
+
+/* Defines */
+
+#define SC_NUM_IPC		5
+
+/* Includes */
+
+#include <soc/imx8/sc/ipc.h>
+#include <soc/imx8/sc/svc/misc/api.h>
+#include <soc/imx8/sc/svc/pad/api.h>
+#include <soc/imx8/sc/svc/pm/api.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+#include <soc/imx8/sc/svc/timer/api.h>
+
+/* Types */
+
+/* Functions */
+/*!
+ * This function initializes the MU connection to SCU.
+ *
+ * @return  Returns an error code.
+ */
+int imx8_mu_init(void);
+
+#endif /* _SC_SCI_H */
+
+/**@}*/
+
diff --git a/include/soc/imx8/sc/svc/irq/api.h b/include/soc/imx8/sc/svc/irq/api.h
new file mode 100644
index 0000000..bd1b7fc
--- /dev/null
+++ b/include/soc/imx8/sc/svc/irq/api.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing the public API for the System Controller (SC)
+ * Interrupt (IRQ) function.
+ *
+ * @addtogroup IRQ_SVC (SVC) Interrupt Service
+ *
+ * Module for the Interrupt (IRQ) service.
+ *
+ * @{
+ */
+
+#ifndef _SC_IRQ_API_H
+#define _SC_IRQ_API_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+
+/* Defines */
+
+#define SC_IRQ_NUM_GROUP    4	/* Number of groups */
+
+/*!
+ * @name Defines for sc_irq_group_t
+ */
+/*@{*/
+#define SC_IRQ_GROUP_TEMP   0	/* Temp interrupts */
+#define SC_IRQ_GROUP_WDOG   1	/* Watchdog interrupts */
+#define SC_IRQ_GROUP_RTC    2	/* RTC interrupts */
+#define SC_IRQ_GROUP_WAKE   3	/* Wakeup interrupts */
+/*@}*/
+
+/*!
+ * @name Defines for sc_irq_temp_t
+ */
+/*@{*/
+#define SC_IRQ_TEMP_HIGH         (1 << 0)	/* Temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU0_HIGH    (1 << 1)	/* CPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU1_HIGH    (1 << 2)	/* CPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU0_HIGH    (1 << 3)	/* GPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU1_HIGH    (1 << 4)	/* GPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC0_HIGH    (1 << 5)	/* DRC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC1_HIGH    (1 << 6)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_VPU_HIGH     (1 << 7)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC0_HIGH   (1 << 8)	/* PMIC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC1_HIGH   (1 << 9)	/* PMIC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_LOW          (1 << 10)	/* Temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU0_LOW     (1 << 11)	/* CPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU1_LOW     (1 << 12)	/* CPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU0_LOW     (1 << 13)	/* GPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU1_LOW     (1 << 14)	/* GPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC0_LOW     (1 << 15)	/* DRC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC1_LOW     (1 << 16)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_VPU_LOW      (1 << 17)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC0_LOW    (1 << 18)	/* PMIC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC1_LOW    (1 << 19)	/* PMIC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC2_HIGH   (1 << 20)	/* PMIC2 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC2_LOW    (1 << 21)	/* PMIC2 temp alarm interrupt */
+/*@}*/
+
+/*!
+ * @name Defines for sc_irq_wdog_t
+ */
+/*@{*/
+#define SC_IRQ_WDOG              (1 << 0)	/* Watchdog interrupt */
+/*@}*/
+
+/*!
+ * @name Defines for sc_irq_rtc_t
+ */
+/*@{*/
+#define SC_IRQ_RTC               (1 << 0)	/* RTC interrupt */
+/*@}*/
+
+/*!
+ * @name Defines for sc_irq_wake_t
+ */
+/*@{*/
+#define SC_IRQ_BUTTON            (1 << 0)	/* Button interrupt */
+/*@}*/
+
+/* Types */
+
+/*!
+ * This type is used to declare an interrupt group.
+ */
+typedef uint8_t sc_irq_group_t;
+
+/*!
+ * This type is used to declare a bit mask of temp interrupts.
+ */
+typedef uint8_t sc_irq_temp_t;
+
+/*!
+ * This type is used to declare a bit mask of watchdog interrupts.
+ */
+typedef uint8_t sc_irq_wdog_t;
+
+/*!
+ * This type is used to declare a bit mask of RTC interrupts.
+ */
+typedef uint8_t sc_irq_rtc_t;
+
+/*!
+ * This type is used to declare a bit mask of wakeup interrupts.
+ */
+typedef uint8_t sc_irq_wake_t;
+
+/* Functions */
+
+/*!
+ * This function enables/disables interrupts. If pending interrupts
+ * are unmasked, an interrupt will be triggered.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    MU channel
+ * @param[in]     group       group the interrupts are in
+ * @param[in]     mask        mask of interrupts to affect
+ * @param[in]     enable      state to change interrupts to
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if group invalid
+ */
+sc_err_t sc_irq_enable(sc_ipc_t ipc, sc_rsrc_t resource,
+		       sc_irq_group_t group, uint32_t mask, bool enable);
+
+/*!
+ * This function returns the current interrupt status (regardless if
+ * masked). Automatically clears pending interrupts.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    MU channel
+ * @param[in]     group       groups the interrupts are in
+ * @param[in]     status      status of interrupts
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if group invalid
+ *
+ * The returned \a status may show interrupts pending that are
+ * currently masked.
+ */
+sc_err_t sc_irq_status(sc_ipc_t ipc, sc_rsrc_t resource,
+		       sc_irq_group_t group, uint32_t *status);
+
+#endif				/* _SC_IRQ_API_H */
+
+/**@}*/
diff --git a/include/soc/imx8/sc/svc/misc/api.h b/include/soc/imx8/sc/svc/misc/api.h
new file mode 100644
index 0000000..8923953
--- /dev/null
+++ b/include/soc/imx8/sc/svc/misc/api.h
@@ -0,0 +1,427 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing the public API for the System Controller (SC)
+ * Miscellaneous (MISC) function.
+ *
+ * @addtogroup MISC_SVC (SVC) Miscellaneous Service
+ *
+ * Module for the Miscellaneous (MISC) service.
+ *
+ * @{
+ */
+
+#ifndef _SC_MISC_API_H
+#define _SC_MISC_API_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+
+/* Defines */
+
+/*!
+ * @name Defines for type widths
+ */
+/*@{*/
+#define SC_MISC_DMA_GRP_W       5	/* Width of sc_misc_dma_group_t */
+/*@}*/
+
+/*! Max DMA channel priority group */
+#define SC_MISC_DMA_GRP_MAX     31
+
+/*!
+ * @name Defines for sc_misc_boot_status_t
+ */
+/*@{*/
+#define SC_MISC_BOOT_STATUS_SUCCESS     0	/* Success */
+#define SC_MISC_BOOT_STATUS_SECURITY    1	/* Security violation */
+/*@}*/
+
+/*!
+ * @name Defines for sc_misc_seco_auth_cmd_t
+ */
+/*@{*/
+#define SC_MISC_SECO_AUTH_SECO_FW       0	/* SECO Firmware */
+#define SC_MISC_SECO_AUTH_HDMI_TX_FW    1	/* HDMI TX Firmware */
+#define SC_MISC_SECO_AUTH_HDMI_RX_FW    2	/* HDMI RX Firmware */
+/*@}*/
+
+/*!
+ * @name Defines for sc_misc_temp_t
+ */
+/*@{*/
+#define SC_MISC_TEMP                    0	/* Temp sensor */
+#define SC_MISC_TEMP_HIGH               1	/* Temp high alarm */
+#define SC_MISC_TEMP_LOW                2	/* Temp low alarm */
+/*@}*/
+
+/*!
+ * @name Defines for sc_misc_seco_auth_cmd_t
+ */
+/*@{*/
+#define SC_MISC_AUTH_CONTAINER          0	/* Authenticate container */
+#define SC_MISC_VERIFY_IMAGE            1	/* Verify image */
+#define SC_MISC_REL_CONTAINER           2	/* Release container */
+/*@}*/
+
+/* Types */
+
+/*!
+ * This type is used to store a DMA channel priority group.
+ */
+typedef uint8_t sc_misc_dma_group_t;
+
+/*!
+ * This type is used report boot status.
+ */
+typedef uint8_t sc_misc_boot_status_t;
+
+/*!
+ * This type is used to issue SECO authenticate commands.
+ */
+typedef uint8_t sc_misc_seco_auth_cmd_t;
+
+/*!
+ * This type is used report boot status.
+ */
+typedef uint8_t sc_misc_temp_t;
+
+/* Functions */
+
+/*!
+ * @name Control Functions
+ * @{
+ */
+
+/*!
+ * This function sets a miscellaneous control value.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource the control is associated with
+ * @param[in]     ctrl        control to change
+ * @param[in]     val         value to apply to the control
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner or parent
+ *   of the owner
+ *
+ * Refer to the [Control List](@ref CONTROLS) for valid control values.
+ */
+sc_err_t sc_misc_set_control(sc_ipc_t ipc, sc_rsrc_t resource,
+			     sc_ctrl_t ctrl, uint32_t val);
+
+/*!
+ * This function gets a miscellaneous control value.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource the control is associated with
+ * @param[in]     ctrl        control to get
+ * @param[out]    val         pointer to return the control value
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner or parent
+ *   of the owner
+ *
+ * Refer to the [Control List](@ref CONTROLS) for valid control values.
+ */
+sc_err_t sc_misc_get_control(sc_ipc_t ipc, sc_rsrc_t resource,
+			     sc_ctrl_t ctrl, uint32_t *val);
+
+/* @} */
+
+/*!
+ * @name DMA Functions
+ * @{
+ */
+
+/*!
+ * This function configures the max DMA channel priority group for a
+ * partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to assign \a max
+ * @param[in]     max         max priority group (0-31)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent
+ *   of the affected partition
+ *
+ * Valid \a max range is 0-31 with 0 being the lowest and 31 the highest.
+ * Default is the max priority group for the parent partition of \a pt.
+ */
+sc_err_t sc_misc_set_max_dma_group(sc_ipc_t ipc, sc_rm_pt_t pt,
+				   sc_misc_dma_group_t max);
+
+/*!
+ * This function configures the priority group for a DMA channel.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    DMA channel resource
+ * @param[in]     group       priority group (0-31)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the owner or parent
+ *   of the owner of the DMA channel
+ *
+ * Valid \a group range is 0-31 with 0 being the lowest and 31 the highest.
+ * The max value of \a group is limited by the partition max set using
+ * sc_misc_set_max_dma_group().
+ */
+sc_err_t sc_misc_set_dma_group(sc_ipc_t ipc, sc_rsrc_t resource,
+			       sc_misc_dma_group_t group);
+
+/* @} */
+
+/*!
+ * @name Security Functions
+ * @{
+ */
+
+/*!
+ * This function loads a SECO image.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr_src    address of image source
+ * @param[in]     addr_dst    address of image destination
+ * @param[in]     len         lenth of image to load
+ * @param[in]     fw          true = firmware load
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * This is used to load images via the SECO. Examples include SECO
+ * Firmware and IVT/CSF data used for authentication. These are usually
+ * loaded into SECO TCM. \a addr_src is in secure memory.
+ */
+sc_err_t sc_misc_seco_image_load(sc_ipc_t ipc, uint32_t addr_src,
+				 uint32_t addr_dst, uint32_t len, bool fw);
+
+/*!
+ * This function is used to authenticate a SECO image or command.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     cmd         authenticate command
+ * @param[in]     addr_meta   address of/or metadata
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * This is used to authenticate a SECO image or issue a security
+ * command. \a addr_meta often points to an container. It is also
+ * just data (or even unused) for some commands.
+ */
+sc_err_t sc_misc_seco_authenticate(sc_ipc_t ipc,
+				   sc_misc_seco_auth_cmd_t cmd,
+				   uint32_t addr_meta);
+
+/* @} */
+
+/*!
+ * @name Debug Functions
+ * @{
+ */
+
+/*!
+ * This function is used output a debug character from the SCU UART.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     ch          character to output
+ */
+void sc_misc_debug_out(sc_ipc_t ipc, uint8_t ch);
+
+/*!
+ * This function starts/stops emulation waveform capture.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     enable      flag to enable/disable capture
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_UNAVAILABLE if not running on emulation
+ */
+sc_err_t sc_misc_waveform_capture(sc_ipc_t ipc, bool enable);
+
+/*!
+ * This function is used to return the SCFW build info.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    build       pointer to return build number
+ * @param[out]    commit      pointer to return commit ID (git SHA-1)
+ */
+void sc_misc_build_info(sc_ipc_t ipc, uint32_t *build, uint32_t *commit);
+
+/*!
+ * This function is used to return the device's unique ID.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    id_l        pointer to return lower 32-bit of ID [31:0]
+ * @param[out]    id_h        pointer to return upper 32-bits of ID [63:32]
+ */
+void sc_misc_unique_id(sc_ipc_t ipc, uint32_t *id_l, uint32_t *id_h);
+
+/* @} */
+
+/*!
+ * @name Other Functions
+ * @{
+ */
+
+/*!
+ * This function configures the ARI match value for PCIe/SATA resources.
+ *
+ * @param[in]     ipc          IPC handle
+ * @param[in]     resource     match resource
+ * @param[in]     resource_mst PCIe/SATA master to match
+ * @param[in]     ari          ARI to match
+ * @param[in]     enable       enable match or not
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the owner or parent
+ *   of the owner of the resource and translation
+ *
+ * For PCIe, the ARI is the 16-bit value that includes the bus number,
+ * device number, and function number. For SATA, this value includes the
+ * FISType and PM_Port.
+ */
+sc_err_t sc_misc_set_ari(sc_ipc_t ipc, sc_rsrc_t resource,
+			 sc_rsrc_t resource_mst, uint16_t ari, bool enable);
+
+/*!
+ * This function reports boot status.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     status      boot status
+ *
+ * This is used by SW partitions to report status of boot. This is
+ * normally used to report a boot failure.
+ */
+void sc_misc_boot_status(sc_ipc_t ipc, sc_misc_boot_status_t status);
+
+/*!
+ * This function tells the SCFW that a CPU is done booting.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     cpu         CPU that is done booting
+ *
+ * This is called by early booting CPUs to report they are done with
+ * initialization. After starting early CPUs, the SCFW halts the
+ * booting process until they are done. During this time, early
+ * CPUs can call the SCFW with lower latency as the SCFW is idle.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the CPU owner
+ */
+sc_err_t sc_misc_boot_done(sc_ipc_t ipc, sc_rsrc_t cpu);
+
+/*!
+ * This function reads a given fuse word index.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     word        fuse word index
+ * @param[out]    val         fuse read value
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if word fuse index param out of range or invalid
+ * - SC_ERR_NOACCESS if read operation failed
+ * - SC_ERR_LOCKED if read operation is locked
+ */
+sc_err_t sc_misc_otp_fuse_read(sc_ipc_t ipc, uint32_t word, uint32_t *val);
+
+/*!
+ * This function writes a given fuse word index.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     word        fuse word index
+ * @param[in]     val         fuse write value
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if word fuse index param out of range or invalid
+ * - SC_ERR_NOACCESS if write operation failed
+ * - SC_ERR_LOCKED if write operation is locked
+ */
+sc_err_t sc_misc_otp_fuse_write(sc_ipc_t ipc, uint32_t word, uint32_t val);
+
+/*!
+ * This function sets a temp sensor alarm.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource with sensor
+ * @param[in]     temp        alarm to set
+ * @param[in]     celsius     whole part of temp to set
+ * @param[in]     tenths      fractional part of temp to set
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if parameters invalid
+ */
+sc_err_t sc_misc_set_temp(sc_ipc_t ipc, sc_rsrc_t resource,
+			  sc_misc_temp_t temp, int16_t celsius, int8_t tenths);
+
+/*!
+ * This function gets a temp sensor value.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource with sensor
+ * @param[in]     temp        value to get (sensor or alarm)
+ * @param[out]    celsius     whole part of temp to get
+ * @param[out]    tenths      fractional part of temp to get
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if parameters invalid
+ */
+sc_err_t sc_misc_get_temp(sc_ipc_t ipc, sc_rsrc_t resource,
+			  sc_misc_temp_t temp, int16_t * celsius,
+			  int8_t * tenths);
+
+/*!
+ * This function returns the boot device.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    dev         pointer to return boot device
+ */
+void sc_misc_get_boot_dev(sc_ipc_t ipc, sc_rsrc_t *dev);
+
+/*!
+ * This function returns the current status of the ON/OFF button.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    status      pointer to return button status
+ */
+void sc_misc_get_button_status(sc_ipc_t ipc, bool *status);
+
+/* @} */
+
+#endif				/* _SC_MISC_API_H */
+
+/**@}*/
diff --git a/include/soc/imx8/sc/svc/pad/api.h b/include/soc/imx8/sc/svc/pad/api.h
new file mode 100644
index 0000000..27cb03e
--- /dev/null
+++ b/include/soc/imx8/sc/svc/pad/api.h
@@ -0,0 +1,565 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing the public API for the System Controller (SC)
+ * Pad Control (PAD) function.
+ *
+ * @addtogroup PAD_SVC (SVC) Pad Service
+ *
+ * Module for the Pad Control (PAD) service.
+ *
+ * @details
+ *
+ * Pad configuration is managed by SC firmware. The pad configuration
+ * features supported by the SC firmware include:
+ *
+ * - Configuring the mux, input/output connection, and low-power isolation
+     mode.
+ * - Configuring the technology-specific pad setting such as drive strength,
+ *   pullup/pulldown, etc.
+ * - Configuring compensation for pad groups with dual voltage capability.
+ *
+ * Pad functions fall into one of three categories. Generic functions are
+ * common to all SoCs and all process technologies. SoC functions are raw
+ * low-level functions. Technology-specific functions are specific to the
+ * process technology.
+ *
+ * The list of pads is SoC specific.  Refer to the SoC [Pad List](@ref PADS)
+ * for valid pad values. Note that all pads exist on a die but may or
+ * may not be brought out by the specific package.  Mapping of pads to
+ * package pins/balls is documented in the associated Data Sheet. Some pads
+ * may not be brought out because the part (die+package) is defeatured and
+ * some pads may connect to the substrate in the package.
+ *
+ * Some pads (SC_P_COMP_*) that can be specified are not individual pads
+ * but are in fact pad groups. These groups have additional configuration
+ * that can be done using the sc_pad_set_gp_28fdsoi_comp() function. More
+ * info on these can be found in the associated Reference Manual.
+ *
+ * Pads are managed as a resource by the Resource Manager (RM).  They have
+ * assigned owners and only the owners can configure the pads. Some of the
+ * pads are reserved for use by the SCFW itself and this can be overriden
+ * with the implementation of board_config_sc(). Additionally, pads may
+ * be assigned to various other partitions via SCD or via the implementation
+ * of board_system_config().
+ *
+ * @{
+ */
+
+#ifndef _SC_PAD_API_H
+#define _SC_PAD_API_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+
+/* Defines */
+
+/*!
+ * @name Defines for type widths
+ */
+/*@{*/
+#define SC_PAD_MUX_W            3	/* Width of mux parameter */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pad_config_t
+ */
+/*@{*/
+#define SC_PAD_CONFIG_NORMAL    0	/* Normal */
+#define SC_PAD_CONFIG_OD        1	/* Open Drain */
+#define SC_PAD_CONFIG_OD_IN     2	/* Open Drain and input */
+#define SC_PAD_CONFIG_OUT_IN    3	/* Output and input */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pad_iso_t
+ */
+/*@{*/
+#define SC_PAD_ISO_OFF          0	/* ISO latch is transparent */
+#define SC_PAD_ISO_EARLY        1	/* Follow EARLY_ISO */
+#define SC_PAD_ISO_LATE         2	/* Follow LATE_ISO */
+#define SC_PAD_ISO_ON           3	/* ISO latched data is held */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pad_28fdsoi_dse_t
+ */
+/*@{*/
+#define SC_PAD_28FDSOI_DSE_18V_1MA   0	/* Drive strength of 1mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_2MA   1	/* Drive strength of 2mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_4MA   2	/* Drive strength of 4mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_6MA   3	/* Drive strength of 6mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_8MA   4	/* Drive strength of 8mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_10MA  5	/* Drive strength of 10mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_12MA  6	/* Drive strength of 12mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_HS    7	/* High-speed drive strength for 1.8v */
+#define SC_PAD_28FDSOI_DSE_33V_2MA   0	/* Drive strength of 2mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_33V_4MA   1	/* Drive strength of 4mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_33V_8MA   2	/* Drive strength of 8mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_33V_12MA  3	/* Drive strength of 12mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_DV_HIGH   0	/* High drive strength for dual volt */
+#define SC_PAD_28FDSOI_DSE_DV_LOW    1	/* Low drive strength for dual volt */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pad_28fdsoi_ps_t
+ */
+/*@{*/
+#define SC_PAD_28FDSOI_PS_KEEPER 0	/* Bus-keeper (only valid for 1.8v) */
+#define SC_PAD_28FDSOI_PS_PU     1	/* Pull-up */
+#define SC_PAD_28FDSOI_PS_PD     2	/* Pull-down */
+#define SC_PAD_28FDSOI_PS_NONE   3	/* No pull (disabled) */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pad_28fdsoi_pus_t
+ */
+/*@{*/
+#define SC_PAD_28FDSOI_PUS_30K_PD  0	/* 30K pull-down */
+#define SC_PAD_28FDSOI_PUS_100K_PU 1	/* 100K pull-up */
+#define SC_PAD_28FDSOI_PUS_3K_PU   2	/* 3K pull-up */
+#define SC_PAD_28FDSOI_PUS_30K_PU  3	/* 30K pull-up */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pad_wakeup_t
+ */
+/*@{*/
+#define SC_PAD_WAKEUP_OFF       0	/* Off */
+#define SC_PAD_WAKEUP_CLEAR     1	/* Clears pending flag */
+#define SC_PAD_WAKEUP_LOW_LVL   4	/* Low level */
+#define SC_PAD_WAKEUP_FALL_EDGE 5	/* Falling edge */
+#define SC_PAD_WAKEUP_RISE_EDGE 6	/* Rising edge */
+#define SC_PAD_WAKEUP_HIGH_LVL  7	/* High-level */
+/*@}*/
+
+/* Types */
+
+/*!
+ * This type is used to declare a pad config. It determines how the
+ * output data is driven, pull-up is controlled, and input signal is
+ * connected. Normal and OD are typical and only connect the input
+ * when the output is not driven.  The IN options are less common and
+ * force an input connection even when driving the output.
+ */
+typedef uint8_t sc_pad_config_t;
+
+/*!
+ * This type is used to declare a pad low-power isolation config.
+ * ISO_LATE is the most common setting. ISO_EARLY is only used when
+ * an output pad is directly determined by another input pad. The
+ * other two are only used when SW wants to directly contol isolation.
+ */
+typedef uint8_t sc_pad_iso_t;
+
+/*!
+ * This type is used to declare a drive strength. Note it is specific
+ * to 28FDSOI. Also note that valid values depend on the pad type.
+ */
+typedef uint8_t sc_pad_28fdsoi_dse_t;
+
+/*!
+ * This type is used to declare a pull select. Note it is specific
+ * to 28FDSOI.
+ */
+typedef uint8_t sc_pad_28fdsoi_ps_t;
+
+/*!
+ * This type is used to declare a pull-up select. Note it is specific
+ * to 28FDSOI HSIC pads.
+ */
+typedef uint8_t sc_pad_28fdsoi_pus_t;
+
+/*!
+ * This type is used to declare a wakeup mode of a pad.
+ */
+typedef uint8_t sc_pad_wakeup_t;
+
+/* Functions */
+
+/*!
+ * @name Generic Functions
+ * @{
+ */
+
+/*!
+ * This function configures the mux settings for a pad. This includes
+ * the signal mux, pad config, and low-power isolation mode.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     mux         mux setting
+ * @param[in]     config      pad config
+ * @param[in]     iso         low-power isolation mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set_mux(sc_ipc_t ipc, sc_pad_t pad,
+			uint8_t mux, sc_pad_config_t config, sc_pad_iso_t iso);
+
+/*!
+ * This function gets the mux settings for a pad. This includes
+ * the signal mux, pad config, and low-power isolation mode.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    mux         pointer to return mux setting
+ * @param[out]    config      pointer to return pad config
+ * @param[out]    iso         pointer to return low-power isolation mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_mux(sc_ipc_t ipc, sc_pad_t pad,
+			uint8_t *mux, sc_pad_config_t *config,
+			sc_pad_iso_t *iso);
+
+/*!
+ * This function configures the general purpose pad control. This
+ * is technology dependent and includes things like drive strength,
+ * slew rate, pull up/down, etc. Refer to the SoC Reference Manual
+ * for bit field details.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     ctrl        control value to set
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set_gp(sc_ipc_t ipc, sc_pad_t pad, uint32_t ctrl);
+
+/*!
+ * This function gets the general purpose pad control. This
+ * is technology dependent and includes things like drive strength,
+ * slew rate, pull up/down, etc. Refer to the SoC Reference Manual
+ * for bit field details.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    ctrl        pointer to return control value
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_gp(sc_ipc_t ipc, sc_pad_t pad, uint32_t *ctrl);
+
+/*!
+ * This function configures the wakeup mode of the pad.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     wakeup      wakeup to set
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set_wakeup(sc_ipc_t ipc, sc_pad_t pad, sc_pad_wakeup_t wakeup);
+
+/*!
+ * This function gets the wakeup mode of a pad.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    wakeup      pointer to return wakeup
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_wakeup(sc_ipc_t ipc, sc_pad_t pad, sc_pad_wakeup_t *wakeup);
+
+/*!
+ * This function configures a pad.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     mux         mux setting
+ * @param[in]     config      pad config
+ * @param[in]     iso         low-power isolation mode
+ * @param[in]     ctrl        control value
+ * @param[in]     wakeup      wakeup to set
+ *
+ * @see sc_pad_set_mux().
+ * @see sc_pad_set_gp().
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t mux,
+			sc_pad_config_t config, sc_pad_iso_t iso, uint32_t ctrl,
+			sc_pad_wakeup_t wakeup);
+
+/*!
+ * This function gets a pad's config.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    mux         pointer to return mux setting
+ * @param[out]    config      pointer to return pad config
+ * @param[out]    iso         pointer to return low-power isolation mode
+ * @param[out]    ctrl        pointer to return control value
+ * @param[out]    wakeup      pointer to return wakeup to set
+ *
+ * @see sc_pad_set_mux().
+ * @see sc_pad_set_gp().
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t *mux,
+			sc_pad_config_t *config, sc_pad_iso_t *iso,
+			uint32_t *ctrl, sc_pad_wakeup_t *wakeup);
+
+/* @} */
+
+/*!
+ * @name SoC Specific Functions
+ * @{
+ */
+
+/*!
+ * This function configures the settings for a pad. This setting is SoC
+ * specific.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     val         value to set
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set(sc_ipc_t ipc, sc_pad_t pad, uint32_t val);
+
+/*!
+ * This function gets the settings for a pad. This setting is SoC
+ * specific.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    val         pointer to return setting
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get(sc_ipc_t ipc, sc_pad_t pad, uint32_t *val);
+
+/* @} */
+
+/*!
+ * @name Technology Specific Functions
+ * @{
+ */
+
+/*!
+ * This function configures the pad control specific to 28FDSOI.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     dse         drive strength
+ * @param[in]     ps          pull select
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner,
+ * - SC_ERR_UNAVAILABLE if process not applicable
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
+			       sc_pad_28fdsoi_dse_t dse,
+			       sc_pad_28fdsoi_ps_t ps);
+
+/*!
+ * This function gets the pad control specific to 28FDSOI.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    dse         pointer to return drive strength
+ * @param[out]    ps          pointer to return pull select
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner,
+ * - SC_ERR_UNAVAILABLE if process not applicable
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
+			       sc_pad_28fdsoi_dse_t *dse,
+			       sc_pad_28fdsoi_ps_t *ps);
+
+/*!
+ * This function configures the pad control specific to 28FDSOI.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     dse         drive strength
+ * @param[in]     hys         hysteresis
+ * @param[in]     pus         pull-up select
+ * @param[in]     pke         pull keeper enable
+ * @param[in]     pue         pull-up enable
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner,
+ * - SC_ERR_UNAVAILABLE if process not applicable
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_set_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
+				    sc_pad_28fdsoi_dse_t dse, bool hys,
+				    sc_pad_28fdsoi_pus_t pus, bool pke,
+				    bool pue);
+
+/*!
+ * This function gets the pad control specific to 28FDSOI.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    dse         pointer to return drive strength
+ * @param[out]    hys         pointer to return hysteresis
+ * @param[out]    pus         pointer to return pull-up select
+ * @param[out]    pke         pointer to return pull keeper enable
+ * @param[out]    pue         pointer to return pull-up enable
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner,
+ * - SC_ERR_UNAVAILABLE if process not applicable
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
+				    sc_pad_28fdsoi_dse_t *dse, bool *hys,
+				    sc_pad_28fdsoi_pus_t *pus, bool *pke,
+				    bool *pue);
+
+/*!
+ * This function configures the compensation control specific to 28FDSOI.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to configure
+ * @param[in]     compen      compensation/freeze mode
+ * @param[in]     fastfrz     fast freeze
+ * @param[in]     rasrcp      compensation code for PMOS
+ * @param[in]     rasrcn      compensation code for NMOS
+ * @param[in]     nasrc_sel   NASRC read select
+ * @param[in]     psw_ovr     2.5v override
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner,
+ * - SC_ERR_UNAVAILABLE if process not applicable
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ *
+ * Note \a psw_ovr is only applicable to pads supporting 2.5 volt
+ * operation (e.g. some Ethernet pads).
+ */
+sc_err_t sc_pad_set_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
+				    uint8_t compen, bool fastfrz,
+				    uint8_t rasrcp, uint8_t rasrcn,
+				    bool nasrc_sel, bool psw_ovr);
+
+/*!
+ * This function gets the compensation control specific to 28FDSOI.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to query
+ * @param[out]    compen      pointer to return compensation/freeze mode
+ * @param[out]    fastfrz     pointer to return fast freeze
+ * @param[out]    rasrcp      pointer to return compensation code for PMOS
+ * @param[out]    rasrcn      pointer to return compensation code for NMOS
+ * @param[out]    nasrc_sel   pointer to return NASRC read select
+ * @param[out]    compok      pointer to return compensation status
+ * @param[out]    nasrc       pointer to return NASRCP/NASRCN
+ * @param[out]    psw_ovr     pointer to return the 2.5v override
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner,
+ * - SC_ERR_UNAVAILABLE if process not applicable
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+sc_err_t sc_pad_get_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
+				    uint8_t *compen, bool *fastfrz,
+				    uint8_t *rasrcp, uint8_t *rasrcn,
+				    bool *nasrc_sel, bool *compok,
+				    uint8_t *nasrc, bool *psw_ovr);
+
+/* @} */
+
+#endif				/* _SC_PAD_API_H */
+
+/**@}*/
diff --git a/include/soc/imx8/sc/svc/pm/api.h b/include/soc/imx8/sc/svc/pm/api.h
new file mode 100644
index 0000000..ae49c5b
--- /dev/null
+++ b/include/soc/imx8/sc/svc/pm/api.h
@@ -0,0 +1,595 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing the public API for the System Controller (SC)
+ * Power Management (PM) function. This includes functions for power state
+ * control, clock control, reset control, and wake-up event control.
+ *
+ * @addtogroup PM_SVC (SVC) Power Management Service
+ *
+ * Module for the Power Management (PM) service.
+ *
+ * @{
+ */
+
+#ifndef _SC_PM_API_H
+#define _SC_PM_API_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+
+/* Defines */
+
+/*!
+ * @name Defines for type widths
+ */
+/*@{*/
+#define SC_PM_POWER_MODE_W      2	/* Width of sc_pm_power_mode_t */
+#define SC_PM_CLOCK_MODE_W      3	/* Width of sc_pm_clock_mode_t */
+#define SC_PM_RESET_TYPE_W      2	/* Width of sc_pm_reset_type_t */
+#define SC_PM_RESET_REASON_W    3	/* Width of sc_pm_reset_reason_t */
+/*@}*/
+
+/*!
+ * @name Defines for clock indexes (sc_pm_clk_t)
+ */
+/*@{*/
+/*@}*/
+
+/*!
+ * @name Defines for ALL parameters
+ */
+/*@{*/
+#define SC_PM_CLK_ALL   UINT8_MAX	/* All clocks */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_power_mode_t
+ */
+/*@{*/
+#define SC_PM_PW_MODE_OFF       0	/* Power off */
+#define SC_PM_PW_MODE_STBY      1	/* Power in standby */
+#define SC_PM_PW_MODE_LP        2	/* Power in low-power */
+#define SC_PM_PW_MODE_ON        3	/* Power on */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_clk_t
+ */
+/*@{*/
+#define SC_PM_CLK_SLV_BUS       0	/* Slave bus clock */
+#define SC_PM_CLK_MST_BUS       1	/* Master bus clock */
+#define SC_PM_CLK_PER           2	/* Peripheral clock */
+#define SC_PM_CLK_PHY           3	/* Phy clock */
+#define SC_PM_CLK_MISC          4	/* Misc clock */
+#define SC_PM_CLK_MISC0         0	/* Misc 0 clock */
+#define SC_PM_CLK_MISC1         1	/* Misc 1 clock */
+#define SC_PM_CLK_MISC2         2	/* Misc 2 clock */
+#define SC_PM_CLK_MISC3         3	/* Misc 3 clock */
+#define SC_PM_CLK_MISC4         4	/* Misc 4 clock */
+#define SC_PM_CLK_CPU           2	/* CPU clock */
+#define SC_PM_CLK_PLL           4	/* PLL */
+#define SC_PM_CLK_BYPASS        4	/* Bypass clock */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_clk_mode_t
+ */
+/*@{*/
+#define SC_PM_CLK_MODE_ROM_INIT        0	/* Clock is initialized by ROM. */
+#define SC_PM_CLK_MODE_OFF             1	/* Clock is disabled */
+#define SC_PM_CLK_MODE_ON              2	/* Clock is enabled. */
+#define SC_PM_CLK_MODE_AUTOGATE_SW     3	/* Clock is in SW autogate mode */
+#define SC_PM_CLK_MODE_AUTOGATE_HW     4	/* Clock is in HW autogate mode */
+#define SC_PM_CLK_MODE_AUTOGATE_SW_HW  5	/* Clock is in SW-HW autogate mode */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_clk_parent_t
+ */
+/*@{*/
+#define SC_PM_PARENT_XTAL              0	/* Parent is XTAL. */
+#define SC_PM_PARENT_PLL0              1	/* Parent is PLL0 */
+#define SC_PM_PARENT_PLL1              2	/* Parent is PLL1 or PLL0/2 */
+#define SC_PM_PARENT_PLL2              3	/* Parent in PLL2 or PLL0/4 */
+#define SC_PM_PARENT_BYPS              4	/* Parent is a bypass clock. */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_reset_type_t
+ */
+/*@{*/
+#define SC_PM_RESET_TYPE_COLD          0	/* Cold reset */
+#define SC_PM_RESET_TYPE_WARM          1	/* Warm reset */
+#define SC_PM_RESET_TYPE_BOARD         2	/* Board reset */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_reset_reason_t
+ */
+/*@{*/
+#define SC_PM_RESET_REASON_POR         0	/* Power on reset */
+#define SC_PM_RESET_REASON_WARM        1	/* Warm reset */
+#define SC_PM_RESET_REASON_SW          2	/* Software reset */
+#define SC_PM_RESET_REASON_WDOG        3	/* Watchdog reset */
+#define SC_PM_RESET_REASON_LOCKUP      4	/* Lockup reset */
+#define SC_PM_RESET_REASON_TAMPER      5	/* Tamper reset */
+#define SC_PM_RESET_REASON_TEMP        6	/* Temp reset */
+#define SC_PM_RESET_REASON_LOW_VOLT    7	/* Low voltage reset */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_sys_if_t
+ */
+/*@{*/
+#define SC_PM_SYS_IF_INTERCONNECT       0	/* System interconnect */
+#define SC_PM_SYS_IF_MU                 1	/* AP -> SCU message units */
+#define SC_PM_SYS_IF_OCMEM              2	/* On-chip memory (ROM/OCRAM) */
+#define SC_PM_SYS_IF_DDR                3	/* DDR memory */
+/*@}*/
+
+/* Types */
+
+/*!
+ * This type is used to declare a power mode. Note resources only use
+ * SC_PM_PW_MODE_OFF and SC_PM_PW_MODE_ON. The other modes are used only
+ * as system power modes.
+ */
+typedef uint8_t sc_pm_power_mode_t;
+
+/*!
+ * This type is used to declare a clock.
+ */
+typedef uint8_t sc_pm_clk_t;
+
+/*!
+ * This type is used to declare a clock mode.
+ */
+typedef uint8_t sc_pm_clk_mode_t;
+
+/*!
+ * This type is used to declare the clock parent.
+ */
+typedef uint8_t sc_pm_clk_parent_t;
+
+/*!
+ * This type is used to declare clock rates.
+ */
+typedef uint32_t sc_pm_clock_rate_t;
+
+/*!
+ * This type is used to declare a desired reset type.
+ */
+typedef uint8_t sc_pm_reset_type_t;
+
+/*!
+ * This type is used to declare a reason for a reset.
+ */
+typedef uint8_t sc_pm_reset_reason_t;
+
+/*!
+ * This type is used to specify a system-level interface to be power managed.
+ */
+typedef uint8_t sc_pm_sys_if_t;
+
+/* Functions */
+
+/*!
+ * @name Power Functions
+ * @{
+ */
+
+/*!
+ * This function sets the system power mode. Only the owner of the
+ * SC_R_SYSTEM resource can do this.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mode        power mode to apply
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid mode,
+ * - SC_ERR_NOACCESS if caller not the owner of SC_R_SYSTEM
+ *
+ * @see sc_pm_set_sys_power_mode().
+ */
+sc_err_t sc_pm_set_sys_power_mode(sc_ipc_t ipc, sc_pm_power_mode_t mode);
+
+/*!
+ * This function sets the power mode of a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition
+ * @param[in]     mode        power mode to apply
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid partition or mode,
+ * - SC_ERR_NOACCESS if caller's partition is not the owner or
+ *   parent of \a pt
+ *
+ * All resources owned by \a pt that are on will have their power
+ * mode changed to \a mode.
+ *
+ * @see sc_pm_set_resource_power_mode().
+ */
+sc_err_t sc_pm_set_partition_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
+					sc_pm_power_mode_t mode);
+
+/*!
+ * This function gets the power mode of a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition
+ * @param[out]    mode        pointer to return power mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid partition
+ */
+sc_err_t sc_pm_get_sys_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
+				  sc_pm_power_mode_t *mode);
+
+/*!
+ * This function sets the power mode of a resource.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     mode        power mode to apply
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or mode,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner
+ *   or parent of the owner
+ *
+ * Resources set to SC_PM_PW_MODE_ON will reflect the
+ * power mode of the partition and will change as that changes.
+ *
+ * Note some resources are still not accessible even when powered up if bus
+ * transactions go through a fabric not powered up. Examples of this are
+ * resources in display and capture subsystems which require the display
+ * controller or the imaging subsytem to be powered up first.
+ *
+ *  @see sc_pm_set_partition_power_mode().
+ */
+sc_err_t sc_pm_set_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				       sc_pm_power_mode_t mode);
+
+/*!
+ * This function gets the power mode of a resource.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[out]    mode        pointer to return power mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Note only SC_PM_PW_MODE_OFF and SC_PM_PW_MODE_ON are valid. The value
+ * returned does not reflect the power mode of the partition..
+ */
+sc_err_t sc_pm_get_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				       sc_pm_power_mode_t *mode);
+
+/*!
+ * This function requests the low power mode some of the resources
+ * can enter based on their state. This API is only valid for the
+ * following resources : SC_R_A53, SC_R_A53_0, SC_R_A53_1, SC_A53_2,
+ * SC_A53_3, SC_R_A72, SC_R_A72_0, SC_R_A72_1, SC_R_CC1, SC_R_A35,
+ * SC_R_A35_0, SC_R_A35_1, SC_R_A35_2, SC_R_A35_3.
+ * For all other resources it will return SC_ERR_PARAM.
+ * This function will set the low power mode the cores, cluster
+ * and cluster associated resources will enter when all the cores
+ * in a given cluster execute WFI
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[out]    mode        pointer to return power mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ */
+sc_err_t sc_pm_req_low_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				  sc_pm_power_mode_t mode);
+
+/*!
+ * This function is used to set the resume address of a CPU.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the CPU resource
+ * @param[in]     address     64-bit resume address
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or address,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of the
+ *   resource (CPU) owner
+ */
+sc_err_t sc_pm_set_cpu_resume_addr(sc_ipc_t ipc, sc_rsrc_t resource,
+				   sc_faddr_t address);
+
+/*!
+ * This function requests the power mode configuration for system-level
+ * interfaces including messaging units, interconnect, and memories.  This API
+ * is only valid for the following resources : SC_R_A53, SC_R_A72, and
+ * SC_R_M4_x_PID_y.  For all other resources, it will return SC_ERR_PARAM.
+ * The requested power mode will be captured and applied to system-level
+ * resources as system conditions allow.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     sys_if      system-level interface to be configured
+ * @param[in]     hpm         high-power mode for the system interface
+ * @param[in]     lpm         low-power mode for the system interface
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ */
+sc_err_t sc_pm_req_sys_if_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				     sc_pm_sys_if_t sys_if,
+				     sc_pm_power_mode_t hpm,
+				     sc_pm_power_mode_t lpm);
+
+/* @} */
+
+/*!
+ * @name Clock/PLL Functions
+ * @{
+ */
+
+/*!
+ * This function sets the rate of a resource's clock/PLL.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     clk         clock/PLL to affect
+ * @param[in,out] rate        pointer to rate to set,
+ *                            return actual rate
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or clock/PLL,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner
+ *   or parent of the owner,
+ * - SC_ERR_UNAVAILABLE if clock/PLL not applicable to this resource,
+ * - SC_ERR_LOCKED if rate locked (usually because shared clock/PLL)
+ *
+ * Refer to the [Clock List](@ref CLOCKS) for valid clock/PLL values.
+ */
+sc_err_t sc_pm_set_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_pm_clk_t clk, sc_pm_clock_rate_t *rate);
+
+/*!
+ * This function gets the rate of a resource's clock/PLL.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     clk         clock/PLL to affect
+ * @param[out]    rate        pointer to return rate
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or clock/PLL,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner
+ *   or parent of the owner,
+ * - SC_ERR_UNAVAILABLE if clock/PLL not applicable to this resource
+ *
+ * Refer to the [Clock List](@ref CLOCKS) for valid clock/PLL values.
+ */
+sc_err_t sc_pm_get_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_pm_clk_t clk, sc_pm_clock_rate_t *rate);
+
+/*!
+ * This function enables/disables a resource's clock.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     clk         clock to affect
+ * @param[in]     enable      enable if true; otherwise disabled
+ * @param[in]     autog       HW auto clock gating
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or clock,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner
+ *   or parent of the owner,
+ * - SC_ERR_UNAVAILABLE if clock not applicable to this resource
+ *
+ * Refer to the [Clock List](@ref CLOCKS) for valid clock values.
+ */
+sc_err_t sc_pm_clock_enable(sc_ipc_t ipc, sc_rsrc_t resource,
+			    sc_pm_clk_t clk, bool enable, bool autog);
+
+/*!
+ * This function sets the parent of a resource's clock.
+ * This function should only be called when the clock is disabled.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     clk         clock to affect
+ * @param[in]     parent      New parent of the clock.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or clock,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner
+ *   or parent of the owner,
+ * - SC_ERR_UNAVAILABLE if clock not applicable to this resource
+ * - SC_ERR_BUSY if clock is currently enabled.
+ *
+ * Refer to the [Clock List](@ref CLOCKS) for valid clock values.
+ */
+sc_err_t sc_pm_set_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
+				sc_pm_clk_t clk, sc_pm_clk_parent_t parent);
+
+/*!
+ * This function gets the parent of a resource's clock.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     clk         clock to affect
+ * @param[out]     parent     pointer to return parent of clock.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or clock,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner
+ *   or parent of the owner,
+ * - SC_ERR_UNAVAILABLE if clock not applicable to this resource
+ *
+ * Refer to the [Clock List](@ref CLOCKS) for valid clock values.
+ */
+sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
+				sc_pm_clk_t clk, sc_pm_clk_parent_t * parent);
+
+/* @} */
+
+/*!
+ * @name Reset Functions
+ * @{
+ */
+
+/*!
+ * This function is used to reset the system. Only the owner of the
+ * SC_R_SYSTEM resource can do this.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     type        reset type
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid type,
+ * - SC_ERR_NOACCESS if caller not the owner of SC_R_SYSTEM
+ *
+ * If this function returns, then the reset did not occur due to an
+ * invalid parameter.
+ */
+sc_err_t sc_pm_reset(sc_ipc_t ipc, sc_pm_reset_type_t type);
+
+/*!
+ * This function gets a caller's reset reason.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    reason      pointer to return reset reason
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_pm_reset_reason(sc_ipc_t ipc, sc_pm_reset_reason_t *reason);
+
+/*!
+ * This function is used to boot a partition.
+ *
+ * @param[in]     ipc          IPC handle
+ * @param[in]     pt           handle of partition to boot
+ * @param[in]     resource_cpu ID of the CPU resource to start
+ * @param[in]     boot_addr    64-bit boot address
+ * @param[in]     resource_mu  ID of the MU that must be powered
+ * @param[in]     resource_dev ID of the boot device that must be powered
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid partition, resource, or addr,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of the
+ *   partition to boot
+ */
+sc_err_t sc_pm_boot(sc_ipc_t ipc, sc_rm_pt_t pt,
+		    sc_rsrc_t resource_cpu, sc_faddr_t boot_addr,
+		    sc_rsrc_t resource_mu, sc_rsrc_t resource_dev);
+
+/*!
+ * This function is used to reboot the caller's partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     type        reset type
+ *
+ * If \a type is SC_PM_RESET_TYPE_COLD, then most peripherals owned by
+ * the calling partition will be reset if possible. SC state (partitions,
+ * power, clocks, etc.) is reset. The boot SW of the booting CPU must be
+ * able to handle peripherals that that are not reset.
+ *
+ * If \a type is SC_PM_RESET_TYPE_WARM, then only the boot CPU is reset.
+ * SC state (partitions, power, clocks, etc.) are NOT reset. The boot SW
+ * of the booting CPU must be able to handle peripherals and SC state that
+ * that are not reset.
+ *
+ * If \a type is SC_PM_RESET_TYPE_BOARD, then return with no action.
+ *
+ * If this function returns, then the reset did not occur due to an
+ * invalid parameter.
+ */
+void sc_pm_reboot(sc_ipc_t ipc, sc_pm_reset_type_t type);
+
+/*!
+ * This function is used to reboot a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to reboot
+ * @param[in]     type        reset type
+ *
+ * If \a type is SC_PM_RESET_TYPE_COLD, then most peripherals owned by
+ * the calling partition will be reset if possible. SC state (partitions,
+ * power, clocks, etc.) is reset. The boot SW of the booting CPU must be
+ * able to handle peripherals that that are not reset.
+ *
+ * If \a type is SC_PM_RESET_TYPE_WARM, then only the boot CPU is reset.
+ * SC state (partitions, power, clocks, etc.) are NOT reset. The boot SW
+ * of the booting CPU must be able to handle peripherals and SC state that
+ * that are not reset.
+ *
+ * If \a type is SC_PM_RESET_TYPE_BOARD, then return with no action.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid partition or type
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt,
+ *
+ * Most peripherals owned by the partition will be reset if
+ * possible. SC state (partitions, power, clocks, etc.) is reset. The
+ * boot SW of the booting CPU must be able to handle peripherals that
+ * that are not reset.
+ */
+sc_err_t sc_pm_reboot_partition(sc_ipc_t ipc, sc_rm_pt_t pt,
+				sc_pm_reset_type_t type);
+
+/*!
+ * This function is used to start/stop a CPU.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the CPU resource
+ * @param[in]     enable      start if true; otherwise stop
+ * @param[in]     address     64-bit boot address
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or address,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of the
+ *   resource (CPU) owner
+ */
+sc_err_t sc_pm_cpu_start(sc_ipc_t ipc, sc_rsrc_t resource, bool enable,
+			 sc_faddr_t address);
+
+/* @} */
+
+#endif				/* _SC_PM_API_H */
+
+/**@}*/
diff --git a/include/soc/imx8/sc/svc/rm/api.h b/include/soc/imx8/sc/svc/rm/api.h
new file mode 100644
index 0000000..1b798fe
--- /dev/null
+++ b/include/soc/imx8/sc/svc/rm/api.h
@@ -0,0 +1,758 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing the public API for the System Controller (SC)
+ * Resource Management (RM) function. This includes functions for
+ * partitioning resources, pads, and memory regions.
+ *
+ * @addtogroup RM_SVC (SVC) Resource Management Service
+ *
+ * Module for the Resource Management (RM) service.
+ *
+ * @includedoc rm/details.dox
+ *
+ * @{
+ */
+
+#ifndef _SC_RM_API_H
+#define _SC_RM_API_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+
+/* Defines */
+
+/*!
+ * @name Defines for type widths
+ */
+/*@{*/
+#define SC_RM_PARTITION_W   5	/* Width of sc_rm_pt_t */
+#define SC_RM_MEMREG_W      6	/* Width of sc_rm_mr_t */
+#define SC_RM_DID_W         4	/* Width of sc_rm_did_t */
+#define SC_RM_SID_W         6	/* Width of sc_rm_sid_t */
+#define SC_RM_SPA_W         2	/* Width of sc_rm_spa_t */
+#define SC_RM_PERM_W        3	/* Width of sc_rm_perm_t */
+/*@}*/
+
+/*!
+ * @name Defines for ALL parameters
+ */
+/*@{*/
+#define SC_RM_PT_ALL        UINT8_MAX	/* All partitions */
+#define SC_RM_MR_ALL        UINT8_MAX	/* All memory regions */
+/*@}*/
+
+/*!
+ * @name Defines for sc_rm_spa_t
+ */
+/*@{*/
+#define SC_RM_SPA_PASSTHRU  0	/* Pass through (attribute driven by master) */
+#define SC_RM_SPA_PASSSID   1	/* Pass through and output on SID */
+#define SC_RM_SPA_ASSERT    2	/* Assert (force to be secure/privileged) */
+#define SC_RM_SPA_NEGATE    3	/* Negate (force to be non-secure/user) */
+/*@}*/
+
+/*!
+ * @name Defines for sc_rm_perm_t
+ */
+/*@{*/
+#define SC_RM_PERM_NONE         0	/* No access */
+#define SC_RM_PERM_SEC_R        1	/* Secure RO */
+#define SC_RM_PERM_SECPRIV_RW   2	/* Secure privilege R/W */
+#define SC_RM_PERM_SEC_RW       3	/* Secure R/W */
+#define SC_RM_PERM_NSPRIV_R     4	/* Secure R/W, non-secure privilege RO */
+#define SC_RM_PERM_NS_R         5	/* Secure R/W, non-secure RO */
+#define SC_RM_PERM_NSPRIV_RW    6	/* Secure R/W, non-secure privilege R/W */
+#define SC_RM_PERM_FULL         7	/* Full access */
+/*@}*/
+
+/* Types */
+
+/*!
+ * This type is used to declare a resource partition.
+ */
+typedef uint8_t sc_rm_pt_t;
+
+/*!
+ * This type is used to declare a memory region.
+ */
+typedef uint8_t sc_rm_mr_t;
+
+/*!
+ * This type is used to declare a resource domain ID used by the
+ * isolation HW.
+ */
+typedef uint8_t sc_rm_did_t;
+
+/*!
+ * This type is used to declare an SMMU StreamID.
+ */
+typedef uint16_t sc_rm_sid_t;
+
+/*!
+ * This type is a used to declare master transaction attributes.
+ */
+typedef uint8_t sc_rm_spa_t;
+
+/*!
+ * This type is used to declare a resource/memory region access permission.
+ * Refer to the XRDC2 Block Guide for more information.
+ */
+typedef uint8_t sc_rm_perm_t;
+
+/* Functions */
+
+/*!
+ * @name Partition Functions
+ * @{
+ */
+
+/*!
+ * This function requests that the SC create a new resource partition.
+ *
+ * @param[in]     ipc          IPC handle
+ * @param[out]    pt           return handle for partition; used for subsequent function
+ *                             calls associated with this partition
+ * @param[in]     secure       boolean indicating if this partition should be secure; only
+ *                             valid if caller is secure
+ * @param[in]     isolated     boolean indicating if this partition should be HW isolated
+ *                             via XRDC; set true if new DID is desired
+ * @param[in]     restricted   boolean indicating if this partition should be restricted; set
+ *                             true if masters in this partition cannot create new partitions
+ * @param[in]     grant        boolean indicating if this partition should always grant
+ *                             access and control to the parent
+ * @param[in]     coherent     boolean indicating if this partition is coherent;
+ *                             set true if only this partition will contain both AP clusters
+ *                             and they will be coherent via the CCI
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_ERR_PARM if caller's partition is not secure but a new secure partition is requested,
+ * - SC_ERR_LOCKED if caller's partition is locked,
+ * - SC_ERR_UNAVAILABLE if partition table is full (no more allocation space)
+ *
+ * Marking as non-secure prevents subsequent functions from configuring masters in this
+ * partition to assert the secure signal. If restricted then the new partition is limited
+ * in what functions it can call, especially those associated with managing partitions.
+ *
+ * The grant option is usually used to isolate a bus master's traffic to specific
+ * memory without isolating the peripheral interface of the master or the API
+ * controls of that master.
+ */
+sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, bool secure,
+			       bool isolated, bool restricted, bool grant,
+			       bool coherent);
+
+/*!
+ * This function makes a partition confidential.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition that is granting
+ * @param[in]     retro       retroactive
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if \a pt out of range,
+ * - SC_ERR_NOACCESS if caller's not allowed to change \a pt
+ * - SC_ERR_LOCKED if partition \a pt is locked
+ *
+ * Call to make a partition confidential. Confidential means only this
+ * partition should be able to grant access permissions to this partition.
+ *
+ * If retroactive, then all resources owned by other partitions will have
+ * access rights for this partition removed, even if locked.
+ */
+sc_err_t sc_rm_set_confidential(sc_ipc_t ipc, sc_rm_pt_t pt, bool retro);
+
+/*!
+ * This function frees a partition and assigns all resources to the caller.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to free
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if \a pt out of range or invalid,
+ * - SC_ERR_NOACCESS if \a pt is the SC partition,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt,
+ * - SC_ERR_LOCKED if \a pt or caller's partition is locked
+ *
+ * All resources, memory regions, and pads are assigned to the caller/parent.
+ * The partition watchdog is disabled (even if locked). DID is freed.
+ */
+sc_err_t sc_rm_partition_free(sc_ipc_t ipc, sc_rm_pt_t pt);
+
+/*!
+ * This function returns the DID of a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ *
+ * @return Returns the domain ID (DID) of the caller's partition.
+ *
+ * The DID is a SoC-specific internal ID used by the HW resource
+ * protection mechanism. It is only required by clients when using the
+ * SEMA42 module as the DID is sometimes connected to the master ID.
+ */
+sc_rm_did_t sc_rm_get_did(sc_ipc_t ipc);
+
+/*!
+ * This function forces a partition to use a specific static DID.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to assign \a did
+ * @param[in]     did         static DID to assign
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if \a pt or \a did out of range,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt,
+ * - SC_ERR_LOCKED if \a pt is locked
+ *
+ * Assumes no assigned resources or memory regions yet! The number of static
+ * DID is fixed by the SC at boot.
+ */
+sc_err_t sc_rm_partition_static(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_did_t did);
+
+/*!
+ * This function locks a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to lock
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if \a pt out of range,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt
+ *
+ * If a partition is locked it cannot be freed, have resources/pads assigned
+ * to/from it, memory regions created/assigned, DID changed, or parent changed.
+ */
+sc_err_t sc_rm_partition_lock(sc_ipc_t ipc, sc_rm_pt_t pt);
+
+/*!
+ * This function gets the partition handle of the caller.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    pt          return handle for caller's partition
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_rm_get_partition(sc_ipc_t ipc, sc_rm_pt_t *pt);
+
+/*!
+ * This function sets a new parent for a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition for which parent is to be
+ *                            changed
+ * @param[in]     pt_parent   handle of partition to set as parent
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt,
+ * - SC_ERR_LOCKED if either partition is locked
+ */
+sc_err_t sc_rm_set_parent(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_pt_t pt_parent);
+
+/*!
+ * This function moves all movable resources/pads owned by a source partition
+ * to a destination partition. It can be used to more quickly set up a new
+ * partition if a majority of the caller's resources are to be moved to a
+ * new partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt_src      handle of partition from which resources should
+ *                            be moved from
+ * @param[in]     pt_dst      handle of partition to which resources should be
+ *                            moved to
+ * @param[in]     move_rsrc   boolean to indicate if resources should be moved
+ * @param[in]     move_pads   boolean to indicate if pads should be moved
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * By default, all resources are movable. This can be changed using the
+ * sc_rm_set_resource_movable() function. Note all masters defaulted to SMMU
+ * bypass.
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not \a pt_src or the
+ *   parent of \a pt_src,
+ * - SC_ERR_LOCKED if either partition is locked
+ */
+sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
+			bool move_rsrc, bool move_pads);
+
+/* @} */
+
+/*!
+ * @name Resource Functions
+ * @{
+ */
+
+/*!
+ * This function assigns ownership of a resource to a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to which resource should be
+ *                            assigned
+ * @param[in]     resource    resource to assign
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * This action resets the resource's master and peripheral attributes.
+ * Privilege attribute will be PASSTHRU, security attribute will be
+ * ASSERT if the partition si secure and NEGATE if it is not, and
+ * masters will defaulted to SMMU bypass. Access permissions will reset
+ * to SEC_RW for the owning partition only for secure partitions, FULL for
+ * non-secure. DEfault is no access by other partitions.
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner or parent
+ *   of the owner,
+ * - SC_ERR_LOCKED if the owning partition or \a pt is locked
+ */
+sc_err_t sc_rm_assign_resource(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rsrc_t resource);
+
+/*!
+ * This function flags resources as movable or not.
+ *
+ * @param[in]     ipc          IPC handle
+ * @param[in]     resource_fst first resource for which flag should be set
+ * @param[in]     resource_lst last resource for which flag should be set
+ * @param[in]     movable      movable flag (true) is movable
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if resources are out of range,
+ * - SC_ERR_NOACCESS if caller's partition is not a parent of a resource owner,
+ * - SC_ERR_LOCKED if the owning partition is locked
+ *
+ * This function is used to determine the set of resources that will be
+ * moved using the sc_rm_move_all() function. All resources are movable
+ * by default so this function is normally used to prevent a set of
+ * resources from moving.
+ */
+sc_err_t sc_rm_set_resource_movable(sc_ipc_t ipc, sc_rsrc_t resource_fst,
+				    sc_rsrc_t resource_lst, bool movable);
+
+/*!
+ * This function flags all of a subsystem's resources as movable
+ * or not.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource to use to identify subsystem
+ * @param[in]     movable     movable flag (true) is movable
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if a function argument is out of range
+ *
+ * Note \a resource is used to find the associated subsystem. Only
+ * resources owned by the caller are set.
+ */
+sc_err_t sc_rm_set_subsys_rsrc_movable(sc_ipc_t ipc, sc_rsrc_t resource,
+				       bool movable);
+
+/*!
+ * This function sets attributes for a resource which is a bus master (i.e.
+ * capable of DMA).
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    master resource for which attributes should apply
+ * @param[in]     sa          security attribute
+ * @param[in]     pa          privilege attribute
+ * @param[in]     smmu_bypass SMMU bypass mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not a parent of the resource owner,
+ * - SC_ERR_LOCKED if the owning partition is locked
+ *
+ * This function configures how the HW isolation will see bus transactions
+ * from the specified master. Note the security attribute will only be
+ * changed if the caller's partition is secure.
+ */
+sc_err_t sc_rm_set_master_attributes(sc_ipc_t ipc, sc_rsrc_t resource,
+				     sc_rm_spa_t sa, sc_rm_spa_t pa,
+				     bool smmu_bypass);
+
+/*!
+ * This function sets the StreamID for a resource which is a bus master (i.e.
+ * capable of DMA).
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    master resource for which attributes should apply
+ * @param[in]     sid         StreamID
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner or parent
+ *   of the owner,
+ * - SC_ERR_LOCKED if the owning partition is locked
+ *
+ * This function configures the SID attribute associated with all bus transactions
+ * from this master. Note 0 is not a valid SID as it is reserved to indicate
+ * bypass.
+ */
+sc_err_t sc_rm_set_master_sid(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_rm_sid_t sid);
+
+/*!
+ * This function sets access permissions for a peripheral resource.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    peripheral resource for which permissions should apply
+ * @param[in]     pt          handle of partition \a perm should by applied for
+ * @param[in]     perm        permissions to apply to \a resource for \a pt
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the resource owner or parent
+ *   of the owner,
+ * - SC_ERR_LOCKED if the owning partition is locked
+ * - SC_ERR_LOCKED if the \a pt is confidential and the caller isn't \a pt
+ *
+ * This function configures how the HW isolation will restrict access to a
+ * peripheral based on the attributes of a transaction from bus master.
+ */
+sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
+					  sc_rm_pt_t pt, sc_rm_perm_t perm);
+
+/*!
+ * This function gets ownership status of a resource.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource to check
+ *
+ * @return Returns a boolean (true if caller's partition owns the resource).
+ *
+ * If \a resource is out of range then false is returned.
+ */
+bool sc_rm_is_resource_owned(sc_ipc_t ipc, sc_rsrc_t resource);
+
+/*!
+ * This function is used to test if a resource is a bus master.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource to check
+ *
+ * @return Returns a boolean (true if the resource is a bus master).
+ *
+ * If \a resource is out of range then false is returned.
+ */
+bool sc_rm_is_resource_master(sc_ipc_t ipc, sc_rsrc_t resource);
+
+/*!
+ * This function is used to test if a resource is a peripheral.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource to check
+ *
+ * @return Returns a boolean (true if the resource is a peripheral).
+ *
+ * If \a resource is out of range then false is returned.
+ */
+bool sc_rm_is_resource_peripheral(sc_ipc_t ipc, sc_rsrc_t resource);
+
+/*!
+ * This function is used to obtain info about a resource.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    resource to inquire about
+ * @param[out]    sid         pointer to return StreamID
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if \a resource is out of range
+ */
+sc_err_t sc_rm_get_resource_info(sc_ipc_t ipc, sc_rsrc_t resource,
+				 sc_rm_sid_t *sid);
+
+/* @} */
+
+/*!
+ * @name Memory Region Functions
+ * @{
+ */
+
+/*!
+ * This function requests that the SC create a new memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    mr          return handle for region; used for
+ *                            subsequent function calls
+ *                            associated with this region
+ * @param[in]     addr_start  start address of region (physical)
+ * @param[in]     addr_end    end address of region (physical)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if the new memory region is misaligned,
+ * - SC_ERR_LOCKED if caller's partition is locked,
+ * - SC_ERR_PARM if the new memory region spans multiple existing regions,
+ * - SC_ERR_NOACCESS if caller's partition does not own the memory containing
+ *   the new region,
+ * - SC_ERR_UNAVAILABLE if memory region table is full (no more allocation
+ *   space)
+ *
+ * The area covered by the memory region must currently be owned by the caller.
+ * By default, the new region will have access permission set to allow the
+ * caller to access.
+ */
+sc_err_t sc_rm_memreg_alloc(sc_ipc_t ipc, sc_rm_mr_t *mr,
+			    sc_faddr_t addr_start, sc_faddr_t addr_end);
+
+/*!
+ * This function requests that the SC split a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mr          handle of memory region to split
+ * @param[out]    mr_ret      return handle for new region; used for
+ *                            subsequent function calls
+ *                            associated with this region
+ * @param[in]     addr_start  start address of region (physical)
+ * @param[in]     addr_end    end address of region (physical)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if the new memory region is not start/end part of mr,
+ * - SC_ERR_LOCKED if caller's partition is locked,
+ * - SC_ERR_PARM if the new memory region spans multiple existing regions,
+ * - SC_ERR_NOACCESS if caller's partition does not own the memory containing
+ *   the new region,
+ * - SC_ERR_UNAVAILABLE if memory region table is full (no more allocation
+ *   space)
+ *
+ * Note the new region must start or end on the split region.
+ */
+sc_err_t sc_rm_memreg_split(sc_ipc_t ipc, sc_rm_mr_t mr,
+			    sc_rm_mr_t *mr_ret, sc_faddr_t addr_start,
+			    sc_faddr_t addr_end);
+
+/*!
+ * This function frees a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mr          handle of memory region to free
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if \a mr out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not a parent of \a mr,
+ * - SC_ERR_LOCKED if the owning partition of \a mr is locked
+ */
+sc_err_t sc_rm_memreg_free(sc_ipc_t ipc, sc_rm_mr_t mr);
+
+/*!
+ * Internal SC function to find a memory region.
+ *
+ * @see sc_rm_find_memreg().
+ */
+/*!
+ * This function finds a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    mr          return handle for region; used for
+ *                            subsequent function calls
+ *                            associated with this region
+ * @param[in]     addr_start  start address of region to search for
+ * @param[in]     addr_end    end address of region to search for
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOTFOUND if region not found,
+ *
+ * Searches only for regions owned by the caller. Finds first
+ * region containing the range specified.
+ */
+sc_err_t sc_rm_find_memreg(sc_ipc_t ipc, sc_rm_mr_t *mr,
+			   sc_faddr_t addr_start, sc_faddr_t addr_end);
+
+/*!
+ * This function assigns ownership of a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to which memory region
+ *                            should be assigned
+ * @param[in]     mr          handle of memory region to assign
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the \a mr owner or parent
+ *   of the owner,
+ * - SC_ERR_LOCKED if the owning partition or \a pt is locked
+ */
+sc_err_t sc_rm_assign_memreg(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_mr_t mr);
+
+/*!
+ * This function sets access permissions for a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mr          handle of memory region for which permissions
+ *                            should apply
+ * @param[in]     pt          handle of partition \a perm should by
+ *                            applied for
+ * @param[in]     perm        permissions to apply to \a mr for \a pt
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the region owner or parent
+ *   of the owner,
+ * - SC_ERR_LOCKED if the owning partition is locked
+ * - SC_ERR_LOCKED if the \a pt is confidential and the caller isn't \a pt
+ *
+ * This function configures how the HW isolation will restrict access to a
+ * memory region based on the attributes of a transaction from bus master.
+ */
+sc_err_t sc_rm_set_memreg_permissions(sc_ipc_t ipc, sc_rm_mr_t mr,
+				      sc_rm_pt_t pt, sc_rm_perm_t perm);
+
+/*!
+ * This function gets ownership status of a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mr          handle of memory region to check
+ *
+ * @return Returns a boolean (true if caller's partition owns the
+ * memory region).
+ *
+ * If \a mr is out of range then false is returned.
+ */
+bool sc_rm_is_memreg_owned(sc_ipc_t ipc, sc_rm_mr_t mr);
+
+/*!
+ * This function is used to obtain info about a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mr          handle of memory region to inquire about
+ * @param[out]    addr_start  pointer to return start address
+ * @param[out]    addr_end    pointer to return end address
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if \a mr is out of range
+ */
+sc_err_t sc_rm_get_memreg_info(sc_ipc_t ipc, sc_rm_mr_t mr,
+			       sc_faddr_t *addr_start, sc_faddr_t *addr_end);
+
+/* @} */
+
+/*!
+ * @name Pad Functions
+ * @{
+ */
+
+/*!
+ * This function assigns ownership of a pad to a partition.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          handle of partition to which pad should
+ *                            be assigned
+ * @param[in]     pad         pad to assign
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_NOACCESS if caller's partition is restricted,
+ * - SC_PARM if arguments out of range or invalid,
+ * - SC_ERR_NOACCESS if caller's partition is not the pad owner or parent
+ *   of the owner,
+ * - SC_ERR_LOCKED if the owning partition or \a pt is locked
+ */
+sc_err_t sc_rm_assign_pad(sc_ipc_t ipc, sc_rm_pt_t pt, sc_pad_t pad);
+
+/*!
+ * This function flags pads as movable or not.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad_fst     first pad for which flag should be set
+ * @param[in]     pad_lst     last pad for which flag should be set
+ * @param[in]     movable     movable flag (true) is movable
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_PARM if pads are out of range,
+ * - SC_ERR_NOACCESS if caller's partition is not a parent of a pad owner,
+ * - SC_ERR_LOCKED if the owning partition is locked
+ *
+ * This function is used to determine the set of pads that will be
+ * moved using the sc_rm_move_all() function. All pads are movable
+ * by default so this function is normally used to prevent a set of
+ * pads from moving.
+ */
+sc_err_t sc_rm_set_pad_movable(sc_ipc_t ipc, sc_pad_t pad_fst,
+			       sc_pad_t pad_lst, bool movable);
+
+/*!
+ * This function gets ownership status of a pad.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pad         pad to check
+ *
+ * @return Returns a boolean (true if caller's partition owns the pad).
+ *
+ * If \a pad is out of range then false is returned.
+ */
+bool sc_rm_is_pad_owned(sc_ipc_t ipc, sc_pad_t pad);
+
+/* @} */
+
+/*!
+ * @name Debug Functions
+ * @{
+ */
+
+/*!
+ * This function dumps the RM state for debug.
+ *
+ * @param[in]     ipc         IPC handle
+ */
+void sc_rm_dump(sc_ipc_t ipc);
+
+/* @} */
+
+#endif				/* _SC_RM_API_H */
+
+/**@}*/
diff --git a/include/soc/imx8/sc/svc/timer/api.h b/include/soc/imx8/sc/svc/timer/api.h
new file mode 100644
index 0000000..2f7e298
--- /dev/null
+++ b/include/soc/imx8/sc/svc/timer/api.h
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing the public API for the System Controller (SC)
+ * Timer function.
+ *
+ * @addtogroup TIMER_SVC (SVC) Timer Service
+ *
+ * Module for the Timer service. This includes support for the watchdog, RTC,
+ * and system counter. Note every resource partition has a watchdog it can
+ * use.
+ *
+ * @{
+ */
+
+#ifndef _SC_TIMER_API_H
+#define _SC_TIMER_API_H
+
+/* Includes */
+
+#include <soc/imx8/sc/types.h>
+#include <soc/imx8/sc/svc/rm/api.h>
+
+/* Defines */
+
+/*!
+ * @name Defines for type widths
+ */
+/*@{*/
+#define SC_TIMER_ACTION_W   3	/* Width of sc_timer_wdog_action_t */
+/*@}*/
+
+/*!
+ * @name Defines for sc_timer_wdog_action_t
+ */
+/*@{*/
+#define SC_TIMER_WDOG_ACTION_PARTITION      0	/* Reset partition */
+#define SC_TIMER_WDOG_ACTION_WARM           1	/* Warm reset system */
+#define SC_TIMER_WDOG_ACTION_COLD           2	/* Cold reset system */
+#define SC_TIMER_WDOG_ACTION_BOARD          3	/* Reset board */
+#define SC_TIMER_WDOG_ACTION_IRQ            4	/* Only generate IRQs */
+/*@}*/
+
+/* Types */
+
+/*!
+ * This type is used to configure the watchdog action.
+ */
+typedef uint8_t sc_timer_wdog_action_t;
+
+/*!
+ * This type is used to declare a watchdog time value in milliseconds.
+ */
+typedef uint32_t sc_timer_wdog_time_t;
+
+/* Functions */
+
+/*!
+ * @name Wathdog Functions
+ * @{
+ */
+
+/*!
+ * This function sets the watchdog timeout in milliseconds. If not
+ * set then the timeout defaults to the max. Once locked this value
+ * cannot be changed.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     timeout     timeout period for the watchdog
+ *
+ * @return Returns an error code (SC_ERR_NONE = success, SC_ERR_LOCKED
+ *         = locked).
+ */
+sc_err_t sc_timer_set_wdog_timeout(sc_ipc_t ipc, sc_timer_wdog_time_t timeout);
+
+/*!
+ * This function sets the watchdog pre-timeout in milliseconds. If not
+ * set then the pre-timeout defaults to the max. Once locked this value
+ * cannot be changed.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pre_timeout pre-timeout period for the watchdog
+ *
+ * When the pre-timout expires an IRQ will be generated. Note this timeout
+ * clears when the IRQ is triggered. An IRQ is generated for the failing
+ * partition and all of its child partitions.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_set_wdog_pre_timeout(sc_ipc_t ipc,
+				       sc_timer_wdog_time_t pre_timeout);
+
+/*!
+ * This function starts the watchdog.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     lock        boolean indicating the lock status
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * If \a lock is set then the watchdog cannot be stopped or the timeout
+ * period changed.
+ */
+sc_err_t sc_timer_start_wdog(sc_ipc_t ipc, bool lock);
+
+/*!
+ * This function stops the watchdog if it is not locked.
+ *
+ * @param[in]     ipc         IPC handle
+ *
+ * @return Returns an error code (SC_ERR_NONE = success, SC_ERR_LOCKED
+ *         = locked).
+ */
+sc_err_t sc_timer_stop_wdog(sc_ipc_t ipc);
+
+/*!
+ * This function pings (services, kicks) the watchdog resetting the time
+ * before expiration back to the timeout.
+ *
+ * @param[in]     ipc         IPC handle
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_ping_wdog(sc_ipc_t ipc);
+
+/*!
+ * This function gets the status of the watchdog. All arguments are
+ * in milliseconds.
+ *
+ * @param[in]     ipc             IPC handle
+ * @param[out]    timeout         pointer to return the timeout
+ * @param[out]    max_timeout     pointer to return the max timeout
+ * @param[out]    remaining_time  pointer to return the time remaining
+ *                                until trigger
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_get_wdog_status(sc_ipc_t ipc,
+				  sc_timer_wdog_time_t *timeout,
+				  sc_timer_wdog_time_t *max_timeout,
+				  sc_timer_wdog_time_t *remaining_time);
+
+/*!
+ * This function gets the status of the watchdog of a partition. All
+ * arguments are in milliseconds.
+ *
+ * @param[in]     ipc             IPC handle
+ * @param[in]     pt              partition to query
+ * @param[out]    enb             pointer to return enable status
+ * @param[out]    timeout         pointer to return the timeout
+ * @param[out]    remaining_time  pointer to return the time remaining
+ *                                until trigger
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt, bool *enb,
+				     sc_timer_wdog_time_t *timeout,
+				     sc_timer_wdog_time_t *remaining_time);
+
+/*!
+ * This function configures the action to be taken when a watchdog
+ * expires.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     pt          partition to affect
+ * @param[in]     action      action to take
+ *
+ * Default action is inherited from the parent.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid parameters,
+ * - SC_ERR_NOACCESS if caller's partition is not the SYSTEM owner,
+ * - SC_ERR_LOCKED if the watchdog is locked
+ */
+sc_err_t sc_timer_set_wdog_action(sc_ipc_t ipc,
+				  sc_rm_pt_t pt, sc_timer_wdog_action_t action);
+
+/* @} */
+
+/*!
+ * @name Real-Time Clock (RTC) Functions
+ * @{
+ */
+
+/*!
+ * This function sets the RTC time. Only the owner of the SC_R_SYSTEM
+ * resource can set the time.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     year        year (min 1970)
+ * @param[in]     mon         month (1-12)
+ * @param[in]     day         day of the month (1-31)
+ * @param[in]     hour        hour (0-23)
+ * @param[in]     min         minute (0-59)
+ * @param[in]     sec         second (0-59)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters,
+ * - SC_ERR_NOACCESS if caller's partition is not the SYSTEM owner
+ */
+sc_err_t sc_timer_set_rtc_time(sc_ipc_t ipc, uint16_t year, uint8_t mon,
+			       uint8_t day, uint8_t hour, uint8_t min,
+			       uint8_t sec);
+
+/*!
+ * This function gets the RTC time.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    year        pointer to return year (min 1970)
+ * @param[out]    mon         pointer to return month (1-12)
+ * @param[out]    day         pointer to return day of the month (1-31)
+ * @param[out]    hour        pointer to return hour (0-23)
+ * @param[out]    min         pointer to return minute (0-59)
+ * @param[out]    sec         pointer to return second (0-59)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_get_rtc_time(sc_ipc_t ipc, uint16_t *year, uint8_t *mon,
+			       uint8_t *day, uint8_t *hour, uint8_t *min,
+			       uint8_t *sec);
+
+/*!
+ * This function gets the RTC time in seconds since 1/1/1970.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    sec         pointer to return second
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_get_rtc_sec1970(sc_ipc_t ipc, uint32_t *sec);
+
+/*!
+ * This function sets the RTC alarm.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     year        year (min 1970)
+ * @param[in]     mon         month (1-12)
+ * @param[in]     day         day of the month (1-31)
+ * @param[in]     hour        hour (0-23)
+ * @param[in]     min         minute (0-59)
+ * @param[in]     sec         second (0-59)
+ *
+ * Note this alarm setting clears when the alarm is triggered.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters
+ */
+sc_err_t sc_timer_set_rtc_alarm(sc_ipc_t ipc, uint16_t year, uint8_t mon,
+				uint8_t day, uint8_t hour, uint8_t min,
+				uint8_t sec);
+
+/*!
+ * This function sets the RTC calibration value. Only the owner of the SC_R_SYSTEM
+ * resource can set the calibration.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     count       calbration count (-16 to 15)
+ *
+ * The calibration value is a 5-bit value including the sign bit, which is
+ * implemented in 2's complement. It is added or subtracted from the RTC on
+ * a perdiodic basis, once per 32768 cycles of the RTC clock.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_timer_set_rtc_calb(sc_ipc_t ipc, int8_t count);
+
+/* @} */
+
+#endif				/* _SC_TIMER_API_H */
+
+/**@}*/
diff --git a/include/soc/imx8/sc/types.h b/include/soc/imx8/sc/types.h
new file mode 100644
index 0000000..8d8b046
--- /dev/null
+++ b/include/soc/imx8/sc/types.h
@@ -0,0 +1,824 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*!
+ * Header file containing types used across multiple service APIs.
+ */
+
+#ifndef _SC_TYPES_H
+#define _SC_TYPES_H
+
+/* Includes */
+
+#include <soc/imx8/sc/scfw.h>
+
+/* Defines */
+
+/*!
+ * @name Defines for common frequencies
+ */
+/*@{*/
+#define SC_32KHZ            32768	/* 32KHz */
+#define SC_10MHZ         10000000	/* 10MHz */
+#define SC_20MHZ         20000000	/* 20MHz */
+#define SC_25MHZ         25000000	/* 25MHz */
+#define SC_27MHZ         27000000	/* 27MHz */
+#define SC_40MHZ         40000000	/* 40MHz */
+#define SC_45MHZ         45000000	/* 45MHz */
+#define SC_50MHZ         50000000	/* 50MHz */
+#define SC_60MHZ         60000000	/* 60MHz */
+#define SC_66MHZ         66666666	/* 66MHz */
+#define SC_74MHZ         74250000	/* 74.25MHz */
+#define SC_80MHZ         80000000	/* 80MHz */
+#define SC_83MHZ         83333333	/* 83MHz */
+#define SC_84MHZ         84375000	/* 84.37MHz */
+#define SC_100MHZ       100000000	/* 100MHz */
+#define SC_125MHZ       125000000	/* 125MHz */
+#define SC_133MHZ       133333333	/* 133MHz */
+#define SC_135MHZ       135000000	/* 135MHz */
+#define SC_150MHZ       150000000	/* 150MHz */
+#define SC_160MHZ       160000000	/* 160MHz */
+#define SC_166MHZ       166666666	/* 160MHz */
+#define SC_175MHZ       175000000	/* 175MHz */
+#define SC_180MHZ       180000000	/* 180MHz */
+#define SC_200MHZ       200000000	/* 200MHz */
+#define SC_250MHZ       250000000	/* 250MHz */
+#define SC_266MHZ       266666666	/* 266MHz */
+#define SC_300MHZ       300000000	/* 300MHz */
+#define SC_320MHZ       320000000	/* 320MHz */
+#define SC_325MHZ       325000000	/* 325MHz */
+#define SC_333MHZ       333333333	/* 333MHz */
+#define SC_350MHZ       350000000	/* 350MHz */
+#define SC_372MHZ       372000000	/* 372MHz */
+#define SC_375MHZ       375000000	/* 375MHz */
+#define SC_400MHZ       400000000	/* 400MHz */
+#define SC_500MHZ       500000000	/* 500MHz */
+#define SC_594MHZ       594000000	/* 594MHz */
+#define SC_650MHZ       650000000	/* 650MHz */
+#define SC_667MHZ       666666667	/* 667MHz */
+#define SC_675MHZ       675000000	/* 675MHz */
+#define SC_700MHZ       700000000	/* 700MHz */
+#define SC_720MHZ       720000000	/* 720MHz */
+#define SC_750MHZ       750000000	/* 750MHz */
+#define SC_800MHZ       800000000	/* 800MHz */
+#define SC_850MHZ       850000000	/* 850MHz */
+#define SC_900MHZ       900000000	/* 900MHz */
+#define SC_1000MHZ     1000000000	/* 1GHz */
+#define SC_1056MHZ     1056000000	/* 1.056GHz */
+#define SC_1188MHZ     1188000000	/* 1.188GHz */
+#define SC_1260MHZ     1260000000	/* 1.26GHz */
+#define SC_1300MHZ     1300000000	/* 1.3GHz */
+#define SC_1400MHZ     1400000000	/* 1.4GHz */
+#define SC_1500MHZ     1500000000	/* 1.5GHz */
+#define SC_1600MHZ     1600000000	/* 1.6GHz */
+#define SC_1800MHZ     1800000000	/* 1.8GHz */
+#define SC_2000MHZ     2000000000	/* 2.0GHz */
+#define SC_2112MHZ     2112000000	/* 2.12GHz */
+
+/*@}*/
+
+/*!
+ * @name Defines for 24M related frequencies
+ */
+/*@{*/
+#define SC_8MHZ           8000000	/* 8MHz */
+#define SC_12MHZ         12000000	/* 12MHz */
+#define SC_19MHZ         19800000	/* 19.8MHz */
+#define SC_24MHZ         24000000	/* 24MHz */
+#define SC_48MHZ         48000000	/* 48MHz */
+#define SC_120MHZ       120000000	/* 120MHz */
+#define SC_132MHZ       132000000	/* 132MHz */
+#define SC_144MHZ       144000000	/* 144MHz */
+#define SC_192MHZ       192000000	/* 192MHz */
+#define SC_211MHZ       211200000	/* 211.2MHz */
+#define SC_240MHZ       240000000	/* 240MHz */
+#define SC_264MHZ       264000000	/* 264MHz */
+#define SC_352MHZ       352000000	/* 352MHz */
+#define SC_360MHZ       360000000	/* 360MHz */
+#define SC_384MHZ       384000000	/* 384MHz */
+#define SC_396MHZ       396000000	/* 396MHz */
+#define SC_432MHZ       432000000	/* 432MHz */
+#define SC_480MHZ       480000000	/* 480MHz */
+#define SC_600MHZ       600000000	/* 600MHz */
+#define SC_744MHZ       744000000	/* 744MHz */
+#define SC_792MHZ       792000000	/* 792MHz */
+#define SC_864MHZ       864000000	/* 864MHz */
+#define SC_960MHZ       960000000	/* 960MHz */
+#define SC_1056MHZ     1056000000	/* 1056MHz */
+#define SC_1200MHZ     1200000000	/* 1.2GHz */
+#define SC_1464MHZ     1464000000	/* 1.464GHz */
+#define SC_2400MHZ     2400000000	/* 2.4GHz */
+/*@}*/
+
+/*!
+ * @name Defines for A/V related frequencies
+ */
+/*@{*/
+#define SC_62MHZ         62937500	/* 62.9375MHz */
+#define SC_755MHZ       755250000	/* 755.25MHz */
+/*@}*/
+
+/*!
+ * @name Defines for type widths
+ */
+/*@{*/
+#define SC_FADDR_W      36	/* Width of sc_faddr_t */
+#define SC_BOOL_W       1	/* Width of bool */
+#define SC_ERR_W        4	/* Width of sc_err_t */
+#define SC_RSRC_W       10	/* Width of sc_rsrc_t */
+#define SC_CTRL_W       6	/* Width of sc_ctrl_t */
+/*@}*/
+
+#define SC_R_ALL        UINT16_MAX	/* All resources */
+#define SC_P_ALL        UINT16_MAX	/* All pads */
+
+/*!
+ * This type is used to store a system (full-size) address.
+ */
+typedef uint64_t sc_faddr_t;
+
+/*!
+ * This type is used to indicate error response for most functions.
+ */
+typedef enum sc_err_e {
+	SC_ERR_NONE = 0,	/* Success */
+	SC_ERR_VERSION = 1,	/* Incompatible API version */
+	SC_ERR_CONFIG = 2,	/* Configuration error */
+	SC_ERR_PARM = 3,	/* Bad parameter */
+	SC_ERR_NOACCESS = 4,	/* Permission error (no access) */
+	SC_ERR_LOCKED = 5,	/* Permission error (locked) */
+	SC_ERR_UNAVAILABLE = 6,	/* Unavailable (out of resources) */
+	SC_ERR_NOTFOUND = 7,	/* Not found */
+	SC_ERR_NOPOWER = 8,	/* No power */
+	SC_ERR_IPC = 9,		/* Generic IPC error */
+	SC_ERR_BUSY = 10,	/* Resource is currently busy/active */
+	SC_ERR_FAIL = 11,	/* General I/O failure */
+	SC_ERR_LAST
+} sc_err_t;
+
+/*!
+ * This type is used to indicate a resource. Resources include peripherals
+ * and bus masters (but not memory regions). Note items from list should
+ * never be changed or removed (only added to at the end of the list).
+ */
+typedef enum sc_rsrc_e {
+	SC_R_A53 = 0,
+	SC_R_A53_0 = 1,
+	SC_R_A53_1 = 2,
+	SC_R_A53_2 = 3,
+	SC_R_A53_3 = 4,
+	SC_R_A72 = 5,
+	SC_R_A72_0 = 6,
+	SC_R_A72_1 = 7,
+	SC_R_A72_2 = 8,
+	SC_R_A72_3 = 9,
+	SC_R_CCI = 10,
+	SC_R_DB = 11,
+	SC_R_DRC_0 = 12,
+	SC_R_DRC_1 = 13,
+	SC_R_GIC_SMMU = 14,
+	SC_R_IRQSTR_M4_0 = 15,
+	SC_R_IRQSTR_M4_1 = 16,
+	SC_R_SMMU = 17,
+	SC_R_GIC = 18,
+	SC_R_DC_0_BLIT0 = 19,
+	SC_R_DC_0_BLIT1 = 20,
+	SC_R_DC_0_BLIT2 = 21,
+	SC_R_DC_0_BLIT_OUT = 22,
+	SC_R_DC_0_CAPTURE0 = 23,
+	SC_R_DC_0_CAPTURE1 = 24,
+	SC_R_DC_0_WARP = 25,
+	SC_R_DC_0_INTEGRAL0 = 26,
+	SC_R_DC_0_INTEGRAL1 = 27,
+	SC_R_DC_0_VIDEO0 = 28,
+	SC_R_DC_0_VIDEO1 = 29,
+	SC_R_DC_0_FRAC0 = 30,
+	SC_R_DC_0_FRAC1 = 31,
+	SC_R_DC_0 = 32,
+	SC_R_GPU_2_PID0 = 33,
+	SC_R_DC_0_PLL_0 = 34,
+	SC_R_DC_0_PLL_1 = 35,
+	SC_R_DC_1_BLIT0 = 36,
+	SC_R_DC_1_BLIT1 = 37,
+	SC_R_DC_1_BLIT2 = 38,
+	SC_R_DC_1_BLIT_OUT = 39,
+	SC_R_DC_1_CAPTURE0 = 40,
+	SC_R_DC_1_CAPTURE1 = 41,
+	SC_R_DC_1_WARP = 42,
+	SC_R_DC_1_INTEGRAL0 = 43,
+	SC_R_DC_1_INTEGRAL1 = 44,
+	SC_R_DC_1_VIDEO0 = 45,
+	SC_R_DC_1_VIDEO1 = 46,
+	SC_R_DC_1_FRAC0 = 47,
+	SC_R_DC_1_FRAC1 = 48,
+	SC_R_DC_1 = 49,
+	SC_R_GPU_3_PID0 = 50,
+	SC_R_DC_1_PLL_0 = 51,
+	SC_R_DC_1_PLL_1 = 52,
+	SC_R_SPI_0 = 53,
+	SC_R_SPI_1 = 54,
+	SC_R_SPI_2 = 55,
+	SC_R_SPI_3 = 56,
+	SC_R_UART_0 = 57,
+	SC_R_UART_1 = 58,
+	SC_R_UART_2 = 59,
+	SC_R_UART_3 = 60,
+	SC_R_UART_4 = 61,
+	SC_R_EMVSIM_0 = 62,
+	SC_R_EMVSIM_1 = 63,
+	SC_R_DMA_0_CH0 = 64,
+	SC_R_DMA_0_CH1 = 65,
+	SC_R_DMA_0_CH2 = 66,
+	SC_R_DMA_0_CH3 = 67,
+	SC_R_DMA_0_CH4 = 68,
+	SC_R_DMA_0_CH5 = 69,
+	SC_R_DMA_0_CH6 = 70,
+	SC_R_DMA_0_CH7 = 71,
+	SC_R_DMA_0_CH8 = 72,
+	SC_R_DMA_0_CH9 = 73,
+	SC_R_DMA_0_CH10 = 74,
+	SC_R_DMA_0_CH11 = 75,
+	SC_R_DMA_0_CH12 = 76,
+	SC_R_DMA_0_CH13 = 77,
+	SC_R_DMA_0_CH14 = 78,
+	SC_R_DMA_0_CH15 = 79,
+	SC_R_DMA_0_CH16 = 80,
+	SC_R_DMA_0_CH17 = 81,
+	SC_R_DMA_0_CH18 = 82,
+	SC_R_DMA_0_CH19 = 83,
+	SC_R_DMA_0_CH20 = 84,
+	SC_R_DMA_0_CH21 = 85,
+	SC_R_DMA_0_CH22 = 86,
+	SC_R_DMA_0_CH23 = 87,
+	SC_R_DMA_0_CH24 = 88,
+	SC_R_DMA_0_CH25 = 89,
+	SC_R_DMA_0_CH26 = 90,
+	SC_R_DMA_0_CH27 = 91,
+	SC_R_DMA_0_CH28 = 92,
+	SC_R_DMA_0_CH29 = 93,
+	SC_R_DMA_0_CH30 = 94,
+	SC_R_DMA_0_CH31 = 95,
+	SC_R_I2C_0 = 96,
+	SC_R_I2C_1 = 97,
+	SC_R_I2C_2 = 98,
+	SC_R_I2C_3 = 99,
+	SC_R_I2C_4 = 100,
+	SC_R_ADC_0 = 101,
+	SC_R_ADC_1 = 102,
+	SC_R_FTM_0 = 103,
+	SC_R_FTM_1 = 104,
+	SC_R_CAN_0 = 105,
+	SC_R_CAN_1 = 106,
+	SC_R_CAN_2 = 107,
+	SC_R_DMA_1_CH0 = 108,
+	SC_R_DMA_1_CH1 = 109,
+	SC_R_DMA_1_CH2 = 110,
+	SC_R_DMA_1_CH3 = 111,
+	SC_R_DMA_1_CH4 = 112,
+	SC_R_DMA_1_CH5 = 113,
+	SC_R_DMA_1_CH6 = 114,
+	SC_R_DMA_1_CH7 = 115,
+	SC_R_DMA_1_CH8 = 116,
+	SC_R_DMA_1_CH9 = 117,
+	SC_R_DMA_1_CH10 = 118,
+	SC_R_DMA_1_CH11 = 119,
+	SC_R_DMA_1_CH12 = 120,
+	SC_R_DMA_1_CH13 = 121,
+	SC_R_DMA_1_CH14 = 122,
+	SC_R_DMA_1_CH15 = 123,
+	SC_R_DMA_1_CH16 = 124,
+	SC_R_DMA_1_CH17 = 125,
+	SC_R_DMA_1_CH18 = 126,
+	SC_R_DMA_1_CH19 = 127,
+	SC_R_DMA_1_CH20 = 128,
+	SC_R_DMA_1_CH21 = 129,
+	SC_R_DMA_1_CH22 = 130,
+	SC_R_DMA_1_CH23 = 131,
+	SC_R_DMA_1_CH24 = 132,
+	SC_R_DMA_1_CH25 = 133,
+	SC_R_DMA_1_CH26 = 134,
+	SC_R_DMA_1_CH27 = 135,
+	SC_R_DMA_1_CH28 = 136,
+	SC_R_DMA_1_CH29 = 137,
+	SC_R_DMA_1_CH30 = 138,
+	SC_R_DMA_1_CH31 = 139,
+	SC_R_UNUSED1 = 140,
+	SC_R_UNUSED2 = 141,
+	SC_R_UNUSED3 = 142,
+	SC_R_UNUSED4 = 143,
+	SC_R_GPU_0_PID0 = 144,
+	SC_R_GPU_0_PID1 = 145,
+	SC_R_GPU_0_PID2 = 146,
+	SC_R_GPU_0_PID3 = 147,
+	SC_R_GPU_1_PID0 = 148,
+	SC_R_GPU_1_PID1 = 149,
+	SC_R_GPU_1_PID2 = 150,
+	SC_R_GPU_1_PID3 = 151,
+	SC_R_PCIE_A = 152,
+	SC_R_SERDES_0 = 153,
+	SC_R_MATCH_0 = 154,
+	SC_R_MATCH_1 = 155,
+	SC_R_MATCH_2 = 156,
+	SC_R_MATCH_3 = 157,
+	SC_R_MATCH_4 = 158,
+	SC_R_MATCH_5 = 159,
+	SC_R_MATCH_6 = 160,
+	SC_R_MATCH_7 = 161,
+	SC_R_MATCH_8 = 162,
+	SC_R_MATCH_9 = 163,
+	SC_R_MATCH_10 = 164,
+	SC_R_MATCH_11 = 165,
+	SC_R_MATCH_12 = 166,
+	SC_R_MATCH_13 = 167,
+	SC_R_MATCH_14 = 168,
+	SC_R_PCIE_B = 169,
+	SC_R_SATA_0 = 170,
+	SC_R_SERDES_1 = 171,
+	SC_R_HSIO_GPIO = 172,
+	SC_R_MATCH_15 = 173,
+	SC_R_MATCH_16 = 174,
+	SC_R_MATCH_17 = 175,
+	SC_R_MATCH_18 = 176,
+	SC_R_MATCH_19 = 177,
+	SC_R_MATCH_20 = 178,
+	SC_R_MATCH_21 = 179,
+	SC_R_MATCH_22 = 180,
+	SC_R_MATCH_23 = 181,
+	SC_R_MATCH_24 = 182,
+	SC_R_MATCH_25 = 183,
+	SC_R_MATCH_26 = 184,
+	SC_R_MATCH_27 = 185,
+	SC_R_MATCH_28 = 186,
+	SC_R_LCD_0 = 187,
+	SC_R_LCD_0_PWM_0 = 188,
+	SC_R_LCD_0_I2C_0 = 189,
+	SC_R_LCD_0_I2C_1 = 190,
+	SC_R_PWM_0 = 191,
+	SC_R_PWM_1 = 192,
+	SC_R_PWM_2 = 193,
+	SC_R_PWM_3 = 194,
+	SC_R_PWM_4 = 195,
+	SC_R_PWM_5 = 196,
+	SC_R_PWM_6 = 197,
+	SC_R_PWM_7 = 198,
+	SC_R_GPIO_0 = 199,
+	SC_R_GPIO_1 = 200,
+	SC_R_GPIO_2 = 201,
+	SC_R_GPIO_3 = 202,
+	SC_R_GPIO_4 = 203,
+	SC_R_GPIO_5 = 204,
+	SC_R_GPIO_6 = 205,
+	SC_R_GPIO_7 = 206,
+	SC_R_GPT_0 = 207,
+	SC_R_GPT_1 = 208,
+	SC_R_GPT_2 = 209,
+	SC_R_GPT_3 = 210,
+	SC_R_GPT_4 = 211,
+	SC_R_KPP = 212,
+	SC_R_MU_0A = 213,
+	SC_R_MU_1A = 214,
+	SC_R_MU_2A = 215,
+	SC_R_MU_3A = 216,
+	SC_R_MU_4A = 217,
+	SC_R_MU_5A = 218,
+	SC_R_MU_6A = 219,
+	SC_R_MU_7A = 220,
+	SC_R_MU_8A = 221,
+	SC_R_MU_9A = 222,
+	SC_R_MU_10A = 223,
+	SC_R_MU_11A = 224,
+	SC_R_MU_12A = 225,
+	SC_R_MU_13A = 226,
+	SC_R_MU_5B = 227,
+	SC_R_MU_6B = 228,
+	SC_R_MU_7B = 229,
+	SC_R_MU_8B = 230,
+	SC_R_MU_9B = 231,
+	SC_R_MU_10B = 232,
+	SC_R_MU_11B = 233,
+	SC_R_MU_12B = 234,
+	SC_R_MU_13B = 235,
+	SC_R_ROM_0 = 236,
+	SC_R_FSPI_0 = 237,
+	SC_R_FSPI_1 = 238,
+	SC_R_IEE = 239,
+	SC_R_IEE_R0 = 240,
+	SC_R_IEE_R1 = 241,
+	SC_R_IEE_R2 = 242,
+	SC_R_IEE_R3 = 243,
+	SC_R_IEE_R4 = 244,
+	SC_R_IEE_R5 = 245,
+	SC_R_IEE_R6 = 246,
+	SC_R_IEE_R7 = 247,
+	SC_R_SDHC_0 = 248,
+	SC_R_SDHC_1 = 249,
+	SC_R_SDHC_2 = 250,
+	SC_R_ENET_0 = 251,
+	SC_R_ENET_1 = 252,
+	SC_R_MLB_0 = 253,
+	SC_R_DMA_2_CH0 = 254,
+	SC_R_DMA_2_CH1 = 255,
+	SC_R_DMA_2_CH2 = 256,
+	SC_R_DMA_2_CH3 = 257,
+	SC_R_DMA_2_CH4 = 258,
+	SC_R_USB_0 = 259,
+	SC_R_USB_1 = 260,
+	SC_R_USB_0_PHY = 261,
+	SC_R_USB_2 = 262,
+	SC_R_USB_2_PHY = 263,
+	SC_R_DTCP = 264,
+	SC_R_NAND = 265,
+	SC_R_LVDS_0 = 266,
+	SC_R_LVDS_0_PWM_0 = 267,
+	SC_R_LVDS_0_I2C_0 = 268,
+	SC_R_LVDS_0_I2C_1 = 269,
+	SC_R_LVDS_1 = 270,
+	SC_R_LVDS_1_PWM_0 = 271,
+	SC_R_LVDS_1_I2C_0 = 272,
+	SC_R_LVDS_1_I2C_1 = 273,
+	SC_R_LVDS_2 = 274,
+	SC_R_LVDS_2_PWM_0 = 275,
+	SC_R_LVDS_2_I2C_0 = 276,
+	SC_R_LVDS_2_I2C_1 = 277,
+	SC_R_M4_0_PID0 = 278,
+	SC_R_M4_0_PID1 = 279,
+	SC_R_M4_0_PID2 = 280,
+	SC_R_M4_0_PID3 = 281,
+	SC_R_M4_0_PID4 = 282,
+	SC_R_M4_0_RGPIO = 283,
+	SC_R_M4_0_SEMA42 = 284,
+	SC_R_M4_0_TPM = 285,
+	SC_R_M4_0_PIT = 286,
+	SC_R_M4_0_UART = 287,
+	SC_R_M4_0_I2C = 288,
+	SC_R_M4_0_INTMUX = 289,
+	SC_R_M4_0_SIM = 290,
+	SC_R_M4_0_WDOG = 291,
+	SC_R_M4_0_MU_0B = 292,
+	SC_R_M4_0_MU_0A0 = 293,
+	SC_R_M4_0_MU_0A1 = 294,
+	SC_R_M4_0_MU_0A2 = 295,
+	SC_R_M4_0_MU_0A3 = 296,
+	SC_R_M4_0_MU_1A = 297,
+	SC_R_M4_1_PID0 = 298,
+	SC_R_M4_1_PID1 = 299,
+	SC_R_M4_1_PID2 = 300,
+	SC_R_M4_1_PID3 = 301,
+	SC_R_M4_1_PID4 = 302,
+	SC_R_M4_1_RGPIO = 303,
+	SC_R_M4_1_SEMA42 = 304,
+	SC_R_M4_1_TPM = 305,
+	SC_R_M4_1_PIT = 306,
+	SC_R_M4_1_UART = 307,
+	SC_R_M4_1_I2C = 308,
+	SC_R_M4_1_INTMUX = 309,
+	SC_R_M4_1_SIM = 310,
+	SC_R_M4_1_WDOG = 311,
+	SC_R_M4_1_MU_0B = 312,
+	SC_R_M4_1_MU_0A0 = 313,
+	SC_R_M4_1_MU_0A1 = 314,
+	SC_R_M4_1_MU_0A2 = 315,
+	SC_R_M4_1_MU_0A3 = 316,
+	SC_R_M4_1_MU_1A = 317,
+	SC_R_SAI_0 = 318,
+	SC_R_SAI_1 = 319,
+	SC_R_SAI_2 = 320,
+	SC_R_IRQSTR_SCU2 = 321,
+	SC_R_IRQSTR_DSP = 322,
+	SC_R_UNUSED5 = 323,
+	SC_R_UNUSED6 = 324,
+	SC_R_AUDIO_PLL_0 = 325,
+	SC_R_PI_0 = 326,
+	SC_R_PI_0_PWM_0 = 327,
+	SC_R_PI_0_PWM_1 = 328,
+	SC_R_PI_0_I2C_0 = 329,
+	SC_R_PI_0_PLL = 330,
+	SC_R_PI_1 = 331,
+	SC_R_PI_1_PWM_0 = 332,
+	SC_R_PI_1_PWM_1 = 333,
+	SC_R_PI_1_I2C_0 = 334,
+	SC_R_PI_1_PLL = 335,
+	SC_R_SC_PID0 = 336,
+	SC_R_SC_PID1 = 337,
+	SC_R_SC_PID2 = 338,
+	SC_R_SC_PID3 = 339,
+	SC_R_SC_PID4 = 340,
+	SC_R_SC_SEMA42 = 341,
+	SC_R_SC_TPM = 342,
+	SC_R_SC_PIT = 343,
+	SC_R_SC_UART = 344,
+	SC_R_SC_I2C = 345,
+	SC_R_SC_MU_0B = 346,
+	SC_R_SC_MU_0A0 = 347,
+	SC_R_SC_MU_0A1 = 348,
+	SC_R_SC_MU_0A2 = 349,
+	SC_R_SC_MU_0A3 = 350,
+	SC_R_SC_MU_1A = 351,
+	SC_R_SYSCNT_RD = 352,
+	SC_R_SYSCNT_CMP = 353,
+	SC_R_DEBUG = 354,
+	SC_R_SYSTEM = 355,
+	SC_R_SNVS = 356,
+	SC_R_OTP = 357,
+	SC_R_VPU_PID0 = 358,
+	SC_R_VPU_PID1 = 359,
+	SC_R_VPU_PID2 = 360,
+	SC_R_VPU_PID3 = 361,
+	SC_R_VPU_PID4 = 362,
+	SC_R_VPU_PID5 = 363,
+	SC_R_VPU_PID6 = 364,
+	SC_R_VPU_PID7 = 365,
+	SC_R_VPU_UART = 366,
+	SC_R_VPUCORE = 367,
+	SC_R_VPUCORE_0 = 368,
+	SC_R_VPUCORE_1 = 369,
+	SC_R_VPUCORE_2 = 370,
+	SC_R_VPUCORE_3 = 371,
+	SC_R_DMA_4_CH0 = 372,
+	SC_R_DMA_4_CH1 = 373,
+	SC_R_DMA_4_CH2 = 374,
+	SC_R_DMA_4_CH3 = 375,
+	SC_R_DMA_4_CH4 = 376,
+	SC_R_ISI_CH0 = 377,
+	SC_R_ISI_CH1 = 378,
+	SC_R_ISI_CH2 = 379,
+	SC_R_ISI_CH3 = 380,
+	SC_R_ISI_CH4 = 381,
+	SC_R_ISI_CH5 = 382,
+	SC_R_ISI_CH6 = 383,
+	SC_R_ISI_CH7 = 384,
+	SC_R_MJPEG_DEC_S0 = 385,
+	SC_R_MJPEG_DEC_S1 = 386,
+	SC_R_MJPEG_DEC_S2 = 387,
+	SC_R_MJPEG_DEC_S3 = 388,
+	SC_R_MJPEG_ENC_S0 = 389,
+	SC_R_MJPEG_ENC_S1 = 390,
+	SC_R_MJPEG_ENC_S2 = 391,
+	SC_R_MJPEG_ENC_S3 = 392,
+	SC_R_MIPI_0 = 393,
+	SC_R_MIPI_0_PWM_0 = 394,
+	SC_R_MIPI_0_I2C_0 = 395,
+	SC_R_MIPI_0_I2C_1 = 396,
+	SC_R_MIPI_1 = 397,
+	SC_R_MIPI_1_PWM_0 = 398,
+	SC_R_MIPI_1_I2C_0 = 399,
+	SC_R_MIPI_1_I2C_1 = 400,
+	SC_R_CSI_0 = 401,
+	SC_R_CSI_0_PWM_0 = 402,
+	SC_R_CSI_0_I2C_0 = 403,
+	SC_R_CSI_1 = 404,
+	SC_R_CSI_1_PWM_0 = 405,
+	SC_R_CSI_1_I2C_0 = 406,
+	SC_R_HDMI = 407,
+	SC_R_HDMI_I2S = 408,
+	SC_R_HDMI_I2C_0 = 409,
+	SC_R_HDMI_PLL_0 = 410,
+	SC_R_HDMI_RX = 411,
+	SC_R_HDMI_RX_BYPASS = 412,
+	SC_R_HDMI_RX_I2C_0 = 413,
+	SC_R_ASRC_0 = 414,
+	SC_R_ESAI_0 = 415,
+	SC_R_SPDIF_0 = 416,
+	SC_R_SPDIF_1 = 417,
+	SC_R_SAI_3 = 418,
+	SC_R_SAI_4 = 419,
+	SC_R_SAI_5 = 420,
+	SC_R_GPT_5 = 421,
+	SC_R_GPT_6 = 422,
+	SC_R_GPT_7 = 423,
+	SC_R_GPT_8 = 424,
+	SC_R_GPT_9 = 425,
+	SC_R_GPT_10 = 426,
+	SC_R_DMA_2_CH5 = 427,
+	SC_R_DMA_2_CH6 = 428,
+	SC_R_DMA_2_CH7 = 429,
+	SC_R_DMA_2_CH8 = 430,
+	SC_R_DMA_2_CH9 = 431,
+	SC_R_DMA_2_CH10 = 432,
+	SC_R_DMA_2_CH11 = 433,
+	SC_R_DMA_2_CH12 = 434,
+	SC_R_DMA_2_CH13 = 435,
+	SC_R_DMA_2_CH14 = 436,
+	SC_R_DMA_2_CH15 = 437,
+	SC_R_DMA_2_CH16 = 438,
+	SC_R_DMA_2_CH17 = 439,
+	SC_R_DMA_2_CH18 = 440,
+	SC_R_DMA_2_CH19 = 441,
+	SC_R_DMA_2_CH20 = 442,
+	SC_R_DMA_2_CH21 = 443,
+	SC_R_DMA_2_CH22 = 444,
+	SC_R_DMA_2_CH23 = 445,
+	SC_R_DMA_2_CH24 = 446,
+	SC_R_DMA_2_CH25 = 447,
+	SC_R_DMA_2_CH26 = 448,
+	SC_R_DMA_2_CH27 = 449,
+	SC_R_DMA_2_CH28 = 450,
+	SC_R_DMA_2_CH29 = 451,
+	SC_R_DMA_2_CH30 = 452,
+	SC_R_DMA_2_CH31 = 453,
+	SC_R_ASRC_1 = 454,
+	SC_R_ESAI_1 = 455,
+	SC_R_SAI_6 = 456,
+	SC_R_SAI_7 = 457,
+	SC_R_AMIX = 458,
+	SC_R_MQS_0 = 459,
+	SC_R_DMA_3_CH0 = 460,
+	SC_R_DMA_3_CH1 = 461,
+	SC_R_DMA_3_CH2 = 462,
+	SC_R_DMA_3_CH3 = 463,
+	SC_R_DMA_3_CH4 = 464,
+	SC_R_DMA_3_CH5 = 465,
+	SC_R_DMA_3_CH6 = 466,
+	SC_R_DMA_3_CH7 = 467,
+	SC_R_DMA_3_CH8 = 468,
+	SC_R_DMA_3_CH9 = 469,
+	SC_R_DMA_3_CH10 = 470,
+	SC_R_DMA_3_CH11 = 471,
+	SC_R_DMA_3_CH12 = 472,
+	SC_R_DMA_3_CH13 = 473,
+	SC_R_DMA_3_CH14 = 474,
+	SC_R_DMA_3_CH15 = 475,
+	SC_R_DMA_3_CH16 = 476,
+	SC_R_DMA_3_CH17 = 477,
+	SC_R_DMA_3_CH18 = 478,
+	SC_R_DMA_3_CH19 = 479,
+	SC_R_DMA_3_CH20 = 480,
+	SC_R_DMA_3_CH21 = 481,
+	SC_R_DMA_3_CH22 = 482,
+	SC_R_DMA_3_CH23 = 483,
+	SC_R_DMA_3_CH24 = 484,
+	SC_R_DMA_3_CH25 = 485,
+	SC_R_DMA_3_CH26 = 486,
+	SC_R_DMA_3_CH27 = 487,
+	SC_R_DMA_3_CH28 = 488,
+	SC_R_DMA_3_CH29 = 489,
+	SC_R_DMA_3_CH30 = 490,
+	SC_R_DMA_3_CH31 = 491,
+	SC_R_AUDIO_PLL_1 = 492,
+	SC_R_AUDIO_CLK_0 = 493,
+	SC_R_AUDIO_CLK_1 = 494,
+	SC_R_MCLK_OUT_0 = 495,
+	SC_R_MCLK_OUT_1 = 496,
+	SC_R_PMIC_0 = 497,
+	SC_R_PMIC_1 = 498,
+	SC_R_SECO = 499,
+	SC_R_CAAM_JR1 = 500,
+	SC_R_CAAM_JR2 = 501,
+	SC_R_CAAM_JR3 = 502,
+	SC_R_SECO_MU_2 = 503,
+	SC_R_SECO_MU_3 = 504,
+	SC_R_SECO_MU_4 = 505,
+	SC_R_HDMI_RX_PWM_0 = 506,
+	SC_R_A35 = 507,
+	SC_R_A35_0 = 508,
+	SC_R_A35_1 = 509,
+	SC_R_A35_2 = 510,
+	SC_R_A35_3 = 511,
+	SC_R_DSP = 512,
+	SC_R_DSP_RAM = 513,
+	SC_R_CAAM_JR1_OUT = 514,
+	SC_R_CAAM_JR2_OUT = 515,
+	SC_R_CAAM_JR3_OUT = 516,
+	SC_R_VPU_DEC_0 = 517,
+	SC_R_VPU_ENC_0 = 518,
+	SC_R_CAAM_JR0 = 519,
+	SC_R_CAAM_JR0_OUT = 520,
+	SC_R_PMIC_2 = 521,
+	SC_R_DBLOGIC = 522,
+	SC_R_HDMI_PLL_1 = 523,
+	SC_R_BOARD_R0 = 524,
+	SC_R_BOARD_R1 = 525,
+	SC_R_BOARD_R2 = 526,
+	SC_R_BOARD_R3 = 527,
+	SC_R_BOARD_R4 = 528,
+	SC_R_BOARD_R5 = 529,
+	SC_R_BOARD_R6 = 530,
+	SC_R_BOARD_R7 = 531,
+	SC_R_MJPEG_DEC_MP = 532,
+	SC_R_MJPEG_ENC_MP = 533,
+	SC_R_VPU_TS_0 = 534,
+	SC_R_VPU_MU_0 = 535,
+	SC_R_VPU_MU_1 = 536,
+	SC_R_VPU_MU_2 = 537,
+	SC_R_VPU_MU_3 = 538,
+	SC_R_VPU_ENC_1 = 539,
+	SC_R_VPU = 540,
+	SC_R_LAST
+} sc_rsrc_t;
+
+/* NOTE - please add by replacing some of the UNUSED from above! */
+
+/*!
+ * This type is used to indicate a control.
+ */
+typedef enum sc_ctrl_e {
+
+	SC_C_TEMP = 0,
+	SC_C_TEMP_HI = 1,
+	SC_C_TEMP_LOW = 2,
+	SC_C_PXL_LINK_MST1_ADDR = 3,
+	SC_C_PXL_LINK_MST2_ADDR = 4,
+	SC_C_PXL_LINK_MST_ENB = 5,
+	SC_C_PXL_LINK_MST1_ENB = 6,
+	SC_C_PXL_LINK_MST2_ENB = 7,
+	SC_C_PXL_LINK_SLV1_ADDR = 8,
+	SC_C_PXL_LINK_SLV2_ADDR = 9,
+	SC_C_PXL_LINK_MST_VLD = 10,
+	SC_C_PXL_LINK_MST1_VLD = 11,
+	SC_C_PXL_LINK_MST2_VLD = 12,
+	SC_C_SINGLE_MODE = 13,
+	SC_C_ID = 14,
+	SC_C_PXL_CLK_POLARITY = 15,
+	SC_C_LINESTATE = 16,
+	SC_C_PCIE_G_RST = 17,
+	SC_C_PCIE_BUTTON_RST = 18,
+	SC_C_PCIE_PERST = 19,
+	SC_C_PHY_RESET = 20,
+	SC_C_PXL_LINK_RATE_CORRECTION = 21,
+	SC_C_PANIC = 22,
+	SC_C_PRIORITY_GROUP = 23,
+	SC_C_TXCLK = 24,
+	SC_C_CLKDIV = 25,
+	SC_C_DISABLE_50 = 26,
+	SC_C_DISABLE_125 = 27,
+	SC_C_SEL_125 = 28,
+	SC_C_MODE = 29,
+	SC_C_SYNC_CTRL0 = 30,
+	SC_C_KACHUNK_CNT = 31,
+	SC_C_KACHUNK_SEL = 32,
+	SC_C_SYNC_CTRL1 = 33,
+	SC_C_DPI_RESET = 34,
+	SC_C_MIPI_RESET = 35,
+	SC_C_DUAL_MODE = 36,
+	SC_C_VOLTAGE = 37,
+	SC_C_PXL_LINK_SEL = 38,
+	SC_C_OFS_SEL = 39,
+	SC_C_OFS_AUDIO = 40,
+	SC_C_OFS_PERIPH = 41,
+	SC_C_OFS_IRQ = 42,
+	SC_C_RST0 = 43,
+	SC_C_RST1 = 44,
+	SC_C_LAST
+} sc_ctrl_t;
+
+/*!
+ * This type is used to indicate a pad. Valid values are SoC specific.
+ *
+ * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
+ */
+typedef uint16_t sc_pad_t;
+
+/* Extra documentation of standard types */
+
+#ifdef DOXYGEN
+    /*!
+     * Type used to declare a true/false boolean.
+     */
+typedef enum { false = 0, true = 1 } bool;
+
+    /*!
+     * Type used to declare an 8-bit integer.
+     */
+typedef __INT8_TYPE__ int8_t;
+
+    /*!
+     * Type used to declare a 16-bit integer.
+     */
+typedef __INT16_TYPE__ int16_t;
+
+    /*!
+     * Type used to declare a 32-bit integer.
+     */
+typedef __INT32_TYPE__ int32_t;
+
+    /*!
+     * Type used to declare a 64-bit integer.
+     */
+typedef __INT64_TYPE__ int64_t;
+
+    /*!
+     * Type used to declare an 8-bit unsigned integer.
+     */
+typedef __UINT8_TYPE__ uint8_t;
+
+    /*!
+     * Type used to declare a 16-bit unsigned integer.
+     */
+typedef __UINT16_TYPE__ uint16_t;
+
+    /*!
+     * Type used to declare a 32-bit unsigned integer.
+     */
+typedef __UINT32_TYPE__ uint32_t;
+
+    /*!
+     * Type used to declare a 64-bit unsigned integer.
+     */
+typedef __UINT64_TYPE__ uint64_t;
+#endif
+
+#endif				/* _SC_TYPES_H */
-- 
1.7.9.5


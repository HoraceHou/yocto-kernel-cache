From 755eb27fc4cca1bf629d77d89a29b323a0854ae6 Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Fri, 27 Jul 2018 15:52:48 +0300
Subject: [PATCH 4850/5242] MLK-18789-4: drm/mxsfb: Update mxsfb to support
 LCD reset

commit  37b999a6c05286a9b953bd46f0bd52f47814bd91 from
https://source.codeaurora.org/external/imx/linux-imx.git

The eLCDIF controller has control pin for the external LCD reset pin.
Add support for it and assert this pin in enable and de-assert it in
disable.
Also, correct the pm_runtime_enable call, since it was made too early in
the probe, causing issues to DRM enable routines.

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/mxsfb/mxsfb_crtc.c |   12 ++++++++++--
 drivers/gpu/drm/mxsfb/mxsfb_drv.c  |   20 ++++++++------------
 drivers/gpu/drm/mxsfb/mxsfb_regs.h |    1 +
 3 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/mxsfb/mxsfb_crtc.c b/drivers/gpu/drm/mxsfb/mxsfb_crtc.c
index a54c9f5..942c037 100644
--- a/drivers/gpu/drm/mxsfb/mxsfb_crtc.c
+++ b/drivers/gpu/drm/mxsfb/mxsfb_crtc.c
@@ -232,9 +232,12 @@ static void mxsfb_enable_controller(struct mxsfb_drm_private *mxsfb)
 	clk_prepare_enable(mxsfb->clk);
 	mxsfb_enable_axi_clk(mxsfb);
 
-	if (mxsfb->devdata->ipversion >= 4)
+	if (mxsfb->devdata->ipversion >= 4) {
 		writel(CTRL2_OUTSTANDING_REQS(REQ_16),
 			mxsfb->base + LCDC_V4_CTRL2 + REG_SET);
+		/* Assert LCD Reset bit */
+		writel(CTRL2_LCD_RESET, mxsfb->base + LCDC_V4_CTRL2 + REG_SET);
+	}
 
 	/* If it was disabled, re-enable the mode again */
 	writel(CTRL_DOTCLK_MODE, mxsfb->base + LCDC_CTRL + REG_SET);
@@ -254,9 +257,12 @@ static void mxsfb_disable_controller(struct mxsfb_drm_private *mxsfb)
 {
 	u32 reg;
 
-	if (mxsfb->devdata->ipversion >= 4)
+	if (mxsfb->devdata->ipversion >= 4) {
 		writel(CTRL2_OUTSTANDING_REQS(0x7),
 			mxsfb->base + LCDC_V4_CTRL2 + REG_CLR);
+		/* De-assert LCD Reset bit */
+		writel(CTRL2_LCD_RESET, mxsfb->base + LCDC_V4_CTRL2 + REG_CLR);
+	}
 
 	writel(CTRL_RUN, mxsfb->base + LCDC_CTRL + REG_CLR);
 
@@ -339,6 +345,8 @@ static void mxsfb_crtc_mode_set_nofb(struct mxsfb_drm_private *mxsfb)
 		return;
 
 	clk_set_rate(mxsfb->clk, m->crtc_clock * 1000);
+	DRM_DEV_DEBUG_DRIVER(mxsfb->dev, "Pixel clock: %dkHz (actual: %dkHz)\n",
+		m->crtc_clock, (int)(clk_get_rate(mxsfb->clk) / 1000));
 
 	DRM_DEV_DEBUG_DRIVER(mxsfb->dev,
 		"Connector bus_flags: 0x%08X\n", bus_flags);
diff --git a/drivers/gpu/drm/mxsfb/mxsfb_drv.c b/drivers/gpu/drm/mxsfb/mxsfb_drv.c
index b033a5c..6a67120 100644
--- a/drivers/gpu/drm/mxsfb/mxsfb_drv.c
+++ b/drivers/gpu/drm/mxsfb/mxsfb_drv.c
@@ -284,7 +284,7 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 	if (IS_ERR(mxsfb->base))
 		return PTR_ERR(mxsfb->base);
 
-	mxsfb->clk = devm_clk_get(drm->dev, NULL);
+	mxsfb->clk = devm_clk_get(drm->dev, "pix");
 	if (IS_ERR(mxsfb->clk))
 		return PTR_ERR(mxsfb->clk);
 
@@ -300,12 +300,10 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 	if (ret)
 		return ret;
 
-	pm_runtime_enable(drm->dev);
-
 	ret = drm_vblank_init(drm, MAX_CRTCS);
 	if (ret < 0) {
 		dev_err(drm->dev, "Failed to initialise vblank\n");
-		goto err_vblank;
+		return ret;
 	}
 
 	/* Modeset init */
@@ -314,7 +312,7 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 	ret = mxsfb_create_output(drm);
 	if (ret < 0) {
 		dev_err(drm->dev, "Failed to create outputs\n");
-		goto err_vblank;
+		return ret;
 	}
 
 	ret = drm_simple_display_pipe_init(drm, &mxsfb->pipe, &mxsfb_funcs,
@@ -322,7 +320,7 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 			mxsfb->connector);
 	if (ret < 0) {
 		dev_err(drm->dev, "Cannot setup simple display pipe\n");
-		goto err_vblank;
+		return ret;
 	}
 
 	drm_crtc_vblank_off(&mxsfb->pipe.crtc);
@@ -339,14 +337,14 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 		ret = drm_panel_attach(mxsfb->panel, mxsfb->connector);
 		if (ret) {
 			dev_err(drm->dev, "Cannot connect panel\n");
-			goto err_vblank;
+			return ret;
 		}
 	} else if (mxsfb->bridge) {
 		ret = drm_simple_display_pipe_attach_bridge(&mxsfb->pipe,
 				mxsfb->bridge);
 		if (ret) {
 			dev_err(drm->dev, "Cannot connect bridge\n");
-			goto err_vblank;
+			return ret;
 		}
 	}
 
@@ -365,9 +363,7 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 
 	drm_mode_config_reset(drm);
 
-	pm_runtime_get_sync(drm->dev);
 	ret = drm_irq_install(drm, platform_get_irq(pdev, 0));
-	pm_runtime_put_sync(drm->dev);
 
 	if (ret < 0) {
 		dev_err(drm->dev, "Failed to install IRQ handler\n");
@@ -388,14 +384,14 @@ static int mxsfb_load(struct drm_device *drm, unsigned long flags)
 
 	drm_helper_hpd_irq_event(drm);
 
+	pm_runtime_enable(drm->dev);
+
 	return 0;
 
 err_cma:
 	drm_irq_uninstall(drm);
 err_irq:
 	drm_panel_detach(mxsfb->panel);
-err_vblank:
-	pm_runtime_disable(drm->dev);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/mxsfb/mxsfb_regs.h b/drivers/gpu/drm/mxsfb/mxsfb_regs.h
index b8ceeb3..0a4c76d 100644
--- a/drivers/gpu/drm/mxsfb/mxsfb_regs.h
+++ b/drivers/gpu/drm/mxsfb/mxsfb_regs.h
@@ -95,6 +95,7 @@
 #define CTRL2_OUTSTANDING_REQS(x)	REG_PUT((x), 23, 21)
 #define CTRL2_ODD_LINE_PATTERN(x)	REG_PUT((x), 18, 16)
 #define CTRL2_EVEN_LINE_PATTERN(x)	REG_PUT((x), 14, 12)
+#define CTRL2_LCD_RESET			BIT(0)
 
 #define TRANSFER_COUNT_SET_VCOUNT(x)	(((x) & 0xffff) << 16)
 #define TRANSFER_COUNT_GET_VCOUNT(x)	(((x) >> 16) & 0xffff)
-- 
1.7.9.5


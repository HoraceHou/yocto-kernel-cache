From 1532287cb5956f0121892f265bcea9a86c1f7ec2 Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Wed, 13 Dec 2017 15:15:40 +0800
Subject: [PATCH 3112/5242] MLK-17088: mipi_csi: improve the compatiblility of
 S_FMT

commit  c4dc557a0787e94d3c5d50383b662a0d1ebefc3c from
https://source.codeaurora.org/external/imx/linux-imx.git

1) When app call S_FMT ioctl, they may only set width, height
   and format of image. So driver can't determine whether it
   support the specified format by checking the format fourcc
   value and the plane number.

2) Driver should also fill plane and sizeimage member in S_FMT
   ioctl, because some apps use this information after they call
   S_FMT ioctl, such as gstreamer.

Reviewed-by: Sandor.Yu <sandor.yu@nxp.com>
Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/mxc-isi-cap.c |   24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/drivers/media/platform/imx8/mxc-isi-cap.c b/drivers/media/platform/imx8/mxc-isi-cap.c
index e9e61c1..1667da1 100644
--- a/drivers/media/platform/imx8/mxc-isi-cap.c
+++ b/drivers/media/platform/imx8/mxc-isi-cap.c
@@ -652,7 +652,7 @@ static int mxc_isi_cap_try_fmt_mplane(struct file *file, void *fh,
 
 	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
 		fmt = &mxc_isi_out_formats[i];
-		if (fmt->fourcc == pix->pixelformat && fmt->memplanes == pix->num_planes)
+		if (fmt->fourcc == pix->pixelformat)
 			break;
 	}
 	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
@@ -660,6 +660,12 @@ static int mxc_isi_cap_try_fmt_mplane(struct file *file, void *fh,
 		return -EINVAL;
 	}
 
+	if (pix->width <= 0 || pix->height <= 0) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, width %d, height %d is not valid\n",
+				__func__, pix->width, pix->height);
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -738,6 +744,7 @@ static int mxc_isi_cap_s_fmt_mplane(struct file *file, void *priv,
 	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
 	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
 	struct mxc_isi_fmt *fmt;
+	int bpl;
 	int i;
 
 	/* Step1: Check format with output support format list.
@@ -757,9 +764,10 @@ static int mxc_isi_cap_s_fmt_mplane(struct file *file, void *priv,
 	/* Check out put format */
 	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
 		fmt = &mxc_isi_out_formats[i];
-		if (fmt->fourcc == pix->pixelformat && fmt->memplanes == pix->num_planes)
+		if (pix && fmt->fourcc == pix->pixelformat)
 			break;
 	}
+
 	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
 		dev_dbg(&mxc_isi->pdev->dev, "%s, format is not support!\n", __func__);
 		return -EINVAL;
@@ -773,6 +781,18 @@ static int mxc_isi_cap_s_fmt_mplane(struct file *file, void *priv,
 	dst_f->height = pix->height;
 	dst_f->width = pix->width;
 
+	pix->num_planes = fmt->memplanes;
+
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+						(pix->width * fmt->depth[i]) >> 3;
+		if (pix->plane_fmt[i].sizeimage == 0)
+			pix->plane_fmt[i].sizeimage = (pix->width * pix->height *
+						fmt->depth[i] >> 3);
+	}
+
 	if (pix->num_planes > 1) {
 		for (i = 0; i < pix->num_planes; i++) {
 			dst_f->bytesperline[i] = pix->plane_fmt[i].bytesperline;
-- 
1.7.9.5


From cd2dff18de1830fbe2db6cbb0b50bb608c272f04 Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Fri, 2 Feb 2018 15:41:14 +0800
Subject: [PATCH 3403/5242] MLK-17489-3: hdp: use the drm debug log

commit  d8faf554c45c40ef8fdc770366b6ab08664a08c1 from
https://source.codeaurora.org/external/imx/linux-imx.git

Use drm debug log function.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c   |   59 ++++++++++----------
 drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c    |   57 +++++++++----------
 drivers/gpu/drm/imx/hdp/imx-dp.c                   |   34 +++++------
 drivers/gpu/drm/imx/hdp/imx-hdmi.c                 |   38 ++++++-------
 drivers/gpu/drm/imx/hdp/imx-hdp.c                  |    7 +--
 5 files changed, 98 insertions(+), 97 deletions(-)

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
index 1802e73..328e584 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
@@ -44,6 +44,7 @@
  ******************************************************************************
  */
 
+#include <drm/drmP.h>
 #include <linux/io.h>
 #include "API_AFE_ss28fdsoi_kiran_hdmitx.h"
 #include "ss28fdsoi_hdmitx_table.h"
@@ -175,7 +176,7 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 	charge_pump_gain.msb = 8;
 	charge_pump_gain.lsb = 0;
 
-	pr_info
+	DRM_INFO
 	    ("phy_cfg_hdp() num_lanes: %0d, vicMode: %0d, color depth: %0d-bit, encoding: %0d\n",
 	     num_lanes, vicMode, bpp, format);
 
@@ -308,11 +309,11 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 	/* Check if row was found */
 	ftemp = pixel_freq_khz;
 	if (row + 1) {
-		pr_info
+		DRM_INFO
 		    ("Pixel clock frequency (%u kHz) is supported in this color depth (%0d-bit). Settings found in row %0d\n",
 		     ftemp, bpp, row);
 	} else {
-		pr_info
+		DRM_INFO
 		    ("Pixel clock frequency (%u kHz) not supported for this color depth (%0d-bit), row=%d\n",
 		     ftemp, bpp, row);
 	}
@@ -320,7 +321,7 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 	    pixel_freq_khz * character_clock_ratio_num /
 	    character_clock_ratio_den;
 	ftemp = character_freq_khz;
-	pr_info("Character clock frequency: %u kHz.\n", ftemp);
+	DRM_INFO("Character clock frequency: %u kHz.\n", ftemp);
 
 	/* Extract particular values from the ss28fdsoi_hdmitx_clock_control_table table */
 	set_field_value(&cmnda_pll0_hs_sym_div_sel,
@@ -357,27 +358,27 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 			[PLL_FB_DIV_TOTAL]);
 
 	/* Display parameters (informative message) */
-	pr_info("set_field_value() cmnda_pll0_hs_sym_div_sel : 0x%X\n",
+	DRM_DEBUG("set_field_value() cmnda_pll0_hs_sym_div_sel : 0x%X\n",
 		cmnda_pll0_hs_sym_div_sel.value);
-	pr_info("set_field_value() cmnda_pll0_ip_div         : 0x%02X\n",
+	DRM_DEBUG("set_field_value() cmnda_pll0_ip_div         : 0x%02X\n",
 		cmnda_pll0_ip_div.value);
-	pr_info("set_field_value() cmnda_pll0_fb_div_low     : 0x%03X\n",
+	DRM_DEBUG("set_field_value() cmnda_pll0_fb_div_low     : 0x%03X\n",
 		cmnda_pll0_fb_div_low.value);
-	pr_info("set_field_value() cmnda_pll0_fb_div_high    : 0x%03X\n",
+	DRM_DEBUG("set_field_value() cmnda_pll0_fb_div_high    : 0x%03X\n",
 		cmnda_pll0_fb_div_high.value);
-	pr_info("set_field_value() cmn_ref_clk_dig_div       : 0x%X\n",
+	DRM_DEBUG("set_field_value() cmn_ref_clk_dig_div       : 0x%X\n",
 		cmn_ref_clk_dig_div.value);
-	pr_info("set_field_value() divider_scaler            : 0x%X\n",
+	DRM_DEBUG("set_field_value() divider_scaler            : 0x%X\n",
 		divider_scaler.value);
-	pr_info("set_field_value() cmnda_hs_clk_0_sel        : %0d\n",
+	DRM_DEBUG("set_field_value() cmnda_hs_clk_0_sel        : %0d\n",
 		cmnda_hs_clk_0_sel.value);
-	pr_info("set_field_value() cmnda_hs_clk_1_sel        : %0d\n",
+	DRM_DEBUG("set_field_value() cmnda_hs_clk_1_sel        : %0d\n",
 		cmnda_hs_clk_1_sel.value);
-	pr_info("set_field_value() tx_subrate                : %0d\n",
+	DRM_DEBUG("set_field_value() tx_subrate                : %0d\n",
 		tx_subrate.value);
-	pr_info("set_field_value() vco_ring_select           : %0d\n",
+	DRM_DEBUG("set_field_value() vco_ring_select           : %0d\n",
 		vco_ring_select.value);
-	pr_info("set_field_value() pll_feedback_divider_total: %0d\n",
+	DRM_DEBUG("set_field_value() pll_feedback_divider_total: %0d\n",
 		pll_feedback_divider_total.value);
 
 	vco_freq_khz =
@@ -398,11 +399,11 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 			  pll_feedback_divider_total.value);
 	ftemp = vco_freq_khz;
 	if (row + 1) {
-		pr_info
+		DRM_INFO
 		    ("VCO frequency (%u kHz) is supported. Settings found in row %0d\n",
 		     ftemp, row);
 	} else {
-		pr_info("VCO frequency (%u kHz) not supported\n", ftemp);
+		DRM_INFO("VCO frequency (%u kHz) not supported\n", ftemp);
 	}
 
 	/* Extract particular values from the ss28fdsoi_hdmitx_pll_tuning_table table */
@@ -423,17 +424,17 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 			[CHARGE_PUMP_GAIN]);
 
 	/* Display parameters (informative message) */
-	pr_info("set_field_value() voltage_to_current_coarse : 0x%X\n",
+	DRM_DEBUG("set_field_value() voltage_to_current_coarse : 0x%X\n",
 		voltage_to_current_coarse.value);
-	pr_info("set_field_value() voltage_to_current        : 0x%X\n",
+	DRM_DEBUG("set_field_value() voltage_to_current        : 0x%X\n",
 		voltage_to_current.value);
-	pr_info("set_field_value() ndac_ctrl                 : 0x%X\n",
+	DRM_DEBUG("set_field_value() ndac_ctrl                 : 0x%X\n",
 		ndac_ctrl.value);
-	pr_info("set_field_value() pmos_ctrl                 : 0x%02X\n",
+	DRM_DEBUG("set_field_value() pmos_ctrl                 : 0x%02X\n",
 		pmos_ctrl.value);
-	pr_info("set_field_value() ptat_ndac_ctrl            : 0x%02X\n",
+	DRM_DEBUG("set_field_value() ptat_ndac_ctrl            : 0x%02X\n",
 		ptat_ndac_ctrl.value);
-	pr_info("set_field_value() charge_pump_gain          : 0x%03X\n",
+	DRM_DEBUG("set_field_value() charge_pump_gain          : 0x%03X\n",
 		charge_pump_gain.value);
 
 	/* ---------------------------------------------------------------
@@ -579,7 +580,7 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 
 static void arc_power_up(state_struct *state)
 {
-	pr_info("arc_power_up()\n");
+	DRM_DEBUG("arc_power_up()\n");
 
 	/* register CMN_RXCAL_OVRD */
 	Afe_write(state, 0x5025, 0x0001);
@@ -595,7 +596,7 @@ static void arc_calibrate(state_struct *state)
 	uint16_t new_calib_code;
 	uint16_t rdata;
 
-	pr_info("aux_cal_cfg() ARC programming\n");
+	DRM_DEBUG("aux_cal_cfg() ARC programming\n");
 	/* register TX_DIG_CTRL_REG_2 */
 	prev_calib_code = Afe_read(state, 0x5024);
 	/* register CMN_TXPUCAL_CTRL */
@@ -628,7 +629,7 @@ static void arc_calibrate(state_struct *state)
 
 static void arc_config(state_struct *state)
 {
-	pr_info("arc_config() ARC programming\n");
+	DRM_DEBUG("arc_config() ARC programming\n");
 
 	/* register TX_ANA_CTRL_REG_2 */
 	Afe_write(state, 0x5021, 0x0100);
@@ -672,9 +673,9 @@ int hdmi_tx_kiran_power_configuration_seq(state_struct *state, int num_lanes)
 	while (!(Afe_read(state, 0xC008) & (1 << 6))) ;
 
 #ifdef __ARC_CONFIG__
-	arc_power_up();
-	arc_calibrate();
-	arc_config();
+	arc_power_up(state);
+	arc_calibrate(state);
+	arc_config(state);
 #endif
 
 	/* PHY_DP_MODE_CTL */
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
index c6c7035..74cfaf4 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
@@ -44,6 +44,7 @@
  ******************************************************************************
  */
 
+#include <drm/drmP.h>
 #include "API_AFE_t28hpc_hdmitx.h"
 
 static char inside(u32 value, u32 left_sharp_corner,
@@ -119,7 +120,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 	cmnda_pll0_fb_div_high.value = 0x00A;
 	ftemp = pixel_freq_khz;
 
-	pr_info(" VIC %d, pixel clock %u kHz\n", vicMode, ftemp);
+	DRM_INFO(" VIC %d, pixel clock %u kHz\n", vicMode, ftemp);
 
 	/* Set field position */
 	cmnda_pll0_hs_sym_div_sel.msb = 9;
@@ -227,7 +228,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 			character_clock_ratio_den = 1;
 			break;
 		default:
-			pr_warn("Invalid ColorDepth\n");
+			DRM_WARN("Invalid ColorDepth\n");
 		}
 		break;
 
@@ -260,7 +261,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 	    character_clock_ratio_num / character_clock_ratio_den;
 	ftemp = pixel_freq_khz;
 	ftemp2 = character_freq_khz;
-	pr_info
+	DRM_INFO
 	    ("Pixel clock frequency: %u kHz, character clock frequency: %u, color depth is %0d-bit.\n",
 	     ftemp, ftemp2, bpp);
 	if (pixel_clk_from_phy == 0) {
@@ -348,7 +349,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 						400);
 			} else {
 				ftemp = pixel_freq_khz;
-				pr_warn
+				DRM_WARN
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			}
@@ -422,7 +423,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 						400);
 			} else {
 				ftemp = pixel_freq_khz;
-				pr_info
+				DRM_ERROR
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			}
@@ -495,7 +496,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 						360);
 			} else {
 				ftemp = pixel_freq_khz;
-				pr_info
+				DRM_ERROR
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			}
@@ -555,7 +556,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 						400);
 			} else {
 				ftemp = pixel_freq_khz;
-				pr_info
+				DRM_ERROR
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			}
@@ -563,7 +564,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 		case CLK_RATIO_1_2:
 			if (!(inside(pixel_freq_khz, 594000, 594000))) {
 				ftemp = pixel_freq_khz;
-				pr_info
+				DRM_ERROR
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			} else {
@@ -584,7 +585,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 		case CLK_RATIO_5_8:
 			if (!(inside(pixel_freq_khz, 594000, 594000))) {
 				ftemp = pixel_freq_khz;
-				pr_info
+				DRM_ERROR
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			} else {
@@ -605,7 +606,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 		case CLK_RATIO_3_4:
 			if (!(inside(pixel_freq_khz, 594000, 594000))) {
 				ftemp = pixel_freq_khz;
-				pr_info
+				DRM_ERROR
 				    ("Pixel clock frequency (%u) is outside of the supported range\n",
 				     ftemp);
 			} else {
@@ -628,7 +629,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 		    pixel_freq_khz * pll_feedback_divider_total.value /
 		    cmnda_pll0_ip_div.value;
 		ftemp = vco_freq;
-		pr_info("VCO frequency is %u kHz\n", ftemp);
+		DRM_INFO("VCO frequency is %u kHz\n", ftemp);
 
 		if (inside(vco_freq, 1700000, 2000000)) {
 			set_field_value(&voltage_to_current_coarse, 0x04);
@@ -659,7 +660,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0xA2);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -692,7 +693,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x84);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -725,7 +726,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x81);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -758,7 +759,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x46);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -779,7 +780,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x85);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -800,7 +801,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x82);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -818,7 +819,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x4A);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
@@ -836,12 +837,12 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				set_field_value(&charge_pump_gain, 0x45);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
 				     pll_feedback_divider_total.value, ftemp);
 			}
 		} else
-			pr_warn
+			DRM_WARN
 			    ("VCO frequency %u kHz is outside of the supported range\n",
 			     ftemp);
 
@@ -1415,7 +1416,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 				break;
 			default:
 				ftemp = pixel_freq_khz;
-				pr_warn
+				DRM_WARN
 				    ("This pixel clock frequency (%u kHz) is not supported with this (%0d-bit) color depth.\n",
 				     ftemp, bpp);
 			}
@@ -1494,13 +1495,13 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 						0x00);
 				break;
 			default:
-				pr_warn
+				DRM_WARN
 				    ("This pixel clock frequency (%d KHz) is not supported with this (%0d-bit) color depth.\n",
 				     pixel_freq_khz, bpp);
 			}
 		} else {
 			ftemp = pixel_freq_khz;
-			pr_warn
+			DRM_WARN
 			    ("This pixel clock frequency (%u kHz) is not supported.\n",
 			     ftemp);
 		}
@@ -1509,7 +1510,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 		    refclk_freq_khz * pll_feedback_divider_total.value /
 		    cmnda_pll0_ip_div.value;
 		ftemp = vco_freq;
-		pr_info("VCO frequency is %u kHz\n", ftemp);
+		DRM_INFO("VCO frequency is %u kHz\n", ftemp);
 
 		if (inside(vco_freq, 1980000, 1980000)) {
 			set_field_value(&voltage_to_current_coarse, 0x04);
@@ -1654,7 +1655,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 			set_field_value(&vco_cal_code, 292);
 		} else {
 			ftemp = vco_freq;
-			pr_warn("Current vco_freq (%u kHz) is not supported.\n",
+			DRM_WARN("Current vco_freq (%u kHz) is not supported.\n",
 			       ftemp);
 		}
 
@@ -1826,7 +1827,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 
 static void arc_power_up(state_struct *state)
 {
-	pr_info("arc_power_up()\n");
+	DRM_DEBUG("arc_power_up()\n");
 
 	/* register CMN_RXCAL_OVRD */
 	Afe_write(state, 0x5025, 0x0001);
@@ -1842,7 +1843,7 @@ static void arc_calibrate(state_struct *state)
 	uint16_t new_calib_code;
 	uint16_t rdata;
 
-	pr_info("aux_cal_cfg() ARC programming\n");
+	DRM_DEBUG("aux_cal_cfg() ARC programming\n");
 	/* register TX_DIG_CTRL_REG_2 */
 	prev_calib_code = Afe_read(state, 0x5024);
 	/* register CMN_TXPUCAL_CTRL */
@@ -1875,7 +1876,7 @@ static void arc_calibrate(state_struct *state)
 
 static void arc_config(state_struct *state)
 {
-	pr_info("arc_config() ARC programming\n");
+	DRM_DEBUG("arc_config() ARC programming\n");
 
 	/* register TX_ANA_CTRL_REG_2 */
 	Afe_write(state, 0x5021, 0x0100);
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.c b/drivers/gpu/drm/imx/hdp/imx-dp.c
index cfdd3c1..f48968a 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.c
@@ -23,7 +23,7 @@
 #ifdef DEBUG_FW_LOAD
 void dp_fw_load(state_struct *state)
 {
-	pr_info("loading hdmi firmware\n");
+	DRM_INFO("loading hdmi firmware\n");
 	CDN_API_LoadFirmware(state,
 		(u8 *)mhdp_iram0_get_ptr(),
 		mhdp_iram0_get_size(),
@@ -47,33 +47,33 @@ int dp_fw_init(state_struct *state)
 	pr_info("CDN_API_SetClock completed\n");
 
 	cdn_apb_write(state, APB_CTRL << 2, 0);
-	pr_info("Started firmware!\n");
+	DRM_INFO("Started firmware!\n");
 
 	ret = CDN_API_CheckAlive_blocking(state);
 	if (ret != 0) {
-		pr_err("CDN_API_CheckAlive failed - check firmware!\n");
+		DRM_ERROR("CDN_API_CheckAlive failed - check firmware!\n");
 		return -ENXIO;
 	} else
-		pr_info("CDN_API_CheckAlive returned ret = %d\n", ret);
+		DRM_INFO("CDN_API_CheckAlive returned ret = %d\n", ret);
 
 	/* turn on IP activity */
 	ret = CDN_API_MainControl_blocking(state, 1, &resp);
-	pr_info("CDN_API_MainControl_blocking (ret = %d resp = %u)\n",
+	DRM_INFO("CDN_API_MainControl_blocking (ret = %d resp = %u)\n",
 		ret, resp);
 
 	ret = CDN_API_General_Test_Echo_Ext_blocking(state, echo_msg, echo_resp,
 		sizeof(echo_msg), CDN_BUS_TYPE_APB);
 	if (0 != strncmp(echo_msg, echo_resp, sizeof(echo_msg))) {
-		pr_err("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
+		DRM_ERROR("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
 		return -ENXIO;
 	}
-	pr_info("CDN_API_General_Test_Echo_Ext_blocking (ret = %d echo_resp = %s)\n",
+	DRM_INFO("CDN_API_General_Test_Echo_Ext_blocking (ret = %d echo_resp = %s)\n",
 		ret, echo_resp);
 
 	/* Line swaping */
 	CDN_API_General_Write_Register_blocking(state,
 		ADDR_SOURCD_PHY + (LANES_CONFIG << 2), 0x0040001b);
-	pr_info("CDN_API_General_Write_Register_blockin ... setting LANES_CONFIG\n");
+	DRM_INFO("CDN_API_General_Write_Register_blockin ... setting LANES_CONFIG\n");
 
 	return 0;
 }
@@ -90,19 +90,19 @@ int dp_phy_init(state_struct *state, int vic, int format, int color_depth)
 
 	/* PHY initialization while phy reset pin is active */
 	AFE_init(state, num_lanes, (ENUM_AFE_LINK_RATE)max_link_rate);
-	pr_info("AFE_init\n");
+	DRM_INFO("AFE_init\n");
 
 	/* In this point the phy reset should be deactivated */
 	imx_hdp_call(hdp, phy_reset, hdp->ipcHndl, 1);
-	pr_info("deasserted reset\n");
+	DRM_INFO("deasserted reset\n");
 
 	/* PHY power set */
 	AFE_power(state, num_lanes, (ENUM_AFE_LINK_RATE)max_link_rate);
-	pr_info("AFE_power exit\n");
+	DRM_INFO("AFE_power exit\n");
 
 	/* Video off */
 	ret = CDN_API_DPTX_SetVideo_blocking(state, 0);
-	pr_info("CDN_API_DPTX_SetVideo_blocking (ret = %d)\n", ret);
+	DRM_INFO("CDN_API_DPTX_SetVideo_blocking (ret = %d)\n", ret);
 
 	return true;
 }
@@ -151,7 +151,7 @@ void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int
 		lane_mapping,
 		ext_host_cap
 		);
-	pr_info("CDN_API_DPTX_SetHostCap_blocking (ret = %d)\n", ret);
+	DRM_INFO("CDN_API_DPTX_SetHostCap_blocking (ret = %d)\n", ret);
 
 	switch (max_link_rate) {
 	case 0x0a:
@@ -174,14 +174,14 @@ void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int
 		bt_type,
 		transfer_unit
 		);
-	pr_info("CDN_API_DPTX_Set_VIC_blocking (ret = %d)\n", ret);
+	DRM_INFO("CDN_API_DPTX_Set_VIC_blocking (ret = %d)\n", ret);
 
 	ret = CDN_API_DPTX_TrainingControl_blocking(state, 1);
-	pr_info("CDN_API_DPTX_TrainingControl_blocking (ret = %d)\n", ret);
+	DRM_INFO("CDN_API_DPTX_TrainingControl_blocking (ret = %d)\n", ret);
 
 	/* Set video on */
 	ret = CDN_API_DPTX_SetVideo_blocking(state, 1);
-	pr_info("CDN_API_DPTX_SetVideo_blocking (ret = %d)\n", ret);
+	DRM_INFO("CDN_API_DPTX_SetVideo_blocking (ret = %d)\n", ret);
 
 	udelay(1000);
 }
@@ -207,7 +207,7 @@ int dp_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)
 		ret = CDN_API_DPTX_Read_EDID_blocking(state, 1, 1, &edidResp);
 		break;
 	default:
-		pr_warn("EDID block %x read not support\n", block);
+		DRM_WARN("EDID block %x read not support\n", block);
 	}
 
 	memcpy(buf, edidResp.buff, 128);
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.c b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
index 2db6873..bdcab75 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
@@ -25,7 +25,7 @@
 #ifdef DEBUG_FW_LOAD
 void hdmi_fw_load(state_struct *state)
 {
-	pr_info("loading hdmi firmware\n");
+	DRM_INFO("loading hdmi firmware\n");
 	CDN_API_LoadFirmware(state,
 		(u8 *)hdmitx_iram0_get_ptr(),
 		hdmitx_iram0_get_size(),
@@ -50,27 +50,27 @@ int hdmi_fw_init(state_struct *state)
 
 	/* moved from CDN_API_LoadFirmware */
 	cdn_apb_write(state, APB_CTRL << 2, 0);
-	pr_info("Started firmware!\n");
+	DRM_INFO("Started firmware!\n");
 
 	ret = CDN_API_CheckAlive_blocking(state);
 	if (ret != 0) {
-		pr_err("CDN_API_CheckAlive failed - check firmware!\n");
+		DRM_ERROR("CDN_API_CheckAlive failed - check firmware!\n");
 		return -ENXIO;
 	} else
-		pr_info("CDN_API_CheckAlive returned ret = %d\n", ret);
+		DRM_INFO("CDN_API_CheckAlive returned ret = %d\n", ret);
 
 	/* turn on IP activity */
 	ret = CDN_API_MainControl_blocking(state, 1, &sts);
-	pr_info("CDN_API_MainControl_blocking ret = %d sts = %u\n", ret, sts);
+	DRM_INFO("CDN_API_MainControl_blocking ret = %d sts = %u\n", ret, sts);
 
 	ret = CDN_API_General_Test_Echo_Ext_blocking(state, echo_msg, echo_resp,
 		 sizeof(echo_msg), CDN_BUS_TYPE_APB);
 
 	if (0 != strncmp(echo_msg, echo_resp, sizeof(echo_msg))) {
-		pr_err("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
+		DRM_ERROR("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
 		return -ENXIO;
 	}
-	pr_info("CDN_API_General_Test_Echo_Ext_blocking - APB(ret = %d echo_resp = %s)\n",
+	DRM_INFO("CDN_API_General_Test_Echo_Ext_blocking - APB(ret = %d echo_resp = %s)\n",
 		  ret, echo_resp);
 
 	return 0;
@@ -96,7 +96,7 @@ int hdmi_phy_init(state_struct *state, int vic, int format, int color_depth)
 		F_SOURCE_PHY_LANE0_SWAP(3) | F_SOURCE_PHY_LANE1_SWAP(0) |
 		F_SOURCE_PHY_LANE2_SWAP(1) | F_SOURCE_PHY_LANE3_SWAP(2) |
 		F_SOURCE_PHY_COMB_BYPASS(0) | F_SOURCE_PHY_20_10(1));
-	pr_info("CDN_API_General_Write_Register_blocking LANES_CONFIG ret = %d\n", ret);
+	DRM_INFO("CDN_API_General_Write_Register_blocking LANES_CONFIG ret = %d\n", ret);
 
 	return true;
 }
@@ -115,26 +115,26 @@ void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, in
 
 	ret = CDN_API_HDMITX_Init_blocking(state);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_STATUS CDN_API_HDMITX_Init_blocking  ret = %d\n", ret);
+		DRM_INFO("CDN_API_STATUS CDN_API_HDMITX_Init_blocking  ret = %d\n", ret);
 		return;
 	}
 
 	/* Set HDMI TX Mode */
 	ret = CDN_API_HDMITX_Set_Mode_blocking(state, ptype, character_freq_khz);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_HDMITX_Set_Mode_blocking ret = %d\n", ret);
+		DRM_INFO("CDN_API_HDMITX_Set_Mode_blocking ret = %d\n", ret);
 		return;
 	}
 
 	ret = CDN_API_Set_AVI(state, vic, format, bw_type);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_Set_AVI  ret = %d\n", ret);
+		DRM_INFO("CDN_API_Set_AVI  ret = %d\n", ret);
 		return;
 	}
 
 	ret =  CDN_API_HDMITX_SetVic_blocking(state, vic, color_depth, format);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
+		DRM_INFO("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
 		return;
 	}
 
@@ -153,7 +153,7 @@ int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_dep
 
 	ret = CDN_API_CheckAlive_blocking(state);
 	if (ret != 0) {
-		pr_err("NO HDMI FW running\n");
+		DRM_ERROR("NO HDMI FW running\n");
 		return -ENXIO;
 	}
 
@@ -161,7 +161,7 @@ int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_dep
 						     sizeof(echo_msg),
 						     CDN_BUS_TYPE_APB);
 	if (ret != 0) {
-		pr_err("HDMI mailbox access failed\n");
+		DRM_ERROR("HDMI mailbox access failed\n");
 		return -ENXIO;
 	}
 
@@ -181,7 +181,7 @@ int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_dep
 						    F_SOURCE_PHY_LANE3_SWAP(3) |
 						    F_SOURCE_PHY_COMB_BYPASS(0)
 						    | F_SOURCE_PHY_20_10(1));
-	pr_info
+	DRM_INFO
 	    ("CDN_API_General_Write_Register_blocking LANES_CONFIG ret = %d\n",
 	     ret);
 
@@ -204,26 +204,26 @@ void hdmi_mode_set_t28hpc(state_struct *state, int vic, int format, int color_de
 
 	ret = CDN_API_HDMITX_Init_blocking(state);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_STATUS CDN_API_HDMITX_Init_blocking  ret = %d\n", ret);
+		DRM_ERROR("CDN_API_STATUS CDN_API_HDMITX_Init_blocking  ret = %d\n", ret);
 		return;
 	}
 
 	/* Set HDMI TX Mode */
 	ret = CDN_API_HDMITX_Set_Mode_blocking(state, ptype, character_freq_khz);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_HDMITX_Set_Mode_blocking ret = %d\n", ret);
+		DRM_ERROR("CDN_API_HDMITX_Set_Mode_blocking ret = %d\n", ret);
 		return;
 	}
 
 	ret = CDN_API_Set_AVI(state, vic, format, bw_type);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_Set_AVI  ret = %d\n", ret);
+		DRM_ERROR("CDN_API_Set_AVI  ret = %d\n", ret);
 		return;
 	}
 
 	ret = CDN_API_HDMITX_SetVic_blocking(state, vic, color_depth, format);
 	if (ret != CDN_OK) {
-		pr_info("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
+		DRM_ERROR("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
 		return;
 	}
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index f6826a1..829de39 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -97,13 +97,13 @@ int imx8qm_pixel_link_init(state_struct *state)
 
 	sciErr = sc_ipc_getMuID(&hdp->mu_id);
 	if (sciErr != SC_ERR_NONE) {
-		pr_err("Cannot obtain MU ID\n");
+		DRM_ERROR("Cannot obtain MU ID\n");
 		return -EINVAL;
 	}
 
 	sciErr = sc_ipc_open(&hdp->ipcHndl, hdp->mu_id);
 	if (sciErr != SC_ERR_NONE) {
-		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
+		DRM_ERROR("sc_ipc_open failed! (sciError = %d)\n", sciErr);
 		return -EINVAL;
 	}
 
@@ -133,7 +133,7 @@ void imx8qm_phy_reset(sc_ipc_t ipcHndl, u8 reset)
 	/* set the pixel link mode and pixel type */
 	sciErr = sc_misc_set_control(ipcHndl, SC_R_HDMI, SC_C_PHY_RESET, reset);
 	if (sciErr != SC_ERR_NONE)
-		pr_err("SC_R_HDMI PHY reset failed %d!\n", sciErr);
+		DRM_ERROR("SC_R_HDMI PHY reset failed %d!\n", sciErr);
 }
 
 int imx8qm_clock_init(struct hdp_clks *clks)
@@ -1072,7 +1072,6 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	ret = imx_hdp_call(hdp, fw_init, &hdp->state);
 	if (ret < 0) {
-		pr_err("Failed to initialise HDP firmware\n");
 		DRM_ERROR("Failed to initialise HDP firmware\n");
 		return ret;
 	}
-- 
1.7.9.5


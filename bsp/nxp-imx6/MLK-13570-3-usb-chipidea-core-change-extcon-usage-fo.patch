From ea04d9edad4a0fae6fbc51231c661683b3fea814 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Tue, 6 Dec 2016 09:34:58 +0800
Subject: [PATCH 1340/5242] MLK-13570-3 usb: chipidea: core: change extcon
 usage for imx_4.1.y

commit  250779ccff9579a8c5b3d959a9079ebb50147341 from
https://source.codeaurora.org/external/imx/linux-imx.git

At v4.1 kernel, we can't get cable type at notifier, but at
extcon-usb-gpio.c notifies both VBUS and ID event, we had to
do special handling for ID event, and omit VBUS event. Current
implementation only supports ID extcon event.

If wakeup event occurs by extcon, it needs to call ci_irq again since the
first ci_irq calling at extcon notifier only wakes up controller, but
do noop for event handling.

Signed-off-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/chipidea/core.c |   41 ++++++++++++++++++++++++++++++++++++++---
 1 file changed, 38 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index 3f664c2..24a70f3 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -590,11 +590,22 @@ static int ci_cable_notifier(struct notifier_block *nb, unsigned long event,
 {
 	struct ci_hdrc_cable *cbl = container_of(nb, struct ci_hdrc_cable, nb);
 	struct ci_hdrc *ci = cbl->ci;
+	struct extcon_dev *dev = ptr;
+	int ret;
 
-	cbl->connected = event;
-	cbl->changed = true;
+	/* Only support ID extcon now */
+
+	ret = extcon_get_state(dev, EXTCON_USB_HOST);
+	if (ret && !cbl->connected) {
+		cbl->connected = true;
+		cbl->changed = true;
+		ci_irq(ci->irq, ci);
+	} else if (!ret && cbl->connected) {
+		cbl->connected = false;
+		cbl->changed = true;
+		ci_irq(ci->irq, ci);
+	}
 
-	ci_irq(ci->irq, ci);
 	return NOTIFY_DONE;
 }
 
@@ -1205,6 +1216,29 @@ static void ci_controller_suspend(struct ci_hdrc *ci)
 	enable_irq(ci->irq);
 }
 
+/*
+ * Handle the wakeup interrupt triggered by extcon connector
+ * We need to call ci_irq again for extcon since the first
+ * interrupt (wakeup int) only let the controller be out of
+ * low power mode, but not handle any interrupts.
+ */
+static void ci_extcon_wakeup_int(struct ci_hdrc *ci)
+{
+	struct ci_hdrc_cable *cable_id, *cable_vbus;
+	u32 otgsc = hw_read_otgsc(ci, ~0);
+
+	cable_id = &ci->platdata->id_extcon;
+	cable_vbus = &ci->platdata->vbus_extcon;
+
+	if (!IS_ERR(cable_id->edev) && ci->is_otg &&
+		(otgsc & OTGSC_IDIE) && (otgsc & OTGSC_IDIS))
+		ci_irq(ci->irq, ci);
+
+	if (!IS_ERR(cable_vbus->edev) && ci->is_otg &&
+		(otgsc & OTGSC_BSVIE) && (otgsc & OTGSC_BSVIS))
+		ci_irq(ci->irq, ci);
+}
+
 static int ci_controller_resume(struct device *dev)
 {
 	struct ci_hdrc *ci = dev_get_drvdata(dev);
@@ -1237,6 +1271,7 @@ static int ci_controller_resume(struct device *dev)
 		enable_irq(ci->irq);
 		if (ci_otg_is_fsm_mode(ci))
 			ci_otg_fsm_wakeup_by_srp(ci);
+		ci_extcon_wakeup_int(ci);
 	}
 
 	return 0;
-- 
1.7.9.5


From 792820c06db6dd353ced14ad9ed866b395bfd6c2 Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Mon, 3 Sep 2018 15:20:10 +0800
Subject: [PATCH 4573/5242] MLK-19514-1: ISI: correct capture and output
 meaning

commit  cc59622f9c0b3e6380d83accc9c09047ecb4b53b from
https://source.codeaurora.org/external/imx/linux-imx.git

According to V4L2 doc, cap_q_ctx is for "output to memory"
queue and out_q_ctx is for "input from memory", so capature
should represent for output of ISI and output should represent
for ISI's input. But I reversed their relationship, so correct
it.

Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/mxc-isi-m2m.c |  254 ++++++++++++++---------------
 1 file changed, 118 insertions(+), 136 deletions(-)

diff --git a/drivers/media/platform/imx8/mxc-isi-m2m.c b/drivers/media/platform/imx8/mxc-isi-m2m.c
index 334b423..4bb80f0 100644
--- a/drivers/media/platform/imx8/mxc-isi-m2m.c
+++ b/drivers/media/platform/imx8/mxc-isi-m2m.c
@@ -177,10 +177,10 @@ static int m2m_vb2_queue_setup(struct vb2_queue *q,
 		return -EINVAL;
 	}
 
-	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		frame = &mxc_isi->m2m.src_f;
-	else
+	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
 		frame = &mxc_isi->m2m.dst_f;
+	else
+		frame = &mxc_isi->m2m.src_f;
 
 	fmt = frame->fmt;
 	if (fmt == NULL)
@@ -214,10 +214,10 @@ static int m2m_vb2_buffer_prepare(struct vb2_buffer *vb2)
 	struct mxc_isi_frame *frame;
 	int i;
 
-	if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		frame = &mxc_isi->m2m.src_f;
-	else
+	if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
 		frame = &mxc_isi->m2m.dst_f;
+	else
+		frame = &mxc_isi->m2m.src_f;
 
 	if (frame == NULL)
 		return -EINVAL;
@@ -289,7 +289,7 @@ static int mxc_m2m_queue_init(void *priv, struct vb2_queue *src_vq,
 	struct mxc_isi_dev *mxc_isi = mxc_ctx->isi_dev;
 	int ret;
 
-	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
 	src_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
 	src_vq->drv_priv = mxc_ctx;
 	src_vq->buf_struct_size = sizeof(struct mxc_isi_buffer);
@@ -303,7 +303,7 @@ static int mxc_m2m_queue_init(void *priv, struct vb2_queue *src_vq,
 	if (ret)
 		return ret;
 
-	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
 	dst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
 	dst_vq->drv_priv = mxc_ctx;
 	dst_vq->buf_struct_size = sizeof(struct mxc_isi_buffer);
@@ -406,7 +406,7 @@ static int mxc_isi_m2m_querycap(struct file *file, void *priv,
 		 dev_name(&mxc_isi->pdev->dev), mxc_isi->id);
 
 	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE |
-		V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT_MPLANE;
+		V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT;
 	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
 
 	return 0;
@@ -419,10 +419,10 @@ static int mxc_isi_m2m_enum_fmt_vid_out(struct file *file, void *priv,
 	struct mxc_isi_fmt *fmt;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
-	if (f->index >= (int)ARRAY_SIZE(mxc_isi_out_formats))
+	if (f->index >= (int)ARRAY_SIZE(mxc_isi_input_formats))
 		return -EINVAL;
 
-	fmt = &mxc_isi_out_formats[f->index];
+	fmt = &mxc_isi_input_formats[f->index];
 	if (!fmt)
 		return -EINVAL;
 
@@ -440,10 +440,10 @@ static int mxc_isi_m2m_enum_fmt_vid_cap(struct file *file, void *priv,
 	struct mxc_isi_fmt *fmt;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
-	if (f->index >= (int)ARRAY_SIZE(mxc_isi_input_formats))
+	if (f->index >= (int)ARRAY_SIZE(mxc_isi_out_formats))
 		return -EINVAL;
 
-	fmt = &mxc_isi_input_formats[f->index];
+	fmt = &mxc_isi_out_formats[f->index];
 	if (!fmt)
 		return -EINVAL;
 
@@ -454,49 +454,26 @@ static int mxc_isi_m2m_enum_fmt_vid_cap(struct file *file, void *priv,
 	return 0;
 }
 
-static int m2m_get_formats(struct mxc_isi_fmt *fmt, enum v4l2_buf_type type)
-{
-	int ret = 0;
-
-	switch (type) {
-		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			fmt = &mxc_isi_input_formats[0];
-			break;
-		case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
-			fmt = &mxc_isi_out_formats[0];
-			break;
-		default:
-		pr_err("Invalid buf type\n");
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int mxc_isi_m2m_try_fmt(struct file *file, struct v4l2_format *f)
+static int mxc_isi_m2m_try_fmt_vid_out(struct file *file, void *fh,
+				   struct v4l2_format *f)
 {
 	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
 	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
-	struct mxc_isi_fmt *fmt, *formats = NULL;
-	int array_size_fmt;
-	int i, ret;
-
+	struct mxc_isi_fmt *fmt = NULL;
+	int i;
 
-	ret = m2m_get_formats(formats, f->type);
-	if (ret < 0)
-		return ret;
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		array_size_fmt = ARRAY_SIZE(mxc_isi_input_formats);
-	else
-		array_size_fmt = ARRAY_SIZE(mxc_isi_out_formats);
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
 
-	for (i = 0; i < array_size_fmt; i++) {
-		fmt = &formats[i];
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_input_formats); i++) {
+		fmt = &mxc_isi_input_formats[i];
 		if (fmt->fourcc == pix->pixelformat)
 			break;
 	}
-	if (i >= array_size_fmt) {
+
+	if (i >= ARRAY_SIZE(mxc_isi_input_formats)) {
 		v4l2_err(mxc_isi->v4l2_dev, "%s, format is not support!\n", __func__);
 		return -EINVAL;
 	}
@@ -510,30 +487,37 @@ static int mxc_isi_m2m_try_fmt(struct file *file, struct v4l2_format *f)
 	return 0;
 }
 
-static int mxc_isi_m2m_try_fmt_vid_out(struct file *file, void *fh,
+static int mxc_isi_m2m_try_fmt_vid_cap(struct file *file, void *fh,
 				   struct v4l2_format *f)
 {
 	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
-	int ret;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_fmt *fmt = NULL;
+	int i;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	ret = mxc_isi_m2m_try_fmt(file, f);
-
-	return ret;
-}
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
 
-static int mxc_isi_m2m_try_fmt_vid_cap(struct file *file, void *fh,
-				   struct v4l2_format *f)
-{
-	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
-	int ret;
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (fmt->fourcc == pix->pixelformat)
+			break;
+	}
 
-	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
 
-	ret = mxc_isi_m2m_try_fmt(file, f);
+	if (pix->width <= 0 || pix->height <= 0) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, width %d, height %d is not valid\n"
+				, __func__, pix->width, pix->height);
+		return -EINVAL;
+	}
 
-	return ret;
+	return 0;
 }
 
 static int mxc_isi_m2m_s_fmt_vid_out(struct file *file, void *priv,
@@ -541,15 +525,15 @@ static int mxc_isi_m2m_s_fmt_vid_out(struct file *file, void *priv,
 {
 	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
 	struct v4l2_fh *fh = file->private_data;
-	struct mxc_isi_frame *frame = &mxc_isi->m2m.dst_f;
-	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *frame = &mxc_isi->m2m.src_f;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
 	struct mxc_isi_fmt *fmt;
 	struct vb2_queue *vq;
-	int bpl, i;
+	int i;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
 		return -EINVAL;
 
 	vq = v4l2_m2m_get_vq(fh->m2m_ctx, f->type);
@@ -561,13 +545,13 @@ static int mxc_isi_m2m_s_fmt_vid_out(struct file *file, void *priv,
 		return -EBUSY;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
-		fmt = &mxc_isi_out_formats[i];
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_input_formats); i++) {
+		fmt = &mxc_isi_input_formats[i];
 		if (pix && fmt->fourcc == pix->pixelformat)
 			break;
 	}
 
-	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
+	if (i >= ARRAY_SIZE(mxc_isi_input_formats)) {
 		dev_dbg(&mxc_isi->pdev->dev, "%s, format is not support!\n", __func__);
 		return -EINVAL;
 	}
@@ -580,37 +564,15 @@ static int mxc_isi_m2m_s_fmt_vid_out(struct file *file, void *priv,
 	frame->height = pix->height;
 	frame->width = pix->width;
 
-	pix->num_planes = fmt->memplanes;
-	for (i = 0; i < pix->num_planes; i++) {
-		bpl = pix->plane_fmt[i].bytesperline;
-
-		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
-			pix->plane_fmt[i].bytesperline =
-						(pix->width * fmt->depth[i]) >> 3;
-
-		if (pix->plane_fmt[i].sizeimage == 0) {
-
-			if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12))
-				pix->plane_fmt[i].sizeimage =
-					(pix->width * (pix->height >> 1) * fmt->depth[i] >> 3);
-			else
-				pix->plane_fmt[i].sizeimage = (pix->width * pix->height *
-						fmt->depth[i] >> 3);
-		}
-	}
+	pix->bytesperline = pix->width * fmt->depth[0] >> 3;
+	pix->sizeimage = pix->height * pix->bytesperline;
 
-	if (pix->num_planes > 1) {
-		for (i = 0; i < pix->num_planes; i++) {
-			frame->bytesperline[i] = pix->plane_fmt[i].bytesperline;
-			frame->sizeimage[i] = pix->plane_fmt[i].sizeimage;
-		}
-	} else {
-		frame->bytesperline[0] = frame->width * frame->fmt->depth[0] / 8;
-		frame->sizeimage[0] = frame->height * frame->bytesperline[0];
-	}
+	frame->bytesperline[0] = pix->bytesperline;
+	frame->sizeimage[0] = pix->sizeimage;
 
 	set_frame_bounds(frame, pix->width, pix->height);
-	mxc_isi_m2m_config_dst(mxc_isi);
+	mxc_isi_m2m_config_src(mxc_isi);
+
 	return 0;
 }
 
@@ -619,15 +581,15 @@ static int mxc_isi_m2m_s_fmt_vid_cap(struct file *file, void *priv,
 {
 	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
 	struct v4l2_fh *fh = file->private_data;
-	struct mxc_isi_frame *frame = &mxc_isi->m2m.src_f;
-	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct mxc_isi_frame *frame = &mxc_isi->m2m.dst_f;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
 	struct mxc_isi_fmt *fmt;
 	struct vb2_queue *vq;
-	int i;
+	int bpl, i;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
 		return -EINVAL;
 
 	vq = v4l2_m2m_get_vq(fh->m2m_ctx, f->type);
@@ -639,13 +601,13 @@ static int mxc_isi_m2m_s_fmt_vid_cap(struct file *file, void *priv,
 		return -EBUSY;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(mxc_isi_input_formats); i++) {
-		fmt = &mxc_isi_input_formats[i];
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
+		fmt = &mxc_isi_out_formats[i];
 		if (pix && fmt->fourcc == pix->pixelformat)
 			break;
 	}
 
-	if (i >= ARRAY_SIZE(mxc_isi_input_formats)) {
+	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
 		dev_dbg(&mxc_isi->pdev->dev, "%s, format is not support!\n", __func__);
 		return -EINVAL;
 	}
@@ -658,17 +620,38 @@ static int mxc_isi_m2m_s_fmt_vid_cap(struct file *file, void *priv,
 	frame->height = pix->height;
 	frame->width = pix->width;
 
-	pix->bytesperline = pix->width * fmt->depth[0] >> 3;
-	pix->sizeimage = pix->height * pix->bytesperline;
+	pix->num_planes = fmt->memplanes;
+	for (i = 0; i < pix->num_planes; i++) {
+		bpl = pix->plane_fmt[i].bytesperline;
 
-	frame->bytesperline[0] = pix->bytesperline;
-	frame->sizeimage[0] = pix->sizeimage;
+		if ((bpl == 0) || (bpl / (fmt->depth[i] >> 3)) < pix->width)
+			pix->plane_fmt[i].bytesperline =
+						(pix->width * fmt->depth[i]) >> 3;
+
+		if (pix->plane_fmt[i].sizeimage == 0) {
+
+			if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12))
+				pix->plane_fmt[i].sizeimage =
+					(pix->width * (pix->height >> 1) * fmt->depth[i] >> 3);
+			else
+				pix->plane_fmt[i].sizeimage = (pix->width * pix->height *
+						fmt->depth[i] >> 3);
+		}
+	}
+
+	if (pix->num_planes > 1) {
+		for (i = 0; i < pix->num_planes; i++) {
+			frame->bytesperline[i] = pix->plane_fmt[i].bytesperline;
+			frame->sizeimage[i] = pix->plane_fmt[i].sizeimage;
+		}
+	} else {
+		frame->bytesperline[0] = frame->width * frame->fmt->depth[0] / 8;
+		frame->sizeimage[0] = frame->height * frame->bytesperline[0];
+	}
 
 	set_frame_bounds(frame, pix->width, pix->height);
-	mxc_isi_m2m_config_src(mxc_isi);
+	mxc_isi_m2m_config_dst(mxc_isi);
 
-	pr_info("w/h=(%d,%d), bytesperline=0x%x sizeimage=0x%x\n",
-			 pix->width, pix->height, pix->bytesperline, pix->sizeimage);
 	return 0;
 }
 
@@ -676,12 +659,13 @@ static int mxc_isi_m2m_g_fmt_vid_cap(struct file *file, void *fh,
 				 struct v4l2_format *f)
 {
 	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
-	struct v4l2_pix_format *pix = &f->fmt.pix;
-	struct mxc_isi_frame *frame = &mxc_isi->m2m.src_f;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *frame = &mxc_isi->m2m.dst_f;
+	int i;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
 		return -EINVAL;
 
 	pix->width = frame->o_width;
@@ -689,8 +673,12 @@ static int mxc_isi_m2m_g_fmt_vid_cap(struct file *file, void *fh,
 	pix->field = V4L2_FIELD_NONE;
 	pix->pixelformat = frame->fmt->fourcc;
 	pix->colorspace = V4L2_COLORSPACE_JPEG;
-	pix->bytesperline = frame->bytesperline[0];
-	pix->sizeimage = frame->sizeimage[0];
+	pix->num_planes = frame->fmt->memplanes;
+
+	for (i = 0; i < pix->num_planes; ++i) {
+		pix->plane_fmt[i].bytesperline = frame->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = frame->sizeimage[i];
+	}
 
 	return 0;
 }
@@ -699,13 +687,12 @@ static int mxc_isi_m2m_g_fmt_vid_out(struct file *file, void *fh,
 				 struct v4l2_format *f)
 {
 	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
-	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
-	struct mxc_isi_frame *frame = &mxc_isi->m2m.dst_f;
-	int i;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct mxc_isi_frame *frame = &mxc_isi->m2m.src_f;
 
 	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
 
-	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
 		return -EINVAL;
 
 	pix->width = frame->o_width;
@@ -713,12 +700,8 @@ static int mxc_isi_m2m_g_fmt_vid_out(struct file *file, void *fh,
 	pix->field = V4L2_FIELD_NONE;
 	pix->pixelformat = frame->fmt->fourcc;
 	pix->colorspace = V4L2_COLORSPACE_JPEG;
-	pix->num_planes = frame->fmt->memplanes;
-
-	for (i = 0; i < pix->num_planes; ++i) {
-		pix->plane_fmt[i].bytesperline = frame->bytesperline[i];
-		pix->plane_fmt[i].sizeimage = frame->sizeimage[i];
-	}
+	pix->bytesperline = frame->bytesperline[0];
+	pix->sizeimage = frame->sizeimage[0];
 
 	return 0;
 }
@@ -754,17 +737,17 @@ static int mxc_isi_m2m_streamoff(struct file *file, void *priv,
 static const struct v4l2_ioctl_ops mxc_isi_m2m_ioctl_ops = {
 	.vidioc_querycap		= mxc_isi_m2m_querycap,
 
-	.vidioc_enum_fmt_vid_cap = mxc_isi_m2m_enum_fmt_vid_cap,
-	.vidioc_enum_fmt_vid_out_mplane = mxc_isi_m2m_enum_fmt_vid_out,
+	.vidioc_enum_fmt_vid_cap_mplane = mxc_isi_m2m_enum_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_out = mxc_isi_m2m_enum_fmt_vid_out,
 
-	.vidioc_try_fmt_vid_cap = mxc_isi_m2m_try_fmt_vid_cap,
-	.vidioc_try_fmt_vid_out_mplane = mxc_isi_m2m_try_fmt_vid_out,
+	.vidioc_try_fmt_vid_cap_mplane = mxc_isi_m2m_try_fmt_vid_cap,
+	.vidioc_try_fmt_vid_out = mxc_isi_m2m_try_fmt_vid_out,
 
-	.vidioc_s_fmt_vid_cap = mxc_isi_m2m_s_fmt_vid_cap,
-	.vidioc_s_fmt_vid_out_mplane = mxc_isi_m2m_s_fmt_vid_out,
+	.vidioc_s_fmt_vid_cap_mplane = mxc_isi_m2m_s_fmt_vid_cap,
+	.vidioc_s_fmt_vid_out = mxc_isi_m2m_s_fmt_vid_out,
 
-	.vidioc_g_fmt_vid_cap = mxc_isi_m2m_g_fmt_vid_cap,
-	.vidioc_g_fmt_vid_out_mplane = mxc_isi_m2m_g_fmt_vid_out,
+	.vidioc_g_fmt_vid_cap_mplane = mxc_isi_m2m_g_fmt_vid_cap,
+	.vidioc_g_fmt_vid_out = mxc_isi_m2m_g_fmt_vid_out,
 
 	.vidioc_reqbufs			= v4l2_m2m_ioctl_reqbufs,
 	.vidioc_querybuf		= v4l2_m2m_ioctl_querybuf,
@@ -784,7 +767,6 @@ int mxc_isi_register_m2m_device(struct mxc_isi_dev *mxc_isi,
 	struct device *dev = &mxc_isi->pdev->dev;
 	struct video_device *vdev = &mxc_isi->m2m.vdev;
 	struct mxc_isi_m2m_dev *isi_m2m = &mxc_isi->m2m;
-	/*struct v4l2_fh *fh = &isi_m2m->fh;*/
 	int ret = -ENOMEM;
 
 	/* Only ISI channel0 support memory to memory */
@@ -874,8 +856,8 @@ void mxc_isi_m2m_frame_write_done(struct mxc_isi_dev *mxc_isi)
 	src_buf = vb2_to_isi_buffer(src_vb2);
 	dst_buf = vb2_to_isi_buffer(dst_vb2);
 
-	mxc_isi_channel_set_m2m_src_addr(mxc_isi, dst_buf);
-	mxc_isi_channel_set_m2m_out_addr(mxc_isi, src_buf);
+	mxc_isi_channel_set_m2m_src_addr(mxc_isi, src_buf);
+	mxc_isi_channel_set_m2m_out_addr(mxc_isi, dst_buf);
 
 	v4l2_m2m_src_buf_remove(fh->m2m_ctx);
 	v4l2_m2m_dst_buf_remove(fh->m2m_ctx);
-- 
1.7.9.5


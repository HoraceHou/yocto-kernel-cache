From e30f53658b31cfd073a5f27d50cfa51a18d20fc5 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Tue, 21 Nov 2017 13:56:50 +0800
Subject: [PATCH 2850/5242] MLK-16896 tty: serial: lpuart: flush
 transmit/receive fifo/buffer

commit  b698b4bd0825df024a4bd8d79fb8cb156a2d1b61 from
https://source.codeaurora.org/external/imx/linux-imx.git

Although .startup() alreadly do transmit/receive fifo/buffer flush,
but switch the baud rate may introduce dirty data on fifo, in such
case, user will call tcflush() to clean up buffer and fifo. So driver
also ensure HW fifo is cleaned up.

The patch add hw fifo/buffer flush in .flush_buffer() callback.

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/fsl_lpuart.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index 8afdba1..2663639 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -510,6 +510,8 @@ static int lpuart_dma_tx_request(struct uart_port *port)
 static void lpuart_flush_buffer(struct uart_port *port)
 {
 	struct lpuart_port *sport = container_of(port, struct lpuart_port, port);
+	u32 val;
+
 	if (sport->lpuart_dma_tx_use) {
 		if (sport->dma_tx_in_progress) {
 			dma_unmap_sg(sport->port.dev, &sport->tx_sgl[0],
@@ -518,6 +520,16 @@ static void lpuart_flush_buffer(struct uart_port *port)
 		}
 		dmaengine_terminate_all(sport->dma_tx_chan);
 	}
+
+	if (lpuart_is_32(sport)) {
+		val = lpuart32_read(&sport->port, UARTFIFO);
+		val |= UARTFIFO_TXFLUSH | UARTFIFO_RXFLUSH;
+		lpuart32_write(&sport->port, val, UARTFIFO);
+	} else {
+		val = readb(sport->port.membase + UARTPFIFO);
+		val |= UARTCFIFO_TXFLUSH | UARTCFIFO_RXFLUSH;
+		writeb(val, sport->port.membase + UARTCFIFO);
+	}
 }
 
 #if defined(CONFIG_CONSOLE_POLL)
-- 
1.7.9.5


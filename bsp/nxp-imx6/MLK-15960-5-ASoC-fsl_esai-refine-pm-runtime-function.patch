From 46a035f6d03f10dd5e085c7a08a452619e0d0da4 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@freescale.com>
Date: Thu, 13 Jul 2017 10:44:43 +0800
Subject: [PATCH 2125/5242] MLK-15960-5: ASoC: fsl_esai: refine pm runtime
 function

commit  c0bdcd8cf21ab82ae104973a5801b1d3270b4fdf from
https://source.codeaurora.org/external/imx/linux-imx.git

In imx8qm/imx8qxp, the power domain of IP is enabled when
pm_runtime_get_sync() is called, and disabled when pm_runtime
_put_sync() is called. when power domain is disabled, the value
of registers will lost, so we need to use the regcache_sync()
to restore the registers in fsl_esai_runtime_resume.

Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_esai.c |   46 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 46 insertions(+)

diff --git a/sound/soc/fsl/fsl_esai.c b/sound/soc/fsl/fsl_esai.c
index 925b05e..0a39fa2 100644
--- a/sound/soc/fsl/fsl_esai.c
+++ b/sound/soc/fsl/fsl_esai.c
@@ -14,6 +14,7 @@
 #include <linux/of_platform.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmapool.h>
+#include <linux/pm_runtime.h>
 #include <sound/dmaengine_pcm.h>
 #include <sound/pcm_params.h>
 
@@ -1168,6 +1169,9 @@ static int fsl_esai_probe(struct platform_device *pdev)
 						      "nxp,imx8qm-acm",
 						      FSL_DMA_WORKAROUND_ESAI);
 
+	pm_runtime_enable(&pdev->dev);
+	regcache_cache_only(esai_priv->regmap, true);
+
 	ret = imx_pcm_platform_register(&pdev->dev);
 	if (ret)
 		dev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);
@@ -1182,9 +1186,48 @@ static int fsl_esai_remove(struct platform_device *pdev)
 	if (esai_priv->soc->dma_workaround)
 		fsl_dma_workaround_free_info(esai_priv->dma_info, &pdev->dev);
 
+	pm_runtime_disable(&pdev->dev);
+
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int fsl_esai_runtime_resume(struct device *dev)
+{
+	struct fsl_esai *esai = dev_get_drvdata(dev);
+	int ret;
+
+	regcache_cache_only(esai->regmap, false);
+	regcache_mark_dirty(esai->regmap);
+
+	/* FIFO reset for safety */
+	regmap_update_bits(esai->regmap, REG_ESAI_TFCR,
+			   ESAI_xFCR_xFR, ESAI_xFCR_xFR);
+	regmap_update_bits(esai->regmap, REG_ESAI_RFCR,
+			   ESAI_xFCR_xFR, ESAI_xFCR_xFR);
+
+	ret = regcache_sync(esai->regmap);
+	if (ret)
+		return ret;
+
+	/* FIFO reset done */
+	regmap_update_bits(esai->regmap, REG_ESAI_TFCR, ESAI_xFCR_xFR, 0);
+	regmap_update_bits(esai->regmap, REG_ESAI_RFCR, ESAI_xFCR_xFR, 0);
+
+	return 0;
+}
+
+static int fsl_esai_runtime_suspend(struct device *dev)
+{
+	struct fsl_esai *esai = dev_get_drvdata(dev);
+
+	regcache_cache_only(esai->regmap, true);
+
+	return 0;
+}
+#endif
+
+
 #ifdef CONFIG_PM_SLEEP
 static int fsl_esai_suspend(struct device *dev)
 {
@@ -1222,6 +1265,9 @@ static int fsl_esai_resume(struct device *dev)
 #endif /* CONFIG_PM_SLEEP */
 
 static const struct dev_pm_ops fsl_esai_pm_ops = {
+	SET_RUNTIME_PM_OPS(fsl_esai_runtime_suspend,
+			   fsl_esai_runtime_resume,
+			   NULL)
 	SET_SYSTEM_SLEEP_PM_OPS(fsl_esai_suspend, fsl_esai_resume)
 };
 
-- 
1.7.9.5


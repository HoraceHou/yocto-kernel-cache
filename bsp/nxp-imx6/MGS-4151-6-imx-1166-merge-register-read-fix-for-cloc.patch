From bc69a5fe07a7e77679d64f4a8b5899102b516860 Mon Sep 17 00:00:00 2001
From: Xianzhong <xianzhong.li@nxp.com>
Date: Sat, 8 Sep 2018 05:42:51 +0800
Subject: [PATCH 4597/5242] MGS-4151-6 [#imx-1166] merge register read fix for
 clock-off

commit  9302cc91144944e23cad9c92062e2c765d914198 from
https://source.codeaurora.org/external/imx/linux-imx.git

CL165804 fix read register when internal clock off 1. For
 shared IRQ, read register may be called and that's not our
 irq. 2. In some condition, when ISR handled normal FE/PE,
 PM thread could trun off internal clock before ISR read
 register of async FE. And then IRQ handler will call read
 register with internal clock off. So here we need to skip
 read in such case. This is simple fix.

cherry-pick patch:
6.2.4.p3-0019-CL165804-fix-read-register-when-internal-clock-off-1

Signed-off-by: Xianzhong <xianzhong.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c |   23 ++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index dcf4daf..bc316b3 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -1597,6 +1597,8 @@ gceSTATUS gckOS_FreeNonPagedMemory(
 {
     if (in_irq())
     {
+        uint32_t data;
+
         spin_lock(&Os->registerAccessLock);
 
         if (unlikely(Os->clockStates[Core] == gcvFALSE))
@@ -1604,12 +1606,29 @@ gceSTATUS gckOS_FreeNonPagedMemory(
             spin_unlock(&Os->registerAccessLock);
 
             /*
-             * Read register when power off:
+             * Read register when external clock off:
              * 1. In shared IRQ, read register may be called and that's not our irq.
              */
             return gcvSTATUS_GENERIC_IO;
         }
 
+        data = readl(Os->device->registerBases[Core]);
+
+        if (unlikely((data & 0x3) == 0x3))
+        {
+            spin_unlock(&Os->registerAccessLock);
+
+            /*
+             * Read register when internal clock off:
+             * a. In shared IRQ, read register may be called and that's not our irq.
+             * b. In some condition, when ISR handled normal FE/PE, PM thread could
+             *    trun off internal clock before ISR read register of async FE. And
+             *    then IRQ handler will call read register with internal clock off.
+             *    So here we just skip for such case.
+             */
+            return gcvSTATUS_GENERIC_IO;
+        }
+
         *Data = readl((gctUINT8 *)Os->device->registerBases[Core] + Address);
         spin_unlock(&Os->registerAccessLock);
     }
@@ -1624,7 +1643,7 @@ gceSTATUS gckOS_FreeNonPagedMemory(
             spin_unlock_irqrestore(&Os->registerAccessLock, flags);
 
             /*
-             * Read register when power off:
+             * Read register when external clock off:
              * 2. In non-irq context, register access should not be called,
              *    otherwise it's driver bug.
              */
-- 
1.7.9.5


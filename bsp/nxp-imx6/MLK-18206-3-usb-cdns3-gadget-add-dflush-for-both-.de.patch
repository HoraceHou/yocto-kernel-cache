From 17c245991ee77c4233e74e4b96e7e70d37646bfb Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Fri, 27 Apr 2018 10:46:46 +0800
Subject: [PATCH 3789/5242] MLK-18206-3 usb: cdns3: gadget: add dflush for
 both .dequeue and .ep_disable

commit  094e384895fa65c558df762c76d4c0ce28331da6 from
https://source.codeaurora.org/external/imx/linux-imx.git

There are may active transfers when we would like dequeue request
or disable endpoint, so it needs to flush the on-chip buffer before
dequeue software request.

Reviewed-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/cdns3/gadget.c |   27 +++++++++++++++++++++++++--
 1 file changed, 25 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/cdns3/gadget.c b/drivers/usb/cdns3/gadget.c
index ceaf2d9..bc0a893 100644
--- a/drivers/usb/cdns3/gadget.c
+++ b/drivers/usb/cdns3/gadget.c
@@ -218,6 +218,25 @@ static int usb_ss_allocate_trb_pool(struct usb_ss_endpoint *usb_ss_ep)
 }
 
 /**
+ * cdns_data_flush - do flush data at onchip buffer
+ * @usb_ss_ep: extended endpoint object
+ *
+ * Endpoint must be selected before call to this function
+ *
+ * Returns zero on success or negative value on failure
+ */
+static int cdns_data_flush(struct usb_ss_endpoint *usb_ss_ep)
+{
+	struct usb_ss_dev *usb_ss = usb_ss_ep->usb_ss;
+
+	gadget_writel(usb_ss, &usb_ss->regs->ep_cmd,
+		EP_CMD__DFLUSH__MASK);
+	/* wait for DFLUSH cleared */
+	return wait_reg_bit_clear(usb_ss, &usb_ss->regs->ep_cmd,
+		EP_CMD__DFLUSH__MASK, 100);
+}
+
+/**
  * cdns_ep_stall_flush - Stalls and flushes selected endpoint
  * @usb_ss_ep: extended endpoint object
  *
@@ -1728,6 +1747,8 @@ static int usb_ss_gadget_ep_disable(struct usb_ep *ep)
 	dev_dbg(&usb_ss->dev,
 		"Disabling endpoint: %s\n", ep->name);
 
+	select_ep(usb_ss, ep->desc->bEndpointAddress);
+	ret = cdns_data_flush(usb_ss_ep);
 	while (!list_empty(&usb_ss_ep->request_list)) {
 
 		request = next_request(&usb_ss_ep->request_list);
@@ -1740,7 +1761,6 @@ static int usb_ss_gadget_ep_disable(struct usb_ep *ep)
 		spin_lock(&usb_ss->lock);
 	}
 
-	select_ep(usb_ss, ep->desc->bEndpointAddress);
 	ep_cfg = gadget_readl(usb_ss, &usb_ss->regs->ep_cfg);
 	ep_cfg &= ~EP_CFG__ENABLE__MASK;
 	gadget_writel(usb_ss, &usb_ss->regs->ep_cfg, ep_cfg);
@@ -1851,6 +1871,7 @@ static int usb_ss_gadget_ep_dequeue(struct usb_ep *ep,
 	struct usb_ss_dev *usb_ss = usb_ss_ep->usb_ss;
 	unsigned long flags;
 	struct usb_request *req, *req_temp;
+	int ret = 0;
 
 	if (ep == NULL || request == NULL || ep->desc == NULL)
 		return -EINVAL;
@@ -1862,6 +1883,8 @@ static int usb_ss_gadget_ep_dequeue(struct usb_ep *ep,
 		ep->address & USB_DIR_IN);
 	request->status = -ECONNRESET;
 
+	select_ep(usb_ss, ep->desc->bEndpointAddress);
+	ret = cdns_data_flush(usb_ss_ep);
 	if (ep->address) {
 		list_for_each_entry_safe(req, req_temp,
 			&usb_ss_ep->request_list, list) {
@@ -1879,7 +1902,7 @@ static int usb_ss_gadget_ep_dequeue(struct usb_ep *ep,
 	}
 
 	spin_unlock_irqrestore(&usb_ss->lock, flags);
-	return 0;
+	return ret;
 }
 
 /**
-- 
1.7.9.5


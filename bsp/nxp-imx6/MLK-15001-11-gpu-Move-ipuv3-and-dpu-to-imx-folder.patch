From eb0d980370bfa6a9ac6b01832e8c9225055fae33 Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Wed, 12 Apr 2017 16:30:34 +0800
Subject: [PATCH 1914/5242] MLK-15001-11 gpu: Move ipuv3 and dpu to imx folder

commit  d90257128af7f10745970328bd2c42549577938e from
https://source.codeaurora.org/external/imx/linux-imx.git

IPUv3 and DPU are both i.MX display processing units.
To organize the driver code better, let's introduce the imx folder for them.
Later, we may put more drivers into this folder, e.g., the prefetch engines.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/Makefile                       |    3 +-
 drivers/gpu/dpu/Kconfig                    |    9 -
 drivers/gpu/dpu/Makefile                   |    5 -
 drivers/gpu/dpu/dpu-common.c               | 1293 ---------------------
 drivers/gpu/dpu/dpu-constframe.c           |  202 ----
 drivers/gpu/dpu/dpu-disengcfg.c            |  138 ---
 drivers/gpu/dpu/dpu-extdst.c               |  485 --------
 drivers/gpu/dpu/dpu-fetchdecode.c          |  503 --------
 drivers/gpu/dpu/dpu-fetchlayer.c           |  295 -----
 drivers/gpu/dpu/dpu-framegen.c             |  366 ------
 drivers/gpu/dpu/dpu-layerblend.c           |  383 -------
 drivers/gpu/dpu/dpu-prv.h                  |  233 ----
 drivers/gpu/dpu/dpu-tcon.c                 |  233 ----
 drivers/gpu/imx/Kconfig                    |    2 +
 drivers/gpu/imx/Makefile                   |    2 +
 drivers/gpu/imx/dpu/Kconfig                |    9 +
 drivers/gpu/imx/dpu/Makefile               |    5 +
 drivers/gpu/imx/dpu/dpu-common.c           | 1293 +++++++++++++++++++++
 drivers/gpu/imx/dpu/dpu-constframe.c       |  202 ++++
 drivers/gpu/imx/dpu/dpu-disengcfg.c        |  138 +++
 drivers/gpu/imx/dpu/dpu-extdst.c           |  485 ++++++++
 drivers/gpu/imx/dpu/dpu-fetchdecode.c      |  503 ++++++++
 drivers/gpu/imx/dpu/dpu-fetchlayer.c       |  295 +++++
 drivers/gpu/imx/dpu/dpu-framegen.c         |  366 ++++++
 drivers/gpu/imx/dpu/dpu-layerblend.c       |  383 +++++++
 drivers/gpu/imx/dpu/dpu-prv.h              |  233 ++++
 drivers/gpu/imx/dpu/dpu-tcon.c             |  233 ++++
 drivers/gpu/imx/ipu-v3/Kconfig             |   10 +
 drivers/gpu/imx/ipu-v3/Makefile            |   10 +
 drivers/gpu/imx/ipu-v3/ipu-common.c        | 1566 +++++++++++++++++++++++++
 drivers/gpu/imx/ipu-v3/ipu-cpmem.c         |  903 +++++++++++++++
 drivers/gpu/imx/ipu-v3/ipu-csi.c           |  776 +++++++++++++
 drivers/gpu/imx/ipu-v3/ipu-dc.c            |  429 +++++++
 drivers/gpu/imx/ipu-v3/ipu-di.c            |  754 ++++++++++++
 drivers/gpu/imx/ipu-v3/ipu-dmfc.c          |  223 ++++
 drivers/gpu/imx/ipu-v3/ipu-dp.c            |  360 ++++++
 drivers/gpu/imx/ipu-v3/ipu-ic.c            |  801 +++++++++++++
 drivers/gpu/imx/ipu-v3/ipu-image-convert.c | 1718 ++++++++++++++++++++++++++++
 drivers/gpu/imx/ipu-v3/ipu-pre.c           |  341 ++++++
 drivers/gpu/imx/ipu-v3/ipu-prg.c           |  474 ++++++++
 drivers/gpu/imx/ipu-v3/ipu-prv.h           |  282 +++++
 drivers/gpu/imx/ipu-v3/ipu-smfc.c          |  208 ++++
 drivers/gpu/imx/ipu-v3/ipu-vdi.c           |  243 ++++
 drivers/gpu/ipu-v3/Kconfig                 |   10 -
 drivers/gpu/ipu-v3/Makefile                |   10 -
 drivers/gpu/ipu-v3/ipu-common.c            | 1566 -------------------------
 drivers/gpu/ipu-v3/ipu-cpmem.c             |  903 ---------------
 drivers/gpu/ipu-v3/ipu-csi.c               |  776 -------------
 drivers/gpu/ipu-v3/ipu-dc.c                |  429 -------
 drivers/gpu/ipu-v3/ipu-di.c                |  754 ------------
 drivers/gpu/ipu-v3/ipu-dmfc.c              |  223 ----
 drivers/gpu/ipu-v3/ipu-dp.c                |  360 ------
 drivers/gpu/ipu-v3/ipu-ic.c                |  801 -------------
 drivers/gpu/ipu-v3/ipu-image-convert.c     | 1718 ----------------------------
 drivers/gpu/ipu-v3/ipu-pre.c               |  341 ------
 drivers/gpu/ipu-v3/ipu-prg.c               |  474 --------
 drivers/gpu/ipu-v3/ipu-prv.h               |  282 -----
 drivers/gpu/ipu-v3/ipu-smfc.c              |  208 ----
 drivers/gpu/ipu-v3/ipu-vdi.c               |  243 ----
 drivers/video/Kconfig                      |    3 +-
 60 files changed, 13249 insertions(+), 13247 deletions(-)
 delete mode 100644 drivers/gpu/dpu/Kconfig
 delete mode 100644 drivers/gpu/dpu/Makefile
 delete mode 100644 drivers/gpu/dpu/dpu-common.c
 delete mode 100644 drivers/gpu/dpu/dpu-constframe.c
 delete mode 100644 drivers/gpu/dpu/dpu-disengcfg.c
 delete mode 100644 drivers/gpu/dpu/dpu-extdst.c
 delete mode 100644 drivers/gpu/dpu/dpu-fetchdecode.c
 delete mode 100644 drivers/gpu/dpu/dpu-fetchlayer.c
 delete mode 100644 drivers/gpu/dpu/dpu-framegen.c
 delete mode 100644 drivers/gpu/dpu/dpu-layerblend.c
 delete mode 100644 drivers/gpu/dpu/dpu-prv.h
 delete mode 100644 drivers/gpu/dpu/dpu-tcon.c
 create mode 100644 drivers/gpu/imx/Kconfig
 create mode 100644 drivers/gpu/imx/Makefile
 create mode 100644 drivers/gpu/imx/dpu/Kconfig
 create mode 100644 drivers/gpu/imx/dpu/Makefile
 create mode 100644 drivers/gpu/imx/dpu/dpu-common.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-constframe.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-disengcfg.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-extdst.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-fetchdecode.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-fetchlayer.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-framegen.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-layerblend.c
 create mode 100644 drivers/gpu/imx/dpu/dpu-prv.h
 create mode 100644 drivers/gpu/imx/dpu/dpu-tcon.c
 create mode 100644 drivers/gpu/imx/ipu-v3/Kconfig
 create mode 100644 drivers/gpu/imx/ipu-v3/Makefile
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-common.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-cpmem.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-csi.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-dc.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-di.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-dmfc.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-dp.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-ic.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-image-convert.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-pre.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-prg.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-prv.h
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-smfc.c
 create mode 100644 drivers/gpu/imx/ipu-v3/ipu-vdi.c
 delete mode 100644 drivers/gpu/ipu-v3/Kconfig
 delete mode 100644 drivers/gpu/ipu-v3/Makefile
 delete mode 100644 drivers/gpu/ipu-v3/ipu-common.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-cpmem.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-csi.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-dc.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-di.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-dmfc.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-dp.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-ic.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-image-convert.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-pre.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-prg.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-prv.h
 delete mode 100644 drivers/gpu/ipu-v3/ipu-smfc.c
 delete mode 100644 drivers/gpu/ipu-v3/ipu-vdi.c

diff --git a/drivers/gpu/Makefile b/drivers/gpu/Makefile
index 3dc8f3f..368f426 100644
--- a/drivers/gpu/Makefile
+++ b/drivers/gpu/Makefile
@@ -3,5 +3,4 @@
 # to ensure this currently.
 obj-$(CONFIG_TEGRA_HOST1X)	+= host1x/
 obj-y			+= drm/ vga/
-obj-$(CONFIG_IMX_IPUV3_CORE)	+= ipu-v3/
-obj-$(CONFIG_IMX_DPU_CORE)	+= dpu/
+obj-y			+= imx/
diff --git a/drivers/gpu/dpu/Kconfig b/drivers/gpu/dpu/Kconfig
deleted file mode 100644
index 1a1f5a9..0000000
--- a/drivers/gpu/dpu/Kconfig
+++ /dev/null
@@ -1,9 +0,0 @@
-config IMX_DPU_CORE
-	tristate "i.MX DPU core support"
-	depends on ARCH_FSL_IMX8QM || ARCH_FSL_IMX8QXP
-	depends on RESET_CONTROLLER
-	select GENERIC_IRQ_CHIP
-	help
-	  Choose this if you have a Freescale i.MX8QM or i.MX8QXP system and
-	  want to use the Display Processing Unit. This option only enables
-	  DPU base support.
diff --git a/drivers/gpu/dpu/Makefile b/drivers/gpu/dpu/Makefile
deleted file mode 100644
index df07880..0000000
--- a/drivers/gpu/dpu/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-obj-$(CONFIG_IMX_DPU_CORE) += imx-dpu-core.o
-
-imx-dpu-core-objs := dpu-common.o dpu-constframe.o dpu-disengcfg.o \
-		     dpu-extdst.o dpu-fetchdecode.o dpu-framegen.o \
-		     dpu-fetchlayer.o dpu-layerblend.o dpu-tcon.o
diff --git a/drivers/gpu/dpu/dpu-common.c b/drivers/gpu/dpu/dpu-common.c
deleted file mode 100644
index 0f47ff9..0000000
--- a/drivers/gpu/dpu/dpu-common.c
+++ /dev/null
@@ -1,1293 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/clk.h>
-#include <linux/fb.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/irqchip/chained_irq.h>
-#include <linux/irqdomain.h>
-#include <linux/mfd/syscon.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/of_graph.h>
-#include <linux/platform_device.h>
-#include <linux/regmap.h>
-#include <soc/imx8/sc/sci.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define DPU_CM_REG_DEFINE1(name1, name2)		\
-static inline u32 name1(const struct cm_reg_ofs *ofs)	\
-{							\
-	return ofs->name2;				\
-}
-
-#define DPU_CM_REG_DEFINE2(name1, name2)		\
-static inline u32 name1(const struct cm_reg_ofs *ofs,	\
-			unsigned int n)			\
-{							\
-	return ofs->name2 + (4 * n);			\
-}
-
-DPU_CM_REG_DEFINE1(IPIDENTIFIER, ipidentifier);
-
-#define DESIGNDELIVERYID_MASK		0xF0U
-#define DESIGNDELIVERYID_SHIFT		4U
-
-#define DESIGNMATURITYLEVEL_MASK	0xF00U
-#define DESIGNMATURITYLEVEL_SHIFT	8U
-enum design_maturity_level {
-	/* Pre feasibility study. */
-	DESIGNMATURITYLEVEL__PREFS	= 1 << DESIGNMATURITYLEVEL_SHIFT,
-	/* Feasibility study. */
-	DESIGNMATURITYLEVEL__FS		= 2 << DESIGNMATURITYLEVEL_SHIFT,
-	/* Functionality complete. */
-	DESIGNMATURITYLEVEL__R0		= 3 << DESIGNMATURITYLEVEL_SHIFT,
-	/* Verification complete. */
-	DESIGNMATURITYLEVEL__R1		= 4 << DESIGNMATURITYLEVEL_SHIFT,
-};
-
-#define IPEVOLUTION_MASK		0xF000U
-#define IPEVOLUTION_SHIFT		12U
-
-#define IPFEATURESET_MASK		0xF0000U
-#define IPFEATURESET_SHIFT		16U
-enum ip_feature_set {
-	/* Minimal functionality (Eco). */
-	IPFEATURESET__E = 1 << IPFEATURESET_SHIFT,
-	/* Reduced functionality (Light). */
-	IPFEATURESET__L = 2 << IPFEATURESET_SHIFT,
-	/* Advanced functionality (Plus). */
-	IPFEATURESET__P = 4 << IPFEATURESET_SHIFT,
-	/* Extensive functionality (eXtensive). */
-	IPFEATURESET__X = 5 << IPFEATURESET_SHIFT,
-};
-
-#define IPAPPLICATION_MASK		0xF00000U
-#define IPAPPLICATION_SHIFT		20U
-enum ip_application {
-	/* Blit Engine only. */
-	IPAPPLICATION__B = 1 << IPAPPLICATION_SHIFT,
-	/* Blit Engine and Display Controller. */
-	IPAPPLICATION__D = 2 << IPAPPLICATION_SHIFT,
-	/* Display Controller only (with direct capture). */
-	IPAPPLICATION__V = 3 << IPAPPLICATION_SHIFT,
-	/*
-	 * Blit Engine, Display Controller (with direct capture),
-	 * Capture Controller (buffered capture) and Drawing Engine.
-	 */
-	IPAPPLICATION__G = 4 << IPAPPLICATION_SHIFT,
-	/* Display Controller only. */
-	IPAPPLICATION__C = 5 << IPAPPLICATION_SHIFT,
-};
-
-#define IPCONFIGURATION_MASK		0xF000000U
-#define IPCONFIGURATION_SHIFT		24U
-enum ip_configuration {
-	/* Graphics core only (Module). */
-	IPCONFIGURATION__M = 1 << IPCONFIGURATION_SHIFT,
-	/* Subsystem including a graphics core (System). */
-	IPCONFIGURATION__S = 2 << IPCONFIGURATION_SHIFT,
-};
-
-#define IPFAMILY_MASK			0xF0000000U
-#define IPFAMILY_SHIFT			28U
-enum ip_family {
-	/* IMXDPU building block generation 2010. */
-	IPFAMILY__IMXDPU2010 = 0,
-	/* IMXDPU building block generation 2012. */
-	IPFAMILY__IMXDPU2012 = 1 << IPFAMILY_SHIFT,
-	/* IMXDPU building block generation 2013. */
-	IPFAMILY__IMXDPU2013 = 2 << IPFAMILY_SHIFT,
-};
-
-DPU_CM_REG_DEFINE1(LOCKUNLOCK, lockunlock);
-DPU_CM_REG_DEFINE1(LOCKSTATUS, lockstatus);
-DPU_CM_REG_DEFINE2(USERINTERRUPTMASK, userinterruptmask);
-DPU_CM_REG_DEFINE2(INTERRUPTENABLE, interruptenable);
-DPU_CM_REG_DEFINE2(INTERRUPTPRESET, interruptpreset);
-DPU_CM_REG_DEFINE2(INTERRUPTCLEAR, interruptclear);
-DPU_CM_REG_DEFINE2(INTERRUPTSTATUS, interruptstatus);
-DPU_CM_REG_DEFINE2(USERINTERRUPTENABLE, userinterruptenable);
-DPU_CM_REG_DEFINE2(USERINTERRUPTPRESET, userinterruptpreset);
-DPU_CM_REG_DEFINE2(USERINTERRUPTCLEAR, userinterruptclear);
-DPU_CM_REG_DEFINE2(USERINTERRUPTSTATUS, userinterruptstatus);
-DPU_CM_REG_DEFINE1(GENERALPURPOSE, generalpurpose);
-
-static inline u32 dpu_cm_read(struct dpu_soc *dpu, unsigned int offset)
-{
-	return readl(dpu->cm_reg + offset);
-}
-
-static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
-				unsigned int offset)
-{
-	writel(value, dpu->cm_reg + offset);
-}
-
-/* Constant Frame Unit */
-static const unsigned long cf_ofss[] = {0x4400, 0x5400, 0x4c00, 0x5c00};
-static const unsigned long cf_pec_ofss_v1[] = {0x980, 0xa00, 0x9c0, 0xa40};
-static const unsigned long cf_pec_ofss_v2[] = {0x960, 0x9e0, 0x9a0, 0xa20};
-
-/* Display Engine Configuration Unit */
-static const unsigned long dec_ofss_v1[] = {0x10000, 0x10020};
-static const unsigned long dec_ofss_v2[] = {0xb400, 0xb420};
-
-/* External Destination Unit */
-static const unsigned long ed_ofss[] = {0x4800, 0x5800, 0x5000, 0x6000};
-static const unsigned long ed_pec_ofss_v1[] = {0x9a0, 0xa20, 0x9e0, 0xa60};
-static const unsigned long ed_pec_ofss_v2[] = {0x980, 0xa00, 0x9c0, 0xa40};
-
-/* Fetch Decode Unit */
-static const unsigned long fd_ofss_v1[] = {0x8c00, 0x9800, 0x7400, 0x7c00};
-static const unsigned long fd_ofss_v2[] = {0x6c00, 0x7800};
-static const unsigned long fd_pec_ofss_v1[] = {0xb60, 0xb80, 0xb00, 0xb20};
-static const unsigned long fd_pec_ofss_v2[] = {0xa80, 0xaa0};
-
-/* Frame Generator Unit */
-static const unsigned long fg_ofss_v1[] = {0x10c00, 0x12800};
-static const unsigned long fg_ofss_v2[] = {0xb800, 0xd400};
-
-/* Fetch Layer Unit */
-static const unsigned long fl_ofss_v1[] = {0xa400, 0xac00};
-static const unsigned long fl_ofss_v2[] = {0x8400};
-static const unsigned long fl_pec_ofss_v1[] = {0xba0, 0xbb0};
-static const unsigned long fl_pec_ofss_v2[] = {0xac0};
-
-/* Layer Blend Unit */
-static const unsigned long lb_ofss_v1[] = {0xdc00, 0xe000, 0xe400, 0xe800,
-					   0xec00, 0xf000, 0xf400};
-static const unsigned long lb_ofss_v2[] = {0xa400, 0xa800, 0xac00, 0xb000};
-static const unsigned long lb_pec_ofss_v1[] = {0xd00, 0xd20, 0xd40, 0xd60,
-					       0xd80, 0xda0, 0xdc0};
-static const unsigned long lb_pec_ofss_v2[] = {0xba0, 0xbc0, 0xbe0, 0xc00};
-
-/* Timing Controller Unit */
-static const unsigned long tcon_ofss_v1[] = {0x12000, 0x13c00};
-static const unsigned long tcon_ofss_v2[] = {0xcc00, 0xe800};
-
-static const struct dpu_unit cfs_v1 = {
-	.name = "ConstFrame",
-	.num = ARRAY_SIZE(cf_ids),
-	.ids = cf_ids,
-	.pec_ofss = cf_pec_ofss_v1,
-	.ofss = cf_ofss,
-};
-
-static const struct dpu_unit cfs_v2 = {
-	.name = "ConstFrame",
-	.num = ARRAY_SIZE(cf_ids),
-	.ids = cf_ids,
-	.pec_ofss = cf_pec_ofss_v2,
-	.ofss = cf_ofss,
-};
-
-static const struct dpu_unit decs_v1 = {
-	.name = "DisEngCfg",
-	.num = ARRAY_SIZE(dec_ids),
-	.ids = dec_ids,
-	.pec_ofss = NULL,
-	.ofss = dec_ofss_v1,
-};
-
-static const struct dpu_unit decs_v2 = {
-	.name = "DisEngCfg",
-	.num = ARRAY_SIZE(dec_ids),
-	.ids = dec_ids,
-	.pec_ofss = NULL,
-	.ofss = dec_ofss_v2,
-};
-
-static const struct dpu_unit eds_v1 = {
-	.name = "ExtDst",
-	.num = ARRAY_SIZE(ed_ids),
-	.ids = ed_ids,
-	.pec_ofss = ed_pec_ofss_v1,
-	.ofss = ed_ofss,
-};
-
-static const struct dpu_unit eds_v2 = {
-	.name = "ExtDst",
-	.num = ARRAY_SIZE(ed_ids),
-	.ids = ed_ids,
-	.pec_ofss = ed_pec_ofss_v2,
-	.ofss = ed_ofss,
-};
-
-static const struct dpu_unit fds_v1 = {
-	.name = "FetchDecode",
-	.num = ARRAY_SIZE(fd_ids),
-	.ids = fd_ids,
-	.pec_ofss = fd_pec_ofss_v1,
-	.ofss = fd_ofss_v1,
-};
-
-static const struct dpu_unit fds_v2 = {
-	.name = "FetchDecode",
-	.num = 2,
-	.ids = fd_ids,
-	.pec_ofss = fd_pec_ofss_v2,
-	.ofss = fd_ofss_v2,
-};
-
-static const struct dpu_unit fgs_v1 = {
-	.name = "FrameGen",
-	.num = ARRAY_SIZE(fg_ids),
-	.ids = fg_ids,
-	.pec_ofss = NULL,
-	.ofss = fg_ofss_v1,
-};
-
-static const struct dpu_unit fgs_v2 = {
-	.name = "FrameGen",
-	.num = ARRAY_SIZE(fg_ids),
-	.ids = fg_ids,
-	.pec_ofss = NULL,
-	.ofss = fg_ofss_v2,
-};
-
-static const struct dpu_unit fls_v1 = {
-	.name = "FetchLayer",
-	.num = ARRAY_SIZE(fl_ids),
-	.ids = fl_ids,
-	.pec_ofss = fl_pec_ofss_v1,
-	.ofss = fl_ofss_v1,
-};
-
-static const struct dpu_unit fls_v2 = {
-	.name = "FetchLayer",
-	.num = 1,
-	.ids = fl_ids,
-	.pec_ofss = fl_pec_ofss_v2,
-	.ofss = fl_ofss_v2,
-};
-
-static const struct dpu_unit lbs_v1 = {
-	.name = "LayerBlend",
-	.num = ARRAY_SIZE(lb_ids),
-	.ids = lb_ids,
-	.pec_ofss = lb_pec_ofss_v1,
-	.ofss = lb_ofss_v1,
-};
-
-static const struct dpu_unit lbs_v2 = {
-	.name = "LayerBlend",
-	.num = 4,
-	.ids = lb_ids,
-	.pec_ofss = lb_pec_ofss_v2,
-	.ofss = lb_ofss_v2,
-};
-
-static const struct dpu_unit tcons_v1 = {
-	.name = "TCon",
-	.num = ARRAY_SIZE(tcon_ids),
-	.ids = tcon_ids,
-	.pec_ofss = NULL,
-	.ofss = tcon_ofss_v1,
-};
-
-static const struct dpu_unit tcons_v2 = {
-	.name = "TCon",
-	.num = ARRAY_SIZE(tcon_ids),
-	.ids = tcon_ids,
-	.pec_ofss = NULL,
-	.ofss = tcon_ofss_v2,
-};
-
-static const struct cm_reg_ofs cm_reg_ofs_v1 = {
-	.ipidentifier = 0,
-	.lockunlock = 0x80,
-	.lockstatus = 0x84,
-	.userinterruptmask = 0x88,
-	.interruptenable = 0x94,
-	.interruptpreset = 0xa0,
-	.interruptclear = 0xac,
-	.interruptstatus = 0xb8,
-	.userinterruptenable = 0x100,
-	.userinterruptpreset = 0x10c,
-	.userinterruptclear = 0x118,
-	.userinterruptstatus = 0x124,
-	.generalpurpose = 0x200,
-};
-
-static const struct cm_reg_ofs cm_reg_ofs_v2 = {
-	.ipidentifier = 0,
-	.lockunlock = 0x40,
-	.lockstatus = 0x44,
-	.userinterruptmask = 0x48,
-	.interruptenable = 0x50,
-	.interruptpreset = 0x58,
-	.interruptclear = 0x60,
-	.interruptstatus = 0x68,
-	.userinterruptenable = 0x80,
-	.userinterruptpreset = 0x88,
-	.userinterruptclear = 0x90,
-	.userinterruptstatus = 0x98,
-	.generalpurpose = 0x100,
-};
-
-static const unsigned int intsteer_map_v1[] = {
-	/*  0    1    2    3    4    5    6    7 */	/*  0~31: int0 */
-	  448, 449, 450,  64,  65,  66,  67,  68,
-	/*  8    9   10   11   12   13   14   15 */
-	   69,  70, 193, 194, 195, 196, 197, 320,
-	/* 16   17   18   19   20   21   22   23 */
-	  321, 322, 384, 385, 386,  NA, 323,  NA,
-	/* 24   25   26   27   28   29   30   31 */
-	  387,  71, 198,  72,  73,  74,  75,  76,
-	/* 32   33   34   35   36   37   38   39 */	/* 32~63: int1 */
-	   77,  78,  79,  80,  81, 199, 200, 201,
-	/* 40   41   42   43   44   45   46   47 */
-	  202, 203, 204, 205, 206, 207, 208, 324,
-	/* 48   49   50   51   52   53   54   55 */
-	  389,  NA,   0,   1,   2,   3,   4,  82,
-	/* 56   57   58   59   60   61   62   63 */
-	   83,  84,  85, 209, 210, 211, 212, 325,
-	/* 64   65   66 */				/*   64+: int2 */
-	  326, 390, 391,
-};
-static const unsigned long unused_irq_v1[] = {0x00a00000, 0x00020000,
-					      0xfffffff8};
-
-static const unsigned int intsteer_map_v2[] = {
-	/*  0    1    2    3    4    5    6    7 */	/*  0~31: int0 */
-	  448, 449, 450,  64,  65,  66,  67,  68,
-	/*  8    9   10   11   12   13   14   15 */
-	   69,  70, 193, 194, 195, 196, 197,  72,
-	/* 16   17   18   19   20   21   22   23 */
-	   73,  74,  75,  76,  77,  78,  79,  80,
-	/* 24   25   26   27   28   29   30   31 */
-	   81, 199, 200, 201, 202, 203, 204, 205,
-	/* 32   33   34   35   36   37   38   39 */	/*   32+: int1 */
-	  206, 207, 208,  NA,   0,   1,   2,   3,
-	/* 40   41   42   43   44   45   46   47 */
-	    4,  82,  83,  84,  85, 209, 210, 211,
-	/* 48 */
-	  212,
-};
-static const unsigned long unused_irq_v2[] = {0x00000000, 0xfffe0008};
-
-static const unsigned int sw2hw_irq_map_v2[] = {
-	/*  0    1    2    3    4    5    6    7 */
-	    0,   1,   2,   3,   4,   5,   6,   7,
-	/*  8    9   10   11   12   13   14   15 */
-	    8,   9,  10,  11,  12,  13,  14,  NA,
-	/* 16   17   18   19   20   21   22   23 */
-	   NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,
-	/* 24   25   26   27   28   29   30   31 */
-	   NA,  NA,  NA,  15,  16,  17,  18,  19,
-	/* 32   33   34   35   36   37   38   39 */
-	   20,  21,  22,  23,  24,  25,  26,  27,
-	/* 40   41   42   43   44   45   46   47 */
-	   28,  29,  30,  31,  32,  33,  34,  NA,
-	/* 48   49   50   51   52   53   54   55 */
-	   NA,  NA,  36,  37,  38,  39,  40,  41,
-	/* 56   57   58   59   60   61   62   63 */
-	   42,  43,  44,  45,  46,  47,  48,  NA,
-	/* 64   65   66 */
-	   NA,  NA,  NA,
-};
-
-/* FIXME: overkill for some N/As, revive them when needed */
-static const unsigned int sw2hw_block_id_map_v2[] = {
-	/*   0     1     2     3     4     5     6     7 */
-	  0x00,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
-	/*   8     9    10    11    12    13    14    15 */
-	    NA,   NA, 0x0a,   NA, 0x0c,   NA, 0x0e,   NA,
-	/*  16    17    18    19    20    21    22    23 */
-	  0x10,   NA, 0x12,   NA,   NA,   NA,   NA,   NA,
-	/*  24    25    26    27    28    29    30    31 */
-	    NA,   NA, 0x14,   NA, 0x16,   NA, 0x18,   NA,
-	/*  32    33    34    35    36    37    38    39 */
-	  0x1a,   NA,   NA, 0x1b, 0x1c, 0x1d,   NA,   NA,
-	/*  40    41    42    43    44    45    46    47 */
-	  0x1e, 0x1f, 0x20,   NA, 0x21, 0x22, 0x23, 0x24,
-	/*  48    49    50    51    52    53    54    55 */
-	    NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
-	/*  56    57    58    59    60    61    62    63 */
-	    NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
-	/*  64    65    66    67 */
-	    NA,   NA,   NA,   NA,
-};
-
-static const struct dpu_devtype dpu_type_v1 = {
-	.cm_ofs = 0x0,
-	.cfs = &cfs_v1,
-	.decs = &decs_v1,
-	.eds = &eds_v1,
-	.fds = &fds_v1,
-	.fgs = &fgs_v1,
-	.fls = &fls_v1,
-	.lbs = &lbs_v1,
-	.tcons = &tcons_v1,
-	.cm_reg_ofs = &cm_reg_ofs_v1,
-	.intsteer_map = intsteer_map_v1,
-	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v1),
-	.unused_irq = unused_irq_v1,
-	.has_capture = true,
-	.pixel_link_quirks = false,
-	.pixel_link_nhvsync = false,
-	.version = DPU_V1,
-};
-
-static const struct dpu_devtype dpu_type_v2 = {
-	.cm_ofs = 0x0,
-	.cfs = &cfs_v2,
-	.decs = &decs_v2,
-	.eds = &eds_v2,
-	.fds = &fds_v2,
-	.fgs = &fgs_v2,
-	.fls = &fls_v2,
-	.lbs = &lbs_v2,
-	.tcons = &tcons_v2,
-	.cm_reg_ofs = &cm_reg_ofs_v2,
-	.intsteer_map = intsteer_map_v2,
-	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v2),
-	.unused_irq = unused_irq_v2,
-	.sw2hw_irq_map = sw2hw_irq_map_v2,
-	.sw2hw_block_id_map = sw2hw_block_id_map_v2,
-	.has_capture = false,
-	.pixel_link_quirks = true,
-	.pixel_link_nhvsync = true,
-	.version = DPU_V2,
-};
-
-static const struct of_device_id dpu_dt_ids[] = {
-	{ .compatible = "fsl,imx8qm-dpu", .data = &dpu_type_v2, },
-	{ .compatible = "fsl,imx8qxp-dpu", .data = &dpu_type_v2, },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, dpu_dt_ids);
-
-#define DPU_UNIT_INIT(dpu, base, unit, name, id, pec_ofs, ofs)		\
-{									\
-	int ret;							\
-	ret = dpu_##unit##_init((dpu),	(id),				\
-				(pec_ofs) ? (base) + (pec_ofs) : 0,	\
-				(base) + (ofs));			\
-	if (ret) {							\
-		dev_err((dpu)->dev, "init %s%d failed with %d\n",	\
-						(name), (id), ret);	\
-		return ret;						\
-	}								\
-}
-
-#define DPU_UNITS_INIT(unit)						\
-{									\
-	const struct dpu_unit *us = devtype->unit##s;			\
-	int i;								\
-									\
-	/* software check */						\
-	if (WARN_ON(us->num > ARRAY_SIZE(unit##_ids)))			\
-		return -EINVAL;						\
-									\
-	for (i = 0; i < us->num; i++)					\
-		DPU_UNIT_INIT(dpu, dpu_base, unit, us->name,		\
-			      us->ids[i],				\
-			      us->pec_ofss ? us->pec_ofss[i] : 0,	\
-			      us->ofss[i]);				\
-}
-
-static int dpu_submodules_init(struct dpu_soc *dpu,
-		struct platform_device *pdev, unsigned long dpu_base)
-{
-	const struct dpu_devtype *devtype = dpu->devtype;
-
-	DPU_UNITS_INIT(cf);
-	DPU_UNITS_INIT(dec);
-	DPU_UNITS_INIT(ed);
-	DPU_UNITS_INIT(fd);
-	DPU_UNITS_INIT(fg);
-	DPU_UNITS_INIT(fl);
-	DPU_UNITS_INIT(lb);
-	DPU_UNITS_INIT(tcon);
-
-	return 0;
-}
-
-#define DPU_UNITS_ADDR_DBG(unit)					\
-{									\
-	const struct dpu_unit *us = devtype->unit##s;			\
-	int i;								\
-	for (i = 0; i < us->num; i++) {					\
-		if (us->pec_ofss) {					\
-			dev_dbg(&pdev->dev, "%s%d: pixengcfg @ 0x%08lx,"\
-				" unit @ 0x%08lx\n", us->name,		\
-				us->ids[i],				\
-				dpu_base + us->pec_ofss[i],		\
-				dpu_base + us->ofss[i]);		\
-		} else {						\
-			dev_dbg(&pdev->dev,				\
-				"%s%d: unit @ 0x%08lx\n", us->name,	\
-				us->ids[i], dpu_base + us->ofss[i]);	\
-		}							\
-	}								\
-}
-
-enum dpu_irq_line {
-	DPU_IRQ_LINE_CM = 0,
-	DPU_IRQ_LINE_STREAM0A = 1,
-	DPU_IRQ_LINE_STREAM1A = 3,
-	DPU_IRQ_LINE_RESERVED0 = 5,
-	DPU_IRQ_LINE_RESERVED1 = 6,
-	DPU_IRQ_LINE_BLIT = 7,
-};
-
-static inline unsigned int dpu_get_max_intsteer_num(enum dpu_irq_line irq_line)
-{
-	return 64 * (++irq_line) - 1;
-}
-
-static inline unsigned int dpu_get_min_intsteer_num(enum dpu_irq_line irq_line)
-{
-	return 64 * irq_line;
-}
-
-static void dpu_irq_handle(struct irq_desc *desc, enum dpu_irq_line irq_line)
-{
-	struct dpu_soc *dpu = irq_desc_get_handler_data(desc);
-	const struct dpu_devtype *devtype = dpu->devtype;
-	const struct cm_reg_ofs *ofs = devtype->cm_reg_ofs;
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	unsigned int i, virq, min_intsteer_num, max_intsteer_num;
-	u32 status;
-
-	chained_irq_enter(chip, desc);
-
-	min_intsteer_num = dpu_get_min_intsteer_num(irq_line);
-	max_intsteer_num = dpu_get_max_intsteer_num(irq_line);
-
-	for (i = 0; i < devtype->intsteer_map_size; i++) {
-		if (devtype->intsteer_map[i] >= min_intsteer_num &&
-		    devtype->intsteer_map[i] <= max_intsteer_num) {
-			status = dpu_cm_read(dpu,
-					USERINTERRUPTSTATUS(ofs, i / 32));
-			status &= dpu_cm_read(dpu,
-					USERINTERRUPTENABLE(ofs, i / 32));
-
-			if (status & BIT(i % 32)) {
-				virq = irq_linear_revmap(dpu->domain, i);
-				if (virq) {
-					generic_handle_irq(virq);
-				}
-			}
-		}
-	}
-
-	chained_irq_exit(chip, desc);
-}
-
-#define DPU_IRQ_HANDLER_DEFINE(name1, name2)			\
-static void dpu_##name1##_irq_handler(struct irq_desc *desc)	\
-{								\
-	dpu_irq_handle(desc, DPU_IRQ_LINE_##name2);		\
-}
-
-DPU_IRQ_HANDLER_DEFINE(cm, CM)
-DPU_IRQ_HANDLER_DEFINE(stream0a, STREAM0A)
-DPU_IRQ_HANDLER_DEFINE(stream1a, STREAM1A)
-DPU_IRQ_HANDLER_DEFINE(reserved0, RESERVED0)
-DPU_IRQ_HANDLER_DEFINE(reserved1, RESERVED1)
-DPU_IRQ_HANDLER_DEFINE(blit, BLIT)
-
-int dpu_map_irq(struct dpu_soc *dpu, int irq)
-{
-	const unsigned int *sw2hw_irq_map = dpu->devtype->sw2hw_irq_map;
-	int virq, mapped_irq;
-
-	mapped_irq = sw2hw_irq_map ? sw2hw_irq_map[irq] : irq;
-	if (WARN_ON(mapped_irq == NA))
-		return -EINVAL;
-
-	virq = irq_linear_revmap(dpu->domain, mapped_irq);
-	if (!virq)
-		virq = irq_create_mapping(dpu->domain, mapped_irq);
-
-	return virq;
-}
-EXPORT_SYMBOL_GPL(dpu_map_irq);
-
-static int platform_remove_devices_fn(struct device *dev, void *unused)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-
-	platform_device_unregister(pdev);
-
-	return 0;
-}
-
-static void platform_device_unregister_children(struct platform_device *pdev)
-{
-	device_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);
-}
-
-struct dpu_platform_reg {
-	struct dpu_client_platformdata pdata;
-	const char *name;
-};
-
-static struct dpu_platform_reg client_reg[] = {
-	{
-		/* placeholder */
-		.pdata = { },
-		.name = "imx-dpu-csi",
-	}, {
-		/* placeholder */
-		.pdata = { },
-		.name = "imx-dpu-csi",
-	}, {
-		.pdata = {
-			.stream_id = 0,
-		},
-		.name = "imx-dpu-crtc",
-	}, {
-		.pdata = {
-			.stream_id = 1,
-		},
-		.name = "imx-dpu-crtc",
-	},
-};
-
-static DEFINE_MUTEX(dpu_client_id_mutex);
-static int dpu_client_id;
-
-static int dpu_get_plane_resource(struct dpu_soc *dpu,
-				  struct dpu_plane_res *res)
-{
-	const struct dpu_unit *fds = dpu->devtype->fds;
-	const struct dpu_unit *lbs = dpu->devtype->lbs;
-	struct dpu_plane_grp *grp = plane_res_to_grp(res);
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(res->cf); i++) {
-		res->cf[i] = dpu_cf_get(dpu, i);
-		if (IS_ERR(res->cf[i]))
-			return PTR_ERR(res->cf[i]);
-	}
-	for (i = 0; i < ARRAY_SIZE(res->ed); i++) {
-		res->ed[i] = dpu_ed_get(dpu, i);
-		if (IS_ERR(res->ed[i]))
-			return PTR_ERR(res->ed[i]);
-	}
-	for (i = 0; i < fds->num; i++) {
-		res->fd[i] = dpu_fd_get(dpu, i);
-		if (IS_ERR(res->fd[i]))
-			return PTR_ERR(res->fd[i]);
-	}
-	for (i = 0; i < lbs->num; i++) {
-		res->lb[i] = dpu_lb_get(dpu, i);
-		if (IS_ERR(res->lb[i]))
-			return PTR_ERR(res->lb[i]);
-	}
-
-	grp->hw_plane_num = fds->num;
-
-	return 0;
-}
-
-static void dpu_put_plane_resource(struct dpu_plane_res *res)
-{
-	struct dpu_plane_grp *grp = plane_res_to_grp(res);
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(res->cf); i++) {
-		if (!IS_ERR_OR_NULL(res->cf[i]))
-			dpu_cf_put(res->cf[i]);
-	}
-	for (i = 0; i < ARRAY_SIZE(res->ed); i++) {
-		if (!IS_ERR_OR_NULL(res->ed[i]))
-			dpu_ed_put(res->ed[i]);
-	}
-	for (i = 0; i < ARRAY_SIZE(res->fd); i++) {
-		if (!IS_ERR_OR_NULL(res->fd[i]))
-			dpu_fd_put(res->fd[i]);
-	}
-	for (i = 0; i < ARRAY_SIZE(res->lb); i++) {
-		if (!IS_ERR_OR_NULL(res->lb[i]))
-			dpu_lb_put(res->lb[i]);
-	}
-
-	grp->hw_plane_num = 0;
-}
-
-static int dpu_add_client_devices(struct dpu_soc *dpu)
-{
-	const struct dpu_devtype *devtype = dpu->devtype;
-	struct device *dev = dpu->dev;
-	struct dpu_platform_reg *reg;
-	struct dpu_plane_grp *plane_grp;
-	size_t client_num, reg_size;
-	int i, id, ret;
-
-	client_num = ARRAY_SIZE(client_reg);
-	if (!devtype->has_capture)
-		client_num -= 2;
-
-	reg = devm_kcalloc(dev, client_num, sizeof(*reg), GFP_KERNEL);
-	if (!reg)
-		return -ENODEV;
-
-	plane_grp = devm_kzalloc(dev, sizeof(*plane_grp), GFP_KERNEL);
-	if (!plane_grp)
-		return -ENODEV;
-
-	mutex_lock(&dpu_client_id_mutex);
-	id = dpu_client_id;
-	dpu_client_id += client_num;
-	mutex_unlock(&dpu_client_id_mutex);
-
-	reg_size = client_num * sizeof(struct dpu_platform_reg);
-	if (devtype->has_capture)
-		memcpy(reg, client_reg, reg_size);
-	else
-		memcpy(reg, &client_reg[2], reg_size);
-
-	INIT_LIST_HEAD(&plane_grp->list);
-	mutex_init(&plane_grp->lock);
-	plane_grp->id = id / client_num;
-
-	ret = dpu_get_plane_resource(dpu, &plane_grp->res);
-	if (ret)
-		goto err_get_plane_res;
-
-	for (i = 0; i < client_num; i++) {
-		struct platform_device *pdev;
-		struct device_node *of_node;
-		bool is_disp;
-
-		if (devtype->has_capture)
-			is_disp = (i / 2) ? true : false;
-		else
-			is_disp = true;
-
-		/* Associate subdevice with the corresponding port node */
-		of_node = of_graph_get_port_by_id(dev->of_node, i);
-		if (!of_node) {
-			dev_info(dev, "no port@%d node in %s, not using %s%d\n",
-				 i, dev->of_node->full_name,
-				 is_disp ? "DISP" : "CSI", i % 2);
-			continue;
-		}
-
-		if (is_disp)
-			reg[i].pdata.plane_grp = plane_grp;
-
-		pdev = platform_device_alloc(reg[i].name, id++);
-		if (!pdev) {
-			ret = -ENOMEM;
-			goto err_register;
-		}
-
-		pdev->dev.parent = dev;
-
-		reg[i].pdata.of_node = of_node;
-		ret = platform_device_add_data(pdev, &reg[i].pdata,
-					       sizeof(reg[i].pdata));
-		if (!ret)
-			ret = platform_device_add(pdev);
-		if (ret) {
-			platform_device_put(pdev);
-			goto err_register;
-		}
-	}
-
-	return 0;
-
-err_register:
-	platform_device_unregister_children(to_platform_device(dev));
-err_get_plane_res:
-	dpu_put_plane_resource(&plane_grp->res);
-
-	return ret;
-}
-
-#define IRQSTEER_CHANnCTL	0x0
-#define IRQSTEER_CHANnCTL_CH(n)	BIT(n)
-#define IRQSTEER_CHANnMASK(n)	((n) + 4)
-#define LINE_TO_MASK_OFFSET(n)	((15 - ((n) / 32)) * 4)
-#define LINE_TO_MASK_SHIFT(n)	((n) % 32)
-
-static void dpu_irq_gc_mask_set_bit(struct irq_data *d)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct irq_chip_type *ct = irq_data_get_chip_type(d);
-	struct dpu_soc *dpu = gc->domain->host_data;
-	unsigned long flags;
-	u32 mask = d->mask;
-
-	irq_gc_lock(gc);
-	spin_lock_irqsave(&dpu->intsteer_lock, flags);
-	if (++dpu->intsteer_usecount == 1)
-		/* assuming fast I/O regmap */
-		regmap_write(dpu->intsteer_regmap, IRQSTEER_CHANnCTL,
-				IRQSTEER_CHANnCTL_CH(0));
-	spin_unlock_irqrestore(&dpu->intsteer_lock, flags);
-	*ct->mask_cache |= mask;
-	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
-	irq_gc_unlock(gc);
-}
-
-static void dpu_irq_gc_mask_clr_bit(struct irq_data *d)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct irq_chip_type *ct = irq_data_get_chip_type(d);
-	struct dpu_soc *dpu = gc->domain->host_data;
-	unsigned long flags;
-	u32 mask = d->mask;
-
-	irq_gc_lock(gc);
-	spin_lock_irqsave(&dpu->intsteer_lock, flags);
-	if (!--dpu->intsteer_usecount) {
-		WARN(dpu->intsteer_usecount < 0,
-			"intsteer usecount %d is less than zero",
-			dpu->intsteer_usecount);
-		regmap_write(dpu->intsteer_regmap, IRQSTEER_CHANnCTL, 0);
-	}
-	spin_unlock_irqrestore(&dpu->intsteer_lock, flags);
-	*ct->mask_cache &= ~mask;
-	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
-	irq_gc_unlock(gc);
-}
-
-static void dpu_intsteer_enable_line(struct dpu_soc *dpu, unsigned int line)
-{
-	unsigned int offset = LINE_TO_MASK_OFFSET(line);
-	unsigned int shift = LINE_TO_MASK_SHIFT(line);
-
-	regmap_update_bits(dpu->intsteer_regmap, IRQSTEER_CHANnMASK(offset),
-			   BIT(shift), BIT(shift));
-}
-
-static int dpu_irq_init(struct dpu_soc *dpu)
-{
-	const struct dpu_devtype *devtype = dpu->devtype;
-	const struct cm_reg_ofs *ofs = devtype->cm_reg_ofs;
-	struct irq_chip_generic *gc;
-	struct irq_chip_type *ct;
-	int ret, i;
-
-	for (i = 0; i < devtype->intsteer_map_size; i++) {
-		if (devtype->intsteer_map[i] == NA)
-			continue;
-
-		dpu_intsteer_enable_line(dpu, devtype->intsteer_map[i]);
-	}
-
-	dpu->domain = irq_domain_add_linear(dpu->dev->of_node,
-					    devtype->intsteer_map_size,
-					    &irq_generic_chip_ops, dpu);
-	if (!dpu->domain) {
-		dev_err(dpu->dev, "failed to add irq domain\n");
-		return -ENODEV;
-	}
-
-	ret = irq_alloc_domain_generic_chips(dpu->domain, 32, 1, "DPU",
-					     handle_level_irq, 0, 0, 0);
-	if (ret < 0) {
-		dev_err(dpu->dev, "failed to alloc generic irq chips\n");
-		irq_domain_remove(dpu->domain);
-		return ret;
-	}
-
-	for (i = 0; i < devtype->intsteer_map_size; i += 32) {
-		/* Mask and clear all interrupts */
-		dpu_cm_write(dpu, 0,
-					USERINTERRUPTENABLE(ofs, i / 32));
-		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
-					USERINTERRUPTCLEAR(ofs, i / 32));
-		dpu_cm_write(dpu, 0,
-					INTERRUPTENABLE(ofs, i / 32));
-		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
-					INTERRUPTCLEAR(ofs, i / 32));
-
-		/* Set all interrupts to user mode */
-		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
-					USERINTERRUPTMASK(ofs, i / 32));
-
-		gc = irq_get_domain_generic_chip(dpu->domain, i);
-		gc->reg_base = dpu->cm_reg;
-		gc->unused = devtype->unused_irq[i / 32];
-		ct = gc->chip_types;
-		ct->chip.irq_ack = irq_gc_ack_set_bit;
-		ct->chip.irq_mask = dpu_irq_gc_mask_clr_bit;
-		ct->chip.irq_unmask = dpu_irq_gc_mask_set_bit;
-		ct->regs.ack = USERINTERRUPTCLEAR(ofs, i / 32);
-		ct->regs.mask = USERINTERRUPTENABLE(ofs, i / 32);
-	}
-
-#define DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(name)	\
-irq_set_chained_handler_and_data(dpu->irq_##name, dpu_##name##_irq_handler, dpu)
-
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(cm);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(stream0a);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(stream1a);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(reserved0);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(reserved1);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(blit);
-
-	return 0;
-}
-
-static void dpu_irq_exit(struct dpu_soc *dpu)
-{
-	const struct dpu_devtype *devtype = dpu->devtype;
-	unsigned int i, irq;
-
-#define DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(name)	\
-irq_set_chained_handler_and_data(dpu->irq_##name, NULL, NULL)
-
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(cm);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(stream0a);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(stream1a);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(reserved0);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(reserved1);
-	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(blit);
-
-	for (i = 0; i < devtype->intsteer_map_size; i++) {
-		irq = irq_linear_revmap(dpu->domain, i);
-		if (irq)
-			irq_dispose_mapping(irq);
-	}
-
-	irq_domain_remove(dpu->domain);
-}
-
-static void dpu_debug_ip_identity(struct dpu_soc *dpu)
-{
-	struct device *dev = dpu->dev;
-	const struct cm_reg_ofs *ofs = dpu->devtype->cm_reg_ofs;
-	u32 reg;
-	int id = 0;
-
-	reg = dpu_cm_read(dpu, IPIDENTIFIER(ofs));
-
-	dev_dbg(dev, "%d) Maturatiy level:\n", ++id);
-	switch (reg & DESIGNMATURITYLEVEL_MASK) {
-	case DESIGNMATURITYLEVEL__PREFS:
-		dev_dbg(dev, "\tPre feasibility study.\n");
-		break;
-	case DESIGNMATURITYLEVEL__FS:
-		dev_dbg(dev, "\tFeasibility study.\n");
-		break;
-	case DESIGNMATURITYLEVEL__R0:
-		dev_dbg(dev, "\tFunctionality complete.\n");
-		break;
-	case DESIGNMATURITYLEVEL__R1:
-		dev_dbg(dev, "\tVerification complete.\n");
-		break;
-	default:
-		dev_dbg(dev, "\tUnknown.\n");
-		break;
-	}
-
-	dev_dbg(dev, "%d) IP feature set:\n", ++id);
-	switch (reg & IPFEATURESET_MASK) {
-	case IPFEATURESET__E:
-		dev_dbg(dev, "\tMinimal functionality (Eco).\n");
-		break;
-	case IPFEATURESET__L:
-		dev_dbg(dev, "\tReduced functionality (Light).\n");
-		break;
-	case IPFEATURESET__P:
-		dev_dbg(dev, "\tAdvanced functionality (Plus).\n");
-		break;
-	case IPFEATURESET__X:
-		dev_dbg(dev, "\tExtensive functionality (eXtensive).\n");
-		break;
-	default:
-		dev_dbg(dev, "\tUnknown.\n");
-		break;
-	}
-
-	dev_dbg(dev, "%d) IP application:\n", ++id);
-	switch (reg & IPAPPLICATION_MASK) {
-	case IPAPPLICATION__B:
-		dev_dbg(dev, "\tBlit engine only.\n");
-		break;
-	case IPAPPLICATION__D:
-		dev_dbg(dev, "\tBlit engine and display controller.\n");
-		break;
-	case IPAPPLICATION__V:
-		dev_dbg(dev, "\tDisplay controller only "
-					"(with direct capture).\n");
-		break;
-	case IPAPPLICATION__G:
-		dev_dbg(dev, "\tBlit engine, display controller "
-					"(with direct capture),\n"
-				   "\tcapture controller (buffered capture) "
-				   "and drawing engine.\n");
-		break;
-	case IPAPPLICATION__C:
-		dev_dbg(dev, "\tDisplay controller only.\n");
-		break;
-	default:
-		dev_dbg(dev, "\tUnknown.\n");
-		break;
-	}
-
-	dev_dbg(dev, "%d) IP configuration:\n", ++id);
-	switch (reg & IPCONFIGURATION_MASK) {
-	case IPCONFIGURATION__M:
-		dev_dbg(dev, "\tGraphics core only (Module).\n");
-		break;
-	case IPCONFIGURATION__S:
-		dev_dbg(dev, "\tSubsystem including a graphics core "
-							"(System).\n");
-		break;
-	default:
-		dev_dbg(dev, "\tUnknown.\n");
-		break;
-	}
-
-	dev_dbg(dev, "%d) IP family:\n", ++id);
-	switch (reg & IPFAMILY_MASK) {
-	case IPFAMILY__IMXDPU2010:
-		dev_dbg(dev, "\tBuilding block generation 2010.\n");
-		break;
-	case IPFAMILY__IMXDPU2012:
-		dev_dbg(dev, "\tBuilding block generation 2012.\n");
-		break;
-	case IPFAMILY__IMXDPU2013:
-		dev_dbg(dev, "\tBuilding block generation 2013.\n");
-		break;
-	default:
-		dev_dbg(dev, "\tUnknown.\n");
-		break;
-	}
-}
-
-/* FIXME: set pixel link in a proper manner */
-static int dpu_pixel_link_config(int id)
-{
-	sc_err_t sciErr;
-	sc_ipc_t ipcHndl = 0;
-	u32 mu_id;
-
-	sciErr = sc_ipc_getMuID(&mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		pr_err("Cannot obtain MU ID\n");
-		return sciErr;
-	}
-
-	sciErr = sc_ipc_open(&ipcHndl, mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
-		return sciErr;
-	}
-
-	if (id == 0) {
-		/* Enable All Display Pixel Links */
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_ADDR, 0);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_ENB, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_VLD, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_ADDR, 0);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_ENB, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_VLD, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		/* todo: move SC_C_SYNC_CTRL0 to after first valid frame */
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_SYNC_CTRL0, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_SYNC_CTRL0 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		/* todo: move SC_C_SYNC_CTRL1 to after first valid frame */
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_SYNC_CTRL1, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_0:SC_C_SYNC_CTRL1 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-	} else if (id == 1) {
-		/* Enable All Display Pixel Links */
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_ADDR, 0);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_ENB, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_VLD, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_ADDR, 0);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_ENB, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_VLD, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		/* todo: move SC_C_SYNC_CTRL0 to after first valid frame */
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_SYNC_CTRL0, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_SYNC_CTRL0 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-
-		/* todo: move SC_C_SYNC_CTRL1 to after first valid frame */
-		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_SYNC_CTRL1, 1);
-		if (sciErr != SC_ERR_NONE)
-			pr_err("SC_R_DC_1:SC_C_SYNC_CTRL1 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
-	}
-
-	sc_ipc_close(mu_id);
-	return sciErr;
-}
-
-static int dpu_probe(struct platform_device *pdev)
-{
-	const struct of_device_id *of_id =
-			of_match_device(dpu_dt_ids, &pdev->dev);
-	struct device_node *np = pdev->dev.of_node;
-	struct dpu_soc *dpu;
-	struct resource *res;
-	unsigned long dpu_base;
-	const struct dpu_devtype *devtype;
-	int ret;
-
-	devtype = of_id->data;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENODEV;
-
-	dpu_base = res->start;
-
-	dpu = devm_kzalloc(&pdev->dev, sizeof(*dpu), GFP_KERNEL);
-	if (!dpu)
-		return -ENODEV;
-
-	dpu->dev = &pdev->dev;
-	dpu->devtype = devtype;
-	dpu->id = of_alias_get_id(np, "dpu");
-
-	dpu->irq_cm = platform_get_irq(pdev, 0);
-	dpu->irq_stream0a = platform_get_irq(pdev, 1);
-	dpu->irq_stream1a = platform_get_irq(pdev, 3);
-	dpu->irq_reserved0 = platform_get_irq(pdev, 5);
-	dpu->irq_reserved1 = platform_get_irq(pdev, 6);
-	dpu->irq_blit = platform_get_irq(pdev, 7);
-
-	dev_dbg(dpu->dev, "irq_cm: %d\n", dpu->irq_cm);
-	dev_dbg(dpu->dev, "irq_stream0a: %d, irq_stream1a: %d\n",
-			dpu->irq_stream0a, dpu->irq_stream1a);
-	dev_dbg(dpu->dev, "irq_reserved0: %d, irq_reserved1: %d\n",
-			dpu->irq_reserved0, dpu->irq_reserved1);
-	dev_dbg(dpu->dev, "irq_blit: %d\n", dpu->irq_blit);
-
-	if (dpu->irq_cm < 0 ||
-	    dpu->irq_stream0a < 0 || dpu->irq_stream1a < 0 ||
-	    dpu->irq_reserved0 < 0 || dpu->irq_reserved1 < 0 ||
-	    dpu->irq_blit < 0)
-		return -ENODEV;
-
-	dpu->intsteer_regmap = syscon_regmap_lookup_by_phandle(np, "intsteer");
-	if (IS_ERR(dpu->intsteer_regmap)) {
-		dev_err(dpu->dev, "failed to get intsteer regmap\n");
-		return PTR_ERR(dpu->intsteer_regmap);
-	}
-
-	spin_lock_init(&dpu->lock);
-	spin_lock_init(&dpu->intsteer_lock);
-
-	dev_dbg(dpu->dev, "Common: 0x%08lx\n", dpu_base + devtype->cm_ofs);
-	DPU_UNITS_ADDR_DBG(cf);
-	DPU_UNITS_ADDR_DBG(dec);
-	DPU_UNITS_ADDR_DBG(ed);
-	DPU_UNITS_ADDR_DBG(fd);
-	DPU_UNITS_ADDR_DBG(fg);
-	DPU_UNITS_ADDR_DBG(fl);
-	DPU_UNITS_ADDR_DBG(lb);
-	DPU_UNITS_ADDR_DBG(tcon);
-
-	dpu->cm_reg = devm_ioremap(dpu->dev, dpu_base + devtype->cm_ofs, SZ_1K);
-	if (!dpu->cm_reg)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, dpu);
-
-	ret = dpu_irq_init(dpu);
-	if (ret)
-		goto failed_irq;
-
-	ret = dpu_submodules_init(dpu, pdev, dpu_base);
-	if (ret)
-		goto failed_submodules_init;
-
-	ret = dpu_add_client_devices(dpu);
-	if (ret) {
-		dev_err(dpu->dev, "adding client devices failed with %d\n",
-					ret);
-		goto failed_add_clients;
-	}
-
-	dpu_debug_ip_identity(dpu);
-
-	if (devtype->pixel_link_quirks)
-		dpu_pixel_link_config(dpu->id);
-
-	dev_info(dpu->dev, "driver probed\n");
-
-	return 0;
-
-failed_add_clients:
-failed_submodules_init:
-	dpu_irq_exit(dpu);
-failed_irq:
-	return ret;
-}
-
-static int dpu_remove(struct platform_device *pdev)
-{
-	struct dpu_soc *dpu = platform_get_drvdata(pdev);
-
-	platform_device_unregister_children(pdev);
-	dpu_irq_exit(dpu);
-
-	return 0;
-}
-
-static struct platform_driver dpu_driver = {
-	.driver = {
-		.name = "dpu-core",
-		.of_match_table = dpu_dt_ids,
-	},
-	.probe = dpu_probe,
-	.remove = dpu_remove,
-};
-
-module_platform_driver(dpu_driver);
-
-MODULE_DESCRIPTION("i.MX DPU driver");
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/dpu/dpu-constframe.c b/drivers/gpu/dpu/dpu-constframe.c
deleted file mode 100644
index 77718cd..0000000
--- a/drivers/gpu/dpu/dpu-constframe.c
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define FRAMEDIMENSIONS		0xC
-#define WIDTH(w)		(((w) - 1) & 0x3FFF)
-#define HEIGHT(h)		((((h) - 1) & 0x3FFF) << 16)
-#define CONSTANTCOLOR		0x10
-#define RED(r)			(((r) & 0xFF) << 24)
-#define GREEN(g)		(((g) & 0xFF) << 16)
-#define BLUE(b)			(((b) & 0xFF) << 8)
-#define ALPHA(a)		((a) & 0xFF)
-#define CONTROLTRIGGER		0x14
-#define START			0x18
-#define STATUS			0x1C
-
-static const shadow_load_req_t cf_shdlreqs[] = {
-	SHLDREQID_CONSTFRAME0, SHLDREQID_CONSTFRAME1,
-	SHLDREQID_CONSTFRAME4, SHLDREQID_CONSTFRAME5,
-};
-
-struct dpu_constframe {
-	void __iomem *pec_base;
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-	shadow_load_req_t shdlreq;
-};
-
-static inline void dpu_cf_write(struct dpu_constframe *cf, u32 value,
-				unsigned int offset)
-{
-	writel(value, cf->base + offset);
-}
-
-void constframe_shden(struct dpu_constframe *cf, bool enable)
-{
-	u32 val;
-
-	val = enable ? SHDEN : 0;
-
-	mutex_lock(&cf->mutex);
-	dpu_cf_write(cf, val, STATICCONTROL);
-	mutex_unlock(&cf->mutex);
-}
-EXPORT_SYMBOL_GPL(constframe_shden);
-
-void constframe_framedimensions(struct dpu_constframe *cf, unsigned int w,
-				unsigned int h)
-{
-	u32 val;
-
-	val = WIDTH(w) | HEIGHT(h);
-
-	mutex_lock(&cf->mutex);
-	dpu_cf_write(cf, val, FRAMEDIMENSIONS);
-	mutex_unlock(&cf->mutex);
-}
-EXPORT_SYMBOL_GPL(constframe_framedimensions);
-
-void constframe_constantcolor(struct dpu_constframe *cf, unsigned int r,
-			      unsigned int g, unsigned int b, unsigned int a)
-{
-	u32 val;
-
-	val = RED(r) | GREEN(g) | BLUE(b) | ALPHA(a);
-
-	mutex_lock(&cf->mutex);
-	dpu_cf_write(cf, val, CONSTANTCOLOR);
-	mutex_unlock(&cf->mutex);
-}
-EXPORT_SYMBOL_GPL(constframe_constantcolor);
-
-void constframe_controltrigger(struct dpu_constframe *cf, bool trigger)
-{
-	u32 val;
-
-	val = trigger ? SHDTOKGEN : 0;
-
-	mutex_lock(&cf->mutex);
-	dpu_cf_write(cf, val, CONTROLTRIGGER);
-	mutex_unlock(&cf->mutex);
-}
-EXPORT_SYMBOL_GPL(constframe_controltrigger);
-
-shadow_load_req_t constframe_to_shdldreq_t(struct dpu_constframe *cf)
-{
-	shadow_load_req_t t = 0;
-
-	switch (cf->id) {
-	case 0:
-		t = SHLDREQID_CONSTFRAME0;
-		break;
-	case 1:
-		t = SHLDREQID_CONSTFRAME1;
-		break;
-	case 4:
-		t = SHLDREQID_CONSTFRAME4;
-		break;
-	case 5:
-		t = SHLDREQID_CONSTFRAME5;
-		break;
-	}
-
-	return t;
-}
-EXPORT_SYMBOL_GPL(constframe_to_shdldreq_t);
-
-struct dpu_constframe *dpu_cf_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_constframe *cf;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(cf_ids); i++)
-		if (cf_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(cf_ids))
-		return ERR_PTR(-EINVAL);
-
-	cf = dpu->cf_priv[i];
-
-	mutex_lock(&cf->mutex);
-
-	if (cf->inuse) {
-		cf = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	cf->inuse = true;
-out:
-	mutex_unlock(&cf->mutex);
-
-	return cf;
-}
-EXPORT_SYMBOL_GPL(dpu_cf_get);
-
-void dpu_cf_put(struct dpu_constframe *cf)
-{
-	mutex_lock(&cf->mutex);
-
-	cf->inuse = false;
-
-	mutex_unlock(&cf->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_cf_put);
-
-int dpu_cf_init(struct dpu_soc *dpu, unsigned int id,
-		unsigned long pec_base, unsigned long base)
-{
-	struct dpu_constframe *cf;
-	int i;
-
-	cf = devm_kzalloc(dpu->dev, sizeof(*cf), GFP_KERNEL);
-	if (!cf)
-		return -ENOMEM;
-
-	for (i = 0; i < ARRAY_SIZE(cf_ids); i++)
-		if (cf_ids[i] == id)
-			break;
-
-	dpu->cf_priv[i] = cf;
-
-	cf->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
-	if (!cf->pec_base)
-		return -ENOMEM;
-
-	cf->base = devm_ioremap(dpu->dev, base, SZ_32);
-	if (!cf->base)
-		return -ENOMEM;
-
-	cf->dpu = dpu;
-	cf->id = id;
-	cf->shdlreq = cf_shdlreqs[i];
-
-	mutex_init(&cf->mutex);
-
-	constframe_shden(cf, true);
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-disengcfg.c b/drivers/gpu/dpu/dpu-disengcfg.c
deleted file mode 100644
index 0568892..0000000
--- a/drivers/gpu/dpu/dpu-disengcfg.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <drm/drm_mode.h>
-#include <linux/io.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "dpu-prv.h"
-
-#define CLOCKCTRL		0x8
-typedef enum {
-	DSPCLKDIVIDE__DIV1,	/* Ext disp clk signal has pix clk freq. */
-	DSPCLKDIVIDE__DIV2,	/* Ext disp clk signal has 2x the pix clk freq. */
-} clkdivide_t;
-#define POLARITYCTRL		0xC
-#define POLHS_HIGH		BIT(0)
-#define POLVS_HIGH		BIT(1)
-#define POLEN_HIGH		BIT(2)
-#define PIXINV_INV		BIT(3)
-#define SRCSELECT		0x10
-
-struct dpu_disengcfg {
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-};
-
-static inline u32 dpu_dec_read(struct dpu_disengcfg *dec, unsigned int offset)
-{
-	return readl(dec->base + offset);
-}
-
-static inline void dpu_dec_write(struct dpu_disengcfg *dec, u32 value,
-				 unsigned int offset)
-{
-	writel(value, dec->base + offset);
-}
-
-void disengcfg_polarity_ctrl(struct dpu_disengcfg *dec, unsigned int flags)
-{
-	const struct dpu_devtype *devtype = dec->dpu->devtype;
-	u32 val;
-
-	mutex_lock(&dec->mutex);
-	val = dpu_dec_read(dec, POLARITYCTRL);
-	if (devtype->pixel_link_nhvsync) {
-		val &= ~POLHS_HIGH;
-		val &= ~POLVS_HIGH;
-	} else {
-		if (flags & DRM_MODE_FLAG_PHSYNC)
-			val |= POLHS_HIGH;
-		if (flags & DRM_MODE_FLAG_NHSYNC)
-			val &= ~POLHS_HIGH;
-		if (flags & DRM_MODE_FLAG_PVSYNC)
-			val |= POLVS_HIGH;
-		if (flags & DRM_MODE_FLAG_NVSYNC)
-			val &= ~POLVS_HIGH;
-	}
-	dpu_dec_write(dec, val, POLARITYCTRL);
-	mutex_unlock(&dec->mutex);
-}
-EXPORT_SYMBOL_GPL(disengcfg_polarity_ctrl);
-
-struct dpu_disengcfg *dpu_dec_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_disengcfg *dec;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dec_ids); i++)
-		if (dec_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(dec_ids))
-		return ERR_PTR(-EINVAL);
-
-	dec = dpu->dec_priv[i];
-
-	mutex_lock(&dec->mutex);
-
-	if (dec->inuse) {
-		dec = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	dec->inuse = true;
-out:
-	mutex_unlock(&dec->mutex);
-
-	return dec;
-}
-EXPORT_SYMBOL_GPL(dpu_dec_get);
-
-void dpu_dec_put(struct dpu_disengcfg *dec)
-{
-	mutex_lock(&dec->mutex);
-
-	dec->inuse = false;
-
-	mutex_unlock(&dec->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_dec_put);
-
-int dpu_dec_init(struct dpu_soc *dpu, unsigned int id,
-			unsigned long unused, unsigned long base)
-{
-	struct dpu_disengcfg *dec;
-
-	dec = devm_kzalloc(dpu->dev, sizeof(*dec), GFP_KERNEL);
-	if (!dec)
-		return -ENOMEM;
-
-	dpu->dec_priv[id] = dec;
-
-	dec->base = devm_ioremap(dpu->dev, base, SZ_16);
-	if (!dec->base)
-		return -ENOMEM;
-
-	dec->dpu = dpu;
-	dec->id = id;
-	mutex_init(&dec->mutex);
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-extdst.c b/drivers/gpu/dpu/dpu-extdst.c
deleted file mode 100644
index fdb8572..0000000
--- a/drivers/gpu/dpu/dpu-extdst.c
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define PIXENGCFG_STATIC		0x8
-#define POWERDOWN			BIT(4)
-#define SYNC_MODE			BIT(8)
-#define SW_RESET			BIT(11)
-#define DIV(n)				(((n) & 0xFF) << 16)
-#define DIV_RESET			0x80
-#define PIXENGCFG_DYNAMIC		0xC
-#define PIXENGCFG_REQUEST		0x10
-#define SHDLDREQ(n)			BIT(n)
-#define SEL_SHDLDREQ			BIT(0)
-#define PIXENGCFG_TRIGGER		0x14
-#define SYNC_TRIGGER			BIT(0)
-#define TRIGGER_SEQUENCE_COMPLETE	BIT(4)
-#define PIXENGCFG_STATUS		0x18
-#define SYNC_BUSY			BIT(8)
-#define KICK_MODE			BIT(8)
-#define PERFCOUNTMODE			BIT(12)
-#define CONTROL				0xC
-#define GAMMAAPPLYENABLE		BIT(0)
-#define SOFTWAREKICK			0x10
-#define KICK				BIT(0)
-#define STATUS				0x14
-#define CNT_ERR_STS			BIT(0)
-#define CONTROLWORD			0x18
-#define CURPIXELCNT			0x1C
-static u16 get_xval(u32 pixel_cnt)
-{
-	return pixel_cnt && 0xFF;
-}
-
-static u16 get_yval(u32 pixel_cnt)
-{
-	return pixel_cnt >> 16;
-}
-#define LASTPIXELCNT			0x20
-#define PERFCOUNTER			0x24
-
-struct dpu_extdst {
-	void __iomem *pec_base;
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-};
-
-static inline u32 dpu_pec_ed_read(struct dpu_extdst *ed, unsigned int offset)
-{
-	return readl(ed->pec_base + offset);
-}
-
-static inline void dpu_pec_ed_write(struct dpu_extdst *ed, u32 value,
-				unsigned int offset)
-{
-	writel(value, ed->pec_base + offset);
-}
-
-static inline u32 dpu_ed_read(struct dpu_extdst *ed, unsigned int offset)
-{
-	return readl(ed->base + offset);
-}
-
-static inline void dpu_ed_write(struct dpu_extdst *ed, u32 value,
-				unsigned int offset)
-{
-	writel(value, ed->base + offset);
-}
-
-static inline bool dpu_ed_is_safety_stream(struct dpu_extdst *ed)
-{
-	if (ed->id == 4 || ed->id == 5)
-		return true;
-
-	return false;
-}
-
-static inline bool dpu_ed_src_sel_is_extsrc(extdst_src_sel_t src)
-{
-	if (src == ED_SRC_EXTSRC4 || src == ED_SRC_EXTSRC5)
-		return true;
-
-	return false;
-}
-
-void extdst_pixengcfg_shden(struct dpu_extdst *ed, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
-	if (enable)
-		val |= SHDEN;
-	else
-		val &= ~SHDEN;
-	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_shden);
-
-void extdst_pixengcfg_powerdown(struct dpu_extdst *ed, bool powerdown)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
-	if (powerdown)
-		val |= POWERDOWN;
-	else
-		val &= ~POWERDOWN;
-	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_powerdown);
-
-void extdst_pixengcfg_sync_mode(struct dpu_extdst *ed, ed_sync_mode_t mode)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
-	if (mode == AUTO)
-		val |= SYNC_MODE;
-	else
-		val &= ~SYNC_MODE;
-	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_sync_mode);
-
-void extdst_pixengcfg_reset(struct dpu_extdst *ed, bool reset)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
-	if (reset)
-		val |= SW_RESET;
-	else
-		val &= ~SW_RESET;
-	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_reset);
-
-void extdst_pixengcfg_div(struct dpu_extdst *ed, u16 div)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
-	val &= ~0xFF0000;
-	val |= DIV(div);
-	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_div);
-
-int extdst_pixengcfg_src_sel(struct dpu_extdst *ed, extdst_src_sel_t src)
-{
-	struct dpu_soc *dpu = ed->dpu;
-	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
-	u32 mapped_src;
-
-	mapped_src = block_id_map ? block_id_map[src] : src;
-	if (WARN_ON(mapped_src == NA))
-		return -EINVAL;
-
-	if (dpu_ed_is_safety_stream(ed) && dpu_ed_src_sel_is_extsrc(src)) {
-		dev_err(dpu->dev, "ExtDst%d source cannot be ExtSrc\n", ed->id);
-		return -EINVAL;
-	}
-
-	mutex_lock(&ed->mutex);
-	dpu_pec_ed_write(ed, mapped_src, PIXENGCFG_DYNAMIC);
-	mutex_unlock(&ed->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_src_sel);
-
-void extdst_pixengcfg_sel_shdldreq(struct dpu_extdst *ed)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_REQUEST);
-	val |= SEL_SHDLDREQ;
-	dpu_pec_ed_write(ed, val, PIXENGCFG_REQUEST);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_sel_shdldreq);
-
-void extdst_pixengcfg_shdldreq(struct dpu_extdst *ed, u32 req_mask)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_REQUEST);
-	val |= req_mask;
-	dpu_pec_ed_write(ed, val, PIXENGCFG_REQUEST);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_shdldreq);
-
-void extdst_pixengcfg_sync_trigger(struct dpu_extdst *ed)
-{
-	mutex_lock(&ed->mutex);
-	dpu_pec_ed_write(ed, SYNC_TRIGGER, PIXENGCFG_TRIGGER);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_sync_trigger);
-
-void extdst_pixengcfg_trigger_sequence_complete(struct dpu_extdst *ed)
-{
-	mutex_lock(&ed->mutex);
-	dpu_pec_ed_write(ed, TRIGGER_SEQUENCE_COMPLETE, PIXENGCFG_TRIGGER);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_trigger_sequence_complete);
-
-bool extdst_pixengcfg_is_sync_busy(struct dpu_extdst *ed)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATUS);
-	mutex_unlock(&ed->mutex);
-
-	return val & SYNC_BUSY;
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_is_sync_busy);
-
-ed_pipeline_status_t extdst_pixengcfg_pipeline_status(struct dpu_extdst *ed)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_pec_ed_read(ed, PIXENGCFG_STATUS);
-	mutex_unlock(&ed->mutex);
-
-	return val & 0x3;
-}
-EXPORT_SYMBOL_GPL(extdst_pixengcfg_pipeline_status);
-
-void extdst_shden(struct dpu_extdst *ed, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, STATICCONTROL);
-	if (enable)
-		val |= SHDEN;
-	else
-		val &= ~SHDEN;
-	dpu_ed_write(ed, val, STATICCONTROL);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_shden);
-
-void extdst_kick_mode(struct dpu_extdst *ed, ed_kick_mode_t mode)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, STATICCONTROL);
-	val &= ~KICK_MODE;
-	val |= mode;
-	dpu_ed_write(ed, val, STATICCONTROL);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_kick_mode);
-
-void extdst_perfcountmode(struct dpu_extdst *ed, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, STATICCONTROL);
-	if (enable)
-		val |= PERFCOUNTMODE;
-	else
-		val &= ~PERFCOUNTMODE;
-	dpu_ed_write(ed, val, STATICCONTROL);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_perfcountmode);
-
-void extdst_gamma_apply_enable(struct dpu_extdst *ed, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, CONTROL);
-	if (enable)
-		val |= GAMMAAPPLYENABLE;
-	else
-		val &= ~GAMMAAPPLYENABLE;
-	dpu_ed_write(ed, val, CONTROL);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_gamma_apply_enable);
-
-void extdst_kick(struct dpu_extdst *ed)
-{
-	mutex_lock(&ed->mutex);
-	dpu_ed_write(ed, KICK, SOFTWAREKICK);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_kick);
-
-void extdst_cnt_err_clear(struct dpu_extdst *ed)
-{
-	mutex_lock(&ed->mutex);
-	dpu_ed_write(ed, CNT_ERR_STS, STATUS);
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(extdst_cnt_err_clear);
-
-bool extdst_cnt_err_status(struct dpu_extdst *ed)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, STATUS);
-	mutex_unlock(&ed->mutex);
-
-	return val & CNT_ERR_STS;
-}
-EXPORT_SYMBOL_GPL(extdst_cnt_err_status);
-
-u32 extdst_last_control_word(struct dpu_extdst *ed)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, CONTROLWORD);
-	mutex_unlock(&ed->mutex);
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(extdst_last_control_word);
-
-void extdst_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, CURPIXELCNT);
-	mutex_unlock(&ed->mutex);
-
-	*x = get_xval(val);
-	*y = get_yval(val);
-}
-EXPORT_SYMBOL_GPL(extdst_pixel_cnt);
-
-void extdst_last_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, LASTPIXELCNT);
-	mutex_unlock(&ed->mutex);
-
-	*x = get_xval(val);
-	*y = get_yval(val);
-}
-EXPORT_SYMBOL_GPL(extdst_last_pixel_cnt);
-
-u32 extdst_perfresult(struct dpu_extdst *ed)
-{
-	u32 val;
-
-	mutex_lock(&ed->mutex);
-	val = dpu_ed_read(ed, PERFCOUNTER);
-	mutex_unlock(&ed->mutex);
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(extdst_perfresult);
-
-struct dpu_extdst *dpu_ed_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_extdst *ed;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ed_ids); i++)
-		if (ed_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(ed_ids))
-		return ERR_PTR(-EINVAL);
-
-	ed = dpu->ed_priv[i];
-
-	mutex_lock(&ed->mutex);
-
-	if (ed->inuse) {
-		ed = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	ed->inuse = true;
-out:
-	mutex_unlock(&ed->mutex);
-
-	return ed;
-}
-EXPORT_SYMBOL_GPL(dpu_ed_get);
-
-void dpu_ed_put(struct dpu_extdst *ed)
-{
-	mutex_lock(&ed->mutex);
-
-	ed->inuse = false;
-
-	mutex_unlock(&ed->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_ed_put);
-
-int dpu_ed_init(struct dpu_soc *dpu, unsigned int id,
-		unsigned long pec_base, unsigned long base)
-{
-	struct dpu_extdst *ed;
-	int ret, i;
-
-	ed = devm_kzalloc(dpu->dev, sizeof(*ed), GFP_KERNEL);
-	if (!ed)
-		return -ENOMEM;
-
-	for (i = 0; i < ARRAY_SIZE(ed_ids); i++)
-		if (ed_ids[i] == id)
-			break;
-
-	dpu->ed_priv[i] = ed;
-
-	ed->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_32);
-	if (!ed->pec_base)
-		return -ENOMEM;
-
-	ed->base = devm_ioremap(dpu->dev, base, SZ_64);
-	if (!ed->base)
-		return -ENOMEM;
-
-	ed->dpu = dpu;
-	ed->id = id;
-	mutex_init(&ed->mutex);
-
-	ret = extdst_pixengcfg_src_sel(ed, ED_SRC_DISABLE);
-	if (ret < 0)
-		return ret;
-
-	extdst_pixengcfg_shden(ed, true);
-	extdst_pixengcfg_powerdown(ed, false);
-	extdst_pixengcfg_sync_mode(ed, SINGLE);
-	extdst_pixengcfg_reset(ed, false);
-	extdst_pixengcfg_div(ed, DIV_RESET);
-	extdst_shden(ed, true);
-	extdst_perfcountmode(ed, false);
-	extdst_kick_mode(ed, EXTERNAL);
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-fetchdecode.c b/drivers/gpu/dpu/dpu-fetchdecode.c
deleted file mode 100644
index d0eaf66..0000000
--- a/drivers/gpu/dpu/dpu-fetchdecode.c
+++ /dev/null
@@ -1,503 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define PIXENGCFG_DYNAMIC		0x8
-#define SRC_NUM				3
-#define FD_NUM				4
-static const fd_dynamic_src_sel_t fd_srcs[FD_NUM][SRC_NUM] = {
-	{ FD_SRC_DISABLE, FD_SRC_FETCHECO0, FD_SRC_FETCHDECODE2 },
-	{ FD_SRC_DISABLE, FD_SRC_FETCHECO1, FD_SRC_FETCHDECODE3 },
-	{ FD_SRC_DISABLE, FD_SRC_FETCHECO0, FD_SRC_FETCHECO2 },
-	{ FD_SRC_DISABLE, FD_SRC_FETCHECO1, FD_SRC_FETCHECO2 },
-};
-
-#define PIXENGCFG_STATUS		0xC
-
-#define RINGBUFSTARTADDR0		0x10
-#define RINGBUFWRAPADDR0		0x14
-#define FRAMEPROPERTIES0		0x18
-#define BASEADDRESS0			0x1C
-#define SOURCEBUFFERATTRIBUTES0		0x20
-#define SOURCEBUFFERDIMENSION0		0x24
-#define COLORCOMPONENTBITS0		0x28
-#define COLORCOMPONENTSHIFT0		0x2C
-#define LAYEROFFSET0			0x30
-#define CLIPWINDOWOFFSET0		0x34
-#define CLIPWINDOWDIMENSIONS0		0x38
-#define CONSTANTCOLOR0			0x3C
-#define LAYERPROPERTY0			0x40
-#define FRAMEDIMENSIONS			0x44
-#define FRAMERESAMPLING			0x48
-#define DECODECONTROL			0x4C
-#define SOURCEBUFFERLENGTH		0x50
-#define CONTROL				0x54
-#define CONTROLTRIGGER			0x58
-#define START				0x5C
-#define FETCHTYPE			0x60
-#define DECODERSTATUS			0x64
-#define READADDRESS0			0x68
-#define BURSTBUFFERPROPERTIES		0x6C
-#define STATUS				0x70
-#define HIDDENSTATUS			0x74
-
-static const shadow_load_req_t fd_shdlreqs[] = {
-	SHLDREQID_FETCHDECODE0, SHLDREQID_FETCHDECODE1,
-	SHLDREQID_FETCHDECODE2, SHLDREQID_FETCHDECODE3,
-};
-
-struct dpu_fetchdecode {
-	void __iomem *pec_base;
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-	fetchtype_t fetchtype;
-	shadow_load_req_t shdlreq;
-};
-
-static inline u32 dpu_pec_fd_read(struct dpu_fetchdecode *fd,
-				  unsigned int offset)
-{
-	return readl(fd->pec_base + offset);
-}
-
-static inline void dpu_pec_fd_write(struct dpu_fetchdecode *fd, u32 value,
-				    unsigned int offset)
-{
-	writel(value, fd->pec_base + offset);
-}
-
-static inline u32 dpu_fd_read(struct dpu_fetchdecode *fd, unsigned int offset)
-{
-	return readl(fd->base + offset);
-}
-
-static inline void dpu_fd_write(struct dpu_fetchdecode *fd, u32 value,
-				unsigned int offset)
-{
-	writel(value, fd->base + offset);
-}
-
-int fetchdecode_pixengcfg_dynamic_src_sel(struct dpu_fetchdecode *fd,
-					  fd_dynamic_src_sel_t src)
-{
-	int i;
-
-	mutex_lock(&fd->mutex);
-	for (i = 0; i < SRC_NUM; i++) {
-		if (fd_srcs[fd->id][i] == src) {
-			dpu_pec_fd_write(fd, src, PIXENGCFG_DYNAMIC);
-			mutex_unlock(&fd->mutex);
-			return 0;
-		}
-	}
-	mutex_unlock(&fd->mutex);
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(fetchdecode_pixengcfg_dynamic_src_sel);
-
-static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
-{
-	return (r << 24) | (g << 16) | (b << 8) | a;
-}
-
-static inline u32 yuv_color(u8 y, u8 u, u8 v)
-{
-	return (y << 24) | (u << 16) | (v << 8);
-}
-
-void fetchdecode_shden(struct dpu_fetchdecode *fd, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&fd->mutex);
-	val = dpu_fd_read(fd, STATICCONTROL);
-	if (enable)
-		val |= SHDEN;
-	else
-		val &= ~SHDEN;
-	dpu_fd_write(fd, val, STATICCONTROL);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_shden);
-
-void fetchdecode_baddr_autoupdate(struct dpu_fetchdecode *fd, u8 layer_mask)
-{
-	u32 val;
-
-	mutex_lock(&fd->mutex);
-	val = dpu_fd_read(fd, STATICCONTROL);
-	val &= ~BASEADDRESSAUTOUPDATE_MASK;
-	val |= BASEADDRESSAUTOUPDATE(layer_mask);
-	dpu_fd_write(fd, val, STATICCONTROL);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_baddr_autoupdate);
-
-void fetchdecode_baseaddress(struct dpu_fetchdecode *fd, dma_addr_t paddr)
-{
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, paddr, BASEADDRESS0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_baseaddress);
-
-void fetchdecode_source_bpp(struct dpu_fetchdecode *fd, int bpp)
-{
-	u32 val;
-
-	mutex_lock(&fd->mutex);
-	val = dpu_fd_read(fd, SOURCEBUFFERATTRIBUTES0);
-	val &= ~0x3f0000;
-	val |= BITSPERPIXEL(bpp);
-	dpu_fd_write(fd, val, SOURCEBUFFERATTRIBUTES0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_source_bpp);
-
-void fetchdecode_source_stride(struct dpu_fetchdecode *fd, int stride)
-{
-	u32 val;
-
-	mutex_lock(&fd->mutex);
-	val = dpu_fd_read(fd, SOURCEBUFFERATTRIBUTES0);
-	val &= ~0xffff;
-	val |= STRIDE(stride);
-	dpu_fd_write(fd, val, SOURCEBUFFERATTRIBUTES0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_source_stride);
-
-void fetchdecode_src_buf_dimensions(struct dpu_fetchdecode *fd, unsigned int w,
-				    unsigned int h)
-{
-	u32 val;
-
-	val = LINEWIDTH(w) | LINECOUNT(h);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, SOURCEBUFFERDIMENSION0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_src_buf_dimensions);
-
-void fetchdecode_set_fmt(struct dpu_fetchdecode *fd, u32 fmt)
-{
-	u32 bits, shift;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dpu_pixel_format_matrix); i++) {
-		if (dpu_pixel_format_matrix[i].pixel_format == fmt) {
-			bits = dpu_pixel_format_matrix[i].bits;
-			shift = dpu_pixel_format_matrix[i].shift;
-
-			mutex_lock(&fd->mutex);
-			dpu_fd_write(fd, bits, COLORCOMPONENTBITS0);
-			dpu_fd_write(fd, shift, COLORCOMPONENTSHIFT0);
-			mutex_unlock(&fd->mutex);
-			return;
-		}
-	}
-
-	WARN_ON(1);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_set_fmt);
-
-void fetchdecode_layeroffset(struct dpu_fetchdecode *fd, unsigned int x,
-			     unsigned int y)
-{
-	u32 val;
-
-	val = LAYERXOFFSET(x) | LAYERYOFFSET(y);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, LAYEROFFSET0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_layeroffset);
-
-void fetchdecode_clipoffset(struct dpu_fetchdecode *fd, unsigned int x,
-			    unsigned int y)
-{
-	u32 val;
-
-	val = CLIPWINDOWXOFFSET(x) | CLIPWINDOWYOFFSET(y);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, CLIPWINDOWOFFSET0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_clipoffset);
-
-void fetchdecode_layerproperty(struct dpu_fetchdecode *fd, bool enable)
-{
-	u32 val;
-
-	if (enable)
-		val = SOURCEBUFFERENABLE | CLIPWINDOWENABLE;
-	else
-		val = 0;
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, LAYERPROPERTY0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_layerproperty);
-
-void fetchdecode_clipdimensions(struct dpu_fetchdecode *fd, unsigned int w,
-				unsigned int h)
-{
-	u32 val;
-
-	val = CLIPWINDOWWIDTH(w) | CLIPWINDOWHEIGHT(h);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, CLIPWINDOWDIMENSIONS0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_clipdimensions);
-
-void fetchdecode_framedimensions(struct dpu_fetchdecode *fd, unsigned int w,
-				 unsigned int h)
-{
-	u32 val;
-
-	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, FRAMEDIMENSIONS);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_framedimensions);
-
-void fetchdecode_rgb_constantcolor(struct dpu_fetchdecode *fd,
-					u8 r, u8 g, u8 b, u8 a)
-{
-	u32 val;
-
-	val = rgb_color(r, g, b, a);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, CONSTANTCOLOR0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_rgb_constantcolor);
-
-void fetchdecode_yuv_constantcolor(struct dpu_fetchdecode *fd, u8 y, u8 u, u8 v)
-{
-	u32 val;
-
-	val = yuv_color(y, u, v);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, CONSTANTCOLOR0);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_yuv_constantcolor);
-
-void fetchdecode_controltrigger(struct dpu_fetchdecode *fd, bool trigger)
-{
-	u32 val;
-
-	val = trigger ? SHDTOKGEN : 0;
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, val, CONTROLTRIGGER);
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchdecode_controltrigger);
-
-int fetchdecode_fetchtype(struct dpu_fetchdecode *fd, fetchtype_t *type)
-{
-	struct dpu_soc *dpu = fd->dpu;
-	u32 val;
-
-	mutex_lock(&fd->mutex);
-	val = dpu_fd_read(fd, FETCHTYPE);
-	val &= FETCHTYPE_MASK;
-	mutex_unlock(&fd->mutex);
-
-	switch (val) {
-	case FETCHTYPE__DECODE:
-		dev_dbg(dpu->dev, "FetchDecode%d with RL and RLAD decoder\n",
-				fd->id);
-		break;
-	case FETCHTYPE__LAYER:
-		dev_dbg(dpu->dev, "FetchDecode%d with fractional "
-				"plane(8 layers)\n", fd->id);
-		break;
-	case FETCHTYPE__WARP:
-		dev_dbg(dpu->dev, "FetchDecode%d with arbitrary warping and "
-				"fractional plane(8 layers)\n", fd->id);
-		break;
-	case FETCHTYPE__ECO:
-		dev_dbg(dpu->dev, "FetchDecode%d with minimum feature set for "
-				"alpha, chroma and coordinate planes\n",
-				fd->id);
-		break;
-	case FETCHTYPE__PERSP:
-		dev_dbg(dpu->dev, "FetchDecode%d with affine, perspective and "
-				"arbitrary warping\n", fd->id);
-		break;
-	case FETCHTYPE__ROT:
-		dev_dbg(dpu->dev, "FetchDecode%d with affine and arbitrary "
-				"warping\n", fd->id);
-		break;
-	case FETCHTYPE__DECODEL:
-		dev_dbg(dpu->dev, "FetchDecode%d with RL and RLAD decoder, "
-				"reduced feature set\n", fd->id);
-		break;
-	case FETCHTYPE__LAYERL:
-		dev_dbg(dpu->dev, "FetchDecode%d with fractional "
-				"plane(8 layers), reduced feature set\n",
-				fd->id);
-		break;
-	case FETCHTYPE__ROTL:
-		dev_dbg(dpu->dev, "FetchDecode%d with affine and arbitrary "
-				"warping, reduced feature set\n", fd->id);
-		break;
-	default:
-		dev_warn(dpu->dev, "Invalid fetch type %u for FetchDecode%d\n",
-				val, fd->id);
-		return -EINVAL;
-	}
-
-	*type = val;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(fetchdecode_fetchtype);
-
-shadow_load_req_t fetchdecode_to_shdldreq_t(struct dpu_fetchdecode *fd)
-{
-	shadow_load_req_t t = 0;
-
-	switch (fd->id) {
-	case 0:
-		t = SHLDREQID_FETCHDECODE0;
-		break;
-	case 1:
-		t = SHLDREQID_FETCHDECODE1;
-		break;
-	case 2:
-		t = SHLDREQID_FETCHDECODE2;
-		break;
-	case 3:
-		t = SHLDREQID_FETCHDECODE3;
-		break;
-	default:
-		break;
-	}
-
-	return t;
-}
-EXPORT_SYMBOL_GPL(fetchdecode_to_shdldreq_t);
-
-struct dpu_fetchdecode *dpu_fd_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_fetchdecode *fd;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(fd_ids); i++)
-		if (fd_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(fd_ids))
-		return ERR_PTR(-EINVAL);
-
-	fd = dpu->fd_priv[i];
-
-	mutex_lock(&fd->mutex);
-
-	if (fd->inuse) {
-		fd = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	fd->inuse = true;
-out:
-	mutex_unlock(&fd->mutex);
-
-	return fd;
-}
-EXPORT_SYMBOL_GPL(dpu_fd_get);
-
-void dpu_fd_put(struct dpu_fetchdecode *fd)
-{
-	mutex_lock(&fd->mutex);
-
-	fd->inuse = false;
-
-	mutex_unlock(&fd->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_fd_put);
-
-int dpu_fd_init(struct dpu_soc *dpu, unsigned int id,
-		unsigned long pec_base, unsigned long base)
-{
-	struct dpu_fetchdecode *fd;
-	int ret, i;
-
-	fd = devm_kzalloc(dpu->dev, sizeof(*fd), GFP_KERNEL);
-	if (!fd)
-		return -ENOMEM;
-
-	dpu->fd_priv[id] = fd;
-
-	fd->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
-	if (!fd->pec_base)
-		return -ENOMEM;
-
-	fd->base = devm_ioremap(dpu->dev, base, SZ_1K);
-	if (!fd->base)
-		return -ENOMEM;
-
-	fd->dpu = dpu;
-	fd->id = id;
-	for (i = 0; i < ARRAY_SIZE(fd_ids); i++) {
-		if (fd_ids[i] == id) {
-			fd->shdlreq = fd_shdlreqs[i];
-			break;
-		}
-	}
-	mutex_init(&fd->mutex);
-
-	ret = fetchdecode_pixengcfg_dynamic_src_sel(fd, FD_SRC_DISABLE);
-	if (ret < 0)
-		return ret;
-
-	ret = fetchdecode_fetchtype(fd, &fd->fetchtype);
-	if (ret < 0)
-		return ret;
-
-	fetchdecode_baddr_autoupdate(fd, 0x0);
-	fetchdecode_shden(fd, true);
-
-	mutex_lock(&fd->mutex);
-	dpu_fd_write(fd, SETNUMBUFFERS(16) | SETBURSTLENGTH(16),
-			BURSTBUFFERMANAGEMENT);
-	mutex_unlock(&fd->mutex);
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-fetchlayer.c b/drivers/gpu/dpu/dpu-fetchlayer.c
deleted file mode 100644
index fdc8c14..0000000
--- a/drivers/gpu/dpu/dpu-fetchlayer.c
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define PIXENGCFG_STATUS		0x8
-#define BASEADDRESS(n)			(0x10 + (n) * 0x28)
-#define SOURCEBUFFERATTRIBUTES(n)	(0x14 + (n) * 0x28)
-#define SOURCEBUFFERDIMENSION(n)	(0x18 + (n) * 0x28)
-#define COLORCOMPONENTBITS(n)		(0x1C + (n) * 0x28)
-#define COLORCOMPONENTSHIFT(n)		(0x20 + (n) * 0x28)
-#define LAYEROFFSET(n)			(0x24 + (n) * 0x28)
-#define CLIPWINDOWOFFSET(n)		(0x28 + (n) * 0x28)
-#define CLIPWINDOWDIMENSIONS(n)		(0x2C + (n) * 0x28)
-#define CONSTANTCOLOR(n)		(0x30 + (n) * 0x28)
-#define LAYERPROPERTY(n)		(0x34 + (n) * 0x28)
-#define FRAMEDIMENSIONS			0x150
-#define FRAMERESAMPLING			0x154
-#define CONTROL				0x158
-#define TRIGGERENABLE			0x15C
-#define SHDLDREQ(lm)			((lm) & 0xFF)
-#define CONTROLTRIGGER			0x160
-#define START				0x164
-#define FETCHTYPE			0x168
-#define BURSTBUFFERPROPERTIES		0x16C
-#define STATUS				0x170
-#define HIDDENSTATUS			0x174
-
-static const shadow_load_req_t fl_shdlreqs[] = {
-	SHLDREQID_FETCHLAYER0, SHLDREQID_FETCHLAYER1,
-};
-
-struct dpu_fetchlayer {
-	void __iomem *pec_base;
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-	fetchtype_t fetchtype;
-	shadow_load_req_t shdlreq;
-};
-
-static inline u32 dpu_fl_read(struct dpu_fetchlayer *fl, unsigned int offset)
-{
-	return readl(fl->base + offset);
-}
-
-static inline void dpu_fl_write(struct dpu_fetchlayer *fl, u32 value,
-				unsigned int offset)
-{
-	writel(value, fl->base + offset);
-}
-
-static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
-{
-	return (r << 24) | (g << 16) | (b << 8) | a;
-}
-
-static inline u32 yuv_color(u8 y, u8 u, u8 v)
-{
-	return (y << 24) | (u << 16) | (v << 8);
-}
-
-void fetchlayer_shden(struct dpu_fetchlayer *fl, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&fl->mutex);
-	val = dpu_fl_read(fl, STATICCONTROL);
-	if (enable)
-		val |= SHDEN;
-	else
-		val &= ~SHDEN;
-	dpu_fl_write(fl, val, STATICCONTROL);
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchlayer_shden);
-
-void fetchlayer_baddr_autoupdate(struct dpu_fetchlayer *fl, u8 layer_mask)
-{
-	u32 val;
-
-	mutex_lock(&fl->mutex);
-	val = dpu_fl_read(fl, STATICCONTROL);
-	val &= ~BASEADDRESSAUTOUPDATE_MASK;
-	val |= BASEADDRESSAUTOUPDATE(layer_mask);
-	dpu_fl_write(fl, val, STATICCONTROL);
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchlayer_baddr_autoupdate);
-
-void fetchlayer_framedimensions(struct dpu_fetchlayer *fl, unsigned int w,
-				unsigned int h)
-{
-	u32 val;
-
-	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
-
-	mutex_lock(&fl->mutex);
-	dpu_fl_write(fl, val, FRAMEDIMENSIONS);
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchlayer_framedimensions);
-
-void fetchlayer_rgb_constantcolor(struct dpu_fetchlayer *fl,
-					u8 r, u8 g, u8 b, u8 a)
-{
-	u32 val;
-
-	val = rgb_color(r, g, b, a);
-
-	mutex_lock(&fl->mutex);
-	dpu_fl_write(fl, val, CONSTANTCOLOR(fl->id));
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchlayer_rgb_constantcolor);
-
-void fetchlayer_yuv_constantcolor(struct dpu_fetchlayer *fl, u8 y, u8 u, u8 v)
-{
-	u32 val;
-
-	val = yuv_color(y, u, v);
-
-	mutex_lock(&fl->mutex);
-	dpu_fl_write(fl, val, CONSTANTCOLOR(fl->id));
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchlayer_yuv_constantcolor);
-
-void fetchlayer_controltrigger(struct dpu_fetchlayer *fl, bool trigger)
-{
-	u32 val;
-
-	val = trigger ? SHDTOKGEN : 0;
-
-	mutex_lock(&fl->mutex);
-	dpu_fl_write(fl, val, CONTROLTRIGGER);
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(fetchlayer_controltrigger);
-
-int fetchlayer_fetchtype(struct dpu_fetchlayer *fl, fetchtype_t *type)
-{
-	struct dpu_soc *dpu = fl->dpu;
-	u32 val;
-
-	mutex_lock(&fl->mutex);
-	val = dpu_fl_read(fl, FETCHTYPE);
-	val &= FETCHTYPE_MASK;
-	mutex_unlock(&fl->mutex);
-
-	switch (val) {
-	case FETCHTYPE__DECODE:
-		dev_dbg(dpu->dev, "FetchLayer%d with RL and RLAD decoder\n",
-				fl->id);
-		break;
-	case FETCHTYPE__LAYER:
-		dev_dbg(dpu->dev, "FetchLayer%d with fractional "
-				"plane(8 layers)\n", fl->id);
-		break;
-	case FETCHTYPE__WARP:
-		dev_dbg(dpu->dev, "FetchLayer%d with arbitrary warping and "
-				"fractional plane(8 layers)\n", fl->id);
-		break;
-	case FETCHTYPE__ECO:
-		dev_dbg(dpu->dev, "FetchLayer%d with minimum feature set for "
-				"alpha, chroma and coordinate planes\n",
-				fl->id);
-		break;
-	case FETCHTYPE__PERSP:
-		dev_dbg(dpu->dev, "FetchLayer%d with affine, perspective and "
-				"arbitrary warping\n", fl->id);
-		break;
-	case FETCHTYPE__ROT:
-		dev_dbg(dpu->dev, "FetchLayer%d with affine and arbitrary "
-				"warping\n", fl->id);
-		break;
-	case FETCHTYPE__DECODEL:
-		dev_dbg(dpu->dev, "FetchLayer%d with RL and RLAD decoder, "
-				"reduced feature set\n", fl->id);
-		break;
-	case FETCHTYPE__LAYERL:
-		dev_dbg(dpu->dev, "FetchLayer%d with fractional "
-				"plane(8 layers), reduced feature set\n",
-				fl->id);
-		break;
-	case FETCHTYPE__ROTL:
-		dev_dbg(dpu->dev, "FetchLayer%d with affine and arbitrary "
-				"warping, reduced feature set\n", fl->id);
-		break;
-	default:
-		dev_warn(dpu->dev, "Invalid fetch type %u for FetchLayer%d\n",
-				val, fl->id);
-		return -EINVAL;
-	}
-
-	*type = val;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(fetchlayer_fetchtype);
-
-struct dpu_fetchlayer *dpu_fl_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_fetchlayer *fl;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(fl_ids); i++)
-		if (fl_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(fl_ids))
-		return ERR_PTR(-EINVAL);
-
-	fl = dpu->fl_priv[i];
-
-	mutex_lock(&fl->mutex);
-
-	if (fl->inuse) {
-		fl = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	fl->inuse = true;
-out:
-	mutex_unlock(&fl->mutex);
-
-	return fl;
-}
-EXPORT_SYMBOL_GPL(dpu_fl_get);
-
-void dpu_fl_put(struct dpu_fetchlayer *fl)
-{
-	mutex_lock(&fl->mutex);
-
-	fl->inuse = false;
-
-	mutex_unlock(&fl->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_fl_put);
-
-int dpu_fl_init(struct dpu_soc *dpu, unsigned int id,
-		unsigned long pec_base, unsigned long base)
-{
-	struct dpu_fetchlayer *fl;
-	int ret, i;
-
-	fl = devm_kzalloc(dpu->dev, sizeof(*fl), GFP_KERNEL);
-	if (!fl)
-		return -ENOMEM;
-
-	dpu->fl_priv[id] = fl;
-
-	fl->pec_base = devm_ioremap(dpu->dev, base, SZ_16);
-	if (!fl->pec_base)
-		return -ENOMEM;
-
-	fl->base = devm_ioremap(dpu->dev, base, SZ_512);
-	if (!fl->base)
-		return -ENOMEM;
-
-	fl->dpu = dpu;
-	fl->id = id;
-	for (i = 0; i < ARRAY_SIZE(fl_ids); i++) {
-		if (fl_ids[i] == id) {
-			fl->shdlreq = fl_shdlreqs[i];
-			break;
-		}
-	}
-	mutex_init(&fl->mutex);
-
-	ret = fetchlayer_fetchtype(fl, &fl->fetchtype);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-framegen.c b/drivers/gpu/dpu/dpu-framegen.c
deleted file mode 100644
index 93f000f..0000000
--- a/drivers/gpu/dpu/dpu-framegen.c
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define FGSTCTRL		0x8
-#define FGSYNCMODE_MASK		0x6
-typedef enum {
-	/* No side-by-side synchronization. */
-	FGSYNCMODE__OFF = 0,
-	/* Framegen is master. */
-	FGSYNCMODE__MASTER = 1 << 1,
-	/* Runs in cyclic synchronization mode. */
-	FGSYNCMODE__SLAVE_CYC = 2 << 1,
-	/* Runs in one time synchronization mode. */
-	FGSYNCMODE__SLAVE_ONCE = 3 << 1,
-} fgsyncmode_t;
-#define HTCFG1			0xC
-#define HTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
-#define HACT(n)			((n) & 0x3FFF)
-#define HTCFG2			0x10
-#define HSEN			BIT(31)
-#define HSBP(n)			((((n) - 1) & 0x3FFF) << 16)
-#define HSYNC(n)		(((n) - 1) & 0x3FFF)
-#define VTCFG1			0x14
-#define VTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
-#define VACT(n)			((n) & 0x3FFF)
-#define VTCFG2			0x18
-#define VSEN			BIT(31)
-#define VSBP(n)			((((n) - 1) & 0x3FFF) << 16)
-#define VSYNC(n)		(((n) - 1) & 0x3FFF)
-#define INTCONFIG(n)		(0x1C + 4 * (n))
-#define EN			BIT(31)
-#define ROW(n)			(((n) & 0x3FFF) << 16)
-#define COL(n)			((n) & 0x3FFF)
-#define PKICKCONFIG		0x2C
-#define SKICKCONFIG		0x30
-#define SECSTATCONFIG		0x34
-#define FGSRCR1			0x38
-#define FGSRCR2			0x3C
-#define FGSRCR3			0x40
-#define FGSRCR4			0x44
-#define FGSRCR5			0x48
-#define FGSRCR6			0x4C
-#define FGKSDR			0x50
-#define PACFG			0x54
-#define STARTX(n)		(((n) + 1) & 0x3FFF)
-#define STARTY(n)		(((((n) + 1) & 0x3FFF)) << 16)
-#define SACFG			0x58
-#define FGINCTRL		0x5C
-#define FGDM_MASK		0x7
-#define ENPRIMALPHA		BIT(3)
-#define ENSECALPHA		BIT(4)
-#define FGINCTRLPANIC		0x60
-#define FGCCR			0x64
-#define CCALPHA(a)		(((a) & 0x1) << 30)
-#define CCRED(r)		(((r) & 0x3FF) << 20)
-#define CCGREEN(g)		(((g) & 0x3FF) << 10)
-#define CCBLUE(b)		((b) & 0x3FF)
-#define FGENABLE		0x68
-#define FGEN			BIT(0)
-#define FGSLR			0x6C
-#define FGENSTS			0x70
-#define ENSTS			BIT(0)
-#define FGTIMESTAMP		0x74
-#define LINEINDEX_MASK		0x3FFF
-#define LINEINDEX_SHIFT		0
-#define FRAMEINDEX_MASK		0xFFFFC000
-#define FRAMEINDEX_SHIFT	14
-#define FGCHSTAT		0x78
-#define FGCHSTATCLR		0x7C
-#define FGSKEWMON		0x80
-#define FGSFIFOMIN		0x84
-#define FGSFIFOMAX		0x88
-#define FGSFIFOFILLCLR		0x8C
-#define FGSREPD			0x90
-#define FGSRFTD			0x94
-
-struct dpu_framegen {
-	void __iomem *base;
-	struct clk *clk_pll;
-	struct clk *clk_disp;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-};
-
-static inline u32 dpu_fg_read(struct dpu_framegen *fg, unsigned int offset)
-{
-	return readl(fg->base + offset);
-}
-
-static inline void dpu_fg_write(struct dpu_framegen *fg, u32 value,
-				unsigned int offset)
-{
-	writel(value, fg->base + offset);
-}
-
-void framegen_enable(struct dpu_framegen *fg)
-{
-	mutex_lock(&fg->mutex);
-	dpu_fg_write(fg, FGEN, FGENABLE);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_enable);
-
-void framegen_disable(struct dpu_framegen *fg)
-{
-	mutex_lock(&fg->mutex);
-	dpu_fg_write(fg, 0, FGENABLE);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_disable);
-
-void framegen_shdtokgen(struct dpu_framegen *fg)
-{
-	mutex_lock(&fg->mutex);
-	dpu_fg_write(fg, SHDTOKGEN, FGSLR);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_shdtokgen);
-
-void framegen_cfg_videomode(struct dpu_framegen *fg, struct drm_display_mode *m)
-{
-	const struct dpu_devtype *devtype = fg->dpu->devtype;
-	u32 hact, htotal, hsync, hsbp;
-	u32 vact, vtotal, vsync, vsbp;
-	u32 val;
-	unsigned long disp_clock_rate, pll_clock_rate = 0;
-
-	hact = m->crtc_hdisplay;
-	htotal = m->crtc_htotal;
-	hsync = m->crtc_hsync_end - m->crtc_hsync_start;
-	hsbp = m->crtc_htotal - m->crtc_hsync_start;
-
-	vact = m->crtc_vdisplay;
-	vtotal = m->crtc_vtotal;
-	vsync = m->crtc_vsync_end - m->crtc_vsync_start;
-	vsbp = m->crtc_vtotal - m->crtc_vsync_start;
-
-	mutex_lock(&fg->mutex);
-	/* video mode */
-	dpu_fg_write(fg, HACT(hact) | HTOTAL(htotal), HTCFG1);
-	dpu_fg_write(fg, HSYNC(hsync) | HSBP(hsbp) | HSEN, HTCFG2);
-	dpu_fg_write(fg, VACT(vact) | VTOTAL(vtotal), VTCFG1);
-	dpu_fg_write(fg, VSYNC(vsync) | VSBP(vsbp) | VSEN, VTCFG2);
-
-	/* skikconfig */
-	dpu_fg_write(fg, COL(hact - 40) | ROW(vact - 1) | EN, SKICKCONFIG);
-
-	/* primary position config */
-	dpu_fg_write(fg, STARTX(0) | STARTY(0), PACFG);
-
-	/* alpha */
-	val = dpu_fg_read(fg, FGINCTRL);
-	val &= ~(ENPRIMALPHA | ENSECALPHA);
-	dpu_fg_write(fg, val, FGINCTRL);
-
-	val = dpu_fg_read(fg, FGINCTRLPANIC);
-	val &= ~(ENPRIMALPHA | ENSECALPHA);
-	dpu_fg_write(fg, val, FGINCTRLPANIC);
-
-	/* constant color */
-	dpu_fg_write(fg, 0, FGCCR);
-	mutex_unlock(&fg->mutex);
-
-	disp_clock_rate = m->clock * 1000;
-
-	if (devtype->version == DPU_V1) {
-		/* FIXME: why the folders */
-		if (disp_clock_rate > 150000000)
-			pll_clock_rate = disp_clock_rate * 2;
-		else if (disp_clock_rate > 75000000)
-			pll_clock_rate = disp_clock_rate * 4;
-		else
-			pll_clock_rate = disp_clock_rate * 8;
-	} else if (devtype->version == DPU_V2) {
-		/* FIXME: why the hardcoded clock rate */
-		if (disp_clock_rate > 75000000)
-			pll_clock_rate = 1188000000;
-		else
-			pll_clock_rate = disp_clock_rate * 8;
-	}
-
-	clk_set_rate(fg->clk_pll, pll_clock_rate);
-	clk_set_rate(fg->clk_disp, disp_clock_rate);
-}
-EXPORT_SYMBOL_GPL(framegen_cfg_videomode);
-
-void framegen_pkickconfig(struct dpu_framegen *fg, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&fg->mutex);
-	val = dpu_fg_read(fg, PKICKCONFIG);
-	if (enable)
-		val |= EN;
-	else
-		val &= ~EN;
-	dpu_fg_write(fg, val, PKICKCONFIG);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_pkickconfig);
-
-void framegen_sacfg(struct dpu_framegen *fg, unsigned int x, unsigned int y)
-{
-	mutex_lock(&fg->mutex);
-	dpu_fg_write(fg, STARTX(x) | STARTY(y), SACFG);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_sacfg);
-
-void framegen_displaymode(struct dpu_framegen *fg, fgdm_t mode)
-{
-	u32 val;
-
-	mutex_lock(&fg->mutex);
-	val = dpu_fg_read(fg, FGINCTRL);
-	val &= ~FGDM_MASK;
-	val |= mode;
-	dpu_fg_write(fg, val, FGINCTRL);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_displaymode);
-
-void framegen_panic_displaymode(struct dpu_framegen *fg, fgdm_t mode)
-{
-	u32 val;
-
-	mutex_lock(&fg->mutex);
-	val = dpu_fg_read(fg, FGINCTRLPANIC);
-	val &= ~FGDM_MASK;
-	val |= mode;
-	dpu_fg_write(fg, val, FGINCTRLPANIC);
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(framegen_panic_displaymode);
-
-void framegen_wait_done(struct dpu_framegen *fg)
-{
-	unsigned long timeout = jiffies + msecs_to_jiffies(60);
-	u32 val;
-
-	mutex_lock(&fg->mutex);
-	do {
-		val = dpu_fg_read(fg, FGENSTS);
-	} while ((val & ENSTS) && time_before(jiffies, timeout));
-	mutex_unlock(&fg->mutex);
-
-	if (val & ENSTS)
-		dev_err(fg->dpu->dev, "failed to wait for FrameGen%d done\n",
-			fg->id);
-}
-EXPORT_SYMBOL_GPL(framegen_wait_done);
-
-void framegen_enable_clock(struct dpu_framegen *fg)
-{
-	clk_prepare_enable(fg->clk_pll);
-	clk_prepare_enable(fg->clk_disp);
-}
-EXPORT_SYMBOL_GPL(framegen_enable_clock);
-
-void framegen_disable_clock(struct dpu_framegen *fg)
-{
-	clk_disable_unprepare(fg->clk_pll);
-	clk_disable_unprepare(fg->clk_disp);
-}
-EXPORT_SYMBOL_GPL(framegen_disable_clock);
-
-struct dpu_framegen *dpu_fg_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_framegen *fg;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(fg_ids); i++)
-		if (fg_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(fg_ids))
-		return ERR_PTR(-EINVAL);
-
-	fg = dpu->fg_priv[i];
-
-	mutex_lock(&fg->mutex);
-
-	if (fg->inuse) {
-		fg = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	fg->inuse = true;
-out:
-	mutex_unlock(&fg->mutex);
-
-	return fg;
-}
-EXPORT_SYMBOL_GPL(dpu_fg_get);
-
-void dpu_fg_put(struct dpu_framegen *fg)
-{
-	mutex_lock(&fg->mutex);
-
-	fg->inuse = false;
-
-	mutex_unlock(&fg->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_fg_put);
-
-int dpu_fg_init(struct dpu_soc *dpu, unsigned int id,
-		unsigned long unused, unsigned long base)
-{
-	struct dpu_framegen *fg;
-	u32 val;
-
-	fg = devm_kzalloc(dpu->dev, sizeof(*fg), GFP_KERNEL);
-	if (!fg)
-		return -ENOMEM;
-
-	dpu->fg_priv[id] = fg;
-
-	fg->base = devm_ioremap(dpu->dev, base, SZ_256);
-	if (!fg->base)
-		return -ENOMEM;
-
-	fg->clk_pll = devm_clk_get(dpu->dev, id ? "pll1" : "pll0");
-	if (IS_ERR(fg->clk_pll))
-		return PTR_ERR(fg->clk_pll);
-
-	fg->clk_disp = devm_clk_get(dpu->dev, id ? "disp1" : "disp0");
-	if (IS_ERR(fg->clk_disp))
-		return PTR_ERR(fg->clk_disp);
-
-	fg->dpu = dpu;
-	fg->id = id;
-	mutex_init(&fg->mutex);
-
-	mutex_lock(&fg->mutex);
-	val = dpu_fg_read(fg, FGSTCTRL);
-	val &= ~FGSYNCMODE_MASK;
-	val |= FGSYNCMODE__OFF;
-	dpu_fg_write(fg, val, FGSTCTRL);
-
-	mutex_unlock(&fg->mutex);
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-layerblend.c b/drivers/gpu/dpu/dpu-layerblend.c
deleted file mode 100644
index ef90ee6..0000000
--- a/drivers/gpu/dpu/dpu-layerblend.c
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/io.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define PIXENGCFG_DYNAMIC			0x8
-#define PIXENGCFG_DYNAMIC_PRIM_SEL_MASK		0x3F
-#define PIXENGCFG_DYNAMIC_SEC_SEL_MASK		0x3F00
-#define PIXENGCFG_DYNAMIC_SEC_SEL_SHIFT		8
-
-static const lb_prim_sel_t prim_sels[] = {
-	LB_PRIM_SEL__DISABLE,
-	LB_PRIM_SEL__BLITBLEND9,
-	LB_PRIM_SEL__CONSTFRAME0,
-	LB_PRIM_SEL__CONSTFRAME1,
-	LB_PRIM_SEL__CONSTFRAME4,
-	LB_PRIM_SEL__CONSTFRAME5,
-	LB_PRIM_SEL__MATRIX4,
-	LB_PRIM_SEL__HSCALER4,
-	LB_PRIM_SEL__VSCALER4,
-	LB_PRIM_SEL__EXTSRC4,
-	LB_PRIM_SEL__MATRIX5,
-	LB_PRIM_SEL__HSCALER5,
-	LB_PRIM_SEL__VSCALER5,
-	LB_PRIM_SEL__EXTSRC5,
-	LB_PRIM_SEL__LAYERBLEND0,
-	LB_PRIM_SEL__LAYERBLEND1,
-	LB_PRIM_SEL__LAYERBLEND2,
-	LB_PRIM_SEL__LAYERBLEND3,
-	LB_PRIM_SEL__LAYERBLEND4,
-	LB_PRIM_SEL__LAYERBLEND5,
-};
-
-#define PIXENGCFG_STATUS			0xC
-#define SHDTOKSEL				(0x3 << 3)
-#define SHDTOKSEL_SHIFT				3
-#define SHDLDSEL				(0x3 << 1)
-#define CONTROL					0xC
-#define MODE_MASK				BIT(0)
-#define BLENDCONTROL				0x10
-#define ALPHA(a)				(((a) & 0xFF) << 16)
-#define PRIM_C_BLD_FUNC__ONE_MINUS_SEC_ALPHA	0x5
-#define SEC_C_BLD_FUNC__CONST_ALPHA		(0x6 << 4)
-#define PRIM_A_BLD_FUNC__ONE_MINUS_SEC_ALPHA	(0x5 << 8)
-#define SEC_A_BLD_FUNC__ONE			(0x1 << 12)
-#define POSITION				0x14
-#define XPOS(x)					((x) & 0x7FFF)
-#define YPOS(y)					(((y) & 0x7FFF) << 16)
-#define PRIMCONTROLWORD				0x18
-#define SECCONTROLWORD				0x1C
-
-#define CONTROLWORD				0x18
-#define CURPIXELCNT				0x1C
-static u16 get_xval(u32 pixel_cnt)
-{
-	return pixel_cnt && 0xFF;
-}
-
-static u16 get_yval(u32 pixel_cnt)
-{
-	return pixel_cnt >> 16;
-}
-#define LASTPIXELCNT				0x20
-#define PERFCOUNTER				0x24
-
-struct dpu_layerblend {
-	void __iomem *pec_base;
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-};
-
-static inline u32 dpu_pec_lb_read(struct dpu_layerblend *lb,
-				  unsigned int offset)
-{
-	return readl(lb->pec_base + offset);
-}
-
-static inline void dpu_pec_lb_write(struct dpu_layerblend *lb, u32 value,
-				    unsigned int offset)
-{
-	writel(value, lb->pec_base + offset);
-}
-
-static inline u32 dpu_lb_read(struct dpu_layerblend *lb, unsigned int offset)
-{
-	return readl(lb->base + offset);
-}
-
-static inline void dpu_lb_write(struct dpu_layerblend *lb, u32 value,
-				unsigned int offset)
-{
-	writel(value, lb->base + offset);
-}
-
-int layerblend_pixengcfg_dynamic_prim_sel(struct dpu_layerblend *lb,
-					  lb_prim_sel_t prim)
-{
-	struct dpu_soc *dpu = lb->dpu;
-	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
-	int fixed_sels_num = ARRAY_SIZE(prim_sels) - 6;
-	int i;
-	u32 val, mapped_prim;
-
-	mutex_lock(&lb->mutex);
-	for (i = 0; i < fixed_sels_num + lb->id; i++) {
-		if (prim_sels[i] == prim) {
-			mapped_prim = block_id_map ? block_id_map[prim] : prim;
-			if (WARN_ON(mapped_prim == NA))
-				return -EINVAL;
-
-			val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
-			val &= ~PIXENGCFG_DYNAMIC_PRIM_SEL_MASK;
-			val |= mapped_prim;
-			dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
-			mutex_unlock(&lb->mutex);
-			return 0;
-		}
-	}
-	mutex_unlock(&lb->mutex);
-
-	dev_err(dpu->dev, "Invalid primary source for LayerBlend%d\n", lb->id);
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(layerblend_pixengcfg_dynamic_prim_sel);
-
-void layerblend_pixengcfg_dynamic_sec_sel(struct dpu_layerblend *lb,
-					  lb_sec_sel_t sec)
-{
-	struct dpu_soc *dpu = lb->dpu;
-	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
-	u32 val, mapped_sec;
-
-	mapped_sec = block_id_map ? block_id_map[sec] : sec;
-	if (WARN_ON(mapped_sec == NA))
-		return;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
-	val &= ~PIXENGCFG_DYNAMIC_SEC_SEL_MASK;
-	val |= mapped_sec << PIXENGCFG_DYNAMIC_SEC_SEL_SHIFT;
-	dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_pixengcfg_dynamic_sec_sel);
-
-void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
-				lb_pixengcfg_clken_t clken)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
-	val &= ~CLKEN_MASK;
-	val |= clken << CLKEN_MASK_SHIFT;
-	dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_pixengcfg_clken);
-
-void layerblend_shden(struct dpu_layerblend *lb, bool enable)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, STATICCONTROL);
-	if (enable)
-		val |= SHDEN;
-	else
-		val &= ~SHDEN;
-	dpu_lb_write(lb, val, STATICCONTROL);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_shden);
-
-void layerblend_shdtoksel(struct dpu_layerblend *lb, lb_shadow_sel_t sel)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, STATICCONTROL);
-	val &= ~SHDTOKSEL;
-	val |= (sel << SHDTOKSEL_SHIFT);
-	dpu_lb_write(lb, val, STATICCONTROL);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_shdtoksel);
-
-void layerblend_shdldsel(struct dpu_layerblend *lb, lb_shadow_sel_t sel)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, STATICCONTROL);
-	val &= ~SHDLDSEL;
-	val |= sel;
-	dpu_lb_write(lb, val, STATICCONTROL);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_shdldsel);
-
-void layerblend_control(struct dpu_layerblend *lb, lb_mode_t mode)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, CONTROL);
-	val &= ~MODE_MASK;
-	val |= mode;
-	dpu_lb_write(lb, val, CONTROL);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_control);
-
-void layerblend_blendcontrol(struct dpu_layerblend *lb)
-{
-	u32 val;
-
-	val = ALPHA(0xff) |
-	      PRIM_C_BLD_FUNC__ONE_MINUS_SEC_ALPHA |
-	      SEC_C_BLD_FUNC__CONST_ALPHA |
-	      PRIM_A_BLD_FUNC__ONE_MINUS_SEC_ALPHA |
-	      SEC_A_BLD_FUNC__ONE;
-
-	mutex_lock(&lb->mutex);
-	dpu_lb_write(lb, val, BLENDCONTROL);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_blendcontrol);
-
-void layerblend_position(struct dpu_layerblend *lb, int x, int y)
-{
-	mutex_lock(&lb->mutex);
-	dpu_lb_write(lb, XPOS(x) | YPOS(y), POSITION);
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(layerblend_position);
-
-u32 layerblend_last_control_word(struct dpu_layerblend *lb)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, CONTROLWORD);
-	mutex_unlock(&lb->mutex);
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(layerblend_last_control_word);
-
-void layerblend_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, CURPIXELCNT);
-	mutex_unlock(&lb->mutex);
-
-	*x = get_xval(val);
-	*y = get_yval(val);
-}
-EXPORT_SYMBOL_GPL(layerblend_pixel_cnt);
-
-void layerblend_last_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, LASTPIXELCNT);
-	mutex_unlock(&lb->mutex);
-
-	*x = get_xval(val);
-	*y = get_yval(val);
-}
-EXPORT_SYMBOL_GPL(layerblend_last_pixel_cnt);
-
-u32 layerblend_perfresult(struct dpu_layerblend *lb)
-{
-	u32 val;
-
-	mutex_lock(&lb->mutex);
-	val = dpu_lb_read(lb, PERFCOUNTER);
-	mutex_unlock(&lb->mutex);
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(layerblend_perfresult);
-
-struct dpu_layerblend *dpu_lb_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_layerblend *lb;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(lb_ids); i++)
-		if (lb_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(lb_ids))
-		return ERR_PTR(-EINVAL);
-
-	lb = dpu->lb_priv[i];
-
-	mutex_lock(&lb->mutex);
-
-	if (lb->inuse) {
-		lb = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	lb->inuse = true;
-out:
-	mutex_unlock(&lb->mutex);
-
-	return lb;
-}
-EXPORT_SYMBOL_GPL(dpu_lb_get);
-
-void dpu_lb_put(struct dpu_layerblend *lb)
-{
-	mutex_lock(&lb->mutex);
-
-	lb->inuse = false;
-
-	mutex_unlock(&lb->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_lb_put);
-
-int dpu_lb_init(struct dpu_soc *dpu, unsigned int id,
-		unsigned long pec_base, unsigned long base)
-{
-	struct dpu_layerblend *lb;
-	int ret;
-
-	lb = devm_kzalloc(dpu->dev, sizeof(*lb), GFP_KERNEL);
-	if (!lb)
-		return -ENOMEM;
-
-	dpu->lb_priv[id] = lb;
-
-	lb->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
-	if (!lb->pec_base)
-		return -ENOMEM;
-
-	lb->base = devm_ioremap(dpu->dev, base, SZ_32);
-	if (!lb->base)
-		return -ENOMEM;
-
-	lb->dpu = dpu;
-	lb->id = id;
-	mutex_init(&lb->mutex);
-
-	ret = layerblend_pixengcfg_dynamic_prim_sel(lb, LB_PRIM_SEL__DISABLE);
-	if (ret < 0)
-		return ret;
-
-	layerblend_pixengcfg_dynamic_sec_sel(lb, LB_SEC_SEL__DISABLE);
-	layerblend_pixengcfg_clken(lb, CLKEN__AUTOMATIC);
-	layerblend_shdldsel(lb, BOTH);
-	layerblend_shdtoksel(lb, BOTH);
-	layerblend_shden(lb, true);
-
-	return 0;
-}
diff --git a/drivers/gpu/dpu/dpu-prv.h b/drivers/gpu/dpu/dpu-prv.h
deleted file mode 100644
index 957a010..0000000
--- a/drivers/gpu/dpu/dpu-prv.h
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#ifndef __DPU_PRV_H__
-#define __DPU_PRV_H__
-
-#include <drm/drm_fourcc.h>
-
-#define NA				0xDEADBEEF	/* not available */
-
-#define STATICCONTROL			0x8
-#define BASEADDRESSAUTOUPDATE(lm)	(((lm) & 0xFF) << 16)
-#define BASEADDRESSAUTOUPDATE_MASK	(0xFF << 16)
-#define SHDEN				BIT(0)
-#define BURSTBUFFERMANAGEMENT		0xC
-#define SETNUMBUFFERS(n)		((n) & 0xFF)
-#define SETBURSTLENGTH(n)		(((n) & 0x1F) << 8)
-#define LINEMODE_MASK			0x80000000U
-#define LINEMODE_SHIFT			31U
-enum linemode {
-	/*
-	 * Mandatory setting for operation in the Display Controller.
-	 * Works also for Blit Engine with marginal performance impact.
-	 */
-	LINEMODE__DISPLAY = 0,
-	/* Recommended setting for operation in the Blit Engine. */
-	LINEMODE__BLIT = 1 << LINEMODE_SHIFT,
-};
-
-#define BITSPERPIXEL(bpp)		(((bpp) & 0x3F) << 16)
-#define STRIDE(n)			(((n) - 1) & 0xFFFF)
-#define LINEWIDTH(w)			(((w) - 1) & 0x3FFF)
-#define LINECOUNT(h)			((((h) - 1) & 0x3FFF) << 16)
-#define ITUFORMAT			BIT(31)
-#define R_BITS(n)			(((n) & 0xF) << 24)
-#define G_BITS(n)			(((n) & 0xF) << 16)
-#define B_BITS(n)			(((n) & 0xF) << 8)
-#define A_BITS(n)			((n) & 0xF)
-#define R_SHIFT(n)			(((n) & 0x1F) << 24)
-#define G_SHIFT(n)			(((n) & 0x1F) << 16)
-#define B_SHIFT(n)			(((n) & 0x1F) << 8)
-#define A_SHIFT(n)			((n) & 0x1F)
-#define LAYERXOFFSET(x)			((x) & 0x7FFF)
-#define LAYERYOFFSET(y)			(((y) & 0x7FFF) << 16)
-#define CLIPWINDOWXOFFSET(x)		((x) & 0x7FFF)
-#define CLIPWINDOWYOFFSET(y)		(((y) & 0x7FFF) << 16)
-#define CLIPWINDOWWIDTH(w)		(((w) - 1) & 0x3FFF)
-#define CLIPWINDOWHEIGHT(h)		((((h) - 1) & 0x3FFF) << 16)
-#define	PALETTEENABLE			BIT(0)
-typedef enum {
-	TILE_FILL_ZERO,
-	TILE_FILL_CONSTANT,
-	TILE_PAD,
-	TILE_PAD_ZERO,
-} tilemode_t;
-#define ALPHASRCENABLE			BIT(8)
-#define ALPHACONSTENABLE		BIT(9)
-#define ALPHAMASKENABLE			BIT(10)
-#define ALPHATRANSENABLE		BIT(11)
-#define RGBALPHASRCENABLE		BIT(12)
-#define RGBALPHACONSTENABLE		BIT(13)
-#define RGBALPHAMASKENABLE		BIT(14)
-#define RGBALPHATRANSENABLE		BIT(15)
-#define PREMULCONSTRGB			BIT(16)
-typedef enum {
-	YUVCONVERSION__OFF,
-	YUVCONVERSION__ITU601,
-	YUVCONVERSION__ITU601_FR,
-	YUVCONVERSION__ITU709,
-} yuvconversion_t;
-#define GAMMAREMOVEENABLE		BIT(20)
-#define CLIPWINDOWENABLE		BIT(30)
-#define SOURCEBUFFERENABLE		BIT(31)
-#define EMPTYFRAME			BIT(31)
-#define FRAMEWIDTH(w)			(((w) - 1) & 0x3FFF)
-#define FRAMEHEIGHT(h)			((((h) - 1) & 0x3FFF) << 16)
-#define SHDTOKGEN			BIT(0)
-#define FETCHTYPE_MASK			0xF
-
-enum {
-	DPU_V1,
-	DPU_V2,
-};
-
-struct dpu_unit {
-	char *name;
-	unsigned int num;
-	const unsigned int *ids;
-	const unsigned long *pec_ofss;	/* PixEngCFG */
-	const unsigned long *ofss;
-};
-
-struct cm_reg_ofs {
-	u32 ipidentifier;
-	u32 lockunlock;
-	u32 lockstatus;
-	u32 userinterruptmask;
-	u32 interruptenable;
-	u32 interruptpreset;
-	u32 interruptclear;
-	u32 interruptstatus;
-	u32 userinterruptenable;
-	u32 userinterruptpreset;
-	u32 userinterruptclear;
-	u32 userinterruptstatus;
-	u32 generalpurpose;
-};
-
-struct dpu_devtype {
-	const unsigned long cm_ofs;	/* common */
-	const struct dpu_unit *cfs;
-	const struct dpu_unit *decs;
-	const struct dpu_unit *eds;
-	const struct dpu_unit *fds;
-	const struct dpu_unit *fgs;
-	const struct dpu_unit *fls;
-	const struct dpu_unit *lbs;
-	const struct dpu_unit *tcons;
-	const struct cm_reg_ofs *cm_reg_ofs;
-	const unsigned int *intsteer_map;
-	const unsigned int intsteer_map_size;
-	const unsigned long *unused_irq;
-	const unsigned int *sw2hw_irq_map;	/* NULL means linear */
-	const unsigned int *sw2hw_block_id_map;	/* NULL means linear */
-	bool has_capture;
-	bool pixel_link_quirks;
-	bool pixel_link_nhvsync;	/* HSYNC and VSYNC high active */
-	unsigned int version;
-};
-
-struct dpu_soc {
-	struct device		*dev;
-	const struct dpu_devtype	*devtype;
-	spinlock_t		lock;
-
-	void __iomem		*cm_reg;
-
-	int			id;
-	int			usecount;
-
-	struct regmap		*intsteer_regmap;
-	int			intsteer_usecount;
-	spinlock_t		intsteer_lock;
-	int			irq_cm;		/* irq common */
-	int			irq_stream0a;
-	int			irq_stream1a;
-	int			irq_reserved0;
-	int			irq_reserved1;
-	int			irq_blit;
-	struct irq_domain	*domain;
-
-	struct dpu_constframe	*cf_priv[4];
-	struct dpu_disengcfg	*dec_priv[2];
-	struct dpu_extdst	*ed_priv[4];
-	struct dpu_fetchdecode	*fd_priv[4];
-	struct dpu_fetchlayer	*fl_priv[2];
-	struct dpu_framegen	*fg_priv[2];
-	struct dpu_layerblend	*lb_priv[7];
-	struct dpu_tcon		*tcon_priv[2];
-};
-
-#define DECLARE_DPU_UNIT_INIT_FUNC(block)			\
-int dpu_##block##_init(struct dpu_soc *dpu, unsigned int id,	\
-			 unsigned long pec_base, unsigned long base)
-
-DECLARE_DPU_UNIT_INIT_FUNC(cf);
-DECLARE_DPU_UNIT_INIT_FUNC(dec);
-DECLARE_DPU_UNIT_INIT_FUNC(ed);
-DECLARE_DPU_UNIT_INIT_FUNC(fd);
-DECLARE_DPU_UNIT_INIT_FUNC(fg);
-DECLARE_DPU_UNIT_INIT_FUNC(fl);
-DECLARE_DPU_UNIT_INIT_FUNC(lb);
-DECLARE_DPU_UNIT_INIT_FUNC(tcon);
-
-static const unsigned int cf_ids[] = {0, 1, 4, 5};
-static const unsigned int dec_ids[] = {0, 1};
-static const unsigned int ed_ids[] = {0, 1, 4, 5};
-static const unsigned int fd_ids[] = {0, 1, 2, 3};
-static const unsigned int fg_ids[] = {0, 1};
-static const unsigned int fl_ids[] = {0, 1};
-static const unsigned int lb_ids[] = {0, 1, 2, 3, 4, 5, 6};
-static const unsigned int tcon_ids[] = {0, 1};
-
-struct dpu_pixel_format {
-	u32 pixel_format;
-	u32 bits;
-	u32 shift;
-};
-
-static const struct dpu_pixel_format dpu_pixel_format_matrix[] = {
-	{
-		DRM_FORMAT_XRGB8888,
-		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
-		R_SHIFT(16) | G_SHIFT(8)  | B_SHIFT(0)  | A_SHIFT(0),
-	}, {
-		DRM_FORMAT_XBGR8888,
-		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
-		R_SHIFT(0)  | G_SHIFT(8)  | B_SHIFT(16) | A_SHIFT(0),
-	}, {
-		DRM_FORMAT_RGBX8888,
-		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
-		R_SHIFT(24) | G_SHIFT(16) | B_SHIFT(8)  | A_SHIFT(0),
-	}, {
-		DRM_FORMAT_BGRX8888,
-		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
-		R_SHIFT(8)  | G_SHIFT(16) | B_SHIFT(24) | A_SHIFT(0),
-	}, {
-		DRM_FORMAT_RGB888,
-		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
-		R_SHIFT(16) | G_SHIFT(8)  | B_SHIFT(0)  | A_SHIFT(0),
-	}, {
-		DRM_FORMAT_BGR888,
-		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
-		R_SHIFT(0)  | G_SHIFT(8)  | B_SHIFT(16) | A_SHIFT(0),
-	}, {
-		DRM_FORMAT_RGB565,
-		R_BITS(5)   | G_BITS(6)   | B_BITS(5)   | A_BITS(0),
-		R_SHIFT(11) | G_SHIFT(5)  | B_SHIFT(0)  | A_SHIFT(0),
-	},
-};
-
-#endif				/* __DPU_PRV_H__ */
diff --git a/drivers/gpu/dpu/dpu-tcon.c b/drivers/gpu/dpu/dpu-tcon.c
deleted file mode 100644
index 8995e75..0000000
--- a/drivers/gpu/dpu/dpu-tcon.c
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/io.h>
-#include <linux/media-bus-format.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <video/dpu.h>
-#include "dpu-prv.h"
-
-#define SSQCNTS			0
-#define SSQCYCLE		0x8
-#define SWRESET			0xC
-#define TCON_CTRL		0x10
-#define BYPASS			BIT(3)
-#define RSDSINVCTRL		0x14
-#define MAPBIT3_0		0x18
-#define MAPBIT7_4		0x1C
-#define MAPBIT11_8		0x20
-#define MAPBIT15_12		0x24
-#define MAPBIT19_16		0x28
-#define MAPBIT23_20		0x2C
-#define MAPBIT27_24		0x30
-#define MAPBIT31_28		0x34
-#define MAPBIT34_32		0x38
-#define MAPBIT3_0_DUAL		0x3C
-#define MAPBIT7_4_DUAL		0x40
-#define MAPBIT11_8_DUAL		0x44
-#define MAPBIT15_12_DUAL	0x48
-#define MAPBIT19_16_DUAL	0x4C
-#define MAPBIT23_20_DUAL	0x50
-#define MAPBIT27_24_DUAL	0x54
-#define MAPBIT31_28_DUAL	0x58
-#define MAPBIT34_32_DUAL	0x5C
-#define SPGPOSON(n)		(0x60 + (n) * 16)
-#define X(n)			(((n) & 0x7FFF) << 16)
-#define Y(n)			((n) & 0x7FFF)
-#define SPGMASKON(n)		(0x64 + (n) * 16)
-#define SPGPOSOFF(n)		(0x68 + (n) * 16)
-#define SPGMASKOFF(n)		(0x6C + (n) * 16)
-#define SMXSIGS(n)		(0x120 + (n) * 8)
-#define SMXFCTTABLE(n)		(0x124 + (n) * 8)
-#define RESET_OVER_UNFERFLOW	0x180
-#define DUAL_DEBUG		0x184
-
-struct dpu_tcon {
-	void __iomem *base;
-	struct mutex mutex;
-	int id;
-	bool inuse;
-	struct dpu_soc *dpu;
-};
-
-static inline u32 dpu_tcon_read(struct dpu_tcon *tcon, unsigned int offset)
-{
-	return readl(tcon->base + offset);
-}
-
-static inline void dpu_tcon_write(struct dpu_tcon *tcon, u32 value,
-				  unsigned int offset)
-{
-	writel(value, tcon->base + offset);
-}
-
-int tcon_set_fmt(struct dpu_tcon *tcon, u32 bus_format)
-{
-	mutex_lock(&tcon->mutex);
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-		dpu_tcon_write(tcon, 0x19181716, MAPBIT3_0);
-		dpu_tcon_write(tcon, 0x1d1c1b1a, MAPBIT7_4);
-		dpu_tcon_write(tcon, 0x0f0e0d0c, MAPBIT11_8);
-		dpu_tcon_write(tcon, 0x13121110, MAPBIT15_12);
-		dpu_tcon_write(tcon, 0x05040302, MAPBIT19_16);
-		dpu_tcon_write(tcon, 0x09080706, MAPBIT23_20);
-		break;
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-	case MEDIA_BUS_FMT_RGB888_1X30_PADLO:
-	case MEDIA_BUS_FMT_RGB666_1X30_PADLO:
-		dpu_tcon_write(tcon, 0x17161514, MAPBIT3_0);
-		dpu_tcon_write(tcon, 0x1b1a1918, MAPBIT7_4);
-		dpu_tcon_write(tcon, 0x0b0a1d1c, MAPBIT11_8);
-		dpu_tcon_write(tcon, 0x0f0e0d0c, MAPBIT15_12);
-		dpu_tcon_write(tcon, 0x13121110, MAPBIT19_16);
-		dpu_tcon_write(tcon, 0x03020100, MAPBIT23_20);
-		dpu_tcon_write(tcon, 0x07060504, MAPBIT27_24);
-		dpu_tcon_write(tcon, 0x00000908, MAPBIT31_28);
-		break;
-	default:
-		mutex_unlock(&tcon->mutex);
-		return -EINVAL;
-	}
-	mutex_unlock(&tcon->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tcon_set_fmt);
-
-void tcon_cfg_videomode(struct dpu_tcon *tcon, struct drm_display_mode *m)
-{
-	u32 val;
-
-	mutex_lock(&tcon->mutex);
-	val = dpu_tcon_read(tcon, TCON_CTRL);
-	val &= ~BYPASS;
-	dpu_tcon_write(tcon, val, TCON_CTRL);
-
-	/* dsp_control[0]: hsync */
-	dpu_tcon_write(tcon, X(m->hsync_start), SPGPOSON(0));
-	dpu_tcon_write(tcon, 0xffff, SPGMASKON(0));
-
-	dpu_tcon_write(tcon, X(m->hsync_end), SPGPOSOFF(0));
-	dpu_tcon_write(tcon, 0xffff, SPGMASKOFF(0));
-
-	dpu_tcon_write(tcon, 0x2, SMXSIGS(0));
-	dpu_tcon_write(tcon, 0x1, SMXFCTTABLE(0));
-
-	/* dsp_control[1]: vsync */
-	dpu_tcon_write(tcon, X(m->hsync_end) | Y(m->vsync_start - 1),
-								SPGPOSON(1));
-	dpu_tcon_write(tcon, 0x0, SPGMASKON(1));
-
-	dpu_tcon_write(tcon, X(m->hsync_end) | Y(m->vsync_end - 1),
-								SPGPOSOFF(1));
-	dpu_tcon_write(tcon, 0x0, SPGMASKOFF(1));
-
-	dpu_tcon_write(tcon, 0x3, SMXSIGS(1));
-	dpu_tcon_write(tcon, 0x1, SMXFCTTABLE(1));
-
-	/* dsp_control[2]: data enable */
-	/* horizontal */
-	dpu_tcon_write(tcon, 0x0, SPGPOSON(2));
-	dpu_tcon_write(tcon, 0xffff, SPGMASKON(2));
-
-	dpu_tcon_write(tcon, X(m->hdisplay), SPGPOSOFF(2));
-	dpu_tcon_write(tcon, 0xffff, SPGMASKOFF(2));
-
-	/* vertical */
-	dpu_tcon_write(tcon, 0x0, SPGPOSON(3));
-	dpu_tcon_write(tcon, 0x7fff0000, SPGMASKON(3));
-
-	dpu_tcon_write(tcon, Y(m->vdisplay), SPGPOSOFF(3));
-	dpu_tcon_write(tcon, 0x7fff0000, SPGMASKOFF(3));
-
-	dpu_tcon_write(tcon, 0x2c, SMXSIGS(2));
-	dpu_tcon_write(tcon, 0x8, SMXFCTTABLE(2));
-
-	/* dsp_control[3]: kachuck */
-	dpu_tcon_write(tcon, X(0xa) | Y(m->vdisplay), SPGPOSON(4));
-	dpu_tcon_write(tcon, 0x0, SPGMASKON(4));
-
-	dpu_tcon_write(tcon, X(0x2a) | Y(m->vdisplay), SPGPOSOFF(4));
-	dpu_tcon_write(tcon, 0x0, SPGMASKOFF(4));
-
-	dpu_tcon_write(tcon, 0x6, SMXSIGS(3));
-	dpu_tcon_write(tcon, 0x2, SMXFCTTABLE(3));
-	mutex_unlock(&tcon->mutex);
-}
-EXPORT_SYMBOL_GPL(tcon_cfg_videomode);
-
-struct dpu_tcon *dpu_tcon_get(struct dpu_soc *dpu, int id)
-{
-	struct dpu_tcon *tcon;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(tcon_ids); i++)
-		if (tcon_ids[i] == id)
-			break;
-
-	if (i == ARRAY_SIZE(tcon_ids))
-		return ERR_PTR(-EINVAL);
-
-	tcon = dpu->tcon_priv[i];
-
-	mutex_lock(&tcon->mutex);
-
-	if (tcon->inuse) {
-		tcon = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	tcon->inuse = true;
-out:
-	mutex_unlock(&tcon->mutex);
-
-	return tcon;
-}
-EXPORT_SYMBOL_GPL(dpu_tcon_get);
-
-void dpu_tcon_put(struct dpu_tcon *tcon)
-{
-	mutex_lock(&tcon->mutex);
-
-	tcon->inuse = false;
-
-	mutex_unlock(&tcon->mutex);
-}
-EXPORT_SYMBOL_GPL(dpu_tcon_put);
-
-int dpu_tcon_init(struct dpu_soc *dpu, unsigned int id,
-			unsigned long unused, unsigned long base)
-{
-	struct dpu_tcon *tcon;
-
-	tcon = devm_kzalloc(dpu->dev, sizeof(*tcon), GFP_KERNEL);
-	if (!tcon)
-		return -ENOMEM;
-
-	dpu->tcon_priv[id] = tcon;
-
-	tcon->base = devm_ioremap(dpu->dev, base, SZ_512);
-	if (!tcon->base)
-		return -ENOMEM;
-
-	tcon->dpu = dpu;
-	mutex_init(&tcon->mutex);
-
-	return 0;
-}
diff --git a/drivers/gpu/imx/Kconfig b/drivers/gpu/imx/Kconfig
new file mode 100644
index 0000000..431e0b4
--- /dev/null
+++ b/drivers/gpu/imx/Kconfig
@@ -0,0 +1,2 @@
+source drivers/gpu/imx/ipu-v3/Kconfig
+source drivers/gpu/imx/dpu/Kconfig
diff --git a/drivers/gpu/imx/Makefile b/drivers/gpu/imx/Makefile
new file mode 100644
index 0000000..3ac4d4b
--- /dev/null
+++ b/drivers/gpu/imx/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_IMX_IPUV3_CORE)	+= ipu-v3/
+obj-$(CONFIG_IMX_DPU_CORE)	+= dpu/
diff --git a/drivers/gpu/imx/dpu/Kconfig b/drivers/gpu/imx/dpu/Kconfig
new file mode 100644
index 0000000..1a1f5a9
--- /dev/null
+++ b/drivers/gpu/imx/dpu/Kconfig
@@ -0,0 +1,9 @@
+config IMX_DPU_CORE
+	tristate "i.MX DPU core support"
+	depends on ARCH_FSL_IMX8QM || ARCH_FSL_IMX8QXP
+	depends on RESET_CONTROLLER
+	select GENERIC_IRQ_CHIP
+	help
+	  Choose this if you have a Freescale i.MX8QM or i.MX8QXP system and
+	  want to use the Display Processing Unit. This option only enables
+	  DPU base support.
diff --git a/drivers/gpu/imx/dpu/Makefile b/drivers/gpu/imx/dpu/Makefile
new file mode 100644
index 0000000..df07880
--- /dev/null
+++ b/drivers/gpu/imx/dpu/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_IMX_DPU_CORE) += imx-dpu-core.o
+
+imx-dpu-core-objs := dpu-common.o dpu-constframe.o dpu-disengcfg.o \
+		     dpu-extdst.o dpu-fetchdecode.o dpu-framegen.o \
+		     dpu-fetchlayer.o dpu-layerblend.o dpu-tcon.o
diff --git a/drivers/gpu/imx/dpu/dpu-common.c b/drivers/gpu/imx/dpu/dpu-common.c
new file mode 100644
index 0000000..0f47ff9
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-common.c
@@ -0,0 +1,1293 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <soc/imx8/sc/sci.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define DPU_CM_REG_DEFINE1(name1, name2)		\
+static inline u32 name1(const struct cm_reg_ofs *ofs)	\
+{							\
+	return ofs->name2;				\
+}
+
+#define DPU_CM_REG_DEFINE2(name1, name2)		\
+static inline u32 name1(const struct cm_reg_ofs *ofs,	\
+			unsigned int n)			\
+{							\
+	return ofs->name2 + (4 * n);			\
+}
+
+DPU_CM_REG_DEFINE1(IPIDENTIFIER, ipidentifier);
+
+#define DESIGNDELIVERYID_MASK		0xF0U
+#define DESIGNDELIVERYID_SHIFT		4U
+
+#define DESIGNMATURITYLEVEL_MASK	0xF00U
+#define DESIGNMATURITYLEVEL_SHIFT	8U
+enum design_maturity_level {
+	/* Pre feasibility study. */
+	DESIGNMATURITYLEVEL__PREFS	= 1 << DESIGNMATURITYLEVEL_SHIFT,
+	/* Feasibility study. */
+	DESIGNMATURITYLEVEL__FS		= 2 << DESIGNMATURITYLEVEL_SHIFT,
+	/* Functionality complete. */
+	DESIGNMATURITYLEVEL__R0		= 3 << DESIGNMATURITYLEVEL_SHIFT,
+	/* Verification complete. */
+	DESIGNMATURITYLEVEL__R1		= 4 << DESIGNMATURITYLEVEL_SHIFT,
+};
+
+#define IPEVOLUTION_MASK		0xF000U
+#define IPEVOLUTION_SHIFT		12U
+
+#define IPFEATURESET_MASK		0xF0000U
+#define IPFEATURESET_SHIFT		16U
+enum ip_feature_set {
+	/* Minimal functionality (Eco). */
+	IPFEATURESET__E = 1 << IPFEATURESET_SHIFT,
+	/* Reduced functionality (Light). */
+	IPFEATURESET__L = 2 << IPFEATURESET_SHIFT,
+	/* Advanced functionality (Plus). */
+	IPFEATURESET__P = 4 << IPFEATURESET_SHIFT,
+	/* Extensive functionality (eXtensive). */
+	IPFEATURESET__X = 5 << IPFEATURESET_SHIFT,
+};
+
+#define IPAPPLICATION_MASK		0xF00000U
+#define IPAPPLICATION_SHIFT		20U
+enum ip_application {
+	/* Blit Engine only. */
+	IPAPPLICATION__B = 1 << IPAPPLICATION_SHIFT,
+	/* Blit Engine and Display Controller. */
+	IPAPPLICATION__D = 2 << IPAPPLICATION_SHIFT,
+	/* Display Controller only (with direct capture). */
+	IPAPPLICATION__V = 3 << IPAPPLICATION_SHIFT,
+	/*
+	 * Blit Engine, Display Controller (with direct capture),
+	 * Capture Controller (buffered capture) and Drawing Engine.
+	 */
+	IPAPPLICATION__G = 4 << IPAPPLICATION_SHIFT,
+	/* Display Controller only. */
+	IPAPPLICATION__C = 5 << IPAPPLICATION_SHIFT,
+};
+
+#define IPCONFIGURATION_MASK		0xF000000U
+#define IPCONFIGURATION_SHIFT		24U
+enum ip_configuration {
+	/* Graphics core only (Module). */
+	IPCONFIGURATION__M = 1 << IPCONFIGURATION_SHIFT,
+	/* Subsystem including a graphics core (System). */
+	IPCONFIGURATION__S = 2 << IPCONFIGURATION_SHIFT,
+};
+
+#define IPFAMILY_MASK			0xF0000000U
+#define IPFAMILY_SHIFT			28U
+enum ip_family {
+	/* IMXDPU building block generation 2010. */
+	IPFAMILY__IMXDPU2010 = 0,
+	/* IMXDPU building block generation 2012. */
+	IPFAMILY__IMXDPU2012 = 1 << IPFAMILY_SHIFT,
+	/* IMXDPU building block generation 2013. */
+	IPFAMILY__IMXDPU2013 = 2 << IPFAMILY_SHIFT,
+};
+
+DPU_CM_REG_DEFINE1(LOCKUNLOCK, lockunlock);
+DPU_CM_REG_DEFINE1(LOCKSTATUS, lockstatus);
+DPU_CM_REG_DEFINE2(USERINTERRUPTMASK, userinterruptmask);
+DPU_CM_REG_DEFINE2(INTERRUPTENABLE, interruptenable);
+DPU_CM_REG_DEFINE2(INTERRUPTPRESET, interruptpreset);
+DPU_CM_REG_DEFINE2(INTERRUPTCLEAR, interruptclear);
+DPU_CM_REG_DEFINE2(INTERRUPTSTATUS, interruptstatus);
+DPU_CM_REG_DEFINE2(USERINTERRUPTENABLE, userinterruptenable);
+DPU_CM_REG_DEFINE2(USERINTERRUPTPRESET, userinterruptpreset);
+DPU_CM_REG_DEFINE2(USERINTERRUPTCLEAR, userinterruptclear);
+DPU_CM_REG_DEFINE2(USERINTERRUPTSTATUS, userinterruptstatus);
+DPU_CM_REG_DEFINE1(GENERALPURPOSE, generalpurpose);
+
+static inline u32 dpu_cm_read(struct dpu_soc *dpu, unsigned int offset)
+{
+	return readl(dpu->cm_reg + offset);
+}
+
+static inline void dpu_cm_write(struct dpu_soc *dpu, u32 value,
+				unsigned int offset)
+{
+	writel(value, dpu->cm_reg + offset);
+}
+
+/* Constant Frame Unit */
+static const unsigned long cf_ofss[] = {0x4400, 0x5400, 0x4c00, 0x5c00};
+static const unsigned long cf_pec_ofss_v1[] = {0x980, 0xa00, 0x9c0, 0xa40};
+static const unsigned long cf_pec_ofss_v2[] = {0x960, 0x9e0, 0x9a0, 0xa20};
+
+/* Display Engine Configuration Unit */
+static const unsigned long dec_ofss_v1[] = {0x10000, 0x10020};
+static const unsigned long dec_ofss_v2[] = {0xb400, 0xb420};
+
+/* External Destination Unit */
+static const unsigned long ed_ofss[] = {0x4800, 0x5800, 0x5000, 0x6000};
+static const unsigned long ed_pec_ofss_v1[] = {0x9a0, 0xa20, 0x9e0, 0xa60};
+static const unsigned long ed_pec_ofss_v2[] = {0x980, 0xa00, 0x9c0, 0xa40};
+
+/* Fetch Decode Unit */
+static const unsigned long fd_ofss_v1[] = {0x8c00, 0x9800, 0x7400, 0x7c00};
+static const unsigned long fd_ofss_v2[] = {0x6c00, 0x7800};
+static const unsigned long fd_pec_ofss_v1[] = {0xb60, 0xb80, 0xb00, 0xb20};
+static const unsigned long fd_pec_ofss_v2[] = {0xa80, 0xaa0};
+
+/* Frame Generator Unit */
+static const unsigned long fg_ofss_v1[] = {0x10c00, 0x12800};
+static const unsigned long fg_ofss_v2[] = {0xb800, 0xd400};
+
+/* Fetch Layer Unit */
+static const unsigned long fl_ofss_v1[] = {0xa400, 0xac00};
+static const unsigned long fl_ofss_v2[] = {0x8400};
+static const unsigned long fl_pec_ofss_v1[] = {0xba0, 0xbb0};
+static const unsigned long fl_pec_ofss_v2[] = {0xac0};
+
+/* Layer Blend Unit */
+static const unsigned long lb_ofss_v1[] = {0xdc00, 0xe000, 0xe400, 0xe800,
+					   0xec00, 0xf000, 0xf400};
+static const unsigned long lb_ofss_v2[] = {0xa400, 0xa800, 0xac00, 0xb000};
+static const unsigned long lb_pec_ofss_v1[] = {0xd00, 0xd20, 0xd40, 0xd60,
+					       0xd80, 0xda0, 0xdc0};
+static const unsigned long lb_pec_ofss_v2[] = {0xba0, 0xbc0, 0xbe0, 0xc00};
+
+/* Timing Controller Unit */
+static const unsigned long tcon_ofss_v1[] = {0x12000, 0x13c00};
+static const unsigned long tcon_ofss_v2[] = {0xcc00, 0xe800};
+
+static const struct dpu_unit cfs_v1 = {
+	.name = "ConstFrame",
+	.num = ARRAY_SIZE(cf_ids),
+	.ids = cf_ids,
+	.pec_ofss = cf_pec_ofss_v1,
+	.ofss = cf_ofss,
+};
+
+static const struct dpu_unit cfs_v2 = {
+	.name = "ConstFrame",
+	.num = ARRAY_SIZE(cf_ids),
+	.ids = cf_ids,
+	.pec_ofss = cf_pec_ofss_v2,
+	.ofss = cf_ofss,
+};
+
+static const struct dpu_unit decs_v1 = {
+	.name = "DisEngCfg",
+	.num = ARRAY_SIZE(dec_ids),
+	.ids = dec_ids,
+	.pec_ofss = NULL,
+	.ofss = dec_ofss_v1,
+};
+
+static const struct dpu_unit decs_v2 = {
+	.name = "DisEngCfg",
+	.num = ARRAY_SIZE(dec_ids),
+	.ids = dec_ids,
+	.pec_ofss = NULL,
+	.ofss = dec_ofss_v2,
+};
+
+static const struct dpu_unit eds_v1 = {
+	.name = "ExtDst",
+	.num = ARRAY_SIZE(ed_ids),
+	.ids = ed_ids,
+	.pec_ofss = ed_pec_ofss_v1,
+	.ofss = ed_ofss,
+};
+
+static const struct dpu_unit eds_v2 = {
+	.name = "ExtDst",
+	.num = ARRAY_SIZE(ed_ids),
+	.ids = ed_ids,
+	.pec_ofss = ed_pec_ofss_v2,
+	.ofss = ed_ofss,
+};
+
+static const struct dpu_unit fds_v1 = {
+	.name = "FetchDecode",
+	.num = ARRAY_SIZE(fd_ids),
+	.ids = fd_ids,
+	.pec_ofss = fd_pec_ofss_v1,
+	.ofss = fd_ofss_v1,
+};
+
+static const struct dpu_unit fds_v2 = {
+	.name = "FetchDecode",
+	.num = 2,
+	.ids = fd_ids,
+	.pec_ofss = fd_pec_ofss_v2,
+	.ofss = fd_ofss_v2,
+};
+
+static const struct dpu_unit fgs_v1 = {
+	.name = "FrameGen",
+	.num = ARRAY_SIZE(fg_ids),
+	.ids = fg_ids,
+	.pec_ofss = NULL,
+	.ofss = fg_ofss_v1,
+};
+
+static const struct dpu_unit fgs_v2 = {
+	.name = "FrameGen",
+	.num = ARRAY_SIZE(fg_ids),
+	.ids = fg_ids,
+	.pec_ofss = NULL,
+	.ofss = fg_ofss_v2,
+};
+
+static const struct dpu_unit fls_v1 = {
+	.name = "FetchLayer",
+	.num = ARRAY_SIZE(fl_ids),
+	.ids = fl_ids,
+	.pec_ofss = fl_pec_ofss_v1,
+	.ofss = fl_ofss_v1,
+};
+
+static const struct dpu_unit fls_v2 = {
+	.name = "FetchLayer",
+	.num = 1,
+	.ids = fl_ids,
+	.pec_ofss = fl_pec_ofss_v2,
+	.ofss = fl_ofss_v2,
+};
+
+static const struct dpu_unit lbs_v1 = {
+	.name = "LayerBlend",
+	.num = ARRAY_SIZE(lb_ids),
+	.ids = lb_ids,
+	.pec_ofss = lb_pec_ofss_v1,
+	.ofss = lb_ofss_v1,
+};
+
+static const struct dpu_unit lbs_v2 = {
+	.name = "LayerBlend",
+	.num = 4,
+	.ids = lb_ids,
+	.pec_ofss = lb_pec_ofss_v2,
+	.ofss = lb_ofss_v2,
+};
+
+static const struct dpu_unit tcons_v1 = {
+	.name = "TCon",
+	.num = ARRAY_SIZE(tcon_ids),
+	.ids = tcon_ids,
+	.pec_ofss = NULL,
+	.ofss = tcon_ofss_v1,
+};
+
+static const struct dpu_unit tcons_v2 = {
+	.name = "TCon",
+	.num = ARRAY_SIZE(tcon_ids),
+	.ids = tcon_ids,
+	.pec_ofss = NULL,
+	.ofss = tcon_ofss_v2,
+};
+
+static const struct cm_reg_ofs cm_reg_ofs_v1 = {
+	.ipidentifier = 0,
+	.lockunlock = 0x80,
+	.lockstatus = 0x84,
+	.userinterruptmask = 0x88,
+	.interruptenable = 0x94,
+	.interruptpreset = 0xa0,
+	.interruptclear = 0xac,
+	.interruptstatus = 0xb8,
+	.userinterruptenable = 0x100,
+	.userinterruptpreset = 0x10c,
+	.userinterruptclear = 0x118,
+	.userinterruptstatus = 0x124,
+	.generalpurpose = 0x200,
+};
+
+static const struct cm_reg_ofs cm_reg_ofs_v2 = {
+	.ipidentifier = 0,
+	.lockunlock = 0x40,
+	.lockstatus = 0x44,
+	.userinterruptmask = 0x48,
+	.interruptenable = 0x50,
+	.interruptpreset = 0x58,
+	.interruptclear = 0x60,
+	.interruptstatus = 0x68,
+	.userinterruptenable = 0x80,
+	.userinterruptpreset = 0x88,
+	.userinterruptclear = 0x90,
+	.userinterruptstatus = 0x98,
+	.generalpurpose = 0x100,
+};
+
+static const unsigned int intsteer_map_v1[] = {
+	/*  0    1    2    3    4    5    6    7 */	/*  0~31: int0 */
+	  448, 449, 450,  64,  65,  66,  67,  68,
+	/*  8    9   10   11   12   13   14   15 */
+	   69,  70, 193, 194, 195, 196, 197, 320,
+	/* 16   17   18   19   20   21   22   23 */
+	  321, 322, 384, 385, 386,  NA, 323,  NA,
+	/* 24   25   26   27   28   29   30   31 */
+	  387,  71, 198,  72,  73,  74,  75,  76,
+	/* 32   33   34   35   36   37   38   39 */	/* 32~63: int1 */
+	   77,  78,  79,  80,  81, 199, 200, 201,
+	/* 40   41   42   43   44   45   46   47 */
+	  202, 203, 204, 205, 206, 207, 208, 324,
+	/* 48   49   50   51   52   53   54   55 */
+	  389,  NA,   0,   1,   2,   3,   4,  82,
+	/* 56   57   58   59   60   61   62   63 */
+	   83,  84,  85, 209, 210, 211, 212, 325,
+	/* 64   65   66 */				/*   64+: int2 */
+	  326, 390, 391,
+};
+static const unsigned long unused_irq_v1[] = {0x00a00000, 0x00020000,
+					      0xfffffff8};
+
+static const unsigned int intsteer_map_v2[] = {
+	/*  0    1    2    3    4    5    6    7 */	/*  0~31: int0 */
+	  448, 449, 450,  64,  65,  66,  67,  68,
+	/*  8    9   10   11   12   13   14   15 */
+	   69,  70, 193, 194, 195, 196, 197,  72,
+	/* 16   17   18   19   20   21   22   23 */
+	   73,  74,  75,  76,  77,  78,  79,  80,
+	/* 24   25   26   27   28   29   30   31 */
+	   81, 199, 200, 201, 202, 203, 204, 205,
+	/* 32   33   34   35   36   37   38   39 */	/*   32+: int1 */
+	  206, 207, 208,  NA,   0,   1,   2,   3,
+	/* 40   41   42   43   44   45   46   47 */
+	    4,  82,  83,  84,  85, 209, 210, 211,
+	/* 48 */
+	  212,
+};
+static const unsigned long unused_irq_v2[] = {0x00000000, 0xfffe0008};
+
+static const unsigned int sw2hw_irq_map_v2[] = {
+	/*  0    1    2    3    4    5    6    7 */
+	    0,   1,   2,   3,   4,   5,   6,   7,
+	/*  8    9   10   11   12   13   14   15 */
+	    8,   9,  10,  11,  12,  13,  14,  NA,
+	/* 16   17   18   19   20   21   22   23 */
+	   NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,
+	/* 24   25   26   27   28   29   30   31 */
+	   NA,  NA,  NA,  15,  16,  17,  18,  19,
+	/* 32   33   34   35   36   37   38   39 */
+	   20,  21,  22,  23,  24,  25,  26,  27,
+	/* 40   41   42   43   44   45   46   47 */
+	   28,  29,  30,  31,  32,  33,  34,  NA,
+	/* 48   49   50   51   52   53   54   55 */
+	   NA,  NA,  36,  37,  38,  39,  40,  41,
+	/* 56   57   58   59   60   61   62   63 */
+	   42,  43,  44,  45,  46,  47,  48,  NA,
+	/* 64   65   66 */
+	   NA,  NA,  NA,
+};
+
+/* FIXME: overkill for some N/As, revive them when needed */
+static const unsigned int sw2hw_block_id_map_v2[] = {
+	/*   0     1     2     3     4     5     6     7 */
+	  0x00,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
+	/*   8     9    10    11    12    13    14    15 */
+	    NA,   NA, 0x0a,   NA, 0x0c,   NA, 0x0e,   NA,
+	/*  16    17    18    19    20    21    22    23 */
+	  0x10,   NA, 0x12,   NA,   NA,   NA,   NA,   NA,
+	/*  24    25    26    27    28    29    30    31 */
+	    NA,   NA, 0x14,   NA, 0x16,   NA, 0x18,   NA,
+	/*  32    33    34    35    36    37    38    39 */
+	  0x1a,   NA,   NA, 0x1b, 0x1c, 0x1d,   NA,   NA,
+	/*  40    41    42    43    44    45    46    47 */
+	  0x1e, 0x1f, 0x20,   NA, 0x21, 0x22, 0x23, 0x24,
+	/*  48    49    50    51    52    53    54    55 */
+	    NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
+	/*  56    57    58    59    60    61    62    63 */
+	    NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
+	/*  64    65    66    67 */
+	    NA,   NA,   NA,   NA,
+};
+
+static const struct dpu_devtype dpu_type_v1 = {
+	.cm_ofs = 0x0,
+	.cfs = &cfs_v1,
+	.decs = &decs_v1,
+	.eds = &eds_v1,
+	.fds = &fds_v1,
+	.fgs = &fgs_v1,
+	.fls = &fls_v1,
+	.lbs = &lbs_v1,
+	.tcons = &tcons_v1,
+	.cm_reg_ofs = &cm_reg_ofs_v1,
+	.intsteer_map = intsteer_map_v1,
+	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v1),
+	.unused_irq = unused_irq_v1,
+	.has_capture = true,
+	.pixel_link_quirks = false,
+	.pixel_link_nhvsync = false,
+	.version = DPU_V1,
+};
+
+static const struct dpu_devtype dpu_type_v2 = {
+	.cm_ofs = 0x0,
+	.cfs = &cfs_v2,
+	.decs = &decs_v2,
+	.eds = &eds_v2,
+	.fds = &fds_v2,
+	.fgs = &fgs_v2,
+	.fls = &fls_v2,
+	.lbs = &lbs_v2,
+	.tcons = &tcons_v2,
+	.cm_reg_ofs = &cm_reg_ofs_v2,
+	.intsteer_map = intsteer_map_v2,
+	.intsteer_map_size = ARRAY_SIZE(intsteer_map_v2),
+	.unused_irq = unused_irq_v2,
+	.sw2hw_irq_map = sw2hw_irq_map_v2,
+	.sw2hw_block_id_map = sw2hw_block_id_map_v2,
+	.has_capture = false,
+	.pixel_link_quirks = true,
+	.pixel_link_nhvsync = true,
+	.version = DPU_V2,
+};
+
+static const struct of_device_id dpu_dt_ids[] = {
+	{ .compatible = "fsl,imx8qm-dpu", .data = &dpu_type_v2, },
+	{ .compatible = "fsl,imx8qxp-dpu", .data = &dpu_type_v2, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, dpu_dt_ids);
+
+#define DPU_UNIT_INIT(dpu, base, unit, name, id, pec_ofs, ofs)		\
+{									\
+	int ret;							\
+	ret = dpu_##unit##_init((dpu),	(id),				\
+				(pec_ofs) ? (base) + (pec_ofs) : 0,	\
+				(base) + (ofs));			\
+	if (ret) {							\
+		dev_err((dpu)->dev, "init %s%d failed with %d\n",	\
+						(name), (id), ret);	\
+		return ret;						\
+	}								\
+}
+
+#define DPU_UNITS_INIT(unit)						\
+{									\
+	const struct dpu_unit *us = devtype->unit##s;			\
+	int i;								\
+									\
+	/* software check */						\
+	if (WARN_ON(us->num > ARRAY_SIZE(unit##_ids)))			\
+		return -EINVAL;						\
+									\
+	for (i = 0; i < us->num; i++)					\
+		DPU_UNIT_INIT(dpu, dpu_base, unit, us->name,		\
+			      us->ids[i],				\
+			      us->pec_ofss ? us->pec_ofss[i] : 0,	\
+			      us->ofss[i]);				\
+}
+
+static int dpu_submodules_init(struct dpu_soc *dpu,
+		struct platform_device *pdev, unsigned long dpu_base)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+
+	DPU_UNITS_INIT(cf);
+	DPU_UNITS_INIT(dec);
+	DPU_UNITS_INIT(ed);
+	DPU_UNITS_INIT(fd);
+	DPU_UNITS_INIT(fg);
+	DPU_UNITS_INIT(fl);
+	DPU_UNITS_INIT(lb);
+	DPU_UNITS_INIT(tcon);
+
+	return 0;
+}
+
+#define DPU_UNITS_ADDR_DBG(unit)					\
+{									\
+	const struct dpu_unit *us = devtype->unit##s;			\
+	int i;								\
+	for (i = 0; i < us->num; i++) {					\
+		if (us->pec_ofss) {					\
+			dev_dbg(&pdev->dev, "%s%d: pixengcfg @ 0x%08lx,"\
+				" unit @ 0x%08lx\n", us->name,		\
+				us->ids[i],				\
+				dpu_base + us->pec_ofss[i],		\
+				dpu_base + us->ofss[i]);		\
+		} else {						\
+			dev_dbg(&pdev->dev,				\
+				"%s%d: unit @ 0x%08lx\n", us->name,	\
+				us->ids[i], dpu_base + us->ofss[i]);	\
+		}							\
+	}								\
+}
+
+enum dpu_irq_line {
+	DPU_IRQ_LINE_CM = 0,
+	DPU_IRQ_LINE_STREAM0A = 1,
+	DPU_IRQ_LINE_STREAM1A = 3,
+	DPU_IRQ_LINE_RESERVED0 = 5,
+	DPU_IRQ_LINE_RESERVED1 = 6,
+	DPU_IRQ_LINE_BLIT = 7,
+};
+
+static inline unsigned int dpu_get_max_intsteer_num(enum dpu_irq_line irq_line)
+{
+	return 64 * (++irq_line) - 1;
+}
+
+static inline unsigned int dpu_get_min_intsteer_num(enum dpu_irq_line irq_line)
+{
+	return 64 * irq_line;
+}
+
+static void dpu_irq_handle(struct irq_desc *desc, enum dpu_irq_line irq_line)
+{
+	struct dpu_soc *dpu = irq_desc_get_handler_data(desc);
+	const struct dpu_devtype *devtype = dpu->devtype;
+	const struct cm_reg_ofs *ofs = devtype->cm_reg_ofs;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned int i, virq, min_intsteer_num, max_intsteer_num;
+	u32 status;
+
+	chained_irq_enter(chip, desc);
+
+	min_intsteer_num = dpu_get_min_intsteer_num(irq_line);
+	max_intsteer_num = dpu_get_max_intsteer_num(irq_line);
+
+	for (i = 0; i < devtype->intsteer_map_size; i++) {
+		if (devtype->intsteer_map[i] >= min_intsteer_num &&
+		    devtype->intsteer_map[i] <= max_intsteer_num) {
+			status = dpu_cm_read(dpu,
+					USERINTERRUPTSTATUS(ofs, i / 32));
+			status &= dpu_cm_read(dpu,
+					USERINTERRUPTENABLE(ofs, i / 32));
+
+			if (status & BIT(i % 32)) {
+				virq = irq_linear_revmap(dpu->domain, i);
+				if (virq) {
+					generic_handle_irq(virq);
+				}
+			}
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+#define DPU_IRQ_HANDLER_DEFINE(name1, name2)			\
+static void dpu_##name1##_irq_handler(struct irq_desc *desc)	\
+{								\
+	dpu_irq_handle(desc, DPU_IRQ_LINE_##name2);		\
+}
+
+DPU_IRQ_HANDLER_DEFINE(cm, CM)
+DPU_IRQ_HANDLER_DEFINE(stream0a, STREAM0A)
+DPU_IRQ_HANDLER_DEFINE(stream1a, STREAM1A)
+DPU_IRQ_HANDLER_DEFINE(reserved0, RESERVED0)
+DPU_IRQ_HANDLER_DEFINE(reserved1, RESERVED1)
+DPU_IRQ_HANDLER_DEFINE(blit, BLIT)
+
+int dpu_map_irq(struct dpu_soc *dpu, int irq)
+{
+	const unsigned int *sw2hw_irq_map = dpu->devtype->sw2hw_irq_map;
+	int virq, mapped_irq;
+
+	mapped_irq = sw2hw_irq_map ? sw2hw_irq_map[irq] : irq;
+	if (WARN_ON(mapped_irq == NA))
+		return -EINVAL;
+
+	virq = irq_linear_revmap(dpu->domain, mapped_irq);
+	if (!virq)
+		virq = irq_create_mapping(dpu->domain, mapped_irq);
+
+	return virq;
+}
+EXPORT_SYMBOL_GPL(dpu_map_irq);
+
+static int platform_remove_devices_fn(struct device *dev, void *unused)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
+static void platform_device_unregister_children(struct platform_device *pdev)
+{
+	device_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);
+}
+
+struct dpu_platform_reg {
+	struct dpu_client_platformdata pdata;
+	const char *name;
+};
+
+static struct dpu_platform_reg client_reg[] = {
+	{
+		/* placeholder */
+		.pdata = { },
+		.name = "imx-dpu-csi",
+	}, {
+		/* placeholder */
+		.pdata = { },
+		.name = "imx-dpu-csi",
+	}, {
+		.pdata = {
+			.stream_id = 0,
+		},
+		.name = "imx-dpu-crtc",
+	}, {
+		.pdata = {
+			.stream_id = 1,
+		},
+		.name = "imx-dpu-crtc",
+	},
+};
+
+static DEFINE_MUTEX(dpu_client_id_mutex);
+static int dpu_client_id;
+
+static int dpu_get_plane_resource(struct dpu_soc *dpu,
+				  struct dpu_plane_res *res)
+{
+	const struct dpu_unit *fds = dpu->devtype->fds;
+	const struct dpu_unit *lbs = dpu->devtype->lbs;
+	struct dpu_plane_grp *grp = plane_res_to_grp(res);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(res->cf); i++) {
+		res->cf[i] = dpu_cf_get(dpu, i);
+		if (IS_ERR(res->cf[i]))
+			return PTR_ERR(res->cf[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->ed); i++) {
+		res->ed[i] = dpu_ed_get(dpu, i);
+		if (IS_ERR(res->ed[i]))
+			return PTR_ERR(res->ed[i]);
+	}
+	for (i = 0; i < fds->num; i++) {
+		res->fd[i] = dpu_fd_get(dpu, i);
+		if (IS_ERR(res->fd[i]))
+			return PTR_ERR(res->fd[i]);
+	}
+	for (i = 0; i < lbs->num; i++) {
+		res->lb[i] = dpu_lb_get(dpu, i);
+		if (IS_ERR(res->lb[i]))
+			return PTR_ERR(res->lb[i]);
+	}
+
+	grp->hw_plane_num = fds->num;
+
+	return 0;
+}
+
+static void dpu_put_plane_resource(struct dpu_plane_res *res)
+{
+	struct dpu_plane_grp *grp = plane_res_to_grp(res);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(res->cf); i++) {
+		if (!IS_ERR_OR_NULL(res->cf[i]))
+			dpu_cf_put(res->cf[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->ed); i++) {
+		if (!IS_ERR_OR_NULL(res->ed[i]))
+			dpu_ed_put(res->ed[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->fd); i++) {
+		if (!IS_ERR_OR_NULL(res->fd[i]))
+			dpu_fd_put(res->fd[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(res->lb); i++) {
+		if (!IS_ERR_OR_NULL(res->lb[i]))
+			dpu_lb_put(res->lb[i]);
+	}
+
+	grp->hw_plane_num = 0;
+}
+
+static int dpu_add_client_devices(struct dpu_soc *dpu)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+	struct device *dev = dpu->dev;
+	struct dpu_platform_reg *reg;
+	struct dpu_plane_grp *plane_grp;
+	size_t client_num, reg_size;
+	int i, id, ret;
+
+	client_num = ARRAY_SIZE(client_reg);
+	if (!devtype->has_capture)
+		client_num -= 2;
+
+	reg = devm_kcalloc(dev, client_num, sizeof(*reg), GFP_KERNEL);
+	if (!reg)
+		return -ENODEV;
+
+	plane_grp = devm_kzalloc(dev, sizeof(*plane_grp), GFP_KERNEL);
+	if (!plane_grp)
+		return -ENODEV;
+
+	mutex_lock(&dpu_client_id_mutex);
+	id = dpu_client_id;
+	dpu_client_id += client_num;
+	mutex_unlock(&dpu_client_id_mutex);
+
+	reg_size = client_num * sizeof(struct dpu_platform_reg);
+	if (devtype->has_capture)
+		memcpy(reg, client_reg, reg_size);
+	else
+		memcpy(reg, &client_reg[2], reg_size);
+
+	INIT_LIST_HEAD(&plane_grp->list);
+	mutex_init(&plane_grp->lock);
+	plane_grp->id = id / client_num;
+
+	ret = dpu_get_plane_resource(dpu, &plane_grp->res);
+	if (ret)
+		goto err_get_plane_res;
+
+	for (i = 0; i < client_num; i++) {
+		struct platform_device *pdev;
+		struct device_node *of_node;
+		bool is_disp;
+
+		if (devtype->has_capture)
+			is_disp = (i / 2) ? true : false;
+		else
+			is_disp = true;
+
+		/* Associate subdevice with the corresponding port node */
+		of_node = of_graph_get_port_by_id(dev->of_node, i);
+		if (!of_node) {
+			dev_info(dev, "no port@%d node in %s, not using %s%d\n",
+				 i, dev->of_node->full_name,
+				 is_disp ? "DISP" : "CSI", i % 2);
+			continue;
+		}
+
+		if (is_disp)
+			reg[i].pdata.plane_grp = plane_grp;
+
+		pdev = platform_device_alloc(reg[i].name, id++);
+		if (!pdev) {
+			ret = -ENOMEM;
+			goto err_register;
+		}
+
+		pdev->dev.parent = dev;
+
+		reg[i].pdata.of_node = of_node;
+		ret = platform_device_add_data(pdev, &reg[i].pdata,
+					       sizeof(reg[i].pdata));
+		if (!ret)
+			ret = platform_device_add(pdev);
+		if (ret) {
+			platform_device_put(pdev);
+			goto err_register;
+		}
+	}
+
+	return 0;
+
+err_register:
+	platform_device_unregister_children(to_platform_device(dev));
+err_get_plane_res:
+	dpu_put_plane_resource(&plane_grp->res);
+
+	return ret;
+}
+
+#define IRQSTEER_CHANnCTL	0x0
+#define IRQSTEER_CHANnCTL_CH(n)	BIT(n)
+#define IRQSTEER_CHANnMASK(n)	((n) + 4)
+#define LINE_TO_MASK_OFFSET(n)	((15 - ((n) / 32)) * 4)
+#define LINE_TO_MASK_SHIFT(n)	((n) % 32)
+
+static void dpu_irq_gc_mask_set_bit(struct irq_data *d)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	struct dpu_soc *dpu = gc->domain->host_data;
+	unsigned long flags;
+	u32 mask = d->mask;
+
+	irq_gc_lock(gc);
+	spin_lock_irqsave(&dpu->intsteer_lock, flags);
+	if (++dpu->intsteer_usecount == 1)
+		/* assuming fast I/O regmap */
+		regmap_write(dpu->intsteer_regmap, IRQSTEER_CHANnCTL,
+				IRQSTEER_CHANnCTL_CH(0));
+	spin_unlock_irqrestore(&dpu->intsteer_lock, flags);
+	*ct->mask_cache |= mask;
+	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
+	irq_gc_unlock(gc);
+}
+
+static void dpu_irq_gc_mask_clr_bit(struct irq_data *d)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	struct dpu_soc *dpu = gc->domain->host_data;
+	unsigned long flags;
+	u32 mask = d->mask;
+
+	irq_gc_lock(gc);
+	spin_lock_irqsave(&dpu->intsteer_lock, flags);
+	if (!--dpu->intsteer_usecount) {
+		WARN(dpu->intsteer_usecount < 0,
+			"intsteer usecount %d is less than zero",
+			dpu->intsteer_usecount);
+		regmap_write(dpu->intsteer_regmap, IRQSTEER_CHANnCTL, 0);
+	}
+	spin_unlock_irqrestore(&dpu->intsteer_lock, flags);
+	*ct->mask_cache &= ~mask;
+	irq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);
+	irq_gc_unlock(gc);
+}
+
+static void dpu_intsteer_enable_line(struct dpu_soc *dpu, unsigned int line)
+{
+	unsigned int offset = LINE_TO_MASK_OFFSET(line);
+	unsigned int shift = LINE_TO_MASK_SHIFT(line);
+
+	regmap_update_bits(dpu->intsteer_regmap, IRQSTEER_CHANnMASK(offset),
+			   BIT(shift), BIT(shift));
+}
+
+static int dpu_irq_init(struct dpu_soc *dpu)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+	const struct cm_reg_ofs *ofs = devtype->cm_reg_ofs;
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+	int ret, i;
+
+	for (i = 0; i < devtype->intsteer_map_size; i++) {
+		if (devtype->intsteer_map[i] == NA)
+			continue;
+
+		dpu_intsteer_enable_line(dpu, devtype->intsteer_map[i]);
+	}
+
+	dpu->domain = irq_domain_add_linear(dpu->dev->of_node,
+					    devtype->intsteer_map_size,
+					    &irq_generic_chip_ops, dpu);
+	if (!dpu->domain) {
+		dev_err(dpu->dev, "failed to add irq domain\n");
+		return -ENODEV;
+	}
+
+	ret = irq_alloc_domain_generic_chips(dpu->domain, 32, 1, "DPU",
+					     handle_level_irq, 0, 0, 0);
+	if (ret < 0) {
+		dev_err(dpu->dev, "failed to alloc generic irq chips\n");
+		irq_domain_remove(dpu->domain);
+		return ret;
+	}
+
+	for (i = 0; i < devtype->intsteer_map_size; i += 32) {
+		/* Mask and clear all interrupts */
+		dpu_cm_write(dpu, 0,
+					USERINTERRUPTENABLE(ofs, i / 32));
+		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
+					USERINTERRUPTCLEAR(ofs, i / 32));
+		dpu_cm_write(dpu, 0,
+					INTERRUPTENABLE(ofs, i / 32));
+		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
+					INTERRUPTCLEAR(ofs, i / 32));
+
+		/* Set all interrupts to user mode */
+		dpu_cm_write(dpu, ~devtype->unused_irq[i / 32],
+					USERINTERRUPTMASK(ofs, i / 32));
+
+		gc = irq_get_domain_generic_chip(dpu->domain, i);
+		gc->reg_base = dpu->cm_reg;
+		gc->unused = devtype->unused_irq[i / 32];
+		ct = gc->chip_types;
+		ct->chip.irq_ack = irq_gc_ack_set_bit;
+		ct->chip.irq_mask = dpu_irq_gc_mask_clr_bit;
+		ct->chip.irq_unmask = dpu_irq_gc_mask_set_bit;
+		ct->regs.ack = USERINTERRUPTCLEAR(ofs, i / 32);
+		ct->regs.mask = USERINTERRUPTENABLE(ofs, i / 32);
+	}
+
+#define DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(name)	\
+irq_set_chained_handler_and_data(dpu->irq_##name, dpu_##name##_irq_handler, dpu)
+
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(cm);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(stream0a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(stream1a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(reserved0);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(reserved1);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA1(blit);
+
+	return 0;
+}
+
+static void dpu_irq_exit(struct dpu_soc *dpu)
+{
+	const struct dpu_devtype *devtype = dpu->devtype;
+	unsigned int i, irq;
+
+#define DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(name)	\
+irq_set_chained_handler_and_data(dpu->irq_##name, NULL, NULL)
+
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(cm);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(stream0a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(stream1a);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(reserved0);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(reserved1);
+	DPU_IRQ_SET_CHAINED_HANDLER_AND_DATA2(blit);
+
+	for (i = 0; i < devtype->intsteer_map_size; i++) {
+		irq = irq_linear_revmap(dpu->domain, i);
+		if (irq)
+			irq_dispose_mapping(irq);
+	}
+
+	irq_domain_remove(dpu->domain);
+}
+
+static void dpu_debug_ip_identity(struct dpu_soc *dpu)
+{
+	struct device *dev = dpu->dev;
+	const struct cm_reg_ofs *ofs = dpu->devtype->cm_reg_ofs;
+	u32 reg;
+	int id = 0;
+
+	reg = dpu_cm_read(dpu, IPIDENTIFIER(ofs));
+
+	dev_dbg(dev, "%d) Maturatiy level:\n", ++id);
+	switch (reg & DESIGNMATURITYLEVEL_MASK) {
+	case DESIGNMATURITYLEVEL__PREFS:
+		dev_dbg(dev, "\tPre feasibility study.\n");
+		break;
+	case DESIGNMATURITYLEVEL__FS:
+		dev_dbg(dev, "\tFeasibility study.\n");
+		break;
+	case DESIGNMATURITYLEVEL__R0:
+		dev_dbg(dev, "\tFunctionality complete.\n");
+		break;
+	case DESIGNMATURITYLEVEL__R1:
+		dev_dbg(dev, "\tVerification complete.\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP feature set:\n", ++id);
+	switch (reg & IPFEATURESET_MASK) {
+	case IPFEATURESET__E:
+		dev_dbg(dev, "\tMinimal functionality (Eco).\n");
+		break;
+	case IPFEATURESET__L:
+		dev_dbg(dev, "\tReduced functionality (Light).\n");
+		break;
+	case IPFEATURESET__P:
+		dev_dbg(dev, "\tAdvanced functionality (Plus).\n");
+		break;
+	case IPFEATURESET__X:
+		dev_dbg(dev, "\tExtensive functionality (eXtensive).\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP application:\n", ++id);
+	switch (reg & IPAPPLICATION_MASK) {
+	case IPAPPLICATION__B:
+		dev_dbg(dev, "\tBlit engine only.\n");
+		break;
+	case IPAPPLICATION__D:
+		dev_dbg(dev, "\tBlit engine and display controller.\n");
+		break;
+	case IPAPPLICATION__V:
+		dev_dbg(dev, "\tDisplay controller only "
+					"(with direct capture).\n");
+		break;
+	case IPAPPLICATION__G:
+		dev_dbg(dev, "\tBlit engine, display controller "
+					"(with direct capture),\n"
+				   "\tcapture controller (buffered capture) "
+				   "and drawing engine.\n");
+		break;
+	case IPAPPLICATION__C:
+		dev_dbg(dev, "\tDisplay controller only.\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP configuration:\n", ++id);
+	switch (reg & IPCONFIGURATION_MASK) {
+	case IPCONFIGURATION__M:
+		dev_dbg(dev, "\tGraphics core only (Module).\n");
+		break;
+	case IPCONFIGURATION__S:
+		dev_dbg(dev, "\tSubsystem including a graphics core "
+							"(System).\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+
+	dev_dbg(dev, "%d) IP family:\n", ++id);
+	switch (reg & IPFAMILY_MASK) {
+	case IPFAMILY__IMXDPU2010:
+		dev_dbg(dev, "\tBuilding block generation 2010.\n");
+		break;
+	case IPFAMILY__IMXDPU2012:
+		dev_dbg(dev, "\tBuilding block generation 2012.\n");
+		break;
+	case IPFAMILY__IMXDPU2013:
+		dev_dbg(dev, "\tBuilding block generation 2013.\n");
+		break;
+	default:
+		dev_dbg(dev, "\tUnknown.\n");
+		break;
+	}
+}
+
+/* FIXME: set pixel link in a proper manner */
+static int dpu_pixel_link_config(int id)
+{
+	sc_err_t sciErr;
+	sc_ipc_t ipcHndl = 0;
+	u32 mu_id;
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("Cannot obtain MU ID\n");
+		return sciErr;
+	}
+
+	sciErr = sc_ipc_open(&ipcHndl, mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
+		return sciErr;
+	}
+
+	if (id == 0) {
+		/* Enable All Display Pixel Links */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST1_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST1_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_PXL_LINK_MST2_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_PXL_LINK_MST2_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL0 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_SYNC_CTRL0, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_SYNC_CTRL0 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL1 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_0, SC_C_SYNC_CTRL1, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_0:SC_C_SYNC_CTRL1 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+	} else if (id == 1) {
+		/* Enable All Display Pixel Links */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST1_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST1_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_ADDR, 0);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_ADDR sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_ENB, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_ENB sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_PXL_LINK_MST2_VLD, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_PXL_LINK_MST2_VLD sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL0 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_SYNC_CTRL0, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_SYNC_CTRL0 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+
+		/* todo: move SC_C_SYNC_CTRL1 to after first valid frame */
+		sciErr = sc_misc_set_control(ipcHndl, SC_R_DC_1, SC_C_SYNC_CTRL1, 1);
+		if (sciErr != SC_ERR_NONE)
+			pr_err("SC_R_DC_1:SC_C_SYNC_CTRL1 sc_misc_set_control failed! (sciError = %d)\n", sciErr);
+	}
+
+	sc_ipc_close(mu_id);
+	return sciErr;
+}
+
+static int dpu_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(dpu_dt_ids, &pdev->dev);
+	struct device_node *np = pdev->dev.of_node;
+	struct dpu_soc *dpu;
+	struct resource *res;
+	unsigned long dpu_base;
+	const struct dpu_devtype *devtype;
+	int ret;
+
+	devtype = of_id->data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	dpu_base = res->start;
+
+	dpu = devm_kzalloc(&pdev->dev, sizeof(*dpu), GFP_KERNEL);
+	if (!dpu)
+		return -ENODEV;
+
+	dpu->dev = &pdev->dev;
+	dpu->devtype = devtype;
+	dpu->id = of_alias_get_id(np, "dpu");
+
+	dpu->irq_cm = platform_get_irq(pdev, 0);
+	dpu->irq_stream0a = platform_get_irq(pdev, 1);
+	dpu->irq_stream1a = platform_get_irq(pdev, 3);
+	dpu->irq_reserved0 = platform_get_irq(pdev, 5);
+	dpu->irq_reserved1 = platform_get_irq(pdev, 6);
+	dpu->irq_blit = platform_get_irq(pdev, 7);
+
+	dev_dbg(dpu->dev, "irq_cm: %d\n", dpu->irq_cm);
+	dev_dbg(dpu->dev, "irq_stream0a: %d, irq_stream1a: %d\n",
+			dpu->irq_stream0a, dpu->irq_stream1a);
+	dev_dbg(dpu->dev, "irq_reserved0: %d, irq_reserved1: %d\n",
+			dpu->irq_reserved0, dpu->irq_reserved1);
+	dev_dbg(dpu->dev, "irq_blit: %d\n", dpu->irq_blit);
+
+	if (dpu->irq_cm < 0 ||
+	    dpu->irq_stream0a < 0 || dpu->irq_stream1a < 0 ||
+	    dpu->irq_reserved0 < 0 || dpu->irq_reserved1 < 0 ||
+	    dpu->irq_blit < 0)
+		return -ENODEV;
+
+	dpu->intsteer_regmap = syscon_regmap_lookup_by_phandle(np, "intsteer");
+	if (IS_ERR(dpu->intsteer_regmap)) {
+		dev_err(dpu->dev, "failed to get intsteer regmap\n");
+		return PTR_ERR(dpu->intsteer_regmap);
+	}
+
+	spin_lock_init(&dpu->lock);
+	spin_lock_init(&dpu->intsteer_lock);
+
+	dev_dbg(dpu->dev, "Common: 0x%08lx\n", dpu_base + devtype->cm_ofs);
+	DPU_UNITS_ADDR_DBG(cf);
+	DPU_UNITS_ADDR_DBG(dec);
+	DPU_UNITS_ADDR_DBG(ed);
+	DPU_UNITS_ADDR_DBG(fd);
+	DPU_UNITS_ADDR_DBG(fg);
+	DPU_UNITS_ADDR_DBG(fl);
+	DPU_UNITS_ADDR_DBG(lb);
+	DPU_UNITS_ADDR_DBG(tcon);
+
+	dpu->cm_reg = devm_ioremap(dpu->dev, dpu_base + devtype->cm_ofs, SZ_1K);
+	if (!dpu->cm_reg)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, dpu);
+
+	ret = dpu_irq_init(dpu);
+	if (ret)
+		goto failed_irq;
+
+	ret = dpu_submodules_init(dpu, pdev, dpu_base);
+	if (ret)
+		goto failed_submodules_init;
+
+	ret = dpu_add_client_devices(dpu);
+	if (ret) {
+		dev_err(dpu->dev, "adding client devices failed with %d\n",
+					ret);
+		goto failed_add_clients;
+	}
+
+	dpu_debug_ip_identity(dpu);
+
+	if (devtype->pixel_link_quirks)
+		dpu_pixel_link_config(dpu->id);
+
+	dev_info(dpu->dev, "driver probed\n");
+
+	return 0;
+
+failed_add_clients:
+failed_submodules_init:
+	dpu_irq_exit(dpu);
+failed_irq:
+	return ret;
+}
+
+static int dpu_remove(struct platform_device *pdev)
+{
+	struct dpu_soc *dpu = platform_get_drvdata(pdev);
+
+	platform_device_unregister_children(pdev);
+	dpu_irq_exit(dpu);
+
+	return 0;
+}
+
+static struct platform_driver dpu_driver = {
+	.driver = {
+		.name = "dpu-core",
+		.of_match_table = dpu_dt_ids,
+	},
+	.probe = dpu_probe,
+	.remove = dpu_remove,
+};
+
+module_platform_driver(dpu_driver);
+
+MODULE_DESCRIPTION("i.MX DPU driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/imx/dpu/dpu-constframe.c b/drivers/gpu/imx/dpu/dpu-constframe.c
new file mode 100644
index 0000000..77718cd
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-constframe.c
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define FRAMEDIMENSIONS		0xC
+#define WIDTH(w)		(((w) - 1) & 0x3FFF)
+#define HEIGHT(h)		((((h) - 1) & 0x3FFF) << 16)
+#define CONSTANTCOLOR		0x10
+#define RED(r)			(((r) & 0xFF) << 24)
+#define GREEN(g)		(((g) & 0xFF) << 16)
+#define BLUE(b)			(((b) & 0xFF) << 8)
+#define ALPHA(a)		((a) & 0xFF)
+#define CONTROLTRIGGER		0x14
+#define START			0x18
+#define STATUS			0x1C
+
+static const shadow_load_req_t cf_shdlreqs[] = {
+	SHLDREQID_CONSTFRAME0, SHLDREQID_CONSTFRAME1,
+	SHLDREQID_CONSTFRAME4, SHLDREQID_CONSTFRAME5,
+};
+
+struct dpu_constframe {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+	shadow_load_req_t shdlreq;
+};
+
+static inline void dpu_cf_write(struct dpu_constframe *cf, u32 value,
+				unsigned int offset)
+{
+	writel(value, cf->base + offset);
+}
+
+void constframe_shden(struct dpu_constframe *cf, bool enable)
+{
+	u32 val;
+
+	val = enable ? SHDEN : 0;
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, STATICCONTROL);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_shden);
+
+void constframe_framedimensions(struct dpu_constframe *cf, unsigned int w,
+				unsigned int h)
+{
+	u32 val;
+
+	val = WIDTH(w) | HEIGHT(h);
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, FRAMEDIMENSIONS);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_framedimensions);
+
+void constframe_constantcolor(struct dpu_constframe *cf, unsigned int r,
+			      unsigned int g, unsigned int b, unsigned int a)
+{
+	u32 val;
+
+	val = RED(r) | GREEN(g) | BLUE(b) | ALPHA(a);
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, CONSTANTCOLOR);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_constantcolor);
+
+void constframe_controltrigger(struct dpu_constframe *cf, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&cf->mutex);
+	dpu_cf_write(cf, val, CONTROLTRIGGER);
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(constframe_controltrigger);
+
+shadow_load_req_t constframe_to_shdldreq_t(struct dpu_constframe *cf)
+{
+	shadow_load_req_t t = 0;
+
+	switch (cf->id) {
+	case 0:
+		t = SHLDREQID_CONSTFRAME0;
+		break;
+	case 1:
+		t = SHLDREQID_CONSTFRAME1;
+		break;
+	case 4:
+		t = SHLDREQID_CONSTFRAME4;
+		break;
+	case 5:
+		t = SHLDREQID_CONSTFRAME5;
+		break;
+	}
+
+	return t;
+}
+EXPORT_SYMBOL_GPL(constframe_to_shdldreq_t);
+
+struct dpu_constframe *dpu_cf_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_constframe *cf;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(cf_ids); i++)
+		if (cf_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(cf_ids))
+		return ERR_PTR(-EINVAL);
+
+	cf = dpu->cf_priv[i];
+
+	mutex_lock(&cf->mutex);
+
+	if (cf->inuse) {
+		cf = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	cf->inuse = true;
+out:
+	mutex_unlock(&cf->mutex);
+
+	return cf;
+}
+EXPORT_SYMBOL_GPL(dpu_cf_get);
+
+void dpu_cf_put(struct dpu_constframe *cf)
+{
+	mutex_lock(&cf->mutex);
+
+	cf->inuse = false;
+
+	mutex_unlock(&cf->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_cf_put);
+
+int dpu_cf_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_constframe *cf;
+	int i;
+
+	cf = devm_kzalloc(dpu->dev, sizeof(*cf), GFP_KERNEL);
+	if (!cf)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(cf_ids); i++)
+		if (cf_ids[i] == id)
+			break;
+
+	dpu->cf_priv[i] = cf;
+
+	cf->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
+	if (!cf->pec_base)
+		return -ENOMEM;
+
+	cf->base = devm_ioremap(dpu->dev, base, SZ_32);
+	if (!cf->base)
+		return -ENOMEM;
+
+	cf->dpu = dpu;
+	cf->id = id;
+	cf->shdlreq = cf_shdlreqs[i];
+
+	mutex_init(&cf->mutex);
+
+	constframe_shden(cf, true);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-disengcfg.c b/drivers/gpu/imx/dpu/dpu-disengcfg.c
new file mode 100644
index 0000000..0568892
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-disengcfg.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <drm/drm_mode.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "dpu-prv.h"
+
+#define CLOCKCTRL		0x8
+typedef enum {
+	DSPCLKDIVIDE__DIV1,	/* Ext disp clk signal has pix clk freq. */
+	DSPCLKDIVIDE__DIV2,	/* Ext disp clk signal has 2x the pix clk freq. */
+} clkdivide_t;
+#define POLARITYCTRL		0xC
+#define POLHS_HIGH		BIT(0)
+#define POLVS_HIGH		BIT(1)
+#define POLEN_HIGH		BIT(2)
+#define PIXINV_INV		BIT(3)
+#define SRCSELECT		0x10
+
+struct dpu_disengcfg {
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_dec_read(struct dpu_disengcfg *dec, unsigned int offset)
+{
+	return readl(dec->base + offset);
+}
+
+static inline void dpu_dec_write(struct dpu_disengcfg *dec, u32 value,
+				 unsigned int offset)
+{
+	writel(value, dec->base + offset);
+}
+
+void disengcfg_polarity_ctrl(struct dpu_disengcfg *dec, unsigned int flags)
+{
+	const struct dpu_devtype *devtype = dec->dpu->devtype;
+	u32 val;
+
+	mutex_lock(&dec->mutex);
+	val = dpu_dec_read(dec, POLARITYCTRL);
+	if (devtype->pixel_link_nhvsync) {
+		val &= ~POLHS_HIGH;
+		val &= ~POLVS_HIGH;
+	} else {
+		if (flags & DRM_MODE_FLAG_PHSYNC)
+			val |= POLHS_HIGH;
+		if (flags & DRM_MODE_FLAG_NHSYNC)
+			val &= ~POLHS_HIGH;
+		if (flags & DRM_MODE_FLAG_PVSYNC)
+			val |= POLVS_HIGH;
+		if (flags & DRM_MODE_FLAG_NVSYNC)
+			val &= ~POLVS_HIGH;
+	}
+	dpu_dec_write(dec, val, POLARITYCTRL);
+	mutex_unlock(&dec->mutex);
+}
+EXPORT_SYMBOL_GPL(disengcfg_polarity_ctrl);
+
+struct dpu_disengcfg *dpu_dec_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_disengcfg *dec;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dec_ids); i++)
+		if (dec_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(dec_ids))
+		return ERR_PTR(-EINVAL);
+
+	dec = dpu->dec_priv[i];
+
+	mutex_lock(&dec->mutex);
+
+	if (dec->inuse) {
+		dec = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	dec->inuse = true;
+out:
+	mutex_unlock(&dec->mutex);
+
+	return dec;
+}
+EXPORT_SYMBOL_GPL(dpu_dec_get);
+
+void dpu_dec_put(struct dpu_disengcfg *dec)
+{
+	mutex_lock(&dec->mutex);
+
+	dec->inuse = false;
+
+	mutex_unlock(&dec->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_dec_put);
+
+int dpu_dec_init(struct dpu_soc *dpu, unsigned int id,
+			unsigned long unused, unsigned long base)
+{
+	struct dpu_disengcfg *dec;
+
+	dec = devm_kzalloc(dpu->dev, sizeof(*dec), GFP_KERNEL);
+	if (!dec)
+		return -ENOMEM;
+
+	dpu->dec_priv[id] = dec;
+
+	dec->base = devm_ioremap(dpu->dev, base, SZ_16);
+	if (!dec->base)
+		return -ENOMEM;
+
+	dec->dpu = dpu;
+	dec->id = id;
+	mutex_init(&dec->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-extdst.c b/drivers/gpu/imx/dpu/dpu-extdst.c
new file mode 100644
index 0000000..fdb8572
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-extdst.c
@@ -0,0 +1,485 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_STATIC		0x8
+#define POWERDOWN			BIT(4)
+#define SYNC_MODE			BIT(8)
+#define SW_RESET			BIT(11)
+#define DIV(n)				(((n) & 0xFF) << 16)
+#define DIV_RESET			0x80
+#define PIXENGCFG_DYNAMIC		0xC
+#define PIXENGCFG_REQUEST		0x10
+#define SHDLDREQ(n)			BIT(n)
+#define SEL_SHDLDREQ			BIT(0)
+#define PIXENGCFG_TRIGGER		0x14
+#define SYNC_TRIGGER			BIT(0)
+#define TRIGGER_SEQUENCE_COMPLETE	BIT(4)
+#define PIXENGCFG_STATUS		0x18
+#define SYNC_BUSY			BIT(8)
+#define KICK_MODE			BIT(8)
+#define PERFCOUNTMODE			BIT(12)
+#define CONTROL				0xC
+#define GAMMAAPPLYENABLE		BIT(0)
+#define SOFTWAREKICK			0x10
+#define KICK				BIT(0)
+#define STATUS				0x14
+#define CNT_ERR_STS			BIT(0)
+#define CONTROLWORD			0x18
+#define CURPIXELCNT			0x1C
+static u16 get_xval(u32 pixel_cnt)
+{
+	return pixel_cnt && 0xFF;
+}
+
+static u16 get_yval(u32 pixel_cnt)
+{
+	return pixel_cnt >> 16;
+}
+#define LASTPIXELCNT			0x20
+#define PERFCOUNTER			0x24
+
+struct dpu_extdst {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_pec_ed_read(struct dpu_extdst *ed, unsigned int offset)
+{
+	return readl(ed->pec_base + offset);
+}
+
+static inline void dpu_pec_ed_write(struct dpu_extdst *ed, u32 value,
+				unsigned int offset)
+{
+	writel(value, ed->pec_base + offset);
+}
+
+static inline u32 dpu_ed_read(struct dpu_extdst *ed, unsigned int offset)
+{
+	return readl(ed->base + offset);
+}
+
+static inline void dpu_ed_write(struct dpu_extdst *ed, u32 value,
+				unsigned int offset)
+{
+	writel(value, ed->base + offset);
+}
+
+static inline bool dpu_ed_is_safety_stream(struct dpu_extdst *ed)
+{
+	if (ed->id == 4 || ed->id == 5)
+		return true;
+
+	return false;
+}
+
+static inline bool dpu_ed_src_sel_is_extsrc(extdst_src_sel_t src)
+{
+	if (src == ED_SRC_EXTSRC4 || src == ED_SRC_EXTSRC5)
+		return true;
+
+	return false;
+}
+
+void extdst_pixengcfg_shden(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_shden);
+
+void extdst_pixengcfg_powerdown(struct dpu_extdst *ed, bool powerdown)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (powerdown)
+		val |= POWERDOWN;
+	else
+		val &= ~POWERDOWN;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_powerdown);
+
+void extdst_pixengcfg_sync_mode(struct dpu_extdst *ed, ed_sync_mode_t mode)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (mode == AUTO)
+		val |= SYNC_MODE;
+	else
+		val &= ~SYNC_MODE;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_sync_mode);
+
+void extdst_pixengcfg_reset(struct dpu_extdst *ed, bool reset)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	if (reset)
+		val |= SW_RESET;
+	else
+		val &= ~SW_RESET;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_reset);
+
+void extdst_pixengcfg_div(struct dpu_extdst *ed, u16 div)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATIC);
+	val &= ~0xFF0000;
+	val |= DIV(div);
+	dpu_pec_ed_write(ed, val, PIXENGCFG_STATIC);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_div);
+
+int extdst_pixengcfg_src_sel(struct dpu_extdst *ed, extdst_src_sel_t src)
+{
+	struct dpu_soc *dpu = ed->dpu;
+	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
+	u32 mapped_src;
+
+	mapped_src = block_id_map ? block_id_map[src] : src;
+	if (WARN_ON(mapped_src == NA))
+		return -EINVAL;
+
+	if (dpu_ed_is_safety_stream(ed) && dpu_ed_src_sel_is_extsrc(src)) {
+		dev_err(dpu->dev, "ExtDst%d source cannot be ExtSrc\n", ed->id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&ed->mutex);
+	dpu_pec_ed_write(ed, mapped_src, PIXENGCFG_DYNAMIC);
+	mutex_unlock(&ed->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_src_sel);
+
+void extdst_pixengcfg_sel_shdldreq(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_REQUEST);
+	val |= SEL_SHDLDREQ;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_REQUEST);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_sel_shdldreq);
+
+void extdst_pixengcfg_shdldreq(struct dpu_extdst *ed, u32 req_mask)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_REQUEST);
+	val |= req_mask;
+	dpu_pec_ed_write(ed, val, PIXENGCFG_REQUEST);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_shdldreq);
+
+void extdst_pixengcfg_sync_trigger(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_pec_ed_write(ed, SYNC_TRIGGER, PIXENGCFG_TRIGGER);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_sync_trigger);
+
+void extdst_pixengcfg_trigger_sequence_complete(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_pec_ed_write(ed, TRIGGER_SEQUENCE_COMPLETE, PIXENGCFG_TRIGGER);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_trigger_sequence_complete);
+
+bool extdst_pixengcfg_is_sync_busy(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATUS);
+	mutex_unlock(&ed->mutex);
+
+	return val & SYNC_BUSY;
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_is_sync_busy);
+
+ed_pipeline_status_t extdst_pixengcfg_pipeline_status(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_pec_ed_read(ed, PIXENGCFG_STATUS);
+	mutex_unlock(&ed->mutex);
+
+	return val & 0x3;
+}
+EXPORT_SYMBOL_GPL(extdst_pixengcfg_pipeline_status);
+
+void extdst_shden(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_ed_write(ed, val, STATICCONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_shden);
+
+void extdst_kick_mode(struct dpu_extdst *ed, ed_kick_mode_t mode)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATICCONTROL);
+	val &= ~KICK_MODE;
+	val |= mode;
+	dpu_ed_write(ed, val, STATICCONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_kick_mode);
+
+void extdst_perfcountmode(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATICCONTROL);
+	if (enable)
+		val |= PERFCOUNTMODE;
+	else
+		val &= ~PERFCOUNTMODE;
+	dpu_ed_write(ed, val, STATICCONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_perfcountmode);
+
+void extdst_gamma_apply_enable(struct dpu_extdst *ed, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, CONTROL);
+	if (enable)
+		val |= GAMMAAPPLYENABLE;
+	else
+		val &= ~GAMMAAPPLYENABLE;
+	dpu_ed_write(ed, val, CONTROL);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_gamma_apply_enable);
+
+void extdst_kick(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_ed_write(ed, KICK, SOFTWAREKICK);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_kick);
+
+void extdst_cnt_err_clear(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+	dpu_ed_write(ed, CNT_ERR_STS, STATUS);
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(extdst_cnt_err_clear);
+
+bool extdst_cnt_err_status(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, STATUS);
+	mutex_unlock(&ed->mutex);
+
+	return val & CNT_ERR_STS;
+}
+EXPORT_SYMBOL_GPL(extdst_cnt_err_status);
+
+u32 extdst_last_control_word(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, CONTROLWORD);
+	mutex_unlock(&ed->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(extdst_last_control_word);
+
+void extdst_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, CURPIXELCNT);
+	mutex_unlock(&ed->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(extdst_pixel_cnt);
+
+void extdst_last_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, LASTPIXELCNT);
+	mutex_unlock(&ed->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(extdst_last_pixel_cnt);
+
+u32 extdst_perfresult(struct dpu_extdst *ed)
+{
+	u32 val;
+
+	mutex_lock(&ed->mutex);
+	val = dpu_ed_read(ed, PERFCOUNTER);
+	mutex_unlock(&ed->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(extdst_perfresult);
+
+struct dpu_extdst *dpu_ed_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_extdst *ed;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ed_ids); i++)
+		if (ed_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(ed_ids))
+		return ERR_PTR(-EINVAL);
+
+	ed = dpu->ed_priv[i];
+
+	mutex_lock(&ed->mutex);
+
+	if (ed->inuse) {
+		ed = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	ed->inuse = true;
+out:
+	mutex_unlock(&ed->mutex);
+
+	return ed;
+}
+EXPORT_SYMBOL_GPL(dpu_ed_get);
+
+void dpu_ed_put(struct dpu_extdst *ed)
+{
+	mutex_lock(&ed->mutex);
+
+	ed->inuse = false;
+
+	mutex_unlock(&ed->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_ed_put);
+
+int dpu_ed_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_extdst *ed;
+	int ret, i;
+
+	ed = devm_kzalloc(dpu->dev, sizeof(*ed), GFP_KERNEL);
+	if (!ed)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(ed_ids); i++)
+		if (ed_ids[i] == id)
+			break;
+
+	dpu->ed_priv[i] = ed;
+
+	ed->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_32);
+	if (!ed->pec_base)
+		return -ENOMEM;
+
+	ed->base = devm_ioremap(dpu->dev, base, SZ_64);
+	if (!ed->base)
+		return -ENOMEM;
+
+	ed->dpu = dpu;
+	ed->id = id;
+	mutex_init(&ed->mutex);
+
+	ret = extdst_pixengcfg_src_sel(ed, ED_SRC_DISABLE);
+	if (ret < 0)
+		return ret;
+
+	extdst_pixengcfg_shden(ed, true);
+	extdst_pixengcfg_powerdown(ed, false);
+	extdst_pixengcfg_sync_mode(ed, SINGLE);
+	extdst_pixengcfg_reset(ed, false);
+	extdst_pixengcfg_div(ed, DIV_RESET);
+	extdst_shden(ed, true);
+	extdst_perfcountmode(ed, false);
+	extdst_kick_mode(ed, EXTERNAL);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-fetchdecode.c b/drivers/gpu/imx/dpu/dpu-fetchdecode.c
new file mode 100644
index 0000000..d0eaf66
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-fetchdecode.c
@@ -0,0 +1,503 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_DYNAMIC		0x8
+#define SRC_NUM				3
+#define FD_NUM				4
+static const fd_dynamic_src_sel_t fd_srcs[FD_NUM][SRC_NUM] = {
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO0, FD_SRC_FETCHDECODE2 },
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO1, FD_SRC_FETCHDECODE3 },
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO0, FD_SRC_FETCHECO2 },
+	{ FD_SRC_DISABLE, FD_SRC_FETCHECO1, FD_SRC_FETCHECO2 },
+};
+
+#define PIXENGCFG_STATUS		0xC
+
+#define RINGBUFSTARTADDR0		0x10
+#define RINGBUFWRAPADDR0		0x14
+#define FRAMEPROPERTIES0		0x18
+#define BASEADDRESS0			0x1C
+#define SOURCEBUFFERATTRIBUTES0		0x20
+#define SOURCEBUFFERDIMENSION0		0x24
+#define COLORCOMPONENTBITS0		0x28
+#define COLORCOMPONENTSHIFT0		0x2C
+#define LAYEROFFSET0			0x30
+#define CLIPWINDOWOFFSET0		0x34
+#define CLIPWINDOWDIMENSIONS0		0x38
+#define CONSTANTCOLOR0			0x3C
+#define LAYERPROPERTY0			0x40
+#define FRAMEDIMENSIONS			0x44
+#define FRAMERESAMPLING			0x48
+#define DECODECONTROL			0x4C
+#define SOURCEBUFFERLENGTH		0x50
+#define CONTROL				0x54
+#define CONTROLTRIGGER			0x58
+#define START				0x5C
+#define FETCHTYPE			0x60
+#define DECODERSTATUS			0x64
+#define READADDRESS0			0x68
+#define BURSTBUFFERPROPERTIES		0x6C
+#define STATUS				0x70
+#define HIDDENSTATUS			0x74
+
+static const shadow_load_req_t fd_shdlreqs[] = {
+	SHLDREQID_FETCHDECODE0, SHLDREQID_FETCHDECODE1,
+	SHLDREQID_FETCHDECODE2, SHLDREQID_FETCHDECODE3,
+};
+
+struct dpu_fetchdecode {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+	fetchtype_t fetchtype;
+	shadow_load_req_t shdlreq;
+};
+
+static inline u32 dpu_pec_fd_read(struct dpu_fetchdecode *fd,
+				  unsigned int offset)
+{
+	return readl(fd->pec_base + offset);
+}
+
+static inline void dpu_pec_fd_write(struct dpu_fetchdecode *fd, u32 value,
+				    unsigned int offset)
+{
+	writel(value, fd->pec_base + offset);
+}
+
+static inline u32 dpu_fd_read(struct dpu_fetchdecode *fd, unsigned int offset)
+{
+	return readl(fd->base + offset);
+}
+
+static inline void dpu_fd_write(struct dpu_fetchdecode *fd, u32 value,
+				unsigned int offset)
+{
+	writel(value, fd->base + offset);
+}
+
+int fetchdecode_pixengcfg_dynamic_src_sel(struct dpu_fetchdecode *fd,
+					  fd_dynamic_src_sel_t src)
+{
+	int i;
+
+	mutex_lock(&fd->mutex);
+	for (i = 0; i < SRC_NUM; i++) {
+		if (fd_srcs[fd->id][i] == src) {
+			dpu_pec_fd_write(fd, src, PIXENGCFG_DYNAMIC);
+			mutex_unlock(&fd->mutex);
+			return 0;
+		}
+	}
+	mutex_unlock(&fd->mutex);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(fetchdecode_pixengcfg_dynamic_src_sel);
+
+static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
+{
+	return (r << 24) | (g << 16) | (b << 8) | a;
+}
+
+static inline u32 yuv_color(u8 y, u8 u, u8 v)
+{
+	return (y << 24) | (u << 16) | (v << 8);
+}
+
+void fetchdecode_shden(struct dpu_fetchdecode *fd, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_fd_write(fd, val, STATICCONTROL);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_shden);
+
+void fetchdecode_baddr_autoupdate(struct dpu_fetchdecode *fd, u8 layer_mask)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, STATICCONTROL);
+	val &= ~BASEADDRESSAUTOUPDATE_MASK;
+	val |= BASEADDRESSAUTOUPDATE(layer_mask);
+	dpu_fd_write(fd, val, STATICCONTROL);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_baddr_autoupdate);
+
+void fetchdecode_baseaddress(struct dpu_fetchdecode *fd, dma_addr_t paddr)
+{
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, paddr, BASEADDRESS0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_baseaddress);
+
+void fetchdecode_source_bpp(struct dpu_fetchdecode *fd, int bpp)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, SOURCEBUFFERATTRIBUTES0);
+	val &= ~0x3f0000;
+	val |= BITSPERPIXEL(bpp);
+	dpu_fd_write(fd, val, SOURCEBUFFERATTRIBUTES0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_source_bpp);
+
+void fetchdecode_source_stride(struct dpu_fetchdecode *fd, int stride)
+{
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, SOURCEBUFFERATTRIBUTES0);
+	val &= ~0xffff;
+	val |= STRIDE(stride);
+	dpu_fd_write(fd, val, SOURCEBUFFERATTRIBUTES0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_source_stride);
+
+void fetchdecode_src_buf_dimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				    unsigned int h)
+{
+	u32 val;
+
+	val = LINEWIDTH(w) | LINECOUNT(h);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, SOURCEBUFFERDIMENSION0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_src_buf_dimensions);
+
+void fetchdecode_set_fmt(struct dpu_fetchdecode *fd, u32 fmt)
+{
+	u32 bits, shift;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dpu_pixel_format_matrix); i++) {
+		if (dpu_pixel_format_matrix[i].pixel_format == fmt) {
+			bits = dpu_pixel_format_matrix[i].bits;
+			shift = dpu_pixel_format_matrix[i].shift;
+
+			mutex_lock(&fd->mutex);
+			dpu_fd_write(fd, bits, COLORCOMPONENTBITS0);
+			dpu_fd_write(fd, shift, COLORCOMPONENTSHIFT0);
+			mutex_unlock(&fd->mutex);
+			return;
+		}
+	}
+
+	WARN_ON(1);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_set_fmt);
+
+void fetchdecode_layeroffset(struct dpu_fetchdecode *fd, unsigned int x,
+			     unsigned int y)
+{
+	u32 val;
+
+	val = LAYERXOFFSET(x) | LAYERYOFFSET(y);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, LAYEROFFSET0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_layeroffset);
+
+void fetchdecode_clipoffset(struct dpu_fetchdecode *fd, unsigned int x,
+			    unsigned int y)
+{
+	u32 val;
+
+	val = CLIPWINDOWXOFFSET(x) | CLIPWINDOWYOFFSET(y);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CLIPWINDOWOFFSET0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_clipoffset);
+
+void fetchdecode_layerproperty(struct dpu_fetchdecode *fd, bool enable)
+{
+	u32 val;
+
+	if (enable)
+		val = SOURCEBUFFERENABLE | CLIPWINDOWENABLE;
+	else
+		val = 0;
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, LAYERPROPERTY0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_layerproperty);
+
+void fetchdecode_clipdimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				unsigned int h)
+{
+	u32 val;
+
+	val = CLIPWINDOWWIDTH(w) | CLIPWINDOWHEIGHT(h);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CLIPWINDOWDIMENSIONS0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_clipdimensions);
+
+void fetchdecode_framedimensions(struct dpu_fetchdecode *fd, unsigned int w,
+				 unsigned int h)
+{
+	u32 val;
+
+	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, FRAMEDIMENSIONS);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_framedimensions);
+
+void fetchdecode_rgb_constantcolor(struct dpu_fetchdecode *fd,
+					u8 r, u8 g, u8 b, u8 a)
+{
+	u32 val;
+
+	val = rgb_color(r, g, b, a);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CONSTANTCOLOR0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_rgb_constantcolor);
+
+void fetchdecode_yuv_constantcolor(struct dpu_fetchdecode *fd, u8 y, u8 u, u8 v)
+{
+	u32 val;
+
+	val = yuv_color(y, u, v);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CONSTANTCOLOR0);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_yuv_constantcolor);
+
+void fetchdecode_controltrigger(struct dpu_fetchdecode *fd, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, val, CONTROLTRIGGER);
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchdecode_controltrigger);
+
+int fetchdecode_fetchtype(struct dpu_fetchdecode *fd, fetchtype_t *type)
+{
+	struct dpu_soc *dpu = fd->dpu;
+	u32 val;
+
+	mutex_lock(&fd->mutex);
+	val = dpu_fd_read(fd, FETCHTYPE);
+	val &= FETCHTYPE_MASK;
+	mutex_unlock(&fd->mutex);
+
+	switch (val) {
+	case FETCHTYPE__DECODE:
+		dev_dbg(dpu->dev, "FetchDecode%d with RL and RLAD decoder\n",
+				fd->id);
+		break;
+	case FETCHTYPE__LAYER:
+		dev_dbg(dpu->dev, "FetchDecode%d with fractional "
+				"plane(8 layers)\n", fd->id);
+		break;
+	case FETCHTYPE__WARP:
+		dev_dbg(dpu->dev, "FetchDecode%d with arbitrary warping and "
+				"fractional plane(8 layers)\n", fd->id);
+		break;
+	case FETCHTYPE__ECO:
+		dev_dbg(dpu->dev, "FetchDecode%d with minimum feature set for "
+				"alpha, chroma and coordinate planes\n",
+				fd->id);
+		break;
+	case FETCHTYPE__PERSP:
+		dev_dbg(dpu->dev, "FetchDecode%d with affine, perspective and "
+				"arbitrary warping\n", fd->id);
+		break;
+	case FETCHTYPE__ROT:
+		dev_dbg(dpu->dev, "FetchDecode%d with affine and arbitrary "
+				"warping\n", fd->id);
+		break;
+	case FETCHTYPE__DECODEL:
+		dev_dbg(dpu->dev, "FetchDecode%d with RL and RLAD decoder, "
+				"reduced feature set\n", fd->id);
+		break;
+	case FETCHTYPE__LAYERL:
+		dev_dbg(dpu->dev, "FetchDecode%d with fractional "
+				"plane(8 layers), reduced feature set\n",
+				fd->id);
+		break;
+	case FETCHTYPE__ROTL:
+		dev_dbg(dpu->dev, "FetchDecode%d with affine and arbitrary "
+				"warping, reduced feature set\n", fd->id);
+		break;
+	default:
+		dev_warn(dpu->dev, "Invalid fetch type %u for FetchDecode%d\n",
+				val, fd->id);
+		return -EINVAL;
+	}
+
+	*type = val;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fetchdecode_fetchtype);
+
+shadow_load_req_t fetchdecode_to_shdldreq_t(struct dpu_fetchdecode *fd)
+{
+	shadow_load_req_t t = 0;
+
+	switch (fd->id) {
+	case 0:
+		t = SHLDREQID_FETCHDECODE0;
+		break;
+	case 1:
+		t = SHLDREQID_FETCHDECODE1;
+		break;
+	case 2:
+		t = SHLDREQID_FETCHDECODE2;
+		break;
+	case 3:
+		t = SHLDREQID_FETCHDECODE3;
+		break;
+	default:
+		break;
+	}
+
+	return t;
+}
+EXPORT_SYMBOL_GPL(fetchdecode_to_shdldreq_t);
+
+struct dpu_fetchdecode *dpu_fd_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_fetchdecode *fd;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fd_ids); i++)
+		if (fd_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fd_ids))
+		return ERR_PTR(-EINVAL);
+
+	fd = dpu->fd_priv[i];
+
+	mutex_lock(&fd->mutex);
+
+	if (fd->inuse) {
+		fd = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fd->inuse = true;
+out:
+	mutex_unlock(&fd->mutex);
+
+	return fd;
+}
+EXPORT_SYMBOL_GPL(dpu_fd_get);
+
+void dpu_fd_put(struct dpu_fetchdecode *fd)
+{
+	mutex_lock(&fd->mutex);
+
+	fd->inuse = false;
+
+	mutex_unlock(&fd->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fd_put);
+
+int dpu_fd_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_fetchdecode *fd;
+	int ret, i;
+
+	fd = devm_kzalloc(dpu->dev, sizeof(*fd), GFP_KERNEL);
+	if (!fd)
+		return -ENOMEM;
+
+	dpu->fd_priv[id] = fd;
+
+	fd->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
+	if (!fd->pec_base)
+		return -ENOMEM;
+
+	fd->base = devm_ioremap(dpu->dev, base, SZ_1K);
+	if (!fd->base)
+		return -ENOMEM;
+
+	fd->dpu = dpu;
+	fd->id = id;
+	for (i = 0; i < ARRAY_SIZE(fd_ids); i++) {
+		if (fd_ids[i] == id) {
+			fd->shdlreq = fd_shdlreqs[i];
+			break;
+		}
+	}
+	mutex_init(&fd->mutex);
+
+	ret = fetchdecode_pixengcfg_dynamic_src_sel(fd, FD_SRC_DISABLE);
+	if (ret < 0)
+		return ret;
+
+	ret = fetchdecode_fetchtype(fd, &fd->fetchtype);
+	if (ret < 0)
+		return ret;
+
+	fetchdecode_baddr_autoupdate(fd, 0x0);
+	fetchdecode_shden(fd, true);
+
+	mutex_lock(&fd->mutex);
+	dpu_fd_write(fd, SETNUMBUFFERS(16) | SETBURSTLENGTH(16),
+			BURSTBUFFERMANAGEMENT);
+	mutex_unlock(&fd->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-fetchlayer.c b/drivers/gpu/imx/dpu/dpu-fetchlayer.c
new file mode 100644
index 0000000..fdc8c14
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-fetchlayer.c
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_STATUS		0x8
+#define BASEADDRESS(n)			(0x10 + (n) * 0x28)
+#define SOURCEBUFFERATTRIBUTES(n)	(0x14 + (n) * 0x28)
+#define SOURCEBUFFERDIMENSION(n)	(0x18 + (n) * 0x28)
+#define COLORCOMPONENTBITS(n)		(0x1C + (n) * 0x28)
+#define COLORCOMPONENTSHIFT(n)		(0x20 + (n) * 0x28)
+#define LAYEROFFSET(n)			(0x24 + (n) * 0x28)
+#define CLIPWINDOWOFFSET(n)		(0x28 + (n) * 0x28)
+#define CLIPWINDOWDIMENSIONS(n)		(0x2C + (n) * 0x28)
+#define CONSTANTCOLOR(n)		(0x30 + (n) * 0x28)
+#define LAYERPROPERTY(n)		(0x34 + (n) * 0x28)
+#define FRAMEDIMENSIONS			0x150
+#define FRAMERESAMPLING			0x154
+#define CONTROL				0x158
+#define TRIGGERENABLE			0x15C
+#define SHDLDREQ(lm)			((lm) & 0xFF)
+#define CONTROLTRIGGER			0x160
+#define START				0x164
+#define FETCHTYPE			0x168
+#define BURSTBUFFERPROPERTIES		0x16C
+#define STATUS				0x170
+#define HIDDENSTATUS			0x174
+
+static const shadow_load_req_t fl_shdlreqs[] = {
+	SHLDREQID_FETCHLAYER0, SHLDREQID_FETCHLAYER1,
+};
+
+struct dpu_fetchlayer {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+	fetchtype_t fetchtype;
+	shadow_load_req_t shdlreq;
+};
+
+static inline u32 dpu_fl_read(struct dpu_fetchlayer *fl, unsigned int offset)
+{
+	return readl(fl->base + offset);
+}
+
+static inline void dpu_fl_write(struct dpu_fetchlayer *fl, u32 value,
+				unsigned int offset)
+{
+	writel(value, fl->base + offset);
+}
+
+static inline u32 rgb_color(u8 r, u8 g, u8 b, u8 a)
+{
+	return (r << 24) | (g << 16) | (b << 8) | a;
+}
+
+static inline u32 yuv_color(u8 y, u8 u, u8 v)
+{
+	return (y << 24) | (u << 16) | (v << 8);
+}
+
+void fetchlayer_shden(struct dpu_fetchlayer *fl, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fl->mutex);
+	val = dpu_fl_read(fl, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_fl_write(fl, val, STATICCONTROL);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_shden);
+
+void fetchlayer_baddr_autoupdate(struct dpu_fetchlayer *fl, u8 layer_mask)
+{
+	u32 val;
+
+	mutex_lock(&fl->mutex);
+	val = dpu_fl_read(fl, STATICCONTROL);
+	val &= ~BASEADDRESSAUTOUPDATE_MASK;
+	val |= BASEADDRESSAUTOUPDATE(layer_mask);
+	dpu_fl_write(fl, val, STATICCONTROL);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_baddr_autoupdate);
+
+void fetchlayer_framedimensions(struct dpu_fetchlayer *fl, unsigned int w,
+				unsigned int h)
+{
+	u32 val;
+
+	val = FRAMEWIDTH(w) | FRAMEHEIGHT(h);
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, FRAMEDIMENSIONS);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_framedimensions);
+
+void fetchlayer_rgb_constantcolor(struct dpu_fetchlayer *fl,
+					u8 r, u8 g, u8 b, u8 a)
+{
+	u32 val;
+
+	val = rgb_color(r, g, b, a);
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, CONSTANTCOLOR(fl->id));
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_rgb_constantcolor);
+
+void fetchlayer_yuv_constantcolor(struct dpu_fetchlayer *fl, u8 y, u8 u, u8 v)
+{
+	u32 val;
+
+	val = yuv_color(y, u, v);
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, CONSTANTCOLOR(fl->id));
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_yuv_constantcolor);
+
+void fetchlayer_controltrigger(struct dpu_fetchlayer *fl, bool trigger)
+{
+	u32 val;
+
+	val = trigger ? SHDTOKGEN : 0;
+
+	mutex_lock(&fl->mutex);
+	dpu_fl_write(fl, val, CONTROLTRIGGER);
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(fetchlayer_controltrigger);
+
+int fetchlayer_fetchtype(struct dpu_fetchlayer *fl, fetchtype_t *type)
+{
+	struct dpu_soc *dpu = fl->dpu;
+	u32 val;
+
+	mutex_lock(&fl->mutex);
+	val = dpu_fl_read(fl, FETCHTYPE);
+	val &= FETCHTYPE_MASK;
+	mutex_unlock(&fl->mutex);
+
+	switch (val) {
+	case FETCHTYPE__DECODE:
+		dev_dbg(dpu->dev, "FetchLayer%d with RL and RLAD decoder\n",
+				fl->id);
+		break;
+	case FETCHTYPE__LAYER:
+		dev_dbg(dpu->dev, "FetchLayer%d with fractional "
+				"plane(8 layers)\n", fl->id);
+		break;
+	case FETCHTYPE__WARP:
+		dev_dbg(dpu->dev, "FetchLayer%d with arbitrary warping and "
+				"fractional plane(8 layers)\n", fl->id);
+		break;
+	case FETCHTYPE__ECO:
+		dev_dbg(dpu->dev, "FetchLayer%d with minimum feature set for "
+				"alpha, chroma and coordinate planes\n",
+				fl->id);
+		break;
+	case FETCHTYPE__PERSP:
+		dev_dbg(dpu->dev, "FetchLayer%d with affine, perspective and "
+				"arbitrary warping\n", fl->id);
+		break;
+	case FETCHTYPE__ROT:
+		dev_dbg(dpu->dev, "FetchLayer%d with affine and arbitrary "
+				"warping\n", fl->id);
+		break;
+	case FETCHTYPE__DECODEL:
+		dev_dbg(dpu->dev, "FetchLayer%d with RL and RLAD decoder, "
+				"reduced feature set\n", fl->id);
+		break;
+	case FETCHTYPE__LAYERL:
+		dev_dbg(dpu->dev, "FetchLayer%d with fractional "
+				"plane(8 layers), reduced feature set\n",
+				fl->id);
+		break;
+	case FETCHTYPE__ROTL:
+		dev_dbg(dpu->dev, "FetchLayer%d with affine and arbitrary "
+				"warping, reduced feature set\n", fl->id);
+		break;
+	default:
+		dev_warn(dpu->dev, "Invalid fetch type %u for FetchLayer%d\n",
+				val, fl->id);
+		return -EINVAL;
+	}
+
+	*type = val;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fetchlayer_fetchtype);
+
+struct dpu_fetchlayer *dpu_fl_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_fetchlayer *fl;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fl_ids); i++)
+		if (fl_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fl_ids))
+		return ERR_PTR(-EINVAL);
+
+	fl = dpu->fl_priv[i];
+
+	mutex_lock(&fl->mutex);
+
+	if (fl->inuse) {
+		fl = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fl->inuse = true;
+out:
+	mutex_unlock(&fl->mutex);
+
+	return fl;
+}
+EXPORT_SYMBOL_GPL(dpu_fl_get);
+
+void dpu_fl_put(struct dpu_fetchlayer *fl)
+{
+	mutex_lock(&fl->mutex);
+
+	fl->inuse = false;
+
+	mutex_unlock(&fl->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fl_put);
+
+int dpu_fl_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_fetchlayer *fl;
+	int ret, i;
+
+	fl = devm_kzalloc(dpu->dev, sizeof(*fl), GFP_KERNEL);
+	if (!fl)
+		return -ENOMEM;
+
+	dpu->fl_priv[id] = fl;
+
+	fl->pec_base = devm_ioremap(dpu->dev, base, SZ_16);
+	if (!fl->pec_base)
+		return -ENOMEM;
+
+	fl->base = devm_ioremap(dpu->dev, base, SZ_512);
+	if (!fl->base)
+		return -ENOMEM;
+
+	fl->dpu = dpu;
+	fl->id = id;
+	for (i = 0; i < ARRAY_SIZE(fl_ids); i++) {
+		if (fl_ids[i] == id) {
+			fl->shdlreq = fl_shdlreqs[i];
+			break;
+		}
+	}
+	mutex_init(&fl->mutex);
+
+	ret = fetchlayer_fetchtype(fl, &fl->fetchtype);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-framegen.c b/drivers/gpu/imx/dpu/dpu-framegen.c
new file mode 100644
index 0000000..93f000f
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-framegen.c
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define FGSTCTRL		0x8
+#define FGSYNCMODE_MASK		0x6
+typedef enum {
+	/* No side-by-side synchronization. */
+	FGSYNCMODE__OFF = 0,
+	/* Framegen is master. */
+	FGSYNCMODE__MASTER = 1 << 1,
+	/* Runs in cyclic synchronization mode. */
+	FGSYNCMODE__SLAVE_CYC = 2 << 1,
+	/* Runs in one time synchronization mode. */
+	FGSYNCMODE__SLAVE_ONCE = 3 << 1,
+} fgsyncmode_t;
+#define HTCFG1			0xC
+#define HTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
+#define HACT(n)			((n) & 0x3FFF)
+#define HTCFG2			0x10
+#define HSEN			BIT(31)
+#define HSBP(n)			((((n) - 1) & 0x3FFF) << 16)
+#define HSYNC(n)		(((n) - 1) & 0x3FFF)
+#define VTCFG1			0x14
+#define VTOTAL(n)		((((n) - 1) & 0x3FFF) << 16)
+#define VACT(n)			((n) & 0x3FFF)
+#define VTCFG2			0x18
+#define VSEN			BIT(31)
+#define VSBP(n)			((((n) - 1) & 0x3FFF) << 16)
+#define VSYNC(n)		(((n) - 1) & 0x3FFF)
+#define INTCONFIG(n)		(0x1C + 4 * (n))
+#define EN			BIT(31)
+#define ROW(n)			(((n) & 0x3FFF) << 16)
+#define COL(n)			((n) & 0x3FFF)
+#define PKICKCONFIG		0x2C
+#define SKICKCONFIG		0x30
+#define SECSTATCONFIG		0x34
+#define FGSRCR1			0x38
+#define FGSRCR2			0x3C
+#define FGSRCR3			0x40
+#define FGSRCR4			0x44
+#define FGSRCR5			0x48
+#define FGSRCR6			0x4C
+#define FGKSDR			0x50
+#define PACFG			0x54
+#define STARTX(n)		(((n) + 1) & 0x3FFF)
+#define STARTY(n)		(((((n) + 1) & 0x3FFF)) << 16)
+#define SACFG			0x58
+#define FGINCTRL		0x5C
+#define FGDM_MASK		0x7
+#define ENPRIMALPHA		BIT(3)
+#define ENSECALPHA		BIT(4)
+#define FGINCTRLPANIC		0x60
+#define FGCCR			0x64
+#define CCALPHA(a)		(((a) & 0x1) << 30)
+#define CCRED(r)		(((r) & 0x3FF) << 20)
+#define CCGREEN(g)		(((g) & 0x3FF) << 10)
+#define CCBLUE(b)		((b) & 0x3FF)
+#define FGENABLE		0x68
+#define FGEN			BIT(0)
+#define FGSLR			0x6C
+#define FGENSTS			0x70
+#define ENSTS			BIT(0)
+#define FGTIMESTAMP		0x74
+#define LINEINDEX_MASK		0x3FFF
+#define LINEINDEX_SHIFT		0
+#define FRAMEINDEX_MASK		0xFFFFC000
+#define FRAMEINDEX_SHIFT	14
+#define FGCHSTAT		0x78
+#define FGCHSTATCLR		0x7C
+#define FGSKEWMON		0x80
+#define FGSFIFOMIN		0x84
+#define FGSFIFOMAX		0x88
+#define FGSFIFOFILLCLR		0x8C
+#define FGSREPD			0x90
+#define FGSRFTD			0x94
+
+struct dpu_framegen {
+	void __iomem *base;
+	struct clk *clk_pll;
+	struct clk *clk_disp;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_fg_read(struct dpu_framegen *fg, unsigned int offset)
+{
+	return readl(fg->base + offset);
+}
+
+static inline void dpu_fg_write(struct dpu_framegen *fg, u32 value,
+				unsigned int offset)
+{
+	writel(value, fg->base + offset);
+}
+
+void framegen_enable(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, FGEN, FGENABLE);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_enable);
+
+void framegen_disable(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, 0, FGENABLE);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_disable);
+
+void framegen_shdtokgen(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, SHDTOKGEN, FGSLR);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_shdtokgen);
+
+void framegen_cfg_videomode(struct dpu_framegen *fg, struct drm_display_mode *m)
+{
+	const struct dpu_devtype *devtype = fg->dpu->devtype;
+	u32 hact, htotal, hsync, hsbp;
+	u32 vact, vtotal, vsync, vsbp;
+	u32 val;
+	unsigned long disp_clock_rate, pll_clock_rate = 0;
+
+	hact = m->crtc_hdisplay;
+	htotal = m->crtc_htotal;
+	hsync = m->crtc_hsync_end - m->crtc_hsync_start;
+	hsbp = m->crtc_htotal - m->crtc_hsync_start;
+
+	vact = m->crtc_vdisplay;
+	vtotal = m->crtc_vtotal;
+	vsync = m->crtc_vsync_end - m->crtc_vsync_start;
+	vsbp = m->crtc_vtotal - m->crtc_vsync_start;
+
+	mutex_lock(&fg->mutex);
+	/* video mode */
+	dpu_fg_write(fg, HACT(hact) | HTOTAL(htotal), HTCFG1);
+	dpu_fg_write(fg, HSYNC(hsync) | HSBP(hsbp) | HSEN, HTCFG2);
+	dpu_fg_write(fg, VACT(vact) | VTOTAL(vtotal), VTCFG1);
+	dpu_fg_write(fg, VSYNC(vsync) | VSBP(vsbp) | VSEN, VTCFG2);
+
+	/* skikconfig */
+	dpu_fg_write(fg, COL(hact - 40) | ROW(vact - 1) | EN, SKICKCONFIG);
+
+	/* primary position config */
+	dpu_fg_write(fg, STARTX(0) | STARTY(0), PACFG);
+
+	/* alpha */
+	val = dpu_fg_read(fg, FGINCTRL);
+	val &= ~(ENPRIMALPHA | ENSECALPHA);
+	dpu_fg_write(fg, val, FGINCTRL);
+
+	val = dpu_fg_read(fg, FGINCTRLPANIC);
+	val &= ~(ENPRIMALPHA | ENSECALPHA);
+	dpu_fg_write(fg, val, FGINCTRLPANIC);
+
+	/* constant color */
+	dpu_fg_write(fg, 0, FGCCR);
+	mutex_unlock(&fg->mutex);
+
+	disp_clock_rate = m->clock * 1000;
+
+	if (devtype->version == DPU_V1) {
+		/* FIXME: why the folders */
+		if (disp_clock_rate > 150000000)
+			pll_clock_rate = disp_clock_rate * 2;
+		else if (disp_clock_rate > 75000000)
+			pll_clock_rate = disp_clock_rate * 4;
+		else
+			pll_clock_rate = disp_clock_rate * 8;
+	} else if (devtype->version == DPU_V2) {
+		/* FIXME: why the hardcoded clock rate */
+		if (disp_clock_rate > 75000000)
+			pll_clock_rate = 1188000000;
+		else
+			pll_clock_rate = disp_clock_rate * 8;
+	}
+
+	clk_set_rate(fg->clk_pll, pll_clock_rate);
+	clk_set_rate(fg->clk_disp, disp_clock_rate);
+}
+EXPORT_SYMBOL_GPL(framegen_cfg_videomode);
+
+void framegen_pkickconfig(struct dpu_framegen *fg, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, PKICKCONFIG);
+	if (enable)
+		val |= EN;
+	else
+		val &= ~EN;
+	dpu_fg_write(fg, val, PKICKCONFIG);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_pkickconfig);
+
+void framegen_sacfg(struct dpu_framegen *fg, unsigned int x, unsigned int y)
+{
+	mutex_lock(&fg->mutex);
+	dpu_fg_write(fg, STARTX(x) | STARTY(y), SACFG);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_sacfg);
+
+void framegen_displaymode(struct dpu_framegen *fg, fgdm_t mode)
+{
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGINCTRL);
+	val &= ~FGDM_MASK;
+	val |= mode;
+	dpu_fg_write(fg, val, FGINCTRL);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_displaymode);
+
+void framegen_panic_displaymode(struct dpu_framegen *fg, fgdm_t mode)
+{
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGINCTRLPANIC);
+	val &= ~FGDM_MASK;
+	val |= mode;
+	dpu_fg_write(fg, val, FGINCTRLPANIC);
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(framegen_panic_displaymode);
+
+void framegen_wait_done(struct dpu_framegen *fg)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(60);
+	u32 val;
+
+	mutex_lock(&fg->mutex);
+	do {
+		val = dpu_fg_read(fg, FGENSTS);
+	} while ((val & ENSTS) && time_before(jiffies, timeout));
+	mutex_unlock(&fg->mutex);
+
+	if (val & ENSTS)
+		dev_err(fg->dpu->dev, "failed to wait for FrameGen%d done\n",
+			fg->id);
+}
+EXPORT_SYMBOL_GPL(framegen_wait_done);
+
+void framegen_enable_clock(struct dpu_framegen *fg)
+{
+	clk_prepare_enable(fg->clk_pll);
+	clk_prepare_enable(fg->clk_disp);
+}
+EXPORT_SYMBOL_GPL(framegen_enable_clock);
+
+void framegen_disable_clock(struct dpu_framegen *fg)
+{
+	clk_disable_unprepare(fg->clk_pll);
+	clk_disable_unprepare(fg->clk_disp);
+}
+EXPORT_SYMBOL_GPL(framegen_disable_clock);
+
+struct dpu_framegen *dpu_fg_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_framegen *fg;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fg_ids); i++)
+		if (fg_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(fg_ids))
+		return ERR_PTR(-EINVAL);
+
+	fg = dpu->fg_priv[i];
+
+	mutex_lock(&fg->mutex);
+
+	if (fg->inuse) {
+		fg = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	fg->inuse = true;
+out:
+	mutex_unlock(&fg->mutex);
+
+	return fg;
+}
+EXPORT_SYMBOL_GPL(dpu_fg_get);
+
+void dpu_fg_put(struct dpu_framegen *fg)
+{
+	mutex_lock(&fg->mutex);
+
+	fg->inuse = false;
+
+	mutex_unlock(&fg->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_fg_put);
+
+int dpu_fg_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long unused, unsigned long base)
+{
+	struct dpu_framegen *fg;
+	u32 val;
+
+	fg = devm_kzalloc(dpu->dev, sizeof(*fg), GFP_KERNEL);
+	if (!fg)
+		return -ENOMEM;
+
+	dpu->fg_priv[id] = fg;
+
+	fg->base = devm_ioremap(dpu->dev, base, SZ_256);
+	if (!fg->base)
+		return -ENOMEM;
+
+	fg->clk_pll = devm_clk_get(dpu->dev, id ? "pll1" : "pll0");
+	if (IS_ERR(fg->clk_pll))
+		return PTR_ERR(fg->clk_pll);
+
+	fg->clk_disp = devm_clk_get(dpu->dev, id ? "disp1" : "disp0");
+	if (IS_ERR(fg->clk_disp))
+		return PTR_ERR(fg->clk_disp);
+
+	fg->dpu = dpu;
+	fg->id = id;
+	mutex_init(&fg->mutex);
+
+	mutex_lock(&fg->mutex);
+	val = dpu_fg_read(fg, FGSTCTRL);
+	val &= ~FGSYNCMODE_MASK;
+	val |= FGSYNCMODE__OFF;
+	dpu_fg_write(fg, val, FGSTCTRL);
+
+	mutex_unlock(&fg->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-layerblend.c b/drivers/gpu/imx/dpu/dpu-layerblend.c
new file mode 100644
index 0000000..ef90ee6
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-layerblend.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define PIXENGCFG_DYNAMIC			0x8
+#define PIXENGCFG_DYNAMIC_PRIM_SEL_MASK		0x3F
+#define PIXENGCFG_DYNAMIC_SEC_SEL_MASK		0x3F00
+#define PIXENGCFG_DYNAMIC_SEC_SEL_SHIFT		8
+
+static const lb_prim_sel_t prim_sels[] = {
+	LB_PRIM_SEL__DISABLE,
+	LB_PRIM_SEL__BLITBLEND9,
+	LB_PRIM_SEL__CONSTFRAME0,
+	LB_PRIM_SEL__CONSTFRAME1,
+	LB_PRIM_SEL__CONSTFRAME4,
+	LB_PRIM_SEL__CONSTFRAME5,
+	LB_PRIM_SEL__MATRIX4,
+	LB_PRIM_SEL__HSCALER4,
+	LB_PRIM_SEL__VSCALER4,
+	LB_PRIM_SEL__EXTSRC4,
+	LB_PRIM_SEL__MATRIX5,
+	LB_PRIM_SEL__HSCALER5,
+	LB_PRIM_SEL__VSCALER5,
+	LB_PRIM_SEL__EXTSRC5,
+	LB_PRIM_SEL__LAYERBLEND0,
+	LB_PRIM_SEL__LAYERBLEND1,
+	LB_PRIM_SEL__LAYERBLEND2,
+	LB_PRIM_SEL__LAYERBLEND3,
+	LB_PRIM_SEL__LAYERBLEND4,
+	LB_PRIM_SEL__LAYERBLEND5,
+};
+
+#define PIXENGCFG_STATUS			0xC
+#define SHDTOKSEL				(0x3 << 3)
+#define SHDTOKSEL_SHIFT				3
+#define SHDLDSEL				(0x3 << 1)
+#define CONTROL					0xC
+#define MODE_MASK				BIT(0)
+#define BLENDCONTROL				0x10
+#define ALPHA(a)				(((a) & 0xFF) << 16)
+#define PRIM_C_BLD_FUNC__ONE_MINUS_SEC_ALPHA	0x5
+#define SEC_C_BLD_FUNC__CONST_ALPHA		(0x6 << 4)
+#define PRIM_A_BLD_FUNC__ONE_MINUS_SEC_ALPHA	(0x5 << 8)
+#define SEC_A_BLD_FUNC__ONE			(0x1 << 12)
+#define POSITION				0x14
+#define XPOS(x)					((x) & 0x7FFF)
+#define YPOS(y)					(((y) & 0x7FFF) << 16)
+#define PRIMCONTROLWORD				0x18
+#define SECCONTROLWORD				0x1C
+
+#define CONTROLWORD				0x18
+#define CURPIXELCNT				0x1C
+static u16 get_xval(u32 pixel_cnt)
+{
+	return pixel_cnt && 0xFF;
+}
+
+static u16 get_yval(u32 pixel_cnt)
+{
+	return pixel_cnt >> 16;
+}
+#define LASTPIXELCNT				0x20
+#define PERFCOUNTER				0x24
+
+struct dpu_layerblend {
+	void __iomem *pec_base;
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_pec_lb_read(struct dpu_layerblend *lb,
+				  unsigned int offset)
+{
+	return readl(lb->pec_base + offset);
+}
+
+static inline void dpu_pec_lb_write(struct dpu_layerblend *lb, u32 value,
+				    unsigned int offset)
+{
+	writel(value, lb->pec_base + offset);
+}
+
+static inline u32 dpu_lb_read(struct dpu_layerblend *lb, unsigned int offset)
+{
+	return readl(lb->base + offset);
+}
+
+static inline void dpu_lb_write(struct dpu_layerblend *lb, u32 value,
+				unsigned int offset)
+{
+	writel(value, lb->base + offset);
+}
+
+int layerblend_pixengcfg_dynamic_prim_sel(struct dpu_layerblend *lb,
+					  lb_prim_sel_t prim)
+{
+	struct dpu_soc *dpu = lb->dpu;
+	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
+	int fixed_sels_num = ARRAY_SIZE(prim_sels) - 6;
+	int i;
+	u32 val, mapped_prim;
+
+	mutex_lock(&lb->mutex);
+	for (i = 0; i < fixed_sels_num + lb->id; i++) {
+		if (prim_sels[i] == prim) {
+			mapped_prim = block_id_map ? block_id_map[prim] : prim;
+			if (WARN_ON(mapped_prim == NA))
+				return -EINVAL;
+
+			val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
+			val &= ~PIXENGCFG_DYNAMIC_PRIM_SEL_MASK;
+			val |= mapped_prim;
+			dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
+			mutex_unlock(&lb->mutex);
+			return 0;
+		}
+	}
+	mutex_unlock(&lb->mutex);
+
+	dev_err(dpu->dev, "Invalid primary source for LayerBlend%d\n", lb->id);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(layerblend_pixengcfg_dynamic_prim_sel);
+
+void layerblend_pixengcfg_dynamic_sec_sel(struct dpu_layerblend *lb,
+					  lb_sec_sel_t sec)
+{
+	struct dpu_soc *dpu = lb->dpu;
+	const unsigned int *block_id_map = dpu->devtype->sw2hw_block_id_map;
+	u32 val, mapped_sec;
+
+	mapped_sec = block_id_map ? block_id_map[sec] : sec;
+	if (WARN_ON(mapped_sec == NA))
+		return;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
+	val &= ~PIXENGCFG_DYNAMIC_SEC_SEL_MASK;
+	val |= mapped_sec << PIXENGCFG_DYNAMIC_SEC_SEL_SHIFT;
+	dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_pixengcfg_dynamic_sec_sel);
+
+void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
+				lb_pixengcfg_clken_t clken)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_pec_lb_read(lb, PIXENGCFG_DYNAMIC);
+	val &= ~CLKEN_MASK;
+	val |= clken << CLKEN_MASK_SHIFT;
+	dpu_pec_lb_write(lb, val, PIXENGCFG_DYNAMIC);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_pixengcfg_clken);
+
+void layerblend_shden(struct dpu_layerblend *lb, bool enable)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, STATICCONTROL);
+	if (enable)
+		val |= SHDEN;
+	else
+		val &= ~SHDEN;
+	dpu_lb_write(lb, val, STATICCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_shden);
+
+void layerblend_shdtoksel(struct dpu_layerblend *lb, lb_shadow_sel_t sel)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, STATICCONTROL);
+	val &= ~SHDTOKSEL;
+	val |= (sel << SHDTOKSEL_SHIFT);
+	dpu_lb_write(lb, val, STATICCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_shdtoksel);
+
+void layerblend_shdldsel(struct dpu_layerblend *lb, lb_shadow_sel_t sel)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, STATICCONTROL);
+	val &= ~SHDLDSEL;
+	val |= sel;
+	dpu_lb_write(lb, val, STATICCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_shdldsel);
+
+void layerblend_control(struct dpu_layerblend *lb, lb_mode_t mode)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, CONTROL);
+	val &= ~MODE_MASK;
+	val |= mode;
+	dpu_lb_write(lb, val, CONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_control);
+
+void layerblend_blendcontrol(struct dpu_layerblend *lb)
+{
+	u32 val;
+
+	val = ALPHA(0xff) |
+	      PRIM_C_BLD_FUNC__ONE_MINUS_SEC_ALPHA |
+	      SEC_C_BLD_FUNC__CONST_ALPHA |
+	      PRIM_A_BLD_FUNC__ONE_MINUS_SEC_ALPHA |
+	      SEC_A_BLD_FUNC__ONE;
+
+	mutex_lock(&lb->mutex);
+	dpu_lb_write(lb, val, BLENDCONTROL);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_blendcontrol);
+
+void layerblend_position(struct dpu_layerblend *lb, int x, int y)
+{
+	mutex_lock(&lb->mutex);
+	dpu_lb_write(lb, XPOS(x) | YPOS(y), POSITION);
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(layerblend_position);
+
+u32 layerblend_last_control_word(struct dpu_layerblend *lb)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, CONTROLWORD);
+	mutex_unlock(&lb->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(layerblend_last_control_word);
+
+void layerblend_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, CURPIXELCNT);
+	mutex_unlock(&lb->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(layerblend_pixel_cnt);
+
+void layerblend_last_pixel_cnt(struct dpu_layerblend *lb, u16 *x, u16 *y)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, LASTPIXELCNT);
+	mutex_unlock(&lb->mutex);
+
+	*x = get_xval(val);
+	*y = get_yval(val);
+}
+EXPORT_SYMBOL_GPL(layerblend_last_pixel_cnt);
+
+u32 layerblend_perfresult(struct dpu_layerblend *lb)
+{
+	u32 val;
+
+	mutex_lock(&lb->mutex);
+	val = dpu_lb_read(lb, PERFCOUNTER);
+	mutex_unlock(&lb->mutex);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(layerblend_perfresult);
+
+struct dpu_layerblend *dpu_lb_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_layerblend *lb;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lb_ids); i++)
+		if (lb_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(lb_ids))
+		return ERR_PTR(-EINVAL);
+
+	lb = dpu->lb_priv[i];
+
+	mutex_lock(&lb->mutex);
+
+	if (lb->inuse) {
+		lb = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	lb->inuse = true;
+out:
+	mutex_unlock(&lb->mutex);
+
+	return lb;
+}
+EXPORT_SYMBOL_GPL(dpu_lb_get);
+
+void dpu_lb_put(struct dpu_layerblend *lb)
+{
+	mutex_lock(&lb->mutex);
+
+	lb->inuse = false;
+
+	mutex_unlock(&lb->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_lb_put);
+
+int dpu_lb_init(struct dpu_soc *dpu, unsigned int id,
+		unsigned long pec_base, unsigned long base)
+{
+	struct dpu_layerblend *lb;
+	int ret;
+
+	lb = devm_kzalloc(dpu->dev, sizeof(*lb), GFP_KERNEL);
+	if (!lb)
+		return -ENOMEM;
+
+	dpu->lb_priv[id] = lb;
+
+	lb->pec_base = devm_ioremap(dpu->dev, pec_base, SZ_16);
+	if (!lb->pec_base)
+		return -ENOMEM;
+
+	lb->base = devm_ioremap(dpu->dev, base, SZ_32);
+	if (!lb->base)
+		return -ENOMEM;
+
+	lb->dpu = dpu;
+	lb->id = id;
+	mutex_init(&lb->mutex);
+
+	ret = layerblend_pixengcfg_dynamic_prim_sel(lb, LB_PRIM_SEL__DISABLE);
+	if (ret < 0)
+		return ret;
+
+	layerblend_pixengcfg_dynamic_sec_sel(lb, LB_SEC_SEL__DISABLE);
+	layerblend_pixengcfg_clken(lb, CLKEN__AUTOMATIC);
+	layerblend_shdldsel(lb, BOTH);
+	layerblend_shdtoksel(lb, BOTH);
+	layerblend_shden(lb, true);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/dpu/dpu-prv.h b/drivers/gpu/imx/dpu/dpu-prv.h
new file mode 100644
index 0000000..957a010
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-prv.h
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#ifndef __DPU_PRV_H__
+#define __DPU_PRV_H__
+
+#include <drm/drm_fourcc.h>
+
+#define NA				0xDEADBEEF	/* not available */
+
+#define STATICCONTROL			0x8
+#define BASEADDRESSAUTOUPDATE(lm)	(((lm) & 0xFF) << 16)
+#define BASEADDRESSAUTOUPDATE_MASK	(0xFF << 16)
+#define SHDEN				BIT(0)
+#define BURSTBUFFERMANAGEMENT		0xC
+#define SETNUMBUFFERS(n)		((n) & 0xFF)
+#define SETBURSTLENGTH(n)		(((n) & 0x1F) << 8)
+#define LINEMODE_MASK			0x80000000U
+#define LINEMODE_SHIFT			31U
+enum linemode {
+	/*
+	 * Mandatory setting for operation in the Display Controller.
+	 * Works also for Blit Engine with marginal performance impact.
+	 */
+	LINEMODE__DISPLAY = 0,
+	/* Recommended setting for operation in the Blit Engine. */
+	LINEMODE__BLIT = 1 << LINEMODE_SHIFT,
+};
+
+#define BITSPERPIXEL(bpp)		(((bpp) & 0x3F) << 16)
+#define STRIDE(n)			(((n) - 1) & 0xFFFF)
+#define LINEWIDTH(w)			(((w) - 1) & 0x3FFF)
+#define LINECOUNT(h)			((((h) - 1) & 0x3FFF) << 16)
+#define ITUFORMAT			BIT(31)
+#define R_BITS(n)			(((n) & 0xF) << 24)
+#define G_BITS(n)			(((n) & 0xF) << 16)
+#define B_BITS(n)			(((n) & 0xF) << 8)
+#define A_BITS(n)			((n) & 0xF)
+#define R_SHIFT(n)			(((n) & 0x1F) << 24)
+#define G_SHIFT(n)			(((n) & 0x1F) << 16)
+#define B_SHIFT(n)			(((n) & 0x1F) << 8)
+#define A_SHIFT(n)			((n) & 0x1F)
+#define LAYERXOFFSET(x)			((x) & 0x7FFF)
+#define LAYERYOFFSET(y)			(((y) & 0x7FFF) << 16)
+#define CLIPWINDOWXOFFSET(x)		((x) & 0x7FFF)
+#define CLIPWINDOWYOFFSET(y)		(((y) & 0x7FFF) << 16)
+#define CLIPWINDOWWIDTH(w)		(((w) - 1) & 0x3FFF)
+#define CLIPWINDOWHEIGHT(h)		((((h) - 1) & 0x3FFF) << 16)
+#define	PALETTEENABLE			BIT(0)
+typedef enum {
+	TILE_FILL_ZERO,
+	TILE_FILL_CONSTANT,
+	TILE_PAD,
+	TILE_PAD_ZERO,
+} tilemode_t;
+#define ALPHASRCENABLE			BIT(8)
+#define ALPHACONSTENABLE		BIT(9)
+#define ALPHAMASKENABLE			BIT(10)
+#define ALPHATRANSENABLE		BIT(11)
+#define RGBALPHASRCENABLE		BIT(12)
+#define RGBALPHACONSTENABLE		BIT(13)
+#define RGBALPHAMASKENABLE		BIT(14)
+#define RGBALPHATRANSENABLE		BIT(15)
+#define PREMULCONSTRGB			BIT(16)
+typedef enum {
+	YUVCONVERSION__OFF,
+	YUVCONVERSION__ITU601,
+	YUVCONVERSION__ITU601_FR,
+	YUVCONVERSION__ITU709,
+} yuvconversion_t;
+#define GAMMAREMOVEENABLE		BIT(20)
+#define CLIPWINDOWENABLE		BIT(30)
+#define SOURCEBUFFERENABLE		BIT(31)
+#define EMPTYFRAME			BIT(31)
+#define FRAMEWIDTH(w)			(((w) - 1) & 0x3FFF)
+#define FRAMEHEIGHT(h)			((((h) - 1) & 0x3FFF) << 16)
+#define SHDTOKGEN			BIT(0)
+#define FETCHTYPE_MASK			0xF
+
+enum {
+	DPU_V1,
+	DPU_V2,
+};
+
+struct dpu_unit {
+	char *name;
+	unsigned int num;
+	const unsigned int *ids;
+	const unsigned long *pec_ofss;	/* PixEngCFG */
+	const unsigned long *ofss;
+};
+
+struct cm_reg_ofs {
+	u32 ipidentifier;
+	u32 lockunlock;
+	u32 lockstatus;
+	u32 userinterruptmask;
+	u32 interruptenable;
+	u32 interruptpreset;
+	u32 interruptclear;
+	u32 interruptstatus;
+	u32 userinterruptenable;
+	u32 userinterruptpreset;
+	u32 userinterruptclear;
+	u32 userinterruptstatus;
+	u32 generalpurpose;
+};
+
+struct dpu_devtype {
+	const unsigned long cm_ofs;	/* common */
+	const struct dpu_unit *cfs;
+	const struct dpu_unit *decs;
+	const struct dpu_unit *eds;
+	const struct dpu_unit *fds;
+	const struct dpu_unit *fgs;
+	const struct dpu_unit *fls;
+	const struct dpu_unit *lbs;
+	const struct dpu_unit *tcons;
+	const struct cm_reg_ofs *cm_reg_ofs;
+	const unsigned int *intsteer_map;
+	const unsigned int intsteer_map_size;
+	const unsigned long *unused_irq;
+	const unsigned int *sw2hw_irq_map;	/* NULL means linear */
+	const unsigned int *sw2hw_block_id_map;	/* NULL means linear */
+	bool has_capture;
+	bool pixel_link_quirks;
+	bool pixel_link_nhvsync;	/* HSYNC and VSYNC high active */
+	unsigned int version;
+};
+
+struct dpu_soc {
+	struct device		*dev;
+	const struct dpu_devtype	*devtype;
+	spinlock_t		lock;
+
+	void __iomem		*cm_reg;
+
+	int			id;
+	int			usecount;
+
+	struct regmap		*intsteer_regmap;
+	int			intsteer_usecount;
+	spinlock_t		intsteer_lock;
+	int			irq_cm;		/* irq common */
+	int			irq_stream0a;
+	int			irq_stream1a;
+	int			irq_reserved0;
+	int			irq_reserved1;
+	int			irq_blit;
+	struct irq_domain	*domain;
+
+	struct dpu_constframe	*cf_priv[4];
+	struct dpu_disengcfg	*dec_priv[2];
+	struct dpu_extdst	*ed_priv[4];
+	struct dpu_fetchdecode	*fd_priv[4];
+	struct dpu_fetchlayer	*fl_priv[2];
+	struct dpu_framegen	*fg_priv[2];
+	struct dpu_layerblend	*lb_priv[7];
+	struct dpu_tcon		*tcon_priv[2];
+};
+
+#define DECLARE_DPU_UNIT_INIT_FUNC(block)			\
+int dpu_##block##_init(struct dpu_soc *dpu, unsigned int id,	\
+			 unsigned long pec_base, unsigned long base)
+
+DECLARE_DPU_UNIT_INIT_FUNC(cf);
+DECLARE_DPU_UNIT_INIT_FUNC(dec);
+DECLARE_DPU_UNIT_INIT_FUNC(ed);
+DECLARE_DPU_UNIT_INIT_FUNC(fd);
+DECLARE_DPU_UNIT_INIT_FUNC(fg);
+DECLARE_DPU_UNIT_INIT_FUNC(fl);
+DECLARE_DPU_UNIT_INIT_FUNC(lb);
+DECLARE_DPU_UNIT_INIT_FUNC(tcon);
+
+static const unsigned int cf_ids[] = {0, 1, 4, 5};
+static const unsigned int dec_ids[] = {0, 1};
+static const unsigned int ed_ids[] = {0, 1, 4, 5};
+static const unsigned int fd_ids[] = {0, 1, 2, 3};
+static const unsigned int fg_ids[] = {0, 1};
+static const unsigned int fl_ids[] = {0, 1};
+static const unsigned int lb_ids[] = {0, 1, 2, 3, 4, 5, 6};
+static const unsigned int tcon_ids[] = {0, 1};
+
+struct dpu_pixel_format {
+	u32 pixel_format;
+	u32 bits;
+	u32 shift;
+};
+
+static const struct dpu_pixel_format dpu_pixel_format_matrix[] = {
+	{
+		DRM_FORMAT_XRGB8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(16) | G_SHIFT(8)  | B_SHIFT(0)  | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_XBGR8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(0)  | G_SHIFT(8)  | B_SHIFT(16) | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_RGBX8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(24) | G_SHIFT(16) | B_SHIFT(8)  | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_BGRX8888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(8)  | G_SHIFT(16) | B_SHIFT(24) | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_RGB888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(16) | G_SHIFT(8)  | B_SHIFT(0)  | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_BGR888,
+		R_BITS(8)   | G_BITS(8)   | B_BITS(8)   | A_BITS(0),
+		R_SHIFT(0)  | G_SHIFT(8)  | B_SHIFT(16) | A_SHIFT(0),
+	}, {
+		DRM_FORMAT_RGB565,
+		R_BITS(5)   | G_BITS(6)   | B_BITS(5)   | A_BITS(0),
+		R_SHIFT(11) | G_SHIFT(5)  | B_SHIFT(0)  | A_SHIFT(0),
+	},
+};
+
+#endif				/* __DPU_PRV_H__ */
diff --git a/drivers/gpu/imx/dpu/dpu-tcon.c b/drivers/gpu/imx/dpu/dpu-tcon.c
new file mode 100644
index 0000000..8995e75
--- /dev/null
+++ b/drivers/gpu/imx/dpu/dpu-tcon.c
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <video/dpu.h>
+#include "dpu-prv.h"
+
+#define SSQCNTS			0
+#define SSQCYCLE		0x8
+#define SWRESET			0xC
+#define TCON_CTRL		0x10
+#define BYPASS			BIT(3)
+#define RSDSINVCTRL		0x14
+#define MAPBIT3_0		0x18
+#define MAPBIT7_4		0x1C
+#define MAPBIT11_8		0x20
+#define MAPBIT15_12		0x24
+#define MAPBIT19_16		0x28
+#define MAPBIT23_20		0x2C
+#define MAPBIT27_24		0x30
+#define MAPBIT31_28		0x34
+#define MAPBIT34_32		0x38
+#define MAPBIT3_0_DUAL		0x3C
+#define MAPBIT7_4_DUAL		0x40
+#define MAPBIT11_8_DUAL		0x44
+#define MAPBIT15_12_DUAL	0x48
+#define MAPBIT19_16_DUAL	0x4C
+#define MAPBIT23_20_DUAL	0x50
+#define MAPBIT27_24_DUAL	0x54
+#define MAPBIT31_28_DUAL	0x58
+#define MAPBIT34_32_DUAL	0x5C
+#define SPGPOSON(n)		(0x60 + (n) * 16)
+#define X(n)			(((n) & 0x7FFF) << 16)
+#define Y(n)			((n) & 0x7FFF)
+#define SPGMASKON(n)		(0x64 + (n) * 16)
+#define SPGPOSOFF(n)		(0x68 + (n) * 16)
+#define SPGMASKOFF(n)		(0x6C + (n) * 16)
+#define SMXSIGS(n)		(0x120 + (n) * 8)
+#define SMXFCTTABLE(n)		(0x124 + (n) * 8)
+#define RESET_OVER_UNFERFLOW	0x180
+#define DUAL_DEBUG		0x184
+
+struct dpu_tcon {
+	void __iomem *base;
+	struct mutex mutex;
+	int id;
+	bool inuse;
+	struct dpu_soc *dpu;
+};
+
+static inline u32 dpu_tcon_read(struct dpu_tcon *tcon, unsigned int offset)
+{
+	return readl(tcon->base + offset);
+}
+
+static inline void dpu_tcon_write(struct dpu_tcon *tcon, u32 value,
+				  unsigned int offset)
+{
+	writel(value, tcon->base + offset);
+}
+
+int tcon_set_fmt(struct dpu_tcon *tcon, u32 bus_format)
+{
+	mutex_lock(&tcon->mutex);
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		dpu_tcon_write(tcon, 0x19181716, MAPBIT3_0);
+		dpu_tcon_write(tcon, 0x1d1c1b1a, MAPBIT7_4);
+		dpu_tcon_write(tcon, 0x0f0e0d0c, MAPBIT11_8);
+		dpu_tcon_write(tcon, 0x13121110, MAPBIT15_12);
+		dpu_tcon_write(tcon, 0x05040302, MAPBIT19_16);
+		dpu_tcon_write(tcon, 0x09080706, MAPBIT23_20);
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB888_1X30_PADLO:
+	case MEDIA_BUS_FMT_RGB666_1X30_PADLO:
+		dpu_tcon_write(tcon, 0x17161514, MAPBIT3_0);
+		dpu_tcon_write(tcon, 0x1b1a1918, MAPBIT7_4);
+		dpu_tcon_write(tcon, 0x0b0a1d1c, MAPBIT11_8);
+		dpu_tcon_write(tcon, 0x0f0e0d0c, MAPBIT15_12);
+		dpu_tcon_write(tcon, 0x13121110, MAPBIT19_16);
+		dpu_tcon_write(tcon, 0x03020100, MAPBIT23_20);
+		dpu_tcon_write(tcon, 0x07060504, MAPBIT27_24);
+		dpu_tcon_write(tcon, 0x00000908, MAPBIT31_28);
+		break;
+	default:
+		mutex_unlock(&tcon->mutex);
+		return -EINVAL;
+	}
+	mutex_unlock(&tcon->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tcon_set_fmt);
+
+void tcon_cfg_videomode(struct dpu_tcon *tcon, struct drm_display_mode *m)
+{
+	u32 val;
+
+	mutex_lock(&tcon->mutex);
+	val = dpu_tcon_read(tcon, TCON_CTRL);
+	val &= ~BYPASS;
+	dpu_tcon_write(tcon, val, TCON_CTRL);
+
+	/* dsp_control[0]: hsync */
+	dpu_tcon_write(tcon, X(m->hsync_start), SPGPOSON(0));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKON(0));
+
+	dpu_tcon_write(tcon, X(m->hsync_end), SPGPOSOFF(0));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKOFF(0));
+
+	dpu_tcon_write(tcon, 0x2, SMXSIGS(0));
+	dpu_tcon_write(tcon, 0x1, SMXFCTTABLE(0));
+
+	/* dsp_control[1]: vsync */
+	dpu_tcon_write(tcon, X(m->hsync_end) | Y(m->vsync_start - 1),
+								SPGPOSON(1));
+	dpu_tcon_write(tcon, 0x0, SPGMASKON(1));
+
+	dpu_tcon_write(tcon, X(m->hsync_end) | Y(m->vsync_end - 1),
+								SPGPOSOFF(1));
+	dpu_tcon_write(tcon, 0x0, SPGMASKOFF(1));
+
+	dpu_tcon_write(tcon, 0x3, SMXSIGS(1));
+	dpu_tcon_write(tcon, 0x1, SMXFCTTABLE(1));
+
+	/* dsp_control[2]: data enable */
+	/* horizontal */
+	dpu_tcon_write(tcon, 0x0, SPGPOSON(2));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKON(2));
+
+	dpu_tcon_write(tcon, X(m->hdisplay), SPGPOSOFF(2));
+	dpu_tcon_write(tcon, 0xffff, SPGMASKOFF(2));
+
+	/* vertical */
+	dpu_tcon_write(tcon, 0x0, SPGPOSON(3));
+	dpu_tcon_write(tcon, 0x7fff0000, SPGMASKON(3));
+
+	dpu_tcon_write(tcon, Y(m->vdisplay), SPGPOSOFF(3));
+	dpu_tcon_write(tcon, 0x7fff0000, SPGMASKOFF(3));
+
+	dpu_tcon_write(tcon, 0x2c, SMXSIGS(2));
+	dpu_tcon_write(tcon, 0x8, SMXFCTTABLE(2));
+
+	/* dsp_control[3]: kachuck */
+	dpu_tcon_write(tcon, X(0xa) | Y(m->vdisplay), SPGPOSON(4));
+	dpu_tcon_write(tcon, 0x0, SPGMASKON(4));
+
+	dpu_tcon_write(tcon, X(0x2a) | Y(m->vdisplay), SPGPOSOFF(4));
+	dpu_tcon_write(tcon, 0x0, SPGMASKOFF(4));
+
+	dpu_tcon_write(tcon, 0x6, SMXSIGS(3));
+	dpu_tcon_write(tcon, 0x2, SMXFCTTABLE(3));
+	mutex_unlock(&tcon->mutex);
+}
+EXPORT_SYMBOL_GPL(tcon_cfg_videomode);
+
+struct dpu_tcon *dpu_tcon_get(struct dpu_soc *dpu, int id)
+{
+	struct dpu_tcon *tcon;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tcon_ids); i++)
+		if (tcon_ids[i] == id)
+			break;
+
+	if (i == ARRAY_SIZE(tcon_ids))
+		return ERR_PTR(-EINVAL);
+
+	tcon = dpu->tcon_priv[i];
+
+	mutex_lock(&tcon->mutex);
+
+	if (tcon->inuse) {
+		tcon = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	tcon->inuse = true;
+out:
+	mutex_unlock(&tcon->mutex);
+
+	return tcon;
+}
+EXPORT_SYMBOL_GPL(dpu_tcon_get);
+
+void dpu_tcon_put(struct dpu_tcon *tcon)
+{
+	mutex_lock(&tcon->mutex);
+
+	tcon->inuse = false;
+
+	mutex_unlock(&tcon->mutex);
+}
+EXPORT_SYMBOL_GPL(dpu_tcon_put);
+
+int dpu_tcon_init(struct dpu_soc *dpu, unsigned int id,
+			unsigned long unused, unsigned long base)
+{
+	struct dpu_tcon *tcon;
+
+	tcon = devm_kzalloc(dpu->dev, sizeof(*tcon), GFP_KERNEL);
+	if (!tcon)
+		return -ENOMEM;
+
+	dpu->tcon_priv[id] = tcon;
+
+	tcon->base = devm_ioremap(dpu->dev, base, SZ_512);
+	if (!tcon->base)
+		return -ENOMEM;
+
+	tcon->dpu = dpu;
+	mutex_init(&tcon->mutex);
+
+	return 0;
+}
diff --git a/drivers/gpu/imx/ipu-v3/Kconfig b/drivers/gpu/imx/ipu-v3/Kconfig
new file mode 100644
index 0000000..fe6f8c5
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/Kconfig
@@ -0,0 +1,10 @@
+config IMX_IPUV3_CORE
+	tristate "IPUv3 core support"
+	depends on SOC_IMX5 || SOC_IMX6Q || ARCH_MULTIPLATFORM || COMPILE_TEST
+	depends on DRM || !DRM # if DRM=m, this can't be 'y'
+	select BITREVERSE
+	select GENERIC_ALLOCATOR if DRM
+	select GENERIC_IRQ_CHIP
+	help
+	  Choose this if you have a i.MX5/6 system and want to use the Image
+	  Processing Unit. This option only enables IPU base support.
diff --git a/drivers/gpu/imx/ipu-v3/Makefile b/drivers/gpu/imx/ipu-v3/Makefile
new file mode 100644
index 0000000..7cc8b47
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_IMX_IPUV3_CORE) += imx-ipu-v3.o
+
+imx-ipu-v3-objs := ipu-common.o ipu-cpmem.o ipu-csi.o ipu-dc.o ipu-di.o \
+		ipu-dp.o ipu-dmfc.o ipu-ic.o ipu-image-convert.o \
+		ipu-smfc.o ipu-vdi.o
+
+ifdef CONFIG_DRM
+	imx-ipu-v3-objs += ipu-pre.o ipu-prg.o
+endif
diff --git a/drivers/gpu/imx/ipu-v3/ipu-common.c b/drivers/gpu/imx/ipu-v3/ipu-common.c
new file mode 100644
index 0000000..c73bd00
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-common.c
@@ -0,0 +1,1566 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/module.h>
+#include <linux/export.h>
+#include <linux/types.h>
+#include <linux/reset.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/list.h>
+#include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+
+#include <drm/drm_fourcc.h>
+
+#include <video/imx-ipu-v3.h>
+#include "ipu-prv.h"
+
+static inline u32 ipu_cm_read(struct ipu_soc *ipu, unsigned offset)
+{
+	return readl(ipu->cm_reg + offset);
+}
+
+static inline void ipu_cm_write(struct ipu_soc *ipu, u32 value, unsigned offset)
+{
+	writel(value, ipu->cm_reg + offset);
+}
+
+int ipu_get_num(struct ipu_soc *ipu)
+{
+	return ipu->id;
+}
+EXPORT_SYMBOL_GPL(ipu_get_num);
+
+void ipu_srm_dp_update(struct ipu_soc *ipu, bool sync)
+{
+	u32 val;
+
+	val = ipu_cm_read(ipu, IPU_SRM_PRI2);
+	val &= ~DP_S_SRM_MODE_MASK;
+	val |= sync ? DP_S_SRM_MODE_NEXT_FRAME :
+		      DP_S_SRM_MODE_NOW;
+	ipu_cm_write(ipu, val, IPU_SRM_PRI2);
+}
+EXPORT_SYMBOL_GPL(ipu_srm_dp_update);
+
+enum ipu_color_space ipu_drm_fourcc_to_colorspace(u32 drm_fourcc)
+{
+	switch (drm_fourcc) {
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_RGBA5551:
+	case DRM_FORMAT_BGRA5551:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_ARGB4444:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_RGB565_A8:
+	case DRM_FORMAT_BGR565_A8:
+	case DRM_FORMAT_RGB888_A8:
+	case DRM_FORMAT_BGR888_A8:
+	case DRM_FORMAT_RGBX8888_A8:
+	case DRM_FORMAT_BGRX8888_A8:
+		return IPUV3_COLORSPACE_RGB;
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+	case DRM_FORMAT_YUV444:
+	case DRM_FORMAT_YVU444:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+		return IPUV3_COLORSPACE_YUV;
+	default:
+		return IPUV3_COLORSPACE_UNKNOWN;
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_drm_fourcc_to_colorspace);
+
+enum ipu_color_space ipu_pixelformat_to_colorspace(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+		return IPUV3_COLORSPACE_YUV;
+	case V4L2_PIX_FMT_RGB32:
+	case V4L2_PIX_FMT_BGR32:
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB565:
+		return IPUV3_COLORSPACE_RGB;
+	default:
+		return IPUV3_COLORSPACE_UNKNOWN;
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_pixelformat_to_colorspace);
+
+bool ipu_pixelformat_is_planar(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+		return true;
+	}
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(ipu_pixelformat_is_planar);
+
+enum ipu_color_space ipu_mbus_code_to_colorspace(u32 mbus_code)
+{
+	switch (mbus_code & 0xf000) {
+	case 0x1000:
+		return IPUV3_COLORSPACE_RGB;
+	case 0x2000:
+		return IPUV3_COLORSPACE_YUV;
+	default:
+		return IPUV3_COLORSPACE_UNKNOWN;
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_mbus_code_to_colorspace);
+
+int ipu_stride_to_bytes(u32 pixel_stride, u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+		/*
+		 * for the planar YUV formats, the stride passed to
+		 * cpmem must be the stride in bytes of the Y plane.
+		 * And all the planar YUV formats have an 8-bit
+		 * Y component.
+		 */
+		return (8 * pixel_stride) >> 3;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		return (16 * pixel_stride) >> 3;
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB24:
+		return (24 * pixel_stride) >> 3;
+	case V4L2_PIX_FMT_BGR32:
+	case V4L2_PIX_FMT_RGB32:
+		return (32 * pixel_stride) >> 3;
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(ipu_stride_to_bytes);
+
+int ipu_degrees_to_rot_mode(enum ipu_rotate_mode *mode, int degrees,
+			    bool hflip, bool vflip)
+{
+	u32 r90, vf, hf;
+
+	switch (degrees) {
+	case 0:
+		vf = hf = r90 = 0;
+		break;
+	case 90:
+		vf = hf = 0;
+		r90 = 1;
+		break;
+	case 180:
+		vf = hf = 1;
+		r90 = 0;
+		break;
+	case 270:
+		vf = hf = r90 = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	hf ^= (u32)hflip;
+	vf ^= (u32)vflip;
+
+	*mode = (enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_degrees_to_rot_mode);
+
+int ipu_rot_mode_to_degrees(int *degrees, enum ipu_rotate_mode mode,
+			    bool hflip, bool vflip)
+{
+	u32 r90, vf, hf;
+
+	r90 = ((u32)mode >> 2) & 0x1;
+	hf = ((u32)mode >> 1) & 0x1;
+	vf = ((u32)mode >> 0) & 0x1;
+	hf ^= (u32)hflip;
+	vf ^= (u32)vflip;
+
+	switch ((enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf)) {
+	case IPU_ROTATE_NONE:
+		*degrees = 0;
+		break;
+	case IPU_ROTATE_90_RIGHT:
+		*degrees = 90;
+		break;
+	case IPU_ROTATE_180:
+		*degrees = 180;
+		break;
+	case IPU_ROTATE_90_LEFT:
+		*degrees = 270;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_rot_mode_to_degrees);
+
+struct ipuv3_channel *ipu_idmac_get(struct ipu_soc *ipu, unsigned num)
+{
+	struct ipuv3_channel *channel;
+
+	dev_dbg(ipu->dev, "%s %d\n", __func__, num);
+
+	if (num > 63)
+		return ERR_PTR(-ENODEV);
+
+	mutex_lock(&ipu->channel_lock);
+
+	list_for_each_entry(channel, &ipu->channels, list) {
+		if (channel->num == num) {
+			channel = ERR_PTR(-EBUSY);
+			goto out;
+		}
+	}
+
+	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
+	if (!channel) {
+		channel = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	channel->num = num;
+	channel->ipu = ipu;
+	list_add(&channel->list, &ipu->channels);
+
+out:
+	mutex_unlock(&ipu->channel_lock);
+
+	return channel;
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_get);
+
+void ipu_idmac_put(struct ipuv3_channel *channel)
+{
+	struct ipu_soc *ipu = channel->ipu;
+
+	dev_dbg(ipu->dev, "%s %d\n", __func__, channel->num);
+
+	mutex_lock(&ipu->channel_lock);
+
+	list_del(&channel->list);
+	kfree(channel);
+
+	mutex_unlock(&ipu->channel_lock);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_put);
+
+#define idma_mask(ch)			(1 << ((ch) & 0x1f))
+
+/*
+ * This is an undocumented feature, a write one to a channel bit in
+ * IPU_CHA_CUR_BUF and IPU_CHA_TRIPLE_CUR_BUF will reset the channel's
+ * internal current buffer pointer so that transfers start from buffer
+ * 0 on the next channel enable (that's the theory anyway, the imx6 TRM
+ * only says these are read-only registers). This operation is required
+ * for channel linking to work correctly, for instance video capture
+ * pipelines that carry out image rotations will fail after the first
+ * streaming unless this function is called for each channel before
+ * re-enabling the channels.
+ */
+static void __ipu_idmac_reset_current_buffer(struct ipuv3_channel *channel)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned int chno = channel->num;
+
+	ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_CUR_BUF(chno));
+}
+
+void ipu_idmac_set_double_buffer(struct ipuv3_channel *channel,
+		bool doublebuffer)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));
+	if (doublebuffer)
+		reg |= idma_mask(channel->num);
+	else
+		reg &= ~idma_mask(channel->num);
+	ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(channel->num));
+
+	__ipu_idmac_reset_current_buffer(channel);
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_set_double_buffer);
+
+static const struct {
+	int chnum;
+	u32 reg;
+	int shift;
+} idmac_lock_en_info[] = {
+	{ .chnum =  5, .reg = IDMAC_CH_LOCK_EN_1, .shift =  0, },
+	{ .chnum = 11, .reg = IDMAC_CH_LOCK_EN_1, .shift =  2, },
+	{ .chnum = 12, .reg = IDMAC_CH_LOCK_EN_1, .shift =  4, },
+	{ .chnum = 14, .reg = IDMAC_CH_LOCK_EN_1, .shift =  6, },
+	{ .chnum = 15, .reg = IDMAC_CH_LOCK_EN_1, .shift =  8, },
+	{ .chnum = 20, .reg = IDMAC_CH_LOCK_EN_1, .shift = 10, },
+	{ .chnum = 21, .reg = IDMAC_CH_LOCK_EN_1, .shift = 12, },
+	{ .chnum = 22, .reg = IDMAC_CH_LOCK_EN_1, .shift = 14, },
+	{ .chnum = 23, .reg = IDMAC_CH_LOCK_EN_1, .shift = 16, },
+	{ .chnum = 27, .reg = IDMAC_CH_LOCK_EN_1, .shift = 18, },
+	{ .chnum = 28, .reg = IDMAC_CH_LOCK_EN_1, .shift = 20, },
+	{ .chnum = 45, .reg = IDMAC_CH_LOCK_EN_2, .shift =  0, },
+	{ .chnum = 46, .reg = IDMAC_CH_LOCK_EN_2, .shift =  2, },
+	{ .chnum = 47, .reg = IDMAC_CH_LOCK_EN_2, .shift =  4, },
+	{ .chnum = 48, .reg = IDMAC_CH_LOCK_EN_2, .shift =  6, },
+	{ .chnum = 49, .reg = IDMAC_CH_LOCK_EN_2, .shift =  8, },
+	{ .chnum = 50, .reg = IDMAC_CH_LOCK_EN_2, .shift = 10, },
+};
+
+int ipu_idmac_lock_enable(struct ipuv3_channel *channel, int num_bursts)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned long flags;
+	u32 bursts, regval;
+	int i;
+
+	switch (num_bursts) {
+	case 0:
+	case 1:
+		bursts = 0x00; /* locking disabled */
+		break;
+	case 2:
+		bursts = 0x01;
+		break;
+	case 4:
+		bursts = 0x02;
+		break;
+	case 8:
+		bursts = 0x03;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * IPUv3EX / i.MX51 has a different register layout, and on IPUv3M /
+	 * i.MX53 channel arbitration locking doesn't seem to work properly.
+	 * Allow enabling the lock feature on IPUv3H / i.MX6 only.
+	 */
+	if (bursts && ipu->ipu_type != IPUV3H)
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(idmac_lock_en_info); i++) {
+		if (channel->num == idmac_lock_en_info[i].chnum)
+			break;
+	}
+	if (i >= ARRAY_SIZE(idmac_lock_en_info))
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	regval = ipu_idmac_read(ipu, idmac_lock_en_info[i].reg);
+	regval &= ~(0x03 << idmac_lock_en_info[i].shift);
+	regval |= (bursts << idmac_lock_en_info[i].shift);
+	ipu_idmac_write(ipu, regval, idmac_lock_en_info[i].reg);
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_lock_enable);
+
+int ipu_module_enable(struct ipu_soc *ipu, u32 mask)
+{
+	unsigned long lock_flags;
+	u32 val;
+
+	spin_lock_irqsave(&ipu->lock, lock_flags);
+
+	val = ipu_cm_read(ipu, IPU_DISP_GEN);
+
+	if (mask & IPU_CONF_DI0_EN)
+		val |= IPU_DI0_COUNTER_RELEASE;
+	if (mask & IPU_CONF_DI1_EN)
+		val |= IPU_DI1_COUNTER_RELEASE;
+
+	ipu_cm_write(ipu, val, IPU_DISP_GEN);
+
+	val = ipu_cm_read(ipu, IPU_CONF);
+	val |= mask;
+	ipu_cm_write(ipu, val, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu->lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_module_enable);
+
+int ipu_module_disable(struct ipu_soc *ipu, u32 mask)
+{
+	unsigned long lock_flags;
+	u32 val;
+
+	spin_lock_irqsave(&ipu->lock, lock_flags);
+
+	val = ipu_cm_read(ipu, IPU_CONF);
+	val &= ~mask;
+	ipu_cm_write(ipu, val, IPU_CONF);
+
+	val = ipu_cm_read(ipu, IPU_DISP_GEN);
+
+	if (mask & IPU_CONF_DI0_EN)
+		val &= ~IPU_DI0_COUNTER_RELEASE;
+	if (mask & IPU_CONF_DI1_EN)
+		val &= ~IPU_DI1_COUNTER_RELEASE;
+
+	ipu_cm_write(ipu, val, IPU_DISP_GEN);
+
+	spin_unlock_irqrestore(&ipu->lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_module_disable);
+
+int ipu_idmac_get_current_buffer(struct ipuv3_channel *channel)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned int chno = channel->num;
+
+	return (ipu_cm_read(ipu, IPU_CHA_CUR_BUF(chno)) & idma_mask(chno)) ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_get_current_buffer);
+
+bool ipu_idmac_buffer_is_ready(struct ipuv3_channel *channel, u32 buf_num)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned long flags;
+	u32 reg = 0;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+	switch (buf_num) {
+	case 0:
+		reg = ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num));
+		break;
+	case 1:
+		reg = ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num));
+		break;
+	case 2:
+		reg = ipu_cm_read(ipu, IPU_CHA_BUF2_RDY(channel->num));
+		break;
+	}
+	spin_unlock_irqrestore(&ipu->lock, flags);
+
+	return ((reg & idma_mask(channel->num)) != 0);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_buffer_is_ready);
+
+void ipu_idmac_select_buffer(struct ipuv3_channel *channel, u32 buf_num)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned int chno = channel->num;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	/* Mark buffer as ready. */
+	if (buf_num == 0)
+		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));
+	else
+		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_select_buffer);
+
+void ipu_idmac_clear_buffer(struct ipuv3_channel *channel, u32 buf_num)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned int chno = channel->num;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	ipu_cm_write(ipu, 0xF0300000, IPU_GPR); /* write one to clear */
+	switch (buf_num) {
+	case 0:
+		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));
+		break;
+	case 1:
+		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));
+		break;
+	case 2:
+		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF2_RDY(chno));
+		break;
+	default:
+		break;
+	}
+	ipu_cm_write(ipu, 0x0, IPU_GPR); /* write one to set */
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_clear_buffer);
+
+int ipu_idmac_enable_channel(struct ipuv3_channel *channel)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	u32 val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	val = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));
+	val |= idma_mask(channel->num);
+	ipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_enable_channel);
+
+bool ipu_idmac_channel_busy(struct ipu_soc *ipu, unsigned int chno)
+{
+	return (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(chno)) & idma_mask(chno));
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_channel_busy);
+
+int ipu_idmac_wait_busy(struct ipuv3_channel *channel, int ms)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(ms);
+	while (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(channel->num)) &
+			idma_mask(channel->num)) {
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		cpu_relax();
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_wait_busy);
+
+int ipu_idmac_disable_channel(struct ipuv3_channel *channel)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	u32 val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	/* Disable DMA channel(s) */
+	val = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));
+	val &= ~idma_mask(channel->num);
+	ipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));
+
+	__ipu_idmac_reset_current_buffer(channel);
+
+	/* Set channel buffers NOT to be ready */
+	ipu_cm_write(ipu, 0xf0000000, IPU_GPR); /* write one to clear */
+
+	if (ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num)) &
+			idma_mask(channel->num)) {
+		ipu_cm_write(ipu, idma_mask(channel->num),
+			     IPU_CHA_BUF0_RDY(channel->num));
+	}
+
+	if (ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num)) &
+			idma_mask(channel->num)) {
+		ipu_cm_write(ipu, idma_mask(channel->num),
+			     IPU_CHA_BUF1_RDY(channel->num));
+	}
+
+	ipu_cm_write(ipu, 0x0, IPU_GPR); /* write one to set */
+
+	/* Reset the double buffer */
+	val = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));
+	val &= ~idma_mask(channel->num);
+	ipu_cm_write(ipu, val, IPU_CHA_DB_MODE_SEL(channel->num));
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_disable_channel);
+
+/*
+ * The imx6 rev. D TRM says that enabling the WM feature will increase
+ * a channel's priority. Refer to Table 36-8 Calculated priority value.
+ * The sub-module that is the sink or source for the channel must enable
+ * watermark signal for this to take effect (SMFC_WM for instance).
+ */
+void ipu_idmac_enable_watermark(struct ipuv3_channel *channel, bool enable)
+{
+	struct ipu_soc *ipu = channel->ipu;
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	val = ipu_idmac_read(ipu, IDMAC_WM_EN(channel->num));
+	if (enable)
+		val |= 1 << (channel->num % 32);
+	else
+		val &= ~(1 << (channel->num % 32));
+	ipu_idmac_write(ipu, val, IDMAC_WM_EN(channel->num));
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_enable_watermark);
+
+static int ipu_memory_reset(struct ipu_soc *ipu)
+{
+	unsigned long timeout;
+
+	ipu_cm_write(ipu, 0x807FFFFF, IPU_MEM_RST);
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+	while (ipu_cm_read(ipu, IPU_MEM_RST) & 0x80000000) {
+		if (time_after(jiffies, timeout))
+			return -ETIME;
+		cpu_relax();
+	}
+
+	return 0;
+}
+
+/*
+ * Set the source mux for the given CSI. Selects either parallel or
+ * MIPI CSI2 sources.
+ */
+void ipu_set_csi_src_mux(struct ipu_soc *ipu, int csi_id, bool mipi_csi2)
+{
+	unsigned long flags;
+	u32 val, mask;
+
+	mask = (csi_id == 1) ? IPU_CONF_CSI1_DATA_SOURCE :
+		IPU_CONF_CSI0_DATA_SOURCE;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	val = ipu_cm_read(ipu, IPU_CONF);
+	if (mipi_csi2)
+		val |= mask;
+	else
+		val &= ~mask;
+	ipu_cm_write(ipu, val, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_set_csi_src_mux);
+
+/*
+ * Set the source mux for the IC. Selects either CSI[01] or the VDI.
+ */
+void ipu_set_ic_src_mux(struct ipu_soc *ipu, int csi_id, bool vdi)
+{
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	val = ipu_cm_read(ipu, IPU_CONF);
+	if (vdi)
+		val |= IPU_CONF_IC_INPUT;
+	else
+		val &= ~IPU_CONF_IC_INPUT;
+
+	if (csi_id == 1)
+		val |= IPU_CONF_CSI_SEL;
+	else
+		val &= ~IPU_CONF_CSI_SEL;
+
+	ipu_cm_write(ipu, val, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_set_ic_src_mux);
+
+
+/* Frame Synchronization Unit Channel Linking */
+
+struct fsu_link_reg_info {
+	int chno;
+	u32 reg;
+	u32 mask;
+	u32 val;
+};
+
+struct fsu_link_info {
+	struct fsu_link_reg_info src;
+	struct fsu_link_reg_info sink;
+};
+
+static const struct fsu_link_info fsu_link_info[] = {
+	{
+		.src  = { IPUV3_CHANNEL_IC_PRP_ENC_MEM, IPU_FS_PROC_FLOW2,
+			  FS_PRP_ENC_DEST_SEL_MASK, FS_PRP_ENC_DEST_SEL_IRT_ENC },
+		.sink = { IPUV3_CHANNEL_MEM_ROT_ENC, IPU_FS_PROC_FLOW1,
+			  FS_PRPENC_ROT_SRC_SEL_MASK, FS_PRPENC_ROT_SRC_SEL_ENC },
+	}, {
+		.src =  { IPUV3_CHANNEL_IC_PRP_VF_MEM, IPU_FS_PROC_FLOW2,
+			  FS_PRPVF_DEST_SEL_MASK, FS_PRPVF_DEST_SEL_IRT_VF },
+		.sink = { IPUV3_CHANNEL_MEM_ROT_VF, IPU_FS_PROC_FLOW1,
+			  FS_PRPVF_ROT_SRC_SEL_MASK, FS_PRPVF_ROT_SRC_SEL_VF },
+	}, {
+		.src =  { IPUV3_CHANNEL_IC_PP_MEM, IPU_FS_PROC_FLOW2,
+			  FS_PP_DEST_SEL_MASK, FS_PP_DEST_SEL_IRT_PP },
+		.sink = { IPUV3_CHANNEL_MEM_ROT_PP, IPU_FS_PROC_FLOW1,
+			  FS_PP_ROT_SRC_SEL_MASK, FS_PP_ROT_SRC_SEL_PP },
+	}, {
+		.src =  { IPUV3_CHANNEL_CSI_DIRECT, 0 },
+		.sink = { IPUV3_CHANNEL_CSI_VDI_PREV, IPU_FS_PROC_FLOW1,
+			  FS_VDI_SRC_SEL_MASK, FS_VDI_SRC_SEL_CSI_DIRECT },
+	},
+};
+
+static const struct fsu_link_info *find_fsu_link_info(int src, int sink)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fsu_link_info); i++) {
+		if (src == fsu_link_info[i].src.chno &&
+		    sink == fsu_link_info[i].sink.chno)
+			return &fsu_link_info[i];
+	}
+
+	return NULL;
+}
+
+/*
+ * Links a source channel to a sink channel in the FSU.
+ */
+int ipu_fsu_link(struct ipu_soc *ipu, int src_ch, int sink_ch)
+{
+	const struct fsu_link_info *link;
+	u32 src_reg, sink_reg;
+	unsigned long flags;
+
+	link = find_fsu_link_info(src_ch, sink_ch);
+	if (!link)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	if (link->src.mask) {
+		src_reg = ipu_cm_read(ipu, link->src.reg);
+		src_reg &= ~link->src.mask;
+		src_reg |= link->src.val;
+		ipu_cm_write(ipu, src_reg, link->src.reg);
+	}
+
+	if (link->sink.mask) {
+		sink_reg = ipu_cm_read(ipu, link->sink.reg);
+		sink_reg &= ~link->sink.mask;
+		sink_reg |= link->sink.val;
+		ipu_cm_write(ipu, sink_reg, link->sink.reg);
+	}
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_fsu_link);
+
+/*
+ * Unlinks source and sink channels in the FSU.
+ */
+int ipu_fsu_unlink(struct ipu_soc *ipu, int src_ch, int sink_ch)
+{
+	const struct fsu_link_info *link;
+	u32 src_reg, sink_reg;
+	unsigned long flags;
+
+	link = find_fsu_link_info(src_ch, sink_ch);
+	if (!link)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu->lock, flags);
+
+	if (link->src.mask) {
+		src_reg = ipu_cm_read(ipu, link->src.reg);
+		src_reg &= ~link->src.mask;
+		ipu_cm_write(ipu, src_reg, link->src.reg);
+	}
+
+	if (link->sink.mask) {
+		sink_reg = ipu_cm_read(ipu, link->sink.reg);
+		sink_reg &= ~link->sink.mask;
+		ipu_cm_write(ipu, sink_reg, link->sink.reg);
+	}
+
+	spin_unlock_irqrestore(&ipu->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_fsu_unlink);
+
+/* Link IDMAC channels in the FSU */
+int ipu_idmac_link(struct ipuv3_channel *src, struct ipuv3_channel *sink)
+{
+	return ipu_fsu_link(src->ipu, src->num, sink->num);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_link);
+
+/* Unlink IDMAC channels in the FSU */
+int ipu_idmac_unlink(struct ipuv3_channel *src, struct ipuv3_channel *sink)
+{
+	return ipu_fsu_unlink(src->ipu, src->num, sink->num);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_unlink);
+
+struct ipu_devtype {
+	const char *name;
+	unsigned long cm_ofs;
+	unsigned long cpmem_ofs;
+	unsigned long srm_ofs;
+	unsigned long tpm_ofs;
+	unsigned long csi0_ofs;
+	unsigned long csi1_ofs;
+	unsigned long ic_ofs;
+	unsigned long disp0_ofs;
+	unsigned long disp1_ofs;
+	unsigned long dc_tmpl_ofs;
+	unsigned long vdi_ofs;
+	enum ipuv3_type type;
+};
+
+static struct ipu_devtype ipu_type_imx51 = {
+	.name = "IPUv3EX",
+	.cm_ofs = 0x1e000000,
+	.cpmem_ofs = 0x1f000000,
+	.srm_ofs = 0x1f040000,
+	.tpm_ofs = 0x1f060000,
+	.csi0_ofs = 0x1f030000,
+	.csi1_ofs = 0x1f038000,
+	.ic_ofs = 0x1e020000,
+	.disp0_ofs = 0x1e040000,
+	.disp1_ofs = 0x1e048000,
+	.dc_tmpl_ofs = 0x1f080000,
+	.vdi_ofs = 0x1e068000,
+	.type = IPUV3EX,
+};
+
+static struct ipu_devtype ipu_type_imx53 = {
+	.name = "IPUv3M",
+	.cm_ofs = 0x06000000,
+	.cpmem_ofs = 0x07000000,
+	.srm_ofs = 0x07040000,
+	.tpm_ofs = 0x07060000,
+	.csi0_ofs = 0x07030000,
+	.csi1_ofs = 0x07038000,
+	.ic_ofs = 0x06020000,
+	.disp0_ofs = 0x06040000,
+	.disp1_ofs = 0x06048000,
+	.dc_tmpl_ofs = 0x07080000,
+	.vdi_ofs = 0x06068000,
+	.type = IPUV3M,
+};
+
+static struct ipu_devtype ipu_type_imx6q = {
+	.name = "IPUv3H",
+	.cm_ofs = 0x00200000,
+	.cpmem_ofs = 0x00300000,
+	.srm_ofs = 0x00340000,
+	.tpm_ofs = 0x00360000,
+	.csi0_ofs = 0x00230000,
+	.csi1_ofs = 0x00238000,
+	.ic_ofs = 0x00220000,
+	.disp0_ofs = 0x00240000,
+	.disp1_ofs = 0x00248000,
+	.dc_tmpl_ofs = 0x00380000,
+	.vdi_ofs = 0x00268000,
+	.type = IPUV3H,
+};
+
+static const struct of_device_id imx_ipu_dt_ids[] = {
+	{ .compatible = "fsl,imx51-ipu", .data = &ipu_type_imx51, },
+	{ .compatible = "fsl,imx53-ipu", .data = &ipu_type_imx53, },
+	{ .compatible = "fsl,imx6q-ipu", .data = &ipu_type_imx6q, },
+	{ .compatible = "fsl,imx6qp-ipu", .data = &ipu_type_imx6q, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_ipu_dt_ids);
+
+static int ipu_submodules_init(struct ipu_soc *ipu,
+		struct platform_device *pdev, unsigned long ipu_base,
+		struct clk *ipu_clk)
+{
+	char *unit;
+	int ret;
+	struct device *dev = &pdev->dev;
+	const struct ipu_devtype *devtype = ipu->devtype;
+
+	ret = ipu_cpmem_init(ipu, dev, ipu_base + devtype->cpmem_ofs);
+	if (ret) {
+		unit = "cpmem";
+		goto err_cpmem;
+	}
+
+	ret = ipu_csi_init(ipu, dev, 0, ipu_base + devtype->csi0_ofs,
+			   IPU_CONF_CSI0_EN, ipu_clk);
+	if (ret) {
+		unit = "csi0";
+		goto err_csi_0;
+	}
+
+	ret = ipu_csi_init(ipu, dev, 1, ipu_base + devtype->csi1_ofs,
+			   IPU_CONF_CSI1_EN, ipu_clk);
+	if (ret) {
+		unit = "csi1";
+		goto err_csi_1;
+	}
+
+	ret = ipu_ic_init(ipu, dev,
+			  ipu_base + devtype->ic_ofs,
+			  ipu_base + devtype->tpm_ofs);
+	if (ret) {
+		unit = "ic";
+		goto err_ic;
+	}
+
+	ret = ipu_vdi_init(ipu, dev, ipu_base + devtype->vdi_ofs,
+			   IPU_CONF_VDI_EN | IPU_CONF_ISP_EN |
+			   IPU_CONF_IC_INPUT);
+	if (ret) {
+		unit = "vdi";
+		goto err_vdi;
+	}
+
+	ret = ipu_image_convert_init(ipu, dev);
+	if (ret) {
+		unit = "image_convert";
+		goto err_image_convert;
+	}
+
+	ret = ipu_di_init(ipu, dev, 0, ipu_base + devtype->disp0_ofs,
+			  IPU_CONF_DI0_EN, ipu_clk);
+	if (ret) {
+		unit = "di0";
+		goto err_di_0;
+	}
+
+	ret = ipu_di_init(ipu, dev, 1, ipu_base + devtype->disp1_ofs,
+			IPU_CONF_DI1_EN, ipu_clk);
+	if (ret) {
+		unit = "di1";
+		goto err_di_1;
+	}
+
+	ret = ipu_dc_init(ipu, dev, ipu_base + devtype->cm_ofs +
+			IPU_CM_DC_REG_OFS, ipu_base + devtype->dc_tmpl_ofs);
+	if (ret) {
+		unit = "dc_template";
+		goto err_dc;
+	}
+
+	ret = ipu_dmfc_init(ipu, dev, ipu_base +
+			devtype->cm_ofs + IPU_CM_DMFC_REG_OFS, ipu_clk);
+	if (ret) {
+		unit = "dmfc";
+		goto err_dmfc;
+	}
+
+	ret = ipu_dp_init(ipu, dev, ipu_base + devtype->srm_ofs);
+	if (ret) {
+		unit = "dp";
+		goto err_dp;
+	}
+
+	ret = ipu_smfc_init(ipu, dev, ipu_base +
+			devtype->cm_ofs + IPU_CM_SMFC_REG_OFS);
+	if (ret) {
+		unit = "smfc";
+		goto err_smfc;
+	}
+
+	return 0;
+
+err_smfc:
+	ipu_dp_exit(ipu);
+err_dp:
+	ipu_dmfc_exit(ipu);
+err_dmfc:
+	ipu_dc_exit(ipu);
+err_dc:
+	ipu_di_exit(ipu, 1);
+err_di_1:
+	ipu_di_exit(ipu, 0);
+err_di_0:
+	ipu_image_convert_exit(ipu);
+err_image_convert:
+	ipu_vdi_exit(ipu);
+err_vdi:
+	ipu_ic_exit(ipu);
+err_ic:
+	ipu_csi_exit(ipu, 1);
+err_csi_1:
+	ipu_csi_exit(ipu, 0);
+err_csi_0:
+	ipu_cpmem_exit(ipu);
+err_cpmem:
+	dev_err(&pdev->dev, "init %s failed with %d\n", unit, ret);
+	return ret;
+}
+
+static void ipu_irq_handle(struct ipu_soc *ipu, const int *regs, int num_regs)
+{
+	unsigned long status;
+	int i, bit, irq;
+
+	for (i = 0; i < num_regs; i++) {
+
+		status = ipu_cm_read(ipu, IPU_INT_STAT(regs[i]));
+		status &= ipu_cm_read(ipu, IPU_INT_CTRL(regs[i]));
+
+		for_each_set_bit(bit, &status, 32) {
+			irq = irq_linear_revmap(ipu->domain,
+						regs[i] * 32 + bit);
+			if (irq)
+				generic_handle_irq(irq);
+		}
+	}
+}
+
+static void ipu_irq_handler(struct irq_desc *desc)
+{
+	struct ipu_soc *ipu = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	static const int int_reg[] = { 0, 1, 2, 3, 10, 11, 12, 13, 14};
+
+	chained_irq_enter(chip, desc);
+
+	ipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));
+
+	chained_irq_exit(chip, desc);
+}
+
+static void ipu_err_irq_handler(struct irq_desc *desc)
+{
+	struct ipu_soc *ipu = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	static const int int_reg[] = { 4, 5, 8, 9};
+
+	chained_irq_enter(chip, desc);
+
+	ipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));
+
+	chained_irq_exit(chip, desc);
+}
+
+int ipu_map_irq(struct ipu_soc *ipu, int irq)
+{
+	int virq;
+
+	virq = irq_linear_revmap(ipu->domain, irq);
+	if (!virq)
+		virq = irq_create_mapping(ipu->domain, irq);
+
+	return virq;
+}
+EXPORT_SYMBOL_GPL(ipu_map_irq);
+
+int ipu_idmac_channel_irq(struct ipu_soc *ipu, struct ipuv3_channel *channel,
+		enum ipu_channel_irq irq_type)
+{
+	return ipu_map_irq(ipu, irq_type + channel->num);
+}
+EXPORT_SYMBOL_GPL(ipu_idmac_channel_irq);
+
+static void ipu_submodules_exit(struct ipu_soc *ipu)
+{
+	ipu_smfc_exit(ipu);
+	ipu_dp_exit(ipu);
+	ipu_dmfc_exit(ipu);
+	ipu_dc_exit(ipu);
+	ipu_di_exit(ipu, 1);
+	ipu_di_exit(ipu, 0);
+	ipu_image_convert_exit(ipu);
+	ipu_vdi_exit(ipu);
+	ipu_ic_exit(ipu);
+	ipu_csi_exit(ipu, 1);
+	ipu_csi_exit(ipu, 0);
+	ipu_cpmem_exit(ipu);
+}
+
+static int platform_remove_devices_fn(struct device *dev, void *unused)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
+static void platform_device_unregister_children(struct platform_device *pdev)
+{
+	device_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);
+}
+
+struct ipu_platform_reg {
+	struct ipu_client_platformdata pdata;
+	const char *name;
+};
+
+/* These must be in the order of the corresponding device tree port nodes */
+static struct ipu_platform_reg client_reg[] = {
+	{
+		.pdata = {
+			.csi = 0,
+			.dma[0] = IPUV3_CHANNEL_CSI0,
+			.dma[1] = -EINVAL,
+		},
+		.name = "imx-ipuv3-csi",
+	}, {
+		.pdata = {
+			.csi = 1,
+			.dma[0] = IPUV3_CHANNEL_CSI1,
+			.dma[1] = -EINVAL,
+		},
+		.name = "imx-ipuv3-csi",
+	}, {
+		.pdata = {
+			.di = 0,
+			.dc = 5,
+			.dp = IPU_DP_FLOW_SYNC_BG,
+			.dma[0] = IPUV3_CHANNEL_MEM_BG_SYNC,
+			.dma[1] = IPUV3_CHANNEL_MEM_FG_SYNC,
+		},
+		.name = "imx-ipuv3-crtc",
+	}, {
+		.pdata = {
+			.di = 1,
+			.dc = 1,
+			.dp = -EINVAL,
+			.dma[0] = IPUV3_CHANNEL_MEM_DC_SYNC,
+			.dma[1] = -EINVAL,
+		},
+		.name = "imx-ipuv3-crtc",
+	},
+};
+
+static DEFINE_MUTEX(ipu_client_id_mutex);
+static int ipu_client_id;
+
+static int ipu_add_client_devices(struct ipu_soc *ipu, unsigned long ipu_base)
+{
+	struct device *dev = ipu->dev;
+	unsigned i;
+	int id, ret;
+
+	mutex_lock(&ipu_client_id_mutex);
+	id = ipu_client_id;
+	ipu_client_id += ARRAY_SIZE(client_reg);
+	mutex_unlock(&ipu_client_id_mutex);
+
+	for (i = 0; i < ARRAY_SIZE(client_reg); i++) {
+		struct ipu_platform_reg *reg = &client_reg[i];
+		struct platform_device *pdev;
+		struct device_node *of_node;
+
+		/* Associate subdevice with the corresponding port node */
+		of_node = of_graph_get_port_by_id(dev->of_node, i);
+		if (!of_node) {
+			dev_info(dev,
+				 "no port@%d node in %pOF, not using %s%d\n",
+				 i, dev->of_node,
+				 (i / 2) ? "DI" : "CSI", i % 2);
+			continue;
+		}
+
+		pdev = platform_device_alloc(reg->name, id++);
+		if (!pdev) {
+			ret = -ENOMEM;
+			goto err_register;
+		}
+
+		pdev->dev.parent = dev;
+
+		reg->pdata.of_node = of_node;
+		ret = platform_device_add_data(pdev, &reg->pdata,
+					       sizeof(reg->pdata));
+		if (!ret)
+			ret = platform_device_add(pdev);
+		if (ret) {
+			platform_device_put(pdev);
+			goto err_register;
+		}
+	}
+
+	return 0;
+
+err_register:
+	platform_device_unregister_children(to_platform_device(dev));
+
+	return ret;
+}
+
+
+static int ipu_irq_init(struct ipu_soc *ipu)
+{
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+	unsigned long unused[IPU_NUM_IRQS / 32] = {
+		0x400100d0, 0xffe000fd,
+		0x400100d0, 0xffe000fd,
+		0x400100d0, 0xffe000fd,
+		0x4077ffff, 0xffe7e1fd,
+		0x23fffffe, 0x8880fff0,
+		0xf98fe7d0, 0xfff81fff,
+		0x400100d0, 0xffe000fd,
+		0x00000000,
+	};
+	int ret, i;
+
+	ipu->domain = irq_domain_add_linear(ipu->dev->of_node, IPU_NUM_IRQS,
+					    &irq_generic_chip_ops, ipu);
+	if (!ipu->domain) {
+		dev_err(ipu->dev, "failed to add irq domain\n");
+		return -ENODEV;
+	}
+
+	ret = irq_alloc_domain_generic_chips(ipu->domain, 32, 1, "IPU",
+					     handle_level_irq, 0, 0, 0);
+	if (ret < 0) {
+		dev_err(ipu->dev, "failed to alloc generic irq chips\n");
+		irq_domain_remove(ipu->domain);
+		return ret;
+	}
+
+	/* Mask and clear all interrupts */
+	for (i = 0; i < IPU_NUM_IRQS; i += 32) {
+		ipu_cm_write(ipu, 0, IPU_INT_CTRL(i / 32));
+		ipu_cm_write(ipu, ~unused[i / 32], IPU_INT_STAT(i / 32));
+	}
+
+	for (i = 0; i < IPU_NUM_IRQS; i += 32) {
+		gc = irq_get_domain_generic_chip(ipu->domain, i);
+		gc->reg_base = ipu->cm_reg;
+		gc->unused = unused[i / 32];
+		ct = gc->chip_types;
+		ct->chip.irq_ack = irq_gc_ack_set_bit;
+		ct->chip.irq_mask = irq_gc_mask_clr_bit;
+		ct->chip.irq_unmask = irq_gc_mask_set_bit;
+		ct->regs.ack = IPU_INT_STAT(i / 32);
+		ct->regs.mask = IPU_INT_CTRL(i / 32);
+	}
+
+	irq_set_chained_handler_and_data(ipu->irq_sync, ipu_irq_handler, ipu);
+	irq_set_chained_handler_and_data(ipu->irq_err, ipu_err_irq_handler,
+					 ipu);
+
+	return 0;
+}
+
+static void ipu_irq_exit(struct ipu_soc *ipu)
+{
+	int i, irq;
+
+	irq_set_chained_handler_and_data(ipu->irq_err, NULL, NULL);
+	irq_set_chained_handler_and_data(ipu->irq_sync, NULL, NULL);
+
+	/* TODO: remove irq_domain_generic_chips */
+
+	for (i = 0; i < IPU_NUM_IRQS; i++) {
+		irq = irq_linear_revmap(ipu->domain, i);
+		if (irq)
+			irq_dispose_mapping(irq);
+	}
+
+	irq_domain_remove(ipu->domain);
+}
+
+void ipu_dump(struct ipu_soc *ipu)
+{
+	int i;
+
+	dev_dbg(ipu->dev, "IPU_CONF = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_CONF));
+	dev_dbg(ipu->dev, "IDMAC_CONF = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_CONF));
+	dev_dbg(ipu->dev, "IDMAC_CHA_EN1 = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_CHA_EN(0)));
+	dev_dbg(ipu->dev, "IDMAC_CHA_EN2 = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_CHA_EN(32)));
+	dev_dbg(ipu->dev, "IDMAC_CHA_PRI1 = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_CHA_PRI(0)));
+	dev_dbg(ipu->dev, "IDMAC_CHA_PRI2 = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_CHA_PRI(32)));
+	dev_dbg(ipu->dev, "IDMAC_BAND_EN1 = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_BAND_EN(0)));
+	dev_dbg(ipu->dev, "IDMAC_BAND_EN2 = \t0x%08X\n",
+		ipu_idmac_read(ipu, IDMAC_BAND_EN(32)));
+	dev_dbg(ipu->dev, "IPU_CHA_DB_MODE_SEL0 = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(0)));
+	dev_dbg(ipu->dev, "IPU_CHA_DB_MODE_SEL1 = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(32)));
+	dev_dbg(ipu->dev, "IPU_FS_PROC_FLOW1 = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_FS_PROC_FLOW1));
+	dev_dbg(ipu->dev, "IPU_FS_PROC_FLOW2 = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_FS_PROC_FLOW2));
+	dev_dbg(ipu->dev, "IPU_FS_PROC_FLOW3 = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_FS_PROC_FLOW3));
+	dev_dbg(ipu->dev, "IPU_FS_DISP_FLOW1 = \t0x%08X\n",
+		ipu_cm_read(ipu, IPU_FS_DISP_FLOW1));
+	for (i = 0; i < 15; i++)
+		dev_dbg(ipu->dev, "IPU_INT_CTRL(%d) = \t%08X\n", i,
+			ipu_cm_read(ipu, IPU_INT_CTRL(i)));
+}
+EXPORT_SYMBOL_GPL(ipu_dump);
+
+static int ipu_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct ipu_soc *ipu;
+	struct resource *res;
+	unsigned long ipu_base;
+	int ret, irq_sync, irq_err;
+	const struct ipu_devtype *devtype;
+
+	devtype = of_device_get_match_data(&pdev->dev);
+	if (!devtype)
+		return -EINVAL;
+
+	irq_sync = platform_get_irq(pdev, 0);
+	irq_err = platform_get_irq(pdev, 1);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	dev_dbg(&pdev->dev, "irq_sync: %d irq_err: %d\n",
+			irq_sync, irq_err);
+
+	if (!res || irq_sync < 0 || irq_err < 0)
+		return -ENODEV;
+
+	ipu_base = res->start;
+
+	ipu = devm_kzalloc(&pdev->dev, sizeof(*ipu), GFP_KERNEL);
+	if (!ipu)
+		return -ENODEV;
+
+	ipu->id = of_alias_get_id(np, "ipu");
+	if (ipu->id < 0)
+		ipu->id = 0;
+
+	if (of_device_is_compatible(np, "fsl,imx6qp-ipu") &&
+	    IS_ENABLED(CONFIG_DRM)) {
+		ipu->prg_priv = ipu_prg_lookup_by_phandle(&pdev->dev,
+							  "fsl,prg", ipu->id);
+		if (!ipu->prg_priv)
+			return -EPROBE_DEFER;
+	}
+
+	ipu->devtype = devtype;
+	ipu->ipu_type = devtype->type;
+
+	spin_lock_init(&ipu->lock);
+	mutex_init(&ipu->channel_lock);
+	INIT_LIST_HEAD(&ipu->channels);
+
+	dev_dbg(&pdev->dev, "cm_reg:   0x%08lx\n",
+			ipu_base + devtype->cm_ofs);
+	dev_dbg(&pdev->dev, "idmac:    0x%08lx\n",
+			ipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS);
+	dev_dbg(&pdev->dev, "cpmem:    0x%08lx\n",
+			ipu_base + devtype->cpmem_ofs);
+	dev_dbg(&pdev->dev, "csi0:    0x%08lx\n",
+			ipu_base + devtype->csi0_ofs);
+	dev_dbg(&pdev->dev, "csi1:    0x%08lx\n",
+			ipu_base + devtype->csi1_ofs);
+	dev_dbg(&pdev->dev, "ic:      0x%08lx\n",
+			ipu_base + devtype->ic_ofs);
+	dev_dbg(&pdev->dev, "disp0:    0x%08lx\n",
+			ipu_base + devtype->disp0_ofs);
+	dev_dbg(&pdev->dev, "disp1:    0x%08lx\n",
+			ipu_base + devtype->disp1_ofs);
+	dev_dbg(&pdev->dev, "srm:      0x%08lx\n",
+			ipu_base + devtype->srm_ofs);
+	dev_dbg(&pdev->dev, "tpm:      0x%08lx\n",
+			ipu_base + devtype->tpm_ofs);
+	dev_dbg(&pdev->dev, "dc:       0x%08lx\n",
+			ipu_base + devtype->cm_ofs + IPU_CM_DC_REG_OFS);
+	dev_dbg(&pdev->dev, "ic:       0x%08lx\n",
+			ipu_base + devtype->cm_ofs + IPU_CM_IC_REG_OFS);
+	dev_dbg(&pdev->dev, "dmfc:     0x%08lx\n",
+			ipu_base + devtype->cm_ofs + IPU_CM_DMFC_REG_OFS);
+	dev_dbg(&pdev->dev, "vdi:      0x%08lx\n",
+			ipu_base + devtype->vdi_ofs);
+
+	ipu->cm_reg = devm_ioremap(&pdev->dev,
+			ipu_base + devtype->cm_ofs, PAGE_SIZE);
+	ipu->idmac_reg = devm_ioremap(&pdev->dev,
+			ipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS,
+			PAGE_SIZE);
+
+	if (!ipu->cm_reg || !ipu->idmac_reg)
+		return -ENOMEM;
+
+	ipu->clk = devm_clk_get(&pdev->dev, "bus");
+	if (IS_ERR(ipu->clk)) {
+		ret = PTR_ERR(ipu->clk);
+		dev_err(&pdev->dev, "clk_get failed with %d", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, ipu);
+
+	ret = clk_prepare_enable(ipu->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "clk_prepare_enable failed: %d\n", ret);
+		return ret;
+	}
+
+	ipu->dev = &pdev->dev;
+	ipu->irq_sync = irq_sync;
+	ipu->irq_err = irq_err;
+
+	ret = device_reset(&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to reset: %d\n", ret);
+		goto out_failed_reset;
+	}
+	ret = ipu_memory_reset(ipu);
+	if (ret)
+		goto out_failed_reset;
+
+	ret = ipu_irq_init(ipu);
+	if (ret)
+		goto out_failed_irq;
+
+	/* Set MCU_T to divide MCU access window into 2 */
+	ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),
+			IPU_DISP_GEN);
+
+	ret = ipu_submodules_init(ipu, pdev, ipu_base, ipu->clk);
+	if (ret)
+		goto failed_submodules_init;
+
+	ret = ipu_add_client_devices(ipu, ipu_base);
+	if (ret) {
+		dev_err(&pdev->dev, "adding client devices failed with %d\n",
+				ret);
+		goto failed_add_clients;
+	}
+
+	dev_info(&pdev->dev, "%s probed\n", devtype->name);
+
+	return 0;
+
+failed_add_clients:
+	ipu_submodules_exit(ipu);
+failed_submodules_init:
+	ipu_irq_exit(ipu);
+out_failed_irq:
+out_failed_reset:
+	clk_disable_unprepare(ipu->clk);
+	return ret;
+}
+
+static int ipu_remove(struct platform_device *pdev)
+{
+	struct ipu_soc *ipu = platform_get_drvdata(pdev);
+
+	platform_device_unregister_children(pdev);
+	ipu_submodules_exit(ipu);
+	ipu_irq_exit(ipu);
+
+	clk_disable_unprepare(ipu->clk);
+
+	return 0;
+}
+
+static struct platform_driver imx_ipu_driver = {
+	.driver = {
+		.name = "imx-ipuv3",
+		.of_match_table = imx_ipu_dt_ids,
+	},
+	.probe = ipu_probe,
+	.remove = ipu_remove,
+};
+
+static struct platform_driver * const drivers[] = {
+#if IS_ENABLED(CONFIG_DRM)
+	&ipu_pre_drv,
+	&ipu_prg_drv,
+#endif
+	&imx_ipu_driver,
+};
+
+static int __init imx_ipu_init(void)
+{
+	return platform_register_drivers(drivers, ARRAY_SIZE(drivers));
+}
+module_init(imx_ipu_init);
+
+static void __exit imx_ipu_exit(void)
+{
+	platform_unregister_drivers(drivers, ARRAY_SIZE(drivers));
+}
+module_exit(imx_ipu_exit);
+
+MODULE_ALIAS("platform:imx-ipuv3");
+MODULE_DESCRIPTION("i.MX IPU v3 driver");
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/imx/ipu-v3/ipu-cpmem.c b/drivers/gpu/imx/ipu-v3/ipu-cpmem.c
new file mode 100644
index 0000000..9f2d9ec
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-cpmem.c
@@ -0,0 +1,903 @@
+/*
+ * Copyright (C) 2012 Mentor Graphics Inc.
+ * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/types.h>
+#include <linux/bitrev.h>
+#include <linux/io.h>
+#include <linux/sizes.h>
+#include <drm/drm_fourcc.h>
+#include "ipu-prv.h"
+
+struct ipu_cpmem_word {
+	u32 data[5];
+	u32 res[3];
+};
+
+struct ipu_ch_param {
+	struct ipu_cpmem_word word[2];
+};
+
+struct ipu_cpmem {
+	struct ipu_ch_param __iomem *base;
+	u32 module;
+	spinlock_t lock;
+	int use_count;
+	struct ipu_soc *ipu;
+};
+
+#define IPU_CPMEM_WORD(word, ofs, size) ((((word) * 160 + (ofs)) << 8) | (size))
+
+#define IPU_FIELD_UBO		IPU_CPMEM_WORD(0, 46, 22)
+#define IPU_FIELD_VBO		IPU_CPMEM_WORD(0, 68, 22)
+#define IPU_FIELD_IOX		IPU_CPMEM_WORD(0, 90, 4)
+#define IPU_FIELD_RDRW		IPU_CPMEM_WORD(0, 94, 1)
+#define IPU_FIELD_SO		IPU_CPMEM_WORD(0, 113, 1)
+#define IPU_FIELD_SLY		IPU_CPMEM_WORD(1, 102, 14)
+#define IPU_FIELD_SLUV		IPU_CPMEM_WORD(1, 128, 14)
+
+#define IPU_FIELD_XV		IPU_CPMEM_WORD(0, 0, 10)
+#define IPU_FIELD_YV		IPU_CPMEM_WORD(0, 10, 9)
+#define IPU_FIELD_XB		IPU_CPMEM_WORD(0, 19, 13)
+#define IPU_FIELD_YB		IPU_CPMEM_WORD(0, 32, 12)
+#define IPU_FIELD_NSB_B		IPU_CPMEM_WORD(0, 44, 1)
+#define IPU_FIELD_CF		IPU_CPMEM_WORD(0, 45, 1)
+#define IPU_FIELD_SX		IPU_CPMEM_WORD(0, 46, 12)
+#define IPU_FIELD_SY		IPU_CPMEM_WORD(0, 58, 11)
+#define IPU_FIELD_NS		IPU_CPMEM_WORD(0, 69, 10)
+#define IPU_FIELD_SDX		IPU_CPMEM_WORD(0, 79, 7)
+#define IPU_FIELD_SM		IPU_CPMEM_WORD(0, 86, 10)
+#define IPU_FIELD_SCC		IPU_CPMEM_WORD(0, 96, 1)
+#define IPU_FIELD_SCE		IPU_CPMEM_WORD(0, 97, 1)
+#define IPU_FIELD_SDY		IPU_CPMEM_WORD(0, 98, 7)
+#define IPU_FIELD_SDRX		IPU_CPMEM_WORD(0, 105, 1)
+#define IPU_FIELD_SDRY		IPU_CPMEM_WORD(0, 106, 1)
+#define IPU_FIELD_BPP		IPU_CPMEM_WORD(0, 107, 3)
+#define IPU_FIELD_DEC_SEL	IPU_CPMEM_WORD(0, 110, 2)
+#define IPU_FIELD_DIM		IPU_CPMEM_WORD(0, 112, 1)
+#define IPU_FIELD_BNDM		IPU_CPMEM_WORD(0, 114, 3)
+#define IPU_FIELD_BM		IPU_CPMEM_WORD(0, 117, 2)
+#define IPU_FIELD_ROT		IPU_CPMEM_WORD(0, 119, 1)
+#define IPU_FIELD_ROT_HF_VF	IPU_CPMEM_WORD(0, 119, 3)
+#define IPU_FIELD_HF		IPU_CPMEM_WORD(0, 120, 1)
+#define IPU_FIELD_VF		IPU_CPMEM_WORD(0, 121, 1)
+#define IPU_FIELD_THE		IPU_CPMEM_WORD(0, 122, 1)
+#define IPU_FIELD_CAP		IPU_CPMEM_WORD(0, 123, 1)
+#define IPU_FIELD_CAE		IPU_CPMEM_WORD(0, 124, 1)
+#define IPU_FIELD_FW		IPU_CPMEM_WORD(0, 125, 13)
+#define IPU_FIELD_FH		IPU_CPMEM_WORD(0, 138, 12)
+#define IPU_FIELD_EBA0		IPU_CPMEM_WORD(1, 0, 29)
+#define IPU_FIELD_EBA1		IPU_CPMEM_WORD(1, 29, 29)
+#define IPU_FIELD_ILO		IPU_CPMEM_WORD(1, 58, 20)
+#define IPU_FIELD_NPB		IPU_CPMEM_WORD(1, 78, 7)
+#define IPU_FIELD_PFS		IPU_CPMEM_WORD(1, 85, 4)
+#define IPU_FIELD_ALU		IPU_CPMEM_WORD(1, 89, 1)
+#define IPU_FIELD_ALBM		IPU_CPMEM_WORD(1, 90, 3)
+#define IPU_FIELD_ID		IPU_CPMEM_WORD(1, 93, 2)
+#define IPU_FIELD_TH		IPU_CPMEM_WORD(1, 95, 7)
+#define IPU_FIELD_SL		IPU_CPMEM_WORD(1, 102, 14)
+#define IPU_FIELD_WID0		IPU_CPMEM_WORD(1, 116, 3)
+#define IPU_FIELD_WID1		IPU_CPMEM_WORD(1, 119, 3)
+#define IPU_FIELD_WID2		IPU_CPMEM_WORD(1, 122, 3)
+#define IPU_FIELD_WID3		IPU_CPMEM_WORD(1, 125, 3)
+#define IPU_FIELD_OFS0		IPU_CPMEM_WORD(1, 128, 5)
+#define IPU_FIELD_OFS1		IPU_CPMEM_WORD(1, 133, 5)
+#define IPU_FIELD_OFS2		IPU_CPMEM_WORD(1, 138, 5)
+#define IPU_FIELD_OFS3		IPU_CPMEM_WORD(1, 143, 5)
+#define IPU_FIELD_SXYS		IPU_CPMEM_WORD(1, 148, 1)
+#define IPU_FIELD_CRE		IPU_CPMEM_WORD(1, 149, 1)
+#define IPU_FIELD_DEC_SEL2	IPU_CPMEM_WORD(1, 150, 1)
+
+static inline struct ipu_ch_param __iomem *
+ipu_get_cpmem(struct ipuv3_channel *ch)
+{
+	struct ipu_cpmem *cpmem = ch->ipu->cpmem_priv;
+
+	return cpmem->base + ch->num;
+}
+
+static void ipu_ch_param_write_field(struct ipuv3_channel *ch, u32 wbs, u32 v)
+{
+	struct ipu_ch_param __iomem *base = ipu_get_cpmem(ch);
+	u32 bit = (wbs >> 8) % 160;
+	u32 size = wbs & 0xff;
+	u32 word = (wbs >> 8) / 160;
+	u32 i = bit / 32;
+	u32 ofs = bit % 32;
+	u32 mask = (1 << size) - 1;
+	u32 val;
+
+	pr_debug("%s %d %d %d\n", __func__, word, bit , size);
+
+	val = readl(&base->word[word].data[i]);
+	val &= ~(mask << ofs);
+	val |= v << ofs;
+	writel(val, &base->word[word].data[i]);
+
+	if ((bit + size - 1) / 32 > i) {
+		val = readl(&base->word[word].data[i + 1]);
+		val &= ~(mask >> (ofs ? (32 - ofs) : 0));
+		val |= v >> (ofs ? (32 - ofs) : 0);
+		writel(val, &base->word[word].data[i + 1]);
+	}
+}
+
+static u32 ipu_ch_param_read_field(struct ipuv3_channel *ch, u32 wbs)
+{
+	struct ipu_ch_param __iomem *base = ipu_get_cpmem(ch);
+	u32 bit = (wbs >> 8) % 160;
+	u32 size = wbs & 0xff;
+	u32 word = (wbs >> 8) / 160;
+	u32 i = bit / 32;
+	u32 ofs = bit % 32;
+	u32 mask = (1 << size) - 1;
+	u32 val = 0;
+
+	pr_debug("%s %d %d %d\n", __func__, word, bit , size);
+
+	val = (readl(&base->word[word].data[i]) >> ofs) & mask;
+
+	if ((bit + size - 1) / 32 > i) {
+		u32 tmp;
+
+		tmp = readl(&base->word[word].data[i + 1]);
+		tmp &= mask >> (ofs ? (32 - ofs) : 0);
+		val |= tmp << (ofs ? (32 - ofs) : 0);
+	}
+
+	return val;
+}
+
+/*
+ * The V4L2 spec defines packed RGB formats in memory byte order, which from
+ * point of view of the IPU corresponds to little-endian words with the first
+ * component in the least significant bits.
+ * The DRM pixel formats and IPU internal representation are ordered the other
+ * way around, with the first named component ordered at the most significant
+ * bits. Further, V4L2 formats are not well defined:
+ *     https://linuxtv.org/downloads/v4l-dvb-apis/packed-rgb.html
+ * We choose the interpretation which matches GStreamer behavior.
+ */
+static int v4l2_pix_fmt_to_drm_fourcc(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_RGB565:
+		/*
+		 * Here we choose the 'corrected' interpretation of RGBP, a
+		 * little-endian 16-bit word with the red component at the most
+		 * significant bits:
+		 * g[2:0]b[4:0] r[4:0]g[5:3] <=> [16:0] R:G:B
+		 */
+		return DRM_FORMAT_RGB565;
+	case V4L2_PIX_FMT_BGR24:
+		/* B G R <=> [24:0] R:G:B */
+		return DRM_FORMAT_RGB888;
+	case V4L2_PIX_FMT_RGB24:
+		/* R G B <=> [24:0] B:G:R */
+		return DRM_FORMAT_BGR888;
+	case V4L2_PIX_FMT_BGR32:
+		/* B G R A <=> [32:0] A:B:G:R */
+		return DRM_FORMAT_XRGB8888;
+	case V4L2_PIX_FMT_RGB32:
+		/* R G B A <=> [32:0] A:B:G:R */
+		return DRM_FORMAT_XBGR8888;
+	case V4L2_PIX_FMT_UYVY:
+		return DRM_FORMAT_UYVY;
+	case V4L2_PIX_FMT_YUYV:
+		return DRM_FORMAT_YUYV;
+	case V4L2_PIX_FMT_YUV420:
+		return DRM_FORMAT_YUV420;
+	case V4L2_PIX_FMT_YUV422P:
+		return DRM_FORMAT_YUV422;
+	case V4L2_PIX_FMT_YVU420:
+		return DRM_FORMAT_YVU420;
+	case V4L2_PIX_FMT_NV12:
+		return DRM_FORMAT_NV12;
+	case V4L2_PIX_FMT_NV16:
+		return DRM_FORMAT_NV16;
+	}
+
+	return -EINVAL;
+}
+
+void ipu_cpmem_zero(struct ipuv3_channel *ch)
+{
+	struct ipu_ch_param __iomem *p = ipu_get_cpmem(ch);
+	void __iomem *base = p;
+	int i;
+
+	for (i = 0; i < sizeof(*p) / sizeof(u32); i++)
+		writel(0, base + i * sizeof(u32));
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_zero);
+
+void ipu_cpmem_set_resolution(struct ipuv3_channel *ch, int xres, int yres)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_FW, xres - 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_FH, yres - 1);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_resolution);
+
+void ipu_cpmem_skip_odd_chroma_rows(struct ipuv3_channel *ch)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_RDRW, 1);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_skip_odd_chroma_rows);
+
+void ipu_cpmem_set_stride(struct ipuv3_channel *ch, int stride)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_SLY, stride - 1);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_stride);
+
+void ipu_cpmem_set_high_priority(struct ipuv3_channel *ch)
+{
+	struct ipu_soc *ipu = ch->ipu;
+	u32 val;
+
+	if (ipu->ipu_type == IPUV3EX)
+		ipu_ch_param_write_field(ch, IPU_FIELD_ID, 1);
+
+	val = ipu_idmac_read(ipu, IDMAC_CHA_PRI(ch->num));
+	val |= 1 << (ch->num % 32);
+	ipu_idmac_write(ipu, val, IDMAC_CHA_PRI(ch->num));
+};
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_high_priority);
+
+void ipu_cpmem_set_buffer(struct ipuv3_channel *ch, int bufnum, dma_addr_t buf)
+{
+	if (bufnum)
+		ipu_ch_param_write_field(ch, IPU_FIELD_EBA1, buf >> 3);
+	else
+		ipu_ch_param_write_field(ch, IPU_FIELD_EBA0, buf >> 3);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_buffer);
+
+void ipu_cpmem_set_uv_offset(struct ipuv3_channel *ch, u32 u_off, u32 v_off)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_UBO, u_off / 8);
+	ipu_ch_param_write_field(ch, IPU_FIELD_VBO, v_off / 8);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_uv_offset);
+
+void ipu_cpmem_interlaced_scan(struct ipuv3_channel *ch, int stride)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_SO, 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_ILO, stride / 8);
+	ipu_ch_param_write_field(ch, IPU_FIELD_SLY, (stride * 2) - 1);
+};
+EXPORT_SYMBOL_GPL(ipu_cpmem_interlaced_scan);
+
+void ipu_cpmem_set_axi_id(struct ipuv3_channel *ch, u32 id)
+{
+	id &= 0x3;
+	ipu_ch_param_write_field(ch, IPU_FIELD_ID, id);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_axi_id);
+
+int ipu_cpmem_get_burstsize(struct ipuv3_channel *ch)
+{
+	return ipu_ch_param_read_field(ch, IPU_FIELD_NPB) + 1;
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_get_burstsize);
+
+void ipu_cpmem_set_burstsize(struct ipuv3_channel *ch, int burstsize)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_NPB, burstsize - 1);
+};
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_burstsize);
+
+void ipu_cpmem_set_block_mode(struct ipuv3_channel *ch)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_BM, 1);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_block_mode);
+
+void ipu_cpmem_set_rotation(struct ipuv3_channel *ch,
+			    enum ipu_rotate_mode rot)
+{
+	u32 temp_rot = bitrev8(rot) >> 5;
+
+	ipu_ch_param_write_field(ch, IPU_FIELD_ROT_HF_VF, temp_rot);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_rotation);
+
+int ipu_cpmem_set_format_rgb(struct ipuv3_channel *ch,
+			     const struct ipu_rgb *rgb)
+{
+	int bpp = 0, npb = 0, ro, go, bo, to;
+
+	ro = rgb->bits_per_pixel - rgb->red.length - rgb->red.offset;
+	go = rgb->bits_per_pixel - rgb->green.length - rgb->green.offset;
+	bo = rgb->bits_per_pixel - rgb->blue.length - rgb->blue.offset;
+	to = rgb->bits_per_pixel - rgb->transp.length - rgb->transp.offset;
+
+	ipu_ch_param_write_field(ch, IPU_FIELD_WID0, rgb->red.length - 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_OFS0, ro);
+	ipu_ch_param_write_field(ch, IPU_FIELD_WID1, rgb->green.length - 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_OFS1, go);
+	ipu_ch_param_write_field(ch, IPU_FIELD_WID2, rgb->blue.length - 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_OFS2, bo);
+
+	if (rgb->transp.length) {
+		ipu_ch_param_write_field(ch, IPU_FIELD_WID3,
+				rgb->transp.length - 1);
+		ipu_ch_param_write_field(ch, IPU_FIELD_OFS3, to);
+	} else {
+		ipu_ch_param_write_field(ch, IPU_FIELD_WID3, 7);
+		ipu_ch_param_write_field(ch, IPU_FIELD_OFS3,
+				rgb->bits_per_pixel);
+	}
+
+	switch (rgb->bits_per_pixel) {
+	case 32:
+		bpp = 0;
+		npb = 15;
+		break;
+	case 24:
+		bpp = 1;
+		npb = 19;
+		break;
+	case 16:
+		bpp = 3;
+		npb = 31;
+		break;
+	case 8:
+		bpp = 5;
+		npb = 63;
+		break;
+	default:
+		return -EINVAL;
+	}
+	ipu_ch_param_write_field(ch, IPU_FIELD_BPP, bpp);
+	ipu_ch_param_write_field(ch, IPU_FIELD_NPB, npb);
+	ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 7); /* rgb mode */
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_format_rgb);
+
+int ipu_cpmem_set_format_passthrough(struct ipuv3_channel *ch, int width)
+{
+	int bpp = 0, npb = 0;
+
+	switch (width) {
+	case 32:
+		bpp = 0;
+		npb = 15;
+		break;
+	case 24:
+		bpp = 1;
+		npb = 19;
+		break;
+	case 16:
+		bpp = 3;
+		npb = 31;
+		break;
+	case 8:
+		bpp = 5;
+		npb = 63;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ipu_ch_param_write_field(ch, IPU_FIELD_BPP, bpp);
+	ipu_ch_param_write_field(ch, IPU_FIELD_NPB, npb);
+	ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 6); /* raw mode */
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_format_passthrough);
+
+void ipu_cpmem_set_yuv_interleaved(struct ipuv3_channel *ch, u32 pixel_format)
+{
+	switch (pixel_format) {
+	case V4L2_PIX_FMT_UYVY:
+		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3); /* bits/pixel */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0xA);/* pix fmt */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);/* burst size */
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3); /* bits/pixel */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0x8);/* pix fmt */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);/* burst size */
+		break;
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_yuv_interleaved);
+
+void ipu_cpmem_set_yuv_planar_full(struct ipuv3_channel *ch,
+				   unsigned int uv_stride,
+				   unsigned int u_offset, unsigned int v_offset)
+{
+	ipu_ch_param_write_field(ch, IPU_FIELD_SLUV, uv_stride - 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_UBO, u_offset / 8);
+	ipu_ch_param_write_field(ch, IPU_FIELD_VBO, v_offset / 8);
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_yuv_planar_full);
+
+static const struct ipu_rgb def_xrgb_32 = {
+	.red	= { .offset = 16, .length = 8, },
+	.green	= { .offset =  8, .length = 8, },
+	.blue	= { .offset =  0, .length = 8, },
+	.transp = { .offset = 24, .length = 8, },
+	.bits_per_pixel = 32,
+};
+
+static const struct ipu_rgb def_xbgr_32 = {
+	.red	= { .offset =  0, .length = 8, },
+	.green	= { .offset =  8, .length = 8, },
+	.blue	= { .offset = 16, .length = 8, },
+	.transp = { .offset = 24, .length = 8, },
+	.bits_per_pixel = 32,
+};
+
+static const struct ipu_rgb def_rgbx_32 = {
+	.red	= { .offset = 24, .length = 8, },
+	.green	= { .offset = 16, .length = 8, },
+	.blue	= { .offset =  8, .length = 8, },
+	.transp = { .offset =  0, .length = 8, },
+	.bits_per_pixel = 32,
+};
+
+static const struct ipu_rgb def_bgrx_32 = {
+	.red	= { .offset =  8, .length = 8, },
+	.green	= { .offset = 16, .length = 8, },
+	.blue	= { .offset = 24, .length = 8, },
+	.transp = { .offset =  0, .length = 8, },
+	.bits_per_pixel = 32,
+};
+
+static const struct ipu_rgb def_rgb_24 = {
+	.red	= { .offset = 16, .length = 8, },
+	.green	= { .offset =  8, .length = 8, },
+	.blue	= { .offset =  0, .length = 8, },
+	.transp = { .offset =  0, .length = 0, },
+	.bits_per_pixel = 24,
+};
+
+static const struct ipu_rgb def_bgr_24 = {
+	.red	= { .offset =  0, .length = 8, },
+	.green	= { .offset =  8, .length = 8, },
+	.blue	= { .offset = 16, .length = 8, },
+	.transp = { .offset =  0, .length = 0, },
+	.bits_per_pixel = 24,
+};
+
+static const struct ipu_rgb def_rgb_16 = {
+	.red	= { .offset = 11, .length = 5, },
+	.green	= { .offset =  5, .length = 6, },
+	.blue	= { .offset =  0, .length = 5, },
+	.transp = { .offset =  0, .length = 0, },
+	.bits_per_pixel = 16,
+};
+
+static const struct ipu_rgb def_bgr_16 = {
+	.red	= { .offset =  0, .length = 5, },
+	.green	= { .offset =  5, .length = 6, },
+	.blue	= { .offset = 11, .length = 5, },
+	.transp = { .offset =  0, .length = 0, },
+	.bits_per_pixel = 16,
+};
+
+static const struct ipu_rgb def_argb_16 = {
+	.red	= { .offset = 10, .length = 5, },
+	.green	= { .offset =  5, .length = 5, },
+	.blue	= { .offset =  0, .length = 5, },
+	.transp = { .offset = 15, .length = 1, },
+	.bits_per_pixel = 16,
+};
+
+static const struct ipu_rgb def_argb_16_4444 = {
+	.red	= { .offset =  8, .length = 4, },
+	.green	= { .offset =  4, .length = 4, },
+	.blue	= { .offset =  0, .length = 4, },
+	.transp = { .offset = 12, .length = 4, },
+	.bits_per_pixel = 16,
+};
+
+static const struct ipu_rgb def_abgr_16 = {
+	.red	= { .offset =  0, .length = 5, },
+	.green	= { .offset =  5, .length = 5, },
+	.blue	= { .offset = 10, .length = 5, },
+	.transp = { .offset = 15, .length = 1, },
+	.bits_per_pixel = 16,
+};
+
+static const struct ipu_rgb def_rgba_16 = {
+	.red	= { .offset = 11, .length = 5, },
+	.green	= { .offset =  6, .length = 5, },
+	.blue	= { .offset =  1, .length = 5, },
+	.transp = { .offset =  0, .length = 1, },
+	.bits_per_pixel = 16,
+};
+
+static const struct ipu_rgb def_bgra_16 = {
+	.red	= { .offset =  1, .length = 5, },
+	.green	= { .offset =  6, .length = 5, },
+	.blue	= { .offset = 11, .length = 5, },
+	.transp = { .offset =  0, .length = 1, },
+	.bits_per_pixel = 16,
+};
+
+#define Y_OFFSET(pix, x, y)	((x) + pix->width * (y))
+#define U_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
+				 (pix->width * (y) / 4) + (x) / 2)
+#define V_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
+				 (pix->width * pix->height / 4) +	\
+				 (pix->width * (y) / 4) + (x) / 2)
+#define U2_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
+				 (pix->width * (y) / 2) + (x) / 2)
+#define V2_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
+				 (pix->width * pix->height / 2) +	\
+				 (pix->width * (y) / 2) + (x) / 2)
+#define UV_OFFSET(pix, x, y)	((pix->width * pix->height) +	\
+				 (pix->width * (y) / 2) + (x))
+#define UV2_OFFSET(pix, x, y)	((pix->width * pix->height) +	\
+				 (pix->width * y) + (x))
+
+#define NUM_ALPHA_CHANNELS	7
+
+/* See Table 37-12. Alpha channels mapping. */
+static int ipu_channel_albm(int ch_num)
+{
+	switch (ch_num) {
+	case IPUV3_CHANNEL_G_MEM_IC_PRP_VF:	return 0;
+	case IPUV3_CHANNEL_G_MEM_IC_PP:		return 1;
+	case IPUV3_CHANNEL_MEM_FG_SYNC:		return 2;
+	case IPUV3_CHANNEL_MEM_FG_ASYNC:	return 3;
+	case IPUV3_CHANNEL_MEM_BG_SYNC:		return 4;
+	case IPUV3_CHANNEL_MEM_BG_ASYNC:	return 5;
+	case IPUV3_CHANNEL_MEM_VDI_PLANE1_COMB: return 6;
+	default:
+		return -EINVAL;
+	}
+}
+
+static void ipu_cpmem_set_separate_alpha(struct ipuv3_channel *ch)
+{
+	struct ipu_soc *ipu = ch->ipu;
+	int albm;
+	u32 val;
+
+	albm = ipu_channel_albm(ch->num);
+	if (albm < 0)
+		return;
+
+	ipu_ch_param_write_field(ch, IPU_FIELD_ALU, 1);
+	ipu_ch_param_write_field(ch, IPU_FIELD_ALBM, albm);
+	ipu_ch_param_write_field(ch, IPU_FIELD_CRE, 1);
+
+	val = ipu_idmac_read(ipu, IDMAC_SEP_ALPHA);
+	val |= BIT(ch->num);
+	ipu_idmac_write(ipu, val, IDMAC_SEP_ALPHA);
+}
+
+int ipu_cpmem_set_fmt(struct ipuv3_channel *ch, u32 drm_fourcc)
+{
+	switch (drm_fourcc) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 2);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 1);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_YUV444:
+	case DRM_FORMAT_YVU444:
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_NV12:
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 4);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_NV16:
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 3);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_UYVY:
+		/* bits/pixel */
+		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3);
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0xA);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_YUYV:
+		/* bits/pixel */
+		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3);
+		/* pix format */
+		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0x8);
+		/* burst size */
+		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
+		break;
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_XBGR8888:
+		ipu_cpmem_set_format_rgb(ch, &def_xbgr_32);
+		break;
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XRGB8888:
+		ipu_cpmem_set_format_rgb(ch, &def_xrgb_32);
+		break;
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_RGBX8888_A8:
+		ipu_cpmem_set_format_rgb(ch, &def_rgbx_32);
+		break;
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_BGRX8888_A8:
+		ipu_cpmem_set_format_rgb(ch, &def_bgrx_32);
+		break;
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_BGR888_A8:
+		ipu_cpmem_set_format_rgb(ch, &def_bgr_24);
+		break;
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_RGB888_A8:
+		ipu_cpmem_set_format_rgb(ch, &def_rgb_24);
+		break;
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_RGB565_A8:
+		ipu_cpmem_set_format_rgb(ch, &def_rgb_16);
+		break;
+	case DRM_FORMAT_BGR565:
+	case DRM_FORMAT_BGR565_A8:
+		ipu_cpmem_set_format_rgb(ch, &def_bgr_16);
+		break;
+	case DRM_FORMAT_ARGB1555:
+		ipu_cpmem_set_format_rgb(ch, &def_argb_16);
+		break;
+	case DRM_FORMAT_ABGR1555:
+		ipu_cpmem_set_format_rgb(ch, &def_abgr_16);
+		break;
+	case DRM_FORMAT_RGBA5551:
+		ipu_cpmem_set_format_rgb(ch, &def_rgba_16);
+		break;
+	case DRM_FORMAT_BGRA5551:
+		ipu_cpmem_set_format_rgb(ch, &def_bgra_16);
+		break;
+	case DRM_FORMAT_ARGB4444:
+		ipu_cpmem_set_format_rgb(ch, &def_argb_16_4444);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (drm_fourcc) {
+	case DRM_FORMAT_RGB565_A8:
+	case DRM_FORMAT_BGR565_A8:
+	case DRM_FORMAT_RGB888_A8:
+	case DRM_FORMAT_BGR888_A8:
+	case DRM_FORMAT_RGBX8888_A8:
+	case DRM_FORMAT_BGRX8888_A8:
+		ipu_ch_param_write_field(ch, IPU_FIELD_WID3, 7);
+		ipu_cpmem_set_separate_alpha(ch);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_fmt);
+
+int ipu_cpmem_set_image(struct ipuv3_channel *ch, struct ipu_image *image)
+{
+	struct v4l2_pix_format *pix = &image->pix;
+	int offset, u_offset, v_offset;
+	int ret = 0;
+
+	pr_debug("%s: resolution: %dx%d stride: %d\n",
+		 __func__, pix->width, pix->height,
+		 pix->bytesperline);
+
+	ipu_cpmem_set_resolution(ch, image->rect.width, image->rect.height);
+	ipu_cpmem_set_stride(ch, pix->bytesperline);
+
+	ipu_cpmem_set_fmt(ch, v4l2_pix_fmt_to_drm_fourcc(pix->pixelformat));
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
+		u_offset = U_OFFSET(pix, image->rect.left,
+				    image->rect.top) - offset;
+		v_offset = V_OFFSET(pix, image->rect.left,
+				    image->rect.top) - offset;
+
+		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline / 2,
+					      u_offset, v_offset);
+		break;
+	case V4L2_PIX_FMT_YVU420:
+		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
+		u_offset = U_OFFSET(pix, image->rect.left,
+				    image->rect.top) - offset;
+		v_offset = V_OFFSET(pix, image->rect.left,
+				    image->rect.top) - offset;
+
+		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline / 2,
+					      v_offset, u_offset);
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
+		u_offset = U2_OFFSET(pix, image->rect.left,
+				     image->rect.top) - offset;
+		v_offset = V2_OFFSET(pix, image->rect.left,
+				     image->rect.top) - offset;
+
+		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline / 2,
+					      u_offset, v_offset);
+		break;
+	case V4L2_PIX_FMT_NV12:
+		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
+		u_offset = UV_OFFSET(pix, image->rect.left,
+				     image->rect.top) - offset;
+		v_offset = 0;
+
+		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline,
+					      u_offset, v_offset);
+		break;
+	case V4L2_PIX_FMT_NV16:
+		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
+		u_offset = UV2_OFFSET(pix, image->rect.left,
+				      image->rect.top) - offset;
+		v_offset = 0;
+
+		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline,
+					      u_offset, v_offset);
+		break;
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_RGB565:
+		offset = image->rect.left * 2 +
+			image->rect.top * pix->bytesperline;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+	case V4L2_PIX_FMT_BGR32:
+		offset = image->rect.left * 4 +
+			image->rect.top * pix->bytesperline;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+		offset = image->rect.left * 3 +
+			image->rect.top * pix->bytesperline;
+		break;
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+	case V4L2_PIX_FMT_GREY:
+		offset = image->rect.left + image->rect.top * pix->bytesperline;
+		break;
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SGBRG16:
+	case V4L2_PIX_FMT_SGRBG16:
+	case V4L2_PIX_FMT_SRGGB16:
+	case V4L2_PIX_FMT_Y16:
+		offset = image->rect.left * 2 +
+			 image->rect.top * pix->bytesperline;
+		break;
+	default:
+		/* This should not happen */
+		WARN_ON(1);
+		offset = 0;
+		ret = -EINVAL;
+	}
+
+	ipu_cpmem_set_buffer(ch, 0, image->phys0 + offset);
+	ipu_cpmem_set_buffer(ch, 1, image->phys1 + offset);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_set_image);
+
+void ipu_cpmem_dump(struct ipuv3_channel *ch)
+{
+	struct ipu_ch_param __iomem *p = ipu_get_cpmem(ch);
+	struct ipu_soc *ipu = ch->ipu;
+	int chno = ch->num;
+
+	dev_dbg(ipu->dev, "ch %d word 0 - %08X %08X %08X %08X %08X\n", chno,
+		readl(&p->word[0].data[0]),
+		readl(&p->word[0].data[1]),
+		readl(&p->word[0].data[2]),
+		readl(&p->word[0].data[3]),
+		readl(&p->word[0].data[4]));
+	dev_dbg(ipu->dev, "ch %d word 1 - %08X %08X %08X %08X %08X\n", chno,
+		readl(&p->word[1].data[0]),
+		readl(&p->word[1].data[1]),
+		readl(&p->word[1].data[2]),
+		readl(&p->word[1].data[3]),
+		readl(&p->word[1].data[4]));
+	dev_dbg(ipu->dev, "PFS 0x%x, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_PFS));
+	dev_dbg(ipu->dev, "BPP 0x%x, ",
+		ipu_ch_param_read_field(ch, IPU_FIELD_BPP));
+	dev_dbg(ipu->dev, "NPB 0x%x\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_NPB));
+
+	dev_dbg(ipu->dev, "FW %d, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_FW));
+	dev_dbg(ipu->dev, "FH %d, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_FH));
+	dev_dbg(ipu->dev, "EBA0 0x%x\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_EBA0) << 3);
+	dev_dbg(ipu->dev, "EBA1 0x%x\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_EBA1) << 3);
+	dev_dbg(ipu->dev, "Stride %d\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_SL));
+	dev_dbg(ipu->dev, "scan_order %d\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_SO));
+	dev_dbg(ipu->dev, "uv_stride %d\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_SLUV));
+	dev_dbg(ipu->dev, "u_offset 0x%x\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_UBO) << 3);
+	dev_dbg(ipu->dev, "v_offset 0x%x\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_VBO) << 3);
+
+	dev_dbg(ipu->dev, "Width0 %d+1, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_WID0));
+	dev_dbg(ipu->dev, "Width1 %d+1, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_WID1));
+	dev_dbg(ipu->dev, "Width2 %d+1, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_WID2));
+	dev_dbg(ipu->dev, "Width3 %d+1, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_WID3));
+	dev_dbg(ipu->dev, "Offset0 %d, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS0));
+	dev_dbg(ipu->dev, "Offset1 %d, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS1));
+	dev_dbg(ipu->dev, "Offset2 %d, ",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS2));
+	dev_dbg(ipu->dev, "Offset3 %d\n",
+		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS3));
+}
+EXPORT_SYMBOL_GPL(ipu_cpmem_dump);
+
+int ipu_cpmem_init(struct ipu_soc *ipu, struct device *dev, unsigned long base)
+{
+	struct ipu_cpmem *cpmem;
+
+	cpmem = devm_kzalloc(dev, sizeof(*cpmem), GFP_KERNEL);
+	if (!cpmem)
+		return -ENOMEM;
+
+	ipu->cpmem_priv = cpmem;
+
+	spin_lock_init(&cpmem->lock);
+	cpmem->base = devm_ioremap(dev, base, SZ_128K);
+	if (!cpmem->base)
+		return -ENOMEM;
+
+	dev_dbg(dev, "CPMEM base: 0x%08lx remapped to %p\n",
+		base, cpmem->base);
+	cpmem->ipu = ipu;
+
+	return 0;
+}
+
+void ipu_cpmem_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-csi.c b/drivers/gpu/imx/ipu-v3/ipu-csi.c
new file mode 100644
index 0000000..2beadb3
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-csi.c
@@ -0,0 +1,776 @@
+/*
+ * Copyright (C) 2012-2014 Mentor Graphics Inc.
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <uapi/linux/v4l2-mediabus.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+
+#include "ipu-prv.h"
+
+struct ipu_csi {
+	void __iomem *base;
+	int id;
+	u32 module;
+	struct clk *clk_ipu;	/* IPU bus clock */
+	spinlock_t lock;
+	bool inuse;
+	struct ipu_soc *ipu;
+};
+
+/* CSI Register Offsets */
+#define CSI_SENS_CONF		0x0000
+#define CSI_SENS_FRM_SIZE	0x0004
+#define CSI_ACT_FRM_SIZE	0x0008
+#define CSI_OUT_FRM_CTRL	0x000c
+#define CSI_TST_CTRL		0x0010
+#define CSI_CCIR_CODE_1		0x0014
+#define CSI_CCIR_CODE_2		0x0018
+#define CSI_CCIR_CODE_3		0x001c
+#define CSI_MIPI_DI		0x0020
+#define CSI_SKIP		0x0024
+#define CSI_CPD_CTRL		0x0028
+#define CSI_CPD_RC(n)		(0x002c + ((n)*4))
+#define CSI_CPD_RS(n)		(0x004c + ((n)*4))
+#define CSI_CPD_GRC(n)		(0x005c + ((n)*4))
+#define CSI_CPD_GRS(n)		(0x007c + ((n)*4))
+#define CSI_CPD_GBC(n)		(0x008c + ((n)*4))
+#define CSI_CPD_GBS(n)		(0x00Ac + ((n)*4))
+#define CSI_CPD_BC(n)		(0x00Bc + ((n)*4))
+#define CSI_CPD_BS(n)		(0x00Dc + ((n)*4))
+#define CSI_CPD_OFFSET1		0x00ec
+#define CSI_CPD_OFFSET2		0x00f0
+
+/* CSI Register Fields */
+#define CSI_SENS_CONF_DATA_FMT_SHIFT		8
+#define CSI_SENS_CONF_DATA_FMT_MASK		0x00000700
+#define CSI_SENS_CONF_DATA_FMT_RGB_YUV444	0L
+#define CSI_SENS_CONF_DATA_FMT_YUV422_YUYV	1L
+#define CSI_SENS_CONF_DATA_FMT_YUV422_UYVY	2L
+#define CSI_SENS_CONF_DATA_FMT_BAYER		3L
+#define CSI_SENS_CONF_DATA_FMT_RGB565		4L
+#define CSI_SENS_CONF_DATA_FMT_RGB555		5L
+#define CSI_SENS_CONF_DATA_FMT_RGB444		6L
+#define CSI_SENS_CONF_DATA_FMT_JPEG		7L
+
+#define CSI_SENS_CONF_VSYNC_POL_SHIFT		0
+#define CSI_SENS_CONF_HSYNC_POL_SHIFT		1
+#define CSI_SENS_CONF_DATA_POL_SHIFT		2
+#define CSI_SENS_CONF_PIX_CLK_POL_SHIFT		3
+#define CSI_SENS_CONF_SENS_PRTCL_MASK		0x00000070
+#define CSI_SENS_CONF_SENS_PRTCL_SHIFT		4
+#define CSI_SENS_CONF_PACK_TIGHT_SHIFT		7
+#define CSI_SENS_CONF_DATA_WIDTH_SHIFT		11
+#define CSI_SENS_CONF_EXT_VSYNC_SHIFT		15
+#define CSI_SENS_CONF_DIVRATIO_SHIFT		16
+
+#define CSI_SENS_CONF_DIVRATIO_MASK		0x00ff0000
+#define CSI_SENS_CONF_DATA_DEST_SHIFT		24
+#define CSI_SENS_CONF_DATA_DEST_MASK		0x07000000
+#define CSI_SENS_CONF_JPEG8_EN_SHIFT		27
+#define CSI_SENS_CONF_JPEG_EN_SHIFT		28
+#define CSI_SENS_CONF_FORCE_EOF_SHIFT		29
+#define CSI_SENS_CONF_DATA_EN_POL_SHIFT		31
+
+#define CSI_DATA_DEST_IC			2
+#define CSI_DATA_DEST_IDMAC			4
+
+#define CSI_CCIR_ERR_DET_EN			0x01000000
+#define CSI_HORI_DOWNSIZE_EN			0x80000000
+#define CSI_VERT_DOWNSIZE_EN			0x40000000
+#define CSI_TEST_GEN_MODE_EN			0x01000000
+
+#define CSI_HSC_MASK				0x1fff0000
+#define CSI_HSC_SHIFT				16
+#define CSI_VSC_MASK				0x00000fff
+#define CSI_VSC_SHIFT				0
+
+#define CSI_TEST_GEN_R_MASK			0x000000ff
+#define CSI_TEST_GEN_R_SHIFT			0
+#define CSI_TEST_GEN_G_MASK			0x0000ff00
+#define CSI_TEST_GEN_G_SHIFT			8
+#define CSI_TEST_GEN_B_MASK			0x00ff0000
+#define CSI_TEST_GEN_B_SHIFT			16
+
+#define CSI_MAX_RATIO_SKIP_SMFC_MASK		0x00000007
+#define CSI_MAX_RATIO_SKIP_SMFC_SHIFT		0
+#define CSI_SKIP_SMFC_MASK			0x000000f8
+#define CSI_SKIP_SMFC_SHIFT			3
+#define CSI_ID_2_SKIP_MASK			0x00000300
+#define CSI_ID_2_SKIP_SHIFT			8
+
+#define CSI_COLOR_FIRST_ROW_MASK		0x00000002
+#define CSI_COLOR_FIRST_COMP_MASK		0x00000001
+
+/* MIPI CSI-2 data types */
+#define MIPI_DT_YUV420		0x18 /* YYY.../UYVY.... */
+#define MIPI_DT_YUV420_LEGACY	0x1a /* UYY.../VYY...   */
+#define MIPI_DT_YUV422		0x1e /* UYVY...         */
+#define MIPI_DT_RGB444		0x20
+#define MIPI_DT_RGB555		0x21
+#define MIPI_DT_RGB565		0x22
+#define MIPI_DT_RGB666		0x23
+#define MIPI_DT_RGB888		0x24
+#define MIPI_DT_RAW6		0x28
+#define MIPI_DT_RAW7		0x29
+#define MIPI_DT_RAW8		0x2a
+#define MIPI_DT_RAW10		0x2b
+#define MIPI_DT_RAW12		0x2c
+#define MIPI_DT_RAW14		0x2d
+
+/*
+ * Bitfield of CSI bus signal polarities and modes.
+ */
+struct ipu_csi_bus_config {
+	unsigned data_width:4;
+	unsigned clk_mode:3;
+	unsigned ext_vsync:1;
+	unsigned vsync_pol:1;
+	unsigned hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+	unsigned pack_tight:1;
+	unsigned force_eof:1;
+	unsigned data_en_pol:1;
+
+	unsigned data_fmt;
+	unsigned mipi_dt;
+};
+
+/*
+ * Enumeration of CSI data bus widths.
+ */
+enum ipu_csi_data_width {
+	IPU_CSI_DATA_WIDTH_4   = 0,
+	IPU_CSI_DATA_WIDTH_8   = 1,
+	IPU_CSI_DATA_WIDTH_10  = 3,
+	IPU_CSI_DATA_WIDTH_12  = 5,
+	IPU_CSI_DATA_WIDTH_16  = 9,
+};
+
+/*
+ * Enumeration of CSI clock modes.
+ */
+enum ipu_csi_clk_mode {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
+};
+
+static inline u32 ipu_csi_read(struct ipu_csi *csi, unsigned offset)
+{
+	return readl(csi->base + offset);
+}
+
+static inline void ipu_csi_write(struct ipu_csi *csi, u32 value,
+				 unsigned offset)
+{
+	writel(value, csi->base + offset);
+}
+
+/*
+ * Set mclk division ratio for generating test mode mclk. Only used
+ * for test generator.
+ */
+static int ipu_csi_set_testgen_mclk(struct ipu_csi *csi, u32 pixel_clk,
+					u32 ipu_clk)
+{
+	u32 temp;
+	int div_ratio;
+
+	div_ratio = (ipu_clk / pixel_clk) - 1;
+
+	if (div_ratio > 0xFF || div_ratio < 0) {
+		dev_err(csi->ipu->dev,
+			"value of pixel_clk extends normal range\n");
+		return -EINVAL;
+	}
+
+	temp = ipu_csi_read(csi, CSI_SENS_CONF);
+	temp &= ~CSI_SENS_CONF_DIVRATIO_MASK;
+	ipu_csi_write(csi, temp | (div_ratio << CSI_SENS_CONF_DIVRATIO_SHIFT),
+			  CSI_SENS_CONF);
+
+	return 0;
+}
+
+/*
+ * Find the CSI data format and data width for the given V4L2 media
+ * bus pixel format code.
+ */
+static int mbus_code_to_bus_cfg(struct ipu_csi_bus_config *cfg, u32 mbus_code)
+{
+	switch (mbus_code) {
+	case MEDIA_BUS_FMT_BGR565_2X8_BE:
+	case MEDIA_BUS_FMT_BGR565_2X8_LE:
+	case MEDIA_BUS_FMT_RGB565_2X8_BE:
+	case MEDIA_BUS_FMT_RGB565_2X8_LE:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB565;
+		cfg->mipi_dt = MIPI_DT_RGB565;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:
+	case MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB444;
+		cfg->mipi_dt = MIPI_DT_RGB444;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:
+	case MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB555;
+		cfg->mipi_dt = MIPI_DT_RGB555;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;
+		cfg->mipi_dt = MIPI_DT_YUV422;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;
+		cfg->mipi_dt = MIPI_DT_YUV422;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		cfg->mipi_dt = MIPI_DT_YUV422;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_16;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_Y8_1X8:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		cfg->mipi_dt = MIPI_DT_RAW8;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE:
+	case MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:
+	case MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE:
+	case MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		cfg->mipi_dt = MIPI_DT_RAW10;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_Y10_1X10:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		cfg->mipi_dt = MIPI_DT_RAW10;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_10;
+		break;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_Y12_1X12:
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
+		cfg->mipi_dt = MIPI_DT_RAW12;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_12;
+		break;
+	case MEDIA_BUS_FMT_JPEG_1X8:
+		/* TODO */
+		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_JPEG;
+		cfg->mipi_dt = MIPI_DT_RAW8;
+		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Fill a CSI bus config struct from mbus_config and mbus_framefmt.
+ */
+static int fill_csi_bus_cfg(struct ipu_csi_bus_config *csicfg,
+				 struct v4l2_mbus_config *mbus_cfg,
+				 struct v4l2_mbus_framefmt *mbus_fmt)
+{
+	int ret;
+
+	memset(csicfg, 0, sizeof(*csicfg));
+
+	ret = mbus_code_to_bus_cfg(csicfg, mbus_fmt->code);
+	if (ret < 0)
+		return ret;
+
+	switch (mbus_cfg->type) {
+	case V4L2_MBUS_PARALLEL:
+		csicfg->ext_vsync = 1;
+		csicfg->vsync_pol = (mbus_cfg->flags &
+				     V4L2_MBUS_VSYNC_ACTIVE_LOW) ? 1 : 0;
+		csicfg->hsync_pol = (mbus_cfg->flags &
+				     V4L2_MBUS_HSYNC_ACTIVE_LOW) ? 1 : 0;
+		csicfg->pixclk_pol = (mbus_cfg->flags &
+				      V4L2_MBUS_PCLK_SAMPLE_FALLING) ? 1 : 0;
+		csicfg->clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;
+		break;
+	case V4L2_MBUS_BT656:
+		csicfg->ext_vsync = 0;
+		if (V4L2_FIELD_HAS_BOTH(mbus_fmt->field) ||
+		    mbus_fmt->field == V4L2_FIELD_ALTERNATE)
+			csicfg->clk_mode = IPU_CSI_CLK_MODE_CCIR656_INTERLACED;
+		else
+			csicfg->clk_mode = IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE;
+		break;
+	case V4L2_MBUS_CSI2:
+		/*
+		 * MIPI CSI-2 requires non gated clock mode, all other
+		 * parameters are not applicable for MIPI CSI-2 bus.
+		 */
+		csicfg->clk_mode = IPU_CSI_CLK_MODE_NONGATED_CLK;
+		break;
+	default:
+		/* will never get here, keep compiler quiet */
+		break;
+	}
+
+	return 0;
+}
+
+int ipu_csi_init_interface(struct ipu_csi *csi,
+			   struct v4l2_mbus_config *mbus_cfg,
+			   struct v4l2_mbus_framefmt *mbus_fmt)
+{
+	struct ipu_csi_bus_config cfg;
+	unsigned long flags;
+	u32 width, height, data = 0;
+	int ret;
+
+	ret = fill_csi_bus_cfg(&cfg, mbus_cfg, mbus_fmt);
+	if (ret < 0)
+		return ret;
+
+	/* set default sensor frame width and height */
+	width = mbus_fmt->width;
+	height = mbus_fmt->height;
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	data |= cfg.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
+		cfg.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |
+		cfg.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |
+		cfg.vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |
+		cfg.hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |
+		cfg.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |
+		cfg.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |
+		cfg.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |
+		cfg.pack_tight << CSI_SENS_CONF_PACK_TIGHT_SHIFT |
+		cfg.force_eof << CSI_SENS_CONF_FORCE_EOF_SHIFT |
+		cfg.data_en_pol << CSI_SENS_CONF_DATA_EN_POL_SHIFT;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	ipu_csi_write(csi, data, CSI_SENS_CONF);
+
+	/* Set CCIR registers */
+
+	switch (cfg.clk_mode) {
+	case IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:
+		ipu_csi_write(csi, 0x40030, CSI_CCIR_CODE_1);
+		ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
+		break;
+	case IPU_CSI_CLK_MODE_CCIR656_INTERLACED:
+		if (mbus_fmt->width == 720 && mbus_fmt->height == 576) {
+			/*
+			 * PAL case
+			 *
+			 * Field0BlankEnd = 0x6, Field0BlankStart = 0x2,
+			 * Field0ActiveEnd = 0x4, Field0ActiveStart = 0
+			 * Field1BlankEnd = 0x7, Field1BlankStart = 0x3,
+			 * Field1ActiveEnd = 0x5, Field1ActiveStart = 0x1
+			 */
+			height = 625; /* framelines for PAL */
+
+			ipu_csi_write(csi, 0x40596 | CSI_CCIR_ERR_DET_EN,
+					  CSI_CCIR_CODE_1);
+			ipu_csi_write(csi, 0xD07DF, CSI_CCIR_CODE_2);
+			ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
+		} else if (mbus_fmt->width == 720 && mbus_fmt->height == 480) {
+			/*
+			 * NTSC case
+			 *
+			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
+			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
+			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
+			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 */
+			height = 525; /* framelines for NTSC */
+
+			ipu_csi_write(csi, 0xD07DF | CSI_CCIR_ERR_DET_EN,
+					  CSI_CCIR_CODE_1);
+			ipu_csi_write(csi, 0x40596, CSI_CCIR_CODE_2);
+			ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
+		} else {
+			dev_err(csi->ipu->dev,
+				"Unsupported CCIR656 interlaced video mode\n");
+			spin_unlock_irqrestore(&csi->lock, flags);
+			return -EINVAL;
+		}
+		break;
+	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:
+	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:
+	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:
+	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:
+		ipu_csi_write(csi, 0x40030 | CSI_CCIR_ERR_DET_EN,
+				   CSI_CCIR_CODE_1);
+		ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
+		break;
+	case IPU_CSI_CLK_MODE_GATED_CLK:
+	case IPU_CSI_CLK_MODE_NONGATED_CLK:
+		ipu_csi_write(csi, 0, CSI_CCIR_CODE_1);
+		break;
+	}
+
+	/* Setup sensor frame size */
+	ipu_csi_write(csi, (width - 1) | ((height - 1) << 16),
+		      CSI_SENS_FRM_SIZE);
+
+	dev_dbg(csi->ipu->dev, "CSI_SENS_CONF = 0x%08X\n",
+		ipu_csi_read(csi, CSI_SENS_CONF));
+	dev_dbg(csi->ipu->dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
+		ipu_csi_read(csi, CSI_ACT_FRM_SIZE));
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_init_interface);
+
+bool ipu_csi_is_interlaced(struct ipu_csi *csi)
+{
+	unsigned long flags;
+	u32 sensor_protocol;
+
+	spin_lock_irqsave(&csi->lock, flags);
+	sensor_protocol =
+		(ipu_csi_read(csi, CSI_SENS_CONF) &
+		 CSI_SENS_CONF_SENS_PRTCL_MASK) >>
+		CSI_SENS_CONF_SENS_PRTCL_SHIFT;
+	spin_unlock_irqrestore(&csi->lock, flags);
+
+	switch (sensor_protocol) {
+	case IPU_CSI_CLK_MODE_GATED_CLK:
+	case IPU_CSI_CLK_MODE_NONGATED_CLK:
+	case IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:
+	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:
+	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:
+		return false;
+	case IPU_CSI_CLK_MODE_CCIR656_INTERLACED:
+	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:
+	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:
+		return true;
+	default:
+		dev_err(csi->ipu->dev,
+			"CSI %d sensor protocol unsupported\n", csi->id);
+		return false;
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_csi_is_interlaced);
+
+void ipu_csi_get_window(struct ipu_csi *csi, struct v4l2_rect *w)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	reg = ipu_csi_read(csi, CSI_ACT_FRM_SIZE);
+	w->width = (reg & 0xFFFF) + 1;
+	w->height = (reg >> 16 & 0xFFFF) + 1;
+
+	reg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);
+	w->left = (reg & CSI_HSC_MASK) >> CSI_HSC_SHIFT;
+	w->top = (reg & CSI_VSC_MASK) >> CSI_VSC_SHIFT;
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_csi_get_window);
+
+void ipu_csi_set_window(struct ipu_csi *csi, struct v4l2_rect *w)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	ipu_csi_write(csi, (w->width - 1) | ((w->height - 1) << 16),
+			  CSI_ACT_FRM_SIZE);
+
+	reg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);
+	reg &= ~(CSI_HSC_MASK | CSI_VSC_MASK);
+	reg |= ((w->top << CSI_VSC_SHIFT) | (w->left << CSI_HSC_SHIFT));
+	ipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_csi_set_window);
+
+void ipu_csi_set_downsize(struct ipu_csi *csi, bool horiz, bool vert)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	reg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);
+	reg &= ~(CSI_HORI_DOWNSIZE_EN | CSI_VERT_DOWNSIZE_EN);
+	reg |= (horiz ? CSI_HORI_DOWNSIZE_EN : 0) |
+	       (vert ? CSI_VERT_DOWNSIZE_EN : 0);
+	ipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_csi_set_downsize);
+
+void ipu_csi_set_test_generator(struct ipu_csi *csi, bool active,
+				u32 r_value, u32 g_value, u32 b_value,
+				u32 pix_clk)
+{
+	unsigned long flags;
+	u32 ipu_clk = clk_get_rate(csi->clk_ipu);
+	u32 temp;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	temp = ipu_csi_read(csi, CSI_TST_CTRL);
+
+	if (!active) {
+		temp &= ~CSI_TEST_GEN_MODE_EN;
+		ipu_csi_write(csi, temp, CSI_TST_CTRL);
+	} else {
+		/* Set sensb_mclk div_ratio */
+		ipu_csi_set_testgen_mclk(csi, pix_clk, ipu_clk);
+
+		temp &= ~(CSI_TEST_GEN_R_MASK | CSI_TEST_GEN_G_MASK |
+			  CSI_TEST_GEN_B_MASK);
+		temp |= CSI_TEST_GEN_MODE_EN;
+		temp |= (r_value << CSI_TEST_GEN_R_SHIFT) |
+			(g_value << CSI_TEST_GEN_G_SHIFT) |
+			(b_value << CSI_TEST_GEN_B_SHIFT);
+		ipu_csi_write(csi, temp, CSI_TST_CTRL);
+	}
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_csi_set_test_generator);
+
+int ipu_csi_set_mipi_datatype(struct ipu_csi *csi, u32 vc,
+			      struct v4l2_mbus_framefmt *mbus_fmt)
+{
+	struct ipu_csi_bus_config cfg;
+	unsigned long flags;
+	u32 temp;
+	int ret;
+
+	if (vc > 3)
+		return -EINVAL;
+
+	ret = mbus_code_to_bus_cfg(&cfg, mbus_fmt->code);
+	if (ret < 0)
+		return ret;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	temp = ipu_csi_read(csi, CSI_MIPI_DI);
+	temp &= ~(0xff << (vc * 8));
+	temp |= (cfg.mipi_dt << (vc * 8));
+	ipu_csi_write(csi, temp, CSI_MIPI_DI);
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_set_mipi_datatype);
+
+int ipu_csi_set_skip_smfc(struct ipu_csi *csi, u32 skip,
+			  u32 max_ratio, u32 id)
+{
+	unsigned long flags;
+	u32 temp;
+
+	if (max_ratio > 5 || id > 3)
+		return -EINVAL;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	temp = ipu_csi_read(csi, CSI_SKIP);
+	temp &= ~(CSI_MAX_RATIO_SKIP_SMFC_MASK | CSI_ID_2_SKIP_MASK |
+		  CSI_SKIP_SMFC_MASK);
+	temp |= (max_ratio << CSI_MAX_RATIO_SKIP_SMFC_SHIFT) |
+		(id << CSI_ID_2_SKIP_SHIFT) |
+		(skip << CSI_SKIP_SMFC_SHIFT);
+	ipu_csi_write(csi, temp, CSI_SKIP);
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_set_skip_smfc);
+
+int ipu_csi_set_dest(struct ipu_csi *csi, enum ipu_csi_dest csi_dest)
+{
+	unsigned long flags;
+	u32 csi_sens_conf, dest;
+
+	if (csi_dest == IPU_CSI_DEST_IDMAC)
+		dest = CSI_DATA_DEST_IDMAC;
+	else
+		dest = CSI_DATA_DEST_IC; /* IC or VDIC */
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	csi_sens_conf = ipu_csi_read(csi, CSI_SENS_CONF);
+	csi_sens_conf &= ~CSI_SENS_CONF_DATA_DEST_MASK;
+	csi_sens_conf |= (dest << CSI_SENS_CONF_DATA_DEST_SHIFT);
+	ipu_csi_write(csi, csi_sens_conf, CSI_SENS_CONF);
+
+	spin_unlock_irqrestore(&csi->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_set_dest);
+
+int ipu_csi_enable(struct ipu_csi *csi)
+{
+	ipu_module_enable(csi->ipu, csi->module);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_enable);
+
+int ipu_csi_disable(struct ipu_csi *csi)
+{
+	ipu_module_disable(csi->ipu, csi->module);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_disable);
+
+struct ipu_csi *ipu_csi_get(struct ipu_soc *ipu, int id)
+{
+	unsigned long flags;
+	struct ipu_csi *csi, *ret;
+
+	if (id > 1)
+		return ERR_PTR(-EINVAL);
+
+	csi = ipu->csi_priv[id];
+	ret = csi;
+
+	spin_lock_irqsave(&csi->lock, flags);
+
+	if (csi->inuse) {
+		ret = ERR_PTR(-EBUSY);
+		goto unlock;
+	}
+
+	csi->inuse = true;
+unlock:
+	spin_unlock_irqrestore(&csi->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_csi_get);
+
+void ipu_csi_put(struct ipu_csi *csi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&csi->lock, flags);
+	csi->inuse = false;
+	spin_unlock_irqrestore(&csi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_csi_put);
+
+int ipu_csi_init(struct ipu_soc *ipu, struct device *dev, int id,
+		 unsigned long base, u32 module, struct clk *clk_ipu)
+{
+	struct ipu_csi *csi;
+
+	if (id > 1)
+		return -ENODEV;
+
+	csi = devm_kzalloc(dev, sizeof(*csi), GFP_KERNEL);
+	if (!csi)
+		return -ENOMEM;
+
+	ipu->csi_priv[id] = csi;
+
+	spin_lock_init(&csi->lock);
+	csi->module = module;
+	csi->id = id;
+	csi->clk_ipu = clk_ipu;
+	csi->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!csi->base)
+		return -ENOMEM;
+
+	dev_dbg(dev, "CSI%d base: 0x%08lx remapped to %p\n",
+		id, base, csi->base);
+	csi->ipu = ipu;
+
+	return 0;
+}
+
+void ipu_csi_exit(struct ipu_soc *ipu, int id)
+{
+}
+
+void ipu_csi_dump(struct ipu_csi *csi)
+{
+	dev_dbg(csi->ipu->dev, "CSI_SENS_CONF:     %08x\n",
+		ipu_csi_read(csi, CSI_SENS_CONF));
+	dev_dbg(csi->ipu->dev, "CSI_SENS_FRM_SIZE: %08x\n",
+		ipu_csi_read(csi, CSI_SENS_FRM_SIZE));
+	dev_dbg(csi->ipu->dev, "CSI_ACT_FRM_SIZE:  %08x\n",
+		ipu_csi_read(csi, CSI_ACT_FRM_SIZE));
+	dev_dbg(csi->ipu->dev, "CSI_OUT_FRM_CTRL:  %08x\n",
+		ipu_csi_read(csi, CSI_OUT_FRM_CTRL));
+	dev_dbg(csi->ipu->dev, "CSI_TST_CTRL:      %08x\n",
+		ipu_csi_read(csi, CSI_TST_CTRL));
+	dev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_1:   %08x\n",
+		ipu_csi_read(csi, CSI_CCIR_CODE_1));
+	dev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_2:   %08x\n",
+		ipu_csi_read(csi, CSI_CCIR_CODE_2));
+	dev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_3:   %08x\n",
+		ipu_csi_read(csi, CSI_CCIR_CODE_3));
+	dev_dbg(csi->ipu->dev, "CSI_MIPI_DI:       %08x\n",
+		ipu_csi_read(csi, CSI_MIPI_DI));
+	dev_dbg(csi->ipu->dev, "CSI_SKIP:          %08x\n",
+		ipu_csi_read(csi, CSI_SKIP));
+}
+EXPORT_SYMBOL_GPL(ipu_csi_dump);
diff --git a/drivers/gpu/imx/ipu-v3/ipu-dc.c b/drivers/gpu/imx/ipu-v3/ipu-dc.c
new file mode 100644
index 0000000..49bfe6e
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-dc.c
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+
+#include <video/imx-ipu-v3.h>
+#include "ipu-prv.h"
+
+#define DC_MAP_CONF_PTR(n)	(0x108 + ((n) & ~0x1) * 2)
+#define DC_MAP_CONF_VAL(n)	(0x144 + ((n) & ~0x1) * 2)
+
+#define DC_EVT_NF		0
+#define DC_EVT_NL		1
+#define DC_EVT_EOF		2
+#define DC_EVT_NFIELD		3
+#define DC_EVT_EOL		4
+#define DC_EVT_EOFIELD		5
+#define DC_EVT_NEW_ADDR		6
+#define DC_EVT_NEW_CHAN		7
+#define DC_EVT_NEW_DATA		8
+
+#define DC_EVT_NEW_ADDR_W_0	0
+#define DC_EVT_NEW_ADDR_W_1	1
+#define DC_EVT_NEW_CHAN_W_0	2
+#define DC_EVT_NEW_CHAN_W_1	3
+#define DC_EVT_NEW_DATA_W_0	4
+#define DC_EVT_NEW_DATA_W_1	5
+#define DC_EVT_NEW_ADDR_R_0	6
+#define DC_EVT_NEW_ADDR_R_1	7
+#define DC_EVT_NEW_CHAN_R_0	8
+#define DC_EVT_NEW_CHAN_R_1	9
+#define DC_EVT_NEW_DATA_R_0	10
+#define DC_EVT_NEW_DATA_R_1	11
+
+#define DC_WR_CH_CONF		0x0
+#define DC_WR_CH_ADDR		0x4
+#define DC_RL_CH(evt)		(8 + ((evt) & ~0x1) * 2)
+
+#define DC_GEN			0xd4
+#define DC_DISP_CONF1(disp)	(0xd8 + (disp) * 4)
+#define DC_DISP_CONF2(disp)	(0xe8 + (disp) * 4)
+#define DC_STAT			0x1c8
+
+#define WROD(lf)		(0x18 | ((lf) << 1))
+#define WRG			0x01
+#define WCLK			0xc9
+
+#define SYNC_WAVE 0
+#define NULL_WAVE (-1)
+
+#define DC_GEN_SYNC_1_6_SYNC	(2 << 1)
+#define DC_GEN_SYNC_PRIORITY_1	(1 << 7)
+
+#define DC_WR_CH_CONF_WORD_SIZE_8		(0 << 0)
+#define DC_WR_CH_CONF_WORD_SIZE_16		(1 << 0)
+#define DC_WR_CH_CONF_WORD_SIZE_24		(2 << 0)
+#define DC_WR_CH_CONF_WORD_SIZE_32		(3 << 0)
+#define DC_WR_CH_CONF_DISP_ID_PARALLEL(i)	(((i) & 0x1) << 3)
+#define DC_WR_CH_CONF_DISP_ID_SERIAL		(2 << 3)
+#define DC_WR_CH_CONF_DISP_ID_ASYNC		(3 << 4)
+#define DC_WR_CH_CONF_FIELD_MODE		(1 << 9)
+#define DC_WR_CH_CONF_PROG_TYPE_NORMAL		(4 << 5)
+#define DC_WR_CH_CONF_PROG_TYPE_MASK		(7 << 5)
+#define DC_WR_CH_CONF_PROG_DI_ID		(1 << 2)
+#define DC_WR_CH_CONF_PROG_DISP_ID(i)		(((i) & 0x1) << 3)
+
+#define IPU_DC_NUM_CHANNELS	10
+
+struct ipu_dc_priv;
+
+enum ipu_dc_map {
+	IPU_DC_MAP_RGB24,
+	IPU_DC_MAP_RGB565,
+	IPU_DC_MAP_GBR24, /* TVEv2 */
+	IPU_DC_MAP_BGR666,
+	IPU_DC_MAP_LVDS666,
+	IPU_DC_MAP_BGR24,
+};
+
+struct ipu_dc {
+	/* The display interface number assigned to this dc channel */
+	unsigned int		di;
+	void __iomem		*base;
+	struct ipu_dc_priv	*priv;
+	int			chno;
+	bool			in_use;
+};
+
+struct ipu_dc_priv {
+	void __iomem		*dc_reg;
+	void __iomem		*dc_tmpl_reg;
+	struct ipu_soc		*ipu;
+	struct device		*dev;
+	struct ipu_dc		channels[IPU_DC_NUM_CHANNELS];
+	struct mutex		mutex;
+	struct completion	comp;
+	int			use_count;
+};
+
+static void dc_link_event(struct ipu_dc *dc, int event, int addr, int priority)
+{
+	u32 reg;
+
+	reg = readl(dc->base + DC_RL_CH(event));
+	reg &= ~(0xffff << (16 * (event & 0x1)));
+	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
+	writel(reg, dc->base + DC_RL_CH(event));
+}
+
+static void dc_write_tmpl(struct ipu_dc *dc, int word, u32 opcode, u32 operand,
+		int map, int wave, int glue, int sync, int stop)
+{
+	struct ipu_dc_priv *priv = dc->priv;
+	u32 reg1, reg2;
+
+	if (opcode == WCLK) {
+		reg1 = (operand << 20) & 0xfff00000;
+		reg2 = operand >> 12 | opcode << 1 | stop << 9;
+	} else if (opcode == WRG) {
+		reg1 = sync | glue << 4 | ++wave << 11 | ((operand << 15) & 0xffff8000);
+		reg2 = operand >> 17 | opcode << 7 | stop << 9;
+	} else {
+		reg1 = sync | glue << 4 | ++wave << 11 | ++map << 15 | ((operand << 20) & 0xfff00000);
+		reg2 = operand >> 12 | opcode << 4 | stop << 9;
+	}
+	writel(reg1, priv->dc_tmpl_reg + word * 8);
+	writel(reg2, priv->dc_tmpl_reg + word * 8 + 4);
+}
+
+static int ipu_bus_format_to_map(u32 fmt)
+{
+	switch (fmt) {
+	default:
+		WARN_ON(1);
+		/* fall-through */
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		return IPU_DC_MAP_RGB24;
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		return IPU_DC_MAP_RGB565;
+	case MEDIA_BUS_FMT_GBR888_1X24:
+		return IPU_DC_MAP_GBR24;
+	case MEDIA_BUS_FMT_RGB666_1X18:
+		return IPU_DC_MAP_BGR666;
+	case MEDIA_BUS_FMT_RGB666_1X24_CPADHI:
+		return IPU_DC_MAP_LVDS666;
+	case MEDIA_BUS_FMT_BGR888_1X24:
+		return IPU_DC_MAP_BGR24;
+	}
+}
+
+int ipu_dc_init_sync(struct ipu_dc *dc, struct ipu_di *di, bool interlaced,
+		u32 bus_format, u32 width)
+{
+	struct ipu_dc_priv *priv = dc->priv;
+	int addr, sync;
+	u32 reg = 0;
+	int map;
+
+	dc->di = ipu_di_get_num(di);
+
+	map = ipu_bus_format_to_map(bus_format);
+
+	/*
+	 * In interlaced mode we need more counters to create the asymmetric
+	 * per-field VSYNC signals. The pixel active signal synchronising DC
+	 * to DI moves to signal generator #6 (see ipu-di.c). In progressive
+	 * mode counter #5 is used.
+	 */
+	sync = interlaced ? 6 : 5;
+
+	/* Reserve 5 microcode template words for each DI */
+	if (dc->di)
+		addr = 5;
+	else
+		addr = 0;
+
+	if (interlaced) {
+		dc_link_event(dc, DC_EVT_NL, addr, 3);
+		dc_link_event(dc, DC_EVT_EOL, addr, 2);
+		dc_link_event(dc, DC_EVT_NEW_DATA, addr, 1);
+
+		/* Init template microcode */
+		dc_write_tmpl(dc, addr, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);
+	} else {
+		dc_link_event(dc, DC_EVT_NL, addr + 2, 3);
+		dc_link_event(dc, DC_EVT_EOL, addr + 3, 2);
+		dc_link_event(dc, DC_EVT_NEW_DATA, addr + 1, 1);
+
+		/* Init template microcode */
+		dc_write_tmpl(dc, addr + 2, WROD(0), 0, map, SYNC_WAVE, 8, sync, 1);
+		dc_write_tmpl(dc, addr + 3, WROD(0), 0, map, SYNC_WAVE, 4, sync, 0);
+		dc_write_tmpl(dc, addr + 4, WRG, 0, map, NULL_WAVE, 0, 0, 1);
+		dc_write_tmpl(dc, addr + 1, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);
+	}
+
+	dc_link_event(dc, DC_EVT_NF, 0, 0);
+	dc_link_event(dc, DC_EVT_NFIELD, 0, 0);
+	dc_link_event(dc, DC_EVT_EOF, 0, 0);
+	dc_link_event(dc, DC_EVT_EOFIELD, 0, 0);
+	dc_link_event(dc, DC_EVT_NEW_CHAN, 0, 0);
+	dc_link_event(dc, DC_EVT_NEW_ADDR, 0, 0);
+
+	reg = readl(dc->base + DC_WR_CH_CONF);
+	if (interlaced)
+		reg |= DC_WR_CH_CONF_FIELD_MODE;
+	else
+		reg &= ~DC_WR_CH_CONF_FIELD_MODE;
+	writel(reg, dc->base + DC_WR_CH_CONF);
+
+	writel(0x0, dc->base + DC_WR_CH_ADDR);
+	writel(width, priv->dc_reg + DC_DISP_CONF2(dc->di));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dc_init_sync);
+
+void ipu_dc_enable(struct ipu_soc *ipu)
+{
+	struct ipu_dc_priv *priv = ipu->dc_priv;
+
+	mutex_lock(&priv->mutex);
+
+	if (!priv->use_count)
+		ipu_module_enable(priv->ipu, IPU_CONF_DC_EN);
+
+	priv->use_count++;
+
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dc_enable);
+
+void ipu_dc_enable_channel(struct ipu_dc *dc)
+{
+	u32 reg;
+
+	reg = readl(dc->base + DC_WR_CH_CONF);
+	reg |= DC_WR_CH_CONF_PROG_TYPE_NORMAL;
+	writel(reg, dc->base + DC_WR_CH_CONF);
+}
+EXPORT_SYMBOL_GPL(ipu_dc_enable_channel);
+
+void ipu_dc_disable_channel(struct ipu_dc *dc)
+{
+	u32 val;
+
+	val = readl(dc->base + DC_WR_CH_CONF);
+	val &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
+	writel(val, dc->base + DC_WR_CH_CONF);
+}
+EXPORT_SYMBOL_GPL(ipu_dc_disable_channel);
+
+void ipu_dc_disable(struct ipu_soc *ipu)
+{
+	struct ipu_dc_priv *priv = ipu->dc_priv;
+
+	mutex_lock(&priv->mutex);
+
+	priv->use_count--;
+	if (!priv->use_count)
+		ipu_module_disable(priv->ipu, IPU_CONF_DC_EN);
+
+	if (priv->use_count < 0)
+		priv->use_count = 0;
+
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dc_disable);
+
+static void ipu_dc_map_config(struct ipu_dc_priv *priv, enum ipu_dc_map map,
+		int byte_num, int offset, int mask)
+{
+	int ptr = map * 3 + byte_num;
+	u32 reg;
+
+	reg = readl(priv->dc_reg + DC_MAP_CONF_VAL(ptr));
+	reg &= ~(0xffff << (16 * (ptr & 0x1)));
+	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
+	writel(reg, priv->dc_reg + DC_MAP_CONF_VAL(ptr));
+
+	reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));
+	reg &= ~(0x1f << ((16 * (map & 0x1)) + (5 * byte_num)));
+	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
+	writel(reg, priv->dc_reg + DC_MAP_CONF_PTR(map));
+}
+
+static void ipu_dc_map_clear(struct ipu_dc_priv *priv, int map)
+{
+	u32 reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));
+
+	writel(reg & ~(0xffff << (16 * (map & 0x1))),
+		     priv->dc_reg + DC_MAP_CONF_PTR(map));
+}
+
+struct ipu_dc *ipu_dc_get(struct ipu_soc *ipu, int channel)
+{
+	struct ipu_dc_priv *priv = ipu->dc_priv;
+	struct ipu_dc *dc;
+
+	if (channel >= IPU_DC_NUM_CHANNELS)
+		return ERR_PTR(-ENODEV);
+
+	dc = &priv->channels[channel];
+
+	mutex_lock(&priv->mutex);
+
+	if (dc->in_use) {
+		mutex_unlock(&priv->mutex);
+		return ERR_PTR(-EBUSY);
+	}
+
+	dc->in_use = true;
+
+	mutex_unlock(&priv->mutex);
+
+	return dc;
+}
+EXPORT_SYMBOL_GPL(ipu_dc_get);
+
+void ipu_dc_put(struct ipu_dc *dc)
+{
+	struct ipu_dc_priv *priv = dc->priv;
+
+	mutex_lock(&priv->mutex);
+	dc->in_use = false;
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dc_put);
+
+int ipu_dc_init(struct ipu_soc *ipu, struct device *dev,
+		unsigned long base, unsigned long template_base)
+{
+	struct ipu_dc_priv *priv;
+	static int channel_offsets[] = { 0, 0x1c, 0x38, 0x54, 0x58, 0x5c,
+		0x78, 0, 0x94, 0xb4};
+	int i;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	mutex_init(&priv->mutex);
+
+	priv->dev = dev;
+	priv->ipu = ipu;
+	priv->dc_reg = devm_ioremap(dev, base, PAGE_SIZE);
+	priv->dc_tmpl_reg = devm_ioremap(dev, template_base, PAGE_SIZE);
+	if (!priv->dc_reg || !priv->dc_tmpl_reg)
+		return -ENOMEM;
+
+	for (i = 0; i < IPU_DC_NUM_CHANNELS; i++) {
+		priv->channels[i].chno = i;
+		priv->channels[i].priv = priv;
+		priv->channels[i].base = priv->dc_reg + channel_offsets[i];
+	}
+
+	writel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(1) |
+			DC_WR_CH_CONF_PROG_DI_ID,
+			priv->channels[1].base + DC_WR_CH_CONF);
+	writel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(0),
+			priv->channels[5].base + DC_WR_CH_CONF);
+
+	writel(DC_GEN_SYNC_1_6_SYNC | DC_GEN_SYNC_PRIORITY_1,
+		priv->dc_reg + DC_GEN);
+
+	ipu->dc_priv = priv;
+
+	dev_dbg(dev, "DC base: 0x%08lx template base: 0x%08lx\n",
+			base, template_base);
+
+	/* rgb24 */
+	ipu_dc_map_clear(priv, IPU_DC_MAP_RGB24);
+	ipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 0, 7, 0xff); /* blue */
+	ipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 1, 15, 0xff); /* green */
+	ipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 2, 23, 0xff); /* red */
+
+	/* rgb565 */
+	ipu_dc_map_clear(priv, IPU_DC_MAP_RGB565);
+	ipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 0, 4, 0xf8); /* blue */
+	ipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 1, 10, 0xfc); /* green */
+	ipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 2, 15, 0xf8); /* red */
+
+	/* gbr24 */
+	ipu_dc_map_clear(priv, IPU_DC_MAP_GBR24);
+	ipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 2, 15, 0xff); /* green */
+	ipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 1, 7, 0xff); /* blue */
+	ipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 0, 23, 0xff); /* red */
+
+	/* bgr666 */
+	ipu_dc_map_clear(priv, IPU_DC_MAP_BGR666);
+	ipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 0, 5, 0xfc); /* blue */
+	ipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 1, 11, 0xfc); /* green */
+	ipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 2, 17, 0xfc); /* red */
+
+	/* lvds666 */
+	ipu_dc_map_clear(priv, IPU_DC_MAP_LVDS666);
+	ipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 0, 5, 0xfc); /* blue */
+	ipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 1, 13, 0xfc); /* green */
+	ipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 2, 21, 0xfc); /* red */
+
+	/* bgr24 */
+	ipu_dc_map_clear(priv, IPU_DC_MAP_BGR24);
+	ipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 2, 7, 0xff); /* red */
+	ipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 1, 15, 0xff); /* green */
+	ipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 0, 23, 0xff); /* blue */
+
+	return 0;
+}
+
+void ipu_dc_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-di.c b/drivers/gpu/imx/ipu-v3/ipu-di.c
new file mode 100644
index 0000000..d2f1bd9
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-di.c
@@ -0,0 +1,754 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+
+#include <video/imx-ipu-v3.h>
+#include "ipu-prv.h"
+
+struct ipu_di {
+	void __iomem *base;
+	int id;
+	u32 module;
+	struct clk *clk_di;	/* display input clock */
+	struct clk *clk_ipu;	/* IPU bus clock */
+	struct clk *clk_di_pixel; /* resulting pixel clock */
+	bool inuse;
+	struct ipu_soc *ipu;
+};
+
+static DEFINE_MUTEX(di_mutex);
+
+struct di_sync_config {
+	int run_count;
+	int run_src;
+	int offset_count;
+	int offset_src;
+	int repeat_count;
+	int cnt_clr_src;
+	int cnt_polarity_gen_en;
+	int cnt_polarity_clr_src;
+	int cnt_polarity_trigger_src;
+	int cnt_up;
+	int cnt_down;
+};
+
+enum di_pins {
+	DI_PIN11 = 0,
+	DI_PIN12 = 1,
+	DI_PIN13 = 2,
+	DI_PIN14 = 3,
+	DI_PIN15 = 4,
+	DI_PIN16 = 5,
+	DI_PIN17 = 6,
+	DI_PIN_CS = 7,
+
+	DI_PIN_SER_CLK = 0,
+	DI_PIN_SER_RS = 1,
+};
+
+enum di_sync_wave {
+	DI_SYNC_NONE = 0,
+	DI_SYNC_CLK = 1,
+	DI_SYNC_INT_HSYNC = 2,
+	DI_SYNC_HSYNC = 3,
+	DI_SYNC_VSYNC = 4,
+	DI_SYNC_DE = 6,
+
+	DI_SYNC_CNT1 = 2,	/* counter >= 2 only */
+	DI_SYNC_CNT4 = 5,	/* counter >= 5 only */
+	DI_SYNC_CNT5 = 6,	/* counter >= 6 only */
+};
+
+#define SYNC_WAVE 0
+
+#define DI_GENERAL		0x0000
+#define DI_BS_CLKGEN0		0x0004
+#define DI_BS_CLKGEN1		0x0008
+#define DI_SW_GEN0(gen)		(0x000c + 4 * ((gen) - 1))
+#define DI_SW_GEN1(gen)		(0x0030 + 4 * ((gen) - 1))
+#define DI_STP_REP(gen)		(0x0148 + 4 * (((gen) - 1)/2))
+#define DI_SYNC_AS_GEN		0x0054
+#define DI_DW_GEN(gen)		(0x0058 + 4 * (gen))
+#define DI_DW_SET(gen, set)	(0x0088 + 4 * ((gen) + 0xc * (set)))
+#define DI_SER_CONF		0x015c
+#define DI_SSC			0x0160
+#define DI_POL			0x0164
+#define DI_AW0			0x0168
+#define DI_AW1			0x016c
+#define DI_SCR_CONF		0x0170
+#define DI_STAT			0x0174
+
+#define DI_SW_GEN0_RUN_COUNT(x)			((x) << 19)
+#define DI_SW_GEN0_RUN_SRC(x)			((x) << 16)
+#define DI_SW_GEN0_OFFSET_COUNT(x)		((x) << 3)
+#define DI_SW_GEN0_OFFSET_SRC(x)		((x) << 0)
+
+#define DI_SW_GEN1_CNT_POL_GEN_EN(x)		((x) << 29)
+#define DI_SW_GEN1_CNT_CLR_SRC(x)		((x) << 25)
+#define DI_SW_GEN1_CNT_POL_TRIGGER_SRC(x)	((x) << 12)
+#define DI_SW_GEN1_CNT_POL_CLR_SRC(x)		((x) << 9)
+#define DI_SW_GEN1_CNT_DOWN(x)			((x) << 16)
+#define DI_SW_GEN1_CNT_UP(x)			(x)
+#define DI_SW_GEN1_AUTO_RELOAD			(0x10000000)
+
+#define DI_DW_GEN_ACCESS_SIZE_OFFSET		24
+#define DI_DW_GEN_COMPONENT_SIZE_OFFSET		16
+
+#define DI_GEN_POLARITY_1			(1 << 0)
+#define DI_GEN_POLARITY_2			(1 << 1)
+#define DI_GEN_POLARITY_3			(1 << 2)
+#define DI_GEN_POLARITY_4			(1 << 3)
+#define DI_GEN_POLARITY_5			(1 << 4)
+#define DI_GEN_POLARITY_6			(1 << 5)
+#define DI_GEN_POLARITY_7			(1 << 6)
+#define DI_GEN_POLARITY_8			(1 << 7)
+#define DI_GEN_POLARITY_DISP_CLK		(1 << 17)
+#define DI_GEN_DI_CLK_EXT			(1 << 20)
+#define DI_GEN_DI_VSYNC_EXT			(1 << 21)
+
+#define DI_POL_DRDY_DATA_POLARITY		(1 << 7)
+#define DI_POL_DRDY_POLARITY_15			(1 << 4)
+
+#define DI_VSYNC_SEL_OFFSET			13
+
+static inline u32 ipu_di_read(struct ipu_di *di, unsigned offset)
+{
+	return readl(di->base + offset);
+}
+
+static inline void ipu_di_write(struct ipu_di *di, u32 value, unsigned offset)
+{
+	writel(value, di->base + offset);
+}
+
+static void ipu_di_data_wave_config(struct ipu_di *di,
+				     int wave_gen,
+				     int access_size, int component_size)
+{
+	u32 reg;
+	reg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |
+	    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);
+	ipu_di_write(di, reg, DI_DW_GEN(wave_gen));
+}
+
+static void ipu_di_data_pin_config(struct ipu_di *di, int wave_gen, int di_pin,
+		int set, int up, int down)
+{
+	u32 reg;
+
+	reg = ipu_di_read(di, DI_DW_GEN(wave_gen));
+	reg &= ~(0x3 << (di_pin * 2));
+	reg |= set << (di_pin * 2);
+	ipu_di_write(di, reg, DI_DW_GEN(wave_gen));
+
+	ipu_di_write(di, (down << 16) | up, DI_DW_SET(wave_gen, set));
+}
+
+static void ipu_di_sync_config(struct ipu_di *di, struct di_sync_config *config,
+		int start, int count)
+{
+	u32 reg;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		struct di_sync_config *c = &config[i];
+		int wave_gen = start + i + 1;
+
+		if ((c->run_count >= 0x1000) || (c->offset_count >= 0x1000) ||
+				(c->repeat_count >= 0x1000) ||
+				(c->cnt_up >= 0x400) ||
+				(c->cnt_down >= 0x400)) {
+			dev_err(di->ipu->dev, "DI%d counters out of range.\n",
+					di->id);
+			return;
+		}
+
+		reg = DI_SW_GEN0_RUN_COUNT(c->run_count) |
+			DI_SW_GEN0_RUN_SRC(c->run_src) |
+			DI_SW_GEN0_OFFSET_COUNT(c->offset_count) |
+			DI_SW_GEN0_OFFSET_SRC(c->offset_src);
+		ipu_di_write(di, reg, DI_SW_GEN0(wave_gen));
+
+		reg = DI_SW_GEN1_CNT_POL_GEN_EN(c->cnt_polarity_gen_en) |
+			DI_SW_GEN1_CNT_CLR_SRC(c->cnt_clr_src) |
+			DI_SW_GEN1_CNT_POL_TRIGGER_SRC(
+					c->cnt_polarity_trigger_src) |
+			DI_SW_GEN1_CNT_POL_CLR_SRC(c->cnt_polarity_clr_src) |
+			DI_SW_GEN1_CNT_DOWN(c->cnt_down) |
+			DI_SW_GEN1_CNT_UP(c->cnt_up);
+
+		/* Enable auto reload */
+		if (c->repeat_count == 0)
+			reg |= DI_SW_GEN1_AUTO_RELOAD;
+
+		ipu_di_write(di, reg, DI_SW_GEN1(wave_gen));
+
+		reg = ipu_di_read(di, DI_STP_REP(wave_gen));
+		reg &= ~(0xffff << (16 * ((wave_gen - 1) & 0x1)));
+		reg |= c->repeat_count << (16 * ((wave_gen - 1) & 0x1));
+		ipu_di_write(di, reg, DI_STP_REP(wave_gen));
+	}
+}
+
+static void ipu_di_sync_config_interlaced(struct ipu_di *di,
+		struct ipu_di_signal_cfg *sig)
+{
+	u32 h_total = sig->mode.hactive + sig->mode.hsync_len +
+		sig->mode.hback_porch + sig->mode.hfront_porch;
+	u32 v_total = sig->mode.vactive + sig->mode.vsync_len +
+		sig->mode.vback_porch + sig->mode.vfront_porch;
+	struct di_sync_config cfg[] = {
+		{
+			/* 1: internal VSYNC for each frame */
+			.run_count = v_total * 2 - 1,
+			.run_src = 3,			/* == counter 7 */
+		}, {
+			/* PIN2: HSYNC waveform */
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_CLK,
+			.cnt_down = sig->mode.hsync_len * 2,
+		}, {
+			/* PIN3: VSYNC waveform */
+			.run_count = v_total - 1,
+			.run_src = 4,			/* == counter 7 */
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = 4,	/* == counter 7 */
+			.cnt_down = sig->mode.vsync_len * 2,
+			.cnt_clr_src = DI_SYNC_CNT1,
+		}, {
+			/* 4: Field */
+			.run_count = v_total / 2,
+			.run_src = DI_SYNC_HSYNC,
+			.offset_count = h_total / 2,
+			.offset_src = DI_SYNC_CLK,
+			.repeat_count = 2,
+			.cnt_clr_src = DI_SYNC_CNT1,
+		}, {
+			/* 5: Active lines */
+			.run_src = DI_SYNC_HSYNC,
+			.offset_count = (sig->mode.vsync_len +
+					 sig->mode.vback_porch) / 2,
+			.offset_src = DI_SYNC_HSYNC,
+			.repeat_count = sig->mode.vactive / 2,
+			.cnt_clr_src = DI_SYNC_CNT4,
+		}, {
+			/* 6: Active pixel, referenced by DC */
+			.run_src = DI_SYNC_CLK,
+			.offset_count = sig->mode.hsync_len +
+					sig->mode.hback_porch,
+			.offset_src = DI_SYNC_CLK,
+			.repeat_count = sig->mode.hactive,
+			.cnt_clr_src = DI_SYNC_CNT5,
+		}, {
+			/* 7: Half line HSYNC */
+			.run_count = h_total / 2 - 1,
+			.run_src = DI_SYNC_CLK,
+		}
+	};
+
+	ipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));
+
+	ipu_di_write(di, v_total / 2 - 1, DI_SCR_CONF);
+}
+
+static void ipu_di_sync_config_noninterlaced(struct ipu_di *di,
+		struct ipu_di_signal_cfg *sig, int div)
+{
+	u32 h_total = sig->mode.hactive + sig->mode.hsync_len +
+		sig->mode.hback_porch + sig->mode.hfront_porch;
+	u32 v_total = sig->mode.vactive + sig->mode.vsync_len +
+		sig->mode.vback_porch + sig->mode.vfront_porch;
+	struct di_sync_config cfg[] = {
+		{
+			/* 1: INT_HSYNC */
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+		} , {
+			/* PIN2: HSYNC */
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+			.offset_count = div * sig->v_to_h_sync,
+			.offset_src = DI_SYNC_CLK,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_CLK,
+			.cnt_down = sig->mode.hsync_len * 2,
+		} , {
+			/* PIN3: VSYNC */
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
+			.cnt_down = sig->mode.vsync_len * 2,
+		} , {
+			/* 4: Line Active */
+			.run_src = DI_SYNC_HSYNC,
+			.offset_count = sig->mode.vsync_len +
+					sig->mode.vback_porch,
+			.offset_src = DI_SYNC_HSYNC,
+			.repeat_count = sig->mode.vactive,
+			.cnt_clr_src = DI_SYNC_VSYNC,
+		} , {
+			/* 5: Pixel Active, referenced by DC */
+			.run_src = DI_SYNC_CLK,
+			.offset_count = sig->mode.hsync_len +
+					sig->mode.hback_porch,
+			.offset_src = DI_SYNC_CLK,
+			.repeat_count = sig->mode.hactive,
+			.cnt_clr_src = 5, /* Line Active */
+		} , {
+			/* unused */
+		} , {
+			/* unused */
+		} , {
+			/* unused */
+		} , {
+			/* unused */
+		},
+	};
+	/* can't use #7 and #8 for line active and pixel active counters */
+	struct di_sync_config cfg_vga[] = {
+		{
+			/* 1: INT_HSYNC */
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+		} , {
+			/* 2: VSYNC */
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+		} , {
+			/* 3: Line Active */
+			.run_src = DI_SYNC_INT_HSYNC,
+			.offset_count = sig->mode.vsync_len +
+					sig->mode.vback_porch,
+			.offset_src = DI_SYNC_INT_HSYNC,
+			.repeat_count = sig->mode.vactive,
+			.cnt_clr_src = 3 /* VSYNC */,
+		} , {
+			/* PIN4: HSYNC for VGA via TVEv2 on TQ MBa53 */
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+			.offset_count = div * sig->v_to_h_sync + 18, /* magic value from Freescale TVE driver */
+			.offset_src = DI_SYNC_CLK,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_CLK,
+			.cnt_down = sig->mode.hsync_len * 2,
+		} , {
+			/* 5: Pixel Active signal to DC */
+			.run_src = DI_SYNC_CLK,
+			.offset_count = sig->mode.hsync_len +
+					sig->mode.hback_porch,
+			.offset_src = DI_SYNC_CLK,
+			.repeat_count = sig->mode.hactive,
+			.cnt_clr_src = 4, /* Line Active */
+		} , {
+			/* PIN6: VSYNC for VGA via TVEv2 on TQ MBa53 */
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+			.offset_count = 1, /* magic value from Freescale TVE driver */
+			.offset_src = DI_SYNC_INT_HSYNC,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
+			.cnt_down = sig->mode.vsync_len * 2,
+		} , {
+			/* PIN4: HSYNC for VGA via TVEv2 on i.MX53-QSB */
+			.run_count = h_total - 1,
+			.run_src = DI_SYNC_CLK,
+			.offset_count = div * sig->v_to_h_sync + 18, /* magic value from Freescale TVE driver */
+			.offset_src = DI_SYNC_CLK,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_CLK,
+			.cnt_down = sig->mode.hsync_len * 2,
+		} , {
+			/* PIN6: VSYNC for VGA via TVEv2 on i.MX53-QSB */
+			.run_count = v_total - 1,
+			.run_src = DI_SYNC_INT_HSYNC,
+			.offset_count = 1, /* magic value from Freescale TVE driver */
+			.offset_src = DI_SYNC_INT_HSYNC,
+			.cnt_polarity_gen_en = 1,
+			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
+			.cnt_down = sig->mode.vsync_len * 2,
+		} , {
+			/* unused */
+		},
+	};
+
+	ipu_di_write(di, v_total - 1, DI_SCR_CONF);
+	if (sig->hsync_pin == 2 && sig->vsync_pin == 3)
+		ipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));
+	else
+		ipu_di_sync_config(di, cfg_vga, 0, ARRAY_SIZE(cfg_vga));
+}
+
+static void ipu_di_config_clock(struct ipu_di *di,
+	const struct ipu_di_signal_cfg *sig)
+{
+	struct clk *clk;
+	unsigned clkgen0;
+	uint32_t val;
+
+	if (sig->clkflags & IPU_DI_CLKMODE_EXT) {
+		/*
+		 * CLKMODE_EXT means we must use the DI clock: this is
+		 * needed for things like LVDS which needs to feed the
+		 * DI and LDB with the same pixel clock.
+		 */
+		clk = di->clk_di;
+
+		if (sig->clkflags & IPU_DI_CLKMODE_SYNC) {
+			/*
+			 * CLKMODE_SYNC means that we want the DI to be
+			 * clocked at the same rate as the parent clock.
+			 * This is needed (eg) for LDB which needs to be
+			 * fed with the same pixel clock.  We assume that
+			 * the LDB clock has already been set correctly.
+			 */
+			clkgen0 = 1 << 4;
+		} else {
+			/*
+			 * We can use the divider.  We should really have
+			 * a flag here indicating whether the bridge can
+			 * cope with a fractional divider or not.  For the
+			 * time being, let's go for simplicitly and
+			 * reliability.
+			 */
+			unsigned long in_rate;
+			unsigned div;
+
+			clk_set_rate(clk, sig->mode.pixelclock);
+
+			in_rate = clk_get_rate(clk);
+			div = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);
+			div = clamp(div, 1U, 255U);
+
+			clkgen0 = div << 4;
+		}
+	} else {
+		/*
+		 * For other interfaces, we can arbitarily select between
+		 * the DI specific clock and the internal IPU clock.  See
+		 * DI_GENERAL bit 20.  We select the IPU clock if it can
+		 * give us a clock rate within 1% of the requested frequency,
+		 * otherwise we use the DI clock.
+		 */
+		unsigned long rate, clkrate;
+		unsigned div, error;
+
+		clkrate = clk_get_rate(di->clk_ipu);
+		div = DIV_ROUND_CLOSEST(clkrate, sig->mode.pixelclock);
+		div = clamp(div, 1U, 255U);
+		rate = clkrate / div;
+
+		error = rate / (sig->mode.pixelclock / 1000);
+
+		dev_dbg(di->ipu->dev, "  IPU clock can give %lu with divider %u, error %d.%u%%\n",
+			rate, div, (signed)(error - 1000) / 10, error % 10);
+
+		/* Allow a 1% error */
+		if (error < 1010 && error >= 990) {
+			clk = di->clk_ipu;
+
+			clkgen0 = div << 4;
+		} else {
+			unsigned long in_rate;
+			unsigned div;
+
+			clk = di->clk_di;
+
+			clk_set_rate(clk, sig->mode.pixelclock);
+
+			in_rate = clk_get_rate(clk);
+			div = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);
+			div = clamp(div, 1U, 255U);
+
+			clkgen0 = div << 4;
+		}
+	}
+
+	di->clk_di_pixel = clk;
+
+	/* Set the divider */
+	ipu_di_write(di, clkgen0, DI_BS_CLKGEN0);
+
+	/*
+	 * Set the high/low periods.  Bits 24:16 give us the falling edge,
+	 * and bits 8:0 give the rising edge.  LSB is fraction, and is
+	 * based on the divider above.  We want a 50% duty cycle, so set
+	 * the falling edge to be half the divider.
+	 */
+	ipu_di_write(di, (clkgen0 >> 4) << 16, DI_BS_CLKGEN1);
+
+	/* Finally select the input clock */
+	val = ipu_di_read(di, DI_GENERAL) & ~DI_GEN_DI_CLK_EXT;
+	if (clk == di->clk_di)
+		val |= DI_GEN_DI_CLK_EXT;
+	ipu_di_write(di, val, DI_GENERAL);
+
+	dev_dbg(di->ipu->dev, "Want %luHz IPU %luHz DI %luHz using %s, %luHz\n",
+		sig->mode.pixelclock,
+		clk_get_rate(di->clk_ipu),
+		clk_get_rate(di->clk_di),
+		clk == di->clk_di ? "DI" : "IPU",
+		clk_get_rate(di->clk_di_pixel) / (clkgen0 >> 4));
+}
+
+/*
+ * This function is called to adjust a video mode to IPU restrictions.
+ * It is meant to be called from drm crtc mode_fixup() methods.
+ */
+int ipu_di_adjust_videomode(struct ipu_di *di, struct videomode *mode)
+{
+	u32 diff;
+
+	if (mode->vfront_porch >= 2)
+		return 0;
+
+	diff = 2 - mode->vfront_porch;
+
+	if (mode->vback_porch >= diff) {
+		mode->vfront_porch = 2;
+		mode->vback_porch -= diff;
+	} else if (mode->vsync_len > diff) {
+		mode->vfront_porch = 2;
+		mode->vsync_len = mode->vsync_len - diff;
+	} else {
+		dev_warn(di->ipu->dev, "failed to adjust videomode\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(di->ipu->dev, "videomode adapted for IPU restrictions\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_di_adjust_videomode);
+
+static u32 ipu_di_gen_polarity(int pin)
+{
+	switch (pin) {
+	case 1:
+		return DI_GEN_POLARITY_1;
+	case 2:
+		return DI_GEN_POLARITY_2;
+	case 3:
+		return DI_GEN_POLARITY_3;
+	case 4:
+		return DI_GEN_POLARITY_4;
+	case 5:
+		return DI_GEN_POLARITY_5;
+	case 6:
+		return DI_GEN_POLARITY_6;
+	case 7:
+		return DI_GEN_POLARITY_7;
+	case 8:
+		return DI_GEN_POLARITY_8;
+	}
+	return 0;
+}
+
+int ipu_di_init_sync_panel(struct ipu_di *di, struct ipu_di_signal_cfg *sig)
+{
+	u32 reg;
+	u32 di_gen, vsync_cnt;
+	u32 div;
+
+	dev_dbg(di->ipu->dev, "disp %d: panel size = %d x %d\n",
+		di->id, sig->mode.hactive, sig->mode.vactive);
+
+	dev_dbg(di->ipu->dev, "Clocks: IPU %luHz DI %luHz Needed %luHz\n",
+		clk_get_rate(di->clk_ipu),
+		clk_get_rate(di->clk_di),
+		sig->mode.pixelclock);
+
+	mutex_lock(&di_mutex);
+
+	ipu_di_config_clock(di, sig);
+
+	div = ipu_di_read(di, DI_BS_CLKGEN0) & 0xfff;
+	div = div / 16;		/* Now divider is integer portion */
+
+	/* Setup pixel clock timing */
+	/* Down time is half of period */
+	ipu_di_write(di, (div << 16), DI_BS_CLKGEN1);
+
+	ipu_di_data_wave_config(di, SYNC_WAVE, div - 1, div - 1);
+	ipu_di_data_pin_config(di, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);
+
+	di_gen = ipu_di_read(di, DI_GENERAL) & DI_GEN_DI_CLK_EXT;
+	di_gen |= DI_GEN_DI_VSYNC_EXT;
+
+	if (sig->mode.flags & DISPLAY_FLAGS_INTERLACED) {
+		ipu_di_sync_config_interlaced(di, sig);
+
+		/* set y_sel = 1 */
+		di_gen |= 0x10000000;
+
+		vsync_cnt = 3;
+	} else {
+		ipu_di_sync_config_noninterlaced(di, sig, div);
+
+		vsync_cnt = 3;
+		if (di->id == 1)
+			/*
+			 * TODO: change only for TVEv2, parallel display
+			 * uses pin 2 / 3
+			 */
+			if (!(sig->hsync_pin == 2 && sig->vsync_pin == 3))
+				vsync_cnt = 6;
+	}
+
+	if (sig->mode.flags & DISPLAY_FLAGS_HSYNC_HIGH)
+		di_gen |= ipu_di_gen_polarity(sig->hsync_pin);
+	if (sig->mode.flags & DISPLAY_FLAGS_VSYNC_HIGH)
+		di_gen |= ipu_di_gen_polarity(sig->vsync_pin);
+
+	if (sig->clk_pol)
+		di_gen |= DI_GEN_POLARITY_DISP_CLK;
+
+	ipu_di_write(di, di_gen, DI_GENERAL);
+
+	ipu_di_write(di, (--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,
+		     DI_SYNC_AS_GEN);
+
+	reg = ipu_di_read(di, DI_POL);
+	reg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);
+
+	if (sig->enable_pol)
+		reg |= DI_POL_DRDY_POLARITY_15;
+	if (sig->data_pol)
+		reg |= DI_POL_DRDY_DATA_POLARITY;
+
+	ipu_di_write(di, reg, DI_POL);
+
+	mutex_unlock(&di_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_di_init_sync_panel);
+
+int ipu_di_enable(struct ipu_di *di)
+{
+	int ret;
+
+	WARN_ON(IS_ERR(di->clk_di_pixel));
+
+	ret = clk_prepare_enable(di->clk_di_pixel);
+	if (ret)
+		return ret;
+
+	ipu_module_enable(di->ipu, di->module);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_di_enable);
+
+int ipu_di_disable(struct ipu_di *di)
+{
+	WARN_ON(IS_ERR(di->clk_di_pixel));
+
+	ipu_module_disable(di->ipu, di->module);
+
+	clk_disable_unprepare(di->clk_di_pixel);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_di_disable);
+
+int ipu_di_get_num(struct ipu_di *di)
+{
+	return di->id;
+}
+EXPORT_SYMBOL_GPL(ipu_di_get_num);
+
+static DEFINE_MUTEX(ipu_di_lock);
+
+struct ipu_di *ipu_di_get(struct ipu_soc *ipu, int disp)
+{
+	struct ipu_di *di;
+
+	if (disp > 1)
+		return ERR_PTR(-EINVAL);
+
+	di = ipu->di_priv[disp];
+
+	mutex_lock(&ipu_di_lock);
+
+	if (di->inuse) {
+		di = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
+	di->inuse = true;
+out:
+	mutex_unlock(&ipu_di_lock);
+
+	return di;
+}
+EXPORT_SYMBOL_GPL(ipu_di_get);
+
+void ipu_di_put(struct ipu_di *di)
+{
+	mutex_lock(&ipu_di_lock);
+
+	di->inuse = false;
+
+	mutex_unlock(&ipu_di_lock);
+}
+EXPORT_SYMBOL_GPL(ipu_di_put);
+
+int ipu_di_init(struct ipu_soc *ipu, struct device *dev, int id,
+		unsigned long base,
+		u32 module, struct clk *clk_ipu)
+{
+	struct ipu_di *di;
+
+	if (id > 1)
+		return -ENODEV;
+
+	di = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);
+	if (!di)
+		return -ENOMEM;
+
+	ipu->di_priv[id] = di;
+
+	di->clk_di = devm_clk_get(dev, id ? "di1" : "di0");
+	if (IS_ERR(di->clk_di))
+		return PTR_ERR(di->clk_di);
+
+	di->module = module;
+	di->id = id;
+	di->clk_ipu = clk_ipu;
+	di->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!di->base)
+		return -ENOMEM;
+
+	ipu_di_write(di, 0x10, DI_BS_CLKGEN0);
+
+	dev_dbg(dev, "DI%d base: 0x%08lx remapped to %p\n",
+			id, base, di->base);
+	di->inuse = false;
+	di->ipu = ipu;
+
+	return 0;
+}
+
+void ipu_di_exit(struct ipu_soc *ipu, int id)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-dmfc.c b/drivers/gpu/imx/ipu-v3/ipu-dmfc.c
new file mode 100644
index 0000000..a40f211
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-dmfc.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/export.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+
+#include <video/imx-ipu-v3.h>
+#include "ipu-prv.h"
+
+#define DMFC_RD_CHAN		0x0000
+#define DMFC_WR_CHAN		0x0004
+#define DMFC_WR_CHAN_DEF	0x0008
+#define DMFC_DP_CHAN		0x000c
+#define DMFC_DP_CHAN_DEF	0x0010
+#define DMFC_GENERAL1		0x0014
+#define DMFC_GENERAL2		0x0018
+#define DMFC_IC_CTRL		0x001c
+#define DMFC_WR_CHAN_ALT	0x0020
+#define DMFC_WR_CHAN_DEF_ALT	0x0024
+#define DMFC_DP_CHAN_ALT	0x0028
+#define DMFC_DP_CHAN_DEF_ALT	0x002c
+#define DMFC_GENERAL1_ALT	0x0030
+#define DMFC_STAT		0x0034
+
+#define DMFC_WR_CHAN_1_28		0
+#define DMFC_WR_CHAN_2_41		8
+#define DMFC_WR_CHAN_1C_42		16
+#define DMFC_WR_CHAN_2C_43		24
+
+#define DMFC_DP_CHAN_5B_23		0
+#define DMFC_DP_CHAN_5F_27		8
+#define DMFC_DP_CHAN_6B_24		16
+#define DMFC_DP_CHAN_6F_29		24
+
+struct dmfc_channel_data {
+	int		ipu_channel;
+	unsigned long	channel_reg;
+	unsigned long	shift;
+	unsigned	eot_shift;
+	unsigned	max_fifo_lines;
+};
+
+static const struct dmfc_channel_data dmfcdata[] = {
+	{
+		.ipu_channel	= IPUV3_CHANNEL_MEM_BG_SYNC,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_5B_23,
+		.eot_shift	= 20,
+		.max_fifo_lines	= 3,
+	}, {
+		.ipu_channel	= 24,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_6B_24,
+		.eot_shift	= 22,
+		.max_fifo_lines	= 1,
+	}, {
+		.ipu_channel	= IPUV3_CHANNEL_MEM_FG_SYNC,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_5F_27,
+		.eot_shift	= 21,
+		.max_fifo_lines	= 2,
+	}, {
+		.ipu_channel	= IPUV3_CHANNEL_MEM_DC_SYNC,
+		.channel_reg	= DMFC_WR_CHAN,
+		.shift		= DMFC_WR_CHAN_1_28,
+		.eot_shift	= 16,
+		.max_fifo_lines	= 2,
+	}, {
+		.ipu_channel	= 29,
+		.channel_reg	= DMFC_DP_CHAN,
+		.shift		= DMFC_DP_CHAN_6F_29,
+		.eot_shift	= 23,
+		.max_fifo_lines	= 1,
+	},
+};
+
+#define DMFC_NUM_CHANNELS	ARRAY_SIZE(dmfcdata)
+
+struct ipu_dmfc_priv;
+
+struct dmfc_channel {
+	unsigned			slots;
+	struct ipu_soc			*ipu;
+	struct ipu_dmfc_priv		*priv;
+	const struct dmfc_channel_data	*data;
+};
+
+struct ipu_dmfc_priv {
+	struct ipu_soc *ipu;
+	struct device *dev;
+	struct dmfc_channel channels[DMFC_NUM_CHANNELS];
+	struct mutex mutex;
+	void __iomem *base;
+	int use_count;
+};
+
+int ipu_dmfc_enable_channel(struct dmfc_channel *dmfc)
+{
+	struct ipu_dmfc_priv *priv = dmfc->priv;
+	mutex_lock(&priv->mutex);
+
+	if (!priv->use_count)
+		ipu_module_enable(priv->ipu, IPU_CONF_DMFC_EN);
+
+	priv->use_count++;
+
+	mutex_unlock(&priv->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dmfc_enable_channel);
+
+void ipu_dmfc_disable_channel(struct dmfc_channel *dmfc)
+{
+	struct ipu_dmfc_priv *priv = dmfc->priv;
+
+	mutex_lock(&priv->mutex);
+
+	priv->use_count--;
+
+	if (!priv->use_count)
+		ipu_module_disable(priv->ipu, IPU_CONF_DMFC_EN);
+
+	if (priv->use_count < 0)
+		priv->use_count = 0;
+
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dmfc_disable_channel);
+
+void ipu_dmfc_config_wait4eot(struct dmfc_channel *dmfc, int width)
+{
+	struct ipu_dmfc_priv *priv = dmfc->priv;
+	u32 dmfc_gen1;
+
+	mutex_lock(&priv->mutex);
+
+	dmfc_gen1 = readl(priv->base + DMFC_GENERAL1);
+
+	if ((dmfc->slots * 64 * 4) / width > dmfc->data->max_fifo_lines)
+		dmfc_gen1 |= 1 << dmfc->data->eot_shift;
+	else
+		dmfc_gen1 &= ~(1 << dmfc->data->eot_shift);
+
+	writel(dmfc_gen1, priv->base + DMFC_GENERAL1);
+
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dmfc_config_wait4eot);
+
+struct dmfc_channel *ipu_dmfc_get(struct ipu_soc *ipu, int ipu_channel)
+{
+	struct ipu_dmfc_priv *priv = ipu->dmfc_priv;
+	int i;
+
+	for (i = 0; i < DMFC_NUM_CHANNELS; i++)
+		if (dmfcdata[i].ipu_channel == ipu_channel)
+			return &priv->channels[i];
+	return ERR_PTR(-ENODEV);
+}
+EXPORT_SYMBOL_GPL(ipu_dmfc_get);
+
+void ipu_dmfc_put(struct dmfc_channel *dmfc)
+{
+}
+EXPORT_SYMBOL_GPL(ipu_dmfc_put);
+
+int ipu_dmfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,
+		struct clk *ipu_clk)
+{
+	struct ipu_dmfc_priv *priv;
+	int i;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!priv->base)
+		return -ENOMEM;
+
+	priv->dev = dev;
+	priv->ipu = ipu;
+	mutex_init(&priv->mutex);
+
+	ipu->dmfc_priv = priv;
+
+	for (i = 0; i < DMFC_NUM_CHANNELS; i++) {
+		priv->channels[i].priv = priv;
+		priv->channels[i].ipu = ipu;
+		priv->channels[i].data = &dmfcdata[i];
+
+		if (dmfcdata[i].ipu_channel == IPUV3_CHANNEL_MEM_BG_SYNC ||
+		    dmfcdata[i].ipu_channel == IPUV3_CHANNEL_MEM_FG_SYNC ||
+		    dmfcdata[i].ipu_channel == IPUV3_CHANNEL_MEM_DC_SYNC)
+			priv->channels[i].slots = 2;
+	}
+
+	writel(0x00000050, priv->base + DMFC_WR_CHAN);
+	writel(0x00005654, priv->base + DMFC_DP_CHAN);
+	writel(0x202020f6, priv->base + DMFC_WR_CHAN_DEF);
+	writel(0x2020f6f6, priv->base + DMFC_DP_CHAN_DEF);
+	writel(0x00000003, priv->base + DMFC_GENERAL1);
+
+	return 0;
+}
+
+void ipu_dmfc_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-dp.c b/drivers/gpu/imx/ipu-v3/ipu-dp.c
new file mode 100644
index 0000000..9b2b3fa
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-dp.c
@@ -0,0 +1,360 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/err.h>
+
+#include <video/imx-ipu-v3.h>
+#include "ipu-prv.h"
+
+#define DP_SYNC 0
+#define DP_ASYNC0 0x60
+#define DP_ASYNC1 0xBC
+
+#define DP_COM_CONF		0x0
+#define DP_GRAPH_WIND_CTRL	0x0004
+#define DP_FG_POS		0x0008
+#define DP_CSC_A_0		0x0044
+#define DP_CSC_A_1		0x0048
+#define DP_CSC_A_2		0x004C
+#define DP_CSC_A_3		0x0050
+#define DP_CSC_0		0x0054
+#define DP_CSC_1		0x0058
+
+#define DP_COM_CONF_FG_EN		(1 << 0)
+#define DP_COM_CONF_GWSEL		(1 << 1)
+#define DP_COM_CONF_GWAM		(1 << 2)
+#define DP_COM_CONF_GWCKE		(1 << 3)
+#define DP_COM_CONF_CSC_DEF_MASK	(3 << 8)
+#define DP_COM_CONF_CSC_DEF_OFFSET	8
+#define DP_COM_CONF_CSC_DEF_FG		(3 << 8)
+#define DP_COM_CONF_CSC_DEF_BG		(2 << 8)
+#define DP_COM_CONF_CSC_DEF_BOTH	(1 << 8)
+
+#define IPUV3_NUM_FLOWS		3
+
+struct ipu_dp_priv;
+
+struct ipu_dp {
+	u32 flow;
+	bool in_use;
+	bool foreground;
+	enum ipu_color_space in_cs;
+};
+
+struct ipu_flow {
+	struct ipu_dp foreground;
+	struct ipu_dp background;
+	enum ipu_color_space out_cs;
+	void __iomem *base;
+	struct ipu_dp_priv *priv;
+};
+
+struct ipu_dp_priv {
+	struct ipu_soc *ipu;
+	struct device *dev;
+	void __iomem *base;
+	struct ipu_flow flow[IPUV3_NUM_FLOWS];
+	struct mutex mutex;
+	int use_count;
+};
+
+static u32 ipu_dp_flow_base[] = {DP_SYNC, DP_ASYNC0, DP_ASYNC1};
+
+static inline struct ipu_flow *to_flow(struct ipu_dp *dp)
+{
+	if (dp->foreground)
+		return container_of(dp, struct ipu_flow, foreground);
+	else
+		return container_of(dp, struct ipu_flow, background);
+}
+
+int ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable,
+		u8 alpha, bool bg_chan)
+{
+	struct ipu_flow *flow = to_flow(dp);
+	struct ipu_dp_priv *priv = flow->priv;
+	u32 reg;
+
+	mutex_lock(&priv->mutex);
+
+	reg = readl(flow->base + DP_COM_CONF);
+	if (bg_chan)
+		reg &= ~DP_COM_CONF_GWSEL;
+	else
+		reg |= DP_COM_CONF_GWSEL;
+	writel(reg, flow->base + DP_COM_CONF);
+
+	if (enable) {
+		reg = readl(flow->base + DP_GRAPH_WIND_CTRL) & 0x00FFFFFFL;
+		writel(reg | ((u32) alpha << 24),
+			     flow->base + DP_GRAPH_WIND_CTRL);
+
+		reg = readl(flow->base + DP_COM_CONF);
+		writel(reg | DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);
+	} else {
+		reg = readl(flow->base + DP_COM_CONF);
+		writel(reg & ~DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);
+	}
+
+	ipu_srm_dp_update(priv->ipu, true);
+
+	mutex_unlock(&priv->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_set_global_alpha);
+
+int ipu_dp_set_window_pos(struct ipu_dp *dp, u16 x_pos, u16 y_pos)
+{
+	struct ipu_flow *flow = to_flow(dp);
+	struct ipu_dp_priv *priv = flow->priv;
+
+	writel((x_pos << 16) | y_pos, flow->base + DP_FG_POS);
+
+	ipu_srm_dp_update(priv->ipu, true);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_set_window_pos);
+
+static void ipu_dp_csc_init(struct ipu_flow *flow,
+		enum ipu_color_space in,
+		enum ipu_color_space out,
+		u32 place)
+{
+	u32 reg;
+
+	reg = readl(flow->base + DP_COM_CONF);
+	reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+
+	if (in == out) {
+		writel(reg, flow->base + DP_COM_CONF);
+		return;
+	}
+
+	if (in == IPUV3_COLORSPACE_RGB && out == IPUV3_COLORSPACE_YUV) {
+		writel(0x099 | (0x12d << 16), flow->base + DP_CSC_A_0);
+		writel(0x03a | (0x3a9 << 16), flow->base + DP_CSC_A_1);
+		writel(0x356 | (0x100 << 16), flow->base + DP_CSC_A_2);
+		writel(0x100 | (0x329 << 16), flow->base + DP_CSC_A_3);
+		writel(0x3d6 | (0x0000 << 16) | (2 << 30),
+				flow->base + DP_CSC_0);
+		writel(0x200 | (2 << 14) | (0x200 << 16) | (2 << 30),
+				flow->base + DP_CSC_1);
+	} else {
+		writel(0x095 | (0x000 << 16), flow->base + DP_CSC_A_0);
+		writel(0x0cc | (0x095 << 16), flow->base + DP_CSC_A_1);
+		writel(0x3ce | (0x398 << 16), flow->base + DP_CSC_A_2);
+		writel(0x095 | (0x0ff << 16), flow->base + DP_CSC_A_3);
+		writel(0x000 | (0x3e42 << 16) | (1 << 30),
+				flow->base + DP_CSC_0);
+		writel(0x10a | (1 << 14) | (0x3dd6 << 16) | (1 << 30),
+				flow->base + DP_CSC_1);
+	}
+
+	reg |= place;
+
+	writel(reg, flow->base + DP_COM_CONF);
+}
+
+int ipu_dp_setup_channel(struct ipu_dp *dp,
+		enum ipu_color_space in,
+		enum ipu_color_space out)
+{
+	struct ipu_flow *flow = to_flow(dp);
+	struct ipu_dp_priv *priv = flow->priv;
+
+	mutex_lock(&priv->mutex);
+
+	dp->in_cs = in;
+
+	if (!dp->foreground)
+		flow->out_cs = out;
+
+	if (flow->foreground.in_cs == flow->background.in_cs) {
+		/*
+		 * foreground and background are of same colorspace, put
+		 * colorspace converter after combining unit.
+		 */
+		ipu_dp_csc_init(flow, flow->foreground.in_cs, flow->out_cs,
+				DP_COM_CONF_CSC_DEF_BOTH);
+	} else {
+		if (flow->foreground.in_cs == flow->out_cs)
+			/*
+			 * foreground identical to output, apply color
+			 * conversion on background
+			 */
+			ipu_dp_csc_init(flow, flow->background.in_cs,
+					flow->out_cs, DP_COM_CONF_CSC_DEF_BG);
+		else
+			ipu_dp_csc_init(flow, flow->foreground.in_cs,
+					flow->out_cs, DP_COM_CONF_CSC_DEF_FG);
+	}
+
+	ipu_srm_dp_update(priv->ipu, true);
+
+	mutex_unlock(&priv->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_setup_channel);
+
+int ipu_dp_enable(struct ipu_soc *ipu)
+{
+	struct ipu_dp_priv *priv = ipu->dp_priv;
+
+	mutex_lock(&priv->mutex);
+
+	if (!priv->use_count)
+		ipu_module_enable(priv->ipu, IPU_CONF_DP_EN);
+
+	priv->use_count++;
+
+	mutex_unlock(&priv->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_enable);
+
+int ipu_dp_enable_channel(struct ipu_dp *dp)
+{
+	struct ipu_flow *flow = to_flow(dp);
+	struct ipu_dp_priv *priv = flow->priv;
+	u32 reg;
+
+	if (!dp->foreground)
+		return 0;
+
+	mutex_lock(&priv->mutex);
+
+	reg = readl(flow->base + DP_COM_CONF);
+	reg |= DP_COM_CONF_FG_EN;
+	writel(reg, flow->base + DP_COM_CONF);
+
+	ipu_srm_dp_update(priv->ipu, true);
+
+	mutex_unlock(&priv->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_enable_channel);
+
+void ipu_dp_disable_channel(struct ipu_dp *dp, bool sync)
+{
+	struct ipu_flow *flow = to_flow(dp);
+	struct ipu_dp_priv *priv = flow->priv;
+	u32 reg, csc;
+
+	if (!dp->foreground)
+		return;
+
+	mutex_lock(&priv->mutex);
+
+	reg = readl(flow->base + DP_COM_CONF);
+	csc = reg & DP_COM_CONF_CSC_DEF_MASK;
+	if (csc == DP_COM_CONF_CSC_DEF_FG)
+		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+
+	reg &= ~DP_COM_CONF_FG_EN;
+	writel(reg, flow->base + DP_COM_CONF);
+
+	writel(0, flow->base + DP_FG_POS);
+	ipu_srm_dp_update(priv->ipu, sync);
+
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dp_disable_channel);
+
+void ipu_dp_disable(struct ipu_soc *ipu)
+{
+	struct ipu_dp_priv *priv = ipu->dp_priv;
+
+	mutex_lock(&priv->mutex);
+
+	priv->use_count--;
+
+	if (!priv->use_count)
+		ipu_module_disable(priv->ipu, IPU_CONF_DP_EN);
+
+	if (priv->use_count < 0)
+		priv->use_count = 0;
+
+	mutex_unlock(&priv->mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_dp_disable);
+
+struct ipu_dp *ipu_dp_get(struct ipu_soc *ipu, unsigned int flow)
+{
+	struct ipu_dp_priv *priv = ipu->dp_priv;
+	struct ipu_dp *dp;
+
+	if ((flow >> 1) >= IPUV3_NUM_FLOWS)
+		return ERR_PTR(-EINVAL);
+
+	if (flow & 1)
+		dp = &priv->flow[flow >> 1].foreground;
+	else
+		dp = &priv->flow[flow >> 1].background;
+
+	if (dp->in_use)
+		return ERR_PTR(-EBUSY);
+
+	dp->in_use = true;
+
+	return dp;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_get);
+
+void ipu_dp_put(struct ipu_dp *dp)
+{
+	dp->in_use = false;
+}
+EXPORT_SYMBOL_GPL(ipu_dp_put);
+
+int ipu_dp_init(struct ipu_soc *ipu, struct device *dev, unsigned long base)
+{
+	struct ipu_dp_priv *priv;
+	int i;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->dev = dev;
+	priv->ipu = ipu;
+
+	ipu->dp_priv = priv;
+
+	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!priv->base)
+		return -ENOMEM;
+
+	mutex_init(&priv->mutex);
+
+	for (i = 0; i < IPUV3_NUM_FLOWS; i++) {
+		priv->flow[i].foreground.foreground = true;
+		priv->flow[i].base = priv->base + ipu_dp_flow_base[i];
+		priv->flow[i].priv = priv;
+	}
+
+	return 0;
+}
+
+void ipu_dp_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-ic.c b/drivers/gpu/imx/ipu-v3/ipu-ic.c
new file mode 100644
index 0000000..67cc820
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-ic.c
@@ -0,0 +1,801 @@
+/*
+ * Copyright (C) 2012-2014 Mentor Graphics Inc.
+ * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/bitrev.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/sizes.h>
+#include "ipu-prv.h"
+
+/* IC Register Offsets */
+#define IC_CONF                 0x0000
+#define IC_PRP_ENC_RSC          0x0004
+#define IC_PRP_VF_RSC           0x0008
+#define IC_PP_RSC               0x000C
+#define IC_CMBP_1               0x0010
+#define IC_CMBP_2               0x0014
+#define IC_IDMAC_1              0x0018
+#define IC_IDMAC_2              0x001C
+#define IC_IDMAC_3              0x0020
+#define IC_IDMAC_4              0x0024
+
+/* IC Register Fields */
+#define IC_CONF_PRPENC_EN       (1 << 0)
+#define IC_CONF_PRPENC_CSC1     (1 << 1)
+#define IC_CONF_PRPENC_ROT_EN   (1 << 2)
+#define IC_CONF_PRPVF_EN        (1 << 8)
+#define IC_CONF_PRPVF_CSC1      (1 << 9)
+#define IC_CONF_PRPVF_CSC2      (1 << 10)
+#define IC_CONF_PRPVF_CMB       (1 << 11)
+#define IC_CONF_PRPVF_ROT_EN    (1 << 12)
+#define IC_CONF_PP_EN           (1 << 16)
+#define IC_CONF_PP_CSC1         (1 << 17)
+#define IC_CONF_PP_CSC2         (1 << 18)
+#define IC_CONF_PP_CMB          (1 << 19)
+#define IC_CONF_PP_ROT_EN       (1 << 20)
+#define IC_CONF_IC_GLB_LOC_A    (1 << 28)
+#define IC_CONF_KEY_COLOR_EN    (1 << 29)
+#define IC_CONF_RWS_EN          (1 << 30)
+#define IC_CONF_CSI_MEM_WR_EN   (1 << 31)
+
+#define IC_IDMAC_1_CB0_BURST_16         (1 << 0)
+#define IC_IDMAC_1_CB1_BURST_16         (1 << 1)
+#define IC_IDMAC_1_CB2_BURST_16         (1 << 2)
+#define IC_IDMAC_1_CB3_BURST_16         (1 << 3)
+#define IC_IDMAC_1_CB4_BURST_16         (1 << 4)
+#define IC_IDMAC_1_CB5_BURST_16         (1 << 5)
+#define IC_IDMAC_1_CB6_BURST_16         (1 << 6)
+#define IC_IDMAC_1_CB7_BURST_16         (1 << 7)
+#define IC_IDMAC_1_PRPENC_ROT_MASK      (0x7 << 11)
+#define IC_IDMAC_1_PRPENC_ROT_OFFSET    11
+#define IC_IDMAC_1_PRPVF_ROT_MASK       (0x7 << 14)
+#define IC_IDMAC_1_PRPVF_ROT_OFFSET     14
+#define IC_IDMAC_1_PP_ROT_MASK          (0x7 << 17)
+#define IC_IDMAC_1_PP_ROT_OFFSET        17
+#define IC_IDMAC_1_PP_FLIP_RS           (1 << 22)
+#define IC_IDMAC_1_PRPVF_FLIP_RS        (1 << 21)
+#define IC_IDMAC_1_PRPENC_FLIP_RS       (1 << 20)
+
+#define IC_IDMAC_2_PRPENC_HEIGHT_MASK   (0x3ff << 0)
+#define IC_IDMAC_2_PRPENC_HEIGHT_OFFSET 0
+#define IC_IDMAC_2_PRPVF_HEIGHT_MASK    (0x3ff << 10)
+#define IC_IDMAC_2_PRPVF_HEIGHT_OFFSET  10
+#define IC_IDMAC_2_PP_HEIGHT_MASK       (0x3ff << 20)
+#define IC_IDMAC_2_PP_HEIGHT_OFFSET     20
+
+#define IC_IDMAC_3_PRPENC_WIDTH_MASK    (0x3ff << 0)
+#define IC_IDMAC_3_PRPENC_WIDTH_OFFSET  0
+#define IC_IDMAC_3_PRPVF_WIDTH_MASK     (0x3ff << 10)
+#define IC_IDMAC_3_PRPVF_WIDTH_OFFSET   10
+#define IC_IDMAC_3_PP_WIDTH_MASK        (0x3ff << 20)
+#define IC_IDMAC_3_PP_WIDTH_OFFSET      20
+
+struct ic_task_regoffs {
+	u32 rsc;
+	u32 tpmem_csc[2];
+};
+
+struct ic_task_bitfields {
+	u32 ic_conf_en;
+	u32 ic_conf_rot_en;
+	u32 ic_conf_cmb_en;
+	u32 ic_conf_csc1_en;
+	u32 ic_conf_csc2_en;
+	u32 ic_cmb_galpha_bit;
+};
+
+static const struct ic_task_regoffs ic_task_reg[IC_NUM_TASKS] = {
+	[IC_TASK_ENCODER] = {
+		.rsc = IC_PRP_ENC_RSC,
+		.tpmem_csc = {0x2008, 0},
+	},
+	[IC_TASK_VIEWFINDER] = {
+		.rsc = IC_PRP_VF_RSC,
+		.tpmem_csc = {0x4028, 0x4040},
+	},
+	[IC_TASK_POST_PROCESSOR] = {
+		.rsc = IC_PP_RSC,
+		.tpmem_csc = {0x6060, 0x6078},
+	},
+};
+
+static const struct ic_task_bitfields ic_task_bit[IC_NUM_TASKS] = {
+	[IC_TASK_ENCODER] = {
+		.ic_conf_en = IC_CONF_PRPENC_EN,
+		.ic_conf_rot_en = IC_CONF_PRPENC_ROT_EN,
+		.ic_conf_cmb_en = 0,    /* NA */
+		.ic_conf_csc1_en = IC_CONF_PRPENC_CSC1,
+		.ic_conf_csc2_en = 0,   /* NA */
+		.ic_cmb_galpha_bit = 0, /* NA */
+	},
+	[IC_TASK_VIEWFINDER] = {
+		.ic_conf_en = IC_CONF_PRPVF_EN,
+		.ic_conf_rot_en = IC_CONF_PRPVF_ROT_EN,
+		.ic_conf_cmb_en = IC_CONF_PRPVF_CMB,
+		.ic_conf_csc1_en = IC_CONF_PRPVF_CSC1,
+		.ic_conf_csc2_en = IC_CONF_PRPVF_CSC2,
+		.ic_cmb_galpha_bit = 0,
+	},
+	[IC_TASK_POST_PROCESSOR] = {
+		.ic_conf_en = IC_CONF_PP_EN,
+		.ic_conf_rot_en = IC_CONF_PP_ROT_EN,
+		.ic_conf_cmb_en = IC_CONF_PP_CMB,
+		.ic_conf_csc1_en = IC_CONF_PP_CSC1,
+		.ic_conf_csc2_en = IC_CONF_PP_CSC2,
+		.ic_cmb_galpha_bit = 8,
+	},
+};
+
+struct ipu_ic_priv;
+
+struct ipu_ic {
+	enum ipu_ic_task task;
+	const struct ic_task_regoffs *reg;
+	const struct ic_task_bitfields *bit;
+
+	enum ipu_color_space in_cs, g_in_cs;
+	enum ipu_color_space out_cs;
+	bool graphics;
+	bool rotation;
+	bool in_use;
+
+	struct ipu_ic_priv *priv;
+};
+
+struct ipu_ic_priv {
+	void __iomem *base;
+	void __iomem *tpmem_base;
+	spinlock_t lock;
+	struct ipu_soc *ipu;
+	int use_count;
+	int irt_use_count;
+	struct ipu_ic task[IC_NUM_TASKS];
+};
+
+static inline u32 ipu_ic_read(struct ipu_ic *ic, unsigned offset)
+{
+	return readl(ic->priv->base + offset);
+}
+
+static inline void ipu_ic_write(struct ipu_ic *ic, u32 value, unsigned offset)
+{
+	writel(value, ic->priv->base + offset);
+}
+
+struct ic_csc_params {
+	s16 coeff[3][3];	/* signed 9-bit integer coefficients */
+	s16 offset[3];		/* signed 11+2-bit fixed point offset */
+	u8 scale:2;		/* scale coefficients * 2^(scale-1) */
+	bool sat:1;		/* saturate to (16, 235(Y) / 240(U, V)) */
+};
+
+/*
+ * Y = R *  .299 + G *  .587 + B *  .114;
+ * U = R * -.169 + G * -.332 + B *  .500 + 128.;
+ * V = R *  .500 + G * -.419 + B * -.0813 + 128.;
+ */
+static const struct ic_csc_params ic_csc_rgb2ycbcr = {
+	.coeff = {
+		{ 77, 150, 29 },
+		{ 469, 427, 128 },
+		{ 128, 405, 491 },
+	},
+	.offset = { 0, 512, 512 },
+	.scale = 1,
+};
+
+/* transparent RGB->RGB matrix for graphics combining */
+static const struct ic_csc_params ic_csc_rgb2rgb = {
+	.coeff = {
+		{ 128, 0, 0 },
+		{ 0, 128, 0 },
+		{ 0, 0, 128 },
+	},
+	.scale = 2,
+};
+
+/*
+ * R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+ * G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+ * B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128);
+ */
+static const struct ic_csc_params ic_csc_ycbcr2rgb = {
+	.coeff = {
+		{ 149, 0, 204 },
+		{ 149, 462, 408 },
+		{ 149, 255, 0 },
+	},
+	.offset = { -446, 266, -554 },
+	.scale = 2,
+};
+
+static int init_csc(struct ipu_ic *ic,
+		    enum ipu_color_space inf,
+		    enum ipu_color_space outf,
+		    int csc_index)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	const struct ic_csc_params *params;
+	u32 __iomem *base;
+	const u16 (*c)[3];
+	const u16 *a;
+	u32 param;
+
+	base = (u32 __iomem *)
+		(priv->tpmem_base + ic->reg->tpmem_csc[csc_index]);
+
+	if (inf == IPUV3_COLORSPACE_YUV && outf == IPUV3_COLORSPACE_RGB)
+		params = &ic_csc_ycbcr2rgb;
+	else if (inf == IPUV3_COLORSPACE_RGB && outf == IPUV3_COLORSPACE_YUV)
+		params = &ic_csc_rgb2ycbcr;
+	else if (inf == IPUV3_COLORSPACE_RGB && outf == IPUV3_COLORSPACE_RGB)
+		params = &ic_csc_rgb2rgb;
+	else {
+		dev_err(priv->ipu->dev, "Unsupported color space conversion\n");
+		return -EINVAL;
+	}
+
+	/* Cast to unsigned */
+	c = (const u16 (*)[3])params->coeff;
+	a = (const u16 *)params->offset;
+
+	param = ((a[0] & 0x1f) << 27) | ((c[0][0] & 0x1ff) << 18) |
+		((c[1][1] & 0x1ff) << 9) | (c[2][2] & 0x1ff);
+	writel(param, base++);
+
+	param = ((a[0] & 0x1fe0) >> 5) | (params->scale << 8) |
+		(params->sat << 9);
+	writel(param, base++);
+
+	param = ((a[1] & 0x1f) << 27) | ((c[0][1] & 0x1ff) << 18) |
+		((c[1][0] & 0x1ff) << 9) | (c[2][0] & 0x1ff);
+	writel(param, base++);
+
+	param = ((a[1] & 0x1fe0) >> 5);
+	writel(param, base++);
+
+	param = ((a[2] & 0x1f) << 27) | ((c[0][2] & 0x1ff) << 18) |
+		((c[1][2] & 0x1ff) << 9) | (c[2][1] & 0x1ff);
+	writel(param, base++);
+
+	param = ((a[2] & 0x1fe0) >> 5);
+	writel(param, base++);
+
+	return 0;
+}
+
+static int calc_resize_coeffs(struct ipu_ic *ic,
+			      u32 in_size, u32 out_size,
+			      u32 *resize_coeff,
+			      u32 *downsize_coeff)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	struct ipu_soc *ipu = priv->ipu;
+	u32 temp_size, temp_downsize;
+
+	/*
+	 * Input size cannot be more than 4096, and output size cannot
+	 * be more than 1024
+	 */
+	if (in_size > 4096) {
+		dev_err(ipu->dev, "Unsupported resize (in_size > 4096)\n");
+		return -EINVAL;
+	}
+	if (out_size > 1024) {
+		dev_err(ipu->dev, "Unsupported resize (out_size > 1024)\n");
+		return -EINVAL;
+	}
+
+	/* Cannot downsize more than 4:1 */
+	if ((out_size << 2) < in_size) {
+		dev_err(ipu->dev, "Unsupported downsize\n");
+		return -EINVAL;
+	}
+
+	/* Compute downsizing coefficient */
+	temp_downsize = 0;
+	temp_size = in_size;
+	while (((temp_size > 1024) || (temp_size >= out_size * 2)) &&
+	       (temp_downsize < 2)) {
+		temp_size >>= 1;
+		temp_downsize++;
+	}
+	*downsize_coeff = temp_downsize;
+
+	/*
+	 * compute resizing coefficient using the following equation:
+	 * resize_coeff = M * (SI - 1) / (SO - 1)
+	 * where M = 2^13, SI = input size, SO = output size
+	 */
+	*resize_coeff = (8192L * (temp_size - 1)) / (out_size - 1);
+	if (*resize_coeff >= 16384L) {
+		dev_err(ipu->dev, "Warning! Overflow on resize coeff.\n");
+		*resize_coeff = 0x3FFF;
+	}
+
+	return 0;
+}
+
+void ipu_ic_task_enable(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	unsigned long flags;
+	u32 ic_conf;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ic_conf = ipu_ic_read(ic, IC_CONF);
+
+	ic_conf |= ic->bit->ic_conf_en;
+
+	if (ic->rotation)
+		ic_conf |= ic->bit->ic_conf_rot_en;
+
+	if (ic->in_cs != ic->out_cs)
+		ic_conf |= ic->bit->ic_conf_csc1_en;
+
+	if (ic->graphics) {
+		ic_conf |= ic->bit->ic_conf_cmb_en;
+		ic_conf |= ic->bit->ic_conf_csc1_en;
+
+		if (ic->g_in_cs != ic->out_cs)
+			ic_conf |= ic->bit->ic_conf_csc2_en;
+	}
+
+	ipu_ic_write(ic, ic_conf, IC_CONF);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_ic_task_enable);
+
+void ipu_ic_task_disable(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	unsigned long flags;
+	u32 ic_conf;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ic_conf = ipu_ic_read(ic, IC_CONF);
+
+	ic_conf &= ~(ic->bit->ic_conf_en |
+		     ic->bit->ic_conf_csc1_en |
+		     ic->bit->ic_conf_rot_en);
+	if (ic->bit->ic_conf_csc2_en)
+		ic_conf &= ~ic->bit->ic_conf_csc2_en;
+	if (ic->bit->ic_conf_cmb_en)
+		ic_conf &= ~ic->bit->ic_conf_cmb_en;
+
+	ipu_ic_write(ic, ic_conf, IC_CONF);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_ic_task_disable);
+
+int ipu_ic_task_graphics_init(struct ipu_ic *ic,
+			      enum ipu_color_space in_g_cs,
+			      bool galpha_en, u32 galpha,
+			      bool colorkey_en, u32 colorkey)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	unsigned long flags;
+	u32 reg, ic_conf;
+	int ret = 0;
+
+	if (ic->task == IC_TASK_ENCODER)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ic_conf = ipu_ic_read(ic, IC_CONF);
+
+	if (!(ic_conf & ic->bit->ic_conf_csc1_en)) {
+		/* need transparent CSC1 conversion */
+		ret = init_csc(ic, IPUV3_COLORSPACE_RGB,
+			       IPUV3_COLORSPACE_RGB, 0);
+		if (ret)
+			goto unlock;
+	}
+
+	ic->g_in_cs = in_g_cs;
+
+	if (ic->g_in_cs != ic->out_cs) {
+		ret = init_csc(ic, ic->g_in_cs, ic->out_cs, 1);
+		if (ret)
+			goto unlock;
+	}
+
+	if (galpha_en) {
+		ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		reg = ipu_ic_read(ic, IC_CMBP_1);
+		reg &= ~(0xff << ic->bit->ic_cmb_galpha_bit);
+		reg |= (galpha << ic->bit->ic_cmb_galpha_bit);
+		ipu_ic_write(ic, reg, IC_CMBP_1);
+	} else
+		ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+	if (colorkey_en) {
+		ic_conf |= IC_CONF_KEY_COLOR_EN;
+		ipu_ic_write(ic, colorkey, IC_CMBP_2);
+	} else
+		ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+
+	ipu_ic_write(ic, ic_conf, IC_CONF);
+
+	ic->graphics = true;
+unlock:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_ic_task_graphics_init);
+
+int ipu_ic_task_init(struct ipu_ic *ic,
+		     int in_width, int in_height,
+		     int out_width, int out_height,
+		     enum ipu_color_space in_cs,
+		     enum ipu_color_space out_cs)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	u32 reg, downsize_coeff, resize_coeff;
+	unsigned long flags;
+	int ret = 0;
+
+	/* Setup vertical resizing */
+	ret = calc_resize_coeffs(ic, in_height, out_height,
+				 &resize_coeff, &downsize_coeff);
+	if (ret)
+		return ret;
+
+	reg = (downsize_coeff << 30) | (resize_coeff << 16);
+
+	/* Setup horizontal resizing */
+	ret = calc_resize_coeffs(ic, in_width, out_width,
+				 &resize_coeff, &downsize_coeff);
+	if (ret)
+		return ret;
+
+	reg |= (downsize_coeff << 14) | resize_coeff;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ipu_ic_write(ic, reg, ic->reg->rsc);
+
+	/* Setup color space conversion */
+	ic->in_cs = in_cs;
+	ic->out_cs = out_cs;
+
+	if (ic->in_cs != ic->out_cs) {
+		ret = init_csc(ic, ic->in_cs, ic->out_cs, 0);
+		if (ret)
+			goto unlock;
+	}
+
+unlock:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_ic_task_init);
+
+int ipu_ic_task_idma_init(struct ipu_ic *ic, struct ipuv3_channel *channel,
+			  u32 width, u32 height, int burst_size,
+			  enum ipu_rotate_mode rot)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	struct ipu_soc *ipu = priv->ipu;
+	u32 ic_idmac_1, ic_idmac_2, ic_idmac_3;
+	u32 temp_rot = bitrev8(rot) >> 5;
+	bool need_hor_flip = false;
+	unsigned long flags;
+	int ret = 0;
+
+	if ((burst_size != 8) && (burst_size != 16)) {
+		dev_err(ipu->dev, "Illegal burst length for IC\n");
+		return -EINVAL;
+	}
+
+	width--;
+	height--;
+
+	if (temp_rot & 0x2)	/* Need horizontal flip */
+		need_hor_flip = true;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ic_idmac_1 = ipu_ic_read(ic, IC_IDMAC_1);
+	ic_idmac_2 = ipu_ic_read(ic, IC_IDMAC_2);
+	ic_idmac_3 = ipu_ic_read(ic, IC_IDMAC_3);
+
+	switch (channel->num) {
+	case IPUV3_CHANNEL_IC_PP_MEM:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PP_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PP_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;
+		break;
+	case IPUV3_CHANNEL_MEM_IC_PP:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;
+		break;
+	case IPUV3_CHANNEL_MEM_ROT_PP:
+		ic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;
+		break;
+	case IPUV3_CHANNEL_MEM_IC_PRP_VF:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB6_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB6_BURST_16;
+		break;
+	case IPUV3_CHANNEL_IC_PRP_ENC_MEM:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB0_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB0_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PRPENC_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PRPENC_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PRPENC_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PRPENC_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PRPENC_WIDTH_OFFSET;
+		break;
+	case IPUV3_CHANNEL_MEM_ROT_ENC:
+		ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPENC_ROT_OFFSET;
+		break;
+	case IPUV3_CHANNEL_IC_PRP_VF_MEM:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB1_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB1_BURST_16;
+
+		if (need_hor_flip)
+			ic_idmac_1 |= IC_IDMAC_1_PRPVF_FLIP_RS;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_FLIP_RS;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PRPVF_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PRPVF_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PRPVF_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PRPVF_WIDTH_OFFSET;
+		break;
+	case IPUV3_CHANNEL_MEM_ROT_VF:
+		ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPVF_ROT_OFFSET;
+		break;
+	case IPUV3_CHANNEL_G_MEM_IC_PRP_VF:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB3_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB3_BURST_16;
+		break;
+	case IPUV3_CHANNEL_G_MEM_IC_PP:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB4_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB4_BURST_16;
+		break;
+	case IPUV3_CHANNEL_VDI_MEM_IC_VF:
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB7_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB7_BURST_16;
+		break;
+	default:
+		goto unlock;
+	}
+
+	ipu_ic_write(ic, ic_idmac_1, IC_IDMAC_1);
+	ipu_ic_write(ic, ic_idmac_2, IC_IDMAC_2);
+	ipu_ic_write(ic, ic_idmac_3, IC_IDMAC_3);
+
+	if (ipu_rot_mode_is_irt(rot))
+		ic->rotation = true;
+
+unlock:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_ic_task_idma_init);
+
+static void ipu_irt_enable(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+
+	if (!priv->irt_use_count)
+		ipu_module_enable(priv->ipu, IPU_CONF_ROT_EN);
+
+	priv->irt_use_count++;
+}
+
+static void ipu_irt_disable(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+
+	if (priv->irt_use_count) {
+		if (!--priv->irt_use_count)
+			ipu_module_disable(priv->ipu, IPU_CONF_ROT_EN);
+	}
+}
+
+int ipu_ic_enable(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!priv->use_count)
+		ipu_module_enable(priv->ipu, IPU_CONF_IC_EN);
+
+	priv->use_count++;
+
+	if (ic->rotation)
+		ipu_irt_enable(ic);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_ic_enable);
+
+int ipu_ic_disable(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	priv->use_count--;
+
+	if (!priv->use_count)
+		ipu_module_disable(priv->ipu, IPU_CONF_IC_EN);
+
+	if (priv->use_count < 0)
+		priv->use_count = 0;
+
+	if (ic->rotation)
+		ipu_irt_disable(ic);
+
+	ic->rotation = ic->graphics = false;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_ic_disable);
+
+struct ipu_ic *ipu_ic_get(struct ipu_soc *ipu, enum ipu_ic_task task)
+{
+	struct ipu_ic_priv *priv = ipu->ic_priv;
+	unsigned long flags;
+	struct ipu_ic *ic, *ret;
+
+	if (task >= IC_NUM_TASKS)
+		return ERR_PTR(-EINVAL);
+
+	ic = &priv->task[task];
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (ic->in_use) {
+		ret = ERR_PTR(-EBUSY);
+		goto unlock;
+	}
+
+	ic->in_use = true;
+	ret = ic;
+
+unlock:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_ic_get);
+
+void ipu_ic_put(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	ic->in_use = false;
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_ic_put);
+
+int ipu_ic_init(struct ipu_soc *ipu, struct device *dev,
+		unsigned long base, unsigned long tpmem_base)
+{
+	struct ipu_ic_priv *priv;
+	int i;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ipu->ic_priv = priv;
+
+	spin_lock_init(&priv->lock);
+	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!priv->base)
+		return -ENOMEM;
+	priv->tpmem_base = devm_ioremap(dev, tpmem_base, SZ_64K);
+	if (!priv->tpmem_base)
+		return -ENOMEM;
+
+	dev_dbg(dev, "IC base: 0x%08lx remapped to %p\n", base, priv->base);
+
+	priv->ipu = ipu;
+
+	for (i = 0; i < IC_NUM_TASKS; i++) {
+		priv->task[i].task = i;
+		priv->task[i].priv = priv;
+		priv->task[i].reg = &ic_task_reg[i];
+		priv->task[i].bit = &ic_task_bit[i];
+	}
+
+	return 0;
+}
+
+void ipu_ic_exit(struct ipu_soc *ipu)
+{
+}
+
+void ipu_ic_dump(struct ipu_ic *ic)
+{
+	struct ipu_ic_priv *priv = ic->priv;
+	struct ipu_soc *ipu = priv->ipu;
+
+	dev_dbg(ipu->dev, "IC_CONF = \t0x%08X\n",
+		ipu_ic_read(ic, IC_CONF));
+	dev_dbg(ipu->dev, "IC_PRP_ENC_RSC = \t0x%08X\n",
+		ipu_ic_read(ic, IC_PRP_ENC_RSC));
+	dev_dbg(ipu->dev, "IC_PRP_VF_RSC = \t0x%08X\n",
+		ipu_ic_read(ic, IC_PRP_VF_RSC));
+	dev_dbg(ipu->dev, "IC_PP_RSC = \t0x%08X\n",
+		ipu_ic_read(ic, IC_PP_RSC));
+	dev_dbg(ipu->dev, "IC_CMBP_1 = \t0x%08X\n",
+		ipu_ic_read(ic, IC_CMBP_1));
+	dev_dbg(ipu->dev, "IC_CMBP_2 = \t0x%08X\n",
+		ipu_ic_read(ic, IC_CMBP_2));
+	dev_dbg(ipu->dev, "IC_IDMAC_1 = \t0x%08X\n",
+		ipu_ic_read(ic, IC_IDMAC_1));
+	dev_dbg(ipu->dev, "IC_IDMAC_2 = \t0x%08X\n",
+		ipu_ic_read(ic, IC_IDMAC_2));
+	dev_dbg(ipu->dev, "IC_IDMAC_3 = \t0x%08X\n",
+		ipu_ic_read(ic, IC_IDMAC_3));
+	dev_dbg(ipu->dev, "IC_IDMAC_4 = \t0x%08X\n",
+		ipu_ic_read(ic, IC_IDMAC_4));
+}
+EXPORT_SYMBOL_GPL(ipu_ic_dump);
diff --git a/drivers/gpu/imx/ipu-v3/ipu-image-convert.c b/drivers/gpu/imx/ipu-v3/ipu-image-convert.c
new file mode 100644
index 0000000..a5e33d5
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-image-convert.c
@@ -0,0 +1,1718 @@
+/*
+ * Copyright (C) 2012-2016 Mentor Graphics Inc.
+ *
+ * Queued image conversion support, with tiling and rotation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <video/imx-ipu-image-convert.h>
+#include "ipu-prv.h"
+
+/*
+ * The IC Resizer has a restriction that the output frame from the
+ * resizer must be 1024 or less in both width (pixels) and height
+ * (lines).
+ *
+ * The image converter attempts to split up a conversion when
+ * the desired output (converted) frame resolution exceeds the
+ * IC resizer limit of 1024 in either dimension.
+ *
+ * If either dimension of the output frame exceeds the limit, the
+ * dimension is split into 1, 2, or 4 equal stripes, for a maximum
+ * of 4*4 or 16 tiles. A conversion is then carried out for each
+ * tile (but taking care to pass the full frame stride length to
+ * the DMA channel's parameter memory!). IDMA double-buffering is used
+ * to convert each tile back-to-back when possible (see note below
+ * when double_buffering boolean is set).
+ *
+ * Note that the input frame must be split up into the same number
+ * of tiles as the output frame.
+ *
+ * FIXME: at this point there is no attempt to deal with visible seams
+ * at the tile boundaries when upscaling. The seams are caused by a reset
+ * of the bilinear upscale interpolation when starting a new tile. The
+ * seams are barely visible for small upscale factors, but become
+ * increasingly visible as the upscale factor gets larger, since more
+ * interpolated pixels get thrown out at the tile boundaries. A possilble
+ * fix might be to overlap tiles of different sizes, but this must be done
+ * while also maintaining the IDMAC dma buffer address alignment and 8x8 IRT
+ * alignment restrictions of each tile.
+ */
+
+#define MAX_STRIPES_W    4
+#define MAX_STRIPES_H    4
+#define MAX_TILES (MAX_STRIPES_W * MAX_STRIPES_H)
+
+#define MIN_W     16
+#define MIN_H     8
+#define MAX_W     4096
+#define MAX_H     4096
+
+enum ipu_image_convert_type {
+	IMAGE_CONVERT_IN = 0,
+	IMAGE_CONVERT_OUT,
+};
+
+struct ipu_image_convert_dma_buf {
+	void          *virt;
+	dma_addr_t    phys;
+	unsigned long len;
+};
+
+struct ipu_image_convert_dma_chan {
+	int in;
+	int out;
+	int rot_in;
+	int rot_out;
+	int vdi_in_p;
+	int vdi_in;
+	int vdi_in_n;
+};
+
+/* dimensions of one tile */
+struct ipu_image_tile {
+	u32 width;
+	u32 height;
+	/* size and strides are in bytes */
+	u32 size;
+	u32 stride;
+	u32 rot_stride;
+	/* start Y or packed offset of this tile */
+	u32 offset;
+	/* offset from start to tile in U plane, for planar formats */
+	u32 u_off;
+	/* offset from start to tile in V plane, for planar formats */
+	u32 v_off;
+};
+
+struct ipu_image_convert_image {
+	struct ipu_image base;
+	enum ipu_image_convert_type type;
+
+	const struct ipu_image_pixfmt *fmt;
+	unsigned int stride;
+
+	/* # of rows (horizontal stripes) if dest height is > 1024 */
+	unsigned int num_rows;
+	/* # of columns (vertical stripes) if dest width is > 1024 */
+	unsigned int num_cols;
+
+	struct ipu_image_tile tile[MAX_TILES];
+};
+
+struct ipu_image_pixfmt {
+	u32	fourcc;        /* V4L2 fourcc */
+	int     bpp;           /* total bpp */
+	int     uv_width_dec;  /* decimation in width for U/V planes */
+	int     uv_height_dec; /* decimation in height for U/V planes */
+	bool    planar;        /* planar format */
+	bool    uv_swapped;    /* U and V planes are swapped */
+	bool    uv_packed;     /* partial planar (U and V in same plane) */
+};
+
+struct ipu_image_convert_ctx;
+struct ipu_image_convert_chan;
+struct ipu_image_convert_priv;
+
+struct ipu_image_convert_ctx {
+	struct ipu_image_convert_chan *chan;
+
+	ipu_image_convert_cb_t complete;
+	void *complete_context;
+
+	/* Source/destination image data and rotation mode */
+	struct ipu_image_convert_image in;
+	struct ipu_image_convert_image out;
+	enum ipu_rotate_mode rot_mode;
+
+	/* intermediate buffer for rotation */
+	struct ipu_image_convert_dma_buf rot_intermediate[2];
+
+	/* current buffer number for double buffering */
+	int cur_buf_num;
+
+	bool aborting;
+	struct completion aborted;
+
+	/* can we use double-buffering for this conversion operation? */
+	bool double_buffering;
+	/* num_rows * num_cols */
+	unsigned int num_tiles;
+	/* next tile to process */
+	unsigned int next_tile;
+	/* where to place converted tile in dest image */
+	unsigned int out_tile_map[MAX_TILES];
+
+	struct list_head list;
+};
+
+struct ipu_image_convert_chan {
+	struct ipu_image_convert_priv *priv;
+
+	enum ipu_ic_task ic_task;
+	const struct ipu_image_convert_dma_chan *dma_ch;
+
+	struct ipu_ic *ic;
+	struct ipuv3_channel *in_chan;
+	struct ipuv3_channel *out_chan;
+	struct ipuv3_channel *rotation_in_chan;
+	struct ipuv3_channel *rotation_out_chan;
+
+	/* the IPU end-of-frame irqs */
+	int out_eof_irq;
+	int rot_out_eof_irq;
+
+	spinlock_t irqlock;
+
+	/* list of convert contexts */
+	struct list_head ctx_list;
+	/* queue of conversion runs */
+	struct list_head pending_q;
+	/* queue of completed runs */
+	struct list_head done_q;
+
+	/* the current conversion run */
+	struct ipu_image_convert_run *current_run;
+};
+
+struct ipu_image_convert_priv {
+	struct ipu_image_convert_chan chan[IC_NUM_TASKS];
+	struct ipu_soc *ipu;
+};
+
+static const struct ipu_image_convert_dma_chan
+image_convert_dma_chan[IC_NUM_TASKS] = {
+	[IC_TASK_VIEWFINDER] = {
+		.in = IPUV3_CHANNEL_MEM_IC_PRP_VF,
+		.out = IPUV3_CHANNEL_IC_PRP_VF_MEM,
+		.rot_in = IPUV3_CHANNEL_MEM_ROT_VF,
+		.rot_out = IPUV3_CHANNEL_ROT_VF_MEM,
+		.vdi_in_p = IPUV3_CHANNEL_MEM_VDI_PREV,
+		.vdi_in = IPUV3_CHANNEL_MEM_VDI_CUR,
+		.vdi_in_n = IPUV3_CHANNEL_MEM_VDI_NEXT,
+	},
+	[IC_TASK_POST_PROCESSOR] = {
+		.in = IPUV3_CHANNEL_MEM_IC_PP,
+		.out = IPUV3_CHANNEL_IC_PP_MEM,
+		.rot_in = IPUV3_CHANNEL_MEM_ROT_PP,
+		.rot_out = IPUV3_CHANNEL_ROT_PP_MEM,
+	},
+};
+
+static const struct ipu_image_pixfmt image_convert_formats[] = {
+	{
+		.fourcc	= V4L2_PIX_FMT_RGB565,
+		.bpp    = 16,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_RGB24,
+		.bpp    = 24,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_BGR24,
+		.bpp    = 24,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_RGB32,
+		.bpp    = 32,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_BGR32,
+		.bpp    = 32,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_YUYV,
+		.bpp    = 16,
+		.uv_width_dec = 2,
+		.uv_height_dec = 1,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_UYVY,
+		.bpp    = 16,
+		.uv_width_dec = 2,
+		.uv_height_dec = 1,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_YUV420,
+		.bpp    = 12,
+		.planar = true,
+		.uv_width_dec = 2,
+		.uv_height_dec = 2,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_YVU420,
+		.bpp    = 12,
+		.planar = true,
+		.uv_width_dec = 2,
+		.uv_height_dec = 2,
+		.uv_swapped = true,
+	}, {
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.bpp    = 12,
+		.planar = true,
+		.uv_width_dec = 2,
+		.uv_height_dec = 2,
+		.uv_packed = true,
+	}, {
+		.fourcc = V4L2_PIX_FMT_YUV422P,
+		.bpp    = 16,
+		.planar = true,
+		.uv_width_dec = 2,
+		.uv_height_dec = 1,
+	}, {
+		.fourcc = V4L2_PIX_FMT_NV16,
+		.bpp    = 16,
+		.planar = true,
+		.uv_width_dec = 2,
+		.uv_height_dec = 1,
+		.uv_packed = true,
+	},
+};
+
+static const struct ipu_image_pixfmt *get_format(u32 fourcc)
+{
+	const struct ipu_image_pixfmt *ret = NULL;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(image_convert_formats); i++) {
+		if (image_convert_formats[i].fourcc == fourcc) {
+			ret = &image_convert_formats[i];
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void dump_format(struct ipu_image_convert_ctx *ctx,
+			struct ipu_image_convert_image *ic_image)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+
+	dev_dbg(priv->ipu->dev,
+		"task %u: ctx %p: %s format: %dx%d (%dx%d tiles of size %dx%d), %c%c%c%c\n",
+		chan->ic_task, ctx,
+		ic_image->type == IMAGE_CONVERT_OUT ? "Output" : "Input",
+		ic_image->base.pix.width, ic_image->base.pix.height,
+		ic_image->num_cols, ic_image->num_rows,
+		ic_image->tile[0].width, ic_image->tile[0].height,
+		ic_image->fmt->fourcc & 0xff,
+		(ic_image->fmt->fourcc >> 8) & 0xff,
+		(ic_image->fmt->fourcc >> 16) & 0xff,
+		(ic_image->fmt->fourcc >> 24) & 0xff);
+}
+
+int ipu_image_convert_enum_format(int index, u32 *fourcc)
+{
+	const struct ipu_image_pixfmt *fmt;
+
+	if (index >= (int)ARRAY_SIZE(image_convert_formats))
+		return -EINVAL;
+
+	/* Format found */
+	fmt = &image_convert_formats[index];
+	*fourcc = fmt->fourcc;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_enum_format);
+
+static void free_dma_buf(struct ipu_image_convert_priv *priv,
+			 struct ipu_image_convert_dma_buf *buf)
+{
+	if (buf->virt)
+		dma_free_coherent(priv->ipu->dev,
+				  buf->len, buf->virt, buf->phys);
+	buf->virt = NULL;
+	buf->phys = 0;
+}
+
+static int alloc_dma_buf(struct ipu_image_convert_priv *priv,
+			 struct ipu_image_convert_dma_buf *buf,
+			 int size)
+{
+	buf->len = PAGE_ALIGN(size);
+	buf->virt = dma_alloc_coherent(priv->ipu->dev, buf->len, &buf->phys,
+				       GFP_DMA | GFP_KERNEL);
+	if (!buf->virt) {
+		dev_err(priv->ipu->dev, "failed to alloc dma buffer\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static inline int num_stripes(int dim)
+{
+	if (dim <= 1024)
+		return 1;
+	else if (dim <= 2048)
+		return 2;
+	else
+		return 4;
+}
+
+static void calc_tile_dimensions(struct ipu_image_convert_ctx *ctx,
+				 struct ipu_image_convert_image *image)
+{
+	int i;
+
+	for (i = 0; i < ctx->num_tiles; i++) {
+		struct ipu_image_tile *tile = &image->tile[i];
+
+		tile->height = image->base.pix.height / image->num_rows;
+		tile->width = image->base.pix.width / image->num_cols;
+		tile->size = ((tile->height * image->fmt->bpp) >> 3) *
+			tile->width;
+
+		if (image->fmt->planar) {
+			tile->stride = tile->width;
+			tile->rot_stride = tile->height;
+		} else {
+			tile->stride =
+				(image->fmt->bpp * tile->width) >> 3;
+			tile->rot_stride =
+				(image->fmt->bpp * tile->height) >> 3;
+		}
+	}
+}
+
+/*
+ * Use the rotation transformation to find the tile coordinates
+ * (row, col) of a tile in the destination frame that corresponds
+ * to the given tile coordinates of a source frame. The destination
+ * coordinate is then converted to a tile index.
+ */
+static int transform_tile_index(struct ipu_image_convert_ctx *ctx,
+				int src_row, int src_col)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_image *s_image = &ctx->in;
+	struct ipu_image_convert_image *d_image = &ctx->out;
+	int dst_row, dst_col;
+
+	/* with no rotation it's a 1:1 mapping */
+	if (ctx->rot_mode == IPU_ROTATE_NONE)
+		return src_row * s_image->num_cols + src_col;
+
+	/*
+	 * before doing the transform, first we have to translate
+	 * source row,col for an origin in the center of s_image
+	 */
+	src_row = src_row * 2 - (s_image->num_rows - 1);
+	src_col = src_col * 2 - (s_image->num_cols - 1);
+
+	/* do the rotation transform */
+	if (ctx->rot_mode & IPU_ROT_BIT_90) {
+		dst_col = -src_row;
+		dst_row = src_col;
+	} else {
+		dst_col = src_col;
+		dst_row = src_row;
+	}
+
+	/* apply flip */
+	if (ctx->rot_mode & IPU_ROT_BIT_HFLIP)
+		dst_col = -dst_col;
+	if (ctx->rot_mode & IPU_ROT_BIT_VFLIP)
+		dst_row = -dst_row;
+
+	dev_dbg(priv->ipu->dev, "task %u: ctx %p: [%d,%d] --> [%d,%d]\n",
+		chan->ic_task, ctx, src_col, src_row, dst_col, dst_row);
+
+	/*
+	 * finally translate dest row,col using an origin in upper
+	 * left of d_image
+	 */
+	dst_row += d_image->num_rows - 1;
+	dst_col += d_image->num_cols - 1;
+	dst_row /= 2;
+	dst_col /= 2;
+
+	return dst_row * d_image->num_cols + dst_col;
+}
+
+/*
+ * Fill the out_tile_map[] with transformed destination tile indeces.
+ */
+static void calc_out_tile_map(struct ipu_image_convert_ctx *ctx)
+{
+	struct ipu_image_convert_image *s_image = &ctx->in;
+	unsigned int row, col, tile = 0;
+
+	for (row = 0; row < s_image->num_rows; row++) {
+		for (col = 0; col < s_image->num_cols; col++) {
+			ctx->out_tile_map[tile] =
+				transform_tile_index(ctx, row, col);
+			tile++;
+		}
+	}
+}
+
+static void calc_tile_offsets_planar(struct ipu_image_convert_ctx *ctx,
+				     struct ipu_image_convert_image *image)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	const struct ipu_image_pixfmt *fmt = image->fmt;
+	unsigned int row, col, tile = 0;
+	u32 H, w, h, y_stride, uv_stride;
+	u32 uv_row_off, uv_col_off, uv_off, u_off, v_off, tmp;
+	u32 y_row_off, y_col_off, y_off;
+	u32 y_size, uv_size;
+
+	/* setup some convenience vars */
+	H = image->base.pix.height;
+
+	y_stride = image->stride;
+	uv_stride = y_stride / fmt->uv_width_dec;
+	if (fmt->uv_packed)
+		uv_stride *= 2;
+
+	y_size = H * y_stride;
+	uv_size = y_size / (fmt->uv_width_dec * fmt->uv_height_dec);
+
+	for (row = 0; row < image->num_rows; row++) {
+		w = image->tile[tile].width;
+		h = image->tile[tile].height;
+		y_row_off = row * h * y_stride;
+		uv_row_off = (row * h * uv_stride) / fmt->uv_height_dec;
+
+		for (col = 0; col < image->num_cols; col++) {
+			y_col_off = col * w;
+			uv_col_off = y_col_off / fmt->uv_width_dec;
+			if (fmt->uv_packed)
+				uv_col_off *= 2;
+
+			y_off = y_row_off + y_col_off;
+			uv_off = uv_row_off + uv_col_off;
+
+			u_off = y_size - y_off + uv_off;
+			v_off = (fmt->uv_packed) ? 0 : u_off + uv_size;
+			if (fmt->uv_swapped) {
+				tmp = u_off;
+				u_off = v_off;
+				v_off = tmp;
+			}
+
+			image->tile[tile].offset = y_off;
+			image->tile[tile].u_off = u_off;
+			image->tile[tile++].v_off = v_off;
+
+			dev_dbg(priv->ipu->dev,
+				"task %u: ctx %p: %s@[%d,%d]: y_off %08x, u_off %08x, v_off %08x\n",
+				chan->ic_task, ctx,
+				image->type == IMAGE_CONVERT_IN ?
+				"Input" : "Output", row, col,
+				y_off, u_off, v_off);
+		}
+	}
+}
+
+static void calc_tile_offsets_packed(struct ipu_image_convert_ctx *ctx,
+				     struct ipu_image_convert_image *image)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	const struct ipu_image_pixfmt *fmt = image->fmt;
+	unsigned int row, col, tile = 0;
+	u32 w, h, bpp, stride;
+	u32 row_off, col_off;
+
+	/* setup some convenience vars */
+	stride = image->stride;
+	bpp = fmt->bpp;
+
+	for (row = 0; row < image->num_rows; row++) {
+		w = image->tile[tile].width;
+		h = image->tile[tile].height;
+		row_off = row * h * stride;
+
+		for (col = 0; col < image->num_cols; col++) {
+			col_off = (col * w * bpp) >> 3;
+
+			image->tile[tile].offset = row_off + col_off;
+			image->tile[tile].u_off = 0;
+			image->tile[tile++].v_off = 0;
+
+			dev_dbg(priv->ipu->dev,
+				"task %u: ctx %p: %s@[%d,%d]: phys %08x\n",
+				chan->ic_task, ctx,
+				image->type == IMAGE_CONVERT_IN ?
+				"Input" : "Output", row, col,
+				row_off + col_off);
+		}
+	}
+}
+
+static void calc_tile_offsets(struct ipu_image_convert_ctx *ctx,
+			      struct ipu_image_convert_image *image)
+{
+	if (image->fmt->planar)
+		calc_tile_offsets_planar(ctx, image);
+	else
+		calc_tile_offsets_packed(ctx, image);
+}
+
+/*
+ * return the number of runs in given queue (pending_q or done_q)
+ * for this context. hold irqlock when calling.
+ */
+static int get_run_count(struct ipu_image_convert_ctx *ctx,
+			 struct list_head *q)
+{
+	struct ipu_image_convert_run *run;
+	int count = 0;
+
+	lockdep_assert_held(&ctx->chan->irqlock);
+
+	list_for_each_entry(run, q, list) {
+		if (run->ctx == ctx)
+			count++;
+	}
+
+	return count;
+}
+
+static void convert_stop(struct ipu_image_convert_run *run)
+{
+	struct ipu_image_convert_ctx *ctx = run->ctx;
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: stopping ctx %p run %p\n",
+		__func__, chan->ic_task, ctx, run);
+
+	/* disable IC tasks and the channels */
+	ipu_ic_task_disable(chan->ic);
+	ipu_idmac_disable_channel(chan->in_chan);
+	ipu_idmac_disable_channel(chan->out_chan);
+
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		ipu_idmac_disable_channel(chan->rotation_in_chan);
+		ipu_idmac_disable_channel(chan->rotation_out_chan);
+		ipu_idmac_unlink(chan->out_chan, chan->rotation_in_chan);
+	}
+
+	ipu_ic_disable(chan->ic);
+}
+
+static void init_idmac_channel(struct ipu_image_convert_ctx *ctx,
+			       struct ipuv3_channel *channel,
+			       struct ipu_image_convert_image *image,
+			       enum ipu_rotate_mode rot_mode,
+			       bool rot_swap_width_height)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	unsigned int burst_size;
+	u32 width, height, stride;
+	dma_addr_t addr0, addr1 = 0;
+	struct ipu_image tile_image;
+	unsigned int tile_idx[2];
+
+	if (image->type == IMAGE_CONVERT_OUT) {
+		tile_idx[0] = ctx->out_tile_map[0];
+		tile_idx[1] = ctx->out_tile_map[1];
+	} else {
+		tile_idx[0] = 0;
+		tile_idx[1] = 1;
+	}
+
+	if (rot_swap_width_height) {
+		width = image->tile[0].height;
+		height = image->tile[0].width;
+		stride = image->tile[0].rot_stride;
+		addr0 = ctx->rot_intermediate[0].phys;
+		if (ctx->double_buffering)
+			addr1 = ctx->rot_intermediate[1].phys;
+	} else {
+		width = image->tile[0].width;
+		height = image->tile[0].height;
+		stride = image->stride;
+		addr0 = image->base.phys0 +
+			image->tile[tile_idx[0]].offset;
+		if (ctx->double_buffering)
+			addr1 = image->base.phys0 +
+				image->tile[tile_idx[1]].offset;
+	}
+
+	ipu_cpmem_zero(channel);
+
+	memset(&tile_image, 0, sizeof(tile_image));
+	tile_image.pix.width = tile_image.rect.width = width;
+	tile_image.pix.height = tile_image.rect.height = height;
+	tile_image.pix.bytesperline = stride;
+	tile_image.pix.pixelformat =  image->fmt->fourcc;
+	tile_image.phys0 = addr0;
+	tile_image.phys1 = addr1;
+	ipu_cpmem_set_image(channel, &tile_image);
+
+	if (image->fmt->planar && !rot_swap_width_height)
+		ipu_cpmem_set_uv_offset(channel,
+					image->tile[tile_idx[0]].u_off,
+					image->tile[tile_idx[0]].v_off);
+
+	if (rot_mode)
+		ipu_cpmem_set_rotation(channel, rot_mode);
+
+	if (channel == chan->rotation_in_chan ||
+	    channel == chan->rotation_out_chan) {
+		burst_size = 8;
+		ipu_cpmem_set_block_mode(channel);
+	} else
+		burst_size = (width % 16) ? 8 : 16;
+
+	ipu_cpmem_set_burstsize(channel, burst_size);
+
+	ipu_ic_task_idma_init(chan->ic, channel, width, height,
+			      burst_size, rot_mode);
+
+	/*
+	 * Setting a non-zero AXI ID collides with the PRG AXI snooping, so
+	 * only do this when there is no PRG present.
+	 */
+	if (!channel->ipu->prg_priv)
+		ipu_cpmem_set_axi_id(channel, 1);
+
+	ipu_idmac_set_double_buffer(channel, ctx->double_buffering);
+}
+
+static int convert_start(struct ipu_image_convert_run *run)
+{
+	struct ipu_image_convert_ctx *ctx = run->ctx;
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_image *s_image = &ctx->in;
+	struct ipu_image_convert_image *d_image = &ctx->out;
+	enum ipu_color_space src_cs, dest_cs;
+	unsigned int dest_width, dest_height;
+	int ret;
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: starting ctx %p run %p\n",
+		__func__, chan->ic_task, ctx, run);
+
+	src_cs = ipu_pixelformat_to_colorspace(s_image->fmt->fourcc);
+	dest_cs = ipu_pixelformat_to_colorspace(d_image->fmt->fourcc);
+
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		/* swap width/height for resizer */
+		dest_width = d_image->tile[0].height;
+		dest_height = d_image->tile[0].width;
+	} else {
+		dest_width = d_image->tile[0].width;
+		dest_height = d_image->tile[0].height;
+	}
+
+	/* setup the IC resizer and CSC */
+	ret = ipu_ic_task_init(chan->ic,
+			       s_image->tile[0].width,
+			       s_image->tile[0].height,
+			       dest_width,
+			       dest_height,
+			       src_cs, dest_cs);
+	if (ret) {
+		dev_err(priv->ipu->dev, "ipu_ic_task_init failed, %d\n", ret);
+		return ret;
+	}
+
+	/* init the source MEM-->IC PP IDMAC channel */
+	init_idmac_channel(ctx, chan->in_chan, s_image,
+			   IPU_ROTATE_NONE, false);
+
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		/* init the IC PP-->MEM IDMAC channel */
+		init_idmac_channel(ctx, chan->out_chan, d_image,
+				   IPU_ROTATE_NONE, true);
+
+		/* init the MEM-->IC PP ROT IDMAC channel */
+		init_idmac_channel(ctx, chan->rotation_in_chan, d_image,
+				   ctx->rot_mode, true);
+
+		/* init the destination IC PP ROT-->MEM IDMAC channel */
+		init_idmac_channel(ctx, chan->rotation_out_chan, d_image,
+				   IPU_ROTATE_NONE, false);
+
+		/* now link IC PP-->MEM to MEM-->IC PP ROT */
+		ipu_idmac_link(chan->out_chan, chan->rotation_in_chan);
+	} else {
+		/* init the destination IC PP-->MEM IDMAC channel */
+		init_idmac_channel(ctx, chan->out_chan, d_image,
+				   ctx->rot_mode, false);
+	}
+
+	/* enable the IC */
+	ipu_ic_enable(chan->ic);
+
+	/* set buffers ready */
+	ipu_idmac_select_buffer(chan->in_chan, 0);
+	ipu_idmac_select_buffer(chan->out_chan, 0);
+	if (ipu_rot_mode_is_irt(ctx->rot_mode))
+		ipu_idmac_select_buffer(chan->rotation_out_chan, 0);
+	if (ctx->double_buffering) {
+		ipu_idmac_select_buffer(chan->in_chan, 1);
+		ipu_idmac_select_buffer(chan->out_chan, 1);
+		if (ipu_rot_mode_is_irt(ctx->rot_mode))
+			ipu_idmac_select_buffer(chan->rotation_out_chan, 1);
+	}
+
+	/* enable the channels! */
+	ipu_idmac_enable_channel(chan->in_chan);
+	ipu_idmac_enable_channel(chan->out_chan);
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		ipu_idmac_enable_channel(chan->rotation_in_chan);
+		ipu_idmac_enable_channel(chan->rotation_out_chan);
+	}
+
+	ipu_ic_task_enable(chan->ic);
+
+	ipu_cpmem_dump(chan->in_chan);
+	ipu_cpmem_dump(chan->out_chan);
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		ipu_cpmem_dump(chan->rotation_in_chan);
+		ipu_cpmem_dump(chan->rotation_out_chan);
+	}
+
+	ipu_dump(priv->ipu);
+
+	return 0;
+}
+
+/* hold irqlock when calling */
+static int do_run(struct ipu_image_convert_run *run)
+{
+	struct ipu_image_convert_ctx *ctx = run->ctx;
+	struct ipu_image_convert_chan *chan = ctx->chan;
+
+	lockdep_assert_held(&chan->irqlock);
+
+	ctx->in.base.phys0 = run->in_phys;
+	ctx->out.base.phys0 = run->out_phys;
+
+	ctx->cur_buf_num = 0;
+	ctx->next_tile = 1;
+
+	/* remove run from pending_q and set as current */
+	list_del(&run->list);
+	chan->current_run = run;
+
+	return convert_start(run);
+}
+
+/* hold irqlock when calling */
+static void run_next(struct ipu_image_convert_chan *chan)
+{
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_run *run, *tmp;
+	int ret;
+
+	lockdep_assert_held(&chan->irqlock);
+
+	list_for_each_entry_safe(run, tmp, &chan->pending_q, list) {
+		/* skip contexts that are aborting */
+		if (run->ctx->aborting) {
+			dev_dbg(priv->ipu->dev,
+				"%s: task %u: skipping aborting ctx %p run %p\n",
+				__func__, chan->ic_task, run->ctx, run);
+			continue;
+		}
+
+		ret = do_run(run);
+		if (!ret)
+			break;
+
+		/*
+		 * something went wrong with start, add the run
+		 * to done q and continue to the next run in the
+		 * pending q.
+		 */
+		run->status = ret;
+		list_add_tail(&run->list, &chan->done_q);
+		chan->current_run = NULL;
+	}
+}
+
+static void empty_done_q(struct ipu_image_convert_chan *chan)
+{
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_run *run;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	while (!list_empty(&chan->done_q)) {
+		run = list_entry(chan->done_q.next,
+				 struct ipu_image_convert_run,
+				 list);
+
+		list_del(&run->list);
+
+		dev_dbg(priv->ipu->dev,
+			"%s: task %u: completing ctx %p run %p with %d\n",
+			__func__, chan->ic_task, run->ctx, run, run->status);
+
+		/* call the completion callback and free the run */
+		spin_unlock_irqrestore(&chan->irqlock, flags);
+		run->ctx->complete(run, run->ctx->complete_context);
+		spin_lock_irqsave(&chan->irqlock, flags);
+	}
+
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+}
+
+/*
+ * the bottom half thread clears out the done_q, calling the
+ * completion handler for each.
+ */
+static irqreturn_t do_bh(int irq, void *dev_id)
+{
+	struct ipu_image_convert_chan *chan = dev_id;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_ctx *ctx;
+	unsigned long flags;
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: enter\n", __func__,
+		chan->ic_task);
+
+	empty_done_q(chan);
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	/*
+	 * the done_q is cleared out, signal any contexts
+	 * that are aborting that abort can complete.
+	 */
+	list_for_each_entry(ctx, &chan->ctx_list, list) {
+		if (ctx->aborting) {
+			dev_dbg(priv->ipu->dev,
+				"%s: task %u: signaling abort for ctx %p\n",
+				__func__, chan->ic_task, ctx);
+			complete(&ctx->aborted);
+		}
+	}
+
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: exit\n", __func__,
+		chan->ic_task);
+
+	return IRQ_HANDLED;
+}
+
+/* hold irqlock when calling */
+static irqreturn_t do_irq(struct ipu_image_convert_run *run)
+{
+	struct ipu_image_convert_ctx *ctx = run->ctx;
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_tile *src_tile, *dst_tile;
+	struct ipu_image_convert_image *s_image = &ctx->in;
+	struct ipu_image_convert_image *d_image = &ctx->out;
+	struct ipuv3_channel *outch;
+	unsigned int dst_idx;
+
+	lockdep_assert_held(&chan->irqlock);
+
+	outch = ipu_rot_mode_is_irt(ctx->rot_mode) ?
+		chan->rotation_out_chan : chan->out_chan;
+
+	/*
+	 * It is difficult to stop the channel DMA before the channels
+	 * enter the paused state. Without double-buffering the channels
+	 * are always in a paused state when the EOF irq occurs, so it
+	 * is safe to stop the channels now. For double-buffering we
+	 * just ignore the abort until the operation completes, when it
+	 * is safe to shut down.
+	 */
+	if (ctx->aborting && !ctx->double_buffering) {
+		convert_stop(run);
+		run->status = -EIO;
+		goto done;
+	}
+
+	if (ctx->next_tile == ctx->num_tiles) {
+		/*
+		 * the conversion is complete
+		 */
+		convert_stop(run);
+		run->status = 0;
+		goto done;
+	}
+
+	/*
+	 * not done, place the next tile buffers.
+	 */
+	if (!ctx->double_buffering) {
+
+		src_tile = &s_image->tile[ctx->next_tile];
+		dst_idx = ctx->out_tile_map[ctx->next_tile];
+		dst_tile = &d_image->tile[dst_idx];
+
+		ipu_cpmem_set_buffer(chan->in_chan, 0,
+				     s_image->base.phys0 + src_tile->offset);
+		ipu_cpmem_set_buffer(outch, 0,
+				     d_image->base.phys0 + dst_tile->offset);
+		if (s_image->fmt->planar)
+			ipu_cpmem_set_uv_offset(chan->in_chan,
+						src_tile->u_off,
+						src_tile->v_off);
+		if (d_image->fmt->planar)
+			ipu_cpmem_set_uv_offset(outch,
+						dst_tile->u_off,
+						dst_tile->v_off);
+
+		ipu_idmac_select_buffer(chan->in_chan, 0);
+		ipu_idmac_select_buffer(outch, 0);
+
+	} else if (ctx->next_tile < ctx->num_tiles - 1) {
+
+		src_tile = &s_image->tile[ctx->next_tile + 1];
+		dst_idx = ctx->out_tile_map[ctx->next_tile + 1];
+		dst_tile = &d_image->tile[dst_idx];
+
+		ipu_cpmem_set_buffer(chan->in_chan, ctx->cur_buf_num,
+				     s_image->base.phys0 + src_tile->offset);
+		ipu_cpmem_set_buffer(outch, ctx->cur_buf_num,
+				     d_image->base.phys0 + dst_tile->offset);
+
+		ipu_idmac_select_buffer(chan->in_chan, ctx->cur_buf_num);
+		ipu_idmac_select_buffer(outch, ctx->cur_buf_num);
+
+		ctx->cur_buf_num ^= 1;
+	}
+
+	ctx->next_tile++;
+	return IRQ_HANDLED;
+done:
+	list_add_tail(&run->list, &chan->done_q);
+	chan->current_run = NULL;
+	run_next(chan);
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t norotate_irq(int irq, void *data)
+{
+	struct ipu_image_convert_chan *chan = data;
+	struct ipu_image_convert_ctx *ctx;
+	struct ipu_image_convert_run *run;
+	unsigned long flags;
+	irqreturn_t ret;
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	/* get current run and its context */
+	run = chan->current_run;
+	if (!run) {
+		ret = IRQ_NONE;
+		goto out;
+	}
+
+	ctx = run->ctx;
+
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		/* this is a rotation operation, just ignore */
+		spin_unlock_irqrestore(&chan->irqlock, flags);
+		return IRQ_HANDLED;
+	}
+
+	ret = do_irq(run);
+out:
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+	return ret;
+}
+
+static irqreturn_t rotate_irq(int irq, void *data)
+{
+	struct ipu_image_convert_chan *chan = data;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_ctx *ctx;
+	struct ipu_image_convert_run *run;
+	unsigned long flags;
+	irqreturn_t ret;
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	/* get current run and its context */
+	run = chan->current_run;
+	if (!run) {
+		ret = IRQ_NONE;
+		goto out;
+	}
+
+	ctx = run->ctx;
+
+	if (!ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		/* this was NOT a rotation operation, shouldn't happen */
+		dev_err(priv->ipu->dev, "Unexpected rotation interrupt\n");
+		spin_unlock_irqrestore(&chan->irqlock, flags);
+		return IRQ_HANDLED;
+	}
+
+	ret = do_irq(run);
+out:
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+	return ret;
+}
+
+/*
+ * try to force the completion of runs for this ctx. Called when
+ * abort wait times out in ipu_image_convert_abort().
+ */
+static void force_abort(struct ipu_image_convert_ctx *ctx)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_run *run;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	run = chan->current_run;
+	if (run && run->ctx == ctx) {
+		convert_stop(run);
+		run->status = -EIO;
+		list_add_tail(&run->list, &chan->done_q);
+		chan->current_run = NULL;
+		run_next(chan);
+	}
+
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+
+	empty_done_q(chan);
+}
+
+static void release_ipu_resources(struct ipu_image_convert_chan *chan)
+{
+	if (chan->out_eof_irq >= 0)
+		free_irq(chan->out_eof_irq, chan);
+	if (chan->rot_out_eof_irq >= 0)
+		free_irq(chan->rot_out_eof_irq, chan);
+
+	if (!IS_ERR_OR_NULL(chan->in_chan))
+		ipu_idmac_put(chan->in_chan);
+	if (!IS_ERR_OR_NULL(chan->out_chan))
+		ipu_idmac_put(chan->out_chan);
+	if (!IS_ERR_OR_NULL(chan->rotation_in_chan))
+		ipu_idmac_put(chan->rotation_in_chan);
+	if (!IS_ERR_OR_NULL(chan->rotation_out_chan))
+		ipu_idmac_put(chan->rotation_out_chan);
+	if (!IS_ERR_OR_NULL(chan->ic))
+		ipu_ic_put(chan->ic);
+
+	chan->in_chan = chan->out_chan = chan->rotation_in_chan =
+		chan->rotation_out_chan = NULL;
+	chan->out_eof_irq = chan->rot_out_eof_irq = -1;
+}
+
+static int get_ipu_resources(struct ipu_image_convert_chan *chan)
+{
+	const struct ipu_image_convert_dma_chan *dma = chan->dma_ch;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	int ret;
+
+	/* get IC */
+	chan->ic = ipu_ic_get(priv->ipu, chan->ic_task);
+	if (IS_ERR(chan->ic)) {
+		dev_err(priv->ipu->dev, "could not acquire IC\n");
+		ret = PTR_ERR(chan->ic);
+		goto err;
+	}
+
+	/* get IDMAC channels */
+	chan->in_chan = ipu_idmac_get(priv->ipu, dma->in);
+	chan->out_chan = ipu_idmac_get(priv->ipu, dma->out);
+	if (IS_ERR(chan->in_chan) || IS_ERR(chan->out_chan)) {
+		dev_err(priv->ipu->dev, "could not acquire idmac channels\n");
+		ret = -EBUSY;
+		goto err;
+	}
+
+	chan->rotation_in_chan = ipu_idmac_get(priv->ipu, dma->rot_in);
+	chan->rotation_out_chan = ipu_idmac_get(priv->ipu, dma->rot_out);
+	if (IS_ERR(chan->rotation_in_chan) || IS_ERR(chan->rotation_out_chan)) {
+		dev_err(priv->ipu->dev,
+			"could not acquire idmac rotation channels\n");
+		ret = -EBUSY;
+		goto err;
+	}
+
+	/* acquire the EOF interrupts */
+	chan->out_eof_irq = ipu_idmac_channel_irq(priv->ipu,
+						  chan->out_chan,
+						  IPU_IRQ_EOF);
+
+	ret = request_threaded_irq(chan->out_eof_irq, norotate_irq, do_bh,
+				   0, "ipu-ic", chan);
+	if (ret < 0) {
+		dev_err(priv->ipu->dev, "could not acquire irq %d\n",
+			 chan->out_eof_irq);
+		chan->out_eof_irq = -1;
+		goto err;
+	}
+
+	chan->rot_out_eof_irq = ipu_idmac_channel_irq(priv->ipu,
+						     chan->rotation_out_chan,
+						     IPU_IRQ_EOF);
+
+	ret = request_threaded_irq(chan->rot_out_eof_irq, rotate_irq, do_bh,
+				   0, "ipu-ic", chan);
+	if (ret < 0) {
+		dev_err(priv->ipu->dev, "could not acquire irq %d\n",
+			chan->rot_out_eof_irq);
+		chan->rot_out_eof_irq = -1;
+		goto err;
+	}
+
+	return 0;
+err:
+	release_ipu_resources(chan);
+	return ret;
+}
+
+static int fill_image(struct ipu_image_convert_ctx *ctx,
+		      struct ipu_image_convert_image *ic_image,
+		      struct ipu_image *image,
+		      enum ipu_image_convert_type type)
+{
+	struct ipu_image_convert_priv *priv = ctx->chan->priv;
+
+	ic_image->base = *image;
+	ic_image->type = type;
+
+	ic_image->fmt = get_format(image->pix.pixelformat);
+	if (!ic_image->fmt) {
+		dev_err(priv->ipu->dev, "pixelformat not supported for %s\n",
+			type == IMAGE_CONVERT_OUT ? "Output" : "Input");
+		return -EINVAL;
+	}
+
+	if (ic_image->fmt->planar)
+		ic_image->stride = ic_image->base.pix.width;
+	else
+		ic_image->stride  = ic_image->base.pix.bytesperline;
+
+	calc_tile_dimensions(ctx, ic_image);
+	calc_tile_offsets(ctx, ic_image);
+
+	return 0;
+}
+
+/* borrowed from drivers/media/v4l2-core/v4l2-common.c */
+static unsigned int clamp_align(unsigned int x, unsigned int min,
+				unsigned int max, unsigned int align)
+{
+	/* Bits that must be zero to be aligned */
+	unsigned int mask = ~((1 << align) - 1);
+
+	/* Clamp to aligned min and max */
+	x = clamp(x, (min + ~mask) & mask, max & mask);
+
+	/* Round to nearest aligned value */
+	if (align)
+		x = (x + (1 << (align - 1))) & mask;
+
+	return x;
+}
+
+/*
+ * We have to adjust the tile width such that the tile physaddrs and
+ * U and V plane offsets are multiples of 8 bytes as required by
+ * the IPU DMA Controller. For the planar formats, this corresponds
+ * to a pixel alignment of 16 (but use a more formal equation since
+ * the variables are available). For all the packed formats, 8 is
+ * good enough.
+ */
+static inline u32 tile_width_align(const struct ipu_image_pixfmt *fmt)
+{
+	return fmt->planar ? 8 * fmt->uv_width_dec : 8;
+}
+
+/*
+ * For tile height alignment, we have to ensure that the output tile
+ * heights are multiples of 8 lines if the IRT is required by the
+ * given rotation mode (the IRT performs rotations on 8x8 blocks
+ * at a time). If the IRT is not used, or for input image tiles,
+ * 2 lines are good enough.
+ */
+static inline u32 tile_height_align(enum ipu_image_convert_type type,
+				    enum ipu_rotate_mode rot_mode)
+{
+	return (type == IMAGE_CONVERT_OUT &&
+		ipu_rot_mode_is_irt(rot_mode)) ? 8 : 2;
+}
+
+/* Adjusts input/output images to IPU restrictions */
+void ipu_image_convert_adjust(struct ipu_image *in, struct ipu_image *out,
+			      enum ipu_rotate_mode rot_mode)
+{
+	const struct ipu_image_pixfmt *infmt, *outfmt;
+	unsigned int num_in_rows, num_in_cols;
+	unsigned int num_out_rows, num_out_cols;
+	u32 w_align, h_align;
+
+	infmt = get_format(in->pix.pixelformat);
+	outfmt = get_format(out->pix.pixelformat);
+
+	/* set some default pixel formats if needed */
+	if (!infmt) {
+		in->pix.pixelformat = V4L2_PIX_FMT_RGB24;
+		infmt = get_format(V4L2_PIX_FMT_RGB24);
+	}
+	if (!outfmt) {
+		out->pix.pixelformat = V4L2_PIX_FMT_RGB24;
+		outfmt = get_format(V4L2_PIX_FMT_RGB24);
+	}
+
+	/* image converter does not handle fields */
+	in->pix.field = out->pix.field = V4L2_FIELD_NONE;
+
+	/* resizer cannot downsize more than 4:1 */
+	if (ipu_rot_mode_is_irt(rot_mode)) {
+		out->pix.height = max_t(__u32, out->pix.height,
+					in->pix.width / 4);
+		out->pix.width = max_t(__u32, out->pix.width,
+				       in->pix.height / 4);
+	} else {
+		out->pix.width = max_t(__u32, out->pix.width,
+				       in->pix.width / 4);
+		out->pix.height = max_t(__u32, out->pix.height,
+					in->pix.height / 4);
+	}
+
+	/* get tiling rows/cols from output format */
+	num_out_rows = num_stripes(out->pix.height);
+	num_out_cols = num_stripes(out->pix.width);
+	if (ipu_rot_mode_is_irt(rot_mode)) {
+		num_in_rows = num_out_cols;
+		num_in_cols = num_out_rows;
+	} else {
+		num_in_rows = num_out_rows;
+		num_in_cols = num_out_cols;
+	}
+
+	/* align input width/height */
+	w_align = ilog2(tile_width_align(infmt) * num_in_cols);
+	h_align = ilog2(tile_height_align(IMAGE_CONVERT_IN, rot_mode) *
+			num_in_rows);
+	in->pix.width = clamp_align(in->pix.width, MIN_W, MAX_W, w_align);
+	in->pix.height = clamp_align(in->pix.height, MIN_H, MAX_H, h_align);
+
+	/* align output width/height */
+	w_align = ilog2(tile_width_align(outfmt) * num_out_cols);
+	h_align = ilog2(tile_height_align(IMAGE_CONVERT_OUT, rot_mode) *
+			num_out_rows);
+	out->pix.width = clamp_align(out->pix.width, MIN_W, MAX_W, w_align);
+	out->pix.height = clamp_align(out->pix.height, MIN_H, MAX_H, h_align);
+
+	/* set input/output strides and image sizes */
+	in->pix.bytesperline = (in->pix.width * infmt->bpp) >> 3;
+	in->pix.sizeimage = in->pix.height * in->pix.bytesperline;
+	out->pix.bytesperline = (out->pix.width * outfmt->bpp) >> 3;
+	out->pix.sizeimage = out->pix.height * out->pix.bytesperline;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_adjust);
+
+/*
+ * this is used by ipu_image_convert_prepare() to verify set input and
+ * output images are valid before starting the conversion. Clients can
+ * also call it before calling ipu_image_convert_prepare().
+ */
+int ipu_image_convert_verify(struct ipu_image *in, struct ipu_image *out,
+			     enum ipu_rotate_mode rot_mode)
+{
+	struct ipu_image testin, testout;
+
+	testin = *in;
+	testout = *out;
+
+	ipu_image_convert_adjust(&testin, &testout, rot_mode);
+
+	if (testin.pix.width != in->pix.width ||
+	    testin.pix.height != in->pix.height ||
+	    testout.pix.width != out->pix.width ||
+	    testout.pix.height != out->pix.height)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_verify);
+
+/*
+ * Call ipu_image_convert_prepare() to prepare for the conversion of
+ * given images and rotation mode. Returns a new conversion context.
+ */
+struct ipu_image_convert_ctx *
+ipu_image_convert_prepare(struct ipu_soc *ipu, enum ipu_ic_task ic_task,
+			  struct ipu_image *in, struct ipu_image *out,
+			  enum ipu_rotate_mode rot_mode,
+			  ipu_image_convert_cb_t complete,
+			  void *complete_context)
+{
+	struct ipu_image_convert_priv *priv = ipu->image_convert_priv;
+	struct ipu_image_convert_image *s_image, *d_image;
+	struct ipu_image_convert_chan *chan;
+	struct ipu_image_convert_ctx *ctx;
+	unsigned long flags;
+	bool get_res;
+	int ret;
+
+	if (!in || !out || !complete ||
+	    (ic_task != IC_TASK_VIEWFINDER &&
+	     ic_task != IC_TASK_POST_PROCESSOR))
+		return ERR_PTR(-EINVAL);
+
+	/* verify the in/out images before continuing */
+	ret = ipu_image_convert_verify(in, out, rot_mode);
+	if (ret) {
+		dev_err(priv->ipu->dev, "%s: in/out formats invalid\n",
+			__func__);
+		return ERR_PTR(ret);
+	}
+
+	chan = &priv->chan[ic_task];
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return ERR_PTR(-ENOMEM);
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: ctx %p\n", __func__,
+		chan->ic_task, ctx);
+
+	ctx->chan = chan;
+	init_completion(&ctx->aborted);
+
+	s_image = &ctx->in;
+	d_image = &ctx->out;
+
+	/* set tiling and rotation */
+	d_image->num_rows = num_stripes(out->pix.height);
+	d_image->num_cols = num_stripes(out->pix.width);
+	if (ipu_rot_mode_is_irt(rot_mode)) {
+		s_image->num_rows = d_image->num_cols;
+		s_image->num_cols = d_image->num_rows;
+	} else {
+		s_image->num_rows = d_image->num_rows;
+		s_image->num_cols = d_image->num_cols;
+	}
+
+	ctx->num_tiles = d_image->num_cols * d_image->num_rows;
+	ctx->rot_mode = rot_mode;
+
+	ret = fill_image(ctx, s_image, in, IMAGE_CONVERT_IN);
+	if (ret)
+		goto out_free;
+	ret = fill_image(ctx, d_image, out, IMAGE_CONVERT_OUT);
+	if (ret)
+		goto out_free;
+
+	calc_out_tile_map(ctx);
+
+	dump_format(ctx, s_image);
+	dump_format(ctx, d_image);
+
+	ctx->complete = complete;
+	ctx->complete_context = complete_context;
+
+	/*
+	 * Can we use double-buffering for this operation? If there is
+	 * only one tile (the whole image can be converted in a single
+	 * operation) there's no point in using double-buffering. Also,
+	 * the IPU's IDMAC channels allow only a single U and V plane
+	 * offset shared between both buffers, but these offsets change
+	 * for every tile, and therefore would have to be updated for
+	 * each buffer which is not possible. So double-buffering is
+	 * impossible when either the source or destination images are
+	 * a planar format (YUV420, YUV422P, etc.).
+	 */
+	ctx->double_buffering = (ctx->num_tiles > 1 &&
+				 !s_image->fmt->planar &&
+				 !d_image->fmt->planar);
+
+	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
+		ret = alloc_dma_buf(priv, &ctx->rot_intermediate[0],
+				    d_image->tile[0].size);
+		if (ret)
+			goto out_free;
+		if (ctx->double_buffering) {
+			ret = alloc_dma_buf(priv,
+					    &ctx->rot_intermediate[1],
+					    d_image->tile[0].size);
+			if (ret)
+				goto out_free_dmabuf0;
+		}
+	}
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	get_res = list_empty(&chan->ctx_list);
+
+	list_add_tail(&ctx->list, &chan->ctx_list);
+
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+
+	if (get_res) {
+		ret = get_ipu_resources(chan);
+		if (ret)
+			goto out_free_dmabuf1;
+	}
+
+	return ctx;
+
+out_free_dmabuf1:
+	free_dma_buf(priv, &ctx->rot_intermediate[1]);
+	spin_lock_irqsave(&chan->irqlock, flags);
+	list_del(&ctx->list);
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+out_free_dmabuf0:
+	free_dma_buf(priv, &ctx->rot_intermediate[0]);
+out_free:
+	kfree(ctx);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_prepare);
+
+/*
+ * Carry out a single image conversion run. Only the physaddr's of the input
+ * and output image buffers are needed. The conversion context must have
+ * been created previously with ipu_image_convert_prepare().
+ */
+int ipu_image_convert_queue(struct ipu_image_convert_run *run)
+{
+	struct ipu_image_convert_chan *chan;
+	struct ipu_image_convert_priv *priv;
+	struct ipu_image_convert_ctx *ctx;
+	unsigned long flags;
+	int ret = 0;
+
+	if (!run || !run->ctx || !run->in_phys || !run->out_phys)
+		return -EINVAL;
+
+	ctx = run->ctx;
+	chan = ctx->chan;
+	priv = chan->priv;
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: ctx %p run %p\n", __func__,
+		chan->ic_task, ctx, run);
+
+	INIT_LIST_HEAD(&run->list);
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	if (ctx->aborting) {
+		ret = -EIO;
+		goto unlock;
+	}
+
+	list_add_tail(&run->list, &chan->pending_q);
+
+	if (!chan->current_run) {
+		ret = do_run(run);
+		if (ret)
+			chan->current_run = NULL;
+	}
+unlock:
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_queue);
+
+/* Abort any active or pending conversions for this context */
+static void __ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	struct ipu_image_convert_run *run, *active_run, *tmp;
+	unsigned long flags;
+	int run_count, ret;
+	bool need_abort;
+
+	reinit_completion(&ctx->aborted);
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	/* move all remaining pending runs in this context to done_q */
+	list_for_each_entry_safe(run, tmp, &chan->pending_q, list) {
+		if (run->ctx != ctx)
+			continue;
+		run->status = -EIO;
+		list_move_tail(&run->list, &chan->done_q);
+	}
+
+	run_count = get_run_count(ctx, &chan->done_q);
+	active_run = (chan->current_run && chan->current_run->ctx == ctx) ?
+		chan->current_run : NULL;
+
+	need_abort = (run_count || active_run);
+
+	ctx->aborting = true;
+
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+
+	if (!need_abort) {
+		dev_dbg(priv->ipu->dev,
+			"%s: task %u: no abort needed for ctx %p\n",
+			__func__, chan->ic_task, ctx);
+		return;
+	}
+
+	dev_dbg(priv->ipu->dev,
+		"%s: task %u: wait for completion: %d runs, active run %p\n",
+		__func__, chan->ic_task, run_count, active_run);
+
+	ret = wait_for_completion_timeout(&ctx->aborted,
+					  msecs_to_jiffies(10000));
+	if (ret == 0) {
+		dev_warn(priv->ipu->dev, "%s: timeout\n", __func__);
+		force_abort(ctx);
+	}
+}
+
+void ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)
+{
+	__ipu_image_convert_abort(ctx);
+	ctx->aborting = false;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_abort);
+
+/* Unprepare image conversion context */
+void ipu_image_convert_unprepare(struct ipu_image_convert_ctx *ctx)
+{
+	struct ipu_image_convert_chan *chan = ctx->chan;
+	struct ipu_image_convert_priv *priv = chan->priv;
+	unsigned long flags;
+	bool put_res;
+
+	/* make sure no runs are hanging around */
+	__ipu_image_convert_abort(ctx);
+
+	dev_dbg(priv->ipu->dev, "%s: task %u: removing ctx %p\n", __func__,
+		chan->ic_task, ctx);
+
+	spin_lock_irqsave(&chan->irqlock, flags);
+
+	list_del(&ctx->list);
+
+	put_res = list_empty(&chan->ctx_list);
+
+	spin_unlock_irqrestore(&chan->irqlock, flags);
+
+	if (put_res)
+		release_ipu_resources(chan);
+
+	free_dma_buf(priv, &ctx->rot_intermediate[1]);
+	free_dma_buf(priv, &ctx->rot_intermediate[0]);
+
+	kfree(ctx);
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_unprepare);
+
+/*
+ * "Canned" asynchronous single image conversion. Allocates and returns
+ * a new conversion run.  On successful return the caller must free the
+ * run and call ipu_image_convert_unprepare() after conversion completes.
+ */
+struct ipu_image_convert_run *
+ipu_image_convert(struct ipu_soc *ipu, enum ipu_ic_task ic_task,
+		  struct ipu_image *in, struct ipu_image *out,
+		  enum ipu_rotate_mode rot_mode,
+		  ipu_image_convert_cb_t complete,
+		  void *complete_context)
+{
+	struct ipu_image_convert_ctx *ctx;
+	struct ipu_image_convert_run *run;
+	int ret;
+
+	ctx = ipu_image_convert_prepare(ipu, ic_task, in, out, rot_mode,
+					complete, complete_context);
+	if (IS_ERR(ctx))
+		return ERR_CAST(ctx);
+
+	run = kzalloc(sizeof(*run), GFP_KERNEL);
+	if (!run) {
+		ipu_image_convert_unprepare(ctx);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	run->ctx = ctx;
+	run->in_phys = in->phys0;
+	run->out_phys = out->phys0;
+
+	ret = ipu_image_convert_queue(run);
+	if (ret) {
+		ipu_image_convert_unprepare(ctx);
+		kfree(run);
+		return ERR_PTR(ret);
+	}
+
+	return run;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert);
+
+/* "Canned" synchronous single image conversion */
+static void image_convert_sync_complete(struct ipu_image_convert_run *run,
+					void *data)
+{
+	struct completion *comp = data;
+
+	complete(comp);
+}
+
+int ipu_image_convert_sync(struct ipu_soc *ipu, enum ipu_ic_task ic_task,
+			   struct ipu_image *in, struct ipu_image *out,
+			   enum ipu_rotate_mode rot_mode)
+{
+	struct ipu_image_convert_run *run;
+	struct completion comp;
+	int ret;
+
+	init_completion(&comp);
+
+	run = ipu_image_convert(ipu, ic_task, in, out, rot_mode,
+				image_convert_sync_complete, &comp);
+	if (IS_ERR(run))
+		return PTR_ERR(run);
+
+	ret = wait_for_completion_timeout(&comp, msecs_to_jiffies(10000));
+	ret = (ret == 0) ? -ETIMEDOUT : 0;
+
+	ipu_image_convert_unprepare(run->ctx);
+	kfree(run);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_image_convert_sync);
+
+int ipu_image_convert_init(struct ipu_soc *ipu, struct device *dev)
+{
+	struct ipu_image_convert_priv *priv;
+	int i;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ipu->image_convert_priv = priv;
+	priv->ipu = ipu;
+
+	for (i = 0; i < IC_NUM_TASKS; i++) {
+		struct ipu_image_convert_chan *chan = &priv->chan[i];
+
+		chan->ic_task = i;
+		chan->priv = priv;
+		chan->dma_ch = &image_convert_dma_chan[i];
+		chan->out_eof_irq = -1;
+		chan->rot_out_eof_irq = -1;
+
+		spin_lock_init(&chan->irqlock);
+		INIT_LIST_HEAD(&chan->ctx_list);
+		INIT_LIST_HEAD(&chan->pending_q);
+		INIT_LIST_HEAD(&chan->done_q);
+	}
+
+	return 0;
+}
+
+void ipu_image_convert_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-pre.c b/drivers/gpu/imx/ipu-v3/ipu-pre.c
new file mode 100644
index 0000000..0f70e88
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-pre.c
@@ -0,0 +1,341 @@
+/*
+ * Copyright (c) 2017 Lucas Stach, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <drm/drm_fourcc.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/genalloc.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <video/imx-ipu-v3.h>
+
+#include "ipu-prv.h"
+
+#define IPU_PRE_MAX_WIDTH	2048
+#define IPU_PRE_NUM_SCANLINES	8
+
+#define IPU_PRE_CTRL					0x000
+#define IPU_PRE_CTRL_SET				0x004
+#define  IPU_PRE_CTRL_ENABLE				(1 << 0)
+#define  IPU_PRE_CTRL_BLOCK_EN				(1 << 1)
+#define  IPU_PRE_CTRL_BLOCK_16				(1 << 2)
+#define  IPU_PRE_CTRL_SDW_UPDATE			(1 << 4)
+#define  IPU_PRE_CTRL_VFLIP				(1 << 5)
+#define  IPU_PRE_CTRL_SO				(1 << 6)
+#define  IPU_PRE_CTRL_INTERLACED_FIELD			(1 << 7)
+#define  IPU_PRE_CTRL_HANDSHAKE_EN			(1 << 8)
+#define  IPU_PRE_CTRL_HANDSHAKE_LINE_NUM(v)		((v & 0x3) << 9)
+#define  IPU_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN		(1 << 11)
+#define  IPU_PRE_CTRL_EN_REPEAT				(1 << 28)
+#define  IPU_PRE_CTRL_TPR_REST_SEL			(1 << 29)
+#define  IPU_PRE_CTRL_CLKGATE				(1 << 30)
+#define  IPU_PRE_CTRL_SFTRST				(1 << 31)
+
+#define IPU_PRE_CUR_BUF					0x030
+
+#define IPU_PRE_NEXT_BUF				0x040
+
+#define IPU_PRE_TPR_CTRL				0x070
+#define  IPU_PRE_TPR_CTRL_TILE_FORMAT(v)		((v & 0xff) << 0)
+#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_MASK		0xff
+#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_16_BIT		(1 << 0)
+#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SPLIT_BUF		(1 << 4)
+#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SINGLE_BUF	(1 << 5)
+#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SUPER_TILED	(1 << 6)
+
+#define IPU_PRE_PREFETCH_ENG_CTRL			0x080
+#define  IPU_PRE_PREF_ENG_CTRL_PREFETCH_EN		(1 << 0)
+#define  IPU_PRE_PREF_ENG_CTRL_RD_NUM_BYTES(v)		((v & 0x7) << 1)
+#define  IPU_PRE_PREF_ENG_CTRL_INPUT_ACTIVE_BPP(v)	((v & 0x3) << 4)
+#define  IPU_PRE_PREF_ENG_CTRL_INPUT_PIXEL_FORMAT(v)	((v & 0x7) << 8)
+#define  IPU_PRE_PREF_ENG_CTRL_SHIFT_BYPASS		(1 << 11)
+#define  IPU_PRE_PREF_ENG_CTRL_FIELD_INVERSE		(1 << 12)
+#define  IPU_PRE_PREF_ENG_CTRL_PARTIAL_UV_SWAP		(1 << 14)
+#define  IPU_PRE_PREF_ENG_CTRL_TPR_COOR_OFFSET_EN	(1 << 15)
+
+#define IPU_PRE_PREFETCH_ENG_INPUT_SIZE			0x0a0
+#define  IPU_PRE_PREFETCH_ENG_INPUT_SIZE_WIDTH(v)	((v & 0xffff) << 0)
+#define  IPU_PRE_PREFETCH_ENG_INPUT_SIZE_HEIGHT(v)	((v & 0xffff) << 16)
+
+#define IPU_PRE_PREFETCH_ENG_PITCH			0x0d0
+#define  IPU_PRE_PREFETCH_ENG_PITCH_Y(v)		((v & 0xffff) << 0)
+#define  IPU_PRE_PREFETCH_ENG_PITCH_UV(v)		((v & 0xffff) << 16)
+
+#define IPU_PRE_STORE_ENG_CTRL				0x110
+#define  IPU_PRE_STORE_ENG_CTRL_STORE_EN		(1 << 0)
+#define  IPU_PRE_STORE_ENG_CTRL_WR_NUM_BYTES(v)		((v & 0x7) << 1)
+#define  IPU_PRE_STORE_ENG_CTRL_OUTPUT_ACTIVE_BPP(v)	((v & 0x3) << 4)
+
+#define IPU_PRE_STORE_ENG_STATUS			0x120
+#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_X_MASK	0xffff
+#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_X_SHIFT	0
+#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_MASK	0x3fff
+#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_SHIFT	16
+#define  IPU_PRE_STORE_ENG_STATUS_STORE_FIFO_FULL	(1 << 30)
+#define  IPU_PRE_STORE_ENG_STATUS_STORE_FIELD		(1 << 31)
+
+#define IPU_PRE_STORE_ENG_SIZE				0x130
+#define  IPU_PRE_STORE_ENG_SIZE_INPUT_WIDTH(v)		((v & 0xffff) << 0)
+#define  IPU_PRE_STORE_ENG_SIZE_INPUT_HEIGHT(v)		((v & 0xffff) << 16)
+
+#define IPU_PRE_STORE_ENG_PITCH				0x140
+#define  IPU_PRE_STORE_ENG_PITCH_OUT_PITCH(v)		((v & 0xffff) << 0)
+
+#define IPU_PRE_STORE_ENG_ADDR				0x150
+
+struct ipu_pre {
+	struct list_head	list;
+	struct device		*dev;
+
+	void __iomem		*regs;
+	struct clk		*clk_axi;
+	struct gen_pool		*iram;
+
+	dma_addr_t		buffer_paddr;
+	void			*buffer_virt;
+	bool			in_use;
+	unsigned int		safe_window_end;
+};
+
+static DEFINE_MUTEX(ipu_pre_list_mutex);
+static LIST_HEAD(ipu_pre_list);
+static int available_pres;
+
+int ipu_pre_get_available_count(void)
+{
+	return available_pres;
+}
+
+struct ipu_pre *
+ipu_pre_lookup_by_phandle(struct device *dev, const char *name, int index)
+{
+	struct device_node *pre_node = of_parse_phandle(dev->of_node,
+							name, index);
+	struct ipu_pre *pre;
+
+	mutex_lock(&ipu_pre_list_mutex);
+	list_for_each_entry(pre, &ipu_pre_list, list) {
+		if (pre_node == pre->dev->of_node) {
+			mutex_unlock(&ipu_pre_list_mutex);
+			device_link_add(dev, pre->dev, DL_FLAG_AUTOREMOVE);
+			of_node_put(pre_node);
+			return pre;
+		}
+	}
+	mutex_unlock(&ipu_pre_list_mutex);
+
+	of_node_put(pre_node);
+
+	return NULL;
+}
+
+int ipu_pre_get(struct ipu_pre *pre)
+{
+	u32 val;
+
+	if (pre->in_use)
+		return -EBUSY;
+
+	/* first get the engine out of reset and remove clock gating */
+	writel(0, pre->regs + IPU_PRE_CTRL);
+
+	/* init defaults that should be applied to all streams */
+	val = IPU_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN |
+	      IPU_PRE_CTRL_HANDSHAKE_EN |
+	      IPU_PRE_CTRL_TPR_REST_SEL |
+	      IPU_PRE_CTRL_SDW_UPDATE;
+	writel(val, pre->regs + IPU_PRE_CTRL);
+
+	pre->in_use = true;
+	return 0;
+}
+
+void ipu_pre_put(struct ipu_pre *pre)
+{
+	writel(IPU_PRE_CTRL_SFTRST, pre->regs + IPU_PRE_CTRL);
+
+	pre->in_use = false;
+}
+
+void ipu_pre_configure(struct ipu_pre *pre, unsigned int width,
+		       unsigned int height, unsigned int stride, u32 format,
+		       uint64_t modifier, unsigned int bufaddr)
+{
+	const struct drm_format_info *info = drm_format_info(format);
+	u32 active_bpp = info->cpp[0] >> 1;
+	u32 val;
+
+	/* calculate safe window for ctrl register updates */
+	if (modifier == DRM_FORMAT_MOD_LINEAR)
+		pre->safe_window_end = height - 2;
+	else
+		pre->safe_window_end = DIV_ROUND_UP(height, 4) - 1;
+
+	writel(bufaddr, pre->regs + IPU_PRE_CUR_BUF);
+	writel(bufaddr, pre->regs + IPU_PRE_NEXT_BUF);
+
+	val = IPU_PRE_PREF_ENG_CTRL_INPUT_PIXEL_FORMAT(0) |
+	      IPU_PRE_PREF_ENG_CTRL_INPUT_ACTIVE_BPP(active_bpp) |
+	      IPU_PRE_PREF_ENG_CTRL_RD_NUM_BYTES(4) |
+	      IPU_PRE_PREF_ENG_CTRL_SHIFT_BYPASS |
+	      IPU_PRE_PREF_ENG_CTRL_PREFETCH_EN;
+	writel(val, pre->regs + IPU_PRE_PREFETCH_ENG_CTRL);
+
+	val = IPU_PRE_PREFETCH_ENG_INPUT_SIZE_WIDTH(width) |
+	      IPU_PRE_PREFETCH_ENG_INPUT_SIZE_HEIGHT(height);
+	writel(val, pre->regs + IPU_PRE_PREFETCH_ENG_INPUT_SIZE);
+
+	val = IPU_PRE_PREFETCH_ENG_PITCH_Y(stride);
+	writel(val, pre->regs + IPU_PRE_PREFETCH_ENG_PITCH);
+
+	val = IPU_PRE_STORE_ENG_CTRL_OUTPUT_ACTIVE_BPP(active_bpp) |
+	      IPU_PRE_STORE_ENG_CTRL_WR_NUM_BYTES(4) |
+	      IPU_PRE_STORE_ENG_CTRL_STORE_EN;
+	writel(val, pre->regs + IPU_PRE_STORE_ENG_CTRL);
+
+	val = IPU_PRE_STORE_ENG_SIZE_INPUT_WIDTH(width) |
+	      IPU_PRE_STORE_ENG_SIZE_INPUT_HEIGHT(height);
+	writel(val, pre->regs + IPU_PRE_STORE_ENG_SIZE);
+
+	val = IPU_PRE_STORE_ENG_PITCH_OUT_PITCH(stride);
+	writel(val, pre->regs + IPU_PRE_STORE_ENG_PITCH);
+
+	writel(pre->buffer_paddr, pre->regs + IPU_PRE_STORE_ENG_ADDR);
+
+	val = readl(pre->regs + IPU_PRE_TPR_CTRL);
+	val &= ~IPU_PRE_TPR_CTRL_TILE_FORMAT_MASK;
+	if (modifier != DRM_FORMAT_MOD_LINEAR) {
+		/* only support single buffer formats for now */
+		val |= IPU_PRE_TPR_CTRL_TILE_FORMAT_SINGLE_BUF;
+		if (modifier == DRM_FORMAT_MOD_VIVANTE_SUPER_TILED)
+			val |= IPU_PRE_TPR_CTRL_TILE_FORMAT_SUPER_TILED;
+		if (info->cpp[0] == 2)
+			val |= IPU_PRE_TPR_CTRL_TILE_FORMAT_16_BIT;
+	}
+	writel(val, pre->regs + IPU_PRE_TPR_CTRL);
+
+	val = readl(pre->regs + IPU_PRE_CTRL);
+	val |= IPU_PRE_CTRL_EN_REPEAT | IPU_PRE_CTRL_ENABLE |
+	       IPU_PRE_CTRL_SDW_UPDATE;
+	if (modifier == DRM_FORMAT_MOD_LINEAR)
+		val &= ~IPU_PRE_CTRL_BLOCK_EN;
+	else
+		val |= IPU_PRE_CTRL_BLOCK_EN;
+	writel(val, pre->regs + IPU_PRE_CTRL);
+}
+
+void ipu_pre_update(struct ipu_pre *pre, unsigned int bufaddr)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(5);
+	unsigned short current_yblock;
+	u32 val;
+
+	writel(bufaddr, pre->regs + IPU_PRE_NEXT_BUF);
+
+	do {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(pre->dev, "timeout waiting for PRE safe window\n");
+			return;
+		}
+
+		val = readl(pre->regs + IPU_PRE_STORE_ENG_STATUS);
+		current_yblock =
+			(val >> IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_SHIFT) &
+			IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_MASK;
+	} while (current_yblock == 0 || current_yblock >= pre->safe_window_end);
+
+	writel(IPU_PRE_CTRL_SDW_UPDATE, pre->regs + IPU_PRE_CTRL_SET);
+}
+
+u32 ipu_pre_get_baddr(struct ipu_pre *pre)
+{
+	return (u32)pre->buffer_paddr;
+}
+
+static int ipu_pre_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct ipu_pre *pre;
+
+	pre = devm_kzalloc(dev, sizeof(*pre), GFP_KERNEL);
+	if (!pre)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pre->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pre->regs))
+		return PTR_ERR(pre->regs);
+
+	pre->clk_axi = devm_clk_get(dev, "axi");
+	if (IS_ERR(pre->clk_axi))
+		return PTR_ERR(pre->clk_axi);
+
+	pre->iram = of_gen_pool_get(dev->of_node, "fsl,iram", 0);
+	if (!pre->iram)
+		return -EPROBE_DEFER;
+
+	/*
+	 * Allocate IRAM buffer with maximum size. This could be made dynamic,
+	 * but as there is no other user of this IRAM region and we can fit all
+	 * max sized buffers into it, there is no need yet.
+	 */
+	pre->buffer_virt = gen_pool_dma_alloc(pre->iram, IPU_PRE_MAX_WIDTH *
+					      IPU_PRE_NUM_SCANLINES * 4,
+					      &pre->buffer_paddr);
+	if (!pre->buffer_virt)
+		return -ENOMEM;
+
+	clk_prepare_enable(pre->clk_axi);
+
+	pre->dev = dev;
+	platform_set_drvdata(pdev, pre);
+	mutex_lock(&ipu_pre_list_mutex);
+	list_add(&pre->list, &ipu_pre_list);
+	available_pres++;
+	mutex_unlock(&ipu_pre_list_mutex);
+
+	return 0;
+}
+
+static int ipu_pre_remove(struct platform_device *pdev)
+{
+	struct ipu_pre *pre = platform_get_drvdata(pdev);
+
+	mutex_lock(&ipu_pre_list_mutex);
+	list_del(&pre->list);
+	available_pres--;
+	mutex_unlock(&ipu_pre_list_mutex);
+
+	clk_disable_unprepare(pre->clk_axi);
+
+	if (pre->buffer_virt)
+		gen_pool_free(pre->iram, (unsigned long)pre->buffer_virt,
+			      IPU_PRE_MAX_WIDTH * IPU_PRE_NUM_SCANLINES * 4);
+	return 0;
+}
+
+static const struct of_device_id ipu_pre_dt_ids[] = {
+	{ .compatible = "fsl,imx6qp-pre", },
+	{ /* sentinel */ },
+};
+
+struct platform_driver ipu_pre_drv = {
+	.probe		= ipu_pre_probe,
+	.remove		= ipu_pre_remove,
+	.driver		= {
+		.name	= "imx-ipu-pre",
+		.of_match_table = ipu_pre_dt_ids,
+	},
+};
diff --git a/drivers/gpu/imx/ipu-v3/ipu-prg.c b/drivers/gpu/imx/ipu-v3/ipu-prg.c
new file mode 100644
index 0000000..83f9dd9
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-prg.c
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) 2016-2017 Lucas Stach, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <drm/drm_fourcc.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/iopoll.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <video/imx-ipu-v3.h>
+
+#include "ipu-prv.h"
+
+#define IPU_PRG_CTL				0x00
+#define  IPU_PRG_CTL_BYPASS(i)			(1 << (0 + i))
+#define  IPU_PRG_CTL_SOFT_ARID_MASK		0x3
+#define  IPU_PRG_CTL_SOFT_ARID_SHIFT(i)		(8 + i * 2)
+#define  IPU_PRG_CTL_SOFT_ARID(i, v)		((v & 0x3) << (8 + 2 * i))
+#define  IPU_PRG_CTL_SO(i)			(1 << (16 + i))
+#define  IPU_PRG_CTL_VFLIP(i)			(1 << (19 + i))
+#define  IPU_PRG_CTL_BLOCK_MODE(i)		(1 << (22 + i))
+#define  IPU_PRG_CTL_CNT_LOAD_EN(i)		(1 << (25 + i))
+#define  IPU_PRG_CTL_SOFTRST			(1 << 30)
+#define  IPU_PRG_CTL_SHADOW_EN			(1 << 31)
+
+#define IPU_PRG_STATUS				0x04
+#define  IPU_PRG_STATUS_BUFFER0_READY(i)	(1 << (0 + i * 2))
+#define  IPU_PRG_STATUS_BUFFER1_READY(i)	(1 << (1 + i * 2))
+
+#define IPU_PRG_QOS				0x08
+#define  IPU_PRG_QOS_ARID_MASK			0xf
+#define  IPU_PRG_QOS_ARID_SHIFT(i)		(0 + i * 4)
+
+#define IPU_PRG_REG_UPDATE			0x0c
+#define  IPU_PRG_REG_UPDATE_REG_UPDATE		(1 << 0)
+
+#define IPU_PRG_STRIDE(i)			(0x10 + i * 0x4)
+#define  IPU_PRG_STRIDE_STRIDE_MASK		0x3fff
+
+#define IPU_PRG_CROP_LINE			0x1c
+
+#define IPU_PRG_THD				0x20
+
+#define IPU_PRG_BADDR(i)			(0x24 + i * 0x4)
+
+#define IPU_PRG_OFFSET(i)			(0x30 + i * 0x4)
+
+#define IPU_PRG_ILO(i)				(0x3c + i * 0x4)
+
+#define IPU_PRG_HEIGHT(i)			(0x48 + i * 0x4)
+#define  IPU_PRG_HEIGHT_PRE_HEIGHT_MASK		0xfff
+#define  IPU_PRG_HEIGHT_PRE_HEIGHT_SHIFT	0
+#define  IPU_PRG_HEIGHT_IPU_HEIGHT_MASK		0xfff
+#define  IPU_PRG_HEIGHT_IPU_HEIGHT_SHIFT	16
+
+struct ipu_prg_channel {
+	bool			enabled;
+	int			used_pre;
+};
+
+struct ipu_prg {
+	struct list_head	list;
+	struct device		*dev;
+	int			id;
+
+	void __iomem		*regs;
+	struct clk		*clk_ipg, *clk_axi;
+	struct regmap		*iomuxc_gpr;
+	struct ipu_pre		*pres[3];
+
+	struct ipu_prg_channel	chan[3];
+};
+
+static DEFINE_MUTEX(ipu_prg_list_mutex);
+static LIST_HEAD(ipu_prg_list);
+
+struct ipu_prg *
+ipu_prg_lookup_by_phandle(struct device *dev, const char *name, int ipu_id)
+{
+	struct device_node *prg_node = of_parse_phandle(dev->of_node,
+							name, 0);
+	struct ipu_prg *prg;
+
+	mutex_lock(&ipu_prg_list_mutex);
+	list_for_each_entry(prg, &ipu_prg_list, list) {
+		if (prg_node == prg->dev->of_node) {
+			mutex_unlock(&ipu_prg_list_mutex);
+			device_link_add(dev, prg->dev, DL_FLAG_AUTOREMOVE);
+			prg->id = ipu_id;
+			of_node_put(prg_node);
+			return prg;
+		}
+	}
+	mutex_unlock(&ipu_prg_list_mutex);
+
+	of_node_put(prg_node);
+
+	return NULL;
+}
+
+int ipu_prg_max_active_channels(void)
+{
+	return ipu_pre_get_available_count();
+}
+EXPORT_SYMBOL_GPL(ipu_prg_max_active_channels);
+
+bool ipu_prg_present(struct ipu_soc *ipu)
+{
+	if (ipu->prg_priv)
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(ipu_prg_present);
+
+bool ipu_prg_format_supported(struct ipu_soc *ipu, uint32_t format,
+			      uint64_t modifier)
+{
+	const struct drm_format_info *info = drm_format_info(format);
+
+	if (info->num_planes != 1)
+		return false;
+
+	switch (modifier) {
+	case DRM_FORMAT_MOD_LINEAR:
+	case DRM_FORMAT_MOD_VIVANTE_TILED:
+	case DRM_FORMAT_MOD_VIVANTE_SUPER_TILED:
+		return true;
+	default:
+		return false;
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_prg_format_supported);
+
+int ipu_prg_enable(struct ipu_soc *ipu)
+{
+	struct ipu_prg *prg = ipu->prg_priv;
+
+	if (!prg)
+		return 0;
+
+	return pm_runtime_get_sync(prg->dev);
+}
+EXPORT_SYMBOL_GPL(ipu_prg_enable);
+
+void ipu_prg_disable(struct ipu_soc *ipu)
+{
+	struct ipu_prg *prg = ipu->prg_priv;
+
+	if (!prg)
+		return;
+
+	pm_runtime_put(prg->dev);
+}
+EXPORT_SYMBOL_GPL(ipu_prg_disable);
+
+/*
+ * The channel configuartion functions below are not thread safe, as they
+ * must be only called from the atomic commit path in the DRM driver, which
+ * is properly serialized.
+ */
+static int ipu_prg_ipu_to_prg_chan(int ipu_chan)
+{
+	/*
+	 * This isn't clearly documented in the RM, but IPU to PRG channel
+	 * assignment is fixed, as only with this mapping the control signals
+	 * match up.
+	 */
+	switch (ipu_chan) {
+	case IPUV3_CHANNEL_MEM_BG_SYNC:
+		return 0;
+	case IPUV3_CHANNEL_MEM_FG_SYNC:
+		return 1;
+	case IPUV3_CHANNEL_MEM_DC_SYNC:
+		return 2;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ipu_prg_get_pre(struct ipu_prg *prg, int prg_chan)
+{
+	int i, ret;
+
+	/* channel 0 is special as it is hardwired to one of the PREs */
+	if (prg_chan == 0) {
+		ret = ipu_pre_get(prg->pres[0]);
+		if (ret)
+			goto fail;
+		prg->chan[prg_chan].used_pre = 0;
+		return 0;
+	}
+
+	for (i = 1; i < 3; i++) {
+		ret = ipu_pre_get(prg->pres[i]);
+		if (!ret) {
+			u32 val, mux;
+			int shift;
+
+			prg->chan[prg_chan].used_pre = i;
+
+			/* configure the PRE to PRG channel mux */
+			shift = (i == 1) ? 12 : 14;
+			mux = (prg->id << 1) | (prg_chan - 1);
+			regmap_update_bits(prg->iomuxc_gpr, IOMUXC_GPR5,
+					   0x3 << shift, mux << shift);
+
+			/* check other mux, must not point to same channel */
+			shift = (i == 1) ? 14 : 12;
+			regmap_read(prg->iomuxc_gpr, IOMUXC_GPR5, &val);
+			if (((val >> shift) & 0x3) == mux) {
+				regmap_update_bits(prg->iomuxc_gpr, IOMUXC_GPR5,
+						   0x3 << shift,
+						   (mux ^ 0x1) << shift);
+			}
+
+			return 0;
+		}
+	}
+
+fail:
+	dev_err(prg->dev, "could not get PRE for PRG chan %d", prg_chan);
+	return ret;
+}
+
+static void ipu_prg_put_pre(struct ipu_prg *prg, int prg_chan)
+{
+	struct ipu_prg_channel *chan = &prg->chan[prg_chan];
+
+	ipu_pre_put(prg->pres[chan->used_pre]);
+	chan->used_pre = -1;
+}
+
+void ipu_prg_channel_disable(struct ipuv3_channel *ipu_chan)
+{
+	int prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);
+	struct ipu_prg *prg = ipu_chan->ipu->prg_priv;
+	struct ipu_prg_channel *chan;
+	u32 val;
+
+	if (prg_chan < 0)
+		return;
+
+	chan = &prg->chan[prg_chan];
+	if (!chan->enabled)
+		return;
+
+	pm_runtime_get_sync(prg->dev);
+
+	val = readl(prg->regs + IPU_PRG_CTL);
+	val |= IPU_PRG_CTL_BYPASS(prg_chan);
+	writel(val, prg->regs + IPU_PRG_CTL);
+
+	val = IPU_PRG_REG_UPDATE_REG_UPDATE;
+	writel(val, prg->regs + IPU_PRG_REG_UPDATE);
+
+	pm_runtime_put(prg->dev);
+
+	ipu_prg_put_pre(prg, prg_chan);
+
+	chan->enabled = false;
+}
+EXPORT_SYMBOL_GPL(ipu_prg_channel_disable);
+
+int ipu_prg_channel_configure(struct ipuv3_channel *ipu_chan,
+			      unsigned int axi_id, unsigned int width,
+			      unsigned int height, unsigned int stride,
+			      u32 format, uint64_t modifier, unsigned long *eba)
+{
+	int prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);
+	struct ipu_prg *prg = ipu_chan->ipu->prg_priv;
+	struct ipu_prg_channel *chan;
+	u32 val;
+	int ret;
+
+	if (prg_chan < 0)
+		return prg_chan;
+
+	chan = &prg->chan[prg_chan];
+
+	if (chan->enabled) {
+		ipu_pre_update(prg->pres[chan->used_pre], *eba);
+		return 0;
+	}
+
+	ret = ipu_prg_get_pre(prg, prg_chan);
+	if (ret)
+		return ret;
+
+	ipu_pre_configure(prg->pres[chan->used_pre],
+			  width, height, stride, format, modifier, *eba);
+
+
+	pm_runtime_get_sync(prg->dev);
+
+	val = (stride - 1) & IPU_PRG_STRIDE_STRIDE_MASK;
+	writel(val, prg->regs + IPU_PRG_STRIDE(prg_chan));
+
+	val = ((height & IPU_PRG_HEIGHT_PRE_HEIGHT_MASK) <<
+	       IPU_PRG_HEIGHT_PRE_HEIGHT_SHIFT) |
+	      ((height & IPU_PRG_HEIGHT_IPU_HEIGHT_MASK) <<
+	       IPU_PRG_HEIGHT_IPU_HEIGHT_SHIFT);
+	writel(val, prg->regs + IPU_PRG_HEIGHT(prg_chan));
+
+	val = ipu_pre_get_baddr(prg->pres[chan->used_pre]);
+	*eba = val;
+	writel(val, prg->regs + IPU_PRG_BADDR(prg_chan));
+
+	val = readl(prg->regs + IPU_PRG_CTL);
+	/* config AXI ID */
+	val &= ~(IPU_PRG_CTL_SOFT_ARID_MASK <<
+		 IPU_PRG_CTL_SOFT_ARID_SHIFT(prg_chan));
+	val |= IPU_PRG_CTL_SOFT_ARID(prg_chan, axi_id);
+	/* enable channel */
+	val &= ~IPU_PRG_CTL_BYPASS(prg_chan);
+	writel(val, prg->regs + IPU_PRG_CTL);
+
+	val = IPU_PRG_REG_UPDATE_REG_UPDATE;
+	writel(val, prg->regs + IPU_PRG_REG_UPDATE);
+
+	/* wait for both double buffers to be filled */
+	readl_poll_timeout(prg->regs + IPU_PRG_STATUS, val,
+			   (val & IPU_PRG_STATUS_BUFFER0_READY(prg_chan)) &&
+			   (val & IPU_PRG_STATUS_BUFFER1_READY(prg_chan)),
+			   5, 1000);
+
+	pm_runtime_put(prg->dev);
+
+	chan->enabled = true;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_prg_channel_configure);
+
+static int ipu_prg_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct ipu_prg *prg;
+	u32 val;
+	int i, ret;
+
+	prg = devm_kzalloc(dev, sizeof(*prg), GFP_KERNEL);
+	if (!prg)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	prg->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(prg->regs))
+		return PTR_ERR(prg->regs);
+
+
+	prg->clk_ipg = devm_clk_get(dev, "ipg");
+	if (IS_ERR(prg->clk_ipg))
+		return PTR_ERR(prg->clk_ipg);
+
+	prg->clk_axi = devm_clk_get(dev, "axi");
+	if (IS_ERR(prg->clk_axi))
+		return PTR_ERR(prg->clk_axi);
+
+	prg->iomuxc_gpr =
+		syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+	if (IS_ERR(prg->iomuxc_gpr))
+		return PTR_ERR(prg->iomuxc_gpr);
+
+	for (i = 0; i < 3; i++) {
+		prg->pres[i] = ipu_pre_lookup_by_phandle(dev, "fsl,pres", i);
+		if (!prg->pres[i])
+			return -EPROBE_DEFER;
+	}
+
+	ret = clk_prepare_enable(prg->clk_ipg);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(prg->clk_axi);
+	if (ret) {
+		clk_disable_unprepare(prg->clk_ipg);
+		return ret;
+	}
+
+	/* init to free running mode */
+	val = readl(prg->regs + IPU_PRG_CTL);
+	val |= IPU_PRG_CTL_SHADOW_EN;
+	writel(val, prg->regs + IPU_PRG_CTL);
+
+	/* disable address threshold */
+	writel(0xffffffff, prg->regs + IPU_PRG_THD);
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	prg->dev = dev;
+	platform_set_drvdata(pdev, prg);
+	mutex_lock(&ipu_prg_list_mutex);
+	list_add(&prg->list, &ipu_prg_list);
+	mutex_unlock(&ipu_prg_list_mutex);
+
+	return 0;
+}
+
+static int ipu_prg_remove(struct platform_device *pdev)
+{
+	struct ipu_prg *prg = platform_get_drvdata(pdev);
+
+	mutex_lock(&ipu_prg_list_mutex);
+	list_del(&prg->list);
+	mutex_unlock(&ipu_prg_list_mutex);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int prg_suspend(struct device *dev)
+{
+	struct ipu_prg *prg = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(prg->clk_axi);
+	clk_disable_unprepare(prg->clk_ipg);
+
+	return 0;
+}
+
+static int prg_resume(struct device *dev)
+{
+	struct ipu_prg *prg = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(prg->clk_ipg);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(prg->clk_axi);
+	if (ret) {
+		clk_disable_unprepare(prg->clk_ipg);
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops prg_pm_ops = {
+	SET_RUNTIME_PM_OPS(prg_suspend, prg_resume, NULL)
+};
+
+static const struct of_device_id ipu_prg_dt_ids[] = {
+	{ .compatible = "fsl,imx6qp-prg", },
+	{ /* sentinel */ },
+};
+
+struct platform_driver ipu_prg_drv = {
+	.probe		= ipu_prg_probe,
+	.remove		= ipu_prg_remove,
+	.driver		= {
+		.name	= "imx-ipu-prg",
+		.pm	= &prg_pm_ops,
+		.of_match_table = ipu_prg_dt_ids,
+	},
+};
diff --git a/drivers/gpu/imx/ipu-v3/ipu-prv.h b/drivers/gpu/imx/ipu-v3/ipu-prv.h
new file mode 100644
index 0000000..d6beee9
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-prv.h
@@ -0,0 +1,282 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#ifndef __IPU_PRV_H__
+#define __IPU_PRV_H__
+
+struct ipu_soc;
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <video/imx-ipu-v3.h>
+
+#define IPU_MCU_T_DEFAULT	8
+#define IPU_CM_IDMAC_REG_OFS	0x00008000
+#define IPU_CM_IC_REG_OFS	0x00020000
+#define IPU_CM_IRT_REG_OFS	0x00028000
+#define IPU_CM_CSI0_REG_OFS	0x00030000
+#define IPU_CM_CSI1_REG_OFS	0x00038000
+#define IPU_CM_SMFC_REG_OFS	0x00050000
+#define IPU_CM_DC_REG_OFS	0x00058000
+#define IPU_CM_DMFC_REG_OFS	0x00060000
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CM_REG(offset)	(offset)
+
+#define IPU_CONF			IPU_CM_REG(0)
+
+#define IPU_SRM_PRI1			IPU_CM_REG(0x00a0)
+#define IPU_SRM_PRI2			IPU_CM_REG(0x00a4)
+#define IPU_FS_PROC_FLOW1		IPU_CM_REG(0x00a8)
+#define IPU_FS_PROC_FLOW2		IPU_CM_REG(0x00ac)
+#define IPU_FS_PROC_FLOW3		IPU_CM_REG(0x00b0)
+#define IPU_FS_DISP_FLOW1		IPU_CM_REG(0x00b4)
+#define IPU_FS_DISP_FLOW2		IPU_CM_REG(0x00b8)
+#define IPU_SKIP			IPU_CM_REG(0x00bc)
+#define IPU_DISP_ALT_CONF		IPU_CM_REG(0x00c0)
+#define IPU_DISP_GEN			IPU_CM_REG(0x00c4)
+#define IPU_DISP_ALT1			IPU_CM_REG(0x00c8)
+#define IPU_DISP_ALT2			IPU_CM_REG(0x00cc)
+#define IPU_DISP_ALT3			IPU_CM_REG(0x00d0)
+#define IPU_DISP_ALT4			IPU_CM_REG(0x00d4)
+#define IPU_SNOOP			IPU_CM_REG(0x00d8)
+#define IPU_MEM_RST			IPU_CM_REG(0x00dc)
+#define IPU_PM				IPU_CM_REG(0x00e0)
+#define IPU_GPR				IPU_CM_REG(0x00e4)
+#define IPU_CHA_DB_MODE_SEL(ch)		IPU_CM_REG(0x0150 + 4 * ((ch) / 32))
+#define IPU_ALT_CHA_DB_MODE_SEL(ch)	IPU_CM_REG(0x0168 + 4 * ((ch) / 32))
+#define IPU_CHA_CUR_BUF(ch)		IPU_CM_REG(0x023C + 4 * ((ch) / 32))
+#define IPU_ALT_CUR_BUF0		IPU_CM_REG(0x0244)
+#define IPU_ALT_CUR_BUF1		IPU_CM_REG(0x0248)
+#define IPU_SRM_STAT			IPU_CM_REG(0x024C)
+#define IPU_PROC_TASK_STAT		IPU_CM_REG(0x0250)
+#define IPU_DISP_TASK_STAT		IPU_CM_REG(0x0254)
+#define IPU_CHA_BUF0_RDY(ch)		IPU_CM_REG(0x0268 + 4 * ((ch) / 32))
+#define IPU_CHA_BUF1_RDY(ch)		IPU_CM_REG(0x0270 + 4 * ((ch) / 32))
+#define IPU_CHA_BUF2_RDY(ch)		IPU_CM_REG(0x0288 + 4 * ((ch) / 32))
+#define IPU_ALT_CHA_BUF0_RDY(ch)	IPU_CM_REG(0x0278 + 4 * ((ch) / 32))
+#define IPU_ALT_CHA_BUF1_RDY(ch)	IPU_CM_REG(0x0280 + 4 * ((ch) / 32))
+
+#define IPU_INT_CTRL(n)		IPU_CM_REG(0x003C + 4 * (n))
+#define IPU_INT_STAT(n)		IPU_CM_REG(0x0200 + 4 * (n))
+
+/* SRM_PRI2 */
+#define DP_S_SRM_MODE_MASK		(0x3 << 3)
+#define DP_S_SRM_MODE_NOW		(0x3 << 3)
+#define DP_S_SRM_MODE_NEXT_FRAME	(0x1 << 3)
+
+/* FS_PROC_FLOW1 */
+#define FS_PRPENC_ROT_SRC_SEL_MASK	(0xf << 0)
+#define FS_PRPENC_ROT_SRC_SEL_ENC		(0x7 << 0)
+#define FS_PRPVF_ROT_SRC_SEL_MASK	(0xf << 8)
+#define FS_PRPVF_ROT_SRC_SEL_VF			(0x8 << 8)
+#define FS_PP_SRC_SEL_MASK		(0xf << 12)
+#define FS_PP_ROT_SRC_SEL_MASK		(0xf << 16)
+#define FS_PP_ROT_SRC_SEL_PP			(0x5 << 16)
+#define FS_VDI1_SRC_SEL_MASK		(0x3 << 20)
+#define FS_VDI3_SRC_SEL_MASK		(0x3 << 20)
+#define FS_PRP_SRC_SEL_MASK		(0xf << 24)
+#define FS_VDI_SRC_SEL_MASK		(0x3 << 28)
+#define FS_VDI_SRC_SEL_CSI_DIRECT		(0x1 << 28)
+#define FS_VDI_SRC_SEL_VDOA			(0x2 << 28)
+
+/* FS_PROC_FLOW2 */
+#define FS_PRP_ENC_DEST_SEL_MASK	(0xf << 0)
+#define FS_PRP_ENC_DEST_SEL_IRT_ENC		(0x1 << 0)
+#define FS_PRPVF_DEST_SEL_MASK		(0xf << 4)
+#define FS_PRPVF_DEST_SEL_IRT_VF		(0x1 << 4)
+#define FS_PRPVF_ROT_DEST_SEL_MASK	(0xf << 8)
+#define FS_PP_DEST_SEL_MASK		(0xf << 12)
+#define FS_PP_DEST_SEL_IRT_PP			(0x3 << 12)
+#define FS_PP_ROT_DEST_SEL_MASK		(0xf << 16)
+#define FS_PRPENC_ROT_DEST_SEL_MASK	(0xf << 20)
+#define FS_PRP_DEST_SEL_MASK		(0xf << 24)
+
+#define IPU_DI0_COUNTER_RELEASE			(1 << 24)
+#define IPU_DI1_COUNTER_RELEASE			(1 << 25)
+
+#define IPU_IDMAC_REG(offset)	(offset)
+
+#define IDMAC_CONF			IPU_IDMAC_REG(0x0000)
+#define IDMAC_CHA_EN(ch)		IPU_IDMAC_REG(0x0004 + 4 * ((ch) / 32))
+#define IDMAC_SEP_ALPHA			IPU_IDMAC_REG(0x000c)
+#define IDMAC_ALT_SEP_ALPHA		IPU_IDMAC_REG(0x0010)
+#define IDMAC_CHA_PRI(ch)		IPU_IDMAC_REG(0x0014 + 4 * ((ch) / 32))
+#define IDMAC_WM_EN(ch)			IPU_IDMAC_REG(0x001c + 4 * ((ch) / 32))
+#define IDMAC_CH_LOCK_EN_1		IPU_IDMAC_REG(0x0024)
+#define IDMAC_CH_LOCK_EN_2		IPU_IDMAC_REG(0x0028)
+#define IDMAC_SUB_ADDR_0		IPU_IDMAC_REG(0x002c)
+#define IDMAC_SUB_ADDR_1		IPU_IDMAC_REG(0x0030)
+#define IDMAC_SUB_ADDR_2		IPU_IDMAC_REG(0x0034)
+#define IDMAC_BAND_EN(ch)		IPU_IDMAC_REG(0x0040 + 4 * ((ch) / 32))
+#define IDMAC_CHA_BUSY(ch)		IPU_IDMAC_REG(0x0100 + 4 * ((ch) / 32))
+
+#define IPU_NUM_IRQS	(32 * 15)
+
+enum ipu_modules {
+	IPU_CONF_CSI0_EN		= (1 << 0),
+	IPU_CONF_CSI1_EN		= (1 << 1),
+	IPU_CONF_IC_EN			= (1 << 2),
+	IPU_CONF_ROT_EN			= (1 << 3),
+	IPU_CONF_ISP_EN			= (1 << 4),
+	IPU_CONF_DP_EN			= (1 << 5),
+	IPU_CONF_DI0_EN			= (1 << 6),
+	IPU_CONF_DI1_EN			= (1 << 7),
+	IPU_CONF_SMFC_EN		= (1 << 8),
+	IPU_CONF_DC_EN			= (1 << 9),
+	IPU_CONF_DMFC_EN		= (1 << 10),
+
+	IPU_CONF_VDI_EN			= (1 << 12),
+
+	IPU_CONF_IDMAC_DIS		= (1 << 22),
+
+	IPU_CONF_IC_DMFC_SEL		= (1 << 25),
+	IPU_CONF_IC_DMFC_SYNC		= (1 << 26),
+	IPU_CONF_VDI_DMFC_SYNC		= (1 << 27),
+
+	IPU_CONF_CSI0_DATA_SOURCE	= (1 << 28),
+	IPU_CONF_CSI1_DATA_SOURCE	= (1 << 29),
+	IPU_CONF_IC_INPUT		= (1 << 30),
+	IPU_CONF_CSI_SEL		= (1 << 31),
+};
+
+struct ipuv3_channel {
+	unsigned int num;
+	struct ipu_soc *ipu;
+	struct list_head list;
+};
+
+struct ipu_cpmem;
+struct ipu_csi;
+struct ipu_dc_priv;
+struct ipu_dmfc_priv;
+struct ipu_di;
+struct ipu_ic_priv;
+struct ipu_vdi;
+struct ipu_image_convert_priv;
+struct ipu_smfc_priv;
+struct ipu_pre;
+struct ipu_prg;
+
+struct ipu_devtype;
+
+struct ipu_soc {
+	struct device		*dev;
+	const struct ipu_devtype	*devtype;
+	enum ipuv3_type		ipu_type;
+	spinlock_t		lock;
+	struct mutex		channel_lock;
+	struct list_head	channels;
+
+	void __iomem		*cm_reg;
+	void __iomem		*idmac_reg;
+
+	int			id;
+	int			usecount;
+
+	struct clk		*clk;
+
+	int			irq_sync;
+	int			irq_err;
+	struct irq_domain	*domain;
+
+	struct ipu_cpmem	*cpmem_priv;
+	struct ipu_dc_priv	*dc_priv;
+	struct ipu_dp_priv	*dp_priv;
+	struct ipu_dmfc_priv	*dmfc_priv;
+	struct ipu_di		*di_priv[2];
+	struct ipu_csi		*csi_priv[2];
+	struct ipu_ic_priv	*ic_priv;
+	struct ipu_vdi          *vdi_priv;
+	struct ipu_image_convert_priv *image_convert_priv;
+	struct ipu_smfc_priv	*smfc_priv;
+	struct ipu_prg		*prg_priv;
+};
+
+static inline u32 ipu_idmac_read(struct ipu_soc *ipu, unsigned offset)
+{
+	return readl(ipu->idmac_reg + offset);
+}
+
+static inline void ipu_idmac_write(struct ipu_soc *ipu, u32 value,
+				   unsigned offset)
+{
+	writel(value, ipu->idmac_reg + offset);
+}
+
+void ipu_srm_dp_update(struct ipu_soc *ipu, bool sync);
+
+int ipu_module_enable(struct ipu_soc *ipu, u32 mask);
+int ipu_module_disable(struct ipu_soc *ipu, u32 mask);
+
+bool ipu_idmac_channel_busy(struct ipu_soc *ipu, unsigned int chno);
+
+int ipu_csi_init(struct ipu_soc *ipu, struct device *dev, int id,
+		 unsigned long base, u32 module, struct clk *clk_ipu);
+void ipu_csi_exit(struct ipu_soc *ipu, int id);
+
+int ipu_ic_init(struct ipu_soc *ipu, struct device *dev,
+		unsigned long base, unsigned long tpmem_base);
+void ipu_ic_exit(struct ipu_soc *ipu);
+
+int ipu_vdi_init(struct ipu_soc *ipu, struct device *dev,
+		 unsigned long base, u32 module);
+void ipu_vdi_exit(struct ipu_soc *ipu);
+
+int ipu_image_convert_init(struct ipu_soc *ipu, struct device *dev);
+void ipu_image_convert_exit(struct ipu_soc *ipu);
+
+int ipu_di_init(struct ipu_soc *ipu, struct device *dev, int id,
+		unsigned long base, u32 module, struct clk *ipu_clk);
+void ipu_di_exit(struct ipu_soc *ipu, int id);
+
+int ipu_dmfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,
+		struct clk *ipu_clk);
+void ipu_dmfc_exit(struct ipu_soc *ipu);
+
+int ipu_dp_init(struct ipu_soc *ipu, struct device *dev, unsigned long base);
+void ipu_dp_exit(struct ipu_soc *ipu);
+
+int ipu_dc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,
+		unsigned long template_base);
+void ipu_dc_exit(struct ipu_soc *ipu);
+
+int ipu_cpmem_init(struct ipu_soc *ipu, struct device *dev, unsigned long base);
+void ipu_cpmem_exit(struct ipu_soc *ipu);
+
+int ipu_smfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base);
+void ipu_smfc_exit(struct ipu_soc *ipu);
+
+struct ipu_pre *ipu_pre_lookup_by_phandle(struct device *dev, const char *name,
+					  int index);
+int ipu_pre_get_available_count(void);
+int ipu_pre_get(struct ipu_pre *pre);
+void ipu_pre_put(struct ipu_pre *pre);
+u32 ipu_pre_get_baddr(struct ipu_pre *pre);
+void ipu_pre_configure(struct ipu_pre *pre, unsigned int width,
+		       unsigned int height, unsigned int stride, u32 format,
+		       uint64_t modifier, unsigned int bufaddr);
+void ipu_pre_update(struct ipu_pre *pre, unsigned int bufaddr);
+
+struct ipu_prg *ipu_prg_lookup_by_phandle(struct device *dev, const char *name,
+					  int ipu_id);
+
+extern struct platform_driver ipu_pre_drv;
+extern struct platform_driver ipu_prg_drv;
+
+#endif				/* __IPU_PRV_H__ */
diff --git a/drivers/gpu/imx/ipu-v3/ipu-smfc.c b/drivers/gpu/imx/ipu-v3/ipu-smfc.c
new file mode 100644
index 0000000..4ef9109
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-smfc.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/export.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <video/imx-ipu-v3.h>
+
+#include "ipu-prv.h"
+
+struct ipu_smfc {
+	struct ipu_smfc_priv *priv;
+	int chno;
+	bool inuse;
+};
+
+struct ipu_smfc_priv {
+	void __iomem *base;
+	spinlock_t lock;
+	struct ipu_soc *ipu;
+	struct ipu_smfc channel[4];
+	int use_count;
+};
+
+/*SMFC Registers */
+#define SMFC_MAP	0x0000
+#define SMFC_WMC	0x0004
+#define SMFC_BS		0x0008
+
+int ipu_smfc_set_burstsize(struct ipu_smfc *smfc, int burstsize)
+{
+	struct ipu_smfc_priv *priv = smfc->priv;
+	unsigned long flags;
+	u32 val, shift;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	shift = smfc->chno * 4;
+	val = readl(priv->base + SMFC_BS);
+	val &= ~(0xf << shift);
+	val |= burstsize << shift;
+	writel(val, priv->base + SMFC_BS);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_set_burstsize);
+
+int ipu_smfc_map_channel(struct ipu_smfc *smfc, int csi_id, int mipi_id)
+{
+	struct ipu_smfc_priv *priv = smfc->priv;
+	unsigned long flags;
+	u32 val, shift;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	shift = smfc->chno * 3;
+	val = readl(priv->base + SMFC_MAP);
+	val &= ~(0x7 << shift);
+	val |= ((csi_id << 2) | mipi_id) << shift;
+	writel(val, priv->base + SMFC_MAP);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_map_channel);
+
+int ipu_smfc_set_watermark(struct ipu_smfc *smfc, u32 set_level, u32 clr_level)
+{
+	struct ipu_smfc_priv *priv = smfc->priv;
+	unsigned long flags;
+	u32 val, shift;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	shift = smfc->chno * 6 + (smfc->chno > 1 ? 4 : 0);
+	val = readl(priv->base + SMFC_WMC);
+	val &= ~(0x3f << shift);
+	val |= ((clr_level << 3) | set_level) << shift;
+	writel(val, priv->base + SMFC_WMC);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_set_watermark);
+
+int ipu_smfc_enable(struct ipu_smfc *smfc)
+{
+	struct ipu_smfc_priv *priv = smfc->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!priv->use_count)
+		ipu_module_enable(priv->ipu, IPU_CONF_SMFC_EN);
+
+	priv->use_count++;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_enable);
+
+int ipu_smfc_disable(struct ipu_smfc *smfc)
+{
+	struct ipu_smfc_priv *priv = smfc->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	priv->use_count--;
+
+	if (!priv->use_count)
+		ipu_module_disable(priv->ipu, IPU_CONF_SMFC_EN);
+
+	if (priv->use_count < 0)
+		priv->use_count = 0;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_disable);
+
+struct ipu_smfc *ipu_smfc_get(struct ipu_soc *ipu, unsigned int chno)
+{
+	struct ipu_smfc_priv *priv = ipu->smfc_priv;
+	struct ipu_smfc *smfc, *ret;
+	unsigned long flags;
+
+	if (chno >= 4)
+		return ERR_PTR(-EINVAL);
+
+	smfc = &priv->channel[chno];
+	ret = smfc;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (smfc->inuse) {
+		ret = ERR_PTR(-EBUSY);
+		goto unlock;
+	}
+
+	smfc->inuse = true;
+unlock:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_get);
+
+void ipu_smfc_put(struct ipu_smfc *smfc)
+{
+	struct ipu_smfc_priv *priv = smfc->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	smfc->inuse = false;
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_smfc_put);
+
+int ipu_smfc_init(struct ipu_soc *ipu, struct device *dev,
+		  unsigned long base)
+{
+	struct ipu_smfc_priv *priv;
+	int i;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ipu->smfc_priv = priv;
+	spin_lock_init(&priv->lock);
+	priv->ipu = ipu;
+
+	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!priv->base)
+		return -ENOMEM;
+
+	for (i = 0; i < 4; i++) {
+		priv->channel[i].priv = priv;
+		priv->channel[i].chno = i;
+	}
+
+	pr_debug("%s: ioremap 0x%08lx -> %p\n", __func__, base, priv->base);
+
+	return 0;
+}
+
+void ipu_smfc_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/imx/ipu-v3/ipu-vdi.c b/drivers/gpu/imx/ipu-v3/ipu-vdi.c
new file mode 100644
index 0000000..a663893
--- /dev/null
+++ b/drivers/gpu/imx/ipu-v3/ipu-vdi.c
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2012-2016 Mentor Graphics Inc.
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#include <linux/io.h>
+#include "ipu-prv.h"
+
+struct ipu_vdi {
+	void __iomem *base;
+	u32 module;
+	spinlock_t lock;
+	int use_count;
+	struct ipu_soc *ipu;
+};
+
+
+/* VDI Register Offsets */
+#define VDI_FSIZE 0x0000
+#define VDI_C     0x0004
+
+/* VDI Register Fields */
+#define VDI_C_CH_420             (0 << 1)
+#define VDI_C_CH_422             (1 << 1)
+#define VDI_C_MOT_SEL_MASK       (0x3 << 2)
+#define VDI_C_MOT_SEL_FULL       (2 << 2)
+#define VDI_C_MOT_SEL_LOW        (1 << 2)
+#define VDI_C_MOT_SEL_MED        (0 << 2)
+#define VDI_C_BURST_SIZE1_4      (3 << 4)
+#define VDI_C_BURST_SIZE2_4      (3 << 8)
+#define VDI_C_BURST_SIZE3_4      (3 << 12)
+#define VDI_C_BURST_SIZE_MASK    0xF
+#define VDI_C_BURST_SIZE1_OFFSET 4
+#define VDI_C_BURST_SIZE2_OFFSET 8
+#define VDI_C_BURST_SIZE3_OFFSET 12
+#define VDI_C_VWM1_SET_1         (0 << 16)
+#define VDI_C_VWM1_SET_2         (1 << 16)
+#define VDI_C_VWM1_CLR_2         (1 << 19)
+#define VDI_C_VWM3_SET_1         (0 << 22)
+#define VDI_C_VWM3_SET_2         (1 << 22)
+#define VDI_C_VWM3_CLR_2         (1 << 25)
+#define VDI_C_TOP_FIELD_MAN_1    (1 << 30)
+#define VDI_C_TOP_FIELD_AUTO_1   (1 << 31)
+
+static inline u32 ipu_vdi_read(struct ipu_vdi *vdi, unsigned int offset)
+{
+	return readl(vdi->base + offset);
+}
+
+static inline void ipu_vdi_write(struct ipu_vdi *vdi, u32 value,
+				 unsigned int offset)
+{
+	writel(value, vdi->base + offset);
+}
+
+void ipu_vdi_set_field_order(struct ipu_vdi *vdi, v4l2_std_id std, u32 field)
+{
+	bool top_field_0 = false;
+	unsigned long flags;
+	u32 reg;
+
+	switch (field) {
+	case V4L2_FIELD_INTERLACED_TB:
+	case V4L2_FIELD_SEQ_TB:
+	case V4L2_FIELD_TOP:
+		top_field_0 = true;
+		break;
+	case V4L2_FIELD_INTERLACED_BT:
+	case V4L2_FIELD_SEQ_BT:
+	case V4L2_FIELD_BOTTOM:
+		top_field_0 = false;
+		break;
+	default:
+		top_field_0 = (std & V4L2_STD_525_60) ? true : false;
+		break;
+	}
+
+	spin_lock_irqsave(&vdi->lock, flags);
+
+	reg = ipu_vdi_read(vdi, VDI_C);
+	if (top_field_0)
+		reg &= ~(VDI_C_TOP_FIELD_MAN_1 | VDI_C_TOP_FIELD_AUTO_1);
+	else
+		reg |= VDI_C_TOP_FIELD_MAN_1 | VDI_C_TOP_FIELD_AUTO_1;
+	ipu_vdi_write(vdi, reg, VDI_C);
+
+	spin_unlock_irqrestore(&vdi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_set_field_order);
+
+void ipu_vdi_set_motion(struct ipu_vdi *vdi, enum ipu_motion_sel motion_sel)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&vdi->lock, flags);
+
+	reg = ipu_vdi_read(vdi, VDI_C);
+
+	reg &= ~VDI_C_MOT_SEL_MASK;
+
+	switch (motion_sel) {
+	case MED_MOTION:
+		reg |= VDI_C_MOT_SEL_MED;
+		break;
+	case HIGH_MOTION:
+		reg |= VDI_C_MOT_SEL_FULL;
+		break;
+	default:
+		reg |= VDI_C_MOT_SEL_LOW;
+		break;
+	}
+
+	ipu_vdi_write(vdi, reg, VDI_C);
+
+	spin_unlock_irqrestore(&vdi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_set_motion);
+
+void ipu_vdi_setup(struct ipu_vdi *vdi, u32 code, int xres, int yres)
+{
+	unsigned long flags;
+	u32 pixel_fmt, reg;
+
+	spin_lock_irqsave(&vdi->lock, flags);
+
+	reg = ((yres - 1) << 16) | (xres - 1);
+	ipu_vdi_write(vdi, reg, VDI_FSIZE);
+
+	/*
+	 * Full motion, only vertical filter is used.
+	 * Burst size is 4 accesses
+	 */
+	if (code == MEDIA_BUS_FMT_UYVY8_2X8 ||
+	    code == MEDIA_BUS_FMT_UYVY8_1X16 ||
+	    code == MEDIA_BUS_FMT_YUYV8_2X8 ||
+	    code == MEDIA_BUS_FMT_YUYV8_1X16)
+		pixel_fmt = VDI_C_CH_422;
+	else
+		pixel_fmt = VDI_C_CH_420;
+
+	reg = ipu_vdi_read(vdi, VDI_C);
+	reg |= pixel_fmt;
+	reg |= VDI_C_BURST_SIZE2_4;
+	reg |= VDI_C_BURST_SIZE1_4 | VDI_C_VWM1_CLR_2;
+	reg |= VDI_C_BURST_SIZE3_4 | VDI_C_VWM3_CLR_2;
+	ipu_vdi_write(vdi, reg, VDI_C);
+
+	spin_unlock_irqrestore(&vdi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_setup);
+
+void ipu_vdi_unsetup(struct ipu_vdi *vdi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&vdi->lock, flags);
+	ipu_vdi_write(vdi, 0, VDI_FSIZE);
+	ipu_vdi_write(vdi, 0, VDI_C);
+	spin_unlock_irqrestore(&vdi->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_unsetup);
+
+int ipu_vdi_enable(struct ipu_vdi *vdi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&vdi->lock, flags);
+
+	if (!vdi->use_count)
+		ipu_module_enable(vdi->ipu, vdi->module);
+
+	vdi->use_count++;
+
+	spin_unlock_irqrestore(&vdi->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_enable);
+
+int ipu_vdi_disable(struct ipu_vdi *vdi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&vdi->lock, flags);
+
+	if (vdi->use_count) {
+		if (!--vdi->use_count)
+			ipu_module_disable(vdi->ipu, vdi->module);
+	}
+
+	spin_unlock_irqrestore(&vdi->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_disable);
+
+struct ipu_vdi *ipu_vdi_get(struct ipu_soc *ipu)
+{
+	return ipu->vdi_priv;
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_get);
+
+void ipu_vdi_put(struct ipu_vdi *vdi)
+{
+}
+EXPORT_SYMBOL_GPL(ipu_vdi_put);
+
+int ipu_vdi_init(struct ipu_soc *ipu, struct device *dev,
+		 unsigned long base, u32 module)
+{
+	struct ipu_vdi *vdi;
+
+	vdi = devm_kzalloc(dev, sizeof(*vdi), GFP_KERNEL);
+	if (!vdi)
+		return -ENOMEM;
+
+	ipu->vdi_priv = vdi;
+
+	spin_lock_init(&vdi->lock);
+	vdi->module = module;
+	vdi->base = devm_ioremap(dev, base, PAGE_SIZE);
+	if (!vdi->base)
+		return -ENOMEM;
+
+	dev_dbg(dev, "VDI base: 0x%08lx remapped to %p\n", base, vdi->base);
+	vdi->ipu = ipu;
+
+	return 0;
+}
+
+void ipu_vdi_exit(struct ipu_soc *ipu)
+{
+}
diff --git a/drivers/gpu/ipu-v3/Kconfig b/drivers/gpu/ipu-v3/Kconfig
deleted file mode 100644
index fe6f8c5..0000000
--- a/drivers/gpu/ipu-v3/Kconfig
+++ /dev/null
@@ -1,10 +0,0 @@
-config IMX_IPUV3_CORE
-	tristate "IPUv3 core support"
-	depends on SOC_IMX5 || SOC_IMX6Q || ARCH_MULTIPLATFORM || COMPILE_TEST
-	depends on DRM || !DRM # if DRM=m, this can't be 'y'
-	select BITREVERSE
-	select GENERIC_ALLOCATOR if DRM
-	select GENERIC_IRQ_CHIP
-	help
-	  Choose this if you have a i.MX5/6 system and want to use the Image
-	  Processing Unit. This option only enables IPU base support.
diff --git a/drivers/gpu/ipu-v3/Makefile b/drivers/gpu/ipu-v3/Makefile
deleted file mode 100644
index 7cc8b47..0000000
--- a/drivers/gpu/ipu-v3/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_IMX_IPUV3_CORE) += imx-ipu-v3.o
-
-imx-ipu-v3-objs := ipu-common.o ipu-cpmem.o ipu-csi.o ipu-dc.o ipu-di.o \
-		ipu-dp.o ipu-dmfc.o ipu-ic.o ipu-image-convert.o \
-		ipu-smfc.o ipu-vdi.o
-
-ifdef CONFIG_DRM
-	imx-ipu-v3-objs += ipu-pre.o ipu-prg.o
-endif
diff --git a/drivers/gpu/ipu-v3/ipu-common.c b/drivers/gpu/ipu-v3/ipu-common.c
deleted file mode 100644
index c73bd00..0000000
--- a/drivers/gpu/ipu-v3/ipu-common.c
+++ /dev/null
@@ -1,1566 +0,0 @@
-/*
- * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/module.h>
-#include <linux/export.h>
-#include <linux/types.h>
-#include <linux/reset.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/list.h>
-#include <linux/irq.h>
-#include <linux/irqchip/chained_irq.h>
-#include <linux/irqdomain.h>
-#include <linux/of_device.h>
-#include <linux/of_graph.h>
-
-#include <drm/drm_fourcc.h>
-
-#include <video/imx-ipu-v3.h>
-#include "ipu-prv.h"
-
-static inline u32 ipu_cm_read(struct ipu_soc *ipu, unsigned offset)
-{
-	return readl(ipu->cm_reg + offset);
-}
-
-static inline void ipu_cm_write(struct ipu_soc *ipu, u32 value, unsigned offset)
-{
-	writel(value, ipu->cm_reg + offset);
-}
-
-int ipu_get_num(struct ipu_soc *ipu)
-{
-	return ipu->id;
-}
-EXPORT_SYMBOL_GPL(ipu_get_num);
-
-void ipu_srm_dp_update(struct ipu_soc *ipu, bool sync)
-{
-	u32 val;
-
-	val = ipu_cm_read(ipu, IPU_SRM_PRI2);
-	val &= ~DP_S_SRM_MODE_MASK;
-	val |= sync ? DP_S_SRM_MODE_NEXT_FRAME :
-		      DP_S_SRM_MODE_NOW;
-	ipu_cm_write(ipu, val, IPU_SRM_PRI2);
-}
-EXPORT_SYMBOL_GPL(ipu_srm_dp_update);
-
-enum ipu_color_space ipu_drm_fourcc_to_colorspace(u32 drm_fourcc)
-{
-	switch (drm_fourcc) {
-	case DRM_FORMAT_ARGB1555:
-	case DRM_FORMAT_ABGR1555:
-	case DRM_FORMAT_RGBA5551:
-	case DRM_FORMAT_BGRA5551:
-	case DRM_FORMAT_RGB565:
-	case DRM_FORMAT_BGR565:
-	case DRM_FORMAT_RGB888:
-	case DRM_FORMAT_BGR888:
-	case DRM_FORMAT_ARGB4444:
-	case DRM_FORMAT_XRGB8888:
-	case DRM_FORMAT_XBGR8888:
-	case DRM_FORMAT_RGBX8888:
-	case DRM_FORMAT_BGRX8888:
-	case DRM_FORMAT_ARGB8888:
-	case DRM_FORMAT_ABGR8888:
-	case DRM_FORMAT_RGBA8888:
-	case DRM_FORMAT_BGRA8888:
-	case DRM_FORMAT_RGB565_A8:
-	case DRM_FORMAT_BGR565_A8:
-	case DRM_FORMAT_RGB888_A8:
-	case DRM_FORMAT_BGR888_A8:
-	case DRM_FORMAT_RGBX8888_A8:
-	case DRM_FORMAT_BGRX8888_A8:
-		return IPUV3_COLORSPACE_RGB;
-	case DRM_FORMAT_YUYV:
-	case DRM_FORMAT_UYVY:
-	case DRM_FORMAT_YUV420:
-	case DRM_FORMAT_YVU420:
-	case DRM_FORMAT_YUV422:
-	case DRM_FORMAT_YVU422:
-	case DRM_FORMAT_YUV444:
-	case DRM_FORMAT_YVU444:
-	case DRM_FORMAT_NV12:
-	case DRM_FORMAT_NV21:
-	case DRM_FORMAT_NV16:
-	case DRM_FORMAT_NV61:
-		return IPUV3_COLORSPACE_YUV;
-	default:
-		return IPUV3_COLORSPACE_UNKNOWN;
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_drm_fourcc_to_colorspace);
-
-enum ipu_color_space ipu_pixelformat_to_colorspace(u32 pixelformat)
-{
-	switch (pixelformat) {
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV422P:
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-		return IPUV3_COLORSPACE_YUV;
-	case V4L2_PIX_FMT_RGB32:
-	case V4L2_PIX_FMT_BGR32:
-	case V4L2_PIX_FMT_RGB24:
-	case V4L2_PIX_FMT_BGR24:
-	case V4L2_PIX_FMT_RGB565:
-		return IPUV3_COLORSPACE_RGB;
-	default:
-		return IPUV3_COLORSPACE_UNKNOWN;
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_pixelformat_to_colorspace);
-
-bool ipu_pixelformat_is_planar(u32 pixelformat)
-{
-	switch (pixelformat) {
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV422P:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-		return true;
-	}
-
-	return false;
-}
-EXPORT_SYMBOL_GPL(ipu_pixelformat_is_planar);
-
-enum ipu_color_space ipu_mbus_code_to_colorspace(u32 mbus_code)
-{
-	switch (mbus_code & 0xf000) {
-	case 0x1000:
-		return IPUV3_COLORSPACE_RGB;
-	case 0x2000:
-		return IPUV3_COLORSPACE_YUV;
-	default:
-		return IPUV3_COLORSPACE_UNKNOWN;
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_mbus_code_to_colorspace);
-
-int ipu_stride_to_bytes(u32 pixel_stride, u32 pixelformat)
-{
-	switch (pixelformat) {
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV422P:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-		/*
-		 * for the planar YUV formats, the stride passed to
-		 * cpmem must be the stride in bytes of the Y plane.
-		 * And all the planar YUV formats have an 8-bit
-		 * Y component.
-		 */
-		return (8 * pixel_stride) >> 3;
-	case V4L2_PIX_FMT_RGB565:
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_UYVY:
-		return (16 * pixel_stride) >> 3;
-	case V4L2_PIX_FMT_BGR24:
-	case V4L2_PIX_FMT_RGB24:
-		return (24 * pixel_stride) >> 3;
-	case V4L2_PIX_FMT_BGR32:
-	case V4L2_PIX_FMT_RGB32:
-		return (32 * pixel_stride) >> 3;
-	default:
-		break;
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(ipu_stride_to_bytes);
-
-int ipu_degrees_to_rot_mode(enum ipu_rotate_mode *mode, int degrees,
-			    bool hflip, bool vflip)
-{
-	u32 r90, vf, hf;
-
-	switch (degrees) {
-	case 0:
-		vf = hf = r90 = 0;
-		break;
-	case 90:
-		vf = hf = 0;
-		r90 = 1;
-		break;
-	case 180:
-		vf = hf = 1;
-		r90 = 0;
-		break;
-	case 270:
-		vf = hf = r90 = 1;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	hf ^= (u32)hflip;
-	vf ^= (u32)vflip;
-
-	*mode = (enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_degrees_to_rot_mode);
-
-int ipu_rot_mode_to_degrees(int *degrees, enum ipu_rotate_mode mode,
-			    bool hflip, bool vflip)
-{
-	u32 r90, vf, hf;
-
-	r90 = ((u32)mode >> 2) & 0x1;
-	hf = ((u32)mode >> 1) & 0x1;
-	vf = ((u32)mode >> 0) & 0x1;
-	hf ^= (u32)hflip;
-	vf ^= (u32)vflip;
-
-	switch ((enum ipu_rotate_mode)((r90 << 2) | (hf << 1) | vf)) {
-	case IPU_ROTATE_NONE:
-		*degrees = 0;
-		break;
-	case IPU_ROTATE_90_RIGHT:
-		*degrees = 90;
-		break;
-	case IPU_ROTATE_180:
-		*degrees = 180;
-		break;
-	case IPU_ROTATE_90_LEFT:
-		*degrees = 270;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_rot_mode_to_degrees);
-
-struct ipuv3_channel *ipu_idmac_get(struct ipu_soc *ipu, unsigned num)
-{
-	struct ipuv3_channel *channel;
-
-	dev_dbg(ipu->dev, "%s %d\n", __func__, num);
-
-	if (num > 63)
-		return ERR_PTR(-ENODEV);
-
-	mutex_lock(&ipu->channel_lock);
-
-	list_for_each_entry(channel, &ipu->channels, list) {
-		if (channel->num == num) {
-			channel = ERR_PTR(-EBUSY);
-			goto out;
-		}
-	}
-
-	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
-	if (!channel) {
-		channel = ERR_PTR(-ENOMEM);
-		goto out;
-	}
-
-	channel->num = num;
-	channel->ipu = ipu;
-	list_add(&channel->list, &ipu->channels);
-
-out:
-	mutex_unlock(&ipu->channel_lock);
-
-	return channel;
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_get);
-
-void ipu_idmac_put(struct ipuv3_channel *channel)
-{
-	struct ipu_soc *ipu = channel->ipu;
-
-	dev_dbg(ipu->dev, "%s %d\n", __func__, channel->num);
-
-	mutex_lock(&ipu->channel_lock);
-
-	list_del(&channel->list);
-	kfree(channel);
-
-	mutex_unlock(&ipu->channel_lock);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_put);
-
-#define idma_mask(ch)			(1 << ((ch) & 0x1f))
-
-/*
- * This is an undocumented feature, a write one to a channel bit in
- * IPU_CHA_CUR_BUF and IPU_CHA_TRIPLE_CUR_BUF will reset the channel's
- * internal current buffer pointer so that transfers start from buffer
- * 0 on the next channel enable (that's the theory anyway, the imx6 TRM
- * only says these are read-only registers). This operation is required
- * for channel linking to work correctly, for instance video capture
- * pipelines that carry out image rotations will fail after the first
- * streaming unless this function is called for each channel before
- * re-enabling the channels.
- */
-static void __ipu_idmac_reset_current_buffer(struct ipuv3_channel *channel)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned int chno = channel->num;
-
-	ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_CUR_BUF(chno));
-}
-
-void ipu_idmac_set_double_buffer(struct ipuv3_channel *channel,
-		bool doublebuffer)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));
-	if (doublebuffer)
-		reg |= idma_mask(channel->num);
-	else
-		reg &= ~idma_mask(channel->num);
-	ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(channel->num));
-
-	__ipu_idmac_reset_current_buffer(channel);
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_set_double_buffer);
-
-static const struct {
-	int chnum;
-	u32 reg;
-	int shift;
-} idmac_lock_en_info[] = {
-	{ .chnum =  5, .reg = IDMAC_CH_LOCK_EN_1, .shift =  0, },
-	{ .chnum = 11, .reg = IDMAC_CH_LOCK_EN_1, .shift =  2, },
-	{ .chnum = 12, .reg = IDMAC_CH_LOCK_EN_1, .shift =  4, },
-	{ .chnum = 14, .reg = IDMAC_CH_LOCK_EN_1, .shift =  6, },
-	{ .chnum = 15, .reg = IDMAC_CH_LOCK_EN_1, .shift =  8, },
-	{ .chnum = 20, .reg = IDMAC_CH_LOCK_EN_1, .shift = 10, },
-	{ .chnum = 21, .reg = IDMAC_CH_LOCK_EN_1, .shift = 12, },
-	{ .chnum = 22, .reg = IDMAC_CH_LOCK_EN_1, .shift = 14, },
-	{ .chnum = 23, .reg = IDMAC_CH_LOCK_EN_1, .shift = 16, },
-	{ .chnum = 27, .reg = IDMAC_CH_LOCK_EN_1, .shift = 18, },
-	{ .chnum = 28, .reg = IDMAC_CH_LOCK_EN_1, .shift = 20, },
-	{ .chnum = 45, .reg = IDMAC_CH_LOCK_EN_2, .shift =  0, },
-	{ .chnum = 46, .reg = IDMAC_CH_LOCK_EN_2, .shift =  2, },
-	{ .chnum = 47, .reg = IDMAC_CH_LOCK_EN_2, .shift =  4, },
-	{ .chnum = 48, .reg = IDMAC_CH_LOCK_EN_2, .shift =  6, },
-	{ .chnum = 49, .reg = IDMAC_CH_LOCK_EN_2, .shift =  8, },
-	{ .chnum = 50, .reg = IDMAC_CH_LOCK_EN_2, .shift = 10, },
-};
-
-int ipu_idmac_lock_enable(struct ipuv3_channel *channel, int num_bursts)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned long flags;
-	u32 bursts, regval;
-	int i;
-
-	switch (num_bursts) {
-	case 0:
-	case 1:
-		bursts = 0x00; /* locking disabled */
-		break;
-	case 2:
-		bursts = 0x01;
-		break;
-	case 4:
-		bursts = 0x02;
-		break;
-	case 8:
-		bursts = 0x03;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/*
-	 * IPUv3EX / i.MX51 has a different register layout, and on IPUv3M /
-	 * i.MX53 channel arbitration locking doesn't seem to work properly.
-	 * Allow enabling the lock feature on IPUv3H / i.MX6 only.
-	 */
-	if (bursts && ipu->ipu_type != IPUV3H)
-		return -EINVAL;
-
-	for (i = 0; i < ARRAY_SIZE(idmac_lock_en_info); i++) {
-		if (channel->num == idmac_lock_en_info[i].chnum)
-			break;
-	}
-	if (i >= ARRAY_SIZE(idmac_lock_en_info))
-		return -EINVAL;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	regval = ipu_idmac_read(ipu, idmac_lock_en_info[i].reg);
-	regval &= ~(0x03 << idmac_lock_en_info[i].shift);
-	regval |= (bursts << idmac_lock_en_info[i].shift);
-	ipu_idmac_write(ipu, regval, idmac_lock_en_info[i].reg);
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_lock_enable);
-
-int ipu_module_enable(struct ipu_soc *ipu, u32 mask)
-{
-	unsigned long lock_flags;
-	u32 val;
-
-	spin_lock_irqsave(&ipu->lock, lock_flags);
-
-	val = ipu_cm_read(ipu, IPU_DISP_GEN);
-
-	if (mask & IPU_CONF_DI0_EN)
-		val |= IPU_DI0_COUNTER_RELEASE;
-	if (mask & IPU_CONF_DI1_EN)
-		val |= IPU_DI1_COUNTER_RELEASE;
-
-	ipu_cm_write(ipu, val, IPU_DISP_GEN);
-
-	val = ipu_cm_read(ipu, IPU_CONF);
-	val |= mask;
-	ipu_cm_write(ipu, val, IPU_CONF);
-
-	spin_unlock_irqrestore(&ipu->lock, lock_flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_module_enable);
-
-int ipu_module_disable(struct ipu_soc *ipu, u32 mask)
-{
-	unsigned long lock_flags;
-	u32 val;
-
-	spin_lock_irqsave(&ipu->lock, lock_flags);
-
-	val = ipu_cm_read(ipu, IPU_CONF);
-	val &= ~mask;
-	ipu_cm_write(ipu, val, IPU_CONF);
-
-	val = ipu_cm_read(ipu, IPU_DISP_GEN);
-
-	if (mask & IPU_CONF_DI0_EN)
-		val &= ~IPU_DI0_COUNTER_RELEASE;
-	if (mask & IPU_CONF_DI1_EN)
-		val &= ~IPU_DI1_COUNTER_RELEASE;
-
-	ipu_cm_write(ipu, val, IPU_DISP_GEN);
-
-	spin_unlock_irqrestore(&ipu->lock, lock_flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_module_disable);
-
-int ipu_idmac_get_current_buffer(struct ipuv3_channel *channel)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned int chno = channel->num;
-
-	return (ipu_cm_read(ipu, IPU_CHA_CUR_BUF(chno)) & idma_mask(chno)) ? 1 : 0;
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_get_current_buffer);
-
-bool ipu_idmac_buffer_is_ready(struct ipuv3_channel *channel, u32 buf_num)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned long flags;
-	u32 reg = 0;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-	switch (buf_num) {
-	case 0:
-		reg = ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num));
-		break;
-	case 1:
-		reg = ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num));
-		break;
-	case 2:
-		reg = ipu_cm_read(ipu, IPU_CHA_BUF2_RDY(channel->num));
-		break;
-	}
-	spin_unlock_irqrestore(&ipu->lock, flags);
-
-	return ((reg & idma_mask(channel->num)) != 0);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_buffer_is_ready);
-
-void ipu_idmac_select_buffer(struct ipuv3_channel *channel, u32 buf_num)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned int chno = channel->num;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	/* Mark buffer as ready. */
-	if (buf_num == 0)
-		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));
-	else
-		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_select_buffer);
-
-void ipu_idmac_clear_buffer(struct ipuv3_channel *channel, u32 buf_num)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned int chno = channel->num;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	ipu_cm_write(ipu, 0xF0300000, IPU_GPR); /* write one to clear */
-	switch (buf_num) {
-	case 0:
-		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));
-		break;
-	case 1:
-		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));
-		break;
-	case 2:
-		ipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF2_RDY(chno));
-		break;
-	default:
-		break;
-	}
-	ipu_cm_write(ipu, 0x0, IPU_GPR); /* write one to set */
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_clear_buffer);
-
-int ipu_idmac_enable_channel(struct ipuv3_channel *channel)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	u32 val;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	val = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));
-	val |= idma_mask(channel->num);
-	ipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_enable_channel);
-
-bool ipu_idmac_channel_busy(struct ipu_soc *ipu, unsigned int chno)
-{
-	return (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(chno)) & idma_mask(chno));
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_channel_busy);
-
-int ipu_idmac_wait_busy(struct ipuv3_channel *channel, int ms)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned long timeout;
-
-	timeout = jiffies + msecs_to_jiffies(ms);
-	while (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(channel->num)) &
-			idma_mask(channel->num)) {
-		if (time_after(jiffies, timeout))
-			return -ETIMEDOUT;
-		cpu_relax();
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_wait_busy);
-
-int ipu_idmac_disable_channel(struct ipuv3_channel *channel)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	u32 val;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	/* Disable DMA channel(s) */
-	val = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));
-	val &= ~idma_mask(channel->num);
-	ipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));
-
-	__ipu_idmac_reset_current_buffer(channel);
-
-	/* Set channel buffers NOT to be ready */
-	ipu_cm_write(ipu, 0xf0000000, IPU_GPR); /* write one to clear */
-
-	if (ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num)) &
-			idma_mask(channel->num)) {
-		ipu_cm_write(ipu, idma_mask(channel->num),
-			     IPU_CHA_BUF0_RDY(channel->num));
-	}
-
-	if (ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num)) &
-			idma_mask(channel->num)) {
-		ipu_cm_write(ipu, idma_mask(channel->num),
-			     IPU_CHA_BUF1_RDY(channel->num));
-	}
-
-	ipu_cm_write(ipu, 0x0, IPU_GPR); /* write one to set */
-
-	/* Reset the double buffer */
-	val = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));
-	val &= ~idma_mask(channel->num);
-	ipu_cm_write(ipu, val, IPU_CHA_DB_MODE_SEL(channel->num));
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_disable_channel);
-
-/*
- * The imx6 rev. D TRM says that enabling the WM feature will increase
- * a channel's priority. Refer to Table 36-8 Calculated priority value.
- * The sub-module that is the sink or source for the channel must enable
- * watermark signal for this to take effect (SMFC_WM for instance).
- */
-void ipu_idmac_enable_watermark(struct ipuv3_channel *channel, bool enable)
-{
-	struct ipu_soc *ipu = channel->ipu;
-	unsigned long flags;
-	u32 val;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	val = ipu_idmac_read(ipu, IDMAC_WM_EN(channel->num));
-	if (enable)
-		val |= 1 << (channel->num % 32);
-	else
-		val &= ~(1 << (channel->num % 32));
-	ipu_idmac_write(ipu, val, IDMAC_WM_EN(channel->num));
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_enable_watermark);
-
-static int ipu_memory_reset(struct ipu_soc *ipu)
-{
-	unsigned long timeout;
-
-	ipu_cm_write(ipu, 0x807FFFFF, IPU_MEM_RST);
-
-	timeout = jiffies + msecs_to_jiffies(1000);
-	while (ipu_cm_read(ipu, IPU_MEM_RST) & 0x80000000) {
-		if (time_after(jiffies, timeout))
-			return -ETIME;
-		cpu_relax();
-	}
-
-	return 0;
-}
-
-/*
- * Set the source mux for the given CSI. Selects either parallel or
- * MIPI CSI2 sources.
- */
-void ipu_set_csi_src_mux(struct ipu_soc *ipu, int csi_id, bool mipi_csi2)
-{
-	unsigned long flags;
-	u32 val, mask;
-
-	mask = (csi_id == 1) ? IPU_CONF_CSI1_DATA_SOURCE :
-		IPU_CONF_CSI0_DATA_SOURCE;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	val = ipu_cm_read(ipu, IPU_CONF);
-	if (mipi_csi2)
-		val |= mask;
-	else
-		val &= ~mask;
-	ipu_cm_write(ipu, val, IPU_CONF);
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_set_csi_src_mux);
-
-/*
- * Set the source mux for the IC. Selects either CSI[01] or the VDI.
- */
-void ipu_set_ic_src_mux(struct ipu_soc *ipu, int csi_id, bool vdi)
-{
-	unsigned long flags;
-	u32 val;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	val = ipu_cm_read(ipu, IPU_CONF);
-	if (vdi)
-		val |= IPU_CONF_IC_INPUT;
-	else
-		val &= ~IPU_CONF_IC_INPUT;
-
-	if (csi_id == 1)
-		val |= IPU_CONF_CSI_SEL;
-	else
-		val &= ~IPU_CONF_CSI_SEL;
-
-	ipu_cm_write(ipu, val, IPU_CONF);
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_set_ic_src_mux);
-
-
-/* Frame Synchronization Unit Channel Linking */
-
-struct fsu_link_reg_info {
-	int chno;
-	u32 reg;
-	u32 mask;
-	u32 val;
-};
-
-struct fsu_link_info {
-	struct fsu_link_reg_info src;
-	struct fsu_link_reg_info sink;
-};
-
-static const struct fsu_link_info fsu_link_info[] = {
-	{
-		.src  = { IPUV3_CHANNEL_IC_PRP_ENC_MEM, IPU_FS_PROC_FLOW2,
-			  FS_PRP_ENC_DEST_SEL_MASK, FS_PRP_ENC_DEST_SEL_IRT_ENC },
-		.sink = { IPUV3_CHANNEL_MEM_ROT_ENC, IPU_FS_PROC_FLOW1,
-			  FS_PRPENC_ROT_SRC_SEL_MASK, FS_PRPENC_ROT_SRC_SEL_ENC },
-	}, {
-		.src =  { IPUV3_CHANNEL_IC_PRP_VF_MEM, IPU_FS_PROC_FLOW2,
-			  FS_PRPVF_DEST_SEL_MASK, FS_PRPVF_DEST_SEL_IRT_VF },
-		.sink = { IPUV3_CHANNEL_MEM_ROT_VF, IPU_FS_PROC_FLOW1,
-			  FS_PRPVF_ROT_SRC_SEL_MASK, FS_PRPVF_ROT_SRC_SEL_VF },
-	}, {
-		.src =  { IPUV3_CHANNEL_IC_PP_MEM, IPU_FS_PROC_FLOW2,
-			  FS_PP_DEST_SEL_MASK, FS_PP_DEST_SEL_IRT_PP },
-		.sink = { IPUV3_CHANNEL_MEM_ROT_PP, IPU_FS_PROC_FLOW1,
-			  FS_PP_ROT_SRC_SEL_MASK, FS_PP_ROT_SRC_SEL_PP },
-	}, {
-		.src =  { IPUV3_CHANNEL_CSI_DIRECT, 0 },
-		.sink = { IPUV3_CHANNEL_CSI_VDI_PREV, IPU_FS_PROC_FLOW1,
-			  FS_VDI_SRC_SEL_MASK, FS_VDI_SRC_SEL_CSI_DIRECT },
-	},
-};
-
-static const struct fsu_link_info *find_fsu_link_info(int src, int sink)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(fsu_link_info); i++) {
-		if (src == fsu_link_info[i].src.chno &&
-		    sink == fsu_link_info[i].sink.chno)
-			return &fsu_link_info[i];
-	}
-
-	return NULL;
-}
-
-/*
- * Links a source channel to a sink channel in the FSU.
- */
-int ipu_fsu_link(struct ipu_soc *ipu, int src_ch, int sink_ch)
-{
-	const struct fsu_link_info *link;
-	u32 src_reg, sink_reg;
-	unsigned long flags;
-
-	link = find_fsu_link_info(src_ch, sink_ch);
-	if (!link)
-		return -EINVAL;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	if (link->src.mask) {
-		src_reg = ipu_cm_read(ipu, link->src.reg);
-		src_reg &= ~link->src.mask;
-		src_reg |= link->src.val;
-		ipu_cm_write(ipu, src_reg, link->src.reg);
-	}
-
-	if (link->sink.mask) {
-		sink_reg = ipu_cm_read(ipu, link->sink.reg);
-		sink_reg &= ~link->sink.mask;
-		sink_reg |= link->sink.val;
-		ipu_cm_write(ipu, sink_reg, link->sink.reg);
-	}
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_fsu_link);
-
-/*
- * Unlinks source and sink channels in the FSU.
- */
-int ipu_fsu_unlink(struct ipu_soc *ipu, int src_ch, int sink_ch)
-{
-	const struct fsu_link_info *link;
-	u32 src_reg, sink_reg;
-	unsigned long flags;
-
-	link = find_fsu_link_info(src_ch, sink_ch);
-	if (!link)
-		return -EINVAL;
-
-	spin_lock_irqsave(&ipu->lock, flags);
-
-	if (link->src.mask) {
-		src_reg = ipu_cm_read(ipu, link->src.reg);
-		src_reg &= ~link->src.mask;
-		ipu_cm_write(ipu, src_reg, link->src.reg);
-	}
-
-	if (link->sink.mask) {
-		sink_reg = ipu_cm_read(ipu, link->sink.reg);
-		sink_reg &= ~link->sink.mask;
-		ipu_cm_write(ipu, sink_reg, link->sink.reg);
-	}
-
-	spin_unlock_irqrestore(&ipu->lock, flags);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_fsu_unlink);
-
-/* Link IDMAC channels in the FSU */
-int ipu_idmac_link(struct ipuv3_channel *src, struct ipuv3_channel *sink)
-{
-	return ipu_fsu_link(src->ipu, src->num, sink->num);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_link);
-
-/* Unlink IDMAC channels in the FSU */
-int ipu_idmac_unlink(struct ipuv3_channel *src, struct ipuv3_channel *sink)
-{
-	return ipu_fsu_unlink(src->ipu, src->num, sink->num);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_unlink);
-
-struct ipu_devtype {
-	const char *name;
-	unsigned long cm_ofs;
-	unsigned long cpmem_ofs;
-	unsigned long srm_ofs;
-	unsigned long tpm_ofs;
-	unsigned long csi0_ofs;
-	unsigned long csi1_ofs;
-	unsigned long ic_ofs;
-	unsigned long disp0_ofs;
-	unsigned long disp1_ofs;
-	unsigned long dc_tmpl_ofs;
-	unsigned long vdi_ofs;
-	enum ipuv3_type type;
-};
-
-static struct ipu_devtype ipu_type_imx51 = {
-	.name = "IPUv3EX",
-	.cm_ofs = 0x1e000000,
-	.cpmem_ofs = 0x1f000000,
-	.srm_ofs = 0x1f040000,
-	.tpm_ofs = 0x1f060000,
-	.csi0_ofs = 0x1f030000,
-	.csi1_ofs = 0x1f038000,
-	.ic_ofs = 0x1e020000,
-	.disp0_ofs = 0x1e040000,
-	.disp1_ofs = 0x1e048000,
-	.dc_tmpl_ofs = 0x1f080000,
-	.vdi_ofs = 0x1e068000,
-	.type = IPUV3EX,
-};
-
-static struct ipu_devtype ipu_type_imx53 = {
-	.name = "IPUv3M",
-	.cm_ofs = 0x06000000,
-	.cpmem_ofs = 0x07000000,
-	.srm_ofs = 0x07040000,
-	.tpm_ofs = 0x07060000,
-	.csi0_ofs = 0x07030000,
-	.csi1_ofs = 0x07038000,
-	.ic_ofs = 0x06020000,
-	.disp0_ofs = 0x06040000,
-	.disp1_ofs = 0x06048000,
-	.dc_tmpl_ofs = 0x07080000,
-	.vdi_ofs = 0x06068000,
-	.type = IPUV3M,
-};
-
-static struct ipu_devtype ipu_type_imx6q = {
-	.name = "IPUv3H",
-	.cm_ofs = 0x00200000,
-	.cpmem_ofs = 0x00300000,
-	.srm_ofs = 0x00340000,
-	.tpm_ofs = 0x00360000,
-	.csi0_ofs = 0x00230000,
-	.csi1_ofs = 0x00238000,
-	.ic_ofs = 0x00220000,
-	.disp0_ofs = 0x00240000,
-	.disp1_ofs = 0x00248000,
-	.dc_tmpl_ofs = 0x00380000,
-	.vdi_ofs = 0x00268000,
-	.type = IPUV3H,
-};
-
-static const struct of_device_id imx_ipu_dt_ids[] = {
-	{ .compatible = "fsl,imx51-ipu", .data = &ipu_type_imx51, },
-	{ .compatible = "fsl,imx53-ipu", .data = &ipu_type_imx53, },
-	{ .compatible = "fsl,imx6q-ipu", .data = &ipu_type_imx6q, },
-	{ .compatible = "fsl,imx6qp-ipu", .data = &ipu_type_imx6q, },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, imx_ipu_dt_ids);
-
-static int ipu_submodules_init(struct ipu_soc *ipu,
-		struct platform_device *pdev, unsigned long ipu_base,
-		struct clk *ipu_clk)
-{
-	char *unit;
-	int ret;
-	struct device *dev = &pdev->dev;
-	const struct ipu_devtype *devtype = ipu->devtype;
-
-	ret = ipu_cpmem_init(ipu, dev, ipu_base + devtype->cpmem_ofs);
-	if (ret) {
-		unit = "cpmem";
-		goto err_cpmem;
-	}
-
-	ret = ipu_csi_init(ipu, dev, 0, ipu_base + devtype->csi0_ofs,
-			   IPU_CONF_CSI0_EN, ipu_clk);
-	if (ret) {
-		unit = "csi0";
-		goto err_csi_0;
-	}
-
-	ret = ipu_csi_init(ipu, dev, 1, ipu_base + devtype->csi1_ofs,
-			   IPU_CONF_CSI1_EN, ipu_clk);
-	if (ret) {
-		unit = "csi1";
-		goto err_csi_1;
-	}
-
-	ret = ipu_ic_init(ipu, dev,
-			  ipu_base + devtype->ic_ofs,
-			  ipu_base + devtype->tpm_ofs);
-	if (ret) {
-		unit = "ic";
-		goto err_ic;
-	}
-
-	ret = ipu_vdi_init(ipu, dev, ipu_base + devtype->vdi_ofs,
-			   IPU_CONF_VDI_EN | IPU_CONF_ISP_EN |
-			   IPU_CONF_IC_INPUT);
-	if (ret) {
-		unit = "vdi";
-		goto err_vdi;
-	}
-
-	ret = ipu_image_convert_init(ipu, dev);
-	if (ret) {
-		unit = "image_convert";
-		goto err_image_convert;
-	}
-
-	ret = ipu_di_init(ipu, dev, 0, ipu_base + devtype->disp0_ofs,
-			  IPU_CONF_DI0_EN, ipu_clk);
-	if (ret) {
-		unit = "di0";
-		goto err_di_0;
-	}
-
-	ret = ipu_di_init(ipu, dev, 1, ipu_base + devtype->disp1_ofs,
-			IPU_CONF_DI1_EN, ipu_clk);
-	if (ret) {
-		unit = "di1";
-		goto err_di_1;
-	}
-
-	ret = ipu_dc_init(ipu, dev, ipu_base + devtype->cm_ofs +
-			IPU_CM_DC_REG_OFS, ipu_base + devtype->dc_tmpl_ofs);
-	if (ret) {
-		unit = "dc_template";
-		goto err_dc;
-	}
-
-	ret = ipu_dmfc_init(ipu, dev, ipu_base +
-			devtype->cm_ofs + IPU_CM_DMFC_REG_OFS, ipu_clk);
-	if (ret) {
-		unit = "dmfc";
-		goto err_dmfc;
-	}
-
-	ret = ipu_dp_init(ipu, dev, ipu_base + devtype->srm_ofs);
-	if (ret) {
-		unit = "dp";
-		goto err_dp;
-	}
-
-	ret = ipu_smfc_init(ipu, dev, ipu_base +
-			devtype->cm_ofs + IPU_CM_SMFC_REG_OFS);
-	if (ret) {
-		unit = "smfc";
-		goto err_smfc;
-	}
-
-	return 0;
-
-err_smfc:
-	ipu_dp_exit(ipu);
-err_dp:
-	ipu_dmfc_exit(ipu);
-err_dmfc:
-	ipu_dc_exit(ipu);
-err_dc:
-	ipu_di_exit(ipu, 1);
-err_di_1:
-	ipu_di_exit(ipu, 0);
-err_di_0:
-	ipu_image_convert_exit(ipu);
-err_image_convert:
-	ipu_vdi_exit(ipu);
-err_vdi:
-	ipu_ic_exit(ipu);
-err_ic:
-	ipu_csi_exit(ipu, 1);
-err_csi_1:
-	ipu_csi_exit(ipu, 0);
-err_csi_0:
-	ipu_cpmem_exit(ipu);
-err_cpmem:
-	dev_err(&pdev->dev, "init %s failed with %d\n", unit, ret);
-	return ret;
-}
-
-static void ipu_irq_handle(struct ipu_soc *ipu, const int *regs, int num_regs)
-{
-	unsigned long status;
-	int i, bit, irq;
-
-	for (i = 0; i < num_regs; i++) {
-
-		status = ipu_cm_read(ipu, IPU_INT_STAT(regs[i]));
-		status &= ipu_cm_read(ipu, IPU_INT_CTRL(regs[i]));
-
-		for_each_set_bit(bit, &status, 32) {
-			irq = irq_linear_revmap(ipu->domain,
-						regs[i] * 32 + bit);
-			if (irq)
-				generic_handle_irq(irq);
-		}
-	}
-}
-
-static void ipu_irq_handler(struct irq_desc *desc)
-{
-	struct ipu_soc *ipu = irq_desc_get_handler_data(desc);
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	static const int int_reg[] = { 0, 1, 2, 3, 10, 11, 12, 13, 14};
-
-	chained_irq_enter(chip, desc);
-
-	ipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));
-
-	chained_irq_exit(chip, desc);
-}
-
-static void ipu_err_irq_handler(struct irq_desc *desc)
-{
-	struct ipu_soc *ipu = irq_desc_get_handler_data(desc);
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	static const int int_reg[] = { 4, 5, 8, 9};
-
-	chained_irq_enter(chip, desc);
-
-	ipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));
-
-	chained_irq_exit(chip, desc);
-}
-
-int ipu_map_irq(struct ipu_soc *ipu, int irq)
-{
-	int virq;
-
-	virq = irq_linear_revmap(ipu->domain, irq);
-	if (!virq)
-		virq = irq_create_mapping(ipu->domain, irq);
-
-	return virq;
-}
-EXPORT_SYMBOL_GPL(ipu_map_irq);
-
-int ipu_idmac_channel_irq(struct ipu_soc *ipu, struct ipuv3_channel *channel,
-		enum ipu_channel_irq irq_type)
-{
-	return ipu_map_irq(ipu, irq_type + channel->num);
-}
-EXPORT_SYMBOL_GPL(ipu_idmac_channel_irq);
-
-static void ipu_submodules_exit(struct ipu_soc *ipu)
-{
-	ipu_smfc_exit(ipu);
-	ipu_dp_exit(ipu);
-	ipu_dmfc_exit(ipu);
-	ipu_dc_exit(ipu);
-	ipu_di_exit(ipu, 1);
-	ipu_di_exit(ipu, 0);
-	ipu_image_convert_exit(ipu);
-	ipu_vdi_exit(ipu);
-	ipu_ic_exit(ipu);
-	ipu_csi_exit(ipu, 1);
-	ipu_csi_exit(ipu, 0);
-	ipu_cpmem_exit(ipu);
-}
-
-static int platform_remove_devices_fn(struct device *dev, void *unused)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-
-	platform_device_unregister(pdev);
-
-	return 0;
-}
-
-static void platform_device_unregister_children(struct platform_device *pdev)
-{
-	device_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);
-}
-
-struct ipu_platform_reg {
-	struct ipu_client_platformdata pdata;
-	const char *name;
-};
-
-/* These must be in the order of the corresponding device tree port nodes */
-static struct ipu_platform_reg client_reg[] = {
-	{
-		.pdata = {
-			.csi = 0,
-			.dma[0] = IPUV3_CHANNEL_CSI0,
-			.dma[1] = -EINVAL,
-		},
-		.name = "imx-ipuv3-csi",
-	}, {
-		.pdata = {
-			.csi = 1,
-			.dma[0] = IPUV3_CHANNEL_CSI1,
-			.dma[1] = -EINVAL,
-		},
-		.name = "imx-ipuv3-csi",
-	}, {
-		.pdata = {
-			.di = 0,
-			.dc = 5,
-			.dp = IPU_DP_FLOW_SYNC_BG,
-			.dma[0] = IPUV3_CHANNEL_MEM_BG_SYNC,
-			.dma[1] = IPUV3_CHANNEL_MEM_FG_SYNC,
-		},
-		.name = "imx-ipuv3-crtc",
-	}, {
-		.pdata = {
-			.di = 1,
-			.dc = 1,
-			.dp = -EINVAL,
-			.dma[0] = IPUV3_CHANNEL_MEM_DC_SYNC,
-			.dma[1] = -EINVAL,
-		},
-		.name = "imx-ipuv3-crtc",
-	},
-};
-
-static DEFINE_MUTEX(ipu_client_id_mutex);
-static int ipu_client_id;
-
-static int ipu_add_client_devices(struct ipu_soc *ipu, unsigned long ipu_base)
-{
-	struct device *dev = ipu->dev;
-	unsigned i;
-	int id, ret;
-
-	mutex_lock(&ipu_client_id_mutex);
-	id = ipu_client_id;
-	ipu_client_id += ARRAY_SIZE(client_reg);
-	mutex_unlock(&ipu_client_id_mutex);
-
-	for (i = 0; i < ARRAY_SIZE(client_reg); i++) {
-		struct ipu_platform_reg *reg = &client_reg[i];
-		struct platform_device *pdev;
-		struct device_node *of_node;
-
-		/* Associate subdevice with the corresponding port node */
-		of_node = of_graph_get_port_by_id(dev->of_node, i);
-		if (!of_node) {
-			dev_info(dev,
-				 "no port@%d node in %pOF, not using %s%d\n",
-				 i, dev->of_node,
-				 (i / 2) ? "DI" : "CSI", i % 2);
-			continue;
-		}
-
-		pdev = platform_device_alloc(reg->name, id++);
-		if (!pdev) {
-			ret = -ENOMEM;
-			goto err_register;
-		}
-
-		pdev->dev.parent = dev;
-
-		reg->pdata.of_node = of_node;
-		ret = platform_device_add_data(pdev, &reg->pdata,
-					       sizeof(reg->pdata));
-		if (!ret)
-			ret = platform_device_add(pdev);
-		if (ret) {
-			platform_device_put(pdev);
-			goto err_register;
-		}
-	}
-
-	return 0;
-
-err_register:
-	platform_device_unregister_children(to_platform_device(dev));
-
-	return ret;
-}
-
-
-static int ipu_irq_init(struct ipu_soc *ipu)
-{
-	struct irq_chip_generic *gc;
-	struct irq_chip_type *ct;
-	unsigned long unused[IPU_NUM_IRQS / 32] = {
-		0x400100d0, 0xffe000fd,
-		0x400100d0, 0xffe000fd,
-		0x400100d0, 0xffe000fd,
-		0x4077ffff, 0xffe7e1fd,
-		0x23fffffe, 0x8880fff0,
-		0xf98fe7d0, 0xfff81fff,
-		0x400100d0, 0xffe000fd,
-		0x00000000,
-	};
-	int ret, i;
-
-	ipu->domain = irq_domain_add_linear(ipu->dev->of_node, IPU_NUM_IRQS,
-					    &irq_generic_chip_ops, ipu);
-	if (!ipu->domain) {
-		dev_err(ipu->dev, "failed to add irq domain\n");
-		return -ENODEV;
-	}
-
-	ret = irq_alloc_domain_generic_chips(ipu->domain, 32, 1, "IPU",
-					     handle_level_irq, 0, 0, 0);
-	if (ret < 0) {
-		dev_err(ipu->dev, "failed to alloc generic irq chips\n");
-		irq_domain_remove(ipu->domain);
-		return ret;
-	}
-
-	/* Mask and clear all interrupts */
-	for (i = 0; i < IPU_NUM_IRQS; i += 32) {
-		ipu_cm_write(ipu, 0, IPU_INT_CTRL(i / 32));
-		ipu_cm_write(ipu, ~unused[i / 32], IPU_INT_STAT(i / 32));
-	}
-
-	for (i = 0; i < IPU_NUM_IRQS; i += 32) {
-		gc = irq_get_domain_generic_chip(ipu->domain, i);
-		gc->reg_base = ipu->cm_reg;
-		gc->unused = unused[i / 32];
-		ct = gc->chip_types;
-		ct->chip.irq_ack = irq_gc_ack_set_bit;
-		ct->chip.irq_mask = irq_gc_mask_clr_bit;
-		ct->chip.irq_unmask = irq_gc_mask_set_bit;
-		ct->regs.ack = IPU_INT_STAT(i / 32);
-		ct->regs.mask = IPU_INT_CTRL(i / 32);
-	}
-
-	irq_set_chained_handler_and_data(ipu->irq_sync, ipu_irq_handler, ipu);
-	irq_set_chained_handler_and_data(ipu->irq_err, ipu_err_irq_handler,
-					 ipu);
-
-	return 0;
-}
-
-static void ipu_irq_exit(struct ipu_soc *ipu)
-{
-	int i, irq;
-
-	irq_set_chained_handler_and_data(ipu->irq_err, NULL, NULL);
-	irq_set_chained_handler_and_data(ipu->irq_sync, NULL, NULL);
-
-	/* TODO: remove irq_domain_generic_chips */
-
-	for (i = 0; i < IPU_NUM_IRQS; i++) {
-		irq = irq_linear_revmap(ipu->domain, i);
-		if (irq)
-			irq_dispose_mapping(irq);
-	}
-
-	irq_domain_remove(ipu->domain);
-}
-
-void ipu_dump(struct ipu_soc *ipu)
-{
-	int i;
-
-	dev_dbg(ipu->dev, "IPU_CONF = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_CONF));
-	dev_dbg(ipu->dev, "IDMAC_CONF = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_CONF));
-	dev_dbg(ipu->dev, "IDMAC_CHA_EN1 = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_CHA_EN(0)));
-	dev_dbg(ipu->dev, "IDMAC_CHA_EN2 = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_CHA_EN(32)));
-	dev_dbg(ipu->dev, "IDMAC_CHA_PRI1 = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_CHA_PRI(0)));
-	dev_dbg(ipu->dev, "IDMAC_CHA_PRI2 = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_CHA_PRI(32)));
-	dev_dbg(ipu->dev, "IDMAC_BAND_EN1 = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_BAND_EN(0)));
-	dev_dbg(ipu->dev, "IDMAC_BAND_EN2 = \t0x%08X\n",
-		ipu_idmac_read(ipu, IDMAC_BAND_EN(32)));
-	dev_dbg(ipu->dev, "IPU_CHA_DB_MODE_SEL0 = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(0)));
-	dev_dbg(ipu->dev, "IPU_CHA_DB_MODE_SEL1 = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(32)));
-	dev_dbg(ipu->dev, "IPU_FS_PROC_FLOW1 = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_FS_PROC_FLOW1));
-	dev_dbg(ipu->dev, "IPU_FS_PROC_FLOW2 = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_FS_PROC_FLOW2));
-	dev_dbg(ipu->dev, "IPU_FS_PROC_FLOW3 = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_FS_PROC_FLOW3));
-	dev_dbg(ipu->dev, "IPU_FS_DISP_FLOW1 = \t0x%08X\n",
-		ipu_cm_read(ipu, IPU_FS_DISP_FLOW1));
-	for (i = 0; i < 15; i++)
-		dev_dbg(ipu->dev, "IPU_INT_CTRL(%d) = \t%08X\n", i,
-			ipu_cm_read(ipu, IPU_INT_CTRL(i)));
-}
-EXPORT_SYMBOL_GPL(ipu_dump);
-
-static int ipu_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct ipu_soc *ipu;
-	struct resource *res;
-	unsigned long ipu_base;
-	int ret, irq_sync, irq_err;
-	const struct ipu_devtype *devtype;
-
-	devtype = of_device_get_match_data(&pdev->dev);
-	if (!devtype)
-		return -EINVAL;
-
-	irq_sync = platform_get_irq(pdev, 0);
-	irq_err = platform_get_irq(pdev, 1);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	dev_dbg(&pdev->dev, "irq_sync: %d irq_err: %d\n",
-			irq_sync, irq_err);
-
-	if (!res || irq_sync < 0 || irq_err < 0)
-		return -ENODEV;
-
-	ipu_base = res->start;
-
-	ipu = devm_kzalloc(&pdev->dev, sizeof(*ipu), GFP_KERNEL);
-	if (!ipu)
-		return -ENODEV;
-
-	ipu->id = of_alias_get_id(np, "ipu");
-	if (ipu->id < 0)
-		ipu->id = 0;
-
-	if (of_device_is_compatible(np, "fsl,imx6qp-ipu") &&
-	    IS_ENABLED(CONFIG_DRM)) {
-		ipu->prg_priv = ipu_prg_lookup_by_phandle(&pdev->dev,
-							  "fsl,prg", ipu->id);
-		if (!ipu->prg_priv)
-			return -EPROBE_DEFER;
-	}
-
-	ipu->devtype = devtype;
-	ipu->ipu_type = devtype->type;
-
-	spin_lock_init(&ipu->lock);
-	mutex_init(&ipu->channel_lock);
-	INIT_LIST_HEAD(&ipu->channels);
-
-	dev_dbg(&pdev->dev, "cm_reg:   0x%08lx\n",
-			ipu_base + devtype->cm_ofs);
-	dev_dbg(&pdev->dev, "idmac:    0x%08lx\n",
-			ipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS);
-	dev_dbg(&pdev->dev, "cpmem:    0x%08lx\n",
-			ipu_base + devtype->cpmem_ofs);
-	dev_dbg(&pdev->dev, "csi0:    0x%08lx\n",
-			ipu_base + devtype->csi0_ofs);
-	dev_dbg(&pdev->dev, "csi1:    0x%08lx\n",
-			ipu_base + devtype->csi1_ofs);
-	dev_dbg(&pdev->dev, "ic:      0x%08lx\n",
-			ipu_base + devtype->ic_ofs);
-	dev_dbg(&pdev->dev, "disp0:    0x%08lx\n",
-			ipu_base + devtype->disp0_ofs);
-	dev_dbg(&pdev->dev, "disp1:    0x%08lx\n",
-			ipu_base + devtype->disp1_ofs);
-	dev_dbg(&pdev->dev, "srm:      0x%08lx\n",
-			ipu_base + devtype->srm_ofs);
-	dev_dbg(&pdev->dev, "tpm:      0x%08lx\n",
-			ipu_base + devtype->tpm_ofs);
-	dev_dbg(&pdev->dev, "dc:       0x%08lx\n",
-			ipu_base + devtype->cm_ofs + IPU_CM_DC_REG_OFS);
-	dev_dbg(&pdev->dev, "ic:       0x%08lx\n",
-			ipu_base + devtype->cm_ofs + IPU_CM_IC_REG_OFS);
-	dev_dbg(&pdev->dev, "dmfc:     0x%08lx\n",
-			ipu_base + devtype->cm_ofs + IPU_CM_DMFC_REG_OFS);
-	dev_dbg(&pdev->dev, "vdi:      0x%08lx\n",
-			ipu_base + devtype->vdi_ofs);
-
-	ipu->cm_reg = devm_ioremap(&pdev->dev,
-			ipu_base + devtype->cm_ofs, PAGE_SIZE);
-	ipu->idmac_reg = devm_ioremap(&pdev->dev,
-			ipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS,
-			PAGE_SIZE);
-
-	if (!ipu->cm_reg || !ipu->idmac_reg)
-		return -ENOMEM;
-
-	ipu->clk = devm_clk_get(&pdev->dev, "bus");
-	if (IS_ERR(ipu->clk)) {
-		ret = PTR_ERR(ipu->clk);
-		dev_err(&pdev->dev, "clk_get failed with %d", ret);
-		return ret;
-	}
-
-	platform_set_drvdata(pdev, ipu);
-
-	ret = clk_prepare_enable(ipu->clk);
-	if (ret) {
-		dev_err(&pdev->dev, "clk_prepare_enable failed: %d\n", ret);
-		return ret;
-	}
-
-	ipu->dev = &pdev->dev;
-	ipu->irq_sync = irq_sync;
-	ipu->irq_err = irq_err;
-
-	ret = device_reset(&pdev->dev);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to reset: %d\n", ret);
-		goto out_failed_reset;
-	}
-	ret = ipu_memory_reset(ipu);
-	if (ret)
-		goto out_failed_reset;
-
-	ret = ipu_irq_init(ipu);
-	if (ret)
-		goto out_failed_irq;
-
-	/* Set MCU_T to divide MCU access window into 2 */
-	ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),
-			IPU_DISP_GEN);
-
-	ret = ipu_submodules_init(ipu, pdev, ipu_base, ipu->clk);
-	if (ret)
-		goto failed_submodules_init;
-
-	ret = ipu_add_client_devices(ipu, ipu_base);
-	if (ret) {
-		dev_err(&pdev->dev, "adding client devices failed with %d\n",
-				ret);
-		goto failed_add_clients;
-	}
-
-	dev_info(&pdev->dev, "%s probed\n", devtype->name);
-
-	return 0;
-
-failed_add_clients:
-	ipu_submodules_exit(ipu);
-failed_submodules_init:
-	ipu_irq_exit(ipu);
-out_failed_irq:
-out_failed_reset:
-	clk_disable_unprepare(ipu->clk);
-	return ret;
-}
-
-static int ipu_remove(struct platform_device *pdev)
-{
-	struct ipu_soc *ipu = platform_get_drvdata(pdev);
-
-	platform_device_unregister_children(pdev);
-	ipu_submodules_exit(ipu);
-	ipu_irq_exit(ipu);
-
-	clk_disable_unprepare(ipu->clk);
-
-	return 0;
-}
-
-static struct platform_driver imx_ipu_driver = {
-	.driver = {
-		.name = "imx-ipuv3",
-		.of_match_table = imx_ipu_dt_ids,
-	},
-	.probe = ipu_probe,
-	.remove = ipu_remove,
-};
-
-static struct platform_driver * const drivers[] = {
-#if IS_ENABLED(CONFIG_DRM)
-	&ipu_pre_drv,
-	&ipu_prg_drv,
-#endif
-	&imx_ipu_driver,
-};
-
-static int __init imx_ipu_init(void)
-{
-	return platform_register_drivers(drivers, ARRAY_SIZE(drivers));
-}
-module_init(imx_ipu_init);
-
-static void __exit imx_ipu_exit(void)
-{
-	platform_unregister_drivers(drivers, ARRAY_SIZE(drivers));
-}
-module_exit(imx_ipu_exit);
-
-MODULE_ALIAS("platform:imx-ipuv3");
-MODULE_DESCRIPTION("i.MX IPU v3 driver");
-MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/ipu-v3/ipu-cpmem.c b/drivers/gpu/ipu-v3/ipu-cpmem.c
deleted file mode 100644
index 9f2d9ec..0000000
--- a/drivers/gpu/ipu-v3/ipu-cpmem.c
+++ /dev/null
@@ -1,903 +0,0 @@
-/*
- * Copyright (C) 2012 Mentor Graphics Inc.
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#include <linux/types.h>
-#include <linux/bitrev.h>
-#include <linux/io.h>
-#include <linux/sizes.h>
-#include <drm/drm_fourcc.h>
-#include "ipu-prv.h"
-
-struct ipu_cpmem_word {
-	u32 data[5];
-	u32 res[3];
-};
-
-struct ipu_ch_param {
-	struct ipu_cpmem_word word[2];
-};
-
-struct ipu_cpmem {
-	struct ipu_ch_param __iomem *base;
-	u32 module;
-	spinlock_t lock;
-	int use_count;
-	struct ipu_soc *ipu;
-};
-
-#define IPU_CPMEM_WORD(word, ofs, size) ((((word) * 160 + (ofs)) << 8) | (size))
-
-#define IPU_FIELD_UBO		IPU_CPMEM_WORD(0, 46, 22)
-#define IPU_FIELD_VBO		IPU_CPMEM_WORD(0, 68, 22)
-#define IPU_FIELD_IOX		IPU_CPMEM_WORD(0, 90, 4)
-#define IPU_FIELD_RDRW		IPU_CPMEM_WORD(0, 94, 1)
-#define IPU_FIELD_SO		IPU_CPMEM_WORD(0, 113, 1)
-#define IPU_FIELD_SLY		IPU_CPMEM_WORD(1, 102, 14)
-#define IPU_FIELD_SLUV		IPU_CPMEM_WORD(1, 128, 14)
-
-#define IPU_FIELD_XV		IPU_CPMEM_WORD(0, 0, 10)
-#define IPU_FIELD_YV		IPU_CPMEM_WORD(0, 10, 9)
-#define IPU_FIELD_XB		IPU_CPMEM_WORD(0, 19, 13)
-#define IPU_FIELD_YB		IPU_CPMEM_WORD(0, 32, 12)
-#define IPU_FIELD_NSB_B		IPU_CPMEM_WORD(0, 44, 1)
-#define IPU_FIELD_CF		IPU_CPMEM_WORD(0, 45, 1)
-#define IPU_FIELD_SX		IPU_CPMEM_WORD(0, 46, 12)
-#define IPU_FIELD_SY		IPU_CPMEM_WORD(0, 58, 11)
-#define IPU_FIELD_NS		IPU_CPMEM_WORD(0, 69, 10)
-#define IPU_FIELD_SDX		IPU_CPMEM_WORD(0, 79, 7)
-#define IPU_FIELD_SM		IPU_CPMEM_WORD(0, 86, 10)
-#define IPU_FIELD_SCC		IPU_CPMEM_WORD(0, 96, 1)
-#define IPU_FIELD_SCE		IPU_CPMEM_WORD(0, 97, 1)
-#define IPU_FIELD_SDY		IPU_CPMEM_WORD(0, 98, 7)
-#define IPU_FIELD_SDRX		IPU_CPMEM_WORD(0, 105, 1)
-#define IPU_FIELD_SDRY		IPU_CPMEM_WORD(0, 106, 1)
-#define IPU_FIELD_BPP		IPU_CPMEM_WORD(0, 107, 3)
-#define IPU_FIELD_DEC_SEL	IPU_CPMEM_WORD(0, 110, 2)
-#define IPU_FIELD_DIM		IPU_CPMEM_WORD(0, 112, 1)
-#define IPU_FIELD_BNDM		IPU_CPMEM_WORD(0, 114, 3)
-#define IPU_FIELD_BM		IPU_CPMEM_WORD(0, 117, 2)
-#define IPU_FIELD_ROT		IPU_CPMEM_WORD(0, 119, 1)
-#define IPU_FIELD_ROT_HF_VF	IPU_CPMEM_WORD(0, 119, 3)
-#define IPU_FIELD_HF		IPU_CPMEM_WORD(0, 120, 1)
-#define IPU_FIELD_VF		IPU_CPMEM_WORD(0, 121, 1)
-#define IPU_FIELD_THE		IPU_CPMEM_WORD(0, 122, 1)
-#define IPU_FIELD_CAP		IPU_CPMEM_WORD(0, 123, 1)
-#define IPU_FIELD_CAE		IPU_CPMEM_WORD(0, 124, 1)
-#define IPU_FIELD_FW		IPU_CPMEM_WORD(0, 125, 13)
-#define IPU_FIELD_FH		IPU_CPMEM_WORD(0, 138, 12)
-#define IPU_FIELD_EBA0		IPU_CPMEM_WORD(1, 0, 29)
-#define IPU_FIELD_EBA1		IPU_CPMEM_WORD(1, 29, 29)
-#define IPU_FIELD_ILO		IPU_CPMEM_WORD(1, 58, 20)
-#define IPU_FIELD_NPB		IPU_CPMEM_WORD(1, 78, 7)
-#define IPU_FIELD_PFS		IPU_CPMEM_WORD(1, 85, 4)
-#define IPU_FIELD_ALU		IPU_CPMEM_WORD(1, 89, 1)
-#define IPU_FIELD_ALBM		IPU_CPMEM_WORD(1, 90, 3)
-#define IPU_FIELD_ID		IPU_CPMEM_WORD(1, 93, 2)
-#define IPU_FIELD_TH		IPU_CPMEM_WORD(1, 95, 7)
-#define IPU_FIELD_SL		IPU_CPMEM_WORD(1, 102, 14)
-#define IPU_FIELD_WID0		IPU_CPMEM_WORD(1, 116, 3)
-#define IPU_FIELD_WID1		IPU_CPMEM_WORD(1, 119, 3)
-#define IPU_FIELD_WID2		IPU_CPMEM_WORD(1, 122, 3)
-#define IPU_FIELD_WID3		IPU_CPMEM_WORD(1, 125, 3)
-#define IPU_FIELD_OFS0		IPU_CPMEM_WORD(1, 128, 5)
-#define IPU_FIELD_OFS1		IPU_CPMEM_WORD(1, 133, 5)
-#define IPU_FIELD_OFS2		IPU_CPMEM_WORD(1, 138, 5)
-#define IPU_FIELD_OFS3		IPU_CPMEM_WORD(1, 143, 5)
-#define IPU_FIELD_SXYS		IPU_CPMEM_WORD(1, 148, 1)
-#define IPU_FIELD_CRE		IPU_CPMEM_WORD(1, 149, 1)
-#define IPU_FIELD_DEC_SEL2	IPU_CPMEM_WORD(1, 150, 1)
-
-static inline struct ipu_ch_param __iomem *
-ipu_get_cpmem(struct ipuv3_channel *ch)
-{
-	struct ipu_cpmem *cpmem = ch->ipu->cpmem_priv;
-
-	return cpmem->base + ch->num;
-}
-
-static void ipu_ch_param_write_field(struct ipuv3_channel *ch, u32 wbs, u32 v)
-{
-	struct ipu_ch_param __iomem *base = ipu_get_cpmem(ch);
-	u32 bit = (wbs >> 8) % 160;
-	u32 size = wbs & 0xff;
-	u32 word = (wbs >> 8) / 160;
-	u32 i = bit / 32;
-	u32 ofs = bit % 32;
-	u32 mask = (1 << size) - 1;
-	u32 val;
-
-	pr_debug("%s %d %d %d\n", __func__, word, bit , size);
-
-	val = readl(&base->word[word].data[i]);
-	val &= ~(mask << ofs);
-	val |= v << ofs;
-	writel(val, &base->word[word].data[i]);
-
-	if ((bit + size - 1) / 32 > i) {
-		val = readl(&base->word[word].data[i + 1]);
-		val &= ~(mask >> (ofs ? (32 - ofs) : 0));
-		val |= v >> (ofs ? (32 - ofs) : 0);
-		writel(val, &base->word[word].data[i + 1]);
-	}
-}
-
-static u32 ipu_ch_param_read_field(struct ipuv3_channel *ch, u32 wbs)
-{
-	struct ipu_ch_param __iomem *base = ipu_get_cpmem(ch);
-	u32 bit = (wbs >> 8) % 160;
-	u32 size = wbs & 0xff;
-	u32 word = (wbs >> 8) / 160;
-	u32 i = bit / 32;
-	u32 ofs = bit % 32;
-	u32 mask = (1 << size) - 1;
-	u32 val = 0;
-
-	pr_debug("%s %d %d %d\n", __func__, word, bit , size);
-
-	val = (readl(&base->word[word].data[i]) >> ofs) & mask;
-
-	if ((bit + size - 1) / 32 > i) {
-		u32 tmp;
-
-		tmp = readl(&base->word[word].data[i + 1]);
-		tmp &= mask >> (ofs ? (32 - ofs) : 0);
-		val |= tmp << (ofs ? (32 - ofs) : 0);
-	}
-
-	return val;
-}
-
-/*
- * The V4L2 spec defines packed RGB formats in memory byte order, which from
- * point of view of the IPU corresponds to little-endian words with the first
- * component in the least significant bits.
- * The DRM pixel formats and IPU internal representation are ordered the other
- * way around, with the first named component ordered at the most significant
- * bits. Further, V4L2 formats are not well defined:
- *     https://linuxtv.org/downloads/v4l-dvb-apis/packed-rgb.html
- * We choose the interpretation which matches GStreamer behavior.
- */
-static int v4l2_pix_fmt_to_drm_fourcc(u32 pixelformat)
-{
-	switch (pixelformat) {
-	case V4L2_PIX_FMT_RGB565:
-		/*
-		 * Here we choose the 'corrected' interpretation of RGBP, a
-		 * little-endian 16-bit word with the red component at the most
-		 * significant bits:
-		 * g[2:0]b[4:0] r[4:0]g[5:3] <=> [16:0] R:G:B
-		 */
-		return DRM_FORMAT_RGB565;
-	case V4L2_PIX_FMT_BGR24:
-		/* B G R <=> [24:0] R:G:B */
-		return DRM_FORMAT_RGB888;
-	case V4L2_PIX_FMT_RGB24:
-		/* R G B <=> [24:0] B:G:R */
-		return DRM_FORMAT_BGR888;
-	case V4L2_PIX_FMT_BGR32:
-		/* B G R A <=> [32:0] A:B:G:R */
-		return DRM_FORMAT_XRGB8888;
-	case V4L2_PIX_FMT_RGB32:
-		/* R G B A <=> [32:0] A:B:G:R */
-		return DRM_FORMAT_XBGR8888;
-	case V4L2_PIX_FMT_UYVY:
-		return DRM_FORMAT_UYVY;
-	case V4L2_PIX_FMT_YUYV:
-		return DRM_FORMAT_YUYV;
-	case V4L2_PIX_FMT_YUV420:
-		return DRM_FORMAT_YUV420;
-	case V4L2_PIX_FMT_YUV422P:
-		return DRM_FORMAT_YUV422;
-	case V4L2_PIX_FMT_YVU420:
-		return DRM_FORMAT_YVU420;
-	case V4L2_PIX_FMT_NV12:
-		return DRM_FORMAT_NV12;
-	case V4L2_PIX_FMT_NV16:
-		return DRM_FORMAT_NV16;
-	}
-
-	return -EINVAL;
-}
-
-void ipu_cpmem_zero(struct ipuv3_channel *ch)
-{
-	struct ipu_ch_param __iomem *p = ipu_get_cpmem(ch);
-	void __iomem *base = p;
-	int i;
-
-	for (i = 0; i < sizeof(*p) / sizeof(u32); i++)
-		writel(0, base + i * sizeof(u32));
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_zero);
-
-void ipu_cpmem_set_resolution(struct ipuv3_channel *ch, int xres, int yres)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_FW, xres - 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_FH, yres - 1);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_resolution);
-
-void ipu_cpmem_skip_odd_chroma_rows(struct ipuv3_channel *ch)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_RDRW, 1);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_skip_odd_chroma_rows);
-
-void ipu_cpmem_set_stride(struct ipuv3_channel *ch, int stride)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_SLY, stride - 1);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_stride);
-
-void ipu_cpmem_set_high_priority(struct ipuv3_channel *ch)
-{
-	struct ipu_soc *ipu = ch->ipu;
-	u32 val;
-
-	if (ipu->ipu_type == IPUV3EX)
-		ipu_ch_param_write_field(ch, IPU_FIELD_ID, 1);
-
-	val = ipu_idmac_read(ipu, IDMAC_CHA_PRI(ch->num));
-	val |= 1 << (ch->num % 32);
-	ipu_idmac_write(ipu, val, IDMAC_CHA_PRI(ch->num));
-};
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_high_priority);
-
-void ipu_cpmem_set_buffer(struct ipuv3_channel *ch, int bufnum, dma_addr_t buf)
-{
-	if (bufnum)
-		ipu_ch_param_write_field(ch, IPU_FIELD_EBA1, buf >> 3);
-	else
-		ipu_ch_param_write_field(ch, IPU_FIELD_EBA0, buf >> 3);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_buffer);
-
-void ipu_cpmem_set_uv_offset(struct ipuv3_channel *ch, u32 u_off, u32 v_off)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_UBO, u_off / 8);
-	ipu_ch_param_write_field(ch, IPU_FIELD_VBO, v_off / 8);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_uv_offset);
-
-void ipu_cpmem_interlaced_scan(struct ipuv3_channel *ch, int stride)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_SO, 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_ILO, stride / 8);
-	ipu_ch_param_write_field(ch, IPU_FIELD_SLY, (stride * 2) - 1);
-};
-EXPORT_SYMBOL_GPL(ipu_cpmem_interlaced_scan);
-
-void ipu_cpmem_set_axi_id(struct ipuv3_channel *ch, u32 id)
-{
-	id &= 0x3;
-	ipu_ch_param_write_field(ch, IPU_FIELD_ID, id);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_axi_id);
-
-int ipu_cpmem_get_burstsize(struct ipuv3_channel *ch)
-{
-	return ipu_ch_param_read_field(ch, IPU_FIELD_NPB) + 1;
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_get_burstsize);
-
-void ipu_cpmem_set_burstsize(struct ipuv3_channel *ch, int burstsize)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_NPB, burstsize - 1);
-};
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_burstsize);
-
-void ipu_cpmem_set_block_mode(struct ipuv3_channel *ch)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_BM, 1);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_block_mode);
-
-void ipu_cpmem_set_rotation(struct ipuv3_channel *ch,
-			    enum ipu_rotate_mode rot)
-{
-	u32 temp_rot = bitrev8(rot) >> 5;
-
-	ipu_ch_param_write_field(ch, IPU_FIELD_ROT_HF_VF, temp_rot);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_rotation);
-
-int ipu_cpmem_set_format_rgb(struct ipuv3_channel *ch,
-			     const struct ipu_rgb *rgb)
-{
-	int bpp = 0, npb = 0, ro, go, bo, to;
-
-	ro = rgb->bits_per_pixel - rgb->red.length - rgb->red.offset;
-	go = rgb->bits_per_pixel - rgb->green.length - rgb->green.offset;
-	bo = rgb->bits_per_pixel - rgb->blue.length - rgb->blue.offset;
-	to = rgb->bits_per_pixel - rgb->transp.length - rgb->transp.offset;
-
-	ipu_ch_param_write_field(ch, IPU_FIELD_WID0, rgb->red.length - 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_OFS0, ro);
-	ipu_ch_param_write_field(ch, IPU_FIELD_WID1, rgb->green.length - 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_OFS1, go);
-	ipu_ch_param_write_field(ch, IPU_FIELD_WID2, rgb->blue.length - 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_OFS2, bo);
-
-	if (rgb->transp.length) {
-		ipu_ch_param_write_field(ch, IPU_FIELD_WID3,
-				rgb->transp.length - 1);
-		ipu_ch_param_write_field(ch, IPU_FIELD_OFS3, to);
-	} else {
-		ipu_ch_param_write_field(ch, IPU_FIELD_WID3, 7);
-		ipu_ch_param_write_field(ch, IPU_FIELD_OFS3,
-				rgb->bits_per_pixel);
-	}
-
-	switch (rgb->bits_per_pixel) {
-	case 32:
-		bpp = 0;
-		npb = 15;
-		break;
-	case 24:
-		bpp = 1;
-		npb = 19;
-		break;
-	case 16:
-		bpp = 3;
-		npb = 31;
-		break;
-	case 8:
-		bpp = 5;
-		npb = 63;
-		break;
-	default:
-		return -EINVAL;
-	}
-	ipu_ch_param_write_field(ch, IPU_FIELD_BPP, bpp);
-	ipu_ch_param_write_field(ch, IPU_FIELD_NPB, npb);
-	ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 7); /* rgb mode */
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_format_rgb);
-
-int ipu_cpmem_set_format_passthrough(struct ipuv3_channel *ch, int width)
-{
-	int bpp = 0, npb = 0;
-
-	switch (width) {
-	case 32:
-		bpp = 0;
-		npb = 15;
-		break;
-	case 24:
-		bpp = 1;
-		npb = 19;
-		break;
-	case 16:
-		bpp = 3;
-		npb = 31;
-		break;
-	case 8:
-		bpp = 5;
-		npb = 63;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ipu_ch_param_write_field(ch, IPU_FIELD_BPP, bpp);
-	ipu_ch_param_write_field(ch, IPU_FIELD_NPB, npb);
-	ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 6); /* raw mode */
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_format_passthrough);
-
-void ipu_cpmem_set_yuv_interleaved(struct ipuv3_channel *ch, u32 pixel_format)
-{
-	switch (pixel_format) {
-	case V4L2_PIX_FMT_UYVY:
-		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3); /* bits/pixel */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0xA);/* pix fmt */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);/* burst size */
-		break;
-	case V4L2_PIX_FMT_YUYV:
-		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3); /* bits/pixel */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0x8);/* pix fmt */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);/* burst size */
-		break;
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_yuv_interleaved);
-
-void ipu_cpmem_set_yuv_planar_full(struct ipuv3_channel *ch,
-				   unsigned int uv_stride,
-				   unsigned int u_offset, unsigned int v_offset)
-{
-	ipu_ch_param_write_field(ch, IPU_FIELD_SLUV, uv_stride - 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_UBO, u_offset / 8);
-	ipu_ch_param_write_field(ch, IPU_FIELD_VBO, v_offset / 8);
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_yuv_planar_full);
-
-static const struct ipu_rgb def_xrgb_32 = {
-	.red	= { .offset = 16, .length = 8, },
-	.green	= { .offset =  8, .length = 8, },
-	.blue	= { .offset =  0, .length = 8, },
-	.transp = { .offset = 24, .length = 8, },
-	.bits_per_pixel = 32,
-};
-
-static const struct ipu_rgb def_xbgr_32 = {
-	.red	= { .offset =  0, .length = 8, },
-	.green	= { .offset =  8, .length = 8, },
-	.blue	= { .offset = 16, .length = 8, },
-	.transp = { .offset = 24, .length = 8, },
-	.bits_per_pixel = 32,
-};
-
-static const struct ipu_rgb def_rgbx_32 = {
-	.red	= { .offset = 24, .length = 8, },
-	.green	= { .offset = 16, .length = 8, },
-	.blue	= { .offset =  8, .length = 8, },
-	.transp = { .offset =  0, .length = 8, },
-	.bits_per_pixel = 32,
-};
-
-static const struct ipu_rgb def_bgrx_32 = {
-	.red	= { .offset =  8, .length = 8, },
-	.green	= { .offset = 16, .length = 8, },
-	.blue	= { .offset = 24, .length = 8, },
-	.transp = { .offset =  0, .length = 8, },
-	.bits_per_pixel = 32,
-};
-
-static const struct ipu_rgb def_rgb_24 = {
-	.red	= { .offset = 16, .length = 8, },
-	.green	= { .offset =  8, .length = 8, },
-	.blue	= { .offset =  0, .length = 8, },
-	.transp = { .offset =  0, .length = 0, },
-	.bits_per_pixel = 24,
-};
-
-static const struct ipu_rgb def_bgr_24 = {
-	.red	= { .offset =  0, .length = 8, },
-	.green	= { .offset =  8, .length = 8, },
-	.blue	= { .offset = 16, .length = 8, },
-	.transp = { .offset =  0, .length = 0, },
-	.bits_per_pixel = 24,
-};
-
-static const struct ipu_rgb def_rgb_16 = {
-	.red	= { .offset = 11, .length = 5, },
-	.green	= { .offset =  5, .length = 6, },
-	.blue	= { .offset =  0, .length = 5, },
-	.transp = { .offset =  0, .length = 0, },
-	.bits_per_pixel = 16,
-};
-
-static const struct ipu_rgb def_bgr_16 = {
-	.red	= { .offset =  0, .length = 5, },
-	.green	= { .offset =  5, .length = 6, },
-	.blue	= { .offset = 11, .length = 5, },
-	.transp = { .offset =  0, .length = 0, },
-	.bits_per_pixel = 16,
-};
-
-static const struct ipu_rgb def_argb_16 = {
-	.red	= { .offset = 10, .length = 5, },
-	.green	= { .offset =  5, .length = 5, },
-	.blue	= { .offset =  0, .length = 5, },
-	.transp = { .offset = 15, .length = 1, },
-	.bits_per_pixel = 16,
-};
-
-static const struct ipu_rgb def_argb_16_4444 = {
-	.red	= { .offset =  8, .length = 4, },
-	.green	= { .offset =  4, .length = 4, },
-	.blue	= { .offset =  0, .length = 4, },
-	.transp = { .offset = 12, .length = 4, },
-	.bits_per_pixel = 16,
-};
-
-static const struct ipu_rgb def_abgr_16 = {
-	.red	= { .offset =  0, .length = 5, },
-	.green	= { .offset =  5, .length = 5, },
-	.blue	= { .offset = 10, .length = 5, },
-	.transp = { .offset = 15, .length = 1, },
-	.bits_per_pixel = 16,
-};
-
-static const struct ipu_rgb def_rgba_16 = {
-	.red	= { .offset = 11, .length = 5, },
-	.green	= { .offset =  6, .length = 5, },
-	.blue	= { .offset =  1, .length = 5, },
-	.transp = { .offset =  0, .length = 1, },
-	.bits_per_pixel = 16,
-};
-
-static const struct ipu_rgb def_bgra_16 = {
-	.red	= { .offset =  1, .length = 5, },
-	.green	= { .offset =  6, .length = 5, },
-	.blue	= { .offset = 11, .length = 5, },
-	.transp = { .offset =  0, .length = 1, },
-	.bits_per_pixel = 16,
-};
-
-#define Y_OFFSET(pix, x, y)	((x) + pix->width * (y))
-#define U_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
-				 (pix->width * (y) / 4) + (x) / 2)
-#define V_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
-				 (pix->width * pix->height / 4) +	\
-				 (pix->width * (y) / 4) + (x) / 2)
-#define U2_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
-				 (pix->width * (y) / 2) + (x) / 2)
-#define V2_OFFSET(pix, x, y)	((pix->width * pix->height) +		\
-				 (pix->width * pix->height / 2) +	\
-				 (pix->width * (y) / 2) + (x) / 2)
-#define UV_OFFSET(pix, x, y)	((pix->width * pix->height) +	\
-				 (pix->width * (y) / 2) + (x))
-#define UV2_OFFSET(pix, x, y)	((pix->width * pix->height) +	\
-				 (pix->width * y) + (x))
-
-#define NUM_ALPHA_CHANNELS	7
-
-/* See Table 37-12. Alpha channels mapping. */
-static int ipu_channel_albm(int ch_num)
-{
-	switch (ch_num) {
-	case IPUV3_CHANNEL_G_MEM_IC_PRP_VF:	return 0;
-	case IPUV3_CHANNEL_G_MEM_IC_PP:		return 1;
-	case IPUV3_CHANNEL_MEM_FG_SYNC:		return 2;
-	case IPUV3_CHANNEL_MEM_FG_ASYNC:	return 3;
-	case IPUV3_CHANNEL_MEM_BG_SYNC:		return 4;
-	case IPUV3_CHANNEL_MEM_BG_ASYNC:	return 5;
-	case IPUV3_CHANNEL_MEM_VDI_PLANE1_COMB: return 6;
-	default:
-		return -EINVAL;
-	}
-}
-
-static void ipu_cpmem_set_separate_alpha(struct ipuv3_channel *ch)
-{
-	struct ipu_soc *ipu = ch->ipu;
-	int albm;
-	u32 val;
-
-	albm = ipu_channel_albm(ch->num);
-	if (albm < 0)
-		return;
-
-	ipu_ch_param_write_field(ch, IPU_FIELD_ALU, 1);
-	ipu_ch_param_write_field(ch, IPU_FIELD_ALBM, albm);
-	ipu_ch_param_write_field(ch, IPU_FIELD_CRE, 1);
-
-	val = ipu_idmac_read(ipu, IDMAC_SEP_ALPHA);
-	val |= BIT(ch->num);
-	ipu_idmac_write(ipu, val, IDMAC_SEP_ALPHA);
-}
-
-int ipu_cpmem_set_fmt(struct ipuv3_channel *ch, u32 drm_fourcc)
-{
-	switch (drm_fourcc) {
-	case DRM_FORMAT_YUV420:
-	case DRM_FORMAT_YVU420:
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 2);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_YUV422:
-	case DRM_FORMAT_YVU422:
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 1);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_YUV444:
-	case DRM_FORMAT_YVU444:
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_NV12:
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 4);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_NV16:
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 3);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_UYVY:
-		/* bits/pixel */
-		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3);
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0xA);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_YUYV:
-		/* bits/pixel */
-		ipu_ch_param_write_field(ch, IPU_FIELD_BPP, 3);
-		/* pix format */
-		ipu_ch_param_write_field(ch, IPU_FIELD_PFS, 0x8);
-		/* burst size */
-		ipu_ch_param_write_field(ch, IPU_FIELD_NPB, 31);
-		break;
-	case DRM_FORMAT_ABGR8888:
-	case DRM_FORMAT_XBGR8888:
-		ipu_cpmem_set_format_rgb(ch, &def_xbgr_32);
-		break;
-	case DRM_FORMAT_ARGB8888:
-	case DRM_FORMAT_XRGB8888:
-		ipu_cpmem_set_format_rgb(ch, &def_xrgb_32);
-		break;
-	case DRM_FORMAT_RGBA8888:
-	case DRM_FORMAT_RGBX8888:
-	case DRM_FORMAT_RGBX8888_A8:
-		ipu_cpmem_set_format_rgb(ch, &def_rgbx_32);
-		break;
-	case DRM_FORMAT_BGRA8888:
-	case DRM_FORMAT_BGRX8888:
-	case DRM_FORMAT_BGRX8888_A8:
-		ipu_cpmem_set_format_rgb(ch, &def_bgrx_32);
-		break;
-	case DRM_FORMAT_BGR888:
-	case DRM_FORMAT_BGR888_A8:
-		ipu_cpmem_set_format_rgb(ch, &def_bgr_24);
-		break;
-	case DRM_FORMAT_RGB888:
-	case DRM_FORMAT_RGB888_A8:
-		ipu_cpmem_set_format_rgb(ch, &def_rgb_24);
-		break;
-	case DRM_FORMAT_RGB565:
-	case DRM_FORMAT_RGB565_A8:
-		ipu_cpmem_set_format_rgb(ch, &def_rgb_16);
-		break;
-	case DRM_FORMAT_BGR565:
-	case DRM_FORMAT_BGR565_A8:
-		ipu_cpmem_set_format_rgb(ch, &def_bgr_16);
-		break;
-	case DRM_FORMAT_ARGB1555:
-		ipu_cpmem_set_format_rgb(ch, &def_argb_16);
-		break;
-	case DRM_FORMAT_ABGR1555:
-		ipu_cpmem_set_format_rgb(ch, &def_abgr_16);
-		break;
-	case DRM_FORMAT_RGBA5551:
-		ipu_cpmem_set_format_rgb(ch, &def_rgba_16);
-		break;
-	case DRM_FORMAT_BGRA5551:
-		ipu_cpmem_set_format_rgb(ch, &def_bgra_16);
-		break;
-	case DRM_FORMAT_ARGB4444:
-		ipu_cpmem_set_format_rgb(ch, &def_argb_16_4444);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	switch (drm_fourcc) {
-	case DRM_FORMAT_RGB565_A8:
-	case DRM_FORMAT_BGR565_A8:
-	case DRM_FORMAT_RGB888_A8:
-	case DRM_FORMAT_BGR888_A8:
-	case DRM_FORMAT_RGBX8888_A8:
-	case DRM_FORMAT_BGRX8888_A8:
-		ipu_ch_param_write_field(ch, IPU_FIELD_WID3, 7);
-		ipu_cpmem_set_separate_alpha(ch);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_fmt);
-
-int ipu_cpmem_set_image(struct ipuv3_channel *ch, struct ipu_image *image)
-{
-	struct v4l2_pix_format *pix = &image->pix;
-	int offset, u_offset, v_offset;
-	int ret = 0;
-
-	pr_debug("%s: resolution: %dx%d stride: %d\n",
-		 __func__, pix->width, pix->height,
-		 pix->bytesperline);
-
-	ipu_cpmem_set_resolution(ch, image->rect.width, image->rect.height);
-	ipu_cpmem_set_stride(ch, pix->bytesperline);
-
-	ipu_cpmem_set_fmt(ch, v4l2_pix_fmt_to_drm_fourcc(pix->pixelformat));
-
-	switch (pix->pixelformat) {
-	case V4L2_PIX_FMT_YUV420:
-		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
-		u_offset = U_OFFSET(pix, image->rect.left,
-				    image->rect.top) - offset;
-		v_offset = V_OFFSET(pix, image->rect.left,
-				    image->rect.top) - offset;
-
-		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline / 2,
-					      u_offset, v_offset);
-		break;
-	case V4L2_PIX_FMT_YVU420:
-		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
-		u_offset = U_OFFSET(pix, image->rect.left,
-				    image->rect.top) - offset;
-		v_offset = V_OFFSET(pix, image->rect.left,
-				    image->rect.top) - offset;
-
-		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline / 2,
-					      v_offset, u_offset);
-		break;
-	case V4L2_PIX_FMT_YUV422P:
-		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
-		u_offset = U2_OFFSET(pix, image->rect.left,
-				     image->rect.top) - offset;
-		v_offset = V2_OFFSET(pix, image->rect.left,
-				     image->rect.top) - offset;
-
-		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline / 2,
-					      u_offset, v_offset);
-		break;
-	case V4L2_PIX_FMT_NV12:
-		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
-		u_offset = UV_OFFSET(pix, image->rect.left,
-				     image->rect.top) - offset;
-		v_offset = 0;
-
-		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline,
-					      u_offset, v_offset);
-		break;
-	case V4L2_PIX_FMT_NV16:
-		offset = Y_OFFSET(pix, image->rect.left, image->rect.top);
-		u_offset = UV2_OFFSET(pix, image->rect.left,
-				      image->rect.top) - offset;
-		v_offset = 0;
-
-		ipu_cpmem_set_yuv_planar_full(ch, pix->bytesperline,
-					      u_offset, v_offset);
-		break;
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_RGB565:
-		offset = image->rect.left * 2 +
-			image->rect.top * pix->bytesperline;
-		break;
-	case V4L2_PIX_FMT_RGB32:
-	case V4L2_PIX_FMT_BGR32:
-		offset = image->rect.left * 4 +
-			image->rect.top * pix->bytesperline;
-		break;
-	case V4L2_PIX_FMT_RGB24:
-	case V4L2_PIX_FMT_BGR24:
-		offset = image->rect.left * 3 +
-			image->rect.top * pix->bytesperline;
-		break;
-	case V4L2_PIX_FMT_SBGGR8:
-	case V4L2_PIX_FMT_SGBRG8:
-	case V4L2_PIX_FMT_SGRBG8:
-	case V4L2_PIX_FMT_SRGGB8:
-	case V4L2_PIX_FMT_GREY:
-		offset = image->rect.left + image->rect.top * pix->bytesperline;
-		break;
-	case V4L2_PIX_FMT_SBGGR16:
-	case V4L2_PIX_FMT_SGBRG16:
-	case V4L2_PIX_FMT_SGRBG16:
-	case V4L2_PIX_FMT_SRGGB16:
-	case V4L2_PIX_FMT_Y16:
-		offset = image->rect.left * 2 +
-			 image->rect.top * pix->bytesperline;
-		break;
-	default:
-		/* This should not happen */
-		WARN_ON(1);
-		offset = 0;
-		ret = -EINVAL;
-	}
-
-	ipu_cpmem_set_buffer(ch, 0, image->phys0 + offset);
-	ipu_cpmem_set_buffer(ch, 1, image->phys1 + offset);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_set_image);
-
-void ipu_cpmem_dump(struct ipuv3_channel *ch)
-{
-	struct ipu_ch_param __iomem *p = ipu_get_cpmem(ch);
-	struct ipu_soc *ipu = ch->ipu;
-	int chno = ch->num;
-
-	dev_dbg(ipu->dev, "ch %d word 0 - %08X %08X %08X %08X %08X\n", chno,
-		readl(&p->word[0].data[0]),
-		readl(&p->word[0].data[1]),
-		readl(&p->word[0].data[2]),
-		readl(&p->word[0].data[3]),
-		readl(&p->word[0].data[4]));
-	dev_dbg(ipu->dev, "ch %d word 1 - %08X %08X %08X %08X %08X\n", chno,
-		readl(&p->word[1].data[0]),
-		readl(&p->word[1].data[1]),
-		readl(&p->word[1].data[2]),
-		readl(&p->word[1].data[3]),
-		readl(&p->word[1].data[4]));
-	dev_dbg(ipu->dev, "PFS 0x%x, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_PFS));
-	dev_dbg(ipu->dev, "BPP 0x%x, ",
-		ipu_ch_param_read_field(ch, IPU_FIELD_BPP));
-	dev_dbg(ipu->dev, "NPB 0x%x\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_NPB));
-
-	dev_dbg(ipu->dev, "FW %d, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_FW));
-	dev_dbg(ipu->dev, "FH %d, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_FH));
-	dev_dbg(ipu->dev, "EBA0 0x%x\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_EBA0) << 3);
-	dev_dbg(ipu->dev, "EBA1 0x%x\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_EBA1) << 3);
-	dev_dbg(ipu->dev, "Stride %d\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_SL));
-	dev_dbg(ipu->dev, "scan_order %d\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_SO));
-	dev_dbg(ipu->dev, "uv_stride %d\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_SLUV));
-	dev_dbg(ipu->dev, "u_offset 0x%x\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_UBO) << 3);
-	dev_dbg(ipu->dev, "v_offset 0x%x\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_VBO) << 3);
-
-	dev_dbg(ipu->dev, "Width0 %d+1, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_WID0));
-	dev_dbg(ipu->dev, "Width1 %d+1, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_WID1));
-	dev_dbg(ipu->dev, "Width2 %d+1, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_WID2));
-	dev_dbg(ipu->dev, "Width3 %d+1, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_WID3));
-	dev_dbg(ipu->dev, "Offset0 %d, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS0));
-	dev_dbg(ipu->dev, "Offset1 %d, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS1));
-	dev_dbg(ipu->dev, "Offset2 %d, ",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS2));
-	dev_dbg(ipu->dev, "Offset3 %d\n",
-		 ipu_ch_param_read_field(ch, IPU_FIELD_OFS3));
-}
-EXPORT_SYMBOL_GPL(ipu_cpmem_dump);
-
-int ipu_cpmem_init(struct ipu_soc *ipu, struct device *dev, unsigned long base)
-{
-	struct ipu_cpmem *cpmem;
-
-	cpmem = devm_kzalloc(dev, sizeof(*cpmem), GFP_KERNEL);
-	if (!cpmem)
-		return -ENOMEM;
-
-	ipu->cpmem_priv = cpmem;
-
-	spin_lock_init(&cpmem->lock);
-	cpmem->base = devm_ioremap(dev, base, SZ_128K);
-	if (!cpmem->base)
-		return -ENOMEM;
-
-	dev_dbg(dev, "CPMEM base: 0x%08lx remapped to %p\n",
-		base, cpmem->base);
-	cpmem->ipu = ipu;
-
-	return 0;
-}
-
-void ipu_cpmem_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-csi.c b/drivers/gpu/ipu-v3/ipu-csi.c
deleted file mode 100644
index 2beadb3..0000000
--- a/drivers/gpu/ipu-v3/ipu-csi.c
+++ /dev/null
@@ -1,776 +0,0 @@
-/*
- * Copyright (C) 2012-2014 Mentor Graphics Inc.
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/export.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
-#include <linux/videodev2.h>
-#include <uapi/linux/v4l2-mediabus.h>
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/clkdev.h>
-
-#include "ipu-prv.h"
-
-struct ipu_csi {
-	void __iomem *base;
-	int id;
-	u32 module;
-	struct clk *clk_ipu;	/* IPU bus clock */
-	spinlock_t lock;
-	bool inuse;
-	struct ipu_soc *ipu;
-};
-
-/* CSI Register Offsets */
-#define CSI_SENS_CONF		0x0000
-#define CSI_SENS_FRM_SIZE	0x0004
-#define CSI_ACT_FRM_SIZE	0x0008
-#define CSI_OUT_FRM_CTRL	0x000c
-#define CSI_TST_CTRL		0x0010
-#define CSI_CCIR_CODE_1		0x0014
-#define CSI_CCIR_CODE_2		0x0018
-#define CSI_CCIR_CODE_3		0x001c
-#define CSI_MIPI_DI		0x0020
-#define CSI_SKIP		0x0024
-#define CSI_CPD_CTRL		0x0028
-#define CSI_CPD_RC(n)		(0x002c + ((n)*4))
-#define CSI_CPD_RS(n)		(0x004c + ((n)*4))
-#define CSI_CPD_GRC(n)		(0x005c + ((n)*4))
-#define CSI_CPD_GRS(n)		(0x007c + ((n)*4))
-#define CSI_CPD_GBC(n)		(0x008c + ((n)*4))
-#define CSI_CPD_GBS(n)		(0x00Ac + ((n)*4))
-#define CSI_CPD_BC(n)		(0x00Bc + ((n)*4))
-#define CSI_CPD_BS(n)		(0x00Dc + ((n)*4))
-#define CSI_CPD_OFFSET1		0x00ec
-#define CSI_CPD_OFFSET2		0x00f0
-
-/* CSI Register Fields */
-#define CSI_SENS_CONF_DATA_FMT_SHIFT		8
-#define CSI_SENS_CONF_DATA_FMT_MASK		0x00000700
-#define CSI_SENS_CONF_DATA_FMT_RGB_YUV444	0L
-#define CSI_SENS_CONF_DATA_FMT_YUV422_YUYV	1L
-#define CSI_SENS_CONF_DATA_FMT_YUV422_UYVY	2L
-#define CSI_SENS_CONF_DATA_FMT_BAYER		3L
-#define CSI_SENS_CONF_DATA_FMT_RGB565		4L
-#define CSI_SENS_CONF_DATA_FMT_RGB555		5L
-#define CSI_SENS_CONF_DATA_FMT_RGB444		6L
-#define CSI_SENS_CONF_DATA_FMT_JPEG		7L
-
-#define CSI_SENS_CONF_VSYNC_POL_SHIFT		0
-#define CSI_SENS_CONF_HSYNC_POL_SHIFT		1
-#define CSI_SENS_CONF_DATA_POL_SHIFT		2
-#define CSI_SENS_CONF_PIX_CLK_POL_SHIFT		3
-#define CSI_SENS_CONF_SENS_PRTCL_MASK		0x00000070
-#define CSI_SENS_CONF_SENS_PRTCL_SHIFT		4
-#define CSI_SENS_CONF_PACK_TIGHT_SHIFT		7
-#define CSI_SENS_CONF_DATA_WIDTH_SHIFT		11
-#define CSI_SENS_CONF_EXT_VSYNC_SHIFT		15
-#define CSI_SENS_CONF_DIVRATIO_SHIFT		16
-
-#define CSI_SENS_CONF_DIVRATIO_MASK		0x00ff0000
-#define CSI_SENS_CONF_DATA_DEST_SHIFT		24
-#define CSI_SENS_CONF_DATA_DEST_MASK		0x07000000
-#define CSI_SENS_CONF_JPEG8_EN_SHIFT		27
-#define CSI_SENS_CONF_JPEG_EN_SHIFT		28
-#define CSI_SENS_CONF_FORCE_EOF_SHIFT		29
-#define CSI_SENS_CONF_DATA_EN_POL_SHIFT		31
-
-#define CSI_DATA_DEST_IC			2
-#define CSI_DATA_DEST_IDMAC			4
-
-#define CSI_CCIR_ERR_DET_EN			0x01000000
-#define CSI_HORI_DOWNSIZE_EN			0x80000000
-#define CSI_VERT_DOWNSIZE_EN			0x40000000
-#define CSI_TEST_GEN_MODE_EN			0x01000000
-
-#define CSI_HSC_MASK				0x1fff0000
-#define CSI_HSC_SHIFT				16
-#define CSI_VSC_MASK				0x00000fff
-#define CSI_VSC_SHIFT				0
-
-#define CSI_TEST_GEN_R_MASK			0x000000ff
-#define CSI_TEST_GEN_R_SHIFT			0
-#define CSI_TEST_GEN_G_MASK			0x0000ff00
-#define CSI_TEST_GEN_G_SHIFT			8
-#define CSI_TEST_GEN_B_MASK			0x00ff0000
-#define CSI_TEST_GEN_B_SHIFT			16
-
-#define CSI_MAX_RATIO_SKIP_SMFC_MASK		0x00000007
-#define CSI_MAX_RATIO_SKIP_SMFC_SHIFT		0
-#define CSI_SKIP_SMFC_MASK			0x000000f8
-#define CSI_SKIP_SMFC_SHIFT			3
-#define CSI_ID_2_SKIP_MASK			0x00000300
-#define CSI_ID_2_SKIP_SHIFT			8
-
-#define CSI_COLOR_FIRST_ROW_MASK		0x00000002
-#define CSI_COLOR_FIRST_COMP_MASK		0x00000001
-
-/* MIPI CSI-2 data types */
-#define MIPI_DT_YUV420		0x18 /* YYY.../UYVY.... */
-#define MIPI_DT_YUV420_LEGACY	0x1a /* UYY.../VYY...   */
-#define MIPI_DT_YUV422		0x1e /* UYVY...         */
-#define MIPI_DT_RGB444		0x20
-#define MIPI_DT_RGB555		0x21
-#define MIPI_DT_RGB565		0x22
-#define MIPI_DT_RGB666		0x23
-#define MIPI_DT_RGB888		0x24
-#define MIPI_DT_RAW6		0x28
-#define MIPI_DT_RAW7		0x29
-#define MIPI_DT_RAW8		0x2a
-#define MIPI_DT_RAW10		0x2b
-#define MIPI_DT_RAW12		0x2c
-#define MIPI_DT_RAW14		0x2d
-
-/*
- * Bitfield of CSI bus signal polarities and modes.
- */
-struct ipu_csi_bus_config {
-	unsigned data_width:4;
-	unsigned clk_mode:3;
-	unsigned ext_vsync:1;
-	unsigned vsync_pol:1;
-	unsigned hsync_pol:1;
-	unsigned pixclk_pol:1;
-	unsigned data_pol:1;
-	unsigned sens_clksrc:1;
-	unsigned pack_tight:1;
-	unsigned force_eof:1;
-	unsigned data_en_pol:1;
-
-	unsigned data_fmt;
-	unsigned mipi_dt;
-};
-
-/*
- * Enumeration of CSI data bus widths.
- */
-enum ipu_csi_data_width {
-	IPU_CSI_DATA_WIDTH_4   = 0,
-	IPU_CSI_DATA_WIDTH_8   = 1,
-	IPU_CSI_DATA_WIDTH_10  = 3,
-	IPU_CSI_DATA_WIDTH_12  = 5,
-	IPU_CSI_DATA_WIDTH_16  = 9,
-};
-
-/*
- * Enumeration of CSI clock modes.
- */
-enum ipu_csi_clk_mode {
-	IPU_CSI_CLK_MODE_GATED_CLK,
-	IPU_CSI_CLK_MODE_NONGATED_CLK,
-	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
-	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
-	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
-	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
-	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
-	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
-};
-
-static inline u32 ipu_csi_read(struct ipu_csi *csi, unsigned offset)
-{
-	return readl(csi->base + offset);
-}
-
-static inline void ipu_csi_write(struct ipu_csi *csi, u32 value,
-				 unsigned offset)
-{
-	writel(value, csi->base + offset);
-}
-
-/*
- * Set mclk division ratio for generating test mode mclk. Only used
- * for test generator.
- */
-static int ipu_csi_set_testgen_mclk(struct ipu_csi *csi, u32 pixel_clk,
-					u32 ipu_clk)
-{
-	u32 temp;
-	int div_ratio;
-
-	div_ratio = (ipu_clk / pixel_clk) - 1;
-
-	if (div_ratio > 0xFF || div_ratio < 0) {
-		dev_err(csi->ipu->dev,
-			"value of pixel_clk extends normal range\n");
-		return -EINVAL;
-	}
-
-	temp = ipu_csi_read(csi, CSI_SENS_CONF);
-	temp &= ~CSI_SENS_CONF_DIVRATIO_MASK;
-	ipu_csi_write(csi, temp | (div_ratio << CSI_SENS_CONF_DIVRATIO_SHIFT),
-			  CSI_SENS_CONF);
-
-	return 0;
-}
-
-/*
- * Find the CSI data format and data width for the given V4L2 media
- * bus pixel format code.
- */
-static int mbus_code_to_bus_cfg(struct ipu_csi_bus_config *cfg, u32 mbus_code)
-{
-	switch (mbus_code) {
-	case MEDIA_BUS_FMT_BGR565_2X8_BE:
-	case MEDIA_BUS_FMT_BGR565_2X8_LE:
-	case MEDIA_BUS_FMT_RGB565_2X8_BE:
-	case MEDIA_BUS_FMT_RGB565_2X8_LE:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB565;
-		cfg->mipi_dt = MIPI_DT_RGB565;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:
-	case MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB444;
-		cfg->mipi_dt = MIPI_DT_RGB444;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:
-	case MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB555;
-		cfg->mipi_dt = MIPI_DT_RGB555;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_UYVY8_2X8:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;
-		cfg->mipi_dt = MIPI_DT_YUV422;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_YUYV8_2X8:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;
-		cfg->mipi_dt = MIPI_DT_YUV422;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-	case MEDIA_BUS_FMT_YUYV8_1X16:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
-		cfg->mipi_dt = MIPI_DT_YUV422;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_16;
-		break;
-	case MEDIA_BUS_FMT_SBGGR8_1X8:
-	case MEDIA_BUS_FMT_SGBRG8_1X8:
-	case MEDIA_BUS_FMT_SGRBG8_1X8:
-	case MEDIA_BUS_FMT_SRGGB8_1X8:
-	case MEDIA_BUS_FMT_Y8_1X8:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
-		cfg->mipi_dt = MIPI_DT_RAW8;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
-	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
-	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
-	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
-	case MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE:
-	case MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:
-	case MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE:
-	case MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
-		cfg->mipi_dt = MIPI_DT_RAW10;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	case MEDIA_BUS_FMT_SBGGR10_1X10:
-	case MEDIA_BUS_FMT_SGBRG10_1X10:
-	case MEDIA_BUS_FMT_SGRBG10_1X10:
-	case MEDIA_BUS_FMT_SRGGB10_1X10:
-	case MEDIA_BUS_FMT_Y10_1X10:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
-		cfg->mipi_dt = MIPI_DT_RAW10;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_10;
-		break;
-	case MEDIA_BUS_FMT_SBGGR12_1X12:
-	case MEDIA_BUS_FMT_SGBRG12_1X12:
-	case MEDIA_BUS_FMT_SGRBG12_1X12:
-	case MEDIA_BUS_FMT_SRGGB12_1X12:
-	case MEDIA_BUS_FMT_Y12_1X12:
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
-		cfg->mipi_dt = MIPI_DT_RAW12;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_12;
-		break;
-	case MEDIA_BUS_FMT_JPEG_1X8:
-		/* TODO */
-		cfg->data_fmt = CSI_SENS_CONF_DATA_FMT_JPEG;
-		cfg->mipi_dt = MIPI_DT_RAW8;
-		cfg->data_width = IPU_CSI_DATA_WIDTH_8;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/*
- * Fill a CSI bus config struct from mbus_config and mbus_framefmt.
- */
-static int fill_csi_bus_cfg(struct ipu_csi_bus_config *csicfg,
-				 struct v4l2_mbus_config *mbus_cfg,
-				 struct v4l2_mbus_framefmt *mbus_fmt)
-{
-	int ret;
-
-	memset(csicfg, 0, sizeof(*csicfg));
-
-	ret = mbus_code_to_bus_cfg(csicfg, mbus_fmt->code);
-	if (ret < 0)
-		return ret;
-
-	switch (mbus_cfg->type) {
-	case V4L2_MBUS_PARALLEL:
-		csicfg->ext_vsync = 1;
-		csicfg->vsync_pol = (mbus_cfg->flags &
-				     V4L2_MBUS_VSYNC_ACTIVE_LOW) ? 1 : 0;
-		csicfg->hsync_pol = (mbus_cfg->flags &
-				     V4L2_MBUS_HSYNC_ACTIVE_LOW) ? 1 : 0;
-		csicfg->pixclk_pol = (mbus_cfg->flags &
-				      V4L2_MBUS_PCLK_SAMPLE_FALLING) ? 1 : 0;
-		csicfg->clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;
-		break;
-	case V4L2_MBUS_BT656:
-		csicfg->ext_vsync = 0;
-		if (V4L2_FIELD_HAS_BOTH(mbus_fmt->field) ||
-		    mbus_fmt->field == V4L2_FIELD_ALTERNATE)
-			csicfg->clk_mode = IPU_CSI_CLK_MODE_CCIR656_INTERLACED;
-		else
-			csicfg->clk_mode = IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE;
-		break;
-	case V4L2_MBUS_CSI2:
-		/*
-		 * MIPI CSI-2 requires non gated clock mode, all other
-		 * parameters are not applicable for MIPI CSI-2 bus.
-		 */
-		csicfg->clk_mode = IPU_CSI_CLK_MODE_NONGATED_CLK;
-		break;
-	default:
-		/* will never get here, keep compiler quiet */
-		break;
-	}
-
-	return 0;
-}
-
-int ipu_csi_init_interface(struct ipu_csi *csi,
-			   struct v4l2_mbus_config *mbus_cfg,
-			   struct v4l2_mbus_framefmt *mbus_fmt)
-{
-	struct ipu_csi_bus_config cfg;
-	unsigned long flags;
-	u32 width, height, data = 0;
-	int ret;
-
-	ret = fill_csi_bus_cfg(&cfg, mbus_cfg, mbus_fmt);
-	if (ret < 0)
-		return ret;
-
-	/* set default sensor frame width and height */
-	width = mbus_fmt->width;
-	height = mbus_fmt->height;
-
-	/* Set the CSI_SENS_CONF register remaining fields */
-	data |= cfg.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
-		cfg.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |
-		cfg.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |
-		cfg.vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |
-		cfg.hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |
-		cfg.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |
-		cfg.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |
-		cfg.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |
-		cfg.pack_tight << CSI_SENS_CONF_PACK_TIGHT_SHIFT |
-		cfg.force_eof << CSI_SENS_CONF_FORCE_EOF_SHIFT |
-		cfg.data_en_pol << CSI_SENS_CONF_DATA_EN_POL_SHIFT;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	ipu_csi_write(csi, data, CSI_SENS_CONF);
-
-	/* Set CCIR registers */
-
-	switch (cfg.clk_mode) {
-	case IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:
-		ipu_csi_write(csi, 0x40030, CSI_CCIR_CODE_1);
-		ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
-		break;
-	case IPU_CSI_CLK_MODE_CCIR656_INTERLACED:
-		if (mbus_fmt->width == 720 && mbus_fmt->height == 576) {
-			/*
-			 * PAL case
-			 *
-			 * Field0BlankEnd = 0x6, Field0BlankStart = 0x2,
-			 * Field0ActiveEnd = 0x4, Field0ActiveStart = 0
-			 * Field1BlankEnd = 0x7, Field1BlankStart = 0x3,
-			 * Field1ActiveEnd = 0x5, Field1ActiveStart = 0x1
-			 */
-			height = 625; /* framelines for PAL */
-
-			ipu_csi_write(csi, 0x40596 | CSI_CCIR_ERR_DET_EN,
-					  CSI_CCIR_CODE_1);
-			ipu_csi_write(csi, 0xD07DF, CSI_CCIR_CODE_2);
-			ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
-		} else if (mbus_fmt->width == 720 && mbus_fmt->height == 480) {
-			/*
-			 * NTSC case
-			 *
-			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
-			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
-			 */
-			height = 525; /* framelines for NTSC */
-
-			ipu_csi_write(csi, 0xD07DF | CSI_CCIR_ERR_DET_EN,
-					  CSI_CCIR_CODE_1);
-			ipu_csi_write(csi, 0x40596, CSI_CCIR_CODE_2);
-			ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
-		} else {
-			dev_err(csi->ipu->dev,
-				"Unsupported CCIR656 interlaced video mode\n");
-			spin_unlock_irqrestore(&csi->lock, flags);
-			return -EINVAL;
-		}
-		break;
-	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:
-	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:
-	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:
-	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:
-		ipu_csi_write(csi, 0x40030 | CSI_CCIR_ERR_DET_EN,
-				   CSI_CCIR_CODE_1);
-		ipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);
-		break;
-	case IPU_CSI_CLK_MODE_GATED_CLK:
-	case IPU_CSI_CLK_MODE_NONGATED_CLK:
-		ipu_csi_write(csi, 0, CSI_CCIR_CODE_1);
-		break;
-	}
-
-	/* Setup sensor frame size */
-	ipu_csi_write(csi, (width - 1) | ((height - 1) << 16),
-		      CSI_SENS_FRM_SIZE);
-
-	dev_dbg(csi->ipu->dev, "CSI_SENS_CONF = 0x%08X\n",
-		ipu_csi_read(csi, CSI_SENS_CONF));
-	dev_dbg(csi->ipu->dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",
-		ipu_csi_read(csi, CSI_ACT_FRM_SIZE));
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_init_interface);
-
-bool ipu_csi_is_interlaced(struct ipu_csi *csi)
-{
-	unsigned long flags;
-	u32 sensor_protocol;
-
-	spin_lock_irqsave(&csi->lock, flags);
-	sensor_protocol =
-		(ipu_csi_read(csi, CSI_SENS_CONF) &
-		 CSI_SENS_CONF_SENS_PRTCL_MASK) >>
-		CSI_SENS_CONF_SENS_PRTCL_SHIFT;
-	spin_unlock_irqrestore(&csi->lock, flags);
-
-	switch (sensor_protocol) {
-	case IPU_CSI_CLK_MODE_GATED_CLK:
-	case IPU_CSI_CLK_MODE_NONGATED_CLK:
-	case IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:
-	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:
-	case IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:
-		return false;
-	case IPU_CSI_CLK_MODE_CCIR656_INTERLACED:
-	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:
-	case IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:
-		return true;
-	default:
-		dev_err(csi->ipu->dev,
-			"CSI %d sensor protocol unsupported\n", csi->id);
-		return false;
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_csi_is_interlaced);
-
-void ipu_csi_get_window(struct ipu_csi *csi, struct v4l2_rect *w)
-{
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	reg = ipu_csi_read(csi, CSI_ACT_FRM_SIZE);
-	w->width = (reg & 0xFFFF) + 1;
-	w->height = (reg >> 16 & 0xFFFF) + 1;
-
-	reg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);
-	w->left = (reg & CSI_HSC_MASK) >> CSI_HSC_SHIFT;
-	w->top = (reg & CSI_VSC_MASK) >> CSI_VSC_SHIFT;
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_csi_get_window);
-
-void ipu_csi_set_window(struct ipu_csi *csi, struct v4l2_rect *w)
-{
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	ipu_csi_write(csi, (w->width - 1) | ((w->height - 1) << 16),
-			  CSI_ACT_FRM_SIZE);
-
-	reg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);
-	reg &= ~(CSI_HSC_MASK | CSI_VSC_MASK);
-	reg |= ((w->top << CSI_VSC_SHIFT) | (w->left << CSI_HSC_SHIFT));
-	ipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_csi_set_window);
-
-void ipu_csi_set_downsize(struct ipu_csi *csi, bool horiz, bool vert)
-{
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	reg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);
-	reg &= ~(CSI_HORI_DOWNSIZE_EN | CSI_VERT_DOWNSIZE_EN);
-	reg |= (horiz ? CSI_HORI_DOWNSIZE_EN : 0) |
-	       (vert ? CSI_VERT_DOWNSIZE_EN : 0);
-	ipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_csi_set_downsize);
-
-void ipu_csi_set_test_generator(struct ipu_csi *csi, bool active,
-				u32 r_value, u32 g_value, u32 b_value,
-				u32 pix_clk)
-{
-	unsigned long flags;
-	u32 ipu_clk = clk_get_rate(csi->clk_ipu);
-	u32 temp;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	temp = ipu_csi_read(csi, CSI_TST_CTRL);
-
-	if (!active) {
-		temp &= ~CSI_TEST_GEN_MODE_EN;
-		ipu_csi_write(csi, temp, CSI_TST_CTRL);
-	} else {
-		/* Set sensb_mclk div_ratio */
-		ipu_csi_set_testgen_mclk(csi, pix_clk, ipu_clk);
-
-		temp &= ~(CSI_TEST_GEN_R_MASK | CSI_TEST_GEN_G_MASK |
-			  CSI_TEST_GEN_B_MASK);
-		temp |= CSI_TEST_GEN_MODE_EN;
-		temp |= (r_value << CSI_TEST_GEN_R_SHIFT) |
-			(g_value << CSI_TEST_GEN_G_SHIFT) |
-			(b_value << CSI_TEST_GEN_B_SHIFT);
-		ipu_csi_write(csi, temp, CSI_TST_CTRL);
-	}
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_csi_set_test_generator);
-
-int ipu_csi_set_mipi_datatype(struct ipu_csi *csi, u32 vc,
-			      struct v4l2_mbus_framefmt *mbus_fmt)
-{
-	struct ipu_csi_bus_config cfg;
-	unsigned long flags;
-	u32 temp;
-	int ret;
-
-	if (vc > 3)
-		return -EINVAL;
-
-	ret = mbus_code_to_bus_cfg(&cfg, mbus_fmt->code);
-	if (ret < 0)
-		return ret;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	temp = ipu_csi_read(csi, CSI_MIPI_DI);
-	temp &= ~(0xff << (vc * 8));
-	temp |= (cfg.mipi_dt << (vc * 8));
-	ipu_csi_write(csi, temp, CSI_MIPI_DI);
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_set_mipi_datatype);
-
-int ipu_csi_set_skip_smfc(struct ipu_csi *csi, u32 skip,
-			  u32 max_ratio, u32 id)
-{
-	unsigned long flags;
-	u32 temp;
-
-	if (max_ratio > 5 || id > 3)
-		return -EINVAL;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	temp = ipu_csi_read(csi, CSI_SKIP);
-	temp &= ~(CSI_MAX_RATIO_SKIP_SMFC_MASK | CSI_ID_2_SKIP_MASK |
-		  CSI_SKIP_SMFC_MASK);
-	temp |= (max_ratio << CSI_MAX_RATIO_SKIP_SMFC_SHIFT) |
-		(id << CSI_ID_2_SKIP_SHIFT) |
-		(skip << CSI_SKIP_SMFC_SHIFT);
-	ipu_csi_write(csi, temp, CSI_SKIP);
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_set_skip_smfc);
-
-int ipu_csi_set_dest(struct ipu_csi *csi, enum ipu_csi_dest csi_dest)
-{
-	unsigned long flags;
-	u32 csi_sens_conf, dest;
-
-	if (csi_dest == IPU_CSI_DEST_IDMAC)
-		dest = CSI_DATA_DEST_IDMAC;
-	else
-		dest = CSI_DATA_DEST_IC; /* IC or VDIC */
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	csi_sens_conf = ipu_csi_read(csi, CSI_SENS_CONF);
-	csi_sens_conf &= ~CSI_SENS_CONF_DATA_DEST_MASK;
-	csi_sens_conf |= (dest << CSI_SENS_CONF_DATA_DEST_SHIFT);
-	ipu_csi_write(csi, csi_sens_conf, CSI_SENS_CONF);
-
-	spin_unlock_irqrestore(&csi->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_set_dest);
-
-int ipu_csi_enable(struct ipu_csi *csi)
-{
-	ipu_module_enable(csi->ipu, csi->module);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_enable);
-
-int ipu_csi_disable(struct ipu_csi *csi)
-{
-	ipu_module_disable(csi->ipu, csi->module);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_disable);
-
-struct ipu_csi *ipu_csi_get(struct ipu_soc *ipu, int id)
-{
-	unsigned long flags;
-	struct ipu_csi *csi, *ret;
-
-	if (id > 1)
-		return ERR_PTR(-EINVAL);
-
-	csi = ipu->csi_priv[id];
-	ret = csi;
-
-	spin_lock_irqsave(&csi->lock, flags);
-
-	if (csi->inuse) {
-		ret = ERR_PTR(-EBUSY);
-		goto unlock;
-	}
-
-	csi->inuse = true;
-unlock:
-	spin_unlock_irqrestore(&csi->lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_csi_get);
-
-void ipu_csi_put(struct ipu_csi *csi)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&csi->lock, flags);
-	csi->inuse = false;
-	spin_unlock_irqrestore(&csi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_csi_put);
-
-int ipu_csi_init(struct ipu_soc *ipu, struct device *dev, int id,
-		 unsigned long base, u32 module, struct clk *clk_ipu)
-{
-	struct ipu_csi *csi;
-
-	if (id > 1)
-		return -ENODEV;
-
-	csi = devm_kzalloc(dev, sizeof(*csi), GFP_KERNEL);
-	if (!csi)
-		return -ENOMEM;
-
-	ipu->csi_priv[id] = csi;
-
-	spin_lock_init(&csi->lock);
-	csi->module = module;
-	csi->id = id;
-	csi->clk_ipu = clk_ipu;
-	csi->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!csi->base)
-		return -ENOMEM;
-
-	dev_dbg(dev, "CSI%d base: 0x%08lx remapped to %p\n",
-		id, base, csi->base);
-	csi->ipu = ipu;
-
-	return 0;
-}
-
-void ipu_csi_exit(struct ipu_soc *ipu, int id)
-{
-}
-
-void ipu_csi_dump(struct ipu_csi *csi)
-{
-	dev_dbg(csi->ipu->dev, "CSI_SENS_CONF:     %08x\n",
-		ipu_csi_read(csi, CSI_SENS_CONF));
-	dev_dbg(csi->ipu->dev, "CSI_SENS_FRM_SIZE: %08x\n",
-		ipu_csi_read(csi, CSI_SENS_FRM_SIZE));
-	dev_dbg(csi->ipu->dev, "CSI_ACT_FRM_SIZE:  %08x\n",
-		ipu_csi_read(csi, CSI_ACT_FRM_SIZE));
-	dev_dbg(csi->ipu->dev, "CSI_OUT_FRM_CTRL:  %08x\n",
-		ipu_csi_read(csi, CSI_OUT_FRM_CTRL));
-	dev_dbg(csi->ipu->dev, "CSI_TST_CTRL:      %08x\n",
-		ipu_csi_read(csi, CSI_TST_CTRL));
-	dev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_1:   %08x\n",
-		ipu_csi_read(csi, CSI_CCIR_CODE_1));
-	dev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_2:   %08x\n",
-		ipu_csi_read(csi, CSI_CCIR_CODE_2));
-	dev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_3:   %08x\n",
-		ipu_csi_read(csi, CSI_CCIR_CODE_3));
-	dev_dbg(csi->ipu->dev, "CSI_MIPI_DI:       %08x\n",
-		ipu_csi_read(csi, CSI_MIPI_DI));
-	dev_dbg(csi->ipu->dev, "CSI_SKIP:          %08x\n",
-		ipu_csi_read(csi, CSI_SKIP));
-}
-EXPORT_SYMBOL_GPL(ipu_csi_dump);
diff --git a/drivers/gpu/ipu-v3/ipu-dc.c b/drivers/gpu/ipu-v3/ipu-dc.c
deleted file mode 100644
index 49bfe6e..0000000
--- a/drivers/gpu/ipu-v3/ipu-dc.c
+++ /dev/null
@@ -1,429 +0,0 @@
-/*
- * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/export.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-
-#include <video/imx-ipu-v3.h>
-#include "ipu-prv.h"
-
-#define DC_MAP_CONF_PTR(n)	(0x108 + ((n) & ~0x1) * 2)
-#define DC_MAP_CONF_VAL(n)	(0x144 + ((n) & ~0x1) * 2)
-
-#define DC_EVT_NF		0
-#define DC_EVT_NL		1
-#define DC_EVT_EOF		2
-#define DC_EVT_NFIELD		3
-#define DC_EVT_EOL		4
-#define DC_EVT_EOFIELD		5
-#define DC_EVT_NEW_ADDR		6
-#define DC_EVT_NEW_CHAN		7
-#define DC_EVT_NEW_DATA		8
-
-#define DC_EVT_NEW_ADDR_W_0	0
-#define DC_EVT_NEW_ADDR_W_1	1
-#define DC_EVT_NEW_CHAN_W_0	2
-#define DC_EVT_NEW_CHAN_W_1	3
-#define DC_EVT_NEW_DATA_W_0	4
-#define DC_EVT_NEW_DATA_W_1	5
-#define DC_EVT_NEW_ADDR_R_0	6
-#define DC_EVT_NEW_ADDR_R_1	7
-#define DC_EVT_NEW_CHAN_R_0	8
-#define DC_EVT_NEW_CHAN_R_1	9
-#define DC_EVT_NEW_DATA_R_0	10
-#define DC_EVT_NEW_DATA_R_1	11
-
-#define DC_WR_CH_CONF		0x0
-#define DC_WR_CH_ADDR		0x4
-#define DC_RL_CH(evt)		(8 + ((evt) & ~0x1) * 2)
-
-#define DC_GEN			0xd4
-#define DC_DISP_CONF1(disp)	(0xd8 + (disp) * 4)
-#define DC_DISP_CONF2(disp)	(0xe8 + (disp) * 4)
-#define DC_STAT			0x1c8
-
-#define WROD(lf)		(0x18 | ((lf) << 1))
-#define WRG			0x01
-#define WCLK			0xc9
-
-#define SYNC_WAVE 0
-#define NULL_WAVE (-1)
-
-#define DC_GEN_SYNC_1_6_SYNC	(2 << 1)
-#define DC_GEN_SYNC_PRIORITY_1	(1 << 7)
-
-#define DC_WR_CH_CONF_WORD_SIZE_8		(0 << 0)
-#define DC_WR_CH_CONF_WORD_SIZE_16		(1 << 0)
-#define DC_WR_CH_CONF_WORD_SIZE_24		(2 << 0)
-#define DC_WR_CH_CONF_WORD_SIZE_32		(3 << 0)
-#define DC_WR_CH_CONF_DISP_ID_PARALLEL(i)	(((i) & 0x1) << 3)
-#define DC_WR_CH_CONF_DISP_ID_SERIAL		(2 << 3)
-#define DC_WR_CH_CONF_DISP_ID_ASYNC		(3 << 4)
-#define DC_WR_CH_CONF_FIELD_MODE		(1 << 9)
-#define DC_WR_CH_CONF_PROG_TYPE_NORMAL		(4 << 5)
-#define DC_WR_CH_CONF_PROG_TYPE_MASK		(7 << 5)
-#define DC_WR_CH_CONF_PROG_DI_ID		(1 << 2)
-#define DC_WR_CH_CONF_PROG_DISP_ID(i)		(((i) & 0x1) << 3)
-
-#define IPU_DC_NUM_CHANNELS	10
-
-struct ipu_dc_priv;
-
-enum ipu_dc_map {
-	IPU_DC_MAP_RGB24,
-	IPU_DC_MAP_RGB565,
-	IPU_DC_MAP_GBR24, /* TVEv2 */
-	IPU_DC_MAP_BGR666,
-	IPU_DC_MAP_LVDS666,
-	IPU_DC_MAP_BGR24,
-};
-
-struct ipu_dc {
-	/* The display interface number assigned to this dc channel */
-	unsigned int		di;
-	void __iomem		*base;
-	struct ipu_dc_priv	*priv;
-	int			chno;
-	bool			in_use;
-};
-
-struct ipu_dc_priv {
-	void __iomem		*dc_reg;
-	void __iomem		*dc_tmpl_reg;
-	struct ipu_soc		*ipu;
-	struct device		*dev;
-	struct ipu_dc		channels[IPU_DC_NUM_CHANNELS];
-	struct mutex		mutex;
-	struct completion	comp;
-	int			use_count;
-};
-
-static void dc_link_event(struct ipu_dc *dc, int event, int addr, int priority)
-{
-	u32 reg;
-
-	reg = readl(dc->base + DC_RL_CH(event));
-	reg &= ~(0xffff << (16 * (event & 0x1)));
-	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
-	writel(reg, dc->base + DC_RL_CH(event));
-}
-
-static void dc_write_tmpl(struct ipu_dc *dc, int word, u32 opcode, u32 operand,
-		int map, int wave, int glue, int sync, int stop)
-{
-	struct ipu_dc_priv *priv = dc->priv;
-	u32 reg1, reg2;
-
-	if (opcode == WCLK) {
-		reg1 = (operand << 20) & 0xfff00000;
-		reg2 = operand >> 12 | opcode << 1 | stop << 9;
-	} else if (opcode == WRG) {
-		reg1 = sync | glue << 4 | ++wave << 11 | ((operand << 15) & 0xffff8000);
-		reg2 = operand >> 17 | opcode << 7 | stop << 9;
-	} else {
-		reg1 = sync | glue << 4 | ++wave << 11 | ++map << 15 | ((operand << 20) & 0xfff00000);
-		reg2 = operand >> 12 | opcode << 4 | stop << 9;
-	}
-	writel(reg1, priv->dc_tmpl_reg + word * 8);
-	writel(reg2, priv->dc_tmpl_reg + word * 8 + 4);
-}
-
-static int ipu_bus_format_to_map(u32 fmt)
-{
-	switch (fmt) {
-	default:
-		WARN_ON(1);
-		/* fall-through */
-	case MEDIA_BUS_FMT_RGB888_1X24:
-		return IPU_DC_MAP_RGB24;
-	case MEDIA_BUS_FMT_RGB565_1X16:
-		return IPU_DC_MAP_RGB565;
-	case MEDIA_BUS_FMT_GBR888_1X24:
-		return IPU_DC_MAP_GBR24;
-	case MEDIA_BUS_FMT_RGB666_1X18:
-		return IPU_DC_MAP_BGR666;
-	case MEDIA_BUS_FMT_RGB666_1X24_CPADHI:
-		return IPU_DC_MAP_LVDS666;
-	case MEDIA_BUS_FMT_BGR888_1X24:
-		return IPU_DC_MAP_BGR24;
-	}
-}
-
-int ipu_dc_init_sync(struct ipu_dc *dc, struct ipu_di *di, bool interlaced,
-		u32 bus_format, u32 width)
-{
-	struct ipu_dc_priv *priv = dc->priv;
-	int addr, sync;
-	u32 reg = 0;
-	int map;
-
-	dc->di = ipu_di_get_num(di);
-
-	map = ipu_bus_format_to_map(bus_format);
-
-	/*
-	 * In interlaced mode we need more counters to create the asymmetric
-	 * per-field VSYNC signals. The pixel active signal synchronising DC
-	 * to DI moves to signal generator #6 (see ipu-di.c). In progressive
-	 * mode counter #5 is used.
-	 */
-	sync = interlaced ? 6 : 5;
-
-	/* Reserve 5 microcode template words for each DI */
-	if (dc->di)
-		addr = 5;
-	else
-		addr = 0;
-
-	if (interlaced) {
-		dc_link_event(dc, DC_EVT_NL, addr, 3);
-		dc_link_event(dc, DC_EVT_EOL, addr, 2);
-		dc_link_event(dc, DC_EVT_NEW_DATA, addr, 1);
-
-		/* Init template microcode */
-		dc_write_tmpl(dc, addr, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);
-	} else {
-		dc_link_event(dc, DC_EVT_NL, addr + 2, 3);
-		dc_link_event(dc, DC_EVT_EOL, addr + 3, 2);
-		dc_link_event(dc, DC_EVT_NEW_DATA, addr + 1, 1);
-
-		/* Init template microcode */
-		dc_write_tmpl(dc, addr + 2, WROD(0), 0, map, SYNC_WAVE, 8, sync, 1);
-		dc_write_tmpl(dc, addr + 3, WROD(0), 0, map, SYNC_WAVE, 4, sync, 0);
-		dc_write_tmpl(dc, addr + 4, WRG, 0, map, NULL_WAVE, 0, 0, 1);
-		dc_write_tmpl(dc, addr + 1, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);
-	}
-
-	dc_link_event(dc, DC_EVT_NF, 0, 0);
-	dc_link_event(dc, DC_EVT_NFIELD, 0, 0);
-	dc_link_event(dc, DC_EVT_EOF, 0, 0);
-	dc_link_event(dc, DC_EVT_EOFIELD, 0, 0);
-	dc_link_event(dc, DC_EVT_NEW_CHAN, 0, 0);
-	dc_link_event(dc, DC_EVT_NEW_ADDR, 0, 0);
-
-	reg = readl(dc->base + DC_WR_CH_CONF);
-	if (interlaced)
-		reg |= DC_WR_CH_CONF_FIELD_MODE;
-	else
-		reg &= ~DC_WR_CH_CONF_FIELD_MODE;
-	writel(reg, dc->base + DC_WR_CH_CONF);
-
-	writel(0x0, dc->base + DC_WR_CH_ADDR);
-	writel(width, priv->dc_reg + DC_DISP_CONF2(dc->di));
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dc_init_sync);
-
-void ipu_dc_enable(struct ipu_soc *ipu)
-{
-	struct ipu_dc_priv *priv = ipu->dc_priv;
-
-	mutex_lock(&priv->mutex);
-
-	if (!priv->use_count)
-		ipu_module_enable(priv->ipu, IPU_CONF_DC_EN);
-
-	priv->use_count++;
-
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dc_enable);
-
-void ipu_dc_enable_channel(struct ipu_dc *dc)
-{
-	u32 reg;
-
-	reg = readl(dc->base + DC_WR_CH_CONF);
-	reg |= DC_WR_CH_CONF_PROG_TYPE_NORMAL;
-	writel(reg, dc->base + DC_WR_CH_CONF);
-}
-EXPORT_SYMBOL_GPL(ipu_dc_enable_channel);
-
-void ipu_dc_disable_channel(struct ipu_dc *dc)
-{
-	u32 val;
-
-	val = readl(dc->base + DC_WR_CH_CONF);
-	val &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
-	writel(val, dc->base + DC_WR_CH_CONF);
-}
-EXPORT_SYMBOL_GPL(ipu_dc_disable_channel);
-
-void ipu_dc_disable(struct ipu_soc *ipu)
-{
-	struct ipu_dc_priv *priv = ipu->dc_priv;
-
-	mutex_lock(&priv->mutex);
-
-	priv->use_count--;
-	if (!priv->use_count)
-		ipu_module_disable(priv->ipu, IPU_CONF_DC_EN);
-
-	if (priv->use_count < 0)
-		priv->use_count = 0;
-
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dc_disable);
-
-static void ipu_dc_map_config(struct ipu_dc_priv *priv, enum ipu_dc_map map,
-		int byte_num, int offset, int mask)
-{
-	int ptr = map * 3 + byte_num;
-	u32 reg;
-
-	reg = readl(priv->dc_reg + DC_MAP_CONF_VAL(ptr));
-	reg &= ~(0xffff << (16 * (ptr & 0x1)));
-	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
-	writel(reg, priv->dc_reg + DC_MAP_CONF_VAL(ptr));
-
-	reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));
-	reg &= ~(0x1f << ((16 * (map & 0x1)) + (5 * byte_num)));
-	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
-	writel(reg, priv->dc_reg + DC_MAP_CONF_PTR(map));
-}
-
-static void ipu_dc_map_clear(struct ipu_dc_priv *priv, int map)
-{
-	u32 reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));
-
-	writel(reg & ~(0xffff << (16 * (map & 0x1))),
-		     priv->dc_reg + DC_MAP_CONF_PTR(map));
-}
-
-struct ipu_dc *ipu_dc_get(struct ipu_soc *ipu, int channel)
-{
-	struct ipu_dc_priv *priv = ipu->dc_priv;
-	struct ipu_dc *dc;
-
-	if (channel >= IPU_DC_NUM_CHANNELS)
-		return ERR_PTR(-ENODEV);
-
-	dc = &priv->channels[channel];
-
-	mutex_lock(&priv->mutex);
-
-	if (dc->in_use) {
-		mutex_unlock(&priv->mutex);
-		return ERR_PTR(-EBUSY);
-	}
-
-	dc->in_use = true;
-
-	mutex_unlock(&priv->mutex);
-
-	return dc;
-}
-EXPORT_SYMBOL_GPL(ipu_dc_get);
-
-void ipu_dc_put(struct ipu_dc *dc)
-{
-	struct ipu_dc_priv *priv = dc->priv;
-
-	mutex_lock(&priv->mutex);
-	dc->in_use = false;
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dc_put);
-
-int ipu_dc_init(struct ipu_soc *ipu, struct device *dev,
-		unsigned long base, unsigned long template_base)
-{
-	struct ipu_dc_priv *priv;
-	static int channel_offsets[] = { 0, 0x1c, 0x38, 0x54, 0x58, 0x5c,
-		0x78, 0, 0x94, 0xb4};
-	int i;
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	mutex_init(&priv->mutex);
-
-	priv->dev = dev;
-	priv->ipu = ipu;
-	priv->dc_reg = devm_ioremap(dev, base, PAGE_SIZE);
-	priv->dc_tmpl_reg = devm_ioremap(dev, template_base, PAGE_SIZE);
-	if (!priv->dc_reg || !priv->dc_tmpl_reg)
-		return -ENOMEM;
-
-	for (i = 0; i < IPU_DC_NUM_CHANNELS; i++) {
-		priv->channels[i].chno = i;
-		priv->channels[i].priv = priv;
-		priv->channels[i].base = priv->dc_reg + channel_offsets[i];
-	}
-
-	writel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(1) |
-			DC_WR_CH_CONF_PROG_DI_ID,
-			priv->channels[1].base + DC_WR_CH_CONF);
-	writel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(0),
-			priv->channels[5].base + DC_WR_CH_CONF);
-
-	writel(DC_GEN_SYNC_1_6_SYNC | DC_GEN_SYNC_PRIORITY_1,
-		priv->dc_reg + DC_GEN);
-
-	ipu->dc_priv = priv;
-
-	dev_dbg(dev, "DC base: 0x%08lx template base: 0x%08lx\n",
-			base, template_base);
-
-	/* rgb24 */
-	ipu_dc_map_clear(priv, IPU_DC_MAP_RGB24);
-	ipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 0, 7, 0xff); /* blue */
-	ipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 1, 15, 0xff); /* green */
-	ipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 2, 23, 0xff); /* red */
-
-	/* rgb565 */
-	ipu_dc_map_clear(priv, IPU_DC_MAP_RGB565);
-	ipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 0, 4, 0xf8); /* blue */
-	ipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 1, 10, 0xfc); /* green */
-	ipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 2, 15, 0xf8); /* red */
-
-	/* gbr24 */
-	ipu_dc_map_clear(priv, IPU_DC_MAP_GBR24);
-	ipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 2, 15, 0xff); /* green */
-	ipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 1, 7, 0xff); /* blue */
-	ipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 0, 23, 0xff); /* red */
-
-	/* bgr666 */
-	ipu_dc_map_clear(priv, IPU_DC_MAP_BGR666);
-	ipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 0, 5, 0xfc); /* blue */
-	ipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 1, 11, 0xfc); /* green */
-	ipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 2, 17, 0xfc); /* red */
-
-	/* lvds666 */
-	ipu_dc_map_clear(priv, IPU_DC_MAP_LVDS666);
-	ipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 0, 5, 0xfc); /* blue */
-	ipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 1, 13, 0xfc); /* green */
-	ipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 2, 21, 0xfc); /* red */
-
-	/* bgr24 */
-	ipu_dc_map_clear(priv, IPU_DC_MAP_BGR24);
-	ipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 2, 7, 0xff); /* red */
-	ipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 1, 15, 0xff); /* green */
-	ipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 0, 23, 0xff); /* blue */
-
-	return 0;
-}
-
-void ipu_dc_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-di.c b/drivers/gpu/ipu-v3/ipu-di.c
deleted file mode 100644
index d2f1bd9..0000000
--- a/drivers/gpu/ipu-v3/ipu-di.c
+++ /dev/null
@@ -1,754 +0,0 @@
-/*
- * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/export.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
-
-#include <video/imx-ipu-v3.h>
-#include "ipu-prv.h"
-
-struct ipu_di {
-	void __iomem *base;
-	int id;
-	u32 module;
-	struct clk *clk_di;	/* display input clock */
-	struct clk *clk_ipu;	/* IPU bus clock */
-	struct clk *clk_di_pixel; /* resulting pixel clock */
-	bool inuse;
-	struct ipu_soc *ipu;
-};
-
-static DEFINE_MUTEX(di_mutex);
-
-struct di_sync_config {
-	int run_count;
-	int run_src;
-	int offset_count;
-	int offset_src;
-	int repeat_count;
-	int cnt_clr_src;
-	int cnt_polarity_gen_en;
-	int cnt_polarity_clr_src;
-	int cnt_polarity_trigger_src;
-	int cnt_up;
-	int cnt_down;
-};
-
-enum di_pins {
-	DI_PIN11 = 0,
-	DI_PIN12 = 1,
-	DI_PIN13 = 2,
-	DI_PIN14 = 3,
-	DI_PIN15 = 4,
-	DI_PIN16 = 5,
-	DI_PIN17 = 6,
-	DI_PIN_CS = 7,
-
-	DI_PIN_SER_CLK = 0,
-	DI_PIN_SER_RS = 1,
-};
-
-enum di_sync_wave {
-	DI_SYNC_NONE = 0,
-	DI_SYNC_CLK = 1,
-	DI_SYNC_INT_HSYNC = 2,
-	DI_SYNC_HSYNC = 3,
-	DI_SYNC_VSYNC = 4,
-	DI_SYNC_DE = 6,
-
-	DI_SYNC_CNT1 = 2,	/* counter >= 2 only */
-	DI_SYNC_CNT4 = 5,	/* counter >= 5 only */
-	DI_SYNC_CNT5 = 6,	/* counter >= 6 only */
-};
-
-#define SYNC_WAVE 0
-
-#define DI_GENERAL		0x0000
-#define DI_BS_CLKGEN0		0x0004
-#define DI_BS_CLKGEN1		0x0008
-#define DI_SW_GEN0(gen)		(0x000c + 4 * ((gen) - 1))
-#define DI_SW_GEN1(gen)		(0x0030 + 4 * ((gen) - 1))
-#define DI_STP_REP(gen)		(0x0148 + 4 * (((gen) - 1)/2))
-#define DI_SYNC_AS_GEN		0x0054
-#define DI_DW_GEN(gen)		(0x0058 + 4 * (gen))
-#define DI_DW_SET(gen, set)	(0x0088 + 4 * ((gen) + 0xc * (set)))
-#define DI_SER_CONF		0x015c
-#define DI_SSC			0x0160
-#define DI_POL			0x0164
-#define DI_AW0			0x0168
-#define DI_AW1			0x016c
-#define DI_SCR_CONF		0x0170
-#define DI_STAT			0x0174
-
-#define DI_SW_GEN0_RUN_COUNT(x)			((x) << 19)
-#define DI_SW_GEN0_RUN_SRC(x)			((x) << 16)
-#define DI_SW_GEN0_OFFSET_COUNT(x)		((x) << 3)
-#define DI_SW_GEN0_OFFSET_SRC(x)		((x) << 0)
-
-#define DI_SW_GEN1_CNT_POL_GEN_EN(x)		((x) << 29)
-#define DI_SW_GEN1_CNT_CLR_SRC(x)		((x) << 25)
-#define DI_SW_GEN1_CNT_POL_TRIGGER_SRC(x)	((x) << 12)
-#define DI_SW_GEN1_CNT_POL_CLR_SRC(x)		((x) << 9)
-#define DI_SW_GEN1_CNT_DOWN(x)			((x) << 16)
-#define DI_SW_GEN1_CNT_UP(x)			(x)
-#define DI_SW_GEN1_AUTO_RELOAD			(0x10000000)
-
-#define DI_DW_GEN_ACCESS_SIZE_OFFSET		24
-#define DI_DW_GEN_COMPONENT_SIZE_OFFSET		16
-
-#define DI_GEN_POLARITY_1			(1 << 0)
-#define DI_GEN_POLARITY_2			(1 << 1)
-#define DI_GEN_POLARITY_3			(1 << 2)
-#define DI_GEN_POLARITY_4			(1 << 3)
-#define DI_GEN_POLARITY_5			(1 << 4)
-#define DI_GEN_POLARITY_6			(1 << 5)
-#define DI_GEN_POLARITY_7			(1 << 6)
-#define DI_GEN_POLARITY_8			(1 << 7)
-#define DI_GEN_POLARITY_DISP_CLK		(1 << 17)
-#define DI_GEN_DI_CLK_EXT			(1 << 20)
-#define DI_GEN_DI_VSYNC_EXT			(1 << 21)
-
-#define DI_POL_DRDY_DATA_POLARITY		(1 << 7)
-#define DI_POL_DRDY_POLARITY_15			(1 << 4)
-
-#define DI_VSYNC_SEL_OFFSET			13
-
-static inline u32 ipu_di_read(struct ipu_di *di, unsigned offset)
-{
-	return readl(di->base + offset);
-}
-
-static inline void ipu_di_write(struct ipu_di *di, u32 value, unsigned offset)
-{
-	writel(value, di->base + offset);
-}
-
-static void ipu_di_data_wave_config(struct ipu_di *di,
-				     int wave_gen,
-				     int access_size, int component_size)
-{
-	u32 reg;
-	reg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |
-	    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);
-	ipu_di_write(di, reg, DI_DW_GEN(wave_gen));
-}
-
-static void ipu_di_data_pin_config(struct ipu_di *di, int wave_gen, int di_pin,
-		int set, int up, int down)
-{
-	u32 reg;
-
-	reg = ipu_di_read(di, DI_DW_GEN(wave_gen));
-	reg &= ~(0x3 << (di_pin * 2));
-	reg |= set << (di_pin * 2);
-	ipu_di_write(di, reg, DI_DW_GEN(wave_gen));
-
-	ipu_di_write(di, (down << 16) | up, DI_DW_SET(wave_gen, set));
-}
-
-static void ipu_di_sync_config(struct ipu_di *di, struct di_sync_config *config,
-		int start, int count)
-{
-	u32 reg;
-	int i;
-
-	for (i = 0; i < count; i++) {
-		struct di_sync_config *c = &config[i];
-		int wave_gen = start + i + 1;
-
-		if ((c->run_count >= 0x1000) || (c->offset_count >= 0x1000) ||
-				(c->repeat_count >= 0x1000) ||
-				(c->cnt_up >= 0x400) ||
-				(c->cnt_down >= 0x400)) {
-			dev_err(di->ipu->dev, "DI%d counters out of range.\n",
-					di->id);
-			return;
-		}
-
-		reg = DI_SW_GEN0_RUN_COUNT(c->run_count) |
-			DI_SW_GEN0_RUN_SRC(c->run_src) |
-			DI_SW_GEN0_OFFSET_COUNT(c->offset_count) |
-			DI_SW_GEN0_OFFSET_SRC(c->offset_src);
-		ipu_di_write(di, reg, DI_SW_GEN0(wave_gen));
-
-		reg = DI_SW_GEN1_CNT_POL_GEN_EN(c->cnt_polarity_gen_en) |
-			DI_SW_GEN1_CNT_CLR_SRC(c->cnt_clr_src) |
-			DI_SW_GEN1_CNT_POL_TRIGGER_SRC(
-					c->cnt_polarity_trigger_src) |
-			DI_SW_GEN1_CNT_POL_CLR_SRC(c->cnt_polarity_clr_src) |
-			DI_SW_GEN1_CNT_DOWN(c->cnt_down) |
-			DI_SW_GEN1_CNT_UP(c->cnt_up);
-
-		/* Enable auto reload */
-		if (c->repeat_count == 0)
-			reg |= DI_SW_GEN1_AUTO_RELOAD;
-
-		ipu_di_write(di, reg, DI_SW_GEN1(wave_gen));
-
-		reg = ipu_di_read(di, DI_STP_REP(wave_gen));
-		reg &= ~(0xffff << (16 * ((wave_gen - 1) & 0x1)));
-		reg |= c->repeat_count << (16 * ((wave_gen - 1) & 0x1));
-		ipu_di_write(di, reg, DI_STP_REP(wave_gen));
-	}
-}
-
-static void ipu_di_sync_config_interlaced(struct ipu_di *di,
-		struct ipu_di_signal_cfg *sig)
-{
-	u32 h_total = sig->mode.hactive + sig->mode.hsync_len +
-		sig->mode.hback_porch + sig->mode.hfront_porch;
-	u32 v_total = sig->mode.vactive + sig->mode.vsync_len +
-		sig->mode.vback_porch + sig->mode.vfront_porch;
-	struct di_sync_config cfg[] = {
-		{
-			/* 1: internal VSYNC for each frame */
-			.run_count = v_total * 2 - 1,
-			.run_src = 3,			/* == counter 7 */
-		}, {
-			/* PIN2: HSYNC waveform */
-			.run_count = h_total - 1,
-			.run_src = DI_SYNC_CLK,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_CLK,
-			.cnt_down = sig->mode.hsync_len * 2,
-		}, {
-			/* PIN3: VSYNC waveform */
-			.run_count = v_total - 1,
-			.run_src = 4,			/* == counter 7 */
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = 4,	/* == counter 7 */
-			.cnt_down = sig->mode.vsync_len * 2,
-			.cnt_clr_src = DI_SYNC_CNT1,
-		}, {
-			/* 4: Field */
-			.run_count = v_total / 2,
-			.run_src = DI_SYNC_HSYNC,
-			.offset_count = h_total / 2,
-			.offset_src = DI_SYNC_CLK,
-			.repeat_count = 2,
-			.cnt_clr_src = DI_SYNC_CNT1,
-		}, {
-			/* 5: Active lines */
-			.run_src = DI_SYNC_HSYNC,
-			.offset_count = (sig->mode.vsync_len +
-					 sig->mode.vback_porch) / 2,
-			.offset_src = DI_SYNC_HSYNC,
-			.repeat_count = sig->mode.vactive / 2,
-			.cnt_clr_src = DI_SYNC_CNT4,
-		}, {
-			/* 6: Active pixel, referenced by DC */
-			.run_src = DI_SYNC_CLK,
-			.offset_count = sig->mode.hsync_len +
-					sig->mode.hback_porch,
-			.offset_src = DI_SYNC_CLK,
-			.repeat_count = sig->mode.hactive,
-			.cnt_clr_src = DI_SYNC_CNT5,
-		}, {
-			/* 7: Half line HSYNC */
-			.run_count = h_total / 2 - 1,
-			.run_src = DI_SYNC_CLK,
-		}
-	};
-
-	ipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));
-
-	ipu_di_write(di, v_total / 2 - 1, DI_SCR_CONF);
-}
-
-static void ipu_di_sync_config_noninterlaced(struct ipu_di *di,
-		struct ipu_di_signal_cfg *sig, int div)
-{
-	u32 h_total = sig->mode.hactive + sig->mode.hsync_len +
-		sig->mode.hback_porch + sig->mode.hfront_porch;
-	u32 v_total = sig->mode.vactive + sig->mode.vsync_len +
-		sig->mode.vback_porch + sig->mode.vfront_porch;
-	struct di_sync_config cfg[] = {
-		{
-			/* 1: INT_HSYNC */
-			.run_count = h_total - 1,
-			.run_src = DI_SYNC_CLK,
-		} , {
-			/* PIN2: HSYNC */
-			.run_count = h_total - 1,
-			.run_src = DI_SYNC_CLK,
-			.offset_count = div * sig->v_to_h_sync,
-			.offset_src = DI_SYNC_CLK,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_CLK,
-			.cnt_down = sig->mode.hsync_len * 2,
-		} , {
-			/* PIN3: VSYNC */
-			.run_count = v_total - 1,
-			.run_src = DI_SYNC_INT_HSYNC,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
-			.cnt_down = sig->mode.vsync_len * 2,
-		} , {
-			/* 4: Line Active */
-			.run_src = DI_SYNC_HSYNC,
-			.offset_count = sig->mode.vsync_len +
-					sig->mode.vback_porch,
-			.offset_src = DI_SYNC_HSYNC,
-			.repeat_count = sig->mode.vactive,
-			.cnt_clr_src = DI_SYNC_VSYNC,
-		} , {
-			/* 5: Pixel Active, referenced by DC */
-			.run_src = DI_SYNC_CLK,
-			.offset_count = sig->mode.hsync_len +
-					sig->mode.hback_porch,
-			.offset_src = DI_SYNC_CLK,
-			.repeat_count = sig->mode.hactive,
-			.cnt_clr_src = 5, /* Line Active */
-		} , {
-			/* unused */
-		} , {
-			/* unused */
-		} , {
-			/* unused */
-		} , {
-			/* unused */
-		},
-	};
-	/* can't use #7 and #8 for line active and pixel active counters */
-	struct di_sync_config cfg_vga[] = {
-		{
-			/* 1: INT_HSYNC */
-			.run_count = h_total - 1,
-			.run_src = DI_SYNC_CLK,
-		} , {
-			/* 2: VSYNC */
-			.run_count = v_total - 1,
-			.run_src = DI_SYNC_INT_HSYNC,
-		} , {
-			/* 3: Line Active */
-			.run_src = DI_SYNC_INT_HSYNC,
-			.offset_count = sig->mode.vsync_len +
-					sig->mode.vback_porch,
-			.offset_src = DI_SYNC_INT_HSYNC,
-			.repeat_count = sig->mode.vactive,
-			.cnt_clr_src = 3 /* VSYNC */,
-		} , {
-			/* PIN4: HSYNC for VGA via TVEv2 on TQ MBa53 */
-			.run_count = h_total - 1,
-			.run_src = DI_SYNC_CLK,
-			.offset_count = div * sig->v_to_h_sync + 18, /* magic value from Freescale TVE driver */
-			.offset_src = DI_SYNC_CLK,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_CLK,
-			.cnt_down = sig->mode.hsync_len * 2,
-		} , {
-			/* 5: Pixel Active signal to DC */
-			.run_src = DI_SYNC_CLK,
-			.offset_count = sig->mode.hsync_len +
-					sig->mode.hback_porch,
-			.offset_src = DI_SYNC_CLK,
-			.repeat_count = sig->mode.hactive,
-			.cnt_clr_src = 4, /* Line Active */
-		} , {
-			/* PIN6: VSYNC for VGA via TVEv2 on TQ MBa53 */
-			.run_count = v_total - 1,
-			.run_src = DI_SYNC_INT_HSYNC,
-			.offset_count = 1, /* magic value from Freescale TVE driver */
-			.offset_src = DI_SYNC_INT_HSYNC,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
-			.cnt_down = sig->mode.vsync_len * 2,
-		} , {
-			/* PIN4: HSYNC for VGA via TVEv2 on i.MX53-QSB */
-			.run_count = h_total - 1,
-			.run_src = DI_SYNC_CLK,
-			.offset_count = div * sig->v_to_h_sync + 18, /* magic value from Freescale TVE driver */
-			.offset_src = DI_SYNC_CLK,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_CLK,
-			.cnt_down = sig->mode.hsync_len * 2,
-		} , {
-			/* PIN6: VSYNC for VGA via TVEv2 on i.MX53-QSB */
-			.run_count = v_total - 1,
-			.run_src = DI_SYNC_INT_HSYNC,
-			.offset_count = 1, /* magic value from Freescale TVE driver */
-			.offset_src = DI_SYNC_INT_HSYNC,
-			.cnt_polarity_gen_en = 1,
-			.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,
-			.cnt_down = sig->mode.vsync_len * 2,
-		} , {
-			/* unused */
-		},
-	};
-
-	ipu_di_write(di, v_total - 1, DI_SCR_CONF);
-	if (sig->hsync_pin == 2 && sig->vsync_pin == 3)
-		ipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));
-	else
-		ipu_di_sync_config(di, cfg_vga, 0, ARRAY_SIZE(cfg_vga));
-}
-
-static void ipu_di_config_clock(struct ipu_di *di,
-	const struct ipu_di_signal_cfg *sig)
-{
-	struct clk *clk;
-	unsigned clkgen0;
-	uint32_t val;
-
-	if (sig->clkflags & IPU_DI_CLKMODE_EXT) {
-		/*
-		 * CLKMODE_EXT means we must use the DI clock: this is
-		 * needed for things like LVDS which needs to feed the
-		 * DI and LDB with the same pixel clock.
-		 */
-		clk = di->clk_di;
-
-		if (sig->clkflags & IPU_DI_CLKMODE_SYNC) {
-			/*
-			 * CLKMODE_SYNC means that we want the DI to be
-			 * clocked at the same rate as the parent clock.
-			 * This is needed (eg) for LDB which needs to be
-			 * fed with the same pixel clock.  We assume that
-			 * the LDB clock has already been set correctly.
-			 */
-			clkgen0 = 1 << 4;
-		} else {
-			/*
-			 * We can use the divider.  We should really have
-			 * a flag here indicating whether the bridge can
-			 * cope with a fractional divider or not.  For the
-			 * time being, let's go for simplicitly and
-			 * reliability.
-			 */
-			unsigned long in_rate;
-			unsigned div;
-
-			clk_set_rate(clk, sig->mode.pixelclock);
-
-			in_rate = clk_get_rate(clk);
-			div = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);
-			div = clamp(div, 1U, 255U);
-
-			clkgen0 = div << 4;
-		}
-	} else {
-		/*
-		 * For other interfaces, we can arbitarily select between
-		 * the DI specific clock and the internal IPU clock.  See
-		 * DI_GENERAL bit 20.  We select the IPU clock if it can
-		 * give us a clock rate within 1% of the requested frequency,
-		 * otherwise we use the DI clock.
-		 */
-		unsigned long rate, clkrate;
-		unsigned div, error;
-
-		clkrate = clk_get_rate(di->clk_ipu);
-		div = DIV_ROUND_CLOSEST(clkrate, sig->mode.pixelclock);
-		div = clamp(div, 1U, 255U);
-		rate = clkrate / div;
-
-		error = rate / (sig->mode.pixelclock / 1000);
-
-		dev_dbg(di->ipu->dev, "  IPU clock can give %lu with divider %u, error %d.%u%%\n",
-			rate, div, (signed)(error - 1000) / 10, error % 10);
-
-		/* Allow a 1% error */
-		if (error < 1010 && error >= 990) {
-			clk = di->clk_ipu;
-
-			clkgen0 = div << 4;
-		} else {
-			unsigned long in_rate;
-			unsigned div;
-
-			clk = di->clk_di;
-
-			clk_set_rate(clk, sig->mode.pixelclock);
-
-			in_rate = clk_get_rate(clk);
-			div = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);
-			div = clamp(div, 1U, 255U);
-
-			clkgen0 = div << 4;
-		}
-	}
-
-	di->clk_di_pixel = clk;
-
-	/* Set the divider */
-	ipu_di_write(di, clkgen0, DI_BS_CLKGEN0);
-
-	/*
-	 * Set the high/low periods.  Bits 24:16 give us the falling edge,
-	 * and bits 8:0 give the rising edge.  LSB is fraction, and is
-	 * based on the divider above.  We want a 50% duty cycle, so set
-	 * the falling edge to be half the divider.
-	 */
-	ipu_di_write(di, (clkgen0 >> 4) << 16, DI_BS_CLKGEN1);
-
-	/* Finally select the input clock */
-	val = ipu_di_read(di, DI_GENERAL) & ~DI_GEN_DI_CLK_EXT;
-	if (clk == di->clk_di)
-		val |= DI_GEN_DI_CLK_EXT;
-	ipu_di_write(di, val, DI_GENERAL);
-
-	dev_dbg(di->ipu->dev, "Want %luHz IPU %luHz DI %luHz using %s, %luHz\n",
-		sig->mode.pixelclock,
-		clk_get_rate(di->clk_ipu),
-		clk_get_rate(di->clk_di),
-		clk == di->clk_di ? "DI" : "IPU",
-		clk_get_rate(di->clk_di_pixel) / (clkgen0 >> 4));
-}
-
-/*
- * This function is called to adjust a video mode to IPU restrictions.
- * It is meant to be called from drm crtc mode_fixup() methods.
- */
-int ipu_di_adjust_videomode(struct ipu_di *di, struct videomode *mode)
-{
-	u32 diff;
-
-	if (mode->vfront_porch >= 2)
-		return 0;
-
-	diff = 2 - mode->vfront_porch;
-
-	if (mode->vback_porch >= diff) {
-		mode->vfront_porch = 2;
-		mode->vback_porch -= diff;
-	} else if (mode->vsync_len > diff) {
-		mode->vfront_porch = 2;
-		mode->vsync_len = mode->vsync_len - diff;
-	} else {
-		dev_warn(di->ipu->dev, "failed to adjust videomode\n");
-		return -EINVAL;
-	}
-
-	dev_dbg(di->ipu->dev, "videomode adapted for IPU restrictions\n");
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_di_adjust_videomode);
-
-static u32 ipu_di_gen_polarity(int pin)
-{
-	switch (pin) {
-	case 1:
-		return DI_GEN_POLARITY_1;
-	case 2:
-		return DI_GEN_POLARITY_2;
-	case 3:
-		return DI_GEN_POLARITY_3;
-	case 4:
-		return DI_GEN_POLARITY_4;
-	case 5:
-		return DI_GEN_POLARITY_5;
-	case 6:
-		return DI_GEN_POLARITY_6;
-	case 7:
-		return DI_GEN_POLARITY_7;
-	case 8:
-		return DI_GEN_POLARITY_8;
-	}
-	return 0;
-}
-
-int ipu_di_init_sync_panel(struct ipu_di *di, struct ipu_di_signal_cfg *sig)
-{
-	u32 reg;
-	u32 di_gen, vsync_cnt;
-	u32 div;
-
-	dev_dbg(di->ipu->dev, "disp %d: panel size = %d x %d\n",
-		di->id, sig->mode.hactive, sig->mode.vactive);
-
-	dev_dbg(di->ipu->dev, "Clocks: IPU %luHz DI %luHz Needed %luHz\n",
-		clk_get_rate(di->clk_ipu),
-		clk_get_rate(di->clk_di),
-		sig->mode.pixelclock);
-
-	mutex_lock(&di_mutex);
-
-	ipu_di_config_clock(di, sig);
-
-	div = ipu_di_read(di, DI_BS_CLKGEN0) & 0xfff;
-	div = div / 16;		/* Now divider is integer portion */
-
-	/* Setup pixel clock timing */
-	/* Down time is half of period */
-	ipu_di_write(di, (div << 16), DI_BS_CLKGEN1);
-
-	ipu_di_data_wave_config(di, SYNC_WAVE, div - 1, div - 1);
-	ipu_di_data_pin_config(di, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);
-
-	di_gen = ipu_di_read(di, DI_GENERAL) & DI_GEN_DI_CLK_EXT;
-	di_gen |= DI_GEN_DI_VSYNC_EXT;
-
-	if (sig->mode.flags & DISPLAY_FLAGS_INTERLACED) {
-		ipu_di_sync_config_interlaced(di, sig);
-
-		/* set y_sel = 1 */
-		di_gen |= 0x10000000;
-
-		vsync_cnt = 3;
-	} else {
-		ipu_di_sync_config_noninterlaced(di, sig, div);
-
-		vsync_cnt = 3;
-		if (di->id == 1)
-			/*
-			 * TODO: change only for TVEv2, parallel display
-			 * uses pin 2 / 3
-			 */
-			if (!(sig->hsync_pin == 2 && sig->vsync_pin == 3))
-				vsync_cnt = 6;
-	}
-
-	if (sig->mode.flags & DISPLAY_FLAGS_HSYNC_HIGH)
-		di_gen |= ipu_di_gen_polarity(sig->hsync_pin);
-	if (sig->mode.flags & DISPLAY_FLAGS_VSYNC_HIGH)
-		di_gen |= ipu_di_gen_polarity(sig->vsync_pin);
-
-	if (sig->clk_pol)
-		di_gen |= DI_GEN_POLARITY_DISP_CLK;
-
-	ipu_di_write(di, di_gen, DI_GENERAL);
-
-	ipu_di_write(di, (--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,
-		     DI_SYNC_AS_GEN);
-
-	reg = ipu_di_read(di, DI_POL);
-	reg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);
-
-	if (sig->enable_pol)
-		reg |= DI_POL_DRDY_POLARITY_15;
-	if (sig->data_pol)
-		reg |= DI_POL_DRDY_DATA_POLARITY;
-
-	ipu_di_write(di, reg, DI_POL);
-
-	mutex_unlock(&di_mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_di_init_sync_panel);
-
-int ipu_di_enable(struct ipu_di *di)
-{
-	int ret;
-
-	WARN_ON(IS_ERR(di->clk_di_pixel));
-
-	ret = clk_prepare_enable(di->clk_di_pixel);
-	if (ret)
-		return ret;
-
-	ipu_module_enable(di->ipu, di->module);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_di_enable);
-
-int ipu_di_disable(struct ipu_di *di)
-{
-	WARN_ON(IS_ERR(di->clk_di_pixel));
-
-	ipu_module_disable(di->ipu, di->module);
-
-	clk_disable_unprepare(di->clk_di_pixel);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_di_disable);
-
-int ipu_di_get_num(struct ipu_di *di)
-{
-	return di->id;
-}
-EXPORT_SYMBOL_GPL(ipu_di_get_num);
-
-static DEFINE_MUTEX(ipu_di_lock);
-
-struct ipu_di *ipu_di_get(struct ipu_soc *ipu, int disp)
-{
-	struct ipu_di *di;
-
-	if (disp > 1)
-		return ERR_PTR(-EINVAL);
-
-	di = ipu->di_priv[disp];
-
-	mutex_lock(&ipu_di_lock);
-
-	if (di->inuse) {
-		di = ERR_PTR(-EBUSY);
-		goto out;
-	}
-
-	di->inuse = true;
-out:
-	mutex_unlock(&ipu_di_lock);
-
-	return di;
-}
-EXPORT_SYMBOL_GPL(ipu_di_get);
-
-void ipu_di_put(struct ipu_di *di)
-{
-	mutex_lock(&ipu_di_lock);
-
-	di->inuse = false;
-
-	mutex_unlock(&ipu_di_lock);
-}
-EXPORT_SYMBOL_GPL(ipu_di_put);
-
-int ipu_di_init(struct ipu_soc *ipu, struct device *dev, int id,
-		unsigned long base,
-		u32 module, struct clk *clk_ipu)
-{
-	struct ipu_di *di;
-
-	if (id > 1)
-		return -ENODEV;
-
-	di = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);
-	if (!di)
-		return -ENOMEM;
-
-	ipu->di_priv[id] = di;
-
-	di->clk_di = devm_clk_get(dev, id ? "di1" : "di0");
-	if (IS_ERR(di->clk_di))
-		return PTR_ERR(di->clk_di);
-
-	di->module = module;
-	di->id = id;
-	di->clk_ipu = clk_ipu;
-	di->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!di->base)
-		return -ENOMEM;
-
-	ipu_di_write(di, 0x10, DI_BS_CLKGEN0);
-
-	dev_dbg(dev, "DI%d base: 0x%08lx remapped to %p\n",
-			id, base, di->base);
-	di->inuse = false;
-	di->ipu = ipu;
-
-	return 0;
-}
-
-void ipu_di_exit(struct ipu_soc *ipu, int id)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-dmfc.c b/drivers/gpu/ipu-v3/ipu-dmfc.c
deleted file mode 100644
index a40f211..0000000
--- a/drivers/gpu/ipu-v3/ipu-dmfc.c
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/export.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/io.h>
-
-#include <video/imx-ipu-v3.h>
-#include "ipu-prv.h"
-
-#define DMFC_RD_CHAN		0x0000
-#define DMFC_WR_CHAN		0x0004
-#define DMFC_WR_CHAN_DEF	0x0008
-#define DMFC_DP_CHAN		0x000c
-#define DMFC_DP_CHAN_DEF	0x0010
-#define DMFC_GENERAL1		0x0014
-#define DMFC_GENERAL2		0x0018
-#define DMFC_IC_CTRL		0x001c
-#define DMFC_WR_CHAN_ALT	0x0020
-#define DMFC_WR_CHAN_DEF_ALT	0x0024
-#define DMFC_DP_CHAN_ALT	0x0028
-#define DMFC_DP_CHAN_DEF_ALT	0x002c
-#define DMFC_GENERAL1_ALT	0x0030
-#define DMFC_STAT		0x0034
-
-#define DMFC_WR_CHAN_1_28		0
-#define DMFC_WR_CHAN_2_41		8
-#define DMFC_WR_CHAN_1C_42		16
-#define DMFC_WR_CHAN_2C_43		24
-
-#define DMFC_DP_CHAN_5B_23		0
-#define DMFC_DP_CHAN_5F_27		8
-#define DMFC_DP_CHAN_6B_24		16
-#define DMFC_DP_CHAN_6F_29		24
-
-struct dmfc_channel_data {
-	int		ipu_channel;
-	unsigned long	channel_reg;
-	unsigned long	shift;
-	unsigned	eot_shift;
-	unsigned	max_fifo_lines;
-};
-
-static const struct dmfc_channel_data dmfcdata[] = {
-	{
-		.ipu_channel	= IPUV3_CHANNEL_MEM_BG_SYNC,
-		.channel_reg	= DMFC_DP_CHAN,
-		.shift		= DMFC_DP_CHAN_5B_23,
-		.eot_shift	= 20,
-		.max_fifo_lines	= 3,
-	}, {
-		.ipu_channel	= 24,
-		.channel_reg	= DMFC_DP_CHAN,
-		.shift		= DMFC_DP_CHAN_6B_24,
-		.eot_shift	= 22,
-		.max_fifo_lines	= 1,
-	}, {
-		.ipu_channel	= IPUV3_CHANNEL_MEM_FG_SYNC,
-		.channel_reg	= DMFC_DP_CHAN,
-		.shift		= DMFC_DP_CHAN_5F_27,
-		.eot_shift	= 21,
-		.max_fifo_lines	= 2,
-	}, {
-		.ipu_channel	= IPUV3_CHANNEL_MEM_DC_SYNC,
-		.channel_reg	= DMFC_WR_CHAN,
-		.shift		= DMFC_WR_CHAN_1_28,
-		.eot_shift	= 16,
-		.max_fifo_lines	= 2,
-	}, {
-		.ipu_channel	= 29,
-		.channel_reg	= DMFC_DP_CHAN,
-		.shift		= DMFC_DP_CHAN_6F_29,
-		.eot_shift	= 23,
-		.max_fifo_lines	= 1,
-	},
-};
-
-#define DMFC_NUM_CHANNELS	ARRAY_SIZE(dmfcdata)
-
-struct ipu_dmfc_priv;
-
-struct dmfc_channel {
-	unsigned			slots;
-	struct ipu_soc			*ipu;
-	struct ipu_dmfc_priv		*priv;
-	const struct dmfc_channel_data	*data;
-};
-
-struct ipu_dmfc_priv {
-	struct ipu_soc *ipu;
-	struct device *dev;
-	struct dmfc_channel channels[DMFC_NUM_CHANNELS];
-	struct mutex mutex;
-	void __iomem *base;
-	int use_count;
-};
-
-int ipu_dmfc_enable_channel(struct dmfc_channel *dmfc)
-{
-	struct ipu_dmfc_priv *priv = dmfc->priv;
-	mutex_lock(&priv->mutex);
-
-	if (!priv->use_count)
-		ipu_module_enable(priv->ipu, IPU_CONF_DMFC_EN);
-
-	priv->use_count++;
-
-	mutex_unlock(&priv->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dmfc_enable_channel);
-
-void ipu_dmfc_disable_channel(struct dmfc_channel *dmfc)
-{
-	struct ipu_dmfc_priv *priv = dmfc->priv;
-
-	mutex_lock(&priv->mutex);
-
-	priv->use_count--;
-
-	if (!priv->use_count)
-		ipu_module_disable(priv->ipu, IPU_CONF_DMFC_EN);
-
-	if (priv->use_count < 0)
-		priv->use_count = 0;
-
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dmfc_disable_channel);
-
-void ipu_dmfc_config_wait4eot(struct dmfc_channel *dmfc, int width)
-{
-	struct ipu_dmfc_priv *priv = dmfc->priv;
-	u32 dmfc_gen1;
-
-	mutex_lock(&priv->mutex);
-
-	dmfc_gen1 = readl(priv->base + DMFC_GENERAL1);
-
-	if ((dmfc->slots * 64 * 4) / width > dmfc->data->max_fifo_lines)
-		dmfc_gen1 |= 1 << dmfc->data->eot_shift;
-	else
-		dmfc_gen1 &= ~(1 << dmfc->data->eot_shift);
-
-	writel(dmfc_gen1, priv->base + DMFC_GENERAL1);
-
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dmfc_config_wait4eot);
-
-struct dmfc_channel *ipu_dmfc_get(struct ipu_soc *ipu, int ipu_channel)
-{
-	struct ipu_dmfc_priv *priv = ipu->dmfc_priv;
-	int i;
-
-	for (i = 0; i < DMFC_NUM_CHANNELS; i++)
-		if (dmfcdata[i].ipu_channel == ipu_channel)
-			return &priv->channels[i];
-	return ERR_PTR(-ENODEV);
-}
-EXPORT_SYMBOL_GPL(ipu_dmfc_get);
-
-void ipu_dmfc_put(struct dmfc_channel *dmfc)
-{
-}
-EXPORT_SYMBOL_GPL(ipu_dmfc_put);
-
-int ipu_dmfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,
-		struct clk *ipu_clk)
-{
-	struct ipu_dmfc_priv *priv;
-	int i;
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!priv->base)
-		return -ENOMEM;
-
-	priv->dev = dev;
-	priv->ipu = ipu;
-	mutex_init(&priv->mutex);
-
-	ipu->dmfc_priv = priv;
-
-	for (i = 0; i < DMFC_NUM_CHANNELS; i++) {
-		priv->channels[i].priv = priv;
-		priv->channels[i].ipu = ipu;
-		priv->channels[i].data = &dmfcdata[i];
-
-		if (dmfcdata[i].ipu_channel == IPUV3_CHANNEL_MEM_BG_SYNC ||
-		    dmfcdata[i].ipu_channel == IPUV3_CHANNEL_MEM_FG_SYNC ||
-		    dmfcdata[i].ipu_channel == IPUV3_CHANNEL_MEM_DC_SYNC)
-			priv->channels[i].slots = 2;
-	}
-
-	writel(0x00000050, priv->base + DMFC_WR_CHAN);
-	writel(0x00005654, priv->base + DMFC_DP_CHAN);
-	writel(0x202020f6, priv->base + DMFC_WR_CHAN_DEF);
-	writel(0x2020f6f6, priv->base + DMFC_DP_CHAN_DEF);
-	writel(0x00000003, priv->base + DMFC_GENERAL1);
-
-	return 0;
-}
-
-void ipu_dmfc_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-dp.c b/drivers/gpu/ipu-v3/ipu-dp.c
deleted file mode 100644
index 9b2b3fa..0000000
--- a/drivers/gpu/ipu-v3/ipu-dp.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/export.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/io.h>
-#include <linux/err.h>
-
-#include <video/imx-ipu-v3.h>
-#include "ipu-prv.h"
-
-#define DP_SYNC 0
-#define DP_ASYNC0 0x60
-#define DP_ASYNC1 0xBC
-
-#define DP_COM_CONF		0x0
-#define DP_GRAPH_WIND_CTRL	0x0004
-#define DP_FG_POS		0x0008
-#define DP_CSC_A_0		0x0044
-#define DP_CSC_A_1		0x0048
-#define DP_CSC_A_2		0x004C
-#define DP_CSC_A_3		0x0050
-#define DP_CSC_0		0x0054
-#define DP_CSC_1		0x0058
-
-#define DP_COM_CONF_FG_EN		(1 << 0)
-#define DP_COM_CONF_GWSEL		(1 << 1)
-#define DP_COM_CONF_GWAM		(1 << 2)
-#define DP_COM_CONF_GWCKE		(1 << 3)
-#define DP_COM_CONF_CSC_DEF_MASK	(3 << 8)
-#define DP_COM_CONF_CSC_DEF_OFFSET	8
-#define DP_COM_CONF_CSC_DEF_FG		(3 << 8)
-#define DP_COM_CONF_CSC_DEF_BG		(2 << 8)
-#define DP_COM_CONF_CSC_DEF_BOTH	(1 << 8)
-
-#define IPUV3_NUM_FLOWS		3
-
-struct ipu_dp_priv;
-
-struct ipu_dp {
-	u32 flow;
-	bool in_use;
-	bool foreground;
-	enum ipu_color_space in_cs;
-};
-
-struct ipu_flow {
-	struct ipu_dp foreground;
-	struct ipu_dp background;
-	enum ipu_color_space out_cs;
-	void __iomem *base;
-	struct ipu_dp_priv *priv;
-};
-
-struct ipu_dp_priv {
-	struct ipu_soc *ipu;
-	struct device *dev;
-	void __iomem *base;
-	struct ipu_flow flow[IPUV3_NUM_FLOWS];
-	struct mutex mutex;
-	int use_count;
-};
-
-static u32 ipu_dp_flow_base[] = {DP_SYNC, DP_ASYNC0, DP_ASYNC1};
-
-static inline struct ipu_flow *to_flow(struct ipu_dp *dp)
-{
-	if (dp->foreground)
-		return container_of(dp, struct ipu_flow, foreground);
-	else
-		return container_of(dp, struct ipu_flow, background);
-}
-
-int ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable,
-		u8 alpha, bool bg_chan)
-{
-	struct ipu_flow *flow = to_flow(dp);
-	struct ipu_dp_priv *priv = flow->priv;
-	u32 reg;
-
-	mutex_lock(&priv->mutex);
-
-	reg = readl(flow->base + DP_COM_CONF);
-	if (bg_chan)
-		reg &= ~DP_COM_CONF_GWSEL;
-	else
-		reg |= DP_COM_CONF_GWSEL;
-	writel(reg, flow->base + DP_COM_CONF);
-
-	if (enable) {
-		reg = readl(flow->base + DP_GRAPH_WIND_CTRL) & 0x00FFFFFFL;
-		writel(reg | ((u32) alpha << 24),
-			     flow->base + DP_GRAPH_WIND_CTRL);
-
-		reg = readl(flow->base + DP_COM_CONF);
-		writel(reg | DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);
-	} else {
-		reg = readl(flow->base + DP_COM_CONF);
-		writel(reg & ~DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);
-	}
-
-	ipu_srm_dp_update(priv->ipu, true);
-
-	mutex_unlock(&priv->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_set_global_alpha);
-
-int ipu_dp_set_window_pos(struct ipu_dp *dp, u16 x_pos, u16 y_pos)
-{
-	struct ipu_flow *flow = to_flow(dp);
-	struct ipu_dp_priv *priv = flow->priv;
-
-	writel((x_pos << 16) | y_pos, flow->base + DP_FG_POS);
-
-	ipu_srm_dp_update(priv->ipu, true);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_set_window_pos);
-
-static void ipu_dp_csc_init(struct ipu_flow *flow,
-		enum ipu_color_space in,
-		enum ipu_color_space out,
-		u32 place)
-{
-	u32 reg;
-
-	reg = readl(flow->base + DP_COM_CONF);
-	reg &= ~DP_COM_CONF_CSC_DEF_MASK;
-
-	if (in == out) {
-		writel(reg, flow->base + DP_COM_CONF);
-		return;
-	}
-
-	if (in == IPUV3_COLORSPACE_RGB && out == IPUV3_COLORSPACE_YUV) {
-		writel(0x099 | (0x12d << 16), flow->base + DP_CSC_A_0);
-		writel(0x03a | (0x3a9 << 16), flow->base + DP_CSC_A_1);
-		writel(0x356 | (0x100 << 16), flow->base + DP_CSC_A_2);
-		writel(0x100 | (0x329 << 16), flow->base + DP_CSC_A_3);
-		writel(0x3d6 | (0x0000 << 16) | (2 << 30),
-				flow->base + DP_CSC_0);
-		writel(0x200 | (2 << 14) | (0x200 << 16) | (2 << 30),
-				flow->base + DP_CSC_1);
-	} else {
-		writel(0x095 | (0x000 << 16), flow->base + DP_CSC_A_0);
-		writel(0x0cc | (0x095 << 16), flow->base + DP_CSC_A_1);
-		writel(0x3ce | (0x398 << 16), flow->base + DP_CSC_A_2);
-		writel(0x095 | (0x0ff << 16), flow->base + DP_CSC_A_3);
-		writel(0x000 | (0x3e42 << 16) | (1 << 30),
-				flow->base + DP_CSC_0);
-		writel(0x10a | (1 << 14) | (0x3dd6 << 16) | (1 << 30),
-				flow->base + DP_CSC_1);
-	}
-
-	reg |= place;
-
-	writel(reg, flow->base + DP_COM_CONF);
-}
-
-int ipu_dp_setup_channel(struct ipu_dp *dp,
-		enum ipu_color_space in,
-		enum ipu_color_space out)
-{
-	struct ipu_flow *flow = to_flow(dp);
-	struct ipu_dp_priv *priv = flow->priv;
-
-	mutex_lock(&priv->mutex);
-
-	dp->in_cs = in;
-
-	if (!dp->foreground)
-		flow->out_cs = out;
-
-	if (flow->foreground.in_cs == flow->background.in_cs) {
-		/*
-		 * foreground and background are of same colorspace, put
-		 * colorspace converter after combining unit.
-		 */
-		ipu_dp_csc_init(flow, flow->foreground.in_cs, flow->out_cs,
-				DP_COM_CONF_CSC_DEF_BOTH);
-	} else {
-		if (flow->foreground.in_cs == flow->out_cs)
-			/*
-			 * foreground identical to output, apply color
-			 * conversion on background
-			 */
-			ipu_dp_csc_init(flow, flow->background.in_cs,
-					flow->out_cs, DP_COM_CONF_CSC_DEF_BG);
-		else
-			ipu_dp_csc_init(flow, flow->foreground.in_cs,
-					flow->out_cs, DP_COM_CONF_CSC_DEF_FG);
-	}
-
-	ipu_srm_dp_update(priv->ipu, true);
-
-	mutex_unlock(&priv->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_setup_channel);
-
-int ipu_dp_enable(struct ipu_soc *ipu)
-{
-	struct ipu_dp_priv *priv = ipu->dp_priv;
-
-	mutex_lock(&priv->mutex);
-
-	if (!priv->use_count)
-		ipu_module_enable(priv->ipu, IPU_CONF_DP_EN);
-
-	priv->use_count++;
-
-	mutex_unlock(&priv->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_enable);
-
-int ipu_dp_enable_channel(struct ipu_dp *dp)
-{
-	struct ipu_flow *flow = to_flow(dp);
-	struct ipu_dp_priv *priv = flow->priv;
-	u32 reg;
-
-	if (!dp->foreground)
-		return 0;
-
-	mutex_lock(&priv->mutex);
-
-	reg = readl(flow->base + DP_COM_CONF);
-	reg |= DP_COM_CONF_FG_EN;
-	writel(reg, flow->base + DP_COM_CONF);
-
-	ipu_srm_dp_update(priv->ipu, true);
-
-	mutex_unlock(&priv->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_enable_channel);
-
-void ipu_dp_disable_channel(struct ipu_dp *dp, bool sync)
-{
-	struct ipu_flow *flow = to_flow(dp);
-	struct ipu_dp_priv *priv = flow->priv;
-	u32 reg, csc;
-
-	if (!dp->foreground)
-		return;
-
-	mutex_lock(&priv->mutex);
-
-	reg = readl(flow->base + DP_COM_CONF);
-	csc = reg & DP_COM_CONF_CSC_DEF_MASK;
-	if (csc == DP_COM_CONF_CSC_DEF_FG)
-		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
-
-	reg &= ~DP_COM_CONF_FG_EN;
-	writel(reg, flow->base + DP_COM_CONF);
-
-	writel(0, flow->base + DP_FG_POS);
-	ipu_srm_dp_update(priv->ipu, sync);
-
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dp_disable_channel);
-
-void ipu_dp_disable(struct ipu_soc *ipu)
-{
-	struct ipu_dp_priv *priv = ipu->dp_priv;
-
-	mutex_lock(&priv->mutex);
-
-	priv->use_count--;
-
-	if (!priv->use_count)
-		ipu_module_disable(priv->ipu, IPU_CONF_DP_EN);
-
-	if (priv->use_count < 0)
-		priv->use_count = 0;
-
-	mutex_unlock(&priv->mutex);
-}
-EXPORT_SYMBOL_GPL(ipu_dp_disable);
-
-struct ipu_dp *ipu_dp_get(struct ipu_soc *ipu, unsigned int flow)
-{
-	struct ipu_dp_priv *priv = ipu->dp_priv;
-	struct ipu_dp *dp;
-
-	if ((flow >> 1) >= IPUV3_NUM_FLOWS)
-		return ERR_PTR(-EINVAL);
-
-	if (flow & 1)
-		dp = &priv->flow[flow >> 1].foreground;
-	else
-		dp = &priv->flow[flow >> 1].background;
-
-	if (dp->in_use)
-		return ERR_PTR(-EBUSY);
-
-	dp->in_use = true;
-
-	return dp;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_get);
-
-void ipu_dp_put(struct ipu_dp *dp)
-{
-	dp->in_use = false;
-}
-EXPORT_SYMBOL_GPL(ipu_dp_put);
-
-int ipu_dp_init(struct ipu_soc *ipu, struct device *dev, unsigned long base)
-{
-	struct ipu_dp_priv *priv;
-	int i;
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-	priv->dev = dev;
-	priv->ipu = ipu;
-
-	ipu->dp_priv = priv;
-
-	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!priv->base)
-		return -ENOMEM;
-
-	mutex_init(&priv->mutex);
-
-	for (i = 0; i < IPUV3_NUM_FLOWS; i++) {
-		priv->flow[i].foreground.foreground = true;
-		priv->flow[i].base = priv->base + ipu_dp_flow_base[i];
-		priv->flow[i].priv = priv;
-	}
-
-	return 0;
-}
-
-void ipu_dp_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-ic.c b/drivers/gpu/ipu-v3/ipu-ic.c
deleted file mode 100644
index 67cc820..0000000
--- a/drivers/gpu/ipu-v3/ipu-ic.c
+++ /dev/null
@@ -1,801 +0,0 @@
-/*
- * Copyright (C) 2012-2014 Mentor Graphics Inc.
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/spinlock.h>
-#include <linux/bitrev.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <linux/sizes.h>
-#include "ipu-prv.h"
-
-/* IC Register Offsets */
-#define IC_CONF                 0x0000
-#define IC_PRP_ENC_RSC          0x0004
-#define IC_PRP_VF_RSC           0x0008
-#define IC_PP_RSC               0x000C
-#define IC_CMBP_1               0x0010
-#define IC_CMBP_2               0x0014
-#define IC_IDMAC_1              0x0018
-#define IC_IDMAC_2              0x001C
-#define IC_IDMAC_3              0x0020
-#define IC_IDMAC_4              0x0024
-
-/* IC Register Fields */
-#define IC_CONF_PRPENC_EN       (1 << 0)
-#define IC_CONF_PRPENC_CSC1     (1 << 1)
-#define IC_CONF_PRPENC_ROT_EN   (1 << 2)
-#define IC_CONF_PRPVF_EN        (1 << 8)
-#define IC_CONF_PRPVF_CSC1      (1 << 9)
-#define IC_CONF_PRPVF_CSC2      (1 << 10)
-#define IC_CONF_PRPVF_CMB       (1 << 11)
-#define IC_CONF_PRPVF_ROT_EN    (1 << 12)
-#define IC_CONF_PP_EN           (1 << 16)
-#define IC_CONF_PP_CSC1         (1 << 17)
-#define IC_CONF_PP_CSC2         (1 << 18)
-#define IC_CONF_PP_CMB          (1 << 19)
-#define IC_CONF_PP_ROT_EN       (1 << 20)
-#define IC_CONF_IC_GLB_LOC_A    (1 << 28)
-#define IC_CONF_KEY_COLOR_EN    (1 << 29)
-#define IC_CONF_RWS_EN          (1 << 30)
-#define IC_CONF_CSI_MEM_WR_EN   (1 << 31)
-
-#define IC_IDMAC_1_CB0_BURST_16         (1 << 0)
-#define IC_IDMAC_1_CB1_BURST_16         (1 << 1)
-#define IC_IDMAC_1_CB2_BURST_16         (1 << 2)
-#define IC_IDMAC_1_CB3_BURST_16         (1 << 3)
-#define IC_IDMAC_1_CB4_BURST_16         (1 << 4)
-#define IC_IDMAC_1_CB5_BURST_16         (1 << 5)
-#define IC_IDMAC_1_CB6_BURST_16         (1 << 6)
-#define IC_IDMAC_1_CB7_BURST_16         (1 << 7)
-#define IC_IDMAC_1_PRPENC_ROT_MASK      (0x7 << 11)
-#define IC_IDMAC_1_PRPENC_ROT_OFFSET    11
-#define IC_IDMAC_1_PRPVF_ROT_MASK       (0x7 << 14)
-#define IC_IDMAC_1_PRPVF_ROT_OFFSET     14
-#define IC_IDMAC_1_PP_ROT_MASK          (0x7 << 17)
-#define IC_IDMAC_1_PP_ROT_OFFSET        17
-#define IC_IDMAC_1_PP_FLIP_RS           (1 << 22)
-#define IC_IDMAC_1_PRPVF_FLIP_RS        (1 << 21)
-#define IC_IDMAC_1_PRPENC_FLIP_RS       (1 << 20)
-
-#define IC_IDMAC_2_PRPENC_HEIGHT_MASK   (0x3ff << 0)
-#define IC_IDMAC_2_PRPENC_HEIGHT_OFFSET 0
-#define IC_IDMAC_2_PRPVF_HEIGHT_MASK    (0x3ff << 10)
-#define IC_IDMAC_2_PRPVF_HEIGHT_OFFSET  10
-#define IC_IDMAC_2_PP_HEIGHT_MASK       (0x3ff << 20)
-#define IC_IDMAC_2_PP_HEIGHT_OFFSET     20
-
-#define IC_IDMAC_3_PRPENC_WIDTH_MASK    (0x3ff << 0)
-#define IC_IDMAC_3_PRPENC_WIDTH_OFFSET  0
-#define IC_IDMAC_3_PRPVF_WIDTH_MASK     (0x3ff << 10)
-#define IC_IDMAC_3_PRPVF_WIDTH_OFFSET   10
-#define IC_IDMAC_3_PP_WIDTH_MASK        (0x3ff << 20)
-#define IC_IDMAC_3_PP_WIDTH_OFFSET      20
-
-struct ic_task_regoffs {
-	u32 rsc;
-	u32 tpmem_csc[2];
-};
-
-struct ic_task_bitfields {
-	u32 ic_conf_en;
-	u32 ic_conf_rot_en;
-	u32 ic_conf_cmb_en;
-	u32 ic_conf_csc1_en;
-	u32 ic_conf_csc2_en;
-	u32 ic_cmb_galpha_bit;
-};
-
-static const struct ic_task_regoffs ic_task_reg[IC_NUM_TASKS] = {
-	[IC_TASK_ENCODER] = {
-		.rsc = IC_PRP_ENC_RSC,
-		.tpmem_csc = {0x2008, 0},
-	},
-	[IC_TASK_VIEWFINDER] = {
-		.rsc = IC_PRP_VF_RSC,
-		.tpmem_csc = {0x4028, 0x4040},
-	},
-	[IC_TASK_POST_PROCESSOR] = {
-		.rsc = IC_PP_RSC,
-		.tpmem_csc = {0x6060, 0x6078},
-	},
-};
-
-static const struct ic_task_bitfields ic_task_bit[IC_NUM_TASKS] = {
-	[IC_TASK_ENCODER] = {
-		.ic_conf_en = IC_CONF_PRPENC_EN,
-		.ic_conf_rot_en = IC_CONF_PRPENC_ROT_EN,
-		.ic_conf_cmb_en = 0,    /* NA */
-		.ic_conf_csc1_en = IC_CONF_PRPENC_CSC1,
-		.ic_conf_csc2_en = 0,   /* NA */
-		.ic_cmb_galpha_bit = 0, /* NA */
-	},
-	[IC_TASK_VIEWFINDER] = {
-		.ic_conf_en = IC_CONF_PRPVF_EN,
-		.ic_conf_rot_en = IC_CONF_PRPVF_ROT_EN,
-		.ic_conf_cmb_en = IC_CONF_PRPVF_CMB,
-		.ic_conf_csc1_en = IC_CONF_PRPVF_CSC1,
-		.ic_conf_csc2_en = IC_CONF_PRPVF_CSC2,
-		.ic_cmb_galpha_bit = 0,
-	},
-	[IC_TASK_POST_PROCESSOR] = {
-		.ic_conf_en = IC_CONF_PP_EN,
-		.ic_conf_rot_en = IC_CONF_PP_ROT_EN,
-		.ic_conf_cmb_en = IC_CONF_PP_CMB,
-		.ic_conf_csc1_en = IC_CONF_PP_CSC1,
-		.ic_conf_csc2_en = IC_CONF_PP_CSC2,
-		.ic_cmb_galpha_bit = 8,
-	},
-};
-
-struct ipu_ic_priv;
-
-struct ipu_ic {
-	enum ipu_ic_task task;
-	const struct ic_task_regoffs *reg;
-	const struct ic_task_bitfields *bit;
-
-	enum ipu_color_space in_cs, g_in_cs;
-	enum ipu_color_space out_cs;
-	bool graphics;
-	bool rotation;
-	bool in_use;
-
-	struct ipu_ic_priv *priv;
-};
-
-struct ipu_ic_priv {
-	void __iomem *base;
-	void __iomem *tpmem_base;
-	spinlock_t lock;
-	struct ipu_soc *ipu;
-	int use_count;
-	int irt_use_count;
-	struct ipu_ic task[IC_NUM_TASKS];
-};
-
-static inline u32 ipu_ic_read(struct ipu_ic *ic, unsigned offset)
-{
-	return readl(ic->priv->base + offset);
-}
-
-static inline void ipu_ic_write(struct ipu_ic *ic, u32 value, unsigned offset)
-{
-	writel(value, ic->priv->base + offset);
-}
-
-struct ic_csc_params {
-	s16 coeff[3][3];	/* signed 9-bit integer coefficients */
-	s16 offset[3];		/* signed 11+2-bit fixed point offset */
-	u8 scale:2;		/* scale coefficients * 2^(scale-1) */
-	bool sat:1;		/* saturate to (16, 235(Y) / 240(U, V)) */
-};
-
-/*
- * Y = R *  .299 + G *  .587 + B *  .114;
- * U = R * -.169 + G * -.332 + B *  .500 + 128.;
- * V = R *  .500 + G * -.419 + B * -.0813 + 128.;
- */
-static const struct ic_csc_params ic_csc_rgb2ycbcr = {
-	.coeff = {
-		{ 77, 150, 29 },
-		{ 469, 427, 128 },
-		{ 128, 405, 491 },
-	},
-	.offset = { 0, 512, 512 },
-	.scale = 1,
-};
-
-/* transparent RGB->RGB matrix for graphics combining */
-static const struct ic_csc_params ic_csc_rgb2rgb = {
-	.coeff = {
-		{ 128, 0, 0 },
-		{ 0, 128, 0 },
-		{ 0, 0, 128 },
-	},
-	.scale = 2,
-};
-
-/*
- * R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
- * G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
- * B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128);
- */
-static const struct ic_csc_params ic_csc_ycbcr2rgb = {
-	.coeff = {
-		{ 149, 0, 204 },
-		{ 149, 462, 408 },
-		{ 149, 255, 0 },
-	},
-	.offset = { -446, 266, -554 },
-	.scale = 2,
-};
-
-static int init_csc(struct ipu_ic *ic,
-		    enum ipu_color_space inf,
-		    enum ipu_color_space outf,
-		    int csc_index)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	const struct ic_csc_params *params;
-	u32 __iomem *base;
-	const u16 (*c)[3];
-	const u16 *a;
-	u32 param;
-
-	base = (u32 __iomem *)
-		(priv->tpmem_base + ic->reg->tpmem_csc[csc_index]);
-
-	if (inf == IPUV3_COLORSPACE_YUV && outf == IPUV3_COLORSPACE_RGB)
-		params = &ic_csc_ycbcr2rgb;
-	else if (inf == IPUV3_COLORSPACE_RGB && outf == IPUV3_COLORSPACE_YUV)
-		params = &ic_csc_rgb2ycbcr;
-	else if (inf == IPUV3_COLORSPACE_RGB && outf == IPUV3_COLORSPACE_RGB)
-		params = &ic_csc_rgb2rgb;
-	else {
-		dev_err(priv->ipu->dev, "Unsupported color space conversion\n");
-		return -EINVAL;
-	}
-
-	/* Cast to unsigned */
-	c = (const u16 (*)[3])params->coeff;
-	a = (const u16 *)params->offset;
-
-	param = ((a[0] & 0x1f) << 27) | ((c[0][0] & 0x1ff) << 18) |
-		((c[1][1] & 0x1ff) << 9) | (c[2][2] & 0x1ff);
-	writel(param, base++);
-
-	param = ((a[0] & 0x1fe0) >> 5) | (params->scale << 8) |
-		(params->sat << 9);
-	writel(param, base++);
-
-	param = ((a[1] & 0x1f) << 27) | ((c[0][1] & 0x1ff) << 18) |
-		((c[1][0] & 0x1ff) << 9) | (c[2][0] & 0x1ff);
-	writel(param, base++);
-
-	param = ((a[1] & 0x1fe0) >> 5);
-	writel(param, base++);
-
-	param = ((a[2] & 0x1f) << 27) | ((c[0][2] & 0x1ff) << 18) |
-		((c[1][2] & 0x1ff) << 9) | (c[2][1] & 0x1ff);
-	writel(param, base++);
-
-	param = ((a[2] & 0x1fe0) >> 5);
-	writel(param, base++);
-
-	return 0;
-}
-
-static int calc_resize_coeffs(struct ipu_ic *ic,
-			      u32 in_size, u32 out_size,
-			      u32 *resize_coeff,
-			      u32 *downsize_coeff)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	struct ipu_soc *ipu = priv->ipu;
-	u32 temp_size, temp_downsize;
-
-	/*
-	 * Input size cannot be more than 4096, and output size cannot
-	 * be more than 1024
-	 */
-	if (in_size > 4096) {
-		dev_err(ipu->dev, "Unsupported resize (in_size > 4096)\n");
-		return -EINVAL;
-	}
-	if (out_size > 1024) {
-		dev_err(ipu->dev, "Unsupported resize (out_size > 1024)\n");
-		return -EINVAL;
-	}
-
-	/* Cannot downsize more than 4:1 */
-	if ((out_size << 2) < in_size) {
-		dev_err(ipu->dev, "Unsupported downsize\n");
-		return -EINVAL;
-	}
-
-	/* Compute downsizing coefficient */
-	temp_downsize = 0;
-	temp_size = in_size;
-	while (((temp_size > 1024) || (temp_size >= out_size * 2)) &&
-	       (temp_downsize < 2)) {
-		temp_size >>= 1;
-		temp_downsize++;
-	}
-	*downsize_coeff = temp_downsize;
-
-	/*
-	 * compute resizing coefficient using the following equation:
-	 * resize_coeff = M * (SI - 1) / (SO - 1)
-	 * where M = 2^13, SI = input size, SO = output size
-	 */
-	*resize_coeff = (8192L * (temp_size - 1)) / (out_size - 1);
-	if (*resize_coeff >= 16384L) {
-		dev_err(ipu->dev, "Warning! Overflow on resize coeff.\n");
-		*resize_coeff = 0x3FFF;
-	}
-
-	return 0;
-}
-
-void ipu_ic_task_enable(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	unsigned long flags;
-	u32 ic_conf;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	ic_conf = ipu_ic_read(ic, IC_CONF);
-
-	ic_conf |= ic->bit->ic_conf_en;
-
-	if (ic->rotation)
-		ic_conf |= ic->bit->ic_conf_rot_en;
-
-	if (ic->in_cs != ic->out_cs)
-		ic_conf |= ic->bit->ic_conf_csc1_en;
-
-	if (ic->graphics) {
-		ic_conf |= ic->bit->ic_conf_cmb_en;
-		ic_conf |= ic->bit->ic_conf_csc1_en;
-
-		if (ic->g_in_cs != ic->out_cs)
-			ic_conf |= ic->bit->ic_conf_csc2_en;
-	}
-
-	ipu_ic_write(ic, ic_conf, IC_CONF);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_ic_task_enable);
-
-void ipu_ic_task_disable(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	unsigned long flags;
-	u32 ic_conf;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	ic_conf = ipu_ic_read(ic, IC_CONF);
-
-	ic_conf &= ~(ic->bit->ic_conf_en |
-		     ic->bit->ic_conf_csc1_en |
-		     ic->bit->ic_conf_rot_en);
-	if (ic->bit->ic_conf_csc2_en)
-		ic_conf &= ~ic->bit->ic_conf_csc2_en;
-	if (ic->bit->ic_conf_cmb_en)
-		ic_conf &= ~ic->bit->ic_conf_cmb_en;
-
-	ipu_ic_write(ic, ic_conf, IC_CONF);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_ic_task_disable);
-
-int ipu_ic_task_graphics_init(struct ipu_ic *ic,
-			      enum ipu_color_space in_g_cs,
-			      bool galpha_en, u32 galpha,
-			      bool colorkey_en, u32 colorkey)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	unsigned long flags;
-	u32 reg, ic_conf;
-	int ret = 0;
-
-	if (ic->task == IC_TASK_ENCODER)
-		return -EINVAL;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	ic_conf = ipu_ic_read(ic, IC_CONF);
-
-	if (!(ic_conf & ic->bit->ic_conf_csc1_en)) {
-		/* need transparent CSC1 conversion */
-		ret = init_csc(ic, IPUV3_COLORSPACE_RGB,
-			       IPUV3_COLORSPACE_RGB, 0);
-		if (ret)
-			goto unlock;
-	}
-
-	ic->g_in_cs = in_g_cs;
-
-	if (ic->g_in_cs != ic->out_cs) {
-		ret = init_csc(ic, ic->g_in_cs, ic->out_cs, 1);
-		if (ret)
-			goto unlock;
-	}
-
-	if (galpha_en) {
-		ic_conf |= IC_CONF_IC_GLB_LOC_A;
-		reg = ipu_ic_read(ic, IC_CMBP_1);
-		reg &= ~(0xff << ic->bit->ic_cmb_galpha_bit);
-		reg |= (galpha << ic->bit->ic_cmb_galpha_bit);
-		ipu_ic_write(ic, reg, IC_CMBP_1);
-	} else
-		ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
-
-	if (colorkey_en) {
-		ic_conf |= IC_CONF_KEY_COLOR_EN;
-		ipu_ic_write(ic, colorkey, IC_CMBP_2);
-	} else
-		ic_conf &= ~IC_CONF_KEY_COLOR_EN;
-
-	ipu_ic_write(ic, ic_conf, IC_CONF);
-
-	ic->graphics = true;
-unlock:
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_ic_task_graphics_init);
-
-int ipu_ic_task_init(struct ipu_ic *ic,
-		     int in_width, int in_height,
-		     int out_width, int out_height,
-		     enum ipu_color_space in_cs,
-		     enum ipu_color_space out_cs)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	u32 reg, downsize_coeff, resize_coeff;
-	unsigned long flags;
-	int ret = 0;
-
-	/* Setup vertical resizing */
-	ret = calc_resize_coeffs(ic, in_height, out_height,
-				 &resize_coeff, &downsize_coeff);
-	if (ret)
-		return ret;
-
-	reg = (downsize_coeff << 30) | (resize_coeff << 16);
-
-	/* Setup horizontal resizing */
-	ret = calc_resize_coeffs(ic, in_width, out_width,
-				 &resize_coeff, &downsize_coeff);
-	if (ret)
-		return ret;
-
-	reg |= (downsize_coeff << 14) | resize_coeff;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	ipu_ic_write(ic, reg, ic->reg->rsc);
-
-	/* Setup color space conversion */
-	ic->in_cs = in_cs;
-	ic->out_cs = out_cs;
-
-	if (ic->in_cs != ic->out_cs) {
-		ret = init_csc(ic, ic->in_cs, ic->out_cs, 0);
-		if (ret)
-			goto unlock;
-	}
-
-unlock:
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_ic_task_init);
-
-int ipu_ic_task_idma_init(struct ipu_ic *ic, struct ipuv3_channel *channel,
-			  u32 width, u32 height, int burst_size,
-			  enum ipu_rotate_mode rot)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	struct ipu_soc *ipu = priv->ipu;
-	u32 ic_idmac_1, ic_idmac_2, ic_idmac_3;
-	u32 temp_rot = bitrev8(rot) >> 5;
-	bool need_hor_flip = false;
-	unsigned long flags;
-	int ret = 0;
-
-	if ((burst_size != 8) && (burst_size != 16)) {
-		dev_err(ipu->dev, "Illegal burst length for IC\n");
-		return -EINVAL;
-	}
-
-	width--;
-	height--;
-
-	if (temp_rot & 0x2)	/* Need horizontal flip */
-		need_hor_flip = true;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	ic_idmac_1 = ipu_ic_read(ic, IC_IDMAC_1);
-	ic_idmac_2 = ipu_ic_read(ic, IC_IDMAC_2);
-	ic_idmac_3 = ipu_ic_read(ic, IC_IDMAC_3);
-
-	switch (channel->num) {
-	case IPUV3_CHANNEL_IC_PP_MEM:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;
-
-		if (need_hor_flip)
-			ic_idmac_1 |= IC_IDMAC_1_PP_FLIP_RS;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_PP_FLIP_RS;
-
-		ic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;
-		ic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;
-
-		ic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;
-		ic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;
-		break;
-	case IPUV3_CHANNEL_MEM_IC_PP:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;
-		break;
-	case IPUV3_CHANNEL_MEM_ROT_PP:
-		ic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;
-		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;
-		break;
-	case IPUV3_CHANNEL_MEM_IC_PRP_VF:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB6_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB6_BURST_16;
-		break;
-	case IPUV3_CHANNEL_IC_PRP_ENC_MEM:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB0_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB0_BURST_16;
-
-		if (need_hor_flip)
-			ic_idmac_1 |= IC_IDMAC_1_PRPENC_FLIP_RS;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_FLIP_RS;
-
-		ic_idmac_2 &= ~IC_IDMAC_2_PRPENC_HEIGHT_MASK;
-		ic_idmac_2 |= height << IC_IDMAC_2_PRPENC_HEIGHT_OFFSET;
-
-		ic_idmac_3 &= ~IC_IDMAC_3_PRPENC_WIDTH_MASK;
-		ic_idmac_3 |= width << IC_IDMAC_3_PRPENC_WIDTH_OFFSET;
-		break;
-	case IPUV3_CHANNEL_MEM_ROT_ENC:
-		ic_idmac_1 &= ~IC_IDMAC_1_PRPENC_ROT_MASK;
-		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPENC_ROT_OFFSET;
-		break;
-	case IPUV3_CHANNEL_IC_PRP_VF_MEM:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB1_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB1_BURST_16;
-
-		if (need_hor_flip)
-			ic_idmac_1 |= IC_IDMAC_1_PRPVF_FLIP_RS;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_FLIP_RS;
-
-		ic_idmac_2 &= ~IC_IDMAC_2_PRPVF_HEIGHT_MASK;
-		ic_idmac_2 |= height << IC_IDMAC_2_PRPVF_HEIGHT_OFFSET;
-
-		ic_idmac_3 &= ~IC_IDMAC_3_PRPVF_WIDTH_MASK;
-		ic_idmac_3 |= width << IC_IDMAC_3_PRPVF_WIDTH_OFFSET;
-		break;
-	case IPUV3_CHANNEL_MEM_ROT_VF:
-		ic_idmac_1 &= ~IC_IDMAC_1_PRPVF_ROT_MASK;
-		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPVF_ROT_OFFSET;
-		break;
-	case IPUV3_CHANNEL_G_MEM_IC_PRP_VF:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB3_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB3_BURST_16;
-		break;
-	case IPUV3_CHANNEL_G_MEM_IC_PP:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB4_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB4_BURST_16;
-		break;
-	case IPUV3_CHANNEL_VDI_MEM_IC_VF:
-		if (burst_size == 16)
-			ic_idmac_1 |= IC_IDMAC_1_CB7_BURST_16;
-		else
-			ic_idmac_1 &= ~IC_IDMAC_1_CB7_BURST_16;
-		break;
-	default:
-		goto unlock;
-	}
-
-	ipu_ic_write(ic, ic_idmac_1, IC_IDMAC_1);
-	ipu_ic_write(ic, ic_idmac_2, IC_IDMAC_2);
-	ipu_ic_write(ic, ic_idmac_3, IC_IDMAC_3);
-
-	if (ipu_rot_mode_is_irt(rot))
-		ic->rotation = true;
-
-unlock:
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_ic_task_idma_init);
-
-static void ipu_irt_enable(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-
-	if (!priv->irt_use_count)
-		ipu_module_enable(priv->ipu, IPU_CONF_ROT_EN);
-
-	priv->irt_use_count++;
-}
-
-static void ipu_irt_disable(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-
-	if (priv->irt_use_count) {
-		if (!--priv->irt_use_count)
-			ipu_module_disable(priv->ipu, IPU_CONF_ROT_EN);
-	}
-}
-
-int ipu_ic_enable(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (!priv->use_count)
-		ipu_module_enable(priv->ipu, IPU_CONF_IC_EN);
-
-	priv->use_count++;
-
-	if (ic->rotation)
-		ipu_irt_enable(ic);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_ic_enable);
-
-int ipu_ic_disable(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	priv->use_count--;
-
-	if (!priv->use_count)
-		ipu_module_disable(priv->ipu, IPU_CONF_IC_EN);
-
-	if (priv->use_count < 0)
-		priv->use_count = 0;
-
-	if (ic->rotation)
-		ipu_irt_disable(ic);
-
-	ic->rotation = ic->graphics = false;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_ic_disable);
-
-struct ipu_ic *ipu_ic_get(struct ipu_soc *ipu, enum ipu_ic_task task)
-{
-	struct ipu_ic_priv *priv = ipu->ic_priv;
-	unsigned long flags;
-	struct ipu_ic *ic, *ret;
-
-	if (task >= IC_NUM_TASKS)
-		return ERR_PTR(-EINVAL);
-
-	ic = &priv->task[task];
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (ic->in_use) {
-		ret = ERR_PTR(-EBUSY);
-		goto unlock;
-	}
-
-	ic->in_use = true;
-	ret = ic;
-
-unlock:
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_ic_get);
-
-void ipu_ic_put(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	ic->in_use = false;
-	spin_unlock_irqrestore(&priv->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_ic_put);
-
-int ipu_ic_init(struct ipu_soc *ipu, struct device *dev,
-		unsigned long base, unsigned long tpmem_base)
-{
-	struct ipu_ic_priv *priv;
-	int i;
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	ipu->ic_priv = priv;
-
-	spin_lock_init(&priv->lock);
-	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!priv->base)
-		return -ENOMEM;
-	priv->tpmem_base = devm_ioremap(dev, tpmem_base, SZ_64K);
-	if (!priv->tpmem_base)
-		return -ENOMEM;
-
-	dev_dbg(dev, "IC base: 0x%08lx remapped to %p\n", base, priv->base);
-
-	priv->ipu = ipu;
-
-	for (i = 0; i < IC_NUM_TASKS; i++) {
-		priv->task[i].task = i;
-		priv->task[i].priv = priv;
-		priv->task[i].reg = &ic_task_reg[i];
-		priv->task[i].bit = &ic_task_bit[i];
-	}
-
-	return 0;
-}
-
-void ipu_ic_exit(struct ipu_soc *ipu)
-{
-}
-
-void ipu_ic_dump(struct ipu_ic *ic)
-{
-	struct ipu_ic_priv *priv = ic->priv;
-	struct ipu_soc *ipu = priv->ipu;
-
-	dev_dbg(ipu->dev, "IC_CONF = \t0x%08X\n",
-		ipu_ic_read(ic, IC_CONF));
-	dev_dbg(ipu->dev, "IC_PRP_ENC_RSC = \t0x%08X\n",
-		ipu_ic_read(ic, IC_PRP_ENC_RSC));
-	dev_dbg(ipu->dev, "IC_PRP_VF_RSC = \t0x%08X\n",
-		ipu_ic_read(ic, IC_PRP_VF_RSC));
-	dev_dbg(ipu->dev, "IC_PP_RSC = \t0x%08X\n",
-		ipu_ic_read(ic, IC_PP_RSC));
-	dev_dbg(ipu->dev, "IC_CMBP_1 = \t0x%08X\n",
-		ipu_ic_read(ic, IC_CMBP_1));
-	dev_dbg(ipu->dev, "IC_CMBP_2 = \t0x%08X\n",
-		ipu_ic_read(ic, IC_CMBP_2));
-	dev_dbg(ipu->dev, "IC_IDMAC_1 = \t0x%08X\n",
-		ipu_ic_read(ic, IC_IDMAC_1));
-	dev_dbg(ipu->dev, "IC_IDMAC_2 = \t0x%08X\n",
-		ipu_ic_read(ic, IC_IDMAC_2));
-	dev_dbg(ipu->dev, "IC_IDMAC_3 = \t0x%08X\n",
-		ipu_ic_read(ic, IC_IDMAC_3));
-	dev_dbg(ipu->dev, "IC_IDMAC_4 = \t0x%08X\n",
-		ipu_ic_read(ic, IC_IDMAC_4));
-}
-EXPORT_SYMBOL_GPL(ipu_ic_dump);
diff --git a/drivers/gpu/ipu-v3/ipu-image-convert.c b/drivers/gpu/ipu-v3/ipu-image-convert.c
deleted file mode 100644
index a5e33d5..0000000
--- a/drivers/gpu/ipu-v3/ipu-image-convert.c
+++ /dev/null
@@ -1,1718 +0,0 @@
-/*
- * Copyright (C) 2012-2016 Mentor Graphics Inc.
- *
- * Queued image conversion support, with tiling and rotation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/interrupt.h>
-#include <linux/dma-mapping.h>
-#include <video/imx-ipu-image-convert.h>
-#include "ipu-prv.h"
-
-/*
- * The IC Resizer has a restriction that the output frame from the
- * resizer must be 1024 or less in both width (pixels) and height
- * (lines).
- *
- * The image converter attempts to split up a conversion when
- * the desired output (converted) frame resolution exceeds the
- * IC resizer limit of 1024 in either dimension.
- *
- * If either dimension of the output frame exceeds the limit, the
- * dimension is split into 1, 2, or 4 equal stripes, for a maximum
- * of 4*4 or 16 tiles. A conversion is then carried out for each
- * tile (but taking care to pass the full frame stride length to
- * the DMA channel's parameter memory!). IDMA double-buffering is used
- * to convert each tile back-to-back when possible (see note below
- * when double_buffering boolean is set).
- *
- * Note that the input frame must be split up into the same number
- * of tiles as the output frame.
- *
- * FIXME: at this point there is no attempt to deal with visible seams
- * at the tile boundaries when upscaling. The seams are caused by a reset
- * of the bilinear upscale interpolation when starting a new tile. The
- * seams are barely visible for small upscale factors, but become
- * increasingly visible as the upscale factor gets larger, since more
- * interpolated pixels get thrown out at the tile boundaries. A possilble
- * fix might be to overlap tiles of different sizes, but this must be done
- * while also maintaining the IDMAC dma buffer address alignment and 8x8 IRT
- * alignment restrictions of each tile.
- */
-
-#define MAX_STRIPES_W    4
-#define MAX_STRIPES_H    4
-#define MAX_TILES (MAX_STRIPES_W * MAX_STRIPES_H)
-
-#define MIN_W     16
-#define MIN_H     8
-#define MAX_W     4096
-#define MAX_H     4096
-
-enum ipu_image_convert_type {
-	IMAGE_CONVERT_IN = 0,
-	IMAGE_CONVERT_OUT,
-};
-
-struct ipu_image_convert_dma_buf {
-	void          *virt;
-	dma_addr_t    phys;
-	unsigned long len;
-};
-
-struct ipu_image_convert_dma_chan {
-	int in;
-	int out;
-	int rot_in;
-	int rot_out;
-	int vdi_in_p;
-	int vdi_in;
-	int vdi_in_n;
-};
-
-/* dimensions of one tile */
-struct ipu_image_tile {
-	u32 width;
-	u32 height;
-	/* size and strides are in bytes */
-	u32 size;
-	u32 stride;
-	u32 rot_stride;
-	/* start Y or packed offset of this tile */
-	u32 offset;
-	/* offset from start to tile in U plane, for planar formats */
-	u32 u_off;
-	/* offset from start to tile in V plane, for planar formats */
-	u32 v_off;
-};
-
-struct ipu_image_convert_image {
-	struct ipu_image base;
-	enum ipu_image_convert_type type;
-
-	const struct ipu_image_pixfmt *fmt;
-	unsigned int stride;
-
-	/* # of rows (horizontal stripes) if dest height is > 1024 */
-	unsigned int num_rows;
-	/* # of columns (vertical stripes) if dest width is > 1024 */
-	unsigned int num_cols;
-
-	struct ipu_image_tile tile[MAX_TILES];
-};
-
-struct ipu_image_pixfmt {
-	u32	fourcc;        /* V4L2 fourcc */
-	int     bpp;           /* total bpp */
-	int     uv_width_dec;  /* decimation in width for U/V planes */
-	int     uv_height_dec; /* decimation in height for U/V planes */
-	bool    planar;        /* planar format */
-	bool    uv_swapped;    /* U and V planes are swapped */
-	bool    uv_packed;     /* partial planar (U and V in same plane) */
-};
-
-struct ipu_image_convert_ctx;
-struct ipu_image_convert_chan;
-struct ipu_image_convert_priv;
-
-struct ipu_image_convert_ctx {
-	struct ipu_image_convert_chan *chan;
-
-	ipu_image_convert_cb_t complete;
-	void *complete_context;
-
-	/* Source/destination image data and rotation mode */
-	struct ipu_image_convert_image in;
-	struct ipu_image_convert_image out;
-	enum ipu_rotate_mode rot_mode;
-
-	/* intermediate buffer for rotation */
-	struct ipu_image_convert_dma_buf rot_intermediate[2];
-
-	/* current buffer number for double buffering */
-	int cur_buf_num;
-
-	bool aborting;
-	struct completion aborted;
-
-	/* can we use double-buffering for this conversion operation? */
-	bool double_buffering;
-	/* num_rows * num_cols */
-	unsigned int num_tiles;
-	/* next tile to process */
-	unsigned int next_tile;
-	/* where to place converted tile in dest image */
-	unsigned int out_tile_map[MAX_TILES];
-
-	struct list_head list;
-};
-
-struct ipu_image_convert_chan {
-	struct ipu_image_convert_priv *priv;
-
-	enum ipu_ic_task ic_task;
-	const struct ipu_image_convert_dma_chan *dma_ch;
-
-	struct ipu_ic *ic;
-	struct ipuv3_channel *in_chan;
-	struct ipuv3_channel *out_chan;
-	struct ipuv3_channel *rotation_in_chan;
-	struct ipuv3_channel *rotation_out_chan;
-
-	/* the IPU end-of-frame irqs */
-	int out_eof_irq;
-	int rot_out_eof_irq;
-
-	spinlock_t irqlock;
-
-	/* list of convert contexts */
-	struct list_head ctx_list;
-	/* queue of conversion runs */
-	struct list_head pending_q;
-	/* queue of completed runs */
-	struct list_head done_q;
-
-	/* the current conversion run */
-	struct ipu_image_convert_run *current_run;
-};
-
-struct ipu_image_convert_priv {
-	struct ipu_image_convert_chan chan[IC_NUM_TASKS];
-	struct ipu_soc *ipu;
-};
-
-static const struct ipu_image_convert_dma_chan
-image_convert_dma_chan[IC_NUM_TASKS] = {
-	[IC_TASK_VIEWFINDER] = {
-		.in = IPUV3_CHANNEL_MEM_IC_PRP_VF,
-		.out = IPUV3_CHANNEL_IC_PRP_VF_MEM,
-		.rot_in = IPUV3_CHANNEL_MEM_ROT_VF,
-		.rot_out = IPUV3_CHANNEL_ROT_VF_MEM,
-		.vdi_in_p = IPUV3_CHANNEL_MEM_VDI_PREV,
-		.vdi_in = IPUV3_CHANNEL_MEM_VDI_CUR,
-		.vdi_in_n = IPUV3_CHANNEL_MEM_VDI_NEXT,
-	},
-	[IC_TASK_POST_PROCESSOR] = {
-		.in = IPUV3_CHANNEL_MEM_IC_PP,
-		.out = IPUV3_CHANNEL_IC_PP_MEM,
-		.rot_in = IPUV3_CHANNEL_MEM_ROT_PP,
-		.rot_out = IPUV3_CHANNEL_ROT_PP_MEM,
-	},
-};
-
-static const struct ipu_image_pixfmt image_convert_formats[] = {
-	{
-		.fourcc	= V4L2_PIX_FMT_RGB565,
-		.bpp    = 16,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_RGB24,
-		.bpp    = 24,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_BGR24,
-		.bpp    = 24,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_RGB32,
-		.bpp    = 32,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_BGR32,
-		.bpp    = 32,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_YUYV,
-		.bpp    = 16,
-		.uv_width_dec = 2,
-		.uv_height_dec = 1,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_UYVY,
-		.bpp    = 16,
-		.uv_width_dec = 2,
-		.uv_height_dec = 1,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_YUV420,
-		.bpp    = 12,
-		.planar = true,
-		.uv_width_dec = 2,
-		.uv_height_dec = 2,
-	}, {
-		.fourcc	= V4L2_PIX_FMT_YVU420,
-		.bpp    = 12,
-		.planar = true,
-		.uv_width_dec = 2,
-		.uv_height_dec = 2,
-		.uv_swapped = true,
-	}, {
-		.fourcc = V4L2_PIX_FMT_NV12,
-		.bpp    = 12,
-		.planar = true,
-		.uv_width_dec = 2,
-		.uv_height_dec = 2,
-		.uv_packed = true,
-	}, {
-		.fourcc = V4L2_PIX_FMT_YUV422P,
-		.bpp    = 16,
-		.planar = true,
-		.uv_width_dec = 2,
-		.uv_height_dec = 1,
-	}, {
-		.fourcc = V4L2_PIX_FMT_NV16,
-		.bpp    = 16,
-		.planar = true,
-		.uv_width_dec = 2,
-		.uv_height_dec = 1,
-		.uv_packed = true,
-	},
-};
-
-static const struct ipu_image_pixfmt *get_format(u32 fourcc)
-{
-	const struct ipu_image_pixfmt *ret = NULL;
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(image_convert_formats); i++) {
-		if (image_convert_formats[i].fourcc == fourcc) {
-			ret = &image_convert_formats[i];
-			break;
-		}
-	}
-
-	return ret;
-}
-
-static void dump_format(struct ipu_image_convert_ctx *ctx,
-			struct ipu_image_convert_image *ic_image)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-
-	dev_dbg(priv->ipu->dev,
-		"task %u: ctx %p: %s format: %dx%d (%dx%d tiles of size %dx%d), %c%c%c%c\n",
-		chan->ic_task, ctx,
-		ic_image->type == IMAGE_CONVERT_OUT ? "Output" : "Input",
-		ic_image->base.pix.width, ic_image->base.pix.height,
-		ic_image->num_cols, ic_image->num_rows,
-		ic_image->tile[0].width, ic_image->tile[0].height,
-		ic_image->fmt->fourcc & 0xff,
-		(ic_image->fmt->fourcc >> 8) & 0xff,
-		(ic_image->fmt->fourcc >> 16) & 0xff,
-		(ic_image->fmt->fourcc >> 24) & 0xff);
-}
-
-int ipu_image_convert_enum_format(int index, u32 *fourcc)
-{
-	const struct ipu_image_pixfmt *fmt;
-
-	if (index >= (int)ARRAY_SIZE(image_convert_formats))
-		return -EINVAL;
-
-	/* Format found */
-	fmt = &image_convert_formats[index];
-	*fourcc = fmt->fourcc;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_enum_format);
-
-static void free_dma_buf(struct ipu_image_convert_priv *priv,
-			 struct ipu_image_convert_dma_buf *buf)
-{
-	if (buf->virt)
-		dma_free_coherent(priv->ipu->dev,
-				  buf->len, buf->virt, buf->phys);
-	buf->virt = NULL;
-	buf->phys = 0;
-}
-
-static int alloc_dma_buf(struct ipu_image_convert_priv *priv,
-			 struct ipu_image_convert_dma_buf *buf,
-			 int size)
-{
-	buf->len = PAGE_ALIGN(size);
-	buf->virt = dma_alloc_coherent(priv->ipu->dev, buf->len, &buf->phys,
-				       GFP_DMA | GFP_KERNEL);
-	if (!buf->virt) {
-		dev_err(priv->ipu->dev, "failed to alloc dma buffer\n");
-		return -ENOMEM;
-	}
-
-	return 0;
-}
-
-static inline int num_stripes(int dim)
-{
-	if (dim <= 1024)
-		return 1;
-	else if (dim <= 2048)
-		return 2;
-	else
-		return 4;
-}
-
-static void calc_tile_dimensions(struct ipu_image_convert_ctx *ctx,
-				 struct ipu_image_convert_image *image)
-{
-	int i;
-
-	for (i = 0; i < ctx->num_tiles; i++) {
-		struct ipu_image_tile *tile = &image->tile[i];
-
-		tile->height = image->base.pix.height / image->num_rows;
-		tile->width = image->base.pix.width / image->num_cols;
-		tile->size = ((tile->height * image->fmt->bpp) >> 3) *
-			tile->width;
-
-		if (image->fmt->planar) {
-			tile->stride = tile->width;
-			tile->rot_stride = tile->height;
-		} else {
-			tile->stride =
-				(image->fmt->bpp * tile->width) >> 3;
-			tile->rot_stride =
-				(image->fmt->bpp * tile->height) >> 3;
-		}
-	}
-}
-
-/*
- * Use the rotation transformation to find the tile coordinates
- * (row, col) of a tile in the destination frame that corresponds
- * to the given tile coordinates of a source frame. The destination
- * coordinate is then converted to a tile index.
- */
-static int transform_tile_index(struct ipu_image_convert_ctx *ctx,
-				int src_row, int src_col)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_image *s_image = &ctx->in;
-	struct ipu_image_convert_image *d_image = &ctx->out;
-	int dst_row, dst_col;
-
-	/* with no rotation it's a 1:1 mapping */
-	if (ctx->rot_mode == IPU_ROTATE_NONE)
-		return src_row * s_image->num_cols + src_col;
-
-	/*
-	 * before doing the transform, first we have to translate
-	 * source row,col for an origin in the center of s_image
-	 */
-	src_row = src_row * 2 - (s_image->num_rows - 1);
-	src_col = src_col * 2 - (s_image->num_cols - 1);
-
-	/* do the rotation transform */
-	if (ctx->rot_mode & IPU_ROT_BIT_90) {
-		dst_col = -src_row;
-		dst_row = src_col;
-	} else {
-		dst_col = src_col;
-		dst_row = src_row;
-	}
-
-	/* apply flip */
-	if (ctx->rot_mode & IPU_ROT_BIT_HFLIP)
-		dst_col = -dst_col;
-	if (ctx->rot_mode & IPU_ROT_BIT_VFLIP)
-		dst_row = -dst_row;
-
-	dev_dbg(priv->ipu->dev, "task %u: ctx %p: [%d,%d] --> [%d,%d]\n",
-		chan->ic_task, ctx, src_col, src_row, dst_col, dst_row);
-
-	/*
-	 * finally translate dest row,col using an origin in upper
-	 * left of d_image
-	 */
-	dst_row += d_image->num_rows - 1;
-	dst_col += d_image->num_cols - 1;
-	dst_row /= 2;
-	dst_col /= 2;
-
-	return dst_row * d_image->num_cols + dst_col;
-}
-
-/*
- * Fill the out_tile_map[] with transformed destination tile indeces.
- */
-static void calc_out_tile_map(struct ipu_image_convert_ctx *ctx)
-{
-	struct ipu_image_convert_image *s_image = &ctx->in;
-	unsigned int row, col, tile = 0;
-
-	for (row = 0; row < s_image->num_rows; row++) {
-		for (col = 0; col < s_image->num_cols; col++) {
-			ctx->out_tile_map[tile] =
-				transform_tile_index(ctx, row, col);
-			tile++;
-		}
-	}
-}
-
-static void calc_tile_offsets_planar(struct ipu_image_convert_ctx *ctx,
-				     struct ipu_image_convert_image *image)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	const struct ipu_image_pixfmt *fmt = image->fmt;
-	unsigned int row, col, tile = 0;
-	u32 H, w, h, y_stride, uv_stride;
-	u32 uv_row_off, uv_col_off, uv_off, u_off, v_off, tmp;
-	u32 y_row_off, y_col_off, y_off;
-	u32 y_size, uv_size;
-
-	/* setup some convenience vars */
-	H = image->base.pix.height;
-
-	y_stride = image->stride;
-	uv_stride = y_stride / fmt->uv_width_dec;
-	if (fmt->uv_packed)
-		uv_stride *= 2;
-
-	y_size = H * y_stride;
-	uv_size = y_size / (fmt->uv_width_dec * fmt->uv_height_dec);
-
-	for (row = 0; row < image->num_rows; row++) {
-		w = image->tile[tile].width;
-		h = image->tile[tile].height;
-		y_row_off = row * h * y_stride;
-		uv_row_off = (row * h * uv_stride) / fmt->uv_height_dec;
-
-		for (col = 0; col < image->num_cols; col++) {
-			y_col_off = col * w;
-			uv_col_off = y_col_off / fmt->uv_width_dec;
-			if (fmt->uv_packed)
-				uv_col_off *= 2;
-
-			y_off = y_row_off + y_col_off;
-			uv_off = uv_row_off + uv_col_off;
-
-			u_off = y_size - y_off + uv_off;
-			v_off = (fmt->uv_packed) ? 0 : u_off + uv_size;
-			if (fmt->uv_swapped) {
-				tmp = u_off;
-				u_off = v_off;
-				v_off = tmp;
-			}
-
-			image->tile[tile].offset = y_off;
-			image->tile[tile].u_off = u_off;
-			image->tile[tile++].v_off = v_off;
-
-			dev_dbg(priv->ipu->dev,
-				"task %u: ctx %p: %s@[%d,%d]: y_off %08x, u_off %08x, v_off %08x\n",
-				chan->ic_task, ctx,
-				image->type == IMAGE_CONVERT_IN ?
-				"Input" : "Output", row, col,
-				y_off, u_off, v_off);
-		}
-	}
-}
-
-static void calc_tile_offsets_packed(struct ipu_image_convert_ctx *ctx,
-				     struct ipu_image_convert_image *image)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	const struct ipu_image_pixfmt *fmt = image->fmt;
-	unsigned int row, col, tile = 0;
-	u32 w, h, bpp, stride;
-	u32 row_off, col_off;
-
-	/* setup some convenience vars */
-	stride = image->stride;
-	bpp = fmt->bpp;
-
-	for (row = 0; row < image->num_rows; row++) {
-		w = image->tile[tile].width;
-		h = image->tile[tile].height;
-		row_off = row * h * stride;
-
-		for (col = 0; col < image->num_cols; col++) {
-			col_off = (col * w * bpp) >> 3;
-
-			image->tile[tile].offset = row_off + col_off;
-			image->tile[tile].u_off = 0;
-			image->tile[tile++].v_off = 0;
-
-			dev_dbg(priv->ipu->dev,
-				"task %u: ctx %p: %s@[%d,%d]: phys %08x\n",
-				chan->ic_task, ctx,
-				image->type == IMAGE_CONVERT_IN ?
-				"Input" : "Output", row, col,
-				row_off + col_off);
-		}
-	}
-}
-
-static void calc_tile_offsets(struct ipu_image_convert_ctx *ctx,
-			      struct ipu_image_convert_image *image)
-{
-	if (image->fmt->planar)
-		calc_tile_offsets_planar(ctx, image);
-	else
-		calc_tile_offsets_packed(ctx, image);
-}
-
-/*
- * return the number of runs in given queue (pending_q or done_q)
- * for this context. hold irqlock when calling.
- */
-static int get_run_count(struct ipu_image_convert_ctx *ctx,
-			 struct list_head *q)
-{
-	struct ipu_image_convert_run *run;
-	int count = 0;
-
-	lockdep_assert_held(&ctx->chan->irqlock);
-
-	list_for_each_entry(run, q, list) {
-		if (run->ctx == ctx)
-			count++;
-	}
-
-	return count;
-}
-
-static void convert_stop(struct ipu_image_convert_run *run)
-{
-	struct ipu_image_convert_ctx *ctx = run->ctx;
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: stopping ctx %p run %p\n",
-		__func__, chan->ic_task, ctx, run);
-
-	/* disable IC tasks and the channels */
-	ipu_ic_task_disable(chan->ic);
-	ipu_idmac_disable_channel(chan->in_chan);
-	ipu_idmac_disable_channel(chan->out_chan);
-
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		ipu_idmac_disable_channel(chan->rotation_in_chan);
-		ipu_idmac_disable_channel(chan->rotation_out_chan);
-		ipu_idmac_unlink(chan->out_chan, chan->rotation_in_chan);
-	}
-
-	ipu_ic_disable(chan->ic);
-}
-
-static void init_idmac_channel(struct ipu_image_convert_ctx *ctx,
-			       struct ipuv3_channel *channel,
-			       struct ipu_image_convert_image *image,
-			       enum ipu_rotate_mode rot_mode,
-			       bool rot_swap_width_height)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	unsigned int burst_size;
-	u32 width, height, stride;
-	dma_addr_t addr0, addr1 = 0;
-	struct ipu_image tile_image;
-	unsigned int tile_idx[2];
-
-	if (image->type == IMAGE_CONVERT_OUT) {
-		tile_idx[0] = ctx->out_tile_map[0];
-		tile_idx[1] = ctx->out_tile_map[1];
-	} else {
-		tile_idx[0] = 0;
-		tile_idx[1] = 1;
-	}
-
-	if (rot_swap_width_height) {
-		width = image->tile[0].height;
-		height = image->tile[0].width;
-		stride = image->tile[0].rot_stride;
-		addr0 = ctx->rot_intermediate[0].phys;
-		if (ctx->double_buffering)
-			addr1 = ctx->rot_intermediate[1].phys;
-	} else {
-		width = image->tile[0].width;
-		height = image->tile[0].height;
-		stride = image->stride;
-		addr0 = image->base.phys0 +
-			image->tile[tile_idx[0]].offset;
-		if (ctx->double_buffering)
-			addr1 = image->base.phys0 +
-				image->tile[tile_idx[1]].offset;
-	}
-
-	ipu_cpmem_zero(channel);
-
-	memset(&tile_image, 0, sizeof(tile_image));
-	tile_image.pix.width = tile_image.rect.width = width;
-	tile_image.pix.height = tile_image.rect.height = height;
-	tile_image.pix.bytesperline = stride;
-	tile_image.pix.pixelformat =  image->fmt->fourcc;
-	tile_image.phys0 = addr0;
-	tile_image.phys1 = addr1;
-	ipu_cpmem_set_image(channel, &tile_image);
-
-	if (image->fmt->planar && !rot_swap_width_height)
-		ipu_cpmem_set_uv_offset(channel,
-					image->tile[tile_idx[0]].u_off,
-					image->tile[tile_idx[0]].v_off);
-
-	if (rot_mode)
-		ipu_cpmem_set_rotation(channel, rot_mode);
-
-	if (channel == chan->rotation_in_chan ||
-	    channel == chan->rotation_out_chan) {
-		burst_size = 8;
-		ipu_cpmem_set_block_mode(channel);
-	} else
-		burst_size = (width % 16) ? 8 : 16;
-
-	ipu_cpmem_set_burstsize(channel, burst_size);
-
-	ipu_ic_task_idma_init(chan->ic, channel, width, height,
-			      burst_size, rot_mode);
-
-	/*
-	 * Setting a non-zero AXI ID collides with the PRG AXI snooping, so
-	 * only do this when there is no PRG present.
-	 */
-	if (!channel->ipu->prg_priv)
-		ipu_cpmem_set_axi_id(channel, 1);
-
-	ipu_idmac_set_double_buffer(channel, ctx->double_buffering);
-}
-
-static int convert_start(struct ipu_image_convert_run *run)
-{
-	struct ipu_image_convert_ctx *ctx = run->ctx;
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_image *s_image = &ctx->in;
-	struct ipu_image_convert_image *d_image = &ctx->out;
-	enum ipu_color_space src_cs, dest_cs;
-	unsigned int dest_width, dest_height;
-	int ret;
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: starting ctx %p run %p\n",
-		__func__, chan->ic_task, ctx, run);
-
-	src_cs = ipu_pixelformat_to_colorspace(s_image->fmt->fourcc);
-	dest_cs = ipu_pixelformat_to_colorspace(d_image->fmt->fourcc);
-
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		/* swap width/height for resizer */
-		dest_width = d_image->tile[0].height;
-		dest_height = d_image->tile[0].width;
-	} else {
-		dest_width = d_image->tile[0].width;
-		dest_height = d_image->tile[0].height;
-	}
-
-	/* setup the IC resizer and CSC */
-	ret = ipu_ic_task_init(chan->ic,
-			       s_image->tile[0].width,
-			       s_image->tile[0].height,
-			       dest_width,
-			       dest_height,
-			       src_cs, dest_cs);
-	if (ret) {
-		dev_err(priv->ipu->dev, "ipu_ic_task_init failed, %d\n", ret);
-		return ret;
-	}
-
-	/* init the source MEM-->IC PP IDMAC channel */
-	init_idmac_channel(ctx, chan->in_chan, s_image,
-			   IPU_ROTATE_NONE, false);
-
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		/* init the IC PP-->MEM IDMAC channel */
-		init_idmac_channel(ctx, chan->out_chan, d_image,
-				   IPU_ROTATE_NONE, true);
-
-		/* init the MEM-->IC PP ROT IDMAC channel */
-		init_idmac_channel(ctx, chan->rotation_in_chan, d_image,
-				   ctx->rot_mode, true);
-
-		/* init the destination IC PP ROT-->MEM IDMAC channel */
-		init_idmac_channel(ctx, chan->rotation_out_chan, d_image,
-				   IPU_ROTATE_NONE, false);
-
-		/* now link IC PP-->MEM to MEM-->IC PP ROT */
-		ipu_idmac_link(chan->out_chan, chan->rotation_in_chan);
-	} else {
-		/* init the destination IC PP-->MEM IDMAC channel */
-		init_idmac_channel(ctx, chan->out_chan, d_image,
-				   ctx->rot_mode, false);
-	}
-
-	/* enable the IC */
-	ipu_ic_enable(chan->ic);
-
-	/* set buffers ready */
-	ipu_idmac_select_buffer(chan->in_chan, 0);
-	ipu_idmac_select_buffer(chan->out_chan, 0);
-	if (ipu_rot_mode_is_irt(ctx->rot_mode))
-		ipu_idmac_select_buffer(chan->rotation_out_chan, 0);
-	if (ctx->double_buffering) {
-		ipu_idmac_select_buffer(chan->in_chan, 1);
-		ipu_idmac_select_buffer(chan->out_chan, 1);
-		if (ipu_rot_mode_is_irt(ctx->rot_mode))
-			ipu_idmac_select_buffer(chan->rotation_out_chan, 1);
-	}
-
-	/* enable the channels! */
-	ipu_idmac_enable_channel(chan->in_chan);
-	ipu_idmac_enable_channel(chan->out_chan);
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		ipu_idmac_enable_channel(chan->rotation_in_chan);
-		ipu_idmac_enable_channel(chan->rotation_out_chan);
-	}
-
-	ipu_ic_task_enable(chan->ic);
-
-	ipu_cpmem_dump(chan->in_chan);
-	ipu_cpmem_dump(chan->out_chan);
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		ipu_cpmem_dump(chan->rotation_in_chan);
-		ipu_cpmem_dump(chan->rotation_out_chan);
-	}
-
-	ipu_dump(priv->ipu);
-
-	return 0;
-}
-
-/* hold irqlock when calling */
-static int do_run(struct ipu_image_convert_run *run)
-{
-	struct ipu_image_convert_ctx *ctx = run->ctx;
-	struct ipu_image_convert_chan *chan = ctx->chan;
-
-	lockdep_assert_held(&chan->irqlock);
-
-	ctx->in.base.phys0 = run->in_phys;
-	ctx->out.base.phys0 = run->out_phys;
-
-	ctx->cur_buf_num = 0;
-	ctx->next_tile = 1;
-
-	/* remove run from pending_q and set as current */
-	list_del(&run->list);
-	chan->current_run = run;
-
-	return convert_start(run);
-}
-
-/* hold irqlock when calling */
-static void run_next(struct ipu_image_convert_chan *chan)
-{
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_run *run, *tmp;
-	int ret;
-
-	lockdep_assert_held(&chan->irqlock);
-
-	list_for_each_entry_safe(run, tmp, &chan->pending_q, list) {
-		/* skip contexts that are aborting */
-		if (run->ctx->aborting) {
-			dev_dbg(priv->ipu->dev,
-				"%s: task %u: skipping aborting ctx %p run %p\n",
-				__func__, chan->ic_task, run->ctx, run);
-			continue;
-		}
-
-		ret = do_run(run);
-		if (!ret)
-			break;
-
-		/*
-		 * something went wrong with start, add the run
-		 * to done q and continue to the next run in the
-		 * pending q.
-		 */
-		run->status = ret;
-		list_add_tail(&run->list, &chan->done_q);
-		chan->current_run = NULL;
-	}
-}
-
-static void empty_done_q(struct ipu_image_convert_chan *chan)
-{
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_run *run;
-	unsigned long flags;
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	while (!list_empty(&chan->done_q)) {
-		run = list_entry(chan->done_q.next,
-				 struct ipu_image_convert_run,
-				 list);
-
-		list_del(&run->list);
-
-		dev_dbg(priv->ipu->dev,
-			"%s: task %u: completing ctx %p run %p with %d\n",
-			__func__, chan->ic_task, run->ctx, run, run->status);
-
-		/* call the completion callback and free the run */
-		spin_unlock_irqrestore(&chan->irqlock, flags);
-		run->ctx->complete(run, run->ctx->complete_context);
-		spin_lock_irqsave(&chan->irqlock, flags);
-	}
-
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-}
-
-/*
- * the bottom half thread clears out the done_q, calling the
- * completion handler for each.
- */
-static irqreturn_t do_bh(int irq, void *dev_id)
-{
-	struct ipu_image_convert_chan *chan = dev_id;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_ctx *ctx;
-	unsigned long flags;
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: enter\n", __func__,
-		chan->ic_task);
-
-	empty_done_q(chan);
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	/*
-	 * the done_q is cleared out, signal any contexts
-	 * that are aborting that abort can complete.
-	 */
-	list_for_each_entry(ctx, &chan->ctx_list, list) {
-		if (ctx->aborting) {
-			dev_dbg(priv->ipu->dev,
-				"%s: task %u: signaling abort for ctx %p\n",
-				__func__, chan->ic_task, ctx);
-			complete(&ctx->aborted);
-		}
-	}
-
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: exit\n", __func__,
-		chan->ic_task);
-
-	return IRQ_HANDLED;
-}
-
-/* hold irqlock when calling */
-static irqreturn_t do_irq(struct ipu_image_convert_run *run)
-{
-	struct ipu_image_convert_ctx *ctx = run->ctx;
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_tile *src_tile, *dst_tile;
-	struct ipu_image_convert_image *s_image = &ctx->in;
-	struct ipu_image_convert_image *d_image = &ctx->out;
-	struct ipuv3_channel *outch;
-	unsigned int dst_idx;
-
-	lockdep_assert_held(&chan->irqlock);
-
-	outch = ipu_rot_mode_is_irt(ctx->rot_mode) ?
-		chan->rotation_out_chan : chan->out_chan;
-
-	/*
-	 * It is difficult to stop the channel DMA before the channels
-	 * enter the paused state. Without double-buffering the channels
-	 * are always in a paused state when the EOF irq occurs, so it
-	 * is safe to stop the channels now. For double-buffering we
-	 * just ignore the abort until the operation completes, when it
-	 * is safe to shut down.
-	 */
-	if (ctx->aborting && !ctx->double_buffering) {
-		convert_stop(run);
-		run->status = -EIO;
-		goto done;
-	}
-
-	if (ctx->next_tile == ctx->num_tiles) {
-		/*
-		 * the conversion is complete
-		 */
-		convert_stop(run);
-		run->status = 0;
-		goto done;
-	}
-
-	/*
-	 * not done, place the next tile buffers.
-	 */
-	if (!ctx->double_buffering) {
-
-		src_tile = &s_image->tile[ctx->next_tile];
-		dst_idx = ctx->out_tile_map[ctx->next_tile];
-		dst_tile = &d_image->tile[dst_idx];
-
-		ipu_cpmem_set_buffer(chan->in_chan, 0,
-				     s_image->base.phys0 + src_tile->offset);
-		ipu_cpmem_set_buffer(outch, 0,
-				     d_image->base.phys0 + dst_tile->offset);
-		if (s_image->fmt->planar)
-			ipu_cpmem_set_uv_offset(chan->in_chan,
-						src_tile->u_off,
-						src_tile->v_off);
-		if (d_image->fmt->planar)
-			ipu_cpmem_set_uv_offset(outch,
-						dst_tile->u_off,
-						dst_tile->v_off);
-
-		ipu_idmac_select_buffer(chan->in_chan, 0);
-		ipu_idmac_select_buffer(outch, 0);
-
-	} else if (ctx->next_tile < ctx->num_tiles - 1) {
-
-		src_tile = &s_image->tile[ctx->next_tile + 1];
-		dst_idx = ctx->out_tile_map[ctx->next_tile + 1];
-		dst_tile = &d_image->tile[dst_idx];
-
-		ipu_cpmem_set_buffer(chan->in_chan, ctx->cur_buf_num,
-				     s_image->base.phys0 + src_tile->offset);
-		ipu_cpmem_set_buffer(outch, ctx->cur_buf_num,
-				     d_image->base.phys0 + dst_tile->offset);
-
-		ipu_idmac_select_buffer(chan->in_chan, ctx->cur_buf_num);
-		ipu_idmac_select_buffer(outch, ctx->cur_buf_num);
-
-		ctx->cur_buf_num ^= 1;
-	}
-
-	ctx->next_tile++;
-	return IRQ_HANDLED;
-done:
-	list_add_tail(&run->list, &chan->done_q);
-	chan->current_run = NULL;
-	run_next(chan);
-	return IRQ_WAKE_THREAD;
-}
-
-static irqreturn_t norotate_irq(int irq, void *data)
-{
-	struct ipu_image_convert_chan *chan = data;
-	struct ipu_image_convert_ctx *ctx;
-	struct ipu_image_convert_run *run;
-	unsigned long flags;
-	irqreturn_t ret;
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	/* get current run and its context */
-	run = chan->current_run;
-	if (!run) {
-		ret = IRQ_NONE;
-		goto out;
-	}
-
-	ctx = run->ctx;
-
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		/* this is a rotation operation, just ignore */
-		spin_unlock_irqrestore(&chan->irqlock, flags);
-		return IRQ_HANDLED;
-	}
-
-	ret = do_irq(run);
-out:
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-	return ret;
-}
-
-static irqreturn_t rotate_irq(int irq, void *data)
-{
-	struct ipu_image_convert_chan *chan = data;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_ctx *ctx;
-	struct ipu_image_convert_run *run;
-	unsigned long flags;
-	irqreturn_t ret;
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	/* get current run and its context */
-	run = chan->current_run;
-	if (!run) {
-		ret = IRQ_NONE;
-		goto out;
-	}
-
-	ctx = run->ctx;
-
-	if (!ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		/* this was NOT a rotation operation, shouldn't happen */
-		dev_err(priv->ipu->dev, "Unexpected rotation interrupt\n");
-		spin_unlock_irqrestore(&chan->irqlock, flags);
-		return IRQ_HANDLED;
-	}
-
-	ret = do_irq(run);
-out:
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-	return ret;
-}
-
-/*
- * try to force the completion of runs for this ctx. Called when
- * abort wait times out in ipu_image_convert_abort().
- */
-static void force_abort(struct ipu_image_convert_ctx *ctx)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_run *run;
-	unsigned long flags;
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	run = chan->current_run;
-	if (run && run->ctx == ctx) {
-		convert_stop(run);
-		run->status = -EIO;
-		list_add_tail(&run->list, &chan->done_q);
-		chan->current_run = NULL;
-		run_next(chan);
-	}
-
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-
-	empty_done_q(chan);
-}
-
-static void release_ipu_resources(struct ipu_image_convert_chan *chan)
-{
-	if (chan->out_eof_irq >= 0)
-		free_irq(chan->out_eof_irq, chan);
-	if (chan->rot_out_eof_irq >= 0)
-		free_irq(chan->rot_out_eof_irq, chan);
-
-	if (!IS_ERR_OR_NULL(chan->in_chan))
-		ipu_idmac_put(chan->in_chan);
-	if (!IS_ERR_OR_NULL(chan->out_chan))
-		ipu_idmac_put(chan->out_chan);
-	if (!IS_ERR_OR_NULL(chan->rotation_in_chan))
-		ipu_idmac_put(chan->rotation_in_chan);
-	if (!IS_ERR_OR_NULL(chan->rotation_out_chan))
-		ipu_idmac_put(chan->rotation_out_chan);
-	if (!IS_ERR_OR_NULL(chan->ic))
-		ipu_ic_put(chan->ic);
-
-	chan->in_chan = chan->out_chan = chan->rotation_in_chan =
-		chan->rotation_out_chan = NULL;
-	chan->out_eof_irq = chan->rot_out_eof_irq = -1;
-}
-
-static int get_ipu_resources(struct ipu_image_convert_chan *chan)
-{
-	const struct ipu_image_convert_dma_chan *dma = chan->dma_ch;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	int ret;
-
-	/* get IC */
-	chan->ic = ipu_ic_get(priv->ipu, chan->ic_task);
-	if (IS_ERR(chan->ic)) {
-		dev_err(priv->ipu->dev, "could not acquire IC\n");
-		ret = PTR_ERR(chan->ic);
-		goto err;
-	}
-
-	/* get IDMAC channels */
-	chan->in_chan = ipu_idmac_get(priv->ipu, dma->in);
-	chan->out_chan = ipu_idmac_get(priv->ipu, dma->out);
-	if (IS_ERR(chan->in_chan) || IS_ERR(chan->out_chan)) {
-		dev_err(priv->ipu->dev, "could not acquire idmac channels\n");
-		ret = -EBUSY;
-		goto err;
-	}
-
-	chan->rotation_in_chan = ipu_idmac_get(priv->ipu, dma->rot_in);
-	chan->rotation_out_chan = ipu_idmac_get(priv->ipu, dma->rot_out);
-	if (IS_ERR(chan->rotation_in_chan) || IS_ERR(chan->rotation_out_chan)) {
-		dev_err(priv->ipu->dev,
-			"could not acquire idmac rotation channels\n");
-		ret = -EBUSY;
-		goto err;
-	}
-
-	/* acquire the EOF interrupts */
-	chan->out_eof_irq = ipu_idmac_channel_irq(priv->ipu,
-						  chan->out_chan,
-						  IPU_IRQ_EOF);
-
-	ret = request_threaded_irq(chan->out_eof_irq, norotate_irq, do_bh,
-				   0, "ipu-ic", chan);
-	if (ret < 0) {
-		dev_err(priv->ipu->dev, "could not acquire irq %d\n",
-			 chan->out_eof_irq);
-		chan->out_eof_irq = -1;
-		goto err;
-	}
-
-	chan->rot_out_eof_irq = ipu_idmac_channel_irq(priv->ipu,
-						     chan->rotation_out_chan,
-						     IPU_IRQ_EOF);
-
-	ret = request_threaded_irq(chan->rot_out_eof_irq, rotate_irq, do_bh,
-				   0, "ipu-ic", chan);
-	if (ret < 0) {
-		dev_err(priv->ipu->dev, "could not acquire irq %d\n",
-			chan->rot_out_eof_irq);
-		chan->rot_out_eof_irq = -1;
-		goto err;
-	}
-
-	return 0;
-err:
-	release_ipu_resources(chan);
-	return ret;
-}
-
-static int fill_image(struct ipu_image_convert_ctx *ctx,
-		      struct ipu_image_convert_image *ic_image,
-		      struct ipu_image *image,
-		      enum ipu_image_convert_type type)
-{
-	struct ipu_image_convert_priv *priv = ctx->chan->priv;
-
-	ic_image->base = *image;
-	ic_image->type = type;
-
-	ic_image->fmt = get_format(image->pix.pixelformat);
-	if (!ic_image->fmt) {
-		dev_err(priv->ipu->dev, "pixelformat not supported for %s\n",
-			type == IMAGE_CONVERT_OUT ? "Output" : "Input");
-		return -EINVAL;
-	}
-
-	if (ic_image->fmt->planar)
-		ic_image->stride = ic_image->base.pix.width;
-	else
-		ic_image->stride  = ic_image->base.pix.bytesperline;
-
-	calc_tile_dimensions(ctx, ic_image);
-	calc_tile_offsets(ctx, ic_image);
-
-	return 0;
-}
-
-/* borrowed from drivers/media/v4l2-core/v4l2-common.c */
-static unsigned int clamp_align(unsigned int x, unsigned int min,
-				unsigned int max, unsigned int align)
-{
-	/* Bits that must be zero to be aligned */
-	unsigned int mask = ~((1 << align) - 1);
-
-	/* Clamp to aligned min and max */
-	x = clamp(x, (min + ~mask) & mask, max & mask);
-
-	/* Round to nearest aligned value */
-	if (align)
-		x = (x + (1 << (align - 1))) & mask;
-
-	return x;
-}
-
-/*
- * We have to adjust the tile width such that the tile physaddrs and
- * U and V plane offsets are multiples of 8 bytes as required by
- * the IPU DMA Controller. For the planar formats, this corresponds
- * to a pixel alignment of 16 (but use a more formal equation since
- * the variables are available). For all the packed formats, 8 is
- * good enough.
- */
-static inline u32 tile_width_align(const struct ipu_image_pixfmt *fmt)
-{
-	return fmt->planar ? 8 * fmt->uv_width_dec : 8;
-}
-
-/*
- * For tile height alignment, we have to ensure that the output tile
- * heights are multiples of 8 lines if the IRT is required by the
- * given rotation mode (the IRT performs rotations on 8x8 blocks
- * at a time). If the IRT is not used, or for input image tiles,
- * 2 lines are good enough.
- */
-static inline u32 tile_height_align(enum ipu_image_convert_type type,
-				    enum ipu_rotate_mode rot_mode)
-{
-	return (type == IMAGE_CONVERT_OUT &&
-		ipu_rot_mode_is_irt(rot_mode)) ? 8 : 2;
-}
-
-/* Adjusts input/output images to IPU restrictions */
-void ipu_image_convert_adjust(struct ipu_image *in, struct ipu_image *out,
-			      enum ipu_rotate_mode rot_mode)
-{
-	const struct ipu_image_pixfmt *infmt, *outfmt;
-	unsigned int num_in_rows, num_in_cols;
-	unsigned int num_out_rows, num_out_cols;
-	u32 w_align, h_align;
-
-	infmt = get_format(in->pix.pixelformat);
-	outfmt = get_format(out->pix.pixelformat);
-
-	/* set some default pixel formats if needed */
-	if (!infmt) {
-		in->pix.pixelformat = V4L2_PIX_FMT_RGB24;
-		infmt = get_format(V4L2_PIX_FMT_RGB24);
-	}
-	if (!outfmt) {
-		out->pix.pixelformat = V4L2_PIX_FMT_RGB24;
-		outfmt = get_format(V4L2_PIX_FMT_RGB24);
-	}
-
-	/* image converter does not handle fields */
-	in->pix.field = out->pix.field = V4L2_FIELD_NONE;
-
-	/* resizer cannot downsize more than 4:1 */
-	if (ipu_rot_mode_is_irt(rot_mode)) {
-		out->pix.height = max_t(__u32, out->pix.height,
-					in->pix.width / 4);
-		out->pix.width = max_t(__u32, out->pix.width,
-				       in->pix.height / 4);
-	} else {
-		out->pix.width = max_t(__u32, out->pix.width,
-				       in->pix.width / 4);
-		out->pix.height = max_t(__u32, out->pix.height,
-					in->pix.height / 4);
-	}
-
-	/* get tiling rows/cols from output format */
-	num_out_rows = num_stripes(out->pix.height);
-	num_out_cols = num_stripes(out->pix.width);
-	if (ipu_rot_mode_is_irt(rot_mode)) {
-		num_in_rows = num_out_cols;
-		num_in_cols = num_out_rows;
-	} else {
-		num_in_rows = num_out_rows;
-		num_in_cols = num_out_cols;
-	}
-
-	/* align input width/height */
-	w_align = ilog2(tile_width_align(infmt) * num_in_cols);
-	h_align = ilog2(tile_height_align(IMAGE_CONVERT_IN, rot_mode) *
-			num_in_rows);
-	in->pix.width = clamp_align(in->pix.width, MIN_W, MAX_W, w_align);
-	in->pix.height = clamp_align(in->pix.height, MIN_H, MAX_H, h_align);
-
-	/* align output width/height */
-	w_align = ilog2(tile_width_align(outfmt) * num_out_cols);
-	h_align = ilog2(tile_height_align(IMAGE_CONVERT_OUT, rot_mode) *
-			num_out_rows);
-	out->pix.width = clamp_align(out->pix.width, MIN_W, MAX_W, w_align);
-	out->pix.height = clamp_align(out->pix.height, MIN_H, MAX_H, h_align);
-
-	/* set input/output strides and image sizes */
-	in->pix.bytesperline = (in->pix.width * infmt->bpp) >> 3;
-	in->pix.sizeimage = in->pix.height * in->pix.bytesperline;
-	out->pix.bytesperline = (out->pix.width * outfmt->bpp) >> 3;
-	out->pix.sizeimage = out->pix.height * out->pix.bytesperline;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_adjust);
-
-/*
- * this is used by ipu_image_convert_prepare() to verify set input and
- * output images are valid before starting the conversion. Clients can
- * also call it before calling ipu_image_convert_prepare().
- */
-int ipu_image_convert_verify(struct ipu_image *in, struct ipu_image *out,
-			     enum ipu_rotate_mode rot_mode)
-{
-	struct ipu_image testin, testout;
-
-	testin = *in;
-	testout = *out;
-
-	ipu_image_convert_adjust(&testin, &testout, rot_mode);
-
-	if (testin.pix.width != in->pix.width ||
-	    testin.pix.height != in->pix.height ||
-	    testout.pix.width != out->pix.width ||
-	    testout.pix.height != out->pix.height)
-		return -EINVAL;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_verify);
-
-/*
- * Call ipu_image_convert_prepare() to prepare for the conversion of
- * given images and rotation mode. Returns a new conversion context.
- */
-struct ipu_image_convert_ctx *
-ipu_image_convert_prepare(struct ipu_soc *ipu, enum ipu_ic_task ic_task,
-			  struct ipu_image *in, struct ipu_image *out,
-			  enum ipu_rotate_mode rot_mode,
-			  ipu_image_convert_cb_t complete,
-			  void *complete_context)
-{
-	struct ipu_image_convert_priv *priv = ipu->image_convert_priv;
-	struct ipu_image_convert_image *s_image, *d_image;
-	struct ipu_image_convert_chan *chan;
-	struct ipu_image_convert_ctx *ctx;
-	unsigned long flags;
-	bool get_res;
-	int ret;
-
-	if (!in || !out || !complete ||
-	    (ic_task != IC_TASK_VIEWFINDER &&
-	     ic_task != IC_TASK_POST_PROCESSOR))
-		return ERR_PTR(-EINVAL);
-
-	/* verify the in/out images before continuing */
-	ret = ipu_image_convert_verify(in, out, rot_mode);
-	if (ret) {
-		dev_err(priv->ipu->dev, "%s: in/out formats invalid\n",
-			__func__);
-		return ERR_PTR(ret);
-	}
-
-	chan = &priv->chan[ic_task];
-
-	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
-	if (!ctx)
-		return ERR_PTR(-ENOMEM);
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: ctx %p\n", __func__,
-		chan->ic_task, ctx);
-
-	ctx->chan = chan;
-	init_completion(&ctx->aborted);
-
-	s_image = &ctx->in;
-	d_image = &ctx->out;
-
-	/* set tiling and rotation */
-	d_image->num_rows = num_stripes(out->pix.height);
-	d_image->num_cols = num_stripes(out->pix.width);
-	if (ipu_rot_mode_is_irt(rot_mode)) {
-		s_image->num_rows = d_image->num_cols;
-		s_image->num_cols = d_image->num_rows;
-	} else {
-		s_image->num_rows = d_image->num_rows;
-		s_image->num_cols = d_image->num_cols;
-	}
-
-	ctx->num_tiles = d_image->num_cols * d_image->num_rows;
-	ctx->rot_mode = rot_mode;
-
-	ret = fill_image(ctx, s_image, in, IMAGE_CONVERT_IN);
-	if (ret)
-		goto out_free;
-	ret = fill_image(ctx, d_image, out, IMAGE_CONVERT_OUT);
-	if (ret)
-		goto out_free;
-
-	calc_out_tile_map(ctx);
-
-	dump_format(ctx, s_image);
-	dump_format(ctx, d_image);
-
-	ctx->complete = complete;
-	ctx->complete_context = complete_context;
-
-	/*
-	 * Can we use double-buffering for this operation? If there is
-	 * only one tile (the whole image can be converted in a single
-	 * operation) there's no point in using double-buffering. Also,
-	 * the IPU's IDMAC channels allow only a single U and V plane
-	 * offset shared between both buffers, but these offsets change
-	 * for every tile, and therefore would have to be updated for
-	 * each buffer which is not possible. So double-buffering is
-	 * impossible when either the source or destination images are
-	 * a planar format (YUV420, YUV422P, etc.).
-	 */
-	ctx->double_buffering = (ctx->num_tiles > 1 &&
-				 !s_image->fmt->planar &&
-				 !d_image->fmt->planar);
-
-	if (ipu_rot_mode_is_irt(ctx->rot_mode)) {
-		ret = alloc_dma_buf(priv, &ctx->rot_intermediate[0],
-				    d_image->tile[0].size);
-		if (ret)
-			goto out_free;
-		if (ctx->double_buffering) {
-			ret = alloc_dma_buf(priv,
-					    &ctx->rot_intermediate[1],
-					    d_image->tile[0].size);
-			if (ret)
-				goto out_free_dmabuf0;
-		}
-	}
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	get_res = list_empty(&chan->ctx_list);
-
-	list_add_tail(&ctx->list, &chan->ctx_list);
-
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-
-	if (get_res) {
-		ret = get_ipu_resources(chan);
-		if (ret)
-			goto out_free_dmabuf1;
-	}
-
-	return ctx;
-
-out_free_dmabuf1:
-	free_dma_buf(priv, &ctx->rot_intermediate[1]);
-	spin_lock_irqsave(&chan->irqlock, flags);
-	list_del(&ctx->list);
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-out_free_dmabuf0:
-	free_dma_buf(priv, &ctx->rot_intermediate[0]);
-out_free:
-	kfree(ctx);
-	return ERR_PTR(ret);
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_prepare);
-
-/*
- * Carry out a single image conversion run. Only the physaddr's of the input
- * and output image buffers are needed. The conversion context must have
- * been created previously with ipu_image_convert_prepare().
- */
-int ipu_image_convert_queue(struct ipu_image_convert_run *run)
-{
-	struct ipu_image_convert_chan *chan;
-	struct ipu_image_convert_priv *priv;
-	struct ipu_image_convert_ctx *ctx;
-	unsigned long flags;
-	int ret = 0;
-
-	if (!run || !run->ctx || !run->in_phys || !run->out_phys)
-		return -EINVAL;
-
-	ctx = run->ctx;
-	chan = ctx->chan;
-	priv = chan->priv;
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: ctx %p run %p\n", __func__,
-		chan->ic_task, ctx, run);
-
-	INIT_LIST_HEAD(&run->list);
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	if (ctx->aborting) {
-		ret = -EIO;
-		goto unlock;
-	}
-
-	list_add_tail(&run->list, &chan->pending_q);
-
-	if (!chan->current_run) {
-		ret = do_run(run);
-		if (ret)
-			chan->current_run = NULL;
-	}
-unlock:
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_queue);
-
-/* Abort any active or pending conversions for this context */
-static void __ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	struct ipu_image_convert_run *run, *active_run, *tmp;
-	unsigned long flags;
-	int run_count, ret;
-	bool need_abort;
-
-	reinit_completion(&ctx->aborted);
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	/* move all remaining pending runs in this context to done_q */
-	list_for_each_entry_safe(run, tmp, &chan->pending_q, list) {
-		if (run->ctx != ctx)
-			continue;
-		run->status = -EIO;
-		list_move_tail(&run->list, &chan->done_q);
-	}
-
-	run_count = get_run_count(ctx, &chan->done_q);
-	active_run = (chan->current_run && chan->current_run->ctx == ctx) ?
-		chan->current_run : NULL;
-
-	need_abort = (run_count || active_run);
-
-	ctx->aborting = true;
-
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-
-	if (!need_abort) {
-		dev_dbg(priv->ipu->dev,
-			"%s: task %u: no abort needed for ctx %p\n",
-			__func__, chan->ic_task, ctx);
-		return;
-	}
-
-	dev_dbg(priv->ipu->dev,
-		"%s: task %u: wait for completion: %d runs, active run %p\n",
-		__func__, chan->ic_task, run_count, active_run);
-
-	ret = wait_for_completion_timeout(&ctx->aborted,
-					  msecs_to_jiffies(10000));
-	if (ret == 0) {
-		dev_warn(priv->ipu->dev, "%s: timeout\n", __func__);
-		force_abort(ctx);
-	}
-}
-
-void ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)
-{
-	__ipu_image_convert_abort(ctx);
-	ctx->aborting = false;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_abort);
-
-/* Unprepare image conversion context */
-void ipu_image_convert_unprepare(struct ipu_image_convert_ctx *ctx)
-{
-	struct ipu_image_convert_chan *chan = ctx->chan;
-	struct ipu_image_convert_priv *priv = chan->priv;
-	unsigned long flags;
-	bool put_res;
-
-	/* make sure no runs are hanging around */
-	__ipu_image_convert_abort(ctx);
-
-	dev_dbg(priv->ipu->dev, "%s: task %u: removing ctx %p\n", __func__,
-		chan->ic_task, ctx);
-
-	spin_lock_irqsave(&chan->irqlock, flags);
-
-	list_del(&ctx->list);
-
-	put_res = list_empty(&chan->ctx_list);
-
-	spin_unlock_irqrestore(&chan->irqlock, flags);
-
-	if (put_res)
-		release_ipu_resources(chan);
-
-	free_dma_buf(priv, &ctx->rot_intermediate[1]);
-	free_dma_buf(priv, &ctx->rot_intermediate[0]);
-
-	kfree(ctx);
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_unprepare);
-
-/*
- * "Canned" asynchronous single image conversion. Allocates and returns
- * a new conversion run.  On successful return the caller must free the
- * run and call ipu_image_convert_unprepare() after conversion completes.
- */
-struct ipu_image_convert_run *
-ipu_image_convert(struct ipu_soc *ipu, enum ipu_ic_task ic_task,
-		  struct ipu_image *in, struct ipu_image *out,
-		  enum ipu_rotate_mode rot_mode,
-		  ipu_image_convert_cb_t complete,
-		  void *complete_context)
-{
-	struct ipu_image_convert_ctx *ctx;
-	struct ipu_image_convert_run *run;
-	int ret;
-
-	ctx = ipu_image_convert_prepare(ipu, ic_task, in, out, rot_mode,
-					complete, complete_context);
-	if (IS_ERR(ctx))
-		return ERR_CAST(ctx);
-
-	run = kzalloc(sizeof(*run), GFP_KERNEL);
-	if (!run) {
-		ipu_image_convert_unprepare(ctx);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	run->ctx = ctx;
-	run->in_phys = in->phys0;
-	run->out_phys = out->phys0;
-
-	ret = ipu_image_convert_queue(run);
-	if (ret) {
-		ipu_image_convert_unprepare(ctx);
-		kfree(run);
-		return ERR_PTR(ret);
-	}
-
-	return run;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert);
-
-/* "Canned" synchronous single image conversion */
-static void image_convert_sync_complete(struct ipu_image_convert_run *run,
-					void *data)
-{
-	struct completion *comp = data;
-
-	complete(comp);
-}
-
-int ipu_image_convert_sync(struct ipu_soc *ipu, enum ipu_ic_task ic_task,
-			   struct ipu_image *in, struct ipu_image *out,
-			   enum ipu_rotate_mode rot_mode)
-{
-	struct ipu_image_convert_run *run;
-	struct completion comp;
-	int ret;
-
-	init_completion(&comp);
-
-	run = ipu_image_convert(ipu, ic_task, in, out, rot_mode,
-				image_convert_sync_complete, &comp);
-	if (IS_ERR(run))
-		return PTR_ERR(run);
-
-	ret = wait_for_completion_timeout(&comp, msecs_to_jiffies(10000));
-	ret = (ret == 0) ? -ETIMEDOUT : 0;
-
-	ipu_image_convert_unprepare(run->ctx);
-	kfree(run);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_image_convert_sync);
-
-int ipu_image_convert_init(struct ipu_soc *ipu, struct device *dev)
-{
-	struct ipu_image_convert_priv *priv;
-	int i;
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	ipu->image_convert_priv = priv;
-	priv->ipu = ipu;
-
-	for (i = 0; i < IC_NUM_TASKS; i++) {
-		struct ipu_image_convert_chan *chan = &priv->chan[i];
-
-		chan->ic_task = i;
-		chan->priv = priv;
-		chan->dma_ch = &image_convert_dma_chan[i];
-		chan->out_eof_irq = -1;
-		chan->rot_out_eof_irq = -1;
-
-		spin_lock_init(&chan->irqlock);
-		INIT_LIST_HEAD(&chan->ctx_list);
-		INIT_LIST_HEAD(&chan->pending_q);
-		INIT_LIST_HEAD(&chan->done_q);
-	}
-
-	return 0;
-}
-
-void ipu_image_convert_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-pre.c b/drivers/gpu/ipu-v3/ipu-pre.c
deleted file mode 100644
index 0f70e88..0000000
--- a/drivers/gpu/ipu-v3/ipu-pre.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright (c) 2017 Lucas Stach, Pengutronix
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <drm/drm_fourcc.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/genalloc.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <video/imx-ipu-v3.h>
-
-#include "ipu-prv.h"
-
-#define IPU_PRE_MAX_WIDTH	2048
-#define IPU_PRE_NUM_SCANLINES	8
-
-#define IPU_PRE_CTRL					0x000
-#define IPU_PRE_CTRL_SET				0x004
-#define  IPU_PRE_CTRL_ENABLE				(1 << 0)
-#define  IPU_PRE_CTRL_BLOCK_EN				(1 << 1)
-#define  IPU_PRE_CTRL_BLOCK_16				(1 << 2)
-#define  IPU_PRE_CTRL_SDW_UPDATE			(1 << 4)
-#define  IPU_PRE_CTRL_VFLIP				(1 << 5)
-#define  IPU_PRE_CTRL_SO				(1 << 6)
-#define  IPU_PRE_CTRL_INTERLACED_FIELD			(1 << 7)
-#define  IPU_PRE_CTRL_HANDSHAKE_EN			(1 << 8)
-#define  IPU_PRE_CTRL_HANDSHAKE_LINE_NUM(v)		((v & 0x3) << 9)
-#define  IPU_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN		(1 << 11)
-#define  IPU_PRE_CTRL_EN_REPEAT				(1 << 28)
-#define  IPU_PRE_CTRL_TPR_REST_SEL			(1 << 29)
-#define  IPU_PRE_CTRL_CLKGATE				(1 << 30)
-#define  IPU_PRE_CTRL_SFTRST				(1 << 31)
-
-#define IPU_PRE_CUR_BUF					0x030
-
-#define IPU_PRE_NEXT_BUF				0x040
-
-#define IPU_PRE_TPR_CTRL				0x070
-#define  IPU_PRE_TPR_CTRL_TILE_FORMAT(v)		((v & 0xff) << 0)
-#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_MASK		0xff
-#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_16_BIT		(1 << 0)
-#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SPLIT_BUF		(1 << 4)
-#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SINGLE_BUF	(1 << 5)
-#define  IPU_PRE_TPR_CTRL_TILE_FORMAT_SUPER_TILED	(1 << 6)
-
-#define IPU_PRE_PREFETCH_ENG_CTRL			0x080
-#define  IPU_PRE_PREF_ENG_CTRL_PREFETCH_EN		(1 << 0)
-#define  IPU_PRE_PREF_ENG_CTRL_RD_NUM_BYTES(v)		((v & 0x7) << 1)
-#define  IPU_PRE_PREF_ENG_CTRL_INPUT_ACTIVE_BPP(v)	((v & 0x3) << 4)
-#define  IPU_PRE_PREF_ENG_CTRL_INPUT_PIXEL_FORMAT(v)	((v & 0x7) << 8)
-#define  IPU_PRE_PREF_ENG_CTRL_SHIFT_BYPASS		(1 << 11)
-#define  IPU_PRE_PREF_ENG_CTRL_FIELD_INVERSE		(1 << 12)
-#define  IPU_PRE_PREF_ENG_CTRL_PARTIAL_UV_SWAP		(1 << 14)
-#define  IPU_PRE_PREF_ENG_CTRL_TPR_COOR_OFFSET_EN	(1 << 15)
-
-#define IPU_PRE_PREFETCH_ENG_INPUT_SIZE			0x0a0
-#define  IPU_PRE_PREFETCH_ENG_INPUT_SIZE_WIDTH(v)	((v & 0xffff) << 0)
-#define  IPU_PRE_PREFETCH_ENG_INPUT_SIZE_HEIGHT(v)	((v & 0xffff) << 16)
-
-#define IPU_PRE_PREFETCH_ENG_PITCH			0x0d0
-#define  IPU_PRE_PREFETCH_ENG_PITCH_Y(v)		((v & 0xffff) << 0)
-#define  IPU_PRE_PREFETCH_ENG_PITCH_UV(v)		((v & 0xffff) << 16)
-
-#define IPU_PRE_STORE_ENG_CTRL				0x110
-#define  IPU_PRE_STORE_ENG_CTRL_STORE_EN		(1 << 0)
-#define  IPU_PRE_STORE_ENG_CTRL_WR_NUM_BYTES(v)		((v & 0x7) << 1)
-#define  IPU_PRE_STORE_ENG_CTRL_OUTPUT_ACTIVE_BPP(v)	((v & 0x3) << 4)
-
-#define IPU_PRE_STORE_ENG_STATUS			0x120
-#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_X_MASK	0xffff
-#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_X_SHIFT	0
-#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_MASK	0x3fff
-#define  IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_SHIFT	16
-#define  IPU_PRE_STORE_ENG_STATUS_STORE_FIFO_FULL	(1 << 30)
-#define  IPU_PRE_STORE_ENG_STATUS_STORE_FIELD		(1 << 31)
-
-#define IPU_PRE_STORE_ENG_SIZE				0x130
-#define  IPU_PRE_STORE_ENG_SIZE_INPUT_WIDTH(v)		((v & 0xffff) << 0)
-#define  IPU_PRE_STORE_ENG_SIZE_INPUT_HEIGHT(v)		((v & 0xffff) << 16)
-
-#define IPU_PRE_STORE_ENG_PITCH				0x140
-#define  IPU_PRE_STORE_ENG_PITCH_OUT_PITCH(v)		((v & 0xffff) << 0)
-
-#define IPU_PRE_STORE_ENG_ADDR				0x150
-
-struct ipu_pre {
-	struct list_head	list;
-	struct device		*dev;
-
-	void __iomem		*regs;
-	struct clk		*clk_axi;
-	struct gen_pool		*iram;
-
-	dma_addr_t		buffer_paddr;
-	void			*buffer_virt;
-	bool			in_use;
-	unsigned int		safe_window_end;
-};
-
-static DEFINE_MUTEX(ipu_pre_list_mutex);
-static LIST_HEAD(ipu_pre_list);
-static int available_pres;
-
-int ipu_pre_get_available_count(void)
-{
-	return available_pres;
-}
-
-struct ipu_pre *
-ipu_pre_lookup_by_phandle(struct device *dev, const char *name, int index)
-{
-	struct device_node *pre_node = of_parse_phandle(dev->of_node,
-							name, index);
-	struct ipu_pre *pre;
-
-	mutex_lock(&ipu_pre_list_mutex);
-	list_for_each_entry(pre, &ipu_pre_list, list) {
-		if (pre_node == pre->dev->of_node) {
-			mutex_unlock(&ipu_pre_list_mutex);
-			device_link_add(dev, pre->dev, DL_FLAG_AUTOREMOVE);
-			of_node_put(pre_node);
-			return pre;
-		}
-	}
-	mutex_unlock(&ipu_pre_list_mutex);
-
-	of_node_put(pre_node);
-
-	return NULL;
-}
-
-int ipu_pre_get(struct ipu_pre *pre)
-{
-	u32 val;
-
-	if (pre->in_use)
-		return -EBUSY;
-
-	/* first get the engine out of reset and remove clock gating */
-	writel(0, pre->regs + IPU_PRE_CTRL);
-
-	/* init defaults that should be applied to all streams */
-	val = IPU_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN |
-	      IPU_PRE_CTRL_HANDSHAKE_EN |
-	      IPU_PRE_CTRL_TPR_REST_SEL |
-	      IPU_PRE_CTRL_SDW_UPDATE;
-	writel(val, pre->regs + IPU_PRE_CTRL);
-
-	pre->in_use = true;
-	return 0;
-}
-
-void ipu_pre_put(struct ipu_pre *pre)
-{
-	writel(IPU_PRE_CTRL_SFTRST, pre->regs + IPU_PRE_CTRL);
-
-	pre->in_use = false;
-}
-
-void ipu_pre_configure(struct ipu_pre *pre, unsigned int width,
-		       unsigned int height, unsigned int stride, u32 format,
-		       uint64_t modifier, unsigned int bufaddr)
-{
-	const struct drm_format_info *info = drm_format_info(format);
-	u32 active_bpp = info->cpp[0] >> 1;
-	u32 val;
-
-	/* calculate safe window for ctrl register updates */
-	if (modifier == DRM_FORMAT_MOD_LINEAR)
-		pre->safe_window_end = height - 2;
-	else
-		pre->safe_window_end = DIV_ROUND_UP(height, 4) - 1;
-
-	writel(bufaddr, pre->regs + IPU_PRE_CUR_BUF);
-	writel(bufaddr, pre->regs + IPU_PRE_NEXT_BUF);
-
-	val = IPU_PRE_PREF_ENG_CTRL_INPUT_PIXEL_FORMAT(0) |
-	      IPU_PRE_PREF_ENG_CTRL_INPUT_ACTIVE_BPP(active_bpp) |
-	      IPU_PRE_PREF_ENG_CTRL_RD_NUM_BYTES(4) |
-	      IPU_PRE_PREF_ENG_CTRL_SHIFT_BYPASS |
-	      IPU_PRE_PREF_ENG_CTRL_PREFETCH_EN;
-	writel(val, pre->regs + IPU_PRE_PREFETCH_ENG_CTRL);
-
-	val = IPU_PRE_PREFETCH_ENG_INPUT_SIZE_WIDTH(width) |
-	      IPU_PRE_PREFETCH_ENG_INPUT_SIZE_HEIGHT(height);
-	writel(val, pre->regs + IPU_PRE_PREFETCH_ENG_INPUT_SIZE);
-
-	val = IPU_PRE_PREFETCH_ENG_PITCH_Y(stride);
-	writel(val, pre->regs + IPU_PRE_PREFETCH_ENG_PITCH);
-
-	val = IPU_PRE_STORE_ENG_CTRL_OUTPUT_ACTIVE_BPP(active_bpp) |
-	      IPU_PRE_STORE_ENG_CTRL_WR_NUM_BYTES(4) |
-	      IPU_PRE_STORE_ENG_CTRL_STORE_EN;
-	writel(val, pre->regs + IPU_PRE_STORE_ENG_CTRL);
-
-	val = IPU_PRE_STORE_ENG_SIZE_INPUT_WIDTH(width) |
-	      IPU_PRE_STORE_ENG_SIZE_INPUT_HEIGHT(height);
-	writel(val, pre->regs + IPU_PRE_STORE_ENG_SIZE);
-
-	val = IPU_PRE_STORE_ENG_PITCH_OUT_PITCH(stride);
-	writel(val, pre->regs + IPU_PRE_STORE_ENG_PITCH);
-
-	writel(pre->buffer_paddr, pre->regs + IPU_PRE_STORE_ENG_ADDR);
-
-	val = readl(pre->regs + IPU_PRE_TPR_CTRL);
-	val &= ~IPU_PRE_TPR_CTRL_TILE_FORMAT_MASK;
-	if (modifier != DRM_FORMAT_MOD_LINEAR) {
-		/* only support single buffer formats for now */
-		val |= IPU_PRE_TPR_CTRL_TILE_FORMAT_SINGLE_BUF;
-		if (modifier == DRM_FORMAT_MOD_VIVANTE_SUPER_TILED)
-			val |= IPU_PRE_TPR_CTRL_TILE_FORMAT_SUPER_TILED;
-		if (info->cpp[0] == 2)
-			val |= IPU_PRE_TPR_CTRL_TILE_FORMAT_16_BIT;
-	}
-	writel(val, pre->regs + IPU_PRE_TPR_CTRL);
-
-	val = readl(pre->regs + IPU_PRE_CTRL);
-	val |= IPU_PRE_CTRL_EN_REPEAT | IPU_PRE_CTRL_ENABLE |
-	       IPU_PRE_CTRL_SDW_UPDATE;
-	if (modifier == DRM_FORMAT_MOD_LINEAR)
-		val &= ~IPU_PRE_CTRL_BLOCK_EN;
-	else
-		val |= IPU_PRE_CTRL_BLOCK_EN;
-	writel(val, pre->regs + IPU_PRE_CTRL);
-}
-
-void ipu_pre_update(struct ipu_pre *pre, unsigned int bufaddr)
-{
-	unsigned long timeout = jiffies + msecs_to_jiffies(5);
-	unsigned short current_yblock;
-	u32 val;
-
-	writel(bufaddr, pre->regs + IPU_PRE_NEXT_BUF);
-
-	do {
-		if (time_after(jiffies, timeout)) {
-			dev_warn(pre->dev, "timeout waiting for PRE safe window\n");
-			return;
-		}
-
-		val = readl(pre->regs + IPU_PRE_STORE_ENG_STATUS);
-		current_yblock =
-			(val >> IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_SHIFT) &
-			IPU_PRE_STORE_ENG_STATUS_STORE_BLOCK_Y_MASK;
-	} while (current_yblock == 0 || current_yblock >= pre->safe_window_end);
-
-	writel(IPU_PRE_CTRL_SDW_UPDATE, pre->regs + IPU_PRE_CTRL_SET);
-}
-
-u32 ipu_pre_get_baddr(struct ipu_pre *pre)
-{
-	return (u32)pre->buffer_paddr;
-}
-
-static int ipu_pre_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct ipu_pre *pre;
-
-	pre = devm_kzalloc(dev, sizeof(*pre), GFP_KERNEL);
-	if (!pre)
-		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	pre->regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(pre->regs))
-		return PTR_ERR(pre->regs);
-
-	pre->clk_axi = devm_clk_get(dev, "axi");
-	if (IS_ERR(pre->clk_axi))
-		return PTR_ERR(pre->clk_axi);
-
-	pre->iram = of_gen_pool_get(dev->of_node, "fsl,iram", 0);
-	if (!pre->iram)
-		return -EPROBE_DEFER;
-
-	/*
-	 * Allocate IRAM buffer with maximum size. This could be made dynamic,
-	 * but as there is no other user of this IRAM region and we can fit all
-	 * max sized buffers into it, there is no need yet.
-	 */
-	pre->buffer_virt = gen_pool_dma_alloc(pre->iram, IPU_PRE_MAX_WIDTH *
-					      IPU_PRE_NUM_SCANLINES * 4,
-					      &pre->buffer_paddr);
-	if (!pre->buffer_virt)
-		return -ENOMEM;
-
-	clk_prepare_enable(pre->clk_axi);
-
-	pre->dev = dev;
-	platform_set_drvdata(pdev, pre);
-	mutex_lock(&ipu_pre_list_mutex);
-	list_add(&pre->list, &ipu_pre_list);
-	available_pres++;
-	mutex_unlock(&ipu_pre_list_mutex);
-
-	return 0;
-}
-
-static int ipu_pre_remove(struct platform_device *pdev)
-{
-	struct ipu_pre *pre = platform_get_drvdata(pdev);
-
-	mutex_lock(&ipu_pre_list_mutex);
-	list_del(&pre->list);
-	available_pres--;
-	mutex_unlock(&ipu_pre_list_mutex);
-
-	clk_disable_unprepare(pre->clk_axi);
-
-	if (pre->buffer_virt)
-		gen_pool_free(pre->iram, (unsigned long)pre->buffer_virt,
-			      IPU_PRE_MAX_WIDTH * IPU_PRE_NUM_SCANLINES * 4);
-	return 0;
-}
-
-static const struct of_device_id ipu_pre_dt_ids[] = {
-	{ .compatible = "fsl,imx6qp-pre", },
-	{ /* sentinel */ },
-};
-
-struct platform_driver ipu_pre_drv = {
-	.probe		= ipu_pre_probe,
-	.remove		= ipu_pre_remove,
-	.driver		= {
-		.name	= "imx-ipu-pre",
-		.of_match_table = ipu_pre_dt_ids,
-	},
-};
diff --git a/drivers/gpu/ipu-v3/ipu-prg.c b/drivers/gpu/ipu-v3/ipu-prg.c
deleted file mode 100644
index 83f9dd9..0000000
--- a/drivers/gpu/ipu-v3/ipu-prg.c
+++ /dev/null
@@ -1,474 +0,0 @@
-/*
- * Copyright (c) 2016-2017 Lucas Stach, Pengutronix
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <drm/drm_fourcc.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/iopoll.h>
-#include <linux/mfd/syscon.h>
-#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/regmap.h>
-#include <video/imx-ipu-v3.h>
-
-#include "ipu-prv.h"
-
-#define IPU_PRG_CTL				0x00
-#define  IPU_PRG_CTL_BYPASS(i)			(1 << (0 + i))
-#define  IPU_PRG_CTL_SOFT_ARID_MASK		0x3
-#define  IPU_PRG_CTL_SOFT_ARID_SHIFT(i)		(8 + i * 2)
-#define  IPU_PRG_CTL_SOFT_ARID(i, v)		((v & 0x3) << (8 + 2 * i))
-#define  IPU_PRG_CTL_SO(i)			(1 << (16 + i))
-#define  IPU_PRG_CTL_VFLIP(i)			(1 << (19 + i))
-#define  IPU_PRG_CTL_BLOCK_MODE(i)		(1 << (22 + i))
-#define  IPU_PRG_CTL_CNT_LOAD_EN(i)		(1 << (25 + i))
-#define  IPU_PRG_CTL_SOFTRST			(1 << 30)
-#define  IPU_PRG_CTL_SHADOW_EN			(1 << 31)
-
-#define IPU_PRG_STATUS				0x04
-#define  IPU_PRG_STATUS_BUFFER0_READY(i)	(1 << (0 + i * 2))
-#define  IPU_PRG_STATUS_BUFFER1_READY(i)	(1 << (1 + i * 2))
-
-#define IPU_PRG_QOS				0x08
-#define  IPU_PRG_QOS_ARID_MASK			0xf
-#define  IPU_PRG_QOS_ARID_SHIFT(i)		(0 + i * 4)
-
-#define IPU_PRG_REG_UPDATE			0x0c
-#define  IPU_PRG_REG_UPDATE_REG_UPDATE		(1 << 0)
-
-#define IPU_PRG_STRIDE(i)			(0x10 + i * 0x4)
-#define  IPU_PRG_STRIDE_STRIDE_MASK		0x3fff
-
-#define IPU_PRG_CROP_LINE			0x1c
-
-#define IPU_PRG_THD				0x20
-
-#define IPU_PRG_BADDR(i)			(0x24 + i * 0x4)
-
-#define IPU_PRG_OFFSET(i)			(0x30 + i * 0x4)
-
-#define IPU_PRG_ILO(i)				(0x3c + i * 0x4)
-
-#define IPU_PRG_HEIGHT(i)			(0x48 + i * 0x4)
-#define  IPU_PRG_HEIGHT_PRE_HEIGHT_MASK		0xfff
-#define  IPU_PRG_HEIGHT_PRE_HEIGHT_SHIFT	0
-#define  IPU_PRG_HEIGHT_IPU_HEIGHT_MASK		0xfff
-#define  IPU_PRG_HEIGHT_IPU_HEIGHT_SHIFT	16
-
-struct ipu_prg_channel {
-	bool			enabled;
-	int			used_pre;
-};
-
-struct ipu_prg {
-	struct list_head	list;
-	struct device		*dev;
-	int			id;
-
-	void __iomem		*regs;
-	struct clk		*clk_ipg, *clk_axi;
-	struct regmap		*iomuxc_gpr;
-	struct ipu_pre		*pres[3];
-
-	struct ipu_prg_channel	chan[3];
-};
-
-static DEFINE_MUTEX(ipu_prg_list_mutex);
-static LIST_HEAD(ipu_prg_list);
-
-struct ipu_prg *
-ipu_prg_lookup_by_phandle(struct device *dev, const char *name, int ipu_id)
-{
-	struct device_node *prg_node = of_parse_phandle(dev->of_node,
-							name, 0);
-	struct ipu_prg *prg;
-
-	mutex_lock(&ipu_prg_list_mutex);
-	list_for_each_entry(prg, &ipu_prg_list, list) {
-		if (prg_node == prg->dev->of_node) {
-			mutex_unlock(&ipu_prg_list_mutex);
-			device_link_add(dev, prg->dev, DL_FLAG_AUTOREMOVE);
-			prg->id = ipu_id;
-			of_node_put(prg_node);
-			return prg;
-		}
-	}
-	mutex_unlock(&ipu_prg_list_mutex);
-
-	of_node_put(prg_node);
-
-	return NULL;
-}
-
-int ipu_prg_max_active_channels(void)
-{
-	return ipu_pre_get_available_count();
-}
-EXPORT_SYMBOL_GPL(ipu_prg_max_active_channels);
-
-bool ipu_prg_present(struct ipu_soc *ipu)
-{
-	if (ipu->prg_priv)
-		return true;
-
-	return false;
-}
-EXPORT_SYMBOL_GPL(ipu_prg_present);
-
-bool ipu_prg_format_supported(struct ipu_soc *ipu, uint32_t format,
-			      uint64_t modifier)
-{
-	const struct drm_format_info *info = drm_format_info(format);
-
-	if (info->num_planes != 1)
-		return false;
-
-	switch (modifier) {
-	case DRM_FORMAT_MOD_LINEAR:
-	case DRM_FORMAT_MOD_VIVANTE_TILED:
-	case DRM_FORMAT_MOD_VIVANTE_SUPER_TILED:
-		return true;
-	default:
-		return false;
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_prg_format_supported);
-
-int ipu_prg_enable(struct ipu_soc *ipu)
-{
-	struct ipu_prg *prg = ipu->prg_priv;
-
-	if (!prg)
-		return 0;
-
-	return pm_runtime_get_sync(prg->dev);
-}
-EXPORT_SYMBOL_GPL(ipu_prg_enable);
-
-void ipu_prg_disable(struct ipu_soc *ipu)
-{
-	struct ipu_prg *prg = ipu->prg_priv;
-
-	if (!prg)
-		return;
-
-	pm_runtime_put(prg->dev);
-}
-EXPORT_SYMBOL_GPL(ipu_prg_disable);
-
-/*
- * The channel configuartion functions below are not thread safe, as they
- * must be only called from the atomic commit path in the DRM driver, which
- * is properly serialized.
- */
-static int ipu_prg_ipu_to_prg_chan(int ipu_chan)
-{
-	/*
-	 * This isn't clearly documented in the RM, but IPU to PRG channel
-	 * assignment is fixed, as only with this mapping the control signals
-	 * match up.
-	 */
-	switch (ipu_chan) {
-	case IPUV3_CHANNEL_MEM_BG_SYNC:
-		return 0;
-	case IPUV3_CHANNEL_MEM_FG_SYNC:
-		return 1;
-	case IPUV3_CHANNEL_MEM_DC_SYNC:
-		return 2;
-	default:
-		return -EINVAL;
-	}
-}
-
-static int ipu_prg_get_pre(struct ipu_prg *prg, int prg_chan)
-{
-	int i, ret;
-
-	/* channel 0 is special as it is hardwired to one of the PREs */
-	if (prg_chan == 0) {
-		ret = ipu_pre_get(prg->pres[0]);
-		if (ret)
-			goto fail;
-		prg->chan[prg_chan].used_pre = 0;
-		return 0;
-	}
-
-	for (i = 1; i < 3; i++) {
-		ret = ipu_pre_get(prg->pres[i]);
-		if (!ret) {
-			u32 val, mux;
-			int shift;
-
-			prg->chan[prg_chan].used_pre = i;
-
-			/* configure the PRE to PRG channel mux */
-			shift = (i == 1) ? 12 : 14;
-			mux = (prg->id << 1) | (prg_chan - 1);
-			regmap_update_bits(prg->iomuxc_gpr, IOMUXC_GPR5,
-					   0x3 << shift, mux << shift);
-
-			/* check other mux, must not point to same channel */
-			shift = (i == 1) ? 14 : 12;
-			regmap_read(prg->iomuxc_gpr, IOMUXC_GPR5, &val);
-			if (((val >> shift) & 0x3) == mux) {
-				regmap_update_bits(prg->iomuxc_gpr, IOMUXC_GPR5,
-						   0x3 << shift,
-						   (mux ^ 0x1) << shift);
-			}
-
-			return 0;
-		}
-	}
-
-fail:
-	dev_err(prg->dev, "could not get PRE for PRG chan %d", prg_chan);
-	return ret;
-}
-
-static void ipu_prg_put_pre(struct ipu_prg *prg, int prg_chan)
-{
-	struct ipu_prg_channel *chan = &prg->chan[prg_chan];
-
-	ipu_pre_put(prg->pres[chan->used_pre]);
-	chan->used_pre = -1;
-}
-
-void ipu_prg_channel_disable(struct ipuv3_channel *ipu_chan)
-{
-	int prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);
-	struct ipu_prg *prg = ipu_chan->ipu->prg_priv;
-	struct ipu_prg_channel *chan;
-	u32 val;
-
-	if (prg_chan < 0)
-		return;
-
-	chan = &prg->chan[prg_chan];
-	if (!chan->enabled)
-		return;
-
-	pm_runtime_get_sync(prg->dev);
-
-	val = readl(prg->regs + IPU_PRG_CTL);
-	val |= IPU_PRG_CTL_BYPASS(prg_chan);
-	writel(val, prg->regs + IPU_PRG_CTL);
-
-	val = IPU_PRG_REG_UPDATE_REG_UPDATE;
-	writel(val, prg->regs + IPU_PRG_REG_UPDATE);
-
-	pm_runtime_put(prg->dev);
-
-	ipu_prg_put_pre(prg, prg_chan);
-
-	chan->enabled = false;
-}
-EXPORT_SYMBOL_GPL(ipu_prg_channel_disable);
-
-int ipu_prg_channel_configure(struct ipuv3_channel *ipu_chan,
-			      unsigned int axi_id, unsigned int width,
-			      unsigned int height, unsigned int stride,
-			      u32 format, uint64_t modifier, unsigned long *eba)
-{
-	int prg_chan = ipu_prg_ipu_to_prg_chan(ipu_chan->num);
-	struct ipu_prg *prg = ipu_chan->ipu->prg_priv;
-	struct ipu_prg_channel *chan;
-	u32 val;
-	int ret;
-
-	if (prg_chan < 0)
-		return prg_chan;
-
-	chan = &prg->chan[prg_chan];
-
-	if (chan->enabled) {
-		ipu_pre_update(prg->pres[chan->used_pre], *eba);
-		return 0;
-	}
-
-	ret = ipu_prg_get_pre(prg, prg_chan);
-	if (ret)
-		return ret;
-
-	ipu_pre_configure(prg->pres[chan->used_pre],
-			  width, height, stride, format, modifier, *eba);
-
-
-	pm_runtime_get_sync(prg->dev);
-
-	val = (stride - 1) & IPU_PRG_STRIDE_STRIDE_MASK;
-	writel(val, prg->regs + IPU_PRG_STRIDE(prg_chan));
-
-	val = ((height & IPU_PRG_HEIGHT_PRE_HEIGHT_MASK) <<
-	       IPU_PRG_HEIGHT_PRE_HEIGHT_SHIFT) |
-	      ((height & IPU_PRG_HEIGHT_IPU_HEIGHT_MASK) <<
-	       IPU_PRG_HEIGHT_IPU_HEIGHT_SHIFT);
-	writel(val, prg->regs + IPU_PRG_HEIGHT(prg_chan));
-
-	val = ipu_pre_get_baddr(prg->pres[chan->used_pre]);
-	*eba = val;
-	writel(val, prg->regs + IPU_PRG_BADDR(prg_chan));
-
-	val = readl(prg->regs + IPU_PRG_CTL);
-	/* config AXI ID */
-	val &= ~(IPU_PRG_CTL_SOFT_ARID_MASK <<
-		 IPU_PRG_CTL_SOFT_ARID_SHIFT(prg_chan));
-	val |= IPU_PRG_CTL_SOFT_ARID(prg_chan, axi_id);
-	/* enable channel */
-	val &= ~IPU_PRG_CTL_BYPASS(prg_chan);
-	writel(val, prg->regs + IPU_PRG_CTL);
-
-	val = IPU_PRG_REG_UPDATE_REG_UPDATE;
-	writel(val, prg->regs + IPU_PRG_REG_UPDATE);
-
-	/* wait for both double buffers to be filled */
-	readl_poll_timeout(prg->regs + IPU_PRG_STATUS, val,
-			   (val & IPU_PRG_STATUS_BUFFER0_READY(prg_chan)) &&
-			   (val & IPU_PRG_STATUS_BUFFER1_READY(prg_chan)),
-			   5, 1000);
-
-	pm_runtime_put(prg->dev);
-
-	chan->enabled = true;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_prg_channel_configure);
-
-static int ipu_prg_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct ipu_prg *prg;
-	u32 val;
-	int i, ret;
-
-	prg = devm_kzalloc(dev, sizeof(*prg), GFP_KERNEL);
-	if (!prg)
-		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	prg->regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(prg->regs))
-		return PTR_ERR(prg->regs);
-
-
-	prg->clk_ipg = devm_clk_get(dev, "ipg");
-	if (IS_ERR(prg->clk_ipg))
-		return PTR_ERR(prg->clk_ipg);
-
-	prg->clk_axi = devm_clk_get(dev, "axi");
-	if (IS_ERR(prg->clk_axi))
-		return PTR_ERR(prg->clk_axi);
-
-	prg->iomuxc_gpr =
-		syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
-	if (IS_ERR(prg->iomuxc_gpr))
-		return PTR_ERR(prg->iomuxc_gpr);
-
-	for (i = 0; i < 3; i++) {
-		prg->pres[i] = ipu_pre_lookup_by_phandle(dev, "fsl,pres", i);
-		if (!prg->pres[i])
-			return -EPROBE_DEFER;
-	}
-
-	ret = clk_prepare_enable(prg->clk_ipg);
-	if (ret)
-		return ret;
-
-	ret = clk_prepare_enable(prg->clk_axi);
-	if (ret) {
-		clk_disable_unprepare(prg->clk_ipg);
-		return ret;
-	}
-
-	/* init to free running mode */
-	val = readl(prg->regs + IPU_PRG_CTL);
-	val |= IPU_PRG_CTL_SHADOW_EN;
-	writel(val, prg->regs + IPU_PRG_CTL);
-
-	/* disable address threshold */
-	writel(0xffffffff, prg->regs + IPU_PRG_THD);
-
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	prg->dev = dev;
-	platform_set_drvdata(pdev, prg);
-	mutex_lock(&ipu_prg_list_mutex);
-	list_add(&prg->list, &ipu_prg_list);
-	mutex_unlock(&ipu_prg_list_mutex);
-
-	return 0;
-}
-
-static int ipu_prg_remove(struct platform_device *pdev)
-{
-	struct ipu_prg *prg = platform_get_drvdata(pdev);
-
-	mutex_lock(&ipu_prg_list_mutex);
-	list_del(&prg->list);
-	mutex_unlock(&ipu_prg_list_mutex);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int prg_suspend(struct device *dev)
-{
-	struct ipu_prg *prg = dev_get_drvdata(dev);
-
-	clk_disable_unprepare(prg->clk_axi);
-	clk_disable_unprepare(prg->clk_ipg);
-
-	return 0;
-}
-
-static int prg_resume(struct device *dev)
-{
-	struct ipu_prg *prg = dev_get_drvdata(dev);
-	int ret;
-
-	ret = clk_prepare_enable(prg->clk_ipg);
-	if (ret)
-		return ret;
-
-	ret = clk_prepare_enable(prg->clk_axi);
-	if (ret) {
-		clk_disable_unprepare(prg->clk_ipg);
-		return ret;
-	}
-
-	return 0;
-}
-#endif
-
-static const struct dev_pm_ops prg_pm_ops = {
-	SET_RUNTIME_PM_OPS(prg_suspend, prg_resume, NULL)
-};
-
-static const struct of_device_id ipu_prg_dt_ids[] = {
-	{ .compatible = "fsl,imx6qp-prg", },
-	{ /* sentinel */ },
-};
-
-struct platform_driver ipu_prg_drv = {
-	.probe		= ipu_prg_probe,
-	.remove		= ipu_prg_remove,
-	.driver		= {
-		.name	= "imx-ipu-prg",
-		.pm	= &prg_pm_ops,
-		.of_match_table = ipu_prg_dt_ids,
-	},
-};
diff --git a/drivers/gpu/ipu-v3/ipu-prv.h b/drivers/gpu/ipu-v3/ipu-prv.h
deleted file mode 100644
index d6beee9..0000000
--- a/drivers/gpu/ipu-v3/ipu-prv.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#ifndef __IPU_PRV_H__
-#define __IPU_PRV_H__
-
-struct ipu_soc;
-
-#include <linux/types.h>
-#include <linux/device.h>
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-
-#include <video/imx-ipu-v3.h>
-
-#define IPU_MCU_T_DEFAULT	8
-#define IPU_CM_IDMAC_REG_OFS	0x00008000
-#define IPU_CM_IC_REG_OFS	0x00020000
-#define IPU_CM_IRT_REG_OFS	0x00028000
-#define IPU_CM_CSI0_REG_OFS	0x00030000
-#define IPU_CM_CSI1_REG_OFS	0x00038000
-#define IPU_CM_SMFC_REG_OFS	0x00050000
-#define IPU_CM_DC_REG_OFS	0x00058000
-#define IPU_CM_DMFC_REG_OFS	0x00060000
-
-/* Register addresses */
-/* IPU Common registers */
-#define IPU_CM_REG(offset)	(offset)
-
-#define IPU_CONF			IPU_CM_REG(0)
-
-#define IPU_SRM_PRI1			IPU_CM_REG(0x00a0)
-#define IPU_SRM_PRI2			IPU_CM_REG(0x00a4)
-#define IPU_FS_PROC_FLOW1		IPU_CM_REG(0x00a8)
-#define IPU_FS_PROC_FLOW2		IPU_CM_REG(0x00ac)
-#define IPU_FS_PROC_FLOW3		IPU_CM_REG(0x00b0)
-#define IPU_FS_DISP_FLOW1		IPU_CM_REG(0x00b4)
-#define IPU_FS_DISP_FLOW2		IPU_CM_REG(0x00b8)
-#define IPU_SKIP			IPU_CM_REG(0x00bc)
-#define IPU_DISP_ALT_CONF		IPU_CM_REG(0x00c0)
-#define IPU_DISP_GEN			IPU_CM_REG(0x00c4)
-#define IPU_DISP_ALT1			IPU_CM_REG(0x00c8)
-#define IPU_DISP_ALT2			IPU_CM_REG(0x00cc)
-#define IPU_DISP_ALT3			IPU_CM_REG(0x00d0)
-#define IPU_DISP_ALT4			IPU_CM_REG(0x00d4)
-#define IPU_SNOOP			IPU_CM_REG(0x00d8)
-#define IPU_MEM_RST			IPU_CM_REG(0x00dc)
-#define IPU_PM				IPU_CM_REG(0x00e0)
-#define IPU_GPR				IPU_CM_REG(0x00e4)
-#define IPU_CHA_DB_MODE_SEL(ch)		IPU_CM_REG(0x0150 + 4 * ((ch) / 32))
-#define IPU_ALT_CHA_DB_MODE_SEL(ch)	IPU_CM_REG(0x0168 + 4 * ((ch) / 32))
-#define IPU_CHA_CUR_BUF(ch)		IPU_CM_REG(0x023C + 4 * ((ch) / 32))
-#define IPU_ALT_CUR_BUF0		IPU_CM_REG(0x0244)
-#define IPU_ALT_CUR_BUF1		IPU_CM_REG(0x0248)
-#define IPU_SRM_STAT			IPU_CM_REG(0x024C)
-#define IPU_PROC_TASK_STAT		IPU_CM_REG(0x0250)
-#define IPU_DISP_TASK_STAT		IPU_CM_REG(0x0254)
-#define IPU_CHA_BUF0_RDY(ch)		IPU_CM_REG(0x0268 + 4 * ((ch) / 32))
-#define IPU_CHA_BUF1_RDY(ch)		IPU_CM_REG(0x0270 + 4 * ((ch) / 32))
-#define IPU_CHA_BUF2_RDY(ch)		IPU_CM_REG(0x0288 + 4 * ((ch) / 32))
-#define IPU_ALT_CHA_BUF0_RDY(ch)	IPU_CM_REG(0x0278 + 4 * ((ch) / 32))
-#define IPU_ALT_CHA_BUF1_RDY(ch)	IPU_CM_REG(0x0280 + 4 * ((ch) / 32))
-
-#define IPU_INT_CTRL(n)		IPU_CM_REG(0x003C + 4 * (n))
-#define IPU_INT_STAT(n)		IPU_CM_REG(0x0200 + 4 * (n))
-
-/* SRM_PRI2 */
-#define DP_S_SRM_MODE_MASK		(0x3 << 3)
-#define DP_S_SRM_MODE_NOW		(0x3 << 3)
-#define DP_S_SRM_MODE_NEXT_FRAME	(0x1 << 3)
-
-/* FS_PROC_FLOW1 */
-#define FS_PRPENC_ROT_SRC_SEL_MASK	(0xf << 0)
-#define FS_PRPENC_ROT_SRC_SEL_ENC		(0x7 << 0)
-#define FS_PRPVF_ROT_SRC_SEL_MASK	(0xf << 8)
-#define FS_PRPVF_ROT_SRC_SEL_VF			(0x8 << 8)
-#define FS_PP_SRC_SEL_MASK		(0xf << 12)
-#define FS_PP_ROT_SRC_SEL_MASK		(0xf << 16)
-#define FS_PP_ROT_SRC_SEL_PP			(0x5 << 16)
-#define FS_VDI1_SRC_SEL_MASK		(0x3 << 20)
-#define FS_VDI3_SRC_SEL_MASK		(0x3 << 20)
-#define FS_PRP_SRC_SEL_MASK		(0xf << 24)
-#define FS_VDI_SRC_SEL_MASK		(0x3 << 28)
-#define FS_VDI_SRC_SEL_CSI_DIRECT		(0x1 << 28)
-#define FS_VDI_SRC_SEL_VDOA			(0x2 << 28)
-
-/* FS_PROC_FLOW2 */
-#define FS_PRP_ENC_DEST_SEL_MASK	(0xf << 0)
-#define FS_PRP_ENC_DEST_SEL_IRT_ENC		(0x1 << 0)
-#define FS_PRPVF_DEST_SEL_MASK		(0xf << 4)
-#define FS_PRPVF_DEST_SEL_IRT_VF		(0x1 << 4)
-#define FS_PRPVF_ROT_DEST_SEL_MASK	(0xf << 8)
-#define FS_PP_DEST_SEL_MASK		(0xf << 12)
-#define FS_PP_DEST_SEL_IRT_PP			(0x3 << 12)
-#define FS_PP_ROT_DEST_SEL_MASK		(0xf << 16)
-#define FS_PRPENC_ROT_DEST_SEL_MASK	(0xf << 20)
-#define FS_PRP_DEST_SEL_MASK		(0xf << 24)
-
-#define IPU_DI0_COUNTER_RELEASE			(1 << 24)
-#define IPU_DI1_COUNTER_RELEASE			(1 << 25)
-
-#define IPU_IDMAC_REG(offset)	(offset)
-
-#define IDMAC_CONF			IPU_IDMAC_REG(0x0000)
-#define IDMAC_CHA_EN(ch)		IPU_IDMAC_REG(0x0004 + 4 * ((ch) / 32))
-#define IDMAC_SEP_ALPHA			IPU_IDMAC_REG(0x000c)
-#define IDMAC_ALT_SEP_ALPHA		IPU_IDMAC_REG(0x0010)
-#define IDMAC_CHA_PRI(ch)		IPU_IDMAC_REG(0x0014 + 4 * ((ch) / 32))
-#define IDMAC_WM_EN(ch)			IPU_IDMAC_REG(0x001c + 4 * ((ch) / 32))
-#define IDMAC_CH_LOCK_EN_1		IPU_IDMAC_REG(0x0024)
-#define IDMAC_CH_LOCK_EN_2		IPU_IDMAC_REG(0x0028)
-#define IDMAC_SUB_ADDR_0		IPU_IDMAC_REG(0x002c)
-#define IDMAC_SUB_ADDR_1		IPU_IDMAC_REG(0x0030)
-#define IDMAC_SUB_ADDR_2		IPU_IDMAC_REG(0x0034)
-#define IDMAC_BAND_EN(ch)		IPU_IDMAC_REG(0x0040 + 4 * ((ch) / 32))
-#define IDMAC_CHA_BUSY(ch)		IPU_IDMAC_REG(0x0100 + 4 * ((ch) / 32))
-
-#define IPU_NUM_IRQS	(32 * 15)
-
-enum ipu_modules {
-	IPU_CONF_CSI0_EN		= (1 << 0),
-	IPU_CONF_CSI1_EN		= (1 << 1),
-	IPU_CONF_IC_EN			= (1 << 2),
-	IPU_CONF_ROT_EN			= (1 << 3),
-	IPU_CONF_ISP_EN			= (1 << 4),
-	IPU_CONF_DP_EN			= (1 << 5),
-	IPU_CONF_DI0_EN			= (1 << 6),
-	IPU_CONF_DI1_EN			= (1 << 7),
-	IPU_CONF_SMFC_EN		= (1 << 8),
-	IPU_CONF_DC_EN			= (1 << 9),
-	IPU_CONF_DMFC_EN		= (1 << 10),
-
-	IPU_CONF_VDI_EN			= (1 << 12),
-
-	IPU_CONF_IDMAC_DIS		= (1 << 22),
-
-	IPU_CONF_IC_DMFC_SEL		= (1 << 25),
-	IPU_CONF_IC_DMFC_SYNC		= (1 << 26),
-	IPU_CONF_VDI_DMFC_SYNC		= (1 << 27),
-
-	IPU_CONF_CSI0_DATA_SOURCE	= (1 << 28),
-	IPU_CONF_CSI1_DATA_SOURCE	= (1 << 29),
-	IPU_CONF_IC_INPUT		= (1 << 30),
-	IPU_CONF_CSI_SEL		= (1 << 31),
-};
-
-struct ipuv3_channel {
-	unsigned int num;
-	struct ipu_soc *ipu;
-	struct list_head list;
-};
-
-struct ipu_cpmem;
-struct ipu_csi;
-struct ipu_dc_priv;
-struct ipu_dmfc_priv;
-struct ipu_di;
-struct ipu_ic_priv;
-struct ipu_vdi;
-struct ipu_image_convert_priv;
-struct ipu_smfc_priv;
-struct ipu_pre;
-struct ipu_prg;
-
-struct ipu_devtype;
-
-struct ipu_soc {
-	struct device		*dev;
-	const struct ipu_devtype	*devtype;
-	enum ipuv3_type		ipu_type;
-	spinlock_t		lock;
-	struct mutex		channel_lock;
-	struct list_head	channels;
-
-	void __iomem		*cm_reg;
-	void __iomem		*idmac_reg;
-
-	int			id;
-	int			usecount;
-
-	struct clk		*clk;
-
-	int			irq_sync;
-	int			irq_err;
-	struct irq_domain	*domain;
-
-	struct ipu_cpmem	*cpmem_priv;
-	struct ipu_dc_priv	*dc_priv;
-	struct ipu_dp_priv	*dp_priv;
-	struct ipu_dmfc_priv	*dmfc_priv;
-	struct ipu_di		*di_priv[2];
-	struct ipu_csi		*csi_priv[2];
-	struct ipu_ic_priv	*ic_priv;
-	struct ipu_vdi          *vdi_priv;
-	struct ipu_image_convert_priv *image_convert_priv;
-	struct ipu_smfc_priv	*smfc_priv;
-	struct ipu_prg		*prg_priv;
-};
-
-static inline u32 ipu_idmac_read(struct ipu_soc *ipu, unsigned offset)
-{
-	return readl(ipu->idmac_reg + offset);
-}
-
-static inline void ipu_idmac_write(struct ipu_soc *ipu, u32 value,
-				   unsigned offset)
-{
-	writel(value, ipu->idmac_reg + offset);
-}
-
-void ipu_srm_dp_update(struct ipu_soc *ipu, bool sync);
-
-int ipu_module_enable(struct ipu_soc *ipu, u32 mask);
-int ipu_module_disable(struct ipu_soc *ipu, u32 mask);
-
-bool ipu_idmac_channel_busy(struct ipu_soc *ipu, unsigned int chno);
-
-int ipu_csi_init(struct ipu_soc *ipu, struct device *dev, int id,
-		 unsigned long base, u32 module, struct clk *clk_ipu);
-void ipu_csi_exit(struct ipu_soc *ipu, int id);
-
-int ipu_ic_init(struct ipu_soc *ipu, struct device *dev,
-		unsigned long base, unsigned long tpmem_base);
-void ipu_ic_exit(struct ipu_soc *ipu);
-
-int ipu_vdi_init(struct ipu_soc *ipu, struct device *dev,
-		 unsigned long base, u32 module);
-void ipu_vdi_exit(struct ipu_soc *ipu);
-
-int ipu_image_convert_init(struct ipu_soc *ipu, struct device *dev);
-void ipu_image_convert_exit(struct ipu_soc *ipu);
-
-int ipu_di_init(struct ipu_soc *ipu, struct device *dev, int id,
-		unsigned long base, u32 module, struct clk *ipu_clk);
-void ipu_di_exit(struct ipu_soc *ipu, int id);
-
-int ipu_dmfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,
-		struct clk *ipu_clk);
-void ipu_dmfc_exit(struct ipu_soc *ipu);
-
-int ipu_dp_init(struct ipu_soc *ipu, struct device *dev, unsigned long base);
-void ipu_dp_exit(struct ipu_soc *ipu);
-
-int ipu_dc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base,
-		unsigned long template_base);
-void ipu_dc_exit(struct ipu_soc *ipu);
-
-int ipu_cpmem_init(struct ipu_soc *ipu, struct device *dev, unsigned long base);
-void ipu_cpmem_exit(struct ipu_soc *ipu);
-
-int ipu_smfc_init(struct ipu_soc *ipu, struct device *dev, unsigned long base);
-void ipu_smfc_exit(struct ipu_soc *ipu);
-
-struct ipu_pre *ipu_pre_lookup_by_phandle(struct device *dev, const char *name,
-					  int index);
-int ipu_pre_get_available_count(void);
-int ipu_pre_get(struct ipu_pre *pre);
-void ipu_pre_put(struct ipu_pre *pre);
-u32 ipu_pre_get_baddr(struct ipu_pre *pre);
-void ipu_pre_configure(struct ipu_pre *pre, unsigned int width,
-		       unsigned int height, unsigned int stride, u32 format,
-		       uint64_t modifier, unsigned int bufaddr);
-void ipu_pre_update(struct ipu_pre *pre, unsigned int bufaddr);
-
-struct ipu_prg *ipu_prg_lookup_by_phandle(struct device *dev, const char *name,
-					  int ipu_id);
-
-extern struct platform_driver ipu_pre_drv;
-extern struct platform_driver ipu_prg_drv;
-
-#endif				/* __IPU_PRV_H__ */
diff --git a/drivers/gpu/ipu-v3/ipu-smfc.c b/drivers/gpu/ipu-v3/ipu-smfc.c
deleted file mode 100644
index 4ef9109..0000000
--- a/drivers/gpu/ipu-v3/ipu-smfc.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#include <linux/export.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/errno.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <video/imx-ipu-v3.h>
-
-#include "ipu-prv.h"
-
-struct ipu_smfc {
-	struct ipu_smfc_priv *priv;
-	int chno;
-	bool inuse;
-};
-
-struct ipu_smfc_priv {
-	void __iomem *base;
-	spinlock_t lock;
-	struct ipu_soc *ipu;
-	struct ipu_smfc channel[4];
-	int use_count;
-};
-
-/*SMFC Registers */
-#define SMFC_MAP	0x0000
-#define SMFC_WMC	0x0004
-#define SMFC_BS		0x0008
-
-int ipu_smfc_set_burstsize(struct ipu_smfc *smfc, int burstsize)
-{
-	struct ipu_smfc_priv *priv = smfc->priv;
-	unsigned long flags;
-	u32 val, shift;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	shift = smfc->chno * 4;
-	val = readl(priv->base + SMFC_BS);
-	val &= ~(0xf << shift);
-	val |= burstsize << shift;
-	writel(val, priv->base + SMFC_BS);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_set_burstsize);
-
-int ipu_smfc_map_channel(struct ipu_smfc *smfc, int csi_id, int mipi_id)
-{
-	struct ipu_smfc_priv *priv = smfc->priv;
-	unsigned long flags;
-	u32 val, shift;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	shift = smfc->chno * 3;
-	val = readl(priv->base + SMFC_MAP);
-	val &= ~(0x7 << shift);
-	val |= ((csi_id << 2) | mipi_id) << shift;
-	writel(val, priv->base + SMFC_MAP);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_map_channel);
-
-int ipu_smfc_set_watermark(struct ipu_smfc *smfc, u32 set_level, u32 clr_level)
-{
-	struct ipu_smfc_priv *priv = smfc->priv;
-	unsigned long flags;
-	u32 val, shift;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	shift = smfc->chno * 6 + (smfc->chno > 1 ? 4 : 0);
-	val = readl(priv->base + SMFC_WMC);
-	val &= ~(0x3f << shift);
-	val |= ((clr_level << 3) | set_level) << shift;
-	writel(val, priv->base + SMFC_WMC);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_set_watermark);
-
-int ipu_smfc_enable(struct ipu_smfc *smfc)
-{
-	struct ipu_smfc_priv *priv = smfc->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (!priv->use_count)
-		ipu_module_enable(priv->ipu, IPU_CONF_SMFC_EN);
-
-	priv->use_count++;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_enable);
-
-int ipu_smfc_disable(struct ipu_smfc *smfc)
-{
-	struct ipu_smfc_priv *priv = smfc->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	priv->use_count--;
-
-	if (!priv->use_count)
-		ipu_module_disable(priv->ipu, IPU_CONF_SMFC_EN);
-
-	if (priv->use_count < 0)
-		priv->use_count = 0;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_disable);
-
-struct ipu_smfc *ipu_smfc_get(struct ipu_soc *ipu, unsigned int chno)
-{
-	struct ipu_smfc_priv *priv = ipu->smfc_priv;
-	struct ipu_smfc *smfc, *ret;
-	unsigned long flags;
-
-	if (chno >= 4)
-		return ERR_PTR(-EINVAL);
-
-	smfc = &priv->channel[chno];
-	ret = smfc;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (smfc->inuse) {
-		ret = ERR_PTR(-EBUSY);
-		goto unlock;
-	}
-
-	smfc->inuse = true;
-unlock:
-	spin_unlock_irqrestore(&priv->lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_get);
-
-void ipu_smfc_put(struct ipu_smfc *smfc)
-{
-	struct ipu_smfc_priv *priv = smfc->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	smfc->inuse = false;
-	spin_unlock_irqrestore(&priv->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_smfc_put);
-
-int ipu_smfc_init(struct ipu_soc *ipu, struct device *dev,
-		  unsigned long base)
-{
-	struct ipu_smfc_priv *priv;
-	int i;
-
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	ipu->smfc_priv = priv;
-	spin_lock_init(&priv->lock);
-	priv->ipu = ipu;
-
-	priv->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!priv->base)
-		return -ENOMEM;
-
-	for (i = 0; i < 4; i++) {
-		priv->channel[i].priv = priv;
-		priv->channel[i].chno = i;
-	}
-
-	pr_debug("%s: ioremap 0x%08lx -> %p\n", __func__, base, priv->base);
-
-	return 0;
-}
-
-void ipu_smfc_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/gpu/ipu-v3/ipu-vdi.c b/drivers/gpu/ipu-v3/ipu-vdi.c
deleted file mode 100644
index a663893..0000000
--- a/drivers/gpu/ipu-v3/ipu-vdi.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (C) 2012-2016 Mentor Graphics Inc.
- * Copyright (C) 2005-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#include <linux/io.h>
-#include "ipu-prv.h"
-
-struct ipu_vdi {
-	void __iomem *base;
-	u32 module;
-	spinlock_t lock;
-	int use_count;
-	struct ipu_soc *ipu;
-};
-
-
-/* VDI Register Offsets */
-#define VDI_FSIZE 0x0000
-#define VDI_C     0x0004
-
-/* VDI Register Fields */
-#define VDI_C_CH_420             (0 << 1)
-#define VDI_C_CH_422             (1 << 1)
-#define VDI_C_MOT_SEL_MASK       (0x3 << 2)
-#define VDI_C_MOT_SEL_FULL       (2 << 2)
-#define VDI_C_MOT_SEL_LOW        (1 << 2)
-#define VDI_C_MOT_SEL_MED        (0 << 2)
-#define VDI_C_BURST_SIZE1_4      (3 << 4)
-#define VDI_C_BURST_SIZE2_4      (3 << 8)
-#define VDI_C_BURST_SIZE3_4      (3 << 12)
-#define VDI_C_BURST_SIZE_MASK    0xF
-#define VDI_C_BURST_SIZE1_OFFSET 4
-#define VDI_C_BURST_SIZE2_OFFSET 8
-#define VDI_C_BURST_SIZE3_OFFSET 12
-#define VDI_C_VWM1_SET_1         (0 << 16)
-#define VDI_C_VWM1_SET_2         (1 << 16)
-#define VDI_C_VWM1_CLR_2         (1 << 19)
-#define VDI_C_VWM3_SET_1         (0 << 22)
-#define VDI_C_VWM3_SET_2         (1 << 22)
-#define VDI_C_VWM3_CLR_2         (1 << 25)
-#define VDI_C_TOP_FIELD_MAN_1    (1 << 30)
-#define VDI_C_TOP_FIELD_AUTO_1   (1 << 31)
-
-static inline u32 ipu_vdi_read(struct ipu_vdi *vdi, unsigned int offset)
-{
-	return readl(vdi->base + offset);
-}
-
-static inline void ipu_vdi_write(struct ipu_vdi *vdi, u32 value,
-				 unsigned int offset)
-{
-	writel(value, vdi->base + offset);
-}
-
-void ipu_vdi_set_field_order(struct ipu_vdi *vdi, v4l2_std_id std, u32 field)
-{
-	bool top_field_0 = false;
-	unsigned long flags;
-	u32 reg;
-
-	switch (field) {
-	case V4L2_FIELD_INTERLACED_TB:
-	case V4L2_FIELD_SEQ_TB:
-	case V4L2_FIELD_TOP:
-		top_field_0 = true;
-		break;
-	case V4L2_FIELD_INTERLACED_BT:
-	case V4L2_FIELD_SEQ_BT:
-	case V4L2_FIELD_BOTTOM:
-		top_field_0 = false;
-		break;
-	default:
-		top_field_0 = (std & V4L2_STD_525_60) ? true : false;
-		break;
-	}
-
-	spin_lock_irqsave(&vdi->lock, flags);
-
-	reg = ipu_vdi_read(vdi, VDI_C);
-	if (top_field_0)
-		reg &= ~(VDI_C_TOP_FIELD_MAN_1 | VDI_C_TOP_FIELD_AUTO_1);
-	else
-		reg |= VDI_C_TOP_FIELD_MAN_1 | VDI_C_TOP_FIELD_AUTO_1;
-	ipu_vdi_write(vdi, reg, VDI_C);
-
-	spin_unlock_irqrestore(&vdi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_set_field_order);
-
-void ipu_vdi_set_motion(struct ipu_vdi *vdi, enum ipu_motion_sel motion_sel)
-{
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&vdi->lock, flags);
-
-	reg = ipu_vdi_read(vdi, VDI_C);
-
-	reg &= ~VDI_C_MOT_SEL_MASK;
-
-	switch (motion_sel) {
-	case MED_MOTION:
-		reg |= VDI_C_MOT_SEL_MED;
-		break;
-	case HIGH_MOTION:
-		reg |= VDI_C_MOT_SEL_FULL;
-		break;
-	default:
-		reg |= VDI_C_MOT_SEL_LOW;
-		break;
-	}
-
-	ipu_vdi_write(vdi, reg, VDI_C);
-
-	spin_unlock_irqrestore(&vdi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_set_motion);
-
-void ipu_vdi_setup(struct ipu_vdi *vdi, u32 code, int xres, int yres)
-{
-	unsigned long flags;
-	u32 pixel_fmt, reg;
-
-	spin_lock_irqsave(&vdi->lock, flags);
-
-	reg = ((yres - 1) << 16) | (xres - 1);
-	ipu_vdi_write(vdi, reg, VDI_FSIZE);
-
-	/*
-	 * Full motion, only vertical filter is used.
-	 * Burst size is 4 accesses
-	 */
-	if (code == MEDIA_BUS_FMT_UYVY8_2X8 ||
-	    code == MEDIA_BUS_FMT_UYVY8_1X16 ||
-	    code == MEDIA_BUS_FMT_YUYV8_2X8 ||
-	    code == MEDIA_BUS_FMT_YUYV8_1X16)
-		pixel_fmt = VDI_C_CH_422;
-	else
-		pixel_fmt = VDI_C_CH_420;
-
-	reg = ipu_vdi_read(vdi, VDI_C);
-	reg |= pixel_fmt;
-	reg |= VDI_C_BURST_SIZE2_4;
-	reg |= VDI_C_BURST_SIZE1_4 | VDI_C_VWM1_CLR_2;
-	reg |= VDI_C_BURST_SIZE3_4 | VDI_C_VWM3_CLR_2;
-	ipu_vdi_write(vdi, reg, VDI_C);
-
-	spin_unlock_irqrestore(&vdi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_setup);
-
-void ipu_vdi_unsetup(struct ipu_vdi *vdi)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vdi->lock, flags);
-	ipu_vdi_write(vdi, 0, VDI_FSIZE);
-	ipu_vdi_write(vdi, 0, VDI_C);
-	spin_unlock_irqrestore(&vdi->lock, flags);
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_unsetup);
-
-int ipu_vdi_enable(struct ipu_vdi *vdi)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vdi->lock, flags);
-
-	if (!vdi->use_count)
-		ipu_module_enable(vdi->ipu, vdi->module);
-
-	vdi->use_count++;
-
-	spin_unlock_irqrestore(&vdi->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_enable);
-
-int ipu_vdi_disable(struct ipu_vdi *vdi)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vdi->lock, flags);
-
-	if (vdi->use_count) {
-		if (!--vdi->use_count)
-			ipu_module_disable(vdi->ipu, vdi->module);
-	}
-
-	spin_unlock_irqrestore(&vdi->lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_disable);
-
-struct ipu_vdi *ipu_vdi_get(struct ipu_soc *ipu)
-{
-	return ipu->vdi_priv;
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_get);
-
-void ipu_vdi_put(struct ipu_vdi *vdi)
-{
-}
-EXPORT_SYMBOL_GPL(ipu_vdi_put);
-
-int ipu_vdi_init(struct ipu_soc *ipu, struct device *dev,
-		 unsigned long base, u32 module)
-{
-	struct ipu_vdi *vdi;
-
-	vdi = devm_kzalloc(dev, sizeof(*vdi), GFP_KERNEL);
-	if (!vdi)
-		return -ENOMEM;
-
-	ipu->vdi_priv = vdi;
-
-	spin_lock_init(&vdi->lock);
-	vdi->module = module;
-	vdi->base = devm_ioremap(dev, base, PAGE_SIZE);
-	if (!vdi->base)
-		return -ENOMEM;
-
-	dev_dbg(dev, "VDI base: 0x%08lx remapped to %p\n", base, vdi->base);
-	vdi->ipu = ipu;
-
-	return 0;
-}
-
-void ipu_vdi_exit(struct ipu_soc *ipu)
-{
-}
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 974febf..3ba39b94d 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -14,8 +14,7 @@ source "drivers/char/agp/Kconfig"
 source "drivers/gpu/vga/Kconfig"
 
 source "drivers/gpu/host1x/Kconfig"
-source "drivers/gpu/ipu-v3/Kconfig"
-source "drivers/gpu/dpu/Kconfig"
+source "drivers/gpu/imx/Kconfig"
 
 source "drivers/gpu/drm/Kconfig"
 
-- 
1.7.9.5


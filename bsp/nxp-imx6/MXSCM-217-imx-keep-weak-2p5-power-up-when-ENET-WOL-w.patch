From 01e1086d71e6c6e27983396fdca533cab6e14b65 Mon Sep 17 00:00:00 2001
From: Juan Gutierrez <juan.gutierrez@nxp.com>
Date: Thu, 3 Nov 2016 18:06:21 -0500
Subject: [PATCH 1335/5242] MXSCM-217 imx: keep weak 2p5 power up when ENET
 WOL wakeup is enabled

commit  fe1ca0b161ea053e1091f287b4c0c6966be6eec6 from
https://source.codeaurora.org/external/imx/linux-imx.git

When ENET wake up is enabled by wake-on-lan (WOL), the weak 2P5
ldo needs to keep power up even for LPDDR2 due to the ENET_PLL is
feed by the weak 2p5 ldo during DSM. If the weak 2P5 ldo is power
down the ENET module is power off hence it is not able to sense the
WOL interrupt and trigger the system resume.

Signed-off-by: Juan Gutierrez <juan.gutierrez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/anatop.c |    4 ++--
 arch/arm/mach-imx/common.h |    1 +
 arch/arm/mach-imx/gpc.c    |   14 ++++++++++++++
 3 files changed, 17 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-imx/anatop.c b/arch/arm/mach-imx/anatop.c
index 25be1e5..d66b886 100644
--- a/arch/arm/mach-imx/anatop.c
+++ b/arch/arm/mach-imx/anatop.c
@@ -151,7 +151,7 @@ void imx_anatop_pre_suspend(void)
 
 	if ((imx_mmdc_get_ddr_type() == IMX_DDR_TYPE_LPDDR2 ||
 		imx_mmdc_get_ddr_type() == IMX_MMDC_DDR_TYPE_LPDDR3) &&
-		!imx_gpc_usb_wakeup_enabled())
+		!imx_gpc_usb_wakeup_enabled() && !imx_gpc_enet_wakeup_enabled())
 		imx_anatop_enable_2p5_pulldown(true);
 	else
 		imx_anatop_enable_weak2p5(true);
@@ -181,7 +181,7 @@ void imx_anatop_post_resume(void)
 
 	if ((imx_mmdc_get_ddr_type() == IMX_DDR_TYPE_LPDDR2 ||
 		imx_mmdc_get_ddr_type() == IMX_MMDC_DDR_TYPE_LPDDR3) &&
-		!imx_gpc_usb_wakeup_enabled())
+		!imx_gpc_usb_wakeup_enabled() && !imx_gpc_enet_wakeup_enabled())
 		imx_anatop_enable_2p5_pulldown(false);
 	else
 		imx_anatop_enable_weak2p5(false);
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index a6acdf4..1b52de6 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -178,6 +178,7 @@ static void imx_gpcv2_add_m4_wake_up_irq(u32 hwirq, bool enable) {}
 void imx6sl_low_power_idle(void);
 void imx6sll_low_power_idle(void);
 bool imx_gpc_usb_wakeup_enabled(void);
+bool imx_gpc_enet_wakeup_enabled(void);
 
 #ifdef CONFIG_SUSPEND
 void v7_cpu_resume(void);
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 52fe8ab..e0ab680 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -49,6 +49,9 @@
 /* for irq #74 and #75 */
 #define GPC_USB_VBUS_WAKEUP_IRQ_MASK		0xc00
 
+/* for irq #150 and #151 */
+#define GPC_ENET_WAKEUP_IRQ_MASK        0xC00000
+
 static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
@@ -139,6 +142,17 @@ bool imx_gpc_usb_wakeup_enabled(void)
 	return false;
 }
 
+bool imx_gpc_enet_wakeup_enabled(void)
+{
+	if (!cpu_is_imx6q())
+		return false;
+
+	if (gpc_wake_irqs[3] & GPC_ENET_WAKEUP_IRQ_MASK)
+		return true;
+
+	return false;
+}
+
 unsigned int imx_gpc_is_mf_mix_off(void)
 {
 	return readl_relaxed(gpc_base + GPC_PGC_MF_PDN);
-- 
1.7.9.5


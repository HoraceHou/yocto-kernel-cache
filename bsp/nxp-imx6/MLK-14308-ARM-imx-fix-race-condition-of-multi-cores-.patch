From 4808a1d41abc69102b89eca6e9e254c50c5000d3 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Thu, 2 Mar 2017 17:39:12 +0800
Subject: [PATCH 1689/5242] MLK-14308 ARM: imx: fix race condition of
 multi-cores low power idle on i.mx7d

commit  3e9a91b3ae0f2f367d2d32b178a781bc58baad4d from
https://source.codeaurora.org/external/imx/linux-imx.git

On i.MX7D low power idle, consider below scenario which has
race condition that low power idle is entered unexpectedly
for first CPU:

CPU#1 enters low power idle:
	1. set last_cpu to invalid -1;
	2. set cpu1_wfi in low level ASM code;
	3. enter WFI;
CPU#0 enters low power idle:
	4. set last_cpu to CPU#0;
	5. Set hardware(DDR, CCM, ANATOP) to low power idle mode;
	6. enter WFI;

If during 4~6 window, CPU#1 go out of WFI and then go into low
power idle again, the condition check of master_lpi will be true
and CPU#1 will go through 4~6 steps in low level ASM code,
which is unexpected. As cpu_cluster_pm_enter/exit can only be called
once for last cpu in same cluster.

To avoid this race condition, add last_cpu check as well as master_lpi
check, that means if last_cpu is a valid value, the other CPU entering
low power idle will be treated as first CPU. And also move the setting
of last_cpu to invalid value to last CPU low power idle exit path.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/cpuidle-imx7d.c |   14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-imx/cpuidle-imx7d.c b/arch/arm/mach-imx/cpuidle-imx7d.c
index 83d1f48..34d3bd4 100644
--- a/arch/arm/mach-imx/cpuidle-imx7d.c
+++ b/arch/arm/mach-imx/cpuidle-imx7d.c
@@ -105,13 +105,8 @@ static int imx7d_enter_low_power_idle(struct cpuidle_device *dev,
 	} else {
 		imx_gpcv2_set_lpm_mode(WAIT_UNCLOCKED);
 		cpu_pm_enter();
-
-		if (atomic_inc_return(&master_lpi) < num_online_cpus()) {
-			imx_set_cpu_jump(dev->cpu, ca7_cpu_resume);
-			/* initialize the last cpu id to invalid here */
-			cpuidle_pm_info->last_cpu = -1;
-			cpu_suspend(0, imx7d_idle_finish);
-		} else {
+		if (atomic_inc_return(&master_lpi) == num_online_cpus() &&
+			cpuidle_pm_info->last_cpu == -1) {
 			imx_gpcv2_set_cpu_power_gate_in_idle(true);
 			cpu_cluster_pm_enter();
 
@@ -120,6 +115,11 @@ static int imx7d_enter_low_power_idle(struct cpuidle_device *dev,
 
 			cpu_cluster_pm_exit();
 			imx_gpcv2_set_cpu_power_gate_in_idle(false);
+			/* initialize the last cpu id to invalid here */
+			cpuidle_pm_info->last_cpu = -1;
+		} else {
+			imx_set_cpu_jump(dev->cpu, ca7_cpu_resume);
+			cpu_suspend(0, imx7d_idle_finish);
 		}
 		atomic_dec(&master_lpi);
 
-- 
1.7.9.5


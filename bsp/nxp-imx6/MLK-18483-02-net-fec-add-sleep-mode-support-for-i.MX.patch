From 87748367db02e171604a391feceb3f1abc84d2b6 Mon Sep 17 00:00:00 2001
From: Andy Duan <fugang.duan@nxp.com>
Date: Tue, 5 Jun 2018 18:02:46 +0800
Subject: [PATCH 3912/5242] MLK-18483-02 net: fec: add sleep mode support for
 i.MX8QM/QXP

commit  7f6a7145dfffe4dbade59dc3fcf056703e3e8dc8 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add sleep mode support for i.MX8QM/QXP platforms.

Reviewed-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/freescale/fec.h       |    1 +
 drivers/net/ethernet/freescale/fec_fixup.c |   45 ++++++++++++++++++++++++++++
 drivers/net/ethernet/freescale/fec_main.c  |    3 ++
 3 files changed, 49 insertions(+)

diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
index a6f6592..881aea76 100644
--- a/drivers/net/ethernet/freescale/fec.h
+++ b/drivers/net/ethernet/freescale/fec.h
@@ -650,6 +650,7 @@ struct fec_enet_private {
 void fec_enet_register_fixup(struct net_device *ndev);
 int of_fec_enet_parse_fixup(struct device_node *np);
 void fec_enet_get_mac_from_fuse(struct device_node *np, unsigned char *mac);
+void fec_enet_ipg_stop_misc_set(struct device_node *np, bool enabled);
 
 /****************************************************************************/
 #endif /* FEC_H */
diff --git a/drivers/net/ethernet/freescale/fec_fixup.c b/drivers/net/ethernet/freescale/fec_fixup.c
index b78e091..ad47a57 100644
--- a/drivers/net/ethernet/freescale/fec_fixup.c
+++ b/drivers/net/ethernet/freescale/fec_fixup.c
@@ -197,9 +197,38 @@ static void imx8qm_get_mac_from_fuse(int dev_id, unsigned char *mac,
 	mac[4] = val2;
 	mac[5] = val2 >> 8;
 }
+
+static void imx8qm_ipg_stop_enable(int dev_id, bool enabled)
+{
+	uint32_t mu_id;
+	sc_ipc_t ipc_handle;
+	sc_err_t sc_err = SC_ERR_NONE;
+	uint32_t rsrc_id, val;
+
+	sc_err = sc_ipc_getMuID(&mu_id);
+	if (sc_err != SC_ERR_NONE) {
+		pr_err("FEC MAC fuse: Get MU ID failed\n");
+		return;
+	}
+
+	sc_err = sc_ipc_open(&ipc_handle, mu_id);
+	if (sc_err != SC_ERR_NONE) {
+		pr_err("FEC MAC fuse: Open MU channel failed\n");
+		return;
+	}
+
+	if (dev_id == 0)
+		rsrc_id = SC_R_ENET_0;
+	else
+		rsrc_id = SC_R_ENET_1;
+
+	val = enabled ? 1 : 0;
+	sc_misc_set_control(ipc_handle, rsrc_id, SC_C_IPG_STOP, val);
+}
 #else
 static void imx8qm_get_mac_from_fuse(int dev_id, unsigned char *mac,
 				     struct imx_fuse_mac_addr *fuse_mapping) {}
+static void imx8qm_ipg_stop_enable(int dev_id, bool enabled) {}
 #endif
 
 void fec_enet_get_mac_from_fuse(struct device_node *np, unsigned char *mac)
@@ -222,3 +251,19 @@ void fec_enet_get_mac_from_fuse(struct device_node *np, unsigned char *mac)
 	else if (of_machine_is_compatible("fsl,imx8mq"))
 		imx8mq_get_mac_from_fuse(idx, mac);
 }
+
+void fec_enet_ipg_stop_misc_set(struct device_node *np, bool enabled)
+{
+	int idx;
+
+	if (!np)
+		return;
+
+	idx = of_alias_get_id(np, "ethernet");
+	if (idx < 0)
+		idx = 0;
+
+	if (of_machine_is_compatible("fsl,imx8qm") ||
+	    of_machine_is_compatible("fsl,imx8qxp"))
+		imx8qm_ipg_stop_enable(idx, enabled);
+}
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 1558f9c..f2c8d26 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -1134,6 +1134,7 @@ static void fec_enet_reset_skb(struct net_device *ndev)
 static int fec_enet_stop_mode(struct fec_enet_private *fep, bool enabled)
 {
 	struct fec_platform_data *pdata = fep->pdev->dev.platform_data;
+	struct device_node *np = fep->pdev->dev.of_node;
 
 	if (fep->gpr.gpr) {
 		if (enabled)
@@ -1146,6 +1147,8 @@ static int fec_enet_stop_mode(struct fec_enet_private *fep, bool enabled)
 					   0);
 	} else if (pdata && pdata->sleep_mode_enable) {
 		pdata->sleep_mode_enable(enabled);
+	} else {
+		fec_enet_ipg_stop_misc_set(np, enabled);
 	}
 
 	return 0;
-- 
1.7.9.5


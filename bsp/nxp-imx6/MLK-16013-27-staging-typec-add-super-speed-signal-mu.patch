From bfc8df4100e7505819e93ff4b493d19d688426cf Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Fri, 28 Jul 2017 01:09:12 +0800
Subject: [PATCH 2306/5242] MLK-16013-27 staging: typec: add super speed
 signal mux selection

commit  13f735b060a4ef9a3e71fa0be701b17013c27d95 from
https://source.codeaurora.org/external/imx/linux-imx.git

According to the polarity of cc line, we need to do USB3 signal mux
selection if it's controlled by software.

Reviewed-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/staging/typec/tcpci.c |   41 +++++++++++++++++++++++++++++++++++++++++
 drivers/usb/typec/tcpm.c      |   11 +++++++++--
 include/linux/usb/tcpm.h      |    2 ++
 3 files changed, 52 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/typec/tcpci.c b/drivers/staging/typec/tcpci.c
index 57fcdd9..ffe1179 100644
--- a/drivers/staging/typec/tcpci.c
+++ b/drivers/staging/typec/tcpci.c
@@ -14,6 +14,7 @@
 #include <linux/usb/pd.h>
 #include <linux/usb/tcpm.h>
 #include <linux/usb/typec.h>
+#include <linux/of_gpio.h>
 
 #include "tcpci.h"
 
@@ -27,6 +28,7 @@ struct tcpci {
 	struct regmap *regmap;
 
 	bool controls_vbus;
+	int ss_sel_gpio;
 
 	struct tcpc_dev tcpc;
 	struct tcpci_data *data;
@@ -270,6 +272,19 @@ static int tcpci_set_polarity(struct tcpc_dev *tcpc,
 	return 0;
 }
 
+static int tcpci_set_ss_mux(struct tcpc_dev *tcpc,
+				enum typec_cc_polarity polarity)
+{
+	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
+
+	if (polarity == TYPEC_POLARITY_CC1)
+		gpio_set_value(tcpci->ss_sel_gpio, 1);
+	else
+		gpio_set_value(tcpci->ss_sel_gpio, 0);
+
+	return 0;
+}
+
 static int tcpci_set_vconn(struct tcpc_dev *tcpc, bool enable)
 {
 	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
@@ -644,6 +659,7 @@ struct tcpci *tcpci_register_port(struct device *dev, struct tcpci_data *data)
 	tcpci->tcpc.vbus_discharge = tcpci_vbus_force_discharge;
 	tcpci->tcpc.get_vbus_vol = tcpci_get_vbus_vol;
 	tcpci->tcpc.bist_mode = tcpci_bist_mode;
+	tcpci->tcpc.ss_mux_sel = tcpci_set_ss_mux;
 
 	tcpci->tcpc.set_pd_rx = tcpci_set_pd_rx;
 	tcpci->tcpc.set_roles = tcpci_set_roles;
@@ -653,6 +669,10 @@ struct tcpci *tcpci_register_port(struct device *dev, struct tcpci_data *data)
 	if (err < 0)
 		return ERR_PTR(err);
 
+	err = tcpci_ss_mux_control_init(tcpci);
+	if (err)
+		return err;
+
 	tcpci->port = tcpm_register_port(tcpci->dev, &tcpci->tcpc);
 	if (PTR_ERR_OR_ZERO(tcpci->port))
 		return ERR_CAST(tcpci->port);
@@ -667,6 +687,27 @@ void tcpci_unregister_port(struct tcpci *tcpci)
 }
 EXPORT_SYMBOL_GPL(tcpci_unregister_port);
 
+static int tcpci_ss_mux_control_init(struct tcpci *tcpci)
+{
+	struct device *dev = tcpci->dev;
+	int retval = 0;
+
+	tcpci->ss_sel_gpio = of_get_named_gpio(dev->of_node,
+						"ss-sel-gpios", 0);
+	if (!gpio_is_valid(tcpci->ss_sel_gpio)) {
+		/* Super speed signal mux conrol gpio is optional */
+		dev_dbg(dev, "no Super Speed mux gpio pin available");
+	} else {
+		retval = devm_gpio_request_one(dev, tcpci->ss_sel_gpio,
+				GPIOF_OUT_INIT_LOW, "typec_ss_sel");
+		if (retval < 0)
+			dev_err(dev, "Unable to request super speed mux gpio %d\n",
+									retval);
+	}
+
+	return retval;
+}
+
 static int tcpci_probe(struct i2c_client *client,
 		       const struct i2c_device_id *i2c_id)
 {
diff --git a/drivers/usb/typec/tcpm.c b/drivers/usb/typec/tcpm.c
index c14b383..0be62b0 100644
--- a/drivers/usb/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -2554,6 +2554,9 @@ static int tcpm_src_attach(struct tcpm_port *port)
 	if (ret < 0)
 		return ret;
 
+	if (port->tcpc->ss_mux_sel)
+		port->tcpc->ss_mux_sel(port->tcpc, polarity);
+
 	tcpm_start_drp_toggling(port);
 
 	ret = tcpm_set_roles(port, true, TYPEC_SOURCE, TYPEC_HOST);
@@ -2669,16 +2672,20 @@ static void tcpm_src_detach(struct tcpm_port *port)
 
 static int tcpm_snk_attach(struct tcpm_port *port)
 {
+	enum typec_cc_polarity polarity = port->cc2 != TYPEC_CC_OPEN ?
+				TYPEC_POLARITY_CC2 : TYPEC_POLARITY_CC1;
 	int ret;
 
 	if (port->attached)
 		return 0;
 
-	ret = tcpm_set_polarity(port, port->cc2 != TYPEC_CC_OPEN ?
-				TYPEC_POLARITY_CC2 : TYPEC_POLARITY_CC1);
+	ret = tcpm_set_polarity(port, polarity);
 	if (ret < 0)
 		return ret;
 
+	if (port->tcpc->ss_mux_sel)
+		port->tcpc->ss_mux_sel(port->tcpc, polarity);
+
 	tcpm_start_drp_toggling(port);
 
 	ret = tcpm_set_roles(port, true, TYPEC_SINK, TYPEC_DEVICE);
diff --git a/include/linux/usb/tcpm.h b/include/linux/usb/tcpm.h
index 9469f87..3b8822b 100644
--- a/include/linux/usb/tcpm.h
+++ b/include/linux/usb/tcpm.h
@@ -166,6 +166,8 @@ struct tcpc_dev {
 	int (*vbus_detect)(struct tcpc_dev *dev, bool enable);
 	int (*vbus_discharge)(struct tcpc_dev *tcpc, bool enable);
 	void (*bist_mode)(struct tcpc_dev *tcpc, bool enable);
+	int (*ss_mux_sel)(struct tcpc_dev *dev,
+				enum typec_cc_polarity polarity);
 
 };
 
-- 
1.7.9.5


From 17c61bf5c8456c19314469b33cfb2893436e616d Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@nxp.com>
Date: Fri, 30 Dec 2016 15:21:28 +0800
Subject: [PATCH 1445/5242] MLK-13706 video: mxsfb: defer fb probe when
 dispdrv is not ready

commit  408710ce8ec212e3ea5816d49fece6931e139acb from
https://source.codeaurora.org/external/imx/linux-imx.git

Some dispdrv depends on several other modules. For example, mipi dsi
depends on gpio and gpio-reset modules. And in some cases, during
the mipi dsi initialization process, the gpio or gpio-reset is not
loaded yet, so defer the fb probing until all the depending modules
loaded completed.

Signed-off-by: Fancy Fang <chen.fang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxc/mipi_dsi_northwest.c |    6 ++++++
 drivers/video/fbdev/mxc/mxc_dispdrv.c        |    4 ++--
 drivers/video/fbdev/mxsfb.c                  |   24 ++++++++++++++++++------
 3 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/drivers/video/fbdev/mxc/mipi_dsi_northwest.c b/drivers/video/fbdev/mxc/mipi_dsi_northwest.c
index 19286ca..d3ce1de 100644
--- a/drivers/video/fbdev/mxc/mipi_dsi_northwest.c
+++ b/drivers/video/fbdev/mxc/mipi_dsi_northwest.c
@@ -154,8 +154,14 @@ static int mipi_dsi_disp_init(struct mxc_dispdrv_handle *disp,
 {
 	struct mipi_dsi_info *mipi_dsi = mxc_dispdrv_getdata(disp);
 	struct device *dev = &mipi_dsi->pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct reset_control *reset = NULL;
 	int ret = 0;
 
+	reset = of_reset_control_get(np, NULL);
+	if (IS_ERR(reset))
+		return PTR_ERR(reset);
+
 	ret = mipi_dsi_lcd_init(mipi_dsi, setting);
 	if (ret) {
 		dev_err(dev, "failed to init mipi dsi lcd\n");
diff --git a/drivers/video/fbdev/mxc/mxc_dispdrv.c b/drivers/video/fbdev/mxc/mxc_dispdrv.c
index d8501eb..77c0d50 100644
--- a/drivers/video/fbdev/mxc/mxc_dispdrv.c
+++ b/drivers/video/fbdev/mxc/mxc_dispdrv.c
@@ -89,7 +89,7 @@ int mxc_dispdrv_unregister(struct mxc_dispdrv_handle *handle)
 struct mxc_dispdrv_handle *mxc_dispdrv_gethandle(char *name,
 	struct mxc_dispdrv_setting *setting)
 {
-	int ret, found = 0;
+	int ret = -ENODEV, found = 0;
 	struct mxc_dispdrv_entry *entry;
 
 	mutex_lock(&dispdrv_lock);
@@ -106,7 +106,7 @@ struct mxc_dispdrv_handle *mxc_dispdrv_gethandle(char *name,
 	}
 	mutex_unlock(&dispdrv_lock);
 
-	return found ? (struct mxc_dispdrv_handle *)entry:ERR_PTR(-ENODEV);
+	return found ? (struct mxc_dispdrv_handle *)entry:ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(mxc_dispdrv_gethandle);
 
diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c
index e4339e6..7f437d2 100644
--- a/drivers/video/fbdev/mxsfb.c
+++ b/drivers/video/fbdev/mxsfb.c
@@ -1283,7 +1283,7 @@ static int mxsfb_init_fbinfo(struct fb_info *fb_info)
 	return 0;
 }
 
-static void mxsfb_dispdrv_init(struct platform_device *pdev,
+static int mxsfb_dispdrv_init(struct platform_device *pdev,
 			      struct fb_info *fbi)
 {
 	struct mxsfb_info *host = fbi->par;
@@ -1298,13 +1298,17 @@ static void mxsfb_dispdrv_init(struct platform_device *pdev,
 
 	host->dispdrv = mxc_dispdrv_gethandle(disp_dev, &setting);
 	if (IS_ERR(host->dispdrv)) {
+		if (PTR_ERR(host->dispdrv) == -EPROBE_DEFER)
+			return PTR_ERR(host->dispdrv);
+
 		host->dispdrv = NULL;
 		dev_info(dev, "failed to find mxc display driver %s\n",
 			 disp_dev);
-	} else {
+	} else
 		dev_info(dev, "registered mxc display driver %s\n",
 			 disp_dev);
-	}
+
+	return 0;
 }
 
 static void mxsfb_free_videomem(struct fb_info *fb_info)
@@ -1493,7 +1497,13 @@ static int mxsfb_probe(struct platform_device *pdev)
 	if (ret != 0)
 		goto fb_pm_runtime_disable;
 
-	mxsfb_dispdrv_init(pdev, fb_info);
+	ret = mxsfb_dispdrv_init(pdev, fb_info);
+	if (ret != 0) {
+		if (ret == -EPROBE_DEFER)
+			dev_info(&pdev->dev,
+				 "Defer fb probe due to dispdrv not ready\n");
+		goto fb_pm_runtime_disable;
+	}
 
 	if (!host->dispdrv) {
 		pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
@@ -1533,10 +1543,12 @@ static int mxsfb_probe(struct platform_device *pdev)
 fb_unregister:
 	unregister_framebuffer(fb_info);
 fb_destroy:
-	if (host->enabled)
-		clk_disable_unprepare(host->clk_pix);
 	fb_destroy_modelist(&fb_info->modelist);
 fb_pm_runtime_disable:
+	clk_disable_pix(host);
+	clk_disable_axi(host);
+	clk_disable_disp_axi(host);
+
 	pm_runtime_disable(&host->pdev->dev);
 	devm_kfree(&pdev->dev, fb_info->pseudo_palette);
 fb_release:
-- 
1.7.9.5


From 737da80fef2c7f9237f60dc4d006462c40480556 Mon Sep 17 00:00:00 2001
From: Weiguang Kong <weiguang.kong@nxp.com>
Date: Wed, 18 Apr 2018 23:36:37 +0800
Subject: [PATCH 3696/5242] MLK-17747: dsp: use the name of dsp instead of
 hifi

commit  a8393121b0cbeebad8c01404569da1370e3c6045 from
https://source.codeaurora.org/external/imx/linux-imx.git

In order to avoid the name problem going forward with
integration with Qcom, Qcom has their own dsp and hifi
is competitor, so the hifi name should not be used in
our code.

So use the name of dsp instead of hifi to fix this
problem.

Signed-off-by: Weiguang Kong <weiguang.kong@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/sound/fsl,dsp.txt          |   16 +
 .../devicetree/bindings/sound/fsl,hifi4.txt        |   16 -
 arch/arm64/boot/dts/freescale/fsl-imx8qxp.dtsi     |   23 +-
 drivers/clk/imx/clk-imx8qxp.c                      |    6 +-
 include/dt-bindings/clock/imx8qxp-clock.h          |    6 +-
 include/dt-bindings/soc/imx8_pd.h                  |    2 +-
 include/soc/imx8/imx8qxp/lpcg.h                    |    2 +-
 include/uapi/linux/mxc_dsp.h                       |  146 +++
 include/uapi/linux/mxc_hifi4.h                     |  145 ---
 sound/soc/fsl/Kconfig                              |    4 +-
 sound/soc/fsl/Makefile                             |    4 +-
 sound/soc/fsl/fsl_dsp.c                            | 1028 ++++++++++++++++++++
 sound/soc/fsl/fsl_dsp.h                            |  139 +++
 sound/soc/fsl/fsl_dsp_proxy.c                      |  702 +++++++++++++
 sound/soc/fsl/fsl_dsp_proxy.h                      |  404 ++++++++
 sound/soc/fsl/fsl_hifi4.c                          | 1028 --------------------
 sound/soc/fsl/fsl_hifi4.h                          |  139 ---
 sound/soc/fsl/fsl_hifi4_proxy.c                    |  702 -------------
 sound/soc/fsl/fsl_hifi4_proxy.h                    |  404 --------
 19 files changed, 2459 insertions(+), 2457 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/fsl,dsp.txt
 delete mode 100644 Documentation/devicetree/bindings/sound/fsl,hifi4.txt
 create mode 100644 include/uapi/linux/mxc_dsp.h
 delete mode 100644 include/uapi/linux/mxc_hifi4.h
 create mode 100644 sound/soc/fsl/fsl_dsp.c
 create mode 100644 sound/soc/fsl/fsl_dsp.h
 create mode 100644 sound/soc/fsl/fsl_dsp_proxy.c
 create mode 100644 sound/soc/fsl/fsl_dsp_proxy.h
 delete mode 100644 sound/soc/fsl/fsl_hifi4.c
 delete mode 100644 sound/soc/fsl/fsl_hifi4.h
 delete mode 100644 sound/soc/fsl/fsl_hifi4_proxy.c
 delete mode 100644 sound/soc/fsl/fsl_hifi4_proxy.h

diff --git a/Documentation/devicetree/bindings/sound/fsl,dsp.txt b/Documentation/devicetree/bindings/sound/fsl,dsp.txt
new file mode 100644
index 0000000..84bc228
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/fsl,dsp.txt
@@ -0,0 +1,16 @@
+NXP DSP
+
+The IP is from Cadence.
+
+Required properties:
+
+  - compatible	: Contains "fsl,imx8qxp-dsp".
+  - reg		: Offset and length of the register set for the device.
+
+Example:
+
+dsp:  dsp@596e8000 {
+	compatible = "fsl,imx8qxp-dsp";
+	reg = <0x0 0x596e8000 0x0 0x88000>;
+	status = "okay";
+};
diff --git a/Documentation/devicetree/bindings/sound/fsl,hifi4.txt b/Documentation/devicetree/bindings/sound/fsl,hifi4.txt
deleted file mode 100644
index a82b25a..0000000
--- a/Documentation/devicetree/bindings/sound/fsl,hifi4.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-NXP HIFI4 DSP (HIFI4)
-
-The IP is from Cadence.
-
-Required properties:
-
-  - compatible	: Contains "fsl,imx8qxp-hifi4".
-  - reg		: Offset and length of the register set for the device.
-
-Example:
-
-hifi4:  hifi4@596e8000 {
-	compatible = "fsl,imx8qxp-hifi4";
-	reg = <0x0 0x596e8000 0x0 0x88000>;
-	status = "okay";
-};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8qxp.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8qxp.dtsi
index ff349f7..21b90cc 100644
--- a/arch/arm64/boot/dts/freescale/fsl-imx8qxp.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8qxp.dtsi
@@ -69,7 +69,7 @@
 		#size-cells = <2>;
 		ranges;
 
-		hifi4_reserved: hifi4@0x8e000000 {
+		dsp_reserved: dsp@0x8e000000 {
 			no-map;
 			reg = <0 0x8e000000 0 0x1ffffff>;
 		};
@@ -124,12 +124,13 @@
 	};
 
 	mu13: mu13@5d280000 {
-		compatible = "fsl,imx8-mu-hifi";
+		compatible = "fsl,imx8-mu-dsp";
 		reg = <0x0 0x5d280000 0x0 0x10000>;
 		interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH>;
-		fsl,hifi_ap_mu_id = <13>;
+		fsl,dsp_ap_mu_id = <13>;
 		status = "okay";
 	};
+
 	mu_m4: mu_m4@37440000 {
 		compatible = "fsl,imx8-mu0-vpu-m4";
 		reg = <0x0 0x37440000 0x0 0x10000>;
@@ -547,12 +548,12 @@
 				};
 			};
 
-			pd_hifi: PD_AUD_HIFI {
+			pd_dsp: PD_AUD_DSP {
 				reg = <SC_R_DSP>;
 				#power-domain-cells = <0>;
 				power-domains =<&pd_audio>;
 			};
-			pd_hifi_ram: PD_AUD_OCRAM {
+			pd_dsp_ram: PD_AUD_OCRAM {
 				reg = <SC_R_DSP_RAM>;
 				#power-domain-cells = <0>;
 				power-domains =<&pd_audio>;
@@ -2552,15 +2553,15 @@
 		status = "disabled";
 	};
 
-	hifi4: hifi4@586e8000 {
-		compatible = "fsl,imx8qxp-hifi4";
+	dsp: dsp@586e8000 {
+		compatible = "fsl,imx8qxp-dsp";
 		reg = <0x0 0x596e8000 0x0 0x88000>;
-		clocks = <&clk IMX8QXP_AUD_HIFI_IPG>,
+		clocks = <&clk IMX8QXP_AUD_DSP_IPG>,
 			<&clk IMX8QXP_AUD_OCRAM_IPG>,
-			<&clk IMX8QXP_AUD_HIFI_CORE_CLK>;
+			<&clk IMX8QXP_AUD_DSP_CORE_CLK>;
 		clock-names = "ipg", "ocram", "core";
-		fsl,hifi4-firmware = "imx/hifi/hifi4.bin";
-		power-domains = <&pd_hifi>;
+		fsl,dsp-firmware = "imx/dsp/hifi4.bin";
+		power-domains = <&pd_dsp>;
 	};
 
 	esai0: esai@59010000 {
diff --git a/drivers/clk/imx/clk-imx8qxp.c b/drivers/clk/imx/clk-imx8qxp.c
index f52600d..0b3de52 100644
--- a/drivers/clk/imx/clk-imx8qxp.c
+++ b/drivers/clk/imx/clk-imx8qxp.c
@@ -690,9 +690,9 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 	clks[IMX8QXP_AUD_SPDIF_0_TX_CLK] = imx_clk_gate2_scu("spdif0_tx_clk", "acm_spdif0_mclk_sel", (void __iomem *)(AUD_SPDIF_0_LPCG), 0, FUNCTION_NAME(PD_AUD_SPDIF_0));
 	clks[IMX8QXP_AUD_ASRC_0_IPG]     = imx_clk_gate2_scu("aud_asrc0_ipg", "ipg_aud_clk_root", (void __iomem *)(AUD_ASRC_0_LPCG), 16, FUNCTION_NAME(PD_AUD_ASRC_0));
 	clks[IMX8QXP_AUD_ASRC_1_IPG]     = imx_clk_gate2_scu("aud_asrc1_ipg", "ipg_aud_clk_root", (void __iomem *)(AUD_ASRC_1_LPCG), 16, FUNCTION_NAME(PD_AUD_ASRC_1));
-	clks[IMX8QXP_AUD_HIFI_ADB_ACLK]  = imx_clk_gate2_scu("aud_hifi_adb_aclk", "ipg_aud_clk_root", (void __iomem *)(AUD_HIFI_LPCG), 16, FUNCTION_NAME(PD_AUD_HIFI));
-	clks[IMX8QXP_AUD_HIFI_IPG]       = imx_clk_gate2_scu("aud_hifi_ipg", "ipg_aud_clk_root", (void __iomem *)(AUD_HIFI_LPCG), 20, FUNCTION_NAME(PD_AUD_HIFI));
-	clks[IMX8QXP_AUD_HIFI_CORE_CLK]  = imx_clk_gate2_scu("aud_hifi_core_clk", "ipg_aud_clk_root", (void __iomem *)(AUD_HIFI_LPCG), 28, FUNCTION_NAME(PD_AUD_HIFI));
+	clks[IMX8QXP_AUD_DSP_ADB_ACLK]  = imx_clk_gate2_scu("aud_dsp_adb_aclk", "ipg_aud_clk_root", (void __iomem *)(AUD_DSP_LPCG), 16, FUNCTION_NAME(PD_AUD_DSP));
+	clks[IMX8QXP_AUD_DSP_IPG]       = imx_clk_gate2_scu("aud_dsp_ipg", "ipg_aud_clk_root", (void __iomem *)(AUD_DSP_LPCG), 20, FUNCTION_NAME(PD_AUD_DSP));
+	clks[IMX8QXP_AUD_DSP_CORE_CLK]  = imx_clk_gate2_scu("aud_dsp_core_clk", "ipg_aud_clk_root", (void __iomem *)(AUD_DSP_LPCG), 28, FUNCTION_NAME(PD_AUD_DSP));
 	clks[IMX8QXP_AUD_OCRAM_IPG]      = imx_clk_gate2_scu("aud_ocram_ipg", "ipg_aud_clk_root", (void __iomem *)(AUD_OCRAM_LPCG), 16, FUNCTION_NAME(PD_AUD_OCRAM));
 
 	for (i = 0; i < ARRAY_SIZE(clks); i++)
diff --git a/include/dt-bindings/clock/imx8qxp-clock.h b/include/dt-bindings/clock/imx8qxp-clock.h
index 9d95e7b..dcc085a3 100644
--- a/include/dt-bindings/clock/imx8qxp-clock.h
+++ b/include/dt-bindings/clock/imx8qxp-clock.h
@@ -476,9 +476,9 @@
 #define IMX8QXP_AUD_SPDIF_0_IPG					432
 #define IMX8QXP_AUD_ASRC_0_IPG					433
 #define IMX8QXP_AUD_ASRC_1_IPG					434
-#define IMX8QXP_AUD_HIFI_ADB_ACLK				435
-#define IMX8QXP_AUD_HIFI_IPG					436
-#define IMX8QXP_AUD_HIFI_CORE_CLK				437
+#define IMX8QXP_AUD_DSP_ADB_ACLK				435
+#define IMX8QXP_AUD_DSP_IPG				        436
+#define IMX8QXP_AUD_DSP_CORE_CLK				437
 #define IMX8QXP_AUD_OCRAM_IPG					438
 
 /* DC part2 */
diff --git a/include/dt-bindings/soc/imx8_pd.h b/include/dt-bindings/soc/imx8_pd.h
index 2152f3a..f74a4d3 100644
--- a/include/dt-bindings/soc/imx8_pd.h
+++ b/include/dt-bindings/soc/imx8_pd.h
@@ -145,7 +145,7 @@
 #define PD_AUD_GPT_10               audio_gpt10
 #define PD_AUD_AMIX                 audio_amix
 #define PD_AUD_MQS_0                audio_mqs0
-#define PD_AUD_HIFI                 audio_hifi
+#define PD_AUD_DSP                  audio_dsp
 #define PD_AUD_OCRAM                audio_ocram
 #define PD_AUD_MCLK_OUT_0           audio_mclkout0
 #define PD_AUD_MCLK_OUT_1           audio_mclkout1
diff --git a/include/soc/imx8/imx8qxp/lpcg.h b/include/soc/imx8/imx8qxp/lpcg.h
index 77be9ce..e4cd601 100644
--- a/include/soc/imx8/imx8qxp/lpcg.h
+++ b/include/soc/imx8/imx8qxp/lpcg.h
@@ -149,7 +149,7 @@
 #define     AUD_GPT_8_LPCG          0x594E0000
 #define     AUD_GPT_9_LPCG          0x594F0000
 #define     AUD_GPT_10_LPCG         0x59500000
-#define     AUD_HIFI_LPCG           0x59580000
+#define     AUD_DSP_LPCG            0x59580000
 #define     AUD_OCRAM_LPCG          0x59590000
 #define     AUD_EDMA_0_LPCG         0x595f0000
 #define     AUD_ASRC_1_LPCG         0x59c00000
diff --git a/include/uapi/linux/mxc_dsp.h b/include/uapi/linux/mxc_dsp.h
new file mode 100644
index 0000000..aa721f3
--- /dev/null
+++ b/include/uapi/linux/mxc_dsp.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MXC_DSP_UAPI_H__
+#define __MXC_DSP_UAPI_H__
+
+#define DSP_IOC_MAGIC		'H'
+#define DSP_CLIENT_REGISTER   _IOW(DSP_IOC_MAGIC, 0, unsigned int)
+#define DSP_CLIENT_UNREGISTER _IOW(DSP_IOC_MAGIC, 1, unsigned int)
+#define DSP_IPC_MSG_SEND      _IOW(DSP_IOC_MAGIC, 2, unsigned int)
+#define DSP_IPC_MSG_RECV      _IOW(DSP_IOC_MAGIC, 3, unsigned int)
+#define DSP_GET_SHMEM_INFO    _IOW(DSP_IOC_MAGIC, 4, unsigned int)
+
+#define CODEC_MP3_DEC		1
+#define CODEC_AAC_DEC		2
+#define CODEC_DAB_DEC		3
+#define CODEC_MP2_DEC		4
+#define CODEC_BSAC_DEC		5
+#define CODEC_DRM_DEC		6
+#define CODEC_SBC_DEC		7
+#define CODEC_SBC_ENC		8
+#define CODEC_DEMO_DEC		9
+
+enum DSP_ERROR_TYPE {
+	XA_SUCCESS = 0,
+
+	XA_ERROR_STREAM,
+	XA_PARA_ERROR,
+	XA_INSUFFICIENT_MEM,
+	XA_ERR_UNKNOWN,
+	XA_PROFILE_NOT_SUPPORT,
+	XA_INIT_ERR,
+	XA_NO_OUTPUT,
+
+	XA_NOT_ENOUGH_DATA = 0x100,
+	XA_CAPIBILITY_CHANGE = 0x200,
+	XA_END_OF_STREAM = 0x300, /* no output */
+};
+
+/* Parameter type to Set /Get */
+enum DSP_ParaType {
+/* Set parmameters */
+/* common  */
+	XA_SAMPLERATE = 0,
+	XA_CHANNEL,
+	XA_FRAMED,        /* one whole frame input */
+	XA_DEPTH,
+	XA_CODEC_DATA,
+	XA_BITRATE,
+	XA_DOWNMIX_STEREO,
+	XA_STREAM_TYPE,
+	XA_CHAN_MAP_TABLE,
+	//UNIA_CHANNEL_MASK,
+	XA_TO_STEREO,
+
+/* dedicate for mp3 dec */
+	XA_MP3_DEC_CRC_CHECK = 0x120,
+	XA_MP3_DEC_MCH_ENABLE,
+	XA_MP3_DEC_NONSTD_STRM_SUPPORT,
+
+/* dedicate for bsac dec */
+	XA_BSAC_DEC_DECODELAYERS = 0x130,
+
+/* dedicate for aacplus dec */
+	XA_AACPLUS_DEC_BDOWNSAMPLE = 0x140,
+	XA_AACPLUS_DEC_BBITSTREAMDOWNMIX,
+	XA_AACPLUS_DEC_CHANROUTING,
+
+/* dedicate for dabplus dec */
+	XA_DABPLUS_DEC_BDOWNSAMPLE = 0x150,
+	XA_DABPLUS_DEC_BBITSTREAMDOWNMIX,
+	XA_DABPLUS_DEC_CHANROUTING,
+
+/* dedicate for sbc enc */
+	XA_SBC_ENC_SUBBANDS = 0x160,
+	XA_SBC_ENC_BLOCKS,
+	XA_SBC_ENC_SNR,
+	XA_SBC_ENC_BITPOOL,
+	XA_SBC_ENC_CHMODE,
+
+/* Get parmameters */
+	XA_CODEC_DESCRIPTION = 0x200,
+	XA_OUTPUT_PCM_FORMAT,
+	XA_CONSUMED_LENGTH,
+	XA_OUTBUF_ALLOC_SIZE,
+	XA_CONSUMED_CYCLES,
+
+};
+
+#define XA_STREAM_DABPLUS_BASE  0x30
+enum DSP_StreamType {
+    /* AAC/AACPLUS file format */
+	XA_STREAM_UNKNOWN = 0,
+	XA_STREAM_ADTS,
+	XA_STREAM_ADIF,
+	XA_STREAM_RAW,
+
+	XA_STREAM_LATM,
+	XA_STREAM_LATM_OUTOFBAND_CONFIG,
+	XA_STREAM_LOAS,
+
+    /* DABPLUS file format */
+	XA_STREAM_DABPLUS_RAW_SIDEINFO = XA_STREAM_DABPLUS_BASE,
+	XA_STREAM_DABPLUS,
+
+    /* BSAC file raw format */
+	XA_STREAM_BSAC_RAW,
+
+};
+
+/* sbc_enc-specific channel modes */
+enum DSP_SbcEncChmode {
+	XA_CHMODE_MONO =   0,
+	XA_CHMODE_DUAL =   1,
+	XA_CHMODE_STEREO = 2,
+	XA_CHMODE_JOINT =  3,
+};
+
+struct shmem_info {
+	unsigned int phys_addr;
+	unsigned int size;
+};
+
+#endif/* __MXC_DSP_UAPI_H__ */
diff --git a/include/uapi/linux/mxc_hifi4.h b/include/uapi/linux/mxc_hifi4.h
deleted file mode 100644
index 5078537..0000000
--- a/include/uapi/linux/mxc_hifi4.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __MXC_HIFI4_UAPI_H__
-#define __MXC_HIFI4_UAPI_H__
-
-#define DSP_IOC_MAGIC		'H'
-#define DSP_CLIENT_REGISTER   _IOW(DSP_IOC_MAGIC, 0, unsigned int)
-#define DSP_CLIENT_UNREGISTER _IOW(DSP_IOC_MAGIC, 1, unsigned int)
-#define DSP_IPC_MSG_SEND      _IOW(DSP_IOC_MAGIC, 2, unsigned int)
-#define DSP_IPC_MSG_RECV      _IOW(DSP_IOC_MAGIC, 3, unsigned int)
-#define DSP_GET_SHMEM_INFO    _IOW(DSP_IOC_MAGIC, 4, unsigned int)
-
-#define CODEC_MP3_DEC		1
-#define CODEC_AAC_DEC		2
-#define CODEC_DAB_DEC		3
-#define CODEC_MP2_DEC		4
-#define CODEC_BSAC_DEC		5
-#define CODEC_DRM_DEC		6
-#define CODEC_SBC_DEC		7
-#define CODEC_SBC_ENC		8
-#define CODEC_DEMO_DEC		9
-
-enum HIFI_ERROR_TYPE {
-	XA_SUCCESS = 0,
-
-	XA_ERROR_STREAM,
-	XA_PARA_ERROR,
-	XA_INSUFFICIENT_MEM,
-	XA_ERR_UNKNOWN,
-	XA_PROFILE_NOT_SUPPORT,
-	XA_INIT_ERR,
-	XA_NO_OUTPUT,
-
-	XA_NOT_ENOUGH_DATA = 0x100,
-	XA_CAPIBILITY_CHANGE = 0x200,
-	XA_END_OF_STREAM = 0x300, /* no output */
-};
-
-/* Parameter type to Set /Get */
-enum HIFI_ParaType {
-/* Set parmameters */
-/* common  */
-	XA_SAMPLERATE = 0,
-	XA_CHANNEL,
-	XA_FRAMED,        /* one whole frame input */
-	XA_DEPTH,
-	XA_CODEC_DATA,
-	XA_BITRATE,
-	XA_DOWNMIX_STEREO,
-	XA_STREAM_TYPE,
-	XA_CHAN_MAP_TABLE,
-	//UNIA_CHANNEL_MASK,
-	XA_TO_STEREO,
-
-/* dedicate for mp3 dec */
-	XA_MP3_DEC_CRC_CHECK = 0x120,
-	XA_MP3_DEC_MCH_ENABLE,
-	XA_MP3_DEC_NONSTD_STRM_SUPPORT,
-
-/* dedicate for bsac dec */
-	XA_BSAC_DEC_DECODELAYERS = 0x130,
-
-/* dedicate for aacplus dec */
-	XA_AACPLUS_DEC_BDOWNSAMPLE = 0x140,
-	XA_AACPLUS_DEC_BBITSTREAMDOWNMIX,
-	XA_AACPLUS_DEC_CHANROUTING,
-
-/* dedicate for dabplus dec */
-	XA_DABPLUS_DEC_BDOWNSAMPLE = 0x150,
-	XA_DABPLUS_DEC_BBITSTREAMDOWNMIX,
-	XA_DABPLUS_DEC_CHANROUTING,
-
-/* dedicate for sbc enc */
-	XA_SBC_ENC_SUBBANDS = 0x160,
-	XA_SBC_ENC_BLOCKS,
-	XA_SBC_ENC_SNR,
-	XA_SBC_ENC_BITPOOL,
-	XA_SBC_ENC_CHMODE,
-
-/* Get parmameters */
-	XA_CODEC_DESCRIPTION = 0x200,
-	XA_OUTPUT_PCM_FORMAT,
-	XA_CONSUMED_LENGTH,
-	XA_OUTBUF_ALLOC_SIZE,
-	XA_CONSUMED_CYCLES,
-
-};
-
-#define HIFI_STREAM_DABPLUS_BASE  0x30
-enum HIFI_StreamType {
-    /* AAC/AACPLUS file format */
-	XA_STREAM_UNKNOWN = 0,
-	XA_STREAM_ADTS,
-	XA_STREAM_ADIF,
-	XA_STREAM_RAW,
-
-	XA_STREAM_LATM,
-	XA_STREAM_LATM_OUTOFBAND_CONFIG,
-	XA_STREAM_LOAS,
-
-    /* DABPLUS file format */
-	XA_STREAM_DABPLUS_RAW_SIDEINFO = HIFI_STREAM_DABPLUS_BASE,
-	XA_STREAM_DABPLUS,
-
-    /* BSAC file raw format */
-	XA_STREAM_BSAC_RAW,
-
-};
-
-/* sbc_enc-specific channel modes */
-enum HIFI_SbcEncChmode {
-	XA_CHMODE_MONO =   0,
-	XA_CHMODE_DUAL =   1,
-	XA_CHMODE_STEREO = 2,
-	XA_CHMODE_JOINT =  3,
-};
-
-struct shmem_info {
-	unsigned int phys_addr;
-	unsigned int size;
-};
-
-#endif/* __MXC_HIFI4_UAPI_H__ */
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 28f7475..fe4489d 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -83,8 +83,8 @@ config SND_SOC_FSL_RPMSG_I2S
 	  This option is only useful for out-of-tree drivers since
 	  in-tree drivers select it automatically.
 
-config SND_SOC_FSL_HIFI4
-	tristate "hifi 4 module support"
+config SND_SOC_FSL_DSP
+	tristate "dsp module support"
 	help
 	  Say Y if you want to add hifi 4 support for the Freescale CPUs.
 	  which is a DSP core for audio processing.
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index 7c659e1..ebeea00 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -16,7 +16,7 @@ snd-soc-fsl-acm-objs := fsl_acm.o
 snd-soc-fsl-amix-objs := fsl_amix.o
 snd-soc-fsl-asrc-objs := fsl_asrc.o fsl_asrc_dma.o
 snd-soc-fsl-dma-workaround-objs := fsl_dma_workaround.o
-snd-soc-fsl-hifi4-objs := fsl_hifi4.o fsl_hifi4_proxy.o
+snd-soc-fsl-dsp-objs := fsl_dsp.o fsl_dsp_proxy.o
 snd-soc-fsl-sai-objs := fsl_sai.o
 snd-soc-fsl-ssi-y := fsl_ssi.o
 snd-soc-fsl-ssi-$(CONFIG_DEBUG_FS) += fsl_ssi_dbg.o
@@ -30,7 +30,7 @@ snd-soc-fsl-asoc-card-objs := fsl-asoc-card.o
 obj-$(CONFIG_SND_SOC_FSL_ACM) += snd-soc-fsl-acm.o
 obj-$(CONFIG_SND_SOC_FSL_AMIX) += snd-soc-fsl-amix.o
 obj-$(CONFIG_SND_SOC_FSL_ASRC) += snd-soc-fsl-asrc.o
-obj-$(CONFIG_SND_SOC_FSL_HIFI4) += snd-soc-fsl-hifi4.o
+obj-$(CONFIG_SND_SOC_FSL_DSP) += snd-soc-fsl-dsp.o
 obj-$(CONFIG_SND_SOC_FSL_SAI) += snd-soc-fsl-sai.o
 obj-$(CONFIG_SND_SOC_FSL_SSI) += snd-soc-fsl-ssi.o
 obj-$(CONFIG_SND_SOC_FSL_SPDIF) += snd-soc-fsl-spdif.o
diff --git a/sound/soc/fsl/fsl_dsp.c b/sound/soc/fsl/fsl_dsp.c
new file mode 100644
index 0000000..7df05c7
--- /dev/null
+++ b/sound/soc/fsl/fsl_dsp.c
@@ -0,0 +1,1028 @@
+/*
+ * Freescale DSP driver
+ *
+ * Copyright (c) 2012-2013 by Tensilica Inc. ALL RIGHTS RESERVED.
+ * Copyright 2018 NXP
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * Copyright (c) 2001 William L. Pitts
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are freely
+ * permitted provided that the above copyright notice and this
+ * paragraph and the following disclaimer are duplicated in all
+ * such forms.
+ *
+ * This software is provided "AS IS" and without any express or
+ * implied warranties, including, without limitation, the implied
+ * warranties of merchantability and fitness for a particular
+ * purpose.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/file.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+#include <linux/platform_data/dma-imx.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/pm_runtime.h>
+#include <linux/mx8_mu.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include <uapi/linux/mxc_dsp.h>
+#include <soc/imx8/sc/svc/irq/api.h>
+#include <soc/imx8/sc/ipc.h>
+#include <soc/imx8/sc/sci.h>
+#include "fsl_dsp.h"
+
+
+/* ...allocate new client */
+static inline struct xf_client *xf_client_alloc(struct fsl_dsp *dsp_priv)
+{
+	struct xf_client *client;
+	u32             id;
+
+	id = dsp_priv->xf_client_map[0].next;
+
+	/* ...try to allocate a client handle */
+	if (id != 0) {
+		/* ...allocate client memory */
+		client = kmalloc(sizeof(*client), GFP_KERNEL);
+		if (!client)
+			return ERR_PTR(-ENOMEM);
+
+		/* ...advance the head of free clients */
+		dsp_priv->xf_client_map[0].next =
+				dsp_priv->xf_client_map[id].next;
+
+		/* ...put associate client id with given object */
+		dsp_priv->xf_client_map[id].client = client;
+
+		/* ...mark client is not yet bound to proxy */
+		client->proxy = NULL;
+
+		/* ...save global proxy client identifier */
+		client->id = id;
+
+		return client;
+	}
+
+	/* ...number of clients exceeded */
+	return ERR_PTR(-EBUSY);
+}
+
+/* ...recycle client object */
+static inline void xf_client_free(struct xf_client *client)
+{
+	int     id = client->id;
+	struct fsl_dsp *dsp_priv = (struct fsl_dsp *)client->global;
+
+	/* ...put proxy client id into free clients list */
+	dsp_priv->xf_client_map[id].next = dsp_priv->xf_client_map[0].next;
+	dsp_priv->xf_client_map[0].next = id;
+
+	/* ...destroy client data */
+	kfree(client);
+}
+
+/* ...lookup client basing on id */
+struct xf_client *xf_client_lookup(struct fsl_dsp *dsp_priv, u32 id)
+{
+	if ((id >= XF_CFG_MAX_IPC_CLIENTS) ||
+		(dsp_priv->xf_client_map[id].next < XF_CFG_MAX_IPC_CLIENTS)
+	   )
+		return NULL;
+	else
+		return dsp_priv->xf_client_map[id].client;
+}
+
+/* ...helper function for retrieving the client handle */
+static inline struct xf_client *xf_get_client(struct file *file)
+{
+	struct xf_client *client;
+	u32             id;
+
+	client = (struct xf_client *)file->private_data;
+	if (!client)
+		return ERR_PTR(-EINVAL);
+
+	id = client->id;
+	if (id >= XF_CFG_MAX_IPC_CLIENTS)
+		return ERR_PTR(-EINVAL);
+
+	return client;
+}
+
+static int fsl_dsp_client_register(struct xf_client *client)
+{
+	struct fsl_dsp *dsp_priv;
+	struct device *dev;
+
+	dsp_priv = (struct fsl_dsp *)client->global;
+	dev = dsp_priv->dev;
+
+	/* ...make sure client is not registered yet */
+	if (client->proxy != NULL) {
+		pr_err("client-%x already registered", client->id);
+		return -EBUSY;
+	}
+
+	/* ...complete association (no communication with remote proxy here) */
+	client->proxy = &dsp_priv->proxy;
+
+	pr_debug("client-%x registered within proxy", client->id);
+
+	return 0;
+}
+
+/* ...unregister client from shared memory interface */
+static int fsl_dsp_client_unregister(struct xf_client *client)
+{
+	struct xf_proxy *proxy = client->proxy;
+
+	/* ...make sure client is registered */
+	if (proxy == NULL) {
+		pr_err("client-%x is not registered", client->id);
+		return -EBUSY;
+	}
+
+	/* ...just clean proxy reference */
+	client->proxy = NULL;
+
+	pr_debug("client-%x registered within proxy", client->id);
+
+	return 0;
+}
+
+static int fsl_dsp_ipc_msg_to_dsp(struct xf_client *client,
+							void __user *user)
+{
+	struct fsl_dsp *dsp_priv = (struct fsl_dsp *)client->global;
+	struct device *dev = dsp_priv->dev;
+	struct xf_proxy_message msg;
+	void *buffer;
+	unsigned long ret = 0;
+
+	ret = copy_from_user(&msg, user, sizeof(struct xf_proxy_message));
+	if (ret) {
+		dev_err(dev, "failed to get message from user space\n");
+		return -EFAULT;
+	}
+
+	/* ...make sure message pointer is sane */
+	buffer = xf_proxy_a2b(&dsp_priv->proxy, msg.address);
+	if (buffer == (void *)-1)
+		return -EFAULT;
+
+	/* ...put current proxy client into message session id */
+	msg.session_id = XF_MSG_AP_FROM_USER(msg.session_id, client->id);
+
+	xf_cmd_send(&dsp_priv->proxy,
+				msg.session_id,
+				msg.opcode,
+				buffer,
+				msg.length);
+
+	return 0;
+}
+
+static int fsl_dsp_ipc_msg_from_dsp(struct xf_client *client,
+							void __user *user)
+{
+	struct fsl_dsp *dsp_priv = (struct fsl_dsp *)client->global;
+	struct device *dev = dsp_priv->dev;
+	struct xf_message *m;
+	struct xf_proxy_message msg;
+	unsigned long ret = 0;
+
+	m = xf_cmd_recv(&dsp_priv->proxy, &client->wait, &client->queue, 0);
+	if (IS_ERR(m)) {
+		dev_err(dev, "receiving failed: %d", (int)PTR_ERR(m));
+		return PTR_ERR(m);
+	}
+
+	/* ...check if there is a response available */
+	if (m == NULL)
+		return -EAGAIN;
+
+	/* ...prepare message parameters (lock is taken) */
+	msg.session_id = XF_MSG_AP_TO_USER(m->id);
+	msg.opcode = m->opcode;
+	msg.length = m->length;
+	msg.address = xf_proxy_b2a(&dsp_priv->proxy, m->buffer);
+	msg.ret = m->ret;
+
+	/* ...return the message back to a pool and release lock */
+	xf_msg_free(&dsp_priv->proxy, m);
+	xf_unlock(&dsp_priv->proxy.lock);
+
+	ret = copy_to_user(user, &msg, sizeof(struct xf_proxy_message));
+	if (ret) {
+		dev_err(dev, "failed to response message to user space\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int fsl_dsp_get_shmem_info(struct xf_client *client,
+							void __user *user)
+{
+	struct fsl_dsp *dsp_priv = (struct fsl_dsp *)client->global;
+	struct device *dev = dsp_priv->dev;
+	struct shmem_info mem_info;
+	unsigned long ret = 0;
+
+	mem_info.phys_addr = dsp_priv->scratch_buf_phys;
+	mem_info.size = dsp_priv->scratch_buf_size;
+
+	ret = copy_to_user(user, &mem_info, sizeof(struct shmem_info));
+	if (ret) {
+		dev_err(dev, "failed to response message to user space\n");
+		return -EFAULT;
+	}
+
+	return ret;
+}
+
+static struct miscdevice dsp_miscdev = {
+	.name	= "mxc_hifi4",
+	.minor	= MISC_DYNAMIC_MINOR,
+};
+
+static long fsl_dsp_ioctl(struct file *file, unsigned int cmd,
+						unsigned long arg)
+{
+	struct xf_client *client;
+	struct fsl_dsp *dsp_priv;
+	struct xf_proxy  *proxy;
+	struct device *dev;
+	void __user *user;
+	long ret = 0;
+
+	/* ...basic sanity checks */
+	client = xf_get_client(file);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	dsp_priv = (struct fsl_dsp *)client->global;
+	proxy = &dsp_priv->proxy;
+	dev = dsp_priv->dev;
+	user = (void __user *)arg;
+
+	mutex_lock(&dsp_priv->dsp_mutex);
+
+	if (!proxy->is_ready) {
+		mutex_unlock(&dsp_priv->dsp_mutex);
+		dev_err(dev, "dsp firmware is not ready\n");
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case DSP_CLIENT_REGISTER:
+		ret = fsl_dsp_client_register(client);
+		break;
+	case DSP_CLIENT_UNREGISTER:
+		ret = fsl_dsp_client_unregister(client);
+		break;
+	case DSP_IPC_MSG_SEND:
+		ret = fsl_dsp_ipc_msg_to_dsp(client, user);
+		break;
+	case DSP_IPC_MSG_RECV:
+		ret = fsl_dsp_ipc_msg_from_dsp(client, user);
+		break;
+	case DSP_GET_SHMEM_INFO:
+		ret = fsl_dsp_get_shmem_info(client, user);
+		break;
+	default:
+		break;
+	}
+
+	mutex_unlock(&dsp_priv->dsp_mutex);
+
+	return ret;
+}
+
+void resource_release(struct fsl_dsp *dsp_priv)
+{
+	int i;
+
+	/* ...initialize client association map */
+	for (i = 0; i < XF_CFG_MAX_IPC_CLIENTS - 1; i++)
+		dsp_priv->xf_client_map[i].next = i + 1;
+	/* ...set list terminator */
+	dsp_priv->xf_client_map[i].next = 0;
+
+	/* ...set pointer to shared memory */
+	xf_proxy_init(&dsp_priv->proxy);
+}
+
+static int fsl_dsp_open(struct inode *inode, struct file *file)
+{
+	struct fsl_dsp *dsp_priv = dev_get_drvdata(dsp_miscdev.parent);
+	struct device *dev = dsp_priv->dev;
+	struct xf_client *client;
+	int ret = 0;
+
+	/* ...basic sanity checks */
+	if (!inode || !file)
+		return -EINVAL;
+
+	/* ...allocate new proxy client object */
+	client = xf_client_alloc(dsp_priv);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	/* ...initialize waiting queue */
+	init_waitqueue_head(&client->wait);
+
+	/* ...initialize client pending message queue */
+	xf_msg_queue_init(&client->queue);
+
+	/* ...mark user data is not mapped */
+	client->vm_start = 0;
+
+	/* ...reset mappings counter */
+	atomic_set(&client->vm_use, 0);
+
+	client->global = (void *)dsp_priv;
+
+	file->private_data = (void *)client;
+
+	pm_runtime_get_sync(dev);
+
+	mutex_lock(&dsp_priv->dsp_mutex);
+	/* increase reference counter when opening device */
+	atomic_long_inc(&dsp_priv->refcnt);
+	mutex_unlock(&dsp_priv->dsp_mutex);
+
+	return ret;
+}
+
+static int fsl_dsp_close(struct inode *inode, struct file *file)
+{
+	struct fsl_dsp *dsp_priv;
+	struct device *dev;
+	struct xf_proxy *proxy;
+	struct xf_client *client;
+
+	/* ...basic sanity checks */
+	client = xf_get_client(file);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	proxy = client->proxy;
+	if (proxy) {
+		/* ...release all pending messages */
+		xf_msg_free_all(proxy, &client->queue);
+
+		/* ...recycle client id and release memory */
+		xf_client_free(client);
+	}
+
+	dsp_priv = (struct fsl_dsp *)client->global;
+	dev = dsp_priv->dev;
+	pm_runtime_put_sync(dev);
+
+	mutex_lock(&dsp_priv->dsp_mutex);
+	/* decrease reference counter when closing device */
+	atomic_long_dec(&dsp_priv->refcnt);
+	/* If device is free, reinitialize the resource of
+	 * dsp driver and framework
+	 */
+	if (atomic_long_read(&dsp_priv->refcnt) <= 0)
+		resource_release(dsp_priv);
+
+	mutex_unlock(&dsp_priv->dsp_mutex);
+
+	return 0;
+}
+
+/* ...wait until data is available in the response queue */
+static unsigned int fsl_dsp_poll(struct file *file, poll_table *wait)
+{
+	struct xf_proxy *proxy;
+	struct xf_client *client;
+	int mask;
+
+	/* ...basic sanity checks */
+	client = xf_get_client(file);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	/* ...get proxy interface */
+	proxy = client->proxy;
+	if (!proxy)
+		return -EPERM;
+
+	/* ...register client waiting queue */
+	poll_wait(file, &client->wait, wait);
+
+	/* ...return current queue state */
+	mask = (xf_msg_queue_head(&client->queue) ? POLLIN | POLLRDNORM : 0);
+
+	return mask;
+}
+
+/*******************************************************************************
+ * Low-level mmap interface
+ ******************************************************************************/
+
+/* ...add reference to shared buffer */
+static void dsp_mmap_open(struct vm_area_struct *vma)
+{
+	struct xf_client *client = vma->vm_private_data;
+
+	/* ...probably just increase counter of open references? - tbd */
+	atomic_inc(&client->vm_use);
+
+	pr_debug("xf_mmap_open: vma = %p, client = %p", vma, client);
+}
+
+/* ...close reference to shared buffer */
+static void dsp_mmap_close(struct vm_area_struct *vma)
+{
+	struct xf_client *client = vma->vm_private_data;
+
+	pr_debug("xf_mmap_close: vma = %p, b = %p", vma, client);
+
+	/* ...decrement number of mapping */
+	atomic_dec_return(&client->vm_use);
+}
+
+/* ...memory map operations */
+static const struct vm_operations_struct dsp_mmap_ops = {
+	.open   = dsp_mmap_open,
+	.close  = dsp_mmap_close,
+};
+
+/* ...shared memory mapping */
+static int fsl_dsp_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct xf_proxy *proxy;
+	struct xf_client *client;
+	unsigned long   size;
+	unsigned long   pfn;
+	int             r;
+	struct fsl_dsp *dsp_priv;
+
+	/* ...basic sanity checks */
+	client = xf_get_client(file);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	/* ...get proxy interface */
+	proxy = client->proxy;
+	if (!proxy)
+		return -EPERM;
+
+	/* ...check it was not mapped already */
+	if (client->vm_start != 0)
+		return -EBUSY;
+
+	/* ...check mapping flags (tbd) */
+	if ((vma->vm_flags & (VM_READ | VM_WRITE | VM_SHARED))
+				!= (VM_READ | VM_WRITE | VM_SHARED))
+		return -EPERM;
+
+	/* ...set memory map operations */
+	vma->vm_ops = &dsp_mmap_ops;
+
+	/* ...assign private data */
+	client->vm_start = vma->vm_start;
+
+	/* ...set private memory data */
+	vma->vm_private_data = client;
+
+	/* ...set page number of shared memory */
+	dsp_priv = (struct fsl_dsp *)client->global;
+	pfn = dsp_priv->scratch_buf_phys >> PAGE_SHIFT;
+	size = dsp_priv->scratch_buf_size;
+
+	/* ...remap shared memory to user-space */
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	r = remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot);
+	if (r != 0) {
+		pr_err("mapping failed: %d", r);
+		return r;
+	}
+
+	/* ...system-specific hook for registering shared memory mapping */
+	return 0;
+}
+
+void *memset_dsp(void *dest, int c, size_t count)
+{
+	uint *dl = (uint *)dest;
+	void *dl_1, *dl_2;
+	size_t align = 4;
+	size_t n, n1, n2;
+
+	/* while all data is aligned (common case), copy a word at a time */
+	if ((((ulong)dest) & (sizeof(*dl) - 1)) != 0) {
+		dl = (unsigned int *)(((ulong)dest + align - 1) &
+								(~(align - 1)));
+		dl_1 = dest;
+		dl_2 = (void *)(((ulong)dest + count) & (~(align - 1)));
+		n1 = (ulong)dl - (ulong)dl_1;
+		n2 = (ulong)dest + count - (ulong)dl_2;
+		n = (count - n1 - n2) / align;
+
+		while (n--) {
+			writel_relaxed(0,  dl);
+			dl++;
+		}
+		while (n1--) {
+			writeb_relaxed(0, dl_1);
+			dl_1++;
+		}
+		while (n2--) {
+			writeb_relaxed(0, dl_2);
+			dl_2++;
+		}
+	} else {
+		n = count / align;
+		n1 = count - n * align;
+		dl_1 = dest + n * align;
+		while (n--) {
+			writel_relaxed(0,  dl);
+			dl++;
+		}
+		while (n1--) {
+			writeb_relaxed(0, dl_1);
+			dl_1++;
+		}
+	}
+
+	return dest;
+}
+
+void *memcpy_dsp(void *dest, const void *src, size_t count)
+{
+	unsigned int *dl = (unsigned int *)dest, *sl = (unsigned int *)src;
+	size_t n = round_up(count, 4) / 4;
+
+	if (src == dest)
+		return dest;
+
+	/* while all data is aligned (common case), copy a word at a time */
+	if ((((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) != 0)
+		pr_info("dest %p src %p not 4 bytes aligned\n", dest, src);
+
+	while (n--) {
+		writel_relaxed(*sl,  dl);
+		dl++;
+		sl++;
+	}
+
+	return dest;
+}
+
+static void dsp_load_firmware(const struct firmware *fw, void *context)
+{
+	struct fsl_dsp *dsp_priv = context;
+	struct device *dev = dsp_priv->dev;
+	Elf32_Ehdr *ehdr; /* Elf header structure pointer */
+	Elf32_Shdr *shdr; /* Section header structure pointer */
+	Elf32_Addr  sh_addr;
+	unsigned char *strtab = 0; /* String table pointer */
+	unsigned char *image; /* Binary image pointer */
+	int i; /* Loop counter */
+	unsigned long addr;
+
+	if (!fw) {
+		dev_info(dev, "external firmware not found\n");
+		return;
+	}
+
+	addr = (unsigned long)fw->data;
+	ehdr = (Elf32_Ehdr *)addr;
+
+	/* Find the section header string table for output info */
+	shdr = (Elf32_Shdr *)(addr + ehdr->e_shoff +
+			(ehdr->e_shstrndx * sizeof(Elf32_Shdr)));
+
+	if (shdr->sh_type == SHT_STRTAB)
+		strtab = (unsigned char *)(addr + shdr->sh_offset);
+
+	/* Load each appropriate section */
+	for (i = 0; i < ehdr->e_shnum; ++i) {
+		shdr = (Elf32_Shdr *)(addr + ehdr->e_shoff +
+				(i * sizeof(Elf32_Shdr)));
+
+		if (!(shdr->sh_flags & SHF_ALLOC) ||
+			shdr->sh_addr == 0 || shdr->sh_size == 0)
+			continue;
+
+		if (strtab) {
+			dev_dbg(dev, "%sing %s @ 0x%08lx (%ld bytes)\n",
+			  (shdr->sh_type == SHT_NOBITS) ? "Clear" : "Load",
+				&strtab[shdr->sh_name],
+				(unsigned long)shdr->sh_addr,
+				(long)shdr->sh_size);
+		}
+
+		sh_addr = shdr->sh_addr;
+
+		if (shdr->sh_type == SHT_NOBITS) {
+			memset_dsp((void *)(dsp_priv->sdram_vir_addr +
+				(sh_addr - dsp_priv->sdram_phys_addr)),
+				0,
+				shdr->sh_size);
+		} else {
+			image = (unsigned char *)addr + shdr->sh_offset;
+			if ((!strcmp(&strtab[shdr->sh_name], ".rodata")) ||
+				(!strcmp(&strtab[shdr->sh_name], ".text"))   ||
+				(!strcmp(&strtab[shdr->sh_name], ".data"))   ||
+				(!strcmp(&strtab[shdr->sh_name], ".bss"))
+			) {
+				memcpy_dsp((void *)(dsp_priv->sdram_vir_addr
+				  + (sh_addr - dsp_priv->sdram_phys_addr)),
+				  (const void *)image,
+				  shdr->sh_size);
+			} else {
+				memcpy_dsp((void *)(dsp_priv->regs +
+						(sh_addr - dsp_priv->paddr)),
+						(const void *)image,
+						shdr->sh_size);
+			}
+		}
+	}
+
+	/* start the core */
+	sc_pm_cpu_start(dsp_priv->dsp_ipcHandle,
+					SC_R_DSP, true, dsp_priv->iram);
+}
+
+/* Initialization of the MU code. */
+int dsp_mu_init(struct fsl_dsp *dsp_priv)
+{
+	struct device *dev = dsp_priv->dev;
+	struct device_node *np;
+	unsigned int	dsp_mu_id;
+	u32 irq;
+	int ret = 0;
+
+	/*
+	 * Get the address of MU to be used for communication with the dsp
+	 */
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx8-mu-dsp");
+	if (!np) {
+		dev_err(dev, "Cannot find MU entry in device tree\n");
+		return -EINVAL;
+	}
+	dsp_priv->mu_base_virtaddr = of_iomap(np, 0);
+	WARN_ON(!dsp_priv->mu_base_virtaddr);
+
+	ret = of_property_read_u32_index(np,
+				"fsl,dsp_ap_mu_id", 0, &dsp_mu_id);
+	if (ret) {
+		dev_err(dev, "Cannot get mu_id %d\n", ret);
+		return -EINVAL;
+	}
+
+	dsp_priv->dsp_mu_id = dsp_mu_id;
+
+	irq = of_irq_get(np, 0);
+
+	ret = devm_request_irq(dsp_priv->dev, irq, fsl_dsp_mu_isr,
+			IRQF_EARLY_RESUME, "dsp_mu_isr", &dsp_priv->proxy);
+	if (ret) {
+		dev_err(dev, "request_irq failed %d, err = %d\n", irq, ret);
+		return -EINVAL;
+	}
+
+	if (!dsp_priv->dsp_mu_init) {
+		MU_Init(dsp_priv->mu_base_virtaddr);
+		MU_EnableRxFullInt(dsp_priv->mu_base_virtaddr, 0);
+		dsp_priv->dsp_mu_init = 1;
+	}
+
+	return ret;
+}
+
+static const struct file_operations dsp_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= fsl_dsp_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = fsl_dsp_ioctl,
+#endif
+	.open		= fsl_dsp_open,
+	.poll		= fsl_dsp_poll,
+	.mmap		= fsl_dsp_mmap,
+	.release	= fsl_dsp_close,
+};
+
+static int fsl_dsp_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct fsl_dsp *dsp_priv;
+	const char *fw_name;
+	struct resource *res;
+	void __iomem *regs;
+	uint32_t mu_id;
+	sc_err_t sciErr;
+	void *buf_virt;
+	dma_addr_t buf_phys;
+	int size, offset, i;
+	int ret;
+
+	dsp_priv = devm_kzalloc(&pdev->dev, sizeof(*dsp_priv), GFP_KERNEL);
+	if (!dsp_priv)
+		return -ENOMEM;
+
+	dsp_priv->dev = &pdev->dev;
+
+	/* Get the addresses and IRQ */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	dsp_priv->paddr = res->start;
+	dsp_priv->regs  = regs;
+
+	dsp_priv->dram0 = dsp_priv->paddr + DRAM0_OFFSET;
+	dsp_priv->dram1 = dsp_priv->paddr + DRAM1_OFFSET;
+	dsp_priv->iram  = dsp_priv->paddr + IRAM_OFFSET;
+	dsp_priv->sram  = dsp_priv->paddr + SYSRAM_OFFSET;
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		dev_err(&pdev->dev, "Cannot obtain MU ID\n");
+		return sciErr;
+	}
+
+	sciErr = sc_ipc_open(&dsp_priv->dsp_ipcHandle, mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		dev_err(&pdev->dev, "Cannot open MU channel to SCU %d, %d\n",
+								mu_id, sciErr);
+		return sciErr;
+	};
+
+	sciErr = sc_misc_set_control(dsp_priv->dsp_ipcHandle, SC_R_DSP,
+				SC_C_OFS_SEL, 1);
+	if (sciErr != SC_ERR_NONE) {
+		dev_err(&pdev->dev, "Error system address offset source select\n");
+		return -EIO;
+	}
+
+	sciErr = sc_misc_set_control(dsp_priv->dsp_ipcHandle, SC_R_DSP,
+				SC_C_OFS_AUDIO, 0x80);
+	if (sciErr != SC_ERR_NONE) {
+		dev_err(&pdev->dev, "Error system address offset of AUDIO\n");
+		return -EIO;
+	}
+
+	sciErr = sc_misc_set_control(dsp_priv->dsp_ipcHandle, SC_R_DSP,
+				SC_C_OFS_PERIPH, 0x5A);
+	if (sciErr != SC_ERR_NONE) {
+		dev_err(&pdev->dev, "Error system address offset of PERIPH\n");
+		return -EIO;
+	}
+
+	sciErr = sc_misc_set_control(dsp_priv->dsp_ipcHandle, SC_R_DSP,
+				SC_C_OFS_IRQ, 0x51);
+	if (sciErr != SC_ERR_NONE) {
+		dev_err(&pdev->dev, "Error system address offset of IRQ\n");
+		return -EIO;
+	}
+
+	ret = dsp_mu_init(dsp_priv);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_string(np, "fsl,dsp-firmware", &fw_name);
+	dsp_priv->fw_name = fw_name;
+
+	platform_set_drvdata(pdev, dsp_priv);
+	pm_runtime_enable(&pdev->dev);
+
+	dsp_miscdev.fops = &dsp_fops,
+	dsp_miscdev.parent = &pdev->dev,
+	ret = misc_register(&dsp_miscdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register misc device %d\n", ret);
+		return ret;
+	}
+
+	dsp_priv->sdram_phys_addr = SDRAM_BASE_ADDR;
+	dsp_priv->sdram_vir_addr = ioremap_wc(dsp_priv->sdram_phys_addr,
+							SDRAM_BASE_SIZE);
+	if (!dsp_priv->sdram_vir_addr) {
+		dev_err(&pdev->dev, "failed to remap sdram space for dsp firmware\n");
+		return -ENXIO;
+	}
+	memset_io(dsp_priv->sdram_vir_addr, 0, SDRAM_BASE_SIZE);
+
+	size = MSG_BUF_SIZE + DSP_CONFIG_SIZE;
+
+	buf_virt = dma_alloc_coherent(&pdev->dev, size, &buf_phys, GFP_KERNEL);
+	if (!buf_virt) {
+		dev_err(&pdev->dev, "failed alloc memory.\n");
+		return -ENOMEM;
+	}
+
+	/* msg ring buffer memory */
+	dsp_priv->msg_buf_virt = buf_virt;
+	dsp_priv->msg_buf_phys = buf_phys;
+	dsp_priv->msg_buf_size = MSG_BUF_SIZE;
+	offset = MSG_BUF_SIZE;
+
+	/* keep dsp framework's global data when suspend/resume */
+	dsp_priv->dsp_config_virt = buf_virt + offset;
+	dsp_priv->dsp_config_phys = buf_phys + offset;
+	dsp_priv->dsp_config_size = DSP_CONFIG_SIZE;
+
+	/* scratch memory for dsp framework */
+	dsp_priv->scratch_buf_virt = dsp_priv->sdram_vir_addr +
+						SDRAM_CODEC_LIB_OFFSET;
+	dsp_priv->scratch_buf_phys = dsp_priv->sdram_phys_addr +
+						SDRAM_CODEC_LIB_OFFSET;
+	dsp_priv->scratch_buf_size = SDRAM_BASE_SIZE - SDRAM_CODEC_LIB_OFFSET;
+
+	/* initialize the reference counter for dsp_priv
+	 * structure
+	 */
+	atomic_long_set(&dsp_priv->refcnt, 0);
+
+	/* ...initialize client association map */
+	for (i = 0; i < XF_CFG_MAX_IPC_CLIENTS - 1; i++)
+		dsp_priv->xf_client_map[i].next = i + 1;
+	/* ...set list terminator */
+	dsp_priv->xf_client_map[i].next = 0;
+
+	/* ...set pointer to shared memory */
+	xf_proxy_init(&dsp_priv->proxy);
+
+	/* ...initialize mutex */
+	mutex_init(&dsp_priv->dsp_mutex);
+
+	return 0;
+}
+
+static int fsl_dsp_remove(struct platform_device *pdev)
+{
+	struct fsl_dsp *dsp_priv = platform_get_drvdata(pdev);
+	int size;
+
+	misc_deregister(&dsp_miscdev);
+
+	size = MSG_BUF_SIZE + DSP_CONFIG_SIZE;
+	dma_free_coherent(&pdev->dev, size, dsp_priv->msg_buf_virt,
+				dsp_priv->msg_buf_phys);
+	if (dsp_priv->sdram_vir_addr)
+		iounmap(dsp_priv->sdram_vir_addr);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int fsl_dsp_runtime_resume(struct device *dev)
+{
+	struct fsl_dsp *dsp_priv = dev_get_drvdata(dev);
+	struct xf_proxy *proxy = &dsp_priv->proxy;
+	int ret;
+
+	if (sc_pm_set_resource_power_mode(dsp_priv->dsp_ipcHandle,
+			SC_R_DSP_RAM, SC_PM_PW_MODE_ON) != SC_ERR_NONE) {
+		dev_err(dev, "Error power on DSP RAM\n");
+		return -EIO;
+	}
+
+	if (!proxy->is_ready) {
+		init_completion(&proxy->cmd_complete);
+
+		ret = request_firmware_nowait(THIS_MODULE,
+				FW_ACTION_HOTPLUG, dsp_priv->fw_name,
+				dev,
+				GFP_KERNEL, dsp_priv, dsp_load_firmware);
+
+		if (ret) {
+			dev_err(dev, "failed to load firmware\n");
+			return ret;
+		}
+
+		ret = icm_ack_wait(proxy, 0);
+		if (ret)
+			return ret;
+
+		dev_info(dev, "dsp driver registered\n");
+	}
+
+	return 0;
+}
+
+static int fsl_dsp_runtime_suspend(struct device *dev)
+{
+	struct fsl_dsp *dsp_priv = dev_get_drvdata(dev);
+	struct xf_proxy *proxy = &dsp_priv->proxy;
+
+	if (sc_pm_set_resource_power_mode(dsp_priv->dsp_ipcHandle,
+			SC_R_DSP_RAM, SC_PM_PW_MODE_OFF) != SC_ERR_NONE) {
+		dev_err(dev, "Error power off DSP RAM\n");
+		return -EIO;
+	}
+	proxy->is_ready = 0;
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+
+#ifdef CONFIG_PM_SLEEP
+static int fsl_dsp_suspend(struct device *dev)
+{
+	struct fsl_dsp *dsp_priv = dev_get_drvdata(dev);
+	struct xf_proxy *proxy = &dsp_priv->proxy;
+	int ret = 0;
+
+	if (proxy->is_ready) {
+		ret = xf_cmd_send_suspend(proxy);
+		if (ret) {
+			dev_err(dev, "dsp suspend fail\n");
+			return ret;
+		}
+	}
+
+	ret = pm_runtime_force_suspend(dev);
+
+	return ret;
+}
+
+static int fsl_dsp_resume(struct device *dev)
+{
+	struct fsl_dsp *dsp_priv = dev_get_drvdata(dev);
+	struct xf_proxy *proxy = &dsp_priv->proxy;
+	int ret = 0;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		return ret;
+
+	if (proxy->is_ready) {
+		ret = xf_cmd_send_resume(proxy);
+		if (ret) {
+			dev_err(dev, "dsp resume fail\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops fsl_dsp_pm = {
+	SET_RUNTIME_PM_OPS(fsl_dsp_runtime_suspend,
+					fsl_dsp_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(fsl_dsp_suspend, fsl_dsp_resume)
+};
+
+static const struct of_device_id fsl_dsp_ids[] = {
+	{ .compatible = "fsl,imx8qxp-dsp", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, fsl_dsp_ids);
+
+static struct platform_driver fsl_dsp_driver = {
+	.probe = fsl_dsp_probe,
+	.remove = fsl_dsp_remove,
+	.driver = {
+		.name = "fsl-dsp",
+		.of_match_table = fsl_dsp_ids,
+		.pm = &fsl_dsp_pm,
+	},
+};
+module_platform_driver(fsl_dsp_driver);
+
+MODULE_DESCRIPTION("Freescale DSP driver");
+MODULE_ALIAS("platform:fsl-dsp");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/fsl/fsl_dsp.h b/sound/soc/fsl/fsl_dsp.h
new file mode 100644
index 0000000..bc05f09
--- /dev/null
+++ b/sound/soc/fsl/fsl_dsp.h
@@ -0,0 +1,139 @@
+/*
+ * Freescale DSP driver
+ *
+ * Copyright 2018 NXP
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <uapi/linux/mxc_dsp.h>
+#include "fsl_dsp_proxy.h"
+
+
+typedef void (*memcpy_func) (void *dest, const void *src, size_t n);
+typedef void (*memset_func) (void *s, int c, size_t n);
+
+/* ...maximal number of IPC clients per proxy */
+#define XF_CFG_MAX_IPC_CLIENTS          (1 << 4)
+
+
+/* ...proxy client data */
+struct xf_client {
+	/* ...pointer to proxy interface */
+	struct xf_proxy     *proxy;
+
+	/* ...allocated proxy client id */
+	u32                 id;
+
+	/* ...pending response queue */
+	struct xf_msg_queue queue;
+
+	/* ...response waiting queue */
+	wait_queue_head_t   wait;
+
+	/* ...virtual memory mapping */
+	unsigned long       vm_start;
+
+	/* ...counter of memory mappings (no real use of it yet - tbd) */
+	atomic_t            vm_use;
+
+	/* ...global structure pointer */
+	void				*global;
+};
+
+union xf_client_link {
+	/* ...index of next client in free list */
+	u32                 next;
+
+	/* ...reference to proxy data for allocated client */
+	struct xf_client    *client;
+};
+
+struct fsl_dsp {
+	struct device			*dev;
+	const char			*fw_name;
+	void __iomem			*regs;
+	void __iomem			*mu_base_virtaddr;
+	sc_ipc_t			dsp_ipcHandle;
+	sc_ipc_t			mu_ipcHandle;
+	unsigned int			dsp_mu_id;
+	int				dsp_mu_init;
+	atomic_long_t			refcnt;
+	unsigned long			paddr;
+	unsigned long			dram0;
+	unsigned long			dram1;
+	unsigned long			iram;
+	unsigned long			sram;
+	void			        *sdram_vir_addr;
+	unsigned long			sdram_phys_addr;
+	void				*msg_buf_virt;
+	dma_addr_t			 msg_buf_phys;
+	int				 msg_buf_size;
+	void				*scratch_buf_virt;
+	dma_addr_t			 scratch_buf_phys;
+	int				 scratch_buf_size;
+	void				*dsp_config_virt;
+	dma_addr_t			 dsp_config_phys;
+	int				 dsp_config_size;
+
+	/* ...proxy data structures */
+	struct xf_proxy proxy;
+
+	/* ...mutex lock */
+	struct mutex dsp_mutex;
+
+	/* ...global clients pool (item[0] serves as list terminator) */
+	union xf_client_link xf_client_map[XF_CFG_MAX_IPC_CLIENTS];
+};
+
+#define IRAM_OFFSET		0x10000
+#define IRAM_SIZE		2048
+
+#define DRAM0_OFFSET		0x0
+#define DRAM0_SIZE		0x8000
+
+#define DRAM1_OFFSET		0x8000
+#define DRAM1_SIZE		0x8000
+
+#define SYSRAM_OFFSET		0x18000
+#define SYSRAM_SIZE		0x40000
+
+#define SYSROM_OFFSET		0x58000
+#define SYSROM_SIZE		0x30000
+
+#define MSG_BUF_SIZE		8192
+#define INPUT_BUF_SIZE		4096
+#define OUTPUT_BUF_SIZE		16384
+#define DSP_CONFIG_SIZE    4096
+
+/*external buffer
+ *  ----------------------------------------------------------------------
+ *  |  name                      | size     |   description     |
+ * -----------------------------------------------------------------------
+ *  |  scratch buffer for malloc | 0xffffff | For MEM_scratch_malloc()
+ * ------------------------------------------------------------------------
+ *  |  global structure          | 4096     | For store dsp config structure
+ * ------------------------------------------------------------------------
+ */
+
+#define MEMORY_REMAP_OFFSET	0x39000000
+
+/* reserved memory for dsp firmware and core libs to
+ * save their instruction/data section in SDRAM, the physical
+ * address range is 0x8e000000 ~ 0x8fffffff (32M bytes).
+ */
+#define SDRAM_BASE_ADDR  0x8e000000
+#define SDRAM_BASE_SIZE  0x1ffffff
+#define SDRAM_CODEC_LIB_OFFSET 0x1000000
+#define SDRAM_SCRATCH_BUF_SIZE 0xffffff
+
+#define SC_C_OFS_SEL    39
+#define SC_C_OFS_AUDIO  40
+#define SC_C_OFS_PERIPH 41
+#define SC_C_OFS_IRQ    42
+
+void *memcpy_dsp(void *dest, const void *src, size_t count);
+void *memset_dsp(void *dest, int c, size_t count);
+struct xf_client *xf_client_lookup(struct fsl_dsp *dsp_priv, u32 id);
diff --git a/sound/soc/fsl/fsl_dsp_proxy.c b/sound/soc/fsl/fsl_dsp_proxy.c
new file mode 100644
index 0000000..77dc7c2
--- /dev/null
+++ b/sound/soc/fsl/fsl_dsp_proxy.c
@@ -0,0 +1,702 @@
+/*******************************************************************************
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Copyright (C) 2017 Cadence Design Systems, Inc.
+ * Copyright 2018 NXP
+ *
+ ******************************************************************************/
+/*******************************************************************************
+ * fsl_dsp_proxy.c
+ *
+ * DSP proxy driver
+ *
+ * DSP proxy driver is used to transfer messages between dsp driver
+ * and dsp framework
+ ******************************************************************************/
+
+#include <soc/imx8/sc/ipc.h>
+#include "fsl_dsp_proxy.h"
+#include "fsl_dsp.h"
+
+
+/* ...initialize message queue */
+void xf_msg_queue_init(struct xf_msg_queue *queue)
+{
+	queue->head = queue->tail = NULL;
+}
+
+/* ...get message queue head */
+struct xf_message *xf_msg_queue_head(struct xf_msg_queue *queue)
+{
+	return queue->head;
+}
+
+/* ...allocate new message from the pool */
+struct xf_message *xf_msg_alloc(struct xf_proxy *proxy)
+{
+	struct xf_message *m = proxy->free;
+
+	/* ...make sure we have a free message item */
+	if (m != NULL) {
+		/* ...get message from the pool */
+		proxy->free = m->next, m->next = NULL;
+	}
+
+	return m;
+}
+
+/* ...return message to the pool of free items */
+void xf_msg_free(struct xf_proxy *proxy, struct xf_message *m)
+{
+	/* ...put message into the head of free items list */
+	m->next = proxy->free, proxy->free = m;
+
+	/* ...notify potential client waiting for message */
+	wake_up(&proxy->busy);
+}
+
+/* ...return all messages from the queue to the pool of free items */
+void xf_msg_free_all(struct xf_proxy *proxy, struct xf_msg_queue *queue)
+{
+	struct xf_message *m = queue->head;
+
+	/* ...check if there is anything in the queue */
+	if (m != NULL) {
+		queue->tail->next = proxy->free;
+		proxy->free = queue->head;
+		queue->head = queue->tail = NULL;
+
+		/* ...notify potential client waiting for message */
+		wake_up(&proxy->busy);
+	}
+}
+
+/* ...submit message to a queue */
+int xf_msg_enqueue(struct xf_msg_queue *queue, struct xf_message *m)
+{
+	int first = (queue->head == NULL);
+
+	/* ...set pointer to next item */
+	m->next = NULL;
+
+	/* ...advance head/tail pointer as required */
+	if (first)
+		queue->head = m;
+	else
+		queue->tail->next = m;
+
+	/* ...new tail points to this message */
+	queue->tail = m;
+
+	return first;
+}
+
+/* ...retrieve next message from the per-task queue */
+struct xf_message *xf_msg_dequeue(struct xf_msg_queue *queue)
+{
+	struct xf_message *m = queue->head;
+
+	/* ...check if there is anything in the queue */
+	if (m != NULL) {
+		/* ...pop message from the head of the list */
+		queue->head = m->next;
+		if (queue->head == NULL)
+			queue->tail = NULL;
+	}
+
+	return m;
+}
+
+/* ...helper function for requesting execution message from a pool */
+struct xf_message *xf_msg_available(struct xf_proxy *proxy)
+{
+	struct xf_message *m;
+
+	/* ...acquire global lock */
+	xf_lock(&proxy->lock);
+
+	/* ...try to allocate the message */
+	m = xf_msg_alloc(proxy);
+	if (m  == NULL) {
+		/* ...failed to allocate message; release lock */
+		xf_unlock(&proxy->lock);
+	}
+
+	/* ...if successfully allocated */
+	return m;
+}
+
+/* ...helper function for receiving a message from per-client queue */
+struct xf_message *xf_msg_received(struct xf_proxy *proxy,
+				struct xf_msg_queue *queue)
+{
+	struct xf_message *m;
+
+	/* ...acquire global lock */
+	xf_lock(&proxy->lock);
+
+	/* ...try to peek message from the queue */
+	m = xf_msg_dequeue(queue);
+	if (m == NULL) {
+		/* ...queue is empty; release lock */
+		xf_unlock(&proxy->lock);
+	}
+
+	/* ...if message is non-null, lock is held */
+	return m;
+}
+
+/*
+ * MU related functions
+ */
+u32 icm_intr_send(struct xf_proxy *proxy, u32 msg)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+
+	MU_SendMessage(dsp_priv->mu_base_virtaddr, 0, msg);
+	return 0;
+}
+
+int icm_intr_extended_send(struct xf_proxy *proxy,
+				u32 msg,
+				struct dsp_ext_msg *ext_msg)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+	struct device *dev = dsp_priv->dev;
+	union icm_header_t msghdr;
+
+	msghdr.allbits = msg;
+	if (msghdr.size != 8)
+		dev_err(dev, "too much ext msg\n");
+
+	MU_SendMessage(dsp_priv->mu_base_virtaddr, 1, ext_msg->phys);
+	MU_SendMessage(dsp_priv->mu_base_virtaddr, 2, ext_msg->size);
+	MU_SendMessage(dsp_priv->mu_base_virtaddr, 0, msg);
+
+	return 0;
+}
+
+int send_dpu_ext_msg_addr(struct xf_proxy *proxy)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+	union icm_header_t msghdr;
+	struct dsp_ext_msg ext_msg;
+	struct dsp_mem_msg *dpu_ext_msg =
+	 (struct dsp_mem_msg *)((unsigned char *)dsp_priv->msg_buf_virt
+					+ (MSG_BUF_SIZE / 2));
+	int ret_val = 0;
+
+	msghdr.allbits = 0;	/* clear all bits; */
+	msghdr.ack  = 0;
+	msghdr.intr = 1;
+	msghdr.msg  = ICM_CORE_INIT;
+	msghdr.size = 8;
+	ext_msg.phys = dsp_priv->msg_buf_phys + (MSG_BUF_SIZE / 2);
+	ext_msg.size = sizeof(struct dsp_mem_msg);
+
+	dpu_ext_msg->ext_msg_phys = dsp_priv->msg_buf_phys;
+	dpu_ext_msg->ext_msg_size = MSG_BUF_SIZE;
+	dpu_ext_msg->scratch_phys =  dsp_priv->scratch_buf_phys;
+	dpu_ext_msg->scratch_size =  dsp_priv->scratch_buf_size;
+	dpu_ext_msg->dsp_config_phys =  dsp_priv->dsp_config_phys;
+	dpu_ext_msg->dsp_config_size =  dsp_priv->dsp_config_size;
+
+	icm_intr_extended_send(proxy, msghdr.allbits, &ext_msg);
+
+	return ret_val;
+}
+
+long icm_ack_wait(struct xf_proxy *proxy, u32 msg)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+	struct device *dev = dsp_priv->dev;
+	union icm_header_t msghdr;
+	int err;
+
+	msghdr.allbits = msg;
+	/* wait response from mu */
+	err = wait_for_completion_timeout(&proxy->cmd_complete,
+				msecs_to_jiffies(1000));
+	if (!err) {
+		dev_err(dev, "icm ack timeout! %x\n", msg);
+		return -ETIMEDOUT;
+	}
+
+	dev_dbg(dev, "Ack recd for message 0x%08x\n", msghdr.allbits);
+
+	return 0;
+}
+
+irqreturn_t fsl_dsp_mu_isr(int irq, void *dev_id)
+{
+	struct xf_proxy *proxy = dev_id;
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+	struct device *dev = dsp_priv->dev;
+	union icm_header_t msghdr;
+	u32 reg;
+
+	MU_ReceiveMsg(dsp_priv->mu_base_virtaddr, 0, &reg);
+	msghdr = (union icm_header_t)reg;
+
+	if (msghdr.intr == 1) {
+		dev_dbg(dev, "INTR: Received ICM intr, msg 0x%08x\n",
+						msghdr.allbits);
+		switch (msghdr.msg) {
+		case ICM_CORE_EXIT:
+			break;
+		case ICM_CORE_READY:
+			send_dpu_ext_msg_addr(proxy);
+			proxy->is_ready = 1;
+			complete(&proxy->cmd_complete);
+			break;
+		case XF_SUSPEND:
+		case XF_RESUME:
+			complete(&proxy->cmd_complete);
+			break;
+		default:
+			schedule_work(&proxy->work);
+			break;
+		}
+	} else if (msghdr.ack == 1) {
+		dev_dbg(dev, "INTR: Received ICM ack 0x%08x\n", msghdr.size);
+		msghdr.ack = 0;
+	} else {
+		dev_dbg(dev, "Received false ICM intr 0x%08x\n",
+							msghdr.allbits);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Proxy related functions
+ */
+/* ...NULL-address specification */
+#define XF_PROXY_NULL           (~0U)
+
+#define XF_PROXY_BADADDR  SDRAM_SCRATCH_BUF_SIZE
+
+/* ...shared memory translation - kernel virtual address to shared address */
+u32 xf_proxy_b2a(struct xf_proxy *proxy, void *b)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+
+	if (b == NULL)
+		return XF_PROXY_NULL;
+	else if ((u32)(b - dsp_priv->scratch_buf_virt) <
+					SDRAM_SCRATCH_BUF_SIZE)
+		return (u32)(b - dsp_priv->scratch_buf_virt);
+	else
+		return XF_PROXY_BADADDR;
+}
+
+/* ...shared memory translation - shared address to kernel virtual address */
+void *xf_proxy_a2b(struct xf_proxy *proxy, u32 address)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+
+	if (address < SDRAM_SCRATCH_BUF_SIZE)
+		return dsp_priv->scratch_buf_virt + address;
+	else if (address == XF_PROXY_NULL)
+		return NULL;
+	else
+		return (void *) -1;
+}
+
+/* ...process association between response received and intended client */
+static void xf_cmap(struct xf_proxy *proxy, struct xf_message *m)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+	u32 id = XF_AP_IPC_CLIENT(m->id);
+	struct xf_client *client;
+
+	/* ...process messages addressed to proxy itself */
+	if (id == 0) {
+		/* ...place message into local response queue */
+		xf_msg_enqueue(&proxy->response, m);
+		wake_up(&proxy->wait);
+		return;
+	}
+
+	/* ...make sure the client ID is sane */
+	client = xf_client_lookup(dsp_priv, id);
+	if (!client) {
+		pr_err("rsp[id:%08x]: client lookup failed", m->id);
+		xf_msg_free(proxy, m);
+		return;
+	}
+
+	/* ...make sure client is bound to this proxy interface */
+	if (client->proxy != proxy) {
+		pr_err("rsp[id:%08x]: wrong proxy interface", m->id);
+		xf_msg_free(proxy, m);
+		return;
+	}
+
+	/* ...place message into local response queue */
+	if (xf_msg_enqueue(&client->queue, m))
+		wake_up(&client->wait);
+}
+
+/* ...retrieve pending responses from shared memory ring-buffer */
+static u32 xf_shmem_process_responses(struct xf_proxy *proxy)
+{
+	struct xf_message *m;
+	u32 read_idx, write_idx;
+	int status;
+
+	status = 0;
+
+	/* ...get current values of read/write pointers in response queue */
+	read_idx = XF_PROXY_READ(proxy, rsp_read_idx);
+	write_idx = XF_PROXY_READ(proxy, rsp_write_idx);
+
+	/* ...process all committed responses */
+	while (!XF_QUEUE_EMPTY(read_idx, write_idx)) {
+		struct xf_proxy_message *response;
+
+		/* ...allocate execution message */
+		m = xf_msg_alloc(proxy);
+		if (m  == NULL)
+			break;
+
+		/* ...mark the interface status has changed */
+		status |= (XF_QUEUE_FULL(read_idx, write_idx) ? 0x3 : 0x1);
+
+		/* ...get oldest not yet processed response */
+		response = XF_PROXY_RESPONSE(proxy, XF_QUEUE_IDX(read_idx));
+
+		/* ...fill message parameters */
+		m->id = response->session_id;
+		m->opcode = response->opcode;
+		m->length = response->length;
+		m->buffer = xf_proxy_a2b(proxy, response->address);
+		m->ret = response->ret;
+
+		/* ...advance local reading index copy */
+		read_idx = XF_QUEUE_ADVANCE_IDX(read_idx);
+
+		/* ...update shadow copy of reading index */
+		XF_PROXY_WRITE(proxy, rsp_read_idx, read_idx);
+
+		/* ...submit message to proper client */
+		xf_cmap(proxy, m);
+	}
+
+	return status;
+}
+
+/* ...put pending commands into shared memory ring-buffer */
+static u32 xf_shmem_process_commands(struct xf_proxy *proxy)
+{
+	struct xf_message *m;
+	u32 read_idx, write_idx;
+	int status = 0;
+
+	/* ...get current value of peer read pointer */
+	write_idx = XF_PROXY_READ(proxy, cmd_write_idx);
+	read_idx = XF_PROXY_READ(proxy, cmd_read_idx);
+
+	/* ...submit any pending commands */
+	while (!XF_QUEUE_FULL(read_idx, write_idx)) {
+		struct xf_proxy_message *command;
+
+		/* ...check if we have a pending command */
+		m = xf_msg_dequeue(&proxy->command);
+		if (m  == NULL)
+			break;
+
+		/* ...always mark the interface status has changed */
+		status |= 0x3;
+
+		/* ...select the place for the command */
+		command = XF_PROXY_COMMAND(proxy, XF_QUEUE_IDX(write_idx));
+
+		/* ...put the response message fields */
+		command->session_id = m->id;
+		command->opcode = m->opcode;
+		command->length = m->length;
+		command->address = xf_proxy_b2a(proxy, m->buffer);
+		command->ret = m->ret;
+
+		/* ...return message back to the pool */
+		xf_msg_free(proxy, m);
+
+		/* ...advance local writing index copy */
+		write_idx = XF_QUEUE_ADVANCE_IDX(write_idx);
+
+		/* ...update shared copy of queue write pointer */
+		XF_PROXY_WRITE(proxy, cmd_write_idx, write_idx);
+	}
+
+	if (status)
+		icm_intr_send(proxy, 0);
+
+	return status;
+}
+
+/* ...shared memory interface maintenance routine */
+void xf_proxy_process(struct work_struct *w)
+{
+	struct xf_proxy *proxy = container_of(w, struct xf_proxy, work);
+	int status = 0;
+
+	/* ...get exclusive access to internal data */
+	xf_lock(&proxy->lock);
+
+	do {
+		/* ...process outgoing commands first */
+		status = xf_shmem_process_commands(proxy);
+
+		/* ...process all pending responses */
+		status |= xf_shmem_process_responses(proxy);
+
+	} while (status);
+
+	/* ...unlock internal proxy data */
+	xf_unlock(&proxy->lock);
+}
+
+/* ...initialize shared memory interface */
+int xf_proxy_init(struct xf_proxy *proxy)
+{
+	struct fsl_dsp *dsp_priv = container_of(proxy,
+					struct fsl_dsp, proxy);
+	struct xf_message *m;
+	int i;
+
+	/* ...create a list of all messages in a pool; set head pointer */
+	proxy->free = &proxy->pool[0];
+
+	/* ...put all messages into a single-linked list */
+	for (i = 0, m = proxy->free; i < XF_CFG_MESSAGE_POOL_SIZE - 1; i++, m++)
+		m->next = m + 1;
+
+	/* ...set list tail pointer */
+	m->next = NULL;
+
+	/* ...initialize proxy lock */
+	xf_lock_init(&proxy->lock);
+
+	/* ...initialize proxy thread message queues */
+	xf_msg_queue_init(&proxy->command);
+	xf_msg_queue_init(&proxy->response);
+
+	/* ...initialize global busy queue */
+	init_waitqueue_head(&proxy->busy);
+	init_waitqueue_head(&proxy->wait);
+
+	/* ...create work structure */
+	INIT_WORK(&proxy->work, xf_proxy_process);
+
+	/* ...set pointer to shared memory */
+	proxy->ipc.shmem = (struct xf_shmem_data *)dsp_priv->msg_buf_virt;
+
+	/* ...initialize shared memory interface */
+	XF_PROXY_WRITE(proxy, cmd_read_idx, 0);
+	XF_PROXY_WRITE(proxy, cmd_write_idx, 0);
+	XF_PROXY_WRITE(proxy, cmd_invalid, 0);
+	XF_PROXY_WRITE(proxy, rsp_read_idx, 0);
+	XF_PROXY_WRITE(proxy, rsp_write_idx, 0);
+	XF_PROXY_WRITE(proxy, rsp_invalid, 0);
+
+	return 0;
+}
+
+/* ...trigger shared memory interface processing */
+void xf_proxy_notify(struct xf_proxy *proxy)
+{
+	schedule_work(&proxy->work);
+}
+
+/* ...submit a command to proxy pending queue (lock released upon return) */
+void xf_proxy_command(struct xf_proxy *proxy, struct xf_message *m)
+{
+	int first;
+
+	/* ...submit message to proxy thread */
+	first = xf_msg_enqueue(&proxy->command, m);
+
+	/* ...release the lock */
+	xf_unlock(&proxy->lock);
+
+	/* ...notify thread about command reception */
+	(first ? xf_proxy_notify(proxy), 1 : 0);
+}
+
+/*
+ * Proxy cmd send and receive functions
+ */
+int xf_cmd_send(struct xf_proxy *proxy,
+				u32 id,
+				u32 opcode,
+				void *buffer,
+				u32 length)
+{
+	struct xf_message *m;
+	int ret;
+
+	/* ...retrieve message handle (take the lock on success) */
+	ret = wait_event_interruptible(proxy->busy,
+					(m = xf_msg_available(proxy)) != NULL);
+	if (ret)
+		return -EINTR;
+
+	/* ...fill-in message parameters (lock is taken) */
+	m->id = id;
+	m->opcode = opcode;
+	m->length = length;
+	m->buffer = buffer;
+	m->ret = 0;
+
+	/* ...submit command to the proxy */
+	xf_proxy_command(proxy, m);
+
+	return 0;
+}
+
+struct xf_message *xf_cmd_recv(struct xf_proxy *proxy,
+						  wait_queue_head_t *wq,
+						  struct xf_msg_queue *queue,
+						  int wait)
+{
+	struct xf_message *m;
+	int ret;
+
+	/* ...wait for message reception (take lock on success) */
+	ret = wait_event_interruptible(*wq,
+			(m = xf_msg_received(proxy, queue)) != NULL || !wait);
+	if (ret)
+		return ERR_PTR(-EINTR);
+
+	/* ...return message with a lock taken */
+	return m;
+}
+
+/* ...helper function for synchronous command execution */
+struct xf_message *xf_cmd_send_recv(struct xf_proxy *proxy,
+							   u32 id, u32 opcode,
+							   void *buffer,
+							   u32 length)
+{
+	int ret;
+
+	/* ...send command to remote proxy */
+	ret = xf_cmd_send(proxy, id, opcode, buffer, length);
+	if (ret)
+		return ERR_PTR(ret);
+
+	/* ...wait for message delivery */
+	return xf_cmd_recv(proxy, &proxy->wait, &proxy->response, 1);
+}
+
+/*
+ * Proxy allocate and free memory functions
+ */
+/* ...allocate memory buffer for kernel use */
+int xf_cmd_alloc(struct xf_proxy *proxy, void **buffer, u32 length)
+{
+	struct xf_message *m;
+	u32 id = 0;
+	int ret;
+
+	/* ...send command to remote proxy */
+	m = xf_cmd_send_recv(proxy, id, XF_ALLOC, NULL, length);
+	if (IS_ERR(m)) {
+		ret = PTR_ERR(m);
+		return ret;
+	}
+
+	/* ...check if response is expected */
+	if (m->opcode == XF_ALLOC && m->buffer != NULL) {
+		*buffer = m->buffer;
+		ret = 0;
+	} else {
+		ret = -ENOMEM;
+	}
+
+	/* ...free message and release proxy lock */
+	xf_msg_free(proxy, m);
+
+	return ret;
+}
+
+/* ...free memory buffer */
+int xf_cmd_free(struct xf_proxy *proxy, void *buffer, u32 length)
+{
+	struct xf_message *m;
+	u32 id = 0;
+	int ret;
+
+	/* ...synchronously execute freeing command */
+	m = xf_cmd_send_recv(proxy, id, XF_FREE, buffer, length);
+	if (IS_ERR(m)) {
+		ret = PTR_ERR(m);
+		return ret;
+	}
+
+	/* ...check if response is expected */
+	if (m->opcode == XF_FREE)
+		ret = 0;
+	else
+		ret = -EINVAL;
+
+	/* ...free message and release proxy lock */
+	xf_msg_free(proxy, m);
+
+	return ret;
+}
+
+/*
+ * suspend & resume functions
+ */
+int xf_cmd_send_suspend(struct xf_proxy *proxy)
+{
+	union icm_header_t msghdr;
+	int ret = 0;
+
+	init_completion(&proxy->cmd_complete);
+
+	msghdr.allbits = 0;	/* clear all bits; */
+	msghdr.ack  = 0;
+	msghdr.intr = 1;
+	msghdr.msg  = XF_SUSPEND;
+	msghdr.size = 0;
+	icm_intr_send(proxy, msghdr.allbits);
+
+	/* wait for response here */
+	ret = icm_ack_wait(proxy, msghdr.allbits);
+
+	return ret;
+}
+
+int xf_cmd_send_resume(struct xf_proxy *proxy)
+{
+	union icm_header_t msghdr;
+	int ret = 0;
+
+	init_completion(&proxy->cmd_complete);
+
+	msghdr.allbits = 0;	/* clear all bits; */
+	msghdr.ack  = 0;
+	msghdr.intr = 1;
+	msghdr.msg  = XF_RESUME;
+	msghdr.size = 0;
+	icm_intr_send(proxy, msghdr.allbits);
+
+	/* wait for response here */
+	ret = icm_ack_wait(proxy, msghdr.allbits);
+
+	return ret;
+}
diff --git a/sound/soc/fsl/fsl_dsp_proxy.h b/sound/soc/fsl/fsl_dsp_proxy.h
new file mode 100644
index 0000000..4c3ec9b
--- /dev/null
+++ b/sound/soc/fsl/fsl_dsp_proxy.h
@@ -0,0 +1,404 @@
+/*******************************************************************************
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Copyright (c) 2017 Cadence Design Systems, Inc.
+ * Copyright 2018 NXP
+ *
+ ************************************************************/
+/************************************************************
+ * fsl_dsp_proxy.h
+ *
+ * Proxy commmand/response messages
+ ************************************************************/
+
+#ifndef __FSL_DSP_PROXY_H
+#define __FSL_DSP_PROXY_H
+
+#include <linux/wait.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <linux/compiler.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_data/dma-imx.h>
+#include <linux/mx8_mu.h>
+#include <linux/interrupt.h>
+
+#define XF_CFG_MESSAGE_POOL_SIZE        256
+
+/*******************************************************************************
+ * Local proxy data
+ ******************************************************************************/
+
+/* ...execution message */
+struct xf_message {
+	/* ...pointer to next message in a list */
+	struct xf_message   *next;
+
+	/* ...session-id */
+	u32                 id;
+
+	/* ...operation code */
+	u32                 opcode;
+
+	/* ...length of data buffer */
+	u32                 length;
+
+	/* ...translated data pointer */
+	void               *buffer;
+
+	/* ...return message status */
+	u32                ret;
+};
+
+/* ...message queue */
+struct xf_msg_queue {
+	/* ...pointer to list head */
+	struct xf_message   *head;
+
+	/* ...pointer to list tail */
+	struct xf_message   *tail;
+};
+
+struct xf_proxy_message {
+	/* ...session ID */
+	u32 session_id;
+
+	/* ...proxy API command/response code */
+	u32 opcode;
+
+	/* ...length of attached buffer */
+	u32 length;
+
+	/* ...physical address of message buffer */
+	u32 address;
+
+	/* ...return message status */
+	u32 ret;
+};
+/**********************************************************************/
+
+enum icm_action_t {
+	ICM_CORE_READY = 1,
+	ICM_CORE_INIT,
+	ICM_CORE_EXIT,
+};
+
+/* ...adjust IPC client of message going from user-space */
+#define XF_MSG_AP_FROM_USER(id, client) (((id) & ~(0xF << 2)) | (client << 2))
+
+/* ...message id contains source and destination ports specification */
+#define __XF_MSG_ID(src, dst)   (((src) & 0xFFFF) | (((dst) & 0xFFFF) << 16))
+
+/* ...wipe out IPC client from message going to user-space */
+#define XF_MSG_AP_TO_USER(id)   ((id) & ~(0xF << 18))
+#define __XF_AP_PROXY(core)     ((core) | 0x8000)
+#define __XF_DSP_PROXY(core)    ((core) | 0x8000)
+
+/* ...message id contains source and destination ports specification */
+#define __XF_MSG_ID(src, dst)   (((src) & 0xFFFF) | (((dst) & 0xFFFF) << 16))
+#define XF_MSG_SRC_CLIENT(id)   (((id) >> 2) & 0x3F)
+#define XF_MSG_DST_CLIENT(id)   (((id) >> 18) & 0x3F)
+
+/* ...special treatment of AP-proxy destination field */
+#define XF_AP_IPC_CLIENT(id)    (((id) >> 18) & 0xF)
+#define __XF_AP_PROXY(core)     ((core) | 0x8000)
+#define __XF_DSP_PROXY(core)    ((core) | 0x8000)
+
+/* ...opcode composition with command/response data tags */
+#define __XF_OPCODE(c, r, op)   (((c) << 31) | ((r) << 30) | ((op) & 0x3F))
+
+/* ...shared buffer allocation */
+#define XF_ALLOC                        __XF_OPCODE(0, 0, 4)
+
+/* ...shared buffer freeing */
+#define XF_FREE                         __XF_OPCODE(0, 0, 5)
+
+/* ...resume component operation */
+#define XF_RESUME                       __XF_OPCODE(0, 0, 14)
+
+/* ...resume component operation */
+#define XF_SUSPEND                      __XF_OPCODE(0, 0, 15)
+
+
+/*******************************************************************************
+ * Ring buffer support
+ ******************************************************************************/
+/* ...cache-line size on DSP */
+#define XF_PROXY_ALIGNMENT              64
+
+/* ...total length of shared memory queue (for commands and responses) */
+#define XF_PROXY_MESSAGE_QUEUE_LENGTH   (1 << 6)
+
+/* ...index mask */
+#define XF_PROXY_MESSAGE_QUEUE_MASK     0x3F
+
+/* ...ring-buffer index */
+#define __XF_QUEUE_IDX(idx, counter)    \
+		(((idx) & XF_PROXY_MESSAGE_QUEUE_MASK) | ((counter) << 16))
+
+/* ...retrieve ring-buffer index */
+#define XF_QUEUE_IDX(idx)               \
+		((idx) & XF_PROXY_MESSAGE_QUEUE_MASK)
+
+/* ...increment ring-buffer index */
+#define XF_QUEUE_ADVANCE_IDX(idx)       \
+		(((idx) + 0x10001) & (0xFFFF0000 | XF_PROXY_MESSAGE_QUEUE_MASK))
+
+/* ...test if ring buffer is empty */
+#define XF_QUEUE_EMPTY(read, write)     \
+		((read) == (write))
+
+/* ...test if ring buffer is full */
+#define XF_QUEUE_FULL(read, write)      \
+		((write) == (read) + (XF_PROXY_MESSAGE_QUEUE_LENGTH << 16))
+
+/* ...basic cache operations */
+#define XF_PROXY_INVALIDATE(addr, len)  { }
+
+#define XF_PROXY_FLUSH(addr, len)       { }
+
+/* ...data managed by host CPU (remote) - in case of shunt it is a IPC layer */
+struct xf_proxy_host_data {
+	/* ...command queue */
+	struct xf_proxy_message command[XF_PROXY_MESSAGE_QUEUE_LENGTH];
+
+	/* ...writing index into command queue */
+	u32                 cmd_write_idx;
+
+	/* ...reading index for response queue */
+	u32                 rsp_read_idx;
+
+	/* ...indicate command queue is valid or not */
+	u32                 cmd_invalid;
+};
+
+/* ...data managed by DSP (local) */
+struct xf_proxy_dsp_data {
+	/* ...response queue */
+	struct xf_proxy_message response[XF_PROXY_MESSAGE_QUEUE_LENGTH];
+
+	/* ...writing index into response queue */
+	u32                 rsp_write_idx;
+
+	/* ...reading index for command queue */
+	u32                 cmd_read_idx;
+
+	/* ...indicate response queue is valid or not */
+	u32                 rsp_invalid;
+};
+
+/* ...shared memory data */
+struct xf_shmem_data {
+	/* ...ingoing data (maintained by DSP (local side)) */
+	struct xf_proxy_host_data    local;
+
+	/* ...outgoing data (maintained by host CPU (remote side)) */
+	struct xf_proxy_dsp_data   remote;
+
+};
+
+/* ...shared memory data accessor */
+#define XF_SHMEM_DATA(proxy)                \
+		((proxy)->ipc.shmem)
+
+/* ...atomic reading */
+#define __XF_PROXY_READ_ATOMIC(var)         \
+	({ XF_PROXY_INVALIDATE(&(var), sizeof(var));  \
+	 *(u32 *)&(var); })
+
+/* ...atomic writing */
+#define __XF_PROXY_WRITE_ATOMIC(var, value) \
+	({*(u32 *)&(var) = (value);    \
+	 XF_PROXY_FLUSH(&(var), sizeof(var));   \
+	 (value); })
+
+/* ...accessors */
+#define XF_PROXY_READ(proxy, field)          \
+		__XF_PROXY_READ_##field(XF_SHMEM_DATA(proxy))
+
+#define XF_PROXY_WRITE(proxy, field, v)      \
+		__XF_PROXY_WRITE_##field(XF_SHMEM_DATA(proxy), (v))
+
+/* ...individual fields reading */
+#define __XF_PROXY_READ_cmd_write_idx(shmem)        \
+		__XF_PROXY_READ_ATOMIC(shmem->local.cmd_write_idx)
+
+#define __XF_PROXY_READ_cmd_read_idx(shmem)         \
+		shmem->remote.cmd_read_idx
+
+#define __XF_PROXY_READ_cmd_invalid(shmem)            \
+		__XF_PROXY_READ_ATOMIC(shmem->local.cmd_invalid)
+
+#define __XF_PROXY_READ_rsp_write_idx(shmem)        \
+		__XF_PROXY_READ_ATOMIC(shmem->remote.rsp_write_idx)
+
+#define __XF_PROXY_READ_rsp_read_idx(shmem)         \
+		shmem->local.rsp_read_idx
+
+#define __XF_PROXY_READ_rsp_invalid(shmem)            \
+		__XF_PROXY_READ_ATOMIC(shmem->remote.rsp_invalid)
+
+/* ...individual fields writings */
+#define __XF_PROXY_WRITE_cmd_write_idx(shmem, v)    \
+		__XF_PROXY_WRITE_ATOMIC(shmem->local.cmd_write_idx, v)
+
+#define __XF_PROXY_WRITE_cmd_read_idx(shmem, v)     \
+		__XF_PROXY_WRITE_ATOMIC(shmem->remote.cmd_read_idx, v)
+
+#define __XF_PROXY_WRITE_cmd_invalid(shmem, v)     \
+		__XF_PROXY_WRITE_ATOMIC(shmem->local.cmd_invalid, v)
+
+#define __XF_PROXY_WRITE_rsp_read_idx(shmem, v)     \
+		__XF_PROXY_WRITE_ATOMIC(shmem->local.rsp_read_idx, v)
+
+#define __XF_PROXY_WRITE_rsp_write_idx(shmem, v)    \
+		__XF_PROXY_WRITE_ATOMIC(shmem->remote.rsp_write_idx, v)
+
+#define __XF_PROXY_WRITE_rsp_invalid(shmem, v)     \
+		__XF_PROXY_WRITE_ATOMIC(shmem->remote.rsp_invalid, v)
+
+/* ...command buffer accessor */
+#define XF_PROXY_COMMAND(proxy, idx)                \
+		(&XF_SHMEM_DATA(proxy)->local.command[(idx)])
+
+/* ...response buffer accessor */
+#define XF_PROXY_RESPONSE(proxy, idx)               \
+		(&XF_SHMEM_DATA(proxy)->remote.response[(idx)])
+
+/*******************************************************************************
+ * Local proxy data
+ ******************************************************************************/
+
+struct xf_proxy_ipc_data {
+	/* ...shared memory data pointer */
+	struct xf_shmem_data __iomem     *shmem;
+
+	/* ...core identifier */
+	u32                     core;
+
+	/* ...IPC registers memory */
+	void __iomem           *regs;
+};
+
+/* ...proxy data */
+struct xf_proxy {
+	/* ...IPC layer data */
+	struct xf_proxy_ipc_data ipc;
+
+	/* ...shared memory status change processing item */
+	struct work_struct      work;
+
+	struct completion		cmd_complete;
+	int						is_ready;
+
+	/* ...internal lock */
+	spinlock_t              lock;
+
+	/* ...busy queue (for clients waiting ON NOTIFIcation) */
+	wait_queue_head_t       busy;
+
+	/* ...waiting queue for synchronous proxy operations */
+	wait_queue_head_t       wait;
+
+	/* ...submitted commands queue */
+	struct xf_msg_queue     command;
+
+	/* ...pending responses queue */
+	struct xf_msg_queue     response;
+
+	/* ...global message pool */
+	struct xf_message       pool[XF_CFG_MESSAGE_POOL_SIZE];
+
+	/* ...pointer to first free message in the pool */
+	struct xf_message       *free;
+};
+
+union icm_header_t {
+	struct {
+		u32 msg:6;
+		u32 sub_msg:6;      // sub_msg will have ICM_MSG
+		u32 rsvd:3;     /* reserved */
+		u32 intr:1;     /* intr = 1 when sending msg. */
+		u32 size:15;    /* =size in bytes (excluding header) */
+		u32 ack:1;      /* response message when ack=1 */
+	};
+	u32 allbits;
+};
+
+struct dsp_ext_msg {
+	u32	phys;
+	u32	size;
+};
+
+struct dsp_mem_msg {
+	u32 ext_msg_phys;
+	u32 ext_msg_size;
+	u32 scratch_phys;
+	u32 scratch_size;
+	u32 dsp_config_phys;
+	u32 dsp_config_size;
+};
+
+static inline void xf_lock_init(spinlock_t *lock)
+{
+	spin_lock_init(lock);
+}
+
+static inline void xf_lock(spinlock_t *lock)
+{
+	spin_lock(lock);
+}
+
+static inline void xf_unlock(spinlock_t *lock)
+{
+	spin_unlock(lock);
+}
+
+/* ...init proxy */
+int xf_proxy_init(struct xf_proxy *proxy);
+
+/* ...send message to proxy */
+int xf_cmd_send(struct xf_proxy *proxy,
+				u32 id,
+				u32 opcode,
+				void *buffer,
+				u32 length);
+
+/* ...get message from proxy */
+struct xf_message *xf_cmd_recv(struct xf_proxy *proxy,
+					wait_queue_head_t *wq,
+					struct xf_msg_queue *queue,
+					int wait);
+
+/* ...mu interrupt handle */
+irqreturn_t fsl_dsp_mu_isr(int irq, void *dev_id);
+
+/* ...initialize client pending message queue */
+void xf_msg_queue_init(struct xf_msg_queue *queue);
+
+/* ...return current queue state */
+struct xf_message *xf_msg_queue_head(struct xf_msg_queue *queue);
+
+/* ...return the message back to a pool */
+void xf_msg_free(struct xf_proxy *proxy, struct xf_message *m);
+
+/* ...release all pending messages */
+void xf_msg_free_all(struct xf_proxy *proxy, struct xf_msg_queue *queue);
+
+/* ...wait mu interrupt */
+long icm_ack_wait(struct xf_proxy *proxy, u32 msg);
+
+/* ...shared memory translation - kernel virtual address to shared address */
+u32 xf_proxy_b2a(struct xf_proxy *proxy, void *b);
+
+/* ...shared memory translation - shared address to kernel virtual address */
+void *xf_proxy_a2b(struct xf_proxy *proxy, u32 address);
+
+int xf_cmd_send_suspend(struct xf_proxy *proxy);
+int xf_cmd_send_resume(struct xf_proxy *proxy);
+
+#endif
diff --git a/sound/soc/fsl/fsl_hifi4.c b/sound/soc/fsl/fsl_hifi4.c
deleted file mode 100644
index 63a4981..0000000
--- a/sound/soc/fsl/fsl_hifi4.c
+++ /dev/null
@@ -1,1028 +0,0 @@
-/*
- * Freescale HIFI 4 driver
- *
- * Copyright (c) 2012-2013 by Tensilica Inc. ALL RIGHTS RESERVED.
- * Copyright 2018 NXP
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- * Copyright (c) 2001 William L. Pitts
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms are freely
- * permitted provided that the above copyright notice and this
- * paragraph and the following disclaimer are duplicated in all
- * such forms.
- *
- * This software is provided "AS IS" and without any express or
- * implied warranties, including, without limitation, the implied
- * warranties of merchantability and fitness for a particular
- * purpose.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/dma-mapping.h>
-#include <linux/module.h>
-#include <linux/firmware.h>
-#include <linux/interrupt.h>
-#include <linux/file.h>
-#include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <linux/slab.h>
-#include <linux/platform_data/dma-imx.h>
-#include <linux/miscdevice.h>
-#include <linux/fs.h>
-#include <linux/pm_runtime.h>
-#include <linux/mx8_mu.h>
-#include <linux/uaccess.h>
-#include <linux/poll.h>
-#ifdef CONFIG_COMPAT
-#include <linux/compat.h>
-#endif
-#include <uapi/linux/mxc_hifi4.h>
-#include <soc/imx8/sc/svc/irq/api.h>
-#include <soc/imx8/sc/ipc.h>
-#include <soc/imx8/sc/sci.h>
-#include "fsl_hifi4.h"
-
-
-/* ...allocate new client */
-static inline struct xf_client *xf_client_alloc(struct fsl_hifi4 *hifi4_priv)
-{
-	struct xf_client *client;
-	u32             id;
-
-	id = hifi4_priv->xf_client_map[0].next;
-
-	/* ...try to allocate a client handle */
-	if (id != 0) {
-		/* ...allocate client memory */
-		client = kmalloc(sizeof(*client), GFP_KERNEL);
-		if (!client)
-			return ERR_PTR(-ENOMEM);
-
-		/* ...advance the head of free clients */
-		hifi4_priv->xf_client_map[0].next =
-				hifi4_priv->xf_client_map[id].next;
-
-		/* ...put associate client id with given object */
-		hifi4_priv->xf_client_map[id].client = client;
-
-		/* ...mark client is not yet bound to proxy */
-		client->proxy = NULL;
-
-		/* ...save global proxy client identifier */
-		client->id = id;
-
-		return client;
-	}
-
-	/* ...number of clients exceeded */
-	return ERR_PTR(-EBUSY);
-}
-
-/* ...recycle client object */
-static inline void xf_client_free(struct xf_client *client)
-{
-	int     id = client->id;
-	struct fsl_hifi4 *hifi4_priv = (struct fsl_hifi4 *)client->global;
-
-	/* ...put proxy client id into free clients list */
-	hifi4_priv->xf_client_map[id].next = hifi4_priv->xf_client_map[0].next;
-	hifi4_priv->xf_client_map[0].next = id;
-
-	/* ...destroy client data */
-	kfree(client);
-}
-
-/* ...lookup client basing on id */
-struct xf_client *xf_client_lookup(struct fsl_hifi4 *hifi4_priv, u32 id)
-{
-	if ((id >= XF_CFG_MAX_IPC_CLIENTS) ||
-		(hifi4_priv->xf_client_map[id].next < XF_CFG_MAX_IPC_CLIENTS)
-	   )
-		return NULL;
-	else
-		return hifi4_priv->xf_client_map[id].client;
-}
-
-/* ...helper function for retrieving the client handle */
-static inline struct xf_client *xf_get_client(struct file *file)
-{
-	struct xf_client *client;
-	u32             id;
-
-	client = (struct xf_client *)file->private_data;
-	if (!client)
-		return ERR_PTR(-EINVAL);
-
-	id = client->id;
-	if (id >= XF_CFG_MAX_IPC_CLIENTS)
-		return ERR_PTR(-EINVAL);
-
-	return client;
-}
-
-static int fsl_dsp_client_register(struct xf_client *client)
-{
-	struct fsl_hifi4 *hifi4_priv;
-	struct device *dev;
-
-	hifi4_priv = (struct fsl_hifi4 *)client->global;
-	dev = hifi4_priv->dev;
-
-	/* ...make sure client is not registered yet */
-	if (client->proxy != NULL) {
-		pr_err("client-%x already registered", client->id);
-		return -EBUSY;
-	}
-
-	/* ...complete association (no communication with remote proxy here) */
-	client->proxy = &hifi4_priv->proxy;
-
-	pr_debug("client-%x registered within proxy", client->id);
-
-	return 0;
-}
-
-/* ...unregister client from shared memory interface */
-static int fsl_dsp_client_unregister(struct xf_client *client)
-{
-	struct xf_proxy *proxy = client->proxy;
-
-	/* ...make sure client is registered */
-	if (proxy == NULL) {
-		pr_err("client-%x is not registered", client->id);
-		return -EBUSY;
-	}
-
-	/* ...just clean proxy reference */
-	client->proxy = NULL;
-
-	pr_debug("client-%x registered within proxy", client->id);
-
-	return 0;
-}
-
-static int fsl_dsp_ipc_msg_to_dsp(struct xf_client *client,
-							void __user *user)
-{
-	struct fsl_hifi4 *hifi4_priv = (struct fsl_hifi4 *)client->global;
-	struct device *dev = hifi4_priv->dev;
-	struct xf_proxy_message msg;
-	void *buffer;
-	unsigned long ret = 0;
-
-	ret = copy_from_user(&msg, user, sizeof(struct xf_proxy_message));
-	if (ret) {
-		dev_err(dev, "failed to get message from user space\n");
-		return -EFAULT;
-	}
-
-	/* ...make sure message pointer is sane */
-	buffer = xf_proxy_a2b(&hifi4_priv->proxy, msg.address);
-	if (buffer == (void *)-1)
-		return -EFAULT;
-
-	/* ...put current proxy client into message session id */
-	msg.session_id = XF_MSG_AP_FROM_USER(msg.session_id, client->id);
-
-	xf_cmd_send(&hifi4_priv->proxy,
-				msg.session_id,
-				msg.opcode,
-				buffer,
-				msg.length);
-
-	return 0;
-}
-
-static int fsl_dsp_ipc_msg_from_dsp(struct xf_client *client,
-							void __user *user)
-{
-	struct fsl_hifi4 *hifi4_priv = (struct fsl_hifi4 *)client->global;
-	struct device *dev = hifi4_priv->dev;
-	struct xf_message *m;
-	struct xf_proxy_message msg;
-	unsigned long ret = 0;
-
-	m = xf_cmd_recv(&hifi4_priv->proxy, &client->wait, &client->queue, 0);
-	if (IS_ERR(m)) {
-		dev_err(dev, "receiving failed: %d", (int)PTR_ERR(m));
-		return PTR_ERR(m);
-	}
-
-	/* ...check if there is a response available */
-	if (m == NULL)
-		return -EAGAIN;
-
-	/* ...prepare message parameters (lock is taken) */
-	msg.session_id = XF_MSG_AP_TO_USER(m->id);
-	msg.opcode = m->opcode;
-	msg.length = m->length;
-	msg.address = xf_proxy_b2a(&hifi4_priv->proxy, m->buffer);
-	msg.ret = m->ret;
-
-	/* ...return the message back to a pool and release lock */
-	xf_msg_free(&hifi4_priv->proxy, m);
-	xf_unlock(&hifi4_priv->proxy.lock);
-
-	ret = copy_to_user(user, &msg, sizeof(struct xf_proxy_message));
-	if (ret) {
-		dev_err(dev, "failed to response message to user space\n");
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
-static int fsl_dsp_get_shmem_info(struct xf_client *client,
-							void __user *user)
-{
-	struct fsl_hifi4 *hifi4_priv = (struct fsl_hifi4 *)client->global;
-	struct device *dev = hifi4_priv->dev;
-	struct shmem_info mem_info;
-	unsigned long ret = 0;
-
-	mem_info.phys_addr = hifi4_priv->scratch_buf_phys;
-	mem_info.size = hifi4_priv->scratch_buf_size;
-
-	ret = copy_to_user(user, &mem_info, sizeof(struct shmem_info));
-	if (ret) {
-		dev_err(dev, "failed to response message to user space\n");
-		return -EFAULT;
-	}
-
-	return ret;
-}
-
-static struct miscdevice hifi4_miscdev = {
-	.name	= "mxc_hifi4",
-	.minor	= MISC_DYNAMIC_MINOR,
-};
-
-static long fsl_hifi4_ioctl(struct file *file, unsigned int cmd,
-						unsigned long arg)
-{
-	struct xf_client *client;
-	struct fsl_hifi4 *hifi4_priv;
-	struct xf_proxy  *proxy;
-	struct device *dev;
-	void __user *user;
-	long ret = 0;
-
-	/* ...basic sanity checks */
-	client = xf_get_client(file);
-	if (IS_ERR(client))
-		return PTR_ERR(client);
-
-	hifi4_priv = (struct fsl_hifi4 *)client->global;
-	proxy = &hifi4_priv->proxy;
-	dev = hifi4_priv->dev;
-	user = (void __user *)arg;
-
-	mutex_lock(&hifi4_priv->hifi4_mutex);
-
-	if (!proxy->is_ready) {
-		mutex_unlock(&hifi4_priv->hifi4_mutex);
-		dev_err(dev, "hifi firmware is not ready\n");
-		return -EFAULT;
-	}
-
-	switch (cmd) {
-	case DSP_CLIENT_REGISTER:
-		ret = fsl_dsp_client_register(client);
-		break;
-	case DSP_CLIENT_UNREGISTER:
-		ret = fsl_dsp_client_unregister(client);
-		break;
-	case DSP_IPC_MSG_SEND:
-		ret = fsl_dsp_ipc_msg_to_dsp(client, user);
-		break;
-	case DSP_IPC_MSG_RECV:
-		ret = fsl_dsp_ipc_msg_from_dsp(client, user);
-		break;
-	case DSP_GET_SHMEM_INFO:
-		ret = fsl_dsp_get_shmem_info(client, user);
-		break;
-	default:
-		break;
-	}
-
-	mutex_unlock(&hifi4_priv->hifi4_mutex);
-
-	return ret;
-}
-
-void resource_release(struct fsl_hifi4 *hifi4_priv)
-{
-	int i;
-
-	/* ...initialize client association map */
-	for (i = 0; i < XF_CFG_MAX_IPC_CLIENTS - 1; i++)
-		hifi4_priv->xf_client_map[i].next = i + 1;
-	/* ...set list terminator */
-	hifi4_priv->xf_client_map[i].next = 0;
-
-	/* ...set pointer to shared memory */
-	xf_proxy_init(&hifi4_priv->proxy);
-}
-
-static int fsl_hifi4_open(struct inode *inode, struct file *file)
-{
-	struct fsl_hifi4 *hifi4_priv = dev_get_drvdata(hifi4_miscdev.parent);
-	struct device *dev = hifi4_priv->dev;
-	struct xf_client *client;
-	int ret = 0;
-
-	/* ...basic sanity checks */
-	if (!inode || !file)
-		return -EINVAL;
-
-	/* ...allocate new proxy client object */
-	client = xf_client_alloc(hifi4_priv);
-	if (IS_ERR(client))
-		return PTR_ERR(client);
-
-	/* ...initialize waiting queue */
-	init_waitqueue_head(&client->wait);
-
-	/* ...initialize client pending message queue */
-	xf_msg_queue_init(&client->queue);
-
-	/* ...mark user data is not mapped */
-	client->vm_start = 0;
-
-	/* ...reset mappings counter */
-	atomic_set(&client->vm_use, 0);
-
-	client->global = (void *)hifi4_priv;
-
-	file->private_data = (void *)client;
-
-	pm_runtime_get_sync(dev);
-
-	mutex_lock(&hifi4_priv->hifi4_mutex);
-	/* increase reference counter when opening device */
-	atomic_long_inc(&hifi4_priv->refcnt);
-	mutex_unlock(&hifi4_priv->hifi4_mutex);
-
-	return ret;
-}
-
-static int fsl_hifi4_close(struct inode *inode, struct file *file)
-{
-	struct fsl_hifi4 *hifi4_priv;
-	struct device *dev;
-	struct xf_proxy *proxy;
-	struct xf_client *client;
-
-	/* ...basic sanity checks */
-	client = xf_get_client(file);
-	if (IS_ERR(client))
-		return PTR_ERR(client);
-
-	proxy = client->proxy;
-	if (proxy) {
-		/* ...release all pending messages */
-		xf_msg_free_all(proxy, &client->queue);
-
-		/* ...recycle client id and release memory */
-		xf_client_free(client);
-	}
-
-	hifi4_priv = (struct fsl_hifi4 *)client->global;
-	dev = hifi4_priv->dev;
-	pm_runtime_put_sync(dev);
-
-	mutex_lock(&hifi4_priv->hifi4_mutex);
-	/* decrease reference counter when closing device */
-	atomic_long_dec(&hifi4_priv->refcnt);
-	/* If device is free, reinitialize the resource of
-	 * hifi4 driver and framework
-	 */
-	if (atomic_long_read(&hifi4_priv->refcnt) <= 0)
-		resource_release(hifi4_priv);
-
-	mutex_unlock(&hifi4_priv->hifi4_mutex);
-
-	return 0;
-}
-
-/* ...wait until data is available in the response queue */
-static unsigned int fsl_hifi4_poll(struct file *file, poll_table *wait)
-{
-	struct xf_proxy *proxy;
-	struct xf_client *client;
-	int mask;
-
-	/* ...basic sanity checks */
-	client = xf_get_client(file);
-	if (IS_ERR(client))
-		return PTR_ERR(client);
-
-	/* ...get proxy interface */
-	proxy = client->proxy;
-	if (!proxy)
-		return -EPERM;
-
-	/* ...register client waiting queue */
-	poll_wait(file, &client->wait, wait);
-
-	/* ...return current queue state */
-	mask = (xf_msg_queue_head(&client->queue) ? POLLIN | POLLRDNORM : 0);
-
-	return mask;
-}
-
-/*******************************************************************************
- * Low-level mmap interface
- ******************************************************************************/
-
-/* ...add reference to shared buffer */
-static void hifi4_mmap_open(struct vm_area_struct *vma)
-{
-	struct xf_client *client = vma->vm_private_data;
-
-	/* ...probably just increase counter of open references? - tbd */
-	atomic_inc(&client->vm_use);
-
-	pr_debug("xf_mmap_open: vma = %p, client = %p", vma, client);
-}
-
-/* ...close reference to shared buffer */
-static void hifi4_mmap_close(struct vm_area_struct *vma)
-{
-	struct xf_client *client = vma->vm_private_data;
-
-	pr_debug("xf_mmap_close: vma = %p, b = %p", vma, client);
-
-	/* ...decrement number of mapping */
-	atomic_dec_return(&client->vm_use);
-}
-
-/* ...memory map operations */
-static const struct vm_operations_struct hifi4_mmap_ops = {
-	.open   = hifi4_mmap_open,
-	.close  = hifi4_mmap_close,
-};
-
-/* ...shared memory mapping */
-static int fsl_hifi4_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct xf_proxy *proxy;
-	struct xf_client *client;
-	unsigned long   size;
-	unsigned long   pfn;
-	int             r;
-	struct fsl_hifi4 *hifi4_priv;
-
-	/* ...basic sanity checks */
-	client = xf_get_client(file);
-	if (IS_ERR(client))
-		return PTR_ERR(client);
-
-	/* ...get proxy interface */
-	proxy = client->proxy;
-	if (!proxy)
-		return -EPERM;
-
-	/* ...check it was not mapped already */
-	if (client->vm_start != 0)
-		return -EBUSY;
-
-	/* ...check mapping flags (tbd) */
-	if ((vma->vm_flags & (VM_READ | VM_WRITE | VM_SHARED))
-				!= (VM_READ | VM_WRITE | VM_SHARED))
-		return -EPERM;
-
-	/* ...set memory map operations */
-	vma->vm_ops = &hifi4_mmap_ops;
-
-	/* ...assign private data */
-	client->vm_start = vma->vm_start;
-
-	/* ...set private memory data */
-	vma->vm_private_data = client;
-
-	/* ...set page number of shared memory */
-	hifi4_priv = (struct fsl_hifi4 *)client->global;
-	pfn = hifi4_priv->scratch_buf_phys >> PAGE_SHIFT;
-	size = hifi4_priv->scratch_buf_size;
-
-	/* ...remap shared memory to user-space */
-	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-	r = remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot);
-	if (r != 0) {
-		pr_err("mapping failed: %d", r);
-		return r;
-	}
-
-	/* ...system-specific hook for registering shared memory mapping */
-	return 0;
-}
-
-void *memset_hifi(void *dest, int c, size_t count)
-{
-	uint *dl = (uint *)dest;
-	void *dl_1, *dl_2;
-	size_t align = 4;
-	size_t n, n1, n2;
-
-	/* while all data is aligned (common case), copy a word at a time */
-	if ((((ulong)dest) & (sizeof(*dl) - 1)) != 0) {
-		dl = (unsigned int *)(((ulong)dest + align - 1) &
-								(~(align - 1)));
-		dl_1 = dest;
-		dl_2 = (void *)(((ulong)dest + count) & (~(align - 1)));
-		n1 = (ulong)dl - (ulong)dl_1;
-		n2 = (ulong)dest + count - (ulong)dl_2;
-		n = (count - n1 - n2) / align;
-
-		while (n--) {
-			writel_relaxed(0,  dl);
-			dl++;
-		}
-		while (n1--) {
-			writeb_relaxed(0, dl_1);
-			dl_1++;
-		}
-		while (n2--) {
-			writeb_relaxed(0, dl_2);
-			dl_2++;
-		}
-	} else {
-		n = count / align;
-		n1 = count - n * align;
-		dl_1 = dest + n * align;
-		while (n--) {
-			writel_relaxed(0,  dl);
-			dl++;
-		}
-		while (n1--) {
-			writeb_relaxed(0, dl_1);
-			dl_1++;
-		}
-	}
-
-	return dest;
-}
-
-void *memcpy_hifi(void *dest, const void *src, size_t count)
-{
-	unsigned int *dl = (unsigned int *)dest, *sl = (unsigned int *)src;
-	size_t n = round_up(count, 4) / 4;
-
-	if (src == dest)
-		return dest;
-
-	/* while all data is aligned (common case), copy a word at a time */
-	if ((((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) != 0)
-		pr_info("dest %p src %p not 4 bytes aligned\n", dest, src);
-
-	while (n--) {
-		writel_relaxed(*sl,  dl);
-		dl++;
-		sl++;
-	}
-
-	return dest;
-}
-
-static void hifi4_load_firmware(const struct firmware *fw, void *context)
-{
-	struct fsl_hifi4 *hifi4_priv = context;
-	struct device *dev = hifi4_priv->dev;
-	Elf32_Ehdr *ehdr; /* Elf header structure pointer */
-	Elf32_Shdr *shdr; /* Section header structure pointer */
-	Elf32_Addr  sh_addr;
-	unsigned char *strtab = 0; /* String table pointer */
-	unsigned char *image; /* Binary image pointer */
-	int i; /* Loop counter */
-	unsigned long addr;
-
-	if (!fw) {
-		dev_info(dev, "external firmware not found\n");
-		return;
-	}
-
-	addr = (unsigned long)fw->data;
-	ehdr = (Elf32_Ehdr *)addr;
-
-	/* Find the section header string table for output info */
-	shdr = (Elf32_Shdr *)(addr + ehdr->e_shoff +
-			(ehdr->e_shstrndx * sizeof(Elf32_Shdr)));
-
-	if (shdr->sh_type == SHT_STRTAB)
-		strtab = (unsigned char *)(addr + shdr->sh_offset);
-
-	/* Load each appropriate section */
-	for (i = 0; i < ehdr->e_shnum; ++i) {
-		shdr = (Elf32_Shdr *)(addr + ehdr->e_shoff +
-				(i * sizeof(Elf32_Shdr)));
-
-		if (!(shdr->sh_flags & SHF_ALLOC) ||
-			shdr->sh_addr == 0 || shdr->sh_size == 0)
-			continue;
-
-		if (strtab) {
-			dev_dbg(dev, "%sing %s @ 0x%08lx (%ld bytes)\n",
-			  (shdr->sh_type == SHT_NOBITS) ? "Clear" : "Load",
-				&strtab[shdr->sh_name],
-				(unsigned long)shdr->sh_addr,
-				(long)shdr->sh_size);
-		}
-
-		sh_addr = shdr->sh_addr;
-
-		if (shdr->sh_type == SHT_NOBITS) {
-			memset_hifi((void *)(hifi4_priv->sdram_vir_addr +
-				(sh_addr - hifi4_priv->sdram_phys_addr)),
-				0,
-				shdr->sh_size);
-		} else {
-			image = (unsigned char *)addr + shdr->sh_offset;
-			if ((!strcmp(&strtab[shdr->sh_name], ".rodata")) ||
-				(!strcmp(&strtab[shdr->sh_name], ".text"))   ||
-				(!strcmp(&strtab[shdr->sh_name], ".data"))   ||
-				(!strcmp(&strtab[shdr->sh_name], ".bss"))
-			) {
-				memcpy_hifi((void *)(hifi4_priv->sdram_vir_addr
-				  + (sh_addr - hifi4_priv->sdram_phys_addr)),
-				  (const void *)image,
-				  shdr->sh_size);
-			} else {
-				memcpy_hifi((void *)(hifi4_priv->regs +
-						(sh_addr - hifi4_priv->paddr)),
-						(const void *)image,
-						shdr->sh_size);
-			}
-		}
-	}
-
-	/* start the core */
-	sc_pm_cpu_start(hifi4_priv->hifi_ipcHandle,
-					SC_R_DSP, true, hifi4_priv->iram);
-}
-
-/* Initialization of the MU code. */
-int hifi4_mu_init(struct fsl_hifi4 *hifi4_priv)
-{
-	struct device *dev = hifi4_priv->dev;
-	struct device_node *np;
-	unsigned int	hifi_mu_id;
-	u32 irq;
-	int ret = 0;
-
-	/*
-	 * Get the address of MU to be used for communication with the hifi
-	 */
-	np = of_find_compatible_node(NULL, NULL, "fsl,imx8-mu-hifi");
-	if (!np) {
-		dev_err(dev, "Cannot find MU entry in device tree\n");
-		return -EINVAL;
-	}
-	hifi4_priv->mu_base_virtaddr = of_iomap(np, 0);
-	WARN_ON(!hifi4_priv->mu_base_virtaddr);
-
-	ret = of_property_read_u32_index(np,
-				"fsl,hifi_ap_mu_id", 0, &hifi_mu_id);
-	if (ret) {
-		dev_err(dev, "Cannot get mu_id %d\n", ret);
-		return -EINVAL;
-	}
-
-	hifi4_priv->hifi_mu_id = hifi_mu_id;
-
-	irq = of_irq_get(np, 0);
-
-	ret = devm_request_irq(hifi4_priv->dev, irq, fsl_hifi4_mu_isr,
-			IRQF_EARLY_RESUME, "hifi4_mu_isr", &hifi4_priv->proxy);
-	if (ret) {
-		dev_err(dev, "request_irq failed %d, err = %d\n", irq, ret);
-		return -EINVAL;
-	}
-
-	if (!hifi4_priv->hifi_mu_init) {
-		MU_Init(hifi4_priv->mu_base_virtaddr);
-		MU_EnableRxFullInt(hifi4_priv->mu_base_virtaddr, 0);
-		hifi4_priv->hifi_mu_init = 1;
-	}
-
-	return ret;
-}
-
-static const struct file_operations hifi4_fops = {
-	.owner		= THIS_MODULE,
-	.unlocked_ioctl	= fsl_hifi4_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = fsl_hifi4_ioctl,
-#endif
-	.open		= fsl_hifi4_open,
-	.poll		= fsl_hifi4_poll,
-	.mmap		= fsl_hifi4_mmap,
-	.release	= fsl_hifi4_close,
-};
-
-static int fsl_hifi4_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct fsl_hifi4 *hifi4_priv;
-	const char *fw_name;
-	struct resource *res;
-	void __iomem *regs;
-	uint32_t mu_id;
-	sc_err_t sciErr;
-	void *buf_virt;
-	dma_addr_t buf_phys;
-	int size, offset, i;
-	int ret;
-
-	hifi4_priv = devm_kzalloc(&pdev->dev, sizeof(*hifi4_priv), GFP_KERNEL);
-	if (!hifi4_priv)
-		return -ENOMEM;
-
-	hifi4_priv->dev = &pdev->dev;
-
-	/* Get the addresses and IRQ */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
-
-	hifi4_priv->paddr = res->start;
-	hifi4_priv->regs  = regs;
-
-	hifi4_priv->dram0 = hifi4_priv->paddr + DRAM0_OFFSET;
-	hifi4_priv->dram1 = hifi4_priv->paddr + DRAM1_OFFSET;
-	hifi4_priv->iram  = hifi4_priv->paddr + IRAM_OFFSET;
-	hifi4_priv->sram  = hifi4_priv->paddr + SYSRAM_OFFSET;
-
-	sciErr = sc_ipc_getMuID(&mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		dev_err(&pdev->dev, "Cannot obtain MU ID\n");
-		return sciErr;
-	}
-
-	sciErr = sc_ipc_open(&hifi4_priv->hifi_ipcHandle, mu_id);
-	if (sciErr != SC_ERR_NONE) {
-		dev_err(&pdev->dev, "Cannot open MU channel to SCU %d, %d\n",
-								mu_id, sciErr);
-		return sciErr;
-	};
-
-	sciErr = sc_misc_set_control(hifi4_priv->hifi_ipcHandle, SC_R_DSP,
-				SC_C_OFS_SEL, 1);
-	if (sciErr != SC_ERR_NONE) {
-		dev_err(&pdev->dev, "Error system address offset source select\n");
-		return -EIO;
-	}
-
-	sciErr = sc_misc_set_control(hifi4_priv->hifi_ipcHandle, SC_R_DSP,
-				SC_C_OFS_AUDIO, 0x80);
-	if (sciErr != SC_ERR_NONE) {
-		dev_err(&pdev->dev, "Error system address offset of AUDIO\n");
-		return -EIO;
-	}
-
-	sciErr = sc_misc_set_control(hifi4_priv->hifi_ipcHandle, SC_R_DSP,
-				SC_C_OFS_PERIPH, 0x5A);
-	if (sciErr != SC_ERR_NONE) {
-		dev_err(&pdev->dev, "Error system address offset of PERIPH\n");
-		return -EIO;
-	}
-
-	sciErr = sc_misc_set_control(hifi4_priv->hifi_ipcHandle, SC_R_DSP,
-				SC_C_OFS_IRQ, 0x51);
-	if (sciErr != SC_ERR_NONE) {
-		dev_err(&pdev->dev, "Error system address offset of IRQ\n");
-		return -EIO;
-	}
-
-	ret = hifi4_mu_init(hifi4_priv);
-	if (ret)
-		return ret;
-
-	ret = of_property_read_string(np, "fsl,hifi4-firmware", &fw_name);
-	hifi4_priv->fw_name = fw_name;
-
-	platform_set_drvdata(pdev, hifi4_priv);
-	pm_runtime_enable(&pdev->dev);
-
-	hifi4_miscdev.fops = &hifi4_fops,
-	hifi4_miscdev.parent = &pdev->dev,
-	ret = misc_register(&hifi4_miscdev);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to register misc device %d\n", ret);
-		return ret;
-	}
-
-	hifi4_priv->sdram_phys_addr = SDRAM_BASE_ADDR;
-	hifi4_priv->sdram_vir_addr = ioremap_wc(hifi4_priv->sdram_phys_addr,
-							SDRAM_BASE_SIZE);
-	if (!hifi4_priv->sdram_vir_addr) {
-		dev_err(&pdev->dev, "failed to remap sdram space for hifi4 firmware\n");
-		return -ENXIO;
-	}
-	memset_io(hifi4_priv->sdram_vir_addr, 0, SDRAM_BASE_SIZE);
-
-	size = MSG_BUF_SIZE + HIFI_CONFIG_SIZE;
-
-	buf_virt = dma_alloc_coherent(&pdev->dev, size, &buf_phys, GFP_KERNEL);
-	if (!buf_virt) {
-		dev_err(&pdev->dev, "failed alloc memory.\n");
-		return -ENOMEM;
-	}
-
-	/* msg ring buffer memory */
-	hifi4_priv->msg_buf_virt = buf_virt;
-	hifi4_priv->msg_buf_phys = buf_phys;
-	hifi4_priv->msg_buf_size = MSG_BUF_SIZE;
-	offset = MSG_BUF_SIZE;
-
-	/* keep dsp framework's global data when suspend/resume */
-	hifi4_priv->hifi_config_virt = buf_virt + offset;
-	hifi4_priv->hifi_config_phys = buf_phys + offset;
-	hifi4_priv->hifi_config_size = HIFI_CONFIG_SIZE;
-
-	/* scratch memory for dsp framework */
-	hifi4_priv->scratch_buf_virt = hifi4_priv->sdram_vir_addr +
-						SDRAM_CODEC_LIB_OFFSET;
-	hifi4_priv->scratch_buf_phys = hifi4_priv->sdram_phys_addr +
-						SDRAM_CODEC_LIB_OFFSET;
-	hifi4_priv->scratch_buf_size = SDRAM_BASE_SIZE - SDRAM_CODEC_LIB_OFFSET;
-
-	/* initialize the reference counter for hifi4_priv
-	 * structure
-	 */
-	atomic_long_set(&hifi4_priv->refcnt, 0);
-
-	/* ...initialize client association map */
-	for (i = 0; i < XF_CFG_MAX_IPC_CLIENTS - 1; i++)
-		hifi4_priv->xf_client_map[i].next = i + 1;
-	/* ...set list terminator */
-	hifi4_priv->xf_client_map[i].next = 0;
-
-	/* ...set pointer to shared memory */
-	xf_proxy_init(&hifi4_priv->proxy);
-
-	/* ...initialize mutex */
-	mutex_init(&hifi4_priv->hifi4_mutex);
-
-	return 0;
-}
-
-static int fsl_hifi4_remove(struct platform_device *pdev)
-{
-	struct fsl_hifi4 *hifi4_priv = platform_get_drvdata(pdev);
-	int size;
-
-	misc_deregister(&hifi4_miscdev);
-
-	size = MSG_BUF_SIZE + HIFI_CONFIG_SIZE;
-	dma_free_coherent(&pdev->dev, size, hifi4_priv->msg_buf_virt,
-				hifi4_priv->msg_buf_phys);
-	if (hifi4_priv->sdram_vir_addr)
-		iounmap(hifi4_priv->sdram_vir_addr);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int fsl_hifi4_runtime_resume(struct device *dev)
-{
-	struct fsl_hifi4 *hifi4_priv = dev_get_drvdata(dev);
-	struct xf_proxy *proxy = &hifi4_priv->proxy;
-	int ret;
-
-	if (sc_pm_set_resource_power_mode(hifi4_priv->hifi_ipcHandle,
-			SC_R_DSP_RAM, SC_PM_PW_MODE_ON) != SC_ERR_NONE) {
-		dev_err(dev, "Error power on HIFI RAM\n");
-		return -EIO;
-	}
-
-	if (!proxy->is_ready) {
-		init_completion(&proxy->cmd_complete);
-
-		ret = request_firmware_nowait(THIS_MODULE,
-				FW_ACTION_HOTPLUG, hifi4_priv->fw_name,
-				dev,
-				GFP_KERNEL, hifi4_priv, hifi4_load_firmware);
-
-		if (ret) {
-			dev_err(dev, "failed to load firmware\n");
-			return ret;
-		}
-
-		ret = icm_ack_wait(proxy, 0);
-		if (ret) {
-			return ret;
-		}
-		dev_info(dev, "hifi driver registered\n");
-	}
-
-	return 0;
-}
-
-static int fsl_hifi4_runtime_suspend(struct device *dev)
-{
-	struct fsl_hifi4 *hifi4_priv = dev_get_drvdata(dev);
-	struct xf_proxy *proxy = &hifi4_priv->proxy;
-
-	if (sc_pm_set_resource_power_mode(hifi4_priv->hifi_ipcHandle,
-			SC_R_DSP_RAM, SC_PM_PW_MODE_OFF) != SC_ERR_NONE) {
-		dev_err(dev, "Error power off HIFI RAM\n");
-		return -EIO;
-	}
-	proxy->is_ready = 0;
-	return 0;
-}
-#endif /* CONFIG_PM */
-
-
-#ifdef CONFIG_PM_SLEEP
-static int fsl_hifi4_suspend(struct device *dev)
-{
-	struct fsl_hifi4 *hifi4_priv = dev_get_drvdata(dev);
-	struct xf_proxy *proxy = &hifi4_priv->proxy;
-	int ret = 0;
-
-	if (proxy->is_ready) {
-		ret = xf_cmd_send_suspend(proxy);
-		if (ret) {
-			dev_err(dev, "hifi4 suspend fail\n");
-			return ret;
-		}
-	}
-
-	ret = pm_runtime_force_suspend(dev);
-
-	return ret;
-}
-
-static int fsl_hifi4_resume(struct device *dev)
-{
-	struct fsl_hifi4 *hifi4_priv = dev_get_drvdata(dev);
-	struct xf_proxy *proxy = &hifi4_priv->proxy;
-	int ret = 0;
-
-	ret = pm_runtime_force_resume(dev);
-	if (ret)
-		return ret;
-
-	if (proxy->is_ready) {
-		ret = xf_cmd_send_resume(proxy);
-		if (ret) {
-			dev_err(dev, "hifi4 resume fail\n");
-			return ret;
-		}
-	}
-
-	return 0;
-}
-#endif /* CONFIG_PM_SLEEP */
-
-static const struct dev_pm_ops fsl_hifi4_pm = {
-	SET_RUNTIME_PM_OPS(fsl_hifi4_runtime_suspend,
-					fsl_hifi4_runtime_resume, NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(fsl_hifi4_suspend, fsl_hifi4_resume)
-};
-
-static const struct of_device_id fsl_hifi4_ids[] = {
-	{ .compatible = "fsl,imx8qxp-hifi4", },
-	{}
-};
-MODULE_DEVICE_TABLE(of, fsl_hifi4_ids);
-
-static struct platform_driver fsl_hifi4_driver = {
-	.probe = fsl_hifi4_probe,
-	.remove = fsl_hifi4_remove,
-	.driver = {
-		.name = "fsl-hifi4",
-		.of_match_table = fsl_hifi4_ids,
-		.pm = &fsl_hifi4_pm,
-	},
-};
-module_platform_driver(fsl_hifi4_driver);
-
-MODULE_DESCRIPTION("Freescale HIFI 4 driver");
-MODULE_ALIAS("platform:fsl-hifi4");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/fsl/fsl_hifi4.h b/sound/soc/fsl/fsl_hifi4.h
deleted file mode 100644
index 4700d66..0000000
--- a/sound/soc/fsl/fsl_hifi4.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Freescale HIFI 4 driver
- *
- * Copyright 2018 NXP
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#include <uapi/linux/mxc_hifi4.h>
-#include "fsl_hifi4_proxy.h"
-
-
-typedef void (*memcpy_func) (void *dest, const void *src, size_t n);
-typedef void (*memset_func) (void *s, int c, size_t n);
-
-/* ...maximal number of IPC clients per proxy */
-#define XF_CFG_MAX_IPC_CLIENTS          (1 << 4)
-
-
-/* ...proxy client data */
-struct xf_client {
-	/* ...pointer to proxy interface */
-	struct xf_proxy     *proxy;
-
-	/* ...allocated proxy client id */
-	u32                 id;
-
-	/* ...pending response queue */
-	struct xf_msg_queue queue;
-
-	/* ...response waiting queue */
-	wait_queue_head_t   wait;
-
-	/* ...virtual memory mapping */
-	unsigned long       vm_start;
-
-	/* ...counter of memory mappings (no real use of it yet - tbd) */
-	atomic_t            vm_use;
-
-	/* ...global structure pointer */
-	void				*global;
-};
-
-union xf_client_link {
-	/* ...index of next client in free list */
-	u32                 next;
-
-	/* ...reference to proxy data for allocated client */
-	struct xf_client    *client;
-};
-
-struct fsl_hifi4 {
-	struct device			*dev;
-	const char			*fw_name;
-	void __iomem			*regs;
-	void __iomem			*mu_base_virtaddr;
-	sc_ipc_t			hifi_ipcHandle;
-	sc_ipc_t			mu_ipcHandle;
-	unsigned int			hifi_mu_id;
-	int				hifi_mu_init;
-	atomic_long_t			refcnt;
-	unsigned long			paddr;
-	unsigned long			dram0;
-	unsigned long			dram1;
-	unsigned long			iram;
-	unsigned long			sram;
-	void			        *sdram_vir_addr;
-	unsigned long			sdram_phys_addr;
-	void				*msg_buf_virt;
-	dma_addr_t			 msg_buf_phys;
-	int				 msg_buf_size;
-	void				*scratch_buf_virt;
-	dma_addr_t			 scratch_buf_phys;
-	int				 scratch_buf_size;
-	void				*hifi_config_virt;
-	dma_addr_t			 hifi_config_phys;
-	int				 hifi_config_size;
-
-	/* ...proxy data structures */
-	struct xf_proxy proxy;
-
-	/* ...mutex lock */
-	struct mutex hifi4_mutex;
-
-	/* ...global clients pool (item[0] serves as list terminator) */
-	union xf_client_link xf_client_map[XF_CFG_MAX_IPC_CLIENTS];
-};
-
-#define IRAM_OFFSET		0x10000
-#define IRAM_SIZE		2048
-
-#define DRAM0_OFFSET		0x0
-#define DRAM0_SIZE		0x8000
-
-#define DRAM1_OFFSET		0x8000
-#define DRAM1_SIZE		0x8000
-
-#define SYSRAM_OFFSET		0x18000
-#define SYSRAM_SIZE		0x40000
-
-#define SYSROM_OFFSET		0x58000
-#define SYSROM_SIZE		0x30000
-
-#define MSG_BUF_SIZE		8192
-#define INPUT_BUF_SIZE		4096
-#define OUTPUT_BUF_SIZE		16384
-#define HIFI_CONFIG_SIZE    4096
-
-/*external buffer
- *  ----------------------------------------------------------------------
- *  |  name                      | size     |   description     |
- * -----------------------------------------------------------------------
- *  |  scratch buffer for malloc | 0xffffff | For MEM_scratch_malloc()
- * ------------------------------------------------------------------------
- *  |  global structure          | 4096     | For store hifi config structure
- * ------------------------------------------------------------------------
- */
-
-#define MEMORY_REMAP_OFFSET	0x39000000
-
-/* reserved memory for hifi4 firmware and core libs to
- * save their instruction/data section in SDRAM, the physical
- * address range is 0x8e000000 ~ 0x8fffffff (32M bytes).
- */
-#define SDRAM_BASE_ADDR  0x8e000000
-#define SDRAM_BASE_SIZE  0x1ffffff
-#define SDRAM_CODEC_LIB_OFFSET 0x1000000
-#define SDRAM_SCRATCH_BUF_SIZE 0xffffff
-
-#define SC_C_OFS_SEL    39
-#define SC_C_OFS_AUDIO  40
-#define SC_C_OFS_PERIPH 41
-#define SC_C_OFS_IRQ    42
-
-void *memcpy_hifi(void *dest, const void *src, size_t count);
-void *memset_hifi(void *dest, int c, size_t count);
-struct xf_client *xf_client_lookup(struct fsl_hifi4 *hifi4_priv, u32 id);
diff --git a/sound/soc/fsl/fsl_hifi4_proxy.c b/sound/soc/fsl/fsl_hifi4_proxy.c
deleted file mode 100644
index 27aece7..0000000
--- a/sound/soc/fsl/fsl_hifi4_proxy.c
+++ /dev/null
@@ -1,702 +0,0 @@
-/*******************************************************************************
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- *
- * Copyright (C) 2017 Cadence Design Systems, Inc.
- * Copyright 2018 NXP
- *
- ******************************************************************************/
-/*******************************************************************************
- * fsl_hifi4_proxy.c
- *
- * DSP proxy driver
- *
- * DSP proxy driver is used to transfer messages between dsp driver
- * and dsp framework
- ******************************************************************************/
-
-#include <soc/imx8/sc/ipc.h>
-#include "fsl_hifi4_proxy.h"
-#include "fsl_hifi4.h"
-
-
-/* ...initialize message queue */
-void xf_msg_queue_init(struct xf_msg_queue *queue)
-{
-	queue->head = queue->tail = NULL;
-}
-
-/* ...get message queue head */
-struct xf_message *xf_msg_queue_head(struct xf_msg_queue *queue)
-{
-	return queue->head;
-}
-
-/* ...allocate new message from the pool */
-struct xf_message *xf_msg_alloc(struct xf_proxy *proxy)
-{
-	struct xf_message *m = proxy->free;
-
-	/* ...make sure we have a free message item */
-	if (m != NULL) {
-		/* ...get message from the pool */
-		proxy->free = m->next, m->next = NULL;
-	}
-
-	return m;
-}
-
-/* ...return message to the pool of free items */
-void xf_msg_free(struct xf_proxy *proxy, struct xf_message *m)
-{
-	/* ...put message into the head of free items list */
-	m->next = proxy->free, proxy->free = m;
-
-	/* ...notify potential client waiting for message */
-	wake_up(&proxy->busy);
-}
-
-/* ...return all messages from the queue to the pool of free items */
-void xf_msg_free_all(struct xf_proxy *proxy, struct xf_msg_queue *queue)
-{
-	struct xf_message *m = queue->head;
-
-	/* ...check if there is anything in the queue */
-	if (m != NULL) {
-		queue->tail->next = proxy->free;
-		proxy->free = queue->head;
-		queue->head = queue->tail = NULL;
-
-		/* ...notify potential client waiting for message */
-		wake_up(&proxy->busy);
-	}
-}
-
-/* ...submit message to a queue */
-int xf_msg_enqueue(struct xf_msg_queue *queue, struct xf_message *m)
-{
-	int first = (queue->head == NULL);
-
-	/* ...set pointer to next item */
-	m->next = NULL;
-
-	/* ...advance head/tail pointer as required */
-	if (first)
-		queue->head = m;
-	else
-		queue->tail->next = m;
-
-	/* ...new tail points to this message */
-	queue->tail = m;
-
-	return first;
-}
-
-/* ...retrieve next message from the per-task queue */
-struct xf_message *xf_msg_dequeue(struct xf_msg_queue *queue)
-{
-	struct xf_message *m = queue->head;
-
-	/* ...check if there is anything in the queue */
-	if (m != NULL) {
-		/* ...pop message from the head of the list */
-		queue->head = m->next;
-		if (queue->head == NULL)
-			queue->tail = NULL;
-	}
-
-	return m;
-}
-
-/* ...helper function for requesting execution message from a pool */
-struct xf_message *xf_msg_available(struct xf_proxy *proxy)
-{
-	struct xf_message *m;
-
-	/* ...acquire global lock */
-	xf_lock(&proxy->lock);
-
-	/* ...try to allocate the message */
-	m = xf_msg_alloc(proxy);
-	if (m  == NULL) {
-		/* ...failed to allocate message; release lock */
-		xf_unlock(&proxy->lock);
-	}
-
-	/* ...if successfully allocated */
-	return m;
-}
-
-/* ...helper function for receiving a message from per-client queue */
-struct xf_message *xf_msg_received(struct xf_proxy *proxy,
-				struct xf_msg_queue *queue)
-{
-	struct xf_message *m;
-
-	/* ...acquire global lock */
-	xf_lock(&proxy->lock);
-
-	/* ...try to peek message from the queue */
-	m = xf_msg_dequeue(queue);
-	if (m == NULL) {
-		/* ...queue is empty; release lock */
-		xf_unlock(&proxy->lock);
-	}
-
-	/* ...if message is non-null, lock is held */
-	return m;
-}
-
-/*
- * MU related functions
- */
-u32 icm_intr_send(struct xf_proxy *proxy, u32 msg)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-
-	MU_SendMessage(hifi4_priv->mu_base_virtaddr, 0, msg);
-	return 0;
-}
-
-int icm_intr_extended_send(struct xf_proxy *proxy,
-				u32 msg,
-				struct hifi4_ext_msg *ext_msg)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-	struct device *dev = hifi4_priv->dev;
-	union icm_header_t msghdr;
-
-	msghdr.allbits = msg;
-	if (msghdr.size != 8)
-		dev_err(dev, "too much ext msg\n");
-
-	MU_SendMessage(hifi4_priv->mu_base_virtaddr, 1, ext_msg->phys);
-	MU_SendMessage(hifi4_priv->mu_base_virtaddr, 2, ext_msg->size);
-	MU_SendMessage(hifi4_priv->mu_base_virtaddr, 0, msg);
-
-	return 0;
-}
-
-int send_dpu_ext_msg_addr(struct xf_proxy *proxy)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-	union icm_header_t msghdr;
-	struct hifi4_ext_msg ext_msg;
-	struct hifi4_mem_msg *dpu_ext_msg =
-	 (struct hifi4_mem_msg *)((unsigned char *)hifi4_priv->msg_buf_virt
-					+ (MSG_BUF_SIZE / 2));
-	int ret_val = 0;
-
-	msghdr.allbits = 0;	/* clear all bits; */
-	msghdr.ack  = 0;
-	msghdr.intr = 1;
-	msghdr.msg  = ICM_CORE_INIT;
-	msghdr.size = 8;
-	ext_msg.phys = hifi4_priv->msg_buf_phys + (MSG_BUF_SIZE / 2);
-	ext_msg.size = sizeof(struct hifi4_mem_msg);
-
-	dpu_ext_msg->ext_msg_phys = hifi4_priv->msg_buf_phys;
-	dpu_ext_msg->ext_msg_size = MSG_BUF_SIZE;
-	dpu_ext_msg->scratch_phys =  hifi4_priv->scratch_buf_phys;
-	dpu_ext_msg->scratch_size =  hifi4_priv->scratch_buf_size;
-	dpu_ext_msg->hifi_config_phys =  hifi4_priv->hifi_config_phys;
-	dpu_ext_msg->hifi_config_size =  hifi4_priv->hifi_config_size;
-
-	icm_intr_extended_send(proxy, msghdr.allbits, &ext_msg);
-
-	return ret_val;
-}
-
-long icm_ack_wait(struct xf_proxy *proxy, u32 msg)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-	struct device *dev = hifi4_priv->dev;
-	union icm_header_t msghdr;
-	int err;
-
-	msghdr.allbits = msg;
-	/* wait response from mu */
-	err = wait_for_completion_timeout(&proxy->cmd_complete,
-				msecs_to_jiffies(1000));
-	if (!err) {
-		dev_err(dev, "icm ack timeout! %x\n", msg);
-		return -ETIMEDOUT;
-	}
-
-	dev_dbg(dev, "Ack recd for message 0x%08x\n", msghdr.allbits);
-
-	return 0;
-}
-
-irqreturn_t fsl_hifi4_mu_isr(int irq, void *dev_id)
-{
-	struct xf_proxy *proxy = dev_id;
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-	struct device *dev = hifi4_priv->dev;
-	union icm_header_t msghdr;
-	u32 reg;
-
-	MU_ReceiveMsg(hifi4_priv->mu_base_virtaddr, 0, &reg);
-	msghdr = (union icm_header_t)reg;
-
-	if (msghdr.intr == 1) {
-		dev_dbg(dev, "INTR: Received ICM intr, msg 0x%08x\n",
-						msghdr.allbits);
-		switch (msghdr.msg) {
-		case ICM_CORE_EXIT:
-			break;
-		case ICM_CORE_READY:
-			send_dpu_ext_msg_addr(proxy);
-			proxy->is_ready = 1;
-			complete(&proxy->cmd_complete);
-			break;
-		case XF_SUSPEND:
-		case XF_RESUME:
-			complete(&proxy->cmd_complete);
-			break;
-		default:
-			schedule_work(&proxy->work);
-			break;
-		}
-	} else if (msghdr.ack == 1) {
-		dev_dbg(dev, "INTR: Received ICM ack 0x%08x\n", msghdr.size);
-		msghdr.ack = 0;
-	} else {
-		dev_dbg(dev, "Received false ICM intr 0x%08x\n",
-							msghdr.allbits);
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Proxy related functions
- */
-/* ...NULL-address specification */
-#define XF_PROXY_NULL           (~0U)
-
-#define XF_PROXY_BADADDR  SDRAM_SCRATCH_BUF_SIZE
-
-/* ...shared memory translation - kernel virtual address to shared address */
-u32 xf_proxy_b2a(struct xf_proxy *proxy, void *b)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-
-	if (b == NULL)
-		return XF_PROXY_NULL;
-	else if ((u32)(b - hifi4_priv->scratch_buf_virt) <
-					SDRAM_SCRATCH_BUF_SIZE)
-		return (u32)(b - hifi4_priv->scratch_buf_virt);
-	else
-		return XF_PROXY_BADADDR;
-}
-
-/* ...shared memory translation - shared address to kernel virtual address */
-void *xf_proxy_a2b(struct xf_proxy *proxy, u32 address)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-
-	if (address < SDRAM_SCRATCH_BUF_SIZE)
-		return hifi4_priv->scratch_buf_virt + address;
-	else if (address == XF_PROXY_NULL)
-		return NULL;
-	else
-		return (void *) -1;
-}
-
-/* ...process association between response received and intended client */
-static void xf_cmap(struct xf_proxy *proxy, struct xf_message *m)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-	u32 id = XF_AP_IPC_CLIENT(m->id);
-	struct xf_client *client;
-
-	/* ...process messages addressed to proxy itself */
-	if (id == 0) {
-		/* ...place message into local response queue */
-		xf_msg_enqueue(&proxy->response, m);
-		wake_up(&proxy->wait);
-		return;
-	}
-
-	/* ...make sure the client ID is sane */
-	client = xf_client_lookup(hifi4_priv, id);
-	if (!client) {
-		pr_err("rsp[id:%08x]: client lookup failed", m->id);
-		xf_msg_free(proxy, m);
-		return;
-	}
-
-	/* ...make sure client is bound to this proxy interface */
-	if (client->proxy != proxy) {
-		pr_err("rsp[id:%08x]: wrong proxy interface", m->id);
-		xf_msg_free(proxy, m);
-		return;
-	}
-
-	/* ...place message into local response queue */
-	if (xf_msg_enqueue(&client->queue, m))
-		wake_up(&client->wait);
-}
-
-/* ...retrieve pending responses from shared memory ring-buffer */
-static u32 xf_shmem_process_responses(struct xf_proxy *proxy)
-{
-	struct xf_message *m;
-	u32 read_idx, write_idx;
-	int status;
-
-	status = 0;
-
-	/* ...get current values of read/write pointers in response queue */
-	read_idx = XF_PROXY_READ(proxy, rsp_read_idx);
-	write_idx = XF_PROXY_READ(proxy, rsp_write_idx);
-
-	/* ...process all committed responses */
-	while (!XF_QUEUE_EMPTY(read_idx, write_idx)) {
-		struct xf_proxy_message *response;
-
-		/* ...allocate execution message */
-		m = xf_msg_alloc(proxy);
-		if (m  == NULL)
-			break;
-
-		/* ...mark the interface status has changed */
-		status |= (XF_QUEUE_FULL(read_idx, write_idx) ? 0x3 : 0x1);
-
-		/* ...get oldest not yet processed response */
-		response = XF_PROXY_RESPONSE(proxy, XF_QUEUE_IDX(read_idx));
-
-		/* ...fill message parameters */
-		m->id = response->session_id;
-		m->opcode = response->opcode;
-		m->length = response->length;
-		m->buffer = xf_proxy_a2b(proxy, response->address);
-		m->ret = response->ret;
-
-		/* ...advance local reading index copy */
-		read_idx = XF_QUEUE_ADVANCE_IDX(read_idx);
-
-		/* ...update shadow copy of reading index */
-		XF_PROXY_WRITE(proxy, rsp_read_idx, read_idx);
-
-		/* ...submit message to proper client */
-		xf_cmap(proxy, m);
-	}
-
-	return status;
-}
-
-/* ...put pending commands into shared memory ring-buffer */
-static u32 xf_shmem_process_commands(struct xf_proxy *proxy)
-{
-	struct xf_message *m;
-	u32 read_idx, write_idx;
-	int status = 0;
-
-	/* ...get current value of peer read pointer */
-	write_idx = XF_PROXY_READ(proxy, cmd_write_idx);
-	read_idx = XF_PROXY_READ(proxy, cmd_read_idx);
-
-	/* ...submit any pending commands */
-	while (!XF_QUEUE_FULL(read_idx, write_idx)) {
-		struct xf_proxy_message *command;
-
-		/* ...check if we have a pending command */
-		m = xf_msg_dequeue(&proxy->command);
-		if (m  == NULL)
-			break;
-
-		/* ...always mark the interface status has changed */
-		status |= 0x3;
-
-		/* ...select the place for the command */
-		command = XF_PROXY_COMMAND(proxy, XF_QUEUE_IDX(write_idx));
-
-		/* ...put the response message fields */
-		command->session_id = m->id;
-		command->opcode = m->opcode;
-		command->length = m->length;
-		command->address = xf_proxy_b2a(proxy, m->buffer);
-		command->ret = m->ret;
-
-		/* ...return message back to the pool */
-		xf_msg_free(proxy, m);
-
-		/* ...advance local writing index copy */
-		write_idx = XF_QUEUE_ADVANCE_IDX(write_idx);
-
-		/* ...update shared copy of queue write pointer */
-		XF_PROXY_WRITE(proxy, cmd_write_idx, write_idx);
-	}
-
-	if (status)
-		icm_intr_send(proxy, 0);
-
-	return status;
-}
-
-/* ...shared memory interface maintenance routine */
-void xf_proxy_process(struct work_struct *w)
-{
-	struct xf_proxy *proxy = container_of(w, struct xf_proxy, work);
-	int status = 0;
-
-	/* ...get exclusive access to internal data */
-	xf_lock(&proxy->lock);
-
-	do {
-		/* ...process outgoing commands first */
-		status = xf_shmem_process_commands(proxy);
-
-		/* ...process all pending responses */
-		status |= xf_shmem_process_responses(proxy);
-
-	} while (status);
-
-	/* ...unlock internal proxy data */
-	xf_unlock(&proxy->lock);
-}
-
-/* ...initialize shared memory interface */
-int xf_proxy_init(struct xf_proxy *proxy)
-{
-	struct fsl_hifi4 *hifi4_priv = container_of(proxy,
-					struct fsl_hifi4, proxy);
-	struct xf_message *m;
-	int i;
-
-	/* ...create a list of all messages in a pool; set head pointer */
-	proxy->free = &proxy->pool[0];
-
-	/* ...put all messages into a single-linked list */
-	for (i = 0, m = proxy->free; i < XF_CFG_MESSAGE_POOL_SIZE - 1; i++, m++)
-		m->next = m + 1;
-
-	/* ...set list tail pointer */
-	m->next = NULL;
-
-	/* ...initialize proxy lock */
-	xf_lock_init(&proxy->lock);
-
-	/* ...initialize proxy thread message queues */
-	xf_msg_queue_init(&proxy->command);
-	xf_msg_queue_init(&proxy->response);
-
-	/* ...initialize global busy queue */
-	init_waitqueue_head(&proxy->busy);
-	init_waitqueue_head(&proxy->wait);
-
-	/* ...create work structure */
-	INIT_WORK(&proxy->work, xf_proxy_process);
-
-	/* ...set pointer to shared memory */
-	proxy->ipc.shmem = (struct xf_shmem_data *)hifi4_priv->msg_buf_virt;
-
-	/* ...initialize shared memory interface */
-	XF_PROXY_WRITE(proxy, cmd_read_idx, 0);
-	XF_PROXY_WRITE(proxy, cmd_write_idx, 0);
-	XF_PROXY_WRITE(proxy, cmd_invalid, 0);
-	XF_PROXY_WRITE(proxy, rsp_read_idx, 0);
-	XF_PROXY_WRITE(proxy, rsp_write_idx, 0);
-	XF_PROXY_WRITE(proxy, rsp_invalid, 0);
-
-	return 0;
-}
-
-/* ...trigger shared memory interface processing */
-void xf_proxy_notify(struct xf_proxy *proxy)
-{
-	schedule_work(&proxy->work);
-}
-
-/* ...submit a command to proxy pending queue (lock released upon return) */
-void xf_proxy_command(struct xf_proxy *proxy, struct xf_message *m)
-{
-	int first;
-
-	/* ...submit message to proxy thread */
-	first = xf_msg_enqueue(&proxy->command, m);
-
-	/* ...release the lock */
-	xf_unlock(&proxy->lock);
-
-	/* ...notify thread about command reception */
-	(first ? xf_proxy_notify(proxy), 1 : 0);
-}
-
-/*
- * Proxy cmd send and receive functions
- */
-int xf_cmd_send(struct xf_proxy *proxy,
-				u32 id,
-				u32 opcode,
-				void *buffer,
-				u32 length)
-{
-	struct xf_message *m;
-	int ret;
-
-	/* ...retrieve message handle (take the lock on success) */
-	ret = wait_event_interruptible(proxy->busy,
-					(m = xf_msg_available(proxy)) != NULL);
-	if (ret)
-		return -EINTR;
-
-	/* ...fill-in message parameters (lock is taken) */
-	m->id = id;
-	m->opcode = opcode;
-	m->length = length;
-	m->buffer = buffer;
-	m->ret = 0;
-
-	/* ...submit command to the proxy */
-	xf_proxy_command(proxy, m);
-
-	return 0;
-}
-
-struct xf_message *xf_cmd_recv(struct xf_proxy *proxy,
-						  wait_queue_head_t *wq,
-						  struct xf_msg_queue *queue,
-						  int wait)
-{
-	struct xf_message *m;
-	int ret;
-
-	/* ...wait for message reception (take lock on success) */
-	ret = wait_event_interruptible(*wq,
-			(m = xf_msg_received(proxy, queue)) != NULL || !wait);
-	if (ret)
-		return ERR_PTR(-EINTR);
-
-	/* ...return message with a lock taken */
-	return m;
-}
-
-/* ...helper function for synchronous command execution */
-struct xf_message *xf_cmd_send_recv(struct xf_proxy *proxy,
-							   u32 id, u32 opcode,
-							   void *buffer,
-							   u32 length)
-{
-	int ret;
-
-	/* ...send command to remote proxy */
-	ret = xf_cmd_send(proxy, id, opcode, buffer, length);
-	if (ret)
-		return ERR_PTR(ret);
-
-	/* ...wait for message delivery */
-	return xf_cmd_recv(proxy, &proxy->wait, &proxy->response, 1);
-}
-
-/*
- * Proxy allocate and free memory functions
- */
-/* ...allocate memory buffer for kernel use */
-int xf_cmd_alloc(struct xf_proxy *proxy, void **buffer, u32 length)
-{
-	struct xf_message *m;
-	u32 id = 0;
-	int ret;
-
-	/* ...send command to remote proxy */
-	m = xf_cmd_send_recv(proxy, id, XF_ALLOC, NULL, length);
-	if (IS_ERR(m)) {
-		ret = PTR_ERR(m);
-		return ret;
-	}
-
-	/* ...check if response is expected */
-	if (m->opcode == XF_ALLOC && m->buffer != NULL) {
-		*buffer = m->buffer;
-		ret = 0;
-	} else {
-		ret = -ENOMEM;
-	}
-
-	/* ...free message and release proxy lock */
-	xf_msg_free(proxy, m);
-
-	return ret;
-}
-
-/* ...free memory buffer */
-int xf_cmd_free(struct xf_proxy *proxy, void *buffer, u32 length)
-{
-	struct xf_message *m;
-	u32 id = 0;
-	int ret;
-
-	/* ...synchronously execute freeing command */
-	m = xf_cmd_send_recv(proxy, id, XF_FREE, buffer, length);
-	if (IS_ERR(m)) {
-		ret = PTR_ERR(m);
-		return ret;
-	}
-
-	/* ...check if response is expected */
-	if (m->opcode == XF_FREE)
-		ret = 0;
-	else
-		ret = -EINVAL;
-
-	/* ...free message and release proxy lock */
-	xf_msg_free(proxy, m);
-
-	return ret;
-}
-
-/*
- * suspend & resume functions
- */
-int xf_cmd_send_suspend(struct xf_proxy *proxy)
-{
-	union icm_header_t msghdr;
-	int ret = 0;
-
-	init_completion(&proxy->cmd_complete);
-
-	msghdr.allbits = 0;	/* clear all bits; */
-	msghdr.ack  = 0;
-	msghdr.intr = 1;
-	msghdr.msg  = XF_SUSPEND;
-	msghdr.size = 0;
-	icm_intr_send(proxy, msghdr.allbits);
-
-	/* wait for response here */
-	ret = icm_ack_wait(proxy, msghdr.allbits);
-
-	return ret;
-}
-
-int xf_cmd_send_resume(struct xf_proxy *proxy)
-{
-	union icm_header_t msghdr;
-	int ret = 0;
-
-	init_completion(&proxy->cmd_complete);
-
-	msghdr.allbits = 0;	/* clear all bits; */
-	msghdr.ack  = 0;
-	msghdr.intr = 1;
-	msghdr.msg  = XF_RESUME;
-	msghdr.size = 0;
-	icm_intr_send(proxy, msghdr.allbits);
-
-	/* wait for response here */
-	ret = icm_ack_wait(proxy, msghdr.allbits);
-
-	return ret;
-}
diff --git a/sound/soc/fsl/fsl_hifi4_proxy.h b/sound/soc/fsl/fsl_hifi4_proxy.h
deleted file mode 100644
index 03d2b55..0000000
--- a/sound/soc/fsl/fsl_hifi4_proxy.h
+++ /dev/null
@@ -1,404 +0,0 @@
-/*******************************************************************************
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- *
- * Copyright (c) 2017 Cadence Design Systems, Inc.
- * Copyright 2018 NXP
- *
- ************************************************************/
-/************************************************************
- * fsl_hifi4_proxy.h
- *
- * Proxy commmand/response messages
- ************************************************************/
-
-#ifndef __FSL_HIFI4_PROXY_H
-#define __FSL_HIFI4_PROXY_H
-
-#include <linux/wait.h>
-#include <linux/device.h>
-#include <linux/workqueue.h>
-#include <linux/spinlock.h>
-#include <linux/compiler.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_data/dma-imx.h>
-#include <linux/mx8_mu.h>
-#include <linux/interrupt.h>
-
-#define XF_CFG_MESSAGE_POOL_SIZE        256
-
-/*******************************************************************************
- * Local proxy data
- ******************************************************************************/
-
-/* ...execution message */
-struct xf_message {
-	/* ...pointer to next message in a list */
-	struct xf_message   *next;
-
-	/* ...session-id */
-	u32                 id;
-
-	/* ...operation code */
-	u32                 opcode;
-
-	/* ...length of data buffer */
-	u32                 length;
-
-	/* ...translated data pointer */
-	void               *buffer;
-
-	/* ...return message status */
-	u32                ret;
-};
-
-/* ...message queue */
-struct xf_msg_queue {
-	/* ...pointer to list head */
-	struct xf_message   *head;
-
-	/* ...pointer to list tail */
-	struct xf_message   *tail;
-};
-
-struct xf_proxy_message {
-	/* ...session ID */
-	u32 session_id;
-
-	/* ...proxy API command/response code */
-	u32 opcode;
-
-	/* ...length of attached buffer */
-	u32 length;
-
-	/* ...physical address of message buffer */
-	u32 address;
-
-	/* ...return message status */
-	u32 ret;
-};
-/**********************************************************************/
-
-enum icm_action_t {
-	ICM_CORE_READY = 1,
-	ICM_CORE_INIT,
-	ICM_CORE_EXIT,
-};
-
-/* ...adjust IPC client of message going from user-space */
-#define XF_MSG_AP_FROM_USER(id, client) (((id) & ~(0xF << 2)) | (client << 2))
-
-/* ...message id contains source and destination ports specification */
-#define __XF_MSG_ID(src, dst)   (((src) & 0xFFFF) | (((dst) & 0xFFFF) << 16))
-
-/* ...wipe out IPC client from message going to user-space */
-#define XF_MSG_AP_TO_USER(id)   ((id) & ~(0xF << 18))
-#define __XF_AP_PROXY(core)     ((core) | 0x8000)
-#define __XF_DSP_PROXY(core)    ((core) | 0x8000)
-
-/* ...message id contains source and destination ports specification */
-#define __XF_MSG_ID(src, dst)   (((src) & 0xFFFF) | (((dst) & 0xFFFF) << 16))
-#define XF_MSG_SRC_CLIENT(id)   (((id) >> 2) & 0x3F)
-#define XF_MSG_DST_CLIENT(id)   (((id) >> 18) & 0x3F)
-
-/* ...special treatment of AP-proxy destination field */
-#define XF_AP_IPC_CLIENT(id)    (((id) >> 18) & 0xF)
-#define __XF_AP_PROXY(core)     ((core) | 0x8000)
-#define __XF_DSP_PROXY(core)    ((core) | 0x8000)
-
-/* ...opcode composition with command/response data tags */
-#define __XF_OPCODE(c, r, op)   (((c) << 31) | ((r) << 30) | ((op) & 0x3F))
-
-/* ...shared buffer allocation */
-#define XF_ALLOC                        __XF_OPCODE(0, 0, 4)
-
-/* ...shared buffer freeing */
-#define XF_FREE                         __XF_OPCODE(0, 0, 5)
-
-/* ...resume component operation */
-#define XF_RESUME                       __XF_OPCODE(0, 0, 14)
-
-/* ...resume component operation */
-#define XF_SUSPEND                      __XF_OPCODE(0, 0, 15)
-
-
-/*******************************************************************************
- * Ring buffer support
- ******************************************************************************/
-/* ...cache-line size on DSP */
-#define XF_PROXY_ALIGNMENT              64
-
-/* ...total length of shared memory queue (for commands and responses) */
-#define XF_PROXY_MESSAGE_QUEUE_LENGTH   (1 << 6)
-
-/* ...index mask */
-#define XF_PROXY_MESSAGE_QUEUE_MASK     0x3F
-
-/* ...ring-buffer index */
-#define __XF_QUEUE_IDX(idx, counter)    \
-		(((idx) & XF_PROXY_MESSAGE_QUEUE_MASK) | ((counter) << 16))
-
-/* ...retrieve ring-buffer index */
-#define XF_QUEUE_IDX(idx)               \
-		((idx) & XF_PROXY_MESSAGE_QUEUE_MASK)
-
-/* ...increment ring-buffer index */
-#define XF_QUEUE_ADVANCE_IDX(idx)       \
-		(((idx) + 0x10001) & (0xFFFF0000 | XF_PROXY_MESSAGE_QUEUE_MASK))
-
-/* ...test if ring buffer is empty */
-#define XF_QUEUE_EMPTY(read, write)     \
-		((read) == (write))
-
-/* ...test if ring buffer is full */
-#define XF_QUEUE_FULL(read, write)      \
-		((write) == (read) + (XF_PROXY_MESSAGE_QUEUE_LENGTH << 16))
-
-/* ...basic cache operations */
-#define XF_PROXY_INVALIDATE(addr, len)  { }
-
-#define XF_PROXY_FLUSH(addr, len)       { }
-
-/* ...data managed by host CPU (remote) - in case of shunt it is a IPC layer */
-struct xf_proxy_host_data {
-	/* ...command queue */
-	struct xf_proxy_message command[XF_PROXY_MESSAGE_QUEUE_LENGTH];
-
-	/* ...writing index into command queue */
-	u32                 cmd_write_idx;
-
-	/* ...reading index for response queue */
-	u32                 rsp_read_idx;
-
-	/* ...indicate command queue is valid or not */
-	u32                 cmd_invalid;
-};
-
-/* ...data managed by DSP (local) */
-struct xf_proxy_dsp_data {
-	/* ...response queue */
-	struct xf_proxy_message response[XF_PROXY_MESSAGE_QUEUE_LENGTH];
-
-	/* ...writing index into response queue */
-	u32                 rsp_write_idx;
-
-	/* ...reading index for command queue */
-	u32                 cmd_read_idx;
-
-	/* ...indicate response queue is valid or not */
-	u32                 rsp_invalid;
-};
-
-/* ...shared memory data */
-struct xf_shmem_data {
-	/* ...ingoing data (maintained by DSP (local side)) */
-	struct xf_proxy_host_data    local;
-
-	/* ...outgoing data (maintained by host CPU (remote side)) */
-	struct xf_proxy_dsp_data   remote;
-
-};
-
-/* ...shared memory data accessor */
-#define XF_SHMEM_DATA(proxy)                \
-		((proxy)->ipc.shmem)
-
-/* ...atomic reading */
-#define __XF_PROXY_READ_ATOMIC(var)         \
-	({ XF_PROXY_INVALIDATE(&(var), sizeof(var));  \
-	 *(u32 *)&(var); })
-
-/* ...atomic writing */
-#define __XF_PROXY_WRITE_ATOMIC(var, value) \
-	({*(u32 *)&(var) = (value);    \
-	 XF_PROXY_FLUSH(&(var), sizeof(var));   \
-	 (value); })
-
-/* ...accessors */
-#define XF_PROXY_READ(proxy, field)          \
-		__XF_PROXY_READ_##field(XF_SHMEM_DATA(proxy))
-
-#define XF_PROXY_WRITE(proxy, field, v)      \
-		__XF_PROXY_WRITE_##field(XF_SHMEM_DATA(proxy), (v))
-
-/* ...individual fields reading */
-#define __XF_PROXY_READ_cmd_write_idx(shmem)        \
-		__XF_PROXY_READ_ATOMIC(shmem->local.cmd_write_idx)
-
-#define __XF_PROXY_READ_cmd_read_idx(shmem)         \
-		shmem->remote.cmd_read_idx
-
-#define __XF_PROXY_READ_cmd_invalid(shmem)            \
-		__XF_PROXY_READ_ATOMIC(shmem->local.cmd_invalid)
-
-#define __XF_PROXY_READ_rsp_write_idx(shmem)        \
-		__XF_PROXY_READ_ATOMIC(shmem->remote.rsp_write_idx)
-
-#define __XF_PROXY_READ_rsp_read_idx(shmem)         \
-		shmem->local.rsp_read_idx
-
-#define __XF_PROXY_READ_rsp_invalid(shmem)            \
-		__XF_PROXY_READ_ATOMIC(shmem->remote.rsp_invalid)
-
-/* ...individual fields writings */
-#define __XF_PROXY_WRITE_cmd_write_idx(shmem, v)    \
-		__XF_PROXY_WRITE_ATOMIC(shmem->local.cmd_write_idx, v)
-
-#define __XF_PROXY_WRITE_cmd_read_idx(shmem, v)     \
-		__XF_PROXY_WRITE_ATOMIC(shmem->remote.cmd_read_idx, v)
-
-#define __XF_PROXY_WRITE_cmd_invalid(shmem, v)     \
-		__XF_PROXY_WRITE_ATOMIC(shmem->local.cmd_invalid, v)
-
-#define __XF_PROXY_WRITE_rsp_read_idx(shmem, v)     \
-		__XF_PROXY_WRITE_ATOMIC(shmem->local.rsp_read_idx, v)
-
-#define __XF_PROXY_WRITE_rsp_write_idx(shmem, v)    \
-		__XF_PROXY_WRITE_ATOMIC(shmem->remote.rsp_write_idx, v)
-
-#define __XF_PROXY_WRITE_rsp_invalid(shmem, v)     \
-		__XF_PROXY_WRITE_ATOMIC(shmem->remote.rsp_invalid, v)
-
-/* ...command buffer accessor */
-#define XF_PROXY_COMMAND(proxy, idx)                \
-		(&XF_SHMEM_DATA(proxy)->local.command[(idx)])
-
-/* ...response buffer accessor */
-#define XF_PROXY_RESPONSE(proxy, idx)               \
-		(&XF_SHMEM_DATA(proxy)->remote.response[(idx)])
-
-/*******************************************************************************
- * Local proxy data
- ******************************************************************************/
-
-struct xf_proxy_ipc_data {
-	/* ...shared memory data pointer */
-	struct xf_shmem_data __iomem     *shmem;
-
-	/* ...core identifier */
-	u32                     core;
-
-	/* ...IPC registers memory */
-	void __iomem           *regs;
-};
-
-/* ...proxy data */
-struct xf_proxy {
-	/* ...IPC layer data */
-	struct xf_proxy_ipc_data ipc;
-
-	/* ...shared memory status change processing item */
-	struct work_struct      work;
-
-	struct completion		cmd_complete;
-	int						is_ready;
-
-	/* ...internal lock */
-	spinlock_t              lock;
-
-	/* ...busy queue (for clients waiting ON NOTIFIcation) */
-	wait_queue_head_t       busy;
-
-	/* ...waiting queue for synchronous proxy operations */
-	wait_queue_head_t       wait;
-
-	/* ...submitted commands queue */
-	struct xf_msg_queue     command;
-
-	/* ...pending responses queue */
-	struct xf_msg_queue     response;
-
-	/* ...global message pool */
-	struct xf_message       pool[XF_CFG_MESSAGE_POOL_SIZE];
-
-	/* ...pointer to first free message in the pool */
-	struct xf_message       *free;
-};
-
-union icm_header_t {
-	struct {
-		u32 msg:6;
-		u32 sub_msg:6;      // sub_msg will have ICM_MSG
-		u32 rsvd:3;     /* reserved */
-		u32 intr:1;     /* intr = 1 when sending msg. */
-		u32 size:15;    /* =size in bytes (excluding header) */
-		u32 ack:1;      /* response message when ack=1 */
-	};
-	u32 allbits;
-};
-
-struct hifi4_ext_msg {
-	u32	phys;
-	u32	size;
-};
-
-struct hifi4_mem_msg {
-	u32 ext_msg_phys;
-	u32 ext_msg_size;
-	u32 scratch_phys;
-	u32 scratch_size;
-	u32 hifi_config_phys;
-	u32 hifi_config_size;
-};
-
-static inline void xf_lock_init(spinlock_t *lock)
-{
-	spin_lock_init(lock);
-}
-
-static inline void xf_lock(spinlock_t *lock)
-{
-	spin_lock(lock);
-}
-
-static inline void xf_unlock(spinlock_t *lock)
-{
-	spin_unlock(lock);
-}
-
-/* ...init proxy */
-int xf_proxy_init(struct xf_proxy *proxy);
-
-/* ...send message to proxy */
-int xf_cmd_send(struct xf_proxy *proxy,
-				u32 id,
-				u32 opcode,
-				void *buffer,
-				u32 length);
-
-/* ...get message from proxy */
-struct xf_message *xf_cmd_recv(struct xf_proxy *proxy,
-					wait_queue_head_t *wq,
-					struct xf_msg_queue *queue,
-					int wait);
-
-/* ...mu interrupt handle */
-irqreturn_t fsl_hifi4_mu_isr(int irq, void *dev_id);
-
-/* ...initialize client pending message queue */
-void xf_msg_queue_init(struct xf_msg_queue *queue);
-
-/* ...return current queue state */
-struct xf_message *xf_msg_queue_head(struct xf_msg_queue *queue);
-
-/* ...return the message back to a pool */
-void xf_msg_free(struct xf_proxy *proxy, struct xf_message *m);
-
-/* ...release all pending messages */
-void xf_msg_free_all(struct xf_proxy *proxy, struct xf_msg_queue *queue);
-
-/* ...wait mu interrupt */
-long icm_ack_wait(struct xf_proxy *proxy, u32 msg);
-
-/* ...shared memory translation - kernel virtual address to shared address */
-u32 xf_proxy_b2a(struct xf_proxy *proxy, void *b);
-
-/* ...shared memory translation - shared address to kernel virtual address */
-void *xf_proxy_a2b(struct xf_proxy *proxy, u32 address);
-
-int xf_cmd_send_suspend(struct xf_proxy *proxy);
-int xf_cmd_send_resume(struct xf_proxy *proxy);
-
-#endif
-- 
1.7.9.5


From fb758a2d2f65f4bff79145c64ab0b625dc6447a4 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Thu, 5 May 2016 18:21:10 +0800
Subject: [PATCH 1043/5242] MLK-12761 ARM: imx: add mu as wakeup source for
 i.mx7d

commit  eda3c35abd6c47796c6a6beb3ba1407aee535401 from
https://source.codeaurora.org/external/imx/linux-imx.git

When A7 platform is in low power mode while M4 is NOT,
M4 should be able to send message to wake up A7, so
MU must be always as wake up source.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/common.h |    2 ++
 arch/arm/mach-imx/gpcv2.c  |   17 +++++++++++++++++
 arch/arm/mach-imx/mu.c     |    3 +++
 3 files changed, 22 insertions(+)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index c4d074e..77b76dc 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -123,9 +123,11 @@ static inline void imx_smp_prepare(void) {}
 #ifdef CONFIG_HAVE_IMX_GPCV2
 int imx_gpcv2_mf_power_on(unsigned int irq, unsigned int on);
 void imx_gpcv2_set_core1_pdn_pup_by_software(bool pdn);
+void imx_gpcv2_add_m4_wake_up_irq(u32 hwirq, bool enable);
 #else
 static inline int imx_gpcv2_mf_power_on(unsigned int irq, unsigned int on) { return 0; }
 static inline void imx_gpcv2_set_core1_pdn_pup_by_software(bool pdn) {}
+static void imx_gpcv2_add_m4_wake_up_irq(u32 hwirq, bool enable) {}
 #endif
 void __init imx_gpcv2_check_dt(void);
 void imx_gpcv2_set_lpm_mode(enum mxc_cpu_pwr_mode mode);
diff --git a/arch/arm/mach-imx/gpcv2.c b/arch/arm/mach-imx/gpcv2.c
index a3dc47c..1fcce44 100644
--- a/arch/arm/mach-imx/gpcv2.c
+++ b/arch/arm/mach-imx/gpcv2.c
@@ -113,6 +113,23 @@ enum imx_gpc_slot {
 static DEFINE_SPINLOCK(gpcv2_lock);
 static struct notifier_block nb_mipi, nb_pcie;
 
+void imx_gpcv2_add_m4_wake_up_irq(u32 hwirq, bool enable)
+{
+	unsigned int idx = hwirq / 32;
+	unsigned long flags;
+	u32 mask;
+
+	/* Sanity check for SPI irq */
+	if (hwirq < 32)
+		return;
+
+	mask = 1 << hwirq % 32;
+	spin_lock_irqsave(&gpcv2_lock, flags);
+	gpcv2_wake_irqs[idx] = enable ? gpcv2_wake_irqs[idx] | mask :
+		gpcv2_wake_irqs[idx] & ~mask;
+	spin_unlock_irqrestore(&gpcv2_lock, flags);
+}
+
 static int imx_gpcv2_irq_set_wake(struct irq_data *d, unsigned int on)
 {
 	unsigned int idx = d->hwirq / 32;
diff --git a/arch/arm/mach-imx/mu.c b/arch/arm/mach-imx/mu.c
index 2a482be..c992e58 100644
--- a/arch/arm/mach-imx/mu.c
+++ b/arch/arm/mach-imx/mu.c
@@ -388,6 +388,9 @@ static int imx_mu_probe(struct platform_device *pdev)
 		/* enable the bit26(RIE1) of MU_ACR */
 		writel_relaxed(readl_relaxed(mu_base + MU_ACR) |
 			BIT(26) | BIT(27), mu_base + MU_ACR);
+		/* MU always as a wakeup source for low power mode */
+		imx_gpcv2_add_m4_wake_up_irq(irq_to_desc(irq)->irq_data.hwirq,
+			true);
 	} else {
 		INIT_DELAYED_WORK(&mu_work, mu_work_handler);
 
-- 
1.7.9.5


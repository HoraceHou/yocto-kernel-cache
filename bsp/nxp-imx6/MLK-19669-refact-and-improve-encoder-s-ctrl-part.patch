From f8f96d082051b450893eb19ec4679d390160d6ba Mon Sep 17 00:00:00 2001
From: ming_qian <ming.qian@nxp.com>
Date: Fri, 21 Sep 2018 15:52:03 +0800
Subject: [PATCH 4727/5242] MLK-19669: refact and improve encoder's ctrl part

commit  a95254700f509551d19f1cbdd73c5803c593703b from
https://source.codeaurora.org/external/imx/linux-imx.git

1.separate it into a single part
2.add ctrl: V4L2_CID_MPEG_VIDEO_H264_I_PERIOD
3.add ctrl: V4L2_CID_MPEG_VIDEO_BITRATE_PEAK

Signed-off-by: ming_qian <ming.qian@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-encoder-b0/Makefile           |    1 +
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c   |  236 +++----------
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h   |   17 +-
 drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.c |  443 +++++++++++++++++++++++++
 drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.h |   19 ++
 5 files changed, 521 insertions(+), 195 deletions(-)
 create mode 100644 drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.c
 create mode 100644 drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.h

diff --git a/drivers/mxc/vpu-encoder-b0/Makefile b/drivers/mxc/vpu-encoder-b0/Makefile
index b8a8fc1..ccce55a 100644
--- a/drivers/mxc/vpu-encoder-b0/Makefile
+++ b/drivers/mxc/vpu-encoder-b0/Makefile
@@ -6,6 +6,7 @@ EXTRA_CFLAGS += $(DEFINES)
 
 obj-y = vpu-encoder.o
 vpu-encoder-objs = vpu_encoder_b0.o \
+	vpu_encoder_ctrl.o \
 	vpu_encoder_rpc.o
 
 clean:
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index 8a40b96..2aa9fc4d 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -47,6 +47,7 @@
 #include <media/videobuf2-vmalloc.h>
 
 #include "vpu_encoder_b0.h"
+#include "vpu_encoder_ctrl.h"
 
 unsigned int vpu_dbg_level_encoder = 1;
 #ifdef DUMP_DATA
@@ -58,26 +59,6 @@
 	"fsl,imx8-mu2-vpu-m0"
 };
 
-// H264 level is maped like level 5.1 to uLevel 51, except level 1b to uLevel 14
-const u_int32 h264_level[] = {
-	[V4L2_MPEG_VIDEO_H264_LEVEL_1_0] = 10,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_1B]  = 14,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_1_1] = 11,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_1_2] = 12,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_1_3] = 13,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_2_0] = 20,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_2_1] = 21,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_2_2] = 22,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_3_0] = 30,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_3_1] = 31,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_3_2] = 32,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_4_0] = 40,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_4_1] = 41,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_4_2] = 42,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_5_0] = 50,
-	[V4L2_MPEG_VIDEO_H264_LEVEL_5_1] = 51
-};
-
 #define ITEM_NAME(name)		\
 				[name] = #name
 
@@ -256,13 +237,6 @@ static void get_param_from_v4l2(pMEDIAIP_ENC_PARAM pEncParam,
 		)
 {
 	//get the param and update gpParameters
-	pEncParam->eCodecMode           = MEDIAIP_ENC_FMT_H264;
-
-	pEncParam->tEncMemDesc.uMemPhysAddr = ctx->encoder_mem.phy_addr;
-	pEncParam->tEncMemDesc.uMemVirtAddr = ctx->encoder_mem.phy_addr;
-	pEncParam->tEncMemDesc.uMemSize     = ctx->encoder_mem.size;
-
-	pEncParam->uFrameRate           = 30;
 	pEncParam->uSrcStride           = pix_mp->width;
 	pEncParam->uSrcWidth            = pix_mp->width;
 	pEncParam->uSrcHeight           = pix_mp->height;
@@ -272,12 +246,6 @@ static void get_param_from_v4l2(pMEDIAIP_ENC_PARAM pEncParam,
 	pEncParam->uSrcCropHeight       = pix_mp->height;
 	pEncParam->uOutWidth            = pix_mp->width;
 	pEncParam->uOutHeight           = pix_mp->height;
-	pEncParam->uLowLatencyMode      = 0;
-
-	if (!pEncParam->uIFrameInterval)
-		pEncParam->uIFrameInterval = 30;
-	if (!pEncParam->uGopBLength)
-		pEncParam->uGopBLength = 30;
 
 	vpu_dbg(LVL_INFO, "eCodecMode(%d) eProfile(%d) uSrcStride(%d) uSrcWidth(%d) uSrcHeight(%d) uSrcOffset_x(%d) uSrcOffset_y(%d) uSrcCropWidth(%d) uSrcCropHeight(%d) uOutWidth(%d) uOutHeight(%d) uGopBLength(%d) uLowLatencyMode(%d) uInitSliceQP(%d) uIFrameInterval(%d) eBitRateMode(%d) uTargetBitrate(%d) uMaxBitRate(%d) uMinBitRate(%d) uFrameRate(%d)\n",
 			pEncParam->eCodecMode, pEncParam->eProfile, pEncParam->uSrcStride, pEncParam->uSrcWidth,
@@ -293,6 +261,36 @@ static void *phy_to_virt(u_int32 src, unsigned long long offset)
 	return result;
 }
 
+pMEDIAIP_ENC_PARAM get_enc_param(struct vpu_ctx *ctx)
+{
+	struct core_device  *dev = &ctx->dev->core_dev[ctx->core_id];
+	pENC_RPC_HOST_IFACE iface = dev->shared_mem.pSharedInterface;
+	pMEDIA_ENC_API_CONTROL_INTERFACE ctrl_interface;
+	pMEDIAIP_ENC_PARAM  pEncParam;
+
+	ctrl_interface = phy_to_virt(iface->pEncCtrlInterface[ctx->str_index],
+					dev->shared_mem.base_offset);
+	pEncParam = phy_to_virt(ctrl_interface->pEncParam,
+				dev->shared_mem.base_offset);
+
+	return pEncParam;
+}
+
+static int initialize_enc_param(struct vpu_ctx *ctx)
+{
+	pMEDIAIP_ENC_PARAM param = get_enc_param(ctx);
+
+	param->eCodecMode = MEDIAIP_ENC_FMT_H264;
+	param->tEncMemDesc.uMemPhysAddr = ctx->encoder_mem.phy_addr;
+	param->tEncMemDesc.uMemVirtAddr = ctx->encoder_mem.phy_addr;
+	param->tEncMemDesc.uMemSize     = ctx->encoder_mem.size;
+	param->uFrameRate = 30;
+	param->uMinBitRate = BITRATE_LOW_THRESHOLD;
+	param->uLowLatencyMode = 0;
+
+	return 0;
+}
+
 static struct vpu_v4l2_fmt *find_fmt_by_fourcc(struct vpu_v4l2_fmt *fmts,
 						unsigned int size,
 						u32 fourcc)
@@ -837,161 +835,6 @@ static int v4l2_ioctl_streamoff(struct file *file,
 	.vidioc_streamoff               = v4l2_ioctl_streamoff,
 };
 
-static int v4l2_enc_s_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
-	struct core_device  *dev = &ctx->dev->core_dev[ctx->core_id];
-	pENC_RPC_HOST_IFACE pSharedInterface = dev->shared_mem.pSharedInterface;
-	pMEDIA_ENC_API_CONTROL_INTERFACE pEncCtrlInterface;
-	pMEDIAIP_ENC_PARAM  pEncParam;
-	pMEDIAIP_ENC_EXPERT_MODE_PARAM pEncExpertModeParam;
-
-	pEncCtrlInterface = (pMEDIA_ENC_API_CONTROL_INTERFACE)phy_to_virt(pSharedInterface->pEncCtrlInterface[ctx->str_index],
-			dev->shared_mem.base_offset);
-	pEncParam = (pMEDIAIP_ENC_PARAM)phy_to_virt(pEncCtrlInterface->pEncParam,
-			dev->shared_mem.base_offset);
-	pEncExpertModeParam = (pMEDIAIP_ENC_EXPERT_MODE_PARAM)phy_to_virt(pEncCtrlInterface->pEncExpertModeParam,
-			dev->shared_mem.base_offset);
-
-	vpu_dbg(LVL_INFO, "s_ctrl: id = %d, val = %d\n", ctrl->id, ctrl->val);
-
-	switch (ctrl->id) {
-	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE: {
-		if (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) {
-			pEncParam->eBitRateMode = MEDIAIP_ENC_BITRATECONTROLMODE_CONSTANT_QP;
-
-			// Not used for CQ mode - set zero
-			pEncParam->uTargetBitrate       = 0;
-			pEncParam->uMaxBitRate          = 0;
-			pEncParam->uMinBitRate          = 0;
-		} else if (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) {
-			pEncParam->eBitRateMode = MEDIAIP_ENC_BITRATECONTROLMODE_CBR;
-			if (!pEncParam->uTargetBitrate) {
-				// Setup some default values if not set, these should really be
-				// resolution specific
-				pEncParam->uTargetBitrate = ctx->q_data[V4L2_SRC].height * ctx->q_data[V4L2_SRC].width * 12 * 30 / 100000;
-				pEncParam->uMaxBitRate    = ctx->q_data[V4L2_SRC].height * ctx->q_data[V4L2_SRC].width * 12 * 30 / 10000;
-				pEncParam->uMinBitRate    = ctx->q_data[V4L2_SRC].height * ctx->q_data[V4L2_SRC].width * 12 * 30 / 1000000;
-			}
-		} else
-			// Only CQ and CBR supported at present, force CQ mode
-			pEncParam->eBitRateMode = MEDIAIP_ENC_BITRATECONTROLMODE_CONSTANT_QP;
-	}
-		break;
-	case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
-		if ((V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE == ctrl->val) || (V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE == ctrl->val))
-			pEncParam->eProfile = MEDIAIP_ENC_PROF_H264_BP;
-		else if (V4L2_MPEG_VIDEO_H264_PROFILE_MAIN == ctrl->val)
-			pEncParam->eProfile = MEDIAIP_ENC_PROF_H264_MP;
-		else if (V4L2_MPEG_VIDEO_H264_PROFILE_HIGH == ctrl->val)
-			pEncParam->eProfile = MEDIAIP_ENC_PROF_H264_HP;
-		else {
-			vpu_dbg(LVL_INFO, "not support h264 profile %d, set default: BP\n", ctrl->val);
-			pEncParam->eProfile = MEDIAIP_ENC_PROF_H264_BP;
-		}
-		break;
-	case V4L2_CID_MPEG_VIDEO_H264_LEVEL:
-		pEncParam->uLevel = h264_level[ctrl->val];
-		vpu_dbg(LVL_INFO, "V4L2_CID_MPEG_VIDEO_H264_LEVEL set val = %d\n", ctrl->val);
-		break;
-	case V4L2_CID_MPEG_VIDEO_BITRATE:
-		pEncParam->uTargetBitrate = ctrl->val;
-		break;
-	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
-		pEncParam->uIFrameInterval = ctrl->val;
-		pEncParam->uGopBLength = ctrl->val;
-		break;
-	case V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:
-		pEncParam->uInitSliceQP = ctrl->val;
-		break;
-	case V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:
-		pEncParam->uInitSliceQP = ctrl->val;
-		break;
-	case V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP:
-		pEncParam->uInitSliceQP = ctrl->val;
-		break;
-	}
-	return 0;
-}
-
-static int v4l2_enc_g_ctrl(struct v4l2_ctrl *ctrl)
-{
-	vpu_dbg(LVL_INFO, "g_ctrl: id = %d\n", ctrl->id);
-
-	switch (ctrl->id) {
-	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:
-		ctrl->val = MIN_BUFFER_COUNT;
-		break;
-	default:
-		vpu_dbg(LVL_INFO, "%s() Invalid control(%d)\n",
-				__func__, ctrl->id);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static const struct v4l2_ctrl_ops   vpu_enc_ctrl_ops = {
-	.s_ctrl             = v4l2_enc_s_ctrl,
-	.g_volatile_ctrl    = v4l2_enc_g_ctrl,
-};
-
-static void vpu_encoder_ctrls(struct vpu_ctx *ctx)
-{
-	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-			V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
-			V4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0x0,
-			V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);
-	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-			V4L2_CID_MPEG_VIDEO_H264_PROFILE,
-			V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH, 0x0,
-			V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE
-			);
-	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-			V4L2_CID_MPEG_VIDEO_H264_LEVEL,
-			V4L2_MPEG_VIDEO_H264_LEVEL_5_1, 0x0,
-			V4L2_MPEG_VIDEO_H264_LEVEL_4_0
-			);
-	v4l2_ctrl_new_std(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-		V4L2_CID_MPEG_VIDEO_BITRATE, 0, 32767000, 1, 0);
-	v4l2_ctrl_new_std(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-		V4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 60, 1, 16);
-	v4l2_ctrl_new_std(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-		V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP, 0, 51, 1, 25);
-	v4l2_ctrl_new_std(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-		V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP, 0, 51, 1, 25);
-	v4l2_ctrl_new_std(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-		V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP, 0, 51, 1, 25);
-	v4l2_ctrl_new_std(&ctx->ctrl_handler, &vpu_enc_ctrl_ops,
-		V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 0, 32, 1, MIN_BUFFER_COUNT);
-}
-
-static int ctrls_setup_encoder(struct vpu_ctx *ctx)
-{
-	v4l2_ctrl_handler_init(&ctx->ctrl_handler, 2);
-	vpu_encoder_ctrls(ctx);
-	if (ctx->ctrl_handler.error) {
-		vpu_dbg(LVL_ERR,
-			"control initialization error (%d)",
-			ctx->ctrl_handler.error);
-		return -EINVAL;
-	} else
-		ctx->ctrl_inited = true;
-
-	return v4l2_ctrl_handler_setup(&ctx->ctrl_handler);
-}
-
-static void ctrls_delete_encoder(struct vpu_ctx *This)
-{
-	int i;
-
-	if (This->ctrl_inited) {
-		v4l2_ctrl_handler_free(&This->ctrl_handler);
-		This->ctrl_inited = false;
-	}
-	for (i = 0; i < 2; i++)
-		This->ctrls[i] = NULL;
-}
-
 static void v4l2_vpu_send_cmd(struct vpu_ctx *ctx, uint32_t idx, uint32_t cmdid, uint32_t cmdnum, uint32_t *local_cmddata)
 {
 
@@ -1905,7 +1748,8 @@ static int v4l2_open(struct file *filp)
 	ctx->str_index = idx;
 	ctx->dev = dev;
 	ctx->ctrl_inited = false;
-	ctrls_setup_encoder(ctx);
+	vpu_enc_setup_ctrls(ctx);
+
 	ctx->fh.ctrl_handler = &ctx->ctrl_handler;
 
 	ctx->instance_wq = alloc_workqueue("vpu_instance", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
@@ -1983,11 +1827,13 @@ static int v4l2_open(struct file *filp)
 	ctx->q_data[V4L2_DST].supported_fmts = formats_compressed_enc;
 	ctx->q_data[V4L2_DST].fmt_count = ARRAY_SIZE(formats_compressed_enc);
 
+	initialize_enc_param(ctx);
+
 	return 0;
 
 err_firmware_load:
 	release_queue_data(ctx);
-	ctrls_delete_encoder(ctx);
+	vpu_enc_free_ctrls(ctx);
 	v4l2_fh_del(&ctx->fh);
 	v4l2_fh_exit(&ctx->fh);
 	clear_bit(ctx->str_index, &dev->core_dev[ctx->core_id].instance_mask);
@@ -2024,7 +1870,7 @@ static int v4l2_release(struct file *filp)
 		wait_for_completion(&ctx->stop_cmp);
 
 	release_queue_data(ctx);
-	ctrls_delete_encoder(ctx);
+	vpu_enc_free_ctrls(ctx);
 	v4l2_fh_del(&ctx->fh);
 	v4l2_fh_exit(&ctx->fh);
 
@@ -2419,7 +2265,7 @@ static int init_vpu_core_dev(struct vpu_dev *dev, u32 id)
 	ret = vpu_mu_init(dev, id);
 	if (ret) {
 		vpu_dbg(LVL_ERR, "%s vpu mu init failed\n", __func__);
-		return ret;
+		goto error;
 	}
 	//firmware space for M0
 	core_dev->m0_p_fw_space_vir =
@@ -2442,6 +2288,12 @@ static int init_vpu_core_dev(struct vpu_dev *dev, u32 id)
 			VPU_REG_BASE, id);
 
 	return 0;
+error:
+	if (core_dev->workqueue) {
+		destroy_workqueue(core_dev->workqueue);
+		core_dev->workqueue = NULL;
+	}
+	return ret;
 }
 
 static int vpu_probe(struct platform_device *pdev)
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
index 35952e7..f98c387 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.h
@@ -61,8 +61,17 @@
 #define VPU_REG_BASE 0x40000000
 #endif
 #define ENC_REG_BASE 0x2c000000
-#define MIN_BUFFER_COUNT 3
-#define V4L2_MAX_CTRLS 12
+
+#define MIN_BUFFER_COUNT		3
+#define BITRATE_LOW_THRESHOLD		64
+#define BITRATE_HIGH_THRESHOLD		1048576
+#define GOP_H_THRESHOLD			300
+#define GOP_L_THRESHOLD			1
+#define GOP_DEFAULT			30
+#define QP_MAX				51
+#define QP_MIN				0
+#define QP_DEFAULT			25
+
 #define ENCODER_NODE_NUMBER 13 //use /dev/video13 as encoder node
 struct vpu_v4l2_control {
 	uint32_t id;
@@ -231,7 +240,6 @@ struct vpu_ctx {
 	struct vpu_dev *dev;
 	struct v4l2_fh fh;
 
-	struct v4l2_ctrl *ctrls[V4L2_MAX_CTRLS];
 	struct v4l2_ctrl_handler ctrl_handler;
 	bool ctrl_inited;
 
@@ -276,4 +284,7 @@ struct vpu_ctx {
 			pr_info(TAG""fmt, ## arg); \
 	} while (0)
 
+
+pMEDIAIP_ENC_PARAM get_enc_param(struct vpu_ctx *ctx);
+
 #endif
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.c
new file mode 100644
index 0000000..2f46251c
--- /dev/null
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.c
@@ -0,0 +1,443 @@
+/*
+ * Copyright(c) 2018 NXP. All rights reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ *
+ * @file vpu_encoder_ctrl.c
+ *
+ * Author Ming Qian<ming.qian@nxp.com>
+ */
+
+#include <media/v4l2-ctrls.h>
+
+#include "vpu_encoder_b0.h"
+#include "vpu_encoder_ctrl.h"
+
+// H264 level is maped like level 5.1 to uLevel 51, except level 1b to uLevel 14
+const u_int32 h264_level[] = {
+	[V4L2_MPEG_VIDEO_H264_LEVEL_1_0] = 10,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_1B]  = 14,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_1_1] = 11,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_1_2] = 12,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_1_3] = 13,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_2_0] = 20,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_2_1] = 21,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_2_2] = 22,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_3_0] = 30,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_3_1] = 31,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_3_2] = 32,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_4_0] = 40,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_4_1] = 41,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_4_2] = 42,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_5_0] = 50,
+	[V4L2_MPEG_VIDEO_H264_LEVEL_5_1] = 51
+};
+
+static int set_h264_profile(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	switch (ctrl->val) {
+	case V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
+		param->eProfile = MEDIAIP_ENC_PROF_H264_BP;
+		break;
+	case V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
+		param->eProfile = MEDIAIP_ENC_PROF_H264_MP;
+		break;
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
+		param->eProfile = MEDIAIP_ENC_PROF_H264_HP;
+		break;
+	default:
+		vpu_dbg(LVL_ERR, "not support H264 profile %d, set to main\n",
+				ctrl->val);
+		param->eProfile = MEDIAIP_ENC_PROF_H264_MP;
+		break;
+	}
+
+	return 0;
+}
+
+static int set_h264_level(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	param->uLevel = h264_level[ctrl->val];
+	vpu_dbg(LVL_DEBUG, "set h264 level to %d\n", ctrl->val);
+
+	return 0;
+}
+
+static int set_bitrate_mode(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	switch (ctrl->val) {
+	case V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
+		param->eBitRateMode =
+				MEDIAIP_ENC_BITRATECONTROLMODE_CONSTANT_QP;
+		break;
+	case V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
+		param->eBitRateMode = MEDIAIP_ENC_BITRATECONTROLMODE_CBR;
+		break;
+	default:
+		vpu_dbg(LVL_ERR, "not support bitrate mode %d, set to cbr\n",
+				ctrl->val);
+		param->eBitRateMode = MEDIAIP_ENC_BITRATECONTROLMODE_CBR;
+		break;
+	}
+
+	return 0;
+}
+
+static int set_bitrate(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	param->uTargetBitrate = ctrl->val;
+	if (param->uMaxBitRate < param->uTargetBitrate)
+		param->uMaxBitRate = param->uTargetBitrate;
+
+	return 0;
+}
+
+static int set_bitrate_peak(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	param->uMaxBitRate = ctrl->val;
+	if (param->uTargetBitrate > param->uMaxBitRate)
+		param->uTargetBitrate = param->uMaxBitRate;
+
+	return 0;
+}
+
+static int set_gop_size(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	param->uGopBLength = ctrl->val;
+
+	return 0;
+}
+
+static int set_i_period(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	param->uIFrameInterval = ctrl->val;
+
+	return 0;
+}
+
+static int set_qp(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_ctx *ctx = v4l2_ctrl_to_ctx(ctrl);
+	pMEDIAIP_ENC_PARAM  param = get_enc_param(ctx);
+
+	param->uInitSliceQP = ctrl->val;
+
+	return 0;
+}
+
+static int get_min_buffers_for_output(struct v4l2_ctrl *ctrl)
+{
+	vpu_dbg(LVL_DEBUG, "get min buffers for output\n");
+
+	ctrl->val = MIN_BUFFER_COUNT;
+
+	return 0;
+}
+
+static int add_ctrl_h264_profile(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_h264_profile_ops = {
+		.s_ctrl = set_h264_profile,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrl_handler,
+				      &ctrl_h264_profile_ops,
+				      V4L2_CID_MPEG_VIDEO_H264_PROFILE,
+				      V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,
+				      0xa,
+				      V4L2_MPEG_VIDEO_H264_PROFILE_MAIN);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl h264 profile fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_h264_level(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_h264_level_ops = {
+		.s_ctrl = set_h264_level,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrl_handler,
+				      &ctrl_h264_level_ops,
+				      V4L2_CID_MPEG_VIDEO_H264_LEVEL,
+				      V4L2_MPEG_VIDEO_H264_LEVEL_5_1,
+				      0x0,
+				      V4L2_MPEG_VIDEO_H264_LEVEL_4_0);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl h264 level fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_bitrate_mode(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_bitrate_mode_ops = {
+		.s_ctrl = set_bitrate_mode,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrl_handler,
+				      &ctrl_bitrate_mode_ops,
+				      V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+				      V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,
+				      0x0,
+				      V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl bitrate mode fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_bitrate(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_bitrate_ops = {
+		.s_ctrl = set_bitrate,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_bitrate_ops,
+				 V4L2_CID_MPEG_VIDEO_BITRATE,
+				 BITRATE_LOW_THRESHOLD,
+				 BITRATE_HIGH_THRESHOLD,
+				 1,
+				 1024);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl bitrate fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_bitrate_peak(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_bitrate_ops = {
+		.s_ctrl = set_bitrate_peak,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_bitrate_ops,
+				 V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,
+				 BITRATE_LOW_THRESHOLD,
+				 BITRATE_HIGH_THRESHOLD,
+				 1,
+				 2048);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl bitrate peak fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_gop_size(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_gop_ops = {
+		.s_ctrl = set_gop_size,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_gop_ops,
+				 V4L2_CID_MPEG_VIDEO_GOP_SIZE,
+				 GOP_L_THRESHOLD,
+				 GOP_H_THRESHOLD,
+				 1,
+				 GOP_DEFAULT);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl gop size fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_i_period(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_i_period_ops = {
+		.s_ctrl = set_i_period,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+			&ctrl_i_period_ops,
+			V4L2_CID_MPEG_VIDEO_H264_I_PERIOD,
+			GOP_L_THRESHOLD,
+			GOP_H_THRESHOLD,
+			1,
+			GOP_DEFAULT);
+
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl i period fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_i_frame_qp(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_iframe_qp_ops = {
+		.s_ctrl = set_qp,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_iframe_qp_ops,
+				 V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP,
+				 QP_MIN,
+				 QP_MAX,
+				 1,
+				 QP_DEFAULT);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl h264 I frame qp fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_p_frame_qp(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_pframe_qp_ops = {
+		.s_ctrl = set_qp,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_pframe_qp_ops,
+				 V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP,
+				 QP_MIN,
+				 QP_MAX,
+				 1,
+				 QP_DEFAULT);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl h264 P frame qp fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_b_frame_qp(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_bframe_qp_ops = {
+		.s_ctrl = set_qp,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_bframe_qp_ops,
+				 V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP,
+				 QP_MIN,
+				 QP_MAX,
+				 1,
+				 QP_DEFAULT);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl h264 B frame qp fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int add_ctrl_min_buffers_for_output(struct vpu_ctx *ctx)
+{
+	static const struct v4l2_ctrl_ops ctrl_min_buffers_ops = {
+		.g_volatile_ctrl = get_min_buffers_for_output,
+	};
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler,
+				 &ctrl_min_buffers_ops,
+				 V4L2_CID_MIN_BUFFERS_FOR_OUTPUT,
+				 1,
+				 32,
+				 1,
+				 MIN_BUFFER_COUNT);
+	if (!ctrl) {
+		vpu_dbg(LVL_ERR, "add ctrl min buffers for output fail\n");
+		return -EINVAL;
+	}
+
+	ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	return 0;
+}
+
+static int vpu_enc_register_ctrls(struct vpu_ctx *ctx)
+{
+	add_ctrl_h264_profile(ctx);
+	add_ctrl_h264_level(ctx);
+	add_ctrl_bitrate_mode(ctx);
+	add_ctrl_bitrate(ctx);
+	add_ctrl_bitrate_peak(ctx);
+	add_ctrl_gop_size(ctx);
+	add_ctrl_i_period(ctx);
+	add_ctrl_i_frame_qp(ctx);
+	add_ctrl_p_frame_qp(ctx);
+	add_ctrl_b_frame_qp(ctx);
+	add_ctrl_min_buffers_for_output(ctx);
+
+	return 0;
+}
+
+int vpu_enc_setup_ctrls(struct vpu_ctx *ctx)
+{
+	v4l2_ctrl_handler_init(&ctx->ctrl_handler, 11);
+	vpu_enc_register_ctrls(ctx);
+	if (ctx->ctrl_handler.error) {
+		vpu_dbg(LVL_ERR, "control initialization error (%d)\n",
+			ctx->ctrl_handler.error);
+		return -EINVAL;
+	}
+	ctx->ctrl_inited = true;
+	return v4l2_ctrl_handler_setup(&ctx->ctrl_handler);
+}
+
+int vpu_enc_free_ctrls(struct vpu_ctx *ctx)
+{
+	if (ctx->ctrl_inited) {
+		v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+		ctx->ctrl_inited = false;
+	}
+
+	return 0;
+}
diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.h b/drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.h
new file mode 100644
index 0000000..5fc9818
--- /dev/null
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_ctrl.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright(c) 2018 NXP. All rights reserved.
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * vpu_encoder_ctrl.h
+ *
+ * Author Ming Qian<ming.qian@nxp.com>
+ */
+#ifndef _VPU_ENCODER_CTRL_H
+#define _VPU_ENCODER_CTRL_H
+
+#include "mediasys_types.h"
+
+int vpu_enc_setup_ctrls(struct vpu_ctx *ctx);
+int vpu_enc_free_ctrls(struct vpu_ctx *ctx);
+
+#endif
-- 
1.7.9.5


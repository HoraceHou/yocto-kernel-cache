From 24b6346f33b29ff374655527889f6c254530c528 Mon Sep 17 00:00:00 2001
From: GuoRui <rui.guo_4@nxp.com>
Date: Fri, 1 Jun 2018 19:01:39 +0800
Subject: [PATCH 3901/5242] MLK-18481: encoder multi-instance, wait_timeout,
 suspend & resume

commit  6a232a5955bc35e960ebce8647e1a482dc800850 from
https://source.codeaurora.org/external/imx/linux-imx.git

fix encoder multi-instance bug
modify wait to wait_timeout
complete encoder suspend and resume

Signed-off-by: GuoRui <rui.guo_4@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c |   28 ++++++++++++++++++++-------
 1 file changed, 21 insertions(+), 7 deletions(-)

diff --git a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
index 1768a61..2ba0b3d 100644
--- a/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
+++ b/drivers/mxc/vpu-encoder-b0/vpu_encoder_b0.c
@@ -810,9 +810,14 @@ static bool update_yuv_addr(struct vpu_ctx *ctx, u_int32 uStrIdx)
 	pParamYuvBuffDesc = (pMEDIAIP_ENC_YUV_BUFFER_DESC)phy_to_virt(pEncCtrlInterface->pEncYUVBufferDesc,
 			ctx->dev->shared_mem.base_offset);
 
-	wait_event_interruptible(ctx->buffer_wq_input,
-			!list_empty(&This->drv_q) || ctx->forceStop
-			);
+	while (1) {
+		if (!wait_event_interruptible_timeout(ctx->buffer_wq_input,
+				(!list_empty(&This->drv_q)) || ctx->forceStop,
+				msecs_to_jiffies(5000)))
+			vpu_dbg(LVL_ERR, " warn: wait_event_interruptible_timeout wait 5s timeout\n");
+		else
+			break;
+	}
 
 	down(&This->drv_q_lock);
 	if (!list_empty(&This->drv_q)) {
@@ -880,9 +885,14 @@ static void report_stream_done(struct vpu_ctx *ctx,  MEDIAIP_ENC_PIC_INFO *pEncP
 	rptr_virt = ctx->encoder_stream.virt_addr + rptr - start;
 
 	vpu_dbg(LVL_INFO, "report_stream_done eptr=%x, rptr=%x, start=%x, end=%x\n", wptr, rptr, start, end);
-	wait_event_interruptible(ctx->buffer_wq_output,
-			!list_empty(&This->drv_q) || ctx->forceStop
-			);
+	while (1) {
+		if (!wait_event_interruptible_timeout(ctx->buffer_wq_output,
+				(!list_empty(&This->drv_q)) || ctx->forceStop,
+				msecs_to_jiffies(5000)))
+			vpu_dbg(LVL_ERR, " warn: wait_event_interruptible_timeout wait 5s timeout\n");
+		else
+			break;
+	}
 	if (ctx->forceStop)
 		return;
 
@@ -1036,7 +1046,7 @@ static void vpu_api_event_handler(struct vpu_ctx *ctx, u_int32 uStrIdx, u_int32
 	if (uStrIdx < VID_API_NUM_STREAMS) {
 		switch (uEvent) {
 		case VID_API_ENC_EVENT_START_DONE: {
-		update_yuv_addr(ctx, 0);
+		update_yuv_addr(ctx, uStrIdx);
 		v4l2_vpu_send_cmd(ctx, uStrIdx, GTB_ENC_CMD_FRAME_ENCODE, 0, NULL);
 		} break;
 		case VID_API_ENC_EVENT_MEM_REQUEST: {
@@ -1124,6 +1134,9 @@ static irqreturn_t fsl_vpu_mu_isr(int irq, void *This)
 	} else if (msg == 0x55) {
 		dev->firmware_started = true;
 		complete(&dev->start_cmp);
+	}  else if (msg == 0xA5) {
+		/*receive snapshot done msg and wakeup complete to suspend*/
+		complete(&dev->snap_done_cmp);
 	} else
 		schedule_work(&dev->msg_work);
 	return IRQ_HANDLED;
@@ -1991,6 +2004,7 @@ static int vpu_probe(struct platform_device *pdev)
 	mutex_init(&dev->dev_mutex);
 	mutex_init(&dev->cmd_mutex);
 	init_completion(&dev->start_cmp);
+	init_completion(&dev->snap_done_cmp);
 	dev->firmware_started = false;
 
 	dev->fw_is_ready = false;
-- 
1.7.9.5


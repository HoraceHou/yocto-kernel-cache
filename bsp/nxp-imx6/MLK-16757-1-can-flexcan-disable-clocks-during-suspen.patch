From 35760f52316c881bd30e27d4bf503e80b3384722 Mon Sep 17 00:00:00 2001
From: Dong Aisheng <aisheng.dong@nxp.com>
Date: Mon, 30 Oct 2017 19:13:38 +0800
Subject: [PATCH 2775/5242] MLK-16757-1 can: flexcan: disable clocks during
 suspend

commit  0165c6427272f88a4945b3a8424e5dbe6243d258 from
https://source.codeaurora.org/external/imx/linux-imx.git

Flexcan will be stopped during suspend if no wakeup function required
and enabled after resume accordingly. During this period, we could
explicitly disable clocks.

We do this by moving the clk_prepare_enable/clk_disable_unprepare into
flexcan_chip_start and flexcan_chip_stop functions which will be called
during suspend/resume function.

Reviewed-by: Frank Li <frank.li@nxp.com>
Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/can/flexcan.c |   75 ++++++++++++++++++++++++++-------------------
 1 file changed, 44 insertions(+), 31 deletions(-)

diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 6f8182b..ddffff5 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -396,6 +396,27 @@ static inline void flexcan_error_irq_disable(const struct flexcan_priv *priv)
 	priv->write(reg_ctrl, &regs->ctrl);
 }
 
+static int flexcan_clks_enable(const struct flexcan_priv *priv)
+{
+	int err;
+
+	err = clk_prepare_enable(priv->clk_ipg);
+	if (err)
+		return err;
+
+	err = clk_prepare_enable(priv->clk_per);
+	if (err)
+		clk_disable_unprepare(priv->clk_ipg);
+
+	return err;
+}
+
+static void flexcan_clks_disable(const struct flexcan_priv *priv)
+{
+	clk_disable_unprepare(priv->clk_ipg);
+	clk_disable_unprepare(priv->clk_per);
+}
+
 static inline void flexcan_enter_stop_mode(struct flexcan_priv *priv)
 {
 	/* enable stop request */
@@ -548,19 +569,13 @@ static int flexcan_get_berr_counter(const struct net_device *dev,
 	const struct flexcan_priv *priv = netdev_priv(dev);
 	int err;
 
-	err = clk_prepare_enable(priv->clk_ipg);
+	err = flexcan_clks_enable(priv);
 	if (err)
 		return err;
 
-	err = clk_prepare_enable(priv->clk_per);
-	if (err)
-		goto out_disable_ipg;
-
 	err = __flexcan_get_berr_counter(dev, bec);
 
-	clk_disable_unprepare(priv->clk_per);
- out_disable_ipg:
-	clk_disable_unprepare(priv->clk_ipg);
+	flexcan_clks_disable(priv);
 
 	return err;
 }
@@ -979,10 +994,14 @@ static int flexcan_chip_start(struct net_device *dev)
 	u32 reg_mcr, reg_ctrl, reg_ctrl2, reg_mecr;
 	int err, i;
 
+	err = flexcan_clks_enable(priv);
+	if (err)
+		return err;
+
 	/* enable module */
 	err = flexcan_chip_enable(priv);
 	if (err)
-		return err;
+		goto out_clocks_disable;
 
 	/* soft reset */
 	err = flexcan_chip_softreset(priv);
@@ -1143,6 +1162,9 @@ static int flexcan_chip_start(struct net_device *dev)
 	flexcan_transceiver_disable(priv);
  out_chip_disable:
 	flexcan_chip_disable(priv);
+ out_clocks_disable:
+	flexcan_clks_disable(priv);
+
 	return err;
 }
 
@@ -1165,6 +1187,8 @@ static void flexcan_chip_stop(struct net_device *dev)
 	priv->write(priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL,
 		    &regs->ctrl);
 
+	flexcan_clks_disable(priv);
+
 	flexcan_transceiver_disable(priv);
 	priv->can.state = CAN_STATE_STOPPED;
 }
@@ -1174,17 +1198,13 @@ static int flexcan_open(struct net_device *dev)
 	struct flexcan_priv *priv = netdev_priv(dev);
 	int err;
 
-	err = clk_prepare_enable(priv->clk_ipg);
+	err = flexcan_clks_enable(priv);
 	if (err)
 		return err;
 
-	err = clk_prepare_enable(priv->clk_per);
-	if (err)
-		goto out_disable_ipg;
-
 	err = open_candev(dev);
 	if (err)
-		goto out_disable_per;
+		goto out_clocks_disable;
 
 	err = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);
 	if (err)
@@ -1206,10 +1226,9 @@ static int flexcan_open(struct net_device *dev)
 	free_irq(dev->irq, dev);
  out_close:
 	close_candev(dev);
- out_disable_per:
-	clk_disable_unprepare(priv->clk_per);
- out_disable_ipg:
-	clk_disable_unprepare(priv->clk_ipg);
+
+ out_clocks_disable:
+	flexcan_clks_disable(priv);
 
 	return err;
 }
@@ -1223,13 +1242,13 @@ static int flexcan_close(struct net_device *dev)
 	flexcan_chip_stop(dev);
 
 	free_irq(dev->irq, dev);
-	clk_disable_unprepare(priv->clk_per);
-	clk_disable_unprepare(priv->clk_ipg);
 
 	close_candev(dev);
 
 	can_led_event(dev, CAN_LED_EVENT_STOP);
 
+	flexcan_clks_disable(priv);
+
 	return 0;
 }
 
@@ -1266,18 +1285,14 @@ static int register_flexcandev(struct net_device *dev)
 	struct flexcan_regs __iomem *regs = priv->regs;
 	u32 reg, err;
 
-	err = clk_prepare_enable(priv->clk_ipg);
+	err = flexcan_clks_enable(priv);
 	if (err)
 		return err;
 
-	err = clk_prepare_enable(priv->clk_per);
-	if (err)
-		goto out_disable_ipg;
-
 	/* select "bus clock", chip must be disabled */
 	err = flexcan_chip_disable(priv);
 	if (err)
-		goto out_disable_per;
+		goto out_clocks_disable;
 	reg = priv->read(&regs->ctrl);
 	reg |= FLEXCAN_CTRL_CLK_SRC;
 	priv->write(reg, &regs->ctrl);
@@ -1309,10 +1324,8 @@ static int register_flexcandev(struct net_device *dev)
 	/* disable core and turn off clocks */
  out_chip_disable:
 	flexcan_chip_disable(priv);
- out_disable_per:
-	clk_disable_unprepare(priv->clk_per);
- out_disable_ipg:
-	clk_disable_unprepare(priv->clk_ipg);
+ out_clocks_disable:
+	flexcan_clks_disable(priv);
 
 	return err;
 }
-- 
1.7.9.5


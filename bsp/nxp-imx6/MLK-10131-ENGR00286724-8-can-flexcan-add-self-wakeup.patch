From feb91bbce6f3039f7c34c9c9467e8fdabad99bde Mon Sep 17 00:00:00 2001
From: Dong Aisheng <b29396@freescale.com>
Date: Wed, 6 Nov 2013 19:10:28 +0800
Subject: [PATCH 0596/5242] MLK-10131 ENGR00286724-8 can: flexcan: add self
 wakeup support

commit  01f799229cf1fb0182d6c01d6169b4f874b5ea66 from
https://source.codeaurora.org/external/imx/linux-imx.git

If wakeup is enabled, enter stop mode, else enter disabled mode.
Self wake can only work on stop mode.
For imx6q, the stop request has to be mannually assert on
IOMUX GPR13[28:29] register, we use syscon to control that bit.

Signed-off-by: Dong Aisheng <b29396@freescale.com>
(cherry picked from commit 7f8ef8eeb2bd93d75eb4c970bcaabcfd499d348d)
(cherry picked from commit 496fef522e515488147cce3adcc7f101bb532805)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/net/can/fsl-flexcan.txt    |    5 ++
 drivers/net/can/flexcan.c                          |   94 +++++++++++++++++---
 2 files changed, 89 insertions(+), 10 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt b/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
index bfc0c43..e8cc0a6 100644
--- a/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
+++ b/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
@@ -23,6 +23,11 @@ Optional properties:
               device tree node then controller is assumed to be little endian.
               if this property is present then controller is assumed to be big
               endian.
+- gpr: phandle to general purpose register node. The remote wakeup control
+	bits is stored here.
+- trx_en_gpio : enable gpio
+- trx_stby_gpio : standby gpio
+- trx_nerr_gpio : NERR gpio
 
 Example:
 
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index d427743..e98d9fb 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -31,11 +31,16 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
 
 #define DRV_NAME			"flexcan"
 
@@ -143,7 +148,8 @@
 	(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)
 #define FLEXCAN_ESR_ALL_INT \
 	(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | \
-	 FLEXCAN_ESR_BOFF_INT | FLEXCAN_ESR_ERR_INT)
+	 FLEXCAN_ESR_BOFF_INT | FLEXCAN_ESR_ERR_INT | \
+	 FLEXCAN_ESR_WAK_INT)
 
 /* FLEXCAN interrupt flag register (IFLAG) bits */
 /* Errata ERR005829 step7: Reserve first valid MB */
@@ -280,6 +286,8 @@ struct flexcan_priv {
 	struct flexcan_platform_data *pdata;
 	const struct flexcan_devtype_data *devtype_data;
 	struct regulator *reg_xceiver;
+	struct regmap *gpr;
+	int id;
 
 	/* Read and Write APIs */
 	u32 (*read)(void __iomem *addr);
@@ -379,6 +387,32 @@ static inline void flexcan_error_irq_disable(const struct flexcan_priv *priv)
 	priv->write(reg_ctrl, &regs->ctrl);
 }
 
+static inline void flexcan_enter_stop_mode(struct flexcan_priv *priv)
+{
+	int val;
+
+	/* enable stop request */
+	if (priv->devtype_data->quirks & FLEXCAN_QUIRK_DISABLE_RXFG) {
+		val = priv->id ? IMX6Q_GPR13_CAN2_STOP_REQ :
+				IMX6Q_GPR13_CAN1_STOP_REQ;
+		regmap_update_bits(priv->gpr, IOMUXC_GPR13,
+			val, val);
+	}
+}
+
+static inline void flexcan_exit_stop_mode(struct flexcan_priv *priv)
+{
+	int val;
+
+	/* remove stop request */
+	if (priv->devtype_data->quirks & FLEXCAN_QUIRK_DISABLE_RXFG) {
+		val = priv->id ? IMX6Q_GPR13_CAN2_STOP_REQ :
+				IMX6Q_GPR13_CAN1_STOP_REQ;
+		regmap_update_bits(priv->gpr, IOMUXC_GPR13,
+			val, 0);
+	}
+}
+
 static inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)
 {
 	if (priv->pdata && priv->pdata->transceiver_switch) {
@@ -841,6 +875,9 @@ static irqreturn_t flexcan_irq(int irq, void *dev_id)
 		priv->write(reg_esr & FLEXCAN_ESR_ALL_INT, &regs->esr);
 	}
 
+	if (reg_esr & FLEXCAN_ESR_WAK_INT)
+		flexcan_exit_stop_mode(priv);
+
 	/* state change interrupt or broken error state quirk fix is enabled */
 	if ((reg_esr & FLEXCAN_ESR_ERR_STATE) ||
 	    (priv->devtype_data->quirks & (FLEXCAN_QUIRK_BROKEN_WERR_STATE |
@@ -978,6 +1015,9 @@ static int flexcan_chip_start(struct net_device *dev)
 	else
 		reg_mcr |= FLEXCAN_MCR_FEN;
 
+	/* enable self wakeup */
+	reg_mcr |= FLEXCAN_MCR_WAK_MSK | FLEXCAN_MCR_SLF_WAK;
+
 	netdev_dbg(dev, "%s: writing mcr=0x%08x", __func__, reg_mcr);
 	priv->write(reg_mcr, &regs->mcr);
 
@@ -1314,6 +1354,7 @@ static int flexcan_probe(struct platform_device *pdev)
 	struct flexcan_regs __iomem *regs;
 	int err, irq;
 	u32 clock_freq = 0;
+	int wakeup = 1;
 
 	reg_xceiver = devm_regulator_get(&pdev->dev, "xceiver");
 	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)
@@ -1432,6 +1473,23 @@ static int flexcan_probe(struct platform_device *pdev)
 
 	devm_can_led_init(dev);
 
+	if (priv->devtype_data->quirks & FLEXCAN_QUIRK_DISABLE_RXFG) {
+		priv->gpr = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+				"gpr");
+		if (IS_ERR(priv->gpr)) {
+			wakeup = 0;
+			dev_dbg(&pdev->dev, "can not get grp\n");
+		}
+
+		priv->id = of_alias_get_id(pdev->dev.of_node, "flexcan");
+		if (priv->id < 0) {
+			wakeup = 0;
+			dev_dbg(&pdev->dev, "can not get alias id\n");
+		}
+	}
+
+	device_set_wakeup_capable(&pdev->dev, wakeup);
+
 	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",
 		 priv->regs, dev->irq);
 
@@ -1459,35 +1517,51 @@ static int __maybe_unused flexcan_suspend(struct device *device)
 {
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
-	int err;
+	int err = 0;
 
 	if (netif_running(dev)) {
-		err = flexcan_chip_disable(priv);
-		if (err)
-			return err;
 		netif_stop_queue(dev);
 		netif_device_detach(dev);
+		/*
+		* if wakeup is enabled, enter stop mode
+		* else enter disabled mode.
+		*/
+		if (device_may_wakeup(device)) {
+			enable_irq_wake(dev->irq);
+			flexcan_enter_stop_mode(priv);
+		} else {
+			err = flexcan_chip_disable(priv);
+		}
+	} else {
+		flexcan_chip_disable(priv);
 	}
 	priv->can.state = CAN_STATE_SLEEPING;
 
-	return 0;
+	return err;
 }
 
 static int __maybe_unused flexcan_resume(struct device *device)
 {
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
-	int err;
+	int err = 0;
 
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
 	if (netif_running(dev)) {
 		netif_device_attach(dev);
 		netif_start_queue(dev);
+
+		if (device_may_wakeup(device)) {
+			disable_irq_wake(dev->irq);
+			flexcan_exit_stop_mode(priv);
+		} else {
+			err = flexcan_chip_enable(priv);
+		}
+	} else {
 		err = flexcan_chip_enable(priv);
-		if (err)
-			return err;
 	}
-	return 0;
+
+	return err;
 }
 
 static SIMPLE_DEV_PM_OPS(flexcan_pm_ops, flexcan_suspend, flexcan_resume);
-- 
1.7.9.5


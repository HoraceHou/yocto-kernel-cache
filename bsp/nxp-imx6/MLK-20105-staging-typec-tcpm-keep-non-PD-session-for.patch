From 9f059a2cca83797b5f39b4ceec4bf8dbfc07e6ef Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Wed, 31 Oct 2018 13:58:04 +0800
Subject: [PATCH 4980/5242] MLK-20105 staging: typec: tcpm: keep non-PD
 session for no GoodCRC

commit  75fc02b7d64c4cae5c5fc54324220fcf31c60849 from
https://source.codeaurora.org/external/imx/linux-imx.git

In case of vbus_never_low, if source setup a typye-c only session, sink
time out on waiting for source capability message and send soft reset,
the source does not response by goodcrc for the soft reset message, we
don't do hard reset, but keep a non-PD typec session, because the source
maybe PD capable, this hard reset will make the source terminate the
session by turn off vbus, if this type-c port is the system power supply,
the whole system will reboot.

Acked-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/typec/tcpm.c |   19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/typec/tcpm.c b/drivers/usb/typec/tcpm.c
index b2af0c6..f92c4ce 100644
--- a/drivers/usb/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -3179,7 +3179,6 @@ static void run_state_machine(struct tcpm_port *port)
 		 * Do this only once.
 		 */
 		if (port->vbus_never_low) {
-			port->vbus_never_low = false;
 			tcpm_set_state(port, SOFT_RESET_SEND,
 				       PD_T_SINK_WAIT_CAP);
 		} else {
@@ -3338,11 +3337,23 @@ static void run_state_machine(struct tcpm_port *port)
 	case SOFT_RESET_SEND:
 		port->message_id = 0;
 		port->rx_msgid = -1;
-		if (tcpm_pd_send_control(port, PD_CTRL_SOFT_RESET))
-			tcpm_set_state_cond(port, hard_reset_state(port), 0);
-		else
+		if (tcpm_pd_send_control(port, PD_CTRL_SOFT_RESET)) {
+			if (port->vbus_never_low)
+				/*
+				 * No ack from source, we keep a
+				 * non-PD session as it is(only 5V)
+				 * because it may be the system power
+				 * source.
+				 */
+				tcpm_set_state(port, SNK_READY, 0);
+			else
+				tcpm_set_state_cond(port,
+						    hard_reset_state(port), 0);
+		} else {
 			tcpm_set_state_cond(port, hard_reset_state(port),
 					    PD_T_SENDER_RESPONSE);
+		}
+		port->vbus_never_low = false;
 		break;
 
 	/* DR_Swap states */
-- 
1.7.9.5


From 7057119a024ed47ef0f39eeb5ac0ca5b74c9dc08 Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Wed, 28 Mar 2018 21:21:02 +0300
Subject: [PATCH 1917/5242] MLK-15001-15 drm/imx: ipuv3-kms: Move to a new
 ipuv3 folder

commit  eb0386ba3029c9e79300af39bd5a1a62dfce2bc4 from
https://source.codeaurora.org/external/imx/linux-imx.git

Since we want to add i.MX DPU support into imx-drm, the IPUv3 KMS driver
can be put into the ipuv3 folder to organize the driver code better.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/Kconfig             |    2 +
 drivers/gpu/drm/imx/Makefile            |    4 +-
 drivers/gpu/drm/imx/imx-drm-core.c      |    2 +-
 drivers/gpu/drm/imx/ipuv3-crtc.c        |  493 ------------------
 drivers/gpu/drm/imx/ipuv3-kms.c         |  101 ----
 drivers/gpu/drm/imx/ipuv3-kms.h         |   20 -
 drivers/gpu/drm/imx/ipuv3-plane.c       |  845 -------------------------------
 drivers/gpu/drm/imx/ipuv3-plane.h       |   52 --
 drivers/gpu/drm/imx/ipuv3/Kconfig       |    6 +
 drivers/gpu/drm/imx/ipuv3/Makefile      |    4 +
 drivers/gpu/drm/imx/ipuv3/ipuv3-crtc.c  |  493 ++++++++++++++++++
 drivers/gpu/drm/imx/ipuv3/ipuv3-kms.c   |  101 ++++
 drivers/gpu/drm/imx/ipuv3/ipuv3-kms.h   |   20 +
 drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c |  845 +++++++++++++++++++++++++++++++
 drivers/gpu/drm/imx/ipuv3/ipuv3-plane.h |   52 ++
 15 files changed, 1526 insertions(+), 1514 deletions(-)
 delete mode 100644 drivers/gpu/drm/imx/ipuv3-crtc.c
 delete mode 100644 drivers/gpu/drm/imx/ipuv3-kms.c
 delete mode 100644 drivers/gpu/drm/imx/ipuv3-kms.h
 delete mode 100644 drivers/gpu/drm/imx/ipuv3-plane.c
 delete mode 100644 drivers/gpu/drm/imx/ipuv3-plane.h
 create mode 100644 drivers/gpu/drm/imx/ipuv3/Kconfig
 create mode 100644 drivers/gpu/drm/imx/ipuv3/Makefile
 create mode 100644 drivers/gpu/drm/imx/ipuv3/ipuv3-crtc.c
 create mode 100644 drivers/gpu/drm/imx/ipuv3/ipuv3-kms.c
 create mode 100644 drivers/gpu/drm/imx/ipuv3/ipuv3-kms.h
 create mode 100644 drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c
 create mode 100644 drivers/gpu/drm/imx/ipuv3/ipuv3-plane.h

diff --git a/drivers/gpu/drm/imx/Kconfig b/drivers/gpu/drm/imx/Kconfig
index f2c9ae8..70e3fa3 100644
--- a/drivers/gpu/drm/imx/Kconfig
+++ b/drivers/gpu/drm/imx/Kconfig
@@ -44,3 +44,5 @@ config DRM_IMX_HDMI
 	depends on DRM_IMX
 	help
 	  Choose this if you want to use HDMI on i.MX6.
+
+source "drivers/gpu/drm/imx/ipuv3/Kconfig"
diff --git a/drivers/gpu/drm/imx/Makefile b/drivers/gpu/drm/imx/Makefile
index f771872..f64243b 100644
--- a/drivers/gpu/drm/imx/Makefile
+++ b/drivers/gpu/drm/imx/Makefile
@@ -8,6 +8,6 @@ obj-$(CONFIG_DRM_IMX_PARALLEL_DISPLAY) += parallel-display.o
 obj-$(CONFIG_DRM_IMX_TVE) += imx-tve.o
 obj-$(CONFIG_DRM_IMX_LDB) += imx-ldb.o
 
-imx-ipuv3-crtc-objs  := ipuv3-crtc.o ipuv3-plane.o ipuv3-kms.o
-obj-$(CONFIG_DRM_IMX_IPUV3)	+= imx-ipuv3-crtc.o
 obj-$(CONFIG_DRM_IMX_HDMI) += dw_hdmi-imx.o
+
+obj-$(CONFIG_DRM_IMX_IPUV3) += ipuv3/
diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 9f25f41..5870aed 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -30,7 +30,7 @@
 #include <video/imx-ipu-v3.h>
 
 #include "imx-drm.h"
-#include "ipuv3-plane.h"
+#include "ipuv3/ipuv3-plane.h"
 
 #if IS_ENABLED(CONFIG_DRM_FBDEV_EMULATION)
 static int legacyfb_depth = 16;
diff --git a/drivers/gpu/drm/imx/ipuv3-crtc.c b/drivers/gpu/drm/imx/ipuv3-crtc.c
deleted file mode 100644
index cb0bfaf..0000000
--- a/drivers/gpu/drm/imx/ipuv3-crtc.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/*
- * i.MX IPUv3 Graphics driver
- *
- * Copyright (C) 2011 Sascha Hauer, Pengutronix
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <linux/component.h>
-#include <linux/module.h>
-#include <linux/export.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <drm/drmP.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_crtc_helper.h>
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-
-#include <video/imx-ipu-v3.h>
-#include "imx-drm.h"
-#include "ipuv3-kms.h"
-#include "ipuv3-plane.h"
-
-#define DRIVER_DESC		"i.MX IPUv3 Graphics"
-
-struct ipu_crtc {
-	struct device		*dev;
-	struct drm_crtc		base;
-	struct imx_drm_crtc	*imx_crtc;
-
-	/* plane[0] is the full plane, plane[1] is the partial plane */
-	struct ipu_plane	*plane[2];
-
-	struct ipu_dc		*dc;
-	struct ipu_di		*di;
-	int			irq;
-};
-
-static inline struct ipu_crtc *to_ipu_crtc(struct drm_crtc *crtc)
-{
-	return container_of(crtc, struct ipu_crtc, base);
-}
-
-static void ipu_crtc_atomic_enable(struct drm_crtc *crtc,
-				   struct drm_crtc_state *old_state)
-{
-	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
-	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
-
-	ipu_prg_enable(ipu);
-	ipu_dc_enable(ipu);
-	ipu_dc_enable_channel(ipu_crtc->dc);
-	ipu_di_enable(ipu_crtc->di);
-}
-
-static void ipu_crtc_disable_planes(struct ipu_crtc *ipu_crtc,
-				    struct drm_crtc_state *old_crtc_state)
-{
-	bool disable_partial = false;
-	bool disable_full = false;
-	struct drm_plane *plane;
-
-	drm_atomic_crtc_state_for_each_plane(plane, old_crtc_state) {
-		if (plane == &ipu_crtc->plane[0]->base)
-			disable_full = true;
-		if (&ipu_crtc->plane[1] && plane == &ipu_crtc->plane[1]->base)
-			disable_partial = true;
-	}
-
-	if (disable_partial)
-		ipu_plane_disable(ipu_crtc->plane[1], true);
-	if (disable_full)
-		ipu_plane_disable(ipu_crtc->plane[0], false);
-}
-
-static void ipu_crtc_atomic_disable(struct drm_crtc *crtc,
-				    struct drm_crtc_state *old_crtc_state)
-{
-	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
-	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
-
-	ipu_dc_disable_channel(ipu_crtc->dc);
-	ipu_di_disable(ipu_crtc->di);
-	/*
-	 * Planes must be disabled before DC clock is removed, as otherwise the
-	 * attached IDMACs will be left in undefined state, possibly hanging
-	 * the IPU or even system.
-	 */
-	ipu_crtc_disable_planes(ipu_crtc, old_crtc_state);
-	ipu_dc_disable(ipu);
-	ipu_prg_disable(ipu);
-
-	spin_lock_irq(&crtc->dev->event_lock);
-	if (crtc->state->event) {
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
-		crtc->state->event = NULL;
-	}
-	spin_unlock_irq(&crtc->dev->event_lock);
-
-	drm_crtc_vblank_off(crtc);
-}
-
-static void ipu_crtc_reset(struct drm_crtc *crtc)
-{
-	struct imx_crtc_state *state;
-
-	if (crtc->state) {
-		if (crtc->state->mode_blob)
-			drm_property_blob_put(crtc->state->mode_blob);
-
-		state = to_imx_crtc_state(crtc->state);
-		memset(state, 0, sizeof(*state));
-	} else {
-		state = kzalloc(sizeof(*state), GFP_KERNEL);
-		if (!state)
-			return;
-		crtc->state = &state->base;
-	}
-
-	state->base.crtc = crtc;
-}
-
-static struct drm_crtc_state *ipu_crtc_duplicate_state(struct drm_crtc *crtc)
-{
-	struct imx_crtc_state *state;
-
-	state = kzalloc(sizeof(*state), GFP_KERNEL);
-	if (!state)
-		return NULL;
-
-	__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);
-
-	WARN_ON(state->base.crtc != crtc);
-	state->base.crtc = crtc;
-
-	return &state->base;
-}
-
-static void ipu_crtc_destroy_state(struct drm_crtc *crtc,
-				struct drm_crtc_state *state)
-{
-	__drm_atomic_helper_crtc_destroy_state(state);
-	kfree(to_imx_crtc_state(state));
-}
-
-static int ipu_enable_vblank(struct drm_crtc *crtc)
-{
-	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
-
-	enable_irq(ipu_crtc->irq);
-
-	return 0;
-}
-
-static void ipu_disable_vblank(struct drm_crtc *crtc)
-{
-	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
-
-	disable_irq_nosync(ipu_crtc->irq);
-}
-
-static const struct drm_crtc_funcs ipu_crtc_funcs = {
-	.set_config = drm_atomic_helper_set_config,
-	.destroy = drm_crtc_cleanup,
-	.page_flip = drm_atomic_helper_page_flip,
-	.reset = ipu_crtc_reset,
-	.atomic_duplicate_state = ipu_crtc_duplicate_state,
-	.atomic_destroy_state = ipu_crtc_destroy_state,
-	.enable_vblank = ipu_enable_vblank,
-	.disable_vblank = ipu_disable_vblank,
-};
-
-static irqreturn_t ipu_irq_handler(int irq, void *dev_id)
-{
-	struct ipu_crtc *ipu_crtc = dev_id;
-
-	drm_crtc_handle_vblank(&ipu_crtc->base);
-
-	return IRQ_HANDLED;
-}
-
-static bool ipu_crtc_mode_fixup(struct drm_crtc *crtc,
-				  const struct drm_display_mode *mode,
-				  struct drm_display_mode *adjusted_mode)
-{
-	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
-	struct videomode vm;
-	int ret;
-
-	drm_display_mode_to_videomode(adjusted_mode, &vm);
-
-	ret = ipu_di_adjust_videomode(ipu_crtc->di, &vm);
-	if (ret)
-		return false;
-
-	if ((vm.vsync_len == 0) || (vm.hsync_len == 0))
-		return false;
-
-	drm_display_mode_from_videomode(&vm, adjusted_mode);
-
-	return true;
-}
-
-static int ipu_crtc_atomic_check(struct drm_crtc *crtc,
-				 struct drm_crtc_state *state)
-{
-	u32 primary_plane_mask = 1 << drm_plane_index(crtc->primary);
-
-	if (state->active && (primary_plane_mask & state->plane_mask) == 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-static void ipu_crtc_atomic_begin(struct drm_crtc *crtc,
-				  struct drm_crtc_state *old_crtc_state)
-{
-	drm_crtc_vblank_on(crtc);
-}
-
-static void ipu_crtc_atomic_flush(struct drm_crtc *crtc,
-				  struct drm_crtc_state *old_crtc_state)
-{
-	spin_lock_irq(&crtc->dev->event_lock);
-	if (crtc->state->event) {
-		WARN_ON(drm_crtc_vblank_get(crtc));
-		drm_crtc_arm_vblank_event(crtc, crtc->state->event);
-		crtc->state->event = NULL;
-	}
-	spin_unlock_irq(&crtc->dev->event_lock);
-}
-
-static void ipu_crtc_mode_set_nofb(struct drm_crtc *crtc)
-{
-	struct drm_device *dev = crtc->dev;
-	struct drm_encoder *encoder;
-	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
-	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	struct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc->state);
-	struct ipu_di_signal_cfg sig_cfg = {};
-	unsigned long encoder_types = 0;
-
-	dev_dbg(ipu_crtc->dev, "%s: mode->hdisplay: %d\n", __func__,
-			mode->hdisplay);
-	dev_dbg(ipu_crtc->dev, "%s: mode->vdisplay: %d\n", __func__,
-			mode->vdisplay);
-
-	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
-		if (encoder->crtc == crtc)
-			encoder_types |= BIT(encoder->encoder_type);
-	}
-
-	dev_dbg(ipu_crtc->dev, "%s: attached to encoder types 0x%lx\n",
-		__func__, encoder_types);
-
-	/*
-	 * If we have DAC or LDB, then we need the IPU DI clock to be
-	 * the same as the LDB DI clock. For TVDAC, derive the IPU DI
-	 * clock from 27 MHz TVE_DI clock, but allow to divide it.
-	 */
-	if (encoder_types & (BIT(DRM_MODE_ENCODER_DAC) |
-			     BIT(DRM_MODE_ENCODER_LVDS)))
-		sig_cfg.clkflags = IPU_DI_CLKMODE_SYNC | IPU_DI_CLKMODE_EXT;
-	else if (encoder_types & BIT(DRM_MODE_ENCODER_TVDAC))
-		sig_cfg.clkflags = IPU_DI_CLKMODE_EXT;
-	else
-		sig_cfg.clkflags = 0;
-
-	sig_cfg.enable_pol = !(imx_crtc_state->bus_flags & DRM_BUS_FLAG_DE_LOW);
-	/* Default to driving pixel data on negative clock edges */
-	sig_cfg.clk_pol = !!(imx_crtc_state->bus_flags &
-			     DRM_BUS_FLAG_PIXDATA_POSEDGE);
-	sig_cfg.bus_format = imx_crtc_state->bus_format;
-	sig_cfg.v_to_h_sync = 0;
-	sig_cfg.hsync_pin = imx_crtc_state->di_hsync_pin;
-	sig_cfg.vsync_pin = imx_crtc_state->di_vsync_pin;
-
-	drm_display_mode_to_videomode(mode, &sig_cfg.mode);
-
-	ipu_dc_init_sync(ipu_crtc->dc, ipu_crtc->di,
-			 mode->flags & DRM_MODE_FLAG_INTERLACE,
-			 imx_crtc_state->bus_format, mode->hdisplay);
-	ipu_di_init_sync_panel(ipu_crtc->di, &sig_cfg);
-}
-
-static const struct drm_crtc_helper_funcs ipu_helper_funcs = {
-	.mode_fixup = ipu_crtc_mode_fixup,
-	.mode_set_nofb = ipu_crtc_mode_set_nofb,
-	.atomic_check = ipu_crtc_atomic_check,
-	.atomic_begin = ipu_crtc_atomic_begin,
-	.atomic_flush = ipu_crtc_atomic_flush,
-	.atomic_disable = ipu_crtc_atomic_disable,
-	.atomic_enable = ipu_crtc_atomic_enable,
-};
-
-static void ipu_put_resources(struct ipu_crtc *ipu_crtc)
-{
-	if (!IS_ERR_OR_NULL(ipu_crtc->dc))
-		ipu_dc_put(ipu_crtc->dc);
-	if (!IS_ERR_OR_NULL(ipu_crtc->di))
-		ipu_di_put(ipu_crtc->di);
-}
-
-static int ipu_get_resources(struct ipu_crtc *ipu_crtc,
-		struct ipu_client_platformdata *pdata)
-{
-	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
-	int ret;
-
-	ipu_crtc->dc = ipu_dc_get(ipu, pdata->dc);
-	if (IS_ERR(ipu_crtc->dc)) {
-		ret = PTR_ERR(ipu_crtc->dc);
-		goto err_out;
-	}
-
-	ipu_crtc->di = ipu_di_get(ipu, pdata->di);
-	if (IS_ERR(ipu_crtc->di)) {
-		ret = PTR_ERR(ipu_crtc->di);
-		goto err_out;
-	}
-
-	return 0;
-err_out:
-	ipu_put_resources(ipu_crtc);
-
-	return ret;
-}
-
-static int ipu_crtc_init(struct ipu_crtc *ipu_crtc,
-	struct ipu_client_platformdata *pdata, struct drm_device *drm)
-{
-	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
-	struct drm_crtc *crtc = &ipu_crtc->base;
-	int dp = -EINVAL;
-	int ret;
-
-	ret = ipu_get_resources(ipu_crtc, pdata);
-	if (ret) {
-		dev_err(ipu_crtc->dev, "getting resources failed with %d.\n",
-				ret);
-		return ret;
-	}
-
-	if (pdata->dp >= 0)
-		dp = IPU_DP_FLOW_SYNC_BG;
-	ipu_crtc->plane[0] = ipu_plane_init(drm, ipu, pdata->dma[0], dp, 0,
-					    DRM_PLANE_TYPE_PRIMARY);
-	if (IS_ERR(ipu_crtc->plane[0])) {
-		ret = PTR_ERR(ipu_crtc->plane[0]);
-		goto err_put_resources;
-	}
-
-	crtc->port = pdata->of_node;
-	drm_crtc_helper_add(crtc, &ipu_helper_funcs);
-	drm_crtc_init_with_planes(drm, crtc, &ipu_crtc->plane[0]->base, NULL,
-				  &ipu_crtc_funcs, NULL);
-
-	ret = ipu_plane_get_resources(ipu_crtc->plane[0]);
-	if (ret) {
-		dev_err(ipu_crtc->dev, "getting plane 0 resources failed with %d.\n",
-			ret);
-		goto err_put_resources;
-	}
-
-	/* If this crtc is using the DP, add an overlay plane */
-	if (pdata->dp >= 0 && pdata->dma[1] > 0) {
-		ipu_crtc->plane[1] = ipu_plane_init(drm, ipu, pdata->dma[1],
-						IPU_DP_FLOW_SYNC_FG,
-						drm_crtc_mask(&ipu_crtc->base),
-						DRM_PLANE_TYPE_OVERLAY);
-		if (IS_ERR(ipu_crtc->plane[1])) {
-			ipu_crtc->plane[1] = NULL;
-		} else {
-			ret = ipu_plane_get_resources(ipu_crtc->plane[1]);
-			if (ret) {
-				dev_err(ipu_crtc->dev, "getting plane 1 "
-					"resources failed with %d.\n", ret);
-				goto err_put_plane0_res;
-			}
-		}
-	}
-
-	ipu_crtc->irq = ipu_plane_irq(ipu_crtc->plane[0]);
-	ret = devm_request_irq(ipu_crtc->dev, ipu_crtc->irq, ipu_irq_handler, 0,
-			"imx_drm", ipu_crtc);
-	if (ret < 0) {
-		dev_err(ipu_crtc->dev, "irq request failed with %d.\n", ret);
-		goto err_put_plane1_res;
-	}
-	/* Only enable IRQ when we actually need it to trigger work. */
-	disable_irq(ipu_crtc->irq);
-
-	return 0;
-
-err_put_plane1_res:
-	if (ipu_crtc->plane[1])
-		ipu_plane_put_resources(ipu_crtc->plane[1]);
-err_put_plane0_res:
-	ipu_plane_put_resources(ipu_crtc->plane[0]);
-err_put_resources:
-	ipu_put_resources(ipu_crtc);
-
-	return ret;
-}
-
-static int ipu_drm_bind(struct device *dev, struct device *master, void *data)
-{
-	struct ipu_client_platformdata *pdata = dev->platform_data;
-	struct drm_device *drm = data;
-	struct ipu_crtc *ipu_crtc;
-	int ret;
-
-	ipu_crtc = devm_kzalloc(dev, sizeof(*ipu_crtc), GFP_KERNEL);
-	if (!ipu_crtc)
-		return -ENOMEM;
-
-	ipu_crtc->dev = dev;
-
-	ret = ipu_crtc_init(ipu_crtc, pdata, drm);
-	if (ret)
-		return ret;
-
-	if (!drm->mode_config.funcs)
-		drm->mode_config.funcs = &ipuv3_drm_mode_config_funcs;
-	if (!drm->mode_config.helper_private)
-		drm->mode_config.helper_private =
-					&ipuv3_drm_mode_config_helpers;
-
-	dev_set_drvdata(dev, ipu_crtc);
-
-	return 0;
-}
-
-static void ipu_drm_unbind(struct device *dev, struct device *master,
-	void *data)
-{
-	struct ipu_crtc *ipu_crtc = dev_get_drvdata(dev);
-
-	ipu_put_resources(ipu_crtc);
-	if (ipu_crtc->plane[1])
-		ipu_plane_put_resources(ipu_crtc->plane[1]);
-	ipu_plane_put_resources(ipu_crtc->plane[0]);
-}
-
-static const struct component_ops ipu_crtc_ops = {
-	.bind = ipu_drm_bind,
-	.unbind = ipu_drm_unbind,
-};
-
-static int ipu_drm_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	int ret;
-
-	if (!dev->platform_data)
-		return -EINVAL;
-
-	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
-	if (ret)
-		return ret;
-
-	return component_add(dev, &ipu_crtc_ops);
-}
-
-static int ipu_drm_remove(struct platform_device *pdev)
-{
-	component_del(&pdev->dev, &ipu_crtc_ops);
-	return 0;
-}
-
-static struct platform_driver ipu_drm_driver = {
-	.driver = {
-		.name = "imx-ipuv3-crtc",
-	},
-	.probe = ipu_drm_probe,
-	.remove = ipu_drm_remove,
-};
-module_platform_driver(ipu_drm_driver);
-
-MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:imx-ipuv3-crtc");
diff --git a/drivers/gpu/drm/imx/ipuv3-kms.c b/drivers/gpu/drm/imx/ipuv3-kms.c
deleted file mode 100644
index d342458..0000000
--- a/drivers/gpu/drm/imx/ipuv3-kms.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <drm/drmP.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <linux/dma-buf.h>
-#include <linux/reservation.h>
-#include "imx-drm.h"
-
-static int imx_drm_atomic_check(struct drm_device *dev,
-				struct drm_atomic_state *state)
-{
-	int ret;
-
-	ret = drm_atomic_helper_check_modeset(dev, state);
-	if (ret)
-		return ret;
-
-	ret = drm_atomic_helper_check_planes(dev, state);
-	if (ret)
-		return ret;
-
-	/*
-	 * Check modeset again in case crtc_state->mode_changed is
-	 * updated in plane's ->atomic_check callback.
-	 */
-	ret = drm_atomic_helper_check_modeset(dev, state);
-	if (ret)
-		return ret;
-
-	/* Assign PRG/PRE channels and check if all constrains are satisfied. */
-	ret = ipu_planes_assign_pre(dev, state);
-	if (ret)
-		return ret;
-
-	return ret;
-}
-
-static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
-	.fb_create = drm_gem_fb_create,
-	.output_poll_changed = drm_fb_helper_output_poll_changed,
-	.atomic_check = imx_drm_atomic_check,
-	.atomic_commit = drm_atomic_helper_commit,
-};
-
-static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
-{
-	struct drm_device *dev = state->dev;
-	struct drm_plane *plane;
-	struct drm_plane_state *old_plane_state, *new_plane_state;
-	bool plane_disabling = false;
-	int i;
-
-	drm_atomic_helper_commit_modeset_disables(dev, state);
-
-	drm_atomic_helper_commit_planes(dev, state,
-				DRM_PLANE_COMMIT_ACTIVE_ONLY |
-				DRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET);
-
-	drm_atomic_helper_commit_modeset_enables(dev, state);
-
-	for_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {
-		if (drm_atomic_plane_disabling(old_plane_state, new_plane_state))
-			plane_disabling = true;
-	}
-
-	/*
-	 * The flip done wait is only strictly required by imx-drm if a deferred
-	 * plane disable is in-flight. As the core requires blocking commits
-	 * to wait for the flip it is done here unconditionally. This keeps the
-	 * workitem around a bit longer than required for the majority of
-	 * non-blocking commits, but we accept that for the sake of simplicity.
-	 */
-	drm_atomic_helper_wait_for_flip_done(dev, state);
-
-	if (plane_disabling) {
-		for_each_old_plane_in_state(state, plane, old_plane_state, i)
-			ipu_plane_disable_deferred(plane);
-
-	}
-
-	drm_atomic_helper_commit_hw_done(state);
-}
-
-static const struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
-	.atomic_commit_tail = imx_drm_atomic_commit_tail,
-};
diff --git a/drivers/gpu/drm/imx/ipuv3-kms.h b/drivers/gpu/drm/imx/ipuv3-kms.h
deleted file mode 100644
index 3968131..0000000
--- a/drivers/gpu/drm/imx/ipuv3-kms.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright 2017 NXP
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-#ifndef _IPUV3_KMS_H_
-#define _IPUV3_KMS_H_
-
-extern const struct drm_mode_config_funcs ipuv3_drm_mode_config_funcs;
-extern struct drm_mode_config_helper_funcs ipuv3_drm_mode_config_helpers;
-
-#endif
diff --git a/drivers/gpu/drm/imx/ipuv3-plane.c b/drivers/gpu/drm/imx/ipuv3-plane.c
deleted file mode 100644
index 203f247..0000000
--- a/drivers/gpu/drm/imx/ipuv3-plane.c
+++ /dev/null
@@ -1,845 +0,0 @@
-/*
- * i.MX IPUv3 DP Overlay Planes
- *
- * Copyright (C) 2013 Philipp Zabel, Pengutronix
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <drm/drmP.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_plane_helper.h>
-
-#include "video/imx-ipu-v3.h"
-#include "imx-drm.h"
-#include "ipuv3-plane.h"
-
-struct ipu_plane_state {
-	struct drm_plane_state base;
-	bool use_pre;
-};
-
-static inline struct ipu_plane_state *
-to_ipu_plane_state(struct drm_plane_state *p)
-{
-	return container_of(p, struct ipu_plane_state, base);
-}
-
-static inline struct ipu_plane *to_ipu_plane(struct drm_plane *p)
-{
-	return container_of(p, struct ipu_plane, base);
-}
-
-static const uint32_t ipu_plane_formats[] = {
-	DRM_FORMAT_ARGB1555,
-	DRM_FORMAT_XRGB1555,
-	DRM_FORMAT_ABGR1555,
-	DRM_FORMAT_XBGR1555,
-	DRM_FORMAT_RGBA5551,
-	DRM_FORMAT_BGRA5551,
-	DRM_FORMAT_ARGB4444,
-	DRM_FORMAT_ARGB8888,
-	DRM_FORMAT_XRGB8888,
-	DRM_FORMAT_ABGR8888,
-	DRM_FORMAT_XBGR8888,
-	DRM_FORMAT_RGBA8888,
-	DRM_FORMAT_RGBX8888,
-	DRM_FORMAT_BGRA8888,
-	DRM_FORMAT_BGRX8888,
-	DRM_FORMAT_UYVY,
-	DRM_FORMAT_VYUY,
-	DRM_FORMAT_YUYV,
-	DRM_FORMAT_YVYU,
-	DRM_FORMAT_YUV420,
-	DRM_FORMAT_YVU420,
-	DRM_FORMAT_YUV422,
-	DRM_FORMAT_YVU422,
-	DRM_FORMAT_YUV444,
-	DRM_FORMAT_YVU444,
-	DRM_FORMAT_NV12,
-	DRM_FORMAT_NV16,
-	DRM_FORMAT_RGB565,
-	DRM_FORMAT_RGB565_A8,
-	DRM_FORMAT_BGR565_A8,
-	DRM_FORMAT_RGB888_A8,
-	DRM_FORMAT_BGR888_A8,
-	DRM_FORMAT_RGBX8888_A8,
-	DRM_FORMAT_BGRX8888_A8,
-};
-
-static const uint64_t ipu_format_modifiers[] = {
-	DRM_FORMAT_MOD_LINEAR,
-	DRM_FORMAT_MOD_INVALID
-};
-
-static const uint64_t pre_format_modifiers[] = {
-	DRM_FORMAT_MOD_LINEAR,
-	DRM_FORMAT_MOD_VIVANTE_TILED,
-	DRM_FORMAT_MOD_VIVANTE_SUPER_TILED,
-	DRM_FORMAT_MOD_INVALID
-};
-
-int ipu_plane_irq(struct ipu_plane *ipu_plane)
-{
-	return ipu_idmac_channel_irq(ipu_plane->ipu, ipu_plane->ipu_ch,
-				     IPU_IRQ_EOF);
-}
-
-static inline unsigned long
-drm_plane_state_to_eba(struct drm_plane_state *state, int plane)
-{
-	struct drm_framebuffer *fb = state->fb;
-	struct drm_gem_cma_object *cma_obj;
-	int x = state->src.x1 >> 16;
-	int y = state->src.y1 >> 16;
-
-	cma_obj = drm_fb_cma_get_gem_obj(fb, plane);
-	BUG_ON(!cma_obj);
-
-	return cma_obj->paddr + fb->offsets[plane] + fb->pitches[plane] * y +
-	       fb->format->cpp[plane] * x;
-}
-
-static inline unsigned long
-drm_plane_state_to_ubo(struct drm_plane_state *state)
-{
-	struct drm_framebuffer *fb = state->fb;
-	struct drm_gem_cma_object *cma_obj;
-	unsigned long eba = drm_plane_state_to_eba(state, 0);
-	int x = state->src.x1 >> 16;
-	int y = state->src.y1 >> 16;
-
-	cma_obj = drm_fb_cma_get_gem_obj(fb, 1);
-	BUG_ON(!cma_obj);
-
-	x /= drm_format_horz_chroma_subsampling(fb->format->format);
-	y /= drm_format_vert_chroma_subsampling(fb->format->format);
-
-	return cma_obj->paddr + fb->offsets[1] + fb->pitches[1] * y +
-	       fb->format->cpp[1] * x - eba;
-}
-
-static inline unsigned long
-drm_plane_state_to_vbo(struct drm_plane_state *state)
-{
-	struct drm_framebuffer *fb = state->fb;
-	struct drm_gem_cma_object *cma_obj;
-	unsigned long eba = drm_plane_state_to_eba(state, 0);
-	int x = state->src.x1 >> 16;
-	int y = state->src.y1 >> 16;
-
-	cma_obj = drm_fb_cma_get_gem_obj(fb, 2);
-	BUG_ON(!cma_obj);
-
-	x /= drm_format_horz_chroma_subsampling(fb->format->format);
-	y /= drm_format_vert_chroma_subsampling(fb->format->format);
-
-	return cma_obj->paddr + fb->offsets[2] + fb->pitches[2] * y +
-	       fb->format->cpp[2] * x - eba;
-}
-
-void ipu_plane_put_resources(struct ipu_plane *ipu_plane)
-{
-	if (!IS_ERR_OR_NULL(ipu_plane->dp))
-		ipu_dp_put(ipu_plane->dp);
-	if (!IS_ERR_OR_NULL(ipu_plane->dmfc))
-		ipu_dmfc_put(ipu_plane->dmfc);
-	if (!IS_ERR_OR_NULL(ipu_plane->ipu_ch))
-		ipu_idmac_put(ipu_plane->ipu_ch);
-	if (!IS_ERR_OR_NULL(ipu_plane->alpha_ch))
-		ipu_idmac_put(ipu_plane->alpha_ch);
-}
-
-int ipu_plane_get_resources(struct ipu_plane *ipu_plane)
-{
-	int ret;
-	int alpha_ch;
-
-	ipu_plane->ipu_ch = ipu_idmac_get(ipu_plane->ipu, ipu_plane->dma);
-	if (IS_ERR(ipu_plane->ipu_ch)) {
-		ret = PTR_ERR(ipu_plane->ipu_ch);
-		DRM_ERROR("failed to get idmac channel: %d\n", ret);
-		return ret;
-	}
-
-	alpha_ch = ipu_channel_alpha_channel(ipu_plane->dma);
-	if (alpha_ch >= 0) {
-		ipu_plane->alpha_ch = ipu_idmac_get(ipu_plane->ipu, alpha_ch);
-		if (IS_ERR(ipu_plane->alpha_ch)) {
-			ret = PTR_ERR(ipu_plane->alpha_ch);
-			DRM_ERROR("failed to get alpha idmac channel %d: %d\n",
-				  alpha_ch, ret);
-			return ret;
-		}
-	}
-
-	ipu_plane->dmfc = ipu_dmfc_get(ipu_plane->ipu, ipu_plane->dma);
-	if (IS_ERR(ipu_plane->dmfc)) {
-		ret = PTR_ERR(ipu_plane->dmfc);
-		DRM_ERROR("failed to get dmfc: ret %d\n", ret);
-		goto err_out;
-	}
-
-	if (ipu_plane->dp_flow >= 0) {
-		ipu_plane->dp = ipu_dp_get(ipu_plane->ipu, ipu_plane->dp_flow);
-		if (IS_ERR(ipu_plane->dp)) {
-			ret = PTR_ERR(ipu_plane->dp);
-			DRM_ERROR("failed to get dp flow: %d\n", ret);
-			goto err_out;
-		}
-	}
-
-	return 0;
-err_out:
-	ipu_plane_put_resources(ipu_plane);
-
-	return ret;
-}
-
-static bool ipu_plane_separate_alpha(struct ipu_plane *ipu_plane)
-{
-	switch (ipu_plane->base.state->fb->format->format) {
-	case DRM_FORMAT_RGB565_A8:
-	case DRM_FORMAT_BGR565_A8:
-	case DRM_FORMAT_RGB888_A8:
-	case DRM_FORMAT_BGR888_A8:
-	case DRM_FORMAT_RGBX8888_A8:
-	case DRM_FORMAT_BGRX8888_A8:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static void ipu_plane_enable(struct ipu_plane *ipu_plane)
-{
-	if (ipu_plane->dp)
-		ipu_dp_enable(ipu_plane->ipu);
-	ipu_dmfc_enable_channel(ipu_plane->dmfc);
-	ipu_idmac_enable_channel(ipu_plane->ipu_ch);
-	if (ipu_plane_separate_alpha(ipu_plane))
-		ipu_idmac_enable_channel(ipu_plane->alpha_ch);
-	if (ipu_plane->dp)
-		ipu_dp_enable_channel(ipu_plane->dp);
-}
-
-void ipu_plane_disable(struct ipu_plane *ipu_plane, bool disable_dp_channel)
-{
-	DRM_DEBUG_KMS("[%d] %s\n", __LINE__, __func__);
-
-	ipu_idmac_wait_busy(ipu_plane->ipu_ch, 50);
-
-	if (ipu_plane->dp && disable_dp_channel)
-		ipu_dp_disable_channel(ipu_plane->dp, false);
-	ipu_idmac_disable_channel(ipu_plane->ipu_ch);
-	if (ipu_plane->alpha_ch)
-		ipu_idmac_disable_channel(ipu_plane->alpha_ch);
-	ipu_dmfc_disable_channel(ipu_plane->dmfc);
-	if (ipu_plane->dp)
-		ipu_dp_disable(ipu_plane->ipu);
-	if (ipu_prg_present(ipu_plane->ipu))
-		ipu_prg_channel_disable(ipu_plane->ipu_ch);
-}
-
-void ipu_plane_disable_deferred(struct drm_plane *plane)
-{
-	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
-
-	if (ipu_plane->disabling) {
-		ipu_plane->disabling = false;
-		ipu_plane_disable(ipu_plane, false);
-	}
-}
-EXPORT_SYMBOL_GPL(ipu_plane_disable_deferred);
-
-static void ipu_plane_destroy(struct drm_plane *plane)
-{
-	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
-
-	DRM_DEBUG_KMS("[%d] %s\n", __LINE__, __func__);
-
-	drm_plane_cleanup(plane);
-	kfree(ipu_plane);
-}
-
-static void ipu_plane_state_reset(struct drm_plane *plane)
-{
-	struct ipu_plane_state *ipu_state;
-
-	if (plane->state) {
-		ipu_state = to_ipu_plane_state(plane->state);
-		__drm_atomic_helper_plane_destroy_state(plane->state);
-		kfree(ipu_state);
-	}
-
-	ipu_state = kzalloc(sizeof(*ipu_state), GFP_KERNEL);
-
-	if (ipu_state) {
-		ipu_state->base.plane = plane;
-		ipu_state->base.rotation = DRM_MODE_ROTATE_0;
-	}
-
-	plane->state = &ipu_state->base;
-}
-
-static struct drm_plane_state *
-ipu_plane_duplicate_state(struct drm_plane *plane)
-{
-	struct ipu_plane_state *state;
-
-	if (WARN_ON(!plane->state))
-		return NULL;
-
-	state = kmalloc(sizeof(*state), GFP_KERNEL);
-	if (state)
-		__drm_atomic_helper_plane_duplicate_state(plane, &state->base);
-
-	return &state->base;
-}
-
-static void ipu_plane_destroy_state(struct drm_plane *plane,
-				    struct drm_plane_state *state)
-{
-	struct ipu_plane_state *ipu_state = to_ipu_plane_state(state);
-
-	__drm_atomic_helper_plane_destroy_state(state);
-	kfree(ipu_state);
-}
-
-static bool ipu_plane_format_mod_supported(struct drm_plane *plane,
-					   uint32_t format, uint64_t modifier)
-{
-	struct ipu_soc *ipu = to_ipu_plane(plane)->ipu;
-
-	/* linear is supported for all planes and formats */
-	if (modifier == DRM_FORMAT_MOD_LINEAR)
-		return true;
-
-	/* without a PRG there are no supported modifiers */
-	if (!ipu_prg_present(ipu))
-		return false;
-
-	return ipu_prg_format_supported(ipu, format, modifier);
-}
-
-static const struct drm_plane_funcs ipu_plane_funcs = {
-	.update_plane	= drm_atomic_helper_update_plane,
-	.disable_plane	= drm_atomic_helper_disable_plane,
-	.destroy	= ipu_plane_destroy,
-	.reset		= ipu_plane_state_reset,
-	.atomic_duplicate_state	= ipu_plane_duplicate_state,
-	.atomic_destroy_state	= ipu_plane_destroy_state,
-	.format_mod_supported = ipu_plane_format_mod_supported,
-};
-
-static int ipu_plane_atomic_check(struct drm_plane *plane,
-				  struct drm_plane_state *state)
-{
-	struct drm_plane_state *old_state = plane->state;
-	struct drm_crtc_state *crtc_state;
-	struct device *dev = plane->dev->dev;
-	struct drm_framebuffer *fb = state->fb;
-	struct drm_framebuffer *old_fb = old_state->fb;
-	unsigned long eba, ubo, vbo, old_ubo, old_vbo, alpha_eba;
-	bool can_position = (plane->type == DRM_PLANE_TYPE_OVERLAY);
-	int hsub, vsub;
-	int ret;
-
-	/* Ok to disable */
-	if (!fb)
-		return 0;
-
-	if (!state->crtc)
-		return -EINVAL;
-
-	crtc_state =
-		drm_atomic_get_existing_crtc_state(state->state, state->crtc);
-	if (WARN_ON(!crtc_state))
-		return -EINVAL;
-
-	ret = drm_atomic_helper_check_plane_state(state, crtc_state,
-						  DRM_PLANE_HELPER_NO_SCALING,
-						  DRM_PLANE_HELPER_NO_SCALING,
-						  can_position, true);
-	if (ret)
-		return ret;
-
-	/* CRTC should be enabled */
-	if (!crtc_state->enable)
-		return -EINVAL;
-
-	switch (plane->type) {
-	case DRM_PLANE_TYPE_PRIMARY:
-		/* full plane minimum width is 13 pixels */
-		if (drm_rect_width(&state->dst) < 13)
-			return -EINVAL;
-		break;
-	case DRM_PLANE_TYPE_OVERLAY:
-		break;
-	default:
-		dev_warn(dev, "Unsupported plane type %d\n", plane->type);
-		return -EINVAL;
-	}
-
-	if (drm_rect_height(&state->dst) < 2)
-		return -EINVAL;
-
-	/*
-	 * We support resizing active plane or changing its format by
-	 * forcing CRTC mode change in plane's ->atomic_check callback
-	 * and disabling all affected active planes in CRTC's ->atomic_disable
-	 * callback.  The planes will be reenabled in plane's ->atomic_update
-	 * callback.
-	 */
-	if (old_fb &&
-	    (drm_rect_width(&state->dst) != drm_rect_width(&old_state->dst) ||
-	     drm_rect_height(&state->dst) != drm_rect_height(&old_state->dst) ||
-	     fb->format != old_fb->format))
-		crtc_state->mode_changed = true;
-
-	eba = drm_plane_state_to_eba(state, 0);
-
-	if (eba & 0x7)
-		return -EINVAL;
-
-	if (fb->pitches[0] < 1 || fb->pitches[0] > 16384)
-		return -EINVAL;
-
-	if (old_fb && fb->pitches[0] != old_fb->pitches[0])
-		crtc_state->mode_changed = true;
-
-	switch (fb->format->format) {
-	case DRM_FORMAT_YUV420:
-	case DRM_FORMAT_YVU420:
-	case DRM_FORMAT_YUV422:
-	case DRM_FORMAT_YVU422:
-	case DRM_FORMAT_YUV444:
-	case DRM_FORMAT_YVU444:
-		/*
-		 * Multiplanar formats have to meet the following restrictions:
-		 * - The (up to) three plane addresses are EBA, EBA+UBO, EBA+VBO
-		 * - EBA, UBO and VBO are a multiple of 8
-		 * - UBO and VBO are unsigned and not larger than 0xfffff8
-		 * - Only EBA may be changed while scanout is active
-		 * - The strides of U and V planes must be identical.
-		 */
-		vbo = drm_plane_state_to_vbo(state);
-
-		if (vbo & 0x7 || vbo > 0xfffff8)
-			return -EINVAL;
-
-		if (old_fb && (fb->format == old_fb->format)) {
-			old_vbo = drm_plane_state_to_vbo(old_state);
-			if (vbo != old_vbo)
-				crtc_state->mode_changed = true;
-		}
-
-		if (fb->pitches[1] != fb->pitches[2])
-			return -EINVAL;
-
-		/* fall-through */
-	case DRM_FORMAT_NV12:
-	case DRM_FORMAT_NV16:
-		ubo = drm_plane_state_to_ubo(state);
-
-		if (ubo & 0x7 || ubo > 0xfffff8)
-			return -EINVAL;
-
-		if (old_fb && (fb->format == old_fb->format)) {
-			old_ubo = drm_plane_state_to_ubo(old_state);
-			if (ubo != old_ubo)
-				crtc_state->mode_changed = true;
-		}
-
-		if (fb->pitches[1] < 1 || fb->pitches[1] > 16384)
-			return -EINVAL;
-
-		if (old_fb && old_fb->pitches[1] != fb->pitches[1])
-			crtc_state->mode_changed = true;
-
-		/*
-		 * The x/y offsets must be even in case of horizontal/vertical
-		 * chroma subsampling.
-		 */
-		hsub = drm_format_horz_chroma_subsampling(fb->format->format);
-		vsub = drm_format_vert_chroma_subsampling(fb->format->format);
-		if (((state->src.x1 >> 16) & (hsub - 1)) ||
-		    ((state->src.y1 >> 16) & (vsub - 1)))
-			return -EINVAL;
-		break;
-	case DRM_FORMAT_RGB565_A8:
-	case DRM_FORMAT_BGR565_A8:
-	case DRM_FORMAT_RGB888_A8:
-	case DRM_FORMAT_BGR888_A8:
-	case DRM_FORMAT_RGBX8888_A8:
-	case DRM_FORMAT_BGRX8888_A8:
-		alpha_eba = drm_plane_state_to_eba(state, 1);
-		if (alpha_eba & 0x7)
-			return -EINVAL;
-
-		if (fb->pitches[1] < 1 || fb->pitches[1] > 16384)
-			return -EINVAL;
-
-		if (old_fb && old_fb->pitches[1] != fb->pitches[1])
-			crtc_state->mode_changed = true;
-		break;
-	}
-
-	return 0;
-}
-
-static void ipu_plane_atomic_disable(struct drm_plane *plane,
-				     struct drm_plane_state *old_state)
-{
-	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
-
-	if (ipu_plane->dp)
-		ipu_dp_disable_channel(ipu_plane->dp, true);
-	ipu_plane->disabling = true;
-}
-
-static int ipu_chan_assign_axi_id(int ipu_chan)
-{
-	switch (ipu_chan) {
-	case IPUV3_CHANNEL_MEM_BG_SYNC:
-		return 1;
-	case IPUV3_CHANNEL_MEM_FG_SYNC:
-		return 2;
-	case IPUV3_CHANNEL_MEM_DC_SYNC:
-		return 3;
-	default:
-		return 0;
-	}
-}
-
-static void ipu_calculate_bursts(u32 width, u32 cpp, u32 stride,
-				 u8 *burstsize, u8 *num_bursts)
-{
-	const unsigned int width_bytes = width * cpp;
-	unsigned int npb, bursts;
-
-	/* Maximum number of pixels per burst without overshooting stride */
-	for (npb = 64 / cpp; npb > 0; --npb) {
-		if (round_up(width_bytes, npb * cpp) <= stride)
-			break;
-	}
-	*burstsize = npb;
-
-	/* Maximum number of consecutive bursts without overshooting stride */
-	for (bursts = 8; bursts > 1; bursts /= 2) {
-		if (round_up(width_bytes, npb * cpp * bursts) <= stride)
-			break;
-	}
-	*num_bursts = bursts;
-}
-
-static void ipu_plane_atomic_update(struct drm_plane *plane,
-				    struct drm_plane_state *old_state)
-{
-	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
-	struct drm_plane_state *state = plane->state;
-	struct ipu_plane_state *ipu_state = to_ipu_plane_state(state);
-	struct drm_crtc_state *crtc_state = state->crtc->state;
-	struct drm_framebuffer *fb = state->fb;
-	struct drm_rect *dst = &state->dst;
-	unsigned long eba, ubo, vbo;
-	unsigned long alpha_eba = 0;
-	enum ipu_color_space ics;
-	unsigned int axi_id = 0;
-	const struct drm_format_info *info;
-	u8 burstsize, num_bursts;
-	u32 width, height;
-	int active;
-
-	if (ipu_plane->dp_flow == IPU_DP_FLOW_SYNC_FG)
-		ipu_dp_set_window_pos(ipu_plane->dp, dst->x1, dst->y1);
-
-	eba = drm_plane_state_to_eba(state, 0);
-
-	/*
-	 * Configure PRG channel and attached PRE, this changes the EBA to an
-	 * internal SRAM location.
-	 */
-	if (ipu_state->use_pre) {
-		axi_id = ipu_chan_assign_axi_id(ipu_plane->dma);
-		ipu_prg_channel_configure(ipu_plane->ipu_ch, axi_id,
-					  drm_rect_width(&state->src) >> 16,
-					  drm_rect_height(&state->src) >> 16,
-					  fb->pitches[0], fb->format->format,
-					  fb->modifier, &eba);
-	}
-
-	if (old_state->fb && !drm_atomic_crtc_needs_modeset(crtc_state)) {
-		/* nothing to do if PRE is used */
-		if (ipu_state->use_pre)
-			return;
-		active = ipu_idmac_get_current_buffer(ipu_plane->ipu_ch);
-		ipu_cpmem_set_buffer(ipu_plane->ipu_ch, !active, eba);
-		ipu_idmac_select_buffer(ipu_plane->ipu_ch, !active);
-		if (ipu_plane_separate_alpha(ipu_plane)) {
-			active = ipu_idmac_get_current_buffer(ipu_plane->alpha_ch);
-			ipu_cpmem_set_buffer(ipu_plane->alpha_ch, !active,
-					     alpha_eba);
-			ipu_idmac_select_buffer(ipu_plane->alpha_ch, !active);
-		}
-		return;
-	}
-
-	ics = ipu_drm_fourcc_to_colorspace(fb->format->format);
-	switch (ipu_plane->dp_flow) {
-	case IPU_DP_FLOW_SYNC_BG:
-		ipu_dp_setup_channel(ipu_plane->dp, ics, IPUV3_COLORSPACE_RGB);
-		ipu_dp_set_global_alpha(ipu_plane->dp, true, 0, true);
-		break;
-	case IPU_DP_FLOW_SYNC_FG:
-		ipu_dp_setup_channel(ipu_plane->dp, ics,
-					IPUV3_COLORSPACE_UNKNOWN);
-		/* Enable local alpha on partial plane */
-		switch (fb->format->format) {
-		case DRM_FORMAT_ARGB1555:
-		case DRM_FORMAT_ABGR1555:
-		case DRM_FORMAT_RGBA5551:
-		case DRM_FORMAT_BGRA5551:
-		case DRM_FORMAT_ARGB4444:
-		case DRM_FORMAT_ARGB8888:
-		case DRM_FORMAT_ABGR8888:
-		case DRM_FORMAT_RGBA8888:
-		case DRM_FORMAT_BGRA8888:
-		case DRM_FORMAT_RGB565_A8:
-		case DRM_FORMAT_BGR565_A8:
-		case DRM_FORMAT_RGB888_A8:
-		case DRM_FORMAT_BGR888_A8:
-		case DRM_FORMAT_RGBX8888_A8:
-		case DRM_FORMAT_BGRX8888_A8:
-			ipu_dp_set_global_alpha(ipu_plane->dp, false, 0, false);
-			break;
-		default:
-			ipu_dp_set_global_alpha(ipu_plane->dp, true, 0, true);
-			break;
-		}
-	}
-
-	ipu_dmfc_config_wait4eot(ipu_plane->dmfc, drm_rect_width(dst));
-
-	width = drm_rect_width(&state->src) >> 16;
-	height = drm_rect_height(&state->src) >> 16;
-	info = drm_format_info(fb->format->format);
-	ipu_calculate_bursts(width, info->cpp[0], fb->pitches[0],
-			     &burstsize, &num_bursts);
-
-	ipu_cpmem_zero(ipu_plane->ipu_ch);
-	ipu_cpmem_set_resolution(ipu_plane->ipu_ch, width, height);
-	ipu_cpmem_set_fmt(ipu_plane->ipu_ch, fb->format->format);
-	ipu_cpmem_set_burstsize(ipu_plane->ipu_ch, burstsize);
-	ipu_cpmem_set_high_priority(ipu_plane->ipu_ch);
-	ipu_idmac_set_double_buffer(ipu_plane->ipu_ch, 1);
-	ipu_cpmem_set_stride(ipu_plane->ipu_ch, fb->pitches[0]);
-	ipu_cpmem_set_axi_id(ipu_plane->ipu_ch, axi_id);
-
-	switch (fb->format->format) {
-	case DRM_FORMAT_YUV420:
-	case DRM_FORMAT_YVU420:
-	case DRM_FORMAT_YUV422:
-	case DRM_FORMAT_YVU422:
-	case DRM_FORMAT_YUV444:
-	case DRM_FORMAT_YVU444:
-		ubo = drm_plane_state_to_ubo(state);
-		vbo = drm_plane_state_to_vbo(state);
-		if (fb->format->format == DRM_FORMAT_YVU420 ||
-		    fb->format->format == DRM_FORMAT_YVU422 ||
-		    fb->format->format == DRM_FORMAT_YVU444)
-			swap(ubo, vbo);
-
-		ipu_cpmem_set_yuv_planar_full(ipu_plane->ipu_ch,
-					      fb->pitches[1], ubo, vbo);
-
-		dev_dbg(ipu_plane->base.dev->dev,
-			"phy = %lu %lu %lu, x = %d, y = %d", eba, ubo, vbo,
-			state->src.x1 >> 16, state->src.y1 >> 16);
-		break;
-	case DRM_FORMAT_NV12:
-	case DRM_FORMAT_NV16:
-		ubo = drm_plane_state_to_ubo(state);
-
-		ipu_cpmem_set_yuv_planar_full(ipu_plane->ipu_ch,
-					      fb->pitches[1], ubo, ubo);
-
-		dev_dbg(ipu_plane->base.dev->dev,
-			"phy = %lu %lu, x = %d, y = %d", eba, ubo,
-			state->src.x1 >> 16, state->src.y1 >> 16);
-		break;
-	case DRM_FORMAT_RGB565_A8:
-	case DRM_FORMAT_BGR565_A8:
-	case DRM_FORMAT_RGB888_A8:
-	case DRM_FORMAT_BGR888_A8:
-	case DRM_FORMAT_RGBX8888_A8:
-	case DRM_FORMAT_BGRX8888_A8:
-		alpha_eba = drm_plane_state_to_eba(state, 1);
-		num_bursts = 0;
-
-		dev_dbg(ipu_plane->base.dev->dev, "phys = %lu %lu, x = %d, y = %d",
-			eba, alpha_eba, state->src.x1 >> 16, state->src.y1 >> 16);
-
-		ipu_cpmem_set_burstsize(ipu_plane->ipu_ch, 16);
-
-		ipu_cpmem_zero(ipu_plane->alpha_ch);
-		ipu_cpmem_set_resolution(ipu_plane->alpha_ch,
-					 drm_rect_width(&state->src) >> 16,
-					 drm_rect_height(&state->src) >> 16);
-		ipu_cpmem_set_format_passthrough(ipu_plane->alpha_ch, 8);
-		ipu_cpmem_set_high_priority(ipu_plane->alpha_ch);
-		ipu_idmac_set_double_buffer(ipu_plane->alpha_ch, 1);
-		ipu_cpmem_set_stride(ipu_plane->alpha_ch, fb->pitches[1]);
-		ipu_cpmem_set_burstsize(ipu_plane->alpha_ch, 16);
-		ipu_cpmem_set_buffer(ipu_plane->alpha_ch, 0, alpha_eba);
-		ipu_cpmem_set_buffer(ipu_plane->alpha_ch, 1, alpha_eba);
-		break;
-	default:
-		dev_dbg(ipu_plane->base.dev->dev, "phys = %lu, x = %d, y = %d",
-			eba, state->src.x1 >> 16, state->src.y1 >> 16);
-		break;
-	}
-	ipu_cpmem_set_buffer(ipu_plane->ipu_ch, 0, eba);
-	ipu_cpmem_set_buffer(ipu_plane->ipu_ch, 1, eba);
-	ipu_idmac_lock_enable(ipu_plane->ipu_ch, num_bursts);
-	ipu_plane_enable(ipu_plane);
-}
-
-static const struct drm_plane_helper_funcs ipu_plane_helper_funcs = {
-	.prepare_fb = drm_gem_fb_prepare_fb,
-	.atomic_check = ipu_plane_atomic_check,
-	.atomic_disable = ipu_plane_atomic_disable,
-	.atomic_update = ipu_plane_atomic_update,
-};
-
-int ipu_planes_assign_pre(struct drm_device *dev,
-			  struct drm_atomic_state *state)
-{
-	struct drm_crtc_state *old_crtc_state, *crtc_state;
-	struct drm_plane_state *plane_state;
-	struct ipu_plane_state *ipu_state;
-	struct ipu_plane *ipu_plane;
-	struct drm_plane *plane;
-	struct drm_crtc *crtc;
-	int available_pres = ipu_prg_max_active_channels();
-	int ret, i;
-
-	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, crtc_state, i) {
-		ret = drm_atomic_add_affected_planes(state, crtc);
-		if (ret)
-			return ret;
-	}
-
-	/*
-	 * We are going over the planes in 2 passes: first we assign PREs to
-	 * planes with a tiling modifier, which need the PREs to resolve into
-	 * linear. Any failure to assign a PRE there is fatal. In the second
-	 * pass we try to assign PREs to linear FBs, to improve memory access
-	 * patterns for them. Failure at this point is non-fatal, as we can
-	 * scan out linear FBs without a PRE.
-	 */
-	for_each_new_plane_in_state(state, plane, plane_state, i) {
-		ipu_state = to_ipu_plane_state(plane_state);
-		ipu_plane = to_ipu_plane(plane);
-
-		if (!plane_state->fb) {
-			ipu_state->use_pre = false;
-			continue;
-		}
-
-		if (!(plane_state->fb->flags & DRM_MODE_FB_MODIFIERS) ||
-		    plane_state->fb->modifier == DRM_FORMAT_MOD_LINEAR)
-			continue;
-
-		if (!ipu_prg_present(ipu_plane->ipu) || !available_pres)
-			return -EINVAL;
-
-		if (!ipu_prg_format_supported(ipu_plane->ipu,
-					      plane_state->fb->format->format,
-					      plane_state->fb->modifier))
-			return -EINVAL;
-
-		ipu_state->use_pre = true;
-		available_pres--;
-	}
-
-	for_each_new_plane_in_state(state, plane, plane_state, i) {
-		ipu_state = to_ipu_plane_state(plane_state);
-		ipu_plane = to_ipu_plane(plane);
-
-		if (!plane_state->fb) {
-			ipu_state->use_pre = false;
-			continue;
-		}
-
-		if ((plane_state->fb->flags & DRM_MODE_FB_MODIFIERS) &&
-		    plane_state->fb->modifier != DRM_FORMAT_MOD_LINEAR)
-			continue;
-
-		/* make sure that modifier is initialized */
-		plane_state->fb->modifier = DRM_FORMAT_MOD_LINEAR;
-
-		if (ipu_prg_present(ipu_plane->ipu) && available_pres &&
-		    ipu_prg_format_supported(ipu_plane->ipu,
-					     plane_state->fb->format->format,
-					     plane_state->fb->modifier)) {
-			ipu_state->use_pre = true;
-			available_pres--;
-		} else {
-			ipu_state->use_pre = false;
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ipu_planes_assign_pre);
-
-struct ipu_plane *ipu_plane_init(struct drm_device *dev, struct ipu_soc *ipu,
-				 int dma, int dp, unsigned int possible_crtcs,
-				 enum drm_plane_type type)
-{
-	struct ipu_plane *ipu_plane;
-	const uint64_t *modifiers = ipu_format_modifiers;
-	int ret;
-
-	DRM_DEBUG_KMS("channel %d, dp flow %d, possible_crtcs=0x%x\n",
-		      dma, dp, possible_crtcs);
-
-	ipu_plane = kzalloc(sizeof(*ipu_plane), GFP_KERNEL);
-	if (!ipu_plane) {
-		DRM_ERROR("failed to allocate plane\n");
-		return ERR_PTR(-ENOMEM);
-	}
-
-	ipu_plane->ipu = ipu;
-	ipu_plane->dma = dma;
-	ipu_plane->dp_flow = dp;
-
-	if (ipu_prg_present(ipu))
-		modifiers = pre_format_modifiers;
-
-	ret = drm_universal_plane_init(dev, &ipu_plane->base, possible_crtcs,
-				       &ipu_plane_funcs, ipu_plane_formats,
-				       ARRAY_SIZE(ipu_plane_formats),
-				       modifiers, type, NULL);
-	if (ret) {
-		DRM_ERROR("failed to initialize plane\n");
-		kfree(ipu_plane);
-		return ERR_PTR(ret);
-	}
-
-	drm_plane_helper_add(&ipu_plane->base, &ipu_plane_helper_funcs);
-
-	return ipu_plane;
-}
diff --git a/drivers/gpu/drm/imx/ipuv3-plane.h b/drivers/gpu/drm/imx/ipuv3-plane.h
deleted file mode 100644
index e563ea1..0000000
--- a/drivers/gpu/drm/imx/ipuv3-plane.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __IPUV3_PLANE_H__
-#define __IPUV3_PLANE_H__
-
-#include <drm/drm_crtc.h> /* drm_plane */
-
-struct drm_plane;
-struct drm_device;
-struct ipu_soc;
-struct drm_crtc;
-struct drm_framebuffer;
-
-struct ipuv3_channel;
-struct dmfc_channel;
-struct ipu_dp;
-
-struct ipu_plane {
-	struct drm_plane	base;
-
-	struct ipu_soc		*ipu;
-	struct ipuv3_channel	*ipu_ch;
-	struct ipuv3_channel	*alpha_ch;
-	struct dmfc_channel	*dmfc;
-	struct ipu_dp		*dp;
-
-	int			dma;
-	int			dp_flow;
-
-	bool			disabling;
-};
-
-struct ipu_plane *ipu_plane_init(struct drm_device *dev, struct ipu_soc *ipu,
-				 int dma, int dp, unsigned int possible_crtcs,
-				 enum drm_plane_type type);
-
-/* Init IDMAC, DMFC, DP */
-int ipu_plane_mode_set(struct ipu_plane *plane, struct drm_crtc *crtc,
-		       struct drm_display_mode *mode,
-		       struct drm_framebuffer *fb, int crtc_x, int crtc_y,
-		       unsigned int crtc_w, unsigned int crtc_h,
-		       uint32_t src_x, uint32_t src_y, uint32_t src_w,
-		       uint32_t src_h, bool interlaced);
-
-int ipu_plane_get_resources(struct ipu_plane *plane);
-void ipu_plane_put_resources(struct ipu_plane *plane);
-
-int ipu_plane_irq(struct ipu_plane *plane);
-
-void ipu_plane_disable(struct ipu_plane *ipu_plane, bool disable_dp_channel);
-void ipu_plane_disable_deferred(struct drm_plane *plane);
-
-#endif
diff --git a/drivers/gpu/drm/imx/ipuv3/Kconfig b/drivers/gpu/drm/imx/ipuv3/Kconfig
new file mode 100644
index 0000000..718da37
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/Kconfig
@@ -0,0 +1,6 @@
+config DRM_IMX_IPUV3
+	tristate
+	depends on DRM_IMX
+	depends on IMX_IPUV3_CORE
+	default y if DRM_IMX=y
+	default m if DRM_IMX=m
diff --git a/drivers/gpu/drm/imx/ipuv3/Makefile b/drivers/gpu/drm/imx/ipuv3/Makefile
new file mode 100644
index 0000000..e8ccced
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/Makefile
@@ -0,0 +1,4 @@
+ccflags-y += -Idrivers/gpu/drm/imx
+
+imx-ipuv3-crtc-objs := ipuv3-crtc.o ipuv3-plane.o ipuv3-kms.o
+obj-$(CONFIG_DRM_IMX_IPUV3) += imx-ipuv3-crtc.o
diff --git a/drivers/gpu/drm/imx/ipuv3/ipuv3-crtc.c b/drivers/gpu/drm/imx/ipuv3/ipuv3-crtc.c
new file mode 100644
index 0000000..cb0bfaf
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/ipuv3-crtc.c
@@ -0,0 +1,493 @@
+/*
+ * i.MX IPUv3 Graphics driver
+ *
+ * Copyright (C) 2011 Sascha Hauer, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/component.h>
+#include <linux/module.h>
+#include <linux/export.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+
+#include <video/imx-ipu-v3.h>
+#include "imx-drm.h"
+#include "ipuv3-kms.h"
+#include "ipuv3-plane.h"
+
+#define DRIVER_DESC		"i.MX IPUv3 Graphics"
+
+struct ipu_crtc {
+	struct device		*dev;
+	struct drm_crtc		base;
+	struct imx_drm_crtc	*imx_crtc;
+
+	/* plane[0] is the full plane, plane[1] is the partial plane */
+	struct ipu_plane	*plane[2];
+
+	struct ipu_dc		*dc;
+	struct ipu_di		*di;
+	int			irq;
+};
+
+static inline struct ipu_crtc *to_ipu_crtc(struct drm_crtc *crtc)
+{
+	return container_of(crtc, struct ipu_crtc, base);
+}
+
+static void ipu_crtc_atomic_enable(struct drm_crtc *crtc,
+				   struct drm_crtc_state *old_state)
+{
+	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
+	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
+
+	ipu_prg_enable(ipu);
+	ipu_dc_enable(ipu);
+	ipu_dc_enable_channel(ipu_crtc->dc);
+	ipu_di_enable(ipu_crtc->di);
+}
+
+static void ipu_crtc_disable_planes(struct ipu_crtc *ipu_crtc,
+				    struct drm_crtc_state *old_crtc_state)
+{
+	bool disable_partial = false;
+	bool disable_full = false;
+	struct drm_plane *plane;
+
+	drm_atomic_crtc_state_for_each_plane(plane, old_crtc_state) {
+		if (plane == &ipu_crtc->plane[0]->base)
+			disable_full = true;
+		if (&ipu_crtc->plane[1] && plane == &ipu_crtc->plane[1]->base)
+			disable_partial = true;
+	}
+
+	if (disable_partial)
+		ipu_plane_disable(ipu_crtc->plane[1], true);
+	if (disable_full)
+		ipu_plane_disable(ipu_crtc->plane[0], false);
+}
+
+static void ipu_crtc_atomic_disable(struct drm_crtc *crtc,
+				    struct drm_crtc_state *old_crtc_state)
+{
+	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
+	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
+
+	ipu_dc_disable_channel(ipu_crtc->dc);
+	ipu_di_disable(ipu_crtc->di);
+	/*
+	 * Planes must be disabled before DC clock is removed, as otherwise the
+	 * attached IDMACs will be left in undefined state, possibly hanging
+	 * the IPU or even system.
+	 */
+	ipu_crtc_disable_planes(ipu_crtc, old_crtc_state);
+	ipu_dc_disable(ipu);
+	ipu_prg_disable(ipu);
+
+	spin_lock_irq(&crtc->dev->event_lock);
+	if (crtc->state->event) {
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		crtc->state->event = NULL;
+	}
+	spin_unlock_irq(&crtc->dev->event_lock);
+
+	drm_crtc_vblank_off(crtc);
+}
+
+static void ipu_crtc_reset(struct drm_crtc *crtc)
+{
+	struct imx_crtc_state *state;
+
+	if (crtc->state) {
+		if (crtc->state->mode_blob)
+			drm_property_blob_put(crtc->state->mode_blob);
+
+		state = to_imx_crtc_state(crtc->state);
+		memset(state, 0, sizeof(*state));
+	} else {
+		state = kzalloc(sizeof(*state), GFP_KERNEL);
+		if (!state)
+			return;
+		crtc->state = &state->base;
+	}
+
+	state->base.crtc = crtc;
+}
+
+static struct drm_crtc_state *ipu_crtc_duplicate_state(struct drm_crtc *crtc)
+{
+	struct imx_crtc_state *state;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);
+
+	WARN_ON(state->base.crtc != crtc);
+	state->base.crtc = crtc;
+
+	return &state->base;
+}
+
+static void ipu_crtc_destroy_state(struct drm_crtc *crtc,
+				struct drm_crtc_state *state)
+{
+	__drm_atomic_helper_crtc_destroy_state(state);
+	kfree(to_imx_crtc_state(state));
+}
+
+static int ipu_enable_vblank(struct drm_crtc *crtc)
+{
+	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
+
+	enable_irq(ipu_crtc->irq);
+
+	return 0;
+}
+
+static void ipu_disable_vblank(struct drm_crtc *crtc)
+{
+	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
+
+	disable_irq_nosync(ipu_crtc->irq);
+}
+
+static const struct drm_crtc_funcs ipu_crtc_funcs = {
+	.set_config = drm_atomic_helper_set_config,
+	.destroy = drm_crtc_cleanup,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = ipu_crtc_reset,
+	.atomic_duplicate_state = ipu_crtc_duplicate_state,
+	.atomic_destroy_state = ipu_crtc_destroy_state,
+	.enable_vblank = ipu_enable_vblank,
+	.disable_vblank = ipu_disable_vblank,
+};
+
+static irqreturn_t ipu_irq_handler(int irq, void *dev_id)
+{
+	struct ipu_crtc *ipu_crtc = dev_id;
+
+	drm_crtc_handle_vblank(&ipu_crtc->base);
+
+	return IRQ_HANDLED;
+}
+
+static bool ipu_crtc_mode_fixup(struct drm_crtc *crtc,
+				  const struct drm_display_mode *mode,
+				  struct drm_display_mode *adjusted_mode)
+{
+	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
+	struct videomode vm;
+	int ret;
+
+	drm_display_mode_to_videomode(adjusted_mode, &vm);
+
+	ret = ipu_di_adjust_videomode(ipu_crtc->di, &vm);
+	if (ret)
+		return false;
+
+	if ((vm.vsync_len == 0) || (vm.hsync_len == 0))
+		return false;
+
+	drm_display_mode_from_videomode(&vm, adjusted_mode);
+
+	return true;
+}
+
+static int ipu_crtc_atomic_check(struct drm_crtc *crtc,
+				 struct drm_crtc_state *state)
+{
+	u32 primary_plane_mask = 1 << drm_plane_index(crtc->primary);
+
+	if (state->active && (primary_plane_mask & state->plane_mask) == 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void ipu_crtc_atomic_begin(struct drm_crtc *crtc,
+				  struct drm_crtc_state *old_crtc_state)
+{
+	drm_crtc_vblank_on(crtc);
+}
+
+static void ipu_crtc_atomic_flush(struct drm_crtc *crtc,
+				  struct drm_crtc_state *old_crtc_state)
+{
+	spin_lock_irq(&crtc->dev->event_lock);
+	if (crtc->state->event) {
+		WARN_ON(drm_crtc_vblank_get(crtc));
+		drm_crtc_arm_vblank_event(crtc, crtc->state->event);
+		crtc->state->event = NULL;
+	}
+	spin_unlock_irq(&crtc->dev->event_lock);
+}
+
+static void ipu_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	struct drm_encoder *encoder;
+	struct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);
+	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	struct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc->state);
+	struct ipu_di_signal_cfg sig_cfg = {};
+	unsigned long encoder_types = 0;
+
+	dev_dbg(ipu_crtc->dev, "%s: mode->hdisplay: %d\n", __func__,
+			mode->hdisplay);
+	dev_dbg(ipu_crtc->dev, "%s: mode->vdisplay: %d\n", __func__,
+			mode->vdisplay);
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (encoder->crtc == crtc)
+			encoder_types |= BIT(encoder->encoder_type);
+	}
+
+	dev_dbg(ipu_crtc->dev, "%s: attached to encoder types 0x%lx\n",
+		__func__, encoder_types);
+
+	/*
+	 * If we have DAC or LDB, then we need the IPU DI clock to be
+	 * the same as the LDB DI clock. For TVDAC, derive the IPU DI
+	 * clock from 27 MHz TVE_DI clock, but allow to divide it.
+	 */
+	if (encoder_types & (BIT(DRM_MODE_ENCODER_DAC) |
+			     BIT(DRM_MODE_ENCODER_LVDS)))
+		sig_cfg.clkflags = IPU_DI_CLKMODE_SYNC | IPU_DI_CLKMODE_EXT;
+	else if (encoder_types & BIT(DRM_MODE_ENCODER_TVDAC))
+		sig_cfg.clkflags = IPU_DI_CLKMODE_EXT;
+	else
+		sig_cfg.clkflags = 0;
+
+	sig_cfg.enable_pol = !(imx_crtc_state->bus_flags & DRM_BUS_FLAG_DE_LOW);
+	/* Default to driving pixel data on negative clock edges */
+	sig_cfg.clk_pol = !!(imx_crtc_state->bus_flags &
+			     DRM_BUS_FLAG_PIXDATA_POSEDGE);
+	sig_cfg.bus_format = imx_crtc_state->bus_format;
+	sig_cfg.v_to_h_sync = 0;
+	sig_cfg.hsync_pin = imx_crtc_state->di_hsync_pin;
+	sig_cfg.vsync_pin = imx_crtc_state->di_vsync_pin;
+
+	drm_display_mode_to_videomode(mode, &sig_cfg.mode);
+
+	ipu_dc_init_sync(ipu_crtc->dc, ipu_crtc->di,
+			 mode->flags & DRM_MODE_FLAG_INTERLACE,
+			 imx_crtc_state->bus_format, mode->hdisplay);
+	ipu_di_init_sync_panel(ipu_crtc->di, &sig_cfg);
+}
+
+static const struct drm_crtc_helper_funcs ipu_helper_funcs = {
+	.mode_fixup = ipu_crtc_mode_fixup,
+	.mode_set_nofb = ipu_crtc_mode_set_nofb,
+	.atomic_check = ipu_crtc_atomic_check,
+	.atomic_begin = ipu_crtc_atomic_begin,
+	.atomic_flush = ipu_crtc_atomic_flush,
+	.atomic_disable = ipu_crtc_atomic_disable,
+	.atomic_enable = ipu_crtc_atomic_enable,
+};
+
+static void ipu_put_resources(struct ipu_crtc *ipu_crtc)
+{
+	if (!IS_ERR_OR_NULL(ipu_crtc->dc))
+		ipu_dc_put(ipu_crtc->dc);
+	if (!IS_ERR_OR_NULL(ipu_crtc->di))
+		ipu_di_put(ipu_crtc->di);
+}
+
+static int ipu_get_resources(struct ipu_crtc *ipu_crtc,
+		struct ipu_client_platformdata *pdata)
+{
+	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
+	int ret;
+
+	ipu_crtc->dc = ipu_dc_get(ipu, pdata->dc);
+	if (IS_ERR(ipu_crtc->dc)) {
+		ret = PTR_ERR(ipu_crtc->dc);
+		goto err_out;
+	}
+
+	ipu_crtc->di = ipu_di_get(ipu, pdata->di);
+	if (IS_ERR(ipu_crtc->di)) {
+		ret = PTR_ERR(ipu_crtc->di);
+		goto err_out;
+	}
+
+	return 0;
+err_out:
+	ipu_put_resources(ipu_crtc);
+
+	return ret;
+}
+
+static int ipu_crtc_init(struct ipu_crtc *ipu_crtc,
+	struct ipu_client_platformdata *pdata, struct drm_device *drm)
+{
+	struct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);
+	struct drm_crtc *crtc = &ipu_crtc->base;
+	int dp = -EINVAL;
+	int ret;
+
+	ret = ipu_get_resources(ipu_crtc, pdata);
+	if (ret) {
+		dev_err(ipu_crtc->dev, "getting resources failed with %d.\n",
+				ret);
+		return ret;
+	}
+
+	if (pdata->dp >= 0)
+		dp = IPU_DP_FLOW_SYNC_BG;
+	ipu_crtc->plane[0] = ipu_plane_init(drm, ipu, pdata->dma[0], dp, 0,
+					    DRM_PLANE_TYPE_PRIMARY);
+	if (IS_ERR(ipu_crtc->plane[0])) {
+		ret = PTR_ERR(ipu_crtc->plane[0]);
+		goto err_put_resources;
+	}
+
+	crtc->port = pdata->of_node;
+	drm_crtc_helper_add(crtc, &ipu_helper_funcs);
+	drm_crtc_init_with_planes(drm, crtc, &ipu_crtc->plane[0]->base, NULL,
+				  &ipu_crtc_funcs, NULL);
+
+	ret = ipu_plane_get_resources(ipu_crtc->plane[0]);
+	if (ret) {
+		dev_err(ipu_crtc->dev, "getting plane 0 resources failed with %d.\n",
+			ret);
+		goto err_put_resources;
+	}
+
+	/* If this crtc is using the DP, add an overlay plane */
+	if (pdata->dp >= 0 && pdata->dma[1] > 0) {
+		ipu_crtc->plane[1] = ipu_plane_init(drm, ipu, pdata->dma[1],
+						IPU_DP_FLOW_SYNC_FG,
+						drm_crtc_mask(&ipu_crtc->base),
+						DRM_PLANE_TYPE_OVERLAY);
+		if (IS_ERR(ipu_crtc->plane[1])) {
+			ipu_crtc->plane[1] = NULL;
+		} else {
+			ret = ipu_plane_get_resources(ipu_crtc->plane[1]);
+			if (ret) {
+				dev_err(ipu_crtc->dev, "getting plane 1 "
+					"resources failed with %d.\n", ret);
+				goto err_put_plane0_res;
+			}
+		}
+	}
+
+	ipu_crtc->irq = ipu_plane_irq(ipu_crtc->plane[0]);
+	ret = devm_request_irq(ipu_crtc->dev, ipu_crtc->irq, ipu_irq_handler, 0,
+			"imx_drm", ipu_crtc);
+	if (ret < 0) {
+		dev_err(ipu_crtc->dev, "irq request failed with %d.\n", ret);
+		goto err_put_plane1_res;
+	}
+	/* Only enable IRQ when we actually need it to trigger work. */
+	disable_irq(ipu_crtc->irq);
+
+	return 0;
+
+err_put_plane1_res:
+	if (ipu_crtc->plane[1])
+		ipu_plane_put_resources(ipu_crtc->plane[1]);
+err_put_plane0_res:
+	ipu_plane_put_resources(ipu_crtc->plane[0]);
+err_put_resources:
+	ipu_put_resources(ipu_crtc);
+
+	return ret;
+}
+
+static int ipu_drm_bind(struct device *dev, struct device *master, void *data)
+{
+	struct ipu_client_platformdata *pdata = dev->platform_data;
+	struct drm_device *drm = data;
+	struct ipu_crtc *ipu_crtc;
+	int ret;
+
+	ipu_crtc = devm_kzalloc(dev, sizeof(*ipu_crtc), GFP_KERNEL);
+	if (!ipu_crtc)
+		return -ENOMEM;
+
+	ipu_crtc->dev = dev;
+
+	ret = ipu_crtc_init(ipu_crtc, pdata, drm);
+	if (ret)
+		return ret;
+
+	if (!drm->mode_config.funcs)
+		drm->mode_config.funcs = &ipuv3_drm_mode_config_funcs;
+	if (!drm->mode_config.helper_private)
+		drm->mode_config.helper_private =
+					&ipuv3_drm_mode_config_helpers;
+
+	dev_set_drvdata(dev, ipu_crtc);
+
+	return 0;
+}
+
+static void ipu_drm_unbind(struct device *dev, struct device *master,
+	void *data)
+{
+	struct ipu_crtc *ipu_crtc = dev_get_drvdata(dev);
+
+	ipu_put_resources(ipu_crtc);
+	if (ipu_crtc->plane[1])
+		ipu_plane_put_resources(ipu_crtc->plane[1]);
+	ipu_plane_put_resources(ipu_crtc->plane[0]);
+}
+
+static const struct component_ops ipu_crtc_ops = {
+	.bind = ipu_drm_bind,
+	.unbind = ipu_drm_unbind,
+};
+
+static int ipu_drm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	if (!dev->platform_data)
+		return -EINVAL;
+
+	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	return component_add(dev, &ipu_crtc_ops);
+}
+
+static int ipu_drm_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &ipu_crtc_ops);
+	return 0;
+}
+
+static struct platform_driver ipu_drm_driver = {
+	.driver = {
+		.name = "imx-ipuv3-crtc",
+	},
+	.probe = ipu_drm_probe,
+	.remove = ipu_drm_remove,
+};
+module_platform_driver(ipu_drm_driver);
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:imx-ipuv3-crtc");
diff --git a/drivers/gpu/drm/imx/ipuv3/ipuv3-kms.c b/drivers/gpu/drm/imx/ipuv3/ipuv3-kms.c
new file mode 100644
index 0000000..d342458
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/ipuv3-kms.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <linux/dma-buf.h>
+#include <linux/reservation.h>
+#include "imx-drm.h"
+
+static int imx_drm_atomic_check(struct drm_device *dev,
+				struct drm_atomic_state *state)
+{
+	int ret;
+
+	ret = drm_atomic_helper_check_modeset(dev, state);
+	if (ret)
+		return ret;
+
+	ret = drm_atomic_helper_check_planes(dev, state);
+	if (ret)
+		return ret;
+
+	/*
+	 * Check modeset again in case crtc_state->mode_changed is
+	 * updated in plane's ->atomic_check callback.
+	 */
+	ret = drm_atomic_helper_check_modeset(dev, state);
+	if (ret)
+		return ret;
+
+	/* Assign PRG/PRE channels and check if all constrains are satisfied. */
+	ret = ipu_planes_assign_pre(dev, state);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static const struct drm_mode_config_funcs imx_drm_mode_config_funcs = {
+	.fb_create = drm_gem_fb_create,
+	.output_poll_changed = drm_fb_helper_output_poll_changed,
+	.atomic_check = imx_drm_atomic_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void imx_drm_atomic_commit_tail(struct drm_atomic_state *state)
+{
+	struct drm_device *dev = state->dev;
+	struct drm_plane *plane;
+	struct drm_plane_state *old_plane_state, *new_plane_state;
+	bool plane_disabling = false;
+	int i;
+
+	drm_atomic_helper_commit_modeset_disables(dev, state);
+
+	drm_atomic_helper_commit_planes(dev, state,
+				DRM_PLANE_COMMIT_ACTIVE_ONLY |
+				DRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET);
+
+	drm_atomic_helper_commit_modeset_enables(dev, state);
+
+	for_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {
+		if (drm_atomic_plane_disabling(old_plane_state, new_plane_state))
+			plane_disabling = true;
+	}
+
+	/*
+	 * The flip done wait is only strictly required by imx-drm if a deferred
+	 * plane disable is in-flight. As the core requires blocking commits
+	 * to wait for the flip it is done here unconditionally. This keeps the
+	 * workitem around a bit longer than required for the majority of
+	 * non-blocking commits, but we accept that for the sake of simplicity.
+	 */
+	drm_atomic_helper_wait_for_flip_done(dev, state);
+
+	if (plane_disabling) {
+		for_each_old_plane_in_state(state, plane, old_plane_state, i)
+			ipu_plane_disable_deferred(plane);
+
+	}
+
+	drm_atomic_helper_commit_hw_done(state);
+}
+
+static const struct drm_mode_config_helper_funcs imx_drm_mode_config_helpers = {
+	.atomic_commit_tail = imx_drm_atomic_commit_tail,
+};
diff --git a/drivers/gpu/drm/imx/ipuv3/ipuv3-kms.h b/drivers/gpu/drm/imx/ipuv3/ipuv3-kms.h
new file mode 100644
index 0000000..3968131
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/ipuv3-kms.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+#ifndef _IPUV3_KMS_H_
+#define _IPUV3_KMS_H_
+
+extern const struct drm_mode_config_funcs ipuv3_drm_mode_config_funcs;
+extern struct drm_mode_config_helper_funcs ipuv3_drm_mode_config_helpers;
+
+#endif
diff --git a/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c b/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c
new file mode 100644
index 0000000..203f247
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c
@@ -0,0 +1,845 @@
+/*
+ * i.MX IPUv3 DP Overlay Planes
+ *
+ * Copyright (C) 2013 Philipp Zabel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "video/imx-ipu-v3.h"
+#include "imx-drm.h"
+#include "ipuv3-plane.h"
+
+struct ipu_plane_state {
+	struct drm_plane_state base;
+	bool use_pre;
+};
+
+static inline struct ipu_plane_state *
+to_ipu_plane_state(struct drm_plane_state *p)
+{
+	return container_of(p, struct ipu_plane_state, base);
+}
+
+static inline struct ipu_plane *to_ipu_plane(struct drm_plane *p)
+{
+	return container_of(p, struct ipu_plane, base);
+}
+
+static const uint32_t ipu_plane_formats[] = {
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ABGR1555,
+	DRM_FORMAT_XBGR1555,
+	DRM_FORMAT_RGBA5551,
+	DRM_FORMAT_BGRA5551,
+	DRM_FORMAT_ARGB4444,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_BGRX8888,
+	DRM_FORMAT_UYVY,
+	DRM_FORMAT_VYUY,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVYU,
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_YVU420,
+	DRM_FORMAT_YUV422,
+	DRM_FORMAT_YVU422,
+	DRM_FORMAT_YUV444,
+	DRM_FORMAT_YVU444,
+	DRM_FORMAT_NV12,
+	DRM_FORMAT_NV16,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_RGB565_A8,
+	DRM_FORMAT_BGR565_A8,
+	DRM_FORMAT_RGB888_A8,
+	DRM_FORMAT_BGR888_A8,
+	DRM_FORMAT_RGBX8888_A8,
+	DRM_FORMAT_BGRX8888_A8,
+};
+
+static const uint64_t ipu_format_modifiers[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_INVALID
+};
+
+static const uint64_t pre_format_modifiers[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_VIVANTE_TILED,
+	DRM_FORMAT_MOD_VIVANTE_SUPER_TILED,
+	DRM_FORMAT_MOD_INVALID
+};
+
+int ipu_plane_irq(struct ipu_plane *ipu_plane)
+{
+	return ipu_idmac_channel_irq(ipu_plane->ipu, ipu_plane->ipu_ch,
+				     IPU_IRQ_EOF);
+}
+
+static inline unsigned long
+drm_plane_state_to_eba(struct drm_plane_state *state, int plane)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_gem_cma_object *cma_obj;
+	int x = state->src.x1 >> 16;
+	int y = state->src.y1 >> 16;
+
+	cma_obj = drm_fb_cma_get_gem_obj(fb, plane);
+	BUG_ON(!cma_obj);
+
+	return cma_obj->paddr + fb->offsets[plane] + fb->pitches[plane] * y +
+	       fb->format->cpp[plane] * x;
+}
+
+static inline unsigned long
+drm_plane_state_to_ubo(struct drm_plane_state *state)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_gem_cma_object *cma_obj;
+	unsigned long eba = drm_plane_state_to_eba(state, 0);
+	int x = state->src.x1 >> 16;
+	int y = state->src.y1 >> 16;
+
+	cma_obj = drm_fb_cma_get_gem_obj(fb, 1);
+	BUG_ON(!cma_obj);
+
+	x /= drm_format_horz_chroma_subsampling(fb->format->format);
+	y /= drm_format_vert_chroma_subsampling(fb->format->format);
+
+	return cma_obj->paddr + fb->offsets[1] + fb->pitches[1] * y +
+	       fb->format->cpp[1] * x - eba;
+}
+
+static inline unsigned long
+drm_plane_state_to_vbo(struct drm_plane_state *state)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_gem_cma_object *cma_obj;
+	unsigned long eba = drm_plane_state_to_eba(state, 0);
+	int x = state->src.x1 >> 16;
+	int y = state->src.y1 >> 16;
+
+	cma_obj = drm_fb_cma_get_gem_obj(fb, 2);
+	BUG_ON(!cma_obj);
+
+	x /= drm_format_horz_chroma_subsampling(fb->format->format);
+	y /= drm_format_vert_chroma_subsampling(fb->format->format);
+
+	return cma_obj->paddr + fb->offsets[2] + fb->pitches[2] * y +
+	       fb->format->cpp[2] * x - eba;
+}
+
+void ipu_plane_put_resources(struct ipu_plane *ipu_plane)
+{
+	if (!IS_ERR_OR_NULL(ipu_plane->dp))
+		ipu_dp_put(ipu_plane->dp);
+	if (!IS_ERR_OR_NULL(ipu_plane->dmfc))
+		ipu_dmfc_put(ipu_plane->dmfc);
+	if (!IS_ERR_OR_NULL(ipu_plane->ipu_ch))
+		ipu_idmac_put(ipu_plane->ipu_ch);
+	if (!IS_ERR_OR_NULL(ipu_plane->alpha_ch))
+		ipu_idmac_put(ipu_plane->alpha_ch);
+}
+
+int ipu_plane_get_resources(struct ipu_plane *ipu_plane)
+{
+	int ret;
+	int alpha_ch;
+
+	ipu_plane->ipu_ch = ipu_idmac_get(ipu_plane->ipu, ipu_plane->dma);
+	if (IS_ERR(ipu_plane->ipu_ch)) {
+		ret = PTR_ERR(ipu_plane->ipu_ch);
+		DRM_ERROR("failed to get idmac channel: %d\n", ret);
+		return ret;
+	}
+
+	alpha_ch = ipu_channel_alpha_channel(ipu_plane->dma);
+	if (alpha_ch >= 0) {
+		ipu_plane->alpha_ch = ipu_idmac_get(ipu_plane->ipu, alpha_ch);
+		if (IS_ERR(ipu_plane->alpha_ch)) {
+			ret = PTR_ERR(ipu_plane->alpha_ch);
+			DRM_ERROR("failed to get alpha idmac channel %d: %d\n",
+				  alpha_ch, ret);
+			return ret;
+		}
+	}
+
+	ipu_plane->dmfc = ipu_dmfc_get(ipu_plane->ipu, ipu_plane->dma);
+	if (IS_ERR(ipu_plane->dmfc)) {
+		ret = PTR_ERR(ipu_plane->dmfc);
+		DRM_ERROR("failed to get dmfc: ret %d\n", ret);
+		goto err_out;
+	}
+
+	if (ipu_plane->dp_flow >= 0) {
+		ipu_plane->dp = ipu_dp_get(ipu_plane->ipu, ipu_plane->dp_flow);
+		if (IS_ERR(ipu_plane->dp)) {
+			ret = PTR_ERR(ipu_plane->dp);
+			DRM_ERROR("failed to get dp flow: %d\n", ret);
+			goto err_out;
+		}
+	}
+
+	return 0;
+err_out:
+	ipu_plane_put_resources(ipu_plane);
+
+	return ret;
+}
+
+static bool ipu_plane_separate_alpha(struct ipu_plane *ipu_plane)
+{
+	switch (ipu_plane->base.state->fb->format->format) {
+	case DRM_FORMAT_RGB565_A8:
+	case DRM_FORMAT_BGR565_A8:
+	case DRM_FORMAT_RGB888_A8:
+	case DRM_FORMAT_BGR888_A8:
+	case DRM_FORMAT_RGBX8888_A8:
+	case DRM_FORMAT_BGRX8888_A8:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static void ipu_plane_enable(struct ipu_plane *ipu_plane)
+{
+	if (ipu_plane->dp)
+		ipu_dp_enable(ipu_plane->ipu);
+	ipu_dmfc_enable_channel(ipu_plane->dmfc);
+	ipu_idmac_enable_channel(ipu_plane->ipu_ch);
+	if (ipu_plane_separate_alpha(ipu_plane))
+		ipu_idmac_enable_channel(ipu_plane->alpha_ch);
+	if (ipu_plane->dp)
+		ipu_dp_enable_channel(ipu_plane->dp);
+}
+
+void ipu_plane_disable(struct ipu_plane *ipu_plane, bool disable_dp_channel)
+{
+	DRM_DEBUG_KMS("[%d] %s\n", __LINE__, __func__);
+
+	ipu_idmac_wait_busy(ipu_plane->ipu_ch, 50);
+
+	if (ipu_plane->dp && disable_dp_channel)
+		ipu_dp_disable_channel(ipu_plane->dp, false);
+	ipu_idmac_disable_channel(ipu_plane->ipu_ch);
+	if (ipu_plane->alpha_ch)
+		ipu_idmac_disable_channel(ipu_plane->alpha_ch);
+	ipu_dmfc_disable_channel(ipu_plane->dmfc);
+	if (ipu_plane->dp)
+		ipu_dp_disable(ipu_plane->ipu);
+	if (ipu_prg_present(ipu_plane->ipu))
+		ipu_prg_channel_disable(ipu_plane->ipu_ch);
+}
+
+void ipu_plane_disable_deferred(struct drm_plane *plane)
+{
+	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
+
+	if (ipu_plane->disabling) {
+		ipu_plane->disabling = false;
+		ipu_plane_disable(ipu_plane, false);
+	}
+}
+EXPORT_SYMBOL_GPL(ipu_plane_disable_deferred);
+
+static void ipu_plane_destroy(struct drm_plane *plane)
+{
+	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
+
+	DRM_DEBUG_KMS("[%d] %s\n", __LINE__, __func__);
+
+	drm_plane_cleanup(plane);
+	kfree(ipu_plane);
+}
+
+static void ipu_plane_state_reset(struct drm_plane *plane)
+{
+	struct ipu_plane_state *ipu_state;
+
+	if (plane->state) {
+		ipu_state = to_ipu_plane_state(plane->state);
+		__drm_atomic_helper_plane_destroy_state(plane->state);
+		kfree(ipu_state);
+	}
+
+	ipu_state = kzalloc(sizeof(*ipu_state), GFP_KERNEL);
+
+	if (ipu_state) {
+		ipu_state->base.plane = plane;
+		ipu_state->base.rotation = DRM_MODE_ROTATE_0;
+	}
+
+	plane->state = &ipu_state->base;
+}
+
+static struct drm_plane_state *
+ipu_plane_duplicate_state(struct drm_plane *plane)
+{
+	struct ipu_plane_state *state;
+
+	if (WARN_ON(!plane->state))
+		return NULL;
+
+	state = kmalloc(sizeof(*state), GFP_KERNEL);
+	if (state)
+		__drm_atomic_helper_plane_duplicate_state(plane, &state->base);
+
+	return &state->base;
+}
+
+static void ipu_plane_destroy_state(struct drm_plane *plane,
+				    struct drm_plane_state *state)
+{
+	struct ipu_plane_state *ipu_state = to_ipu_plane_state(state);
+
+	__drm_atomic_helper_plane_destroy_state(state);
+	kfree(ipu_state);
+}
+
+static bool ipu_plane_format_mod_supported(struct drm_plane *plane,
+					   uint32_t format, uint64_t modifier)
+{
+	struct ipu_soc *ipu = to_ipu_plane(plane)->ipu;
+
+	/* linear is supported for all planes and formats */
+	if (modifier == DRM_FORMAT_MOD_LINEAR)
+		return true;
+
+	/* without a PRG there are no supported modifiers */
+	if (!ipu_prg_present(ipu))
+		return false;
+
+	return ipu_prg_format_supported(ipu, format, modifier);
+}
+
+static const struct drm_plane_funcs ipu_plane_funcs = {
+	.update_plane	= drm_atomic_helper_update_plane,
+	.disable_plane	= drm_atomic_helper_disable_plane,
+	.destroy	= ipu_plane_destroy,
+	.reset		= ipu_plane_state_reset,
+	.atomic_duplicate_state	= ipu_plane_duplicate_state,
+	.atomic_destroy_state	= ipu_plane_destroy_state,
+	.format_mod_supported = ipu_plane_format_mod_supported,
+};
+
+static int ipu_plane_atomic_check(struct drm_plane *plane,
+				  struct drm_plane_state *state)
+{
+	struct drm_plane_state *old_state = plane->state;
+	struct drm_crtc_state *crtc_state;
+	struct device *dev = plane->dev->dev;
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_framebuffer *old_fb = old_state->fb;
+	unsigned long eba, ubo, vbo, old_ubo, old_vbo, alpha_eba;
+	bool can_position = (plane->type == DRM_PLANE_TYPE_OVERLAY);
+	int hsub, vsub;
+	int ret;
+
+	/* Ok to disable */
+	if (!fb)
+		return 0;
+
+	if (!state->crtc)
+		return -EINVAL;
+
+	crtc_state =
+		drm_atomic_get_existing_crtc_state(state->state, state->crtc);
+	if (WARN_ON(!crtc_state))
+		return -EINVAL;
+
+	ret = drm_atomic_helper_check_plane_state(state, crtc_state,
+						  DRM_PLANE_HELPER_NO_SCALING,
+						  DRM_PLANE_HELPER_NO_SCALING,
+						  can_position, true);
+	if (ret)
+		return ret;
+
+	/* CRTC should be enabled */
+	if (!crtc_state->enable)
+		return -EINVAL;
+
+	switch (plane->type) {
+	case DRM_PLANE_TYPE_PRIMARY:
+		/* full plane minimum width is 13 pixels */
+		if (drm_rect_width(&state->dst) < 13)
+			return -EINVAL;
+		break;
+	case DRM_PLANE_TYPE_OVERLAY:
+		break;
+	default:
+		dev_warn(dev, "Unsupported plane type %d\n", plane->type);
+		return -EINVAL;
+	}
+
+	if (drm_rect_height(&state->dst) < 2)
+		return -EINVAL;
+
+	/*
+	 * We support resizing active plane or changing its format by
+	 * forcing CRTC mode change in plane's ->atomic_check callback
+	 * and disabling all affected active planes in CRTC's ->atomic_disable
+	 * callback.  The planes will be reenabled in plane's ->atomic_update
+	 * callback.
+	 */
+	if (old_fb &&
+	    (drm_rect_width(&state->dst) != drm_rect_width(&old_state->dst) ||
+	     drm_rect_height(&state->dst) != drm_rect_height(&old_state->dst) ||
+	     fb->format != old_fb->format))
+		crtc_state->mode_changed = true;
+
+	eba = drm_plane_state_to_eba(state, 0);
+
+	if (eba & 0x7)
+		return -EINVAL;
+
+	if (fb->pitches[0] < 1 || fb->pitches[0] > 16384)
+		return -EINVAL;
+
+	if (old_fb && fb->pitches[0] != old_fb->pitches[0])
+		crtc_state->mode_changed = true;
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+	case DRM_FORMAT_YUV444:
+	case DRM_FORMAT_YVU444:
+		/*
+		 * Multiplanar formats have to meet the following restrictions:
+		 * - The (up to) three plane addresses are EBA, EBA+UBO, EBA+VBO
+		 * - EBA, UBO and VBO are a multiple of 8
+		 * - UBO and VBO are unsigned and not larger than 0xfffff8
+		 * - Only EBA may be changed while scanout is active
+		 * - The strides of U and V planes must be identical.
+		 */
+		vbo = drm_plane_state_to_vbo(state);
+
+		if (vbo & 0x7 || vbo > 0xfffff8)
+			return -EINVAL;
+
+		if (old_fb && (fb->format == old_fb->format)) {
+			old_vbo = drm_plane_state_to_vbo(old_state);
+			if (vbo != old_vbo)
+				crtc_state->mode_changed = true;
+		}
+
+		if (fb->pitches[1] != fb->pitches[2])
+			return -EINVAL;
+
+		/* fall-through */
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV16:
+		ubo = drm_plane_state_to_ubo(state);
+
+		if (ubo & 0x7 || ubo > 0xfffff8)
+			return -EINVAL;
+
+		if (old_fb && (fb->format == old_fb->format)) {
+			old_ubo = drm_plane_state_to_ubo(old_state);
+			if (ubo != old_ubo)
+				crtc_state->mode_changed = true;
+		}
+
+		if (fb->pitches[1] < 1 || fb->pitches[1] > 16384)
+			return -EINVAL;
+
+		if (old_fb && old_fb->pitches[1] != fb->pitches[1])
+			crtc_state->mode_changed = true;
+
+		/*
+		 * The x/y offsets must be even in case of horizontal/vertical
+		 * chroma subsampling.
+		 */
+		hsub = drm_format_horz_chroma_subsampling(fb->format->format);
+		vsub = drm_format_vert_chroma_subsampling(fb->format->format);
+		if (((state->src.x1 >> 16) & (hsub - 1)) ||
+		    ((state->src.y1 >> 16) & (vsub - 1)))
+			return -EINVAL;
+		break;
+	case DRM_FORMAT_RGB565_A8:
+	case DRM_FORMAT_BGR565_A8:
+	case DRM_FORMAT_RGB888_A8:
+	case DRM_FORMAT_BGR888_A8:
+	case DRM_FORMAT_RGBX8888_A8:
+	case DRM_FORMAT_BGRX8888_A8:
+		alpha_eba = drm_plane_state_to_eba(state, 1);
+		if (alpha_eba & 0x7)
+			return -EINVAL;
+
+		if (fb->pitches[1] < 1 || fb->pitches[1] > 16384)
+			return -EINVAL;
+
+		if (old_fb && old_fb->pitches[1] != fb->pitches[1])
+			crtc_state->mode_changed = true;
+		break;
+	}
+
+	return 0;
+}
+
+static void ipu_plane_atomic_disable(struct drm_plane *plane,
+				     struct drm_plane_state *old_state)
+{
+	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
+
+	if (ipu_plane->dp)
+		ipu_dp_disable_channel(ipu_plane->dp, true);
+	ipu_plane->disabling = true;
+}
+
+static int ipu_chan_assign_axi_id(int ipu_chan)
+{
+	switch (ipu_chan) {
+	case IPUV3_CHANNEL_MEM_BG_SYNC:
+		return 1;
+	case IPUV3_CHANNEL_MEM_FG_SYNC:
+		return 2;
+	case IPUV3_CHANNEL_MEM_DC_SYNC:
+		return 3;
+	default:
+		return 0;
+	}
+}
+
+static void ipu_calculate_bursts(u32 width, u32 cpp, u32 stride,
+				 u8 *burstsize, u8 *num_bursts)
+{
+	const unsigned int width_bytes = width * cpp;
+	unsigned int npb, bursts;
+
+	/* Maximum number of pixels per burst without overshooting stride */
+	for (npb = 64 / cpp; npb > 0; --npb) {
+		if (round_up(width_bytes, npb * cpp) <= stride)
+			break;
+	}
+	*burstsize = npb;
+
+	/* Maximum number of consecutive bursts without overshooting stride */
+	for (bursts = 8; bursts > 1; bursts /= 2) {
+		if (round_up(width_bytes, npb * cpp * bursts) <= stride)
+			break;
+	}
+	*num_bursts = bursts;
+}
+
+static void ipu_plane_atomic_update(struct drm_plane *plane,
+				    struct drm_plane_state *old_state)
+{
+	struct ipu_plane *ipu_plane = to_ipu_plane(plane);
+	struct drm_plane_state *state = plane->state;
+	struct ipu_plane_state *ipu_state = to_ipu_plane_state(state);
+	struct drm_crtc_state *crtc_state = state->crtc->state;
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_rect *dst = &state->dst;
+	unsigned long eba, ubo, vbo;
+	unsigned long alpha_eba = 0;
+	enum ipu_color_space ics;
+	unsigned int axi_id = 0;
+	const struct drm_format_info *info;
+	u8 burstsize, num_bursts;
+	u32 width, height;
+	int active;
+
+	if (ipu_plane->dp_flow == IPU_DP_FLOW_SYNC_FG)
+		ipu_dp_set_window_pos(ipu_plane->dp, dst->x1, dst->y1);
+
+	eba = drm_plane_state_to_eba(state, 0);
+
+	/*
+	 * Configure PRG channel and attached PRE, this changes the EBA to an
+	 * internal SRAM location.
+	 */
+	if (ipu_state->use_pre) {
+		axi_id = ipu_chan_assign_axi_id(ipu_plane->dma);
+		ipu_prg_channel_configure(ipu_plane->ipu_ch, axi_id,
+					  drm_rect_width(&state->src) >> 16,
+					  drm_rect_height(&state->src) >> 16,
+					  fb->pitches[0], fb->format->format,
+					  fb->modifier, &eba);
+	}
+
+	if (old_state->fb && !drm_atomic_crtc_needs_modeset(crtc_state)) {
+		/* nothing to do if PRE is used */
+		if (ipu_state->use_pre)
+			return;
+		active = ipu_idmac_get_current_buffer(ipu_plane->ipu_ch);
+		ipu_cpmem_set_buffer(ipu_plane->ipu_ch, !active, eba);
+		ipu_idmac_select_buffer(ipu_plane->ipu_ch, !active);
+		if (ipu_plane_separate_alpha(ipu_plane)) {
+			active = ipu_idmac_get_current_buffer(ipu_plane->alpha_ch);
+			ipu_cpmem_set_buffer(ipu_plane->alpha_ch, !active,
+					     alpha_eba);
+			ipu_idmac_select_buffer(ipu_plane->alpha_ch, !active);
+		}
+		return;
+	}
+
+	ics = ipu_drm_fourcc_to_colorspace(fb->format->format);
+	switch (ipu_plane->dp_flow) {
+	case IPU_DP_FLOW_SYNC_BG:
+		ipu_dp_setup_channel(ipu_plane->dp, ics, IPUV3_COLORSPACE_RGB);
+		ipu_dp_set_global_alpha(ipu_plane->dp, true, 0, true);
+		break;
+	case IPU_DP_FLOW_SYNC_FG:
+		ipu_dp_setup_channel(ipu_plane->dp, ics,
+					IPUV3_COLORSPACE_UNKNOWN);
+		/* Enable local alpha on partial plane */
+		switch (fb->format->format) {
+		case DRM_FORMAT_ARGB1555:
+		case DRM_FORMAT_ABGR1555:
+		case DRM_FORMAT_RGBA5551:
+		case DRM_FORMAT_BGRA5551:
+		case DRM_FORMAT_ARGB4444:
+		case DRM_FORMAT_ARGB8888:
+		case DRM_FORMAT_ABGR8888:
+		case DRM_FORMAT_RGBA8888:
+		case DRM_FORMAT_BGRA8888:
+		case DRM_FORMAT_RGB565_A8:
+		case DRM_FORMAT_BGR565_A8:
+		case DRM_FORMAT_RGB888_A8:
+		case DRM_FORMAT_BGR888_A8:
+		case DRM_FORMAT_RGBX8888_A8:
+		case DRM_FORMAT_BGRX8888_A8:
+			ipu_dp_set_global_alpha(ipu_plane->dp, false, 0, false);
+			break;
+		default:
+			ipu_dp_set_global_alpha(ipu_plane->dp, true, 0, true);
+			break;
+		}
+	}
+
+	ipu_dmfc_config_wait4eot(ipu_plane->dmfc, drm_rect_width(dst));
+
+	width = drm_rect_width(&state->src) >> 16;
+	height = drm_rect_height(&state->src) >> 16;
+	info = drm_format_info(fb->format->format);
+	ipu_calculate_bursts(width, info->cpp[0], fb->pitches[0],
+			     &burstsize, &num_bursts);
+
+	ipu_cpmem_zero(ipu_plane->ipu_ch);
+	ipu_cpmem_set_resolution(ipu_plane->ipu_ch, width, height);
+	ipu_cpmem_set_fmt(ipu_plane->ipu_ch, fb->format->format);
+	ipu_cpmem_set_burstsize(ipu_plane->ipu_ch, burstsize);
+	ipu_cpmem_set_high_priority(ipu_plane->ipu_ch);
+	ipu_idmac_set_double_buffer(ipu_plane->ipu_ch, 1);
+	ipu_cpmem_set_stride(ipu_plane->ipu_ch, fb->pitches[0]);
+	ipu_cpmem_set_axi_id(ipu_plane->ipu_ch, axi_id);
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+	case DRM_FORMAT_YUV444:
+	case DRM_FORMAT_YVU444:
+		ubo = drm_plane_state_to_ubo(state);
+		vbo = drm_plane_state_to_vbo(state);
+		if (fb->format->format == DRM_FORMAT_YVU420 ||
+		    fb->format->format == DRM_FORMAT_YVU422 ||
+		    fb->format->format == DRM_FORMAT_YVU444)
+			swap(ubo, vbo);
+
+		ipu_cpmem_set_yuv_planar_full(ipu_plane->ipu_ch,
+					      fb->pitches[1], ubo, vbo);
+
+		dev_dbg(ipu_plane->base.dev->dev,
+			"phy = %lu %lu %lu, x = %d, y = %d", eba, ubo, vbo,
+			state->src.x1 >> 16, state->src.y1 >> 16);
+		break;
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV16:
+		ubo = drm_plane_state_to_ubo(state);
+
+		ipu_cpmem_set_yuv_planar_full(ipu_plane->ipu_ch,
+					      fb->pitches[1], ubo, ubo);
+
+		dev_dbg(ipu_plane->base.dev->dev,
+			"phy = %lu %lu, x = %d, y = %d", eba, ubo,
+			state->src.x1 >> 16, state->src.y1 >> 16);
+		break;
+	case DRM_FORMAT_RGB565_A8:
+	case DRM_FORMAT_BGR565_A8:
+	case DRM_FORMAT_RGB888_A8:
+	case DRM_FORMAT_BGR888_A8:
+	case DRM_FORMAT_RGBX8888_A8:
+	case DRM_FORMAT_BGRX8888_A8:
+		alpha_eba = drm_plane_state_to_eba(state, 1);
+		num_bursts = 0;
+
+		dev_dbg(ipu_plane->base.dev->dev, "phys = %lu %lu, x = %d, y = %d",
+			eba, alpha_eba, state->src.x1 >> 16, state->src.y1 >> 16);
+
+		ipu_cpmem_set_burstsize(ipu_plane->ipu_ch, 16);
+
+		ipu_cpmem_zero(ipu_plane->alpha_ch);
+		ipu_cpmem_set_resolution(ipu_plane->alpha_ch,
+					 drm_rect_width(&state->src) >> 16,
+					 drm_rect_height(&state->src) >> 16);
+		ipu_cpmem_set_format_passthrough(ipu_plane->alpha_ch, 8);
+		ipu_cpmem_set_high_priority(ipu_plane->alpha_ch);
+		ipu_idmac_set_double_buffer(ipu_plane->alpha_ch, 1);
+		ipu_cpmem_set_stride(ipu_plane->alpha_ch, fb->pitches[1]);
+		ipu_cpmem_set_burstsize(ipu_plane->alpha_ch, 16);
+		ipu_cpmem_set_buffer(ipu_plane->alpha_ch, 0, alpha_eba);
+		ipu_cpmem_set_buffer(ipu_plane->alpha_ch, 1, alpha_eba);
+		break;
+	default:
+		dev_dbg(ipu_plane->base.dev->dev, "phys = %lu, x = %d, y = %d",
+			eba, state->src.x1 >> 16, state->src.y1 >> 16);
+		break;
+	}
+	ipu_cpmem_set_buffer(ipu_plane->ipu_ch, 0, eba);
+	ipu_cpmem_set_buffer(ipu_plane->ipu_ch, 1, eba);
+	ipu_idmac_lock_enable(ipu_plane->ipu_ch, num_bursts);
+	ipu_plane_enable(ipu_plane);
+}
+
+static const struct drm_plane_helper_funcs ipu_plane_helper_funcs = {
+	.prepare_fb = drm_gem_fb_prepare_fb,
+	.atomic_check = ipu_plane_atomic_check,
+	.atomic_disable = ipu_plane_atomic_disable,
+	.atomic_update = ipu_plane_atomic_update,
+};
+
+int ipu_planes_assign_pre(struct drm_device *dev,
+			  struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *old_crtc_state, *crtc_state;
+	struct drm_plane_state *plane_state;
+	struct ipu_plane_state *ipu_state;
+	struct ipu_plane *ipu_plane;
+	struct drm_plane *plane;
+	struct drm_crtc *crtc;
+	int available_pres = ipu_prg_max_active_channels();
+	int ret, i;
+
+	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, crtc_state, i) {
+		ret = drm_atomic_add_affected_planes(state, crtc);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * We are going over the planes in 2 passes: first we assign PREs to
+	 * planes with a tiling modifier, which need the PREs to resolve into
+	 * linear. Any failure to assign a PRE there is fatal. In the second
+	 * pass we try to assign PREs to linear FBs, to improve memory access
+	 * patterns for them. Failure at this point is non-fatal, as we can
+	 * scan out linear FBs without a PRE.
+	 */
+	for_each_new_plane_in_state(state, plane, plane_state, i) {
+		ipu_state = to_ipu_plane_state(plane_state);
+		ipu_plane = to_ipu_plane(plane);
+
+		if (!plane_state->fb) {
+			ipu_state->use_pre = false;
+			continue;
+		}
+
+		if (!(plane_state->fb->flags & DRM_MODE_FB_MODIFIERS) ||
+		    plane_state->fb->modifier == DRM_FORMAT_MOD_LINEAR)
+			continue;
+
+		if (!ipu_prg_present(ipu_plane->ipu) || !available_pres)
+			return -EINVAL;
+
+		if (!ipu_prg_format_supported(ipu_plane->ipu,
+					      plane_state->fb->format->format,
+					      plane_state->fb->modifier))
+			return -EINVAL;
+
+		ipu_state->use_pre = true;
+		available_pres--;
+	}
+
+	for_each_new_plane_in_state(state, plane, plane_state, i) {
+		ipu_state = to_ipu_plane_state(plane_state);
+		ipu_plane = to_ipu_plane(plane);
+
+		if (!plane_state->fb) {
+			ipu_state->use_pre = false;
+			continue;
+		}
+
+		if ((plane_state->fb->flags & DRM_MODE_FB_MODIFIERS) &&
+		    plane_state->fb->modifier != DRM_FORMAT_MOD_LINEAR)
+			continue;
+
+		/* make sure that modifier is initialized */
+		plane_state->fb->modifier = DRM_FORMAT_MOD_LINEAR;
+
+		if (ipu_prg_present(ipu_plane->ipu) && available_pres &&
+		    ipu_prg_format_supported(ipu_plane->ipu,
+					     plane_state->fb->format->format,
+					     plane_state->fb->modifier)) {
+			ipu_state->use_pre = true;
+			available_pres--;
+		} else {
+			ipu_state->use_pre = false;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_planes_assign_pre);
+
+struct ipu_plane *ipu_plane_init(struct drm_device *dev, struct ipu_soc *ipu,
+				 int dma, int dp, unsigned int possible_crtcs,
+				 enum drm_plane_type type)
+{
+	struct ipu_plane *ipu_plane;
+	const uint64_t *modifiers = ipu_format_modifiers;
+	int ret;
+
+	DRM_DEBUG_KMS("channel %d, dp flow %d, possible_crtcs=0x%x\n",
+		      dma, dp, possible_crtcs);
+
+	ipu_plane = kzalloc(sizeof(*ipu_plane), GFP_KERNEL);
+	if (!ipu_plane) {
+		DRM_ERROR("failed to allocate plane\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	ipu_plane->ipu = ipu;
+	ipu_plane->dma = dma;
+	ipu_plane->dp_flow = dp;
+
+	if (ipu_prg_present(ipu))
+		modifiers = pre_format_modifiers;
+
+	ret = drm_universal_plane_init(dev, &ipu_plane->base, possible_crtcs,
+				       &ipu_plane_funcs, ipu_plane_formats,
+				       ARRAY_SIZE(ipu_plane_formats),
+				       modifiers, type, NULL);
+	if (ret) {
+		DRM_ERROR("failed to initialize plane\n");
+		kfree(ipu_plane);
+		return ERR_PTR(ret);
+	}
+
+	drm_plane_helper_add(&ipu_plane->base, &ipu_plane_helper_funcs);
+
+	return ipu_plane;
+}
diff --git a/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.h b/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.h
new file mode 100644
index 0000000..e563ea1
--- /dev/null
+++ b/drivers/gpu/drm/imx/ipuv3/ipuv3-plane.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __IPUV3_PLANE_H__
+#define __IPUV3_PLANE_H__
+
+#include <drm/drm_crtc.h> /* drm_plane */
+
+struct drm_plane;
+struct drm_device;
+struct ipu_soc;
+struct drm_crtc;
+struct drm_framebuffer;
+
+struct ipuv3_channel;
+struct dmfc_channel;
+struct ipu_dp;
+
+struct ipu_plane {
+	struct drm_plane	base;
+
+	struct ipu_soc		*ipu;
+	struct ipuv3_channel	*ipu_ch;
+	struct ipuv3_channel	*alpha_ch;
+	struct dmfc_channel	*dmfc;
+	struct ipu_dp		*dp;
+
+	int			dma;
+	int			dp_flow;
+
+	bool			disabling;
+};
+
+struct ipu_plane *ipu_plane_init(struct drm_device *dev, struct ipu_soc *ipu,
+				 int dma, int dp, unsigned int possible_crtcs,
+				 enum drm_plane_type type);
+
+/* Init IDMAC, DMFC, DP */
+int ipu_plane_mode_set(struct ipu_plane *plane, struct drm_crtc *crtc,
+		       struct drm_display_mode *mode,
+		       struct drm_framebuffer *fb, int crtc_x, int crtc_y,
+		       unsigned int crtc_w, unsigned int crtc_h,
+		       uint32_t src_x, uint32_t src_y, uint32_t src_w,
+		       uint32_t src_h, bool interlaced);
+
+int ipu_plane_get_resources(struct ipu_plane *plane);
+void ipu_plane_put_resources(struct ipu_plane *plane);
+
+int ipu_plane_irq(struct ipu_plane *plane);
+
+void ipu_plane_disable(struct ipu_plane *ipu_plane, bool disable_dp_channel);
+void ipu_plane_disable_deferred(struct drm_plane *plane);
+
+#endif
-- 
1.7.9.5


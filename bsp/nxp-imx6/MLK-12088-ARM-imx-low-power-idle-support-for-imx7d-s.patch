From ef1f8b28b6de4c133949a8a9a1e13e201bb0b6de Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Mon, 28 Dec 2015 22:38:26 +0800
Subject: [PATCH 3634/5242] MLK-12088 ARM: imx: low power idle support for
 imx7d single core (HAX)

commit  5e453a241dd57727f9febff9119ba7709eed4199 from
https://source.codeaurora.org/external/imx/linux-imx.git

When only single core online for i.MX7D, the secondary core wfi
flag should be set to make sure low power idle can be entered when
last core enters wfi. Otherwise, DDR/CCM/ANATOP will NOT enter
low power mode as the secondary core wfi flag is always clear;

Make sure the last power up slot do the ack for single core case.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>

Since upstream removed cpu hotplug notifiers skip this part.

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/cpuidle-imx7d.c |    5 ++++-
 arch/arm/mach-imx/gpcv2.c         |    4 ++--
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-imx/cpuidle-imx7d.c b/arch/arm/mach-imx/cpuidle-imx7d.c
index 60702f3e..30d60d9 100644
--- a/arch/arm/mach-imx/cpuidle-imx7d.c
+++ b/arch/arm/mach-imx/cpuidle-imx7d.c
@@ -233,7 +233,10 @@ int __init imx7d_cpuidle_init(void)
 	cpuidle_pm_info->pbase = (phys_addr_t) wfi_iram_base_phys;
 	cpuidle_pm_info->pm_info_size = sizeof(*cpuidle_pm_info);
 	cpuidle_pm_info->resume_addr = virt_to_phys(ca7_cpu_resume);
-	cpuidle_pm_info->cpu1_wfi = 0;
+	if (num_online_cpus() == 1)
+		cpuidle_pm_info->cpu1_wfi = 1;
+	else
+		cpuidle_pm_info->cpu1_wfi = 0;
 	cpuidle_pm_info->lpi_enter = 0;
 	/* initialize the last cpu id to invalid here */
 	cpuidle_pm_info->last_cpu = -1;
diff --git a/arch/arm/mach-imx/gpcv2.c b/arch/arm/mach-imx/gpcv2.c
index f2e5876..9be7de4 100644
--- a/arch/arm/mach-imx/gpcv2.c
+++ b/arch/arm/mach-imx/gpcv2.c
@@ -411,9 +411,9 @@ void imx_gpcv2_set_cpu_power_gate_in_idle(bool pdn)
 			imx_gpcv2_set_slot_ack(2, CORE1_A7, false, false);
 		imx_gpcv2_set_slot_ack(3, SCU_A7, false, true);
 		imx_gpcv2_set_slot_ack(6, SCU_A7, true, false);
-		imx_gpcv2_set_slot_ack(7, CORE0_A7, true, false);
 		if (num_online_cpus() > 1)
-			imx_gpcv2_set_slot_ack(8, CORE1_A7, true, true);
+			imx_gpcv2_set_slot_ack(7, CORE1_A7, true, false);
+		imx_gpcv2_set_slot_ack(8, CORE0_A7, true, true);
 	} else {
 		writel_relaxed(0x0, gpc_base + GPC_SLOT0_CFG + 0 * 0x4);
 		writel_relaxed(0x0, gpc_base + GPC_SLOT0_CFG + 2 * 0x4);
-- 
1.7.9.5


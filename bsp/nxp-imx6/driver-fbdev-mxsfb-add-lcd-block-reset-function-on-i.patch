From 87a07b0e9bf4eae5d69a6e6698ba933bef763a4f Mon Sep 17 00:00:00 2001
From: MengLi <meng.li@windriver.com>
Date: Mon, 1 Apr 2019 17:19:15 +0800
Subject: [PATCH] driver: fbdev: mxsfb: add lcd block reset function on
 imx6-sx plarform.

Before initializing LCD controller, it is need to reset it firstly.
This operation has key effect for kdump feature. If the LCD controller
is not reset, lcd screen is not able to be lighted when the second
kernel boots up.

Write the reset operation code, refer to imx6sx reference manual and
u-boot code.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxsfb.c |   52 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 52 insertions(+)

diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c
index 6f2d18f..b28c3b9 100644
--- a/drivers/video/fbdev/mxsfb.c
+++ b/drivers/video/fbdev/mxsfb.c
@@ -62,6 +62,8 @@
 #include <video/of_display_timing.h>
 #include <video/videomode.h>
 #include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
 
 #include "mxc/mxc_dispdrv.h"
 
@@ -189,6 +191,9 @@
 #define FB_SYNC_OE_LOW_ACT		0x80000000
 #define FB_SYNC_CLK_LAT_FALL	0x40000000
 
+#define	RESET_TIMEOUT	1000000
+#define	RESET_SLEEP		1000
+
 enum mxsfb_devtype {
 	MXSFB_V3,
 	MXSFB_V4,
@@ -2179,6 +2184,52 @@ static void mxsfb_overlay_resume(struct mxsfb_info *fbi) {}
 static void mxsfb_overlay_suspend(struct mxsfb_info *fbi) {}
 #endif
 
+static void mxsfb_reset_block(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = fb_info->par;
+	int ret;
+	u32 val;
+
+	/* Clear SFTRST */
+	writel(CTRL_SFTRST, host->base + LCDC_CTRL + REG_CLR);
+
+	/* Wait for SFTRST being cleared */
+	ret = readl_poll_timeout(host->base + LCDC_CTRL, val,
+				(val & CTRL_SFTRST) == 0, RESET_SLEEP, RESET_TIMEOUT);
+	if(ret)
+		return;
+
+	/* Clear CLKGATE */
+	writel(CTRL_CLKGATE, host->base + LCDC_CTRL + REG_CLR);
+
+	/* Set SFTRST */
+	writel(CTRL_SFTRST, host->base + LCDC_CTRL + REG_SET);
+
+	/* Wait for CLKGATE being set */
+	ret = readl_poll_timeout(host->base + LCDC_CTRL, val,
+				val & CTRL_CLKGATE, RESET_SLEEP, RESET_TIMEOUT);
+	if(ret)
+		return;
+
+	/* Clear SFTRST */
+	writel(CTRL_SFTRST, host->base + LCDC_CTRL + REG_CLR);
+
+	/* Wait for SFTRST being cleared */
+	ret = readl_poll_timeout(host->base + LCDC_CTRL, val,
+				(val & CTRL_SFTRST) == 0, RESET_SLEEP, RESET_TIMEOUT);
+	if(ret)
+		return;
+
+	/* Clear CLKGATE */
+	writel(CTRL_CLKGATE, host->base + LCDC_CTRL + REG_CLR);
+
+	/* Wait for CLKGATE being cleared */
+	ret = readl_poll_timeout(host->base + LCDC_CTRL, val,
+				(val & CTRL_CLKGATE) == 0, RESET_SLEEP, RESET_TIMEOUT);
+	if(ret)
+		return;
+}
+
 static int mxsfb_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id =
@@ -2304,6 +2355,7 @@ static int mxsfb_probe(struct platform_device *pdev)
 
 	if (!host->enabled) {
 		writel(0, host->base + LCDC_CTRL);
+		mxsfb_reset_block(fb_info);
 		mxsfb_set_par(fb_info);
 		mxsfb_enable_controller(fb_info);
 		pm_runtime_get_sync(&host->pdev->dev);
-- 
1.7.9.5


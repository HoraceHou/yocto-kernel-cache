From 9cd1c08739042c5b620ffcee4e4f1b119e870528 Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <Ranjani.Vaidyanathan@nxp.com>
Date: Fri, 2 Nov 2018 15:51:01 -0500
Subject: [PATCH 5017/5242] MLK-20222-1 soc: Update SCFW API

commit  1c21a146dc8d0fd03068f503c9ec5ca575c882b1 from
https://source.codeaurora.org/external/imx/linux-imx.git

Update SCFW API to the following commit:
"
    ("430d1e3646fbe75e339e18abf2330565eac906e0")
    Author: Chuck Cannon <chuck.cannon@nxp.com>
    Date:   Fri Nov 2 15:25:45 2018 -0500

    SCF-105: RN updates.
"

Signed-off-by: Ranjani Vaidyanathan <Ranjani.Vaidyanathan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/sc/main/ipc.c           |    4 +-
 drivers/soc/imx/sc/main/rpc.h           |  119 ++-
 drivers/soc/imx/sc/svc/irq/rpc.h        |   32 +-
 drivers/soc/imx/sc/svc/irq/rpc_clnt.c   |   34 +-
 drivers/soc/imx/sc/svc/misc/rpc.h       |   80 +-
 drivers/soc/imx/sc/svc/misc/rpc_clnt.c  |  531 ++++++++---
 drivers/soc/imx/sc/svc/pad/rpc.h        |   60 +-
 drivers/soc/imx/sc/svc/pad/rpc_clnt.c   |  290 +++---
 drivers/soc/imx/sc/svc/pm/rpc.h         |   70 +-
 drivers/soc/imx/sc/svc/pm/rpc_clnt.c    |  341 ++++---
 drivers/soc/imx/sc/svc/rm/rpc.h         |   91 +-
 drivers/soc/imx/sc/svc/rm/rpc_clnt.c    |  477 +++++-----
 drivers/soc/imx/sc/svc/timer/rpc.h      |   59 +-
 drivers/soc/imx/sc/svc/timer/rpc_clnt.c |  264 ++++--
 drivers/soc/imx/soc-imx8.c              |    1 +
 include/soc/imx/fsl_sip.h               |    5 -
 include/soc/imx8/sc/ipc.h               |   11 +-
 include/soc/imx8/sc/svc/irq/api.h       |   80 +-
 include/soc/imx8/sc/svc/misc/api.h      |  343 ++++++-
 include/soc/imx8/sc/svc/pad/api.h       |  119 +--
 include/soc/imx8/sc/svc/pm/api.h        |  293 ++++--
 include/soc/imx8/sc/svc/rm/api.h        |  139 +--
 include/soc/imx8/sc/svc/timer/api.h     |  109 ++-
 include/soc/imx8/sc/types.h             | 1487 ++++++++++++++++---------------
 24 files changed, 3057 insertions(+), 1982 deletions(-)

diff --git a/drivers/soc/imx/sc/main/ipc.c b/drivers/soc/imx/sc/main/ipc.c
index f795b24..c070089 100644
--- a/drivers/soc/imx/sc/main/ipc.c
+++ b/drivers/soc/imx/sc/main/ipc.c
@@ -54,7 +54,7 @@
 /*--------------------------------------------------------------------------*/
 /* RPC command/response                                                     */
 /*--------------------------------------------------------------------------*/
-void sc_call_rpc(sc_ipc_t handle, sc_rpc_msg_t *msg, bool no_resp)
+void sc_call_rpc(sc_ipc_t handle, sc_rpc_msg_t *msg, sc_bool_t no_resp)
 {
 	struct arm_smccc_res res;
 
@@ -214,7 +214,7 @@ void sc_ipc_read(sc_ipc_t handle, void *data)
  *
  * This function will block if the outgoing buffer is full.
  */
-void sc_ipc_write(sc_ipc_t handle, void *data)
+void sc_ipc_write(sc_ipc_t handle, const void *data)
 {
 	uint32_t *base;
 	uint8_t count = 0;
diff --git a/drivers/soc/imx/sc/main/rpc.h b/drivers/soc/imx/sc/main/rpc.h
index 85cff23..d6bc39e3 100644
--- a/drivers/soc/imx/sc/main/rpc.h
+++ b/drivers/soc/imx/sc/main/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -9,8 +9,8 @@
  * Header file for the RPC implementation.
  */
 
-#ifndef _SC_RPC_H
-#define _SC_RPC_H
+#ifndef SC_RPC_H
+#define SC_RPC_H
 
 /* Includes */
 
@@ -19,35 +19,69 @@
 
 /* Defines */
 
-#define SC_RPC_VERSION          1
-
-#define SC_RPC_MAX_MSG          8
-
-#define RPC_VER(MSG)            ((MSG)->version)
-#define RPC_SIZE(MSG)           ((MSG)->size)
-#define RPC_SVC(MSG)            ((MSG)->svc)
-#define RPC_FUNC(MSG)           ((MSG)->func)
-#define RPC_R8(MSG)             ((MSG)->func)
-#define RPC_I32(MSG, IDX)       ((MSG)->DATA.i32[(IDX) / 4])
-#define RPC_I16(MSG, IDX)       ((MSG)->DATA.i16[(IDX) / 2])
-#define RPC_I8(MSG, IDX)        ((MSG)->DATA.i8[(IDX)])
-#define RPC_U32(MSG, IDX)       ((MSG)->DATA.u32[(IDX) / 4])
-#define RPC_U16(MSG, IDX)       ((MSG)->DATA.u16[(IDX) / 2])
-#define RPC_U8(MSG, IDX)        ((MSG)->DATA.u8[(IDX)])
+#define SC_RPC_VERSION          1U
+
+#define SC_RPC_MAX_MSG          8U
+
+#define RPC_VER(MESG)           ((MESG)->version)
+#define RPC_SIZE(MESG)          ((MESG)->size)
+#define RPC_SVC(MESG)           ((MESG)->svc)
+#define RPC_FUNC(MESG)          ((MESG)->func)
+#define RPC_R8(MESG)            ((MESG)->func)
+#define RPC_I32(MESG, IDX)      ((MESG)->DATA.i32[(IDX) / 4U])
+#define RPC_I16(MESG, IDX)      ((MESG)->DATA.i16[(IDX) / 2U])
+#define RPC_I8(MESG, IDX)       ((MESG)->DATA.i8[(IDX)])
+#define RPC_U32(MESG, IDX)      ((MESG)->DATA.u32[(IDX) / 4U])
+#define RPC_U16(MESG, IDX)      ((MESG)->DATA.u16[(IDX) / 2U])
+#define RPC_U8(MESG, IDX)       ((MESG)->DATA.u8[(IDX)])
+
+#define SC_RPC_SVC_UNKNOWN      0U
+#define SC_RPC_SVC_RETURN       1U
+#define SC_RPC_SVC_PM           2U
+#define SC_RPC_SVC_RM           3U
+#define SC_RPC_SVC_TIMER        5U
+#define SC_RPC_SVC_PAD          6U
+#define SC_RPC_SVC_MISC         7U
+#define SC_RPC_SVC_IRQ          8U
+#define SC_RPC_SVC_ABORT        9U
+
+#define SC_RPC_ASYNC_STATE_RD_START      0U
+#define SC_RPC_ASYNC_STATE_RD_ACTIVE     1U
+#define SC_RPC_ASYNC_STATE_RD_DONE       2U
+#define SC_RPC_ASYNC_STATE_WR_START      3U
+#define SC_RPC_ASYNC_STATE_WR_ACTIVE     4U
+#define SC_RPC_ASYNC_STATE_WR_DONE       5U
+
+#define SC_RPC_MU_GIR_SVC       0x1U
+#define SC_RPC_MU_GIR_DBG       0x8U
+
+#define I8(X)       ((int8_t) (X))
+#define I16(X)      ((int16_t) (X))
+#define I32(X)      ((int32_t) (X))
+#define I64(X)      ((int64_t) (X))
+#define U8(X)       ((uint8_t) (X))
+#define U16(X)      ((uint16_t) (X))
+#define U32(X)      ((uint32_t) (X))
+#define U64(X)      ((uint64_t) (X))
+
+#define PTR_I8(X)   ((int8_t *) (X))
+#define PTR_I16(X)  ((int16_t *) (X))
+#define PTR_I32(X)  ((int32_t *) (X))
+#define PTR_I64(X)  ((int64_t *) (X))
+#define PTR_U8(X)   ((uint8_t *) (X))
+#define PTR_U16(X)  ((uint16_t *) (X))
+#define PTR_U32(X)  ((uint32_t *) (X))
+#define PTR_U64(X)  ((uint64_t *) (X))
+
+#define U2B(X)      (((X) != 0U) ? SC_TRUE : SC_FALSE)
+#define U2B32(X)    (((X) != 0UL) ? SC_TRUE : SC_FALSE)
+#define B2U8(X)     (((X) != SC_FALSE) ? U8(0x01U) : U8(0x00U))
+#define B2U16(X)    (((X) != SC_FALSE) ? U16(0x01U) : U16(0x00U))
+#define B2U32(X)    (((X) != SC_FALSE) ? U32(0x01U) : U32(0x00U))
 
 /* Types */
 
-typedef enum sc_rpc_svc_e {
-	SC_RPC_SVC_UNKNOWN = 0,
-	SC_RPC_SVC_RETURN = 1,
-	SC_RPC_SVC_PM = 2,
-	SC_RPC_SVC_RM = 3,
-	SC_RPC_SVC_TIMER = 5,
-	SC_RPC_SVC_PAD = 6,
-	SC_RPC_SVC_MISC = 7,
-	SC_RPC_SVC_IRQ = 8,
-	SC_RPC_SVC_ABORT = 9
-} sc_rpc_svc_t;
+typedef uint8_t sc_rpc_svc_t;
 
 typedef struct sc_rpc_msg_s {
 	uint8_t version;
@@ -55,23 +89,16 @@
 	uint8_t svc;
 	uint8_t func;
 	union {
-		int32_t i32[(SC_RPC_MAX_MSG - 1)];
-		int16_t i16[(SC_RPC_MAX_MSG - 1) * 2];
-		int8_t i8[(SC_RPC_MAX_MSG - 1) * 4];
-		uint32_t u32[(SC_RPC_MAX_MSG - 1)];
-		uint16_t u16[(SC_RPC_MAX_MSG - 1) * 2];
-		uint8_t u8[(SC_RPC_MAX_MSG - 1) * 4];
+		int32_t i32[(SC_RPC_MAX_MSG - 1U)];
+		int16_t i16[(SC_RPC_MAX_MSG - 1U) * 2U];
+		int8_t i8[(SC_RPC_MAX_MSG - 1U) * 4U];
+		uint32_t u32[(SC_RPC_MAX_MSG - 1U)];
+		uint16_t u16[(SC_RPC_MAX_MSG - 1U) * 2U];
+		uint8_t u8[(SC_RPC_MAX_MSG - 1U) * 4U];
 	} DATA;
 } sc_rpc_msg_t;
 
-typedef enum sc_rpc_async_state_e {
-	SC_RPC_ASYNC_STATE_RD_START = 0,
-	SC_RPC_ASYNC_STATE_RD_ACTIVE = 1,
-	SC_RPC_ASYNC_STATE_RD_DONE = 2,
-	SC_RPC_ASYNC_STATE_WR_START = 3,
-	SC_RPC_ASYNC_STATE_WR_ACTIVE = 4,
-	SC_RPC_ASYNC_STATE_WR_DONE = 5,
-} sc_rpc_async_state_t;
+typedef uint8_t sc_rpc_async_state_t;
 
 typedef struct sc_rpc_async_msg_s {
 	sc_rpc_async_state_t state;
@@ -90,10 +117,10 @@
  * @param[in,out] msg         handle to a message
  * @param[in]     no_resp     response flag
  *
- * If \a no_resp is false then this function waits for a response
+ * If \a no_resp is SC_FALSE then this function waits for a response
  * and returns the result in \a msg.
  */
-void sc_call_rpc(sc_ipc_t ipc, sc_rpc_msg_t *msg, bool no_resp);
+void sc_call_rpc(sc_ipc_t ipc, sc_rpc_msg_t *msg, sc_bool_t no_resp);
 
 /*!
  * This is an internal function to dispath an RPC call that has
@@ -121,4 +148,4 @@
  */
 void sc_rpc_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
 
-#endif				/* _SC_RPC_H */
+#endif				/* SC_RPC_H */
diff --git a/drivers/soc/imx/sc/svc/irq/rpc.h b/drivers/soc/imx/sc/svc/irq/rpc.h
index 93ce7c3..216659d0 100644
--- a/drivers/soc/imx/sc/svc/irq/rpc.h
+++ b/drivers/soc/imx/sc/svc/irq/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -12,23 +12,23 @@
  * @{
  */
 
-#ifndef _SC_IRQ_RPC_H
-#define _SC_IRQ_RPC_H
+#ifndef SC_IRQ_RPC_H
+#define SC_IRQ_RPC_H
 
 /* Includes */
 
 /* Defines */
 
-/* Types */
-
 /*!
- * This type is used to indicate RPC IRQ function calls.
+ * @name Defines for RPC IRQ function calls
  */
-typedef enum irq_func_e {
-	IRQ_FUNC_UNKNOWN = 0,	/* Unknown function */
-	IRQ_FUNC_ENABLE = 1,	/* Index for irq_enable() RPC call */
-	IRQ_FUNC_STATUS = 2,	/* Index for irq_status() RPC call */
-} irq_func_t;
+/*@{*/
+#define IRQ_FUNC_UNKNOWN 0	/* Unknown function */
+#define IRQ_FUNC_ENABLE 1U	/* Index for irq_enable() RPC call */
+#define IRQ_FUNC_STATUS 2U	/* Index for irq_status() RPC call */
+/*@}*/
+
+/* Types */
 
 /* Functions */
 
@@ -40,14 +40,6 @@
  */
 void irq_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
 
-/*!
- * This function translates and dispatches an IRQ RPC request.
- *
- * @param[in]     ipc         IPC handle
- * @param[in]     msg         pointer to RPC message
- */
-void irq_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
-
-#endif				/* _SC_IRQ_RPC_H */
+#endif				/* SC_IRQ_RPC_H */
 
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/irq/rpc_clnt.c b/drivers/soc/imx/sc/svc/irq/rpc_clnt.c
index 779be38..881e19a 100644
--- a/drivers/soc/imx/sc/svc/irq/rpc_clnt.c
+++ b/drivers/soc/imx/sc/svc/irq/rpc_clnt.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -28,21 +28,21 @@
 /* Local Functions */
 
 sc_err_t sc_irq_enable(sc_ipc_t ipc, sc_rsrc_t resource,
-		       sc_irq_group_t group, uint32_t mask, bool enable)
+		       sc_irq_group_t group, uint32_t mask, sc_bool_t enable)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_IRQ;
-	RPC_FUNC(&msg) = (uint8_t)IRQ_FUNC_ENABLE;
-	RPC_U32(&msg, 0) = mask;
-	RPC_U16(&msg, 4) = resource;
-	RPC_U8(&msg, 6) = group;
-	RPC_U8(&msg, 7) = (uint8_t)enable;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_IRQ);
+	RPC_FUNC(&msg) = U8(IRQ_FUNC_ENABLE);
+	RPC_U32(&msg, 0U) = U32(mask);
+	RPC_U16(&msg, 4U) = U16(resource);
+	RPC_U8(&msg, 6U) = U8(group);
+	RPC_U8(&msg, 7U) = B2U8(enable);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -55,16 +55,16 @@ sc_err_t sc_irq_status(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_IRQ;
-	RPC_FUNC(&msg) = (uint8_t)IRQ_FUNC_STATUS;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = group;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_IRQ);
+	RPC_FUNC(&msg) = U8(IRQ_FUNC_STATUS);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(group);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (status != NULL) {
-		*status = RPC_U32(&msg, 0);
+		*status = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
diff --git a/drivers/soc/imx/sc/svc/misc/rpc.h b/drivers/soc/imx/sc/svc/misc/rpc.h
index 087b6b9..df0604f 100644
--- a/drivers/soc/imx/sc/svc/misc/rpc.h
+++ b/drivers/soc/imx/sc/svc/misc/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -12,40 +12,54 @@
  * @{
  */
 
-#ifndef _SC_MISC_RPC_H
-#define _SC_MISC_RPC_H
+#ifndef SC_MISC_RPC_H
+#define SC_MISC_RPC_H
 
 /* Includes */
 
 /* Defines */
 
-/* Types */
-
 /*!
- * This type is used to indicate RPC MISC function calls.
+ * @name Defines for RPC MISC function calls
  */
-typedef enum misc_func_e {
-	MISC_FUNC_UNKNOWN = 0,	/* Unknown function */
-	MISC_FUNC_SET_CONTROL = 1,	/* Index for misc_set_control() RPC call */
-	MISC_FUNC_GET_CONTROL = 2,	/* Index for misc_get_control() RPC call */
-	MISC_FUNC_SET_MAX_DMA_GROUP = 4,	/* Index for misc_set_max_dma_group() RPC call */
-	MISC_FUNC_SET_DMA_GROUP = 5,	/* Index for misc_set_dma_group() RPC call */
-	MISC_FUNC_SECO_IMAGE_LOAD = 8,	/* Index for misc_seco_image_load() RPC call */
-	MISC_FUNC_SECO_AUTHENTICATE = 9,	/* Index for misc_seco_authenticate() RPC call */
-	MISC_FUNC_DEBUG_OUT = 10,	/* Index for misc_debug_out() RPC call */
-	MISC_FUNC_WAVEFORM_CAPTURE = 6,	/* Index for misc_waveform_capture() RPC call */
-	MISC_FUNC_BUILD_INFO = 15,	/* Index for misc_build_info() RPC call */
-	MISC_FUNC_UNIQUE_ID = 19,	/* Index for misc_unique_id() RPC call */
-	MISC_FUNC_SET_ARI = 3,	/* Index for misc_set_ari() RPC call */
-	MISC_FUNC_BOOT_STATUS = 7,	/* Index for misc_boot_status() RPC call */
-	MISC_FUNC_BOOT_DONE = 14,	/* Index for misc_boot_done() RPC call */
-	MISC_FUNC_OTP_FUSE_READ = 11,	/* Index for misc_otp_fuse_read() RPC call */
-	MISC_FUNC_OTP_FUSE_WRITE = 17,	/* Index for misc_otp_fuse_write() RPC call */
-	MISC_FUNC_SET_TEMP = 12,	/* Index for misc_set_temp() RPC call */
-	MISC_FUNC_GET_TEMP = 13,	/* Index for misc_get_temp() RPC call */
-	MISC_FUNC_GET_BOOT_DEV = 16,	/* Index for misc_get_boot_dev() RPC call */
-	MISC_FUNC_GET_BUTTON_STATUS = 18,	/* Index for misc_get_button_status() RPC call */
-} misc_func_t;
+/*@{*/
+#define MISC_FUNC_UNKNOWN 0	/* Unknown function */
+#define MISC_FUNC_SET_CONTROL 1U	/* Index for misc_set_control() RPC call */
+#define MISC_FUNC_GET_CONTROL 2U	/* Index for misc_get_control() RPC call */
+#define MISC_FUNC_SET_MAX_DMA_GROUP 4U	/* Index for misc_set_max_dma_group() RPC call */
+#define MISC_FUNC_SET_DMA_GROUP 5U	/* Index for misc_set_dma_group() RPC call */
+#define MISC_FUNC_SECO_IMAGE_LOAD 8U	/* Index for misc_seco_image_load() RPC call */
+#define MISC_FUNC_SECO_AUTHENTICATE 9U	/* Index for misc_seco_authenticate() RPC call */
+#define MISC_FUNC_SECO_FUSE_WRITE 20U	/* Index for misc_seco_fuse_write() RPC call */
+#define MISC_FUNC_SECO_ENABLE_DEBUG 21U	/* Index for misc_seco_enable_debug() RPC call */
+#define MISC_FUNC_SECO_FORWARD_LIFECYCLE 22U	/* Index for misc_seco_forward_lifecycle() RPC call */
+#define MISC_FUNC_SECO_RETURN_LIFECYCLE 23U	/* Index for misc_seco_return_lifecycle() RPC call */
+#define MISC_FUNC_SECO_BUILD_INFO 24U	/* Index for misc_seco_build_info() RPC call */
+#define MISC_FUNC_SECO_CHIP_INFO 25U	/* Index for misc_seco_chip_info() RPC call */
+#define MISC_FUNC_SECO_ATTEST_MODE 27U	/* Index for misc_seco_attest_mode() RPC call */
+#define MISC_FUNC_SECO_ATTEST 28U	/* Index for misc_seco_attest() RPC call */
+#define MISC_FUNC_SECO_GET_ATTEST_PKEY 31U	/* Index for misc_seco_get_attest_pkey() RPC call */
+#define MISC_FUNC_SECO_GET_ATTEST_SIGN 29U	/* Index for misc_seco_get_attest_sign() RPC call */
+#define MISC_FUNC_SECO_ATTEST_VERIFY 30U	/* Index for misc_seco_attest_verify() RPC call */
+#define MISC_FUNC_SECO_COMMIT 32U	/* Index for misc_seco_commit() RPC call */
+#define MISC_FUNC_DEBUG_OUT 10U	/* Index for misc_debug_out() RPC call */
+#define MISC_FUNC_WAVEFORM_CAPTURE 6U	/* Index for misc_waveform_capture() RPC call */
+#define MISC_FUNC_BUILD_INFO 15U	/* Index for misc_build_info() RPC call */
+#define MISC_FUNC_UNIQUE_ID 19U	/* Index for misc_unique_id() RPC call */
+#define MISC_FUNC_SET_ARI 3U	/* Index for misc_set_ari() RPC call */
+#define MISC_FUNC_BOOT_STATUS 7U	/* Index for misc_boot_status() RPC call */
+#define MISC_FUNC_BOOT_DONE 14U	/* Index for misc_boot_done() RPC call */
+#define MISC_FUNC_OTP_FUSE_READ 11U	/* Index for misc_otp_fuse_read() RPC call */
+#define MISC_FUNC_OTP_FUSE_WRITE 17U	/* Index for misc_otp_fuse_write() RPC call */
+#define MISC_FUNC_SET_TEMP 12U	/* Index for misc_set_temp() RPC call */
+#define MISC_FUNC_GET_TEMP 13U	/* Index for misc_get_temp() RPC call */
+#define MISC_FUNC_GET_BOOT_DEV 16U	/* Index for misc_get_boot_dev() RPC call */
+#define MISC_FUNC_GET_BOOT_TYPE 33U	/* Index for misc_get_boot_type() RPC call */
+#define MISC_FUNC_GET_BUTTON_STATUS 18U	/* Index for misc_get_button_status() RPC call */
+#define MISC_FUNC_ROMPATCH_CHECKSUM 26U	/* Index for misc_rompatch_checksum() RPC call */
+/*@}*/
+
+/* Types */
 
 /* Functions */
 
@@ -57,14 +71,6 @@
  */
 void misc_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
 
-/*!
- * This function translates and dispatches an MISC RPC request.
- *
- * @param[in]     ipc         IPC handle
- * @param[in]     msg         pointer to RPC message
- */
-void misc_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
-
-#endif				/* _SC_MISC_RPC_H */
+#endif				/* SC_MISC_RPC_H */
 
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/misc/rpc_clnt.c b/drivers/soc/imx/sc/svc/misc/rpc_clnt.c
index e1f588c..ab36e87 100644
--- a/drivers/soc/imx/sc/svc/misc/rpc_clnt.c
+++ b/drivers/soc/imx/sc/svc/misc/rpc_clnt.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -34,14 +34,14 @@ sc_err_t sc_misc_set_control(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_CONTROL;
-	RPC_U32(&msg, 0) = ctrl;
-	RPC_U32(&msg, 4) = val;
-	RPC_U16(&msg, 8) = resource;
-	RPC_SIZE(&msg) = 4;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SET_CONTROL);
+	RPC_U32(&msg, 0U) = U32(ctrl);
+	RPC_U32(&msg, 4U) = U32(val);
+	RPC_U16(&msg, 8U) = U16(resource);
+	RPC_SIZE(&msg) = 4U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -54,16 +54,16 @@ sc_err_t sc_misc_get_control(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_CONTROL;
-	RPC_U32(&msg, 0) = ctrl;
-	RPC_U16(&msg, 4) = resource;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_GET_CONTROL);
+	RPC_U32(&msg, 0U) = U32(ctrl);
+	RPC_U16(&msg, 4U) = U16(resource);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (val != NULL) {
-		*val = RPC_U32(&msg, 0);
+		*val = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -77,13 +77,13 @@ sc_err_t sc_misc_set_max_dma_group(sc_ipc_t ipc, sc_rm_pt_t pt,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_MAX_DMA_GROUP;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = max;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SET_MAX_DMA_GROUP);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(max);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -96,86 +96,323 @@ sc_err_t sc_misc_set_dma_group(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_DMA_GROUP;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = group;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SET_DMA_GROUP);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(group);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-sc_err_t sc_misc_seco_image_load(sc_ipc_t ipc, uint32_t addr_src,
-				 uint32_t addr_dst, uint32_t len, bool fw)
+sc_err_t sc_misc_seco_image_load(sc_ipc_t ipc, sc_faddr_t addr_src,
+				 sc_faddr_t addr_dst, uint32_t len,
+				 sc_bool_t fw)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SECO_IMAGE_LOAD;
-	RPC_U32(&msg, 0) = addr_src;
-	RPC_U32(&msg, 4) = addr_dst;
-	RPC_U32(&msg, 8) = len;
-	RPC_U8(&msg, 12) = (uint8_t)fw;
-	RPC_SIZE(&msg) = 5;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_IMAGE_LOAD);
+	RPC_U32(&msg, 0U) = U32(addr_src >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr_src);
+	RPC_U32(&msg, 8U) = U32(addr_dst >> 32ULL);
+	RPC_U32(&msg, 12U) = U32(addr_dst);
+	RPC_U32(&msg, 16U) = U32(len);
+	RPC_U8(&msg, 20U) = B2U8(fw);
+	RPC_SIZE(&msg) = 7U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_misc_seco_authenticate(sc_ipc_t ipc,
-				   sc_misc_seco_auth_cmd_t cmd,
-				   uint32_t addr_meta)
+				   sc_misc_seco_auth_cmd_t cmd, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_AUTHENTICATE);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_U8(&msg, 8U) = U8(cmd);
+	RPC_SIZE(&msg) = 4U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_fuse_write(sc_ipc_t ipc, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_FUSE_WRITE);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_enable_debug(sc_ipc_t ipc, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_ENABLE_DEBUG);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_forward_lifecycle(sc_ipc_t ipc, uint32_t change)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_FORWARD_LIFECYCLE);
+	RPC_U32(&msg, 0U) = U32(change);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_return_lifecycle(sc_ipc_t ipc, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_RETURN_LIFECYCLE);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+void sc_misc_seco_build_info(sc_ipc_t ipc, uint32_t *version, uint32_t *commit)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_BUILD_INFO);
+	RPC_SIZE(&msg) = 1U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	if (version != NULL) {
+		*version = RPC_U32(&msg, 0U);
+	}
+
+	if (commit != NULL) {
+		*commit = RPC_U32(&msg, 4U);
+	}
+
+	return;
+}
+
+sc_err_t sc_misc_seco_chip_info(sc_ipc_t ipc, uint16_t *lc,
+				uint16_t *monotonic, uint32_t *uid_l,
+				uint32_t *uid_h)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_CHIP_INFO);
+	RPC_SIZE(&msg) = 1U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	if (uid_l != NULL) {
+		*uid_l = RPC_U32(&msg, 0U);
+	}
+
+	if (uid_h != NULL) {
+		*uid_h = RPC_U32(&msg, 4U);
+	}
+
+	if (lc != NULL) {
+		*lc = RPC_U16(&msg, 8U);
+	}
+
+	if (monotonic != NULL) {
+		*monotonic = RPC_U16(&msg, 10U);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_attest_mode(sc_ipc_t ipc, uint32_t mode)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_ATTEST_MODE);
+	RPC_U32(&msg, 0U) = U32(mode);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_attest(sc_ipc_t ipc, uint64_t nonce)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SECO_AUTHENTICATE;
-	RPC_U32(&msg, 0) = addr_meta;
-	RPC_U8(&msg, 4) = cmd;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_ATTEST);
+	RPC_U32(&msg, 0U) = U32(nonce >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(nonce);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
+sc_err_t sc_misc_seco_get_attest_pkey(sc_ipc_t ipc, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_GET_ATTEST_PKEY);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_get_attest_sign(sc_ipc_t ipc, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_GET_ATTEST_SIGN);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_attest_verify(sc_ipc_t ipc, sc_faddr_t addr)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_ATTEST_VERIFY);
+	RPC_U32(&msg, 0U) = U32(addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_misc_seco_commit(sc_ipc_t ipc, uint32_t *info)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SECO_COMMIT);
+	RPC_U32(&msg, 0U) = *PTR_U32(info);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	*info = RPC_U32(&msg, 0U);
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
 void sc_misc_debug_out(sc_ipc_t ipc, uint8_t ch)
 {
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_DEBUG_OUT;
-	RPC_U8(&msg, 0) = ch;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_DEBUG_OUT);
+	RPC_U8(&msg, 0U) = U8(ch);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	return;
 }
 
-sc_err_t sc_misc_waveform_capture(sc_ipc_t ipc, bool enable)
+sc_err_t sc_misc_waveform_capture(sc_ipc_t ipc, sc_bool_t enable)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_WAVEFORM_CAPTURE;
-	RPC_U8(&msg, 0) = (uint8_t)enable;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_WAVEFORM_CAPTURE);
+	RPC_U8(&msg, 0U) = B2U8(enable);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -186,18 +423,18 @@ void sc_misc_build_info(sc_ipc_t ipc, uint32_t *build, uint32_t *commit)
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_BUILD_INFO;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_BUILD_INFO);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (build != NULL) {
-		*build = RPC_U32(&msg, 0);
+		*build = RPC_U32(&msg, 0U);
 	}
 
 	if (commit != NULL) {
-		*commit = RPC_U32(&msg, 4);
+		*commit = RPC_U32(&msg, 4U);
 	}
 
 	return;
@@ -208,39 +445,39 @@ void sc_misc_unique_id(sc_ipc_t ipc, uint32_t *id_l, uint32_t *id_h)
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_UNIQUE_ID;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_UNIQUE_ID);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (id_l != NULL) {
-		*id_l = RPC_U32(&msg, 0);
+		*id_l = RPC_U32(&msg, 0U);
 	}
 
 	if (id_h != NULL) {
-		*id_h = RPC_U32(&msg, 4);
+		*id_h = RPC_U32(&msg, 4U);
 	}
 
 	return;
 }
 
 sc_err_t sc_misc_set_ari(sc_ipc_t ipc, sc_rsrc_t resource,
-			 sc_rsrc_t resource_mst, uint16_t ari, bool enable)
+			 sc_rsrc_t resource_mst, uint16_t ari, sc_bool_t enable)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_ARI;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U16(&msg, 2) = resource_mst;
-	RPC_U16(&msg, 4) = ari;
-	RPC_U8(&msg, 6) = (uint8_t)enable;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SET_ARI);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U16(&msg, 2U) = U16(resource_mst);
+	RPC_U16(&msg, 4U) = U16(ari);
+	RPC_U8(&msg, 6U) = B2U8(enable);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -251,12 +488,12 @@ void sc_misc_boot_status(sc_ipc_t ipc, sc_misc_boot_status_t status)
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_BOOT_STATUS;
-	RPC_U8(&msg, 0) = status;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_BOOT_STATUS);
+	RPC_U8(&msg, 0U) = U8(status);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, true);
+	sc_call_rpc(ipc, &msg, SC_TRUE);
 
 	return;
 }
@@ -267,12 +504,12 @@ sc_err_t sc_misc_boot_done(sc_ipc_t ipc, sc_rsrc_t cpu)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_BOOT_DONE;
-	RPC_U16(&msg, 0) = cpu;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_BOOT_DONE);
+	RPC_U16(&msg, 0U) = U16(cpu);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -284,15 +521,15 @@ sc_err_t sc_misc_otp_fuse_read(sc_ipc_t ipc, uint32_t word, uint32_t *val)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_OTP_FUSE_READ;
-	RPC_U32(&msg, 0) = word;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_OTP_FUSE_READ);
+	RPC_U32(&msg, 0U) = U32(word);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (val != NULL) {
-		*val = RPC_U32(&msg, 0);
+		*val = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -305,13 +542,13 @@ sc_err_t sc_misc_otp_fuse_write(sc_ipc_t ipc, uint32_t word, uint32_t val)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_OTP_FUSE_WRITE;
-	RPC_U32(&msg, 0) = word;
-	RPC_U32(&msg, 4) = val;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_OTP_FUSE_WRITE);
+	RPC_U32(&msg, 0U) = U32(word);
+	RPC_U32(&msg, 4U) = U32(val);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -324,15 +561,15 @@ sc_err_t sc_misc_set_temp(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_SET_TEMP;
-	RPC_U16(&msg, 0) = resource;
-	RPC_I16(&msg, 2) = celsius;
-	RPC_U8(&msg, 4) = temp;
-	RPC_I8(&msg, 5) = tenths;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_SET_TEMP);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_I16(&msg, 2U) = I16(celsius);
+	RPC_U8(&msg, 4U) = U8(temp);
+	RPC_I8(&msg, 5U) = I8(tenths);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -346,21 +583,21 @@ sc_err_t sc_misc_get_temp(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_TEMP;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = temp;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_GET_TEMP);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(temp);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (celsius != NULL) {
-		*celsius = RPC_I16(&msg, 0);
+		*celsius = RPC_I16(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
 	if (tenths != NULL) {
-		*tenths = RPC_I8(&msg, 2);
+		*tenths = RPC_I8(&msg, 2U);
 	}
 
 	return (sc_err_t)result;
@@ -371,35 +608,75 @@ void sc_misc_get_boot_dev(sc_ipc_t ipc, sc_rsrc_t *dev)
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_BOOT_DEV;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_GET_BOOT_DEV);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (dev != NULL) {
-		*dev = RPC_U16(&msg, 0);
+		*dev = RPC_U16(&msg, 0U);
 	}
 
 	return;
 }
 
-void sc_misc_get_button_status(sc_ipc_t ipc, bool *status)
+sc_err_t sc_misc_get_boot_type(sc_ipc_t ipc, sc_misc_bt_t *type)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_GET_BOOT_TYPE);
+	RPC_SIZE(&msg) = 1U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	if (type != NULL) {
+		*type = RPC_U8(&msg, 0U);
+	}
+
+	return (sc_err_t)result;
+}
+
+void sc_misc_get_button_status(sc_ipc_t ipc, sc_bool_t *status)
 {
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_MISC;
-	RPC_FUNC(&msg) = (uint8_t)MISC_FUNC_GET_BUTTON_STATUS;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_GET_BUTTON_STATUS);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (status != NULL) {
-		*status = RPC_U8(&msg, 0);
+		*status = U2B(RPC_U8(&msg, 0U));
 	}
 
 	return;
 }
 
+sc_err_t sc_misc_rompatch_checksum(sc_ipc_t ipc, uint32_t *checksum)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_MISC);
+	RPC_FUNC(&msg) = U8(MISC_FUNC_ROMPATCH_CHECKSUM);
+	RPC_SIZE(&msg) = 1U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	if (checksum != NULL) {
+		*checksum = RPC_U32(&msg, 0U);
+	}
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/pad/rpc.h b/drivers/soc/imx/sc/svc/pad/rpc.h
index ee8fe3b..b00b9c1 100644
--- a/drivers/soc/imx/sc/svc/pad/rpc.h
+++ b/drivers/soc/imx/sc/svc/pad/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -12,37 +12,37 @@
  * @{
  */
 
-#ifndef _SC_PAD_RPC_H
-#define _SC_PAD_RPC_H
+#ifndef SC_PAD_RPC_H
+#define SC_PAD_RPC_H
 
 /* Includes */
 
 /* Defines */
 
-/* Types */
-
 /*!
- * This type is used to indicate RPC PAD function calls.
+ * @name Defines for RPC PAD function calls
  */
-typedef enum pad_func_e {
-	PAD_FUNC_UNKNOWN = 0,	/* Unknown function */
-	PAD_FUNC_SET_MUX = 1,	/* Index for pad_set_mux() RPC call */
-	PAD_FUNC_GET_MUX = 6,	/* Index for pad_get_mux() RPC call */
-	PAD_FUNC_SET_GP = 2,	/* Index for pad_set_gp() RPC call */
-	PAD_FUNC_GET_GP = 7,	/* Index for pad_get_gp() RPC call */
-	PAD_FUNC_SET_WAKEUP = 4,	/* Index for pad_set_wakeup() RPC call */
-	PAD_FUNC_GET_WAKEUP = 9,	/* Index for pad_get_wakeup() RPC call */
-	PAD_FUNC_SET_ALL = 5,	/* Index for pad_set_all() RPC call */
-	PAD_FUNC_GET_ALL = 10,	/* Index for pad_get_all() RPC call */
-	PAD_FUNC_SET = 15,	/* Index for pad_set() RPC call */
-	PAD_FUNC_GET = 16,	/* Index for pad_get() RPC call */
-	PAD_FUNC_SET_GP_28FDSOI = 11,	/* Index for pad_set_gp_28fdsoi() RPC call */
-	PAD_FUNC_GET_GP_28FDSOI = 12,	/* Index for pad_get_gp_28fdsoi() RPC call */
-	PAD_FUNC_SET_GP_28FDSOI_HSIC = 3,	/* Index for pad_set_gp_28fdsoi_hsic() RPC call */
-	PAD_FUNC_GET_GP_28FDSOI_HSIC = 8,	/* Index for pad_get_gp_28fdsoi_hsic() RPC call */
-	PAD_FUNC_SET_GP_28FDSOI_COMP = 13,	/* Index for pad_set_gp_28fdsoi_comp() RPC call */
-	PAD_FUNC_GET_GP_28FDSOI_COMP = 14,	/* Index for pad_get_gp_28fdsoi_comp() RPC call */
-} pad_func_t;
+/*@{*/
+#define PAD_FUNC_UNKNOWN 0	/* Unknown function */
+#define PAD_FUNC_SET_MUX 1U	/* Index for pad_set_mux() RPC call */
+#define PAD_FUNC_GET_MUX 6U	/* Index for pad_get_mux() RPC call */
+#define PAD_FUNC_SET_GP 2U	/* Index for pad_set_gp() RPC call */
+#define PAD_FUNC_GET_GP 7U	/* Index for pad_get_gp() RPC call */
+#define PAD_FUNC_SET_WAKEUP 4U	/* Index for pad_set_wakeup() RPC call */
+#define PAD_FUNC_GET_WAKEUP 9U	/* Index for pad_get_wakeup() RPC call */
+#define PAD_FUNC_SET_ALL 5U	/* Index for pad_set_all() RPC call */
+#define PAD_FUNC_GET_ALL 10U	/* Index for pad_get_all() RPC call */
+#define PAD_FUNC_SET 15U	/* Index for pad_set() RPC call */
+#define PAD_FUNC_GET 16U	/* Index for pad_get() RPC call */
+#define PAD_FUNC_SET_GP_28FDSOI 11U	/* Index for pad_set_gp_28fdsoi() RPC call */
+#define PAD_FUNC_GET_GP_28FDSOI 12U	/* Index for pad_get_gp_28fdsoi() RPC call */
+#define PAD_FUNC_SET_GP_28FDSOI_HSIC 3U	/* Index for pad_set_gp_28fdsoi_hsic() RPC call */
+#define PAD_FUNC_GET_GP_28FDSOI_HSIC 8U	/* Index for pad_get_gp_28fdsoi_hsic() RPC call */
+#define PAD_FUNC_SET_GP_28FDSOI_COMP 13U	/* Index for pad_set_gp_28fdsoi_comp() RPC call */
+#define PAD_FUNC_GET_GP_28FDSOI_COMP 14U	/* Index for pad_get_gp_28fdsoi_comp() RPC call */
+/*@}*/
+
+/* Types */
 
 /* Functions */
 
@@ -54,14 +54,6 @@
  */
 void pad_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
 
-/*!
- * This function translates and dispatches an PAD RPC request.
- *
- * @param[in]     ipc         IPC handle
- * @param[in]     msg         pointer to RPC message
- */
-void pad_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
-
-#endif				/* _SC_PAD_RPC_H */
+#endif				/* SC_PAD_RPC_H */
 
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/pad/rpc_clnt.c b/drivers/soc/imx/sc/svc/pad/rpc_clnt.c
index 90fb390..0267745 100644
--- a/drivers/soc/imx/sc/svc/pad/rpc_clnt.c
+++ b/drivers/soc/imx/sc/svc/pad/rpc_clnt.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -34,15 +34,15 @@ sc_err_t sc_pad_set_mux(sc_ipc_t ipc, sc_pad_t pad,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_MUX;
-	RPC_U16(&msg, 0) = pad;
-	RPC_U8(&msg, 2) = mux;
-	RPC_U8(&msg, 3) = config;
-	RPC_U8(&msg, 4) = iso;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_MUX);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_U8(&msg, 2U) = U8(mux);
+	RPC_U8(&msg, 3U) = U8(config);
+	RPC_U8(&msg, 4U) = U8(iso);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -56,24 +56,24 @@ sc_err_t sc_pad_get_mux(sc_ipc_t ipc, sc_pad_t pad,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_MUX;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_MUX);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (mux != NULL) {
-		*mux = RPC_U8(&msg, 0);
+		*mux = RPC_U8(&msg, 0U);
 	}
 
 	if (config != NULL) {
-		*config = RPC_U8(&msg, 1);
+		*config = RPC_U8(&msg, 1U);
 	}
 
 	if (iso != NULL) {
-		*iso = RPC_U8(&msg, 2);
+		*iso = RPC_U8(&msg, 2U);
 	}
 
 	return (sc_err_t)result;
@@ -85,13 +85,13 @@ sc_err_t sc_pad_set_gp(sc_ipc_t ipc, sc_pad_t pad, uint32_t ctrl)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP;
-	RPC_U32(&msg, 0) = ctrl;
-	RPC_U16(&msg, 4) = pad;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_GP);
+	RPC_U32(&msg, 0U) = U32(ctrl);
+	RPC_U16(&msg, 4U) = U16(pad);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -103,15 +103,15 @@ sc_err_t sc_pad_get_gp(sc_ipc_t ipc, sc_pad_t pad, uint32_t *ctrl)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_GP);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (ctrl != NULL) {
-		*ctrl = RPC_U32(&msg, 0);
+		*ctrl = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -124,13 +124,13 @@ sc_err_t sc_pad_set_wakeup(sc_ipc_t ipc, sc_pad_t pad, sc_pad_wakeup_t wakeup)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_WAKEUP;
-	RPC_U16(&msg, 0) = pad;
-	RPC_U8(&msg, 2) = wakeup;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_WAKEUP);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_U8(&msg, 2U) = U8(wakeup);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -142,16 +142,16 @@ sc_err_t sc_pad_get_wakeup(sc_ipc_t ipc, sc_pad_t pad, sc_pad_wakeup_t *wakeup)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_WAKEUP;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_WAKEUP);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (wakeup != NULL) {
-		*wakeup = RPC_U8(&msg, 0);
+		*wakeup = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -165,17 +165,17 @@ sc_err_t sc_pad_set_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t mux,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_ALL;
-	RPC_U32(&msg, 0) = ctrl;
-	RPC_U16(&msg, 4) = pad;
-	RPC_U8(&msg, 6) = mux;
-	RPC_U8(&msg, 7) = config;
-	RPC_U8(&msg, 8) = iso;
-	RPC_U8(&msg, 9) = wakeup;
-	RPC_SIZE(&msg) = 4;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_ALL);
+	RPC_U32(&msg, 0U) = U32(ctrl);
+	RPC_U16(&msg, 4U) = U16(pad);
+	RPC_U8(&msg, 6U) = U8(mux);
+	RPC_U8(&msg, 7U) = U8(config);
+	RPC_U8(&msg, 8U) = U8(iso);
+	RPC_U8(&msg, 9U) = U8(wakeup);
+	RPC_SIZE(&msg) = 4U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -189,32 +189,32 @@ sc_err_t sc_pad_get_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t *mux,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_ALL;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_ALL);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (ctrl != NULL) {
-		*ctrl = RPC_U32(&msg, 0);
+		*ctrl = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
 	if (mux != NULL) {
-		*mux = RPC_U8(&msg, 4);
+		*mux = RPC_U8(&msg, 4U);
 	}
 
 	if (config != NULL) {
-		*config = RPC_U8(&msg, 5);
+		*config = RPC_U8(&msg, 5U);
 	}
 
 	if (iso != NULL) {
-		*iso = RPC_U8(&msg, 6);
+		*iso = RPC_U8(&msg, 6U);
 	}
 
 	if (wakeup != NULL) {
-		*wakeup = RPC_U8(&msg, 7);
+		*wakeup = RPC_U8(&msg, 7U);
 	}
 
 	return (sc_err_t)result;
@@ -226,13 +226,13 @@ sc_err_t sc_pad_set(sc_ipc_t ipc, sc_pad_t pad, uint32_t val)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET;
-	RPC_U32(&msg, 0) = val;
-	RPC_U16(&msg, 4) = pad;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET);
+	RPC_U32(&msg, 0U) = U32(val);
+	RPC_U16(&msg, 4U) = U16(pad);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -244,15 +244,15 @@ sc_err_t sc_pad_get(sc_ipc_t ipc, sc_pad_t pad, uint32_t *val)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (val != NULL) {
-		*val = RPC_U32(&msg, 0);
+		*val = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -266,14 +266,14 @@ sc_err_t sc_pad_set_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP_28FDSOI;
-	RPC_U16(&msg, 0) = pad;
-	RPC_U8(&msg, 2) = dse;
-	RPC_U8(&msg, 3) = ps;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_GP_28FDSOI);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_U8(&msg, 2U) = U8(dse);
+	RPC_U8(&msg, 3U) = U8(ps);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -287,164 +287,164 @@ sc_err_t sc_pad_get_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP_28FDSOI;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_GP_28FDSOI);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (dse != NULL) {
-		*dse = RPC_U8(&msg, 0);
+		*dse = RPC_U8(&msg, 0U);
 	}
 
 	if (ps != NULL) {
-		*ps = RPC_U8(&msg, 1);
+		*ps = RPC_U8(&msg, 1U);
 	}
 
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_pad_set_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
-				    sc_pad_28fdsoi_dse_t dse, bool hys,
-				    sc_pad_28fdsoi_pus_t pus, bool pke,
-				    bool pue)
+				    sc_pad_28fdsoi_dse_t dse, sc_bool_t hys,
+				    sc_pad_28fdsoi_pus_t pus, sc_bool_t pke,
+				    sc_bool_t pue)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP_28FDSOI_HSIC;
-	RPC_U16(&msg, 0) = pad;
-	RPC_U8(&msg, 2) = dse;
-	RPC_U8(&msg, 3) = pus;
-	RPC_U8(&msg, 4) = (uint8_t)hys;
-	RPC_U8(&msg, 5) = (uint8_t)pke;
-	RPC_U8(&msg, 6) = (uint8_t)pue;
-	RPC_SIZE(&msg) = 3;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_GP_28FDSOI_HSIC);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_U8(&msg, 2U) = U8(dse);
+	RPC_U8(&msg, 3U) = U8(pus);
+	RPC_U8(&msg, 4U) = B2U8(hys);
+	RPC_U8(&msg, 5U) = B2U8(pke);
+	RPC_U8(&msg, 6U) = B2U8(pue);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_pad_get_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
-				    sc_pad_28fdsoi_dse_t *dse, bool *hys,
-				    sc_pad_28fdsoi_pus_t *pus, bool *pke,
-				    bool *pue)
+				    sc_pad_28fdsoi_dse_t *dse, sc_bool_t *hys,
+				    sc_pad_28fdsoi_pus_t *pus, sc_bool_t *pke,
+				    sc_bool_t *pue)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP_28FDSOI_HSIC;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_GP_28FDSOI_HSIC);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (dse != NULL) {
-		*dse = RPC_U8(&msg, 0);
+		*dse = RPC_U8(&msg, 0U);
 	}
 
 	if (pus != NULL) {
-		*pus = RPC_U8(&msg, 1);
+		*pus = RPC_U8(&msg, 1U);
 	}
 
 	if (hys != NULL) {
-		*hys = RPC_U8(&msg, 2);
+		*hys = U2B(RPC_U8(&msg, 2U));
 	}
 
 	if (pke != NULL) {
-		*pke = RPC_U8(&msg, 3);
+		*pke = U2B(RPC_U8(&msg, 3U));
 	}
 
 	if (pue != NULL) {
-		*pue = RPC_U8(&msg, 4);
+		*pue = U2B(RPC_U8(&msg, 4U));
 	}
 
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_pad_set_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
-				    uint8_t compen, bool fastfrz,
+				    uint8_t compen, sc_bool_t fastfrz,
 				    uint8_t rasrcp, uint8_t rasrcn,
-				    bool nasrc_sel, bool psw_ovr)
+				    sc_bool_t nasrc_sel, sc_bool_t psw_ovr)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_SET_GP_28FDSOI_COMP;
-	RPC_U16(&msg, 0) = pad;
-	RPC_U8(&msg, 2) = compen;
-	RPC_U8(&msg, 3) = rasrcp;
-	RPC_U8(&msg, 4) = rasrcn;
-	RPC_U8(&msg, 5) = (uint8_t)fastfrz;
-	RPC_U8(&msg, 6) = (uint8_t)nasrc_sel;
-	RPC_U8(&msg, 7) = (uint8_t)psw_ovr;
-	RPC_SIZE(&msg) = 3;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_SET_GP_28FDSOI_COMP);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_U8(&msg, 2U) = U8(compen);
+	RPC_U8(&msg, 3U) = U8(rasrcp);
+	RPC_U8(&msg, 4U) = U8(rasrcn);
+	RPC_U8(&msg, 5U) = B2U8(fastfrz);
+	RPC_U8(&msg, 6U) = B2U8(nasrc_sel);
+	RPC_U8(&msg, 7U) = B2U8(psw_ovr);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_pad_get_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
-				    uint8_t *compen, bool *fastfrz,
+				    uint8_t *compen, sc_bool_t *fastfrz,
 				    uint8_t *rasrcp, uint8_t *rasrcn,
-				    bool *nasrc_sel, bool *compok,
-				    uint8_t *nasrc, bool *psw_ovr)
+				    sc_bool_t *nasrc_sel, sc_bool_t *compok,
+				    uint8_t *nasrc, sc_bool_t *psw_ovr)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PAD;
-	RPC_FUNC(&msg) = (uint8_t)PAD_FUNC_GET_GP_28FDSOI_COMP;
-	RPC_U16(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PAD);
+	RPC_FUNC(&msg) = U8(PAD_FUNC_GET_GP_28FDSOI_COMP);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (compen != NULL) {
-		*compen = RPC_U8(&msg, 0);
+		*compen = RPC_U8(&msg, 0U);
 	}
 
 	if (rasrcp != NULL) {
-		*rasrcp = RPC_U8(&msg, 1);
+		*rasrcp = RPC_U8(&msg, 1U);
 	}
 
 	if (rasrcn != NULL) {
-		*rasrcn = RPC_U8(&msg, 2);
+		*rasrcn = RPC_U8(&msg, 2U);
 	}
 
 	if (nasrc != NULL) {
-		*nasrc = RPC_U8(&msg, 3);
+		*nasrc = RPC_U8(&msg, 3U);
 	}
 
 	if (fastfrz != NULL) {
-		*fastfrz = RPC_U8(&msg, 4);
+		*fastfrz = U2B(RPC_U8(&msg, 4U));
 	}
 
 	if (nasrc_sel != NULL) {
-		*nasrc_sel = RPC_U8(&msg, 5);
+		*nasrc_sel = U2B(RPC_U8(&msg, 5U));
 	}
 
 	if (compok != NULL) {
-		*compok = RPC_U8(&msg, 6);
+		*compok = U2B(RPC_U8(&msg, 6U));
 	}
 
 	if (psw_ovr != NULL) {
-		*psw_ovr = RPC_U8(&msg, 7);
+		*psw_ovr = U2B(RPC_U8(&msg, 7U));
 	}
 
 	return (sc_err_t)result;
diff --git a/drivers/soc/imx/sc/svc/pm/rpc.h b/drivers/soc/imx/sc/svc/pm/rpc.h
index e83db74..037923a 100644
--- a/drivers/soc/imx/sc/svc/pm/rpc.h
+++ b/drivers/soc/imx/sc/svc/pm/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -12,40 +12,44 @@
  * @{
  */
 
-#ifndef _SC_PM_RPC_H
-#define _SC_PM_RPC_H
+#ifndef SC_PM_RPC_H
+#define SC_PM_RPC_H
 
 /* Includes */
 
 /* Defines */
 
-/* Types */
-
 /*!
- * This type is used to indicate RPC PM function calls.
+ * @name Defines for RPC PM function calls
  */
-typedef enum pm_func_e {
-	PM_FUNC_UNKNOWN = 0,	/* Unknown function */
-	PM_FUNC_SET_SYS_POWER_MODE = 19,	/* Index for pm_set_sys_power_mode() RPC call */
-	PM_FUNC_SET_PARTITION_POWER_MODE = 1,	/* Index for pm_set_partition_power_mode() RPC call */
-	PM_FUNC_GET_SYS_POWER_MODE = 2,	/* Index for pm_get_sys_power_mode() RPC call */
-	PM_FUNC_SET_RESOURCE_POWER_MODE = 3,	/* Index for pm_set_resource_power_mode() RPC call */
-	PM_FUNC_GET_RESOURCE_POWER_MODE = 4,	/* Index for pm_get_resource_power_mode() RPC call */
-	PM_FUNC_REQ_LOW_POWER_MODE = 16,	/* Index for pm_req_low_power_mode() RPC call */
-	PM_FUNC_SET_CPU_RESUME_ADDR = 17,	/* Index for pm_set_cpu_resume_addr() RPC call */
-	PM_FUNC_REQ_SYS_IF_POWER_MODE = 18,	/* Index for pm_req_sys_if_power_mode() RPC call */
-	PM_FUNC_SET_CLOCK_RATE = 5,	/* Index for pm_set_clock_rate() RPC call */
-	PM_FUNC_GET_CLOCK_RATE = 6,	/* Index for pm_get_clock_rate() RPC call */
-	PM_FUNC_CLOCK_ENABLE = 7,	/* Index for pm_clock_enable() RPC call */
-	PM_FUNC_SET_CLOCK_PARENT = 14,	/* Index for pm_set_clock_parent() RPC call */
-	PM_FUNC_GET_CLOCK_PARENT = 15,	/* Index for pm_get_clock_parent() RPC call */
-	PM_FUNC_RESET = 13,	/* Index for pm_reset() RPC call */
-	PM_FUNC_RESET_REASON = 10,	/* Index for pm_reset_reason() RPC call */
-	PM_FUNC_BOOT = 8,	/* Index for pm_boot() RPC call */
-	PM_FUNC_REBOOT = 9,	/* Index for pm_reboot() RPC call */
-	PM_FUNC_REBOOT_PARTITION = 12,	/* Index for pm_reboot_partition() RPC call */
-	PM_FUNC_CPU_START = 11,	/* Index for pm_cpu_start() RPC call */
-} pm_func_t;
+/*@{*/
+#define PM_FUNC_UNKNOWN 0	/* Unknown function */
+#define PM_FUNC_SET_SYS_POWER_MODE 19U	/* Index for pm_set_sys_power_mode() RPC call */
+#define PM_FUNC_SET_PARTITION_POWER_MODE 1U	/* Index for pm_set_partition_power_mode() RPC call */
+#define PM_FUNC_GET_SYS_POWER_MODE 2U	/* Index for pm_get_sys_power_mode() RPC call */
+#define PM_FUNC_SET_RESOURCE_POWER_MODE 3U	/* Index for pm_set_resource_power_mode() RPC call */
+#define PM_FUNC_SET_RESOURCE_POWER_MODE_ALL 22U	/* Index for pm_set_resource_power_mode_all() RPC call */
+#define PM_FUNC_GET_RESOURCE_POWER_MODE 4U	/* Index for pm_get_resource_power_mode() RPC call */
+#define PM_FUNC_REQ_LOW_POWER_MODE 16U	/* Index for pm_req_low_power_mode() RPC call */
+#define PM_FUNC_REQ_CPU_LOW_POWER_MODE 20U	/* Index for pm_req_cpu_low_power_mode() RPC call */
+#define PM_FUNC_SET_CPU_RESUME_ADDR 17U	/* Index for pm_set_cpu_resume_addr() RPC call */
+#define PM_FUNC_SET_CPU_RESUME 21U	/* Index for pm_set_cpu_resume() RPC call */
+#define PM_FUNC_REQ_SYS_IF_POWER_MODE 18U	/* Index for pm_req_sys_if_power_mode() RPC call */
+#define PM_FUNC_SET_CLOCK_RATE 5U	/* Index for pm_set_clock_rate() RPC call */
+#define PM_FUNC_GET_CLOCK_RATE 6U	/* Index for pm_get_clock_rate() RPC call */
+#define PM_FUNC_CLOCK_ENABLE 7U	/* Index for pm_clock_enable() RPC call */
+#define PM_FUNC_SET_CLOCK_PARENT 14U	/* Index for pm_set_clock_parent() RPC call */
+#define PM_FUNC_GET_CLOCK_PARENT 15U	/* Index for pm_get_clock_parent() RPC call */
+#define PM_FUNC_RESET 13U	/* Index for pm_reset() RPC call */
+#define PM_FUNC_RESET_REASON 10U	/* Index for pm_reset_reason() RPC call */
+#define PM_FUNC_BOOT 8U		/* Index for pm_boot() RPC call */
+#define PM_FUNC_REBOOT 9U	/* Index for pm_reboot() RPC call */
+#define PM_FUNC_REBOOT_PARTITION 12U	/* Index for pm_reboot_partition() RPC call */
+#define PM_FUNC_CPU_START 11U	/* Index for pm_cpu_start() RPC call */
+#define PM_FUNC_CPU_RESET 23U	/* Index for pm_cpu_reset() RPC call */
+/*@}*/
+
+/* Types */
 
 /* Functions */
 
@@ -57,14 +61,6 @@
  */
 void pm_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
 
-/*!
- * This function translates and dispatches an PM RPC request.
- *
- * @param[in]     ipc         IPC handle
- * @param[in]     msg         pointer to RPC message
- */
-void pm_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
-
-#endif				/* _SC_PM_RPC_H */
+#endif				/* SC_PM_RPC_H */
 
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/pm/rpc_clnt.c b/drivers/soc/imx/sc/svc/pm/rpc_clnt.c
index b4b651e..acbf99c 100644
--- a/drivers/soc/imx/sc/svc/pm/rpc_clnt.c
+++ b/drivers/soc/imx/sc/svc/pm/rpc_clnt.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -33,12 +33,12 @@ sc_err_t sc_pm_set_sys_power_mode(sc_ipc_t ipc, sc_pm_power_mode_t mode)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_SYS_POWER_MODE;
-	RPC_U8(&msg, 0) = mode;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_SYS_POWER_MODE);
+	RPC_U8(&msg, 0U) = U8(mode);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -51,13 +51,13 @@ sc_err_t sc_pm_set_partition_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_PARTITION_POWER_MODE;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = mode;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_PARTITION_POWER_MODE);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(mode);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -70,16 +70,16 @@ sc_err_t sc_pm_get_sys_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_SYS_POWER_MODE;
-	RPC_U8(&msg, 0) = pt;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_GET_SYS_POWER_MODE);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (mode != NULL) {
-		*mode = RPC_U8(&msg, 0);
+		*mode = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -92,13 +92,35 @@ sc_err_t sc_pm_set_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_RESOURCE_POWER_MODE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = mode;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_RESOURCE_POWER_MODE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(mode);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_resource_power_mode_all(sc_ipc_t ipc,
+					   sc_rm_pt_t pt,
+					   sc_pm_power_mode_t mode,
+					   sc_rsrc_t exclude)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_RESOURCE_POWER_MODE_ALL);
+	RPC_U16(&msg, 0U) = U16(exclude);
+	RPC_U8(&msg, 2U) = U8(pt);
+	RPC_U8(&msg, 3U) = U8(mode);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -111,16 +133,16 @@ sc_err_t sc_pm_get_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_RESOURCE_POWER_MODE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_GET_RESOURCE_POWER_MODE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (mode != NULL) {
-		*mode = RPC_U8(&msg, 0);
+		*mode = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -133,13 +155,34 @@ sc_err_t sc_pm_req_low_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REQ_LOW_POWER_MODE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = mode;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_REQ_LOW_POWER_MODE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(mode);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_req_cpu_low_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				      sc_pm_power_mode_t mode,
+				      sc_pm_wake_src_t wake_src)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_REQ_CPU_LOW_POWER_MODE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(mode);
+	RPC_U8(&msg, 3U) = U8(wake_src);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -152,14 +195,35 @@ sc_err_t sc_pm_set_cpu_resume_addr(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_CPU_RESUME_ADDR;
-	RPC_U32(&msg, 0) = (uint32_t)(address >> 32u);
-	RPC_U32(&msg, 4) = (uint32_t)address;
-	RPC_U16(&msg, 8) = resource;
-	RPC_SIZE(&msg) = 4;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_CPU_RESUME_ADDR);
+	RPC_U32(&msg, 0U) = U32(address >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(address);
+	RPC_U16(&msg, 8U) = U16(resource);
+	RPC_SIZE(&msg) = 4U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_pm_set_cpu_resume(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_bool_t isPrimary, sc_faddr_t address)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_CPU_RESUME);
+	RPC_U32(&msg, 0U) = U32(address >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(address);
+	RPC_U16(&msg, 8U) = U16(resource);
+	RPC_U8(&msg, 10U) = B2U8(isPrimary);
+	RPC_SIZE(&msg) = 4U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -174,15 +238,15 @@ sc_err_t sc_pm_req_sys_if_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REQ_SYS_IF_POWER_MODE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = sys_if;
-	RPC_U8(&msg, 3) = hpm;
-	RPC_U8(&msg, 4) = lpm;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_REQ_SYS_IF_POWER_MODE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(sys_if);
+	RPC_U8(&msg, 3U) = U8(hpm);
+	RPC_U8(&msg, 4U) = U8(lpm);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -195,16 +259,16 @@ sc_err_t sc_pm_set_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_CLOCK_RATE;
-	RPC_U32(&msg, 0) = *rate;
-	RPC_U16(&msg, 4) = resource;
-	RPC_U8(&msg, 6) = clk;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_CLOCK_RATE);
+	RPC_U32(&msg, 0U) = *PTR_U32(rate);
+	RPC_U16(&msg, 4U) = U16(resource);
+	RPC_U8(&msg, 6U) = U8(clk);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
-	*rate = RPC_U32(&msg, 0);
+	*rate = RPC_U32(&msg, 0U);
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
@@ -216,16 +280,16 @@ sc_err_t sc_pm_get_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_CLOCK_RATE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = clk;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_GET_CLOCK_RATE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(clk);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (rate != NULL) {
-		*rate = RPC_U32(&msg, 0);
+		*rate = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -233,21 +297,21 @@ sc_err_t sc_pm_get_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
 }
 
 sc_err_t sc_pm_clock_enable(sc_ipc_t ipc, sc_rsrc_t resource,
-			    sc_pm_clk_t clk, bool enable, bool autog)
+			    sc_pm_clk_t clk, sc_bool_t enable, sc_bool_t autog)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_CLOCK_ENABLE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = clk;
-	RPC_U8(&msg, 3) = (uint8_t)enable;
-	RPC_U8(&msg, 4) = (uint8_t)autog;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_CLOCK_ENABLE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(clk);
+	RPC_U8(&msg, 3U) = B2U8(enable);
+	RPC_U8(&msg, 4U) = B2U8(autog);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -260,14 +324,14 @@ sc_err_t sc_pm_set_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_SET_CLOCK_PARENT;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = clk;
-	RPC_U8(&msg, 3) = parent;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_SET_CLOCK_PARENT);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(clk);
+	RPC_U8(&msg, 3U) = U8(parent);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -280,17 +344,17 @@ sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_GET_CLOCK_PARENT;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = clk;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_GET_CLOCK_PARENT);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(clk);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (parent != NULL) {
-		*parent = RPC_U8(&msg, 0);
+		*parent = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -302,12 +366,12 @@ sc_err_t sc_pm_reset(sc_ipc_t ipc, sc_pm_reset_type_t type)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_RESET;
-	RPC_U8(&msg, 0) = type;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_RESET);
+	RPC_U8(&msg, 0U) = U8(type);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -319,15 +383,15 @@ sc_err_t sc_pm_reset_reason(sc_ipc_t ipc, sc_pm_reset_reason_t *reason)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_RESET_REASON;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_RESET_REASON);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (reason != NULL) {
-		*reason = RPC_U8(&msg, 0);
+		*reason = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -341,17 +405,17 @@ sc_err_t sc_pm_boot(sc_ipc_t ipc, sc_rm_pt_t pt,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_BOOT;
-	RPC_U32(&msg, 0) = (uint32_t)(boot_addr >> 32u);
-	RPC_U32(&msg, 4) = (uint32_t)boot_addr;
-	RPC_U16(&msg, 8) = resource_cpu;
-	RPC_U16(&msg, 10) = resource_mu;
-	RPC_U16(&msg, 12) = resource_dev;
-	RPC_U8(&msg, 14) = pt;
-	RPC_SIZE(&msg) = 5;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_BOOT);
+	RPC_U32(&msg, 0U) = U32(boot_addr >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(boot_addr);
+	RPC_U16(&msg, 8U) = U16(resource_cpu);
+	RPC_U16(&msg, 10U) = U16(resource_mu);
+	RPC_U16(&msg, 12U) = U16(resource_dev);
+	RPC_U8(&msg, 14U) = U8(pt);
+	RPC_SIZE(&msg) = 5U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -362,12 +426,12 @@ void sc_pm_reboot(sc_ipc_t ipc, sc_pm_reset_type_t type)
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REBOOT;
-	RPC_U8(&msg, 0) = type;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_REBOOT);
+	RPC_U8(&msg, 0U) = U8(type);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, true);
+	sc_call_rpc(ipc, &msg, SC_TRUE);
 
 	return;
 }
@@ -379,37 +443,54 @@ sc_err_t sc_pm_reboot_partition(sc_ipc_t ipc, sc_rm_pt_t pt,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_REBOOT_PARTITION;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = type;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_REBOOT_PARTITION);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(type);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-sc_err_t sc_pm_cpu_start(sc_ipc_t ipc, sc_rsrc_t resource, bool enable,
+sc_err_t sc_pm_cpu_start(sc_ipc_t ipc, sc_rsrc_t resource, sc_bool_t enable,
 			 sc_faddr_t address)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_PM;
-	RPC_FUNC(&msg) = (uint8_t)PM_FUNC_CPU_START;
-	RPC_U32(&msg, 0) = (uint32_t)(address >> 32u);
-	RPC_U32(&msg, 4) = (uint32_t)address;
-	RPC_U16(&msg, 8) = resource;
-	RPC_U8(&msg, 10) = (uint8_t)enable;
-	RPC_SIZE(&msg) = 4;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_CPU_START);
+	RPC_U32(&msg, 0U) = U32(address >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(address);
+	RPC_U16(&msg, 8U) = U16(resource);
+	RPC_U8(&msg, 10U) = B2U8(enable);
+	RPC_SIZE(&msg) = 4U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
+void sc_pm_cpu_reset(sc_ipc_t ipc, sc_rsrc_t resource, sc_faddr_t address)
+{
+	sc_rpc_msg_t msg;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_PM);
+	RPC_FUNC(&msg) = U8(PM_FUNC_CPU_RESET);
+	RPC_U32(&msg, 0U) = U32(address >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(address);
+	RPC_U16(&msg, 8U) = U16(resource);
+	RPC_SIZE(&msg) = 4U;
+
+	sc_call_rpc(ipc, &msg, SC_TRUE);
+
+	return;
+}
+
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/rm/rpc.h b/drivers/soc/imx/sc/svc/rm/rpc.h
index 457b018..9b2fa11 100644
--- a/drivers/soc/imx/sc/svc/rm/rpc.h
+++ b/drivers/soc/imx/sc/svc/rm/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -12,52 +12,53 @@
  * @{
  */
 
-#ifndef _SC_RM_RPC_H
-#define _SC_RM_RPC_H
+#ifndef SC_RM_RPC_H
+#define SC_RM_RPC_H
 
 /* Includes */
 
 /* Defines */
 
-/* Types */
-
 /*!
- * This type is used to indicate RPC RM function calls.
+ * @name Defines for RPC RM function calls
  */
-typedef enum rm_func_e {
-	RM_FUNC_UNKNOWN = 0,	/* Unknown function */
-	RM_FUNC_PARTITION_ALLOC = 1,	/* Index for rm_partition_alloc() RPC call */
-	RM_FUNC_SET_CONFIDENTIAL = 31,	/* Index for rm_set_confidential() RPC call */
-	RM_FUNC_PARTITION_FREE = 2,	/* Index for rm_partition_free() RPC call */
-	RM_FUNC_GET_DID = 26,	/* Index for rm_get_did() RPC call */
-	RM_FUNC_PARTITION_STATIC = 3,	/* Index for rm_partition_static() RPC call */
-	RM_FUNC_PARTITION_LOCK = 4,	/* Index for rm_partition_lock() RPC call */
-	RM_FUNC_GET_PARTITION = 5,	/* Index for rm_get_partition() RPC call */
-	RM_FUNC_SET_PARENT = 6,	/* Index for rm_set_parent() RPC call */
-	RM_FUNC_MOVE_ALL = 7,	/* Index for rm_move_all() RPC call */
-	RM_FUNC_ASSIGN_RESOURCE = 8,	/* Index for rm_assign_resource() RPC call */
-	RM_FUNC_SET_RESOURCE_MOVABLE = 9,	/* Index for rm_set_resource_movable() RPC call */
-	RM_FUNC_SET_SUBSYS_RSRC_MOVABLE = 28,	/* Index for rm_set_subsys_rsrc_movable() RPC call */
-	RM_FUNC_SET_MASTER_ATTRIBUTES = 10,	/* Index for rm_set_master_attributes() RPC call */
-	RM_FUNC_SET_MASTER_SID = 11,	/* Index for rm_set_master_sid() RPC call */
-	RM_FUNC_SET_PERIPHERAL_PERMISSIONS = 12,	/* Index for rm_set_peripheral_permissions() RPC call */
-	RM_FUNC_IS_RESOURCE_OWNED = 13,	/* Index for rm_is_resource_owned() RPC call */
-	RM_FUNC_IS_RESOURCE_MASTER = 14,	/* Index for rm_is_resource_master() RPC call */
-	RM_FUNC_IS_RESOURCE_PERIPHERAL = 15,	/* Index for rm_is_resource_peripheral() RPC call */
-	RM_FUNC_GET_RESOURCE_INFO = 16,	/* Index for rm_get_resource_info() RPC call */
-	RM_FUNC_MEMREG_ALLOC = 17,	/* Index for rm_memreg_alloc() RPC call */
-	RM_FUNC_MEMREG_SPLIT = 29,	/* Index for rm_memreg_split() RPC call */
-	RM_FUNC_MEMREG_FREE = 18,	/* Index for rm_memreg_free() RPC call */
-	RM_FUNC_FIND_MEMREG = 30,	/* Index for rm_find_memreg() RPC call */
-	RM_FUNC_ASSIGN_MEMREG = 19,	/* Index for rm_assign_memreg() RPC call */
-	RM_FUNC_SET_MEMREG_PERMISSIONS = 20,	/* Index for rm_set_memreg_permissions() RPC call */
-	RM_FUNC_IS_MEMREG_OWNED = 21,	/* Index for rm_is_memreg_owned() RPC call */
-	RM_FUNC_GET_MEMREG_INFO = 22,	/* Index for rm_get_memreg_info() RPC call */
-	RM_FUNC_ASSIGN_PAD = 23,	/* Index for rm_assign_pad() RPC call */
-	RM_FUNC_SET_PAD_MOVABLE = 24,	/* Index for rm_set_pad_movable() RPC call */
-	RM_FUNC_IS_PAD_OWNED = 25,	/* Index for rm_is_pad_owned() RPC call */
-	RM_FUNC_DUMP = 27,	/* Index for rm_dump() RPC call */
-} rm_func_t;
+/*@{*/
+#define RM_FUNC_UNKNOWN 0	/* Unknown function */
+#define RM_FUNC_PARTITION_ALLOC 1U	/* Index for rm_partition_alloc() RPC call */
+#define RM_FUNC_SET_CONFIDENTIAL 31U	/* Index for rm_set_confidential() RPC call */
+#define RM_FUNC_PARTITION_FREE 2U	/* Index for rm_partition_free() RPC call */
+#define RM_FUNC_GET_DID 26U	/* Index for rm_get_did() RPC call */
+#define RM_FUNC_PARTITION_STATIC 3U	/* Index for rm_partition_static() RPC call */
+#define RM_FUNC_PARTITION_LOCK 4U	/* Index for rm_partition_lock() RPC call */
+#define RM_FUNC_GET_PARTITION 5U	/* Index for rm_get_partition() RPC call */
+#define RM_FUNC_SET_PARENT 6U	/* Index for rm_set_parent() RPC call */
+#define RM_FUNC_MOVE_ALL 7U	/* Index for rm_move_all() RPC call */
+#define RM_FUNC_ASSIGN_RESOURCE 8U	/* Index for rm_assign_resource() RPC call */
+#define RM_FUNC_SET_RESOURCE_MOVABLE 9U	/* Index for rm_set_resource_movable() RPC call */
+#define RM_FUNC_SET_SUBSYS_RSRC_MOVABLE 28U	/* Index for rm_set_subsys_rsrc_movable() RPC call */
+#define RM_FUNC_SET_MASTER_ATTRIBUTES 10U	/* Index for rm_set_master_attributes() RPC call */
+#define RM_FUNC_SET_MASTER_SID 11U	/* Index for rm_set_master_sid() RPC call */
+#define RM_FUNC_SET_PERIPHERAL_PERMISSIONS 12U	/* Index for rm_set_peripheral_permissions() RPC call */
+#define RM_FUNC_IS_RESOURCE_OWNED 13U	/* Index for rm_is_resource_owned() RPC call */
+#define RM_FUNC_IS_RESOURCE_MASTER 14U	/* Index for rm_is_resource_master() RPC call */
+#define RM_FUNC_IS_RESOURCE_PERIPHERAL 15U	/* Index for rm_is_resource_peripheral() RPC call */
+#define RM_FUNC_GET_RESOURCE_INFO 16U	/* Index for rm_get_resource_info() RPC call */
+#define RM_FUNC_MEMREG_ALLOC 17U	/* Index for rm_memreg_alloc() RPC call */
+#define RM_FUNC_MEMREG_SPLIT 29U	/* Index for rm_memreg_split() RPC call */
+#define RM_FUNC_MEMREG_FRAG 32U	/* Index for rm_memreg_frag() RPC call */
+#define RM_FUNC_MEMREG_FREE 18U	/* Index for rm_memreg_free() RPC call */
+#define RM_FUNC_FIND_MEMREG 30U	/* Index for rm_find_memreg() RPC call */
+#define RM_FUNC_ASSIGN_MEMREG 19U	/* Index for rm_assign_memreg() RPC call */
+#define RM_FUNC_SET_MEMREG_PERMISSIONS 20U	/* Index for rm_set_memreg_permissions() RPC call */
+#define RM_FUNC_IS_MEMREG_OWNED 21U	/* Index for rm_is_memreg_owned() RPC call */
+#define RM_FUNC_GET_MEMREG_INFO 22U	/* Index for rm_get_memreg_info() RPC call */
+#define RM_FUNC_ASSIGN_PAD 23U	/* Index for rm_assign_pad() RPC call */
+#define RM_FUNC_SET_PAD_MOVABLE 24U	/* Index for rm_set_pad_movable() RPC call */
+#define RM_FUNC_IS_PAD_OWNED 25U	/* Index for rm_is_pad_owned() RPC call */
+#define RM_FUNC_DUMP 27U	/* Index for rm_dump() RPC call */
+/*@}*/
+
+/* Types */
 
 /* Functions */
 
@@ -69,14 +70,6 @@
  */
 void rm_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
 
-/*!
- * This function translates and dispatches an RM RPC request.
- *
- * @param[in]     ipc         IPC handle
- * @param[in]     msg         pointer to RPC message
- */
-void rm_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
-
-#endif				/* _SC_RM_RPC_H */
+#endif				/* SC_RM_RPC_H */
 
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/rm/rpc_clnt.c b/drivers/soc/imx/sc/svc/rm/rpc_clnt.c
index a9bb6ba..a245023 100644
--- a/drivers/soc/imx/sc/svc/rm/rpc_clnt.c
+++ b/drivers/soc/imx/sc/svc/rm/rpc_clnt.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -26,46 +26,46 @@
 
 /* Local Functions */
 
-sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, bool secure,
-			       bool isolated, bool restricted, bool grant,
-			       bool coherent)
+sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, sc_bool_t secure,
+			       sc_bool_t isolated, sc_bool_t restricted,
+			       sc_bool_t grant, sc_bool_t coherent)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_ALLOC;
-	RPC_U8(&msg, 0) = (uint8_t)secure;
-	RPC_U8(&msg, 1) = (uint8_t)isolated;
-	RPC_U8(&msg, 2) = (uint8_t)restricted;
-	RPC_U8(&msg, 3) = (uint8_t)grant;
-	RPC_U8(&msg, 4) = (uint8_t)coherent;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_PARTITION_ALLOC);
+	RPC_U8(&msg, 0U) = B2U8(secure);
+	RPC_U8(&msg, 1U) = B2U8(isolated);
+	RPC_U8(&msg, 2U) = B2U8(restricted);
+	RPC_U8(&msg, 3U) = B2U8(grant);
+	RPC_U8(&msg, 4U) = B2U8(coherent);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (pt != NULL) {
-		*pt = RPC_U8(&msg, 0);
+		*pt = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
 }
 
-sc_err_t sc_rm_set_confidential(sc_ipc_t ipc, sc_rm_pt_t pt, bool retro)
+sc_err_t sc_rm_set_confidential(sc_ipc_t ipc, sc_rm_pt_t pt, sc_bool_t retro)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_CONFIDENTIAL;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = (uint8_t)retro;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_CONFIDENTIAL);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = B2U8(retro);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -77,12 +77,12 @@ sc_err_t sc_rm_partition_free(sc_ipc_t ipc, sc_rm_pt_t pt)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_FREE;
-	RPC_U8(&msg, 0) = pt;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_PARTITION_FREE);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -94,11 +94,11 @@ sc_rm_did_t sc_rm_get_did(sc_ipc_t ipc)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_DID;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_GET_DID);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_rm_did_t) result;
@@ -110,13 +110,13 @@ sc_err_t sc_rm_partition_static(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_did_t did)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_STATIC;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = did;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_PARTITION_STATIC);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(did);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -128,12 +128,12 @@ sc_err_t sc_rm_partition_lock(sc_ipc_t ipc, sc_rm_pt_t pt)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_PARTITION_LOCK;
-	RPC_U8(&msg, 0) = pt;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_PARTITION_LOCK);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -145,15 +145,15 @@ sc_err_t sc_rm_get_partition(sc_ipc_t ipc, sc_rm_pt_t *pt)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_PARTITION;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_GET_PARTITION);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (pt != NULL) {
-		*pt = RPC_U8(&msg, 0);
+		*pt = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -165,34 +165,34 @@ sc_err_t sc_rm_set_parent(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_pt_t pt_parent)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_PARENT;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = pt_parent;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_PARENT);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(pt_parent);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
-			bool move_rsrc, bool move_pads)
+			sc_bool_t move_rsrc, sc_bool_t move_pads)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MOVE_ALL;
-	RPC_U8(&msg, 0) = pt_src;
-	RPC_U8(&msg, 1) = pt_dst;
-	RPC_U8(&msg, 2) = (uint8_t)move_rsrc;
-	RPC_U8(&msg, 3) = (uint8_t)move_pads;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_MOVE_ALL);
+	RPC_U8(&msg, 0U) = U8(pt_src);
+	RPC_U8(&msg, 1U) = U8(pt_dst);
+	RPC_U8(&msg, 2U) = B2U8(move_rsrc);
+	RPC_U8(&msg, 3U) = B2U8(move_pads);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -204,52 +204,52 @@ sc_err_t sc_rm_assign_resource(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rsrc_t resource)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_ASSIGN_RESOURCE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = pt;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_ASSIGN_RESOURCE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(pt);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_rm_set_resource_movable(sc_ipc_t ipc, sc_rsrc_t resource_fst,
-				    sc_rsrc_t resource_lst, bool movable)
+				    sc_rsrc_t resource_lst, sc_bool_t movable)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_RESOURCE_MOVABLE;
-	RPC_U16(&msg, 0) = resource_fst;
-	RPC_U16(&msg, 2) = resource_lst;
-	RPC_U8(&msg, 4) = (uint8_t)movable;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_RESOURCE_MOVABLE);
+	RPC_U16(&msg, 0U) = U16(resource_fst);
+	RPC_U16(&msg, 2U) = U16(resource_lst);
+	RPC_U8(&msg, 4U) = B2U8(movable);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_rm_set_subsys_rsrc_movable(sc_ipc_t ipc, sc_rsrc_t resource,
-				       bool movable)
+				       sc_bool_t movable)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_SUBSYS_RSRC_MOVABLE;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = (uint8_t)movable;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_SUBSYS_RSRC_MOVABLE);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = B2U8(movable);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -257,21 +257,21 @@ sc_err_t sc_rm_set_subsys_rsrc_movable(sc_ipc_t ipc, sc_rsrc_t resource,
 
 sc_err_t sc_rm_set_master_attributes(sc_ipc_t ipc, sc_rsrc_t resource,
 				     sc_rm_spa_t sa, sc_rm_spa_t pa,
-				     bool smmu_bypass)
+				     sc_bool_t smmu_bypass)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_MASTER_ATTRIBUTES;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = sa;
-	RPC_U8(&msg, 3) = pa;
-	RPC_U8(&msg, 4) = (uint8_t)smmu_bypass;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_MASTER_ATTRIBUTES);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(sa);
+	RPC_U8(&msg, 3U) = U8(pa);
+	RPC_U8(&msg, 4U) = B2U8(smmu_bypass);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -283,13 +283,13 @@ sc_err_t sc_rm_set_master_sid(sc_ipc_t ipc, sc_rsrc_t resource, sc_rm_sid_t sid)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_MASTER_SID;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U16(&msg, 2) = sid;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_MASTER_SID);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U16(&msg, 2U) = U16(sid);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -302,68 +302,68 @@ sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_PERIPHERAL_PERMISSIONS;
-	RPC_U16(&msg, 0) = resource;
-	RPC_U8(&msg, 2) = pt;
-	RPC_U8(&msg, 3) = perm;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_PERIPHERAL_PERMISSIONS);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_U8(&msg, 2U) = U8(pt);
+	RPC_U8(&msg, 3U) = U8(perm);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-bool sc_rm_is_resource_owned(sc_ipc_t ipc, sc_rsrc_t resource)
+sc_bool_t sc_rm_is_resource_owned(sc_ipc_t ipc, sc_rsrc_t resource)
 {
 	sc_rpc_msg_t msg;
-	uint8_t result;
+	sc_bool_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_RESOURCE_OWNED;
-	RPC_U16(&msg, 0) = resource;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_IS_RESOURCE_OWNED);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
-	result = RPC_R8(&msg);
-	return (bool)result;
+	result = U2B(RPC_R8(&msg));
+	return result;
 }
 
-bool sc_rm_is_resource_master(sc_ipc_t ipc, sc_rsrc_t resource)
+sc_bool_t sc_rm_is_resource_master(sc_ipc_t ipc, sc_rsrc_t resource)
 {
 	sc_rpc_msg_t msg;
-	uint8_t result;
+	sc_bool_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_RESOURCE_MASTER;
-	RPC_U16(&msg, 0) = resource;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_IS_RESOURCE_MASTER);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
-	result = RPC_R8(&msg);
-	return (bool)result;
+	result = U2B(RPC_R8(&msg));
+	return result;
 }
 
-bool sc_rm_is_resource_peripheral(sc_ipc_t ipc, sc_rsrc_t resource)
+sc_bool_t sc_rm_is_resource_peripheral(sc_ipc_t ipc, sc_rsrc_t resource)
 {
 	sc_rpc_msg_t msg;
-	uint8_t result;
+	sc_bool_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_RESOURCE_PERIPHERAL;
-	RPC_U16(&msg, 0) = resource;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_IS_RESOURCE_PERIPHERAL);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
-	result = RPC_R8(&msg);
-	return (bool)result;
+	result = U2B(RPC_R8(&msg));
+	return result;
 }
 
 sc_err_t sc_rm_get_resource_info(sc_ipc_t ipc, sc_rsrc_t resource,
@@ -373,15 +373,15 @@ sc_err_t sc_rm_get_resource_info(sc_ipc_t ipc, sc_rsrc_t resource,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_RESOURCE_INFO;
-	RPC_U16(&msg, 0) = resource;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_GET_RESOURCE_INFO);
+	RPC_U16(&msg, 0U) = U16(resource);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (sid != NULL) {
-		*sid = RPC_U16(&msg, 0);
+		*sid = RPC_U16(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -395,19 +395,19 @@ sc_err_t sc_rm_memreg_alloc(sc_ipc_t ipc, sc_rm_mr_t *mr,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MEMREG_ALLOC;
-	RPC_U32(&msg, 0) = (uint32_t)(addr_start >> 32u);
-	RPC_U32(&msg, 4) = (uint32_t)addr_start;
-	RPC_U32(&msg, 8) = (uint32_t)(addr_end >> 32u);
-	RPC_U32(&msg, 12) = (uint32_t)addr_end;
-	RPC_SIZE(&msg) = 5;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_MEMREG_ALLOC);
+	RPC_U32(&msg, 0U) = U32(addr_start >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr_start);
+	RPC_U32(&msg, 8U) = U32(addr_end >> 32ULL);
+	RPC_U32(&msg, 12U) = U32(addr_end);
+	RPC_SIZE(&msg) = 5U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (mr != NULL) {
-		*mr = RPC_U8(&msg, 0);
+		*mr = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -421,20 +421,45 @@ sc_err_t sc_rm_memreg_split(sc_ipc_t ipc, sc_rm_mr_t mr,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MEMREG_SPLIT;
-	RPC_U32(&msg, 0) = (uint32_t)(addr_start >> 32u);
-	RPC_U32(&msg, 4) = (uint32_t)addr_start;
-	RPC_U32(&msg, 8) = (uint32_t)(addr_end >> 32u);
-	RPC_U32(&msg, 12) = (uint32_t)addr_end;
-	RPC_U8(&msg, 16) = mr;
-	RPC_SIZE(&msg) = 6;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_MEMREG_SPLIT);
+	RPC_U32(&msg, 0U) = U32(addr_start >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr_start);
+	RPC_U32(&msg, 8U) = U32(addr_end >> 32ULL);
+	RPC_U32(&msg, 12U) = U32(addr_end);
+	RPC_U8(&msg, 16U) = U8(mr);
+	RPC_SIZE(&msg) = 6U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (mr_ret != NULL) {
-		*mr_ret = RPC_U8(&msg, 0);
+		*mr_ret = RPC_U8(&msg, 0U);
+	}
+
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_rm_memreg_frag(sc_ipc_t ipc, sc_rm_mr_t *mr_ret,
+			   sc_faddr_t addr_start, sc_faddr_t addr_end)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_MEMREG_FRAG);
+	RPC_U32(&msg, 0U) = U32(addr_start >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr_start);
+	RPC_U32(&msg, 8U) = U32(addr_end >> 32ULL);
+	RPC_U32(&msg, 12U) = U32(addr_end);
+	RPC_SIZE(&msg) = 5U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	if (mr_ret != NULL) {
+		*mr_ret = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -446,12 +471,12 @@ sc_err_t sc_rm_memreg_free(sc_ipc_t ipc, sc_rm_mr_t mr)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_MEMREG_FREE;
-	RPC_U8(&msg, 0) = mr;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_MEMREG_FREE);
+	RPC_U8(&msg, 0U) = U8(mr);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -464,19 +489,19 @@ sc_err_t sc_rm_find_memreg(sc_ipc_t ipc, sc_rm_mr_t *mr,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_FIND_MEMREG;
-	RPC_U32(&msg, 0) = (uint32_t)(addr_start >> 32u);
-	RPC_U32(&msg, 4) = (uint32_t)addr_start;
-	RPC_U32(&msg, 8) = (uint32_t)(addr_end >> 32u);
-	RPC_U32(&msg, 12) = (uint32_t)addr_end;
-	RPC_SIZE(&msg) = 5;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_FIND_MEMREG);
+	RPC_U32(&msg, 0U) = U32(addr_start >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(addr_start);
+	RPC_U32(&msg, 8U) = U32(addr_end >> 32ULL);
+	RPC_U32(&msg, 12U) = U32(addr_end);
+	RPC_SIZE(&msg) = 5U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	if (mr != NULL) {
-		*mr = RPC_U8(&msg, 0);
+		*mr = RPC_U8(&msg, 0U);
 	}
 
 	return (sc_err_t)result;
@@ -488,13 +513,13 @@ sc_err_t sc_rm_assign_memreg(sc_ipc_t ipc, sc_rm_pt_t pt, sc_rm_mr_t mr)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_ASSIGN_MEMREG;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = mr;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_ASSIGN_MEMREG);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(mr);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -507,34 +532,34 @@ sc_err_t sc_rm_set_memreg_permissions(sc_ipc_t ipc, sc_rm_mr_t mr,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_MEMREG_PERMISSIONS;
-	RPC_U8(&msg, 0) = mr;
-	RPC_U8(&msg, 1) = pt;
-	RPC_U8(&msg, 2) = perm;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_MEMREG_PERMISSIONS);
+	RPC_U8(&msg, 0U) = U8(mr);
+	RPC_U8(&msg, 1U) = U8(pt);
+	RPC_U8(&msg, 2U) = U8(perm);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-bool sc_rm_is_memreg_owned(sc_ipc_t ipc, sc_rm_mr_t mr)
+sc_bool_t sc_rm_is_memreg_owned(sc_ipc_t ipc, sc_rm_mr_t mr)
 {
 	sc_rpc_msg_t msg;
-	uint8_t result;
+	sc_bool_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_MEMREG_OWNED;
-	RPC_U8(&msg, 0) = mr;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_IS_MEMREG_OWNED);
+	RPC_U8(&msg, 0U) = U8(mr);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
-	result = RPC_R8(&msg);
-	return (bool)result;
+	result = U2B(RPC_R8(&msg));
+	return result;
 }
 
 sc_err_t sc_rm_get_memreg_info(sc_ipc_t ipc, sc_rm_mr_t mr,
@@ -544,21 +569,21 @@ sc_err_t sc_rm_get_memreg_info(sc_ipc_t ipc, sc_rm_mr_t mr,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_GET_MEMREG_INFO;
-	RPC_U8(&msg, 0) = mr;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_GET_MEMREG_INFO);
+	RPC_U8(&msg, 0U) = U8(mr);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (addr_start != NULL) {
 		*addr_start =
-		    ((uint64_t) RPC_U32(&msg, 0) << 32u) | RPC_U32(&msg, 4);
+		    ((uint64_t) RPC_U32(&msg, 0U) << 32U) | RPC_U32(&msg, 4U);
 	}
 
 	if (addr_end != NULL) {
 		*addr_end =
-		    ((uint64_t) RPC_U32(&msg, 8) << 32u) | RPC_U32(&msg, 12);
+		    ((uint64_t) RPC_U32(&msg, 8U) << 32U) | RPC_U32(&msg, 12U);
 	}
 
 	result = RPC_R8(&msg);
@@ -571,53 +596,53 @@ sc_err_t sc_rm_assign_pad(sc_ipc_t ipc, sc_rm_pt_t pt, sc_pad_t pad)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_ASSIGN_PAD;
-	RPC_U16(&msg, 0) = pad;
-	RPC_U8(&msg, 2) = pt;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_ASSIGN_PAD);
+	RPC_U16(&msg, 0U) = U16(pad);
+	RPC_U8(&msg, 2U) = U8(pt);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
 sc_err_t sc_rm_set_pad_movable(sc_ipc_t ipc, sc_pad_t pad_fst,
-			       sc_pad_t pad_lst, bool movable)
+			       sc_pad_t pad_lst, sc_bool_t movable)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_SET_PAD_MOVABLE;
-	RPC_U16(&msg, 0) = pad_fst;
-	RPC_U16(&msg, 2) = pad_lst;
-	RPC_U8(&msg, 4) = (uint8_t)movable;
-	RPC_SIZE(&msg) = 3;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_SET_PAD_MOVABLE);
+	RPC_U16(&msg, 0U) = U16(pad_fst);
+	RPC_U16(&msg, 2U) = U16(pad_lst);
+	RPC_U8(&msg, 4U) = B2U8(movable);
+	RPC_SIZE(&msg) = 3U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-bool sc_rm_is_pad_owned(sc_ipc_t ipc, sc_pad_t pad)
+sc_bool_t sc_rm_is_pad_owned(sc_ipc_t ipc, sc_pad_t pad)
 {
 	sc_rpc_msg_t msg;
-	uint8_t result;
+	sc_bool_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_IS_PAD_OWNED;
-	RPC_U8(&msg, 0) = pad;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_IS_PAD_OWNED);
+	RPC_U8(&msg, 0U) = U8(pad);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
-	result = RPC_R8(&msg);
-	return (bool)result;
+	result = U2B(RPC_R8(&msg));
+	return result;
 }
 
 void sc_rm_dump(sc_ipc_t ipc)
@@ -625,11 +650,11 @@ void sc_rm_dump(sc_ipc_t ipc)
 	sc_rpc_msg_t msg;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_RM;
-	RPC_FUNC(&msg) = (uint8_t)RM_FUNC_DUMP;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_RM);
+	RPC_FUNC(&msg) = U8(RM_FUNC_DUMP);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	return;
 }
diff --git a/drivers/soc/imx/sc/svc/timer/rpc.h b/drivers/soc/imx/sc/svc/timer/rpc.h
index 42413a0..3d15d87 100644
--- a/drivers/soc/imx/sc/svc/timer/rpc.h
+++ b/drivers/soc/imx/sc/svc/timer/rpc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -12,34 +12,39 @@
  * @{
  */
 
-#ifndef _SC_TIMER_RPC_H
-#define _SC_TIMER_RPC_H
+#ifndef SC_TIMER_RPC_H
+#define SC_TIMER_RPC_H
 
 /* Includes */
 
 /* Defines */
 
-/* Types */
-
 /*!
- * This type is used to indicate RPC TIMER function calls.
+ * @name Defines for RPC TIMER function calls
  */
-typedef enum timer_func_e {
-	TIMER_FUNC_UNKNOWN = 0,	/* Unknown function */
-	TIMER_FUNC_SET_WDOG_TIMEOUT = 1,	/* Index for timer_set_wdog_timeout() RPC call */
-	TIMER_FUNC_SET_WDOG_PRE_TIMEOUT = 12,	/* Index for timer_set_wdog_pre_timeout() RPC call */
-	TIMER_FUNC_START_WDOG = 2,	/* Index for timer_start_wdog() RPC call */
-	TIMER_FUNC_STOP_WDOG = 3,	/* Index for timer_stop_wdog() RPC call */
-	TIMER_FUNC_PING_WDOG = 4,	/* Index for timer_ping_wdog() RPC call */
-	TIMER_FUNC_GET_WDOG_STATUS = 5,	/* Index for timer_get_wdog_status() RPC call */
-	TIMER_FUNC_PT_GET_WDOG_STATUS = 13,	/* Index for timer_pt_get_wdog_status() RPC call */
-	TIMER_FUNC_SET_WDOG_ACTION = 10,	/* Index for timer_set_wdog_action() RPC call */
-	TIMER_FUNC_SET_RTC_TIME = 6,	/* Index for timer_set_rtc_time() RPC call */
-	TIMER_FUNC_GET_RTC_TIME = 7,	/* Index for timer_get_rtc_time() RPC call */
-	TIMER_FUNC_GET_RTC_SEC1970 = 9,	/* Index for timer_get_rtc_sec1970() RPC call */
-	TIMER_FUNC_SET_RTC_ALARM = 8,	/* Index for timer_set_rtc_alarm() RPC call */
-	TIMER_FUNC_SET_RTC_CALB = 11,	/* Index for timer_set_rtc_calb() RPC call */
-} timer_func_t;
+/*@{*/
+#define TIMER_FUNC_UNKNOWN 0	/* Unknown function */
+#define TIMER_FUNC_SET_WDOG_TIMEOUT 1U	/* Index for timer_set_wdog_timeout() RPC call */
+#define TIMER_FUNC_SET_WDOG_PRE_TIMEOUT 12U	/* Index for timer_set_wdog_pre_timeout() RPC call */
+#define TIMER_FUNC_START_WDOG 2U	/* Index for timer_start_wdog() RPC call */
+#define TIMER_FUNC_STOP_WDOG 3U	/* Index for timer_stop_wdog() RPC call */
+#define TIMER_FUNC_PING_WDOG 4U	/* Index for timer_ping_wdog() RPC call */
+#define TIMER_FUNC_GET_WDOG_STATUS 5U	/* Index for timer_get_wdog_status() RPC call */
+#define TIMER_FUNC_PT_GET_WDOG_STATUS 13U	/* Index for timer_pt_get_wdog_status() RPC call */
+#define TIMER_FUNC_SET_WDOG_ACTION 10U	/* Index for timer_set_wdog_action() RPC call */
+#define TIMER_FUNC_SET_RTC_TIME 6U	/* Index for timer_set_rtc_time() RPC call */
+#define TIMER_FUNC_GET_RTC_TIME 7U	/* Index for timer_get_rtc_time() RPC call */
+#define TIMER_FUNC_GET_RTC_SEC1970 9U	/* Index for timer_get_rtc_sec1970() RPC call */
+#define TIMER_FUNC_SET_RTC_ALARM 8U	/* Index for timer_set_rtc_alarm() RPC call */
+#define TIMER_FUNC_SET_RTC_PERIODIC_ALARM 14U	/* Index for timer_set_rtc_periodic_alarm() RPC call */
+#define TIMER_FUNC_CANCEL_RTC_ALARM 15U	/* Index for timer_cancel_rtc_alarm() RPC call */
+#define TIMER_FUNC_SET_RTC_CALB 11U	/* Index for timer_set_rtc_calb() RPC call */
+#define TIMER_FUNC_SET_SYSCTR_ALARM 16U	/* Index for timer_set_sysctr_alarm() RPC call */
+#define TIMER_FUNC_SET_SYSCTR_PERIODIC_ALARM 17U	/* Index for timer_set_sysctr_periodic_alarm() RPC call */
+#define TIMER_FUNC_CANCEL_SYSCTR_ALARM 18U	/* Index for timer_cancel_sysctr_alarm() RPC call */
+/*@}*/
+
+/* Types */
 
 /* Functions */
 
@@ -51,14 +56,6 @@
  */
 void timer_dispatch(sc_rm_pt_t caller_pt, sc_rpc_msg_t *msg);
 
-/*!
- * This function translates and dispatches an TIMER RPC request.
- *
- * @param[in]     ipc         IPC handle
- * @param[in]     msg         pointer to RPC message
- */
-void timer_xlate(sc_ipc_t ipc, sc_rpc_msg_t *msg);
-
-#endif				/* _SC_TIMER_RPC_H */
+#endif				/* SC_TIMER_RPC_H */
 
 /**@}*/
diff --git a/drivers/soc/imx/sc/svc/timer/rpc_clnt.c b/drivers/soc/imx/sc/svc/timer/rpc_clnt.c
index badb79e..fe9fdab 100644
--- a/drivers/soc/imx/sc/svc/timer/rpc_clnt.c
+++ b/drivers/soc/imx/sc/svc/timer/rpc_clnt.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -33,12 +33,12 @@ sc_err_t sc_timer_set_wdog_timeout(sc_ipc_t ipc, sc_timer_wdog_time_t timeout)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_WDOG_TIMEOUT;
-	RPC_U32(&msg, 0) = timeout;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_WDOG_TIMEOUT);
+	RPC_U32(&msg, 0U) = U32(timeout);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -51,29 +51,29 @@ sc_err_t sc_timer_set_wdog_pre_timeout(sc_ipc_t ipc,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_WDOG_PRE_TIMEOUT;
-	RPC_U32(&msg, 0) = pre_timeout;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_WDOG_PRE_TIMEOUT);
+	RPC_U32(&msg, 0U) = U32(pre_timeout);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-sc_err_t sc_timer_start_wdog(sc_ipc_t ipc, bool lock)
+sc_err_t sc_timer_start_wdog(sc_ipc_t ipc, sc_bool_t lock)
 {
 	sc_rpc_msg_t msg;
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_START_WDOG;
-	RPC_U8(&msg, 0) = (uint8_t)lock;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_START_WDOG);
+	RPC_U8(&msg, 0U) = B2U8(lock);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -85,11 +85,11 @@ sc_err_t sc_timer_stop_wdog(sc_ipc_t ipc)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_STOP_WDOG;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_STOP_WDOG);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -101,11 +101,11 @@ sc_err_t sc_timer_ping_wdog(sc_ipc_t ipc)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_PING_WDOG;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_PING_WDOG);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -120,29 +120,30 @@ sc_err_t sc_timer_get_wdog_status(sc_ipc_t ipc,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_GET_WDOG_STATUS;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_GET_WDOG_STATUS);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (timeout != NULL) {
-		*timeout = RPC_U32(&msg, 0);
+		*timeout = RPC_U32(&msg, 0U);
 	}
 
 	if (max_timeout != NULL) {
-		*max_timeout = RPC_U32(&msg, 4);
+		*max_timeout = RPC_U32(&msg, 4U);
 	}
 
 	if (remaining_time != NULL) {
-		*remaining_time = RPC_U32(&msg, 8);
+		*remaining_time = RPC_U32(&msg, 8U);
 	}
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
 }
 
-sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt, bool *enb,
+sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt,
+				     sc_bool_t *enb,
 				     sc_timer_wdog_time_t *timeout,
 				     sc_timer_wdog_time_t *remaining_time)
 {
@@ -150,24 +151,24 @@ sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt, bool *enb,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_PT_GET_WDOG_STATUS;
-	RPC_U8(&msg, 0) = pt;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_PT_GET_WDOG_STATUS);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (timeout != NULL) {
-		*timeout = RPC_U32(&msg, 0);
+		*timeout = RPC_U32(&msg, 0U);
 	}
 
 	if (remaining_time != NULL) {
-		*remaining_time = RPC_U32(&msg, 4);
+		*remaining_time = RPC_U32(&msg, 4U);
 	}
 
 	result = RPC_R8(&msg);
 	if (enb != NULL) {
-		*enb = RPC_U8(&msg, 8);
+		*enb = U2B(RPC_U8(&msg, 8U));
 	}
 
 	return (sc_err_t)result;
@@ -180,13 +181,13 @@ sc_err_t sc_timer_set_wdog_action(sc_ipc_t ipc,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_WDOG_ACTION;
-	RPC_U8(&msg, 0) = pt;
-	RPC_U8(&msg, 1) = action;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_WDOG_ACTION);
+	RPC_U8(&msg, 0U) = U8(pt);
+	RPC_U8(&msg, 1U) = U8(action);
+	RPC_SIZE(&msg) = 2U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -200,17 +201,17 @@ sc_err_t sc_timer_set_rtc_time(sc_ipc_t ipc, uint16_t year, uint8_t mon,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_RTC_TIME;
-	RPC_U16(&msg, 0) = year;
-	RPC_U8(&msg, 2) = mon;
-	RPC_U8(&msg, 3) = day;
-	RPC_U8(&msg, 4) = hour;
-	RPC_U8(&msg, 5) = min;
-	RPC_U8(&msg, 6) = sec;
-	RPC_SIZE(&msg) = 3;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_RTC_TIME);
+	RPC_U16(&msg, 0U) = U16(year);
+	RPC_U8(&msg, 2U) = U8(mon);
+	RPC_U8(&msg, 3U) = U8(day);
+	RPC_U8(&msg, 4U) = U8(hour);
+	RPC_U8(&msg, 5U) = U8(min);
+	RPC_U8(&msg, 6U) = U8(sec);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -224,35 +225,35 @@ sc_err_t sc_timer_get_rtc_time(sc_ipc_t ipc, uint16_t *year, uint8_t *mon,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_GET_RTC_TIME;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_GET_RTC_TIME);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (year != NULL) {
-		*year = RPC_U16(&msg, 0);
+		*year = RPC_U16(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
 	if (mon != NULL) {
-		*mon = RPC_U8(&msg, 2);
+		*mon = RPC_U8(&msg, 2U);
 	}
 
 	if (day != NULL) {
-		*day = RPC_U8(&msg, 3);
+		*day = RPC_U8(&msg, 3U);
 	}
 
 	if (hour != NULL) {
-		*hour = RPC_U8(&msg, 4);
+		*hour = RPC_U8(&msg, 4U);
 	}
 
 	if (min != NULL) {
-		*min = RPC_U8(&msg, 5);
+		*min = RPC_U8(&msg, 5U);
 	}
 
 	if (sec != NULL) {
-		*sec = RPC_U8(&msg, 6);
+		*sec = RPC_U8(&msg, 6U);
 	}
 
 	return (sc_err_t)result;
@@ -264,14 +265,14 @@ sc_err_t sc_timer_get_rtc_sec1970(sc_ipc_t ipc, uint32_t *sec)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_GET_RTC_SEC1970;
-	RPC_SIZE(&msg) = 1;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_GET_RTC_SEC1970);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	if (sec != NULL) {
-		*sec = RPC_U32(&msg, 0);
+		*sec = RPC_U32(&msg, 0U);
 	}
 
 	result = RPC_R8(&msg);
@@ -286,17 +287,50 @@ sc_err_t sc_timer_set_rtc_alarm(sc_ipc_t ipc, uint16_t year, uint8_t mon,
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_RTC_ALARM;
-	RPC_U16(&msg, 0) = year;
-	RPC_U8(&msg, 2) = mon;
-	RPC_U8(&msg, 3) = day;
-	RPC_U8(&msg, 4) = hour;
-	RPC_U8(&msg, 5) = min;
-	RPC_U8(&msg, 6) = sec;
-	RPC_SIZE(&msg) = 3;
-
-	sc_call_rpc(ipc, &msg, false);
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_RTC_ALARM);
+	RPC_U16(&msg, 0U) = U16(year);
+	RPC_U8(&msg, 2U) = U8(mon);
+	RPC_U8(&msg, 3U) = U8(day);
+	RPC_U8(&msg, 4U) = U8(hour);
+	RPC_U8(&msg, 5U) = U8(min);
+	RPC_U8(&msg, 6U) = U8(sec);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_rtc_periodic_alarm(sc_ipc_t ipc, uint32_t sec)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_RTC_PERIODIC_ALARM);
+	RPC_U32(&msg, 0U) = U32(sec);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_cancel_rtc_alarm(sc_ipc_t ipc)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_CANCEL_RTC_ALARM);
+	RPC_SIZE(&msg) = 1U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
@@ -308,12 +342,64 @@ sc_err_t sc_timer_set_rtc_calb(sc_ipc_t ipc, int8_t count)
 	uint8_t result;
 
 	RPC_VER(&msg) = SC_RPC_VERSION;
-	RPC_SVC(&msg) = (uint8_t)SC_RPC_SVC_TIMER;
-	RPC_FUNC(&msg) = (uint8_t)TIMER_FUNC_SET_RTC_CALB;
-	RPC_I8(&msg, 0) = count;
-	RPC_SIZE(&msg) = 2;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_RTC_CALB);
+	RPC_I8(&msg, 0U) = I8(count);
+	RPC_SIZE(&msg) = 2U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_sysctr_alarm(sc_ipc_t ipc, uint64_t ticks)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_SYSCTR_ALARM);
+	RPC_U32(&msg, 0U) = U32(ticks >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(ticks);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_set_sysctr_periodic_alarm(sc_ipc_t ipc, uint64_t ticks)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_SET_SYSCTR_PERIODIC_ALARM);
+	RPC_U32(&msg, 0U) = U32(ticks >> 32ULL);
+	RPC_U32(&msg, 4U) = U32(ticks);
+	RPC_SIZE(&msg) = 3U;
+
+	sc_call_rpc(ipc, &msg, SC_FALSE);
+
+	result = RPC_R8(&msg);
+	return (sc_err_t)result;
+}
+
+sc_err_t sc_timer_cancel_sysctr_alarm(sc_ipc_t ipc)
+{
+	sc_rpc_msg_t msg;
+	uint8_t result;
+
+	RPC_VER(&msg) = SC_RPC_VERSION;
+	RPC_SVC(&msg) = U8(SC_RPC_SVC_TIMER);
+	RPC_FUNC(&msg) = U8(TIMER_FUNC_CANCEL_SYSCTR_ALARM);
+	RPC_SIZE(&msg) = 1U;
 
-	sc_call_rpc(ipc, &msg, false);
+	sc_call_rpc(ipc, &msg, SC_FALSE);
 
 	result = RPC_R8(&msg);
 	return (sc_err_t)result;
diff --git a/drivers/soc/imx/soc-imx8.c b/drivers/soc/imx/soc-imx8.c
index 0fc298e..331f9345 100644
--- a/drivers/soc/imx/soc-imx8.c
+++ b/drivers/soc/imx/soc-imx8.c
@@ -24,6 +24,7 @@
 #include <linux/platform_device.h>
 #include <linux/of.h>
 
+#include <soc/imx8/sc/types.h>
 #include <soc/imx8/sc/sci.h>
 #include <soc/imx8/soc.h>
 #include <soc/imx/revision.h>
diff --git a/include/soc/imx/fsl_sip.h b/include/soc/imx/fsl_sip.h
index 44649f4..0fbcbb5 100644
--- a/include/soc/imx/fsl_sip.h
+++ b/include/soc/imx/fsl_sip.h
@@ -44,11 +44,6 @@
 #define IMX8MQ_PD_MIPI_CSI2	9
 #define IMX8MQ_PD_PCIE2		10
 
-#define SC_TIMER_WDOG_ACTION_PARTITION      0   /*!< Reset partition */
-#define SC_TIMER_WDOG_ACTION_WARM           1   /*!< Warm reset system */
-#define SC_TIMER_WDOG_ACTION_COLD           2   /*!< Cold reset system */
-#define SC_TIMER_WDOG_ACTION_BOARD          3   /*!< Reset board */
-
 #define FSL_SIP_DDR_DVFS		0xc2000004
 
 #define FSL_SIP_SRC			0xc2000005
diff --git a/include/soc/imx8/sc/ipc.h b/include/soc/imx8/sc/ipc.h
index d87f918..332e202 100644
--- a/include/soc/imx8/sc/ipc.h
+++ b/include/soc/imx8/sc/ipc.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -9,8 +9,8 @@
  * Header file for the IPC implementation.
  */
 
-#ifndef _SC_IPC_H
-#define _SC_IPC_H
+#ifndef SC_IPC_H
+#define SC_IPC_H
 
 /* Includes */
 
@@ -62,10 +62,9 @@
  *
  * This function will block if the outgoing buffer is full.
  */
-void sc_ipc_write(sc_ipc_t ipc, void *data);
+void sc_ipc_write(sc_ipc_t ipc, const void *data);
 
 int register_scu_notifier(struct notifier_block *nb);
 int unregister_scu_notifier(struct notifier_block *nb);
 
-#endif /* _SC_IPC_H */
-
+#endif				/* SC_IPC_H */
diff --git a/include/soc/imx8/sc/svc/irq/api.h b/include/soc/imx8/sc/svc/irq/api.h
index e416ffa..15b138a 100644
--- a/include/soc/imx8/sc/svc/irq/api.h
+++ b/include/soc/imx8/sc/svc/irq/api.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -16,8 +16,8 @@
  * @{
  */
 
-#ifndef _SC_IRQ_API_H
-#define _SC_IRQ_API_H
+#ifndef SC_IRQ_API_H
+#define SC_IRQ_API_H
 
 /* Includes */
 
@@ -25,66 +25,74 @@
 
 /* Defines */
 
-#define SC_IRQ_NUM_GROUP    4	/* Number of groups */
+#define SC_IRQ_NUM_GROUP    5U	/* Number of groups */
 
 /*!
  * @name Defines for sc_irq_group_t
  */
 /*@{*/
-#define SC_IRQ_GROUP_TEMP   0	/* Temp interrupts */
-#define SC_IRQ_GROUP_WDOG   1	/* Watchdog interrupts */
-#define SC_IRQ_GROUP_RTC    2	/* RTC interrupts */
-#define SC_IRQ_GROUP_WAKE   3	/* Wakeup interrupts */
+#define SC_IRQ_GROUP_TEMP   0U	/* Temp interrupts */
+#define SC_IRQ_GROUP_WDOG   1U	/* Watchdog interrupts */
+#define SC_IRQ_GROUP_RTC    2U	/* RTC interrupts */
+#define SC_IRQ_GROUP_WAKE   3U	/* Wakeup interrupts */
+#define SC_IRQ_GROUP_SYSCTR 4U	/* System counter interrupts */
 /*@}*/
 
 /*!
  * @name Defines for sc_irq_temp_t
  */
 /*@{*/
-#define SC_IRQ_TEMP_HIGH         (1 << 0)	/* Temp alarm interrupt */
-#define SC_IRQ_TEMP_CPU0_HIGH    (1 << 1)	/* CPU0 temp alarm interrupt */
-#define SC_IRQ_TEMP_CPU1_HIGH    (1 << 2)	/* CPU1 temp alarm interrupt */
-#define SC_IRQ_TEMP_GPU0_HIGH    (1 << 3)	/* GPU0 temp alarm interrupt */
-#define SC_IRQ_TEMP_GPU1_HIGH    (1 << 4)	/* GPU1 temp alarm interrupt */
-#define SC_IRQ_TEMP_DRC0_HIGH    (1 << 5)	/* DRC0 temp alarm interrupt */
-#define SC_IRQ_TEMP_DRC1_HIGH    (1 << 6)	/* DRC1 temp alarm interrupt */
-#define SC_IRQ_TEMP_VPU_HIGH     (1 << 7)	/* DRC1 temp alarm interrupt */
-#define SC_IRQ_TEMP_PMIC0_HIGH   (1 << 8)	/* PMIC0 temp alarm interrupt */
-#define SC_IRQ_TEMP_PMIC1_HIGH   (1 << 9)	/* PMIC1 temp alarm interrupt */
-#define SC_IRQ_TEMP_LOW          (1 << 10)	/* Temp alarm interrupt */
-#define SC_IRQ_TEMP_CPU0_LOW     (1 << 11)	/* CPU0 temp alarm interrupt */
-#define SC_IRQ_TEMP_CPU1_LOW     (1 << 12)	/* CPU1 temp alarm interrupt */
-#define SC_IRQ_TEMP_GPU0_LOW     (1 << 13)	/* GPU0 temp alarm interrupt */
-#define SC_IRQ_TEMP_GPU1_LOW     (1 << 14)	/* GPU1 temp alarm interrupt */
-#define SC_IRQ_TEMP_DRC0_LOW     (1 << 15)	/* DRC0 temp alarm interrupt */
-#define SC_IRQ_TEMP_DRC1_LOW     (1 << 16)	/* DRC1 temp alarm interrupt */
-#define SC_IRQ_TEMP_VPU_LOW      (1 << 17)	/* DRC1 temp alarm interrupt */
-#define SC_IRQ_TEMP_PMIC0_LOW    (1 << 18)	/* PMIC0 temp alarm interrupt */
-#define SC_IRQ_TEMP_PMIC1_LOW    (1 << 19)	/* PMIC1 temp alarm interrupt */
-#define SC_IRQ_TEMP_PMIC2_HIGH   (1 << 20)	/* PMIC2 temp alarm interrupt */
-#define SC_IRQ_TEMP_PMIC2_LOW    (1 << 21)	/* PMIC2 temp alarm interrupt */
+#define SC_IRQ_TEMP_HIGH         (1UL << 0U)	/* Temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU0_HIGH    (1UL << 1U)	/* CPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU1_HIGH    (1UL << 2U)	/* CPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU0_HIGH    (1UL << 3U)	/* GPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU1_HIGH    (1UL << 4U)	/* GPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC0_HIGH    (1UL << 5U)	/* DRC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC1_HIGH    (1UL << 6U)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_VPU_HIGH     (1UL << 7U)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC0_HIGH   (1UL << 8U)	/* PMIC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC1_HIGH   (1UL << 9U)	/* PMIC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_LOW          (1UL << 10U)	/* Temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU0_LOW     (1UL << 11U)	/* CPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_CPU1_LOW     (1UL << 12U)	/* CPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU0_LOW     (1UL << 13U)	/* GPU0 temp alarm interrupt */
+#define SC_IRQ_TEMP_GPU1_LOW     (1UL << 14U)	/* GPU1 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC0_LOW     (1UL << 15U)	/* DRC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_DRC1_LOW     (1UL << 16U)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_VPU_LOW      (1UL << 17U)	/* DRC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC0_LOW    (1UL << 18U)	/* PMIC0 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC1_LOW    (1UL << 19U)	/* PMIC1 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC2_HIGH   (1UL << 20U)	/* PMIC2 temp alarm interrupt */
+#define SC_IRQ_TEMP_PMIC2_LOW    (1UL << 21U)	/* PMIC2 temp alarm interrupt */
 /*@}*/
 
 /*!
  * @name Defines for sc_irq_wdog_t
  */
 /*@{*/
-#define SC_IRQ_WDOG              (1 << 0)	/* Watchdog interrupt */
-#define SC_IRQ_PAD               (1U << 1U)     /*!< Pad wakeup */
+#define SC_IRQ_WDOG              (1U << 0U)	/* Watchdog interrupt */
 /*@}*/
 
 /*!
  * @name Defines for sc_irq_rtc_t
  */
 /*@{*/
-#define SC_IRQ_RTC               (1 << 0)	/* RTC interrupt */
+#define SC_IRQ_RTC               (1U << 0U)	/* RTC interrupt */
 /*@}*/
 
 /*!
  * @name Defines for sc_irq_wake_t
  */
 /*@{*/
-#define SC_IRQ_BUTTON            (1 << 0)	/* Button interrupt */
+#define SC_IRQ_BUTTON            (1U << 0U)	/* Button interrupt */
+#define SC_IRQ_PAD               (1U << 1U)	/* Pad wakeup */
+/*@}*/
+
+/*!
+ * @name Defines for sc_irq_sysctr_t
+ */
+/*@{*/
+#define SC_IRQ_SYSCTR            (1U << 0U)	/* SYSCTR interrupt */
 /*@}*/
 
 /* Types */
@@ -132,7 +140,7 @@
  * - SC_PARM if group invalid
  */
 sc_err_t sc_irq_enable(sc_ipc_t ipc, sc_rsrc_t resource,
-		       sc_irq_group_t group, uint32_t mask, bool enable);
+		       sc_irq_group_t group, uint32_t mask, sc_bool_t enable);
 
 /*!
  * This function returns the current interrupt status (regardless if
@@ -154,6 +162,6 @@ sc_err_t sc_irq_enable(sc_ipc_t ipc, sc_rsrc_t resource,
 sc_err_t sc_irq_status(sc_ipc_t ipc, sc_rsrc_t resource,
 		       sc_irq_group_t group, uint32_t *status);
 
-#endif				/* _SC_IRQ_API_H */
+#endif				/* SC_IRQ_API_H */
 
 /**@}*/
diff --git a/include/soc/imx8/sc/svc/misc/api.h b/include/soc/imx8/sc/svc/misc/api.h
index 8923953..bddd68a 100644
--- a/include/soc/imx8/sc/svc/misc/api.h
+++ b/include/soc/imx8/sc/svc/misc/api.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -16,8 +16,8 @@
  * @{
  */
 
-#ifndef _SC_MISC_API_H
-#define _SC_MISC_API_H
+#ifndef SC_MISC_API_H
+#define SC_MISC_API_H
 
 /* Includes */
 
@@ -30,45 +30,50 @@
  * @name Defines for type widths
  */
 /*@{*/
-#define SC_MISC_DMA_GRP_W       5	/* Width of sc_misc_dma_group_t */
+#define SC_MISC_DMA_GRP_W       5U	/* Width of sc_misc_dma_group_t */
 /*@}*/
 
 /*! Max DMA channel priority group */
-#define SC_MISC_DMA_GRP_MAX     31
+#define SC_MISC_DMA_GRP_MAX     31U
 
 /*!
  * @name Defines for sc_misc_boot_status_t
  */
 /*@{*/
-#define SC_MISC_BOOT_STATUS_SUCCESS     0	/* Success */
-#define SC_MISC_BOOT_STATUS_SECURITY    1	/* Security violation */
+#define SC_MISC_BOOT_STATUS_SUCCESS     0U	/* Success */
+#define SC_MISC_BOOT_STATUS_SECURITY    1U	/* Security violation */
 /*@}*/
 
 /*!
- * @name Defines for sc_misc_seco_auth_cmd_t
+ * @name Defines for sc_misc_temp_t
  */
 /*@{*/
-#define SC_MISC_SECO_AUTH_SECO_FW       0	/* SECO Firmware */
-#define SC_MISC_SECO_AUTH_HDMI_TX_FW    1	/* HDMI TX Firmware */
-#define SC_MISC_SECO_AUTH_HDMI_RX_FW    2	/* HDMI RX Firmware */
+#define SC_MISC_TEMP                    0U	/* Temp sensor */
+#define SC_MISC_TEMP_HIGH               1U	/* Temp high alarm */
+#define SC_MISC_TEMP_LOW                2U	/* Temp low alarm */
 /*@}*/
 
 /*!
- * @name Defines for sc_misc_temp_t
+ * @name Defines for sc_misc_seco_auth_cmd_t
  */
 /*@{*/
-#define SC_MISC_TEMP                    0	/* Temp sensor */
-#define SC_MISC_TEMP_HIGH               1	/* Temp high alarm */
-#define SC_MISC_TEMP_LOW                2	/* Temp low alarm */
+#define SC_MISC_AUTH_CONTAINER          0U	/* Authenticate container */
+#define SC_MISC_VERIFY_IMAGE            1U	/* Verify image */
+#define SC_MISC_REL_CONTAINER           2U	/* Release container */
+#define SC_MISC_SECO_AUTH_SECO_FW       3U	/* SECO Firmware */
+#define SC_MISC_SECO_AUTH_HDMI_TX_FW    4U	/* HDMI TX Firmware */
+#define SC_MISC_SECO_AUTH_HDMI_RX_FW    5U	/* HDMI RX Firmware */
 /*@}*/
 
 /*!
- * @name Defines for sc_misc_seco_auth_cmd_t
+ * @name Defines for sc_misc_bt_t
  */
 /*@{*/
-#define SC_MISC_AUTH_CONTAINER          0	/* Authenticate container */
-#define SC_MISC_VERIFY_IMAGE            1	/* Verify image */
-#define SC_MISC_REL_CONTAINER           2	/* Release container */
+#define SC_MISC_BT_PRIMARY              0U
+#define SC_MISC_BT_SECONDARY            1U
+#define SC_MISC_BT_RECOVERY             2U
+#define SC_MISC_BT_MANUFACTURE          3U
+#define SC_MISC_BT_SERIAL               4U
 /*@}*/
 
 /* Types */
@@ -93,6 +98,11 @@
  */
 typedef uint8_t sc_misc_temp_t;
 
+/*!
+ * This type is used report the boot type.
+ */
+typedef uint8_t sc_misc_bt_t;
+
 /* Functions */
 
 /*!
@@ -203,33 +213,274 @@ sc_err_t sc_misc_set_dma_group(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     addr_src    address of image source
  * @param[in]     addr_dst    address of image destination
  * @param[in]     len         lenth of image to load
- * @param[in]     fw          true = firmware load
+ * @param[in]     fw          SC_TRUE = firmware load
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
+ * Return errors codes:
+ * - SC_ERR_PARM if word fuse index param out of range or invalid
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
  * This is used to load images via the SECO. Examples include SECO
  * Firmware and IVT/CSF data used for authentication. These are usually
  * loaded into SECO TCM. \a addr_src is in secure memory.
+ *
+ * See the Security Reference Manual (SRM) for more info.
  */
-sc_err_t sc_misc_seco_image_load(sc_ipc_t ipc, uint32_t addr_src,
-				 uint32_t addr_dst, uint32_t len, bool fw);
+sc_err_t sc_misc_seco_image_load(sc_ipc_t ipc, sc_faddr_t addr_src,
+				 sc_faddr_t addr_dst, uint32_t len,
+				 sc_bool_t fw);
 
 /*!
  * This function is used to authenticate a SECO image or command.
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     cmd         authenticate command
- * @param[in]     addr_meta   address of/or metadata
+ * @param[in]     addr        address of/or metadata
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
+ * Return errors codes:
+ * - SC_ERR_PARM if word fuse index param out of range or invalid
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
  * This is used to authenticate a SECO image or issue a security
- * command. \a addr_meta often points to an container. It is also
+ * command. \a addr often points to an container. It is also
  * just data (or even unused) for some commands.
+ *
+ * See the Security Reference Manual (SRM) for more info.
  */
 sc_err_t sc_misc_seco_authenticate(sc_ipc_t ipc,
 				   sc_misc_seco_auth_cmd_t cmd,
-				   uint32_t addr_meta);
+				   sc_faddr_t addr);
+
+/*!
+ * This function securely writes a group of fuse words.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr        address of message block
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * Note \a addr must be a pointer to a signed message block.
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_fuse_write(sc_ipc_t ipc, sc_faddr_t addr);
+
+/*!
+ * This function securely enables debug.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr        address of message block
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * Note \a addr must be a pointer to a signed message block.
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_enable_debug(sc_ipc_t ipc, sc_faddr_t addr);
+
+/*!
+ * This function updates the lifecycle of the device.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     change      desired lifecycle transistion
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * This message is used for going from Open to NXP Closed to OEM Closed.
+ * Note \a change is NOT the new desired lifecycle. It is a lifecycle
+ * transition as documented in the Security Reference Manual (SRM).
+ *
+ * If any SECO request fails or only succeeds because the part is in an
+ * "OEM open" lifecycle, then a request to transition from "NXP closed"
+ * to "OEM closed" will also fail. For example, booting a signed container
+ * when the OEM SRK is not fused will succeed, but as it is an abnormal
+ * situation, a subsequent request to transition the lifecycle will return
+ * an error.
+ */
+sc_err_t sc_misc_seco_forward_lifecycle(sc_ipc_t ipc, uint32_t change);
+
+/*!
+ * This function updates the lifecycle to one of the return lifecycles.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr        address of message block
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * Note \a addr must be a pointer to a signed message block.
+ *
+ * To switch back to NXP states (Full Field Return), message must be signed
+ * by NXP SRK. For OEM States (Partial Field Return), must be signed by OEM
+ * SRK.
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_return_lifecycle(sc_ipc_t ipc, sc_faddr_t addr);
+
+/*!
+ * This function is used to return the SECO FW build info.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    version     pointer to return build number
+ * @param[out]    commit      pointer to return commit ID (git SHA-1)
+ */
+void sc_misc_seco_build_info(sc_ipc_t ipc, uint32_t *version, uint32_t *commit);
+
+/*!
+ * This function is used to return SECO chip info.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    lc          pointer to return lifecycle
+ * @param[out]    monotonic   pointer to return monotonic counter
+ * @param[out]    uid_l       pointer to return UID (lower 32 bits)
+ * @param[out]    uid_h       pointer to return UID (upper 32 bits)
+ */
+sc_err_t sc_misc_seco_chip_info(sc_ipc_t ipc, uint16_t *lc,
+				uint16_t *monotonic, uint32_t *uid_l,
+				uint32_t *uid_h);
+
+/*!
+ * This function is used to set the attestation mode. Only the owner of
+ * the SC_R_ATTESTATION resource may make this call.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     mode        mode
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if \a mode is invalid
+ * - SC_ERR_NOACCESS if SC_R_ATTESTATON not owned by caller
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * This is used to set the SECO attestation mode. This can be prover
+ * or verfier. See the Security Reference Manual (SRM) for more on the
+ * suported modes, mode values, and mode behavior.
+ */
+sc_err_t sc_misc_seco_attest_mode(sc_ipc_t ipc, uint32_t mode);
+
+/*!
+ * This function is used to request atestation. Only the owner of
+ * the SC_R_ATTESTATION resource may make this call.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     nonce       unique value
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_NOACCESS if SC_R_ATTESTATON not owned by caller
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * This is used to ask SECO to perform an attestation. The result depends
+ * on the attestation mode. After this call, the signature can be
+ * requested or a verify can be requested.
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_attest(sc_ipc_t ipc, uint64_t nonce);
+
+/*!
+ * This function is used to retrieve the attestation public key.
+ * Mode must be verifier. Only the owner of the SC_R_ATTESTATION resource
+ * may make this call.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr        address to write response
+ *
+ * Result will be written to \a addr. The \a addr parmater must point
+ * to an address SECO can access. It must be 64-bit aligned. There
+ * should be 96 bytes of space.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if \a addr bad or attestation has not been requested
+ * - SC_ERR_NOACCESS if SC_R_ATTESTATON not owned by caller
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_get_attest_pkey(sc_ipc_t ipc, sc_faddr_t addr);
+
+/*!
+ * This function is used to retrieve attestation signature and parameters.
+ * Mode must be provider. Only the owner of the SC_R_ATTESTATION resource
+ * may make this call.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr        address to write response
+ *
+ * Result will be written to \a addr. The \a addr parmater must point
+ * to an address SECO can access. It must be 64-bit aligned. There
+ * should be 120 bytes of space.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if \a addr bad or attestation has not been requested
+ * - SC_ERR_NOACCESS if SC_R_ATTESTATON not owned by caller
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_get_attest_sign(sc_ipc_t ipc, sc_faddr_t addr);
+
+/*!
+ * This function is used to verify attestation. Mode must be verifier.
+ * Only the owner of the SC_R_ATTESTATION resource may make this call.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     addr        address of signature
+ *
+ * The \a addr parmater must point to an address SECO can access. It must be
+ * 64-bit aligned.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if \a addr bad or attestation has not been requested
+ * - SC_ERR_NOACCESS if SC_R_ATTESTATON not owned by caller
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ * - SC_ERR_FAIL if signature doesn't match
+ *
+ * See the Security Reference Manual (SRM) for more info.
+ */
+sc_err_t sc_misc_seco_attest_verify(sc_ipc_t ipc, sc_faddr_t addr);
+
+/*!
+ * This function is used to commit into the fuses any new SRK revocation
+ * and FW version information that have been found in the primary and
+ * secondary containers.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in,out] info        pointer to information type to be committed
+ *
+ * The return \a info will contain what was actually committed.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors codes:
+ * - SC_ERR_PARM if \a info is invalid
+ * - SC_ERR_UNAVAILABLE if SECO not available
+ */
+sc_err_t sc_misc_seco_commit(sc_ipc_t ipc, uint32_t *info);
 
 /* @} */
 
@@ -257,7 +508,7 @@ sc_err_t sc_misc_seco_authenticate(sc_ipc_t ipc,
  * Return errors:
  * - SC_ERR_UNAVAILABLE if not running on emulation
  */
-sc_err_t sc_misc_waveform_capture(sc_ipc_t ipc, bool enable);
+sc_err_t sc_misc_waveform_capture(sc_ipc_t ipc, sc_bool_t enable);
 
 /*!
  * This function is used to return the SCFW build info.
@@ -305,7 +556,8 @@ sc_err_t sc_misc_seco_authenticate(sc_ipc_t ipc,
  * FISType and PM_Port.
  */
 sc_err_t sc_misc_set_ari(sc_ipc_t ipc, sc_rsrc_t resource,
-			 sc_rsrc_t resource_mst, uint16_t ari, bool enable);
+			 sc_rsrc_t resource_mst, uint16_t ari,
+			 sc_bool_t enable);
 
 /*!
  * This function reports boot status.
@@ -360,6 +612,11 @@ sc_err_t sc_misc_set_ari(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     word        fuse word index
  * @param[in]     val         fuse write value
  *
+ * The command is passed as is to SECO. SECO uses part of the
+ * \a word parameter to indicate if the fuse should be locked
+ * after programming. See the "Write common fuse" section of
+ * the Security Reference Manual (SRM) for more info.
+ *
  * @return Returns and error code (SC_ERR_NONE = success).
  *
  * Return errors codes:
@@ -380,6 +637,10 @@ sc_err_t sc_misc_set_ari(sc_ipc_t ipc, sc_rsrc_t resource,
  *
  * @return Returns and error code (SC_ERR_NONE = success).
  *
+ * This function will enable the alarm interrupt if the temp requested is
+ * not the min/max temp. This enable automatically clears when the alarm
+ * occurs and this function has to be called again to re-enable.
+ *
  * Return errors codes:
  * - SC_ERR_PARM if parameters invalid
  */
@@ -399,6 +660,7 @@ sc_err_t sc_misc_set_temp(sc_ipc_t ipc, sc_rsrc_t resource,
  *
  * Return errors codes:
  * - SC_ERR_PARM if parameters invalid
+ * - SC_ERR_BUSY if temp not ready yet (time delay after power on)
  */
 sc_err_t sc_misc_get_temp(sc_ipc_t ipc, sc_rsrc_t resource,
 			  sc_misc_temp_t temp, int16_t * celsius,
@@ -413,15 +675,38 @@ sc_err_t sc_misc_get_temp(sc_ipc_t ipc, sc_rsrc_t resource,
 void sc_misc_get_boot_dev(sc_ipc_t ipc, sc_rsrc_t *dev);
 
 /*!
+ * This function returns the boot type.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    type        pointer to return boot type
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ *
+ * Return errors code:
+ * - SC_ERR_UNAVAILABLE if type not passed by ROM
+ */
+sc_err_t sc_misc_get_boot_type(sc_ipc_t ipc, sc_misc_bt_t *type);
+
+/*!
  * This function returns the current status of the ON/OFF button.
  *
  * @param[in]     ipc         IPC handle
  * @param[out]    status      pointer to return button status
  */
-void sc_misc_get_button_status(sc_ipc_t ipc, bool *status);
+void sc_misc_get_button_status(sc_ipc_t ipc, sc_bool_t *status);
+
+/*!
+ * This function returns the ROM patch checksum.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    checksum    pointer to return checksum
+ *
+ * @return Returns and error code (SC_ERR_NONE = success).
+ */
+sc_err_t sc_misc_rompatch_checksum(sc_ipc_t ipc, uint32_t *checksum);
 
 /* @} */
 
-#endif				/* _SC_MISC_API_H */
+#endif				/* SC_MISC_API_H */
 
 /**@}*/
diff --git a/include/soc/imx8/sc/svc/pad/api.h b/include/soc/imx8/sc/svc/pad/api.h
index 27cb03e..975ce08 100644
--- a/include/soc/imx8/sc/svc/pad/api.h
+++ b/include/soc/imx8/sc/svc/pad/api.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -45,14 +45,19 @@
  * assigned owners and only the owners can configure the pads. Some of the
  * pads are reserved for use by the SCFW itself and this can be overriden
  * with the implementation of board_config_sc(). Additionally, pads may
- * be assigned to various other partitions via SCD or via the implementation
- * of board_system_config().
+ * be assigned to various other partitions via the implementation of
+ * board_system_config().
+ *
+ * Note muxing two input pads to the same IP functional signal will
+ * result in undefined behavior.
+ *
+ * @includedoc pad/details.dox
  *
  * @{
  */
 
-#ifndef _SC_PAD_API_H
-#define _SC_PAD_API_H
+#ifndef SC_PAD_API_H
+#define SC_PAD_API_H
 
 /* Includes */
 
@@ -65,79 +70,79 @@
  * @name Defines for type widths
  */
 /*@{*/
-#define SC_PAD_MUX_W            3	/* Width of mux parameter */
+#define SC_PAD_MUX_W            3U	/* Width of mux parameter */
 /*@}*/
 
 /*!
  * @name Defines for sc_pad_config_t
  */
 /*@{*/
-#define SC_PAD_CONFIG_NORMAL    0	/* Normal */
-#define SC_PAD_CONFIG_OD        1	/* Open Drain */
-#define SC_PAD_CONFIG_OD_IN     2	/* Open Drain and input */
-#define SC_PAD_CONFIG_OUT_IN    3	/* Output and input */
+#define SC_PAD_CONFIG_NORMAL    0U	/* Normal */
+#define SC_PAD_CONFIG_OD        1U	/* Open Drain */
+#define SC_PAD_CONFIG_OD_IN     2U	/* Open Drain and input */
+#define SC_PAD_CONFIG_OUT_IN    3U	/* Output and input */
 /*@}*/
 
 /*!
  * @name Defines for sc_pad_iso_t
  */
 /*@{*/
-#define SC_PAD_ISO_OFF          0	/* ISO latch is transparent */
-#define SC_PAD_ISO_EARLY        1	/* Follow EARLY_ISO */
-#define SC_PAD_ISO_LATE         2	/* Follow LATE_ISO */
-#define SC_PAD_ISO_ON           3	/* ISO latched data is held */
+#define SC_PAD_ISO_OFF          0U	/* ISO latch is transparent */
+#define SC_PAD_ISO_EARLY        1U	/* Follow EARLY_ISO */
+#define SC_PAD_ISO_LATE         2U	/* Follow LATE_ISO */
+#define SC_PAD_ISO_ON           3U	/* ISO latched data is held */
 /*@}*/
 
 /*!
  * @name Defines for sc_pad_28fdsoi_dse_t
  */
 /*@{*/
-#define SC_PAD_28FDSOI_DSE_18V_1MA   0	/* Drive strength of 1mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_2MA   1	/* Drive strength of 2mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_4MA   2	/* Drive strength of 4mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_6MA   3	/* Drive strength of 6mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_8MA   4	/* Drive strength of 8mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_10MA  5	/* Drive strength of 10mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_12MA  6	/* Drive strength of 12mA for 1.8v */
-#define SC_PAD_28FDSOI_DSE_18V_HS    7	/* High-speed drive strength for 1.8v */
-#define SC_PAD_28FDSOI_DSE_33V_2MA   0	/* Drive strength of 2mA for 3.3v */
-#define SC_PAD_28FDSOI_DSE_33V_4MA   1	/* Drive strength of 4mA for 3.3v */
-#define SC_PAD_28FDSOI_DSE_33V_8MA   2	/* Drive strength of 8mA for 3.3v */
-#define SC_PAD_28FDSOI_DSE_33V_12MA  3	/* Drive strength of 12mA for 3.3v */
-#define SC_PAD_28FDSOI_DSE_DV_HIGH   0	/* High drive strength for dual volt */
-#define SC_PAD_28FDSOI_DSE_DV_LOW    1	/* Low drive strength for dual volt */
+#define SC_PAD_28FDSOI_DSE_18V_1MA   0U	/* Drive strength of 1mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_2MA   1U	/* Drive strength of 2mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_4MA   2U	/* Drive strength of 4mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_6MA   3U	/* Drive strength of 6mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_8MA   4U	/* Drive strength of 8mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_10MA  5U	/* Drive strength of 10mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_12MA  6U	/* Drive strength of 12mA for 1.8v */
+#define SC_PAD_28FDSOI_DSE_18V_HS    7U	/* High-speed drive strength for 1.8v */
+#define SC_PAD_28FDSOI_DSE_33V_2MA   0U	/* Drive strength of 2mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_33V_4MA   1U	/* Drive strength of 4mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_33V_8MA   2U	/* Drive strength of 8mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_33V_12MA  3U	/* Drive strength of 12mA for 3.3v */
+#define SC_PAD_28FDSOI_DSE_DV_HIGH   0U	/* High drive strength for dual volt */
+#define SC_PAD_28FDSOI_DSE_DV_LOW    1U	/* Low drive strength for dual volt */
 /*@}*/
 
 /*!
  * @name Defines for sc_pad_28fdsoi_ps_t
  */
 /*@{*/
-#define SC_PAD_28FDSOI_PS_KEEPER 0	/* Bus-keeper (only valid for 1.8v) */
-#define SC_PAD_28FDSOI_PS_PU     1	/* Pull-up */
-#define SC_PAD_28FDSOI_PS_PD     2	/* Pull-down */
-#define SC_PAD_28FDSOI_PS_NONE   3	/* No pull (disabled) */
+#define SC_PAD_28FDSOI_PS_KEEPER 0U	/* Bus-keeper (only valid for 1.8v) */
+#define SC_PAD_28FDSOI_PS_PU     1U	/* Pull-up */
+#define SC_PAD_28FDSOI_PS_PD     2U	/* Pull-down */
+#define SC_PAD_28FDSOI_PS_NONE   3U	/* No pull (disabled) */
 /*@}*/
 
 /*!
  * @name Defines for sc_pad_28fdsoi_pus_t
  */
 /*@{*/
-#define SC_PAD_28FDSOI_PUS_30K_PD  0	/* 30K pull-down */
-#define SC_PAD_28FDSOI_PUS_100K_PU 1	/* 100K pull-up */
-#define SC_PAD_28FDSOI_PUS_3K_PU   2	/* 3K pull-up */
-#define SC_PAD_28FDSOI_PUS_30K_PU  3	/* 30K pull-up */
+#define SC_PAD_28FDSOI_PUS_30K_PD  0U	/* 30K pull-down */
+#define SC_PAD_28FDSOI_PUS_100K_PU 1U	/* 100K pull-up */
+#define SC_PAD_28FDSOI_PUS_3K_PU   2U	/* 3K pull-up */
+#define SC_PAD_28FDSOI_PUS_30K_PU  3U	/* 30K pull-up */
 /*@}*/
 
 /*!
  * @name Defines for sc_pad_wakeup_t
  */
 /*@{*/
-#define SC_PAD_WAKEUP_OFF       0	/* Off */
-#define SC_PAD_WAKEUP_CLEAR     1	/* Clears pending flag */
-#define SC_PAD_WAKEUP_LOW_LVL   4	/* Low level */
-#define SC_PAD_WAKEUP_FALL_EDGE 5	/* Falling edge */
-#define SC_PAD_WAKEUP_RISE_EDGE 6	/* Rising edge */
-#define SC_PAD_WAKEUP_HIGH_LVL  7	/* High-level */
+#define SC_PAD_WAKEUP_OFF       0U	/* Off */
+#define SC_PAD_WAKEUP_CLEAR     1U	/* Clears pending flag */
+#define SC_PAD_WAKEUP_LOW_LVL   4U	/* Low level */
+#define SC_PAD_WAKEUP_FALL_EDGE 5U	/* Falling edge */
+#define SC_PAD_WAKEUP_RISE_EDGE 6U	/* Rising edge */
+#define SC_PAD_WAKEUP_HIGH_LVL  7U	/* High-level */
 /*@}*/
 
 /* Types */
@@ -205,6 +210,9 @@
  * - SC_PARM if arguments out of range or invalid,
  * - SC_ERR_NOACCESS if caller's partition is not the pad owner
  *
+ * Note muxing two input pads to the same IP functional signal will
+ * result in undefined behavior.
+ *
  * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
  */
 sc_err_t sc_pad_set_mux(sc_ipc_t ipc, sc_pad_t pad,
@@ -326,6 +334,9 @@ sc_err_t sc_pad_get_mux(sc_ipc_t ipc, sc_pad_t pad,
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
+ * Note muxing two input pads to the same IP functional signal will
+ * result in undefined behavior.
+ *
  * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
  */
 sc_err_t sc_pad_set_all(sc_ipc_t ipc, sc_pad_t pad, uint8_t mux,
@@ -471,9 +482,9 @@ sc_err_t sc_pad_get_gp_28fdsoi(sc_ipc_t ipc, sc_pad_t pad,
  * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
  */
 sc_err_t sc_pad_set_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
-				    sc_pad_28fdsoi_dse_t dse, bool hys,
-				    sc_pad_28fdsoi_pus_t pus, bool pke,
-				    bool pue);
+				    sc_pad_28fdsoi_dse_t dse, sc_bool_t hys,
+				    sc_pad_28fdsoi_pus_t pus, sc_bool_t pke,
+				    sc_bool_t pue);
 
 /*!
  * This function gets the pad control specific to 28FDSOI.
@@ -496,9 +507,9 @@ sc_err_t sc_pad_set_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
  * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
  */
 sc_err_t sc_pad_get_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
-				    sc_pad_28fdsoi_dse_t *dse, bool *hys,
-				    sc_pad_28fdsoi_pus_t *pus, bool *pke,
-				    bool *pue);
+				    sc_pad_28fdsoi_dse_t *dse, sc_bool_t *hys,
+				    sc_pad_28fdsoi_pus_t *pus, sc_bool_t *pke,
+				    sc_bool_t *pue);
 
 /*!
  * This function configures the compensation control specific to 28FDSOI.
@@ -525,9 +536,9 @@ sc_err_t sc_pad_get_gp_28fdsoi_hsic(sc_ipc_t ipc, sc_pad_t pad,
  * operation (e.g. some Ethernet pads).
  */
 sc_err_t sc_pad_set_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
-				    uint8_t compen, bool fastfrz,
+				    uint8_t compen, sc_bool_t fastfrz,
 				    uint8_t rasrcp, uint8_t rasrcn,
-				    bool nasrc_sel, bool psw_ovr);
+				    sc_bool_t nasrc_sel, sc_bool_t psw_ovr);
 
 /*!
  * This function gets the compensation control specific to 28FDSOI.
@@ -553,13 +564,13 @@ sc_err_t sc_pad_set_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
  * Refer to the SoC [Pad List](@ref PADS) for valid pad values.
  */
 sc_err_t sc_pad_get_gp_28fdsoi_comp(sc_ipc_t ipc, sc_pad_t pad,
-				    uint8_t *compen, bool *fastfrz,
+				    uint8_t *compen, sc_bool_t *fastfrz,
 				    uint8_t *rasrcp, uint8_t *rasrcn,
-				    bool *nasrc_sel, bool *compok,
-				    uint8_t *nasrc, bool *psw_ovr);
+				    sc_bool_t *nasrc_sel, sc_bool_t *compok,
+				    uint8_t *nasrc, sc_bool_t *psw_ovr);
 
 /* @} */
 
-#endif				/* _SC_PAD_API_H */
+#endif				/* SC_PAD_API_H */
 
 /**@}*/
diff --git a/include/soc/imx8/sc/svc/pm/api.h b/include/soc/imx8/sc/svc/pm/api.h
index ae49c5b..cd201ba 100644
--- a/include/soc/imx8/sc/svc/pm/api.h
+++ b/include/soc/imx8/sc/svc/pm/api.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -14,11 +14,13 @@
  *
  * Module for the Power Management (PM) service.
  *
+ * @includedoc pm/details.dox
+ *
  * @{
  */
 
-#ifndef _SC_PM_API_H
-#define _SC_PM_API_H
+#ifndef SC_PM_API_H
+#define SC_PM_API_H
 
 /* Includes */
 
@@ -31,10 +33,10 @@
  * @name Defines for type widths
  */
 /*@{*/
-#define SC_PM_POWER_MODE_W      2	/* Width of sc_pm_power_mode_t */
-#define SC_PM_CLOCK_MODE_W      3	/* Width of sc_pm_clock_mode_t */
-#define SC_PM_RESET_TYPE_W      2	/* Width of sc_pm_reset_type_t */
-#define SC_PM_RESET_REASON_W    3	/* Width of sc_pm_reset_reason_t */
+#define SC_PM_POWER_MODE_W      2U	/* Width of sc_pm_power_mode_t */
+#define SC_PM_CLOCK_MODE_W      3U	/* Width of sc_pm_clock_mode_t */
+#define SC_PM_RESET_TYPE_W      2U	/* Width of sc_pm_reset_type_t */
+#define SC_PM_RESET_REASON_W    4U	/* Width of sc_pm_reset_reason_t */
 /*@}*/
 
 /*!
@@ -47,92 +49,108 @@
  * @name Defines for ALL parameters
  */
 /*@{*/
-#define SC_PM_CLK_ALL   UINT8_MAX	/* All clocks */
+#define SC_PM_CLK_ALL   ((sc_pm_clk_t) UINT8_MAX)	/* All clocks */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_power_mode_t
  */
 /*@{*/
-#define SC_PM_PW_MODE_OFF       0	/* Power off */
-#define SC_PM_PW_MODE_STBY      1	/* Power in standby */
-#define SC_PM_PW_MODE_LP        2	/* Power in low-power */
-#define SC_PM_PW_MODE_ON        3	/* Power on */
+#define SC_PM_PW_MODE_OFF       0U	/* Power off */
+#define SC_PM_PW_MODE_STBY      1U	/* Power in standby */
+#define SC_PM_PW_MODE_LP        2U	/* Power in low-power */
+#define SC_PM_PW_MODE_ON        3U	/* Power on */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_clk_t
  */
 /*@{*/
-#define SC_PM_CLK_SLV_BUS       0	/* Slave bus clock */
-#define SC_PM_CLK_MST_BUS       1	/* Master bus clock */
-#define SC_PM_CLK_PER           2	/* Peripheral clock */
-#define SC_PM_CLK_PHY           3	/* Phy clock */
-#define SC_PM_CLK_MISC          4	/* Misc clock */
-#define SC_PM_CLK_MISC0         0	/* Misc 0 clock */
-#define SC_PM_CLK_MISC1         1	/* Misc 1 clock */
-#define SC_PM_CLK_MISC2         2	/* Misc 2 clock */
-#define SC_PM_CLK_MISC3         3	/* Misc 3 clock */
-#define SC_PM_CLK_MISC4         4	/* Misc 4 clock */
-#define SC_PM_CLK_CPU           2	/* CPU clock */
-#define SC_PM_CLK_PLL           4	/* PLL */
-#define SC_PM_CLK_BYPASS        4	/* Bypass clock */
+#define SC_PM_CLK_SLV_BUS       0U	/* Slave bus clock */
+#define SC_PM_CLK_MST_BUS       1U	/* Master bus clock */
+#define SC_PM_CLK_PER           2U	/* Peripheral clock */
+#define SC_PM_CLK_PHY           3U	/* Phy clock */
+#define SC_PM_CLK_MISC          4U	/* Misc clock */
+#define SC_PM_CLK_MISC0         0U	/* Misc 0 clock */
+#define SC_PM_CLK_MISC1         1U	/* Misc 1 clock */
+#define SC_PM_CLK_MISC2         2U	/* Misc 2 clock */
+#define SC_PM_CLK_MISC3         3U	/* Misc 3 clock */
+#define SC_PM_CLK_MISC4         4U	/* Misc 4 clock */
+#define SC_PM_CLK_CPU           2U	/* CPU clock */
+#define SC_PM_CLK_PLL           4U	/* PLL */
+#define SC_PM_CLK_BYPASS        4U	/* Bypass clock */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_clk_mode_t
  */
 /*@{*/
-#define SC_PM_CLK_MODE_ROM_INIT        0	/* Clock is initialized by ROM. */
-#define SC_PM_CLK_MODE_OFF             1	/* Clock is disabled */
-#define SC_PM_CLK_MODE_ON              2	/* Clock is enabled. */
-#define SC_PM_CLK_MODE_AUTOGATE_SW     3	/* Clock is in SW autogate mode */
-#define SC_PM_CLK_MODE_AUTOGATE_HW     4	/* Clock is in HW autogate mode */
-#define SC_PM_CLK_MODE_AUTOGATE_SW_HW  5	/* Clock is in SW-HW autogate mode */
+#define SC_PM_CLK_MODE_ROM_INIT        0U	/* Clock is initialized by ROM. */
+#define SC_PM_CLK_MODE_OFF             1U	/* Clock is disabled */
+#define SC_PM_CLK_MODE_ON              2U	/* Clock is enabled. */
+#define SC_PM_CLK_MODE_AUTOGATE_SW     3U	/* Clock is in SW autogate mode */
+#define SC_PM_CLK_MODE_AUTOGATE_HW     4U	/* Clock is in HW autogate mode */
+#define SC_PM_CLK_MODE_AUTOGATE_SW_HW  5U	/* Clock is in SW-HW autogate mode */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_clk_parent_t
  */
 /*@{*/
-#define SC_PM_PARENT_XTAL              0	/* Parent is XTAL. */
-#define SC_PM_PARENT_PLL0              1	/* Parent is PLL0 */
-#define SC_PM_PARENT_PLL1              2	/* Parent is PLL1 or PLL0/2 */
-#define SC_PM_PARENT_PLL2              3	/* Parent in PLL2 or PLL0/4 */
-#define SC_PM_PARENT_BYPS              4	/* Parent is a bypass clock. */
+#define SC_PM_PARENT_XTAL              0U	/* Parent is XTAL. */
+#define SC_PM_PARENT_PLL0              1U	/* Parent is PLL0 */
+#define SC_PM_PARENT_PLL1              2U	/* Parent is PLL1 or PLL0/2 */
+#define SC_PM_PARENT_PLL2              3U	/* Parent in PLL2 or PLL0/4 */
+#define SC_PM_PARENT_BYPS              4U	/* Parent is a bypass clock. */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_reset_type_t
  */
 /*@{*/
-#define SC_PM_RESET_TYPE_COLD          0	/* Cold reset */
-#define SC_PM_RESET_TYPE_WARM          1	/* Warm reset */
-#define SC_PM_RESET_TYPE_BOARD         2	/* Board reset */
+#define SC_PM_RESET_TYPE_COLD          0U	/* Cold reset */
+#define SC_PM_RESET_TYPE_WARM          1U	/* Warm reset */
+#define SC_PM_RESET_TYPE_BOARD         2U	/* Board reset */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_reset_reason_t
  */
 /*@{*/
-#define SC_PM_RESET_REASON_POR         0	/* Power on reset */
-#define SC_PM_RESET_REASON_WARM        1	/* Warm reset */
-#define SC_PM_RESET_REASON_SW          2	/* Software reset */
-#define SC_PM_RESET_REASON_WDOG        3	/* Watchdog reset */
-#define SC_PM_RESET_REASON_LOCKUP      4	/* Lockup reset */
-#define SC_PM_RESET_REASON_TAMPER      5	/* Tamper reset */
-#define SC_PM_RESET_REASON_TEMP        6	/* Temp reset */
-#define SC_PM_RESET_REASON_LOW_VOLT    7	/* Low voltage reset */
+#define SC_PM_RESET_REASON_POR         0U	/* Power on reset */
+#define SC_PM_RESET_REASON_JTAG        1U	/* JTAG reset */
+#define SC_PM_RESET_REASON_SW          2U	/* Software reset */
+#define SC_PM_RESET_REASON_WDOG        3U	/* Partition watchdog reset */
+#define SC_PM_RESET_REASON_LOCKUP      4U	/* SCU lockup reset */
+#define SC_PM_RESET_REASON_SNVS        5U	/* SNVS reset */
+#define SC_PM_RESET_REASON_TEMP        6U	/* Temp panic reset */
+#define SC_PM_RESET_REASON_MSI         7U	/* MSI reset */
+#define SC_PM_RESET_REASON_UECC        8U	/* ECC reset */
+#define SC_PM_RESET_REASON_SCFW_WDOG   9U	/* SCFW watchdog reset */
+#define SC_PM_RESET_REASON_ROM_WDOG    10U	/* SCU ROM watchdog reset */
+#define SC_PM_RESET_REASON_SECO        11U	/* SECO reset */
+#define SC_PM_RESET_REASON_SCFW_FAULT  12U	/* SCFW fault reset */
 /*@}*/
 
 /*!
  * @name Defines for sc_pm_sys_if_t
  */
 /*@{*/
-#define SC_PM_SYS_IF_INTERCONNECT       0	/* System interconnect */
-#define SC_PM_SYS_IF_MU                 1	/* AP -> SCU message units */
-#define SC_PM_SYS_IF_OCMEM              2	/* On-chip memory (ROM/OCRAM) */
-#define SC_PM_SYS_IF_DDR                3	/* DDR memory */
+#define SC_PM_SYS_IF_INTERCONNECT       0U	/* System interconnect */
+#define SC_PM_SYS_IF_MU                 1U	/* AP -> SCU message units */
+#define SC_PM_SYS_IF_OCMEM              2U	/* On-chip memory (ROM/OCRAM) */
+#define SC_PM_SYS_IF_DDR                3U	/* DDR memory */
+/*@}*/
+
+/*!
+ * @name Defines for sc_pm_wake_src_t
+ */
+/*@{*/
+#define SC_PM_WAKE_SRC_NONE             0U	/* No wake source, used for self-kill */
+#define SC_PM_WAKE_SRC_SCU              1U	/* Wakeup from SCU to resume CPU (IRQSTEER & GIC powered down) */
+#define SC_PM_WAKE_SRC_IRQSTEER         2U	/* Wakeup from IRQSTEER to resume CPU (GIC powered down) */
+#define SC_PM_WAKE_SRC_IRQSTEER_GIC     3U	/* Wakeup from IRQSTEER+GIC to wake CPU  (GIC clock gated) */
+#define SC_PM_WAKE_SRC_GIC              4U	/* Wakeup from GIC to wake CPU */
 /*@}*/
 
 /* Types */
@@ -179,6 +197,11 @@
  */
 typedef uint8_t sc_pm_sys_if_t;
 
+/*!
+ * This type is used to specify a wake source for CPU resources.
+ */
+typedef uint8_t sc_pm_wake_src_t;
+
 /* Functions */
 
 /*!
@@ -188,7 +211,8 @@
 
 /*!
  * This function sets the system power mode. Only the owner of the
- * SC_R_SYSTEM resource can do this.
+ * SC_R_SYSTEM resource or a partition with access permissions to
+ * SC_R_SYSTEM can do this.
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     mode        power mode to apply
@@ -197,7 +221,7 @@
  *
  * Return errors:
  * - SC_ERR_PARM if invalid mode,
- * - SC_ERR_NOACCESS if caller not the owner of SC_R_SYSTEM
+ * - SC_ERR_NOACCESS if caller does not have SC_R_SYSTEM access
  *
  * @see sc_pm_set_sys_power_mode().
  */
@@ -217,10 +241,10 @@
  * - SC_ERR_NOACCESS if caller's partition is not the owner or
  *   parent of \a pt
  *
- * All resources owned by \a pt that are on will have their power
- * mode changed to \a mode.
- *
- * @see sc_pm_set_resource_power_mode().
+ * The power mode of the partitions is a max power any resource will
+ * be set to. Calling this will result in all resources owned
+ * by \a pt to have their power changed to the lower of \a mode or the
+ * individual resource mode set using sc_pm_set_resource_power_mode().
  */
 sc_err_t sc_pm_set_partition_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
 					sc_pm_power_mode_t mode);
@@ -254,20 +278,59 @@ sc_err_t sc_pm_get_sys_power_mode(sc_ipc_t ipc, sc_rm_pt_t pt,
  * - SC_ERR_NOACCESS if caller's partition is not the resource owner
  *   or parent of the owner
  *
- * Resources set to SC_PM_PW_MODE_ON will reflect the
- * power mode of the partition and will change as that changes.
+ * Resources must be at SC_PM_PW_MODE_LP mode or higher to access them,
+ * otherwise the master will get a bus error or hang.
+ *
+ * This function will record the individual resource power mode
+ * and change it if the requested mode is lower than or equal to the
+ * partition power mode set with sc_pm_set_partition_power_mode().
+ * In other words, the power mode of the resource will be the minimum
+ * of the resource power mode and the partition power mode.
  *
  * Note some resources are still not accessible even when powered up if bus
  * transactions go through a fabric not powered up. Examples of this are
  * resources in display and capture subsystems which require the display
  * controller or the imaging subsytem to be powered up first.
  *
- *  @see sc_pm_set_partition_power_mode().
+ * Not that resources are grouped into power domains by the underlying
+ * hardware. If any resource in the domain is on, the entire power domain
+ * will be on. Other power domains required to access the resource will
+ * also be turned on. Clocks required to access the peripheral will be
+ * turned on. Refer to the SoC RM for more info on power domains and access
+ * infrastructure (bus fabrics, clock domains, etc.).
  */
 sc_err_t sc_pm_set_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
 				       sc_pm_power_mode_t mode);
 
 /*!
+* This function sets the power mode for all the resources owned
+* by a child partition.
+*
+* @param[in]     ipc         IPC handle
+* @param[in]     pt          handle of child partition
+* @param[in]     mode        power mode to apply
+* @param[in]     exclude     resource to exclude
+*
+* @return Returns an error code (SC_ERR_NONE = success).
+*
+* Return errors:
+* - SC_ERR_PARM if invalid partition or mode,
+* - SC_ERR_NOACCESS if caller's partition is not the parent
+*   of \a pt
+*
+* This functions loops through all the resources owned by \a pt
+* and sets the power mode to \a mode. It will skip setting
+* \a exclude (SC_R_LAST to skip none).
+*
+* This function can only be called by the parent. It is used to
+* implement some aspects of virtualization.
+*/
+sc_err_t sc_pm_set_resource_power_mode_all(sc_ipc_t ipc,
+					   sc_rm_pt_t pt,
+					   sc_pm_power_mode_t mode,
+					   sc_rsrc_t exclude);
+
+/*!
  * This function gets the power mode of a resource.
  *
  * @param[in]     ipc         IPC handle
@@ -295,7 +358,7 @@ sc_err_t sc_pm_get_resource_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    ID of the resource
- * @param[out]    mode        pointer to return power mode
+ * @param[in]     mode        power mode to apply
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
@@ -304,6 +367,30 @@ sc_err_t sc_pm_req_low_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
 				  sc_pm_power_mode_t mode);
 
 /*!
+ * This function requests low-power mode entry for CPU/cluster
+ * resources. This API is only valid for the following resources:
+ * SC_R_A53, SC_R_A53_x, SC_R_A72, SC_R_A72_x, SC_R_A35, SC_R_A35_x,
+ * SC_R_CCI. For all other resources it will return SC_ERR_PARAM.
+ * For individual core resources, the specified power mode
+ * and wake source will be applied after the core has entered
+ * WFI.  For cluster resources, the specified power mode is
+ * applied after all cores in the cluster have entered low-power mode.
+ * For multicluster resources, the specified power mode is applied
+ * after all clusters have reached low-power mode.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the resource
+ * @param[in]     mode        power mode to apply
+ * @param[in]     wake_src    wake source for low-power exit
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ */
+sc_err_t sc_pm_req_cpu_low_power_mode(sc_ipc_t ipc, sc_rsrc_t resource,
+				      sc_pm_power_mode_t mode,
+				      sc_pm_wake_src_t wake_src);
+
+/*!
  * This function is used to set the resume address of a CPU.
  *
  * @param[in]     ipc         IPC handle
@@ -321,6 +408,25 @@ sc_err_t sc_pm_set_cpu_resume_addr(sc_ipc_t ipc, sc_rsrc_t resource,
 				   sc_faddr_t address);
 
 /*!
+ * This function is used to set parameters for CPU resume from
+ * low-power mode.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the CPU resource
+ * @param[in]     isPrimary   set SC_TRUE if primary wake CPU
+ * @param[in]     address     64-bit resume address
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid resource or address,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of the
+ *   resource (CPU) owner
+ */
+sc_err_t sc_pm_set_cpu_resume(sc_ipc_t ipc, sc_rsrc_t resource,
+			      sc_bool_t isPrimary, sc_faddr_t address);
+
+/*!
  * This function requests the power mode configuration for system-level
  * interfaces including messaging units, interconnect, and memories.  This API
  * is only valid for the following resources : SC_R_A53, SC_R_A72, and
@@ -398,9 +504,15 @@ sc_err_t sc_pm_get_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    ID of the resource
  * @param[in]     clk         clock to affect
- * @param[in]     enable      enable if true; otherwise disabled
+ * @param[in]     enable      enable if SC_TRUE; otherwise disabled
  * @param[in]     autog       HW auto clock gating
  *
+ * If \a resource is SC_R_ALL then all resources owned will be affected.
+ * No error will be returned.
+ *
+ * If \a clk is SC_PM_CLK_ALL, then an error will be returned if any
+ * of the available clocks returns an error.
+ *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
  * Return errors:
@@ -412,7 +524,7 @@ sc_err_t sc_pm_get_clock_rate(sc_ipc_t ipc, sc_rsrc_t resource,
  * Refer to the [Clock List](@ref CLOCKS) for valid clock values.
  */
 sc_err_t sc_pm_clock_enable(sc_ipc_t ipc, sc_rsrc_t resource,
-			    sc_pm_clk_t clk, bool enable, bool autog);
+			    sc_pm_clk_t clk, sc_bool_t enable, sc_bool_t autog);
 
 /*!
  * This function sets the parent of a resource's clock.
@@ -431,6 +543,7 @@ sc_err_t sc_pm_clock_enable(sc_ipc_t ipc, sc_rsrc_t resource,
  *   or parent of the owner,
  * - SC_ERR_UNAVAILABLE if clock not applicable to this resource
  * - SC_ERR_BUSY if clock is currently enabled.
+ * - SC_ERR_NOPOWER if resource not powered
  *
  * Refer to the [Clock List](@ref CLOCKS) for valid clock values.
  */
@@ -467,7 +580,8 @@ sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
 
 /*!
  * This function is used to reset the system. Only the owner of the
- * SC_R_SYSTEM resource can do this.
+ * SC_R_SYSTEM resource or a partition with access permissions to
+ * SC_R_SYSTEM can do this.
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     type        reset type
@@ -476,7 +590,7 @@ sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
  *
  * Return errors:
  * - SC_ERR_PARM if invalid type,
- * - SC_ERR_NOACCESS if caller not the owner of SC_R_SYSTEM
+ * - SC_ERR_NOACCESS if caller cannot access SC_R_SYSTEM
  *
  * If this function returns, then the reset did not occur due to an
  * invalid parameter.
@@ -489,6 +603,13 @@ sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     ipc         IPC handle
  * @param[out]    reason      pointer to return reset reason
  *
+ * This function returns the reason a partition was reset. If the reason
+ * is POR, then the system reset reason will be returned.
+ *
+ * Note depending on the connection of the WDOG_OUT signal and the OTP
+ * programming of the PMIC, some resets may trigger a system POR
+ * and the original reason will be lost.
+ *
  * @return Returns an error code (SC_ERR_NONE = success).
  */
 sc_err_t sc_pm_reset_reason(sc_ipc_t ipc, sc_pm_reset_reason_t *reason);
@@ -509,6 +630,10 @@ sc_err_t sc_pm_get_clock_parent(sc_ipc_t ipc, sc_rsrc_t resource,
  * - SC_ERR_PARM if invalid partition, resource, or addr,
  * - SC_ERR_NOACCESS if caller's partition is not the parent of the
  *   partition to boot
+ *
+ * This must be used to boot a partition. Only a partition booted this
+ * way can be rebooted using the watchdog, sc_pm_boot() or
+ * sc_pm_reboot_partition().
  */
 sc_err_t sc_pm_boot(sc_ipc_t ipc, sc_rm_pt_t pt,
 		    sc_rsrc_t resource_cpu, sc_faddr_t boot_addr,
@@ -560,7 +685,8 @@ sc_err_t sc_pm_boot(sc_ipc_t ipc, sc_rm_pt_t pt,
  *
  * Return errors:
  * - SC_ERR_PARM if invalid partition or type
- * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt,
+ * - SC_ERR_NOACCESS if caller's partition is not the parent of \a pt
+ *   and the caller does not have access to SC_R_SYSTEM
  *
  * Most peripherals owned by the partition will be reset if
  * possible. SC state (partitions, power, clocks, etc.) is reset. The
@@ -575,7 +701,7 @@ sc_err_t sc_pm_reboot_partition(sc_ipc_t ipc, sc_rm_pt_t pt,
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    ID of the CPU resource
- * @param[in]     enable      start if true; otherwise stop
+ * @param[in]     enable      start if SC_TRUE; otherwise stop
  * @param[in]     address     64-bit boot address
  *
  * @return Returns an error code (SC_ERR_NONE = success).
@@ -584,12 +710,41 @@ sc_err_t sc_pm_reboot_partition(sc_ipc_t ipc, sc_rm_pt_t pt,
  * - SC_ERR_PARM if invalid resource or address,
  * - SC_ERR_NOACCESS if caller's partition is not the parent of the
  *   resource (CPU) owner
+ *
+ * This function is usually used to start a secondar CPU in the
+ * same partition as the caller.  It is not used to start the first
+ * CPU in a dedicated partition.  That would be started by calling
+ * sc_pm_boot().
+ *
+ * A CPU started with sc_pm_cpu_start() will not restart as a result
+ * of a watchdog event or calling sc_pm_reboot() or sc_pm_reboot_partition().
+ * Those will reboot that partition which will start the CPU started with
+ * sc_pm_boot().
  */
-sc_err_t sc_pm_cpu_start(sc_ipc_t ipc, sc_rsrc_t resource, bool enable,
+sc_err_t sc_pm_cpu_start(sc_ipc_t ipc, sc_rsrc_t resource, sc_bool_t enable,
 			 sc_faddr_t address);
 
+/*!
+ * This function is used to reset a CPU.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     resource    ID of the CPU resource
+ * @param[in]     address     64-bit boot address
+ *
+ * This function does not return anything as the calling core may have been
+ * reset. It can still fail if the resource or address is invalid. It can also
+ * fail if the caller's partition is not the owner of the CPU, not the parent
+ * of the CPU resource owner, or has access to SC_R_SYSTEM. Will also fail if
+ * the resource is not powered on. No indication of failure is returned.
+ *
+ * Note this just resets the CPU. None of the peripherals or bus fabric used by
+ * the CPU is reset. State configured in the SCFW is not reset. The SW running
+ * on the core has to understand and deal with this.
+ */
+void sc_pm_cpu_reset(sc_ipc_t ipc, sc_rsrc_t resource, sc_faddr_t address);
+
 /* @} */
 
-#endif				/* _SC_PM_API_H */
+#endif				/* SC_PM_API_H */
 
 /**@}*/
diff --git a/include/soc/imx8/sc/svc/rm/api.h b/include/soc/imx8/sc/svc/rm/api.h
index 1b798fe..7bd2bf4 100644
--- a/include/soc/imx8/sc/svc/rm/api.h
+++ b/include/soc/imx8/sc/svc/rm/api.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -19,8 +19,8 @@
  * @{
  */
 
-#ifndef _SC_RM_API_H
-#define _SC_RM_API_H
+#ifndef SC_RM_API_H
+#define SC_RM_API_H
 
 /* Includes */
 
@@ -32,44 +32,44 @@
  * @name Defines for type widths
  */
 /*@{*/
-#define SC_RM_PARTITION_W   5	/* Width of sc_rm_pt_t */
-#define SC_RM_MEMREG_W      6	/* Width of sc_rm_mr_t */
-#define SC_RM_DID_W         4	/* Width of sc_rm_did_t */
-#define SC_RM_SID_W         6	/* Width of sc_rm_sid_t */
-#define SC_RM_SPA_W         2	/* Width of sc_rm_spa_t */
-#define SC_RM_PERM_W        3	/* Width of sc_rm_perm_t */
+#define SC_RM_PARTITION_W   5U	/* Width of sc_rm_pt_t */
+#define SC_RM_MEMREG_W      6U	/* Width of sc_rm_mr_t */
+#define SC_RM_DID_W         4U	/* Width of sc_rm_did_t */
+#define SC_RM_SID_W         6U	/* Width of sc_rm_sid_t */
+#define SC_RM_SPA_W         2U	/* Width of sc_rm_spa_t */
+#define SC_RM_PERM_W        3U	/* Width of sc_rm_perm_t */
 /*@}*/
 
 /*!
  * @name Defines for ALL parameters
  */
 /*@{*/
-#define SC_RM_PT_ALL        UINT8_MAX	/* All partitions */
-#define SC_RM_MR_ALL        UINT8_MAX	/* All memory regions */
+#define SC_RM_PT_ALL        ((sc_rm_pt_t) UINT8_MAX)	/* All partitions */
+#define SC_RM_MR_ALL        ((sc_rm_mr_t) UINT8_MAX)	/* All memory regions */
 /*@}*/
 
 /*!
  * @name Defines for sc_rm_spa_t
  */
 /*@{*/
-#define SC_RM_SPA_PASSTHRU  0	/* Pass through (attribute driven by master) */
-#define SC_RM_SPA_PASSSID   1	/* Pass through and output on SID */
-#define SC_RM_SPA_ASSERT    2	/* Assert (force to be secure/privileged) */
-#define SC_RM_SPA_NEGATE    3	/* Negate (force to be non-secure/user) */
+#define SC_RM_SPA_PASSTHRU  0U	/* Pass through (attribute driven by master) */
+#define SC_RM_SPA_PASSSID   1U	/* Pass through and output on SID */
+#define SC_RM_SPA_ASSERT    2U	/* Assert (force to be secure/privileged) */
+#define SC_RM_SPA_NEGATE    3U	/* Negate (force to be non-secure/user) */
 /*@}*/
 
 /*!
  * @name Defines for sc_rm_perm_t
  */
 /*@{*/
-#define SC_RM_PERM_NONE         0	/* No access */
-#define SC_RM_PERM_SEC_R        1	/* Secure RO */
-#define SC_RM_PERM_SECPRIV_RW   2	/* Secure privilege R/W */
-#define SC_RM_PERM_SEC_RW       3	/* Secure R/W */
-#define SC_RM_PERM_NSPRIV_R     4	/* Secure R/W, non-secure privilege RO */
-#define SC_RM_PERM_NS_R         5	/* Secure R/W, non-secure RO */
-#define SC_RM_PERM_NSPRIV_RW    6	/* Secure R/W, non-secure privilege R/W */
-#define SC_RM_PERM_FULL         7	/* Full access */
+#define SC_RM_PERM_NONE         0U	/* No access */
+#define SC_RM_PERM_SEC_R        1U	/* Secure RO */
+#define SC_RM_PERM_SECPRIV_RW   2U	/* Secure privilege R/W */
+#define SC_RM_PERM_SEC_RW       3U	/* Secure R/W */
+#define SC_RM_PERM_NSPRIV_R     4U	/* Secure R/W, non-secure privilege RO */
+#define SC_RM_PERM_NS_R         5U	/* Secure R/W, non-secure RO */
+#define SC_RM_PERM_NSPRIV_RW    6U	/* Secure R/W, non-secure privilege R/W */
+#define SC_RM_PERM_FULL         7U	/* Full access */
 /*@}*/
 
 /* Types */
@@ -122,13 +122,13 @@
  * @param[in]     secure       boolean indicating if this partition should be secure; only
  *                             valid if caller is secure
  * @param[in]     isolated     boolean indicating if this partition should be HW isolated
- *                             via XRDC; set true if new DID is desired
+ *                             via XRDC; set SC_TRUE if new DID is desired
  * @param[in]     restricted   boolean indicating if this partition should be restricted; set
- *                             true if masters in this partition cannot create new partitions
+ *                             SC_TRUE if masters in this partition cannot create new partitions
  * @param[in]     grant        boolean indicating if this partition should always grant
  *                             access and control to the parent
  * @param[in]     coherent     boolean indicating if this partition is coherent;
- *                             set true if only this partition will contain both AP clusters
+ *                             set SC_TRUE if only this partition will contain both AP clusters
  *                             and they will be coherent via the CCI
  *
  * @return Returns an error code (SC_ERR_NONE = success).
@@ -147,9 +147,9 @@
  * memory without isolating the peripheral interface of the master or the API
  * controls of that master.
  */
-sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, bool secure,
-			       bool isolated, bool restricted, bool grant,
-			       bool coherent);
+sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, sc_bool_t secure,
+			       sc_bool_t isolated, sc_bool_t restricted,
+			       sc_bool_t grant, sc_bool_t coherent);
 
 /*!
  * This function makes a partition confidential.
@@ -171,7 +171,7 @@ sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, bool secure,
  * If retroactive, then all resources owned by other partitions will have
  * access rights for this partition removed, even if locked.
  */
-sc_err_t sc_rm_set_confidential(sc_ipc_t ipc, sc_rm_pt_t pt, bool retro);
+sc_err_t sc_rm_set_confidential(sc_ipc_t ipc, sc_rm_pt_t pt, sc_bool_t retro);
 
 /*!
  * This function frees a partition and assigns all resources to the caller.
@@ -299,7 +299,7 @@ sc_err_t sc_rm_partition_alloc(sc_ipc_t ipc, sc_rm_pt_t *pt, bool secure,
  * - SC_ERR_LOCKED if either partition is locked
  */
 sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
-			bool move_rsrc, bool move_pads);
+			sc_bool_t move_rsrc, sc_bool_t move_pads);
 
 /* @} */
 
@@ -323,7 +323,7 @@ sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
  * ASSERT if the partition si secure and NEGATE if it is not, and
  * masters will defaulted to SMMU bypass. Access permissions will reset
  * to SEC_RW for the owning partition only for secure partitions, FULL for
- * non-secure. DEfault is no access by other partitions.
+ * non-secure. Default is no access by other partitions.
  *
  * Return errors:
  * - SC_ERR_NOACCESS if caller's partition is restricted,
@@ -340,7 +340,7 @@ sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
  * @param[in]     ipc          IPC handle
  * @param[in]     resource_fst first resource for which flag should be set
  * @param[in]     resource_lst last resource for which flag should be set
- * @param[in]     movable      movable flag (true) is movable
+ * @param[in]     movable      movable flag (SC_TRUE is movable)
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
@@ -355,7 +355,7 @@ sc_err_t sc_rm_move_all(sc_ipc_t ipc, sc_rm_pt_t pt_src, sc_rm_pt_t pt_dst,
  * resources from moving.
  */
 sc_err_t sc_rm_set_resource_movable(sc_ipc_t ipc, sc_rsrc_t resource_fst,
-				    sc_rsrc_t resource_lst, bool movable);
+				    sc_rsrc_t resource_lst, sc_bool_t movable);
 
 /*!
  * This function flags all of a subsystem's resources as movable
@@ -363,7 +363,7 @@ sc_err_t sc_rm_set_resource_movable(sc_ipc_t ipc, sc_rsrc_t resource_fst,
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    resource to use to identify subsystem
- * @param[in]     movable     movable flag (true) is movable
+ * @param[in]     movable     movable flag (SC_TRUE is movable)
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
@@ -374,7 +374,7 @@ sc_err_t sc_rm_set_resource_movable(sc_ipc_t ipc, sc_rsrc_t resource_fst,
  * resources owned by the caller are set.
  */
 sc_err_t sc_rm_set_subsys_rsrc_movable(sc_ipc_t ipc, sc_rsrc_t resource,
-				       bool movable);
+				       sc_bool_t movable);
 
 /*!
  * This function sets attributes for a resource which is a bus master (i.e.
@@ -400,7 +400,7 @@ sc_err_t sc_rm_set_subsys_rsrc_movable(sc_ipc_t ipc, sc_rsrc_t resource,
  */
 sc_err_t sc_rm_set_master_attributes(sc_ipc_t ipc, sc_rsrc_t resource,
 				     sc_rm_spa_t sa, sc_rm_spa_t pa,
-				     bool smmu_bypass);
+				     sc_bool_t smmu_bypass);
 
 /*!
  * This function sets the StreamID for a resource which is a bus master (i.e.
@@ -444,7 +444,8 @@ sc_err_t sc_rm_set_master_sid(sc_ipc_t ipc, sc_rsrc_t resource,
  * - SC_ERR_LOCKED if the \a pt is confidential and the caller isn't \a pt
  *
  * This function configures how the HW isolation will restrict access to a
- * peripheral based on the attributes of a transaction from bus master.
+ * peripheral based on the attributes of a transaction from bus master. It
+ * also allows the access permissions of SC_R_SYSTEM to be set.
  */
 sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
 					  sc_rm_pt_t pt, sc_rm_perm_t perm);
@@ -455,11 +456,11 @@ sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    resource to check
  *
- * @return Returns a boolean (true if caller's partition owns the resource).
+ * @return Returns a boolean (SC_TRUE if caller's partition owns the resource).
  *
- * If \a resource is out of range then false is returned.
+ * If \a resource is out of range then SC_FALSE is returned.
  */
-bool sc_rm_is_resource_owned(sc_ipc_t ipc, sc_rsrc_t resource);
+sc_bool_t sc_rm_is_resource_owned(sc_ipc_t ipc, sc_rsrc_t resource);
 
 /*!
  * This function is used to test if a resource is a bus master.
@@ -467,11 +468,11 @@ sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    resource to check
  *
- * @return Returns a boolean (true if the resource is a bus master).
+ * @return Returns a boolean (SC_TRUE if the resource is a bus master).
  *
- * If \a resource is out of range then false is returned.
+ * If \a resource is out of range then SC_FALSE is returned.
  */
-bool sc_rm_is_resource_master(sc_ipc_t ipc, sc_rsrc_t resource);
+sc_bool_t sc_rm_is_resource_master(sc_ipc_t ipc, sc_rsrc_t resource);
 
 /*!
  * This function is used to test if a resource is a peripheral.
@@ -479,11 +480,11 @@ sc_err_t sc_rm_set_peripheral_permissions(sc_ipc_t ipc, sc_rsrc_t resource,
  * @param[in]     ipc         IPC handle
  * @param[in]     resource    resource to check
  *
- * @return Returns a boolean (true if the resource is a peripheral).
+ * @return Returns a boolean (SC_TRUE if the resource is a peripheral).
  *
- * If \a resource is out of range then false is returned.
+ * If \a resource is out of range then SC_FALSE is returned.
  */
-bool sc_rm_is_resource_peripheral(sc_ipc_t ipc, sc_rsrc_t resource);
+sc_bool_t sc_rm_is_resource_peripheral(sc_ipc_t ipc, sc_rsrc_t resource);
 
 /*!
  * This function is used to obtain info about a resource.
@@ -564,6 +565,32 @@ sc_err_t sc_rm_memreg_split(sc_ipc_t ipc, sc_rm_mr_t mr,
 			    sc_faddr_t addr_end);
 
 /*!
+ * This function requests that the SC fragment a memory region.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[out]    mr_ret      return handle for new region; used for
+ *                            subsequent function calls
+ *                            associated with this region
+ * @param[in]     addr_start  start address of region (physical)
+ * @param[in]     addr_end    end address of region (physical)
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_LOCKED if caller's partition is locked,
+ * - SC_ERR_PARM if the new memory region spans multiple existing regions,
+ * - SC_ERR_NOACCESS if caller's partition does not own the memory containing
+ *   the new region,
+ * - SC_ERR_UNAVAILABLE if memory region table is full (no more allocation
+ *   space)
+ *
+ * This function finds the memory region containing the address range.
+ * It then splits it as required and returns the extracted region.
+ */
+sc_err_t sc_rm_memreg_frag(sc_ipc_t ipc, sc_rm_mr_t *mr_ret,
+			   sc_faddr_t addr_start, sc_faddr_t addr_end);
+
+/*!
  * This function frees a memory region.
  *
  * @param[in]     ipc         IPC handle
@@ -653,12 +680,12 @@ sc_err_t sc_rm_set_memreg_permissions(sc_ipc_t ipc, sc_rm_mr_t mr,
  * @param[in]     ipc         IPC handle
  * @param[in]     mr          handle of memory region to check
  *
- * @return Returns a boolean (true if caller's partition owns the
+ * @return Returns a boolean (SC_TRUE if caller's partition owns the
  * memory region).
  *
- * If \a mr is out of range then false is returned.
+ * If \a mr is out of range then SC_FALSE is returned.
  */
-bool sc_rm_is_memreg_owned(sc_ipc_t ipc, sc_rm_mr_t mr);
+sc_bool_t sc_rm_is_memreg_owned(sc_ipc_t ipc, sc_rm_mr_t mr);
 
 /*!
  * This function is used to obtain info about a memory region.
@@ -708,7 +735,7 @@ sc_err_t sc_rm_get_memreg_info(sc_ipc_t ipc, sc_rm_mr_t mr,
  * @param[in]     ipc         IPC handle
  * @param[in]     pad_fst     first pad for which flag should be set
  * @param[in]     pad_lst     last pad for which flag should be set
- * @param[in]     movable     movable flag (true) is movable
+ * @param[in]     movable     movable flag (SC_TRUE is movable)
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  *
@@ -723,7 +750,7 @@ sc_err_t sc_rm_get_memreg_info(sc_ipc_t ipc, sc_rm_mr_t mr,
  * pads from moving.
  */
 sc_err_t sc_rm_set_pad_movable(sc_ipc_t ipc, sc_pad_t pad_fst,
-			       sc_pad_t pad_lst, bool movable);
+			       sc_pad_t pad_lst, sc_bool_t movable);
 
 /*!
  * This function gets ownership status of a pad.
@@ -731,11 +758,11 @@ sc_err_t sc_rm_set_pad_movable(sc_ipc_t ipc, sc_pad_t pad_fst,
  * @param[in]     ipc         IPC handle
  * @param[in]     pad         pad to check
  *
- * @return Returns a boolean (true if caller's partition owns the pad).
+ * @return Returns a boolean (SC_TRUE if caller's partition owns the pad).
  *
- * If \a pad is out of range then false is returned.
+ * If \a pad is out of range then SC_FALSE is returned.
  */
-bool sc_rm_is_pad_owned(sc_ipc_t ipc, sc_pad_t pad);
+sc_bool_t sc_rm_is_pad_owned(sc_ipc_t ipc, sc_pad_t pad);
 
 /* @} */
 
@@ -753,6 +780,6 @@ sc_err_t sc_rm_set_pad_movable(sc_ipc_t ipc, sc_pad_t pad_fst,
 
 /* @} */
 
-#endif				/* _SC_RM_API_H */
+#endif				/* SC_RM_API_H */
 
 /**@}*/
diff --git a/include/soc/imx8/sc/svc/timer/api.h b/include/soc/imx8/sc/svc/timer/api.h
index 2f7e298..a38afc3 100644
--- a/include/soc/imx8/sc/svc/timer/api.h
+++ b/include/soc/imx8/sc/svc/timer/api.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * SPDX-License-Identifier:     GPL-2.0+
  */
@@ -18,8 +18,8 @@
  * @{
  */
 
-#ifndef _SC_TIMER_API_H
-#define _SC_TIMER_API_H
+#ifndef SC_TIMER_API_H
+#define SC_TIMER_API_H
 
 /* Includes */
 
@@ -32,18 +32,18 @@
  * @name Defines for type widths
  */
 /*@{*/
-#define SC_TIMER_ACTION_W   3	/* Width of sc_timer_wdog_action_t */
+#define SC_TIMER_ACTION_W   3U	/* Width of sc_timer_wdog_action_t */
 /*@}*/
 
 /*!
  * @name Defines for sc_timer_wdog_action_t
  */
 /*@{*/
-#define SC_TIMER_WDOG_ACTION_PARTITION      0	/* Reset partition */
-#define SC_TIMER_WDOG_ACTION_WARM           1	/* Warm reset system */
-#define SC_TIMER_WDOG_ACTION_COLD           2	/* Cold reset system */
-#define SC_TIMER_WDOG_ACTION_BOARD          3	/* Reset board */
-#define SC_TIMER_WDOG_ACTION_IRQ            4	/* Only generate IRQs */
+#define SC_TIMER_WDOG_ACTION_PARTITION      0U	/* Reset partition */
+#define SC_TIMER_WDOG_ACTION_WARM           1U	/* Warm reset system */
+#define SC_TIMER_WDOG_ACTION_COLD           2U	/* Cold reset system */
+#define SC_TIMER_WDOG_ACTION_BOARD          3U	/* Reset board */
+#define SC_TIMER_WDOG_ACTION_IRQ            4U	/* Only generate IRQs */
 /*@}*/
 
 /* Types */
@@ -106,7 +106,7 @@ sc_err_t sc_timer_set_wdog_pre_timeout(sc_ipc_t ipc,
  * If \a lock is set then the watchdog cannot be stopped or the timeout
  * period changed.
  */
-sc_err_t sc_timer_start_wdog(sc_ipc_t ipc, bool lock);
+sc_err_t sc_timer_start_wdog(sc_ipc_t ipc, sc_bool_t lock);
 
 /*!
  * This function stops the watchdog if it is not locked.
@@ -158,7 +158,8 @@ sc_err_t sc_timer_get_wdog_status(sc_ipc_t ipc,
  *
  * @return Returns an error code (SC_ERR_NONE = success).
  */
-sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt, bool *enb,
+sc_err_t sc_timer_pt_get_wdog_status(sc_ipc_t ipc, sc_rm_pt_t pt,
+				     sc_bool_t *enb,
 				     sc_timer_wdog_time_t *timeout,
 				     sc_timer_wdog_time_t *remaining_time);
 
@@ -191,7 +192,8 @@ sc_err_t sc_timer_set_wdog_action(sc_ipc_t ipc,
 
 /*!
  * This function sets the RTC time. Only the owner of the SC_R_SYSTEM
- * resource can set the time.
+ * resource or a partition with access permissions to SC_R_SYSTEM can
+ * set the time.
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     year        year (min 1970)
@@ -205,7 +207,7 @@ sc_err_t sc_timer_set_wdog_action(sc_ipc_t ipc,
  *
  * Return errors:
  * - SC_ERR_PARM if invalid time/date parameters,
- * - SC_ERR_NOACCESS if caller's partition is not the SYSTEM owner
+ * - SC_ERR_NOACCESS if caller's partition cannot access SC_R_SYSTEM
  */
 sc_err_t sc_timer_set_rtc_time(sc_ipc_t ipc, uint16_t year, uint8_t mon,
 			       uint8_t day, uint8_t hour, uint8_t min,
@@ -261,8 +263,36 @@ sc_err_t sc_timer_set_rtc_alarm(sc_ipc_t ipc, uint16_t year, uint8_t mon,
 				uint8_t sec);
 
 /*!
+ * This function sets the RTC alarm (periodic mode).
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     sec         period in seconds
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters
+ */
+sc_err_t sc_timer_set_rtc_periodic_alarm(sc_ipc_t ipc, uint32_t sec);
+
+/*!
+ * This function cancels the RTC alarm.
+ *
+ * @param[in]     ipc         IPC handle
+ *
+ * Note this alarm setting clears when the alarm is triggered.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters
+ */
+sc_err_t sc_timer_cancel_rtc_alarm(sc_ipc_t ipc);
+
+/*!
  * This function sets the RTC calibration value. Only the owner of the SC_R_SYSTEM
- * resource can set the calibration.
+ * resource or a partition with access permissions to SC_R_SYSTEM can set the
+ * calibration.
  *
  * @param[in]     ipc         IPC handle
  * @param[in]     count       calbration count (-16 to 15)
@@ -277,6 +307,55 @@ sc_err_t sc_timer_set_rtc_alarm(sc_ipc_t ipc, uint16_t year, uint8_t mon,
 
 /* @} */
 
-#endif				/* _SC_TIMER_API_H */
+/*!
+ * @name System Counter (SYSCTR) Functions
+ * @{
+ */
+
+/*!
+ * This function sets the SYSCTR alarm.
+ *
+ * @param[in]     ipc         IPC handle
+ * @param[in]     ticks       number of 8MHz cycles
+ *
+ * Note this alarm setting clears when the alarm is triggered.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters
+ */
+sc_err_t sc_timer_set_sysctr_alarm(sc_ipc_t ipc, uint64_t ticks);
+
+/*!
+ * This function sets the SYSCTR alarm (periodic mode).
+ *
+ * @param[in]     ipc          IPC handle
+ * @param[in]     ticks        number of 8MHz cycles
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters
+ */
+sc_err_t sc_timer_set_sysctr_periodic_alarm(sc_ipc_t ipc, uint64_t ticks);
+
+/*!
+ * This function cancels the SYSCTR alarm.
+ *
+ * @param[in]     ipc         IPC handle
+ *
+ * Note this alarm setting clears when the alarm is triggered.
+ *
+ * @return Returns an error code (SC_ERR_NONE = success).
+ *
+ * Return errors:
+ * - SC_ERR_PARM if invalid time/date parameters
+ */
+sc_err_t sc_timer_cancel_sysctr_alarm(sc_ipc_t ipc);
+
+/* @} */
+
+#endif				/* SC_TIMER_API_H */
 
 /**@}*/
diff --git a/include/soc/imx8/sc/types.h b/include/soc/imx8/sc/types.h
index c2bb434..9d4f22e 100644
--- a/include/soc/imx8/sc/types.h
+++ b/include/soc/imx8/sc/types.h
@@ -9,8 +9,8 @@
  * Header file containing types used across multiple service APIs.
  */
 
-#ifndef _SC_TYPES_H
-#define _SC_TYPES_H
+#ifndef SC_TYPES_H
+#define SC_TYPES_H
 
 /* Includes */
 
@@ -22,119 +22,785 @@
  * @name Defines for common frequencies
  */
 /*@{*/
-#define SC_32KHZ            32768	/* 32KHz */
-#define SC_10MHZ         10000000	/* 10MHz */
-#define SC_20MHZ         20000000	/* 20MHz */
-#define SC_25MHZ         25000000	/* 25MHz */
-#define SC_27MHZ         27000000	/* 27MHz */
-#define SC_40MHZ         40000000	/* 40MHz */
-#define SC_45MHZ         45000000	/* 45MHz */
-#define SC_50MHZ         50000000	/* 50MHz */
-#define SC_60MHZ         60000000	/* 60MHz */
-#define SC_66MHZ         66666666	/* 66MHz */
-#define SC_74MHZ         74250000	/* 74.25MHz */
-#define SC_80MHZ         80000000	/* 80MHz */
-#define SC_83MHZ         83333333	/* 83MHz */
-#define SC_84MHZ         84375000	/* 84.37MHz */
-#define SC_100MHZ       100000000	/* 100MHz */
-#define SC_125MHZ       125000000	/* 125MHz */
-#define SC_133MHZ       133333333	/* 133MHz */
-#define SC_135MHZ       135000000	/* 135MHz */
-#define SC_150MHZ       150000000	/* 150MHz */
-#define SC_160MHZ       160000000	/* 160MHz */
-#define SC_166MHZ       166666666	/* 160MHz */
-#define SC_175MHZ       175000000	/* 175MHz */
-#define SC_180MHZ       180000000	/* 180MHz */
-#define SC_200MHZ       200000000	/* 200MHz */
-#define SC_250MHZ       250000000	/* 250MHz */
-#define SC_266MHZ       266666666	/* 266MHz */
-#define SC_300MHZ       300000000	/* 300MHz */
-#define SC_320MHZ       320000000	/* 320MHz */
-#define SC_325MHZ       325000000	/* 325MHz */
-#define SC_333MHZ       333333333	/* 333MHz */
-#define SC_350MHZ       350000000	/* 350MHz */
-#define SC_372MHZ       372000000	/* 372MHz */
-#define SC_375MHZ       375000000	/* 375MHz */
-#define SC_400MHZ       400000000	/* 400MHz */
-#define SC_500MHZ       500000000	/* 500MHz */
-#define SC_594MHZ       594000000	/* 594MHz */
-#define SC_650MHZ       650000000	/* 650MHz */
-#define SC_667MHZ       666666667	/* 667MHz */
-#define SC_675MHZ       675000000	/* 675MHz */
-#define SC_700MHZ       700000000	/* 700MHz */
-#define SC_720MHZ       720000000	/* 720MHz */
-#define SC_750MHZ       750000000	/* 750MHz */
-#define SC_800MHZ       800000000	/* 800MHz */
-#define SC_850MHZ       850000000	/* 850MHz */
-#define SC_900MHZ       900000000	/* 900MHz */
-#define SC_1000MHZ     1000000000	/* 1GHz */
-#define SC_1056MHZ     1056000000	/* 1.056GHz */
-#define SC_1188MHZ     1188000000	/* 1.188GHz */
-#define SC_1260MHZ     1260000000	/* 1.26GHz */
-#define SC_1300MHZ     1300000000	/* 1.3GHz */
-#define SC_1400MHZ     1400000000	/* 1.4GHz */
-#define SC_1500MHZ     1500000000	/* 1.5GHz */
-#define SC_1600MHZ     1600000000	/* 1.6GHz */
-#define SC_1800MHZ     1800000000	/* 1.8GHz */
-#define SC_2000MHZ     2000000000	/* 2.0GHz */
-#define SC_2112MHZ     2112000000	/* 2.12GHz */
-
+#define SC_32KHZ            32768U	/* 32KHz */
+#define SC_10MHZ         10000000U	/* 10MHz */
+#define SC_20MHZ         20000000U	/* 20MHz */
+#define SC_25MHZ         25000000U	/* 25MHz */
+#define SC_27MHZ         27000000U	/* 27MHz */
+#define SC_40MHZ         40000000U	/* 40MHz */
+#define SC_45MHZ         45000000U	/* 45MHz */
+#define SC_50MHZ         50000000U	/* 50MHz */
+#define SC_60MHZ         60000000U	/* 60MHz */
+#define SC_66MHZ         66666666U	/* 66MHz */
+#define SC_74MHZ         74250000U	/* 74.25MHz */
+#define SC_80MHZ         80000000U	/* 80MHz */
+#define SC_83MHZ         83333333U	/* 83MHz */
+#define SC_84MHZ         84375000U	/* 84.37MHz */
+#define SC_100MHZ       100000000U	/* 100MHz */
+#define SC_125MHZ       125000000U	/* 125MHz */
+#define SC_133MHZ       133333333U	/* 133MHz */
+#define SC_135MHZ       135000000U	/* 135MHz */
+#define SC_150MHZ       150000000U	/* 150MHz */
+#define SC_160MHZ       160000000U	/* 160MHz */
+#define SC_166MHZ       166666666U	/* 166MHz */
+#define SC_175MHZ       175000000U	/* 175MHz */
+#define SC_180MHZ       180000000U	/* 180MHz */
+#define SC_200MHZ       200000000U	/* 200MHz */
+#define SC_250MHZ       250000000U	/* 250MHz */
+#define SC_266MHZ       266666666U	/* 266MHz */
+#define SC_300MHZ       300000000U	/* 300MHz */
+#define SC_312MHZ       312500000U	/* 312.5MHZ */
+#define SC_320MHZ       320000000U	/* 320MHz */
+#define SC_325MHZ       325000000U	/* 325MHz */
+#define SC_333MHZ       333333333U	/* 333MHz */
+#define SC_350MHZ       350000000U	/* 350MHz */
+#define SC_372MHZ       372000000U	/* 372MHz */
+#define SC_375MHZ       375000000U	/* 375MHz */
+#define SC_400MHZ       400000000U	/* 400MHz */
+#define SC_500MHZ       500000000U	/* 500MHz */
+#define SC_594MHZ       594000000U	/* 594MHz */
+#define SC_625MHZ       625000000U	/* 625MHz */
+#define SC_640MHZ       640000000U	/* 640MHz */
+#define SC_648MHZ       648000000U	/* 648MHz */
+#define SC_650MHZ       650000000U	/* 650MHz */
+#define SC_667MHZ       666666667U	/* 667MHz */
+#define SC_675MHZ       675000000U	/* 675MHz */
+#define SC_700MHZ       700000000U	/* 700MHz */
+#define SC_720MHZ       720000000U	/* 720MHz */
+#define SC_750MHZ       750000000U	/* 750MHz */
+#define SC_753MHZ       753000000U	/* 753MHz */
+#define SC_793MHZ       793000000U	/* 793MHz */
+#define SC_800MHZ       800000000U	/* 800MHz */
+#define SC_850MHZ       850000000U	/* 850MHz */
+#define SC_858MHZ       858000000U	/* 858MHz */
+#define SC_900MHZ       900000000U	/* 900MHz */
+#define SC_953MHZ       953000000U	/* 953MHz */
+#define SC_963MHZ       963000000U	/* 963MHz */
+#define SC_1000MHZ     1000000000U	/* 1GHz */
+#define SC_1060MHZ     1060000000U	/* 1.06GHz */
+#define SC_1068MHZ     1068000000U	/* 1.068GHz */
+#define SC_1121MHZ     1121000000U	/* 1.121GHz */
+#define SC_1173MHZ     1173000000U	/* 1.173GHz */
+#define SC_1188MHZ     1188000000U	/* 1.188GHz */
+#define SC_1260MHZ     1260000000U	/* 1.26GHz */
+#define SC_1278MHZ     1278000000U	/* 1.278GHz */
+#define SC_1280MHZ     1280000000U	/* 1.28GHz */
+#define SC_1300MHZ     1300000000U	/* 1.3GHz */
+#define SC_1313MHZ     1313000000U	/* 1.313GHz */
+#define SC_1345MHZ     1345000000U	/* 1.345GHz */
+#define SC_1400MHZ     1400000000U	/* 1.4GHz */
+#define SC_1500MHZ     1500000000U	/* 1.5GHz */
+#define SC_1600MHZ     1600000000U	/* 1.6GHz */
+#define SC_1800MHZ     1800000000U	/* 1.8GHz */
+#define SC_2000MHZ     2000000000U	/* 2.0GHz */
+#define SC_2112MHZ     2112000000U	/* 2.12GHz */
 /*@}*/
 
 /*!
  * @name Defines for 24M related frequencies
  */
 /*@{*/
-#define SC_8MHZ           8000000	/* 8MHz */
-#define SC_12MHZ         12000000	/* 12MHz */
-#define SC_19MHZ         19800000	/* 19.8MHz */
-#define SC_24MHZ         24000000	/* 24MHz */
-#define SC_48MHZ         48000000	/* 48MHz */
-#define SC_120MHZ       120000000	/* 120MHz */
-#define SC_132MHZ       132000000	/* 132MHz */
-#define SC_144MHZ       144000000	/* 144MHz */
-#define SC_192MHZ       192000000	/* 192MHz */
-#define SC_211MHZ       211200000	/* 211.2MHz */
-#define SC_240MHZ       240000000	/* 240MHz */
-#define SC_264MHZ       264000000	/* 264MHz */
-#define SC_352MHZ       352000000	/* 352MHz */
-#define SC_360MHZ       360000000	/* 360MHz */
-#define SC_384MHZ       384000000	/* 384MHz */
-#define SC_396MHZ       396000000	/* 396MHz */
-#define SC_432MHZ       432000000	/* 432MHz */
-#define SC_480MHZ       480000000	/* 480MHz */
-#define SC_600MHZ       600000000	/* 600MHz */
-#define SC_744MHZ       744000000	/* 744MHz */
-#define SC_792MHZ       792000000	/* 792MHz */
-#define SC_864MHZ       864000000	/* 864MHz */
-#define SC_960MHZ       960000000	/* 960MHz */
-#define SC_1056MHZ     1056000000	/* 1056MHz */
-#define SC_1200MHZ     1200000000	/* 1.2GHz */
-#define SC_1464MHZ     1464000000	/* 1.464GHz */
-#define SC_2400MHZ     2400000000	/* 2.4GHz */
+#define SC_8MHZ           8000000U	/* 8MHz */
+#define SC_12MHZ         12000000U	/* 12MHz */
+#define SC_19MHZ         19800000U	/* 19.8MHz */
+#define SC_24MHZ         24000000U	/* 24MHz */
+#define SC_48MHZ         48000000U	/* 48MHz */
+#define SC_120MHZ       120000000U	/* 120MHz */
+#define SC_132MHZ       132000000U	/* 132MHz */
+#define SC_144MHZ       144000000U	/* 144MHz */
+#define SC_192MHZ       192000000U	/* 192MHz */
+#define SC_211MHZ       211200000U	/* 211.2MHz */
+#define SC_240MHZ       240000000U	/* 240MHz */
+#define SC_264MHZ       264000000U	/* 264MHz */
+#define SC_352MHZ       352000000U	/* 352MHz */
+#define SC_360MHZ       360000000U	/* 360MHz */
+#define SC_384MHZ       384000000U	/* 384MHz */
+#define SC_396MHZ       396000000U	/* 396MHz */
+#define SC_432MHZ       432000000U	/* 432MHz */
+#define SC_480MHZ       480000000U	/* 480MHz */
+#define SC_600MHZ       600000000U	/* 600MHz */
+#define SC_744MHZ       744000000U	/* 744MHz */
+#define SC_792MHZ       792000000U	/* 792MHz */
+#define SC_864MHZ       864000000U	/* 864MHz */
+#define SC_960MHZ       960000000U	/* 960MHz */
+#define SC_1056MHZ     1056000000U	/* 1056MHz */
+#define SC_1104MHZ     1104000000U	/* 1104MHz */
+#define SC_1200MHZ     1200000000U	/* 1.2GHz */
+#define SC_1464MHZ     1464000000U	/* 1.464GHz */
+#define SC_2400MHZ     2400000000U	/* 2.4GHz */
 /*@}*/
 
 /*!
  * @name Defines for A/V related frequencies
  */
 /*@{*/
-#define SC_62MHZ         62937500	/* 62.9375MHz */
-#define SC_755MHZ       755250000	/* 755.25MHz */
+#define SC_62MHZ         62937500U	/* 62.9375MHz */
+#define SC_755MHZ       755250000U	/* 755.25MHz */
 /*@}*/
 
 /*!
  * @name Defines for type widths
  */
 /*@{*/
-#define SC_FADDR_W      36	/* Width of sc_faddr_t */
-#define SC_BOOL_W       1	/* Width of bool */
-#define SC_ERR_W        4	/* Width of sc_err_t */
-#define SC_RSRC_W       10	/* Width of sc_rsrc_t */
-#define SC_CTRL_W       6	/* Width of sc_ctrl_t */
+#define SC_BOOL_W       1U	/* Width of sc_bool_t */
+#define SC_ERR_W        4U	/* Width of sc_err_t */
+#define SC_RSRC_W       10U	/* Width of sc_rsrc_t */
+#define SC_CTRL_W       6U	/* Width of sc_ctrl_t */
+/*@}*/
+
+/*!
+ * @name Defines for sc_bool_t
+ */
+/*@{*/
+#define SC_FALSE        ((sc_bool_t) 0U)	/* False */
+#define SC_TRUE         ((sc_bool_t) 1U)	/* True */
+/*@}*/
+
+/*!
+ * @name Defines for sc_err_t.
+ */
+/*@{*/
+#define SC_ERR_NONE         0U	/* Success */
+#define SC_ERR_VERSION      1U	/* Incompatible API version */
+#define SC_ERR_CONFIG       2U	/* Configuration error */
+#define SC_ERR_PARM         3U	/* Bad parameter */
+#define SC_ERR_NOACCESS     4U	/* Permission error (no access) */
+#define SC_ERR_LOCKED       5U	/* Permission error (locked) */
+#define SC_ERR_UNAVAILABLE  6U	/* Unavailable (out of resources) */
+#define SC_ERR_NOTFOUND     7U	/* Not found */
+#define SC_ERR_NOPOWER      8U	/* No power */
+#define SC_ERR_IPC          9U	/* Generic IPC error */
+#define SC_ERR_BUSY         10U	/* Resource is currently busy/active */
+#define SC_ERR_FAIL         11U	/* General I/O failure */
+#define SC_ERR_LAST         12U
+/*@}*/
+
+/*!
+ * @name Defines for sc_rsrc_t.
+ */
+/*@{*/
+#define SC_R_A53                  0U
+#define SC_R_A53_0                1U
+#define SC_R_A53_1                2U
+#define SC_R_A53_2                3U
+#define SC_R_A53_3                4U
+#define SC_R_A72                  5U
+#define SC_R_A72_0                6U
+#define SC_R_A72_1                7U
+#define SC_R_A72_2                8U
+#define SC_R_A72_3                9U
+#define SC_R_CCI                  10U
+#define SC_R_DB                   11U
+#define SC_R_DRC_0                12U
+#define SC_R_DRC_1                13U
+#define SC_R_GIC_SMMU             14U
+#define SC_R_IRQSTR_M4_0          15U
+#define SC_R_IRQSTR_M4_1          16U
+#define SC_R_SMMU                 17U
+#define SC_R_GIC                  18U
+#define SC_R_DC_0_BLIT0           19U
+#define SC_R_DC_0_BLIT1           20U
+#define SC_R_DC_0_BLIT2           21U
+#define SC_R_DC_0_BLIT_OUT        22U
+#define SC_R_DC_0_CAPTURE0        23U
+#define SC_R_DC_0_CAPTURE1        24U
+#define SC_R_DC_0_WARP            25U
+#define SC_R_DC_0_INTEGRAL0       26U
+#define SC_R_DC_0_INTEGRAL1       27U
+#define SC_R_DC_0_VIDEO0          28U
+#define SC_R_DC_0_VIDEO1          29U
+#define SC_R_DC_0_FRAC0           30U
+#define SC_R_DC_0_FRAC1           31U
+#define SC_R_DC_0                 32U
+#define SC_R_GPU_2_PID0           33U
+#define SC_R_DC_0_PLL_0           34U
+#define SC_R_DC_0_PLL_1           35U
+#define SC_R_DC_1_BLIT0           36U
+#define SC_R_DC_1_BLIT1           37U
+#define SC_R_DC_1_BLIT2           38U
+#define SC_R_DC_1_BLIT_OUT        39U
+#define SC_R_DC_1_CAPTURE0        40U
+#define SC_R_DC_1_CAPTURE1        41U
+#define SC_R_DC_1_WARP            42U
+#define SC_R_DC_1_INTEGRAL0       43U
+#define SC_R_DC_1_INTEGRAL1       44U
+#define SC_R_DC_1_VIDEO0          45U
+#define SC_R_DC_1_VIDEO1          46U
+#define SC_R_DC_1_FRAC0           47U
+#define SC_R_DC_1_FRAC1           48U
+#define SC_R_DC_1                 49U
+#define SC_R_GPU_3_PID0           50U
+#define SC_R_DC_1_PLL_0           51U
+#define SC_R_DC_1_PLL_1           52U
+#define SC_R_SPI_0                53U
+#define SC_R_SPI_1                54U
+#define SC_R_SPI_2                55U
+#define SC_R_SPI_3                56U
+#define SC_R_UART_0               57U
+#define SC_R_UART_1               58U
+#define SC_R_UART_2               59U
+#define SC_R_UART_3               60U
+#define SC_R_UART_4               61U
+#define SC_R_EMVSIM_0             62U
+#define SC_R_EMVSIM_1             63U
+#define SC_R_DMA_0_CH0            64U
+#define SC_R_DMA_0_CH1            65U
+#define SC_R_DMA_0_CH2            66U
+#define SC_R_DMA_0_CH3            67U
+#define SC_R_DMA_0_CH4            68U
+#define SC_R_DMA_0_CH5            69U
+#define SC_R_DMA_0_CH6            70U
+#define SC_R_DMA_0_CH7            71U
+#define SC_R_DMA_0_CH8            72U
+#define SC_R_DMA_0_CH9            73U
+#define SC_R_DMA_0_CH10           74U
+#define SC_R_DMA_0_CH11           75U
+#define SC_R_DMA_0_CH12           76U
+#define SC_R_DMA_0_CH13           77U
+#define SC_R_DMA_0_CH14           78U
+#define SC_R_DMA_0_CH15           79U
+#define SC_R_DMA_0_CH16           80U
+#define SC_R_DMA_0_CH17           81U
+#define SC_R_DMA_0_CH18           82U
+#define SC_R_DMA_0_CH19           83U
+#define SC_R_DMA_0_CH20           84U
+#define SC_R_DMA_0_CH21           85U
+#define SC_R_DMA_0_CH22           86U
+#define SC_R_DMA_0_CH23           87U
+#define SC_R_DMA_0_CH24           88U
+#define SC_R_DMA_0_CH25           89U
+#define SC_R_DMA_0_CH26           90U
+#define SC_R_DMA_0_CH27           91U
+#define SC_R_DMA_0_CH28           92U
+#define SC_R_DMA_0_CH29           93U
+#define SC_R_DMA_0_CH30           94U
+#define SC_R_DMA_0_CH31           95U
+#define SC_R_I2C_0                96U
+#define SC_R_I2C_1                97U
+#define SC_R_I2C_2                98U
+#define SC_R_I2C_3                99U
+#define SC_R_I2C_4                100U
+#define SC_R_ADC_0                101U
+#define SC_R_ADC_1                102U
+#define SC_R_FTM_0                103U
+#define SC_R_FTM_1                104U
+#define SC_R_CAN_0                105U
+#define SC_R_CAN_1                106U
+#define SC_R_CAN_2                107U
+#define SC_R_DMA_1_CH0            108U
+#define SC_R_DMA_1_CH1            109U
+#define SC_R_DMA_1_CH2            110U
+#define SC_R_DMA_1_CH3            111U
+#define SC_R_DMA_1_CH4            112U
+#define SC_R_DMA_1_CH5            113U
+#define SC_R_DMA_1_CH6            114U
+#define SC_R_DMA_1_CH7            115U
+#define SC_R_DMA_1_CH8            116U
+#define SC_R_DMA_1_CH9            117U
+#define SC_R_DMA_1_CH10           118U
+#define SC_R_DMA_1_CH11           119U
+#define SC_R_DMA_1_CH12           120U
+#define SC_R_DMA_1_CH13           121U
+#define SC_R_DMA_1_CH14           122U
+#define SC_R_DMA_1_CH15           123U
+#define SC_R_DMA_1_CH16           124U
+#define SC_R_DMA_1_CH17           125U
+#define SC_R_DMA_1_CH18           126U
+#define SC_R_DMA_1_CH19           127U
+#define SC_R_DMA_1_CH20           128U
+#define SC_R_DMA_1_CH21           129U
+#define SC_R_DMA_1_CH22           130U
+#define SC_R_DMA_1_CH23           131U
+#define SC_R_DMA_1_CH24           132U
+#define SC_R_DMA_1_CH25           133U
+#define SC_R_DMA_1_CH26           134U
+#define SC_R_DMA_1_CH27           135U
+#define SC_R_DMA_1_CH28           136U
+#define SC_R_DMA_1_CH29           137U
+#define SC_R_DMA_1_CH30           138U
+#define SC_R_DMA_1_CH31           139U
+#define SC_R_UNUSED1              140U
+#define SC_R_UNUSED2              141U
+#define SC_R_UNUSED3              142U
+#define SC_R_UNUSED4              143U
+#define SC_R_GPU_0_PID0           144U
+#define SC_R_GPU_0_PID1           145U
+#define SC_R_GPU_0_PID2           146U
+#define SC_R_GPU_0_PID3           147U
+#define SC_R_GPU_1_PID0           148U
+#define SC_R_GPU_1_PID1           149U
+#define SC_R_GPU_1_PID2           150U
+#define SC_R_GPU_1_PID3           151U
+#define SC_R_PCIE_A               152U
+#define SC_R_SERDES_0             153U
+#define SC_R_MATCH_0              154U
+#define SC_R_MATCH_1              155U
+#define SC_R_MATCH_2              156U
+#define SC_R_MATCH_3              157U
+#define SC_R_MATCH_4              158U
+#define SC_R_MATCH_5              159U
+#define SC_R_MATCH_6              160U
+#define SC_R_MATCH_7              161U
+#define SC_R_MATCH_8              162U
+#define SC_R_MATCH_9              163U
+#define SC_R_MATCH_10             164U
+#define SC_R_MATCH_11             165U
+#define SC_R_MATCH_12             166U
+#define SC_R_MATCH_13             167U
+#define SC_R_MATCH_14             168U
+#define SC_R_PCIE_B               169U
+#define SC_R_SATA_0               170U
+#define SC_R_SERDES_1             171U
+#define SC_R_HSIO_GPIO            172U
+#define SC_R_MATCH_15             173U
+#define SC_R_MATCH_16             174U
+#define SC_R_MATCH_17             175U
+#define SC_R_MATCH_18             176U
+#define SC_R_MATCH_19             177U
+#define SC_R_MATCH_20             178U
+#define SC_R_MATCH_21             179U
+#define SC_R_MATCH_22             180U
+#define SC_R_MATCH_23             181U
+#define SC_R_MATCH_24             182U
+#define SC_R_MATCH_25             183U
+#define SC_R_MATCH_26             184U
+#define SC_R_MATCH_27             185U
+#define SC_R_MATCH_28             186U
+#define SC_R_LCD_0                187U
+#define SC_R_LCD_0_PWM_0          188U
+#define SC_R_LCD_0_I2C_0          189U
+#define SC_R_LCD_0_I2C_1          190U
+#define SC_R_PWM_0                191U
+#define SC_R_PWM_1                192U
+#define SC_R_PWM_2                193U
+#define SC_R_PWM_3                194U
+#define SC_R_PWM_4                195U
+#define SC_R_PWM_5                196U
+#define SC_R_PWM_6                197U
+#define SC_R_PWM_7                198U
+#define SC_R_GPIO_0               199U
+#define SC_R_GPIO_1               200U
+#define SC_R_GPIO_2               201U
+#define SC_R_GPIO_3               202U
+#define SC_R_GPIO_4               203U
+#define SC_R_GPIO_5               204U
+#define SC_R_GPIO_6               205U
+#define SC_R_GPIO_7               206U
+#define SC_R_GPT_0                207U
+#define SC_R_GPT_1                208U
+#define SC_R_GPT_2                209U
+#define SC_R_GPT_3                210U
+#define SC_R_GPT_4                211U
+#define SC_R_KPP                  212U
+#define SC_R_MU_0A                213U
+#define SC_R_MU_1A                214U
+#define SC_R_MU_2A                215U
+#define SC_R_MU_3A                216U
+#define SC_R_MU_4A                217U
+#define SC_R_MU_5A                218U
+#define SC_R_MU_6A                219U
+#define SC_R_MU_7A                220U
+#define SC_R_MU_8A                221U
+#define SC_R_MU_9A                222U
+#define SC_R_MU_10A               223U
+#define SC_R_MU_11A               224U
+#define SC_R_MU_12A               225U
+#define SC_R_MU_13A               226U
+#define SC_R_MU_5B                227U
+#define SC_R_MU_6B                228U
+#define SC_R_MU_7B                229U
+#define SC_R_MU_8B                230U
+#define SC_R_MU_9B                231U
+#define SC_R_MU_10B               232U
+#define SC_R_MU_11B               233U
+#define SC_R_MU_12B               234U
+#define SC_R_MU_13B               235U
+#define SC_R_ROM_0                236U
+#define SC_R_FSPI_0               237U
+#define SC_R_FSPI_1               238U
+#define SC_R_IEE                  239U
+#define SC_R_IEE_R0               240U
+#define SC_R_IEE_R1               241U
+#define SC_R_IEE_R2               242U
+#define SC_R_IEE_R3               243U
+#define SC_R_IEE_R4               244U
+#define SC_R_IEE_R5               245U
+#define SC_R_IEE_R6               246U
+#define SC_R_IEE_R7               247U
+#define SC_R_SDHC_0               248U
+#define SC_R_SDHC_1               249U
+#define SC_R_SDHC_2               250U
+#define SC_R_ENET_0               251U
+#define SC_R_ENET_1               252U
+#define SC_R_MLB_0                253U
+#define SC_R_DMA_2_CH0            254U
+#define SC_R_DMA_2_CH1            255U
+#define SC_R_DMA_2_CH2            256U
+#define SC_R_DMA_2_CH3            257U
+#define SC_R_DMA_2_CH4            258U
+#define SC_R_USB_0                259U
+#define SC_R_USB_1                260U
+#define SC_R_USB_0_PHY            261U
+#define SC_R_USB_2                262U
+#define SC_R_USB_2_PHY            263U
+#define SC_R_DTCP                 264U
+#define SC_R_NAND                 265U
+#define SC_R_LVDS_0               266U
+#define SC_R_LVDS_0_PWM_0         267U
+#define SC_R_LVDS_0_I2C_0         268U
+#define SC_R_LVDS_0_I2C_1         269U
+#define SC_R_LVDS_1               270U
+#define SC_R_LVDS_1_PWM_0         271U
+#define SC_R_LVDS_1_I2C_0         272U
+#define SC_R_LVDS_1_I2C_1         273U
+#define SC_R_LVDS_2               274U
+#define SC_R_LVDS_2_PWM_0         275U
+#define SC_R_LVDS_2_I2C_0         276U
+#define SC_R_LVDS_2_I2C_1         277U
+#define SC_R_M4_0_PID0            278U
+#define SC_R_M4_0_PID1            279U
+#define SC_R_M4_0_PID2            280U
+#define SC_R_M4_0_PID3            281U
+#define SC_R_M4_0_PID4            282U
+#define SC_R_M4_0_RGPIO           283U
+#define SC_R_M4_0_SEMA42          284U
+#define SC_R_M4_0_TPM             285U
+#define SC_R_M4_0_PIT             286U
+#define SC_R_M4_0_UART            287U
+#define SC_R_M4_0_I2C             288U
+#define SC_R_M4_0_INTMUX          289U
+#define SC_R_M4_0_SIM             290U
+#define SC_R_M4_0_WDOG            291U
+#define SC_R_M4_0_MU_0B           292U
+#define SC_R_M4_0_MU_0A0          293U
+#define SC_R_M4_0_MU_0A1          294U
+#define SC_R_M4_0_MU_0A2          295U
+#define SC_R_M4_0_MU_0A3          296U
+#define SC_R_M4_0_MU_1A           297U
+#define SC_R_M4_1_PID0            298U
+#define SC_R_M4_1_PID1            299U
+#define SC_R_M4_1_PID2            300U
+#define SC_R_M4_1_PID3            301U
+#define SC_R_M4_1_PID4            302U
+#define SC_R_M4_1_RGPIO           303U
+#define SC_R_M4_1_SEMA42          304U
+#define SC_R_M4_1_TPM             305U
+#define SC_R_M4_1_PIT             306U
+#define SC_R_M4_1_UART            307U
+#define SC_R_M4_1_I2C             308U
+#define SC_R_M4_1_INTMUX          309U
+#define SC_R_M4_1_SIM             310U
+#define SC_R_M4_1_WDOG            311U
+#define SC_R_M4_1_MU_0B           312U
+#define SC_R_M4_1_MU_0A0          313U
+#define SC_R_M4_1_MU_0A1          314U
+#define SC_R_M4_1_MU_0A2          315U
+#define SC_R_M4_1_MU_0A3          316U
+#define SC_R_M4_1_MU_1A           317U
+#define SC_R_SAI_0                318U
+#define SC_R_SAI_1                319U
+#define SC_R_SAI_2                320U
+#define SC_R_IRQSTR_SCU2          321U
+#define SC_R_IRQSTR_DSP           322U
+#define SC_R_ELCDIF_PLL           323U
+#define SC_R_OCRAM                324U
+#define SC_R_AUDIO_PLL_0          325U
+#define SC_R_PI_0                 326U
+#define SC_R_PI_0_PWM_0           327U
+#define SC_R_PI_0_PWM_1           328U
+#define SC_R_PI_0_I2C_0           329U
+#define SC_R_PI_0_PLL             330U
+#define SC_R_PI_1                 331U
+#define SC_R_PI_1_PWM_0           332U
+#define SC_R_PI_1_PWM_1           333U
+#define SC_R_PI_1_I2C_0           334U
+#define SC_R_PI_1_PLL             335U
+#define SC_R_SC_PID0              336U
+#define SC_R_SC_PID1              337U
+#define SC_R_SC_PID2              338U
+#define SC_R_SC_PID3              339U
+#define SC_R_SC_PID4              340U
+#define SC_R_SC_SEMA42            341U
+#define SC_R_SC_TPM               342U
+#define SC_R_SC_PIT               343U
+#define SC_R_SC_UART              344U
+#define SC_R_SC_I2C               345U
+#define SC_R_SC_MU_0B             346U
+#define SC_R_SC_MU_0A0            347U
+#define SC_R_SC_MU_0A1            348U
+#define SC_R_SC_MU_0A2            349U
+#define SC_R_SC_MU_0A3            350U
+#define SC_R_SC_MU_1A             351U
+#define SC_R_SYSCNT_RD            352U
+#define SC_R_SYSCNT_CMP           353U
+#define SC_R_DEBUG                354U
+#define SC_R_SYSTEM               355U
+#define SC_R_SNVS                 356U
+#define SC_R_OTP                  357U
+#define SC_R_VPU_PID0             358U
+#define SC_R_VPU_PID1             359U
+#define SC_R_VPU_PID2             360U
+#define SC_R_VPU_PID3             361U
+#define SC_R_VPU_PID4             362U
+#define SC_R_VPU_PID5             363U
+#define SC_R_VPU_PID6             364U
+#define SC_R_VPU_PID7             365U
+#define SC_R_VPU_UART             366U
+#define SC_R_VPUCORE              367U
+#define SC_R_VPUCORE_0            368U
+#define SC_R_VPUCORE_1            369U
+#define SC_R_VPUCORE_2            370U
+#define SC_R_VPUCORE_3            371U
+#define SC_R_DMA_4_CH0            372U
+#define SC_R_DMA_4_CH1            373U
+#define SC_R_DMA_4_CH2            374U
+#define SC_R_DMA_4_CH3            375U
+#define SC_R_DMA_4_CH4            376U
+#define SC_R_ISI_CH0              377U
+#define SC_R_ISI_CH1              378U
+#define SC_R_ISI_CH2              379U
+#define SC_R_ISI_CH3              380U
+#define SC_R_ISI_CH4              381U
+#define SC_R_ISI_CH5              382U
+#define SC_R_ISI_CH6              383U
+#define SC_R_ISI_CH7              384U
+#define SC_R_MJPEG_DEC_S0         385U
+#define SC_R_MJPEG_DEC_S1         386U
+#define SC_R_MJPEG_DEC_S2         387U
+#define SC_R_MJPEG_DEC_S3         388U
+#define SC_R_MJPEG_ENC_S0         389U
+#define SC_R_MJPEG_ENC_S1         390U
+#define SC_R_MJPEG_ENC_S2         391U
+#define SC_R_MJPEG_ENC_S3         392U
+#define SC_R_MIPI_0               393U
+#define SC_R_MIPI_0_PWM_0         394U
+#define SC_R_MIPI_0_I2C_0         395U
+#define SC_R_MIPI_0_I2C_1         396U
+#define SC_R_MIPI_1               397U
+#define SC_R_MIPI_1_PWM_0         398U
+#define SC_R_MIPI_1_I2C_0         399U
+#define SC_R_MIPI_1_I2C_1         400U
+#define SC_R_CSI_0                401U
+#define SC_R_CSI_0_PWM_0          402U
+#define SC_R_CSI_0_I2C_0          403U
+#define SC_R_CSI_1                404U
+#define SC_R_CSI_1_PWM_0          405U
+#define SC_R_CSI_1_I2C_0          406U
+#define SC_R_HDMI                 407U
+#define SC_R_HDMI_I2S             408U
+#define SC_R_HDMI_I2C_0           409U
+#define SC_R_HDMI_PLL_0           410U
+#define SC_R_HDMI_RX              411U
+#define SC_R_HDMI_RX_BYPASS       412U
+#define SC_R_HDMI_RX_I2C_0        413U
+#define SC_R_ASRC_0               414U
+#define SC_R_ESAI_0               415U
+#define SC_R_SPDIF_0              416U
+#define SC_R_SPDIF_1              417U
+#define SC_R_SAI_3                418U
+#define SC_R_SAI_4                419U
+#define SC_R_SAI_5                420U
+#define SC_R_GPT_5                421U
+#define SC_R_GPT_6                422U
+#define SC_R_GPT_7                423U
+#define SC_R_GPT_8                424U
+#define SC_R_GPT_9                425U
+#define SC_R_GPT_10               426U
+#define SC_R_DMA_2_CH5            427U
+#define SC_R_DMA_2_CH6            428U
+#define SC_R_DMA_2_CH7            429U
+#define SC_R_DMA_2_CH8            430U
+#define SC_R_DMA_2_CH9            431U
+#define SC_R_DMA_2_CH10           432U
+#define SC_R_DMA_2_CH11           433U
+#define SC_R_DMA_2_CH12           434U
+#define SC_R_DMA_2_CH13           435U
+#define SC_R_DMA_2_CH14           436U
+#define SC_R_DMA_2_CH15           437U
+#define SC_R_DMA_2_CH16           438U
+#define SC_R_DMA_2_CH17           439U
+#define SC_R_DMA_2_CH18           440U
+#define SC_R_DMA_2_CH19           441U
+#define SC_R_DMA_2_CH20           442U
+#define SC_R_DMA_2_CH21           443U
+#define SC_R_DMA_2_CH22           444U
+#define SC_R_DMA_2_CH23           445U
+#define SC_R_DMA_2_CH24           446U
+#define SC_R_DMA_2_CH25           447U
+#define SC_R_DMA_2_CH26           448U
+#define SC_R_DMA_2_CH27           449U
+#define SC_R_DMA_2_CH28           450U
+#define SC_R_DMA_2_CH29           451U
+#define SC_R_DMA_2_CH30           452U
+#define SC_R_DMA_2_CH31           453U
+#define SC_R_ASRC_1               454U
+#define SC_R_ESAI_1               455U
+#define SC_R_SAI_6                456U
+#define SC_R_SAI_7                457U
+#define SC_R_AMIX                 458U
+#define SC_R_MQS_0                459U
+#define SC_R_DMA_3_CH0            460U
+#define SC_R_DMA_3_CH1            461U
+#define SC_R_DMA_3_CH2            462U
+#define SC_R_DMA_3_CH3            463U
+#define SC_R_DMA_3_CH4            464U
+#define SC_R_DMA_3_CH5            465U
+#define SC_R_DMA_3_CH6            466U
+#define SC_R_DMA_3_CH7            467U
+#define SC_R_DMA_3_CH8            468U
+#define SC_R_DMA_3_CH9            469U
+#define SC_R_DMA_3_CH10           470U
+#define SC_R_DMA_3_CH11           471U
+#define SC_R_DMA_3_CH12           472U
+#define SC_R_DMA_3_CH13           473U
+#define SC_R_DMA_3_CH14           474U
+#define SC_R_DMA_3_CH15           475U
+#define SC_R_DMA_3_CH16           476U
+#define SC_R_DMA_3_CH17           477U
+#define SC_R_DMA_3_CH18           478U
+#define SC_R_DMA_3_CH19           479U
+#define SC_R_DMA_3_CH20           480U
+#define SC_R_DMA_3_CH21           481U
+#define SC_R_DMA_3_CH22           482U
+#define SC_R_DMA_3_CH23           483U
+#define SC_R_DMA_3_CH24           484U
+#define SC_R_DMA_3_CH25           485U
+#define SC_R_DMA_3_CH26           486U
+#define SC_R_DMA_3_CH27           487U
+#define SC_R_DMA_3_CH28           488U
+#define SC_R_DMA_3_CH29           489U
+#define SC_R_DMA_3_CH30           490U
+#define SC_R_DMA_3_CH31           491U
+#define SC_R_AUDIO_PLL_1          492U
+#define SC_R_AUDIO_CLK_0          493U
+#define SC_R_AUDIO_CLK_1          494U
+#define SC_R_MCLK_OUT_0           495U
+#define SC_R_MCLK_OUT_1           496U
+#define SC_R_PMIC_0               497U
+#define SC_R_PMIC_1               498U
+#define SC_R_SECO                 499U
+#define SC_R_CAAM_JR1             500U
+#define SC_R_CAAM_JR2             501U
+#define SC_R_CAAM_JR3             502U
+#define SC_R_SECO_MU_2            503U
+#define SC_R_SECO_MU_3            504U
+#define SC_R_SECO_MU_4            505U
+#define SC_R_HDMI_RX_PWM_0        506U
+#define SC_R_A35                  507U
+#define SC_R_A35_0                508U
+#define SC_R_A35_1                509U
+#define SC_R_A35_2                510U
+#define SC_R_A35_3                511U
+#define SC_R_DSP                  512U
+#define SC_R_DSP_RAM              513U
+#define SC_R_CAAM_JR1_OUT         514U
+#define SC_R_CAAM_JR2_OUT         515U
+#define SC_R_CAAM_JR3_OUT         516U
+#define SC_R_VPU_DEC_0            517U
+#define SC_R_VPU_ENC_0            518U
+#define SC_R_CAAM_JR0             519U
+#define SC_R_CAAM_JR0_OUT         520U
+#define SC_R_PMIC_2               521U
+#define SC_R_DBLOGIC              522U
+#define SC_R_HDMI_PLL_1           523U
+#define SC_R_BOARD_R0             524U
+#define SC_R_BOARD_R1             525U
+#define SC_R_BOARD_R2             526U
+#define SC_R_BOARD_R3             527U
+#define SC_R_BOARD_R4             528U
+#define SC_R_BOARD_R5             529U
+#define SC_R_BOARD_R6             530U
+#define SC_R_BOARD_R7             531U
+#define SC_R_MJPEG_DEC_MP         532U
+#define SC_R_MJPEG_ENC_MP         533U
+#define SC_R_VPU_TS_0             534U
+#define SC_R_VPU_MU_0             535U
+#define SC_R_VPU_MU_1             536U
+#define SC_R_VPU_MU_2             537U
+#define SC_R_VPU_MU_3             538U
+#define SC_R_VPU_ENC_1            539U
+#define SC_R_VPU                  540U
+#define SC_R_DMA_5_CH0            541U
+#define SC_R_DMA_5_CH1            542U
+#define SC_R_DMA_5_CH2            543U
+#define SC_R_DMA_5_CH3            544U
+#define SC_R_ATTESTATION          545U
+#define SC_R_PERF                 546U
+#define SC_R_LAST                 547U
+#define SC_R_ALL                  ((sc_rsrc_t) UINT16_MAX)	/* All resources */
 /*@}*/
 
-#define SC_R_ALL        UINT16_MAX	/* All resources */
-#define SC_P_ALL        UINT16_MAX	/* All pads */
+/* NOTE - please add by replacing some of the UNUSED from above! */
+
+/*!
+ * Defnes for sc_ctrl_t.
+ */
+#define SC_C_TEMP                       0U
+#define SC_C_TEMP_HI                    1U
+#define SC_C_TEMP_LOW                   2U
+#define SC_C_PXL_LINK_MST1_ADDR         3U
+#define SC_C_PXL_LINK_MST2_ADDR         4U
+#define SC_C_PXL_LINK_MST_ENB           5U
+#define SC_C_PXL_LINK_MST1_ENB          6U
+#define SC_C_PXL_LINK_MST2_ENB          7U
+#define SC_C_PXL_LINK_SLV1_ADDR         8U
+#define SC_C_PXL_LINK_SLV2_ADDR         9U
+#define SC_C_PXL_LINK_MST_VLD           10U
+#define SC_C_PXL_LINK_MST1_VLD          11U
+#define SC_C_PXL_LINK_MST2_VLD          12U
+#define SC_C_SINGLE_MODE                13U
+#define SC_C_ID                         14U
+#define SC_C_PXL_CLK_POLARITY           15U
+#define SC_C_LINESTATE                  16U
+#define SC_C_PCIE_G_RST                 17U
+#define SC_C_PCIE_BUTTON_RST            18U
+#define SC_C_PCIE_PERST                 19U
+#define SC_C_PHY_RESET                  20U
+#define SC_C_PXL_LINK_RATE_CORRECTION   21U
+#define SC_C_PANIC                      22U
+#define SC_C_PRIORITY_GROUP             23U
+#define SC_C_TXCLK                      24U
+#define SC_C_CLKDIV                     25U
+#define SC_C_DISABLE_50                 26U
+#define SC_C_DISABLE_125                27U
+#define SC_C_SEL_125                    28U
+#define SC_C_MODE                       29U
+#define SC_C_SYNC_CTRL0                 30U
+#define SC_C_KACHUNK_CNT                31U
+#define SC_C_KACHUNK_SEL                32U
+#define SC_C_SYNC_CTRL1                 33U
+#define SC_C_DPI_RESET                  34U
+#define SC_C_MIPI_RESET                 35U
+#define SC_C_DUAL_MODE                  36U
+#define SC_C_VOLTAGE                    37U
+#define SC_C_PXL_LINK_SEL               38U
+#define SC_C_OFS_SEL                    39U
+#define SC_C_OFS_AUDIO                  40U
+#define SC_C_OFS_PERIPH                 41U
+#define SC_C_OFS_IRQ                    42U
+#define SC_C_RST0                       43U
+#define SC_C_RST1                       44U
+#define SC_C_SEL0                       45U
+#define SC_C_CALIB0                     46U
+#define SC_C_CALIB1                     47U
+#define SC_C_CALIB2                     48U
+#define SC_C_IPG_DEBUG                  49U
+#define SC_C_IPG_DOZE                   50U
+#define SC_C_IPG_WAIT                   51U
+#define SC_C_IPG_STOP                   52U
+#define SC_C_IPG_STOP_MODE              53U
+#define SC_C_IPG_STOP_ACK               54U
+#define SC_C_SYNC_CTRL                  55U
+#define SC_C_LAST                       56U
+
+#define SC_P_ALL        ((sc_pad_t) UINT16_MAX)	/* All pads */
+
+/* Types */
+
+/*!
+ * This type is used to store a boolean
+ */
+typedef uint8_t sc_bool_t;
 
 /*!
  * This type is used to store a system (full-size) address.
@@ -144,637 +810,19 @@
 /*!
  * This type is used to indicate error response for most functions.
  */
-typedef enum sc_err_e {
-	SC_ERR_NONE = 0,	/* Success */
-	SC_ERR_VERSION = 1,	/* Incompatible API version */
-	SC_ERR_CONFIG = 2,	/* Configuration error */
-	SC_ERR_PARM = 3,	/* Bad parameter */
-	SC_ERR_NOACCESS = 4,	/* Permission error (no access) */
-	SC_ERR_LOCKED = 5,	/* Permission error (locked) */
-	SC_ERR_UNAVAILABLE = 6,	/* Unavailable (out of resources) */
-	SC_ERR_NOTFOUND = 7,	/* Not found */
-	SC_ERR_NOPOWER = 8,	/* No power */
-	SC_ERR_IPC = 9,		/* Generic IPC error */
-	SC_ERR_BUSY = 10,	/* Resource is currently busy/active */
-	SC_ERR_FAIL = 11,	/* General I/O failure */
-	SC_ERR_LAST
-} sc_err_t;
+typedef uint8_t sc_err_t;
 
 /*!
  * This type is used to indicate a resource. Resources include peripherals
  * and bus masters (but not memory regions). Note items from list should
  * never be changed or removed (only added to at the end of the list).
  */
-typedef enum sc_rsrc_e {
-	SC_R_A53 = 0,
-	SC_R_A53_0 = 1,
-	SC_R_A53_1 = 2,
-	SC_R_A53_2 = 3,
-	SC_R_A53_3 = 4,
-	SC_R_A72 = 5,
-	SC_R_A72_0 = 6,
-	SC_R_A72_1 = 7,
-	SC_R_A72_2 = 8,
-	SC_R_A72_3 = 9,
-	SC_R_CCI = 10,
-	SC_R_DB = 11,
-	SC_R_DRC_0 = 12,
-	SC_R_DRC_1 = 13,
-	SC_R_GIC_SMMU = 14,
-	SC_R_IRQSTR_M4_0 = 15,
-	SC_R_IRQSTR_M4_1 = 16,
-	SC_R_SMMU = 17,
-	SC_R_GIC = 18,
-	SC_R_DC_0_BLIT0 = 19,
-	SC_R_DC_0_BLIT1 = 20,
-	SC_R_DC_0_BLIT2 = 21,
-	SC_R_DC_0_BLIT_OUT = 22,
-	SC_R_DC_0_CAPTURE0 = 23,
-	SC_R_DC_0_CAPTURE1 = 24,
-	SC_R_DC_0_WARP = 25,
-	SC_R_DC_0_INTEGRAL0 = 26,
-	SC_R_DC_0_INTEGRAL1 = 27,
-	SC_R_DC_0_VIDEO0 = 28,
-	SC_R_DC_0_VIDEO1 = 29,
-	SC_R_DC_0_FRAC0 = 30,
-	SC_R_DC_0_FRAC1 = 31,
-	SC_R_DC_0 = 32,
-	SC_R_GPU_2_PID0 = 33,
-	SC_R_DC_0_PLL_0 = 34,
-	SC_R_DC_0_PLL_1 = 35,
-	SC_R_DC_1_BLIT0 = 36,
-	SC_R_DC_1_BLIT1 = 37,
-	SC_R_DC_1_BLIT2 = 38,
-	SC_R_DC_1_BLIT_OUT = 39,
-	SC_R_DC_1_CAPTURE0 = 40,
-	SC_R_DC_1_CAPTURE1 = 41,
-	SC_R_DC_1_WARP = 42,
-	SC_R_DC_1_INTEGRAL0 = 43,
-	SC_R_DC_1_INTEGRAL1 = 44,
-	SC_R_DC_1_VIDEO0 = 45,
-	SC_R_DC_1_VIDEO1 = 46,
-	SC_R_DC_1_FRAC0 = 47,
-	SC_R_DC_1_FRAC1 = 48,
-	SC_R_DC_1 = 49,
-	SC_R_GPU_3_PID0 = 50,
-	SC_R_DC_1_PLL_0 = 51,
-	SC_R_DC_1_PLL_1 = 52,
-	SC_R_SPI_0 = 53,
-	SC_R_SPI_1 = 54,
-	SC_R_SPI_2 = 55,
-	SC_R_SPI_3 = 56,
-	SC_R_UART_0 = 57,
-	SC_R_UART_1 = 58,
-	SC_R_UART_2 = 59,
-	SC_R_UART_3 = 60,
-	SC_R_UART_4 = 61,
-	SC_R_EMVSIM_0 = 62,
-	SC_R_EMVSIM_1 = 63,
-	SC_R_DMA_0_CH0 = 64,
-	SC_R_DMA_0_CH1 = 65,
-	SC_R_DMA_0_CH2 = 66,
-	SC_R_DMA_0_CH3 = 67,
-	SC_R_DMA_0_CH4 = 68,
-	SC_R_DMA_0_CH5 = 69,
-	SC_R_DMA_0_CH6 = 70,
-	SC_R_DMA_0_CH7 = 71,
-	SC_R_DMA_0_CH8 = 72,
-	SC_R_DMA_0_CH9 = 73,
-	SC_R_DMA_0_CH10 = 74,
-	SC_R_DMA_0_CH11 = 75,
-	SC_R_DMA_0_CH12 = 76,
-	SC_R_DMA_0_CH13 = 77,
-	SC_R_DMA_0_CH14 = 78,
-	SC_R_DMA_0_CH15 = 79,
-	SC_R_DMA_0_CH16 = 80,
-	SC_R_DMA_0_CH17 = 81,
-	SC_R_DMA_0_CH18 = 82,
-	SC_R_DMA_0_CH19 = 83,
-	SC_R_DMA_0_CH20 = 84,
-	SC_R_DMA_0_CH21 = 85,
-	SC_R_DMA_0_CH22 = 86,
-	SC_R_DMA_0_CH23 = 87,
-	SC_R_DMA_0_CH24 = 88,
-	SC_R_DMA_0_CH25 = 89,
-	SC_R_DMA_0_CH26 = 90,
-	SC_R_DMA_0_CH27 = 91,
-	SC_R_DMA_0_CH28 = 92,
-	SC_R_DMA_0_CH29 = 93,
-	SC_R_DMA_0_CH30 = 94,
-	SC_R_DMA_0_CH31 = 95,
-	SC_R_I2C_0 = 96,
-	SC_R_I2C_1 = 97,
-	SC_R_I2C_2 = 98,
-	SC_R_I2C_3 = 99,
-	SC_R_I2C_4 = 100,
-	SC_R_ADC_0 = 101,
-	SC_R_ADC_1 = 102,
-	SC_R_FTM_0 = 103,
-	SC_R_FTM_1 = 104,
-	SC_R_CAN_0 = 105,
-	SC_R_CAN_1 = 106,
-	SC_R_CAN_2 = 107,
-	SC_R_DMA_1_CH0 = 108,
-	SC_R_DMA_1_CH1 = 109,
-	SC_R_DMA_1_CH2 = 110,
-	SC_R_DMA_1_CH3 = 111,
-	SC_R_DMA_1_CH4 = 112,
-	SC_R_DMA_1_CH5 = 113,
-	SC_R_DMA_1_CH6 = 114,
-	SC_R_DMA_1_CH7 = 115,
-	SC_R_DMA_1_CH8 = 116,
-	SC_R_DMA_1_CH9 = 117,
-	SC_R_DMA_1_CH10 = 118,
-	SC_R_DMA_1_CH11 = 119,
-	SC_R_DMA_1_CH12 = 120,
-	SC_R_DMA_1_CH13 = 121,
-	SC_R_DMA_1_CH14 = 122,
-	SC_R_DMA_1_CH15 = 123,
-	SC_R_DMA_1_CH16 = 124,
-	SC_R_DMA_1_CH17 = 125,
-	SC_R_DMA_1_CH18 = 126,
-	SC_R_DMA_1_CH19 = 127,
-	SC_R_DMA_1_CH20 = 128,
-	SC_R_DMA_1_CH21 = 129,
-	SC_R_DMA_1_CH22 = 130,
-	SC_R_DMA_1_CH23 = 131,
-	SC_R_DMA_1_CH24 = 132,
-	SC_R_DMA_1_CH25 = 133,
-	SC_R_DMA_1_CH26 = 134,
-	SC_R_DMA_1_CH27 = 135,
-	SC_R_DMA_1_CH28 = 136,
-	SC_R_DMA_1_CH29 = 137,
-	SC_R_DMA_1_CH30 = 138,
-	SC_R_DMA_1_CH31 = 139,
-	SC_R_UNUSED1 = 140,
-	SC_R_UNUSED2 = 141,
-	SC_R_UNUSED3 = 142,
-	SC_R_UNUSED4 = 143,
-	SC_R_GPU_0_PID0 = 144,
-	SC_R_GPU_0_PID1 = 145,
-	SC_R_GPU_0_PID2 = 146,
-	SC_R_GPU_0_PID3 = 147,
-	SC_R_GPU_1_PID0 = 148,
-	SC_R_GPU_1_PID1 = 149,
-	SC_R_GPU_1_PID2 = 150,
-	SC_R_GPU_1_PID3 = 151,
-	SC_R_PCIE_A = 152,
-	SC_R_SERDES_0 = 153,
-	SC_R_MATCH_0 = 154,
-	SC_R_MATCH_1 = 155,
-	SC_R_MATCH_2 = 156,
-	SC_R_MATCH_3 = 157,
-	SC_R_MATCH_4 = 158,
-	SC_R_MATCH_5 = 159,
-	SC_R_MATCH_6 = 160,
-	SC_R_MATCH_7 = 161,
-	SC_R_MATCH_8 = 162,
-	SC_R_MATCH_9 = 163,
-	SC_R_MATCH_10 = 164,
-	SC_R_MATCH_11 = 165,
-	SC_R_MATCH_12 = 166,
-	SC_R_MATCH_13 = 167,
-	SC_R_MATCH_14 = 168,
-	SC_R_PCIE_B = 169,
-	SC_R_SATA_0 = 170,
-	SC_R_SERDES_1 = 171,
-	SC_R_HSIO_GPIO = 172,
-	SC_R_MATCH_15 = 173,
-	SC_R_MATCH_16 = 174,
-	SC_R_MATCH_17 = 175,
-	SC_R_MATCH_18 = 176,
-	SC_R_MATCH_19 = 177,
-	SC_R_MATCH_20 = 178,
-	SC_R_MATCH_21 = 179,
-	SC_R_MATCH_22 = 180,
-	SC_R_MATCH_23 = 181,
-	SC_R_MATCH_24 = 182,
-	SC_R_MATCH_25 = 183,
-	SC_R_MATCH_26 = 184,
-	SC_R_MATCH_27 = 185,
-	SC_R_MATCH_28 = 186,
-	SC_R_LCD_0 = 187,
-	SC_R_LCD_0_PWM_0 = 188,
-	SC_R_LCD_0_I2C_0 = 189,
-	SC_R_LCD_0_I2C_1 = 190,
-	SC_R_PWM_0 = 191,
-	SC_R_PWM_1 = 192,
-	SC_R_PWM_2 = 193,
-	SC_R_PWM_3 = 194,
-	SC_R_PWM_4 = 195,
-	SC_R_PWM_5 = 196,
-	SC_R_PWM_6 = 197,
-	SC_R_PWM_7 = 198,
-	SC_R_GPIO_0 = 199,
-	SC_R_GPIO_1 = 200,
-	SC_R_GPIO_2 = 201,
-	SC_R_GPIO_3 = 202,
-	SC_R_GPIO_4 = 203,
-	SC_R_GPIO_5 = 204,
-	SC_R_GPIO_6 = 205,
-	SC_R_GPIO_7 = 206,
-	SC_R_GPT_0 = 207,
-	SC_R_GPT_1 = 208,
-	SC_R_GPT_2 = 209,
-	SC_R_GPT_3 = 210,
-	SC_R_GPT_4 = 211,
-	SC_R_KPP = 212,
-	SC_R_MU_0A = 213,
-	SC_R_MU_1A = 214,
-	SC_R_MU_2A = 215,
-	SC_R_MU_3A = 216,
-	SC_R_MU_4A = 217,
-	SC_R_MU_5A = 218,
-	SC_R_MU_6A = 219,
-	SC_R_MU_7A = 220,
-	SC_R_MU_8A = 221,
-	SC_R_MU_9A = 222,
-	SC_R_MU_10A = 223,
-	SC_R_MU_11A = 224,
-	SC_R_MU_12A = 225,
-	SC_R_MU_13A = 226,
-	SC_R_MU_5B = 227,
-	SC_R_MU_6B = 228,
-	SC_R_MU_7B = 229,
-	SC_R_MU_8B = 230,
-	SC_R_MU_9B = 231,
-	SC_R_MU_10B = 232,
-	SC_R_MU_11B = 233,
-	SC_R_MU_12B = 234,
-	SC_R_MU_13B = 235,
-	SC_R_ROM_0 = 236,
-	SC_R_FSPI_0 = 237,
-	SC_R_FSPI_1 = 238,
-	SC_R_IEE = 239,
-	SC_R_IEE_R0 = 240,
-	SC_R_IEE_R1 = 241,
-	SC_R_IEE_R2 = 242,
-	SC_R_IEE_R3 = 243,
-	SC_R_IEE_R4 = 244,
-	SC_R_IEE_R5 = 245,
-	SC_R_IEE_R6 = 246,
-	SC_R_IEE_R7 = 247,
-	SC_R_SDHC_0 = 248,
-	SC_R_SDHC_1 = 249,
-	SC_R_SDHC_2 = 250,
-	SC_R_ENET_0 = 251,
-	SC_R_ENET_1 = 252,
-	SC_R_MLB_0 = 253,
-	SC_R_DMA_2_CH0 = 254,
-	SC_R_DMA_2_CH1 = 255,
-	SC_R_DMA_2_CH2 = 256,
-	SC_R_DMA_2_CH3 = 257,
-	SC_R_DMA_2_CH4 = 258,
-	SC_R_USB_0 = 259,
-	SC_R_USB_1 = 260,
-	SC_R_USB_0_PHY = 261,
-	SC_R_USB_2 = 262,
-	SC_R_USB_2_PHY = 263,
-	SC_R_DTCP = 264,
-	SC_R_NAND = 265,
-	SC_R_LVDS_0 = 266,
-	SC_R_LVDS_0_PWM_0 = 267,
-	SC_R_LVDS_0_I2C_0 = 268,
-	SC_R_LVDS_0_I2C_1 = 269,
-	SC_R_LVDS_1 = 270,
-	SC_R_LVDS_1_PWM_0 = 271,
-	SC_R_LVDS_1_I2C_0 = 272,
-	SC_R_LVDS_1_I2C_1 = 273,
-	SC_R_LVDS_2 = 274,
-	SC_R_LVDS_2_PWM_0 = 275,
-	SC_R_LVDS_2_I2C_0 = 276,
-	SC_R_LVDS_2_I2C_1 = 277,
-	SC_R_M4_0_PID0 = 278,
-	SC_R_M4_0_PID1 = 279,
-	SC_R_M4_0_PID2 = 280,
-	SC_R_M4_0_PID3 = 281,
-	SC_R_M4_0_PID4 = 282,
-	SC_R_M4_0_RGPIO = 283,
-	SC_R_M4_0_SEMA42 = 284,
-	SC_R_M4_0_TPM = 285,
-	SC_R_M4_0_PIT = 286,
-	SC_R_M4_0_UART = 287,
-	SC_R_M4_0_I2C = 288,
-	SC_R_M4_0_INTMUX = 289,
-	SC_R_M4_0_SIM = 290,
-	SC_R_M4_0_WDOG = 291,
-	SC_R_M4_0_MU_0B = 292,
-	SC_R_M4_0_MU_0A0 = 293,
-	SC_R_M4_0_MU_0A1 = 294,
-	SC_R_M4_0_MU_0A2 = 295,
-	SC_R_M4_0_MU_0A3 = 296,
-	SC_R_M4_0_MU_1A = 297,
-	SC_R_M4_1_PID0 = 298,
-	SC_R_M4_1_PID1 = 299,
-	SC_R_M4_1_PID2 = 300,
-	SC_R_M4_1_PID3 = 301,
-	SC_R_M4_1_PID4 = 302,
-	SC_R_M4_1_RGPIO = 303,
-	SC_R_M4_1_SEMA42 = 304,
-	SC_R_M4_1_TPM = 305,
-	SC_R_M4_1_PIT = 306,
-	SC_R_M4_1_UART = 307,
-	SC_R_M4_1_I2C = 308,
-	SC_R_M4_1_INTMUX = 309,
-	SC_R_M4_1_SIM = 310,
-	SC_R_M4_1_WDOG = 311,
-	SC_R_M4_1_MU_0B = 312,
-	SC_R_M4_1_MU_0A0 = 313,
-	SC_R_M4_1_MU_0A1 = 314,
-	SC_R_M4_1_MU_0A2 = 315,
-	SC_R_M4_1_MU_0A3 = 316,
-	SC_R_M4_1_MU_1A = 317,
-	SC_R_SAI_0 = 318,
-	SC_R_SAI_1 = 319,
-	SC_R_SAI_2 = 320,
-	SC_R_IRQSTR_SCU2 = 321,
-	SC_R_IRQSTR_DSP = 322,
-	SC_R_ELCDIF_PLL = 323,
-	SC_R_UNUSED6 = 324,
-	SC_R_AUDIO_PLL_0 = 325,
-	SC_R_PI_0 = 326,
-	SC_R_PI_0_PWM_0 = 327,
-	SC_R_PI_0_PWM_1 = 328,
-	SC_R_PI_0_I2C_0 = 329,
-	SC_R_PI_0_PLL = 330,
-	SC_R_PI_1 = 331,
-	SC_R_PI_1_PWM_0 = 332,
-	SC_R_PI_1_PWM_1 = 333,
-	SC_R_PI_1_I2C_0 = 334,
-	SC_R_PI_1_PLL = 335,
-	SC_R_SC_PID0 = 336,
-	SC_R_SC_PID1 = 337,
-	SC_R_SC_PID2 = 338,
-	SC_R_SC_PID3 = 339,
-	SC_R_SC_PID4 = 340,
-	SC_R_SC_SEMA42 = 341,
-	SC_R_SC_TPM = 342,
-	SC_R_SC_PIT = 343,
-	SC_R_SC_UART = 344,
-	SC_R_SC_I2C = 345,
-	SC_R_SC_MU_0B = 346,
-	SC_R_SC_MU_0A0 = 347,
-	SC_R_SC_MU_0A1 = 348,
-	SC_R_SC_MU_0A2 = 349,
-	SC_R_SC_MU_0A3 = 350,
-	SC_R_SC_MU_1A = 351,
-	SC_R_SYSCNT_RD = 352,
-	SC_R_SYSCNT_CMP = 353,
-	SC_R_DEBUG = 354,
-	SC_R_SYSTEM = 355,
-	SC_R_SNVS = 356,
-	SC_R_OTP = 357,
-	SC_R_VPU_PID0 = 358,
-	SC_R_VPU_PID1 = 359,
-	SC_R_VPU_PID2 = 360,
-	SC_R_VPU_PID3 = 361,
-	SC_R_VPU_PID4 = 362,
-	SC_R_VPU_PID5 = 363,
-	SC_R_VPU_PID6 = 364,
-	SC_R_VPU_PID7 = 365,
-	SC_R_VPU_UART = 366,
-	SC_R_VPUCORE = 367,
-	SC_R_VPUCORE_0 = 368,
-	SC_R_VPUCORE_1 = 369,
-	SC_R_VPUCORE_2 = 370,
-	SC_R_VPUCORE_3 = 371,
-	SC_R_DMA_4_CH0 = 372,
-	SC_R_DMA_4_CH1 = 373,
-	SC_R_DMA_4_CH2 = 374,
-	SC_R_DMA_4_CH3 = 375,
-	SC_R_DMA_4_CH4 = 376,
-	SC_R_ISI_CH0 = 377,
-	SC_R_ISI_CH1 = 378,
-	SC_R_ISI_CH2 = 379,
-	SC_R_ISI_CH3 = 380,
-	SC_R_ISI_CH4 = 381,
-	SC_R_ISI_CH5 = 382,
-	SC_R_ISI_CH6 = 383,
-	SC_R_ISI_CH7 = 384,
-	SC_R_MJPEG_DEC_S0 = 385,
-	SC_R_MJPEG_DEC_S1 = 386,
-	SC_R_MJPEG_DEC_S2 = 387,
-	SC_R_MJPEG_DEC_S3 = 388,
-	SC_R_MJPEG_ENC_S0 = 389,
-	SC_R_MJPEG_ENC_S1 = 390,
-	SC_R_MJPEG_ENC_S2 = 391,
-	SC_R_MJPEG_ENC_S3 = 392,
-	SC_R_MIPI_0 = 393,
-	SC_R_MIPI_0_PWM_0 = 394,
-	SC_R_MIPI_0_I2C_0 = 395,
-	SC_R_MIPI_0_I2C_1 = 396,
-	SC_R_MIPI_1 = 397,
-	SC_R_MIPI_1_PWM_0 = 398,
-	SC_R_MIPI_1_I2C_0 = 399,
-	SC_R_MIPI_1_I2C_1 = 400,
-	SC_R_CSI_0 = 401,
-	SC_R_CSI_0_PWM_0 = 402,
-	SC_R_CSI_0_I2C_0 = 403,
-	SC_R_CSI_1 = 404,
-	SC_R_CSI_1_PWM_0 = 405,
-	SC_R_CSI_1_I2C_0 = 406,
-	SC_R_HDMI = 407,
-	SC_R_HDMI_I2S = 408,
-	SC_R_HDMI_I2C_0 = 409,
-	SC_R_HDMI_PLL_0 = 410,
-	SC_R_HDMI_RX = 411,
-	SC_R_HDMI_RX_BYPASS = 412,
-	SC_R_HDMI_RX_I2C_0 = 413,
-	SC_R_ASRC_0 = 414,
-	SC_R_ESAI_0 = 415,
-	SC_R_SPDIF_0 = 416,
-	SC_R_SPDIF_1 = 417,
-	SC_R_SAI_3 = 418,
-	SC_R_SAI_4 = 419,
-	SC_R_SAI_5 = 420,
-	SC_R_GPT_5 = 421,
-	SC_R_GPT_6 = 422,
-	SC_R_GPT_7 = 423,
-	SC_R_GPT_8 = 424,
-	SC_R_GPT_9 = 425,
-	SC_R_GPT_10 = 426,
-	SC_R_DMA_2_CH5 = 427,
-	SC_R_DMA_2_CH6 = 428,
-	SC_R_DMA_2_CH7 = 429,
-	SC_R_DMA_2_CH8 = 430,
-	SC_R_DMA_2_CH9 = 431,
-	SC_R_DMA_2_CH10 = 432,
-	SC_R_DMA_2_CH11 = 433,
-	SC_R_DMA_2_CH12 = 434,
-	SC_R_DMA_2_CH13 = 435,
-	SC_R_DMA_2_CH14 = 436,
-	SC_R_DMA_2_CH15 = 437,
-	SC_R_DMA_2_CH16 = 438,
-	SC_R_DMA_2_CH17 = 439,
-	SC_R_DMA_2_CH18 = 440,
-	SC_R_DMA_2_CH19 = 441,
-	SC_R_DMA_2_CH20 = 442,
-	SC_R_DMA_2_CH21 = 443,
-	SC_R_DMA_2_CH22 = 444,
-	SC_R_DMA_2_CH23 = 445,
-	SC_R_DMA_2_CH24 = 446,
-	SC_R_DMA_2_CH25 = 447,
-	SC_R_DMA_2_CH26 = 448,
-	SC_R_DMA_2_CH27 = 449,
-	SC_R_DMA_2_CH28 = 450,
-	SC_R_DMA_2_CH29 = 451,
-	SC_R_DMA_2_CH30 = 452,
-	SC_R_DMA_2_CH31 = 453,
-	SC_R_ASRC_1 = 454,
-	SC_R_ESAI_1 = 455,
-	SC_R_SAI_6 = 456,
-	SC_R_SAI_7 = 457,
-	SC_R_AMIX = 458,
-	SC_R_MQS_0 = 459,
-	SC_R_DMA_3_CH0 = 460,
-	SC_R_DMA_3_CH1 = 461,
-	SC_R_DMA_3_CH2 = 462,
-	SC_R_DMA_3_CH3 = 463,
-	SC_R_DMA_3_CH4 = 464,
-	SC_R_DMA_3_CH5 = 465,
-	SC_R_DMA_3_CH6 = 466,
-	SC_R_DMA_3_CH7 = 467,
-	SC_R_DMA_3_CH8 = 468,
-	SC_R_DMA_3_CH9 = 469,
-	SC_R_DMA_3_CH10 = 470,
-	SC_R_DMA_3_CH11 = 471,
-	SC_R_DMA_3_CH12 = 472,
-	SC_R_DMA_3_CH13 = 473,
-	SC_R_DMA_3_CH14 = 474,
-	SC_R_DMA_3_CH15 = 475,
-	SC_R_DMA_3_CH16 = 476,
-	SC_R_DMA_3_CH17 = 477,
-	SC_R_DMA_3_CH18 = 478,
-	SC_R_DMA_3_CH19 = 479,
-	SC_R_DMA_3_CH20 = 480,
-	SC_R_DMA_3_CH21 = 481,
-	SC_R_DMA_3_CH22 = 482,
-	SC_R_DMA_3_CH23 = 483,
-	SC_R_DMA_3_CH24 = 484,
-	SC_R_DMA_3_CH25 = 485,
-	SC_R_DMA_3_CH26 = 486,
-	SC_R_DMA_3_CH27 = 487,
-	SC_R_DMA_3_CH28 = 488,
-	SC_R_DMA_3_CH29 = 489,
-	SC_R_DMA_3_CH30 = 490,
-	SC_R_DMA_3_CH31 = 491,
-	SC_R_AUDIO_PLL_1 = 492,
-	SC_R_AUDIO_CLK_0 = 493,
-	SC_R_AUDIO_CLK_1 = 494,
-	SC_R_MCLK_OUT_0 = 495,
-	SC_R_MCLK_OUT_1 = 496,
-	SC_R_PMIC_0 = 497,
-	SC_R_PMIC_1 = 498,
-	SC_R_SECO = 499,
-	SC_R_CAAM_JR1 = 500,
-	SC_R_CAAM_JR2 = 501,
-	SC_R_CAAM_JR3 = 502,
-	SC_R_SECO_MU_2 = 503,
-	SC_R_SECO_MU_3 = 504,
-	SC_R_SECO_MU_4 = 505,
-	SC_R_HDMI_RX_PWM_0 = 506,
-	SC_R_A35 = 507,
-	SC_R_A35_0 = 508,
-	SC_R_A35_1 = 509,
-	SC_R_A35_2 = 510,
-	SC_R_A35_3 = 511,
-	SC_R_DSP = 512,
-	SC_R_DSP_RAM = 513,
-	SC_R_CAAM_JR1_OUT = 514,
-	SC_R_CAAM_JR2_OUT = 515,
-	SC_R_CAAM_JR3_OUT = 516,
-	SC_R_VPU_DEC_0 = 517,
-	SC_R_VPU_ENC_0 = 518,
-	SC_R_CAAM_JR0 = 519,
-	SC_R_CAAM_JR0_OUT = 520,
-	SC_R_PMIC_2 = 521,
-	SC_R_DBLOGIC = 522,
-	SC_R_HDMI_PLL_1 = 523,
-	SC_R_BOARD_R0 = 524,
-	SC_R_BOARD_R1 = 525,
-	SC_R_BOARD_R2 = 526,
-	SC_R_BOARD_R3 = 527,
-	SC_R_BOARD_R4 = 528,
-	SC_R_BOARD_R5 = 529,
-	SC_R_BOARD_R6 = 530,
-	SC_R_BOARD_R7 = 531,
-	SC_R_MJPEG_DEC_MP = 532,
-	SC_R_MJPEG_ENC_MP = 533,
-	SC_R_VPU_TS_0 = 534,
-	SC_R_VPU_MU_0 = 535,
-	SC_R_VPU_MU_1 = 536,
-	SC_R_VPU_MU_2 = 537,
-	SC_R_VPU_MU_3 = 538,
-	SC_R_VPU_ENC_1 = 539,
-	SC_R_VPU = 540,
-	SC_R_LAST
-} sc_rsrc_t;
-
-/* NOTE - please add by replacing some of the UNUSED from above! */
+typedef uint32_t sc_rsrc_t;
 
 /*!
  * This type is used to indicate a control.
  */
-typedef enum sc_ctrl_e {
-
-	SC_C_TEMP = 0,
-	SC_C_TEMP_HI = 1,
-	SC_C_TEMP_LOW = 2,
-	SC_C_PXL_LINK_MST1_ADDR = 3,
-	SC_C_PXL_LINK_MST2_ADDR = 4,
-	SC_C_PXL_LINK_MST_ENB = 5,
-	SC_C_PXL_LINK_MST1_ENB = 6,
-	SC_C_PXL_LINK_MST2_ENB = 7,
-	SC_C_PXL_LINK_SLV1_ADDR = 8,
-	SC_C_PXL_LINK_SLV2_ADDR = 9,
-	SC_C_PXL_LINK_MST_VLD = 10,
-	SC_C_PXL_LINK_MST1_VLD = 11,
-	SC_C_PXL_LINK_MST2_VLD = 12,
-	SC_C_SINGLE_MODE = 13,
-	SC_C_ID = 14,
-	SC_C_PXL_CLK_POLARITY = 15,
-	SC_C_LINESTATE = 16,
-	SC_C_PCIE_G_RST = 17,
-	SC_C_PCIE_BUTTON_RST = 18,
-	SC_C_PCIE_PERST = 19,
-	SC_C_PHY_RESET = 20,
-	SC_C_PXL_LINK_RATE_CORRECTION = 21,
-	SC_C_PANIC = 22,
-	SC_C_PRIORITY_GROUP = 23,
-	SC_C_TXCLK = 24,
-	SC_C_CLKDIV = 25,
-	SC_C_DISABLE_50 = 26,
-	SC_C_DISABLE_125 = 27,
-	SC_C_SEL_125 = 28,
-	SC_C_MODE = 29,
-	SC_C_SYNC_CTRL0 = 30,
-	SC_C_KACHUNK_CNT = 31,
-	SC_C_KACHUNK_SEL = 32,
-	SC_C_SYNC_CTRL1 = 33,
-	SC_C_DPI_RESET = 34,
-	SC_C_MIPI_RESET = 35,
-	SC_C_DUAL_MODE = 36,
-	SC_C_VOLTAGE = 37,
-	SC_C_PXL_LINK_SEL = 38,
-	SC_C_OFS_SEL = 39,
-	SC_C_OFS_AUDIO = 40,
-	SC_C_OFS_PERIPH = 41,
-	SC_C_OFS_IRQ = 42,
-	SC_C_RST0 = 43,
-	SC_C_RST1 = 44,
-	SC_C_SEL0 = 45,
-	SC_C_CALIB0 = 46,
-	SC_C_CALIB1 = 47,
-	SC_C_CALIB2 = 48,
-	SC_C_IPG_DEBUG = 49,
-	SC_C_IPG_DOZE = 50,
-	SC_C_IPG_WAIT = 51,
-	SC_C_IPG_STOP = 52,
-	SC_C_IPG_STOP_MODE = 53,
-	SC_C_IPG_STOP_ACK = 54,
-	SC_C_SYNC_CTRL = 55,
-	SC_C_LAST
-} sc_ctrl_t;
+typedef uint32_t sc_ctrl_t;
 
 /*!
  * This type is used to indicate a pad. Valid values are SoC specific.
@@ -787,11 +835,6 @@
 
 #ifdef DOXYGEN
     /*!
-     * Type used to declare a true/false boolean.
-     */
-typedef enum { false = 0, true = 1 } bool;
-
-    /*!
      * Type used to declare an 8-bit integer.
      */
 typedef __INT8_TYPE__ int8_t;
@@ -832,4 +875,4 @@
 typedef __UINT64_TYPE__ uint64_t;
 #endif
 
-#endif				/* _SC_TYPES_H */
+#endif				/* SC_TYPES_H */
-- 
1.7.9.5


From 70f223c0e77ff512baad627e2f8d7e289d6269fc Mon Sep 17 00:00:00 2001
From: Ya Zhou <ya.zhou@nxp.com>
Date: Wed, 24 Oct 2018 02:08:48 +0800
Subject: [PATCH 4915/5242] MGS-4010 [#imx-919] Vulkan test met gpu hang on
 wayland

commit  7fa256e32f392d31156d6250189c8a5d9a1394ac from
https://source.codeaurora.org/external/imx/linux-imx.git

These case will generate a huge command object, which was divided into 33 Command Buffers to commit.
It will introduce a context switch within a command object. So add a mutex to avoid the Context switch.

Date: 23th Otc,2018
Signed-off-by Ya Zhou <ya.zhou@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     |   54 +++++++++++++++-----
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |   14 +++++
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |    1 +
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |   20 ++++++++
 4 files changed, 75 insertions(+), 14 deletions(-)

diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 7ad5956..97f0128 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -2558,12 +2558,15 @@
         break;
 
     case gcvHAL_EVENT_COMMIT:
-        gcmkONERROR(gckOS_AcquireMutex(Kernel->os,
-            Kernel->device->commitMutex,
-            gcvINFINITE
-            ));
+        if (!Interface->commitMutex)
+        {
+            gcmkONERROR(gckOS_AcquireMutex(Kernel->os,
+                Kernel->device->commitMutex,
+                gcvINFINITE
+                ));
 
-        commitMutexAcquired = gcvTRUE;
+            commitMutexAcquired = gcvTRUE;
+        }
         /* Commit an event queue. */
         if (Interface->engine == gcvENGINE_BLT)
         {
@@ -2581,16 +2584,22 @@
                 Kernel->eventObj, gcmUINT64_TO_PTR(Interface->u.Event.queue), gcvFALSE));
         }
 
-        gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->device->commitMutex));
-        commitMutexAcquired = gcvFALSE;
+        if (!Interface->commitMutex)
+        {
+            gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->device->commitMutex));
+            commitMutexAcquired = gcvFALSE;
+        }
         break;
 
     case gcvHAL_COMMIT:
-        gcmkONERROR(gckOS_AcquireMutex(Kernel->os,
-            Kernel->device->commitMutex,
-            gcvINFINITE
-            ));
-        commitMutexAcquired = gcvTRUE;
+        if (!Interface->commitMutex)
+        {
+            gcmkONERROR(gckOS_AcquireMutex(Kernel->os,
+                Kernel->device->commitMutex,
+                gcvINFINITE
+                ));
+            commitMutexAcquired = gcvTRUE;
+        }
 
         /* Commit a command and context buffer. */
         if (Interface->engine == gcvENGINE_BLT)
@@ -2715,9 +2724,12 @@
                 }
             }
         }
-        gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->device->commitMutex));
-        commitMutexAcquired = gcvFALSE;
 
+        if (!Interface->commitMutex)
+        {
+            gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->device->commitMutex));
+            commitMutexAcquired = gcvFALSE;
+        }
         break;
 
     case gcvHAL_STALL:
@@ -3439,6 +3451,20 @@
             ));
         break;
 
+    case gcvHAL_DEVICE_MUTEX:
+        if (Interface->u.DeviceMutex.isMutexLocked)
+        {
+            gcmkONERROR(gckOS_AcquireMutex(Kernel->os,
+                Kernel->device->commitMutex,
+                gcvINFINITE
+                ));
+        }
+        else
+        {
+            gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->device->commitMutex));
+        }
+        break;
+
 #if gcdDEC_ENABLE_AHB
     case gcvHAL_DEC300_READ:
         gcmkONERROR(viv_dec300_read(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index cf5267f..e8d7cbb9f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -242,6 +242,9 @@
     /* Wait until GPU finishes access to a resource. */
     gcvHAL_WAIT_FENCE,
 
+    /* Mutex Operation. */
+    gcvHAL_DEVICE_MUTEX,
+
 #if gcdDEC_ENABLE_AHB
     gcvHAL_DEC300_READ,
     gcvHAL_DEC300_WRITE,
@@ -416,6 +419,9 @@
     /* Ignore information from TSL when doing IO control */
     gctBOOL                     ignoreTLS;
 
+    /* The mutext already acquired */
+    IN gctBOOL                  commitMutex;
+
     /* Union of command structures. */
     union _u
     {
@@ -1361,6 +1367,14 @@
         }
         BottomHalfUnlockVideoMemory;
 
+        /* gcvHAL_DEVICE_MUTEX: */
+        struct _gcsHAL_DEVICE_MUTEX
+        {
+            /* Lock or Release device mutex. */
+            gctBOOL                     isMutexLocked;
+        }
+        DeviceMutex;
+
         gcsHAL_QUERY_CHIP_OPTIONS QueryChipOptions;
     }
     u;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index 185485cf..4232200 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -177,6 +177,7 @@
      * closes it.
      */
     gctUINT32           pidOpen;
+    gctBOOL             isLocked;
 }
 gcsHAL_PRIVATE_DATA, * gcsHAL_PRIVATE_DATA_PTR;
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index 39beea7..6159398 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -388,6 +388,7 @@ static int drv_open(
 
     data->device             = galDevice;
     data->pidOpen            = _GetProcessID();
+    data->isLocked           = gcvFALSE;
 
     /* Attached the process. */
     for (i = 0; i < gcdMAX_GPU_COUNT; i++)
@@ -475,6 +476,13 @@ static int drv_release(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
+    if (data->isLocked)
+    {
+        /* Release the mutex. */
+        gcmkONERROR(gckOS_ReleaseMutex(gcvNULL, device->device->commitMutex));
+        data->isLocked = gcvFALSE;
+    }
+
     /* A process gets detached. */
     for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
@@ -610,6 +618,18 @@ static long drv_ioctl(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
+    if (iface.command == gcvHAL_DEVICE_MUTEX)
+    {
+        if (iface.u.DeviceMutex.isMutexLocked == gcvTRUE)
+        {
+            data->isLocked = gcvTRUE;
+        }
+        else
+        {
+            data->isLocked = gcvFALSE;
+        }
+    }
+
     status = gckDEVICE_Dispatch(device->device, &iface);
 
     /* Redo system call after pending signal is handled. */
-- 
1.7.9.5


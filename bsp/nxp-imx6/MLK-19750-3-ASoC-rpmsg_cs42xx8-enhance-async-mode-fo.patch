From 2fc337f4f0bf4d3cdbb1ba96c3452c66a2f3b979 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@nxp.com>
Date: Wed, 31 Oct 2018 16:45:27 +0800
Subject: [PATCH 4965/5242] MLK-19750-3: ASoC: rpmsg_cs42xx8: enhance async
 mode for rpmsg_cs42xx8

commit  e366eb506e02ae981bc66b1a8664a84b2955249d from
https://source.codeaurora.org/external/imx/linux-imx.git

with this patch,codec driver can support tx and rx in
different master/slave mode, for example, tx in master mode,
rx in slave mode

Signed-off-by: Shengjiu Wang <shengjiu.wang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/codecs/rpmsg_cs42xx8.c |   75 ++++++++++++++++++++++----------------
 1 file changed, 44 insertions(+), 31 deletions(-)

diff --git a/sound/soc/codecs/rpmsg_cs42xx8.c b/sound/soc/codecs/rpmsg_cs42xx8.c
index ec3bb63..650d1ae 100644
--- a/sound/soc/codecs/rpmsg_cs42xx8.c
+++ b/sound/soc/codecs/rpmsg_cs42xx8.c
@@ -43,7 +43,7 @@ struct rpmsg_cs42xx8_priv {
 	struct regmap *regmap;
 	struct clk *clk;
 
-	bool slave_mode;
+	bool slave_mode[2];
 	unsigned long sysclk;
 	u32 tx_channels;
 	int rate[2];
@@ -253,11 +253,11 @@ static int cs42xx8_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_component *component = dai->component;
 	struct rpmsg_cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	u32 rate = params_rate(params);
-	u32 ratio_tx, ratio_rx;
-	u32 rate_tx, rate_rx;
-	u32 fm_tx, fm_rx;
-	u32 i, fm, val, mask;
+	u32 ratio[2];
+	u32 rate[2];
+	u32 fm[2];
+	u32 i, val, mask;
+	bool condition1, condition2;
 
 	if (tx)
 		cs42xx8->tx_channels = params_channels(params);
@@ -286,28 +286,29 @@ static int cs42xx8_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	fm = tx ? fm_tx : fm_rx;
-
-	if (fm == CS42XX8_FM_AUTO) {
-		for (i = 0; i < ARRAY_SIZE(cs42xx8_ratios); i++) {
-			if ((ratio_tx > 0 ? (cs42xx8_ratios[i].ratio[0] == ratio_tx ||
-				cs42xx8_ratios[i].ratio[1] == ratio_tx ||
-				cs42xx8_ratios[i].ratio[2] == ratio_tx) : true) &&
-			    (ratio_rx > 0 ? (cs42xx8_ratios[i].ratio[0] == ratio_rx ||
-				cs42xx8_ratios[i].ratio[1] == ratio_rx ||
-				cs42xx8_ratios[i].ratio[2] == ratio_rx) : true) &&
-			    cs42xx8->sysclk >= cs42xx8_ratios[i].min_mclk &&
-			    cs42xx8->sysclk <= cs42xx8_ratios[i].max_mclk)
-				break;
-		}
-	} else {
-		for (i = 0; i < ARRAY_SIZE(cs42xx8_ratios); i++) {
-			if ((ratio_tx > 0 ? (cs42xx8_ratios[i].ratio[fm_tx] == ratio_tx) : true) &&
-				(ratio_rx > 0 ? (cs42xx8_ratios[i].ratio[fm_rx] == ratio_rx) : true) &&
-				cs42xx8->sysclk >= cs42xx8_ratios[i].min_mclk &&
-				cs42xx8->sysclk <= cs42xx8_ratios[i].max_mclk)
-				break;
-		}
+	for (i = 0; i < ARRAY_SIZE(cs42xx8_ratios); i++) {
+		condition1 = ((fm[tx] == CS42XX8_FM_AUTO) ?
+			(cs42xx8_ratios[i].ratio[0] == ratio[tx] ||
+			cs42xx8_ratios[i].ratio[1] == ratio[tx] ||
+			cs42xx8_ratios[i].ratio[2] == ratio[tx]) :
+			(cs42xx8_ratios[i].ratio[fm[tx]] == ratio[tx])) &&
+			cs42xx8->sysclk >= cs42xx8_ratios[i].min_mclk &&
+			cs42xx8->sysclk <= cs42xx8_ratios[i].max_mclk;
+
+		if (ratio[tx] <= 0)
+			condition1 = true;
+
+		condition2 = ((fm[!tx] == CS42XX8_FM_AUTO) ?
+			(cs42xx8_ratios[i].ratio[0] == ratio[!tx] ||
+			cs42xx8_ratios[i].ratio[1] == ratio[!tx] ||
+			cs42xx8_ratios[i].ratio[2] == ratio[!tx]) :
+			(cs42xx8_ratios[i].ratio[fm[!tx]] == ratio[!tx]));
+
+		if (ratio[!tx] <= 0)
+			condition2 = true;
+
+		if (condition1 && condition2)
+			break;
 	}
 
 	if (i == ARRAY_SIZE(cs42xx8_ratios)) {
@@ -315,14 +316,14 @@ static int cs42xx8_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	cs42xx8->rate[substream->stream] = rate;
+	cs42xx8->rate[tx] = params_rate(params);
 
 	mask = CS42XX8_FUNCMOD_MFREQ_MASK;
 	val = cs42xx8_ratios[i].mfreq;
 
 	regmap_update_bits(cs42xx8->regmap, CS42XX8_FUNCMOD,
 			   CS42XX8_FUNCMOD_xC_FM_MASK(tx) | mask,
-			   CS42XX8_FUNCMOD_xC_FM(tx, fm) | val);
+			   CS42XX8_FUNCMOD_xC_FM(tx, fm[tx]) | val);
 
 	return 0;
 }
@@ -335,7 +336,7 @@ static int cs42xx8_hw_free(struct snd_pcm_substream *substream,
 	struct rpmsg_cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
-	cs42xx8->rate[substream->stream] = 0;
+	cs42xx8->rate[tx] = 0;
 
 	regmap_update_bits(cs42xx8->regmap, CS42XX8_FUNCMOD,
 			   CS42XX8_FUNCMOD_xC_FM_MASK(tx),
@@ -574,6 +575,18 @@ static int rpmsg_cs42xx8_codec_probe(struct platform_device *pdev)
 
 	cs42xx8->sysclk = clk_get_rate(cs42xx8->clk);
 
+	if (of_property_read_bool(pdev->dev.parent->of_node, "fsl,txm-rxs")) {
+		/* 0 --  rx,  1 -- tx */
+		cs42xx8->slave_mode[0] = true;
+		cs42xx8->slave_mode[1] = false;
+	}
+
+	if (of_property_read_bool(pdev->dev.parent->of_node, "fsl,txs-rxm")) {
+		/* 0 --  rx,  1 -- tx */
+		cs42xx8->slave_mode[0] = false;
+		cs42xx8->slave_mode[1] = true;
+	}
+
 	for (i = 0; i < ARRAY_SIZE(cs42xx8->supplies); i++)
 		cs42xx8->supplies[i].supply = cs42xx8_supply_names[i];
 
-- 
1.7.9.5


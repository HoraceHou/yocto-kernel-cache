From 8d56baa68317501acff6a0d2fe7e57079b5ad53d Mon Sep 17 00:00:00 2001
From: Leonard Crestez <leonard.crestez@nxp.com>
Date: Wed, 21 Feb 2018 19:57:53 +0200
Subject: [PATCH 0486/5242] MLK-10058-3 arm: gpc: add pcie phy power gpc
 operations

commit  bb9d1ba362f17d6c779568958d91950a8cf24cf8 from
https://source.codeaurora.org/external/imx/linux-imx.git

For PCIe module on i.mx6sx, some GPC operations would be mandatory
required when PCIe PHY is powered on/off. So we need update gpc driver
for the new requirements. We implement it by regulator notify framwork
in gpc driver.

NOTE: make sure gpc driver is ready before PCIe driver is probed.
Otherwise, cause system hang during PCIe driver probe, because the
notify NOT installed ready and the gpc will NOT power on PCIe.

Signed-off-by: Richard Zhu <Richard.Zhu@freescale.com>

For 4.14 attempted to port this in new gpc implementation.

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/gpc.c |   50 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/drivers/soc/imx/gpc.c b/drivers/soc/imx/gpc.c
index 6daf62a..78baf05 100644
--- a/drivers/soc/imx/gpc.c
+++ b/drivers/soc/imx/gpc.c
@@ -21,6 +21,11 @@
 
 #define GPC_CNTR		0x000
 
+#define GPC_CNTR_PCIE_PHY_PDU_SHIFT	0x7
+#define GPC_CNTR_PCIE_PHY_PDN_SHIFT	0x6
+#define PGC_PCIE_PHY_CTRL		0x200
+#define PGC_PCIE_PHY_PDN_EN		0x1
+
 #define GPC_PGC_CTRL_OFFS	0x0
 #define GPC_PGC_PUPSCR_OFFS	0x4
 #define GPC_PGC_PDNSCR_OFFS	0x8
@@ -418,6 +423,32 @@ static void imx_gpc_handle_ldobypass(struct platform_device *pdev)
 	}
 }
 
+static struct notifier_block nb_pcie;
+
+static int imx_pcie_regulator_notify(struct notifier_block *nb,
+					unsigned long event,
+					void *ignored)
+{
+	u32 value = readl_relaxed(gpc_base + GPC_CNTR);
+
+	switch (event) {
+	case REGULATOR_EVENT_PRE_DO_ENABLE:
+		value |= 1 << GPC_CNTR_PCIE_PHY_PDU_SHIFT;
+		writel_relaxed(value, gpc_base + GPC_CNTR);
+		break;
+	case REGULATOR_EVENT_PRE_DO_DISABLE:
+		value |= 1 << GPC_CNTR_PCIE_PHY_PDN_SHIFT;
+		writel_relaxed(value, gpc_base + GPC_CNTR);
+		writel_relaxed(PGC_PCIE_PHY_PDN_EN,
+				gpc_base + PGC_PCIE_PHY_CTRL);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
 static int imx_gpc_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id =
@@ -516,6 +547,25 @@ static int imx_gpc_probe(struct platform_device *pdev)
 
 	imx_gpc_handle_ldobypass(pdev);
 
+	if (of_machine_is_compatible("fsl,imx6sx")) {
+		struct regulator *pcie_reg;
+
+		pcie_reg = devm_regulator_get(&pdev->dev, "pcie-phy");
+		if (IS_ERR(pcie_reg)) {
+			ret = PTR_ERR(pcie_reg);
+			dev_info(&pdev->dev, "pcie regulator not ready.\n");
+			return ret;
+		}
+		nb_pcie.notifier_call = &imx_pcie_regulator_notify;
+
+		ret = regulator_register_notifier(pcie_reg, &nb_pcie);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"pcie regulator notifier request failed\n");
+			return ret;
+		}
+	}
+
 	return 0;
 }
 
-- 
1.7.9.5


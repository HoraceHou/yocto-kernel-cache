From f876ab365133f583c85b5f7e2f7e212e14e3c574 Mon Sep 17 00:00:00 2001
From: Zidan Wang <zidan.wang@freescale.com>
Date: Fri, 26 Jun 2015 16:06:45 +0800
Subject: [PATCH 0281/5242] MLK-11179 ASoC: fsl: implement specify audio DMA
 buffer size from devicetree

commit  9cee852bf017d8a43362d5dba275bd9be64fa679 from
https://source.codeaurora.org/external/imx/linux-imx.git

If the property "fsl,dma-buffer-size" is present, using the specified buffer size.
Otherwise, using the default audio buffer size.

Signed-off-by: Zidan Wang <zidan.wang@freescale.com>
(cherry picked from commit bba153dd92a4f58b81c4c26fb3a95c45445c65e0)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/sound/fsl,esai.txt         |    4 ++++
 .../devicetree/bindings/sound/fsl,spdif.txt        |    4 ++++
 .../devicetree/bindings/sound/fsl,ssi.txt          |    4 ++++
 sound/soc/fsl/fsl_esai.c                           |    8 ++++++--
 sound/soc/fsl/fsl_sai.c                            |    6 +++++-
 sound/soc/fsl/fsl_spdif.c                          |    6 +++++-
 sound/soc/fsl/fsl_ssi.c                            |    6 +++++-
 7 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/Documentation/devicetree/bindings/sound/fsl,esai.txt b/Documentation/devicetree/bindings/sound/fsl,esai.txt
index 5b99143..3574b53 100644
--- a/Documentation/devicetree/bindings/sound/fsl,esai.txt
+++ b/Documentation/devicetree/bindings/sound/fsl,esai.txt
@@ -48,6 +48,10 @@ Optional properties:
 			  will be in use as default, or the big endian mode
 			  will be in use for all the device registers.
 
+  - fsl,dma-buffer-size: It specify the audio buffer size of playback and
+    capture. If this property is absent, using the default value of audio buffer
+    size.
+
 Example:
 
 esai: esai@2024000 {
diff --git a/Documentation/devicetree/bindings/sound/fsl,spdif.txt b/Documentation/devicetree/bindings/sound/fsl,spdif.txt
index 8b324f8..e5cd44c 100644
--- a/Documentation/devicetree/bindings/sound/fsl,spdif.txt
+++ b/Documentation/devicetree/bindings/sound/fsl,spdif.txt
@@ -39,6 +39,10 @@ Optional properties:
 			  will be in use as default, or the big endian mode
 			  will be in use for all the device registers.
 
+   - fsl,dma-buffer-size: It specify the audio buffer size of playback and
+   capture. If this property is absent, using the default value of audio buffer
+   size.
+
 Example:
 
 spdif: spdif@2004000 {
diff --git a/Documentation/devicetree/bindings/sound/fsl,ssi.txt b/Documentation/devicetree/bindings/sound/fsl,ssi.txt
index d415888..1a61722 100644
--- a/Documentation/devicetree/bindings/sound/fsl,ssi.txt
+++ b/Documentation/devicetree/bindings/sound/fsl,ssi.txt
@@ -64,6 +64,10 @@ Optional properties:
                     by SOC design.  See the notes below.
                     Only used on Power Architecture.
 
+- fsl,dma-buffer-size: It specify the audio buffer size of playback and
+  capture. If this property is absent, using the default value of audio buffer
+  size.
+
 Child 'codec' node required properties:
 - compatible:       Compatible list, contains the name of the codec
 
diff --git a/sound/soc/fsl/fsl_esai.c b/sound/soc/fsl/fsl_esai.c
index 8f43110..1696fe3 100644
--- a/sound/soc/fsl/fsl_esai.c
+++ b/sound/soc/fsl/fsl_esai.c
@@ -2,7 +2,7 @@
 //
 // Freescale ESAI ALSA SoC Digital Audio Interface (DAI) driver
 //
-// Copyright (C) 2014 Freescale Semiconductor, Inc.
+// Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
 
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
@@ -800,6 +800,7 @@ static int fsl_esai_probe(struct platform_device *pdev)
 	const __be32 *iprop;
 	void __iomem *regs;
 	int irq, ret;
+	u32 buffer_size;
 
 	esai_priv = devm_kzalloc(&pdev->dev, sizeof(*esai_priv), GFP_KERNEL);
 	if (!esai_priv)
@@ -911,7 +912,10 @@ static int fsl_esai_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = imx_pcm_dma_init(pdev, IMX_ESAI_DMABUF_SIZE);
+	if (of_property_read_u32(np, "fsl,dma-buffer-size", &buffer_size))
+		buffer_size = IMX_ESAI_DMABUF_SIZE;
+
+	ret = imx_pcm_dma_init(pdev, buffer_size);
 	if (ret)
 		dev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);
 
diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 720d9b2..da7627d 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -802,6 +802,7 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	char tmp[8];
 	int irq, ret, i;
 	int index;
+	u32 buffer_size;
 
 	sai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);
 	if (!sai)
@@ -918,8 +919,11 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	if (of_property_read_u32(np, "fsl,dma-buffer-size", &buffer_size))
+		buffer_size = IMX_SAI_DMABUF_SIZE;
+
 	if (sai->sai_on_imx)
-		return imx_pcm_dma_init(pdev, IMX_SAI_DMABUF_SIZE);
+		return imx_pcm_dma_init(pdev, buffer_size);
 	else
 		return devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 }
diff --git a/sound/soc/fsl/fsl_spdif.c b/sound/soc/fsl/fsl_spdif.c
index 9b59d87..0b43a77 100644
--- a/sound/soc/fsl/fsl_spdif.c
+++ b/sound/soc/fsl/fsl_spdif.c
@@ -1218,6 +1218,7 @@ static int fsl_spdif_probe(struct platform_device *pdev)
 	struct resource *res;
 	void __iomem *regs;
 	int irq, ret, i;
+	u32 buffer_size;
 
 	if (!np)
 		return -ENODEV;
@@ -1319,7 +1320,10 @@ static int fsl_spdif_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = imx_pcm_dma_init(pdev, IMX_SPDIF_DMABUF_SIZE);
+	if (of_property_read_u32(np, "fsl,dma-buffer-size", &buffer_size))
+		buffer_size = IMX_SPDIF_DMABUF_SIZE;
+
+	ret = imx_pcm_dma_init(pdev, buffer_size);
 	if (ret)
 		dev_err(&pdev->dev, "imx_pcm_dma_init failed: %d\n", ret);
 
diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c
index 0a64822..69a23be 100644
--- a/sound/soc/fsl/fsl_ssi.c
+++ b/sound/soc/fsl/fsl_ssi.c
@@ -1297,6 +1297,7 @@ static int fsl_ssi_imx_probe(struct platform_device *pdev,
 {
 	struct device *dev = &pdev->dev;
 	int ret;
+	u32 buffer_size;
 
 	/* Backward compatible for a DT without ipg clock name assigned */
 	if (ssi->has_ipg_clk_name)
@@ -1335,6 +1336,9 @@ static int fsl_ssi_imx_probe(struct platform_device *pdev,
 		ssi->dma_params_rx.maxburst &= ~0x1;
 	}
 
+	if (of_property_read_u32(np, "fsl,dma-buffer-size", &buffer_size))
+		buffer_size = IMX_SSI_DMABUF_SIZE;
+
 	if (!ssi->use_dma) {
 		/*
 		 * Some boards use an incompatible codec. Use imx-fiq-pcm-audio
@@ -1349,7 +1353,7 @@ static int fsl_ssi_imx_probe(struct platform_device *pdev,
 		if (ret)
 			goto error_pcm;
 	} else {
-		ret = imx_pcm_dma_init(pdev, IMX_SSI_DMABUF_SIZE);
+		ret = imx_pcm_dma_init(pdev, buffer_size);
 		if (ret)
 			goto error_pcm;
 	}
-- 
1.7.9.5


From 69e36834c79edf8439b3a3a412e4c58e59c1e797 Mon Sep 17 00:00:00 2001
From: "Guoniu.Zhou" <guoniu.zhou@nxp.com>
Date: Tue, 31 Oct 2017 09:57:25 +0800
Subject: [PATCH 2741/5242] MLK-16692-1: csi: Identify which camera really
 connect to interface

commit  dc49c4cedefe6234149ef463d3bef298ca780eba from
https://source.codeaurora.org/external/imx/linux-imx.git

There maybe 0-4 cameras can connected to interface at
the same time. Add this ioctl to identify which camera
really connect to the interface.

Reviewed-by: Robby Cai <robby.cai@nxp.com>
Signed-off-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
(cherry picked from commit 785fbbd10c8a484b7f70488234c3a03e9aee9992)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/max9286.c     |   74 +------------------------
 drivers/media/platform/imx8/max9286.h     |   84 +++++++++++++++++++++++++++++
 drivers/media/platform/imx8/mxc-isi-cap.c |   42 +++++++++++++++
 3 files changed, 128 insertions(+), 72 deletions(-)
 create mode 100644 drivers/media/platform/imx8/max9286.h

diff --git a/drivers/media/platform/imx8/max9286.c b/drivers/media/platform/imx8/max9286.c
index 5610436..c45077d 100644
--- a/drivers/media/platform/imx8/max9286.c
+++ b/drivers/media/platform/imx8/max9286.c
@@ -24,6 +24,8 @@
 #include <linux/regulator/consumer.h>
 #include <media/v4l2-subdev.h>
 
+#include "max9286.h"
+
 #define MAX9271_MAX_SENSOR_NUM	4
 #define CAMERA_USES_15HZ
 
@@ -37,78 +39,6 @@
 static unsigned int g_max9286_width = 1280;
 static unsigned int g_max9286_height = 800;
 
-#define MIPI_CSI2_SENS_VC0_PAD_SOURCE	0
-#define MIPI_CSI2_SENS_VC1_PAD_SOURCE	1
-#define MIPI_CSI2_SENS_VC2_PAD_SOURCE	2
-#define MIPI_CSI2_SENS_VC3_PAD_SOURCE	3
-#define MIPI_CSI2_SENS_VCX_PADS_NUM		4
-
-/*!
- * Maintains the information on the current state of the sesor.
- */
-struct imxdpu_videomode {
-	char name[64];		/* may not be needed */
-
-	uint32_t pixelclock;	/* Hz */
-
-	/* htotal (pixels) = hlen + hfp + hsync + hbp */
-	uint32_t hlen;
-	uint32_t hfp;
-	uint32_t hbp;
-	uint32_t hsync;
-
-	/* field0 - vtotal (lines) = vlen + vfp + vsync + vbp */
-	uint32_t vlen;
-	uint32_t vfp;
-	uint32_t vbp;
-	uint32_t vsync;
-
-	/* field1  */
-	uint32_t vlen1;
-	uint32_t vfp1;
-	uint32_t vbp1;
-	uint32_t vsync1;
-
-	uint32_t flags;
-
-	uint32_t format;
-	uint32_t dest_format; /*buffer format for capture*/
-
-	int16_t clip_top;
-	int16_t clip_left;
-	uint16_t clip_width;
-	uint16_t clip_height;
-
-};
-struct sensor_data {
-	struct v4l2_subdev	subdev;
-	struct media_pad pads[MIPI_CSI2_SENS_VCX_PADS_NUM];
-	struct i2c_client *i2c_client;
-	struct v4l2_mbus_framefmt format;
-	struct v4l2_captureparm streamcap;
-	char running;
-
-	/* control settings */
-	int brightness;
-	int hue;
-	int contrast;
-	int saturation;
-	int red;
-	int green;
-	int blue;
-	int ae_mode;
-
-	u32 mclk;
-	u8 mclk_source;
-	struct clk *sensor_clk;
-	int v_channel;
-	bool is_mipi;
-	struct imxdpu_videomode cap_mode;
-
-	unsigned int sensor_num;       /* sensor num connect max9271 */
-	unsigned char sensor_is_there; /* Bit 0~3 for 4 cameras, 0b1= is there; 0b0 = is not there */
-};
-
 #ifdef CONFIG_SENSOR_OV10635
 #define OV10635_REG_PID		0x300A
 #define OV10635_REG_VER		0x300B
diff --git a/drivers/media/platform/imx8/max9286.h b/drivers/media/platform/imx8/max9286.h
new file mode 100644
index 0000000..f80f4a7
--- /dev/null
+++ b/drivers/media/platform/imx8/max9286.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later.
+ */
+
+#ifndef __MAX9286_H__
+#define __MAX9286_H__
+
+#define MIPI_CSI2_SENS_VC0_PAD_SOURCE	0
+#define MIPI_CSI2_SENS_VC1_PAD_SOURCE	1
+#define MIPI_CSI2_SENS_VC2_PAD_SOURCE	2
+#define MIPI_CSI2_SENS_VC3_PAD_SOURCE	3
+#define MIPI_CSI2_SENS_VCX_PADS_NUM		4
+
+/*!
+ * Maintains the information on the current state of the sesor.
+ */
+struct imxdpu_videomode {
+	char name[64];		/* may not be needed */
+
+	uint32_t pixelclock;	/* Hz */
+
+	/* htotal (pixels) = hlen + hfp + hsync + hbp */
+	uint32_t hlen;
+	uint32_t hfp;
+	uint32_t hbp;
+	uint32_t hsync;
+
+	/* field0 - vtotal (lines) = vlen + vfp + vsync + vbp */
+	uint32_t vlen;
+	uint32_t vfp;
+	uint32_t vbp;
+	uint32_t vsync;
+
+	/* field1  */
+	uint32_t vlen1;
+	uint32_t vfp1;
+	uint32_t vbp1;
+	uint32_t vsync1;
+
+	uint32_t flags;
+
+	uint32_t format;
+	uint32_t dest_format; /*buffer format for capture*/
+
+	int16_t clip_top;
+	int16_t clip_left;
+	uint16_t clip_width;
+	uint16_t clip_height;
+
+};
+struct sensor_data {
+	struct v4l2_subdev	subdev;
+	struct media_pad pads[MIPI_CSI2_SENS_VCX_PADS_NUM];
+	struct i2c_client *i2c_client;
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_captureparm streamcap;
+	char running;
+
+	/* control settings */
+	int brightness;
+	int hue;
+	int contrast;
+	int saturation;
+	int red;
+	int green;
+	int blue;
+	int ae_mode;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int v_channel;
+	bool is_mipi;
+	struct imxdpu_videomode cap_mode;
+
+	unsigned int sensor_num;       /* sensor num connect max9271 */
+	unsigned char sensor_is_there; /* Bit 0~3 for 4 cameras, 0b1= is there; 0b0 = is not there */
+};
+#endif
diff --git a/drivers/media/platform/imx8/mxc-isi-cap.c b/drivers/media/platform/imx8/mxc-isi-cap.c
index 4d21f9f..2dec8bb 100644
--- a/drivers/media/platform/imx8/mxc-isi-cap.c
+++ b/drivers/media/platform/imx8/mxc-isi-cap.c
@@ -31,6 +31,7 @@
 #include "mxc-isi-core.h"
 #include "mxc-isi-hw.h"
 #include "mxc-media-dev.h"
+#include "max9286.h"
 
 struct mxc_isi_fmt mxc_isi_out_formats[] = {
 	{
@@ -903,6 +904,46 @@ static int mxc_isi_cap_s_selection(struct file *file, void *fh,
 	return 0;
 }
 
+static struct v4l2_subdev *mxc_isi_get_subdev_by_name(struct v4l2_device *v4l2,
+			const char *name)
+{
+	struct v4l2_subdev *sd;
+	bool found = false;
+
+	list_for_each_entry(sd, &v4l2->subdevs, list) {
+		if (strstr(sd->name, name) != NULL) {
+			found = true;
+			break;
+		}
+	}
+
+	return (found) ? sd : NULL;
+}
+
+static int mxc_isi_cap_g_chip_ident(struct file *file, void *fb,
+			struct v4l2_dbg_chip_ident *chip)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct v4l2_device *v4l2_dev = mxc_isi->isi_cap.sd.v4l2_dev;
+	struct video_device *vdev = video_devdata(file);
+	struct sensor_data *max9286;
+	struct v4l2_subdev *sd;
+
+	sd = mxc_isi_get_subdev_by_name(v4l2_dev, "max9286_mipi");
+	if (sd == NULL) {
+		v4l2_err(&mxc_isi->isi_cap.sd, "Can't find sub device\n");
+		return -ENODEV;
+	}
+
+	max9286 = container_of(sd, struct sensor_data, subdev);
+	if (max9286->sensor_is_there & (0x1 << vdev->num))
+		sprintf(chip->match.name, "max9286_mipi%d\n", vdev->num);
+	else
+		return -ENODEV;
+
+	return 0;
+}
+
 static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
 	.vidioc_querycap		= mxc_isi_cap_querycap,
 
@@ -924,6 +965,7 @@ static int mxc_isi_cap_s_selection(struct file *file, void *fh,
 
 	.vidioc_g_selection		= mxc_isi_cap_g_selection,
 	.vidioc_s_selection		= mxc_isi_cap_s_selection,
+	.vidioc_g_chip_ident	= mxc_isi_cap_g_chip_ident,
 };
 
 /* Capture subdev media entity operations */
-- 
1.7.9.5


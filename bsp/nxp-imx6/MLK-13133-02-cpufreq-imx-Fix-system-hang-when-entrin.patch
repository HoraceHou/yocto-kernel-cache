From 59c81b3cac7bdeab8a153d7cfbf1fb8e2f05803a Mon Sep 17 00:00:00 2001
From: Bai Ping <ping.bai@nxp.com>
Date: Tue, 30 Aug 2016 13:01:29 +0800
Subject: [PATCH 1139/5242] MLK-13133-02 cpufreq: imx: Fix system hang when
 entring low bus mode on imx6ull

commit  8e1db6101571edc50ddd46d4dccb46c21fc6d129 from
https://source.codeaurora.org/external/imx/linux-imx.git

On i.MX6ULL, when the CPU freq is running at 198MHz or 396MHz, the system will
enter low bus mode if no device need high bus mode. The first time the system
entering low bus mode, CPU freq will be set to 24MHz, if cpufreq change the CPU
freq from 198MHz(396MHz) to 396MHz(198MHz), the CPU freq will be set to 198MHz or
396 MHz. At this time, if the CPU enter low power idle, system will hang.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/cpufreq/imx6q-cpufreq.c |   23 ++++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/drivers/cpufreq/imx6q-cpufreq.c b/drivers/cpufreq/imx6q-cpufreq.c
index 5781388..19dd599 100644
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@ -73,6 +73,7 @@ enum IMX6_CPUFREQ_CLKS {
 static u32 *imx6_soc_volt;
 static u32 soc_opp_count;
 static bool ignore_dc_reg;
+static bool low_power_run_support;
 
 static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
 {
@@ -114,8 +115,12 @@ static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
 	 * CPU freq is increasing, so need to ensure
 	 * that bus frequency is increased too.
 	 */
-	if (old_freq <= FREQ_396_MHZ && new_freq > FREQ_396_MHZ)
+	if (low_power_run_support) {
+		if (old_freq == freq_table[0].frequency)
+			request_bus_freq(BUS_FREQ_HIGH);
+	} else if (old_freq <= FREQ_396_MHZ && new_freq > FREQ_396_MHZ) {
 		request_bus_freq(BUS_FREQ_HIGH);
+	}
 
 	/* scaling up?  scale voltage before frequency */
 	if (new_freq > old_freq) {
@@ -236,8 +241,12 @@ static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
 	 * If CPU is dropped to the lowest level, release the need
 	 * for a high bus frequency.
 	 */
-	if (old_freq > FREQ_396_MHZ && new_freq <= FREQ_396_MHZ)
+	if (low_power_run_support) {
+		if (new_freq == freq_table[0].frequency)
+			release_bus_freq(BUS_FREQ_HIGH);
+	} else if (old_freq > FREQ_396_MHZ && new_freq <= FREQ_396_MHZ) {
 		release_bus_freq(BUS_FREQ_HIGH);
+	}
 
 	return 0;
 }
@@ -254,8 +263,12 @@ static int imx6q_cpufreq_init(struct cpufreq_policy *policy)
 		dev_err(cpu_dev, "imx6 cpufreq init failed!\n");
 		return ret;
 	}
-	if (policy->cur > FREQ_396_MHZ)
+	if (low_power_run_support && policy->cur > freq_table[0].frequency) {
 		request_bus_freq(BUS_FREQ_HIGH);
+	} else if (policy->cur > FREQ_396_MHZ) {
+		request_bus_freq(BUS_FREQ_HIGH);
+	}
+
 	return 0;
 }
 
@@ -474,6 +487,10 @@ static int imx6q_cpufreq_probe(struct platform_device *pdev)
 	if (i == 1)
 		soc_reg = arm_reg;
 
+	/* On i.MX6ULL, check the 24MHz low power run mode support */
+	low_power_run_support = of_property_read_bool(np, "fsl,low-power-run");
+
+
 	ret = dev_pm_opp_of_add_table(cpu_dev);
 	if (ret < 0) {
 		dev_err(cpu_dev, "failed to init OPP table: %d\n", ret);
-- 
1.7.9.5


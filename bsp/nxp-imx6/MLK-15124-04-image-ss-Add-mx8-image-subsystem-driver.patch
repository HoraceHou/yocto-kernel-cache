From 363d17ab5e62293a078fd2a1ebb67748b8cef399 Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Tue, 20 Jun 2017 15:37:16 +0800
Subject: [PATCH 1965/5242] MLK-15124-04: image ss: Add mx8 image subsystem
 driver

commit  f221f3648c7f9c2737ddaae8195ecdaee011276b from
https://source.codeaurora.org/external/imx/linux-imx.git

Add mxc media device driver.
Add mx8 isi device driver.
Add mx8 mipi csi device driver.
Add max9286 sensor driver.
mxc isi driver support CSC and scaling function.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/Kconfig              |    7 +
 drivers/media/platform/Makefile             |    1 +
 drivers/media/platform/imx8/Kconfig         |   29 +
 drivers/media/platform/imx8/Makefile        |    7 +
 drivers/media/platform/imx8/max9286.c       | 2918 +++++++++++++++++++++++++++
 drivers/media/platform/imx8/mxc-isi-cap.c   | 1339 ++++++++++++
 drivers/media/platform/imx8/mxc-isi-core.c  |  210 ++
 drivers/media/platform/imx8/mxc-isi-core.h  |  319 +++
 drivers/media/platform/imx8/mxc-isi-hw.c    |  557 +++++
 drivers/media/platform/imx8/mxc-isi-hw.h    |  483 +++++
 drivers/media/platform/imx8/mxc-media-dev.c |  603 ++++++
 drivers/media/platform/imx8/mxc-media-dev.h |  118 ++
 drivers/media/platform/imx8/mxc-mipi-csi2.c |  632 ++++++
 drivers/media/platform/imx8/mxc-mipi-csi2.h |  251 +++
 14 files changed, 7474 insertions(+)
 create mode 100644 drivers/media/platform/imx8/Kconfig
 create mode 100644 drivers/media/platform/imx8/Makefile
 create mode 100644 drivers/media/platform/imx8/max9286.c
 create mode 100644 drivers/media/platform/imx8/mxc-isi-cap.c
 create mode 100644 drivers/media/platform/imx8/mxc-isi-core.c
 create mode 100644 drivers/media/platform/imx8/mxc-isi-core.h
 create mode 100644 drivers/media/platform/imx8/mxc-isi-hw.c
 create mode 100644 drivers/media/platform/imx8/mxc-isi-hw.h
 create mode 100644 drivers/media/platform/imx8/mxc-media-dev.c
 create mode 100644 drivers/media/platform/imx8/mxc-media-dev.h
 create mode 100644 drivers/media/platform/imx8/mxc-mipi-csi2.c
 create mode 100644 drivers/media/platform/imx8/mxc-mipi-csi2.h

diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 752315a..5287108 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -144,6 +144,13 @@ config VIDEO_MXC_CAPTURE
 	---help---
 	  This is the video4linux2 capture driver based on i.MX video-in module.
 
+config VIDEO_MX8_CAPTURE
+	tristate "MX8 Video For Linux Video Capture"
+	depends on VIDEO_V4L2
+	---help---
+	  This is the video4linux2 capture driver based on i.MX8 module.
+
+source "drivers/media/platform/imx8/Kconfig"
 source "drivers/media/platform/mxc/capture/Kconfig"
 source "drivers/media/platform/mxc/output/Kconfig"
 source "drivers/media/platform/soc_camera/Kconfig"
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index b3eabd3..bfce73a 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_VIDEO_MXC_OUTPUT)		+= mxc/output/
 
 obj-$(CONFIG_VIDEO_MXC_CAPTURE)	+= mxc/capture/
 obj-$(CONFIG_VIDEO_MXC_OUTPUT)  += mxc/output/
+obj-$(CONFIG_VIDEO_MX8_CAPTURE)	+= imx8/
 
 obj-$(CONFIG_VIDEO_MEDIATEK_VPU)	+= mtk-vpu/
 
diff --git a/drivers/media/platform/imx8/Kconfig b/drivers/media/platform/imx8/Kconfig
new file mode 100644
index 0000000..c8f32f1
--- /dev/null
+++ b/drivers/media/platform/imx8/Kconfig
@@ -0,0 +1,29 @@
+if VIDEO_MX8_CAPTURE
+menu "IMX8 Camera ISI/MIPI Features support"
+
+config IMX8_MEDIA_DEVICE
+	tristate "IMX8 Media Device Driver"
+	select V4L2_FWNODE
+	default y
+
+config IMX8_CAPTURE_DRIVER
+	tristate "IMX8 Camera Controller"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	select V4L2_MEM2MEM_DEV
+	select VIDEOBUF2_DMA_CONTIG
+	default y
+
+config IMX8_MIPI_CSI2
+	tristate "IMX8 MIPI CSI2 Controller"
+	default y
+
+config GMSL_MAX9286
+        tristate "Maxim max9286 GMSL Deserializer Input support"
+	select SENSOR_OV10635
+        depends on I2C
+        ---help---
+          If you plan to use the max9286 GMSL Deserializer with your capture system, say Y here.
+
+endmenu
+endif #VIDEO_MX8_CAPTURE
+
diff --git a/drivers/media/platform/imx8/Makefile b/drivers/media/platform/imx8/Makefile
new file mode 100644
index 0000000..6b0f4cb
--- /dev/null
+++ b/drivers/media/platform/imx8/Makefile
@@ -0,0 +1,7 @@
+mxc-capture-objs := mxc-isi-core.o mxc-isi-cap.o mxc-isi-hw.o
+
+obj-$(CONFIG_IMX8_CAPTURE_DRIVER) += mxc-capture.o
+obj-$(CONFIG_IMX8_MIPI_CSI2) += mxc-mipi-csi2.o
+max9286_gmsl-objs := max9286.o
+obj-$(CONFIG_GMSL_MAX9286) += max9286_gmsl.o
+obj-$(CONFIG_IMX8_MEDIA_DEVICE) += mxc-media-dev.o
diff --git a/drivers/media/platform/imx8/max9286.c b/drivers/media/platform/imx8/max9286.c
new file mode 100644
index 0000000..a09fbc3
--- /dev/null
+++ b/drivers/media/platform/imx8/max9286.c
@@ -0,0 +1,2918 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/i2c.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <media/v4l2-subdev.h>
+
+#define MAX9271_MAX_SENSOR_NUM	4
+#define CAMERA_USES_15HZ
+
+#define ADDR_MAX9286		0x6A
+#define ADDR_MAX9271		0x40
+#define ADDR_MAX9271_ALL	(ADDR_MAX9271 + 5)  /* Broadcast address */
+#define ADDR_OV_SENSOR	0x30
+#define ADDR_AP_SENSOR	0x5D
+
+#define CONFIG_SENSOR_OV10635
+static unsigned int g_max9286_width = 1280;
+static unsigned int g_max9286_height = 800;
+
+#define MIPI_CSI2_SENS_VC0_PAD_SOURCE	0
+#define MIPI_CSI2_SENS_VC1_PAD_SOURCE	1
+#define MIPI_CSI2_SENS_VC2_PAD_SOURCE	2
+#define MIPI_CSI2_SENS_VC3_PAD_SOURCE	3
+#define MIPI_CSI2_SENS_VCX_PADS_NUM		4
+
+/*!
+ * Maintains the information on the current state of the sesor.
+ */
+struct imxdpu_videomode {
+	char name[64];		/* may not be needed */
+
+	uint32_t pixelclock;	/* Hz */
+
+	/* htotal (pixels) = hlen + hfp + hsync + hbp */
+	uint32_t hlen;
+	uint32_t hfp;
+	uint32_t hbp;
+	uint32_t hsync;
+
+	/* field0 - vtotal (lines) = vlen + vfp + vsync + vbp */
+	uint32_t vlen;
+	uint32_t vfp;
+	uint32_t vbp;
+	uint32_t vsync;
+
+	/* field1  */
+	uint32_t vlen1;
+	uint32_t vfp1;
+	uint32_t vbp1;
+	uint32_t vsync1;
+
+	uint32_t flags;
+
+	uint32_t format;
+	uint32_t dest_format; /*buffer format for capture*/
+
+	int16_t clip_top;
+	int16_t clip_left;
+	uint16_t clip_width;
+	uint16_t clip_height;
+
+};
+struct sensor_data {
+	struct v4l2_subdev	subdev;
+	struct media_pad pads[MIPI_CSI2_SENS_VCX_PADS_NUM];
+	struct i2c_client *i2c_client;
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_captureparm streamcap;
+	char running;
+
+	/* control settings */
+	int brightness;
+	int hue;
+	int contrast;
+	int saturation;
+	int red;
+	int green;
+	int blue;
+	int ae_mode;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int v_channel;
+	bool is_mipi;
+	struct imxdpu_videomode cap_mode;
+
+	unsigned int sensor_num;       /* sensor num connect max9271 */
+	unsigned char sensor_is_there; /* Bit 0~3 for 4 cameras, 0b1= is there; 0b0 = is not there */
+};
+
+#ifdef CONFIG_SENSOR_OV10635
+#define OV10635_REG_PID		0x300A
+#define OV10635_REG_VER		0x300B
+
+struct reg_value {
+	unsigned short reg_addr;
+	unsigned char val;
+	unsigned int delay_ms;
+};
+
+static struct reg_value ov10635_init_data[] = {
+	{ 0x0103, 0x01, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x300c, 0x61, 0 },
+	{ 0x301b, 0xff, 0 },
+	{ 0x301c, 0xff, 0 },
+	{ 0x301a, 0xff, 0 },
+	{ 0x3011, 0x42, 0 },
+	{ 0x6900, 0x0c, 0 },
+	{ 0x6901, 0x11, 0 },
+	{ 0x3503, 0x10, 0 },
+	{ 0x3025, 0x03, 0 },
+	{ 0x3003, 0x20, 0 },
+	{ 0x3004, 0x23, 0 },
+	{ 0x3005, 0x20, 0 },
+	{ 0x3006, 0x91, 0 },
+	{ 0x3600, 0x74, 0 },
+	{ 0x3601, 0x2b, 0 },
+	{ 0x3612, 0x00, 0 },
+	{ 0x3611, 0x67, 0 },
+	{ 0x3633, 0xca, 0 },
+	{ 0x3602, 0x2f, 0 },
+	{ 0x3603, 0x00, 0 },
+	{ 0x3630, 0x28, 0 },
+	{ 0x3631, 0x16, 0 },
+	{ 0x3714, 0x10, 0 },
+	{ 0x371d, 0x01, 0 },
+	{ 0x4300, 0x38, 0},
+	{ 0x3007, 0x01, 0 },
+	{ 0x3024, 0x01, 0 },  //YUV
+	{ 0x3020, 0x0b, 0 },
+	{ 0x3702, 0x10, 0 },  //0x20 for 96MHz
+	{ 0x3703, 0x24, 0 },  //0x48 for 96MHz
+	{ 0x3704, 0x19, 0 },
+	{ 0x3709, 0xa8, 0 },
+	{ 0x3709, 0xa8, 0 },
+	{ 0x370c, 0xc7, 0 },
+	{ 0x370d, 0x80, 0 },
+	{ 0x3712, 0x00, 0 },
+	{ 0x3713, 0x20, 0 },
+	{ 0x3715, 0x04, 0 },
+	{ 0x381d, 0x40, 0 },
+	{ 0x381c, 0x00, 0 },
+	{ 0x3822, 0x50, 0 },
+	{ 0x3824, 0x50, 0 },
+	{ 0x3815, 0x8c, 0 },
+	{ 0x3804, 0x05, 0 },
+	{ 0x3805, 0x1f, 0 },
+	{ 0x3800, 0x00, 0 },
+	{ 0x3801, 0x00, 0 },
+	{ 0x3806, 0x03, 0 },
+	{ 0x3807, 0x29, 0 },
+	{ 0x3802, 0x00, 0 },
+	{ 0x3803, 0x04, 0 },
+	{ 0x3808, 0x05, 0 },
+	{ 0x3809, 0x00, 0 },
+	{ 0x380a, 0x03, 0 },
+	{ 0x380b, 0x20, 0 },
+	{ 0x380c, 0x07, 0 },
+	{ 0x380d, 0x71, 0 },
+	{ 0x6e42, 0x03, 0 },
+	{ 0x6e43, 0x48, 0 },
+	{ 0x380e, 0x03, 0 },
+	{ 0x380f, 0x48, 0 },
+	{ 0x3813, 0x02, 0 },
+	{ 0x3811, 0x10, 0 },
+	{ 0x381f, 0x0c, 0 },
+	{ 0x3828, 0x03, 0 },
+	{ 0x3829, 0x10, 0 },
+	{ 0x382a, 0x10, 0 },
+	{ 0x382b, 0x10, 0 },
+	{ 0x3621, 0x64, 0 },
+	{ 0x5005, 0x08, 0 },
+	{ 0x56d5, 0x00, 0 },
+	{ 0x56d6, 0x80, 0 },
+	{ 0x56d7, 0x00, 0 },
+	{ 0x56d8, 0x00, 0 },
+	{ 0x56d9, 0x00, 0 },
+	{ 0x56da, 0x80, 0 },
+	{ 0x56db, 0x00, 0 },
+	{ 0x56dc, 0x00, 0 },
+	{ 0x56e8, 0x00, 0 },
+	{ 0x56e9, 0x7f, 0 },
+	{ 0x56ea, 0x00, 0 },
+	{ 0x56eb, 0x7f, 0 },
+	{ 0x5100, 0x00, 0 },
+	{ 0x5101, 0x80, 0 },
+	{ 0x5102, 0x00, 0 },
+	{ 0x5103, 0x80, 0 },
+	{ 0x5104, 0x00, 0 },
+	{ 0x5105, 0x80, 0 },
+	{ 0x5106, 0x00, 0 },
+	{ 0x5107, 0x80, 0 },
+	{ 0x5108, 0x00, 0 },
+	{ 0x5109, 0x00, 0 },
+	{ 0x510a, 0x00, 0 },
+	{ 0x510b, 0x00, 0 },
+	{ 0x510c, 0x00, 0 },
+	{ 0x510d, 0x00, 0 },
+	{ 0x510e, 0x00, 0 },
+	{ 0x510f, 0x00, 0 },
+	{ 0x5110, 0x00, 0 },
+	{ 0x5111, 0x80, 0 },
+	{ 0x5112, 0x00, 0 },
+	{ 0x5113, 0x80, 0 },
+	{ 0x5114, 0x00, 0 },
+	{ 0x5115, 0x80, 0 },
+	{ 0x5116, 0x00, 0 },
+	{ 0x5117, 0x80, 0 },
+	{ 0x5118, 0x00, 0 },
+	{ 0x5119, 0x00, 0 },
+	{ 0x511a, 0x00, 0 },
+	{ 0x511b, 0x00, 0 },
+	{ 0x511c, 0x00, 0 },
+	{ 0x511d, 0x00, 0 },
+	{ 0x511e, 0x00, 0 },
+	{ 0x511f, 0x00, 0 },
+	{ 0x56d0, 0x00, 0 },
+	{ 0x5006, 0x24, 0 },
+	{ 0x5608, 0x0d, 0 },
+	{ 0x52d7, 0x06, 0 },
+	{ 0x528d, 0x08, 0 },
+	{ 0x5293, 0x12, 0 },
+	{ 0x52d3, 0x12, 0 },
+	{ 0x5288, 0x06, 0 },
+	{ 0x5289, 0x20, 0 },
+	{ 0x52c8, 0x06, 0 },
+	{ 0x52c9, 0x20, 0 },
+	{ 0x52cd, 0x04, 0 },
+	{ 0x5381, 0x00, 0 },
+	{ 0x5382, 0xff, 0 },
+	{ 0x5589, 0x76, 0 },
+	{ 0x558a, 0x47, 0 },
+	{ 0x558b, 0xef, 0 },
+	{ 0x558c, 0xc9, 0 },
+	{ 0x558d, 0x49, 0 },
+	{ 0x558e, 0x30, 0 },
+	{ 0x558f, 0x67, 0 },
+	{ 0x5590, 0x3f, 0 },
+	{ 0x5591, 0xf0, 0 },
+	{ 0x5592, 0x10, 0 },
+	{ 0x55a2, 0x6d, 0 },
+	{ 0x55a3, 0x55, 0 },
+	{ 0x55a4, 0xc3, 0 },
+	{ 0x55a5, 0xb5, 0 },
+	{ 0x55a6, 0x43, 0 },
+	{ 0x55a7, 0x38, 0 },
+	{ 0x55a8, 0x5f, 0 },
+	{ 0x55a9, 0x4b, 0 },
+	{ 0x55aa, 0xf0, 0 },
+	{ 0x55ab, 0x10, 0 },
+	{ 0x5581, 0x52, 0 },
+	{ 0x5300, 0x01, 0 },
+	{ 0x5301, 0x00, 0 },
+	{ 0x5302, 0x00, 0 },
+	{ 0x5303, 0x0e, 0 },
+	{ 0x5304, 0x00, 0 },
+	{ 0x5305, 0x0e, 0 },
+	{ 0x5306, 0x00, 0 },
+	{ 0x5307, 0x36, 0 },
+	{ 0x5308, 0x00, 0 },
+	{ 0x5309, 0xd9, 0 },
+	{ 0x530a, 0x00, 0 },
+	{ 0x530b, 0x0f, 0 },
+	{ 0x530c, 0x00, 0 },
+	{ 0x530d, 0x2c, 0 },
+	{ 0x530e, 0x00, 0 },
+	{ 0x530f, 0x59, 0 },
+	{ 0x5310, 0x00, 0 },
+	{ 0x5311, 0x7b, 0 },
+	{ 0x5312, 0x00, 0 },
+	{ 0x5313, 0x22, 0 },
+	{ 0x5314, 0x00, 0 },
+	{ 0x5315, 0xd5, 0 },
+	{ 0x5316, 0x00, 0 },
+	{ 0x5317, 0x13, 0 },
+	{ 0x5318, 0x00, 0 },
+	{ 0x5319, 0x18, 0 },
+	{ 0x531a, 0x00, 0 },
+	{ 0x531b, 0x26, 0 },
+	{ 0x531c, 0x00, 0 },
+	{ 0x531d, 0xdc, 0 },
+	{ 0x531e, 0x00, 0 },
+	{ 0x531f, 0x02, 0 },
+	{ 0x5320, 0x00, 0 },
+	{ 0x5321, 0x24, 0 },
+	{ 0x5322, 0x00, 0 },
+	{ 0x5323, 0x56, 0 },
+	{ 0x5324, 0x00, 0 },
+	{ 0x5325, 0x85, 0 },
+	{ 0x5326, 0x00, 0 },
+	{ 0x5327, 0x20, 0 },
+	{ 0x5609, 0x01, 0 },
+	{ 0x560a, 0x40, 0 },
+	{ 0x560b, 0x01, 0 },
+	{ 0x560c, 0x40, 0 },
+	{ 0x560d, 0x00, 0 },
+	{ 0x560e, 0xfa, 0 },
+	{ 0x560f, 0x00, 0 },
+	{ 0x5610, 0xfa, 0 },
+	{ 0x5611, 0x02, 0 },
+	{ 0x5612, 0x80, 0 },
+	{ 0x5613, 0x02, 0 },
+	{ 0x5614, 0x80, 0 },
+	{ 0x5615, 0x01, 0 },
+	{ 0x5616, 0x2c, 0 },
+	{ 0x5617, 0x01, 0 },
+	{ 0x5618, 0x2c, 0 },
+	{ 0x563b, 0x01, 0 },
+	{ 0x563c, 0x01, 0 },
+	{ 0x563d, 0x01, 0 },
+	{ 0x563e, 0x01, 0 },
+	{ 0x563f, 0x03, 0 },
+	{ 0x5640, 0x03, 0 },
+	{ 0x5641, 0x03, 0 },
+	{ 0x5642, 0x05, 0 },
+	{ 0x5643, 0x09, 0 },
+	{ 0x5644, 0x05, 0 },
+	{ 0x5645, 0x05, 0 },
+	{ 0x5646, 0x05, 0 },
+	{ 0x5647, 0x05, 0 },
+	{ 0x5651, 0x00, 0 },
+	{ 0x5652, 0x80, 0 },
+	{ 0x521a, 0x01, 0 },
+	{ 0x521b, 0x03, 0 },
+	{ 0x521c, 0x06, 0 },
+	{ 0x521d, 0x0a, 0 },
+	{ 0x521e, 0x0e, 0 },
+	{ 0x521f, 0x12, 0 },
+	{ 0x5220, 0x16, 0 },
+	{ 0x5223, 0x02, 0 },
+	{ 0x5225, 0x04, 0 },
+	{ 0x5227, 0x08, 0 },
+	{ 0x5229, 0x0c, 0 },
+	{ 0x522b, 0x12, 0 },
+	{ 0x522d, 0x18, 0 },
+	{ 0x522f, 0x1e, 0 },
+	{ 0x5241, 0x04, 0 },
+	{ 0x5242, 0x01, 0 },
+	{ 0x5243, 0x03, 0 },
+	{ 0x5244, 0x06, 0 },
+	{ 0x5245, 0x0a, 0 },
+	{ 0x5246, 0x0e, 0 },
+	{ 0x5247, 0x12, 0 },
+	{ 0x5248, 0x16, 0 },
+	{ 0x524a, 0x03, 0 },
+	{ 0x524c, 0x04, 0 },
+	{ 0x524e, 0x08, 0 },
+	{ 0x5250, 0x0c, 0 },
+	{ 0x5252, 0x12, 0 },
+	{ 0x5254, 0x18, 0 },
+	{ 0x5256, 0x1e, 0 },
+	{ 0x4606, 0x07, 0 },
+	{ 0x4607, 0x71, 0 },
+	{ 0x460a, 0x02, 0 },
+	{ 0x460b, 0x70, 0 },
+	{ 0x460c, 0x00, 0 },
+	{ 0x4620, 0x0e, 0 },
+	{ 0x4700, 0x04, 0 },
+	{ 0x4701, 0x00, 0 },
+	{ 0x4702, 0x01, 0 },
+	//                  0x04, 0x47, 0x03, 0xF1,
+	{ 0x4004, 0x04, 0 },
+	{ 0x4005, 0x18, 0 },
+	{ 0x4001, 0x06, 0 },
+	{ 0x4050, 0x22, 0 },
+	{ 0x4051, 0x24, 0 },
+	{ 0x4052, 0x02, 0 },
+	{ 0x4057, 0x9c, 0 },
+	{ 0x405a, 0x00, 0 },
+	{ 0x4202, 0x02, 0 },
+	{ 0x3023, 0x10, 0 },
+	{ 0x0100, 0x01, 0 },
+	{ 0x0100, 0x01, 0 },
+	{ 0x6f10, 0x07, 0 },
+	{ 0x6f11, 0x82, 0 },
+	{ 0x6f12, 0x04, 0 },
+	{ 0x6f13, 0x00, 0 },
+	{ 0x6f14, 0x1f, 0 },
+	{ 0x6f15, 0xdd, 0 },
+	{ 0x6f16, 0x04, 0 },
+	{ 0x6f17, 0x04, 0 },
+	{ 0x6f18, 0x36, 0 },
+	{ 0x6f19, 0x66, 0 },
+	{ 0x6f1a, 0x04, 0 },
+	{ 0x6f1b, 0x08, 0 },
+	{ 0x6f1c, 0x0c, 0 },
+	{ 0x6f1d, 0xe7, 0 },
+	{ 0x6f1e, 0x04, 0 },
+	{ 0x6f1f, 0x0c, 0 },
+	{ 0xd000, 0x19, 0 },
+	{ 0xd001, 0xa0, 0 },
+	{ 0xd002, 0x00, 0 },
+	{ 0xd003, 0x01, 0 },
+	{ 0xd004, 0xa9, 0 },
+	{ 0xd005, 0xad, 0 },
+	{ 0xd006, 0x10, 0 },
+	{ 0xd007, 0x40, 0 },
+	{ 0xd008, 0x44, 0 },
+	{ 0xd009, 0x00, 0 },
+	{ 0xd00a, 0x68, 0 },
+	{ 0xd00b, 0x00, 0 },
+	{ 0xd00c, 0x15, 0 },
+	{ 0xd00d, 0x00, 0 },
+	{ 0xd00e, 0x00, 0 },
+	{ 0xd00f, 0x00, 0 },
+	{ 0xd010, 0x19, 0 },
+	{ 0xd011, 0xa0, 0 },
+	{ 0xd012, 0x00, 0 },
+	{ 0xd013, 0x01, 0 },
+	{ 0xd014, 0xa9, 0 },
+	{ 0xd015, 0xad, 0 },
+	{ 0xd016, 0x13, 0 },
+	{ 0xd017, 0xd0, 0 },
+	{ 0xd018, 0x44, 0 },
+	{ 0xd019, 0x00, 0 },
+	{ 0xd01a, 0x68, 0 },
+	{ 0xd01b, 0x00, 0 },
+	{ 0xd01c, 0x15, 0 },
+	{ 0xd01d, 0x00, 0 },
+	{ 0xd01e, 0x00, 0 },
+	{ 0xd01f, 0x00, 0 },
+	{ 0xd020, 0x19, 0 },
+	{ 0xd021, 0xa0, 0 },
+	{ 0xd022, 0x00, 0 },
+	{ 0xd023, 0x01, 0 },
+	{ 0xd024, 0xa9, 0 },
+	{ 0xd025, 0xad, 0 },
+	{ 0xd026, 0x14, 0 },
+	{ 0xd027, 0xb8, 0 },
+	{ 0xd028, 0x44, 0 },
+	{ 0xd029, 0x00, 0 },
+	{ 0xd02a, 0x68, 0 },
+	{ 0xd02b, 0x00, 0 },
+	{ 0xd02c, 0x15, 0 },
+	{ 0xd02d, 0x00, 0 },
+	{ 0xd02e, 0x00, 0 },
+	{ 0xd02f, 0x00, 0 },
+	{ 0xd030, 0x19, 0 },
+	{ 0xd031, 0xa0, 0 },
+	{ 0xd032, 0x00, 0 },
+	{ 0xd033, 0x01, 0 },
+	{ 0xd034, 0xa9, 0 },
+	{ 0xd035, 0xad, 0 },
+	{ 0xd036, 0x14, 0 },
+	{ 0xd037, 0xdc, 0 },
+	{ 0xd038, 0x44, 0 },
+	{ 0xd039, 0x00, 0 },
+	{ 0xd03a, 0x68, 0 },
+	{ 0xd03b, 0x00, 0 },
+	{ 0xd03c, 0x15, 0 },
+	{ 0xd03d, 0x00, 0 },
+	{ 0xd03e, 0x00, 0 },
+	{ 0xd03f, 0x00, 0 },
+	{ 0xd040, 0x9c, 0 },
+	{ 0xd041, 0x21, 0 },
+	{ 0xd042, 0xff, 0 },
+	{ 0xd043, 0xe4, 0 },
+	{ 0xd044, 0xd4, 0 },
+	{ 0xd045, 0x01, 0 },
+	{ 0xd046, 0x48, 0 },
+	{ 0xd047, 0x00, 0 },
+	{ 0xd048, 0xd4, 0 },
+	{ 0xd049, 0x01, 0 },
+	{ 0xd04a, 0x50, 0 },
+	{ 0xd04b, 0x04, 0 },
+	{ 0xd04c, 0xd4, 0 },
+	{ 0xd04d, 0x01, 0 },
+	{ 0xd04e, 0x60, 0 },
+	{ 0xd04f, 0x08, 0 },
+	{ 0xd050, 0xd4, 0 },
+	{ 0xd051, 0x01, 0 },
+	{ 0xd052, 0x70, 0 },
+	{ 0xd053, 0x0c, 0 },
+	{ 0xd054, 0xd4, 0 },
+	{ 0xd055, 0x01, 0 },
+	{ 0xd056, 0x80, 0 },
+	{ 0xd057, 0x10, 0 },
+	{ 0xd058, 0x19, 0 },
+	{ 0xd059, 0xc0, 0 },
+	{ 0xd05a, 0x00, 0 },
+	{ 0xd05b, 0x01, 0 },
+	{ 0xd05c, 0xa9, 0 },
+	{ 0xd05d, 0xce, 0 },
+	{ 0xd05e, 0x02, 0 },
+	{ 0xd05f, 0xa4, 0 },
+	{ 0xd060, 0x9c, 0 },
+	{ 0xd061, 0xa0, 0 },
+	{ 0xd062, 0x00, 0 },
+	{ 0xd063, 0x00, 0 },
+	{ 0xd064, 0x84, 0 },
+	{ 0xd065, 0x6e, 0 },
+	{ 0xd066, 0x00, 0 },
+	{ 0xd067, 0x00, 0 },
+	{ 0xd068, 0xd8, 0 },
+	{ 0xd069, 0x03, 0 },
+	{ 0xd06a, 0x28, 0 },
+	{ 0xd06b, 0x76, 0 },
+	{ 0xd06c, 0x1a, 0 },
+	{ 0xd06d, 0x00, 0 },
+	{ 0xd06e, 0x00, 0 },
+	{ 0xd06f, 0x01, 0 },
+	{ 0xd070, 0xaa, 0 },
+	{ 0xd071, 0x10, 0 },
+	{ 0xd072, 0x03, 0 },
+	{ 0xd073, 0xf0, 0 },
+	{ 0xd074, 0x18, 0 },
+	{ 0xd075, 0x60, 0 },
+	{ 0xd076, 0x00, 0 },
+	{ 0xd077, 0x01, 0 },
+	{ 0xd078, 0xa8, 0 },
+	{ 0xd079, 0x63, 0 },
+	{ 0xd07a, 0x07, 0 },
+	{ 0xd07b, 0x80, 0 },
+	{ 0xd07c, 0xe0, 0 },
+	{ 0xd07d, 0xa0, 0 },
+	{ 0xd07e, 0x00, 0 },
+	{ 0xd07f, 0x04, 0 },
+	{ 0xd080, 0x18, 0 },
+	{ 0xd081, 0xc0, 0 },
+	{ 0xd082, 0x00, 0 },
+	{ 0xd083, 0x00, 0 },
+	{ 0xd084, 0xa8, 0 },
+	{ 0xd085, 0xc6, 0 },
+	{ 0xd086, 0x00, 0 },
+	{ 0xd087, 0x00, 0 },
+	{ 0xd088, 0x8c, 0 },
+	{ 0xd089, 0x63, 0 },
+	{ 0xd08a, 0x00, 0 },
+	{ 0xd08b, 0x00, 0 },
+	{ 0xd08c, 0xd4, 0 },
+	{ 0xd08d, 0x01, 0 },
+	{ 0xd08e, 0x28, 0 },
+	{ 0xd08f, 0x14, 0 },
+	{ 0xd090, 0xd4, 0 },
+	{ 0xd091, 0x01, 0 },
+	{ 0xd092, 0x30, 0 },
+	{ 0xd093, 0x18, 0 },
+	{ 0xd094, 0x07, 0 },
+	{ 0xd095, 0xff, 0 },
+	{ 0xd096, 0xf8, 0 },
+	{ 0xd097, 0xfd, 0 },
+	{ 0xd098, 0x9c, 0 },
+	{ 0xd099, 0x80, 0 },
+	{ 0xd09a, 0x00, 0 },
+	{ 0xd09b, 0x03, 0 },
+	{ 0xd09c, 0xa5, 0 },
+	{ 0xd09d, 0x6b, 0 },
+	{ 0xd09e, 0x00, 0 },
+	{ 0xd09f, 0xff, 0 },
+	{ 0xd0a0, 0x18, 0 },
+	{ 0xd0a1, 0xc0, 0 },
+	{ 0xd0a2, 0x00, 0 },
+	{ 0xd0a3, 0x01, 0 },
+	{ 0xd0a4, 0xa8, 0 },
+	{ 0xd0a5, 0xc6, 0 },
+	{ 0xd0a6, 0x01, 0 },
+	{ 0xd0a7, 0x02, 0 },
+	{ 0xd0a8, 0xe1, 0 },
+	{ 0xd0a9, 0x6b, 0 },
+	{ 0xd0aa, 0x58, 0 },
+	{ 0xd0ab, 0x00, 0 },
+	{ 0xd0ac, 0x84, 0 },
+	{ 0xd0ad, 0x8e, 0 },
+	{ 0xd0ae, 0x00, 0 },
+	{ 0xd0af, 0x00, 0 },
+	{ 0xd0b0, 0xe1, 0 },
+	{ 0xd0b1, 0x6b, 0 },
+	{ 0xd0b2, 0x30, 0 },
+	{ 0xd0b3, 0x00, 0 },
+	{ 0xd0b4, 0x98, 0 },
+	{ 0xd0b5, 0xb0, 0 },
+	{ 0xd0b6, 0x00, 0 },
+	{ 0xd0b7, 0x00, 0 },
+	{ 0xd0b8, 0x8c, 0 },
+	{ 0xd0b9, 0x64, 0 },
+	{ 0xd0ba, 0x00, 0 },
+	{ 0xd0bb, 0x6e, 0 },
+	{ 0xd0bc, 0xe5, 0 },
+	{ 0xd0bd, 0xa5, 0 },
+	{ 0xd0be, 0x18, 0 },
+	{ 0xd0bf, 0x00, 0 },
+	{ 0xd0c0, 0x10, 0 },
+	{ 0xd0c1, 0x00, 0 },
+	{ 0xd0c2, 0x00, 0 },
+	{ 0xd0c3, 0x06, 0 },
+	{ 0xd0c4, 0x95, 0 },
+	{ 0xd0c5, 0x8b, 0 },
+	{ 0xd0c6, 0x00, 0 },
+	{ 0xd0c7, 0x00, 0 },
+	{ 0xd0c8, 0x94, 0 },
+	{ 0xd0c9, 0xa4, 0 },
+	{ 0xd0ca, 0x00, 0 },
+	{ 0xd0cb, 0x70, 0 },
+	{ 0xd0cc, 0xe5, 0 },
+	{ 0xd0cd, 0x65, 0 },
+	{ 0xd0ce, 0x60, 0 },
+	{ 0xd0cf, 0x00, 0 },
+	{ 0xd0d0, 0x0c, 0 },
+	{ 0xd0d1, 0x00, 0 },
+	{ 0xd0d2, 0x00, 0 },
+	{ 0xd0d3, 0x62, 0 },
+	{ 0xd0d4, 0x15, 0 },
+	{ 0xd0d5, 0x00, 0 },
+	{ 0xd0d6, 0x00, 0 },
+	{ 0xd0d7, 0x00, 0 },
+	{ 0xd0d8, 0x18, 0 },
+	{ 0xd0d9, 0x60, 0 },
+	{ 0xd0da, 0x80, 0 },
+	{ 0xd0db, 0x06, 0 },
+	{ 0xd0dc, 0xa8, 0 },
+	{ 0xd0dd, 0x83, 0 },
+	{ 0xd0de, 0x38, 0 },
+	{ 0xd0df, 0x29, 0 },
+	{ 0xd0e0, 0xa8, 0 },
+	{ 0xd0e1, 0xe3, 0 },
+	{ 0xd0e2, 0x40, 0 },
+	{ 0xd0e3, 0x08, 0},
+	{ 0xd0e4, 0x8c, 0 },
+	{ 0xd0e5, 0x84, 0},
+	{ 0xd0e6, 0x00, 0 },
+	{ 0xd0e7, 0x00, 0 },
+	{ 0xd0e8, 0xa8, 0},
+	{ 0xd0e9, 0xa3, 0},
+	{ 0xd0ea, 0x40, 0},
+	{ 0xd0eb, 0x09, 0},
+	{ 0xd0ec, 0xa8, 0},
+	{ 0xd0ed, 0xc3, 0},
+	{ 0xd0ee, 0x38, 0},
+	{ 0xd0ef, 0x2a, 0},
+	{ 0xd0f0, 0xd8, 0},
+	{ 0xd0f1, 0x07, 0},
+	{ 0xd0f2, 0x20, 0},
+	{ 0xd0f3, 0x00, 0 },
+	{ 0xd0f4, 0x8c, 0},
+	{ 0xd0f5, 0x66, 0},
+	{ 0xd0f6, 0x00, 0 },
+	{ 0xd0f7, 0x00, 0},
+	{ 0xd0f8, 0xd8, 0},
+	{ 0xd0f9, 0x05, 0},
+	{ 0xd0fa, 0x18, 0},
+	{ 0xd0fb, 0x00, 0},
+	{ 0xd0fc, 0x18, 0},
+	{ 0xd0fd, 0x60, 0},
+	{ 0xd0fe, 0x00, 0 },
+	{ 0xd0ff, 0x01, 0},
+	{ 0xd100, 0x98, 0},
+	{ 0xd101, 0x90, 0},
+	{ 0xd102, 0x00, 0 },
+	{ 0xd103, 0x00, 0 },
+	{ 0xd104, 0x84, 0},
+	{ 0xd105, 0xae, 0},
+	{ 0xd106, 0x00, 0},
+	{ 0xd107, 0x00, 0},
+	{ 0xd108, 0xa8, 0},
+	{ 0xd109, 0x63, 0},
+	{ 0xd10a, 0x06, 0},
+	{ 0xd10b, 0x4c, 0},
+	{ 0xd10c, 0x9c, 0},
+	{ 0xd10d, 0xc0, 0},
+	{ 0xd10e, 0x00, 0 },
+	{ 0xd10f, 0x00, 0 },
+	{ 0xd110, 0xd8, 0},
+	{ 0xd111, 0x03, 0},
+	{ 0xd112, 0x30, 0},
+	{ 0xd113, 0x00, 0},
+	{ 0xd114, 0x8c, 0},
+	{ 0xd115, 0x65, 0},
+	{ 0xd116, 0x00, 0},
+	{ 0xd117, 0x6e, 0},
+	{ 0xd118, 0xe5, 0},
+	{ 0xd119, 0x84, 0},
+	{ 0xd11a, 0x18, 0 },
+	{ 0xd11b, 0x00, 0 },
+	{ 0xd11c, 0x10, 0},
+	{ 0xd11d, 0x00, 0},
+	{ 0xd11e, 0x00, 0},
+	{ 0xd11f, 0x07, 0},
+	{ 0xd120, 0x18, 0},
+	{ 0xd121, 0x80, 0},
+	{ 0xd122, 0x80, 0},
+	{ 0xd123, 0x06, 0},
+	{ 0xd124, 0x94, 0},
+	{ 0xd125, 0x65, 0},
+	{ 0xd126, 0x00, 0},
+	{ 0xd127, 0x70, 0},
+	{ 0xd128, 0xe5, 0},
+	{ 0xd129, 0x43, 0},
+	{ 0xd12a, 0x60, 0},
+	{ 0xd12b, 0x00, 0 },
+	{ 0xd12c, 0x0c, 0},
+	{ 0xd12d, 0x00, 0},
+	{ 0xd12e, 0x00, 0 },
+	{ 0xd12f, 0x3e, 0},
+	{ 0xd130, 0xa8, 0},
+	{ 0xd131, 0x64, 0},
+	{ 0xd132, 0x38, 0},
+	{ 0xd133, 0x24, 0},
+	{ 0xd134, 0x18, 0},
+	{ 0xd135, 0x80, 0 },
+	{ 0xd136, 0x80, 0},
+	{ 0xd137, 0x06, 0},
+	{ 0xd138, 0xa8, 0 },
+	{ 0xd139, 0x64, 0},
+	{ 0xd13a, 0x38, 0 },
+	{ 0xd13b, 0x24, 0},
+	{ 0xd13c, 0x8c, 0},
+	{ 0xd13d, 0x63, 0},
+	{ 0xd13e, 0x00, 0},
+	{ 0xd13f, 0x00, 0},
+	{ 0xd140, 0xa4, 0},
+	{ 0xd141, 0x63, 0},
+	{ 0xd142, 0x00, 0},
+	{ 0xd143, 0x40, 0},
+	{ 0xd144, 0xbc, 0},
+	{ 0xd145, 0x23, 0},
+	{ 0xd146, 0x00, 0},
+	{ 0xd147, 0x00, 0},
+	{ 0xd148, 0x0c, 0},
+	{ 0xd149, 0x00, 0},
+	{ 0xd14a, 0x00, 0 },
+	{ 0xd14b, 0x2a, 0},
+	{ 0xd14c, 0xa8, 0},
+	{ 0xd14d, 0x64, 0},
+	{ 0xd14e, 0x6e, 0},
+	{ 0xd14f, 0x44, 0},
+	{ 0xd150, 0x19, 0},
+	{ 0xd151, 0x00, 0},
+	{ 0xd152, 0x80, 0},
+	{ 0xd153, 0x06, 0},
+	{ 0xd154, 0xa8, 0},
+	{ 0xd155, 0xe8, 0},
+	{ 0xd156, 0x3d, 0},
+	{ 0xd157, 0x05, 0},
+	{ 0xd158, 0x8c, 0},
+	{ 0xd159, 0x67, 0},
+	{ 0xd15a, 0x00, 0 },
+	{ 0xd15b, 0x00, 0},
+	{ 0xd15c, 0xb8, 0},
+	{ 0xd15d, 0x63, 0},
+	{ 0xd15e, 0x00, 0 },
+	{ 0xd15f, 0x18, 0},
+	{ 0xd160, 0xb8, 0},
+	{ 0xd161, 0x63, 0},
+	{ 0xd162, 0x00, 0 },
+	{ 0xd163, 0x98, 0},
+	{ 0xd164, 0xbc, 0 },
+	{ 0xd165, 0x03, 0 },
+	{ 0xd166, 0x00, 0 },
+	{ 0xd167, 0x00, 0 },
+	{ 0xd168, 0x10, 0 },
+	{ 0xd169, 0x00, 0 },
+	{ 0xd16a, 0x00, 0 },
+	{ 0xd16b, 0x10, 0},
+	{ 0xd16c, 0xa9, 0},
+	{ 0xd16d, 0x48, 0},
+	{ 0xd16e, 0x67, 0},
+	{ 0xd16f, 0x02, 0 },
+	{ 0xd170, 0xb8, 0},
+	{ 0xd171, 0xa3, 0},
+	{ 0xd172, 0x00, 0 },
+	{ 0xd173, 0x19, 0},
+	{ 0xd174, 0x8c, 0 },
+	{ 0xd175, 0x8a, 0},
+	{ 0xd176, 0x00, 0 },
+	{ 0xd177, 0x00, 0 },
+	{ 0xd178, 0xa9, 0},
+	{ 0xd179, 0x68, 0},
+	{ 0xd17a, 0x67, 0},
+	{ 0xd17b, 0x03, 0},
+	{ 0xd17c, 0xb8, 0},
+	{ 0xd17d, 0xc4, 0},
+	{ 0xd17e, 0x00, 0 },
+	{ 0xd17f, 0x08, 0},
+	{ 0xd180, 0x8c, 0},
+	{ 0xd181, 0x6b, 0},
+	{ 0xd182, 0x00, 0},
+	{ 0xd183, 0x00, 0},
+	{ 0xd184, 0xb8, 0},
+	{ 0xd185, 0x85, 0},
+	{ 0xd186, 0x00, 0 },
+	{ 0xd187, 0x98, 0},
+	{ 0xd188, 0xe0, 0},
+	{ 0xd189, 0x63, 0},
+	{ 0xd18a, 0x30, 0},
+	{ 0xd18b, 0x04, 0},
+	{ 0xd18c, 0xe0, 0},
+	{ 0xd18d, 0x64, 0},
+	{ 0xd18e, 0x18, 0},
+	{ 0xd18f, 0x00, 0},
+	{ 0xd190, 0xa4, 0},
+	{ 0xd191, 0x83, 0},
+	{ 0xd192, 0xff, 0},
+	{ 0xd193, 0xff, 0},
+	{ 0xd194, 0xb8, 0},
+	{ 0xd195, 0x64, 0},
+	{ 0xd196, 0x00, 0 },
+	{ 0xd197, 0x48, 0},
+	{ 0xd198, 0xd8, 0},
+	{ 0xd199, 0x0a, 0},
+	{ 0xd19a, 0x18, 0},
+	{ 0xd19b, 0x00, 0},
+	{ 0xd19c, 0xd8, 0},
+	{ 0xd19d, 0x0b, 0},
+	{ 0xd19e, 0x20, 0},
+	{ 0xd19f, 0x00, 0},
+	{ 0xd1a0, 0x9c, 0},
+	{ 0xd1a1, 0x60, 0},
+	{ 0xd1a2, 0x00, 0},
+	{ 0xd1a3, 0x00, 0},
+	{ 0xd1a4, 0xd8, 0},
+	{ 0xd1a5, 0x07, 0},
+	{ 0xd1a6, 0x18, 0},
+	{ 0xd1a7, 0x00, 0 },
+	{ 0xd1a8, 0xa8, 0 },
+	{ 0xd1a9, 0x68, 0},
+	{ 0xd1aa, 0x38, 0 },
+	{ 0xd1ab, 0x22, 0},
+	{ 0xd1ac, 0x9c, 0},
+	{ 0xd1ad, 0x80, 0},
+	{ 0xd1ae, 0x00, 0},
+	{ 0xd1af, 0x70, 0},
+	{ 0xd1b0, 0xa8, 0},
+	{ 0xd1b1, 0xe8, 0},
+	{ 0xd1b2, 0x38, 0},
+	{ 0xd1b3, 0x43, 0},
+	{ 0xd1b4, 0xd8, 0},
+	{ 0xd1b5, 0x03, 0},
+	{ 0xd1b6, 0x20, 0},
+	{ 0xd1b7, 0x00, 0 },
+	{ 0xd1b8, 0x9c, 0},
+	{ 0xd1b9, 0xa0, 0},
+	{ 0xd1ba, 0x00, 0},
+	{ 0xd1bb, 0x00, 0},
+	{ 0xd1bc, 0xa8, 0},
+	{ 0xd1bd, 0xc8, 0},
+	{ 0xd1be, 0x38, 0},
+	{ 0xd1bf, 0x42, 0},
+	{ 0xd1c0, 0x8c, 0 },
+	{ 0xd1c1, 0x66, 0},
+	{ 0xd1c2, 0x00, 0 },
+	{ 0xd1c3, 0x00, 0 },
+	{ 0xd1c4, 0x9c, 0},
+	{ 0xd1c5, 0xa5, 0},
+	{ 0xd1c6, 0x00, 0 },
+	{ 0xd1c7, 0x01, 0},
+	{ 0xd1c8, 0xb8, 0},
+	{ 0xd1c9, 0x83, 0},
+	{ 0xd1ca, 0x00, 0 },
+	{ 0xd1cb, 0x08, 0},
+	{ 0xd1cc, 0xa4, 0},
+	{ 0xd1cd, 0xa5, 0},
+	{ 0xd1ce, 0x00, 0},
+	{ 0xd1cf, 0xff, 0},
+	{ 0xd1d0, 0x8c, 0},
+	{ 0xd1d1, 0x67, 0},
+	{ 0xd1d2, 0x00, 0},
+	{ 0xd1d3, 0x00, 0},
+	{ 0xd1d4, 0xe0, 0},
+	{ 0xd1d5, 0x63, 0},
+	{ 0xd1d6, 0x20, 0},
+	{ 0xd1d7, 0x00, 0},
+	{ 0xd1d8, 0xa4, 0},
+	{ 0xd1d9, 0x63, 0 },
+	{ 0xd1da, 0xff, 0},
+	{ 0xd1db, 0xff, 0},
+	{ 0xd1dc, 0xbc, 0},
+	{ 0xd1dd, 0x43, 0},
+	{ 0xd1de, 0x00, 0},
+	{ 0xd1df, 0x07, 0},
+	{ 0xd1e0, 0x0c, 0},
+	{ 0xd1e1, 0x00, 0},
+	{ 0xd1e2, 0x00, 0},
+	{ 0xd1e3, 0x5b, 0},
+	{ 0xd1e4, 0xbc, 0},
+	{ 0xd1e5, 0x05, 0 },
+	{ 0xd1e6, 0x00, 0},
+	{ 0xd1e7, 0x02, 0},
+	{ 0xd1e8, 0x03, 0},
+	{ 0xd1e9, 0xff, 0},
+	{ 0xd1ea, 0xff, 0},
+	{ 0xd1eb, 0xf6, 0},
+	{ 0xd1ec, 0x9c, 0},
+	{ 0xd1ed, 0xa0, 0},
+	{ 0xd1ee, 0x00, 0},
+	{ 0xd1ef, 0x00, 0},
+	{ 0xd1f0, 0xa8, 0},
+	{ 0xd1f1, 0xa4, 0},
+	{ 0xd1f2, 0x55, 0},
+	{ 0xd1f3, 0x86, 0},
+	{ 0xd1f4, 0x8c, 0},
+	{ 0xd1f5, 0x63, 0},
+	{ 0xd1f6, 0x00, 0},
+	{ 0xd1f7, 0x00, 0},
+	{ 0xd1f8, 0xa8, 0},
+	{ 0xd1f9, 0xc4, 0},
+	{ 0xd1fa, 0x6e, 0},
+	{ 0xd1fb, 0x45, 0},
+	{ 0xd1fc, 0xa8, 0},
+	{ 0xd1fd, 0xe4, 0},
+	{ 0xd1fe, 0x55, 0},
+	{ 0xd1ff, 0x87, 0},
+	{ 0xd200, 0xd8, 0},
+	{ 0xd201, 0x05, 0},
+	{ 0xd202, 0x18, 0},
+	{ 0xd203, 0x00, 0},
+	{ 0xd204, 0x8c, 0},
+	{ 0xd205, 0x66, 0},
+	{ 0xd206, 0x00, 0},
+	{ 0xd207, 0x00, 0},
+	{ 0xd208, 0xa8, 0 },
+	{ 0xd209, 0xa4, 0},
+	{ 0xd20a, 0x6e, 0 },
+	{ 0xd20b, 0x46, 0},
+	{ 0xd20c, 0xd8, 0},
+	{ 0xd20d, 0x07, 0},
+	{ 0xd20e, 0x18, 0},
+	{ 0xd20f, 0x00, 0},
+	{ 0xd210, 0xa8, 0},
+	{ 0xd211, 0x84, 0 },
+	{ 0xd212, 0x55, 0},
+	{ 0xd213, 0x88, 0},
+	{ 0xd214, 0x8c, 0},
+	{ 0xd215, 0x65, 0},
+	{ 0xd216, 0x00, 0},
+	{ 0xd217, 0x00, 0},
+	{ 0xd218, 0xd8, 0},
+	{ 0xd219, 0x04, 0},
+	{ 0xd21a, 0x18, 0},
+	{ 0xd21b, 0x00, 0},
+	{ 0xd21c, 0x03, 0},
+	{ 0xd21d, 0xff, 0},
+	{ 0xd21e, 0xff, 0},
+	{ 0xd21f, 0xce, 0},
+	{ 0xd220, 0x19, 0},
+	{ 0xd221, 0x00, 0},
+	{ 0xd222, 0x80, 0},
+	{ 0xd223, 0x06, 0},
+	{ 0xd224, 0x8c, 0},
+	{ 0xd225, 0x63, 0},
+	{ 0xd226, 0x00, 0},
+	{ 0xd227, 0x00, 0 },
+	{ 0xd228, 0xa4, 0},
+	{ 0xd229, 0x63, 0},
+	{ 0xd22a, 0x00, 0},
+	{ 0xd22b, 0x40, 0},
+	{ 0xd22c, 0xbc, 0},
+	{ 0xd22d, 0x23, 0},
+	{ 0xd22e, 0x00, 0 },
+	{ 0xd22f, 0x00, 0 },
+	{ 0xd230, 0x13, 0},
+	{ 0xd231, 0xff, 0},
+	{ 0xd232, 0xff, 0 },
+	{ 0xd233, 0xc8, 0},
+	{ 0xd234, 0x9d, 0},
+	{ 0xd235, 0x00, 0},
+	{ 0xd236, 0x00, 0},
+	{ 0xd237, 0x40, 0},
+	{ 0xd238, 0xa8, 0},
+	{ 0xd239, 0x64, 0},
+	{ 0xd23a, 0x55, 0},
+	{ 0xd23b, 0x86, 0},
+	{ 0xd23c, 0xa8, 0 },
+	{ 0xd23d, 0xa4, 0},
+	{ 0xd23e, 0x55, 0},
+	{ 0xd23f, 0x87, 0},
+	{ 0xd240, 0xd8, 0},
+	{ 0xd241, 0x03, 0},
+	{ 0xd242, 0x40, 0},
+	{ 0xd243, 0x00, 0},
+	{ 0xd244, 0xa8, 0},
+	{ 0xd245, 0x64, 0},
+	{ 0xd246, 0x55, 0},
+	{ 0xd247, 0x88, 0},
+	{ 0xd248, 0xd8, 0},
+	{ 0xd249, 0x05, 0},
+	{ 0xd24a, 0x40, 0},
+	{ 0xd24b, 0x00, 0},
+	{ 0xd24c, 0xd8, 0},
+	{ 0xd24d, 0x03, 0},
+	{ 0xd24e, 0x40, 0},
+	{ 0xd24f, 0x00, 0 },
+	{ 0xd250, 0x03, 0},
+	{ 0xd251, 0xff, 0 },
+	{ 0xd252, 0xff, 0},
+	{ 0xd253, 0xc1, 0},
+	{ 0xd254, 0x19, 0},
+	{ 0xd255, 0x00, 0 },
+	{ 0xd256, 0x80, 0},
+	{ 0xd257, 0x06, 0},
+	{ 0xd258, 0x94, 0},
+	{ 0xd259, 0x84, 0},
+	{ 0xd25a, 0x00, 0},
+	{ 0xd25b, 0x72, 0},
+	{ 0xd25c, 0xe5, 0},
+	{ 0xd25d, 0xa4, 0},
+	{ 0xd25e, 0x60, 0},
+	{ 0xd25f, 0x00, 0},
+	{ 0xd260, 0x0c, 0},
+	{ 0xd261, 0x00, 0},
+	{ 0xd262, 0x00, 0 },
+	{ 0xd263, 0x3f, 0},
+	{ 0xd264, 0x9d, 0},
+	{ 0xd265, 0x60, 0},
+	{ 0xd266, 0x01, 0},
+	{ 0xd267, 0x00, 0},
+	{ 0xd268, 0x85, 0},
+	{ 0xd269, 0x4e, 0},
+	{ 0xd26a, 0x00, 0 },
+	{ 0xd26b, 0x00, 0},
+	{ 0xd26c, 0x98, 0},
+	{ 0xd26d, 0x70, 0},
+	{ 0xd26e, 0x00, 0 },
+	{ 0xd26f, 0x00, 0 },
+	{ 0xd270, 0x8c, 0},
+	{ 0xd271, 0x8a, 0},
+	{ 0xd272, 0x00, 0 },
+	{ 0xd273, 0x6f, 0},
+	{ 0xd274, 0xe5, 0},
+	{ 0xd275, 0x63, 0},
+	{ 0xd276, 0x20, 0},
+	{ 0xd277, 0x00, 0},
+	{ 0xd278, 0x10, 0},
+	{ 0xd279, 0x00, 0},
+	{ 0xd27a, 0x00, 0},
+	{ 0xd27b, 0x07, 0},
+	{ 0xd27c, 0x15, 0 },
+	{ 0xd27d, 0x00, 0 },
+	{ 0xd27e, 0x00, 0 },
+	{ 0xd27f, 0x00, 0 },
+	{ 0xd280, 0x8c, 0},
+	{ 0xd281, 0xaa, 0},
+	{ 0xd282, 0x00, 0},
+	{ 0xd283, 0x6e, 0},
+	{ 0xd284, 0xe0, 0},
+	{ 0xd285, 0x63, 0 },
+	{ 0xd286, 0x28, 0},
+	{ 0xd287, 0x02, 0},
+	{ 0xd288, 0xe0, 0},
+	{ 0xd289, 0x84, 0},
+	{ 0xd28a, 0x28, 0},
+	{ 0xd28b, 0x02, 0},
+	{ 0xd28c, 0x07, 0},
+	{ 0xd28d, 0xff, 0},
+	{ 0xd28e, 0xf8, 0},
+	{ 0xd28f, 0x66, 0},
+	{ 0xd290, 0xe0, 0},
+	{ 0xd291, 0x63, 0},
+	{ 0xd292, 0x5b, 0},
+	{ 0xd293, 0x06, 0},
+	{ 0xd294, 0x8c, 0},
+	{ 0xd295, 0x6a, 0},
+	{ 0xd296, 0x00, 0 },
+	{ 0xd297, 0x77, 0},
+	{ 0xd298, 0xe0, 0},
+	{ 0xd299, 0x63, 0},
+	{ 0xd29a, 0x5b, 0},
+	{ 0xd29b, 0x06, 0},
+	{ 0xd29c, 0xbd, 0},
+	{ 0xd29d, 0x63, 0},
+	{ 0xd29e, 0x00, 0 },
+	{ 0xd29f, 0x00, 0 },
+	{ 0xd2a0, 0x0c, 0},
+	{ 0xd2a1, 0x00, 0},
+	{ 0xd2a2, 0x00, 0},
+	{ 0xd2a3, 0x3c, 0},
+	{ 0xd2a4, 0x15, 0},
+	{ 0xd2a5, 0x00, 0},
+	{ 0xd2a6, 0x00, 0},
+	{ 0xd2a7, 0x00, 0 },
+	{ 0xd2a8, 0x8c, 0},
+	{ 0xd2a9, 0x8a, 0},
+	{ 0xd2aa, 0x00, 0},
+	{ 0xd2ab, 0x78, 0},
+	{ 0xd2ac, 0xb8, 0},
+	{ 0xd2ad, 0x63, 0},
+	{ 0xd2ae, 0x00, 0 },
+	{ 0xd2af, 0x88, 0},
+	{ 0xd2b0, 0xe1, 0},
+	{ 0xd2b1, 0x64, 0},
+	{ 0xd2b2, 0x5b, 0},
+	{ 0xd2b3, 0x06, 0},
+	{ 0xd2b4, 0xbd, 0},
+	{ 0xd2b5, 0x6b, 0},
+	{ 0xd2b6, 0x00, 0},
+	{ 0xd2b7, 0x00, 0 },
+	{ 0xd2b8, 0x0c, 0},
+	{ 0xd2b9, 0x00, 0},
+	{ 0xd2ba, 0x00, 0 },
+	{ 0xd2bb, 0x34, 0},
+	{ 0xd2bc, 0xd4, 0},
+	{ 0xd2bd, 0x01, 0},
+	{ 0xd2be, 0x18, 0 },
+	{ 0xd2bf, 0x14, 0},
+	{ 0xd2c0, 0xb9, 0},
+	{ 0xd2c1, 0x6b, 0},
+	{ 0xd2c2, 0x00, 0 },
+	{ 0xd2c3, 0x88, 0},
+	{ 0xd2c4, 0x85, 0},
+	{ 0xd2c5, 0x01, 0},
+	{ 0xd2c6, 0x00, 0},
+	{ 0xd2c7, 0x14, 0},
+	{ 0xd2c8, 0xbd, 0},
+	{ 0xd2c9, 0x68, 0},
+	{ 0xd2ca, 0x00, 0 },
+	{ 0xd2cb, 0x00, 0},
+	{ 0xd2cc, 0x0c, 0},
+	{ 0xd2cd, 0x00, 0},
+	{ 0xd2ce, 0x00, 0 },
+	{ 0xd2cf, 0x2c, 0},
+	{ 0xd2d0, 0xd4, 0},
+	{ 0xd2d1, 0x01, 0},
+	{ 0xd2d2, 0x58, 0},
+	{ 0xd2d3, 0x18, 0},
+	{ 0xd2d4, 0x84, 0},
+	{ 0xd2d5, 0x81, 0},
+	{ 0xd2d6, 0x00, 0 },
+	{ 0xd2d7, 0x14, 0},
+	{ 0xd2d8, 0xbd, 0},
+	{ 0xd2d9, 0xa4, 0},
+	{ 0xd2da, 0x01, 0},
+	{ 0xd2db, 0x00, 0},
+	{ 0xd2dc, 0x10, 0},
+	{ 0xd2dd, 0x00, 0},
+	{ 0xd2de, 0x00, 0},
+	{ 0xd2df, 0x05, 0},
+	{ 0xd2e0, 0x84, 0},
+	{ 0xd2e1, 0xc1, 0},
+	{ 0xd2e2, 0x00, 0},
+	{ 0xd2e3, 0x18, 0},
+	{ 0xd2e4, 0x9c, 0},
+	{ 0xd2e5, 0xa0, 0},
+	{ 0xd2e6, 0x01, 0},
+	{ 0xd2e7, 0x00, 0 },
+	{ 0xd2e8, 0xd4, 0},
+	{ 0xd2e9, 0x01, 0},
+	{ 0xd2ea, 0x28, 0},
+	{ 0xd2eb, 0x14, 0},
+	{ 0xd2ec, 0x84, 0},
+	{ 0xd2ed, 0xc1, 0},
+	{ 0xd2ee, 0x00, 0 },
+	{ 0xd2ef, 0x18, 0},
+	{ 0xd2f0, 0xbd, 0},
+	{ 0xd2f1, 0x66, 0},
+	{ 0xd2f2, 0x00, 0 },
+	{ 0xd2f3, 0x00, 0},
+	{ 0xd2f4, 0x0c, 0},
+	{ 0xd2f5, 0x00, 0},
+	{ 0xd2f6, 0x00, 0},
+	{ 0xd2f7, 0x20, 0},
+	{ 0xd2f8, 0x9d, 0},
+	{ 0xd2f9, 0x00, 0},
+	{ 0xd2fa, 0x00, 0 },
+	{ 0xd2fb, 0x00, 0},
+	{ 0xd2fc, 0x84, 0},
+	{ 0xd2fd, 0x61, 0},
+	{ 0xd2fe, 0x00, 0 },
+	{ 0xd2ff, 0x18, 0},
+	{ 0xd300, 0xbd, 0},
+	{ 0xd301, 0xa3, 0},
+	{ 0xd302, 0x01, 0},
+	{ 0xd303, 0x00, 0},
+	{ 0xd304, 0x10, 0},
+	{ 0xd305, 0x00, 0},
+	{ 0xd306, 0x00, 0},
+	{ 0xd307, 0x03, 0},
+	{ 0xd308, 0x9c, 0 },
+	{ 0xd309, 0x80, 0},
+	{ 0xd30a, 0x01, 0},
+	{ 0xd30b, 0x00, 0},
+	{ 0xd30c, 0xd4, 0},
+	{ 0xd30d, 0x01, 0},
+	{ 0xd30e, 0x20, 0},
+	{ 0xd30f, 0x18, 0},
+	{ 0xd310, 0x18, 0},
+	{ 0xd311, 0x60, 0},
+	{ 0xd312, 0x80, 0},
+	{ 0xd313, 0x06, 0},
+	{ 0xd314, 0x85, 0},
+	{ 0xd315, 0x01, 0},
+	{ 0xd316, 0x00, 0 },
+	{ 0xd317, 0x14, 0},
+	{ 0xd318, 0xa8, 0},
+	{ 0xd319, 0x83, 0},
+	{ 0xd31a, 0x38, 0},
+	{ 0xd31b, 0x29, 0},
+	{ 0xd31c, 0xa8, 0},
+	{ 0xd31d, 0xc3, 0},
+	{ 0xd31e, 0x40, 0},
+	{ 0xd31f, 0x08, 0},
+	{ 0xd320, 0x8c, 0},
+	{ 0xd321, 0x84, 0},
+	{ 0xd322, 0x00, 0},
+	{ 0xd323, 0x00, 0},
+	{ 0xd324, 0xa8, 0},
+	{ 0xd325, 0xa3, 0},
+	{ 0xd326, 0x38, 0},
+	{ 0xd327, 0x2a, 0},
+	{ 0xd328, 0xa8, 0},
+	{ 0xd329, 0xe3, 0},
+	{ 0xd32a, 0x40, 0},
+	{ 0xd32b, 0x09, 0},
+	{ 0xd32c, 0xe0, 0},
+	{ 0xd32d, 0x64, 0},
+	{ 0xd32e, 0x40, 0},
+	{ 0xd32f, 0x00, 0},
+	{ 0xd330, 0xd8, 0 },
+	{ 0xd331, 0x06, 0},
+	{ 0xd332, 0x18, 0},
+	{ 0xd333, 0x00, 0 },
+	{ 0xd334, 0x8c, 0},
+	{ 0xd335, 0x65, 0},
+	{ 0xd336, 0x00, 0},
+	{ 0xd337, 0x00, 0 },
+	{ 0xd338, 0x84, 0},
+	{ 0xd339, 0x81, 0},
+	{ 0xd33a, 0x00, 0 },
+	{ 0xd33b, 0x18, 0},
+	{ 0xd33c, 0xe3, 0},
+	{ 0xd33d, 0xe3, 0},
+	{ 0xd33e, 0x20, 0},
+	{ 0xd33f, 0x00, 0},
+	{ 0xd340, 0xd8, 0},
+	{ 0xd341, 0x07, 0},
+	{ 0xd342, 0xf8, 0},
+	{ 0xd343, 0x00, 0},
+	{ 0xd344, 0x03, 0},
+	{ 0xd345, 0xff, 0},
+	{ 0xd346, 0xff, 0},
+	{ 0xd347, 0x6f, 0},
+	{ 0xd348, 0x18, 0},
+	{ 0xd349, 0x60, 0},
+	{ 0xd34a, 0x00, 0 },
+	{ 0xd34b, 0x01, 0},
+	{ 0xd34c, 0x0f, 0},
+	{ 0xd34d, 0xff, 0 },
+	{ 0xd34e, 0xff, 0 },
+	{ 0xd34f, 0x9d, 0},
+	{ 0xd350, 0x18, 0},
+	{ 0xd351, 0x60, 0},
+	{ 0xd352, 0x80, 0},
+	{ 0xd353, 0x06, 0},
+	{ 0xd354, 0x00, 0},
+	{ 0xd355, 0x00, 0 },
+	{ 0xd356, 0x00, 0},
+	{ 0xd357, 0x11, 0},
+	{ 0xd358, 0xa8, 0},
+	{ 0xd359, 0x83, 0},
+	{ 0xd35a, 0x6e, 0},
+	{ 0xd35b, 0x43, 0},
+	{ 0xd35c, 0xe0, 0},
+	{ 0xd35d, 0x6c, 0},
+	{ 0xd35e, 0x28, 0},
+	{ 0xd35f, 0x02, 0},
+	{ 0xd360, 0xe0, 0},
+	{ 0xd361, 0x84, 0},
+	{ 0xd362, 0x28, 0},
+	{ 0xd363, 0x02, 0},
+	{ 0xd364, 0x07, 0},
+	{ 0xd365, 0xff, 0},
+	{ 0xd366, 0xf8, 0},
+	{ 0xd367, 0x30, 0},
+	{ 0xd368, 0xb8, 0},
+	{ 0xd369, 0x63, 0},
+	{ 0xd36a, 0x00, 0},
+	{ 0xd36b, 0x08, 0},
+	{ 0xd36c, 0x03, 0},
+	{ 0xd36d, 0xff, 0},
+	{ 0xd36e, 0xff, 0},
+	{ 0xd36f, 0xc0, 0},
+	{ 0xd370, 0x85, 0},
+	{ 0xd371, 0x4e, 0},
+	{ 0xd372, 0x00, 0},
+	{ 0xd373, 0x00, 0},
+	{ 0xd374, 0x03, 0},
+	{ 0xd375, 0xff, 0},
+	{ 0xd376, 0xff, 0},
+	{ 0xd377, 0xe7, 0},
+	{ 0xd378, 0xd4, 0},
+	{ 0xd379, 0x01, 0},
+	{ 0xd37a, 0x40, 0},
+	{ 0xd37b, 0x18, 0},
+	{ 0xd37c, 0x9c, 0},
+	{ 0xd37d, 0x60, 0},
+	{ 0xd37e, 0x00, 0},
+	{ 0xd37f, 0x00, 0},
+	{ 0xd380, 0x03, 0},
+	{ 0xd381, 0xff, 0},
+	{ 0xd382, 0xff, 0},
+	{ 0xd383, 0xdb, 0},
+	{ 0xd384, 0xd4, 0},
+	{ 0xd385, 0x01, 0},
+	{ 0xd386, 0x18, 0},
+	{ 0xd387, 0x14, 0},
+	{ 0xd388, 0x03, 0},
+	{ 0xd389, 0xff, 0},
+	{ 0xd38a, 0xff, 0},
+	{ 0xd38b, 0xce, 0},
+	{ 0xd38c, 0x9d, 0},
+	{ 0xd38d, 0x6b, 0},
+	{ 0xd38e, 0x00, 0},
+	{ 0xd38f, 0xff, 0},
+	{ 0xd390, 0x03, 0},
+	{ 0xd391, 0xff, 0},
+	{ 0xd392, 0xff, 0},
+	{ 0xd393, 0xc6, 0},
+	{ 0xd394, 0x9c, 0},
+	{ 0xd395, 0x63, 0},
+	{ 0xd396, 0x00, 0},
+	{ 0xd397, 0xff, 0},
+	{ 0xd398, 0xa8, 0},
+	{ 0xd399, 0xe3, 0},
+	{ 0xd39a, 0x38, 0},
+	{ 0xd39b, 0x0f, 0},
+	{ 0xd39c, 0x8c, 0},
+	{ 0xd39d, 0x84, 0},
+	{ 0xd39e, 0x00, 0},
+	{ 0xd39f, 0x00, 0},
+	{ 0xd3a0, 0xa8, 0},
+	{ 0xd3a1, 0xa3, 0},
+	{ 0xd3a2, 0x38, 0},
+	{ 0xd3a3, 0x0e, 0},
+	{ 0xd3a4, 0xa8, 0},
+	{ 0xd3a5, 0xc3, 0},
+	{ 0xd3a6, 0x6e, 0},
+	{ 0xd3a7, 0x42, 0},
+	{ 0xd3a8, 0xd8, 0},
+	{ 0xd3a9, 0x07, 0},
+	{ 0xd3aa, 0x20, 0},
+	{ 0xd3ab, 0x00, 0},
+	{ 0xd3ac, 0x8c, 0},
+	{ 0xd3ad, 0x66, 0},
+	{ 0xd3ae, 0x00, 0},
+	{ 0xd3af, 0x00, 0},
+	{ 0xd3b0, 0xd8, 0},
+	{ 0xd3b1, 0x05, 0},
+	{ 0xd3b2, 0x18, 0},
+	{ 0xd3b3, 0x00, 0},
+	{ 0xd3b4, 0x85, 0},
+	{ 0xd3b5, 0x21, 0},
+	{ 0xd3b6, 0x00, 0},
+	{ 0xd3b7, 0x00, 0},
+	{ 0xd3b8, 0x85, 0},
+	{ 0xd3b9, 0x41, 0},
+	{ 0xd3ba, 0x00, 0},
+	{ 0xd3bb, 0x04, 0},
+	{ 0xd3bc, 0x85, 0},
+	{ 0xd3bd, 0x81, 0},
+	{ 0xd3be, 0x00, 0},
+	{ 0xd3bf, 0x08, 0},
+	{ 0xd3c0, 0x85, 0},
+	{ 0xd3c1, 0xc1, 0},
+	{ 0xd3c2, 0x00, 0},
+	{ 0xd3c3, 0x0c, 0},
+	{ 0xd3c4, 0x86, 0},
+	{ 0xd3c5, 0x01, 0},
+	{ 0xd3c6, 0x00, 0},
+	{ 0xd3c7, 0x10, 0},
+	{ 0xd3c8, 0x44, 0},
+	{ 0xd3c9, 0x00, 0},
+	{ 0xd3ca, 0x48, 0},
+	{ 0xd3cb, 0x00, 0},
+	{ 0xd3cc, 0x9c, 0},
+	{ 0xd3cd, 0x21, 0},
+	{ 0xd3ce, 0x00, 0},
+	{ 0xd3cf, 0x1c, 0},
+	{ 0xd3d0, 0x9c, 0},
+	{ 0xd3d1, 0x21, 0},
+	{ 0xd3d2, 0xff, 0},
+	{ 0xd3d3, 0xfc, 0},
+	{ 0xd3d4, 0xd4, 0},
+	{ 0xd3d5, 0x01, 0},
+	{ 0xd3d6, 0x48, 0},
+	{ 0xd3d7, 0x00, 0},
+	{ 0xd3d8, 0x18, 0},
+	{ 0xd3d9, 0x60, 0},
+	{ 0xd3da, 0x00, 0},
+	{ 0xd3db, 0x01, 0},
+	{ 0xd3dc, 0xa8, 0},
+	{ 0xd3dd, 0x63, 0},
+	{ 0xd3de, 0x07, 0},
+	{ 0xd3df, 0x80, 0},
+	{ 0xd3e0, 0x8c, 0},
+	{ 0xd3e1, 0x63, 0},
+	{ 0xd3e2, 0x00, 0},
+	{ 0xd3e3, 0x68, 0},
+	{ 0xd3e4, 0xbc, 0},
+	{ 0xd3e5, 0x03, 0},
+	{ 0xd3e6, 0x00, 0},
+	{ 0xd3e7, 0x00, 0},
+	{ 0xd3e8, 0x10, 0},
+	{ 0xd3e9, 0x00, 0},
+	{ 0xd3ea, 0x00, 0},
+	{ 0xd3eb, 0x0c, 0},
+	{ 0xd3ec, 0x15, 0},
+	{ 0xd3ed, 0x00, 0},
+	{ 0xd3ee, 0x00, 0},
+	{ 0xd3ef, 0x00, 0},
+	{ 0xd3f0, 0x07, 0},
+	{ 0xd3f1, 0xff, 0},
+	{ 0xd3f2, 0xd9, 0},
+	{ 0xd3f3, 0x98, 0},
+	{ 0xd3f4, 0x15, 0},
+	{ 0xd3f5, 0x00, 0},
+	{ 0xd3f6, 0x00, 0},
+	{ 0xd3f7, 0x00, 0},
+	{ 0xd3f8, 0x18, 0},
+	{ 0xd3f9, 0x60, 0},
+	{ 0xd3fa, 0x80, 0},
+	{ 0xd3fb, 0x06, 0},
+	{ 0xd3fc, 0xa8, 0},
+	{ 0xd3fd, 0x63, 0},
+	{ 0xd3fe, 0xc4, 0},
+	{ 0xd3ff, 0xb8, 0},
+	{ 0xd400, 0x8c, 0},
+	{ 0xd401, 0x63, 0},
+	{ 0xd402, 0x00, 0},
+	{ 0xd403, 0x00, 0},
+	{ 0xd404, 0xbc, 0},
+	{ 0xd405, 0x23, 0},
+	{ 0xd406, 0x00, 0},
+	{ 0xd407, 0x01, 0},
+	{ 0xd408, 0x10, 0},
+	{ 0xd409, 0x00, 0},
+	{ 0xd40a, 0x00, 0},
+	{ 0xd40b, 0x25, 0},
+	{ 0xd40c, 0x9d, 0},
+	{ 0xd40d, 0x00, 0},
+	{ 0xd40e, 0x00, 0},
+	{ 0xd40f, 0x00, 0},
+	{ 0xd410, 0x00, 0},
+	{ 0xd411, 0x00, 0},
+	{ 0xd412, 0x00, 0},
+	{ 0xd413, 0x0b, 0},
+	{ 0xd414, 0xb8, 0},
+	{ 0xd415, 0xe8, 0},
+	{ 0xd416, 0x00, 0},
+	{ 0xd417, 0x02, 0},
+	{ 0xd418, 0x07, 0},
+	{ 0xd419, 0xff, 0},
+	{ 0xd41a, 0xd6, 0},
+	{ 0xd41b, 0x24, 0},
+	{ 0xd41c, 0x15, 0},
+	{ 0xd41d, 0x00, 0},
+	{ 0xd41e, 0x00, 0},
+	{ 0xd41f, 0x00, 0},
+	{ 0xd420, 0x18, 0},
+	{ 0xd421, 0x60, 0},
+	{ 0xd422, 0x80, 0},
+	{ 0xd423, 0x06, 0},
+	{ 0xd424, 0xa8, 0},
+	{ 0xd425, 0x63, 0},
+	{ 0xd426, 0xc4, 0},
+	{ 0xd427, 0xb8, 0},
+	{ 0xd428, 0x8c, 0},
+	{ 0xd429, 0x63, 0},
+	{ 0xd42a, 0x00, 0},
+	{ 0xd42b, 0x00, 0},
+	{ 0xd42c, 0xbc, 0},
+	{ 0xd42d, 0x23, 0},
+	{ 0xd42e, 0x00, 0},
+	{ 0xd42f, 0x01, 0},
+	{ 0xd430, 0x10, 0},
+	{ 0xd431, 0x00, 0},
+	{ 0xd432, 0x00, 0},
+	{ 0xd433, 0x1b, 0},
+	{ 0xd434, 0x9d, 0},
+	{ 0xd435, 0x00, 0},
+	{ 0xd436, 0x00, 0},
+	{ 0xd437, 0x00, 0},
+	{ 0xd438, 0xb8, 0},
+	{ 0xd439, 0xe8, 0},
+	{ 0xd43a, 0x00, 0},
+	{ 0xd43b, 0x02, 0},
+	{ 0xd43c, 0x9c, 0},
+	{ 0xd43d, 0xc0, 0},
+	{ 0xd43e, 0x00, 0},
+	{ 0xd43f, 0x00, 0},
+	{ 0xd440, 0x18, 0},
+	{ 0xd441, 0xa0, 0},
+	{ 0xd442, 0x80, 0},
+	{ 0xd443, 0x06, 0},
+	{ 0xd444, 0xe0, 0},
+	{ 0xd445, 0x67, 0},
+	{ 0xd446, 0x30, 0},
+	{ 0xd447, 0x00, 0},
+	{ 0xd448, 0xa8, 0},
+	{ 0xd449, 0xa5, 0},
+	{ 0xd44a, 0xce, 0},
+	{ 0xd44b, 0xb0, 0},
+	{ 0xd44c, 0x19, 0},
+	{ 0xd44d, 0x60, 0},
+	{ 0xd44e, 0x00, 0},
+	{ 0xd44f, 0x01, 0},
+	{ 0xd450, 0xa9, 0},
+	{ 0xd451, 0x6b, 0},
+	{ 0xd452, 0x06, 0},
+	{ 0xd453, 0x14, 0},
+	{ 0xd454, 0xe0, 0},
+	{ 0xd455, 0x83, 0},
+	{ 0xd456, 0x28, 0},
+	{ 0xd457, 0x00, 0},
+	{ 0xd458, 0x9c, 0},
+	{ 0xd459, 0xc6, 0},
+	{ 0xd45a, 0x00, 0},
+	{ 0xd45b, 0x01, 0},
+	{ 0xd45c, 0xe0, 0},
+	{ 0xd45d, 0x63, 0},
+	{ 0xd45e, 0x18, 0},
+	{ 0xd45f, 0x00, 0},
+	{ 0xd460, 0x8c, 0},
+	{ 0xd461, 0x84, 0},
+	{ 0xd462, 0x00, 0},
+	{ 0xd463, 0x00, 0},
+	{ 0xd464, 0xe0, 0},
+	{ 0xd465, 0xa3, 0},
+	{ 0xd466, 0x58, 0},
+	{ 0xd467, 0x00, 0},
+	{ 0xd468, 0xa4, 0},
+	{ 0xd469, 0xc6, 0},
+	{ 0xd46a, 0x00, 0},
+	{ 0xd46b, 0xff, 0},
+	{ 0xd46c, 0xb8, 0},
+	{ 0xd46d, 0x64, 0},
+	{ 0xd46e, 0x00, 0},
+	{ 0xd46f, 0x18, 0},
+	{ 0xd470, 0xbc, 0},
+	{ 0xd471, 0x46, 0},
+	{ 0xd472, 0x00, 0},
+	{ 0xd473, 0x03, 0},
+	{ 0xd474, 0x94, 0},
+	{ 0xd475, 0x85, 0},
+	{ 0xd476, 0x00, 0},
+	{ 0xd477, 0x00, 0},
+	{ 0xd478, 0xb8, 0},
+	{ 0xd479, 0x63, 0},
+	{ 0xd47a, 0x00, 0},
+	{ 0xd47b, 0x98, 0},
+	{ 0xd47c, 0xe0, 0},
+	{ 0xd47d, 0x64, 0},
+	{ 0xd47e, 0x18, 0},
+	{ 0xd47f, 0x00, 0},
+	{ 0xd480, 0x0f, 0},
+	{ 0xd481, 0xff, 0},
+	{ 0xd482, 0xff, 0},
+	{ 0xd483, 0xf0, 0},
+	{ 0xd484, 0xdc, 0},
+	{ 0xd485, 0x05, 0},
+	{ 0xd486, 0x18, 0},
+	{ 0xd487, 0x00, 0},
+	{ 0xd488, 0x9c, 0},
+	{ 0xd489, 0x68, 0},
+	{ 0xd48a, 0x00, 0},
+	{ 0xd48b, 0x01, 0},
+	{ 0xd48c, 0xa5, 0},
+	{ 0xd48d, 0x03, 0},
+	{ 0xd48e, 0x00, 0},
+	{ 0xd48f, 0xff, 0},
+	{ 0xd490, 0xbc, 0},
+	{ 0xd491, 0x48, 0},
+	{ 0xd492, 0x00, 0},
+	{ 0xd493, 0x01, 0},
+	{ 0xd494, 0x0f, 0},
+	{ 0xd495, 0xff, 0},
+	{ 0xd496, 0xff, 0},
+	{ 0xd497, 0xea, 0},
+	{ 0xd498, 0xb8, 0},
+	{ 0xd499, 0xe8, 0},
+	{ 0xd49a, 0x00, 0},
+	{ 0xd49b, 0x02, 0},
+	{ 0xd49c, 0x18, 0},
+	{ 0xd49d, 0x60, 0},
+	{ 0xd49e, 0x00, 0},
+	{ 0xd49f, 0x01, 0},
+	{ 0xd4a0, 0xa8, 0},
+	{ 0xd4a1, 0x63, 0},
+	{ 0xd4a2, 0x06, 0},
+	{ 0xd4a3, 0x14, 0},
+	{ 0xd4a4, 0x07, 0},
+	{ 0xd4a5, 0xff, 0},
+	{ 0xd4a6, 0xe4, 0},
+	{ 0xd4a7, 0x05, 0},
+	{ 0xd4a8, 0x9c, 0},
+	{ 0xd4a9, 0x83, 0},
+	{ 0xd4aa, 0x00, 0},
+	{ 0xd4ab, 0x10, 0},
+	{ 0xd4ac, 0x85, 0},
+	{ 0xd4ad, 0x21, 0},
+	{ 0xd4ae, 0x00, 0},
+	{ 0xd4af, 0x00, 0},
+	{ 0xd4b0, 0x44, 0},
+	{ 0xd4b1, 0x00, 0},
+	{ 0xd4b2, 0x48, 0},
+	{ 0xd4b3, 0x00, 0},
+	{ 0xd4b4, 0x9c, 0},
+	{ 0xd4b5, 0x21, 0},
+	{ 0xd4b6, 0x00, 0},
+	{ 0xd4b7, 0x04, 0},
+	{ 0xd4b8, 0x18, 0},
+	{ 0xd4b9, 0x60, 0},
+	{ 0xd4ba, 0x00, 0},
+	{ 0xd4bb, 0x01, 0},
+	{ 0xd4bc, 0x9c, 0},
+	{ 0xd4bd, 0x80, 0},
+	{ 0xd4be, 0xff, 0},
+	{ 0xd4bf, 0xff, 0},
+	{ 0xd4c0, 0xa8, 0},
+	{ 0xd4c1, 0x63, 0},
+	{ 0xd4c2, 0x09, 0},
+	{ 0xd4c3, 0xef, 0},
+	{ 0xd4c4, 0xd8, 0},
+	{ 0xd4c5, 0x03, 0},
+	{ 0xd4c6, 0x20, 0},
+	{ 0xd4c7, 0x00, 0},
+	{ 0xd4c8, 0x18, 0},
+	{ 0xd4c9, 0x60, 0},
+	{ 0xd4ca, 0x80, 0},
+	{ 0xd4cb, 0x06, 0},
+	{ 0xd4cc, 0xa8, 0},
+	{ 0xd4cd, 0x63, 0},
+	{ 0xd4ce, 0xc9, 0},
+	{ 0xd4cf, 0xef, 0},
+	{ 0xd4d0, 0xd8, 0},
+	{ 0xd4d1, 0x03, 0},
+	{ 0xd4d2, 0x20, 0},
+	{ 0xd4d3, 0x00, 0},
+	{ 0xd4d4, 0x44, 0},
+	{ 0xd4d5, 0x00, 0},
+	{ 0xd4d6, 0x48, 0},
+	{ 0xd4d7, 0x00, 0},
+	{ 0xd4d8, 0x15, 0},
+	{ 0xd4d9, 0x00, 0},
+	{ 0xd4da, 0x00, 0},
+	{ 0xd4db, 0x00, 0},
+	{ 0xd4dc, 0x18, 0},
+	{ 0xd4dd, 0x80, 0},
+	{ 0xd4de, 0x00, 0},
+	{ 0xd4df, 0x01, 0},
+	{ 0xd4e0, 0xa8, 0},
+	{ 0xd4e1, 0x84, 0},
+	{ 0xd4e2, 0x0a, 0},
+	{ 0xd4e3, 0x12, 0},
+	{ 0xd4e4, 0x8c, 0},
+	{ 0xd4e5, 0x64, 0},
+	{ 0xd4e6, 0x00, 0},
+	{ 0xd4e7, 0x00, 0},
+	{ 0xd4e8, 0xbc, 0},
+	{ 0xd4e9, 0x03, 0},
+	{ 0xd4ea, 0x00, 0},
+	{ 0xd4eb, 0x00, 0},
+	{ 0xd4ec, 0x13, 0},
+	{ 0xd4ed, 0xff, 0},
+	{ 0xd4ee, 0xff, 0},
+	{ 0xd4ef, 0xfe, 0},
+	{ 0xd4f0, 0x15, 0},
+	{ 0xd4f1, 0x00, 0},
+	{ 0xd4f2, 0x00, 0},
+	{ 0xd4f3, 0x00, 0},
+	{ 0xd4f4, 0x44, 0},
+	{ 0xd4f5, 0x00, 0},
+	{ 0xd4f6, 0x48, 0},
+	{ 0xd4f7, 0x00, 0},
+	{ 0xd4f8, 0x15, 0},
+	{ 0xd4f9, 0x00, 0},
+	{ 0xd4fa, 0x00, 0},
+	{ 0xd4fb, 0x00, 0},
+	{ 0xd4fc, 0x00, 0},
+	{ 0xd4fd, 0x00, 0},
+	{ 0xd4fe, 0x00, 0},
+	{ 0xd4ff, 0x00, 0},
+	{ 0xd500, 0x00, 0},
+	{ 0xd501, 0x00, 0},
+	{ 0xd502, 0x00, 0},
+	{ 0xd503, 0x00, 0},
+	{ 0x6f0e, 0x33, 0 },
+	{ 0x6f0f, 0x33, 0 },
+	{ 0x460e, 0x08, 0 },
+	{ 0x460f, 0x01, 0 },
+	{ 0x4610, 0x00, 0 },
+	{ 0x4611, 0x01, 0 },
+	{ 0x4612, 0x00, 0 },
+	{ 0x4613, 0x01, 0 },
+	{ 0x4605, 0x08, 0},
+	{ 0x4608, 0x00, 0 },
+	{ 0x4609, 0x08, 0 },
+	{ 0x6804, 0x00, 0 },
+	{ 0x6805, 0x06, 0 },
+	{ 0x6806, 0x00, 0 },
+	{ 0x5120, 0x00, 0 },
+	{ 0x3510, 0x00, 0 },
+	{ 0x3504, 0x00, 0 },
+	{ 0x6800, 0x00, 0 },
+	{ 0x6f0d, 0x0f, 0 },
+	{ 0x5000, 0xff, 0 },
+	{ 0x5001, 0xbf, 0 },
+	{ 0x5002, 0x7e, 0 },
+	{ 0x5003, 0x0c, 0},
+	{ 0x503d, 0x00, 0 },
+	{ 0xc450, 0x01, 0 },
+	{ 0xc452, 0x04, 0 },
+	{ 0xc453, 0x00, 0 },
+	{ 0xc454, 0x00, 0 },
+	{ 0xc455, 0x00, 0 },
+	{ 0xc456, 0x00, 0 },
+	{ 0xc457, 0x00, 0 },
+	{ 0xc458, 0x00, 0 },
+	{ 0xc459, 0x00, 0 },
+	{ 0xc45b, 0x00, 0 },
+	{ 0xc45c, 0x00, 0 },
+	{ 0xc45d, 0x00, 0 },
+	{ 0xc45e, 0x00, 0 },
+	{ 0xc45f, 0x00, 0 },
+	{ 0xc460, 0x00, 0 },
+	{ 0xc461, 0x01, 0 },
+	{ 0xc462, 0x01, 0 },
+	{ 0xc464, 0x88, 0 },
+	{ 0xc465, 0x00, 0 },
+	{ 0xc466, 0x8a, 0 },
+	{ 0xc467, 0x00, 0 },
+	{ 0xc468, 0x86, 0 },
+	{ 0xc469, 0x00, 0 },
+	{ 0xc46a, 0x40, 0 },
+	{ 0xc46b, 0x50, 0 },
+	{ 0xc46c, 0x30, 0 },
+	{ 0xc46d, 0x28, 0 },
+	{ 0xc46e, 0x60, 0 },
+	{ 0xc46f, 0x40, 0 },
+	{ 0xc47c, 0x01, 0 },
+	{ 0xc47d, 0x38, 0 },
+	{ 0xc47e, 0x00, 0 },
+	{ 0xc47f, 0x00, 0 },
+	{ 0xc480, 0x00, 0 },
+	{ 0xc481, 0xff, 0 },
+	{ 0xc482, 0x00, 0 },
+	{ 0xc483, 0x40, 0 },
+	{ 0xc484, 0x00, 0 },
+	{ 0xc485, 0x18, 0 },
+	{ 0xc486, 0x00, 0 },
+	{ 0xc487, 0x18, 0 },
+	{ 0xc488, 0x34, 0 },
+	{ 0xc489, 0x00, 0 },
+	{ 0xc48a, 0x34, 0 },
+	{ 0xc48b, 0x00, 0 },
+	{ 0xc48c, 0x00, 0 },
+	{ 0xc48d, 0x04, 0 },
+	{ 0xc48e, 0x00, 0 },
+	{ 0xc48f, 0x04, 0 },
+	{ 0xc490, 0x07, 0 },
+	{ 0xc492, 0x20, 0 },
+	{ 0xc493, 0x08, 0 },
+	{ 0xc498, 0x02, 0 },
+	{ 0xc499, 0x00, 0 },
+	{ 0xc49a, 0x02, 0 },
+	{ 0xc49b, 0x00, 0 },
+	{ 0xc49c, 0x02, 0 },
+	{ 0xc49d, 0x00, 0 },
+	{ 0xc49e, 0x02, 0 },
+	{ 0xc49f, 0x60, 0 },
+	{ 0xc4a0, 0x03, 0 },
+	{ 0xc4a1, 0x00, 0 },
+	{ 0xc4a2, 0x04, 0 },
+	{ 0xc4a3, 0x00, 0 },
+	{ 0xc4a4, 0x00, 0 },
+	{ 0xc4a5, 0x10, 0 },
+	{ 0xc4a6, 0x00, 0 },
+	{ 0xc4a7, 0x40, 0 },
+	{ 0xc4a8, 0x00, 0 },
+	{ 0xc4a9, 0x80, 0 },
+	{ 0xc4aa, 0x0d, 0 },
+	{ 0xc4ab, 0x00, 0 },
+	{ 0xc4ac, 0x0f, 0 },
+	{ 0xc4ad, 0xc0, 0 },
+	{ 0xc4b4, 0x01, 0 },
+	{ 0xc4b5, 0x01, 0 },
+	{ 0xc4b6, 0x00, 0 },
+	{ 0xc4b7, 0x01, 0 },
+	{ 0xc4b8, 0x00, 0 },
+	{ 0xc4b9, 0x01, 0 },
+	{ 0xc4ba, 0x01, 0 },
+	{ 0xc4bb, 0x00, 0 },
+	{ 0xc4bc, 0x01, 0 },
+	{ 0xc4bd, 0x60, 0 },
+	{ 0xc4be, 0x02, 0 },
+	{ 0xc4bf, 0x33, 0 },
+	{ 0xc4c8, 0x03, 0 },
+	{ 0xc4c9, 0xd0, 0 },
+	{ 0xc4ca, 0x0e, 0 },
+	{ 0xc4cb, 0x00, 0 },
+	{ 0xc4cc, 0x10, 0 },
+	{ 0xc4cd, 0x18, 0 },
+	{ 0xc4ce, 0x10, 0 },
+	{ 0xc4cf, 0x18, 0 },
+	{ 0xc4d0, 0x04, 0 },
+	{ 0xc4d1, 0x80, 0 },
+	{ 0xc4e0, 0x04, 0 },
+	{ 0xc4e1, 0x02, 0 },
+	{ 0xc4e2, 0x01, 0 },
+	{ 0xc4e4, 0x10, 0 },
+	{ 0xc4e5, 0x20, 0 },
+	{ 0xc4e6, 0x30, 0 },
+	{ 0xc4e7, 0x40, 0 },
+	{ 0xc4e8, 0x50, 0 },
+	{ 0xc4e9, 0x60, 0 },
+	{ 0xc4ea, 0x70, 0 },
+	{ 0xc4eb, 0x80, 0 },
+	{ 0xc4ec, 0x90, 0 },
+	{ 0xc4ed, 0xa0, 0 },
+	{ 0xc4ee, 0xb0, 0 },
+	{ 0xc4ef, 0xc0, 0 },
+	{ 0xc4f0, 0xd0, 0 },
+	{ 0xc4f1, 0xe0, 0 },
+	{ 0xc4f2, 0xf0, 0 },
+	{ 0xc4f3, 0x80, 0 },
+	{ 0xc4f4, 0x00, 0 },
+	{ 0xc4f5, 0x20, 0 },
+	{ 0xc4f6, 0x02, 0 },
+	{ 0xc4f7, 0x00, 0 },
+	{ 0xc4f8, 0x04, 0 },
+	{ 0xc4f9, 0x0b, 0 },
+	{ 0xc4fa, 0x00, 0 },
+	{ 0xc4fb, 0x00, 0},
+	{ 0xc4fc, 0x01, 0 },
+	{ 0xc4fd, 0x00, 0 },
+	{ 0xc4fe, 0x04, 0 },
+	{ 0xc4ff, 0x02, 0 },
+	{ 0xc500, 0x48, 0 },
+	{ 0xc501, 0x74, 0 },
+	{ 0xc502, 0x58, 0 },
+	{ 0xc503, 0x80, 0 },
+	{ 0xc504, 0x05, 0 },
+	{ 0xc505, 0x80, 0 },
+	{ 0xc506, 0x03, 0 },
+	{ 0xc507, 0x80, 0 },
+	{ 0xc508, 0x01, 0 },
+	{ 0xc509, 0xc0, 0 },
+	{ 0xc50a, 0x01, 0 },
+	{ 0xc50b, 0xa0, 0 },
+	{ 0xc50c, 0x01, 0 },
+	{ 0xc50d, 0x2c, 0 },
+	{ 0xc50e, 0x01, 0 },
+	{ 0xc50f, 0x0a, 0 },
+	{ 0xc510, 0x00, 0 },
+	{ 0xc511, 0x01, 0 },
+	{ 0xc512, 0x01, 0 },
+	{ 0xc513, 0x80, 0 },
+	{ 0xc514, 0x04, 0 },
+	{ 0xc515, 0x00, 0 },
+	{ 0xc518, 0x03, 0 },
+	{ 0xc519, 0x48, 0 },
+	{ 0xc51a, 0x07, 0 },
+	{ 0xc51b, 0x70, 0 },
+	{ 0xc2e0, 0x00, 0 },
+	{ 0xc2e1, 0x51, 0 },
+	{ 0xc2e2, 0x00, 0 },
+	{ 0xc2e3, 0xd6, 0 },
+	{ 0xc2e4, 0x01, 0 },
+	{ 0xc2e5, 0x5e, 0 },
+	{ 0xc2e9, 0x01, 0 },
+	{ 0xc2ea, 0x7a, 0 },
+	{ 0xc2eb, 0x90, 0 },
+	{ 0xc2ed, 0x00, 0 },
+	{ 0xc2ee, 0x7a, 0 },
+	{ 0xc2ef, 0x64, 0 },
+	{ 0xc308, 0x00, 0 },
+	{ 0xc309, 0x00, 0 },
+	{ 0xc30a, 0x00, 0 },
+	{ 0xc30c, 0x00, 0 },
+	{ 0xc30d, 0x01, 0 },
+	{ 0xc30e, 0x00, 0 },
+	{ 0xc30f, 0x00, 0 },
+	{ 0xc310, 0x01, 0 },
+	{ 0xc311, 0x60, 0 },
+	{ 0xc312, 0xff, 0 },
+	{ 0xc313, 0x08, 0 },
+	{ 0xc314, 0x01, 0 },
+	{ 0xc315, 0x7f, 0 },
+	{ 0xc316, 0xff, 0 },
+	{ 0xc317, 0x0b, 0 },
+	{ 0xc318, 0x00, 0 },
+	{ 0xc319, 0x0c, 0 },
+	{ 0xc31a, 0x00, 0 },
+	{ 0xc31b, 0xe0, 0 },
+	{ 0xc31c, 0x00, 0 },
+	{ 0xc31d, 0x14, 0 },
+	{ 0xc31e, 0x00, 0 },
+	{ 0xc31f, 0xc5, 0 },
+	{ 0xc320, 0xff, 0 },
+	{ 0xc321, 0x4b, 0 },
+	{ 0xc322, 0xff, 0 },
+	{ 0xc323, 0xf0, 0 },
+	{ 0xc324, 0xff, 0 },
+	{ 0xc325, 0xe8, 0 },
+	{ 0xc326, 0x00, 0 },
+	{ 0xc327, 0x46, 0 },
+	{ 0xc328, 0xff, 0 },
+	{ 0xc329, 0xd2, 0 },
+	{ 0xc32a, 0xff, 0 },
+	{ 0xc32b, 0xe4, 0 },
+	{ 0xc32c, 0xff, 0 },
+	{ 0xc32d, 0xbb, 0 },
+	{ 0xc32e, 0x00, 0 },
+	{ 0xc32f, 0x61, 0 },
+	{ 0xc330, 0xff, 0 },
+	{ 0xc331, 0xf9, 0 },
+	{ 0xc332, 0x00, 0 },
+	{ 0xc333, 0xd9, 0 },
+	{ 0xc334, 0x00, 0 },
+	{ 0xc335, 0x2e, 0 },
+	{ 0xc336, 0x00, 0 },
+	{ 0xc337, 0xb1, 0 },
+	{ 0xc338, 0xff, 0 },
+	{ 0xc339, 0x64, 0 },
+	{ 0xc33a, 0xff, 0 },
+	{ 0xc33b, 0xeb, 0 },
+	{ 0xc33c, 0xff, 0 },
+	{ 0xc33d, 0xe8, 0 },
+	{ 0xc33e, 0x00, 0 },
+	{ 0xc33f, 0x48, 0 },
+	{ 0xc340, 0xff, 0 },
+	{ 0xc341, 0xd0, 0 },
+	{ 0xc342, 0xff, 0 },
+	{ 0xc343, 0xed, 0 },
+	{ 0xc344, 0xff, 0 },
+	{ 0xc345, 0xad, 0 },
+	{ 0xc346, 0x00, 0 },
+	{ 0xc347, 0x66, 0 },
+	{ 0xc348, 0x01, 0 },
+	{ 0xc349, 0x00, 0 },
+	{ 0x6700, 0x04, 0 },
+	{ 0x6701, 0x7b, 0 },
+	{ 0x6702, 0xfd, 0 },
+	{ 0x6703, 0xf9, 0 },
+	{ 0x6704, 0x3d, 0 },
+	{ 0x6705, 0x71, 0 },
+	{ 0x6706, 0x78, 0 },
+	{ 0x6708, 0x05, 0 },
+	{ 0x6f06, 0x6f, 0 },
+	{ 0x6f07, 0x00, 0 },
+	{ 0x6f0a, 0x6f, 0 },
+	{ 0x6f0b, 0x00, 0 },
+	{ 0x6f00, 0x03, 0 },
+	{ 0xc34c, 0x01, 0 },
+	{ 0xc34d, 0x00, 0 },
+	{ 0xc34e, 0x46, 0 },
+	{ 0xc34f, 0x55, 0 },
+	{ 0xc350, 0x00, 0 },
+	{ 0xc351, 0x40, 0 },
+	{ 0xc352, 0x00, 0 },
+	{ 0xc353, 0xff, 0 },
+	{ 0xc354, 0x04, 0 },
+	{ 0xc355, 0x08, 0 },
+	{ 0xc356, 0x01, 0 },
+	{ 0xc357, 0xef, 0 },
+	{ 0xc358, 0x30, 0 },
+	{ 0xc359, 0x01, 0 },
+	{ 0xc35a, 0x64, 0 },
+	{ 0xc35b, 0x46, 0 },
+	{ 0xc35c, 0x00, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x3042, 0xf0, 0 },
+	{ 0x301b, 0xf0, 0 },
+	{ 0x301c, 0xf0, 0 },
+	{ 0x301a, 0xf0, 0 },
+
+	{ 0xceb0, 0x00, 0 },
+	{ 0xceb1, 0x00, 0 },
+	{ 0xceb2, 0x00, 0 },
+	{ 0xceb3, 0x00, 0 },
+	{ 0xceb4, 0x00, 0 },
+	{ 0xceb5, 0x00, 0 },
+	{ 0xceb6, 0x00, 0 },
+	{ 0xceb7, 0x00, 0 },
+	{ 0xc4bc, 0x01, 0 },
+	{ 0xc4bd, 0x60, 0 },
+
+	{ 0x301b, 0xf1, 0 }, //PLL
+	{ 0x3003, 0x18, 0 },
+	{ 0x3004, 0x11, 0 },
+	{ 0x3005, 0x12, 0 },
+	{ 0x3006, 0x11, 0 },
+	{ 0x3024, 0x00, 0 },
+	{ 0x3621, 0x63, 0 },
+	{ 0x3702, 0x20, 0 },
+	{ 0x3703, 0x48, 0 },
+	{ 0x3704, 0x32, 0 },
+	{ 0x3800, 0x00, 0 },
+	{ 0x3801, 0x00, 0 },
+	{ 0x3802, 0x00, 0 },
+	{ 0x3803, 0x04, 0 },
+	{ 0x3804, 0x00, 0 },
+	{ 0x3805, 0xFF, 0 },
+	{ 0x3806, 0x03, 0 },
+	{ 0x3807, 0x29, 0 },
+	{ 0x3808, 0x05, 0 },
+	{ 0x3809, 0x00, 0 },
+	{ 0x380a, 0x03, 0 },
+	{ 0x380b, 0x20, 0 },
+	{ 0x380c, 0x07, 0 },
+	{ 0x380d, 0x70, 0 },
+	{ 0x6e42, 0x03, 0 },
+	{ 0x6e43, 0x48, 0 },
+	{ 0x3810, 0x00, 0 },
+	{ 0x3811, 0x10, 0 },
+	{ 0x3812, 0x00, 0 },
+	{ 0x3813, 0x02, 0 },
+	{ 0x381c, 0x00, 0 },
+	{ 0x381e, 0x00, 0 },
+	{ 0x381f, 0x0C, 0 },
+	{ 0x4001, 0x06, 0 },
+	{ 0x4004, 0x04, 0 },
+	{ 0x4050, 0x22, 0 },
+	{ 0x4051, 0x24, 0 },
+	{ 0x4605, 0x0C, 0 },
+	{ 0x4606, 0x0A, 0 },
+	{ 0x4607, 0xDA, 0 },
+	{ 0xc488, 0x35, 0 },
+	{ 0xc489, 0x80, 0 },
+	{ 0xc48a, 0x35, 0 },
+	{ 0xc48b, 0x80, 0 },
+	{ 0xc4cc, 0x10, 0 },
+	{ 0xc4cd, 0x18, 0 },
+	{ 0xc4ce, 0x10, 0 },
+	{ 0xc4cf, 0x18, 0 },
+	{ 0xc510, 0x00, 0 },
+	{ 0xc511, 0x01, 0 },
+	{ 0xc512, 0x01, 0 },
+	{ 0xc513, 0x88, 0 },
+	{ 0x5005, 0x08, 0 },
+	{ 0x3007, 0x01, 0 },
+	{ 0xc518, 0x03, 0 },
+	{ 0xc519, 0x60, 0 },
+	{ 0xc51a, 0x07, 0 },
+	{ 0xc51b, 0x3C, 0 },
+	{ 0x5608, 0x0D, 0 },
+	{ 0x3815, 0x8C, 0 },
+	{ 0x301b, 0xf0, 0 },
+
+	{ 0x4709, 0x10, 0 },//dvp swap
+	{ 0x4300, 0x3a, 0 }, //YUV order UYVY
+	{ 0x3832, 0x01, 0 },//fsin
+	{ 0x3833, 0x1A, 0 },
+	{ 0x3834, 0x03, 0 },
+	{ 0x3835, 0x48, 0 },
+	{ 0x302E, 0x01, 0 },
+#if 0
+	{ 0x4709, 0x10, 0 },  //Flip Bits MSB do DOUT0
+	{ 0x4605, 0x08, 0 },  //8-bit YUV
+	{ 0x4300, 0x3a, 5 },  //YUYV  check with validation code
+	{ 0x3832, 0x01, 0 },
+	{ 0x3833, 0x1A, 0 },
+	{ 0x3834, 0x03, 60 },
+	{ 0x3835, 0x48, 60 },
+	{ 0x302E, 0x01, 0 },
+#endif
+};
+
+static inline struct sensor_data *subdev_to_sensor_data(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_data, subdev);
+}
+
+static inline int ov10635_read_reg(struct sensor_data *max9286_data, int index,
+											unsigned short reg, unsigned char *val)
+{
+	unsigned char u8_buf[2] = { 0 };
+	unsigned int buf_len = 2;
+	int retry, timeout = 10;
+	unsigned char u8_val = 0;
+
+	u8_buf[0] = (reg >> 8) & 0xFF;
+	u8_buf[1] = reg & 0xFF;
+
+	max9286_data->i2c_client->addr = ADDR_OV_SENSOR + index;
+
+	for (retry = 0; retry < timeout; retry++) {
+		if (i2c_master_send(max9286_data->i2c_client, u8_buf, buf_len) < 0) {
+			dev_dbg(&max9286_data->i2c_client->dev,
+				"%s:read reg error on send: reg=0x%x, retry = %d.\n", __func__, reg, retry);
+			msleep(5);
+			continue;
+		}
+		if (i2c_master_recv(max9286_data->i2c_client, &u8_val, 1) != 1) {
+			dev_dbg(&max9286_data->i2c_client->dev,
+				"%s:read reg error on recv: reg=0x%x, retry = %d.\n", __func__, reg, retry);
+			msleep(5);
+			continue;
+		}
+		break;
+	}
+
+	if (retry >= timeout) {
+		dev_info(&max9286_data->i2c_client->dev,
+			"%s:read reg error: reg=0x%x.\n", __func__, reg);
+		return -1;
+	}
+
+	*val = u8_val;
+
+	return u8_val;
+}
+
+static inline int ov10635_write_reg(struct sensor_data *max9286_data, int index,
+												unsigned short reg, unsigned char val)
+{
+	unsigned char u8_buf[3] = { 0 };
+	unsigned int buf_len = 3;
+	int retry, timeout = 10;
+
+	u8_buf[0] = (reg >> 8) & 0xFF;
+	u8_buf[1] = reg & 0xFF;
+	u8_buf[2] = val;
+
+	max9286_data->i2c_client->addr = ADDR_OV_SENSOR + index;
+	for (retry = 0; retry < timeout; retry++) {
+		if (i2c_master_send(max9286_data->i2c_client, u8_buf, buf_len) < 0) {
+			dev_dbg(&max9286_data->i2c_client->dev,
+				"%s:write reg error: reg=0x%x, val=0x%x, retry = %d.\n", __func__, reg, val, retry);
+			msleep(5);
+			continue;
+		}
+		break;
+	}
+
+	if (retry >= timeout) {
+		dev_info(&max9286_data->i2c_client->dev,
+			"%s:write reg error: reg=0x%x, val=0x%x.\n", __func__, reg, val);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ov10635_check_device(struct sensor_data *max9286_data, int index)
+{
+	unsigned char reg = 0;
+
+	ov10635_read_reg(max9286_data, index, OV10635_REG_PID, &reg);
+	if (reg != 0xA6) {
+		dev_err(&max9286_data->i2c_client->dev,
+			"%s: OV10635 hasn't been found, reg[0x%x] = 0x%x., index=%d\n",
+			__func__, OV10635_REG_PID, reg, index);
+		return -1;
+	}
+	ov10635_read_reg(max9286_data, index, OV10635_REG_VER, &reg);
+	if (reg != 0x35) {
+		dev_err(&max9286_data->i2c_client->dev,
+			"%s: OV10635 hasn't been found, reg[0x%x] = 0x%x.\n", __func__, OV10635_REG_VER, reg);
+		return -1;
+	}
+	dev_info(&max9286_data->i2c_client->dev, "%s: OV10635 index=%d was found.\n", __func__, index);
+
+	return 0;
+}
+
+static int ov10635_initialize(struct sensor_data *max9286_data, int index, int sensor_num)
+{
+	int i, array_size;
+	int retval;
+
+	dev_info(&max9286_data->i2c_client->dev, "%s: index = %d.\n", __func__, index);
+	array_size = ARRAY_SIZE(ov10635_init_data);
+	for (i = 0; i < array_size; i++) {
+		retval = ov10635_write_reg(max9286_data, index,
+					ov10635_init_data[i].reg_addr, ov10635_init_data[i].val);
+		if (retval < 0)
+			break;
+		if (ov10635_init_data[i].delay_ms != 0)
+			msleep(ov10635_init_data[i].delay_ms);
+	}
+
+	return 0;
+}
+#endif
+
+static inline int max9271_read_reg(struct sensor_data *max9286_data, int index, u8 reg)
+{
+	int val;
+	int retry, timeout = 10;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9271 + index;
+	for (retry = 0; retry < timeout; retry++) {
+		val = i2c_smbus_read_byte_data(max9286_data->i2c_client, reg);
+		if (val < 0)
+			msleep(5);
+		else
+			break;
+	}
+
+	if (retry >= timeout) {
+		dev_info(&max9286_data->i2c_client->dev,
+			"%s:read reg error: reg=%2x\n", __func__, reg);
+		return -1;
+	}
+
+	return val;
+}
+
+static int max9271_write_reg(struct sensor_data *max9286_data, int index, u8 reg, u8 val)
+{
+	s32 ret;
+	int retry, timeout = 10;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9271 + index;
+	for (retry = 0; retry < timeout; retry++) {
+		ret = i2c_smbus_write_byte_data(max9286_data->i2c_client, reg, val);
+		if (val < 0)
+			msleep(5);
+		else
+			break;
+	}
+	dev_dbg(&max9286_data->i2c_client->dev,
+		"%s: addr %02x reg %02x val %02x\n",
+		__func__, max9286_data->i2c_client->addr, reg, val);
+
+	if (retry >= timeout) {
+		dev_info(&max9286_data->i2c_client->dev,
+			"%s:write reg error:reg=%2x,val=%2x\n", __func__,
+			reg, val);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*! Read one register from a MAX9286 i2c slave device.
+ *
+ *  @param *reg		register in the device we wish to access.
+ *
+ *  @return		       0 if success, an error code otherwise.
+ */
+static inline int max9286_read_reg(struct sensor_data *max9286_data, u8 reg)
+{
+	int val;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9286;
+	val = i2c_smbus_read_byte_data(max9286_data->i2c_client, reg);
+	if (val < 0) {
+		dev_info(&max9286_data->i2c_client->dev,
+			"%s:read reg error: reg=%2x\n", __func__, reg);
+		return -1;
+	}
+	return val;
+}
+
+/*! Write one register of a MAX9286 i2c slave device.
+ *
+ *  @param *reg		register in the device we wish to access.
+ *
+ *  @return		       0 if success, an error code otherwise.
+ */
+static int max9286_write_reg(struct sensor_data *max9286_data, u8 reg, u8 val)
+{
+	s32 ret;
+
+	max9286_data->i2c_client->addr = ADDR_MAX9286;
+	ret = i2c_smbus_write_byte_data(max9286_data->i2c_client, reg, val);
+
+	dev_dbg(&max9286_data->i2c_client->dev,
+		"%s:  addr %02x reg %02x val %02x\n",
+		__func__, max9286_data->i2c_client->addr, reg, val);
+
+	if (ret < 0) {
+		dev_info(&max9286_data->i2c_client->dev,
+			"%s:write reg error:reg=%2x,val=%2x\n", __func__,
+			reg, val);
+		return -1;
+	}
+	return 0;
+}
+
+#ifdef debug
+static void max9271_dump_registers(struct sensor_data *max9286_data, int index)
+{
+	unsigned char i;
+	printk("max9271_dump_registers: index = %d.\r\n", index);
+	for (i = 0; i < 0x20; i++)
+		printk("MAX9271 Reg 0x%02x = 0x%x.\r\n", i, max9271_read_reg(max9286_data, index, i));
+}
+
+static void max9286_dump_registers(struct sensor_data *max9286_data)
+{
+	unsigned char i;
+	printk("Dump MAX9286 registers:\r\n");
+	for (i = 0; i < 0x72; i++)
+		printk("MAX9286 Reg 0x%02x = 0x%x.\r\n", i, max9286_read_reg(max9286_data, i));
+}
+#else
+static void max9271_dump_registers(struct sensor_data *max9286_data, int index)
+{
+}
+#endif
+
+static int max9286_hardware_preinit(struct sensor_data *max9286_data)
+{
+	u8 reg;
+
+	dev_info(&max9286_data->i2c_client->dev, "In %s()\n", __func__);
+
+	/* Disable CSI Output */
+	max9286_write_reg(max9286_data, 0x15, 0x03);
+
+	/* Enable PRBS test */
+	max9286_write_reg(max9286_data, 0x0E, 0x5F);
+	msleep(10);
+
+	/* Enable Custom Reverse Channel & First Pulse Length  STEP 1 */
+	max9286_write_reg(max9286_data, 0x3F, 0x4F);
+	msleep(2); /* STEP 2 */
+
+	/* Reverse Channel Amplitude to mid level and transition time */
+	max9286_write_reg(max9286_data, 0x3B, 0x1E); /* STEP 3 */
+	msleep(2); /* STEP 4 */
+
+	/* Enable MAX9271 Configuration Link */
+	max9271_write_reg(max9286_data, 0, 0x04, 0x43);  /* STEP 5 */
+	msleep(2);  /* STEP 6 */
+
+	/* Increase serializer reverse channel input thresholds */
+#ifdef CONFIG_SENSOR_OV10635
+	max9271_write_reg(max9286_data, 0, 0x08, 0x01);  /* STEP 7 */
+#endif
+#ifdef CONFIG_SENSOR_AP0101
+	/* Invert VSYNC */
+	max9271_write_reg(max9286_data, 0, 0x08, 0x81);
+#endif
+	msleep(2);  /* STEP 8 */
+
+	/* Reverse Channel Amplitude level */
+	max9286_write_reg(max9286_data, 0x3B, 0x19);  /* STEP 9 */
+	msleep(5);  /* STEP 10 */
+
+	/* Set YUV422 8 bits mode, Double Data Rate, 4 data lane */
+	max9286_write_reg(max9286_data, 0x12, 0xF3); /* STEP 12 */
+
+	max9286_write_reg(max9286_data, 0x01, 0x02); /* STEP 13 */
+	/* Enable All Link 0-3  */
+	max9286_write_reg(max9286_data, 0x00, 0xef); /* STEP 14 */
+
+	/* Frame Sync */
+#ifdef CONFIG_SENSOR_OV10635
+	/* Automatic Mode */
+	max9286_write_reg(max9286_data, 0x01, 0x02);/* STEP 13 */
+#endif
+#ifdef CONFIG_SENSOR_AP0101
+	/* Manual Mode */
+	max9286_write_reg(max9286_data, 0x01, 0x00);
+
+	max9286_write_reg(max9286_data, 0x63, 0x00);
+	max9286_write_reg(max9286_data, 0x64, 0x00);
+
+	max9286_write_reg(max9286_data, 0x06, 0x00);
+	max9286_write_reg(max9286_data, 0x07, 0x00);
+	max9286_write_reg(max9286_data, 0x08, 0x26);
+#endif
+	msleep(200);
+	/* Detect link */
+	max9286_data->sensor_num = 0;
+	reg = max9286_read_reg(max9286_data, 0x49);
+	max9286_data->sensor_is_there = ((reg >> 4) & 0xF) | (reg & 0xF);
+	if (max9286_data->sensor_is_there & (0x1 << 0))
+		max9286_data->sensor_num += 1;
+	if (max9286_data->sensor_is_there & (0x1 << 1))
+		max9286_data->sensor_num += 1;
+	if (max9286_data->sensor_is_there & (0x1 << 2))
+		max9286_data->sensor_num += 1;
+	if (max9286_data->sensor_is_there & (0x1 << 3))
+		max9286_data->sensor_num += 1;
+	pr_info("max9286_mipi: reg = 0x%02x.\n", reg);
+	pr_info("max9286_mipi: sensor number = %d.\n", max9286_data->sensor_num);
+
+	if (max9286_data->sensor_num == 0) {
+		pr_err("%s: no camera connected.\n", __func__);
+		return -1;
+	}
+	return 0;
+
+}
+static int max9286_hardware_init(struct sensor_data *max9286_data)
+{
+	int retval = 0;
+	int i;
+	u8 reg, sensor_addr = 0;
+
+	dev_info(&max9286_data->i2c_client->dev, "In %s()\n", __func__);
+
+	/* Disable PRBS test */
+	max9286_write_reg(max9286_data, 0x0E, 0x50);
+
+	/* Enable all links */
+	reg = 0xE0 | max9286_data->sensor_is_there;
+	max9286_write_reg(max9286_data, 0x00, reg);
+
+	/* Set up links */
+#ifdef CONFIG_SENSOR_OV10635
+	sensor_addr = ADDR_OV_SENSOR;
+#endif
+#ifdef CONFIG_SENSOR_AP0101
+	sensor_addr = ADDR_AP_SENSOR;
+#endif
+	max9271_write_reg(max9286_data, 0, 0x07, 0x84);
+	/* STEP 15-46 */
+	reg = 0;
+	for (i = 1; i <= MAX9271_MAX_SENSOR_NUM; i++) {
+		if (((0x1 << (i - 1)) & max9286_data->sensor_is_there) == 0)
+			continue;
+
+		/* Enable Link control channel */
+		reg |= (0x11 << (i - 1));
+		max9286_write_reg(max9286_data, 0x0A, reg);/* STEP 15 */
+
+		/* Set MAX9271 new address for link 0 */
+		max9271_write_reg(max9286_data, 0, 0x00, (ADDR_MAX9271 + i) << 1);
+		msleep(2);
+
+		max9271_write_reg(max9286_data, i, 0x01, ADDR_MAX9286 << 1);
+		max9271_write_reg(max9286_data, i, 0x09, (sensor_addr + i) << 1);
+		max9271_write_reg(max9286_data, i, 0x0A, sensor_addr << 1);
+		max9271_write_reg(max9286_data, i, 0x0B, ADDR_MAX9271_ALL << 1);
+		max9271_write_reg(max9286_data, i, 0x0C, (ADDR_MAX9271 + i) << 1);
+
+		msleep(1);
+		pr_info("max9286_mipi: initialized sensor  = 0x%02x.\n", i);
+		max9271_dump_registers(max9286_data, i);
+	}
+	max9286_write_reg(max9286_data, 0x0A, reg);
+	max9286_write_reg(max9286_data, 0x0A, reg);
+
+	/* Disable Local Auto I2C ACK */
+	max9286_write_reg(max9286_data, 0x34, 0x36); /* STEP 48 */
+
+	/* Initialize Camera Sensor */
+	/* STEP 49 */
+#ifdef CONFIG_SENSOR_OV10635
+	if (max9286_data->sensor_is_there & (0x1 << 0) &&
+			ov10635_check_device(max9286_data, 1) == 0)
+		ov10635_initialize(max9286_data, 0, max9286_data->sensor_num);
+
+	if (max9286_data->sensor_is_there & (0x1 << 1) &&
+			ov10635_check_device(max9286_data, 2) == 0)
+		ov10635_initialize(max9286_data, 1, max9286_data->sensor_num);
+
+	if (max9286_data->sensor_is_there & (0x1 << 2) &&
+			ov10635_check_device(max9286_data, 3) == 0)
+		ov10635_initialize(max9286_data, 2, max9286_data->sensor_num);
+
+	if (max9286_data->sensor_is_there & (0x1 << 3) &&
+			ov10635_check_device(max9286_data, 4) == 0)
+		ov10635_initialize(max9286_data, 3, max9286_data->sensor_num);
+#endif
+
+	/* Enable Local Auto I2C ACK */
+	max9286_write_reg(max9286_data, 0x34, 0xB6); /* STEP 50 */
+
+	/* MAX9271: Enable Serial Links and Disable Configuration Link */
+	max9271_write_reg(max9286_data, ADDR_MAX9271_ALL - ADDR_MAX9271, 0x04, 0x83); /* STEP 51 */
+	/* Wait for more than 2 frame time */
+	msleep(1000); /* STEP 52 */
+
+	/* Enable CSI output, set virtual channel according to the link number */
+	max9286_write_reg(max9286_data, 0x15, 0x9B); /* STEP 52 */
+	msleep(10);
+	return retval;
+}
+
+static int max9286_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	int ret = 0;
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability = max9286_data->streamcap.capability;
+		cparm->timeperframe = max9286_data->streamcap.timeperframe;
+		cparm->capturemode = max9286_data->streamcap.capturemode;
+		ret = 0;
+		break;
+
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/*!
+ * ioctl_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ */
+static int max9286_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	int ret = 0;
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		break;
+
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		pr_debug("   type is not "\
+				 "V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			a->type);
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int max9286_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	code->code = max9286_data->format.code;
+	return 0;
+}
+
+/*!
+ * max9286_enum_framesizes - V4L2 sensor interface handler for
+ *			   VIDIOC_ENUM_FRAMESIZES ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fsize: standard V4L2 VIDIOC_ENUM_FRAMESIZES ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int max9286_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	if (fse->index > 1)
+		return -EINVAL;
+
+	fse->max_width = max9286_data->format.width;
+	fse->min_width = fse->max_width;
+
+	fse->max_height = max9286_data->format.height;
+	fse->min_height = fse->max_height;
+	return 0;
+}
+
+static int max9286_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mf->code = max9286_data->format.code;
+	mf->width =  max9286_data->format.width;
+	mf->height = max9286_data->format.height;
+	mf->colorspace = max9286_data->format.colorspace;
+	mf->field = max9286_data->format.field;
+
+	return 0;
+}
+
+static int max9286_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *fmt)
+{
+	return 0;
+}
+
+static int max9286_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_mbus_frame_desc *fd)
+{
+	return 0;
+}
+
+static int max9286_set_frame_desc(struct v4l2_subdev *sd,
+					unsigned int pad,
+					struct v4l2_mbus_frame_desc *fd)
+{
+	return 0;
+}
+
+static int max9286_set_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int max9286_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	dev_dbg(sd->dev, "%s\n", __func__);
+	if (enable) {
+		if (!max9286_data->running) {
+			/* Enable CSI output, set virtual channel according to the link number */
+			max9286_write_reg(max9286_data, 0x15, 0x9B);
+		}
+		max9286_data->running++;
+
+	} else {
+
+		if (max9286_data->running) {
+			/* Disable CSI Output */
+			max9286_write_reg(max9286_data, 0x15, 0x03);
+		}
+		max9286_data->running--;
+	}
+
+	return 0;
+}
+
+static int max9286_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops max9286_pad_ops = {
+	.enum_mbus_code		= max9286_enum_mbus_code,
+	.enum_frame_size	= max9286_enum_framesizes,
+	.get_fmt		= max9286_get_fmt,
+	.set_fmt		= max9286_set_fmt,
+	.get_frame_desc		= max9286_get_frame_desc,
+	.set_frame_desc		= max9286_set_frame_desc,
+};
+
+static const struct v4l2_subdev_core_ops max9286_core_ops = {
+	.s_power	= max9286_set_power,
+};
+
+static const struct v4l2_subdev_video_ops max9286_video_ops = {
+	.s_parm =	max9286_s_parm,
+	.g_parm =	max9286_g_parm,
+	.s_stream		= max9286_s_stream,
+};
+
+static const struct v4l2_subdev_ops max9286_subdev_ops = {
+	.core	= &max9286_core_ops,
+	.pad	= &max9286_pad_ops,
+	.video	= &max9286_video_ops,
+};
+
+static const struct media_entity_operations max9286_sd_media_ops = {
+	.link_setup = max9286_link_setup,
+};
+
+/*!
+ * max9286 I2C probe function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int max9286_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct sensor_data *max9286_data;
+	struct v4l2_subdev *sd;
+	int retval;
+
+	max9286_data = devm_kzalloc(dev, sizeof(*max9286_data), GFP_KERNEL);
+	if (!max9286_data)
+		return -ENOMEM;
+
+	/* Set initial values for the sensor struct. */
+	max9286_data->sensor_clk = devm_clk_get(dev, "capture_mclk");
+	if (IS_ERR(max9286_data->sensor_clk)) {
+		/* assuming clock enabled by default */
+		max9286_data->sensor_clk = NULL;
+		dev_err(dev, "clock-frequency missing or invalid\n");
+		return PTR_ERR(max9286_data->sensor_clk);
+	}
+
+	retval = of_property_read_u32(dev->of_node, "mclk",
+		&(max9286_data->mclk));
+	if (retval) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return retval;
+	}
+
+	retval = of_property_read_u32(dev->of_node, "mclk_source",
+		(u32 *)&(max9286_data->mclk_source));
+	if (retval) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return retval;
+	}
+
+	clk_prepare_enable(max9286_data->sensor_clk);
+
+	max9286_data->i2c_client = client;
+	max9286_data->format.code = MEDIA_BUS_FMT_YUYV8_1X16;
+	max9286_data->format.width = g_max9286_width;
+	max9286_data->format.height = g_max9286_height;
+	max9286_data->format.colorspace = V4L2_COLORSPACE_JPEG;
+	max9286_data->format.field = V4L2_FIELD_NONE;
+	max9286_data->streamcap.capturemode = 0;
+	max9286_data->streamcap.timeperframe.denominator = 30;
+	max9286_data->streamcap.timeperframe.numerator = 1;
+	max9286_data->is_mipi = 1;
+
+	retval = max9286_read_reg(max9286_data, 0x1e);
+	if (retval != 0x40) {
+		pr_warning("max9286 is not found, chip id reg 0x1e = 0x%x.\n", retval);
+		clk_disable_unprepare(max9286_data->sensor_clk);
+		return -ENODEV;
+	}
+
+	max9286_hardware_preinit(max9286_data);
+
+	if  (max9286_data->sensor_num == 0) {
+		pr_warning("cameras are not found,\n");
+		clk_disable_unprepare(max9286_data->sensor_clk);
+		return -ENODEV;
+	}
+
+	max9286_data->streamcap.capability = V4L2_CAP_TIMEPERFRAME;
+	max9286_data->streamcap.timeperframe.denominator = 30;
+	max9286_data->streamcap.timeperframe.numerator = 1;
+	max9286_data->v_channel = 0;
+	max9286_data->cap_mode.clip_top = 0;
+	max9286_data->cap_mode.clip_left = 0;
+
+	max9286_data->cap_mode.clip_height = 800;
+	max9286_data->cap_mode.clip_width = 1280;
+
+	max9286_data->cap_mode.hlen = max9286_data->cap_mode.clip_width;
+
+	max9286_data->cap_mode.hfp = 0;
+	max9286_data->cap_mode.hbp = 0;
+	max9286_data->cap_mode.hsync = 625;
+	max9286_data->cap_mode.vlen = 800;
+	max9286_data->cap_mode.vfp = 0;
+	max9286_data->cap_mode.vbp = 0;
+	max9286_data->cap_mode.vsync = 40;
+	max9286_data->cap_mode.vlen1 = 0;
+	max9286_data->cap_mode.vfp1 = 0;
+	max9286_data->cap_mode.vbp1 = 0;
+	max9286_data->cap_mode.vsync1 = 0;
+	max9286_data->cap_mode.pixelclock = 27000000;
+
+	sd = &max9286_data->subdev;
+	v4l2_i2c_subdev_init(sd, client, &max9286_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	max9286_data->pads[MIPI_CSI2_SENS_VC0_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	max9286_data->pads[MIPI_CSI2_SENS_VC1_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	max9286_data->pads[MIPI_CSI2_SENS_VC2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	max9286_data->pads[MIPI_CSI2_SENS_VC3_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity, MIPI_CSI2_SENS_VCX_PADS_NUM,
+							max9286_data->pads);
+	if (retval < 0)
+		return retval;
+
+	max9286_data->subdev.entity.ops = &max9286_sd_media_ops;
+	retval = v4l2_async_register_subdev(&max9286_data->subdev);
+	if (retval < 0) {
+		dev_err(&client->dev,
+					"%s--Async register failed, ret=%d\n", __func__, retval);
+		media_entity_cleanup(&sd->entity);
+	}
+
+	max9286_hardware_init(max9286_data);
+
+	max9286_data->running = 0;
+
+	/* Disable CSI Output */
+	max9286_write_reg(max9286_data, 0x15, 0x03);
+
+	dev_info(&max9286_data->i2c_client->dev,
+			"max9286_mipi is found, name %s\n", sd->name);
+	return retval;
+}
+
+/*!
+ * max9286 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int max9286_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
+
+	clk_disable_unprepare(max9286_data->sensor_clk);
+	media_entity_cleanup(&sd->entity);
+	v4l2_async_unregister_subdev(sd);
+
+	return 0;
+}
+static const struct i2c_device_id max9286_id[] = {
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, max9286_id);
+
+static const struct of_device_id max9286_of_match[] = {
+	{ .compatible = "maxim,max9286_mipi" },
+	{ /* sentinel */ }
+};
+
+static struct i2c_driver max9286_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name   = "max9286_mipi",
+		.of_match_table	= of_match_ptr(max9286_of_match),
+	},
+	.probe  = max9286_probe,
+	.remove = max9286_remove,
+	.id_table = max9286_id,
+};
+
+module_i2c_driver(max9286_i2c_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MAX9286 GSML Deserializer Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_ALIAS("CSI");
diff --git a/drivers/media/platform/imx8/mxc-isi-cap.c b/drivers/media/platform/imx8/mxc-isi-cap.c
new file mode 100644
index 0000000..7ecf705
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-isi-cap.c
@@ -0,0 +1,1339 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/pm_runtime.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <soc/imx8/sc/sci.h>
+
+#include "mxc-isi-core.h"
+#include "mxc-isi-hw.h"
+#include "mxc-media-dev.h"
+
+struct mxc_isi_fmt mxc_isi_out_formats[] = {
+	{
+		.name		= "RGB565",
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_RGB565,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code  = MEDIA_BUS_FMT_RGB565_1X16,
+	}, {
+		.name		= "RGB24",
+		.fourcc		= V4L2_PIX_FMT_RGB24,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_XRGB32,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code  = MEDIA_BUS_FMT_RGB888_1X24,
+	}, {
+		.name		= "RGB32",
+		.fourcc		= V4L2_PIX_FMT_RGB32,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_XRGB32,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code  = MEDIA_BUS_FMT_RGB888_1X24,
+	}, {
+		.name		= "BGR24",
+		.fourcc		= V4L2_PIX_FMT_BGR24,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_XBGR32,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code  = MEDIA_BUS_FMT_BGR888_1X24,
+	}, {
+		.name		= "ARGB32",
+		.fourcc		= V4L2_PIX_FMT_ARGB32,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_ARGB32,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code  = MEDIA_BUS_FMT_ARGB8888_1X32,
+	}, {
+		.name		= "YUYV-16",
+		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_YUV422_1P8P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
+	}, {
+		.name		= "YUV32 (X-Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUV32,
+		.depth		= { 32 },
+		.color		= MXC_ISI_OUT_FMT_YUV444_1P8,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code	= MEDIA_BUS_FMT_AYUV8_1X32,
+	},
+};
+
+struct mxc_isi_fmt mxc_isi_src_formats[] = {
+	/* Pixel link input format */
+	{
+		.name		= "RGB32",
+		.fourcc		= V4L2_PIX_FMT_RGB32,
+		.depth		= { 32 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}, {
+		.name		= "YUV32 (X-Y-U-V)",
+		.fourcc		= V4L2_PIX_FMT_YUV32,
+		.depth		= { 32 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}
+};
+
+struct mxc_isi_fmt mxc_isi_m2m_in_formats[] = {
+	{
+		.name		= "RGB565",
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.depth		= { 16 },
+		.color		= MXC_ISI_M2M_IN_FMT_RGB565,
+		.memplanes	= 1,
+		.colplanes	= 1,
+	}, {
+		.name		= "YUV 4:2:2 packed, YCbYCr",
+		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.depth		= { 16 },
+		.color		= MXC_ISI_M2M_IN_FMT_YUV422_1P8P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
+	},
+};
+
+struct mxc_isi_fmt *mxc_isi_get_format(unsigned int index)
+{
+	return &mxc_isi_out_formats[index];
+}
+
+/**
+ * mxc_isi_find_format - lookup mxc_isi color format by fourcc or media bus format
+ */
+struct mxc_isi_fmt *mxc_isi_find_format(const u32 *pixelformat, const u32 *mbus_code,
+				  unsigned int mask, int index)
+{
+	struct mxc_isi_fmt *fmt, *def_fmt = NULL;
+	unsigned int i;
+	int id = 0;
+
+	if (index >= (int)ARRAY_SIZE(mxc_isi_out_formats))
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (!(fmt->flags & mask))
+			continue;
+		if (pixelformat && fmt->fourcc == *pixelformat)
+			return fmt;
+		if (mbus_code && fmt->mbus_code == *mbus_code)
+			return fmt;
+		if (index == id)
+			def_fmt = fmt;
+		id++;
+	}
+	return def_fmt;
+}
+
+struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
+{
+	u32 index;
+
+	/* two fmt RGB32 and YUV444 from pixellink */
+	if (sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_1X16)
+		index = 1;
+	else
+		index = 0;
+	return &mxc_isi_src_formats[index];
+}
+
+/*
+ * mxc_isi_pipeline_enable() - Enable streaming on a pipeline
+ *
+ */
+static int mxc_isi_pipeline_enable(struct mxc_isi_dev *mxc_isi, bool enable)
+{
+	struct media_entity *entity = &mxc_isi->isi_cap.vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_graph graph;
+	struct v4l2_subdev *subdev;
+	int ret = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	ret = media_graph_walk_init(&graph, entity->graph_obj.mdev);
+	if (ret) {
+		mutex_unlock(&mdev->graph_mutex);
+		return ret;
+	}
+	media_graph_walk_start(&graph, entity);
+
+	while ((entity = media_graph_walk_next(&graph))) {
+		if (entity == NULL) {
+			dev_dbg(&mxc_isi->pdev->dev,
+					"%s ,entity is NULL\n", __func__);
+			continue;
+		}
+
+		if (!is_media_entity_v4l2_subdev(entity)) {
+			dev_dbg(&mxc_isi->pdev->dev,
+					"%s ,entity is no v4l2, %s\n", __func__, entity->name);
+			continue;
+		}
+
+		subdev = media_entity_to_v4l2_subdev(entity);
+		if (subdev == NULL) {
+			dev_dbg(&mxc_isi->pdev->dev,
+					"%s ,%s,subdev is NULL\n", __func__, entity->name);
+			continue;
+		}
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, enable);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+	}
+	mutex_unlock(&mdev->graph_mutex);
+	media_graph_walk_cleanup(&graph);
+
+	return ret;
+}
+
+static int mxc_isi_update_buf_paddr(struct mxc_isi_buffer *buf, int memplanes)
+{
+	struct frame_addr *paddr = &buf->paddr;
+	struct vb2_buffer *vb2 = &buf->v4l2_buf.vb2_buf;
+	int ret = 0;
+
+	/* support one plane now */
+	paddr->cb = 0;
+	paddr->cr = 0;
+
+	switch (memplanes) {
+	case 3:
+		paddr->cr = vb2_dma_contig_plane_dma_addr(vb2, 2);
+	case 2:
+		paddr->cb = vb2_dma_contig_plane_dma_addr(vb2, 1);
+	case 1:
+		paddr->y = vb2_dma_contig_plane_dma_addr(vb2, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void mxc_isi_frame_write_done(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_buffer *buf;
+	struct vb2_buffer *vb2;
+
+	/* Retrun if no pending buffer */
+	if (!list_empty(&mxc_isi->isi_cap.out_active)) {
+
+		buf = list_first_entry(&mxc_isi->isi_cap.out_active,
+					struct mxc_isi_buffer, list);
+
+		list_del(&buf->list);
+		buf->v4l2_buf.vb2_buf.timestamp = ktime_get_ns();
+		buf->v4l2_buf.sequence = mxc_isi->isi_cap.frame_count++;
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_DONE);
+	}
+
+	if (!list_empty(&mxc_isi->isi_cap.out_pending)) {
+
+		/* ISI channel output buffer */
+		buf = list_first_entry(&mxc_isi->isi_cap.out_pending,
+						struct mxc_isi_buffer, list);
+		list_del(&buf->list);
+
+		buf->v4l2_buf.sequence = mxc_isi->isi_cap.frame_count;
+		mxc_isi_channel_set_outbuf(mxc_isi, buf);
+		vb2 = &buf->v4l2_buf.vb2_buf;
+		vb2->state = VB2_BUF_STATE_ACTIVE;
+		list_add_tail(&buf->list, &mxc_isi->isi_cap.out_active);
+	}
+}
+
+static int cap_vb2_queue_setup(struct vb2_queue *q,
+		       unsigned int *num_buffers, unsigned int *num_planes,
+		       unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct mxc_isi_dev *mxc_isi = q->drv_priv;
+	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
+	struct mxc_isi_fmt *fmt = dst_f->fmt;
+	unsigned long wh;
+	int i;
+
+	alloc_devs[0] = &mxc_isi->pdev->dev;
+	wh = dst_f->width * dst_f->height;
+
+	if (fmt == NULL)
+		return -EINVAL;
+
+	*num_planes = fmt->memplanes;
+
+	for (i = 0; i < fmt->memplanes; i++) {
+		unsigned int size = (wh * fmt->depth[i]) / 8;
+		sizes[i] = max_t(u32, size, dst_f->sizeimage[i]);
+	}
+	dev_dbg(&mxc_isi->pdev->dev, "%s, buf_n=%d, size=%d\n",
+					__func__,  *num_buffers, sizes[0]);
+
+	return 0;
+}
+
+static int cap_vb2_buffer_prepare(struct vb2_buffer *vb2)
+{
+	struct vb2_queue *q = vb2->vb2_queue;
+	struct mxc_isi_dev *mxc_isi = q->drv_priv;
+	struct mxc_isi_frame	*dst_f = &mxc_isi->isi_cap.dst_f;
+	int i;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	if (mxc_isi->isi_cap.dst_f.fmt == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < dst_f->fmt->memplanes; i++) {
+		unsigned long size = dst_f->sizeimage[i];
+
+		if (vb2_plane_size(vb2, i) < size) {
+			v4l2_err(&mxc_isi->isi_cap.vdev,
+				 "User buffer too small (%ld < %ld)\n",
+				 vb2_plane_size(vb2, i), size);
+			return -EINVAL;
+		}
+#if 0 //debug only
+		if (vb2_plane_vaddr(vb2, i))
+			memset((void *)vb2_plane_vaddr(vb2, i), 0xaa,
+					vb2_get_plane_payload(vb2, i));
+#endif
+		vb2_set_plane_payload(vb2, i, size);
+	}
+
+	return 0;
+}
+
+static void cap_vb2_buffer_queue(struct vb2_buffer *vb2)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb2);
+	struct mxc_isi_buffer *buf
+			= container_of(v4l2_buf, struct mxc_isi_buffer, v4l2_buf);
+	struct mxc_isi_dev *mxc_isi = vb2_get_drv_priv(vb2->vb2_queue);
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+
+	mxc_isi_update_buf_paddr(buf, mxc_isi->isi_cap.dst_f.fmt->mdataplanes);
+	list_add_tail(&buf->list, &mxc_isi->isi_cap.out_pending);
+
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+}
+
+
+static int cap_vb2_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct mxc_isi_dev *mxc_isi = q->drv_priv;
+	struct mxc_isi_buffer *buf;
+	struct vb2_buffer *vb2;
+	unsigned long flags;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+
+	mxc_isi->isi_cap.frame_count = 0;
+
+	/* ISI channel output buffer 1 */
+	buf = list_first_entry(&mxc_isi->isi_cap.out_pending,
+					struct mxc_isi_buffer, list);
+	buf->v4l2_buf.sequence = 0;
+	mxc_isi_channel_set_outbuf(mxc_isi, buf);
+	vb2 = &buf->v4l2_buf.vb2_buf;
+	vb2->state = VB2_BUF_STATE_ACTIVE;
+	list_move_tail(mxc_isi->isi_cap.out_pending.next, &mxc_isi->isi_cap.out_active);
+
+	/* ISI channel output buffer 2 */
+	buf = list_first_entry(&mxc_isi->isi_cap.out_pending,
+					struct mxc_isi_buffer, list);
+	buf->v4l2_buf.sequence = 1;
+	mxc_isi_channel_set_outbuf(mxc_isi, buf);
+	vb2 = &buf->v4l2_buf.vb2_buf;
+	vb2->state = VB2_BUF_STATE_ACTIVE;
+	list_move_tail(mxc_isi->isi_cap.out_pending.next, &mxc_isi->isi_cap.out_active);
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+
+	return 0;
+}
+
+
+static void cap_vb2_stop_streaming(struct vb2_queue *q)
+{
+	struct mxc_isi_dev *mxc_isi = q->drv_priv;
+	struct mxc_isi_buffer *buf, *tmp;
+	unsigned long flags;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	mxc_isi_channel_disable(mxc_isi);
+
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+
+	while (!list_empty(&mxc_isi->isi_cap.out_active)) {
+		buf = list_entry(mxc_isi->isi_cap.out_active.next, struct mxc_isi_buffer, list);
+
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	while (!list_empty(&mxc_isi->isi_cap.out_pending)) {
+		buf = list_entry(mxc_isi->isi_cap.out_pending.next, struct mxc_isi_buffer, list);
+
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	list_for_each_entry_safe(buf, tmp,
+				&mxc_isi->isi_cap.out_active, list) {
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	list_for_each_entry_safe(buf, tmp,
+				&mxc_isi->isi_cap.out_pending, list) {
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+
+	INIT_LIST_HEAD(&mxc_isi->isi_cap.out_active);
+	INIT_LIST_HEAD(&mxc_isi->isi_cap.out_pending);
+
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+}
+
+static struct vb2_ops mxc_cap_vb2_qops = {
+	.queue_setup		= cap_vb2_queue_setup,
+	.buf_prepare		= cap_vb2_buffer_prepare,
+	.buf_queue			= cap_vb2_buffer_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= cap_vb2_start_streaming,
+	.stop_streaming		= cap_vb2_stop_streaming,
+};
+
+/*
+ * V4L2 controls handling
+ */
+#define ctrl_to_mxc_isi(__ctrl) \
+	container_of((__ctrl)->handler, struct mxc_isi_dev, ctrls.handler)
+
+static int mxc_isi_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mxc_isi_dev *mxc_isi = ctrl_to_mxc_isi(ctrl);
+	unsigned long flags;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	if (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)
+		return 0;
+
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		mxc_isi->hflip = ctrl->val;
+		break;
+
+	case V4L2_CID_VFLIP:
+		mxc_isi->vflip = ctrl->val;
+		break;
+
+	case V4L2_CID_ALPHA_COMPONENT:
+		mxc_isi->alpha = ctrl->val;
+		break;
+	}
+
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mxc_isi_ctrl_ops = {
+	.s_ctrl = mxc_isi_s_ctrl,
+};
+
+int mxc_isi_ctrls_create(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_ctrls *ctrls = &mxc_isi->ctrls;
+	struct v4l2_ctrl_handler *handler = &ctrls->handler;
+
+	if (mxc_isi->ctrls.ready)
+		return 0;
+
+	v4l2_ctrl_handler_init(handler, 4);
+
+	ctrls->hflip = v4l2_ctrl_new_std(handler, &mxc_isi_ctrl_ops,
+					V4L2_CID_HFLIP, 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(handler, &mxc_isi_ctrl_ops,
+					V4L2_CID_VFLIP, 0, 1, 1, 0);
+
+	ctrls->alpha = v4l2_ctrl_new_std(handler, &mxc_isi_ctrl_ops,
+					V4L2_CID_ALPHA_COMPONENT, 0, 0xff, 1, 0);
+
+	if (!handler->error)
+		ctrls->ready = true;
+
+	return handler->error;
+}
+
+void mxc_isi_ctrls_delete(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_ctrls *ctrls = &mxc_isi->ctrls;
+
+	if (ctrls->ready) {
+		v4l2_ctrl_handler_free(&ctrls->handler);
+		ctrls->ready = false;
+		ctrls->alpha = NULL;
+	}
+}
+
+static int mxc_isi_capture_open(struct file *file)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	int ret = -EBUSY;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s, ISI%d\n", __func__, mxc_isi->id);
+
+	mutex_lock(&mxc_isi->lock);
+	ret = v4l2_fh_open(file);
+	mutex_unlock(&mxc_isi->lock);
+
+	mxc_isi_channel_init(mxc_isi);
+	return 0;
+}
+
+static int mxc_isi_capture_release(struct file *file)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	int ret;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	mutex_lock(&mxc_isi->lock);
+	ret = _vb2_fop_release(file, NULL);
+	mutex_unlock(&mxc_isi->lock);
+	mxc_isi_channel_deinit(mxc_isi);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations mxc_isi_capture_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mxc_isi_capture_open,
+	.release	= mxc_isi_capture_release,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap		= vb2_fop_mmap,
+};
+
+/*
+ * Format and crop negotiation helpers
+ */
+
+/*
+ * The video node ioctl operations
+ */
+static int mxc_isi_cap_querycap(struct file *file, void *priv,
+					struct v4l2_capability *cap)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+
+	strlcpy(cap->driver, MXC_ISI_DRIVER_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, MXC_ISI_DRIVER_NAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s.%d",
+		 dev_name(&mxc_isi->pdev->dev), mxc_isi->id);
+
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int mxc_isi_cap_enum_fmt_mplane(struct file *file, void *priv,
+				    struct v4l2_fmtdesc *f)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct mxc_isi_fmt *fmt;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+	if (f->index >= (int)ARRAY_SIZE(mxc_isi_out_formats))
+		return -EINVAL;
+
+	fmt = &mxc_isi_out_formats[f->index];
+	if (!fmt)
+		return -EINVAL;
+
+	strncpy(f->description, fmt->name, sizeof(f->description) - 1);
+
+	f->pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int mxc_isi_cap_g_fmt_mplane(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
+	int i;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	pix->width = dst_f->o_width;
+	pix->height = dst_f->o_height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->pixelformat = dst_f->fmt->fourcc;
+	pix->colorspace = V4L2_COLORSPACE_JPEG;
+	pix->num_planes = dst_f->fmt->memplanes;
+
+	for (i = 0; i < pix->num_planes; ++i) {
+		pix->plane_fmt[i].bytesperline = dst_f->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = dst_f->sizeimage[i];
+	}
+	return 0;
+}
+
+
+static int mxc_isi_cap_try_fmt_mplane(struct file *file, void *fh,
+				   struct v4l2_format *f)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_fmt *fmt;
+	int i;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (fmt->fourcc == pix->pixelformat && fmt->memplanes == pix->num_planes)
+			break;
+	}
+	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static struct media_pad *mxc_isi_get_remote_source_pad(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_cap_dev *isi_cap = &mxc_isi->isi_cap;
+	struct v4l2_subdev *subdev = &isi_cap->sd;
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote pad found!\n", __func__);
+
+	return NULL;
+}
+
+/* Update input frame size and formate  */
+static int mxc_isi_source_fmt_init(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_frame *src_f = &mxc_isi->isi_cap.src_f;
+	struct v4l2_subdev_format src_fmt;
+	struct media_pad *source_pad;
+	struct v4l2_subdev *src_sd;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = mxc_isi_get_remote_source_pad(mxc_isi);
+	if (source_pad == NULL) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	src_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (src_sd == NULL) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	src_fmt.pad = source_pad->index;
+	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(src_sd, pad, get_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return -EINVAL;
+
+	/* Pixel link master will transfer format to RGB32 or YUV32 */
+	src_f->fmt = mxc_isi_get_src_fmt(&src_fmt);
+
+	set_frame_bounds(src_f, src_fmt.format.width, src_fmt.format.height);
+
+	return 0;
+}
+
+static int mxc_isi_cap_s_fmt_mplane(struct file *file, void *priv,
+				 struct v4l2_format *f)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
+	struct mxc_isi_fmt *fmt;
+	int i;
+
+	/* Step1: Check format with output support format list.
+	 * Step2: Update output frame information.
+	 * Step3: Checkout the format whether is supported by remote subdev
+	 *	 Step3.1: If Yes, call remote subdev set_fmt.
+	 *	 Step3.2: If NO, call remote subdev get_fmt.
+	 * Step4: Update input frame information.
+	 * Step5: Update mxc isi channel configuration.
+	 * */
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s, fmt=0x%X\n", __func__, pix->pixelformat);
+	if (vb2_is_busy(&mxc_isi->isi_cap.vb2_q)) {
+		return -EBUSY;
+	}
+
+	/* Check out put format */
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
+		fmt = &mxc_isi_out_formats[i];
+		if (fmt->fourcc == pix->pixelformat && fmt->memplanes == pix->num_planes)
+			break;
+	}
+	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
+		dev_dbg(&mxc_isi->pdev->dev, "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* update out put frame size and formate */
+	if (pix->height <= 0 || pix->width <= 0)
+		return -EINVAL;
+
+	dst_f->fmt = fmt;
+	dst_f->height = pix->height;
+	dst_f->width = pix->width;
+
+	if (pix->num_planes > 1) {
+		for (i = 0; i < pix->num_planes; i++) {
+			dst_f->bytesperline[i] = pix->plane_fmt[i].bytesperline;
+			dst_f->sizeimage[i] = pix->plane_fmt[i].sizeimage;
+		}
+	} else {
+		dst_f->bytesperline[0] = dst_f->width * dst_f->fmt->depth[0] / 8;
+		dst_f->sizeimage[0] = dst_f->height * dst_f->bytesperline[0];
+	}
+
+	set_frame_bounds(dst_f, pix->width, pix->height);
+
+	mxc_isi_source_fmt_init(mxc_isi);
+
+	/* configure mxc isi channel */
+	mxc_isi_channel_config(mxc_isi);
+
+	return 0;
+}
+
+static int mxc_isi_cap_streamon(struct file *file, void *priv,
+			     enum v4l2_buf_type type)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	int ret;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+	mxc_isi_pipeline_enable(mxc_isi, 1);
+
+	ret = vb2_ioctl_streamon(file, priv, type);
+
+	mxc_isi_channel_enable(mxc_isi);
+
+	return ret;
+}
+
+static int mxc_isi_cap_streamoff(struct file *file, void *priv,
+			    enum v4l2_buf_type type)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	int ret;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+	mxc_isi_pipeline_enable(mxc_isi, 0);
+
+	ret = vb2_ioctl_streamoff(file, priv, type);
+	mxc_isi_channel_disable(mxc_isi);
+	return ret;
+}
+
+static int mxc_isi_cap_g_selection(struct file *file, void *fh,
+				struct v4l2_selection *s)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct mxc_isi_frame *f = &mxc_isi->isi_cap.src_f;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		f = &mxc_isi->isi_cap.dst_f;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = f->o_width;
+		s->r.height = f->o_height;
+		return 0;
+
+	case V4L2_SEL_TGT_COMPOSE:
+		f = &mxc_isi->isi_cap.dst_f;
+	case V4L2_SEL_TGT_CROP:
+		s->r.left = f->h_off;
+		s->r.top = f->v_off;
+		s->r.width = f->width;
+		s->r.height = f->height;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)
+{
+	if (a->left < b->left || a->top < b->top)
+		return 0;
+
+	if (a->left + a->width > b->left + b->width)
+		return 0;
+
+	if (a->top + a->height > b->top + b->height)
+		return 0;
+
+	return 1;
+}
+static int mxc_isi_cap_s_selection(struct file *file, void *fh,
+				struct v4l2_selection *s)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct mxc_isi_frame *f;
+	struct v4l2_rect rect = s->r;
+	unsigned long flags;
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	if (s->target == V4L2_SEL_TGT_COMPOSE)
+		f = &mxc_isi->isi_cap.dst_f;
+	else if (s->target == V4L2_SEL_TGT_CROP)
+		f = &mxc_isi->isi_cap.src_f;
+	else
+		return -EINVAL;
+
+	if (s->flags & V4L2_SEL_FLAG_LE &&
+	    !enclosed_rectangle(&rect, &s->r))
+		return -ERANGE;
+
+	if (s->flags & V4L2_SEL_FLAG_GE &&
+	    !enclosed_rectangle(&s->r, &rect))
+		return -ERANGE;
+
+	s->r = rect;
+	spin_lock_irqsave(&mxc_isi->slock, flags);
+	set_frame_crop(f, s->r.left, s->r.top, s->r.width,
+		       s->r.height);
+	spin_unlock_irqrestore(&mxc_isi->slock, flags);
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
+	.vidioc_querycap		= mxc_isi_cap_querycap,
+
+	.vidioc_enum_fmt_vid_cap_mplane	= mxc_isi_cap_enum_fmt_mplane,
+	.vidioc_try_fmt_vid_cap_mplane	= mxc_isi_cap_try_fmt_mplane,
+	.vidioc_s_fmt_vid_cap_mplane	= mxc_isi_cap_s_fmt_mplane,
+	.vidioc_g_fmt_vid_cap_mplane	= mxc_isi_cap_g_fmt_mplane,
+
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_expbuf			= vb2_ioctl_expbuf,
+	.vidioc_prepare_buf		= vb2_ioctl_prepare_buf,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+
+	.vidioc_streamon		= mxc_isi_cap_streamon,
+	.vidioc_streamoff		= mxc_isi_cap_streamoff,
+
+	.vidioc_g_selection		= mxc_isi_cap_g_selection,
+	.vidioc_s_selection		= mxc_isi_cap_s_selection,
+};
+
+/* Capture subdev media entity operations */
+static int mxc_isi_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+
+	if (WARN_ON(mxc_isi == NULL))
+		return 0;
+
+	if (!(flags & MEDIA_LNK_FL_ENABLED)) {
+		return 0;
+	}
+	/* TODO */
+	/* Add ISI source and sink pad link configuration */
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		switch (local->index) {
+		case MXC_ISI_SD_PAD_SOURCE_DC0:
+		case MXC_ISI_SD_PAD_SOURCE_DC1:
+			break;
+		case MXC_ISI_SD_PAD_SOURCE_MEM:
+		default:
+			return 0;
+		}
+	} else if (local->flags & MEDIA_PAD_FL_SINK) {
+		switch (local->index) {
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC0:
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC1:
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC2:
+		case MXC_ISI_SD_PAD_SINK_MIPI0_VC3:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC0:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC1:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC2:
+		case MXC_ISI_SD_PAD_SINK_MIPI1_VC3:
+		case MXC_ISI_SD_PAD_SINK_HDMI:
+		case MXC_ISI_SD_PAD_SINK_DC0:
+		case MXC_ISI_SD_PAD_SINK_DC1:
+		case MXC_ISI_SD_PAD_SINK_MEM:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static const struct media_entity_operations mxc_isi_sd_media_ops = {
+	.link_setup = mxc_isi_link_setup,
+};
+
+static int mxc_isi_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_pad_config *cfg,
+				      struct v4l2_subdev_mbus_code_enum *code)
+{
+	return 0;
+}
+
+static int mxc_isi_subdev_get_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+	struct mxc_isi_frame *f;
+	struct v4l2_mbus_framefmt *mf;
+
+	mutex_lock(&mxc_isi->lock);
+
+	switch (fmt->pad) {
+	case MXC_ISI_SD_PAD_SOURCE_MEM:
+	case MXC_ISI_SD_PAD_SOURCE_DC0:
+	case MXC_ISI_SD_PAD_SOURCE_DC1:
+		f = &mxc_isi->isi_cap.dst_f;
+		break;
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC0:
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC1:
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC2:
+	case MXC_ISI_SD_PAD_SINK_MIPI0_VC3:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC0:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC1:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC2:
+	case MXC_ISI_SD_PAD_SINK_MIPI1_VC3:
+	case MXC_ISI_SD_PAD_SINK_HDMI:
+	case MXC_ISI_SD_PAD_SINK_DC0:
+	case MXC_ISI_SD_PAD_SINK_DC1:
+	case MXC_ISI_SD_PAD_SINK_MEM:
+		f = &mxc_isi->isi_cap.src_f;
+		break;
+	default:
+		mutex_unlock(&mxc_isi->lock);
+		v4l2_err(mxc_isi->v4l2_dev, "%s, Pad is not support now!\n", __func__);
+		return -1;
+	}
+
+	if (!WARN_ON(f->fmt == NULL))
+		mf->code = f->fmt->mbus_code;
+
+	/* Source/Sink pads crop rectangle size */
+	mf->width = f->width;
+	mf->height = f->height;
+
+	mutex_unlock(&mxc_isi->lock);
+	mf->colorspace = V4L2_COLORSPACE_JPEG;
+
+	return 0;
+}
+
+static int mxc_isi_subdev_set_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
+	struct mxc_isi_fmt *out_fmt;
+	int i;
+
+	if (fmt->pad < MXC_ISI_SD_PAD_SOURCE_MEM &&
+					vb2_is_busy(&mxc_isi->isi_cap.vb2_q))
+		return -EBUSY;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_isi_out_formats); i++) {
+		out_fmt = &mxc_isi_out_formats[i];
+		if (mf->code == out_fmt->mbus_code)
+			break;
+	}
+	if (i >= ARRAY_SIZE(mxc_isi_out_formats)) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, format is not support!\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&mxc_isi->lock);
+	/* update out put frame size and formate */
+	dst_f->fmt = &mxc_isi_out_formats[i];
+	set_frame_bounds(dst_f, mf->width, mf->height);
+	mutex_unlock(&mxc_isi->lock);
+
+	dev_dbg(&mxc_isi->pdev->dev, "pad%d: code: 0x%x, %dx%d",
+	    fmt->pad, mf->code, mf->width, mf->height);
+
+	return 0;
+}
+
+static int mxc_isi_subdev_get_selection(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_pad_config *cfg,
+				     struct v4l2_subdev_selection *sel)
+{
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+	struct mxc_isi_frame *f = &mxc_isi->isi_cap.src_f;
+	struct v4l2_rect *r = &sel->r;
+	struct v4l2_rect *try_sel;
+
+	mutex_lock(&mxc_isi->lock);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		f = &mxc_isi->isi_cap.dst_f;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		r->width = f->o_width;
+		r->height = f->o_height;
+		r->left = 0;
+		r->top = 0;
+		mutex_unlock(&mxc_isi->lock);
+		return 0;
+
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, cfg, sel->pad);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		try_sel = v4l2_subdev_get_try_compose(sd, cfg, sel->pad);
+		f = &mxc_isi->isi_cap.dst_f;
+		break;
+	default:
+		mutex_unlock(&mxc_isi->lock);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY) {
+		sel->r = *try_sel;
+	} else {
+		r->left = f->h_off;
+		r->top = f->v_off;
+		r->width = f->width;
+		r->height = f->height;
+	}
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s, target %#x: l:%d, t:%d, %dx%d, f_w: %d, f_h: %d",
+			__func__, sel->pad, r->left, r->top, r->width, r->height,
+			f->c_width, f->c_height);
+
+	mutex_unlock(&mxc_isi->lock);
+	return 0;
+}
+
+static int mxc_isi_subdev_set_selection(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_pad_config *cfg,
+				     struct v4l2_subdev_selection *sel)
+{
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+	struct mxc_isi_frame *f = &mxc_isi->isi_cap.src_f;
+	struct v4l2_rect *r = &sel->r;
+	struct v4l2_rect *try_sel;
+	unsigned long flags;
+
+	mutex_lock(&mxc_isi->lock);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, cfg, sel->pad);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		try_sel = v4l2_subdev_get_try_compose(sd, cfg, sel->pad);
+		f = &mxc_isi->isi_cap.dst_f;
+		break;
+	default:
+		mutex_unlock(&mxc_isi->lock);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*try_sel = sel->r;
+	} else {
+		spin_lock_irqsave(&mxc_isi->slock, flags);
+		set_frame_crop(f, r->left, r->top, r->width, r->height);
+		spin_unlock_irqrestore(&mxc_isi->slock, flags);
+	}
+
+	dev_dbg(&mxc_isi->pdev->dev, "%s, target %#x: (%d,%d)/%dx%d", __func__,
+			sel->target, r->left, r->top, r->width, r->height);
+
+	mutex_unlock(&mxc_isi->lock);
+
+	return 0;
+}
+
+static struct v4l2_subdev_pad_ops mxc_isi_subdev_pad_ops = {
+	.enum_mbus_code = mxc_isi_subdev_enum_mbus_code,
+	.get_selection = mxc_isi_subdev_get_selection,
+	.set_selection = mxc_isi_subdev_set_selection,
+	.get_fmt = mxc_isi_subdev_get_fmt,
+	.set_fmt = mxc_isi_subdev_set_fmt,
+};
+
+static struct v4l2_subdev_ops mxc_isi_subdev_ops = {
+	.pad = &mxc_isi_subdev_pad_ops,
+};
+
+static int mxc_isi_register_cap_device(struct mxc_isi_dev *mxc_isi,
+				 struct v4l2_device *v4l2_dev)
+{
+	struct video_device *vdev = &mxc_isi->isi_cap.vdev;
+	struct vb2_queue *q = &mxc_isi->isi_cap.vb2_q;
+	struct mxc_isi_cap_dev *isi_cap = &mxc_isi->isi_cap;
+	int ret = -ENOMEM;
+
+	snprintf(vdev->name, sizeof(vdev->name), "mxc_isi.%d.capture", mxc_isi->id);
+	memset(vdev, 0, sizeof(*vdev));
+
+	vdev->fops	= &mxc_isi_capture_fops;
+	vdev->ioctl_ops	= &mxc_isi_capture_ioctl_ops;
+	vdev->v4l2_dev	= v4l2_dev;
+	vdev->minor	= -1;
+	vdev->release	= video_device_release_empty;
+	vdev->queue	= q;
+	vdev->lock	= &mxc_isi->lock;
+
+	video_set_drvdata(vdev, mxc_isi);
+
+	INIT_LIST_HEAD(&mxc_isi->isi_cap.out_pending);
+	INIT_LIST_HEAD(&mxc_isi->isi_cap.out_active);
+
+	memset(q, 0, sizeof(*q));
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	q->drv_priv = mxc_isi;
+	q->ops = &mxc_cap_vb2_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->buf_struct_size = sizeof(struct mxc_isi_buffer);
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->lock = &mxc_isi->lock;
+
+	ret = vb2_queue_init(q);
+	if (ret)
+		goto err_free_ctx;
+
+	/* Default configuration  */
+	isi_cap->dst_f.width = 1280;
+	isi_cap->dst_f.height = 800;
+	isi_cap->dst_f.fmt = &mxc_isi_out_formats[0];;
+	isi_cap->src_f.fmt = isi_cap->dst_f.fmt;
+
+	isi_cap->cap_pad.flags = MEDIA_PAD_FL_SINK;
+	vdev->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;
+	ret = media_entity_pads_init(&vdev->entity, 1, &isi_cap->cap_pad);
+	if (ret)
+		goto err_free_ctx;
+
+	ret = mxc_isi_ctrls_create(mxc_isi);
+	if (ret)
+		goto err_me_cleanup;
+
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret)
+		goto err_ctrl_free;
+
+	vdev->ctrl_handler = &mxc_isi->ctrls.handler;
+	v4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",
+		  vdev->name, video_device_node_name(vdev));
+
+	return 0;
+
+err_ctrl_free:
+	mxc_isi_ctrls_delete(mxc_isi);
+err_me_cleanup:
+	media_entity_cleanup(&vdev->entity);
+err_free_ctx:
+	return ret;
+}
+
+static int mxc_isi_capture_subdev_registered(struct v4l2_subdev *sd)
+{
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (mxc_isi == NULL)
+		return -ENXIO;
+
+#if 0
+	if (mxc_isi->id == 0) {
+		/* ISI channel 0 support source input image from memory  */
+		ret = mxc_isi_register_m2m_device(mxc_isi, sd->v4l2_dev);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+
+	ret = mxc_isi_register_cap_device(mxc_isi, sd->v4l2_dev);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static void mxc_isi_capture_subdev_unregistered(struct v4l2_subdev *sd)
+{
+	struct mxc_isi_dev *mxc_isi = v4l2_get_subdevdata(sd);
+	struct video_device *vdev;
+
+	if (mxc_isi == NULL)
+		return;
+
+	mutex_lock(&mxc_isi->lock);
+
+	vdev = &mxc_isi->isi_cap.vdev;
+	if (video_is_registered(vdev)) {
+		video_unregister_device(vdev);
+		mxc_isi_ctrls_delete(mxc_isi);
+		media_entity_cleanup(&vdev->entity);
+	}
+
+	mutex_unlock(&mxc_isi->lock);
+}
+
+static const struct v4l2_subdev_internal_ops mxc_isi_capture_sd_internal_ops = {
+	.registered = mxc_isi_capture_subdev_registered,
+	.unregistered = mxc_isi_capture_subdev_unregistered,
+};
+
+int mxc_isi_initialize_capture_subdev(struct mxc_isi_dev *mxc_isi)
+{
+	struct v4l2_subdev *sd = &mxc_isi->isi_cap.sd;
+	int ret;
+
+	v4l2_subdev_init(sd, &mxc_isi_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	snprintf(sd->name, sizeof(sd->name), "mxc_isi.%d", mxc_isi->id);
+
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+
+	/* ISI Sink pads */
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC0].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC1].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC2].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI0_VC3].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC0].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC1].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC2].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MIPI1_VC3].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_DC0].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_DC1].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_HDMI].flags = MEDIA_PAD_FL_SINK;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SINK_MEM].flags = MEDIA_PAD_FL_SINK;
+
+	/* ISI source pads */
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SOURCE_MEM].flags = MEDIA_PAD_FL_SOURCE;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SOURCE_DC0].flags = MEDIA_PAD_FL_SOURCE;
+	mxc_isi->isi_cap.sd_pads[MXC_ISI_SD_PAD_SOURCE_DC1].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, MXC_ISI_SD_PADS_NUM,
+				mxc_isi->isi_cap.sd_pads);
+	if (ret)
+		return ret;
+
+	sd->entity.ops = &mxc_isi_sd_media_ops;
+	sd->internal_ops = &mxc_isi_capture_sd_internal_ops;
+	v4l2_set_subdevdata(sd, mxc_isi);
+
+	return 0;
+}
+
+void mxc_isi_unregister_capture_subdev(struct mxc_isi_dev *mxc_isi)
+{
+	struct v4l2_subdev *sd = &mxc_isi->isi_cap.sd;
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_set_subdevdata(sd, NULL);
+}
diff --git a/drivers/media/platform/imx8/mxc-isi-core.c b/drivers/media/platform/imx8/mxc-isi-core.c
new file mode 100644
index 0000000..fca1496
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-isi-core.c
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "mxc-media-dev.h"
+
+static irqreturn_t mxc_isi_irq_handler(int irq, void *priv)
+{
+	struct mxc_isi_dev *mxc_isi = priv;
+	u32 status;
+
+	spin_lock(&mxc_isi->slock);
+
+	status = mxc_isi_get_irq_status(mxc_isi);
+	mxc_isi_clean_irq_status(mxc_isi, status);
+
+	if (status & CHNL_STS_FRM_STRD_MASK)
+		mxc_isi_frame_write_done(mxc_isi);
+
+	if (status & (CHNL_STS_AXI_WR_ERR_Y_MASK |
+					CHNL_STS_AXI_WR_ERR_U_MASK |
+					CHNL_STS_AXI_WR_ERR_V_MASK))
+		printk("%s, IRQ AXI Error stat=0x%X\n", __func__, status);
+	if (status & (CHNL_STS_OFLW_PANIC_Y_BUF_MASK |
+					CHNL_STS_OFLW_PANIC_U_BUF_MASK |
+					CHNL_STS_OFLW_PANIC_V_BUF_MASK))
+		printk("%s, IRQ Panic OFLW Error stat=0x%X\n", __func__, status);
+	if (status & (CHNL_STS_OFLW_Y_BUF_MASK |
+					CHNL_STS_OFLW_U_BUF_MASK |
+					CHNL_STS_OFLW_V_BUF_MASK))
+		printk("%s, IRQ OFLW Error stat=0x%X\n", __func__, status);
+	if (status & (CHNL_STS_EXCS_OFLW_Y_BUF_MASK |
+					CHNL_STS_EXCS_OFLW_U_BUF_MASK |
+					CHNL_STS_EXCS_OFLW_V_BUF_MASK))
+		printk("%s, IRQ EXCS OFLW Error stat=0x%X\n", __func__, status);
+
+	spin_unlock(&mxc_isi->slock);
+	return IRQ_HANDLED;
+}
+
+/**
+ * mxc_isi_adjust_mplane_format - adjust bytesperline or sizeimage
+ */
+void mxc_isi_adjust_mplane_format(struct mxc_isi_fmt *fmt, u32 width, u32 height,
+			       struct v4l2_pix_format_mplane *pix)
+{
+	u32 bytesperline = 0;
+	int i;
+
+	pix->colorspace	= V4L2_COLORSPACE_JPEG;
+	pix->field = V4L2_FIELD_NONE;
+	pix->num_planes = fmt->memplanes;
+	pix->pixelformat = fmt->fourcc;
+	pix->height = height;
+	pix->width = width;
+
+	for (i = 0; i < pix->num_planes; ++i) {
+		struct v4l2_plane_pix_format *plane_fmt = &pix->plane_fmt[i];
+		u32 bpl = plane_fmt->bytesperline;
+
+		if (fmt->colplanes > 1 && (bpl == 0 || bpl < pix->width))
+			bpl = pix->width; /* Planar */
+
+		if (fmt->colplanes == 1 && /* Packed */
+		    (bpl == 0 || ((bpl * 8) / fmt->depth[i]) < pix->width))
+			bpl = (pix->width * fmt->depth[0]) / 8;
+
+		if (i == 0)
+			bytesperline = bpl;
+		else if (i == 1 && fmt->memplanes == 3)
+			bytesperline /= 2;
+
+		plane_fmt->bytesperline = bytesperline;
+		plane_fmt->sizeimage = max((pix->width * pix->height *
+				   fmt->depth[i]) / 8, plane_fmt->sizeimage);
+	}
+}
+
+static int mxc_isi_parse_dt(struct mxc_isi_dev *mxc_isi)
+{
+	struct device *dev = &mxc_isi->pdev->dev;
+	struct device_node *node = dev->of_node;
+	int ret = 0;
+
+	mxc_isi->id = of_alias_get_id(node, "isi");
+
+	ret = of_property_read_u32_array(node, "interface",
+			mxc_isi->interface, 3);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(dev, "%s, isi_%d,interface(%d, %d, %d)\n", __func__, mxc_isi->id,
+			mxc_isi->interface[0], mxc_isi->interface[1], mxc_isi->interface[2]);
+	return 0;
+}
+
+static int mxc_isi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mxc_isi_dev *mxc_isi;
+	struct resource *res;
+	int ret = 0;
+
+	mxc_isi = devm_kzalloc(dev, sizeof(*mxc_isi), GFP_KERNEL);
+	if (!mxc_isi)
+		return -ENOMEM;
+
+	mxc_isi->pdev = pdev;
+
+	ret = mxc_isi_parse_dt(mxc_isi);
+	if (ret < 0)
+		return ret;
+
+	if (mxc_isi->id >= MXC_ISI_MAX_DEVS || mxc_isi->id < 0) {
+		dev_err(dev, "Invalid driver data or device id (%d)\n",
+			mxc_isi->id);
+		return -EINVAL;
+	}
+
+	init_waitqueue_head(&mxc_isi->irq_queue);
+	spin_lock_init(&mxc_isi->slock);
+	mutex_init(&mxc_isi->lock);
+
+	mxc_isi->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(mxc_isi->clk)) {
+		dev_err(dev, "failed to get isi clk\n");
+		return PTR_ERR(mxc_isi->clk);
+	}
+	ret = clk_prepare(mxc_isi->clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk error\n", __func__);
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mxc_isi->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(mxc_isi->regs)) {
+		dev_err(dev, "Failed to get ISI register map\n");
+		return PTR_ERR(mxc_isi->regs);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		dev_err(dev, "Failed to get IRQ resource\n");
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(dev, res->start, mxc_isi_irq_handler,
+			       0, dev_name(dev), mxc_isi);
+	if (ret < 0) {
+		dev_err(dev, "failed to install irq (%d)\n", ret);
+		return -EINVAL;
+	}
+
+	ret = mxc_isi_initialize_capture_subdev(mxc_isi);
+	if (ret < 0)
+		return -EINVAL;
+
+	platform_set_drvdata(pdev, mxc_isi);
+
+	ret = clk_enable(mxc_isi->clk);
+	if (ret < 0) {
+		dev_err(dev, "%s, enable clk error\n", __func__);
+		goto err_sclk;
+	}
+
+	dev_dbg(dev, "mxc_isi.%d registered successfully\n", mxc_isi->id);
+
+	return 0;
+
+err_sclk:
+	mxc_isi_unregister_capture_subdev(mxc_isi);
+	return ret;
+}
+
+static int mxc_isi_remove(struct platform_device *pdev)
+{
+	struct mxc_isi_dev *mxc_isi = platform_get_drvdata(pdev);
+
+	mxc_isi_unregister_capture_subdev(mxc_isi);
+
+	clk_disable_unprepare(mxc_isi->clk);
+
+	return 0;
+}
+
+static const struct of_device_id mxc_isi_of_match[] = {
+	{.compatible = "fsl,imx8-isi",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mxc_isi_of_match);
+
+static struct platform_driver mxc_isi_driver = {
+	.probe		= mxc_isi_probe,
+	.remove		= mxc_isi_remove,
+	.driver = {
+		.of_match_table = mxc_isi_of_match,
+		.name		= MXC_ISI_DRIVER_NAME,
+	}
+};
+
+module_platform_driver(mxc_isi_driver);
diff --git a/drivers/media/platform/imx8/mxc-isi-core.h b/drivers/media/platform/imx8/mxc-isi-core.h
new file mode 100644
index 0000000..0b71b3d
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-isi-core.h
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef MXC_ISI_CORE_H_
+#define MXC_ISI_CORE_H_
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#define MXC_ISI_DRIVER_NAME	"mxc-isi"
+#define MXC_ISI_MAX_DEVS	8
+
+#define ISI_OF_NODE_NAME	"isi"
+
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC0	0
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC1	1
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC2	2
+#define MXC_ISI_SD_PAD_SINK_MIPI0_VC3	3
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC0	4
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC1	5
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC2	6
+#define MXC_ISI_SD_PAD_SINK_MIPI1_VC3	7
+#if 0
+#define MXC_ISI_SD_PAD_SINK_MIPI_CSI0	0
+#define MXC_ISI_SD_PAD_SINK_MIPI_CSI1	1
+#endif
+#define MXC_ISI_SD_PAD_SINK_DC0			8
+#define MXC_ISI_SD_PAD_SINK_DC1			9
+#define MXC_ISI_SD_PAD_SINK_HDMI		10
+#define MXC_ISI_SD_PAD_SINK_MEM			11
+#define MXC_ISI_SD_PAD_SOURCE_MEM		12
+#define MXC_ISI_SD_PAD_SOURCE_DC0		13
+#define MXC_ISI_SD_PAD_SOURCE_DC1		14
+#define MXC_ISI_SD_PADS_NUM				15
+
+#define MXC_MAX_PLANES		3
+
+enum isi_input_interface {
+	ISI_INPUT_INTERFACE_DC0 = 0,
+	ISI_INPUT_INTERFACE_DC1,
+	ISI_INPUT_INTERFACE_MIPI0_CSI2,
+	ISI_INPUT_INTERFACE_MIPI1_CSI2,
+	ISI_INPUT_INTERFACE_HDMI,
+	ISI_INPUT_INTERFACE_MEM,
+	ISI_INPUT_INTERFACE_MAX,
+};
+
+enum isi_input_sub_interface {
+	ISI_INPUT_SUB_INTERFACE_VC0 = 0,
+	ISI_INPUT_SUB_INTERFACE_VC1,
+	ISI_INPUT_SUB_INTERFACE_VC2,
+	ISI_INPUT_SUB_INTERFACE_VC3,
+};
+
+enum isi_output_interface {
+	ISI_OUTPUT_INTERFACE_DC0 = 0,
+	ISI_OUTPUT_INTERFACE_DC1,
+	ISI_OUTPUT_INTERFACE_MEM,
+	ISI_OUTPUT_INTERFACE_MAX,
+};
+
+enum {
+	IN_PORT,
+	SUB_IN_PORT,
+	OUT_PORT,
+	MAX_PORTS,
+};
+
+enum mxc_isi_out_fmt {
+	MXC_ISI_OUT_FMT_RGBA32	= 0x0,
+	MXC_ISI_OUT_FMT_ABGR32,
+	MXC_ISI_OUT_FMT_ARGB32,
+	MXC_ISI_OUT_FMT_RGBX32,
+	MXC_ISI_OUT_FMT_XBGR32,
+	MXC_ISI_OUT_FMT_XRGB32,
+	MXC_ISI_OUT_FMT_RGB32P,
+	MXC_ISI_OUT_FMT_BGR32P,
+	MXC_ISI_OUT_FMT_A2BGR10,
+	MXC_ISI_OUT_FMT_A2RGB10,
+	MXC_ISI_OUT_FMT_RGB565,
+	MXC_ISI_OUT_FMT_RAW8,
+	MXC_ISI_OUT_FMT_RAW10,
+	MXC_ISI_OUT_FMT_RAW10P,
+	MXC_ISI_OUT_FMT_RAW12,
+	MXC_ISI_OUT_FMT_RAW16,
+	MXC_ISI_OUT_FMT_YUV444_1P8P,
+	MXC_ISI_OUT_FMT_YUV444_2P8P,
+	MXC_ISI_OUT_FMT_YUV444_3P8P,
+	MXC_ISI_OUT_FMT_YUV444_1P8,
+	MXC_ISI_OUT_FMT_YUV444_1P10,
+	MXC_ISI_OUT_FMT_YUV444_2P10,
+	MXC_ISI_OUT_FMT_YUV444_3P10,
+	MXC_ISI_OUT_FMT_YUV444_1P10P = 0x18,
+	MXC_ISI_OUT_FMT_YUV444_2P10P,
+	MXC_ISI_OUT_FMT_YUV444_3P10P,
+	MXC_ISI_OUT_FMT_YUV444_1P12 = 0x1C,
+	MXC_ISI_OUT_FMT_YUV444_2P12,
+	MXC_ISI_OUT_FMT_YUV444_3P12,
+	MXC_ISI_OUT_FMT_YUV422_1P8P = 0x20,
+	MXC_ISI_OUT_FMT_YUV422_2P8P,
+	MXC_ISI_OUT_FMT_YUV422_3P8P,
+	MXC_ISI_OUT_FMT_YUV422_1P10 = 0x24,
+	MXC_ISI_OUT_FMT_YUV422_2P10,
+	MXC_ISI_OUT_FMT_YUV422_3P10,
+	MXC_ISI_OUT_FMT_YUV422_1P10P = 0x28,
+	MXC_ISI_OUT_FMT_YUV422_2P10P,
+	MXC_ISI_OUT_FMT_YUV422_3P10P,
+	MXC_ISI_OUT_FMT_YUV422_1P12 = 0x2C,
+	MXC_ISI_OUT_FMT_YUV422_2P12,
+	MXC_ISI_OUT_FMT_YUV422_3P12,
+	MXC_ISI_OUT_FMT_YUV420_2P8P = 0x31,
+	MXC_ISI_OUT_FMT_YUV420_3P8P,
+	MXC_ISI_OUT_FMT_YUV420_2P10 = 0x35,
+	MXC_ISI_OUT_FMT_YUV420_3P10,
+	MXC_ISI_OUT_FMT_YUV420_2P10P = 0x39,
+	MXC_ISI_OUT_FMT_YUV420_3P10P,
+	MXC_ISI_OUT_FMT_YUV420_2P12 = 0x3D,
+	MXC_ISI_OUT_FMT_YUV420_3P12,
+};
+
+enum mxc_isi_in_fmt {
+	MXC_ISI_IN_FMT_BGR8P	= 0x0,
+};
+
+enum mxc_isi_m2m_in_fmt {
+	MXC_ISI_M2M_IN_FMT_BGR8P	= 0x0,
+	MXC_ISI_M2M_IN_FMT_RGB8P,
+	MXC_ISI_M2M_IN_FMT_XRGB8,
+	MXC_ISI_M2M_IN_FMT_RGBX8,
+	MXC_ISI_M2M_IN_FMT_XBGR8,
+	MXC_ISI_M2M_IN_FMT_RGB565,
+	MXC_ISI_M2M_IN_FMT_A2BGR10,
+	MXC_ISI_M2M_IN_FMT_A2RGB10,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P8P,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P10,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P10P,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P12,
+	MXC_ISI_M2M_IN_FMT_YUV444_1P8,
+	MXC_ISI_M2M_IN_FMT_YUV422_1P8P,
+	MXC_ISI_M2M_IN_FMT_YUV422_1P10,
+	MXC_ISI_M2M_IN_FMT_YUV422_1P10P,
+};
+
+struct mxc_isi_fmt {
+	char	*name;
+	u32 mbus_code;
+	u32	fourcc;
+	u32	color;
+	u16	memplanes;
+	u16	colplanes;
+	u8	colorspace;
+	u8	depth[MXC_MAX_PLANES];
+	u16	mdataplanes;
+	u16	flags;
+};
+
+struct mxc_isi_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *alpha;
+	bool ready;
+};
+
+/**
+ * struct addr -  physical address set for DMA
+ * @y:	 luminance plane physical address
+ * @cb:	 Cb plane physical address
+ * @cr:	 Cr plane physical address
+ */
+struct frame_addr {
+	u32	y;
+	u32	cb;
+	u32	cr;
+};
+
+/**
+ * struct mxc_isi_frame - source/target frame properties
+ * o_width:	 original image width from sensor
+ * o_height: original image height from sensor
+ * c_width:	 crop image width set by g_selection
+ * c_height: crop image height set by g_selection
+ * h_off:	crop horizontal pixel offset
+ * v_off:	crop vertical pixel offset
+ * width:	out image pixel width
+ * height:	out image pixel weight
+ * bytesperline: bytesperline value for each plane
+ * paddr:	image frame buffer physical addresses
+ * fmt:	color format pointer
+ */
+struct mxc_isi_frame {
+	u32	o_width;
+	u32	o_height;
+	u32 c_width;
+	u32 c_height;
+	u32	h_off;
+	u32	v_off;
+	u32	width;
+	u32	height;
+	unsigned int	sizeimage[MXC_MAX_PLANES];
+	unsigned int	bytesperline[MXC_MAX_PLANES];
+	struct mxc_isi_fmt	*fmt;
+};
+
+struct mxc_isi_roi_alpha {
+	u8 alpha;
+	struct v4l2_rect rect;
+};
+
+struct mxc_isi_buffer {
+	struct vb2_v4l2_buffer v4l2_buf;
+	struct list_head	list;
+	struct frame_addr	paddr;
+};
+
+struct mxc_isi_m2m_dev {
+	struct video_device		vdev;
+	struct v4l2_m2m_dev		*m2m_dev;
+	struct v4l2_fh			fh;
+
+	struct mxc_isi_frame	src_f;
+	struct mxc_isi_frame	dst_f;
+};
+
+struct mxc_isi_cap_dev {
+	struct v4l2_subdev		sd;
+	struct video_device		vdev;
+	struct v4l2_fh			fh;
+	struct media_pad		cap_pad;
+	struct media_pad		sd_pads[MXC_ISI_SD_PADS_NUM];
+	struct vb2_queue		vb2_q;
+	struct list_head		out_pending;
+	struct list_head		out_active;
+
+	struct mxc_isi_frame	src_f;
+	struct mxc_isi_frame	dst_f;
+	u32						frame_count;
+
+	u32 buf_index;
+
+};
+
+struct mxc_isi_dev {
+	spinlock_t				slock;
+	struct mutex			lock;
+	wait_queue_head_t		irq_queue;
+
+	int						id;
+	void __iomem			*regs;
+	unsigned long			state;
+
+	struct platform_device		*pdev;
+	struct v4l2_device			*v4l2_dev;
+	struct mxc_isi_m2m_dev		m2m;
+	struct mxc_isi_cap_dev		isi_cap;
+	struct clk		*clk;
+
+	u32 interface[MAX_PORTS];
+
+	/* scale factor */
+	u32	xfactor;
+	u32	yfactor;
+	u32	pre_dec_x;
+	u32	pre_dec_y;
+
+	unsigned int		hflip:1;
+	unsigned int		vflip:1;
+
+	unsigned int		cscen:1;
+	unsigned int		scale:1;
+	unsigned int		alphaen:1;
+	unsigned int		crop:1;
+	unsigned int		deinterlace:1;
+
+	struct mxc_isi_ctrls ctrls;
+	u8			alpha;		/* goable alpha */
+	struct mxc_isi_roi_alpha alpha_roi[5];		/* ROI alpha */
+};
+
+static inline void set_frame_bounds(struct mxc_isi_frame *f, u32 width, u32 height)
+{
+	f->o_width  = width;
+	f->o_height = height;
+	f->c_width  = width;
+	f->c_height = height;
+	f->width  = width;
+	f->height = height;
+}
+
+static inline void set_frame_out(struct mxc_isi_frame *f, u32 width, u32 height)
+{
+	f->c_width  = width;
+	f->c_height = height;
+	f->width  = width;
+	f->height = height;
+}
+
+static inline void set_frame_crop(struct mxc_isi_frame *f,
+				  u32 left, u32 top, u32 width, u32 height)
+{
+	f->h_off = left;
+	f->v_off = top;
+	f->c_width  = width;
+	f->c_height = height;
+}
+
+#endif
diff --git a/drivers/media/platform/imx8/mxc-isi-hw.c b/drivers/media/platform/imx8/mxc-isi-hw.c
new file mode 100644
index 0000000..d209b87
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-isi-hw.c
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "mxc-isi-hw.h"
+
+#define	ISI_DOWNSCALE_THRESHOLD		0x4000
+
+#ifdef debug
+static void dump_isi_regs(struct mxc_isi_dev *mxc_isi)
+{
+	printk("ISI CHNLC register dump, isi%d\n", mxc_isi->id);
+	printk("CHNL_CTRL              0x0h  = 0x%x\n", readl(mxc_isi->regs + 0x0));
+	printk("CHNL_IMG_CTRL          0x4h  = 0x%x\n", readl(mxc_isi->regs + 0x4));
+	printk("CHNL_OUT_BUF_CTRL      0x8h  = 0x%x\n", readl(mxc_isi->regs + 0x8));
+	printk("CHNL_IMG_CFG           0xCh  = 0x%x\n", readl(mxc_isi->regs + 0xC));
+	printk("CHNL_IER               0x10h = 0x%x\n", readl(mxc_isi->regs + 0x10));
+	printk("CHNL_STS               0x14h = 0x%x\n", readl(mxc_isi->regs + 0x14));
+	printk("CHNL_SCALE_FACTOR      0x18h = 0x%x\n", readl(mxc_isi->regs + 0x18));
+	printk("CHNL_SCALE_OFFSET      0x1Ch = 0x%x\n", readl(mxc_isi->regs + 0x1C));
+	printk("CHNL_CROP_ULC          0x20h = 0x%x\n", readl(mxc_isi->regs + 0x20));
+	printk("CHNL_CROP_LRC          0x24h = 0x%x\n", readl(mxc_isi->regs + 0x24));
+	printk("CHNL_CSC_COEFF0        0x28h = 0x%x\n", readl(mxc_isi->regs + 0x28));
+	printk("CHNL_CSC_COEFF1        0x2Ch = 0x%x\n", readl(mxc_isi->regs + 0x2C));
+	printk("CHNL_CSC_COEFF2        0x30h = 0x%x\n", readl(mxc_isi->regs + 0x30));
+	printk("CHNL_CSC_COEFF3        0x34h = 0x%x\n", readl(mxc_isi->regs + 0x34));
+	printk("CHNL_CSC_COEFF4        0x38h = 0x%x\n", readl(mxc_isi->regs + 0x38));
+	printk("CHNL_CSC_COEFF5        0x3Ch = 0x%x\n", readl(mxc_isi->regs + 0x3C));
+	printk("CHNL_ROI_0_ALPHA       0x40h = 0x%x\n", readl(mxc_isi->regs + 0x40));
+	printk("CHNL_ROI_0_ULC         0x44h = 0x%x\n", readl(mxc_isi->regs + 0x44));
+	printk("CHNL_ROI_0_LRC         0x48h = 0x%x\n", readl(mxc_isi->regs + 0x48));
+	printk("CHNL_ROI_1_ALPHA       0x4Ch = 0x%x\n", readl(mxc_isi->regs + 0x4C));
+	printk("CHNL_ROI_1_ULC         0x50h = 0x%x\n", readl(mxc_isi->regs + 0x50));
+	printk("CHNL_ROI_1_LRC         0x54h = 0x%x\n", readl(mxc_isi->regs + 0x54));
+	printk("CHNL_ROI_2_ALPHA       0x58h = 0x%x\n", readl(mxc_isi->regs + 0x58));
+	printk("CHNL_ROI_2_ULC         0x5Ch = 0x%x\n", readl(mxc_isi->regs + 0x5C));
+	printk("CHNL_ROI_2_LRC         0x60h = 0x%x\n", readl(mxc_isi->regs + 0x60));
+	printk("CHNL_ROI_3_ALPHA       0x64h = 0x%x\n", readl(mxc_isi->regs + 0x64));
+	printk("CHNL_ROI_3_ULC         0x68h = 0x%x\n", readl(mxc_isi->regs + 0x68));
+	printk("CHNL_ROI_3_LRC         0x6Ch = 0x%x\n", readl(mxc_isi->regs + 0x6C));
+	printk("CHNL_OUT_BUF1_ADDR_Y   0x70h = 0x%x\n", readl(mxc_isi->regs + 0x70));
+	printk("CHNL_OUT_BUF1_ADDR_U   0x74h = 0x%x\n", readl(mxc_isi->regs + 0x74));
+	printk("CHNL_OUT_BUF1_ADDR_V   0x78h = 0x%x\n", readl(mxc_isi->regs + 0x78));
+	printk("CHNL_OUT_BUF_PITCH     0x7Ch = 0x%x\n", readl(mxc_isi->regs + 0x7C));
+	printk("CHNL_IN_BUF_ADDR       0x80h = 0x%x\n", readl(mxc_isi->regs + 0x80));
+	printk("CHNL_IN_BUF_PITCH      0x84h = 0x%x\n", readl(mxc_isi->regs + 0x84));
+	printk("CHNL_MEM_RD_CTRL       0x88h = 0x%x\n", readl(mxc_isi->regs + 0x88));
+	printk("CHNL_OUT_BUF2_ADDR_Y   0x8Ch = 0x%x\n", readl(mxc_isi->regs + 0x8C));
+	printk("CHNL_OUT_BUF2_ADDR_U   0x90h = 0x%x\n", readl(mxc_isi->regs + 0x90));
+	printk("CHNL_OUT_BUF2_ADDR_V   0x94h = 0x%x\n", readl(mxc_isi->regs + 0x94));
+}
+#else
+static void dump_isi_regs(struct mxc_isi_dev *mxc_isi)
+{
+}
+#endif
+
+struct colorspace_coeffs coeffs[] = {
+	/* A2,A1,      B1, A3,     B3, B2,      C2, C1,     D1, C3,   D3, D2   */
+	/* YUV2RGB */
+	{ 0x0000012A, 0x012A0198, 0x0730079C, 0x0204012A, 0x01F00000, 0x01800180 },
+	/* RGB->YUV */
+	{ 0x0096004D, 0x05DA001D, 0x007005B6, 0x057C009E, 0x000005E6, 0x00000000 },
+};
+
+static void printk_pixelformat(char *prefix, int val)
+{
+	printk("%s %c%c%c%c\n", prefix ? prefix : "pixelformat",
+			val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
+}
+
+static bool is_rgb(u32 pix_fmt)
+{
+	if ((pix_fmt == V4L2_PIX_FMT_RGB565) ||
+		(pix_fmt == V4L2_PIX_FMT_RGB24) ||
+		(pix_fmt == V4L2_PIX_FMT_RGB32) ||
+		(pix_fmt == V4L2_PIX_FMT_BGR24) ||
+	    (pix_fmt == V4L2_PIX_FMT_ARGB32)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static bool is_yuv(u32 pix_fmt)
+{
+	if ((pix_fmt == V4L2_PIX_FMT_YUYV) ||
+		(pix_fmt == V4L2_PIX_FMT_YUV32)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+void mxc_isi_channel_set_outbuf(struct mxc_isi_dev *mxc_isi, struct mxc_isi_buffer *buf)
+{
+	struct vb2_buffer *vb2_buf = &buf->v4l2_buf.vb2_buf;
+	struct frame_addr *paddr = &buf->paddr;
+	u32 framecount = buf->v4l2_buf.sequence;
+	int val = 0;
+
+	paddr->y = vb2_dma_contig_plane_dma_addr(vb2_buf, 0);
+
+	if (vb2_buf->num_planes == 2)
+		paddr->cb = vb2_dma_contig_plane_dma_addr(vb2_buf, 1);
+	if (vb2_buf->num_planes == 3) {
+		paddr->cb = vb2_dma_contig_plane_dma_addr(vb2_buf, 1);
+		paddr->cr = vb2_dma_contig_plane_dma_addr(vb2_buf, 2);
+	}
+
+	val = readl(mxc_isi->regs + CHNL_OUT_BUF_CTRL);
+	if (framecount % 2 == 1) {
+		writel(paddr->y, mxc_isi->regs + CHNL_OUT_BUF2_ADDR_Y);
+		writel(paddr->cb, mxc_isi->regs + CHNL_OUT_BUF2_ADDR_U);
+		writel(paddr->cr, mxc_isi->regs + CHNL_OUT_BUF2_ADDR_V);
+		val ^= CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR_MASK;
+	} else {
+		writel(paddr->y, mxc_isi->regs + CHNL_OUT_BUF1_ADDR_Y);
+		writel(paddr->cb, mxc_isi->regs + CHNL_OUT_BUF1_ADDR_U);
+		writel(paddr->cr, mxc_isi->regs + CHNL_OUT_BUF1_ADDR_V);
+		val ^= CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR_MASK;
+	}
+	writel(val,	mxc_isi->regs + CHNL_OUT_BUF_CTRL);
+}
+
+
+void mxc_isi_channel_sw_reset(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val |= CHNL_CTRL_SW_RST;
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+	mdelay(5);
+	val &= ~CHNL_CTRL_SW_RST;
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+
+void mxc_isi_channel_source_config(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~(CHNL_CTRL_MIPI_VC_ID_MASK |
+				CHNL_CTRL_SRC_INPUT_MASK | CHNL_CTRL_SRC_TYPE_MASK);
+
+	switch (mxc_isi->interface[IN_PORT]) {
+	case ISI_INPUT_INTERFACE_MIPI0_CSI2:
+		val |= CHNL_CTRL_SRC_INPUT_MIPI0;
+		if (mxc_isi->interface[SUB_IN_PORT] <= CHNL_CTRL_MIPI_VC_ID_VC3 &&
+				mxc_isi->interface[SUB_IN_PORT] >= CHNL_CTRL_MIPI_VC_ID_VC0)
+			val |= (mxc_isi->interface[SUB_IN_PORT] << CHNL_CTRL_MIPI_VC_ID_OFFSET);
+		break;
+	case ISI_INPUT_INTERFACE_MIPI1_CSI2:
+		val |= CHNL_CTRL_SRC_INPUT_MIPI1;
+		if (mxc_isi->interface[SUB_IN_PORT] <= CHNL_CTRL_MIPI_VC_ID_VC3 &&
+				mxc_isi->interface[SUB_IN_PORT] >= CHNL_CTRL_MIPI_VC_ID_VC0)
+			val |= (mxc_isi->interface[SUB_IN_PORT] << CHNL_CTRL_MIPI_VC_ID_OFFSET);
+		break;
+	case ISI_INPUT_INTERFACE_DC0:
+		val |= CHNL_CTRL_SRC_INPUT_DC0;
+		break;
+	case ISI_INPUT_INTERFACE_DC1:
+		val |= CHNL_CTRL_SRC_INPUT_DC1;
+		break;
+	case ISI_INPUT_INTERFACE_HDMI:
+		val |= CHNL_CTRL_SRC_INPUT_HDMI;
+		break;
+	case ISI_INPUT_INTERFACE_MEM:
+		val |= CHNL_CTRL_SRC_INPUT_MEMORY;
+		val |= (CHNL_CTRL_SRC_TYPE_MEMORY << CHNL_CTRL_SRC_TYPE_OFFSET);
+		break;
+	default:
+		dev_err(&mxc_isi->pdev->dev, "invalid interface\n");
+		break;
+	}
+
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+
+void mxc_isi_channel_set_flip(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~(CHNL_IMG_CTRL_VFLIP_EN_MASK | CHNL_IMG_CTRL_HFLIP_EN_MASK);
+
+	if (mxc_isi->vflip)
+		val |= (CHNL_IMG_CTRL_VFLIP_EN_ENABLE << CHNL_IMG_CTRL_VFLIP_EN_OFFSET);
+	if (mxc_isi->hflip)
+		val |= (CHNL_IMG_CTRL_HFLIP_EN_ENABLE << CHNL_IMG_CTRL_HFLIP_EN_OFFSET);
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_csc(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_fmt	*dst_fmt = mxc_isi->isi_cap.dst_f.fmt;
+	struct mxc_isi_fmt	*src_fmt = mxc_isi->isi_cap.src_f.fmt;
+	u32 val, csc = 0;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~(CHNL_IMG_CTRL_FORMAT_MASK |
+			CHNL_IMG_CTRL_YCBCR_MODE_MASK |
+			CHNL_IMG_CTRL_CSC_BYPASS_MASK |
+			CHNL_IMG_CTRL_CSC_MODE_MASK);
+
+	/* set outbuf format */
+	val |= dst_fmt->color << CHNL_IMG_CTRL_FORMAT_OFFSET;
+
+	mxc_isi->cscen = 1;
+
+	if (is_yuv(src_fmt->fourcc) && is_rgb(dst_fmt->fourcc)) {
+		/* YUV2RGB */
+		csc = YUV2RGB;
+		/* YCbCr enable???  */
+		val |= (CHNL_IMG_CTRL_CSC_MODE_YCBCR2RGB << CHNL_IMG_CTRL_CSC_MODE_OFFSET);
+		val |= (CHNL_IMG_CTRL_YCBCR_MODE_ENABLE << CHNL_IMG_CTRL_YCBCR_MODE_OFFSET);
+	} else if (is_rgb(src_fmt->fourcc) && is_yuv(dst_fmt->fourcc)) {
+		/* RGB2YUV */
+		csc = RGB2YUV;
+		val |= (CHNL_IMG_CTRL_CSC_MODE_RGB2YUV << CHNL_IMG_CTRL_CSC_MODE_OFFSET);
+	} else {
+		/* Bypass CSC */
+		printk("bypass csc\n");
+		mxc_isi->cscen = 0;
+		val |= CHNL_IMG_CTRL_CSC_BYPASS_ENABLE;
+	}
+
+	printk_pixelformat("input fmt", src_fmt->fourcc);
+	printk_pixelformat("output fmt", dst_fmt->fourcc);
+
+	if (mxc_isi->cscen) {
+		writel(coeffs[csc].coeff[0], mxc_isi->regs + CHNL_CSC_COEFF0);
+		writel(coeffs[csc].coeff[1], mxc_isi->regs + CHNL_CSC_COEFF1);
+		writel(coeffs[csc].coeff[2], mxc_isi->regs + CHNL_CSC_COEFF2);
+		writel(coeffs[csc].coeff[3], mxc_isi->regs + CHNL_CSC_COEFF3);
+		writel(coeffs[csc].coeff[4], mxc_isi->regs + CHNL_CSC_COEFF4);
+		writel(coeffs[csc].coeff[5], mxc_isi->regs + CHNL_CSC_COEFF5);
+	}
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+void mxc_isi_channel_set_alpha_roi0(struct mxc_isi_dev *mxc_isi,
+				struct v4l2_rect *rect)
+{
+	u32 val0, val1;
+	val0 = (rect->left << 16) | rect->top;
+	writel(val0, mxc_isi->regs + CHNL_ROI_0_ULC);
+	val1 = (rect->width << 16) | rect->height;
+	writel(val0 + val1, mxc_isi->regs + CHNL_ROI_0_LRC);
+}
+
+void mxc_isi_channel_set_alpha(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~(CHNL_IMG_CTRL_GBL_ALPHA_VAL_MASK | CHNL_IMG_CTRL_GBL_ALPHA_EN_MASK);
+	val |= ((mxc_isi->alpha << CHNL_IMG_CTRL_GBL_ALPHA_VAL_OFFSET) |
+			(CHNL_IMG_CTRL_GBL_ALPHA_EN_ENABLE << CHNL_IMG_CTRL_GBL_ALPHA_EN_OFFSET));
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_4k(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_frame *src_f = &mxc_isi->isi_cap.src_f;
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~CHNL_CTRL_CHAIN_BUF_MASK;
+	if (src_f->width > 2046)
+		val |= (CHNL_CTRL_CHAIN_BUF_2_CHAIN << CHNL_CTRL_CHAIN_BUF_OFFSET);
+
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+
+void mxc_isi_channel_deinterlace_init(struct mxc_isi_dev *mxc_isi)
+{
+	/* Config for Blending deinterlace */
+}
+
+void mxc_isi_channel_set_deinterlace(struct mxc_isi_dev *mxc_isi)
+{
+	/* de-interlacing method
+	 * Weaving-------------Yes
+	 * Line Doubling-------No
+	 * Blending -----------TODO*/
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~CHNL_IMG_CTRL_DEINT_MASK;
+	if (mxc_isi->deinterlace)
+		val |= mxc_isi->deinterlace << CHNL_IMG_CTRL_DEINT_OFFSET;
+	if (mxc_isi->deinterlace == CHNL_IMG_CTRL_DEINT_LDOUBLE_ODD_EVEN ||
+			mxc_isi->deinterlace == CHNL_IMG_CTRL_DEINT_LDOUBLE_EVEN_ODD)
+		mxc_isi_channel_deinterlace_init(mxc_isi);
+
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_crop(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_frame *src_f = &mxc_isi->isi_cap.src_f;
+	struct v4l2_rect crop;
+	u32 val, val0, val1, temp;
+
+	val = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val &= ~CHNL_IMG_CTRL_CROP_EN_MASK;
+
+	if ((src_f->o_height == src_f->height) &&
+			(src_f->o_width == src_f->width)) {
+		mxc_isi->crop = 0;
+		writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+		return;
+	}
+
+	if (mxc_isi->scale) {
+		temp = (src_f->h_off << 12) / mxc_isi->xfactor;
+		crop.left = temp >> mxc_isi->pre_dec_x;
+		temp = (src_f->v_off << 12) / mxc_isi->yfactor;
+		crop.top = temp >> mxc_isi->pre_dec_y;
+		temp = (src_f->width << 12) / mxc_isi->xfactor;
+		crop.width = temp >> mxc_isi->pre_dec_x;
+		temp = (src_f->height << 12) / mxc_isi->yfactor;
+		crop.height = temp >> mxc_isi->pre_dec_y;
+	} else {
+		crop.left = src_f->h_off;
+		crop.top = src_f->v_off;
+		crop.width = src_f->width;
+		crop.height = src_f->height;
+	}
+
+	mxc_isi->crop = 1;
+	val |= (CHNL_IMG_CTRL_CROP_EN_ENABLE << CHNL_IMG_CTRL_CROP_EN_OFFSET);
+	val0 = crop.top | (crop.left << CHNL_CROP_ULC_X_OFFSET);
+	val1 = crop.height | (crop.width << CHNL_CROP_LRC_X_OFFSET);
+
+	writel(val0, mxc_isi->regs + CHNL_CROP_ULC);
+	writel((val1 + val0), mxc_isi->regs + CHNL_CROP_LRC);
+	writel(val, mxc_isi->regs + CHNL_IMG_CTRL);
+}
+
+void mxc_isi_channel_set_scaling(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
+	struct mxc_isi_frame *src_f = &mxc_isi->isi_cap.src_f;
+	u32 decx, decy;
+	u32 xscale, yscale;
+	u32 xdec = 0, ydec = 0;
+	u32 val0, val1;
+
+	if (dst_f->height == src_f->height ||
+			dst_f->width == src_f->width) {
+		mxc_isi->scale = 0;
+		return;
+	}
+
+	dev_info(&mxc_isi->pdev->dev, "input_size(%d,%d), output_size(%d,%d)\n",
+			src_f->height, src_f->width, dst_f->height, dst_f->width);
+
+	mxc_isi->scale = 1;
+
+	decx = src_f->width / dst_f->width;
+	decy = src_f->height / dst_f->height;
+
+	if (decx > 1) {
+		/* Down */
+		if (decx >= 2 && decx < 4) {
+			decx = 2;
+			xdec = 1;
+		} else if (decx >= 4 && decx < 8) {
+			decx = 4;
+			xdec = 2;
+		} else if (decx >= 8) {
+			decx = 8;
+			xdec = 3;
+		}
+		xscale = src_f->width * 0x1000 / (dst_f->width * decx);
+	} else
+		/* Up  */
+		xscale = src_f->width * 0x1000 / dst_f->width;
+
+	if (decy > 1) {
+		if (decy >= 2 && decy < 4) {
+			decy = 2;
+			ydec = 1;
+		} else if (decy >= 4 && decy < 8) {
+			decy = 4;
+			ydec = 2;
+		} else if (decy >= 8) {
+			decy = 8;
+			ydec = 3;
+		}
+		yscale = src_f->height * 0x1000 / (dst_f->height * decy);
+	} else
+		yscale = src_f->height * 0x1000 / dst_f->height;
+
+	val0 = readl(mxc_isi->regs + CHNL_IMG_CTRL);
+	val0 |= CHNL_IMG_CTRL_YCBCR_MODE_MASK;//YCbCr  Sandor???
+	val0 &= ~(CHNL_IMG_CTRL_DEC_X_MASK | CHNL_IMG_CTRL_DEC_Y_MASK);
+	val0 |= (xdec << CHNL_IMG_CTRL_DEC_X_OFFSET) |
+			(ydec << CHNL_IMG_CTRL_DEC_Y_OFFSET);
+	writel(val0, mxc_isi->regs + CHNL_IMG_CTRL);
+
+	if (xscale > ISI_DOWNSCALE_THRESHOLD)
+		xscale = ISI_DOWNSCALE_THRESHOLD;
+	if (yscale > ISI_DOWNSCALE_THRESHOLD)
+		yscale = ISI_DOWNSCALE_THRESHOLD;
+
+	val1 = xscale | (yscale << CHNL_SCALE_FACTOR_Y_SCALE_OFFSET);
+
+	writel(val1, mxc_isi->regs + CHNL_SCALE_FACTOR);
+	writel(0, mxc_isi->regs + CHNL_SCALE_OFFSET);
+
+	return;
+}
+
+void mxc_isi_channel_init(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	/* Init channel clk first */
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val |= (CHNL_CTRL_CLK_EN_ENABLE << CHNL_CTRL_CLK_EN_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+
+	/* sw reset */
+	mxc_isi_channel_sw_reset(mxc_isi);
+}
+
+void mxc_isi_channel_deinit(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	/* sw reset */
+	mxc_isi_channel_sw_reset(mxc_isi);
+
+	/* deinit channel clk first */
+	val = (CHNL_CTRL_CLK_EN_ENABLE << CHNL_CTRL_CLK_EN_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+
+void mxc_isi_channel_config(struct mxc_isi_dev *mxc_isi)
+{
+	struct mxc_isi_frame *dst_f = &mxc_isi->isi_cap.dst_f;
+	struct mxc_isi_frame *src_f = &mxc_isi->isi_cap.src_f;
+	u32 val;
+
+	/* config output frame size and format */
+	val = src_f->o_width | (src_f->o_height << CHNL_IMG_CFG_HEIGHT_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_IMG_CFG);
+
+	/* check csc and scaling  */
+	mxc_isi_channel_set_csc(mxc_isi);
+
+	mxc_isi_channel_set_scaling(mxc_isi);
+
+	/* select the source input / src type / virtual channel for mipi*/
+	mxc_isi_channel_source_config(mxc_isi);
+
+	/* line pitch */
+	val = dst_f->bytesperline[0];
+	writel(val, mxc_isi->regs + CHNL_OUT_BUF_PITCH);
+
+	/* TODO */
+#if 0
+	mxc_isi_channel_set_crop(mxc_isi);
+
+	mxc_isi_channel_set_flip(mxc_isi);
+	if (mxc_isi->alphaen)
+		mxc_isi_channel_set_alpha(mxc_isi);
+
+	mxc_isi_channel_set_4k(mxc_isi);
+#endif
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~CHNL_CTRL_CHNL_BYPASS_MASK;
+
+	/*  Bypass channel */
+	if (!mxc_isi->cscen && !mxc_isi->scale)
+		val |= (CHNL_CTRL_CHNL_BYPASS_ENABLE << CHNL_CTRL_CHNL_BYPASS_OFFSET);
+
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+
+void mxc_isi_channel_enable(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val |= (CHNL_CTRL_CHNL_EN_ENABLE << CHNL_CTRL_CHNL_EN_OFFSET);
+	val |= 0xff << CHNL_CTRL_BLANK_PXL_OFFSET;
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+
+	mxc_isi_enable_irq(mxc_isi);
+	dump_isi_regs(mxc_isi);
+}
+
+void mxc_isi_channel_disable(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	mxc_isi_disable_irq(mxc_isi);
+
+	val = readl(mxc_isi->regs + CHNL_CTRL);
+	val &= ~(CHNL_CTRL_CHNL_EN_MASK | CHNL_CTRL_CLK_EN_MASK);
+	val |= (CHNL_CTRL_CHNL_EN_DISABLE << CHNL_CTRL_CHNL_EN_OFFSET);
+	val |= (CHNL_CTRL_CLK_EN_DISABLE << CHNL_CTRL_CLK_EN_OFFSET);
+	writel(val, mxc_isi->regs + CHNL_CTRL);
+}
+
+void  mxc_isi_enable_irq(struct mxc_isi_dev *mxc_isi)
+{
+	u32 val;
+
+	val = CHNL_IER_FRM_RCVD_EN_MASK |
+			CHNL_IER_OFLW_Y_BUF_EN_MASK |
+			CHNL_IER_AXI_WR_ERR_U_EN_MASK |
+			CHNL_IER_AXI_WR_ERR_V_EN_MASK |
+			CHNL_IER_AXI_WR_ERR_Y_EN_MASK |
+			CHNL_IER_OFLW_PANIC_V_BUF_EN_MASK |
+			CHNL_IER_EXCS_OFLW_V_BUF_EN_MASK |
+			CHNL_IER_OFLW_V_BUF_EN_MASK |
+			CHNL_IER_OFLW_PANIC_U_BUF_EN_MASK |
+			CHNL_IER_EXCS_OFLW_U_BUF_EN_MASK |
+			CHNL_IER_OFLW_U_BUF_EN_MASK |
+			CHNL_IER_OFLW_PANIC_Y_BUF_EN_MASK |
+			CHNL_IER_EXCS_OFLW_Y_BUF_EN_MASK |
+			CHNL_IER_OFLW_Y_BUF_EN_MASK;
+
+	writel(val, mxc_isi->regs + CHNL_IER);
+}
+
+void mxc_isi_disable_irq(struct mxc_isi_dev *mxc_isi)
+{
+	writel(0, mxc_isi->regs + CHNL_CTRL);
+}
+
+u32 mxc_isi_get_irq_status(struct mxc_isi_dev *mxc_isi)
+{
+	return readl(mxc_isi->regs + CHNL_STS);
+}
+
+void mxc_isi_clean_irq_status(struct mxc_isi_dev *mxc_isi, u32 val)
+{
+	writel(val, mxc_isi->regs + CHNL_STS);
+}
diff --git a/drivers/media/platform/imx8/mxc-isi-hw.h b/drivers/media/platform/imx8/mxc-isi-hw.h
new file mode 100644
index 0000000..f32c1e6
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-isi-hw.h
@@ -0,0 +1,483 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef MXC_ISI_HW_H_
+#define MXC_ISI_HW_H_
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+
+#include "mxc-isi-core.h"
+
+/* ISI Registers Define  */
+/* Channel Control Register */
+#define  CHNL_CTRL						0x0
+#define  CHNL_CTRL_CHNL_EN_OFFSET		31
+#define  CHNL_CTRL_CHNL_EN_MASK			0x80000000
+#define  CHNL_CTRL_CHNL_EN_DISABLE		0
+#define  CHNL_CTRL_CHNL_EN_ENABLE		1
+#define  CHNL_CTRL_CLK_EN_OFFSET		30
+#define  CHNL_CTRL_CLK_EN_MASK			0x40000000
+#define  CHNL_CTRL_CLK_EN_DISABLE		0
+#define  CHNL_CTRL_CLK_EN_ENABLE		1
+#define  CHNL_CTRL_CHNL_BYPASS_OFFSET	29
+#define  CHNL_CTRL_CHNL_BYPASS_MASK		0x20000000
+#define  CHNL_CTRL_CHNL_BYPASS_ENABLE	1
+#define  CHNL_CTRL_CHAIN_BUF_OFFSET		25
+#define  CHNL_CTRL_CHAIN_BUF_MASK		0x60000
+#define  CHNL_CTRL_CHAIN_BUF_NO_CHAIN	0
+#define  CHNL_CTRL_CHAIN_BUF_2_CHAIN	1
+#define  CHNL_CTRL_SW_RST_OFFSET		24
+#define  CHNL_CTRL_SW_RST_MASK			0x100000
+#define  CHNL_CTRL_SW_RST				0x100000
+#define  CHNL_CTRL_BLANK_PXL_OFFSET		16
+#define  CHNL_CTRL_MIPI_VC_ID_OFFSET	6
+#define  CHNL_CTRL_MIPI_VC_ID_MASK		0xc0
+#define  CHNL_CTRL_MIPI_VC_ID_VC0		0
+#define  CHNL_CTRL_MIPI_VC_ID_VC1		1
+#define  CHNL_CTRL_MIPI_VC_ID_VC2		2
+#define  CHNL_CTRL_MIPI_VC_ID_VC3		3
+#define  CHNL_CTRL_SRC_TYPE_OFFSET		4
+#define  CHNL_CTRL_SRC_TYPE_MASK		0x10
+#define  CHNL_CTRL_SRC_TYPE_DEVICE		0
+#define  CHNL_CTRL_SRC_TYPE_MEMORY		1
+#define  CHNL_CTRL_SRC_INPUT_OFFSET		0
+#define  CHNL_CTRL_SRC_INPUT_MASK		0x7
+#define  CHNL_CTRL_SRC_INPUT_DC0		0
+#define  CHNL_CTRL_SRC_INPUT_DC1		1
+#define  CHNL_CTRL_SRC_INPUT_MIPI0		2
+#define  CHNL_CTRL_SRC_INPUT_MIPI1		3
+#define  CHNL_CTRL_SRC_INPUT_HDMI		4
+#define  CHNL_CTRL_SRC_INPUT_MEMORY		5
+
+/* Channel Image Control Register */
+#define  CHNL_IMG_CTRL						0x4
+#define  CHNL_IMG_CTRL_FORMAT_OFFSET		24
+#define  CHNL_IMG_CTRL_FORMAT_MASK			0x3F000000
+#define  CHNL_IMG_CTRL_GBL_ALPHA_VAL_OFFSET	16
+#define  CHNL_IMG_CTRL_GBL_ALPHA_VAL_MASK	0xFF0000
+#define  CHNL_IMG_CTRL_GBL_ALPHA_EN_OFFSET	15
+#define  CHNL_IMG_CTRL_GBL_ALPHA_EN_ENABLE	1
+#define  CHNL_IMG_CTRL_GBL_ALPHA_EN_MASK	0x8000
+#define  CHNL_IMG_CTRL_DEINT_OFFSET			12
+#define  CHNL_IMG_CTRL_DEINT_MASK			0x7000
+#define  CHNL_IMG_CTRL_DEINT_WEAVE_ODD_EVEN	2
+#define  CHNL_IMG_CTRL_DEINT_WEAVE_EVEN_ODD	3
+#define  CHNL_IMG_CTRL_DEINT_BLEND_ODD_EVEN	4
+#define  CHNL_IMG_CTRL_DEINT_BLEND_EVEN_ODD	5
+#define  CHNL_IMG_CTRL_DEINT_LDOUBLE_ODD_EVEN	6
+#define  CHNL_IMG_CTRL_DEINT_LDOUBLE_EVEN_ODD	7
+#define  CHNL_IMG_CTRL_DEC_X_OFFSET			10
+#define  CHNL_IMG_CTRL_DEC_X_MASK			0xC00
+#define  CHNL_IMG_CTRL_DEC_X_0				0
+#define  CHNL_IMG_CTRL_DEC_X_2				1
+#define  CHNL_IMG_CTRL_DEC_X_4				2
+#define  CHNL_IMG_CTRL_DEC_X_8				3
+#define  CHNL_IMG_CTRL_DEC_Y_OFFSET			8
+#define  CHNL_IMG_CTRL_DEC_Y_MASK			0x300
+#define  CHNL_IMG_CTRL_DEC_Y_0				0
+#define  CHNL_IMG_CTRL_DEC_Y_2				1
+#define  CHNL_IMG_CTRL_DEC_Y_4				2
+#define  CHNL_IMG_CTRL_DEC_Y_8				3
+#define  CHNL_IMG_CTRL_CROP_EN_OFFSET		7
+#define  CHNL_IMG_CTRL_CROP_EN_MASK			0x80
+#define  CHNL_IMG_CTRL_CROP_EN_ENABLE		1
+#define  CHNL_IMG_CTRL_VFLIP_EN_OFFSET		6
+#define  CHNL_IMG_CTRL_VFLIP_EN_MASK		0x40
+#define  CHNL_IMG_CTRL_VFLIP_EN_ENABLE		1
+#define  CHNL_IMG_CTRL_HFLIP_EN_OFFSET		5
+#define  CHNL_IMG_CTRL_HFLIP_EN_MASK		0x20
+#define  CHNL_IMG_CTRL_HFLIP_EN_ENABLE		1
+#define  CHNL_IMG_CTRL_YCBCR_MODE_OFFSET	3
+#define  CHNL_IMG_CTRL_YCBCR_MODE_MASK		0x8
+#define  CHNL_IMG_CTRL_YCBCR_MODE_ENABLE	1
+#define  CHNL_IMG_CTRL_CSC_MODE_OFFSET		1
+#define  CHNL_IMG_CTRL_CSC_MODE_MASK		0x6
+#define  CHNL_IMG_CTRL_CSC_MODE_YUV2RGB		0
+#define  CHNL_IMG_CTRL_CSC_MODE_YCBCR2RGB	1
+#define  CHNL_IMG_CTRL_CSC_MODE_RGB2YUV		2
+#define  CHNL_IMG_CTRL_CSC_MODE_RGB2YCBCR	3
+#define  CHNL_IMG_CTRL_CSC_BYPASS_OFFSET	0
+#define  CHNL_IMG_CTRL_CSC_BYPASS_MASK		0x1
+#define  CHNL_IMG_CTRL_CSC_BYPASS_ENABLE	0x1
+
+/* Channel Output Buffer Control Register */
+#define  CHNL_OUT_BUF_CTRL					0x8
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR_OFFSET			15
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR_MASK				0x8000
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR_OFFSET			14
+#define  CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR_MASK				0x4000
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_OFFSET		6
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_MASK		0xC0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_NO_PANIC	0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_PANIC_25	1
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_PANIC_50	2
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_V_PANIC_75	3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_OFFSET		3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_MASK		0x18
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_NO_PANIC	0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_PANIC_25	1
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_PANIC_50	2
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_U_PANIC_75	3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_OFFSET		0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_MASK		0x3
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_NO_PANIC	0
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_PANIC_25	1
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_PANIC_50	2
+#define  CHNL_OUT_BUF_CTRL_OFLW_PANIC_SET_THD_Y_PANIC_75	3
+
+/* Channel Image Configuration */
+#define  CHNL_IMG_CFG					0xC
+#define  CHNL_IMG_CFG_HEIGHT_OFFSET		16
+#define  CHNL_IMG_CFG_HEIGHT_MASK		0x1FFF0000
+#define  CHNL_IMG_CFG_WIDTH_OFFSET		0
+#define  CHNL_IMG_CFG_WIDTH_MASK		0x1FFF
+
+/* Channel Interrupt Enable Register */
+#define  CHNL_IER									0x10
+#define  CHNL_IER_MEM_RD_DONE_EN_OFFSET				31
+#define  CHNL_IER_MEM_RD_DONE_EN_MASK				0x80000000
+#define  CHNL_IER_MEM_RD_DONE_EN_ENABLE				1
+#define  CHNL_IER_LINE_RCVD_EN_OFFSET				30
+#define  CHNL_IER_LINE_RCVD_EN_MASK					0x40000000
+#define  CHNL_IER_LINE_RCVD_EN_ENABLE				1
+#define  CHNL_IER_FRM_RCVD_EN_OFFSET				29
+#define  CHNL_IER_FRM_RCVD_EN_MASK					0x20000000
+#define  CHNL_IER_FRM_RCVD_EN_ENABLE				1
+#define  CHNL_IER_AXI_WR_ERR_V_EN_OFFSET			28
+#define  CHNL_IER_AXI_WR_ERR_V_EN_MASK				0x10000000
+#define  CHNL_IER_AXI_WR_ERR_V_EN_ENABLE			1
+#define  CHNL_IER_AXI_WR_ERR_U_EN_OFFSET			27
+#define  CHNL_IER_AXI_WR_ERR_U_EN_MASK				0x8000000
+#define  CHNL_IER_AXI_WR_ERR_U_EN_ENABLE			1
+#define  CHNL_IER_AXI_WR_ERR_Y_EN_OFFSET			26
+#define  CHNL_IER_AXI_WR_ERR_Y_EN_MASK				0x4000000
+#define  CHNL_IER_AXI_WR_ERR_Y_EN_ENABLE			1
+#define  CHNL_IER_AXI_RD_ERR_EN_OFFSET				25
+#define  CHNL_IER_AXI_RD_ERR_EN_MASK				0x2000000
+#define  CHNL_IER_AXI_RD_ERR_EN_ENABLE				1
+#define  CHNL_IER_OFLW_PANIC_V_BUF_EN_OFFSET		24
+#define  CHNL_IER_OFLW_PANIC_V_BUF_EN_MASK			0x1000000
+#define  CHNL_IER_OFLW_PANIC_V_BUF_EN_ENABLE		1
+#define  CHNL_IER_EXCS_OFLW_V_BUF_EN_OFFSET			23
+#define  CHNL_IER_EXCS_OFLW_V_BUF_EN_MASK			0x800000
+#define  CHNL_IER_EXCS_OFLW_V_BUF_EN_ENABLE			1
+#define  CHNL_IER_OFLW_V_BUF_EN_OFFSET				22
+#define  CHNL_IER_OFLW_V_BUF_EN_MASK				0x400000
+#define  CHNL_IER_OFLW_V_BUF_EN_ENABLE				1
+#define  CHNL_IER_OFLW_PANIC_U_BUF_EN_OFFSET		21
+#define  CHNL_IER_OFLW_PANIC_U_BUF_EN_MASK			0x200000
+#define  CHNL_IER_OFLW_PANIC_U_BUF_EN_ENABLE		1
+#define  CHNL_IER_EXCS_OFLW_U_BUF_EN_OFFSET			20
+#define  CHNL_IER_EXCS_OFLW_U_BUF_EN_MASK			0x100000
+#define  CHNL_IER_EXCS_OFLW_U_BUF_EN_ENABLE			1
+#define  CHNL_IER_OFLW_U_BUF_EN_OFFSET				19
+#define  CHNL_IER_OFLW_U_BUF_EN_MASK				0x80000
+#define  CHNL_IER_OFLW_U_BUF_EN_ENABLE				1
+#define  CHNL_IER_OFLW_PANIC_Y_BUF_EN_OFFSET		18
+#define  CHNL_IER_OFLW_PANIC_Y_BUF_EN_MASK			0x40000
+#define  CHNL_IER_OFLW_PANIC_Y_BUF_EN_ENABLE		1
+#define  CHNL_IER_EXCS_OFLW_Y_BUF_EN_OFFSET			17
+#define  CHNL_IER_EXCS_OFLW_Y_BUF_EN_MASK			0x20000
+#define  CHNL_IER_EXCS_OFLW_Y_BUF_EN_ENABLE			1
+#define  CHNL_IER_OFLW_Y_BUF_EN_OFFSET				16
+#define  CHNL_IER_OFLW_Y_BUF_EN_MASK				0x10000
+#define  CHNL_IER_OFLW_Y_BUF_EN_ENABLE				1
+
+/* Channel Status Register */
+#define  CHNL_STS								0x14
+#define  CHNL_STS_MEM_RD_DONE_OFFSET			31
+#define  CHNL_STS_MEM_RD_DONE_MASK				0x80000000
+#define  CHNL_STS_MEM_RD_DONE_ENABLE			1
+#define  CHNL_STS_LINE_STRD_OFFSET				30
+#define  CHNL_STS_LINE_STRD_MASK				0x40000000
+#define  CHNL_STS_LINE_STRD_ENABLE				1
+#define  CHNL_STS_FRM_STRD_OFFSET				29
+#define  CHNL_STS_FRM_STRD_MASK					0x20000000
+#define  CHNL_STS_FRM_STRD_ENABLE				1
+#define  CHNL_STS_AXI_WR_ERR_V_OFFSET			28
+#define  CHNL_STS_AXI_WR_ERR_V_MASK				0x10000000
+#define  CHNL_STS_AXI_WR_ERR_V_ENABLE			1
+#define  CHNL_STS_AXI_WR_ERR_U_OFFSET			27
+#define  CHNL_STS_AXI_WR_ERR_U_MASK				0x8000000
+#define  CHNL_STS_AXI_WR_ERR_U_ENABLE			1
+#define  CHNL_STS_AXI_WR_ERR_Y_OFFSET			26
+#define  CHNL_STS_AXI_WR_ERR_Y_MASK				0x4000000
+#define  CHNL_STS_AXI_WR_ERR_Y_ENABLE			1
+#define  CHNL_STS_AXI_RD_ERR_OFFSET				25
+#define  CHNL_STS_AXI_RD_ERR_MASK				0x2000000
+#define  CHNL_STS_AXI_RD_ERR_ENABLE				1
+#define  CHNL_STS_OFLW_PANIC_V_BUF_OFFSET		24
+#define  CHNL_STS_OFLW_PANIC_V_BUF_MASK			0x1000000
+#define  CHNL_STS_OFLW_PANIC_V_BUF_ENABLE		1
+#define  CHNL_STS_EXCS_OFLW_V_BUF_OFFSET		23
+#define  CHNL_STS_EXCS_OFLW_V_BUF_MASK			0x800000
+#define  CHNL_STS_EXCS_OFLW_V_BUF_ENABLE		1
+#define  CHNL_STS_OFLW_V_BUF_OFFSET				22
+#define  CHNL_STS_OFLW_V_BUF_MASK				0x400000
+#define  CHNL_STS_OFLW_V_BUF_ENABLE				1
+#define  CHNL_STS_OFLW_PANIC_U_BUF_OFFSET		21
+#define  CHNL_STS_OFLW_PANIC_U_BUF_MASK			0x200000
+#define  CHNL_STS_OFLW_PANIC_U_BUF_ENABLE		1
+#define  CHNL_STS_EXCS_OFLW_U_BUF_OFFSET		20
+#define  CHNL_STS_EXCS_OFLW_U_BUF_MASK			0x100000
+#define  CHNL_STS_EXCS_OFLW_U_BUF_ENABLE		1
+#define  CHNL_STS_OFLW_U_BUF_OFFSET				19
+#define  CHNL_STS_OFLW_U_BUF_MASK				0x80000
+#define  CHNL_STS_OFLW_U_BUF_ENABLE				1
+#define  CHNL_STS_OFLW_PANIC_Y_BUF_OFFSET		18
+#define  CHNL_STS_OFLW_PANIC_Y_BUF_MASK			0x40000
+#define  CHNL_STS_OFLW_PANIC_Y_BUF_ENABLE		1
+#define  CHNL_STS_EXCS_OFLW_Y_BUF_OFFSET		17
+#define  CHNL_STS_EXCS_OFLW_Y_BUF_MASK			0x20000
+#define  CHNL_STS_EXCS_OFLW_Y_BUF_ENABLE		1
+#define  CHNL_STS_OFLW_Y_BUF_OFFSET				16
+#define  CHNL_STS_OFLW_Y_BUF_MASK				0x10000
+#define  CHNL_STS_OFLW_Y_BUF_ENABLE				1
+#define  CHNL_STS_OFLW_BYTES_OFFSET				0
+#define  CHNL_STS_OFLW_BYTES_MASK				0xFF
+
+/* Channel Scale Factor Register */
+#define  CHNL_SCALE_FACTOR					0x18
+#define  CHNL_SCALE_FACTOR_Y_SCALE_OFFSET	16
+#define  CHNL_SCALE_FACTOR_Y_SCALE_MASK		0x3FFF0000
+#define  CHNL_SCALE_FACTOR_X_SCALE_OFFSET	0
+#define  CHNL_SCALE_FACTOR_X_SCALE_MASK		0x3FFF
+
+/* Channel Scale Offset Register */
+#define  CHNL_SCALE_OFFSET    			   0x1C
+#define  CHNL_SCALE_OFFSET_Y_SCALE_OFFSET	16
+#define  CHNL_SCALE_OFFSET_Y_SCALE_MASK		0xFFF0000
+#define  CHNL_SCALE_OFFSET_X_SCALE_OFFSET	0
+#define  CHNL_SCALE_OFFSET_X_SCALE_MASK		0xFFF
+
+/* Channel Crop Upper Left Corner Coordinate Register */
+#define  CHNL_CROP_ULC					0x20
+#define  CHNL_CROP_ULC_X_OFFSET			16
+#define  CHNL_CROP_ULC_X_MASK			0xFFF0000
+#define  CHNL_CROP_ULC_Y_OFFSET			0
+#define  CHNL_CROP_ULC_Y_MASK			0xFFF
+
+/* Channel Crop Lower Right Corner Coordinate Register */
+#define  CHNL_CROP_LRC					0x24
+#define  CHNL_CROP_LRC_X_OFFSET			16
+#define  CHNL_CROP_LRC_X_MASK			0xFFF0000
+#define  CHNL_CROP_LRC_Y_OFFSET			0
+#define  CHNL_CROP_LRC_Y_MASK			0xFFF
+
+/* Channel Color Space Conversion Coefficient Register 0 */
+#define  CHNL_CSC_COEFF0				0x28
+#define  CHNL_CSC_COEFF0_A2_OFFSET		16
+#define  CHNL_CSC_COEFF0_A2_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF0_A1_OFFSET		0
+#define  CHNL_CSC_COEFF0_A1_MASK		0x7FF
+
+
+/* Channel Color Space Conversion Coefficient Register 1 */
+#define  CHNL_CSC_COEFF1				0x2C
+#define  CHNL_CSC_COEFF1_B1_OFFSET		16
+#define  CHNL_CSC_COEFF1_B1_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF1_A3_OFFSET		0
+#define  CHNL_CSC_COEFF1_A3_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 2 */
+#define  CHNL_CSC_COEFF2				0x30
+#define  CHNL_CSC_COEFF2_B3_OFFSET		16
+#define  CHNL_CSC_COEFF2_B3_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF2_B2_OFFSET		0
+#define  CHNL_CSC_COEFF2_B2_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 3 */
+#define  CHNL_CSC_COEFF3				0x34
+#define  CHNL_CSC_COEFF3_C2_OFFSET		16
+#define  CHNL_CSC_COEFF3_C2_MASK		0x7FF0000
+#define  CHNL_CSC_COEFF3_C1_OFFSET		0
+#define  CHNL_CSC_COEFF3_C1_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 4 */
+#define  CHNL_CSC_COEFF4				0x38
+#define  CHNL_CSC_COEFF4_D1_OFFSET		16
+#define  CHNL_CSC_COEFF4_D1_MASK		0x1FF0000
+#define  CHNL_CSC_COEFF4_C3_OFFSET		0
+#define  CHNL_CSC_COEFF4_C3_MASK		0x7FF
+
+/* Channel Color Space Conversion Coefficient Register 5 */
+#define  CHNL_CSC_COEFF5				0x3C
+#define  CHNL_CSC_COEFF5_D3_OFFSET		16
+#define  CHNL_CSC_COEFF5_D3_MASK		0x1FF0000
+#define  CHNL_CSC_COEFF5_D2_OFFSET		0
+#define  CHNL_CSC_COEFF5_D2_MASK		0x1FF
+
+/* Channel Alpha Value Register for ROI 0 */
+#define  CHNL_ROI_0_ALPHA				0x40
+#define  CHNL_ROI_0_ALPHA_OFFSET		24
+#define  CHNL_ROI_0_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_0_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_0_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 0 */
+#define  CHNL_ROI_0_ULC					0x44
+#define  CHNL_ROI_0_ULC_X_OFFSET		16
+#define  CHNL_ROI_0_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_0_ULC_Y_OFFSET		0
+#define  CHNL_ROI_0_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 0 */
+#define  CHNL_ROI_0_LRC					0x48
+#define  CHNL_ROI_0_LRC_X_OFFSET		16
+#define  CHNL_ROI_0_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_0_LRC_Y_OFFSET		0
+#define  CHNL_ROI_0_LRC_Y_MASK			0xFFF
+
+/* Channel Alpha Value Register for ROI 1 */
+#define  CHNL_ROI_1_ALPHA				0x4C
+#define  CHNL_ROI_1_ALPHA_OFFSET		24
+#define  CHNL_ROI_1_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_1_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_1_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 1 */
+#define  CHNL_ROI_1_ULC					0x50
+#define  CHNL_ROI_1_ULC_X_OFFSET		16
+#define  CHNL_ROI_1_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_1_ULC_Y_OFFSET		0
+#define  CHNL_ROI_1_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 1 */
+#define  CHNL_ROI_1_LRC					0x54
+#define  CHNL_ROI_1_LRC_X_OFFSET		16
+#define  CHNL_ROI_1_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_1_LRC_Y_OFFSET		0
+#define  CHNL_ROI_1_LRC_Y_MASK			0xFFF
+
+/* Channel Alpha Value Register for ROI 2 */
+#define  CHNL_ROI_2_ALPHA				0x58
+#define  CHNL_ROI_2_ALPHA_OFFSET		24
+#define  CHNL_ROI_2_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_2_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_2_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 2 */
+#define  CHNL_ROI_2_ULC					0x5C
+#define  CHNL_ROI_2_ULC_X_OFFSET		16
+#define  CHNL_ROI_2_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_2_ULC_Y_OFFSET		0
+#define  CHNL_ROI_2_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 2 */
+#define  CHNL_ROI_2_LRC					0x60
+#define  CHNL_ROI_2_LRC_X_OFFSET		16
+#define  CHNL_ROI_2_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_2_LRC_Y_OFFSET		0
+#define  CHNL_ROI_2_LRC_Y_MASK			0xFFF
+
+/* Channel Alpha Value Register for ROI 3 */
+#define  CHNL_ROI_3_ALPHA				0x64
+#define  CHNL_ROI_3_ALPHA_OFFSET		24
+#define  CHNL_ROI_3_ALPHA_MASK			0xFF000000
+#define  CHNL_ROI_3_ALPHA_EN_OFFSET		16
+#define  CHNL_ROI_3_ALPHA_EN_MASK		0x10000
+
+/* Channel Upper Left Coordinate Register for ROI 3 */
+#define  CHNL_ROI_3_ULC					0x68
+#define  CHNL_ROI_3_ULC_X_OFFSET		16
+#define  CHNL_ROI_3_ULC_X_MASK			0xFFF0000
+#define  CHNL_ROI_3_ULC_Y_OFFSET		0
+#define  CHNL_ROI_3_ULC_Y_MASK			0xFFF
+
+/* Channel Lower Right Coordinate Register for ROI 3 */
+#define  CHNL_ROI_3_LRC					0x6C
+#define  CHNL_ROI_3_LRC_X_OFFSET		16
+#define  CHNL_ROI_3_LRC_X_MASK			0xFFF0000
+#define  CHNL_ROI_3_LRC_Y_OFFSET		0
+#define  CHNL_ROI_3_LRC_Y_MASK			0xFFF
+
+/* Channel RGB or Luma (Y) Output Buffer 1 Address */
+#define  CHNL_OUT_BUF1_ADDR_Y			0x70
+
+/* Channel Chroma (U/Cb/UV/CbCr) Output Buffer 1 Address */
+#define  CHNL_OUT_BUF1_ADDR_U			0x74
+
+/* Channel Chroma (V/Cr) Output Buffer 1 Address */
+#define  CHNL_OUT_BUF1_ADDR_V			0x78
+
+/* Channel Output Buffer Pitch */
+#define  CHNL_OUT_BUF_PITCH						0x7C
+#define  CHNL_OUT_BUF_PITCH_LINE_PITCH_OFFSET	0
+#define  CHNL_OUT_BUF_PITCH_LINE_PITCH_MASK	 	0xFFFF
+
+/* Channel Input Buffer Address */
+#define  CHNL_IN_BUF_ADDR						0x80
+
+/* Channel Input Buffer Pitch */
+#define  CHNL_IN_BUF_PITCH						0x84
+#define  CHNL_IN_BUF_PITCH_FRM_PITCH_OFFSET		16
+#define  CHNL_IN_BUF_PITCH_FRM_PITCH_MASK	 	0xFFFF0000
+#define  CHNL_IN_BUF_PITCH_LINE_PITCH_OFFSET	0
+#define  CHNL_IN_BUF_PITCH_LINE_PITCH_MASK	 	0xFFFF
+
+/* Channel Memory Read Control */
+#define  CHNL_MEM_RD_CTRL						0x88
+#define  CHNL_MEM_RD_CTRL_IMG_TYPE_OFFSET		28
+#define  CHNL_MEM_RD_CTRL_IMG_TYPE_MASK			0xF0000000
+#define  CHNL_MEM_RD_CTRL_READ_MEM_OFFSET		0
+#define  CHNL_MEM_RD_CTRL_READ_MEM_MASK			1
+#define  CHNL_MEM_RD_CTRL_READ_MEM_ENABLE		1
+
+/* Channel RGB or Luma (Y) Output Buffer 2 Address */
+#define  CHNL_OUT_BUF2_ADDR_Y		0x8C
+
+/* Channel Chroma (U/Cb/UV/CbCr) Output Buffer 2 Address  */
+#define  CHNL_OUT_BUF2_ADDR_U		0x90
+
+/* Channel Chroma (V/Cr) Output Buffer 2 Address   */
+#define  CHNL_OUT_BUF2_ADDR_V		0x94
+
+enum isi_csi_coeff {
+	YUV2RGB = 0,
+	RGB2YUV,
+};
+struct colorspace_coeffs {
+	u32	coeff[6];
+};
+
+void mxc_isi_channel_init(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_deinit(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_config(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_enable(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_disable(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_outbuf(struct mxc_isi_dev *mxc_isi, struct mxc_isi_buffer *buf);
+void mxc_isi_frame_write_done(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_frame_read_done(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_deinterlace(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_sw_reset(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_source_config(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_flip(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_csc(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_alpha_roi0(struct mxc_isi_dev *mxc_isi, struct v4l2_rect *rect);
+void mxc_isi_channel_set_alpha(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_4k(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_deinterlace(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_crop(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_memory_image(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_channel_set_scaler(struct mxc_isi_dev *mxc_isi);
+
+void mxc_isi_clean_irq_status(struct mxc_isi_dev *mxc_isi, u32 val);
+u32 mxc_isi_get_irq_status(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_enable_irq(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_disable_irq(struct mxc_isi_dev *mxc_isi);
+
+#endif /* MXC_ISI_HW_H_ */
diff --git a/drivers/media/platform/imx8/mxc-media-dev.c b/drivers/media/platform/imx8/mxc-media-dev.c
new file mode 100644
index 0000000..f666a9c
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-media-dev.c
@@ -0,0 +1,603 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/bug.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/media-device.h>
+
+#include "mxc-media-dev.h"
+#include "mxc-isi-core.h"
+#include "mxc-mipi-csi2.h"
+
+/*create default links between registered entities  */
+static int mxc_md_create_links(struct mxc_md *mxc_md)
+{
+	struct media_entity *source, *sink;
+	struct mxc_isi_dev *mxc_isi;
+	struct mxc_sensor_info *sensor;
+	struct mxc_mipi_csi2_dev *mipi_csi2;
+	int i, j, ret = 0;
+	u16  source_pad, sink_pad;
+	u32 flags;
+	u32 mipi_vc = 0;
+
+	/* Create links between each ISI's subdev and video node */
+	flags = MEDIA_LNK_FL_ENABLED;
+	for (i = 0; i < MXC_ISI_MAX_DEVS; i++) {
+		mxc_isi = mxc_md->mxc_isi[i];
+		if (!mxc_isi)
+			continue;
+
+		/* Connect ISI source to video device */
+		source = &mxc_isi->isi_cap.sd.entity;
+		sink = &mxc_isi->isi_cap.vdev.entity;
+		sink_pad = 0;
+
+		switch (mxc_isi->interface[OUT_PORT]) {
+		case ISI_OUTPUT_INTERFACE_DC0:
+			source_pad = MXC_ISI_SD_PAD_SOURCE_DC0;
+			break;
+		case ISI_OUTPUT_INTERFACE_DC1:
+			source_pad = MXC_ISI_SD_PAD_SOURCE_DC1;
+			break;
+		case ISI_OUTPUT_INTERFACE_MEM:
+			source_pad = MXC_ISI_SD_PAD_SOURCE_MEM;
+			break;
+		default:
+			v4l2_err(&mxc_md->v4l2_dev, "Wrong output interface: %x\n",
+				mxc_isi->interface[OUT_PORT]);
+			return -EINVAL;
+		}
+
+		ret = media_create_pad_link(source, source_pad,
+					      sink, sink_pad, flags);
+		if (ret) {
+			v4l2_err(&mxc_md->v4l2_dev, "Failed created link [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+			break;
+		}
+
+		/* Notify capture subdev entity ,ISI cap link setup */
+		ret = media_entity_call(source, link_setup, &source->pads[source_pad],
+						&sink->pads[sink_pad], flags);
+		if (ret) {
+			v4l2_err(&mxc_md->v4l2_dev, "failed call link_setup [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+			break;
+		}
+
+		v4l2_info(&mxc_md->v4l2_dev, "created link [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+
+		/* Connect MIPI/HDMI/Mem source to ISI sink */
+		sink = &mxc_isi->isi_cap.sd.entity;
+
+		switch (mxc_isi->interface[IN_PORT]) {
+
+		case ISI_INPUT_INTERFACE_MIPI0_CSI2:
+			if (mxc_md->mipi_csi2[0] == NULL)
+				continue;
+			source = &mxc_md->mipi_csi2[0]->sd.entity;
+
+			switch (mxc_isi->interface[SUB_IN_PORT]) {
+			case ISI_INPUT_SUB_INTERFACE_VC1:
+				source_pad = MXC_MIPI_CSI2_VC1_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC1;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC2:
+				source_pad = MXC_MIPI_CSI2_VC2_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC2;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC3:
+				source_pad = MXC_MIPI_CSI2_VC3_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC3;
+				break;
+			default:
+				source_pad = MXC_MIPI_CSI2_VC0_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI0_VC0;
+				break;
+			}
+			break;
+
+		case ISI_INPUT_INTERFACE_MIPI1_CSI2:
+			if (mxc_md->mipi_csi2[1] == NULL)
+				continue;
+			source = &mxc_md->mipi_csi2[1]->sd.entity;
+
+			switch (mxc_isi->interface[SUB_IN_PORT]) {
+			case ISI_INPUT_SUB_INTERFACE_VC1:
+				source_pad = MXC_MIPI_CSI2_VC1_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC1;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC2:
+				source_pad = MXC_MIPI_CSI2_VC2_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC2;
+				break;
+			case ISI_INPUT_SUB_INTERFACE_VC3:
+				source_pad = MXC_MIPI_CSI2_VC3_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC3;
+				break;
+			default:
+				source_pad = MXC_MIPI_CSI2_VC0_PAD_SOURCE;
+				sink_pad = MXC_ISI_SD_PAD_SINK_MIPI1_VC0;
+				break;
+			}
+			break;
+
+		case ISI_INPUT_INTERFACE_HDMI:
+		case ISI_INPUT_INTERFACE_DC0:
+		case ISI_INPUT_INTERFACE_DC1:
+		case ISI_INPUT_INTERFACE_MEM:
+		default:
+			v4l2_err(&mxc_md->v4l2_dev, "Not support input interface: %x\n",
+				mxc_isi->interface[IN_PORT]);
+			return -EINVAL;
+		}
+		/* Create link MIPI/HDMI to ISI */
+		ret = media_create_pad_link(source, source_pad, sink, sink_pad, flags);
+		if (ret) {
+			v4l2_err(&mxc_md->v4l2_dev, "created link [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+			break;
+		}
+
+		/* Notify ISI subdev entity */
+		ret = media_entity_call(sink, link_setup, &sink->pads[sink_pad],
+					&source->pads[source_pad], 0);
+		if (ret)
+			break;
+
+		/* Notify MIPI/HDMI entity */
+		ret = media_entity_call(source, link_setup, &source->pads[source_pad],
+					&sink->pads[sink_pad], 0);
+		if (ret)
+			break;
+
+		v4l2_info(&mxc_md->v4l2_dev, "created link [%s] %c> [%s]\n",
+			  source->name, flags ? '=' : '-', sink->name);
+	}
+
+	/* Connect MIPI Sensor to MIPI CSI2 */
+	for (i = 0; i < mxc_md->num_sensors; i++) {
+		sensor = &mxc_md->sensor[i];
+		if (sensor == NULL || sensor->sd == NULL)
+			continue;
+
+		mipi_csi2 = mxc_md->mipi_csi2[sensor->id];
+		if (mipi_csi2 ==  NULL)
+			continue;
+
+		source = &sensor->sd->entity;
+		sink = &mipi_csi2->sd.entity;
+
+		source_pad = 0;  //sensor source pad: MIPI_CSI2_SENS_VC0_PAD_SOURCE
+		sink_pad = source_pad;  //mipi sink pad: MXC_MIPI_CSI2_VC0_PAD_SINK;
+
+		if (mipi_csi2->vchannel == true)
+			mipi_vc = 4;
+		else
+			mipi_vc = 0;
+
+		for (j = 0; j < mipi_vc; j++) {
+			ret = media_create_pad_link(source, source_pad + j, sink, sink_pad + j,
+				      MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+			if (ret)
+				return ret;
+
+			/* Notify MIPI subdev entity */
+			ret = media_entity_call(sink, link_setup, &sink->pads[sink_pad + j],
+						&source->pads[source_pad + j], 0);
+			if (ret)
+				return ret;
+
+			/* Notify MIPI sensor subdev entity */
+			ret = media_entity_call(source, link_setup, &source->pads[source_pad + j],
+						&sink->pads[sink_pad + j], 0);
+			if (ret)
+				return ret;
+		}
+
+		v4l2_info(&mxc_md->v4l2_dev, "created link [%s] => [%s]\n",
+			  sensor->sd->entity.name, mipi_csi2->sd.entity.name);
+	}
+
+	/* TODO */
+	/* Notify HDMI IN / DC0 / DC1 subdev entity */
+	return 0;
+}
+
+static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *sd,
+				 struct v4l2_async_subdev *asd)
+{
+	struct mxc_md *mxc_md = notifier_to_mxc_md(notifier);
+	struct mxc_sensor_info *sensor = NULL;
+	int i;
+
+	/* Find platform data for this sensor subdev */
+	for (i = 0; i < ARRAY_SIZE(mxc_md->sensor); i++) {
+		if (mxc_md->sensor[i].asd.match.fwnode.fwnode ==
+				of_fwnode_handle(sd->dev->of_node))
+			sensor = &mxc_md->sensor[i];
+	}
+
+	if (sensor == NULL)
+		return -EINVAL;
+
+	sd->grp_id = GRP_ID_MXC_SENSOR;
+
+	sensor->sd = sd;
+
+	mxc_md->num_sensors++;
+
+	v4l2_info(&mxc_md->v4l2_dev, "Registered sensor subdevice: %s (%d)\n",
+		  sd->name, mxc_md->num_sensors);
+
+	return 0;
+}
+
+static int subdev_notifier_complete(struct v4l2_async_notifier *notifier)
+{
+	struct mxc_md *mxc_md = notifier_to_mxc_md(notifier);
+	int ret;
+
+	mutex_lock(&mxc_md->media_dev.graph_mutex);
+
+	ret = mxc_md_create_links(mxc_md);
+	if (ret < 0)
+		goto unlock;
+
+	ret = v4l2_device_register_subdev_nodes(&mxc_md->v4l2_dev);
+unlock:
+	mutex_unlock(&mxc_md->media_dev.graph_mutex);
+	if (ret < 0) {
+		v4l2_err(&mxc_md->v4l2_dev, "%s error exit\n", __func__);
+		return ret;
+	}
+
+	return media_device_register(&mxc_md->media_dev);
+}
+
+
+/**
+ * mxc_sensor_notify - v4l2_device notification from a sensor subdev
+ */
+void mxc_sensor_notify(struct v4l2_subdev *sd, unsigned int notification,
+			void *arg)
+{
+	return;
+}
+
+/* Register mipi sensor sub-devices */
+static int register_sensor_entities(struct mxc_md *mxc_md)
+{
+	struct device_node *parent = mxc_md->pdev->dev.of_node;
+	struct device_node *node, *ep, *rem;
+	struct v4l2_fwnode_endpoint endpoint;
+	int index = 0;
+
+	mxc_md->num_sensors = 0;
+
+	/* Attach sensors linked to MIPI CSI2 */
+	for_each_available_child_of_node(parent, node) {
+		struct device_node *port;
+
+		if (of_node_cmp(node->name, "csi"))
+			continue;
+		/* csi2 node have only port */
+		port = of_get_next_child(node, NULL);
+		if (!port)
+			continue;
+
+		/* port can have only endpoint */
+		ep = of_get_next_child(port, NULL);
+		if (!ep)
+			return -EINVAL;
+
+		v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &endpoint);
+		if (WARN_ON(endpoint.base.port >= MXC_MAX_MIPI_SENSORS)) {
+			v4l2_err(&mxc_md->v4l2_dev, "Failed to get sensor endpoint\n");
+			return -EINVAL;
+		}
+
+		mxc_md->sensor[index].id = endpoint.base.port;
+
+		/* remote port---sensor node */
+		rem = of_graph_get_remote_port_parent(ep);
+		of_node_put(ep);
+		if (rem == NULL) {
+			v4l2_info(&mxc_md->v4l2_dev, "Remote device at %s not found\n",
+								ep->full_name);
+			continue;
+		}
+
+		mxc_md->sensor[index].asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		mxc_md->sensor[index].asd.match.fwnode.fwnode = of_fwnode_handle(rem);
+		mxc_md->async_subdevs[index] = &mxc_md->sensor[index].asd;
+
+		mxc_md->num_sensors++;
+
+		index++;
+	}
+
+	return 0;
+}
+
+static int register_isi_entity(struct mxc_md *mxc_md, struct mxc_isi_dev *mxc_isi)
+{
+	struct v4l2_subdev *sd = &mxc_isi->isi_cap.sd;
+	int ret;
+
+	if (WARN_ON(mxc_isi->id >= MXC_ISI_MAX_DEVS || mxc_md->mxc_isi[mxc_isi->id]))
+		return -EBUSY;
+
+	sd->grp_id = GRP_ID_MXC_ISI;
+
+	ret = v4l2_device_register_subdev(&mxc_md->v4l2_dev, sd);
+	if (!ret)
+		mxc_md->mxc_isi[mxc_isi->id] = mxc_isi;
+	else
+		v4l2_err(&mxc_md->v4l2_dev, "Failed to register ISI.%d (%d)\n",
+			 mxc_isi->id, ret);
+	return ret;
+}
+
+static int register_mipi_csi2_entity(struct mxc_md *mxc_md,
+				struct mxc_mipi_csi2_dev *mipi_csi2)
+{
+	struct v4l2_subdev *sd = &mipi_csi2->sd;
+	int ret;
+
+	if (WARN_ON(mipi_csi2->id >= MXC_MIPI_CSI2_MAX_DEVS))
+		return -ENOENT;
+
+	sd->grp_id = GRP_ID_MXC_MIPI_CSI2;
+	ret = v4l2_device_register_subdev(&mxc_md->v4l2_dev, sd);
+	if (!ret)
+		mxc_md->mipi_csi2[mipi_csi2->id] = mipi_csi2;
+	else
+		v4l2_err(&mxc_md->v4l2_dev,
+			 "Failed to register MIPI-CSIS.%d (%d)\n", mipi_csi2->id, ret);
+	return ret;
+}
+
+static int mxc_md_register_platform_entity(struct mxc_md *mxc_md,
+					    struct platform_device *pdev,
+					    int plat_entity)
+{
+	struct device *dev = &pdev->dev;
+	int ret = -EPROBE_DEFER;
+	void *drvdata;
+
+	/* Lock to ensure dev->driver won't change. */
+	device_lock(dev);
+
+	if (!dev->driver || !try_module_get(dev->driver->owner))
+		goto dev_unlock;
+
+	drvdata = dev_get_drvdata(dev);
+	/* Some subdev didn't probe successfully id drvdata is NULL */
+	if (drvdata) {
+		switch (plat_entity) {
+		case IDX_ISI:
+			ret = register_isi_entity(mxc_md, drvdata);
+			break;
+		case IDX_MIPI_CSI2:
+			ret = register_mipi_csi2_entity(mxc_md, drvdata);
+			break;
+		default:
+			ret = -ENODEV;
+		}
+	}
+	module_put(dev->driver->owner);
+
+dev_unlock:
+	device_unlock(dev);
+	if (ret == -EPROBE_DEFER)
+		dev_info(&mxc_md->pdev->dev, "deferring %s device registration\n",
+			dev_name(dev));
+	else if (ret < 0)
+		dev_err(&mxc_md->pdev->dev, "%s device registration failed (%d)\n",
+			dev_name(dev), ret);
+
+	return ret;
+}
+
+/* Register ISI, MIPI CSI2 and HDMI In Media entities */
+static int mxc_md_register_platform_entities(struct mxc_md *mxc_md,
+					      struct device_node *parent)
+{
+	struct device_node *node;
+	int ret = 0;
+
+	for_each_available_child_of_node(parent, node) {
+		struct platform_device *pdev;
+		int plat_entity = -1;
+
+		pdev = of_find_device_by_node(node);
+		if (!pdev)
+			continue;
+
+		/* If driver of any entity isn't ready try all again later. */
+		if (!strcmp(node->name, ISI_OF_NODE_NAME))
+			plat_entity = IDX_ISI;
+		else if (!strcmp(node->name, MIPI_CSI2_OF_NODE_NAME))
+			plat_entity = IDX_MIPI_CSI2;
+
+		if (plat_entity >= 0)
+			ret = mxc_md_register_platform_entity(mxc_md, pdev,
+							plat_entity);
+		put_device(&pdev->dev);
+		if (ret < 0)
+			break;
+	}
+
+	return ret;
+}
+
+static void mxc_md_unregister_entities(struct mxc_md *mxc_md)
+{
+	int i;
+
+	for (i = 0; i < MXC_ISI_MAX_DEVS; i++) {
+		struct mxc_isi_dev *dev = mxc_md->mxc_isi[i];
+		if (dev == NULL)
+			continue;
+		v4l2_device_unregister_subdev(&dev->isi_cap.sd);
+		mxc_md->mxc_isi[i] = NULL;
+	}
+	for (i = 0; i < MXC_MIPI_CSI2_MAX_DEVS; i++) {
+		if (mxc_md->mipi_csi2[i] == NULL)
+			continue;
+		v4l2_device_unregister_subdev(&mxc_md->mipi_csi2[i]->sd);
+		mxc_md->mipi_csi2[i] = NULL;
+	}
+
+	v4l2_info(&mxc_md->v4l2_dev, "Unregistered all entities\n");
+}
+
+static int mxc_md_link_notify(struct media_link *link, unsigned int flags,
+				unsigned int notification)
+{
+	return 0;
+}
+
+static const struct media_device_ops mxc_md_ops = {
+	.link_notify = mxc_md_link_notify,
+};
+
+
+static int mxc_md_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct v4l2_device *v4l2_dev;
+	struct mxc_md *mxc_md;
+	int ret;
+
+	mxc_md = devm_kzalloc(dev, sizeof(*mxc_md), GFP_KERNEL);
+	if (!mxc_md)
+		return -ENOMEM;
+
+	mxc_md->pdev = pdev;
+	platform_set_drvdata(pdev, mxc_md);
+
+	/* register media device  */
+	strlcpy(mxc_md->media_dev.model, "FSL Capture Media Deivce",
+		sizeof(mxc_md->media_dev.model));
+	mxc_md->media_dev.ops = &mxc_md_ops;
+	mxc_md->media_dev.dev = dev;
+
+	/* register v4l2 device */
+	v4l2_dev = &mxc_md->v4l2_dev;
+	v4l2_dev->mdev = &mxc_md->media_dev;
+	v4l2_dev->notify = mxc_sensor_notify;
+	strlcpy(v4l2_dev->name, "mx8-img-md", sizeof(v4l2_dev->name));
+
+	media_device_init(&mxc_md->media_dev);
+
+	ret = v4l2_device_register(dev, &mxc_md->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register v4l2_device: %d\n", ret);
+		goto err_md;
+	}
+
+	ret = mxc_md_register_platform_entities(mxc_md, dev->of_node);
+	if (ret < 0)
+		goto err_v4l2_dev;
+
+	ret = register_sensor_entities(mxc_md);
+	if (ret < 0)
+		goto err_m_ent;
+
+	if (mxc_md->num_sensors > 0) {
+		mxc_md->subdev_notifier.subdevs = mxc_md->async_subdevs;
+		mxc_md->subdev_notifier.num_subdevs = mxc_md->num_sensors;
+		mxc_md->subdev_notifier.bound = subdev_notifier_bound;
+		mxc_md->subdev_notifier.complete = subdev_notifier_complete;
+		mxc_md->num_sensors = 0;
+
+		ret = v4l2_async_notifier_register(&mxc_md->v4l2_dev,
+						&mxc_md->subdev_notifier);
+		if (ret < 0) {
+			printk("Sensor register failed\n");
+			goto err_m_ent;
+		}
+	}
+
+	return 0;
+
+err_m_ent:
+	mxc_md_unregister_entities(mxc_md);
+err_v4l2_dev:
+	v4l2_device_unregister(&mxc_md->v4l2_dev);
+err_md:
+	media_device_cleanup(&mxc_md->media_dev);
+	return ret;
+}
+
+static int mxc_md_remove(struct platform_device *pdev)
+{
+	struct mxc_md *mxc_md = platform_get_drvdata(pdev);
+
+	if (!mxc_md)
+		return 0;
+
+	v4l2_async_notifier_unregister(&mxc_md->subdev_notifier);
+
+	v4l2_device_unregister(&mxc_md->v4l2_dev);
+	mxc_md_unregister_entities(mxc_md);
+	media_device_unregister(&mxc_md->media_dev);
+	media_device_cleanup(&mxc_md->media_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mxc_md_of_match[] = {
+	{	.compatible = "fsl,mxc-md",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mxc_md_of_match);
+
+
+static struct platform_driver mxc_md_driver = {
+	.driver = {
+		.name = MXC_MD_DRIVER_NAME,
+		.of_match_table	= mxc_md_of_match,
+	},
+	.probe = mxc_md_probe,
+	.remove = mxc_md_remove,
+};
+
+module_platform_driver(mxc_md_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Media Device driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MXC_MD_DRIVER_NAME);
diff --git a/drivers/media/platform/imx8/mxc-media-dev.h b/drivers/media/platform/imx8/mxc-media-dev.h
new file mode 100644
index 0000000..fc095a6
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-media-dev.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef MXC_MEDIA_DEV_H_
+#define MXC_MEDIA_DEV_H_
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/bug.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/list.h>
+#include <linux/mfd/syscon.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <media/media-device.h>
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+
+#include "mxc-mipi-csi2.h"
+#include "mxc-isi-core.h"
+#include "mxc-isi-hw.h"
+
+#define MXC_MD_DRIVER_NAME	"mxc-md"
+#define MXC_MAX_MIPI_SENSORS 2
+
+#define MJPEG_DEC_OF_NODE_NAME	"jpegdec"
+#define MJPEG_ENC_OF_NODE_NAME	"jpegenc"
+
+/*
+ * The subdevices' group IDs.
+ */
+#define GRP_ID_MXC_SENSOR		(1 << 8)
+#define GRP_ID_MXC_ISI			(1 << 9)
+#define GRP_ID_MXC_MIPI_CSI2	(1 << 11)
+#define GRP_ID_MXC_HDMI_IN		(1 << 12)
+#define GRP_ID_MXC_MJPEG_DEC	(1 << 13)
+#define GRP_ID_MXC_MJPEG_ENC	(1 << 14)
+
+enum mxc_subdev_index {
+	IDX_SENSOR,
+	IDX_ISI,
+	IDX_MIPI_CSI2,
+	IDX_HDMI_IN,
+	IDX_MJPEG_ENC,
+	IDX_MJPEG_DEC,
+	IDX_MAX,
+};
+
+struct mxc_sensor_info {
+	int				id;
+	struct v4l2_subdev		*sd;
+	struct v4l2_async_subdev asd;
+//	struct mxc_isi_dev *host;
+};
+
+struct mxc_mjpeg_dec{
+	struct v4l2_device		*v4l2_dev;
+	struct v4l2_subdev		sd;
+};
+
+struct mxc_mjpeg_enc{
+	struct v4l2_device		*v4l2_dev;
+	struct v4l2_subdev		sd;
+};
+
+struct mxc_md {
+	struct mxc_isi_dev *mxc_isi[MXC_ISI_MAX_DEVS];
+	struct mxc_hdmi_in_dev *hdmi_in;
+	struct mxc_mipi_csi2_dev *mipi_csi2[MXC_MIPI_CSI2_MAX_DEVS];
+	struct mxc_sensor_info sensor[MXC_MAX_MIPI_SENSORS];
+	struct mxc_mjpeg_dec  *mjpeg_dec;
+	struct mxc_mjpeg_enc  *mjpeg_enc;
+
+	int num_sensors;
+
+	struct media_device media_dev;
+	struct v4l2_device v4l2_dev;
+	struct platform_device *pdev;
+
+	struct v4l2_async_notifier subdev_notifier;
+	struct v4l2_async_subdev *async_subdevs[MXC_MAX_MIPI_SENSORS];
+};
+
+static inline struct mxc_md *notifier_to_mxc_md(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct mxc_md, subdev_notifier);
+};
+
+int mxc_isi_initialize_capture_subdev(struct mxc_isi_dev *mxc_isi);
+void mxc_isi_unregister_capture_subdev(struct mxc_isi_dev *mxc_isi);
+int mxc_isi_register_m2m_device(struct mxc_isi_dev *mxc_isi,
+			     struct v4l2_device *v4l2_dev);
+void mxc_sensor_notify(struct v4l2_subdev *sd, unsigned int notification,
+			void *arg);
+void mxc_isi_unregister_m2m_device(struct mxc_isi_dev *mxc_isi);
+int mxc_isi_register_driver(void);
+void mxc_isi_unregister_driver(void);
+#endif
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2.c b/drivers/media/platform/imx8/mxc-mipi-csi2.c
new file mode 100644
index 0000000..3143152
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2.c
@@ -0,0 +1,632 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <soc/imx8/sc/sci.h>
+
+#include "mxc-mipi-csi2.h"
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+/* 0~ 80Mbps: 0xB
+ * 80~250Mbps: 0x8
+ * 250~1.5Gbps: 0x6*/
+static u8 rxhs_settle[3] = {0xB, 0x8, 0x6};
+
+static struct mxc_mipi_csi2_dev *sd_to_mxc_mipi_csi2_dev(struct v4l2_subdev *sdev)
+{
+	return container_of(sdev, struct mxc_mipi_csi2_dev, sd);
+}
+
+#ifdef debug
+static void mxc_mipi_csi2_reg_dump(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	printk("MIPI CSI2 HC register dump, mipi csi%d\n", csi2dev->id);
+	printk("MIPI CSI2 HC num of lanes     0x100 = 0x%x\n", readl(csi2dev->base_regs + 0x100));
+	printk("MIPI CSI2 HC dis lanes        0x104 = 0x%x\n", readl(csi2dev->base_regs + 0x104));
+	printk("MIPI CSI2 HC BIT ERR          0x108 = 0x%x\n", readl(csi2dev->base_regs + 0x108));
+	printk("MIPI CSI2 HC IRQ STATUS       0x10C = 0x%x\n", readl(csi2dev->base_regs + 0x10C));
+	printk("MIPI CSI2 HC IRQ MASK         0x110 = 0x%x\n", readl(csi2dev->base_regs + 0x110));
+	printk("MIPI CSI2 HC ULPS STATUS      0x114 = 0x%x\n", readl(csi2dev->base_regs + 0x114));
+	printk("MIPI CSI2 HC DPHY ErrSotHS    0x118 = 0x%x\n", readl(csi2dev->base_regs + 0x118));
+	printk("MIPI CSI2 HC DPHY ErrSotSync  0x11c = 0x%x\n", readl(csi2dev->base_regs + 0x11c));
+	printk("MIPI CSI2 HC DPHY ErrEsc      0x120 = 0x%x\n", readl(csi2dev->base_regs + 0x120));
+	printk("MIPI CSI2 HC DPHY ErrSyncEsc  0x124 = 0x%x\n", readl(csi2dev->base_regs + 0x124));
+	printk("MIPI CSI2 HC DPHY ErrControl  0x128 = 0x%x\n", readl(csi2dev->base_regs + 0x128));
+	printk("MIPI CSI2 HC DISABLE_PAYLOAD  0x12C = 0x%x\n", readl(csi2dev->base_regs + 0x12C));
+	printk("MIPI CSI2 HC DISABLE_PAYLOAD  0x130 = 0x%x\n", readl(csi2dev->base_regs + 0x130));
+	printk("MIPI CSI2 HC IGNORE_VC        0x180 = 0x%x\n", readl(csi2dev->base_regs + 0x180));
+	printk("MIPI CSI2 HC VID_VC           0x184 = 0x%x\n", readl(csi2dev->base_regs + 0x184));
+	printk("MIPI CSI2 HC FIFO_SEND_LEVEL  0x188 = 0x%x\n", readl(csi2dev->base_regs + 0x188));
+	printk("MIPI CSI2 HC VID_VSYNC        0x18C = 0x%x\n", readl(csi2dev->base_regs + 0x18C));
+	printk("MIPI CSI2 HC VID_SYNC_FP      0x190 = 0x%x\n", readl(csi2dev->base_regs + 0x190));
+	printk("MIPI CSI2 HC VID_HSYNC        0x194 = 0x%x\n", readl(csi2dev->base_regs + 0x194));
+	printk("MIPI CSI2 HC VID_HSYNC_BP     0x198 = 0x%x\n", readl(csi2dev->base_regs + 0x198));
+	printk("MIPI CSI2 CSR register dump\n");
+	printk("MIPI CSI2 CSR PLM_CTRL        0x000 = 0x%x\n", readl(csi2dev->csr_regs + 0x000));
+	printk("MIPI CSI2 CSR PHY_CTRL        0x004 = 0x%x\n", readl(csi2dev->csr_regs + 0x004));
+	printk("MIPI CSI2 CSR PHY_Status      0x008 = 0x%x\n", readl(csi2dev->csr_regs + 0x008));
+	printk("MIPI CSI2 CSR PHY_Test_Status 0x010 = 0x%x\n", readl(csi2dev->csr_regs + 0x010));
+	printk("MIPI CSI2 CSR PHY_Test_Status 0x014 = 0x%x\n", readl(csi2dev->csr_regs + 0x014));
+	printk("MIPI CSI2 CSR PHY_Test_Status 0x018 = 0x%x\n", readl(csi2dev->csr_regs + 0x018));
+	printk("MIPI CSI2 CSR PHY_Test_Status 0x01C = 0x%x\n", readl(csi2dev->csr_regs + 0x01C));
+	printk("MIPI CSI2 CSR PHY_Test_Status 0x020 = 0x%x\n", readl(csi2dev->csr_regs + 0x020));
+	printk("MIPI CSI2 CSR VC Interlaced   0x030 = 0x%x\n", readl(csi2dev->csr_regs + 0x030));
+	printk("MIPI CSI2 CSR Data Type Dis   0x038 = 0x%x\n", readl(csi2dev->csr_regs + 0x038));
+	printk("MIPI CSI2 CSR 420 1st type    0x040 = 0x%x\n", readl(csi2dev->csr_regs + 0x040));
+	printk("MIPI CSI2 CSR Ctr_Ck_Rst_Ctr  0x044 = 0x%x\n", readl(csi2dev->csr_regs + 0x044));
+	printk("MIPI CSI2 CSR Stream Fencing  0x048 = 0x%x\n", readl(csi2dev->csr_regs + 0x048));
+	printk("MIPI CSI2 CSR Stream Fencing  0x04C = 0x%x\n", readl(csi2dev->csr_regs + 0x04C));
+}
+#else
+static void mxc_mipi_csi2_reg_dump(struct mxc_mipi_csi2_dev *csi2dev)
+{
+}
+#endif
+
+static void mipi_sc_fw_init(struct mxc_mipi_csi2_dev *csi2dev, char enable)
+{
+	sc_ipc_t ipcHndl;
+	sc_err_t sciErr;
+	sc_rsrc_t	rsrc_id;
+	uint32_t mu_id;
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("Cannot obtain MU ID\n");
+		return;
+	}
+
+	sciErr = sc_ipc_open(&ipcHndl, mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_err("sc_ipc_open failed! (sciError = %d)\n", sciErr);
+		return;
+	}
+
+	if (csi2dev->id == 1)
+		rsrc_id = SC_R_CSI_1;
+	else
+		rsrc_id = SC_R_CSI_0;
+
+	sciErr = sc_misc_set_control(ipcHndl, rsrc_id, SC_C_MIPI_RESET, enable);
+	if (sciErr != SC_ERR_NONE)
+		pr_err("sc_misc_MIPI reset failed! (sciError = %d)\n", sciErr);
+
+	msleep(10);
+
+	sc_ipc_close(mu_id);
+}
+
+static void mxc_mipi_csi2_reset(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val;
+
+	/* Reset MIPI CSI */
+	val = CSI2SS_CTRL_CLK_RESET_EN | CSI2SS_CTRL_CLK_RESET_CLK_OFF;
+	writel(val, csi2dev->csr_regs + CSI2SS_CTRL_CLK_RESET);
+}
+
+static void mxc_mipi_csi2_enable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val = 0;
+
+	val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+	while (val & CSI2SS_PLM_CTRL_PL_CLK_RUN) {
+		msleep(10);
+		val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+		printk("Waiting pl clk running, val=0x%x\n", val);
+	}
+
+	/* Enable Pixel link Master*/
+	val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+	val |= CSI2SS_PLM_CTRL_ENABLE_PL;
+	writel(val, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	val |= CSI2SS_PLM_CTRL_VALID_OVERRIDE;
+	writel(val, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	/* PHY Enable */
+	val = readl(csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+	val &= ~(CSI2SS_PHY_CTRL_PD_MASK | CSI2SS_PLM_CTRL_POLARITY_MASK);
+	writel(val, csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+
+	/* Deassert reset */
+	writel(1, csi2dev->csr_regs + CSI2SS_CTRL_CLK_RESET);
+}
+
+static void mxc_mipi_csi2_disable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	/* Disable Data lanes */
+	writel(0xf, csi2dev->base_regs + CSI2RX_CFG_DISABLE_DATA_LANES);
+
+	/* Disable Pixel Link */
+	writel(0, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	/* Disable  PHY */
+	writel(0, csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+
+	/* Reset */
+	writel(2, csi2dev->csr_regs + CSI2SS_CTRL_CLK_RESET);
+}
+
+static void mxc_mipi_csi2_csr_config(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val;
+
+	/* format */
+	val = 0;
+	writel(val, csi2dev->csr_regs + CSI2SS_DATA_TYPE);
+
+	/* polarity */
+	val = readl(csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+	val &= ~(CSI2SS_PLM_CTRL_VSYNC_OVERRIDE |
+			CSI2SS_PLM_CTRL_HSYNC_OVERRIDE |
+			CSI2SS_PLM_CTRL_VALID_OVERRIDE |
+			CSI2SS_PLM_CTRL_POLARITY_MASK);
+
+	writel(val, csi2dev->csr_regs + CSI2SS_PLM_CTRL);
+
+	val = CSI2SS_PHY_CTRL_RX_ENABLE |
+		CSI2SS_PHY_CTRL_DDRCLK_EN << CSI2SS_PHY_CTRL_DDRCLK_EN_OFFSET |
+		CSI2SS_PHY_CTRL_CONT_CLK_MODE << CSI2SS_PHY_CTRL_CONT_CLK_MODE_OFFSET |
+		csi2dev->hs_settle << CSI2SS_PHY_CTRL_RX_HS_SETTLE_OFFSET |
+		CSI2SS_PHY_CTRL_PD << CSI2SS_PHY_CTRL_PD_OFFSET |
+		CSI2SS_PHY_CTRL_RTERM_SEL << CSI2SS_PHY_CTRL_RTERM_SEL_OFFSET;
+
+	writel(val, csi2dev->csr_regs + CSI2SS_PHY_CTRL);
+}
+
+static void mxc_mipi_csi2_hc_config(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	u32 val0, val1;
+	u32 i;
+
+	val0 = 0;
+
+	/* Lanes */
+	writel(csi2dev->num_lanes - 1, csi2dev->base_regs + CSI2RX_CFG_NUM_LANES);
+
+	for (i = 0; i < csi2dev->num_lanes; i++)
+		val0 |= (1 << (csi2dev->data_lanes[i] - 1));
+
+	val1 = 0xF & ~val0;
+	writel(val1, csi2dev->base_regs + CSI2RX_CFG_DISABLE_DATA_LANES);
+
+	/* Mask interrupt */
+	writel(0x1FF, csi2dev->base_regs + CSI2RX_IRQ_MASK);
+
+	/* vid_vc */
+	writel(3, csi2dev->base_regs + 0x184);
+}
+
+static struct media_pad *mxc_csi2_get_remote_sensor_pad(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct v4l2_subdev *subdev = &csi2dev->sd;
+	struct media_pad *sink_pad, *source_pad;
+	int i;
+
+	while (1) {
+		source_pad = NULL;
+		for (i = 0; i < subdev->entity.num_pads; i++) {
+			sink_pad = &subdev->entity.pads[i];
+
+			if (sink_pad->flags & MEDIA_PAD_FL_SINK) {
+				source_pad = media_entity_remote_pad(sink_pad);
+				if (source_pad)
+					break;
+			}
+		}
+		/* return first pad point in the loop  */
+		return source_pad;
+	}
+
+	if (i == subdev->entity.num_pads)
+		v4l2_err(csi2dev->v4l2_dev, "%s, No remote pad found!\n", __func__);
+
+	return NULL;
+}
+
+static int mxc_csi2_get_sensor_fmt(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct v4l2_mbus_framefmt *mf = &csi2dev->format;
+	struct v4l2_subdev *sen_sd;
+	struct media_pad *source_pad;
+	struct v4l2_subdev_format src_fmt;
+	int ret;
+
+	/* Get remote source pad */
+	source_pad = mxc_csi2_get_remote_sensor_pad(csi2dev);
+	if (source_pad == NULL) {
+		v4l2_err(csi2dev->v4l2_dev, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (sen_sd == NULL) {
+		v4l2_err(csi2dev->v4l2_dev, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	src_fmt.pad = source_pad->index;
+	ret = v4l2_subdev_call(sen_sd, pad, get_fmt, NULL, &src_fmt);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return -EINVAL;
+
+	memcpy(mf, &src_fmt.format, sizeof(struct v4l2_mbus_framefmt));
+
+	/* Update input frame size and formate  */
+	dev_info(&csi2dev->pdev->dev, "width=%d, height=%d, fmt.code=0x%x\n", mf->width, mf->height, mf->code);
+	if (src_fmt.format.height * src_fmt.format.width > 1024 * 768)
+		csi2dev->hs_settle = rxhs_settle[2];
+	else if (src_fmt.format.height * src_fmt.format.width < 480 * 320)
+		csi2dev->hs_settle = rxhs_settle[0];
+	else
+		csi2dev->hs_settle = rxhs_settle[1];
+	return 0;
+}
+
+static int mipi_csi2_clk_init(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+
+	csi2dev->clk_apb = devm_clk_get(dev, "clk_apb");
+	if (IS_ERR(csi2dev->clk_apb)) {
+		dev_err(dev, "failed to get csi apb clk\n");
+		return PTR_ERR(csi2dev->clk_apb);
+	}
+
+	csi2dev->clk_core = devm_clk_get(dev, "clk_core");
+	if (IS_ERR(csi2dev->clk_core)) {
+		dev_err(dev, "failed to get csi core clk\n");
+		return PTR_ERR(csi2dev->clk_core);
+	}
+
+	csi2dev->clk_esc = devm_clk_get(dev, "clk_esc");
+	if (IS_ERR(csi2dev->clk_esc)) {
+		dev_err(dev, "failed to get csi esc clk\n");
+		return PTR_ERR(csi2dev->clk_esc);
+	}
+
+	csi2dev->clk_pxl = devm_clk_get(dev, "clk_pxl");
+	if (IS_ERR(csi2dev->clk_pxl)) {
+		dev_err(dev, "failed to get csi pixel link clk\n");
+		return PTR_ERR(csi2dev->clk_pxl);
+	}
+
+	return 0;
+}
+
+static int mipi_csi2_clk_enable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	int ret;
+
+	ret = clk_prepare_enable(csi2dev->clk_apb);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk_apb error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(csi2dev->clk_core);
+	if (ret < 0) {
+		dev_err(dev, "%s, pre clk_core error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(csi2dev->clk_esc);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk_esc error\n", __func__);
+		return ret;
+	}
+	ret = clk_prepare_enable(csi2dev->clk_pxl);
+	if (ret < 0) {
+		dev_err(dev, "%s, prepare clk_pxl error\n", __func__);
+		return ret;
+	}
+	return ret;
+}
+
+static void mipi_csi2_clk_disable(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	clk_disable_unprepare(csi2dev->clk_apb);
+	clk_disable_unprepare(csi2dev->clk_core);
+	clk_disable_unprepare(csi2dev->clk_esc);
+	clk_disable_unprepare(csi2dev->clk_pxl);
+}
+
+static int mipi_csi2_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+/* mipi csi2 subdev media entity operations */
+static int mipi_csi2_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+	/* TODO */
+	/* Add MIPI source and sink pad link configuration */
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		switch (local->index) {
+		case MXC_MIPI_CSI2_VC0_PAD_SOURCE:
+		case MXC_MIPI_CSI2_VC1_PAD_SOURCE:
+		case MXC_MIPI_CSI2_VC2_PAD_SOURCE:
+		case MXC_MIPI_CSI2_VC3_PAD_SOURCE:
+			break;
+		default:
+			return 0;
+		}
+	} else if (local->flags & MEDIA_PAD_FL_SINK) {
+		switch (local->index) {
+		case MXC_MIPI_CSI2_VC0_PAD_SINK:
+		case MXC_MIPI_CSI2_VC1_PAD_SINK:
+		case MXC_MIPI_CSI2_VC2_PAD_SINK:
+		case MXC_MIPI_CSI2_VC3_PAD_SINK:
+			break;
+		default:
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static const struct media_entity_operations mipi_csi2_sd_media_ops = {
+	.link_setup = mipi_csi2_link_setup,
+};
+
+/*
+ * V4L2 subdev operations
+ */
+static int mipi_csi2_s_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	int ret = 0;
+
+	dev_dbg(&csi2dev->pdev->dev, "%s: %d, csi2dev: 0x%x\n",
+		 __func__, enable, csi2dev->flags);
+
+	if (enable) {
+		if (!csi2dev->running) {
+			mxc_csi2_get_sensor_fmt(csi2dev);
+			mxc_mipi_csi2_hc_config(csi2dev);
+			mxc_mipi_csi2_reset(csi2dev);
+			mxc_mipi_csi2_csr_config(csi2dev);
+			mxc_mipi_csi2_enable(csi2dev);
+			mxc_mipi_csi2_reg_dump(csi2dev);
+		}
+		csi2dev->running++;
+
+	} else {
+
+		if (csi2dev->running)
+			mxc_mipi_csi2_disable(csi2dev);
+		csi2dev->running--;
+	}
+
+	return ret;
+}
+
+static int mipi_csi2_get_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+
+	mxc_csi2_get_sensor_fmt(csi2dev);
+
+	memcpy(mf, &csi2dev->format, sizeof(struct v4l2_mbus_framefmt));
+	/* Source/Sink pads crop rectangle size */
+
+	return 0;
+}
+
+static int mipi_csi2_set_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *fmt)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops mipi_csi2_sd_internal_ops = {
+	.open = mipi_csi2_open,
+};
+
+static struct v4l2_subdev_pad_ops mipi_csi2_pad_ops = {
+	.get_fmt = mipi_csi2_get_fmt,
+	.set_fmt = mipi_csi2_set_fmt,
+};
+
+static struct v4l2_subdev_core_ops mipi_csi2_core_ops = {
+	.s_power = mipi_csi2_s_power,
+};
+
+static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
+	.s_stream = mipi_csi2_s_stream,
+};
+
+static struct v4l2_subdev_ops mipi_csi2_subdev_ops = {
+	.core = &mipi_csi2_core_ops,
+	.video = &mipi_csi2_video_ops,
+	.pad = &mipi_csi2_pad_ops,
+};
+static int mipi_csi2_parse_dt(struct mxc_mipi_csi2_dev *csi2dev)
+{
+	struct device *dev = &csi2dev->pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct v4l2_fwnode_endpoint endpoint;
+	u32 i;
+
+	csi2dev->id = of_alias_get_id(node, "csi");
+
+	csi2dev->vchannel = of_property_read_bool(node, "virtual-channel");
+
+	node = of_graph_get_next_endpoint(node, NULL);
+	if (!node) {
+		dev_err(dev, "No port node at %s\n", node->full_name);
+		return -EINVAL;
+	}
+
+	/* Get port node */
+	v4l2_fwnode_endpoint_parse(of_fwnode_handle(node), &endpoint);
+
+	csi2dev->num_lanes = endpoint.bus.mipi_csi2.num_data_lanes;
+	for (i = 0; i < 4; i++)
+		csi2dev->data_lanes[i] = endpoint.bus.mipi_csi2.data_lanes[i];
+
+	of_node_put(node);
+
+	return 0;
+}
+
+static int mipi_csi2_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *mem_res;
+	struct mxc_mipi_csi2_dev *csi2dev;
+	int ret = -ENOMEM;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+	csi2dev = devm_kzalloc(dev, sizeof(*csi2dev), GFP_KERNEL);
+	if (!csi2dev)
+		return -ENOMEM;
+
+	csi2dev->pdev = pdev;
+
+	ret = mipi_csi2_parse_dt(csi2dev);
+	if (ret < 0)
+		return -EINVAL ;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	csi2dev->base_regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(csi2dev->base_regs)) {
+		dev_err(dev, "Failed to get mipi csi2 HC register\n");
+		return PTR_ERR(csi2dev->base_regs);
+	}
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	csi2dev->csr_regs = devm_ioremap_resource(dev, mem_res);
+	if (IS_ERR(csi2dev->csr_regs)) {
+		dev_err(dev, "Failed to get mipi CSR register\n");
+		return PTR_ERR(csi2dev->csr_regs);
+	}
+
+	ret = mipi_csi2_clk_init(csi2dev);
+	if (ret < 0)
+		return -EINVAL ;
+
+	v4l2_subdev_init(&csi2dev->sd, &mipi_csi2_subdev_ops);
+
+	csi2dev->sd.owner = THIS_MODULE;
+	snprintf(csi2dev->sd.name, sizeof(csi2dev->sd.name), "%s.%d",
+		 MXC_MIPI_CSI2_SUBDEV_NAME, csi2dev->id);
+
+	csi2dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	csi2dev->sd.entity.function = MEDIA_ENT_F_IO_V4L;
+
+	csi2dev->pads[MXC_MIPI_CSI2_VC0_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC1_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC3_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2dev->pads[MXC_MIPI_CSI2_VC0_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2dev->pads[MXC_MIPI_CSI2_VC1_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2dev->pads[MXC_MIPI_CSI2_VC2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2dev->pads[MXC_MIPI_CSI2_VC3_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&csi2dev->sd.entity,
+				MXC_MIPI_CSI2_VCX_PADS_NUM, csi2dev->pads);
+	if (ret < 0)
+		goto e_clkdis;
+
+	csi2dev->sd.entity.ops = &mipi_csi2_sd_media_ops;
+
+	/* This allows to retrieve the platform device id by the host driver */
+	v4l2_set_subdevdata(&csi2dev->sd, pdev);
+
+	/* .. and a pointer to the subdev. */
+	platform_set_drvdata(pdev, csi2dev);
+
+	mipi_sc_fw_init(csi2dev, 1);
+
+	ret = mipi_csi2_clk_enable(csi2dev);
+	if (ret < 0)
+		goto e_clkdis;
+
+	dev_info(&pdev->dev, "lanes: %d, name: %s\n",
+		 csi2dev->num_lanes, csi2dev->sd.name);
+
+	csi2dev->running = 0;
+	return 0;
+
+e_clkdis:
+	media_entity_cleanup(&csi2dev->sd.entity);
+	return ret;
+}
+
+static int mipi_csi2_remove(struct platform_device *pdev)
+{
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+
+	mipi_sc_fw_init(csi2dev, 0);
+	media_entity_cleanup(&csi2dev->sd.entity);
+	mipi_csi2_clk_disable(csi2dev);
+
+	return 0;
+}
+
+static const struct of_device_id mipi_csi2_of_match[] = {
+	{	.compatible = "fsl,mxc-mipi-csi2",},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mipi_csi2_of_match);
+
+
+static struct platform_driver mipi_csi2_driver = {
+	.driver = {
+		.name = MXC_MIPI_CSI2_DRIVER_NAME,
+		.of_match_table	= mipi_csi2_of_match,
+	},
+	.probe = mipi_csi2_probe,
+	.remove = mipi_csi2_remove,
+};
+
+module_platform_driver(mipi_csi2_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC MIPI CSI2 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MXC_MIPI_CSI2_DRIVER_NAME);
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2.h b/drivers/media/platform/imx8/mxc-mipi-csi2.h
new file mode 100644
index 0000000..b451112
--- /dev/null
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2.h
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2017 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef MXC_MIPI_CSI2_H_
+#define MXC_MIPI_CSI2_H_
+
+#define MXC_MIPI_CSI2_DRIVER_NAME	"mxc-mipi-csi2"
+#define MXC_MIPI_CSI2_SUBDEV_NAME	MXC_MIPI_CSI2_DRIVER_NAME
+#define MXC_MIPI_CSI2_MAX_DEVS		2
+#define MXC_MIPI_CSI2_MAX_LANES		4
+
+#define MIPI_CSI2_OF_NODE_NAME	"csi"
+
+#define MXC_MIPI_CSI2_VC0_PAD_SINK		0
+#define MXC_MIPI_CSI2_VC1_PAD_SINK		1
+#define MXC_MIPI_CSI2_VC2_PAD_SINK		2
+#define MXC_MIPI_CSI2_VC3_PAD_SINK		3
+
+#define MXC_MIPI_CSI2_VC0_PAD_SOURCE	4
+#define MXC_MIPI_CSI2_VC1_PAD_SOURCE	5
+#define MXC_MIPI_CSI2_VC2_PAD_SOURCE	6
+#define MXC_MIPI_CSI2_VC3_PAD_SOURCE	7
+#define MXC_MIPI_CSI2_VCX_PADS_NUM		8
+
+/* Subsystem CSR */
+#define CSI2SS_BASE_OFFSET					0x0
+
+#define CSI2SS_PLM_CTRL						(CSI2SS_BASE_OFFSET + 0x0)
+#define CSI2SS_PLM_CTRL_PL_CLK_RUN			0x80000000
+#define CSI2SS_PLM_CTRL_VSYNC_OVERRIDE		0x200
+#define CSI2SS_PLM_CTRL_HSYNC_OVERRIDE		0x400
+#define CSI2SS_PLM_CTRL_VALID_OVERRIDE		0x800
+#define CSI2SS_PLM_CTRL_POLARITY_MASK		0x1000
+#define CSI2SS_PLM_CTRL_POLARITY_HIGH		0x1000
+#define CSI2SS_PLM_CTRL_POLARITY_LOW		0x0
+#define CSI2SS_PLM_CTRL_ENABLE_PL			1
+#define CSI2SS_PLM_CTRL_ENABLE_PL_OFFSET	0
+#define CSI2SS_PLM_CTRL_ENABLE_PL_MASK		1
+
+#define CSI2SS_PHY_CTRL						(CSI2SS_BASE_OFFSET + 0x4)
+#define CSI2SS_PHY_CTRL_PD					1
+#define CSI2SS_PHY_CTRL_PD_OFFSET			22
+#define CSI2SS_PHY_CTRL_PD_MASK				0x400000
+#define CSI2SS_PHY_CTRL_RTERM_SEL			1
+#define CSI2SS_PHY_CTRL_RTERM_SEL_OFFSET	21
+#define CSI2SS_PHY_CTRL_RTERM_SEL_MASK		0x200000
+#define CSI2SS_PHY_CTRL_RX_HS_SETTLE_OFFSET	4
+#define CSI2SS_PHY_CTRL_RX_HS_SETTLE_MASK	0x3F0
+#define CSI2SS_PHY_CTRL_CONT_CLK_MODE		1
+#define CSI2SS_PHY_CTRL_CONT_CLK_MODE_OFFSET	3
+#define CSI2SS_PHY_CTRL_CONT_CLK_MODE_MASK	0x8
+#define CSI2SS_PHY_CTRL_DDRCLK_EN			1
+#define CSI2SS_PHY_CTRL_DDRCLK_EN_OFFSET	2
+#define CSI2SS_PHY_CTRL_DDRCLK_EN_MASK		0x4
+#define CSI2SS_PHY_CTRL_AUTO_PD_EN			1
+#define CSI2SS_PHY_CTRL_AUTO_PD_EN_OFFSET	1
+#define CSI2SS_PHY_CTRL_AUTO_PD_EN_MASK		0x2
+#define CSI2SS_PHY_CTRL_RX_ENABLE			1
+#define CSI2SS_PHY_CTRL_RX_ENABLE_OFFSET	0
+#define CSI2SS_PHY_CTRL_RX_ENABLE_MASK		0x1
+
+#define CSI2SS_PHY_STATUS					(CSI2SS_BASE_OFFSET + 0x8)
+#define CSI2SS_PHY_TEST_STATUS				(CSI2SS_BASE_OFFSET + 0x10)
+#define CSI2SS_PHY_TEST_STATUS_D0			(CSI2SS_BASE_OFFSET + 0x14)
+#define CSI2SS_PHY_TEST_STATUS_D1			(CSI2SS_BASE_OFFSET + 0x18)
+#define CSI2SS_PHY_TEST_STATUS_D2			(CSI2SS_BASE_OFFSET + 0x1C)
+#define CSI2SS_PHY_TEST_STATUS_D3			(CSI2SS_BASE_OFFSET + 0x20)
+
+#define CSI2SS_VC_INTERLACED				(CSI2SS_BASE_OFFSET + 0x30)
+#define CSI2SS_VC_INTERLACED_VC0			1
+#define CSI2SS_VC_INTERLACED_VC1			2
+#define CSI2SS_VC_INTERLACED_VC2			4
+#define CSI2SS_VC_INTERLACED_VC3			8
+#define CSI2SS_VC_INTERLACED_OFFSET			0
+#define CSI2SS_VC_INTERLACED_MASK			0xF
+
+#define CSI2SS_DATA_TYPE						(CSI2SS_BASE_OFFSET + 0x38)
+#define CSI2SS_DATA_TYPE_LEGACY_YUV420_8BIT		(1 << 2)
+#define CSI2SS_DATA_TYPE_YUV422_8BIT       		(1 << 6)
+#define CSI2SS_DATA_TYPE_YUV422_10BIT      		(1 << 7)
+#define CSI2SS_DATA_TYPE_RGB444					(1 << 8)
+#define CSI2SS_DATA_TYPE_RGB555					(1 << 9)
+#define CSI2SS_DATA_TYPE_RGB565					(1 << 10)
+#define CSI2SS_DATA_TYPE_RGB666					(1 << 11)
+#define CSI2SS_DATA_TYPE_RGB888					(1 << 12)
+#define CSI2SS_DATA_TYPE_RAW6					(1 << 16)
+#define CSI2SS_DATA_TYPE_RAW8					(1 << 18)
+#define CSI2SS_DATA_TYPE_RAW10					(1 << 19)
+#define CSI2SS_DATA_TYPE_RAW12					(1 << 20)
+#define CSI2SS_DATA_TYPE_RAW14					(1 << 21)
+
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE		(CSI2SS_BASE_OFFSET + 0x40)
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_ODD	0
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_EVEN	1
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_OFFSET	0
+#define CSI2SS_YUV420_1ST_LINE_DATA_TYPE_MASK	1
+
+#define CSI2SS_CTRL_CLK_RESET					(CSI2SS_BASE_OFFSET + 0x44)
+#define CSI2SS_CTRL_CLK_RESET_EN				1
+#define CSI2SS_CTRL_CLK_RESET_OFFSET			0
+#define CSI2SS_CTRL_CLK_RESET_MASK				1
+#define CSI2SS_CTRL_CLK_RESET_CLK_OFF			1
+#define CSI2SS_CTRL_CLK_RESET_CLK_OFFSET		1
+#define CSI2SS_CTRL_CLK_RESET_CLK_MASK			0x1
+
+#define CSI2SS_STREAM_FENCE_CTRL				(CSI2SS_BASE_OFFSET + 0x48)
+#define CSI2SS_STREAM_FENCE_VC0					1
+#define CSI2SS_STREAM_FENCE_VC1					2
+#define CSI2SS_STREAM_FENCE_VC2					4
+#define CSI2SS_STREAM_FENCE_VC3					8
+#define CSI2SS_STREAM_FENCE_CTRL_OFFSET			0
+#define CSI2SS_STREAM_FENCE_CTRL_MASK			0xF
+
+#define CSI2SS_STREAM_FENCE_STATUS				(CSI2SS_BASE_OFFSET + 0x4C)
+
+/* CSI-2 controller CSR */
+#define CSI2RX_BASE_OFFSET						(0x100)
+
+#define CSI2RX_CFG_NUM_LANES					(CSI2RX_BASE_OFFSET + 0x0)
+#define CSI2RX_CFG_NUM_LANES_OFFSET				0
+#define CSI2RX_CFG_NUM_LANES_MASK				0x3
+
+#define CSI2RX_CFG_DISABLE_DATA_LANES			(CSI2RX_BASE_OFFSET + 0x4)
+#define CSI2RX_CFG_DISABLE_DATA_LANES_3			8
+#define CSI2RX_CFG_DISABLE_DATA_LANES_2			4
+#define CSI2RX_CFG_DISABLE_DATA_LANES_1			2
+#define CSI2RX_CFG_DISABLE_DATA_LANES_0			1
+#define CSI2RX_CFG_DISABLE_DATA_LANES_OFFSET	0
+#define CSI2RX_CFG_DISABLE_DATA_LANES_MASK		0xF
+
+#define CSI2RX_BIT_ERR								(CSI2RX_BASE_OFFSET + 0x8)
+
+#define CSI2RX_IRQ_STATUS							(CSI2RX_BASE_OFFSET + 0xC)
+#define CSI2RX_IRQ_STATUS_CRC_ERROR					0x1
+#define CSI2RX_IRQ_STATUS_1BIT_CRC_ERROR			0x2
+#define CSI2RX_IRQ_STATUS_2BIT_CRC_ERROR			0x4
+#define CSI2RX_IRQ_STATUS_ULPS_CHANGE				0x8
+#define CSI2RX_IRQ_STATUS_DPHY_ERRSOTHS				0x10
+#define CSI2RX_IRQ_STATUS_DPHY_ERRSOTSYNC_HS		0x20
+#define CSI2RX_IRQ_STATUS_DPHY_ERRESC				0x40
+#define CSI2RX_IRQ_STATUS_DPHY_ERRSYNCESC			0x80
+#define CSI2RX_IRQ_STATUS_DPHY_ERRCTRL				0x100
+
+#define CSI2RX_IRQ_MASK								(CSI2RX_BASE_OFFSET + 0x10)
+#define CSI2RX_IRQ_MASK_CRC_ERROR					0x1
+#define CSI2RX_IRQ_MASK_1BIT_CRC_ERROR				0x2
+#define CSI2RX_IRQ_MASK_2BIT_CRC_ERROR				0x4
+#define CSI2RX_IRQ_MASK_ULPS_CHANGE					0x8
+#define CSI2RX_IRQ_MASK_DPHY_ERRSOTHS				0x10
+#define CSI2RX_IRQ_MASK_DPHY_ERRSOTSYNC_HS			0x20
+#define CSI2RX_IRQ_MASK_DPHY_ERRESC					0x40
+#define CSI2RX_IRQ_MASK_DPHY_ERRSYNCESC				0x80
+#define CSI2RX_IRQ_MASK_DPHY_ERRCTRL				0x100
+
+#define CSI2RX_ULPS_STATUS							(CSI2RX_BASE_OFFSET + 0x14)
+#define CSI2RX_ULPS_STATUS_CLK_LANE_ULPS			0x1
+#define CSI2RX_ULPS_STATUS_DAT_LANE0_ULPS			0x2
+#define CSI2RX_ULPS_STATUS_DAT_LANE1_ULPS			0x4
+#define CSI2RX_ULPS_STATUS_DAT_LANE2_ULPS			0x8
+#define CSI2RX_ULPS_STATUS_DAT_LANE3_ULPS			0x10
+#define CSI2RX_ULPS_STATUS_CLK_LANE_MARK			0x20
+#define CSI2RX_ULPS_STATUS_DAT_LANE0_MARK			0x40
+#define CSI2RX_ULPS_STATUS_DAT_LANE1_MARK			0x80
+#define CSI2RX_ULPS_STATUS_DAT_LANE2_MARK			0x100
+#define CSI2RX_ULPS_STATUS_DAT_LANE3_MARK			0x200
+
+#define CSI2RX_PPI_ERRSOT_HS						(CSI2RX_BASE_OFFSET + 0x18)
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE0				0x1
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE1				0x2
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE2				0x4
+#define CSI2RX_PPI_ERRSOT_HS_DAT_LANE3				0x8
+
+#define CSI2RX_PPI_ERRSOTSYNC_HS					(CSI2RX_BASE_OFFSET + 0x1C)
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE0			0x1
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE1			0x2
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE2			0x4
+#define CSI2RX_PPI_ERRSOTSYNC_HS_DAT_LANE3			0x8
+
+#define CSI2RX_PPI_ERRESC				   		 	(CSI2RX_BASE_OFFSET + 0x20)
+#define CSI2RX_PPI_ERRESC_DAT_LANE0		   		 	0x1
+#define CSI2RX_PPI_ERRESC_DAT_LANE1		   		 	0x2
+#define CSI2RX_PPI_ERRESC_DAT_LANE2		   		 	0x4
+#define CSI2RX_PPI_ERRESC_DAT_LANE3		   		 	0x8
+
+#define CSI2RX_PPI_ERRSYNCESC			   		 	(CSI2RX_BASE_OFFSET + 0x24)
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE0	   		 	0x1
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE1	   		 	0x2
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE2	   		 	0x4
+#define CSI2RX_PPI_ERRSYNCESC_DAT_LANE3	   		 	0x8
+
+#define CSI2RX_PPI_ERRCONTROL			   		 	(CSI2RX_BASE_OFFSET + 0x28)
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE0	   		 	0x1
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE1	   		 	0x2
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE2	   		 	0x4
+#define CSI2RX_PPI_ERRCONTROL_DAT_LANE3	   		 	0x8
+
+#define CSI2RX_CFG_DISABLE_PAYLOAD_0							(CSI2RX_BASE_OFFSET + 0x2C)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_LEGACY_YUV420_8BIT		(1 << 10)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_YUV422_8BIT				(1 << 14)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_YUV422_10BIT			(1 << 15)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB444					(1 << 16)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB555					(1 << 17)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB565					(1 << 18)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB666					(1 << 19)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RGB888					(1 << 20)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW6					(1 << 24)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW7					(1 << 25)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW8					(1 << 26)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW10					(1 << 27)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW12					(1 << 28)
+#define CSI2RX_CFG_DISABLE_PAYLOAD_TYPE_RAW14					(1 << 29)
+
+#define CSI2RX_CFG_DISABLE_PAYLOAD_1	(CSI2RX_BASE_OFFSET + 0x30)
+
+struct mxc_mipi_csi2_dev {
+	struct v4l2_device		*v4l2_dev;
+	struct v4l2_subdev		sd;
+	struct v4l2_subdev		*sensor_sd;
+
+	struct media_pad pads[MXC_MIPI_CSI2_VCX_PADS_NUM];
+	struct v4l2_mbus_framefmt format;
+
+	void __iomem *csr_regs;
+	void __iomem *base_regs;
+	struct platform_device *pdev;
+	u32 flags;
+	int irq;
+
+	struct clk *clk_apb;
+	struct clk *clk_core;
+	struct clk *clk_esc;
+	struct clk *clk_pxl;
+
+	int	 id;
+	u32 hs_settle;
+	u32 num_lanes;
+	u8 data_lanes[4];
+	u8 vchannel;
+	u8 running;
+};
+
+#endif
-- 
1.7.9.5


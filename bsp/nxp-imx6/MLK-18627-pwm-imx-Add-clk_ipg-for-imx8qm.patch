From 4568c8180a78b313828d4792503e346cd8944518 Mon Sep 17 00:00:00 2001
From: Leonard Crestez <leonard.crestez@nxp.com>
Date: Mon, 18 Jun 2018 19:26:16 +0300
Subject: [PATCH 3987/5242] MLK-18627 pwm: imx: Add clk_ipg for imx8qm

commit  8a81676ae085e521a256725f8ab98d2d075ea87d from
https://source.codeaurora.org/external/imx/linux-imx.git

As part of converting the imx pwm driver to an atomic apply function the
code handling ipg clock was dropped. Add it back because on imx8qm it is
indeed required.

This fixes the same issue as imx_4.9.y commit
ce627dbfd76e ("MLK-16973-4 pwm: imx: Use ipg and per clks in ->config, ->enable and ->disable")

Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
Reported-by: Marius Vlad <marius-cristian.vlad@nxp.com>
Tested-by: Marius Vlad <marius-cristian.vlad@nxp.com>
Reviewed-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pwm/pwm-imx.c |   38 ++++++++++++++++++++++++++++++++++++--
 1 file changed, 36 insertions(+), 2 deletions(-)

diff --git a/drivers/pwm/pwm-imx.c b/drivers/pwm/pwm-imx.c
index 08cbe81..147df09 100644
--- a/drivers/pwm/pwm-imx.c
+++ b/drivers/pwm/pwm-imx.c
@@ -51,6 +51,7 @@
 
 struct imx_chip {
 	struct clk	*clk_per;
+	struct clk	*clk_ipg;
 
 	void __iomem	*mmio_base;
 
@@ -59,6 +60,32 @@ struct imx_chip {
 
 #define to_imx_chip(chip)	container_of(chip, struct imx_chip, chip)
 
+static int imx_pwm_clk_prepare_enable(struct pwm_chip *chip)
+{
+	struct imx_chip *imx = to_imx_chip(chip);
+	int ret;
+
+	ret = clk_prepare_enable(imx->clk_per);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(imx->clk_ipg);
+	if (ret) {
+		clk_disable_unprepare(imx->clk_per);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void imx_pwm_clk_disable_unprepare(struct pwm_chip *chip)
+{
+	struct imx_chip *imx = to_imx_chip(chip);
+
+	clk_disable_unprepare(imx->clk_ipg);
+	clk_disable_unprepare(imx->clk_per);
+}
+
 static int imx_pwm_config_v1(struct pwm_chip *chip,
 		struct pwm_device *pwm, int duty_ns, int period_ns)
 {
@@ -200,7 +227,7 @@ static int imx_pwm_apply_v2(struct pwm_chip *chip, struct pwm_device *pwm,
 		if (cstate.enabled) {
 			imx_pwm_wait_fifo_slot(chip, pwm);
 		} else {
-			ret = clk_prepare_enable(imx->clk_per);
+			ret = imx_pwm_clk_prepare_enable(chip);
 			if (ret)
 				return ret;
 
@@ -222,7 +249,7 @@ static int imx_pwm_apply_v2(struct pwm_chip *chip, struct pwm_device *pwm,
 	} else if (cstate.enabled) {
 		writel(0, imx->mmio_base + MX3_PWMCR);
 
-		clk_disable_unprepare(imx->clk_per);
+		imx_pwm_clk_disable_unprepare(chip);
 	}
 
 	return 0;
@@ -286,6 +313,13 @@ static int imx_pwm_probe(struct platform_device *pdev)
 		return PTR_ERR(imx->clk_per);
 	}
 
+	imx->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
+	if (IS_ERR(imx->clk_ipg)) {
+		dev_err(&pdev->dev, "getting ipg clock failed with %ld\n",
+				PTR_ERR(imx->clk_ipg));
+		return PTR_ERR(imx->clk_ipg);
+	}
+
 	imx->chip.ops = data->ops;
 	imx->chip.dev = &pdev->dev;
 	imx->chip.base = -1;
-- 
1.7.9.5


From 0d620c7ace7e986422f7a2b098d781bee1c03ced Mon Sep 17 00:00:00 2001
From: Dong AiSheng <aisheng.dong@nxp.com>
Date: Tue, 28 Aug 2018 14:53:15 +0800
Subject: [PATCH 4629/5242] MLK-19351-2 can: flexcan: add can fd bitrate
 switch support

commit  076fdfbdf42e0198f20227b62d2c793db9693ead from
https://source.codeaurora.org/external/imx/linux-imx.git

Add can fd bitrate switch support

Signed-off-by: Joakim Zhang <qiangqing.zhang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/can/flexcan.c |   17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 06fffd2..1460491 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -201,6 +201,8 @@
 #define FLEXCAN_MB_CNT_LENGTH(x)	(((x) & 0xf) << 16)
 #define FLEXCAN_MB_CNT_TIMESTAMP(x)	((x) & 0xffff)
 
+#define FLEXCAN_FDCTRL_FDRATE		BIT(31)
+
 #define FLEXCAN_TIMEOUT_US		(50)
 
 /* FLEXCAN hardware feature flags
@@ -710,7 +712,7 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	const struct flexcan_priv *priv = netdev_priv(dev);
 	struct flexcan_regs __iomem *regs = priv->regs;
 	struct canfd_frame *cf = (struct canfd_frame *)skb->data;
-	u32 can_id;
+	u32 can_id, reg_fdctrl;
 	u32 data;
 	u32 ctrl = FLEXCAN_MB_CODE_TX_DATA | (can_len2dlc(cf->len) << 16);
 	u32 i;
@@ -737,8 +739,16 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	can_put_echo_skb(skb, dev, 0);
 
-	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD) {
+		reg_fdctrl = priv->read(&regs->fdctrl) &
+						~FLEXCAN_FDCTRL_FDRATE;
+		if (cf->flags & CANFD_BRS) {
+			reg_fdctrl |= FLEXCAN_FDCTRL_FDRATE;
+			ctrl |= FLEXCAN_MB_CNT_BRS;
+		}
+		priv->write(reg_fdctrl, &regs->fdctrl);
 		ctrl |= FLEXCAN_MB_CNT_EDL;
+	}
 
 	priv->mb_write(priv, priv->tx_mb_idx, FLEXCAN_MB_ID, can_id);
 	priv->mb_write(priv, priv->tx_mb_idx, FLEXCAN_MB_CTRL, ctrl);
@@ -919,6 +929,9 @@ static unsigned int flexcan_mailbox_read(struct can_rx_offload *offload,
 	if (!(reg_ctrl & FLEXCAN_MB_CNT_EDL) && reg_ctrl & FLEXCAN_MB_CNT_RTR) {
 		cf->can_id |= CAN_RTR_FLAG;
 	} else {
+		if (reg_ctrl & FLEXCAN_MB_CNT_BRS)
+			cf->flags |= CANFD_BRS;
+
 		for (i = 0; i < cf->len; i += 4)
 			*(__be32 *)(cf->data + i) = cpu_to_be32(priv->mb_read(priv,
 							n, FLEXCAN_MB_DATA(i / 4)));
-- 
1.7.9.5


From d03e9fa7ba271562f57930bf4183373168052253 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@freescale.com>
Date: Tue, 1 Aug 2017 16:10:38 +0800
Subject: [PATCH 2281/5242] MLK-16130-1: ASoC: fsl_sai: enable TCE/RCE
 according to input channels

commit  bde2b1ffa5a11cc4eb07745861a6467765d72b6b from
https://source.codeaurora.org/external/imx/linux-imx.git

If there is only two channels input and slots is 2, then enable one
port is enough for data transfer. so enable the TCE/RCE according to
the input channels and slots configuration.

Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/fsl/fsl_sai.c |   19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 048bd5d..24ebcb8 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -485,11 +485,14 @@ static int fsl_sai_hw_params(struct snd_pcm_substream *substream,
 	u32 val_cr4 = 0, val_cr5 = 0;
 	u32 slots = (channels == 1) ? 2 : channels;
 	u32 slot_width = word_width;
+	u32 pins;
 	int ret;
 
 	if (sai->slots)
 		slots = sai->slots;
 
+	pins = DIV_ROUND_UP(channels, slots);
+
 	if (sai->slot_width)
 		slot_width = sai->slot_width;
 
@@ -556,6 +559,10 @@ static int fsl_sai_hw_params(struct snd_pcm_substream *substream,
 				FSL_SAI_CR4_FCOMB_MASK, FSL_SAI_CR4_FCOMB_SOFT);
 	}
 
+	regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx, offset),
+			   FSL_SAI_CR3_TRCE_MASK,
+			   FSL_SAI_CR3_TRCE((sai->dataline[tx] & ((1 << pins) - 1))));
+
 	regmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, offset),
 			   FSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,
 			   val_cr4);
@@ -571,8 +578,12 @@ static int fsl_sai_hw_free(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *cpu_dai)
 {
 	struct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned char offset = sai->soc->reg_offset;
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
+	regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx, offset),
+				   FSL_SAI_CR3_TRCE_MASK, 0);
+
 	if (!sai->slave_mode[tx] &&
 			sai->mclk_streams & BIT(substream->stream)) {
 		clk_disable_unprepare(sai->mclk_clk[sai->mclk_id[tx]]);
@@ -692,7 +703,6 @@ static int fsl_sai_startup(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *cpu_dai)
 {
 	struct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);
-	unsigned char offset = sai->soc->reg_offset;
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 	struct device *dev = &sai->pdev->dev;
 	int ret;
@@ -708,10 +718,6 @@ static int fsl_sai_startup(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
-	regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx, offset),
-			   FSL_SAI_CR3_TRCE_MASK,
-			   FSL_SAI_CR3_TRCE(sai->dataline[tx]));
-
 	/* EDMA engine needs periods of size multiple of tx/rx maxburst */
 	if (sai->soc->constrain_period_size)
 		snd_pcm_hw_constraint_step(substream->runtime, 0,
@@ -729,12 +735,9 @@ static void fsl_sai_shutdown(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *cpu_dai)
 {
 	struct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);
-	unsigned char offset = sai->soc->reg_offset;
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
 	if (sai->is_stream_opened[tx]) {
-		regmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx, offset),
-				   FSL_SAI_CR3_TRCE_MASK, 0);
 		clk_disable_unprepare(sai->bus_clk);
 		sai->is_stream_opened[tx] = false;
 	}
-- 
1.7.9.5


From 285889e0f4cad290dd8d7349e93c5942798da8ac Mon Sep 17 00:00:00 2001
From: Bai Ping <ping.bai@nxp.com>
Date: Fri, 14 Oct 2016 12:49:08 +0800
Subject: [PATCH 1222/5242] MLK-13344-04 ARM: imx: Add busfreq support on
 imx6sll

commit  53ee89a2d05258785033b97cc4c177c1366b0a15 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add bufreq driver support on i.MX6SLL. For i.MX6SLL,
it only support LPDDR2 and LPDDR3. the DDR clock change
flow is same on these two type of DDR.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/Makefile              |    4 +-
 arch/arm/mach-imx/busfreq-imx.c         |   38 +--
 arch/arm/mach-imx/busfreq_lpddr2.c      |    7 +-
 arch/arm/mach-imx/common.c              |    6 +-
 arch/arm/mach-imx/lpddr2_freq_imx6sll.S |  441 +++++++++++++++++++++++++++++++
 5 files changed, 476 insertions(+), 20 deletions(-)
 create mode 100644 arch/arm/mach-imx/lpddr2_freq_imx6sll.S

diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index 30f2b80..6ad6e9c 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -36,7 +36,6 @@ AFLAGS_imx6ull_low_power_idle.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6ULL) += imx6ull_low_power_idle.o
 AFLAGS_imx7d_low_power_idle.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX7D) += cpuidle-imx7d.o imx7d_low_power_idle.o
-obj-$(CONFIG_SOC_IMX6SLL) += mach-imx6sl.o
 endif
 
 ifdef CONFIG_SND_IMX_SOC
@@ -96,7 +95,8 @@ obj-$(CONFIG_SOC_IMX6Q) += mach-imx6q.o ddr3_freq_imx6.o smp_wfe_imx6.o \
 			   lpddr2_freq_imx6q.o
 AFLAGS_lpddr2_freq_imx6.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6SL) += mach-imx6sl.o lpddr2_freq_imx6.o
-obj-$(CONFIG_SOC_IMX6SLL) += mach-imx6sl.o
+AFLAGS_lpddr2_freq_imx6sll.o :=-Wa,-march=armv7-a
+obj-$(CONFIG_SOC_IMX6SLL) += mach-imx6sl.o lpddr2_freq_imx6sll.o
 AFLAGS_lpddr2_freq_imx6sx.o :=-Wa,-march=armv7-a
 AFLAGS_ddr3_freq_imx6sx.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6SX) += mach-imx6sx.o ddr3_freq_imx6sx.o \
diff --git a/arch/arm/mach-imx/busfreq-imx.c b/arch/arm/mach-imx/busfreq-imx.c
index 5e9ce18..71ee54f 100644
--- a/arch/arm/mach-imx/busfreq-imx.c
+++ b/arch/arm/mach-imx/busfreq-imx.c
@@ -205,7 +205,8 @@ static void enter_lpm_imx6_up(void)
 		clk_prepare_enable(pll2_400_clk);
 		if (ddr_type == IMX_DDR_TYPE_DDR3)
 			update_ddr_freq_imx6_up(LOW_AUDIO_CLK);
-		else if (ddr_type == IMX_DDR_TYPE_LPDDR2)
+		else if (ddr_type == IMX_DDR_TYPE_LPDDR2 ||
+			 ddr_type == IMX_MMDC_DDR_TYPE_LPDDR3)
 			update_lpddr2_freq(HIGH_AUDIO_CLK);
 		clk_set_parent(periph2_clk2_sel_clk, pll3_clk);
 		clk_set_parent(periph2_pre_clk, pll2_400_clk);
@@ -222,11 +223,12 @@ static void enter_lpm_imx6_up(void)
 		if (high_bus_freq_mode) {
 			if (ddr_type == IMX_DDR_TYPE_DDR3)
 				clk_set_rate(mmdc_clk, LOW_AUDIO_CLK);
-			else if (ddr_type == IMX_DDR_TYPE_LPDDR2)
+			else if (ddr_type == IMX_DDR_TYPE_LPDDR2 ||
+				 ddr_type == IMX_MMDC_DDR_TYPE_LPDDR3)
 				clk_set_rate(mmdc_clk, HIGH_AUDIO_CLK);
 		}
 
-		if (cpu_is_imx6ull() && low_bus_freq_mode)
+		if ((cpu_is_imx6ull() || cpu_is_imx6sll()) && low_bus_freq_mode)
 			imx6ull_lower_cpu_rate(false);
 
 		audio_bus_freq_mode = 1;
@@ -235,7 +237,8 @@ static void enter_lpm_imx6_up(void)
 	} else {
 		if (ddr_type == IMX_DDR_TYPE_DDR3)
 			update_ddr_freq_imx6_up(LPAPM_CLK);
-		else if (ddr_type == IMX_DDR_TYPE_LPDDR2)
+		else if (ddr_type == IMX_DDR_TYPE_LPDDR2 ||
+			 ddr_type == IMX_MMDC_DDR_TYPE_LPDDR3)
 			update_lpddr2_freq(LPAPM_CLK);
 		clk_set_parent(periph2_clk2_sel_clk, osc_clk);
 		clk_set_parent(periph2_clk, periph2_clk2_clk);
@@ -243,7 +246,7 @@ static void enter_lpm_imx6_up(void)
 		if (audio_bus_freq_mode)
 			clk_disable_unprepare(pll2_400_clk);
 
-		if (cpu_is_imx6ull())
+		if (cpu_is_imx6ull() || cpu_is_imx6sll())
 			imx6ull_lower_cpu_rate(true);
 
 		low_bus_freq_mode = 1;
@@ -294,7 +297,7 @@ static void enter_lpm_imx6_smp(void)
 
 static void exit_lpm_imx6_up(void)
 {
-	if (cpu_is_imx6ull() && low_bus_freq_mode)
+	if ((cpu_is_imx6ull() || cpu_is_imx6sll()) && low_bus_freq_mode)
 		imx6ull_lower_cpu_rate(false);
 
 	clk_prepare_enable(pll2_400_clk);
@@ -303,14 +306,14 @@ static void exit_lpm_imx6_up(void)
 	 * lower ahb/ocram's freq first to avoid too high
 	 * freq during parent switch from OSC to pll3.
 	 */
-	if (cpu_is_imx6ul() || cpu_is_imx6ull())
+	if (cpu_is_imx6ul() || cpu_is_imx6ull() || cpu_is_imx6sll())
 		clk_set_rate(ahb_clk, LPAPM_CLK / 4);
 	else
 		clk_set_rate(ahb_clk, LPAPM_CLK / 3);
 
 	clk_set_rate(ocram_clk, LPAPM_CLK / 2);
 	/* set periph clk to from pll2_bus on i.MX6UL */
-	if (cpu_is_imx6ul() || cpu_is_imx6ull())
+	if (cpu_is_imx6ul() || cpu_is_imx6ull() || cpu_is_imx6sll())
 		clk_set_parent(periph_pre_clk, pll2_bus_clk);
 	/* set periph clk to from pll2_400 */
 	else
@@ -321,7 +324,7 @@ static void exit_lpm_imx6_up(void)
 
 	if (ddr_type == IMX_DDR_TYPE_DDR3)
 		update_ddr_freq_imx6_up(ddr_normal_rate);
-	else if (ddr_type == IMX_DDR_TYPE_LPDDR2)
+	else if (ddr_type == IMX_DDR_TYPE_LPDDR2 || ddr_type == IMX_MMDC_DDR_TYPE_LPDDR3)
 		update_lpddr2_freq(ddr_normal_rate);
 	/* correct parent info after ddr freq change in asm code */
 	clk_set_parent(periph2_pre_clk, pll2_400_clk);
@@ -605,7 +608,7 @@ static void reduce_bus_freq(void)
 
 	if (cpu_is_imx7d())
 		enter_lpm_imx7d();
-	else if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull())
+	else if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull() || cpu_is_imx6sll())
 		enter_lpm_imx6_up();
 	else if (cpu_is_imx6q() || cpu_is_imx6dl())
 		enter_lpm_imx6_smp();
@@ -698,7 +701,7 @@ static int set_high_bus_freq(int high_bus_freq)
 
 	if (cpu_is_imx7d())
 		exit_lpm_imx7d();
-	else if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull())
+	else if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull() || cpu_is_imx6sll())
 		exit_lpm_imx6_up();
 	else if (cpu_is_imx6q() || cpu_is_imx6dl())
 		exit_lpm_imx6_smp();
@@ -1057,7 +1060,8 @@ static int busfreq_probe(struct platform_device *pdev)
 		}
 	}
 
-	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6sl() || cpu_is_imx6ull()) {
+	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6sl() || cpu_is_imx6ull() ||
+	    cpu_is_imx6sll()) {
 		ahb_clk = devm_clk_get(&pdev->dev, "ahb");
 		ocram_clk = devm_clk_get(&pdev->dev, "ocram");
 		periph2_clk = devm_clk_get(&pdev->dev, "periph2");
@@ -1075,7 +1079,7 @@ static int busfreq_probe(struct platform_device *pdev)
 		}
 	}
 
-	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull()) {
+	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull() || cpu_is_imx6sll()) {
 		mmdc_clk = devm_clk_get(&pdev->dev, "mmdc");
 		if (IS_ERR(mmdc_clk)) {
 			dev_err(busfreq_dev,
@@ -1104,7 +1108,7 @@ static int busfreq_probe(struct platform_device *pdev)
 		}
 	}
 
-	if (cpu_is_imx6ull() || cpu_is_imx6sl()) {
+	if (cpu_is_imx6ull() || cpu_is_imx6sl() || cpu_is_imx6sll()) {
 		arm_clk = devm_clk_get(&pdev->dev, "arm");
 		step_clk = devm_clk_get(&pdev->dev, "step");
 		pll1_clk = devm_clk_get(&pdev->dev, "pll1");
@@ -1201,11 +1205,13 @@ static int busfreq_probe(struct platform_device *pdev)
 
 	if (cpu_is_imx7d())
 		err = init_ddrc_ddr_settings(pdev);
-	else if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull()) {
+	else if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull() ||
+		cpu_is_imx6sll()) {
 		ddr_type = imx_mmdc_get_ddr_type();
 		if (ddr_type == IMX_DDR_TYPE_DDR3)
 			err = init_mmdc_ddr3_settings_imx6_up(pdev);
-		else if (ddr_type == IMX_DDR_TYPE_LPDDR2)
+		else if (ddr_type == IMX_DDR_TYPE_LPDDR2 ||
+			 ddr_type == IMX_MMDC_DDR_TYPE_LPDDR3)
 			err = init_mmdc_lpddr2_settings(pdev);
 	} else if (cpu_is_imx6q() || cpu_is_imx6dl()) {
 		ddr_type = imx_mmdc_get_ddr_type();
diff --git a/arch/arm/mach-imx/busfreq_lpddr2.c b/arch/arm/mach-imx/busfreq_lpddr2.c
index cd20893..5bc1807 100644
--- a/arch/arm/mach-imx/busfreq_lpddr2.c
+++ b/arch/arm/mach-imx/busfreq_lpddr2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -56,6 +56,7 @@
 extern unsigned int ddr_normal_rate;
 extern void mx6_lpddr2_freq_change(u32 freq, int bus_freq_mode);
 extern void imx6_up_lpddr2_freq_change(u32 freq, int bus_freq_mode);
+extern void imx6sll_lpddr2_freq_change(u32 freq, int bus_freq_mode);
 extern unsigned long save_ttbr1(void);
 extern void restore_ttbr1(unsigned long ttbr1);
 extern void mx6q_lpddr2_freq_change(u32 freq, void *ddr_settings);
@@ -163,6 +164,10 @@ int init_mmdc_lpddr2_settings(struct platform_device *busfreq_pdev)
 		mx6_change_lpddr2_freq = (void *)fncpy(
 			(void *)ddr_freq_change_iram_base,
 			&imx6_up_lpddr2_freq_change, ddr_code_size);
+	if (cpu_is_imx6sll())
+		mx6_change_lpddr2_freq = (void *)fncpy(
+			(void *)ddr_freq_change_iram_base,
+			&imx6sll_lpddr2_freq_change, ddr_code_size);
 
 	curr_ddr_rate = ddr_normal_rate;
 
diff --git a/arch/arm/mach-imx/common.c b/arch/arm/mach-imx/common.c
index 20454dd..cf57b55 100644
--- a/arch/arm/mach-imx/common.c
+++ b/arch/arm/mach-imx/common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -132,6 +132,10 @@ void __init imx6_enet_mac_init(const char *enet_compat, const char *ocotp_compat
 void mx6_lpddr2_freq_change(u32 freq, int bus_freq_mode) {}
 #endif
 
+#if !defined(CONFIG_SOC_IMX6SLL)
+void imx6sll_lpddr2_freq_change(u32 freq, int bus_freq_mode) {}
+#endif
+
 #if !defined(CONFIG_SOC_IMX6SX) && !defined(CONFIG_SOC_IMX6UL)
 u32 imx6_up_ddr3_freq_change_start, imx6_up_ddr3_freq_change_end;
 struct imx6_busfreq_info {
diff --git a/arch/arm/mach-imx/lpddr2_freq_imx6sll.S b/arch/arm/mach-imx/lpddr2_freq_imx6sll.S
new file mode 100644
index 0000000..3feb28a
--- /dev/null
+++ b/arch/arm/mach-imx/lpddr2_freq_imx6sll.S
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include "hardware.h"
+
+#define CCM_CBCDR	0x14
+#define CCM_CBCMR	0x18
+#define CCM_CSCMR1	0x1c
+#define CCM_CDHIPR	0x48
+
+#define L2_CACHE_SYNC	0x730
+
+#define MMDC0_MDPDC	0x4
+#define MMDC0_MAPSR	0x404
+#define MMDC0_MADPCR0	0x410
+
+	.macro	wait_for_ccm_handshake
+
+1:
+	ldr	r8, [r2, #CCM_CDHIPR]
+	cmp	r8, #0
+	bne	1b
+
+	.endm
+
+	.macro	switch_to_24MHz
+
+	/* periph2_clk2 sel to OSC_CLK */
+	ldr	r8, [r2, #CCM_CBCMR]
+	orr	r8, r8, #(1 << 20)
+	str	r8, [r2, #CCM_CBCMR]
+
+	/* periph2_clk2_podf to 0 */
+	ldr	r8, [r2, #CCM_CBCDR]
+	bic	r8, r8, #0x7
+	str	r8, [r2, #CCM_CBCDR]
+
+	/* periph2_clk sel to periph2_clk2 */
+	ldr	r8, [r2, #CCM_CBCDR]
+	orr	r8, r8, #(0x1 << 26)
+	str	r8, [r2, #CCM_CBCDR]
+
+	wait_for_ccm_handshake
+
+	/* fabric_mmdc_podf to 0 */
+	ldr	r8, [r2, #CCM_CBCDR]
+	bic	r8, r8, #(0x7 << 3)
+	str	r8, [r2, #CCM_CBCDR]
+
+	wait_for_ccm_handshake
+
+	.endm
+
+	.macro	switch_to_100MHz
+
+	/* check whether periph2_clk is from top path */
+	ldr	r8, [r2, #CCM_CBCDR]
+	ands	r8, #(1 << 26)
+	beq	skip_periph2_clk2_switch_100m
+
+	/* now switch periph2_clk back. */
+	ldr	r8, [r2, #CCM_CBCDR]
+	bic	r8, r8, #(1 << 26)
+	str	r8, [r2, #CCM_CBCDR]
+
+	wait_for_ccm_handshake
+
+	/*
+	 * on i.MX6SLL, pre_periph2_clk will be always from
+	 * pll2_pfd2, so no need to set pre_periph2_clk
+	 * parent, just set the mmdc divider directly.
+	 */
+skip_periph2_clk2_switch_100m:
+
+	/* fabric_mmdc_podf to 3 so that mmdc is 400 / 4 = 100MHz */
+	ldr	r8, [r2, #CCM_CBCDR]
+	bic	r8, r8, #(0x7 << 3)
+	orr	r8, r8, #(0x3 << 3)
+	str	r8, [r2, #CCM_CBCDR]
+
+	wait_for_ccm_handshake
+
+	.endm
+
+	.macro	switch_to_400MHz
+
+	/* check whether periph2_clk is from top path */
+	ldr	r8, [r2, #CCM_CBCDR]
+	ands	r8, #(1 << 26)
+	beq	skip_periph2_clk2_switch_400m
+
+	/* now switch periph2_clk back. */
+	ldr	r8, [r2, #CCM_CBCDR]
+	bic	r8, r8, #(1 << 26)
+	str	r8, [r2, #CCM_CBCDR]
+
+	wait_for_ccm_handshake
+
+	/*
+	 * on i.MX6SLL, pre_periph2_clk will be always from
+	 * pll2_pfd2, so no need to set pre_periph2_clk
+	 * parent, just set the mmdc divider directly.
+	 */
+skip_periph2_clk2_switch_400m:
+
+	/* fabric_mmdc_podf to 0 */
+	ldr	r8, [r2, #CCM_CBCDR]
+	bic	r8, r8, #(0x7 << 3)
+	str	r8, [r2, #CCM_CBCDR]
+
+	wait_for_ccm_handshake
+
+	.endm
+
+	.macro	mmdc_clk_lower_100MHz
+
+	/*
+	 * Prior to reducing the DDR frequency (at 528/400 MHz),
+	 * read the Measure unit count bits (MU_UNIT_DEL_NUM)
+	 */
+	ldr	r8, =0x8B8
+	ldr	r6, [r5, r8]
+	/* Original MU unit count */
+	mov	r6, r6, LSR #16
+	ldr	r4, =0x3FF
+	and	r6, r6, r4
+	/* Original MU unit count * 2 */
+	mov	r7, r6, LSL #1
+	/*
+	 * Bypass the automatic measure unit when below 100 MHz
+	 * by setting the Measure unit bypass enable bit (MU_BYP_EN)
+	 */
+	ldr	r6, [r5, r8]
+	orr	r6, r6, #0x400
+	str	r6, [r5, r8]
+	/*
+	 * Double the measure count value read in step 1 and program it in the
+	 * measurement bypass bits (MU_BYP_VAL) of the MMDC PHY Measure Unit
+	 * Register for the reduced frequency operation below 100 MHz
+	 */
+	ldr	r6, [r5, r8]
+	ldr	r4, =0x3FF
+	bic	r6, r6, r4
+	orr	r6, r6, r7
+	str	r6, [r5, r8]
+	/* Now perform a Force Measurement. */
+	ldr	r6, [r5, r8]
+	orr	r6, r6, #0x800
+	str	r6, [r5, r8]
+	/* Wait for FRC_MSR to clear. */
+force_measure:
+	ldr	r6, [r5, r8]
+	and	r6, r6, #0x800
+	cmp	r6, #0x0
+	bne	force_measure
+
+	/* For freq lower than 100MHz, need to set RALAT to 2 */
+	ldr	r6, [r5, #0x18]
+	bic	r6, r6, #(0x7 << 6)
+	orr	r6, r6, #(0x2 << 6)
+	str	r6, [r5, #0x18]
+
+	.endm
+
+	.macro	mmdc_clk_above_100MHz
+
+	/* Make sure that the PHY measurement unit is NOT in bypass mode */
+	ldr	r8, =0x8B8
+	ldr	r6, [r5, r8]
+	bic	r6, r6, #0x400
+	str	r6, [r5, r8]
+	/* Now perform a Force Measurement. */
+	ldr	r6, [r5, r8]
+	orr	r6, r6, #0x800
+	str	r6, [r5, r8]
+	/* Wait for FRC_MSR to clear. */
+force_measure1:
+	ldr	r6, [r5, r8]
+	and	r6, r6, #0x800
+	cmp	r6, #0x0
+	bne	force_measure1
+
+	/* For freq higher than 100MHz, need to set RALAT to 5 */
+	ldr	r6, [r5, #0x18]
+	bic	r6, r6, #(0x7 << 6)
+	orr	r6, r6, #(0x5 << 6)
+	str	r6, [r5, #0x18]
+
+	.endm
+
+	.align 3
+/*
+ * Below code can be used by i.MX6SLL when changing the
+ * frequency of MMDC. the MMDC is the same on these two SOCs.
+ */
+ENTRY(imx6sll_lpddr2_freq_change)
+	push	{r2 - r8}
+
+	/*
+	 * To ensure no page table walks occur in DDR, we
+	 * have a another page table stored in IRAM that only
+	 * contains entries pointing to IRAM, AIPS1 and AIPS2.
+	 * We need to set the TTBR1 to the new IRAM TLB.
+	 * Do the following steps:
+	 * 1. Flush the Branch Target Address Cache (BTAC)
+	 * 2. Set TTBR1 to point to IRAM page table.
+	 * 3. Disable page table walks in TTBR0 (PD0 = 1)
+	 * 4. Set TTBR0.N=1, implying 0-2G is translated by TTBR0
+	 *     and 2-4G is translated by TTBR1.
+	 */
+
+	ldr	r6, =iram_tlb_phys_addr
+	ldr	r7, [r6]
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	/* Disable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	dsb
+	isb
+	/* Store the IRAM table in TTBR1 */
+	mcr	p15, 0, r7, c2, c0, 1
+
+	/* Read TTBCR and set PD0=1, N = 1 */
+	mrc	p15, 0, r6, c2, c0, 2
+	orr	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	/* Disable L1 data cache. */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+
+	dsb
+	isb
+
+#ifdef CONFIG_CACHE_L2X0
+	/*
+	 * Need to make sure the buffers in L2 are drained.
+	 * Performing a sync operation does this.
+	 */
+	ldr	r7, =IMX_IO_P2V(MX6Q_L2_BASE_ADDR)
+	mov	r6, #0x0
+	str	r6, [r7, #L2_CACHE_SYNC]
+
+	/*
+	 * The second dsb might be needed to keep cache sync (device write)
+	 * ordering with the memory accesses before it.
+	 */
+	dsb
+	isb
+
+	/* Disable L2. */
+	str	r6, [r7, #0x100]
+#endif
+
+	ldr	r2, =IMX_IO_P2V(MX6Q_CCM_BASE_ADDR)
+	ldr	r3, =IMX_IO_P2V(MX6Q_ANATOP_BASE_ADDR)
+	ldr	r5, =IMX_IO_P2V(MX6Q_MMDC_P0_BASE_ADDR)
+
+	/* Disable Automatic power savings. */
+	ldr	r6, [r5, #MMDC0_MAPSR]
+	orr	r6, r6, #0x1
+	str	r6, [r5, #MMDC0_MAPSR]
+
+	/* Delay for a while */
+	ldr	r8, =10
+delay:
+	ldr	r7, =0
+cont:
+	ldr	r6, [r5, r7]
+	add	r7, r7, #4
+	cmp	r7, #16
+	bne	cont
+	sub	r8, r8, #1
+	cmp	r8, #0
+	bgt	delay
+
+	/* Make the DDR explicitly enter self-refresh. */
+	ldr	r6, [r5, #MMDC0_MAPSR]
+	orr	r6, r6, #0x200000
+	str	r6, [r5, #MMDC0_MAPSR]
+
+poll_dvfs_set_1:
+	ldr	r6, [r5, #MMDC0_MAPSR]
+	and	r6, r6, #0x2000000
+	cmp	r6, #0x2000000
+	bne	poll_dvfs_set_1
+
+	/* set SBS step-by-step mode */
+	ldr	r6, [r5, #MMDC0_MADPCR0]
+	orr	r6, r6, #0x100
+	str	r6, [r5, #MMDC0_MADPCR0]
+
+	ldr	r6, =100000000
+	cmp	r0, r6
+	bgt	set_ddr_mu_above_100
+	mmdc_clk_lower_100MHz
+
+set_ddr_mu_above_100:
+	ldr	r6, =24000000
+	cmp	r0, r6
+	beq	set_to_24MHz
+
+	ldr     r6, =100000000
+	cmp	r0, r6
+	beq	set_to_100MHz
+
+	switch_to_400MHz
+
+	mmdc_clk_above_100MHz
+
+	b	done
+
+set_to_24MHz:
+	switch_to_24MHz
+	b	done
+set_to_100MHz:
+	switch_to_100MHz
+done:
+	/* clear DVFS - exit from self refresh mode */
+	ldr	r6, [r5, #MMDC0_MAPSR]
+	bic	r6, r6, #0x200000
+	str	r6, [r5, #MMDC0_MAPSR]
+
+poll_dvfs_clear_1:
+	ldr	r6, [r5, #MMDC0_MAPSR]
+	and	r6, r6, #0x2000000
+	cmp	r6, #0x2000000
+	beq	poll_dvfs_clear_1
+
+	/* Enable Automatic power savings. */
+	ldr	r6, [r5, #MMDC0_MAPSR]
+	bic	r6, r6, #0x1
+	str	r6, [r5, #MMDC0_MAPSR]
+
+	/* clear SBS - unblock DDR accesses */
+	ldr	r6, [r5, #MMDC0_MADPCR0]
+	bic	r6, r6, #0x100
+	str	r6, [r5, #MMDC0_MADPCR0]
+
+	ldr	r6,  =0xa0000000
+	str	r6, [r5, #0x83c]
+
+
+#ifdef CONFIG_CACHE_L2X0
+	/* Enable L2. */
+	ldr	r7, =IMX_IO_P2V(MX6Q_L2_BASE_ADDR)
+	ldr	r6, =0x1
+	str	r6, [r7, #0x100]
+#endif
+
+	/* Enable L1 data cache. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Restore the TTBCR */
+	dsb
+	isb
+
+	/* Read TTBCR and set PD0=0, N = 0 */
+	mrc	p15, 0, r6, c2, c0, 2
+	bic	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	dsb
+	isb
+
+	/* Enable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* Restore registers */
+	pop	{r2 - r8}
+	mov	pc, lr
-- 
1.7.9.5


From d62a727a932ca8547dc0e96aac3378fa16b60305 Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Thu, 19 Jul 2018 17:58:07 +0800
Subject: [PATCH 4295/5242] MLK-18982 VPU: Add support for vp6, vp8, spk,
 divx, mjpeg

commit  0c32432d030c2fca919f7ddb71deed7e1fe60f3c from
https://source.codeaurora.org/external/imx/linux-imx.git

Add support for vp6, vp8, spk, divx, mjpeg by adding start code

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
(cherry picked from commit b943cabf2255d93c04cec9795a1b9bcbe2b656ec)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/insert_startcode.c |  280 +++++++++++++++++++++++++
 drivers/mxc/vpu-decoder-b0/vpu_b0.c           |   13 ++
 drivers/mxc/vpu-decoder-b0/vpu_b0.h           |    1 +
 3 files changed, 294 insertions(+)

diff --git a/drivers/mxc/vpu-decoder-b0/insert_startcode.c b/drivers/mxc/vpu-decoder-b0/insert_startcode.c
index a5f9b5b..761eac3 100644
--- a/drivers/mxc/vpu-decoder-b0/insert_startcode.c
+++ b/drivers/mxc/vpu-decoder-b0/insert_startcode.c
@@ -190,6 +190,221 @@ static int VC1CreateNalFrameHeader(unsigned char *pHeader, int *pHeaderLen, unsi
 	return 1;
 }
 
+void vp6_scd_sequence_header(unsigned char *buffer, int pic_width, int pic_height)
+{
+	int Length = 0;
+
+	buffer[0] = 0x00;
+	buffer[1] = 0x00;
+	buffer[2] = 0x01;
+	buffer[3] = 0x31;
+	buffer[4] = (Length+12)>>16;
+	buffer[5] = (Length+12)>>8;
+	buffer[6] = 0x4e;
+	buffer[7] = (Length+12);
+	buffer[8] = 0x36;
+	buffer[9] = 0x1;
+	buffer[10] = pic_width>>8;
+	buffer[11] = pic_width;
+	buffer[12] = 0x58;
+	buffer[13] = pic_height>>8;
+	buffer[14] = pic_height;
+	buffer[15] = 0x50;
+}
+
+void vp6_scd_frame_header(unsigned char *buffer, int pic_width, int pic_height, int Length)
+{
+	buffer[0] = 0x00;
+	buffer[1] = 0x00;
+	buffer[2] = 0x01;
+	buffer[3] = 0x32;
+	buffer[4] = (Length+12)>>16;
+	buffer[5] = (Length+12)>>8;
+	buffer[6] = 0x4e;
+	buffer[7] = (Length+12);
+	buffer[8] = 0x36;
+	buffer[9] = 0x1;
+	buffer[10] = pic_width>>8;
+	buffer[11] = pic_width;
+	buffer[12] = 0x58;
+	buffer[13] = pic_height>>8;
+	buffer[14] = pic_height;
+	buffer[15] = 0x50;
+}
+
+void vp8_ivf_sequence_header(unsigned char *buffer, int pic_width, int pic_height)
+{
+	int Length = 32;
+
+	buffer[0] = 0x44;
+	buffer[1] = 0x4b;
+	buffer[2] = 0x49;
+	buffer[3] = 0x46; //0-3byte signature "DKIF"
+	buffer[4] = 0x00;
+	buffer[5] = 0x00; //4-5byte version 0
+	buffer[6] = Length;
+	buffer[7] = Length >> 8; //length of Header
+	buffer[8] = 0x56;
+	buffer[9] = 0x50;
+	buffer[10] = 0x38;
+	buffer[11] = 0x30; //VP8 fourcc
+	buffer[12] = pic_width;
+	buffer[13] = pic_width >> 8;
+	buffer[14] = pic_height;
+	buffer[15] = pic_height >> 8;
+	buffer[16] = 0xe8;
+	buffer[17] = 0x03;
+	buffer[18] = 0x00;
+	buffer[19] = 0x00; //16-19 frame rate
+	buffer[20] = 0x01;
+	buffer[21] = 0x00;
+	buffer[22] = 0x00;
+	buffer[23] = 0x00; //20-23 time scale
+	buffer[24] = 0xdf;
+	buffer[25] = 0xf9;
+	buffer[26] = 0x09;
+	buffer[27] = 0x00; //24-27 number frames
+	//28-31 unused
+}
+
+void vp8_ivf_frame_header(unsigned char *buffer, u_int32 FrameSize)
+{
+	buffer[0] = FrameSize;
+	buffer[1] = FrameSize >> 8;
+	buffer[2] = FrameSize >> 16;
+	buffer[3] = FrameSize >> 24;
+	//4-11 timestamp
+}
+
+void vp8_scd_sequence_header(unsigned char *buffer, int pic_width, int pic_height)
+{
+	int Length = 32;
+
+	buffer[0] = 0x00;
+	buffer[1] = 0x00;
+	buffer[2] = 0x01;
+	buffer[3] = 0x31;
+	buffer[4] = (Length+12)>>16;
+	buffer[5] = (Length+12)>>8;
+	buffer[6] = 0x4e;
+	buffer[7] = (Length+12);
+	buffer[8] = 0x36;
+	buffer[9] = 0x1;
+	buffer[10] = pic_width>>8;
+	buffer[11] = pic_width;
+	buffer[12] = 0x58;
+	buffer[13] = pic_height>>8;
+	buffer[14] = pic_height;
+	buffer[15] = 0x50;
+}
+void vp8_scd_frame_header(unsigned char *buffer, int pic_width, int pic_height, int Length)
+{
+	buffer[0] = 0x00;
+	buffer[1] = 0x00;
+	buffer[2] = 0x01;
+	buffer[3] = 0x32;
+	buffer[4] = (Length+12)>>16;
+	buffer[5] = (Length+12)>>8;
+	buffer[6] = 0x4e;
+	buffer[7] = (Length+12);
+	buffer[8] = 0x36;
+	buffer[9] = 0x1;
+	buffer[10] = pic_width>>8;
+	buffer[11] = pic_width;
+	buffer[12] = 0x58;
+	buffer[13] = pic_height>>8;
+	buffer[14] = pic_height;
+	buffer[15] = 0x50;
+}
+
+static void insert_payload_header_divx(u_int8 *dst, u_int32 uPayloadSize, u_int32 uWidth, u_int32 uHeight)
+{
+	// Startcode
+	dst[0] = 0x00;
+	dst[1] = 0x00;
+	dst[2] = 0x01;
+	dst[3] = 0x32;
+
+	// Length
+	dst[4] = ((uPayloadSize>>16)&0xff);
+	dst[5] = ((uPayloadSize>>8)&0xff);
+	dst[6] = 0x4e;
+	dst[7] = ((uPayloadSize>>0)&0xff);
+
+	// Codec ID and Version
+	dst[8] = 0x38;
+	dst[9] = 0x01;
+
+	// Width
+	dst[10] = ((uWidth>>8)&0xff);
+	dst[11] = ((uWidth>>0)&0xff);
+	dst[12] = 0x58;
+
+	// Height
+	dst[13] = ((uHeight>>8)&0xff);
+	dst[14] = ((uHeight>>0)&0xff);
+	dst[15] = 0x50;
+}
+
+static void insert_seq_header_spk(u_int8 *dst, u_int32 uPayloadSize, u_int32 uWidth, u_int32 uHeight)
+{
+	// Startcode
+	dst[0] = 0x00;
+	dst[1] = 0x00;
+	dst[2] = 0x01;
+	dst[3] = 0x31;
+
+	// Length
+	dst[4] = ((uPayloadSize>>16)&0xff);
+	dst[5] = ((uPayloadSize>>8)&0xff);
+	dst[6] = 0x4e;
+	dst[7] = ((uPayloadSize>>0)&0xff);
+
+	// Codec ID and Version
+	dst[8] = 0x39;
+	dst[9] = 0x01;
+
+	// Width
+	dst[10] = ((uWidth>>8)&0xff);
+	dst[11] = ((uWidth>>0)&0xff);
+	dst[12] = 0x58;
+
+	// Height
+	dst[13] = ((uHeight>>8)&0xff);
+	dst[14] = ((uHeight>>0)&0xff);
+	dst[15] = 0x50;
+}
+
+static void insert_frame_header_spk(u_int8 *dst, u_int32 uPayloadSize, u_int32 uWidth, u_int32 uHeight)
+{
+	uPayloadSize = 0;
+	// Startcode
+	dst[0] = 0x00;
+	dst[1] = 0x00;
+	dst[2] = 0x01;
+	dst[3] = 0x32;
+
+	// Length
+	dst[4] = ((uPayloadSize>>16)&0xff);
+	dst[5] = ((uPayloadSize>>8)&0xff);
+	dst[6] = 0x4e;
+	dst[7] = ((uPayloadSize>>0)&0xff);
+
+	// Codec ID and Version
+	dst[8] = 0x39;
+	dst[9] = 0x01;
+
+	// Width
+	dst[10] = ((uWidth>>8)&0xff);
+	dst[11] = ((uWidth>>0)&0xff);
+	dst[12] = 0x58;
+
+	// Height
+	dst[13] = ((uHeight>>8)&0xff);
+	dst[14] = ((uHeight>>0)&0xff);
+	dst[15] = 0x50;
+}
+
 u_int32 insert_scode_4_seq(struct vpu_ctx *ctx, u_int8 *src, u_int8 *dst, u_int32 vdec_std, u_int32 uPayloadSize)
 {
 	struct queue_data *q_data = &ctx->q_data[V4L2_SRC];
@@ -223,6 +438,44 @@ u_int32 insert_scode_4_seq(struct vpu_ctx *ctx, u_int8 *src, u_int8 *dst, u_int3
 			length += HeaderLen;
 		}
 	}
+
+	break;
+	case VPU_VIDEO_VP6: {
+		vp6_scd_sequence_header(dst, q_data->width, q_data->height);
+		length = 16;
+	}
+	break;
+	case VPU_VIDEO_VP8: {
+		u_int8 seq_header[32] = {0};
+		u_int8 frame_header[8] = {0};
+
+		vp8_scd_sequence_header(dst, q_data->width, q_data->height);
+		length = 16;
+		vp8_ivf_sequence_header(seq_header, q_data->width, q_data->height);
+		memcpy(dst+length, seq_header, 32);
+		length += 32;
+		vp8_scd_frame_header(dst + length, q_data->width, q_data->height, uPayloadSize);
+		length += 16;
+		vp8_ivf_frame_header(frame_header, uPayloadSize);
+		memcpy(dst+length, frame_header, 8);
+		length += 8;
+		memcpy(dst+length, src, uPayloadSize);
+		length += uPayloadSize;
+	}
+	break;
+	case VPU_VIDEO_ASP: {
+		if (q_data->fourcc == VPU_PIX_FMT_DIVX) {
+			insert_payload_header_divx(dst, uPayloadSize, q_data->width, q_data->height);
+			length = 16;
+			memcpy(dst+length, src, uPayloadSize);
+			length += uPayloadSize;
+		}
+	}
+	break;
+	case VPU_VIDEO_SPK: {
+		insert_seq_header_spk(dst, uPayloadSize, q_data->width, q_data->height);
+		length = 16;
+	}
 	break;
 	default:
 	break;
@@ -257,6 +510,33 @@ u_int32 insert_scode_4_pic(struct vpu_ctx *ctx, u_int8 *dst, u_int8 *src, u_int3
 		}
 	}
 	break;
+	case VPU_VIDEO_VP6: {
+		vp6_scd_frame_header(dst, q_data->width, q_data->height, uPayloadSize);
+		length = 16;
+	}
+	break;
+	case VPU_VIDEO_VP8: {
+		u_int8 frame_header[8];
+
+		vp8_scd_frame_header(dst, q_data->width, q_data->height, uPayloadSize);
+		length = 16;
+		vp8_ivf_frame_header(frame_header, uPayloadSize);
+		memcpy(dst+length, frame_header, 8);
+		length += 8;
+	}
+	break;
+	case VPU_VIDEO_ASP: {
+		if (q_data->fourcc == VPU_PIX_FMT_DIVX) {
+			insert_payload_header_divx(dst, uPayloadSize, q_data->width, q_data->height);
+			length = 16;
+		}
+	}
+	break;
+	case VPU_VIDEO_SPK: {
+		insert_frame_header_spk(dst, uPayloadSize, q_data->width, q_data->height);
+		length = 16;
+	}
+	break;
 	default:
 	break;
 	}
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index 50fff8d..dbb91df 100755
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -266,6 +266,12 @@ static void vpu_log_shared_mem(struct vpu_ctx *ctx)
 		.vdec_std   = VPU_VIDEO_ASP,
 	},
 	{
+		.name       = "DIVX Encoded Stream",
+		.fourcc     = VPU_PIX_FMT_DIVX,
+		.num_planes = 1,
+		.vdec_std   = VPU_VIDEO_ASP,
+	},
+	{
 		.name       = "JPEG stills",
 		.fourcc     = V4L2_PIX_FMT_JPEG,
 		.num_planes = 1,
@@ -1271,6 +1277,13 @@ static void transfer_buffer_to_firmware(struct vpu_ctx *ctx, void *input_buffer,
 	pUdataBuf->uUDataBase = ctx->udata_buffer_phy - ctx->dev->cm_offset;
 	pUdataBuf->uUDataSlotSize = ctx->udata_buffer_size;
 	VID_STREAM_CONFIG_FORMAT_SET(vpu_format_remap(vdec_std), CurrStrfg);
+	if (vdec_std == VPU_VIDEO_JPEG) {
+		MediaIPFW_Video_JpegParams *pJpgPara;
+
+		pJpgPara = (MediaIPFW_Video_JpegParams *)ctx->dev->shared_mem.jpeg_mem_vir;
+		pJpgPara[ctx->str_index].uJpgMjpegMode = 1; //1:JPGD_MJPEG_MODE_A; 2:JPGD_MJPEG_MODE_B
+		pJpgPara[ctx->str_index].uJpgMjpegInterlaced = 0; //0: JPGD_MJPEG_PROGRESSIVE
+	}
 }
 
 static void v4l2_transfer_buffer_to_firmware(struct queue_data *This, struct vb2_buffer *vb)
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.h b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
index 0372960..007c280 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.h
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
@@ -114,6 +114,7 @@ enum vpu_video_standard {
 #define VPU_PIX_FMT_RV          v4l2_fourcc('R', 'V', '0', '0')
 #define VPU_PIX_FMT_VP6         v4l2_fourcc('V', 'P', '6', '0')
 #define VPU_PIX_FMT_SPK         v4l2_fourcc('S', 'P', 'K', '0')
+#define VPU_PIX_FMT_DIVX        v4l2_fourcc('D', 'I', 'V', 'X')
 #define VPU_PIX_FMT_HEVC        v4l2_fourcc('H', 'E', 'V', 'C')
 #define VPU_PIX_FMT_LOGO        v4l2_fourcc('L', 'O', 'G', 'O')
 
-- 
1.7.9.5


From ed50b30dff5de49fa0bf51490475918853344d62 Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Tue, 27 Dec 2016 10:15:50 +0800
Subject: [PATCH 1466/5242] MLK-13679-2 PCI: imx: workaround of ERR010728 for
 pcie on imx7d

commit  7db90e9f709ea34c2f29aeaeb695b7881385c89e from
https://source.codeaurora.org/external/imx/linux-imx.git

Description: Initial VCO oscillation may fail under
corner conditions such as cold temperature. It causes
PCIe PLL fail to lock in initialization phase.

Project Impact: iMX7 PCIe PLL fails to lock and iMX7D
PCIe doesn't work.

Workarounds: To toggle internal PLL_PD signal to make
VCO oscillate after G_RST signal is de-asserted by
following the sequences:
  - De-asserted G_RST signal
  - Toggle internal PLL_PD signal:
    - Write "0x04" to the address "0x306D_0054"
    - Write "0xA4" to the address "0x306D_0054"
    - Write "0x04" to the address "0x306D_0054"
  - De-asserted CMN_RST signal

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/controller/dwc/pci-imx6.c |   31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index a42cbe3..c8a4911 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -76,6 +76,7 @@ struct imx6_pcie {
 	int			link_gen;
 	struct regulator	*vpcie;
 	struct regmap		*reg_src;
+	void __iomem		*phy_base;
 	struct regulator	*pcie_phy_regulator;
 	struct regulator	*pcie_bus_regulator;
 };
@@ -142,6 +143,12 @@ struct imx6_pcie {
  * FIELD: ref_clkdiv2 [0:0]
  */
 
+/* iMX7 PCIe PHY registers */
+#define PCIE_PHY_CMN_REG15	0x54
+#define PCIE_PHY_CMN_REG15_DLY_4	(1 << 2)
+#define PCIE_PHY_CMN_REG15_PLL_PD	(1 << 5)
+#define PCIE_PHY_CMN_REG15_OVRD_PLL_PD	(1 << 7)
+
 static int pcie_phy_poll_ack(struct imx6_pcie *imx6_pcie, int exp_val)
 {
 	struct dw_pcie *pci = imx6_pcie->pci;
@@ -533,6 +540,21 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		udelay(10);
 		regmap_update_bits(imx6_pcie->reg_src, 0x2c, BIT(6), 0);
 		regmap_update_bits(imx6_pcie->reg_src, 0x2c, BIT(1), 0);
+
+		/* Add the workaround for ERR010728 */
+		if (unlikely(imx6_pcie->phy_base == NULL)) {
+			pr_err("phy base shouldn't be null.\n");
+		} else {
+			writel(PCIE_PHY_CMN_REG15_DLY_4,
+			       imx6_pcie->phy_base + PCIE_PHY_CMN_REG15);
+			writel(PCIE_PHY_CMN_REG15_DLY_4
+			       | PCIE_PHY_CMN_REG15_PLL_PD
+			       | PCIE_PHY_CMN_REG15_OVRD_PLL_PD,
+			       imx6_pcie->phy_base + PCIE_PHY_CMN_REG15);
+			writel(PCIE_PHY_CMN_REG15_DLY_4,
+			       imx6_pcie->phy_base + PCIE_PHY_CMN_REG15);
+		}
+
 		regmap_update_bits(imx6_pcie->reg_src, 0x2c, BIT(2), 0);
 
 		/* wait for phy pll lock firstly. */
@@ -1175,6 +1197,7 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct dw_pcie *pci;
 	struct imx6_pcie *imx6_pcie;
+	struct device_node *np;
 	struct resource *dbi_base;
 	struct device_node *node = dev->of_node;
 	int ret;
@@ -1202,6 +1225,14 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 			return -EINVAL;
 	}
 
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx-pcie-phy");
+	if (np != NULL) {
+		imx6_pcie->phy_base = of_iomap(np, 0);
+		WARN_ON(!imx6_pcie->phy_base);
+	} else {
+		imx6_pcie->phy_base = NULL;
+	}
+
 	dbi_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	pci->dbi_base = devm_ioremap_resource(dev, dbi_base);
 	if (IS_ERR(pci->dbi_base))
-- 
1.7.9.5


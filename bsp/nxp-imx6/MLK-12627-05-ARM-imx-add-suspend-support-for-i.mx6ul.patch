From e06654449ac8bdcaa562111172cfa1f9bd39d25b Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Fri, 1 Apr 2016 20:16:48 +0800
Subject: [PATCH 1003/5242] MLK-12627-05 ARM: imx: add suspend support for
 i.mx6ul

commit  da7a3ac924bb2e2c6fa43bc68203328859360885 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add suspend/resume support for i.MX6ULL.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Bai Ping <ping.bai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/common.h  |    1 +
 arch/arm/mach-imx/gpc.c     |   10 +++++-----
 arch/arm/mach-imx/pm-imx6.c |   18 ++++++++++++++----
 3 files changed, 20 insertions(+), 9 deletions(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index e13e688..f471842 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -180,6 +180,7 @@ static inline void imx7_suspend(void __iomem *ocram_vbase) {}
 void imx6sl_pm_init(void);
 void imx6sx_pm_init(void);
 void imx6ul_pm_init(void);
+void imx6ull_pm_init(void);
 void imx6q_pm_set_ccm_base(void __iomem *base);
 
 #ifdef CONFIG_PM
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index d4e2dff..86eac31 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -119,7 +119,7 @@ unsigned int imx_gpc_is_m4_sleeping(void)
 
 bool imx_gpc_usb_wakeup_enabled(void)
 {
-	if (!(cpu_is_imx6sx() || cpu_is_imx6ul()))
+	if (!(cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull()))
 		return false;
 
 	/*
@@ -180,7 +180,7 @@ void imx_gpc_pre_suspend(bool arm_power_off)
 		_imx6_pm_pu_power_off();
 
 	/* power down the mega-fast power domain */
-	if ((cpu_is_imx6sx() || cpu_is_imx6ul()) && arm_power_off)
+	if ((cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull()) && arm_power_off)
 		imx_gpc_mf_mix_off();
 
 	/* Tell GPC to power off ARM core when suspend */
@@ -204,7 +204,7 @@ void imx_gpc_post_resume(void)
 	/* Keep ARM core powered on for other low-power modes */
 	imx_gpc_set_arm_power_in_lpm(false);
 	/* Keep M/F mix powered on for other low-power modes */
-	if (cpu_is_imx6sx() || cpu_is_imx6ul())
+	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull())
 		writel_relaxed(0x0, gpc_base + GPC_PGC_MF_PDN);
 
 	for (i = 0; i < IMR_NUM; i++)
@@ -371,7 +371,7 @@ int imx_gpc_mf_power_on(unsigned int irq, unsigned int on)
 
 int imx_gpc_mf_request_on(unsigned int irq, unsigned int on)
 {
-	if (cpu_is_imx6sx() || cpu_is_imx6ul())
+	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull())
 		return imx_gpc_mf_power_on(irq, on);
 	else if (cpu_is_imx7d())
 		return imx_gpcv2_mf_power_on(irq, on);
@@ -453,7 +453,7 @@ static int __init imx_gpc_init(struct device_node *node,
 		writel_relaxed(~0, gpc_base + GPC_IMR1 + i * 4);
 
 	/* Read supported wakeup source in M/F domain */
-	if (cpu_is_imx6sx() || cpu_is_imx6ul()) {
+	if (cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull()) {
 		of_property_read_u32_index(node, "fsl,mf-mix-wakeup-irq", 0,
 			&gpc_mf_irqs[0]);
 		of_property_read_u32_index(node, "fsl,mf-mix-wakeup-irq", 1,
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index 0ae883d..cd678c4 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright 2011-2016 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -805,7 +805,6 @@ static int imx6q_pm_enter(suspend_state_t state)
 		}
 	}
 #endif
-
 	switch (state) {
 	case PM_SUSPEND_STANDBY:
 		imx6_set_lpm(STOP_POWER_ON);
@@ -836,6 +835,7 @@ static int imx6q_pm_enter(suspend_state_t state)
 			imx6_enable_rbc(true);
 		imx_gpc_pre_suspend(true);
 		imx_anatop_pre_suspend();
+		imx6_console_save(console_saved_reg);
 		if (cpu_is_imx6sx() && imx_gpc_is_mf_mix_off()) {
 			ccm_ccgr4 = readl_relaxed(ccm_base + CCGR4);
 			ccm_ccgr6 = readl_relaxed(ccm_base + CCGR6);
@@ -876,6 +876,7 @@ static int imx6q_pm_enter(suspend_state_t state)
 		}
 		if (cpu_is_imx6q() || cpu_is_imx6dl())
 			imx_smp_prepare();
+		imx6_console_restore(console_saved_reg);
 		imx_anatop_post_resume();
 		imx_gpc_post_resume();
 		imx6_enable_rbc(false);
@@ -1099,7 +1100,7 @@ static int __init imx6q_suspend_init(const struct imx6_pm_socdata *socdata)
 	}
 
 	/* need to overwrite the value for some mmdc registers */
-	if ((cpu_is_imx6sx() || cpu_is_imx6ul()) &&
+	if ((cpu_is_imx6sx() || cpu_is_imx6ul() || cpu_is_imx6ull()) &&
 		pm_info->ddr_type != IMX_DDR_TYPE_LPDDR2) {
 		pm_info->mmdc_val[20][1] = (pm_info->mmdc_val[20][1]
 			& 0xffff0000) | 0x0202;
@@ -1118,7 +1119,7 @@ static int __init imx6q_suspend_init(const struct imx6_pm_socdata *socdata)
 		pm_info->mmdc_val[32][1] = 0xa1310003;
 	}
 
-	if (cpu_is_imx6ul() &&
+	if ((cpu_is_imx6ul() || cpu_is_imx6ull()) &&
 		pm_info->ddr_type == IMX_DDR_TYPE_LPDDR2) {
 		pm_info->mmdc_val[0][1] = 0x8000;
 		pm_info->mmdc_val[2][1] = 0xa1390003;
@@ -1267,8 +1268,17 @@ void __init imx6sx_pm_init(void)
 
 void __init imx6ul_pm_init(void)
 {
+	struct device_node *np;
+
 	if (imx_mmdc_get_ddr_type() == IMX_DDR_TYPE_LPDDR2)
 		imx6_pm_common_init(&imx6ul_lpddr2_pm_data);
 	else
 		imx6_pm_common_init(&imx6ul_pm_data);
+
+	if (cpu_is_imx6ull()) {
+		np = of_find_node_by_path(
+			"/soc/aips-bus@02000000/spba-bus@02000000/serial@02020000");
+		if (np)
+			console_base = of_iomap(np, 0);
+	}
 }
-- 
1.7.9.5


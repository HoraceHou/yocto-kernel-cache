From 313cea44dc2fe85940caac4ac191a164976e82a8 Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Fri, 6 Jul 2018 09:59:59 +0800
Subject: [PATCH 4137/5242] MLK-18791 VPU: Fix the potential issue for add_eos
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit  6b9a723de8b9e4c4213236083d2a0479ea092774 from
https://source.codeaurora.org/external/imx/linux-imx.git

Fix the potential issue for add_eos to ensure memory wonâ€™t out
of range access

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/vpu_b0.c |   27 +++++++++++++++++++--------
 1 file changed, 19 insertions(+), 8 deletions(-)

diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
index 645ef72..88f2e4a 100644
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -52,7 +52,7 @@
 
 static void vpu_api_event_handler(struct vpu_ctx *ctx, u_int32 uStrIdx, u_int32 uEvent, u_int32 *event_data);
 static void v4l2_vpu_send_cmd(struct vpu_ctx *ctx, uint32_t idx, uint32_t cmdid, uint32_t cmdnum, uint32_t *local_cmddata);
-static void add_eos(struct vpu_ctx *ctx, u_int32 uStrBufIdx);
+static bool add_eos(struct vpu_ctx *ctx, u_int32 uStrBufIdx);
 static void v4l2_update_stream_addr(struct vpu_ctx *ctx, uint32_t uStrBufIdx);
 static int reset_vpu_firmware(struct vpu_dev *dev);
 
@@ -1033,7 +1033,7 @@ static void ctrls_delete_decoder(struct vpu_ctx *This)
 		This->ctrls[i] = NULL;
 }
 
-static void add_eos(struct vpu_ctx *ctx, u_int32 uStrBufIdx)
+static bool add_eos(struct vpu_ctx *ctx, u_int32 uStrBufIdx)
 {
 	struct vpu_dev *dev = ctx->dev;
 	pSTREAM_BUFFER_DESCRIPTOR_TYPE pStrBufDesc;
@@ -1057,24 +1057,34 @@ static void add_eos(struct vpu_ctx *ctx, u_int32 uStrBufIdx)
 	rptr = pStrBufDesc->rptr;
 
 	buffer = kzalloc(MIN_SPACE, GFP_KERNEL); //for eos data
-	if (!buffer)
+	if (!buffer) {
 		vpu_dbg(LVL_ERR, "error:  eos buffer alloc fail\n");
+		return false;
+	}
 	plbuffer = (uint32_t *)buffer;
-	pbbuffer = (uint8_t *)(ctx->stream_buffer_virt + wptr - start);
+	if (wptr - start < ctx->stream_buffer_size)
+		pbbuffer = (uint8_t *)(ctx->stream_buffer_virt + wptr - start);
+	else {
+		vpu_dbg(LVL_ERR, "error: return wptr(0x%x), start(0x%x) is not valid\n", wptr, start);
+		return false;
+	}
 
 	// Word align
 	if (((u_int64)pbbuffer)%4 != 0) {
 		int i;
-
+		if (end%4 != 0) {
+			vpu_dbg(LVL_ERR, "end address of stream not aligned by 4 bytes !\n");
+			return false;
+		}
 		pad_bytes = 4 - (((u_int64)pbbuffer)%4);
 		for (i = 0; i < pad_bytes; i++)
 			pbbuffer[i] = 0;
 		pbbuffer += pad_bytes;
-		if (end%4 != 0)
-			vpu_dbg(LVL_ERR, "end address of stream not aligned by 4 bytes !\n");
 		wptr += pad_bytes;
-		if (wptr == end)
+		if (wptr == end) {
 			wptr = start;
+			pbbuffer = (uint8_t *)ctx->stream_buffer_virt;
+		}
 	}
 
 	switch (q_data->vdec_std) {
@@ -1143,6 +1153,7 @@ static void add_eos(struct vpu_ctx *ctx, u_int32 uStrBufIdx)
 		(VPU_REG_BASE + DEC_MFD_XREG_SLV_BASE + MFD_MCX + MFD_MCX_OFF * ctx->str_index);
 	kfree(buffer);
 	vpu_dbg(LVL_INFO, "add eos MCX address virt=%p, phy=0x%x, index=%d\n", pStrBufDesc, dev->shared_mem.pSharedInterface->pStreamBuffDesc[ctx->str_index][uStrBufIdx], ctx->str_index);
+	return true;
 }
 
 TB_API_DEC_FMT vpu_format_remap(uint32_t vdec_std)
-- 
1.7.9.5


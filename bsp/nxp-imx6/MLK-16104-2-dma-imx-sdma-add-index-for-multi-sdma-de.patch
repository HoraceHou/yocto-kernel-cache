From ad925ed5847471aad355b0747a3d7ea642b33404 Mon Sep 17 00:00:00 2001
From: Robin Gong <yibin.gong@nxp.com>
Date: Mon, 31 Jul 2017 16:44:32 +0800
Subject: [PATCH 2266/5242] MLK-16104-2 dma: imx-sdma: add index for multi
 sdma devices case

commit  13f9c31be70287452a91ad59d3918212c2db8140 from
https://source.codeaurora.org/external/imx/linux-imx.git

On i.mx8mscale, there are two sdma instances here, and common dma
frameowrk will get channel dynamicly from any available channel whatever
it's from the first sdma device or the second sdma device. But actually,
some IP like SAI only work in sdma2 not sdma1. To make sure get sdma
channel from the right sdma device, add index to match.

Signed-off-by: Robin Gong <yibin.gong@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/dma/imx-sdma.c                |   10 ++++++++++
 include/linux/platform_data/dma-imx.h |    1 +
 2 files changed, 11 insertions(+)

diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index 88c389c..911e8ec 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -427,6 +427,7 @@ struct sdma_engine {
 	bool				bd0_iram;
 	struct sdma_buffer_descriptor	*bd0;
 	bool				suspend_off;
+	int				idx;
 };
 
 static struct sdma_driver_data sdma_imx31 = {
@@ -615,6 +616,8 @@ struct sdma_engine {
 };
 MODULE_DEVICE_TABLE(of, sdma_dt_ids);
 
+static int sdma_dev_idx;
+
 #define SDMA_H_CONFIG_DSPDMA	BIT(12) /* indicates if the DSPDMA is used */
 #define SDMA_H_CONFIG_RTD_PINS	BIT(11) /* indicates if Real-Time Debug pins are enabled */
 #define SDMA_H_CONFIG_ACR	BIT(4)  /* indicates if AHB freq /core freq = 2 or 1 */
@@ -2153,6 +2156,10 @@ static bool sdma_filter_fn(struct dma_chan *chan, void *fn_param)
 
 	if (!imx_dma_is_general_purpose(chan))
 		return false;
+	/* return false if it's not the right device */
+	if ((sdmac->sdma->drvdata == &sdma_imx8m)
+		&& (sdmac->sdma->idx != data->idx))
+		return false;
 
 	sdmac->data = *data;
 	chan->private = &sdmac->data;
@@ -2175,6 +2182,7 @@ static struct dma_chan *sdma_xlate(struct of_phandle_args *dma_spec,
 	data.dma_request = dma_spec->args[0];
 	data.peripheral_type = dma_spec->args[1];
 	data.priority = dma_spec->args[2];
+	data.idx = sdma->idx;
 
 	return dma_request_channel(mask, sdma_filter_fn, &data);
 }
@@ -2372,6 +2380,8 @@ static int sdma_probe(struct platform_device *pdev)
 		}
 		of_node_put(spba_bus);
 	}
+	/* There maybe multi sdma devices such as i.mx8mscale */
+	sdma->idx = sdma_dev_idx++;
 
 	return 0;
 
diff --git a/include/linux/platform_data/dma-imx.h b/include/linux/platform_data/dma-imx.h
index bee13cf..18ed10c 100644
--- a/include/linux/platform_data/dma-imx.h
+++ b/include/linux/platform_data/dma-imx.h
@@ -58,6 +58,7 @@ struct imx_dma_data {
 	int priority;
 	bool src_dualfifo;
 	bool dst_dualfifo;
+	int idx;
 };
 
 static inline int imx_dma_is_ipu(struct dma_chan *chan)
-- 
1.7.9.5


From 0ef75f6ac177f0e07b5d12e65c3cf6ac42db2e6c Mon Sep 17 00:00:00 2001
From: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Date: Tue, 20 Feb 2018 15:06:49 +0200
Subject: [PATCH 3412/5242] MLK-17634-16: drm: imx: dcss: make 10-bit formats
 work with HDR

commit  e36ba383fb4e89c62e95bd115000d6d894b6d879 from
https://source.codeaurora.org/external/imx/linux-imx.git

Signed-off-by: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/dcss/dcss-plane.c |    6 +-----
 drivers/gpu/imx/dcss/dcss-dpr.c       |    7 +++++--
 drivers/gpu/imx/dcss/dcss-dtrc.c      |   10 ++++++----
 drivers/gpu/imx/dcss/dcss-hdr10.c     |   10 ++++++++--
 drivers/gpu/imx/dcss/dcss-scaler.c    |    3 ++-
 5 files changed, 22 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/imx/dcss/dcss-plane.c b/drivers/gpu/drm/imx/dcss/dcss-plane.c
index 0efbd97..a50ad4e 100644
--- a/drivers/gpu/drm/imx/dcss/dcss-plane.c
+++ b/drivers/gpu/drm/imx/dcss/dcss-plane.c
@@ -384,10 +384,6 @@ static void dcss_plane_atomic_update(struct drm_plane *plane,
 		return;
 	}
 
-	dcss_dpr_enable(dcss_plane->dcss, dcss_plane->ch_num, false);
-	dcss_scaler_enable(dcss_plane->dcss, dcss_plane->ch_num, false);
-	dcss_dtg_ch_enable(dcss_plane->dcss, dcss_plane->ch_num, false);
-
 	disp.x1 = 0;
 	disp.y1 = 0;
 	disp.x2 = crtc_state->adjusted_mode.hdisplay;
@@ -453,7 +449,7 @@ static void dcss_plane_atomic_update(struct drm_plane *plane,
 
 	ipipe_cfg.pixel_format = pixel_format;
 	ipipe_cfg.nl = NL_REC709;
-	ipipe_cfg.pr = PR_LIMITED;
+	ipipe_cfg.pr = PR_FULL;
 	ipipe_cfg.g = G_REC709;
 
 	dcss_crtc_get_opipe_cfg(state->crtc, &opipe_cfg);
diff --git a/drivers/gpu/imx/dcss/dcss-dpr.c b/drivers/gpu/imx/dcss/dcss-dpr.c
index 61f8184..c2c70e5 100644
--- a/drivers/gpu/imx/dcss/dcss-dpr.c
+++ b/drivers/gpu/imx/dcss/dcss-dpr.c
@@ -239,7 +239,7 @@ static u32 dcss_dpr_x_pix_wide_adjust(struct dcss_dpr_ch *ch, u32 pix_wide,
 	pix_in_64byte = pix_in_64byte_map[ch->pix_size][ch->tile];
 
 	if (pix_format == DRM_FORMAT_P010)
-		pix_wide *= 10 / 8;
+		pix_wide = pix_wide * 10 / 8;
 
 	div_64byte_mod = pix_wide % pix_in_64byte;
 	offset = (div_64byte_mod == 0) ? 0 : (pix_in_64byte - div_64byte_mod);
@@ -274,6 +274,9 @@ void dcss_dpr_set_res(struct dcss_soc *dcss, int ch_num, u32 xres, u32 yres,
 	    pix_format == DRM_FORMAT_P010)
 		max_planes = 2;
 
+	if (pix_format == DRM_FORMAT_P010)
+		adj_w = adj_w * 10 / 8;
+
 	for (plane = 0; plane < max_planes; plane++) {
 		yres = plane == 1 ? yres >> 1 : yres;
 
@@ -281,7 +284,7 @@ void dcss_dpr_set_res(struct dcss_soc *dcss, int ch_num, u32 xres, u32 yres,
 		pix_y_high = dcss_dpr_y_pix_high_adjust(ch, yres, pix_format);
 
 		/* DTRC may need another width alignment. If it does, use it. */
-		if (pix_x_wide != adj_w)
+		if (pix_x_wide < adj_w)
 			pix_x_wide = adj_w;
 
 		if (pix_y_high != adj_h)
diff --git a/drivers/gpu/imx/dcss/dcss-dtrc.c b/drivers/gpu/imx/dcss/dcss-dtrc.c
index 8589627..e862308 100644
--- a/drivers/gpu/imx/dcss/dcss-dtrc.c
+++ b/drivers/gpu/imx/dcss/dcss-dtrc.c
@@ -330,6 +330,7 @@ void dcss_dtrc_set_res(struct dcss_soc *dcss, int ch_num, struct drm_rect *src,
 	int bank;
 	u32 old_xres, old_yres, xres, yres;
 	u32 pix_depth;
+	u16 width_align = 0;
 
 	if (ch_num == 0)
 		return;
@@ -357,10 +358,11 @@ void dcss_dtrc_set_res(struct dcss_soc *dcss, int ch_num, struct drm_rect *src,
 
 	/*
 	 * Image original size is aligned:
-	 *   - 128 pixels for width;
+	 *   - 128 pixels for width (8-bit) or 256 (10-bit);
 	 *   - 8 lines for height;
 	 */
-	if (xres == old_xres && !(xres & 0x7f) &&
+	width_align = ch->pix_format == DRM_FORMAT_P010 ? 0xff : 0x7f;
+	if (xres == old_xres && !(xres & width_align) &&
 	    yres == old_yres && !(yres & 0xf)) {
 		ch->dctl &= ~CROPPING_EN;
 		goto exit;
@@ -368,9 +370,9 @@ void dcss_dtrc_set_res(struct dcss_soc *dcss, int ch_num, struct drm_rect *src,
 
 	/* align the image size: down align for compressed formats */
 	if (ch->format_modifier == DRM_FORMAT_MOD_VSI_G2_TILED_COMPRESSED && src->x1)
-		xres = xres & ~0x7f;
+		xres = xres & ~width_align;
 	else
-		xres = (xres - 1 + 0x7f) & ~0x7f;
+		xres = (xres - 1 + width_align) & ~width_align;
 
 	if (ch->format_modifier == DRM_FORMAT_MOD_VSI_G2_TILED_COMPRESSED && src->y1)
 		yres = yres & ~0xf;
diff --git a/drivers/gpu/imx/dcss/dcss-hdr10.c b/drivers/gpu/imx/dcss/dcss-hdr10.c
index 843a781..aa60cd7 100644
--- a/drivers/gpu/imx/dcss/dcss-hdr10.c
+++ b/drivers/gpu/imx/dcss/dcss-hdr10.c
@@ -597,7 +597,8 @@ static u64 dcss_hdr10_get_desc(struct dcss_hdr10_pipe_cfg *ipipe_cfg,
 {
 	u32 ipipe_desc, opipe_desc;
 
-	ipipe_desc = dcss_hdr10_pipe_desc(ipipe_cfg);
+	ipipe_desc = dcss_hdr10_pipe_desc(ipipe_cfg) & (~HDR10_BPC_MASK);
+	ipipe_desc |= 2 << HDR10_BPC_POS;
 	opipe_desc = dcss_hdr10_pipe_desc(opipe_cfg);
 
 	return (ipipe_desc & 0xFFFF) |
@@ -630,6 +631,11 @@ void dcss_hdr10_setup(struct dcss_soc *dcss, int ch_num,
 	u64 desc = dcss_hdr10_get_desc(ipipe_cfg, opipe_cfg);
 
 	dcss_hdr10_pipe_setup(dcss, ch_num, desc);
-	dcss_hdr10_pipe_setup(dcss, OPIPE_CH_NO, desc);
+
+	/*
+	 * Input pipe configuration doesn't matter for configuring the output
+	 * pipe. So, will just mask off the input part of the descriptor.
+	 */
+	dcss_hdr10_pipe_setup(dcss, OPIPE_CH_NO, desc | 0xffff);
 }
 EXPORT_SYMBOL(dcss_hdr10_setup);
diff --git a/drivers/gpu/imx/dcss/dcss-scaler.c b/drivers/gpu/imx/dcss/dcss-scaler.c
index c9c422f..3069c53 100644
--- a/drivers/gpu/imx/dcss/dcss-scaler.c
+++ b/drivers/gpu/imx/dcss/dcss-scaler.c
@@ -616,7 +616,8 @@ void dcss_scaler_setup(struct dcss_soc *dcss, int ch_num, u32 pix_format,
 
 		dcss_scaler_yuv_coef_set(dcss, ch_num);
 
-		/* TODO: determine component depth for YUV */
+		if (pix_format == DRM_FORMAT_P010)
+			pixel_depth = 30;
 
 	} else if (dcss_cs == DCSS_COLORSPACE_RGB) {
 		dcss_scaler_yuv_enable(dcss, ch_num, false);
-- 
1.7.9.5


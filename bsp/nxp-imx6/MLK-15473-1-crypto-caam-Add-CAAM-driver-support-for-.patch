From 21676bf73314da3aba10ec9077cfacab82a4c211 Mon Sep 17 00:00:00 2001
From: Franck LENORMAND <franck.lenormand@nxp.com>
Date: Tue, 3 Jul 2018 13:27:23 +0200
Subject: [PATCH 4179/5242] MLK-15473-1: crypto: caam: Add CAAM driver support
 for iMX8 soc family

commit  afa53c2c96a54b4432a26372e3b5e7dbccbb9671 from
https://source.codeaurora.org/external/imx/linux-imx.git

Enable CAAM driver for i.MX8 family:
	- Use a Job ring for RNG instantiation rather than DECO, even
     for i.MX6/7 families.
	- Use of aliased CAAM registers instead of original registers in page 0
     since page 0 is no more accessible in i.MX8 family except mScale.

Signed-off-by: Aymen Sghaier <aymen.sghaier@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/crypto/fsl-sec4.txt        |    2 +-
 drivers/crypto/caam/caamalg.c                      |   10 +-
 drivers/crypto/caam/caamhash.c                     |   12 +-
 drivers/crypto/caam/caampkc.c                      |   10 +-
 drivers/crypto/caam/caamrng.c                      |   10 +-
 drivers/crypto/caam/ctrl.c                         |  724 ++++++++++++--------
 drivers/crypto/caam/desc_constr.h                  |   28 +-
 drivers/crypto/caam/intern.h                       |   24 +-
 drivers/crypto/caam/jr.c                           |    2 +-
 drivers/crypto/caam/regs.h                         |    9 +-
 10 files changed, 512 insertions(+), 319 deletions(-)

diff --git a/Documentation/devicetree/bindings/crypto/fsl-sec4.txt b/Documentation/devicetree/bindings/crypto/fsl-sec4.txt
index d05d044..5cf810e 100644
--- a/Documentation/devicetree/bindings/crypto/fsl-sec4.txt
+++ b/Documentation/devicetree/bindings/crypto/fsl-sec4.txt
@@ -54,7 +54,7 @@ PROPERTIES
    - compatible
       Usage: required
       Value type: <string>
-      Definition: Must include "fsl,sec-v4.0"
+      Definition: Must include "fsl,sec-v4.0" or "fsl,sec4.0"
 
    - fsl,sec-era
       Usage: optional
diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index 1403f18..1ac7413 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -3597,8 +3597,14 @@ static int __init caam_algapi_init(void)
 	 * Register crypto algorithms the device supports.
 	 * First, detect presence and attributes of DES, AES, and MD blocks.
 	 */
-	cha_vid = rd_reg32(&priv->ctrl->perfmon.cha_id_ls);
-	cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	if (priv->has_seco) {
+		i = priv->first_jr_index;
+		cha_vid = rd_reg32(&priv->jr[i]->perfmon.cha_id_ls);
+		cha_inst = rd_reg32(&priv->jr[i]->perfmon.cha_num_ls);
+	} else {
+		cha_vid = rd_reg32(&priv->ctrl->perfmon.cha_id_ls);
+		cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	}
 	des_inst = (cha_inst & CHA_ID_LS_DES_MASK) >> CHA_ID_LS_DES_SHIFT;
 	aes_inst = (cha_inst & CHA_ID_LS_AES_MASK) >> CHA_ID_LS_AES_SHIFT;
 	md_inst = (cha_inst & CHA_ID_LS_MD_MASK) >> CHA_ID_LS_MD_SHIFT;
diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c
index 0090e6f..2b5f32f 100644
--- a/drivers/crypto/caam/caamhash.c
+++ b/drivers/crypto/caam/caamhash.c
@@ -1,7 +1,7 @@
 /*
  * caam - Freescale FSL CAAM support for ahash functions of crypto API
  *
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2017 Freescale Semiconductor, Inc.
  *
  * Based on caamalg.c crypto API driver.
  *
@@ -2172,8 +2172,14 @@ static int __init caam_algapi_hash_init(void)
 	 * Register crypto algorithms the device supports.  First, identify
 	 * presence and attributes of MD block.
 	 */
-	cha_vid = rd_reg32(&priv->ctrl->perfmon.cha_id_ls);
-	cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	if (priv->has_seco) {
+		i = priv->first_jr_index;
+		cha_vid = rd_reg32(&priv->jr[i]->perfmon.cha_id_ls);
+		cha_inst = rd_reg32(&priv->jr[i]->perfmon.cha_num_ls);
+	} else {
+		cha_vid = rd_reg32(&priv->ctrl->perfmon.cha_id_ls);
+		cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	}
 
 	/*
 	 * Skip registration of any hashing algorithms if MD block
diff --git a/drivers/crypto/caam/caampkc.c b/drivers/crypto/caam/caampkc.c
index f26d62e..64afab4 100644
--- a/drivers/crypto/caam/caampkc.c
+++ b/drivers/crypto/caam/caampkc.c
@@ -1,7 +1,7 @@
 /*
  * caam - Freescale FSL CAAM support for Public Key Cryptography
  *
- * Copyright 2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2017 Freescale Semiconductor, Inc.
  *
  * There is no Shared Descriptor for PKC so that the Job Descriptor must carry
  * all the desired key parameters, input and output pointers.
@@ -1044,7 +1044,13 @@ static int __init caam_pkc_init(void)
 		return -ENODEV;
 
 	/* Determine public key hardware accelerator presence. */
-	cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	if (priv->has_seco) {
+		int i = priv->first_jr_index;
+
+		cha_inst = rd_reg32(&priv->jr[i]->perfmon.cha_num_ls);
+	} else {
+		cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	}
 	pk_inst = (cha_inst & CHA_ID_LS_PK_MASK) >> CHA_ID_LS_PK_SHIFT;
 
 	/* Do not register algorithms if PKHA is not present. */
diff --git a/drivers/crypto/caam/caamrng.c b/drivers/crypto/caam/caamrng.c
index d354e6e..47dc537 100644
--- a/drivers/crypto/caam/caamrng.c
+++ b/drivers/crypto/caam/caamrng.c
@@ -352,6 +352,7 @@ static int __init caam_rng_init(void)
 	struct device *ctrldev;
 	struct caam_drv_private *priv;
 	int err;
+	u32 cha_inst;
 
 	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
 	if (!dev_node) {
@@ -378,7 +379,14 @@ static int __init caam_rng_init(void)
 		return -ENODEV;
 
 	/* Check for an instantiated RNG before registration */
-	if (!(rd_reg32(&priv->ctrl->perfmon.cha_num_ls) & CHA_ID_LS_RNG_MASK))
+	if (priv->has_seco) {
+		int i = priv->first_jr_index;
+
+		cha_inst = rd_reg32(&priv->jr[i]->perfmon.cha_num_ls);
+	} else {
+		cha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);
+	}
+	if (!(cha_inst & CHA_ID_LS_RNG_MASK))
 		return -ENODEV;
 
 	dev = caam_jr_alloc();
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 5ad0ca8..be76c31 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -1,7 +1,7 @@
 /* * CAAM control-plane driver backend
  * Controller-level driver, kernel property detection, initialization
  *
- * Copyright 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright 2008-2017 Freescale Semiconductor, Inc.
  */
 
 #include <linux/device.h>
@@ -28,6 +28,17 @@
 #include "qi.h"
 #endif
 
+static int caam_remove(struct platform_device *pdev);
+static void handle_imx6_err005766(struct caam_drv_private *ctrlpriv);
+static int caam_probe(struct platform_device *pdev);
+static void init_debugfs(struct caam_drv_private *ctrlpriv);
+static int init_clocks(struct caam_drv_private *ctrlpriv);
+static void check_virt(struct caam_drv_private *ctrlpriv, u32 comp_params);
+static int enable_jobrings(struct caam_drv_private *ctrlpriv, int block_offset);
+static void enable_qi(struct caam_drv_private *ctrlpriv, int block_offset);
+static int read_first_jr_index(struct caam_drv_private *ctrlpriv);
+static int probe_w_seco(struct caam_drv_private *ctrlpriv);
+
 /*
  * i.MX targets tend to have clock control subsystems that can
  * enable/disable clocking to our device.
@@ -74,8 +85,9 @@ static int caam_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int caam_get_era_from_hw(struct caam_ctrl __iomem *ctrl)
+static int caam_get_era_from_hw(struct caam_drv_private *ctrlpriv)
 {
+	struct device *dev = ctrlpriv->dev;
 	static const struct {
 		u16 ip_id;
 		u8 maj_rev;
@@ -113,19 +125,31 @@ static int caam_get_era_from_hw(struct caam_ctrl __iomem *ctrl)
 	u16 ip_id;
 	int i;
 
-	ccbvid = rd_reg32(&ctrl->perfmon.ccb_id);
+	i = ctrlpriv->first_jr_index;
+	if (ctrlpriv->has_seco)
+		ccbvid = rd_reg32(&ctrlpriv->jr[i]->perfmon.ccb_id);
+	else
+		ccbvid = rd_reg32(&ctrlpriv->ctrl->perfmon.ccb_id);
+
 	era = (ccbvid & CCBVID_ERA_MASK) >> CCBVID_ERA_SHIFT;
 	if (era)	/* This is '0' prior to CAAM ERA-6 */
 		return era;
 
-	id_ms = rd_reg32(&ctrl->perfmon.caam_id_ms);
+	if (ctrlpriv->has_seco)
+		id_ms = rd_reg32(&ctrlpriv->jr[i]->perfmon.caam_id_ms);
+	else
+		id_ms = rd_reg32(&ctrlpriv->ctrl->perfmon.caam_id_ms);
 	ip_id = (id_ms & SECVID_MS_IPID_MASK) >> SECVID_MS_IPID_SHIFT;
 	maj_rev = (id_ms & SECVID_MS_MAJ_REV_MASK) >> SECVID_MS_MAJ_REV_SHIFT;
 
-	for (i = 0; i < ARRAY_SIZE(id); i++)
-		if (id[i].ip_id == ip_id && id[i].maj_rev == maj_rev)
+	for (i = 0; i < ARRAY_SIZE(id); i++) {
+		if (id[i].ip_id == ip_id && id[i].maj_rev == maj_rev) {
+			dev_info(dev, "ERA source: %s.\n", era_source);
 			return id[i].era;
+		}
+	}
 
+	dev_info(dev, "ERA undetermined!.\n");
 	return -ENOTSUPP;
 }
 
@@ -136,7 +160,7 @@ static int caam_get_era_from_hw(struct caam_ctrl __iomem *ctrl)
  * In case this property is not passed an attempt to retrieve the CAAM
  * era via register reads will be made.
  **/
-static int caam_get_era(struct caam_ctrl __iomem *ctrl)
+static int caam_get_era(struct caam_drv_private *ctrlpriv)
 {
 	struct device_node *caam_node;
 	int ret;
@@ -149,7 +173,7 @@ static int caam_get_era(struct caam_ctrl __iomem *ctrl)
 	if (!ret)
 		return prop;
 	else
-		return caam_get_era_from_hw(ctrl);
+		return caam_get_era_from_hw(ctrlpriv);
 }
 
 static void handle_imx6_err005766(struct caam_drv_private *ctrlpriv)
@@ -172,7 +196,8 @@ static void handle_imx6_err005766(struct caam_drv_private *ctrlpriv)
 	if (of_machine_is_compatible("fsl,imx6q") ||
 	    of_machine_is_compatible("fsl,imx6dl") ||
 	    of_machine_is_compatible("fsl,imx6qp")) {
-		pr_info("AXI pipeline throttling enabled.\n");
+		dev_info(&ctrlpriv->pdev->dev,
+			 "AXI pipeline throttling enabled.\n");
 		mcr_val = rd_reg32(&ctrlpriv->ctrl->mcr);
 		wr_reg32(&ctrlpriv->ctrl->mcr,
 			 (mcr_val & ~(MCFGR_AXIPIPE_MASK)) |
@@ -180,75 +205,131 @@ static void handle_imx6_err005766(struct caam_drv_private *ctrlpriv)
 	}
 }
 
-static const struct of_device_id caam_match[] = {
-	{
-		.compatible = "fsl,sec-v4.0",
-	},
-	{
-		.compatible = "fsl,sec4.0",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, caam_match);
-
-/* Probe routine for CAAM top (controller) level */
-static int caam_probe(struct platform_device *pdev)
+static void init_debugfs(struct caam_drv_private *ctrlpriv)
 {
-	int ret, ring, gen_sk, ent_delay = RTSDCTL_ENT_DLY_MIN;
-	u64 caam_id;
-	static const struct soc_device_attribute imx_soc[] = {
-		{.family = "Freescale i.MX"},
-		{},
-	};
-	struct device *dev;
-	struct device_node *nprop, *np;
-	struct caam_ctrl __iomem *ctrl;
-	struct caam_drv_private *ctrlpriv;
-	struct clk *clk;
 #ifdef CONFIG_DEBUG_FS
 	struct caam_perfmon *perfmon;
-#endif
-	u32 scfgr, comp_params;
-	u32 cha_vid_ls;
-	int pg_size;
-	int BLOCK_OFFSET = 0;
 
-	ctrlpriv = devm_kzalloc(&pdev->dev, sizeof(*ctrlpriv), GFP_KERNEL);
-	if (!ctrlpriv)
-		return -ENOMEM;
+	/*
+	 * FIXME: needs better naming distinction, as some amalgamation of
+	 * "caam" and nprop->full_name. The OF name isn't distinctive,
+	 * but does separate instances
+	 */
+	perfmon = (struct caam_perfmon __force *)&ctrlpriv->ctrl->perfmon;
 
-	dev = &pdev->dev;
-	dev_set_drvdata(dev, ctrlpriv);
-	nprop = pdev->dev.of_node;
+	ctrlpriv->dfs_root = debugfs_create_dir(dev_name(ctrlpriv->dev), NULL);
+	ctrlpriv->ctl = debugfs_create_dir("ctl", ctrlpriv->dfs_root);
 
-	caam_imx = (bool)soc_device_match(imx_soc);
+	/* Controller-level - performance monitor counters */
+
+	ctrlpriv->ctl_rq_dequeued =
+		debugfs_create_file("rq_dequeued",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->req_dequeued,
+				    &caam_fops_u64_ro);
+	ctrlpriv->ctl_ob_enc_req =
+		debugfs_create_file("ob_rq_encrypted",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->ob_enc_req,
+				    &caam_fops_u64_ro);
+	ctrlpriv->ctl_ib_dec_req =
+		debugfs_create_file("ib_rq_decrypted",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->ib_dec_req,
+				    &caam_fops_u64_ro);
+	ctrlpriv->ctl_ob_enc_bytes =
+		debugfs_create_file("ob_bytes_encrypted",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->ob_enc_bytes,
+				    &caam_fops_u64_ro);
+	ctrlpriv->ctl_ob_prot_bytes =
+		debugfs_create_file("ob_bytes_protected",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->ob_prot_bytes,
+				    &caam_fops_u64_ro);
+	ctrlpriv->ctl_ib_dec_bytes =
+		debugfs_create_file("ib_bytes_decrypted",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->ib_dec_bytes,
+				    &caam_fops_u64_ro);
+	ctrlpriv->ctl_ib_valid_bytes =
+		debugfs_create_file("ib_bytes_validated",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->ib_valid_bytes,
+				    &caam_fops_u64_ro);
+
+	/* Controller level - global status values */
+	ctrlpriv->ctl_faultaddr =
+		debugfs_create_file("fault_addr",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->faultaddr,
+				    &caam_fops_u32_ro);
+	ctrlpriv->ctl_faultdetail =
+		debugfs_create_file("fault_detail",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->faultdetail,
+				    &caam_fops_u32_ro);
+	ctrlpriv->ctl_faultstatus =
+		debugfs_create_file("fault_status",
+				    0444,
+				    ctrlpriv->ctl, &perfmon->status,
+				    &caam_fops_u32_ro);
+
+	/* Internal covering keys (useful in non-secure mode only) */
+	ctrlpriv->ctl_kek_wrap.data = &ctrlpriv->ctrl->kek[0];
+	ctrlpriv->ctl_kek_wrap.size = KEK_KEY_SIZE * sizeof(u32);
+	ctrlpriv->ctl_kek = debugfs_create_blob("kek",
+						0444,
+						ctrlpriv->ctl,
+						&ctrlpriv->ctl_kek_wrap);
+
+	ctrlpriv->ctl_tkek_wrap.data = &ctrlpriv->ctrl->tkek[0];
+	ctrlpriv->ctl_tkek_wrap.size = KEK_KEY_SIZE * sizeof(u32);
+	ctrlpriv->ctl_tkek = debugfs_create_blob("tkek",
+						 0444,
+						 ctrlpriv->ctl,
+						 &ctrlpriv->ctl_tkek_wrap);
+
+	ctrlpriv->ctl_tdsk_wrap.data = &ctrlpriv->ctrl->tdsk[0];
+	ctrlpriv->ctl_tdsk_wrap.size = KEK_KEY_SIZE * sizeof(u32);
+	ctrlpriv->ctl_tdsk = debugfs_create_blob("tdsk",
+						 0444,
+						 ctrlpriv->ctl,
+						 &ctrlpriv->ctl_tdsk_wrap);
+#endif
+}
+
+static int init_clocks(struct caam_drv_private *ctrlpriv)
+{
+	struct clk *clk;
+	struct device *dev = ctrlpriv->dev;
+	int ret = 0;
 
 	/* Enable clocking */
-	clk = caam_drv_identify_clk(&pdev->dev, "ipg");
+	clk = caam_drv_identify_clk(dev, "ipg");
 	if (IS_ERR(clk)) {
 		ret = PTR_ERR(clk);
-		dev_err(&pdev->dev,
-			"can't identify CAAM ipg clk: %d\n", ret);
+		dev_err(dev, "can't identify CAAM ipg clk: %d\n", ret);
 		return ret;
 	}
 	ctrlpriv->caam_ipg = clk;
 
 	if (!of_machine_is_compatible("fsl,imx7d") &&
 	    !of_machine_is_compatible("fsl,imx7s")) {
-		clk = caam_drv_identify_clk(&pdev->dev, "mem");
+		clk = caam_drv_identify_clk(dev, "mem");
 		if (IS_ERR(clk)) {
 			ret = PTR_ERR(clk);
-			dev_err(&pdev->dev,
+			dev_err(dev,
 				"can't identify CAAM mem clk: %d\n", ret);
 			return ret;
 		}
 		ctrlpriv->caam_mem = clk;
 	}
 
-	clk = caam_drv_identify_clk(&pdev->dev, "aclk");
+	clk = caam_drv_identify_clk(dev, "aclk");
 	if (IS_ERR(clk)) {
 		ret = PTR_ERR(clk);
-		dev_err(&pdev->dev,
+		dev_err(dev,
 			"can't identify CAAM aclk clk: %d\n", ret);
 		return ret;
 	}
@@ -257,10 +338,10 @@ static int caam_probe(struct platform_device *pdev)
 	if (!of_machine_is_compatible("fsl,imx6ul") &&
 	    !of_machine_is_compatible("fsl,imx7d") &&
 	    !of_machine_is_compatible("fsl,imx7s")) {
-		clk = caam_drv_identify_clk(&pdev->dev, "emi_slow");
+		clk = caam_drv_identify_clk(dev, "emi_slow");
 		if (IS_ERR(clk)) {
 			ret = PTR_ERR(clk);
-			dev_err(&pdev->dev,
+			dev_err(dev,
 				"can't identify CAAM emi_slow clk: %d\n", ret);
 			return ret;
 		}
@@ -269,32 +350,258 @@ static int caam_probe(struct platform_device *pdev)
 
 	ret = clk_prepare_enable(ctrlpriv->caam_ipg);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "can't enable CAAM ipg clock: %d\n", ret);
+		dev_err(dev, "can't enable CAAM ipg clock: %d\n", ret);
 		return ret;
 	}
 
 	if (ctrlpriv->caam_mem) {
 		ret = clk_prepare_enable(ctrlpriv->caam_mem);
 		if (ret < 0) {
-			dev_err(&pdev->dev, "can't enable CAAM secure mem clock: %d\n",
+			dev_err(dev, "can't enable CAAM secure mem clock: %d\n",
 				ret);
-			goto disable_caam_ipg;
+			return ret;
 		}
 	}
 
 	ret = clk_prepare_enable(ctrlpriv->caam_aclk);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "can't enable CAAM aclk clock: %d\n", ret);
-		goto disable_caam_mem;
+		dev_err(dev, "can't enable CAAM aclk clock: %d\n", ret);
+		return ret;
 	}
 
 	if (ctrlpriv->caam_emi_slow) {
 		ret = clk_prepare_enable(ctrlpriv->caam_emi_slow);
 		if (ret < 0) {
-			dev_err(&pdev->dev, "can't enable CAAM emi slow clock: %d\n",
+			dev_err(dev, "can't enable CAAM emi slow clock: %d\n",
 				ret);
-			goto disable_caam_aclk;
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static void check_virt(struct caam_drv_private *ctrlpriv, u32 comp_params)
+{
+	/*
+	 *  Read the Compile Time parameters and SCFGR to determine
+	 * if Virtualization is enabled for this platform
+	 */
+	u32 scfgr;
+
+	scfgr = rd_reg32(&ctrlpriv->ctrl->scfgr);
+
+	ctrlpriv->virt_en = 0;
+	if (comp_params & CTPR_MS_VIRT_EN_INCL) {
+		/* VIRT_EN_INCL = 1 & VIRT_EN_POR = 1 or
+		 * VIRT_EN_INCL = 1 & VIRT_EN_POR = 0 & SCFGR_VIRT_EN = 1
+		 */
+		if ((comp_params & CTPR_MS_VIRT_EN_POR) ||
+		    (!(comp_params & CTPR_MS_VIRT_EN_POR) &&
+		       (scfgr & SCFGR_VIRT_EN)))
+			ctrlpriv->virt_en = 1;
+	} else {
+		/* VIRT_EN_INCL = 0 && VIRT_EN_POR_VALUE = 1 */
+		if (comp_params & CTPR_MS_VIRT_EN_POR)
+			ctrlpriv->virt_en = 1;
+	}
+
+	if (ctrlpriv->virt_en == 1)
+		clrsetbits_32(&ctrlpriv->ctrl->jrstart, 0, JRSTART_JR0_START |
+			      JRSTART_JR1_START | JRSTART_JR2_START |
+			      JRSTART_JR3_START);
+}
+
+static int enable_jobrings(struct caam_drv_private *ctrlpriv, int block_offset)
+{
+	int ring;
+	int ret;
+	struct device_node *nprop, *np;
+	struct device *dev = ctrlpriv->dev;
+
+#ifdef CONFIG_DEBUG_FS
+	/*
+	 * FIXME: needs better naming distinction, as some amalgamation of
+	 * "caam" and nprop->full_name. The OF name isn't distinctive,
+	 * but does separate instances
+	 */
+
+	ctrlpriv->dfs_root = debugfs_create_dir(dev_name(dev), NULL);
+	ctrlpriv->ctl = debugfs_create_dir("ctl", ctrlpriv->dfs_root);
+#endif
+
+	nprop = ctrlpriv->pdev->dev.of_node;
+	ret = of_platform_populate(nprop, NULL, NULL, dev);
+	if (ret) {
+		dev_err(dev, "JR platform devices creation error\n");
+		return -ENOMEM;
+	}
+
+	ring = 0;
+	for_each_available_child_of_node(nprop, np)
+		if (of_device_is_compatible(np, "fsl,sec-v4.0-job-ring") ||
+		    of_device_is_compatible(np, "fsl,sec4.0-job-ring")) {
+			ctrlpriv->jr[ring] = (struct caam_job_ring __iomem __force *)
+					     ((__force uint8_t *)ctrl +
+					     (ring + JR_BLOCK_NUMBER) *
+					      block_offset);
+			ctrlpriv->total_jobrs++;
+			ring++;
 		}
+
+	return 0;
+}
+
+static void enable_qi(struct caam_drv_private *ctrlpriv, int block_offset)
+{
+	u32 parms_ms = rd_reg32(&ctrlpriv->ctrl->perfmon.comp_parms_ms);
+
+	/* Check to see if (DPAA 1.x) QI present. If so, enable */
+	ctrlpriv->qi_present = !!(parms_ms & CTPR_MS_QI_MASK);
+	if (ctrlpriv->qi_present && !caam_dpaa2) {
+		ctrlpriv->qi = (struct caam_queue_if __iomem __force *)
+			       ((__force uint8_t *)ctrlpriv->ctrl +
+				 block_offset * QI_BLOCK_NUMBER
+			       );
+
+		/* This is all that's required to physically enable QI */
+		wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_DQEN);
+
+		/* If QMAN driver is present, init CAAM-QI backend */
+#ifdef CONFIG_CAAM_QI
+		ret = caam_qi_init(pdev);
+		if (ret)
+			dev_err(dev, "caam qi i/f init failed: %d\n", ret);
+#endif
+	}
+}
+
+static int read_first_jr_index(struct caam_drv_private *ctrlpriv)
+{
+	struct device_node *caam_node;
+	int ret;
+	u32 first_index;
+
+	caam_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	ret = of_property_read_u32(caam_node,
+		   "fsl,first-jr-index", &first_index);
+	of_node_put(caam_node);
+	if (ret == 0)
+		if (first_index > 0 && first_index < 4)
+			ctrlpriv->first_jr_index = first_index;
+	return ret;
+}
+
+static int probe_w_seco(struct caam_drv_private *ctrlpriv)
+{
+	int ret = 0;
+	struct device_node *np;
+	u32 idx, status;
+
+	ctrlpriv->has_seco = true;
+	/*
+	 * For imx8 page size is 64k, we can't access ctrl regs to dynamically
+	 * obtain this info.
+	 */
+	ret = enable_jobrings(ctrlpriv, PG_SIZE_64K);
+	if (ret)
+		return ret;
+	if (!ctrlpriv->total_jobrs) {
+		dev_err(ctrlpriv->dev, "no job rings configured!\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Read first job ring index for aliased registers
+	 */
+	if (read_first_jr_index(ctrlpriv)) {
+		dev_err(ctrlpriv->dev, "missing first job ring index!\n");
+		return -ENODEV;
+	}
+	idx = ctrlpriv->first_jr_index;
+	status = rd_reg32(&ctrlpriv->jr[idx]->perfmon.status);
+	caam_little_end = !(bool)(status & (CSTA_PLEND | CSTA_ALT_PLEND));
+	ctrlpriv->assure = ((struct caam_assurance __force *)
+			    ((uint8_t *)ctrlpriv->ctrl +
+			     PG_SIZE_64K * ASSURE_BLOCK_NUMBER));
+	ctrlpriv->deco = ((struct caam_deco __force *)
+			  ((uint8_t *)ctrlpriv->ctrl +
+			   PG_SIZE_64K * DECO_BLOCK_NUMBER));
+
+	ctrlpriv->era = caam_get_era(ctrl);
+
+	/* Get CAAM-SM node and of_iomap() and save */
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-caam-sm");
+	if (!np) {
+		dev_warn(ctrlpriv->dev, "No CAAM-SM node found!\n");
+		return -ENODEV;
+	}
+
+	ctrlpriv->sm_base = of_iomap(np, 0);
+	ctrlpriv->sm_size = 0x3fff;
+
+	/* Can't enable DECO WD and LPs those are in MCR */
+
+	/*
+	 * can't check for virtualization because we need access to SCFGR for it
+	 */
+
+	/* Set DMA masks according to platform ranging */
+	if (sizeof(dma_addr_t) == sizeof(u64))
+		if (of_device_is_compatible(ctrlpriv->pdev->dev.of_node,
+					    "fsl,sec-v5.0"))
+			dma_set_mask_and_coherent(ctrlpriv->dev,
+						  DMA_BIT_MASK(40));
+		else
+			dma_set_mask_and_coherent(ctrlpriv->dev,
+						  DMA_BIT_MASK(36));
+	else
+		dma_set_mask_and_coherent(ctrlpriv->dev, DMA_BIT_MASK(32));
+
+	/*
+	 * this is where we should run the descriptor for DRNG init
+	 * TRNG must be initialized by SECO
+	 */
+	return ret;
+}
+
+/* Probe routine for CAAM top (controller) level */
+static int caam_probe(struct platform_device *pdev)
+{
+	int ret;
+	u64 caam_id;
+	static const struct soc_device_attribute imx_soc[] = {
+		{.family = "Freescale i.MX"},
+		{},
+	};
+	struct device *dev;
+	struct device_node *nprop, *np;
+	struct caam_ctrl __iomem *ctrl;
+	struct caam_drv_private *ctrlpriv;
+
+	u32 comp_params;
+	u32 cha_vid_ls;
+	int pg_size;
+	int block_offset = 0;
+
+	ctrlpriv = devm_kzalloc(&pdev->dev, sizeof(*ctrlpriv), GFP_KERNEL);
+	if (!ctrlpriv)
+		return -ENOMEM;
+
+	dev = &pdev->dev;
+	dev_set_drvdata(dev, ctrlpriv);
+	ctrlpriv->dev = dev;
+	ctrlpriv->pdev = pdev;
+	nprop = pdev->dev.of_node;
+
+	caam_imx = (bool)soc_device_match(imx_soc);
+
+	if (!of_machine_is_compatible("fsl,imx8mq") &&
+	     !of_machine_is_compatible("fsl,imx8qm") &&
+	     !of_machine_is_compatible("fsl,imx8qxp")) {
+		ret = init_clocks(ctrlpriv);
+		if (ret)
+			goto disable_clocks;
 	}
 
 	/* Get configuration properties from device tree */
@@ -303,9 +610,21 @@ static int caam_probe(struct platform_device *pdev)
 	if (ctrl == NULL) {
 		dev_err(dev, "caam: of_iomap() failed\n");
 		ret = -ENOMEM;
-		goto disable_caam_emi_slow;
+		goto disable_clocks;
+	}
+
+	ctrlpriv->ctrl = (struct caam_ctrl __force *)ctrl;
+
+	if (of_machine_is_compatible("fsl,imx8qm") ||
+		 of_machine_is_compatible("fsl,imx8qxp")) {
+		ret = probe_w_seco(ctrlpriv);
+		if (ret)
+			goto iounmap_ctrl;
+		return ret;
 	}
 
+	ctrlpriv->has_seco = false;
+
 	caam_little_end = !(bool)(rd_reg32(&ctrl->perfmon.status) &
 				  (CSTA_PLEND | CSTA_ALT_PLEND));
 
@@ -313,32 +632,36 @@ static int caam_probe(struct platform_device *pdev)
 	comp_params = rd_reg32(&ctrl->perfmon.comp_parms_ms);
 	pg_size = (comp_params & CTPR_MS_PG_SZ_MASK) >> CTPR_MS_PG_SZ_SHIFT;
 
-	/* Allocating the BLOCK_OFFSET based on the supported page size on
+	/* Allocating the block_offset based on the supported page size on
 	 * the platform
 	 */
 	if (pg_size == 0)
-		BLOCK_OFFSET = PG_SIZE_4K;
+		block_offset = PG_SIZE_4K;
 	else
-		BLOCK_OFFSET = PG_SIZE_64K;
-
-	ctrlpriv->ctrl = (struct caam_ctrl __iomem __force *)ctrl;
-	ctrlpriv->assure = (struct caam_assurance __iomem __force *)
-			   ((__force uint8_t *)ctrl +
-			    BLOCK_OFFSET * ASSURE_BLOCK_NUMBER
-			   );
-	ctrlpriv->deco = (struct caam_deco __iomem __force *)
-			 ((__force uint8_t *)ctrl +
-			 BLOCK_OFFSET * DECO_BLOCK_NUMBER
-			 );
+		block_offset = PG_SIZE_64K;
+
+	ctrlpriv->assure = (struct caam_assurance __force *)
+			   ((uint8_t *)ctrl +
+			    block_offset * ASSURE_BLOCK_NUMBER);
+	ctrlpriv->deco = (struct caam_deco __force *)
+			 ((uint8_t *)ctrl +
+			 block_offset * DECO_BLOCK_NUMBER);
 
 	/* Get CAAM-SM node and of_iomap() and save */
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-caam-sm");
-
-	if (!np)
-		return -ENODEV;
+	if (!np) {
+		ret = -ENODEV;
+		goto disable_clocks;
+	}
 
 	ctrlpriv->sm_base = of_iomap(np, 0);
-	ctrlpriv->sm_size = 0x3fff;
+	if (!of_machine_is_compatible("fsl,imx8mq") &&
+		!of_machine_is_compatible("fsl,imx8qm") &&
+		!of_machine_is_compatible("fsl,imx8qxp")) {
+		ctrlpriv->sm_size = 0x3fff;
+	} else {
+		ctrlpriv->sm_size = PG_SIZE_64K;
+	}
 
 	/*
 	 * Enable DECO watchdogs and, if this is a PHYS_ADDR_T_64BIT kernel,
@@ -358,31 +681,11 @@ static int caam_probe(struct platform_device *pdev)
 			      (sizeof(dma_addr_t) == sizeof(u64) ?
 			       MCFGR_LONG_PTR : 0));
 
-	/*
-	 *  Read the Compile Time paramters and SCFGR to determine
-	 * if Virtualization is enabled for this platform
-	 */
-	scfgr = rd_reg32(&ctrl->scfgr);
+	ctrlpriv->era = caam_get_era(ctrl);
 
-	ctrlpriv->virt_en = 0;
-	if (comp_params & CTPR_MS_VIRT_EN_INCL) {
-		/* VIRT_EN_INCL = 1 & VIRT_EN_POR = 1 or
-		 * VIRT_EN_INCL = 1 & VIRT_EN_POR = 0 & SCFGR_VIRT_EN = 1
-		 */
-		if ((comp_params & CTPR_MS_VIRT_EN_POR) ||
-		    (!(comp_params & CTPR_MS_VIRT_EN_POR) &&
-		       (scfgr & SCFGR_VIRT_EN)))
-				ctrlpriv->virt_en = 1;
-	} else {
-		/* VIRT_EN_INCL = 0 && VIRT_EN_POR_VALUE = 1 */
-		if (comp_params & CTPR_MS_VIRT_EN_POR)
-				ctrlpriv->virt_en = 1;
-	}
+	handle_imx6_err005766(ctrlpriv);
 
-	if (ctrlpriv->virt_en == 1)
-		clrsetbits_32(&ctrl->jrstart, 0, JRSTART_JR0_START |
-			      JRSTART_JR1_START | JRSTART_JR2_START |
-			      JRSTART_JR3_START);
+	check_virt(ctrlpriv, comp_params);
 
 	if (sizeof(dma_addr_t) == sizeof(u64)) {
 		if (caam_dpaa2)
@@ -399,58 +702,11 @@ static int caam_probe(struct platform_device *pdev)
 		goto iounmap_ctrl;
 	}
 
-	ctrlpriv->era = caam_get_era(ctrl);
-
-	handle_imx6_err005766(ctrlpriv);
-
-	ret = of_platform_populate(nprop, caam_match, NULL, dev);
-	if (ret) {
-		dev_err(dev, "JR platform devices creation error\n");
+	ret = enable_jobrings(ctrlpriv, block_offset);
+	if (ret)
 		goto iounmap_ctrl;
-	}
-
-#ifdef CONFIG_DEBUG_FS
-	/*
-	 * FIXME: needs better naming distinction, as some amalgamation of
-	 * "caam" and nprop->full_name. The OF name isn't distinctive,
-	 * but does separate instances
-	 */
-	perfmon = (struct caam_perfmon __force *)&ctrl->perfmon;
 
-	ctrlpriv->dfs_root = debugfs_create_dir(dev_name(dev), NULL);
-	ctrlpriv->ctl = debugfs_create_dir("ctl", ctrlpriv->dfs_root);
-#endif
-
-	ring = 0;
-	for_each_available_child_of_node(nprop, np)
-		if (of_device_is_compatible(np, "fsl,sec-v4.0-job-ring") ||
-		    of_device_is_compatible(np, "fsl,sec4.0-job-ring")) {
-			ctrlpriv->jr[ring] = (struct caam_job_ring __iomem __force *)
-					     ((__force uint8_t *)ctrl +
-					     (ring + JR_BLOCK_NUMBER) *
-					      BLOCK_OFFSET
-					     );
-			ctrlpriv->total_jobrs++;
-			ring++;
-		}
-
-	/* Check to see if (DPAA 1.x) QI present. If so, enable */
-	ctrlpriv->qi_present = !!(comp_params & CTPR_MS_QI_MASK);
-	if (ctrlpriv->qi_present && !caam_dpaa2) {
-		ctrlpriv->qi = (struct caam_queue_if __iomem __force *)
-			       ((__force uint8_t *)ctrl +
-				 BLOCK_OFFSET * QI_BLOCK_NUMBER
-			       );
-		/* This is all that's required to physically enable QI */
-		wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_DQEN);
-
-		/* If QMAN driver is present, init CAAM-QI backend */
-#ifdef CONFIG_CAAM_QI
-		ret = caam_qi_init(pdev);
-		if (ret)
-			dev_err(dev, "caam qi i/f init failed: %d\n", ret);
-#endif
-	}
+	enable_qi(ctrlpriv, block_offset);
 
 	/* If no QI and no rings specified, quit and go home */
 	if ((!ctrlpriv->qi_present) && (!ctrlpriv->total_jobrs)) {
@@ -459,74 +715,6 @@ static int caam_probe(struct platform_device *pdev)
 		goto caam_remove;
 	}
 
-	cha_vid_ls = rd_reg32(&ctrl->perfmon.cha_id_ls);
-
-	/*
-	 * If SEC has RNG version >= 4 and RNG state handle has not been
-	 * already instantiated, do RNG instantiation
-	 * In case of SoCs with Management Complex, RNG is managed by MC f/w.
-	 */
-	if (!ctrlpriv->mc_en &&
-	    (cha_vid_ls & CHA_ID_LS_RNG_MASK) >> CHA_ID_LS_RNG_SHIFT >= 4) {
-		ctrlpriv->rng4_sh_init =
-			rd_reg32(&ctrl->r4tst[0].rdsta);
-		/*
-		 * If the secure keys (TDKEK, JDKEK, TDSK), were already
-		 * generated, signal this to the function that is instantiating
-		 * the state handles. An error would occur if RNG4 attempts
-		 * to regenerate these keys before the next POR.
-		 */
-		gen_sk = ctrlpriv->rng4_sh_init & RDSTA_SKVN ? 0 : 1;
-		ctrlpriv->rng4_sh_init &= RDSTA_IFMASK;
-		do {
-			int inst_handles =
-				rd_reg32(&ctrl->r4tst[0].rdsta) &
-								RDSTA_IFMASK;
-			/*
-			 * If either SH were instantiated by somebody else
-			 * (e.g. u-boot) then it is assumed that the entropy
-			 * parameters are properly set and thus the function
-			 * setting these (kick_trng(...)) is skipped.
-			 * Also, if a handle was instantiated, do not change
-			 * the TRNG parameters.
-			 */
-			if (!(ctrlpriv->rng4_sh_init || inst_handles)) {
-				dev_info(dev,
-					 "Entropy delay = %u\n",
-					 ent_delay);
-				kick_trng(pdev, ent_delay);
-				ent_delay += 400;
-			}
-			/*
-			 * if instantiate_rng(...) fails, the loop will rerun
-			 * and the kick_trng(...) function will modfiy the
-			 * upper and lower limits of the entropy sampling
-			 * interval, leading to a sucessful initialization of
-			 * the RNG.
-			 */
-			ret = instantiate_rng(dev, inst_handles,
-					      gen_sk);
-			if (ret == -EAGAIN)
-				/*
-				 * if here, the loop will rerun,
-				 * so don't hog the CPU
-				 */
-				cpu_relax();
-		} while ((ret == -EAGAIN) && (ent_delay < RTSDCTL_ENT_DLY_MAX));
-		if (ret) {
-			dev_err(dev, "failed to instantiate RNG");
-			goto caam_remove;
-		}
-		/*
-		 * Set handles init'ed by this module as the complement of the
-		 * already initialized ones
-		 */
-		ctrlpriv->rng4_sh_init = ~ctrlpriv->rng4_sh_init & RDSTA_IFMASK;
-
-		/* Enable RDB bit so that RNG works faster */
-		clrsetbits_32(&ctrl->scfgr, 0, SCFGR_RDBENABLE);
-	}
-
 	/* NOTE: RTIC detection ought to go here, around Si time */
 
 	caam_id = (u64)rd_reg32(&ctrl->perfmon.caam_id_ms) << 32 |
@@ -538,65 +726,14 @@ static int caam_probe(struct platform_device *pdev)
 	dev_info(dev, "job rings = %d, qi = %d\n",
 		 ctrlpriv->total_jobrs, ctrlpriv->qi_present);
 
-#ifdef CONFIG_DEBUG_FS
-	debugfs_create_file("rq_dequeued", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->req_dequeued,
-			    &caam_fops_u64_ro);
-	debugfs_create_file("ob_rq_encrypted", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->ob_enc_req,
-			    &caam_fops_u64_ro);
-	debugfs_create_file("ib_rq_decrypted", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->ib_dec_req,
-			    &caam_fops_u64_ro);
-	debugfs_create_file("ob_bytes_encrypted", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->ob_enc_bytes,
-			    &caam_fops_u64_ro);
-	debugfs_create_file("ob_bytes_protected", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->ob_prot_bytes,
-			    &caam_fops_u64_ro);
-	debugfs_create_file("ib_bytes_decrypted", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->ib_dec_bytes,
-			    &caam_fops_u64_ro);
-	debugfs_create_file("ib_bytes_validated", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->ib_valid_bytes,
-			    &caam_fops_u64_ro);
-
-	/* Controller level - global status values */
-	debugfs_create_file("fault_addr", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->faultaddr,
-			    &caam_fops_u32_ro);
-	debugfs_create_file("fault_detail", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->faultdetail,
-			    &caam_fops_u32_ro);
-	debugfs_create_file("fault_status", S_IRUSR | S_IRGRP | S_IROTH,
-			    ctrlpriv->ctl, &perfmon->status,
-			    &caam_fops_u32_ro);
-
-	/* Internal covering keys (useful in non-secure mode only) */
-	ctrlpriv->ctl_kek_wrap.data = (__force void *)&ctrlpriv->ctrl->kek[0];
-	ctrlpriv->ctl_kek_wrap.size = KEK_KEY_SIZE * sizeof(u32);
-	ctrlpriv->ctl_kek = debugfs_create_blob("kek",
-						S_IRUSR |
-						S_IRGRP | S_IROTH,
-						ctrlpriv->ctl,
-						&ctrlpriv->ctl_kek_wrap);
+	dev_info(dev, "device ID = 0x%016llx (Era %d)\n"
+			"job rings = %d, qi = %d\n",
+			caam_id,
+			ctrlpriv->era,
+			ctrlpriv->total_jobrs, ctrlpriv->qi_present);
 
-	ctrlpriv->ctl_tkek_wrap.data = (__force void *)&ctrlpriv->ctrl->tkek[0];
-	ctrlpriv->ctl_tkek_wrap.size = KEK_KEY_SIZE * sizeof(u32);
-	ctrlpriv->ctl_tkek = debugfs_create_blob("tkek",
-						 S_IRUSR |
-						 S_IRGRP | S_IROTH,
-						 ctrlpriv->ctl,
-						 &ctrlpriv->ctl_tkek_wrap);
+	init_debugfs(ctrlpriv);
 
-	ctrlpriv->ctl_tdsk_wrap.data = (__force void *)&ctrlpriv->ctrl->tdsk[0];
-	ctrlpriv->ctl_tdsk_wrap.size = KEK_KEY_SIZE * sizeof(u32);
-	ctrlpriv->ctl_tdsk = debugfs_create_blob("tdsk",
-						 S_IRUSR |
-						 S_IRGRP | S_IROTH,
-						 ctrlpriv->ctl,
-						 &ctrlpriv->ctl_tdsk_wrap);
-#endif
 	return 0;
 
 caam_remove:
@@ -605,19 +742,32 @@ static int caam_probe(struct platform_device *pdev)
 
 iounmap_ctrl:
 	iounmap(ctrl);
-disable_caam_emi_slow:
-	if (ctrlpriv->caam_emi_slow)
-		clk_disable_unprepare(ctrlpriv->caam_emi_slow);
-disable_caam_aclk:
-	clk_disable_unprepare(ctrlpriv->caam_aclk);
-disable_caam_mem:
-	if (ctrlpriv->caam_mem)
-		clk_disable_unprepare(ctrlpriv->caam_mem);
-disable_caam_ipg:
-	clk_disable_unprepare(ctrlpriv->caam_ipg);
+disable_clocks:
+	if (!of_machine_is_compatible("fsl,imx8mq") &&
+		!of_machine_is_compatible("fsl,imx8qm") &&
+		!of_machine_is_compatible("fsl,imx8qxp")) {
+		if (ctrlpriv->caam_emi_slow)
+			clk_disable_unprepare(ctrlpriv->caam_emi_slow);
+		clk_disable_unprepare(ctrlpriv->caam_aclk);
+		if (ctrlpriv->caam_mem)
+			clk_disable_unprepare(ctrlpriv->caam_mem);
+		clk_disable_unprepare(ctrlpriv->caam_ipg);
+	}
+
 	return ret;
 }
 
+static const struct of_device_id caam_match[] = {
+	{
+		.compatible = "fsl,sec-v4.0",
+	},
+	{
+		.compatible = "fsl,sec4.0",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, caam_match);
+
 static struct platform_driver caam_driver = {
 	.driver = {
 		.name = "caam",
diff --git a/drivers/crypto/caam/desc_constr.h b/drivers/crypto/caam/desc_constr.h
index d4256fa..6094e60 100644
--- a/drivers/crypto/caam/desc_constr.h
+++ b/drivers/crypto/caam/desc_constr.h
@@ -2,7 +2,7 @@
 /*
  * caam descriptor construction helper functions
  *
- * Copyright 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright 2008-2017 Freescale Semiconductor, Inc.
  */
 
 #ifndef DESC_CONSTR_H
@@ -13,7 +13,8 @@
 
 #define IMMEDIATE (1 << 23)
 #define CAAM_CMD_SZ sizeof(u32)
-#define CAAM_PTR_SZ sizeof(dma_addr_t)
+/* CAAM Pointer Size in MCFGR[PS] is 0 by default (32bits) */
+#define CAAM_PTR_SZ sizeof(u32)
 #define CAAM_DESC_BYTES_MAX (CAAM_CMD_SZ * MAX_CAAM_DESCSIZE)
 #define DESC_JOB_IO_LEN (CAAM_CMD_SZ * 5 + CAAM_PTR_SZ * 3)
 
@@ -90,9 +91,10 @@ static inline void init_job_desc_pdb(u32 * const desc, u32 options,
 	init_job_desc(desc, (((pdb_len + 1) << HDR_START_IDX_SHIFT)) | options);
 }
 
-static inline void append_ptr(u32 * const desc, dma_addr_t ptr)
+static inline void append_ptr(u32 * const desc, u32 ptr)
+
 {
-	dma_addr_t *offset = (dma_addr_t *)desc_end(desc);
+	u32 *offset = (u32 *)desc_end(desc);
 
 	*offset = cpu_to_caam_dma(ptr);
 
@@ -100,7 +102,7 @@ static inline void append_ptr(u32 * const desc, dma_addr_t ptr)
 				CAAM_PTR_SZ / CAAM_CMD_SZ);
 }
 
-static inline void init_job_desc_shared(u32 * const desc, dma_addr_t ptr,
+static inline void init_job_desc_shared(u32 * const desc, u32 ptr,
 					int len, u32 options)
 {
 	PRINT_POS;
@@ -155,7 +157,7 @@ static inline u32 *write_cmd(u32 * const desc, u32 command)
 	return desc + 1;
 }
 
-static inline void append_cmd_ptr(u32 * const desc, dma_addr_t ptr, int len,
+static inline void append_cmd_ptr(u32 * const desc, u32 ptr, int len,
 				  u32 command)
 {
 	append_cmd(desc, command | len);
@@ -163,7 +165,7 @@ static inline void append_cmd_ptr(u32 * const desc, dma_addr_t ptr, int len,
 }
 
 /* Write length after pointer, rather than inside command */
-static inline void append_cmd_ptr_extlen(u32 * const desc, dma_addr_t ptr,
+static inline void append_cmd_ptr_extlen(u32 * const desc, u32 ptr,
 					 unsigned int len, u32 command)
 {
 	append_cmd(desc, command);
@@ -227,7 +229,7 @@ static inline void set_move_tgt_here(u32 * const desc, u32 *move_cmd)
 APPEND_CMD_LEN(seq_fifo_store, SEQ_FIFO_STORE)
 
 #define APPEND_CMD_PTR(cmd, op) \
-static inline void append_##cmd(u32 * const desc, dma_addr_t ptr, \
+static inline void append_##cmd(u32 * const desc, u32 ptr, \
 				unsigned int len, u32 options) \
 { \
 	PRINT_POS; \
@@ -238,7 +240,7 @@ static inline void set_move_tgt_here(u32 * const desc, u32 *move_cmd)
 APPEND_CMD_PTR(fifo_load, FIFO_LOAD)
 APPEND_CMD_PTR(fifo_store, FIFO_STORE)
 
-static inline void append_store(u32 * const desc, dma_addr_t ptr,
+static inline void append_store(u32 * const desc, u32 ptr,
 				unsigned int len, u32 options)
 {
 	u32 cmd_src;
@@ -257,7 +259,7 @@ static inline void append_store(u32 * const desc, dma_addr_t ptr,
 
 #define APPEND_SEQ_PTR_INTLEN(cmd, op) \
 static inline void append_seq_##cmd##_ptr_intlen(u32 * const desc, \
-						 dma_addr_t ptr, \
+						 u32 ptr, \
 						 unsigned int len, \
 						 u32 options) \
 { \
@@ -281,7 +283,7 @@ static inline void append_store(u32 * const desc, dma_addr_t ptr,
 APPEND_CMD_PTR_TO_IMM(fifo_load, FIFO_LOAD);
 
 #define APPEND_CMD_PTR_EXTLEN(cmd, op) \
-static inline void append_##cmd##_extlen(u32 * const desc, dma_addr_t ptr, \
+static inline void append_##cmd##_extlen(u32 * const desc, u32 ptr, \
 					 unsigned int len, u32 options) \
 { \
 	PRINT_POS; \
@@ -295,7 +297,7 @@ static inline void append_store(u32 * const desc, dma_addr_t ptr,
  * the size of its type
  */
 #define APPEND_CMD_PTR_LEN(cmd, op, type) \
-static inline void append_##cmd(u32 * const desc, dma_addr_t ptr, \
+static inline void append_##cmd(u32 * const desc, u32 ptr, \
 				type len, u32 options) \
 { \
 	PRINT_POS; \
@@ -451,7 +453,7 @@ struct alginfo {
 	unsigned int keylen;
 	unsigned int keylen_pad;
 	union {
-		dma_addr_t key_dma;
+		caam_dma_addr_t key_dma;
 		const void *key_virt;
 	};
 	bool key_inline;
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index 3c890d9..3d49ade 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -3,7 +3,7 @@
  * CAAM/SEC 4.x driver backend
  * Private/internal definitions between modules
  *
- * Copyright 2008-2011 Freescale Semiconductor, Inc.
+ * Copyright 2008-2017 Freescale Semiconductor, Inc.
  *
  */
 
@@ -13,6 +13,9 @@
 /* Currently comes from Kconfig param as a ^2 (driver-required) */
 #define JOBR_DEPTH (1 << CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE)
 
+/* Job ring count */
+#define JOBR_MAX_COUNT 4
+
 /* Kconfig params for interrupt coalescing if selected (else zero) */
 #ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_INTC
 #define JOBR_INTC JRCFG_ICEN
@@ -32,7 +35,8 @@ struct caam_jrentry_info {
 	void (*callbk)(struct device *dev, u32 *desc, u32 status, void *arg);
 	void *cbkarg;	/* Argument per ring entry */
 	u32 *desc_addr_virt;	/* Stored virt addr for postprocessing */
-	dma_addr_t desc_addr_dma;	/* Stored bus addr for done matching */
+	/* CAAM Pointer Size in MCFGR[PS] is 0 by default (32bits) */
+	u32 desc_addr_dma;	/* Stored bus addr for done matching */
 	u32 desc_size;	/* Stored size for postprocessing, header derived */
 };
 
@@ -54,7 +58,8 @@ struct caam_drv_private_jr {
 	spinlock_t inplock ____cacheline_aligned; /* Input ring index lock */
 	int inp_ring_write_index;	/* Input index "tail" */
 	int head;			/* entinfo (s/w ring) head index */
-	dma_addr_t *inpring;	/* Base of input ring, alloc DMA-safe */
+	/* CAAM Pointer Size in MCFGR[PS] is 0 by default (32bits) */
+	u32 *inpring;	/* Base of input ring, alloc DMA-safe */
 	spinlock_t outlock ____cacheline_aligned; /* Output ring index lock */
 	int out_ring_read_index;	/* Output index "tail" */
 	int tail;			/* entinfo (s/w ring) tail index */
@@ -68,7 +73,8 @@ struct caam_drv_private {
 #ifdef CONFIG_CAAM_QI
 	struct device *qidev;
 #endif
-
+	struct device *dev;
+	struct platform_device *pdev;
 	struct device *smdev;
 
 	/*
@@ -83,7 +89,8 @@ struct caam_drv_private {
 	struct caam_deco __iomem *deco; /* DECO/CCB views */
 	struct caam_assurance __iomem *assure;
 	struct caam_queue_if __iomem *qi; /* QI control region */
-	struct caam_job_ring __iomem *jr[4];	/* JobR's register space */
+	/* JobR's register space */
+	struct caam_job_ring __iomem *jr[JOBR_MAX_COUNT];
 	dma_addr_t __iomem *sm_base;	/* Secure memory storage base */
 	u32 sm_size;
 
@@ -108,6 +115,8 @@ struct caam_drv_private {
 	struct clk *caam_aclk;
 	struct clk *caam_emi_slow;
 
+	bool has_seco;
+	u32 first_jr_index;
 	/*
 	 * debugfs entries for developer view into driver/device
 	 * variables at runtime.
@@ -115,6 +124,11 @@ struct caam_drv_private {
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dfs_root;
 	struct dentry *ctl; /* controller dir */
+	struct dentry *ctl_rq_dequeued, *ctl_ob_enc_req, *ctl_ib_dec_req;
+	struct dentry *ctl_ob_enc_bytes, *ctl_ob_prot_bytes;
+	struct dentry *ctl_ib_dec_bytes, *ctl_ib_valid_bytes;
+	struct dentry *ctl_faultaddr, *ctl_faultdetail, *ctl_faultstatus;
+
 	struct debugfs_blob_wrapper ctl_kek_wrap, ctl_tkek_wrap, ctl_tdsk_wrap;
 	struct dentry *ctl_kek, *ctl_tkek, *ctl_tdsk;
 #endif
diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index 88d66f4..1d667e5 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -2,7 +2,7 @@
  * CAAM/SEC 4.x transport/backend driver
  * JobR backend functionality
  *
- * Copyright 2008-2015 Freescale Semiconductor, Inc.
+ * Copyright 2008-2017 Freescale Semiconductor, Inc.
  */
 
 #include <linux/of_irq.h>
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index a210f79..adeec34 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -2,7 +2,7 @@
 /*
  * CAAM hardware register-level view
  *
- * Copyright 2008-2011 Freescale Semiconductor, Inc.
+ * Copyright 2008-2017 Freescale Semiconductor, Inc.
  */
 
 #ifndef REGS_H
@@ -136,7 +136,7 @@ static inline void clrsetbits_32(void __iomem *reg, u32 clear, u32 set)
  *    base + 0x0000 : least-significant 32 bits
  *    base + 0x0004 : most-significant 32 bits
  */
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !(defined(CONFIG_HAVE_IMX8_SOC))
 static inline void wr_reg64(void __iomem *reg, u64 data)
 {
 	if (caam_little_end)
@@ -194,7 +194,7 @@ static inline u64 caam_dma64_to_cpu(u64 value)
 	return caam64_to_cpu(value);
 }
 
-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
+#if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT) && !defined(CONFIG_HAVE_IMX8_SOC)
 #define cpu_to_caam_dma(value) cpu_to_caam_dma64(value)
 #define caam_dma_to_cpu(value) caam_dma64_to_cpu(value)
 #else
@@ -207,7 +207,8 @@ static inline u64 caam_dma64_to_cpu(u64 value)
  * Represents each entry in a JobR output ring
  */
 struct jr_outentry {
-	dma_addr_t desc;/* Pointer to completed descriptor */
+	/* CAAM Pointer Size in MCFGR[PS] is 0 by default (32bits) */
+	u32 desc;/* Pointer to completed descriptor */
 	u32 jrstatus;	/* Status for completed descriptor */
 } __packed;
 
-- 
1.7.9.5


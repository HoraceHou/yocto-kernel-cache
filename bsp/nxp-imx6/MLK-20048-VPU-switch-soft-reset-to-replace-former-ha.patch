From f600d3ce1ffb15754839565256f6d88806cd7f3d Mon Sep 17 00:00:00 2001
From: Huang Chaofan <chaofan.huang@nxp.com>
Date: Wed, 24 Oct 2018 15:47:24 +0800
Subject: [PATCH 4940/5242] MLK-20048 VPU: switch soft reset to replace former
 hard reset in the vpu decoder driver

commit  b2d3211d1dce3478a62228a77f2dbfcfdda76a87 from
https://source.codeaurora.org/external/imx/linux-imx.git

switch soft reset to replace former hard reset in the vpu decoder driver
when all instance hang

Signed-off-by: Huang Chaofan <chaofan.huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mxc/vpu-decoder-b0/mediasys_types.h |    3 +
 drivers/mxc/vpu-decoder-b0/vpu_b0.c         |  147 ++++++++++-----------------
 2 files changed, 56 insertions(+), 94 deletions(-)
 mode change 100755 => 100644 drivers/mxc/vpu-decoder-b0/Kconfig
 mode change 100755 => 100644 drivers/mxc/vpu-decoder-b0/vpu_b0.c
 mode change 100755 => 100644 drivers/mxc/vpu-decoder-b0/vpu_b0.h

diff --git a/drivers/mxc/vpu-decoder-b0/Kconfig b/drivers/mxc/vpu-decoder-b0/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/mxc/vpu-decoder-b0/mediasys_types.h b/drivers/mxc/vpu-decoder-b0/mediasys_types.h
index aae9fe5..921d79e 100644
--- a/drivers/mxc/vpu-decoder-b0/mediasys_types.h
+++ b/drivers/mxc/vpu-decoder-b0/mediasys_types.h
@@ -161,6 +161,9 @@
 	VID_API_CMD_DBG_DUMP_LOG      = 0x1F,
 	/* Begin Encode CMDs */
 	VID_API_CMD_YUV_READY         = 0x20,
+
+	VID_API_CMD_FIRM_RESET        = 0x40,
+
 #if BOOT_ARCH == REBOOT
 	VID_API_CMD_SNAPSHOT          = 0xAA,
 	VID_API_CMD_ROLL_SNAPSHOT     = 0xAB,
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.c b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
old mode 100755
new mode 100644
index 057acae..76f8f68
--- a/drivers/mxc/vpu-decoder-b0/vpu_b0.c
+++ b/drivers/mxc/vpu-decoder-b0/vpu_b0.c
@@ -61,7 +61,7 @@
 static void v4l2_vpu_send_cmd(struct vpu_ctx *ctx, uint32_t idx, uint32_t cmdid, uint32_t cmdnum, uint32_t *local_cmddata);
 static bool add_scode(struct vpu_ctx *ctx, u_int32 uStrBufIdx, VPU_PADDING_SCODE_TYPE eScodeType);
 static void v4l2_update_stream_addr(struct vpu_ctx *ctx, uint32_t uStrBufIdx);
-static int reset_vpu_firmware(struct vpu_dev *dev);
+static int swreset_vpu_firmware(struct vpu_dev *dev);
 
 static char *cmd2str[] = {
 	"VID_API_CMD_NULL",   /*0x0*/
@@ -2031,6 +2031,9 @@ static irqreturn_t fsl_vpu_mu_isr(int irq, void *This)
 
 	MU_ReceiveMsg(dev->mu_base_virtaddr, 0, &msg);
 	if (msg == 0xaa) {
+		rpc_init_shared_memory(&dev->shared_mem, dev->m0_rpc_phy - dev->m0_p_fw_space_phy, dev->m0_rpc_virt, SHARED_SIZE);
+		rpc_set_system_cfg_value(dev->shared_mem.pSharedInterface, VPU_REG_BASE);
+
 		MU_sendMesgToFW(dev->mu_base_virtaddr, PRINT_BUF_OFFSET, dev->m0_rpc_phy - dev->m0_p_fw_space_phy + M0_PRINT_OFFSET);
 		MU_sendMesgToFW(dev->mu_base_virtaddr, RPC_BUF_OFFSET, dev->m0_rpc_phy - dev->m0_p_fw_space_phy); //CM0 use relative address
 		MU_sendMesgToFW(dev->mu_base_virtaddr, BOOT_ADDRESS, dev->m0_p_fw_space_phy);
@@ -2094,6 +2097,22 @@ static int vpu_mu_init(struct vpu_dev *dev)
 	return ret;
 }
 
+static int release_hang_instance(struct vpu_dev *dev)
+{
+	u_int32 i;
+
+	if (!dev)
+		return -EINVAL;
+
+	for (i = 0; i < VPU_MAX_NUM_STREAMS; i++)
+		if (!dev->ctx[i]) {
+			kfree(dev->ctx[i]);
+			dev->ctx[i] = NULL;
+		}
+
+	return 0;
+}
+
 /*
  * Add judge to find if it has available path to decode, if all
  * path hang, reset vpu and then get one index
@@ -2112,7 +2131,8 @@ static int vpu_next_free_instance(struct vpu_dev *dev)
 	if (count == VPU_MAX_NUM_STREAMS) {
 		dev->hang_mask = 0;
 		dev->instance_mask = 0;
-		reset_vpu_firmware(dev);
+		swreset_vpu_firmware(dev);
+		release_hang_instance(dev);
 	}
 
 	idx = ffz(dev->instance_mask);
@@ -2811,13 +2831,15 @@ static int v4l2_release(struct file *filp)
 	mutex_unlock(&ctx->instance_mutex);
 	ctx->stream_buffer_virt = NULL;
 	mutex_lock(&dev->dev_mutex);
-	if (!(dev->hang_mask & (1 << ctx->str_index))) // judge the path is hang or not, if hang, don't clear
-		clear_bit(ctx->str_index, &dev->instance_mask);
-	dev->ctx[ctx->str_index] = NULL;
 	mutex_unlock(&dev->dev_mutex);
 
 	pm_runtime_put_sync(ctx->dev->generic_dev);
-	kfree(ctx);
+
+	if (!(dev->hang_mask & (1 << ctx->str_index))) { // judge the path is hang or not, if hang, don't clear
+		clear_bit(ctx->str_index, &dev->instance_mask);
+		dev->ctx[ctx->str_index] = NULL;
+		kfree(ctx);
+	}
 	return 0;
 }
 
@@ -2901,78 +2923,6 @@ static int v4l2_mmap(struct file *filp, struct vm_area_struct *vma)
 	.ioctl_ops = &v4l2_decoder_ioctl_ops,
 	.vfl_dir = VFL_DIR_M2M,
 };
-#if 1
-static int set_vpu_pwr(sc_ipc_t ipcHndl,
-		sc_pm_power_mode_t pm
-		)
-{
-	int rv = -1;
-	sc_err_t sciErr;
-
-	vpu_dbg(LVL_INFO, "%s()\n", __func__);
-	if (!ipcHndl) {
-		vpu_dbg(LVL_ERR, "error: --- set_vpu_pwr no IPC handle\n");
-		goto set_vpu_pwrexit;
-	}
-
-	// Power on or off DEC, ENC MU
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-#ifdef TEST_BUILD
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_DEC, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_DEC,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_ENC, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_ENC,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-#else
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_DEC_0, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_DEC_0,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_ENC_0, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_ENC_0,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-#endif
-	sciErr = sc_pm_set_resource_power_mode(ipcHndl, SC_R_VPU_MU_0, pm);
-	if (sciErr != SC_ERR_NONE) {
-		vpu_dbg(LVL_ERR, "error: --- sc_pm_set_resource_power_mode(SC_R_VPU_MU_0,%d) SCI error! (%d)\n", sciErr, pm);
-		goto set_vpu_pwrexit;
-	}
-
-	rv = 0;
-
-set_vpu_pwrexit:
-	return rv;
-}
-
-static void vpu_set_power(struct vpu_dev *dev, bool on)
-{
-	int ret;
-
-	if (on) {
-		ret = set_vpu_pwr(dev->mu_ipcHandle, SC_PM_PW_MODE_ON);
-		if (ret)
-			vpu_dbg(LVL_ERR, "error: failed to power on\n");
-		pm_runtime_get_sync(dev->generic_dev);
-	} else {
-		pm_runtime_put_sync_suspend(dev->generic_dev);
-		ret = set_vpu_pwr(dev->mu_ipcHandle, SC_PM_PW_MODE_OFF);
-		if (ret)
-			vpu_dbg(LVL_ERR, "error: failed to power off\n");
-	}
-}
-#endif
 
 static void vpu_setup(struct vpu_dev *This)
 {
@@ -3013,23 +2963,17 @@ static void vpu_disable_hw(struct vpu_dev *This)
 	vpu_reset(This);
 }
 
-static int reset_vpu_firmware(struct vpu_dev *dev)
+static int swreset_vpu_firmware(struct vpu_dev *dev)
 {
 	int ret = 0;
 
-	vpu_dbg(LVL_WARN, "RESET: reset_vpu_firmware\n");
-	vpu_set_power(dev, false);
-	usleep_range(1000, 1100);
-	vpu_set_power(dev, true);
-	dev->fw_is_ready = false;
+	vpu_dbg(LVL_WARN, "SWRESET: swreset_vpu_firmware\n");
 	dev->firmware_started = false;
-	vpu_enable_hw(dev);
 
-	rpc_init_shared_memory(&dev->shared_mem, dev->m0_rpc_phy - dev->m0_p_fw_space_phy, dev->m0_rpc_virt, SHARED_SIZE);
-	rpc_set_system_cfg_value(dev->shared_mem.pSharedInterface, VPU_REG_BASE);
+	v4l2_vpu_send_cmd(dev->ctx[0], 0, VID_API_CMD_FIRM_RESET, 0, NULL);
 
-	MU_Init(dev->mu_base_virtaddr);
-	MU_EnableRxFullInt(dev->mu_base_virtaddr, 0);
+	wait_for_completion(&dev->start_cmp);
+	dev->firmware_started = true;
 
 	return ret;
 }
@@ -3344,11 +3288,15 @@ static int vpu_runtime_resume(struct device *dev)
 
 #define CHECK_BIT(var, pos) (((var) >> (pos)) & 1)
 
-static void v4l2_vpu_send_snapshot(struct vpu_dev *dev)
+static int find_first_available_instance(struct vpu_dev *dev)
 {
-	int i = 0;
-	int strIdx = (~dev->hang_mask) & (dev->instance_mask);
-	/*figure out the first available instance*/
+	int strIdx, i;
+
+	if (!dev)
+		return -EINVAL;
+
+	strIdx = (~dev->hang_mask) & (dev->instance_mask);
+
 	for (i = 0; i < VPU_MAX_NUM_STREAMS; i++) {
 		if (CHECK_BIT(strIdx, i)) {
 			strIdx = i;
@@ -3356,7 +3304,18 @@ static void v4l2_vpu_send_snapshot(struct vpu_dev *dev)
 		}
 	}
 
-	v4l2_vpu_send_cmd(dev->ctx[strIdx], strIdx, VID_API_CMD_SNAPSHOT, 0, NULL);
+	return strIdx;
+}
+
+static void v4l2_vpu_send_snapshot(struct vpu_dev *dev)
+{
+	int strIdx;
+
+	strIdx = find_first_available_instance(dev);
+	if (strIdx > 0 && strIdx < VPU_MAX_NUM_STREAMS)
+		v4l2_vpu_send_cmd(dev->ctx[strIdx], strIdx, VID_API_CMD_SNAPSHOT, 0, NULL);
+	else
+		vpu_dbg(LVL_WARN, "warning: all path hang, need to reset\n");
 }
 
 static int vpu_suspend(struct device *dev)
diff --git a/drivers/mxc/vpu-decoder-b0/vpu_b0.h b/drivers/mxc/vpu-decoder-b0/vpu_b0.h
old mode 100755
new mode 100644
-- 
1.7.9.5


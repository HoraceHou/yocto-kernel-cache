From 970a8157589531495adad0ebca134d648770fc9b Mon Sep 17 00:00:00 2001
From: Mirela Rabulea <mirela.rabulea@nxp.com>
Date: Wed, 8 Aug 2018 17:45:02 +0300
Subject: [PATCH 4386/5242] MLK-18451: mxc-jpeg: Fix jpeg encoder output

commit  969e33a81bd569216c1b18c02dcecfd1cca84dfb from
https://source.codeaurora.org/external/imx/linux-imx.git

Use two chained descriptors for encoder (config desc & encode desc),
they are set-up in new function mxc_jpeg_config_enc_desc.

Refactor function mxc_jpeg_enc_config, in order for the encoder to
function correctly, the CAST_MODE register needs to be written after
the descriptor(s) are ready.

Set-up decoder descriptor in new function mxc_jpeg_config_dec_desc,
this was previously done in mxc_jpeg_device_run, which is
leaner & cleaner now.

Function mxc_jpeg_go cannot be used both for encoder and decoder, because
the CAST IP control registers are different, the decoder has CTRL
(offset 0x34) while the encoder has MODE register (offset 0x0).
So, have two functions instead: mxc_jpeg_go_enc and mxc_jpeg_go_dec.

Function mxc_jpeg_reset had no purpose anymore, instead use
mxc_jpeg_sw_reset, for soft reset.

Add function mxc_jpeg_set_l_endian.

Signed-off-by: Mirela Rabulea <mirela.rabulea@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/imx8/mxc-jpeg-hw.c |  120 +++++++++-----------------
 drivers/media/platform/imx8/mxc-jpeg-hw.h |   55 +++++++-----
 drivers/media/platform/imx8/mxc-jpeg.c    |  134 ++++++++++++++++-------------
 drivers/media/platform/imx8/mxc-jpeg.h    |    2 -
 4 files changed, 145 insertions(+), 166 deletions(-)

diff --git a/drivers/media/platform/imx8/mxc-jpeg-hw.c b/drivers/media/platform/imx8/mxc-jpeg-hw.c
index 5b6408b..2263ec4 100644
--- a/drivers/media/platform/imx8/mxc-jpeg-hw.c
+++ b/drivers/media/platform/imx8/mxc-jpeg-hw.c
@@ -20,26 +20,26 @@
 #define internal_print_wrapper_reg(dev, base_address, reg_name, reg_offset) {\
 		int val;\
 		val = readl((base_address) + (reg_offset));\
-		dev_info(dev, "Wrapper reg %s = 0x%x\n", reg_name, val);\
+		dev_dbg(dev, "Wrapper reg %s = 0x%x\n", reg_name, val);\
 }
 
 void print_descriptor_info(struct device *dev, struct mxc_jpeg_desc *desc)
 {
-	dev_info(dev, " MXC JPEG NEXT_DESCPT_PTR 0x%x\n",
+	dev_dbg(dev, " MXC JPEG NEXT_DESCPT_PTR 0x%x\n",
 		desc->next_descpt_ptr);
-	dev_info(dev, " MXC JPEG BUF_BASE0 0x%x\n", desc->buf_base0);
-	dev_info(dev, " MXC JPEG BUF_BASE1 0x%x\n", desc->buf_base1);
-	dev_info(dev, " MXC JPEG LINE_PITCH %d\n", desc->line_pitch);
-	dev_info(dev, " MXC JPEG STM_BUFBASE 0x%x\n", desc->stm_bufbase);
-	dev_info(dev, " MXC JPEG STM_BUFSIZE %d\n", desc->stm_bufsize);
-	dev_info(dev, " MXC JPEG IMGSIZE %x (%d x %d)\n", desc->imgsize,
+	dev_dbg(dev, " MXC JPEG BUF_BASE0 0x%x\n", desc->buf_base0);
+	dev_dbg(dev, " MXC JPEG BUF_BASE1 0x%x\n", desc->buf_base1);
+	dev_dbg(dev, " MXC JPEG LINE_PITCH %d\n", desc->line_pitch);
+	dev_dbg(dev, " MXC JPEG STM_BUFBASE 0x%x\n", desc->stm_bufbase);
+	dev_dbg(dev, " MXC JPEG STM_BUFSIZE %d\n", desc->stm_bufsize);
+	dev_dbg(dev, " MXC JPEG IMGSIZE %x (%d x %d)\n", desc->imgsize,
 		desc->imgsize >> 16, desc->imgsize & 0xFFFF);
-	dev_info(dev, " MXC JPEG STM_CTRL 0x%x\n", desc->stm_ctrl);
+	dev_dbg(dev, " MXC JPEG STM_CTRL 0x%x\n", desc->stm_ctrl);
 }
 
-void print_cast_decoder_info(struct device *dev, void __iomem *reg)
+void print_cast_status(struct device *dev, void __iomem *reg, unsigned int mode)
 {
-	dev_info(dev, "CAST IP decoder regs:\n");
+	dev_dbg(dev, "CAST IP status regs:\n");
 	print_wrapper_reg(dev, reg, CAST_STATUS0);
 	print_wrapper_reg(dev, reg, CAST_STATUS1);
 	print_wrapper_reg(dev, reg, CAST_STATUS2);
@@ -54,27 +54,19 @@ void print_cast_decoder_info(struct device *dev, void __iomem *reg)
 	print_wrapper_reg(dev, reg, CAST_STATUS11);
 	print_wrapper_reg(dev, reg, CAST_STATUS12);
 	print_wrapper_reg(dev, reg, CAST_STATUS13);
-}
-
-void print_cast_encoder_info(struct device *dev, void __iomem *reg)
-{
-	dev_info(dev, "CAST IP encoder regs:\n");
-	print_wrapper_reg(dev, reg, CAST_MODE);
-	print_wrapper_reg(dev, reg, CAST_CFG_MODE);
-	print_wrapper_reg(dev, reg, CAST_QUALITY);
-	print_wrapper_reg(dev, reg, CAST_RSVD);
-	print_wrapper_reg(dev, reg, CAST_REC_REGS_SEL);
-	print_wrapper_reg(dev, reg, CAST_LUMTH);
-	print_wrapper_reg(dev, reg, CAST_CHRTH);
-	print_wrapper_reg(dev, reg, CAST_NOMFRSIZE_LO);
-	print_wrapper_reg(dev, reg, CAST_NOMFRSIZE_HI);
-	print_wrapper_reg(dev, reg, CAST_OFBSIZE_LO);
-	print_wrapper_reg(dev, reg, CAST_OFBSIZE_HI);
+	if (mode == MXC_JPEG_DECODE)
+		return;
+	print_wrapper_reg(dev, reg, CAST_STATUS14);
+	print_wrapper_reg(dev, reg, CAST_STATUS15);
+	print_wrapper_reg(dev, reg, CAST_STATUS16);
+	print_wrapper_reg(dev, reg, CAST_STATUS17);
+	print_wrapper_reg(dev, reg, CAST_STATUS18);
+	print_wrapper_reg(dev, reg, CAST_STATUS19);
 }
 
 void print_wrapper_info(struct device *dev, void __iomem *reg)
 {
-	dev_info(dev, "Wrapper regs:\n");
+	dev_dbg(dev, "Wrapper regs:\n");
 	print_wrapper_reg(dev, reg, GLB_CTRL);
 	print_wrapper_reg(dev, reg, COM_STATUS);
 	print_wrapper_reg(dev, reg, BUF_BASE0);
@@ -91,14 +83,15 @@ void mxc_jpeg_enable_irq(void __iomem *reg, int slot)
 	writel(0xFFFFFFFF, reg + MXC_SLOT_OFFSET(slot, SLOT_IRQ_EN));
 }
 
-void mxc_jpeg_reset(void __iomem *reg)
-{
-	writel(GLB_CTRL_JPG_EN, reg + GLB_CTRL);
-}
-
 void mxc_jpeg_sw_reset(void __iomem *reg)
 {
-	writel(GLB_CTRL_SFT_RST | GLB_CTRL_JPG_EN, reg + GLB_CTRL);
+	/*
+	 * engine soft reset, internal state machine reset
+	 * this will not reset registers, however, it seems
+	 * the registers may remain inconsistent with the internal state
+	 * so, on purpose, at least let GLB_CTRL bits clear after this reset
+	 */
+	writel(GLB_CTRL_SFT_RST, reg + GLB_CTRL);
 }
 
 u32 mxc_jpeg_get_offset(void __iomem *reg, int slot)
@@ -106,12 +99,9 @@ u32 mxc_jpeg_get_offset(void __iomem *reg, int slot)
 	return readl(reg + MXC_SLOT_OFFSET(slot, SLOT_BUF_PTR));
 }
 
-void mxc_jpeg_enc_config(struct device *dev,
-			 void __iomem *reg, struct mxc_jpeg_desc *cfg_desc,
-			 u32 cfg_handle, u32 cfg_stream_handle, u32 jpg_handle)
+void mxc_jpeg_go_enc(struct device *dev, void __iomem *reg)
 {
-	u32 slot;
-
+	dev_dbg(dev, "CAST Encoder GO...\n");
 	/*
 	 * "Config_Mode" enabled, "Config_Mode auto clear enabled",
 	 * "GO" enabled, "GO bit auto clear" enabled
@@ -123,28 +113,6 @@ void mxc_jpeg_enc_config(struct device *dev,
 
 	/* quality factor */
 	writel(0x4b, reg + CAST_QUALITY);
-
-	cfg_desc->next_descpt_ptr = 0;
-	cfg_desc->buf_base0 = cfg_stream_handle;
-	cfg_desc->buf_base1 = 0;
-	cfg_desc->line_pitch = 0;
-	cfg_desc->stm_bufbase = 0;
-	cfg_desc->stm_bufsize = 0x2000;
-	cfg_desc->imgsize = 0;
-	cfg_desc->stm_ctrl = STM_CTRL_CONFIG_MOD(1) | STM_CTRL_AUTO_START(1);
-
-	slot = 0; /* TODO get slot*/
-	writel(GLB_CTRL_SLOT_EN(slot) | GLB_CTRL_L_ENDIAN | GLB_CTRL_JPG_EN,
-	       reg + GLB_CTRL);
-
-	mxc_jpeg_enable_irq(reg, slot);
-
-	print_descriptor_info(dev, cfg_desc);
-	print_wrapper_info(dev, reg);
-	print_cast_encoder_info(dev, reg);
-
-	mxc_jpeg_set_desc(cfg_handle, reg, slot);
-	mxc_jpeg_go_auto(reg);
 }
 
 void wait_frmdone(struct device *dev, void __iomem *reg)
@@ -171,25 +139,10 @@ int mxc_jpeg_enable(void __iomem *reg)
 	return regval;
 }
 
-void mxc_jpeg_go(void __iomem *reg)
+void mxc_jpeg_go_dec(struct device *dev, void __iomem *reg)
 {
-	u32 val;
-
-	val = readl(reg + GLB_CTRL);
-	writel(GLB_CTRL_L_ENDIAN | GLB_CTRL_DEC_GO | val, reg + GLB_CTRL);
-	writel(MXC_DEC_EXIT_IDLE_MODE, reg + CAST_STATUS13);
-}
-
-void mxc_jpeg_go_auto(void __iomem *reg)
-{
-	u32 val;
-
-	/* Automatically start the CAST encoder/decoder */
-	val = readl(reg + STM_CTRL);
-	writel(STM_CTRL_AUTO_START(1) | val, reg + STM_CTRL);
-
-	val = readl(reg + GLB_CTRL);
-	writel(GLB_CTRL_L_ENDIAN | GLB_CTRL_DEC_GO | val, reg + GLB_CTRL);
+	dev_dbg(dev, "CAST Decoder GO...\n");
+	writel(MXC_DEC_EXIT_IDLE_MODE, reg + CAST_CTRL);
 }
 
 int mxc_jpeg_get_slot(void __iomem *reg)
@@ -218,6 +171,15 @@ void mxc_jpeg_enable_slot(void __iomem *reg, int slot)
 	writel(GLB_CTRL_SLOT_EN(slot) | regval, reg + GLB_CTRL);
 }
 
+void mxc_jpeg_set_l_endian(void __iomem *reg, int le)
+{
+	u32 regval;
+
+	regval = readl(reg + GLB_CTRL);
+	regval &= ~GLB_CTRL_L_ENDIAN(1); /* clear */
+	writel(GLB_CTRL_L_ENDIAN(le) | regval, reg + GLB_CTRL); /* set */
+}
+
 void mxc_jpeg_set_config_mode(void __iomem *reg, int config_mode)
 {
 	u32 regval;
diff --git a/drivers/media/platform/imx8/mxc-jpeg-hw.h b/drivers/media/platform/imx8/mxc-jpeg-hw.h
index bd89895..ce158c8 100644
--- a/drivers/media/platform/imx8/mxc-jpeg-hw.h
+++ b/drivers/media/platform/imx8/mxc-jpeg-hw.h
@@ -12,6 +12,9 @@
 #ifndef _MXC_JPEG_HW_H
 #define _MXC_JPEG_HW_H
 
+#define MXC_JPEG_DECODE			0
+#define MXC_JPEG_ENCODE			1
+
 /* JPEG Decoder/Encoder Wrapper Register Map */
 #define GLB_CTRL			0x0
 #define COM_STATUS			0x4
@@ -23,7 +26,7 @@
 #define IMGSIZE				0x28
 #define STM_CTRL			0x2C
 
-/* CAST JPEG-Decoder Register Map */
+/* CAST JPEG-Decoder/Encoder Status Register Map (read-only)*/
 #define CAST_STATUS0			0x100
 #define CAST_STATUS1			0x104
 #define CAST_STATUS2			0x108
@@ -38,20 +41,29 @@
 #define CAST_STATUS11			0x12c
 #define CAST_STATUS12			0x130
 #define CAST_STATUS13			0x134
+/* the following are for encoder only */
+#define CAST_STATUS14		0x138
+#define CAST_STATUS15		0x13c
+#define CAST_STATUS16		0x140
+#define CAST_STATUS17		0x144
+#define CAST_STATUS18		0x148
+#define CAST_STATUS19		0x14c
+
+/* CAST JPEG-Decoder Control Register Map (write-only) */
+#define CAST_CTRL			CAST_STATUS13
 
-/* CAST JPEG-Encoder Register Map */
-#define CAST_MODE			0x100
-#define CAST_CFG_MODE			0x104
-#define CAST_QUALITY			0x108
-#define CAST_RSVD			0x10c
-#define CAST_REC_REGS_SEL		0x110
-#define CAST_LUMTH			0x114
-#define CAST_CHRTH			0x118
-#define CAST_NOMFRSIZE_LO		0x11c
-#define CAST_NOMFRSIZE_HI		0x120
-#define CAST_OFBSIZE_LO			0x124
-#define CAST_OFBSIZE_HI			0x128
-/* TODO add more if necessary*/
+/* CAST JPEG-Encoder Control Register Map (write-only) */
+#define CAST_MODE			CAST_STATUS0
+#define CAST_CFG_MODE			CAST_STATUS1
+#define CAST_QUALITY			CAST_STATUS2
+#define CAST_RSVD			CAST_STATUS3
+#define CAST_REC_REGS_SEL		CAST_STATUS4
+#define CAST_LUMTH			CAST_STATUS5
+#define CAST_CHRTH			CAST_STATUS6
+#define CAST_NOMFRSIZE_LO		CAST_STATUS7
+#define CAST_NOMFRSIZE_HI		CAST_STATUS8
+#define CAST_OFBSIZE_LO			CAST_STATUS9
+#define CAST_OFBSIZE_HI			CAST_STATUS10
 
 #define MXC_MAX_SLOTS	1 /* TODO use all 4 slots*/
 /* JPEG-Decoder Wrapper Slot Registers 0..3 */
@@ -67,7 +79,7 @@
 #define GLB_CTRL_JPG_EN					0x1
 #define GLB_CTRL_SFT_RST				(0x1 << 1)
 #define GLB_CTRL_DEC_GO					(0x1 << 2)
-#define GLB_CTRL_L_ENDIAN				(0x1 << 3)
+#define GLB_CTRL_L_ENDIAN(le)				((le) << 3)
 #define GLB_CTRL_SLOT_EN(slot)				(0x1 << (slot + 4))
 
 /* STM_CTRL fields */
@@ -101,21 +113,18 @@ enum mxc_jpeg_image_format {
 
 #include "mxc-jpeg.h"
 void print_descriptor_info(struct device *dev, struct mxc_jpeg_desc *desc);
-void print_cast_decoder_info(struct device *dev, void __iomem *reg);
-void print_cast_encoder_info(struct device *dev, void __iomem *reg);
+void print_cast_status(struct device *dev, void __iomem *reg,
+			unsigned int mode);
 void print_wrapper_info(struct device *dev, void __iomem *reg);
-void mxc_jpeg_reset(void __iomem *reg);
 void mxc_jpeg_sw_reset(void __iomem *reg);
 int mxc_jpeg_enable(void __iomem *reg);
 void wait_frmdone(struct device *dev, void __iomem *reg);
-void mxc_jpeg_enc_config(struct device *dev,
-			 void __iomem *reg, struct mxc_jpeg_desc *cfg_desc,
-			 u32 cfg_handle, u32 tbl_handle, u32 jpg_handle);
-void mxc_jpeg_go(void __iomem *reg);
-void mxc_jpeg_go_auto(void __iomem *reg);
+void mxc_jpeg_go_enc(struct device *dev, void __iomem *reg);
+void mxc_jpeg_go_dec(struct device *dev, void __iomem *reg);
 int mxc_jpeg_get_slot(void __iomem *reg);
 u32 mxc_jpeg_get_offset(void __iomem *reg, int slot);
 void mxc_jpeg_enable_slot(void __iomem *reg, int slot);
+void mxc_jpeg_set_l_endian(void __iomem *reg, int le);
 void mxc_jpeg_enable_irq(void __iomem *reg, int slot);
 int mxc_jpeg_set_input(void __iomem *reg, u32 in_buf, u32 bufsize);
 int mxc_jpeg_set_output(void __iomem *reg, u16 out_pitch, u32 out_buf,
diff --git a/drivers/media/platform/imx8/mxc-jpeg.c b/drivers/media/platform/imx8/mxc-jpeg.c
index 08d4f92..4d203a6 100644
--- a/drivers/media/platform/imx8/mxc-jpeg.c
+++ b/drivers/media/platform/imx8/mxc-jpeg.c
@@ -242,8 +242,6 @@ static irqreturn_t mxc_jpeg_dec_irq(int irq, void *priv)
 	void __iomem *reg = jpeg->base_reg;
 	struct device *dev = jpeg->dev;
 	struct vb2_buffer *src_buf, *dst_buf;
-	struct mxc_jpeg_desc *desc;
-	dma_addr_t dma_handle;
 	u32 dec_ret;
 	int slot = 0; /* TODO remove hardcoded slot 0 */
 
@@ -277,36 +275,7 @@ static irqreturn_t mxc_jpeg_dec_irq(int irq, void *priv)
 			goto job_finish;
 		}
 
-		dev_dbg(dev, "Encoder config finished.\n");
-
-		/* get out of config mode*/
-		mxc_jpeg_set_config_mode(reg, 0);
-
-		slot = 0; /* TODO get slot*/
-
-		desc = jpeg->slot_data[slot].desc;
-		dma_handle = jpeg->slot_data[slot].desc_handle;
-
-		mxc_jpeg_addrs(desc, src_buf, dst_buf, 0);
-
-		/* TODO remove hardcodings*/
-		mxc_jpeg_set_bufsize(desc, 0x1000);
-		mxc_jpeg_set_res(desc, 64, 64);
-		mxc_jpeg_set_line_pitch(desc, 64 * 2);
-		desc->stm_ctrl = STM_CTRL_CONFIG_MOD(0) |
-				 STM_CTRL_AUTO_START(1) |
-				 STM_CTRL_IMAGE_FORMAT(MXC_JPEG_YUV422);
-
-		mxc_jpeg_enable_slot(jpeg->base_reg, slot);
-		mxc_jpeg_enable_irq(jpeg->base_reg, slot);
-		mxc_jpeg_set_desc(dma_handle, jpeg->base_reg, slot);
-
-		print_descriptor_info(dev, desc);
-		print_wrapper_info(dev, jpeg->base_reg);
-		print_cast_encoder_info(dev, jpeg->base_reg);
-
-		dev_dbg(dev, "Encoder starts encoding...\n");
-		mxc_jpeg_go_auto(jpeg->base_reg);
+		dev_dbg(dev, "Encoder config finished. Start encoding...\n");
 		goto job_unlock;
 	}
 	if (ctx->mode == MXC_JPEG_ENCODE)
@@ -315,9 +284,9 @@ static irqreturn_t mxc_jpeg_dec_irq(int irq, void *priv)
 		dev_dbg(dev, "Decoding finished\n");
 
 	/* short preview of the results */
-	dev_dbg(dev, "src_buf: ");
+	dev_dbg(dev, "src_buf preview: ");
 	print_buf(dev, src_buf);
-	dev_dbg(dev, "dst_buf: ");
+	dev_dbg(dev, "dst_buf preview: ");
 	print_buf(dev, dst_buf);
 
 	v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
@@ -331,29 +300,76 @@ static irqreturn_t mxc_jpeg_dec_irq(int irq, void *priv)
 	return IRQ_HANDLED;
 }
 
-static void mxc_jpeg_config_enc(struct vb2_buffer *out_buf,
+static void mxc_jpeg_config_dec_desc(struct vb2_buffer *out_buf,
 			 int slot,
-			 struct mxc_jpeg_dev *jpeg)
+			 struct mxc_jpeg_dev *jpeg,
+			 struct vb2_buffer *src_buf, struct vb2_buffer *dst_buf)
 {
-	dma_addr_t jpg_handle;
+	void __iomem *reg = jpeg->base_reg;
+	struct mxc_jpeg_desc *desc = jpeg->slot_data[slot].desc;
+	dma_addr_t desc_handle = jpeg->slot_data[slot].desc_handle;
 
-	jpg_handle = vb2_dma_contig_plane_dma_addr(out_buf, 0);
-	mxc_jpeg_enc_config(jpeg->dev,
-		jpeg->base_reg,
-		jpeg->slot_data[slot].desc, jpeg->slot_data[slot].desc_handle,
-		jpeg->slot_data[slot].cfg_stream_handle, jpg_handle);
+	mxc_jpeg_addrs(desc, dst_buf, src_buf, 0);
+	mxc_jpeg_set_bufsize(desc,
+			mxc_jpeg_align(vb2_plane_size(src_buf, 0), 1024));
+	print_descriptor_info(jpeg->dev, desc);
+
+	/* validate the decoding descriptor */
+	mxc_jpeg_set_desc(desc_handle, reg, slot);
+}
+
+static void mxc_jpeg_config_enc_desc(struct vb2_buffer *out_buf,
+			 int slot,
+			 struct mxc_jpeg_dev *jpeg,
+			 struct vb2_buffer *src_buf, struct vb2_buffer *dst_buf)
+{
+	void __iomem *reg = jpeg->base_reg;
+	struct mxc_jpeg_desc *desc = jpeg->slot_data[slot].desc;
+	struct mxc_jpeg_desc *cfg_desc = jpeg->slot_data[slot].cfg_desc;
+	dma_addr_t desc_handle = jpeg->slot_data[slot].desc_handle;
+	dma_addr_t cfg_desc_handle = jpeg->slot_data[slot].cfg_desc_handle;
+
+
+	/* chain the config descriptor with the encoding descriptor */
+	cfg_desc->next_descpt_ptr = desc_handle | MXC_NXT_DESCPT_EN;
+
+	cfg_desc->buf_base0 = jpeg->slot_data[slot].cfg_stream_handle;
+	cfg_desc->buf_base1 = 0;
+	cfg_desc->line_pitch = 0;
+	cfg_desc->stm_bufbase = 0;
+	cfg_desc->stm_bufsize = 0x2000;
+	cfg_desc->imgsize = 0;
+	cfg_desc->stm_ctrl = STM_CTRL_CONFIG_MOD(1);
+
+	desc->next_descpt_ptr = 0; /* end of chain */
+	mxc_jpeg_addrs(desc, src_buf, dst_buf, 0);
+	/* TODO remove hardcodings*/
+	mxc_jpeg_set_bufsize(desc, 0x1000);
+	mxc_jpeg_set_res(desc, 64, 64);
+	mxc_jpeg_set_line_pitch(desc, 64 * 2);
+	desc->stm_ctrl = STM_CTRL_CONFIG_MOD(0) |
+			 STM_CTRL_IMAGE_FORMAT(MXC_JPEG_YUV422);
+
+	dev_dbg(jpeg->dev, "cfg_desc - 0x%llx:\n", cfg_desc_handle);
+	print_descriptor_info(jpeg->dev, cfg_desc);
+	dev_dbg(jpeg->dev, "enc desc - 0x%llx:\n", desc_handle);
+	print_descriptor_info(jpeg->dev, desc);
+	print_wrapper_info(jpeg->dev, reg);
+	print_cast_status(jpeg->dev, reg, MXC_JPEG_ENCODE);
+
+	/* validate the configuration descriptor */
+	mxc_jpeg_set_desc(cfg_desc_handle, reg, slot);
 }
 
 static void mxc_jpeg_device_run(void *priv)
 {
 	struct mxc_jpeg_ctx *ctx = priv;
 	struct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;
+	void __iomem *reg = jpeg->base_reg;
 	struct device *dev = jpeg->dev;
 	struct vb2_buffer *src_buf, *dst_buf;
 	unsigned long flags;
 	int slot = 0;
-	dma_addr_t dma_handle;
-	struct mxc_jpeg_desc *desc;
 
 	spin_lock_irqsave(&ctx->mxc_jpeg->hw_lock, flags);
 	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
@@ -362,28 +378,24 @@ static void mxc_jpeg_device_run(void *priv)
 		dev_err(dev, "Null src or dst buf\n");
 		goto end;
 	}
+
+	mxc_jpeg_sw_reset(reg);
+	mxc_jpeg_enable(reg);
+	mxc_jpeg_set_l_endian(reg, 1);
+
 	slot = 0; /* TODO get slot */
-	mxc_jpeg_enable(jpeg->base_reg);
+	mxc_jpeg_enable_slot(reg, slot);
+	mxc_jpeg_enable_irq(reg, slot);
 
 	if (ctx->mode == MXC_JPEG_ENCODE) {
 		dev_dbg(dev, "Encoding on slot %d\n", slot);
-		mxc_jpeg_sw_reset(jpeg->base_reg);
 		ctx->enc_state = MXC_JPEG_ENC_CONF;
-		mxc_jpeg_config_enc(dst_buf, slot, jpeg);
+		mxc_jpeg_config_enc_desc(dst_buf, slot, jpeg, src_buf, dst_buf);
+		mxc_jpeg_go_enc(dev, reg);
 	} else {
 		dev_dbg(dev, "Decoding on slot %d\n", slot);
-		desc = jpeg->slot_data[slot].desc;
-		dma_handle = jpeg->slot_data[slot].desc_handle;
-
-		mxc_jpeg_addrs(desc, dst_buf, src_buf, 0);
-
-		mxc_jpeg_enable_slot(jpeg->base_reg, slot);
-		mxc_jpeg_set_bufsize(desc,
-			mxc_jpeg_align(vb2_plane_size(src_buf, 0), 1024));
-		mxc_jpeg_enable_irq(jpeg->base_reg, slot);
-		print_descriptor_info(dev, desc);
-		mxc_jpeg_set_desc(dma_handle, jpeg->base_reg, slot);
-		mxc_jpeg_go(jpeg->base_reg);
+		mxc_jpeg_config_dec_desc(dst_buf, slot, jpeg, src_buf, dst_buf);
+		mxc_jpeg_go_dec(dev, reg);
 	}
 end:
 	spin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);
@@ -493,8 +505,7 @@ static u8 get_sof(struct device *dev,
 	_bswap16(&sof->length);
 	_bswap16(&sof->height);
 	_bswap16(&sof->width);
-	dev_info(dev, "JPEG SOF: length=%d, precision=%d\n",
-		sof->length, sof->precision);
+	dev_info(dev, "JPEG SOF: precision=%d\n", sof->precision);
 	dev_info(dev, "JPEG SOF: height=%d, width=%d\n",
 		sof->height, sof->width);
 	for (i = 0; i < sof->components_no; i++) {
@@ -1345,4 +1356,3 @@ static int mxc_jpeg_remove(struct platform_device *pdev)
 };
 module_platform_driver(mxc_jpeg_driver);
 MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/media/platform/imx8/mxc-jpeg.h b/drivers/media/platform/imx8/mxc-jpeg.h
index 88a3fba..d2eb052 100644
--- a/drivers/media/platform/imx8/mxc-jpeg.h
+++ b/drivers/media/platform/imx8/mxc-jpeg.h
@@ -31,8 +31,6 @@
 #define MXC_JPEG_MAX_HEIGHT		0x2000
 #define MXC_JPEG_MAX_WIDTH		0x2000
 #define MXC_JPEG_DEFAULT_SIZEIMAGE	10000
-#define MXC_JPEG_DECODE			0
-#define MXC_JPEG_ENCODE			1
 #define MXC_JPEG_ENC_CONF		1
 #define MXC_JPEG_ENC_DONE		0
 #define SOF0				0xC0
-- 
1.7.9.5


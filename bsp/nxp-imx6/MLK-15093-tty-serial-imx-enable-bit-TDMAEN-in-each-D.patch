From bd8168f4b6b3fca9a31736a15c16d2777ba5a315 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Mon, 12 Jun 2017 16:56:43 +0800
Subject: [PATCH 1896/5242] MLK-15093 tty: serial: imx: enable bit TDMAEN in
 each DMA transfer

commit  3739f6f8c7b07cf2e784da1caaf19dfeb22c7386 from
https://source.codeaurora.org/external/imx/linux-imx.git

In below case:
write() -> flush() -> write() -> flush() ...

.imx_flush_buffer() _MAY_ clear UCR1_TDMAEN bit if the callback is not
comming or DMA transfer is not completed, to ensure DMA trigger is enabled
for the new DMA prep_sg, enable the UCR1_TDMAEN bit in .dma_tx_work().

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
Tested-by: David Wolfe <david.wolfe@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/imx.c |   19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 1a0c147..f2a6ee0 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -579,16 +579,21 @@ static void imx_uart_dma_tx_callback(void *data)
 	unsigned long flags;
 	u32 ucr1;
 
-	dma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);
-
-	sport->dma_is_txing = 0;
-
 	/* update the stat */
 	spin_lock_irqsave(&sport->port.lock, flags);
+	/* user call .flush() before the code slice coming */
+	if (!sport->dma_is_txing) {
+		spin_unlock_irqrestore(&sport->port.lock, flags);
+		return;
+	}
+	sport->dma_is_txing = 0;
+
 	xmit->tail = (xmit->tail + sport->tx_bytes) & (UART_XMIT_SIZE - 1);
 	sport->port.icount.tx += sport->tx_bytes;
 	spin_unlock_irqrestore(&sport->port.lock, flags);
 
+	dma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);
+
 	dev_dbg(sport->port.dev, "we finish the TX DMA.\n");
 
 	clear_bit(DMA_TX_IS_WORKING, &sport->flags);
@@ -665,6 +670,10 @@ static void imx_uart_dma_tx_work(struct work_struct *w)
 		sport->dma_is_txing = 1;
 		dmaengine_submit(desc);
 		dma_async_issue_pending(chan);
+
+		ucr1 = imx_uart_readl(sport, UCR1);
+		ucr1 |= UCR1_TXDMAEN;
+		imx_uart_writel(sport, ucr1, UCR1);
 		return;
 	}
 
@@ -1573,6 +1582,8 @@ static void imx_uart_flush_buffer(struct uart_port *port)
 		ucr1 &= ~UCR1_TXDMAEN;
 		imx_uart_writel(sport, ucr1, UCR1);
 		sport->dma_is_txing = 0;
+		clear_bit(DMA_TX_IS_WORKING, &sport->flags);
+		smp_mb__after_atomic();
 	}
 
 	/*
-- 
1.7.9.5


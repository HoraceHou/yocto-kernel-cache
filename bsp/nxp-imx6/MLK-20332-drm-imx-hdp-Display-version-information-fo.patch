From 4266c5658f14b7dd9dab022e43b3b2986d37a437 Mon Sep 17 00:00:00 2001
From: Oliver Brown <oliver.brown@nxp.com>
Date: Mon, 12 Nov 2018 08:46:55 -0600
Subject: [PATCH 5120/5242] MLK-20332 drm: imx hdp: Display version
 information for HDMI/DP firmware

commit  81c76467492de8e2e4e4ec1e5cc5cb84bdce1b51 from
https://source.codeaurora.org/external/imx/linux-imx.git

The HDMI/DP firmware verison will now be displayed.
Moved firmware handling to common file for HDMI and DisplayPort.

Signed-off-by: Oliver Brown <oliver.brown@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/hdp/imx-dp.c   |   62 --------------
 drivers/gpu/drm/imx/hdp/imx-dp.h   |    2 -
 drivers/gpu/drm/imx/hdp/imx-hdmi.c |   62 ++------------
 drivers/gpu/drm/imx/hdp/imx-hdmi.h |    2 -
 drivers/gpu/drm/imx/hdp/imx-hdp.c  |  160 ++++++++++++++++++++++++++++--------
 drivers/gpu/drm/imx/hdp/imx-hdp.h  |    1 +
 6 files changed, 136 insertions(+), 153 deletions(-)

diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.c b/drivers/gpu/drm/imx/hdp/imx-dp.c
index 1bc5984..d97a387 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.c
@@ -23,68 +23,6 @@
 #include "imx-hdmi.h"
 #include "imx-dp.h"
 
-#ifdef DEBUG_FW_LOAD
-void dp_fw_load(state_struct *state)
-{
-	DRM_INFO("loading hdmi firmware\n");
-	CDN_API_LoadFirmware(state,
-		(u8 *)mhdp_iram0_get_ptr(),
-		mhdp_iram0_get_size(),
-		(u8 *)mhdp_dram0_get_ptr(),
-		mhdp_dram0_get_size());
-}
-#endif
-int dp_fw_init(state_struct *state)
-{
-	u8 echo_msg[] = "echo test";
-	u8 echo_resp[sizeof(echo_msg) + 1];
-	struct imx_hdp *hdp = state_to_imx_hdp(state);
-	u32 core_rate;
-	int ret;
-	u8 resp;
-
-	core_rate = clk_get_rate(hdp->clks.clk_core);
-
-	/* configure the clock */
-	CDN_API_SetClock(state, core_rate/1000000);
-	pr_info("CDN_API_SetClock completed\n");
-
-	cdn_apb_write(state, APB_CTRL << 2, 0);
-	DRM_INFO("Started firmware!\n");
-
-	ret = CDN_API_CheckAlive_blocking(state);
-	if (ret != 0) {
-		DRM_ERROR("CDN_API_CheckAlive failed - check firmware!\n");
-		return -ENXIO;
-	}
-
-	DRM_INFO("CDN_API_CheckAlive returned ret = %d\n", ret);
-
-	/* turn on IP activity */
-	ret = CDN_API_MainControl_blocking(state, 1, &resp);
-	DRM_INFO("CDN_API_MainControl_blocking (ret = %d resp = %u)\n",
-		ret, resp);
-
-	ret = CDN_API_General_Test_Echo_Ext_blocking(state, echo_msg, echo_resp,
-		sizeof(echo_msg), CDN_BUS_TYPE_APB);
-	if (strncmp(echo_msg, echo_resp, sizeof(echo_msg)) != 0) {
-		DRM_ERROR("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
-		return -ENXIO;
-	}
-	DRM_INFO("CDN_API_General_Test_Echo_Ext_blocking (ret = %d echo_resp = %s)\n",
-		ret, echo_resp);
-
-	/* Line swaping */
-	CDN_API_General_Write_Register_blocking(state,
-						ADDR_SOURCD_PHY +
-						(LANES_CONFIG << 2),
-						0x00400000 |
-						hdp->dp_lane_mapping);
-	DRM_INFO("CDN_API_General_Write_Register_blockin ... setting LANES_CONFIG\n");
-
-	return 0;
-}
-
 int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format,
 		int color_depth)
 {
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.h b/drivers/gpu/drm/imx/hdp/imx-dp.h
index a019347..83177b1 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.h
@@ -14,8 +14,6 @@
 #ifndef _IMX_DP_H_
 #define _IMX_DP_H_
 
-void dp_fw_load(state_struct *state);
-int dp_fw_init(state_struct *state);
 void dp_mode_set(state_struct *state,
 		 struct drm_display_mode *mode,
 		 int format, int color_depth,
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.c b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
index b8b15a5..0d6b7fc 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
@@ -22,59 +22,6 @@
 #include "API_AFE_t28hpc_hdmitx.h"
 
 static int character_freq_khz;
-#ifdef DEBUG_FW_LOAD
-void hdmi_fw_load(state_struct *state)
-{
-	DRM_INFO("loading hdmi firmware\n");
-	CDN_API_LoadFirmware(state,
-		(u8 *)hdmitx_iram0_get_ptr(),
-		hdmitx_iram0_get_size(),
-		(u8 *)hdmitx_dram0_get_ptr(),
-		hdmitx_dram0_get_size());
-}
-#endif
-int hdmi_fw_init(state_struct *state)
-{
-	u8 echo_msg[] = "echo test";
-	u8 echo_resp[sizeof(echo_msg) + 1];
-	struct imx_hdp *hdp = state_to_imx_hdp(state);
-	u32 core_rate;
-	int ret;
-	u8 sts;
-
-	core_rate = clk_get_rate(hdp->clks.clk_core);
-
-	/* configure the clock */
-	CDN_API_SetClock(state, core_rate/1000000);
-	pr_info("CDN_API_SetClock completed\n");
-
-	/* moved from CDN_API_LoadFirmware */
-	cdn_apb_write(state, APB_CTRL << 2, 0);
-	DRM_INFO("Started firmware!\n");
-
-	ret = CDN_API_CheckAlive_blocking(state);
-	if (ret != 0) {
-		DRM_ERROR("CDN_API_CheckAlive failed - check firmware!\n");
-		return -ENXIO;
-	} else
-		DRM_INFO("CDN_API_CheckAlive returned ret = %d\n", ret);
-
-	/* turn on IP activity */
-	ret = CDN_API_MainControl_blocking(state, 1, &sts);
-	DRM_INFO("CDN_API_MainControl_blocking ret = %d sts = %u\n", ret, sts);
-
-	ret = CDN_API_General_Test_Echo_Ext_blocking(state, echo_msg, echo_resp,
-		 sizeof(echo_msg), CDN_BUS_TYPE_APB);
-
-	if (0 != strncmp(echo_msg, echo_resp, sizeof(echo_msg))) {
-		DRM_ERROR("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
-		return -ENXIO;
-	}
-	DRM_INFO("CDN_API_General_Test_Echo_Ext_blocking - APB(ret = %d echo_resp = %s)\n",
-		  ret, echo_resp);
-
-	return 0;
-}
 
 #define RGB_ALLOWED_COLORIMETRY (BIT(HDMI_EXTENDED_COLORIMETRY_BT2020) |\
 				 BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB))
@@ -252,8 +199,6 @@ void hdmi_mode_set_ss28fdsoi(state_struct *state, struct drm_display_mode *mode,
 		DRM_INFO("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
 		return;
 	}
-
-	msleep(50);
 }
 
 int hdmi_phy_init_t28hpc(state_struct *state, struct drm_display_mode *mode, int format, int color_depth)
@@ -418,6 +363,11 @@ void hdmi_mode_set_t28hpc(state_struct *state, struct drm_display_mode *mode, in
 		DRM_ERROR("hdmi avi info set ret = %d\n", ret);
 		return;
 	}
+	ret = hdmi_avi_info_set(hdp, mode, format);
+	if (ret < 0) {
+		DRM_ERROR("hdmi avi info set ret = %d\n", ret);
+		return;
+	}
 
 	ret = hdmi_vendor_info_set(hdp, mode, format);
 	if (ret < 0)
@@ -430,6 +380,8 @@ void hdmi_mode_set_t28hpc(state_struct *state, struct drm_display_mode *mode, in
 	}
 
 	hdmi_mode_set_vswing(state);
+
+	msleep(50);
 }
 
 #define YUV_MODE		BIT(0)
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.h b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
index 1ed5a65..8871477 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
@@ -14,8 +14,6 @@
 #ifndef _IMX_HDMI_H_
 #define _IMX_HDMI_H_
 
-void hdmi_fw_load(state_struct *state);
-int hdmi_fw_init(state_struct *state);
 int hdmi_phy_init_ss28fdsoi(state_struct *state,
 			struct drm_display_mode *mode, int format, int color_depth);
 void hdmi_mode_set_ss28fdsoi(state_struct *state,
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index 573c138..7a848fe 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -101,6 +101,94 @@ static void imx_hdp_cec_init(struct imx_hdp *hdp)
 }
 #endif
 
+#ifdef DEBUG_FW_LOAD
+void hdp_fw_load(state_struct *state)
+{
+	DRM_INFO("loading hdmi firmware\n");
+	CDN_API_LoadFirmware(state,
+		(u8 *)hdmitx_iram0_get_ptr(),
+		hdmitx_iram0_get_size(),
+		(u8 *)hdmitx_dram0_get_ptr(),
+		hdmitx_dram0_get_size());
+}
+#endif
+
+int hdp_fw_check(state_struct *state)
+{
+	u16 ver, verlib;
+	u8 echo_msg[] = "echo test";
+	u8 echo_resp[sizeof(echo_msg) + 1];
+	int ret;
+
+	ret = CDN_API_General_Test_Echo_Ext_blocking(state, echo_msg, echo_resp,
+		 sizeof(echo_msg), CDN_BUS_TYPE_APB);
+
+	if (0 != strncmp(echo_msg, echo_resp, sizeof(echo_msg))) {
+		DRM_ERROR("CDN_API_General_Test_Echo_Ext_blocking - echo test failed, check firmware!");
+		return -ENXIO;
+	}
+	DRM_INFO("CDN_API_General_Test_Echo_Ext_blocking - APB(ret = %d echo_resp = %s)\n",
+		  ret, echo_resp);
+
+	ret = CDN_API_General_getCurVersion(state, &ver, &verlib);
+	if (ret != 0) {
+		DRM_ERROR("CDN_API_General_getCurVersion - check firmware!\n");
+		return -ENXIO;
+	} else
+		DRM_INFO("CDN_API_General_getCurVersion - ver %d verlib %d\n",
+			 ver, verlib);
+	/* we can add a check here to reject older firmware
+	 * versions if needed */
+
+	return 0;
+}
+
+int hdp_fw_init(state_struct *state)
+{
+	struct imx_hdp *hdp = state_to_imx_hdp(state);
+	u32 core_rate;
+	int ret;
+	u8 sts;
+
+	core_rate = clk_get_rate(hdp->clks.clk_core);
+
+	/* configure the clock */
+	CDN_API_SetClock(state, core_rate/1000000);
+	pr_info("CDN_API_SetClock completed\n");
+
+	/* moved from CDN_API_LoadFirmware */
+	cdn_apb_write(state, APB_CTRL << 2, 0);
+	DRM_INFO("Started firmware!\n");
+
+	ret = CDN_API_CheckAlive_blocking(state);
+	if (ret != 0) {
+		DRM_ERROR("CDN_API_CheckAlive failed - check firmware!\n");
+		return -ENXIO;
+	} else
+		DRM_INFO("CDN_API_CheckAlive returned ret = %d\n", ret);
+
+	/* turn on IP activity */
+	ret = CDN_API_MainControl_blocking(state, 1, &sts);
+	DRM_INFO("CDN_API_MainControl_blocking ret = %d sts = %u\n", ret, sts);
+
+	ret = hdp_fw_check(state);
+	if (ret != 0) {
+		DRM_ERROR("hdmi_fw_check failed!\n");
+		return -ENXIO;
+	}
+
+	if (hdp->is_dp) {
+	/* Line swaping - DP only */
+	       CDN_API_General_Write_Register_blocking(state,
+						ADDR_SOURCD_PHY +
+						(LANES_CONFIG << 2),
+						0x00400000 |
+						hdp->dp_lane_mapping);
+	       DRM_INFO("CDN_API_General_Write_* ... setting LANES_CONFIG\n");
+	}
+	return 0;
+}
+
 static void imx8qm_pixel_link_mux(state_struct *state,
 				  struct drm_display_mode *mode)
 {
@@ -1143,9 +1231,9 @@ static int imx8qm_hdp_swrite(struct hdp_mem *mem,
 
 static struct hdp_ops imx8qm_dp_ops = {
 #ifdef DEBUG_FW_LOAD
-	.fw_load = dp_fw_load,
+	.fw_load = hdp_fw_load,
 #endif
-	.fw_init = dp_fw_init,
+	.fw_init = hdp_fw_init,
 	.phy_init = dp_phy_init,
 	.mode_set = dp_mode_set,
 	.get_edid_block = dp_get_edid_block,
@@ -1169,9 +1257,9 @@ static int imx8qm_hdp_swrite(struct hdp_mem *mem,
 
 static struct hdp_ops imx8qm_hdmi_ops = {
 #ifdef DEBUG_FW_LOAD
-	.fw_load = hdmi_fw_load,
+	.fw_load = hdp_fw_load,
 #endif
-	.fw_init = hdmi_fw_init,
+	.fw_init = hdp_fw_init,
 	.phy_init = hdmi_phy_init_ss28fdsoi,
 	.mode_set = hdmi_mode_set_ss28fdsoi,
 	.get_edid_block = hdmi_get_edid_block,
@@ -1215,6 +1303,7 @@ static int imx8qm_hdp_swrite(struct hdp_mem *mem,
 };
 
 static struct hdp_ops imx8mq_ops = {
+	.fw_init = hdp_fw_check,
 	.phy_init = hdmi_phy_init_t28hpc,
 	.mode_set = hdmi_mode_set_t28hpc,
 	.mode_fixup = hdmi_mode_fixup_t28hpc,
@@ -1234,6 +1323,7 @@ static int imx8qm_hdp_swrite(struct hdp_mem *mem,
 };
 
 static struct hdp_ops imx8mq_dp_ops = {
+	.fw_init = hdp_fw_check,
 	.phy_init = dp_phy_init_t28hpc,
 	.mode_set = dp_mode_set,
 	.get_edid_block = dp_get_edid_block,
@@ -1362,40 +1452,44 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	hdp->no_edid = of_property_read_bool(pdev->dev.of_node, "fsl,no_edid");
 
-	hdp->is_edp = of_property_read_bool(pdev->dev.of_node, "fsl,edp");
-
 	/* EDID function is not supported by iMX8QM A0 */
 	if (cpu_is_imx8qm() && (imx8_get_soc_revision() < B0_SILICON_ID))
 		hdp->no_edid = true;
 
-	ret = of_property_read_u32(pdev->dev.of_node,
-				       "dp-lane-mapping",
-				       &hdp->dp_lane_mapping);
-	if (ret) {
-		hdp->dp_lane_mapping = 0x1b;
-		dev_warn(dev, "Failed to get lane_mapping - using default\n");
-	}
-	dev_info(dev, "dp-lane-mapping 0x%02x\n", hdp->dp_lane_mapping);
+	if (devtype->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+		hdp->is_dp = true;
+		hdp->is_edp = of_property_read_bool(pdev->dev.of_node, "fsl,edp");
 
-	ret = of_property_read_u32(pdev->dev.of_node,
-				       "dp-link-rate",
-				       &hdp->dp_link_rate);
-	if (ret) {
-		hdp->dp_link_rate = AFE_LINK_RATE_1_6;
-		hdp->link_rate = AFE_LINK_RATE_1_6;
-		dev_warn(dev, "Failed to get dp-link-rate - using default\n");
-	} else
-		hdp->link_rate = hdp->dp_link_rate;
-	dev_info(dev, "dp-link-rate 0x%02x\n", hdp->dp_link_rate);
+		ret = of_property_read_u32(pdev->dev.of_node,
+					       "dp-lane-mapping",
+					       &hdp->dp_lane_mapping);
+		if (ret) {
+			hdp->dp_lane_mapping = 0x1b;
+			dev_warn(dev, "Failed to get lane_mapping - using default\n");
+		}
+		dev_info(dev, "dp-lane-mapping 0x%02x\n", hdp->dp_lane_mapping);
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					       "dp-link-rate",
+					       &hdp->dp_link_rate);
+		if (ret) {
+			hdp->dp_link_rate = AFE_LINK_RATE_1_6;
+			hdp->link_rate = AFE_LINK_RATE_1_6;
+			dev_warn(dev, "Failed to get dp-link-rate - using default\n");
+		} else
+			hdp->link_rate = hdp->dp_link_rate;
+		dev_info(dev, "dp-link-rate 0x%02x\n", hdp->dp_link_rate);
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					       "dp-num-lanes",
+					       &hdp->dp_num_lanes);
+		if (ret) {
+			hdp->dp_num_lanes = 4;
+			dev_warn(dev, "Failed to get dp_num_lanes - using default\n");
+		}
+		dev_info(dev, "dp_num_lanes 0x%02x\n", hdp->dp_num_lanes);
 
-	ret = of_property_read_u32(pdev->dev.of_node,
-				       "dp-num-lanes",
-				       &hdp->dp_num_lanes);
-	if (ret) {
-		hdp->dp_num_lanes = 4;
-		dev_warn(dev, "Failed to get dp_num_lanes - using default\n");
 	}
-	dev_info(dev, "dp_num_lanes 0x%02x\n", hdp->dp_num_lanes);
 
 	hdp->audio_type = devtype->audio_type;
 	hdp->ops = devtype->ops;
@@ -1492,7 +1586,9 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 
 	dev_set_drvdata(dev, hdp);
 
-	dp_aux_init(&hdp->state, dev);
+	if (hdp->is_dp) {
+		dp_aux_init(&hdp->state, dev);
+	}
 
 	INIT_DELAYED_WORK(&hdp->hotplug_work, hotplug_work_func);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index 3bf130a9..e771243 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -217,6 +217,7 @@ struct imx_hdp {
 
 	u8 is_cec;
 	u8 is_edp;
+	u8 is_dp;
 	u8 is_digpll_dp_pclock;
 	u8 no_edid;
 	u8 audio_type;
-- 
1.7.9.5


From 41f7922e8795d1660415cbcea9101df5bd0cadea Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Tue, 6 Mar 2018 14:52:35 +0800
Subject: [PATCH 3698/5242] MLK-17631-1 usb: cdns3: gadget: fix deadlock
 during remove gadget module

commit  42a115ca2085e9667702b5c8a42b682f6e053961 from
https://source.codeaurora.org/external/imx/linux-imx.git

For mass_storage gadget, when we remove the module after disconnection,
the request->complete at .ep_dequeue can't be executed, then the
wakeup_thread for certain endpoints is not called, the sleep_thread
will be dead lock.

Signed-off-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/cdns3/gadget.c |   31 ++++++++++++++++++-------------
 1 file changed, 18 insertions(+), 13 deletions(-)

diff --git a/drivers/usb/cdns3/gadget.c b/drivers/usb/cdns3/gadget.c
index dcb332a..14588d3 100644
--- a/drivers/usb/cdns3/gadget.c
+++ b/drivers/usb/cdns3/gadget.c
@@ -1760,27 +1760,32 @@ static int usb_ss_gadget_ep_dequeue(struct usb_ep *ep,
 		to_usb_ss_ep(ep);
 	struct usb_ss_dev *usb_ss = usb_ss_ep->usb_ss;
 	unsigned long flags;
+	struct usb_request *req, *req_temp;
+
+	if (ep == NULL || request == NULL || ep->desc == NULL)
+		return -EINVAL;
 
 	spin_lock_irqsave(&usb_ss->lock, flags);
-	if (!usb_ss->start_gadget) {
-		dev_dbg(&usb_ss->dev,
-			"DEQUEUE at disconnection: %s\n", ep->name);
-		spin_unlock_irqrestore(&usb_ss->lock, flags);
-		return 0;
-	}
 	dev_dbg(&usb_ss->dev, "DEQUEUE(%02X) %d\n",
 		ep->address, request->length);
 	usb_gadget_unmap_request_by_dev(usb_ss->sysdev, request,
 		ep->address & USB_DIR_IN);
 	request->status = -ECONNRESET;
 
-	if (ep->address)
-	list_del(&request->list);
-
-	if (request->complete) {
-		spin_unlock(&usb_ss->lock);
-		request->complete(ep, request);
-		spin_lock(&usb_ss->lock);
+	if (ep->address) {
+		list_for_each_entry_safe(req, req_temp,
+			&usb_ss_ep->request_list, list) {
+			if (request == req) {
+				list_del_init(&request->list);
+				if (request->complete) {
+					spin_unlock(&usb_ss->lock);
+					usb_gadget_giveback_request
+						(&usb_ss_ep->endpoint, request);
+					spin_lock(&usb_ss->lock);
+				}
+				break;
+			}
+		}
 	}
 
 	spin_unlock_irqrestore(&usb_ss->lock, flags);
-- 
1.7.9.5


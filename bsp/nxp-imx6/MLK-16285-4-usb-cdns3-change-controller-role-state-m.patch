From 2f376d0aac0be025e9ffaf2de8ac0dc22b78d811 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Mon, 18 Sep 2017 10:51:00 +0800
Subject: [PATCH 2555/5242] MLK-16285-4 usb: cdns3: change controller role
 state machine

commit  af73fc0bc7104c1ae0f64db3b5fe1ed289656842 from
https://source.codeaurora.org/external/imx/linux-imx.git

Since the USB Type-C port only has two data roles, host and device,
the controller driver can only receive above two events, it can't
remain 'disconnection' state alone at controller driver due to there
is no such event from Type-C.

Due to above, we delete the controller state "CDNS3_ROLE_END" which
stands for 'disconnection' state before. Instead, when we use
"CDNS3_ROLE_GADGET" stands for it, and this state is the default
state for controller.

Signed-off-by: Peter Chen <peter.chen@nxp.com>
Acked-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/cdns3/core.c |   36 +++++++-----------------------------
 drivers/usb/cdns3/core.h |   14 +++-----------
 drivers/usb/cdns3/host.c |    1 -
 3 files changed, 10 insertions(+), 41 deletions(-)

diff --git a/drivers/usb/cdns3/core.c b/drivers/usb/cdns3/core.c
index ddc9fff..f977465 100644
--- a/drivers/usb/cdns3/core.c
+++ b/drivers/usb/cdns3/core.c
@@ -130,9 +130,6 @@ static void cdns_set_role(struct cdns3 *cdns, enum cdns3_roles role)
 	u32 value;
 	int timeout_us = 100000;
 
-	if (role == CDNS3_ROLE_END)
-		return;
-
 	/* Wait clk value */
 	value = readl(cdns->none_core_regs + USB3_SSPHY_STATUS);
 	writel(value, cdns->none_core_regs + USB3_SSPHY_STATUS);
@@ -226,10 +223,8 @@ static enum cdns3_roles cdns3_get_role(struct cdns3 *cdns)
 	if (cdns->roles[CDNS3_ROLE_HOST] && cdns->roles[CDNS3_ROLE_GADGET]) {
 		if (extcon_get_state(cdns->extcon, EXTCON_USB_HOST))
 			return CDNS3_ROLE_HOST;
-		else if (extcon_get_state(cdns->extcon, EXTCON_USB))
-			return CDNS3_ROLE_GADGET;
 		else
-			return CDNS3_ROLE_END;
+			return CDNS3_ROLE_GADGET;
 	} else {
 		return cdns->roles[CDNS3_ROLE_HOST]
 			? CDNS3_ROLE_HOST
@@ -248,7 +243,7 @@ static int cdns3_core_init_role(struct cdns3 *cdns)
 	struct device *dev = cdns->dev;
 	enum usb_dr_mode dr_mode = usb_get_dr_mode(dev);
 
-	cdns->role = CDNS3_ROLE_END;
+	cdns->role = CDNS3_ROLE_GADGET;
 	if (dr_mode == USB_DR_MODE_UNKNOWN)
 		dr_mode = USB_DR_MODE_OTG;
 
@@ -281,13 +276,9 @@ static int cdns3_core_init_role(struct cdns3 *cdns)
 static irqreturn_t cdns3_irq(int irq, void *data)
 {
 	struct cdns3 *cdns = data;
-	irqreturn_t ret = IRQ_NONE;
 
 	/* Handle device/host interrupt */
-	if (cdns->role != CDNS3_ROLE_END)
-		ret = cdns3_role(cdns)->irq(cdns);
-
-	return ret;
+	return cdns3_role(cdns)->irq(cdns);
 }
 
 static int cdns3_get_clks(struct device *dev)
@@ -380,9 +371,6 @@ static int cdsn3_do_role_switch(struct cdns3 *cdns, enum cdns3_roles role)
 		return 0;
 
 	cdns3_role_stop(cdns);
-	if (role == CDNS3_ROLE_END)
-		return 0;
-
 	cdns_set_role(cdns, role);
 	return cdns3_role_start(cdns, role);
 }
@@ -397,18 +385,15 @@ static void cdns3_role_switch(struct work_struct *work)
 {
 	struct cdns3 *cdns = container_of(work, struct cdns3,
 			role_switch_wq);
-	bool is_device, is_host;
+	bool host;
 
-	is_device = extcon_get_state(cdns->extcon, EXTCON_USB_HOST);
-	is_host = extcon_get_state(cdns->extcon, EXTCON_USB);
+	host = extcon_get_state(cdns->extcon, EXTCON_USB_HOST);
 
 	disable_irq(cdns->irq);
-	if (is_device)
+	if (host)
 		cdsn3_do_role_switch(cdns, CDNS3_ROLE_HOST);
-	else if (is_host)
-		cdsn3_do_role_switch(cdns, CDNS3_ROLE_GADGET);
 	else
-		cdsn3_do_role_switch(cdns, CDNS3_ROLE_END);
+		cdsn3_do_role_switch(cdns, CDNS3_ROLE_GADGET);
 	enable_irq(cdns->irq);
 }
 
@@ -440,13 +425,6 @@ static int cdns3_register_extcon(struct cdns3 *cdns)
 			return ret;
 		}
 
-		ret = devm_extcon_register_notifier(dev, extcon,
-			EXTCON_USB, &cdns->extcon_nb);
-		if (ret < 0) {
-			dev_err(dev, "register Device Connector failed\n");
-			return ret;
-		}
-
 		cdns->extcon = extcon;
 		cdns->extcon_nb.notifier_call = cdns3_extcon_notifier;
 	}
diff --git a/drivers/usb/cdns3/core.h b/drivers/usb/cdns3/core.h
index 793d5ccc..1381e9f 100644
--- a/drivers/usb/cdns3/core.h
+++ b/drivers/usb/cdns3/core.h
@@ -25,7 +25,6 @@
 enum cdns3_roles {
 	CDNS3_ROLE_HOST = 0,
 	CDNS3_ROLE_GADGET,
-	CDNS3_ROLE_END,
 };
 
 /**
@@ -69,7 +68,7 @@ struct cdns3 {
 	struct usbss_dev_register_block_type __iomem *dev_regs;
 	void __iomem *none_core_regs;
 	int irq;
-	struct cdns3_role_driver *roles[CDNS3_ROLE_END];
+	struct cdns3_role_driver *roles[CDNS3_ROLE_GADGET + 1];
 	enum cdns3_roles role;
 	struct device *host_dev;
 	struct device *gadget_dev;
@@ -83,7 +82,7 @@ struct cdns3 {
 
 static inline struct cdns3_role_driver *cdns3_role(struct cdns3 *cdns)
 {
-	WARN_ON(cdns->role >= CDNS3_ROLE_END || !cdns->roles[cdns->role]);
+	WARN_ON(!cdns->roles[cdns->role]);
 	return cdns->roles[cdns->role];
 }
 
@@ -91,9 +90,6 @@ static inline int cdns3_role_start(struct cdns3 *cdns, enum cdns3_roles role)
 {
 	int ret;
 
-	if (role >= CDNS3_ROLE_END)
-		return 0;
-
 	if (!cdns->roles[role])
 		return -ENXIO;
 
@@ -108,12 +104,8 @@ static inline void cdns3_role_stop(struct cdns3 *cdns)
 {
 	enum cdns3_roles role = cdns->role;
 
-	if (role == CDNS3_ROLE_END)
-		return;
-
-	cdns->role = CDNS3_ROLE_END;
-
 	cdns->roles[role]->stop(cdns);
+	cdns->role = CDNS3_ROLE_GADGET;
 }
 
 #endif /* __DRIVERS_USB_CDNS3_CORE_H */
diff --git a/drivers/usb/cdns3/host.c b/drivers/usb/cdns3/host.c
index 7b68560..621e96f 100644
--- a/drivers/usb/cdns3/host.c
+++ b/drivers/usb/cdns3/host.c
@@ -174,7 +174,6 @@ static void cdns3_host_stop(struct cdns3 *cdns)
 		xhci = hcd_to_xhci(hcd);
 		usb_remove_hcd(hcd);
 		usb_remove_hcd(xhci->shared_hcd);
-		cdns->role = CDNS3_ROLE_END;
 		synchronize_irq(cdns->irq);
 		usb_put_hcd(hcd);
 		usb_put_hcd(xhci->shared_hcd);
-- 
1.7.9.5


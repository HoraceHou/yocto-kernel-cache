From fb2816a2b82f0aa7c2c20916c1045be248808a3c Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Mon, 27 Nov 2017 16:49:27 +0200
Subject: [PATCH 2981/5242] MLK-16926-3: drm/imx: Add sync-pol to nwl_dsi-imx

commit  1c15f78ac65c3160201458c45350e87df0d2829f from
https://source.codeaurora.org/external/imx/linux-imx.git

Add a new dt property to the nwl_dsi-imx driver: sync-pol.
This property represents the sync polarity of the input signal to it's
internal DPI-to-DSI block.

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Reviewed-by: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/display/imx/dsi_nwl.txt    |    4 ++++
 drivers/gpu/drm/imx/nwl_dsi-imx.c                  |   24 ++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt b/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt
index 296b01b..76441b2 100644
--- a/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt
+++ b/Documentation/devicetree/bindings/display/imx/dsi_nwl.txt
@@ -42,6 +42,10 @@ Optional properties:
 			and i.MX8qxp for the reset functions)
 - assigned-clock-parents phandles to parent clocks that needs to be assigned as
 			parents to clocks defined in assigned-clocks
+- sync-pol		horizontal and vertical sync polarity of the input
+			signal; can be <0> for LOW (negative) or <1> for HIGH
+			(positive) polarity; default value is <0>, when this
+			property is ommited
 
 Example:
 	mipi_dsi1: mipi_dsi {
diff --git a/drivers/gpu/drm/imx/nwl_dsi-imx.c b/drivers/gpu/drm/imx/nwl_dsi-imx.c
index 95ae7383..0d19649 100644
--- a/drivers/gpu/drm/imx/nwl_dsi-imx.c
+++ b/drivers/gpu/drm/imx/nwl_dsi-imx.c
@@ -89,6 +89,7 @@ struct imx_mipi_dsi {
 	unsigned long			bit_clk;
 	u32				phyref_rate;
 	u32				instance;
+	u32				sync_pol;
 	bool				enabled;
 };
 
@@ -501,6 +502,22 @@ static void imx_nwl_dsi_disable(struct imx_mipi_dsi *dsi)
 	dsi->enabled = false;
 }
 
+static void imx_nwl_update_sync_polarity(unsigned int *flags, u32 sync_pol)
+{
+	/* Make sure all flags are set-up accordingly */
+	if (sync_pol) {
+		*flags |= DRM_MODE_FLAG_PHSYNC;
+		*flags |= DRM_MODE_FLAG_PVSYNC;
+		*flags &= ~DRM_MODE_FLAG_NHSYNC;
+		*flags &= ~DRM_MODE_FLAG_NVSYNC;
+	} else {
+		*flags &= ~DRM_MODE_FLAG_PHSYNC;
+		*flags &= ~DRM_MODE_FLAG_PVSYNC;
+		*flags |= DRM_MODE_FLAG_NHSYNC;
+		*flags |= DRM_MODE_FLAG_NVSYNC;
+	}
+}
+
 /*
  * This function will try the required phy speed for current mode
  * If the phy speed can be achieved, the phy will save the speed
@@ -574,8 +591,10 @@ static int imx_nwl_dsi_encoder_atomic_check(struct drm_encoder *encoder,
 {
 	struct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);
 	struct imx_mipi_dsi *dsi = encoder_to_dsi(encoder);
+	unsigned int *flags = &crtc_state->adjusted_mode.flags;
 
 	imx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB101010_1X30;
+	imx_nwl_update_sync_polarity(flags, dsi->sync_pol);
 
 	/* Try to see if the phy can satisfy the current mode */
 	return imx_nwl_try_phy_speed(dsi, &crtc_state->adjusted_mode);
@@ -619,6 +638,9 @@ static bool imx_nwl_dsi_bridge_mode_fixup(struct drm_bridge *bridge,
 			   struct drm_display_mode *adjusted_mode)
 {
 	struct imx_mipi_dsi *dsi = bridge->driver_private;
+	unsigned int *flags = &adjusted_mode->flags;
+
+	imx_nwl_update_sync_polarity(flags, dsi->sync_pol);
 
 	return (imx_nwl_try_phy_speed(dsi, adjusted_mode) == 0);
 }
@@ -725,6 +747,8 @@ static int imx_nwl_dsi_parse_of(struct device *dev, bool as_bridge)
 	dsi->tx_ulps_reg = devtype->tx_ulps_reg;
 	dsi->pxl2dpi_reg = devtype->pxl2dpi_reg;
 
+	of_property_read_u32(np, "sync-pol", &dsi->sync_pol);
+
 	/* Look for optional regmaps */
 	dsi->csr = syscon_regmap_lookup_by_phandle(np, "csr");
 	if (IS_ERR(dsi->csr) && (devtype->ext_regs & IMX_REG_CSR)) {
-- 
1.7.9.5


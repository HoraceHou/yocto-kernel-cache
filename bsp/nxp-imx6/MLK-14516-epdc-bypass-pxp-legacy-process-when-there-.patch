From 5911dc4d76d66128259baf060263d17e3745162a Mon Sep 17 00:00:00 2001
From: Robby Cai <robby.cai@nxp.com>
Date: Thu, 9 Mar 2017 21:42:04 +0800
Subject: [PATCH 1699/5242] MLK-14516 epdc: bypass pxp legacy process when
 there's no transformation

commit  8212bf924aabd68a0ed789031ce0d83ad6f2ad51 from
https://source.codeaurora.org/external/imx/linux-imx.git

when there's no transform (Y8 format in framebuffer, no rotation,
no look-up transformation such as CMAP, no scaling/flip, etc.)
and no dithering, bypass pxp legacy process to save time.

Signed-off-by: Robby Cai <robby.cai@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c |   39 ++++++++++++++++++++----------
 1 file changed, 26 insertions(+), 13 deletions(-)

diff --git a/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c b/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
index 9f6140a..36ae604 100644
--- a/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
+++ b/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
@@ -2760,6 +2760,8 @@ static void epdc_submit_work_func(struct work_struct *work)
 	struct update_marker_data *next_marker, *temp_marker;
 	struct mxc_epdc_fb_data *fb_data =
 		container_of(work, struct mxc_epdc_fb_data, epdc_submit_work);
+	struct pxp_config_data *pxp_conf = &fb_data->pxp_conf;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
 	struct update_data_list *upd_data_list = NULL;
 	struct mxcfb_rect adj_update_region, *upd_region;
 	bool end_merge = false;
@@ -2907,22 +2909,22 @@ static void epdc_submit_work_func(struct work_struct *work)
 	 *   - FB unrotated
 	 *   - FB pixel format = 8-bit grayscale
 	 *   - No look-up transformations (inversion, posterization, etc.)
-	 *
-	 * Note: A bug with EPDC stride prevents us from skipping
-	 * PxP in versions 2.0 and earlier of EPDC.
+	 *   - No scaling/flip
 	 */
-	is_transform = upd_data_list->update_desc->upd_data.flags &
+	is_transform = ((upd_data_list->update_desc->upd_data.flags &
 		(EPDC_FLAG_ENABLE_INVERSION | EPDC_FLAG_USE_DITHERING_Y1 |
 		EPDC_FLAG_USE_DITHERING_Y4 | EPDC_FLAG_FORCE_MONOCHROME |
-		EPDC_FLAG_USE_CMAP) ? true : false;
+		EPDC_FLAG_USE_CMAP)) && (proc_data->scaling == 0) &&
+		(proc_data->hflip == 0) && (proc_data->vflip == 0)) ?
+		true : false;
 
 	/*XXX if we use external mode, we should first use pxp
 	 * to update upd buffer data to working buffer first.
 	 */
 	if ((fb_data->epdc_fb_var.rotate == FB_ROTATE_UR) &&
 		(fb_data->epdc_fb_var.grayscale == GRAYSCALE_8BIT) &&
-		!is_transform && (fb_data->rev > 20) &&
-		!fb_data->restrict_width && !fb_data->epdc_wb_mode) {
+		!is_transform && (proc_data->dither_mode == 0) &&
+		!fb_data->restrict_width) {
 
 		/* If needed, enable EPDC HW while ePxP is processing */
 		if ((fb_data->power_state == POWER_STATE_OFF)
@@ -6315,6 +6317,7 @@ static int pxp_wfe_a_process(struct mxc_epdc_fb_data *fb_data,
 	u32 wv_mode = upd_data_list->update_desc->upd_data.waveform_mode;
 	int i, j = 0, ret;
 	int length;
+	bool is_transform;
 
 	dev_dbg(fb_data->dev, "Starting PxP WFE_A process.\n");
 
@@ -6392,12 +6395,22 @@ static int pxp_wfe_a_process(struct mxc_epdc_fb_data *fb_data,
 	if (proc_data->dither_mode) {
 		pxp_conf->wfe_a_fetch_param[0].paddr = fb_data->phys_addr_y4;
 	} else {
-#ifdef USE_PS_AS_OUTPUT
-	pxp_conf->wfe_a_fetch_param[0].paddr = upd_data_list->phys_addr + upd_data_list->update_desc->epdc_offs;
-
-#else
-	pxp_conf->wfe_a_fetch_param[0].paddr = sg_dma_address(&sg[0]);
-#endif
+		is_transform = ((upd_data_list->update_desc->upd_data.flags &
+			(EPDC_FLAG_ENABLE_INVERSION | EPDC_FLAG_USE_DITHERING_Y1 |
+			EPDC_FLAG_USE_DITHERING_Y4 | EPDC_FLAG_FORCE_MONOCHROME |
+			EPDC_FLAG_USE_CMAP)) && (proc_data->scaling == 0) &&
+			(proc_data->hflip == 0) && (proc_data->vflip == 0)) ?
+			true : false;
+
+		if ((fb_data->epdc_fb_var.rotate == FB_ROTATE_UR) &&
+			(fb_data->epdc_fb_var.grayscale == GRAYSCALE_8BIT) &&
+			!is_transform && (proc_data->dither_mode == 0) &&
+			!fb_data->restrict_width) {
+				pxp_conf->wfe_a_fetch_param[0].paddr =
+					sg_dma_address(&sg[0]);
+		} else
+			pxp_conf->wfe_a_fetch_param[0].paddr =
+				upd_data_list->phys_addr + upd_data_list->update_desc->epdc_offs;
 	}
 
 	/* fetch1 is working buffer */
-- 
1.7.9.5


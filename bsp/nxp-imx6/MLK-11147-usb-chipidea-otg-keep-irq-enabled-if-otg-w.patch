From 60fb42f353193cf3579c2ab0cc1c3fb1a77abd3d Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@freescale.com>
Date: Tue, 23 Jun 2015 10:46:44 +0800
Subject: [PATCH 0152/5242] MLK-11147 usb: chipidea: otg: keep irq enabled if
 otg work had been queued

commit  9d5743033dbacaefa71a07a550447e997d9f6b62 from
https://source.codeaurora.org/external/imx/linux-imx.git

If the otg work had been queued, current code will disable irq again
but the otg work will be done only once, so the irq enable and disable
cannot be balanced, this patch is to fix this.

Signed-off-by: Li Jun <b47624@freescale.com>
(cherry picked from commit 0d5c0888eaec17289e40968d7d15b92b781ed34f)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/chipidea/otg.h |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/chipidea/otg.h b/drivers/usb/chipidea/otg.h
index 829ed67..89836d3 100644
--- a/drivers/usb/chipidea/otg.h
+++ b/drivers/usb/chipidea/otg.h
@@ -18,12 +18,12 @@
 void ci_handle_vbus_connected(struct ci_hdrc *ci);
 static inline void ci_otg_queue_work(struct ci_hdrc *ci)
 {
-	WARN_ON(!ci->wq);
-
-	disable_irq_nosync(ci->irq);
 	if (ci->wq) {
+		disable_irq_nosync(ci->irq);
 		if (queue_work(ci->wq, &ci->work) == false)
 			enable_irq(ci->irq);
+	} else {
+		WARN_ON(!ci->wq);
 	}
 }
 
-- 
1.7.9.5


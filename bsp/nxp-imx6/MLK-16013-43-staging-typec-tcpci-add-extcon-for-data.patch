From 13ac6c18e0494d9936c5c97a1da7f0587e1aebbc Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Sat, 19 Aug 2017 02:32:48 +0800
Subject: [PATCH 2452/5242] MLK-16013-43 staging: typec: tcpci: add extcon for
 data role switch

commit  b25bbcfac521e4472b27d5eb3477076500fe50b7 from
https://source.codeaurora.org/external/imx/linux-imx.git

Use extcon device for dual role switch on typec port.

Acked-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/staging/typec/tcpci.c |   68 ++++++++++++++++++++++++++++-------------
 1 file changed, 47 insertions(+), 21 deletions(-)

diff --git a/drivers/staging/typec/tcpci.c b/drivers/staging/typec/tcpci.c
index a069e9b..d1e55db 100644
--- a/drivers/staging/typec/tcpci.c
+++ b/drivers/staging/typec/tcpci.c
@@ -15,6 +15,7 @@
 #include <linux/usb/tcpm.h>
 #include <linux/usb/typec.h>
 #include <linux/of_gpio.h>
+#include <linux/extcon.h>
 
 #include "tcpci.h"
 
@@ -22,6 +23,7 @@
 
 struct tcpci {
 	struct device *dev;
+	struct extcon_dev *edev;
 
 	struct tcpm_port *port;
 
@@ -40,6 +42,11 @@ struct tcpci_chip {
 	struct tcpci_data data;
 };
 
+static const unsigned int tcpci_extcon_cable[] = {
+	EXTCON_USB_HOST,
+	EXTCON_NONE,
+};
+
 static inline struct tcpci *tcpc_to_tcpci(struct tcpc_dev *tcpc)
 {
 	return container_of(tcpc, struct tcpci, tcpc);
@@ -319,6 +326,11 @@ static int tcpci_set_roles(struct tcpc_dev *tcpc, bool attached,
 	if (ret < 0)
 		return ret;
 
+	if (data == TYPEC_HOST)
+		extcon_set_state_sync(tcpci->edev, EXTCON_USB_HOST, true);
+	else
+		extcon_set_state_sync(tcpci->edev, EXTCON_USB_HOST, false);
+
 	return 0;
 }
 
@@ -719,6 +731,27 @@ static int tcpci_parse_config(struct tcpci *tcpci)
 	return ret;
 }
 
+static int tcpci_ss_mux_control_init(struct tcpci *tcpci)
+{
+	struct device *dev = tcpci->dev;
+	int retval = 0;
+
+	tcpci->ss_sel_gpio = of_get_named_gpio(dev->of_node,
+						"ss-sel-gpios", 0);
+	if (!gpio_is_valid(tcpci->ss_sel_gpio)) {
+		/* Super speed signal mux conrol gpio is optional */
+		dev_dbg(dev, "no Super Speed mux gpio pin available");
+	} else {
+		retval = devm_gpio_request_one(dev, tcpci->ss_sel_gpio,
+				GPIOF_OUT_INIT_LOW, "typec_ss_sel");
+		if (retval < 0)
+			dev_err(dev, "Unable to request super speed mux gpio %d\n",
+									retval);
+	}
+
+	return retval;
+}
+
 struct tcpci *tcpci_register_port(struct device *dev, struct tcpci_data *data)
 {
 	struct tcpci *tcpci;
@@ -750,6 +783,20 @@ struct tcpci *tcpci_register_port(struct device *dev, struct tcpci_data *data)
 	tcpci->tcpc.set_roles = tcpci_set_roles;
 	tcpci->tcpc.pd_transmit = tcpci_pd_transmit;
 
+	/* Allocate extcon device */
+	tcpci->edev = devm_extcon_dev_allocate(&client->dev,
+					tcpci_extcon_cable);
+	if (IS_ERR(tcpci->edev)) {
+		dev_err(&client->dev, "failed to allocate extcon dev.\n");
+		return -ENOMEM;
+	}
+
+	err = devm_extcon_dev_register(&client->dev, tcpci->edev);
+	if (err) {
+		dev_err(&client->dev, "failed to register extcon dev.\n");
+		return err;
+	}
+
 	err = tcpci_parse_config(tcpci);
 	if (err < 0)
 		return ERR_PTR(err);
@@ -772,27 +819,6 @@ void tcpci_unregister_port(struct tcpci *tcpci)
 }
 EXPORT_SYMBOL_GPL(tcpci_unregister_port);
 
-static int tcpci_ss_mux_control_init(struct tcpci *tcpci)
-{
-	struct device *dev = tcpci->dev;
-	int retval = 0;
-
-	tcpci->ss_sel_gpio = of_get_named_gpio(dev->of_node,
-						"ss-sel-gpios", 0);
-	if (!gpio_is_valid(tcpci->ss_sel_gpio)) {
-		/* Super speed signal mux conrol gpio is optional */
-		dev_dbg(dev, "no Super Speed mux gpio pin available");
-	} else {
-		retval = devm_gpio_request_one(dev, tcpci->ss_sel_gpio,
-				GPIOF_OUT_INIT_LOW, "typec_ss_sel");
-		if (retval < 0)
-			dev_err(dev, "Unable to request super speed mux gpio %d\n",
-									retval);
-	}
-
-	return retval;
-}
-
 static int tcpci_probe(struct i2c_client *client,
 		       const struct i2c_device_id *i2c_id)
 {
-- 
1.7.9.5


From f0a872ea85c454631e6f3f96dd1ddb2e5c25701f Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Wed, 8 Jun 2016 18:52:38 +0800
Subject: [PATCH 1085/5242] MLK-12890 rtc: snvs: update time read function

commit  19f5771128345ed749e1514caa443a5edab33855 from
https://source.codeaurora.org/external/imx/linux-imx.git

When CPU/AXI/AHB are running at 24MHz, IPG at
12MHz, two consecutive reads of RTC timer registers
never get same value, so we need to skip the low
15 bits, only make sure the second value are same
during two consecutive reads.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/rtc/rtc-snvs.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/rtc/rtc-snvs.c b/drivers/rtc/rtc-snvs.c
index 8a75cc3..8888d40 100644
--- a/drivers/rtc/rtc-snvs.c
+++ b/drivers/rtc/rtc-snvs.c
@@ -57,7 +57,12 @@ static u32 rtc_read_lp_counter(struct snvs_rtc_data *data)
 		read2 <<= 32;
 		regmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &val);
 		read2 |= val;
-	} while (read1 != read2);
+	/*
+	 * when CPU/BUS are running at low speed, there is chance that
+	 * we never get same value during two consecutive read, so here
+	 * we only compare the second value.
+	 */
+	} while ((read1 >> CNTR_TO_SECS_SH) != (read2 >> CNTR_TO_SECS_SH));
 
 	/* Convert 47-bit counter to 32-bit raw second count */
 	return (u32) (read1 >> CNTR_TO_SECS_SH);
-- 
1.7.9.5


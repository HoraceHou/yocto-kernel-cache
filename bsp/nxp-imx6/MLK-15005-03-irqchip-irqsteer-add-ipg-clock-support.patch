From fa5603ce8097ab2ecc1654aad7cb5ce435a4ca8d Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Mon, 5 Jun 2017 11:31:10 +0800
Subject: [PATCH 1845/5242] MLK-15005-03 irqchip: irqsteer: add ipg clock
 support

commit  b0dc844137d48dc1fa0d20e7fb7f087477027c9b from
https://source.codeaurora.org/external/imx/linux-imx.git

Some subsystems have lpcg sw_bit to control the ipg_clk to LIS,
so add the ipg clock for the module.

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../interrupt-controller/nxp,imx-irqsteer.txt      |    1 +
 drivers/irqchip/irq-imx-irqsteer.c                 |   16 ++++++++++++++++
 2 files changed, 17 insertions(+)

diff --git a/Documentation/devicetree/bindings/interrupt-controller/nxp,imx-irqsteer.txt b/Documentation/devicetree/bindings/interrupt-controller/nxp,imx-irqsteer.txt
index 8e33f10..671622c 100644
--- a/Documentation/devicetree/bindings/interrupt-controller/nxp,imx-irqsteer.txt
+++ b/Documentation/devicetree/bindings/interrupt-controller/nxp,imx-irqsteer.txt
@@ -3,6 +3,7 @@
 Required properties:
 - compatible: "nxp,imx-irqsteer".
 - reg: should contain IC registers location and length.
+- clocks : ipg clock for irqsteer.
 - interrupts: an interrupt to the parent interrupt controller.
 - interrupt-controller: identifies the node as an interrupt controller.
 - interrupt-parent: gic interrupt controller, link to parent
diff --git a/drivers/irqchip/irq-imx-irqsteer.c b/drivers/irqchip/irq-imx-irqsteer.c
index f2affac..1a961f4 100644
--- a/drivers/irqchip/irq-imx-irqsteer.c
+++ b/drivers/irqchip/irq-imx-irqsteer.c
@@ -8,6 +8,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
@@ -27,6 +28,7 @@ struct irqsteer_irqchip_data {
 	spinlock_t lock;
 	struct platform_device	*pdev;
 	void __iomem *regs;
+	struct clk *ipg_clk;
 	int irq;
 	int channum;
 	struct irq_domain *domain;
@@ -170,10 +172,23 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	irqsteer_data->ipg_clk = devm_clk_get(&pdev->dev, "ipg");
+	if (IS_ERR(irqsteer_data->ipg_clk)) {
+		ret = PTR_ERR(irqsteer_data->ipg_clk);
+		dev_err(&pdev->dev, "failed to get ipg clk: %d\n", ret);
+		return ret;
+	}
+
 	irqsteer_data->channum = channum;
 	irqsteer_data->pdev = pdev;
 	spin_lock_init(&irqsteer_data->lock);
 
+	ret = clk_prepare_enable(irqsteer_data->ipg_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable ipg clk: %d\n", ret);
+		return ret;
+	}
+
 	imx_irqsteer_init(irqsteer_data);
 
 	irqsteer_data->domain = irq_domain_add_linear(np,
@@ -204,6 +219,7 @@ static int imx_irqsteer_remove(struct platform_device *pdev)
 	irq_domain_remove(irqsteer_data->domain);
 
 	platform_set_drvdata(pdev, NULL);
+	clk_disable_unprepare(irqsteer_data->ipg_clk);
 
 	return 0;
 }
-- 
1.7.9.5


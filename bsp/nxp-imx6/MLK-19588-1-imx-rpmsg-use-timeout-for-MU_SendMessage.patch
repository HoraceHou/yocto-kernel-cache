From 956a9ca20099cef11d57c8836cedbebdb08a0e39 Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Fri, 14 Sep 2018 16:29:58 +0800
Subject: [PATCH 4652/5242] MLK-19588-1 imx: rpmsg: use timeout for
 MU_SendMessage function

commit  76bc2c5c62aecf15d3c9062bd593e247d9247add from
https://source.codeaurora.org/external/imx/linux-imx.git

- Add the timeout mu msg send api.
- Use the timeout mu send message function to do the
notification when multi-vdev is enabled on one channel.

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/rpmsg/imx_rpmsg.c   |    9 +++++++--
 drivers/soc/imx/mu/mx8_mu.c |   31 +++++++++++++++++++++++++++++++
 include/linux/mx8_mu.h      |    1 +
 3 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/drivers/rpmsg/imx_rpmsg.c b/drivers/rpmsg/imx_rpmsg.c
index 7b6e772..4fed5b0 100644
--- a/drivers/rpmsg/imx_rpmsg.c
+++ b/drivers/rpmsg/imx_rpmsg.c
@@ -121,8 +121,13 @@ static bool imx_rpmsg_notify(struct virtqueue *vq)
 
 	mu_rpmsg = rpvq->vq_id << 16;
 	mutex_lock(&rpvq->rpdev->lock);
-	/* send the index of the triggered virtqueue as the mu payload */
-	MU_SendMessage(rpvq->rpdev->mu_base, 1, mu_rpmsg);
+	/*
+	 * Send the index of the triggered virtqueue as the mu payload.
+	 * Use the timeout MU send message here.
+	 * Since that M4 core may not be loaded, and the first MSG may
+	 * not be handled by M4 when multi-vdev is enabled.
+	 */
+	MU_SendMessageTimeout(rpvq->rpdev->mu_base, 1, mu_rpmsg, 200);
 	mutex_unlock(&rpvq->rpdev->lock);
 
 	return true;
diff --git a/drivers/soc/imx/mu/mx8_mu.c b/drivers/soc/imx/mu/mx8_mu.c
index 30c7fd8..2cd6dc8 100644
--- a/drivers/soc/imx/mu/mx8_mu.c
+++ b/drivers/soc/imx/mu/mx8_mu.c
@@ -5,6 +5,7 @@
  * SPDX-License-Identifier:     GPL-2.0+
  */
 
+#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/mx8_mu.h>
@@ -103,6 +104,36 @@ void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg)
 	}
 }
 
+/*
+ * Wait and send message to the other core with timeout mechanism.
+ */
+void MU_SendMessageTimeout(void __iomem *base, uint32_t regIndex, uint32_t msg,
+		uint32_t t)
+{
+	uint32_t mask = MU_SR_TE0_MASK1 >> regIndex;
+	uint32_t timeout = t;
+
+	if (unlikely(version == MU_VER_ID_V10)) {
+		/* Wait TX register to be empty. */
+		while (!(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask)) {
+			udelay(10);
+			if (timeout-- == 0)
+				return;
+		};
+
+		writel_relaxed(msg, base + MU_V10_ATR0_OFFSET1
+			       + (regIndex * 4));
+	} else {
+		/* Wait TX register to be empty. */
+		while (!(readl_relaxed(base + MU_ASR_OFFSET1) & mask)) {
+			udelay(10);
+			if (timeout-- == 0)
+				return;
+		};
+
+		writel_relaxed(msg, base + MU_ATR0_OFFSET1  + (regIndex * 4));
+	}
+}
 
 /*
  * Wait to receive message from the other core.
diff --git a/include/linux/mx8_mu.h b/include/linux/mx8_mu.h
index a26d2c6..b31e526 100644
--- a/include/linux/mx8_mu.h
+++ b/include/linux/mx8_mu.h
@@ -39,6 +39,7 @@
 
 void MU_Init(void __iomem *base);
 void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg);
+void MU_SendMessageTimeout(void __iomem *base, uint32_t regIndex, uint32_t msg, uint32_t t);
 void MU_ReceiveMsg(void __iomem *base, uint32_t regIndex, uint32_t *msg);
 void MU_EnableGeneralInt(void __iomem *base, uint32_t index);
 void MU_EnableRxFullInt(void __iomem *base, uint32_t index);
-- 
1.7.9.5


From d28f2b20510988ba42c38fdbc033bee3e335080f Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Tue, 7 Nov 2017 21:32:51 +0800
Subject: [PATCH 2756/5242] MLK-16776 staging: typec: tcpci: use vbus from
 partner for EXTCON_USB

commit  54dd46dd754fc658d02e7deeb96d8dab90f5be51 from
https://source.codeaurora.org/external/imx/linux-imx.git

Change to use the vbus from partner to notify EXTCON_USB.
This is to work around the case of source only typec port
connecting to Host PC via a Rp fixed cable.

Acked-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/staging/typec/tcpci.c |   36 ++++++++++++++++++------------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/drivers/staging/typec/tcpci.c b/drivers/staging/typec/tcpci.c
index 7903313..6fd6bd9 100644
--- a/drivers/staging/typec/tcpci.c
+++ b/drivers/staging/typec/tcpci.c
@@ -30,7 +30,7 @@ struct tcpci {
 	struct regmap *regmap;
 
 	bool controls_vbus;
-	bool attached;
+	bool drive_vbus;
 	struct gpio_desc *ss_sel_gpio;
 
 	struct tcpc_dev tcpc;
@@ -263,11 +263,6 @@ static int tcpci_get_cc(struct tcpc_dev *tcpc,
 				 TCPC_CC_STATUS_CC2_MASK,
 				 reg & TCPC_CC_STATUS_TERM);
 
-	if ((*cc1 == TYPEC_CC_OPEN) && (*cc2 == TYPEC_CC_OPEN))
-		tcpci->attached = false;
-	else
-		tcpci->attached = true;
-
 	return 0;
 }
 
@@ -336,19 +331,10 @@ static int tcpci_set_roles(struct tcpc_dev *tcpc, bool attached,
 	if (ret < 0)
 		return ret;
 
-	if (data == TYPEC_HOST) {
-		extcon_set_state_sync(tcpci->edev, EXTCON_USB, false);
+	if (data == TYPEC_HOST)
 		extcon_set_state_sync(tcpci->edev, EXTCON_USB_HOST, true);
-	} else {
+	else
 		extcon_set_state_sync(tcpci->edev, EXTCON_USB_HOST, false);
-		/*
-		 * Instead of use 'attached' input, we need
-		 * the real HW connection status to notify
-		 * USB device controller driver the attach
-		 * and dettach event to host.
-		 */
-		extcon_set_state_sync(tcpci->edev, EXTCON_USB, tcpci->attached);
-	}
 
 	return 0;
 }
@@ -378,7 +364,19 @@ static int tcpci_get_vbus(struct tcpc_dev *tcpc)
 	if (ret < 0)
 		return ret;
 
-	return !!(reg & TCPC_POWER_STATUS_VBUS_PRES);
+	ret = !!(reg & TCPC_POWER_STATUS_VBUS_PRES);
+
+	/*
+	 * If the vbus is not from itself for source, we
+	 * assume the vbus is from the port partner, this
+	 * is to work around the case of connect to legacy
+	 * Host like PC via a fixed Rp pull up cable, so
+	 * we notify the possible EXTCON_USB connection.
+	 */
+	if (!tcpci->drive_vbus)
+		extcon_set_state_sync(tcpci->edev, EXTCON_USB, ret);
+
+	return ret;
 }
 
 static unsigned int tcpci_get_vbus_vol(struct tcpc_dev *tcpc)
@@ -409,6 +407,7 @@ static int tcpci_set_vbus(struct tcpc_dev *tcpc, bool source, bool sink)
 		if (ret < 0)
 			return ret;
 
+		tcpci->drive_vbus = false;
 		/* Enable force discharge */
 		tcpci_vbus_force_discharge(tcpc, true);
 	}
@@ -425,6 +424,7 @@ static int tcpci_set_vbus(struct tcpc_dev *tcpc, bool source, bool sink)
 				   TCPC_CMD_SRC_VBUS_DEFAULT);
 		if (ret < 0)
 			return ret;
+		tcpci->drive_vbus = true;
 	}
 
 	if (sink) {
-- 
1.7.9.5


From 5a76b7e0709a757a655c1931d862ed0f9909d5f2 Mon Sep 17 00:00:00 2001
From: Anson Huang <Anson.Huang@nxp.com>
Date: Wed, 29 Mar 2017 00:07:57 +0800
Subject: [PATCH 1617/5242] MLK-14534-1 cpufreq: imx8: add cpu-freq support

commit  331a4ac3dd5efadb8c02f048026b8c19da080a9c from
https://source.codeaurora.org/external/imx/linux-imx.git

Add multi-clusters cpu-freq driver support for i.MX8,
only support cpu-freq get now.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/cpufreq/Kconfig.arm    |    8 ++
 drivers/cpufreq/Makefile       |    1 +
 drivers/cpufreq/imx8-cpufreq.c |  183 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 192 insertions(+)
 create mode 100644 drivers/cpufreq/imx8-cpufreq.c

diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index e85b04a..e758434 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -113,6 +113,14 @@ config ARM_IMX7ULP_CPUFREQ
 
 	  If in doubt, say N.
 
+config ARM_IMX8_CPUFREQ
+	tristate "NXP i.MX8 cpufreq support"
+	select PM_OPP
+	help
+	  This adds cpufreq driver support for NXP i.MX8 series SoCs.
+
+	  If in doubt, say N.
+
 config ARM_KIRKWOOD_CPUFREQ
 	def_bool MACH_KIRKWOOD
 	help
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index cdebcc4..48369ee 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -60,6 +60,7 @@ obj-$(CONFIG_ARM_EXYNOS5440_CPUFREQ)	+= exynos5440-cpufreq.o
 obj-$(CONFIG_ARM_HIGHBANK_CPUFREQ)	+= highbank-cpufreq.o
 obj-$(CONFIG_ARM_IMX6Q_CPUFREQ)		+= imx6q-cpufreq.o
 obj-$(CONFIG_ARM_IMX7ULP_CPUFREQ)	+= imx7ulp-cpufreq.o
+obj-$(CONFIG_ARM_IMX8_CPUFREQ)		+= imx8-cpufreq.o
 obj-$(CONFIG_ARM_KIRKWOOD_CPUFREQ)	+= kirkwood-cpufreq.o
 obj-$(CONFIG_ARM_MEDIATEK_CPUFREQ)	+= mediatek-cpufreq.o
 obj-$(CONFIG_MACH_MVEBU_V7)		+= mvebu-cpufreq.o
diff --git a/drivers/cpufreq/imx8-cpufreq.c b/drivers/cpufreq/imx8-cpufreq.c
new file mode 100644
index 0000000..46f1800
--- /dev/null
+++ b/drivers/cpufreq/imx8-cpufreq.c
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/pm_opp.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#define MAX_CLUSTER_NUM	2
+
+struct imx8_cpufreq {
+	struct clk	*cpu_clk;
+};
+
+struct imx8_cpufreq cluster_freq[MAX_CLUSTER_NUM];
+static struct cpufreq_frequency_table *freq_table[MAX_CLUSTER_NUM];
+static unsigned int transition_latency[MAX_CLUSTER_NUM];
+
+static int imx8_set_target(struct cpufreq_policy *policy, unsigned int index)
+{
+	return 0;
+}
+
+static int imx8_cpufreq_init(struct cpufreq_policy *policy)
+{
+	int cluster_id = topology_physical_package_id(policy->cpu);
+	int ret = 0;
+
+	policy->clk = cluster_freq[cluster_id].cpu_clk;
+	policy->cur = clk_get_rate(cluster_freq[cluster_id].cpu_clk) / 1000;
+
+	pr_info("%s: cluster %d running at freq %d MHz\n",
+		__func__, cluster_id, policy->cur / 1000);
+	/*
+	 * The driver only supports the SMP configuartion where all processors
+	 * share the clock and voltage and clock.
+	 */
+	cpumask_copy(policy->cpus, topology_core_cpumask(policy->cpu));
+
+	ret = cpufreq_table_validate_and_show(policy, freq_table[cluster_id]);
+	if (ret) {
+		pr_err("%s: invalid frequency table: %d\n", __func__, ret);
+		return ret;
+	}
+
+	policy->cpuinfo.transition_latency = transition_latency[cluster_id];
+
+	return ret;
+}
+
+static struct cpufreq_driver imx8_cpufreq_driver = {
+	.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+	.verify = cpufreq_generic_frequency_table_verify,
+	.target_index = imx8_set_target,
+	.get = cpufreq_generic_get,
+	.init = imx8_cpufreq_init,
+	.name = "imx8-cpufreq",
+	.attr = cpufreq_generic_attr,
+};
+
+static int imx8_cpufreq_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct device *cpu_dev;
+	int ret = 0;
+	int i, cluster_id;
+
+	cpu_dev = get_cpu_device(0);
+
+	if (!cpu_dev) {
+		pr_err("failed to get cpu device 0\n");
+		return -ENODEV;
+	}
+
+	np = of_node_get(cpu_dev->of_node);
+	if (!np) {
+		pr_warn("failed to find cpu 0 node\n");
+		return -ENODEV;
+	}
+
+	ret = dev_pm_opp_of_add_table(cpu_dev);
+	if (ret < 0) {
+		dev_err(cpu_dev, "failed to init OPP table: %d\n", ret);
+		goto put_node;
+	}
+
+	cluster_id = topology_physical_package_id(0);
+	cluster_freq[cluster_id].cpu_clk = devm_clk_get(cpu_dev, NULL);
+	if (IS_ERR(cluster_freq[cluster_id].cpu_clk)) {
+		dev_err(cpu_dev, "failed to get cluster %d clock\n", cluster_id);
+		ret = -ENOENT;
+		goto put_node;
+	}
+
+	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table[cluster_id]);
+	if (ret) {
+		dev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);
+		goto put_node;
+	}
+
+	if (of_property_read_u32(np, "clock-latency", &transition_latency[cluster_id]))
+		transition_latency[cluster_id] = CPUFREQ_ETERNAL;
+
+	/* init next cluster if there is */
+	for (i = 1; i < num_online_cpus(); i++) {
+		if (topology_physical_package_id(i) == topology_physical_package_id(0))
+			continue;
+		cpu_dev = get_cpu_device(i);
+		if (!cpu_dev) {
+			pr_err("failed to get cpu device %d\n", i);
+				return -ENODEV;
+		}
+
+		np = of_node_get(cpu_dev->of_node);
+		if (!np) {
+			pr_warn("failed to find cpu %d node\n", i);
+			ret = -ENODEV;
+			goto put_node;
+		}
+
+		ret = dev_pm_opp_of_add_table(cpu_dev);
+		if (ret < 0) {
+			dev_err(cpu_dev, "failed to add OPP table for cpu %d\n", i);
+			goto put_node;
+		}
+
+		cluster_id = topology_physical_package_id(i);
+		cluster_freq[cluster_id].cpu_clk = devm_clk_get(cpu_dev, NULL);
+		if (IS_ERR(cluster_freq[cluster_id].cpu_clk)) {
+			dev_err(cpu_dev, "failed to get cluster %d clock\n", cluster_id);
+			ret = -ENOENT;
+			goto put_node;
+		}
+
+		ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table[cluster_id]);
+		if (ret) {
+			dev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);
+			goto put_node;
+		}
+
+		if (of_property_read_u32(np, "clock-latency", &transition_latency[cluster_id]))
+			transition_latency[cluster_id] = CPUFREQ_ETERNAL;
+		break;
+	}
+
+	ret = cpufreq_register_driver(&imx8_cpufreq_driver);
+	if (ret)
+		dev_err(cpu_dev, "failed register driver: %d\n", ret);
+
+put_node:
+	of_node_put(np);
+	return ret;
+}
+
+static int imx8_cpufreq_remove(struct platform_device *pdev)
+{
+	cpufreq_unregister_driver(&imx8_cpufreq_driver);
+
+	return 0;
+}
+
+static struct platform_driver imx8_cpufreq_platdrv = {
+	.driver = {
+		.name	= "imx8-cpufreq",
+	},
+	.probe		= imx8_cpufreq_probe,
+	.remove		= imx8_cpufreq_remove,
+};
+module_platform_driver(imx8_cpufreq_platdrv);
+
+MODULE_AUTHOR("Anson Huang <Anson.Huang@nxp.com>");
+MODULE_DESCRIPTION("NXP i.MX8 cpufreq driver");
+MODULE_LICENSE("GPL");
-- 
1.7.9.5


From d05f1ec21fd69c0047ba4bce23ce59f1eea3a088 Mon Sep 17 00:00:00 2001
From: Leonard Crestez <leonard.crestez@nxp.com>
Date: Fri, 16 Mar 2018 15:46:52 +0200
Subject: [PATCH 1410/5242] MLK-13911-6 soc: imx8: add soc and power domain

commit  2dc02e9ba551afd9f15e16f949a167f96ec74d1d from
https://source.codeaurora.org/external/imx/linux-imx.git

Add i.MX8 SOC and power domain support.

Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
Signed-off-by: Peng Fan <peng.fan@nxp.com>
Signed-off-by: Jason Liu <jason.hui.liu@nxp.com>
Signed-off-by: Ranjani Vaidyanathan <Ranjani.Vaidyanathan@nxp.com>
Signed-off-by: Adrian Alonso <adrian.alonso@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/soc/imx/Makefile         |    1 +
 drivers/soc/imx/pm-domain-imx8.h |   45 ++++++++++++
 drivers/soc/imx/pm-domains.c     |  140 ++++++++++++++++++++++++++++++++++++++
 drivers/soc/imx/soc-imx8.c       |  113 ++++++++++++++++++++++++++++++
 4 files changed, 299 insertions(+)
 create mode 100644 drivers/soc/imx/pm-domain-imx8.h
 create mode 100644 drivers/soc/imx/pm-domains.c
 create mode 100644 drivers/soc/imx/soc-imx8.c

diff --git a/drivers/soc/imx/Makefile b/drivers/soc/imx/Makefile
index 49fdc3d..8dc698b 100644
--- a/drivers/soc/imx/Makefile
+++ b/drivers/soc/imx/Makefile
@@ -2,3 +2,4 @@ obj-$(CONFIG_HAVE_IMX_GPC) += gpc.o
 obj-$(CONFIG_IMX7_PM_DOMAINS) += gpcv2.o
 obj-$(CONFIG_ARCH_FSL_IMX8QM) += mu/
 obj-$(CONFIG_ARCH_FSL_IMX8QM) += sc/
+obj-$(CONFIG_ARCH_FSL_IMX8QM) += pm-domains.o soc-imx8.o
diff --git a/drivers/soc/imx/pm-domain-imx8.h b/drivers/soc/imx/pm-domain-imx8.h
new file mode 100644
index 0000000..910ac21
--- /dev/null
+++ b/drivers/soc/imx/pm-domain-imx8.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef PM_DOMAIN_IMX8_H
+#define PM_DOMAIN_IMX8_H
+
+#include <linux/pm_domain.h>
+#include <soc/imx8/sc/sci.h>
+
+#define DEFAULT_DEV_LATENCY_NS	250000
+
+struct platform_device;
+
+struct imx8_pm_domain {
+	const char *name;
+	struct generic_pm_domain pd;
+	struct dev_power_governor *gov;
+	int (*suspend)(void);
+	void (*resume)(void);
+	sc_rsrc_t rsrc_id;
+};
+
+static inline
+struct imx8_pm_domain *to_imx8_pd(struct generic_pm_domain *d)
+{
+	return container_of(d, struct imx8_pm_domain, pd);
+}
+
+struct pm_domain_device {
+	const char *domain_name;
+	struct platform_device *pdev;
+};
+
+#endif /* PM_DOMAIN_IMX8_H */
diff --git a/drivers/soc/imx/pm-domains.c b/drivers/soc/imx/pm-domains.c
new file mode 100644
index 0000000..88d5d9b
--- /dev/null
+++ b/drivers/soc/imx/pm-domains.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_clock.h>
+#include <linux/slab.h>
+
+#include <soc/imx8/sc/sci.h>
+
+#include "pm-domain-imx8.h"
+
+static sc_ipc_t pm_ipcHandle;
+
+static int imx8_pd_power(struct generic_pm_domain *domain, bool power_on)
+{
+	struct imx8_pm_domain *pd;
+	sc_err_t sciErr;
+
+	pd = container_of(domain, struct imx8_pm_domain, pd);
+
+	if (pd->rsrc_id == SC_R_LAST)
+		return 0;
+
+	sciErr = sc_pm_set_resource_power_mode(pm_ipcHandle, pd->rsrc_id,
+		(power_on) ? SC_PM_PW_MODE_ON : SC_PM_PW_MODE_OFF);
+
+	if (sciErr)
+		pr_err("Failed power operation on resource %d\n", pd->rsrc_id);
+
+	return 0;
+}
+
+static int imx8_pd_power_on(struct generic_pm_domain *domain)
+{
+	return imx8_pd_power(domain, true);
+}
+
+static int imx8_pd_power_off(struct generic_pm_domain *domain)
+{
+	return imx8_pd_power(domain, false);
+}
+
+static int __init imx8_add_pm_domains(struct device_node *parent,
+					struct generic_pm_domain *genpd_parent)
+{
+	struct device_node *np;
+
+	for_each_child_of_node(parent, np) {
+		struct imx8_pm_domain *imx8_pd;
+		sc_rsrc_t rsrc_id;
+
+		imx8_pd = kzalloc(sizeof(*imx8_pd), GFP_KERNEL);
+		if (!imx8_pd)
+			return -ENOMEM;
+
+		if (!of_property_read_string(np, "name", &imx8_pd->pd.name))
+			imx8_pd->name = imx8_pd->pd.name;
+
+		if (!of_property_read_u32(np, "reg", &rsrc_id))
+			imx8_pd->rsrc_id = rsrc_id;
+
+		imx8_pd->pd.power_off = imx8_pd_power_off;
+		imx8_pd->pd.power_on = imx8_pd_power_on;
+
+		pm_genpd_init(&imx8_pd->pd, NULL, true);
+
+		if (genpd_parent)
+			pm_genpd_add_subdomain(genpd_parent, &imx8_pd->pd);
+
+		of_genpd_add_provider_simple(np, &imx8_pd->pd);
+
+		imx8_add_pm_domains(np, &imx8_pd->pd);
+	}
+	return 0;
+}
+
+static int __init imx8_init_pm_domains(void)
+{
+	struct device_node *np;
+	sc_err_t sciErr;
+	sc_rsrc_t rsrc_id;
+	uint32_t mu_id;
+
+	pr_info("***** imx8_init_pm_domains *****\n");
+
+	for_each_compatible_node(np, NULL, "nxp,imx8-pd") {
+		struct imx8_pm_domain *imx8_pd;
+
+		imx8_pd = kzalloc(sizeof(struct imx8_pm_domain), GFP_KERNEL);
+		if (!imx8_pd) {
+			pr_err("%s: failed to allocate memory for domain\n",
+				__func__);
+			return -ENOMEM;
+		}
+		if (!of_property_read_string(np, "name", &imx8_pd->pd.name))
+			imx8_pd->name = imx8_pd->pd.name;
+
+		if (!of_property_read_u32(np, "reg", &rsrc_id))
+			imx8_pd->rsrc_id = rsrc_id;
+
+		if (imx8_pd->rsrc_id != SC_R_LAST) {
+			imx8_pd->pd.power_off = imx8_pd_power_off;
+			imx8_pd->pd.power_on = imx8_pd_power_on;
+		}
+		pm_genpd_init(&imx8_pd->pd, NULL, true);
+		of_genpd_add_provider_simple(np, &imx8_pd->pd);
+		imx8_add_pm_domains(np, &imx8_pd->pd);
+	}
+
+	sciErr = sc_ipc_getMuID(&mu_id);
+	if (sciErr != SC_ERR_NONE) {
+		pr_info("Cannot obtain MU ID\n");
+		return sciErr;
+	}
+
+	sciErr = sc_ipc_open(&pm_ipcHandle, mu_id);
+
+	return 0;
+}
+
+early_initcall(imx8_init_pm_domains);
diff --git a/drivers/soc/imx/soc-imx8.c b/drivers/soc/imx/soc-imx8.c
new file mode 100644
index 0000000..7920770
--- /dev/null
+++ b/drivers/soc/imx/soc-imx8.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/sys_soc.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+struct imx8_soc_data {
+	char *name;
+	u32 (*soc_revision)(void);
+};
+
+u32 imx8qm_soc_revision(void);
+u32 imx8qxp_soc_revision(void);
+
+struct imx8_soc_data imx8qm_soc_data = {
+	.name = "i.MX8QM",
+	.soc_revision = imx8qm_soc_revision,
+};
+
+struct imx8_soc_data imx8qxp_soc_data = {
+	.name = "i.MX8QXP",
+	.soc_revision = imx8qxp_soc_revision,
+};
+
+static const struct of_device_id imx8_soc_match[] = {
+	{ .compatible = "fsl,imx8qm", .data = &imx8qm_soc_data, },
+	{ .compatible = "fsl,imx8qxp", .data = &imx8qxp_soc_data, },
+	{ }
+};
+
+u32 imx8qm_soc_revision(void)
+{
+	/*FIX ME later */
+
+	return 0x10;
+}
+
+u32 imx8qxp_soc_revision(void)
+{
+	/*FIX ME later */
+
+	return 0x10;
+}
+
+static int __init imx8_soc_init(void)
+{
+	struct soc_device_attribute *soc_dev_attr;
+	struct soc_device *soc_dev;
+	struct device_node *root;
+	const struct of_device_id *id;
+	u32 imx_soc_revision = 0;
+	const struct imx8_soc_data *data;
+	int ret;
+
+	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
+	if (!soc_dev_attr)
+		return -ENODEV;
+
+	soc_dev_attr->family = "Freescale i.MX";
+
+	root = of_find_node_by_path("/");
+	ret = of_property_read_string(root, "model", &soc_dev_attr->machine);
+	if (ret)
+		goto free_soc;
+
+	id = of_match_node(imx8_soc_match, root);
+	if (!id)
+		goto free_soc;
+
+	of_node_put(root);
+
+	data = id->data;
+	if (data) {
+		soc_dev_attr->soc_id = data->name;
+		if (data->soc_revision)
+			imx_soc_revision = data->soc_revision();
+	}
+
+	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%d.%d",
+					   (imx_soc_revision >> 4) & 0xf,
+					   imx_soc_revision & 0xf);
+	if (!soc_dev_attr->revision)
+		goto free_soc;
+
+	soc_dev = soc_device_register(soc_dev_attr);
+	if (IS_ERR(soc_dev))
+		goto free_rev;
+
+	return 0;
+
+free_rev:
+	kfree(soc_dev_attr->revision);
+free_soc:
+	kfree(soc_dev_attr);
+	return -ENODEV;
+}
+device_initcall(imx8_soc_init);
-- 
1.7.9.5


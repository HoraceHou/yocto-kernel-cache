From d759ff9f14c45493d2d7df76855bd8b6bebd7c74 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@nxp.com>
Date: Wed, 29 Nov 2017 15:32:21 +0800
Subject: [PATCH 2948/5242] MLK-17034-5: ASoC: fsl_mqs: Move clock operation
 to pm runtime function

commit  c32892c6572a0311a085e0321d6feb0a77436b81 from
https://source.codeaurora.org/external/imx/linux-imx.git

In imx8 when systerm enter suspend state, the power of subsystem will be
off, The clock enable state will be lost after resume, but the runtime
resume function will be called after resume by pm, so need to move clock
enablement to runtime resume and clock disablement to runtime suspend.
Then after resume the clock enable state can be recovered.

Signed-off-by: Shengjiu Wang <shengjiu.wang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 sound/soc/codecs/fsl_mqs.c |   29 +++++++++++++++++------------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/sound/soc/codecs/fsl_mqs.c b/sound/soc/codecs/fsl_mqs.c
index 0a0335e..fbcb96c 100644
--- a/sound/soc/codecs/fsl_mqs.c
+++ b/sound/soc/codecs/fsl_mqs.c
@@ -145,12 +145,6 @@ static int fsl_mqs_startup(struct snd_pcm_substream *substream,
 	struct snd_soc_component *component = dai->component;
 	struct fsl_mqs *mqs_priv = snd_soc_component_get_drvdata(component);
 
-	if (mqs_priv->ipg)
-		clk_prepare_enable(mqs_priv->ipg);
-
-	if (mqs_priv->mclk)
-		clk_prepare_enable(mqs_priv->mclk);
-
 	if (mqs_priv->use_gpr)
 		regmap_update_bits(mqs_priv->gpr, IOMUXC_GPR2, IMX6SX_GPR2_MQS_EN_MASK,
 					1 << IMX6SX_GPR2_MQS_EN_SHIFT);
@@ -173,12 +167,6 @@ static void fsl_mqs_shutdown(struct snd_pcm_substream *substream,
 	else
 		regmap_update_bits(mqs_priv->regmap, REG_MQS_CTRL,
 					MQS_EN_MASK, 0);
-
-	if (mqs_priv->mclk)
-		clk_disable_unprepare(mqs_priv->mclk);
-
-	if (mqs_priv->ipg)
-		clk_disable_unprepare(mqs_priv->ipg);
 }
 
 static struct snd_soc_component_driver soc_component_fsl_mqs = {
@@ -316,6 +304,20 @@ static int fsl_mqs_runtime_resume(struct device *dev)
 	return 0;
 }
 
+static int fsl_mqs_runtime_suspend(struct device *dev)
+{
+	struct fsl_mqs *mqs_priv = dev_get_drvdata(dev);
+
+	if (mqs_priv->mclk)
+		clk_disable_unprepare(mqs_priv->mclk);
+
+	if (mqs_priv->ipg)
+		clk_disable_unprepare(mqs_priv->ipg);
+
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_PM_SLEEP
 static int fsl_mqs_resume(struct device *dev)
 {
@@ -347,6 +349,9 @@ static int fsl_mqs_suspend(struct device *dev)
 #endif
 
 static const struct dev_pm_ops fsl_mqs_pm_ops = {
+	SET_RUNTIME_PM_OPS(fsl_mqs_runtime_suspend,
+			   fsl_mqs_runtime_resume,
+			   NULL)
 	SET_SYSTEM_SLEEP_PM_OPS(fsl_mqs_suspend, fsl_mqs_resume)
 };
 
-- 
1.7.9.5


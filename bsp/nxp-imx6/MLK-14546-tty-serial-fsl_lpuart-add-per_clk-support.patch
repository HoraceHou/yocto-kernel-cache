From aca8c5c13ddeda974cf9698f8f57492f2ecee7bc Mon Sep 17 00:00:00 2001
From: Andy Duan <fugang.duan@nxp.com>
Date: Wed, 29 Mar 2017 14:56:19 +0800
Subject: [PATCH 1624/5242] MLK-14546 tty: serial: fsl_lpuart: add per_clk
 support

commit  ca29eee743fe62fb226b3091af4bf04969dd56fa from
https://source.codeaurora.org/external/imx/linux-imx.git

i.MX8QM lpuart has ipg_clk and per_clk, ipg_clk for bus and register
accessing, per_clk is lpuart module clock. Add per_clk support in
driver.

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/serial/fsl-lpuart.txt      |   10 ++-
 drivers/tty/serial/fsl_lpuart.c                    |   95 ++++++++++++++++----
 2 files changed, 87 insertions(+), 18 deletions(-)

diff --git a/Documentation/devicetree/bindings/serial/fsl-lpuart.txt b/Documentation/devicetree/bindings/serial/fsl-lpuart.txt
index 6bd3f2e..33cfa2f 100644
--- a/Documentation/devicetree/bindings/serial/fsl-lpuart.txt
+++ b/Documentation/devicetree/bindings/serial/fsl-lpuart.txt
@@ -8,14 +8,22 @@ Required properties:
     on LS1021A SoC with 32-bit big-endian register organization
   - "fsl,imx7ulp-lpuart" for lpuart compatible with the one integrated
     on i.MX7ULP SoC with 32-bit little-endian register organization
+  - "fsl,imx8qm-lpuart"for lpuart  compatible with the one integrated
+    on i.MX8QM SoC with 32-bit little-endian register organization, which
+    is based on i.MX7ULP lpuart IP but add EEOP new feature.
 - reg : Address and length of the register set for the device
 - interrupts : Should contain uart interrupt
 - clocks : phandle + clock specifier pairs, one for each entry in clock-names
-- clock-names : should contain: "ipg" - the uart clock
+- clock-names : should contain: "ipg" - the uart peripheral register accessing
+  clock source, if "per" clock missing, the "ipg" clock also is the uart module
+  clock.
 
 Optional properties:
 - dmas: A list of two dma specifiers, one for each entry in dma-names.
 - dma-names: should contain "tx" and "rx".
+- clocks : phandle + clock specifier pairs, one for each entry in clock-names
+- clock-names : "per" - the uart module clock.
+  clock.
 - rs485-rts-delay, rs485-rts-active-low, rs485-rx-during-tx,
   linux,rs485-enabled-at-boot-time: see rs485.txt
 
diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index f52877a..ec9516a 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -236,7 +236,8 @@
 
 struct lpuart_port {
 	struct uart_port	port;
-	struct clk		*clk;
+	struct clk		*ipg_clk;
+	struct clk		*per_clk;
 	unsigned int		txfifo_size;
 	unsigned int		rxfifo_size;
 
@@ -1278,9 +1279,19 @@ static void rx_dma_timer_init(struct lpuart_port *sport)
 static int lpuart_startup(struct uart_port *port)
 {
 	struct lpuart_port *sport = container_of(port, struct lpuart_port, port);
+	int ret;
 	unsigned long flags;
 	unsigned char temp;
 
+	ret = clk_prepare_enable(sport->ipg_clk);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(sport->per_clk);
+	if (ret) {
+		clk_disable_unprepare(sport->ipg_clk);
+		return ret;
+	}
+
 	/* determine FIFO size and enable FIFO mode */
 	temp = readb(sport->port.membase + UARTPFIFO);
 
@@ -1331,6 +1342,16 @@ static int lpuart32_startup(struct uart_port *port)
 	struct lpuart_port *sport = container_of(port, struct lpuart_port, port);
 	unsigned long flags;
 	unsigned long temp;
+	int ret;
+
+	ret = clk_prepare_enable(sport->ipg_clk);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(sport->per_clk);
+	if (ret) {
+		clk_disable_unprepare(sport->ipg_clk);
+		return ret;
+	}
 
 	/* determine FIFO size */
 	temp = lpuart32_read(&sport->port, UARTFIFO);
@@ -1381,10 +1402,13 @@ static void lpuart_shutdown(struct uart_port *port)
 
 		lpuart_stop_tx(port);
 	}
+	clk_disable_unprepare(sport->per_clk);
+	clk_disable_unprepare(sport->ipg_clk);
 }
 
 static void lpuart32_shutdown(struct uart_port *port)
 {
+	struct lpuart_port *sport = container_of(port, struct lpuart_port, port);
 	unsigned long temp;
 	unsigned long flags;
 
@@ -1397,6 +1421,9 @@ static void lpuart32_shutdown(struct uart_port *port)
 	lpuart32_write(port, temp, UARTCTRL);
 
 	spin_unlock_irqrestore(&port->lock, flags);
+
+	clk_disable_unprepare(sport->per_clk);
+	clk_disable_unprepare(sport->ipg_clk);
 }
 
 static void
@@ -1953,7 +1980,10 @@ static void lpuart32_console_putchar(struct uart_port *port, int ch)
 	brfa = readb(sport->port.membase + UARTCR4);
 	brfa &= UARTCR4_BRFA_MASK;
 
-	uartclk = clk_get_rate(sport->clk);
+	if (sport->per_clk)
+		uartclk = clk_get_rate(sport->per_clk);
+	else
+		uartclk = clk_get_rate(sport->ipg_clk);
 	/*
 	 * baud = mod_clk/(16*(sbr[13]+(brfa)/32)
 	 */
@@ -1996,7 +2026,11 @@ static void lpuart32_console_putchar(struct uart_port *port, int ch)
 	bd = lpuart32_read(&sport->port, UARTBAUD);
 	bd &= UARTBAUD_SBR_MASK;
 	sbr = bd;
-	uartclk = clk_get_rate(sport->clk);
+	if (sport->per_clk)
+		uartclk = clk_get_rate(sport->per_clk);
+	else
+		uartclk = clk_get_rate(sport->ipg_clk);
+
 	/*
 	 * baud = mod_clk/(16*(sbr[13]+(brfa)/32)
 	 */
@@ -2014,6 +2048,7 @@ static int __init lpuart_console_setup(struct console *co, char *options)
 	int bits = 8;
 	int parity = 'n';
 	int flow = 'n';
+	int ret;
 
 	/*
 	 * check whether an invalid uart number has been specified, and
@@ -2027,6 +2062,15 @@ static int __init lpuart_console_setup(struct console *co, char *options)
 	if (sport == NULL)
 		return -ENODEV;
 
+	ret = clk_prepare_enable(sport->ipg_clk);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(sport->per_clk);
+	if (ret) {
+		clk_disable_unprepare(sport->ipg_clk);
+		return ret;
+	}
+
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
 	else
@@ -2184,21 +2228,31 @@ static int lpuart_probe(struct platform_device *pdev)
 
 	sport->port.rs485_config = lpuart_config_rs485;
 
-	sport->clk = devm_clk_get(&pdev->dev, "ipg");
-	if (IS_ERR(sport->clk)) {
-		ret = PTR_ERR(sport->clk);
-		dev_err(&pdev->dev, "failed to get uart clk: %d\n", ret);
+	sport->ipg_clk = devm_clk_get(&pdev->dev, "ipg");
+	if (IS_ERR(sport->ipg_clk)) {
+		ret = PTR_ERR(sport->per_clk);
+		dev_err(&pdev->dev, "failed to get ipg clk: %d\n", ret);
 		return ret;
 	}
+	sport->per_clk = devm_clk_get(&pdev->dev, "per");
+	if (IS_ERR(sport->per_clk))
+		sport->per_clk = NULL;
 
-	ret = clk_prepare_enable(sport->clk);
+	ret = clk_prepare_enable(sport->ipg_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable uart ipg clk: %d\n", ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(sport->per_clk);
 	if (ret) {
+		clk_disable_unprepare(sport->ipg_clk);
 		dev_err(&pdev->dev, "failed to enable uart clk: %d\n", ret);
 		return ret;
 	}
-
-	sport->port.uartclk = clk_get_rate(sport->clk);
-	pr_info("uartclk = %ld\n", clk_get_rate(sport->clk));
+	if (sport->per_clk)
+		sport->port.uartclk = clk_get_rate(sport->per_clk);
+	else
+		sport->port.uartclk = clk_get_rate(sport->ipg_clk);
 
 	lpuart_ports[sport->port.line] = sport;
 
@@ -2236,7 +2290,8 @@ static int lpuart_probe(struct platform_device *pdev)
 
 failed_attach_port:
 failed_irq_request:
-	clk_disable_unprepare(sport->clk);
+	clk_disable_unprepare(sport->per_clk);
+	clk_disable_unprepare(sport->ipg_clk);
 	return ret;
 }
 
@@ -2246,7 +2301,8 @@ static int lpuart_remove(struct platform_device *pdev)
 
 	uart_remove_one_port(&lpuart_reg, &sport->port);
 
-	clk_disable_unprepare(sport->clk);
+	clk_disable_unprepare(sport->per_clk);
+	clk_disable_unprepare(sport->ipg_clk);
 
 	if (sport->dma_tx_chan)
 		dma_release_channel(sport->dma_tx_chan);
@@ -2263,6 +2319,11 @@ static int lpuart_suspend(struct device *dev)
 	struct lpuart_port *sport = dev_get_drvdata(dev);
 	unsigned long temp;
 	bool irq_wake;
+	int ret;
+
+	ret = clk_prepare_enable(sport->ipg_clk);
+	if (ret)
+		return ret;
 
 	if (lpuart_is_32(sport)) {
 		/* disable Rx/Tx and interrupts */
@@ -2304,8 +2365,7 @@ static int lpuart_suspend(struct device *dev)
 		dmaengine_terminate_all(sport->dma_tx_chan);
 	}
 
-	if (sport->port.suspended && !irq_wake)
-		clk_disable_unprepare(sport->clk);
+	clk_disable_unprepare(sport->ipg_clk);
 
 	return 0;
 }
@@ -2316,8 +2376,7 @@ static int lpuart_resume(struct device *dev)
 	bool irq_wake = irqd_is_wakeup_set(irq_get_irq_data(sport->port.irq));
 	unsigned long temp;
 
-	if (sport->port.suspended && !irq_wake)
-		clk_prepare_enable(sport->clk);
+	clk_prepare_enable(sport->ipg_clk);
 
 	if (lpuart_is_32(sport)) {
 		lpuart32_setup_watermark(sport);
@@ -2352,6 +2411,8 @@ static int lpuart_resume(struct device *dev)
 
 	uart_resume_port(&lpuart_reg, &sport->port);
 
+	clk_disable_unprepare(sport->ipg_clk);
+
 	return 0;
 }
 #endif
-- 
1.7.9.5


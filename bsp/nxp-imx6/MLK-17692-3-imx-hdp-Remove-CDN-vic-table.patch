From 641ee5b73000cf26bf36a5a59fdaf4bd5e6ba17a Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Tue, 6 Mar 2018 17:17:35 +0800
Subject: [PATCH 3455/5242] MLK-17692-3: imx hdp: Remove CDN vic table

commit  99ab0e260c4d1ed4534dc6ad9f006bbe2dcda583 from
https://source.codeaurora.org/external/imx/linux-imx.git

Remove CDN vic table and replace with drm_display_mode.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c   |   11 +-
 .../drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h   |    4 +-
 drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c    |    6 +-
 drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.h    |    4 +-
 drivers/gpu/drm/imx/hdp/imx-dp.c                   |    8 +-
 drivers/gpu/drm/imx/hdp/imx-dp.h                   |    6 +-
 drivers/gpu/drm/imx/hdp/imx-hdmi.c                 |   26 ++--
 drivers/gpu/drm/imx/hdp/imx-hdmi.h                 |   10 +-
 drivers/gpu/drm/imx/hdp/imx-hdp-audio.c            |   25 ++--
 drivers/gpu/drm/imx/hdp/imx-hdp.c                  |   41 +-----
 drivers/gpu/drm/imx/hdp/imx-hdp.h                  |    9 +-
 drivers/mxc/hdp/API_AVI.c                          |   19 ++-
 drivers/mxc/hdp/API_AVI.h                          |    3 +-
 drivers/mxc/hdp/API_Audio.h                        |    1 -
 drivers/mxc/hdp/API_DPTX.c                         |   90 +++++-------
 drivers/mxc/hdp/API_DPTX.h                         |    5 +-
 drivers/mxc/hdp/API_HDMITX.c                       |   49 ++++---
 drivers/mxc/hdp/API_HDMITX.h                       |    3 +-
 drivers/mxc/hdp/Makefile                           |    3 +-
 drivers/mxc/hdp/all.h                              |    1 -
 drivers/mxc/hdp/util.h                             |   46 ++++++-
 drivers/mxc/hdp/vic_table.c                        |   68 ---------
 drivers/mxc/hdp/vic_table.h                        |  144 --------------------
 23 files changed, 182 insertions(+), 400 deletions(-)
 delete mode 100644 drivers/mxc/hdp/vic_table.c
 delete mode 100644 drivers/mxc/hdp/vic_table.h

diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
index 88bc821..0e28aa3 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.c
@@ -106,16 +106,15 @@ int get_table_row(const u32 *array, u32 table_rows,
 	return i;
 }
 
-int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
-			  VIC_MODES vicMode, int bpp,
-			  VIC_PXL_ENCODING_FORMAT format)
+int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes, struct drm_display_mode *mode, int bpp,
+		VIC_PXL_ENCODING_FORMAT format)
 {
 	const int phy_reset_workaround = 0;
 	u32 vco_freq_khz;
 	unsigned char i;
 	u32 row, feedback_factor;
 	uint32_t reg_val;
-	int pixel_freq_khz = vic_table[vicMode][PIXEL_FREQ_KHZ];
+	int pixel_freq_khz = mode->clock;
 	uint32_t character_clock_ratio_num = 1;
 	uint32_t character_clock_ratio_den = 1;
 	int character_freq_khz;
@@ -178,8 +177,8 @@ int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
 	charge_pump_gain.lsb = 0;
 
 	DRM_INFO
-	    ("phy_cfg_hdp() num_lanes: %0d, vicMode: %0d, color depth: %0d-bit, encoding: %0d\n",
-	     num_lanes, vicMode, bpp, format);
+	    ("phy_cfg_hdp() num_lanes: %0d, mode:%dx%dp%d, color depth: %0d-bit, encoding: %0d\n",
+	     num_lanes, mode->hdisplay, mode->vdisplay, mode->vrefresh, bpp, format);
 
 	/* register PHY_PMA_ISOLATION_CTRL
 	 * enable PHY isolation mode only for CMN */
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h
index 6a334be..2374e00 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_ss28fdsoi_kiran_hdmitx.h
@@ -35,6 +35,8 @@
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
+ * Copyright 2017-2018 NXP
+ *
  ******************************************************************************
  *
  * API_AFE_ss28fdsoi_kiran_hdmitx.h
@@ -48,7 +50,7 @@
 #include "../../../../mxc/hdp/all.h"
 
 int phy_cfg_hdp_ss28fdsoi(state_struct *state, int num_lanes,
-				VIC_MODES vicMode, int bpp, VIC_PXL_ENCODING_FORMAT format);
+				struct drm_display_mode *mode, int bpp, VIC_PXL_ENCODING_FORMAT format);
 int hdmi_tx_kiran_power_configuration_seq(state_struct *state, int num_lanes);
 int get_table_row_match_column(const u32 *array, u32 table_rows,
 			       u32 table_cols, u32 start_row,
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
index 9b99bf1..88d92fe 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
@@ -58,7 +58,7 @@ static char inside(u32 value, u32 left_sharp_corner,
 	return true;
 }
 
-int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bpp,
+int phy_cfg_t28hpc(state_struct *state, int num_lanes, struct drm_display_mode *mode, int bpp,
 		VIC_PXL_ENCODING_FORMAT format, bool pixel_clk_from_phy)
 {
 
@@ -66,7 +66,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 	unsigned int vco_freq;
 	unsigned char k;
 	uint32_t reg_val;
-	uint32_t pixel_freq_khz = vic_table[vicMode][PIXEL_FREQ_KHZ];
+	uint32_t pixel_freq_khz = mode->clock;
 	uint32_t character_clock_ratio_num = 1;
 	uint32_t character_clock_ratio_den = 1;
 	uint32_t character_freq_khz;
@@ -100,7 +100,7 @@ int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bp
 	cmnda_pll0_fb_div_high.value = 0x00A;
 	ftemp = pixel_freq_khz;
 
-	DRM_INFO(" VIC %d, pixel clock %u kHz\n", vicMode, ftemp);
+	DRM_INFO("mode:%dx%dp%d, pixel clock %u kHz\n", mode->hdisplay, mode->vdisplay, mode->vrefresh, ftemp);
 
 	/* Set field position */
 	cmnda_pll0_hs_sym_div_sel.msb = 9;
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.h b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.h
index 9a44140..de0f6b0 100644
--- a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.h
+++ b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.h
@@ -35,6 +35,8 @@
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
+ * Copyright 2017-2018 NXP
+ *
  ******************************************************************************
  *
  * API_AFE_t28hpc_hdmitx.h
@@ -51,7 +53,7 @@
 
 #include "../../../../mxc/hdp/all.h"
 
-int phy_cfg_t28hpc(state_struct *state, int num_lanes, VIC_MODES vicMode, int bpp,
+int phy_cfg_t28hpc(state_struct *state, int num_lanes, struct drm_display_mode *mode, int bpp,
 		VIC_PXL_ENCODING_FORMAT format, bool pixel_clk_from_phy);
 int hdmi_tx_t28hpc_power_config_seq(state_struct *state, int num_lanes);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.c b/drivers/gpu/drm/imx/hdp/imx-dp.c
index f48968a..40b7959 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -78,7 +78,7 @@ int dp_fw_init(state_struct *state)
 	return 0;
 }
 
-int dp_phy_init(state_struct *state, int vic, int format, int color_depth)
+int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format, int color_depth)
 {
 	struct imx_hdp *hdp = state_to_imx_hdp(state);
 	int max_link_rate = hdp->link_rate;
@@ -108,7 +108,7 @@ int dp_phy_init(state_struct *state, int vic, int format, int color_depth)
 }
 
 /* Max Link Rate: 06h (1.62Gbps), 0Ah (2.7Gbps), 14h (5.4Gbps), 1Eh (8.1Gbps)--N/A */
-void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int max_link_rate)
+void dp_mode_set(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int max_link_rate)
 {
 	int ret;
 
@@ -165,7 +165,7 @@ void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int
 	}
 
 	ret = CDN_API_DPTX_Set_VIC_blocking(state,
-		vic,
+		mode,
 		bits_per_subpixel,
 		num_lanes,
 		sym_rate,
diff --git a/drivers/gpu/drm/imx/hdp/imx-dp.h b/drivers/gpu/drm/imx/hdp/imx-dp.h
index dc597a9..db53aac 100644
--- a/drivers/gpu/drm/imx/hdp/imx-dp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-dp.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,8 +16,8 @@
 
 void dp_fw_load(state_struct *state);
 int dp_fw_init(state_struct *state);
-void dp_mode_set(state_struct *state, int vic, int format, int color_depth, int max_link_rate);
-int dp_phy_init(state_struct *state, int vic, int format, int color_depth);
+void dp_mode_set(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int max_link_rate);
+int dp_phy_init(state_struct *state, struct drm_display_mode *mode, int format, int color_depth);
 int dp_get_edid_block(void *data, u8 *buf, u32 block, size_t len);
 int dp_get_hpd_state(state_struct *state, u8 *hpd);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.c b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
index 770c476..a7f0f3b 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -76,7 +76,7 @@ int hdmi_fw_init(state_struct *state)
 	return 0;
 }
 
-int hdmi_phy_init(state_struct *state, int vic, int format, int color_depth)
+int hdmi_phy_init(state_struct *state, struct drm_display_mode *mode, int format, int color_depth)
 {
 	struct imx_hdp *hdp = state_to_imx_hdp(state);
 	int ret;
@@ -85,7 +85,7 @@ int hdmi_phy_init(state_struct *state, int vic, int format, int color_depth)
 	imx_hdp_call(hdp, phy_reset, hdp->ipcHndl, 0);
 
 	/* Configure PHY */
-	character_freq_khz = phy_cfg_hdp_ss28fdsoi(state, 4, vic, color_depth, format);
+	character_freq_khz = phy_cfg_hdp_ss28fdsoi(state, 4, mode, color_depth, format);
 
 	imx_hdp_call(hdp, phy_reset, hdp->ipcHndl, 1);
 
@@ -101,7 +101,7 @@ int hdmi_phy_init(state_struct *state, int vic, int format, int color_depth)
 	return true;
 }
 
-void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, int temp)
+void hdmi_mode_set(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int temp)
 {
 	int ret;
 
@@ -110,7 +110,7 @@ void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, in
 	/* Mode = 0 - DVI, 1 - HDMI1.4, 2 HDMI 2.0 */
 	HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE ptype = 1;
 
-	if (vic == VIC_MODE_97_60Hz)
+	if (drm_match_cea_mode(mode) == VIC_MODE_97_60Hz)
 		ptype = 2;
 
 	ret = CDN_API_HDMITX_Init_blocking(state);
@@ -126,13 +126,13 @@ void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, in
 		return;
 	}
 
-	ret = CDN_API_Set_AVI(state, vic, format, bw_type);
+	ret = CDN_API_Set_AVI(state, mode, format, bw_type);
 	if (ret != CDN_OK) {
 		DRM_INFO("CDN_API_Set_AVI  ret = %d\n", ret);
 		return;
 	}
 
-	ret =  CDN_API_HDMITX_SetVic_blocking(state, vic, color_depth, format);
+	ret =  CDN_API_HDMITX_SetVic_blocking(state, mode, color_depth, format);
 	if (ret != CDN_OK) {
 		DRM_INFO("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
 		return;
@@ -141,7 +141,7 @@ void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, in
 	msleep(50);
 }
 
-int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_depth)
+int hdmi_phy_init_t28hpc(state_struct *state, struct drm_display_mode *mode, int format, int color_depth)
 {
 	int ret;
 	/* 0- pixel clock from phy */
@@ -167,7 +167,7 @@ int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_dep
 
 	/* Configure PHY */
 	character_freq_khz =
-	    phy_cfg_t28hpc(state, 4, vic, color_depth, format, pixel_clk_from_phy);
+	    phy_cfg_t28hpc(state, 4, mode, color_depth, format, pixel_clk_from_phy);
 
 	hdmi_tx_t28hpc_power_config_seq(state, 4);
 
@@ -188,7 +188,7 @@ int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_dep
 	return true;
 }
 
-void hdmi_mode_set_t28hpc(state_struct *state, int vic, int format, int color_depth, int temp)
+void hdmi_mode_set_t28hpc(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int temp)
 {
 	int ret;
 
@@ -199,7 +199,7 @@ void hdmi_mode_set_t28hpc(state_struct *state, int vic, int format, int color_de
 	/* Mode = 0 - DVI, 1 - HDMI1.4, 2 HDMI 2.0 */
 	HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE ptype = 1;
 
-	if (vic == VIC_MODE_97_60Hz)
+	if (drm_match_cea_mode(mode) == VIC_MODE_97_60Hz)
 		ptype = 2;
 
 	ret = CDN_API_HDMITX_Init_blocking(state);
@@ -215,13 +215,13 @@ void hdmi_mode_set_t28hpc(state_struct *state, int vic, int format, int color_de
 		return;
 	}
 
-	ret = CDN_API_Set_AVI(state, vic, format, bw_type);
+	ret = CDN_API_Set_AVI(state, mode, format, bw_type);
 	if (ret != CDN_OK) {
 		DRM_ERROR("CDN_API_Set_AVI  ret = %d\n", ret);
 		return;
 	}
 
-	ret = CDN_API_HDMITX_SetVic_blocking(state, vic, color_depth, format);
+	ret = CDN_API_HDMITX_SetVic_blocking(state, mode, color_depth, format);
 	if (ret != CDN_OK) {
 		DRM_ERROR("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
 		return;
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.h b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
index c39f1ca..8b24063 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,12 +16,12 @@
 
 void hdmi_fw_load(state_struct *state);
 int hdmi_fw_init(state_struct *state);
-int hdmi_phy_init(state_struct *state, int vic, int format, int color_depth);
-void hdmi_mode_set(state_struct *state, int vic, int format, int color_depth, int temp);
+int hdmi_phy_init(state_struct *state, struct drm_display_mode *mode, int format, int color_depth);
+void hdmi_mode_set(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int temp);
 int hdmi_get_edid_block(void *data, u8 *buf, u32 block, size_t len);
 int hdmi_get_hpd_state(state_struct *state, u8 *hpd);
-int hdmi_phy_init_t28hpc(state_struct *state, int vic, int format, int color_depth);
-void hdmi_mode_set_t28hpc(state_struct *state, int vic, int format, int color_depth, int temp);
+int hdmi_phy_init_t28hpc(state_struct *state, struct drm_display_mode *mode, int format, int color_depth);
+void hdmi_mode_set_t28hpc(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int temp);
 int hdmi_write_hdr_metadata(state_struct *state,
 			    union hdmi_infoframe *hdr_infoframe);
 
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp-audio.c b/drivers/gpu/drm/imx/hdp/imx-hdp-audio.c
index afc5c6b..6624b8a 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp-audio.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp-audio.c
@@ -45,28 +45,19 @@
 6144, 6144, 6144, 6144, 6144, 5120, 6144, 6144,
 };
 
-static int select_N_index(int vmode_index)
+static int select_N_index(u32 pclk)
 {
+	int i = 0;
 
-	int i = 0, j = 0;
-
-	for (i = 0; i < VIC_MODE_COUNT; i++) {
-		if (vic_table[i][23] == vmode_index)
+	for (i = 0; i < 7; i++) {
+		if (pclk == TMDS_rate_table[i])
 			break;
 	}
 
-	if (i == VIC_MODE_COUNT) {
-		DRM_ERROR("vmode is wrong!\n");
-		j = 7;
-		return j;
-	}
-
-	for (j = 0; j < 7; j++) {
-		if (vic_table[i][13] == TMDS_rate_table[j])
-			break;
-	}
+	if (i == 7)
+		DRM_WARN("pclkc %d is not supported!\n", pclk);
 
-	return j;
+	return i;
 }
 
 static u32 imx_hdp_audio(struct imx_hdp *hdmi, AUDIO_TYPE type, u32 sample_rate, u32 channels, u32 width)
@@ -75,7 +66,7 @@ static u32 imx_hdp_audio(struct imx_hdp *hdmi, AUDIO_TYPE type, u32 sample_rate,
 	AUDIO_WIDTH bits;
 	int ncts_n;
 	state_struct *state = &hdmi->state;
-	int idx_n = select_N_index(hdmi->vic);
+	int idx_n = select_N_index(hdmi->cur_mode->clock);
 
 	switch (sample_rate) {
 	case 32000:
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.c b/drivers/gpu/drm/imx/hdp/imx-hdp.c
index 4a97f3a..59dd43b 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -28,7 +28,7 @@
 
 struct drm_display_mode *g_mode;
 
-static const struct drm_display_mode edid_cea_modes[] = {
+static struct drm_display_mode edid_cea_modes[] = {
 	/* 3 - 720x480@60Hz */
 	{ DRM_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
 		   798, 858, 0, 480, 489, 495, 525, 0,
@@ -446,20 +446,6 @@ void imx8qm_ipg_clock_set_rate(struct hdp_clks *clks)
 	clk_set_rate(clks->av_pll, 24000000);
 }
 
-static int imx_get_vic_index(struct drm_display_mode *mode)
-{
-	int i;
-
-	for (i = 0; i < VIC_MODE_COUNT; i++) {
-		if (mode->hdisplay == vic_table[i][H_ACTIVE] &&
-			mode->vdisplay == vic_table[i][V_ACTIVE] &&
-			mode->clock == vic_table[i][PIXEL_FREQ_KHZ])
-			return i;
-	}
-	/* vidoe mode not support now  */
-	return -1;
-}
-
 static u8 imx_hdp_link_rate(struct drm_display_mode *mode)
 {
 	if (mode->clock < 297000)
@@ -472,16 +458,8 @@ static u8 imx_hdp_link_rate(struct drm_display_mode *mode)
 
 static void imx_hdp_mode_setup(struct imx_hdp *hdp, struct drm_display_mode *mode)
 {
-	int dp_vic;
 	int ret;
 
-	/* Check video mode supported by hdmi/dp phy */
-	dp_vic = imx_get_vic_index(mode);
-	if (dp_vic < 0) {
-		DRM_ERROR("Unsupport video mode now, %s, clk=%d\n", mode->name, mode->clock);
-		return;
-	}
-
 	/* set pixel clock before video mode setup */
 	imx_hdp_call(hdp, pixel_clock_disable, &hdp->clks);
 
@@ -495,16 +473,17 @@ static void imx_hdp_mode_setup(struct imx_hdp *hdp, struct drm_display_mode *mod
 	hdp->link_rate = imx_hdp_link_rate(mode);
 
 	/* mode set */
-	ret = imx_hdp_call(hdp, phy_init, &hdp->state, dp_vic, hdp->format, hdp->bpc);
+	ret = imx_hdp_call(hdp, phy_init, &hdp->state, mode, hdp->format, hdp->bpc);
 	if (ret < 0) {
 		DRM_ERROR("Failed to initialise HDP PHY\n");
 		return;
 	}
-	imx_hdp_call(hdp, mode_set, &hdp->state, dp_vic,
+	imx_hdp_call(hdp, mode_set, &hdp->state, mode,
 		     hdp->format, hdp->bpc, hdp->link_rate);
 
 	/* Get vic of CEA-861 */
 	hdp->vic = drm_match_cea_mode(mode);
+	hdp->cur_mode = mode;
 }
 
 bool imx_hdp_bridge_mode_fixup(struct drm_bridge *bridge,
@@ -513,7 +492,7 @@ bool imx_hdp_bridge_mode_fixup(struct drm_bridge *bridge,
 {
 	struct imx_hdp *hdp = bridge->driver_private;
 	struct drm_display_info *di = &hdp->connector.display_info;
-	int vic = imx_get_vic_index((struct drm_display_mode *)mode);
+	int vic = drm_match_cea_mode(mode);
 
 	if (vic < 0)
 		return false;
@@ -626,7 +605,6 @@ static int imx_hdp_connector_get_modes(struct drm_connector *connector)
 					     connector);
 	enum drm_mode_status mode_status = MODE_OK;
 	struct drm_cmdline_mode *cmdline_mode;
-	int hdp_vic;
 
 	cmdline_mode = &connector->cmdline_mode;
 
@@ -635,11 +613,6 @@ static int imx_hdp_connector_get_modes(struct drm_connector *connector)
 		if (cmdline_mode->xres != 0 &&
 			cmdline_mode->xres < mode->hdisplay)
 			return MODE_BAD_HVALUE;
-	} else {
-		/* Check mode in hdp vic table */
-		hdp_vic = imx_get_vic_index(mode);
-		if (hdp_vic < 0)
-			return MODE_NOMODE;
 	}
 
 	if (hdp->is_4kp60 && mode->clock > 594000)
@@ -1108,7 +1081,7 @@ static int imx_hdp_imx_bind(struct device *dev, struct device *master,
 	/* Pixel Format - 1 RGB, 2 YCbCr 444, 3 YCbCr 420 */
 	/* bpp (bits per subpixel) - 8 24bpp, 10 30bpp, 12 36bpp, 16 48bpp */
 	/* default set hdmi to 1080p60 mode */
-	ret = imx_hdp_call(hdp, phy_init, &hdp->state, 2,
+	ret = imx_hdp_call(hdp, phy_init, &hdp->state, &edid_cea_modes[2],
 			   hdp->format, hdp->bpc);
 	if (ret < 0) {
 		DRM_ERROR("Failed to initialise HDP PHY\n");
diff --git a/drivers/gpu/drm/imx/hdp/imx-hdp.h b/drivers/gpu/drm/imx/hdp/imx-hdp.h
index 8229b5b..61759d4 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdp.h
+++ b/drivers/gpu/drm/imx/hdp/imx-hdp.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 NXP
+ * Copyright 2017-2018 NXP
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -59,6 +59,7 @@
 
 #define HOTPLUG_DEBOUNCE_MS		200
 
+#define VIC_MODE_97_60Hz 97
 /**
  * imx_hdp_call - Calls a struct imx hdp_operations operation on
  *	an entity
@@ -86,8 +87,8 @@
 struct hdp_ops {
 	void (*fw_load)(state_struct *state);
 	int (*fw_init)(state_struct *state);
-	int (*phy_init)(state_struct *state, int vic, int format, int color_depth);
-	void (*mode_set)(state_struct *state, int vic, int format, int color_depth, int max_link);
+	int (*phy_init)(state_struct *state, struct drm_display_mode *mode, int format, int color_depth);
+	void (*mode_set)(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int max_link);
 	int (*get_edid_block)(void *data, u8 *buf, u32 block, size_t len);
 	int (*get_hpd_state)(state_struct *state, u8 *hpd);
 	int (*write_hdr_metadata)(state_struct *state,
@@ -230,6 +231,8 @@ struct imx_hdp {
 	int bpc;
 	VIC_PXL_ENCODING_FORMAT format;
 	bool hdr_metadata_present;
+	bool hdr_mode;
+	struct drm_display_mode *cur_mode;
 };
 
 void imx_hdp_register_audio_driver(struct device *dev);
diff --git a/drivers/mxc/hdp/API_AVI.c b/drivers/mxc/hdp/API_AVI.c
index 91f1659..a2b1a3a 100644
--- a/drivers/mxc/hdp/API_AVI.c
+++ b/drivers/mxc/hdp/API_AVI.c
@@ -47,14 +47,14 @@
 #include "API_AVI.h"
 #include "API_Infoframe.h"
 
-CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, struct drm_display_mode *mode,
 			       VIC_PXL_ENCODING_FORMAT colorMode,
 			       BT_TYPE ITUver)
 {
-	u32 active_slot = vic_table[vicMode][H_BLANK];
-	u32 line_width = vic_table[vicMode][H_TOTAL];
+	u32 active_slot = mode->htotal - mode->hdisplay;
+	u32 line_width = mode->htotal;
 	u32 Hactive = line_width - active_slot + 1;
-	u32 Vactive = vic_table[vicMode][V_ACTIVE] + 1;
+	u32 Vactive = mode->hdisplay + 1;
 
 	u32 Hactive_l = Hactive - 256 * ((u32) Hactive / 256);
 	u32 Hactive_h = Hactive / 256;
@@ -111,11 +111,16 @@ CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, VIC_MODES vicMode,
 
 	/* Active Format Aspec Ratio:
 	 * Same As Picture = 0x8 4:3(Center)=0x9 16:9=0xA 14:9=0xB */
-	packet_R = vic_table[vicMode][VIC_R3_0];
+	if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3)
+		packet_R = 9;
+	else if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9)
+		packet_R = 0xa;
+	else
+		packet_R = 8;
 	/* Video Code (CEA) */
-	packet_VIC = vic_table[vicMode][VIC];
+	packet_VIC = drm_match_cea_mode(mode);
 	/* Pixel Repetition 0 ... 9 (1-10) */
-	packet_PR = vic_table[vicMode][VIC_PR];
+	packet_PR = 0;
 
 	if (colorMode == PXL_RGB)
 		packet_Y = 0;
diff --git a/drivers/mxc/hdp/API_AVI.h b/drivers/mxc/hdp/API_AVI.h
index f4aca89..c67ee8a 100644
--- a/drivers/mxc/hdp/API_AVI.h
+++ b/drivers/mxc/hdp/API_AVI.h
@@ -47,10 +47,9 @@
 #ifndef API_AVI_H_
 #define API_AVI_H_
 
-#include "vic_table.h"
 #include "API_General.h"
 
-CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_Set_AVI(state_struct *state, struct drm_display_mode *mode,
 			       VIC_PXL_ENCODING_FORMAT colorMode,
 			       BT_TYPE ITUver);
 
diff --git a/drivers/mxc/hdp/API_Audio.h b/drivers/mxc/hdp/API_Audio.h
index 4283713..4147594 100644
--- a/drivers/mxc/hdp/API_Audio.h
+++ b/drivers/mxc/hdp/API_Audio.h
@@ -48,7 +48,6 @@
 #define API_AUDIO_H_
 
 #include "API_General.h"
-#include "vic_table.h"
 /**
  * \addtogroup AUDIO_API
  * \{
diff --git a/drivers/mxc/hdp/API_DPTX.c b/drivers/mxc/hdp/API_DPTX.c
index ecdaad6..4bd74bd 100644
--- a/drivers/mxc/hdp/API_DPTX.c
+++ b/drivers/mxc/hdp/API_DPTX.c
@@ -411,7 +411,8 @@ CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(state_struct *state,
 				(state, LinkeventId, HPDevents));
 }
 
-CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state,
+					struct drm_display_mode *mode,
 				    int bitsPerPixel,
 				    VIC_NUM_OF_LANES NumOfLanes,
 				    VIC_SYMBOL_RATE rate,
@@ -453,7 +454,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 		bitsPerPixelCalc = bitsPerPixel * 3;
 
 	/* KHz */
-	pixelClockFreq = vic_table[vicMode][PIXEL_FREQ_KHZ];
+	pixelClockFreq = mode->clock;
 
 	/* KHz */
 	min_link_rate = rate * 995;
@@ -482,9 +483,6 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 		val2 = TU_SIZE_reg * pixelClockFreq * bitsPerPixelCalc;
 		val2_f = val2 / (NumOfLanes * min_link_rate * 8);
 		val2 /= NumOfLanes * min_link_rate * 8;
-
-/*		pr_info("val=%d, val_f=%d, val2=%d, val2_f=%d\n", val, val_f,
-		       val2, val2_f); */
 	}
 
 	/* calculate the fixed valid symbols */
@@ -510,65 +508,50 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 	lineThresh += 2;
 
 	DP_FRAMER_SP_Param =
-	    (vic_table[vicMode][I_P] == INTERLACED ? 4 : 0) +
-	    (vic_table[vicMode][HSYNC_POL] == ACTIVE_LOW ? 2 : 0) +
-	    (vic_table[vicMode][VSYNC_POL] == ACTIVE_LOW ? 1 : 0);
+	    ((mode->flags & DRM_MODE_FLAG_INTERLACE) ? 4 : 0) +
+		((mode->flags & DRM_MODE_FLAG_NHSYNC) ? 2 : 0) +
+		((mode->flags & DRM_MODE_FLAG_NVSYNC) ? 1 : 0);
+
 	DP_FRONT_BACK_PORCH_Param =
-	    vic_table[vicMode][BACK_PORCH] +
-	    (vic_table[vicMode][FRONT_PORCH] << 16);
+	    mode->htotal - mode->hsync_end + ((mode->hsync_start - mode->hdisplay) << 16);
+
+	DP_BYTE_COUNT_Param = mode->hdisplay * (bitsPerPixelCalc) / 8;
 
-	DP_BYTE_COUNT_Param =
-	    vic_table[vicMode][H_ACTIVE] * (bitsPerPixelCalc) / 8;
 	MSA_HORIZONTAL_0_Param =
-	    vic_table[vicMode][H_TOTAL] +
-	    ((vic_table[vicMode][HSYNC] +
-	      vic_table[vicMode][BACK_PORCH]) << 16);
+	    mode->htotal + ((mode->htotal - mode->hsync_start) << 16);
+
 	MSA_HORIZONTAL_1_Param =
-	    vic_table[vicMode][HSYNC] +
-	    ((vic_table[vicMode][HSYNC_POL] ==
-	      ACTIVE_LOW ? 0 : 1) << 15) + (vic_table[vicMode][H_ACTIVE] << 16);
+	    mode->hsync_end - mode->hsync_start +
+	    ((mode->flags & DRM_MODE_FLAG_NHSYNC ? 0 : 1) << 15) + (mode->hdisplay << 16);
 
 	MSA_VERTICAL_0_Param =
-	    (vic_table[vicMode][I_P] == INTERLACED ?
-	     ((vic_table[vicMode][V_TOTAL] /
-	       2)) : vic_table[vicMode][V_TOTAL]) +
-	    ((vic_table[vicMode][VSYNC] + vic_table[vicMode][SOF]) << 16);
+	    (mode->flags & DRM_MODE_FLAG_INTERLACE ? (mode->vtotal / 2) : mode->vtotal) +
+	    ((mode->vtotal - mode->vsync_start) << 16);
+
 	MSA_VERTICAL_1_Param =
-	    (vic_table[vicMode][VSYNC] +
-	     ((vic_table[vicMode][VSYNC_POL] ==
-	       ACTIVE_LOW ? 0 : 1) << 15)) + ((vic_table[vicMode][I_P] ==
-					       INTERLACED ?
-					       vic_table[vicMode][V_ACTIVE] /
-					       2 : vic_table[vicMode][V_ACTIVE])
-					      << 16);
-	DP_HORIZONTAL_ADDR_Param =
-	    ((vic_table[vicMode][H_TOTAL] -
-	      vic_table[vicMode][H_BLANK]) << 16) +
-	    (vic_table[vicMode][H_BLANK] - vic_table[vicMode][FRONT_PORCH] -
-	     vic_table[vicMode][BACK_PORCH]);
+	    (mode->vsync_end - mode->vsync_start +
+		 ((mode->flags & DRM_MODE_FLAG_NVSYNC ? 0 : 1) << 15)) +
+		((mode->flags & DRM_MODE_FLAG_INTERLACE ? mode->vdisplay / 2 : mode->vdisplay) << 16);
+
+	DP_HORIZONTAL_ADDR_Param = (mode->hdisplay << 16) + mode->hsync;
+
 	DP_VERTICAL_0_ADDR_Param =
-	    (vic_table[vicMode][I_P] ==
-	     INTERLACED ? (((vic_table[vicMode][V_TOTAL]) / 2)) :
-	     vic_table[vicMode][V_TOTAL]) - (vic_table[vicMode][VSYNC] +
-					     vic_table[vicMode][SOF] +
-					     vic_table[vicMode][TYPE_EOF]) +
-	    ((vic_table[vicMode][VSYNC] + vic_table[vicMode][SOF]) << 16);
+	    (mode->flags & DRM_MODE_FLAG_INTERLACE ? (mode->vtotal / 2) : mode->vtotal) -
+		(mode->vtotal - mode->vdisplay) + ((mode->vtotal - mode->vsync_start) << 16);
+
 	DP_VERTICAL_1_ADDR_Param =
-	    (vic_table[vicMode][I_P] ==
-	     INTERLACED ? (((vic_table[vicMode][V_TOTAL]) / 2)) :
-	     vic_table[vicMode][V_TOTAL]);
+	    mode->flags & DRM_MODE_FLAG_INTERLACE ? (mode->vtotal / 2) : mode->vtotal;
 
-	if (vic_table[vicMode][I_P] == INTERLACED)
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
 		BND_HSYNC2VSYNC_Param = 0x3020;
 	else
 		BND_HSYNC2VSYNC_Param = 0x2000;
 
-	if (vic_table[vicMode][HSYNC_POL] == ACTIVE_LOW) {
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 		HSYNC2VSYNC_POL_CTRL_Param |= F_HPOL(1);
-	}
-	if (vic_table[vicMode][VSYNC_POL] == ACTIVE_LOW) {
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 		HSYNC2VSYNC_POL_CTRL_Param |= F_VPOL(1);
-	}
 
 	switch (bitsPerPixel) {
 	case 6:
@@ -638,13 +621,13 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 
 	};
 
-	oddEvenV_Total = vic_table[vicMode][V_TOTAL] % 2;
+	oddEvenV_Total = mode->vtotal % 2;
 	oddEvenV_Total = 1 - oddEvenV_Total;
 	oddEvenV_Total = oddEvenV_Total << 8;
 	MSA_MISC_Param =
 	    ((tempForMisc * 2) + (32 * tempForMisc2) +
 	     ((pxlencformat == Y_ONLY ? 1 : 0) << 14) +
-	     ((oddEvenV_Total) * (vic_table[vicMode][I_P])));
+	     ((oddEvenV_Total) * (mode->flags & DRM_MODE_FLAG_INTERLACE ? 1 : 0)));
 
 	/* 420 has diffrent parameters, enable VSS SDP */
 	if (pxlencformat == YCBCR_4_2_0)
@@ -749,8 +732,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 		ret =
 		    CDN_API_DPTX_Write_Field(state, BASE_DPTX_STREAM, DP_VB_ID,
 					     2, 1,
-					     ((vic_table[vicMode][I_P] ==
-					       INTERLACED ? 1 : 0) << 2));
+					     ((mode->flags & DRM_MODE_FLAG_INTERLACE ? 1 : 0) << 2));
 		break;
 	case 17:
 		ret =
@@ -784,7 +766,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
 }
 
 CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
-					     VIC_MODES vicMode,
+					     struct drm_display_mode *mode,
 					     int bitsPerPixel,
 					     VIC_NUM_OF_LANES NumOfLanes,
 					     VIC_SYMBOL_RATE rate,
@@ -794,7 +776,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
 					     BT_TYPE bt_type, int TU)
 {
 	internal_block_function(&state->mutex, CDN_API_DPTX_Set_VIC
-				(state, vicMode, bitsPerPixel, NumOfLanes, rate,
+				(state, mode, bitsPerPixel, NumOfLanes, rate,
 				 pxlencformat, steroVidAttr, bt_type, TU));
 }
 
diff --git a/drivers/mxc/hdp/API_DPTX.h b/drivers/mxc/hdp/API_DPTX.h
index a4e4530..8910500 100644
--- a/drivers/mxc/hdp/API_DPTX.h
+++ b/drivers/mxc/hdp/API_DPTX.h
@@ -48,7 +48,6 @@
 #define _API_DPTX_H_
 
 #include "API_General.h"
-#include "vic_table.h"
 #include "API_AFE.h"
 
 #define MAX_NUM_OF_EVENTS 4
@@ -322,7 +321,7 @@ CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(state_struct *state,
 /**
  * \brief set vic mode according to vic table, the input are video parameters
  */
-CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, struct drm_display_mode *mode,
 				    int bitsPerPixel,
 				    VIC_NUM_OF_LANES NumOfLanes,
 				    VIC_SYMBOL_RATE rate,
@@ -334,7 +333,7 @@ CDN_API_STATUS CDN_API_DPTX_Set_VIC(state_struct *state, VIC_MODES vicMode,
  * blocking version of #CDN_API_DPTX_Set_VIC
  */
 CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(state_struct *state,
-					     VIC_MODES vicMode,
+					     struct drm_display_mode *mode,
 					     int bitsPerPixel,
 					     VIC_NUM_OF_LANES NumOfLanes,
 					     VIC_SYMBOL_RATE rate,
diff --git a/drivers/mxc/hdp/API_HDMITX.c b/drivers/mxc/hdp/API_HDMITX.c
index 1e16395..ba9af10 100644
--- a/drivers/mxc/hdp/API_HDMITX.c
+++ b/drivers/mxc/hdp/API_HDMITX.c
@@ -302,59 +302,59 @@ CDN_API_STATUS CDN_API_HDMITX_Init_blocking(state_struct *state)
 }
 
 CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
-					      VIC_MODES vicMode, int bpp,
+					      struct drm_display_mode *mode, int bpp,
 					      VIC_PXL_ENCODING_FORMAT format)
 {
 	CDN_API_STATUS ret;
 	GENERAL_Read_Register_response resp;
-	u32 vsync_lines = vic_table[vicMode][VSYNC];
-	u32 eof_lines = vic_table[vicMode][TYPE_EOF];
-	u32 sof_lines = vic_table[vicMode][SOF];
-	u32 hblank = vic_table[vicMode][H_BLANK];
-	u32 hactive = vic_table[vicMode][H_TOTAL] - hblank;
-	u32 vblank = vsync_lines + eof_lines + sof_lines;
-	u32 vactive = vic_table[vicMode][V_TOTAL] - vblank;
-	u32 hfront = vic_table[vicMode][FRONT_PORCH];
-	u32 hback = vic_table[vicMode][BACK_PORCH];
+	u32 vsync_lines = mode->vsync_end - mode->vsync_start;
+	u32 eof_lines = mode->vsync_start - mode->vdisplay;
+	u32 sof_lines = mode->vtotal - mode->vsync_end;
+	u32 hblank = mode->htotal - mode->hdisplay;
+	u32 hactive = mode->hdisplay;
+	u32 vblank = mode->vtotal - mode->vdisplay;
+	u32 vactive = mode->vdisplay;
+	u32 hfront = mode->hsync_start - mode->hdisplay;
+	u32 hback = mode->htotal - mode->hsync_end;
 	u32 vfront = eof_lines;
 	u32 hsync = hblank - hfront - hback;
 	u32 vsync = vsync_lines;
 	u32 vback = sof_lines;
-	u32 v_h_polarity = ((vic_table[vicMode][HSYNC_POL] == ACTIVE_LOW) ? 0 : 1) + ((vic_table[vicMode][VSYNC_POL] == ACTIVE_LOW) ? 0 : 2);
+	u32 v_h_polarity = ((mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : 1) +
+						((mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : 2);
 
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
 						    (SCHEDULER_H_SIZE << 2),
 						    (hactive << 16) + hblank);
 	if (ret != CDN_OK)
 		return ret;
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
 						    (SCHEDULER_V_SIZE << 2),
 						    (vactive << 16) + vblank);
 	if (ret != CDN_OK)
 		return ret;
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
 						    (HDTX_SIGNAL_FRONT_WIDTH <<
 						     2),
 						    (vfront << 16) + hfront);
 	if (ret != CDN_OK)
 		return ret;
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
 						    (HDTX_SIGNAL_SYNC_WIDTH <<
 						     2), (vsync << 16) + hsync);
 	if (ret != CDN_OK)
 		return ret;
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
 						    (HDTX_SIGNAL_BACK_WIDTH <<
 						     2), (vback << 16) + hback);
 	if (ret != CDN_OK)
 		return ret;
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_VIF +
+
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_VIF +
 						    (HSYNC2VSYNC_POL_CTRL << 2),
 						    v_h_polarity);
 	if (ret != CDN_OK)
@@ -368,8 +368,7 @@ CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
 
 	/* reset data enable */
 	resp.val = resp.val & (~(F_DATA_EN(1)));
-	ret =
-	    CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
+	ret = CDN_API_General_Write_Register_blocking(state, ADDR_SOURCE_MHL_HD +
 						    (HDTX_CONTROLLER << 2),
 						    resp.val);
 	if (ret != CDN_OK)
diff --git a/drivers/mxc/hdp/API_HDMITX.h b/drivers/mxc/hdp/API_HDMITX.h
index 570ae5a..f4a1aa9 100644
--- a/drivers/mxc/hdp/API_HDMITX.h
+++ b/drivers/mxc/hdp/API_HDMITX.h
@@ -49,7 +49,6 @@
 
 #include "API_General.h"
 #include "hdmi.h"
-#include "vic_table.h"
 
 /**
  * \addtogroup HDMI_TX_API
@@ -147,7 +146,7 @@ CDN_API_STATUS CDN_API_HDMITX_READ_EDID_blocking(state_struct *state, u8 block,
  * \returns status
  */
 CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(state_struct *state,
-					      VIC_MODES vicMode, int bpp,
+					      struct drm_display_mode *mode, int bpp,
 					      VIC_PXL_ENCODING_FORMAT format);
 
 /**
diff --git a/drivers/mxc/hdp/Makefile b/drivers/mxc/hdp/Makefile
index 08f37d6..235b845 100644
--- a/drivers/mxc/hdp/Makefile
+++ b/drivers/mxc/hdp/Makefile
@@ -8,5 +8,4 @@ obj-$(CONFIG_MX8_HDP) += \
 	API_HDMI_Audio.o \
 	API_Infoframe.o \
 	API_DPTX.o \
-	util.o \
-	vic_table.o
+	util.o
diff --git a/drivers/mxc/hdp/all.h b/drivers/mxc/hdp/all.h
index 5cba69b..ca51a1e 100644
--- a/drivers/mxc/hdp/all.h
+++ b/drivers/mxc/hdp/all.h
@@ -58,5 +58,4 @@
 #include "source_car.h"
 #include "source_phy.h"
 #include "source_vif.h"
-#include "vic_table.h"
 #include "util.h"
diff --git a/drivers/mxc/hdp/util.h b/drivers/mxc/hdp/util.h
index 212e54c..063c369 100644
--- a/drivers/mxc/hdp/util.h
+++ b/drivers/mxc/hdp/util.h
@@ -49,6 +49,8 @@
 
 #include <linux/delay.h>
 #include <linux/mutex.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_edid.h>
 
 /**
  * \addtogroup GENERAL_API
@@ -106,6 +108,49 @@
 	CDN_BUS_TYPE_SAPB = 1
 } CDN_BUS_TYPE;
 
+typedef enum {
+	NUM_OF_LANES_1 = 1,
+	NUM_OF_LANES_2 = 2,
+	NUM_OF_LANES_4 = 4,
+} VIC_NUM_OF_LANES;
+
+typedef enum {
+	RATE_1_6 = 162,
+	RATE_2_1 = 216,
+	RATE_2_4 = 243,
+	RATE_2_7 = 270,
+	RATE_3_2 = 324,
+	RATE_4_3 = 432,
+	RATE_5_4 = 540,
+	RATE_8_1 = 810,
+} VIC_SYMBOL_RATE;
+
+typedef enum {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+} VIC_PXL_ENCODING_FORMAT;
+
+typedef enum {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+} VIC_COLOR_DEPTH;
+
+typedef enum {
+	STEREO_VIDEO_LEFT = 0x0,
+	STEREO_VIDEO_RIGHT = 0x1,
+} STEREO_VIDEO_ATTR;
+
+typedef enum {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+} BT_TYPE;
+
 typedef struct {
     /** apb write status */
 	enum tx_status_enum {
@@ -345,5 +390,4 @@ CDN_API_STATUS internal_test_rx_head(state_struct *state, u8 module,
 void cdn_sleep(u32 ms);
 void cdn_usleep(u32 us);
 u16 internal_get_msg_len(state_struct *state);
-
 #endif
diff --git a/drivers/mxc/hdp/vic_table.c b/drivers/mxc/hdp/vic_table.c
deleted file mode 100644
index f826e5e..0000000
--- a/drivers/mxc/hdp/vic_table.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
- * All rights reserved worldwide.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation and/or
- * other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
- * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
- * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * Copyright 2017 NXP
- *
- ******************************************************************************
- *
- * This file was auto-generated. Do not edit it manually.
- *
- ******************************************************************************
- *
- * vic_table.c
- *
- ******************************************************************************
- */
-#include "vic_table.h"
-
-const unsigned int vic_table[VIC_MODE_COUNT][27] = {
-	{858, 720, 138, 62, 16, 60, 525, 480, 45, 6, 9, 30, 59, 27000,
-	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 3,
-	 8, 0},
-	{1650, 1280, 370, 40, 110, 220, 750, 720, 30, 5, 5, 20, 60, 74250,
-	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535, 65535,
-	 4, 8, 0},
-	{2200, 1920, 280, 44, 88, 148, 1125, 1080, 45, 5, 4,
-	 36, 60, 148500, PROGRESSIVE, ACTIVE_HIGH,
-	 ACTIVE_HIGH, 1, 65535, 1, 46, 65535, 65535, 16, 8, 0},
-	{4400, 3840, 560, 88, 176, 296, 2250, 2160, 90, 10, 8, 72, 60,
-	 594000, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
-	 285, 97, 8, 0},
-	{4400, 3840, 560, 88, 176, 296, 2250, 2160, 90, 10, 8, 72, 30,
-	 297000, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
-	 285, 95, 8, 0},
-};
diff --git a/drivers/mxc/hdp/vic_table.h b/drivers/mxc/hdp/vic_table.h
deleted file mode 100644
index 139c485..0000000
--- a/drivers/mxc/hdp/vic_table.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
- * All rights reserved worldwide.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation and/or
- * other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
- * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
- * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * Copyright 2017-2018 NXP
- *
- ******************************************************************************
- *
- * This file was auto-generated. Do not edit it manually.
- *
- ******************************************************************************
- *
- * vic_table.h
- *
- ******************************************************************************
- */
-
-#ifndef VIC_TABLE_H_
-#define VIC_TABLE_H_
-
-#define PROGRESSIVE 0
-#define INTERLACED 1
-
-#define ACTIVE_LOW 0
-#define ACTIVE_HIGH 1
-
-typedef enum {
-	H_TOTAL,
-	H_ACTIVE,
-	H_BLANK,
-	HSYNC,
-	FRONT_PORCH,
-	BACK_PORCH,
-	/* H_FREQ_KHZ, */
-	V_TOTAL,
-	V_ACTIVE,
-	V_BLANK,
-	VSYNC,
-	TYPE_EOF,
-	SOF,
-	V_FREQ_HZ,
-	PIXEL_FREQ_KHZ,
-	I_P,
-	HSYNC_POL,
-	VSYNC_POL,
-	START_OF_F0,
-	START_OF_F1,
-	VSYNC_START_INTERLACED_F0,
-	VSYNC_END_INTERLACED_F0,
-	VSYNC_START_INTERLACED_F1,
-	VSYNC_END_INTERLACED_F1,
-	VIC,
-	VIC_R3_0,
-	VIC_PR,
-} MSA_PARAM;
-
-typedef enum {
-	NUM_OF_LANES_1 = 1,
-	NUM_OF_LANES_2 = 2,
-	NUM_OF_LANES_4 = 4,
-} VIC_NUM_OF_LANES;
-
-typedef enum {
-	RATE_1_6 = 162,
-	RATE_2_1 = 216,
-	RATE_2_4 = 243,
-	RATE_2_7 = 270,
-	RATE_3_2 = 324,
-	RATE_4_3 = 432,
-	RATE_5_4 = 540,
-	RATE_8_1 = 810,
-} VIC_SYMBOL_RATE;
-
-typedef enum {
-	PXL_RGB = 0x1,
-	YCBCR_4_4_4 = 0x2,
-	YCBCR_4_2_2 = 0x4,
-	YCBCR_4_2_0 = 0x8,
-	Y_ONLY = 0x10,
-} VIC_PXL_ENCODING_FORMAT;
-
-typedef enum {
-	BCS_6 = 0x1,
-	BCS_8 = 0x2,
-	BCS_10 = 0x4,
-	BCS_12 = 0x8,
-	BCS_16 = 0x10,
-} VIC_COLOR_DEPTH;
-
-typedef enum {
-	STEREO_VIDEO_LEFT = 0x0,
-	STEREO_VIDEO_RIGHT = 0x1,
-} STEREO_VIDEO_ATTR;
-
-typedef enum {
-	BT_601 = 0x0,
-	BT_709 = 0x1,
-} BT_TYPE;
-
-typedef enum {
-	VIC_MODE_3_59_94Hz,
-	VIC_MODE_4_60Hz,
-	VIC_MODE_16_60Hz,
-	VIC_MODE_97_60Hz,
-	VIC_MODE_95_30Hz,
-	VIC_MODE_COUNT
-} VIC_MODES;
-
-extern const unsigned int vic_table[VIC_MODE_COUNT][27];
-
-#endif
-- 
1.7.9.5


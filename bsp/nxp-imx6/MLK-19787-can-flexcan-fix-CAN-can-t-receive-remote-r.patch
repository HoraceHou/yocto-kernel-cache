From f80f35e7ee28af6774e8ef50c3becd1e016e06bb Mon Sep 17 00:00:00 2001
From: Joakim Zhang <qiangqing.zhang@nxp.com>
Date: Thu, 18 Oct 2018 13:06:19 +0800
Subject: [PATCH 4899/5242] MLK-19787 can: flexcan: fix CAN can't receive
 remote request frame

commit  7fca8c6ebe4461cf83cdaf33aaff3232f6bfe5e1 from
https://source.codeaurora.org/external/imx/linux-imx.git

The flexcan driver allocates canfd-skb no matter whether use CAN FD
mode or not, it's unreasonable due to it will affect the parse of the
remote request frame.

To fix the issue, allocating can-skb with "alloc_can_skb()" in normal
mode and canfd-skb with "alloc_canfd_skb()" in fd mode.

Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
Signed-off-by: Joakim Zhang <qiangqing.zhang@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/can/flexcan.c      |    2 ++
 drivers/net/can/rx-offload.c   |    8 ++++++--
 include/linux/can/rx-offload.h |    2 ++
 3 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 9f754b7..b182408 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -1799,12 +1799,14 @@ static int flexcan_probe(struct platform_device *pdev)
 	priv->pdata = dev_get_platdata(&pdev->dev);
 	priv->devtype_data = devtype_data;
 	priv->reg_xceiver = reg_xceiver;
+	priv->offload.is_canfd = false;
 
 	if (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {
 		if (priv->devtype_data->quirks & FLEXCAN_QUIRK_TIMESTAMP_SUPPORT_FD) {
 			if (!(of_find_property(np, "disable-fd-mode", NULL))) {
 				priv->can.ctrlmode_supported |= CAN_CTRLMODE_FD;
 				priv->can.bittiming_const = &flexcan_fd_bittiming_const;
+				priv->offload.is_canfd = true;
 			}
 
 			priv->tx_mb_reserved_idx = FLEXCAN_TX_MB_RESERVED_OFF_TIMESTAMP_FD;
diff --git a/drivers/net/can/rx-offload.c b/drivers/net/can/rx-offload.c
index 46a9f35..d516e88 100644
--- a/drivers/net/can/rx-offload.c
+++ b/drivers/net/can/rx-offload.c
@@ -125,8 +125,12 @@ static struct sk_buff *can_rx_offload_offload_one(struct can_rx_offload *offload
 
 	/* If queue is full or skb not available, read to discard mailbox */
 	if (likely(skb_queue_len(&offload->skb_queue) <=
-		   offload->skb_queue_len_max))
-		skb = alloc_canfd_skb(offload->dev, &cf);
+		   offload->skb_queue_len_max)) {
+		if (offload->is_canfd)
+			skb = alloc_canfd_skb(offload->dev, &cf);
+		else
+			skb = alloc_can_skb(offload->dev, (struct can_frame **)&cf);
+	}
 
 	if (!skb) {
 		struct canfd_frame cf_overflow;
diff --git a/include/linux/can/rx-offload.h b/include/linux/can/rx-offload.h
index e4b1118..6448e7d 100644
--- a/include/linux/can/rx-offload.h
+++ b/include/linux/can/rx-offload.h
@@ -35,6 +35,8 @@ struct can_rx_offload {
 	struct napi_struct napi;
 
 	bool inc;
+
+	bool is_canfd;
 };
 
 int can_rx_offload_add_timestamp(struct net_device *dev, struct can_rx_offload *offload);
-- 
1.7.9.5


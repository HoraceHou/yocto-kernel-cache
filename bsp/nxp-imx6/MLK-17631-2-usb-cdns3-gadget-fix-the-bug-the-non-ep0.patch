From e38682c7be56c3d59c8d231172a70029613924eb Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Tue, 6 Mar 2018 15:21:01 +0800
Subject: [PATCH 3699/5242] MLK-17631-2 usb: cdns3: gadget: fix the bug the
 non-ep0 can't work after disconnection

commit  997ccf4804751a6dbef36d5714b1bf5b60c9c08e from
https://source.codeaurora.org/external/imx/linux-imx.git

We add endpoints to ep_match_list when adding gadget module, but
we delete the endpoints from the ep_match_list before set configuration.
When the re-enumeration after the new connection, the ep_match_list
is empty, in that case, the non-ep0s have not configurated, the
transfer on them will be failed.

In this commit, we only delete the endpoints from the list when we
remove the gadget module.

Acked-by: Jun Li <jun.li@nxp.com>
Signed-off-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/cdns3/gadget.c |   14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/drivers/usb/cdns3/gadget.c b/drivers/usb/cdns3/gadget.c
index 14588d3..7144d70 100644
--- a/drivers/usb/cdns3/gadget.c
+++ b/drivers/usb/cdns3/gadget.c
@@ -755,10 +755,8 @@ static int cdns_req_ep0_set_configuration(struct usb_ss_dev *usb_ss,
 	case USB_STATE_ADDRESS:
 		/* Configure non-control EPs */
 		list_for_each_entry_safe(usb_ss_ep, temp_ss_ep,
-			&usb_ss->ep_match_list, ep_match_pending_list) {
+			&usb_ss->ep_match_list, ep_match_pending_list)
 			cdns_ep_config(usb_ss_ep);
-			list_del(&usb_ss_ep->ep_match_pending_list);
-		}
 
 #ifdef CDNS_THREADED_IRQ_HANDLING
 		usb_ss->ep_ien = gadget_readl(usb_ss, &usb_ss->regs->ep_ien)
@@ -1980,18 +1978,24 @@ static int usb_ss_gadget_udc_stop(struct usb_gadget *gadget)
 {
 	struct usb_ss_dev *usb_ss = gadget_to_usb_ss(gadget);
 	struct usb_ep *ep;
-	struct usb_ss_endpoint *usb_ss_ep;
+	struct usb_ss_endpoint *usb_ss_ep, *temp_ss_ep;
 	int i;
 	u32 bEndpointAddress;
 
 	usb_ss->gadget_driver = NULL;
+
+	list_for_each_entry_safe(usb_ss_ep, temp_ss_ep,
+		&usb_ss->ep_match_list, ep_match_pending_list) {
+		list_del(&usb_ss_ep->ep_match_pending_list);
+		usb_ss_ep->used = false;
+	}
+
 	if (!usb_ss->start_gadget)
 		return 0;
 
 	list_for_each_entry(ep, &usb_ss->gadget.ep_list, ep_list) {
 		usb_ss_ep = to_usb_ss_ep(ep);
 		bEndpointAddress = usb_ss_ep->num | usb_ss_ep->dir;
-		usb_ss_ep->used = false;
 		select_ep(usb_ss, bEndpointAddress);
 		gadget_writel(usb_ss, &usb_ss->regs->ep_cmd,
 			EP_CMD__EPRST__MASK);
-- 
1.7.9.5


From 511f7428ab4d7b7ad6999b278a0939401c02dafb Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Mon, 14 May 2018 17:02:35 +0800
Subject: [PATCH 3952/5242] MLK-18319-1 usb: cdns3: gadget: improvement the
 handling for non-aligned buffer

commit  65aed0a45ffa70180819216e2125c3ad6e3eb4b1 from
https://source.codeaurora.org/external/imx/linux-imx.git

If the user buffer is not 8-byte aligned, it needs to use debounce
buffer for DMA transfer, and in this commit, we do below two
improvements:
- Copy back the request buffer when the transfer has completed
- Using Macro for default debounce buffer size

Reviewed-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/cdns3/gadget.c |   28 +++++++++++++++++++---------
 drivers/usb/cdns3/gadget.h |    1 +
 2 files changed, 20 insertions(+), 9 deletions(-)

diff --git a/drivers/usb/cdns3/gadget.c b/drivers/usb/cdns3/gadget.c
index c7a3e14..46678a5 100644
--- a/drivers/usb/cdns3/gadget.c
+++ b/drivers/usb/cdns3/gadget.c
@@ -414,9 +414,14 @@ static int cdns_ep_run_transfer(struct usb_ss_endpoint *usb_ss_ep)
 	trb_dma = request->dma;
 
 	/* must allocate buffer aligned to 8 */
-	if (request->dma % ADDR_MODULO_8) {
-		memcpy(usb_ss_ep->cpu_addr, request->buf, request->length);
-		trb_dma = usb_ss_ep->dma_addr;
+	if ((request->dma % ADDR_MODULO_8)) {
+		if (request->length <= CDNS3_UNALIGNED_BUF_SIZE) {
+			memcpy(usb_ss_ep->cpu_addr, request->buf,
+				request->length);
+			trb_dma = usb_ss_ep->dma_addr;
+		} else {
+			return -ENOMEM;
+		}
 	}
 
 	trb = usb_ss_ep->trb_pool;
@@ -1006,6 +1011,11 @@ static int cdns_check_ep_interrupt_proceed(struct usb_ss_endpoint *usb_ss_ep)
 		if (!request)
 			return 0;
 
+		if ((request->dma % ADDR_MODULO_8) &&
+				(usb_ss_ep->dir == USB_DIR_OUT))
+			memcpy(request->buf, usb_ss_ep->cpu_addr,
+					request->length);
+
 		usb_gadget_unmap_request_by_dev(usb_ss->sysdev, request,
 			usb_ss_ep->endpoint.desc->bEndpointAddress
 			& ENDPOINT_DIR_MASK);
@@ -1605,9 +1615,9 @@ static int usb_ss_gadget_ep_enable(struct usb_ep *ep,
 		return ret;
 
 	if (!usb_ss_ep->cpu_addr) {
-		usb_ss_ep->cpu_addr = dma_alloc_coherent(usb_ss->sysdev, 4096,
-			&usb_ss_ep->dma_addr, GFP_DMA);
-
+		usb_ss_ep->cpu_addr = dma_alloc_coherent(usb_ss->sysdev,
+				CDNS3_UNALIGNED_BUF_SIZE,
+				&usb_ss_ep->dma_addr, GFP_DMA);
 		if (!usb_ss_ep->cpu_addr)
 			return -ENOMEM;
 	}
@@ -1711,8 +1721,8 @@ static void usb_ss_free_trb_pool(struct usb_ss_endpoint *usb_ss_ep)
 	}
 
 	if (usb_ss_ep->cpu_addr) {
-		dma_free_coherent(usb_ss->sysdev, 4096, usb_ss_ep->cpu_addr,
-			usb_ss_ep->dma_addr);
+		dma_free_coherent(usb_ss->sysdev, CDNS3_UNALIGNED_BUF_SIZE,
+			usb_ss_ep->cpu_addr, usb_ss_ep->dma_addr);
 		usb_ss_ep->cpu_addr = NULL;
 	}
 }
@@ -1853,7 +1863,7 @@ static int usb_ss_gadget_ep_queue(struct usb_ep *ep,
 
 	if (empty_list) {
 		if (!usb_ss_ep->stalled_flag)
-			cdns_ep_run_transfer(usb_ss_ep);
+			ret = cdns_ep_run_transfer(usb_ss_ep);
 	}
 	spin_unlock_irqrestore(&usb_ss->lock, flags);
 
diff --git a/drivers/usb/cdns3/gadget.h b/drivers/usb/cdns3/gadget.h
index f4d15af..af8f33e 100644
--- a/drivers/usb/cdns3/gadget.h
+++ b/drivers/usb/cdns3/gadget.h
@@ -149,6 +149,7 @@
 /* 18KB is the total size, and 2KB is used for EP0 and configuration */
 #define CDNS3_ONCHIP_BUF_SIZE	16	/* KB */
 #define CDNS3_EP_BUF_SIZE	2	/* KB */
+#define CDNS3_UNALIGNED_BUF_SIZE	16384 /* Bytes */
 /*-------------------------------------------------------------------------*/
 /* Used structs */
 
-- 
1.7.9.5


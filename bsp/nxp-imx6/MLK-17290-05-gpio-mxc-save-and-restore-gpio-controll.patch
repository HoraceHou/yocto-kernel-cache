From afe5718b09545a63b31f3a168f7272b332dce8e5 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Mon, 25 Dec 2017 17:44:28 +0800
Subject: [PATCH 3139/5242] MLK-17290-05 gpio: mxc: save and restore gpio
 controller registers when power off

commit  e70f05b91281c982fde572e006ef6ddee085c68e from
https://source.codeaurora.org/external/imx/linux-imx.git

Save gpio controller registers before power off, and then restore these
registers after power on. There have two cases need to save/restore regs:
  a. If sub_irqs/sub_gpios are not free/released, device suspend() force
     runtime suspend and power domain off in suspended stage, it needs to
     keep the previous registers value after device resume back.
  b. If some sub_irqs set irq type just one time, then irqchip should restore
     the registers for correct irq type.

Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Tested-by: Guoniu.Zhou <guoniu.zhou@nxp.com>
Reviewed-by: Frank Li <Frank.Li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpio/gpio-mxc.c |   45 ++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 44 insertions(+), 1 deletion(-)

diff --git a/drivers/gpio/gpio-mxc.c b/drivers/gpio/gpio-mxc.c
index 84ef42e..d6593d8 100644
--- a/drivers/gpio/gpio-mxc.c
+++ b/drivers/gpio/gpio-mxc.c
@@ -56,6 +56,7 @@ struct mxc_gpio_port {
 	struct gpio_chip gc;
 	struct device *dev;
 	u32 both_edges;
+	int saved_reg[6];
 	bool gpio_ranges;
 };
 
@@ -576,11 +577,46 @@ static int mxc_gpio_probe(struct platform_device *pdev)
 	return err;
 }
 
+static void mxc_gpio_save_regs(struct mxc_gpio_port *port)
+{
+	unsigned long flags;
+
+	if (mxc_gpio_hwtype == IMX21_GPIO)
+		return;
+
+	spin_lock_irqsave(&port->gc.bgpio_lock, flags);
+	port->saved_reg[0] = readl(port->base + GPIO_ICR1);
+	port->saved_reg[1] = readl(port->base + GPIO_ICR2);
+	port->saved_reg[2] = readl(port->base + GPIO_IMR);
+	port->saved_reg[3] = readl(port->base + GPIO_GDIR);
+	port->saved_reg[4] = readl(port->base + GPIO_EDGE_SEL);
+	port->saved_reg[5] = readl(port->base + GPIO_DR);
+	spin_unlock_irqrestore(&port->gc.bgpio_lock, flags);
+}
+
+static void mxc_gpio_restore_regs(struct mxc_gpio_port *port)
+{
+	unsigned long flags;
+
+	if (mxc_gpio_hwtype == IMX21_GPIO)
+		return;
+
+	spin_lock_irqsave(&port->gc.bgpio_lock, flags);
+	writel(port->saved_reg[0], port->base + GPIO_ICR1);
+	writel(port->saved_reg[1], port->base + GPIO_ICR2);
+	writel(port->saved_reg[2], port->base + GPIO_IMR);
+	writel(port->saved_reg[3], port->base + GPIO_GDIR);
+	writel(port->saved_reg[4], port->base + GPIO_EDGE_SEL);
+	writel(port->saved_reg[5], port->base + GPIO_DR);
+	spin_unlock_irqrestore(&port->gc.bgpio_lock, flags);
+}
+
 static int __maybe_unused mxc_gpio_runtime_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct mxc_gpio_port *port = platform_get_drvdata(pdev);
 
+	mxc_gpio_save_regs(port);
 	clk_disable_unprepare(port->clk);
 
 	return 0;
@@ -590,8 +626,15 @@ static int __maybe_unused mxc_gpio_runtime_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct mxc_gpio_port *port = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = clk_prepare_enable(port->clk);
+	if (ret)
+		return ret;
 
-	return clk_prepare_enable(port->clk);
+	mxc_gpio_restore_regs(port);
+
+	return 0;
 }
 
 static int __maybe_unused mxc_gpio_suspend(struct device *dev)
-- 
1.7.9.5


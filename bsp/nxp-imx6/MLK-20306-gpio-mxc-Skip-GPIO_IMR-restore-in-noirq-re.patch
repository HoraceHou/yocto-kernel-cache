From 21674407c64f34a8e2ce095270dbbc1894c1f71e Mon Sep 17 00:00:00 2001
From: Bai Ping <ping.bai@nxp.com>
Date: Fri, 9 Nov 2018 17:11:52 +0800
Subject: [PATCH 5158/5242] MLK-20306 gpio: mxc: Skip GPIO_IMR restore in
 noirq resume

commit  cf3ac97055b1198d7be0b53b51d9fc7071c82159 from
https://source.codeaurora.org/external/imx/linux-imx.git

During the time window of noirq suspend and noirq resume, if a GPIO
pin is enabled as system wakeup source, the corresponding GPIO line's
IRQ will be unmasked, and GPIO bank will NOT lost power, when GPIO irq
arrives, generic irq handler will mask it until GPIO driver is ready
to handle it, but in GPIO noirq resume callback, current
implementation will restore the IMR register using the value saved in
previous noirq suspend callback which is unmasked, so this GPIO line
with IRQ pending will be unmasked again after GPIO IMR regitster is
restored, ARM will be triggered to handle this IRQ again, because of
the change of commit bf22ff45bed6 ("genirq: Avoid unnecessary low
level irq function calls"), the mask_irq function will check the
status of irq_data to decide whether to mask the irq, in this
scenario, since the GPIO IRQ is being masked before GPIO noirq resume,
IRQD_IRQ_MASKED flag is set, so the second time GPIO IRQ triggered by
restoring GPIO IMR register, the irq_mask callback will be skipped and
cause ARM busy handling the GPIO IRQ come all the way and no response to
user anymore.

Signed-off-by: Bai Ping <ping.bai@nxp.com>
Reviewed-by: Anson Huang <Anson.Huang@nxp.com>
(cherry picked from commit c03d9ec1f861ff7cd04637ef01aa7e14388277b6)
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpio/gpio-mxc.c |    2 --
 1 file changed, 2 deletions(-)

diff --git a/drivers/gpio/gpio-mxc.c b/drivers/gpio/gpio-mxc.c
index 1aeca44..8c1fad2 100644
--- a/drivers/gpio/gpio-mxc.c
+++ b/drivers/gpio/gpio-mxc.c
@@ -781,7 +781,6 @@ static int __maybe_unused mxc_gpio_noirq_suspend(struct device *dev)
 	spin_lock_irqsave(&port->gc.bgpio_lock, flags);
 	port->suspend_saved_reg[0] = readl(port->base + GPIO_ICR1);
 	port->suspend_saved_reg[1] = readl(port->base + GPIO_ICR2);
-	port->suspend_saved_reg[2] = readl(port->base + GPIO_IMR);
 	port->suspend_saved_reg[3] = readl(port->base + GPIO_GDIR);
 	port->suspend_saved_reg[4] = readl(port->base + GPIO_EDGE_SEL);
 	port->suspend_saved_reg[5] = readl(port->base + GPIO_DR);
@@ -812,7 +811,6 @@ static int __maybe_unused mxc_gpio_noirq_resume(struct device *dev)
 	spin_lock_irqsave(&port->gc.bgpio_lock, flags);
 	writel(port->suspend_saved_reg[0], port->base + GPIO_ICR1);
 	writel(port->suspend_saved_reg[1], port->base + GPIO_ICR2);
-	writel(port->suspend_saved_reg[2], port->base + GPIO_IMR);
 	writel(port->suspend_saved_reg[3], port->base + GPIO_GDIR);
 	writel(port->suspend_saved_reg[4], port->base + GPIO_EDGE_SEL);
 	writel(port->suspend_saved_reg[5], port->base + GPIO_DR);
-- 
1.7.9.5


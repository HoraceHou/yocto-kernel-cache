From 07d1a3742236835f133f18d2260f64b622690c6c Mon Sep 17 00:00:00 2001
From: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Date: Tue, 18 Sep 2018 10:05:35 +0300
Subject: [PATCH 4689/5242] MLK-19265: drm: imx: dcss: ignore invisible planes

commit  e87e00705793cdc072210e620226dd442f8a62ba from
https://source.codeaurora.org/external/imx/linux-imx.git

Right now, an error is returned in the atomic_check callback if a plane
is not visible. However, this can lead to warnings when removing
framebuffers after connector is removed. That's because display's width
and height becomes 0 and, technically, the plane becomes invisible. Any
attempt to remove a plane will also perform an atomic_commit() on the
remaining, still active, planes. Since they are invisible, the following
warning will be shown:

[  161.623590] atomic remove_fb failed with -22
Signed-off-by: Meng Li <Meng.Li@windriver.com>
[  161.628099] ------------[ cut here ]------------
[  161.632727] WARNING: CPU: 0 PID: 95 at /usr/src/kernel/drivers/gpu/drm/drm_framebuffer.c:924 drm_framebuffer_remove+0x3b8/0x3e0
[  161.644200] Modules linked in: 8021q garp stp mrp qca6174(O) crc32_ce crct10dif_ce galcore(O) ipv6
[  161.653175] CPU: 0 PID: 95 Comm: kworker/0:1 Tainted: G           O 4.14.62-imx_4.14.y+gef7acf9 #1
[  161.662391] Hardware name: Freescale i.MX8MQ EVK (DT)
[  161.667443] Workqueue: events drm_mode_rmfb_work_fn
[  161.672319] task: ffff8000b8973600 task.stack: ffff000009ee0000
[  161.678237] PC is at drm_framebuffer_remove+0x3b8/0x3e0
[  161.683460] LR is at drm_framebuffer_remove+0x3b8/0x3e0
[  161.688683] pc : [<ffff00000867f5d0>] lr : [<ffff00000867f5d0>] pstate: 40000145
[  161.696075] sp : ffff000009ee3d10
[  161.699388] x29: ffff000009ee3d10 x28: 0000000000000000
[  161.704701] x27: 0000000000000000 x26: ffff8000b8fda000
[  161.710013] x25: ffff0000080e8c60 x24: ffff00001999bc90
[  161.715324] x23: 00000000ffffffea x22: ffff8000bdf63580
[  161.720636] x21: ffff8000b45d6280 x20: ffff8000b5fd2800
[  161.725947] x19: ffff00001999bc90 x18: 0000000000000010
[  161.731258] x17: 0000ffff9d121910 x16: ffff000008231398
[  161.736570] x15: ffffffffffffffff x14: ffff0000895c144f
[  161.741881] x13: ffff0000095c145d x12: ffff000009429df8
[  161.747193] x11: ffff000008616e40 x10: ffff000009ee3a20
[  161.752504] x9 : 0000000000000006 x8 : 6961662062665f65
[  161.757816] x7 : 766f6d6572206369 x6 : 00000000000002ba
[  161.763127] x5 : 0000000000000000 x4 : 0000000000000000
[  161.768438] x3 : 0000000000000000 x2 : ffff8000bdf5fef0
[  161.773749] x1 : ffff8000b8973600 x0 : 0000000000000020
[  161.779061] Call trace:
[  161.781507] Exception stack(0xffff000009ee3bd0 to 0xffff000009ee3d10)
[  161.787946] 3bc0:                                   0000000000000020 ffff8000b8973600
[  161.795774] 3be0: ffff8000bdf5fef0 0000000000000000 0000000000000000 0000000000000000
[  161.803601] 3c00: 00000000000002ba 766f6d6572206369 6961662062665f65 0000000000000006
[  161.811430] 3c20: ffff000009ee3a20 ffff000008616e40 ffff000009429df8 ffff0000095c145d
[  161.819258] 3c40: ffff0000895c144f ffffffffffffffff ffff000008231398 0000ffff9d121910
[  161.827086] 3c60: 0000000000000010 ffff00001999bc90 ffff8000b5fd2800 ffff8000b45d6280
[  161.834914] 3c80: ffff8000bdf63580 00000000ffffffea ffff00001999bc90 ffff0000080e8c60
[  161.842743] 3ca0: ffff8000b8fda000 0000000000000000 0000000000000000 ffff000009ee3d10
[  161.850571] 3cc0: ffff00000867f5d0 ffff000009ee3d10 ffff00000867f5d0 0000000040000145
[  161.858399] 3ce0: 0000000000000000 ffff8000b8973600 ffffffffffffffff ffff00000867cfb4
[  161.866226] 3d00: ffff000009ee3d10 ffff00000867f5d0
[  161.871103] [<ffff00000867f5d0>] drm_framebuffer_remove+0x3b8/0x3e0
[  161.877369] [<ffff00000867f638>] drm_mode_rmfb_work_fn+0x40/0x58
[  161.883375] [<ffff0000080e8aec>] process_one_work+0x1d4/0x348
[  161.889120] [<ffff0000080e8ea4>] worker_thread+0x244/0x470
[  161.894606] [<ffff0000080eefac>] kthread+0x12c/0x130
[  161.899571] [<ffff000008084ed8>] ret_from_fork+0x10/0x18
[  161.904880] ---[ end trace 489a96a125920066 ]---

To avoid this, we simply return 0 in the atomic_check() callback and do
not perform any update on the plane in the atomic_update().
Since the plane is invisible, it's perfectly fine.

Signed-off-by: Laurentiu Palcu <laurentiu.palcu@nxp.com>
---
 drivers/gpu/drm/imx/dcss/dcss-plane.c |   15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/imx/dcss/dcss-plane.c b/drivers/gpu/drm/imx/dcss/dcss-plane.c
index b9f26b1..0c75f6d 100644
--- a/drivers/gpu/drm/imx/dcss/dcss-plane.c
+++ b/drivers/gpu/drm/imx/dcss/dcss-plane.c
@@ -218,12 +218,9 @@ static int dcss_plane_atomic_check(struct drm_plane *plane,
 	int hdisplay, vdisplay;
 	struct drm_rect crtc_rect, disp_rect;
 
-	if (!fb)
+	if (!fb || !state->crtc)
 		return 0;
 
-	if (!state->crtc)
-		return -EINVAL;
-
 	cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
 	WARN_ON(!cma_obj);
 
@@ -244,8 +241,12 @@ static int dcss_plane_atomic_check(struct drm_plane *plane,
 	disp_rect.y2 = vdisplay;
 
 	/* make sure the crtc is visible */
-	if (!drm_rect_intersect(&crtc_rect, &disp_rect))
-		return -EINVAL;
+	if (!drm_rect_intersect(&crtc_rect, &disp_rect)) {
+		state->visible = false;
+		return 0;
+	}
+
+	state->visible = true;
 
 	if (!dcss_plane_can_rotate(fb->format->format,
 				   !!(fb->flags & DRM_MODE_FB_MODIFIERS),
@@ -480,7 +481,7 @@ static void dcss_plane_atomic_update(struct drm_plane *plane,
 	struct dcss_hdr10_pipe_cfg ipipe_cfg, opipe_cfg;
 	bool enable = true;
 
-	if (!fb || !state->crtc)
+	if (!fb || !state->crtc || !state->visible)
 		return;
 
 	pixel_format = state->fb->format->format;
-- 
1.7.9.5


From eb04eb71a5a490f528ff2c081ffd6a81856ff08b Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Tue, 26 Jun 2018 15:07:34 +0800
Subject: [PATCH 4105/5242] MLK-18690-1: hdmi: Rewrite hdmi avi infoframe
 function

commit  bb26ca75ca843135d2aa23cbbd5a824f584c28f5 from
https://source.codeaurora.org/external/imx/linux-imx.git

Remove Cadence AVI infoframe function.
Replace with hdmi avi infoframe api function.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/hdp/imx-hdmi.c |  121 ++++++++++++++++++++----------------
 1 file changed, 69 insertions(+), 52 deletions(-)

diff --git a/drivers/gpu/drm/imx/hdp/imx-hdmi.c b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
index 2c4abed..84fa5be 100644
--- a/drivers/gpu/drm/imx/hdp/imx-hdmi.c
+++ b/drivers/gpu/drm/imx/hdp/imx-hdmi.c
@@ -76,6 +76,69 @@ int hdmi_fw_init(state_struct *state)
 	return 0;
 }
 
+#define RGB_ALLOWED_COLORIMETRY (BIT(HDMI_EXTENDED_COLORIMETRY_BT2020) |\
+				 BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB))
+#define YCC_ALLOWED_COLORIMETRY (BIT(HDMI_EXTENDED_COLORIMETRY_BT2020) |\
+				 BIT(HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM) |\
+				 BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601) |\
+				 BIT(HDMI_EXTENDED_COLORIMETRY_S_YCC_601) |\
+				 BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_709) |\
+				 BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_601))
+
+static int hdmi_avi_info_set(struct imx_hdp *hdp,
+				struct drm_display_mode *mode,
+				int format)
+{
+	struct hdmi_avi_infoframe frame;
+	struct drm_display_info *di = &hdp->connector.display_info;
+	enum hdmi_extended_colorimetry ext_colorimetry;
+	u32 sink_colorimetry;
+	u32 allowed_colorimetry;
+	u8 buf[32];
+	int ret;
+
+	/* Initialise info frame from DRM mode */
+	drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, false);
+
+	/* Set up colorimetry */
+	allowed_colorimetry = format == PXL_RGB ? RGB_ALLOWED_COLORIMETRY :
+						  YCC_ALLOWED_COLORIMETRY;
+
+	sink_colorimetry = di->hdmi.colorimetry & allowed_colorimetry;
+
+	if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_BT2020))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_BT2020;
+	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM;
+	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB;
+	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_709))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
+	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601;
+	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_S_YCC_601))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_S_YCC_601;
+	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_601))
+		ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+	else
+		ext_colorimetry = 0;
+
+	frame.colorimetry = sink_colorimetry ? HDMI_COLORIMETRY_EXTENDED :
+					  HDMI_COLORIMETRY_NONE;
+	frame.extended_colorimetry = ext_colorimetry;
+
+	ret = hdmi_avi_infoframe_pack(&frame, buf + 1, sizeof(buf) - 1);
+	if (ret < 0) {
+		DRM_ERROR("failed to pack AVI infoframe: %d\n", ret);
+		return -1;
+	}
+
+	buf[0] = 0;
+	return CDN_API_InfoframeSet(&hdp->state, 0, sizeof(buf),
+				    (u32 *)buf, HDMI_INFOFRAME_TYPE_AVI);
+
+}
+
 int hdmi_phy_init_ss28fdsoi(state_struct *state, struct drm_display_mode *mode, int format, int color_depth)
 {
 	struct imx_hdp *hdp = state_to_imx_hdp(state);
@@ -107,6 +170,7 @@ int hdmi_phy_init_ss28fdsoi(state_struct *state, struct drm_display_mode *mode,
 
 void hdmi_mode_set_ss28fdsoi(state_struct *state, struct drm_display_mode *mode, int format, int color_depth, int temp)
 {
+	struct imx_hdp *hdp = container_of(state, struct imx_hdp, state);
 	int ret;
 
 	/* Mode = 0 - DVI, 1 - HDMI1.4, 2 HDMI 2.0 */
@@ -128,12 +192,13 @@ void hdmi_mode_set_ss28fdsoi(state_struct *state, struct drm_display_mode *mode,
 		return;
 	}
 
-	ret = CDN_API_Set_AVI(state, mode, format, 0, 0);
+	ret = hdmi_avi_info_set(hdp, mode, format);
 	if (ret != CDN_OK) {
-		DRM_INFO("CDN_API_Set_AVI  ret = %d\n", ret);
+		DRM_ERROR("hdmi avi info set ret = %d\n", ret);
 		return;
 	}
 
+
 	ret =  CDN_API_HDMITX_SetVic_blocking(state, mode, color_depth, format);
 	if (ret != CDN_OK) {
 		DRM_INFO("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
@@ -194,49 +259,6 @@ int hdmi_phy_init_t28hpc(state_struct *state, struct drm_display_mode *mode, int
 	return true;
 }
 
-#define RGB_ALLOWED_COLORIMETRY (BIT(HDMI_EXTENDED_COLORIMETRY_BT2020) |\
-				 BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB))
-#define YCC_ALLOWED_COLORIMETRY (BIT(HDMI_EXTENDED_COLORIMETRY_BT2020) |\
-				 BIT(HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM) |\
-				 BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601) |\
-				 BIT(HDMI_EXTENDED_COLORIMETRY_S_YCC_601) |\
-				 BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_709) |\
-				 BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_601))
-
-static void hdmi_compute_colorimetry(struct drm_display_info *di,
-				     int format,
-				     enum hdmi_colorimetry *colorimetry,
-				     enum hdmi_extended_colorimetry *ext_colorimetry)
-{
-	u32 sink_colorimetry;
-	u32 allowed_colorimetry;
-
-	allowed_colorimetry = format == PXL_RGB ? RGB_ALLOWED_COLORIMETRY :
-						  YCC_ALLOWED_COLORIMETRY;
-
-	sink_colorimetry = di->hdmi.colorimetry & allowed_colorimetry;
-
-	if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_BT2020))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_BT2020;
-	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM;
-	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB;
-	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_709))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
-	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601;
-	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_S_YCC_601))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_S_YCC_601;
-	else if (sink_colorimetry & BIT(HDMI_EXTENDED_COLORIMETRY_XV_YCC_601))
-		*ext_colorimetry = HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
-	else
-		*ext_colorimetry = 0;
-
-	*colorimetry = sink_colorimetry ? HDMI_COLORIMETRY_EXTENDED :
-					  HDMI_COLORIMETRY_NONE;
-}
-
 void hdmi_mode_set_vswing(state_struct *state)
 {
 	GENERAL_Read_Register_response regresp[12];
@@ -302,8 +324,6 @@ void hdmi_mode_set_t28hpc(state_struct *state, struct drm_display_mode *mode, in
 {
 	struct imx_hdp *hdp = container_of(state, struct imx_hdp, state);
 	int ret;
-	enum hdmi_colorimetry colorimetry;
-	enum hdmi_extended_colorimetry ext_colorimetry;
 
 	/* Set HDMI TX Mode */
 	/* Mode = 0 - DVI, 1 - HDMI1.4, 2 HDMI 2.0 */
@@ -325,12 +345,9 @@ void hdmi_mode_set_t28hpc(state_struct *state, struct drm_display_mode *mode, in
 		return;
 	}
 
-	hdmi_compute_colorimetry(&hdp->connector.display_info, format,
-				 &colorimetry, &ext_colorimetry);
-
-	ret = CDN_API_Set_AVI(state, mode, format, colorimetry, ext_colorimetry);
+	ret = hdmi_avi_info_set(hdp, mode, format);
 	if (ret != CDN_OK) {
-		DRM_ERROR("CDN_API_Set_AVI  ret = %d\n", ret);
+		DRM_ERROR("hdmi avi info set ret = %d\n", ret);
 		return;
 	}
 
-- 
1.7.9.5


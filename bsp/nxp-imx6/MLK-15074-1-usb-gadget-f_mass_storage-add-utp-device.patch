From 5083adbb5df2f8bf45706de39a5b3951cff4d31f Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@nxp.com>
Date: Wed, 14 Jun 2017 04:06:38 +0800
Subject: [PATCH 0372/5242] MLK-15074-1 usb: gadget: f_mass_storage: add utp
 device check

commit  e2f9d464ac4d1d0adf8d7508d04834137e4d1723 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add utp device check for utp handling in f_mass_storage.

Acked-by: Peter Chen <peter.chen@nxp.com>
Signed-off-by: Li Jun <jun.li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/gadget/function/f_mass_storage.c |   38 ++++++++++++++++----------
 drivers/usb/gadget/function/fsl_updater.c    |   18 +++++++++++-
 drivers/usb/gadget/function/fsl_updater.h    |    7 ++++-
 3 files changed, 46 insertions(+), 17 deletions(-)

diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index 9d10f99..57123cd 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -1120,7 +1120,9 @@ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 #endif
 
 #ifdef CONFIG_FSL_UTP
-	if (utp_get_sense(common->fsg) == 0) {  /* got the sense from the UTP */
+	if (is_utp_device(common->fsg) &&
+			utp_get_sense(common->fsg) == 0) {
+		/* got the sense from the UTP */
 		sd = UTP_CTX(common->fsg)->sd;
 		sdinfo = UTP_CTX(common->fsg)->sdinfo;
 		valid = 0;
@@ -1148,7 +1150,8 @@ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 	buf[12] = ASC(sd);
 	buf[13] = ASCQ(sd);
 #ifdef CONFIG_FSL_UTP
-	put_unaligned_be32(UTP_CTX(common->fsg)->sdinfo_h, &buf[8]);
+	if (is_utp_device(common->fsg))
+		put_unaligned_be32(UTP_CTX(common->fsg)->sdinfo_h, &buf[8]);
 #endif
 	return 18;
 }
@@ -1637,17 +1640,19 @@ static void send_status(struct fsg_common *common)
 	} else if (sd != SS_NO_SENSE) {
 		DBG(common, "sending command-failure status\n");
 #ifdef CONFIG_FSL_UTP
-/*
- * mfgtool host frequently reset bus during transfer
- *  - the response in csw to request sense will be 1 due to UTP change
- *    some storage information
- *  - host will reset the bus if response to request sense is 1
- *  - change the response to 0 if CONFIG_FSL_UTP is defined
- */
-		status = US_BULK_STAT_OK;
-#else
-		status = US_BULK_STAT_FAIL;
+		/*
+		 * mfgtool host frequently reset bus during transfer
+		 *  - the response in csw to request sense will be 1
+		 *    due to UTP change some storage information
+		 *  - host will reset the bus if response to request sense is 1
+		 *  - change the response to 0 if CONFIG_FSL_UTP is defined
+		 */
+		if (is_utp_device(common->fsg))
+			status = US_BULK_STAT_OK;
+		else
 #endif
+			status = US_BULK_STAT_FAIL;
+
 		VDBG(common, "  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"
 				"  info x%x\n",
 				SK(sd), ASC(sd), ASCQ(sd), sdinfo);
@@ -1838,7 +1843,8 @@ static int do_scsi_command(struct fsg_common *common)
 	common->short_packet_received = 0;
 
 #ifdef CONFIG_FSL_UTP
-	reply = utp_handle_message(common->fsg, common->cmnd, reply);
+	if (is_utp_device(common->fsg))
+		reply = utp_handle_message(common->fsg, common->cmnd, reply);
 
 	if (reply != -EINVAL)
 		return reply;
@@ -2992,7 +2998,8 @@ static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 	fsg->interface_number = i;
 
 #ifdef CONFIG_FSL_UTP
-	utp_init(fsg);
+	if (is_utp_device(common->fsg))
+		utp_init(fsg);
 #endif
 
 	/* Find all the endpoints we will use */
@@ -3060,7 +3067,8 @@ static void fsg_unbind(struct usb_configuration *c, struct usb_function *f)
 	usb_free_all_descriptors(&fsg->function);
 
 #ifdef CONFIG_FSL_UTP
-	utp_exit(fsg);
+	if (is_utp_device(common->fsg))
+		utp_exit(fsg);
 #endif
 
 }
diff --git a/drivers/usb/gadget/function/fsl_updater.c b/drivers/usb/gadget/function/fsl_updater.c
index 61658cf..c248962 100644
--- a/drivers/usb/gadget/function/fsl_updater.c
+++ b/drivers/usb/gadget/function/fsl_updater.c
@@ -1,8 +1,9 @@
 /*
  * Freescale UUT driver
  *
- * Copyright 2008-2014 Freescale Semiconductor, Inc.
+ * Copyright 2008-2016 Freescale Semiconductor, Inc.
  * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2017 NXP
  */
 
 /*
@@ -14,6 +15,21 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
+static bool is_utp_device(struct fsg_dev *fsg)
+{
+	struct usb_device_descriptor *pdesc;
+
+	if (!fsg || !fsg->common || !fsg->common->cdev)
+		return false;
+
+	pdesc = &fsg->common->cdev->desc;
+	if (pdesc->idVendor == UTP_IDVENDOR &&
+		pdesc->idProduct == UTP_IDPRODUCT)
+		return true;
+
+	return false;
+}
+
 static u64 get_be64(u8 *buf)
 {
 	return ((u64)get_unaligned_be32(buf) << 32) |
diff --git a/drivers/usb/gadget/function/fsl_updater.h b/drivers/usb/gadget/function/fsl_updater.h
index 15ebc09..a50d550 100644
--- a/drivers/usb/gadget/function/fsl_updater.h
+++ b/drivers/usb/gadget/function/fsl_updater.h
@@ -1,8 +1,9 @@
 /*
  * Freescale UUT driver
  *
- * Copyright 2008-2014 Freescale Semiconductor, Inc.
+ * Copyright 2008-2016 Freescale Semiconductor, Inc.
  * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2017 NXP
  */
 
 /*
@@ -35,6 +36,7 @@ static ssize_t utp_file_write(struct file *file,
 			      size_t size,
 			      loff_t *off);
 
+static bool is_utp_device(struct fsg_dev *fsg);
 static long utp_ioctl(struct file *file,
 	      unsigned int cmd, unsigned long arg);
 static struct utp_user_data *utp_user_data_alloc(size_t size);
@@ -56,6 +58,9 @@ static int utp_handle_message(struct fsg_dev *fsg,
 #define UTP_MINOR		222
 /* MISC_DYNAMIC_MINOR would be better, but... */
 
+#define UTP_IDVENDOR		0x066F
+#define UTP_IDPRODUCT		0x37FF
+
 #define UTP_COMMAND_SIZE	80
 
 #define UTP_SS_EXIT(fsg, r)	utp_set_sense(fsg, UTP_REPLY_EXIT, (u64)r)
-- 
1.7.9.5


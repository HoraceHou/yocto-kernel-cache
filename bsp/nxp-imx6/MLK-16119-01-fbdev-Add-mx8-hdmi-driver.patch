From 08f3335a463ec30c8c9937a29f8064bbc77d0173 Mon Sep 17 00:00:00 2001
From: Sandor Yu <Sandor.yu@nxp.com>
Date: Tue, 1 Aug 2017 17:41:01 +0800
Subject: [PATCH 2276/5242] MLK-16119-01: fbdev: Add mx8 hdmi driver

commit  10fab75118105b9bbdfc9a2944738320560934b2 from
https://source.codeaurora.org/external/imx/linux-imx.git

Add hdmi api code from cadence.
Add mx8 hdmi driver.
Basic hdmi function:
no hotplug and no video mode dynamic change.

Signed-off-by: Sandor Yu <Sandor.yu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxc/cdn_hdp/API_AFE.c          |   81 +
 drivers/video/fbdev/mxc/cdn_hdp/API_AFE.h          |   63 +
 .../fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.c      | 1942 ++++++++++++++++++++
 .../fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.h      |   85 +
 drivers/video/fbdev/mxc/cdn_hdp/API_AVI.c          |  186 ++
 drivers/video/fbdev/mxc/cdn_hdp/API_AVI.h          |   55 +
 drivers/video/fbdev/mxc/cdn_hdp/API_Audio.c        |  416 +++++
 drivers/video/fbdev/mxc/cdn_hdp/API_Audio.h        |  152 ++
 drivers/video/fbdev/mxc/cdn_hdp/API_DPTX.h         |  426 +++++
 drivers/video/fbdev/mxc/cdn_hdp/API_General.c      |  443 +++++
 drivers/video/fbdev/mxc/cdn_hdp/API_General.h      |  291 +++
 drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.c         |  427 +++++
 drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.h         |  239 +++
 drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.c       |  388 ++++
 drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.h       |  145 ++
 drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.c   |  156 ++
 drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.h   |   66 +
 drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.c    |  132 ++
 drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.h    |   61 +
 drivers/video/fbdev/mxc/cdn_hdp/Makefile           |   14 +
 drivers/video/fbdev/mxc/cdn_hdp/address.h          |  105 ++
 drivers/video/fbdev/mxc/cdn_hdp/aif_pckt2smp.h     |  168 ++
 drivers/video/fbdev/mxc/cdn_hdp/apb_cfg.h          |  185 ++
 drivers/video/fbdev/mxc/cdn_hdp/clock_meters.h     |  157 ++
 drivers/video/fbdev/mxc/cdn_hdp/defs.h             |   54 +
 drivers/video/fbdev/mxc/cdn_hdp/dptx_framer.h      |  372 ++++
 drivers/video/fbdev/mxc/cdn_hdp/dptx_stream.h      |  206 +++
 drivers/video/fbdev/mxc/cdn_hdp/edid_parser.c      |  615 +++++++
 drivers/video/fbdev/mxc/cdn_hdp/edid_parser.h      |  295 +++
 drivers/video/fbdev/mxc/cdn_hdp/externs.h          |   75 +
 drivers/video/fbdev/mxc/cdn_hdp/general_handler.h  |  162 ++
 drivers/video/fbdev/mxc/cdn_hdp/hdcp.h             |   50 +
 drivers/video/fbdev/mxc/cdn_hdp/hdcp2.h            |  289 +++
 drivers/video/fbdev/mxc/cdn_hdp/hdcp_tran.h        |  258 +++
 drivers/video/fbdev/mxc/cdn_hdp/hdmi.h             |  119 ++
 drivers/video/fbdev/mxc/cdn_hdp/mailBox.h          |  116 ++
 drivers/video/fbdev/mxc/cdn_hdp/mhl_hdtx_top.h     |  218 +++
 drivers/video/fbdev/mxc/cdn_hdp/opcodes.h          |  115 ++
 .../video/fbdev/mxc/cdn_hdp/source_aif_decoder.h   |  452 +++++
 .../video/fbdev/mxc/cdn_hdp/source_aif_smpl2pckt.h |  113 ++
 drivers/video/fbdev/mxc/cdn_hdp/source_car.h       |  173 ++
 drivers/video/fbdev/mxc/cdn_hdp/source_phy.h       |  180 ++
 drivers/video/fbdev/mxc/cdn_hdp/source_pif.h       |  170 ++
 drivers/video/fbdev/mxc/cdn_hdp/source_vif.h       |   93 +
 drivers/video/fbdev/mxc/cdn_hdp/test_base_sw.c     |   95 +
 drivers/video/fbdev/mxc/cdn_hdp/util.c             |  326 ++++
 drivers/video/fbdev/mxc/cdn_hdp/util.h             |  266 +++
 drivers/video/fbdev/mxc/cdn_hdp/vic_table.c        |  460 +++++
 drivers/video/fbdev/mxc/cdn_hdp/vic_table.h        |  276 +++
 drivers/video/fbdev/mxc/imx8_hdmi.c                |  371 ++++
 50 files changed, 12302 insertions(+)
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_AFE.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_AFE.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_AVI.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_AVI.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_Audio.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_Audio.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_DPTX.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_General.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_General.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/Makefile
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/address.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/aif_pckt2smp.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/apb_cfg.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/clock_meters.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/defs.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/dptx_framer.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/dptx_stream.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/edid_parser.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/edid_parser.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/externs.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/general_handler.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/hdcp.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/hdcp2.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/hdcp_tran.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/hdmi.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/mailBox.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/mhl_hdtx_top.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/opcodes.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/source_aif_decoder.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/source_aif_smpl2pckt.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/source_car.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/source_phy.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/source_pif.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/source_vif.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/test_base_sw.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/util.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/util.h
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/vic_table.c
 create mode 100644 drivers/video/fbdev/mxc/cdn_hdp/vic_table.h
 create mode 100644 drivers/video/fbdev/mxc/imx8_hdmi.c

diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_AFE.c b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE.c
new file mode 100644
index 0000000..d42ac68
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE.c
@@ -0,0 +1,81 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_AFE.c
+ *
+ ******************************************************************************
+ */
+
+#include "address.h"
+#include "API_AFE.h"
+#include "util.h"
+
+void Afe_write(unsigned int offset, unsigned short val)
+{
+	CDN_API_STATUS sts;
+
+	sts =
+	    CDN_API_General_Write_Register_blocking(ADDR_AFE + (offset << 2),
+						    val);
+
+	if (sts != CDN_OK) {
+		printk
+		    ("CDN_API_General_Write_Register_blocking(0x%.8X, 0x%.8X) returned %d\n",
+		     offset, val, (int)sts);
+	}
+}
+
+unsigned short Afe_read(unsigned int offset)
+{
+	GENERAL_Read_Register_response resp;
+	CDN_API_STATUS sts;
+
+	sts =
+	    CDN_API_General_Read_Register_blocking(ADDR_AFE + (offset << 2),
+						   &resp);
+
+	if (sts != CDN_OK) {
+		printk
+		    ("CDN_API_General_Read_Register_blocking(0x%.8X) returned %d\n",
+		     offset, (int)sts);
+	}
+	return resp.val;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_AFE.h b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE.h
new file mode 100644
index 0000000..32034db
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_AFE.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AFE_H_
+#define API_AFE_H_
+
+typedef enum {
+	AFE_LINK_RATE_1_6 = 0x6,
+	AFE_LINK_RATE_2_7 = 0xA,
+	AFE_LINK_RATE_5_4 = 0x14,
+	AFE_LINK_RATE_8_1 = 0x1A,
+} ENUM_AFE_LINK_RATE;
+
+void Afe_write(unsigned int offset, unsigned short val);
+unsigned short Afe_read(unsigned int offset);
+void AFE_init(int num_lanes, ENUM_AFE_LINK_RATE link_rate);
+void AFE_power(int num_lanes, ENUM_AFE_LINK_RATE link_rate);
+
+extern int cdn_phapb_read(unsigned int addr, unsigned int *value);
+extern int cdn_phapb_write(unsigned int addr, unsigned int value);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.c b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.c
new file mode 100644
index 0000000..913d297
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.c
@@ -0,0 +1,1942 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_AFE_t28hpc_hdmitx.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_AFE_t28hpc_hdmitx.h"
+
+extern void Afe_write(unsigned int offset, unsigned short val);
+extern unsigned short Afe_read(unsigned int offset);
+
+#define  write16(addr, val) __write16(addr, val, __LINE__)
+static inline void __write16(uint32_t addr, uint16_t val, int line)
+{
+	Afe_write(addr, val);
+#ifdef debug
+	printk
+	    ("write16():%4d Writting value 0x%04X at address 0x%05X (0x%04X)\n",
+	     line, val, (0x20000 * 4) + (addr << 2), addr);
+#endif
+}
+
+#define  read16(addr) __read16(addr, __LINE__)
+static inline uint16_t __read16(uint32_t addr, int line)
+{
+#ifdef debug
+	printk("read16():%5d Reading from address 0x%05X (0x%04X)\n", line,
+	       (0x20000 * 4) + (addr << 2), addr);
+#endif
+	return Afe_read(addr);
+}
+
+int inside(int value, int left_sharp_corner, int right_sharp_corner)
+{
+	if (value < left_sharp_corner)
+		return 0;
+	if (value > right_sharp_corner)
+		return 0;
+	return 1;
+}
+
+int inside_float(unsigned int value, unsigned int left_sharp_corner,
+		 unsigned int right_sharp_corner)
+{
+	if (value < left_sharp_corner)
+		return 0;
+	if (value > right_sharp_corner)
+		return 0;
+	return 1;
+}
+
+void set_field_value(reg_field_t *reg_field, unsigned int value)
+{
+	unsigned char length;
+	unsigned int max_value;
+	unsigned int trunc_val;
+	length = (reg_field->msb - reg_field->lsb + 1);
+	max_value = (1 << length) - 1;
+	if (value > max_value) {
+		trunc_val = value;
+		trunc_val &= (1 << length) - 1;
+#ifdef debug
+		printk
+		    ("set_field_value() Error! Specified value (0x%0X) exceeds field capacity - it will by truncated to 0x%0X (%0d-bit field - max value: %0d dec)\n",
+		     value, trunc_val, length, max_value);
+#endif
+	} else {
+		printk("set_field_value() Setting field to 0x%0X\n", value);
+		reg_field->value = value;
+	}
+}
+
+int set_reg_value(reg_field_t reg_field)
+{
+	return reg_field.value << reg_field.lsb;
+}
+
+int phy_cfg_hdp(int num_lanes, VIC_MODES vicMode, int bpp,
+		VIC_PXL_ENCODING_FORMAT format, bool pixel_clk_from_phy)
+{
+
+	const int phy_reset_workaround = 1;
+	unsigned int vco_freq;
+	unsigned char k;
+	uint32_t reg_val;
+	uint32_t pixel_freq_khz = vic_table[vicMode][PIXEL_FREQ_KHZ];
+	uint32_t character_clock_ratio_num = 1;
+	uint32_t character_clock_ratio_den = 1;
+	uint32_t character_freq_khz;
+	const unsigned int refclk_freq_khz = 27000;
+	unsigned int ftemp, ftemp2;
+
+	clk_ratio_t clk_ratio = 0;
+	reg_field_t cmnda_pll0_hs_sym_div_sel;
+	reg_field_t cmnda_pll0_ip_div;
+	reg_field_t cmnda_pll0_fb_div_low;
+	reg_field_t cmnda_pll0_fb_div_high;
+	reg_field_t cmn_ref_clk_dig_div;
+	reg_field_t divider_scaler;
+	reg_field_t cmnda_hs_clk_0_sel;
+	reg_field_t cmnda_hs_clk_1_sel;
+	reg_field_t tx_subrate;
+	reg_field_t voltage_to_current_coarse;
+	reg_field_t voltage_to_current;
+	reg_field_t ndac_ctrl;
+	reg_field_t pmos_ctrl;
+	reg_field_t ptat_ndac_ctrl;
+	reg_field_t charge_pump_gain;
+	reg_field_t vco_ring_select;
+	reg_field_t pll_feedback_divider_total;
+	reg_field_t cmnda_pll0_pxdiv_high;
+	reg_field_t cmnda_pll0_pxdiv_low;
+	reg_field_t coarse_code;
+	reg_field_t v2i_code;
+	reg_field_t vco_cal_code;
+
+	cmnda_pll0_fb_div_high.value = 0x00A;
+	ftemp = pixel_freq_khz;
+
+	printk(" VIC %d, pixel clock %u kHz\n", vicMode, ftemp);
+
+	/* Set field position */
+	cmnda_pll0_hs_sym_div_sel.msb = 9;
+	cmnda_pll0_hs_sym_div_sel.lsb = 8;
+	cmnda_pll0_ip_div.msb = 7;
+	cmnda_pll0_ip_div.lsb = 0;
+	cmnda_pll0_fb_div_low.msb = 9;
+	cmnda_pll0_fb_div_low.lsb = 0;
+	cmnda_pll0_fb_div_high.msb = 9;
+	cmnda_pll0_fb_div_high.lsb = 0;
+	cmn_ref_clk_dig_div.msb = 13;
+	cmn_ref_clk_dig_div.lsb = 12;
+	divider_scaler.msb = 14;
+	divider_scaler.lsb = 12;
+	cmnda_hs_clk_0_sel.msb = 1;
+	cmnda_hs_clk_0_sel.lsb = 0;
+	cmnda_hs_clk_1_sel.msb = 1;
+	cmnda_hs_clk_1_sel.lsb = 0;
+	tx_subrate.msb = 2;
+	tx_subrate.lsb = 0;
+	voltage_to_current_coarse.msb = 2;
+	voltage_to_current_coarse.lsb = 0;
+	voltage_to_current.msb = 5;
+	voltage_to_current.lsb = 4;
+	ndac_ctrl.msb = 11;
+	ndac_ctrl.lsb = 8;
+	pmos_ctrl.msb = 7;
+	pmos_ctrl.lsb = 0;
+	ptat_ndac_ctrl.msb = 5;
+	ptat_ndac_ctrl.lsb = 0;
+	charge_pump_gain.msb = 8;
+	charge_pump_gain.lsb = 0;
+	vco_ring_select.msb = 12;
+	vco_ring_select.lsb = 12;
+	pll_feedback_divider_total.msb = 9;
+	pll_feedback_divider_total.lsb = 0;
+	cmnda_pll0_pxdiv_high.msb = 9;
+	cmnda_pll0_pxdiv_high.lsb = 0;
+	cmnda_pll0_pxdiv_low.msb = 9;
+	cmnda_pll0_pxdiv_low.lsb = 0;
+	coarse_code.msb = 7;
+	coarse_code.lsb = 0;
+	v2i_code.msb = 3;
+	v2i_code.lsb = 0;
+	vco_cal_code.msb = 8;
+	vco_cal_code.lsb = 0;
+
+	if (phy_reset_workaround) {
+		/* register PHY_PMA_ISOLATION_CTRL */
+		write16(0xC81F, 0xD000);	/*  enable PHY isolation mode only for CMN */
+		// register PHY_PMA_ISO_PLL_CTRL1
+		reg_val = read16(0xC812);
+		reg_val &= 0xFF00;
+		reg_val |= 0x0012;
+		write16(0xC812, reg_val);	/* set cmn_pll0_clk_datart1_div/cmn_pll0_clk_datart0_div dividers */
+		/* register PHY_ISO_CMN_CTRL */
+		write16(0xC010, 0x0000);	/* assert PHY reset from isolation register */
+		/* register PHY_PMA_ISO_CMN_CTRL */
+		write16(0xC810, 0x0000);	/* assert PMA CMN reset */
+		/* register XCVR_DIAG_BIDI_CTRL */
+		for (k = 0; k < num_lanes; k++) {
+			write16(0x40E8 | (k << 9), 0x00FF);
+		}
+	}
+	/*---------------------------------------------------------------
+	 * Describing Task phy_cfg_hdp
+	 * --------------------------------------------------------------*/
+	/* register PHY_PMA_CMN_CTRL1 */
+	reg_val = read16(0xC800);
+	reg_val &= 0xFFF7;
+	reg_val |= 0x0008;
+	write16(0xC800, reg_val);
+
+	/* register CMN_DIAG_PLL0_TEST_MODE */
+	write16(0x01C4, 0x0020);
+	/* register CMN_PSM_CLK_CTRL */
+	write16(0x0061, 0x0016);
+
+	switch (format) {
+	case YCBCR_4_2_2:
+		clk_ratio = CLK_RATIO_1_1;
+		character_clock_ratio_num = 1;
+		character_clock_ratio_den = 1;
+		break;
+	case YCBCR_4_2_0:
+		switch (bpp) {
+		case 8:
+			clk_ratio = CLK_RATIO_1_2;
+			character_clock_ratio_num = 1;
+			character_clock_ratio_den = 2;
+			break;
+		case 10:
+			clk_ratio = CLK_RATIO_5_8;
+			character_clock_ratio_num = 5;
+			character_clock_ratio_den = 8;
+			break;
+		case 12:
+			clk_ratio = CLK_RATIO_3_4;
+			character_clock_ratio_num = 3;
+			character_clock_ratio_den = 4;
+			break;
+		case 16:
+			clk_ratio = CLK_RATIO_1_1;
+			character_clock_ratio_num = 1;
+			character_clock_ratio_den = 1;
+			break;
+		default:
+			printk("Invalid ColorDepth\n");
+		}
+		break;
+
+	default:
+		switch (bpp) {
+			/* Assume RGB */
+		case 10:
+			clk_ratio = CLK_RATIO_5_4;
+			character_clock_ratio_num = 5;
+			character_clock_ratio_den = 4;
+			break;
+		case 12:
+			clk_ratio = CLK_RATIO_3_2;
+			character_clock_ratio_num = 3;
+			character_clock_ratio_den = 2;
+			break;
+		case 16:
+			clk_ratio = CLK_RATIO_2_1;
+			character_clock_ratio_num = 2;
+			character_clock_ratio_den = 1;
+			break;
+		default:
+			clk_ratio = CLK_RATIO_1_1;
+			character_clock_ratio_num = 1;
+			character_clock_ratio_den = 1;
+		}
+	}
+
+	character_freq_khz = pixel_freq_khz *
+	    character_clock_ratio_num / character_clock_ratio_den;
+	ftemp = pixel_freq_khz;
+	ftemp2 = character_freq_khz;
+	printk
+	    ("Pixel clock frequency: %u kHz, character clock frequency: %u, color depth is %0d-bit.\n",
+	     ftemp, ftemp2, bpp);
+	if (pixel_clk_from_phy == 0) {
+
+		/* --------------------------------------------------------------
+		 * Describing Task phy_cfg_hdmi_pll0_0pt5736 (Clock is input)
+		 * --------------------------------------------------------------*/
+
+		/* register CMN_PLL0_VCOCAL_INIT_TMR */
+		write16(0x0084, 0x0064);
+		/* register CMN_PLL0_VCOCAL_ITER_TMR */
+		write16(0x0085, 0x000A);
+		/* register PHY_HDP_CLK_CTL */
+		reg_val = read16(0xC009);
+		reg_val &= 0x00FF;
+		reg_val |= 0x1200;
+		write16(0xC009, reg_val);
+
+		switch (clk_ratio) {
+		case CLK_RATIO_1_1:
+			if (inside_float(pixel_freq_khz, 340000, 600000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x3C);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x24A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x06);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						600);
+			} else if (inside_float(pixel_freq_khz, 170000, 340000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x22);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x146);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x07);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						340);
+			} else if (inside_float(pixel_freq_khz, 85000, 170000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				set_field_value(&cmnda_pll0_ip_div, 0x11);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x146);
+				set_field_value(&cmn_ref_clk_dig_div, 0x00);
+				set_field_value(&divider_scaler, 0x07);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						340);
+			} else if (inside_float(pixel_freq_khz, 42500, 85000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				set_field_value(&cmnda_pll0_ip_div, 0x08);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x132);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						320);
+			} else if (inside_float(pixel_freq_khz, 25000, 42500)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				set_field_value(&cmnda_pll0_ip_div, 0x05);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x182);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						400);
+			} else {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			}
+			break;
+
+		case CLK_RATIO_5_4:
+			if (inside_float(pixel_freq_khz, 272000, 480000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x30);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x24A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x05);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						600);
+			} else if (inside_float(pixel_freq_khz, 136000, 272000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x1A);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x137);
+				set_field_value(&cmn_ref_clk_dig_div, 0x02);
+				set_field_value(&divider_scaler, 0x04);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						325);
+			} else if (inside_float(pixel_freq_khz, 68000, 136000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				set_field_value(&cmnda_pll0_ip_div, 0x0D);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x137);
+				set_field_value(&cmn_ref_clk_dig_div, 0x02);
+				set_field_value(&divider_scaler, 0x02);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						325);
+			} else if (inside_float(pixel_freq_khz, 34000, 68000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				set_field_value(&cmnda_pll0_ip_div, 0x06);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x11E);
+				set_field_value(&cmn_ref_clk_dig_div, 0x02);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						300);
+			} else if (inside_float(pixel_freq_khz, 25000, 34000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x182);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						400);
+			} else {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			}
+			break;
+		case CLK_RATIO_3_2:
+			if (inside_float(pixel_freq_khz, 226000, 400000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x28);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x24A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x04);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						600);
+			} else if (inside_float(pixel_freq_khz, 113000, 226000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x16);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x13C);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x05);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						330);
+			} else if (inside_float(pixel_freq_khz, 56000, 113000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				set_field_value(&cmnda_pll0_ip_div, 0x0B);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x13C);
+				set_field_value(&cmn_ref_clk_dig_div, 0x00);
+				set_field_value(&divider_scaler, 0x05);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						330);
+			} else if (inside_float(pixel_freq_khz, 28000, 56000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				set_field_value(&cmnda_pll0_ip_div, 0x06);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x15A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x02);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						360);
+			} else if (inside_float(pixel_freq_khz, 25000, 28000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x15A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						360);
+			} else {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			}
+			break;
+		case CLK_RATIO_2_1:
+			if (inside_float(pixel_freq_khz, 170000, 300000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x22);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x29A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x06);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						680);
+			} else if (inside_float(pixel_freq_khz, 85000, 170000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x11);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x146);
+				set_field_value(&cmn_ref_clk_dig_div, 0x00);
+				set_field_value(&divider_scaler, 0x07);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						340);
+			} else if (inside_float(pixel_freq_khz, 42500, 85000)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				set_field_value(&cmnda_pll0_ip_div, 0x08);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x132);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						320);
+			} else if (inside_float(pixel_freq_khz, 25000, 42500)) {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				set_field_value(&cmnda_pll0_ip_div, 0x05);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x182);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&pll_feedback_divider_total,
+						400);
+			} else {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			}
+			break;
+		case CLK_RATIO_1_2:
+			if (!(inside_float(pixel_freq_khz, 594000, 594000))) {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			} else {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				set_field_value(&cmnda_pll0_ip_div, 0x3C);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x24A);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x06);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						600);
+			}
+			break;
+		case CLK_RATIO_5_8:
+			if (!(inside_float(pixel_freq_khz, 594000, 594000))) {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			} else {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x3C);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x169);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x06);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						375);
+			}
+			break;
+		case CLK_RATIO_3_4:
+			if (!(inside_float(pixel_freq_khz, 594000, 594000))) {
+				ftemp = pixel_freq_khz;
+				printk
+				    ("Pixel clock frequency (%u) is outside of the supported range\n",
+				     ftemp);
+			} else {
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				set_field_value(&cmnda_pll0_ip_div, 0x3C);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x1B4);
+				set_field_value(&cmn_ref_clk_dig_div, 0x03);
+				set_field_value(&divider_scaler, 0x06);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						450);
+			}
+			break;
+		}
+		vco_freq =
+		    pixel_freq_khz * pll_feedback_divider_total.value /
+		    cmnda_pll0_ip_div.value;
+		ftemp = vco_freq;
+		printk("VCO frequency is %u kHz\n", ftemp);
+
+		if (inside_float(vco_freq, 1700000, 2000000)) {
+			set_field_value(&voltage_to_current_coarse, 0x04);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x09);
+			set_field_value(&ptat_ndac_ctrl, 0x09);
+			switch (pll_feedback_divider_total.value) {
+			case 300:
+				set_field_value(&charge_pump_gain, 0x82);
+				break;
+			case 320:
+				set_field_value(&charge_pump_gain, 0x83);
+				break;
+			case 325:
+				set_field_value(&charge_pump_gain, 0x83);
+				break;
+			case 330:
+				set_field_value(&charge_pump_gain, 0x84);
+				break;
+			case 340:
+				set_field_value(&charge_pump_gain, 0x84);
+				break;
+			case 360:
+				set_field_value(&charge_pump_gain, 0x86);
+				break;
+			case 400:
+				set_field_value(&charge_pump_gain, 0xA2);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 2000000, 2400000)) {
+			set_field_value(&voltage_to_current_coarse, 0x04);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x09);
+			set_field_value(&ptat_ndac_ctrl, 0x09);
+			switch (pll_feedback_divider_total.value) {
+			case 300:
+				set_field_value(&charge_pump_gain, 0x47);
+				break;
+			case 320:
+				set_field_value(&charge_pump_gain, 0x4B);
+				break;
+			case 325:
+				set_field_value(&charge_pump_gain, 0x4C);
+				break;
+			case 330:
+				set_field_value(&charge_pump_gain, 0x80);
+				break;
+			case 340:
+				set_field_value(&charge_pump_gain, 0x81);
+				break;
+			case 360:
+				set_field_value(&charge_pump_gain, 0x82);
+				break;
+			case 400:
+				set_field_value(&charge_pump_gain, 0x84);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 2400000, 2800000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			switch (pll_feedback_divider_total.value) {
+			case 300:
+				set_field_value(&charge_pump_gain, 0x43);
+				break;
+			case 320:
+				set_field_value(&charge_pump_gain, 0x45);
+				break;
+			case 325:
+				set_field_value(&charge_pump_gain, 0x45);
+				break;
+			case 330:
+				set_field_value(&charge_pump_gain, 0x45);
+				break;
+			case 340:
+				set_field_value(&charge_pump_gain, 0x86);
+				break;
+			case 360:
+				set_field_value(&charge_pump_gain, 0x4A);
+				break;
+			case 400:
+				set_field_value(&charge_pump_gain, 0x81);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 2800000, 3400000)) {
+			set_field_value(&voltage_to_current_coarse, 0x06);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			switch (pll_feedback_divider_total.value) {
+			case 300:
+				set_field_value(&charge_pump_gain, 0x3D);
+				break;
+			case 320:
+				set_field_value(&charge_pump_gain, 0x41);
+				break;
+			case 325:
+				set_field_value(&charge_pump_gain, 0x41);
+				break;
+			case 330:
+				set_field_value(&charge_pump_gain, 0x41);
+				break;
+			case 340:
+				set_field_value(&charge_pump_gain, 0x42);
+				break;
+			case 360:
+				set_field_value(&charge_pump_gain, 0x43);
+				break;
+			case 400:
+				set_field_value(&charge_pump_gain, 0x46);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 3400000, 3900000)) {
+			set_field_value(&voltage_to_current_coarse, 0x04);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x07);
+			set_field_value(&ptat_ndac_ctrl, 0x0F);
+			switch (pll_feedback_divider_total.value) {
+			case 375:
+				set_field_value(&charge_pump_gain, 0x41);
+				break;
+			case 600:
+				set_field_value(&charge_pump_gain, 0x82);
+				break;
+			case 680:
+				set_field_value(&charge_pump_gain, 0x85);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 3900000, 4500000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x07);
+			set_field_value(&ptat_ndac_ctrl, 0x0F);
+			switch (pll_feedback_divider_total.value) {
+			case 450:
+				set_field_value(&charge_pump_gain, 0x41);
+				break;
+			case 600:
+				set_field_value(&charge_pump_gain, 0x4B);
+				break;
+			case 680:
+				set_field_value(&charge_pump_gain, 0x82);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 4500000, 5200000)) {
+			set_field_value(&voltage_to_current_coarse, 0x06);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			switch (pll_feedback_divider_total.value) {
+			case 600:
+				set_field_value(&charge_pump_gain, 0x45);
+				break;
+			case 680:
+				set_field_value(&charge_pump_gain, 0x4A);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else if (inside_float(vco_freq, 5200000, 6000000)) {
+			set_field_value(&voltage_to_current_coarse, 0x07);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			switch (pll_feedback_divider_total.value) {
+			case 600:
+				set_field_value(&charge_pump_gain, 0x42);
+				break;
+			case 680:
+				set_field_value(&charge_pump_gain, 0x45);
+				break;
+			default:
+				printk
+				    ("pll_feedback_divider_total (%0d) is outside of the supported range for vco_freq equal %u\n",
+				     pll_feedback_divider_total.value, ftemp);
+			}
+		} else
+			printk
+			    ("VCO frequency %u kHz is outside of the supported range\n",
+			     ftemp);
+
+		/* register CMN_DIAG_PLL0_INCLK_CTRL */
+		reg_val = set_reg_value(cmnda_pll0_hs_sym_div_sel);
+		reg_val |= set_reg_value(cmnda_pll0_ip_div);
+		write16(0x01CA, reg_val);
+		/* register CMN_DIAG_PLL0_FBL_OVRD */
+		reg_val = set_reg_value(cmnda_pll0_fb_div_low);
+		reg_val |= (1 << 15);
+		write16(0x01C1, reg_val);
+		/* register PHY_PMA_CMN_CTRL1 */
+		reg_val = read16(0xC800);
+		reg_val &= 0xCFFF;
+		reg_val |= set_reg_value(cmn_ref_clk_dig_div);
+		write16(0xC800, reg_val);
+		/* register CMN_CDIAG_REFCLK_CTRL */
+		reg_val = read16(0x0062);
+		reg_val &= 0x8FFF;
+		reg_val |= set_reg_value(divider_scaler);
+		reg_val |= 0x00C0;
+		write16(0x0062, reg_val);
+		/* register CMN_DIAG_HSCLK_SEL */
+		reg_val = read16(0x01E0);
+		reg_val &= 0xFF00;
+		reg_val |= (cmnda_hs_clk_0_sel.value >> 1) << 0;
+		reg_val |= (cmnda_hs_clk_1_sel.value >> 1) << 4;
+		write16(0x01E0, reg_val);
+
+		/* register XCVR_DIAG_HSCLK_SEL */
+		for (k = 0; k < num_lanes; k++) {
+			reg_val = read16(0x40E1 | (k << 9));
+			reg_val &= 0xCFFF;
+			reg_val |= (cmnda_hs_clk_0_sel.value >> 1) << 12;
+			write16(0x40E1 | (k << 9), reg_val);
+		}
+
+		/* register TX_DIAG_TX_CTRL */
+		for (k = 0; k < num_lanes; k++) {
+			reg_val = read16(0x41E0 | (k << 9));
+			reg_val &= 0xFF3F;
+			reg_val |= (tx_subrate.value >> 1) << 6;
+			write16(0x41E0 | (k << 9), reg_val);
+		}
+
+		/* register CMN_PLLSM0_USER_DEF_CTRL */
+		reg_val = set_reg_value(vco_ring_select);
+		write16(0x002F, reg_val);
+		/* register CMN_DIAG_PLL0_OVRD */
+		write16(0x01C2, 0x0000);
+		/* register CMN_DIAG_PLL0_FBH_OVRD */
+		reg_val = set_reg_value(cmnda_pll0_fb_div_high);
+		reg_val |= (1 << 15);
+		write16(0x01C0, reg_val);
+		/* register CMN_DIAG_PLL0_V2I_TUNE */
+		reg_val = set_reg_value(voltage_to_current_coarse);
+		reg_val |= set_reg_value(voltage_to_current);
+		write16(0x01C5, reg_val);
+		/* register CMN_DIAG_PLL0_PTATIS_TUNE1 */
+		reg_val = set_reg_value(pmos_ctrl);
+		reg_val |= set_reg_value(ndac_ctrl);
+		write16(0x01C8, reg_val);
+		/* register CMN_DIAG_PLL0_PTATIS_TUNE2 */
+		reg_val = set_reg_value(ptat_ndac_ctrl);
+		write16(0x01C9, reg_val);
+		/* register CMN_DIAG_PLL0_CP_TUNE */
+		reg_val = set_reg_value(charge_pump_gain);
+		write16(0x01C6, reg_val);
+		/* register CMN_DIAG_PLL0_LF_PROG */
+		write16(0x01C7, 0x0008);
+
+		/* register XCVR_DIAG_PLLDRC_CTRL */
+		for (k = 0; k < num_lanes; k++) {
+			reg_val = read16(0x40E0 | (k << 9));
+			reg_val &= 0xBFFF;
+			write16(0x40E0 | (k << 9), reg_val);
+		}
+
+	} else {
+		/* Describing task phy_cfg_hdmi_pll0_0pt099_ver2 (Clock is OUTPUT) */
+		if (inside_float(pixel_freq_khz, 27000, 27000)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						240);
+				set_field_value(&cmnda_pll0_fb_div_low, 0xBC);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x30);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x26);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x26);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						300);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x0EC);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x03C);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x030);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x030);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						360);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x11C);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x048);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x03A);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x03A);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						240);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x0BC);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x030);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x026);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x026);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			default:
+				break;
+			}
+		} else if (inside_float(pixel_freq_khz, 54000, 54000)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						480);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x17C);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x060);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x026);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x026);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						400);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x13C);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x050);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x017);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x017);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						480);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x17C);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x060);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x01C);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x01C);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						240);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x0bc);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x030);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x012);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x012);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			default:
+				break;
+			}
+		} else if (inside_float(pixel_freq_khz, 74250, 74250)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x026);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x026);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x03);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						550);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x1b4);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x06e);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x017);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x017);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x04);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x01c);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x01c);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						330);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x104);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x042);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x012);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x012);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			default:
+				break;
+			}
+		} else if (inside_float(pixel_freq_khz, 99000, 99000)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						440);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x15c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x058);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x012);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x012);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						275);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x0d8);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x037);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x00b);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x00a);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						330);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x104);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x042);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x00d);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x00d);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						440);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x15c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x058);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x012);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x012);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			default:
+				break;
+			}
+		} else if (inside_float(pixel_freq_khz, 148500, 148500)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x012);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x012);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x02);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						550);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x1b4);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x06e);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x00b);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x00a);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						495);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x188);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x063);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x00d);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x00d);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x012);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x012);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x02);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x02);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			default:
+				break;
+			}
+		} else if (inside_float(pixel_freq_khz, 198000, 198000)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						220);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x0ac);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x02c);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x003);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x003);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			case CLK_RATIO_5_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						550);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x1b4);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x06e);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x00b);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x00a);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						330);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x104);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x042);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x006);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x005);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						440);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x15c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x058);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x008);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x008);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			default:
+				break;
+			}
+		} else if (inside_float(pixel_freq_khz, 297000, 297000)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						330);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x104);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x042);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x003);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x003);
+				set_field_value(&vco_ring_select, 0x00);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			case CLK_RATIO_3_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						495);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x188);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x063);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x006);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x005);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			case CLK_RATIO_2_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x008);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x008);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			default:
+				ftemp = pixel_freq_khz;
+				printk
+				    ("This pixel clock frequency (%u kHz) is not supported with this (%0d-bit) color depth.\n",
+				     ftemp, bpp);
+			}
+		} else if (inside_float(pixel_freq_khz, 594000, 594000)) {
+			switch (clk_ratio) {
+			case CLK_RATIO_1_1:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x003);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x003);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			case CLK_RATIO_1_2:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						660);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x20c);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x084);
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x003);
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x003);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x02);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x01);
+				break;
+			case CLK_RATIO_5_8:
+				set_field_value(&cmnda_pll0_ip_div, 0x04);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						550);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x1b4);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x06e);
+				/* does not matter - pixel clock delivered to controller from SoC */
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x003);
+				/* does not matter - pixel clock delivered to controller from SoC */
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x003);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			case CLK_RATIO_3_4:
+				set_field_value(&cmnda_pll0_ip_div, 0x03);
+				set_field_value(&cmn_ref_clk_dig_div, 0x01);
+				set_field_value(&divider_scaler, 0x01);
+				set_field_value(&pll_feedback_divider_total,
+						495);
+				set_field_value(&cmnda_pll0_fb_div_low, 0x188);
+				set_field_value(&cmnda_pll0_fb_div_high, 0x063);
+				/* does not matter - pixel clock delivered to controller from SoC */
+				set_field_value(&cmnda_pll0_pxdiv_low, 0x003);
+				/* does not matter - pixel clock delivered to controller from SoC */
+				set_field_value(&cmnda_pll0_pxdiv_high, 0x003);
+				set_field_value(&vco_ring_select, 0x01);
+				set_field_value(&cmnda_hs_clk_0_sel, 0x01);
+				set_field_value(&cmnda_hs_clk_1_sel, 0x01);
+				set_field_value(&tx_subrate, 0x01);
+				set_field_value(&cmnda_pll0_hs_sym_div_sel,
+						0x00);
+				break;
+			default:
+				printk
+				    ("This pixel clock frequency (%d KHz) is not supported with this (%0d-bit) color depth.\n",
+				     pixel_freq_khz, bpp);
+			}
+		} else {
+			ftemp = pixel_freq_khz;
+			printk
+			    ("This pixel clock frequency (%u kHz) is not supported.\n",
+			     ftemp);
+		}
+
+		vco_freq =
+		    refclk_freq_khz * pll_feedback_divider_total.value /
+		    cmnda_pll0_ip_div.value;
+		ftemp = vco_freq;
+		printk("VCO frequency is %u kHz\n", ftemp);
+
+		if (inside_float(vco_freq, 1980000, 1980000)) {
+			set_field_value(&voltage_to_current_coarse, 0x04);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x09);
+			set_field_value(&ptat_ndac_ctrl, 0x09);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 160);
+			set_field_value(&v2i_code, 5);
+			set_field_value(&vco_cal_code, 183);
+		} else if (inside_float(vco_freq, 2160000, 2160000)) {
+			set_field_value(&voltage_to_current_coarse, 0x04);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x09);
+			set_field_value(&ptat_ndac_ctrl, 0x09);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 166);
+			set_field_value(&v2i_code, 6);
+			set_field_value(&vco_cal_code, 208);
+		} else if (inside_float(vco_freq, 2475000, 2475000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 167);
+			set_field_value(&v2i_code, 6);
+			set_field_value(&vco_cal_code, 209);
+		} else if (inside_float(vco_freq, 2700000, 2700000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			switch (pll_feedback_divider_total.value) {
+			case 300:
+				set_field_value(&charge_pump_gain, 0x042);
+				break;
+			case 400:
+				set_field_value(&charge_pump_gain, 0x04c);
+				break;
+			}
+			set_field_value(&coarse_code, 188);
+			set_field_value(&v2i_code, 6);
+			set_field_value(&vco_cal_code, 225);
+		} else if (inside_float(vco_freq, 2970000, 2970000)) {
+			set_field_value(&voltage_to_current_coarse, 0x06);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 183);
+			set_field_value(&v2i_code, 6);
+			set_field_value(&vco_cal_code, 225);
+		} else if (inside_float(vco_freq, 3240000, 3240000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			switch (pll_feedback_divider_total.value) {
+			case 360:
+				set_field_value(&charge_pump_gain, 0x042);
+				break;
+			case 480:
+				set_field_value(&charge_pump_gain, 0x04c);
+				break;
+			}
+			set_field_value(&coarse_code, 203);
+			set_field_value(&v2i_code, 7);
+			set_field_value(&vco_cal_code, 256);
+		} else if (inside_float(vco_freq, 3712500, 3712500)) {
+			set_field_value(&voltage_to_current_coarse, 0x04);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x07);
+			set_field_value(&ptat_ndac_ctrl, 0x0F);
+			set_field_value(&charge_pump_gain, 0x04c);
+			set_field_value(&coarse_code, 212);
+			set_field_value(&v2i_code, 7);
+			set_field_value(&vco_cal_code, 257);
+		} else if (inside_float(vco_freq, 3960000, 3960000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x07);
+			set_field_value(&ptat_ndac_ctrl, 0x0F);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 184);
+			set_field_value(&v2i_code, 6);
+			set_field_value(&vco_cal_code, 226);
+		} else if (inside_float(vco_freq, 4320000, 4320000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x07);
+			set_field_value(&ptat_ndac_ctrl, 0x0F);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 205);
+			set_field_value(&v2i_code, 7);
+			set_field_value(&vco_cal_code, 258);
+		} else if (inside_float(vco_freq, 4455000, 4455000)) {
+			set_field_value(&voltage_to_current_coarse, 0x05);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x00);
+			set_field_value(&pmos_ctrl, 0x07);
+			set_field_value(&ptat_ndac_ctrl, 0x0F);
+			switch (pll_feedback_divider_total.value) {
+			case 495:
+				set_field_value(&charge_pump_gain, 0x042);
+				break;
+			case 660:
+				set_field_value(&charge_pump_gain, 0x04c);
+				break;
+			}
+			set_field_value(&coarse_code, 219);
+			set_field_value(&v2i_code, 7);
+			set_field_value(&vco_cal_code, 272);
+		} else if (inside_float(vco_freq, 4950000, 4950000)) {
+			set_field_value(&voltage_to_current_coarse, 0x06);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 213);
+			set_field_value(&v2i_code, 7);
+			set_field_value(&vco_cal_code, 258);
+		} else if (inside_float(vco_freq, 5940000, 5940000)) {
+			set_field_value(&voltage_to_current_coarse, 0x07);
+			set_field_value(&voltage_to_current, 0x03);
+			set_field_value(&ndac_ctrl, 0x01);
+			set_field_value(&pmos_ctrl, 0x00);
+			set_field_value(&ptat_ndac_ctrl, 0x07);
+			set_field_value(&charge_pump_gain, 0x042);
+			set_field_value(&coarse_code, 244);
+			set_field_value(&v2i_code, 8);
+			set_field_value(&vco_cal_code, 292);
+		} else {
+			ftemp = vco_freq;
+			printk("Current vco_freq (%u kHz) is not supported.\n",
+			       ftemp);
+		}
+
+		/* register CMN_PLL0_VCOCAL_INIT_TMR */
+		write16(0x0084, 0x0064);
+		/* register CMN_PLL0_VCOCAL_ITER_TMR */
+		write16(0x0085, 0x000A);
+		/* register PHY_HDP_CLK_CTL */
+		reg_val = read16(0xC009);
+		reg_val &= 0x00FF;
+		reg_val |= 0x2 << 8;
+		reg_val |= 0x1 << 12;
+		write16(0xC009, reg_val);
+		/* register CMN_DIAG_PLL0_INCLK_CTRL */
+		reg_val = set_reg_value(cmnda_pll0_ip_div);
+		reg_val |= set_reg_value(cmnda_pll0_hs_sym_div_sel);
+		write16(0x01CA, reg_val);
+		/* register CMN_DIAG_PLL0_FBH_OVRD */
+		reg_val = set_reg_value(cmnda_pll0_fb_div_high);
+		reg_val |= (1 << 15);
+		write16(0x01C0, reg_val);
+		/* register CMN_DIAG_PLL0_FBL_OVRD */
+		reg_val = set_reg_value(cmnda_pll0_fb_div_low);
+		reg_val |= (1 << 15);
+		write16(0x01C1, reg_val);
+		/* register CMN_DIAG_PLL0_PXL_DIVL */
+		reg_val = set_reg_value(cmnda_pll0_pxdiv_low);
+		write16(0x01CC, reg_val);
+		/* register CMN_DIAG_PLL0_PXL_DIVH */
+		reg_val = set_reg_value(cmnda_pll0_pxdiv_high);
+		reg_val |= (1 << 15);
+		write16(0x01CB, reg_val);
+
+		/* register TX_DIAG_TX_CTRL */
+		for (k = 0; k < num_lanes; k++) {
+			reg_val = read16(0x41E0 | (k << 9));
+			reg_val &= 0xFF3F;
+			reg_val |= (tx_subrate.value >> 1) << 6;
+			write16(0x41E0 | (k << 9), reg_val);
+		}
+
+		/* register PHY_PMA_CMN_CTRL1 */
+		reg_val = read16(0xC800);
+		reg_val &= 0xCFFF;
+		reg_val |= set_reg_value(cmn_ref_clk_dig_div);
+		write16(0xC800, reg_val);
+		/* register CMN_CDIAG_REFCLK_CTRL */
+		reg_val = read16(0x0062);
+		reg_val &= 0x8FFF;
+		reg_val |= set_reg_value(divider_scaler);
+		reg_val |= 0x00C0;
+		write16(0x0062, reg_val);
+		/* register CMN_DIAG_HSCLK_SEL */
+		reg_val = read16(0x01E0);
+		reg_val &= 0xFF00;
+		reg_val |= (cmnda_hs_clk_0_sel.value >> 1) << 0;
+		reg_val |= (cmnda_hs_clk_1_sel.value >> 1) << 4;
+		write16(0x01E0, reg_val);
+		/* register CMN_PLLSM0_USER_DEF_CTRL */
+		reg_val = set_reg_value(vco_ring_select);
+		write16(0x002F, reg_val);
+
+		/* register XCVR_DIAG_HSCLK_SEL */
+		for (k = 0; k < num_lanes; k++) {
+			reg_val = read16(0x40E1 | (k << 9));
+			reg_val &= 0xCFFF;
+			reg_val |= (cmnda_hs_clk_0_sel.value >> 1) << 12;
+			write16(0x40E1 | (k << 9), reg_val);
+		}
+
+		/* register CMN_DIAG_PLL0_OVRD */
+		write16(0x01C2, 0x0000);
+		/* register CMN_DIAG_PLL0_V2I_TUNE */
+		reg_val = set_reg_value(voltage_to_current_coarse);
+		reg_val |= set_reg_value(voltage_to_current);
+		write16(0x01C5, reg_val);
+		/* register CMN_DIAG_PLL0_PTATIS_TUNE1 */
+		reg_val = set_reg_value(pmos_ctrl);
+		reg_val |= set_reg_value(ndac_ctrl);
+		write16(0x01C8, reg_val);
+		/* register CMN_DIAG_PLL0_PTATIS_TUNE2 */
+		reg_val = set_reg_value(ptat_ndac_ctrl);
+		write16(0x01C9, reg_val);
+		/* register CMN_PLL0_VCOCAL_START */
+		reg_val = read16(0x0081);
+		reg_val &= 0xFE00;
+		reg_val |= set_reg_value(vco_cal_code);
+		write16(0x0081, reg_val);
+		/* register CMN_DIAG_PLL0_CP_TUNE */
+		reg_val = set_reg_value(charge_pump_gain);
+		write16(0x01C6, reg_val);
+		/* register CMN_DIAG_PLL0_LF_PROG */
+		write16(0x01C7, 0x0008);
+
+		/* register XCVR_DIAG_PLLDRC_CTRL */
+		for (k = 0; k < num_lanes; k++) {
+			reg_val = read16(0x40E0 | (k << 9));
+			reg_val &= 0xBFFF;
+			write16(0x40E0 | (k << 9), reg_val);
+		}
+	}
+
+	/* Back to task phy_cfg_hdp */
+
+	/* register PHY_PMA_CMN_CTRL1 */
+	reg_val = read16(0xC800);
+	reg_val &= 0xFF8F;
+	/* for differential clock on the refclk_p and refclk_m
+	 * off chip pins: PHY_PMA_CMN_CTRL1[6:4]=3'b000 */
+	reg_val |= 0x0000;
+	write16(0xC800, reg_val);
+
+	/* register CMN_DIAG_ACYA */
+	write16(0x01FF, 0x0100);
+
+	if (phy_reset_workaround) {
+		/* register PHY_ISO_CMN_CTRL */
+		write16(0xC010, 0x0001);	// Deassert PHY reset
+		/* register PHY_PMA_ISO_CMN_CTRL */
+		write16(0xC810, 0x0003);
+		for (k = 0; k < num_lanes; k++) {
+			/* register XCVR_PSM_RCTRL */
+			write16(0x4001 | (k << 9), 0xFEFC);
+		}
+		/* register PHY_PMA_ISO_CMN_CTRL
+		 * Assert cmn_macro_pwr_en*/
+		write16(0xC810, 0x0013);
+
+		/* PHY_PMA_ISO_CMN_CTRL
+		 * wait for cmn_macro_pwr_en_ack*/
+		while (!(read16(0xC810) & (1 << 5)))
+			;
+
+		/* PHY_PMA_CMN_CTRL1 wait for cmn_ready */
+		while (!(read16(0xC800) & (1 << 0)))
+			;
+	} else {
+		for (k = 0; k < num_lanes; k++) {
+			/* register XCVR_PSM_RCTRL */
+			write16(0x4001 | (k << 9), 0xBEFC);
+		}
+	}
+	for (k = 0; k < num_lanes; k++) {
+		/* register TX_PSC_A0 */
+		write16(0x4100 | (k << 9), 0x6791);
+		/* register TX_PSC_A1 */
+		write16(0x4101 | (k << 9), 0x6790);
+		/* register TX_PSC_A2 */
+		write16(0x4102 | (k << 9), 0x0090);
+		/* register TX_PSC_A3 */
+		write16(0x4103 | (k << 9), 0x0090);
+		/* register RX_PSC_CAL */
+		reg_val = read16(0x8006 | (k << 9));
+		reg_val &= 0xFFBB;
+		write16(0x8006 | (k << 9), reg_val);
+		reg_val = read16(0x8000 | (k << 9));
+		reg_val &= 0xFFBB;
+		write16(0x8000 | (k << 9), reg_val);
+	}
+
+	/* End of task phy_cfg_hdp */
+
+#ifdef SIMULATED_AFE
+	if (pixel_clk_from_phy == 0) {
+		phy_sim_speedup_hdp(4);
+	}
+#endif
+
+	/* register PHY_HDP_MODE_CTL */
+	write16(0xC008, 0x0004);
+	return character_freq_khz;
+
+}
+
+void phy_sim_speedup_hdp(int num_lanes)
+{
+	phy_sim_speedup_cmn();
+	phy_sim_speedup_lane_tx(num_lanes);
+}
+
+void phy_sim_speedup_cmn(void)
+{
+	/* register CMN_PLLSM0_PLLEN_TMR */
+	write16(0x0029, 0x0002);
+	/* register CMN_PLLSM0_PLLPRE_TMR */
+	write16(0x002A, 0x0001);
+	/* register CMN_PLLSM0_PLLVREF_TMR */
+	write16(0x002B, 0x0001);
+	/* register CMN_PLLSM0_PLLLOCK_TMR */
+	write16(0x002C, 0x0008);
+	/* register CMN_PLL0_VCOCAL_OVRD */
+	write16(0x0083, 0x8012);
+	/* register CMN_PLL0_LOCK_REFCNT_START */
+	write16(0x0090, 0x8010);
+	/* register CMN_PLL0_LOCK_PLLCNT_START */
+	write16(0x0092, 0x8010);
+	/* register CMN_ICAL_OVRD */
+	write16(0x00C1, 0x8003);
+	/* register CMN_TXPUCAL_OVRD */
+	write16(0x00E1, 0x8022);
+	/* register CMN_TXPDCAL_OVRD */
+	write16(0x00F1, 0x8022);
+	/* register CMN_RXCAL_OVRD */
+	write16(0x00D1, 0x8003);
+}
+
+void phy_sim_speedup_lane_tx(int num_lanes)
+{
+	unsigned int i;
+	for (i = 0; i < num_lanes; i++) {
+		/* register XCVR_PSM_CAL_TMR */
+		write16(0x4002 | (i << 9), 0x0020);
+		/* register XCVR_PSM_A0IN_TMR */
+		write16(0x4003 | (i << 9), 0x0020);
+		/* register XCVR_DIAG_RX_LANE_CAL_RST_TMR */
+		write16(0x40E2 | (i << 9), 0x0010);
+		/* register XCVR_DIAG_LANE_FCM_EN_MGN_TMR */
+		write16(0x40E6 | (i << 9), 0x0010);
+		/* register TX_DIAG_BGREF_PREDRV_DELAY */
+		write16(0x41E7 | (i << 9), 0x0001);
+	}
+}
+
+int hdmi_tx_kiran_power_configuration_seq(int num_lanes)
+{
+	unsigned char k;
+
+	/* Configure the power state.
+	 * register TX_DIAG_ACYA */
+	for (k = 0; k < num_lanes; k++) {
+		/* register XCVR_PSM_CAL_TMR */
+		write16(0x41FF | (k << 9), 0x0001);
+	}
+
+	/* register PHY_DP_MODE_CTL */
+	while (!(read16(0xC008) & (1 << 6)))
+		;
+
+	/* PHY_DP_MODE_CTL */
+	write16(0xC008, (((0x0F << num_lanes) & 0x0F) << 12) | 0x0101);
+
+	/* PHY_DP_MODE_CTL */
+	while (!(read16(0xC008) & (1 << 4)))
+		;
+
+	return 0;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.h b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.h
new file mode 100644
index 0000000..610324a
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_AFE_t28hpc_hdmitx.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_AFE_t28hpc_hdmitx.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AFE_T28HPC_HDMITX_H_
+# define API_AFE_T28HPC_HDMITX_H_
+/**
+ * \addtogroup AFE
+ * \{
+ */
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/io.h>
+
+# include "vic_table.h"
+
+typedef enum {
+	CLK_RATIO_1_1,
+	CLK_RATIO_5_4,
+	CLK_RATIO_3_2,
+	CLK_RATIO_2_1,
+	CLK_RATIO_1_2,
+	CLK_RATIO_5_8,
+	CLK_RATIO_3_4
+} clk_ratio_t;
+
+typedef struct {
+	unsigned int value;
+	unsigned char lsb;
+	unsigned char msb;
+} reg_field_t;
+
+int phy_cfg_hdp(int num_lanes, VIC_MODES vicMode, int bpp,
+		VIC_PXL_ENCODING_FORMAT format, bool pixel_clk_from_phy);
+void phy_sim_speedup_hdp(int num_lanes);
+void phy_sim_speedup_cmn(void);
+void phy_sim_speedup_lane_tx(int num_lanes);
+int hdmi_tx_kiran_power_configuration_seq(int num_lanes);
+int inside(int value, int left_sharp_corner, int right_sharp_corner);
+int inside_float(unsigned int value, unsigned int left_sharp_corner,
+		 unsigned int right_sharp_corner);
+void set_field_value(reg_field_t *reg_field, unsigned int value);
+int set_reg_value(reg_field_t reg_field);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_AVI.c b/drivers/video/fbdev/mxc/cdn_hdp/API_AVI.c
new file mode 100644
index 0000000..74ce7c3
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_AVI.c
@@ -0,0 +1,186 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_AVI.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_AVI.h"
+#include "API_Infoframe.h"
+
+CDN_API_STATUS CDN_API_Set_AVI(VIC_MODES vicMode,
+			       VIC_PXL_ENCODING_FORMAT colorMode,
+			       BT_TYPE ITUver)
+{
+	unsigned int active_slot = vic_table[vicMode][H_BLANK];
+	unsigned int line_width = vic_table[vicMode][H_TOTAL];
+	unsigned int Hactive = line_width - active_slot + 1;
+	unsigned int Vactive = vic_table[vicMode][V_ACTIVE] + 1;
+
+	unsigned int Hactive_l = Hactive - 256 * ((unsigned int)Hactive / 256);
+	unsigned int Hactive_h = Hactive / 256;
+	unsigned int Vactive_l = Vactive - 256 * ((unsigned int)Vactive / 256);
+	unsigned int Vactive_h = Vactive / 256;
+
+	unsigned int packet_type = 0x82;
+	unsigned int packet_version = 0x2;
+	unsigned int packet_len = 0xD;
+	unsigned int packet_Y = 0;
+	unsigned int packet_C = 0;
+	unsigned int packet_R = 0;
+	unsigned int packet_VIC = 0;
+	unsigned int packet_PR = 0;
+	unsigned char packet[18];
+	unsigned int packet_HB0 = 0;
+	unsigned int packet_HB1 = 0;
+	unsigned int packet_HB2 = 0;
+	unsigned int packet_PB0 = 0;
+	unsigned int packet_PB1 = 0;
+	unsigned int packet_PB2 = 0;
+	unsigned int packet_PB3 = 0;
+	unsigned int packet_PB4 = 0;
+	unsigned int packet_PB5 = 0;
+	unsigned int packet_PB6 = 0;
+	unsigned int packet_PB7 = 0;
+	unsigned int packet_PB8 = 0;
+	unsigned int packet_PB9 = 0;
+	unsigned int packet_PB10 = 0;
+	unsigned int packet_PB11 = 0;
+	unsigned int packet_PB12 = 0;
+	unsigned int packet_PB13 = 0;
+	unsigned int PB1_13_chksum = 0;
+	unsigned int packet_chksum = 0;
+
+	unsigned int packet_A0 = 1;
+	unsigned int packet_B = 0;
+	unsigned int packet_S = 0;
+	/* Picture Scsaling */
+	unsigned int packet_SC = 0;
+	/* Aspect Ratio: Nodata=0 4:3=1 16:9=2 */
+	unsigned int packet_M = 0;
+	/* Quantization Range Default=0 Limited Range=0x1 FullRange=0x2 Reserved 0x3 */
+	unsigned int packet_Q = 0;
+	/* Quantization Range 0=Limited Range  FullRange=0x1 Reserved 0x3/2 */
+	unsigned int packet_YQ = 0;
+	/* Extended Colorimetry xvYCC601=0x0 xvYCC709=1 All other Reserved */
+	unsigned int packet_EC = 0;
+	/* IT content nodata=0 ITcontent=1 */
+	unsigned int packet_IT = 0;
+	/* Content Type */
+	unsigned int packet_CN = 0;
+
+	/* Active Format Aspec Ratio:
+	 * Same As Picture = 0x8 4:3(Center)=0x9 16:9=0xA 14:9=0xB */
+	packet_R = vic_table[vicMode][VIC_R3_0];
+	/* Video Code (CEA) */
+	packet_VIC = vic_table[vicMode][VIC];
+	/* Pixel Repetition 0 ... 9 (1-10) */
+	packet_PR = vic_table[vicMode][VIC_PR];
+
+	if (colorMode == PXL_RGB)
+		packet_Y = 0;
+	else if (colorMode == YCBCR_4_4_4)
+		packet_Y = 2;
+	else if (colorMode == YCBCR_4_2_2)
+		packet_Y = 1;
+	else if (colorMode == YCBCR_4_2_0)
+		packet_Y = 3;
+
+	/* Colorimetry:  Nodata=0 IT601=1 ITU709=2 */
+	if (ITUver == BT_601)
+		packet_C = 1;
+	else if (ITUver == BT_709)
+		packet_C = 2;
+	else
+		packet_C = 0;
+
+	packet_HB0 = packet_type;
+	packet_HB1 = packet_version;
+	packet_HB2 = packet_len;
+
+	packet_PB1 = 32 * packet_Y + 16 * packet_A0 + 4 * packet_B + packet_S;
+	packet_PB2 = 64 * packet_C + 16 * packet_M + packet_R;
+	packet_PB3 =
+	    128 * packet_IT + 16 * packet_EC + 4 * packet_Q + packet_SC;
+	packet_PB4 = packet_VIC;
+	packet_PB5 = 64 * packet_YQ + 16 * packet_CN + packet_PR;
+	packet_PB6 = 0;
+	packet_PB7 = 0;
+	packet_PB8 = Vactive_l;
+	packet_PB9 = Vactive_h;
+	packet_PB10 = 0;
+	packet_PB11 = 0;
+	packet_PB12 = Hactive_l;
+	packet_PB13 = Hactive_h;
+
+	PB1_13_chksum =
+	    (packet_HB0 + packet_HB1 + packet_HB2 + packet_PB1 + packet_PB2 +
+	     packet_PB3 + packet_PB4 + packet_PB5 + packet_PB6 + packet_PB7 +
+	     packet_PB8 + packet_PB9 + packet_PB10 + packet_PB11 + packet_PB12 +
+	     packet_PB13);
+	packet_chksum =
+	    256 - (PB1_13_chksum - 256 * ((unsigned int)PB1_13_chksum / 256));
+	packet_PB0 = packet_chksum;
+
+	packet[0] = 0;
+	packet[1] = packet_HB0;
+	packet[2] = packet_HB1;
+	packet[3] = packet_HB2;
+	packet[4] = packet_PB0;
+	packet[5] = packet_PB1;
+	packet[6] = packet_PB2;
+	packet[7] = packet_PB3;
+	packet[8] = packet_PB4;
+	packet[9] = packet_PB5;
+	packet[10] = packet_PB6;
+	packet[11] = packet_PB7;
+	packet[12] = packet_PB8;
+	packet[13] = packet_PB9;
+	packet[14] = packet_PB10;
+	packet[15] = packet_PB11;
+	packet[16] = packet_PB12;
+	packet[17] = packet_PB13;
+
+	CDN_API_InfoframeSet(0, packet_len, (unsigned int *)packet, packet_type);
+
+	return CDN_OK;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_AVI.h b/drivers/video/fbdev/mxc/cdn_hdp/API_AVI.h
new file mode 100644
index 0000000..e70f0ee
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_AVI.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_AVI.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AVI_H_
+# define API_AVI_H_
+
+# include "vic_table.h"
+# include "API_General.h"
+
+CDN_API_STATUS CDN_API_Set_AVI(VIC_MODES vicMode,
+			       VIC_PXL_ENCODING_FORMAT colorMode,
+			       BT_TYPE ITUver);
+
+#endif //API_AVI_H_
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_Audio.c b/drivers/video/fbdev/mxc/cdn_hdp/API_Audio.c
new file mode 100644
index 0000000..9ecc3f7
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_Audio.c
@@ -0,0 +1,416 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_Audio.c
+ *
+ ******************************************************************************
+ */
+#include "API_Audio.h"
+#include "API_HDMI_Audio.h"
+#include "API_DPTX.h"
+#include "API_General.h"
+#include "source_aif_decoder.h"
+#include "source_aif_smpl2pckt.h"
+#include "dptx_stream.h"
+#include "address.h"
+#include "util.h"
+#include "externs.h"
+#include "aif_pckt2smp.h"
+#include "dptx_framer.h"
+#include "clock_meters.h"
+#include "source_car.h"
+
+CDN_API_STATUS CDN_API_AudioMute(AUDIO_MUTE_MODE mode)
+{
+	return (CDN_API_General_Write_Field
+		(ADDR_DPTX_STREAM + (DP_VB_ID << 2), 4, 1, (1 - mode) << 4));
+}
+
+CDN_API_STATUS CDN_API_AudioMute_blocking(AUDIO_MUTE_MODE mode)
+{
+	internal_block_function(CDN_API_AudioMute(mode));
+}
+
+CDN_API_STATUS CDN_API_AudioMode(AUDIO_MODE mode)
+{
+	return (CDN_API_General_Write_Register
+		(ADDR_DPTX_FRAMER + (AUDIO_PACK_CONTROL << 2),
+		 F_AUDIO_PACK_EN(mode)));
+}
+
+CDN_API_STATUS CDN_API_AudioMode_blocking(AUDIO_MODE mode)
+{
+	internal_block_function(CDN_API_AudioMode(mode));
+}
+
+CDN_API_STATUS CDN_API_AudioConfigCore(AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width)
+{
+	int i;
+	int lanesParam;
+	unsigned int I2S_DEC_PORT_EN_Val;
+
+	if (numOfChannels == 2) {
+		if (lanes == 1) {
+			lanesParam = 1;
+		} else {
+			lanesParam = 3;
+		}
+	} else {
+		lanesParam = 0;
+	}
+
+	if (audioType == AUDIO_TYPE_I2S) {
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNFG << 2),
+			      0x20000);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 2);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNFG << 2),
+			      F_MAX_NUM_CH(numOfChannels -
+					   1) |
+			      F_NUM_OF_I2S_PORTS((numOfChannels / 2) -
+						 1) | (1 << 8) | (lanesParam <<
+								  11));
+
+		if (numOfChannels == 2) {
+			I2S_DEC_PORT_EN_Val = 1;
+		} else if (numOfChannels == 4) {
+			I2S_DEC_PORT_EN_Val = 3;
+		} else {
+			I2S_DEC_PORT_EN_Val = 0xF;
+		}
+
+		/* 24 bit configuration + number of channels according to config */
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNFG << 2),
+			      0x01000 | F_AUDIO_SAMPLE_WIDTH(width) |
+			      F_AUDIO_CH_NUM(numOfChannels -
+					     1) |
+			      F_I2S_DEC_PORT_EN(I2S_DEC_PORT_EN_Val));
+
+		for (i = 0; i < (numOfChannels + 1) / 2; i++) {
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      ((STTS_BIT_CH01 + i) << 2),
+				      F_WORD_LENGTH_CH0(0x2) |
+				      F_WORD_LENGTH_CH1(0x2) |
+				      F_CHANNEL_NUM_CH0(i *
+							2) |
+				      F_CHANNEL_NUM_CH1((i * 2) + 1));
+		}
+
+		/*set ch status bits */
+		switch (freq) {
+
+		case AUDIO_FREQ_32:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x3) |
+				      F_ORIGINAL_SAMP_FREQ(0xC));
+			break;
+		case AUDIO_FREQ_192:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0xE) |
+				      F_ORIGINAL_SAMP_FREQ(0x1));
+			break;
+
+		case AUDIO_FREQ_48:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x2) |
+				      F_ORIGINAL_SAMP_FREQ(0xD));
+			break;
+		case AUDIO_FREQ_96:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0xA) |
+				      F_ORIGINAL_SAMP_FREQ(0x5));
+			break;
+		case AUDIO_FREQ_44_1:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x0) |
+				      F_ORIGINAL_SAMP_FREQ(0xF));
+			break;
+		case AUDIO_FREQ_88_2:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0x8) |
+				      F_ORIGINAL_SAMP_FREQ(0x7));
+			break;
+		case AUDIO_FREQ_176_4:
+			cdn_apb_write(ADDR_SOURCE_AIF_DECODER +
+				      (COM_CH_STTS_BITS << 2),
+				      4 | F_SAMPLING_FREQ(0xC) |
+				      F_ORIGINAL_SAMP_FREQ(0x3));
+			break;
+		}
+
+		/* Enable I2S encoder */
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      2);
+		/* Enable smpl2pkt */
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      2);
+	} else {
+
+		/* set spidif 2c en */
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (SPDIF_CTRL_ADDR << 2),
+			      0x1F0707);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 2);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNFG << 2),
+			      0x101 | (lanesParam << 11));
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      2);
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (SPDIF_CTRL_ADDR << 2),
+			      0x3F0707);
+	}
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_AudioConfigCore_blocking(AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width)
+{
+	internal_block_function(CDN_API_AudioConfigCore
+				(audioType, numOfChannels, freq, lanes, width));
+}
+
+CDN_API_STATUS CDN_API_AudioAutoConfig(AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width,
+				       CDN_PROTOCOL_TYPE protocol, int ncts,
+				       AUDIO_MUTE_MODE mode)
+{
+
+	CDN_API_STATUS ret = CDN_BSY;
+	unsigned int REF_CYC_Val;
+	switch (state.tmp) {
+	case 0:
+		if (protocol == CDN_DPTX) {
+			ret =
+			    CDN_API_General_Write_Register(ADDR_DPTX_FRAMER +
+							   (AUDIO_PACK_STATUS <<
+							    2), 0x11 << 16);
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+
+	case 1:
+		if (protocol == CDN_DPTX) {
+			REF_CYC_Val = 0x8000;
+			ret =
+			    CDN_API_General_Write_Register(ADDR_CLOCK_METERS +
+							   (CM_LANE_CTRL << 2),
+							   REF_CYC_Val);
+		} else {
+			/* hdmi mode */
+			ret = CDN_API_General_Write_Register(ADDR_CLOCK_METERS + (CM_CTRL << 2), 8);
+
+		}
+		break;
+	case 2:
+		if ((protocol == CDN_HDMITX_TYPHOON)
+		    || (protocol == CDN_HDMITX_KIRAN)) {
+			ret =
+			    CDN_API_General_Write_Register(ADDR_CLOCK_METERS +
+							   (CM_I2S_CTRL << 2),
+							   ncts | 0x4000000);
+		} else {
+			ret = CDN_OK;
+		}
+
+		break;
+
+	case 3:
+		if ((protocol == CDN_HDMITX_TYPHOON)
+		    || (protocol == CDN_HDMITX_KIRAN)) {
+			ret = CDN_OK;
+		} else {
+			/* in dptx set audio on in dp framer */
+			ret = CDN_API_AudioMode(1);
+		}
+		break;
+
+	case 4:
+		/* set car audio on _not reset */
+		if (protocol == CDN_DPTX) {
+			/* TODO DK: try to merge case 3 and 4 */
+			ret = CDN_OK;
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+
+	case 5:
+		if ((protocol == CDN_DPTX) && (audioType != AUDIO_TYPE_I2S)) {
+			ret =
+			    CDN_API_General_Write_Register(ADDR_SOURCE_CAR +
+							   (SOURCE_AIF_CAR <<
+							    2), 0xff);
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+	case 6:
+		if (protocol == CDN_DPTX) {
+			ret =
+			    CDN_API_General_Write_Register(ADDR_CLOCK_METERS +
+							   (CM_CTRL << 2), 0);
+		} else {
+			ret = CDN_OK;
+		}
+		break;
+
+	case 7:
+		ret =
+		    CDN_API_AudioConfigCore(audioType, numOfChannels, freq,
+					    lanes, width);
+		break;
+	case 8:
+		if ((protocol == CDN_HDMITX_TYPHOON)
+		    || (protocol == CDN_HDMITX_KIRAN)) {
+			CDN_API_HDMI_AudioSetInfoFrame(mode, audioType,
+						       numOfChannels, freq,
+						       lanes, ncts);
+		}
+		ret = CDN_OK;
+		break;
+
+	}
+	if (!state.tmp && ret == CDN_STARTED)
+		return CDN_STARTED;
+	switch (ret) {
+	case CDN_OK:
+		state.tmp++;
+		break;
+	case CDN_STARTED:
+		return CDN_BSY;
+		break;
+	default:
+		return ret;
+	}
+	if (state.tmp == 9) {
+		state.tmp = 0;
+		return CDN_OK;
+	}
+	return CDN_BSY;
+
+}
+
+CDN_API_STATUS CDN_API_AudioAutoConfig_blocking(AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width,
+						CDN_PROTOCOL_TYPE protocol,
+						int ncts, AUDIO_MUTE_MODE mode)
+{
+	internal_block_function(CDN_API_AudioAutoConfig
+				(audioType, numOfChannels, freq, lanes, width,
+				 protocol, ncts, mode));
+}
+
+CDN_API_STATUS CDN_API_AudioOff(AUDIO_TYPE audioType)
+{
+	CDN_API_STATUS ret = CDN_BSY;
+
+	switch (state.tmp) {
+	case 0:
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (SPDIF_CTRL_ADDR << 2),
+			      0x1F0707);
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      0);
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNFG << 2),
+			      0);
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      1);
+		cdn_apb_write(ADDR_SOURCE_AIF_DECODER + (AUDIO_SRC_CNTL << 2),
+			      0);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      0);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      1);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (SMPL2PKT_CNTL << 2),
+			      0);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 1);
+		cdn_apb_write(ADDR_SOURCE_AIF_SMPL2PCKT + (FIFO_CNTL << 2), 0);
+		ret = CDN_OK;
+
+		break;
+	case 1:
+		ret =
+		    CDN_API_General_Write_Register(ADDR_SOURCE_CAR +
+						   (SOURCE_AIF_CAR << 2), 0x5f);
+		break;
+	case 2:
+		ret =
+		    CDN_API_General_Write_Register(ADDR_SOURCE_CAR +
+						   (SOURCE_AIF_CAR << 2), 0x0f);
+		break;
+	case 3:
+		ret = CDN_OK;
+		break;
+	}
+
+	if (!state.tmp && ret == CDN_STARTED)
+		return CDN_STARTED;
+	switch (ret) {
+	case CDN_OK:
+		state.tmp++;
+		break;
+	case CDN_STARTED:
+		return CDN_BSY;
+		break;
+	default:
+		return ret;
+	}
+	if (state.tmp == 4) {
+		state.tmp = 0;
+		return CDN_OK;
+	}
+	return CDN_BSY;
+}
+
+CDN_API_STATUS CDN_API_AudioOff_blocking(AUDIO_TYPE audioType)
+{
+	internal_block_function(CDN_API_AudioOff(audioType));
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_Audio.h b/drivers/video/fbdev/mxc/cdn_hdp/API_Audio.h
new file mode 100644
index 0000000..a76c23e
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_Audio.h
@@ -0,0 +1,152 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_Audio.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_AUDIO_H_
+# define API_AUDIO_H_
+
+# include "API_General.h"
+# include "vic_table.h"
+# include "defs.h"
+/**
+ * \addtogroup AUDIO_API
+ * \{
+ */
+typedef enum {
+	AUDIO_TYPE_I2S,
+	AUDIO_TYPE_SPIDIF_INTERNAL,
+	AUDIO_TYPE_SPIDIF_EXTERNAL,
+} AUDIO_TYPE;
+
+typedef enum {
+	AUDIO_FREQ_32,
+	AUDIO_FREQ_48,
+	AUDIO_FREQ_96,
+	AUDIO_FREQ_192,
+	AUDIO_FREQ_44_1,
+	AUDIO_FREQ_88_2,
+	AUDIO_FREQ_176_4,
+} AUDIO_FREQ;
+
+typedef enum {
+	AUDIO_WIDTH_16,
+	AUDIO_WIDTH_24,
+	AUDIO_WIDTH_32,
+} AUDIO_WIDTH;
+
+typedef enum {
+	AUDIO_MODE_OFF,
+	AUDIO_MODE_ON
+} AUDIO_MODE;
+
+typedef enum {
+	AUDIO_MUTE_MODE_MUTE,
+	AUDIO_MUTE_MODE_UNMUTE
+} AUDIO_MUTE_MODE;
+
+/**
+ * \brief mute or unmute audio
+ */
+CDN_API_STATUS CDN_API_AudioMute(AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief blocking version of #CDN_API_AudioMute
+ */
+CDN_API_STATUS CDN_API_AudioMute_blocking(AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief start playing audio with the input parameters
+    ncts and mode are relevant only in HDMI TX mode , not relevant for DPTX mode
+ */
+CDN_API_STATUS CDN_API_AudioAutoConfig(AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width,
+				       CDN_PROTOCOL_TYPE protocol, int ncts,
+				       AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief blocking version of #CDN_API_AudioAutoConfig
+ */
+CDN_API_STATUS CDN_API_AudioAutoConfig_blocking(AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width,
+						CDN_PROTOCOL_TYPE protocol,
+						int ncts, AUDIO_MUTE_MODE mode);
+
+/**
+ * \brief audio off (use it to stop current audio and start new one using CDN_API_AudioAutoConfig)
+ */
+CDN_API_STATUS CDN_API_AudioOff(AUDIO_TYPE audioType);
+
+/**
+ * \brief blocking version of #CDN_API_AudioOff
+ */
+CDN_API_STATUS CDN_API_AudioOff_blocking(AUDIO_TYPE audioType);
+
+/**
+ * \brief internal function to set audio on or off inside internal registers
+ */
+CDN_API_STATUS CDN_API_AudioMode(AUDIO_MODE mode);
+
+/**
+ * \brief blocking version of #CDN_API_AudioMode
+ */
+CDN_API_STATUS CDN_API_AudioMode_blocking(AUDIO_MODE mode);
+
+/**
+ * \brief internal function to set audio core registers
+ */
+CDN_API_STATUS CDN_API_AudioConfigCore(AUDIO_TYPE audioType, int numOfChannels,
+				       AUDIO_FREQ freq, int lanes,
+				       AUDIO_WIDTH width);
+
+/**
+ * \brief blocking version of #CDN_API_AudioConfigCore
+ */
+CDN_API_STATUS CDN_API_AudioConfigCore_blocking(AUDIO_TYPE audioType,
+						int numOfChannels,
+						AUDIO_FREQ freq, int lanes,
+						AUDIO_WIDTH width);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_DPTX.h b/drivers/video/fbdev/mxc/cdn_hdp/API_DPTX.h
new file mode 100644
index 0000000..b87c130
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_DPTX.h
@@ -0,0 +1,426 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_DPTX.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _API_DPTX_H_
+# define _API_DPTX_H_
+
+# include "API_General.h"
+# include "vic_table.h"
+# include "defs.h"
+
+# define MAX_NUM_OF_EVENTS 4
+
+/* Flags for CDN_API_DPTX_SetDbg */
+# define DPTX_DBG_SET_PWR_SKIP_SLEEP (1 << 0)
+# define DPTX_DBG_SET_ALT_CIPHER_ADDR (1 << 1)
+
+/**
+ * \addtogroup DP_TX_API
+ * \{
+ */
+typedef unsigned char CDN_API_PWR_MODE;
+typedef unsigned int CDN_EVENT;
+
+/**
+ * reply data struct for CDN_API_DPTX_READ_EDID
+ * please note, buff will point to internal api buffer, user must copy it for later use
+ */
+typedef struct {
+	unsigned char *buff;
+	unsigned char size;
+	unsigned char blockNo;
+} DPTX_Read_EDID_response;
+/**
+ *  \brief Cadence API for DP TX to get RX EDID
+ *  \param [in] segment - EDID segment to read
+  *  \param [in] extension - EDID extension to read
+ *  \param [out] resp - pointer to store response
+ *   buffer , please note, buff will point to internal api buffer, user must copy it for later use
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_EDID(unsigned char segment,
+				      unsigned char extension,
+				      DPTX_Read_EDID_response *resp);
+/**
+ * \brief blocking version of #CDN_API_DPTX_Read_EDID
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_EDID_blocking(unsigned char segment,
+					       unsigned char extension,
+					       DPTX_Read_EDID_response *resp);
+
+/**
+ *  \brief Cadence API for DP TX to set power mode of sink
+ *
+ *  \param [in] mode  - power mode
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_SetPowerMode(CDN_API_PWR_MODE mode);
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetPowerMode
+ */
+CDN_API_STATUS CDN_API_DPTX_SetPowerMode_blocking(CDN_API_PWR_MODE mode);
+
+/**
+ *  \brief Cadence API for DP TX to set Host capabilities
+ *
+ *  \param [in] maxLinkRate Max link rate-> 0x06=1.62Gbps 0x0A=2.7Gbps 0x14=5.4Gbps 0x1E=8.1Gbps
+ *  \param [in] lanesCount_SSC bit 0-3 lanes count, bit 4 SSC
+ *  \param [in] maxVoltageSwing - - max supported VoltageSwing
+ *  \param [in] maxPreemphasis - max supported Preemphasis
+ *  \param [in] testPatternsSupported -which test patern supportrd by phy
+ *  \param [in] fastLinkTraining - is it fast link training
+ *  \param [in] laneMapping - line mapping for USB type C
+ *  \param [in] enchanced - enchanced mode
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_SetHostCap(unsigned char maxLinkRate,
+				       unsigned char lanesCount_SSC,
+				       unsigned char maxVoltageSwing,
+				       unsigned char maxPreemphasis,
+				       unsigned char testPatternsSupported,
+				       unsigned char fastLinkTraining,
+				       unsigned char laneMapping,
+				       unsigned char enchanced);
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetHostCap
+ */
+CDN_API_STATUS CDN_API_DPTX_SetHostCap_blocking(unsigned char maxLinkRate,
+						unsigned char lanesCount_SSC,
+						unsigned char maxVoltageSwing,
+						unsigned char maxPreemphasis,
+						unsigned char
+						testPatternsSupported,
+						unsigned char fastLinkTraining,
+						unsigned char laneMapping,
+						unsigned char enchanced);
+
+/**
+ * reply data struct for #CDN_API_DPTX_READ_DPCD
+ */
+typedef struct {
+    /** buffer where data will be stored, will become invalid after next call to API */
+	unsigned char *buff;
+	int addr;
+	int size;
+} DPTX_Read_DPCD_response;
+/**
+ *  \brief Cadence API for DP TX to read DPCD
+ *
+ *  \param [in] numOfBytes - num of bytes to read
+ *  \param [in] addr - address to read from
+ *  \param [out] resp - pointer to store response
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_DPCD(int numOfBytes, int addr,
+				      DPTX_Read_DPCD_response *resp,
+				      CDN_BUS_TYPE bus_type);
+/**
+ * blocking version of #CDN_API_DPTX_READ_DPCD
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_DPCD_blocking(int numOfBytes, int addr,
+					       DPTX_Read_DPCD_response *resp,
+					       CDN_BUS_TYPE bus_type);
+
+/**
+ * reply data struct for CDN_API_DPTX_WRITE_DPCD
+ */
+typedef struct {
+	int addr;
+	int size;
+} DPTX_Write_DPCD_response;
+/**
+ *  \brief Cadence API for DP TX to write DPCD
+ *
+ *  \param [in] numOfBytes - num of bytes to write
+ *  \param [in] addr - address to write
+ *  \param [in] buff - with the data to write
+ *  \param [out] resp - pointer to store response
+ *  \return status
+ *
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_DPCD(unsigned int numOfBytes,
+				       unsigned int addr, unsigned char *buff,
+				       DPTX_Write_DPCD_response *resp,
+				       CDN_BUS_TYPE bus_type);
+/**
+ * blocking version of #CDN_API_DPTX_WRITE_DPCD
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_DPCD_blocking(unsigned int numOfBytes,
+						unsigned int addr,
+						unsigned char *buff,
+						DPTX_Write_DPCD_response *resp,
+						CDN_BUS_TYPE bus_type);
+
+/**
+ * DPTX_Read_Register response struct
+ */
+typedef struct {
+	unsigned char base;
+	unsigned char regNo;
+	unsigned int val;
+} DPTX_Read_Register_response;
+/**
+ * \brief Cadence API for DP TX to read register
+ *
+ * \param [in] base - bank numeber (MSB of bank base address)
+ * \param [in] regNo - register number
+ * \param [out] resp - pointer to store response
+ * \return status
+ *
+ * this function will return #CDN_ERR if value of base is incorrect
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_Register(unsigned char base,
+					  unsigned char regNo,
+					  DPTX_Read_Register_response *resp);
+/**
+ * blocking version of #CDN_API_DPTX_READ_REGISTER
+ */
+CDN_API_STATUS CDN_API_DPTX_Read_Register_blocking(unsigned char base,
+						   unsigned char regNo,
+						   DPTX_Read_Register_response *resp);
+
+/**
+ * \brief Cadence API for DP TX write register
+ *
+ * \param [in] base - bank numeber (MSB of bank base address)
+ * \param [in] regNo - register number
+ * \param [in] val - value to write
+ * \return status
+ *
+ * this function will return #CDN_ERR if value of base is incorrect
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Register(unsigned char base,
+					   unsigned char regNo,
+					   unsigned int val);
+/**
+ * blocking version of #CDN_API_DPTX_Write_Register
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Register_blocking(unsigned char base,
+						    unsigned char regNo,
+						    unsigned int val);
+
+/**
+ * \brief Cadence API for DP TX write register
+ *
+ * \param [in] base - bank numeber (MSB of bank base address)
+ * \param [in] regNo - register number
+ * \param [in] startBit - first bit to write
+ * \param [in] bitsNo - number of bits to write
+ * \param [in] val - value to write
+ * \return status
+ *
+ * this function will return #CDN_ERR if value of base is incorrect
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Field(unsigned char base, unsigned char regNo,
+					unsigned char startBit,
+					unsigned char bitsNo, unsigned int val);
+/**
+ * blocking version of #CDN_API_DPTX_Write_Field
+ */
+CDN_API_STATUS CDN_API_DPTX_Write_Field_blocking(unsigned char base,
+						 unsigned char regNo,
+						 unsigned char startBit,
+						 unsigned char bitsNo,
+						 unsigned int val);
+
+/* TODO doxygen of DPTX_CONTROL API */
+CDN_API_STATUS CDN_API_DPTX_Control(unsigned int mode);
+/**
+ * blocking version of #CDN_API_DPTX_Control
+ */
+CDN_API_STATUS CDN_API_DPTX_Control_blocking(unsigned int mode);
+
+/**
+  * \brief send DPX_ENABLE_EVENT command
+  */
+CDN_API_STATUS CDN_API_DPTX_EnableEvent(bool hpd, bool training);
+
+/**
+ * blocking version of #CDN_API_DPTX_EnableEvent
+ */
+CDN_API_STATUS CDN_API_DPTX_EnableEvent_blocking(bool hpd, bool training);
+
+/**
+ * \brief send DPTX_READ_EVENT_REQUEST command
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadEvent(unsigned char *LinkeventId,
+				      unsigned char *HPDevents);
+
+/**
+ * blocking version of #CDN_API_DPTX_ReadEvent
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadEvent_blocking(unsigned char *LinkeventId,
+					       unsigned char *HPDevents);
+
+/**
+ * \brief set vic mode according to vic table, the input are video parameters
+ */
+CDN_API_STATUS CDN_API_DPTX_Set_VIC(VIC_MODES vicMode, int bitsPerPixel,
+				    VIC_NUM_OF_LANES NumOfLanes,
+				    VIC_SYMBOL_RATE rate,
+				    VIC_PXL_ENCODING_FORMAT pxlencformat,
+				    STEREO_VIDEO_ATTR steroVidAttr,
+				    BT_TYPE bt_type, int TU);
+
+/**
+ * blocking version of #CDN_API_DPTX_Set_VIC
+ */
+CDN_API_STATUS CDN_API_DPTX_Set_VIC_blocking(VIC_MODES vicMode,
+					     int bitsPerPixel,
+					     VIC_NUM_OF_LANES NumOfLanes,
+					     VIC_SYMBOL_RATE rate,
+					     VIC_PXL_ENCODING_FORMAT
+					     pxlencformat,
+					     STEREO_VIDEO_ATTR steroVidAttr,
+					     BT_TYPE bt_type, int TU);
+
+/**
+ * \brief turn on or off the video
+ */
+CDN_API_STATUS CDN_API_DPTX_SetVideo(unsigned char mode);
+
+/**
+ * \brief blocking version of  CDN_API_DPTX_SetVideo
+ */
+CDN_API_STATUS CDN_API_DPTX_SetVideo_blocking(unsigned char mode);
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetAudio
+ */
+CDN_API_STATUS CDN_API_DPTX_SetAudio_blocking(unsigned char mode);
+
+typedef struct {
+	unsigned char rate;
+	unsigned char lanes;
+	unsigned char swing[3];
+	unsigned char preemphasis[3];
+} S_LINK_STAT;
+
+/**
+ * \brief get current link status (rate, num of lanes etc), user may read it after get link finish event
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadLinkStat(S_LINK_STAT *stat);
+
+/**
+ * \brief blocking version of #CDN_API_DPTX_ReadLinkStat
+ */
+CDN_API_STATUS CDN_API_DPTX_ReadLinkStat_blocking(S_LINK_STAT *stat);
+
+/**
+ * \brief start link training
+ */
+CDN_API_STATUS CDN_API_DPTX_TrainingControl(unsigned char val);
+/**
+ * \brief blocking version of #CDN_API_DPTX_TrainingControl
+ */
+CDN_API_STATUS CDN_API_DPTX_TrainingControl_blocking(unsigned char val);
+
+/**
+ * \brief check if last auxilary transaction succedd
+ */
+CDN_API_STATUS CDN_API_DPTX_GetLastAuxStatus(unsigned char *resp);
+/**
+ * \brief blocking version of #CDN_API_DPTX_GetLastAuxStatus
+ */
+CDN_API_STATUS CDN_API_DPTX_GetLastAuxStatus_blocking(unsigned char *resp);
+
+/**
+ * \brief get current hpd status
+ */
+
+CDN_API_STATUS CDN_API_DPTX_GetHpdStatus(unsigned char *resp);
+/**
+ * \brief blocking version of #CDN_API_DPTX_GetHpdStatus
+ */
+CDN_API_STATUS CDN_API_DPTX_GetHpdStatus_blocking(unsigned char *resp);
+
+/**
+ * \brief force the lanes to specific swing or preemphasis, with SSc or without to pattern (0=PRBS7 or 1=D10.2) for CTS or debug phy purpose
+ */
+CDN_API_STATUS CDN_API_DPTX_ForceLanes(unsigned char linkRate,
+				       unsigned char numOfLanes,
+				       unsigned char voltageSwing_l0,
+				       unsigned char preemphasis_l0,
+				       unsigned char voltageSwing_l1,
+				       unsigned char preemphasis_l1,
+				       unsigned char voltageSwing_l2,
+				       unsigned char preemphasis_l2,
+				       unsigned char voltageSwing_l3,
+				       unsigned char preemphasis_l3,
+				       unsigned char pattern,
+				       unsigned char ssc);
+
+/**
+ * \brief blocking version of #CDN_API_DPTX_ForceLanes
+ */
+CDN_API_STATUS CDN_API_DPTX_ForceLanes_blocking(unsigned char linkRate,
+						unsigned char numOfLanes,
+						unsigned char voltageSwing_l0,
+						unsigned char preemphasis_l0,
+						unsigned char voltageSwing_l1,
+						unsigned char preemphasis_l1,
+						unsigned char voltageSwing_l2,
+						unsigned char preemphasis_l2,
+						unsigned char voltageSwing_l3,
+						unsigned char preemphasis_l3,
+						unsigned char pattern,
+						unsigned char ssc);
+
+/**
+ * \brief Sets DP TX debug related features.
+ */
+CDN_API_STATUS CDN_API_DPTX_SetDbg(uint32_t dbg_cfg);
+
+/**
+ * \brief blocking version of #CDN_API_DPTX_SetDbg
+ */
+CDN_API_STATUS CDN_API_DPTX_SetDbg_blocking(uint32_t dbg_cfg);
+
+double CDN_API_Get_PIXEL_FREQ_MHZ_ClosetVal(double val,
+					    CDN_PROTOCOL_TYPE protocol);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_General.c b/drivers/video/fbdev/mxc/cdn_hdp/API_General.c
new file mode 100644
index 0000000..9002d74
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_General.c
@@ -0,0 +1,443 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_General.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_General.h"
+#include "util.h"
+#include "address.h"
+#include "apb_cfg.h"
+#include "opcodes.h"
+#include "general_handler.h"
+#include "externs.h"
+
+static unsigned int alive;
+
+void CDN_API_Init(void)
+{
+	memset(&state, 0, sizeof(state_struct));
+}
+
+CDN_API_STATUS CDN_API_LoadFirmware(unsigned char *iMem, int imemSize,
+				    unsigned char *dMem, int dmemSize)
+{
+	int i;
+	for (i = 0; i < imemSize; i += 4)
+		if (cdn_apb_write(ADDR_IMEM + i,
+				  (unsigned int)iMem[i] << 0 |
+				  (unsigned int)iMem[i + 1] << 8 |
+				  (unsigned int)iMem[i + 2] << 16 |
+				  (unsigned int)iMem[i + 3] << 24))
+			return CDN_ERR;
+	for (i = 0; i < dmemSize; i += 4)
+		if (cdn_apb_write(ADDR_DMEM + i,
+				  (unsigned int)dMem[i] << 0 |
+				  (unsigned int)dMem[i + 1] << 8 |
+				  (unsigned int)dMem[i + 2] << 16 |
+				  (unsigned int)dMem[i + 3] << 24))
+			return CDN_ERR;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo(unsigned int val,
+					 CDN_BUS_TYPE bus_type)
+{
+	CDN_API_STATUS ret;
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL, GENERAL_TEST_ECHO,
+				      1, 4, val);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	if (state.rxEnable && !internal_mbox_rx_process().rxend)
+		return CDN_BSY;
+	ret = internal_test_rx_head(MB_MODULE_ID_GENERAL,
+						GENERAL_TEST_ECHO);
+	if (ret != CDN_OK) {
+		state.running = 0;
+		return ret;
+	}
+	state.running = 0;
+	if (val != internal_betoi(state.rxBuffer + INTERNAL_CMD_HEAD_SIZE, 4))
+		return CDN_ERR;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo_blocking(unsigned int val,
+						  CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_General_Test_Echo(val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext(uint8_t const *msg, uint8_t *resp,
+					     uint16_t num_bytes,
+					     CDN_BUS_TYPE bus_type)
+{
+	CDN_API_STATUS ret;
+
+	if (!msg || !resp) {
+		return CDN_ERR;
+	}
+
+	if ((num_bytes > GENERAL_TEST_ECHO_MAX_PAYLOAD)
+	    || (num_bytes < GENERAL_TEST_ECHO_MIN_PAYLOAD)) {
+		return CDN_ERR;
+	}
+
+	if (!state.running) {
+		if (!internal_apb_available()) {
+			return CDN_BSY;
+		}
+
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL, GENERAL_TEST_ECHO,
+				      1, -num_bytes, msg);
+
+		return CDN_STARTED;
+	}
+
+	if (state.txEnable && !internal_mbox_tx_process().txend) {
+		return CDN_BSY;
+	}
+
+	if (state.rxEnable && !internal_mbox_rx_process().rxend) {
+		return CDN_BSY;
+	}
+
+	ret = internal_test_rx_head(MB_MODULE_ID_GENERAL, GENERAL_TEST_ECHO);
+
+	if (ret != CDN_OK) {
+		state.running = 0;
+		return ret;
+	}
+
+	state.running = 0;
+
+	memcpy(resp, state.rxBuffer + INTERNAL_CMD_HEAD_SIZE, num_bytes);
+
+	if (memcmp(msg, resp, num_bytes) != 0) {
+		return CDN_ERR;
+	}
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext_blocking(uint8_t const *msg,
+						      uint8_t *resp,
+						      uint16_t num_bytes,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_General_Test_Echo_Ext
+				(msg, resp, num_bytes, bus_type)
+	    );
+}
+
+CDN_API_STATUS CDN_API_General_getCurVersion(unsigned short *ver,
+					     unsigned short *verlib)
+{
+	unsigned int vh, vl, vlh, vll;
+	if (cdn_apb_read(VER_L << 2, &vl))
+		return CDN_ERR;
+	if (cdn_apb_read(VER_H << 2, &vh))
+		return CDN_ERR;
+	if (cdn_apb_read(VER_LIB_L_ADDR << 2, &vll))
+		return CDN_ERR;
+	if (cdn_apb_read(VER_LIB_H_ADDR << 2, &vlh))
+		return CDN_ERR;
+	*ver = F_VER_MSB_RD(vh) << 8 | F_VER_LSB_RD(vl);
+	*verlib = F_SW_LIB_VER_H_RD(vlh) << 8 | F_SW_LIB_VER_L_RD(vll);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_Get_Event(uint32_t *events)
+{
+	uint32_t evt[4] = { 0 };
+
+	if (!events) {
+		printk("events pointer is NULL!\n");
+		return CDN_ERR;
+	}
+
+	if (cdn_apb_read(SW_EVENTS0 << 2, &evt[0])
+	    || cdn_apb_read(SW_EVENTS1 << 2, &evt[1])
+	    || cdn_apb_read(SW_EVENTS2 << 2, &evt[2])
+	    || cdn_apb_read(SW_EVENTS3 << 2, &evt[3])) {
+		printk("Failed to read events registers.\n");
+
+		return CDN_ERR;
+	}
+
+	*events = (evt[0] & 0xFF)
+	    | ((evt[1] & 0xFF) << 8)
+	    | ((evt[2] & 0xFF) << 16)
+	    | ((evt[3] & 0xFF) << 24);
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_Get_Debug_Reg_Val(uint16_t *val)
+{
+	uint32_t dbg[2] = { 0 };
+
+	if (!val) {
+		printk("val pointer is NULL!\n");
+		return CDN_ERR;
+	}
+
+	if (cdn_apb_read(SW_DEBUG_L << 2, &dbg[0])
+	    || cdn_apb_read(SW_DEBUG_H << 2, &dbg[1])) {
+		printk("Failed to read debug registers.\n");
+
+		return CDN_ERR;
+	}
+
+	*val = (uint16_t) ((dbg[0] & 0xFF) | ((dbg[1] & 0xFF) << 8));
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_CheckAlive(void)
+{
+	unsigned int newalive;
+	if (cdn_apb_read(KEEP_ALIVE << 2, &newalive))
+		return CDN_ERR;
+	if (alive == newalive)
+		return CDN_BSY;
+	alive = newalive;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_CheckAlive_blocking(void)
+{
+	internal_block_function(CDN_API_CheckAlive());
+}
+
+CDN_API_STATUS CDN_API_MainControl(unsigned char mode, unsigned char *resp)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = CDN_BUS_TYPE_APB;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL, GENERAL_MAIN_CONTROL, 1, 1, mode);
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	internal_opcode_ok_or_return(MB_MODULE_ID_GENERAL,
+				     GENERAL_MAIN_CONTROL_RESP);
+	internal_readmsg(1, 1, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_MainControl_blocking(unsigned char mode,
+					    unsigned char *resp)
+{
+	internal_block_function(CDN_API_MainControl(mode, resp));
+}
+
+CDN_API_STATUS CDN_API_ApbConf(uint8_t dpcd_bus_sel, uint8_t dpcd_bus_lock,
+			       uint8_t hdcp_bus_sel, uint8_t hdcp_bus_lock,
+			       uint8_t capb_bus_sel, uint8_t capb_bus_lock,
+			       uint8_t *dpcd_resp, uint8_t *hdcp_resp,
+			       uint8_t *capb_resp)
+{
+	uint8_t resp;
+	uint8_t set = 0;
+
+	if (!state.running) {
+		if (!internal_apb_available()) {
+			return CDN_BSY;
+		}
+
+		state.bus_type = CDN_BUS_TYPE_APB;
+		state.rxEnable = 1;
+
+		set |= (dpcd_bus_sel)
+		    ? (1 << GENERAL_BUS_SETTINGS_DPCD_BUS_BIT)
+		    : 0;
+		set |= (dpcd_bus_lock)
+		    ? (1 << GENERAL_BUS_SETTINGS_DPCD_BUS_LOCK_BIT)
+		    : 0;
+		set |= (hdcp_bus_sel)
+		    ? (1 << GENERAL_BUS_SETTINGS_HDCP_BUS_BIT)
+		    : 0;
+		set |= (hdcp_bus_lock)
+		    ? (1 << GENERAL_BUS_SETTINGS_HDCP_BUS_LOCK_BIT)
+		    : 0;
+		set |= (capb_bus_sel)
+		    ? (1 << GENERAL_BUS_SETTINGS_CAPB_OWNER_BIT)
+		    : 0;
+		set |= (capb_bus_lock)
+		    ? (1 << GENERAL_BUS_SETTINGS_CAPB_OWNER_LOCK_BIT)
+		    : 0;
+
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL,
+				      GENERAL_BUS_SETTINGS, 1, 1, set);
+
+		return CDN_STARTED;
+	}
+
+	INTERNAL_PROCESS_MESSAGES;
+	internal_opcode_ok_or_return(MB_MODULE_ID_GENERAL,
+				     GENERAL_BUS_SETTINGS_RESP);
+
+	/* Read one one-byte response */
+	internal_readmsg(1, 1, &resp);
+
+	*dpcd_resp =
+	    (resp & (1 << GENERAL_BUS_SETTINGS_RESP_DPCD_BUS_BIT)) ? 1 : 0;
+	*hdcp_resp =
+	    (resp & (1 << GENERAL_BUS_SETTINGS_RESP_HDCP_BUS_BIT)) ? 1 : 0;
+	*capb_resp =
+	    (resp & (1 << GENERAL_BUS_SETTINGS_RESP_CAPB_OWNER_BIT)) ? 1 : 0;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_ApbConf_blocking(uint8_t dpcd_bus_sel,
+					uint8_t dpcd_bus_lock,
+					uint8_t hdcp_bus_sel,
+					uint8_t hdcp_bus_lock,
+					uint8_t capb_bus_sel,
+					uint8_t capb_bus_lock,
+					uint8_t *dpcd_resp,
+					uint8_t *hdcp_resp,
+					uint8_t *capb_resp)
+{
+	internal_block_function(CDN_API_ApbConf(dpcd_bus_sel, dpcd_bus_lock,
+						hdcp_bus_sel, hdcp_bus_lock,
+						capb_bus_sel, capb_bus_lock,
+						dpcd_resp, hdcp_resp,
+						capb_resp));
+}
+
+CDN_API_STATUS CDN_API_SetClock(unsigned char MHz)
+{
+	return cdn_apb_write(SW_CLK_H << 2, MHz);
+}
+
+CDN_API_STATUS CDN_API_General_Read_Register(unsigned int addr,
+					     GENERAL_Read_Register_response *resp)
+{
+	CDN_API_STATUS ret;
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL,
+				      GENERAL_READ_REGISTER, 1, 4, addr);
+		state.bus_type = CDN_BUS_TYPE_APB;
+		state.rxEnable = 1;
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	ret = internal_test_rx_head(MB_MODULE_ID_GENERAL,
+				   GENERAL_READ_REGISTER_RESP);
+	if (ret != CDN_OK)
+		return ret;
+	internal_readmsg(2, 4, &resp->addr, 4, &resp->val);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Read_Register_blocking(unsigned int addr,
+						      GENERAL_Read_Register_response *resp)
+{
+	internal_block_function(CDN_API_General_Read_Register(addr, resp));
+}
+
+CDN_API_STATUS CDN_API_General_Write_Register(unsigned int addr,
+					      unsigned int val)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL,
+				      GENERAL_WRITE_REGISTER, 2, 4, addr, 4,
+				      val);
+		state.bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Write_Register_blocking(unsigned int addr,
+						       unsigned int val)
+{
+	internal_block_function(CDN_API_General_Write_Register(addr, val));
+}
+
+CDN_API_STATUS CDN_API_General_Write_Field(unsigned int addr,
+					   unsigned char startBit,
+					   unsigned char bitsNo,
+					   unsigned int val)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		internal_tx_mkfullmsg(MB_MODULE_ID_GENERAL, GENERAL_WRITE_FIELD,
+				      4, 4, addr, 1, startBit, 1, bitsNo, 4,
+				      val);
+		state.bus_type = CDN_BUS_TYPE_APB;
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_General_Write_Field_blocking(unsigned int addr,
+						    unsigned char startBit,
+						    unsigned char bitsNo,
+						    unsigned int val)
+{
+	internal_block_function(CDN_API_General_Write_Field
+				(addr, startBit, bitsNo, val));
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_General.h b/drivers/video/fbdev/mxc/cdn_hdp/API_General.h
new file mode 100644
index 0000000..1857470
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_General.h
@@ -0,0 +1,291 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_General.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_GENERAL_H_
+# define API_GENERAL_H_
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/io.h>
+
+# define GENERAL_TEST_ECHO_MAX_PAYLOAD 100
+# define GENERAL_TEST_ECHO_MIN_PAYLOAD 1
+
+/**
+ * \addtogroup GENERAL_API
+ * \{
+ */
+/** status code returned by API calls */
+typedef enum {
+    /** operation succedded */
+	CDN_OK = 0,
+    /** CEC operation succedded */
+	CDN_CEC_ERR_NONE = 0,
+    /** mailbox is currently sending or receiving data */
+	CDN_BSY,
+    /** message set up and ready to be sent, no data sent yet */
+	CDN_STARTED,
+    /** error encountered while reading/writing APB */
+	CDN_ERR,
+    /** reply returned with bad opcode */
+	CDN_BAD_OPCODE,
+    /** reply returned with bad module */
+	CDN_BAD_MODULE,
+    /** reply not supported mode */
+	CDN_ERROR_NOT_SUPPORTED,
+    /** Invalid argument passed to CEC API function */
+	CDN_CEC_ERR_INVALID_ARG,
+    /**
+     * TX Buffer for CEC Messages is full. This is applicable only
+     * when TX Buffers for CEC Messages are implemented in the HW.
+     */
+	CDN_CEC_ERR_TX_BUFF_FULL,
+    /** No Messages in the RX Buffers are present. */
+	CDN_CEC_ERR_RX_BUFF_EMPTY,
+    /** Timeout during TX operation */
+	CDN_CEC_ERR_TX_TIMEOUT,
+    /** Timeout during RX operation */
+	CDN_CEC_ERR_RX_TIMEOUT,
+    /** Data transmision fail. */
+	CDN_CEC_ERR_TX_FAILED,
+    /** Data reception fail. */
+	CDN_CEC_ERR_RX_FAILED,
+    /** Operation aborted. */
+	CDN_CEC_ERR_ABORT,
+} CDN_API_STATUS;
+
+typedef enum {
+	CDN_BUS_TYPE_APB = 0,
+	CDN_BUS_TYPE_SAPB = 1
+} CDN_BUS_TYPE;
+
+/**
+ * GENERAL_Read_Register response struct
+ */
+typedef struct {
+	unsigned int addr;
+	unsigned int val;
+} GENERAL_Read_Register_response;
+
+/**
+ * \brief set up API, must be called before any other API call
+ */
+void CDN_API_Init(void);
+
+/**
+ * \brief Loads firmware
+ *
+ * \param iMem - pointer to instruction memory
+ * \param imemSize - size of instruction memory buffer
+ * \param dMem - pointer to data memory
+ * \param dmemSize - size of data memory buffer
+ * \return 0 if success, 1 if apb error encountered, 2 if CPU isn't alive after loading firmware
+ *
+ * This function does not require initialisation by #CDN_API_Init
+ */
+
+CDN_API_STATUS CDN_API_LoadFirmware(unsigned char *iMem, int imemSize,
+				    unsigned char *dMem, int dmemSize);
+
+/**
+ * \brief debug echo command for APB
+ * \param val - value to echo
+ * \return status
+ *
+ * will return #CDN_ERROR if reply message doesn't match request
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo(unsigned int val,
+					 CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_General_Test_Echo
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo_blocking(unsigned int val,
+						  CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief Extended Echo test for mailbox.
+ *
+ * This test will send msg buffer to firmware's mailbox and receive it back to
+ * the resp buffer. Received data will be check against data sent and status will
+ * be returned as well as received data.
+ *
+ * \param msg - Pointer to a buffer to send.
+ * \param resp - Pointer to buffer for receiving msg payload back.
+ * \param num_bytes - Number of bytes to send and receive.
+ * \param bus_type Bus type.
+ * \return status
+ *
+ * will return #CDN_ERROR if reply message doesn't match request or if
+ *  arguments are invalid.
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext(uint8_t const *msg, uint8_t *resp,
+					     uint16_t num_bytes,
+					     CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_General_Test_Echo_Ext
+ */
+CDN_API_STATUS CDN_API_General_Test_Echo_Ext_blocking(uint8_t const *msg,
+						      uint8_t *resp,
+						      uint16_t num_bytes,
+						      CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief get current version
+ * \param [out] ver - fw version
+ * \param [out] libver - lib version
+ * \return status
+ *
+ * this fucntion does not require #CDN_API_Init
+ */
+CDN_API_STATUS CDN_API_General_getCurVersion(unsigned short *ver,
+					     unsigned short *verlib);
+
+/**
+ * \brief read event value
+ * \param [out] event - pointer to store 32-bit events value
+ * \return status
+ *
+ * this function does not require #CDN_API_Init
+ */
+CDN_API_STATUS CDN_API_Get_Event(uint32_t *events);
+
+/**
+ * \brief read debug register value
+ * \param [out] val - pointer to store 16-bit debug reg value
+ * \return status
+ *
+ * this function does not require #CDN_API_Init
+ */
+CDN_API_STATUS CDN_API_Get_Debug_Reg_Val(uint16_t *val);
+
+/**
+ * \brief check if KEEP_ALIVE register changed
+ * \return #CDN_BSY if KEEP_ALIVE not changed, #CDN_OK if changed and #CDN_ERR if error occured while reading
+ */
+CDN_API_STATUS CDN_API_CheckAlive(void);
+
+/**
+ * \breif blocking version of #CDN_API_CheckAlive
+ * blocks untill KEEP_ALIVE register changes or error occurs while reading
+ */
+CDN_API_STATUS CDN_API_CheckAlive_blocking(void);
+
+/**
+ * \brief set cpu to standby or active
+ * \param [in] state - 1 for active, 0 for standby
+ * \return status
+ */
+CDN_API_STATUS CDN_API_MainControl(unsigned char mode, unsigned char *resp);
+
+/**
+ * \breif blocking version of #CDN_API_MainControl
+ */
+CDN_API_STATUS CDN_API_MainControl_blocking(unsigned char mode,
+					    unsigned char *resp);
+
+/**
+ * \brief settings for APB
+ *
+ * Sends GENERAL_APB_CONF Command via regular Mailbox.
+ * @param dpcd_bus_sel Set DPCD to use selected bus (0 for APB or 1 for SAPB)
+ * @param dpcd_bus_lock Lock bus type. Aftern that bus type cannot be changed
+ * by using this function.
+ * @param hdcp_bus_sel Same meaning as for DPCD but for HDCP.
+ * @param hdcp_bus_lock Same meaning as for DPCD but for HDCP.
+ * @param capb_bus_sel Same meaning as for DPCD but for Cipher APB.
+ * @param capb_bus_lock Same meaning as for DPCD but for Cipher APB.
+ * @param dpcd_resp [out] Status of the operation.
+ * If set to zero then DPCD bus type was successfuly changed.
+ * If not then error occurred, most likely due to locked DPCD bus.
+ * @param hdcp_resp [out] Same as for DPCD but for HDCP.
+ * @param capb_resp [out] Same as for DPCD but for Cipher APB.
+ *
+ * \return status
+ */
+CDN_API_STATUS CDN_API_ApbConf(uint8_t dpcd_bus_sel, uint8_t dpcd_bus_lock,
+			       uint8_t hdcp_bus_sel, uint8_t hdcp_bus_lock,
+			       uint8_t capb_bus_sel, uint8_t capb_bus_lock,
+			       uint8_t *dpcd_resp, uint8_t *hdcp_resp,
+			       uint8_t *capb_resp);
+
+/**
+ * blocking version of #CDN_API_MainControl
+ */
+CDN_API_STATUS CDN_API_ApbConf_blocking(uint8_t dpcd_bus_sel,
+					uint8_t dpcd_bus_lock,
+					uint8_t hdcp_bus_sel,
+					uint8_t hdcp_bus_lock,
+					uint8_t capb_bus_sel,
+					uint8_t capb_bus_lock,
+					uint8_t *dpcd_resp,
+					uint8_t *hdcp_resp,
+					uint8_t *capb_resp);
+
+/**
+ * \brief set the  xtensa clk, write this api before turn on the cpu
+ */
+CDN_API_STATUS CDN_API_SetClock(unsigned char MHz);
+
+CDN_API_STATUS CDN_API_General_Read_Register(unsigned int addr,
+					     GENERAL_Read_Register_response *
+					     resp);
+CDN_API_STATUS CDN_API_General_Read_Register_blocking(unsigned int addr,
+						      GENERAL_Read_Register_response
+						      *resp);
+CDN_API_STATUS CDN_API_General_Write_Register(unsigned int addr,
+					      unsigned int val);
+CDN_API_STATUS CDN_API_General_Write_Register_blocking(unsigned int addr,
+						       unsigned int val);
+CDN_API_STATUS CDN_API_General_Write_Field(unsigned int addr,
+					   unsigned char startBit,
+					   unsigned char bitsNo,
+					   unsigned int val);
+CDN_API_STATUS CDN_API_General_Write_Field_blocking(unsigned int addr,
+						    unsigned char startBit,
+						    unsigned char bitsNo,
+						    unsigned int val);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.c b/drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.c
new file mode 100644
index 0000000..e21d464
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.c
@@ -0,0 +1,427 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_HDCP.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_HDCP.h"
+#include "util.h"
+#include "address.h"
+#include "opcodes.h"
+#include "hdcp2.h"
+
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION(unsigned char val,
+					     CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_CONFIGURATION, 1, 1, val);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	state.running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION_blocking(unsigned char val,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP_TX_CONFIGURATION(val, bus_type));
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS(S_HDCP_TRANS_PUBLIC_KEY_PARAMS *val,
+				       CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_SET_PUBLIC_KEY_PARAMS, 2,
+				      -sizeof(val->N), &val->N, -sizeof(val->E),
+				      &val->E);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	state.running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS_blocking(S_HDCP_TRANS_PUBLIC_KEY_PARAMS *
+						val, CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS
+				(val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS(S_HDCP_TRANS_KM_KEY_PARAMS *
+						  val, CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_SET_KM_KEY_PARAMS, 1,
+				      -sizeof(val->KM_KEY), &val->KM_KEY);
+
+		return CDN_STARTED;
+	}
+
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+
+	state.running = 0;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS_blocking(S_HDCP_TRANS_KM_KEY_PARAMS *val,
+					    CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS
+				(val, bus_type));
+}
+
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS(S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *
+					  val, CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS, 5,
+				      -sizeof(val->KM), &val->KM,
+				      -sizeof(val->RN), &val->RN,
+				      -sizeof(val->KS), &val->KS,
+				      -sizeof(val->RIV), &val->RIV,
+				      -sizeof(val->RTX), &val->RTX);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	state.running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+    CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS_blocking
+    (S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *val, CDN_BUS_TYPE bus_type) {
+	internal_block_function(CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS
+				(val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM(S_HDCP_TRANS_PAIRING_DATA *val,
+					   CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		/* pairing info found in storage */
+		if (val != NULL)
+			internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+					      HDCP2_TX_RESPOND_KM, 4,
+					      -sizeof(val->Receiver_ID),
+					      &val->Receiver_ID,
+					      -sizeof(val->m), &val->m,
+					      -sizeof(val->KM), &val->KM,
+					      -sizeof(val->EKH), &val->EKH);
+		else
+			/* no pairing info found in storage */
+			internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+					      HDCP2_TX_RESPOND_KM, 0);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	state.running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM_blocking(S_HDCP_TRANS_PAIRING_DATA *
+						    val, CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP2_TX_RESPOND_KM(val, bus_type));
+}
+
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS(S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *val,
+			   CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX, HDCP1_TX_SEND_KEYS,
+				      2, -sizeof(val->AKSV), &val->AKSV,
+				      -sizeof(val->KSV), &val->KSV);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	state.running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS_blocking(S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *
+				    val, CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP1_TX_SEND_KEYS(val, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN(unsigned char An[8],
+					       CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP1_TX_SEND_RANDOM_AN, 1, -8, An);
+		return CDN_STARTED;
+	}
+	if (state.txEnable && !internal_mbox_tx_process().txend)
+		return CDN_BSY;
+	state.running = 0;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN_blocking(unsigned char An[8],
+							CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP1_TX_SEND_RANDOM_AN(An, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ(unsigned char *resp,
+					  CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_STATUS_CHANGE, 0);
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	internal_opcode_match_or_return();
+	internal_readmsg(1, -5, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ_blocking(unsigned char resp[5],
+						   CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP_TX_STATUS_REQ(resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ(unsigned char resp[5],
+						 CDN_BUS_TYPE bus_type)
+{
+	printk("_debug: 0\n");
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		printk("_debug: 1\n");
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP2_TX_IS_KM_STORED, 0);
+		printk("_debug: 2\n");
+		return CDN_STARTED;
+	}
+	printk("_debug: 3\n");
+	INTERNAL_PROCESS_MESSAGES;
+	printk("_debug: 4\n");
+	internal_opcode_match_or_return();
+	printk("_debug: 5\n");
+	internal_readmsg(1, -5, resp);
+	printk("_debug: 6\n");
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ_blocking(unsigned char resp[5],
+							  CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP2_TX_IS_KM_STORED_REQ
+				(resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ(S_HDCP_TRANS_PAIRING_DATA *resp,
+					     CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX, HDCP2_TX_STORE_KM,
+				      0);
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	internal_opcode_match_or_return();
+	internal_readmsg(4,
+			 -sizeof(resp->Receiver_ID), &resp->Receiver_ID,
+			 -sizeof(resp->m), &resp->m,
+			 -sizeof(resp->KM), &resp->KM,
+			 -sizeof(resp->EKH), &resp->EKH);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ_blocking(S_HDCP_TRANS_PAIRING_DATA
+						      *resp,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP2_TX_STORE_KM_REQ(resp, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ(unsigned char *num,
+							unsigned char *id,
+							CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_IS_RECEIVER_ID_VALID, 0);
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	internal_opcode_match_or_return();
+	internal_readmsg(1, 1, num);
+	internal_readmsg(2, 1, NULL, -5 * *num, id);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ_blocking(unsigned char
+								 *num,
+								 unsigned char
+								 *id,
+								 CDN_BUS_TYPE
+								 bus_type)
+{
+	internal_block_function(CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ
+				(num, id, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID(unsigned char valid,
+							 CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX,
+				      HDCP_TX_RESPOND_RECEIVER_ID_VALID, 1, 1,
+				      valid);
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID_blocking(unsigned char
+								  valid,
+								  CDN_BUS_TYPE
+								  bus_type)
+{
+	internal_block_function(CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID
+				(valid, bus_type));
+}
+
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC(unsigned char *lc,
+					     CDN_BUS_TYPE bus_type)
+{
+	internal_macro_command_tx(MB_MODULE_ID_HDCP_GENERAL,
+				  HDCP_GENERAL_SET_LC_128, bus_type, 1, -16,
+				  lc);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC_blocking(unsigned char *lc,
+						      CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_HDCP_GENERAL_2_SET_LC(lc, bus_type));
+}
+
+CDN_API_STATUS CDN_API_TEST_KEYS(unsigned char test_type, unsigned char resp[1],
+				 CDN_BUS_TYPE bus_type)
+{
+	if (!state.running) {
+		if (!internal_apb_available())
+			return CDN_BSY;
+		state.bus_type = bus_type;
+		state.rxEnable = 1;
+		internal_tx_mkfullmsg(MB_MODULE_ID_HDCP_TX, HDCP_TX_TEST_KEYS,
+				      1, 1, test_type);
+		return CDN_STARTED;
+	}
+	INTERNAL_PROCESS_MESSAGES;
+	internal_opcode_match_or_return();
+	internal_readmsg(1, -1, resp);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_TEST_KEYS_blocking(unsigned char test_type,
+					  unsigned char resp[1],
+					  CDN_BUS_TYPE bus_type)
+{
+	internal_block_function(CDN_API_TEST_KEYS(test_type, resp, bus_type));
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.h b/drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.h
new file mode 100644
index 0000000..10b13ff
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_HDCP.h
@@ -0,0 +1,239 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_HDCP.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _API_HDCP_H_
+# define _API_HDCP_H_
+
+/**
+ * \addtogroup HDCP_API
+ * \{
+ */
+
+# include "API_General.h"
+# include "hdcp_tran.h"
+
+/**
+ * \brief send HDCP_TX_CONFIGURATION command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION(unsigned char val,
+					     CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_CONFIGURATION
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_CONFIGURATION_blocking(unsigned char val,
+						      CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_SET_PUBLIC_KEY_PARAMS command
+ * \return status
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS(S_HDCP_TRANS_PUBLIC_KEY_PARAMS *val,
+				       CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_PUBLIC_KEY_PARAMS_blocking(S_HDCP_TRANS_PUBLIC_KEY_PARAMS *
+						val, CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_SET_KM_KEY_PARAMS command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS(S_HDCP_TRANS_KM_KEY_PARAMS *
+						  val, CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_KM_KEY_PARAMS_blocking(S_HDCP_TRANS_KM_KEY_PARAMS *val,
+					    CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS command
+ * \return status
+ */
+CDN_API_STATUS
+CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS(S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *
+					  val, CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS
+ */
+CDN_API_STATUS
+    CDN_API_HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS_blocking
+    (S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS *val, CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_RESPOND_KM command
+ * \param val - if NULL no arguments will be send
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM(S_HDCP_TRANS_PAIRING_DATA *val,
+					   CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_RESPOND_KM
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_RESPOND_KM_blocking(S_HDCP_TRANS_PAIRING_DATA *
+						    val, CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP1_TX_SEND_KEYS command
+ * \return status
+ */
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS(S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *val,
+			   CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP1_TX_SEND_KEYS
+ */
+CDN_API_STATUS
+CDN_API_HDCP1_TX_SEND_KEYS_blocking(S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS *
+				    val, CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP1_TX_SEND_RANDOM_AN command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN(unsigned char An[8],
+					       CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP1_TX_SEND_RANDOM_AN
+ */
+CDN_API_STATUS CDN_API_HDCP1_TX_SEND_RANDOM_AN_blocking(unsigned char An[8],
+							CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP_TX_STATUS_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ(unsigned char resp[5],
+					  CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_STATUS_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_STATUS_REQ_blocking(unsigned char resp[5],
+						   CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP2_TX_IS_KM_STORED_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ(unsigned char resp[5],
+						 CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_IS_KM_STORED_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_IS_KM_STORED_REQ_blocking(unsigned char resp[5],
+							  CDN_BUS_TYPE
+							  bus_type);
+
+/**
+ * \brief send HDCP2_TX_STORE_KM_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ(S_HDCP_TRANS_PAIRING_DATA *resp,
+					     CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP2_TX_STORE_KM_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP2_TX_STORE_KM_REQ_blocking(
+							S_HDCP_TRANS_PAIRING_DATA *resp,
+							CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief send HDCP_TX_IS_RECEIVER_ID_VALID_REQ command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ(unsigned char *num,
+							unsigned char *id,
+							CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_IS_RECEIVER_ID_VALID_REQ_blocking(unsigned char
+								 *num, unsigned char
+								 *id,
+								 CDN_BUS_TYPE
+								 bus_type);
+
+/**
+ * \brief send HDCP_TX_RESPOND_RECEIVER_ID_VALID command
+ * \return status
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID(unsigned char valid,
+							 CDN_BUS_TYPE bus_type);
+
+/**
+ * \brief blocking version of #CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID
+ */
+CDN_API_STATUS CDN_API_HDCP_TX_RESPOND_RECEIVER_ID_VALID_blocking(unsigned char
+								  valid,
+								  CDN_BUS_TYPE
+								  bus_type);
+
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC(unsigned char *lc, CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_HDCP_GENERAL_2_SET_LC_blocking(unsigned char *lc, CDN_BUS_TYPE bus_type);
+/* TODO DK: Implement */
+CDN_API_STATUS CDN_API_HDCP_SET_SEED(unsigned char *seed, CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_HDCP_SET_SEED_blocking(unsigned char *seed, CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_TEST_KEYS(unsigned char test_type, unsigned char resp[1],
+				 CDN_BUS_TYPE bus_type);
+CDN_API_STATUS CDN_API_TEST_KEYS_blocking(unsigned char test_type,
+					  unsigned char resp[1],
+					  CDN_BUS_TYPE bus_type);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.c b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.c
new file mode 100644
index 0000000..d80420e
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.c
@@ -0,0 +1,388 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_HDMITX.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_HDMITX.h"
+#include "util.h"
+#include "opcodes.h"
+#include "mhl_hdtx_top.h"
+#include "source_phy.h"
+#include "address.h"
+#include "source_car.h"
+#include "source_vif.h"
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ(HDMITX_TRANS_DATA *data_in,
+				       HDMITX_TRANS_DATA *data_out)
+{
+	internal_macro_command_txrx(MB_MODULE_ID_HDMI_TX, HDMI_TX_READ,
+				    CDN_BUS_TYPE_APB, 3, 1, data_in->slave, 1,
+				    data_in->offset, 2, data_in->len);
+	internal_readmsg(5, 1, &data_out->status, 1, &data_out->slave, 1,
+			 &data_out->offset, 2, &data_out->len, 0,
+			 &data_out->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ_blocking(HDMITX_TRANS_DATA *data_in,
+						HDMITX_TRANS_DATA *data_out)
+{
+	internal_block_function(CDN_API_HDMITX_DDC_READ(data_in, data_out));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE(HDMITX_TRANS_DATA *data_in,
+					HDMITX_TRANS_DATA *data_out)
+{
+	printk("foo: %x\n", data_in->buff[0]);
+	internal_macro_command_txrx(MB_MODULE_ID_HDMI_TX, HDMI_TX_WRITE,
+				    CDN_BUS_TYPE_APB, 4, 1, data_in->slave, 1,
+				    data_in->offset, 2, data_in->len,
+				    -data_in->len, data_in->buff);
+	internal_readmsg(4, 1, &data_out->status, 1, &data_out->slave, 1,
+			 &data_out->offset, 2, &data_out->len);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE_blocking(HDMITX_TRANS_DATA *data_in,
+						 HDMITX_TRANS_DATA *data_out)
+{
+	internal_block_function(CDN_API_HDMITX_DDC_WRITE(data_in, data_out));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ(HDMITX_TRANS_DATA *data_out)
+{
+#ifdef CONFIG_ARCH_FSL_IMX8MQ
+	internal_macro_command_txrx(MB_MODULE_ID_HDMI_TX, HDMI_TX_UPDATE_READ,
+				    CDN_BUS_TYPE_SAPB, 0);
+#else
+	internal_macro_command_txrx(MB_MODULE_ID_HDMI_TX, HDMI_TX_UPDATE_READ,
+				    CDN_BUS_TYPE_APB, 0);
+#endif
+	internal_readmsg(2, 1, &data_out->status, 0, &data_out->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ_blocking(HDMITX_TRANS_DATA *
+						       data_out)
+{
+	internal_block_function(CDN_API_HDMITX_DDC_UPDATE_READ(data_out));
+}
+
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID(unsigned char block,
+					unsigned char segment,
+					HDMITX_TRANS_DATA *data_out)
+{
+	internal_macro_command_txrx(MB_MODULE_ID_HDMI_TX, HDMI_TX_EDID,
+				    CDN_BUS_TYPE_APB, 2, 1, block, 1, segment);
+	internal_readmsg(5, 1, &data_out->status, 1, &data_out->slave, 1,
+			 &data_out->offset, 2, &data_out->len, 0,
+			 &data_out->buff);
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID_blocking(unsigned char block,
+						 unsigned char segment,
+						 HDMITX_TRANS_DATA *data_out)
+{
+	internal_block_function(CDN_API_HDMITX_READ_EDID
+				(block, segment, data_out));
+}
+
+CDN_API_STATUS
+CDN_API_HDMITX_Set_Mode_blocking(HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE protocol,
+				 unsigned int character_rate)
+{
+	CDN_API_STATUS ret;
+	GENERAL_Read_Register_response resp;
+	HDMITX_TRANS_DATA data_in;
+	HDMITX_TRANS_DATA data_out;
+	unsigned char buff = 1;
+
+	/* enable/disable  scrambler; */
+	if (protocol == HDMI_TX_MODE_HDMI_2_0) {
+		if (character_rate >= 340000) {
+			buff = 3;	/* enable scrambling + TMDS_Bit_Clock_Ratio */
+		} else {
+			buff = 1;	/* enable scrambling */
+		}
+	} else {
+		buff = 0;	/* disable scrambling */
+	}
+
+	data_in.buff = &buff;
+	data_in.len = 1;
+	data_in.slave = 0x54;
+	data_in.offset = 0x20;	/* TMDS config */
+	if (protocol == HDMI_TX_MODE_HDMI_2_0)
+		ret = CDN_API_HDMITX_DDC_WRITE_blocking(&data_in, &data_out);
+	ret =
+	    CDN_API_General_Read_Register_blocking(ADDR_SOURCE_MHL_HD +
+						   (HDTX_CONTROLLER << 2),
+						   &resp);
+
+	/* remove data enable */
+	resp.val = resp.val & (~(F_DATA_EN(1)));
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+	if (protocol == HDMI_TX_MODE_HDMI_2_0) {
+		if (character_rate >= 340000) {
+			ret =
+			    CDN_API_General_Write_Register_blocking
+			    (ADDR_SOURCE_MHL_HD + (HDTX_CLOCK_REG_0 << 2),
+			     F_DATA_REGISTER_VAL_0(0x00000));
+			ret =
+			    CDN_API_General_Write_Register_blocking
+			    (ADDR_SOURCE_MHL_HD + (HDTX_CLOCK_REG_1 << 2),
+			     F_DATA_REGISTER_VAL_1(0xFFFFF));
+		}
+	}
+	/* set hdmi mode and preemble mode */
+	resp.val = resp.val & (~(F_HDMI_MODE(3)));
+	resp.val = resp.val & (~(F_HDMI2_PREAMBLE_EN(1)));
+
+	resp.val =
+	    (resp.val) | (F_HDMI_MODE(protocol)) | (F_HDMI2_PREAMBLE_EN(1));
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+
+	/* data enable */
+	resp.val |= F_DATA_EN(1);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+	return ret;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_Init_blocking(void)
+{
+	CDN_API_STATUS ret;
+
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCD_PHY +
+						    (PHY_DATA_SEL << 2),
+						    F_SOURCE_PHY_MHDP_SEL(1));
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_HPD << 2),
+						    F_HPD_VALID_WIDTH(4) |
+						    F_HPD_GLITCH_WIDTH(0));
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    F_HDMI_MODE(1) |
+						    F_AUTO_MODE(0) | F_GCP_EN(1)
+						    | F_DATA_EN(1) |
+						    F_CLEAR_AVMUTE(1) |
+						    F_HDMI2_PREAMBLE_EN(1) |
+						    F_HDMI2_CTRL_IL_MODE(1) |
+						    F_PIC_3D(0XF) |
+						    F_BCH_EN(1));
+	/* open CARS */
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_PHY_CAR << 2), 0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_HDTX_CAR << 2),
+						    0xFF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_PKT_CAR << 2), 0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_AIF_CAR << 2), 0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_CIPHER_CAR << 2),
+						    0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_CRYPTO_CAR << 2),
+						    0xF);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_CAR +
+						    (SOURCE_CEC_CAR << 2), 3);
+
+	/* init vif */
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_VIF +
+						    (HSYNC2VSYNC_POL_CTRL << 2),
+						    F_HPOL(0) | F_VPOL(0));
+	return ret;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(VIC_MODES vicMode, int bpp,
+					      VIC_PXL_ENCODING_FORMAT format)
+{
+	CDN_API_STATUS ret;
+	GENERAL_Read_Register_response resp;
+	unsigned int vsync_lines = vic_table[vicMode][VSYNC];
+	unsigned int eof_lines = vic_table[vicMode][TYPE_EOF];
+	unsigned int sof_lines = vic_table[vicMode][SOF];
+	unsigned int hblank = vic_table[vicMode][H_BLANK];
+	unsigned int hactive = vic_table[vicMode][H_TOTAL] - hblank;
+	unsigned int vblank = vsync_lines + eof_lines + sof_lines;
+	unsigned int vactive = vic_table[vicMode][V_TOTAL] - vblank;
+	unsigned int hfront = vic_table[vicMode][FRONT_PORCH];
+	unsigned int hback = vic_table[vicMode][BACK_PORCH];
+	unsigned int vfront = eof_lines;
+	unsigned int hsync = hblank - hfront - hback;
+	unsigned int vsync = vsync_lines;
+	unsigned int vback = sof_lines;
+	unsigned int v_h_polarity =
+	    ((vic_table[vicMode][HSYNC_POL] ==
+	      ACTIVE_LOW) ? 0 : 1) + ((vic_table[vicMode][VSYNC_POL] ==
+				       ACTIVE_LOW) ? 0 : 2);
+
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (SCHEDULER_H_SIZE << 2),
+						    (hactive << 16) + hblank);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (SCHEDULER_V_SIZE << 2),
+						    (vactive << 16) + vblank);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_SIGNAL_FRONT_WIDTH <<
+						     2),
+						    (vfront << 16) + hfront);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_SIGNAL_SYNC_WIDTH <<
+						     2), (vsync << 16) + hsync);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_SIGNAL_BACK_WIDTH <<
+						     2), (vback << 16) + hback);
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_VIF +
+						    (HSYNC2VSYNC_POL_CTRL << 2),
+						    v_h_polarity);
+
+	/* Reset Data Enable */
+	CDN_API_General_Read_Register_blocking(ADDR_SOURCE_MHL_HD +
+					       (HDTX_CONTROLLER << 2), &resp);
+
+	/* reset data enable */
+	resp.val = resp.val & (~(F_DATA_EN(1)));
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+
+	/* set bpp */
+	resp.val = resp.val & (~(F_VIF_DATA_WIDTH(3)));
+	switch (bpp) {
+	case 8:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(0));
+		break;
+
+	case 10:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(1));
+		break;
+
+	case 12:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(2));
+		break;
+
+	case 16:
+		resp.val = resp.val | (F_VIF_DATA_WIDTH(3));
+		break;
+	}
+
+	/* select color encoding */
+	resp.val = resp.val & (~(F_HDMI_ENCODING(3)));
+	switch (format) {
+	case PXL_RGB:
+
+		resp.val = resp.val | (F_HDMI_ENCODING(0));
+		break;
+
+	case YCBCR_4_4_4:
+		resp.val = resp.val | (F_HDMI_ENCODING(2));
+		break;
+
+	case YCBCR_4_2_2:
+		resp.val = resp.val | (F_HDMI_ENCODING(1));
+		break;
+
+	case YCBCR_4_2_0:
+		resp.val = resp.val | (F_HDMI_ENCODING(3));
+		break;
+	case Y_ONLY:
+		/* not exist in hdmi */
+		break;
+	}
+
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+
+	/* set data enable */
+	resp.val = resp.val | (F_DATA_EN(1));
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						    (HDTX_CONTROLLER << 2),
+						    resp.val);
+	return ret;
+}
+
+CDN_API_STATUS CDN_API_HDMITX_ForceColorDepth_blocking(unsigned char force,
+						       unsigned char val)
+{
+	unsigned int valToWrite =
+	    F_COLOR_DEPTH_VAL(val) | F_COLOR_DEPTH_FORCE(force);
+	CDN_API_General_Write_Register_blocking(ADDR_SOURCE_MHL_HD +
+						(GCP_FORCE_COLOR_DEPTH_CODING <<
+						 2), valToWrite);
+
+	return 0;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.h b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.h
new file mode 100644
index 0000000..b6a4698
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMITX.h
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_HDMITX.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _API_HDMITX_H_
+# define _API_HDMITX_H_
+
+# include "API_General.h"
+# include "hdmi.h"
+# include "vic_table.h"
+
+/**
+ * \addtogroup HDMI_TX_API
+ * \{
+ */
+
+typedef struct {
+    /** if used to return data, this pointer is set (instead of being a destination to copy data to */
+	unsigned char *buff;
+	HDMI_I2C_STATUS status;
+	unsigned short len;
+	unsigned char slave;
+	unsigned char offset;
+} HDMITX_TRANS_DATA;
+
+typedef enum {
+	HDMI_TX_MODE_DVI,
+	HDMI_TX_MODE_HDMI_1_4,
+	HDMI_TX_MODE_HDMI_2_0,
+} HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE;
+
+/**
+ * \brief I2C read transaction
+ * \param [in]  data_in  - fields used: len, slave, offset
+ * \param [out] data_out - fields used: all
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ(HDMITX_TRANS_DATA *data_in,
+				       HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_DDC_READ_blocking(HDMITX_TRANS_DATA *data_in,
+						HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief I2C write transaction
+ * \param [in]  data_in  - fields used: len, slave, offset, buff
+ * \param [out] data_out - fields used: status, len, slave, offset
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE(HDMITX_TRANS_DATA *data_in,
+					HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_DDC_WRITE_blocking(HDMITX_TRANS_DATA *data_in,
+						 HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief I2C update read
+ * \param [out] data_out - fields used: status, buff
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ(HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_DDC_UPDATE_READ_blocking(HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief I2C read edid
+ * \param [in]  block    - EDID block
+ * \pram  [in]  segment  - EDID segment
+ * \param [out] data_out - fields used: status, buff, slave (as block), offset (as segment), len
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID(unsigned char block,
+					unsigned char segment,
+					HDMITX_TRANS_DATA *data_out);
+CDN_API_STATUS CDN_API_HDMITX_READ_EDID_blocking(unsigned char block,
+						 unsigned char segment,
+						 HDMITX_TRANS_DATA *data_out);
+
+/**
+ * \brief set hdmi protocol type (DVI,1.x,2.x) (send scrambler command over scdc and set bits in controller)
+ * \param [in]  protocol    - type
+ * \returns status
+ */
+CDN_API_STATUS
+CDN_API_HDMITX_Set_Mode_blocking(HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE protocol,
+				 unsigned int character_rate);
+
+/**
+ * \brief init hdmi registers
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_Init_blocking(void);
+
+/**
+ * \brief change to vid id vicMode
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_SetVic_blocking(VIC_MODES vicMode, int bpp,
+					      VIC_PXL_ENCODING_FORMAT format);
+
+/**
+ * \brief option to force color depth in the gcp or not force (HW mode)
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMITX_ForceColorDepth_blocking(unsigned char force,
+						       unsigned char val);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.c b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.c
new file mode 100644
index 0000000..ab48ad2
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.c
@@ -0,0 +1,156 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_HDMI_Audio.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_HDMI_Audio.h"
+#include "API_Infoframe.h"
+#include "source_aif_decoder.h"
+#include "source_aif_smpl2pckt.h"
+#include "dptx_stream.h"
+#include "address.h"
+#include "util.h"
+#include "externs.h"
+#include "aif_pckt2smp.h"
+#include "dptx_framer.h"
+#include "clock_meters.h"
+#include "source_car.h"
+#include "API_DPTX.h"
+#include "mhl_hdtx_top.h"
+
+CDN_API_STATUS CDN_API_HDMI_AudioSetInfoFrame(AUDIO_MUTE_MODE mode,
+					      AUDIO_TYPE audioType,
+					      int numOfChannels,
+					      AUDIO_FREQ freq, int lanes,
+					      int ncts)
+{
+	unsigned int packet_type = 0x84;
+	unsigned int packet_version = 0x1;
+	unsigned int packet_len = 0xA;
+	unsigned int packet_HB0 = packet_type;
+	unsigned int packet_HB1 = packet_version;
+	unsigned int packet_HB2 = packet_len;
+	unsigned int packet_PB0 = 0;
+	unsigned int packet_PB1 = numOfChannels - 1;
+	unsigned int packet_PB2 = 0;
+	unsigned int packet_PB3 = 0;
+	unsigned int packet_PB4 = 0;
+	unsigned int packet_PB5 = 0;
+	unsigned int packet_PB6 = 0;
+	unsigned int packet_PB7 = 0;
+	unsigned int packet_PB8 = 0;
+	unsigned int packet_PB9 = 0;
+	unsigned int packet_PB10 = 0;
+	unsigned int packet_PB11 = 0;
+	unsigned int packet_PB12 = 0;
+	unsigned int packet_PB13 = 0;
+	unsigned int packet_PB14 = 0;
+	unsigned int packet_PB15 = 0;
+	unsigned int packet_PB16 = 0;
+	unsigned int packet_PB17 = 0;
+	unsigned int packet_PB18 = 0;
+	unsigned int packet_PB19 = 0;
+	unsigned int packet_PB20 = 0;
+	unsigned int packet_PB21 = 0;
+	unsigned int packet_PB22 = 0;
+	unsigned int packet_PB23 = 0;
+	unsigned int packet_PB24 = 0;
+	unsigned int packet_PB25 = 0;
+	unsigned int packet_PB26 = 0;
+	unsigned int packet_PB27 = 0;
+	unsigned int PB1_13_chksum = 0;
+	unsigned int packet_chksum = 0;
+	unsigned char packet[32];
+
+	if (numOfChannels == 2) {
+		packet_PB4 = 0;
+	} else if (numOfChannels == 8) {
+		packet_PB4 = 0x13;
+	}
+
+	PB1_13_chksum =
+	    (packet_HB0 + packet_HB1 + packet_HB2 + packet_PB1 + packet_PB2 +
+	     packet_PB3 + packet_PB4 + packet_PB5 + packet_PB6 + packet_PB7 +
+	     packet_PB8 + packet_PB9 + packet_PB10);
+	packet_chksum =
+	    256 - (PB1_13_chksum - 256 * ((unsigned int)PB1_13_chksum / 256));
+	packet_PB0 = packet_chksum;
+
+	packet[0] = 0;
+	packet[1] = packet_HB0;
+	packet[2] = packet_HB1;
+	packet[3] = packet_HB2;
+	packet[4] = packet_PB0;
+	packet[5] = packet_PB1;
+	packet[6] = packet_PB2;
+	packet[7] = packet_PB3;
+	packet[8] = packet_PB4;
+	packet[9] = packet_PB5;
+	packet[10] = packet_PB6;
+	packet[11] = packet_PB7;
+	packet[12] = packet_PB8;
+	packet[13] = packet_PB9;
+	packet[14] = packet_PB10;
+	packet[15] = packet_PB11;
+	packet[16] = packet_PB12;
+	packet[17] = packet_PB13;
+	packet[18] = packet_PB14;
+	packet[19] = packet_PB15;
+	packet[20] = packet_PB16;
+	packet[21] = packet_PB17;
+	packet[22] = packet_PB18;
+	packet[23] = packet_PB19;
+	packet[24] = packet_PB20;
+	packet[25] = packet_PB21;
+	packet[26] = packet_PB22;
+	packet[27] = packet_PB23;
+	packet[28] = packet_PB24;
+	packet[29] = packet_PB25;
+	packet[30] = packet_PB26;
+	packet[31] = packet_PB27;
+
+	CDN_API_InfoframeSet(1, 28/4, (unsigned int *)packet, packet_type);
+
+	return CDN_OK;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.h b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.h
new file mode 100644
index 0000000..f1a8b27
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_HDMI_Audio.h
@@ -0,0 +1,66 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_HDMI_Audio.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_HDMI_Audio_H_
+# define API_HDMI_Audio_H_
+
+# include "API_General.h"
+# include "API_Audio.h"
+
+/**
+ * \addtogroup HDMI_TX_API
+ * \{
+ */
+
+ /**
+ * \brief send audio info frame according to parameters
+ * \returns status
+ */
+CDN_API_STATUS CDN_API_HDMI_AudioSetInfoFrame(AUDIO_MUTE_MODE mode,
+					      AUDIO_TYPE audioType,
+					      int numOfChannels,
+					      AUDIO_FREQ freq, int lanes,
+					      int ncts);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.c b/drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.c
new file mode 100644
index 0000000..f2cfbb8
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.c
@@ -0,0 +1,132 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * API_Infoframe.c
+ *
+ ******************************************************************************
+ */
+
+#include "API_Infoframe.h"
+#include "address.h"
+#include "source_pif.h"
+#include "externs.h"
+#include "util.h"
+
+extern void __iomem *g_regs_base;
+#define BANK_OFFSET 0x0
+
+static int avi_apb_write(unsigned int addr, unsigned int value)
+{
+	void *tmp_addr = g_regs_base + addr;
+
+	__raw_writel(value, (volatile unsigned int *)tmp_addr);
+	return 0;
+}
+
+CDN_API_STATUS CDN_API_InfoframeSet(unsigned char entry_id,
+				    unsigned char packet_len,
+				    unsigned int *packet,
+				    unsigned char packet_type)
+{
+	unsigned int idx;
+	/* invalidate entry */
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_REG << 2),
+	     0x20000 | F_PKT_ALLOC_ADDRESS(entry_id)))
+		return CDN_ERR;
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_WR_EN << 2),
+	     F_PKT_ALLOC_WR_EN(1)))
+		return CDN_ERR;
+
+	/* flush fifo 1 */
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_FIFO1_FLUSH << 2),
+	     F_FIFO1_FLUSH(1)))
+		return CDN_ERR;
+
+	/* write packet into memory */
+	for (idx = 0; idx < packet_len; idx++)
+		if (avi_apb_write
+		    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_DATA_WR << 2),
+		     F_DATA_WR(packet[idx])))
+			return CDN_ERR;
+
+	/* write entry id */
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_WR_ADDR << 2),
+	     F_WR_ADDR(entry_id)))
+		return CDN_ERR;
+
+	/* write request */
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_WR_REQ << 2),
+	     F_HOST_WR(1)))
+		return CDN_ERR;
+
+	/* update entry */
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_REG << 2),
+	     0x20000 | F_TYPE_VALID(1) | F_PACKET_TYPE(packet_type) |
+	     F_PKT_ALLOC_ADDRESS(entry_id)))
+		return CDN_ERR;
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_WR_EN << 2),
+	     F_PKT_ALLOC_WR_EN(1)))
+		return CDN_ERR;
+
+	return CDN_OK;
+}
+
+CDN_API_STATUS CDN_API_InfoframeRemove(unsigned char entry_id)
+{
+	/* invalidate entry */
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_REG << 2),
+	     0x20000 | F_PKT_ALLOC_ADDRESS(entry_id)))
+		return CDN_ERR;
+	if (avi_apb_write
+	    (BANK_OFFSET | ADDR_SOURCE_PIF | (SOURCE_PIF_PKT_ALLOC_WR_EN << 2),
+	     F_PKT_ALLOC_WR_EN(1)))
+		return CDN_ERR;
+
+	return CDN_OK;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.h b/drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.h
new file mode 100644
index 0000000..2ddd0cd
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/API_Infoframe.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * API_Infoframe.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef API_INFOFRAME_H
+# define API_INFOFRAME_H
+
+/**
+ * \addtogroup INFO_FRAME_API
+ * \{
+ */
+
+# include "API_General.h"
+
+CDN_API_STATUS CDN_API_InfoframeSet(unsigned char entry_id,
+				    unsigned char packet_len,
+				    unsigned int *packet,
+				    unsigned char packet_type);
+CDN_API_STATUS CDN_API_InfoframeRemove(unsigned char entry_id);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/Makefile b/drivers/video/fbdev/mxc/cdn_hdp/Makefile
new file mode 100644
index 0000000..26e6bb2
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/Makefile
@@ -0,0 +1,14 @@
+obj-$(CONFIG_FB_MX8_HDMI) += \
+	API_Audio.o \
+	API_AVI.o \
+	API_AFE.o \
+	API_AFE_t28hpc_hdmitx.o \
+	API_General.o \
+	API_HDCP.o \
+	API_HDMI_Audio.o \
+	API_HDMITX.o \
+	API_Infoframe.o \
+	edid_parser.o \
+	test_base_sw.o \
+	util.o \
+	vic_table.o
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/address.h b/drivers/video/fbdev/mxc/cdn_hdp/address.h
new file mode 100644
index 0000000..509e7b1
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/address.h
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * address.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef ADDRESS_H_
+# define ADDRESS_H_
+
+# define ADDR_IMEM 0x10000
+# define ADDR_DMEM 0x20000
+# define ADDR_CIPHER 0x60000
+# define BASE_CIPHER 0x600
+# define ADDR_APB_CFG 0x00000
+# define BASE_APB_CFG 0x000
+# define ADDR_SOURCE_AIF_DECODER 0x30000
+# define BASE_SOURCE_AIF_DECODER 0x300
+# define ADDR_SOURCE_AIF_SMPL2PCKT 0x30080
+# define BASE_SOURCE_AIF_SMPL2PCKT 0x300
+# define ADDR_AIF_ENCODER 0x30000
+# define BASE_AIF_ENCODER 0x300
+# define ADDR_SOURCE_PIF 0x30800
+# define BASE_SOURCE_PIF 0x308
+# define ADDR_SINK_PIF 0x30800
+# define BASE_SINK_PIF 0x308
+# define ADDR_APB_CFG 0x00000
+# define BASE_APB_CFG 0x000
+# define ADDR_SOURCE_CSC 0x40000
+# define BASE_SOURCE_CSC 0x400
+# define ADDR_UCPU_CFG 0x00000
+# define BASE_UCPU_CFG 0x000
+# define ADDR_SOURCE_CAR 0x00900
+# define BASE_SOURCE_CAR 0x009
+# define ADDR_SINK_CAR 0x00900
+# define BASE_SINK_CAR 0x009
+# define ADDR_CLOCK_METERS 0x00A00
+# define BASE_CLOCK_METERS 0x00A
+# define ADDR_SOURCE_VIF 0x00b00
+# define BASE_SOURCE_VIF 0x00b
+# define ADDR_SINK_MHL_HD 0x01000
+# define BASE_SINK_MHL_HD 0x010
+# define ADDR_SINK_CORE 0x07800
+# define BASE_SINK_CORE 0x078
+# define ADDR_DPTX_PHY 0x02000
+# define BASE_DPTX_PHY 0x020
+# define ADDR_DPTX_HPD 0x02100
+# define BASE_DPTX_HPD 0x021
+# define ADDR_DPTX_FRAMER 0x02200
+# define BASE_DPTX_FRAMER 0x022
+# define ADDR_DPTX_STREAM 0x02200
+# define BASE_DPTX_STREAM 0x022
+# define ADDR_DPTX_GLBL 0x02300
+# define BASE_DPTX_GLBL 0x023
+# define ADDR_DPTX_HDCP 0x02400
+# define BASE_DPTX_HDCP 0x024
+# define ADDR_DP_AUX 0x02800
+# define BASE_DP_AUX 0x028
+# define ADDR_CRYPTO 0x05800
+# define BASE_CRYPTO 0x058
+# define ADDR_CIPHER 0x60000
+# define BASE_CIPHER 0x600
+# define ADDR_SOURCE_MHL_HD 0x01000
+
+# define ADDR_AFE  (0x20000 * 4)
+# define ADDR_SOURCD_PHY  (0x800)
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/aif_pckt2smp.h b/drivers/video/fbdev/mxc/cdn_hdp/aif_pckt2smp.h
new file mode 100644
index 0000000..fc1b270
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/aif_pckt2smp.h
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * aif_pckt2smp.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef AIF_PCKT2SMP_H_
+# define AIF_PCKT2SMP_H_
+
+/* register PKT2SMPL_CNTL */
+# define PKT2SMPL_CNTL 0
+# define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_PKT2SMPL_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_PKT2SMPL_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_NUM_OF_I2S_PORTS(x) (((x) & ((1 << 2) - 1)) << 2)
+# define F_NUM_OF_I2S_PORTS_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+# define F_AIF_ERR_MASK(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_AIF_ERR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_AIF_OVERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_AIF_OVERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_AIF_UNDERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_AIF_UNDERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_CFG_FORCE_SP(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_CFG_FORCE_SP_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register ACR_CFG */
+# define ACR_CFG 1
+# define F_ACR_STOP_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_ACR_STOP_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_ACR_FIFO_STATUS_DIS(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_ACR_FIFO_STATUS_DIS_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_ACR_DIS_USE_NEDGE(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_ACR_DIS_USE_NEDGE_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_ACR_MASTER_CLK_FX_MODE(x) (((x) & ((1 << 2) - 1)) << 3)
+# define F_ACR_MASTER_CLK_FX_MODE_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+# define F_ACR_SW_RESET(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_ACR_SW_RESET_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SPDIF_CFG */
+# define SPDIF_CFG 2
+# define F_SPDIF_SELECTED(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SPDIF_SELECTED_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register AUDIO_FIFO_PTR_CFG0 */
+# define AUDIO_FIFO_PTR_CFG0 3
+# define F_AUDIO_FIFO_PTR_EMPTY_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_AUDIO_FIFO_PTR_EMPTY_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_AUDIO_FIFO_PTR_EMPTY_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+# define F_AUDIO_FIFO_PTR_EMPTY_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+# define F_AUDIO_FIFO_PTR_LOW_LOW(x) (((x) & ((1 << 9) - 1)) << 18)
+# define F_AUDIO_FIFO_PTR_LOW_LOW_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG1 */
+# define AUDIO_FIFO_PTR_CFG1 4
+# define F_AUDIO_FIFO_PTR_LOW_HIGH(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_AUDIO_FIFO_PTR_LOW_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_AUDIO_FIFO_PTR_BELOW_LOW(x) (((x) & ((1 << 9) - 1)) << 9)
+# define F_AUDIO_FIFO_PTR_BELOW_LOW_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+# define F_AUDIO_FIFO_PTR_BELOW_HIGH(x) (((x) & ((1 << 9) - 1)) << 18)
+# define F_AUDIO_FIFO_PTR_BELOW_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG2 */
+# define AUDIO_FIFO_PTR_CFG2 5
+# define F_AUDIO_FIFO_PTR_NOMINAL_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_AUDIO_FIFO_PTR_NOMINAL_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_AUDIO_FIFO_PTR_NOMINAL_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+# define F_AUDIO_FIFO_PTR_NOMINAL_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+# define F_AUDIO_FIFO_PTR_ABOVE_LOW(x) (((x) & ((1 << 9) - 1)) << 18)
+# define F_AUDIO_FIFO_PTR_ABOVE_LOW_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG3 */
+# define AUDIO_FIFO_PTR_CFG3 6
+# define F_AUDIO_FIFO_PTR_ABOVE_HIGH(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_AUDIO_FIFO_PTR_ABOVE_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_AUDIO_FIFO_PTR_HIGH_LOW(x) (((x) & ((1 << 9) - 1)) << 9)
+# define F_AUDIO_FIFO_PTR_HIGH_LOW_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+# define F_AUDIO_FIFO_PTR_HIGH_HIGH(x) (((x) & ((1 << 9) - 1)) << 18)
+# define F_AUDIO_FIFO_PTR_HIGH_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 18)) >> 18)
+
+/* register AUDIO_FIFO_PTR_CFG4 */
+# define AUDIO_FIFO_PTR_CFG4 7
+# define F_AUDIO_FIFO_PTR_FULL_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_AUDIO_FIFO_PTR_FULL_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_AUDIO_FIFO_PTR_FULL_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+# define F_AUDIO_FIFO_PTR_FULL_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+
+/* register AUDIO_FIFO_PTR_CFG5 */
+# define AUDIO_FIFO_PTR_CFG5 8
+# define F_AUDIO_FIFO_PTR_IDLE_LOW(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_AUDIO_FIFO_PTR_IDLE_LOW_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_AUDIO_FIFO_PTR_IDLE_HIGH(x) (((x) & ((1 << 9) - 1)) << 9)
+# define F_AUDIO_FIFO_PTR_IDLE_HIGH_RD(x) (((x) & (((1 << 9) - 1) << 9)) >> 9)
+
+/* register AIF_INT_STTS */
+# define AIF_INT_STTS 9
+# define F_AIF_ERR_STATUS(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_AIF_ERR_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_AIF_OVERFLOW_STATUS(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_AIF_OVERFLOW_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_AIF_UNDERFLOW_STATUS(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_AIF_UNDERFLOW_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+
+/* register AIF_ACR_N_ST */
+# define AIF_ACR_N_ST 10
+# define F_ACR_N(x) (((x) & ((1 << 20) - 1)) << 0)
+# define F_ACR_N_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register AIF_ACR_CTS_ST */
+# define AIF_ACR_CTS_ST 11
+# define F_ACR_CTS(x) (((x) & ((1 << 20) - 1)) << 0)
+# define F_ACR_CTS_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register AIF_ACR_N_OFST_CFG */
+# define AIF_ACR_N_OFST_CFG 12
+# define F_ACR_N_OFFSET(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_ACR_N_OFFSET_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register AIF_ACR_CTS_OFST_CFG */
+# define AIF_ACR_CTS_OFST_CFG 13
+# define F_ACR_CTS_OFFSET(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_ACR_CTS_OFFSET_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/apb_cfg.h b/drivers/video/fbdev/mxc/cdn_hdp/apb_cfg.h
new file mode 100644
index 0000000..0e86330
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/apb_cfg.h
@@ -0,0 +1,185 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * apb_cfg.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef APB_CFG_H_
+# define APB_CFG_H_
+
+/* register APB_CTRL */
+# define APB_CTRL 0
+# define F_APB_XT_RESET(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_APB_XT_RESET_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_APB_DRAM_PATH(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_APB_DRAM_PATH_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_APB_IRAM_PATH(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_APB_IRAM_PATH_RD(x) (((x) & (((1 << 1) 1) << 2)) >> 2)
+
+/* register XT_INT_CTRL */
+# define XT_INT_CTRL 1
+# define F_XT_INT_POLARITY(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_XT_INT_POLARITY_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+
+/* register MAILBOX_FULL_ADDR */
+# define MAILBOX_FULL_ADDR 2
+# define F_MAILBOX_FULL(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_MAILBOX_FULL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register MAILBOX_EMPTY_ADDR */
+# define MAILBOX_EMPTY_ADDR 3
+# define F_MAILBOX_EMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_MAILBOX_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register MAILBOX0_WR_DATA */
+# define MAILBOX0_WR_DATA 4
+# define F_MAILBOX0_WR_DATA(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_MAILBOX0_WR_DATA_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register MAILBOX0_RD_DATA */
+# define MAILBOX0_RD_DATA 5
+# define F_MAILBOX0_RD_DATA(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_MAILBOX0_RD_DATA_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register KEEP_ALIVE */
+# define KEEP_ALIVE 6
+# define F_KEEP_ALIVE_CNT(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_KEEP_ALIVE_CNT_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_L */
+# define VER_L 7
+# define F_VER_LSB(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_VER_LSB_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_H */
+# define VER_H 8
+# define F_VER_MSB(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_VER_MSB_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_LIB_L_ADDR */
+# define VER_LIB_L_ADDR 9
+# define F_SW_LIB_VER_L(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_LIB_VER_L_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register VER_LIB_H_ADDR */
+# define VER_LIB_H_ADDR 10
+# define F_SW_LIB_VER_H(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_LIB_VER_H_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_DEBUG_L */
+# define SW_DEBUG_L 11
+# define F_SW_DEBUG_7_0(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_DEBUG_7_0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_DEBUG_H */
+# define SW_DEBUG_H 12
+# define F_SW_DEBUG_15_8(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_DEBUG_15_8_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register MAILBOX_INT_MASK */
+# define MAILBOX_INT_MASK 13
+# define F_MAILBOX_INT_MASK(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_MAILBOX_INT_MASK_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+
+/* register MAILBOX_INT_STATUS */
+# define MAILBOX_INT_STATUS 14
+# define F_MAILBOX_INT_STATUS(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_MAILBOX_INT_STATUS_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+
+/* register SW_CLK_L */
+# define SW_CLK_L 15
+# define F_SW_CLOCK_VAL_L(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_CLOCK_VAL_L_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_CLK_H */
+# define SW_CLK_H 16
+# define F_SW_CLOCK_VAL_H(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_CLOCK_VAL_H_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS0 */
+# define SW_EVENTS0 17
+# define F_SW_EVENTS7_0(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_EVENTS7_0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS1 */
+# define SW_EVENTS1 18
+# define F_SW_EVENTS15_8(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_EVENTS15_8_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS2 */
+# define SW_EVENTS2 19
+# define F_SW_EVENTS23_16(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_EVENTS23_16_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register SW_EVENTS3 */
+# define SW_EVENTS3 20
+# define F_SW_EVENTS31_24(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SW_EVENTS31_24_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register XT_OCD_CTRL */
+# define XT_OCD_CTRL 24
+# define F_XT_DRESET(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_XT_DRESET_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_XT_OCDHALTONRESET(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_XT_OCDHALTONRESET_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register XT_OCD_CTRL_RO */
+# define XT_OCD_CTRL_RO 25
+# define F_XT_XOCDMODE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_XT_XOCDMODE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register APB_INT_MASK */
+# define APB_INT_MASK 27
+# define F_APB_INTR_MASK(x) (((x) & ((1 << 3) - 1)) << 0)
+# define F_APB_INTR_MASK_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+
+/* register APB_STATUS_MASK */
+# define APB_STATUS_MASK 28
+# define F_APB_INTR_STATUS(x) (((x) & ((1 << 3) - 1)) << 0)
+# define F_APB_INTR_STATUS_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/clock_meters.h b/drivers/video/fbdev/mxc/cdn_hdp/clock_meters.h
new file mode 100644
index 0000000..5c5c34f
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/clock_meters.h
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * clock_meters.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef CLOCK_METERS_H_
+# define CLOCK_METERS_H_
+
+/* register CM_CTRL */
+# define CM_CTRL 0
+# define F_NMVID_SEL_EXTERNAL(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_NMVID_SEL_EXTERNAL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SPDIF_SEL_EXTERNAL(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SPDIF_SEL_EXTERNAL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_I2S_SEL_EXTERNAL(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_I2S_SEL_EXTERNAL_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_SEL_AUD_LANE_REF(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_SEL_AUD_LANE_REF_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_I2S_MULT(x) (((x) & ((1 << 3) - 1)) << 4)
+# define F_I2S_MULT_RD(x) (((x) & (((1 << 3) - 1) << 4)) >> 4)
+
+/* register CM_I2S_CTRL */
+# define CM_I2S_CTRL 1
+# define F_I2S_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_I2S_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+# define F_I2S_MEAS_TOLERANCE(x) (((x) & ((1 << 4) - 1)) << 24)
+# define F_I2S_MEAS_TOLERANCE_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CM_SPDIF_CTRL */
+# define CM_SPDIF_CTRL 2
+# define F_SPDIF_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_SPDIF_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+# define F_SPDIF_MEAS_TOLERANCE(x) (((x) & ((1 << 4) - 1)) << 24)
+# define F_SPDIF_MEAS_TOLERANCE_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CM_VID_CTRL */
+# define CM_VID_CTRL 3
+# define F_NMVID_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_NMVID_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+# define F_NMVID_MEAS_TOLERANCE(x) (((x) & ((1 << 4) - 1)) << 24)
+# define F_NMVID_MEAS_TOLERANCE_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register CM_LANE_CTRL */
+# define CM_LANE_CTRL 4
+# define F_LANE_REF_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_LANE_REF_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register I2S_NM_STABLE */
+# define I2S_NM_STABLE 5
+# define F_I2S_MNAUD_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_I2S_MNAUD_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register I2S_NCTS_STABLE */
+# define I2S_NCTS_STABLE 6
+# define F_I2S_NCTS_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_I2S_NCTS_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SPDIF_NM_STABLE */
+# define SPDIF_NM_STABLE 7
+# define F_SPDIF_MNAUD_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SPDIF_MNAUD_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SPDIF_NCTS_STABLE */
+# define SPDIF_NCTS_STABLE 8
+# define F_SPDIF_NCTS_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SPDIF_NCTS_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register NMVID_MEAS_STABLE */
+# define NMVID_MEAS_STABLE 9
+# define F_ST_NMVID_MEAS_STABLE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_ST_NMVID_MEAS_STABLE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register CM_VID_MEAS */
+# define CM_VID_MEAS 10
+# define F_NMVID_MEAS_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_NMVID_MEAS_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+# define F_NMVID_MEAS_VALID_INDC(x) (((x) & ((1 << 1) - 1)) << 24)
+# define F_NMVID_MEAS_VALID_INDC_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register CM_AUD_MEAS */
+# define CM_AUD_MEAS 11
+# define F_NMAUD_MEAS_CYC(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_NMAUD_MEAS_CYC_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+# define F_NMAUD_MEAS_VALID_INDC(x) (((x) & ((1 << 1) - 1)) << 24)
+# define F_NMAUD_MEAS_VALID_INDC_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register I2S_MEAS */
+# define I2S_MEAS 16
+# define F_I2_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_I2_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register I2S_DP_MEAS */
+# define I2S_DP_MEAS 17
+# define F_I2_DP_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_I2_DP_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register SPDIF_DP_MEAS */
+# define SPDIF_DP_MEAS 32
+# define F_SPDIF_DP_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_SPDIF_DP_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register SPDIF_MEAS */
+# define SPDIF_MEAS 33
+# define F_SPDIF_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_SPDIF_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+/* register NMVID_MEAS */
+# define NMVID_MEAS 48
+# define F_NMVID_MEAS(x) (((x) & ((1 << 24) - 1)) << 0)
+# define F_NMVID_MEAS_RD(x) (((x) & (((1 << 24) - 1) << 0)) >> 0)
+
+#endif //CLOCK_METERS
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/defs.h b/drivers/video/fbdev/mxc/cdn_hdp/defs.h
new file mode 100644
index 0000000..c390ebf
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/defs.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * defs.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _DEFS_H_
+# define _DEFS_H_
+
+typedef enum {
+	CDN_DPTX,
+	CDN_HDMITX_TYPHOON,
+	CDN_HDMITX_KIRAN,
+} CDN_PROTOCOL_TYPE;
+
+#endif //_DEFS_H_
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/dptx_framer.h b/drivers/video/fbdev/mxc/cdn_hdp/dptx_framer.h
new file mode 100644
index 0000000..27fe352
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/dptx_framer.h
@@ -0,0 +1,372 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * dptx_framer.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef DPTX_FRAMER_H_
+# define DPTX_FRAMER_H_
+
+/* register DP_FRAMER_GLOBAL_CONFIG */
+# define DP_FRAMER_GLOBAL_CONFIG 0
+# define F_NUM_LANES(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_NUM_LANES_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+# define F_MST_SST(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_MST_SST_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_GLOBAL_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_GLOBAL_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_RG_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_RG_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_NO_VIDEO(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_NO_VIDEO_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_ENC_RST_DIS(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_ENC_RST_DIS_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_WR_VHSYNC_FALL(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_WR_VHSYNC_FALL_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register DP_SW_RESET */
+# define DP_SW_RESET 1
+# define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register DP_FRAMER_TU */
+# define DP_FRAMER_TU 2
+# define F_TU_VALID_SYMBOLS(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_TU_VALID_SYMBOLS_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_TU_SIZE(x) (((x) & ((1 << 7) - 1)) << 8)
+# define F_TU_SIZE_RD(x) (((x) & (((1 << 7) - 1) << 8)) >> 8)
+# define F_TU_CNT_RST_EN(x) (((x) & ((1 << 1) - 1)) << 15)
+# define F_TU_CNT_RST_EN_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+# define F_BS_SR_REPLACE_POSITION(x) (((x) & ((1 << 9) - 1)) << 16)
+# define F_BS_SR_REPLACE_POSITION_RD(x) (((x) & (((1 << 9) - 1) << 16)) >> 16)
+
+/* register DP_FRAMER_PXL_REPR */
+# define DP_FRAMER_PXL_REPR 3
+# define F_COLOR_DEPTH(x) (((x) & ((1 << 5) - 1)) << 0)
+# define F_COLOR_DEPTH_RD(x) (((x) & (((1 << 5) - 1) << 0)) >> 0)
+# define F_PXL_ENC_FORMAT(x) (((x) & ((1 << 5) - 1)) << 8)
+# define F_PXL_ENC_FORMAT_RD(x) (((x) & (((1 << 5) - 1) << 8)) >> 8)
+
+/* register DP_FRAMER_SP */
+# define DP_FRAMER_SP 4
+# define F_VSP(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_VSP_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_HSP(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_HSP_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_INTERLACE_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_INTERLACE_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_FRAMER_3D_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_FRAMER_3D_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_STACKED_3D_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_STACKED_3D_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+
+/* register AUDIO_PACK_CONTROL */
+# define AUDIO_PACK_CONTROL 5
+# define F_MST_SDP_ID(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_MST_SDP_ID_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_AUDIO_PACK_EN(x) (((x) & ((1 << 1) - 1)) << 8)
+# define F_AUDIO_PACK_EN_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+# define F_MONO(x) (((x) & ((1 << 1) - 1)) << 9)
+# define F_MONO_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register DP_VC_TABLE_0 */
+# define DP_VC_TABLE_0 6
+# define F_VC_TABLE_0(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_0_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_1(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_1_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_2(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_2_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_3(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_3_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_1 */
+# define DP_VC_TABLE_1 7
+# define F_VC_TABLE_4(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_4_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_5(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_5_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_6(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_6_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_7(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_7_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_2 */
+# define DP_VC_TABLE_2 8
+# define F_VC_TABLE_8(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_8_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_9(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_9_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_10(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_10_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_11(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_11_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_3 */
+# define DP_VC_TABLE_3 9
+# define F_VC_TABLE_12(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_12_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_13(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_13_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_14(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_14_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_15(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_15_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_4 */
+# define DP_VC_TABLE_4 10
+# define F_VC_TABLE_16(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_16_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_17(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_17_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_18(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_18_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_19(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_19_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_5 */
+# define DP_VC_TABLE_5 11
+# define F_VC_TABLE_20(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_20_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_21(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_21_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_22(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_22_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_23(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_23_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_6 */
+# define DP_VC_TABLE_6 12
+# define F_VC_TABLE_24(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_24_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_25(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_25_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_26(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_26_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_27(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_27_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_7 */
+# define DP_VC_TABLE_7 13
+# define F_VC_TABLE_28(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_28_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_29(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_29_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_30(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_30_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_31(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_31_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_8 */
+# define DP_VC_TABLE_8 14
+# define F_VC_TABLE_32(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_32_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_33(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_33_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_34(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_34_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_35(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_35_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_9 */
+# define DP_VC_TABLE_9 15
+# define F_VC_TABLE_36(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_VC_TABLE_36_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_VC_TABLE_37(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_37_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_38(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_38_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_39(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_39_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_10 */
+# define DP_VC_TABLE_10 16
+# define F_VC_TABLE_40(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_40_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_41(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_41_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_42(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_42_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_43(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_43_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_11 */
+# define DP_VC_TABLE_11 17
+# define F_VC_TABLE_44(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_44_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_45(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_45_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_46(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_46_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_47(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_47_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_12 */
+# define DP_VC_TABLE_12 18
+# define F_VC_TABLE_48(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_48_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_49(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_49_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_50(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_50_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_51(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_51_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_13 */
+# define DP_VC_TABLE_13 19
+# define F_VC_TABLE_52(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_52_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_53(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_53_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_54(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_54_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_55(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_55_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VC_TABLE_14 */
+# define DP_VC_TABLE_14 20
+# define F_VC_TABLE_56(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_VC_TABLE_56_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_57(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_57_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_58(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_58_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_59(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_59_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register LINE_THRESH */
+# define LINE_THRESH 21
+# define F_CFG_ACTIVE_LINE_TRESH(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_CFG_ACTIVE_LINE_TRESH_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_VC_TABLE_61(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_VC_TABLE_61_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+# define F_VC_TABLE_62(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_VC_TABLE_62_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_VC_TABLE_63(x) (((x) & ((1 << 6) - 1)) << 24)
+# define F_VC_TABLE_63_RD(x) (((x) & (((1 << 6) - 1) << 24)) >> 24)
+
+/* register DP_VB_ID */
+# define DP_VB_ID 22
+# define F_VB_ID(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_VB_ID_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+
+/* register DP_MTPH_LVP_CONTROL */
+# define DP_MTPH_LVP_CONTROL 23
+# define F_MTPH_LVP_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_MTPH_LVP_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register DP_MTPH_SYMBOL_VALUES */
+# define DP_MTPH_SYMBOL_VALUES 24
+# define F_MPTH_LVP_SYM(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_MPTH_LVP_SYM_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_MTPH_ECF_SYM(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_MTPH_ECF_SYM_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_MTPH_MTPH_SYM(x) (((x) & ((1 << 8) - 1)) << 16)
+# define F_MTPH_MTPH_SYM_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+
+/* register DP_MTPH_ECF_CONTROL */
+# define DP_MTPH_ECF_CONTROL 25
+# define F_MPTH_ECF_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_MPTH_ECF_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_MTPH_ACT_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_MTPH_ACT_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register DP_FIELDSEQ_3D */
+# define DP_FIELDSEQ_3D 26
+# define F_FIELD_SEQ_START(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_FIELD_SEQ_START_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_FIELD_SEQ_END(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_FIELD_SEQ_END_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_MTPH_STATUS */
+# define DP_MTPH_STATUS 27
+# define F_MTP_ACT_CNT_CTRL_CURR_STATE(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_MTP_ACT_CNT_CTRL_CURR_STATE_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_MTP_ECF_CNT_CTRL_CURR_STATE(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_MTP_ECF_CNT_CTRL_CURR_STATE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_MTPH_ACT_STATUS(x) (((x) & ((1 << 1) - 1)) << 16)
+# define F_MTPH_ACT_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+# define F_MTPH_ECF_STATUS(x) (((x) & ((1 << 1) - 1)) << 17)
+# define F_MTPH_ECF_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+# define F_MTPH_LVP_STATUS(x) (((x) & ((1 << 1) - 1)) << 18)
+# define F_MTPH_LVP_STATUS_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+
+/* register DP_INTERRUPT_SOURCE */
+# define DP_INTERRUPT_SOURCE 28
+# define F_PSLVERR(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_PSLVERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_MTPH_ACT_EN_CLEAR(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_MTPH_ACT_EN_CLEAR_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_MTPH_LVP_EN_CLEAR(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_MTPH_LVP_EN_CLEAR_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_MTPH_ECF_EN_CLEAR(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_MTPH_ECF_EN_CLEAR_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register DP_INTERRUPT_MASK */
+# define DP_INTERRUPT_MASK 29
+# define F_PSLVERR_MASK(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_PSLVERR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_MTPH_ACT_EN_CLEAR_MASK(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_MTPH_ACT_EN_CLEAR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_MTPH_LVP_EN_CLEAR_MASK(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_MTPH_LVP_EN_CLEAR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_MTPH_ECF_EN_CLEAR_MASK(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_MTPH_ECF_EN_CLEAR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register DP_FRONT_BACK_PORCH */
+# define DP_FRONT_BACK_PORCH 30
+# define F_BACK_PORCH(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_BACK_PORCH_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_FRONT_PORCH(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_FRONT_PORCH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_BYTE_COUNT */
+# define DP_BYTE_COUNT 31
+# define F_BYTE_COUNT(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_BYTE_COUNT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+#endif //DPTX_FRAMER
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/dptx_stream.h b/drivers/video/fbdev/mxc/cdn_hdp/dptx_stream.h
new file mode 100644
index 0000000..78a7e81
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/dptx_stream.h
@@ -0,0 +1,206 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * dptx_stream.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef DPTX_STREAM_H_
+# define DPTX_STREAM_H_
+
+/* register MSA_HORIZONTAL_0 */
+# define MSA_HORIZONTAL_0 32
+# define F_PCK_STUFF_HTOTAL(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_PCK_STUFF_HTOTAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_PCK_STUFF_HSTART(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_PCK_STUFF_HSTART_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_HORIZONTAL_1 */
+# define MSA_HORIZONTAL_1 33
+# define F_PCK_STUFF_HSYNCWIDTH(x) (((x) & ((1 << 15) - 1)) << 0)
+# define F_PCK_STUFF_HSYNCWIDTH_RD(x) (((x) & (((1 << 15) - 1) << 0)) >> 0)
+# define F_PCK_STUFF_HSYNCPOLARITY(x) (((x) & ((1 << 1) - 1)) << 15)
+# define F_PCK_STUFF_HSYNCPOLARITY_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+# define F_PCK_STUFF_HWIDTH(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_PCK_STUFF_HWIDTH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_VERTICAL_0 */
+# define MSA_VERTICAL_0 34
+# define F_PCK_STUFF_VTOTAL(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_PCK_STUFF_VTOTAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_PCK_STUFF_VSTART(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_PCK_STUFF_VSTART_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_VERTICAL_1 */
+# define MSA_VERTICAL_1 35
+# define F_PCK_STUFF_VSYNCWIDTH(x) (((x) & ((1 << 15) - 1)) << 0)
+# define F_PCK_STUFF_VSYNCWIDTH_RD(x) (((x) & (((1 << 15) - 1) << 0)) >> 0)
+# define F_PCK_STUFF_VSYNCPOLARITY(x) (((x) & ((1 << 1) - 1)) << 15)
+# define F_PCK_STUFF_VSYNCPOLARITY_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+# define F_PCK_STUFF_VHEIGHT(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_PCK_STUFF_VHEIGHT_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register MSA_MISC */
+# define MSA_MISC 36
+# define F_MSA_MISC0(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_MSA_MISC0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_MSA_MISC1(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_MSA_MISC1_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_MSA_MISC1_INV(x) (((x) & ((1 << 1) - 1)) << 16)
+# define F_MSA_MISC1_INV_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+# define F_MSA_IN_MID_INTERLACE_EN(x) (((x) & ((1 << 1) - 1)) << 17)
+# define F_MSA_IN_MID_INTERLACE_EN_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+
+/* register STREAM_CONFIG */
+# define STREAM_CONFIG 37
+# define F_STREAM_NUM(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_STREAM_NUM_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+
+/* register AUDIO_PACK_STATUS */
+# define AUDIO_PACK_STATUS 38
+# define F_AP_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_AP_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_AP_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_AP_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_AP_AIF_FSM_CURR_ST(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_AP_AIF_FSM_CURR_ST_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_AP_SDP_TRANSFER_FSM_CURR_ST(x) (((x) & ((1 << 3) - 1)) << 3)
+# define F_AP_SDP_TRANSFER_FSM_CURR_ST_RD(x) (((x) & (((1 << 3) - 1) << 3)) >> 3)
+# define F_AP_FIFO_RD_FSM_CURR_ST(x) (((x) & ((1 << 2) - 1)) << 6)
+# define F_AP_FIFO_RD_FSM_CURR_ST_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+# define F_AP_FIFO_WR_FSM_CURR_ST(x) (((x) & ((1 << 2) - 1)) << 8)
+# define F_AP_FIFO_WR_FSM_CURR_ST_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+# define F_AP_PARITY_FSM_CURRENT_STATE(x) (((x) & ((1 << 3) - 1)) << 10)
+# define F_AP_PARITY_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 3) - 1) << 10)) >> 10)
+# define F_AUDIO_TS_VERSION(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_AUDIO_TS_VERSION_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+
+/* register VIF_STATUS */
+# define VIF_STATUS 39
+# define F_VIF_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_VIF_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_VIF_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_VIF_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_VIF_WR_CTRL_STATE(x) (((x) & ((1 << 6) - 1)) << 2)
+# define F_VIF_WR_CTRL_STATE_RD(x) (((x) & (((1 << 6) - 1) << 2)) >> 2)
+# define F_VIF_RD_CTRL_STATE(x) (((x) & ((1 << 20) - 1)) << 8)
+# define F_VIF_RD_CTRL_STATE_RD(x) (((x) & (((1 << 20) - 1) << 8)) >> 8)
+
+/* register PCK_STUFF_STATUS_0 */
+# define PCK_STUFF_STATUS_0 40
+# define F_NO_VIDEO_GEN_STATE(x) (((x) & ((1 << 5) - 1)) << 0)
+# define F_NO_VIDEO_GEN_STATE_RD(x) (((x) & (((1 << 5) - 1) << 0)) >> 0)
+# define F_SST_VIDEO_GEN_STATE(x) (((x) & ((1 << 7) - 1)) << 8)
+# define F_SST_VIDEO_GEN_STATE_RD(x) (((x) & (((1 << 7) - 1) << 8)) >> 8)
+# define F_MST_VIDEO_GEN_STATE(x) (((x) & ((1 << 6) - 1)) << 16)
+# define F_MST_VIDEO_GEN_STATE_RD(x) (((x) & (((1 << 6) - 1) << 16)) >> 16)
+# define F_MSA_GEN_STATE(x) (((x) & ((1 << 7) - 1)) << 24)
+# define F_MSA_GEN_STATE_RD(x) (((x) & (((1 << 7) - 1) << 24)) >> 24)
+
+/* register PCK_STUFF_STATUS_1 */
+# define PCK_STUFF_STATUS_1 41
+# define F_SST_SS_GEN_STATE(x) (((x) & ((1 << 6) - 1)) << 0)
+# define F_SST_SS_GEN_STATE_RD(x) (((x) & (((1 << 6) - 1) << 0)) >> 0)
+# define F_MST_SS_GEN_STATE(x) (((x) & ((1 << 6) - 1)) << 8)
+# define F_MST_SS_GEN_STATE_RD(x) (((x) & (((1 << 6) - 1) << 8)) >> 8)
+
+/* register INFO_PACK_STATUS */
+# define INFO_PACK_STATUS 42
+# define F_INFO_PACK_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_INFO_PACK_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_INFO_PACK_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_INFO_PACK_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_IP_PARITY_FSM_CURRENT_STATE(x) (((x) & ((1 << 3) - 1)) << 2)
+# define F_IP_PARITY_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 3) - 1) << 2)) >> 2)
+# define F_IP_FIFO_WR_FSM_CURRENT_STATE(x) (((x) & ((1 << 3) - 1)) << 5)
+# define F_IP_FIFO_WR_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 3) - 1) << 5)) >> 5)
+# define F_IP_FIFO_RD_FSM_CURRENT_STATE(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_IP_FIFO_RD_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_IP_SEND_DATA_FSM_CURRENT_STATE(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_IP_SEND_DATA_FSM_CURRENT_STATE_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_IN_VBID(x) (((x) & ((1 << 8) - 1)) << 24)
+# define F_IN_VBID_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register RATE_GOVERNOR_STATUS */
+# define RATE_GOVERNOR_STATUS 43
+# define F_RATE_GOVERNOR_FSM_STATE(x) (((x) & ((1 << 3) - 1)) << 0)
+# define F_RATE_GOVERNOR_FSM_STATE_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+# define F_CFG_TU_VS_DIFF(x) (((x) & ((1 << 2) - 1)) << 8)
+# define F_CFG_TU_VS_DIFF_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+# define F_CFG_HSYNC_DELAY(x) (((x) & ((1 << 8) - 1)) << 16)
+# define F_CFG_HSYNC_DELAY_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+# define F_CFG_EN_HSYNC_DELAY(x) (((x) & ((1 << 1) - 1)) << 24)
+# define F_CFG_EN_HSYNC_DELAY_RD(x) (((x) & (((1 << 1) - 1) << 24)) >> 24)
+
+/* register DP_HORIZONTAL */
+# define DP_HORIZONTAL 44
+# define F_HSYNCWIDTH(x) (((x) & ((1 << 15) - 1)) << 0)
+# define F_HSYNCWIDTH_RD(x) (((x) & (((1 << 15) - 1) << 0)) >> 0)
+# define F_HWIDTH(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_HWIDTH_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_VERTICAL_0 */
+# define DP_VERTICAL_0 45
+# define F_VHEIGHT(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_VHEIGHT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_VSTART(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_VSTART_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register DP_VERTICAL_1 */
+# define DP_VERTICAL_1 46
+# define F_VTOTAL(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_VTOTAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_VTOTAL_EVEN(x) (((x) & ((1 << 1) - 1)) << 16)
+# define F_VTOTAL_EVEN_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+
+/* register DP_BLOCK_SDP */
+# define DP_BLOCK_SDP 47
+# define F_BLOCK_SDP_BS(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_BLOCK_SDP_BS_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_BLOCK_SDP_BE(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_BLOCK_SDP_BE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_NO_VIDEO_BLOCK_SDP(x) (((x) & ((1 << 12) - 1)) << 16)
+# define F_NO_VIDEO_BLOCK_SDP_RD(x) (((x) & (((1 << 12) - 1) << 16)) >> 16)
+
+#endif //DPTX_STREAM
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/edid_parser.c b/drivers/video/fbdev/mxc/cdn_hdp/edid_parser.c
new file mode 100644
index 0000000..ad65ac5
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/edid_parser.c
@@ -0,0 +1,615 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * edid_parser.c
+ *
+ ******************************************************************************
+ */
+
+#include "edid_parser.h"
+
+static EDID_PARSER_RESULT edid_parse_dtd(S_DTD_DATA *descriptor,
+					 unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_DTD;
+	descriptor->header.tag = 0;
+
+	descriptor->pixel_clock = raw_data[raw_data_index];
+	descriptor->pixel_clock +=
+	    (unsigned short)raw_data[raw_data_index + 1] << 8;
+
+	descriptor->horizontal_addressable_video = raw_data[raw_data_index + 2];
+	descriptor->horizontal_addressable_video +=
+	    ((unsigned short)raw_data[raw_data_index + 4] & 0xF0) << 4;
+	descriptor->horizontal_blanking = raw_data[raw_data_index + 3];
+	descriptor->horizontal_blanking +=
+	    ((unsigned short)raw_data[raw_data_index + 4] & 0x0F) << 8;
+
+	descriptor->vertical_addressable_video = raw_data[raw_data_index + 5];
+	descriptor->vertical_addressable_video +=
+	    ((unsigned short)raw_data[raw_data_index + 7] & 0xF0) << 4;
+	descriptor->vertical_blanking = raw_data[raw_data_index + 6];
+	descriptor->vertical_blanking +=
+	    ((unsigned short)raw_data[raw_data_index + 7] & 0x0F) << 8;
+
+	descriptor->horizontal_front_porch = raw_data[raw_data_index + 8];
+	descriptor->horizontal_front_porch +=
+	    ((unsigned short)raw_data[raw_data_index + 11] & 0xC0) << 2;
+	descriptor->horizontal_sync_pulse_width = raw_data[raw_data_index + 9];
+	descriptor->horizontal_sync_pulse_width +=
+	    ((unsigned short)raw_data[raw_data_index + 11] & 0x30) << 4;
+
+	descriptor->vertical_front_porch =
+	    (raw_data[raw_data_index + 10] & 0xF0) >> 4;
+	descriptor->vertical_front_porch +=
+	    (raw_data[raw_data_index + 11] & 0x0C) << 2;
+	descriptor->vertical_sync_pulse_width =
+	    raw_data[raw_data_index + 10] & 0x0F;
+	descriptor->vertical_sync_pulse_width +=
+	    (raw_data[raw_data_index + 11] & 0x03) << 4;
+
+	descriptor->horizontal_addressable_video_image_size =
+	    raw_data[raw_data_index + 12];
+	descriptor->horizontal_addressable_video_image_size +=
+	    ((unsigned short)raw_data[raw_data_index + 14] & 0xF0) << 4;
+	descriptor->vertical_addressable_video_image_size =
+	    raw_data[raw_data_index + 13];
+	descriptor->vertical_addressable_video_image_size +=
+	    ((unsigned short)raw_data[raw_data_index + 14] & 0x0F) << 8;
+
+	descriptor->horizontal_border = raw_data[raw_data_index + 15];
+	descriptor->vertical_border = raw_data[raw_data_index + 16];
+
+	descriptor->signal_features = raw_data[raw_data_index + 17];
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_serial_number(S_SERIAL_NUMBER_DATA *
+						   descriptor,
+						   unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	int idx;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_SERIAL_NUMBER;
+	descriptor->header.tag = 0xFF;
+
+	for (idx = 0; idx < 13; idx++)
+		descriptor->serial_number[idx] =
+		    raw_data[raw_data_index + 5 + idx];
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_data_string(S_DATA_STRING_DATA *
+						 descriptor,
+						 unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	int idx;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_DATA_STRING;
+	descriptor->header.tag = 0xFE;
+	for (idx = 0; idx < 13; idx++)
+		descriptor->data_string[idx] =
+		    raw_data[raw_data_index + 5 + idx];
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_range_limits(S_RANGE_LIMITS_DATA *
+						  descriptor,
+						  unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	S_RANGE_LIMITS_VIDEO_TIMING_SECONDARY_GTF *timing_type_gtf;
+	S_RANGE_LIMITS_VIDEO_TIMING_CVT *timing_type_cvt;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_RANGE_LIMITS;
+	descriptor->header.tag = 0xFD;
+
+	descriptor->offset_flags = raw_data[raw_data_index + 4];
+	descriptor->min_vertical_rate = raw_data[raw_data_index + 5];
+	descriptor->max_vertical_rate = raw_data[raw_data_index + 6];
+	descriptor->min_horizontal_rate = raw_data[raw_data_index + 7];
+	descriptor->max_horizontal_rate = raw_data[raw_data_index + 8];
+	descriptor->max_pixel_clock = raw_data[raw_data_index + 9];
+
+	switch (raw_data[raw_data_index + 10]) {
+	case 0x00:
+		descriptor->type = VIDEO_TIMING_DEFAULT_GTF;
+		break;
+	case 0x01:
+		descriptor->type = VIDEO_TIMING_RANGE_LIMITS_ONLY;
+		break;
+	case 0x02:
+		descriptor->type = VIDEO_TIMING_SECONDARY_GTF;
+		timing_type_gtf = (S_RANGE_LIMITS_VIDEO_TIMING_SECONDARY_GTF *) descriptor->suport_flags;
+		timing_type_gtf->start_break_frequency =
+		    raw_data[raw_data_index + 12];
+		timing_type_gtf->c = raw_data[raw_data_index + 13];
+		timing_type_gtf->m = raw_data[raw_data_index + 14];
+		timing_type_gtf->m +=
+		    (unsigned short)raw_data[raw_data_index + 15] << 8;
+		timing_type_gtf->k = raw_data[raw_data_index + 16];
+		timing_type_gtf->j = raw_data[raw_data_index + 17];
+		break;
+	case 0x04:
+		descriptor->type = VIDEO_TIMING_CVT;
+		timing_type_cvt = (S_RANGE_LIMITS_VIDEO_TIMING_CVT *) descriptor->suport_flags;
+		timing_type_cvt->cvt_version = raw_data[raw_data_index + 11];
+		timing_type_cvt->additional_pixel_clock_precision =
+		    raw_data[raw_data_index + 12] >> 2;
+		timing_type_cvt->max_active_pixels =
+		    raw_data[raw_data_index + 13];
+		timing_type_cvt->max_active_pixels +=
+		    (unsigned short)(raw_data[raw_data_index + 12] & 0x03) << 8;
+		timing_type_cvt->supported_ar =
+		    raw_data[raw_data_index + 14] >> 3;
+		timing_type_cvt->preferred_ar =
+		    raw_data[raw_data_index + 15] >> 5;
+		timing_type_cvt->blanking_support =
+		    (raw_data[raw_data_index + 15] & 0x18) >> 3;
+		timing_type_cvt->supported_scalling =
+		    raw_data[raw_data_index + 16] >> 4;
+		timing_type_cvt->preferred_vertical_refresh_rate =
+		    raw_data[raw_data_index + 17];
+		break;
+	}
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_product_name(S_PRODUCT_NAME_DATA *
+						  descriptor,
+						  unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	int idx;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_PRODUCT_NAME;
+	descriptor->header.tag = 0xFC;
+	for (idx = 0; idx < 13; idx++)
+		descriptor->product_name[idx] =
+		    raw_data[raw_data_index + 5 + idx];
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_color_point(S_COLOR_POINT_DATA *
+						 descriptor,
+						 unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_COLOR_POINT;
+	descriptor->header.tag = 0xFB;
+	descriptor->white_point_index_1 = raw_data[raw_data_index + 5];
+	descriptor->white_x_1 = (raw_data[raw_data_index + 6] & 0x0C) >> 2;
+	descriptor->white_x_1 +=
+	    (unsigned short)raw_data[raw_data_index + 7] << 2;
+	descriptor->white_y_1 = raw_data[raw_data_index + 6] & 0x03;
+	descriptor->white_y_1 +=
+	    (unsigned short)raw_data[raw_data_index + 8] << 2;
+	descriptor->gamma_1 = raw_data[raw_data_index + 9];
+
+	descriptor->white_point_index_2 = raw_data[raw_data_index + 10];
+	descriptor->white_x_2 = (raw_data[raw_data_index + 11] & 0x0C) >> 2;
+	descriptor->white_x_2 +=
+	    (unsigned short)raw_data[raw_data_index + 12] << 2;
+	descriptor->white_y_2 = raw_data[raw_data_index + 11] & 0x03;
+	descriptor->white_y_2 +=
+	    (unsigned short)raw_data[raw_data_index + 13] << 2;
+	descriptor->gamma_2 = raw_data[raw_data_index + 14];
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_standard_timing(S_STANDARD_TIMING_DATA *
+						     descriptor,
+						     unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	int idx;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_STANDARD_TIMING;
+	descriptor->header.tag = 0xFA;
+	for (idx = 0; idx < 6; idx++) {
+		descriptor->standard_timings[idx] =
+		    raw_data[raw_data_index + 5 + 2 * idx];
+		descriptor->standard_timings[idx] +=
+		    (unsigned short)raw_data[raw_data_index + 5 + 2 * idx + 1];
+	}
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_color_management(S_COLOR_MANAGEMENT_DATA *
+						      descriptor,
+						      unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_COLOR_MANAGEMENT;
+	descriptor->header.tag = 0xF9;
+
+	descriptor->version = raw_data[raw_data_index + 5];
+
+	descriptor->red_a3 = raw_data[raw_data_index + 6];
+	descriptor->red_a3 += (unsigned short)raw_data[raw_data_index + 7] << 8;
+	descriptor->red_a2 = raw_data[raw_data_index + 8];
+	descriptor->red_a2 += (unsigned short)raw_data[raw_data_index + 9] << 8;
+
+	descriptor->green_a3 = raw_data[raw_data_index + 10];
+	descriptor->green_a3 +=
+	    (unsigned short)raw_data[raw_data_index + 11] << 8;
+	descriptor->green_a2 = raw_data[raw_data_index + 12];
+	descriptor->green_a2 +=
+	    (unsigned short)raw_data[raw_data_index + 13] << 8;
+
+	descriptor->blue_a3 = raw_data[raw_data_index + 14];
+	descriptor->blue_a3 +=
+	    (unsigned short)raw_data[raw_data_index + 15] << 8;
+	descriptor->blue_a2 = raw_data[raw_data_index + 16];
+	descriptor->blue_a2 +=
+	    (unsigned short)raw_data[raw_data_index + 17] << 8;
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_cvt_timing_codes(S_CVT_TIMING_CODES_DATA *
+						      descriptor,
+						      unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	int idx;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_CVT_TIMING_CODES;
+	descriptor->header.tag = 0xF8;
+	descriptor->version = raw_data[raw_data_index + 5];
+
+	for (idx = 0; idx < 4; idx++) {
+		descriptor->addressable_lines[idx] =
+		    raw_data[raw_data_index + 6 + idx * 3];
+		descriptor->addressable_lines[idx] +=
+		    (unsigned short)(raw_data[raw_data_index + 7 + idx * 3] &
+				     0xF0) << 4;
+		descriptor->aspect_ratio[idx] =
+		    (raw_data[raw_data_index + 7 + idx * 3] & 0x0C) >> 2;
+		descriptor->preferred_vertical_rate[idx] =
+		    (raw_data[raw_data_index + 8 + idx * 3] & 0x60) >> 5;
+		descriptor->supported_vertical_rate_and_blanking[idx] =
+		    raw_data[raw_data_index + 8 + idx * 3] & 0x1F;
+	}
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT
+edid_parse_established_timings_3(S_ESTABLISHED_TIMINGS_3_DATA *descriptor,
+				 unsigned char *raw_data)
+{
+	unsigned int raw_data_index = 0;
+	int idx;
+
+	descriptor->header.type = DESCRIPTOR_TYPE_ESTABLISHED_TIMINGS_3;
+	descriptor->header.tag = 0xF7;
+	descriptor->version = raw_data[raw_data_index + 5];
+	for (idx = 0; idx < 6; idx++) {
+		descriptor->established_timings[idx] =
+		    raw_data[raw_data_index + 6 + idx];
+	}
+
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT edid_parse_dummy(S_DUMMY_DATA *descriptor,
+					   unsigned char *raw_data)
+{
+	descriptor->header.type = DESCRIPTOR_TYPE_DUMMY;
+	descriptor->header.tag = 0x10;
+	return EDID_PARSER_SUCCESS;
+}
+
+static EDID_PARSER_RESULT
+edid_parse_manufacturer_specific(S_MANUFACTURER_SPECIFIC_DATA *descriptor,
+				 unsigned char *raw_data, unsigned char tag)
+{
+	descriptor->header.type = DESCRIPTOR_TYPE_MANUFACTURER_SPECIFIC;
+	descriptor->header.tag = tag;
+
+	return EDID_PARSER_SUCCESS;
+}
+
+EDID_PARSER_RESULT edid_parse(S_EDID_DATA *edid, unsigned char *raw_data,
+			      unsigned int len)
+{
+	unsigned int raw_data_index = 0;
+	unsigned char sum = 0;
+	unsigned int descriptor_index;
+	unsigned char tag;
+
+	/* CHECK SUM OF BYTES IN BLOCK0 */
+	for (raw_data_index = 0; raw_data_index < EDID_LENGTH; raw_data_index++)
+		sum += raw_data[raw_data_index];
+
+	if (sum != 0)
+		return EDID_PARSER_ERROR;
+
+	/* READ HEADER */
+	for (raw_data_index = 0; raw_data_index < EDID_HEADER_LENGTH;
+	     raw_data_index++)
+		edid->header[raw_data_index] = raw_data[raw_data_index];
+
+	/* READ VENDOR & PRODUCT IDENTIFICATION */
+	/* manufacturer name */
+	edid->manufacturer_name[0] = ((raw_data[8] & 0x7C) >> 2) + 0x40;
+	edid->manufacturer_name[1] =
+	    ((raw_data[8] & 0x03) << 3) + ((raw_data[9] & 0xE0) >> 5) + 0x40;
+	edid->manufacturer_name[2] = ((raw_data[9] & 0x1F)) + 0x40;
+	edid->manufacturer_name[3] = 0;
+
+	/* product code */
+	edid->product_code = (raw_data[10]);
+	edid->product_code += ((unsigned short)raw_data[11]) << 8;
+
+	/* serial number */
+	edid->serial_number = raw_data[12];
+	edid->serial_number += (unsigned int)raw_data[13] << 8;
+	edid->serial_number += (unsigned int)raw_data[14] << 16;
+	edid->serial_number += (unsigned int)raw_data[15] << 24;
+
+	/* week of manufacture */
+	edid->week = raw_data[16];
+
+	/* year of manufacture */
+	edid->year = raw_data[17];
+
+	/* EDID STRUCTURE VERSION & REVISION */
+	edid->edid_version = ((unsigned short)raw_data[18] << 8) + raw_data[19];
+
+	/* BASIC DISPLAY PARAMETERS AND FEATURES
+	* video input definition */
+	edid->video_input_definition = raw_data[20];
+
+	/* horizontal screen size */
+	edid->horizontal_size = raw_data[21];
+
+	/* vertical screen size */
+	edid->vertical_size = raw_data[22];
+
+	/* display transfer characteristic */
+	edid->gamma = raw_data[23];
+
+	/* feature support */
+	edid->feature_support = raw_data[24];
+
+	/* COLOR CHARACTERISTIC */
+	/* red */
+	edid->chromacity_coorditates_red_x = (raw_data[25] & 0xC0) >> 6;
+	edid->chromacity_coorditates_red_x += (unsigned short)raw_data[27] << 2;
+	edid->chromacity_coorditates_red_y = (raw_data[25] & 0x30) >> 4;
+	edid->chromacity_coorditates_red_y += (unsigned short)raw_data[28] << 2;
+
+	/* green */
+	edid->chromacity_coorditates_green_x = (raw_data[25] & 0x0C) >> 2;
+	edid->chromacity_coorditates_green_x +=
+	    (unsigned short)raw_data[29] << 2;
+	edid->chromacity_coorditates_green_y = (raw_data[25] & 0x03);
+	edid->chromacity_coorditates_green_y +=
+	    (unsigned short)raw_data[30] << 2;
+
+	/* blue */
+	edid->chromacity_coorditates_blue_x = (raw_data[26] & 0xC0) >> 6;
+	edid->chromacity_coorditates_blue_x +=
+	    (unsigned short)raw_data[31] << 2;
+	edid->chromacity_coorditates_blue_y = (raw_data[26] & 0x30) >> 4;
+	edid->chromacity_coorditates_blue_y +=
+	    (unsigned short)raw_data[32] << 2;
+
+	/* blue */
+	edid->chromacity_coorditates_white_x = (raw_data[26] & 0x0C) >> 2;
+	edid->chromacity_coorditates_white_x +=
+	    (unsigned short)raw_data[33] << 2;
+	edid->chromacity_coorditates_white_y = (raw_data[26] & 0x03);
+	edid->chromacity_coorditates_white_y +=
+	    (unsigned short)raw_data[34] << 2;
+
+	/* ESTABLISHED TIMINGS */
+	edid->established_timing_1 = raw_data[35];
+	edid->established_timing_2 = raw_data[36];
+	edid->manufacturer_timing = raw_data[37];
+
+	/* STANDARD TIMINGS */
+	for (raw_data_index = 0; raw_data_index < 8; raw_data_index++) {
+		edid->standard_timings[raw_data_index] =
+		    raw_data[38 + (2 * raw_data_index)];
+		edid->standard_timings[raw_data_index] +=
+		    (unsigned short)raw_data[38 + (2 * raw_data_index + 1)];
+	}
+	/* extensions */
+	edid->extensions = raw_data[126];
+
+	/* DESCRIPTORS */
+	raw_data_index = 54;
+	for (descriptor_index = 0; descriptor_index < 4; descriptor_index++) {
+		if (raw_data[raw_data_index] == 0
+		    && raw_data[raw_data_index] == 0) {
+			/* display descriptor found */
+			tag = raw_data[raw_data_index + 3];
+			if (tag == 0xFF) {
+				/* display product serial number */
+				S_SERIAL_NUMBER_DATA *descriptor =
+				    (S_SERIAL_NUMBER_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_serial_number
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xFE) {
+				/* alphanumeric data string */
+				S_DATA_STRING_DATA *descriptor =
+				    (S_DATA_STRING_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_data_string
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xFD) {
+				/* display range limits */
+				S_RANGE_LIMITS_DATA *descriptor =
+				    (S_RANGE_LIMITS_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_range_limits
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xFC) {
+				/* display product name */
+				S_PRODUCT_NAME_DATA *descriptor =
+				    (S_PRODUCT_NAME_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_product_name
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xFB) {
+				/* color point data */
+				S_COLOR_POINT_DATA *descriptor =
+				    (S_COLOR_POINT_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_color_point
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xFA) {
+				/* standard timing identifications */
+				S_STANDARD_TIMING_DATA *descriptor =
+				    (S_STANDARD_TIMING_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_standard_timing
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xF9) {
+				/* display color management (DCM) */
+				S_COLOR_MANAGEMENT_DATA *descriptor =
+				    (S_COLOR_MANAGEMENT_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_color_management
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xF8) {
+				/* CVT 3 byte timing codes */
+				S_CVT_TIMING_CODES_DATA *descriptor =
+				    (S_CVT_TIMING_CODES_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_cvt_timing_codes
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0xF7) {
+				/* established timings III */
+				S_ESTABLISHED_TIMINGS_3_DATA *descriptor =
+				    (S_ESTABLISHED_TIMINGS_3_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_established_timings_3
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag == 0x10) {
+				/* dummy */
+				S_DUMMY_DATA *descriptor =
+				    (S_DUMMY_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_dummy
+				    (descriptor,
+				     raw_data + raw_data_index) !=
+				    EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+
+			} else if (tag <= 0x0F) {
+				/* manufacturer specific data */
+				S_MANUFACTURER_SPECIFIC_DATA *descriptor =
+				    (S_MANUFACTURER_SPECIFIC_DATA *) edid->
+				    descriptors[descriptor_index];
+				if (edid_parse_manufacturer_specific
+				    (descriptor, raw_data + raw_data_index,
+				     tag) != EDID_PARSER_SUCCESS)
+					return EDID_PARSER_ERROR;
+			}
+		} else {
+			/* detailed timing definition */
+			S_DTD_DATA *descriptor =
+			    (S_DTD_DATA *) edid->descriptors[descriptor_index];
+			if (edid_parse_dtd
+			    (descriptor,
+			     raw_data + raw_data_index) != EDID_PARSER_SUCCESS)
+				return EDID_PARSER_ERROR;
+
+		}
+		raw_data_index += 18;
+	}
+
+	return EDID_PARSER_SUCCESS;
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/edid_parser.h b/drivers/video/fbdev/mxc/cdn_hdp/edid_parser.h
new file mode 100644
index 0000000..b9d5cdd
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/edid_parser.h
@@ -0,0 +1,295 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * edid_parser.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef EDID_PARSER_H
+# define EDID_PARSER_H
+
+# define MAX_DESCRIPTOR_LENGTH 36
+# define MAX_RANGE_LIMITS_VIDEO_TIMING_LENGTH 12
+# define EDID_HEADER_LENGTH 8
+# define EDID_LENGTH 128
+
+typedef enum {
+	EDID_PARSER_SUCCESS,
+	EDID_PARSER_ERROR,
+} EDID_PARSER_RESULT;
+
+typedef enum {
+	DESCRIPTOR_TYPE_DTD,
+	DESCRIPTOR_TYPE_SERIAL_NUMBER,
+	DESCRIPTOR_TYPE_DATA_STRING,
+	DESCRIPTOR_TYPE_RANGE_LIMITS,
+	DESCRIPTOR_TYPE_PRODUCT_NAME,
+	DESCRIPTOR_TYPE_COLOR_POINT,
+	DESCRIPTOR_TYPE_STANDARD_TIMING,
+	DESCRIPTOR_TYPE_COLOR_MANAGEMENT,
+	DESCRIPTOR_TYPE_CVT_TIMING_CODES,
+	DESCRIPTOR_TYPE_ESTABLISHED_TIMINGS_3,
+	DESCRIPTOR_TYPE_DUMMY,
+	DESCRIPTOR_TYPE_MANUFACTURER_SPECIFIC
+} EDID_DESCRIPTOR_TYPE;
+
+typedef enum {
+	VIDEO_TIMING_DEFAULT_GTF,
+	VIDEO_TIMING_RANGE_LIMITS_ONLY,
+	VIDEO_TIMING_SECONDARY_GTF,
+	VIDEO_TIMING_CVT,
+} RANGE_LIMITS_VIDEO_TIMING_TYPE;
+
+/**
+ *  \brief Common descriptor header structure
+ */
+typedef struct {
+	EDID_DESCRIPTOR_TYPE type;
+	unsigned char tag;
+
+} S_DESCRIPTOR_HEADER_DATA;
+/**
+ *  \brief Detailed Timing Descriptor (DTD) structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned short pixel_clock;
+	unsigned short horizontal_addressable_video;
+	unsigned short horizontal_blanking;
+	unsigned short vertical_addressable_video;
+	unsigned short vertical_blanking;
+	unsigned short horizontal_front_porch;
+	unsigned short horizontal_sync_pulse_width;
+	unsigned short vertical_front_porch;
+	unsigned short vertical_sync_pulse_width;
+	unsigned short horizontal_addressable_video_image_size;
+	unsigned short vertical_addressable_video_image_size;
+	unsigned char horizontal_border;
+	unsigned char vertical_border;
+	unsigned char signal_features;
+} S_DTD_DATA;
+
+/**
+ *  \brief Serial Number Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char serial_number[13];
+
+} S_SERIAL_NUMBER_DATA;
+
+/**
+ *  \brief Data String Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	char data_string[13];
+
+} S_DATA_STRING_DATA;
+
+/**
+ *  \brief Range Limits Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char offset_flags;
+	unsigned char min_vertical_rate;
+	unsigned char max_vertical_rate;
+	unsigned char min_horizontal_rate;
+	unsigned char max_horizontal_rate;
+	unsigned char max_pixel_clock;
+	RANGE_LIMITS_VIDEO_TIMING_TYPE type;
+	unsigned char suport_flags[MAX_RANGE_LIMITS_VIDEO_TIMING_LENGTH];
+} S_RANGE_LIMITS_DATA;
+
+/**
+ *  \brief Range Limits Secondary GTF Flags structure
+ */
+typedef struct {
+	unsigned char start_break_frequency;
+	unsigned char c;
+	unsigned short m;
+	unsigned char k;
+	unsigned char j;
+
+} S_RANGE_LIMITS_VIDEO_TIMING_SECONDARY_GTF;
+
+/**
+ *  \brief Range Limits CVT Flags structure
+ */
+typedef struct {
+	unsigned char cvt_version;
+	unsigned char additional_pixel_clock_precision;
+	unsigned short max_active_pixels;
+	unsigned char supported_ar;
+	unsigned char preferred_ar;
+	unsigned char blanking_support;
+	unsigned char supported_scalling;
+	unsigned char preferred_vertical_refresh_rate;
+} S_RANGE_LIMITS_VIDEO_TIMING_CVT;
+
+/**
+ *  \brief Product Name Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	char product_name[13];
+
+} S_PRODUCT_NAME_DATA;
+
+/**
+ *  \brief Color point Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char white_point_index_1;
+	unsigned short white_x_1;
+	unsigned short white_y_1;
+	unsigned char gamma_1;
+	unsigned char white_point_index_2;
+	unsigned short white_x_2;
+	unsigned short white_y_2;
+	unsigned char gamma_2;
+} S_COLOR_POINT_DATA;
+
+/**
+ *  \brief Standard Timing Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned short standard_timings[6];
+} S_STANDARD_TIMING_DATA;
+
+/**
+ *  \brief Color Management Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char version;
+	unsigned short red_a3;
+	unsigned short red_a2;
+	unsigned short green_a3;
+	unsigned short green_a2;
+	unsigned short blue_a3;
+	unsigned short blue_a2;
+} S_COLOR_MANAGEMENT_DATA;
+
+/**
+ *  \brief CVT 3 Byte Code Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char version;
+	unsigned short addressable_lines[4];
+	unsigned char aspect_ratio[4];
+	unsigned char preferred_vertical_rate[4];
+	unsigned char supported_vertical_rate_and_blanking[4];
+
+} S_CVT_TIMING_CODES_DATA;
+
+/**
+ *  \brief Established Timings 3 Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char version;
+	unsigned char established_timings[6];
+} S_ESTABLISHED_TIMINGS_3_DATA;
+
+/**
+ *  \brief Dummy Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+} S_DUMMY_DATA;
+
+/**
+ *  \brief Manufacturer Specific Descriptor structure
+ */
+typedef struct {
+	S_DESCRIPTOR_HEADER_DATA header;
+	unsigned char desc_data[18];
+} S_MANUFACTURER_SPECIFIC_DATA;
+
+/**
+ *  \brief CEA-861 extension structure
+ */
+typedef struct {
+	unsigned char revision;
+	unsigned char underscan;
+	unsigned char audio;
+} S_CEA861_DATA;
+
+/**
+ *  \brief Extended Display Identification Data (EDID) structure
+ */
+typedef struct {
+	unsigned char header[8];
+	char manufacturer_name[4];
+	unsigned short product_code;
+	unsigned int serial_number;
+	unsigned char week;
+	unsigned short year;
+	unsigned short edid_version;
+	unsigned char video_input_definition;
+	unsigned char horizontal_size;
+	unsigned char vertical_size;
+	unsigned char gamma;
+	unsigned char feature_support;
+	unsigned short chromacity_coorditates_red_x;
+	unsigned short chromacity_coorditates_red_y;
+	unsigned short chromacity_coorditates_green_x;
+	unsigned short chromacity_coorditates_green_y;
+	unsigned short chromacity_coorditates_blue_x;
+	unsigned short chromacity_coorditates_blue_y;
+	unsigned short chromacity_coorditates_white_x;
+	unsigned short chromacity_coorditates_white_y;
+	unsigned char established_timing_1;
+	unsigned char established_timing_2;
+	unsigned char manufacturer_timing;
+	unsigned short standard_timings[8];
+	unsigned char descriptors[4][MAX_DESCRIPTOR_LENGTH];
+	unsigned char extensions;
+} S_EDID_DATA;
+
+EDID_PARSER_RESULT edid_parse(S_EDID_DATA *edid, unsigned char *raw_data,
+			      unsigned int len);
+
+#endif /* EDID_PARSER_H */
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/externs.h b/drivers/video/fbdev/mxc/cdn_hdp/externs.h
new file mode 100644
index 0000000..b37c51e
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/externs.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * externs.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef EXTERNS_H_
+# define EXTERNS_H_
+
+/**
+ * \addtogroup UTILS
+ * \{
+ */
+/**
+ * \brief read from apb
+ * \param addr - address to read
+ * \param value - pointer to store value
+ * \return non-zero value if error
+ */
+//extern int cdn_bus_read(unsigned int addr, unsigned int* value);
+
+/**
+ * \brief write to apb
+ * \param addr - address to write
+ * \param value - value to write
+ * \return non-zero if error
+ */
+//extern int cdn_bus_write(unsigned int addr, unsigned int value);
+
+extern uint32_t cdn_apb_read(uint32_t addr, volatile uint32_t *value);
+extern uint32_t cdn_sapb_read(uint32_t addr, volatile uint32_t *value);
+extern uint32_t cdn_apb_write(uint32_t addr, uint32_t value);
+extern uint32_t cdn_sapb_write(uint32_t addr, uint32_t value);
+extern void cdn_sleep(uint32_t ms);
+extern void cdn_usleep(uint32_t us);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/general_handler.h b/drivers/video/fbdev/mxc/cdn_hdp/general_handler.h
new file mode 100644
index 0000000..85505a0
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/general_handler.h
@@ -0,0 +1,162 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * general_handler.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef GENERAL_HANDLER_H
+#define GENERAL_HANDLER_H
+
+/**
+ *  \file
+ *  \brief general handler, checks available messages, receives it from mailbox, handles requests and sends response to the host
+ */
+#define DP_TX_MAIL_HANDLER_REQUEST_BUFFER_LEN 256
+
+/**
+ *  \brief opcode defines host->controller
+ */
+#define GENERAL_MAIN_CONTROL            0x01
+#define GENERAL_TEST_ECHO               0x02
+#define GENERAL_BUS_SETTINGS            0x03
+#define GENERAL_TEST_ACCESS             0x04
+
+#define GENERAL_WRITE_REGISTER          0x05
+#define GENERAL_WRITE_FIELD             0x06
+#define GENERAL_READ_REGISTER           0x07
+
+#define GENERAL_TEST_TRNG_SIMPLE        0xF0
+
+#define GENERAL_MAIN_CONTROL_SET_ACTIVE_BIT         0
+#define GENERAL_MAIN_CONTROL_SET_ALT_CIPHER_ADDR    1
+
+#define GENERAL_BUS_SETTINGS_DPCD_BUS_BIT           0
+#define GENERAL_BUS_SETTINGS_DPCD_BUS_LOCK_BIT      1
+#define GENERAL_BUS_SETTINGS_HDCP_BUS_BIT           2
+#define GENERAL_BUS_SETTINGS_HDCP_BUS_LOCK_BIT      3
+#define GENERAL_BUS_SETTINGS_CAPB_OWNER_BIT         4
+#define GENERAL_BUS_SETTINGS_CAPB_OWNER_LOCK_BIT    5
+
+/**
+ *  \brief opcode defines controller->host
+ */
+
+#define GENERAL_MAIN_CONTROL_RESP        0x01
+#define GENERAL_TEST_ECHO_RESP           0x02
+#define GENERAL_BUS_SETTINGS_RESP        0x03
+
+#define GENERAL_READ_REGISTER_RESP       0x07
+
+#define GENERAL_BUS_SETTINGS_RESP_DPCD_BUS_BIT      0
+#define GENERAL_BUS_SETTINGS_RESP_HDCP_BUS_BIT      1
+#define GENERAL_BUS_SETTINGS_RESP_CAPB_OWNER_BIT    2
+
+#define GENERAL_BUS_SETTINGS_RESP_SUCCESS           0
+#define GENERAL_BUS_SETTINGS_RESP_LOCK_ERROR        1
+
+typedef struct {
+	unsigned char dpcd_locked;
+	unsigned char hdcp_locked;
+	unsigned char capb_locked;
+	unsigned char active_mode;
+} S_GENERAL_HANDLER_DATA;
+
+/**
+ *  \brief event id sent to the host
+ */
+typedef enum {
+	EVENT_ID_DPTX_HPD = 0,
+	EVENT_ID_HDMI_TX_HPD = 0,
+	EVENT_ID_HDMI_RX_5V = 0,
+
+	EVENT_ID_DPTX_TRAINING = 1,
+	EVENT_ID_HDMI_RX_SCDC_CHANGE = 1,
+
+	EVENT_ID_RESERVE0 = 2,
+	EVENT_ID_RESERVE1 = 3,
+
+	EVENT_ID_HDCPTX_STATUS = 4,
+	EVENT_ID_HDCPRX_STATUS = 4,
+
+	EVENT_ID_HDCPTX_IS_KM_STORED = 5,
+	EVENT_ID_HDCPTX_STORE_KM = 6,
+	EVENT_ID_HDCPTX_IS_RECEIVER_ID_VALID = 7,
+	EVENT_ID_HDMITX_READ_REQUEST = 8,
+} EVENT_ID;
+
+/**
+ * \brief convert bank id and register number to address and write to ptr
+ */
+
+#define select_reg_old(bank, reg_no, ptr) \
+{ \
+	ptr = 0; \
+	if ((bank == 0x22) || (bank == 0x20) || (bank == 0x0b) || (bank == 0x09) || (bank == 0x0A)) \
+		ptr = (unsigned int *)(bank << 8 | reg_no); \
+}
+
+#define select_reg(bank, reg_no, ptr) \
+do { \
+	ptr = (unsigned int *)(bank << 8 | reg_no); \
+} while (0)
+
+#define select_reg4(pmsb, p2, p3, plsb, ptr) \
+do { \
+	ptr = (unsigned int *)((pmsb << 24) | (p2 << 16) | (p3 << 8) | (plsb << 0)); \
+} while (0)
+
+#define EVENTS_DPTX_CNT 2
+#define EVENTS_HDCPTX_CNT 4
+
+void general_handler_set_active_mode(void);
+void general_handler_set_standby_mode(void);
+
+/**
+ *  \brief request sending en event to the host
+ *  \param [in] eventId
+ *  \param [in] eventCode
+ */
+
+#endif /* GENERAL_HANDLER_H */
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/hdcp.h b/drivers/video/fbdev/mxc/cdn_hdp/hdcp.h
new file mode 100644
index 0000000..78e4540
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/hdcp.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * hdcp.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef HDCP_H
+# define HDCP_H
+# include "mailBox.h"
+
+# define RX_TX_HDCP_TRANS_MAX_BUFFER 640
+#endif //HDCP_H
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/hdcp2.h b/drivers/video/fbdev/mxc/cdn_hdp/hdcp2.h
new file mode 100644
index 0000000..aef8c2b
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/hdcp2.h
@@ -0,0 +1,289 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * hdcp2.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef HDCP2_H
+#define HDCP2_H
+#include "mailBox.h"
+/* HDCP 2 registers
+ * and general use function for HDCP2 (transmitter and receiver)
+ * Author - yehonatan levin - cadence */
+/**
+ *  \file
+ *  \brief HDCP 2 registers
+ * and general use function for HDCP2 (trasmiter and reciever)
+ */
+
+/* HDCP2 register list */
+
+#ifdef DP_TX
+#define HDCP2_RTX                       0x69000
+#define HDCP2_TX_CAPS                   0x69008
+#define HDCP2_CERT_RX                   0x6900B
+#define HDCP2_RRX                       0x69215
+#define HDCP2_RX_CAPS                   0x6921D
+#define HDCP2_EKPUB_KM                  0x69220
+#define HDCP2_EKH_KM_WR                 0x692A0
+#define HDCP2_M                         0x692B0
+#define HDCP2_H_TAG                     0x692C0
+#define HDCP2_EKH_KM_RD                 0x692E0
+#define HDCP2_RN                        0x692F0
+#define HDCP2_L_TAG                     0x692F8
+#define HDCP2_EDKEY_KS                  0x69318
+#define HDCP2_RIV                       0x69328
+#define HDCP2_RX_INFO                   0x69330
+#define HDCP2_SEQ_NUM_V                 0x69332
+#define HDCP2_V_TAG                     0x69335
+#define HDCP2_RECEIVER_ID_LIST          0x69345
+#define HDCP2_V                         0x693E0
+#define HDCP2_SEQ_NUM_M                 0x693F0
+#define HDCP2_K                         0x693F3
+#define HDCP2_STREAM_ID_TYPE            0x693F5
+#define HDCP2_M_TAG                     0x69473
+#define HDCP2_RXSTATUS                  0x69493
+#define HDCP2_RSVD                      0x69494
+#define HDCP2_DBG                       0x69518
+
+#else /* HDMI */
+#define HDCP2_HDCP14        0x0
+#define HDCP2_RSVD1         0x44
+#define HDCP2_HDCP2_VERSION 0x50
+#define HDCP2_RSVD2         0x51
+#define HDCP2_WRITE_MESSAGE 0x60
+#define HDCP2_RSVD3         0x61
+#define HDCP2_RXSTATUS      0x70
+#define HDCP2_RSVD4         0x72
+#define HDCP2_READ_MESSAGE  0x80
+#define HDCP2_RSVD5         0x81
+#define HDCP2_DBG           0xC0
+#endif
+
+/* HDCP2 commands */
+#define HDCP2_CMD_AKE_INIT                          2
+#define HDCP2_CMD_AKE_SEND_CERT                     3
+#define HDCP2_CMD_AKE_NO_STORED_KM                  4
+#define HDCP2_CMD_AKE_STORED_KM                     5
+#define HDCP2_CMD_AKE_SEND_H_PRIME                  7
+#define HDCP2_CMD_AKE_SEND_PAIRING_INFO             8
+#define HDCP2_CMD_LC_INIT                           9
+#define HDCP2_CMD_LC_SEND_L_PRIME                   10
+#define HDCP2_SKE_SEND_EKS                          11
+#define HDCP2_REPEATER_AUTH_SEND_RECEIVER_ID_LIST   12
+#define HDCP2_REPEATER_AUTH_SEND_ACK                15
+#define HDCP2_REPEATER_AUTH_STREAM_MANAGE           16
+#define HDCP2_REPEATER_AUTH_STREAM_READY            17
+
+/* values */
+#define HDCP2_VAL_HDCP2_VERSION_SUPPORTED 2
+
+#define LC_128_LEN 16
+extern unsigned char pHdcpLc128[LC_128_LEN];
+
+typedef enum {
+	HDCP2_NOT_FINISHED = 0x11,
+	HDCP2_FINISHED
+} HDCP_2_REC_RES;
+
+/* command structs */
+/* AKE INIT */
+typedef struct {
+	unsigned char version;
+	unsigned char transmitter_capability_mask[2];
+} S_HDCP2_TXCAPS;
+
+typedef struct {
+	unsigned char rtx[8];
+	S_HDCP2_TXCAPS txcaps;
+} S_HDCP2_CMD_AKE_INIT;
+
+/* AKE_SEND_CERT */
+
+typedef struct {
+	unsigned char cert_rx[522];
+	unsigned char r_rx[8];
+	unsigned char rxcaps[3];
+} S_HDCP2_CMD_AKE_SEND_CERT;
+
+/* AKE_NO_STORED_KM */
+
+typedef struct {
+	unsigned char ekpub_km[128];
+} S_HDCP2_CMD_AKE_NO_STORED_KM;
+
+/* AKE_STORED_KM */
+
+typedef struct {
+	unsigned char ekh_km[16];
+	unsigned char m[16];
+} S_HDCP2_CMD_AKE_STORED_KM;
+
+/* AKE_SEND_H_PRIME */
+
+typedef struct {
+	unsigned char h[32];
+} S_HDCP2_CMD_AKE_SEND_H_PRIME;
+
+/* AKE_SEND_PAIRING_INFO */
+
+typedef struct {
+	unsigned char Ekh_Km[16];
+} S_HDCP2_CMD_AKE_SEND_PAIRING_INFO;
+
+/* LC_Init */
+
+typedef struct {
+	unsigned char rn[8];
+} S_HDCP2_CMD_LC_Init;
+
+/* LC_Send_L_Prime */
+
+typedef struct {
+	unsigned char l[32];
+} S_HDCP2_CMD_LC_Send_L_Prime;
+
+/* LC_Send_Eks */
+
+typedef struct {
+	unsigned char Edkey_Ks[16];
+	unsigned char Riv[8];
+} S_HDCP2_CMD_SKE_Send_Eks;
+
+/* REPEATER_AUTH_SEND_RECEIVER_ID_LIST */
+
+typedef struct {
+	unsigned char RxInfo[2];
+	unsigned char seq_num_V[3];
+	unsigned char V[16];	/* max device count * 5 */
+} S_HDCP2_CMD_REPEATER_AUTH_SEND_RECEIVER_ID_LIST;
+
+/* HDCP2_RxInfo bits */
+typedef struct {
+	unsigned short HDCP1_DEVICE_DOWNSTREAM:1;
+	unsigned short HDCP2_0_REPEATER_DOWNSTREAM:1;
+	unsigned short MAX_CASCADE_EXCEEDED:1;
+	unsigned short MAX_DEVS_EXCEEDED:1;
+	unsigned short DEVICE_COUNT:5;
+	unsigned short DEPTH:3;
+} S_HDCP2_RX_INFO_BITS;
+
+typedef union {
+	S_HDCP2_RX_INFO_BITS bits;
+	unsigned short value16Bit;
+} U_HDCP2_RX_INFO;
+
+/* REPEATER_AUTH_SEND_ACK */
+
+typedef struct {
+	unsigned char v[16];
+} S_HDCP2_CMD_REPEATER_AUTH_SEND_ACK;
+
+/* REPEATER_AUTH_STREAM_MANAGE */
+
+typedef struct {
+	unsigned char seq_num_m[3];
+	unsigned char k[2];
+	unsigned char streamId_Type[2];	/* should be k*2 by spec??? */
+} S_HDCP2_CMD_REPEATER_AUTH_STREAM_MANAGE;
+
+/* REPEATER_AUTH_STREAM_READY */
+
+typedef struct {
+	unsigned char m[32];
+} S_HDCP2_CMD_REPEATER_AUTH_STREAM_READY;
+
+/* HDCP2_RXSTATUS bits */
+#ifdef DP_TX
+typedef struct {
+
+	unsigned char READY:1;
+	unsigned char H_AVAILABLE:1;
+	unsigned char PAIRING_AVAILABLE:1;
+	unsigned char REAUTH_REQ:1;
+	unsigned char LINK_INTEGRITY_FAILURE:1;
+	unsigned char RSVD:3;
+} S_HDCP2_RX_STATUS_BITS;
+#else
+typedef struct {
+	unsigned short Message_Size:10;
+	unsigned short READY:1;
+	unsigned short REAUTH_REQ:1;
+	unsigned short RSVD:4;
+} S_HDCP2_RX_STATUS_BITS;
+
+#endif
+
+typedef union {
+	S_HDCP2_RX_STATUS_BITS bits;
+	unsigned short value16Bit;
+} U_HDCP2_RX_STATUS;
+
+/* HDCP ports mail box messages */
+typedef enum {
+	HDCP_GENERAL_SET_LC_128 = 0,
+	HDCP_SET_SEED,
+} HDCP_GENERAL_MSG;
+
+/**
+ *  \brief get command length for specific command
+ *
+ *  \param [in] offset offset of the command
+ *  \return Return_Description
+ *
+ */
+unsigned int hdcp2_commandLen(unsigned int offset);
+/**
+ *  \brief message length for specific message
+ *
+ *  \param [in] msg the message
+ *  \return the size of this message
+ *
+ */
+unsigned int hdcp2_MsgcommandLen(unsigned char msg);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/hdcp_tran.h b/drivers/video/fbdev/mxc/cdn_hdp/hdcp_tran.h
new file mode 100644
index 0000000..3e14431
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/hdcp_tran.h
@@ -0,0 +1,258 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * hdcp_tran.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef HDCP_TRAN_H
+#define HDCP_TRAN_H
+
+#include "hdcp.h"
+
+/**
+ *  \file
+ *  \brief general HDCP2 transmitter function and data structures
+ */
+
+/* supported HDCP TX ports */
+typedef enum {
+	HDCP_TX_PORT_0,
+	HDCP_TX_PORT_1,
+	HDCP_TX_PORT_2,
+	HDCP_TX_PORT_3,
+	HDCP_TX_NUM_OF_PORTS,
+} HDCP_TX_PORT;
+
+/* HDCP TX ports working mode (HDCP 2.2 or 1.4) */
+typedef enum {
+	HDCP_TX_2,		/* lock only with HDCP2 */
+	HDCP_TX_1,		/* lock only with HDCP1 */
+	HDCP_TX_BOTH,   /* lock on HDCP2 or 1 depend on other side */
+} HDCP_TX_MODE;
+
+/* HDCP TX ports stream type (relevant if receiver is repeater) */
+typedef enum {
+	HDCP_CONTENT_TYPE_0,	/* May be transmitted by The HDCP Repeater to all HDCP Devices. */
+	HDCP_CONTENT_TYPE_1,	/* Must not be transmitted by the HDCP Repeater to HDCP 1.x-compliant Devices and HDCP 2.0-compliant Repeaters */
+} HDCP_TX_CONTENT_STREAM_TYPE;
+
+/* HDCP TX ports stream packet status */
+typedef enum {
+	HDCP_CONTENT_NEED_TO_SEND,
+	HDCP_CONTENT_SENT_AND_WAIT_FOR_RESPOND,
+	HDCP_CONTENT_SENT_AND_FAILED,
+	HDCP_CONTENT_SUCCESS,
+} HDCP_TX_CONTENT_STREAM_STATUS;
+
+/* HDCP TX ports working mode (HDCP 2.2 or 1.4) */
+typedef enum {
+	HDCP_TX_NOT_ACTIVE,
+	HDCP_TX_NOT_CONFIGURED,
+	HDCP_TX_START,
+	HDCP_TX_WAIT_FOR_RX_TYPE,
+	HDCP_TX_ACTION
+} HDCP_TX_STATE;
+
+typedef union {
+	struct {
+		HDCP_TX_MODE port_supported_modes:2;
+		HDCP_TX_MODE port_cur_mode:2;
+		HDCP_TX_STATE port_state:4;
+		HDCP_TX_CONTENT_STREAM_TYPE contentType:1;
+		HDCP_TX_CONTENT_STREAM_STATUS content_status:2;
+		unsigned char statusWasUpdated:1;
+		unsigned char errorWasUpdated:1;
+		unsigned char ENABLE_1_1_FEATURES:1;
+		unsigned char ENABLE_1_1_FEATURES_onCurrentConnection:1;
+		unsigned char hdmi_mode:1;
+		unsigned char irq:1;
+	} fields;
+	unsigned int bits;
+} U_HDCP_TRANS_PORT_DATA_STATUS;
+
+/* struct holding data needed to the HDCP transmitter */
+#define TX_PORT_STATUS_EXTRA_DATA 3
+typedef struct {
+
+	U_HDCP_TRANS_PORT_DATA_STATUS status;
+	unsigned short port_status;
+	unsigned char port_status_extraData[TX_PORT_STATUS_EXTRA_DATA];
+	unsigned int seq_num_M;	/* for sending content stream manage */
+	unsigned int seq_num_V;
+	unsigned char rxTxBuffer[RX_TX_HDCP_TRANS_MAX_BUFFER];
+
+	unsigned char recieverIdListCommand[(128 * 5) + 4];
+	unsigned int recieverIdListSize;
+	MB_TYPE mailBoxType;
+
+} S_HDCP_TRANS_PORT_DATA;
+
+typedef struct {
+	S_HDCP_TRANS_PORT_DATA port[HDCP_TX_NUM_OF_PORTS];
+} S_HDCP_TRANS_DATA;
+
+/* HDCP TX ports working mode (HDCP 2.2 or 1.4) */
+
+/**
+ *
+ *  \brief transmitter supported API (via mail box)
+ */
+typedef enum {
+	HDCP_TX_CONFIGURATION,	/*!< use this command to set HDCP transmitter type and wake it up (or stop ), 1 byte with following bits :  Bit (0-1)= 0 - support only HDCP 2, 1 - support only HDCP 1, 2 - support both HDCP, Bit 2 - active (to activate port set to 1), to stop port set to 0 */
+	HDCP2_TX_SET_PUBLIC_KEY_PARAMS,	/*!< use it to set public key for the HDCP2.x transmitter(HDCP2.x), Modulus n - 384 bytes,  E - 3 bytes */
+	HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS,	/*!< use this command to enforce  the random parameters (for debug only!), instead of the random data generated by the embedded RNG.Use this command after HDCP_TX_SET_PUBLIC_KEY_PARAMS command. Relevant to (HDCP2.x), data is : KM 16 bytes,RN 8 bytes,KS 16 bytes,RIV 8 bytes,RTX 8 bytes */
+	HDCP2_TX_RESPOND_KM,	/*!< If km is stored, return all parameters, else there is no extra data(HDCP2.x), data is : Receiver ID (5 bytes),m (16 bytes),Km (16 bytes),Ekh(Km)(16 bytes) */
+	HDCP1_TX_SEND_KEYS,	/*!< send keys needed for HDCP 1, data is :  AKSV (5 bytes), ksv (7*40 = 280 bytes) */
+	HDCP1_TX_SEND_RANDOM_AN,	/*!< set AN, use it for debug purpose, if not use, it will be random number, data is (8 bytes) */
+	HDCP_TX_STATUS_CHANGE,	/*!< Will be called in port status change event by cadence HDCP IP, Status for the port:Bit 0 - AUTHENTICATED (1 - link is authenticated), Bit 1 - receiver is REPEATER (1 for repeater, 0 not),Bit 2 - 0 for HDCP1, 1 for HDCP2,     */
+	HDCP2_TX_IS_KM_STORED,	/*!< controller check if KM is stored by host(HDCP2.x), data is : Receiver ID (5 bytes) */
+	HDCP2_TX_STORE_KM,	/*!< controller ask host to store KM, host may store it on non-volatile memory for faster authentication(HDCP2.x), data is : Receiver ID (5 bytes),m (16 bytes),Km(16 bytes),Ekh(Km),(16 bytes) */
+	HDCP_TX_IS_RECEIVER_ID_VALID,	/*!< controller check if receivers ID are not in revocation list, input is->first byte for number of receivers, then list of receivers (5 bytes each) */
+	HDCP_TX_RESPOND_RECEIVER_ID_VALID,	/*!< If receivers ID are valid return 1, otherwise return 0, same for HDCP1,HDCP2 */
+	HDCP_TX_TEST_KEYS,	/*!< compare HDCP keys with facsimile key */
+	HDCP2_TX_SET_KM_KEY_PARAMS,	/*!< This Command is used to load customer defined Key for km-key encryption into the HDCP2.x transmitter controller. */
+} HDCP_TRNAS_MAIL_BOX_MSG;
+	  /** @} *///
+
+/* HDCP_TX_CONFIGURATION */
+
+/* bits 0-1 HDCP_TX_MODE */
+#define HDCP_TX_CONFIGURATION_MODE_OFFSET                       0
+#define HDCP_TX_CONFIGURATION_MODE_LEN                          2
+#define HDCP_TX_CONFIGURATION_RUN                               2
+#define HDCP_TX_CONFIGURATION_RPTR_CONTENT_STREAM_MNGR_OFFSET   3
+#define HDCP_TX_CONFIGURATION_RPTR                              4
+#define HDCP_TX_ENABLE_1_1_FEATURES                             5
+#define HDCP_TX_SECOND_LINK                                     6
+#define HDCP_TX_HDMI_MODE                                       7
+
+#define HDCP_TX_CONFIGURATION_ENABLE_KM_KEY_MASK (1 << 4)
+
+/* HDCP_TX_STATUS_CHANGE bits */
+#define HDCP_STATUS_AUTHENTICATED           0
+#define HDCP_STATUS_REPEATER                1
+#define HDCP_STATUS_HDCP2                   2
+#define HDCP_STATUS_STRAM_MANAGE_SUCCESS    4
+#define HDCP_STATUS_ERROR_TYPE              5
+#define HDCP_STATUS_1_1_FEATURES            9
+
+/**
+ *
+ *  \brief different error types for HDCP_TX_STATUS_CHANGE
+ */
+typedef enum {
+	HDCP_TRAN_ERR_No_error,
+	HDCP_TRAN_ERR_HPD_is_down,
+	HDCP_TRAN_ERR_SRM_failure,
+	HDCP_TRAN_ERR_signature_verification,
+	HDCP_TRAN_ERR_h_tag_diff_h,
+	HDCP_TRAN_ERR_v_tag_diff_v,
+	HDCP_TRAN_ERR_locality_check,
+	HDCP_TRAN_ERR_Ddc,
+	HDCP_TRAN_ERR_REAUTH_REQ,
+	HDCP_TRAN_ERR_topology,
+	HDCP_TRAN_ERR_HDCP_RSVD1,
+	HDCP_TRAN_ERR_HDMI_capability,
+	HDCP_TRAN_ERR_RI,
+	HDCP_TRAN_ERR_watchDog_expired,
+} HDCP_TRNAS_ERR_TYPE;
+
+/* HDCP2_TX_SET_PUBLIC_KEY_PARAMS */
+#define DLP_MODULUS_N 384
+#define DLP_E 3
+typedef struct {
+	unsigned char N[DLP_MODULUS_N];
+	unsigned char E[DLP_E];
+} S_HDCP_TRANS_PUBLIC_KEY_PARAMS;
+
+/* HDCP2_TX_SET_KM_KEY_PARAMS */
+#define DLP_KM_KEY 16
+typedef struct {
+	unsigned char KM_KEY[DLP_KM_KEY];
+} S_HDCP_TRANS_KM_KEY_PARAMS;
+
+/* HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS */
+#define DEBUG_RANDOM_NUMBERS_KM_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RN_LEN 8
+#define DEBUG_RANDOM_NUMBERS_KS_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RIV_LEN 8
+#define DEBUG_RANDOM_NUMBERS_RTX_LEN 8
+
+typedef struct {
+	unsigned char KM[DEBUG_RANDOM_NUMBERS_KM_LEN];
+	unsigned char RN[DEBUG_RANDOM_NUMBERS_RN_LEN];
+	unsigned char KS[DEBUG_RANDOM_NUMBERS_KS_LEN];
+	unsigned char RIV[DEBUG_RANDOM_NUMBERS_RIV_LEN];
+	unsigned char RTX[DEBUG_RANDOM_NUMBERS_RTX_LEN];
+} S_HDCP_TRANS_DEBUG_RANDOM_NUMBERS;
+
+#define HDCP_PAIRING_M_LEN 16
+#define HDCP_PAIRING_M_EKH 16
+#define HDCP_PAIRING_R_ID 5
+
+typedef struct {
+	unsigned char Receiver_ID[HDCP_PAIRING_R_ID];
+	unsigned char m[HDCP_PAIRING_M_LEN];
+	unsigned char KM[DEBUG_RANDOM_NUMBERS_KM_LEN];
+	unsigned char EKH[HDCP_PAIRING_M_EKH];
+} S_HDCP_TRANS_PAIRING_DATA;
+
+typedef struct {
+	unsigned char Receiver_ID[HDCP_PAIRING_R_ID];
+} S_HDCP_TRANS_REVOCATION_LIST;
+
+/* HDCP1_TX_SEND_KEYS */
+#define AKSV_SIZE (5)
+#define HDCPT1_KSV_SIZE (7 * 40)
+
+typedef struct {
+	unsigned char AKSV[AKSV_SIZE];
+	unsigned char KSV[HDCPT1_KSV_SIZE];
+} S_HDCP_TX_MAIL_BOX_CMD_HDCP1_TX_SEND_KEYS;
+
+#define AN_SIZE (8)
+
+/* HDCP2_TX_SESSION_KEY */
+#define HDCP_SESSION_KEY_LEN 16
+
+#endif //HDCP_TRAN_H
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/hdmi.h b/drivers/video/fbdev/mxc/cdn_hdp/hdmi.h
new file mode 100644
index 0000000..0330f85
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/hdmi.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * hdmi.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef _HDMI__
+#define _HDMI__
+/* ONLY ENUMS AND #DEFINES IN THIS FILE *
+ * THIS FILE WILL BE USED IN HOST'S API */
+
+#define EDID_SLAVE_ADDRESS                  0x50
+#define EDID_SEGMENT_SLAVE_ADDRESS          0x30
+#define SCDC_SLAVE_ADDRESS                  0x54
+
+typedef enum {
+	HDMI_TX_READ,
+	HDMI_TX_WRITE,
+	HDMI_TX_UPDATE_READ,
+	HDMI_TX_EDID,
+	HDMI_TX_EVENTS,
+	HDMI_TX_DEBUG_ECHO = 0xAA,
+	HDMI_TX_TEST = 0xBB,
+	HDMI_TX_EDID_INTERNAL = 0xF0,
+} HDMI_TX_OPCODE;
+
+typedef enum {
+	HDMI_I2C_ACK,
+	HDMI_I2C_NACK,
+	HDMI_I2C_TO,
+	HDMI_I2C_ARB_LOST,
+	HDMI_I2C_RRTO,
+	HDMI_I2C_RRT,
+    /** when i2c hardware didn't respond after some time */
+	HDMI_I2C_HW_TO,
+	HDMI_I2C_ERR,
+} HDMI_I2C_STATUS;
+
+typedef enum {
+	HDMI_RX_SET_EDID,
+	HDMI_RX_SCDC_SET,
+	HDMI_RX_SCDC_GET,
+	HDMI_RX_READ_EVENTS,
+	HDMI_RX_SET_HPD,
+
+	HDMI_RX_DEBUG_ECHO = 0xAA,
+	HDMI_RX_TEST = 0xBB,
+} HDMI_RX_OPCODE;
+
+typedef enum {
+	HDMI_SCDC_SINK_VER,
+	HDMI_SCDC_SOURCE_VER,
+} HDMI_SCDC_FIELD;
+
+typedef struct {
+	unsigned char sink_ver;
+	unsigned char manufacturer_oui_1;
+	unsigned char manufacturer_oui_2;
+	unsigned char manufacturer_oui_3;
+	unsigned char devId[8];
+	unsigned char hardware_major_rev;
+	unsigned char hardware_minor_rev;
+	unsigned char software_major_rev;
+	unsigned char software_minor_rev;
+	unsigned char manufacturerSpecific[34];
+} S_HDMI_SCDC_SET_MSG;
+
+typedef struct {
+	unsigned char source_ver;
+	unsigned char TMDS_Config;
+	unsigned char config_0;
+	unsigned char manufacturerSpecific[34];
+} S_HDMI_SCDC_GET_MSG;
+
+/* hpd events location */
+#define HDMI_RX_EVENT_5V_HIGH            0
+#define HDMI_RX_EVENT_5V_LOW             1
+#define HDMI_TX_EVENT_reserved           2
+#define HDMI_RX_EVENT_5V_VAL             3
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/mailBox.h b/drivers/video/fbdev/mxc/cdn_hdp/mailBox.h
new file mode 100644
index 0000000..4251372
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/mailBox.h
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * mailBox.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef MAIL_BOX_H
+#define MAIL_BOX_H
+
+#define MAIL_BOX_MAX_SIZE 600
+#define MAIL_BOX_MAX_TX_SIZE 160
+
+ /**
+ *  \file mailBox.h
+ *  \brief Implementation mail box communication channel between IP and external host
+ */
+
+#define MB_MODULE_ID_DP_TX          0x01
+#define MB_MODULE_ID_DP_RX          0x02
+#define MB_MODULE_ID_HDMI_TX        0x03
+#define MB_MODULE_ID_HDMI_RX        0x04
+#define MB_MODULE_ID_MHL_TX         0x05
+#define MB_MODULE_ID_MHL_RX         0x06
+#define MB_MODULE_ID_HDCP_TX        0x07
+#define MB_MODULE_ID_HDCP_RX        0x08
+#define MB_MODULE_ID_HDCP_GENERAL   0x09
+#define MB_MODULE_ID_GENERAL        0x0A
+
+typedef enum {
+	MB_TYPE_REGULAR,
+	MB_TYPE_SECURE,
+	MB_TYPE_COUNT,
+} MB_TYPE;
+
+typedef enum {
+	MB_SUCCESS,
+	MB_BUSY,
+	MB_NO_MEMORY
+} MB_RET;
+
+typedef enum {
+	MB_TO_HOST,
+	MB_TO_CONTROLLER,
+} MB_IDX;
+
+typedef enum {
+	MB_STATE_EMPTY,
+	MB_STATE_WAIT_MODULE_ID,
+	MB_STATE_WAIT_SIZE_MSB,
+	MB_STATE_WAIT_SIZE_LSB,
+	MB_STATE_READ_DATA,
+	MB_STATE_MSG_READY,
+} MB_RX_STATE;
+
+#define MB_OPCODE_ID 0
+#define MB_MODULE_ID 1
+#define MB_SIZE_MSB_ID 2
+#define MB_SIZE_LSB_ID 3
+#define MB_DATA_ID 4
+
+typedef struct {
+	MB_RX_STATE rxState;
+	unsigned int rx_data_idx;
+	unsigned int rx_final_msgSize;
+	unsigned char rxBuff[MAIL_BOX_MAX_SIZE];
+	unsigned char txBuff[MAIL_BOX_MAX_TX_SIZE];
+	unsigned int txTotal;
+	unsigned int txCur;
+} S_MAIL_BOX_PORT_DATA;
+
+typedef struct {
+	S_MAIL_BOX_PORT_DATA portData;
+	unsigned char portsTxBusy;	//bit for each port (0-7)
+} S_MAIL_BOX_DATA;
+
+#endif //MAIL_BOX_H
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/mhl_hdtx_top.h b/drivers/video/fbdev/mxc/cdn_hdp/mhl_hdtx_top.h
new file mode 100644
index 0000000..e5ae727
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/mhl_hdtx_top.h
@@ -0,0 +1,218 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * mhl_hdtx_top.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef MHL_HDTX_TOP_H_
+# define MHL_HDTX_TOP_H_
+
+/* register SCHEDULER_H_SIZE */
+# define SCHEDULER_H_SIZE 0
+# define F_H_BLANK_SIZE(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_H_BLANK_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_H_ACTIVE_SIZE(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_H_ACTIVE_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register SCHEDULER_V_SIZE */
+# define SCHEDULER_V_SIZE 1
+# define F_V_BLANK_SIZE(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_V_BLANK_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_V_ACTIVE_SIZE(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_V_ACTIVE_SIZE_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register SCHEDULER_KEEP_OUT */
+# define SCHEDULER_KEEP_OUT 2
+# define F_HKEEP_OUT(x) (((x) & ((1 << 9) - 1)) << 0)
+# define F_HKEEP_OUT_RD(x) (((x) & (((1 << 9) - 1) << 0)) >> 0)
+# define F_VKEEP_OUT_START(x) (((x) & ((1 << 11) - 1)) << 9)
+# define F_VKEEP_OUT_START_RD(x) (((x) & (((1 << 11) - 1) << 9)) >> 9)
+# define F_VKEEP_OUT_ZONE(x) (((x) & ((1 << 8) - 1)) << 20)
+# define F_VKEEP_OUT_ZONE_RD(x) (((x) & (((1 << 8) - 1) << 20)) >> 20)
+
+/* register HDTX_SIGNAL_FRONT_WIDTH */
+# define HDTX_SIGNAL_FRONT_WIDTH 3
+# define F_HFRONT(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_HFRONT_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_VFRONT(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_VFRONT_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDTX_SIGNAL_SYNC_WIDTH */
+# define HDTX_SIGNAL_SYNC_WIDTH 4
+# define F_HSYNC(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_HSYNC_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_VSYNC(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_VSYNC_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDTX_SIGNAL_BACK_WIDTH */
+# define HDTX_SIGNAL_BACK_WIDTH 5
+# define F_HBACK(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_HBACK_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_VBACK(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_VBACK_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDTX_CONTROLLER */
+# define HDTX_CONTROLLER 6
+# define F_HDMI_MODE(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_HDMI_MODE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+# define F_VIF_DATA_WIDTH(x) (((x) & ((1 << 2) - 1)) << 2)
+# define F_VIF_DATA_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+# define F_AUTO_MODE(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_AUTO_MODE_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_IL_PROG(x) (((x) & ((1 << 2) - 1)) << 5)
+# define F_IL_PROG_RD(x) (((x) & (((1 << 2) - 1) << 5)) >> 5)
+# define F_PIC_3D(x) (((x) & ((1 << 4) - 1)) << 7)
+# define F_PIC_3D_RD(x) (((x) & (((1 << 4) - 1) << 7)) >> 7)
+# define F_BCH_EN(x) (((x) & ((1 << 1) - 1)) << 11)
+# define F_BCH_EN_RD(x) (((x) & (((1 << 1) - 1) << 11)) >> 11)
+# define F_GCP_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+# define F_GCP_EN_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+# define F_SET_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 13)
+# define F_SET_AVMUTE_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+# define F_CLEAR_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 14)
+# define F_CLEAR_AVMUTE_RD(x) (((x) & (((1 << 1) - 1) << 14)) >> 14)
+# define F_DATA_EN(x) (((x) & ((1 << 1) - 1)) << 15)
+# define F_DATA_EN_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+# define F_HDMI_ENCODING(x) (((x) & ((1 << 2) - 1)) << 16)
+# define F_HDMI_ENCODING_RD(x) (((x) & (((1 << 2) - 1) << 16)) >> 16)
+# define F_HDMI2_PREAMBLE_EN(x) (((x) & ((1 << 1) - 1)) << 18)
+# define F_HDMI2_PREAMBLE_EN_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+# define F_HDMI2_CTRL_IL_MODE(x) (((x) & ((1 << 1) - 1)) << 19)
+# define F_HDMI2_CTRL_IL_MODE_RD(x) (((x) & (((1 << 1) - 1) << 19)) >> 19)
+
+/* register HDTX_HDCP */
+# define HDTX_HDCP 7
+# define F_HDTX_HDCP_SELECT(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_HDTX_HDCP_SELECT_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+# define F_ENC_BIT(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_ENC_BIT_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_HDCP_ENABLE_1P1_FEATURES(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_HDCP_ENABLE_1P1_FEATURES_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_HDCP_DELAY_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_HDCP_DELAY_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_HDCP_DELAY_FIFO_SW_START(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_HDCP_DELAY_FIFO_SW_START_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_HDCP_DOUBLE_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_HDCP_DOUBLE_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_HDCP_SINGLE_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_HDCP_SINGLE_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+# define F_HDCP_DELAY_FIFO_AFULL_THR(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_HDCP_DELAY_FIFO_AFULL_THR_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_HDCP_CTRL_SW_RST(x) (((x) & ((1 << 1) - 1)) << 12)
+# define F_HDCP_CTRL_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+# define F_HDCP_CTRL_IL_MODE(x) (((x) & ((1 << 1) - 1)) << 13)
+# define F_HDCP_CTRL_IL_MODE_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+
+/* register HDTX_HPD */
+# define HDTX_HPD 8
+# define F_HPD_VALID_WIDTH(x) (((x) & ((1 << 12) - 1)) << 0)
+# define F_HPD_VALID_WIDTH_RD(x) (((x) & (((1 << 12) - 1) << 0)) >> 0)
+# define F_HPD_GLITCH_WIDTH(x) (((x) & ((1 << 8) - 1)) << 12)
+# define F_HPD_GLITCH_WIDTH_RD(x) (((x) & (((1 << 8) - 1) << 12)) >> 12)
+
+/* register HDTX_CLOCK_REG_0 */
+# define HDTX_CLOCK_REG_0 9
+# define F_DATA_REGISTER_VAL_0(x) (((x) & ((1 << 20) - 1)) << 0)
+# define F_DATA_REGISTER_VAL_0_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register HDTX_CLOCK_REG_1 */
+# define HDTX_CLOCK_REG_1 10
+# define F_DATA_REGISTER_VAL_1(x) (((x) & ((1 << 20) - 1)) << 0)
+# define F_DATA_REGISTER_VAL_1_RD(x) (((x) & (((1 << 20) - 1) << 0)) >> 0)
+
+/* register HPD_PLUG_IN */
+# define HPD_PLUG_IN 11
+# define F_FILTER_HPD(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_FILTER_HPD_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register HDCP_IN */
+# define HDCP_IN 12
+# define F_HDCP_ESS_STATE(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_HDCP_ESS_STATE_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_HDCP_DOUBLE_FIFO_WFULL(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_HDCP_DOUBLE_FIFO_WFULL_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_HDCP_DOUBLE_FIFO_REMPTY(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_HDCP_DOUBLE_FIFO_REMPTY_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_HDCP_DOUBLE_FIFO_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_HDCP_DOUBLE_FIFO_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_HDCP_DOUBLE_FIFO_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_HDCP_DOUBLE_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+# define F_HDCP_DELAY_FIFO_EMPTY(x) (((x) & ((1 << 1) - 1)) << 8)
+# define F_HDCP_DELAY_FIFO_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+# define F_HDCP_DELAY_FIFO_FULL(x) (((x) & ((1 << 1) - 1)) << 9)
+# define F_HDCP_DELAY_FIFO_FULL_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+# define F_HDCP_SINGLE_FIFO_WFULL(x) (((x) & ((1 << 2) - 1)) << 10)
+# define F_HDCP_SINGLE_FIFO_WFULL_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+# define F_HDCP_SINGLE_FIFO_REMPTY(x) (((x) & ((1 << 2) - 1)) << 12)
+# define F_HDCP_SINGLE_FIFO_REMPTY_RD(x) (((x) & (((1 << 2) - 1) << 12)) >> 12)
+# define F_HDCP_SINGLE_FIFO_OVERRUN(x) (((x) & ((1 << 2) - 1)) << 14)
+# define F_HDCP_SINGLE_FIFO_OVERRUN_RD(x) (((x) & (((1 << 2) - 1) << 14)) >> 14)
+# define F_HDCP_SINGLE_FIFO_UNDERRUN(x) (((x) & ((1 << 2) - 1)) << 16)
+# define F_HDCP_SINGLE_FIFO_UNDERRUN_RD(x) (((x) & (((1 << 2) - 1) << 16)) >> 16)
+
+/* register GCP_FORCE_COLOR_DEPTH_CODING */
+# define GCP_FORCE_COLOR_DEPTH_CODING 13
+# define F_COLOR_DEPTH_VAL(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_COLOR_DEPTH_VAL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_COLOR_DEPTH_FORCE(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_COLOR_DEPTH_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_DEFAULT_PHASE_VAL(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_DEFAULT_PHASE_VAL_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+
+/* register SSCP_POSITIONING */
+# define SSCP_POSITIONING 14
+# define F_SSCP_ROW_VAL(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_SSCP_ROW_VAL_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+# define F_SSCP_COL_VAL(x) (((x) & ((1 << 16) - 1)) << 16)
+# define F_SSCP_COL_VAL_RD(x) (((x) & (((1 << 16) - 1) << 16)) >> 16)
+
+/* register HDCP_WIN_OF_OPP_POSITION */
+# define HDCP_WIN_OF_OPP_POSITION 15
+# define F_HDCP_WIN_OF_OPP_START(x) (((x) & ((1 << 10) - 1)) << 0)
+# define F_HDCP_WIN_OF_OPP_START_RD(x) (((x) & (((1 << 10) - 1) << 0)) >> 0)
+# define F_HDCP_WIN_OF_OPP_SIZE(x) (((x) & ((1 << 6) - 1)) << 10)
+# define F_HDCP_WIN_OF_OPP_SIZE_RD(x) (((x) & (((1 << 6) - 1) << 10)) >> 10)
+
+#endif //MHL_HDTX_TOP
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/opcodes.h b/drivers/video/fbdev/mxc/cdn_hdp/opcodes.h
new file mode 100644
index 0000000..04da5ac
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/opcodes.h
@@ -0,0 +1,115 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * opcodes.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef OPCODES_H_
+#define OPCODES_H_
+
+#define DP_TX_MAIL_HANDLER_H
+#define DP_TX_MAIL_HANDLER_REQUEST_BUFFER_LEN 256
+#define DPTX_SET_POWER_MNG              0x00
+#define DPTX_SET_HOST_CAPABILITIES      0x01
+#define DPTX_GET_EDID                   0x02
+#define DPTX_READ_DPCD                  0x03
+#define DPTX_WRITE_DPCD                 0x04
+#define DPTX_ENABLE_EVENT               0x05
+#define DPTX_WRITE_REGISTER             0x06
+#define DPTX_READ_REGISTER              0x07
+#define DPTX_WRITE_FIELD                0x08
+#define DPTX_TRAINING_CONTROL           0x09
+#define DPTX_READ_EVENT                 0x0A
+#define DPTX_READ_LINK_STAT                0x0B
+#define DPTX_SET_VIDEO                    0x0C
+#define DPTX_SET_AUDIO                    0x0D
+#define DPTX_GET_LAST_AUX_STAUS            0x0E
+#define DPTX_SET_LINK_BREAK_POINT        0x0F
+#define DPTX_FORCE_LANES                0x10
+#define DPTX_HPD_STATE                             0x11
+#define DPTX_DBG_SET                               0xF0
+#define DP_TX_OPCODE_READ_I2C_REQUEST              0xA5
+#define DP_TX_OPCODE_WRITE_I2C_REQUEST             0xA6
+#define DP_TX_OPCODE_MESSAGE_FILTER                0xA7
+#define DPTX_EDID_RESP                             0x02
+#define DPTX_DPCD_READ_RESP                        0x03
+#define DPTX_DPCD_WRITE_RESP                       0x04
+#define DPTX_READ_EVENT_RESP                       0x0A
+#define DPTX_READ_REGISTER_RESP                    0x07
+#define DP_TX_OPCODE_MESSAGE                       0x10
+#define DP_TX_OPCODE_READ_I2C_RESPONSE             0x50
+#define DP_TX_OPCODE_WRITE_I2C_RESPONSE            0x60
+#define DP_TX_OPCODE_LOOPBACK_TEST                 0xFE
+#define DP_TX_OPCODE_BIT_TEST                      0xFF
+#define DP_TX_EVENT_ENABLE_HPD_BIT                 0x00
+#define DP_TX_EVENT_ENABLE_TRAINING_BIT            0x01
+#define DP_TX_EVENT_CODE_HPD_HIGH                  0x01
+#define DP_TX_EVENT_CODE_HPD_LOW                   0x02
+#define DP_TX_EVENT_CODE_HPD_PULSE                 0x04
+#define DP_TX_EVENT_CODE_HPD_STATE_HIGH            0x08
+#define DP_TX_EVENT_CODE_HPD_STATE_LOW             0x00
+#define DP_TX_EVENT_CODE_TRAINING_FULL_STARTED     0x01
+#define DP_TX_EVENT_CODE_TRAINING_FAST_STARTED     0x02
+#define DP_TX_EVENT_CODE_TRAINING_FINISHED_CR      0x04
+#define DP_TX_EVENT_CODE_TRAINING_FINISHED_EQ      0x08
+#define DP_TX_EVENT_CODE_TRAINING_FINISHED_FAST    0x10
+#define DP_TX_EVENT_CODE_TRAINING_FAILED_CR        0x20
+#define DP_TX_EVENT_CODE_TRAINING_FAILED_EQ        0x40
+#define DP_TX_EVENT_CODE_TRAINING_FAILED_FAST      0x80
+#define MB_MODULE_ID_DP_TX                         0x01
+#define MB_MODULE_ID_DP_RX                         0x02
+#define MB_MODULE_ID_HDMI_TX                       0x03
+#define MB_MODULE_ID_HDMI_RX                       0x04
+#define MB_MODULE_ID_MHL_TX                        0x05
+#define MB_MODULE_ID_MHL_RX                        0x06
+#define MB_MODULE_ID_HDCP_TX                       0x07
+#define MB_MODULE_ID_HDCP_RX                       0x08
+#define MB_MODULE_ID_HDCP_GENERAL                  0x09
+#define MB_MODULE_ID_GENERAL                       0x0A
+#define MB_MODULE_ID                               1
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/source_aif_decoder.h b/drivers/video/fbdev/mxc/cdn_hdp/source_aif_decoder.h
new file mode 100644
index 0000000..a0d5e49
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/source_aif_decoder.h
@@ -0,0 +1,452 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_aif_decoder.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_AIF_DECODER_H_
+# define SOURCE_AIF_DECODER_H_
+
+/* register AUDIO_SRC_CNTL */
+# define AUDIO_SRC_CNTL 0
+# define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_I2S_DEC_START(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_I2S_DEC_START_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_I2S_BLOCK_START_FORCE(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_I2S_BLOCK_START_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_SPDIF_TS_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_SPDIF_TS_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_I2S_TS_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_I2S_TS_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_VALID_BITS_FORCE(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_VALID_BITS_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_VALID_ALL(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_VALID_ALL_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+
+/* register AUDIO_SRC_CNFG */
+# define AUDIO_SRC_CNFG 1
+# define F_LOW_INDEX_MSB(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_LOW_INDEX_MSB_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_WS_POLARITY(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_WS_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_AUDIO_CH_NUM(x) (((x) & ((1 << 5) - 1)) << 2)
+# define F_AUDIO_CH_NUM_RD(x) (((x) & (((1 << 5) - 1) << 2)) >> 2)
+# define F_AUDIO_SAMPLE_JUST(x) (((x) & ((1 << 2) - 1)) << 7)
+# define F_AUDIO_SAMPLE_JUST_RD(x) (((x) & (((1 << 2) - 1) << 7)) >> 7)
+# define F_AUDIO_SAMPLE_WIDTH(x) (((x) & ((1 << 2) - 1)) << 9)
+# define F_AUDIO_SAMPLE_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 9)) >> 9)
+# define F_TRANS_SMPL_WIDTH(x) (((x) & ((1 << 2) - 1)) << 11)
+# define F_TRANS_SMPL_WIDTH_RD(x) (((x) & (((1 << 2) - 1) << 11)) >> 11)
+# define F_AUDIO_CHANNEL_TYPE(x) (((x) & ((1 << 4) - 1)) << 13)
+# define F_AUDIO_CHANNEL_TYPE_RD(x) (((x) & (((1 << 4) - 1) << 13)) >> 13)
+# define F_I2S_DEC_PORT_EN(x) (((x) & ((1 << 4) - 1)) << 17)
+# define F_I2S_DEC_PORT_EN_RD(x) (((x) & (((1 << 4) - 1) << 17)) >> 17)
+
+/* register COM_CH_STTS_BITS */
+# define COM_CH_STTS_BITS 2
+# define F_BYTE0(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_BYTE0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_CATEGORY_CODE(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_CATEGORY_CODE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_SAMPLING_FREQ(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_SAMPLING_FREQ_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_CLOCK_ACCURACY(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_CLOCK_ACCURACY_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_ORIGINAL_SAMP_FREQ(x) (((x) & ((1 << 4) - 1)) << 24)
+# define F_ORIGINAL_SAMP_FREQ_RD(x) (((x) & (((1 << 4) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH01 */
+# define STTS_BIT_CH01 3
+# define F_SOURCE_NUM_CH0(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH0_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH0(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH0_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH0(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH0_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH1(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH1_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH1(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH1_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH1(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH1_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS1_0(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS1_0_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH23 */
+# define STTS_BIT_CH23 4
+# define F_SOURCE_NUM_CH2(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH2_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH2(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH2_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH2(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH2_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH3(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH3_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH3(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH3_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH3(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH3_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS3_2(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS3_2_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH45 */
+# define STTS_BIT_CH45 5
+# define F_SOURCE_NUM_CH4(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH4_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH4(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH4_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH4(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH4_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH5(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH5_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH5(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH5_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH5(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH5_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS5_4(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS5_4_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH67 */
+# define STTS_BIT_CH67 6
+# define F_SOURCE_NUM_CH6(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH6_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH6(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH6_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH6(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH6_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH7(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH7_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH7(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH7_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH7(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH7_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS7_6(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS7_6_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH89 */
+# define STTS_BIT_CH89 7
+# define F_SOURCE_NUM_CH8(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH8_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH8(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH8_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH8(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH8_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH9(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH9_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH9(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH9_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH9(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH9_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS9_8(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS9_8_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1011 */
+# define STTS_BIT_CH1011 8
+# define F_SOURCE_NUM_CH10(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH10_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH10(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH10_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH10(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH10_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH11(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH11_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH11(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH11_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH11(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH11_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS11_10(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS11_10_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1213 */
+# define STTS_BIT_CH1213 9
+# define F_SOURCE_NUM_CH12(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH12_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH12(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH12_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH12(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH12_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH13(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH13_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH13(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH13_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH13(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH13_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS13_12(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS13_12_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1415 */
+# define STTS_BIT_CH1415 10
+# define F_SOURCE_NUM_CH14(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH14_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH14(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH14_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH14(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH14_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH15(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH15_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH15(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH15_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH15(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH15_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS15_14(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS15_14_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1617 */
+# define STTS_BIT_CH1617 11
+# define F_SOURCE_NUM_CH16(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH16_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH16(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH16_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH16(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH16_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH17(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH17_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH17(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH17_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH17(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH17_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS17_16(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS17_16_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH1819 */
+# define STTS_BIT_CH1819 12
+# define F_SOURCE_NUM_CH18(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH18_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH18(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH18_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH18(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH18_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH19(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH19_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH19(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH19_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH19(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH19_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS19_18(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS19_18_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2021 */
+# define STTS_BIT_CH2021 13
+# define F_SOURCE_NUM_CH20(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH20_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH20(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH20_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH20(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH20_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH21(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH21_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH21(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH21_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH21(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH21_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS21_20(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS21_20_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2223 */
+# define STTS_BIT_CH2223 14
+# define F_SOURCE_NUM_CH22(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH22_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH22(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH22_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH22(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH22_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH23(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH23_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH23(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH23_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH23(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH23_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS23_22(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS23_22_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2425 */
+# define STTS_BIT_CH2425 15
+# define F_SOURCE_NUM_CH24(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH24_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH24(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH24_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH24(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH24_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH25(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH25_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH25(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH25_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH25(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH25_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS25_24(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS25_24_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2627 */
+# define STTS_BIT_CH2627 16
+# define F_SOURCE_NUM_CH26(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH26_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH26(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH26_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH26(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH26_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH27(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH27_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH27(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH27_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH27(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH27_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS27_26(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS27_26_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH2829 */
+# define STTS_BIT_CH2829 17
+# define F_SOURCE_NUM_CH28(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH28_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH28(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH28_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH28(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH28_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH29(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH29_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH29(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH29_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH29(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH29_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS29_28(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS29_28_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register STTS_BIT_CH3031 */
+# define STTS_BIT_CH3031 18
+# define F_SOURCE_NUM_CH30(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_NUM_CH30_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_CHANNEL_NUM_CH30(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_CHANNEL_NUM_CH30_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_WORD_LENGTH_CH30(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_WORD_LENGTH_CH30_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_NUM_CH31(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_NUM_CH31_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_CHANNEL_NUM_CH31(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CHANNEL_NUM_CH31_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_WORD_LENGTH_CH31(x) (((x) & ((1 << 4) - 1)) << 20)
+# define F_WORD_LENGTH_CH31_RD(x) (((x) & (((1 << 4) - 1) << 20)) >> 20)
+# define F_VALID_BITS31_30(x) (((x) & ((1 << 2) - 1)) << 24)
+# define F_VALID_BITS31_30_RD(x) (((x) & (((1 << 2) - 1) << 24)) >> 24)
+
+/* register SPDIF_CTRL_ADDR */
+# define SPDIF_CTRL_ADDR 19
+# define F_SPDIF_JITTER_AVG_WIN(x) (((x) & ((1 << 3) - 1)) << 0)
+# define F_SPDIF_JITTER_AVG_WIN_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+# define F_SPDIF_JITTER_THRSH(x) (((x) & ((1 << 8) - 1)) << 3)
+# define F_SPDIF_JITTER_THRSH_RD(x) (((x) & (((1 << 8) - 1) << 3)) >> 3)
+# define F_SPDIF_FIFO_MID_RANGE(x) (((x) & ((1 << 8) - 1)) << 11)
+# define F_SPDIF_FIFO_MID_RANGE_RD(x) (((x) & (((1 << 8) - 1) << 11)) >> 11)
+# define F_SPDIF_JITTER_BYPASS(x) (((x) & ((1 << 1) - 1)) << 19)
+# define F_SPDIF_JITTER_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 19)) >> 19)
+# define F_SPDIF_AVG_SEL(x) (((x) & ((1 << 1) - 1)) << 20)
+# define F_SPDIF_AVG_SEL_RD(x) (((x) & (((1 << 1) - 1) << 20)) >> 20)
+# define F_SPDIF_ENABLE(x) (((x) & ((1 << 1) - 1)) << 21)
+# define F_SPDIF_ENABLE_RD(x) (((x) & (((1 << 1) - 1) << 21)) >> 21)
+# define F_SPDIF_JITTER_STATUS(x) (((x) & ((1 << 4) - 1)) << 22)
+# define F_SPDIF_JITTER_STATUS_RD(x) (((x) & (((1 << 4) - 1) << 22)) >> 22)
+
+/* register SPDIF_CH1_CS_3100_ADDR */
+# define SPDIF_CH1_CS_3100_ADDR 20
+# define F_SPDIF_CH1_ST_STTS_BITS3100(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH1_ST_STTS_BITS3100_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_6332_ADDR */
+# define SPDIF_CH1_CS_6332_ADDR 21
+# define F_SPDIF_CH1_ST_STTS_BITS6332(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH1_ST_STTS_BITS6332_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_9564_ADDR */
+# define SPDIF_CH1_CS_9564_ADDR 22
+# define F_SPDIF_CH1_ST_STTS_BITS9564(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH1_ST_STTS_BITS9564_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_12796_ADDR */
+# define SPDIF_CH1_CS_12796_ADDR 23
+# define F_SPDIF_CH1_ST_STTS_BITS12796(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH1_ST_STTS_BITS12796_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_159128_ADDR */
+# define SPDIF_CH1_CS_159128_ADDR 24
+# define F_SPDIF_CH1_ST_STTS_BITS159128(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH1_ST_STTS_BITS159128_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH1_CS_191160_ADDR */
+# define SPDIF_CH1_CS_191160_ADDR 25
+# define F_SPDIF_CH1_ST_STTS_BITS191160(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH1_ST_STTS_BITS191160_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_3100_ADDR */
+# define SPDIF_CH2_CS_3100_ADDR 26
+# define F_SPDIF_CH2_ST_STTS_BITS3100(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH2_ST_STTS_BITS3100_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_6332_ADDR */
+# define SPDIF_CH2_CS_6332_ADDR 27
+# define F_SPDIF_CH2_ST_STTS_BITS6332(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH2_ST_STTS_BITS6332_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_9564_ADDR */
+# define SPDIF_CH2_CS_9564_ADDR 28
+# define F_SPDIF_CH2_ST_STTS_BITS9564(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH2_ST_STTS_BITS9564_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_12796_ADDR */
+# define SPDIF_CH2_CS_12796_ADDR 29
+# define F_SPDIF_CH2_ST_STTS_BITS12796(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH2_ST_STTS_BITS12796_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_159128_ADDR */
+# define SPDIF_CH2_CS_159128_ADDR 30
+# define F_SPDIF_CH2_ST_STTS_BITS159128(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH2_ST_STTS_BITS159128_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+/* register SPDIF_CH2_CS_191160_ADDR */
+# define SPDIF_CH2_CS_191160_ADDR 31
+# define F_SPDIF_CH2_ST_STTS_BITS191160(x) (((x) & ((1 << 32) - 1)) << 0)
+# define F_SPDIF_CH2_ST_STTS_BITS191160_RD(x) (((x) & (((1 << 32) - 1) << 0)) >> 0)
+
+#endif //SOURCE_AIF_DECODER
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/source_aif_smpl2pckt.h b/drivers/video/fbdev/mxc/cdn_hdp/source_aif_smpl2pckt.h
new file mode 100644
index 0000000..c0b40d1
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/source_aif_smpl2pckt.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_aif_smpl2pckt.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_AIF_SMPL2PCKT_H_
+# define SOURCE_AIF_SMPL2PCKT_H_
+
+/* register SMPL2PKT_CNTL */
+# define SMPL2PKT_CNTL 0
+# define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SMPL2PKT_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SMPL2PKT_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SMPL2PKT_CNFG */
+# define SMPL2PKT_CNFG 1
+# define F_MAX_NUM_CH(x) (((x) & ((1 << 5) - 1)) << 0)
+# define F_MAX_NUM_CH_RD(x) (((x) & (((1 << 5) - 1) << 0)) >> 0)
+# define F_NUM_OF_I2S_PORTS_S(x) (((x) & ((1 << 2) - 1)) << 5)
+# define F_NUM_OF_I2S_PORTS_RD_S(x) (((x) & (((1 << 2) - 1) << 5)) >> 5)
+# define F_AUDIO_TYPE(x) (((x) & ((1 << 4) - 1)) << 7)
+# define F_AUDIO_TYPE_RD(x) (((x) & (((1 << 4) - 1) << 7)) >> 7)
+# define F_CFG_SUB_PCKT_NUM(x) (((x) & ((1 << 3) - 1)) << 11)
+# define F_CFG_SUB_PCKT_NUM_RD(x) (((x) & (((1 << 3) - 1) << 11)) >> 11)
+# define F_CFG_BLOCK_LPCM_FIRST_PKT(x) (((x) & ((1 << 1) - 1)) << 14)
+# define F_CFG_BLOCK_LPCM_FIRST_PKT_RD(x) (((x) & (((1 << 1) - 1) << 14)) >> 14)
+# define F_CFG_EN_AUTO_SUB_PCKT_NUM(x) (((x) & ((1 << 1) - 1)) << 15)
+# define F_CFG_EN_AUTO_SUB_PCKT_NUM_RD(x) (((x) & (((1 << 1) - 1) << 15)) >> 15)
+# define F_CFG_SAMPLE_PRESENT(x) (((x) & ((1 << 4) - 1)) << 16)
+# define F_CFG_SAMPLE_PRESENT_RD(x) (((x) & (((1 << 4) - 1) << 16)) >> 16)
+# define F_CFG_SAMPLE_PRESENT_FORCE(x) (((x) & ((1 << 1) - 1)) << 20)
+# define F_CFG_SAMPLE_PRESENT_FORCE_RD(x) (((x) & (((1 << 1) - 1) << 20)) >> 20)
+
+/* register FIFO_CNTL */
+# define FIFO_CNTL 2
+# define F_FIFO_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_FIFO_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SYNC_WR_TO_CH_ZERO(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SYNC_WR_TO_CH_ZERO_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_FIFO_DIR(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_FIFO_DIR_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_FIFO_EMPTY_CALC(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_FIFO_EMPTY_CALC_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_CFG_DIS_PORT3(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_CFG_DIS_PORT3_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+
+/* register FIFO_STTS */
+# define FIFO_STTS 3
+# define F_WFULL(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_WFULL_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_REMPTY(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_REMPTY_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_OVERRUN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_OVERRUN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_UNDERRUN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_UNDERRUN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SUB_PCKT_THRSH */
+# define SUB_PCKT_THRSH 4
+# define F_CFG_MEM_FIFO_THRSH1(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_CFG_MEM_FIFO_THRSH1_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_CFG_MEM_FIFO_THRSH2(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_CFG_MEM_FIFO_THRSH2_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_CFG_MEM_FIFO_THRSH3(x) (((x) & ((1 << 8) - 1)) << 16)
+# define F_CFG_MEM_FIFO_THRSH3_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+
+#endif //SOURCE_AIF_SMPL2PCKT
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/source_car.h b/drivers/video/fbdev/mxc/cdn_hdp/source_car.h
new file mode 100644
index 0000000..a63fc47
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/source_car.h
@@ -0,0 +1,173 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_car.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_CAR_H_
+# define SOURCE_CAR_H_
+
+/* register SOURCE_HDTX_CAR */
+# define SOURCE_HDTX_CAR 0
+# define F_HDTX_PIXEL_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_HDTX_PIXEL_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_HDTX_PIXEL_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_HDTX_PIXEL_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_HDTX_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_HDTX_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_HDTX_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_HDTX_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_HDTX_PHY_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_HDTX_PHY_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_HDTX_PHY_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_HDTX_PHY_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_HDTX_PHY_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_HDTX_PHY_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_HDTX_PHY_CHAR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_HDTX_PHY_CHAR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register SOURCE_DPTX_CAR */
+# define SOURCE_DPTX_CAR 1
+# define F_CFG_DPTX_VIF_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_CFG_DPTX_VIF_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_CFG_DPTX_VIF_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_CFG_DPTX_VIF_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_DPTX_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_DPTX_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_DPTX_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_DPTX_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_SOURCE_AUX_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_SOURCE_AUX_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_SOURCE_AUX_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_SOURCE_AUX_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_DPTX_PHY_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_DPTX_PHY_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_DPTX_PHY_CHAR_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_DPTX_PHY_CHAR_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+# define F_DPTX_PHY_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 8)
+# define F_DPTX_PHY_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+# define F_DPTX_PHY_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 9)
+# define F_DPTX_PHY_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+# define F_DPTX_FRMR_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 10)
+# define F_DPTX_FRMR_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 10)) >> 10)
+# define F_DPTX_FRMR_DATA_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 11)
+# define F_DPTX_FRMR_DATA_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 11)) >> 11)
+
+/* register SOURCE_PHY_CAR */
+# define SOURCE_PHY_CAR 2
+# define F_SOURCE_PHY_DATA_OUT_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_PHY_DATA_OUT_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_DATA_OUT_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_PHY_DATA_OUT_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_SOURCE_PHY_CHAR_OUT_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_SOURCE_PHY_CHAR_OUT_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_SOURCE_PHY_CHAR_OUT_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_SOURCE_PHY_CHAR_OUT_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_CEC_CAR */
+# define SOURCE_CEC_CAR 3
+# define F_SOURCE_CEC_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_CEC_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_CEC_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_CEC_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SOURCE_CBUS_CAR */
+# define SOURCE_CBUS_CAR 4
+# define F_SOURCE_CBUS_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_CBUS_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_CBUS_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_CBUS_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+/* register SOURCE_PKT_CAR */
+# define SOURCE_PKT_CAR 6
+# define F_SOURCE_PKT_DATA_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_PKT_DATA_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_PKT_DATA_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_PKT_DATA_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_SOURCE_PKT_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_SOURCE_PKT_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_SOURCE_PKT_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_SOURCE_PKT_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_AIF_CAR */
+# define SOURCE_AIF_CAR 7
+# define F_SOURCE_AIF_PKT_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_AIF_PKT_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_AIF_PKT_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_AIF_PKT_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_SOURCE_AIF_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_SOURCE_AIF_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_SOURCE_AIF_SYS_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_SOURCE_AIF_SYS_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_SPDIF_CDR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_SPDIF_CDR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_SPDIF_CDR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_SPDIF_CDR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_SPDIF_MCLK_EN(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_SPDIF_MCLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_SPDIF_MCLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_SPDIF_MCLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+
+/* register SOURCE_CIPHER_CAR */
+# define SOURCE_CIPHER_CAR 8
+# define F_SOURCE_CIPHER_CHAR_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_CIPHER_CHAR_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_CIPHER_CHAR_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_CIPHER_CHAR_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_SOURCE_CIPHER_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_SOURCE_CIPHER_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_CRYPTO_CAR */
+# define SOURCE_CRYPTO_CAR 9
+# define F_SOURCE_CRYPTO_SYS_CLK_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SOURCE_CRYPTO_SYS_CLK_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_SOURCE_CRYPTO_SYS_CLK_RSTN_EN(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_SOURCE_CRYPTO_SYS_CLK_RSTN_EN_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+
+#endif //SOURCE_CAR
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/source_phy.h b/drivers/video/fbdev/mxc/cdn_hdp/source_phy.h
new file mode 100644
index 0000000..717d5fa
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/source_phy.h
@@ -0,0 +1,180 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_phy.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_PHY_H_
+# define SOURCE_PHY_H_
+
+/* register SHIFT_PATTERN_IN_3_0 */
+# define SHIFT_PATTERN_IN_3_0 0
+# define F_SOURCE_PHY_SHIFT_PATTERN0(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SOURCE_PHY_SHIFT_PATTERN0_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_SHIFT_PATTERN1(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_SOURCE_PHY_SHIFT_PATTERN1_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_SOURCE_PHY_SHIFT_PATTERN2(x) (((x) & ((1 << 8) - 1)) << 16)
+# define F_SOURCE_PHY_SHIFT_PATTERN2_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+# define F_SOURCE_PHY_SHIFT_PATTERN3(x) (((x) & ((1 << 8) - 1)) << 24)
+# define F_SOURCE_PHY_SHIFT_PATTERN3_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register SHIFT_PATTERN_IN_4_7 */
+# define SHIFT_PATTERN_IN_4_7 1
+# define F_SOURCE_PHY_SHIFT_PATTERN4(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SOURCE_PHY_SHIFT_PATTERN4_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_SHIFT_PATTERN5(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_SOURCE_PHY_SHIFT_PATTERN5_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_SOURCE_PHY_SHIFT_PATTERN6(x) (((x) & ((1 << 8) - 1)) << 16)
+# define F_SOURCE_PHY_SHIFT_PATTERN6_RD(x) (((x) & (((1 << 8) - 1) << 16)) >> 16)
+# define F_SOURCE_PHY_SHIFT_PATTERN7(x) (((x) & ((1 << 8) - 1)) << 24)
+# define F_SOURCE_PHY_SHIFT_PATTERN7_RD(x) (((x) & (((1 << 8) - 1) << 24)) >> 24)
+
+/* register SHIFT_PATTERN_IN9_8 */
+# define SHIFT_PATTERN_IN9_8 2
+# define F_SOURCE_PHY_SHIFT_PATTERN8(x) (((x) & ((1 << 8) - 1)) << 0)
+# define F_SOURCE_PHY_SHIFT_PATTERN8_RD(x) (((x) & (((1 << 8) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_SHIFT_PATTERN9(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_SOURCE_PHY_SHIFT_PATTERN9_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_SOURCE_PHY_SHIFT_LOAD(x) (((x) & ((1 << 1) - 1)) << 16)
+# define F_SOURCE_PHY_SHIFT_LOAD_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+# define F_SOURCE_PHY_SHIFT_EN(x) (((x) & ((1 << 1) - 1)) << 17)
+# define F_SOURCE_PHY_SHIFT_EN_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+# define F_SOURCE_PHY_SHIFT_REPETITION(x) (((x) & ((1 << 3) - 1)) << 18)
+# define F_SOURCE_PHY_SHIFT_REPETITION_RD(x) (((x) & (((1 << 3) - 1) << 18)) >> 18)
+
+/* register PRBS_CNTRL */
+# define PRBS_CNTRL 3
+# define F_SOURCE_PHY_PRBS0_MODE(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_SOURCE_PHY_PRBS0_MODE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_PRBS0_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 2)
+# define F_SOURCE_PHY_PRBS0_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+# define F_SOURCE_PHY_PRBS1_MODE(x) (((x) & ((1 << 2) - 1)) << 4)
+# define F_SOURCE_PHY_PRBS1_MODE_RD(x) (((x) & (((1 << 2) - 1) << 4)) >> 4)
+# define F_SOURCE_PHY_PRBS1_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 6)
+# define F_SOURCE_PHY_PRBS1_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+# define F_SOURCE_PHY_PRBS2_MODE(x) (((x) & ((1 << 2) - 1)) << 8)
+# define F_SOURCE_PHY_PRBS2_MODE_RD(x) (((x) & (((1 << 2) - 1) << 8)) >> 8)
+# define F_SOURCE_PHY_PRBS2_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 10)
+# define F_SOURCE_PHY_PRBS2_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 10)) >> 10)
+# define F_SOURCE_PHY_PRBS3_MODE(x) (((x) & ((1 << 2) - 1)) << 12)
+# define F_SOURCE_PHY_PRBS3_MODE_RD(x) (((x) & (((1 << 2) - 1) << 12)) >> 12)
+# define F_SOURCE_PHY_PRBS3_OUT_MODE(x) (((x) & ((1 << 2) - 1)) << 14)
+# define F_SOURCE_PHY_PRBS3_OUT_MODE_RD(x) (((x) & (((1 << 2) - 1) << 14)) >> 14)
+
+/* register PRBS_ERR_INSERTION */
+# define PRBS_ERR_INSERTION 4
+# define F_ADD_ERROR0(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_ADD_ERROR0_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_NUMBER_OF_ERRORS0(x) (((x) & ((1 << 5) - 1)) << 1)
+# define F_NUMBER_OF_ERRORS0_RD(x) (((x) & (((1 << 5) - 1) << 1)) >> 1)
+# define F_ADD_ERROR1(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_ADD_ERROR1_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_NUMBER_OF_ERRORS1(x) (((x) & ((1 << 5) - 1)) << 7)
+# define F_NUMBER_OF_ERRORS1_RD(x) (((x) & (((1 << 5) - 1) << 7)) >> 7)
+# define F_ADD_ERROR2(x) (((x) & ((1 << 1) - 1)) << 12)
+# define F_ADD_ERROR2_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+# define F_NUMBER_OF_ERRORS2(x) (((x) & ((1 << 5) - 1)) << 13)
+# define F_NUMBER_OF_ERRORS2_RD(x) (((x) & (((1 << 5) - 1) << 13)) >> 13)
+# define F_ADD_ERROR3(x) (((x) & ((1 << 1) - 1)) << 18)
+# define F_ADD_ERROR3_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+# define F_NUMBER_OF_ERRORS3(x) (((x) & ((1 << 5) - 1)) << 19)
+# define F_NUMBER_OF_ERRORS3_RD(x) (((x) & (((1 << 5) - 1) << 19)) >> 19)
+
+/* register LANES_CONFIG */
+# define LANES_CONFIG 5
+# define F_SOURCE_PHY_LANE0_SWAP(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_SOURCE_PHY_LANE0_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_LANE1_SWAP(x) (((x) & ((1 << 2) - 1)) << 2)
+# define F_SOURCE_PHY_LANE1_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 2)) >> 2)
+# define F_SOURCE_PHY_LANE2_SWAP(x) (((x) & ((1 << 2) - 1)) << 4)
+# define F_SOURCE_PHY_LANE2_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 4)) >> 4)
+# define F_SOURCE_PHY_LANE3_SWAP(x) (((x) & ((1 << 2) - 1)) << 6)
+# define F_SOURCE_PHY_LANE3_SWAP_RD(x) (((x) & (((1 << 2) - 1) << 6)) >> 6)
+# define F_SOURCE_PHY_LANE0_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 8)
+# define F_SOURCE_PHY_LANE0_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+# define F_SOURCE_PHY_LANE1_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 9)
+# define F_SOURCE_PHY_LANE1_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+# define F_SOURCE_PHY_LANE2_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 10)
+# define F_SOURCE_PHY_LANE2_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 10)) >> 10)
+# define F_SOURCE_PHY_LANE3_LSB_MSB(x) (((x) & ((1 << 1) - 1)) << 11)
+# define F_SOURCE_PHY_LANE3_LSB_MSB_RD(x) (((x) & (((1 << 1) - 1) << 11)) >> 11)
+# define F_SOURCE_PHY_AUX_SPARE(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_PHY_AUX_SPARE_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+# define F_SOURCE_PHY_LANE0_POLARITY(x) (((x) & ((1 << 1) - 1)) << 16)
+# define F_SOURCE_PHY_LANE0_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+# define F_SOURCE_PHY_LANE1_POLARITY(x) (((x) & ((1 << 1) - 1)) << 17)
+# define F_SOURCE_PHY_LANE1_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+# define F_SOURCE_PHY_LANE2_POLARITY(x) (((x) & ((1 << 1) - 1)) << 18)
+# define F_SOURCE_PHY_LANE2_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 18)) >> 18)
+# define F_SOURCE_PHY_LANE3_POLARITY(x) (((x) & ((1 << 1) - 1)) << 19)
+# define F_SOURCE_PHY_LANE3_POLARITY_RD(x) (((x) & (((1 << 1) - 1) << 19)) >> 19)
+# define F_SOURCE_PHY_DATA_DEL_EN(x) (((x) & ((1 << 1) - 1)) << 20)
+# define F_SOURCE_PHY_DATA_DEL_EN_RD(x) (((x) & (((1 << 1) - 1) << 20)) >> 20)
+# define F_SOURCE_PHY_COMB_BYPASS(x) (((x) & ((1 << 1) - 1)) << 21)
+# define F_SOURCE_PHY_COMB_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 21)) >> 21)
+# define F_SOURCE_PHY_20_10(x) (((x) & ((1 << 1) - 1)) << 22)
+# define F_SOURCE_PHY_20_10_RD(x) (((x) & (((1 << 1) - 1) << 22)) >> 22)
+
+/* register PHY_DATA_SEL */
+# define PHY_DATA_SEL 6
+# define F_SOURCE_PHY_DATA_SEL(x) (((x) & ((1 << 3) - 1)) << 0)
+# define F_SOURCE_PHY_DATA_SEL_RD(x) (((x) & (((1 << 3) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_MHDP_SEL(x) (((x) & ((1 << 2) - 1)) << 3)
+# define F_SOURCE_PHY_MHDP_SEL_RD(x) (((x) & (((1 << 2) - 1) << 3)) >> 3)
+
+/* register LANES_DEL_VAL */
+# define LANES_DEL_VAL 7
+# define F_SOURCE_PHY_LANE0_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_SOURCE_PHY_LANE0_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_SOURCE_PHY_LANE1_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 4)
+# define F_SOURCE_PHY_LANE1_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 4)) >> 4)
+# define F_SOURCE_PHY_LANE2_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 8)
+# define F_SOURCE_PHY_LANE2_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 8)) >> 8)
+# define F_SOURCE_PHY_LANE3_DEL_VAL(x) (((x) & ((1 << 4) - 1)) << 12)
+# define F_SOURCE_PHY_LANE3_DEL_VAL_RD(x) (((x) & (((1 << 4) - 1) << 12)) >> 12)
+
+#endif //SOURCE_PHY
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/source_pif.h b/drivers/video/fbdev/mxc/cdn_hdp/source_pif.h
new file mode 100644
index 0000000..10de79c
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/source_pif.h
@@ -0,0 +1,170 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_pif.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_PIF_H_
+# define SOURCE_PIF_H_
+
+/* register SOURCE_PIF_WR_ADDR */
+# define SOURCE_PIF_WR_ADDR 0
+# define F_WR_ADDR(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_WR_ADDR_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_WR_REQ */
+# define SOURCE_PIF_WR_REQ 1
+# define F_HOST_WR(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_HOST_WR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_RD_ADDR */
+# define SOURCE_PIF_RD_ADDR 2
+# define F_RD_ADDR(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_RD_ADDR_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_RD_REQ */
+# define SOURCE_PIF_RD_REQ 3
+# define F_HOST_RD(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_HOST_RD_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_DATA_WR */
+# define SOURCE_PIF_DATA_WR 4
+# define F_DATA_WR(x) (x)
+# define F_DATA_WR_RD(x) (x)
+
+/* register SOURCE_PIF_DATA_RD */
+# define SOURCE_PIF_DATA_RD 5
+# define F_FIFO2_DATA_OUT(x) (x)
+# define F_FIFO2_DATA_OUT_RD(x) (x)
+
+/* register SOURCE_PIF_FIFO1_FLUSH */
+# define SOURCE_PIF_FIFO1_FLUSH 6
+# define F_FIFO1_FLUSH(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_FIFO1_FLUSH_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_FIFO2_FLUSH */
+# define SOURCE_PIF_FIFO2_FLUSH 7
+# define F_FIFO2_FLUSH(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_FIFO2_FLUSH_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_STATUS */
+# define SOURCE_PIF_STATUS 8
+# define F_SOURCE_PKT_MEM_CTRL_FSM_STATE(x) (((x) & ((1 << 2) - 1)) << 0)
+# define F_SOURCE_PKT_MEM_CTRL_FSM_STATE_RD(x) (((x) & (((1 << 2) - 1) << 0)) >> 0)
+# define F_FIFO1_FULL(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_FIFO1_FULL_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_FIFO2_EMPTY(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_FIFO2_EMPTY_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register SOURCE_PIF_INTERRUPT_SOURCE */
+# define SOURCE_PIF_INTERRUPT_SOURCE 9
+# define F_HOST_WR_DONE_INT(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_HOST_WR_DONE_INT_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_HOST_RD_DONE_INT(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_HOST_RD_DONE_INT_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_NONVALID_TYPE_REQUESTED_INT(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_NONVALID_TYPE_REQUESTED_INT_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_PSLVERR(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_PSLVERR_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_ALLOC_WR_DONE(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_ALLOC_WR_DONE_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_ALLOC_WR_ERROR(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_ALLOC_WR_ERROR_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_FIFO1_OVERFLOW(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_FIFO1_OVERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_FIFO1_UNDERFLOW(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_FIFO1_UNDERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+# define F_FIFO2_OVERFLOW(x) (((x) & ((1 << 1) - 1)) << 8)
+# define F_FIFO2_OVERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+# define F_FIFO2_UNDERFLOW(x) (((x) & ((1 << 1) - 1)) << 9)
+# define F_FIFO2_UNDERFLOW_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register SOURCE_PIF_INTERRUPT_MASK */
+# define SOURCE_PIF_INTERRUPT_MASK 10
+# define F_HOST_WR_DONE_INT_MASK(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_HOST_WR_DONE_INT_MASK_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_HOST_RD_DONE_INT_MASK(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_HOST_RD_DONE_INT_MASK_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_NONVALID_TYPE_REQUESTED_INT_MASK(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_NONVALID_TYPE_REQUESTED_INT_MASK_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_PSLVERR_MASK(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_PSLVERR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+# define F_ALLOC_WR_DONE_MASK(x) (((x) & ((1 << 1) - 1)) << 4)
+# define F_ALLOC_WR_DONE_MASK_RD(x) (((x) & (((1 << 1) - 1) << 4)) >> 4)
+# define F_ALLOC_WR_ERROR_MASK(x) (((x) & ((1 << 1) - 1)) << 5)
+# define F_ALLOC_WR_ERROR_MASK_RD(x) (((x) & (((1 << 1) - 1) << 5)) >> 5)
+# define F_FIFO1_OVERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 6)
+# define F_FIFO1_OVERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 6)) >> 6)
+# define F_FIFO1_UNDERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 7)
+# define F_FIFO1_UNDERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 7)) >> 7)
+# define F_FIFO2_OVERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 8)
+# define F_FIFO2_OVERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 8)) >> 8)
+# define F_FIFO2_UNDERFLOW_MASK(x) (((x) & ((1 << 1) - 1)) << 9)
+# define F_FIFO2_UNDERFLOW_MASK_RD(x) (((x) & (((1 << 1) - 1) << 9)) >> 9)
+
+/* register SOURCE_PIF_PKT_ALLOC_REG */
+# define SOURCE_PIF_PKT_ALLOC_REG 11
+# define F_PKT_ALLOC_ADDRESS(x) (((x) & ((1 << 4) - 1)) << 0)
+# define F_PKT_ALLOC_ADDRESS_RD(x) (((x) & (((1 << 4) - 1) << 0)) >> 0)
+# define F_PACKET_TYPE(x) (((x) & ((1 << 8) - 1)) << 8)
+# define F_PACKET_TYPE_RD(x) (((x) & (((1 << 8) - 1) << 8)) >> 8)
+# define F_TYPE_VALID(x) (((x) & ((1 << 1) - 1)) << 16)
+# define F_TYPE_VALID_RD(x) (((x) & (((1 << 1) - 1) << 16)) >> 16)
+# define F_ACTIVE_IDLE_TYPE(x) (((x) & ((1 << 1) - 1)) << 17)
+# define F_ACTIVE_IDLE_TYPE_RD(x) (((x) & (((1 << 1) - 1) << 17)) >> 17)
+
+/* register SOURCE_PIF_PKT_ALLOC_WR_EN */
+# define SOURCE_PIF_PKT_ALLOC_WR_EN 12
+# define F_PKT_ALLOC_WR_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_PKT_ALLOC_WR_EN_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+/* register SOURCE_PIF_SW_RESET */
+# define SOURCE_PIF_SW_RESET 13
+# define F_SW_RST(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_SW_RST_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+#endif //SOURCE_PIF
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/source_vif.h b/drivers/video/fbdev/mxc/cdn_hdp/source_vif.h
new file mode 100644
index 0000000..7e84889
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/source_vif.h
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * source_vif.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef SOURCE_VIF_H_
+# define SOURCE_VIF_H_
+
+/* register BND_HSYNC2VSYNC */
+# define BND_HSYNC2VSYNC 0
+# define F_IP_DTCT_WIN(x) (((x) & ((1 << 12) - 1)) << 0)
+# define F_IP_DTCT_WIN_RD(x) (((x) & (((1 << 12) - 1) << 0)) >> 0)
+# define F_IP_DET_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+# define F_IP_DET_EN_RD(x) (((x) & (((1 << 1) - 1) << 12)) >> 12)
+# define F_IP_VIF_BYPASS(x) (((x) & ((1 << 1) - 1)) << 13)
+# define F_IP_VIF_BYPASS_RD(x) (((x) & (((1 << 1) - 1) << 13)) >> 13)
+
+/* register HSYNC2VSYNC_F1_L1 */
+# define HSYNC2VSYNC_F1_L1 1
+# define F_IP_DTCT_HSYNC2VSYNC_F1(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_IP_DTCT_HSYNC2VSYNC_F1_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register HSYNC2VSYNC_F2_L1 */
+# define HSYNC2VSYNC_F2_L1 2
+# define F_IP_DTCT_HSYNC2VSYNC_F2(x) (((x) & ((1 << 16) - 1)) << 0)
+# define F_IP_DTCT_HSYNC2VSYNC_F2_RD(x) (((x) & (((1 << 16) - 1) << 0)) >> 0)
+
+/* register HSYNC2VSYNC_STATUS */
+# define HSYNC2VSYNC_STATUS 3
+# define F_IP_DTCT_ERR(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_IP_DTCT_ERR_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+# define F_IP_DCT_IP(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_IP_DCT_IP_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_IP_DTCT_VJITTER(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_IP_DTCT_VJITTER_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_IP_DTCT_HJITTER(x) (((x) & ((1 << 1) - 1)) << 3)
+# define F_IP_DTCT_HJITTER_RD(x) (((x) & (((1 << 1) - 1) << 3)) >> 3)
+
+/* register HSYNC2VSYNC_POL_CTRL */
+# define HSYNC2VSYNC_POL_CTRL 4
+# define F_VPOL(x) (((x) & ((1 << 1) - 1)) << 2)
+# define F_VPOL_RD(x) (((x) & (((1 << 1) - 1) << 2)) >> 2)
+# define F_HPOL(x) (((x) & ((1 << 1) - 1)) << 1)
+# define F_HPOL_RD(x) (((x) & (((1 << 1) - 1) << 1)) >> 1)
+# define F_VIF_AUTO_MODE(x) (((x) & ((1 << 1) - 1)) << 0)
+# define F_VIF_AUTO_MODE_RD(x) (((x) & (((1 << 1) - 1) << 0)) >> 0)
+
+#endif //SOURCE_VIF
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/test_base_sw.c b/drivers/video/fbdev/mxc/cdn_hdp/test_base_sw.c
new file mode 100644
index 0000000..e51de7b
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/test_base_sw.c
@@ -0,0 +1,95 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * test_base_sw.c
+ *
+ ******************************************************************************
+ */
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+extern void __iomem *g_sec_base;
+extern void __iomem *g_regs_base;
+
+int cdn_apb_read(unsigned int addr, unsigned int *value)
+{
+	unsigned int temp;
+	void *tmp_addr = g_regs_base + addr;
+	temp = __raw_readl((volatile unsigned int *)tmp_addr);
+	*value = temp;
+	return 0;
+}
+
+int cdn_apb_write(unsigned int addr, unsigned int value)
+{
+	void *tmp_addr = g_regs_base + addr;
+
+	__raw_writel(value, (volatile unsigned int *)tmp_addr);
+	return 0;
+}
+
+int cdn_sapb_read(unsigned int addr, unsigned int *value)
+{
+	unsigned int temp;
+	void *tmp_addr = g_sec_base + addr;
+	temp = __raw_readl((volatile unsigned int *)tmp_addr);
+	*value = temp;
+	return 0;
+}
+
+int cdn_sapb_write(unsigned int addr, unsigned int value)
+{
+	void *tmp_addr = g_sec_base + addr;
+	__raw_writel(value, (volatile unsigned int *)tmp_addr);
+	return 0;
+}
+
+void cdn_sleep(uint32_t ms)
+{
+	mdelay(ms);
+}
+
+void cdn_usleep(uint32_t us)
+{
+	udelay(us);
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/util.c b/drivers/video/fbdev/mxc/cdn_hdp/util.c
new file mode 100644
index 0000000..15faa79
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/util.c
@@ -0,0 +1,326 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * util.c
+ *
+ ******************************************************************************
+ */
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/io.h>
+
+#include "util.h"
+#include "API_General.h"
+#include "externs.h"
+#include "apb_cfg.h"
+#include "opcodes.h"
+
+state_struct state;
+
+extern int cdn_bus_read(unsigned int addr, unsigned int *value)
+{
+	return state.bus_type ?
+	    cdn_sapb_read(addr, value) : cdn_apb_read(addr, value);
+}
+
+extern int cdn_bus_write(unsigned int addr, unsigned int value)
+{
+	return state.bus_type ?
+	    cdn_sapb_write(addr, value) : cdn_apb_write(addr, value);
+}
+
+void internal_itobe(int val, volatile unsigned char *dest, int bytes)
+{
+	int i;
+	for (i = bytes - 1; i >= 0; --i) {
+		dest[i] = (unsigned char)val;
+		val >>= 8;
+	}
+}
+
+uint32_t internal_betoi(volatile uint8_t const *src, uint8_t bytes)
+{
+	uint32_t ret = 0;
+	int i;
+
+	if (bytes > sizeof(ret)) {
+		printk
+		    ("Warning. Read request for payload larger then supported.\n");
+		bytes = sizeof(ret);
+
+	}
+
+	for (i = 0; i < bytes; ++i) {
+		ret <<= 8;
+		ret |= (unsigned int)src[i];
+	}
+
+	return ret;
+}
+
+unsigned int internal_mkmsg(volatile unsigned char *dest, int valNo, ...)
+{
+	va_list vl;
+	unsigned int len = 0;
+	va_start(vl, valNo);
+	len = internal_vmkmsg(dest, valNo, vl);
+	va_end(vl);
+	return len;
+}
+
+unsigned int internal_vmkmsg(volatile unsigned char *dest, int valNo,
+			     va_list vl)
+{
+	unsigned int len = 0;
+	int i;
+	for (i = 0; i < valNo; ++i) {
+		int size = va_arg(vl, int);
+		if (size > 0) {
+			internal_itobe(va_arg(vl, int), dest, size);
+			dest += size;
+			len += size;;
+		} else {
+			memcpy((void *)dest, va_arg(vl, void *), -size);
+			dest -= size;
+			len -= size;
+		}
+	}
+	return len;
+}
+
+void internal_tx_mkfullmsg(unsigned char module, unsigned char opcode,
+			   int valNo, ...)
+{
+	va_list vl;
+	va_start(vl, valNo);
+	internal_vtx_mkfullmsg(module, opcode, valNo, vl);
+	va_end(vl);
+}
+
+void internal_vtx_mkfullmsg(unsigned char module, unsigned char opcode,
+			    int valNo, va_list vl)
+{
+	unsigned int len =
+	    internal_vmkmsg(state.txBuffer + INTERNAL_CMD_HEAD_SIZE, valNo, vl);
+	internal_mbox_tx_enable(module, opcode, len);
+	state.txEnable = 1;
+	state.running = 1;
+}
+
+void internal_readmsg(int valNo, ...)
+{
+	va_list vl;
+	va_start(vl, valNo);
+	internal_vreadmsg(valNo, vl);
+	va_end(vl);
+}
+
+void internal_vreadmsg(int valNo, va_list vl)
+{
+	uint8_t *src = state.rxBuffer + INTERNAL_CMD_HEAD_SIZE;
+	size_t i;
+
+	for (i = 0; i < (size_t) valNo; ++i) {
+		int size = va_arg(vl, int);
+		void *ptr = va_arg(vl, void *);
+
+		if (!ptr) {
+			src += size;
+		} else if (!size) {
+			*((unsigned char **)ptr) = src;
+		} else if (size > 0) {
+			switch ((size_t) size) {
+			case sizeof(uint8_t):
+				*((uint8_t *) ptr) = internal_betoi(src, size);
+				break;
+			case sizeof(uint16_t):
+				*((uint16_t *) ptr) = internal_betoi(src, size);
+				break;
+			case sizeof(uint32_t):
+				*((uint32_t *) ptr) = internal_betoi(src, size);
+				break;
+			default:
+				printk("Warning. Unsupported variable size.\n");
+				memcpy(ptr, src, size);
+			};
+
+			src += size;
+		} else {
+			memcpy(ptr, src, -size);
+			src -= size;
+		}
+	}
+}
+
+INTERNAL_MBOX_STATUS mailbox_write(unsigned char val)
+{
+	INTERNAL_MBOX_STATUS ret;
+	unsigned int full;
+	if (cdn_bus_read(MAILBOX_FULL_ADDR << 2, &full)) {
+		ret.tx_status = CDN_TX_APB_ERROR;
+		return ret;
+	}
+	if (full) {
+		ret.tx_status = CDN_TX_FULL;
+		return ret;
+	}
+	if (cdn_bus_write(MAILBOX0_WR_DATA << 2, val)) {
+		ret.tx_status = CDN_TX_APB_ERROR;
+		return ret;
+	}
+	ret.tx_status = CDN_TX_WRITE;
+	return ret;
+}
+
+INTERNAL_MBOX_STATUS mailbox_read(volatile unsigned char *val)
+{
+	INTERNAL_MBOX_STATUS ret;
+	unsigned int empty;
+	unsigned int rd;
+	if (cdn_bus_read(MAILBOX_EMPTY_ADDR << 2, &empty)) {
+		ret.rx_status = CDN_RX_APB_ERROR;
+		return ret;
+	}
+	if (empty) {
+		ret.rx_status = CDN_RX_EMPTY;
+		return ret;
+	}
+	if (cdn_bus_read(MAILBOX0_RD_DATA << 2, &rd)) {
+		ret.rx_status = CDN_RX_APB_ERROR;
+		return ret;
+	}
+	*val = (unsigned char)rd;
+	ret.rx_status = CDN_RX_READ;
+	return ret;
+}
+
+INTERNAL_MBOX_STATUS internal_mbox_tx_process(void)
+{
+	unsigned int txCount = 0;
+	unsigned int length =
+	    (unsigned int)state.txBuffer[2] << 8 | (unsigned int)state.
+	    txBuffer[3];
+	INTERNAL_MBOX_STATUS ret = {.txend = 0 };
+	INTERNAL_MBOX_STATUS tx_ret;
+
+	ret.tx_status = CDN_TX_NOTHING;
+	if (!state.txEnable)
+		return ret;
+	while ((tx_ret.tx_status =
+		mailbox_write(state.txBuffer[state.txi]).tx_status) ==
+	       CDN_TX_WRITE) {
+		txCount++;
+		if (++state.txi >= length + 4) {
+			state.txEnable = 0;
+			state.txi = 0;
+			ret.txend = 1;
+			break;
+		}
+	}
+	if (txCount && tx_ret.tx_status == CDN_TX_FULL)
+		ret.tx_status = CDN_TX_WRITE;
+	else
+		ret.tx_status = tx_ret.tx_status;
+	return ret;
+}
+
+INTERNAL_MBOX_STATUS internal_mbox_rx_process(void)
+{
+	unsigned int rxCount = 0;
+	INTERNAL_MBOX_STATUS ret = { 0, 0, 0, 0 };
+	INTERNAL_MBOX_STATUS rx_ret;
+	while ((rx_ret.rx_status =
+		mailbox_read(state.rxBuffer + state.rxi).rx_status) ==
+	       CDN_RX_READ) {
+		rxCount++;
+		if (++state.rxi >=
+				4 + ((unsigned int)state.rxBuffer[2] << 8 | (unsigned int)state.rxBuffer[3])) {
+			state.rxi = 0;
+			ret.rxend = 1;
+			state.rxEnable = 0;
+			break;
+		}
+	}
+	ret.rx_status = rxCount ? CDN_RX_READ : CDN_RX_EMPTY;
+	return ret;
+}
+
+unsigned int internal_apb_available(void)
+{
+	return !(state.rxEnable || state.txEnable);
+}
+
+void internal_mbox_tx_enable(unsigned char module, unsigned char opcode,
+			     unsigned short length)
+{
+	state.txBuffer[0] = opcode;
+	state.txBuffer[1] = module;
+	state.txBuffer[2] = (unsigned char)(length >> 8);
+	state.txBuffer[3] = (unsigned char)length;
+	state.txEnable = 1;
+}
+
+CDN_API_STATUS internal_test_rx_head(unsigned char module, unsigned char opcode)
+{
+	if (opcode != state.rxBuffer[0])
+		return CDN_BAD_OPCODE;
+	if (module != state.rxBuffer[1])
+		return CDN_BAD_MODULE;
+	return CDN_OK;
+}
+
+CDN_API_STATUS internal_test_rx_head_match(void)
+{
+	return internal_test_rx_head(state.txBuffer[1], state.txBuffer[0]);
+}
+
+void print_fw_ver(void)
+{
+	unsigned short ver, verlib;
+	CDN_API_General_getCurVersion(&ver, &verlib);
+	printk("FIRMWARE VERSION: %d, LIB VERSION: %d\n", ver, verlib);
+}
+
+unsigned short internal_get_msg_len(void)
+{
+	return ((unsigned short)state.rxBuffer[2] << 8) | (unsigned short)state.
+	    rxBuffer[3];
+}
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/util.h b/drivers/video/fbdev/mxc/cdn_hdp/util.h
new file mode 100644
index 0000000..0248878
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/util.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * util.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef UTIL_H_
+# define UTIL_H_
+
+# include "API_General.h"
+/**
+ * \addtogroup UTILS
+ * \{
+ */
+# define INTERNAL_CMD_HEAD_SIZE 4
+
+/**
+ * \brief expands to blocking function body
+ * \param x - function call
+ */
+# define internal_block_function(x)               \
+do {                                             \
+    CDN_API_STATUS ret;                          \
+    do ret = x;                                  \
+    while (ret == CDN_BSY || ret == CDN_STARTED) \
+		;                                        \
+    return ret;                                  \
+} while (0)
+
+/**
+ * \brief write message and write response (if any), non-blocking way. Also sets state.running = 0
+ */
+# define INTERNAL_PROCESS_MESSAGES                           \
+do {                                                        \
+	if (state.txEnable && !internal_mbox_tx_process().txend) \
+		return CDN_BSY;                                     \
+	if (state.rxEnable && !internal_mbox_rx_process().rxend) \
+		return CDN_BSY;                                     \
+	state.running = 0;                                      \
+} while (0)
+
+# define internal_opcode_ok_or_return(module, opcode) do {                         \
+	CDN_API_STATUS ret;                                                           \
+	ret = internal_test_rx_head(module, opcode);                                  \
+	if (ret != CDN_OK)                                                            \
+		return ret;                                                               \
+} while (0)
+
+# define internal_opcode_match_or_return() do {                                           \
+	CDN_API_STATUS ret;                                                                  \
+	ret = internal_test_rx_head_match();                                                 \
+	if (ret != CDN_OK)                                                                   \
+		return ret;                                                                      \
+} while (0)
+
+/* macro for simple tx only command, command format as in mkfullmsg (with count) */
+# define internal_macro_command_tx(module, opcode, bustype, command...) \
+do {                                                                    \
+	if (!state.running) {                                                \
+		internal_tx_mkfullmsg(module, opcode, command);                 \
+		state.bus_type = bustype;                                      \
+		return CDN_STARTED;                                             \
+	}                                                                   \
+	INTERNAL_PROCESS_MESSAGES;                                          \
+} while (0)
+
+/* macro for command with response with matching opcode, command format as in mkfullmsg (with count) */
+# define internal_macro_command_txrx(module, opcode, bustype, command...) \
+do {                                                                      \
+	if (!state.running) {                                                 \
+		internal_tx_mkfullmsg(module, opcode, command);                   \
+		state.bus_type = bustype;                                        \
+		state.rxEnable = 1;                                               \
+		return CDN_STARTED;                                               \
+	}                                                                     \
+	INTERNAL_PROCESS_MESSAGES;                                            \
+	internal_opcode_match_or_return();                                    \
+} while (0)
+
+typedef struct {
+    /** apb write status */
+	enum tx_status_enum {
+	/** one or more bytes written */
+		CDN_TX_WRITE = 0,
+	/** nothing to write */
+		CDN_TX_NOTHING = 1,
+	/** mailbox full, 0 bytes written */
+		CDN_TX_FULL = 2,
+	/** APB error while writing */
+		CDN_TX_APB_ERROR = 3
+	} tx_status:3;
+    /** apb read status */
+	enum rx_status_enum {
+	/** 1 or more bytes read */
+		CDN_RX_READ = 0,
+	/** mailbox empty, 0 bytes read */
+		CDN_RX_EMPTY = 1,
+	/** apb error while reading */
+		CDN_RX_APB_ERROR = 2
+	} rx_status:2;
+    /** indicates end of currenly recived message */
+	unsigned char rxend:1;
+    /** end of tx message reached */
+	unsigned char txend:1;
+} INTERNAL_MBOX_STATUS;
+
+/**
+ * \brief put val into dest in big endian format
+ * \param val - value to put
+ * \param dest - place to put value
+ * \param bytes - true size of val in bytes. for example if bytes = 2 val is treated as short int
+ */
+void internal_itobe(int val, volatile unsigned char *dest, int bytes);
+
+/**
+ * \brief read big endian value from src and return it
+ * \param src - source to read from
+ * \param bytes - size of read value
+ * \return result
+ */
+uint32_t internal_betoi(volatile uint8_t const *src, uint8_t bytes);
+
+/**
+ * \brief create message from size and value pairs; also sets state.runnging and state.txEnable
+ * \param dest - pointer to write message to
+ * \param valNo - number of values to write
+ * \param ... - pairs of size and value, each value is written after another. if size is positive value, value is written with #internal_itobe, if size is negative, value is treated as src pointer for memcpy
+ *
+ * example:
+ *
+ *  unsigned short x = 0xAABB;
+ *
+ *  internal_mkmsg(dest, 3, 1, 1, 2, 3, -2, &x);
+ *
+ *  will write 01 00 03 AA BB to dest
+ */
+unsigned int internal_mkmsg(volatile unsigned char *dest, int valNo, ...);
+unsigned int internal_vmkmsg(volatile unsigned char *dest, int valNo,
+			     va_list vl);
+
+/**
+ * \brief setup message header in txBuffer, set txEnable = 1
+ */
+void internal_mbox_tx_enable(unsigned char module, unsigned char opcode,
+			     unsigned short length);
+
+/**
+ * \brief write from txBuffer to mailbox untill full or end of message.
+ *
+ * when txEnable == 0 writes nothing
+ * when write reaches end of message set txEnable = 0
+ */
+
+/**
+ * \brief combination of #internal_mkmsg and #internal_mbox_tx_enable
+ *
+ * #internal_mkmsg dest and #internal_mbox_tx_enable length are determined automaticly
+ * this function also sets state.txEnable = 1 and state.running
+ */
+void internal_tx_mkfullmsg(unsigned char module, unsigned char opcode,
+			   int valNo, ...);
+void internal_vtx_mkfullmsg(unsigned char module, unsigned char opcode,
+			    int valNo, va_list vl);
+
+/**
+ * \brief read from state.txBuffer and store results in specified pointers
+ * \param valNo - numbero of values to read
+ * \param ... - pairs of size and ptr
+ *
+ * this function is similar to #internal_mkmsg -
+ *
+ * when size is positive read value using #internal_betoi
+ * when size is negative mempcy from txBuffer to ptr -size bytes
+ * when size is 0 write to ptr addres of current position in rxbuffer
+ * when ptr is NULL ignore size bytes (if size is negative this will rewind buffer)
+ */
+void internal_readmsg(int valNo, ...);
+void internal_vreadmsg(int valNo, va_list vl);
+
+INTERNAL_MBOX_STATUS internal_mbox_tx_process(void);
+/**
+ * \brief read to rxBuffer from mailbox untill empty or end of message
+ *
+ * when rxEnable == 0 reads nothing
+ * when end of message reached sets rxEnable = 0
+ */
+INTERNAL_MBOX_STATUS internal_mbox_rx_process(void);
+
+/**
+ * \brief check if apb is available
+ * \return !(rxEnable && txEable)
+ */
+unsigned int internal_apb_available(void);
+
+/**
+ * \brief test if parameters match module and opcode in rxBuffer
+ * \return CDN_OK or CDN_BAD_OPCODE or CDN_BAD_MODULE
+ */
+CDN_API_STATUS internal_test_rx_head(unsigned char module,
+				     unsigned char opcode);
+
+CDN_API_STATUS internal_test_rx_head_match(void);
+
+/**
+ * \brief print current fw and lib version
+ */
+void print_fw_ver(void);
+
+typedef struct {
+	unsigned char txBuffer[1024];
+	unsigned char rxBuffer[1024];
+	unsigned int txi;	//iterators
+	unsigned int rxi;
+	unsigned char txEnable;	//data readt to send
+	unsigned char rxEnable;
+	unsigned char running;
+	CDN_BUS_TYPE bus_type;
+	unsigned int tmp;
+} state_struct;
+
+extern state_struct state;
+extern int cdn_bus_read(unsigned int addr, unsigned int *value);
+extern int cdn_bus_write(unsigned int addr, unsigned int value);
+unsigned short internal_get_msg_len(void);
+
+#endif
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/vic_table.c b/drivers/video/fbdev/mxc/cdn_hdp/vic_table.c
new file mode 100644
index 0000000..68842d1
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/vic_table.c
@@ -0,0 +1,460 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * vic_table.c
+ *
+ ******************************************************************************
+ */
+
+#include "vic_table.h"
+
+const unsigned int vic_table[VIC_MODE_COUNT][27] = {
+#if 0
+	{800, 640, 160, 96, 16, 48, 31.469, 525, 480, 45, 2, 10, 33, 59.94,
+	 25.18, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 1, 8, 0},
+	{800, 640, 160, 96, 16, 48, 31.5, 525, 480, 45, 2, 10, 33, 60, 25.20,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 1,
+	 8, 0},
+	{858, 720, 138, 62, 16, 60, 31.469, 525, 480, 45, 6, 9, 30, 59.94,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 2, 8, 0},
+	{858, 720, 138, 62, 16, 60, 31.5, 525, 480, 45, 6, 9, 30, 60, 27.03,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 2,
+	 8, 0},
+#endif
+	/*hdmi 4 */
+	{858, 720, 138, 62, 16, 60, 31, 525, 480, 45, 6, 9, 30, 59,
+	 27000, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1,
+	 46, 65535, 65535, 3, 8, 0},
+#if 0
+	{858, 720, 138, 62, 16, 60, 31.5, 525, 480, 45, 6, 9, 30, 60, 27.03,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 3,
+	 8, 0},
+	{1650, 1280, 370, 40, 110, 220, 44.955, 750, 720, 30, 5, 5, 20, 59.94,
+	 74.18, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535,
+	 65535, 4, 8, 0},
+#endif
+/* hdmi 7 */
+	{1650, 1280, 370, 40, 110, 220, 45, 750, 720, 30, 5, 5, 20,
+	 60, 74250, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH,
+	 1, 65535, 1, 31, 65535, 65535, 4, 8, 0},
+#if 0
+	{2200, 1920, 280, 44, 88, 148, 33.716, 1125, 1080, 22.51, 5, 2, 15,
+	 59.94, 74.18, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 1, 563, 561, 21,
+	 1124, 584, 5, 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 33.75, 1125, 1080, 22.51, 5, 2, 15, 60,
+	 74.25, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 1, 563, 561, 21, 1124,
+	 584, 5, 8, 0},
+	{1716, 1440, 276, 124, 38, 114, 15.734, 525, 480, 22.51, 3, 4, 15,
+	 59.94, 27.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525,
+	 285, 6, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.75, 525, 480, 22.51, 3, 4, 15, 60,
+	 27.03, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 6, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.734, 525, 480, 22.51, 3, 4, 15,
+	 59.94, 27.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525,
+	 285, 7, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.75, 525, 480, 22.51, 3, 4, 15, 60,
+	 27.03, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 7, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.734, 262, 240, 22, 3, 4, 15, 60.054,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 8, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.75, 262, 240, 22, 3, 4, 15, 60.115,
+	 27.03, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 8, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.734, 263, 240, 23, 3, 5, 15, 59.826,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 8, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.75, 263, 240, 23, 3, 5, 15, 59.886,
+	 27.03, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 8, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.734, 262, 240, 22, 3, 4, 15, 60.054,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 9, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.75, 262, 240, 22, 3, 4, 15, 60.115,
+	 27.03, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 9, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.734, 263, 240, 23, 3, 5, 15, 59.826,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 9, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 15.75, 263, 240, 23, 3, 5, 15, 59.886,
+	 27.03, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 9, 8, 1},
+	{3432, 2880, 552, 248, 76, 228, 15.734, 525, 480, 22.51, 3, 4, 15,
+	 59.94, 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525,
+	 285, 10, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.75, 525, 480, 22.51, 3, 4, 15, 60,
+	 54.05, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 10, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.734, 525, 480, 22.51, 3, 4, 15,
+	 59.94, 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525,
+	 285, 11, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.75, 525, 480, 22.51, 3, 4, 15, 60,
+	 54.05, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 11, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.734, 262, 240, 22, 3, 4, 15, 60.054,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 12, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.75, 262, 240, 22, 3, 4, 15, 60.115,
+	 54.05, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 12, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.734, 263, 240, 23, 3, 5, 15, 59.826,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 12, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.75, 263, 240, 23, 3, 5, 15, 59.886,
+	 54.05, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 12, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.734, 262, 240, 22, 3, 4, 15, 60.054,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 13, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.75, 262, 240, 22, 3, 4, 15, 60.115,
+	 54.05, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 13, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.734, 263, 240, 23, 3, 5, 15, 59.826,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 23, 65535,
+	 65535, 13, 8, 3},
+	{3432, 2880, 552, 248, 76, 228, 15.75, 263, 240, 23, 3, 5, 15, 59.886,
+	 54.05, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 24, 65535,
+	 65535, 13, 8, 3},
+	{1716, 1440, 276, 124, 32, 120, 31.469, 525, 480, 45, 6, 9, 30, 59.94,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 14, 8, 0},
+	{1716, 1440, 276, 124, 32, 120, 31.5, 525, 480, 45, 6, 9, 30, 60, 54.05,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 14,
+	 8, 0},
+	{1716, 1440, 276, 124, 32, 120, 31.469, 525, 480, 45, 6, 9, 30, 59.94,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 15, 8, 0},
+	{1716, 1440, 276, 124, 32, 120, 31.5, 525, 480, 45, 6, 9, 30, 60, 54.05,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 15,
+	 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 67.433, 1125, 1080, 45, 5, 4, 36, 59.94,
+	 148.35, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 46, 65535,
+	 65535, 16, 8, 0},
+#endif
+	/*hdmi 39 */
+	{2200, 1920, 280, 44, 88, 148, 67, 1125, 1080, 45, 5, 4,
+	 36, 60, 148500, PROGRESSIVE, ACTIVE_HIGH,
+	 ACTIVE_HIGH, 1, 65535, 1, 46, 65535, 65535, 16, 8, 0},
+#if 0
+	{864, 720, 144, 64, 12, 68, 31.25, 625, 576, 49, 5, 5, 39, 50, 27.00,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535, 65535, 17,
+	 8, 0},
+	{864, 720, 144, 64, 12, 68, 31.25, 625, 576, 49, 5, 5, 39, 50, 27.00,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535, 65535, 18,
+	 8, 0},
+	{1980, 1280, 700, 40, 440, 220, 37.5, 750, 720, 30, 5, 5, 20, 50, 74.25,
+	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535, 65535,
+	 19, 8, 0},
+	{2640, 1920, 720, 44, 528, 148, 28.125, 1125, 1080, 22.51, 5, 2, 15, 50,
+	 74.25, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 1, 563, 561, 21, 1124,
+	 584, 20, 8, 0},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 625, 576, 24.51, 3, 2, 19, 50,
+	 27.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 21, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 625, 576, 24.51, 3, 2, 19, 50,
+	 27.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 22, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 312, 288, 24, 3, 2, 19, 50.08,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 25, 65535,
+	 65535, 23, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 313, 288, 25, 3, 3, 19, 49.92,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 26, 65535,
+	 65535, 23, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 314, 288, 26, 3, 4, 19, 49.761,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 27, 65535,
+	 65535, 23, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 312, 288, 24, 3, 2, 19, 50.08,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 25, 65535,
+	 65535, 24, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 313, 288, 25, 3, 3, 19, 49.92,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 26, 65535,
+	 65535, 24, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 15.625, 314, 288, 26, 3, 4, 19, 49.761,
+	 27.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 27, 65535,
+	 65535, 24, 8, 1},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 625, 576, 24.51, 3, 2, 19, 50,
+	 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 25, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 625, 576, 24.51, 3, 2, 19, 50,
+	 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 26, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 312, 288, 24, 3, 2, 19, 50.08,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 25, 65535,
+	 65535, 27, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 313, 288, 25, 3, 3, 19, 49.92,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 26, 65535,
+	 65535, 27, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 314, 288, 26, 3, 4, 19, 49.761,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 27, 65535,
+	 65535, 27, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 312, 288, 24, 3, 2, 19, 50.08,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 25, 65535,
+	 65535, 28, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 313, 288, 25, 3, 3, 19, 49.92,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 26, 65535,
+	 65535, 28, 8, 3},
+	{3456, 2880, 576, 252, 48, 276, 15.625, 314, 288, 26, 3, 4, 19, 49.761,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 27, 65535,
+	 65535, 28, 8, 3},
+	{1728, 1440, 288, 128, 24, 136, 31.25, 625, 576, 49, 5, 5, 39, 50,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535,
+	 65535, 29, 8, 3},
+	{1728, 1440, 288, 128, 24, 136, 31.25, 625, 576, 49, 5, 5, 39, 50,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535,
+	 65535, 30, 8, 3},
+	{2640, 1920, 720, 44, 528, 148, 56.25, 1125, 1080, 45, 5, 4, 36, 50,
+	 148.50, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1122, 42,
+	 65535, 65535, 31, 8, 0},
+	{2750, 1920, 830, 44, 638, 148, 26.973, 1125, 1080, 45, 5, 4, 36,
+	 23.976, 74.18, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 46,
+	 65535, 65535, 32, 8, 0},
+	{2750, 1920, 830, 44, 638, 148, 27, 1125, 1080, 45, 5, 4, 36, 24.0003,
+	 74.25, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 46, 65535,
+	 65535, 32, 8, 0},
+	{2640, 1920, 720, 44, 528, 148, 28.125, 1125, 1080, 45, 5, 4, 36, 25,
+	 74.25, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 46, 65535,
+	 65535, 33, 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 33.716, 1125, 1080, 45, 5, 4, 36, 29.97,
+	 74.18, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 46, 65535,
+	 65535, 34, 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 33.75, 1125, 1080, 45, 5, 4, 36, 30.0003,
+	 74.25, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 46, 65535,
+	 65535, 34, 8, 0},
+	{3432, 2880, 552, 248, 64, 240, 31.469, 525, 480, 45, 6, 9, 30, 59.94,
+	 108.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 35, 8, 0},
+	{3432, 2880, 552, 248, 64, 240, 31.5, 525, 480, 45, 6, 9, 30, 60,
+	 108.11, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 35, 8, 0},
+	{3432, 2880, 552, 248, 64, 240, 31.469, 525, 480, 45, 6, 9, 30, 59.94,
+	 108.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 36, 8, 0},
+	{3432, 2880, 552, 248, 64, 240, 31.5, 525, 480, 45, 6, 9, 30, 60,
+	 108.11, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 36, 8, 0},
+	{3456, 2880, 576, 256, 48, 272, 31.25, 625, 576, 49, 5, 5, 39, 50,
+	 108.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535,
+	 65535, 37, 8, 0},
+	{3456, 2880, 576, 256, 48, 272, 31.25, 625, 576, 49, 5, 5, 39, 50,
+	 108.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535,
+	 65535, 38, 8, 0},
+	{2304, 1920, 384, 168, 32, 184, 31.25, 1250, 1080, 85, 5, 23, 57, 50,
+	 72.00, INTERLACED, ACTIVE_HIGH, ACTIVE_LOW, 1, 625, 603, 63, 1228, 688,
+	 39, 8, 0},
+	{2640, 1920, 720, 44, 528, 148, 56.25, 1125, 1080, 22.51, 5, 2, 15, 100,
+	 148.50, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 1, 563, 561, 21, 1124,
+	 584, 40, 8, 0},
+	{1980, 1280, 700, 40, 440, 220, 75, 750, 720, 30, 5, 5, 20, 100, 148.50,
+	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535, 65535,
+	 41, 8, 0},
+	{864, 720, 144, 64, 12, 68, 62.5, 625, 576, 49, 5, 5, 39, 100, 54.00,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535, 65535, 42,
+	 8, 0},
+	{864, 720, 144, 64, 12, 68, 62.5, 625, 576, 49, 5, 5, 39, 100, 54.00,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535, 65535, 43,
+	 8, 0},
+	{1728, 1440, 288, 126, 24, 138, 31.25, 625, 576, 24.51, 3, 2, 19, 100,
+	 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 44, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 31.25, 625, 576, 24.51, 3, 2, 19, 100,
+	 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 45, 8, 1},
+	{2200, 1920, 280, 44, 88, 148, 67.432, 1125, 1080, 22.51, 5, 2, 15,
+	 119.88, 148.35, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 1, 563, 561, 21,
+	 1124, 584, 46, 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 67.5, 1125, 1080, 22.51, 5, 2, 15, 120,
+	 148.50, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 1, 563, 561, 21, 1124,
+	 584, 46, 8, 0},
+	{1650, 1280, 370, 40, 110, 220, 89.909, 750, 720, 30, 5, 5, 20, 119.88,
+	 148.35, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535,
+	 65535, 47, 8, 0},
+	{1650, 1280, 370, 40, 110, 220, 90, 750, 720, 30, 5, 5, 20, 120, 148.50,
+	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 1, 65535, 1, 31, 65535, 65535,
+	 47, 8, 0},
+	{858, 720, 138, 62, 16, 60, 62.937, 525, 480, 45, 6, 9, 30, 119.88,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 48, 8, 0},
+	{858, 720, 138, 62, 16, 60, 63, 525, 480, 45, 6, 9, 30, 120, 54.05,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 48,
+	 8, 0},
+	{858, 720, 138, 62, 16, 60, 62.937, 525, 480, 45, 6, 9, 30, 119.88,
+	 54.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 49, 8, 0},
+	{858, 720, 138, 62, 16, 60, 63, 525, 480, 45, 6, 9, 30, 120, 54.05,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 49,
+	 8, 0},
+	{1716, 1440, 276, 124, 38, 114, 31.469, 525, 480, 22.51, 3, 4, 15,
+	 119.88, 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22,
+	 525, 285, 50, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 31.5, 525, 480, 22.51, 3, 4, 15, 120,
+	 54.05, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 50, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 31.469, 525, 480, 22.51, 3, 4, 15,
+	 119.88, 54.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22,
+	 525, 285, 51, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 31.5, 525, 480, 22.51, 3, 4, 15, 120,
+	 54.05, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 51, 8, 1},
+	{864, 720, 144, 64, 12, 68, 125, 625, 576, 49, 5, 5, 39, 200, 108.00,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535, 65535, 52,
+	 8, 0},
+	{864, 720, 144, 64, 12, 68, 125, 625, 576, 49, 5, 5, 39, 200, 108.00,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 50, 65535, 65535, 53,
+	 8, 0},
+	{1728, 1440, 288, 126, 24, 138, 62.5, 625, 576, 24.51, 3, 2, 19, 200,
+	 108.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 54, 8, 1},
+	{1728, 1440, 288, 126, 24, 138, 62.5, 625, 576, 24.51, 3, 2, 19, 200,
+	 108.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 1, 313, 311, 23, 624, 336,
+	 55, 8, 1},
+	{858, 720, 138, 62, 16, 60, 125.874, 525, 480, 45, 6, 9, 30, 239.76,
+	 108.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 56, 8, 0},
+	{858, 720, 138, 62, 16, 60, 126, 525, 480, 45, 6, 9, 30, 240, 108.11,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 56,
+	 8, 0},
+	{858, 720, 138, 62, 16, 60, 125.874, 525, 480, 45, 6, 9, 30, 239.76,
+	 108.00, PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535,
+	 65535, 57, 8, 0},
+	{858, 720, 138, 62, 16, 60, 126, 525, 480, 45, 6, 9, 30, 240, 108.11,
+	 PROGRESSIVE, ACTIVE_LOW, ACTIVE_LOW, 1, 65535, 1, 46, 65535, 65535, 57,
+	 8, 0},
+	{1716, 1440, 276, 124, 38, 114, 62.937, 525, 480, 22.51, 3, 4, 15,
+	 239.76, 108.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22,
+	 525, 285, 58, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 63, 525, 480, 22.51, 3, 4, 15, 240,
+	 108.11, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 58, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 62.937, 525, 480, 22.51, 3, 4, 15,
+	 239.76, 108.00, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22,
+	 525, 285, 59, 8, 1},
+	{1716, 1440, 276, 124, 38, 114, 63, 525, 480, 22.51, 3, 4, 15, 240,
+	 108.11, INTERLACED, ACTIVE_LOW, ACTIVE_LOW, 4, 266, 262, 22, 525, 285,
+	 59, 8, 1},
+	{3300, 1280, 2020, 40, 1760, 220, 17.977, 750, 720, 30, 5, 5, 20, 23.97,
+	 59.34, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 60, 8, 0},
+	{3300, 1280, 2020, 40, 1760, 220, 18, 750, 720, 30, 5, 5, 20, 24, 59.4,
+	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525, 285, 60,
+	 8, 0},
+	{3960, 1280, 2680, 40, 2420, 220, 18.75, 750, 720, 30, 5, 5, 20, 25,
+	 74.25, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 61, 8, 0},
+	{3300, 1280, 2020, 40, 1760, 220, 22.477, 750, 720, 30, 5, 5, 20, 29.97,
+	 74.176, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 62, 8, 0},
+	{3300, 1280, 2020, 40, 1760, 220, 22.5, 750, 720, 30, 5, 5, 20, 30,
+	 74.25, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 62, 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 134.865, 1125, 1080, 45, 5, 4, 36,
+	 119.88, 296.703, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 63, 8, 0},
+	{2200, 1920, 280, 44, 88, 148, 135, 1125, 1080, 45, 5, 4, 36, 120, 297,
+	 PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525, 285, 63,
+	 8, 0},
+	{2640, 1920, 720, 44, 528, 148, 112.5, 1125, 1080, 45, 5, 4, 36, 100,
+	 297, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525, 285,
+	 64, 8, 0},
+#endif
+	{4400, 3840, 560, 88, 176, 296, 135, 2250, 2160, 90, 10, 8, 72, 60,
+	 594000, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 97, 8, 0},
+	{4400, 3840, 560, 88, 176, 296, 135, 2250, 2160, 90, 10, 8, 72, 30,
+	 297000, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 95, 8, 0},
+#if 0
+	{1056, 800, 256, 128, 40, 88, 37.879, 628, 600, 28, 4, 1, 23, 60.317,
+	 40, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525, 285,
+	 114, 8, 0},
+	{896, 720, 176, 64, 24, 88, 24.833, 419, 400, 19, 10, 3, 6, 59.26,
+	 22.250, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 115, 8, 0},
+	{912, 720, 192, 72, 24, 96, 37.00657895, 424, 400, 24, 10, 3, 11,
+	 87.27966733, 33.75, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 116, 8, 0},
+	{800, 640, 160, 64, 16, 80, 29.6875, 500, 480, 20, 4, 3, 13, 59.375,
+	 23.75, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22, 525,
+	 285, 117, 8, 0},
+	{800, 640, 160, 64, 16, 80, 33.4375, 502, 480, 22, 4, 3, 15,
+	 66.60856574, 26.75, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 118, 8, 0},
+	{816, 640, 176, 64, 24, 88, 36.15196078, 503, 480, 23, 4, 3, 16,
+	 71.87268546, 29.5, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 119, 8, 0},
+	{816, 640, 176, 64, 24, 88, 37.68382353, 504, 480, 24, 4, 3.00, 17,
+	 74.76949113, 30.75, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 120, 8, 0},
+	{1008, 800, 208, 80, 24, 104, 34.72222222, 623, 600, 23, 4, 3.00, 16,
+	 55.73390405, 35, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 121, 8, 0},
+	{1040, 800, 240, 80, 40, 120, 45.19230769, 628, 600, 28, 4, 3.00, 21,
+	 71.9622734, 47, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262, 22,
+	 525, 285, 122, 8, 0},
+	{1088, 832, 256, 80, 48, 128, 48.94301471, 654, 624, 30, 4, 3.00, 23,
+	 74.83641392, 53.25, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 123, 8, 0},
+	{1376, 1024, 352, 104, 72, 176, 74.49127907, 859, 768, 45, 4, 3.50, 38,
+	 86.71860194, 102.5, INTERLACED, ACTIVE_HIGH, ACTIVE_HIGH, 3.50, 433.5,
+	 429, 45, 859, 475, 124, 8, 0},
+	{1328, 1024, 304, 104, 48, 152, 47.81626506, 798, 768, 30, 4, 3.00, 23,
+	 59.92013165, 63.5, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 125, 8, 0},
+	{1360, 1024, 336, 104, 64, 168, 57.72058824, 803, 768, 35, 4, 3.00, 28,
+	 71.88118087, 78.5, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 126, 8, 0},
+	{1360, 1024, 336, 104, 64, 168, 60.29411765, 805, 768, 37, 4, 3.00, 30,
+	 74.89952503, 82, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266, 262,
+	 22, 525, 285, 127, 8, 0},
+	{1728, 1280, 448, 136, 88, 224, 80.29513889, 1072, 1024, 48, 7, 3.00,
+	 38, 74.9021818, 138.75, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266,
+	 262, 22, 525, 285, 128, 8, 0},
+	{1536, 1152, 384, 120, 72, 192, 68.19661458, 911, 870, 41, 10, 3.00, 28,
+	 74.85907199, 104.75, PROGRESSIVE, ACTIVE_HIGH, ACTIVE_HIGH, 4, 266,
+	 262, 22, 525, 285, 129, 8, 0},
+#endif
+};
diff --git a/drivers/video/fbdev/mxc/cdn_hdp/vic_table.h b/drivers/video/fbdev/mxc/cdn_hdp/vic_table.h
new file mode 100644
index 0000000..568265e
--- /dev/null
+++ b/drivers/video/fbdev/mxc/cdn_hdp/vic_table.h
@@ -0,0 +1,276 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
+ * All rights reserved worldwide.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2017 NXP
+ *
+ ******************************************************************************
+ *
+ * This file was auto-generated. Do not edit it manually.
+ *
+ ******************************************************************************
+ *
+ * vic_table.h
+ *
+ ******************************************************************************
+ */
+
+#ifndef VIC_TABLE_H_
+# define VIC_TABLE_H_
+
+# define PROGRESSIVE 0
+# define INTERLACED 1
+
+# define ACTIVE_LOW 0
+# define ACTIVE_HIGH 1
+
+typedef enum {
+	H_TOTAL,
+	H_ACTIVE,
+	H_BLANK,
+	HSYNC,
+	FRONT_PORCH,
+	BACK_PORCH,
+	H_FREQ_KHZ,
+	V_TOTAL,
+	V_ACTIVE,
+	V_BLANK,
+	VSYNC,
+	TYPE_EOF,
+	SOF,
+	V_FREQ_HZ,
+	PIXEL_FREQ_KHZ,
+	I_P,
+	HSYNC_POL,
+	VSYNC_POL,
+	START_OF_F0,
+	START_OF_F1,
+	VSYNC_START_INTERLACED_F0,
+	VSYNC_END_INTERLACED_F0,
+	VSYNC_START_INTERLACED_F1,
+	VSYNC_END_INTERLACED_F1,
+	VIC,
+	VIC_R3_0,
+	VIC_PR,
+} MSA_PARAM;
+
+typedef enum {
+	NUM_OF_LANES_1 = 1,
+	NUM_OF_LANES_2 = 2,
+	NUM_OF_LANES_4 = 4,
+} VIC_NUM_OF_LANES;
+
+typedef enum {
+	RATE_1_6 = 162,
+	RATE_2_7 = 270,
+	RATE_5_4 = 540,
+	RATE_8_1 = 810,
+} VIC_SYMBOL_RATE;
+
+typedef enum {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+} VIC_PXL_ENCODING_FORMAT;
+
+typedef enum {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+} VIC_COLOR_DEPTH;
+
+typedef enum {
+	STEREO_VIDEO_LEFT = 0x0,
+	STEREO_VIDEO_RIGHT = 0x1,
+} STEREO_VIDEO_ATTR;
+
+typedef enum {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+} BT_TYPE;
+
+typedef enum {
+#if 0
+	VIC_MODE_1_59_94Hz,
+	VIC_MODE_1_60Hz,
+	VIC_MODE_2_59_94Hz,
+	VIC_MODE_2_60Hz,
+#endif
+	VIC_MODE_3_59_94Hz,
+#if 0
+	VIC_MODE_3_60Hz,
+	VIC_MODE_4_59_94Hz,
+#endif
+	VIC_MODE_4_60Hz,
+#if 0
+	VIC_MODE_5_59_94Hz,
+	VIC_MODE_5_60Hz,
+	VIC_MODE_6_59_94Hz,
+	VIC_MODE_6_60Hz,
+	VIC_MODE_7_59_94Hz,
+	VIC_MODE_7_60Hz,
+	VIC_MODE_8_MODE1_59_94Hz,
+	VIC_MODE_8_MODE1_60Hz,
+	VIC_MODE_8_MODE2_59_94Hz,
+	VIC_MODE_8_MODE2_60Hz,
+	VIC_MODE_9_MODE1_59_94Hz,
+	VIC_MODE_9_MODE1_60Hz,
+	VIC_MODE_9_MODE2_59_94Hz,
+	VIC_MODE_9_MODE2_60Hz,
+	VIC_MODE_10_59_94Hz,
+	VIC_MODE_10_60Hz,
+	VIC_MODE_11_59_94Hz,
+	VIC_MODE_11_60Hz,
+	VIC_MODE_12_MODE_1_59_94Hz,
+	VIC_MODE_12_MODE_1_60Hz,
+	VIC_MODE_12_MODE_2_59_94Hz,
+	VIC_MODE_12_MODE_2_60Hz,
+	VIC_MODE_13_MODE_1_59_94Hz,
+	VIC_MODE_13_MODE_1_60Hz,
+	VIC_MODE_13_MODE_2_59_94Hz,
+	VIC_MODE_13_MODE_2_60Hz,
+	VIC_MODE_14_59_94Hz,
+	VIC_MODE_14_60Hz,
+	VIC_MODE_15_59_94Hz,
+	VIC_MODE_15_60Hz,
+	VIC_MODE_16_59_94Hz,
+#endif
+	VIC_MODE_16_60Hz,
+#if 0
+	VIC_MODE_17_50Hz,
+	VIC_MODE_18_50Hz,
+	VIC_MODE_19_50Hz,
+	VIC_MODE_20_50Hz,
+	VIC_MODE_21_50Hz,
+	VIC_MODE_22_50Hz,
+	VIC_MODE_23_MODE_1_50Hz,
+	VIC_MODE_23_MODE_2_50Hz,
+	VIC_MODE_23_MODE_3_50Hz,
+	VIC_MODE_24_MODE_1_50Hz,
+	VIC_MODE_24_MODE_2_50Hz,
+	VIC_MODE_24_MODE_3_50Hz,
+	VIC_MODE_25_50Hz,
+	VIC_MODE_26_50Hz,
+	VIC_MODE_27_MODE_1_50Hz,
+	VIC_MODE_27_MODE_2_50Hz,
+	VIC_MODE_27_MODE_3_50Hz,
+	VIC_MODE_28_MODE_1_50Hz,
+	VIC_MODE_28_MODE_2_50Hz,
+	VIC_MODE_28_MODE_3_50Hz,
+	VIC_MODE_29_50Hz,
+	VIC_MODE_30_50Hz,
+	VIC_MODE_31_50Hz,
+	VIC_MODE_32_23_97Hz,
+	VIC_MODE_32_24Hz,
+	VIC_MODE_33_25Hz,
+	VIC_MODE_34_29_97Hz,
+	VIC_MODE_34_30Hz,
+	VIC_MODE_35_59_94Hz,
+	VIC_MODE_35_60Hz,
+	VIC_MODE_36_59_94Hz,
+	VIC_MODE_36_60Hz,
+	VIC_MODE_37_50Hz,
+	VIC_MODE_38_50Hz,
+	VIC_MODE_39_50Hz,
+	VIC_MODE_40_100Hz,
+	VIC_MODE_41_100Hz,
+	VIC_MODE_42_100Hz,
+	VIC_MODE_43_100Hz,
+	VIC_MODE_44_100Hz,
+	VIC_MODE_45_100Hz,
+	VIC_MODE_46_119_88Hz,
+	VIC_MODE_46_120Hz,
+	VIC_MODE_47_119_88Hz,
+	VIC_MODE_47_120Hz,
+	VIC_MODE_48_119_88Hz,
+	VIC_MODE_48_120Hz,
+	VIC_MODE_49_119_88Hz,
+	VIC_MODE_49_120Hz,
+	VIC_MODE_50_119_88Hz,
+	VIC_MODE_50_120Hz,
+	VIC_MODE_51_119_88Hz,
+	VIC_MODE_51_120Hz,
+	VIC_MODE_52_200Hz,
+	VIC_MODE_53_200Hz,
+	VIC_MODE_54_200Hz,
+	VIC_MODE_55_200Hz,
+	VIC_MODE_56_239Hz,
+	VIC_MODE_56_240Hz,
+	VIC_MODE_57_239Hz,
+	VIC_MODE_57_240Hz,
+	VIC_MODE_58_239Hz,
+	VIC_MODE_58_240Hz,
+	VIC_MODE_59_239Hz,
+	VIC_MODE_59_240Hz,
+	VIC_MODE_60_23_97Hz,
+	VIC_MODE_60_24Hz,
+	VIC_MODE_61_25Hz,
+	VIC_MODE_62_29_97Hz,
+	VIC_MODE_62_30Hz,
+	VIC_MODE_63_119_88Hz,
+	VIC_MODE_63_120Hz,
+	VIC_MODE_64_100Hz,
+#endif
+	VIC_MODE_97_60Hz,
+	VIC_MODE_95_50Hz,
+#if 0
+	VIC_MODE_VESA_800X600P_60Hz,
+	VIC_MODE_VESA_720X400P_70Hz,
+	VIC_MODE_VESA_720X400P_88Hz,
+	VIC_MODE_VESA_640X480P_60Hz,
+	VIC_MODE_VESA_640X480P_67Hz,
+	VIC_MODE_VESA_640X480P_72Hz,
+	VIC_MODE_VESA_640X480P_75Hz,
+	VIC_MODE_VESA_800X600P_56Hz,
+	VIC_MODE_VESA_800X600P_72Hz,
+	VIC_MODE_VESA_832X624P_75Hz,
+	VIC_MODE_VESA_1024X768I_87Hz,
+	VIC_MODE_VESA_1024X768P_60Hz,
+	VIC_MODE_VESA_1024X768P_72Hz,
+	VIC_MODE_VESA_1024X768P_75Hz,
+	VIC_MODE_VESA_1280X1024P_75Hz,
+	VIC_MODE_VESA_1152X870P_75Hz,
+#endif
+	VIC_MODE_COUNT
+} VIC_MODES;
+
+extern const unsigned int vic_table[VIC_MODE_COUNT][27];
+
+#endif
diff --git a/drivers/video/fbdev/mxc/imx8_hdmi.c b/drivers/video/fbdev/mxc/imx8_hdmi.c
new file mode 100644
index 0000000..dc0ae6c
--- /dev/null
+++ b/drivers/video/fbdev/mxc/imx8_hdmi.c
@@ -0,0 +1,371 @@
+/*
+ * Copyright 2017 NXP.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/console.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/bitops.h>
+#include <linux/module.h>
+#include <linux/mxcfb.h>
+#include <linux/pm_runtime.h>
+#include <linux/busfreq-imx.h>
+#include <linux/backlight.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/of_graph.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <video/mxc_edid.h>
+#include <linux/mfd/syscon.h>
+
+#include "mxc_dispdrv.h"
+#include "./cdn_hdp/address.h"
+#include "./cdn_hdp/apb_cfg.h"
+#include "./cdn_hdp/API_General.h"
+#include "./cdn_hdp/API_HDMITX.h"
+#include "./cdn_hdp/API_AVI.h"
+#include "./cdn_hdp/API_AFE.h"
+#include "./cdn_hdp/API_AFE_t28hpc_hdmitx.h"
+#include "./cdn_hdp/externs.h"
+#include "./cdn_hdp/source_car.h"
+#include "./cdn_hdp/source_phy.h"
+#include "./cdn_hdp/source_vif.h"
+#include "./cdn_hdp/vic_table.h"
+
+#define DISPDRV_HDMI		"hdmi_disp"
+
+void __iomem *g_sec_base;
+void __iomem *g_regs_base;
+
+struct pll_divider {
+	unsigned int cm;	/* multiplier */
+	unsigned int cn;	/* predivider */
+	unsigned int co;	/* outdivider */
+};
+
+/* driver private data */
+struct imx_hdmi_info {
+	struct platform_device *pdev;
+	void __iomem *regs_base;
+	void __iomem *sec_base;
+	void __iomem *phy_base;
+	int power_on;
+	u32 dphy_pll_config;
+	int dev_id;
+	int disp_id;
+	int irq;
+	int vic;
+	struct clk *core_clk;
+	struct clk *phy_ref_clk;
+	struct mxc_dispdrv_handle *disp_hdmi;
+	struct fb_videomode *mode;
+	struct regulator *disp_power_on;
+};
+
+static int hdmi_init(int vic, int encoding, int color_depth)
+{
+	int ret;
+	uint32_t character_freq_khz;
+
+	bool pixel_clk_from_phy = 0;
+	uint8_t echo_msg[] = "echo test";
+	uint8_t echo_resp[sizeof(echo_msg) + 1];
+	/* Parameterization: */
+
+	/* VIC Mode - index from vic_table (see vic_table.c) */
+	VIC_MODES vic_mode = vic;
+
+	/* Pixel Format - 1 RGB, 2 YCbCr 444, 3 YCbCr 420 */
+	VIC_PXL_ENCODING_FORMAT format = encoding;
+
+	/*  B/W Balance Type: 0 no data, 1 IT601, 2 ITU709 */
+	BT_TYPE bw_type = 0;
+
+	/* bpp (bits per subpixel) - 8 24bpp, 10 30bpp, 12 36bpp, 16 48bpp */
+	uint8_t bps = color_depth;
+
+	/* Set HDMI TX Mode */
+	/* Mode = 0 - DVI, 1 - HDMI1.4, 2 HDMI 2.0 */
+	HDMI_TX_MAIL_HANDLER_PROTOCOL_TYPE ptype = 1;
+
+	/* 0- pixel clock from phy */
+	pixel_clk_from_phy = 1;
+
+	if (vic_mode == VIC_MODE_97_60Hz)
+		ptype = 2;
+
+	/* Parameterization done */
+
+	CDN_API_Init();
+	printk("CDN_API_Init completed\n");
+
+	ret = CDN_API_CheckAlive_blocking();
+	printk("CDN_API_CheckAlive returned ret = %d\n", ret);
+
+	ret = CDN_API_General_Test_Echo_Ext_blocking(echo_msg, echo_resp,
+						     sizeof(echo_msg),
+						     CDN_BUS_TYPE_APB);
+	printk
+	    ("CDN_API_General_Test_Echo_Ext_blocking - APB(ret = %d echo_resp = %s)\n",
+	     ret, echo_resp);
+	/* Configure PHY */
+	character_freq_khz =
+	    phy_cfg_hdp(4, vic_mode, bps, format, pixel_clk_from_phy);
+
+	hdmi_tx_kiran_power_configuration_seq(4);
+
+	/* Set the lane swapping */
+	ret =
+	    CDN_API_General_Write_Register_blocking(ADDR_SOURCD_PHY +
+						    (LANES_CONFIG << 2),
+						    F_SOURCE_PHY_LANE0_SWAP(0) |
+						    F_SOURCE_PHY_LANE1_SWAP(1) |
+						    F_SOURCE_PHY_LANE2_SWAP(2) |
+						    F_SOURCE_PHY_LANE3_SWAP(3) |
+						    F_SOURCE_PHY_COMB_BYPASS(0)
+						    | F_SOURCE_PHY_20_10(1));
+	printk
+	    ("CDN_API_General_Write_Register_blocking LANES_CONFIG ret = %d\n",
+	     ret);
+
+	ret = CDN_API_HDMITX_Init_blocking();
+	printk("CDN_API_STATUS CDN_API_HDMITX_Init_blocking  ret = %d\n", ret);
+
+	/* Set HDMI TX Mode */
+	ret = CDN_API_HDMITX_Set_Mode_blocking(ptype, character_freq_khz);
+	printk("CDN_API_HDMITX_Set_Mode_blocking ret = %d\n", ret);
+
+	ret = CDN_API_Set_AVI(vic_mode, format, bw_type);
+	printk("CDN_API_Set_AVI  ret = %d\n", ret);
+
+	ret = CDN_API_HDMITX_SetVic_blocking(vic_mode, bps, format);
+	printk("CDN_API_HDMITX_SetVic_blocking ret = %d\n", ret);
+
+	udelay(10000);
+
+	return 0;
+}
+
+static int imx_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
+			      struct mxc_dispdrv_setting *setting)
+{
+	return true;
+}
+
+static void imx_hdmi_disp_deinit(struct mxc_dispdrv_handle *disp)
+{
+}
+
+
+static int imx_hdmi_enable(struct mxc_dispdrv_handle *disp, struct fb_info *fbi)
+{
+	/* 0-480p, 1-720p, 2-1080p, 3-2160p */
+	return 0;
+}
+
+static void imx_hdmi_disable(struct mxc_dispdrv_handle *disp,
+			     struct fb_info *fbi)
+{
+}
+
+static int imx_hdmi_setup(struct mxc_dispdrv_handle *disp, struct fb_info *fbi)
+{
+	return 0;
+}
+
+static struct mxc_dispdrv_driver imx_hdmi_drv = {
+	.name = DISPDRV_HDMI,
+	.init = imx_hdmi_disp_init,
+	.deinit = imx_hdmi_disp_deinit,
+	.enable = imx_hdmi_enable,
+	.disable = imx_hdmi_disable,
+	.setup = imx_hdmi_setup,
+};
+
+#if 0
+static irqreturn_t imx_hdmi_irq_handler(int irq, void *data)
+{
+	return IRQ_HANDLED;
+}
+#endif
+
+static int hdmi_clks_init(struct imx_hdmi_info *hinfo)
+{
+	return true;
+}
+
+/**
+ * This function is called by the driver framework to initialize the HDMI
+ * device.
+ *
+ * @param	pdev	The device structure for the HDMI passed in by the
+ *			driver framework.
+ *
+ * @return      Returns 0 on success or negative error code on error
+ */
+static int imx_hdmi_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct imx_hdmi_info *imx_hdmi;
+	struct resource *res;
+	int ret = 0;
+	u32 vmode_index;
+
+	printk("%s\n", __func__);
+	imx_hdmi = devm_kzalloc(&pdev->dev, sizeof(*imx_hdmi), GFP_KERNEL);
+	if (!imx_hdmi)
+		return -ENOMEM;
+	imx_hdmi->pdev = pdev;
+
+	/* Get HDMI CTRL base register */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get platform mem resource\n");
+		return -ENOMEM;
+	}
+
+	imx_hdmi->regs_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(imx_hdmi->regs_base))
+		return -ENODEV;
+
+	g_regs_base = imx_hdmi->regs_base;
+
+	/* Get HDMI SEC base register */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get platform mem resource\n");
+		return -ENOMEM;
+	}
+
+	imx_hdmi->sec_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(imx_hdmi->sec_base))
+		return -ENODEV;
+
+	g_sec_base = imx_hdmi->sec_base;
+
+	/* IRQ */
+	imx_hdmi->irq = platform_get_irq(pdev, 0);
+	if (imx_hdmi->irq < 0) {
+		dev_err(&pdev->dev, "failed to get device irq\n");
+		return -EINVAL;
+	}
+#if 0
+	ret = devm_request_irq(&pdev->dev, imx_hdmi->irq,
+			       imx_hdmi_irq_handler,
+			       0, "imx_hdmi_cdn", imx_hdmi);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request hdmi irq\n");
+		return ret;
+	}
+#endif
+
+	hdmi_clks_init(imx_hdmi);
+
+	ret = of_property_read_u32(np, "video-mode", &vmode_index);
+	if (ret < 0)
+		return -EINVAL;
+
+	imx_hdmi->disp_hdmi = mxc_dispdrv_register(&imx_hdmi_drv);
+	if (IS_ERR(imx_hdmi->disp_hdmi)) {
+		dev_err(&pdev->dev, "mxc_dispdrv_register error\n");
+		ret = PTR_ERR(imx_hdmi->disp_hdmi);
+		goto dispdrv_reg_fail;
+	}
+
+	mxc_dispdrv_setdata(imx_hdmi->disp_hdmi, imx_hdmi);
+	dev_set_drvdata(&pdev->dev, imx_hdmi);
+
+	/* 0-480p, 1-720p, 2-1080p, 3-2160p60, 4-2160p30 */
+	/* Pixel Format - 1 RGB, 2 YCbCr 444, 3 YCbCr 420 */
+	if (vmode_index == 16)
+		hdmi_init(2, 1, 8);
+	else if (vmode_index == 97)
+		hdmi_init(3, 1, 8);
+	else if (vmode_index == 95)
+		hdmi_init(4, 1, 8);
+	else
+		hdmi_init(1, 1, 8);
+	dev_info(&pdev->dev, "i.MX HDMI driver probed\n");
+	return ret;
+
+dispdrv_reg_fail:
+	return ret;
+}
+
+static int imx_hdmi_remove(struct platform_device *pdev)
+{
+	struct imx_hdmi_info *imx_hdmi = dev_get_drvdata(&pdev->dev);
+
+	mxc_dispdrv_puthandle(imx_hdmi->disp_hdmi);
+	mxc_dispdrv_unregister(imx_hdmi->disp_hdmi);
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return 0;
+}
+
+static void imx_hdmi_shutdown(struct platform_device *pdev)
+{
+}
+
+
+static const struct of_device_id imx_imx_hdmi_dt_ids[] = {
+	{.compatible = "fsl,imx8mq-hdmi", .data = NULL,},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx_imx_hdmi_dt_ids);
+
+static struct platform_driver imx_hdmi_driver = {
+	.driver = {
+		   .of_match_table = imx_imx_hdmi_dt_ids,
+		   .name = "imx_hdmi",
+		   },
+	.probe = imx_hdmi_probe,
+	.remove = imx_hdmi_remove,
+	.shutdown = imx_hdmi_shutdown,
+};
+
+static int __init imx_hdmi_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&imx_hdmi_driver);
+	if (err) {
+		pr_err("imx_hdmi_driver register failed\n");
+		return err;
+	}
+
+	pr_debug("HDMI driver module loaded: %s\n",
+		 imx_hdmi_driver.driver.name);
+
+	return 0;
+}
+
+static void __exit imx_hdmi_exit(void)
+{
+	platform_driver_unregister(&imx_hdmi_driver);
+}
+
+module_init(imx_hdmi_init);
+module_exit(imx_hdmi_exit);
+
+MODULE_AUTHOR("NXP Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX HDMI driver");
+MODULE_LICENSE("GPL");
-- 
1.7.9.5


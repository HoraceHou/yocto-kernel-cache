From 30254db8fff996ca7d215cbbeae2fdf92769da13 Mon Sep 17 00:00:00 2001
From: Fugang Duan <fugang.duan@nxp.com>
Date: Tue, 30 Jan 2018 14:37:36 +0800
Subject: [PATCH 3289/5242] MLK-17475-03 net: phy: tja110x: add quirk for
 refclk_in selection

commit  d2ed51be6b22d9f3aa7813be7ef7f6aec4a26664 from
https://source.codeaurora.org/external/imx/linux-imx.git

When RMII signaling using an external crystal, refclk can output 50Mhz
to MAC as reference clock. When RMII signaling using an externally generated
reference clock refclk pin is input with 50Mhz.

Add one quirk to select the RMII refclk mode that depends on board design.

Reviewed-by: Pandy Gao <pandy.gao@nxp.com>
Signed-off-by: Fugang Duan <fugang.duan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/phy/tja110x.c |   39 +++++++++++++++++++++++++++++----------
 drivers/net/phy/tja110x.h |    3 +++
 2 files changed, 32 insertions(+), 10 deletions(-)

diff --git a/drivers/net/phy/tja110x.c b/drivers/net/phy/tja110x.c
index 7e06244..9ec978b 100644
--- a/drivers/net/phy/tja110x.c
+++ b/drivers/net/phy/tja110x.c
@@ -45,6 +45,8 @@
 #define MII_BUS_NAME "fec_enet_mii_bus"
 #endif
 
+#define TJA110X_REFCLK_IN	(1 << 0)
+
 /* Variable can be modified via parameter passed at load time
  * A nonzero value indicates that we should operate in managed mode
  */
@@ -70,6 +72,7 @@
  */
 static int nxp_config_init(struct phy_device *phydev)
 {
+	struct nxp_specific_data *nxp_specific = phydev->priv;
 	int reg_val;
 	int reg_name, reg_value = -1, reg_mask;
 	int err;
@@ -112,6 +115,11 @@ static int nxp_config_init(struct phy_device *phydev)
 			reg_value |= TJA1100_CFG1_AUTO_OP;
 		reg_mask = TJA1100_CFG1_AUTO_OP |
 		    TJA1100_CFG1_LED_EN | TJA1100_CFG1_LED_MODE;
+
+		if (nxp_specific->quirks & TJA110X_REFCLK_IN) {
+			reg_value |= TJA1100_CFG1_MII_MODE_REFCLK_IN;
+			reg_mask |= CFG1_MII_MODE;
+		}
 		break;
 	case NXP_PHY_ID_TJA1101:
 		/* fall through */
@@ -213,6 +221,7 @@ static int nxp_config_init(struct phy_device *phydev)
 static int nxp_probe(struct phy_device *phydev)
 {
 	int err;
+	struct device *dev = &phydev->mdio.dev;
 	struct nxp_specific_data *nxp_specific;
 
 	if (verbosity > 0)
@@ -222,6 +231,9 @@ static int nxp_probe(struct phy_device *phydev)
 	if (!nxp_specific)
 		goto phy_allocation_error;
 
+	if (of_property_read_bool(dev->of_node, "tja110x,refclk_in"))
+		nxp_specific->quirks |= TJA110X_REFCLK_IN;
+
 	nxp_specific->is_master = get_master_cfg(phydev);
 	nxp_specific->is_polling = 0;
 	nxp_specific->is_poll_setup = 0;
@@ -731,6 +743,7 @@ static int wakeup_from_sleep(struct phy_device *phydev)
 {
 	int err;
 	unsigned long wakeup_delay;
+	struct nxp_specific_data *nxp_specific = phydev->priv;
 
 	if (verbosity > 0)
 		dev_alert(&phydev->mdio.dev, "PHY %x waking up from sleep\n",
@@ -757,11 +770,14 @@ static int wakeup_from_sleep(struct phy_device *phydev)
 	if (err < 0)
 		goto phy_configure_error;
 
-	/* wait until the PLL is locked, indicating a completed transition */
-	err = wait_on_condition(phydev, MII_GENSTAT, GENSTAT_PLL_LOCKED,
-				GENSTAT_PLL_LOCKED, POWER_MODE_TIMEOUT);
-	if (err < 0)
-		goto phy_transition_error;
+	if (!(nxp_specific->quirks & TJA110X_REFCLK_IN)) {
+		/* wait until the PLL is locked, indicating a completed transition */
+		err = wait_on_condition(phydev, MII_GENSTAT, GENSTAT_PLL_LOCKED,
+					GENSTAT_PLL_LOCKED, POWER_MODE_TIMEOUT);
+		if (err < 0)
+			goto phy_transition_error;
+	}
+
 	/* if phy is configured as slave, also send a wakeup request
 	 * to master
 	 */
@@ -928,6 +944,7 @@ static int nxp_suspend(struct phy_device *phydev)
 static int nxp_resume(struct phy_device *phydev)
 {
 	int err;
+	struct nxp_specific_data *nxp_specific = phydev->priv;
 
 	if (verbosity > 0)
 		dev_alert(&phydev->mdio.dev, "resuming PHY %x\n", phydev->mdio.addr);
@@ -949,11 +966,13 @@ static int nxp_resume(struct phy_device *phydev)
 	if (err < 0)
 		goto phy_transition_error;
 
-	/* wait until the PLL is locked, indicating a completed transition */
-	err = wait_on_condition(phydev, MII_GENSTAT, GENSTAT_PLL_LOCKED,
-				GENSTAT_PLL_LOCKED, POWER_MODE_TIMEOUT);
-	if (err < 0)
-		goto phy_pll_error;
+	if (!(nxp_specific->quirks & TJA110X_REFCLK_IN)) {
+		/* wait until the PLL is locked, indicating a completed transition */
+		err = wait_on_condition(phydev, MII_GENSTAT, GENSTAT_PLL_LOCKED,
+					GENSTAT_PLL_LOCKED, POWER_MODE_TIMEOUT);
+		if (err < 0)
+			goto phy_pll_error;
+	}
 
 	/* reenable link control */
 	set_link_control(phydev, 1);
diff --git a/drivers/net/phy/tja110x.h b/drivers/net/phy/tja110x.h
index 98abb55..113dd14 100644
--- a/drivers/net/phy/tja110x.h
+++ b/drivers/net/phy/tja110x.h
@@ -86,6 +86,7 @@
 #define CFG1_REMWUPHY             BIT(11)
 #define CFG1_LOCWUPHY             BIT(10)
 #define CFG1_MII_MODE             (0x00000300U)
+#define TJA1100_CFG1_MII_MODE_REFCLK_IN	0x100
 #define CFG1_MII_DRIVER           BIT(7)
 #define CFG1_SLEEP_CONFIRM        BIT(6)
 #define TJA1100_CFG1_LED_MODE     (0x00000030U)
@@ -235,6 +236,8 @@ struct nxp_specific_data {
 	int is_master;
 	int is_poll_setup;
 	int is_polling;
+
+	u32 quirks;
 };
 
 /* register values of the different led modes */
-- 
1.7.9.5


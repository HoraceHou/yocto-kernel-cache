From 2a5581d40ff86c15b64b744ce46f00473e240316 Mon Sep 17 00:00:00 2001
From: Peng Fan <peng.fan@nxp.com>
Date: Fri, 3 Jun 2016 09:30:04 +0800
Subject: [PATCH 1084/5242] MLK-12740 cpuidle: imx6q: configure CCM to RUN
 mode when CPU is active

commit  de32a74bfecdc3703f2ebe637bad0d79d8fa13f3 from
https://source.codeaurora.org/external/imx/linux-imx.git

There are two states in i.MX6Q cpuidle driver.
state[1]: ARM WFI mode
state[2]: i.MX6Q WAIT mode

Take i.MX6DL as example, think out such a case:
1. CPU0/1 both run at normal mode
2. On CPU0, `sleep 1` is executed. And there are no workload on CPU1.
3. CPU0 first runs into state[2] and 'wfi' instruction. Switched to use
   GPT broadcast.
4. CPU1 runs into state[2] and configure CCM to WAIT MODE,
   then 'wfi' instruction. Now arm_clk and local timer clock are
   shutdown. Switched to use GPT broadcast
5. GPT broadcast timer interrupt comes to GPC/GIC, then CPU0 wakes up.
   CPU0 switched to use arm local timer. CPU1 is still sleeping.
6. No workload on CPU0, CPU0 runs into state[1]. But CCM register
   is still not restored to Normal RUN mode. 'wfi' + CCM WAIT will
   cause arm_clk and arm core clk.
   Now CPU0 stops, which is not correct.

So, need to make sure CCM configured to RUN mode when any cpu exit
state[2].

In this patch,
When CPU exits state[2], it configures CCM to RUN mode.
When all CPUs enters state[2], the last CPU needs to check
whether it's ok to configure CCM to WAIT mode or not.

In imx6q_set_lpm, we only need to unmask GINT when not WAIT_CLOCKED,
so add a check condition.

Signed-off-by: Peng Fan <peng.fan@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/cpuidle-imx6q.c |    5 ++++-
 arch/arm/mach-imx/pm-imx6.c       |    6 ++++--
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-imx/cpuidle-imx6q.c b/arch/arm/mach-imx/cpuidle-imx6q.c
index bfeb25a..02d55ae 100644
--- a/arch/arm/mach-imx/cpuidle-imx6q.c
+++ b/arch/arm/mach-imx/cpuidle-imx6q.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012, 2016 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -30,6 +30,8 @@ static int imx6q_enter_wait(struct cpuidle_device *dev,
 		if (!spin_trylock(&master_lock))
 			goto idle;
 		imx6_set_lpm(WAIT_UNCLOCKED);
+		if (atomic_read(&master) != num_online_cpus())
+			imx6_set_lpm(WAIT_CLOCKED);
 		cpu_do_idle();
 		imx6_set_lpm(WAIT_CLOCKED);
 		spin_unlock(&master_lock);
@@ -41,6 +43,7 @@ static int imx6q_enter_wait(struct cpuidle_device *dev,
 done:
 	atomic_dec(&master);
 
+	imx6_set_lpm(WAIT_CLOCKED);
 	return index;
 }
 
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index 56910b1..208790b 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -693,9 +693,11 @@ int imx6_set_lpm(enum mxc_cpu_pwr_mode mode)
 	 *
 	 * Note that IRQ #32 is GIC SPI #0.
 	 */
-	imx_gpc_hwirq_unmask(0);
+	if (mode != WAIT_CLOCKED)
+		imx_gpc_hwirq_unmask(0);
 	writel_relaxed(val, ccm_base + CLPCR);
-	imx_gpc_hwirq_mask(0);
+	if (mode != WAIT_CLOCKED)
+		imx_gpc_hwirq_mask(0);
 
 	return 0;
 }
-- 
1.7.9.5


From 9d6b670068c333f6b7d9711e0b257f10082eac23 Mon Sep 17 00:00:00 2001
From: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Date: Fri, 17 Nov 2017 11:03:52 +0200
Subject: [PATCH 2841/5242] MLK-16906: drm: imx: core: add possiblity to
 detect if chip has DCSS

commit  0ce22bc541f0d1b1008a3291a606d142cf3fccdc from
https://source.codeaurora.org/external/imx/linux-imx.git

The Mscale Display Controller Subsystem does not support RGB565.
However, the default legacy FB pixel depth is 16. Hence, the users would
have to add a kernel cmdline option to set it to 32bpp:
imxdrm.legacyfb_depth=32

This patch changes imx-drm-core to detect if platform has DCSS and, if
it does, set the FB pixel depth to 32, so that user does not have to.

Signed-off-by: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/imx-drm-core.c |   41 ++++++++++++++++++++++++++++++++----
 1 file changed, 37 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index 28dfa63..77b9aa5 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -144,19 +144,36 @@ static int compare_of(struct device *dev, void *data)
 	return dev->of_node == np;
 }
 
-static bool has_dpu(struct device *dev)
+static const char *const imx_drm_dpu_comp_parents[] = {
+	"fsl,imx8qm-dpu",
+	"fsl,imx8qxp-dpu",
+};
+
+static const char *const imx_drm_dcss_comp_parents[] = {
+	"nxp,imx8mq-dcss",
+};
+
+static bool imx_drm_parent_is_compatible(struct device *dev,
+					 const char *const comp_parents[],
+					 int comp_parents_size)
 {
 	struct device_node *port, *parent;
 	bool ret = false;
+	int i;
 
 	port = of_parse_phandle(dev->of_node, "ports", 0);
 	if (!port)
 		return ret;
 
 	parent = of_get_parent(port);
-	if (of_device_is_compatible(parent, "fsl,imx8qm-dpu") ||
-	    of_device_is_compatible(parent, "fsl,imx8qxp-dpu"))
-		ret = true;
+
+	for (i = 0; i < comp_parents_size; i++) {
+		if (of_device_is_compatible(parent, comp_parents[i])) {
+			ret = true;
+			break;
+		}
+	}
+
 	of_node_put(parent);
 
 	of_node_put(port);
@@ -164,6 +181,18 @@ static bool has_dpu(struct device *dev)
 	return ret;
 }
 
+static inline bool has_dpu(struct device *dev)
+{
+	return imx_drm_parent_is_compatible(dev, imx_drm_dpu_comp_parents,
+					ARRAY_SIZE(imx_drm_dpu_comp_parents));
+}
+
+static inline bool has_dcss(struct device *dev)
+{
+	return imx_drm_parent_is_compatible(dev, imx_drm_dcss_comp_parents,
+					ARRAY_SIZE(imx_drm_dcss_comp_parents));
+}
+
 static void add_dpu_bliteng_components(struct device *dev,
 				       struct component_match **matchptr)
 {
@@ -284,6 +313,10 @@ static int imx_drm_bind(struct device *dev)
 		dev_warn(dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
 		legacyfb_depth = 16;
 	}
+
+	if (legacyfb_depth == 16 && has_dcss(dev))
+		legacyfb_depth = 32;
+
 	ret = drm_fb_cma_fbdev_init(drm, legacyfb_depth, MAX_CRTC);
 	if (ret)
 		goto err_unbind;
-- 
1.7.9.5


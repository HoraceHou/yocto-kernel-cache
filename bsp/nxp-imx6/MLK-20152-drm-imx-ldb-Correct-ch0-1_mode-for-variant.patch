From af8e242a6acf8ca82be8f6343ac45cba7ebb39ff Mon Sep 17 00:00:00 2001
From: Liu Ying <victor.liu@nxp.com>
Date: Tue, 6 Nov 2018 15:46:40 +0800
Subject: [PATCH 5038/5242] MLK-20152 drm/imx: ldb: Correct ch0/1_mode for
 variants without mux

commit  64fba9b9488019d305d8685cdd1f128aa8146073 from
https://source.codeaurora.org/external/imx/linux-imx.git

Unlike i.MX6qdl and i.MX53 LDB variants, the i.MX8 LDB variants(i.MX8qxp
and i.MX8qm) in existence don't have frontend mux, thus, we should split
the logic to program the ch0/1_mode for variants w/wo the mux.  It turns
out LDB_CH0_MODE_EN_TO_DI0 can be used for channel0 in both LDB single
mode and LDB split mode for the i.MX8 LDB variants.  However, based on
test results, for i.MX8qm LDB channel1, LDB_CH1_MODE_EN_TO_DI1 has to be
used in single mode, while, i.MX8qxp may work with LDB_CH1_MODE_EN_TO_DI0
or LDB_CH1_MODE_EN_TO_DI1.  With LDB_CH1_MODE_EN_TO_DI0, i.MX8qm LDB
channel1 would output wrong image in single mode(it looks like color
is wrong based on test results).  The i.MX8 LDB variants channel1 mode
can still be LDB_CH1_MODE_EN_TO_DI0 in split mode(the patch doesn't
touch this).  In essence, this patch fixes the channel1 single mode for
i.MX8qm LDB by correcting the ch1_mode, while all other features
should work as before.  Note that due to hardware issue, we didn't test
the channel1 single mode for i.MX8qm.  We need to populate several
resistors to enable the connectors driven by channel1 in single mode
for either ARM2 platform or MEK board.  Tests are done with IT6263
LVDS to HDMI transmitter driven by LDB0 channel1 after r206, r207, r208
and r209 are populated on the i.MX8qm MEK board.

Signed-off-by: Liu Ying <victor.liu@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/gpu/drm/imx/imx-ldb.c |   23 ++++++++++++++++-------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/imx/imx-ldb.c b/drivers/gpu/drm/imx/imx-ldb.c
index e71dab0..c566de8 100644
--- a/drivers/gpu/drm/imx/imx-ldb.c
+++ b/drivers/gpu/drm/imx/imx-ldb.c
@@ -510,17 +510,26 @@ static void imx_ldb_encoder_enable(struct drm_encoder *encoder)
 
 	if (imx_ldb_ch == &ldb->channel[0] || dual) {
 		ldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;
-		if (mux == 0 || ldb->lvds_mux)
+		if (ldb->has_mux) {
+			if (mux == 0 || ldb->lvds_mux)
+				ldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;
+			else if (mux == 1)
+				ldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;
+		} else {
 			ldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;
-		else if (mux == 1)
-			ldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;
+		}
 	}
 	if (imx_ldb_ch == &ldb->channel[1] || dual) {
 		ldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;
-		if (mux == 1 || ldb->lvds_mux)
-			ldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;
-		else if (mux == 0)
-			ldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;
+		if (ldb->has_mux) {
+			if (mux == 1 || ldb->lvds_mux)
+				ldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;
+			else if (mux == 0)
+				ldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;
+		} else {
+			ldb->ldb_ctrl |= dual ?
+				LDB_CH1_MODE_EN_TO_DI0 : LDB_CH1_MODE_EN_TO_DI1;
+		}
 	}
 
 	if (ldb->lvds_mux) {
-- 
1.7.9.5


From 0fa315541edf25beb6958c8e8a6b9a9ce39edd05 Mon Sep 17 00:00:00 2001
From: Frank Li <Frank.Li@nxp.com>
Date: Thu, 17 May 2018 12:26:48 -0500
Subject: [PATCH 3841/5242] MLK-18338-2 perf: ddr: added axid filter support

commit  adfc7cffbb2579bee8d266ebd7c80b68bd76c79f from
https://source.codeaurora.org/external/imx/linux-imx.git

 perf stat -a -e ddr0/axid-read,axi_id=MMMMDDDD/ cmd

MMMM AXI_MASKING
DDDD AXI_ID

Signed-off-by: Frank Li <Frank.Li@nxp.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/perf/ddr-perf.c |   45 ++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 40 insertions(+), 5 deletions(-)

diff --git a/drivers/perf/ddr-perf.c b/drivers/perf/ddr-perf.c
index cbebdf6..73fe52e 100644
--- a/drivers/perf/ddr-perf.c
+++ b/drivers/perf/ddr-perf.c
@@ -21,6 +21,8 @@
 #define COUNTER_CNTL		0x0
 #define COUNTER_READ		0x20
 
+#define COUNTER_DPCR1		0x30
+
 #define CNTL_OVER		0x1
 #define CNTL_CLEAR		0x2
 #define CNTL_EN			0x4
@@ -80,6 +82,26 @@
 PMU_EVENT_ATTR_STRING(write, ddr_perf_write, "event=0x38");
 PMU_EVENT_ATTR_STRING(raw-hazard, ddr_perf_raw_hazard, "event=0x39");
 
+PMU_EVENT_ATTR_STRING(axid-read, ddr_perf_axid_read, "event=0x41");
+PMU_EVENT_ATTR_STRING(axid-write, ddr_perf_axid_write, "event=0x42");
+
+#define DDR_CAP_AXI_ID 0x1
+
+struct fsl_ddr_devtype_data {
+	unsigned int flags;
+};
+
+static const struct fsl_ddr_devtype_data imx8_data;
+static const struct fsl_ddr_devtype_data imx8m_data = {
+	.flags = DDR_CAP_AXI_ID,
+};
+
+static const struct of_device_id imx_ddr_pmu_dt_ids[] = {
+	{ .compatible = "fsl,imx8-ddr-pmu", .data = (void*)&imx8_data},
+	{ .compatible = "fsl,imx8m-ddr-pmu", .data = (void*)&imx8m_data},
+	{ /* sentinel */ }
+};
+
 struct ddr_pmu {
 	struct pmu pmu;
 	void __iomem *base;
@@ -89,6 +111,7 @@ struct ddr_pmu {
 	struct perf_event *active_events[NUM_COUNTER];
 	int total_events;
 	bool cycles_active;
+	struct fsl_ddr_devtype_data *devtype;
 };
 
 static ssize_t ddr_perf_cpumask_show(struct device *dev,
@@ -142,6 +165,8 @@ static ssize_t ddr_perf_cpumask_show(struct device *dev,
 	&ddr_perf_refresh.attr.attr,
 	&ddr_perf_write.attr.attr,
 	&ddr_perf_raw_hazard.attr.attr,
+	&ddr_perf_axid_read.attr.attr,
+	&ddr_perf_axid_write.attr.attr,
 	NULL,
 };
 
@@ -151,8 +176,11 @@ static ssize_t ddr_perf_cpumask_show(struct device *dev,
 };
 
 PMU_FORMAT_ATTR(event, "config:0-63");
+PMU_FORMAT_ATTR(axi_id, "config1:0-63");
+
 static struct attribute *ddr_perf_format_attrs[] = {
 	&format_attr_event.attr,
+	&format_attr_axi_id.attr,
 	NULL,
 };
 
@@ -276,6 +304,14 @@ static void ddr_perf_event_start(struct perf_event *event, int flags)
 	struct hw_perf_event *hwc = &event->hw;
 	int counter = hwc->idx;
 
+	if (pmu->devtype->flags & DDR_CAP_AXI_ID) {
+		if (event->attr.config == 0x41 ||
+		    event->attr.config == 0x42) {
+			int val = event->attr.config1;
+			writel(val, pmu->base + COUNTER_DPCR1);
+		}
+	}
+
 	local64_set(&hwc->prev_count, 0);
 
 	ddr_perf_event_enable(pmu, event->attr.config, counter, true);
@@ -413,6 +449,8 @@ static int ddr_perf_probe(struct platform_device *pdev)
 	int num;
 	int ret;
 	u32 irq;
+	const struct of_device_id *of_id =
+		of_match_device(imx_ddr_pmu_dt_ids, &pdev->dev);
 
 	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(&pdev->dev, iomem);
@@ -430,6 +468,8 @@ static int ddr_perf_probe(struct platform_device *pdev)
 	num = ddr_perf_init(pmu, base, &pdev->dev);
 	name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "ddr%d", num);
 
+	pmu->devtype = (struct fsl_ddr_devtype_data *)of_id->data;
+
 	cpumask_set_cpu(smp_processor_id(), &pmu->cpu);
 	ret = perf_pmu_register(&(pmu->pmu), name, -1);
 	if (ret)
@@ -473,11 +513,6 @@ static int ddr_perf_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id imx_ddr_pmu_dt_ids[] = {
-	{ .compatible = "fsl,imx8-ddr-pmu", },
-	{ /* sentinel */ }
-};
-
 static struct platform_driver imx_ddr_pmu_driver = {
 	.driver         = {
 		.name   = "imx-ddr-pmu",
-- 
1.7.9.5


From 56fe1ee8daa2f00b63d9579becbb102c207e218f Mon Sep 17 00:00:00 2001
From: Robert Chiras <robert.chiras@nxp.com>
Date: Mon, 26 Nov 2018 13:46:14 +0200
Subject: [PATCH 3/4] MLK-17537-1: drm/bridge: Correct the ADV7533 init

commit 1a48959bfc1de8f3501d2eac6a8e5f9c60c976f1 from
https://source.codeaurora.org/external/imx/linux-imx.git

According to the Analog Devices configuration script, there are some
steps that need to be made when configuring the ADV for a specific mode.
Some of those steps were missing from driver, so this patch takes care
of this.
Also, in mode_fixup, the driver is trying to reconfigure the DSI lanes
from 4 to 3, when pixel clock is lower than 80MHz, which is not
necessary. the lanes property represents the maximum available lanes on
that devices and should not differ from a mode to another.
The DSI host is the one who should predict how many lanes it could use
to drive a display mode, so remove this from ADV driver.

Signed-off-by: Robert Chiras <robert.chiras@nxp.com>
Reviewed-by: Laurentiu Palcu <laurentiu.palcu@nxp.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/gpu/drm/bridge/adv7511/adv7511.h     |  4 +-
 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c |  5 +-
 drivers/gpu/drm/bridge/adv7511/adv7533.c     | 72 +++++++++++++-------
 3 files changed, 54 insertions(+), 27 deletions(-)
 mode change 100644 => 100755 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c

diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511.h b/drivers/gpu/drm/bridge/adv7511/adv7511.h
index 0b931064c953..4ab4b3658853 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511.h
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511.h
@@ -218,6 +218,9 @@
 #define ADV7511_REG_CEC_SOFT_RESET	0x50
 
 #define ADV7533_REG_CEC_OFFSET		0x70
+#define FORMAT_RATIO(x, y) (((x) * 100) / (y))
+#define RATIO_16_9 FORMAT_RATIO(16, 9)
+#define RATIO_4_3  FORMAT_RATIO(4, 3)
 
 enum adv7511_input_clock {
 	ADV7511_INPUT_CLOCK_1X,
@@ -401,7 +404,6 @@ static inline int adv7511_cec_init(struct device *dev, struct adv7511 *adv7511)
 #ifdef CONFIG_DRM_I2C_ADV7533
 void adv7533_dsi_power_on(struct adv7511 *adv);
 void adv7533_dsi_power_off(struct adv7511 *adv);
-void adv7533_mode_set(struct adv7511 *adv, struct drm_display_mode *mode);
 bool adv7533_mode_fixup(struct adv7511 *adv, struct drm_display_mode *mode);
 int adv7533_patch_registers(struct adv7511 *adv);
 int adv7533_patch_cec_registers(struct adv7511 *adv);
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
old mode 100644
new mode 100755
index e72a52933c6a..e40b4645b0da
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -331,6 +331,7 @@ static void __adv7511_power_on(struct adv7511 *adv7511)
 {
 	adv7511->current_edid_segment = -1;
 
+	/* 01-02 Power */
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,
 			   ADV7511_POWER_POWER_DOWN, 0);
 	if (adv7511->i2c_main->irq) {
@@ -348,6 +349,7 @@ static void __adv7511_power_on(struct adv7511 *adv7511)
 	}
 
 	/*
+	 * 01-01 HPD Manual Override
 	 * Per spec it is allowed to pulse the HPD signal to indicate that the
 	 * EDID information has changed. Some monitors do this when they wakeup
 	 * from standby or are enabled. When the HPD goes low the adv7511 is
@@ -777,9 +779,6 @@ static void adv7511_mode_set(struct adv7511 *adv7511,
 	regmap_update_bits(adv7511->regmap, 0x17,
 		0x60, (vsync_polarity << 6) | (hsync_polarity << 5));
 
-	if (adv7511->type == ADV7533 || adv7511->type == ADV7535)
-		adv7533_mode_set(adv7511, adj_mode);
-
 	drm_mode_copy(&adv7511->curr_mode, adj_mode);
 
 	/*
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7533.c b/drivers/gpu/drm/bridge/adv7511/adv7533.c
index 84851e45f83c..eeee86fbf7de 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7533.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7533.c
@@ -34,10 +34,8 @@ static const struct reg_sequence adv7533_cec_fixed_registers[] = {
 
 static void adv7511_dsi_config_timing_gen(struct adv7511 *adv)
 {
-	struct mipi_dsi_device *dsi = adv->dsi;
 	struct drm_display_mode *mode = &adv->curr_mode;
 	unsigned int hsw, hfp, hbp, vsw, vfp, vbp;
-	u8 clock_div_by_lanes[] = { 6, 4, 3 };	/* 2, 3, 4 lanes */
 
 	hsw = mode->hsync_end - mode->hsync_start;
 	hfp = mode->hsync_start - mode->hdisplay;
@@ -46,9 +44,10 @@ static void adv7511_dsi_config_timing_gen(struct adv7511 *adv)
 	vfp = mode->vsync_start - mode->vdisplay;
 	vbp = mode->vtotal - mode->vsync_end;
 
-	/* set pixel clock divider mode */
-	regmap_write(adv->regmap_cec, 0x16,
-		     clock_div_by_lanes[dsi->lanes - 2] << 3);
+	/* 03-01 Enable Internal Timing Generator */
+	regmap_write(adv->regmap_cec, 0x27, 0xcb);
+
+	/* 03-08 Timing Configuration */
 
 	/* horizontal porch params */
 	regmap_write(adv->regmap_cec, 0x28, mode->htotal >> 4);
@@ -69,35 +68,66 @@ static void adv7511_dsi_config_timing_gen(struct adv7511 *adv)
 	regmap_write(adv->regmap_cec, 0x35, (vfp << 4) & 0xff);
 	regmap_write(adv->regmap_cec, 0x36, vbp >> 4);
 	regmap_write(adv->regmap_cec, 0x37, (vbp << 4) & 0xff);
+
+	/* 03-03 Reset Internal Timing Generator */
+	regmap_write(adv->regmap_cec, 0x27, 0xcb);
+	regmap_write(adv->regmap_cec, 0x27, 0x8b);
+	regmap_write(adv->regmap_cec, 0x27, 0xcb);
+
 }
 
 void adv7533_dsi_power_on(struct adv7511 *adv)
 {
 	struct mipi_dsi_device *dsi = adv->dsi;
+	struct drm_display_mode *mode = &adv->curr_mode;
+	u8 clock_div_by_lanes[] = { 6, 4, 3 };	/* 2, 3, 4 lanes */
 
-	if (adv->use_timing_gen)
-		adv7511_dsi_config_timing_gen(adv);
+	/* Gate DSI LP Oscillator */
+	regmap_update_bits(adv->regmap_cec, 0x03, 0x02, 0x00);
+
+	/* 01-03 Initialisation (Fixed) Registers */
+	regmap_register_patch(adv->regmap_cec, adv7533_cec_fixed_registers,
+			      ARRAY_SIZE(adv7533_cec_fixed_registers));
 
-	/* set number of dsi lanes */
+	/* 02-04 DSI Lanes */
 	regmap_write(adv->regmap_cec, 0x1c, dsi->lanes << 4);
 
-	if (adv->use_timing_gen) {
-		/* reset internal timing generator */
-		regmap_write(adv->regmap_cec, 0x27, 0xcb);
-		regmap_write(adv->regmap_cec, 0x27, 0x8b);
-		regmap_write(adv->regmap_cec, 0x27, 0xcb);
-	} else {
-		/* disable internal timing generator */
+	/* 02-05 DSI Pixel Clock Divider */
+	regmap_write(adv->regmap_cec, 0x16,
+		     clock_div_by_lanes[dsi->lanes - 2] << 3);
+
+	if (adv->use_timing_gen)
+		adv7511_dsi_config_timing_gen(adv);
+	else
 		regmap_write(adv->regmap_cec, 0x27, 0x0b);
-	}
 
-	/* enable hdmi */
+	/* 04-01 HDMI Output */
+	regmap_write(adv->regmap, 0xaf, 0x16);
+
+	/* 09-03 AVI Infoframe - RGB - 16-9 Aspect Ratio */
+	regmap_write(adv->regmap, ADV7511_REG_AVI_INFOFRAME(0), 0x10);
+	if (FORMAT_RATIO(mode->hdisplay, mode->vdisplay) == RATIO_16_9)
+		regmap_write(adv->regmap, ADV7511_REG_AVI_INFOFRAME(1), 0x28);
+	else if (FORMAT_RATIO(mode->hdisplay, mode->vdisplay) == RATIO_4_3)
+		regmap_write(adv->regmap, ADV7511_REG_AVI_INFOFRAME(1), 0x18);
+
+	/* 04-04 GC Packet Enable */
+	regmap_write(adv->regmap, ADV7511_REG_PACKET_ENABLE0, 0x80);
+
+	/* 04-06 GC Colour Depth - 24 Bit */
+	regmap_write(adv->regmap, 0x4c, 0x04);
+
+	/* 04-09 Down Dither Output Colour Depth - 8 Bit (default) */
+	regmap_write(adv->regmap, 0x49, 0x00);
+
+	/* 07-01 CEC Power Mode - Always Active */
+	regmap_write(adv->regmap_cec, 0xbe, 0x3d);
+
+	/* 04-03 HDMI Output Enable  */
 	regmap_write(adv->regmap_cec, 0x03, 0x89);
 	/* disable test mode */
 	regmap_write(adv->regmap_cec, 0x55, 0x00);
 
-	regmap_register_patch(adv->regmap_cec, adv7533_cec_fixed_registers,
-			      ARRAY_SIZE(adv7533_cec_fixed_registers));
 }
 
 void adv7533_dsi_power_off(struct adv7511 *adv)
@@ -108,10 +138,6 @@ void adv7533_dsi_power_off(struct adv7511 *adv)
 	regmap_write(adv->regmap_cec, 0x27, 0x0b);
 }
 
-void adv7533_mode_set(struct adv7511 *adv, struct drm_display_mode *mode)
-{
-}
-
 bool adv7533_mode_fixup(struct adv7511 *adv,
 			struct drm_display_mode *mode)
 {
-- 
2.17.1


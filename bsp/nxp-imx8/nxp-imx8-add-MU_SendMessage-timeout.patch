From 0bf984456fe1a8fbdf964faddfb7c7dee51ead34 Mon Sep 17 00:00:00 2001
From: qwang2 <quanyang.wang@windriver.com>
Date: Mon, 26 Nov 2018 20:30:54 +0800
Subject: [PATCH 2/2] nxp-imx8: add MU_SendMessage timeout

The rpmsg is a virtio-based messaging bus which allows kernel
drivers to communicate with remote processors available on
the system. The MU (Message Unit) in imx8 is used to implement
this function. The A side of MU is Cortex A53 and the B side of
MU is Cortex M4. But the Cortex M4 is in RESET mode without running
FreeRTOS on it. When imx_rpmsg_notify calls MU_SendMessage to send
a message to Cortex M4, the message will stay in MUA_ATRx register
and M4 will not read it in MUB_ARRx register. This means that
once imx_rpmsg_notify is called, the TEn(Processor A Transmit Register n Empty)
bit in MUA_ASR will stay zero. When the kexec kernel boots, MU_SendMessage
will run in a indefinite loop because the first boot kernel send message
to M4 failed.

So change indefinite loop to a time limited delay to avoid this.

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/soc/imx/mu/mx8_mu.c |   25 +++++++++++++++++++++----
 1 file changed, 21 insertions(+), 4 deletions(-)

diff --git a/drivers/soc/imx/mu/mx8_mu.c b/drivers/soc/imx/mu/mx8_mu.c
index 894c8fc..ad85426 100644
--- a/drivers/soc/imx/mu/mx8_mu.c
+++ b/drivers/soc/imx/mu/mx8_mu.c
@@ -8,6 +8,10 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/mx8_mu.h>
+#include <linux/delay.h>
+
+/* set send message fail maxium delay */
+#define MU_SEND_DELAY_MAX 10
 
 static int version;
 
@@ -87,17 +91,30 @@ void MU_EnableGeneralInt(void __iomem *base, uint32_t index)
 void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg)
 {
 	uint32_t mask = MU_SR_TE0_MASK1 >> regIndex;
+	uint32_t delay = 0;
 
 	if (unlikely(version == MU_VER_ID_V10)) {
 		/* Wait TX register to be empty. */
-		while (!(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask))
-			;
+		while (!(readl_relaxed(base + MU_V10_ASR_OFFSET1) & mask)) {
+			delay++;
+			udelay(100);
+			if (delay == MU_SEND_DELAY_MAX) {
+				printk("Last MU SendMessage failed!\r\n");
+				return ;
+			}
+		}
 		writel_relaxed(msg, base + MU_V10_ATR0_OFFSET1
 			       + (regIndex * 4));
 	} else {
 		/* Wait TX register to be empty. */
-		while (!(readl_relaxed(base + MU_ASR_OFFSET1) & mask))
-			;
+		while (!(readl_relaxed(base + MU_ASR_OFFSET1) & mask)) {
+			delay++;
+			udelay(100);
+			if (delay == MU_SEND_DELAY_MAX) {
+				printk("Last MU SendMessage timeout!\r\n");
+				return ;
+			}
+		}
 		writel_relaxed(msg, base + MU_ATR0_OFFSET1  + (regIndex * 4));
 	}
 }
-- 
1.7.9.5


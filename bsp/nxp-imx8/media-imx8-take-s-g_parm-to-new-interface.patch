From bd6bb9c8bb7b783a560d4dca5b8f1752ccd63d83 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Tue, 9 Apr 2019 09:58:25 +0800
Subject: [PATCH 25/30] media:imx8: take s/g_parm to new interface

In upstream commit 4471109e3894 ("media: convert g/s_parm to
g/s_frame_interval in subdevs"), g/s_parm should be converted
to g/s_frame_interval.

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../media/platform/imx8/hdmi/mxc-hdmi-rx.c    |  38 ++---
 drivers/media/platform/imx8/max9286.c         | 130 +++++------------
 drivers/media/platform/imx8/mxc-isi-cap.c     |   4 +-
 drivers/media/platform/imx8/mxc-mipi-csi2.c   |  14 +-
 .../media/platform/imx8/mxc-mipi-csi2_yav.c   |  14 +-
 .../media/platform/imx8/mxc-parallel-csi.c    |  14 +-
 drivers/media/platform/imx8/ov5640_mipi_v3.c  | 102 ++++----------
 drivers/media/platform/imx8/ov5640_v3.c       | 109 ++++----------
 .../media/platform/mxc/capture/mx6s_capture.c |   2 +-
 .../media/platform/mxc/capture/mxc_mipi_csi.c |  14 +-
 .../platform/mxc/capture/ov5640_mipi_v2.c     | 133 ++++++------------
 11 files changed, 173 insertions(+), 401 deletions(-)

diff --git a/drivers/media/platform/imx8/hdmi/mxc-hdmi-rx.c b/drivers/media/platform/imx8/hdmi/mxc-hdmi-rx.c
index 43cee8612a9a..c375cfadf971 100644
--- a/drivers/media/platform/imx8/hdmi/mxc-hdmi-rx.c
+++ b/drivers/media/platform/imx8/hdmi/mxc-hdmi-rx.c
@@ -276,7 +276,8 @@ static void mxc_hdmi_pixel_link_encoder(struct mxc_hdmi_rx_dev *hdmi_rx)
 /* -----------------------------------------------------------------------------
  * v4l2_subdev_video_ops
  */
-static int mxc_hdmi_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mxc_hdmi_s_frame_interval(struct v4l2_subdev *sd,
+										struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_hdmi_rx_dev *hdmi_rx = imx_sd_to_hdmi(sd);
 	struct device *dev = &hdmi_rx->pdev->dev;
@@ -286,9 +287,9 @@ static int mxc_hdmi_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
 	return 0;
 }
 
-static int mxc_hdmi_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mxc_hdmi_g_frame_interval(struct v4l2_subdev *sd,
+										struct v4l2_subdev_frame_interval *ival)
 {
-	struct v4l2_captureparm *cparm = &a->parm.capture;
 	struct mxc_hdmi_rx_dev *hdmi_rx = imx_sd_to_hdmi(sd);
 	int ret = 0;
 
@@ -297,31 +298,8 @@ static int mxc_hdmi_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
 		return -EINVAL;
 	}
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		memset(a, 0, sizeof(*a));
-		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cparm->timeperframe.denominator = hdmi_rx->timings->fps;
-		cparm->timeperframe.numerator = 1;
-		ret = 0;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		ret = -EINVAL;
-		break;
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
-	}
+	ival->interval.denominator = hdmi_rx->timings->fps;
+	ival->interval.numerator = 1;
 
 	return ret;
 }
@@ -364,8 +342,8 @@ static int mxc_hdmi_s_stream(struct v4l2_subdev *sd, int enable)
 
 static const struct v4l2_subdev_video_ops imx_video_ops_hdmi = {
 	.s_stream = mxc_hdmi_s_stream,
-	.g_parm =	mxc_hdmi_g_parm,
-	.s_parm =	mxc_hdmi_s_parm,
+	.g_frame_interval =	mxc_hdmi_g_frame_interval,
+	.s_frame_interval =	mxc_hdmi_s_frame_interval,
 };
 
 /* -----------------------------------------------------------------------------
diff --git a/drivers/media/platform/imx8/max9286.c b/drivers/media/platform/imx8/max9286.c
index 1b71c652873a..bbc3af6d89e6 100644
--- a/drivers/media/platform/imx8/max9286.c
+++ b/drivers/media/platform/imx8/max9286.c
@@ -2735,44 +2735,20 @@ static int ov10635_change_mode(struct sensor_data *max9286_data)
 	return retval;
 }
 
-static int max9286_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int max9286_g_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
-	struct v4l2_captureparm *cparm = &a->parm.capture;
 	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		memset(a, 0, sizeof(*a));
-		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cparm->capability = max9286_data->streamcap.capability;
-		cparm->timeperframe = max9286_data->streamcap.timeperframe;
-		cparm->capturemode = max9286_data->streamcap.capturemode;
-		ret = 0;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		ret = -EINVAL;
-		break;
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
-	}
+	ival->interval.numerator = max9286_data->streamcap.timeperframe.numerator;
+	ival->interval.denominator = max9286_data->streamcap.timeperframe.denominator;
 
 	return ret;
 }
 
 /*!
- * ioctl_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * ioctl_s_frame_interval - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
  * @s: pointer to standard V4L2 device structure
  * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
  *
@@ -2780,80 +2756,50 @@ static int max9286_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
  * not possible, reverts to the old parameters and returns the
  * appropriate error code.
  */
-static int max9286_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int max9286_s_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct sensor_data *max9286_data = subdev_to_sensor_data(sd);
-	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	struct v4l2_fract *timeperframe = &ival->interval;
 	enum ov10635_frame_rate frame_rate;
-	enum ov10635_mode mode = a->parm.capture.capturemode;
 	u32 tgt_fps;
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		/* Check that the new frame rate is allowed. */
-		if ((timeperframe->numerator == 0) ||
-		    (timeperframe->denominator == 0)) {
-			timeperframe->denominator = DEFAULT_FPS;
-			timeperframe->numerator = 1;
-		}
-
-		tgt_fps = timeperframe->denominator /
-			  timeperframe->numerator;
-
-		if (tgt_fps > MAX_FPS) {
-			timeperframe->denominator = MAX_FPS;
-			timeperframe->numerator = 1;
-		} else if (tgt_fps < MIN_FPS) {
-			timeperframe->denominator = MIN_FPS;
-			timeperframe->numerator = 1;
-		}
-
-		/* Actual frame rate we use */
-		tgt_fps = timeperframe->denominator /
-			  timeperframe->numerator;
-
-		if (tgt_fps == 30)
-			frame_rate = OV10635_30_FPS;
-		if (tgt_fps == 15)
-			frame_rate = OV10635_15_FPS;
+	/* Check that the new frame rate is allowed. */
+	if ((timeperframe->numerator == 0) ||
+		(timeperframe->denominator == 0)) {
+		timeperframe->denominator = DEFAULT_FPS;
+		timeperframe->numerator = 1;
+	}
 
-		if (frame_rate != OV10635_30_FPS && frame_rate != OV10635_15_FPS) {
-			pr_err(" The camera %d frame rate is not supported!\n", frame_rate);
-			return -EINVAL;
-		}
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
 
-		if (mode > ov10635_mode_MAX || mode < ov10635_mode_MIN) {
-			pr_err("The camera mode[%d] is not supported!\n", mode);
-			return -EINVAL;
-		}
+	if (tgt_fps > MAX_FPS) {
+		timeperframe->denominator = MAX_FPS;
+		timeperframe->numerator = 1;
+	} else if (tgt_fps < MIN_FPS) {
+		timeperframe->denominator = MIN_FPS;
+		timeperframe->numerator = 1;
+	}
 
-		max9286_data->streamcap.timeperframe = *timeperframe;
-		max9286_data->streamcap.capturemode = a->parm.capture.capturemode;
-		max9286_data->format.reserved[0] = 72 * 8;
-		break;
+	/* Actual frame rate we use */
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
 
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		pr_debug("   type is not "\
-				 "V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
-			a->type);
-		ret = -EINVAL;
-		break;
+	if (tgt_fps == 30)
+		frame_rate = OV10635_30_FPS;
+	if (tgt_fps == 15)
+		frame_rate = OV10635_15_FPS;
 
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
+	if (frame_rate != OV10635_30_FPS && frame_rate != OV10635_15_FPS) {
+		pr_err(" The camera %d frame rate is not supported!\n", frame_rate);
+		return -EINVAL;
 	}
 
+	max9286_data->streamcap.timeperframe = *timeperframe;
+	max9286_data->format.reserved[0] = 72 * 8;
+
 	return ret;
 }
 
@@ -3127,8 +3073,8 @@ static const struct v4l2_subdev_core_ops max9286_core_ops = {
 };
 
 static const struct v4l2_subdev_video_ops max9286_video_ops = {
-	.s_parm =	max9286_s_parm,
-	.g_parm =	max9286_g_parm,
+	.s_frame_interval =	max9286_s_frame_interval,
+	.g_frame_interval =	max9286_g_frame_interval,
 	.s_stream		= max9286_s_stream,
 };
 
diff --git a/drivers/media/platform/imx8/mxc-isi-cap.c b/drivers/media/platform/imx8/mxc-isi-cap.c
index da90c91cf880..33bf9f5c786a 100644
--- a/drivers/media/platform/imx8/mxc-isi-cap.c
+++ b/drivers/media/platform/imx8/mxc-isi-cap.c
@@ -1191,7 +1191,7 @@ static int mxc_isi_cap_g_parm(struct file *file, void *fh,
 		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote subdev found!\n", __func__);
 		return -EINVAL;
 	}
-	return v4l2_subdev_call(sd, video, g_parm, a);
+	return v4l2_g_parm_cap(video_devdata(file), sd, a);
 }
 
 static int mxc_isi_cap_s_parm(struct file *file, void *fh,
@@ -1213,7 +1213,7 @@ static int mxc_isi_cap_s_parm(struct file *file, void *fh,
 		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote subdev found!\n", __func__);
 		return -EINVAL;
 	}
-	return v4l2_subdev_call(sd, video, s_parm, a);
+	return v4l2_s_parm_cap(video_devdata(file), sd, a);
 }
 
 static int mxc_isi_cap_enum_framesizes(struct file *file, void *priv,
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2.c b/drivers/media/platform/imx8/mxc-mipi-csi2.c
index 313ec77cd2cf..980d5e3a88f3 100644
--- a/drivers/media/platform/imx8/mxc-mipi-csi2.c
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2.c
@@ -457,7 +457,8 @@ static int mipi_csi2_s_power(struct v4l2_subdev *sd, int on)
 	return v4l2_subdev_call(sen_sd, core, s_power, on);
 }
 
-static int mipi_csi2_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mipi_csi2_s_frame_interval(struct v4l2_subdev *sd,
+									struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
 	struct media_pad *source_pad;
@@ -476,10 +477,11 @@ static int mipi_csi2_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
 		v4l2_err(&csi2dev->v4l2_dev, "%s, No remote subdev found!\n", __func__);
 		return -EINVAL;
 	}
-	return v4l2_subdev_call(sen_sd, video, s_parm, a);
+	return v4l2_subdev_call(sen_sd, video, s_frame_interval, ival);
 }
 
-static int mipi_csi2_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mipi_csi2_g_frame_interval(struct v4l2_subdev *sd,
+									struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
 	struct media_pad *source_pad;
@@ -499,7 +501,7 @@ static int mipi_csi2_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
 		return -EINVAL;
 	}
 
-	return v4l2_subdev_call(sen_sd, video, g_parm, a);
+	return v4l2_subdev_call(sen_sd, video, g_frame_interval, ival);
 }
 
 static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
@@ -646,8 +648,8 @@ static struct v4l2_subdev_core_ops mipi_csi2_core_ops = {
 };
 
 static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
-	.s_parm = mipi_csi2_s_parm,
-	.g_parm = mipi_csi2_g_parm,
+	.s_frame_interval = mipi_csi2_s_frame_interval,
+	.g_frame_interval = mipi_csi2_g_frame_interval,
 	.s_stream = mipi_csi2_s_stream,
 };
 
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c b/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
index 0c97ff990c73..1a113116c9e5 100644
--- a/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
@@ -414,20 +414,22 @@ static int mipi_csi2_set_fmt(struct v4l2_subdev *sd,
 	return v4l2_subdev_call(sensor_sd, pad, set_fmt, NULL, fmt);
 }
 
-static int mipi_csis_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mipi_csis_s_frame_interval(struct v4l2_subdev *sd,
+										struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
 	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
 
-	return v4l2_subdev_call(sensor_sd, video, s_parm, a);
+	return v4l2_subdev_call(sensor_sd, video, s_frame_interval, ival);
 }
 
-static int mipi_csis_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mipi_csis_g_frame_interval(struct v4l2_subdev *sd,
+										struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
 	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
 
-	return v4l2_subdev_call(sensor_sd, video, g_parm, a);
+	return v4l2_subdev_call(sensor_sd, video, g_frame_interval, ival);
 }
 
 static const struct v4l2_subdev_internal_ops mipi_csi2_sd_internal_ops = {
@@ -449,8 +451,8 @@ static struct v4l2_subdev_core_ops mipi_csi2_core_ops = {
 static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
 	.s_stream = mipi_csi2_s_stream,
 
-	.s_parm = mipi_csis_s_parm,
-	.g_parm = mipi_csis_g_parm,
+	.s_frame_interval = mipi_csis_s_frame_interval,
+	.g_frame_interval = mipi_csis_g_frame_interval,
 };
 
 static struct v4l2_subdev_ops mipi_csi2_subdev_ops = {
diff --git a/drivers/media/platform/imx8/mxc-parallel-csi.c b/drivers/media/platform/imx8/mxc-parallel-csi.c
index afefdd54db08..8a5197488901 100644
--- a/drivers/media/platform/imx8/mxc-parallel-csi.c
+++ b/drivers/media/platform/imx8/mxc-parallel-csi.c
@@ -413,7 +413,8 @@ static int mxc_pcsi_s_power(struct v4l2_subdev *sd, int on)
 	return v4l2_subdev_call(sen_sd, core, s_power, on);
 }
 
-static int mxc_pcsi_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mxc_pcsi_s_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
 	struct media_pad *source_pad;
@@ -433,10 +434,11 @@ static int mxc_pcsi_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
 		return -EINVAL;
 	}
 
-	return v4l2_subdev_call(sen_sd, video, s_parm, a);
+	return v4l2_subdev_call(sen_sd, video, s_frame_interval, ival);
 }
 
-static int mxc_pcsi_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int mxc_pcsi_g_frame_interval(struct v4l2_subdev *sd,
+										struct v4l2_subdev_frame_interval *ival)
 {
 	struct mxc_parallel_csi_dev *pcsidev = sd_to_mxc_pcsi_dev(sd);
 	struct media_pad *source_pad;
@@ -455,7 +457,7 @@ static int mxc_pcsi_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
 		v4l2_err(&pcsidev->v4l2_dev, "%s, No remote subdev found!\n", __func__);
 		return -EINVAL;
 	}
-	return v4l2_subdev_call(sen_sd, video, g_parm, a);
+	return v4l2_subdev_call(sen_sd, video, g_frame_interval, ival);
 }
 
 static int mxc_pcsi_s_stream(struct v4l2_subdev *sd, int enable)
@@ -524,8 +526,8 @@ static struct v4l2_subdev_core_ops pcsi_core_ops = {
 };
 
 static struct v4l2_subdev_video_ops pcsi_video_ops = {
-	.s_parm = mxc_pcsi_s_parm,
-	.g_parm = mxc_pcsi_g_parm,
+	.s_frame_interval = mxc_pcsi_s_frame_interval,
+	.g_frame_interval = mxc_pcsi_g_frame_interval,
 	.s_stream = mxc_pcsi_s_stream,
 };
 
diff --git a/drivers/media/platform/imx8/ov5640_mipi_v3.c b/drivers/media/platform/imx8/ov5640_mipi_v3.c
index e1197e71fc1f..055f0845e32b 100644
--- a/drivers/media/platform/imx8/ov5640_mipi_v3.c
+++ b/drivers/media/platform/imx8/ov5640_mipi_v3.c
@@ -807,40 +807,15 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
  *
  * Returns the sensor's video CAPTURE parameters.
  */
-static int ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int ov5640_g_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5640 *sensor = to_ov5640(client);
-	struct v4l2_captureparm *cparm = &a->parm.capture;
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		memset(a, 0, sizeof(*a));
-		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cparm->capability = sensor->streamcap.capability;
-		cparm->timeperframe = sensor->streamcap.timeperframe;
-		cparm->capturemode = sensor->streamcap.capturemode;
-		ret = 0;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		ret = -EINVAL;
-		break;
-
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
-	}
+	ival->interval.numerator = sensor->streamcap.timeperframe.numerator;
+	ival->interval.denominator = sensor->streamcap.timeperframe.denominator;
 
 	return ret;
 }
@@ -854,65 +829,36 @@ static int ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
  * not possible, reverts to the old parameters and returns the
  * appropriate error code.
  */
-static int ov5640_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int ov5640_s_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5640 *sensor = to_ov5640(client);
-	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	struct v4l2_fract *timeperframe = &ival->interval;
 	u32 tgt_fps;	/* target frames per secound */
-	enum ov5640_mode mode = a->parm.capture.capturemode;
 	int ret = 0;
 
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
 		/* Check that the new frame rate is allowed. */
-		if ((timeperframe->numerator == 0) ||
-		    (timeperframe->denominator == 0)) {
-			timeperframe->denominator = DEFAULT_FPS;
-			timeperframe->numerator = 1;
-		}
-
-		tgt_fps = timeperframe->denominator /
-			  timeperframe->numerator;
-
-		if (tgt_fps > MAX_FPS) {
-			timeperframe->denominator = MAX_FPS;
-			timeperframe->numerator = 1;
-		} else if (tgt_fps < MIN_FPS) {
-			timeperframe->denominator = MIN_FPS;
-			timeperframe->numerator = 1;
-		}
+	if ((timeperframe->numerator == 0) ||
+		(timeperframe->denominator == 0)) {
+		timeperframe->denominator = DEFAULT_FPS;
+		timeperframe->numerator = 1;
+	}
 
-		if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
-			pr_err("The camera mode[%d] is not supported!\n", mode);
-			return -EINVAL;
-		}
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
 
-		sensor->streamcap.capturemode = mode;
-		sensor->streamcap.timeperframe = *timeperframe;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		pr_debug("   type is not V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
-					a->type);
-		ret = -EINVAL;
-		break;
-
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
+	if (tgt_fps > MAX_FPS) {
+		timeperframe->denominator = MAX_FPS;
+		timeperframe->numerator = 1;
+	} else if (tgt_fps < MIN_FPS) {
+		timeperframe->denominator = MIN_FPS;
+		timeperframe->numerator = 1;
 	}
 
+	sensor->streamcap.timeperframe = *timeperframe;
+
 	return ret;
 }
 
@@ -1158,8 +1104,8 @@ static int ov5640_link_setup(struct media_entity *entity,
 }
 
 static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
-	.g_parm = ov5640_g_parm,
-	.s_parm = ov5640_s_parm,
+	.g_frame_interval = ov5640_g_frame_interval,
+	.s_frame_interval = ov5640_s_frame_interval,
 	.s_stream = ov5640_s_stream,
 };
 
diff --git a/drivers/media/platform/imx8/ov5640_v3.c b/drivers/media/platform/imx8/ov5640_v3.c
index 03c15f4ed4cb..d9fb709f34c6 100644
--- a/drivers/media/platform/imx8/ov5640_v3.c
+++ b/drivers/media/platform/imx8/ov5640_v3.c
@@ -1171,52 +1171,27 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 }
 
 /*!
- * ov5640_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * ov5640_g_frame_interval - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
  * @s: pointer to standard V4L2 sub device structure
  * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
  *
  * Returns the sensor's video CAPTURE parameters.
  */
-static int ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int ov5640_g_frame_interval(struct v4l2_subdev *sd,
+									struct v4l2_subdev_frame_interval *ival)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5640 *sensor = to_ov5640(client);
-	struct v4l2_captureparm *cparm = &a->parm.capture;
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		memset(a, 0, sizeof(*a));
-		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cparm->capability = sensor->streamcap.capability;
-		cparm->timeperframe = sensor->streamcap.timeperframe;
-		cparm->capturemode = sensor->streamcap.capturemode;
-		ret = 0;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		ret = -EINVAL;
-		break;
-
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
-	}
+	ival->interval.numerator = sensor->streamcap.timeperframe.numerator;
+	ival->interval.denominator = sensor->streamcap.timeperframe.denominator;
 
 	return ret;
 }
 
 /*!
- * ov5460_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * ov5460_s_frame_interval - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
  * @s: pointer to standard V4L2 sub device structure
  * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
  *
@@ -1224,65 +1199,35 @@ static int ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
  * not possible, reverts to the old parameters and returns the
  * appropriate error code.
  */
-static int ov5640_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int ov5640_s_frame_interval(struct v4l2_subdev *sd,
+									struct v4l2_subdev_frame_interval *ival)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5640 *sensor = to_ov5640(client);
-	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	struct v4l2_fract *timeperframe = &ival->interval;
 	u32 tgt_fps;	/* target frames per secound */
-	enum ov5640_mode mode = a->parm.capture.capturemode;
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		/* Check that the new frame rate is allowed. */
-		if ((timeperframe->numerator == 0) ||
-		    (timeperframe->denominator == 0)) {
-			timeperframe->denominator = DEFAULT_FPS;
-			timeperframe->numerator = 1;
-		}
-
-		tgt_fps = timeperframe->denominator /
-			  timeperframe->numerator;
-
-		if (tgt_fps > MAX_FPS) {
-			timeperframe->denominator = MAX_FPS;
-			timeperframe->numerator = 1;
-		} else if (tgt_fps < MIN_FPS) {
-			timeperframe->denominator = MIN_FPS;
-			timeperframe->numerator = 1;
-		}
+	/* Check that the new frame rate is allowed. */
+	if ((timeperframe->numerator == 0) ||
+		(timeperframe->denominator == 0)) {
+		timeperframe->denominator = DEFAULT_FPS;
+		timeperframe->numerator = 1;
+	}
 
-		if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
-			pr_err("The camera mode[%d] is not supported!\n", mode);
-			return -EINVAL;
-		}
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
 
-		sensor->streamcap.timeperframe = *timeperframe;
-		sensor->streamcap.capturemode = mode;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		pr_debug("   type is not " \
-			"V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
-			a->type);
-		ret = -EINVAL;
-		break;
-
-	default:
-		pr_debug("   type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
+	if (tgt_fps > MAX_FPS) {
+		timeperframe->denominator = MAX_FPS;
+		timeperframe->numerator = 1;
+	} else if (tgt_fps < MIN_FPS) {
+		timeperframe->denominator = MIN_FPS;
+		timeperframe->numerator = 1;
 	}
 
+	sensor->streamcap.timeperframe = *timeperframe;
+
 	return ret;
 }
 
@@ -1527,8 +1472,8 @@ static int ov5640_link_setup(struct media_entity *entity,
 }
 
 static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
-	.g_parm = ov5640_g_parm,
-	.s_parm = ov5640_s_parm,
+	.g_frame_interval = ov5640_g_frame_interval,
+	.s_frame_interval = ov5640_s_frame_interval,
 	.s_stream = ov5640_s_stream,
 };
 
diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index 463c3e4d5742..788cdf28cb4a 100644
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -1621,7 +1621,7 @@ static int mx6s_vidioc_s_parm(struct file *file, void *priv,
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 	struct v4l2_subdev *sd = csi_dev->sd;
 
-	return v4l2_g_parm_cap(video_devdata(file), sd, a);
+	return v4l2_s_parm_cap(video_devdata(file), sd, a);
 }
 
 static int mx6s_vidioc_enum_framesizes(struct file *file, void *priv,
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index e491735b20e9..a3ed6990ce88 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -818,20 +818,22 @@ static int mipi_csis_s_rx_buffer(struct v4l2_subdev *mipi_sd, void *buf,
 	return 0;
 }
 
-static int mipi_csis_s_parm(struct v4l2_subdev *mipi_sd, struct v4l2_streamparm *a)
+static int mipi_csis_s_frame_interval(struct v4l2_subdev *mipi_sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
 	struct v4l2_subdev *sensor_sd = state->sensor_sd;
 
-	return v4l2_subdev_call(sensor_sd, video, s_parm, a);
+	return v4l2_subdev_call(sensor_sd, video, s_frame_interval, ival);
 }
 
-static int mipi_csis_g_parm(struct v4l2_subdev *mipi_sd, struct v4l2_streamparm *a)
+static int mipi_csis_g_frame_interval(struct v4l2_subdev *mipi_sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
 	struct v4l2_subdev *sensor_sd = state->sensor_sd;
 
-	return v4l2_subdev_call(sensor_sd, video, g_parm, a);
+	return v4l2_subdev_call(sensor_sd, video, g_frame_interval, ival);
 }
 
 static int mipi_csis_enum_framesizes(struct v4l2_subdev *mipi_sd,
@@ -875,8 +877,8 @@ static struct v4l2_subdev_video_ops mipi_csis_video_ops = {
 	.s_rx_buffer = mipi_csis_s_rx_buffer,
 	.s_stream = mipi_csis_s_stream,
 
-	.s_parm = mipi_csis_s_parm,
-	.g_parm = mipi_csis_g_parm,
+	.s_frame_interval = mipi_csis_s_frame_interval,
+	.g_frame_interval = mipi_csis_g_frame_interval,
 };
 
 static const struct v4l2_subdev_pad_ops mipi_csis_pad_ops = {
diff --git a/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c b/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
index 1cb3d69918f4..11408f7520f1 100644
--- a/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
+++ b/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
@@ -1237,40 +1237,15 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
  *
  * Returns the sensor's video CAPTURE parameters.
  */
-static int ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int ov5640_g_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5640 *sensor = to_ov5640(client);
-	struct device *dev = &sensor->i2c_client->dev;
-	struct v4l2_captureparm *cparm = &a->parm.capture;
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		memset(a, 0, sizeof(*a));
-		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cparm->capability = sensor->streamcap.capability;
-		cparm->timeperframe = sensor->streamcap.timeperframe;
-		cparm->capturemode = sensor->streamcap.capturemode;
-		ret = 0;
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		ret = -EINVAL;
-		break;
-
-	default:
-		dev_warn(dev, "Type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
-	}
+	ival->interval.numerator = sensor->streamcap.timeperframe.numerator;
+	ival->interval.denominator = sensor->streamcap.timeperframe.denominator;
 
 	return ret;
 }
@@ -1284,82 +1259,56 @@ static int ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
  * not possible, reverts to the old parameters and returns the
  * appropriate error code.
  */
-static int ov5640_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+static int ov5640_s_frame_interval(struct v4l2_subdev *sd,
+					struct v4l2_subdev_frame_interval *ival)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5640 *sensor = to_ov5640(client);
 	struct device *dev = &sensor->i2c_client->dev;
-	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	struct v4l2_fract *timeperframe = &ival->interval;
 	u32 tgt_fps;	/* target frames per secound */
 	enum ov5640_frame_rate frame_rate;
 	enum ov5640_mode orig_mode;
 	int ret = 0;
 
-	switch (a->type) {
-	/* This is the only case currently handled. */
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		/* Check that the new frame rate is allowed. */
-		if ((timeperframe->numerator == 0) ||
-		    (timeperframe->denominator == 0)) {
-			timeperframe->denominator = DEFAULT_FPS;
-			timeperframe->numerator = 1;
-		}
+	/* Check that the new frame rate is allowed. */
+	if ((timeperframe->numerator == 0) ||
+		(timeperframe->denominator == 0)) {
+		timeperframe->denominator = DEFAULT_FPS;
+		timeperframe->numerator = 1;
+	}
 
-		tgt_fps = timeperframe->denominator /
-			  timeperframe->numerator;
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
 
-		if (tgt_fps > MAX_FPS) {
-			timeperframe->denominator = MAX_FPS;
-			timeperframe->numerator = 1;
-		} else if (tgt_fps < MIN_FPS) {
-			timeperframe->denominator = MIN_FPS;
-			timeperframe->numerator = 1;
-		}
-
-		/* Actual frame rate we use */
-		tgt_fps = timeperframe->denominator /
-			  timeperframe->numerator;
-
-		if (tgt_fps == 15)
-			frame_rate = ov5640_15_fps;
-		else if (tgt_fps == 30)
-			frame_rate = ov5640_30_fps;
-		else {
-			dev_warn(dev,
-				"The camera frame rate is not supported!\n");
-			return -EINVAL;
-		}
+	if (tgt_fps > MAX_FPS) {
+		timeperframe->denominator = MAX_FPS;
+		timeperframe->numerator = 1;
+	} else if (tgt_fps < MIN_FPS) {
+		timeperframe->denominator = MIN_FPS;
+		timeperframe->numerator = 1;
+	}
 
-		orig_mode = sensor->streamcap.capturemode;
-		ret = ov5640_init_mode(sensor, frame_rate,
-				(u32)a->parm.capture.capturemode, orig_mode);
-		if (ret < 0)
-			return ret;
+	/* Actual frame rate we use */
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
 
-		sensor->streamcap.timeperframe = *timeperframe;
-		sensor->streamcap.capturemode =
-				(u32)a->parm.capture.capturemode;
-
-		break;
-
-	/* These are all the possible cases. */
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_VBI_OUTPUT:
-	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-		dev_warn(dev, "Type is not V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
-			a->type);
-		ret = -EINVAL;
-		break;
-
-	default:
-		dev_warn(dev, "Type is unknown - %d\n", a->type);
-		ret = -EINVAL;
-		break;
+	if (tgt_fps == 15)
+		frame_rate = ov5640_15_fps;
+	else if (tgt_fps == 30)
+		frame_rate = ov5640_30_fps;
+	else {
+		dev_warn(dev,
+			"The camera frame rate is not supported!\n");
+		return -EINVAL;
 	}
 
+	orig_mode = sensor->streamcap.capturemode;
+	ret = ov5640_init_mode(sensor, frame_rate,
+				sensor->streamcap.capturemode, orig_mode);
+
+	sensor->streamcap.timeperframe = *timeperframe;
+
 	return ret;
 }
 
@@ -1559,8 +1508,8 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 }
 
 static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
-	.g_parm = ov5640_g_parm,
-	.s_parm = ov5640_s_parm,
+	.g_frame_interval = ov5640_g_frame_interval,
+	.s_frame_interval = ov5640_s_frame_interval,
 	.s_stream = ov5640_s_stream,
 };
 
-- 
2.17.1


From b3622537f98c424202590a2683bb366f3408a383 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Tue, 7 Jan 2020 16:36:31 +0800
Subject: [PATCH] irqchip: imx-irqsteer: add clock operations during probe

Some platforms like i.MX8QXP has clock control for this module
irqsteer, which as an interrupt controller cooperates with GIC,
gathers interrupts from the system and can be used to steer them
to one of the output bits (non A-series core).

Need to add clock operations and enable channel to IRQs during
initialization to make sure the driver is working properly.

This will fix the kdump hung issue when calling machine_kexec_mask_interrupts()
to mask the related interrupt but hung due to the irqsteer is in a
messy state.

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/irqchip/irq-imx-irqsteer.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)
 mode change 100644 => 100755 drivers/irqchip/irq-imx-irqsteer.c

diff --git a/drivers/irqchip/irq-imx-irqsteer.c b/drivers/irqchip/irq-imx-irqsteer.c
old mode 100644
new mode 100755
index e26d242e1c66..9560a0a98d34
--- a/drivers/irqchip/irq-imx-irqsteer.c
+++ b/drivers/irqchip/irq-imx-irqsteer.c
@@ -214,6 +214,15 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 	irqsteer_data->inited = false;
 	spin_lock_init(&irqsteer_data->lock);
 
+	ret = clk_prepare_enable(irqsteer_data->ipg_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable ipg clk: %d\n", ret);
+		return ret;
+	}
+
+	/* steer IRQs into configured channel */
+	writel_relaxed(BIT(irqsteer_data->channum), irqsteer_data->regs + CHANCTRL);
+
 	irqsteer_data->domain = irq_domain_add_linear(np,
 						 irqsteer_data->channum * 32,
 						 &imx_irqsteer_domain_ops,
@@ -221,7 +230,8 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 	if (!irqsteer_data->domain) {
 		dev_err(&irqsteer_data->pdev->dev,
 			"failed to create IRQ domain\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out;
 	}
 
 	irq_set_chained_handler_and_data(irqsteer_data->irq,
@@ -232,6 +242,10 @@ static int imx_irqsteer_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 	return 0;
+
+out:
+	clk_disable_unprepare(irqsteer_data->ipg_clk);
+	return ret;
 }
 
 static int imx_irqsteer_remove(struct platform_device *pdev)
-- 
2.17.1


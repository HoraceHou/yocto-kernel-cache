From 16213881f5ad91dec53d782e6270c694eff67acc Mon Sep 17 00:00:00 2001
From: Punnaiah Choudary Kalluri <punnaiah.choudary.kalluri@xilinx.com>
Date: Tue, 6 Oct 2015 09:46:26 +0530
Subject: [PATCH 3/3] mtd: rawnand: Fix oob write operation failures in ddr
 mode

    commit 6640bbb7236a42b5f26212736713b5fd3b56b220 from
    https://github.com/Xilinx/linux-xlnx.git

Found that nand_do_write_oob function issuing the RESET command
to device and causing device to default to its power on state from
the current state.

During the init phase, driver places the device and controller in
to ddr mode and max supported timing mode based on the features
advertised by the device.

So, issuing reset in write_oob operation causes device and controller
in different data interface modes and causing the operation failure.

Also apply nand_reset() only to TOSHIBA parts.
While writing oob, flash chips like TOSHIBA will clear the whole data
page, if there is no nand_reset(). So limit this reset only to these
parts.
We can still go without checking the jedec_id, but arasan_nand driver
does not support setup_data_interface() hook to initialize the flash
timings during reset. arasan_nand driver is not supporting this hook
because the NAND subsystem is not supporting NVDDR modes. so by adding
this check we can support SDR, NVDDR modes in arasan.
And to support this jedec id check, added new jedec_id variable to
struct onfi_params. This is needed until NAND subsystem supports NVDDR
modes.

Signed-off-by: Punnaiah Choudary Kalluri <punnaia@xilinx.com>
Signed-off-by: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>

The function nand_reset calls nand_reset_op, which calls chip->cmdfunc to
reset the chip finally, so remove the chip->cmdfunc from nand_do_write_oob
to avoid reseting twice.

Signed-off-by: Yue Tao <Yue.Tao@windriver.com>
---
 drivers/mtd/nand/raw/nand_base.c | 11 ++++++++++-
 include/linux/mtd/rawnand.h      |  2 ++
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/drivers/mtd/nand/raw/nand_base.c b/drivers/mtd/nand/raw/nand_base.c
index 3ce943253f30..12628a59ea9a 100644
--- a/drivers/mtd/nand/raw/nand_base.c
+++ b/drivers/mtd/nand/raw/nand_base.c
@@ -4552,7 +4552,15 @@ static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 	 * if we don't do this. I have no clue why, but I seem to have 'fixed'
 	 * it in the doc2000 driver in August 1999.  dwmw2.
 	 */
-	nand_reset(chip, chipnr);
+	/*
+	 * Nand onfi compatible devices may support different data interface
+	 * modes like SDR, NVDDR and NVDDR2. Giving reset to device places the
+	 * device in to power-up state and places the target in the SDR data
+	 * interface mode. This will be the problem for devices configured for
+	 * NVDDR modes. So, limiting the reset operation to Toshiba devices.
+	 */
+	if (chip->parameters.onfi.jedec_id == NAND_MFR_TOSHIBA)
+		nand_reset(chip, chipnr);
 
 	chip->select_chip(mtd, chipnr);
 
@@ -5258,6 +5266,7 @@ static int nand_flash_detect_onfi(struct nand_chip *chip)
 	chip->parameters.onfi.tCCS = le16_to_cpu(p->t_ccs);
 	chip->parameters.onfi.async_timing_mode =
 		le16_to_cpu(p->async_timing_mode);
+	chip->parameters.onfi.jedec_id = le16_to_cpu(p->jedec_id);
 	chip->parameters.onfi.vendor_revision =
 		le16_to_cpu(p->vendor_revision);
 	memcpy(chip->parameters.onfi.vendor, p->vendor,
diff --git a/include/linux/mtd/rawnand.h b/include/linux/mtd/rawnand.h
index 87c635d6c773..5fdfbd022954 100644
--- a/include/linux/mtd/rawnand.h
+++ b/include/linux/mtd/rawnand.h
@@ -448,6 +448,7 @@ struct nand_jedec_params {
  * @async_timing_mode: Supported asynchronous timing mode
  * @vendor_revision: Vendor specific revision number
  * @vendor: Vendor specific data
+ * @jedec_id: Jedec ID of nand flash device
  */
 struct onfi_params {
 	int version;
@@ -458,6 +459,7 @@ struct onfi_params {
 	u16 async_timing_mode;
 	u16 vendor_revision;
 	u8 vendor[88];
+	u8 jedec_id;
 };
 
 /**
-- 
2.17.1


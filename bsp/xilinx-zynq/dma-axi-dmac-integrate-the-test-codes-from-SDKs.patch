From 35ec812355475d8278fba33ce27b50acf4629f71 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 27 Nov 2018 14:12:39 +0800
Subject: [PATCH 09/25] dma: axi-dmac: integrate the test codes from SDKs

Testing codes for axi-dmac from the following git repo.
  git clone https://github.com/analogdevicesinc/linux.git

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/dma/dma-axi-dmac.c | 69 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/drivers/dma/dma-axi-dmac.c b/drivers/dma/dma-axi-dmac.c
index 9af09bde0e48..8231c40344d7 100644
--- a/drivers/dma/dma-axi-dmac.c
+++ b/drivers/dma/dma-axi-dmac.c
@@ -72,6 +72,8 @@
 
 #define AXI_DMAC_FLAG_CYCLIC		BIT(0)
 
+#undef SPEED_TEST
+
 /* The maximum ID allocated by the hardware is 31 */
 #define AXI_DMAC_SG_UNUSED 32U
 
@@ -126,6 +128,11 @@ struct axi_dmac {
 	struct axi_dmac_chan chan;
 
 	struct device_dma_parameters dma_parms;
+
+#ifdef SPEED_TEST
+	void *test_virt;
+	dma_addr_t test_phys;
+#endif
 };
 
 static struct axi_dmac *chan_to_axi_dmac(struct axi_dmac_chan *chan)
@@ -295,6 +302,40 @@ static bool axi_dmac_transfer_done(struct axi_dmac_chan *chan,
 	return start_next;
 }
 
+#ifdef SPEED_TEST
+static s64 get_time(void)
+{
+	struct timespec ts;
+	ktime_get_real_ts(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static s64 start;
+static unsigned int count;
+
+static irqreturn_t axi_dmac_interrupt_handler(int irq, void *devid)
+{
+	struct axi_dmac *dmac = devid;
+	unsigned int pending;
+
+	pending = axi_dmac_read(dmac, AXI_DMAC_REG_IRQ_PENDING);
+	axi_dmac_write(dmac, AXI_DMAC_REG_IRQ_PENDING, pending);
+
+	if (pending & 1) {
+		if (count == 0)
+			start = get_time();
+		if (count < 100) {
+			axi_dmac_write(dmac, AXI_DMAC_REG_START_TRANSFER, 1);
+			count += 1;
+		}
+	} else if ((pending & 2) && count == 100) {
+		printk("time: %lld %x\n", get_time() - start, pending);
+	}
+
+	return IRQ_HANDLED;
+}
+#else
 static irqreturn_t axi_dmac_interrupt_handler(int irq, void *devid)
 {
 	struct axi_dmac *dmac = devid;
@@ -322,6 +363,7 @@ static irqreturn_t axi_dmac_interrupt_handler(int irq, void *devid)
 
 	return IRQ_HANDLED;
 }
+#endif
 
 static int axi_dmac_terminate_all(struct dma_chan *c)
 {
@@ -734,6 +776,33 @@ static int axi_dmac_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, dmac);
 
+#ifdef SPEED_TEST
+	for (i = 0; i < 0x30; i += 4)
+		printk("reg %x: %x\n", i, axi_dmac_read(dmac, i));
+	dmac->test_virt = dma_alloc_coherent(&pdev->dev, SZ_8M,
+			&dmac->test_phys, GFP_KERNEL);
+
+	axi_dmac_write(dmac, AXI_DMAC_REG_CTRL, AXI_DMAC_CTRL_ENABLE);
+	axi_dmac_write(dmac, AXI_DMAC_REG_DMA_ADDRESS, dmac->test_phys);
+	axi_dmac_write(dmac, AXI_DMAC_REG_DMA_COUNT, SZ_8M);
+
+	printk("Check registers\n");
+	printk("CTRL: %x %x\n", AXI_DMAC_CTRL_ENABLE, axi_dmac_read(dmac, AXI_DMAC_REG_CTRL));
+	printk("ADDR: %x %x\n", dmac->test_phys, axi_dmac_read(dmac, AXI_DMAC_REG_DMA_ADDRESS));
+	printk("COUNT: %x %x\n", PAGE_SIZE, axi_dmac_read(dmac, AXI_DMAC_REG_DMA_COUNT));
+	printk("MASK: %x %x\n", 0, axi_dmac_read(dmac, AXI_DMAC_REG_IRQ_MASK));
+
+	printk("Start transfer\n");
+	axi_dmac_write(dmac, AXI_DMAC_REG_START_TRANSFER, 1);
+	printk("START: %x %x\n", 1, axi_dmac_read(dmac, AXI_DMAC_REG_START_TRANSFER));
+
+	for (i = 0; i < 0x100; i++)
+		printk("%.8x%c", ((unsigned long *)dmac->test_virt)[i],
+			i % 16 == 15 ? '\n' : ' ');
+	printk("Last: %x\n", ((unsigned long *)dmac->test_virt)[PAGE_SIZE/4-1]);
+	printk("PROGRESS: %x %x\n", 1, axi_dmac_read(dmac, AXI_DMAC_REG_DMA_COUNT_PROGRESS));
+#endif
+
 	return 0;
 
 err_unregister_of:
-- 
2.17.0


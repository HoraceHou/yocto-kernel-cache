From 059185c67c084b8054c6b4f691ec334066815cae Mon Sep 17 00:00:00 2001
From: Lukasz Bartosik <lbartosik@marvell.com>
Date: Fri, 28 Dec 2018 15:22:22 +0300
Subject: [PATCH 0872/1051] crypto: cpt - use correct gfp flag in fast path

Use correct gfp flag when allocating memory in fast path.
Currently fast path code assumes that it is executed on
behalf of context which can sleep which might not always
be true.

Change-Id: I5b416e6bcd79845d6b13e54985a24c697e8442d0
Signed-off-by: Lukasz Bartosik <lbartosik@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/1779
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/cavium/cpt/common/cpt_algs.c   | 13 ++++++----
 drivers/crypto/cavium/cpt/common/cpt_reqmgr.h | 24 +++++++++++--------
 2 files changed, 22 insertions(+), 15 deletions(-)

diff --git a/drivers/crypto/cavium/cpt/common/cpt_algs.c b/drivers/crypto/cavium/cpt/common/cpt_algs.c
index fedda40226f4..3272b518e264 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_algs.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_algs.c
@@ -1023,7 +1023,10 @@ static inline u32 create_aead_null_output_list(struct aead_request *req,
 		 * If source and destination are different
 		 * then copy payload to destination
 		 */
-		ptr = kmalloc(inputlen, GFP_KERNEL);
+
+		ptr = kmalloc(inputlen, (req_info->areq->flags &
+					 CRYPTO_TFM_REQ_MAY_SLEEP) ?
+					 GFP_KERNEL : GFP_ATOMIC);
 		if (!ptr) {
 			status = -ENOMEM;
 			goto error;
@@ -1095,6 +1098,10 @@ u32 cvm_aead_enc_dec(struct aead_request *req, u8 reg_type, u8 enc)
 	u32 status, cpu_num;
 
 	memset(rctx, 0, sizeof(struct cvm_req_ctx));
+	req_info->callback = cvm_callback;
+	req_info->areq = &req->base;
+	req_info->req_type = reg_type;
+	req_info->is_enc = enc;
 
 	switch (reg_type) {
 	case AEAD_ENC_DEC_REQ:
@@ -1126,10 +1133,6 @@ u32 cvm_aead_enc_dec(struct aead_request *req, u8 reg_type, u8 enc)
 	if (status)
 		return status;
 
-	req_info->callback = cvm_callback;
-	req_info->areq = &req->base;
-	req_info->req_type = reg_type;
-	req_info->is_enc = enc;
 	req_info->ctrl.s.grp = cpt_get_kcrypto_eng_grp_num(pdev);
 
 	status = cpt_do_request(pdev, req_info, cpu_num);
diff --git a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h
index a948d39ee7a0..190eae7e9835 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h
@@ -143,7 +143,7 @@ static inline int setup_sgio_components(struct pci_dev *pdev,
 
 static inline int setup_sgio_list(struct pci_dev *pdev,
 				  struct cpt_info_buffer *info,
-				  struct cpt_request_info *req)
+				  struct cpt_request_info *req, gfp_t gfp)
 {
 	u16 g_sz_bytes = 0, s_sz_bytes = 0;
 	int ret = 0;
@@ -157,7 +157,7 @@ static inline int setup_sgio_list(struct pci_dev *pdev,
 
 	/* Setup gather (input) components */
 	g_sz_bytes = ((req->incnt + 3) / 4) * sizeof(struct sglist_component);
-	info->gather_components = kzalloc(g_sz_bytes, GFP_KERNEL);
+	info->gather_components = kzalloc(g_sz_bytes, gfp);
 	if (unlikely(!info->gather_components)) {
 		dev_err(&pdev->dev, "Memory allocation failed\n");
 		ret = -ENOMEM;
@@ -174,7 +174,7 @@ static inline int setup_sgio_list(struct pci_dev *pdev,
 
 	/* Setup scatter (output) components */
 	s_sz_bytes = ((req->outcnt + 3) / 4) * sizeof(struct sglist_component);
-	info->scatter_components = kzalloc(s_sz_bytes, GFP_KERNEL);
+	info->scatter_components = kzalloc(s_sz_bytes, gfp);
 	if (unlikely(!info->scatter_components)) {
 		dev_err(&pdev->dev, "Memory allocation failed\n");
 		ret = -ENOMEM;
@@ -191,7 +191,7 @@ static inline int setup_sgio_list(struct pci_dev *pdev,
 
 	/* Create and initialize DPTR */
 	info->dlen = g_sz_bytes + s_sz_bytes + SG_LIST_HDR_SIZE;
-	info->in_buffer = kzalloc(info->dlen, GFP_KERNEL);
+	info->in_buffer = kzalloc(info->dlen, gfp);
 	if (unlikely(!info->in_buffer)) {
 		dev_err(&pdev->dev, "Memory allocation failed\n");
 		ret = -ENOMEM;
@@ -218,7 +218,7 @@ static inline int setup_sgio_list(struct pci_dev *pdev,
 	}
 
 	/* Create and initialize RPTR */
-	info->out_buffer = kzalloc(COMPLETION_CODE_SIZE, GFP_KERNEL);
+	info->out_buffer = kzalloc(COMPLETION_CODE_SIZE, gfp);
 	if (unlikely(!info->out_buffer)) {
 		dev_err(&pdev->dev, "Memory allocation failed\n");
 		ret = -ENOMEM;
@@ -418,14 +418,17 @@ static inline int process_request(struct pci_dev *pdev,
 	union cpt_inst_s cptinst;
 	int retry, ret = 0;
 	u8 resume_sender;
+	gfp_t gfp;
 
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	gfp = (req->areq->flags & CRYPTO_TFM_REQ_MAY_SLEEP) ? GFP_KERNEL :
+							      GFP_ATOMIC;
+	info = kzalloc(sizeof(*info), gfp);
 	if (unlikely(!info)) {
 		dev_err(&pdev->dev, "Memory allocation failed\n");
 		return -ENOMEM;
 	}
 
-	ret = setup_sgio_list(pdev, info, req);
+	ret = setup_sgio_list(pdev, info, req, gfp);
 	if (unlikely(ret)) {
 		dev_err(&pdev->dev, "Setting up SG list failed");
 		goto request_cleanup;
@@ -436,7 +439,7 @@ static inline int process_request(struct pci_dev *pdev,
 	 * Get buffer for union cpt_res_s response
 	 * structure and its physical address
 	 */
-	info->completion_addr = kzalloc(sizeof(union cpt_res_s), GFP_KERNEL);
+	info->completion_addr = kzalloc(sizeof(union cpt_res_s), gfp);
 	if (unlikely(!info->completion_addr)) {
 		dev_err(&pdev->dev, "memory allocation failed\n");
 		goto request_cleanup;
@@ -472,9 +475,10 @@ static inline int process_request(struct pci_dev *pdev,
 
 	/*
 	 * Check if we are close to filling in entire pending queue,
-	 * if so then tell the sender to stop by returning -EBUSY
+	 * if so then tell the sender to stop/sleep by returning -EBUSY
+	 * We do it only for context which can sleep (GFP_KERNEL)
 	 */
-	if ((req->areq->flags & CRYPTO_TFM_REQ_MAY_SLEEP) &&
+	if (gfp == GFP_KERNEL &&
 	    pqueue->pending_count > (pqueue->qlen - CPT_IQ_STOP_MARGIN)) {
 		pentry->resume_sender = true;
 	}
-- 
2.17.1


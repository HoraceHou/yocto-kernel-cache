From 08fe55e02db349bf5d0ef570b1d18f503283ebfb Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Mon, 27 Aug 2018 14:49:40 +0530
Subject: [PATCH 0160/1051] soc: octeontx2: Add NPC MCAM allocation status to
 debugfs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Added support to display current NPC MCAM entries and
counter's allocation status Ã­n debugfs.
'cat /sys/kernel/debug/octeontx2/npc/mcam_info'
will dump following info
- MCAM Rx and Tx keysize
- Total MCAM entries and counters
- Current available count
- Count of number of entries/counters allocated to a RVU device.

Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/octeontx2/rvu.h         |   4 +
 drivers/soc/marvell/octeontx2/rvu_debugfs.c | 100 ++++++++++++++++++++
 drivers/soc/marvell/octeontx2/rvu_npc.c     |  36 +++++++
 3 files changed, 140 insertions(+)

diff --git a/drivers/soc/marvell/octeontx2/rvu.h b/drivers/soc/marvell/octeontx2/rvu.h
index afbda168518d..5fdbd7624404 100644
--- a/drivers/soc/marvell/octeontx2/rvu.h
+++ b/drivers/soc/marvell/octeontx2/rvu.h
@@ -481,6 +481,10 @@ void rvu_npc_install_bcast_match_entry(struct rvu *rvu, u16 pcifunc,
 void rvu_npc_disable_mcam_entries(struct rvu *rvu, u16 pcifunc, int nixlf);
 void rvu_npc_update_flowkey_alg_idx(struct rvu *rvu, u16 pcifunc, int nixlf,
 				    int group, int alg_idx, int mcam_index);
+void rvu_npc_get_mcam_entry_alloc_info(struct rvu *rvu, u16 pcifunc,
+				int blkaddr, int *alloc_cnt, int *enable_cnt);
+void rvu_npc_get_mcam_counter_alloc_info(struct rvu *rvu, u16 pcifunc,
+				int blkaddr, int *alloc_cnt, int *enable_cnt);
 int rvu_mbox_handler_NPC_MCAM_ALLOC_ENTRY(struct rvu *rvu,
 					  struct npc_mcam_alloc_entry_req *req,
 					  struct npc_mcam_alloc_entry_rsp *rsp);
diff --git a/drivers/soc/marvell/octeontx2/rvu_debugfs.c b/drivers/soc/marvell/octeontx2/rvu_debugfs.c
index e9e9ddee05d8..10ae8f0ca7ed 100644
--- a/drivers/soc/marvell/octeontx2/rvu_debugfs.c
+++ b/drivers/soc/marvell/octeontx2/rvu_debugfs.c
@@ -1093,6 +1093,101 @@ static void rvu_dbg_nix_init(struct rvu *rvu)
 }
 
 /* NPC debugfs APIs */
+static inline void rvu_print_npc_mcam_info(struct rvu *rvu,
+					   u16 pcifunc, int blkaddr)
+{
+	int cntr_acnt, cntr_ecnt;
+	int entry_acnt, entry_ecnt;
+
+	/* Skip PF0 */
+	if (!pcifunc)
+		return;
+	rvu_npc_get_mcam_entry_alloc_info(rvu, pcifunc, blkaddr,
+					  &entry_acnt, &entry_ecnt);
+	rvu_npc_get_mcam_counter_alloc_info(rvu, pcifunc, blkaddr,
+					    &cntr_acnt, &cntr_ecnt);
+	if (!entry_acnt && !cntr_acnt)
+		return;
+
+	if (!(pcifunc & RVU_PFVF_FUNC_MASK))
+		pr_info("\n\t\t Device \t\t: PF%d\n", rvu_get_pf(pcifunc));
+	else
+		pr_info("\n\t\t Device \t\t: PF%d VF%d\n", rvu_get_pf(pcifunc),
+			(pcifunc & RVU_PFVF_FUNC_MASK) - 1);
+
+	if (entry_acnt) {
+		pr_info("\t\t Entries allocated \t: %d\n", entry_acnt);
+		pr_info("\t\t Entries enabled \t: %d\n", entry_ecnt);
+	}
+	if (cntr_acnt) {
+		pr_info("\t\t Counters allocated \t: %d\n", cntr_acnt);
+		pr_info("\t\t Counters enabled \t: %d\n", cntr_ecnt);
+	}
+}
+
+static ssize_t rvu_dbg_npc_mcam_info_display(struct file *filp,
+				char __user *buffer, size_t count, loff_t *ppos)
+{
+	struct rvu *rvu = filp->private_data;
+	int pf, vf, numvfs, blkaddr;
+	struct npc_mcam *mcam;
+	u16 pcifunc;
+	u64 cfg;
+
+	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);
+	if (blkaddr < 0)
+		return 0;
+
+	mcam = &rvu->hw->mcam;
+
+	pr_info("\nNPC MCAM info:\n");
+	/* MCAM keywidth on receive and transmit sides */
+	cfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX));
+	cfg = (cfg >> 32) & 0x07;
+	pr_info("\t\t RX keywidth \t: %s\n", (cfg == NPC_MCAM_KEY_X1) ?
+		"112bits" : ((cfg == NPC_MCAM_KEY_X2) ? "224bits" : "448bits"));
+	cfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX));
+	cfg = (cfg >> 32) & 0x07;
+	pr_info("\t\t TX keywidth \t: %s\n", (cfg == NPC_MCAM_KEY_X1) ?
+		"112bits" : ((cfg == NPC_MCAM_KEY_X2) ? "224bits" : "448bits"));
+
+	mutex_lock(&mcam->lock);
+	/* MCAM entries */
+	pr_info("\n\t\t MCAM entries \t: %d\n", mcam->total_entries);
+	pr_info("\t\t Reserved \t: %d\n",
+		mcam->total_entries - mcam->bmap_entries);
+	pr_info("\t\t Available \t: %d\n", mcam->bmap_fcnt);
+
+	/* MCAM counters */
+	cfg = rvu_read64(rvu, blkaddr, NPC_AF_CONST);
+	cfg = (cfg >> 48) & 0xFFFF;
+	pr_info("\n\t\t MCAM counters \t: %lld\n", cfg);
+	pr_info("\t\t Reserved \t: %lld\n", cfg - mcam->counters.max);
+	pr_info("\t\t Available \t: %d\n",
+		rvu_rsrc_free_count(&mcam->counters));
+
+	if (mcam->bmap_entries == mcam->bmap_fcnt)
+		return 0;
+
+	pr_info("\n\t\t Current allocation\n");
+	pr_info("\t\t====================\n");
+	for (pf = 0; pf < rvu->hw->total_pfs; pf++) {
+		pcifunc = (pf << RVU_PFVF_PF_SHIFT);
+		rvu_print_npc_mcam_info(rvu, pcifunc, blkaddr);
+
+		cfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));
+		numvfs = (cfg >> 12) & 0xFF;
+		for (vf = 0; vf < numvfs; vf++) {
+			pcifunc = (pf << RVU_PFVF_PF_SHIFT) | (vf + 1);
+			rvu_print_npc_mcam_info(rvu, pcifunc, blkaddr);
+		}
+	}
+
+	mutex_unlock(&mcam->lock);
+	return 0;
+}
+RVU_DEBUG_FOPS(npc_mcam_info, npc_mcam_info_display, NULL);
+
 static ssize_t rvu_dbg_npc_rx_miss_stats_display(struct file *filp,
 						 char __user *buffer,
 						 size_t count, loff_t *ppos)
@@ -1125,6 +1220,11 @@ static void rvu_dbg_npc_init(struct rvu *rvu)
 	if (!rvu->rvu_dbg.npc)
 		return;
 
+	pfile = debugfs_create_file("mcam_info", 0444, rvu->rvu_dbg.npc,
+				    rvu, &rvu_dbg_npc_mcam_info_fops);
+	if (!pfile)
+		goto create_failed;
+
 	pfile = debugfs_create_file("rx_miss_act_stats", 0444, rvu->rvu_dbg.npc,
 				    rvu, &rvu_dbg_npc_rx_miss_act_fops);
 	if (!pfile)
diff --git a/drivers/soc/marvell/octeontx2/rvu_npc.c b/drivers/soc/marvell/octeontx2/rvu_npc.c
index e06be21e1529..88db277c6050 100644
--- a/drivers/soc/marvell/octeontx2/rvu_npc.c
+++ b/drivers/soc/marvell/octeontx2/rvu_npc.c
@@ -999,6 +999,42 @@ void rvu_npc_freemem(struct rvu *rvu)
 	mutex_destroy(&mcam->lock);
 }
 
+void rvu_npc_get_mcam_entry_alloc_info(struct rvu *rvu, u16 pcifunc,
+				int blkaddr, int *alloc_cnt, int *enable_cnt)
+{
+	struct npc_mcam *mcam = &rvu->hw->mcam;
+	int entry;
+
+	*alloc_cnt = 0;
+	*enable_cnt = 0;
+
+	for (entry = 0; entry < mcam->bmap_entries; entry++) {
+		if (mcam->entry2pfvf_map[entry] == pcifunc) {
+			(*alloc_cnt)++;
+			if (is_mcam_entry_enabled(rvu, mcam, blkaddr, entry))
+				(*enable_cnt)++;
+		}
+	}
+}
+
+void rvu_npc_get_mcam_counter_alloc_info(struct rvu *rvu, u16 pcifunc,
+				int blkaddr, int *alloc_cnt, int *enable_cnt)
+{
+	struct npc_mcam *mcam = &rvu->hw->mcam;
+	int cntr;
+
+	*alloc_cnt = 0;
+	*enable_cnt = 0;
+
+	for (cntr = 0; cntr < mcam->counters.max; cntr++) {
+		if (mcam->cntr2pfvf_map[cntr] == pcifunc) {
+			(*alloc_cnt)++;
+			if (mcam->cntr_refcnt[cntr])
+				(*enable_cnt)++;
+		}
+	}
+}
+
 static int npc_mcam_verify_entry(struct npc_mcam *mcam,
 				 u16 pcifunc, int entry)
 {
-- 
2.17.1


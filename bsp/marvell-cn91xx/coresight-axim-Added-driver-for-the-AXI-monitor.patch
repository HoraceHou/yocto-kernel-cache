From 900fc635cb2182f1b90def5c33731c3c4aea7290 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Thu, 14 Jun 2018 17:46:36 +0300
Subject: [PATCH 0660/1051] coresight: axim: Added driver for the AXI monitor

The AXI monitors is a bus monitor that exists in both AP-806 and
CP-110. it is capable of detecting specific bus transactions and
generate trace events or increment counters

This driver adds the basic support for the AXI monitor. it enables
using the AXI monitor for debug purposes. future patches will add
support for tracing using the axi monitor

Documentation/trace/axi-monitor.txt provides a basic explanation on
the monitor on how to use this driver

Documentation/ABI/testing/sysfs-bus-coresight-devices-axim gives
detailed descirption of all the sysfs file needed to operate the AXI
monitor

Change-Id: Ibad0250ee08c37538c4132d0cdad1dae87e03b78
Signed-off-by: Omri Itach <omrii@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../testing/sysfs-bus-coresight-devices-axim  | 181 ++++
 .../devicetree/bindings/arm/coresight.txt     |   6 +
 Documentation/trace/axi-monitor.txt           | 114 +++
 drivers/hwtracing/coresight/Kconfig           |  10 +
 drivers/hwtracing/coresight/Makefile          |   1 +
 .../coresight/coresight-axi-monitor.c         | 825 ++++++++++++++++++
 .../coresight/coresight-axi-monitor.h         | 206 +++++
 7 files changed, 1343 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-bus-coresight-devices-axim
 create mode 100644 Documentation/trace/axi-monitor.txt
 create mode 100644 drivers/hwtracing/coresight/coresight-axi-monitor.c
 create mode 100644 drivers/hwtracing/coresight/coresight-axi-monitor.h

diff --git a/Documentation/ABI/testing/sysfs-bus-coresight-devices-axim b/Documentation/ABI/testing/sysfs-bus-coresight-devices-axim
new file mode 100644
index 000000000000..4c1232b3632e
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-bus-coresight-devices-axim
@@ -0,0 +1,181 @@
+What:		/sys/bus/coresight/devices/<memory_map>.axim/enable_source
+Date:		April 2016
+KernelVersion:  4.4
+Contact:        Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) Enable/disable tracing on this specific trace entity.
+		Enabling a source implies the source has been configured
+		properly and a sink has been identified for it.  The path
+		of Coresight components linking the source to the sink is
+		configured and managed automatically by the Coresight framework.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/mon_enable
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) Enable The AXI monitor only. Doesn't enable monitor
+		as a trace source. This is useful for using the monitor
+		for debug only
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/nr_chan
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(R) Indicates the number of comparator channels.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/nr_prof_regs
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(R) Indicates the number of profiling counters
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/version
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(R) Indicates the AXI monitor version.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/reset
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(W) Resets the AXIM to it's initial state
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/curr_chan
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) Controlls and Indicates the channel for configuration
+		under "channel" sub directory.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/counters
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(R) Prints the counters of all channels.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/addr_end
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) End address of the comparator.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/addr_start
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) Start address of the comparator.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/cache
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The AxCache[0:3] attribute of the transaction.
+		AxCache[0]: Allocate
+		AxCache[1]: Other allocate
+		AxCache[2]: Modifiable
+		AxCache[3]: Bufferable
+		Refer to AMBA AXI protocol spec for more details.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/cache_mask
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) cache field mask.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/counter
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The channel's event counter
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/domain
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The AxDomain[0:1] attribute of the transaction
+		AxDomain = 0x0 - Non shareable
+		AxDomain = 0x1 - Inner shareable
+		AxDomain = 0x2 - Outer shareable
+		AxDomain = 0x0 - System
+		Refer to AMBA AXI protocol spec for more details.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/domain_mask
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) domain field mask.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/enables
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) Enables and disables the channel
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/event_mode
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) Controls when events are created
+		0 = events are created on every channel match
+		1 = events are created when counter = event_thresh
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/event_thresh
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) if event_mode = 1, controls after how many matches an
+		event is created.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/id
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The AxID[0:15] attribute of the transaction
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/id_mask
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) id field mask.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/prot
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The AxProt[0:1] attribute of the transaction
+		AxCache[0]: 1 = privileged
+		AxCache[1]: 1 = non secure
+		Refer to AMBA AXI protocol spec for more details.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/prot_mask
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) prot field mask.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/qos
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The AxQos[0:1] attribute of the transaction
+		Refer to AMBA AXI protocol spec for more details.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/qos_mask
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) qos field mask.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/user
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) The AxUser[0:15] attribute of the transaction
+		Refer to AMBA AXI protocol spec for more details.
+
+What:		/sys/bus/coresight/devices/<memory_map>.axi/channel/user_mask
+Date:		April 2016
+KernelVersion:	4.4
+Contact:	Yehuda Yitschak <yehuday@marvell.com>
+Description:	(RW) user field mask.
+
diff --git a/Documentation/devicetree/bindings/arm/coresight.txt b/Documentation/devicetree/bindings/arm/coresight.txt
index 15ac8e8dcfdf..be53027d5653 100644
--- a/Documentation/devicetree/bindings/arm/coresight.txt
+++ b/Documentation/devicetree/bindings/arm/coresight.txt
@@ -40,6 +40,9 @@ its hardware characteristcs.
 		- System Trace Macrocell:
 			"arm,coresight-stm", "arm,primecell"; [1]
 
+		- Marvell AXI Bus monitor:
+			"marvell,coresight-axim", "arm,primecell";
+
 	* reg: physical base address and length of the register
 	  set(s) of the component.
 
@@ -86,6 +89,9 @@ its hardware characteristcs.
 	* arm,buffer-size: size of contiguous buffer space for TMC ETR
 	 (embedded trace router)
 
+* Optional property for Marvell AXI Monitor:
+
+	* bus-width: size of bus monitored by AXI monitor
 
 Example:
 
diff --git a/Documentation/trace/axi-monitor.txt b/Documentation/trace/axi-monitor.txt
new file mode 100644
index 000000000000..d5b80ed0b3b7
--- /dev/null
+++ b/Documentation/trace/axi-monitor.txt
@@ -0,0 +1,114 @@
+AXI Monitor
+===========
+
+   Author:   Yehuda Yitschak <yehuday@marvell.com>
+   Date:     April 6th, 2016
+
+Introduction
+------------
+
+The AXI monitor (AXIM) is a HW bus monitor that enables detecting specific
+transactions on the AXI bus and use them for trace and debug purposes.
+It is very useful for debugging DMA accesses from HW devices but it can
+also be used to analyze the load on the DRAM interface or other system buses.
+
+The AXIM uses up to 12 comparators, called channels, to detect bus events.
+An events occur when a transaction matching the channel's filter is detected.
+A Channel event can have several outcomes. It can merely increment the channel's
+event counter, it can trigger an STM trace, cross trigger a CTI block, or
+increment profiling counters which can measure latency or transaction sizes.
+The profiling counters can also be independently traced to the STM.
+
+An AXIM monitors a single direction bus, meaning a read channel or write channel.
+A typical AXIM connection may look like this.
+
+								|-------
+								|       |
+					--------    -------->| CTI |
+		AXI channel (rd/wr) |      |    |      |     |
+		----------------------->| AXIM | ---|   -------
+					|      |    |      -------      -------
+					--------    |      |     |      |     |
+							-------->| STM |----->| ETF |
+									 |     |      |     |
+								 -------      -------
+
+The AXI monitor has several revisions with different feature set:
+
+Rev 1:
+   * Event detection and filtering
+   * Cross triggering CTI on event
+Rev 2
+   * Profiling of transaction variables
+   * Tracing detected events and profiling counters
+
+Acronyms
+--------
+- STM:	System trace Macrocell
+- CTI:	Cross Trigger Interface
+
+Device Tree Bindings
+----------------------
+
+See Documentation/devicetree/bindings/arm/coresight.txt for details.
+
+How to use
+----------
+
+Debug mode
+----------
+To detect specific transactions the AXIM channel filters must be configured
+The channel filters are set by specific sysfs file in the AXIM folder
+Then the entire monitor needs to be enabled.
+Finally the event counters can be read by another sysfs file
+
+For example to detect transaction between physical address 0x0 and 0x1000
+
+    /* Set the required channel */
+    root:/# echo 0x0 > sys/bus/coresight/devices/f0840000.axim/curr_chan
+
+    /* Set the filters */
+    root:/# echo 0x0 > sys/bus/coresight/devices/f0840000.axim/channel/addr_start
+    root:/# echo 0x1000 > sys/bus/coresight/devices/f0840000.axim/channel/addr_end
+
+    /* enable the channel and the monitor*/
+    root:/# echo 0x1 > sys/bus/coresight/devices/f0840000.axim/channel/enable
+    root:/# echo 0x1 > sys/bus/coresight/devices/f0840000.axim/channel/mon_enable
+
+    /* read the channel counter */
+    root:/# cat sys/bus/coresight/devices/f0840000.axim/channel/counter
+    /* or read all channel counter */
+    root:/# cat sys/bus/coresight/devices/f0840000.axim/counters
+
+Another example is detecting all non secure shareable device accesses:
+
+    /* Set the required channel */
+    root:/# echo 0x1 > sys/bus/coresight/devices/f0850000.axim/curr_chan
+
+    /* Set the filters */
+    root:/# echo 0x2 > sys/bus/coresight/devices/f0850000.axim/channel/domain
+    root:/# echo 0x3 > sys/bus/coresight/devices/f0850000.axim/channel/domain_mask
+    root:/# echo 0x2 > sys/bus/coresight/devices/f0850000.axim/channel/prot
+    root:/# echo 0x2 > sys/bus/coresight/devices/f0850000.axim/channel/prot_mask
+
+    /* enable the channel and the monitor*/
+    root:/# echo 0x1 > sys/bus/coresight/devices/f0850000.axim/channel/enable
+    root:/# echo 0x1 > sys/bus/coresight/devices/f0850000.axim/channel/mon_enable
+
+    /* read the channel counter */
+    root:/# cat sys/bus/coresight/devices/f0850000.axim/channel/counter
+    /* or read all channel counter */
+    root:/# cat sys/bus/coresight/devices/f0850000.axim/counters
+
+The specific sysfs files and their functions are documented under:
+Documentation/ABI/testing/sysfs-bus-coresight-devices-axim
+
+NOTE
+----
+CPU or device accesses may not map the same to AXI bus transactions.
+For example when a CPU accesses a non 64byte aligned address (e.g 0x10), the L2 may
+issue a cache line prefetch to the aligned address (0x0). Therefore it is advised
+to use addresses which are 64 byte aligned. Also some transaction may be served by
+caches which are not visible to specific AXI monitor in use. Therefore it is important
+to understand the transaction characteristics for correct filtering.
+
diff --git a/drivers/hwtracing/coresight/Kconfig b/drivers/hwtracing/coresight/Kconfig
index ef9cb3c164e1..7f7f1c8dd43a 100644
--- a/drivers/hwtracing/coresight/Kconfig
+++ b/drivers/hwtracing/coresight/Kconfig
@@ -103,4 +103,14 @@ config CORESIGHT_CPU_DEBUG
 	  properly, please refer Documentation/trace/coresight-cpu-debug.txt
 	  for detailed description and the example for usage.
 
+config CORESIGHT_SOURCE_AXIM
+	bool "CoreSight Marvell AXI Monitor driver"
+	depends on ARM64
+	select CORESIGHT_LINKS_AND_SINKS
+	help
+	  This driver provides support for the Coresight compatible AXI bus
+	  monitoring and profiling HW. This is primarily useful
+	  for debug and profiling of AXI bus transactions. Depending on the
+	  implemented version data capturing may also be available.
+
 endif
diff --git a/drivers/hwtracing/coresight/Makefile b/drivers/hwtracing/coresight/Makefile
index 61db9dd0d571..d4c5c3fe29b7 100644
--- a/drivers/hwtracing/coresight/Makefile
+++ b/drivers/hwtracing/coresight/Makefile
@@ -18,3 +18,4 @@ obj-$(CONFIG_CORESIGHT_SOURCE_ETM4X) += coresight-etm4x.o \
 obj-$(CONFIG_CORESIGHT_DYNAMIC_REPLICATOR) += coresight-dynamic-replicator.o
 obj-$(CONFIG_CORESIGHT_STM) += coresight-stm.o
 obj-$(CONFIG_CORESIGHT_CPU_DEBUG) += coresight-cpu-debug.o
+obj-$(CONFIG_CORESIGHT_SOURCE_AXIM)  += coresight-axi-monitor.o
diff --git a/drivers/hwtracing/coresight/coresight-axi-monitor.c b/drivers/hwtracing/coresight/coresight-axi-monitor.c
new file mode 100644
index 000000000000..a6571faf77e9
--- /dev/null
+++ b/drivers/hwtracing/coresight/coresight-axi-monitor.c
@@ -0,0 +1,825 @@
+/* Copyright (c) 2018 Marvell semiconductiors inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/err.h>
+#include <linux/coresight.h>
+#include <linux/perf_event.h>
+#include <linux/amba/bus.h>
+#include <linux/delay.h>
+#include "coresight-axi-monitor.h"
+
+static int boot_enable;
+module_param_named(boot_enable, boot_enable, int, S_IRUGO);
+
+static bool axim_check_version(struct axim_drvdata *axim)
+{
+	u32 major = readl_relaxed(axim->base + AXI_MON_VER) & 0xF;
+
+	return (major > AXI_MON_REV_2);
+}
+
+static int axim_trace_id(struct coresight_device *csdev)
+{
+	return 0;
+}
+
+static void axim_enable_channel(struct axim_drvdata *axim, int chan_nr)
+{
+	struct axim_chan_data *chan = &axim->channel[chan_nr];
+	u32 reg;
+	u64 addr_mask, bus_mask;
+	int order, offset;
+	u32 reload;
+
+	/* Find the MSB different between both addresses */
+	order = ilog2(chan->addr_end ^ chan->addr_start);
+	if (order < 0)
+		addr_mask = 0;
+	else
+		addr_mask = ~((1 << (order + 1)) - 1);
+
+	/* Limit the address mask and comperator offset to bus width */
+	if (axim->bus_width < 32)
+		bus_mask = (1 << axim->bus_width) - 1;
+	else
+		bus_mask = (0x100000000ULL << (axim->bus_width - 32)) - 1;
+	addr_mask &= bus_mask;
+
+	offset = clamp(order - 31, 0, (int)axim->bus_width - 32);
+
+	/* First define the power of 2 aligned window
+	 * This is a coarse window for address comparison
+	 */
+	writel(chan->addr_start & U32_MAX, axim->base +
+			AXI_MON_CH_REF_ADDR_L(chan_nr));
+	writel(chan->addr_start >> 32, axim->base +
+			AXI_MON_CH_REF_ADDR_H(chan_nr));
+	writel(addr_mask & U32_MAX, axim->base +
+			AXI_MON_CH_USE_ADDR_L(chan_nr));
+	writel(addr_mask >> 32, axim->base +
+			AXI_MON_CH_USE_ADDR_H(chan_nr));
+
+	/* now set precise addresses in the 32 bit comperator
+	 * the comperator can also be used for user field but we
+	 * always use it for address field to enable fine grain
+	 * address match. The comperator can select which 32 bits
+	 * of address to capture so we update the offset accordingly
+	 */
+	if (addr_mask) {
+		writel(chan->addr_start & U32_MAX,
+			axim->base + AXI_MON_CH_COMP_MIN(chan_nr));
+		writel(chan->addr_end & U32_MAX,
+			axim->base + AXI_MON_CH_COMP_MAX(chan_nr));
+		reg = AXI_MON_COMP_ENABLE | AXI_MON_COMP_ADDR |
+			AXI_MON_COMP_WIDTH_32 | offset;
+		writel(reg, axim->base + AXI_MON_CH_COMP_CTL(chan_nr));
+	} else {
+		writel(0, axim->base + AXI_MON_CH_COMP_CTL(chan_nr));
+	}
+
+	writel(chan->user, axim->base + AXI_MON_CH_REF_USER(chan_nr));
+	writel(chan->user_mask, axim->base + AXI_MON_CH_USE_USER(chan_nr));
+	writel(chan->id, axim->base + AXI_MON_CH_REF_ID(chan_nr));
+	writel(chan->id_mask, axim->base + AXI_MON_CH_USE_ID(chan_nr));
+	writel(AXI_CHAN_ATTR(chan->domain, chan->cache, chan->qos, chan->prot),
+			axim->base + AXI_MON_CH_REF_ATTR(chan_nr));
+	writel(AXI_CHAN_ATTR(chan->domain_mask, chan->cache_mask,
+			chan->qos_mask, chan->prot_mask),
+			axim->base + AXI_MON_CH_REF_ATTR(chan_nr));
+
+	reload = (chan->event_mode == AXIM_EVENT_MODE_OVERFLOW) ?
+			(U32_MAX - (chan->event_thresh - 1)) : 0;
+	writel(reload, axim->base + AXI_MON_CH_RLD(chan_nr));
+	writel(reload, axim->base + AXI_MON_CH_COUNT(chan_nr));
+
+	/* enable event triggering for this channel */
+	reg  = readl(axim->base + AXI_MON_CTL);
+	reg |= (1 << chan_nr);
+	writel(reg, axim->base + AXI_MON_CTL);
+
+	reg = AXI_MON_CHAN_ENABLE | AXI_MON_CHAN_TRIG_ENABLE |
+		(chan->event_mode << 4);
+	writel(reg, axim->base + AXI_MON_CH_CTL(axim->curr_chan));
+
+	chan->enable = 1;
+}
+
+static void axim_disable_channel(struct axim_drvdata *axim, int chan_nr)
+{
+	struct axim_chan_data *chan = &axim->channel[chan_nr];
+	u32 reg;
+
+	reg  = readl(axim->base + AXI_MON_CH_CTL(chan_nr));
+	reg &= ~(AXI_MON_CHAN_ENABLE);
+	writel(reg, axim->base + AXI_MON_CH_CTL(chan_nr));
+
+	chan->enable = 0;
+}
+
+static void axim_reset_channel(struct axim_drvdata *axim, int chan_nr)
+{
+	struct axim_chan_data *chan = &axim->channel[chan_nr];
+
+	writel(0, axim->base + AXI_MON_CH_CTL(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_REF_ADDR_L(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_REF_ADDR_H(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_USE_ADDR_L(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_USE_ADDR_L(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_REF_USER(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_USE_USER(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_REF_ID(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_USE_ID(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_REF_ATTR(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_REF_ATTR(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_COMP_MIN(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_COMP_MAX(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_COMP_CTL(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_RLD(chan_nr));
+	writel(0, axim->base + AXI_MON_CH_COUNT(chan_nr));
+
+	chan->enable = 0;
+}
+
+static int axim_enable(struct coresight_device *csdev,
+		       struct perf_event *event, u32 mode)
+{
+	struct axim_drvdata *axim = dev_get_drvdata(csdev->dev.parent);
+	u32 reg;
+
+	axim->enable = true;
+
+	reg  = readl(axim->base + AXI_MON_CTL);
+	reg |= AXI_MON_ENABLE;
+	if (axim->major < 2)
+		reg |= AXI_MON_EVENT_ENABLE;
+	writel(reg, axim->base + AXI_MON_CTL);
+
+	dev_info(axim->dev, "AXIM tracing enabled\n");
+	return 0;
+}
+
+static void axim_disable(struct coresight_device *csdev,
+			 struct perf_event *event)
+{
+	struct axim_drvdata *axim = dev_get_drvdata(csdev->dev.parent);
+	u32 reg;
+
+	reg  = readl(axim->base + AXI_MON_CTL);
+	reg &= ~(1 << 31);
+	writel(reg, axim->base + AXI_MON_CTL);
+
+	axim->enable = false;
+
+	dev_info(axim->dev, "AXIM tracing disabled\n");
+}
+
+static void axim_reset(struct axim_drvdata *axim)
+{
+	int i;
+
+	/* Restore configurations to reset state */
+	writel(0, axim->base + AXI_MON_CTL);
+	writel(0, axim->base + AXI_MON_DYN_CTL);
+	writel(U32_MAX, axim->base + AXI_MON_EV_CLR);
+
+	for (i = 0; i < axim->nr_chan; i++) {
+		axim_reset_channel(axim, i);
+		memset(&axim->channel[i], 0, sizeof(struct axim_chan_data));
+	}
+
+	axim->enable = false;
+}
+
+static const struct coresight_ops_source axim_source_ops = {
+	.trace_id	= axim_trace_id,
+	.enable		= axim_enable,
+	.disable	= axim_disable,
+};
+
+static const struct coresight_ops axim_cs_ops = {
+	.source_ops	= &axim_source_ops,
+};
+
+static ssize_t reset_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	axim_reset(axim);
+
+	return 0;
+
+}
+static DEVICE_ATTR_WO(reset);
+
+static ssize_t nr_chan_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = axim->nr_chan;
+	return scnprintf(buf, PAGE_SIZE, "%#lx\n", val);
+}
+
+static DEVICE_ATTR_RO(nr_chan);
+
+static ssize_t nr_prof_reg_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = axim->nr_prof_reg;
+	return scnprintf(buf, PAGE_SIZE, "%#lx\n", val);
+}
+static DEVICE_ATTR_RO(nr_prof_reg);
+
+static ssize_t version_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = axim->nr_prof_reg;
+	return scnprintf(buf, PAGE_SIZE, "%d.%d\n", axim->major, axim->minor);
+}
+static DEVICE_ATTR_RO(version);
+
+static ssize_t bus_width_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", axim->bus_width);
+}
+static DEVICE_ATTR_RO(bus_width);
+
+static ssize_t curr_chan_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = axim->curr_chan;
+	return scnprintf(buf, PAGE_SIZE, "%#lx\n", val);
+}
+
+static ssize_t curr_chan_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	if (val > axim->nr_chan)
+		return -EINVAL;
+
+	axim->curr_chan = val;
+	return size;
+}
+static DEVICE_ATTR_RW(curr_chan);
+
+static ssize_t counters_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+	int i, ret = 0, size = 0;
+
+	for (i = 0; i < axim->nr_chan; i++) {
+		size = scnprintf(buf + ret, PAGE_SIZE, "%#x\n",
+				readl(axim->base + AXI_MON_CH_COUNT(i)));
+		ret += size;
+	}
+
+	return ret;
+}
+static DEVICE_ATTR_RO(counters);
+
+static ssize_t mon_enable_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = axim->enable;
+	return scnprintf(buf, PAGE_SIZE, "%ld\n", val);
+}
+
+static ssize_t mon_enable_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	if (val)
+		axim_enable(axim->csdev, NULL, CS_MODE_SYSFS);
+	else
+		axim_disable(axim->csdev, NULL);
+
+	return size;
+}
+static DEVICE_ATTR_RW(mon_enable);
+
+
+static ssize_t prof_enable_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = readl(axim->base + AXI_MON_PR_CTL);
+	val = (val >> AXI_MON_PROF_EN_OFF) & 0x1;
+	return scnprintf(buf, PAGE_SIZE, "%ld\n", val);
+}
+
+static ssize_t prof_enable_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long reg, val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	if (!axim->prof_en)
+		return -EPERM;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	reg = readl(axim->base + AXI_MON_PR_CTL);
+	if (val) {
+		reg |= (1 << AXI_MON_PROF_EN_OFF);
+		reg &= ~(AXI_MON_PROF_CYCG_MASK	<< AXI_MON_PROF_CYCG_OFF);
+		reg |= (AXI_MON_PROF_CYCG_4_CYC	<< AXI_MON_PROF_CYCG_OFF);
+		if (AXI_MON_PROF_CYCG_4_CYC != 0)
+			axim->prof_cyc_mul = 1 << (AXI_MON_PROF_CYCG_4_CYC + 1);
+		else
+			axim->prof_cyc_mul = 1;
+	} else {
+		reg &= ~(1 << AXI_MON_PROF_EN_OFF);
+	}
+	writel(reg, axim->base + AXI_MON_PR_CTL);
+
+	return size;
+}
+static DEVICE_ATTR_RW(prof_enable);
+
+static char *memfmt(char *buf, unsigned long n)
+{
+	if (n >= (1UL << 30))
+		sprintf(buf, "%lu GB", n >> 30);
+	else if (n >= (1UL << 20))
+		sprintf(buf, "%lu MB", n >> 20);
+	else
+		sprintf(buf, "%lu KB", n >> 10);
+	return buf;
+}
+
+
+static ssize_t prof_counters_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	int timeout = 100;
+	ssize_t size = 0;
+	uint32_t msec, val, trans, temp;
+	uint64_t val_64;
+	uint32_t min_lat, max_lat, total_lat;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+	char fmt_buf[16];
+
+	/* Start event sampling */
+	val = readl(axim->base + AXI_MON_EV_SW_TRIG);
+	val |= AXI_EV_SW_TRIG_SAMPLE_EN;
+	writel(val, axim->base + AXI_MON_EV_SW_TRIG);
+
+	/* Wait till sampling is done. */
+	while (timeout) {
+		val = readl(axim->base + AXI_MON_STAT) & AXI_MON_STAT_SIP_MASK;
+		if (!val)
+			break;
+		udelay(10);
+		timeout--;
+	}
+
+	if (!timeout) {
+		size += scnprintf(buf, PAGE_SIZE,
+				"Error - Event sampling timeout.\n");
+		return size;
+	}
+
+	/* # of cycles. */
+	val_64 = readl(axim->base + AXI_MON_PR_SMP_CYC) * axim->prof_cyc_mul;
+	msec = val_64 / axim->clock_freq_mhz / 1000;
+	size += scnprintf(buf + size, PAGE_SIZE,
+			"Cycles  - %10u [%d msec]\n", (u32)val_64, msec);
+
+	/* # of transactions */
+	trans = readl(axim->base + AXI_MON_PR_SMP_TRANS);
+	size += scnprintf(buf + size, PAGE_SIZE,
+			"Trans   - %10u [%d trans/sec]\n",
+			trans, (u32)((u64)trans * 1000 / msec));
+
+	/* # of AXI beats */
+	val = readl(axim->base + AXI_MON_PR_SMP_BEATS);
+	size += scnprintf(buf + size, PAGE_SIZE,
+			"Beats   - %10u [%d beats/sec]\n",
+			val, (u32)((u64)val * 1000 / msec));
+
+	/* # of Bytes */
+	val = readl(axim->base + AXI_MON_PR_SMP_BYTES);
+	temp = (u32)((u64)val * 1000 / msec);
+	size += scnprintf(buf + size, PAGE_SIZE,
+			"Bytes   - %10u [%d B/sec, %sps]\n"
+			, val, temp, memfmt(fmt_buf, temp));
+
+	/* Latency */
+	total_lat = readl(axim->base + AXI_MON_PR_SMP_LATEN);
+	max_lat = readl(axim->base + AXI_MON_PR_SMP_MAX);
+	min_lat = readl(axim->base + AXI_MON_PR_SMP_MIN);
+
+	/*
+	 * Convert latency values from clock cycles to nsec.
+	 * Multiply by 1000 and divide by MHz
+	 */
+	size += scnprintf(buf + size, PAGE_SIZE,
+		"Latency - %10u [Avg - %u ns]\n", total_lat,
+		(u32)((u64)total_lat * 1000 / trans / axim->clock_freq_mhz));
+	size += scnprintf(buf + size, PAGE_SIZE, "Min lat - %10u [%d ns]\n",
+			min_lat, min_lat * 1000 / axim->clock_freq_mhz);
+	size += scnprintf(buf + size, PAGE_SIZE, "Max lat - %10u [%d ns]\n",
+			max_lat, max_lat * 1000 / axim->clock_freq_mhz);
+
+	/* Resume event collection */
+	val = readl(axim->base + AXI_MON_EV_CLR);
+	val |= AXI_MON_EV_SMPR;
+	writel(val, axim->base + AXI_MON_EV_CLR);
+
+	if (val & AXI_MON_EV_PE)
+		size += scnprintf(buf + size, PAGE_SIZE,
+				"Warning - Counter overflow occurred in one of the SMP counters.\n");
+
+	return size;
+}
+static DEVICE_ATTR_RO(prof_counters);
+
+static ssize_t freeze_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	/* TODO - create the sysfs dynamically only if rev > 1 */
+	if (axim->major < 2)
+		return -EINVAL;
+
+	val = readl(axim->base + AXI_MON_DYN_CTL);
+	val = (val >> DYN_CTL_FREEZE_OFF) & 0x1;
+	return scnprintf(buf, PAGE_SIZE, "%ld\n", val);
+}
+
+static ssize_t freeze_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+	u32 reg;
+
+	/* TODO - create the sysfs dynamically only if rev > 1 */
+	if (axim->major < 2)
+		return -EINVAL;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	if ((val != 1) && (val != 0))
+		return -EINVAL;
+
+	reg  = readl(axim->base + AXI_MON_DYN_CTL);
+	reg &= ~(1 << DYN_CTL_FREEZE_OFF);
+	reg |= val << DYN_CTL_FREEZE_OFF;
+	writel(reg, axim->base + AXI_MON_DYN_CTL);
+
+	return size;
+}
+static DEVICE_ATTR_RW(freeze);
+
+static struct attribute *coresight_axim_attrs[] = {
+	&dev_attr_nr_chan.attr,
+	&dev_attr_nr_prof_reg.attr,
+	&dev_attr_version.attr,
+	&dev_attr_bus_width.attr,
+	&dev_attr_curr_chan.attr,
+	&dev_attr_reset.attr,
+	&dev_attr_counters.attr,
+	&dev_attr_mon_enable.attr,
+	&dev_attr_freeze.attr,
+	&dev_attr_prof_enable.attr,
+	&dev_attr_prof_counters.attr,
+	NULL,
+};
+
+#define axi_chan_attr(name, max)					\
+static ssize_t name##_show(struct device *dev,				\
+			      struct device_attribute *attr,		\
+			      char *buf)				\
+{									\
+	unsigned long val;						\
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);	\
+									\
+	val = axim->channel[axim->curr_chan].name;		\
+	return scnprintf(buf, PAGE_SIZE, "%#lx\n", val);		\
+}									\
+									\
+static ssize_t name##_store(struct device *dev,				\
+			struct device_attribute *attr,			\
+			const char *buf, size_t size)			\
+{									\
+	unsigned long val;						\
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);	\
+									\
+	if (kstrtoul(buf, 16, &val))					\
+		return -EINVAL;						\
+	if (val > max)							\
+		return -EINVAL;						\
+									\
+	axim->channel[axim->curr_chan].name = val;		\
+									\
+	return size;							\
+}									\
+static DEVICE_ATTR_RW(name)
+
+axi_chan_attr(addr_start,  0xffffffffffffffff);
+axi_chan_attr(addr_end, 0xffffffffffffffff);
+axi_chan_attr(user, 0xffff);
+axi_chan_attr(user_mask, 0xffff);
+axi_chan_attr(id, 0xffff);
+axi_chan_attr(id_mask, 0xffff);
+axi_chan_attr(domain, 0x3);
+axi_chan_attr(domain_mask, 0x3);
+axi_chan_attr(cache, 0xf);
+axi_chan_attr(cache_mask, 0xf);
+axi_chan_attr(qos, 0x3);
+axi_chan_attr(qos_mask, 0x3);
+axi_chan_attr(prot, 0x3);
+axi_chan_attr(prot_mask, 0x3);
+axi_chan_attr(event_mode, 0x1);
+axi_chan_attr(event_thresh, 0xffffffff);
+
+static ssize_t enable_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = readl_relaxed(axim->base + AXI_MON_CH_CTL(axim->curr_chan));
+	val  = BMVAL(val, 31, 31);
+	return scnprintf(buf, PAGE_SIZE, "%#lx\n", val);
+}
+
+static ssize_t enable_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	if ((val != 1) && (val != 0))
+		return -EINVAL;
+
+	if (val)
+		axim_enable_channel(axim, axim->curr_chan);
+	else
+		axim_disable_channel(axim, axim->curr_chan);
+
+	return size;
+}
+static DEVICE_ATTR_RW(enable);
+
+static ssize_t counter_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long reload, count;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	count  = readl_relaxed(axim->base + AXI_MON_CH_COUNT(axim->curr_chan));
+	reload = readl_relaxed(axim->base + AXI_MON_CH_RLD(axim->curr_chan));
+	return scnprintf(buf, PAGE_SIZE, "%#lx\n", count - reload);
+}
+
+static ssize_t counter_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	writel(val, axim->base + AXI_MON_CH_COUNT(axim->curr_chan));
+
+	return size;
+}
+static DEVICE_ATTR_RW(counter);
+
+static struct attribute *coresight_axim_chan_attrs[] = {
+	&dev_attr_addr_start.attr,
+	&dev_attr_addr_end.attr,
+	&dev_attr_user.attr,
+	&dev_attr_user_mask.attr,
+	&dev_attr_id.attr,
+	&dev_attr_id_mask.attr,
+	&dev_attr_domain.attr,
+	&dev_attr_domain_mask.attr,
+	&dev_attr_cache.attr,
+	&dev_attr_cache_mask.attr,
+	&dev_attr_prot.attr,
+	&dev_attr_prot_mask.attr,
+	&dev_attr_qos.attr,
+	&dev_attr_qos_mask.attr,
+	&dev_attr_counter.attr,
+	&dev_attr_event_thresh.attr,
+	&dev_attr_event_mode.attr,
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group coresight_axim_group = {
+	.attrs = coresight_axim_attrs,
+};
+
+static const struct attribute_group coresight_axim_chan_group = {
+	.attrs = coresight_axim_chan_attrs,
+	.name = "channel",
+};
+
+static const struct attribute_group *coresight_axim_groups[] = {
+	&coresight_axim_group,
+	&coresight_axim_chan_group,
+	NULL,
+};
+
+static void axim_init_default_data(struct axim_drvdata *axim)
+{
+	u32 reg;
+
+	reg = readl_relaxed(axim->base + AXI_MON_VER);
+	axim->nr_prof_reg = BMVAL(reg, 16, 19); /* NPRR */
+	axim->latency_en = BMVAL(reg, 24, 24);
+	axim->trace_en = BMVAL(reg, 25, 25);
+	axim->minor = BMVAL(reg, 4, 7);
+	axim->major = BMVAL(reg, 0, 3) + 1;
+
+	/* AXIM v1 doesn't have a version register and will
+	 * return 0 when reading from AXI_MON_VER. For all fields it
+	 * emulates a VER register fine except for nr_chan
+	 */
+	if (reg) {
+		axim->nr_chan = BMVAL(reg, 12, 15); /* NCH */
+		axim->prof_en = true;
+	} else {
+		axim->nr_chan = 4;
+		axim->prof_en = false;
+	}
+}
+
+static int axim_probe(struct amba_device *adev, const struct amba_id *id)
+{
+	void __iomem *base;
+	struct device *dev = &adev->dev;
+	struct coresight_platform_data *pdata = NULL;
+	struct axim_drvdata *axim;
+	struct resource *res = &adev->res;
+	struct coresight_desc desc = { 0 };
+	struct device_node *np = adev->dev.of_node;
+	int ret;
+
+	axim = devm_kzalloc(dev, sizeof(*axim), GFP_KERNEL);
+	if (!axim)
+		return -ENOMEM;
+
+	if (np) {
+		pdata = of_get_coresight_platform_data(dev, np);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+		adev->dev.platform_data = pdata;
+	}
+
+	axim->dev = &adev->dev;
+	dev_set_drvdata(dev, axim);
+
+	/* Validity for the resource is already checked by the AMBA core */
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	axim->base = base;
+
+	ret = of_property_read_u32(np, "bus-width", &axim->bus_width);
+	if ((ret) || (axim->bus_width > AXI_MON_MAX_BUS_WIDTH)) {
+		dev_warn(dev, "Bad or missing bus-width property. assuming %d bit width\n",
+				AXI_MON_MAX_BUS_WIDTH);
+		axim->bus_width = AXI_MON_MAX_BUS_WIDTH;
+	}
+
+	if (axim_check_version(axim))
+		return -EINVAL;
+
+	axim_init_default_data(axim);
+	axim_reset(axim);
+
+	if (axim->prof_en) {
+		axim->clk = devm_clk_get(dev, "hclk");
+		if (IS_ERR(axim->clk)) {
+			dev_warn(dev, "Cannot get profiling clock frequency, Disabling profiling support.\n");
+			axim->prof_en = false;
+		} else {
+			ret = clk_prepare_enable(axim->clk);
+			if (ret)
+				return ret;
+			axim->clock_freq_mhz =
+				clk_get_rate(axim->clk) / 1000000;
+		}
+
+	}
+
+	desc.type = CORESIGHT_DEV_TYPE_SOURCE;
+	desc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;
+	desc.ops = &axim_cs_ops;
+	desc.pdata = pdata;
+	desc.dev = dev;
+	desc.groups = coresight_axim_groups;
+	axim->csdev = coresight_register(&desc);
+	if (IS_ERR(axim->csdev))
+		return PTR_ERR(axim->csdev);
+
+	dev_info(dev, "%s %d.%d initialized\n",
+			(char *)id->data, axim->major, axim->minor);
+
+	if (boot_enable) {
+		coresight_enable(axim->csdev);
+		axim->boot_enable = true;
+	}
+
+	return 0;
+}
+
+const static struct amba_id axim_ids[] = {
+	{       /* AXI Monitor Marvell*/
+		.id	= 0x000e9ae1,
+		.mask	= 0x000fffff,
+		.data	= "AXIM 4.0",
+	},
+	{ 0, 0},
+};
+
+static struct amba_driver axim_driver = {
+	.drv = {
+		.name   = "coresight-axim",
+		.suppress_bind_attrs = true,
+	},
+	.probe		= axim_probe,
+	.id_table	= axim_ids,
+};
+
+builtin_amba_driver(axim_driver);
diff --git a/drivers/hwtracing/coresight/coresight-axi-monitor.h b/drivers/hwtracing/coresight/coresight-axi-monitor.h
new file mode 100644
index 000000000000..e498663937c3
--- /dev/null
+++ b/drivers/hwtracing/coresight/coresight-axi-monitor.h
@@ -0,0 +1,206 @@
+/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _CORESIGHT_CORESIGHT_ETM_H
+#define _CORESIGHT_CORESIGHT_ETM_H
+
+#include "coresight-priv.h"
+
+/*
+ * Device registers:
+ * 0x000 - 0x100: Global	registers
+ * 0x100 - 0xD00: Channel	registers
+ * 0xD00 - 0xFD0: Profiling	registers
+ * 0xFDO - 0xFFC: ID		registers
+ */
+
+/* Global registers (0x000-0x2FC) */
+/* Main control and configuration registers */
+#define AXI_MON_CTL			0x00
+#define AXI_MON_DYN_CTL			0x04
+#define AXI_MON_STAT			0x08
+#define AXI_MON_EV_CLR			0x10
+#define AXI_MON_EV_SW_TRIG		0x20
+#define AXI_MON_VER			0x30
+
+/* Channel registers */
+#define AXI_MON_CH_BASE(x)		(0x100 + 0x100 * x)
+#define AXI_MON_CH_CTL(x)		(AXI_MON_CH_BASE(x) + 0x00)
+#define AXI_MON_CH_REF_ADDR_L(x)	(AXI_MON_CH_BASE(x) + 0x10)
+#define AXI_MON_CH_REF_ADDR_H(x)	(AXI_MON_CH_BASE(x) + 0x14)
+#define AXI_MON_CH_USE_ADDR_L(x)	(AXI_MON_CH_BASE(x) + 0x18)
+#define AXI_MON_CH_USE_ADDR_H(x)	(AXI_MON_CH_BASE(x) + 0x1C)
+#define AXI_MON_CH_REF_ID(x)		(AXI_MON_CH_BASE(x) + 0x20)
+#define AXI_MON_CH_USE_ID(x)		(AXI_MON_CH_BASE(x) + 0x24)
+#define AXI_MON_CH_REF_USER(x)		(AXI_MON_CH_BASE(x) + 0x28)
+#define AXI_MON_CH_USE_USER(x)		(AXI_MON_CH_BASE(x) + 0x2C)
+#define AXI_MON_CH_REF_ATTR(x)		(AXI_MON_CH_BASE(x) + 0x30)
+#define AXI_MON_CH_USE_ATTR(x)		(AXI_MON_CH_BASE(x) + 0x34)
+#define AXI_MON_CH_REF_AUX_ATTR(x)	(AXI_MON_CH_BASE(x) + 0x38)
+#define AXI_MON_CH_USE_AUX_ATTR(x)	(AXI_MON_CH_BASE(x) + 0x3C)
+#define AXI_MON_CH_COMP_CTL(x)		(AXI_MON_CH_BASE(x) + 0x50)
+#define AXI_MON_CH_COMP_MAX(x)		(AXI_MON_CH_BASE(x) + 0x60)
+#define AXI_MON_CH_COMP_MIN(x)		(AXI_MON_CH_BASE(x) + 0x68)
+#define AXI_MON_CH_COUNT(x)		(AXI_MON_CH_BASE(x) + 0x90)
+#define AXI_MON_CH_RLD(x)		(AXI_MON_CH_BASE(x) + 0x98)
+
+/* Profiling registers */
+#define AXI_MON_PR_CTL			(0xD00)
+#define AXI_MON_SAMP_CNT		(0xD20)
+#define AXI_MON_SAMP_CNT_RLD		(0xD24)
+#define AXI_MON_PR_SMP_CYC		(0xD50)
+#define AXI_MON_PR_SMP_TRANS		(0xD54)
+#define AXI_MON_PR_SMP_BEATS		(0xD58)
+#define AXI_MON_PR_SMP_BYTES		(0xD5C)
+#define AXI_MON_PR_SMP_LATEN		(0xD60)
+#define AXI_MON_PR_SMP_MAX		(0xD64)
+#define AXI_MON_PR_SMP_MIN		(0xD68)
+
+/* Comperator configuration */
+#define AXI_MON_COMP_ENABLE		(1 << 31)
+#define AXI_MON_COMP_ADDR		(0 << 24)
+#define AXI_MON_COMP_WIDTH_32		(31 << 8)
+
+/* Channel control */
+#define AXI_MON_CHAN_ENABLE		(1 << 31)
+#define AXI_MON_CHAN_IRQ_ENABLE		(1 << 9)
+#define AXI_MON_CHAN_TRIG_ENABLE	(1 << 8)
+
+/* Global control */
+#define AXI_MON_ENABLE			(1 << 31)
+#define AXI_MON_IRQ_ENABLE		(1 << 14)
+	/* rev 2 only */
+#define AXI_MON_DYN_DEACT		(1 << 13)
+#define AXI_MON_DYN_ACT			(1 << 12)
+	/* rev 1 only */
+#define AXI_MON_EVENT_ENABLE		(1 << 12)
+
+/* Dynamic control */
+#define DYN_CTL_FREEZE_OFF		(0)
+
+/* Attribute register */
+#define AXI_CHAN_ATTR(dom, cache, qos, prot)	(dom << 24 | cache << 16 |\
+							qos << 8 | prot)
+
+/* Axi Mon Event Clear register */
+#define AXI_MON_EV_PE			(1 << 17)
+#define AXI_MON_EV_SMPR			(1 << 24)
+
+/* AXI Mon Stat register */
+#define AXI_MON_STAT_SIP_OFF		(23)
+#define AXI_MON_STAT_SIP_MASK		(0x3 << AXI_MON_STAT_SIP_OFF)
+
+/* SW Trigger register */
+#define AXI_EV_SW_TRIG_SAMPLE_EN	(1 << 16)
+
+/* Profiling Control */
+#define AXI_MON_PROF_EN_OFF		(31)
+#define AXI_MON_PROF_CYCG_OFF		(8)
+#define AXI_MON_PROF_CYCG_MASK		(7)
+#define AXI_MON_PROF_CYCG_4_CYC		(1)
+
+/* Supported versions */
+#define AXI_MON_VER_MASK		(0x0F)
+#define AXI_MON_REV_1			(0x00)
+#define AXI_MON_REV_2			(0x01)
+
+#define AXI_MON_MAX_CHANNELS		(12)
+#define AXI_MON_MAX_BUS_WIDTH		(48)
+
+
+/* Address comparator access types */
+enum axim_comp_type {
+	AXIM_COMP_ADDR,
+	AXIM_COMP_USER,
+};
+/* Event trigger modes */
+enum axim_event_mode {
+	AXIM_EVENT_MODE_MATCH = 0,
+	AXIM_EVENT_MODE_OVERFLOW = 1,
+};
+
+/**
+ * struct axim_chan_data - holds the axi monitor channel configuration
+ *
+ * @addr_start:		Physical start address to match
+ * @addr_end:		Physical end address to match
+ * @id(_mask):		AXI AxID field to match
+ * @user(_mask):	AXI AxUSER field to match
+ * @domain(_mask):	AXI AxDOMAIN field to match
+ * @cache(_mask):	AXI AxCACHE field to match
+ * @qos(_mask):		AXI AxQOS field to match
+ * @prot(_mask):	AXI AxPROT field to match
+ * @event_mode:		Selects when to generate an event
+ * @event_thresh:	Counter threshold to generate event
+ * @enable:		Is this AXIM channel currently enable.
+ */
+struct axim_chan_data {
+	u64	addr_start;
+	u64	addr_end;
+	u32	id;
+	u32	id_mask;
+	u32	user;
+	u32	user_mask;
+	u8	domain;
+	u8	domain_mask;
+	u8	cache;
+	u8	cache_mask;
+	u8	qos;
+	u8	qos_mask;
+	u8	prot;
+	u8	prot_mask;
+	enum axim_event_mode event_mode;
+	u32	event_thresh;
+	bool	enable;
+};
+
+/**
+ * struct axim_drvdata - specifics associated to an AXIM component
+ * @base:       Memory mapped base address for this component.
+ * @dev:        The device entity associated to this component.
+ * @csdev:      Component vitals needed by the framework.
+ * @enable:	Is this AXIM currently enable.
+ * @boot_enable:True if we should start tracing at boot time.
+ * @latency_en: Indicate latency measurment support.
+ * @trace_en:	Indicate trace support.
+ * @prof_en:	Indicate profiling support.
+ * @nr_chan:	Number of comparator channels.
+ * @curr_chan:	Channel Number for configuration.
+ * @nr_prof_reg:Number of profiling registers.
+ * @major:	Major HW version.
+ * @minor:	Minor HW version.
+ * @prof_cyc_mul: Cycle multiplier for profiling clock events.
+ * @clock_freq_mhz: Profiler clock frequency in MHz.
+ * @channels:	Channel descriptor.
+ */
+struct axim_drvdata {
+	void __iomem			*base;
+	struct device			*dev;
+	struct coresight_device		*csdev;
+	struct clk			*clk;
+	bool				enable;
+	bool				boot_enable;
+	bool				latency_en;
+	bool				trace_en;
+	bool				prof_en;
+	u8				nr_chan;
+	u8				curr_chan;
+	u8				nr_prof_reg;
+	u8				major;
+	u8				minor;
+	u8				prof_cyc_mul;
+	u32				bus_width;
+	u32				clock_freq_mhz;
+	struct axim_chan_data		channel[AXI_MON_MAX_CHANNELS];
+};
+
+#endif
-- 
2.17.1


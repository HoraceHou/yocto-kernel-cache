From 5cf304ed73a8894c9a0377dcf94b31fb63c43fc2 Mon Sep 17 00:00:00 2001
From: Yury Norov <ynorov@marvell.com>
Date: Wed, 8 Aug 2018 15:21:47 +0530
Subject: [PATCH 0104/1051] net: octeontx2: Add 128-bit IO functions

There's no arm64 hardware that runs Linux and supports 128-bit
atomic memory access. Therefore there's no corresponding API for
it. But OcteonTX2 requires 128-bit access to some registers. So
in this patch minimal set of 128-bit read/write functions is
introduced to support IO memory access for Octeon TX2 in big and
little-endian modes.

Detailed discussion on 128-bit API is here:
https://lkml.org/lkml/2018/1/24/115

Signed-off-by: Yury Norov <ynorov@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/otx2_common.h  | 37 +++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index edea379729d1..b80d0727d88f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -89,6 +89,43 @@ static inline u64 otx2_read64(struct otx2_nic *nic, u64 offset)
 	return readq(nic->reg_base + offset);
 }
 
+/* With the absence of API for 128-bit IO memory access for arm64,
+ * implement required operations at place.
+ */
+#ifdef __BIG_ENDIAN
+#define otx2_high(high, low)   (low)
+#define otx2_low(high, low)    (high)
+#else
+#define otx2_high(high, low)   (high)
+#define otx2_low(high, low)    (low)
+#endif
+
+static inline void otx2_write128(__uint128_t val, void __iomem *addr)
+{
+	__uint128_t *__addr = (__force __uint128_t *)addr;
+	u64 h, l;
+
+	otx2_low(h, l) = (__force u64)cpu_to_le64(val);
+	otx2_high(h, l) = (__force u64)cpu_to_le64(val >> 64);
+
+	asm volatile("stp %x[x0], %x[x1], %x[p1]"
+		: [p1]"=Ump"(*__addr)
+		: [x0]"r"(l), [x1]"r"(h));
+}
+
+static inline __uint128_t otx2_read128(const void __iomem *addr)
+{
+	__uint128_t *__addr = (__force __uint128_t *)addr;
+	u64 h, l;
+
+	asm volatile("ldp %x[x0], %x[x1], %x[p1]"
+		: [x0]"=r"(l), [x1]"=r"(h)
+		: [p1]"Ump"(*__addr));
+
+	return (__uint128_t)le64_to_cpu(otx2_low(h, l)) |
+		(((__uint128_t)le64_to_cpu(otx2_high(h, l))) << 64);
+}
+
 /* Mbox APIs */
 static inline int otx2_sync_mbox_msg(struct mbox *mbox)
 {
-- 
2.17.1


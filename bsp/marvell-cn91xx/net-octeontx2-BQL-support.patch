From 958bcd266e3d66bb8917ee2d486cf007fb27e66d Mon Sep 17 00:00:00 2001
From: Christina Jacob <cjacob@marvell.com>
Date: Mon, 13 Aug 2018 18:09:40 +0530
Subject: [PATCH 0122/1051] net: octeontx2: BQL support.

Added byte queue limits support for PF driver.

Signed-off-by: Christina Jacob <cjacob@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/otx2_pf.c   |  4 ++++
 .../net/ethernet/marvell/octeontx2/otx2_txrx.c | 18 ++++++++++++++++--
 2 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index d5eaa652aa87..2dd1ac563a25 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -597,6 +597,10 @@ static int otx2_stop(struct net_device *netdev)
 	otx2_disable_msix(pf);
 
 	otx2_disable_napi(pf);
+
+	for (qidx = 0; qidx < netdev->num_tx_queues; qidx++)
+		netdev_tx_reset_queue(netdev_get_tx_queue(netdev, qidx));
+
 	kfree(qset->sq);
 	kfree(qset->cq);
 	kfree(qset->napi);
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
index 60657920f695..3ebf2069228e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
@@ -84,7 +84,7 @@ static void otx2_dma_unmap_skb_frags(struct otx2_nic *pfvf, struct sg_list *sg)
 
 static void otx2_snd_pkt_handler(struct otx2_nic *pfvf,
 				 struct otx2_cq_queue *cq, void *cqe,
-				 int budget)
+				 int budget, int *tx_pkts, int *tx_bytes)
 {
 	struct nix_cqe_hdr_s *cqe_hdr = (struct nix_cqe_hdr_s *)cqe;
 	struct nix_send_comp_s *snd_comp;
@@ -106,6 +106,8 @@ static void otx2_snd_pkt_handler(struct otx2_nic *pfvf,
 
 	skb = (struct sk_buff *)sg->skb;
 	if (skb) {
+		*tx_bytes += skb->len;
+		(*tx_pkts)++;
 		otx2_dma_unmap_skb_frags(pfvf, sg);
 		napi_consume_skb(skb, budget);
 		sg->skb = (u64)NULL;
@@ -267,12 +269,15 @@ int otx2_napi_handler(struct otx2_cq_queue *cq,
 	int processed_cqe = 0, workdone = 0;
 	int cq_head, cq_tail, pool_ptrs = 0;
 	struct nix_cqe_hdr_s *cqe_hdr;
+	int tx_pkts = 0, tx_bytes = 0;
+	struct netdev_queue *txq;
 	u64 cq_status;
 	s64 bufptr;
 
 	cq_status = otx2_nix_cq_op_status(pfvf, cq->cq_idx);
 	cq_head = (cq_status >> 20) & 0xFFFFF;
 	cq_tail = cq_status & 0xFFFFF;
+
 	/* Since multiple CQs may be mapped to same CINT,
 	 * check if there are valid CQEs in this CQ.
 	 */
@@ -295,7 +300,8 @@ int otx2_napi_handler(struct otx2_cq_queue *cq,
 			workdone++;
 			break;
 		case NIX_XQE_TYPE_SEND:
-			otx2_snd_pkt_handler(pfvf, cq, cqe_hdr, budget);
+			otx2_snd_pkt_handler(pfvf, cq, cqe_hdr, budget,
+					     &tx_pkts, &tx_bytes);
 		}
 		processed_cqe++;
 	}
@@ -303,6 +309,11 @@ int otx2_napi_handler(struct otx2_cq_queue *cq,
 	otx2_write64(pfvf, NIX_LF_CQ_OP_DOOR,
 		     ((u64)cq->cq_idx << 32) | processed_cqe);
 
+	if (tx_pkts) {
+		txq = netdev_get_tx_queue(pfvf->netdev, cq->cint_idx);
+		netdev_tx_completed_queue(txq, tx_pkts, tx_bytes);
+	}
+
 	if (!pool_ptrs)
 		return 0;
 
@@ -470,6 +481,7 @@ static void otx2_sqe_add_hdr(struct otx2_nic *pfvf, struct otx2_snd_queue *sq,
 bool otx2_sq_append_skb(struct net_device *netdev, struct otx2_snd_queue *sq,
 			struct sk_buff *skb, u16 qidx)
 {
+	struct netdev_queue *txq = netdev_get_tx_queue(netdev, qidx);
 	struct otx2_nic *pfvf = netdev_priv(netdev);
 	struct nix_sqe_hdr_s *sqe_hdr;
 	int offset, num_segs;
@@ -512,6 +524,8 @@ bool otx2_sq_append_skb(struct net_device *netdev, struct otx2_snd_queue *sq,
 
 	sqe_hdr->sizem1 = (offset / 16) - 1;
 
+	netdev_tx_sent_queue(txq, skb->len);
+
 	/* Packet data stores should finish before SQE is flushed to HW */
 	dma_wmb();
 
-- 
2.17.1


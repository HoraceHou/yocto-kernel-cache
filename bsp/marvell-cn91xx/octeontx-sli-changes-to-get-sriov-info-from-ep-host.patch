From 665aaba9785e7e291df627905d154c4afd67c3da Mon Sep 17 00:00:00 2001
From: Aakash Sasidharan <Aakash.Sasidharan@cavium.com>
Date: Wed, 13 Jun 2018 18:05:48 +0530
Subject: [PATCH 0349/1051] octeontx-sli: changes to get sriov info from ep
 host

Changes to perform handshake between ep host and slipf driver
to get the sriov information at the ep host.

Signed-off-by: Aakash Sasidharan <Aakash.Sasidharan@cavium.com>
Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/cavium/Kconfig           |   2 +-
 .../net/ethernet/cavium/octeontx-83xx/sli.h   |  65 ++++-
 .../cavium/octeontx-83xx/slipf_main.c         | 256 ++++++++++++++----
 3 files changed, 260 insertions(+), 63 deletions(-)

diff --git a/drivers/net/ethernet/cavium/Kconfig b/drivers/net/ethernet/cavium/Kconfig
index 60bda2988037..cd0d603fd49a 100644
--- a/drivers/net/ethernet/cavium/Kconfig
+++ b/drivers/net/ethernet/cavium/Kconfig
@@ -191,7 +191,7 @@ config OCTEONTX_ZIP_PF
 
 config OCTEONTX_SLI_PF
 	tristate "OcteonTX SLI physical function driver(SLI_PF)"
-	depends on 64BIT && OCTEONTX_DPI
+	depends on 64BIT && OCTEONTX_DPI && OCTEONTX_RST
 	default y
 	help
 	  Select this option to enable SLI.
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/sli.h b/drivers/net/ethernet/cavium/octeontx-83xx/sli.h
index d5eb366c2517..7b94666d727a 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/sli.h
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/sli.h
@@ -19,17 +19,57 @@
 #define PCI_SLI_PF_CFG_BAR		0
 #define PCI_SLI_PF_MSIX_BAR		4
 
+#define SLI_LMAC_MAX_PFS		1
+
+#define SLI_SCRATCH1			(0x1000ULL)
+#define SLI_SCRATCH2			(0x1010ULL)
+#define SDP_SCRATCHX(x)			(0x80020180ULL | ((x) << 23))
+#define SLI_EPFX_SCRATCH(x)		(0x80028100ULL | ((x) << 23))
+
+#define SDP_CONST			(0x880300ULL)
+#define SDP_CONST			(0x880300ULL)
+#define SLI_LMAC_CONST0X(x)		(0x1004000ULL | ((x) << 4))
+#define SLI_LMAC_CONST1X(x)		(0x1004008ULL | ((x) << 4))
+
+#define SDP_OUT_WMARK			(0x880000ULL)
+#define SDP_GBL_CONTROL			(0x880200ULL)
+#define SDP_GBL_CONTROL_BPKIND_MASK     0x3f
+#define SDP_GBL_CONTROL_BPKIND_SHIFT	8
+#define SDP_OUT_BP_ENx_W1C(x)		(0x880220ULL | ((x) << 4))
+#define SDP_OUT_BP_ENx_W1S(x)		(0x880240ULL | ((x) << 4))
+#define SDP_PKIND_VALID			(0x880210ULL)
+
+#define SDP_CHANNEL_START		0x400
+#define SDP_HOST_LOADED			0xDEADBEEFULL
+#define SDP_GET_HOST_INFO		0xBEEFDEEDULL
+#define SDP_HOST_INFO_RECEIVED		0xDEADDEULL
+#define SDP_HANDSHAKE_COMPLETED		0xDEEDDEEDULL
+
+#define SDP_HOST_EPF_APP_BASE		0x1
+#define SDP_HOST_EPF_APP_NIC		0x2
+
+struct sli_epf {
+	int hs_done;
+	int app_mode;
+	int pf_srn;
+	int rppf;
+	int num_vfs;
+	int vf_srn;
+	int rpvf;
+};
+
 struct slipf {
-	struct pci_dev		*pdev;
-	void __iomem		*reg_base;
-	int			id;
-	struct msix_entry	*msix_entries;
+	struct pci_dev *pdev;
+	void __iomem *reg_base;
+	int id;
+	struct msix_entry *msix_entries;
 	struct list_head    list; /* List of SLI devices */
-	int   sli_idx; /* CPU-local SLI device index.*/
-	int   port_count;
-	int   node; /* CPU node */
-
-	u32	  flags;
+	int sli_idx; /* CPU-local SLI device index.*/
+	int port_count;
+	int node; /* CPU node */
+	u32 flags;
+	struct sli_epf epf[SLI_LMAC_MAX_PFS];
+	u64 ticks_per_us;
 };
 
 struct slipf_com_s {
@@ -49,4 +89,11 @@ struct slipf_com_s {
 
 extern struct slipf_com_s slipf_com;
 
+static inline void set_sdp_field(u64 *ptr, u64 field_mask,
+				 u8 field_shift, u64 val)
+{
+	*ptr &= ~(field_mask << field_shift);
+	*ptr |= (val & field_mask) << field_shift;
+}
+
 #endif /* __SLI_H__ */
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/slipf_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/slipf_main.c
index ea900c119a35..a13bf9958dfe 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/slipf_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/slipf_main.c
@@ -12,6 +12,7 @@
 #include <linux/random.h>
 
 #include "sli.h"
+#include "rst.h"
 
 #define SLI_DRV_NAME    "octeontx-sli"
 #define SLI_DRV_VERSION "0.1"
@@ -19,17 +20,32 @@
 #define PKI_CHAN_E_SDP_CHX(a) (0x400 + (a))
 
 #define PKO_LMAC_E_SDP   2
-
-static atomic_t sli_count = ATOMIC_INIT(0);
-
 #define SDP_INVALID_ID  (-1)
 
+static struct rst_com_s *rst;
+
 /* Global lists of SDP devices and ports */
 static DEFINE_MUTEX(octeontx_sli_devices_lock);
 static DEFINE_MUTEX(octeontx_sdp_lock);
 static LIST_HEAD(octeontx_sli_devices);
 static LIST_HEAD(octeontx_sdp_ports);
 
+static int poll_for_ep_mode_miss_count;
+struct delayed_work work;
+struct workqueue_struct *ep_mode_handshake;
+
+static u64 get_coproc_clk(u8 node)
+{
+	u64 freq_in_mhz, sclk_freq;
+
+	/* Get SCLK */
+	sclk_freq = rst->get_sclk_freq(node);
+
+	freq_in_mhz = sclk_freq / (1000 * 1000);
+
+	return freq_in_mhz;
+}
+
 /* Register read/write APIs */
 static void sli_reg_write(struct slipf *sli, u64 offset, u64 val)
 {
@@ -56,13 +72,14 @@ static struct slipf *get_sli_dev(int node, int sli_idx)
 }
 
 static struct octtx_sdp_port *get_sdp_port(int domain_id,
-					   int port_idx __maybe_unused)
+					   int port_idx)
 {
 	struct octtx_sdp_port *sdp_port = NULL;
 
 	mutex_lock(&octeontx_sdp_lock);
 	list_for_each_entry(sdp_port, &octeontx_sdp_ports, list) {
-		if ((sdp_port) && (sdp_port->domain_id == domain_id))
+		if ((sdp_port) && (sdp_port->domain_id == domain_id) &&
+		    (sdp_port->dom_port_idx == port_idx))
 			break;
 	}
 	mutex_unlock(&octeontx_sdp_lock);
@@ -199,8 +216,21 @@ int sdp_port_close(struct octtx_sdp_port *port __maybe_unused)
 	return 0;
 }
 
-int sdp_port_start(struct octtx_sdp_port *port __maybe_unused)
+int sdp_port_start(struct octtx_sdp_port *port)
 {
+	int pf_id = port->glb_port_idx >> 8;
+	int vf_id = port->glb_port_idx & 0xff;
+	struct slipf *sli = get_sli_dev(0, 0);
+	u64 reg_val = 0ULL;
+
+	reg_val = sli_reg_read(sli, SLI_EPFX_SCRATCH(pf_id));
+	if (vf_id)
+		reg_val |= 1ULL << vf_id;
+	else
+		reg_val |= 1ULL; /* Bit 0 is to represent PF*/
+
+	sli_reg_write(sli, SLI_EPFX_SCRATCH(pf_id), reg_val);
+
 	return 0;
 }
 
@@ -212,12 +242,25 @@ int sdp_port_stop(struct octtx_sdp_port *port __maybe_unused)
 int sdp_port_config(struct octtx_sdp_port *sdp_port,
 		    struct mbox_sdp_port_conf *conf)
 {
+	struct slipf *sli = get_sli_dev(0, 0);
+	int i = 0;
+	u64 bp_en_val = 0x0ULL;
+
 	conf->node  = sdp_port->node;
 	conf->sdp   = sdp_port->sdp;
 	conf->lmac  = sdp_port->lmac;
 	conf->base_chan = sdp_port->base_chan;
 	conf->num_chans = sdp_port->num_chans;
 
+	sli_reg_write(sli, SDP_OUT_WMARK, 0x100);
+
+	bp_en_val = sli_reg_read(sli, SDP_OUT_BP_ENx_W1S(0));
+	for (i = sdp_port->base_chan - SDP_CHANNEL_START;
+	     i < sdp_port->num_chans; i++) {
+		bp_en_val |= 0x1ULL << i;
+	}
+	sli_reg_write(sli, SDP_OUT_BP_ENx_W1S(0), bp_en_val);
+
 	return 0;
 }
 
@@ -314,7 +357,7 @@ static int sli_create_domain(u32 id, u16 domain_id,
 		}
 	}
 	mutex_unlock(&octeontx_sdp_lock);
-	dev_info(&sli->pdev->dev, "sli domain creation is successful\n");
+	dev_dbg(&sli->pdev->dev, "sli domain creation is successful\n");
 
 	return 0;
 }
@@ -360,28 +403,162 @@ static int sli_reset_domain(u32 id, u16 domain_id)
 static int sli_set_pkind(u32 id, u16 domain_id, int port, int pkind)
 {
 	struct octtx_sdp_port *gport = NULL;
+	u64 reg_val = 0x0ULL;
+	struct slipf *sli = get_sli_dev(0, 0);
 
 	gport = get_sdp_port(domain_id, port);
 	if (!gport)
 		return -ENODEV;
 
-	/* Domain port: */
+	sli_reg_write(sli, SDP_PKIND_VALID, 0x0ULL);
+
+	reg_val = sli_reg_read(sli, SDP_GBL_CONTROL);
+
+	reg_val = 0x1ULL << 3;/* SET PKIPFVAL */
+	set_sdp_field(&reg_val, SDP_GBL_CONTROL_BPKIND_MASK,
+		      SDP_GBL_CONTROL_BPKIND_SHIFT, pkind);
+	sli_reg_write(sli, SDP_GBL_CONTROL, reg_val);
+
 	gport->pkind = pkind;
 
 	return 0;
 }
 
+static void poll_for_ep_mode(struct work_struct *wrk)
+{
+	int i = 0, j = 0;
+	struct slipf *sli = NULL;
+	u64 scratch_addr = 0ULL, scratch_val = 0ULL;
+	struct sli_epf *epf = NULL;
+	struct octtx_sdp_port *sdp_port = NULL;
+	int node = 0;
+	struct list_head *pos, *tmppos;
+
+	sli = get_sli_dev(0, 0);
+
+	for (i = 0; i < SLI_LMAC_MAX_PFS; i++) {
+		epf = &sli->epf[i];
+		if (epf->hs_done)
+			continue;
+
+		scratch_addr = SLI_EPFX_SCRATCH(i);
+		scratch_val = sli_reg_read(sli, scratch_addr);
+		if (scratch_val != SDP_HOST_LOADED) {
+			poll_for_ep_mode_miss_count++;
+		} else {
+			scratch_val = SDP_GET_HOST_INFO;
+			sli_reg_write(sli, scratch_addr, scratch_val);
+
+			/* wait for ep_mode to write the information */
+			while (sli_reg_read(sli, scratch_addr) ==
+			       SDP_GET_HOST_INFO)
+				;
+
+			scratch_val = sli_reg_read(sli, scratch_addr);
+			epf->rpvf = scratch_val & 0xff;
+			epf->vf_srn = (scratch_val >> 8) & 0xff;
+			epf->num_vfs = (scratch_val >> 16) & 0xff;
+			epf->rppf = (scratch_val >> 24) & 0xff;
+			epf->pf_srn = (scratch_val >> 32) & 0xff;
+			epf->app_mode = (scratch_val >> 40) & 0xff;
+
+			scratch_val = (SDP_HOST_INFO_RECEIVED << 16) |
+				      (sli->ticks_per_us & 0xffff);
+			sli_reg_write(sli, scratch_addr, scratch_val);
+
+			/* wait for ep_mode to write the completion */
+			while ((sli_reg_read(sli, scratch_addr) >> 16) ==
+					     SDP_HOST_INFO_RECEIVED)
+				;
+			scratch_val = sli_reg_read(sli, scratch_addr);
+			if (scratch_val == SDP_HANDSHAKE_COMPLETED)
+				epf->hs_done = 1;
+
+			scratch_val = 0x0ULL;
+			sli_reg_write(sli, scratch_addr, scratch_val);
+
+			/* Populate the sdp port for PF */
+			sdp_port = kzalloc(sizeof(*sdp_port), GFP_KERNEL);
+			if (!sdp_port)
+				goto err_free_sdp_ports;
+
+			sdp_port->glb_port_idx = i << 8;
+			sdp_port->sdp = i << 8;
+			sdp_port->node = node;
+			sdp_port->lmac = PKO_LMAC_E_SDP;
+			sdp_port->base_chan = PKI_CHAN_E_SDP_CHX(epf->pf_srn);
+			sdp_port->num_chans = epf->rppf;
+			sdp_port->domain_id = SDP_INVALID_ID;
+			sdp_port->dom_port_idx = SDP_INVALID_ID;
+
+			INIT_LIST_HEAD(&sdp_port->list);
+			mutex_lock(&octeontx_sdp_lock);
+			list_add(&sdp_port->list, &octeontx_sdp_ports);
+			mutex_unlock(&octeontx_sdp_lock);
+			sdp_port = NULL;
+
+			/* Populate the sdp ports for VFs of PF */
+			for (j = 1; j < epf->num_vfs; j++) {
+				sdp_port = kzalloc(sizeof(*sdp_port),
+						   GFP_KERNEL);
+				if (!sdp_port)
+					goto err_free_sdp_ports;
+
+				sdp_port->glb_port_idx = (i << 8) | j;
+				sdp_port->sdp = (i << 8) | j;
+				sdp_port->node = node;
+				sdp_port->lmac = PKO_LMAC_E_SDP;
+				sdp_port->base_chan =
+					PKI_CHAN_E_SDP_CHX(epf->vf_srn +
+							   (j - 1) * epf->rpvf);
+				sdp_port->num_chans = epf->rpvf;
+				sdp_port->domain_id = SDP_INVALID_ID;
+				sdp_port->dom_port_idx = SDP_INVALID_ID;
+
+				INIT_LIST_HEAD(&sdp_port->list);
+				mutex_lock(&octeontx_sdp_lock);
+				list_add(&sdp_port->list, &octeontx_sdp_ports);
+				mutex_unlock(&octeontx_sdp_lock);
+
+				sdp_port = NULL;
+			}
+		}
+	}
+
+	if (poll_for_ep_mode_miss_count > 10)
+		return;
+
+	sli = get_sli_dev(0, 0);
+	for (i = 0; i < SLI_LMAC_MAX_PFS; i++) {
+		epf = &sli->epf[i];
+		if (!epf->hs_done)
+			break;
+	}
+
+	if (i != SLI_LMAC_MAX_PFS)
+		queue_delayed_work(ep_mode_handshake, &work, HZ * 1);
+
+	return;
+err_free_sdp_ports:
+	dev_err(&sli->pdev->dev, "octeontx-sli: sdp port alloc failed!\n");
+	mutex_lock(&octeontx_sdp_lock);
+	list_for_each_safe(pos, tmppos, &octeontx_sdp_ports) {
+		sdp_port = list_entry(pos, struct octtx_sdp_port, list);
+		if (sdp_port) {
+			list_del(pos);
+			kfree(sdp_port);
+		}
+	}
+	mutex_unlock(&octeontx_sdp_lock);
+}
+
 static int sli_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct device *dev = &pdev->dev;
-	struct octtx_sdp_port *sdp_port = NULL;
 	struct slipf *sli = NULL;
 
-	int port_idx;
-	int port_count = 0;
 	int node = 0;
 	int err = 0;
-	struct list_head *pos, *tmppos;
 
 	sli = devm_kzalloc(dev, sizeof(*sli), GFP_KERNEL);
 	if (!sli)
@@ -410,58 +587,23 @@ static int sli_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto err_release_regions;
 	}
 
-	/*set SLI ID */
-	sli->id = atomic_add_return(1, &sli_count);
-	sli->id -= 1;
-
-	sli->port_count = 1;
 	sli->node = node;
 	sli->sli_idx = 0;
 	INIT_LIST_HEAD(&sli->list);
 
-	for (port_idx = 0; port_idx < sli->port_count; port_idx++) {
-		sdp_port = kzalloc(sizeof(*sdp_port), GFP_KERNEL);
-		if (!sdp_port) {
-			err = -ENOMEM;
-			goto err_free_sdp_ports;
-		}
-
-		sdp_port->glb_port_idx = port_idx;
-		sdp_port->sdp = port_idx;
-		sdp_port->node = node;
-		sdp_port->lmac = PKO_LMAC_E_SDP;
-		sdp_port->base_chan = PKI_CHAN_E_SDP_CHX(port_idx);
-		sdp_port->num_chans = 8;
-		sdp_port->domain_id = SDP_INVALID_ID;
-		sdp_port->dom_port_idx = SDP_INVALID_ID;
-
-		INIT_LIST_HEAD(&sdp_port->list);
-		mutex_lock(&octeontx_sdp_lock);
-		list_add(&sdp_port->list, &octeontx_sdp_ports);
-		mutex_unlock(&octeontx_sdp_lock);
-
-		port_count++;
-		sdp_port = NULL;
-	}
+	sli->ticks_per_us = get_coproc_clk(0);
 
+	sli->epf[0].hs_done = 0;
+	ep_mode_handshake = alloc_workqueue("ksli_ep_modefw_hs",
+					    WQ_MEM_RECLAIM, 0);
 	mutex_lock(&octeontx_sli_devices_lock);
 	list_add(&sli->list, &octeontx_sli_devices);
 	mutex_unlock(&octeontx_sli_devices_lock);
+	INIT_DELAYED_WORK(&work, poll_for_ep_mode);
+	queue_delayed_work(ep_mode_handshake, &work, 0);
 
 	return 0;
 
-err_free_sdp_ports:
-	mutex_lock(&octeontx_sdp_lock);
-	list_for_each_safe(pos, tmppos, &octeontx_sdp_ports) {
-		port_idx--;
-		sdp_port = list_entry(pos, struct octtx_sdp_port, list);
-		if ((sdp_port) && (sdp_port->sdp == port_idx)) {
-			list_del(pos);
-			kfree(sdp_port);
-		}
-	}
-	mutex_unlock(&octeontx_sdp_lock);
-
 err_release_regions:
 	if (sli->reg_base)
 		iounmap(sli->reg_base);
@@ -510,6 +652,10 @@ static void sli_remove(struct pci_dev *pdev)
 	}
 	mutex_unlock(&octeontx_sli_devices_lock);
 
+	cancel_delayed_work_sync(&work);
+	flush_workqueue(ep_mode_handshake);
+	destroy_workqueue(ep_mode_handshake);
+
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
@@ -550,6 +696,9 @@ MODULE_DEVICE_TABLE(pci, sli_id_table);
 static int __init sli_init_module(void)
 {
 	pr_info("%s, ver %s\n", SLI_DRV_NAME, SLI_DRV_VERSION);
+	rst = try_then_request_module(symbol_get(rst_com), "rst");
+	if (!rst)
+		return -ENODEV;
 
 	return pci_register_driver(&sli_driver);
 }
@@ -557,6 +706,7 @@ static int __init sli_init_module(void)
 static void __exit sli_cleanup_module(void)
 {
 	pci_unregister_driver(&sli_driver);
+	symbol_put(rst_com);
 }
 
 module_init(sli_init_module);
-- 
2.17.1


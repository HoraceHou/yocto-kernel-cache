From 38751efd9271f192e0b05494377213ee55701598 Mon Sep 17 00:00:00 2001
From: Vidhya Vidhyaraman <Vidhya.Raman@cavium.com>
Date: Mon, 28 Jan 2019 15:03:52 -0800
Subject: [PATCH 0913/1051] soc: octeontx2: Fix for SMQ flush stall

The SMQ flush operation may stall if the
downstream TL3/TL2 queue is backpressured from
CGX due to incoming traffic being received
continuously during flush operation.This commit
fixes the issue by disabling the backpressure

Change-Id: If7556255609beff3d0379fc69bccfdc93ed7b3ce
Signed-off-by: Vidhya Vidhyaraman <Vidhya.Raman@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/2868
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/octeontx2/cgx.c     | 28 +++++++++++++++++++++++++
 drivers/soc/marvell/octeontx2/cgx.h     |  3 +++
 drivers/soc/marvell/octeontx2/rvu.h     |  1 +
 drivers/soc/marvell/octeontx2/rvu_cgx.c | 13 ++++++++++++
 drivers/soc/marvell/octeontx2/rvu_nix.c | 23 ++++++++++++++++++++
 5 files changed, 68 insertions(+)

diff --git a/drivers/soc/marvell/octeontx2/cgx.c b/drivers/soc/marvell/octeontx2/cgx.c
index 1481a5b3ba9b..f4c203308614 100644
--- a/drivers/soc/marvell/octeontx2/cgx.c
+++ b/drivers/soc/marvell/octeontx2/cgx.c
@@ -300,6 +300,34 @@ void cgx_lmac_promisc_config(int cgx_id, int lmac_id, bool enable)
 }
 EXPORT_SYMBOL(cgx_lmac_promisc_config);
 
+void cgx_lmac_bp_config(void *cgxd, int lmac_id, bool enable)
+{
+	struct cgx *cgx = cgxd;
+	u64 cfg;
+
+	if (!cgx)
+		return;
+
+	if (enable) {
+		cfg = cgx_read(cgx, lmac_id, CGXX_GMP_GMI_RXX_FRM_CTL);
+		cfg |= CGX_GMP_GMI_RXX_FRM_CTL_CTL_BCK;
+		cgx_write(cgx, lmac_id, CGXX_GMP_GMI_RXX_FRM_CTL, cfg);
+
+		cfg = cgx_read(cgx, lmac_id, CGXX_SMUX_RX_FRM_CTL);
+		cfg |= CGX_SMUX_RX_FRM_CTL_CTL_BCK;
+		cgx_write(cgx, lmac_id,	CGXX_SMUX_RX_FRM_CTL, cfg);
+	} else {
+		cfg = cgx_read(cgx, lmac_id, CGXX_GMP_GMI_RXX_FRM_CTL);
+		cfg &= ~CGX_GMP_GMI_RXX_FRM_CTL_CTL_BCK;
+		cgx_write(cgx, lmac_id, CGXX_GMP_GMI_RXX_FRM_CTL, cfg);
+
+		cfg = cgx_read(cgx, lmac_id, CGXX_SMUX_RX_FRM_CTL);
+		cfg &= ~CGX_SMUX_RX_FRM_CTL_CTL_BCK;
+		cgx_write(cgx, lmac_id,	CGXX_SMUX_RX_FRM_CTL, cfg);
+	}
+}
+EXPORT_SYMBOL(cgx_lmac_bp_config);
+
 void cgx_lmac_ptp_config(void *cgxd, int lmac_id, bool enable)
 {
 	struct cgx *cgx = cgxd;
diff --git a/drivers/soc/marvell/octeontx2/cgx.h b/drivers/soc/marvell/octeontx2/cgx.h
index a89fe3b4499e..73b2c9280a70 100644
--- a/drivers/soc/marvell/octeontx2/cgx.h
+++ b/drivers/soc/marvell/octeontx2/cgx.h
@@ -55,10 +55,12 @@
 #define CGXX_SPUX_CONTROL1_LBK		BIT_ULL(14)
 #define CGXX_SMUX_RX_FRM_CTL		0x20020
 #define CGX_SMUX_RX_FRM_CTL_PTP_MODE	BIT_ULL(12)
+#define CGX_SMUX_RX_FRM_CTL_CTL_BCK	BIT_ULL(3)
 #define CGXX_GMP_PCS_MRX_CTL		0x30000
 #define CGXX_GMP_PCS_MRX_CTL_LBK	BIT_ULL(14)
 #define CGXX_GMP_GMI_RXX_FRM_CTL		0x38028
 #define CGX_GMP_GMI_RXX_FRM_CTL_PTP_MODE	BIT_ULL(12)
+#define CGX_GMP_GMI_RXX_FRM_CTL_CTL_BCK	BIT_ULL(3)
 
 #define CGX_COMMAND_REG			CGXX_SCRATCH1_REG
 #define CGX_EVENT_REG			CGXX_SCRATCH0_REG
@@ -111,6 +113,7 @@ u64 cgx_lmac_addr_get(u8 cgx_id, u8 lmac_id);
 int cgx_get_pfmacaddr(void *cgxd, u8 lmac_id, u8 *macdst);
 void cgx_lmac_promisc_config(int cgx_id, int lmac_id, bool enable);
 void cgx_lmac_ptp_config(void *cgxd, int lmac_id, bool enable);
+void cgx_lmac_bp_config(void *cgxd, int lmac_id, bool enable);
 int cgx_lmac_internal_loopback(void *cgxd, int lmac_id, bool enable);
 int cgx_get_link_info(void *cgxd, int lmac_id, struct cgx_link_user_info
 			*linfo);
diff --git a/drivers/soc/marvell/octeontx2/rvu.h b/drivers/soc/marvell/octeontx2/rvu.h
index cd3b2e977eb0..1ae986181ce0 100644
--- a/drivers/soc/marvell/octeontx2/rvu.h
+++ b/drivers/soc/marvell/octeontx2/rvu.h
@@ -393,6 +393,7 @@ static inline void rvu_get_cgx_lmac_id(u8 map, u8 *cgx_id, u8 *lmac_id)
 	*lmac_id = (map & 0xF);
 }
 
+void rvu_cgx_config_bp(struct rvu *rvu, u8 cgx_id, u8 lmac_id, bool enable);
 int rvu_cgx_init(struct rvu *rvu);
 int rvu_cgx_exit(struct rvu *rvu);
 int rvu_check_cgx_driver(struct rvu *rvu);
diff --git a/drivers/soc/marvell/octeontx2/rvu_cgx.c b/drivers/soc/marvell/octeontx2/rvu_cgx.c
index 225587edcfdf..cd32fcfbda82 100644
--- a/drivers/soc/marvell/octeontx2/rvu_cgx.c
+++ b/drivers/soc/marvell/octeontx2/rvu_cgx.c
@@ -503,6 +503,19 @@ int rvu_mbox_handler_cgx_promisc_disable(struct rvu *rvu, struct msg_req *req,
 	return 0;
 }
 
+void rvu_cgx_config_bp(struct rvu *rvu, u8 cgx_id, u8 lmac_id, bool enable)
+{
+	void *cgxd;
+
+	if (enable) {
+		cgxd = rvu_cgx_pdata(cgx_id, rvu);
+		cgx_lmac_bp_config(cgxd, lmac_id, true);
+	} else {
+		cgxd = rvu_cgx_pdata(cgx_id, rvu);
+		cgx_lmac_bp_config(cgxd, lmac_id, false);
+	}
+}
+
 int rvu_mbox_handler_cgx_ptp_rx_enable(struct rvu *rvu, struct msg_req *req,
 				       struct msg_rsp *rsp)
 {
diff --git a/drivers/soc/marvell/octeontx2/rvu_nix.c b/drivers/soc/marvell/octeontx2/rvu_nix.c
index f6319fe8cd30..e2cc77842bb1 100644
--- a/drivers/soc/marvell/octeontx2/rvu_nix.c
+++ b/drivers/soc/marvell/octeontx2/rvu_nix.c
@@ -1257,7 +1257,9 @@ static int nix_txschq_free(struct rvu *rvu, u16 pcifunc)
 	struct nix_txsch *txsch;
 	struct nix_hw *nix_hw;
 	u64 cfg;
+	int pf;
 
+	pf = rvu_get_pf(pcifunc);
 	blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NIX, pcifunc);
 	if (blkaddr < 0)
 		return NIX_AF_ERR_AF_LF_INVALID;
@@ -1295,12 +1297,33 @@ static int nix_txschq_free(struct rvu *rvu, u16 pcifunc)
 		rvu_write64(rvu, blkaddr, NIX_AF_SMQX_CFG(schq), cfg);
 
 		/* Wait for flush to complete */
+		err = rvu_poll_reg(rvu, blkaddr,
+				   NIX_AF_SMQX_CFG(schq), BIT_ULL(49), true);
+		if (err) {
+			/* Clear CTL_BCK and try again */
+			if (is_pf_cgxmapped(rvu, pf)) {
+				u8 cgx_id, lmac_id;
+
+				rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf],
+						&cgx_id, &lmac_id);
+				rvu_cgx_config_bp(rvu, cgx_id, lmac_id, false);
+			}
+		}
+
 		err = rvu_poll_reg(rvu, blkaddr,
 				   NIX_AF_SMQX_CFG(schq), BIT_ULL(49), true);
 		if (err) {
 			dev_err(rvu->dev,
 				"NIXLF%d: SMQ%d flush failed\n", nixlf, schq);
 		}
+		if (is_pf_cgxmapped(rvu, pf)) {
+			u8 cgx_id, lmac_id;
+
+		    rvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf],
+					&cgx_id, &lmac_id);
+			rvu_cgx_config_bp(rvu, cgx_id, lmac_id, true);
+		}
+
 	}
 
 	/* Now free scheduler queues to free pool */
-- 
2.17.1


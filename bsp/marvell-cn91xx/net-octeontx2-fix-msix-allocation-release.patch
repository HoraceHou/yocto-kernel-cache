From 9fc77a98b66a910efec15a1cb2a88719e5a5ce14 Mon Sep 17 00:00:00 2001
From: Aleksey Makarov <amakarov@marvell.com>
Date: Wed, 12 Sep 2018 12:42:57 +0300
Subject: [PATCH 0191/1051] net: octeontx2: fix msix allocation/release

This fixes kernel oops in otx2_disable_msix().  For this function to work
correctly it should be called when nix_msixoff is set.  It is not true
in every error path.

Split the pair of functions otx2_enable_msix()/otx2_disable_msix() into two
parts:

1.
- Allocation of memory for irq_name and affinity_mask
- pci_alloc_irq_vectors()
- Initialization of MBOX interrupt

These can be done in the _probe() function and undone in _release() so for
memory allocation we can use the functions for managed allocation.
Also this means that MBOX interrupt is functional for the whole life time
of the driver.  That allows to get rid of otx2_hw->num_vec and therefore
of otx2_nic->set_mac_pending.

2.
- Request/free of CINTs.

This should be done in _open()/_stop().  Requesting was at _open()
initially so free_irq() was moved to otx2_free_cints()

Some small improvements have also been done:

- pci_enable_device() -> pcim_enable_device()
- sprintf() -> snprintf()
- shorten some expressions by using a local variable for interrupt name
  at some place

Signed-off-by: Aleksey Makarov <amakarov@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/otx2_common.c  | 100 ++-------------
 .../ethernet/marvell/octeontx2/otx2_common.h  |  10 +-
 .../net/ethernet/marvell/octeontx2/otx2_pf.c  | 114 +++++++++---------
 .../net/ethernet/marvell/octeontx2/otx2_vf.c  |  59 ++++-----
 4 files changed, 100 insertions(+), 183 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index 728caf41652b..5a48580d4859 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -45,16 +45,7 @@ int otx2_set_mac_address(struct net_device *netdev, void *p)
 
 	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
 
-	/* If mbox irq (i.e MSIX) is disabled then mark this
-	 * change as pending and return, AF will be synced
-	 * once irqs are re-enabled.
-	 */
-	if (pfvf->hw.num_vec) {
-		if (otx2_hw_set_mac_addr(pfvf, netdev))
-			return -EBUSY;
-	} else {
-		pfvf->set_mac_pending = true;
-	}
+	otx2_hw_set_mac_addr(pfvf, netdev);
 
 	return 0;
 }
@@ -64,9 +55,6 @@ int otx2_hw_set_mtu(struct otx2_nic *pfvf, int mtu)
 {
 	struct nix_frs_cfg *req;
 
-	if (!pfvf->hw.num_vec)
-		return -EINVAL;
-
 	req = otx2_mbox_alloc_msg_NIX_SET_HW_FRS(&pfvf->mbox);
 	if (!req)
 		return -ENOMEM;
@@ -275,7 +263,7 @@ void otx2_get_stats64(struct net_device *netdev,
 }
 EXPORT_SYMBOL(otx2_get_stats64);
 
-void otx2_set_irq_affinity(struct otx2_nic *pfvf)
+void otx2_set_cints_affinity(struct otx2_nic *pfvf)
 {
 	struct otx2_hw *hw = &pfvf->hw;
 	int vec, cpu, irq, cint;
@@ -285,9 +273,6 @@ void otx2_set_irq_affinity(struct otx2_nic *pfvf)
 
 	/* CQ interrupts */
 	for (cint = 0; cint < pfvf->hw.cint_cnt; cint++, vec++) {
-		if (!hw->irq_allocated[vec])
-			continue;
-
 		if (!alloc_cpumask_var(&hw->affinity_mask[vec], GFP_KERNEL))
 			return;
 
@@ -1123,11 +1108,7 @@ void mbox_handler_NIX_LF_ALLOC(struct otx2_nic *pfvf,
 	pfvf->hw.sqb_size = rsp->sqb_size;
 	pfvf->rx_chan_base = rsp->rx_chan_base;
 	pfvf->tx_chan_base = rsp->tx_chan_base;
-	/* If a MAC address change is pending then don't
-	 * overwrite 'netdev->dev_addr'.
-	 */
-	if (!pfvf->set_mac_pending)
-		ether_addr_copy(pfvf->netdev->dev_addr, rsp->mac_addr);
+	ether_addr_copy(pfvf->netdev->dev_addr, rsp->mac_addr);
 	pfvf->hw.lso_tsov4_idx = rsp->lso_tsov4_idx;
 	pfvf->hw.lso_tsov6_idx = rsp->lso_tsov6_idx;
 }
@@ -1141,76 +1122,19 @@ void mbox_handler_MSIX_OFFSET(struct otx2_nic *pfvf,
 }
 EXPORT_SYMBOL(mbox_handler_MSIX_OFFSET);
 
-void otx2_disable_msix(struct otx2_nic *pfvf)
+void otx2_free_cints(struct otx2_nic *pfvf, int n)
 {
 	struct otx2_qset *qset = &pfvf->qset;
 	struct otx2_hw *hw = &pfvf->hw;
-	int irq, qidx = 0;
-
-	if (!hw->irq_allocated)
-		goto freemem;
-
-	/* Free all registered IRQ handlers */
-	for (irq = 0; irq < hw->num_vec; irq++) {
-		if (!hw->irq_allocated[irq])
-			continue;
-		if (irq < (hw->nix_msixoff + NIX_LF_CINT_VEC_START)) {
-			free_irq(pci_irq_vector(pfvf->pdev, irq), pfvf);
-		} else {
-			irq_set_affinity_hint(pci_irq_vector(pfvf->pdev, irq),
-					      NULL);
-			free_cpumask_var(hw->affinity_mask[irq]);
-			free_irq(pci_irq_vector(pfvf->pdev, irq),
-				 &qset->napi[qidx++]);
-		}
-	}
+	int irq, qidx;
 
-	pci_free_irq_vectors(hw->pdev);
+	for (qidx = 0, irq = hw->nix_msixoff + NIX_LF_CINT_VEC_START;
+	     qidx < n;
+	     qidx++, irq++) {
+		int vector = pci_irq_vector(pfvf->pdev, irq);
 
-freemem:
-	hw->num_vec = 0;
-	kfree(hw->affinity_mask);
-	kfree(hw->irq_allocated);
-	kfree(hw->irq_name);
-	hw->irq_allocated = NULL;
-	hw->irq_name = NULL;
-}
-EXPORT_SYMBOL(otx2_disable_msix);
-
-int otx2_enable_msix(struct otx2_hw *hw)
-{
-	int ret = -ENOMEM;
-
-	hw->num_vec = pci_msix_vec_count(hw->pdev);
-
-	hw->irq_name = kmalloc_array(hw->num_vec, NAME_SIZE, GFP_KERNEL);
-	if (!hw->irq_name)
-		return -ENOMEM;
-
-	hw->irq_allocated = kcalloc(hw->num_vec, sizeof(bool), GFP_KERNEL);
-	if (!hw->irq_allocated)
-		goto freemem;
-
-	hw->affinity_mask = kcalloc(hw->num_vec, sizeof(cpumask_var_t),
-				    GFP_KERNEL);
-	if (!hw->affinity_mask)
-		goto freemem;
-
-	/* Enable MSI-X */
-	ret = pci_alloc_irq_vectors(hw->pdev, hw->num_vec, hw->num_vec,
-				    PCI_IRQ_MSIX);
-	if (ret < 0) {
-		dev_err(&hw->pdev->dev,
-			"Request for #%d msix vectors failed, ret %d\n",
-			hw->num_vec, ret);
-		goto freemem;
+		irq_set_affinity_hint(vector, NULL);
+		free_cpumask_var(hw->affinity_mask[irq]);
+		free_irq(vector, &qset->napi[qidx]);
 	}
-
-	return 0;
-freemem:
-	kfree(hw->affinity_mask);
-	kfree(hw->irq_allocated);
-	kfree(hw->irq_name);
-	return ret;
 }
-EXPORT_SYMBOL(otx2_enable_msix);
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index 33e8e7a15da3..2c04249cd03a 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -109,10 +109,8 @@ struct otx2_hw {
 	u16			sqb_size;
 
 	/* MSI-X*/
-	u16			num_vec;
 	u16			npa_msixoff; /* Offset of NPA vectors */
 	u16			nix_msixoff; /* Offset of NIX vectors */
-	bool			*irq_allocated;
 	char			*irq_name;
 	cpumask_var_t           *affinity_mask;
 
@@ -140,15 +138,12 @@ struct otx2_nic {
 	struct mbox		mbox;
 	struct workqueue_struct *mbox_wq;
 	bool			intf_down;
-	bool			set_mac_pending;
 	u16			pcifunc;
 	u16			rx_chan_base;
 	u16			tx_chan_base;
 	u8			cq_time_wait;
 	u32			cq_ecount_wait;
 	struct work_struct	reset_task;
-
-	int (*register_mbox_intr)(struct otx2_nic *);
 };
 
 /* Register read/write APIs */
@@ -283,8 +278,8 @@ static inline int rvu_get_pf(u16 pcifunc)
 }
 
 /* MSI-X APIs */
-int otx2_enable_msix(struct otx2_hw *hw);
-void otx2_disable_msix(struct otx2_nic *pfvf);
+void otx2_free_cints(struct otx2_nic *pfvf, int n);
+void otx2_set_cints_affinity(struct otx2_nic *pfvf);
 
 /* RVU block related APIs */
 int otx2_attach_npa_nix(struct otx2_nic *pfvf);
@@ -308,7 +303,6 @@ int otx2_napi_handler(struct otx2_cq_queue *cq,
 void otx2_get_dev_stats(struct otx2_nic *pfvf);
 void otx2_get_stats64(struct net_device *netdev,
 		      struct rtnl_link_stats64 *stats);
-void otx2_set_irq_affinity(struct otx2_nic *pfvf);
 int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, struct net_device *netdev);
 int otx2_set_mac_address(struct net_device *netdev, void *p);
 int otx2_change_mtu(struct net_device *netdev, int new_mtu);
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 84711af50e34..2e882ef580a4 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -238,32 +238,23 @@ static int otx2_register_mbox_intr(struct otx2_nic *pf)
 	struct otx2_hw *hw = &pf->hw;
 	struct msg_req *req;
 	struct mbox_msghdr *rsp_hdr;
+	char *irq_name;
 	int err;
 
-	/* Skip if MSIX is already initialized */
-	if (hw->num_vec)
-		return 0;
-
-	/* Enable MSI-X */
-	err = otx2_enable_msix(hw);
-	if (err)
-		return err;
-
 	/* Register mailbox interrupt handler */
-	sprintf(&hw->irq_name[RVU_PF_INT_VEC_AFPF_MBOX * NAME_SIZE],
-		"RVUPFAF Mbox");
-	err = request_irq(pci_irq_vector(pf->pdev, RVU_PF_INT_VEC_AFPF_MBOX),
-			  otx2_pfaf_mbox_intr_handler, 0,
-			  &hw->irq_name[RVU_PF_INT_VEC_AFPF_MBOX * NAME_SIZE],
-			  pf);
+	irq_name = &hw->irq_name[RVU_PF_INT_VEC_AFPF_MBOX * NAME_SIZE];
+	snprintf(irq_name, NAME_SIZE, "RVUPFAF Mbox");
+	err = devm_request_irq(pf->dev,
+			       pci_irq_vector(pf->pdev,
+					      RVU_PF_INT_VEC_AFPF_MBOX),
+			       otx2_pfaf_mbox_intr_handler, 0,
+			       irq_name, pf);
 	if (err) {
 		dev_err(pf->dev,
 			"RVUPF: IRQ registration failed for PFAF mbox irq\n");
 		return err;
 	}
 
-	hw->irq_allocated[RVU_PF_INT_VEC_AFPF_MBOX] = true;
-
 	/* Enable mailbox interrupt for msgs coming from AF.
 	 * First clear to avoid spurious interrupts, if any.
 	 */
@@ -591,10 +582,6 @@ int otx2_open(struct net_device *netdev)
 
 	netif_carrier_off(netdev);
 
-	err = pf->register_mbox_intr(pf);
-	if (err)
-		return err;
-
 	pf->qset.cq_cnt = pf->hw.rx_queues + pf->hw.tx_queues;
 	/* RQ and SQs are mapped to different CQs,
 	 * so find out max CQ IRQs (i.e CINTs) needed.
@@ -611,21 +598,21 @@ int otx2_open(struct net_device *netdev)
 	qset->cq = kcalloc(pf->qset.cq_cnt,
 			   sizeof(struct otx2_cq_queue), GFP_KERNEL);
 	if (!qset->cq)
-		goto freemem;
+		goto err_free_mem;
 
 	qset->sq = kcalloc(pf->hw.tx_queues,
 			   sizeof(struct otx2_snd_queue), GFP_KERNEL);
 	if (!qset->sq)
-		goto freemem;
+		goto err_free_mem;
 
 	qset->rq = kcalloc(pf->hw.rx_queues,
 			   sizeof(struct otx2_rcv_queue), GFP_KERNEL);
 	if (!qset->rq)
-		goto freemem;
+		goto err_free_mem;
 
 	err = otx2_init_hw_resources(pf);
 	if (err)
-		goto freemem;
+		goto err_free_mem;
 
 	/* Register NAPI handler */
 	for (qidx = 0; qidx < pf->hw.cint_cnt; qidx++) {
@@ -650,39 +637,31 @@ int otx2_open(struct net_device *netdev)
 		eth_hw_addr_random(netdev);
 		err = otx2_hw_set_mac_addr(pf, netdev);
 		if (err)
-			goto cleanup;
-	}
-
-	/* Sync new MAC address to AF, if a change is pending */
-	if (pf->set_mac_pending) {
-		err = otx2_hw_set_mac_addr(pf, netdev);
-		if (err)
-			goto cleanup;
-		pf->set_mac_pending = false;
+			goto err_disable_napi;
 	}
 
 	/* Set default MTU in HW */
 	err = otx2_hw_set_mtu(pf, netdev->mtu);
 	if (err)
-		goto cleanup;
+		goto err_disable_napi;
 
 	/* Register CQ IRQ handlers */
 	vec = pf->hw.nix_msixoff + NIX_LF_CINT_VEC_START;
 	for (qidx = 0; qidx < pf->hw.cint_cnt; qidx++) {
-		sprintf(&pf->hw.irq_name[vec * NAME_SIZE], "%s-rxtx-%d",
-			pf->netdev->name, qidx);
+		char *irq_name = &pf->hw.irq_name[vec * NAME_SIZE];
+
+		snprintf(irq_name, NAME_SIZE, "%s-rxtx-%d", pf->netdev->name,
+			 qidx);
 
 		err = request_irq(pci_irq_vector(pf->pdev, vec),
-				  otx2_cq_intr_handler, 0,
-				  &pf->hw.irq_name[vec * NAME_SIZE],
+				  otx2_cq_intr_handler, 0, irq_name,
 				  &qset->napi[qidx]);
 		if (err) {
 			dev_err(pf->dev,
 				"RVUPF%d: IRQ registration failed for CQ%d\n",
 				rvu_get_pf(pf->pcifunc), qidx);
-			goto cleanup;
+			goto err_free_cints;
 		}
-		pf->hw.irq_allocated[vec] = true;
 		vec++;
 
 		/* Configure CQE interrupt coalescing parameters */
@@ -695,11 +674,11 @@ int otx2_open(struct net_device *netdev)
 		otx2_write64(pf, NIX_LF_CINTX_ENA_W1S(qidx), BIT_ULL(0));
 	}
 
-	otx2_set_irq_affinity(pf);
+	otx2_set_cints_affinity(pf);
 
 	err = otx2_rxtx_enable(pf, true);
 	if (err)
-		goto cleanup;
+		goto err_free_cints;
 
 	pf->intf_down = false;
 
@@ -707,10 +686,11 @@ int otx2_open(struct net_device *netdev)
 	otx2_cgx_config_linkevents(pf, true);
 	return 0;
 
-cleanup:
+err_free_cints:
+	otx2_free_cints(pf, qidx);
+err_disable_napi:
 	otx2_disable_napi(pf);
-	otx2_disable_msix(pf);
-freemem:
+err_free_mem:
 	kfree(qset->sq);
 	kfree(qset->cq);
 	kfree(qset->napi);
@@ -753,7 +733,7 @@ int otx2_stop(struct net_device *netdev)
 
 	netif_tx_disable(netdev);
 	otx2_free_hw_resources(pf);
-	otx2_disable_msix(pf);
+	otx2_free_cints(pf, pf->hw.cint_cnt);
 
 	otx2_disable_napi(pf);
 
@@ -834,8 +814,9 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	struct otx2_nic *pf;
 	struct otx2_hw *hw;
 	int    err, qcount;
+	int    num_vec = pci_msix_vec_count(pdev);
 
-	err = pci_enable_device(pdev);
+	err = pcim_enable_device(pdev);
 	if (err) {
 		dev_err(dev, "Failed to enable PCI device\n");
 		return err;
@@ -844,7 +825,7 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	err = pci_request_regions(pdev, DRV_NAME);
 	if (err) {
 		dev_err(dev, "PCI request regions failed 0x%x\n", err);
-		goto err_disable_device;
+		return err;
 	}
 
 	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(48));
@@ -883,32 +864,44 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	hw->max_queues = qcount;
 	hw->rqpool_cnt = qcount;
 
-	pf->register_mbox_intr = otx2_register_mbox_intr;
+	hw->irq_name = devm_kmalloc_array(&hw->pdev->dev, num_vec, NAME_SIZE,
+					  GFP_KERNEL);
+	if (!hw->irq_name)
+		goto err_free_netdev;
+
+	hw->affinity_mask = devm_kcalloc(&hw->pdev->dev, num_vec,
+					 sizeof(cpumask_var_t), GFP_KERNEL);
+	if (!hw->affinity_mask)
+		goto err_free_netdev;
+
+	err = pci_alloc_irq_vectors(hw->pdev, num_vec, num_vec, PCI_IRQ_MSIX);
+	if (err < 0)
+		goto err_free_netdev;
 
 	/* Map CSRs */
 	pf->reg_base = pcim_iomap(pdev, PCI_CFG_REG_BAR_NUM, 0);
 	if (!pf->reg_base) {
 		dev_err(dev, "Unable to map physical function CSRs, aborting\n");
 		err = -ENOMEM;
-		goto err_free_netdev;
+		goto err_free_irq_vectors;
 	}
 
 	/* Init PF <=> AF mailbox stuff */
 	err = otx2_pfaf_mbox_init(pf);
 	if (err)
-		goto err_free_netdev;
+		goto err_free_irq_vectors;
 
 	/* Register mailbox interrupt */
 	err = otx2_register_mbox_intr(pf);
 	if (err)
-		goto err_irq;
+		goto err_mbox_destroy;
 
 	/* Request AF to attach NPA and NIX LFs to this PF.
 	 * NIX and NPA LFs are needed for this PF to function as a NIC.
 	 */
 	err = otx2_attach_npa_nix(pf);
 	if (err)
-		goto err_irq;
+		goto err_disable_mbox_intr;
 
 	err = otx2_set_real_num_queues(netdev, hw->tx_queues, hw->rx_queues);
 	if (err)
@@ -960,16 +953,17 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 err_detach_rsrc:
 	otx2_detach_resources(&pf->mbox);
-err_irq:
-	otx2_disable_msix(pf);
+err_disable_mbox_intr:
+	otx2_disable_mbox_intr(pf);
+err_mbox_destroy:
 	otx2_pfaf_mbox_destroy(pf);
+err_free_irq_vectors:
+	pci_free_irq_vectors(hw->pdev);
 err_free_netdev:
 	pci_set_drvdata(pdev, NULL);
 	free_netdev(netdev);
 err_release_regions:
 	pci_release_regions(pdev);
-err_disable_device:
-	pci_disable_device(pdev);
 	return err;
 }
 
@@ -985,15 +979,15 @@ static void otx2_remove(struct pci_dev *pdev)
 	unregister_netdev(netdev);
 
 	otx2_disable_mbox_intr(pf);
-	otx2_disable_msix(pf);
+
 	otx2_detach_resources(&pf->mbox);
 	otx2_pfaf_mbox_destroy(pf);
 
+	pci_free_irq_vectors(pf->pdev);
 	pci_set_drvdata(pdev, NULL);
 	free_netdev(netdev);
 
 	pci_release_regions(pdev);
-	pci_disable_device(pdev);
 }
 
 static struct pci_driver otx2_pf_driver = {
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c
index c62c4308c10c..16131b5bbe8b 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c
@@ -151,28 +151,18 @@ static int otx2vf_register_mbox_intr(struct otx2_nic *vf)
 	char *irq_name;
 	int err;
 
-	/* Skip if MSIX is already initialized */
-	if (hw->num_vec)
-		return 0;
-
-	/* Enable MSI-X */
-	err = otx2_enable_msix(hw);
-	if (err)
-		return err;
-
 	/* Register mailbox interrupt handler */
 	irq_name = &hw->irq_name[RVU_VF_INT_VEC_MBOX * NAME_SIZE];
-	sprintf(irq_name, "RVUVFAF Mbox");
-	err = request_irq(pci_irq_vector(vf->pdev, RVU_VF_INT_VEC_MBOX),
-			  otx2vf_vfaf_mbox_intr_handler, 0, irq_name, vf);
+	snprintf(irq_name, NAME_SIZE, "RVUVFAF Mbox");
+	err = devm_request_irq(vf->dev,
+			       pci_irq_vector(vf->pdev, RVU_VF_INT_VEC_MBOX),
+			       otx2vf_vfaf_mbox_intr_handler, 0, irq_name, vf);
 	if (err) {
 		dev_err(vf->dev,
 			"RVUPF: IRQ registration failed for VFAF mbox irq\n");
 		return err;
 	}
 
-	hw->irq_allocated[RVU_VF_INT_VEC_MBOX] = true;
-
 	/* Enable mailbox interrupt for msgs coming from PF.
 	 * First clear to avoid spurious interrupts, if any.
 	 */
@@ -361,8 +351,9 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	struct otx2_nic *vf;
 	struct otx2_hw *hw;
 	int err, qcount, n;
+	int num_vec = pci_msix_vec_count(pdev);
 
-	err = pci_enable_device(pdev);
+	err = pcim_enable_device(pdev);
 	if (err) {
 		dev_err(dev, "Failed to enable PCI device\n");
 		return err;
@@ -371,7 +362,7 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	err = pci_request_regions(pdev, DRV_NAME);
 	if (err) {
 		dev_err(dev, "PCI request regions failed 0x%x\n", err);
-		goto err_disable_device;
+		return err;
 	}
 
 	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(48));
@@ -402,7 +393,6 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	vf->pdev = pdev;
 	vf->dev = dev;
 	vf->iommu_domain = iommu_get_domain_for_dev(dev);
-	vf->register_mbox_intr = otx2vf_register_mbox_intr;
 	hw = &vf->hw;
 	hw->pdev = vf->pdev;
 	hw->rx_queues = qcount;
@@ -410,27 +400,41 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	hw->max_queues = qcount;
 	hw->rqpool_cnt = qcount;
 
+	hw->irq_name = devm_kmalloc_array(&hw->pdev->dev, num_vec, NAME_SIZE,
+					  GFP_KERNEL);
+	if (!hw->irq_name)
+		goto err_free_netdev;
+
+	hw->affinity_mask = devm_kcalloc(&hw->pdev->dev, num_vec,
+					 sizeof(cpumask_var_t), GFP_KERNEL);
+	if (!hw->affinity_mask)
+		goto err_free_netdev;
+
+	err = pci_alloc_irq_vectors(hw->pdev, num_vec, num_vec, PCI_IRQ_MSIX);
+	if (err < 0)
+		goto err_free_netdev;
+
 	vf->reg_base = pcim_iomap(pdev, PCI_CFG_REG_BAR_NUM, 0);
 	if (!vf->reg_base) {
 		dev_err(dev, "Unable to map physical function CSRs, aborting\n");
 		err = -ENOMEM;
-		goto err_free_netdev;
+		goto err_free_irq_vectors;
 	}
 
 	/* Init VF <=> PF mailbox stuff */
 	err = otx2vf_vfaf_mbox_init(vf);
 	if (err)
-		goto err_free_netdev;
+		goto err_free_irq_vectors;
 
 	/* Register mailbox interrupt */
 	err = otx2vf_register_mbox_intr(vf);
 	if (err)
-		goto err_irq;
+		goto err_mbox_destroy;
 
 	/* Request AF to attach NPA and LIX LFs to this AF */
 	err = otx2_attach_npa_nix(vf);
 	if (err)
-		goto err_irq;
+		goto err_disable_mbox_intr;
 
 	err = otx2_set_real_num_queues(netdev, qcount, qcount);
 	if (err)
@@ -467,16 +471,17 @@ static int otx2vf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 err_detach_rsrc:
 	otx2_detach_resources(&vf->mbox);
-err_irq:
-	otx2_disable_msix(vf);
+err_disable_mbox_intr:
+	otx2vf_disable_mbox_intr(vf);
+err_mbox_destroy:
 	otx2vf_vfaf_mbox_destroy(vf);
+err_free_irq_vectors:
+	pci_free_irq_vectors(hw->pdev);
 err_free_netdev:
 	pci_set_drvdata(pdev, NULL);
 	free_netdev(netdev);
 err_release_regions:
 	pci_release_regions(pdev);
-err_disable_device:
-	pci_disable_device(pdev);
 	return err;
 }
 
@@ -492,15 +497,15 @@ static void otx2vf_remove(struct pci_dev *pdev)
 	unregister_netdev(netdev);
 
 	otx2vf_disable_mbox_intr(vf);
-	otx2_disable_msix(vf);
+
 	otx2_detach_resources(&vf->mbox);
 	otx2vf_vfaf_mbox_destroy(vf);
 
+	pci_free_irq_vectors(vf->pdev);
 	pci_set_drvdata(pdev, NULL);
 	free_netdev(netdev);
 
 	pci_release_regions(pdev);
-	pci_disable_device(pdev);
 }
 
 static struct pci_driver otx2vf_driver = {
-- 
2.17.1


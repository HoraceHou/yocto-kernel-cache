From 56d84a06a69e19368d34534c38317fbdfe0c8f2f Mon Sep 17 00:00:00 2001
From: Grzegorz Jaszczyk <jaz@semihalf.com>
Date: Thu, 21 Feb 2019 10:26:05 +0100
Subject: [PATCH 1027/1051] phy: mvebu-cp110-comphy: convert for using both phy
 mode and submode

Convert existing comphy-cp110 driver to use both mode and submode.
Also update marvell network driver accordingly and use recently
introduced PHY_MODE_ETHERNET.

Change-Id: I4582882b74102a339961b3d2f8d911cf3567a97d
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-on: https://sj1git1.cavium.com/4401
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Stefan Chulski <Stefan.Chulski@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/marvell/mvneta.c         |  16 +--
 .../net/ethernet/marvell/mvpp2/mvpp2_main.c   |  19 +--
 drivers/phy/marvell/phy-mvebu-cp110-comphy.c  | 111 ++++++++++++------
 3 files changed, 78 insertions(+), 68 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 6141c26d4506..bc6e90c080d2 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -3193,25 +3193,13 @@ static int mvneta_setup_txqs(struct mvneta_port *pp)
  */
 static int mvneta_comphy_init(struct mvneta_port *pp)
 {
-	enum phy_mode mode;
 	int ret;
 
 	if (!pp->comphy)
 		return 0;
 
-	switch (pp->phy_interface) {
-	case PHY_INTERFACE_MODE_SGMII:
-	case PHY_INTERFACE_MODE_1000BASEX:
-		mode = PHY_MODE_SGMII;
-		break;
-	case PHY_INTERFACE_MODE_2500BASEX:
-		mode = PHY_MODE_2500SGMII;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ret = phy_set_mode(pp->comphy, mode);
+	ret = phy_set_mode_ext(pp->comphy, PHY_MODE_ETHERNET,
+			       pp->phy_interface);
 	if (ret)
 		return ret;
 
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index c067e309f92f..28edc63eff0f 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@ -1428,28 +1428,13 @@ static void mvpp22_gop_setup_irq(struct mvpp2_port *port)
  */
 static int mvpp22_comphy_init(struct mvpp2_port *port)
 {
-	enum phy_mode mode;
 	int ret;
 
 	if (!port->comphy)
 		return 0;
 
-	switch (port->phy_interface) {
-	case PHY_INTERFACE_MODE_SGMII:
-	case PHY_INTERFACE_MODE_1000BASEX:
-		mode = PHY_MODE_SGMII;
-		break;
-	case PHY_INTERFACE_MODE_2500BASEX:
-		mode = PHY_MODE_2500SGMII;
-		break;
-	case PHY_INTERFACE_MODE_10GKR:
-		mode = PHY_MODE_10GKR;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ret = phy_set_mode(port->comphy, mode);
+	ret = phy_set_mode_ext(port->comphy, PHY_MODE_ETHERNET,
+			       port->phy_interface);
 	if (ret)
 		return ret;
 
diff --git a/drivers/phy/marvell/phy-mvebu-cp110-comphy.c b/drivers/phy/marvell/phy-mvebu-cp110-comphy.c
index 601dbf47ac24..34f62f9af646 100644
--- a/drivers/phy/marvell/phy-mvebu-cp110-comphy.c
+++ b/drivers/phy/marvell/phy-mvebu-cp110-comphy.c
@@ -11,11 +11,13 @@
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/phy.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 
 struct mvebu_comhy_conf {
 	enum phy_mode mode;
+	int submode;
 	unsigned lane;
 	unsigned port;
 };
@@ -25,6 +27,14 @@ struct mvebu_comhy_conf {
 		.lane = _lane,			\
 		.port = _port,			\
 		.mode = _mode,			\
+		.submode = PHY_INTERFACE_MODE_NA,			\
+	}
+#define MVEBU_COMPHY_CONF_ETH(_lane, _port, _submode)	\
+	{						\
+		.lane = _lane,				\
+		.port = _port,				\
+		.mode = PHY_MODE_ETHERNET,		\
+		.submode = _submode,			\
 	}
 
 /* FW related definitions */
@@ -89,13 +99,13 @@ static unsigned long a3700_comphy_smc(unsigned long function_id,
 
 static const struct mvebu_comhy_conf mvebu_comphy_a3700_modes[] = {
 	/* lane 0 */
-	MVEBU_COMPHY_CONF(0, 1, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(0, 1, PHY_MODE_2500SGMII),
+	MVEBU_COMPHY_CONF_ETH(0, 1, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(0, 1, PHY_INTERFACE_MODE_2500BASEX),
 	MVEBU_COMPHY_CONF(0, 0, PHY_MODE_USB_HOST),
 	MVEBU_COMPHY_CONF(0, 0, PHY_MODE_USB_DEVICE),
 	/* lane 1 */
 	MVEBU_COMPHY_CONF(1, 0, PHY_MODE_PCIE),
-	MVEBU_COMPHY_CONF(1, 0, PHY_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(1, 0, PHY_INTERFACE_MODE_SGMII),
 	/* lane 2 */
 	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_SATA),
 	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_USB_HOST),
@@ -104,45 +114,45 @@ static const struct mvebu_comhy_conf mvebu_comphy_a3700_modes[] = {
 
 static const struct mvebu_comhy_conf mvebu_comphy_cp110_modes[] = {
 	/* lane 0 */
-	MVEBU_COMPHY_CONF(0, 1, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(0, 1, PHY_MODE_2500SGMII),
+	MVEBU_COMPHY_CONF_ETH(0, 1, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(0, 1, PHY_INTERFACE_MODE_2500BASEX),
 	MVEBU_COMPHY_CONF(0, 0, PHY_MODE_PCIE),
 	MVEBU_COMPHY_CONF(0, 1, PHY_MODE_SATA),
 	/* lane 1 */
-	MVEBU_COMPHY_CONF(1, 2, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(1, 2, PHY_MODE_2500SGMII),
+	MVEBU_COMPHY_CONF_ETH(1, 2, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(1, 2, PHY_INTERFACE_MODE_2500BASEX),
 	MVEBU_COMPHY_CONF(1, 0, PHY_MODE_PCIE),
 	MVEBU_COMPHY_CONF(1, 0, PHY_MODE_SATA),
 	MVEBU_COMPHY_CONF(1, 0, PHY_MODE_USB_HOST),
 	/* lane 2 */
-	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_2500SGMII),
-	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_10GKR),
+	MVEBU_COMPHY_CONF_ETH(2, 0, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(2, 0, PHY_INTERFACE_MODE_2500BASEX),
+	MVEBU_COMPHY_CONF_ETH(2, 0, PHY_INTERFACE_MODE_10GKR),
 	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_PCIE),
 	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_USB_HOST),
 	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_SATA),
-	MVEBU_COMPHY_CONF(2, 0, PHY_MODE_RXAUI),
+	MVEBU_COMPHY_CONF_ETH(2, 0, PHY_INTERFACE_MODE_RXAUI),
 	/* lane 3 */
-	MVEBU_COMPHY_CONF(3, 1, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(3, 1, PHY_MODE_2500SGMII),
+	MVEBU_COMPHY_CONF_ETH(3, 1, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(3, 1, PHY_INTERFACE_MODE_2500BASEX),
 	MVEBU_COMPHY_CONF(3, 0, PHY_MODE_PCIE),
 	MVEBU_COMPHY_CONF(3, 1, PHY_MODE_SATA),
 	MVEBU_COMPHY_CONF(3, 1, PHY_MODE_USB_HOST),
-	MVEBU_COMPHY_CONF(3, 0, PHY_MODE_RXAUI),
+	MVEBU_COMPHY_CONF_ETH(3, 0, PHY_INTERFACE_MODE_RXAUI),
 	/* lane 4 */
-	MVEBU_COMPHY_CONF(4, 0, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(4, 0, PHY_MODE_2500SGMII),
-	MVEBU_COMPHY_CONF(4, 0, PHY_MODE_10GKR),
-	MVEBU_COMPHY_CONF(4, 1, PHY_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(4, 0, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(4, 0, PHY_INTERFACE_MODE_2500BASEX),
+	MVEBU_COMPHY_CONF_ETH(4, 0, PHY_INTERFACE_MODE_10GKR),
+	MVEBU_COMPHY_CONF_ETH(4, 1, PHY_INTERFACE_MODE_SGMII),
 	MVEBU_COMPHY_CONF(4, 1, PHY_MODE_PCIE),
 	MVEBU_COMPHY_CONF(4, 1, PHY_MODE_USB_HOST),
-	MVEBU_COMPHY_CONF(4, 0, PHY_MODE_RXAUI),
+	MVEBU_COMPHY_CONF_ETH(4, 0, PHY_INTERFACE_MODE_RXAUI),
 	/* lane 5 */
-	MVEBU_COMPHY_CONF(5, 2, PHY_MODE_SGMII),
-	MVEBU_COMPHY_CONF(5, 2, PHY_MODE_2500SGMII),
+	MVEBU_COMPHY_CONF_ETH(5, 2, PHY_INTERFACE_MODE_SGMII),
+	MVEBU_COMPHY_CONF_ETH(5, 2, PHY_INTERFACE_MODE_2500BASEX),
 	MVEBU_COMPHY_CONF(5, 2, PHY_MODE_PCIE),
 	MVEBU_COMPHY_CONF(5, 1, PHY_MODE_SATA),
-	MVEBU_COMPHY_CONF(5, 0, PHY_MODE_RXAUI),
+	MVEBU_COMPHY_CONF_ETH(5, 0, PHY_INTERFACE_MODE_RXAUI),
 };
 
 struct mvebu_comphy_data {
@@ -163,6 +173,7 @@ struct mvebu_comphy_lane {
 	struct mvebu_comphy_priv *priv;
 	unsigned id;
 	enum phy_mode mode;
+	int submode;
 	int port;
 };
 
@@ -183,7 +194,7 @@ static const struct mvebu_comphy_data cp110_data = {
 };
 
 static int mvebu_is_comphy_mode_valid(struct mvebu_comphy_lane *lane,
-				      enum phy_mode mode)
+				      enum phy_mode mode, int submode)
 {
 	const struct mvebu_comphy_data *data = lane->priv->data;
 	const struct mvebu_comhy_conf *modes = data->modes;
@@ -192,7 +203,8 @@ static int mvebu_is_comphy_mode_valid(struct mvebu_comphy_lane *lane,
 	for (i = 0; i < data->modes_size; i++) {
 		if (modes[i].lane == lane->id &&
 		    modes[i].port == lane->port &&
-		    modes[i].mode == mode)
+		    modes[i].mode == mode &&
+		    modes[i].submode == submode)
 			break;
 	}
 
@@ -202,37 +214,57 @@ static int mvebu_is_comphy_mode_valid(struct mvebu_comphy_lane *lane,
 	return 0;
 }
 
-static int mvebu_comphy_power_on(struct phy *phy)
+static int mvebu_comphy_eth_power_on(struct phy *phy)
 {
 	struct mvebu_comphy_lane *lane = phy_get_drvdata(phy);
 	struct mvebu_comphy_priv *priv = lane->priv;
 	const struct mvebu_comphy_data *data = priv->data;
 	int ret;
 
-	switch (lane->mode) {
-	case PHY_MODE_SGMII:
+	switch (lane->submode) {
+	case PHY_INTERFACE_MODE_SGMII:
 		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
 				 lane->id,
 				 COMPHY_FW_NET_FORMAT(COMPHY_SGMII_MODE,
 						      lane->port,
 						      COMPHY_SPEED_1_25G));
-
 		break;
-	case PHY_MODE_2500SGMII:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
 				 lane->id,
 				 COMPHY_FW_NET_FORMAT(COMPHY_HS_SGMII_MODE,
 						      lane->port,
 						      COMPHY_SPEED_3_125G));
-
 		break;
-	case PHY_MODE_10GKR:
+	case PHY_INTERFACE_MODE_10GKR:
 		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
 				 lane->id,
 				 COMPHY_FW_NET_FORMAT(COMPHY_XFI_MODE,
 						      lane->port,
 						      COMPHY_SPEED_10_3125G));
 		break;
+	case PHY_INTERFACE_MODE_RXAUI:
+		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
+				 lane->id,
+				 COMPHY_FW_MODE_FORMAT(COMPHY_RXAUI_MODE));
+		break;
+	default:
+		dev_err(priv->dev, "unsupported PHY submode (%d)\n",
+			lane->submode);
+		return -ENOTSUPP;
+	}
+
+	return ret;
+}
+
+static int mvebu_comphy_power_on(struct phy *phy)
+{
+	struct mvebu_comphy_lane *lane = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = lane->priv;
+	const struct mvebu_comphy_data *data = priv->data;
+	int ret;
+
+	switch (lane->mode) {
 	case PHY_MODE_PCIE:
 		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
 				 lane->id,
@@ -246,16 +278,14 @@ static int mvebu_comphy_power_on(struct phy *phy)
 				 lane->id,
 				 COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE));
 		break;
-	case PHY_MODE_RXAUI:
-		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
-				 lane->id,
-				 COMPHY_FW_MODE_FORMAT(COMPHY_RXAUI_MODE));
-		break;
 	case PHY_MODE_USB_HOST:
 		ret = data->comphy_smc(MV_SIP_COMPHY_POWER_ON, priv->phys,
 				 lane->id,
 				 COMPHY_FW_MODE_FORMAT(COMPHY_USB3H_MODE));
 		break;
+	case PHY_MODE_ETHERNET:
+		ret = mvebu_comphy_eth_power_on(phy);
+		break;
 	default:
 		return -ENOTSUPP;
 	}
@@ -270,10 +300,17 @@ static int mvebu_comphy_set_mode(struct phy *phy,
 {
 	struct mvebu_comphy_lane *lane = phy_get_drvdata(phy);
 
-	if (mvebu_is_comphy_mode_valid(lane, mode) < 0)
+	if (submode == PHY_INTERFACE_MODE_1000BASEX)
+		submode = PHY_INTERFACE_MODE_SGMII;
+
+	if (mvebu_is_comphy_mode_valid(lane, mode, submode) < 0) {
+		dev_dbg(&phy->dev, "invalid mode %d or submode %d for lane %d\n",
+		       mode, submode, lane->id);
 		return -EINVAL;
+	}
 
 	lane->mode = mode;
+	lane->submode = submode;
 	return 0;
 }
 
-- 
2.17.1


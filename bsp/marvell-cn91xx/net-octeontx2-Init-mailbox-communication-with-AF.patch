From 235eb6cc1477015df6720aba2ba30470e80ec646 Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Tue, 7 Aug 2018 16:56:24 +0530
Subject: [PATCH 0101/1051] net: octeontx2: Init mailbox communication with AF

RVU PF and AF (admin function) shares 64KB of reserved memory region
for communication. This patch initializes PF <=> AF mailbox IRQs,
registers handlers for processing mbox messages received from AF.
This patch adds support only to handle responses sent by AF
for the mbox messages sent by PF.

Mbox communication APIs and message formats are defined in AF driver
(drivers/soc/marvell/soc/octeontx2), mbox.h from AF driver is included
here to avoid duplication.

Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/Makefile   |   4 +-
 .../ethernet/marvell/octeontx2/otx2_common.c  |  70 ++++++
 .../ethernet/marvell/octeontx2/otx2_common.h  |  65 +++++
 .../net/ethernet/marvell/octeontx2/otx2_pf.c  | 225 +++++++++++++++++-
 .../net/ethernet/marvell/octeontx2/otx2_reg.h |  59 +++++
 5 files changed, 419 insertions(+), 4 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/otx2_common.c
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/otx2_reg.h

diff --git a/drivers/net/ethernet/marvell/octeontx2/Makefile b/drivers/net/ethernet/marvell/octeontx2/Makefile
index 77b71dda41bd..41855bf9dc82 100644
--- a/drivers/net/ethernet/marvell/octeontx2/Makefile
+++ b/drivers/net/ethernet/marvell/octeontx2/Makefile
@@ -5,4 +5,6 @@
 
 obj-$(CONFIG_OCTEONTX2_PF) += octeontx2_nicpf.o
 
-octeontx2_nicpf-y := otx2_pf.o
+octeontx2_nicpf-y := otx2_pf.o otx2_common.o
+
+ccflags-y += -I$(srctree)/drivers/soc/marvell/octeontx2
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
new file mode 100644
index 000000000000..0ec1e453bf85
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 RVU Ethernet driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#include "otx2_reg.h"
+#include "otx2_common.h"
+
+void otx2_disable_msix(struct otx2_nic *pfvf)
+{
+	struct otx2_hw *hw = &pfvf->hw;
+	int irq;
+
+	if (!hw->irq_allocated)
+		goto freemem;
+
+	/* Free all registered IRQ handlers */
+	for (irq = 0; irq < hw->num_vec; irq++) {
+		if (!hw->irq_allocated[irq])
+			continue;
+		free_irq(pci_irq_vector(hw->pdev, irq), pfvf);
+	}
+
+	pci_free_irq_vectors(hw->pdev);
+
+freemem:
+	hw->num_vec = 0;
+	kfree(hw->irq_allocated);
+	kfree(hw->irq_name);
+	hw->irq_allocated = NULL;
+	hw->irq_name = NULL;
+}
+
+int otx2_enable_msix(struct otx2_hw *hw)
+{
+	int ret;
+
+	hw->num_vec = pci_msix_vec_count(hw->pdev);
+
+	hw->irq_name = kmalloc_array(hw->num_vec, NAME_SIZE, GFP_KERNEL);
+	if (!hw->irq_name)
+		return -ENOMEM;
+
+	hw->irq_allocated = kcalloc(hw->num_vec, sizeof(bool), GFP_KERNEL);
+	if (!hw->irq_allocated) {
+		kfree(hw->irq_name);
+		return -ENOMEM;
+	}
+
+	/* Enable MSI-X */
+	ret = pci_alloc_irq_vectors(hw->pdev, hw->num_vec, hw->num_vec,
+				    PCI_IRQ_MSIX);
+	if (ret < 0) {
+		dev_err(&hw->pdev->dev,
+			"Request for #%d msix vectors failed, ret %d\n",
+			hw->num_vec, ret);
+		kfree(hw->irq_allocated);
+		kfree(hw->irq_name);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index 416c5946b9c7..936415108003 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -11,6 +11,10 @@
 #ifndef OTX2_COMMON_H
 #define OTX2_COMMON_H
 
+#include <mbox.h>
+
+#include "otx2_reg.h"
+
 /* PCI device IDs */
 #define PCI_DEVID_OCTEONTX2_RVU_PF              0xA063
 
@@ -18,10 +22,26 @@
 #define PCI_CFG_REG_BAR_NUM                     2
 #define PCI_MBOX_BAR_NUM                        4
 
+#define NAME_SIZE                               32
+
+struct  mbox {
+	struct otx2_mbox	mbox;
+	struct work_struct	mbox_wrk;
+	struct otx2_mbox	mbox_up;
+	struct work_struct	mbox_up_wrk;
+	struct otx2_nic		*pfvf;
+};
+
 struct otx2_hw {
+	struct pci_dev		*pdev;
 	u16                     rx_queues;
 	u16                     tx_queues;
 	u16			max_queues;
+
+	/* MSI-X*/
+	u16			num_vec;
+	bool			*irq_allocated;
+	char			*irq_name;
 };
 
 struct otx2_nic {
@@ -30,6 +50,51 @@ struct otx2_nic {
 	struct device		*dev;
 	struct net_device	*netdev;
 
+	u16			pcifunc;
 	struct otx2_hw		hw;
+	struct mbox		mbox;
+	struct workqueue_struct *mbox_wq;
 };
+
+/* Register read/write APIs */
+static inline void otx2_write64(struct otx2_nic *nic, u64 offset, u64 val)
+{
+	writeq(val, nic->reg_base + offset);
+}
+
+static inline u64 otx2_read64(struct otx2_nic *nic, u64 offset)
+{
+	return readq(nic->reg_base + offset);
+}
+
+/* Mbox APIs */
+static inline int otx2_sync_mbox_msg(struct mbox *mbox)
+{
+	if (!otx2_mbox_nonempty(&mbox->mbox, 0))
+		return 0;
+	otx2_mbox_msg_send(&mbox->mbox, 0);
+	return otx2_mbox_wait_for_rsp(&mbox->mbox, 0);
+}
+
+#define M(_name, _id, _req_type, _rsp_type)				\
+static struct _req_type __maybe_unused					\
+*otx2_mbox_alloc_msg_ ## _name(struct mbox *mbox)			\
+{									\
+	struct _req_type *req;						\
+									\
+	req = (struct _req_type *)otx2_mbox_alloc_msg_rsp(		\
+		&mbox->mbox, 0, sizeof(struct _req_type),		\
+		sizeof(struct _rsp_type));				\
+	if (!req)							\
+		return NULL;						\
+	req->hdr.sig = OTX2_MBOX_REQ_SIG;				\
+	req->hdr.id = _id;						\
+	return req;							\
+}
+
+MBOX_MESSAGES
+#undef M
+
+int otx2_enable_msix(struct otx2_hw *hw);
+void otx2_disable_msix(struct otx2_nic *pfvf);
 #endif /* OTX2_COMMON_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 0cbf1e32889b..36be5d31a1a3 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -16,6 +16,7 @@
 #include <linux/if_vlan.h>
 #include <net/ip.h>
 
+#include "otx2_reg.h"
 #include "otx2_common.h"
 
 #define DRV_NAME	"octeontx2-nicpf"
@@ -34,6 +35,195 @@ MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DRV_VERSION);
 MODULE_DEVICE_TABLE(pci, otx2_pf_id_table);
 
+static void otx2_process_pfaf_mbox_msg(struct otx2_nic *pf,
+				       struct mbox_msghdr *msg)
+{
+	if (msg->id >= MBOX_MSG_MAX) {
+		dev_err(pf->dev,
+			"Mbox msg with unknown ID 0x%x\n", msg->id);
+		return;
+	}
+
+	if (msg->sig != OTX2_MBOX_RSP_SIG) {
+		dev_err(pf->dev,
+			"Mbox msg with wrong signature %x, ID 0x%x\n",
+			 msg->sig, msg->id);
+		return;
+	}
+
+	switch (msg->id) {
+	case MBOX_MSG_READY:
+		pf->pcifunc = msg->pcifunc;
+		break;
+	default:
+		if (msg->rc)
+			dev_err(pf->dev,
+				"Mbox msg response has err %d, ID 0x%x\n",
+				msg->rc, msg->id);
+		break;
+	}
+}
+
+static void otx2_pfaf_mbox_handler(struct work_struct *work)
+{
+	struct otx2_mbox_dev *mdev;
+	struct mbox_hdr *rsp_hdr;
+	struct mbox_msghdr *msg;
+	struct otx2_mbox *mbox;
+	struct mbox *af_mbox;
+	int offset, id;
+
+	af_mbox = container_of(work, struct mbox, mbox_wrk);
+	mbox = &af_mbox->mbox;
+	mdev = &mbox->dev[0];
+	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
+	if (rsp_hdr->num_msgs == 0)
+		return;
+	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
+
+	for (id = 0; id < rsp_hdr->num_msgs; id++) {
+		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
+		otx2_process_pfaf_mbox_msg(af_mbox->pfvf, msg);
+		offset = mbox->rx_start + msg->next_msgoff;
+		mdev->msgs_acked++;
+	}
+
+	otx2_mbox_reset(mbox, 0);
+
+	/* Clear the IRQ */
+	smp_wmb();
+	otx2_write64(af_mbox->pfvf, RVU_PF_INT, BIT_ULL(0));
+}
+
+static irqreturn_t otx2_pfaf_mbox_intr_handler(int irq, void *pf_irq)
+{
+	struct otx2_nic *pf = (struct otx2_nic *)pf_irq;
+	struct otx2_mbox_dev *mdev;
+	struct otx2_mbox *mbox;
+	struct mbox_hdr *hdr;
+
+	/* Read latest mbox data */
+	smp_rmb();
+
+	/* Check for AF => PF response messages */
+	mbox = &pf->mbox.mbox;
+	mdev = &mbox->dev[0];
+	hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
+	if (hdr->num_msgs)
+		queue_work(pf->mbox_wq, &pf->mbox.mbox_wrk);
+
+	/* Clear the IRQ */
+	otx2_write64(pf, RVU_PF_INT, BIT_ULL(0));
+
+	return IRQ_HANDLED;
+}
+
+static int otx2_register_mbox_intr(struct otx2_nic *pf)
+{
+	struct otx2_hw *hw = &pf->hw;
+	int err;
+
+	/* Skip if MSIX is already initialized */
+	if (hw->num_vec)
+		return 0;
+
+	/* Enable MSI-X */
+	err = otx2_enable_msix(hw);
+	if (err)
+		return err;
+
+	/* Register mailbox interrupt handler */
+	sprintf(&hw->irq_name[RVU_PF_INT_VEC_AFPF_MBOX * NAME_SIZE],
+		"RVUPFAF Mbox");
+	err = request_irq(pci_irq_vector(pf->pdev, RVU_PF_INT_VEC_AFPF_MBOX),
+			  otx2_pfaf_mbox_intr_handler, 0,
+			  &hw->irq_name[RVU_PF_INT_VEC_AFPF_MBOX * NAME_SIZE],
+			  pf);
+	if (err) {
+		dev_err(pf->dev,
+			"RVUPF: IRQ registration failed for PFAF mbox irq\n");
+		return err;
+	}
+
+	hw->irq_allocated[RVU_PF_INT_VEC_AFPF_MBOX] = true;
+
+	/* Enable mailbox interrupt for msgs coming from AF.
+	 * First clear to avoid spurious interrupts, if any.
+	 */
+	otx2_write64(pf, RVU_PF_INT, BIT_ULL(0));
+	otx2_write64(pf, RVU_PF_INT_ENA_W1S, BIT_ULL(0));
+
+	/* Check mailbox communication with AF */
+	otx2_mbox_alloc_msg_READY(&pf->mbox);
+	err = otx2_sync_mbox_msg(&pf->mbox);
+	if (err) {
+		dev_warn(pf->dev,
+			 "AF not responding to mailbox, deferring probe\n");
+		return err;
+	}
+	return 0;
+}
+
+static void otx2_disable_mbox_intr(struct otx2_nic *pf)
+{
+	/* Disable AF => PF mailbox IRQ */
+	otx2_write64(pf, RVU_PF_INT_ENA_W1C, BIT_ULL(0));
+}
+
+static void otx2_pfaf_mbox_destroy(struct otx2_nic *pf)
+{
+	struct mbox *mbox = &pf->mbox;
+
+	if (pf->mbox_wq) {
+		flush_workqueue(pf->mbox_wq);
+		destroy_workqueue(pf->mbox_wq);
+		pf->mbox_wq = NULL;
+	}
+
+	if (mbox->mbox.hwbase)
+		iounmap((void __iomem *)mbox->mbox.hwbase);
+
+	otx2_mbox_destroy(&mbox->mbox);
+}
+
+static int otx2_pfaf_mbox_init(struct otx2_nic *pf)
+{
+	struct mbox *mbox = &pf->mbox;
+	void __iomem *hwbase;
+	int err;
+
+	mbox->pfvf = pf;
+	pf->mbox_wq = alloc_workqueue("otx2_pfaf_mailbox",
+				      WQ_UNBOUND | WQ_HIGHPRI |
+				      WQ_MEM_RECLAIM, 1);
+	if (!pf->mbox_wq)
+		return -ENOMEM;
+
+	/* Mailbox is a reserved memory (in RAM) region shared between
+	 * admin function (i.e AF) and this PF, shouldn't be mapped as
+	 * device memory to allow unaligned accesses.
+	 */
+	hwbase = ioremap_wc(pci_resource_start(pf->pdev, PCI_MBOX_BAR_NUM),
+			    pci_resource_len(pf->pdev, PCI_MBOX_BAR_NUM));
+	if (!hwbase) {
+		dev_err(pf->dev, "Unable to map PFAF mailbox region\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	err = otx2_mbox_init(&mbox->mbox, hwbase, pf->pdev, pf->reg_base,
+			     MBOX_DIR_PFAF, 1);
+	if (err)
+		goto exit;
+
+	INIT_WORK(&mbox->mbox_wrk, otx2_pfaf_mbox_handler);
+
+	return 0;
+exit:
+	destroy_workqueue(pf->mbox_wq);
+	return err;
+}
+
 static int otx2_set_real_num_queues(struct net_device *netdev,
 				    int tx_queues, int rx_queues)
 {
@@ -55,14 +245,24 @@ static int otx2_set_real_num_queues(struct net_device *netdev,
 
 static int otx2_open(struct net_device *netdev)
 {
+	struct otx2_nic *pf = netdev_priv(netdev);
+	int err = 0;
+
 	netif_carrier_off(netdev);
 
+	err = otx2_register_mbox_intr(pf);
+	if (err)
+		return err;
+
 	return 0;
 }
 
 static int otx2_stop(struct net_device *netdev)
 {
-	/* Nothing to do */
+	struct otx2_nic *pf = netdev_priv(netdev);
+
+	otx2_disable_msix(pf);
+
 	return 0;
 }
 
@@ -121,6 +321,7 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	pf->pdev = pdev;
 	pf->dev = dev;
 	hw = &pf->hw;
+	hw->pdev = pdev;
 	hw->rx_queues = qcount;
 	hw->tx_queues = qcount;
 	hw->max_queues = qcount;
@@ -133,19 +334,32 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto err_free_netdev;
 	}
 
-	err = otx2_set_real_num_queues(netdev, hw->tx_queues, hw->rx_queues);
+	/* Init PF <=> AF mailbox stuff */
+	err = otx2_pfaf_mbox_init(pf);
 	if (err)
 		goto err_free_netdev;
 
+	/* Register mailbox interrupt */
+	err = otx2_register_mbox_intr(pf);
+	if (err)
+		goto err_irq;
+
+	err = otx2_set_real_num_queues(netdev, hw->tx_queues, hw->rx_queues);
+	if (err)
+		goto err_irq;
+
 	netdev->netdev_ops = &otx2_netdev_ops;
 	err = register_netdev(netdev);
 	if (err) {
 		dev_err(dev, "Failed to register netdevice\n");
-		goto err_free_netdev;
+		goto err_irq;
 	}
 
 	return 0;
 
+err_irq:
+	otx2_disable_msix(pf);
+	otx2_pfaf_mbox_destroy(pf);
 err_free_netdev:
 	pci_set_drvdata(pdev, NULL);
 	free_netdev(netdev);
@@ -166,6 +380,11 @@ static void otx2_remove(struct pci_dev *pdev)
 
 	pf = netdev_priv(netdev);
 	unregister_netdev(netdev);
+
+	otx2_disable_mbox_intr(pf);
+	otx2_disable_msix(pf);
+	otx2_pfaf_mbox_destroy(pf);
+
 	pci_set_drvdata(pdev, NULL);
 	free_netdev(netdev);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h b/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h
new file mode 100644
index 000000000000..bdb9773d9492
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 RVU Physcial Function ethernet driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef OTX2_REG_H
+#define OTX2_REG_H
+
+/* RVU PF registers */
+#define	RVU_PF_VFX_PFVF_MBOX0		    (0x00000)
+#define	RVU_PF_VFX_PFVF_MBOX1		    (0x00008)
+#define RVU_PF_VFX_PFVF_MBOXX(a, b)         (0x0 | (a) << 12 | (b) << 3)
+#define RVU_PF_VF_BAR4_ADDR                 (0x10)
+#define RVU_PF_BLOCK_ADDRX_DISC(a)          (0x200 | (a) << 3)
+#define RVU_PF_VFME_STATUSX(a)              (0x800 | (a) << 3)
+#define RVU_PF_VFTRPENDX(a)                 (0x820 | (a) << 3)
+#define RVU_PF_VFTRPEND_W1SX(a)             (0x840 | (a) << 3)
+#define RVU_PF_VFPF_MBOX_INTX(a)            (0x880 | (a) << 3)
+#define RVU_PF_VFPF_MBOX_INT_W1SX(a)        (0x8A0 | (a) << 3)
+#define RVU_PF_VFPF_MBOX_INT_ENA_W1SX(a)    (0x8C0 | (a) << 3)
+#define RVU_PF_VFPF_MBOX_INT_ENA_W1CX(a)    (0x8E0 | (a) << 3)
+#define RVU_PF_VFFLR_INTX(a)                (0x900 | (a) << 3)
+#define RVU_PF_VFFLR_INT_W1SX(a)            (0x920 | (a) << 3)
+#define RVU_PF_VFFLR_INT_ENA_W1SX(a)        (0x940 | (a) << 3)
+#define RVU_PF_VFFLR_INT_ENA_W1CX(a)        (0x960 | (a) << 3)
+#define RVU_PF_VFME_INTX(a)                 (0x980 | (a) << 3)
+#define RVU_PF_VFME_INT_W1SX(a)             (0x9A0 | (a) << 3)
+#define RVU_PF_VFME_INT_ENA_W1SX(a)         (0x9C0 | (a) << 3)
+#define RVU_PF_VFME_INT_ENA_W1CX(a)         (0x9E0 | (a) << 3)
+#define RVU_PF_PFAF_MBOX0                   (0xC00)
+#define RVU_PF_PFAF_MBOX1                   (0xC08)
+#define RVU_PF_PFAF_MBOXX(a)                (0xC00 | (a) << 3)
+#define RVU_PF_INT                          (0xc20)
+#define RVU_PF_INT_W1S                      (0xc28)
+#define RVU_PF_INT_ENA_W1S                  (0xc30)
+#define RVU_PF_INT_ENA_W1C                  (0xc38)
+#define RVU_PF_MSIX_VECX_ADDR(a)            (0x000 | (a) << 4)
+#define RVU_PF_MSIX_VECX_CTL(a)             (0x008 | (a) << 4)
+#define RVU_PF_MSIX_PBAX(a)                 (0xF0000 | (a) << 3)
+
+/* RVU VF registers */
+#define	RVU_VF_VFPF_MBOX0		    (0x00000)
+#define	RVU_VF_VFPF_MBOX1		    (0x00008)
+#define RVU_VF_VFPF_MBOXX(a)                (0x00 | (a) << 3)
+#define RVU_VF_INT                          (0x20)
+#define RVU_VF_INT_W1S                      (0x28)
+#define RVU_VF_INT_ENA_W1S                  (0x30)
+#define RVU_VF_INT_ENA_W1C                  (0x38)
+#define RVU_VF_BLOCK_ADDRX_DISC(a)          (0x200 | (a) << 3)
+#define RVU_VF_MSIX_VECX_ADDR(a)            (0x000 | (a) << 4)
+#define RVU_VF_MSIX_VECX_CTL(a)             (0x008 | (a) << 4)
+#define RVU_VF_MSIX_PBAX(a)                 (0xF0000 | (a) << 3)
+
+#endif /* OTX2_REG_H */
-- 
2.17.1


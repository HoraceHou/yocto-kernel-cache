From c120316daba37d9b8c133807fa4233eaa16efac8 Mon Sep 17 00:00:00 2001
From: Aleksey Makarov <amakarov@marvell.com>
Date: Tue, 27 Nov 2018 22:51:02 +0300
Subject: [PATCH 0764/1051] net: octeontx2: Add support for PTP clock

This patch adds PTP clock and uses it in OcteonTX2 network device.
PTP clock uses mbox calls to access the hardware counter
on the RVU side.

Signed-off-by: Aleksey Makarov <amakarov@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/Makefile   |   3 +-
 .../ethernet/marvell/octeontx2/otx2_common.c  |   7 +
 .../ethernet/marvell/octeontx2/otx2_common.h  |   5 +
 .../ethernet/marvell/octeontx2/otx2_ethtool.c |  27 ++
 .../net/ethernet/marvell/octeontx2/otx2_pf.c  | 124 ++++++++-
 .../net/ethernet/marvell/octeontx2/otx2_ptp.c | 252 ++++++++++++++++++
 .../net/ethernet/marvell/octeontx2/otx2_ptp.h |  20 ++
 .../ethernet/marvell/octeontx2/otx2_struct.h  |  34 +++
 .../ethernet/marvell/octeontx2/otx2_txrx.c    | 103 ++++++-
 .../ethernet/marvell/octeontx2/otx2_txrx.h    |   1 +
 10 files changed, 562 insertions(+), 14 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/otx2_ptp.h

diff --git a/drivers/net/ethernet/marvell/octeontx2/Makefile b/drivers/net/ethernet/marvell/octeontx2/Makefile
index 1dc29f76d393..c855991c1a97 100644
--- a/drivers/net/ethernet/marvell/octeontx2/Makefile
+++ b/drivers/net/ethernet/marvell/octeontx2/Makefile
@@ -6,7 +6,8 @@
 obj-$(CONFIG_OCTEONTX2_PF) += octeontx2_nicpf.o
 obj-$(CONFIG_OCTEONTX2_VF) += octeontx2_nicvf.o
 
-octeontx2_nicpf-y := otx2_pf.o otx2_common.o otx2_txrx.o otx2_ethtool.o
+octeontx2_nicpf-y := otx2_pf.o otx2_common.o otx2_txrx.o otx2_ethtool.o \
+	otx2_ptp.o
 octeontx2_nicvf-y := otx2_vf.o
 
 ccflags-y += -I$(srctree)/drivers/soc/marvell/octeontx2
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index bb041475d351..fab7163c34fb 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -554,6 +554,13 @@ static int otx2_sq_init(struct otx2_nic *pfvf, u16 qidx, u16 sqb_aura)
 	if (!sq->sg)
 		return -ENOMEM;
 
+	if (pfvf->ptp) {
+		err = qmem_alloc(pfvf->dev, &sq->timestamps, qset->sqe_cnt,
+				 sizeof(*sq->timestamps));
+		if (err)
+			return err;
+	}
+
 	sq->head = 0;
 	sq->sqe_per_sqb = (pfvf->hw.sqb_size / sq->sqe_size) - 1;
 	sq->num_sqbs = (qset->sqe_cnt + sq->sqe_per_sqb) / sq->sqe_per_sqb;
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index 0626f8c6c610..af2ad4655bdd 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -144,6 +144,8 @@ struct otx2_hw {
 	u64			cgx_tx_stats[CGX_TX_STATS_COUNT];
 };
 
+struct otx2_ptp;
+
 struct otx2_nic {
 	void __iomem		*reg_base;
 	struct pci_dev		*pdev;
@@ -163,6 +165,9 @@ struct otx2_nic {
 	u32			cq_ecount_wait;
 	struct work_struct	reset_task;
 	u64			reset_count;
+	u8			hw_rx_tstamp;
+	u8			hw_tx_tstamp;
+	struct otx2_ptp		*ptp;
 };
 
 static inline bool is_9xxx_pass1_silicon(struct pci_dev *pdev)
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c
index b490c6d09985..21e51913568f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c
@@ -16,6 +16,7 @@
 #include <linux/log2.h>
 
 #include "otx2_common.h"
+#include "otx2_ptp.h"
 
 #define DRV_NAME	"octeontx2-nicpf"
 #define DRV_VERSION	"1.0"
@@ -593,6 +594,31 @@ static int otx2_set_rxfh(struct net_device *dev, const u32 *indir,
 	return 0;
 }
 
+static int otx2_get_ts_info(struct net_device *netdev,
+			    struct ethtool_ts_info *info)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+
+	if (!pfvf->ptp)
+		return ethtool_op_get_ts_info(netdev, info);
+
+	info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+				SOF_TIMESTAMPING_RX_SOFTWARE |
+				SOF_TIMESTAMPING_SOFTWARE |
+				SOF_TIMESTAMPING_TX_HARDWARE |
+				SOF_TIMESTAMPING_RX_HARDWARE |
+				SOF_TIMESTAMPING_RAW_HARDWARE;
+
+	info->phc_index = otx2_ptp_clock_index(pfvf);
+
+	info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+
+	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+			   (1 << HWTSTAMP_FILTER_ALL);
+
+	return 0;
+}
+
 static const struct ethtool_ops otx2_ethtool_ops = {
 	.get_drvinfo		= otx2_get_drvinfo,
 	.get_strings		= otx2_get_strings,
@@ -610,6 +636,7 @@ static const struct ethtool_ops otx2_ethtool_ops = {
 	.get_rxfh_indir_size	= otx2_get_rxfh_indir_size,
 	.get_rxfh		= otx2_get_rxfh,
 	.set_rxfh		= otx2_set_rxfh,
+	.get_ts_info		= otx2_get_ts_info,
 };
 
 void otx2_set_ethtool_ops(struct net_device *netdev)
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 22134a61e5a6..6262ef7c89a0 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -21,6 +21,7 @@
 #include "otx2_common.h"
 #include "otx2_txrx.h"
 #include "otx2_struct.h"
+#include "otx2_ptp.h"
 
 #define DRV_NAME	"octeontx2-nicpf"
 #define DRV_STRING	"Marvell OcteonTX2 NIC Physical Function Driver"
@@ -657,6 +658,7 @@ static void otx2_free_hw_resources(struct otx2_nic *pf)
 		if (!pf->hw.hw_tso)
 			qmem_free(pf->dev, sq->tso_hdrs);
 		kfree(sq->sg);
+		qmem_free(pf->dev, sq->timestamps);
 	}
 
 	/* Free SQB pointers */
@@ -1023,6 +1025,119 @@ static int otx2_set_features(struct net_device *netdev,
 	return 0;
 }
 
+static int otx2_config_hw_rx_tstamp(struct otx2_nic *pfvf, bool enable)
+{
+	struct msg_req *req;
+	int err;
+
+	if (!!pfvf->hw_rx_tstamp == enable)
+		return 0;
+
+	if (enable)
+		req = otx2_mbox_alloc_msg_cgx_ptp_rx_enable(&pfvf->mbox);
+	else
+		req = otx2_mbox_alloc_msg_cgx_ptp_rx_disable(&pfvf->mbox);
+	if (!req)
+		return -ENOMEM;
+
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	if (err)
+		return err;
+
+	pfvf->hw_rx_tstamp = enable;
+	return 0;
+}
+
+static int otx2_config_hw_tx_tstamp(struct otx2_nic *pfvf, bool enable)
+{
+	struct msg_req *req;
+	int err;
+
+	if (!!pfvf->hw_tx_tstamp == enable)
+		return 0;
+
+	if (enable)
+		req = otx2_mbox_alloc_msg_nix_lf_ptp_tx_enable(&pfvf->mbox);
+	else
+		req = otx2_mbox_alloc_msg_nix_lf_ptp_tx_disable(&pfvf->mbox);
+	if (!req)
+		return -ENOMEM;
+
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	if (err)
+		return err;
+
+	pfvf->hw_tx_tstamp = enable;
+	return 0;
+}
+
+static int otx2_config_hwtstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+	struct hwtstamp_config config;
+
+	if (!pfvf->ptp)
+		return -ENODEV;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	/* reserved for future extensions */
+	if (config.flags)
+		return -EINVAL;
+
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		otx2_config_hw_tx_tstamp(pfvf, false);
+		break;
+	case HWTSTAMP_TX_ON:
+		otx2_config_hw_tx_tstamp(pfvf, true);
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		otx2_config_hw_rx_tstamp(pfvf, false);
+		break;
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_SOME:
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		otx2_config_hw_rx_tstamp(pfvf, true);
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &config, sizeof(config)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int otx2_ioctl(struct net_device *netdev, struct ifreq *req, int cmd)
+{
+	switch (cmd) {
+	case SIOCSHWTSTAMP:
+		return otx2_config_hwtstamp(netdev, req);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
 static const struct net_device_ops otx2_netdev_ops = {
 	.ndo_open		= otx2_open,
 	.ndo_stop		= otx2_stop,
@@ -1034,6 +1149,7 @@ static const struct net_device_ops otx2_netdev_ops = {
 	.ndo_get_stats64	= otx2_get_stats64,
 	.ndo_set_features	= otx2_set_features,
 	.ndo_tx_timeout         = otx2_tx_timeout,
+	.ndo_do_ioctl		= otx2_ioctl,
 };
 
 static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
@@ -1147,6 +1263,9 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	pf->cq_time_wait = CQ_TIMER_THRESH_DEFAULT;
 	pf->cq_ecount_wait = CQ_CQE_THRESH_DEFAULT;
 
+	/* Don't check for error.  Proceed without ptp */
+	otx2_ptp_init(pf);
+
 	/* NPA's pool is a stack to which SW frees buffer pointers via Aura.
 	 * HW allocates buffer pointer from stack and uses it for DMA'ing
 	 * ingress packet. In some scenarios HW can free back allocated buffer
@@ -1184,12 +1303,14 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	err = register_netdev(netdev);
 	if (err) {
 		dev_err(dev, "Failed to register netdevice\n");
-		goto err_detach_rsrc;
+		goto err_ptp_destroy;
 	}
 
 	otx2_set_ethtool_ops(netdev);
 	return 0;
 
+err_ptp_destroy:
+	otx2_ptp_destroy(pf);
 err_detach_rsrc:
 	otx2_detach_resources(&pf->mbox);
 err_disable_mbox_intr:
@@ -1220,6 +1341,7 @@ static void otx2_remove(struct pci_dev *pdev)
 	pf = netdev_priv(netdev);
 	hw = &pf->hw;
 	unregister_netdev(netdev);
+	otx2_ptp_destroy(pf);
 
 	otx2_disable_mbox_intr(pf);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c b/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c
new file mode 100644
index 000000000000..564e2febbb9d
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c
@@ -0,0 +1,252 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 PTP support for ethernet driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/ptp_clock_kernel.h>
+
+#include "otx2_common.h"
+
+struct otx2_ptp {
+	struct kref refcount;
+	struct ptp_clock_info ptp_info;
+	struct ptp_clock *ptp_clock;
+	struct otx2_nic *nic;
+
+	/* Serialize access to cycle_counter, time_counter and reg_base */
+	spinlock_t spin_lock;
+	struct cyclecounter cycle_counter;
+	struct timecounter time_counter;
+};
+
+static struct otx2_ptp *ptp_ptr;
+static DEFINE_MUTEX(ptp_mutex);
+
+static int otx2_ptp_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)
+{
+	struct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,
+					    ptp_info);
+	struct ptp_req *req;
+	int err;
+
+	if (!ptp->nic)
+		return -ENODEV;
+
+	req = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);
+	if (!req)
+		return -ENOMEM;
+
+	req->op = PTP_OP_ADJFINE;
+	req->scaled_ppm = scaled_ppm;
+
+	err = otx2_sync_mbox_msg(&ptp->nic->mbox);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static u64 ptp_cc_read(const struct cyclecounter *cc)
+{
+	struct otx2_ptp *ptp = container_of(cc, struct otx2_ptp, cycle_counter);
+	struct ptp_req *req;
+	struct ptp_rsp *rsp;
+	int err;
+
+	if (!ptp->nic)
+		return 0;
+
+	req = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);
+	if (!req)
+		return 0;
+
+	req->op = PTP_OP_GET_CLOCK;
+
+	err = otx2_sync_mbox_msg(&ptp->nic->mbox);
+	if (err)
+		return 0;
+
+	rsp = (struct ptp_rsp *)otx2_mbox_get_rsp(&ptp->nic->mbox.mbox, 0,
+						  &req->hdr);
+	if (IS_ERR(rsp))
+		return 0;
+
+	return rsp->clk;
+}
+
+static int otx2_ptp_adjtime(struct ptp_clock_info *ptp_info, s64 delta)
+{
+	struct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,
+					    ptp_info);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ptp->spin_lock, flags);
+	timecounter_adjtime(&ptp->time_counter, delta);
+	spin_unlock_irqrestore(&ptp->spin_lock, flags);
+
+	return 0;
+}
+
+static int otx2_ptp_gettime(struct ptp_clock_info *ptp_info,
+			    struct timespec64 *ts)
+{
+	struct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,
+					    ptp_info);
+	unsigned long flags;
+	u64 nsec;
+
+	spin_lock_irqsave(&ptp->spin_lock, flags);
+	nsec = timecounter_read(&ptp->time_counter);
+	spin_unlock_irqrestore(&ptp->spin_lock, flags);
+
+	*ts = ns_to_timespec64(nsec);
+
+	return 0;
+}
+
+static int otx2_ptp_settime(struct ptp_clock_info *ptp_info,
+			    const struct timespec64 *ts)
+{
+	struct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,
+					    ptp_info);
+	unsigned long flags;
+	u64 nsec;
+
+	nsec = timespec64_to_ns(ts);
+
+	spin_lock_irqsave(&ptp->spin_lock, flags);
+	timecounter_init(&ptp->time_counter, &ptp->cycle_counter, nsec);
+	spin_unlock_irqrestore(&ptp->spin_lock, flags);
+
+	return 0;
+}
+
+static int otx2_ptp_enable(struct ptp_clock_info *ptp_info,
+			   struct ptp_clock_request *rq, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+int otx2_ptp_init(struct otx2_nic *pfvf)
+{
+	struct cyclecounter *cc;
+	struct ptp_req *req;
+	int err;
+
+	/* check if PTP block is available */
+	req = otx2_mbox_alloc_msg_ptp_op(&pfvf->mbox);
+	if (!req)
+		return -ENOMEM;
+
+	req->op = PTP_OP_GET_CLOCK;
+
+	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	if (err)
+		return err;
+
+	mutex_lock(&ptp_mutex);
+
+	if (ptp_ptr) {
+		kref_get(&ptp_ptr->refcount);
+		pfvf->ptp = ptp_ptr;
+		mutex_unlock(&ptp_mutex);
+		return 0;
+	}
+
+	ptp_ptr = kmalloc(sizeof(*ptp_ptr), GFP_KERNEL);
+	if (!ptp_ptr) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	spin_lock_init(&ptp_ptr->spin_lock);
+
+	cc = &ptp_ptr->cycle_counter;
+	cc->read = ptp_cc_read;
+	cc->mask = CYCLECOUNTER_MASK(64);
+	cc->mult = 1;
+	cc->shift = 0;
+
+	timecounter_init(&ptp_ptr->time_counter, &ptp_ptr->cycle_counter,
+			 ktime_to_ns(ktime_get_real()));
+
+	kref_init(&ptp_ptr->refcount);
+
+	ptp_ptr->ptp_info = (struct ptp_clock_info) {
+		.owner          = THIS_MODULE,
+		.name           = "OcteonTX2 PTP",
+		.max_adj        = 1000000000ull,
+		.n_ext_ts       = 0,
+		.n_pins         = 0,
+		.pps            = 0,
+		.adjfine        = otx2_ptp_adjfine,
+		.adjtime        = otx2_ptp_adjtime,
+		.gettime64      = otx2_ptp_gettime,
+		.settime64      = otx2_ptp_settime,
+		.enable         = otx2_ptp_enable,
+	};
+
+	ptp_ptr->ptp_clock = ptp_clock_register(&ptp_ptr->ptp_info, pfvf->dev);
+	if (IS_ERR(ptp_ptr->ptp_clock)) {
+		err = PTR_ERR(ptp_ptr->ptp_clock);
+		kfree(ptp_ptr);
+		goto error;
+	}
+
+	ptp_ptr->nic = pfvf;
+
+	pfvf->ptp = ptp_ptr;
+
+error:
+	mutex_unlock(&ptp_mutex);
+	return err;
+}
+
+static void otx2_ptp_release(struct kref *kref)
+{
+	struct otx2_ptp *ptp = container_of(kref, struct otx2_ptp,
+					    refcount);
+	ptp_clock_unregister(ptp->ptp_clock);
+	kfree(ptp);
+}
+
+void otx2_ptp_destroy(struct otx2_nic *pfvf)
+{
+	if (!pfvf->ptp)
+		return;
+
+	mutex_lock(&ptp_mutex);
+
+	if (kref_put(&pfvf->ptp->refcount, otx2_ptp_release)) {
+		ptp_ptr = NULL;
+	} else if (ptp_ptr->nic == pfvf) {
+		dev_err(pfvf->dev, "orphaned ptp instance; incorrect order of nic destruction");
+		ptp_ptr->nic = NULL;
+	}
+	pfvf->ptp = NULL;
+
+	mutex_unlock(&ptp_mutex);
+}
+
+int otx2_ptp_clock_index(struct otx2_nic *pfvf)
+{
+	if (!pfvf->ptp)
+		return -ENODEV;
+
+	return ptp_clock_index(pfvf->ptp->ptp_clock);
+}
+
+int otx2_ptp_tstamp2time(struct otx2_nic *pfvf, u64 tstamp, u64 *tsns)
+{
+	if (!pfvf->ptp)
+		return -ENODEV;
+
+	*tsns = timecounter_cyc2time(&pfvf->ptp->time_counter, tstamp);
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.h b/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.h
new file mode 100644
index 000000000000..9ddb82cec195
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Marvell OcteonTx2 PTP support for ethernet driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef OTX2_PTP_H
+#define OTX2_PTP_H
+
+int otx2_ptp_init(struct otx2_nic *pfvf);
+void otx2_ptp_destroy(struct otx2_nic *pfvf);
+
+int otx2_ptp_clock_index(struct otx2_nic *pfvf);
+int otx2_ptp_tstamp2time(struct otx2_nic *pfvf, u64 tstamp, u64 *tsns);
+
+#endif
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h b/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h
index 6dd4db07c4a8..e64cd455e702 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h
@@ -66,6 +66,20 @@ enum nix_subdc {
 	NIX_SUBDC_SOD  = 0xf,
 };
 
+/* Algorithm for nix_sqe_mem_s header (value of the `alg` field) */
+enum nix_sendmemalg {
+	NIX_SENDMEMALG_E_SET       = 0x0,
+	NIX_SENDMEMALG_E_SETTSTMP  = 0x1,
+	NIX_SENDMEMALG_E_SETRSLT   = 0x2,
+	NIX_SENDMEMALG_E_ADD       = 0x8,
+	NIX_SENDMEMALG_E_SUB       = 0x9,
+	NIX_SENDMEMALG_E_ADDLEN    = 0xa,
+	NIX_SENDMEMALG_E_SUBLEN    = 0xb,
+	NIX_SENDMEMALG_E_ADDMBUF   = 0xc,
+	NIX_SENDMEMALG_E_SUBMBUF   = 0xd,
+	NIX_SENDMEMALG_E_ENUM_LAST = 0xe,
+};
+
 /* NIX CQE header structure */
 struct nix_cqe_hdr_s {
 #if defined(__BIG_ENDIAN_BITFIELD)
@@ -360,6 +374,26 @@ struct nix_sqe_sg_s {
 #endif
 };
 
+/* NIX send memory subdescriptor structure */
+struct nix_sqe_mem_s {
+#if defined(__BIG_ENDIAN_BITFIELD)  /* W0 */
+	u64 subdc         : 4;
+	u64 alg           : 4;
+	u64 dsz           : 2;
+	u64 wmem          : 1;
+	u64 rsvd_52_16    : 37;
+	u64 offset        : 16;
+#else
+	u64 offset        : 16;
+	u64 rsvd_52_16    : 37;
+	u64 wmem          : 1;
+	u64 dsz           : 2;
+	u64 alg           : 4;
+	u64 subdc         : 4;
+#endif
+	u64 addr;
+};
+
 enum nix_cqerrint_e {
 	NIX_CQERRINT_DOOR_ERR = 0,
 	NIX_CQERRINT_WR_FULL = 1,
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
index 0625b35614c9..2079a6947b60 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
@@ -16,6 +16,7 @@
 #include "otx2_common.h"
 #include "otx2_struct.h"
 #include "otx2_txrx.h"
+#include "otx2_ptp.h"
 
 /* Flush SQE written to LMT to SQB */
 static inline u64 otx2_lmt_flush(uint64_t addr)
@@ -93,6 +94,7 @@ static void otx2_snd_pkt_handler(struct otx2_nic *pfvf,
 	struct sk_buff *skb = NULL;
 	struct otx2_snd_queue *sq;
 	struct sg_list *sg;
+	int sqe_id;
 
 	snd_comp = (struct nix_send_comp_s *)(cqe + sizeof(*cqe_hdr));
 	if (snd_comp->status) {
@@ -104,16 +106,36 @@ static void otx2_snd_pkt_handler(struct otx2_nic *pfvf,
 	/* Barrier, so that update to sq by other cpus is visible */
 	smp_mb();
 	sq = &pfvf->qset.sq[cq->cint_idx];
-	sg = &sq->sg[snd_comp->sqe_id];
+	sqe_id = snd_comp->sqe_id;
+	sg = &sq->sg[sqe_id];
 
 	skb = (struct sk_buff *)sg->skb;
-	if (skb) {
-		*tx_bytes += skb->len;
-		(*tx_pkts)++;
-		otx2_dma_unmap_skb_frags(pfvf, sg);
-		napi_consume_skb(skb, budget);
-		sg->skb = (u64)NULL;
+	if (!skb)
+		return;
+
+	if (skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS) {
+		u64 timestamp = ((u64 *)sq->timestamps->base)[sqe_id];
+
+		if (timestamp != 1) {
+			u64 tsns;
+			int err;
+
+			err = otx2_ptp_tstamp2time(pfvf, timestamp, &tsns);
+			if (!err) {
+				struct skb_shared_hwtstamps ts;
+
+				memset(&ts, 0, sizeof(ts));
+				ts.hwtstamp = ns_to_ktime(tsns);
+				skb_tstamp_tx(skb, &ts);
+			}
+		}
 	}
+
+	*tx_bytes += skb->len;
+	(*tx_pkts)++;
+	otx2_dma_unmap_skb_frags(pfvf, sg);
+	napi_consume_skb(skb, budget);
+	sg->skb = (u64)NULL;
 }
 
 static inline void otx2_set_rxhash(struct otx2_nic *pfvf,
@@ -178,6 +200,25 @@ otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len, int apad)
 	return skb;
 }
 
+static inline void otx2_set_rxtstamp(struct otx2_nic *pfvf, struct sk_buff *skb)
+{
+	u64 tsns;
+	int err;
+
+	if (!pfvf->hw_rx_tstamp)
+		return;
+
+	/* The first 8 bytes is the timestamp */
+	err = otx2_ptp_tstamp2time(pfvf, *(u64 *)skb->data, &tsns);
+	if (err)
+		goto done;
+
+	skb_hwtstamps(skb)->hwtstamp = ns_to_ktime(tsns);
+
+done:
+	__skb_pull(skb, 8);
+}
+
 static void otx2_rcv_pkt_handler(struct otx2_nic *pfvf,
 				 struct otx2_cq_queue *cq, void *cqe,
 				 int *pool_ptrs)
@@ -229,11 +270,19 @@ static void otx2_rcv_pkt_handler(struct otx2_nic *pfvf,
 			/* Starting IOVA's 2:0 bits give alignment
 			 * bytes after which packet data starts.
 			 */
-			if (!skb)
+			if (!skb) {
 				skb = otx2_get_rcv_skb(pfvf, *iova,
 						       len, *iova & 0x07);
-			else
+				/* check if data starts at some nonzero offset
+				 * from the start of the buffer.  For now the
+				 * only possible offset is 8 bytes in the case
+				 * the packet data are prepended by a timestamp.
+				 */
+				if (parse->laptr)
+					otx2_set_rxtstamp(pfvf, skb);
+			} else {
 				otx2_skb_add_frag(pfvf, skb, *iova, len);
+			}
 			iova++;
 			(*pool_ptrs)++;
 		}
@@ -462,9 +511,6 @@ static void otx2_sqe_add_ext(struct otx2_nic *pfvf, struct otx2_snd_queue *sq,
 {
 	struct nix_sqe_ext_s *ext;
 
-	if (!skb_shinfo(skb)->gso_size)
-		return;
-
 	ext = (struct nix_sqe_ext_s *)(sq->sqe_base + *offset);
 	ext->subdc = NIX_SUBDC_EXT;
 	if (skb_shinfo(skb)->gso_size) {
@@ -476,11 +522,27 @@ static void otx2_sqe_add_ext(struct otx2_nic *pfvf, struct otx2_snd_queue *sq,
 			ext->lso_format = pfvf->hw.lso_tsov6_idx;
 		ext->lso_sb = skb_transport_offset(skb) + tcp_hdrlen(skb);
 		ext->lso_mps = skb_shinfo(skb)->gso_size;
+	} else if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+		ext->tstmp = 1;
 	}
 
 	*offset += sizeof(*ext);
 }
 
+static void otx2_sqe_add_mem(struct otx2_snd_queue *sq, int *offset,
+			     int alg, u64 iova)
+{
+	struct nix_sqe_mem_s *mem;
+
+	mem = (struct nix_sqe_mem_s *)(sq->sqe_base + *offset);
+	mem->subdc = NIX_SUBDC_MEM;
+	mem->alg = alg;
+	mem->wmem = 1; /* wait for the memory operation */
+	mem->addr = iova;
+
+	*offset += sizeof(*mem);
+}
+
 /* Add SQE header subdescriptor structure */
 static void otx2_sqe_add_hdr(struct otx2_nic *pfvf, struct otx2_snd_queue *sq,
 			     struct nix_sqe_hdr_s *sqe_hdr,
@@ -701,6 +763,21 @@ static int otx2_get_sqe_count(struct otx2_nic *pfvf, struct sk_buff *skb)
 	return skb_shinfo(skb)->gso_segs;
 }
 
+static inline void otx2_set_txtstamp(struct otx2_nic *pfvf, struct sk_buff *skb,
+				     struct otx2_snd_queue *sq, int *offset)
+{
+	u64 iova;
+
+	if (!skb_shinfo(skb)->gso_size &&
+	    skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+		iova = sq->timestamps->iova + (sq->head * sizeof(u64));
+		otx2_sqe_add_mem(sq, offset, NIX_SENDMEMALG_E_SETTSTMP, iova);
+	} else {
+		skb_tx_timestamp(skb);
+	}
+}
+
 bool otx2_sq_append_skb(struct net_device *netdev, struct otx2_snd_queue *sq,
 			struct sk_buff *skb, u16 qidx)
 {
@@ -750,6 +827,8 @@ bool otx2_sq_append_skb(struct net_device *netdev, struct otx2_snd_queue *sq,
 		return false;
 	}
 
+	otx2_set_txtstamp(pfvf, skb, sq, &offset);
+
 	sqe_hdr->sizem1 = (offset / 16) - 1;
 
 	netdev_tx_sent_queue(txq, skb->len);
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h
index 41fad18b740e..9890f99544b6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h
@@ -67,6 +67,7 @@ struct otx2_snd_queue {
 	struct qmem		*sqe;
 	struct qmem		*tso_hdrs;
 	struct sg_list		*sg;
+	struct qmem		*timestamps;
 	struct queue_stats	stats;
 };
 
-- 
2.17.1


From 52ea247efb075762951840ab549e7876ab7a3c26 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Sun, 27 May 2018 14:52:07 +0300
Subject: [PATCH 0639/1051] mvebu: io: workaround 64-bit register access
 limitation

Some units such as SMMU, have 64bit registers, and can't
access them using readq/writeq.
The kernel assumes 64-bit system are capable of accessing register
of 64-bit size, this is not true for Armada-7k/8k.

This patch introduces a new CONFIG value to differentiate
between 64-bit system and 64-bit register access.
The kernel use this config to fallback to 32-bit access.

The config will be enabled for A8k/A8k-plus system to avoid
creating duplicated defconfig file.

Change-Id: Id06a800a78653d752fc0ca3506cc9cfb9d723256
Signed-off-by: Hanna Hawa <hannah@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm64/Kconfig          |  6 ++++++
 arch/arm64/include/asm/io.h | 34 ++++++++++++++++++++++++++++++++++
 2 files changed, 40 insertions(+)

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 0edbe1898bdf..752ebfea963d 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -701,6 +701,12 @@ config CPU_BIG_ENDIAN
        help
          Say Y if you plan on running a kernel in big-endian mode.
 
+config MMIO_64BIT
+	bool "64BIT MMIO Access"
+	default n
+	help
+	  Say Y if you your platform supports 64bit MMIO access.
+
 config SCHED_MC
 	bool "Multi-core scheduler support"
 	help
diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 49bb9a020a09..964912f66133 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -55,10 +55,20 @@ static inline void __raw_writel(u32 val, volatile void __iomem *addr)
 }
 
 #define __raw_writeq __raw_writeq
+#ifdef CONFIG_MMIO_64BIT
 static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 {
 	asm volatile("str %x0, [%1]" : : "rZ" (val), "r" (addr));
 }
+#else
+static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
+{
+	u8 *low = (u8 *)addr;
+	u8 *high = low + 4;
+	asm volatile("str %w0, [%1]" : : "rZ" (val & U32_MAX), "r" (low));
+	asm volatile("str %w0, [%1]" : : "rZ" (val >> 32), "r" (high));
+}
+#endif
 
 #define __raw_readb __raw_readb
 static inline u8 __raw_readb(const volatile void __iomem *addr)
@@ -95,6 +105,7 @@ static inline u32 __raw_readl(const volatile void __iomem *addr)
 }
 
 #define __raw_readq __raw_readq
+#ifdef CONFIG_MMIO_64BIT
 static inline u64 __raw_readq(const volatile void __iomem *addr)
 {
 	u64 val;
@@ -104,6 +115,29 @@ static inline u64 __raw_readq(const volatile void __iomem *addr)
 		     : "=r" (val) : "r" (addr));
 	return val;
 }
+#else
+static inline u64 __raw_readq(const volatile void __iomem *addr)
+{
+	u64 val = 0;
+	u32 temp;
+	u8 *low = (u8 *)addr;
+	u8 *high = low + 4;
+
+	asm volatile(ALTERNATIVE("ldr %w0, [%1]",
+				 "ldar %w0, [%1]",
+				 ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE)
+		     : "=r" (temp) : "r" (high));
+	val = temp;
+	val = val << 32;
+	asm volatile(ALTERNATIVE("ldr %w0, [%1]",
+				 "ldar %w0, [%1]",
+				 ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE)
+		     : "=r" (temp) : "r" (low));
+	val |= temp;
+
+	return val;
+}
+#endif
 
 /* IO barriers */
 #define __iormb(v)							\
-- 
2.17.1


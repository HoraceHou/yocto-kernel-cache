From 045ca9f224071aed1311ea410911cc736973f545 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Wed, 30 Jan 2019 21:12:31 +0530
Subject: [PATCH 0945/1051] soc: octeontx2: Sync FLOW_KEY_TYPE_XX macro naming
 to upstream

Rename FLOW_KEY_TYPE_XX macros to NIX_FLOW_KEY_TYPE_XX

Change-Id: I5f48b14b4e64d38a5e56932cf9b4540464847bcc
Signed-off-by: Jerin Jacob <jerinj@marvell.com>
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/3485
Tested-by: Linu Cherian <Linu.Cherian@cavium.com>
Reviewed-by: Linu Cherian <Linu.Cherian@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/otx2_common.c  |  6 +-
 .../ethernet/marvell/octeontx2/otx2_ethtool.c | 23 ++++----
 .../ethernet/marvell/octeontx2/otx2_txrx.c    |  2 +-
 drivers/soc/marvell/octeontx2/mbox.h          | 12 ++--
 drivers/soc/marvell/octeontx2/rvu.h           |  4 +-
 drivers/soc/marvell/octeontx2/rvu_nix.c       | 59 ++++++++++---------
 6 files changed, 55 insertions(+), 51 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index d0748857e5d2..20dbe7b41191 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -176,9 +176,9 @@ int otx2_rss_init(struct otx2_nic *pfvf)
 		return ret;
 
 	/* Default flowkey or hash config to be used for generating flow tag */
-	rss->flowkey_cfg = FLOW_KEY_TYPE_IPV4 | FLOW_KEY_TYPE_IPV6 |
-			   FLOW_KEY_TYPE_TCP | FLOW_KEY_TYPE_UDP |
-			   FLOW_KEY_TYPE_SCTP;
+	rss->flowkey_cfg = NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6 |
+			   NIX_FLOW_KEY_TYPE_TCP | NIX_FLOW_KEY_TYPE_UDP |
+			   NIX_FLOW_KEY_TYPE_SCTP;
 
 	return otx2_set_flowkey_cfg(pfvf);
 }
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c
index 21e51913568f..f8aa48dd9fa7 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_ethtool.c
@@ -397,7 +397,8 @@ static int otx2_get_rss_hash_opts(struct otx2_nic *pfvf,
 {
 	struct otx2_rss_info *rss = &pfvf->hw.rss_info;
 
-	if (!(rss->flowkey_cfg & (FLOW_KEY_TYPE_IPV4 | FLOW_KEY_TYPE_IPV6)))
+	if (!(rss->flowkey_cfg & (NIX_FLOW_KEY_TYPE_IPV4 |
+				  NIX_FLOW_KEY_TYPE_IPV6)))
 		return 0;
 
 	/* Mimimum is IPv4 and IPv6, SIP/DIP */
@@ -406,17 +407,17 @@ static int otx2_get_rss_hash_opts(struct otx2_nic *pfvf,
 	switch (nfc->flow_type) {
 	case TCP_V4_FLOW:
 	case TCP_V6_FLOW:
-		if (rss->flowkey_cfg & FLOW_KEY_TYPE_TCP)
+		if (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_TCP)
 			nfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
 		break;
 	case UDP_V4_FLOW:
 	case UDP_V6_FLOW:
-		if (rss->flowkey_cfg & FLOW_KEY_TYPE_UDP)
+		if (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_UDP)
 			nfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
 		break;
 	case SCTP_V4_FLOW:
 	case SCTP_V6_FLOW:
-		if (rss->flowkey_cfg & FLOW_KEY_TYPE_SCTP)
+		if (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_SCTP)
 			nfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
 		break;
 	case AH_ESP_V4_FLOW:
@@ -455,23 +456,23 @@ static int otx2_set_rss_hash_opts(struct otx2_nic *pfvf,
 		 * Both of them have to be either 4-tuple or 2-tuple.
 		 */
 		if ((nfc->data & rxh_l4) == rxh_l4)
-			rss_cfg |= FLOW_KEY_TYPE_TCP;
+			rss_cfg |= NIX_FLOW_KEY_TYPE_TCP;
 		else
-			rss_cfg &= ~FLOW_KEY_TYPE_TCP;
+			rss_cfg &= ~NIX_FLOW_KEY_TYPE_TCP;
 		break;
 	case UDP_V4_FLOW:
 	case UDP_V6_FLOW:
 		if ((nfc->data & rxh_l4) == rxh_l4)
-			rss_cfg |= FLOW_KEY_TYPE_UDP;
+			rss_cfg |= NIX_FLOW_KEY_TYPE_UDP;
 		else
-			rss_cfg &= ~FLOW_KEY_TYPE_UDP;
+			rss_cfg &= ~NIX_FLOW_KEY_TYPE_UDP;
 		break;
 	case SCTP_V4_FLOW:
 	case SCTP_V6_FLOW:
 		if ((nfc->data & rxh_l4) == rxh_l4)
-			rss_cfg |= FLOW_KEY_TYPE_SCTP;
+			rss_cfg |= NIX_FLOW_KEY_TYPE_SCTP;
 		else
-			rss_cfg &= ~FLOW_KEY_TYPE_SCTP;
+			rss_cfg &= ~NIX_FLOW_KEY_TYPE_SCTP;
 		break;
 	case AH_ESP_V4_FLOW:
 	case AH_V4_FLOW:
@@ -481,7 +482,7 @@ static int otx2_set_rss_hash_opts(struct otx2_nic *pfvf,
 	case AH_V6_FLOW:
 	case ESP_V6_FLOW:
 	case IPV6_FLOW:
-		rss_cfg = FLOW_KEY_TYPE_IPV4 | FLOW_KEY_TYPE_IPV6;
+		rss_cfg = NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6;
 		break;
 	default:
 		return -EINVAL;
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
index 09413204bd75..5fd8d434540e 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
@@ -152,7 +152,7 @@ static inline void otx2_set_rxhash(struct otx2_nic *pfvf,
 	rss = &pfvf->hw.rss_info;
 	if (rss->flowkey_cfg) {
 		if (rss->flowkey_cfg &
-		    ~(FLOW_KEY_TYPE_IPV4 | FLOW_KEY_TYPE_IPV6))
+		    ~(NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6))
 			hash_type = PKT_HASH_TYPE_L4;
 		else
 			hash_type = PKT_HASH_TYPE_L3;
diff --git a/drivers/soc/marvell/octeontx2/mbox.h b/drivers/soc/marvell/octeontx2/mbox.h
index e77fe643f5b5..1eed17b71cf8 100644
--- a/drivers/soc/marvell/octeontx2/mbox.h
+++ b/drivers/soc/marvell/octeontx2/mbox.h
@@ -625,12 +625,12 @@ struct nix_rss_flowkey_cfg {
 	struct mbox_msghdr hdr;
 	int	mcam_index;  /* MCAM entry index to modify */
 	u32	flowkey_cfg; /* Flowkey types selected */
-#define FLOW_KEY_TYPE_PORT	BIT(0)
-#define FLOW_KEY_TYPE_IPV4	BIT(1)
-#define FLOW_KEY_TYPE_IPV6	BIT(2)
-#define FLOW_KEY_TYPE_TCP	BIT(3)
-#define FLOW_KEY_TYPE_UDP	BIT(4)
-#define FLOW_KEY_TYPE_SCTP	BIT(5)
+#define NIX_FLOW_KEY_TYPE_PORT	BIT(0)
+#define NIX_FLOW_KEY_TYPE_IPV4	BIT(1)
+#define NIX_FLOW_KEY_TYPE_IPV6	BIT(2)
+#define NIX_FLOW_KEY_TYPE_TCP	BIT(3)
+#define NIX_FLOW_KEY_TYPE_UDP	BIT(4)
+#define NIX_FLOW_KEY_TYPE_SCTP	BIT(5)
 	u8	group;       /* RSS context or group */
 };
 
diff --git a/drivers/soc/marvell/octeontx2/rvu.h b/drivers/soc/marvell/octeontx2/rvu.h
index 4e99b36e2cf5..18d331ef4732 100644
--- a/drivers/soc/marvell/octeontx2/rvu.h
+++ b/drivers/soc/marvell/octeontx2/rvu.h
@@ -210,8 +210,8 @@ struct npc_pkind {
 };
 
 struct nix_flowkey {
-#define FLOW_KEY_ALG_MAX 32
-	u32 flowkey[FLOW_KEY_ALG_MAX];
+#define NIX_FLOW_KEY_ALG_MAX 32
+	u32 flowkey[NIX_FLOW_KEY_ALG_MAX];
 	int in_use;
 };
 
diff --git a/drivers/soc/marvell/octeontx2/rvu_nix.c b/drivers/soc/marvell/octeontx2/rvu_nix.c
index 97d07695b790..4ea83e8bbd23 100644
--- a/drivers/soc/marvell/octeontx2/rvu_nix.c
+++ b/drivers/soc/marvell/octeontx2/rvu_nix.c
@@ -2074,14 +2074,14 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			memset(&tmp, 0, sizeof(tmp));
 
 		switch (key_type) {
-		case FLOW_KEY_TYPE_PORT:
+		case NIX_FLOW_KEY_TYPE_PORT:
 			field->sel_chan = true;
 			/* This should be set to 1, when SEL_CHAN is set */
 			field->bytesm1 = 1;
 			field_marker = true;
 			keyoff_marker = true;
 			break;
-		case FLOW_KEY_TYPE_IPV4:
+		case NIX_FLOW_KEY_TYPE_IPV4:
 			field->lid = NPC_LID_LC;
 			field->ltype_match = NPC_LT_LC_IP;
 			field->hdr_offset = 12; /* SIP offset */
@@ -2090,7 +2090,7 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field_marker = true;
 			keyoff_marker = false;
 			break;
-		case FLOW_KEY_TYPE_IPV6:
+		case NIX_FLOW_KEY_TYPE_IPV6:
 			field->lid = NPC_LID_LC;
 			field->ltype_match = NPC_LT_LC_IP6;
 			field->hdr_offset = 8; /* SIP offset */
@@ -2099,24 +2099,24 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 			field_marker = true;
 			keyoff_marker = true;
 			break;
-		case FLOW_KEY_TYPE_TCP:
-		case FLOW_KEY_TYPE_UDP:
-		case FLOW_KEY_TYPE_SCTP:
+		case NIX_FLOW_KEY_TYPE_TCP:
+		case NIX_FLOW_KEY_TYPE_UDP:
+		case NIX_FLOW_KEY_TYPE_SCTP:
 			field->lid = NPC_LID_LD;
 			field->bytesm1 = 3; /* Sport + Dport, 4 bytes */
-			if (key_type == FLOW_KEY_TYPE_TCP && valid_key) {
+			if (key_type == NIX_FLOW_KEY_TYPE_TCP && valid_key) {
 				field->ltype_match |= NPC_LT_LD_TCP;
 				group_member = true;
-			} else if (key_type == FLOW_KEY_TYPE_UDP && valid_key) {
+			} else if (key_type == NIX_FLOW_KEY_TYPE_UDP && valid_key) {
 				field->ltype_match |= NPC_LT_LD_UDP;
 				group_member = true;
-			} else if (key_type == FLOW_KEY_TYPE_SCTP
+			} else if (key_type == NIX_FLOW_KEY_TYPE_SCTP
 								&& valid_key) {
 				field->ltype_match |= NPC_LT_LD_SCTP;
 				group_member = true;
 			}
 			field->ltype_mask = ~field->ltype_match;
-			if (key_type == FLOW_KEY_TYPE_SCTP) {
+			if (key_type == NIX_FLOW_KEY_TYPE_SCTP) {
 				/* Handle the case where any of the group item
 				 * is enabled in the group but not the final one
 				 */
@@ -2161,15 +2161,15 @@ static int set_flowkey_fields(struct nix_rx_flowkey_alg *alg, u32 flow_cfg)
 static int reserve_flowkey_alg_idx(struct rvu *rvu, int blkaddr, u32 flow_cfg)
 {
 	u64 field[FIELDS_PER_ALG];
-	struct nix_hw *nix_hw;
+	struct nix_hw *hw;
 	int fid, rc;
 
-	nix_hw = get_nix_hw(rvu->hw, blkaddr);
-	if (!nix_hw)
+	hw = get_nix_hw(rvu->hw, blkaddr);
+	if (!hw)
 		return -EINVAL;
 
 	/* No room to add new flow hash algoritham */
-	if (nix_hw->flowkey.in_use >= FLOW_KEY_ALG_MAX)
+	if (hw->flowkey.in_use >= NIX_FLOW_KEY_ALG_MAX)
 		return NIX_AF_ERR_RSS_NOSPC_ALGO;
 
 	/* Generate algo fields for the given flow_cfg */
@@ -2180,13 +2180,13 @@ static int reserve_flowkey_alg_idx(struct rvu *rvu, int blkaddr, u32 flow_cfg)
 	/* Update ALGX_FIELDX register with generated fields */
 	for (fid = 0; fid < FIELDS_PER_ALG; fid++)
 		rvu_write64(rvu, blkaddr,
-			NIX_AF_RX_FLOW_KEY_ALGX_FIELDX(nix_hw->flowkey.in_use,
+			    NIX_AF_RX_FLOW_KEY_ALGX_FIELDX(hw->flowkey.in_use,
 			fid), field[fid]);
 
 	/* Store the flow_cfg for futher lookup */
-	rc = nix_hw->flowkey.in_use;
-	nix_hw->flowkey.flowkey[rc] = flow_cfg;
-	nix_hw->flowkey.in_use++;
+	rc = hw->flowkey.in_use;
+	hw->flowkey.flowkey[rc] = flow_cfg;
+	hw->flowkey.in_use++;
 
 	return rc;
 }
@@ -2232,58 +2232,61 @@ static int nix_rx_flowkey_alg_cfg(struct rvu *rvu, int blkaddr)
 	int alg, fid, rc;
 
 	/* Disable all flow key algx fieldx */
-	for (alg = 0; alg < FLOW_KEY_ALG_MAX; alg++) {
+	for (alg = 0; alg < NIX_FLOW_KEY_ALG_MAX; alg++) {
 		for (fid = 0; fid < FIELDS_PER_ALG; fid++)
 			rvu_write64(rvu, blkaddr,
 			NIX_AF_RX_FLOW_KEY_ALGX_FIELDX(alg, fid), 0);
 	}
 
 	/* IPv4/IPv6 SIP/DIPs */
-	flowkey_cfg = FLOW_KEY_TYPE_IPV4 | FLOW_KEY_TYPE_IPV6;
+	flowkey_cfg = NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* TCPv4/v6 4-tuple, SIP, DIP, Sport, Dport */
 	minkey_cfg = flowkey_cfg;
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_TCP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_TCP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* UDPv4/v6 4-tuple, SIP, DIP, Sport, Dport */
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_UDP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_UDP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* SCTPv4/v6 4-tuple, SIP, DIP, Sport, Dport */
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_SCTP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_SCTP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* TCP/UDP v4/v6 4-tuple, rest IP pkts 2-tuple */
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_TCP | FLOW_KEY_TYPE_UDP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_TCP |
+			NIX_FLOW_KEY_TYPE_UDP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* TCP/SCTP v4/v6 4-tuple, rest IP pkts 2-tuple */
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_TCP | FLOW_KEY_TYPE_SCTP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_TCP |
+			NIX_FLOW_KEY_TYPE_SCTP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* UDP/SCTP v4/v6 4-tuple, rest IP pkts 2-tuple */
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_UDP | FLOW_KEY_TYPE_SCTP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_UDP |
+			NIX_FLOW_KEY_TYPE_SCTP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
 
 	/* TCP/UDP/SCTP v4/v6 4-tuple, rest IP pkts 2-tuple */
-	flowkey_cfg = minkey_cfg | FLOW_KEY_TYPE_TCP |
-		      FLOW_KEY_TYPE_UDP | FLOW_KEY_TYPE_SCTP;
+	flowkey_cfg = minkey_cfg | NIX_FLOW_KEY_TYPE_TCP |
+		      NIX_FLOW_KEY_TYPE_UDP | NIX_FLOW_KEY_TYPE_SCTP;
 	rc = reserve_flowkey_alg_idx(rvu, blkaddr, flowkey_cfg);
 	if (rc < 0)
 		return rc;
-- 
2.17.1


From c4a9f768cfbfa04e55cf0d733bbdc2768cce0cf2 Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Sat, 6 Oct 2018 06:53:27 +0300
Subject: [PATCH 0219/1051] soc: octeontx2: Do CGX init before NIX init

NIX init has dependency on CGX init.
Hence do CGX init before NIX init.

As a side effect,
Partly revert "soc: octeontx2: Fix MCE entry init for bcast tables"

Few related cleanups
- rvu_cgx_probe renamed as rvu_cgx_init for consistency
- Moved out unrelated code from cgx_lmac_event_handler_init
- Added error check on cgx_lmac_event_handler_init
- Handled a corner case for cgx_get_lmac_cnt in nix_link_config

Signed-off-by: Linu Cherian <lcherian@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/octeontx2/rvu.c     | 28 ++++++++------
 drivers/soc/marvell/octeontx2/rvu.h     |  2 +-
 drivers/soc/marvell/octeontx2/rvu_cgx.c | 50 ++++++++++++++++---------
 drivers/soc/marvell/octeontx2/rvu_nix.c |  6 ++-
 4 files changed, 54 insertions(+), 32 deletions(-)

diff --git a/drivers/soc/marvell/octeontx2/rvu.c b/drivers/soc/marvell/octeontx2/rvu.c
index fad6cee58ead..608c476fbe33 100644
--- a/drivers/soc/marvell/octeontx2/rvu.c
+++ b/drivers/soc/marvell/octeontx2/rvu.c
@@ -792,25 +792,34 @@ static int rvu_setup_hw_resources(struct rvu *rvu)
 
 	err = rvu_npc_init(rvu);
 	if (err)
-		return err;
+		goto exit;
+
+	err = rvu_cgx_init(rvu);
+	if (err)
+		goto exit;
 
 	err = rvu_npa_init(rvu);
 	if (err)
-		return err;
+		goto cgx_err;
 
 	err = rvu_nix_init(rvu);
 	if (err)
-		return err;
+		goto cgx_err;
 
 	err = rvu_sso_init(rvu);
 	if (err)
-		return err;
+		goto cgx_err;
 
 	err = rvu_tim_init(rvu);
 	if (err)
-		return err;
+		goto cgx_err;
 
 	return 0;
+
+cgx_err:
+	rvu_cgx_wq_destroy(rvu);
+exit:
+	return err;
 }
 
 /* NPA and NIX admin queue APIs */
@@ -2472,13 +2481,9 @@ static int rvu_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (err)
 		goto err_hwsetup;
 
-	err = rvu_cgx_probe(rvu);
-	if (err)
-		goto err_mbox;
-
 	err = rvu_flr_init(rvu);
 	if (err)
-		goto err_cgx;
+		goto err_mbox;
 
 	err = rvu_register_interrupts(rvu);
 	if (err)
@@ -2503,11 +2508,10 @@ static int rvu_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	rvu_unregister_interrupts(rvu);
 err_flr:
 	rvu_flr_wq_destroy(rvu);
-err_cgx:
-	rvu_cgx_wq_destroy(rvu);
 err_mbox:
 	rvu_mbox_destroy(&rvu->afpf_wq_info);
 err_hwsetup:
+	rvu_cgx_wq_destroy(rvu);
 	rvu_reset_all_blocks(rvu);
 	rvu_free_hw_resources(rvu);
 err_release_regions:
diff --git a/drivers/soc/marvell/octeontx2/rvu.h b/drivers/soc/marvell/octeontx2/rvu.h
index f7fa00b29d92..d666d3c5459e 100644
--- a/drivers/soc/marvell/octeontx2/rvu.h
+++ b/drivers/soc/marvell/octeontx2/rvu.h
@@ -366,7 +366,7 @@ static inline void rvu_get_cgx_lmac_id(u8 map, u8 *cgx_id, u8 *lmac_id)
 	*lmac_id = (map & 0xF);
 }
 
-int rvu_cgx_probe(struct rvu *rvu);
+int rvu_cgx_init(struct rvu *rvu);
 int rvu_check_cgx_driver(struct rvu *rvu);
 void rvu_cgx_wq_destroy(struct rvu *rvu);
 void *rvu_cgx_pdata(u8 cgx_id, struct rvu *rvu);
diff --git a/drivers/soc/marvell/octeontx2/rvu_cgx.c b/drivers/soc/marvell/octeontx2/rvu_cgx.c
index a1c7c23a5b35..d14d6868bcfa 100644
--- a/drivers/soc/marvell/octeontx2/rvu_cgx.c
+++ b/drivers/soc/marvell/octeontx2/rvu_cgx.c
@@ -215,7 +215,7 @@ static void cgx_evhandler_task(struct work_struct *work)
 	} while (1);
 }
 
-static void cgx_lmac_event_handler_init(struct rvu *rvu)
+static int cgx_lmac_event_handler_init(struct rvu *rvu)
 {
 	struct cgx_event_cb cb;
 	int cgx, lmac, err;
@@ -227,7 +227,7 @@ static void cgx_lmac_event_handler_init(struct rvu *rvu)
 	rvu->cgx_evh_wq = alloc_workqueue("rvu_evh_wq", 0, 0);
 	if (!rvu->cgx_evh_wq) {
 		dev_err(rvu->dev, "alloc workqueue failed");
-		return;
+		return -ENOMEM;
 	}
 
 	cb.notify_link_chg = cgx_lmac_postevent; /* link change call back */
@@ -244,18 +244,9 @@ static void cgx_lmac_event_handler_init(struct rvu *rvu)
 					"%d:%d handler register failed\n",
 					cgx, lmac);
 		}
-		/* Ensure event handler registration is completed, before
-		 * we turn on the links
-		 */
-		mb();
-
-		/* Start the link up procedure on all lmac ports */
-		err = cgx_lmac_linkup_start(cgxd);
-		if (err)
-			dev_err(rvu->dev,
-				"Link up process failed to start on cgx %d\n",
-				cgx);
 	}
+
+	return 0;
 }
 
 void rvu_cgx_wq_destroy(struct rvu *rvu)
@@ -267,9 +258,10 @@ void rvu_cgx_wq_destroy(struct rvu *rvu)
 	}
 }
 
-int rvu_cgx_probe(struct rvu *rvu)
+int rvu_cgx_init(struct rvu *rvu)
 {
-	int i, err;
+	int cgx, lmac, err;
+	void *cgxd;
 
 	/* CGX port id starts from 0 and are not necessarily contiguous
 	 * Hence we allocate resources based on the maximum port id value.
@@ -286,8 +278,8 @@ int rvu_cgx_probe(struct rvu *rvu)
 		return -ENOMEM;
 
 	/* Initialize the cgxdata table */
-	for (i = 0; i < rvu->cgx_cnt_max; i++)
-		rvu->cgx_idmap[i] = cgx_get_pdata(i);
+	for (cgx = 0; cgx < rvu->cgx_cnt_max; cgx++)
+		rvu->cgx_idmap[cgx] = cgx_get_pdata(cgx);
 
 	/* Map CGX LMAC interfaces to RVU PFs */
 	err = rvu_map_cgx_lmac_pf(rvu);
@@ -295,7 +287,29 @@ int rvu_cgx_probe(struct rvu *rvu)
 		return err;
 
 	/* Register for CGX events */
-	cgx_lmac_event_handler_init(rvu);
+	err = cgx_lmac_event_handler_init(rvu);
+	if (err)
+		return err;
+
+	/* Ensure event handler registration is completed, before
+	 * we turn on the links
+	 */
+	mb();
+
+	/* Do link up for all CGX ports */
+	for (cgx = 0; cgx <= rvu->cgx_cnt_max; cgx++) {
+		cgxd = rvu_cgx_pdata(cgx, rvu);
+		if (!cgxd)
+			continue;
+		for (lmac = 0; lmac < cgx_get_lmac_cnt(cgxd); lmac++) {
+			err = cgx_lmac_linkup_start(cgxd);
+			if (err)
+				dev_err(rvu->dev,
+					"Link up process failed to start on cgx %d\n",
+					cgx);
+		}
+	}
+
 	return 0;
 }
 
diff --git a/drivers/soc/marvell/octeontx2/rvu_nix.c b/drivers/soc/marvell/octeontx2/rvu_nix.c
index ded2ce0895ac..b3bb372e45e7 100644
--- a/drivers/soc/marvell/octeontx2/rvu_nix.c
+++ b/drivers/soc/marvell/octeontx2/rvu_nix.c
@@ -1723,7 +1723,7 @@ static int nix_setup_bcast_tables(struct rvu *rvu, struct nix_hw *nix_hw)
 	u64 cfg;
 
 	/* Skip PF0 (i.e AF) */
-	for (pf = 1; pf < (rvu->hw->cgx_links + 1); pf++) {
+	for (pf = 1; pf < (rvu->cgx_mapped_pfs + 1); pf++) {
 		cfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));
 		/* If PF is not enabled, nothing to do */
 		if (!((cfg >> 20) & 0x01))
@@ -2377,7 +2377,11 @@ static void nix_link_config(struct rvu *rvu, int blkaddr)
 	 */
 	for (cgx = 0; cgx < hw->cgx; cgx++) {
 		lmac_cnt = cgx_get_lmac_cnt(rvu_cgx_pdata(cgx, rvu));
+		/* Skip when cgx is not available or lmac cnt is zero */
+		if (lmac_cnt <= 0)
+			continue;
 		tx_credits = ((CGX_FIFO_LEN / lmac_cnt) - NIC_HW_MAX_FRS) / 16;
+
 		/* Enable credits and set credit pkt count to max allowed */
 		tx_credits =  (tx_credits << 12) | (0x1FF << 2) | BIT_ULL(1);
 		slink = cgx * hw->lmac_per_cgx;
-- 
2.17.1


From 88faf3d3cb30dd527d0dcd338344e6ad5a391719 Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Sat, 11 Aug 2018 16:43:48 +0530
Subject: [PATCH 0115/1051] net: octeontx2: MAC address configuration support

This patch adds support to set PF netdev's MAC address.
Address will be synced to AF via mbox to update this
PF's NIXLF's unicast NPC MCAM entry for DMAC maching.

Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/otx2_common.c  | 44 ++++++++++++++++++-
 .../ethernet/marvell/octeontx2/otx2_common.h  |  3 ++
 .../net/ethernet/marvell/octeontx2/otx2_pf.c  | 15 ++++++-
 3 files changed, 60 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index 8e459aeeb77c..dfe760bfcaaf 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -15,6 +15,44 @@
 #include "otx2_common.h"
 #include "otx2_struct.h"
 
+/* Sync MAC address with RVU */
+int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, struct net_device *netdev)
+{
+	struct nix_set_mac_addr *req;
+
+	req = otx2_mbox_alloc_msg_NIX_SET_MAC_ADDR(&pfvf->mbox);
+	if (!req)
+		return -ENOMEM;
+
+	ether_addr_copy(req->mac_addr, netdev->dev_addr);
+
+	return otx2_sync_mbox_msg(&pfvf->mbox);
+}
+
+int otx2_set_mac_address(struct net_device *netdev, void *p)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+	struct sockaddr *addr = p;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+
+	/* If mbox irq (i.e MSIX) is disabled then mark this
+	 * change as pending and return, AF will be synced
+	 * once irqs are re-enabled.
+	 */
+	if (pfvf->hw.num_vec) {
+		if (otx2_hw_set_mac_addr(pfvf, netdev))
+			return -EBUSY;
+	} else {
+		pfvf->set_mac_pending = true;
+	}
+
+	return 0;
+}
+
 void otx2_get_dev_stats(struct otx2_nic *pfvf)
 {
 	struct otx2_dev_stats *dev_stats = &pfvf->hw.dev_stats;
@@ -782,7 +820,11 @@ void mbox_handler_NIX_LF_ALLOC(struct otx2_nic *pfvf,
 	pfvf->hw.sqb_size = rsp->sqb_size;
 	pfvf->rx_chan_base = rsp->rx_chan_base;
 	pfvf->tx_chan_base = rsp->tx_chan_base;
-	ether_addr_copy(pfvf->netdev->dev_addr, rsp->mac_addr);
+	/* If a MAC address change is pending then don't
+	 * overwrite 'netdev->dev_addr'.
+	 */
+	if (!pfvf->set_mac_pending)
+		ether_addr_copy(pfvf->netdev->dev_addr, rsp->mac_addr);
 }
 
 void mbox_handler_MSIX_OFFSET(struct otx2_nic *pfvf,
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index c3b42bfc3fb8..894d08cc400f 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -120,6 +120,7 @@ struct otx2_nic {
 	struct mbox		mbox;
 	struct workqueue_struct *mbox_wq;
 	bool			intf_down;
+	bool			set_mac_pending;
 	u16			pcifunc;
 	u16			rx_chan_base;
 	u16			tx_chan_base;
@@ -272,6 +273,8 @@ void otx2_get_dev_stats(struct otx2_nic *pfvf);
 void otx2_get_stats64(struct net_device *netdev,
 		      struct rtnl_link_stats64 *stats);
 void otx2_set_irq_affinity(struct otx2_nic *pfvf);
+int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, struct net_device *netdev);
+int otx2_set_mac_address(struct net_device *netdev, void *p);
 
 /* Mbox handlers */
 void mbox_handler_MSIX_OFFSET(struct otx2_nic *pfvf,
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 3c0866c8a7f1..62f5e0f3f2ef 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -484,8 +484,20 @@ static int otx2_open(struct net_device *netdev)
 	}
 
 	/* Check if MAC address from AF is valid or else set a random MAC */
-	if (is_zero_ether_addr(netdev->dev_addr))
+	if (is_zero_ether_addr(netdev->dev_addr)) {
 		eth_hw_addr_random(netdev);
+		err = otx2_hw_set_mac_addr(pf, netdev);
+		if (err)
+			goto cleanup;
+	}
+
+	/* Sync new MAC address to AF, if a change is pending */
+	if (pf->set_mac_pending) {
+		err = otx2_hw_set_mac_addr(pf, netdev);
+		if (err)
+			goto cleanup;
+		pf->set_mac_pending = false;
+	}
 
 	/* Register CQ IRQ handlers */
 	vec = pf->hw.nix_msixoff + NIX_LF_CINT_VEC_START;
@@ -586,6 +598,7 @@ static const struct net_device_ops otx2_netdev_ops = {
 	.ndo_open		= otx2_open,
 	.ndo_stop		= otx2_stop,
 	.ndo_start_xmit		= otx2_xmit,
+	.ndo_set_mac_address    = otx2_set_mac_address,
 	.ndo_get_stats64	= otx2_get_stats64,
 };
 
-- 
2.17.1


From 6b0248bfc96cfb9499f12f3a18a90ec7e8956f05 Mon Sep 17 00:00:00 2001
From: Linu Cherian <linu.cherian@cavium.com>
Date: Tue, 30 Oct 2018 12:23:40 +0530
Subject: [PATCH 0361/1051] soc: octeontx2: Make cgx firmware interface header
 endian friendly

For supporting big/little endians in a clean way,
change the struct/bitfield/union definitions to bitmask/bitwise operations.

Signed-off-by: Linu Cherian <linu.cherian@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/octeontx2/cgx.c       | 137 ++++++++++------------
 drivers/soc/marvell/octeontx2/cgx_fw_if.h | 105 ++++++-----------
 2 files changed, 96 insertions(+), 146 deletions(-)

diff --git a/drivers/soc/marvell/octeontx2/cgx.c b/drivers/soc/marvell/octeontx2/cgx.c
index 944d66fa1715..c1bff182314a 100644
--- a/drivers/soc/marvell/octeontx2/cgx.c
+++ b/drivers/soc/marvell/octeontx2/cgx.c
@@ -43,7 +43,7 @@
 struct lmac {
 	wait_queue_head_t wq_cmd_cmplt;
 	struct mutex cmd_lock;
-	struct cgx_evt_sts resp;
+	u64 resp;
 	struct cgx_link_user_info link_info;
 	struct cgx_event_cb event_cb;
 	spinlock_t event_cb_lock;
@@ -328,14 +328,12 @@ int cgx_lmac_rx_tx_enable(void *cgxd, int lmac_id, bool enable)
 EXPORT_SYMBOL(cgx_lmac_rx_tx_enable);
 
 /* CGX Firmware interface low level support */
-static int cgx_fwi_cmd_send(struct cgx_cmd *cmd, struct cgx_evt_sts *rsp,
-			    struct lmac *lmac)
+static int cgx_fwi_cmd_send(u64 req, u64 *resp, struct lmac *lmac)
 {
 	struct cgx *cgx = lmac->cgx;
-	union cgx_cmdreg creg;
-	union cgx_evtreg ereg;
 	struct device *dev;
 	int err = 0;
+	u64 cmd;
 
 	/* Ensure no other command is in progress */
 	err = mutex_lock_interruptible(&lmac->cmd_lock);
@@ -343,44 +341,34 @@ static int cgx_fwi_cmd_send(struct cgx_cmd *cmd, struct cgx_evt_sts *rsp,
 		return err;
 
 	/* Ensure command register is free */
-	creg.val = cgx_read(cgx, lmac->lmac_id,  CGX_COMMAND_REG);
-	if (creg.cmd.own != CGX_CMD_OWN_NS) {
+	cmd = cgx_read(cgx, lmac->lmac_id,  CGX_COMMAND_REG);
+	if (FIELD_GET(CMDREG_OWN, cmd) != CGX_CMD_OWN_NS) {
 		err = -EBUSY;
 		goto unlock;
 	}
 
 	/* Update ownership in command request */
-	cmd->own = CGX_CMD_OWN_FIRMWARE;
+	req = FIELD_SET(CMDREG_OWN, CGX_CMD_OWN_FIRMWARE, req);
 
 	/* Mark this lmac as pending, before we start */
 	lmac->cmd_pend = true;
 
 	/* Start command in hardware */
-	creg.cmd = *cmd;
-	cgx_write(cgx, lmac->lmac_id, CGX_COMMAND_REG, creg.val);
-	creg.val = cgx_read(cgx, lmac->lmac_id,  CGX_COMMAND_REG);
+	cgx_write(cgx, lmac->lmac_id, CGX_COMMAND_REG, req);
 
 	/* Ensure command is completed without errors */
 	if (!wait_event_timeout(lmac->wq_cmd_cmplt, !lmac->cmd_pend,
 				msecs_to_jiffies(CGX_CMD_TIMEOUT))) {
 		dev = &cgx->pdev->dev;
-		ereg.val = cgx_read(cgx, lmac->lmac_id,  CGX_EVENT_REG);
-		if (ereg.val) {
-			dev_err(dev, "cgx port %d:%d: No event for response\n",
-				cgx->cgx_id, lmac->lmac_id);
-			/* copy event */
-			lmac->resp = ereg.evt_sts;
-		} else {
-			dev_err(dev, "cgx port %d:%d cmd timeout\n",
-				cgx->cgx_id, lmac->lmac_id);
-			err = -EIO;
-			goto unlock;
-		}
+		dev_err(dev, "cgx port %d:%d cmd timeout\n",
+			cgx->cgx_id, lmac->lmac_id);
+		err = -EIO;
+		goto unlock;
 	}
 
 	/* we have a valid command response */
 	smp_rmb(); /* Ensure the latest updates are visible */
-	*rsp = lmac->resp;
+	*resp = lmac->resp;
 
 unlock:
 	mutex_unlock(&lmac->cmd_lock);
@@ -388,8 +376,7 @@ static int cgx_fwi_cmd_send(struct cgx_cmd *cmd, struct cgx_evt_sts *rsp,
 	return err;
 }
 
-static inline int cgx_fwi_cmd_generic(struct cgx_cmd *req,
-				      struct cgx_evt_sts *rsp,
+static inline int cgx_fwi_cmd_generic(u64 req, u64 *resp,
 				      struct cgx *cgx, int lmac_id)
 {
 	struct lmac *lmac;
@@ -399,11 +386,11 @@ static inline int cgx_fwi_cmd_generic(struct cgx_cmd *req,
 	if (!lmac)
 		return -ENODEV;
 
-	err = cgx_fwi_cmd_send(req, rsp, lmac);
+	err = cgx_fwi_cmd_send(req, resp, lmac);
 
 	/* Check for valid response */
 	if (!err) {
-		if (rsp->stat == CGX_STAT_FAIL)
+		if (FIELD_GET(EVTREG_STAT, *resp) == CGX_STAT_FAIL)
 			return -EIO;
 		else
 			return 0;
@@ -439,32 +426,35 @@ static inline void cgx_link_usertable_init(void)
 	cgx_lmactype_string[LMAC_MODE_USXGMII] = "USXGMII";
 }
 
-static inline void link_status_user_format(struct cgx_lnk_sts *lstat,
+static inline void link_status_user_format(u64 lstat,
 					   struct cgx_link_user_info *linfo,
 					   struct cgx *cgx, u8 lmac_id)
 {
 	char *lmac_string;
 
-	linfo->link_up = lstat->link_up;
-	linfo->full_duplex = lstat->full_duplex;
+	linfo->link_up = FIELD_GET(RESP_LINKSTAT_UP, lstat);
+	linfo->full_duplex = FIELD_GET(RESP_LINKSTAT_FDUPLEX, lstat);
 	linfo->lmac_type_id = cgx_get_lmac_type(cgx, lmac_id);
-	linfo->speed = cgx_speed_mbps[lstat->speed];
+	linfo->speed = cgx_speed_mbps[FIELD_GET(RESP_LINKSTAT_SPEED, lstat)];
 	lmac_string = cgx_lmactype_string[linfo->lmac_type_id];
 	strncpy(linfo->lmac_type, lmac_string, LMACTYPE_STR_LEN - 1);
 }
 
 /* Hardware event handlers */
-static inline void cgx_link_change_handler(struct cgx_lnk_sts *lstat,
+static inline void cgx_link_change_handler(u64 lstat,
 					   struct lmac *lmac)
 {
 	struct cgx_link_user_info *linfo;
 	struct cgx *cgx = lmac->cgx;
 	struct cgx_link_event event;
 	struct device *dev;
+	int err_type;
 
 	dev = &cgx->pdev->dev;
 
 	link_status_user_format(lstat, &event.link_uinfo, cgx, lmac->lmac_id);
+	err_type = FIELD_GET(RESP_LINKSTAT_ERRTYPE, lstat);
+
 	event.cgx_id = cgx->cgx_id;
 	event.lmac_id = lmac->lmac_id;
 
@@ -478,9 +468,9 @@ static inline void cgx_link_change_handler(struct cgx_lnk_sts *lstat,
 	if (!lmac->event_cb.notify_link_chg) {
 		dev_dbg(dev, "cgx port %d:%d Link change handler null",
 			cgx->cgx_id, lmac->lmac_id);
-		if (lstat->err_type != CGX_ERR_NONE) {
+		if (err_type != CGX_ERR_NONE) {
 			dev_err(dev, "cgx port %d:%d Link error %d\n",
-				cgx->cgx_id, lmac->lmac_id, lstat->err_type);
+				cgx->cgx_id, lmac->lmac_id, err_type);
 		}
 		dev_info(dev, "cgx port %d:%d Link is %s %d Mbps\n",
 			 cgx->cgx_id, lmac->lmac_id,
@@ -494,18 +484,21 @@ static inline void cgx_link_change_handler(struct cgx_lnk_sts *lstat,
 	spin_unlock(&lmac->event_cb_lock);
 }
 
-static inline bool cgx_cmdresp_is_linkevent(struct cgx_evt_sts *rsp)
+static inline bool cgx_cmdresp_is_linkevent(u64 event)
 {
-	if (rsp->id == CGX_CMD_LINK_BRING_UP ||
-	    rsp->id == CGX_CMD_LINK_BRING_DOWN)
+	u8 id;
+
+	id = FIELD_GET(EVTREG_ID, event);
+	if (id == CGX_CMD_LINK_BRING_UP ||
+	    id == CGX_CMD_LINK_BRING_DOWN)
 		return true;
 	else
 		return false;
 }
 
-static inline bool cgx_event_is_linkevent(struct cgx_evt_sts *evt)
+static inline bool cgx_event_is_linkevent(u64 event)
 {
-	if (evt->id == CGX_EVT_LINK_CHANGE)
+	if (FIELD_GET(EVTREG_ID, event) == CGX_EVT_LINK_CHANGE)
 		return true;
 	else
 		return false;
@@ -515,19 +508,17 @@ static irqreturn_t cgx_fwi_event_handler(int irq, void *data)
 {
 	struct lmac *lmac = data;
 	struct cgx *cgx = lmac->cgx;
-	struct cgx_evt_sts event;
-	union cgx_evtreg ereg;
 	struct device *dev;
+	u64 event;
+
+	event = cgx_read(cgx, lmac->lmac_id, CGX_EVENT_REG);
 
-	ereg.val = cgx_read(cgx, lmac->lmac_id, CGX_EVENT_REG);
-	if (!ereg.evt_sts.ack)
+	if (!FIELD_GET(EVTREG_ACK, event))
 		return IRQ_NONE;
 
 	dev = &cgx->pdev->dev;
 
-	event = ereg.evt_sts;
-
-	switch (event.evt_type) {
+	switch (FIELD_GET(EVTREG_EVT_TYPE, event)) {
 	case CGX_EVT_CMD_RESP:
 		/* Copy the response. Since only one command is active at a
 		 * time, there is no way a response can get overwritten
@@ -539,20 +530,17 @@ static irqreturn_t cgx_fwi_event_handler(int irq, void *data)
 		/* There wont be separate events for link change initiated from
 		 * software; Hence report the command responses as events
 		 */
-		if (cgx_cmdresp_is_linkevent(&event))
-			cgx_link_change_handler(&ereg.link_sts, lmac);
+		if (cgx_cmdresp_is_linkevent(event))
+			cgx_link_change_handler(event, lmac);
 
 		/* Release thread waiting for completion  */
 		lmac->cmd_pend = false;
 		wake_up_interruptible(&lmac->wq_cmd_cmplt);
 		break;
 	case CGX_EVT_ASYNC:
-		if (cgx_event_is_linkevent(&event))
-			cgx_link_change_handler(&ereg.link_sts, lmac);
+		if (cgx_event_is_linkevent(event))
+			cgx_link_change_handler(event, lmac);
 		break;
-	default:
-		dev_err(dev, "cgx port %d:%d Unknown event received\n",
-			cgx->cgx_id, lmac->lmac_id);
 	}
 
 	/* Any new event or command response will be posted by firmware
@@ -604,46 +592,45 @@ EXPORT_SYMBOL(cgx_lmac_evh_unregister);
 
 static int cgx_fwi_link_change(struct cgx *cgx, int lmac_id, bool enable)
 {
-	struct cgx_cmd req = { 0 };
-	struct cgx_evt_sts rsp;
+	u64 req = 0;
+	u64 resp;
 
 	if (enable)
-		req.id = CGX_CMD_LINK_BRING_UP;
+		req = FIELD_SET(CMDREG_ID, CGX_CMD_LINK_BRING_UP, req);
 	else
-		req.id = CGX_CMD_LINK_BRING_DOWN;
+		req = FIELD_SET(CMDREG_ID, CGX_CMD_LINK_BRING_DOWN, req);
 
-	return cgx_fwi_cmd_generic(&req, &rsp, cgx, lmac_id);
+	return cgx_fwi_cmd_generic(req, &resp, cgx, lmac_id);
 }
 
-static inline int cgx_fwi_read_version(struct cgx_ver_s *ver, struct cgx *cgx)
+static inline int cgx_fwi_read_version(u64 *resp, struct cgx *cgx)
 {
-	struct cgx_cmd req = { 0 };
-	union cgx_evtreg event;
-	int err;
-
-	req.id = CGX_CMD_GET_FW_VER;
+	u64 req = 0;
 
-	err = cgx_fwi_cmd_generic(&req, &event.evt_sts, cgx, 0);
-	if (!err)
-		*ver = event.ver;
-
-	return err;
+	req = FIELD_SET(CMDREG_ID, CGX_CMD_GET_FW_VER, req);
+	return cgx_fwi_cmd_generic(req, resp, cgx, 0);
 }
 
 static int cgx_lmac_verify_fwi_version(struct cgx *cgx)
 {
-	struct cgx_ver_s ver;
 	struct device *dev = &cgx->pdev->dev;
+	int major_ver, minor_ver;
+	u64 resp;
 	int err;
 
 	if (!cgx->lmac_count)
 		return 0;
 
-	err = cgx_fwi_read_version(&ver, cgx);
+	err = cgx_fwi_read_version(&resp, cgx);
+	if (err)
+		return err;
+
+	major_ver = FIELD_GET(RESP_MAJOR_VER, resp);
+	minor_ver = FIELD_GET(RESP_MINOR_VER, resp);
 	dev_dbg(dev, "Firmware command interface version = %d.%d\n",
-		ver.major_ver, ver.minor_ver);
-	if (err || ver.major_ver != CGX_FIRMWARE_MAJOR_VER ||
-	    ver.minor_ver != CGX_FIRMWARE_MINOR_VER)
+		major_ver, minor_ver);
+	if (major_ver != CGX_FIRMWARE_MAJOR_VER ||
+	    minor_ver != CGX_FIRMWARE_MINOR_VER)
 		return -EIO;
 	else
 		return 0;
diff --git a/drivers/soc/marvell/octeontx2/cgx_fw_if.h b/drivers/soc/marvell/octeontx2/cgx_fw_if.h
index 124334ee605d..071c8137f87a 100644
--- a/drivers/soc/marvell/octeontx2/cgx_fw_if.h
+++ b/drivers/soc/marvell/octeontx2/cgx_fw_if.h
@@ -1,5 +1,5 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 CGX driver
+/* SPDX-License-Identifier: GPL-2.0
+ * Marvell OcteonTx2 CGX driver
  *
  * Copyright (C) 2018 Marvell International Ltd.
  *
@@ -11,6 +11,9 @@
 #ifndef __CGX_FW_INTF_H__
 #define __CGX_FW_INTF_H__
 
+#include <linux/bitops.h>
+#include <linux/bitfield.h>
+
 #define CGX_FIRMWARE_MAJOR_VER		1
 #define CGX_FIRMWARE_MINOR_VER		0
 
@@ -100,53 +103,40 @@ enum cgx_cmd_own {
 	CGX_CMD_OWN_FIRMWARE,
 };
 
+/* m - bit mask
+ * y - value to be written in the bitrange
+ * x - input value whose bitrange to be modified
+ */
+#define FIELD_SET(m, y, x)		\
+	(((x) & ~(m)) |			\
+	FIELD_PREP((m), (y)))
+
 /* scratchx(0) CSR used for ATF->non-secure SW communication.
  * This acts as the status register
- * Provides details on command ack/status, link status, error details
+ * Provides details on command ack/status, command response, error details
  */
-struct cgx_evt_sts {
-	uint64_t ack:1;
-	uint64_t evt_type:1;		/* cgx_evt_type */
-	uint64_t stat:1;		/* cgx_stat */
-	uint64_t id:6;			/* cgx_evt_id/cgx_cmd_id */
-	uint64_t reserved:55;
-};
+#define EVTREG_ACK		BIT_ULL(0)
+#define EVTREG_EVT_TYPE		BIT_ULL(1)
+#define EVTREG_STAT		BIT_ULL(2)
+#define EVTREG_ID		GENMASK_ULL(8, 3)
 
 /* Response to command IDs with command status as CGX_STAT_FAIL
  *
  * Not applicable for commands :
  * CGX_CMD_LINK_BRING_UP/DOWN/CGX_EVT_LINK_CHANGE
- * check struct cgx_lnk_sts comments
  */
-struct cgx_err_sts_s {
-	uint64_t reserved1:9;
-	uint64_t type:10;		/* cgx_error_type */
-	uint64_t reserved2:35;
-};
+#define EVTREG_ERRTYPE		GENMASK_ULL(18, 9)
 
 /* Response to cmd ID as CGX_CMD_GET_FW_VER with cmd status as
  * CGX_STAT_SUCCESS
  */
-struct cgx_ver_s {
-	uint64_t reserved1:9;
-	uint64_t major_ver:4;
-	uint64_t minor_ver:4;
-	uint64_t reserved2:47;
-};
+#define RESP_MAJOR_VER		GENMASK_ULL(12, 9)
+#define RESP_MINOR_VER		GENMASK_ULL(16, 13)
 
 /* Response to cmd ID as CGX_CMD_GET_MAC_ADDR with cmd status as
  * CGX_STAT_SUCCESS
  */
-struct cgx_mac_addr_s {
-	uint64_t reserved1:9;
-	uint64_t addr_0:8;
-	uint64_t addr_1:8;
-	uint64_t addr_2:8;
-	uint64_t addr_3:8;
-	uint64_t addr_4:8;
-	uint64_t addr_5:8;
-	uint64_t reserved2:7;
-};
+#define RESP_MAC_ADDR		GENMASK_ULL(56, 9)
 
 /* Response to cmd ID - CGX_CMD_LINK_BRING_UP/DOWN, event ID CGX_EVT_LINK_CHANGE
  * status can be either CGX_STAT_FAIL or CGX_STAT_SUCCESS
@@ -167,56 +157,29 @@ struct cgx_lnk_sts {
 	uint64_t reserved2:39;
 };
 
-union cgx_evtreg {
-	u64 val;
-	struct cgx_evt_sts evt_sts; /* common for all commands/events */
-	struct cgx_lnk_sts link_sts; /* response to LINK_BRINGUP/DOWN/CHANGE */
-	struct cgx_ver_s ver;		/* response to CGX_CMD_GET_FW_VER */
-	struct cgx_mac_addr_s mac_addr;	/* response to CGX_CMD_GET_MAC_ADDR */
-	struct cgx_err_sts_s err;	/* response if evt_status = CMD_FAIL */
-};
+#define RESP_LINKSTAT_UP		GENMASK_ULL(9, 9)
+#define RESP_LINKSTAT_FDUPLEX		GENMASK_ULL(10, 10)
+#define RESP_LINKSTAT_SPEED		GENMASK_ULL(14, 11)
+#define RESP_LINKSTAT_ERRTYPE		GENMASK_ULL(24, 15)
 
 /* scratchx(1) CSR used for non-secure SW->ATF communication
  * This CSR acts as a command register
  */
-struct cgx_cmd {
-	uint64_t own:2;			/* cgx_csr_own */
-	uint64_t id:6;			/* cgx_request_id */
-	uint64_t reserved2:56;
-};
+#define CMDREG_OWN	BIT_ULL(0)
+#define CMDREG_ID	GENMASK_ULL(7, 2)
 
 /* Any command using enable/disable as an argument need
- * to pass the option via this structure.
+ * to set this bitfield.
  * Ex: Loopback, HiGig...
  */
-struct cgx_ctl_args {
-	uint64_t reserved1:8;
-	uint64_t enable:1;
-	uint64_t reserved2:55;
-};
+#define CMDREG_ENABLE	BIT_ULL(8)
 
 /* command argument to be passed for cmd ID - CGX_CMD_SET_MTU */
-struct cgx_mtu_args {
-	uint64_t reserved1:8;
-	uint64_t size:16;
-	uint64_t reserved2:40;
-};
+#define CMDMTU_SIZE	GENMASK_ULL(23, 8)
 
 /* command argument to be passed for cmd ID - CGX_CMD_LINK_CHANGE */
-struct cgx_link_change_args {
-	uint64_t reserved1:8;
-	uint64_t link_up:1;
-	uint64_t full_duplex:1;
-	uint64_t speed:4;		/* cgx_link_speed */
-	uint64_t reserved2:50;
-};
-
-union cgx_cmdreg {
-	u64 val;
-	struct cgx_cmd cmd;
-	struct cgx_ctl_args cmd_args;
-	struct cgx_mtu_args mtu_size;
-	struct cgx_link_change_args lnk_args;/* Input to CGX_CMD_LINK_CHANGE */
-};
+#define CMDLINKCHANGE_LINKUP	BIT_ULL(8)
+#define CMDLINKCHANGE_FULLDPLX	BIT_ULL(9)
+#define CMDLINKCHANGE_SPEED	GENMASK_ULL(13, 10)
 
 #endif /* __CGX_FW_INTF_H__ */
-- 
2.17.1


From 3778e0b90ec93c78440b2590aeb133a70713403b Mon Sep 17 00:00:00 2001
From: Linu Cherian <lcherian@marvell.com>
Date: Thu, 13 Dec 2018 19:27:00 +0530
Subject: [PATCH 0881/1051] soc: octeontx2: Get PF macaddress from firmware

- Support for getting macaddress from firmware through cgx fw interface
- Initialize all cgx mapped PFs with macaddress obtained from
  firmware

Change-Id: Iede82a37f0da7e71ac6fea0560ac47df962b4d1e
Signed-off-by: Linu Cherian <lcherian@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/1788
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/octeontx2/cgx.c     | 29 +++++++++++++++++++++++++
 drivers/soc/marvell/octeontx2/cgx.h     |  1 +
 drivers/soc/marvell/octeontx2/rvu_cgx.c |  6 +++++
 3 files changed, 36 insertions(+)

diff --git a/drivers/soc/marvell/octeontx2/cgx.c b/drivers/soc/marvell/octeontx2/cgx.c
index 875afa5bce29..1481a5b3ba9b 100644
--- a/drivers/soc/marvell/octeontx2/cgx.c
+++ b/drivers/soc/marvell/octeontx2/cgx.c
@@ -74,6 +74,7 @@ static char *cgx_lmactype_string[LMAC_MODE_MAX];
 
 /* CGX PHY management internal APIs */
 static int cgx_fwi_link_change(struct cgx *cgx, int lmac_id, bool en);
+static int cgx_fwi_get_macaddr(struct cgx *cgx, int lmac_id, u8 *dst);
 
 /* Supported devices */
 static const struct pci_device_id cgx_id_table[] = {
@@ -203,6 +204,18 @@ u64 cgx_lmac_addr_get(u8 cgx_id, u8 lmac_id)
 }
 EXPORT_SYMBOL(cgx_lmac_addr_get);
 
+/* Gets mac address from firmware for each cgx mapped PF */
+int cgx_get_pfmacaddr(void *cgxd, u8 lmac_id, u8 *macdst)
+{
+	struct cgx *cgx = cgxd;
+
+	if (!cgx || lmac_id >= cgx->lmac_count)
+		return -ENODEV;
+
+	return cgx_fwi_get_macaddr(cgx, lmac_id, macdst);
+}
+EXPORT_SYMBOL(cgx_get_pfmacaddr);
+
 int cgx_set_pkind(void *cgxd, u8 lmac_id, int pkind)
 {
 	struct cgx *cgx = cgxd;
@@ -673,6 +686,22 @@ int cgx_lmac_evh_unregister(void *cgxd, int lmac_id)
 }
 EXPORT_SYMBOL(cgx_lmac_evh_unregister);
 
+static int cgx_fwi_get_macaddr(struct cgx *cgx, int lmac_id, u8 *dst)
+{
+	u64 req = 0, resp, mac;
+	int err;
+
+	req = FIELD_SET(CMDREG_ID, CGX_CMD_GET_MAC_ADDR, req);
+
+	err = cgx_fwi_cmd_generic(req, &resp, cgx, lmac_id);
+	if (!err) {
+		mac = FIELD_GET(RESP_MAC_ADDR, resp);
+		memcpy(dst, (u8 *)&mac, 6);
+	}
+
+	return err;
+}
+
 static int cgx_fwi_link_change(struct cgx *cgx, int lmac_id, bool enable)
 {
 	u64 req = 0;
diff --git a/drivers/soc/marvell/octeontx2/cgx.h b/drivers/soc/marvell/octeontx2/cgx.h
index 72e0aea0114f..a89fe3b4499e 100644
--- a/drivers/soc/marvell/octeontx2/cgx.h
+++ b/drivers/soc/marvell/octeontx2/cgx.h
@@ -108,6 +108,7 @@ int cgx_get_rx_stats(void *cgxd, int lmac_id, int idx, u64 *rx_stat);
 int cgx_lmac_rx_tx_enable(void *cgxd, int lmac_id, bool enable);
 int cgx_lmac_addr_set(u8 cgx_id, u8 lmac_id, u8 *mac_addr);
 u64 cgx_lmac_addr_get(u8 cgx_id, u8 lmac_id);
+int cgx_get_pfmacaddr(void *cgxd, u8 lmac_id, u8 *macdst);
 void cgx_lmac_promisc_config(int cgx_id, int lmac_id, bool enable);
 void cgx_lmac_ptp_config(void *cgxd, int lmac_id, bool enable);
 int cgx_lmac_internal_loopback(void *cgxd, int lmac_id, bool enable);
diff --git a/drivers/soc/marvell/octeontx2/rvu_cgx.c b/drivers/soc/marvell/octeontx2/rvu_cgx.c
index 79ff4275bcfd..225587edcfdf 100644
--- a/drivers/soc/marvell/octeontx2/rvu_cgx.c
+++ b/drivers/soc/marvell/octeontx2/rvu_cgx.c
@@ -100,6 +100,12 @@ static int rvu_map_cgx_lmac_pf(struct rvu *rvu)
 		for (lmac = 0; lmac < lmac_cnt; lmac++, pf++) {
 			rvu->pf2cgxlmac_map[pf] = cgxlmac_id_to_bmap(cgx, lmac);
 			rvu->cgxlmac2pf_map[CGX_OFFSET(cgx) + lmac] = 1 << pf;
+			/* Get mac address for the CGX mapped PF */
+			if (cgx_get_pfmacaddr(rvu_cgx_pdata(cgx, rvu), lmac,
+					  rvu->pf[pf].mac_addr))
+				dev_dbg(rvu->dev,
+					"pf %d: Failed to get MAC from firmware\n",
+					pf);
 			free_pkind = rvu_alloc_rsrc(&pkind->rsrc);
 			pkind->pfchan_map[free_pkind] = ((pf) & 0x3F) << 16;
 			rvu->cgx_mapped_pfs++;
-- 
2.17.1


From 71e4993e4610ff7576074609e5486af00e7d932d Mon Sep 17 00:00:00 2001
From: Sujeet Baranwal <sbaranwal@caviumnetworks.com>
Date: Mon, 22 Oct 2018 14:29:41 -0700
Subject: [PATCH 0366/1051] mmc: octeontx2: emmc operation limited to 100 MHz

In octtx2, the emmc interface supports operation on up to
200 MHz parts. An issue exists in pass 0 of chip, whereby
the interface timing is broken for reads or writes over
the interface of above 100 MHz .

The future passes of the chip shall have this fixed.

Change-Id: I124dc4e94ecf6774298fec575d72c7a0ec9a3b92
Signed-off-by: Sujeet Baranwal <sbaranwal@caviumnetworks.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium-thunderx.c |  2 ++
 drivers/mmc/host/cavium.c          | 32 +++++++++++++++++++++++++-----
 drivers/mmc/host/cavium.h          | 26 ++++++++++++++++++++++++
 3 files changed, 55 insertions(+), 5 deletions(-)

diff --git a/drivers/mmc/host/cavium-thunderx.c b/drivers/mmc/host/cavium-thunderx.c
index e6bbb76abe25..f25dc71a346a 100644
--- a/drivers/mmc/host/cavium-thunderx.c
+++ b/drivers/mmc/host/cavium-thunderx.c
@@ -82,6 +82,8 @@ static int thunder_mmc_probe(struct pci_dev *pdev,
 	/* On ThunderX these are identical */
 	host->dma_base = host->base;
 
+	host->pdev = pdev;
+
 	host->reg_off = 0x2000;
 	host->reg_off_dma = 0x160;
 
diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 938f2d799300..6b54692140ac 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -848,12 +848,29 @@ static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	writeq(emm_cmd, host->base + MIO_EMM_CMD(host));
 }
 
+static u32 max_supported_frequency(struct cvm_mmc_host *host)
+{
+	/* Default maximum freqeuncey is 52000000 for chip prior to 9X */
+	u32 max_frequency = MHZ_52;
+
+	if (is_mmc_otx2(host)) {
+		/* Default max frequency is 200MHz for 9X chips */
+		max_frequency = MHZ_200;
+
+		/* Erratum is only applicable pass A0 */
+		if (is_mmc_otx2_A0(host))
+			max_frequency = MHZ_100;
+	}
+	return max_frequency;
+}
+
 static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct cvm_mmc_slot *slot = mmc_priv(mmc);
 	struct cvm_mmc_host *host = slot->host;
 	int clk_period = 0, power_class = 10, bus_width = 0;
 	u64 clock, emm_switch;
+	u32 max_f;
 
 	if (ios->power_mode == MMC_POWER_OFF) {
 		if (host->powered) {
@@ -897,8 +914,10 @@ static void cvm_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	/* Change the clock frequency. */
 	clock = ios->clock;
-	if (clock > 52000000)
-		clock = 52000000;
+	max_f = max_supported_frequency(host);
+
+	if (clock > max_f)
+		clock = max_f;
 	slot->clock = clock;
 
 	if (clock)
@@ -981,6 +1000,7 @@ static int cvm_mmc_of_parse(struct device *dev, struct cvm_mmc_slot *slot)
 	u32 id, cmd_skew = 0, dat_skew = 0, bus_width = 0;
 	struct device_node *node = dev->of_node;
 	struct mmc_host *mmc = slot->mmc;
+	u32 max_frequency;
 	int ret;
 
 	ret = of_property_read_u32(node, "reg", &id);
@@ -1024,12 +1044,14 @@ static int cvm_mmc_of_parse(struct device *dev, struct cvm_mmc_slot *slot)
 			mmc->caps |= MMC_CAP_4_BIT_DATA;
 	}
 
+	max_frequency = max_supported_frequency(slot->host);
+
 	/* Set maximum and minimum frequency */
 	if (!mmc->f_max)
 		of_property_read_u32(node, "spi-max-frequency", &mmc->f_max);
-	if (!mmc->f_max || mmc->f_max > 52000000)
-		mmc->f_max = 52000000;
-	mmc->f_min = 400000;
+	if (!mmc->f_max || mmc->f_max > max_frequency)
+		mmc->f_max = max_frequency;
+	mmc->f_min = KHZ_400;
 
 	/* Sampling register settings, period in picoseconds */
 	of_property_read_u32(node, "cavium,cmd-clk-skew", &cmd_skew);
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index f91057dc053f..d4b6377c11e6 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -19,9 +19,19 @@
 #include <linux/of.h>
 #include <linux/scatterlist.h>
 #include <linux/semaphore.h>
+#include <linux/pci.h>
 
 #define CAVIUM_MAX_MMC		4
 
+/* Subsystem Device ID */
+#define PCI_SUBSYS_DEVID_96XX	0xB200
+#define PCI_SUBSYS_DEVID_95XX   0xB300
+
+#define KHZ_400 (400000)
+#define MHZ_52  (52000000)
+#define MHZ_100 (100000000)
+#define MHZ_200 (200000000)
+
 /* DMA register addresses */
 #define MIO_EMM_DMA_FIFO_CFG(x)	(0x00 + x->reg_off_dma)
 #define MIO_EMM_DMA_FIFO_ADR(x)	(0x10 + x->reg_off_dma)
@@ -56,6 +66,7 @@ struct cvm_mmc_host {
 	struct device *dev;
 	void __iomem *base;
 	void __iomem *dma_base;
+	struct pci_dev *pdev;
 	int reg_off;
 	int reg_off_dma;
 	u64 emm_cfg;
@@ -213,4 +224,19 @@ int cvm_mmc_of_slot_probe(struct device *dev, struct cvm_mmc_host *host);
 int cvm_mmc_of_slot_remove(struct cvm_mmc_slot *slot);
 extern const char *cvm_mmc_irq_names[];
 
+static inline bool is_mmc_otx2(struct cvm_mmc_host *host)
+{
+	struct pci_dev *pdev = host->pdev;
+
+	return (pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX) ||
+		(pdev->subsystem_device == PCI_SUBSYS_DEVID_95XX);
+}
+
+static inline bool is_mmc_otx2_A0(struct cvm_mmc_host *host)
+{
+	struct pci_dev *pdev = host->pdev;
+
+	return (pdev->revision == 0x00) &&
+		(pdev->subsystem_device == PCI_SUBSYS_DEVID_96XX);
+}
 #endif
-- 
2.17.1


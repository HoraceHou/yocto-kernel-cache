From 675d6ad002338dda78c9dfec164c60396812bcd5 Mon Sep 17 00:00:00 2001
From: Yan Markman <ymarkman@marvell.com>
Date: Wed, 28 Nov 2018 22:35:08 +0200
Subject: [PATCH 0818/1051] net: mvpp2: do not recycle shrank buffer

The IPsec package uses clone/share skb for segmented data transfer.
If last segment is short the skb data-room is shrank but has
all other attributes checked for recycling (non-clone/share since
it last, hash, bm-pool-id).
The shrank is shorter than bm-pool-id size and should not be recycled.

Add checking that skb-end-offset is less than bm frag_size - shinfo.
This condition is deriven from build_skb() procedure which sets
skb->end = (frag_size-shinfo)

Change-Id: I60c15577df558097e69b4f1e425ee9a221bec84f
Signed-off-by: Yan Markman <ymarkman@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/61421
Reviewed-by: Stefan Chulski <stefanc@marvell.com>
Tested-by: Stefan Chulski <stefanc@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index b265d89740a8..fea81b9d764a 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@ -107,7 +107,8 @@ struct mvpp2_share {
 
 struct mvpp2_share mvpp2_share;
 
-static inline void mvpp2_recycle_put(struct mvpp2_txq_pcpu *txq_pcpu,
+static inline void mvpp2_recycle_put(struct mvpp2_port *port,
+				     struct mvpp2_txq_pcpu *txq_pcpu,
 				     struct mvpp2_txq_pcpu_buf *tx_buf);
 
 static void mvpp2_tx_done_guard_force_irq(struct mvpp2_port *port,
@@ -2149,7 +2150,7 @@ static void mvpp2_txq_bufs_free(struct mvpp2_port *port,
 		} else if (tx_buf->skb != TSO_HEADER_MARK) {
 			dma_unmap_single(port->dev->dev.parent, tx_buf->dma,
 					 tx_buf->size, DMA_TO_DEVICE);
-			mvpp2_recycle_put(txq_pcpu, tx_buf);
+			mvpp2_recycle_put(port, txq_pcpu, tx_buf);
 			/* sets tx_buf->skb=NULL if put to recycle */
 			if (tx_buf->skb)
 				dev_kfree_skb_any(tx_buf->skb);
@@ -3274,19 +3275,25 @@ static int mvpp2_recycle_get_bm_id(struct sk_buff *skb)
 	return (int)hash;
 }
 
-static inline void mvpp2_recycle_put(struct mvpp2_txq_pcpu *txq_pcpu,
+static inline void mvpp2_recycle_put(struct mvpp2_port *port,
+				     struct mvpp2_txq_pcpu *txq_pcpu,
 				     struct mvpp2_txq_pcpu_buf *tx_buf)
 {
 	struct mvpp2_recycle_pcpu *pcpu;
 	struct mvpp2_recycle_pool *pool;
 	short int idx, pool_id;
 	struct sk_buff *skb = tx_buf->skb;
+	struct mvpp2_bm_pool *bm_pool;
 
 	/* tx_buf->skb is not NULL */
 	pool_id = mvpp2_recycle_get_bm_id(skb);
 	if (pool_id < 0)
 		return; /* non-recyclable */
 
+	bm_pool = &port->priv->bm_pools[pool_id];
+	if (skb_end_offset(skb) < (bm_pool->frag_size - MVPP2_SKB_SHINFO_SIZE))
+		return; /* shrank -> non-recyclable */
+
 	/* This skb could be destroyed. Put into recycle */
 	pcpu = mvpp2_share.recycle + txq_pcpu->thread;
 	idx = pcpu->idx[pool_id];
-- 
2.17.1


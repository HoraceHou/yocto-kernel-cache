From 0b9372a117207702cc28c78a031d1aa04b6abbfe Mon Sep 17 00:00:00 2001
From: Lukasz Bartosik <lbartosik@marvell.com>
Date: Thu, 3 Jan 2019 20:04:59 +0300
Subject: [PATCH 0878/1051] crypto: add new msg to query engine group number

Add new msg MBOX_MSG_GET_ENG_GRP_NUM which can be used
by CPT VF to query engine group number which has a given
type of engines attached. This message is exchanged only
between CPT PF <-> CPT VF.

Change-Id: I7ac28c83857692ce616f6151d378fadf29f9baa5
Signed-off-by: Lukasz Bartosik <lbartosik@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/1785
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/cavium/cpt/9x/cpt9x_debug.c    |  8 ++
 .../crypto/cavium/cpt/9x/cpt9x_mbox_common.h  | 22 +++--
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c  |  4 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c  | 90 ++++++++++++++-----
 drivers/crypto/cavium/cpt/9x/cpt9x_vf.h       |  1 +
 drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c  |  8 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c  | 40 +++++++--
 7 files changed, 136 insertions(+), 37 deletions(-)

diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c b/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
index cb1cb7bcfb89..2ce40eea44d4 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
@@ -38,6 +38,14 @@ static char *get_opcode_str(int msg_opcode)
 	case MBOX_MSG_CPT_RD_WR_REGISTER:
 		str = "RD_WR_REGISTER";
 	break;
+
+	case MBOX_MSG_CPT_SET_CRYPTO_GRP:
+		str = "SET_CRYPTO_GRP";
+	break;
+
+	case MBOX_MSG_GET_ENG_GRP_NUM:
+		str = "GET_ENG_GRP_NUM";
+	break;
 	}
 
 	return str;
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
index 06f46b7c2481..73418130b3ef 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
@@ -14,14 +14,24 @@
 #include "cpt9x_pf.h"
 #include "cpt9x_vf.h"
 
-#define INVALID_KCRYPTO_ENG_GRP	0xFF
+#define INVALID_CRYPTO_ENG_GRP		0xFF
+/* Take mbox id from end of CPT mbox range in AF (range 0xA00 - 0xBFF) */
+#define MBOX_MSG_GET_ENG_GRP_NUM	0xBFF
 
-/* Extended ready message response with engine group
- * number for kernel crypto functionality
+/*
+ * Message request and response to get engine group number
+ * which has attached a given type of engines (SE, AE, IE)
+ * This messages are only used between CPT PF <-> CPT VF
  */
-struct ready_msg_rsp_ex {
-	struct ready_msg_rsp msg;
-	int eng_grp_num;
+struct eng_grp_num_msg {
+	struct mbox_msghdr hdr;
+	u8 eng_type;
+};
+
+struct eng_grp_num_rsp {
+	struct mbox_msghdr hdr;
+	u8 eng_type;
+	u8 eng_grp_num;
 };
 
 static inline struct cptlfs_info *get_lfs_info(struct pci_dev *pdev)
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
index 973684dfec2a..c9492e9050b7 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
@@ -491,7 +491,7 @@ static void cptpf_eng_grp_hndlr(void *obj)
 {
 	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
 	struct engine_group_info *grp;
-	int crypto_eng_grp = INVALID_KCRYPTO_ENG_GRP;
+	int crypto_eng_grp = INVALID_CRYPTO_ENG_GRP;
 	int i;
 
 	for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
@@ -525,7 +525,7 @@ static int cptpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	pci_set_drvdata(pdev, cptpf);
 	cptpf->pdev = pdev;
-	cptpf->crypto_eng_grp = INVALID_KCRYPTO_ENG_GRP;
+	cptpf->crypto_eng_grp = INVALID_CRYPTO_ENG_GRP;
 	cptpf->max_vfs = pci_sriov_get_totalvfs(pdev);
 	cpt_set_dbg_level(debug);
 
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
index 4dfb440941f4..2f824dd2591e 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
@@ -87,40 +87,82 @@ static int reply_free_rsrc_cnt(struct cptpf_dev *cptpf, struct cptvf_info *vf,
 	return 0;
 }
 
-static int reply_ready_msg_ex(struct cptpf_dev *cptpf, struct cptvf_info *vf,
-			      struct mbox_msghdr *req)
+static int reply_ready_msg(struct cptpf_dev *cptpf, struct cptvf_info *vf,
+			   struct mbox_msghdr *req)
 {
+	struct mbox_msghdr *rsp;
+
+	rsp = otx2_mbox_alloc_msg(&cptpf->vfpf_mbox, vf->vf_id, sizeof(*rsp));
+	if (!rsp)
+		return -ENOMEM;
+
+	rsp->id = MBOX_MSG_READY;
+	rsp->sig = OTX2_MBOX_RSP_SIG;
+	rsp->pcifunc = req->pcifunc;
+
+	return 0;
+}
+
+static int reply_eng_grp_num_msg(struct cptpf_dev *cptpf,
+				 struct cptvf_info *vf,
+				 struct mbox_msghdr *req)
+{
+	struct eng_grp_num_msg *grp_req = (struct eng_grp_num_msg *)req;
 	struct engine_group_info *grp;
-	struct ready_msg_rsp_ex *rsp;
+	struct eng_grp_num_rsp *rsp;
 	int i;
 
-	rsp = (struct ready_msg_rsp_ex *)
+	rsp = (struct eng_grp_num_rsp *)
 			      otx2_mbox_alloc_msg(&cptpf->vfpf_mbox, vf->vf_id,
 						  sizeof(*rsp));
 	if (!rsp)
 		return -ENOMEM;
 
-	rsp->msg.hdr.id = MBOX_MSG_READY;
-	rsp->msg.hdr.sig = OTX2_MBOX_RSP_SIG;
-	rsp->msg.hdr.pcifunc = req->pcifunc;
-	rsp->eng_grp_num = INVALID_KCRYPTO_ENG_GRP;
+	rsp->hdr.id = MBOX_MSG_GET_ENG_GRP_NUM;
+	rsp->hdr.sig = OTX2_MBOX_RSP_SIG;
+	rsp->hdr.pcifunc = req->pcifunc;
+	rsp->eng_type = grp_req->eng_type;
+	rsp->eng_grp_num = INVALID_CRYPTO_ENG_GRP;
 
 	mutex_lock(&cptpf->eng_grps.lock);
 
-	/* Find engine group for kernel crypto functionality, select first
-	 * engine group which is configured and has only SE engines attached
-	 */
-	for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
-		grp = &cptpf->eng_grps.grp[i];
-		if (!grp->is_enabled)
-			continue;
-
-		if (cpt_eng_grp_has_eng_type(grp, SE_TYPES) &&
-		    !cpt_eng_grp_has_eng_type(grp, IE_TYPES) &&
-		    !cpt_eng_grp_has_eng_type(grp, AE_TYPES)) {
-			rsp->eng_grp_num = i;
-			break;
+	switch (grp_req->eng_type) {
+	case SE_TYPES:
+		/* Find engine group for kernel crypto functionality, select
+		 * first engine group which is configured and has only
+		 * SE engines attached
+		 */
+		for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
+			grp = &cptpf->eng_grps.grp[i];
+			if (!grp->is_enabled)
+				continue;
+
+			if (cpt_eng_grp_has_eng_type(grp, SE_TYPES) &&
+			    !cpt_eng_grp_has_eng_type(grp, IE_TYPES) &&
+			    !cpt_eng_grp_has_eng_type(grp, AE_TYPES)) {
+				rsp->eng_grp_num = i;
+				break;
+			}
 		}
+	break;
+
+	case AE_TYPES:
+	case IE_TYPES:
+		for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
+			grp = &cptpf->eng_grps.grp[i];
+			if (!grp->is_enabled)
+				continue;
+
+			if (cpt_eng_grp_has_eng_type(grp, grp_req->eng_type)) {
+				rsp->eng_grp_num = i;
+				break;
+			}
+		}
+	break;
+
+	default:
+		dev_err(&cptpf->pdev->dev, "Invalid engine type %d",
+			grp_req->eng_type);
 	}
 
 	mutex_unlock(&cptpf->eng_grps.lock);
@@ -138,7 +180,7 @@ static int cptpf_handle_vf_req(struct cptpf_dev *cptpf, struct cptvf_info *vf,
 					      req->pcifunc, req->id);
 	switch (req->id) {
 	case MBOX_MSG_READY:
-		err = reply_ready_msg_ex(cptpf, vf, req);
+		err = reply_ready_msg(cptpf, vf, req);
 		break;
 
 	case MBOX_MSG_FREE_RSRC_CNT:
@@ -149,6 +191,10 @@ static int cptpf_handle_vf_req(struct cptpf_dev *cptpf, struct cptvf_info *vf,
 		err = check_attach_rsrcs_req(cptpf, vf, req, size);
 		break;
 
+	case MBOX_MSG_GET_ENG_GRP_NUM:
+		err = reply_eng_grp_num_msg(cptpf, vf, req);
+		break;
+
 	default:
 		err = forward_to_af(cptpf, vf, req, size);
 		break;
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h b/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h
index 291d7531de5f..ddfecdaf8cfa 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h
@@ -30,5 +30,6 @@ struct cptvf_dev {
 
 irqreturn_t cptvf_pfvf_mbox_intr(int irq, void *arg);
 void cptvf_pfvf_mbox_handler(struct work_struct *work);
+int cptvf_send_eng_grp_num_msg(struct cptvf_dev *cptvf, int eng_type);
 
 #endif /* __CPT9X_VF_H */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c
index 8e4c55120a58..2eff3ee21013 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_main.c
@@ -207,7 +207,13 @@ static int cptvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	err = cpt_send_ready_msg(cptvf->pdev);
 	if (err)
 		goto cpt_err_unregister_interrupts;
-	if (cptvf->lfs.kcrypto_eng_grp_num == INVALID_KCRYPTO_ENG_GRP) {
+
+	/* Get engine group number for symmetric crypto */
+	cptvf->lfs.kcrypto_eng_grp_num = INVALID_CRYPTO_ENG_GRP;
+	err = cptvf_send_eng_grp_num_msg(cptvf, SE_TYPES);
+	if (err)
+		goto cpt_err_unregister_interrupts;
+	if (cptvf->lfs.kcrypto_eng_grp_num == INVALID_CRYPTO_ENG_GRP) {
 		dev_err(dev, "Engine group for kernel crypto not available");
 		err = -ENOENT;
 		goto cpt_err_unregister_interrupts;
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
index 1bf43d192b67..db706801a0b4 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
@@ -34,7 +34,7 @@ void cptvf_pfvf_mbox_handler(struct work_struct *work)
 {
 	struct cpt_rd_wr_reg_msg *rsp_reg;
 	struct msix_offset_rsp *rsp_msix;
-	struct ready_msg_rsp_ex *rsp;
+	struct eng_grp_num_rsp *rsp_grp;
 	struct otx2_mbox *pfvf_mbox;
 	struct mbox_hdr *rsp_hdr;
 	struct mbox_msghdr *msg;
@@ -76,11 +76,8 @@ void cptvf_pfvf_mbox_handler(struct work_struct *work)
 		offset = msg->next_msgoff;
 		switch (msg->id) {
 		case MBOX_MSG_READY:
-			rsp = (struct ready_msg_rsp_ex *) msg;
-			cptvf->vf_id =
-				((rsp->msg.hdr.pcifunc >> RVU_PFVF_FUNC_SHIFT)
-				 & RVU_PFVF_FUNC_MASK) - 1;
-			cptvf->lfs.kcrypto_eng_grp_num = rsp->eng_grp_num;
+			cptvf->vf_id = ((msg->pcifunc >> RVU_PFVF_FUNC_SHIFT)
+					& RVU_PFVF_FUNC_MASK) - 1;
 			break;
 
 		case MBOX_MSG_ATTACH_RESOURCES:
@@ -121,6 +118,10 @@ void cptvf_pfvf_mbox_handler(struct work_struct *work)
 			       sizeof(struct free_rsrcs_rsp));
 			break;
 
+		case MBOX_MSG_GET_ENG_GRP_NUM:
+			rsp_grp = (struct eng_grp_num_rsp *) msg;
+			cptvf->lfs.kcrypto_eng_grp_num = rsp_grp->eng_grp_num;
+			break;
 		default:
 			dev_err(&cptvf->pdev->dev,
 				"Unsupported msg %d received.\n",
@@ -132,3 +133,30 @@ void cptvf_pfvf_mbox_handler(struct work_struct *work)
 	}
 	otx2_mbox_reset(pfvf_mbox, 0);
 }
+
+int cptvf_send_eng_grp_num_msg(struct cptvf_dev *cptvf, int eng_type)
+{
+	struct pci_dev *pdev = cptvf->pdev;
+	struct eng_grp_num_msg *req;
+	int ret = 0;
+
+	req = (struct eng_grp_num_msg *)
+			otx2_mbox_alloc_msg_rsp(&cptvf->pfvf_mbox, 0,
+				sizeof(*req), sizeof(struct eng_grp_num_rsp));
+	if (req == NULL) {
+		dev_err(&pdev->dev, "RVU MBOX failed to get message.\n");
+		ret = -EFAULT;
+		goto error;
+	}
+
+	req->hdr.id = MBOX_MSG_GET_ENG_GRP_NUM;
+	req->hdr.sig = OTX2_MBOX_REQ_SIG;
+	req->hdr.pcifunc = RVU_PFFUNC(cptvf->vf_id, 0);
+	req->eng_type = eng_type;
+
+	ret = cpt_send_mbox_msg(pdev);
+	if (ret)
+		goto error;
+error:
+	return ret;
+}
-- 
2.17.1


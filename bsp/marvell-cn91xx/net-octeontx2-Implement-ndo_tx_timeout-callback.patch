From af155009395873eda62ac4be4e8cb7e15b44bf72 Mon Sep 17 00:00:00 2001
From: Aleksey Makarov <amakarov@marvell.com>
Date: Thu, 16 Aug 2018 17:20:27 +0530
Subject: [PATCH 0123/1051] net: octeontx2: Implement ndo_tx_timeout callback

This patch implements .ndo_tx_timeout() for OcteonTX2
network driver.  On the timeout event, the implementation
just reinitializes the interface by calling stop()/open().

Also check for CQ errors after reading CQ status for CQE count
and trigger interface reset if there is a unrecoverable error.

Signed-off-by: Aleksey Makarov <amakarov@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/otx2_common.c  |  7 +++++++
 .../net/ethernet/marvell/octeontx2/otx2_common.h  |  2 ++
 drivers/net/ethernet/marvell/octeontx2/otx2_pf.c  | 15 +++++++++++++++
 .../net/ethernet/marvell/octeontx2/otx2_txrx.c    | 11 +++++++++++
 4 files changed, 35 insertions(+)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index 3ddb5c715651..b2580b3f85fb 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -292,6 +292,13 @@ dma_addr_t otx2_alloc_rbuf(struct otx2_nic *pfvf, struct otx2_pool *pool)
 	return iova;
 }
 
+void otx2_tx_timeout(struct net_device *netdev)
+{
+	struct otx2_nic *pfvf = netdev_priv(netdev);
+
+	schedule_work(&pfvf->reset_task);
+}
+
 static int otx2_get_link(struct otx2_nic *pfvf)
 {
 	int link = 0;
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index 235c7d025a77..1db8c35942ae 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -139,6 +139,7 @@ struct otx2_nic {
 	u16			pcifunc;
 	u16			rx_chan_base;
 	u16			tx_chan_base;
+	struct work_struct	reset_task;
 };
 
 /* Register read/write APIs */
@@ -303,6 +304,7 @@ int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, struct net_device *netdev);
 int otx2_set_mac_address(struct net_device *netdev, void *p);
 int otx2_change_mtu(struct net_device *netdev, int new_mtu);
 int otx2_hw_set_mtu(struct otx2_nic *pfvf, int mtu);
+void otx2_tx_timeout(struct net_device *netdev);
 
 /* RSS configuration APIs*/
 int otx2_rss_init(struct otx2_nic *pfvf);
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 2dd1ac563a25..2b5705d74984 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -631,6 +631,18 @@ static void otx2_set_rx_mode(struct net_device *netdev)
 	otx2_sync_mbox_msg_busy_poll(&pf->mbox);
 }
 
+static void otx2_reset_task(struct work_struct *work)
+{
+	struct otx2_nic *pf = container_of(work, struct otx2_nic, reset_task);
+
+	if (!netif_running(pf->netdev))
+		return;
+
+	otx2_stop(pf->netdev);
+	otx2_open(pf->netdev);
+	netif_trans_update(pf->netdev);
+}
+
 static const struct net_device_ops otx2_netdev_ops = {
 	.ndo_open		= otx2_open,
 	.ndo_stop		= otx2_stop,
@@ -639,6 +651,7 @@ static const struct net_device_ops otx2_netdev_ops = {
 	.ndo_change_mtu         = otx2_change_mtu,
 	.ndo_set_rx_mode        = otx2_set_rx_mode,
 	.ndo_get_stats64	= otx2_get_stats64,
+	.ndo_tx_timeout         = otx2_tx_timeout,
 };
 
 static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
@@ -754,6 +767,8 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	netdev->min_mtu = OTX2_MIN_MTU;
 	netdev->max_mtu = OTX2_MAX_MTU;
 
+	INIT_WORK(&pf->reset_task, otx2_reset_task);
+
 	err = register_netdev(netdev);
 	if (err) {
 		dev_err(dev, "Failed to register netdevice\n");
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
index 3ebf2069228e..ee1b3d2b95d4 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
@@ -275,6 +275,17 @@ int otx2_napi_handler(struct otx2_cq_queue *cq,
 	s64 bufptr;
 
 	cq_status = otx2_nix_cq_op_status(pfvf, cq->cq_idx);
+	if (cq_status & BIT_ULL(63)) {
+		dev_err(pfvf->dev, "CQ operation error");
+		schedule_work(&pfvf->reset_task);
+		return 0;
+	}
+	if (cq_status & BIT_ULL(46)) {
+		dev_err(pfvf->dev, "CQ stopped due to error");
+		schedule_work(&pfvf->reset_task);
+		return 0;
+	}
+
 	cq_head = (cq_status >> 20) & 0xFFFFF;
 	cq_tail = cq_status & 0xFFFFF;
 
-- 
2.17.1


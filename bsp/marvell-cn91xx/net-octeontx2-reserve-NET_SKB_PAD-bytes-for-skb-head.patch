From f38c6d067dda168129e3cd6c1a74e9c019284a93 Mon Sep 17 00:00:00 2001
From: Tomasz Duszynski <tomasz.duszynski@cavium.com>
Date: Tue, 25 Sep 2018 11:33:27 +0200
Subject: [PATCH 0206/1051] net: octeontx2: reserve NET_SKB_PAD bytes for skb
 headroom

Currently NIC always starts storing received data at offset 0 + apad.
On the other hand we allocate extra NET_SKB_PAD bytes in receive buffer.

NET_SKB_PAD extra bytes are normally used by networking layer to avoid
having to reallocate skb data when header needs to grow.

This patch fixes current situation by adding offset to buffer before
freeing it to aura and reserving NET_SKB_PAD bytes while preparing skb
on RX.

Thus scenarios that do grow headroom (i.e forwarding) do not have to
waste time for reallocation.

Signed-off-by: Tomasz Duszynski <tduszynski@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/marvell/octeontx2/otx2_common.c | 5 ++++-
 drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c   | 6 ++++--
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index cc7bd0ca7b43..cccabb370948 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -696,6 +696,9 @@ void otx2_free_aura_ptr(struct otx2_nic *pfvf, int type)
 		pool = &pfvf->qset.pool[pool_id];
 		iova = otx2_aura_allocptr(pfvf, pool_id);
 		while (iova) {
+			if (type == NIX_AQ_CTYPE_RQ)
+				iova -= NET_SKB_PAD;
+
 			pa = otx2_iova_to_phys(pfvf->iommu_domain, iova);
 			dma_unmap_page_attrs(pfvf->dev, iova, size,
 					     DMA_FROM_DEVICE,
@@ -920,7 +923,7 @@ int otx2_rq_aura_pool_init(struct otx2_nic *pfvf)
 			bufptr = otx2_alloc_rbuf(pfvf, pool);
 			if (bufptr <= 0)
 				return bufptr;
-			otx2_aura_freeptr(pfvf, pool_id, bufptr);
+			otx2_aura_freeptr(pfvf, pool_id, bufptr + NET_SKB_PAD);
 		}
 		otx2_get_page(pool);
 	}
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
index b63855253249..1414f3f9c7ff 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
@@ -145,6 +145,7 @@ static void otx2_skb_add_frag(struct otx2_nic *pfvf,
 	struct page *page;
 	void *va;
 
+	iova -= NET_SKB_PAD;
 	va = phys_to_virt(otx2_iova_to_phys(pfvf->iommu_domain, iova));
 	page = virt_to_page(va);
 	skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
@@ -160,6 +161,7 @@ otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len, int apad)
 	struct sk_buff *skb;
 	void *va;
 
+	iova -= NET_SKB_PAD;
 	va = phys_to_virt(otx2_iova_to_phys(pfvf->iommu_domain, iova));
 	skb = build_skb(va, RCV_FRAG_LEN);
 	if (!skb) {
@@ -167,7 +169,7 @@ otx2_get_rcv_skb(struct otx2_nic *pfvf, u64 iova, int len, int apad)
 		return NULL;
 	}
 
-	skb_reserve(skb, apad);
+	skb_reserve(skb, apad + NET_SKB_PAD);
 	skb_put(skb, len);
 
 	dma_unmap_page_attrs(pfvf->dev, iova - apad, RCV_FRAG_LEN,
@@ -332,7 +334,7 @@ int otx2_napi_handler(struct otx2_cq_queue *cq,
 		bufptr = otx2_alloc_rbuf(pfvf, rbpool);
 		if (bufptr <= 0)
 			break;
-		otx2_aura_freeptr(pfvf, cq->cq_idx, bufptr);
+		otx2_aura_freeptr(pfvf, cq->cq_idx, bufptr + NET_SKB_PAD);
 		pool_ptrs--;
 	}
 	otx2_get_page(rbpool);
-- 
2.17.1


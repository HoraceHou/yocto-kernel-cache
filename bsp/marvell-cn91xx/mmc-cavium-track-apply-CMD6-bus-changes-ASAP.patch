From d42620e3dc06258e09502bfc83c9ff1cdd455ebc Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@marvell.com>
Date: Thu, 24 Jan 2019 01:54:16 -0800
Subject: [PATCH 0914/1051] mmc: cavium: track & apply CMD6 bus changes ASAP

When mmc/core issued CMD6 to change bus width, timing
and encoding style, we must apply the change to our
hardware immediately.
Previous code applied it eventually, but meanwhile
mmc/core code had been polling status with CMD13
under the old protocol, which may have been causing
HS400 transitions to fail.

To apply the change immediately, at IRQ-time, the host
pointer is set on every outgoing request, so IRQ handler
can find context (the associated cvm_mmc_slot) for a
successfully executed CMD6, and the MIO_EMM_SWITCH value
it should apply, to bring the host hardware & target card
into alignment.

CMD6 can potentially set/clear individual bits of ext_csd,
which would require caching the ext_csd entries for the 3
bytes we track, to reconstruct the meaning.
But fortunately mmc/core only issues a full-byte assignment
(action=3) for the power/width/timing properties we mirror.
Should this change, more work may be needed here.

Change-Id: I13df44e96d61a071b73f1d3f014ff0276ba51135
Signed-off-by: Peter Swain <pswain@marvell.com>
Depends-On: I60086d3164aee116cb6b1daf496691430da35544
Reviewed-on: https://sj1git1.cavium.com/2731
Reviewed-by: Peter Swain <pswain@cavium.com>
Tested-by: sa_ip-sw-jenkins
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium.c | 77 +++++++++++++++++++++++++++++++++++----
 drivers/mmc/host/cavium.h |  8 +++-
 2 files changed, 76 insertions(+), 9 deletions(-)

diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index d440b3862eca..5e45c7a7f3fe 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -271,7 +271,8 @@ static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 {
 	int retries = 100;
 	u64 rsp_sts;
-	int bus_id;
+	int bus_id = get_bus_id(emm_switch);
+	struct cvm_mmc_slot *slot = host->slot[bus_id];
 
 	/*
 	 * Modes setting only taken from slot 0. Work around that hardware
@@ -293,6 +294,11 @@ static void do_switch(struct cvm_mmc_host *host, u64 emm_switch)
 	} while (--retries);
 
 	check_switch_errors(host);
+
+	if (slot) {
+		slot->cmd6_pending = false;
+		slot->cached_switch = emm_switch;
+	}
 }
 
 /* need to change hardware state to match software requirements? */
@@ -345,14 +351,11 @@ static void cvm_mmc_reset_bus(struct cvm_mmc_slot *slot)
 	u64 emm_switch, wdog;
 
 	emm_switch = readq(host->base + MIO_EMM_SWITCH(host));
-	emm_switch &= ~(MIO_EMM_SWITCH_EXE | MIO_EMM_SWITCH_ERR0 |
-			MIO_EMM_SWITCH_ERR1 | MIO_EMM_SWITCH_ERR2);
+	emm_switch &= ~(MIO_EMM_SWITCH_EXE | MIO_EMM_SWITCH_ERRS);
 	set_bus_id(&emm_switch, slot->bus_id);
 
 	wdog = readq(host->base + MIO_EMM_WDOG(host));
 	do_switch(host, emm_switch);
-
-	slot->cached_switch = emm_switch;
 	host->powered = true;
 
 	msleep(20);
@@ -538,6 +541,8 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 {
 	struct cvm_mmc_host *host = dev_id;
 	struct mmc_request *req;
+	struct mmc_host *mmc;
+	struct cvm_mmc_slot *slot;
 	unsigned long flags = 0;
 	u64 emm_int, rsp_sts;
 	bool host_done;
@@ -558,6 +563,9 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 	if (!req)
 		goto out;
 
+	mmc = req->host;
+	slot = !mmc ? NULL : mmc_priv(mmc);
+
 	rsp_sts = readq(host->base + MIO_EMM_RSP_STS(host));
 
 	/*
@@ -610,6 +618,14 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 	    (rsp_sts & MIO_EMM_RSP_STS_DMA_PEND))
 		cleanup_dma(host, rsp_sts);
 
+	/* follow CMD6 timing/width with IMMEDIATE switch */
+	if (slot && slot->cmd6_pending) {
+		if (host_done && !req->cmd->error)
+			do_switch(host, slot->want_switch);
+		else if (slot)
+			slot->cmd6_pending = false;
+	}
+
 	host->current_req = NULL;
 	req->done(req);
 
@@ -889,6 +905,51 @@ static void do_write_request(struct cvm_mmc_host *host, struct mmc_request *mrq)
 	sg_miter_stop(smi);
 }
 
+static void cvm_mmc_track_switch(struct cvm_mmc_slot *slot, u32 cmd_arg)
+{
+	u8 how = (cmd_arg >> 24) & 3;
+	u8 where = (u8)(cmd_arg >> 16);
+	u8 val = (u8)(cmd_arg >> 8);
+
+	slot->want_switch = slot->cached_switch;
+
+	/*
+	 * track ext_csd assignments (how==3) for critical entries
+	 * to make sure we follow up with MIO_EMM_SWITCH adjustment
+	 * before ANY mmc/core interaction at old settings.
+	 * Current mmc/core logic (linux 4.14) does not set/clear
+	 * bits (how = 1 or 2), which would require more complex
+	 * logic to track the intent of a change
+	 */
+
+	if (how != 3)
+		return;
+
+	switch (where) {
+	case EXT_CSD_BUS_WIDTH:
+		slot->want_switch &= ~MIO_EMM_SWITCH_BUS_WIDTH;
+		slot->want_switch |=
+			FIELD_PREP(MIO_EMM_SWITCH_BUS_WIDTH, val);
+		break;
+	case EXT_CSD_POWER_CLASS:
+		slot->want_switch &= ~MIO_EMM_SWITCH_POWER_CLASS;
+		slot->want_switch |=
+			FIELD_PREP(MIO_EMM_SWITCH_POWER_CLASS, val);
+		break;
+	case EXT_CSD_HS_TIMING:
+		slot->want_switch &= ~MIO_EMM_SWITCH_TIMING;
+		if (val)
+			slot->want_switch |=
+				FIELD_PREP(MIO_EMM_SWITCH_TIMING,
+					(1 << (val - 1)));
+		break;
+	default:
+		return;
+	}
+
+	slot->cmd6_pending = true;
+}
+
 static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct cvm_mmc_slot *slot = mmc_priv(mmc);
@@ -919,6 +980,7 @@ static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	WARN_ON(host->current_req);
 	host->current_req = mrq;
+	mrq->host = mmc;
 
 	if (cmd->data) {
 		if (cmd->data->flags & MMC_DATA_READ)
@@ -934,6 +996,9 @@ static void cvm_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	host->dma_active = false;
 	host->int_enable(host, MIO_EMM_INT_CMD_DONE | MIO_EMM_INT_CMD_ERR);
 
+	if (cmd->opcode == MMC_SWITCH)
+		cvm_mmc_track_switch(slot, cmd->arg);
+
 	emm_cmd = FIELD_PREP(MIO_EMM_CMD_VAL, 1) |
 		  FIELD_PREP(MIO_EMM_CMD_CTYPE_XOR, mods.ctype_xor) |
 		  FIELD_PREP(MIO_EMM_CMD_RTYPE_XOR, mods.rtype_xor) |
@@ -1138,8 +1203,6 @@ static int cvm_mmc_init_lowlevel(struct cvm_mmc_slot *slot)
 	/* Make the changes take effect on this bus slot. */
 	set_bus_id(&emm_switch, slot->bus_id);
 	do_switch(host, emm_switch);
-
-	slot->cached_switch = emm_switch;
 	host->powered = true;
 
 	/*
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index e7f1417ab983..f93a73a5803d 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -155,6 +155,8 @@ struct cvm_mmc_slot {
 	unsigned int slew;		/* clock skew */
 
 	int bus_id;
+	bool cmd6_pending;
+	u64 want_switch;
 };
 
 struct cvm_mmc_cr_type {
@@ -266,9 +268,11 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_SWITCH_ERR0		BIT_ULL(58)
 #define MIO_EMM_SWITCH_ERR1		BIT_ULL(57)
 #define MIO_EMM_SWITCH_ERR2		BIT_ULL(56)
-#define MIO_EMM_SWITCH_HS_TIMING	BIT_ULL(48)
-#define MIO_EMM_SWITCH_HS200_TIMING	BIT_ULL(49)
+#define MIO_EMM_SWITCH_ERRS		GENMASK_ULL(58, 56)
 #define MIO_EMM_SWITCH_HS400_TIMING	BIT_ULL(50)
+#define MIO_EMM_SWITCH_HS200_TIMING	BIT_ULL(49)
+#define MIO_EMM_SWITCH_HS_TIMING	BIT_ULL(48)
+#define MIO_EMM_SWITCH_TIMING		GENMASK_ULL(50, 48)
 #define MIO_EMM_SWITCH_BUS_WIDTH	GENMASK_ULL(42, 40)
 #define MIO_EMM_SWITCH_POWER_CLASS	GENMASK_ULL(35, 32)
 #define MIO_EMM_SWITCH_CLK_HI		GENMASK_ULL(31, 16)
-- 
2.17.1


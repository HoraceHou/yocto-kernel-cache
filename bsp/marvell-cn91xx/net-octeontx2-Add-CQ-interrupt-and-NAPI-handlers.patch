From 79116c33764df980117ec76f818d7f8b85596b2c Mon Sep 17 00:00:00 2001
From: Sunil Goutham <sgoutham@marvell.com>
Date: Fri, 17 Aug 2018 12:29:24 +0530
Subject: [PATCH 0108/1051] net: octeontx2: Add CQ interrupt and NAPI handlers

This patch enables CQ IRQs (i.e CINTs), registers handlers
and also adds NAPI poll handlers for each of the CQ.

Each of RQ and SQ are mapped to a different CQ to avoid
issues related to CQE limits set for ingress and egress
packets. But these CQs are mapped to same CINT, so that
same CPU processes CQE_RX and CQE_TX, for eg RQ0's CQ
and SQ0's CQ are mapped to CINT0 i.e CPU0.

CQE processing support is not added in this patch.

Signed-off-by: Sunil Goutham <sgoutham@marvell.com>
Signed-off-by: Geetha sowjanya <gakula@marvell.com>
Signed-off-by: Linu Cherian <lcherian@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/marvell/octeontx2/Makefile   |   2 +-
 .../ethernet/marvell/octeontx2/otx2_common.c  |  32 +++-
 .../ethernet/marvell/octeontx2/otx2_common.h  |  41 +++---
 .../net/ethernet/marvell/octeontx2/otx2_pf.c  | 138 +++++++++++++++++-
 .../net/ethernet/marvell/octeontx2/otx2_reg.h |  50 +++++++
 .../ethernet/marvell/octeontx2/otx2_struct.h  |  27 ++++
 .../ethernet/marvell/octeontx2/otx2_txrx.c    | 112 ++++++++++++++
 .../ethernet/marvell/octeontx2/otx2_txrx.h    |  58 ++++++++
 8 files changed, 429 insertions(+), 31 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
 create mode 100644 drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h

diff --git a/drivers/net/ethernet/marvell/octeontx2/Makefile b/drivers/net/ethernet/marvell/octeontx2/Makefile
index 41855bf9dc82..3d4f219508fd 100644
--- a/drivers/net/ethernet/marvell/octeontx2/Makefile
+++ b/drivers/net/ethernet/marvell/octeontx2/Makefile
@@ -5,6 +5,6 @@
 
 obj-$(CONFIG_OCTEONTX2_PF) += octeontx2_nicpf.o
 
-octeontx2_nicpf-y := otx2_pf.o otx2_common.o
+octeontx2_nicpf-y := otx2_pf.o otx2_common.o otx2_txrx.o
 
 ccflags-y += -I$(srctree)/drivers/soc/marvell/octeontx2
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index e8c76da0903e..7af58d6bf535 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -191,7 +191,24 @@ static int otx2_sq_init(struct otx2_nic *pfvf, u16 qidx)
 
 static int otx2_cq_init(struct otx2_nic *pfvf, u16 qidx)
 {
+	struct otx2_qset *qset = &pfvf->qset;
 	struct nix_aq_enq_req *aq;
+	struct otx2_cq_queue *cq;
+	int err;
+
+	cq = &qset->cq[qidx];
+	cq->cqe_cnt = Q_COUNT(Q_SIZE_4K);
+	cq->cqe_size = pfvf->qset.xqe_size;
+
+	/* Allocate memory for CQEs */
+	err = qmem_alloc(pfvf->dev, &cq->cqe, cq->cqe_cnt, cq->cqe_size);
+	if (err)
+		return err;
+
+	/* Save CQE CPU base for faster reference */
+	cq->cqe_base = cq->cqe->base;
+	cq->rbpool = &qset->pool[qidx];
+	cq->cq_idx = qidx;
 
 	/* Get memory to put this msg */
 	aq = otx2_mbox_alloc_msg_NIX_AQ_ENQ(&pfvf->mbox);
@@ -201,7 +218,10 @@ static int otx2_cq_init(struct otx2_nic *pfvf, u16 qidx)
 	aq->cq.ena = 1;
 	aq->cq.qsize = Q_SIZE_4K;
 	aq->cq.caching = 1;
-	aq->cq.base = 1;
+	aq->cq.base = cq->cqe->iova;
+	aq->cq.cint_idx = (qidx < pfvf->hw.rx_queues) ? qidx
+				: (qidx - pfvf->hw.rx_queues);
+	cq->cint_idx = aq->cq.cint_idx;
 
 	/* Fill AQ info */
 	aq->qidx = qidx;
@@ -607,8 +627,9 @@ void mbox_handler_MSIX_OFFSET(struct otx2_nic *pfvf,
 
 void otx2_disable_msix(struct otx2_nic *pfvf)
 {
+	struct otx2_qset *qset = &pfvf->qset;
 	struct otx2_hw *hw = &pfvf->hw;
-	int irq;
+	int irq, qidx = 0;
 
 	if (!hw->irq_allocated)
 		goto freemem;
@@ -617,7 +638,12 @@ void otx2_disable_msix(struct otx2_nic *pfvf)
 	for (irq = 0; irq < hw->num_vec; irq++) {
 		if (!hw->irq_allocated[irq])
 			continue;
-		free_irq(pci_irq_vector(hw->pdev, irq), pfvf);
+		if (irq < (hw->nix_msixoff + NIX_LF_CINT_VEC_START)) {
+			free_irq(pci_irq_vector(pfvf->pdev, irq), pfvf);
+		} else {
+			free_irq(pci_irq_vector(pfvf->pdev, irq),
+				 &qset->napi[qidx++]);
+		}
 	}
 
 	pci_free_irq_vectors(hw->pdev);
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index 4b48c4073400..1b82e36f8183 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -14,6 +14,7 @@
 #include <mbox.h>
 
 #include "otx2_reg.h"
+#include "otx2_txrx.h"
 
 /* PCI device IDs */
 #define PCI_DEVID_OCTEONTX2_RVU_PF              0xA063
@@ -24,28 +25,12 @@
 
 #define NAME_SIZE                               32
 
-#define RQ_QLEN		1024
-#define SQ_QLEN		1024
-
-#define DMA_BUFFER_LEN	1536 /* In multiples of 128bytes */
-#define RCV_FRAG_LEN	(SKB_DATA_ALIGN(DMA_BUFFER_LEN + NET_SKB_PAD) + \
-			 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
-
-struct otx2_pool {
-	struct qmem		*stack;
-	struct qmem		*fc_addr;
-	u16			rbsize;
-	u32			page_offset;
-	u16			pageref;
-	struct page		*page;
-};
-
-struct otx2_qset {
-#define OTX2_MAX_CQ_CNT		64
-	u16			cq_cnt;
-	u16			xqe_size; /* Size of CQE i.e 128 or 512 bytes*/
-	struct otx2_pool	*pool;
-};
+/* NIX LF interrupts range*/
+#define NIX_LF_QINT_VEC_START	0x00
+#define NIX_LF_CINT_VEC_START	0x40
+#define NIX_LF_GINT_VEC		0x80
+#define NIX_LF_ERR_VEC		0x81
+#define NIX_LF_POISON_VEC	0x82
 
 struct  mbox {
 	struct otx2_mbox	mbox;
@@ -74,6 +59,7 @@ struct otx2_hw {
 	bool			*irq_allocated;
 	char			*irq_name;
 
+	u8			cint_cnt; /* CQ interrupt count */
 	u16		txschq_list[NIX_TXSCH_LVL_CNT][MAX_TXSCHQ_PER_FUNC];
 };
 
@@ -192,6 +178,17 @@ static struct _req_type __maybe_unused					\
 MBOX_MESSAGES
 #undef M
 
+#define	RVU_PFVF_PF_SHIFT	10
+#define	RVU_PFVF_PF_MASK	0x3F
+#define	RVU_PFVF_FUNC_SHIFT	0
+#define	RVU_PFVF_FUNC_MASK	0x3FF
+
+static inline int rvu_get_pf(u16 pcifunc)
+{
+	return (pcifunc >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;
+}
+
+/* MSI-X APIs */
 int otx2_enable_msix(struct otx2_hw *hw);
 void otx2_disable_msix(struct otx2_nic *pfvf);
 
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 65ceea2e65db..d220b2bba754 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -18,6 +18,7 @@
 
 #include "otx2_reg.h"
 #include "otx2_common.h"
+#include "otx2_txrx.h"
 
 #define DRV_NAME	"octeontx2-nicpf"
 #define DRV_STRING	"Marvell OcteonTX2 NIC Physical Function Driver"
@@ -256,6 +257,38 @@ static int otx2_set_real_num_queues(struct net_device *netdev,
 	return err;
 }
 
+static irqreturn_t otx2_cq_intr_handler(int irq, void *cq_irq)
+{
+	struct otx2_cq_poll *cq_poll = (struct otx2_cq_poll *)cq_irq;
+	struct otx2_nic *pf = (struct otx2_nic *)cq_poll->dev;
+	int qidx = cq_poll->cint_idx;
+
+	/* Disable interrupts.
+	 *
+	 * Completion interrupts behave in a level-triggered interrupt
+	 * fashion, and hence have to be cleared only after it is serviced.
+	 */
+	otx2_write64(pf, NIX_LF_CINTX_ENA_W1C(qidx), BIT_ULL(0));
+
+	/* Schedule NAPI */
+	napi_schedule_irqoff(&cq_poll->napi);
+
+	return IRQ_HANDLED;
+}
+
+static void otx2_disable_napi(struct otx2_nic *pf)
+{
+	struct otx2_qset *qset = &pf->qset;
+	struct otx2_cq_poll *cq_poll;
+	int qidx;
+
+	for (qidx = 0; qidx < pf->hw.cint_cnt; qidx++) {
+		cq_poll = &qset->napi[qidx];
+		napi_disable(&cq_poll->napi);
+		netif_napi_del(&cq_poll->napi);
+	}
+}
+
 static int otx2_init_hw_resources(struct otx2_nic *pf)
 {
 	int err, lvl;
@@ -300,7 +333,9 @@ static int otx2_init_hw_resources(struct otx2_nic *pf)
 static int otx2_open(struct net_device *netdev)
 {
 	struct otx2_nic *pf = netdev_priv(netdev);
-	int err = 0;
+	struct otx2_cq_poll *cq_poll = NULL;
+	struct otx2_qset *qset = &pf->qset;
+	int err = 0, qidx, vec;
 
 	netif_carrier_off(netdev);
 
@@ -309,24 +344,117 @@ static int otx2_open(struct net_device *netdev)
 		return err;
 
 	pf->qset.cq_cnt = pf->hw.rx_queues + pf->hw.tx_queues;
+	/* RQ and SQs are mapped to different CQs,
+	 * so find out max CQ IRQs (i.e CINTs) needed.
+	 */
+	pf->hw.cint_cnt = max(pf->hw.rx_queues, pf->hw.tx_queues);
+	qset->napi = kcalloc(pf->hw.cint_cnt, sizeof(*cq_poll), GFP_KERNEL);
+	if (!qset->napi)
+		return -ENOMEM;
+
+	qset->cq = kcalloc(pf->qset.cq_cnt,
+			   sizeof(struct otx2_cq_queue), GFP_KERNEL);
+	if (!qset->cq)
+		goto freemem;
+
+	err = otx2_init_hw_resources(pf);
+	if (err)
+		goto freemem;
+
+	/* Register NAPI handler */
+	for (qidx = 0; qidx < pf->hw.cint_cnt; qidx++) {
+		cq_poll = &qset->napi[qidx];
+		cq_poll->cint_idx = qidx;
+		/* RQ0 & SQ0 are mapped to CINT0 and so on..
+		 * 'cq_ids[0]' points to RQ's CQ and
+		 * 'cq_ids[1]' points to SQ's CQ and
+		 */
+		cq_poll->cq_ids[0] =
+			(qidx <  pf->hw.rx_queues) ? qidx : CINT_INVALID_CQ;
+		cq_poll->cq_ids[1] = (qidx < pf->hw.tx_queues) ?
+				      qidx + pf->hw.rx_queues : CINT_INVALID_CQ;
+		cq_poll->dev = (void *)pf;
+		netif_napi_add(netdev, &cq_poll->napi,
+			       otx2_poll, NAPI_POLL_WEIGHT);
+		napi_enable(&cq_poll->napi);
+	}
 
 	/* Check if MAC address from AF is valid or else set a random MAC */
 	if (is_zero_ether_addr(netdev->dev_addr))
 		eth_hw_addr_random(netdev);
 
-	err = otx2_init_hw_resources(pf);
-	if (err)
-		return err;
+	/* Register CQ IRQ handlers */
+	vec = pf->hw.nix_msixoff + NIX_LF_CINT_VEC_START;
+	for (qidx = 0; qidx < pf->hw.cint_cnt; qidx++) {
+		sprintf(&pf->hw.irq_name[vec * NAME_SIZE], "%s-rxtx-%d",
+			pf->netdev->name, qidx);
+
+		err = request_irq(pci_irq_vector(pf->pdev, vec),
+				  otx2_cq_intr_handler, 0,
+				  &pf->hw.irq_name[vec * NAME_SIZE],
+				  &qset->napi[qidx]);
+		if (err) {
+			dev_err(pf->dev,
+				"RVUPF%d: IRQ registration failed for CQ%d\n",
+				rvu_get_pf(pf->pcifunc), qidx);
+			goto cleanup;
+		}
+		pf->hw.irq_allocated[vec] = true;
+		vec++;
+
+		/* Configure CQE interrupt coalescing parameters.
+		 * Set ECOUNT_WAIT and QCOUNT_WAIT to non-zero values.
+		 * TODO: Add timer expiry coalescing as well,
+		 * for now trigger a IRQ when CQE count >= 1.
+		 */
+		otx2_write64(pf, NIX_LF_CINTX_WAIT(qidx), 0x00);
+
+		/* Enable CQ IRQ */
+		otx2_write64(pf, NIX_LF_CINTX_INT(qidx), BIT_ULL(0));
+		otx2_write64(pf, NIX_LF_CINTX_ENA_W1S(qidx), BIT_ULL(0));
+	}
 
 	return 0;
+
+cleanup:
+	otx2_disable_napi(pf);
+	otx2_disable_msix(pf);
+freemem:
+	kfree(qset->cq);
+	kfree(qset->napi);
+	return err;
 }
 
 static int otx2_stop(struct net_device *netdev)
 {
 	struct otx2_nic *pf = netdev_priv(netdev);
+	struct otx2_cq_poll *cq_poll = NULL;
+	struct otx2_qset *qset = &pf->qset;
+	int qidx, vec;
+
+	netif_carrier_off(netdev);
+	netif_tx_stop_all_queues(netdev);
+
+	/* Cleanup CQ NAPI and IRQ */
+	vec = pf->hw.nix_msixoff + NIX_LF_CINT_VEC_START;
+	for (qidx = 0; qidx < pf->hw.cint_cnt; qidx++) {
+		/* Disable interrupt */
+		otx2_write64(pf, NIX_LF_CINTX_ENA_W1C(qidx), BIT_ULL(0));
+
+		synchronize_irq(pci_irq_vector(pf->pdev, vec));
+
+		cq_poll = &qset->napi[qidx];
+		napi_synchronize(&cq_poll->napi);
+		vec++;
+	}
 
+	netif_tx_disable(netdev);
 	otx2_disable_msix(pf);
 
+	otx2_disable_napi(pf);
+	kfree(qset->cq);
+	kfree(qset->napi);
+	memset(qset, 0, sizeof(*qset));
 	return 0;
 }
 
@@ -370,7 +498,7 @@ static int otx2_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	pci_set_master(pdev);
 
 	/* Set number of queues */
-	qcount = num_online_cpus();
+	qcount = min_t(int, num_online_cpus(), OTX2_MAX_CQ_CNT);
 
 	netdev = alloc_etherdev_mqs(sizeof(*pf), qcount, qcount);
 	if (!netdev) {
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h b/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h
index 3f0c9a6e147d..db8d93e4cd7a 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_reg.h
@@ -89,6 +89,51 @@
 #define NPA_LF_QINTX_ENA_W1S(a)         (NPA_LFBASE | 0x320 | (a) << 12)
 #define NPA_LF_QINTX_ENA_W1C(a)         (NPA_LFBASE | 0x330 | (a) << 12)
 
+/* NIX LF registers */
+#define	NIX_LFBASE			(BLKADDR_NIX0 << 20)
+#define	NIX_LF_RX_SECRETX(a)		(NIX_LFBASE | 0x0 | (a) << 3)
+#define	NIX_LF_CFG			(NIX_LFBASE | 0x100)
+#define	NIX_LF_GINT			(NIX_LFBASE | 0x200)
+#define	NIX_LF_GINT_W1S			(NIX_LFBASE | 0x208)
+#define	NIX_LF_GINT_ENA_W1C		(NIX_LFBASE | 0x210)
+#define	NIX_LF_GINT_ENA_W1S		(NIX_LFBASE | 0x218)
+#define	NIX_LF_ERR_INT			(NIX_LFBASE | 0x220)
+#define	NIX_LF_ERR_INT_W1S		(NIX_LFBASE | 0x228)
+#define	NIX_LF_ERR_INT_ENA_W1C		(NIX_LFBASE | 0x230)
+#define	NIX_LF_ERR_INT_ENA_W1S		(NIX_LFBASE | 0x238)
+#define	NIX_LF_RAS			(NIX_LFBASE | 0x240)
+#define	NIX_LF_RAS_W1S			(NIX_LFBASE | 0x248)
+#define	NIX_LF_RAS_ENA_W1C		(NIX_LFBASE | 0x250)
+#define	NIX_LF_RAS_ENA_W1S		(NIX_LFBASE | 0x258)
+#define	NIX_LF_SQ_OP_ERR_DBG		(NIX_LFBASE | 0x260)
+#define	NIX_LF_MNQ_ERR_DBG		(NIX_LFBASE | 0x270)
+#define	NIX_LF_SEND_ERR_DBG		(NIX_LFBASE | 0x280)
+#define	NIX_LF_TX_STATX(a)		(NIX_LFBASE | 0x300 | (a) << 3)
+#define	NIX_LF_RX_STATX(a)		(NIX_LFBASE | 0x400 | (a) << 3)
+#define	NIX_LF_OP_SENDX(a)		(NIX_LFBASE | 0x800 | (a) << 3)
+#define	NIX_LF_RQ_OP_INT		(NIX_LFBASE | 0x900)
+#define	NIX_LF_RQ_OP_OCTS		(NIX_LFBASE | 0x910)
+#define	NIX_LF_RQ_OP_PKTS		(NIX_LFBASE | 0x920)
+#define	NIX_LF_OP_IPSEC_DYNO_CN		(NIX_LFBASE | 0x980)
+#define	NIX_LF_SQ_OP_INT		(NIX_LFBASE | 0xa00)
+#define	NIX_LF_SQ_OP_OCTS		(NIX_LFBASE | 0xa10)
+#define	NIX_LF_SQ_OP_PKTS		(NIX_LFBASE | 0xa20)
+#define	NIX_LF_SQ_OP_STATUS		(NIX_LFBASE | 0xa30)
+#define	NIX_LF_CQ_OP_INT		(NIX_LFBASE | 0xb00)
+#define	NIX_LF_CQ_OP_DOOR		(NIX_LFBASE | 0xb30)
+#define	NIX_LF_CQ_OP_STATUS		(NIX_LFBASE | 0xb40)
+#define	NIX_LF_QINTX_CNT(a)		(NIX_LFBASE | 0xC00 | (a) << 12)
+#define	NIX_LF_QINTX_INT(a)		(NIX_LFBASE | 0xC10 | (a) << 12)
+#define	NIX_LF_QINTX_INT_W1S(a)		(NIX_LFBASE | 0xC18 | (a) << 12)
+#define	NIX_LF_QINTX_ENA_W1S(a)		(NIX_LFBASE | 0xC20 | (a) << 12)
+#define	NIX_LF_QINTX_ENA_W1C(a)		(NIX_LFBASE | 0xC30 | (a) << 12)
+#define	NIX_LF_CINTX_CNT(a)		(NIX_LFBASE | 0xD00 | (a) << 12)
+#define	NIX_LF_CINTX_WAIT(a)		(NIX_LFBASE | 0xD10 | (a) << 12)
+#define	NIX_LF_CINTX_INT(a)		(NIX_LFBASE | 0xD20 | (a) << 12)
+#define	NIX_LF_CINTX_INT_W1S(a)		(NIX_LFBASE | 0xD30 | (a) << 12)
+#define	NIX_LF_CINTX_ENA_W1S(a)		(NIX_LFBASE | 0xD40 | (a) << 12)
+#define	NIX_LF_CINTX_ENA_W1C(a)		(NIX_LFBASE | 0xD50 | (a) << 12)
+
 /* NIX AF transmit scheduler registers */
 #define NIX_AF_SMQX_CFG(a)		(0x700 | (a) << 16)
 #define NIX_AF_TL1X_SCHEDULE(a)		(0xC00 | (a) << 16)
@@ -101,4 +146,9 @@
 #define NIX_AF_MDQX_PARENT(a)		(0x1480 | (a) << 16)
 #define NIX_AF_TL3_TL2X_LINKX_CFG(a, b)	(0x1700 | (a) << 16 | (b) << 3)
 
+/* LMT LF registers */
+#define LMT_LFBASE			BIT_ULL(20)
+#define LMT_LF_LMTLINEX(a)		(LMT_LFBASE | 0x000 | (a) << 12)
+#define LMT_LF_LMTCANCEL		(LMT_LFBASE | 0x400)
+
 #endif /* OTX2_REG_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h b/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h
index 793edbd34e52..8527582cee4c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_struct.h
@@ -17,4 +17,31 @@ enum nix_cqesz_e {
 	NIX_XQESZ_W16 = 0x1,
 };
 
+/* NIX wqe/cqe types */
+enum nix_xqe_type {
+	NIX_XQE_TYPE_INVALID   = 0x0,
+	NIX_XQE_TYPE_RX        = 0x1,
+	NIX_XQE_TYPE_RX_IPSECS = 0x2,
+	NIX_XQE_TYPE_RX_IPSECH = 0x3,
+	NIX_XQE_TYPE_RX_IPSECD = 0x4,
+	NIX_XQE_TYPE_SEND      = 0x8,
+};
+
+/* NIX CQE header structure */
+struct nix_cqe_hdr_s {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64 cqe_type              : 4;
+	u64 node                  : 2;
+	u64 reserved_52_57        : 6;
+	u64 q                     : 20;
+	u64 flow_tag              : 32;
+#else
+	u64 flow_tag              : 32;
+	u64 q                     : 20;
+	u64 reserved_52_57        : 6;
+	u64 node                  : 2;
+	u64 cqe_type              : 4;
+#endif
+};
+
 #endif /* OTX2_STRUCT_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
new file mode 100644
index 000000000000..79969e7b4120
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.c
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 RVU Ethernet driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/etherdevice.h>
+#include <net/ip.h>
+
+#include "otx2_reg.h"
+#include "otx2_common.h"
+#include "otx2_struct.h"
+#include "otx2_txrx.h"
+
+static inline u64 otx2_nix_cq_op_status(struct otx2_nic *pfvf, int cq_idx)
+{
+	u64 incr = (u64)cq_idx << 32;
+	atomic64_t *ptr;
+	u64 status;
+
+	ptr = (__force atomic64_t *)(pfvf->reg_base + NIX_LF_CQ_OP_STATUS);
+
+	status = atomic64_fetch_add_relaxed(incr, ptr);
+
+	/* Barrier to prevent speculative reads of CQEs and their
+	 * processing before above load of CQ_STATUS returns.
+	 */
+	dma_rmb();
+
+	return status;
+}
+
+#define CQE_ADDR(CQ, idx) ((CQ)->cqe_base + ((CQ)->cqe_size * (idx)))
+
+static int otx2_napi_handler(struct otx2_cq_queue *cq, struct otx2_nic *pfvf,
+			     int budget)
+{
+	int processed_cqe = 0, cq_head, cq_tail;
+	struct nix_cqe_hdr_s *cqe_hdr;
+	int workdone = 0;
+	u64 cq_status;
+
+	cq_status = otx2_nix_cq_op_status(pfvf, cq->cq_idx);
+	cq_head = (cq_status >> 20) & 0xFFFFF;
+	cq_tail = cq_status & 0xFFFFF;
+	/* Since multiple CQs may be mapped to same CINT,
+	 * check if there are valid CQEs in this CQ.
+	 */
+	if (cq_head == cq_tail)
+		return 0;
+
+	while (cq_head != cq_tail) {
+		if (workdone >= budget)
+			break;
+
+		cqe_hdr = (struct nix_cqe_hdr_s *)CQE_ADDR(cq, cq_head);
+		cq_head++;
+		cq_head &= (cq->cqe_cnt - 1);
+		prefetch(CQE_ADDR(cq, cq_head));
+
+		switch (cqe_hdr->cqe_type) {
+		case NIX_XQE_TYPE_RX:
+			/* Receive packet handler*/
+			workdone++;
+			break;
+		}
+		processed_cqe++;
+	}
+
+	otx2_write64(pfvf, NIX_LF_CQ_OP_DOOR,
+		     ((u64)cq->cq_idx << 32) | processed_cqe);
+
+	return workdone;
+}
+
+int otx2_poll(struct napi_struct *napi, int budget)
+{
+	struct otx2_cq_poll *cq_poll;
+	int workdone = 0, cq_idx, i;
+	struct otx2_cq_queue *cq;
+	struct otx2_qset *qset;
+	struct otx2_nic *pfvf;
+
+	cq_poll = container_of(napi, struct otx2_cq_poll, napi);
+	pfvf = (struct otx2_nic *)cq_poll->dev;
+	qset = &pfvf->qset;
+
+	for (i = 0; i < MAX_CQS_PER_CNT; i++) {
+		cq_idx = cq_poll->cq_ids[i];
+		if (cq_idx == CINT_INVALID_CQ)
+			continue;
+		cq = &qset->cq[cq_idx];
+		workdone = otx2_napi_handler(cq, pfvf, budget);
+	}
+
+	/* Clear the IRQ */
+	otx2_write64(pfvf, NIX_LF_CINTX_INT(cq_poll->cint_idx), BIT_ULL(0));
+
+	if (workdone < budget) {
+		/* Exit polling */
+		napi_complete(napi);
+
+		/* Re-enable interrupts */
+		otx2_write64(pfvf, NIX_LF_CINTX_ENA_W1S(cq_poll->cint_idx),
+			     BIT_ULL(0));
+	}
+	return workdone;
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h
new file mode 100644
index 000000000000..b417c8058afc
--- /dev/null
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_txrx.h
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 RVU Ethernet driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef OTX2_TXRX_H
+#define OTX2_TXRX_H
+
+#define RQ_QLEN		1024
+#define SQ_QLEN		1024
+#define DMA_BUFFER_LEN	1536 /* In multiples of 128bytes */
+#define RCV_FRAG_LEN	(SKB_DATA_ALIGN(DMA_BUFFER_LEN + NET_SKB_PAD) + \
+			 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
+
+struct otx2_cq_poll {
+	void			*dev;
+#define CINT_INVALID_CQ		255
+#define MAX_CQS_PER_CNT		2 /* RQ + SQ */
+	u8			cint_idx;
+	u8			cq_ids[MAX_CQS_PER_CNT];
+	struct napi_struct	napi;
+};
+
+struct otx2_pool {
+	struct qmem		*stack;
+	struct qmem		*fc_addr;
+	u16			rbsize;
+	u32			page_offset;
+	u16			pageref;
+	struct page		*page;
+};
+
+struct otx2_cq_queue {
+	u8			cq_idx;
+	u8			cint_idx; /* CQ interrupt id */
+	u16			cqe_cnt;
+	u16			cqe_size;
+	void			*cqe_base;
+	struct qmem		*cqe;
+	struct otx2_pool	*rbpool;
+};
+
+struct otx2_qset {
+#define OTX2_MAX_CQ_CNT		64
+	u16			cq_cnt;
+	u16			xqe_size;
+	struct otx2_pool	*pool;
+	struct otx2_cq_poll	*napi;
+	struct otx2_cq_queue	*cq;
+};
+
+int otx2_poll(struct napi_struct *napi, int budget);
+#endif /* OTX2_TXRX_H */
-- 
2.17.1


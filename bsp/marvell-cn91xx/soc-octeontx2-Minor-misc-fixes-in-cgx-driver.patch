From 271b739f4d28562ba2cffbdf0cbcea622f724f9c Mon Sep 17 00:00:00 2001
From: Linu Cherian <linu.cherian@cavium.com>
Date: Tue, 30 Oct 2018 12:49:31 +0530
Subject: [PATCH 0362/1051] soc: octeontx2: Minor misc fixes in cgx driver

- Remove unused/unused-but-set variables
- Fix variable declarations to follow reverse christmas-tree style
- Remove redundant calls to cgx_lmac_linkup_start
- Minor cleanups in cgx.h

Signed-off-by: Linu Cherian <linu.cherian@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/soc/marvell/octeontx2/cgx.c     | 13 ++++++-------
 drivers/soc/marvell/octeontx2/cgx.h     |  7 +++----
 drivers/soc/marvell/octeontx2/rvu_cgx.c | 16 +++++++---------
 3 files changed, 16 insertions(+), 20 deletions(-)

diff --git a/drivers/soc/marvell/octeontx2/cgx.c b/drivers/soc/marvell/octeontx2/cgx.c
index c1bff182314a..07967c326b6f 100644
--- a/drivers/soc/marvell/octeontx2/cgx.c
+++ b/drivers/soc/marvell/octeontx2/cgx.c
@@ -227,8 +227,8 @@ static inline u8 cgx_get_lmac_type(struct cgx *cgx, int lmac_id)
 int cgx_lmac_internal_loopback(void *cgxd, int lmac_id, bool enable)
 {
 	struct cgx *cgx = cgxd;
-	u64 cfg;
 	u8 lmac_type;
+	u64 cfg;
 
 	if (!cgx || lmac_id >= cgx->lmac_count)
 		return -ENODEV;
@@ -434,8 +434,8 @@ static inline void link_status_user_format(u64 lstat,
 
 	linfo->link_up = FIELD_GET(RESP_LINKSTAT_UP, lstat);
 	linfo->full_duplex = FIELD_GET(RESP_LINKSTAT_FDUPLEX, lstat);
-	linfo->lmac_type_id = cgx_get_lmac_type(cgx, lmac_id);
 	linfo->speed = cgx_speed_mbps[FIELD_GET(RESP_LINKSTAT_SPEED, lstat)];
+	linfo->lmac_type_id = cgx_get_lmac_type(cgx, lmac_id);
 	lmac_string = cgx_lmactype_string[linfo->lmac_type_id];
 	strncpy(linfo->lmac_type, lmac_string, LMACTYPE_STR_LEN - 1);
 }
@@ -507,17 +507,16 @@ static inline bool cgx_event_is_linkevent(u64 event)
 static irqreturn_t cgx_fwi_event_handler(int irq, void *data)
 {
 	struct lmac *lmac = data;
-	struct cgx *cgx = lmac->cgx;
-	struct device *dev;
+	struct cgx *cgx;
 	u64 event;
 
+	cgx = lmac->cgx;
+
 	event = cgx_read(cgx, lmac->lmac_id, CGX_EVENT_REG);
 
 	if (!FIELD_GET(EVTREG_ACK, event))
 		return IRQ_NONE;
 
-	dev = &cgx->pdev->dev;
-
 	switch (FIELD_GET(EVTREG_EVT_TYPE, event)) {
 	case CGX_EVT_CMD_RESP:
 		/* Copy the response. Since only one command is active at a
@@ -558,8 +557,8 @@ static irqreturn_t cgx_fwi_event_handler(int irq, void *data)
 /* callback registration for hardware events like link change */
 int cgx_lmac_evh_register(struct cgx_event_cb *cb, void *cgxd, int lmac_id)
 {
-	struct lmac *lmac;
 	struct cgx *cgx = cgxd;
+	struct lmac *lmac;
 
 	lmac = lmac_pdata(lmac_id, cgx);
 	if (!lmac)
diff --git a/drivers/soc/marvell/octeontx2/cgx.h b/drivers/soc/marvell/octeontx2/cgx.h
index 9e7915a6bfd1..8374b95d2620 100644
--- a/drivers/soc/marvell/octeontx2/cgx.h
+++ b/drivers/soc/marvell/octeontx2/cgx.h
@@ -25,8 +25,6 @@
 #define CGX_FIFO_LEN			65536 /* 64K for both Rx & Tx */
 #define CGX_OFFSET(x)			((x) * MAX_LMAC_PER_CGX)
 
-#define FW_CGX_INT			(1 << 1) /* Bitfield used in INT reg */
-
 /* Registers */
 #define CGXX_CMRX_CFG			0x00
 #define CMR_EN				BIT_ULL(55)
@@ -34,8 +32,9 @@
 #define DATA_PKT_RX_EN			BIT_ULL(54)
 #define CGX_LMAC_TYPE_SHIFT		40
 #define CGX_LMAC_TYPE_MASK		0xF
-#define CGXX_CMRX_INT			0x40
-#define CGXX_CMRX_INT_ENA_W1S		0x58
+#define CGXX_CMRX_INT			0x040
+#define FW_CGX_INT			BIT_ULL(1)
+#define CGXX_CMRX_INT_ENA_W1S		0x058
 #define CGXX_CMRX_RX_ID_MAP		0x060
 #define CGXX_CMRX_RX_STAT0		0x070
 #define CGXX_CMRX_RX_LMACS		0x128
diff --git a/drivers/soc/marvell/octeontx2/rvu_cgx.c b/drivers/soc/marvell/octeontx2/rvu_cgx.c
index 98a56bc09daa..d37071e9a2f7 100644
--- a/drivers/soc/marvell/octeontx2/rvu_cgx.c
+++ b/drivers/soc/marvell/octeontx2/rvu_cgx.c
@@ -138,8 +138,8 @@ static int rvu_cgx_send_link_info(int cgx_id, int lmac_id, struct rvu *rvu)
 /* This is called from interrupt context and is expected to be atomic */
 static int cgx_lmac_postevent(struct cgx_link_event *event, void *data)
 {
-	struct rvu *rvu = data;
 	struct cgx_evq_entry *qentry;
+	struct rvu *rvu = data;
 
 	/* post event to the event queue */
 	qentry = kmalloc(sizeof(*qentry), GFP_ATOMIC);
@@ -260,7 +260,7 @@ static void rvu_cgx_wq_destroy(struct rvu *rvu)
 
 int rvu_cgx_init(struct rvu *rvu)
 {
-	int cgx, lmac, err;
+	int cgx, err;
 	void *cgxd;
 
 	/* CGX port id starts from 0 and are not necessarily contiguous
@@ -301,13 +301,11 @@ int rvu_cgx_init(struct rvu *rvu)
 		cgxd = rvu_cgx_pdata(cgx, rvu);
 		if (!cgxd)
 			continue;
-		for (lmac = 0; lmac < cgx_get_lmac_cnt(cgxd); lmac++) {
-			err = cgx_lmac_linkup_start(cgxd);
-			if (err)
-				dev_err(rvu->dev,
-					"Link up process failed to start on cgx %d\n",
-					cgx);
-		}
+		err = cgx_lmac_linkup_start(cgxd);
+		if (err)
+			dev_err(rvu->dev,
+				"Link up process failed to start on cgx %d\n",
+				cgx);
 	}
 
 	return 0;
-- 
2.17.1


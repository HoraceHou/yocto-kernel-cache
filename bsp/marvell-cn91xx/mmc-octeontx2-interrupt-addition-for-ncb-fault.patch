From 58ad6ad86a2de46c1d87082af5eb5c9949927d4f Mon Sep 17 00:00:00 2001
From: Sujeet Baranwal <sujeet.baranwal@cavium.com>
Date: Tue, 27 Nov 2018 04:01:10 +0300
Subject: [PATCH 0778/1051] mmc: octeontx2: interrupt addition for ncb fault

Hardware issues DMA requests using NCB. If one of these requests
receives a fault, the NCB_FLT interrupt bit is set. This typically
indicates a bad pointer in one of the structures, or SMMU
misconfiguration. The interrupt handling is on par with DMA
errors.

Signed-off-by: Sujeet Baranwal <sbaranwal@caviumnetworks.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/mmc/host/cavium.c     | 18 ++++++++++++++----
 drivers/mmc/host/cavium.h     |  1 +
 drivers/mmc/host/cavium_mmc.h |  6 ++++--
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/drivers/mmc/host/cavium.c b/drivers/mmc/host/cavium.c
index 6b54692140ac..e47050bc5619 100644
--- a/drivers/mmc/host/cavium.c
+++ b/drivers/mmc/host/cavium.c
@@ -489,6 +489,10 @@ irqreturn_t cvm_mmc_interrupt(int irq, void *dev_id)
 		    emm_int & MIO_EMM_INT_CMD_ERR  ||
 		    emm_int & MIO_EMM_INT_DMA_ERR;
 
+	/* Add NCB_FLT interrupt for octtx2 */
+	if (!is_mmc_8xxx(host))
+		host_done = host_done || emm_int & MIO_EMM_INT_NCB_FLT;
+
 	if (!(host_done && req->done))
 		goto no_req_done;
 
@@ -662,7 +666,7 @@ static void cvm_mmc_dma_request(struct mmc_host *mmc,
 	struct cvm_mmc_slot *slot = mmc_priv(mmc);
 	struct cvm_mmc_host *host = slot->host;
 	struct mmc_data *data;
-	u64 emm_dma, addr;
+	u64 emm_dma, addr, int_enable_mask = 0;
 	int seg;
 
 	if (!mrq->data || !mrq->data->sg || !mrq->data->sg_len ||
@@ -706,8 +710,14 @@ static void cvm_mmc_dma_request(struct mmc_host *mmc,
 	}
 
 	host->dma_active = true;
-	host->int_enable(host, MIO_EMM_INT_CMD_ERR | MIO_EMM_INT_DMA_DONE |
-			 MIO_EMM_INT_DMA_ERR);
+	int_enable_mask = MIO_EMM_INT_CMD_ERR | MIO_EMM_INT_DMA_DONE |
+			MIO_EMM_INT_DMA_ERR;
+
+	/* Add NCB_FLT interrupt for octtx2 */
+	if (!is_mmc_8xxx(host))
+		int_enable_mask |= MIO_EMM_INT_NCB_FLT;
+
+	host->int_enable(host, int_enable_mask);
 
 	if (host->dmar_fixup)
 		host->dmar_fixup(host, mrq->cmd, data, addr);
@@ -853,7 +863,7 @@ static u32 max_supported_frequency(struct cvm_mmc_host *host)
 	/* Default maximum freqeuncey is 52000000 for chip prior to 9X */
 	u32 max_frequency = MHZ_52;
 
-	if (is_mmc_otx2(host)) {
+	if (!is_mmc_8xxx(host)) {
 		/* Default max frequency is 200MHz for 9X chips */
 		max_frequency = MHZ_200;
 
diff --git a/drivers/mmc/host/cavium.h b/drivers/mmc/host/cavium.h
index 33b6f1b07975..8c2c3d87b892 100644
--- a/drivers/mmc/host/cavium.h
+++ b/drivers/mmc/host/cavium.h
@@ -176,6 +176,7 @@ struct cvm_mmc_cr_mods {
 #define MIO_EMM_DMA_CFG_SIZE		GENMASK_ULL(55, 36)
 #define MIO_EMM_DMA_CFG_ADR		GENMASK_ULL(35, 0)
 
+#define MIO_EMM_INT_NCB_FLT		BIT_ULL(7)
 #define MIO_EMM_INT_SWITCH_ERR		BIT_ULL(6)
 #define MIO_EMM_INT_SWITCH_DONE		BIT_ULL(5)
 #define MIO_EMM_INT_DMA_ERR		BIT_ULL(4)
diff --git a/drivers/mmc/host/cavium_mmc.h b/drivers/mmc/host/cavium_mmc.h
index f350212db9a6..31ec52421e58 100644
--- a/drivers/mmc/host/cavium_mmc.h
+++ b/drivers/mmc/host/cavium_mmc.h
@@ -186,7 +186,8 @@ union mio_emm_int {
 	u64 val;
 	struct mio_emm_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-		u64 :57;
+		u64:56;
+		u64 ncb_flt:1;
 		u64 switch_err:1;
 		u64 switch_done:1;
 		u64 dma_err:1;
@@ -202,7 +203,8 @@ union mio_emm_int {
 		u64 dma_err:1;
 		u64 switch_done:1;
 		u64 switch_err:1;
-		u64 :57;
+		u64 ncb_flt:1;
+		u64:56;
 #endif
 	} s;
 };
-- 
2.17.1


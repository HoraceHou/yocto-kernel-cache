From 31b123f5ab9f7588b18ae7e7d13f797d5606d63b Mon Sep 17 00:00:00 2001
From: Grzegorz Jaszczyk <jaz@semihalf.com>
Date: Tue, 19 Feb 2019 16:31:07 +0100
Subject: [PATCH 1032/1051] net: phy: fix Marvell 88E2110 phy support

Add dedicated for 88e2110 handler allowing to read the phy status.

Change-Id: Ia8de366bbcc6b80ac9b9e5d5291871e5b79ff128
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-on: https://sj1git1.cavium.com/4407
Reviewed-by: Stefan Chulski <Stefan.Chulski@cavium.com>
Reviewed-by: Marcin Wojtas <Marcin.Wojtas@cavium.com>
Tested-by: Stefan Chulski <Stefan.Chulski@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/phy/marvell10g.c | 85 +++++++++++++++++++++++++++++++++++-
 1 file changed, 84 insertions(+), 1 deletion(-)

diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
index 47bc8140ce29..34429e863f49 100644
--- a/drivers/net/phy/marvell10g.c
+++ b/drivers/net/phy/marvell10g.c
@@ -27,6 +27,20 @@
 #include <linux/of.h>
 #include <linux/phy.h>
 
+#define MII_88E2110_PHY_STATUS		0x8008
+#define MII_88E2110_PHY_STATUS_SPD_MASK	0xc00c
+#define MII_88E2110_PHY_STATUS_5000	0xc008
+#define MII_88E2110_PHY_STATUS_2500	0xc004
+#define MII_88E2110_PHY_STATUS_1000	0x8000
+#define MII_88E2110_PHY_STATUS_100	0x4000
+#define MII_88E2110_PHY_STATUS_DUPLEX	0x2000
+#define MII_88E2110_PHY_STATUS_SPDDONE	0x0800
+#define MII_88E2110_PHY_STATUS_LINK	0x0400
+
+#define MII_88E2110_ADVERTISE		0x10
+#define MII_88E2110_LPA			0x13
+#define MII_88E2110_STAT1000		0x8001
+
 enum {
 	MV_PCS_BASE_T		= 0x0000,
 	MV_PCS_BASE_R		= 0x1000,
@@ -557,6 +571,75 @@ static int mv3310_read_status(struct phy_device *phydev)
 	return 0;
 }
 
+static int m88e2110_read_status(struct phy_device *phydev)
+{
+	int adv, lpa, lpagb, status;
+
+	status = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_PHY_STATUS);
+	if (status < 0)
+		return status;
+
+	if (!(status & MII_88E2110_PHY_STATUS_LINK)) {
+		phydev->link = 0;
+		return 0;
+	}
+
+	phydev->link = 1;
+	if (status & MII_88E2110_PHY_STATUS_DUPLEX)
+		phydev->duplex = DUPLEX_FULL;
+	else
+		phydev->duplex = DUPLEX_HALF;
+
+	phydev->pause = 0;
+	phydev->asym_pause = 0;
+
+	switch (status & MII_88E2110_PHY_STATUS_SPD_MASK) {
+	case MII_88E2110_PHY_STATUS_5000:
+		phydev->speed = SPEED_5000;
+		break;
+	case MII_88E2110_PHY_STATUS_2500:
+		phydev->speed = SPEED_2500;
+		break;
+	case MII_88E2110_PHY_STATUS_1000:
+		phydev->speed = SPEED_1000;
+		break;
+	case MII_88E2110_PHY_STATUS_100:
+		phydev->speed = SPEED_100;
+		break;
+	default:
+		phydev->speed = SPEED_10;
+		break;
+	}
+
+	if (phydev->autoneg == AUTONEG_ENABLE) {
+		lpa = phy_read_mmd(phydev, MDIO_MMD_AN, MII_88E2110_LPA);
+		if (lpa < 0)
+			return lpa;
+
+		lpagb = phy_read_mmd(phydev, MDIO_MMD_AN, MII_88E2110_STAT1000);
+		if (lpagb < 0)
+			return lpagb;
+
+		adv = phy_read_mmd(phydev, MDIO_MMD_AN, MII_88E2110_ADVERTISE);
+		if (adv < 0)
+			return adv;
+
+		phydev->lp_advertising = mii_stat1000_to_ethtool_lpa_t(lpagb) |
+					 mii_lpa_to_ethtool_lpa_t(lpa);
+
+		lpa &= adv;
+
+		if (phydev->duplex == DUPLEX_FULL) {
+			phydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;
+			phydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;
+		}
+	} else {
+		phydev->lp_advertising = 0;
+	}
+
+	return 0;
+}
+
 static struct phy_driver mv3310_drivers[] = {
 	{
 		.phy_id		= 0x002b09aa,
@@ -597,7 +680,7 @@ static struct phy_driver mv3310_drivers[] = {
 		.config_init	= mv3310_config_init,
 		.config_aneg	= mv3310_config_aneg,
 		.aneg_done	= mv3310_aneg_done,
-		.read_status	= mv3310_read_status,
+		.read_status	= m88e2110_read_status,
 	},
 };
 
-- 
2.17.1


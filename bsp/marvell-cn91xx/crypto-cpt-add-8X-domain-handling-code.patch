From 658113fd2bf26fee8ad96c36446acc7b7168bff5 Mon Sep 17 00:00:00 2001
From: Lukasz Bartosik <lbartosik@marvell.com>
Date: Fri, 28 Dec 2018 15:22:24 +0300
Subject: [PATCH 0874/1051] crypto: cpt - add 8X domain handling code

Change-Id: I134e177cb3c12417e6fcecac509d9d9700ebf145
Signed-off-by: Lukasz Bartosik <lbartosik@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/1781
Tested-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/cavium/cpt/8x/Makefile         |   2 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_pf.h       |   8 +
 .../crypto/cavium/cpt/8x/cpt8x_pf_domain.c    | 218 ++++++++++++++++++
 3 files changed, 227 insertions(+), 1 deletion(-)
 create mode 100644 drivers/crypto/cavium/cpt/8x/cpt8x_pf_domain.c

diff --git a/drivers/crypto/cavium/cpt/8x/Makefile b/drivers/crypto/cavium/cpt/8x/Makefile
index abee10f1625d..c96ef0a896a7 100644
--- a/drivers/crypto/cavium/cpt/8x/Makefile
+++ b/drivers/crypto/cavium/cpt/8x/Makefile
@@ -2,7 +2,7 @@
 obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += cptpf8x.o cptvf8x.o
 
 common-objs := cpt8x_debug.o ../common/cpt_debug.o
-cptpf8x-objs := cpt8x_pf_main.o cpt8x_pf_mbox.o cpt8x_ucode.o ../common/cpt_ucode.o ${common-objs}
+cptpf8x-objs := cpt8x_pf_main.o cpt8x_pf_mbox.o cpt8x_pf_domain.o cpt8x_ucode.o ../common/cpt_ucode.o ${common-objs}
 cptvf8x-objs := cpt8x_vf_main.o cpt8x_vf_mbox.o cpt8x_reqmgr.o ../common/cpt_algs.o ../common/cpt_reqmgr.o
 
 ifeq ($(CONFIG_CRYPTO_DEV_OCTEONTX_CPT), m)
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h b/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h
index 10fd049393dd..cd1ed765b11d 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h
@@ -13,11 +13,19 @@
 
 #include "cpt8x_common.h"
 #include "cpt_ucode.h"
+#include "octeontx.h"
+
+#define CPT_MAX_VF_NUM	64
+
+struct cptpf_vf {
+	struct octeontx_pf_vf domain;
+};
 
 /**
  * cpt device structure
  */
 struct cpt_device {
+	struct cptpf_vf vf[CPT_MAX_VF_NUM]; /* Per VF info */
 	void __iomem *reg_base; /* Register start address */
 	struct pci_dev *pdev; /* Pci device handle */
 	struct engine_groups eng_grps;	/* Engine groups information */
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_domain.c b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_domain.c
new file mode 100644
index 000000000000..c9060841f100
--- /dev/null
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_domain.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2017 Cavium, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#include "cpt8x_pf.h"
+#include "cpt.h"
+
+extern struct mutex octeontx_cpt_devices_lock;
+extern struct list_head octeontx_cpt_devices;
+
+static void identify(struct cptpf_vf *vf, u16 domain_id, u16 subdomain_id)
+{
+	u64 reg = (((u64)subdomain_id << 16) | (domain_id)) << 8;
+
+	writeq(reg, vf->domain.reg_base + CPT_VQX_SADDR(0));
+}
+
+static void cpt_config_gmctl(struct cpt_device *cpt, uint8_t vq,
+			     uint8_t strm, uint16_t gmid)
+{
+	union cptx_pf_qx_gmctl gmctl = {0};
+
+	gmctl.s.strm = strm;
+	gmctl.s.gmid = gmid;
+	writeq(gmctl.u, cpt->reg_base + CPT_PF_QX_GMCTL(vq));
+
+}
+
+static int cpt_pf_remove_domain(u32 node, u16 domain_id, struct kobject *kobj)
+{
+	struct cpt_device *cpt = NULL;
+	struct cpt_device *curr;
+	struct pci_dev *virtfn;
+	struct cptpf_vf *vf;
+	int i, vf_idx = 0;
+
+	mutex_lock(&octeontx_cpt_devices_lock);
+	list_for_each_entry(curr, &octeontx_cpt_devices, list) {
+		if (curr->pf_type == CPT_SE_83XX) {
+			cpt = curr;
+			break;
+		}
+	}
+
+	if (!cpt) {
+		mutex_unlock(&octeontx_cpt_devices_lock);
+		return -ENODEV;
+	}
+
+	for (i = 0; i < cpt->vfs_enabled; i++) {
+		vf = &cpt->vf[i];
+		if (vf->domain.in_use &&
+		    vf->domain.domain_id == domain_id) {
+			virtfn = pci_get_domain_bus_and_slot(
+				     pci_domain_nr(cpt->pdev->bus),
+				     pci_iov_virtfn_bus(cpt->pdev, i),
+				     pci_iov_virtfn_devfn(cpt->pdev, i));
+
+			if (virtfn && kobj)
+				sysfs_remove_link(kobj, virtfn->dev.kobj.name);
+			put_device(&virtfn->dev);
+
+			/* Release the VF to PF */
+			cpt_config_gmctl(cpt, i, 0, 0);
+			identify(vf, 0x0, 0x0);
+			dev_info(&cpt->pdev->dev, "Free vf[%d] from domain_id:%d subdomain_id:%d\n",
+				 i, vf->domain.domain_id, vf_idx);
+			iounmap(vf->domain.reg_base);
+			vf->domain.in_use = false;
+			memset(vf, 0, sizeof(struct cptpf_vf));
+			vf_idx++;
+		}
+	}
+
+	cpt->vfs_in_use -= vf_idx;
+	mutex_unlock(&octeontx_cpt_devices_lock);
+	return 0;
+}
+
+static int cpt_pf_create_domain(u32 node, u16 domain_id,
+				u32 num_vfs, struct kobject *kobj)
+{
+	struct cpt_device *cpt = NULL;
+	struct cpt_device *curr;
+	struct pci_dev *virtfn;
+	struct cptpf_vf *vf;
+	resource_size_t vf_start;
+	int vf_idx = 0, ret = 0;
+	int i;
+
+	if (!kobj)
+		return -EINVAL;
+
+	mutex_lock(&octeontx_cpt_devices_lock);
+	list_for_each_entry(curr, &octeontx_cpt_devices, list) {
+		if (curr->pf_type == CPT_SE_83XX) {
+			cpt = curr;
+			break;
+		}
+	}
+
+	if (!cpt) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	for (i = 0; i < cpt->vfs_enabled; i++) {
+		vf = &cpt->vf[i];
+		if (vf->domain.in_use)
+			continue;
+
+		virtfn = pci_get_domain_bus_and_slot(
+					pci_domain_nr(cpt->pdev->bus),
+					pci_iov_virtfn_bus(cpt->pdev, i),
+					pci_iov_virtfn_devfn(cpt->pdev, i));
+		if (!virtfn)
+			break;
+
+		ret = sysfs_create_link(kobj, &virtfn->dev.kobj,
+					virtfn->dev.kobj.name);
+		if (ret < 0)
+			goto err_unlock;
+		put_device(&virtfn->dev);
+
+		vf_start = pci_resource_start(cpt->pdev,
+					      PCI_CPT_PF_8X_CFG_BAR);
+		vf_start += CPT_BAR_E_CPTX_VFX_8X_BAR0_OFFSET(node, i);
+		vf->domain.reg_base = ioremap(vf_start,
+					      CPT_BAR_E_CPTX_VFX_8X_BAR0_SIZE);
+		if (!vf->domain.reg_base) {
+			ret = -ENOMEM;
+			goto err_unlock;
+		}
+		vf->domain.domain_id = domain_id;
+		vf->domain.subdomain_id = vf_idx;
+		vf->domain.gmid = get_gmid(domain_id);
+		vf->domain.in_use = true;
+
+		cpt_config_gmctl(cpt, i, i + 1, vf->domain.gmid);
+		identify(vf, domain_id, vf_idx);
+
+		vf_idx++;
+		if (vf_idx == num_vfs) {
+			cpt->vfs_in_use += num_vfs;
+			break;
+		}
+	}
+
+	if (vf_idx != num_vfs) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+	mutex_unlock(&octeontx_cpt_devices_lock);
+	return ret;
+
+err_unlock:
+	mutex_unlock(&octeontx_cpt_devices_lock);
+	cpt_pf_remove_domain(node, domain_id, kobj);
+	return ret;
+}
+
+static int cpt_reset_domain(u32 node, u16 domain_id)
+{
+	struct cpt_device *cpt = NULL;
+	struct cpt_device *curr;
+	struct cptpf_vf *vf;
+	u64 inflight = 0;
+	int i, ret;
+
+	mutex_lock(&octeontx_cpt_devices_lock);
+	list_for_each_entry(curr, &octeontx_cpt_devices, list) {
+		if (curr->pf_type == CPT_SE_83XX) {
+			cpt = curr;
+			break;
+		}
+	}
+
+	if (!cpt) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	for (i = 0; i < cpt->vfs_enabled; i++) {
+		vf = &cpt->vf[i];
+		if (vf->domain.in_use &&
+		    vf->domain.domain_id == domain_id) {
+
+			/* Wait till the VQ is empty */
+			inflight = readq(vf->domain.reg_base +
+					 CPT_VQX_INPROG(0));
+
+			while (inflight != 0) {
+				inflight = readq(vf->domain.reg_base +
+						 CPT_VQX_INPROG(0));
+			}
+
+			identify(vf, domain_id, vf->domain.subdomain_id);
+		}
+	}
+
+	mutex_unlock(&octeontx_cpt_devices_lock);
+	return 0;
+
+err_unlock:
+	mutex_unlock(&octeontx_cpt_devices_lock);
+	return ret;
+}
+
+struct cptpf_com_s cptpf_com = {
+	.create_domain = cpt_pf_create_domain,
+	.destroy_domain = cpt_pf_remove_domain,
+	.reset_domain = cpt_reset_domain
+};
+EXPORT_SYMBOL(cptpf_com);
-- 
2.17.1


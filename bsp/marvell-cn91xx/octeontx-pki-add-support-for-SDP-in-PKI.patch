From 32de2ea069a582a6fc2701da059950967618c95f Mon Sep 17 00:00:00 2001
From: Aakash Sasidharan <Aakash.Sasidharan@cavium.com>
Date: Fri, 11 May 2018 19:12:58 +0530
Subject: [PATCH 0342/1051] octeontx-pki: add support for SDP in PKI

Add new functions and make required configuration changes for
supporting SDP port in octeontx-pki sources.

Signed-off-by: Aakash Sasidharan <Aakash.Sasidharan@cavium.com>
Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/cavium/octeontx-83xx/pki.h   |   4 +
 .../cavium/octeontx-83xx/pki_config.c         | 158 +++++++++++++++---
 .../ethernet/cavium/octeontx-83xx/pki_main.c  |  22 ++-
 3 files changed, 157 insertions(+), 27 deletions(-)

diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/pki.h b/drivers/net/ethernet/cavium/octeontx-83xx/pki.h
index 59d8490b7508..02e56ce546ba 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/pki.h
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/pki.h
@@ -431,6 +431,7 @@ struct pkipf_vf {
 
 	struct	pki_port	bgx_port[MAX_PKI_PORTS];
 	struct	pki_port	lbk_port[MAX_PKI_PORTS];
+	struct	pki_port	sdp_port[1];
 
 	/* In future if resources are allocated per domain */
 	int	max_fstyles;
@@ -503,6 +504,8 @@ struct pki_com_s {
 			    struct octtx_bgx_port *port);
 	int (*add_lbk_port)(u32 node, u16 domain_id,
 			    struct octtx_lbk_port *port);
+	int (*add_sdp_port)(u32 node, u16 domain_id,
+			    struct octtx_sdp_port *port);
 	int (*get_bgx_port_stats)(struct octtx_bgx_port *port);
 };
 
@@ -541,6 +544,7 @@ static inline void set_field(u64 *ptr, u64 field_mask, u8 field_shift, u64 val)
 
 int assign_pkind_bgx(struct pkipf_vf *vf, struct octtx_bgx_port *port);
 int assign_pkind_lbk(struct pkipf_vf *vf, struct octtx_lbk_port *port);
+int assign_pkind_sdp(struct pkipf_vf *vf, struct octtx_sdp_port *port);
 void init_styles(struct pki_t *pki);
 
 int pki_port_open(struct pkipf_vf *vf, u16 vf_id, mbox_pki_port_t *port_data);
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c b/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
index e4dc5ae79491..4055b3b65c75 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/pki_config.c
@@ -130,6 +130,30 @@ int assign_pkind_lbk(struct pkipf_vf *vf, struct octtx_lbk_port *port)
 	return pkind;
 }
 
+int assign_pkind_sdp(struct pkipf_vf *vf, struct octtx_sdp_port *port)
+{
+	int pkind;
+
+	if (vf->sdp_port[port->dom_port_idx].valid)
+		return -EEXIST;
+
+	/* TO_DO use alloc/free resource */
+	pkind = SDP_PKIND_BASE;
+
+	if (pkind > (SDP_PKIND_BASE + MAX_SDP_PKIND))
+		return -EINVAL;
+	vf->sdp_port[port->dom_port_idx].valid = true;
+	vf->sdp_port[port->dom_port_idx].pkind = pkind;
+
+	/* by default disable fcs for bgx port as BGX is stripping it,
+	 * should be controllabe by app
+	 */
+	vf->sdp_port[port->dom_port_idx].has_fcs = false;
+	vf->sdp_port[port->dom_port_idx].state = PKI_PORT_CLOSE;
+
+	return pkind;
+}
+
 void init_styles(struct pki_t *pki)
 
 {
@@ -218,6 +242,9 @@ int pki_port_open(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -234,33 +261,58 @@ int pki_port_open(struct pkipf_vf *vf, u16 vf_id,
 	cfg = port->init_style & PKI_PKIND_STYLE_MASK;
 	for (i = 0; i < pki->max_cls; i++)
 		pki_reg_write(pki, PKI_CLX_PKINDX_STYLE(i, port->pkind), cfg);
-	cfg = port->has_fcs ? (0x1ULL << PKI_PKIND_CFG_FCS_SHIFT) : 0;
-	for (i = 0; i < pki->max_cls; i++)
-		pki_reg_write(pki, PKI_CLX_PKINDX_CFG(i, port->pkind), cfg);
-	/* Initialize style typical values*/
-	cfg = 0;
-	if (port->has_fcs) {
-		cfg |= (0x1ULL << PKI_STYLE_CFG_FCS_CHK_SHIFT);
-		cfg |= (0x1ULL << PKI_STYLE_CFG_FCS_STRIP_SHIFT);
-	}
-	cfg |= (0x1ULL << PKI_STYLE_CFG_LENERR_EN_SHIFT);
-	cfg |= (0x1ull << PKI_STYLE_CFG_DROP_SHIFT);
-	for (i = 0; i < pki->max_cls; i++)
-		pki_reg_write(pki, PKI_CLX_STYLEX_CFG(i, port->init_style),
-			      cfg);
 
-	cfg = 0;
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LC_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LD_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LE_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LF_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LC_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LD_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LE_SHIFT);
-	cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LF_SHIFT);
-	for (i = 0; i < pki->max_cls; i++)
-		pki_reg_write(pki, PKI_CLX_STYLEX_CFG2(i, port->init_style),
-			      cfg);
+	if (port_data->port_type == OCTTX_PORT_TYPE_NET) {
+		cfg = port->has_fcs ? (0x1ULL << PKI_PKIND_CFG_FCS_SHIFT) : 0;
+		for (i = 0; i < pki->max_cls; i++)
+			pki_reg_write(pki, PKI_CLX_PKINDX_CFG(i, port->pkind),
+				      cfg);
+		/* Initialize style typical values*/
+		cfg = 0;
+		if (port->has_fcs) {
+			cfg |= (0x1ULL << PKI_STYLE_CFG_FCS_CHK_SHIFT);
+			cfg |= (0x1ULL << PKI_STYLE_CFG_FCS_STRIP_SHIFT);
+		}
+		cfg |= (0x1ULL << PKI_STYLE_CFG_LENERR_EN_SHIFT);
+		cfg |= (0x1ull << PKI_STYLE_CFG_DROP_SHIFT);
+		for (i = 0; i < pki->max_cls; i++)
+			pki_reg_write(pki,
+				      PKI_CLX_STYLEX_CFG(i, port->init_style),
+				      cfg);
+
+		cfg = 0;
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LC_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LD_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LE_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_CSUM_LF_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LC_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LD_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LE_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_LEN_LF_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_TAG_DLC_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_TAG_DLF_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_TAG_SLC_SHIFT);
+		cfg |= (0x1ULL << PKI_STYLE_CFG2_TAG_SLF_SHIFT);
+		for (i = 0; i < pki->max_cls; i++)
+			pki_reg_write(pki,
+				      PKI_CLX_STYLEX_CFG2(i, port->init_style),
+				      cfg);
+	} else { /* For OCTTX_PORT_TYPE_HOST */
+		for (i = 0; i < pki->max_cls; i++) {
+			cfg = pki_reg_read(pki,
+					   PKI_CLX_PKINDX_CFG(i, port->pkind));
+			cfg |= (0x1ULL << PKI_PKIND_CFG_INST_SHIFT);
+			pki_reg_write(pki, PKI_CLX_PKINDX_CFG(i, port->pkind),
+				      cfg);
+		}
+
+		cfg  = 0;
+		for (i = 0; i < pki->max_cls; i++) {
+			pki_reg_write(pki,
+				      PKI_CLX_STYLEX_CFG(i, port->init_style),
+				      cfg);
+		}
+	} /* END OCTTX_PORT_TYPE_HOST */
 
 	port->state = PKI_PORT_OPEN;
 	port->qpg_base = QPG_INVALID;
@@ -282,6 +334,9 @@ int pki_port_alloc_qpg(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -319,6 +374,9 @@ int pki_port_free_qpg(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -360,6 +418,9 @@ int pki_port_create_qos(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -383,6 +444,7 @@ int pki_port_create_qos(struct pkipf_vf *vf, u16 vf_id,
 	}
 	for (i = 0; i < pki->max_cls; i++) {
 		cfg = pki_reg_read(pki, PKI_CLX_STYLEX_ALG(i, style));
+		cfg |= (1ull << PKI_STYLE_ALG_TAG_PRT_SHIFT);
 		set_field(&cfg, PKI_STYLE_ALG_QPG_QOS_MASK,
 			  PKI_STYLE_ALG_QPG_QOS_SHIFT, qcfg->qpg_qos);
 		set_field(&cfg, PKI_STYLE_ALG_TT_MASK,
@@ -405,6 +467,9 @@ int pki_port_create_qos(struct pkipf_vf *vf, u16 vf_id,
 		set_field(&cfg, PKI_QPG_TBL_GRPTAG_OK_MASK,
 			  PKI_QPG_TBL_GRPTAG_OK_SHIFT, qpg->grptag_ok);
 		pki_reg_write(pki, PKI_QPG_TBLX(qpg_base + i), cfg);
+		dev_dbg(&pki->pdev->dev, "PKI : PKI_QPG_TBLX[%d] :: %llx\n",
+			(qpg_base + i),
+			pki_reg_read(pki, PKI_QPG_TBLX(qpg_base + i)));
 		cfg = pki_reg_read(pki, PKI_QPG_TBLBX(qpg_base + i));
 		set_field(&cfg, PKI_QPG_TBLB_STRM_MASK,
 			  PKI_QPG_TBLB_STRM_SHIFT, vf->stream_id);
@@ -413,12 +478,22 @@ int pki_port_create_qos(struct pkipf_vf *vf, u16 vf_id,
 		set_field(&cfg, PKI_QPG_TBLB_ENA_DROP_MASK,
 			  PKI_QPG_TBLB_ENA_DROP_SHIFT, qpg->ena_drop);
 		pki_reg_write(pki, PKI_QPG_TBLBX(qpg_base + i), cfg);
+		dev_dbg(&pki->pdev->dev, "PKI : PKI_QPG_TBLBX[%d] :: %llx\n",
+			(qpg_base + i),
+			pki_reg_read(pki, PKI_QPG_TBLBX(qpg_base + i)));
+		dev_dbg(&pki->pdev->dev, "PKI : PKI_STREAM[%d] CFG ::%llx\n",
+			vf->stream_id,
+			pki_reg_read(pki, PKI_STRMX_CFG(vf->stream_id)));
 	}
 	for (i = 0; i < pki->max_cls; i++) {
 		cfg = pki_reg_read(pki, PKI_CLX_STYLEX_CFG(i, style));
 		set_field(&cfg, PKI_STYLE_CFG_QPG_BASE_MASK, 0, port->qpg_base);
 		pki_reg_write(pki, PKI_CLX_STYLEX_CFG(i, style), cfg);
 	}
+
+	dev_dbg(&pki->pdev->dev, "PKI : vf_id::[%d] port QPG BASE::%d type: %d\n",
+		vf_id, port->qpg_base, qcfg->port_type);
+
 	port->state = PKI_PORT_STOP;
 	return MBOX_RET_SUCCESS;
 }
@@ -437,6 +512,9 @@ int pki_set_port_config(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -560,6 +638,9 @@ int pki_port_start(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -574,6 +655,12 @@ int pki_port_start(struct pkipf_vf *vf, u16 vf_id,
 		cfg &= ~(0x1ULL << PKI_STYLE_CFG_DROP_SHIFT);
 		pki_reg_write(pki, PKI_CLX_STYLEX_CFG(i,
 						      port->init_style), cfg);
+
+		dev_dbg(&pki->pdev->dev,
+			"PKI: PKI_CL[%d]_STYLE[%d]_CFG : 0x%llx\n", i,
+			port->init_style,
+			pki_reg_read(pki,
+				     PKI_CLX_STYLEX_CFG(i, port->init_style)));
 	}
 	port->state = PKI_PORT_START;
 	return MBOX_RET_SUCCESS;
@@ -591,6 +678,9 @@ int pki_port_stop(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -619,6 +709,9 @@ int pki_port_close(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -654,6 +747,9 @@ int pki_port_pktbuf_cfg(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -737,6 +833,10 @@ int pki_port_pktbuf_cfg(struct pkipf_vf *vf, u16 vf_id,
 
 	pki_reg_write(pki, PKI_STYLEX_BUF(port->init_style), reg);
 
+	dev_dbg(&pki->pdev->dev,
+		"PKI: PKI_STYLE[%d]_BUF :: 0x%llx\n", port->init_style,
+		pki_reg_read(pki, PKI_STYLEX_BUF(port->init_style)));
+
 	return MBOX_RET_SUCCESS;
 }
 
@@ -755,6 +855,9 @@ int pki_port_errchk(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
@@ -849,6 +952,9 @@ int pki_port_hashcfg(struct pkipf_vf *vf, u16 vf_id,
 	case OCTTX_PORT_TYPE_NET:
 		port = &vf->bgx_port[vf_id];
 		break;
+	case OCTTX_PORT_TYPE_HOST:
+		port = &vf->sdp_port[vf_id];
+		break;
 	case OCTTX_PORT_TYPE_INT:
 		port = &vf->lbk_port[vf_id];
 		break;
diff --git a/drivers/net/ethernet/cavium/octeontx-83xx/pki_main.c b/drivers/net/ethernet/cavium/octeontx-83xx/pki_main.c
index 2fc3f1cb914a..b6ea1dbbcd69 100644
--- a/drivers/net/ethernet/cavium/octeontx-83xx/pki_main.c
+++ b/drivers/net/ethernet/cavium/octeontx-83xx/pki_main.c
@@ -674,6 +674,25 @@ int pki_add_lbk_port(u32 id, u16 domain_id, struct octtx_lbk_port *port)
 	return pkind;
 }
 
+int pki_add_sdp_port(u32 id, u16 domain_id, struct octtx_sdp_port *port)
+{
+	struct pkipf_vf *vf = NULL;
+	int pkind;
+
+	mutex_lock(&octeontx_pki_devices_lock);
+
+	vf = pki_get_vf(id, domain_id);
+	if (!vf) {
+		mutex_unlock(&octeontx_pki_devices_lock);
+		return -ENODEV;
+	}
+
+	pkind = assign_pkind_sdp(vf, port);
+
+	mutex_unlock(&octeontx_pki_devices_lock);
+	return pkind;
+}
+
 int pki_get_bgx_port_stats(struct octtx_bgx_port *port)
 {
 	struct pki_t *pki;
@@ -696,7 +715,8 @@ struct pki_com_s pki_com  = {
 	.receive_message = pki_receive_message,
 	.add_bgx_port = pki_add_bgx_port,
 	.add_lbk_port = pki_add_lbk_port,
-	.get_bgx_port_stats = pki_get_bgx_port_stats,
+	.add_sdp_port = pki_add_sdp_port,
+	.get_bgx_port_stats = pki_get_bgx_port_stats
 };
 EXPORT_SYMBOL(pki_com);
 
-- 
2.17.1


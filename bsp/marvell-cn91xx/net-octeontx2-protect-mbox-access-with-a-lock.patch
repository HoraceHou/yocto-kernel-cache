From 91ef16a23cf5b2cb0721858d897516bce9afb8d3 Mon Sep 17 00:00:00 2001
From: Tomasz Duszynski <tduszynski@cavium.com>
Date: Tue, 22 Jan 2019 11:43:02 +0000
Subject: [PATCH 0903/1051] net: octeontx2: protect mbox access with a lock

Currently one may easily end up in a situation where couple of userspace
processes race against the very same mbox. For example, changing netdev
settings and accessing PHC simultaneously.

Fix this by protecting mbox access with a lock.

Change-Id: If8b08949badc4491ae0fb665c06bce92da3bcec1
Signed-off-by: Tomasz Duszynski <tduszynski@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/2827
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../ethernet/marvell/octeontx2/otx2_common.c  | 41 ++++++++++---------
 .../ethernet/marvell/octeontx2/otx2_common.h  | 35 ++++++++++------
 .../net/ethernet/marvell/octeontx2/otx2_pf.c  | 41 +++++++++++++------
 .../net/ethernet/marvell/octeontx2/otx2_ptp.c | 28 +++++++------
 .../net/ethernet/marvell/octeontx2/otx2_vf.c  |  1 +
 5 files changed, 89 insertions(+), 57 deletions(-)

diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
index d0748857e5d2..65bff5a06ab3 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.c
@@ -424,7 +424,7 @@ int otx2_txschq_config(struct otx2_nic *pfvf, int lvl)
 int otx2_txsch_alloc(struct otx2_nic *pfvf)
 {
 	struct nix_txsch_alloc_req *req;
-	int lvl, err;
+	int lvl;
 
 	/* Get memory to put this msg */
 	req = otx2_mbox_alloc_msg_nix_txsch_alloc(&pfvf->mbox);
@@ -435,10 +435,7 @@ int otx2_txsch_alloc(struct otx2_nic *pfvf)
 	for (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++)
 		req->schq[lvl] = 1;
 
-	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	if (err)
-		return err;
-	return 0;
+	return otx2_sync_mbox_msg(&pfvf->mbox);
 }
 
 int otx2_txschq_stop(struct otx2_nic *pfvf)
@@ -697,14 +694,15 @@ int otx2_config_nix(struct otx2_nic *pfvf)
 {
 	struct nix_lf_alloc_req *nixlf;
 	struct nix_lf_alloc_rsp *rsp;
-	int err;
+	int err = -ENOMEM;
 
 	pfvf->qset.xqe_size = NIX_XQESZ_W16 ? 128 : 512;
 
 	/* Get memory to put this msg */
+	spin_lock(&pfvf->mbox.lock);
 	nixlf = otx2_mbox_alloc_msg_nix_lf_alloc(&pfvf->mbox);
 	if (!nixlf)
-		return -ENOMEM;
+		goto exit;
 
 	/* Set RQ/SQ/CQ counts */
 	nixlf->rq_cnt = pfvf->hw.rx_queues;
@@ -723,19 +721,27 @@ int otx2_config_nix(struct otx2_nic *pfvf)
 	 */
 	nixlf->rx_cfg = BIT_ULL(33) | BIT_ULL(35) | BIT_ULL(37);
 
-	err = otx2_sync_mbox_msg(&pfvf->mbox);
+	err = __otx2_sync_mbox_msg(&pfvf->mbox);
 	if (err)
-		return err;
+		goto exit;
 
 	rsp = (struct nix_lf_alloc_rsp *)otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0,
 							   &nixlf->hdr);
-	if (IS_ERR(rsp))
-		return PTR_ERR(rsp);
+	if (IS_ERR(rsp)) {
+		err = PTR_ERR(rsp);
+		goto exit;
+	}
 
-	if (rsp->qints < 1)
-		return -ENXIO;
+	if (rsp->qints < 1) {
+		err = -ENXIO;
+		goto exit;
+	}
 
-	return rsp->hdr.rc;
+	err = rsp->hdr.rc;
+exit:
+	otx2_mdev_reset_num_msgs(&pfvf->mbox);
+	spin_unlock(&pfvf->mbox.lock);
+	return err;
 }
 
 void otx2_free_aura_ptr(struct otx2_nic *pfvf, int type)
@@ -1004,7 +1010,7 @@ int otx2_config_npa(struct otx2_nic *pfvf)
 	struct otx2_qset *qset = &pfvf->qset;
 	struct npa_lf_alloc_req  *npalf;
 	struct otx2_hw *hw = &pfvf->hw;
-	int aura_cnt, err;
+	int aura_cnt;
 
 	/* Pool - Stack of free buffer pointers
 	 * Aura - Alloc/frees pointers from/to pool for NIX DMA.
@@ -1028,10 +1034,7 @@ int otx2_config_npa(struct otx2_nic *pfvf)
 	aura_cnt = ilog2(roundup_pow_of_two(hw->pool_cnt));
 	npalf->aura_sz = (aura_cnt >= ilog2(128)) ? (aura_cnt - 6) : 1;
 
-	err = otx2_sync_mbox_msg(&pfvf->mbox);
-	if (err)
-		return err;
-	return 0;
+	return otx2_sync_mbox_msg(&pfvf->mbox);
 }
 
 int otx2_detach_resources(struct mbox *mbox)
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
index 133477f26682..be2a0f397e41 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_common.h
@@ -108,6 +108,7 @@ struct  mbox {
 	struct work_struct	mbox_up_wrk;
 	struct otx2_nic		*pfvf;
 	void *bbuf_base; /* Bounce buffer for mbox memory */
+	spinlock_t lock; /* Used to serialize mbox access */
 };
 
 struct otx2_hw {
@@ -269,35 +270,43 @@ static inline int otx2_get_pool_idx(struct otx2_nic *pfvf, int type, int idx)
 }
 
 /* Mbox APIs */
-static inline int otx2_sync_mbox_msg(struct mbox *mbox)
+static inline int __otx2_sync_mbox_msg(struct mbox *mbox)
 {
 	int err;
 
 	if (!otx2_mbox_nonempty(&mbox->mbox, 0))
 		return 0;
 	otx2_mbox_msg_send(&mbox->mbox, 0);
-	err = otx2_mbox_wait_for_rsp(&mbox->mbox, 0);
+	err = otx2_mbox_busy_poll_for_rsp(&mbox->mbox, 0);
 	if (err)
 		return err;
 
 	return otx2_mbox_check_rsp_msgs(&mbox->mbox, 0);
 }
 
-/* Use this API to send mbox msgs in atomic context
- * where sleeping is not allowed
- */
-static inline int otx2_sync_mbox_msg_busy_poll(struct mbox *mbox)
+static inline void otx2_mdev_reset_num_msgs(struct mbox *mbox)
+{
+	struct otx2_mbox_dev *mdev = &mbox->mbox.dev[0];
+
+	spin_lock(&mdev->mbox_lock);
+	mdev->num_msgs = 0;
+	spin_unlock(&mdev->mbox_lock);
+}
+
+/* Use this API to send mbox msgs if you do not care about message response */
+static inline int otx2_sync_mbox_msg(struct mbox *mbox)
 {
 	int err;
 
-	if (!otx2_mbox_nonempty(&mbox->mbox, 0))
-		return 0;
-	otx2_mbox_msg_send(&mbox->mbox, 0);
-	err = otx2_mbox_busy_poll_for_rsp(&mbox->mbox, 0);
-	if (err)
-		return err;
+	spin_lock(&mbox->lock);
+	err = __otx2_sync_mbox_msg(mbox);
+	/* mark mbox as empty to avoid situation where the same set of messages
+	 * can be send more than once
+	 */
+	otx2_mdev_reset_num_msgs(mbox);
+	spin_unlock(&mbox->lock);
 
-	return otx2_mbox_check_rsp_msgs(&mbox->mbox, 0);
+	return err;
 }
 
 #define M(_name, _id, _fn_name, _req_type, _rsp_type)			\
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
index 20e6204c8167..93bdce1aa021 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_pf.c
@@ -347,6 +347,7 @@ static int otx2_pfaf_mbox_init(struct otx2_nic *pf)
 
 	INIT_WORK(&mbox->mbox_wrk, otx2_pfaf_mbox_handler);
 	INIT_WORK(&mbox->mbox_up_wrk, otx2_pfaf_mbox_up_handler);
+	spin_lock_init(&mbox->lock);
 
 	return 0;
 exit:
@@ -388,11 +389,12 @@ static int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)
 {
 	struct nix_vtag_config *req;
 	struct mbox_msghdr *rsp_hdr;
-	int err;
+	int err = -ENOMEM;
 
+	spin_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_vtag_cfg(&pf->mbox);
 	if (!req)
-		return -ENOMEM;
+		goto exit;
 
 	req->vtag_size = 0;
 	req->cfg_type = 1;
@@ -401,15 +403,21 @@ static int otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)
 	req->rx.strip_vtag = enable;
 	req->rx.capture_vtag = enable;
 
-	err = otx2_sync_mbox_msg(&pf->mbox);
+	err = __otx2_sync_mbox_msg(&pf->mbox);
 	if (err)
-		return err;
+		goto exit;
 
 	rsp_hdr = otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);
-	if (IS_ERR(rsp_hdr))
-		return PTR_ERR(rsp_hdr);
+	if (IS_ERR(rsp_hdr)) {
+		err =  PTR_ERR(rsp_hdr);
+		goto exit;
+	}
 
-	return rsp_hdr->rc;
+	err = rsp_hdr->rc;
+exit:
+	otx2_mdev_reset_num_msgs(&pf->mbox);
+	spin_unlock(&pf->mbox.lock);
+	return err;
 }
 
 int otx2_set_real_num_queues(struct net_device *netdev,
@@ -440,17 +448,21 @@ static void otx2_alloc_rxvlan(struct otx2_nic *pf)
 	struct msg_req *req;
 	int err;
 
+	spin_lock(&pf->mbox.lock);
 	req = otx2_mbox_alloc_msg_nix_rxvlan_alloc(&pf->mbox);
 	if (!req)
-		return;
+		goto exit;
 
-	err = otx2_sync_mbox_msg(&pf->mbox);
+	err = __otx2_sync_mbox_msg(&pf->mbox);
 	if (err)
-		return;
+		goto exit;
 
 	rsp_hdr = otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);
 	if (IS_ERR(rsp_hdr))
-		return;
+		goto exit;
+
+	otx2_mdev_reset_num_msgs(&pf->mbox);
+	spin_unlock(&pf->mbox.lock);
 
 	old = pf->netdev->hw_features;
 	if (rsp_hdr->rc) {
@@ -478,6 +490,11 @@ static void otx2_alloc_rxvlan(struct otx2_nic *pf)
 
 	if (old != pf->netdev->hw_features)
 		netdev_features_change(pf->netdev);
+
+	return;
+exit:
+	otx2_mdev_reset_num_msgs(&pf->mbox);
+	spin_unlock(&pf->mbox.lock);
 }
 
 static irqreturn_t otx2_q_intr_handler(int irq, void *data)
@@ -1003,7 +1020,7 @@ static void otx2_set_rx_mode(struct net_device *netdev)
 	else if (netdev->flags & IFF_ALLMULTI)
 		req->mode |= NIX_RX_MODE_ALLMULTI;
 
-	otx2_sync_mbox_msg_busy_poll(&pf->mbox);
+	otx2_sync_mbox_msg(&pf->mbox);
 }
 
 static void otx2_reset_task(struct work_struct *work)
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c b/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c
index fefc06a66a81..9f51427509b6 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_ptp.c
@@ -33,7 +33,6 @@ static int otx2_ptp_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)
 	struct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,
 					    ptp_info);
 	struct ptp_req *req;
-	int err;
 
 	if (!ptp->nic)
 		return -ENODEV;
@@ -45,11 +44,7 @@ static int otx2_ptp_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)
 	req->op = PTP_OP_ADJFINE;
 	req->scaled_ppm = scaled_ppm;
 
-	err = otx2_sync_mbox_msg_busy_poll(&ptp->nic->mbox);
-	if (err)
-		return err;
-
-	return 0;
+	return otx2_sync_mbox_msg(&ptp->nic->mbox);
 }
 
 static u64 ptp_cc_read(const struct cyclecounter *cc)
@@ -57,27 +52,34 @@ static u64 ptp_cc_read(const struct cyclecounter *cc)
 	struct otx2_ptp *ptp = container_of(cc, struct otx2_ptp, cycle_counter);
 	struct ptp_req *req;
 	struct ptp_rsp *rsp;
-	int err;
+	int err = 0;
 
 	if (!ptp->nic)
 		return 0;
 
+	spin_lock(&ptp->nic->mbox.lock);
 	req = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);
 	if (!req)
-		return 0;
+		goto exit;
 
 	req->op = PTP_OP_GET_CLOCK;
 
-	err = otx2_sync_mbox_msg_busy_poll(&ptp->nic->mbox);
-	if (err)
-		return 0;
+	err = __otx2_sync_mbox_msg(&ptp->nic->mbox);
+	if (err) {
+		err = 0;
+		goto exit;
+	}
 
 	rsp = (struct ptp_rsp *)otx2_mbox_get_rsp(&ptp->nic->mbox.mbox, 0,
 						  &req->hdr);
 	if (IS_ERR(rsp))
-		return 0;
+		goto exit;
 
-	return rsp->clk;
+	err = rsp->clk;
+exit:
+	otx2_mdev_reset_num_msgs(&ptp->nic->mbox);
+	spin_unlock(&ptp->nic->mbox.lock);
+	return err;
 }
 
 static int otx2_ptp_adjtime(struct ptp_clock_info *ptp_info, s64 delta)
diff --git a/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c b/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c
index a07f5853f060..57b8d5c1a5dc 100644
--- a/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c
+++ b/drivers/net/ethernet/marvell/octeontx2/otx2_vf.c
@@ -255,6 +255,7 @@ static int otx2vf_vfaf_mbox_init(struct otx2_nic *vf)
 
 	INIT_WORK(&mbox->mbox_wrk, otx2vf_vfaf_mbox_handler);
 	INIT_WORK(&mbox->mbox_up_wrk, otx2vf_vfaf_mbox_up_handler);
+	spin_lock_init(&mbox->lock);
 
 	return 0;
 exit:
-- 
2.17.1


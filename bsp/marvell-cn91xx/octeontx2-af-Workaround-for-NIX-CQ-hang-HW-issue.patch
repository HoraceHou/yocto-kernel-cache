From f0d911e4f356ee206f05c5f2eca07be7fe5a4eea Mon Sep 17 00:00:00 2001
From: Jerin Jacob <jerinj@marvell.com>
Date: Tue, 19 Feb 2019 09:52:07 +0000
Subject: [PATCH 1011/1051] octeontx2-af: Workaround for NIX CQ hang HW issue

An issue exists in A0 silicon whereby, NIX CQ may reach in CQ full
state followed by CQ hang on CQM query response from stale
CQ context. To avoid such condition, enable internal backpressure
with BP_TEST registers.

Change-Id: Ib62f7168cc95e3bd13c49055fd1dae0f38ba50f1
Signed-off-by: Jerin Jacob <jerinj@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/4355
Tested-by: sa_ip-sw-jenkins
Reviewed-by: Sunil Kovvuri Goutham <Sunil.Goutham@cavium.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/marvell/octeontx2/af/rvu.h |  1 +
 .../ethernet/marvell/octeontx2/af/rvu_fixes.c   | 17 +++++++++++++++++
 .../net/ethernet/marvell/octeontx2/af/rvu_nix.c |  2 ++
 .../net/ethernet/marvell/octeontx2/af/rvu_reg.h |  2 ++
 4 files changed, 22 insertions(+)

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
index d99df45072c5..3b210e329712 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu.h
@@ -692,4 +692,5 @@ int rvu_nix_tx_stall_workaround_init(struct rvu *rvu,
 void rvu_nix_tx_stall_workaround_exit(struct rvu *rvu, struct nix_hw *nix_hw);
 ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 				      char __user *buffer, loff_t *ppos);
+void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr);
 #endif /* RVU_H */
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
index a59b2685b9c4..de5be4ed7ca5 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_fixes.c
@@ -754,3 +754,20 @@ ssize_t rvu_nix_get_tx_stall_counters(struct rvu *rvu,
 	*ppos += len;
 	return len;
 }
+
+void rvu_nix_enable_internal_bp(struct rvu *rvu, int blkaddr)
+{
+	/* An issue exists in A0 silicon whereby, NIX CQ may reach in CQ full
+	 * state followed by CQ hang on CQM query response from stale
+	 * CQ context. To avoid such condition, enable internal backpressure
+	 * with BP_TEST registers.
+	 */
+	if (is_rvu_9xxx_A0(rvu)) {
+		/* Enable internal backpressure on pipe_stg0 */
+		rvu_write64(rvu, blkaddr, NIX_AF_RQM_BP_TEST,
+			    BIT_ULL(51) | BIT_ULL(23) | BIT_ULL(22) | 0x100ULL);
+		/* Enable internal backpressure on cqm query request */
+		rvu_write64(rvu, blkaddr, NIX_AF_CQM_BP_TEST,
+			    BIT_ULL(43) | BIT_ULL(23) | BIT_ULL(22) | 0x100ULL);
+	}
+}
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
index 310683cf7f2a..7651da1a8056 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
@@ -2732,6 +2732,8 @@ int rvu_nix_init(struct rvu *rvu)
 		rvu_write64(rvu, blkaddr, NIX_AF_CFG,
 			    rvu_read64(rvu, blkaddr, NIX_AF_CFG) | 0x5EULL);
 
+	rvu_nix_enable_internal_bp(rvu, blkaddr);
+
 	/* Calibrate X2P bus to check if CGX/LBK links are fine */
 	err = nix_calibrate_x2p(rvu, blkaddr);
 	if (err)
diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h b/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
index d051f2239479..454ff977cc9c 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_reg.h
@@ -399,6 +399,8 @@
 #define NIX_AF_RX_NPC_MIRROR_RCV	(0x4720)
 #define NIX_AF_RX_NPC_MIRROR_DROP	(0x4730)
 #define NIX_AF_RX_ACTIVE_CYCLES_PCX(a)	(0x4800 | (a) << 16)
+#define NIX_AF_RQM_BP_TEST		(0x4880)
+#define NIX_AF_CQM_BP_TEST		(0x48c0)
 
 #define NIX_PRIV_AF_INT_CFG		(0x8000000)
 #define NIX_PRIV_LFX_CFG		(0x8000010)
-- 
2.17.1


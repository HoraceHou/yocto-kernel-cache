From 4a42912e055e70bc7052913abe1671da9d49094c Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Wed, 9 May 2018 19:49:17 +0300
Subject: [PATCH 0640/1051] mvebu: pcie: quirks: enable ACS quirk for A8K/A8KP
 PCIe host controller

Access Control Services (ACS) is a PCIe capability that enables
controlling and limiting peer-to-peer (P2P) access, meaninig PCI devices
directly accessing other PCI devices on the same bus. This capability is
required in order to securely assign PCIe devices to a guest OS without
breaching guest isolation.
Armada-8K/8KP PCIe host controller doesn't support ACS, however it also
doesn't allow P2P transactions. So practically it can be considered as
having a sort of ACS support.
This patch adds the Armada-8K/8KP PCIe host device ID to the list of devices
that exhibit ACS capabilities without actual ACS support.

Change-Id: Ia7dad514746a21e894794d0236109cbd63602bf6
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/pci/quirks.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 024ed4837408..f7d4251760c8 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -4299,6 +4299,16 @@ static const u16 pci_quirk_intel_pch_acs_ids[] = {
 	0x8c90, 0x8c92, 0x8c94, 0x8c96, 0x8c98, 0x8c9a, 0x8c9c, 0x8c9e,
 };
 
+/*
+ * Some of Marvell's PCIe ports do not support ACS capability
+ * but also do not enable peer-to-peer transactions so allow them
+ * to safely use the ACS quirk
+ */
+static const u16 pci_quirk_marvell_acs_ids[] = {
+	/* Marvell CP-110 south bridge */
+	0x0110,
+};
+
 static bool pci_quirk_intel_pch_acs_match(struct pci_dev *dev)
 {
 	int i;
@@ -4430,6 +4440,21 @@ static int pci_quirk_intel_spt_pch_acs(struct pci_dev *dev, u16 acs_flags)
 	return acs_flags & ~ctrl ? 0 : 1;
 }
 
+static int pci_quirk_marvell_acs(struct pci_dev *dev, u16 acs_flags)
+{
+	int i;
+
+	/* Filter out a few obvious non-matches first */
+	if (!pci_is_pcie(dev) || pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)
+		return false;
+
+	for (i = 0; i < ARRAY_SIZE(pci_quirk_marvell_acs_ids); i++)
+		if (pci_quirk_marvell_acs_ids[i] == dev->device)
+			return true;
+
+	return false;
+}
+
 static int pci_quirk_mf_endpoint_acs(struct pci_dev *dev, u16 acs_flags)
 {
 	/*
@@ -4525,6 +4550,8 @@ static const struct pci_dev_acs_enabled {
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_quirk_intel_spt_pch_acs },
 	{ 0x19a2, 0x710, pci_quirk_mf_endpoint_acs }, /* Emulex BE3-R */
 	{ 0x10df, 0x720, pci_quirk_mf_endpoint_acs }, /* Emulex Skyhawk-R */
+	/* Marvell PCIe root port */
+	{ PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, pci_quirk_marvell_acs },
 	/* Cavium ThunderX */
 	{ PCI_VENDOR_ID_CAVIUM, PCI_ANY_ID, pci_quirk_cavium_acs },
 	/* APM X-Gene */
-- 
2.17.1


From 3aeca217c4c8d34faf8ec302d5741aae2b9ea6db Mon Sep 17 00:00:00 2001
From: Lukasz Bartosik <lukasz.bartosik@cavium.com>
Date: Wed, 16 Jan 2019 10:30:08 +0100
Subject: [PATCH 0937/1051] crypto: cpt - change Kconfig and building of 8x/9x

There were a couple of issues with Kconfig and building of 8x/9x
CPT drivers therefore it was reorganized as follows:
1) both 8x and 9x CPT drivers can be built into a kernel
at the same time (previously only one could been built
into a kernel),
2) create Makefile for common code and build it separately
(previously it was being built from both 8x and 9x directories
and it caused dependency issues during parallel build).

Change-Id: Idaa7cb7f6504c54af1a1a50b583169764b758957
Signed-off-by: Lukasz Bartosik <lukasz.bartosik@cavium.com>
Reviewed-on: https://sj1git1.cavium.com/3021
Reviewed-by: Srujana Challa <schalla@cavium.com>
Tested-by: sa_ip-sw-jenkins
[Kevin: The original patch got from Marvell sdk10.0_19.06]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/Makefile                       |   3 +-
 drivers/crypto/cavium/cpt/8x/Makefile         |   7 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_algs.c     |  50 ++++
 drivers/crypto/cavium/cpt/8x/cpt8x_common.h   |   3 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_debug.c    |   3 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_pf.h       |   3 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c  |   7 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c  |   4 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c   |  63 ++---
 drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.h   |  11 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_ucode.c    |  27 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_vf.h       |   6 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c  |  17 +-
 drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c  |   2 +-
 drivers/crypto/cavium/cpt/9x/Makefile         |   6 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_algs.c     |  38 +++
 drivers/crypto/cavium/cpt/9x/cpt9x_debug.c    |   2 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_lf.h       |   2 +
 drivers/crypto/cavium/cpt/9x/cpt9x_lf_main.c  |  22 +-
 .../crypto/cavium/cpt/9x/cpt9x_mbox_common.h  |   3 +-
 .../crypto/cavium/cpt/9x/cpt9x_passthrough.c  |   7 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_pf.h       |   4 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c  |  52 +---
 drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c  |   4 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_quota.c    |  17 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_quota.h    |  16 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c   |  38 ++-
 drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.h   |   9 +-
 drivers/crypto/cavium/cpt/9x/cpt9x_ucode.c    |  52 +++-
 drivers/crypto/cavium/cpt/9x/cpt9x_vf.h       |   1 +
 drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c  |   2 +-
 drivers/crypto/cavium/cpt/Kconfig             |  42 +--
 drivers/crypto/cavium/cpt/Makefile            |   4 +
 drivers/crypto/cavium/cpt/common/Makefile     |   4 +
 drivers/crypto/cavium/cpt/common/cpt_algs.c   |  51 +++-
 drivers/crypto/cavium/cpt/common/cpt_algs.h   | 206 +-------------
 .../cavium/cpt/common/cpt_algs_internal.h     | 199 +++++++++++++
 drivers/crypto/cavium/cpt/common/cpt_common.h |   5 -
 drivers/crypto/cavium/cpt/common/cpt_debug.c  |   2 +
 drivers/crypto/cavium/cpt/common/cpt_reqmgr.c | 250 +++++++++++++++++
 drivers/crypto/cavium/cpt/common/cpt_reqmgr.h | 265 ++----------------
 drivers/crypto/cavium/cpt/common/cpt_ucode.c  |  96 +++++--
 drivers/crypto/cavium/cpt/common/cpt_ucode.h  |  23 +-
 43 files changed, 932 insertions(+), 696 deletions(-)
 create mode 100644 drivers/crypto/cavium/cpt/8x/cpt8x_algs.c
 create mode 100644 drivers/crypto/cavium/cpt/9x/cpt9x_algs.c
 create mode 100644 drivers/crypto/cavium/cpt/Makefile
 create mode 100644 drivers/crypto/cavium/cpt/common/Makefile
 create mode 100644 drivers/crypto/cavium/cpt/common/cpt_algs_internal.h

diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 0d8cd189c4a2..ab0ded183527 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -44,5 +44,4 @@ obj-$(CONFIG_CRYPTO_DEV_VMX) += vmx/
 obj-$(CONFIG_CRYPTO_DEV_BCM_SPU) += bcm/
 obj-$(CONFIG_CRYPTO_DEV_SAFEXCEL) += inside-secure/
 obj-$(CONFIG_CRYPTO_DEV_ARTPEC6) += axis/
-obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += cavium/cpt/8x/
-obj-$(CONFIG_CRYPTO_DEV_OCTEONTX2_CPT) += cavium/cpt/9x/
+obj-$(CONFIG_CRYPTO_DEV_CPT) += cavium/cpt/
diff --git a/drivers/crypto/cavium/cpt/8x/Makefile b/drivers/crypto/cavium/cpt/8x/Makefile
index c96ef0a896a7..bbef13d8cd08 100644
--- a/drivers/crypto/cavium/cpt/8x/Makefile
+++ b/drivers/crypto/cavium/cpt/8x/Makefile
@@ -1,12 +1,11 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += cptpf8x.o cptvf8x.o
 
-common-objs := cpt8x_debug.o ../common/cpt_debug.o
-cptpf8x-objs := cpt8x_pf_main.o cpt8x_pf_mbox.o cpt8x_pf_domain.o cpt8x_ucode.o ../common/cpt_ucode.o ${common-objs}
-cptvf8x-objs := cpt8x_vf_main.o cpt8x_vf_mbox.o cpt8x_reqmgr.o ../common/cpt_algs.o ../common/cpt_reqmgr.o
+cptpf8x-objs := cpt8x_pf_main.o cpt8x_pf_mbox.o cpt8x_ucode.o cpt8x_pf_domain.o cpt8x_debug.o
+cptvf8x-objs := cpt8x_vf_main.o cpt8x_vf_mbox.o cpt8x_reqmgr.o cpt8x_algs.o
 
 ifeq ($(CONFIG_CRYPTO_DEV_OCTEONTX_CPT), m)
-	cptvf8x-objs += ${common-objs}
+	cptvf8x-objs += cpt8x_debug.o
 endif
 
 ccflags-y := -I$(src)/../common/
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_algs.c b/drivers/crypto/cavium/cpt/8x/cpt8x_algs.c
new file mode 100644
index 000000000000..c9cc8e76b1ed
--- /dev/null
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_algs.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "cpt8x_vf.h"
+#include "cpt_algs.h"
+
+static int cpt8x_do_request(struct pci_dev *pdev, struct cpt_request_info *req,
+			    int cpu_num)
+{
+	struct cpt_vf *cptvf = pci_get_drvdata(pdev);
+
+	if (!cpt_device_ready(cptvf)) {
+		dev_err(&pdev->dev, "CPT Device is not ready");
+		return -ENODEV;
+	}
+
+	if ((cptvf->vftype == SE_TYPES) && (!req->ctrl.s.se_req)) {
+		dev_err(&pdev->dev, "CPTVF-%d of SE TYPE got AE request",
+			cptvf->vfid);
+		return -EINVAL;
+	} else if ((cptvf->vftype == AE_TYPES) && (req->ctrl.s.se_req)) {
+		dev_err(&pdev->dev, "CPTVF-%d of AE TYPE got SE request",
+			cptvf->vfid);
+		return -EINVAL;
+	}
+
+	return process_request(pdev, &cptvf->ops, req,
+			       &cptvf->pqinfo.queue[0], cptvf);
+}
+
+static int cpt8x_get_kcrypto_eng_grp_num(struct pci_dev *pdev)
+{
+	return 0;
+}
+
+struct algs_ops cpt8x_get_algs_ops(void)
+{
+	struct algs_ops ops;
+
+	ops.cpt_do_request = cpt8x_do_request;
+	ops.cpt_get_kcrypto_eng_grp_num = cpt8x_get_kcrypto_eng_grp_num;
+
+	return ops;
+}
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_common.h b/drivers/crypto/cavium/cpt/8x/cpt8x_common.h
index cc0da4b1648f..e09459333e86 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_common.h
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_common.h
@@ -48,6 +48,7 @@ struct cpt_mbox {
 	u64 data;/* Data         MBOX[1] */
 };
 
-void dump_mbox_msg(struct device *dev, struct cpt_mbox *mbox_msg, int vf_id);
+void cpt8x_dump_mbox_msg(struct device *dev, struct cpt_mbox *mbox_msg,
+			 int vf_id);
 
 #endif /* __CPT8X_COMMON_H */
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c b/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c
index 9aa66befdf51..edf0f02b36fd 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_debug.c
@@ -58,7 +58,8 @@ static char *get_opcode_str(int msg_opcode)
 	return str;
 }
 
-void dump_mbox_msg(struct device *dev, struct cpt_mbox *mbox_msg, int vf_id)
+void cpt8x_dump_mbox_msg(struct device *dev, struct cpt_mbox *mbox_msg,
+			 int vf_id)
 {
 	char raw_data_str[MAX_RAW_DATA_STR_SIZE];
 	char *opcode_str;
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h b/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h
index cd1ed765b11d..41b3508d3b9b 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf.h
@@ -38,6 +38,7 @@ struct cpt_device {
 };
 
 void cpt_mbox_intr_handler(struct cpt_device *cpt, int mbx);
-void cpt_disable_all_cores(struct cpt_device *cpt);
+void cpt8x_disable_all_cores(struct cpt_device *cpt);
+struct ucode_ops cpt8x_get_ucode_ops(void);
 
 #endif /* __CPT8X_PF_H */
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c
index 2a3ca7bc9da2..9d3d03f3e06e 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_main.c
@@ -113,7 +113,7 @@ static int cpt_device_init(struct cpt_device *cpt)
 
 	/*TODO: Get CLK frequency*/
 	/*Disable all cores*/
-	cpt_disable_all_cores(cpt);
+	cpt8x_disable_all_cores(cpt);
 	/* PF is ready */
 	cpt->flags |= CPT_FLAG_DEVICE_READY;
 
@@ -279,7 +279,8 @@ static int cpt_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto cpt_err_release_regions;
 
 	/* Initialize engine groups */
-	err = cpt_init_eng_grps(pdev, &cpt->eng_grps, cpt->pf_type);
+	err = cpt_init_eng_grps(pdev, &cpt->eng_grps, cpt8x_get_ucode_ops(),
+				cpt->pf_type);
 	if (err)
 		goto cpt_err_unregister_interrupts;
 
@@ -324,7 +325,7 @@ static void cpt_remove(struct pci_dev *pdev)
 	/* Disable CPT PF interrupts */
 	cpt_unregister_interrupts(cpt);
 	/* Disengage SE and AE cores from all groups*/
-	cpt_disable_all_cores(cpt);
+	cpt8x_disable_all_cores(cpt);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c
index 421ab6c9e7a2..ffea13f9e527 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_pf_mbox.c
@@ -126,11 +126,10 @@ static void cpt_handle_mbox_intr(struct cpt_device *cpt, int vf)
 	mbx.data = readq(cpt->reg_base + CPT_PF_VFX_MBOXX(vf, 1));
 
 	if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-		dump_mbox_msg(&cpt->pdev->dev, &mbx, vf);
+		cpt8x_dump_mbox_msg(&cpt->pdev->dev, &mbx, vf);
 
 	switch (mbx.msg) {
 	case CPT_MSG_VF_UP:
-		try_module_get(THIS_MODULE);
 		mbx.msg  = CPT_MSG_VF_UP;
 		mbx.data = cpt->vfs_enabled;
 		cpt_send_msg_to_vf(cpt, vf, &mbx);
@@ -142,7 +141,6 @@ static void cpt_handle_mbox_intr(struct cpt_device *cpt, int vf)
 		break;
 	case CPT_MSG_VF_DOWN:
 		/* First msg in VF teardown sequence */
-		module_put(THIS_MODULE);
 		cpt_mbox_send_ack(cpt, vf, &mbx);
 		break;
 	case CPT_MSG_QLEN:
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c b/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c
index bdee26fedc7c..f3a2970c83b2 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.c
@@ -8,13 +8,12 @@
  * published by the Free Software Foundation.
  */
 
-#include "cpt_reqmgr.h"
 #include "cpt8x_vf.h"
-#include "cpt8x_reqmgr.h"
+#include "cpt_algs.h"
 
-inline void fill_cpt_inst(union cpt_inst_s *cptinst,
-			  struct cpt_info_buffer *info,
-			  struct cpt_iq_command *iq_cmd)
+static void cpt8x_fill_inst(union cpt_inst_s *cptinst,
+			    struct cpt_info_buffer *info,
+			    struct cpt_iq_command *iq_cmd)
 {
 	cptinst->u[0] = 0x0;
 	cptinst->s8x.doneint = true;
@@ -27,9 +26,10 @@ inline void fill_cpt_inst(union cpt_inst_s *cptinst,
 	cptinst->s8x.ei3 = iq_cmd->cptr.u64;
 }
 
-inline int process_ccode(struct pci_dev *pdev, union cpt_res_s *cpt_status,
-			 struct cpt_info_buffer *cpt_info,
-			 struct cpt_request_info *req, u32 *res_code)
+static int cpt8x_process_ccode(struct pci_dev *pdev,
+			       union cpt_res_s *cpt_status,
+			       struct cpt_info_buffer *cpt_info,
+			       struct cpt_request_info *req, u32 *res_code)
 {
 	u8 ccode = cpt_status->s8x.compcode;
 	union error_code ecode;
@@ -98,7 +98,7 @@ inline int process_ccode(struct pci_dev *pdev, union cpt_res_s *cpt_status,
  * 0 - 1 CPT instruction will be enqueued however CPT will not be informed
  * 1 - 1 CPT instruction will be enqueued and CPT will be informed
  */
-inline void send_cpt_cmd(union cpt_inst_s *cptinst, u32 db_count, void *obj)
+static void cpt8x_send_cmd(union cpt_inst_s *cptinst, u32 db_count, void *obj)
 {
 	struct cpt_vf *cptvf = (struct cpt_vf *) obj;
 	struct command_qinfo *qinfo = &cptvf->cqinfo;
@@ -126,53 +126,36 @@ inline void send_cpt_cmd(union cpt_inst_s *cptinst, u32 db_count, void *obj)
 	spin_unlock(&queue->lock);
 }
 
-inline void send_cpt_cmds_in_batch(union cpt_inst_s *cptinst, u32 num,
-				   void *obj)
+void cpt8x_send_cmds_in_batch(union cpt_inst_s *cptinst, u32 num, void *obj)
 {
 	struct cpt_vf *cptvf = (struct cpt_vf *) obj;
 	int i;
 
 	for (i = 0; i < num; i++)
-		send_cpt_cmd(&cptinst[i], 0, obj);
+		cpt8x_send_cmd(&cptinst[i], 0, obj);
 
 	cptvf_write_vq_doorbell(cptvf, num);
 }
 
-inline void send_cpt_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
-					 void *obj)
+void cpt8x_send_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
+				    void *obj)
 {
-	send_cpt_cmds_in_batch(cptinst, num, obj);
+	cpt8x_send_cmds_in_batch(cptinst, num, obj);
 }
 
-inline int cpt_get_kcrypto_eng_grp_num(struct pci_dev *pdev)
+void cpt8x_post_process(struct cptvf_wqe *wqe)
 {
-	return 0;
-}
-
-inline void cptvf_post_process(struct cptvf_wqe *wqe)
-{
-	process_pending_queue(wqe->cptvf->pdev, &wqe->cptvf->pqinfo.queue[0]);
+	process_pending_queue(wqe->cptvf->pdev, &wqe->cptvf->ops,
+			      &wqe->cptvf->pqinfo.queue[0]);
 }
 
-inline int cpt_do_request(struct pci_dev *pdev, struct cpt_request_info *req,
-		   int cpu_num)
+struct reqmgr_ops cpt8x_get_reqmgr_ops(void)
 {
-	struct cpt_vf *cptvf = pci_get_drvdata(pdev);
+	struct reqmgr_ops ops;
 
-	if (!cpt_device_ready(cptvf)) {
-		dev_err(&pdev->dev, "CPT Device is not ready");
-		return -ENODEV;
-	}
-
-	if ((cptvf->vftype == SE_TYPES) && (!req->ctrl.s.se_req)) {
-		dev_err(&pdev->dev, "CPTVF-%d of SE TYPE got AE request",
-			cptvf->vfid);
-		return -EINVAL;
-	} else if ((cptvf->vftype == AE_TYPES) && (req->ctrl.s.se_req)) {
-		dev_err(&pdev->dev, "CPTVF-%d of AE TYPE got SE request",
-			cptvf->vfid);
-		return -EINVAL;
-	}
+	ops.fill_inst = cpt8x_fill_inst;
+	ops.process_ccode = cpt8x_process_ccode;
+	ops.send_cmd = cpt8x_send_cmd;
 
-	return process_request(pdev, req, &cptvf->pqinfo.queue[0], cptvf);
+	return ops;
 }
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.h b/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.h
index eae063318575..3ad30e6b041d 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.h
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_reqmgr.h
@@ -1,6 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 RVU Admin Function driver
- *
+/*
  * Copyright (C) 2018 Marvell International Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -11,8 +10,10 @@
 #ifndef __CPT8X_REQUEST_MANAGER_H
 #define __CPT8X_REQUEST_MANAGER_H
 
-#include "cpt_common.h"
-
-void vq_post_process(struct cpt_vf *cptvf, u32 qno);
+void cpt8x_post_process(struct cptvf_wqe *wqe);
+struct reqmgr_ops cpt8x_get_reqmgr_ops(void);
+void cpt8x_send_cmds_in_batch(union cpt_inst_s *cptinst, u32 num, void *obj);
+void cpt8x_send_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
+				    void *obj);
 
 #endif /* __CPT8X_REQUEST_MANAGER_H */
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_ucode.c b/drivers/crypto/cavium/cpt/8x/cpt8x_ucode.c
index 4d2ce34cee1a..b2d529e3ccfd 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_ucode.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_ucode.c
@@ -39,7 +39,8 @@ static struct bitmap get_cores_bmap(struct device *dev,
 	return bmap;
 }
 
-int cpt_detach_and_disable_cores(struct engine_group_info *eng_grp, void *obj)
+static int cpt8x_detach_and_disable_cores(struct engine_group_info *eng_grp,
+					  void *obj)
 {
 	struct cpt_device *cpt = (struct cpt_device *) obj;
 	struct bitmap bmap = { 0 };
@@ -86,7 +87,7 @@ int cpt_detach_and_disable_cores(struct engine_group_info *eng_grp, void *obj)
 	return 0;
 }
 
-int cpt_set_ucode_base(struct engine_group_info *eng_grp, void *obj)
+static int cpt8x_set_ucode_base(struct engine_group_info *eng_grp, void *obj)
 {
 	struct cpt_device *cpt = (struct cpt_device *) obj;
 	dma_addr_t dma_addr;
@@ -113,7 +114,8 @@ int cpt_set_ucode_base(struct engine_group_info *eng_grp, void *obj)
 	return 0;
 }
 
-int cpt_attach_and_enable_cores(struct engine_group_info *eng_grp, void *obj)
+static int cpt8x_attach_and_enable_cores(struct engine_group_info *eng_grp,
+					 void *obj)
 {
 	struct cpt_device *cpt = (struct cpt_device *) obj;
 	struct bitmap bmap;
@@ -143,8 +145,8 @@ int cpt_attach_and_enable_cores(struct engine_group_info *eng_grp, void *obj)
 	return 0;
 }
 
-void cpt_print_engines_mask(struct engine_group_info *eng_grp, void *obj,
-			    char *buf, int size)
+static void cpt8x_print_engines_mask(struct engine_group_info *eng_grp,
+				     void *obj, char *buf, int size)
 {
 	struct cpt_device *cpt = (struct cpt_device *) obj;
 	struct bitmap bmap;
@@ -163,7 +165,7 @@ void cpt_print_engines_mask(struct engine_group_info *eng_grp, void *obj,
 	scnprintf(buf, size, "%8.8x %8.8x", mask[1], mask[0]);
 }
 
-void cpt_disable_all_cores(struct cpt_device *cpt)
+void cpt8x_disable_all_cores(struct cpt_device *cpt)
 {
 	u64 reg;
 	int grp, timeout = 100;
@@ -187,3 +189,16 @@ void cpt_disable_all_cores(struct cpt_device *cpt)
 	/* Disable the cores */
 	writeq(0, cpt->reg_base + CPT_PF_EXE_CTL);
 }
+
+struct ucode_ops cpt8x_get_ucode_ops(void)
+{
+	struct ucode_ops ops;
+
+	ops.detach_and_disable_cores = cpt8x_detach_and_disable_cores;
+	ops.attach_and_enable_cores = cpt8x_attach_and_enable_cores;
+	ops.set_ucode_base = cpt8x_set_ucode_base;
+	ops.print_engines_mask = cpt8x_print_engines_mask;
+	ops.notify_group_change = NULL;
+
+	return ops;
+}
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_vf.h b/drivers/crypto/cavium/cpt/8x/cpt8x_vf.h
index 794b8252ee8f..0f32e793b8a3 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_vf.h
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_vf.h
@@ -14,6 +14,7 @@
 #include <linux/list.h>
 #include <linux/interrupt.h>
 #include "cpt_common.h"
+#include "cpt_reqmgr.h"
 #include "cpt_hw_types.h"
 #include "cpt8x_common.h"
 
@@ -76,7 +77,8 @@ struct cpt_vf {
 	u8 priority; /* VF priority ring: 1-High proirity round
 		      * robin ring;0-Low priority round robin ring;
 		      */
-	struct pci_dev *pdev; /* pci device handle */
+	struct pci_dev *pdev; /* Pci device handle */
+	struct reqmgr_ops ops; /* Request manager operations */
 	void __iomem *reg_base; /* Register start address */
 	void *wqe_info;	/* BH worker info */
 	/* MSI-X */
@@ -98,7 +100,7 @@ int cptvf_send_vf_priority_msg(struct cpt_vf *cptvf);
 int cptvf_send_vq_size_msg(struct cpt_vf *cptvf);
 int cptvf_check_pf_ready(struct cpt_vf *cptvf);
 void cptvf_handle_mbox_intr(struct cpt_vf *cptvf);
-void cptvf_post_process(struct cptvf_wqe *wqe);
 void cptvf_write_vq_doorbell(struct cpt_vf *cptvf, u32 val);
+struct algs_ops cpt8x_get_algs_ops(void);
 
 #endif /* __CPT8X_VF_H */
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c
index 9e16c18d6fae..2b85adaf9e4e 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_main.c
@@ -11,6 +11,8 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include "cpt8x_vf.h"
+#include "cpt_algs.h"
+#include "cpt8x_reqmgr.h"
 
 #define DRV_NAME	"octeontx-cptvf"
 #define DRV_VERSION	"1.0"
@@ -21,7 +23,7 @@ static void vq_work_handler(unsigned long data)
 {
 	struct cptvf_wqe_info *cwqe_info = (struct cptvf_wqe_info *) data;
 
-	cptvf_post_process(&cwqe_info->vq_wqe[0]);
+	cpt8x_post_process(&cwqe_info->vq_wqe[0]);
 }
 
 static int init_worker_threads(struct cpt_vf *cptvf)
@@ -916,7 +918,12 @@ static int cptvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto cptvf_free_irq_affinity;
 	}
 
-	err = cvm_crypto_init(pdev, cptvf->vftype == SE_TYPES ? CPT_SE_83XX :
+	/* Set request manager ops */
+	cptvf->ops = cpt8x_get_reqmgr_ops();
+
+	/* Initialize algorithms and set ops */
+	err = cvm_crypto_init(pdev, THIS_MODULE, cpt8x_get_algs_ops(),
+			      cptvf->vftype == SE_TYPES ? CPT_SE_83XX :
 			      CPT_AE_83XX, cptvf->vftype, 1, cptvf->num_vfs);
 	if (err) {
 		dev_err(dev, "Algorithm register failed\n");
@@ -926,11 +933,13 @@ static int cptvf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	err = sysfs_create_group(&dev->kobj, &vf_sysfs_group);
 	if (err) {
 		dev_err(dev, "Creating sysfs entries failed\n");
-		goto cptvf_free_irq_affinity;
+		goto cptvf_crypto_exit;
 	}
 
 	return 0;
 
+cptvf_crypto_exit:
+	cvm_crypto_exit(pdev, THIS_MODULE);
 cptvf_free_irq_affinity:
 	cptvf_free_irq_affinity(cptvf, CPT_8X_VF_INT_VEC_E_DONE);
 	cptvf_free_irq_affinity(cptvf, CPT_8X_VF_INT_VEC_E_MISC);
@@ -962,7 +971,7 @@ static void cptvf_remove(struct pci_dev *pdev)
 	if (cptvf_send_vf_down(cptvf)) {
 		dev_err(&pdev->dev, "PF not responding to DOWN msg");
 	} else {
-		cvm_crypto_exit(pdev);
+		cvm_crypto_exit(pdev, THIS_MODULE);
 		cptvf_free_irq_affinity(cptvf, CPT_8X_VF_INT_VEC_E_DONE);
 		cptvf_free_irq_affinity(cptvf, CPT_8X_VF_INT_VEC_E_MISC);
 		free_irq(pci_irq_vector(pdev, CPT_8X_VF_INT_VEC_E_DONE), cptvf);
diff --git a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c
index e77b5e2410eb..4daa853997d2 100644
--- a/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c
+++ b/drivers/crypto/cavium/cpt/8x/cpt8x_vf_mbox.c
@@ -48,7 +48,7 @@ void cptvf_handle_mbox_intr(struct cpt_vf *cptvf)
 	mbx.data = readq(cptvf->reg_base + CPT_VFX_PF_MBOXX(0, 1));
 
 	if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-		dump_mbox_msg(&cptvf->pdev->dev, &mbx, -1);
+		cpt8x_dump_mbox_msg(&cptvf->pdev->dev, &mbx, -1);
 
 	switch (mbx.msg) {
 	case CPT_MSG_VF_UP:
diff --git a/drivers/crypto/cavium/cpt/9x/Makefile b/drivers/crypto/cavium/cpt/9x/Makefile
index 6e8f9f70d0fb..720725735e4e 100644
--- a/drivers/crypto/cavium/cpt/9x/Makefile
+++ b/drivers/crypto/cavium/cpt/9x/Makefile
@@ -1,9 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_CRYPTO_DEV_OCTEONTX2_CPT) += cptpf9x.o cptvf9x.o
 
-common-objs := cpt9x_mbox_common.o cpt9x_debug.o ../common/cpt_debug.o
-cptpf9x-objs := cpt9x_pf_main.o  cpt9x_pf_mbox.o cpt9x_ucode.o cpt9x_quota.o ../common/cpt_ucode.o ${common-objs}
-cptvf9x-objs := cpt9x_vf_main.o cpt9x_lf_main.o cpt9x_reqmgr.o cpt9x_vf_mbox.o cpt9x_passthrough.o ../common/cpt_algs.o ../common/cpt_reqmgr.o
+common-objs := cpt9x_mbox_common.o cpt9x_debug.o
+cptpf9x-objs := cpt9x_pf_main.o  cpt9x_pf_mbox.o cpt9x_ucode.o cpt9x_quota.o ${common-objs}
+cptvf9x-objs := cpt9x_vf_main.o cpt9x_vf_mbox.o cpt9x_lf_main.o cpt9x_reqmgr.o cpt9x_algs.o cpt9x_passthrough.o
 
 ifeq ($(CONFIG_CRYPTO_DEV_OCTEONTX2_CPT), m)
 	cptvf9x-objs += ${common-objs}
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_algs.c b/drivers/crypto/cavium/cpt/9x/cpt9x_algs.c
new file mode 100644
index 000000000000..046c4ac1488d
--- /dev/null
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_algs.c
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "cpt9x_mbox_common.h"
+#include "cpt_reqmgr.h"
+#include "cpt_algs.h"
+
+static int cpt9x_get_kcrypto_eng_grp_num(struct pci_dev *pdev)
+{
+	struct cptlfs_info *lfs = get_lfs_info(pdev);
+
+	return lfs->kcrypto_eng_grp_num;
+}
+
+int cpt9x_do_request(struct pci_dev *pdev, struct cpt_request_info *req,
+		     int cpu_num)
+{
+	struct cptlfs_info *lfs = get_lfs_info(pdev);
+
+	return process_request(pdev, &lfs->ops, req, &lfs->lf[cpu_num].pqueue,
+			       &lfs->lf[cpu_num]);
+}
+
+struct algs_ops cpt9x_get_algs_ops(void)
+{
+	struct algs_ops ops;
+
+	ops.cpt_do_request = cpt9x_do_request;
+	ops.cpt_get_kcrypto_eng_grp_num = cpt9x_get_kcrypto_eng_grp_num;
+
+	return ops;
+}
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c b/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
index 2ce40eea44d4..c88a9c43a91a 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_debug.c
@@ -51,7 +51,7 @@ static char *get_opcode_str(int msg_opcode)
 	return str;
 }
 
-void dump_mbox_msg(struct device *dev, struct mbox_msghdr *msg, int size)
+void cpt9x_dump_mbox_msg(struct device *dev, struct mbox_msghdr *msg, int size)
 {
 	char *opcode_str;
 	u16 pf_id, vf_id;
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_lf.h b/drivers/crypto/cavium/cpt/9x/cpt9x_lf.h
index da45a6eb3fad..0c597bf18c7d 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_lf.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_lf.h
@@ -13,6 +13,7 @@
 
 #include "cpt_hw_types.h"
 #include "cpt9x_common.h"
+#include "cpt_reqmgr.h"
 
 /*
  * CPT instruction and pending queues user requested length in CPT_INST_S msgs
@@ -99,6 +100,7 @@ struct cptlfs_info {
 	void __iomem *reg_base;
 	struct pci_dev *pdev;   /* Device LFs are attached to */
 	struct cptlf_info lf[CPT_9X_MAX_LFS_NUM];
+	struct reqmgr_ops ops;	/* Request manager operations */
 	u8 kcrypto_eng_grp_num;	/* Kernel crypto engine group number */
 	u8 are_lfs_attached;	/* Whether CPT LFs are attached */
 	u8 lfs_num;		/* Number of CPT LFs */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_lf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_lf_main.c
index c534a618cf0f..44c9a29407fa 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_lf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_lf_main.c
@@ -9,6 +9,7 @@
  */
 
 #include "cpt_reqmgr.h"
+#include "cpt_algs.h"
 #include "cpt9x_mbox_common.h"
 #include "cpt9x_common.h"
 #include "cpt9x_reqmgr.h"
@@ -545,7 +546,7 @@ static void cptlf_free_irqs_affinity(struct cptlfs_info *lfs)
 
 static void cptlf_work_handler(unsigned long data)
 {
-	cpt_post_process((struct cptlf_wqe *) data);
+	cpt9x_post_process((struct cptlf_wqe *) data);
 }
 
 static int init_tasklet_work(struct cptlfs_info *lfs)
@@ -708,19 +709,18 @@ static void cptlf_sw_cleanup(struct cptlfs_info *lfs)
 	free_instruction_queues(lfs);
 }
 
-inline void send_cpt_cmds_in_batch(union cpt_inst_s *cptinst, u32 num,
-				   void *obj)
+void cpt9x_send_cmds_in_batch(union cpt_inst_s *cptinst, u32 num, void *obj)
 {
 	int i;
 
 	for (i = 0; i < (num & 0xFFFFFFFE); i += 2)
-		send_cpt_cmd(&cptinst[i], 2, obj);
+		cpt9x_send_cmd(&cptinst[i], 2, obj);
 	if (num & 0x1)
-		send_cpt_cmd(&cptinst[num-1], 1, obj);
+		cpt9x_send_cmd(&cptinst[num-1], 1, obj);
 }
 
-inline void send_cpt_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
-					 void *obj)
+void cpt9x_send_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
+				    void *obj)
 {
 	struct cptlf_info *lf = (struct cptlf_info *) obj;
 
@@ -731,7 +731,7 @@ inline void send_cpt_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
 	cptlf_do_set_iqueue_size(lf);
 	cptlf_enable_iqueue_enq(lf);
 
-	send_cpt_cmds_in_batch(cptinst, num, obj);
+	cpt9x_send_cmds_in_batch(cptinst, num, obj);
 
 	cptlf_enable_iqueue_exec(lf);
 }
@@ -1033,6 +1033,7 @@ int cptlf_init(struct pci_dev *pdev, void *reg_base,
 	lfs->reg_base = reg_base;
 	lfs->lfs_num = lfs_num;
 	lfs->pdev = pdev;
+	lfs->ops = cpt9x_get_reqmgr_ops();
 	for (slot = 0; slot < lfs->lfs_num; slot++) {
 		lfs->lf[slot].lfs = lfs;
 		lfs->lf[slot].slot = slot;
@@ -1088,7 +1089,8 @@ int cptlf_init(struct pci_dev *pdev, void *reg_base,
 	cptlf_enable_done_intr(lfs);
 
 	/* Register crypto algorithms */
-	ret = cvm_crypto_init(pdev, CPT_96XX, SE_TYPES, lfs_num, 1);
+	ret = cvm_crypto_init(pdev, THIS_MODULE, cpt9x_get_algs_ops(),
+			      CPT_96XX, SE_TYPES, lfs_num, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "algorithms registration failed\n");
 		goto cpt_err_disable_irqs;
@@ -1116,7 +1118,7 @@ int cptlf_shutdown(struct pci_dev *pdev, struct cptlfs_info *lfs)
 	int ret = 0;
 
 	/* Unregister crypto algorithms */
-	cvm_crypto_exit(pdev);
+	cvm_crypto_exit(pdev, THIS_MODULE);
 
 	/* Disable interrupts */
 	cptlf_disable_done_intr(lfs);
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
index 73418130b3ef..a198b6f594b3 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_mbox_common.h
@@ -61,6 +61,7 @@ int cpt_read_af_reg(struct pci_dev *pdev, u64 reg, u64 *val);
 int cpt_write_af_reg(struct pci_dev *pdev, u64 reg, u64 val);
 
 int cpt_send_mbox_msg(struct pci_dev *pdev);
-void dump_mbox_msg(struct device *dev, struct mbox_msghdr *msg, int size);
+void cpt9x_dump_mbox_msg(struct device *dev, struct mbox_msghdr *msg,
+			 int size);
 
 #endif /* __CPT9X_MBOX_COMMON_H */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_passthrough.c b/drivers/crypto/cavium/cpt/9x/cpt9x_passthrough.c
index 8ed97195bcbf..c430bd3e4d06 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_passthrough.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_passthrough.c
@@ -11,9 +11,12 @@
 #include <linux/crypto.h>
 #include <crypto/algapi.h>
 #include <crypto/hash.h>
-#include "cpt_common.h"
+#include "cpt9x_mbox_common.h"
+
 #include "cpt_algs.h"
+#include "cpt_algs_internal.h"
 #include "cpt9x_passthrough.h"
+#include "cpt9x_reqmgr.h"
 
 static void passthrough_callback(struct crypto_async_request *req, int err)
 {
@@ -73,7 +76,7 @@ static int cvm_passthrough(struct pci_dev *pdev, struct ablkcipher_request *req)
 	cpu = get_cpu();
 	put_cpu();
 
-	return cpt_do_request(pdev, req_info, cpu);
+	return cpt9x_do_request(pdev, req_info, cpu);
 }
 
 int run_passthrough_test(struct pci_dev *pdev, const char *buf, int size)
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h b/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h
index f59e17f57846..8a8232e07759 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf.h
@@ -61,7 +61,9 @@ irqreturn_t cptpf_afpf_mbox_intr(int irq, void *arg);
 irqreturn_t cptpf_vfpf_mbox_intr(int irq, void *arg);
 void cptpf_afpf_mbox_handler(struct work_struct *work);
 void cptpf_vfpf_mbox_handler(struct work_struct *work);
-int cpt_disable_all_cores(struct cptpf_dev *cptpf);
 int cptpf_send_crypto_eng_grp_msg(struct cptpf_dev *cptpf,
 				  int crypto_eng_grp);
+int cpt9x_disable_all_cores(struct cptpf_dev *cptpf);
+struct ucode_ops cpt9x_get_ucode_ops(void);
+
 #endif /* __CPT9X_PF_H */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
index c9492e9050b7..664468a5dbf2 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_main.c
@@ -326,7 +326,7 @@ static int cptpf_device_init(struct cptpf_dev *cptpf)
 	cptpf->eng_grps.avail.max_ae_cnt = af_cnsts1.s.ae;
 
 	/* Disable all cores */
-	ret = cpt_disable_all_cores(cptpf);
+	ret = cpt9x_disable_all_cores(cptpf);
 	if (ret)
 		goto error;
 error:
@@ -338,7 +338,7 @@ static void cpt_destroy_sysfs_vf_limits(struct cptpf_dev *cptpf)
 	struct cptvf_info *vf_info;
 	int i;
 
-	quotas_free(cptpf->vf_limits.cpt);
+	cpt_quotas_free(cptpf->vf_limits.cpt);
 	cptpf->vf_limits.cpt = NULL;
 
 	for (i = 0; i < cptpf->enabled_vfs; i++) {
@@ -361,10 +361,10 @@ static int cpt_alloc_vf_limits(struct cptpf_dev *cptpf)
 	mutex_init(&cptpf->vf_limits.lock);
 
 	/* Create limit structures for CPT resource types */
-	cptpf->vf_limits.cpt = quotas_alloc(cptpf->enabled_vfs,
-					    cptpf->limits.cpt,
-					    cptpf->limits.cpt, 0,
-					    &cptpf->vf_limits.lock, NULL);
+	cptpf->vf_limits.cpt = cpt_quotas_alloc(cptpf->enabled_vfs,
+						cptpf->limits.cpt,
+						cptpf->limits.cpt, 0,
+						&cptpf->vf_limits.lock, NULL);
 	if (cptpf->vf_limits.cpt == NULL) {
 		dev_err(&cptpf->pdev->dev,
 			"Failed to allocate cpt limits structures");
@@ -398,7 +398,7 @@ static int cpt_alloc_vf_limits(struct cptpf_dev *cptpf)
 		cptpf->vf_limits.cpt->a[i].val = lfs_per_vf;
 	return 0;
 error:
-	quotas_free(cptpf->vf_limits.cpt);
+	cpt_quotas_free(cptpf->vf_limits.cpt);
 	return ret;
 }
 
@@ -423,9 +423,9 @@ static int cpt_create_sysfs_vf_limits(struct cptpf_dev *cptpf)
 			goto error;
 		}
 
-		if (quota_sysfs_create("cpt", vf_info->limits_kobj, &pdev->dev,
-				       &cptpf->vf_limits.cpt->a[i],
-				       NULL) != 0) {
+		if (cpt_quota_sysfs_create("cpt", vf_info->limits_kobj,
+				&pdev->dev, &cptpf->vf_limits.cpt->a[i],
+				NULL) != 0) {
 			dev_err(&cptpf->pdev->dev,
 				"Failed to create cpt limits sysfs for %s.",
 				pci_name(pdev));
@@ -487,31 +487,6 @@ static int cptpf_sriov_configure(struct pci_dev *pdev, int numvfs)
 	return ret;
 }
 
-static void cptpf_eng_grp_hndlr(void *obj)
-{
-	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
-	struct engine_group_info *grp;
-	int crypto_eng_grp = INVALID_CRYPTO_ENG_GRP;
-	int i;
-
-	for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
-		grp = &cptpf->eng_grps.grp[i];
-		if (!grp->is_enabled)
-			continue;
-
-		if (cpt_eng_grp_has_eng_type(grp, SE_TYPES) &&
-		    !cpt_eng_grp_has_eng_type(grp, IE_TYPES) &&
-		    !cpt_eng_grp_has_eng_type(grp, AE_TYPES)) {
-			crypto_eng_grp = i;
-			break;
-		}
-	}
-
-	if (cptpf->crypto_eng_grp == crypto_eng_grp)
-		return;
-	cptpf_send_crypto_eng_grp_msg(cptpf, crypto_eng_grp);
-}
-
 static int cptpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct device *dev = &pdev->dev;
@@ -631,14 +606,11 @@ static int cptpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto cpt_err_unregister_interrupts;
 
 	/* Initialize engine groups */
-	err = cpt_init_eng_grps(pdev, &cptpf->eng_grps, CPT_96XX);
+	err = cpt_init_eng_grps(pdev, &cptpf->eng_grps, cpt9x_get_ucode_ops(),
+				CPT_96XX);
 	if (err)
 		goto cpt_err_unregister_interrupts;
 
-
-	/* Set engine group create/delete handler */
-	cpt_set_eng_grps_plat_hndlr(&cptpf->eng_grps,
-				    cptpf_eng_grp_hndlr);
 	return 0;
 
 cpt_err_unregister_interrupts:
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
index 2f824dd2591e..17a6a5620f08 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_pf_mbox.c
@@ -358,8 +358,8 @@ void cptpf_afpf_mbox_handler(struct work_struct *work)
 			fwd->rc = msg->rc;
 		} else {
 			if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-				dump_mbox_msg(&cptpf->pdev->dev, msg, size);
-
+				cpt9x_dump_mbox_msg(&cptpf->pdev->dev, msg,
+						    size);
 			switch (msg->id) {
 			case MBOX_MSG_READY:
 				cptpf->pf_id =
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_quota.c b/drivers/crypto/cavium/cpt/9x/cpt9x_quota.c
index 42ae3a8a9c59..923ae3490d52 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_quota.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_quota.c
@@ -103,9 +103,8 @@ static ssize_t quota_store(struct kobject *kobj, struct kobj_attribute *attr,
 	return res;
 }
 
-struct quotas *quotas_alloc(u32 cnt, u32 max, u64 max_sum,
-			    int init_val, struct mutex *lock,
-			    struct quota_ops *ops)
+struct quotas *cpt_quotas_alloc(u32 cnt, u32 max, u64 max_sum, int init_val,
+				struct mutex *lock, struct quota_ops *ops)
 {
 	struct quotas *quotas;
 	u64 i;
@@ -135,7 +134,7 @@ struct quotas *quotas_alloc(u32 cnt, u32 max, u64 max_sum,
 	return quotas;
 }
 
-void quotas_free(struct quotas *quotas)
+void cpt_quotas_free(struct quotas *quotas)
 {
 	u64 i;
 
@@ -144,14 +143,14 @@ void quotas_free(struct quotas *quotas)
 	WARN_ON(quotas->cnt == 0);
 
 	for (i = 0; i < quotas->cnt; i++)
-		quota_sysfs_destroy(&quotas->a[i]);
+		cpt_quota_sysfs_destroy(&quotas->a[i]);
 
 	kfree(quotas);
 }
 
-int quota_sysfs_create(const char *name, struct kobject *parent,
-		       struct device *log_dev, struct quota *quota,
-		       void *ops_arg)
+int cpt_quota_sysfs_create(const char *name, struct kobject *parent,
+			   struct device *log_dev, struct quota *quota,
+			   void *ops_arg)
 {
 	int err;
 
@@ -178,7 +177,7 @@ int quota_sysfs_create(const char *name, struct kobject *parent,
 	return 0;
 }
 
-int quota_sysfs_destroy(struct quota *quota)
+int cpt_quota_sysfs_destroy(struct quota *quota)
 {
 	if (quota == NULL)
 		return -EINVAL;
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_quota.h b/drivers/crypto/cavium/cpt/9x/cpt9x_quota.h
index fddb56392c03..0e7d74da756e 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_quota.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_quota.h
@@ -58,13 +58,13 @@ struct quotas {
  * @p init_val initial value set to all quotas
  * @p ops callbacks for sysfs manipulation notifications
  */
-struct quotas *quotas_alloc(u32 cnt, u32 max, u64 max_sum,
-			    int init_val, struct mutex *lock,
-			    struct quota_ops *ops);
+struct quotas *cpt_quotas_alloc(u32 cnt, u32 max, u64 max_sum,
+				int init_val, struct mutex *lock,
+				struct quota_ops *ops);
 /**
  * Frees quota array and any sysfs entries associated with it.
  */
-void quotas_free(struct quotas *quotas);
+void cpt_quotas_free(struct quotas *quotas);
 
 /**
  * Create a sysfs entry controling given quota entry.
@@ -75,12 +75,12 @@ void quotas_free(struct quotas *quotas);
  *
  * @return 0 if succeeded, negative error code otherwise.
  */
-int quota_sysfs_create(const char *name, struct kobject *parent,
-		       struct device *log_dev, struct quota *quota,
-		       void *ops_arg);
+int cpt_quota_sysfs_create(const char *name, struct kobject *parent,
+			   struct device *log_dev, struct quota *quota,
+			   void *ops_arg);
 /**
  * Remove sysfs entry for a given quota if it was created.
  */
-int quota_sysfs_destroy(struct quota *quota);
+int cpt_quota_sysfs_destroy(struct quota *quota);
 
 #endif /* _CPT9X_QUOTA_H_ */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c b/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c
index 14989ad4ffe7..0aad4abef403 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.c
@@ -11,9 +11,9 @@
 #include "cpt_reqmgr.h"
 #include "cpt9x_mbox_common.h"
 
-inline void fill_cpt_inst(union cpt_inst_s *cptinst,
-			  struct cpt_info_buffer *info,
-			  struct cpt_iq_command *iq_cmd)
+static void cpt9x_fill_inst(union cpt_inst_s *cptinst,
+			    struct cpt_info_buffer *info,
+			    struct cpt_iq_command *iq_cmd)
 {
 	cptinst->u[0] = 0x0;
 	cptinst->s9x.doneint = true;
@@ -26,9 +26,10 @@ inline void fill_cpt_inst(union cpt_inst_s *cptinst,
 	cptinst->s9x.ei3 = iq_cmd->cptr.u64;
 }
 
-inline int process_ccode(struct pci_dev *pdev, union cpt_res_s *cpt_status,
-			 struct cpt_info_buffer *cpt_info,
-			 struct cpt_request_info *req, u32 *res_code)
+static int cpt9x_process_ccode(struct pci_dev *pdev,
+			       union cpt_res_s *cpt_status,
+			       struct cpt_info_buffer *cpt_info,
+			       struct cpt_request_info *req, u32 *res_code)
 {
 	u8 ccode = cpt_status->s9x.compcode;
 
@@ -97,7 +98,7 @@ inline int process_ccode(struct pci_dev *pdev, union cpt_res_s *cpt_status,
  * 1 - 1 CPT instruction will be enqueued during LMTST operation
  * 2 - 2 CPT instructions will be enqueued during LMTST operation
  */
-inline void send_cpt_cmd(union cpt_inst_s *cptinst, u32 insts_num, void *obj)
+void cpt9x_send_cmd(union cpt_inst_s *cptinst, u32 insts_num, void *obj)
 {
 	struct cptlf_info *lf = (struct cptlf_info *) obj;
 	void *lmtline = lf->lmtline;
@@ -138,24 +139,19 @@ inline void send_cpt_cmd(union cpt_inst_s *cptinst, u32 insts_num, void *obj)
 	} while (!ret);
 }
 
-inline int cpt_get_kcrypto_eng_grp_num(struct pci_dev *pdev)
+void cpt9x_post_process(struct cptlf_wqe *wqe)
 {
-	struct cptlfs_info *lfs = get_lfs_info(pdev);
-
-	return lfs->kcrypto_eng_grp_num;
-}
-
-inline void cpt_post_process(struct cptlf_wqe *wqe)
-{
-	process_pending_queue(wqe->lfs->pdev,
+	process_pending_queue(wqe->lfs->pdev, &wqe->lfs->ops,
 			      &wqe->lfs->lf[wqe->lf_num].pqueue);
 }
 
-inline int cpt_do_request(struct pci_dev *pdev, struct cpt_request_info *req,
-			  int cpu_num)
+struct reqmgr_ops cpt9x_get_reqmgr_ops(void)
 {
-	struct cptlfs_info *lfs = get_lfs_info(pdev);
+	struct reqmgr_ops ops;
+
+	ops.fill_inst = cpt9x_fill_inst;
+	ops.process_ccode = cpt9x_process_ccode;
+	ops.send_cmd = cpt9x_send_cmd;
 
-	return process_request(pdev, req, &lfs->lf[cpu_num].pqueue,
-			       &lfs->lf[cpu_num]);
+	return ops;
 }
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.h b/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.h
index cb683ba36ffe..098fb677388c 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_reqmgr.h
@@ -11,6 +11,13 @@
 #ifndef __CPT9X_REQUEST_MANAGER_H
 #define __CPT9X_REQUEST_MANAGER_H
 
-void cpt_post_process(struct cptlf_wqe *wqe);
+void cpt9x_post_process(struct cptlf_wqe *wqe);
+struct reqmgr_ops cpt9x_get_reqmgr_ops(void);
+int cpt9x_do_request(struct pci_dev *pdev, struct cpt_request_info *req,
+		     int cpu_num);
+void cpt9x_send_cmd(union cpt_inst_s *cptinst, u32 insts_num, void *obj);
+void cpt9x_send_cmds_in_batch(union cpt_inst_s *cptinst, u32 num, void *obj);
+void cpt9x_send_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
+				    void *obj);
 
 #endif /* __CPT9X_REQUEST_MANAGER_H */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_ucode.c b/drivers/crypto/cavium/cpt/9x/cpt9x_ucode.c
index 0331e777738f..b0d98a528d8b 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_ucode.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_ucode.c
@@ -40,7 +40,8 @@ static struct bitmap get_cores_bmap(struct device *dev,
 	return bmap;
 }
 
-int cpt_detach_and_disable_cores(struct engine_group_info *eng_grp, void *obj)
+static int cpt9x_detach_and_disable_cores(struct engine_group_info *eng_grp,
+					  void *obj)
 {
 	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
 	struct bitmap bmap;
@@ -101,7 +102,7 @@ int cpt_detach_and_disable_cores(struct engine_group_info *eng_grp, void *obj)
 	return ret;
 }
 
-int cpt_set_ucode_base(struct engine_group_info *eng_grp, void *obj)
+static int cpt9x_set_ucode_base(struct engine_group_info *eng_grp, void *obj)
 {
 	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
 	struct engines_reserved *engs;
@@ -137,7 +138,8 @@ int cpt_set_ucode_base(struct engine_group_info *eng_grp, void *obj)
 	return ret;
 }
 
-int cpt_attach_and_enable_cores(struct engine_group_info *eng_grp, void *obj)
+static int cpt9x_attach_and_enable_cores(struct engine_group_info *eng_grp,
+					 void *obj)
 {
 	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
 	struct bitmap bmap;
@@ -179,8 +181,8 @@ int cpt_attach_and_enable_cores(struct engine_group_info *eng_grp, void *obj)
 	return ret;
 }
 
-void cpt_print_engines_mask(struct engine_group_info *eng_grp, void *obj,
-			    char *buf, int size)
+void cpt9x_print_engines_mask(struct engine_group_info *eng_grp, void *obj,
+			      char *buf, int size)
 {
 	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
 	struct bitmap bmap;
@@ -200,7 +202,32 @@ void cpt_print_engines_mask(struct engine_group_info *eng_grp, void *obj,
 		  mask[1], mask[0]);
 }
 
-int cpt_disable_all_cores(struct cptpf_dev *cptpf)
+static void cpt9x_notify_group_change(void *obj)
+{
+	struct cptpf_dev *cptpf = (struct cptpf_dev *) obj;
+	struct engine_group_info *grp;
+	int crypto_eng_grp = INVALID_CRYPTO_ENG_GRP;
+	int i;
+
+	for (i = 0; i < CPT_MAX_ENGINE_GROUPS; i++) {
+		grp = &cptpf->eng_grps.grp[i];
+		if (!grp->is_enabled)
+			continue;
+
+		if (cpt_eng_grp_has_eng_type(grp, SE_TYPES) &&
+		    !cpt_eng_grp_has_eng_type(grp, IE_TYPES) &&
+		    !cpt_eng_grp_has_eng_type(grp, AE_TYPES)) {
+			crypto_eng_grp = i;
+			break;
+		}
+	}
+
+	if (cptpf->crypto_eng_grp == crypto_eng_grp)
+		return;
+	cptpf_send_crypto_eng_grp_msg(cptpf, crypto_eng_grp);
+}
+
+int cpt9x_disable_all_cores(struct cptpf_dev *cptpf)
 {
 	int timeout = 10, ret = 0;
 	int i, busy, total_cores;
@@ -256,3 +283,16 @@ int cpt_disable_all_cores(struct cptpf_dev *cptpf)
 error:
 	return ret;
 }
+
+struct ucode_ops cpt9x_get_ucode_ops(void)
+{
+	struct ucode_ops ops;
+
+	ops.detach_and_disable_cores = cpt9x_detach_and_disable_cores;
+	ops.attach_and_enable_cores = cpt9x_attach_and_enable_cores;
+	ops.set_ucode_base = cpt9x_set_ucode_base;
+	ops.print_engines_mask = cpt9x_print_engines_mask;
+	ops.notify_group_change = cpt9x_notify_group_change;
+
+	return ops;
+}
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h b/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h
index ddfecdaf8cfa..328e09043dc7 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf.h
@@ -31,5 +31,6 @@ struct cptvf_dev {
 irqreturn_t cptvf_pfvf_mbox_intr(int irq, void *arg);
 void cptvf_pfvf_mbox_handler(struct work_struct *work);
 int cptvf_send_eng_grp_num_msg(struct cptvf_dev *cptvf, int eng_type);
+struct algs_ops cpt9x_get_algs_ops(void);
 
 #endif /* __CPT9X_VF_H */
diff --git a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
index db706801a0b4..6193a7ac3949 100644
--- a/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
+++ b/drivers/crypto/cavium/cpt/9x/cpt9x_vf_mbox.c
@@ -71,7 +71,7 @@ void cptvf_pfvf_mbox_handler(struct work_struct *work)
 		}
 
 		if (cpt_is_dbg_level_en(CPT_DBG_MBOX_MSGS))
-			dump_mbox_msg(&cptvf->pdev->dev, msg, size);
+			cpt9x_dump_mbox_msg(&cptvf->pdev->dev, msg, size);
 
 		offset = msg->next_msgoff;
 		switch (msg->id) {
diff --git a/drivers/crypto/cavium/cpt/Kconfig b/drivers/crypto/cavium/cpt/Kconfig
index 023d66ce421d..8db0043bbf59 100644
--- a/drivers/crypto/cavium/cpt/Kconfig
+++ b/drivers/crypto/cavium/cpt/Kconfig
@@ -2,31 +2,31 @@
 # Cavium crypto device configuration
 #
 
-choice
-	prompt "Cavium Cryptographic Accelerator (CPT) driver"
+config CRYPTO_DEV_CPT
+	tristate
+
+config CRYPTO_DEV_OCTEONTX_CPT
+	tristate "Support for OcteonTX CPT driver"
 	depends on ARCH_THUNDER || COMPILE_TEST
 	depends on PCI_MSI && 64BIT
 	depends on OCTEONTX2_AF
-	optional
+	select CRYPTO_DEV_CPT
 	help
-		Support for Cavium Cryptographic Accelerator (CPT) block
-		found in OcteonTX and OcteonTX2 series of processors.
-
-	config CRYPTO_DEV_OCTEONTX_CPT
-         tristate "OcteonTX CPT driver"
-         help
-			Support for Cavium Cryptographic Accelerator (CPT)
-			block found in OcteonTX series of processors.
+		Support for Cavium Cryptographic Accelerator Unit (CPT)
+		block found in OcteonTX series of processors.
 
-			To compile this driver as modules, choose M here:
-			the modules will be called cptpf8x and cptvf8x.
+		To compile this driver as modules, choose M here:
+		the modules will be called cptpf8x and cptvf8x.
 
-    config CRYPTO_DEV_OCTEONTX2_CPT
-         tristate "OcteonTX2 CPT driver"
-		 help
-			Support for Cavium Cryptographic Accelerator (CPT)
-			block found in OcteonTX2 series of processors.
+config CRYPTO_DEV_OCTEONTX2_CPT
+	tristate "Support for OcteonTX2 CPT driver"
+	depends on ARCH_THUNDER || COMPILE_TEST
+	depends on PCI_MSI && 64BIT
+	depends on OCTEONTX2_AF
+	select CRYPTO_DEV_CPT
+	help
+		Support for Cryptographic Accelerator Unit (CPT)
+		block found in OcteonTX2 series of processors.
 
-			To compile this driver as modules, choose M here:
-			the modules will be called cptpf9x and cptvf9x.
-endchoice
+		To compile this driver as modules, choose M here:
+		the modules will be called cptpf9x and cptvf9x.
\ No newline at end of file
diff --git a/drivers/crypto/cavium/cpt/Makefile b/drivers/crypto/cavium/cpt/Makefile
new file mode 100644
index 000000000000..b915632cb490
--- /dev/null
+++ b/drivers/crypto/cavium/cpt/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_CRYPTO_DEV_CPT) += common/
+obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += 8x/
+obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += 9x/
\ No newline at end of file
diff --git a/drivers/crypto/cavium/cpt/common/Makefile b/drivers/crypto/cavium/cpt/common/Makefile
new file mode 100644
index 000000000000..23df1b37035e
--- /dev/null
+++ b/drivers/crypto/cavium/cpt/common/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_CRYPTO_DEV_OCTEONTX_CPT) += cpt_common.o
+
+cpt_common-objs := cpt_ucode.o cpt_reqmgr.o cpt_algs.o cpt_debug.o
\ No newline at end of file
diff --git a/drivers/crypto/cavium/cpt/common/cpt_algs.c b/drivers/crypto/cavium/cpt/common/cpt_algs.c
index 981b9d4276e5..f0d9b2086c90 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_algs.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_algs.c
@@ -19,6 +19,8 @@
 #include <linux/sort.h>
 #include "cpt_common.h"
 #include "cpt_algs.h"
+#include "cpt_algs_internal.h"
+
 
 static DEFINE_MUTEX(mutex);
 static int is_crypto_registered;
@@ -30,6 +32,7 @@ static int is_crypto_registered;
 
 struct cpt_device_desc {
 	enum cpt_pf_type pf_type;
+	struct algs_ops ops;
 	struct pci_dev *dev;
 	int num_queues;
 };
@@ -47,7 +50,8 @@ static struct cpt_device_table ae_devices = {
 	.count = ATOMIC_INIT(0)
 };
 
-static inline int get_se_device(struct pci_dev **pdev, int *cpu_num)
+static inline int get_se_device(struct pci_dev **pdev, struct algs_ops **ops,
+				int *cpu_num)
 {
 	int count, err = 0;
 
@@ -68,6 +72,7 @@ static inline int get_se_device(struct pci_dev **pdev, int *cpu_num)
 		if (*cpu_num >= count)
 			*cpu_num %= count;
 		*pdev = se_devices.desc[*cpu_num].dev;
+		*ops = &se_devices.desc[*cpu_num].ops;
 	break;
 
 	case CPT_96XX:
@@ -80,6 +85,7 @@ static inline int get_se_device(struct pci_dev **pdev, int *cpu_num)
 		if (*cpu_num >= se_devices.desc[0].num_queues)
 			*cpu_num %= se_devices.desc[0].num_queues;
 		*pdev = se_devices.desc[0].dev;
+		*ops = &se_devices.desc[0].ops;
 	break;
 
 	default:
@@ -125,6 +131,7 @@ void cvm_callback(int status, void *arg, void *req)
 
 	areq->complete(areq, status);
 }
+EXPORT_SYMBOL_GPL(cvm_callback);
 
 static inline void update_input_data(struct cpt_request_info *req_info,
 				     struct scatterlist *inp_sg,
@@ -254,9 +261,10 @@ static inline int cvm_enc_dec(struct ablkcipher_request *req, u32 enc)
 {
 	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
 	struct cvm_req_ctx *rctx = ablkcipher_request_ctx(req);
-	u32 enc_iv_len = crypto_ablkcipher_ivsize(tfm);
 	struct cpt_request_info *req_info = &rctx->cpt_req;
-	struct pci_dev *pdev = NULL;
+	u32 enc_iv_len = crypto_ablkcipher_ivsize(tfm);
+	struct pci_dev *pdev;
+	struct algs_ops *ops;
 	int status, cpu_num;
 
 	/* Validate that request doesn't exceed maximum CPT supported size */
@@ -267,16 +275,20 @@ static inline int cvm_enc_dec(struct ablkcipher_request *req, u32 enc)
 	create_input_list(req, enc, enc_iv_len);
 	create_output_list(req, enc_iv_len);
 
-	status = get_se_device(&pdev, &cpu_num);
+	status = get_se_device(&pdev, &ops, &cpu_num);
 	if (status)
 		return status;
 
 	req_info->callback = (void *)cvm_callback;
 	req_info->areq = &req->base;
 	req_info->req_type = ENC_DEC_REQ;
-	req_info->ctrl.s.grp = cpt_get_kcrypto_eng_grp_num(pdev);
+	if (!ops->cpt_get_kcrypto_eng_grp_num)
+		return -EFAULT;
+	req_info->ctrl.s.grp = ops->cpt_get_kcrypto_eng_grp_num(pdev);
 
-	status = cpt_do_request(pdev, req_info, cpu_num);
+	if (!ops->cpt_do_request)
+		return -EFAULT;
+	status = ops->cpt_do_request(pdev, req_info, cpu_num);
 	/* We perform an asynchronous send and once
 	 * the request is completed the driver would
 	 * intimate through registered call back functions
@@ -1099,7 +1111,8 @@ u32 cvm_aead_enc_dec(struct aead_request *req, u8 reg_type, u8 enc)
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct cvm_req_ctx *rctx = aead_request_ctx(req);
 	struct cpt_request_info *req_info = &rctx->cpt_req;
-	struct pci_dev *pdev = NULL;
+	struct pci_dev *pdev;
+	struct algs_ops *ops;
 	u32 status, cpu_num;
 
 	memset(rctx, 0, sizeof(struct cvm_req_ctx));
@@ -1139,13 +1152,17 @@ u32 cvm_aead_enc_dec(struct aead_request *req, u8 reg_type, u8 enc)
 	    req_info->req.param2 > CPT_MAX_REQ_SIZE)
 		return -E2BIG;
 
-	status = get_se_device(&pdev, &cpu_num);
+	status = get_se_device(&pdev, &ops, &cpu_num);
 	if (status)
 		return status;
 
-	req_info->ctrl.s.grp = cpt_get_kcrypto_eng_grp_num(pdev);
+	if (!ops->cpt_get_kcrypto_eng_grp_num)
+		return -EFAULT;
+	req_info->ctrl.s.grp = ops->cpt_get_kcrypto_eng_grp_num(pdev);
 
-	status = cpt_do_request(pdev, req_info, cpu_num);
+	if (!ops->cpt_do_request)
+		return -EFAULT;
+	status = ops->cpt_do_request(pdev, req_info, cpu_num);
 	/* We perform an asynchronous send and once
 	 * the request is completed the driver would
 	 * intimate through registered call back functions
@@ -1528,7 +1545,8 @@ static void swap_func(void *lptr, void *rptr, int size)
 	*rdesc = desc;
 }
 
-int cvm_crypto_init(struct pci_dev *pdev, enum cpt_pf_type pf_type,
+int cvm_crypto_init(struct pci_dev *pdev, struct module *mod,
+		    struct algs_ops ops, enum cpt_pf_type pf_type,
 		    enum cpt_vf_type engine_type, int num_queues,
 		    int num_devices)
 {
@@ -1546,6 +1564,7 @@ int cvm_crypto_init(struct pci_dev *pdev, enum cpt_pf_type pf_type,
 		}
 		se_devices.desc[count].pf_type = pf_type;
 		se_devices.desc[count].num_queues = num_queues;
+		se_devices.desc[count].ops = ops;
 		se_devices.desc[count++].dev = pdev;
 		atomic_inc(&se_devices.count);
 
@@ -1557,7 +1576,7 @@ int cvm_crypto_init(struct pci_dev *pdev, enum cpt_pf_type pf_type,
 				ret =  -EINVAL;
 				goto err;
 			}
-			try_module_get(THIS_MODULE);
+			try_module_get(mod);
 			is_crypto_registered = true;
 		}
 		sort(se_devices.desc, count, sizeof(struct cpt_device_desc),
@@ -1573,6 +1592,7 @@ int cvm_crypto_init(struct pci_dev *pdev, enum cpt_pf_type pf_type,
 		}
 		ae_devices.desc[count].pf_type = pf_type;
 		ae_devices.desc[count].num_queues = num_queues;
+		ae_devices.desc[count].ops = ops;
 		ae_devices.desc[count++].dev = pdev;
 		atomic_inc(&ae_devices.count);
 		sort(ae_devices.desc, count, sizeof(struct cpt_device_desc),
@@ -1586,8 +1606,9 @@ int cvm_crypto_init(struct pci_dev *pdev, enum cpt_pf_type pf_type,
 	mutex_unlock(&mutex);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(cvm_crypto_init);
 
-void cvm_crypto_exit(struct pci_dev *pdev)
+void cvm_crypto_exit(struct pci_dev *pdev, struct module *mod)
 {
 	bool dev_found = false;
 	int i, j, count;
@@ -1609,8 +1630,10 @@ void cvm_crypto_exit(struct pci_dev *pdev)
 	if (atomic_dec_and_test(&se_devices.count) &&
 	    !is_any_alg_used()) {
 		cav_unregister_algs();
-		module_put(THIS_MODULE);
+		module_put(mod);
 		is_crypto_registered = false;
 	}
 	mutex_unlock(&mutex);
 }
+EXPORT_SYMBOL_GPL(cvm_crypto_exit);
+
diff --git a/drivers/crypto/cavium/cpt/common/cpt_algs.h b/drivers/crypto/cavium/cpt/common/cpt_algs.h
index 8cce0db0ce24..b9b47f81fb8e 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_algs.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_algs.h
@@ -1,204 +1,26 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 RVU Admin Function driver
- *
- * Copyright (C) 2018 Marvell International Ltd.
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-#ifndef _CPT_ALGS_H_
-#define _CPT_ALGS_H_
-
-#define MAX_ENC_KEY_SIZE 32
-#define MAX_HASH_KEY_SIZE 64
-#define MAX_KEY_SIZE (MAX_ENC_KEY_SIZE + MAX_HASH_KEY_SIZE)
-#define CONTROL_WORD_LEN 8
-#define KEY2_OFFSET 48
-
-#define DMA_MODE_FLAG(dma_mode) \
-	(((dma_mode) == DMA_GATHER_SCATTER) ? (1 << 7) : 0)
-
-/* Size of salt in AES GCM mode */
-#define AES_GCM_SALT_SIZE	4
-/* Size of IV in AES GCM mode */
-#define AES_GCM_IV_SIZE		8
-/* Size of ICV (Integrity Check Value) in AES GCM mode */
-#define AES_GCM_ICV_SIZE	16
-/* Offset of IV in AES GCM mode */
-#define AES_GCM_IV_OFFSET	8
-
-/* Truncated SHA digest size */
-#define SHA1_TRUNC_DIGEST_SIZE		12
-#define SHA256_TRUNC_DIGEST_SIZE	16
-#define SHA384_TRUNC_DIGEST_SIZE	24
-#define SHA512_TRUNC_DIGEST_SIZE	32
-
-#define ROUNDUP8(val) (((val) + 7)&0xfffffff8)
-
-enum request_type {
-	ENC_DEC_REQ		= 0x1,
-	AEAD_ENC_DEC_REQ	= 0x2,
-	AEAD_ENC_DEC_NULL_REQ	= 0x3,
-	PASSTHROUGH_REQ		= 0x4
-};
-
-enum major_opcodes {
-	MAJOR_OP_MISC	= 0x01,
-	MAJOR_OP_FC	= 0x33,
-	MAJOR_OP_HMAC	= 0x35,
-};
-
-enum req_type {
-	AE_CORE_REQ,
-	SE_CORE_REQ,
-};
-
-enum cipher_type {
-	CIPHER_NULL	= 0x0,
-	DES3_CBC	= 0x1,
-	DES3_ECB	= 0x2,
-	AES_CBC		= 0x3,
-	AES_ECB		= 0x4,
-	AES_CFB		= 0x5,
-	AES_CTR		= 0x6,
-	AES_GCM		= 0x7,
-	AES_XTS		= 0x8
-};
-
-enum mac_type {
-	MAC_NULL	= 0x0,
-	MD5		= 0x1,
-	SHA1		= 0x2,
-	SHA224		= 0x3,
-	SHA256		= 0x4,
-	SHA384		= 0x5,
-	SHA512		= 0x6,
-	GMAC		= 0x7
-};
-
-enum aes_key_len {
-	AES_128_BIT = 0x1,
-	AES_192_BIT = 0x2,
-	AES_256_BIT = 0x3
-};
-
-union encr_ctrl {
-	u64 flags;
-	struct {
-#if defined(__BIG_ENDIAN_BITFIELD)
-		u64 enc_cipher:4;
-		u64 reserved1:1;
-		u64 aes_key:2;
-		u64 iv_source:1;
-		u64 mac_type:4;
-		u64 reserved2:3;
-		u64 auth_input_type:1;
-		u64 mac_len:8;
-		u64 reserved3:8;
-		u64 encr_offset:16;
-		u64 iv_offset:8;
-		u64 auth_offset:8;
-#else
-		u64 auth_offset:8;
-		u64 iv_offset:8;
-		u64 encr_offset:16;
-		u64 reserved3:8;
-		u64 mac_len:8;
-		u64 auth_input_type:1;
-		u64 reserved2:3;
-		u64 mac_type:4;
-		u64 iv_source:1;
-		u64 aes_key:2;
-		u64 reserved1:1;
-		u64 enc_cipher:4;
-#endif
-	} e;
-};
-
-struct cvm_cipher {
-	const char *name;
-	u8 value;
-};
-
-struct enc_context {
-	union encr_ctrl enc_ctrl;
-	u8 encr_key[32];
-	u8 encr_iv[16];
-};
-
-union fchmac_context {
-	struct {
-		u8 ipad[64];
-		u8 opad[64]; /* or OPAD */
-	} e;
-	struct {
-		u8 hmac_calc[64]; /* HMAC received */
-		u8 hmac_recv[64]; /* HMAC calculated */
-	} s;
-};
-
-struct fc_context {
-	struct enc_context enc;
-	union fchmac_context hmac;
-};
-
-struct cvm_enc_ctx {
-	u32 key_len;
-	u8 enc_key[MAX_KEY_SIZE];
-	u8 cipher_type;
-	u8 key_type;
-};
-
-struct cvm_des3_ctx {
-	u32 key_len;
-	u8 des3_key[MAX_KEY_SIZE];
-};
-
-union offset_ctrl_word {
-	u64 flags;
-	struct {
-#if defined(__BIG_ENDIAN_BITFIELD)
-		u64 reserved:32;
-		u64 enc_data_offset:16;
-		u64 iv_offset:8;
-		u64 auth_offset:8;
-#else
-		u64 auth_offset:8;
-		u64 iv_offset:8;
-		u64 enc_data_offset:16;
-		u64 reserved:32;
-#endif
-	} e;
-};
-
-struct cvm_req_ctx {
-	struct cpt_request_info cpt_req;
-	union offset_ctrl_word ctrl_word;
-	struct fc_context fctx;
-};
-
-struct sdesc {
-	struct shash_desc shash;
-};
+#ifndef __CPT_ALGS_H_
+#define __CPT_ALGS_H_
 
-struct cvm_aead_ctx {
-	u8 key[MAX_KEY_SIZE];
-	struct crypto_shash *hashalg;
-	struct sdesc *sdesc;
-	u8 *ipad;
-	u8 *opad;
-	u32 enc_key_len;
-	u32 auth_key_len;
-	u8 cipher_type;
-	u8 mac_type;
-	u8 key_type;
+struct algs_ops {
+	int (*cpt_do_request)(struct pci_dev *pdev,
+			      struct cpt_request_info *req, int cpu_num);
+	int (*cpt_get_kcrypto_eng_grp_num)(struct pci_dev *pdev);
 };
 
-int cpt_do_request(struct pci_dev *pdev, struct cpt_request_info *req,
-		   int cpu_num);
-int cpt_get_kcrypto_eng_grp_num(struct pci_dev *pdev);
+int cvm_crypto_init(struct pci_dev *pdev, struct module *mod,
+		    struct algs_ops ops, enum cpt_pf_type pf_type,
+		    enum cpt_vf_type engine_type, int num_queues,
+		    int num_devices);
+void cvm_crypto_exit(struct pci_dev *pdev, struct module *mod);
 void cvm_callback(int status, void *arg, void *req);
 
-#endif /*_CPT_ALGS_H_*/
+#endif /* __CPT_ALGS_H_*/
diff --git a/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h b/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h
new file mode 100644
index 000000000000..5941eab2c23d
--- /dev/null
+++ b/drivers/crypto/cavium/cpt/common/cpt_algs_internal.h
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Marvell OcteonTx2 RVU Admin Function driver
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __CPT_ALGS_INTERNAL_H_
+#define __CPT_ALGS_INTERNAL_H_
+
+#define MAX_ENC_KEY_SIZE 32
+#define MAX_HASH_KEY_SIZE 64
+#define MAX_KEY_SIZE (MAX_ENC_KEY_SIZE + MAX_HASH_KEY_SIZE)
+#define CONTROL_WORD_LEN 8
+#define KEY2_OFFSET 48
+
+#define DMA_MODE_FLAG(dma_mode) \
+	(((dma_mode) == DMA_GATHER_SCATTER) ? (1 << 7) : 0)
+
+/* Size of salt in AES GCM mode */
+#define AES_GCM_SALT_SIZE	4
+/* Size of IV in AES GCM mode */
+#define AES_GCM_IV_SIZE		8
+/* Size of ICV (Integrity Check Value) in AES GCM mode */
+#define AES_GCM_ICV_SIZE	16
+/* Offset of IV in AES GCM mode */
+#define AES_GCM_IV_OFFSET	8
+
+/* Truncated SHA digest size */
+#define SHA1_TRUNC_DIGEST_SIZE		12
+#define SHA256_TRUNC_DIGEST_SIZE	16
+#define SHA384_TRUNC_DIGEST_SIZE	24
+#define SHA512_TRUNC_DIGEST_SIZE	32
+
+#define ROUNDUP8(val) (((val) + 7)&0xfffffff8)
+
+enum request_type {
+	ENC_DEC_REQ		= 0x1,
+	AEAD_ENC_DEC_REQ	= 0x2,
+	AEAD_ENC_DEC_NULL_REQ	= 0x3,
+	PASSTHROUGH_REQ		= 0x4
+};
+
+enum major_opcodes {
+	MAJOR_OP_MISC	= 0x01,
+	MAJOR_OP_FC	= 0x33,
+	MAJOR_OP_HMAC	= 0x35,
+};
+
+enum req_type {
+	AE_CORE_REQ,
+	SE_CORE_REQ,
+};
+
+enum cipher_type {
+	CIPHER_NULL	= 0x0,
+	DES3_CBC	= 0x1,
+	DES3_ECB	= 0x2,
+	AES_CBC		= 0x3,
+	AES_ECB		= 0x4,
+	AES_CFB		= 0x5,
+	AES_CTR		= 0x6,
+	AES_GCM		= 0x7,
+	AES_XTS		= 0x8
+};
+
+enum mac_type {
+	MAC_NULL	= 0x0,
+	MD5		= 0x1,
+	SHA1		= 0x2,
+	SHA224		= 0x3,
+	SHA256		= 0x4,
+	SHA384		= 0x5,
+	SHA512		= 0x6,
+	GMAC		= 0x7
+};
+
+enum aes_key_len {
+	AES_128_BIT = 0x1,
+	AES_192_BIT = 0x2,
+	AES_256_BIT = 0x3
+};
+
+union encr_ctrl {
+	u64 flags;
+	struct {
+#if defined(__BIG_ENDIAN_BITFIELD)
+		u64 enc_cipher:4;
+		u64 reserved1:1;
+		u64 aes_key:2;
+		u64 iv_source:1;
+		u64 mac_type:4;
+		u64 reserved2:3;
+		u64 auth_input_type:1;
+		u64 mac_len:8;
+		u64 reserved3:8;
+		u64 encr_offset:16;
+		u64 iv_offset:8;
+		u64 auth_offset:8;
+#else
+		u64 auth_offset:8;
+		u64 iv_offset:8;
+		u64 encr_offset:16;
+		u64 reserved3:8;
+		u64 mac_len:8;
+		u64 auth_input_type:1;
+		u64 reserved2:3;
+		u64 mac_type:4;
+		u64 iv_source:1;
+		u64 aes_key:2;
+		u64 reserved1:1;
+		u64 enc_cipher:4;
+#endif
+	} e;
+};
+
+struct cvm_cipher {
+	const char *name;
+	u8 value;
+};
+
+struct enc_context {
+	union encr_ctrl enc_ctrl;
+	u8 encr_key[32];
+	u8 encr_iv[16];
+};
+
+union fchmac_context {
+	struct {
+		u8 ipad[64];
+		u8 opad[64]; /* or OPAD */
+	} e;
+	struct {
+		u8 hmac_calc[64]; /* HMAC received */
+		u8 hmac_recv[64]; /* HMAC calculated */
+	} s;
+};
+
+struct fc_context {
+	struct enc_context enc;
+	union fchmac_context hmac;
+};
+
+struct cvm_enc_ctx {
+	u32 key_len;
+	u8 enc_key[MAX_KEY_SIZE];
+	u8 cipher_type;
+	u8 key_type;
+};
+
+struct cvm_des3_ctx {
+	u32 key_len;
+	u8 des3_key[MAX_KEY_SIZE];
+};
+
+union offset_ctrl_word {
+	u64 flags;
+	struct {
+#if defined(__BIG_ENDIAN_BITFIELD)
+		u64 reserved:32;
+		u64 enc_data_offset:16;
+		u64 iv_offset:8;
+		u64 auth_offset:8;
+#else
+		u64 auth_offset:8;
+		u64 iv_offset:8;
+		u64 enc_data_offset:16;
+		u64 reserved:32;
+#endif
+	} e;
+};
+
+struct cvm_req_ctx {
+	struct cpt_request_info cpt_req;
+	union offset_ctrl_word ctrl_word;
+	struct fc_context fctx;
+};
+
+struct sdesc {
+	struct shash_desc shash;
+};
+
+struct cvm_aead_ctx {
+	u8 key[MAX_KEY_SIZE];
+	struct crypto_shash *hashalg;
+	struct sdesc *sdesc;
+	u8 *ipad;
+	u8 *opad;
+	u32 enc_key_len;
+	u32 auth_key_len;
+	u8 cipher_type;
+	u8 mac_type;
+	u8 key_type;
+};
+
+#endif /*__CPT_ALGS_INTERNAL_H_*/
diff --git a/drivers/crypto/cavium/cpt/common/cpt_common.h b/drivers/crypto/cavium/cpt/common/cpt_common.h
index 3ae145adb54e..b7540d12e328 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_common.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_common.h
@@ -223,9 +223,4 @@ struct cpt_info_buffer {
 	u8 extra_time;
 };
 
-int cvm_crypto_init(struct pci_dev *pdev, enum cpt_pf_type pf_type,
-		    enum cpt_vf_type engine_type, int num_queues,
-		    int num_devices);
-void cvm_crypto_exit(struct pci_dev *pdev);
-
 #endif /* __CPT_COMMON_H */
diff --git a/drivers/crypto/cavium/cpt/common/cpt_debug.c b/drivers/crypto/cavium/cpt/common/cpt_debug.c
index 1ca1623209a0..9601634c5f67 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_debug.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_debug.c
@@ -20,8 +20,10 @@ void cpt_set_dbg_level(int level)
 	else
 		debug_level = level;
 }
+EXPORT_SYMBOL_GPL(cpt_set_dbg_level);
 
 int cpt_is_dbg_level_en(int level)
 {
 	return (debug_level & level);
 }
+EXPORT_SYMBOL_GPL(cpt_is_dbg_level_en);
diff --git a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c
index 56f9229e36fa..a246ed4e5587 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.c
@@ -11,6 +11,254 @@
 #include "cpt_common.h"
 #include "cpt_reqmgr.h"
 
+inline void process_pending_queue(struct pci_dev *pdev, struct reqmgr_ops *ops,
+				  struct pending_queue *pqueue)
+{
+	struct pending_entry *resume_pentry = NULL;
+	struct cpt_info_buffer *cpt_info = NULL;
+	void (*callback)(int, void *, void *);
+	struct pending_entry *pentry = NULL;
+	struct cpt_request_info *req = NULL;
+	union cpt_res_s *cpt_status = NULL;
+	struct crypto_async_request *areq;
+	u32 res_code, resume_index;
+
+	while (1) {
+		spin_lock_bh(&pqueue->lock);
+		pentry = &pqueue->head[pqueue->front];
+
+		if (WARN_ON(!pentry)) {
+			spin_unlock_bh(&pqueue->lock);
+			break;
+		}
+
+		res_code = -EINVAL;
+		if (unlikely(!pentry->busy)) {
+			spin_unlock_bh(&pqueue->lock);
+			break;
+		}
+
+		if (unlikely(!pentry->callback) ||
+		    unlikely(!pentry->areq)) {
+			dev_err(&pdev->dev, "Callback or callback arg NULL\n");
+			goto process_pentry;
+		}
+
+		cpt_info = (struct cpt_info_buffer *) pentry->post_arg;
+		if (unlikely(!cpt_info)) {
+			dev_err(&pdev->dev, "Pending entry post arg NULL\n");
+			goto process_pentry;
+		}
+
+		req = cpt_info->req;
+		if (unlikely(!req)) {
+			dev_err(&pdev->dev, "Request NULL\n");
+			goto process_pentry;
+		}
+
+		cpt_status = (union cpt_res_s *) pentry->completion_addr;
+		if (unlikely(!cpt_status)) {
+			dev_err(&pdev->dev, "Completion address NULL\n");
+			goto process_pentry;
+		}
+
+		/* Process completion code */
+		if (!ops->process_ccode) {
+			dev_err(&pdev->dev, "Process_ccode pointer is NULL\n");
+			goto process_pentry;
+		}
+		if (ops->process_ccode(pdev, cpt_status, cpt_info, req,
+				       &res_code)) {
+			spin_unlock_bh(&pqueue->lock);
+			return;
+		}
+
+process_pentry:
+		/*
+		 * Check if we should inform sending side to resume
+		 * We do it CPT_IQ_RESUME_MARGIN elements in advance before
+		 * pending queue becomes empty
+		 */
+		resume_index = modulo_inc(pqueue->front, pqueue->qlen,
+					  CPT_IQ_RESUME_MARGIN);
+		resume_pentry = &pqueue->head[resume_index];
+		if (resume_pentry &&
+		    resume_pentry->resume_sender) {
+			resume_pentry->resume_sender = false;
+			callback = resume_pentry->callback;
+			areq = resume_pentry->areq;
+
+			if (callback && areq) {
+				spin_unlock_bh(&pqueue->lock);
+
+				/*
+				 * EINPROGRESS is an indication for sending
+				 * side that it can resume sending requests
+				 */
+				callback(-EINPROGRESS, areq, req);
+				spin_lock_bh(&pqueue->lock);
+			}
+		}
+
+		callback = pentry->callback;
+		areq = pentry->areq;
+		free_pentry(pentry);
+
+		pqueue->pending_count--;
+		pqueue->front = modulo_inc(pqueue->front, pqueue->qlen, 1);
+		spin_unlock_bh(&pqueue->lock);
+
+		/*
+		 * Call callback after current pending entry has been been
+		 * processed we don't do it if the callback pointer or
+		 * argument pointer is invalid
+		 */
+		if (callback && areq)
+			callback(res_code, areq, req);
+
+		if (cpt_info)
+			do_request_cleanup(pdev, cpt_info);
+	}
+}
+EXPORT_SYMBOL_GPL(process_pending_queue);
+
+inline int process_request(struct pci_dev *pdev, struct reqmgr_ops *ops,
+			   struct cpt_request_info *req,
+			   struct pending_queue *pqueue, void *obj)
+{
+	struct cptvf_request *cpt_req = &req->req;
+	struct cpt_info_buffer *info = NULL;
+	struct pending_entry *pentry = NULL;
+	union ctrl_info *ctrl = &req->ctrl;
+	union cpt_res_s *result = NULL;
+	struct cpt_iq_command iq_cmd;
+	union cpt_inst_s cptinst;
+	int retry, ret = 0;
+	u8 resume_sender;
+	gfp_t gfp;
+
+	if (!ops->fill_inst ||
+	    !ops->send_cmd)
+		return -EFAULT;
+
+	gfp = (req->areq->flags & CRYPTO_TFM_REQ_MAY_SLEEP) ? GFP_KERNEL :
+							      GFP_ATOMIC;
+	info = kzalloc(sizeof(*info), gfp);
+	if (unlikely(!info)) {
+		dev_err(&pdev->dev, "Memory allocation failed\n");
+		return -ENOMEM;
+	}
+
+	ret = setup_sgio_list(pdev, info, req, gfp);
+	if (unlikely(ret)) {
+		dev_err(&pdev->dev, "Setting up SG list failed");
+		goto request_cleanup;
+	}
+	cpt_req->dlen = info->dlen;
+
+	/*
+	 * Get buffer for union cpt_res_s response
+	 * structure and its physical address
+	 */
+	info->completion_addr = kzalloc(sizeof(union cpt_res_s), gfp);
+	if (unlikely(!info->completion_addr)) {
+		dev_err(&pdev->dev, "memory allocation failed\n");
+		goto request_cleanup;
+	}
+
+	result = (union cpt_res_s *) info->completion_addr;
+	result->s9x.compcode = COMPLETION_CODE_INIT;
+	info->comp_baddr = dma_map_single(&pdev->dev,
+					  (void *) info->completion_addr,
+					  sizeof(union cpt_res_s),
+					  DMA_BIDIRECTIONAL);
+	if (unlikely(dma_mapping_error(&pdev->dev, info->comp_baddr))) {
+		dev_err(&pdev->dev, "Dma mapping failed\n");
+		ret = -EFAULT;
+		goto request_cleanup;
+	}
+
+	spin_lock_bh(&pqueue->lock);
+	pentry = get_free_pending_entry(pqueue, pqueue->qlen);
+	retry = CPT_PENTRY_TIMEOUT / CPT_PENTRY_STEP;
+	while (unlikely(!pentry) && retry--) {
+		spin_unlock_bh(&pqueue->lock);
+		udelay(CPT_PENTRY_STEP);
+		spin_lock_bh(&pqueue->lock);
+		pentry = get_free_pending_entry(pqueue, pqueue->qlen);
+	}
+
+	if (unlikely(!pentry)) {
+		ret = -ENOSPC;
+		spin_unlock_bh(&pqueue->lock);
+		goto request_cleanup;
+	}
+
+	/*
+	 * Check if we are close to filling in entire pending queue,
+	 * if so then tell the sender to stop/sleep by returning -EBUSY
+	 * We do it only for context which can sleep (GFP_KERNEL)
+	 */
+	if (gfp == GFP_KERNEL &&
+	    pqueue->pending_count > (pqueue->qlen - CPT_IQ_STOP_MARGIN)) {
+		pentry->resume_sender = true;
+	} else
+		pentry->resume_sender = false;
+	resume_sender = pentry->resume_sender;
+	pqueue->pending_count++;
+
+	pentry->completion_addr = info->completion_addr;
+	pentry->post_arg = (void *) info;
+	pentry->callback = req->callback;
+	pentry->areq = req->areq;
+	pentry->busy = true;
+	info->pentry = pentry;
+	info->time_in = jiffies;
+	info->req = req;
+	spin_unlock_bh(&pqueue->lock);
+
+	/* Fill in the command */
+	iq_cmd.cmd.u64 = 0;
+	iq_cmd.cmd.s.opcode = cpu_to_be16(cpt_req->opcode.flags);
+	iq_cmd.cmd.s.param1 = cpu_to_be16(cpt_req->param1);
+	iq_cmd.cmd.s.param2 = cpu_to_be16(cpt_req->param2);
+	iq_cmd.cmd.s.dlen   = cpu_to_be16(cpt_req->dlen);
+
+	/* 64-bit swap for microcode data reads, not needed for addresses*/
+	iq_cmd.cmd.u64 = cpu_to_be64(iq_cmd.cmd.u64);
+	iq_cmd.dptr = info->dptr_baddr;
+	iq_cmd.rptr = info->rptr_baddr;
+	iq_cmd.cptr.u64 = 0;
+	iq_cmd.cptr.s.grp = ctrl->s.grp;
+
+	/* Fill in the CPT_INST_S type command for HW interpretation */
+	ops->fill_inst(&cptinst, info, &iq_cmd);
+
+	/* Print debug info if enabled */
+	if (cpt_is_dbg_level_en(CPT_DBG_ENC_DEC_REQS)) {
+		dump_sg_list(pdev, req);
+		dev_info(&pdev->dev, "Cpt_inst_s hexdump (%d bytes)\n",
+			 CPT_INST_SIZE);
+		print_hex_dump(KERN_INFO, "", 0, 16, 1, &cptinst,
+			       CPT_INST_SIZE, false);
+		dev_info(&pdev->dev, "Dptr hexdump (%d bytes)\n",
+			 cpt_req->dlen);
+		print_hex_dump(KERN_INFO, "", 0, 16, 1, info->in_buffer,
+			       cpt_req->dlen, false);
+	}
+
+	/* Send CPT command */
+	ops->send_cmd(&cptinst, 1, obj);
+
+	ret = resume_sender ? -EBUSY : -EINPROGRESS;
+	return ret;
+
+request_cleanup:
+	do_request_cleanup(pdev, info);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(process_request);
+
 void dump_sg_list(struct pci_dev *pdev, struct cpt_request_info *req)
 {
 	int i;
@@ -39,3 +287,5 @@ void dump_sg_list(struct pci_dev *pdev, struct cpt_request_info *req)
 			       req->out[i].vptr, req->out[i].size, false);
 	}
 }
+EXPORT_SYMBOL_GPL(dump_sg_list);
+
diff --git a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h
index 190eae7e9835..0e3cc1bccd45 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_reqmgr.h
@@ -15,16 +15,23 @@
 #include <linux/crypto.h>
 #include "cpt_hw_types.h"
 
-void send_cpt_cmd(union cpt_inst_s *cptinst, u32 val, void *obj);
-void send_cpt_cmds_in_batch(union cpt_inst_s *cptinst, u32 num, void *obj);
-void send_cpt_cmds_for_speed_test(union cpt_inst_s *cptinst, u32 num,
-				  void *obj);
+struct reqmgr_ops {
+	void (*send_cmd)(union cpt_inst_s *cptinst, u32 val, void *obj);
+	void (*fill_inst)(union cpt_inst_s *cptinst,
+			  struct cpt_info_buffer *info,
+			  struct cpt_iq_command *iq_cmd);
+	int (*process_ccode)(struct pci_dev *pdev, union cpt_res_s *cpt_status,
+			     struct cpt_info_buffer *cpt_info,
+			     struct cpt_request_info *req, u32 *res_code);
+};
+
+void process_pending_queue(struct pci_dev *pdev, struct reqmgr_ops *ops,
+			   struct pending_queue *pqueue);
+int process_request(struct pci_dev *pdev, struct reqmgr_ops *ops,
+		    struct cpt_request_info *req,
+		    struct pending_queue *pqueue, void *obj);
 void dump_sg_list(struct pci_dev *pdev, struct cpt_request_info *req);
-void fill_cpt_inst(union cpt_inst_s *cptinst, struct cpt_info_buffer *info,
-		   struct cpt_iq_command *iq_cmd);
-int process_ccode(struct pci_dev *pdev, union cpt_res_s *cpt_status,
-		  struct cpt_info_buffer *cpt_info,
-		  struct cpt_request_info *req, u32 *res_code);
+
 static inline
 struct pending_entry *get_free_pending_entry(struct pending_queue *q, int qlen)
 {
@@ -298,244 +305,4 @@ static inline void do_request_cleanup(struct pci_dev *pdev,
 	kzfree(info);
 }
 
-static inline void process_pending_queue(struct pci_dev *pdev,
-					 struct pending_queue *pqueue)
-{
-	struct pending_entry *resume_pentry = NULL;
-	struct cpt_info_buffer *cpt_info = NULL;
-	void (*callback)(int, void *, void *);
-	struct pending_entry *pentry = NULL;
-	struct cpt_request_info *req = NULL;
-	union cpt_res_s *cpt_status = NULL;
-	struct crypto_async_request *areq;
-	u32 res_code, resume_index;
-
-	while (1) {
-		spin_lock_bh(&pqueue->lock);
-		pentry = &pqueue->head[pqueue->front];
-
-		if (WARN_ON(!pentry)) {
-			spin_unlock_bh(&pqueue->lock);
-			break;
-		}
-
-		res_code = -EINVAL;
-		if (unlikely(!pentry->busy)) {
-			spin_unlock_bh(&pqueue->lock);
-			break;
-		}
-
-		if (unlikely(!pentry->callback) ||
-		    unlikely(!pentry->areq)) {
-			dev_err(&pdev->dev, "Callback or callback arg NULL\n");
-			goto process_pentry;
-		}
-
-		cpt_info = (struct cpt_info_buffer *) pentry->post_arg;
-		if (unlikely(!cpt_info)) {
-			dev_err(&pdev->dev, "Pending entry post arg NULL\n");
-			goto process_pentry;
-		}
-
-		req = cpt_info->req;
-		if (unlikely(!req)) {
-			dev_err(&pdev->dev, "Request NULL\n");
-			goto process_pentry;
-		}
-
-		cpt_status = (union cpt_res_s *) pentry->completion_addr;
-		if (unlikely(!cpt_status)) {
-			dev_err(&pdev->dev, "Completion address NULL\n");
-			goto process_pentry;
-		}
-
-		/* Process completion code */
-		if (process_ccode(pdev, cpt_status, cpt_info, req,
-				  &res_code)) {
-			spin_unlock_bh(&pqueue->lock);
-			return;
-		}
-
-process_pentry:
-		/*
-		 * Check if we should inform sending side to resume
-		 * We do it CPT_IQ_RESUME_MARGIN elements in advance before
-		 * pending queue becomes empty
-		 */
-		resume_index = modulo_inc(pqueue->front, pqueue->qlen,
-					  CPT_IQ_RESUME_MARGIN);
-		resume_pentry = &pqueue->head[resume_index];
-		if (resume_pentry &&
-		    resume_pentry->resume_sender) {
-			resume_pentry->resume_sender = false;
-			callback = resume_pentry->callback;
-			areq = resume_pentry->areq;
-
-			if (callback && areq) {
-				spin_unlock_bh(&pqueue->lock);
-
-				/*
-				 * EINPROGRESS is an indication for sending
-				 * side that it can resume sending requests
-				 */
-				callback(-EINPROGRESS, areq, req);
-				spin_lock_bh(&pqueue->lock);
-			}
-		}
-
-		callback = pentry->callback;
-		areq = pentry->areq;
-		free_pentry(pentry);
-
-		pqueue->pending_count--;
-		pqueue->front = modulo_inc(pqueue->front, pqueue->qlen, 1);
-		spin_unlock_bh(&pqueue->lock);
-
-		/*
-		 * Call callback after current pending entry has been been
-		 * processed we don't do it if the callback pointer or
-		 * argument pointer is invalid
-		 */
-		if (callback && areq)
-			callback(res_code, areq, req);
-
-		if (cpt_info)
-			do_request_cleanup(pdev, cpt_info);
-	}
-}
-
-static inline int process_request(struct pci_dev *pdev,
-				  struct cpt_request_info *req,
-				  struct pending_queue *pqueue,
-				  void *obj)
-{
-	struct cptvf_request *cpt_req = &req->req;
-	struct cpt_info_buffer *info = NULL;
-	struct pending_entry *pentry = NULL;
-	union ctrl_info *ctrl = &req->ctrl;
-	union cpt_res_s *result = NULL;
-	struct cpt_iq_command iq_cmd;
-	union cpt_inst_s cptinst;
-	int retry, ret = 0;
-	u8 resume_sender;
-	gfp_t gfp;
-
-	gfp = (req->areq->flags & CRYPTO_TFM_REQ_MAY_SLEEP) ? GFP_KERNEL :
-							      GFP_ATOMIC;
-	info = kzalloc(sizeof(*info), gfp);
-	if (unlikely(!info)) {
-		dev_err(&pdev->dev, "Memory allocation failed\n");
-		return -ENOMEM;
-	}
-
-	ret = setup_sgio_list(pdev, info, req, gfp);
-	if (unlikely(ret)) {
-		dev_err(&pdev->dev, "Setting up SG list failed");
-		goto request_cleanup;
-	}
-	cpt_req->dlen = info->dlen;
-
-	/*
-	 * Get buffer for union cpt_res_s response
-	 * structure and its physical address
-	 */
-	info->completion_addr = kzalloc(sizeof(union cpt_res_s), gfp);
-	if (unlikely(!info->completion_addr)) {
-		dev_err(&pdev->dev, "memory allocation failed\n");
-		goto request_cleanup;
-	}
-
-	result = (union cpt_res_s *) info->completion_addr;
-	result->s9x.compcode = COMPLETION_CODE_INIT;
-	info->comp_baddr = dma_map_single(&pdev->dev,
-					  (void *) info->completion_addr,
-					  sizeof(union cpt_res_s),
-					  DMA_BIDIRECTIONAL);
-	if (unlikely(dma_mapping_error(&pdev->dev, info->comp_baddr))) {
-		dev_err(&pdev->dev, "Dma mapping failed\n");
-		ret = -EFAULT;
-		goto request_cleanup;
-	}
-
-	spin_lock_bh(&pqueue->lock);
-	pentry = get_free_pending_entry(pqueue, pqueue->qlen);
-	retry = CPT_PENTRY_TIMEOUT / CPT_PENTRY_STEP;
-	while (unlikely(!pentry) && retry--) {
-		spin_unlock_bh(&pqueue->lock);
-		udelay(CPT_PENTRY_STEP);
-		spin_lock_bh(&pqueue->lock);
-		pentry = get_free_pending_entry(pqueue, pqueue->qlen);
-	}
-
-	if (unlikely(!pentry)) {
-		ret = -ENOSPC;
-		spin_unlock_bh(&pqueue->lock);
-		goto request_cleanup;
-	}
-
-	/*
-	 * Check if we are close to filling in entire pending queue,
-	 * if so then tell the sender to stop/sleep by returning -EBUSY
-	 * We do it only for context which can sleep (GFP_KERNEL)
-	 */
-	if (gfp == GFP_KERNEL &&
-	    pqueue->pending_count > (pqueue->qlen - CPT_IQ_STOP_MARGIN)) {
-		pentry->resume_sender = true;
-	}
-	else
-		pentry->resume_sender = false;
-	resume_sender = pentry->resume_sender;
-	pqueue->pending_count++;
-
-	pentry->completion_addr = info->completion_addr;
-	pentry->post_arg = (void *) info;
-	pentry->callback = req->callback;
-	pentry->areq = req->areq;
-	pentry->busy = true;
-	info->pentry = pentry;
-	info->time_in = jiffies;
-	info->req = req;
-	spin_unlock_bh(&pqueue->lock);
-
-	/* Fill in the command */
-	iq_cmd.cmd.u64 = 0;
-	iq_cmd.cmd.s.opcode = cpu_to_be16(cpt_req->opcode.flags);
-	iq_cmd.cmd.s.param1 = cpu_to_be16(cpt_req->param1);
-	iq_cmd.cmd.s.param2 = cpu_to_be16(cpt_req->param2);
-	iq_cmd.cmd.s.dlen   = cpu_to_be16(cpt_req->dlen);
-
-	/* 64-bit swap for microcode data reads, not needed for addresses*/
-	iq_cmd.cmd.u64 = cpu_to_be64(iq_cmd.cmd.u64);
-	iq_cmd.dptr = info->dptr_baddr;
-	iq_cmd.rptr = info->rptr_baddr;
-	iq_cmd.cptr.u64 = 0;
-	iq_cmd.cptr.s.grp = ctrl->s.grp;
-
-	/* Fill in the CPT_INST_S type command for HW interpretation */
-	fill_cpt_inst(&cptinst, info, &iq_cmd);
-
-	/* Print debug info if enabled */
-	if (cpt_is_dbg_level_en(CPT_DBG_ENC_DEC_REQS)) {
-		dump_sg_list(pdev, req);
-		dev_info(&pdev->dev, "Cpt_inst_s hexdump (%d bytes)\n",
-			 CPT_INST_SIZE);
-		print_hex_dump(KERN_INFO, "", 0, 16, 1, &cptinst,
-			       CPT_INST_SIZE, false);
-		dev_info(&pdev->dev, "Dptr hexdump (%d bytes)\n",
-			 cpt_req->dlen);
-		print_hex_dump(KERN_INFO, "", 0, 16, 1, info->in_buffer,
-			       cpt_req->dlen, false);
-	}
-
-	/* Send CPT command */
-	send_cpt_cmd(&cptinst, 1, obj);
-
-	ret = resume_sender ? -EBUSY : -EINPROGRESS;
-	return ret;
-
-request_cleanup:
-	do_request_cleanup(pdev, info);
-	return ret;
-}
-
 #endif /* __CPT_REQUEST_MANAGER_H */
diff --git a/drivers/crypto/cavium/cpt/common/cpt_ucode.c b/drivers/crypto/cavium/cpt/common/cpt_ucode.c
index 1d4869afb92c..d5d7303bfa87 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_ucode.c
+++ b/drivers/crypto/cavium/cpt/common/cpt_ucode.c
@@ -1,6 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Marvell OcteonTx2 RVU Admin Function driver
- *
+/*
  * Copyright (C) 2018 Marvell International Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -12,6 +11,9 @@
 #include <linux/firmware.h>
 #include "cpt_ucode.h"
 
+#define DRV_NAME	"cpt-common"
+#define DRV_VERSION	"1.0"
+
 static int is_eng_type(int val, int eng_type)
 {
 	return val & (1 << eng_type);
@@ -372,6 +374,7 @@ int cpt_uc_supports_eng_type(struct microcode *ucode, int eng_type)
 {
 	return is_eng_type(ucode->type, eng_type);
 }
+EXPORT_SYMBOL_GPL(cpt_uc_supports_eng_type);
 
 int cpt_eng_grp_has_eng_type(struct engine_group_info *eng_grp, int eng_type)
 {
@@ -381,6 +384,7 @@ int cpt_eng_grp_has_eng_type(struct engine_group_info *eng_grp, int eng_type)
 
 	return (engs != NULL ? 1 : 0);
 }
+EXPORT_SYMBOL_GPL(cpt_eng_grp_has_eng_type);
 
 static void print_ucode_info(struct engine_group_info *eng_grp,
 			     char *buf, int size)
@@ -515,9 +519,9 @@ static void print_dbg_info(struct device *dev,
 			} else
 				dev_info(dev, "Slot%d not used", j);
 		}
-		if (grp->is_enabled) {
-			cpt_print_engines_mask(grp, eng_grps->obj, engs_mask,
-					       NAME_LENGTH);
+		if (grp->is_enabled && eng_grps->ops.print_engines_mask) {
+			eng_grps->ops.print_engines_mask(grp, eng_grps->obj,
+						engs_mask, NAME_LENGTH);
 			dev_info(dev, "Cmask: %s", engs_mask);
 		}
 		dev_info(dev, "\n");
@@ -708,15 +712,15 @@ static ssize_t eng_grp_info_show(struct device *dev,
 
 	print_engs_info(eng_grp, engs_info, 2*NAME_LENGTH, -1);
 	print_ucode_info(eng_grp, ucode_info, 2*NAME_LENGTH);
-	cpt_print_engines_mask(eng_grp, eng_grp->g, engs_mask, NAME_LENGTH);
+	if (eng_grp->g->ops.print_engines_mask)
+		eng_grp->g->ops.print_engines_mask(eng_grp, eng_grp->g,
+						   engs_mask, NAME_LENGTH);
 	ret = scnprintf(buf, PAGE_SIZE,
 			"Microcode : %s\nEngines: %s\nEngines mask: %s\n",
 			ucode_info, engs_info, engs_mask);
 
 	mutex_unlock(&eng_grp->g->lock);
 	return ret;
-
-	return 0;
 }
 
 static int create_sysfs_eng_grps_info(struct device *dev,
@@ -828,12 +832,16 @@ static int enable_eng_grp(struct engine_group_info *eng_grp,
 	int ret = 0;
 
 	/* Point microcode to each core of the group */
-	ret = cpt_set_ucode_base(eng_grp, obj);
+	if (!eng_grp->g->ops.set_ucode_base)
+		return -EPERM;
+	ret = eng_grp->g->ops.set_ucode_base(eng_grp, obj);
 	if (ret)
 		goto err;
 
 	/* Attach the cores to the group and enable them */
-	ret = cpt_attach_and_enable_cores(eng_grp, obj);
+	if (!eng_grp->g->ops.attach_and_enable_cores)
+		return -EPERM;
+	ret = eng_grp->g->ops.attach_and_enable_cores(eng_grp, obj);
 	if (ret)
 		goto err;
 err:
@@ -847,7 +855,9 @@ static int disable_eng_grp(struct device *dev,
 	int i, ret = 0;
 
 	/* Disable all engines used by this group */
-	ret = cpt_detach_and_disable_cores(eng_grp, obj);
+	if (!eng_grp->g->ops.detach_and_disable_cores)
+		return -EPERM;
+	ret = eng_grp->g->ops.detach_and_disable_cores(eng_grp, obj);
 	if (ret)
 		goto err;
 
@@ -863,7 +873,9 @@ static int disable_eng_grp(struct device *dev,
 	}
 
 	/* Clear UCODE_BASE register for each engine used by this group */
-	ret = cpt_set_ucode_base(eng_grp, obj);
+	if (!eng_grp->g->ops.set_ucode_base)
+		return -EPERM;
+	ret = eng_grp->g->ops.set_ucode_base(eng_grp, obj);
 	if (ret)
 		goto err;
 err:
@@ -1076,8 +1088,8 @@ static int delete_engine_group(struct device *dev,
 
 	device_remove_file(dev, &eng_grp->info_attr);
 	eng_grp->is_enabled = false;
-	if (eng_grp->g->plat_hndlr)
-		eng_grp->g->plat_hndlr(eng_grp->g->obj);
+	if (eng_grp->g->ops.notify_group_change)
+		eng_grp->g->ops.notify_group_change(eng_grp->g->obj);
 err:
 	return ret;
 }
@@ -1285,8 +1297,8 @@ static int create_engine_group(struct device *dev,
 		dev_info(dev, "Engine_group%d: microcode loaded %s",
 			 eng_grp->idx, eng_grp->ucode[1].ver_str);
 
-	if (eng_grps->plat_hndlr)
-		eng_grps->plat_hndlr(eng_grps->obj);
+	if (eng_grps->ops.notify_group_change)
+		eng_grps->ops.notify_group_change(eng_grps->obj);
 	return 0;
 
 err_release_engs:
@@ -1466,6 +1478,32 @@ static ssize_t ucode_load_store(struct device *dev,
 	return ret;
 }
 
+static int cpt_set_ucode_ops(struct engine_groups *eng_grps,
+			     struct ucode_ops *uc_ops)
+{
+	if (!uc_ops)
+		return -EINVAL;
+
+	/* notify_group_change is not mandatory */
+	if (!uc_ops->detach_and_disable_cores ||
+	    !uc_ops->attach_and_enable_cores ||
+	    !uc_ops->set_ucode_base ||
+	    !uc_ops->print_engines_mask)
+		return -EPERM;
+
+	eng_grps->ops = *uc_ops;
+	return 0;
+}
+
+static void cpt_clear_ucode_ops(struct engine_groups *eng_grps)
+{
+	eng_grps->ops.detach_and_disable_cores = NULL;
+	eng_grps->ops.attach_and_enable_cores = NULL;
+	eng_grps->ops.set_ucode_base = NULL;
+	eng_grps->ops.print_engines_mask = NULL;
+	eng_grps->ops.notify_group_change = NULL;
+}
+
 int cpt_try_create_default_eng_grps(struct pci_dev *pdev,
 				    struct engine_groups *eng_grps,
 				    int pf_type)
@@ -1571,16 +1609,7 @@ int cpt_try_create_default_eng_grps(struct pci_dev *pdev,
 	mutex_unlock(&eng_grps->lock);
 	return ret;
 }
-
-void cpt_set_eng_grps_plat_hndlr(struct engine_groups *eng_grps,
-				 void (*plat_hndlr)(void *obj))
-{
-	mutex_lock(&eng_grps->lock);
-
-	eng_grps->plat_hndlr = plat_hndlr;
-
-	mutex_unlock(&eng_grps->lock);
-}
+EXPORT_SYMBOL_GPL(cpt_try_create_default_eng_grps);
 
 void cpt_set_eng_grps_is_rdonly(struct engine_groups *eng_grps, bool is_rdonly)
 {
@@ -1590,6 +1619,7 @@ void cpt_set_eng_grps_is_rdonly(struct engine_groups *eng_grps, bool is_rdonly)
 
 	mutex_unlock(&eng_grps->lock);
 }
+EXPORT_SYMBOL_GPL(cpt_set_eng_grps_is_rdonly);
 
 void cpt_cleanup_eng_grps(struct pci_dev *pdev,
 			  struct engine_groups *eng_grps)
@@ -1622,11 +1652,13 @@ void cpt_cleanup_eng_grps(struct pci_dev *pdev,
 		}
 	}
 
+	cpt_clear_ucode_ops(eng_grps);
 	mutex_unlock(&eng_grps->lock);
 }
+EXPORT_SYMBOL_GPL(cpt_cleanup_eng_grps);
 
 int cpt_init_eng_grps(struct pci_dev *pdev, struct engine_groups *eng_grps,
-		      int pf_type)
+		      struct ucode_ops ops, int pf_type)
 {
 	struct engine_group_info *grp;
 	int i, j, ret = 0;
@@ -1694,6 +1726,10 @@ int cpt_init_eng_grps(struct pci_dev *pdev, struct engine_groups *eng_grps,
 		goto err;
 	}
 
+	ret = cpt_set_ucode_ops(eng_grps, &ops);
+	if (ret)
+		goto err;
+
 	eng_grps->ucode_load_attr.show = NULL;
 	eng_grps->ucode_load_attr.store = ucode_load_store;
 	eng_grps->ucode_load_attr.attr.name = "ucode_load";
@@ -1712,3 +1748,9 @@ int cpt_init_eng_grps(struct pci_dev *pdev, struct engine_groups *eng_grps,
 	cpt_cleanup_eng_grps(pdev, eng_grps);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(cpt_init_eng_grps);
+
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_DESCRIPTION("Marvell CPT common layer");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/crypto/cavium/cpt/common/cpt_ucode.h b/drivers/crypto/cavium/cpt/common/cpt_ucode.h
index 38e4da86ed4f..1b9de07a735f 100644
--- a/drivers/crypto/cavium/cpt/common/cpt_ucode.h
+++ b/drivers/crypto/cavium/cpt/common/cpt_ucode.h
@@ -190,12 +190,23 @@ struct engine_group_info {
 			  */
 };
 
+struct ucode_ops {
+	int (*detach_and_disable_cores)(struct engine_group_info *eng_grp,
+					void *obj);
+	int (*attach_and_enable_cores)(struct engine_group_info *eng_grp,
+				       void *obj);
+	int (*set_ucode_base)(struct engine_group_info *eng_grp, void *obj);
+	void (*print_engines_mask)(struct engine_group_info *eng_grp,
+				   void *obj, char *buf, int size);
+	void (*notify_group_change)(void *obj);
+};
+
 struct engine_groups {
 	struct engine_group_info grp[CPT_MAX_ENGINE_GROUPS];
 	struct device_attribute ucode_load_attr;	/* ucode load attr */
 	struct engines_available avail;
 	struct mutex lock;
-	void (*plat_hndlr)(void *obj);	/* 8x/9x hndlr for create/delete grp */
+	struct ucode_ops ops;		/* 8x/9x microcode operations */
 	void *obj;			/* 8x/9x platform specific data */
 	int engs_num;			/* total number of engines supported */
 	int eng_types_supported;	/* engine types supported SE, IE, AE */
@@ -206,20 +217,14 @@ struct engine_groups {
 };
 
 int cpt_init_eng_grps(struct pci_dev *pdev, struct engine_groups *eng_grps,
-		      int pf_type);
+		      struct ucode_ops ops, int pf_type);
 void cpt_cleanup_eng_grps(struct pci_dev *pdev,
 			  struct engine_groups *eng_grps);
 int cpt_try_create_default_eng_grps(struct pci_dev *pdev,
 				    struct engine_groups *eng_grps,
 				    int pf_type);
-int cpt_detach_and_disable_cores(struct engine_group_info *eng_grp, void *obj);
-int cpt_set_ucode_base(struct engine_group_info *eng_grp, void *obj);
-int cpt_attach_and_enable_cores(struct engine_group_info *eng_grp, void *obj);
-void cpt_print_engines_mask(struct engine_group_info *eng_grp, void *obj,
-			    char *buf, int size);
 void cpt_set_eng_grps_is_rdonly(struct engine_groups *eng_grps, bool is_rdonly);
 int cpt_uc_supports_eng_type(struct microcode *ucode, int eng_type);
 int cpt_eng_grp_has_eng_type(struct engine_group_info *eng_grp, int eng_type);
-void cpt_set_eng_grps_plat_hndlr(struct engine_groups *eng_grps,
-				 void (*plat_hdnlr)(void *obj));
+
 #endif /* __CPT_UCODE_H */
-- 
2.17.1


From ff8020b9ebe06d9af49826f1e0b32630c139350f Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@nxp.com>
Date: Tue, 27 Aug 2019 15:16:56 +0300
Subject: [PATCH 122/245] drivers: net: phy: aquantia: enable AQR112 and AQR412

commit b5439297bbf60d0db85290cc3805b1741ff16bbe from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux.git

Adds support for AQR112 and AQR412 which is mostly based on existing code
with the addition of code configuring the protocol on system side.
This allows changing the system side protocol without having to deploy a
different firmware on the PHY.

Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/phy/aquantia.c | 96 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 96 insertions(+)

diff --git a/drivers/net/phy/aquantia.c b/drivers/net/phy/aquantia.c
index e0b13d91f959..4a7cbe2a9ce5 100644
--- a/drivers/net/phy/aquantia.c
+++ b/drivers/net/phy/aquantia.c
@@ -25,6 +25,8 @@
 #define PHY_ID_AQR106	0x03a1b4d0
 #define PHY_ID_AQR107	0x03a1b4e0
 #define PHY_ID_AQR405	0x03a1b4b0
+#define PHY_ID_AQR112	0x03a1b662
+#define PHY_ID_AQR412	0x03a1b712
 
 #define PHY_AQUANTIA_FEATURES	(SUPPORTED_10000baseT_Full | \
 				 SUPPORTED_1000baseT_Full | \
@@ -42,6 +44,29 @@
 #define MDIO_AN_VENDOR_PROV_CTRL       0xc400
 #define MDIO_AN_RECV_LP_STATUS         0xe820
 
+/* registers in MDIO_MMD_VEND1 region */
+#define AQUANTIA_VND1_GLOBAL_SC			0x000
+#define  AQUANTIA_VND1_GLOBAL_SC_LP		BIT(0xb)
+
+/* global start rate, the protocol associated with this speed is used by default
+ * on SI.
+ */
+#define AQUANTIA_VND1_GSTART_RATE		0x31a
+#define  AQUANTIA_VND1_GSTART_RATE_OFF		0
+#define  AQUANTIA_VND1_GSTART_RATE_100M		1
+#define  AQUANTIA_VND1_GSTART_RATE_1G		2
+#define  AQUANTIA_VND1_GSTART_RATE_10G		3
+#define  AQUANTIA_VND1_GSTART_RATE_2_5G		4
+#define  AQUANTIA_VND1_GSTART_RATE_5G		5
+
+/* SYSCFG registers for 100M, 1G, 2.5G, 5G, 10G */
+#define AQUANTIA_VND1_GSYSCFG_BASE		0x31b
+#define AQUANTIA_VND1_GSYSCFG_100M		0
+#define AQUANTIA_VND1_GSYSCFG_1G		1
+#define AQUANTIA_VND1_GSYSCFG_2_5G		2
+#define AQUANTIA_VND1_GSYSCFG_5G		3
+#define AQUANTIA_VND1_GSYSCFG_10G		4
+
 static int aquantia_write_reg(struct phy_device *phydev, int devad,
 			      u32 regnum, u16 val)
 {
@@ -198,6 +223,51 @@ static int aquantia_config_aneg(struct phy_device *phydev)
 	return ret;
 }
 
+static struct {
+        u16 syscfg;
+        int cnt;
+        u16 start_rate;
+} aquantia_syscfg[PHY_INTERFACE_MODE_MAX] = {
+        [PHY_INTERFACE_MODE_SGMII] =      {0x04b, AQUANTIA_VND1_GSYSCFG_1G,
+                                           AQUANTIA_VND1_GSTART_RATE_1G},
+        [PHY_INTERFACE_MODE_2500BASEX] = {0x144, AQUANTIA_VND1_GSYSCFG_2_5G,
+                                           AQUANTIA_VND1_GSTART_RATE_2_5G},
+        [PHY_INTERFACE_MODE_XGMII] =      {0x100, AQUANTIA_VND1_GSYSCFG_10G,
+                                          AQUANTIA_VND1_GSTART_RATE_10G},
+        [PHY_INTERFACE_MODE_USXGMII] =    {0x080, AQUANTIA_VND1_GSYSCFG_10G,
+                                          AQUANTIA_VND1_GSTART_RATE_10G},
+};
+
+/* Sets up protocol on system side before calling aqr_config_aneg */
+static int aquantia_config_aneg_set_prot(struct phy_device *phydev)
+{
+        int if_type = phydev->interface;
+        int i;
+
+        if (!aquantia_syscfg[if_type].cnt)
+                return 0;
+
+        /* set PHY in low power mode so we can configure protocols */
+        phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC,
+                      AQUANTIA_VND1_GLOBAL_SC_LP);
+        mdelay(10);
+
+        /* set the default rate to enable the SI link */
+        phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GSTART_RATE,
+                      aquantia_syscfg[if_type].start_rate);
+
+        for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++)
+                phy_write_mmd(phydev, MDIO_MMD_VEND1,
+                              AQUANTIA_VND1_GSYSCFG_BASE + i,
+                              aquantia_syscfg[if_type].syscfg);
+
+        /* wake PHY back up */
+        phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC, 0);
+        mdelay(10);
+
+        return aquantia_config_aneg(phydev);
+}
+
 static int aquantia_config_intr(struct phy_device *phydev)
 {
 	int err;
@@ -431,6 +501,30 @@ static struct phy_driver aquantia_driver[] = {
 	.ack_interrupt	= aquantia_ack_interrupt,
 	.read_status	= aquantia_read_status,
 },
+{
+	.phy_id		= PHY_ID_AQR112,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "Aquantia AQR112",
+	.features	= PHY_AQUANTIA_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.aneg_done	= genphy_c45_aneg_done,
+	.config_aneg    = aquantia_config_aneg_set_prot,
+	.config_intr	= aquantia_config_intr,
+	.ack_interrupt	= aquantia_ack_interrupt,
+	.read_status	= aquantia_read_status,
+},
+{
+	.phy_id		= PHY_ID_AQR412,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "Aquantia AQR412",
+	.features	= PHY_AQUANTIA_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.aneg_done	= genphy_c45_aneg_done,
+	.config_aneg    = aquantia_config_aneg_set_prot,
+	.config_intr	= aquantia_config_intr,
+	.ack_interrupt	= aquantia_ack_interrupt,
+	.read_status	= aquantia_read_status,
+},
 };
 
 module_phy_driver(aquantia_driver);
@@ -442,6 +536,8 @@ static struct mdio_device_id __maybe_unused aquantia_tbl[] = {
 	{ PHY_ID_AQR106, 0xfffffff0 },
 	{ PHY_ID_AQR107, 0xfffffff0 },
 	{ PHY_ID_AQR405, 0xfffffff0 },
+	{ PHY_ID_AQR112, 0xfffffff0 },
+	{ PHY_ID_AQR412, 0xfffffff0 },
 	{ }
 };
 
-- 
2.17.1


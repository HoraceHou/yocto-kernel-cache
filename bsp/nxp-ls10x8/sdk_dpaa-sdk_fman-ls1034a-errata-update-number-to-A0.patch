From 6aa7a081b55d00c57af5fc18e14302913cfc2192 Mon Sep 17 00:00:00 2001
From: Camelia Groza <camelia.groza@nxp.com>
Date: Fri, 13 Dec 2019 14:49:16 +0200
Subject: [PATCH 24/30] sdk_dpaa: sdk_fman: ls1034a errata: update number to
 A050385

commit ec629de99f2dd81a0700755e0a695a696190a7bb from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux

The A050385 erratum extends the A010022 erratum by defining additional
FMan lock-up conditions and suggests new w/a restrictions.

Signed-off-by: Camelia Groza <camelia.groza@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../ethernet/freescale/sdk_dpaa/dpaa_eth.h    | 13 +++---
 .../ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c | 42 +++++++++----------
 .../LS1043/dpaa_integration_ext.h             |  2 +-
 .../src/inc/wrapper/lnxwrp_fsl_fman.h         |  8 ++--
 .../sdk_fman/src/wrapper/lnxwrp_fm.c          | 16 +++----
 5 files changed, 41 insertions(+), 40 deletions(-)

diff --git a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth.h b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth.h
index 9534ccf3e310..d501ae25a688 100644
--- a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth.h
@@ -99,15 +99,15 @@ struct dpa_buffer_layout_s {
  * space to account for further alignments.
  */
 #define DPA_MAX_FRM_SIZE	9600
-#ifndef FM_ERRATUM_A010022
+#ifndef FM_ERRATUM_A050385
 #define DPA_BP_RAW_SIZE \
 	((DPA_MAX_FRM_SIZE + DPA_MAX_FD_OFFSET + \
 	  sizeof(struct skb_shared_info) + 128) & ~(SMP_CACHE_BYTES - 1))
-#else /* FM_ERRATUM_A010022 */
-#define DPA_BP_RAW_SIZE ((unlikely(fm_has_errata_a010022())) ? 2048 : \
+#else /* FM_ERRATUM_A050385 */
+#define DPA_BP_RAW_SIZE ((unlikely(fm_has_errata_a050385())) ? 2048 : \
 	((DPA_MAX_FRM_SIZE + DPA_MAX_FD_OFFSET + \
 	  sizeof(struct skb_shared_info) + 128) & ~(SMP_CACHE_BYTES - 1)))
-#endif /* FM_ERRATUM_A010022 */
+#endif /* FM_ERRATUM_A050385 */
 #endif /* CONFIG_FSL_DPAA_ETH_JUMBO_FRAME */
 
 /* This is what FMan is ever allowed to use.
@@ -660,10 +660,11 @@ static inline void _dpa_bp_free_pf(void *addr)
  * on egress.
  */
 
-#ifdef FM_ERRATUM_A010022
+#ifdef FM_ERRATUM_A050385 
 #define CROSS_4K(start, size) \
 	(((uintptr_t)(start) + (size)) > \
 	 (((uintptr_t)(start) + 0x1000) & ~0xFFF))
-#endif  /* FM_ERRATUM_A010022 */
+#define DPAA_A050385_HEADROOM  256
+#endif  /* FM_ERRATUM_A050385 */
 
 #endif	/* __DPA_H */
diff --git a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c
index 47c15760fc3f..02114c175535 100644
--- a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c
@@ -102,8 +102,8 @@ static int _dpa_bp_add_8_bufs(const struct dpa_bp *dpa_bp)
 		 * We only need enough space to store a pointer, but allocate
 		 * an entire cacheline for performance reasons.
 		 */
-#ifdef FM_ERRATUM_A010022
-		if (unlikely(fm_has_errata_a010022())) {
+#ifdef FM_ERRATUM_A050385
+		if (unlikely(fm_has_errata_a050385())) {
 			struct page *new_page = alloc_page(GFP_ATOMIC);
 			if (unlikely(!new_page))
 				goto netdev_alloc_failed;
@@ -775,15 +775,15 @@ int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 }
 EXPORT_SYMBOL(skb_to_contig_fd);
 
-#ifdef FM_ERRATUM_A010022
-/* Verify the conditions that trigger the A010022 errata:
+#ifdef FM_ERRATUM_A050385
+/* Verify the conditions that trigger the A050385 errata:
  * - 4K memory address boundary crossings when the data/SG fragments aren't
  *   aligned to 256 bytes
  * - data and SG fragments that aren't aligned to 16 bytes
  * - SG fragments that aren't mod 16 bytes in size (except for the last
  *   fragment)
  */
-static bool a010022_check_skb(struct sk_buff *skb, struct dpa_priv_s *priv)
+static bool a050385_check_skb(struct sk_buff *skb, struct dpa_priv_s *priv)
 {
 	skb_frag_t *frag;
 	int i, nr_frags;
@@ -850,7 +850,7 @@ static bool a010022_check_skb(struct sk_buff *skb, struct dpa_priv_s *priv)
  * page. Build a new skb around the new buffer and release the old one.
  * A performance drop should be expected.
  */
-static struct sk_buff *a010022_realign_skb(struct sk_buff *skb,
+static struct sk_buff *a050385_realign_skb(struct sk_buff *skb,
 					   struct dpa_priv_s *priv)
 {
 	int trans_offset = skb_transport_offset(skb);
@@ -953,8 +953,8 @@ int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	/* Get a page frag to store the SGTable, or a full page if the errata
 	 * is in place and we need to avoid crossing a 4k boundary.
 	 */
-#ifdef FM_ERRATUM_A010022
-	if (unlikely(fm_has_errata_a010022())) {
+#ifdef FM_ERRATUM_A050385
+	if (unlikely(fm_has_errata_a050385())) {
 		struct page *new_page = alloc_page(GFP_ATOMIC);
 
 		if (unlikely(!new_page))
@@ -1111,9 +1111,9 @@ int __hot dpa_tx_extended(struct sk_buff *skb, struct net_device *net_dev,
 	int *countptr, offset = 0;
 	struct sk_buff *nskb;
 
-	/* Flags to help optimize the A010022 errata restriction checks.
+	/* Flags to help optimize the A050385 errata restriction checks.
 	 *
-	 * First flag marks if the skb changed between the first A010022 check
+	 * First flag marks if the skb changed between the first A050385 check
 	 * and the moment it's converted to an FD.
 	 *
 	 * The second flag marks if the skb needs to be realigned in order to
@@ -1133,8 +1133,8 @@ int __hot dpa_tx_extended(struct sk_buff *skb, struct net_device *net_dev,
 
 	clear_fd(&fd);
 
-#ifdef FM_ERRATUM_A010022
-	if (unlikely(fm_has_errata_a010022()) && a010022_check_skb(skb, priv))
+#ifdef FM_ERRATUM_A050385
+	if (unlikely(fm_has_errata_a050385()) && a050385_check_skb(skb, priv))
 		skb_need_wa = true;
 #endif
 
@@ -1188,7 +1188,7 @@ int __hot dpa_tx_extended(struct sk_buff *skb, struct net_device *net_dev,
 		/* We're going to store the skb backpointer at the beginning
 		 * of the data buffer, so we need a privately owned skb
 		 *
-		 * Under the A010022 errata, we are going to have a privately
+		 * Under the A050385 errata, we are going to have a privately
 		 * owned skb after realigning the current one, so no point in
 		 * copying it here in that case.
 		 */
@@ -1206,12 +1206,12 @@ int __hot dpa_tx_extended(struct sk_buff *skb, struct net_device *net_dev,
 			 * more fragments than we support. In this case,
 			 * we have no choice but to linearize it ourselves.
 			 */
-#ifdef FM_ERRATUM_A010022
+#ifdef FM_ERRATUM_A050385
 			/* No point in linearizing the skb now if we are going
 			 * to realign and linearize it again further down due
-			 * to the A010022 errata
+			 * to the A050385 errata
 			 */
-			if (unlikely(fm_has_errata_a010022()))
+			if (unlikely(fm_has_errata_a050385()))
 				skb_need_wa = true;
 			else
 #endif
@@ -1221,16 +1221,16 @@ int __hot dpa_tx_extended(struct sk_buff *skb, struct net_device *net_dev,
 			/* Common out-of-memory error path */
 			goto enomem;
 
-#ifdef FM_ERRATUM_A010022
+#ifdef FM_ERRATUM_A050385
 		/* Verify the skb a second time if it has been updated since
 		 * the previous check
 		 */
-		if (unlikely(fm_has_errata_a010022()) && skb_changed &&
-		    a010022_check_skb(skb, priv))
+		if (unlikely(fm_has_errata_a050385()) && skb_changed &&
+		    a050385_check_skb(skb, priv))
 			skb_need_wa = true;
 
-		if (unlikely(fm_has_errata_a010022()) && skb_need_wa) {
-			nskb = a010022_realign_skb(skb, priv);
+		if (unlikely(fm_has_errata_a050385()) && skb_need_wa) {
+			nskb = a050385_realign_skb(skb, priv);
 			if (!nskb)
 				goto skb_to_fd_failed;
 			dev_kfree_skb(skb);
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h
index ea14bb96209b..2ef81d5c7c70 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h
@@ -271,7 +271,7 @@ typedef enum
 #define FM_AID_MODE_NO_TNUM_SW005 /* refer to pdm TKT068794 - only support of port_id on aid */
 #define FM_ERROR_VSP_NO_MATCH_SW006 /* refer to pdm TKT174304 - no match between errorQ and VSP */
 
-#define FM_ERRATUM_A010022
+#define FM_ERRATUM_A050385
 
 /*****************************************************************************
  RMan INTEGRATION-SPECIFIC DEFINITIONS
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h
index 9325a2f3470f..b0c151ffb628 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -490,12 +490,12 @@ int fm_get_max_frm(void);
 int fm_get_rx_extra_headroom(void);
 
 /**************************************************************************//**
- @Function	fm_has_errata_a010022
+ @Function	fm_has_errata_a050385
 
- @Description   Detect if the SoC is vulnerable to the A010022 errata
+ @Description   Detect if the SoC is vulnerable to the A050385 errata
 *//***************************************************************************/
-#ifdef FM_ERRATUM_A010022
-bool fm_has_errata_a010022(void);
+#ifdef FM_ERRATUM_A050385
+bool fm_has_errata_a050385(void);
 #endif
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
index 2f2f84841f9d..d0b79286de0b 100755
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
@@ -156,8 +156,8 @@ static int fsl_fm_pfc_quanta[] = {
 
 static t_LnxWrpFm   lnxWrpFm;
 
-#ifdef FM_ERRATUM_A010022
-static bool fm_has_err_a010022;
+#ifdef FM_ERRATUM_A050385
+static bool fm_has_err_a050385;
 #endif
 
 int fm_get_max_frm()
@@ -172,12 +172,12 @@ int fm_get_rx_extra_headroom()
 }
 EXPORT_SYMBOL(fm_get_rx_extra_headroom);
 
-#ifdef FM_ERRATUM_A010022
-bool fm_has_errata_a010022()
+#ifdef FM_ERRATUM_A050385
+bool fm_has_errata_a050385()
 {
-	return fm_has_err_a010022;
+	return fm_has_err_a050385;
 }
-EXPORT_SYMBOL(fm_has_errata_a010022);
+EXPORT_SYMBOL(fm_has_errata_a050385);
 #endif
 
 static int __init fm_set_max_frm(char *str)
@@ -758,8 +758,8 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
             p_LnxWrpFmDev->defPcd = e_NO_PCD;
     }
 
-#ifdef FM_ERRATUM_A010022
-    fm_has_err_a010022 = of_property_read_bool(fm_node, "fsl,erratum-a010022");
+#ifdef FM_ERRATUM_A050385
+    fm_has_err_a050385 = of_property_read_bool(fm_node, "fsl,erratum-a050385");
 #endif
 
     of_node_put(fm_node);
-- 
2.17.1


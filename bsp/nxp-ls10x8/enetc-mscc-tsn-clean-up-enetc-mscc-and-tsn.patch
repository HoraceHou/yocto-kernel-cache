From 533e6762a76185e204e6b6a1d4319467af37cf86 Mon Sep 17 00:00:00 2001
From: Zhao Qiang <qiang.zhao@nxp.com>
Date: Tue, 24 Sep 2019 10:52:57 +0800
Subject: [PATCH 145/245] enetc: mscc: tsn: clean up enetc, mscc and tsn

commit 9a380a55d73ce533b618ba2de1eda2a5d565bb6d from
http://source.codeaurora.org/external/qoriq/qoriq-components/linux.git

Signed-off-by: Zhao Qiang <qiang.zhao@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/ethernet/freescale/enetc/Kconfig  |   54 -
 drivers/net/ethernet/freescale/enetc/Makefile |   20 -
 drivers/net/ethernet/freescale/enetc/enetc.c  | 1823 ---------
 drivers/net/ethernet/freescale/enetc/enetc.h  |  284 --
 .../net/ethernet/freescale/enetc/enetc_cbdr.c |  210 -
 .../ethernet/freescale/enetc/enetc_ethtool.c  |  631 ---
 .../net/ethernet/freescale/enetc/enetc_hw.h   | 1045 -----
 .../net/ethernet/freescale/enetc/enetc_mdio.c |  199 -
 .../net/ethernet/freescale/enetc/enetc_msg.c  |  164 -
 .../net/ethernet/freescale/enetc/enetc_pf.c   |  956 -----
 .../net/ethernet/freescale/enetc/enetc_pf.h   |   55 -
 .../net/ethernet/freescale/enetc/enetc_ptp.c  |  149 -
 .../net/ethernet/freescale/enetc/enetc_tsn.c  | 1874 ---------
 .../net/ethernet/freescale/enetc/enetc_vf.c   |  256 --
 drivers/net/ethernet/freescale/enetc_mdio.c   |   70 -
 drivers/net/ethernet/mscc/felix_board.c       |  907 -----
 drivers/net/ethernet/mscc/felix_ptp.c         |  154 -
 drivers/net/ethernet/mscc/felix_regs.c        |  607 ---
 drivers/net/ethernet/mscc/felix_tsn.c         | 1601 --------
 drivers/net/ethernet/mscc/felix_tsn.h         |   98 -
 drivers/net/ethernet/mscc/ocelot_dev.h        |  275 --
 drivers/net/ethernet/mscc/ocelot_dev_gmii.h   |  154 -
 drivers/net/ethernet/mscc/ocelot_hsio.h       |  785 ----
 drivers/net/ethernet/mscc/ocelot_io.c         |  116 -
 drivers/net/ethernet/mscc/ocelot_ptp.h        |   43 -
 drivers/net/ethernet/mscc/ocelot_qs.h         |   78 -
 drivers/net/ethernet/mscc/ocelot_qsys.h       |  270 --
 drivers/net/ethernet/mscc/ocelot_rew.h        |   81 -
 drivers/net/ethernet/mscc/ocelot_sys.h        |  144 -
 include/net/tsn.h                             |   89 -
 include/uapi/linux/tsn.h                      | 1110 ------
 net/tsn/Kconfig                               |   15 -
 net/tsn/Makefile                              |    1 -
 net/tsn/genl_tsn.c                            | 3383 -----------------
 34 files changed, 17701 deletions(-)
 delete mode 100644 drivers/net/ethernet/freescale/enetc/Kconfig
 delete mode 100644 drivers/net/ethernet/freescale/enetc/Makefile
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc.h
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_hw.h
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_mdio.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_msg.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_pf.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_pf.h
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_ptp.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_tsn.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc/enetc_vf.c
 delete mode 100644 drivers/net/ethernet/freescale/enetc_mdio.c
 delete mode 100644 drivers/net/ethernet/mscc/felix_board.c
 delete mode 100644 drivers/net/ethernet/mscc/felix_ptp.c
 delete mode 100644 drivers/net/ethernet/mscc/felix_regs.c
 delete mode 100644 drivers/net/ethernet/mscc/felix_tsn.c
 delete mode 100644 drivers/net/ethernet/mscc/felix_tsn.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_dev.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_dev_gmii.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_hsio.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_io.c
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_ptp.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_qs.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_qsys.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_rew.h
 delete mode 100644 drivers/net/ethernet/mscc/ocelot_sys.h
 delete mode 100644 include/net/tsn.h
 delete mode 100644 include/uapi/linux/tsn.h
 delete mode 100644 net/tsn/Kconfig
 delete mode 100644 net/tsn/Makefile
 delete mode 100644 net/tsn/genl_tsn.c

diff --git a/drivers/net/ethernet/freescale/enetc/Kconfig b/drivers/net/ethernet/freescale/enetc/Kconfig
deleted file mode 100644
index 6a15b8a4aa56..000000000000
--- a/drivers/net/ethernet/freescale/enetc/Kconfig
+++ /dev/null
@@ -1,54 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config FSL_ENETC
-	tristate "ENETC PF driver"
-	depends on PCI && PCI_MSI
-	---help---
-	  This driver supports NXP ENETC gigabit ethernet controller PCIe
-	  physical function (PF) devices, managing ENETC Ports at a privileged
-	  level.
-
-	  If compiled as module (M), the module name is fsl-enetc.
-
-config FSL_ENETC_VF
-	tristate "ENETC VF driver"
-	depends on PCI && PCI_MSI
-	---help---
-	  This driver supports NXP ENETC gigabit ethernet controller PCIe
-	  virtual function (VF) devices enabled by the ENETC PF driver.
-
-	  If compiled as module (M), the module name is fsl-enetc-vf.
-
-config FSL_ENETC_PTP_CLOCK
-	tristate "ENETC PTP clock driver"
-	depends on PTP_1588_CLOCK_QORIQ && (FSL_ENETC || FSL_ENETC_VF)
-	default y
-	---help---
-	  This driver adds support for using the ENETC 1588 timer
-	  as a PTP clock. This clock is only useful if your PTP
-	  programs are getting hardware time stamps on the PTP Ethernet
-	  packets using the SO_TIMESTAMPING API.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called fsl-enetc-ptp.
-
-config FSL_ENETC_HW_TIMESTAMPING
-	bool "ENETC hardware timestamping support"
-	depends on FSL_ENETC || FSL_ENETC_VF
-	---help---
-	  Enable hardware timestamping support on the Ethernet packets
-	  using the SO_TIMESTAMPING API. Because the RX BD ring dynamic
-	  allocation hasn't been supported and it's too expensive to use
-	  extended RX BDs if timestamping isn't used, the option was used
-	  to control hardware timestamping/extended RX BDs to be enabled
-	  or not.
-
-if FSL_ENETC
-
-config ENETC_TSN
-	bool "TSN Support for NXP ENETC driver"
-	default n
-	depends on TSN
-	select NET_SCH_MQPRIO
-	---help---
-	  This driver supports TSN on Freescale ENETC driver.
-endif
diff --git a/drivers/net/ethernet/freescale/enetc/Makefile b/drivers/net/ethernet/freescale/enetc/Makefile
deleted file mode 100644
index 9fefb27bd56c..000000000000
--- a/drivers/net/ethernet/freescale/enetc/Makefile
+++ /dev/null
@@ -1,20 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_FSL_ENETC) += fsl-enetc.o
-fsl-enetc-$(CONFIG_FSL_ENETC) += enetc.o enetc_cbdr.o enetc_ethtool.o \
-				 enetc_mdio.o
-fsl-enetc-$(CONFIG_ENETC_TSN) += enetc_tsn.o
-fsl-enetc-$(CONFIG_PCI_IOV) += enetc_msg.o
-fsl-enetc-objs := enetc_pf.o $(fsl-enetc-y)
-
-obj-$(CONFIG_FSL_ENETC_VF) += fsl-enetc-vf.o
-
-ifeq ($(CONFIG_FSL_ENETC)$(CONFIG_FSL_ENETC_VF), yy)
-fsl-enetc-vf-objs := enetc_vf.o
-else
-fsl-enetc-vf-$(CONFIG_FSL_ENETC_VF) += enetc.o enetc_cbdr.o \
-				       enetc_ethtool.o
-fsl-enetc-vf-objs := enetc_vf.o $(fsl-enetc-vf-y)
-endif
-
-obj-$(CONFIG_FSL_ENETC_PTP_CLOCK) += fsl-enetc-ptp.o
-fsl-enetc-ptp-$(CONFIG_FSL_ENETC_PTP_CLOCK) += enetc_ptp.o
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.c b/drivers/net/ethernet/freescale/enetc/enetc.c
deleted file mode 100644
index c9680bcddda7..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc.c
+++ /dev/null
@@ -1,1823 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include "enetc.h"
-#include <linux/tcp.h>
-#include <linux/udp.h>
-#include <linux/of_mdio.h>
-
-/* ENETC overhead: optional extension BD + 1 BD gap */
-#define ENETC_TXBDS_NEEDED(val)	((val) + 2)
-/* max # of chained Tx BDs is 15, including head and extension BD */
-#define ENETC_MAX_SKB_FRAGS	13
-#define ENETC_TXBDS_MAX_NEEDED	ENETC_TXBDS_NEEDED(ENETC_MAX_SKB_FRAGS + 1)
-
-static int enetc_map_tx_buffs(struct enetc_bdr *tx_ring, struct sk_buff *skb,
-			      enum enetc_hw_features hw_features);
-
-netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_bdr *tx_ring;
-	int count;
-
-	tx_ring = priv->tx_ring[skb->queue_mapping];
-
-	if (unlikely(skb_shinfo(skb)->nr_frags > ENETC_MAX_SKB_FRAGS))
-		if (unlikely(skb_linearize(skb)))
-			goto drop_packet_err;
-
-	count = skb_shinfo(skb)->nr_frags + 1; /* fragments + head */
-	if (enetc_bd_unused(tx_ring) < ENETC_TXBDS_NEEDED(count)) {
-		netif_stop_subqueue(ndev, tx_ring->index);
-		return NETDEV_TX_BUSY;
-	}
-
-	count = enetc_map_tx_buffs(tx_ring, skb, priv->hw_features);
-	if (unlikely(!count))
-		goto drop_packet_err;
-
-	if (enetc_bd_unused(tx_ring) < ENETC_TXBDS_MAX_NEEDED)
-		netif_stop_subqueue(ndev, tx_ring->index);
-
-	return NETDEV_TX_OK;
-
-drop_packet_err:
-	dev_kfree_skb_any(skb);
-	return NETDEV_TX_OK;
-}
-
-static bool enetc_tx_csum(struct sk_buff *skb, union enetc_tx_bd *txbd)
-{
-	int l3_start, l3_hsize;
-	u16 l3_flags, l4_flags;
-
-	if (skb->ip_summed != CHECKSUM_PARTIAL)
-		return false;
-
-	switch (skb->csum_offset) {
-	case offsetof(struct tcphdr, check):
-		l4_flags = ENETC_TXBD_L4_TCP;
-		break;
-	case offsetof(struct udphdr, check):
-		l4_flags = ENETC_TXBD_L4_UDP;
-		break;
-	default:
-		skb_checksum_help(skb);
-		return false;
-	}
-
-	l3_start = skb_network_offset(skb);
-	l3_hsize = skb_network_header_len(skb);
-
-	l3_flags = 0;
-	if (skb->protocol == htons(ETH_P_IPV6))
-		l3_flags = ENETC_TXBD_L3_IPV6;
-
-	/* write BD fields */
-	txbd->l3_csoff = enetc_txbd_l3_csoff(l3_start, l3_hsize, l3_flags);
-	txbd->l4_csoff = l4_flags;
-
-	return true;
-}
-
-static void enetc_unmap_tx_buff(struct enetc_bdr *tx_ring,
-				struct enetc_tx_swbd *tx_swbd)
-{
-	if (tx_swbd->is_dma_page)
-		dma_unmap_page(tx_ring->dev, tx_swbd->dma,
-			       tx_swbd->len, DMA_TO_DEVICE);
-	else
-		dma_unmap_single(tx_ring->dev, tx_swbd->dma,
-				 tx_swbd->len, DMA_TO_DEVICE);
-	tx_swbd->dma = 0;
-}
-
-static void enetc_free_tx_skb(struct enetc_bdr *tx_ring,
-			      struct enetc_tx_swbd *tx_swbd)
-{
-	if (tx_swbd->dma)
-		enetc_unmap_tx_buff(tx_ring, tx_swbd);
-
-	if (tx_swbd->skb) {
-		dev_kfree_skb_any(tx_swbd->skb);
-		tx_swbd->skb = NULL;
-	}
-}
-
-static int enetc_map_tx_buffs(struct enetc_bdr *tx_ring, struct sk_buff *skb,
-			      enum enetc_hw_features hw_features)
-{
-	struct enetc_tx_swbd *tx_swbd;
-	struct skb_frag_struct *frag;
-	int len = skb_headlen(skb);
-	union enetc_tx_bd temp_bd;
-	union enetc_tx_bd *txbd;
-	bool do_vlan, do_tstamp;
-	int i, count = 0;
-	unsigned int f;
-	dma_addr_t dma;
-	u8 flags = 0;
-
-	i = tx_ring->next_to_use;
-	txbd = ENETC_TXBD(*tx_ring, i);
-	prefetchw(txbd);
-
-	dma = dma_map_single(tx_ring->dev, skb->data, len, DMA_TO_DEVICE);
-	if (unlikely(dma_mapping_error(tx_ring->dev, dma)))
-		goto dma_err;
-
-	temp_bd.addr = cpu_to_le64(dma);
-	temp_bd.buf_len = cpu_to_le16(len);
-	temp_bd.lstatus = 0;
-
-	tx_swbd = &tx_ring->tx_swbd[i];
-	tx_swbd->dma = dma;
-	tx_swbd->len = len;
-	tx_swbd->is_dma_page = 0;
-	count++;
-
-	do_vlan = skb_vlan_tag_present(skb);
-	do_tstamp = (hw_features & ENETC_F_TX_TSTAMP) &&
-		    (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP);
-	tx_swbd->do_tstamp = do_tstamp;
-	tx_swbd->qbv_en = hw_features & ENETC_F_QBV;
-	tx_swbd->check_wb = tx_swbd->do_tstamp || tx_swbd->qbv_en;
-
-	if (do_vlan || do_tstamp)
-		flags |= ENETC_TXBD_FLAGS_EX;
-
-	if (enetc_tx_csum(skb, &temp_bd))
-		flags |= ENETC_TXBD_FLAGS_CSUM | ENETC_TXBD_FLAGS_L4CS;
-
-	/* first BD needs frm_len and offload flags set */
-	temp_bd.frm_len = cpu_to_le16(skb->len);
-	temp_bd.flags = flags;
-
-	if (flags & ENETC_TXBD_FLAGS_EX) {
-		u8 e_flags = 0;
-		*txbd = temp_bd;
-		enetc_clear_tx_bd(&temp_bd);
-
-		/* add extension BD for VLAN and/or timestamping */
-		flags = 0;
-		tx_swbd++;
-		txbd++;
-		i++;
-		if (unlikely(i == tx_ring->bd_count)) {
-			i = 0;
-			tx_swbd = tx_ring->tx_swbd;
-			txbd = ENETC_TXBD(*tx_ring, 0);
-		}
-		prefetchw(txbd);
-
-		if (do_vlan) {
-			temp_bd.ext.vid = cpu_to_le16(skb_vlan_tag_get(skb));
-			temp_bd.ext.tpid = 0; /* < C-TAG */
-			e_flags |= ENETC_TXBD_E_FLAGS_VLAN_INS;
-		}
-
-		if (do_tstamp) {
-			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-			e_flags |= ENETC_TXBD_E_FLAGS_TWO_STEP_PTP;
-		}
-
-		temp_bd.ext.e_flags = e_flags;
-		count++;
-	}
-
-	frag = &skb_shinfo(skb)->frags[0];
-	for (f = 0; f < skb_shinfo(skb)->nr_frags; f++, frag++) {
-		len = skb_frag_size(frag);
-		dma = skb_frag_dma_map(tx_ring->dev, frag, 0, len,
-				       DMA_TO_DEVICE);
-		if (dma_mapping_error(tx_ring->dev, dma))
-			goto dma_err;
-
-		*txbd = temp_bd;
-		enetc_clear_tx_bd(&temp_bd);
-
-		flags = 0;
-		tx_swbd++;
-		txbd++;
-		i++;
-		if (unlikely(i == tx_ring->bd_count)) {
-			i = 0;
-			tx_swbd = tx_ring->tx_swbd;
-			txbd = ENETC_TXBD(*tx_ring, 0);
-		}
-		prefetchw(txbd);
-
-		temp_bd.addr = cpu_to_le64(dma);
-		temp_bd.buf_len = cpu_to_le16(len);
-
-		tx_swbd->dma = dma;
-		tx_swbd->len = len;
-		tx_swbd->is_dma_page = 1;
-		count++;
-	}
-
-	/* last BD needs 'F' bit set */
-	flags |= ENETC_TXBD_FLAGS_F;
-	temp_bd.flags = flags;
-	*txbd = temp_bd;
-
-	tx_ring->tx_swbd[i].skb = skb;
-
-	enetc_bdr_idx_inc(tx_ring, &i);
-	tx_ring->next_to_use = i;
-
-	/* let H/W know BD ring has been updated */
-	enetc_wr_reg(tx_ring->tpir, i); /* includes wmb() */
-
-	return count;
-
-dma_err:
-	dev_err(tx_ring->dev, "DMA map error");
-
-	do {
-		tx_swbd = &tx_ring->tx_swbd[i];
-		enetc_free_tx_skb(tx_ring, tx_swbd);
-		if (i == 0)
-			i = tx_ring->bd_count;
-		i--;
-	} while (count--);
-
-	return 0;
-}
-
-static irqreturn_t enetc_msix(int irq, void *data)
-{
-	struct enetc_int_vector	*v = data;
-	int i;
-
-	/* disable interrupts */
-	enetc_wr_reg(v->rbier, 0);
-
-	for_each_set_bit(i, &v->tx_rings_map, v->count_tx_rings)
-		enetc_wr_reg(v->tbier_base + ENETC_BDR_OFF(i), 0);
-
-	napi_schedule_irqoff(&v->napi);
-
-	return IRQ_HANDLED;
-}
-
-static bool enetc_clean_tx_ring(struct enetc_bdr *tx_ring, int napi_budget);
-static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
-			       struct napi_struct *napi, int work_limit);
-
-static int enetc_poll(struct napi_struct *napi, int budget)
-{
-	struct enetc_int_vector
-		*v = container_of(napi, struct enetc_int_vector, napi);
-	bool complete = true;
-	int work_done;
-	int i;
-
-	for (i = 0; i < v->count_tx_rings; i++)
-		if (!enetc_clean_tx_ring(&v->tx_ring[i], budget))
-			complete = false;
-
-	work_done = enetc_clean_rx_ring(&v->rx_ring, napi, budget);
-	if (work_done == budget)
-		complete = false;
-
-	if (!complete)
-		return budget;
-
-	napi_complete_done(napi, work_done);
-
-	/* enable interrupts */
-	enetc_wr_reg(v->rbier, ENETC_RBIER_RXTIE);
-
-	for_each_set_bit(i, &v->tx_rings_map, v->count_tx_rings)
-		enetc_wr_reg(v->tbier_base + ENETC_BDR_OFF(i),
-			     ENETC_TBIER_TXTIE);
-
-	return work_done;
-}
-
-static int enetc_bd_ready_count(struct enetc_bdr *tx_ring, int ci)
-{
-	int pi = enetc_rd_reg(tx_ring->tcir) & ENETC_TBCIR_IDX_MASK;
-
-	return pi >= ci ? pi - ci : tx_ring->bd_count - ci + pi;
-}
-
-static void enetc_get_tx_tstamp(struct enetc_hw *hw, union enetc_tx_bd *txbd,
-				u64 *tstamp)
-{
-	u32 lo, hi;
-
-	lo = enetc_rd(hw, ENETC_SICTR0);
-	hi = enetc_rd(hw, ENETC_SICTR1);
-	if (lo <= txbd->wb.tstamp)
-		hi -= 1;
-	*tstamp = (u64)hi << 32 | txbd->wb.tstamp;
-}
-
-static void enetc_tstamp_tx(struct sk_buff *skb, u64 tstamp)
-{
-	struct skb_shared_hwtstamps shhwtstamps;
-
-	if (skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS) {
-		memset(&shhwtstamps, 0, sizeof(shhwtstamps));
-		shhwtstamps.hwtstamp = ns_to_ktime(tstamp);
-		skb_tstamp_tx(skb, &shhwtstamps);
-	}
-}
-
-static bool enetc_clean_tx_ring(struct enetc_bdr *tx_ring, int napi_budget)
-{
-	int tx_frm_cnt = 0, tx_byte_cnt = 0, tx_win_drop = 0;
-	struct net_device *ndev = tx_ring->ndev;
-	struct enetc_tx_swbd *tx_swbd;
-	int i, bds_to_clean;
-	bool do_tstamp;
-	u64 tstamp = 0;
-
-	i = tx_ring->next_to_clean;
-	tx_swbd = &tx_ring->tx_swbd[i];
-	do_tstamp = false;
-	bds_to_clean = enetc_bd_ready_count(tx_ring, i);
-
-	while (bds_to_clean && tx_frm_cnt < ENETC_DEFAULT_TX_WORK) {
-		bool is_eof = !!tx_swbd->skb;
-
-		if (unlikely(tx_swbd->check_wb)) {
-			struct enetc_ndev_priv *priv = netdev_priv(ndev);
-			union enetc_tx_bd *txbd;
-
-			txbd = ENETC_TXBD(*tx_ring, i);
-			if (!(txbd->flags & ENETC_TXBD_FLAGS_W))
-				goto no_wb;
-
-			if (tx_swbd->do_tstamp) {
-				enetc_get_tx_tstamp(&priv->si->hw, txbd,
-						    &tstamp);
-				do_tstamp = true;
-			}
-
-			if (tx_swbd->qbv_en &&
-			    txbd->wb.status & ENETC_TXBD_STATS_WIN)
-				tx_win_drop++;
-		}
-no_wb:
-		if (likely(tx_swbd->dma))
-			enetc_unmap_tx_buff(tx_ring, tx_swbd);
-
-		if (is_eof) {
-			if (unlikely(do_tstamp)) {
-				enetc_tstamp_tx(tx_swbd->skb, tstamp);
-				do_tstamp = false;
-			}
-			napi_consume_skb(tx_swbd->skb, napi_budget);
-			tx_swbd->skb = NULL;
-		}
-
-		tx_byte_cnt += tx_swbd->len;
-
-		bds_to_clean--;
-		tx_swbd++;
-		i++;
-		if (unlikely(i == tx_ring->bd_count)) {
-			i = 0;
-			tx_swbd = tx_ring->tx_swbd;
-		}
-
-		/* BD iteration loop end */
-		if (is_eof) {
-			tx_frm_cnt++;
-			/* re-arm interrupt source */
-			enetc_wr_reg(tx_ring->idr, BIT(tx_ring->index) |
-				     BIT(16 + tx_ring->index));
-		}
-
-		if (unlikely(!bds_to_clean))
-			bds_to_clean = enetc_bd_ready_count(tx_ring, i);
-	}
-
-	tx_ring->next_to_clean = i;
-	tx_ring->stats.packets += tx_frm_cnt;
-	tx_ring->stats.bytes += tx_byte_cnt;
-	tx_ring->stats.win_drop += tx_win_drop;
-
-	if (unlikely(tx_frm_cnt && netif_carrier_ok(ndev) &&
-		     __netif_subqueue_stopped(ndev, tx_ring->index) &&
-		     (enetc_bd_unused(tx_ring) >= ENETC_TXBDS_MAX_NEEDED))) {
-		netif_wake_subqueue(ndev, tx_ring->index);
-	}
-
-	return tx_frm_cnt != ENETC_DEFAULT_TX_WORK;
-}
-
-static bool enetc_new_page(struct enetc_bdr *rx_ring,
-			   struct enetc_rx_swbd *rx_swbd)
-{
-	struct page *page;
-	dma_addr_t addr;
-
-	page = dev_alloc_page();
-	if (unlikely(!page))
-		return false;
-
-	addr = dma_map_page(rx_ring->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);
-	if (unlikely(dma_mapping_error(rx_ring->dev, addr))) {
-		__free_page(page);
-
-		return false;
-	}
-
-	rx_swbd->dma = addr;
-	rx_swbd->page = page;
-	rx_swbd->page_offset = ENETC_RXB_PAD;
-
-	return true;
-}
-
-static int enetc_refill_rx_ring(struct enetc_bdr *rx_ring, const int buff_cnt)
-{
-	struct enetc_rx_swbd *rx_swbd;
-	union enetc_rx_bd *rxbd;
-	int i, j;
-
-	i = rx_ring->next_to_use;
-	rx_swbd = &rx_ring->rx_swbd[i];
-	rxbd = ENETC_RXBD(*rx_ring, i);
-
-	for (j = 0; j < buff_cnt; j++) {
-		/* try reuse page */
-		if (unlikely(!rx_swbd->page)) {
-			if (unlikely(!enetc_new_page(rx_ring, rx_swbd))) {
-				rx_ring->stats.rx_alloc_errs++;
-				break;
-			}
-		}
-
-		/* update RxBD */
-		rxbd->w.addr = cpu_to_le64(rx_swbd->dma +
-					   rx_swbd->page_offset);
-		/* clear 'R" as well */
-		rxbd->r.lstatus = 0;
-
-		rx_swbd++;
-		rxbd++;
-		i++;
-		if (unlikely(i == rx_ring->bd_count)) {
-			i = 0;
-			rx_swbd = rx_ring->rx_swbd;
-			rxbd = ENETC_RXBD(*rx_ring, 0);
-		}
-	}
-
-	if (likely(j)) {
-		rx_ring->next_to_alloc = i; /* keep track from page reuse */
-		rx_ring->next_to_use = i;
-		/* update ENETC's consumer index */
-		enetc_wr_reg(rx_ring->rcir, i);
-	}
-
-	return j;
-}
-
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-static void enetc_get_rx_tstamp(struct net_device *ndev,
-				union enetc_rx_bd *rxbd,
-				struct sk_buff *skb)
-{
-	struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	u32 lo, hi;
-	u64 tstamp;
-
-	if (rxbd->r.flags & ENETC_RXBD_FLAG_TSTMP) {
-		lo = enetc_rd(hw, ENETC_SICTR0);
-		hi = enetc_rd(hw, ENETC_SICTR1);
-		if (lo <= rxbd->r.tstamp)
-			hi -= 1;
-
-		tstamp = (u64)hi << 32 | rxbd->r.tstamp;
-		memset(shhwtstamps, 0, sizeof(*shhwtstamps));
-		shhwtstamps->hwtstamp = ns_to_ktime(tstamp);
-	}
-}
-#endif
-
-static void enetc_get_offloads(struct enetc_bdr *rx_ring,
-			       union enetc_rx_bd *rxbd, struct sk_buff *skb)
-{
-	/* TODO: add tstamp, hashing */
-	if (rx_ring->ndev->features & NETIF_F_RXCSUM) {
-		u16 inet_csum = le16_to_cpu(rxbd->r.inet_csum);
-
-		skb->csum = csum_unfold((__force __sum16)~htons(inet_csum));
-		skb->ip_summed = CHECKSUM_COMPLETE;
-	}
-
-	/* copy VLAN to skb, if one is extracted, for now we assume it's a
-	 * standard TPID, but HW also supports custom values
-	 */
-	if (le16_to_cpu(rxbd->r.flags) & ENETC_RXBD_FLAG_VLAN)
-		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
-				       le16_to_cpu(rxbd->r.vlan_opt));
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-	enetc_get_rx_tstamp(rx_ring->ndev, rxbd, skb);
-#endif
-}
-
-static void enetc_process_skb(struct enetc_bdr *rx_ring,
-			      struct sk_buff *skb)
-{
-	skb_record_rx_queue(skb, rx_ring->index);
-	skb->protocol = eth_type_trans(skb, rx_ring->ndev);
-}
-
-static bool enetc_page_reusable(struct page *page)
-{
-	return (!page_is_pfmemalloc(page) && page_ref_count(page) == 1);
-}
-
-static void enetc_reuse_page(struct enetc_bdr *rx_ring,
-			     struct enetc_rx_swbd *old)
-{
-	struct enetc_rx_swbd *new;
-
-	new = &rx_ring->rx_swbd[rx_ring->next_to_alloc];
-
-	/* next buf that may reuse a page */
-	enetc_bdr_idx_inc(rx_ring, &rx_ring->next_to_alloc);
-
-	/* copy page reference */
-	*new = *old;
-}
-
-static struct enetc_rx_swbd *enetc_get_rx_buff(struct enetc_bdr *rx_ring,
-					       int i, u16 size)
-{
-	struct enetc_rx_swbd *rx_swbd = &rx_ring->rx_swbd[i];
-
-	dma_sync_single_range_for_cpu(rx_ring->dev, rx_swbd->dma,
-				      rx_swbd->page_offset,
-				      size, DMA_FROM_DEVICE);
-	return rx_swbd;
-}
-
-static void enetc_put_rx_buff(struct enetc_bdr *rx_ring,
-			      struct enetc_rx_swbd *rx_swbd)
-{
-	if (likely(enetc_page_reusable(rx_swbd->page))) {
-		rx_swbd->page_offset ^= ENETC_RXB_TRUESIZE;
-		page_ref_inc(rx_swbd->page);
-
-		enetc_reuse_page(rx_ring, rx_swbd);
-
-		/* sync for use by the device */
-		dma_sync_single_range_for_device(rx_ring->dev, rx_swbd->dma,
-						 rx_swbd->page_offset,
-						 ENETC_RXB_DMA_SIZE,
-						 DMA_FROM_DEVICE);
-	} else {
-		dma_unmap_page(rx_ring->dev, rx_swbd->dma,
-			       PAGE_SIZE, DMA_FROM_DEVICE);
-	}
-
-	rx_swbd->page = NULL;
-}
-
-static struct sk_buff *enetc_map_rx_buff_to_skb(struct enetc_bdr *rx_ring,
-						int i, u16 size)
-{
-	struct enetc_rx_swbd *rx_swbd = enetc_get_rx_buff(rx_ring, i, size);
-	struct sk_buff *skb;
-	void *ba;
-
-	ba = page_address(rx_swbd->page) + rx_swbd->page_offset;
-	skb = build_skb(ba - ENETC_RXB_PAD, ENETC_RXB_TRUESIZE);
-	if (unlikely(!skb)) {
-		rx_ring->stats.rx_alloc_errs++;
-		return NULL;
-	}
-
-	skb_reserve(skb, ENETC_RXB_PAD);
-	__skb_put(skb, size);
-
-	enetc_put_rx_buff(rx_ring, rx_swbd);
-
-	return skb;
-}
-
-static void enetc_add_rx_buff_to_skb(struct enetc_bdr *rx_ring, int i,
-				     u16 size, struct sk_buff *skb)
-{
-	struct enetc_rx_swbd *rx_swbd = enetc_get_rx_buff(rx_ring, i, size);
-
-	skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rx_swbd->page,
-			rx_swbd->page_offset, size, ENETC_RXB_TRUESIZE);
-
-	enetc_put_rx_buff(rx_ring, rx_swbd);
-}
-
-#define ENETC_RXBD_BUNDLE 16 /* # of BDs to update at once */
-
-static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
-			       struct napi_struct *napi, int work_limit)
-{
-	int rx_frm_cnt = 0, rx_byte_cnt = 0;
-	int cleaned_cnt, i;
-
-	cleaned_cnt = enetc_bd_unused(rx_ring);
-	/* next descriptor to process */
-	i = rx_ring->next_to_clean;
-
-	while (likely(rx_frm_cnt < work_limit)) {
-		union enetc_rx_bd *rxbd;
-		struct sk_buff *skb;
-		u32 bd_status;
-		u16 size;
-
-		if (cleaned_cnt >= ENETC_RXBD_BUNDLE) {
-			int count = enetc_refill_rx_ring(rx_ring, cleaned_cnt);
-
-			cleaned_cnt -= count;
-		}
-
-		rxbd = ENETC_RXBD(*rx_ring, i);
-		bd_status = le32_to_cpu(rxbd->r.lstatus);
-		if (!bd_status)
-			break;
-
-		enetc_wr_reg(rx_ring->idr, BIT(rx_ring->index));
-		dma_rmb(); /* for reading other rxbd fields */
-		size = le16_to_cpu(rxbd->r.buf_len);
-		skb = enetc_map_rx_buff_to_skb(rx_ring, i, size);
-		if (!skb)
-			break;
-
-		enetc_get_offloads(rx_ring, rxbd, skb);
-
-		cleaned_cnt++;
-		rxbd++;
-		i++;
-		if (unlikely(i == rx_ring->bd_count)) {
-			i = 0;
-			rxbd = ENETC_RXBD(*rx_ring, 0);
-		}
-
-		if (unlikely(bd_status &
-			     ENETC_RXBD_LSTATUS(ENETC_RXBD_ERR_MASK))) {
-			dev_kfree_skb(skb);
-			while (!(bd_status & ENETC_RXBD_LSTATUS_F)) {
-				dma_rmb();
-				bd_status = le32_to_cpu(rxbd->r.lstatus);
-				rxbd++;
-				i++;
-				if (unlikely(i == rx_ring->bd_count)) {
-					i = 0;
-					rxbd = ENETC_RXBD(*rx_ring, 0);
-				}
-			}
-
-			rx_ring->ndev->stats.rx_dropped++;
-			rx_ring->ndev->stats.rx_errors++;
-
-			break;
-		}
-
-		/* not last BD in frame? */
-		while (!(bd_status & ENETC_RXBD_LSTATUS_F)) {
-			bd_status = le32_to_cpu(rxbd->r.lstatus);
-			size = ENETC_RXB_DMA_SIZE;
-
-			if (bd_status & ENETC_RXBD_LSTATUS_F) {
-				dma_rmb();
-				size = le16_to_cpu(rxbd->r.buf_len);
-			}
-
-			enetc_add_rx_buff_to_skb(rx_ring, i, size, skb);
-
-			cleaned_cnt++;
-			rxbd++;
-			i++;
-			if (unlikely(i == rx_ring->bd_count)) {
-				i = 0;
-				rxbd = ENETC_RXBD(*rx_ring, 0);
-			}
-		}
-
-		rx_byte_cnt += skb->len;
-
-		enetc_process_skb(rx_ring, skb);
-
-		napi_gro_receive(napi, skb);
-
-		rx_frm_cnt++;
-	}
-
-	rx_ring->next_to_clean = i;
-
-	rx_ring->stats.packets += rx_frm_cnt;
-	rx_ring->stats.bytes += rx_byte_cnt;
-
-	return rx_frm_cnt;
-}
-
-/* Probing and Init */
-#define ENETC_MAX_RFS_SIZE 64
-void enetc_get_si_caps(struct enetc_si *si)
-{
-	struct enetc_hw *hw = &si->hw;
-	u32 val;
-
-	/* find out how many of various resources we have to work with */
-	val = enetc_rd(hw, ENETC_SICAPR0);
-	si->num_rx_rings = (val >> 16) & 0xff;
-	si->num_tx_rings = val & 0xff;
-
-	val = enetc_rd(hw, ENETC_SIRFSCAPR);
-	si->num_fs_entries = ENETC_SIRFSCAPR_GET_NUM_RFS(val);
-	si->num_fs_entries = min(si->num_fs_entries, ENETC_MAX_RFS_SIZE);
-
-	si->num_rss = 0;
-	val = enetc_rd(hw, ENETC_SIPCAPR0);
-	if (val & ENETC_SIPCAPR0_RSS) {
-		u32 rsscap = enetc_rd(hw, ENETC_SIRSSCAPR);
-
-		si->num_rss = ENETC_SIRSSCAPR_GET_NUM_RSS(rsscap);
-	}
-	if (val & ENETC_SIPCAPR0_QBV)
-		si->hw_features |= ENETC_SI_F_QBV;
-}
-
-static int enetc_dma_alloc_bdr(struct enetc_bdr *r, size_t bd_size)
-{
-	r->bd_base = dma_zalloc_coherent(r->dev, r->bd_count * bd_size,
-					 &r->bd_dma_base, GFP_KERNEL);
-	if (!r->bd_base)
-		return -ENOMEM;
-
-	/* h/w requires 128B alignment */
-	if (!IS_ALIGNED(r->bd_dma_base, 128)) {
-		dma_free_coherent(r->dev, r->bd_count * bd_size, r->bd_base,
-				  r->bd_dma_base);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int enetc_alloc_txbdr(struct enetc_bdr *txr)
-{
-	int err;
-
-	txr->tx_swbd = vzalloc(txr->bd_count * sizeof(struct enetc_tx_swbd));
-	if (!txr->tx_swbd)
-		return -ENOMEM;
-
-	err = enetc_dma_alloc_bdr(txr, sizeof(union enetc_tx_bd));
-	if (err) {
-		vfree(txr->tx_swbd);
-		return err;
-	}
-
-	txr->next_to_clean = 0;
-	txr->next_to_use = 0;
-
-	return 0;
-}
-
-static void enetc_free_txbdr(struct enetc_bdr *txr)
-{
-	int size, i;
-
-	for (i = 0; i < txr->bd_count; i++)
-		enetc_free_tx_skb(txr, &txr->tx_swbd[i]);
-
-	size = txr->bd_count * sizeof(union enetc_tx_bd);
-
-	dma_free_coherent(txr->dev, size, txr->bd_base, txr->bd_dma_base);
-	txr->bd_base = NULL;
-
-	vfree(txr->tx_swbd);
-	txr->tx_swbd = NULL;
-}
-
-static int enetc_alloc_tx_resources(struct enetc_ndev_priv *priv)
-{
-	int i, err;
-
-	for (i = 0; i < priv->num_tx_rings; i++) {
-		err = enetc_alloc_txbdr(priv->tx_ring[i]);
-
-		if (err)
-			goto fail;
-	}
-
-	return 0;
-
-fail:
-	while (i-- > 0)
-		enetc_free_txbdr(priv->tx_ring[i]);
-
-	return err;
-}
-
-static void enetc_free_tx_resources(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->num_tx_rings; i++)
-		enetc_free_txbdr(priv->tx_ring[i]);
-}
-
-static int enetc_alloc_rxbdr(struct enetc_bdr *rxr)
-{
-	int err;
-
-	rxr->rx_swbd = vzalloc(rxr->bd_count * sizeof(struct enetc_rx_swbd));
-	if (!rxr->rx_swbd)
-		return -ENOMEM;
-
-	err = enetc_dma_alloc_bdr(rxr, sizeof(union enetc_rx_bd));
-	if (err) {
-		vfree(rxr->rx_swbd);
-		return err;
-	}
-
-	rxr->next_to_clean = 0;
-	rxr->next_to_use = 0;
-	rxr->next_to_alloc = 0;
-
-	return 0;
-}
-
-static void enetc_free_rxbdr(struct enetc_bdr *rxr)
-{
-	int size;
-
-	size = rxr->bd_count * sizeof(union enetc_rx_bd);
-
-	dma_free_coherent(rxr->dev, size, rxr->bd_base, rxr->bd_dma_base);
-	rxr->bd_base = NULL;
-
-	vfree(rxr->rx_swbd);
-	rxr->rx_swbd = NULL;
-}
-
-static int enetc_alloc_rx_resources(struct enetc_ndev_priv *priv)
-{
-	int i, err;
-
-	for (i = 0; i < priv->num_rx_rings; i++) {
-		err = enetc_alloc_rxbdr(priv->rx_ring[i]);
-
-		if (err)
-			goto fail;
-	}
-
-	return 0;
-
-fail:
-	while (i-- > 0)
-		enetc_free_rxbdr(priv->rx_ring[i]);
-
-	return err;
-}
-
-static void enetc_free_rx_resources(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->num_rx_rings; i++)
-		enetc_free_rxbdr(priv->rx_ring[i]);
-}
-
-static void enetc_free_tx_ring(struct enetc_bdr *tx_ring)
-{
-	int i;
-
-	if (!tx_ring->tx_swbd)
-		return;
-
-	for (i = 0; i < tx_ring->bd_count; i++) {
-		struct enetc_tx_swbd *tx_swbd = &tx_ring->tx_swbd[i];
-
-		enetc_free_tx_skb(tx_ring, tx_swbd);
-	}
-
-	tx_ring->next_to_clean = 0;
-	tx_ring->next_to_use = 0;
-}
-
-static void enetc_free_rx_ring(struct enetc_bdr *rx_ring)
-{
-	int i;
-
-	if (!rx_ring->rx_swbd)
-		return;
-
-	for (i = 0; i < rx_ring->bd_count; i++) {
-		struct enetc_rx_swbd *rx_swbd = &rx_ring->rx_swbd[i];
-
-		if (!rx_swbd->page)
-			continue;
-
-		dma_unmap_page(rx_ring->dev, rx_swbd->dma,
-			       PAGE_SIZE, DMA_FROM_DEVICE);
-		__free_page(rx_swbd->page);
-		rx_swbd->page = NULL;
-	}
-
-	rx_ring->next_to_clean = 0;
-	rx_ring->next_to_use = 0;
-	rx_ring->next_to_alloc = 0;
-}
-
-static void enetc_free_rxtx_rings(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->num_rx_rings; i++)
-		enetc_free_rx_ring(priv->rx_ring[i]);
-
-	for (i = 0; i < priv->num_tx_rings; i++)
-		enetc_free_tx_ring(priv->tx_ring[i]);
-}
-
-static int enetc_alloc_cbdr(struct device *dev, struct enetc_cbdr *cbdr)
-{
-	int size = cbdr->bd_count * sizeof(struct enetc_cbd);
-
-	cbdr->bd_base = dma_zalloc_coherent(dev, size, &cbdr->bd_dma_base,
-					    GFP_KERNEL);
-	if (!cbdr->bd_base)
-		return -ENOMEM;
-
-	/* h/w requires 128B alignment */
-	if (!IS_ALIGNED(cbdr->bd_dma_base, 128)) {
-		dma_free_coherent(dev, size, cbdr->bd_base, cbdr->bd_dma_base);
-		return -EINVAL;
-	}
-
-	cbdr->next_to_clean = 0;
-	cbdr->next_to_use = 0;
-
-	return 0;
-}
-
-static void enetc_free_cbdr(struct device *dev, struct enetc_cbdr *cbdr)
-{
-	int size = cbdr->bd_count * sizeof(struct enetc_cbd);
-
-	dma_free_coherent(dev, size, cbdr->bd_base, cbdr->bd_dma_base);
-	cbdr->bd_base = NULL;
-}
-
-static void enetc_setup_cbdr(struct enetc_hw *hw, struct enetc_cbdr *cbdr)
-{
-	/* set CBDR cache attributes */
-	enetc_wr(hw, ENETC_SICAR2,
-		 ENETC_SICAR_RD_COHERENT | ENETC_SICAR_WR_COHERENT);
-
-	enetc_wr(hw, ENETC_SICBDRBAR0, lower_32_bits(cbdr->bd_dma_base));
-	enetc_wr(hw, ENETC_SICBDRBAR1, upper_32_bits(cbdr->bd_dma_base));
-	enetc_wr(hw, ENETC_SICBDRLENR, ENETC_RTBLENR_LEN(cbdr->bd_count));
-
-	enetc_wr(hw, ENETC_SICBDRPIR, 0);
-	enetc_wr(hw, ENETC_SICBDRCIR, 0);
-
-	/* enable ring */
-	enetc_wr(hw, ENETC_SICBDRMR, BIT(31));
-
-	cbdr->pir = hw->reg + ENETC_SICBDRPIR;
-	cbdr->cir = hw->reg + ENETC_SICBDRCIR;
-}
-
-static void enetc_clear_cbdr(struct enetc_hw *hw)
-{
-	enetc_wr(hw, ENETC_SICBDRMR, 0);
-}
-
-static int enetc_setup_default_rss_table(struct enetc_si *si, int num_groups)
-{
-	int *rss_table;
-	int i;
-
-	rss_table = kmalloc_array(si->num_rss, sizeof(*rss_table), GFP_KERNEL);
-	if (!rss_table)
-		return -ENOMEM;
-
-	/* Set up RSS table defaults */
-	for (i = 0; i < si->num_rss; i++)
-		rss_table[i] = i % num_groups;
-
-	enetc_set_rss_table(si, rss_table, si->num_rss);
-
-	kfree(rss_table);
-
-	return 0;
-}
-
-static int enetc_configure_si(struct enetc_ndev_priv *priv)
-{
-	struct enetc_si *si = priv->si;
-	struct enetc_hw *hw = &si->hw;
-	int err;
-
-	enetc_setup_cbdr(hw, &si->cbd_ring);
-	/* set SI cache attributes */
-	enetc_wr(hw, ENETC_SICAR0,
-		 ENETC_SICAR_RD_COHERENT | ENETC_SICAR_WR_COHERENT);
-	enetc_wr(hw, ENETC_SICAR1, ENETC_SICAR_MSI);
-	/* enable SI */
-	enetc_wr(hw, ENETC_SIMR, ENETC_SIMR_EN);
-
-	if (si->num_rss) {
-		err = enetc_setup_default_rss_table(si, priv->num_rx_rings);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-void enetc_init_si_rings_params(struct enetc_ndev_priv *priv)
-{
-	struct enetc_si *si = priv->si;
-	int cpus = num_online_cpus();
-
-	priv->tx_bd_count = ENETC_BDR_DEFAULT_SIZE;
-	priv->rx_bd_count = ENETC_BDR_DEFAULT_SIZE;
-
-	/* Enable all available TX rings in order to configure as many
-	 * priorities as possible, when needed.
-	 * TODO: Make # of TX rings run-time configurable
-	 */
-	priv->num_rx_rings = min_t(int, cpus, si->num_rx_rings);
-	priv->num_tx_rings = si->num_tx_rings;
-	priv->bdr_int_num = cpus;
-
-	/* SI specific */
-	si->cbd_ring.bd_count = ENETC_CBDR_DEFAULT_SIZE;
-}
-
-int enetc_alloc_si_resources(struct enetc_ndev_priv *priv)
-{
-	struct enetc_si *si = priv->si;
-	int err;
-
-	err = enetc_alloc_cbdr(priv->dev, &si->cbd_ring);
-	if (err)
-		return err;
-
-	priv->cls_rules = kcalloc(si->num_fs_entries, sizeof(*priv->cls_rules),
-				  GFP_KERNEL);
-	if (!priv->cls_rules) {
-		err = -ENOMEM;
-		goto err_alloc_cls;
-	}
-
-	err = enetc_configure_si(priv);
-	if (err)
-		goto err_config_si;
-
-	return 0;
-
-err_config_si:
-	kfree(priv->cls_rules);
-err_alloc_cls:
-	enetc_clear_cbdr(&si->hw);
-	enetc_free_cbdr(priv->dev, &si->cbd_ring);
-
-	return err;
-}
-
-void enetc_free_si_resources(struct enetc_ndev_priv *priv)
-{
-	struct enetc_si *si = priv->si;
-
-	enetc_clear_cbdr(&si->hw);
-	enetc_free_cbdr(priv->dev, &si->cbd_ring);
-
-	kfree(priv->cls_rules);
-}
-
-static void enetc_setup_txbdr(struct enetc_hw *hw, struct enetc_bdr *tx_ring)
-{
-	int idx = tx_ring->index;
-	u32 tbmr;
-
-	enetc_txbdr_wr(hw, idx, ENETC_TBBAR0,
-		       lower_32_bits(tx_ring->bd_dma_base));
-
-	enetc_txbdr_wr(hw, idx, ENETC_TBBAR1,
-		       upper_32_bits(tx_ring->bd_dma_base));
-
-	WARN_ON(!IS_ALIGNED(tx_ring->bd_count, 64)); /* multiple of 64 */
-	enetc_txbdr_wr(hw, idx, ENETC_TBLENR,
-		       ENETC_RTBLENR_LEN(tx_ring->bd_count));
-
-	/* clearing PI/CI registers for Tx not supported, adjust sw indexes */
-	tx_ring->next_to_use = enetc_txbdr_rd(hw, idx, ENETC_TBPIR);
-	tx_ring->next_to_clean = enetc_txbdr_rd(hw, idx, ENETC_TBCIR);
-
-	/* enable Tx ints by setting pkt thr to 1 */
-	enetc_txbdr_wr(hw, idx, ENETC_TBICIR0, ENETC_TBICIR0_ICEN | 0x1);
-
-	tbmr = ENETC_TBMR_EN;
-	if (tx_ring->ndev->features & NETIF_F_HW_VLAN_CTAG_TX)
-		tbmr |= ENETC_TBMR_VIH;
-
-	/* enable ring */
-	enetc_txbdr_wr(hw, idx, ENETC_TBMR, tbmr);
-
-	tx_ring->tpir = hw->reg + ENETC_BDR(TX, idx, ENETC_TBPIR);
-	tx_ring->tcir = hw->reg + ENETC_BDR(TX, idx, ENETC_TBCIR);
-	tx_ring->idr = hw->reg + ENETC_SITXIDR;
-}
-
-static void enetc_setup_rxbdr(struct enetc_hw *hw, struct enetc_bdr *rx_ring)
-{
-	int idx = rx_ring->index;
-	u32 rbmr;
-
-	enetc_rxbdr_wr(hw, idx, ENETC_RBBAR0,
-		       lower_32_bits(rx_ring->bd_dma_base));
-
-	enetc_rxbdr_wr(hw, idx, ENETC_RBBAR1,
-		       upper_32_bits(rx_ring->bd_dma_base));
-
-	WARN_ON(!IS_ALIGNED(rx_ring->bd_count, 64)); /* multiple of 64 */
-	enetc_rxbdr_wr(hw, idx, ENETC_RBLENR,
-		       ENETC_RTBLENR_LEN(rx_ring->bd_count));
-
-	enetc_rxbdr_wr(hw, idx, ENETC_RBBSR, ENETC_RXB_DMA_SIZE);
-
-	enetc_rxbdr_wr(hw, idx, ENETC_RBPIR, 0);
-
-	/* enable Rx ints by setting pkt thr to 1 */
-	enetc_rxbdr_wr(hw, idx, ENETC_RBICIR0, ENETC_RBICIR0_ICEN | 0x1);
-
-	rbmr = ENETC_RBMR_EN;
-	if (rx_ring->ndev->features & NETIF_F_HW_VLAN_CTAG_RX)
-		rbmr |= ENETC_RBMR_VTE;
-	if (enetc_has_extended_rxbds())
-		rbmr |= ENETC_RBMR_BDS;
-
-	rx_ring->rcir = hw->reg + ENETC_BDR(RX, idx, ENETC_RBCIR);
-	rx_ring->idr = hw->reg + ENETC_SIRXIDR;
-
-	enetc_refill_rx_ring(rx_ring, enetc_bd_unused(rx_ring));
-
-	/* enable ring */
-	enetc_rxbdr_wr(hw, idx, ENETC_RBMR, rbmr);
-}
-
-static void enetc_setup_bdrs(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->num_tx_rings; i++)
-		enetc_setup_txbdr(&priv->si->hw, priv->tx_ring[i]);
-
-	for (i = 0; i < priv->num_rx_rings; i++)
-		enetc_setup_rxbdr(&priv->si->hw, priv->rx_ring[i]);
-}
-
-static void enetc_clear_rxbdr(struct enetc_hw *hw, struct enetc_bdr *rx_ring)
-{
-	int idx = rx_ring->index;
-
-	/* disable EN bit on ring */
-	enetc_rxbdr_wr(hw, idx, ENETC_RBMR, 0);
-}
-
-static void enetc_clear_txbdr(struct enetc_hw *hw, struct enetc_bdr *tx_ring)
-{
-	int delay = 8, timeout = 100;
-	int idx = tx_ring->index;
-
-	/* disable EN bit on ring */
-	enetc_txbdr_wr(hw, idx, ENETC_TBMR, 0);
-
-	/* wait for busy to clear */
-	while (delay < timeout &&
-	       enetc_txbdr_rd(hw, idx, ENETC_TBSR) & ENETC_TBSR_BUSY) {
-		msleep(delay);
-		delay *= 2;
-	}
-
-	if (delay >= timeout)
-		netdev_warn(tx_ring->ndev, "timeout for tx ring #%d clear\n",
-			    idx);
-}
-
-static void enetc_clear_bdrs(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->num_tx_rings; i++)
-		enetc_clear_txbdr(&priv->si->hw, priv->tx_ring[i]);
-
-	for (i = 0; i < priv->num_rx_rings; i++)
-		enetc_clear_rxbdr(&priv->si->hw, priv->rx_ring[i]);
-
-	udelay(1);
-}
-
-static int enetc_setup_irqs(struct enetc_ndev_priv *priv)
-{
-	struct pci_dev *pdev = priv->si->pdev;
-	cpumask_t cpu_mask;
-	int i, j, err;
-
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		int irq = pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i);
-		struct enetc_int_vector *v = priv->int_vector[i];
-		int entry = ENETC_BDR_INT_BASE_IDX + i;
-		struct enetc_hw *hw = &priv->si->hw;
-
-		snprintf(v->name, sizeof(v->name), "%s-rxtx%d",
-			 priv->ndev->name, i);
-		err = request_irq(irq, enetc_msix, 0, v->name, v);
-		if (err) {
-			dev_err(priv->dev, "request_irq() failed!\n");
-			goto irq_err;
-		}
-
-		v->tbier_base = hw->reg + ENETC_BDR(TX, 0, ENETC_TBIER);
-		v->rbier = hw->reg + ENETC_BDR(RX, i, ENETC_RBIER);
-
-		enetc_wr(hw, ENETC_SIMSIRRV(i), entry);
-
-		for (j = 0; j < v->count_tx_rings; j++) {
-			int idx = v->tx_ring[j].index;
-
-			enetc_wr(hw, ENETC_SIMSITRV(idx), entry);
-		}
-		cpumask_clear(&cpu_mask);
-		cpumask_set_cpu(i % num_online_cpus(), &cpu_mask);
-		irq_set_affinity_hint(irq, &cpu_mask);
-	}
-
-	return 0;
-
-irq_err:
-	while (i--) {
-		int irq = pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i);
-
-		irq_set_affinity_hint(irq, NULL);
-		free_irq(irq, priv->int_vector[i]);
-	}
-
-	return err;
-}
-
-static void enetc_free_irqs(struct enetc_ndev_priv *priv)
-{
-	struct pci_dev *pdev = priv->si->pdev;
-	int i;
-
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		int irq = pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i);
-
-		irq_set_affinity_hint(irq, NULL);
-		free_irq(irq, priv->int_vector[i]);
-	}
-}
-
-static void enetc_enable_interrupts(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	/* enable Tx & Rx event indication */
-	for (i = 0; i < priv->num_rx_rings; i++) {
-		enetc_rxbdr_wr(&priv->si->hw, i,
-			       ENETC_RBIER, ENETC_RBIER_RXTIE);
-	}
-
-	for (i = 0; i < priv->num_tx_rings; i++) {
-		enetc_txbdr_wr(&priv->si->hw, i,
-			       ENETC_TBIER, ENETC_TBIER_TXTIE);
-	}
-}
-
-static void enetc_disable_interrupts(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->num_tx_rings; i++)
-		enetc_txbdr_wr(&priv->si->hw, i, ENETC_TBIER, 0);
-
-	for (i = 0; i < priv->num_rx_rings; i++)
-		enetc_rxbdr_wr(&priv->si->hw, i, ENETC_RBIER, 0);
-}
-
-static void adjust_link(struct net_device *ndev)
-{
-	struct phy_device *phydev = ndev->phydev;
-
-	phy_print_status(phydev);
-}
-
-static int enetc_phy_connect(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct phy_device *phydev;
-
-	if (!priv->phy_node)
-		return 0; /* phy-less mode */
-
-	phydev = of_phy_connect(ndev, priv->phy_node, &adjust_link,
-				0, priv->if_mode);
-	if (!phydev) {
-		dev_err(&ndev->dev, "could not attach to PHY\n");
-		return -ENODEV;
-	}
-
-	phy_attached_info(phydev);
-
-	return 0;
-}
-
-int enetc_open(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int i, err;
-
-	err = enetc_setup_irqs(priv);
-	if (err)
-		return err;
-
-	err = enetc_phy_connect(ndev);
-	if (err)
-		goto err_phy_connect;
-
-	err = enetc_alloc_tx_resources(priv);
-	if (err)
-		goto err_alloc_tx;
-
-	err = enetc_alloc_rx_resources(priv);
-	if (err)
-		goto err_alloc_rx;
-
-	enetc_setup_bdrs(priv);
-
-	err = netif_set_real_num_tx_queues(ndev, priv->num_tx_rings);
-	if (err)
-		goto err_set_queues;
-
-	err = netif_set_real_num_rx_queues(ndev, priv->num_rx_rings);
-	if (err)
-		goto err_set_queues;
-
-	for (i = 0; i < priv->bdr_int_num; i++)
-		napi_enable(&priv->int_vector[i]->napi);
-
-	enetc_enable_interrupts(priv);
-
-	if (ndev->phydev)
-		phy_start(ndev->phydev);
-	else
-		netif_carrier_on(ndev);
-
-	netif_tx_start_all_queues(ndev);
-
-	return 0;
-
-err_set_queues:
-	enetc_free_rx_resources(priv);
-err_alloc_rx:
-	enetc_free_tx_resources(priv);
-err_alloc_tx:
-	if (ndev->phydev)
-		phy_disconnect(ndev->phydev);
-err_phy_connect:
-	enetc_free_irqs(priv);
-
-	return err;
-}
-
-int enetc_close(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int i;
-
-	netif_tx_stop_all_queues(ndev);
-
-	if (ndev->phydev) {
-		phy_stop(ndev->phydev);
-		phy_disconnect(ndev->phydev);
-	} else {
-		netif_carrier_off(ndev);
-	}
-
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		napi_synchronize(&priv->int_vector[i]->napi);
-		napi_disable(&priv->int_vector[i]->napi);
-	}
-
-	enetc_disable_interrupts(priv);
-	enetc_clear_bdrs(priv);
-
-	enetc_free_rxtx_rings(priv);
-	enetc_free_rx_resources(priv);
-	enetc_free_tx_resources(priv);
-	enetc_free_irqs(priv);
-
-	return 0;
-}
-
-int enetc_setup_tc(struct net_device *ndev, enum tc_setup_type type,
-		   void *type_data)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct tc_mqprio_qopt *mqprio = type_data;
-	struct enetc_bdr *tx_ring;
-	int i;
-	u8 num_tc;
-	u32 val;
-
-	if (type != TC_SETUP_MQPRIO)
-		return -EOPNOTSUPP;
-
-	mqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;
-	num_tc = mqprio->num_tc;
-
-	if (!num_tc) {
-		netdev_reset_tc(ndev);
-		netif_set_real_num_tx_queues(ndev, ENETC_MAX_NUM_TXQS);
-
-		/* Reset all ring priorities to 0 */
-		for (i = 0; i < priv->num_tx_rings; i++) {
-			tx_ring = priv->tx_ring[i];
-			val = enetc_txbdr_rd(&priv->si->hw, tx_ring->index,
-					     ENETC_TBMR);
-			val &= ~ENETC_TBMR_PRIO_MASK;
-			enetc_txbdr_wr(&priv->si->hw, tx_ring->index,
-				       ENETC_TBMR, val);
-		}
-
-		return 0;
-	}
-
-	/* Check if we have enough BD rings available to accommodate all TCs */
-	if (num_tc > priv->num_tx_rings) {
-		netdev_err(ndev, "Max %d traffic classes supported\n",
-			   priv->num_tx_rings);
-		return -EINVAL;
-	}
-
-	/* For the moment, we use only one BD ring per TC.
-	 *
-	 * Configure num_tc BD rings with increasing priorities.
-	 */
-	for (i = 0; i < num_tc; i++) {
-		tx_ring = priv->tx_ring[i];
-		val = enetc_txbdr_rd(&priv->si->hw, tx_ring->index, ENETC_TBMR);
-		/* Clear the old priority and set the new one */
-		val &= ~ENETC_TBMR_PRIO_MASK;
-		val |= ENETC_TBMR_PRIO_SET(i);
-		enetc_txbdr_wr(&priv->si->hw, tx_ring->index, ENETC_TBMR, val);
-	}
-
-	/* Reset the number of netdev queues based on the TC count */
-	netif_set_real_num_tx_queues(ndev, num_tc);
-
-	netdev_set_num_tc(ndev, num_tc);
-
-	/* Each TC is associated with ENETC_TXQ_PER_TC netdev queues */
-	for (i = 0; i < num_tc; i++)
-		netdev_set_tc_queue(ndev, i, 1, i);
-
-	return 0;
-}
-
-struct net_device_stats *enetc_get_stats(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct net_device_stats *stats = &ndev->stats;
-	unsigned long packets = 0, bytes = 0;
-	int i;
-
-	for (i = 0; i < priv->num_rx_rings; i++) {
-		packets += priv->rx_ring[i]->stats.packets;
-		bytes	+= priv->rx_ring[i]->stats.bytes;
-	}
-
-	stats->rx_packets = packets;
-	stats->rx_bytes = bytes;
-	bytes = 0;
-	packets = 0;
-
-	for (i = 0; i < priv->num_tx_rings; i++) {
-		packets += priv->tx_ring[i]->stats.packets;
-		bytes	+= priv->tx_ring[i]->stats.bytes;
-	}
-
-	stats->tx_packets = packets;
-	stats->tx_bytes = bytes;
-
-	return stats;
-}
-
-static int enetc_set_rss(struct net_device *ndev, int en)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	u32 reg;
-
-	enetc_wr(hw, ENETC_SIRBGCR, priv->num_rx_rings);
-
-	reg = enetc_rd(hw, ENETC_SIMR);
-	reg &= ~ENETC_SIMR_RSSE;
-	reg |= (en) ? ENETC_SIMR_RSSE : 0;
-	enetc_wr(hw, ENETC_SIMR, reg);
-
-	return 0;
-}
-
-int enetc_set_features(struct net_device *ndev,
-		       netdev_features_t features)
-{
-	netdev_features_t changed = ndev->features ^ features;
-
-	if (changed & NETIF_F_RXHASH)
-		enetc_set_rss(ndev, !!(features & NETIF_F_RXHASH));
-
-	return 0;
-}
-
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-static int enetc_hwtstamp_set(struct net_device *ndev, struct ifreq *ifr)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct hwtstamp_config config;
-
-	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
-		return -EFAULT;
-
-	switch (config.tx_type) {
-	case HWTSTAMP_TX_OFF:
-		priv->hw_features &= ~ENETC_F_TX_TSTAMP;
-		break;
-	case HWTSTAMP_TX_ON:
-		priv->hw_features |= ENETC_F_TX_TSTAMP;
-		break;
-	default:
-		return -ERANGE;
-	}
-
-	switch (config.rx_filter) {
-	case HWTSTAMP_FILTER_NONE:
-		priv->hw_features &= ~ENETC_F_RX_TSTAMP;
-		break;
-	default:
-		priv->hw_features |= ENETC_F_RX_TSTAMP;
-		config.rx_filter = HWTSTAMP_FILTER_ALL;
-	}
-
-	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
-	       -EFAULT : 0;
-}
-
-static int enetc_hwtstamp_get(struct net_device *ndev, struct ifreq *ifr)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct hwtstamp_config config;
-
-	config.flags = 0;
-
-	if (priv->hw_features & ENETC_F_TX_TSTAMP)
-		config.tx_type = HWTSTAMP_TX_ON;
-	else
-		config.tx_type = HWTSTAMP_TX_OFF;
-
-	config.rx_filter = (priv->hw_features & ENETC_F_RX_TSTAMP) ?
-			    HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE;
-
-	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
-	       -EFAULT : 0;
-}
-#endif
-
-int enetc_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-	if (cmd == SIOCSHWTSTAMP)
-		return enetc_hwtstamp_set(dev, rq);
-	if (cmd == SIOCGHWTSTAMP)
-		return enetc_hwtstamp_get(dev, rq);
-#endif
-
-	return -EINVAL;
-}
-
-int enetc_alloc_msix(struct enetc_ndev_priv *priv)
-{
-	struct pci_dev *pdev = priv->si->pdev;
-	int size, v_tx_rings;
-	int i, n, err, nvec;
-
-	nvec = ENETC_BDR_INT_BASE_IDX + priv->bdr_int_num;
-	/* allocate MSIX for both messaging and Rx/Tx interrupts */
-	n = pci_alloc_irq_vectors(pdev, nvec, nvec, PCI_IRQ_MSIX);
-
-	if (n < 0)
-		return n;
-
-	if (n != nvec)
-		return -EPERM;
-
-	/* # of tx rings per int vector */
-	v_tx_rings = priv->num_tx_rings / priv->bdr_int_num;
-	size = sizeof(struct enetc_int_vector) +
-	       sizeof(struct enetc_bdr) * v_tx_rings;
-
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		struct enetc_int_vector *v;
-		struct enetc_bdr *bdr;
-		int j;
-
-		v = kzalloc(size, GFP_KERNEL);
-		if (!v) {
-			err = -ENOMEM;
-			goto fail;
-		}
-
-		priv->int_vector[i] = v;
-
-		netif_napi_add(priv->ndev, &v->napi, enetc_poll,
-			       NAPI_POLL_WEIGHT);
-		v->count_tx_rings = v_tx_rings;
-
-		for (j = 0; j < v_tx_rings; j++) {
-			int idx;
-
-			/* default tx ring mapping policy */
-			if (priv->bdr_int_num == ENETC_MAX_BDR_INT)
-				idx = 2 * j + i; /* 2 CPUs */
-			else
-				idx = j + i * v_tx_rings; /* default */
-
-			__set_bit(idx, &v->tx_rings_map);
-			bdr = &v->tx_ring[j];
-			bdr->index = idx;
-			bdr->ndev = priv->ndev;
-			bdr->dev = priv->dev;
-			bdr->bd_count = priv->tx_bd_count;
-			priv->tx_ring[idx] = bdr;
-		}
-
-		bdr = &v->rx_ring;
-		bdr->index = i;
-		bdr->ndev = priv->ndev;
-		bdr->dev = priv->dev;
-		bdr->bd_count = priv->rx_bd_count;
-		priv->rx_ring[i] = bdr;
-	}
-
-	return 0;
-
-fail:
-	while (i--) {
-		netif_napi_del(&priv->int_vector[i]->napi);
-		kfree(priv->int_vector[i]);
-	}
-
-	pci_free_irq_vectors(pdev);
-
-	return err;
-}
-
-void enetc_free_msix(struct enetc_ndev_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		struct enetc_int_vector *v = priv->int_vector[i];
-
-		netif_napi_del(&v->napi);
-	}
-
-	for (i = 0; i < priv->num_rx_rings; i++)
-		priv->rx_ring[i] = NULL;
-
-	for (i = 0; i < priv->num_tx_rings; i++)
-		priv->tx_ring[i] = NULL;
-
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		kfree(priv->int_vector[i]);
-		priv->int_vector[i] = NULL;
-	}
-
-	/* disable all MSIX for this device */
-	pci_free_irq_vectors(priv->si->pdev);
-}
-
-static void enetc_kfree_si(struct enetc_si *si)
-{
-	char *p = (char *)si - si->pad;
-
-	kfree(p);
-}
-
-static void enetc_detect_errata(struct enetc_si *si)
-{
-	if (si->pdev->revision == ENETC_REV1)
-		si->errata = ENETC_ERR_TXCSUM | ENETC_ERR_VLAN_ISOL |
-			     ENETC_ERR_UCMCSWP;
-}
-
-int enetc_pci_probe(struct pci_dev *pdev, const char *name, int sizeof_priv)
-{
-	struct enetc_si *si, *p;
-	struct enetc_hw *hw;
-	size_t alloc_size;
-	int err, len;
-
-	pcie_flr(pdev);
-	err = pci_enable_device_mem(pdev);
-	if (err) {
-		dev_err(&pdev->dev, "device enable failed\n");
-		return err;
-	}
-
-	/* set up for high or low dma */
-	err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
-	if (err) {
-		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
-		if (err) {
-			dev_err(&pdev->dev,
-				"DMA configuration failed: 0x%x\n", err);
-			goto err_dma;
-		}
-	}
-
-	err = pci_request_mem_regions(pdev, name);
-	if (err) {
-		dev_err(&pdev->dev, "pci_request_regions failed err=%d\n", err);
-		goto err_pci_mem_reg;
-	}
-
-	pci_set_master(pdev);
-
-	alloc_size = sizeof(struct enetc_si);
-	if (sizeof_priv) {
-		/* align priv to 32B */
-		alloc_size = ALIGN(alloc_size, ENETC_SI_ALIGN);
-		alloc_size += sizeof_priv;
-	}
-	/* force 32B alignment for enetc_si */
-	alloc_size += ENETC_SI_ALIGN - 1;
-
-	p = kzalloc(alloc_size, GFP_KERNEL);
-	if (!p) {
-		err = -ENOMEM;
-		goto err_alloc_si;
-	}
-
-	si = PTR_ALIGN(p, ENETC_SI_ALIGN);
-	si->pad = (char *)si - (char *)p;
-
-	pci_set_drvdata(pdev, si);
-	si->pdev = pdev;
-	hw = &si->hw;
-
-	len = pci_resource_len(pdev, ENETC_BAR_REGS);
-	hw->reg = ioremap(pci_resource_start(pdev, ENETC_BAR_REGS), len);
-	if (!hw->reg) {
-		err = -ENXIO;
-		dev_err(&pdev->dev, "ioremap() failed\n");
-		goto err_ioremap;
-	}
-	if (len > ENETC_PORT_BASE)
-		hw->port = hw->reg + ENETC_PORT_BASE;
-	if (len > ENETC_GLOBAL_BASE)
-		hw->global = hw->reg + ENETC_GLOBAL_BASE;
-
-	enetc_detect_errata(si);
-
-	return 0;
-
-err_ioremap:
-	enetc_kfree_si(si);
-err_alloc_si:
-	pci_release_mem_regions(pdev);
-err_pci_mem_reg:
-err_dma:
-	pci_disable_device(pdev);
-
-	return err;
-}
-
-void enetc_pci_remove(struct pci_dev *pdev)
-{
-	struct enetc_si *si = pci_get_drvdata(pdev);
-	struct enetc_hw *hw = &si->hw;
-
-	iounmap(hw->reg);
-	enetc_kfree_si(si);
-	pci_release_mem_regions(pdev);
-	pci_disable_device(pdev);
-}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc.h b/drivers/net/ethernet/freescale/enetc/enetc.h
deleted file mode 100644
index 9899b6175df7..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc.h
+++ /dev/null
@@ -1,284 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
-/* Copyright 2017-2019 NXP */
-
-#include <linux/timer.h>
-#include <linux/pci.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/dma-mapping.h>
-#include <linux/skbuff.h>
-#include <linux/ethtool.h>
-#include <linux/if_vlan.h>
-#include <linux/phy.h>
-#include <net/tsn.h>
-
-#include "enetc_hw.h"
-
-#define ENETC_MAC_MAXFRM_SIZE	9600
-#define ENETC_MAX_MTU		(ENETC_MAC_MAXFRM_SIZE - \
-				(ETH_FCS_LEN + ETH_HLEN + VLAN_HLEN))
-#define ENETC_CLK  400000000
-
-struct enetc_tx_swbd {
-	struct sk_buff *skb;
-	dma_addr_t dma;
-	u16 len;
-	u8 is_dma_page:1;
-	u8 check_wb:1;
-	u8 do_tstamp:1;
-	u8 qbv_en:1;
-};
-
-#define ENETC_RX_MAXFRM_SIZE	ENETC_MAC_MAXFRM_SIZE
-#define ENETC_RXB_TRUESIZE	2048 /* PAGE_SIZE >> 1 */
-#define ENETC_RXB_PAD		NET_SKB_PAD /* add extra space if needed */
-#define ENETC_RXB_DMA_SIZE	\
-	(SKB_WITH_OVERHEAD(ENETC_RXB_TRUESIZE) - ENETC_RXB_PAD)
-
-struct enetc_rx_swbd {
-	dma_addr_t dma;
-	struct page *page;
-	u16 page_offset;
-};
-
-struct enetc_ring_stats {
-	unsigned int packets;
-	unsigned int bytes;
-	unsigned int rx_alloc_errs;
-	unsigned int win_drop;
-};
-
-#define ENETC_BDR_DEFAULT_SIZE	1024
-#define ENETC_DEFAULT_TX_WORK	256
-
-struct enetc_bdr {
-	struct device *dev; /* for DMA mapping */
-	struct net_device *ndev;
-	void *bd_base; /* points to Rx or Tx BD ring */
-	union {
-		void __iomem *tpir;
-		void __iomem *rcir;
-	};
-	u16 index;
-	int bd_count; /* # of BDs */
-	int next_to_use;
-	int next_to_clean;
-	union {
-		struct enetc_tx_swbd *tx_swbd;
-		struct enetc_rx_swbd *rx_swbd;
-	};
-	union {
-		void __iomem *tcir; /* Tx */
-		int next_to_alloc; /* Rx */
-	};
-	void __iomem *idr; /* Interrupt Detect Register pointer */
-
-	struct enetc_ring_stats stats;
-
-	dma_addr_t bd_dma_base;
-} ____cacheline_aligned_in_smp;
-
-static inline void enetc_bdr_idx_inc(struct enetc_bdr *bdr, int *i)
-{
-	if (unlikely(++*i == bdr->bd_count))
-		*i = 0;
-}
-
-static inline int enetc_bd_unused(struct enetc_bdr *bdr)
-{
-	if (bdr->next_to_clean > bdr->next_to_use)
-		return bdr->next_to_clean - bdr->next_to_use - 1;
-
-	return bdr->bd_count + bdr->next_to_clean - bdr->next_to_use - 1;
-}
-
-/* Control BD ring */
-#define ENETC_CBDR_DEFAULT_SIZE	64
-struct enetc_cbdr {
-	void *bd_base; /* points to Rx or Tx BD ring */
-	void __iomem *pir;
-	void __iomem *cir;
-
-	int bd_count; /* # of BDs */
-	int next_to_use;
-	int next_to_clean;
-
-	dma_addr_t bd_dma_base;
-};
-
-#define ENETC_TXBD(BDR, i) (&(((union enetc_tx_bd *)((BDR).bd_base))[i]))
-#define ENETC_RXBD(BDR, i) (&(((union enetc_rx_bd *)((BDR).bd_base))[i]))
-
-struct enetc_msg_swbd {
-	void *vaddr;
-	dma_addr_t dma;
-	int size;
-};
-
-#ifdef CONFIG_ENETC_TSN
-/* Credit-Based Shaper parameters */
-struct cbs {
-	u8 tc;
-	bool enable;
-	u8 bw;
-	u32 hi_credit;
-	u32 lo_credit;
-	u32 idle_slope;
-	u32 send_slope;
-	u32 tc_max_sized_frame;
-	u32 max_interfrence_size;
-};
-
-struct enetc_cbs {
-	u32 port_transmit_rate;
-	u32 port_max_size_frame;
-	u8 tc_nums;
-	struct cbs cbs[0];
-};
-#endif
-
-#define ENETC_REV1	0x1
-enum enetc_errata {
-	ENETC_ERR_TXCSUM	= BIT(0),
-	ENETC_ERR_VLAN_ISOL	= BIT(1),
-	ENETC_ERR_UCMCSWP	= BIT(2),
-};
-
-/* PCI IEP device data */
-struct enetc_si {
-	struct pci_dev *pdev;
-	struct enetc_hw hw;
-	enum enetc_errata errata;
-
-	struct net_device *ndev; /* back ref. */
-
-	struct enetc_cbdr cbd_ring;
-
-	int num_rx_rings; /* how many rings are available in the SI */
-	int num_tx_rings;
-	int num_fs_entries;
-	int num_rss; /* number of RSS buckets */
-	unsigned short pad;
-#define ENETC_SI_F_QBV	BIT(0)
-	int hw_features;
-#ifdef CONFIG_ENETC_TSN
-	 struct enetc_cbs *ecbs;
-#endif
-};
-
-#define ENETC_SI_ALIGN	32
-
-static inline void *enetc_si_priv(const struct enetc_si *si)
-{
-	return (char *)si + ALIGN(sizeof(struct enetc_si), ENETC_SI_ALIGN);
-}
-
-static inline bool enetc_si_is_pf(struct enetc_si *si)
-{
-	return !!(si->hw.port);
-}
-
-#define ENETC_MAX_NUM_TXQS	8
-#define ENETC_INT_NAME_MAX	(IFNAMSIZ + 8)
-
-struct enetc_int_vector {
-	void __iomem *rbier;
-	void __iomem *tbier_base;
-	unsigned long tx_rings_map;
-	int count_tx_rings;
-	struct napi_struct napi;
-	char name[ENETC_INT_NAME_MAX];
-
-	struct enetc_bdr rx_ring ____cacheline_aligned_in_smp;
-	struct enetc_bdr tx_ring[0];
-};
-
-struct enetc_cls_rule {
-	struct ethtool_rx_flow_spec fs;
-	bool used;
-};
-
-#define ENETC_MAX_BDR_INT	2 /* fixed to max # of available cpus */
-
-enum enetc_hw_features {
-	ENETC_F_RX_TSTAMP	= BIT(0),
-	ENETC_F_TX_TSTAMP	= BIT(1),
-	ENETC_F_QBV		= BIT(2),
-};
-
-struct enetc_ndev_priv {
-	struct net_device *ndev;
-	struct device *dev; /* dma-mapping device */
-	struct enetc_si *si;
-
-	int bdr_int_num; /* number of Rx/Tx ring interrupts */
-	struct enetc_int_vector *int_vector[ENETC_MAX_BDR_INT];
-	u16 num_rx_rings, num_tx_rings;
-	u16 rx_bd_count, tx_bd_count;
-
-	u16 msg_enable;
-	enum enetc_hw_features hw_features;
-
-	struct enetc_bdr *tx_ring[16];
-	struct enetc_bdr *rx_ring[16];
-
-	struct enetc_cls_rule *cls_rules;
-
-	struct device_node *phy_node;
-	phy_interface_t if_mode;
-};
-
-/* Messaging */
-
-/* VF-PF set primary MAC address message format */
-struct enetc_msg_cmd_set_primary_mac {
-	struct enetc_msg_cmd_header header;
-	struct sockaddr mac;
-};
-
-#define ENETC_CBD(R, i)	(&(((struct enetc_cbd *)((R).bd_base))[i]))
-
-#define ENETC_CBDR_TIMEOUT	1000 /* usecs */
-
-/* SI common */
-int enetc_pci_probe(struct pci_dev *pdev, const char *name, int sizeof_priv);
-void enetc_pci_remove(struct pci_dev *pdev);
-int enetc_alloc_msix(struct enetc_ndev_priv *priv);
-void enetc_free_msix(struct enetc_ndev_priv *priv);
-void enetc_get_si_caps(struct enetc_si *si);
-void enetc_init_si_rings_params(struct enetc_ndev_priv *priv);
-int enetc_alloc_si_resources(struct enetc_ndev_priv *priv);
-void enetc_free_si_resources(struct enetc_ndev_priv *priv);
-
-int enetc_open(struct net_device *ndev);
-int enetc_close(struct net_device *ndev);
-netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev);
-struct net_device_stats *enetc_get_stats(struct net_device *ndev);
-int enetc_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-int enetc_set_features(struct net_device *ndev,
-		       netdev_features_t features);
-/* ethtool */
-void enetc_set_ethtool_ops(struct net_device *ndev);
-
-/* control buffer descriptor ring (CBDR) */
-int enetc_set_mac_flt_entry(struct enetc_si *si, int index,
-			    char *mac_addr, int si_map);
-int enetc_clear_mac_flt_entry(struct enetc_si *si, int index);
-int enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,
-		       int index);
-void enetc_set_rss_key(struct enetc_hw *hw, const u8 *bytes);
-int enetc_get_rss_table(struct enetc_si *si, u32 *table, int count);
-int enetc_set_rss_table(struct enetc_si *si, const u32 *table, int count);
-int enetc_setup_tc(struct net_device *ndev, enum tc_setup_type type,
-		   void *type_data);
-#ifdef CONFIG_ENETC_TSN
-void enetc_tsn_pf_init(struct net_device *netdev, struct pci_dev *pdev);
-void enetc_tsn_pf_deinit(struct net_device *netdev);
-#else
-#define enetc_tsn_pf_init(netdev, pdev) (void)0
-#define enetc_tsn_pf_deinit(netdev) (void)0
-#endif
-
-/* PTP driver exports */
-#define ENETC_PHC_INDEX_DEFAULT	-1
-extern int enetc_phc_index;
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c b/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
deleted file mode 100644
index de466b71bf8f..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c
+++ /dev/null
@@ -1,210 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include "enetc.h"
-
-static void enetc_clean_cbdr(struct enetc_si *si)
-{
-	struct enetc_cbdr *ring = &si->cbd_ring;
-	struct enetc_cbd *dest_cbd;
-	int i, status;
-
-	i = ring->next_to_clean;
-
-	while (enetc_rd_reg(ring->cir) != i) {
-		dest_cbd = ENETC_CBD(*ring, i);
-		status = dest_cbd->status_flags & ENETC_CBD_STATUS_MASK;
-		if (status)
-			dev_warn(&si->pdev->dev, "CMD err %04x for cmd %04x\n",
-				 status, dest_cbd->cmd);
-
-		memset(dest_cbd, 0, sizeof(*dest_cbd));
-
-		i = (i + 1) % ring->bd_count;
-	}
-
-	ring->next_to_clean = i;
-}
-
-static int enetc_cbd_unused(struct enetc_cbdr *r)
-{
-	return (r->next_to_clean - r->next_to_use - 1 + r->bd_count) %
-		r->bd_count;
-}
-
-static int enetc_send_cmd(struct enetc_si *si, struct enetc_cbd *cbd)
-{
-	struct enetc_cbdr *ring = &si->cbd_ring;
-	int timeout = ENETC_CBDR_TIMEOUT;
-	struct enetc_cbd *dest_cbd;
-	int i;
-
-	if (unlikely(!ring->bd_base))
-		return -EIO;
-
-	if (unlikely(!enetc_cbd_unused(ring)))
-		enetc_clean_cbdr(si);
-
-	i = ring->next_to_use;
-	dest_cbd = ENETC_CBD(*ring, i);
-
-	/* copy command to the ring */
-	*dest_cbd = *cbd;
-	i = (i + 1) % ring->bd_count;
-
-	ring->next_to_use = i;
-	/* let H/W know BD ring has been updated */
-	enetc_wr_reg(ring->pir, i);
-
-	do {
-		if (enetc_rd_reg(ring->cir) == i)
-			break;
-		udelay(10); /* cannot sleep, rtnl_lock() */
-		timeout -= 10;
-	} while (timeout);
-
-	if (!timeout)
-		return -EBUSY;
-
-	enetc_clean_cbdr(si);
-
-	return 0;
-}
-
-int enetc_clear_mac_flt_entry(struct enetc_si *si, int index)
-{
-	struct enetc_cbd cbd;
-
-	memset(&cbd, 0, sizeof(cbd));
-
-	cbd.cls = 1;
-	cbd.status_flags = ENETC_CBD_FLAGS_SF;
-	cbd.index = cpu_to_le16(index);
-
-	return enetc_send_cmd(si, &cbd);
-}
-
-int enetc_set_mac_flt_entry(struct enetc_si *si, int index,
-			    char *mac_addr, int si_map)
-{
-	struct enetc_cbd cbd;
-	u32 upper;
-	u16 lower;
-
-	memset(&cbd, 0, sizeof(cbd));
-
-	/* fill up the "set" descriptor */
-	cbd.cls = 1;
-	cbd.status_flags = ENETC_CBD_FLAGS_SF;
-	cbd.index = cpu_to_le16(index);
-	cbd.opt[3] = cpu_to_le32(si_map);
-	/* enable entry */
-	cbd.opt[0] = cpu_to_le32(BIT(31));
-
-	upper = *(const u32 *)mac_addr;
-	lower = *(const u16 *)(mac_addr + 4);
-	cbd.addr[0] = cpu_to_le32(upper);
-	cbd.addr[1] = cpu_to_le32(lower);
-
-	return enetc_send_cmd(si, &cbd);
-}
-
-#define RFSE_ALIGN	64
-/* Set entry in RFS table */
-int enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,
-		       int index)
-{
-	struct enetc_cbd cbd = {.cmd = 0};
-	dma_addr_t dma, dma_align;
-	void *tmp, *tmp_align;
-	int err;
-
-	/* fill up the "set" descriptor */
-	cbd.cmd = 0;
-	cbd.cls = 4;
-	cbd.index = cpu_to_le16(index);
-	cbd.length = cpu_to_le16(sizeof(*rfse));
-	cbd.opt[3] = cpu_to_le32(0); /* SI */
-
-	tmp = dma_alloc_coherent(&si->pdev->dev, sizeof(*rfse) + RFSE_ALIGN,
-				 &dma, GFP_KERNEL);
-	if (!tmp) {
-		dev_err(&si->pdev->dev, "DMA mapping of RFS entry failed!\n");
-		return -ENOMEM;
-	}
-
-	dma_align = ALIGN(dma, RFSE_ALIGN);
-	tmp_align = PTR_ALIGN(tmp, RFSE_ALIGN);
-	memcpy(tmp_align, rfse, sizeof(*rfse));
-
-	cbd.addr[0] = cpu_to_le32(lower_32_bits(dma_align));
-	cbd.addr[1] = cpu_to_le32(upper_32_bits(dma_align));
-
-	err = enetc_send_cmd(si, &cbd);
-	if (err)
-		dev_err(&si->pdev->dev, "FS entry add failed (%d)!", err);
-
-	dma_free_coherent(&si->pdev->dev, sizeof(*rfse) + RFSE_ALIGN,
-			  tmp, dma);
-
-	return err;
-}
-
-#define RSSE_ALIGN	64
-static int enetc_cmd_rss_table(struct enetc_si *si, u32 *table, int count,
-			       bool read)
-{
-	struct enetc_cbd cbd = {.cmd = 0};
-	dma_addr_t dma, dma_align;
-	u8 *tmp, *tmp_align;
-	int err, i;
-
-	if (count < RSSE_ALIGN)
-		/* HW only takes in a full 64 entry table */
-		return -EINVAL;
-
-	tmp = dma_alloc_coherent(&si->pdev->dev, count + RSSE_ALIGN,
-				 &dma, GFP_KERNEL);
-	if (!tmp) {
-		dev_err(&si->pdev->dev, "DMA mapping of RSS table failed!\n");
-		return -ENOMEM;
-	}
-	dma_align = ALIGN(dma, RSSE_ALIGN);
-	tmp_align = PTR_ALIGN(tmp, RSSE_ALIGN);
-
-	if (!read)
-		for (i = 0; i < count; i++)
-			tmp_align[i] = (u8)(table[i]);
-
-	/* fill up the descriptor */
-	cbd.cmd = read ? 2 : 1;
-	cbd.cls = 3;
-	cbd.length = cpu_to_le16(count);
-
-	cbd.addr[0] = cpu_to_le32(lower_32_bits(dma_align));
-	cbd.addr[1] = cpu_to_le32(upper_32_bits(dma_align));
-
-	err = enetc_send_cmd(si, &cbd);
-	if (err)
-		dev_err(&si->pdev->dev, "RSS cmd failed (%d)!", err);
-
-	if (read)
-		for (i = 0; i < count; i++)
-			table[i] = tmp_align[i];
-
-	dma_free_coherent(&si->pdev->dev, count + RSSE_ALIGN, tmp, dma);
-
-	return err;
-}
-
-/* Get RSS table */
-int enetc_get_rss_table(struct enetc_si *si, u32 *table, int count)
-{
-	return enetc_cmd_rss_table(si, table, count, true);
-}
-
-/* Set RSS table */
-int enetc_set_rss_table(struct enetc_si *si, const u32 *table, int count)
-{
-	return enetc_cmd_rss_table(si, (u32 *)table, count, false);
-}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c b/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
deleted file mode 100644
index a339c8889a7e..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c
+++ /dev/null
@@ -1,631 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include <linux/net_tstamp.h>
-#include <linux/module.h>
-#include "enetc.h"
-
-static const u32 enetc_si_regs[] = {
-	ENETC_SIMR, ENETC_SIPMAR0, ENETC_SIPMAR1, ENETC_SICBDRMR,
-	ENETC_SICBDRSR,	ENETC_SICBDRBAR0, ENETC_SICBDRBAR1, ENETC_SICBDRPIR,
-	ENETC_SICBDRCIR, ENETC_SICBDRLENR, ENETC_SICAPR0, ENETC_SICAPR1,
-	ENETC_SIUEFDCR
-};
-
-static const u32 enetc_txbdr_regs[] = {
-	ENETC_TBMR, ENETC_TBSR, ENETC_TBBAR0, ENETC_TBBAR1,
-	ENETC_TBPIR, ENETC_TBCIR, ENETC_TBLENR, ENETC_TBIER
-};
-
-static const u32 enetc_rxbdr_regs[] = {
-	ENETC_RBMR, ENETC_RBSR, ENETC_RBBSR, ENETC_RBCIR, ENETC_RBBAR0,
-	ENETC_RBBAR1, ENETC_RBPIR, ENETC_RBLENR, ENETC_RBICIR0, ENETC_RBIER
-};
-
-static const u32 enetc_port_regs[] = {
-	ENETC_PMR, ENETC_PSR, ENETC_PSIPMR, ENETC_PSIPMAR0(0),
-	ENETC_PSIPMAR1(0), ENETC_PTXMBAR, ENETC_PCAPR0, ENETC_PCAPR1,
-	ENETC_PSICFGR0(0), ENETC_PRFSCAPR, ENETC_PTCMSDUR(0),
-	ENETC_PM0_CMD_CFG, ENETC_PM0_MAXFRM, ENETC_PM0_IF_MODE
-};
-
-static int enetc_get_reglen(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	int len;
-
-	len = ARRAY_SIZE(enetc_si_regs);
-	len += ARRAY_SIZE(enetc_txbdr_regs) * priv->num_tx_rings;
-	len += ARRAY_SIZE(enetc_rxbdr_regs) * priv->num_rx_rings;
-
-	if (hw->port)
-		len += ARRAY_SIZE(enetc_port_regs);
-
-	len *= sizeof(u32) * 2; /* store 2 entries per reg: addr and value */
-
-	return len;
-}
-
-static void enetc_get_regs(struct net_device *ndev, struct ethtool_regs *regs,
-			   void *regbuf)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	u32 *buf = (u32 *)regbuf;
-	int i, j;
-	u32 addr;
-
-	for (i = 0; i < ARRAY_SIZE(enetc_si_regs); i++) {
-		*buf++ = enetc_si_regs[i];
-		*buf++ = enetc_rd(hw, enetc_si_regs[i]);
-	}
-
-	for (i = 0; i < priv->num_tx_rings; i++) {
-		for (j = 0; j < ARRAY_SIZE(enetc_txbdr_regs); j++) {
-			addr = ENETC_BDR(TX, i, enetc_txbdr_regs[j]);
-
-			*buf++ = addr;
-			*buf++ = enetc_rd(hw, addr);
-		}
-	}
-
-	for (i = 0; i < priv->num_rx_rings; i++) {
-		for (j = 0; j < ARRAY_SIZE(enetc_rxbdr_regs); j++) {
-			addr = ENETC_BDR(RX, i, enetc_rxbdr_regs[j]);
-
-			*buf++ = addr;
-			*buf++ = enetc_rd(hw, addr);
-		}
-	}
-
-	if (!hw->port)
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(enetc_port_regs); i++) {
-		addr = ENETC_PORT_BASE + enetc_port_regs[i];
-		*buf++ = addr;
-		*buf++ = enetc_rd(hw, addr);
-	}
-}
-
-static const struct {
-	int reg;
-	char name[ETH_GSTRING_LEN];
-} enetc_si_counters[] =  {
-	{ ENETC_SIROCT, "SI rx octets" },
-	{ ENETC_SIRFRM, "SI rx frames" },
-	{ ENETC_SIRUCA, "SI rx u-cast frames" },
-	{ ENETC_SIRMCA, "SI rx m-cast frames" },
-	{ ENETC_SITOCT, "SI tx octets" },
-	{ ENETC_SITFRM, "SI tx frames" },
-	{ ENETC_SITUCA, "SI tx u-cast frames" },
-	{ ENETC_SITMCA, "SI tx m-cast frames" },
-	{ ENETC_RBDCR(0), "Rx ring  0 discarded frames" },
-	{ ENETC_RBDCR(1), "Rx ring  1 discarded frames" },
-	{ ENETC_RBDCR(2), "Rx ring  2 discarded frames" },
-	{ ENETC_RBDCR(3), "Rx ring  3 discarded frames" },
-	{ ENETC_RBDCR(4), "Rx ring  4 discarded frames" },
-	{ ENETC_RBDCR(5), "Rx ring  5 discarded frames" },
-	{ ENETC_RBDCR(6), "Rx ring  6 discarded frames" },
-	{ ENETC_RBDCR(7), "Rx ring  7 discarded frames" },
-	{ ENETC_RBDCR(8), "Rx ring  8 discarded frames" },
-	{ ENETC_RBDCR(9), "Rx ring  9 discarded frames" },
-	{ ENETC_RBDCR(10), "Rx ring 10 discarded frames" },
-	{ ENETC_RBDCR(11), "Rx ring 11 discarded frames" },
-	{ ENETC_RBDCR(12), "Rx ring 12 discarded frames" },
-	{ ENETC_RBDCR(13), "Rx ring 13 discarded frames" },
-	{ ENETC_RBDCR(14), "Rx ring 14 discarded frames" },
-	{ ENETC_RBDCR(15), "Rx ring 15 discarded frames" },
-};
-
-static const struct {
-	int reg;
-	char name[ETH_GSTRING_LEN];
-} enetc_port_counters[] = {
-	{ ENETC_PM0_REOCT,  "MAC rx ethernet octets" },
-	{ ENETC_PM0_RALN,   "MAC rx alignment errors" },
-	{ ENETC_PM0_RXPF,   "MAC rx valid pause frames" },
-	{ ENETC_PM0_RFRM,   "MAC rx valid frames" },
-	{ ENETC_PM0_RFCS,   "MAC rx fcs errors" },
-	{ ENETC_PM0_RVLAN,  "MAC rx VLAN frames" },
-	{ ENETC_PM0_RERR,   "MAC rx frame errors" },
-	{ ENETC_PM0_RUCA,   "MAC rx unicast frames" },
-	{ ENETC_PM0_RMCA,   "MAC rx multicast frames" },
-	{ ENETC_PM0_RBCA,   "MAC rx broadcast frames" },
-	{ ENETC_PM0_RDRP,   "MAC rx dropped packets" },
-	{ ENETC_PM0_RPKT,   "MAC rx packets" },
-	{ ENETC_PM0_RUND,   "MAC rx undersized packets" },
-	{ ENETC_PM0_R64,    "MAC rx 64 byte packets" },
-	{ ENETC_PM0_R127,   "MAC rx 65-127 byte packets" },
-	{ ENETC_PM0_R255,   "MAC rx 128-255 byte packets" },
-	{ ENETC_PM0_R511,   "MAC rx 256-511 byte packets" },
-	{ ENETC_PM0_R1023,  "MAC rx 512-1023 byte packets" },
-	{ ENETC_PM0_R1518,  "MAC rx 1024-1518 byte packets" },
-	{ ENETC_PM0_R1519X, "MAC rx 1519 to max-octet packets" },
-	{ ENETC_PM0_ROVR,   "MAC rx oversized packets" },
-	{ ENETC_PM0_RJBR,   "MAC rx jabber packets" },
-	{ ENETC_PM0_RFRG,   "MAC rx fragment packets" },
-	{ ENETC_PM0_RCNP,   "MAC rx control packets" },
-	{ ENETC_PM0_RDRNTP, "MAC rx fifo drop" },
-	{ ENETC_PM0_TEOCT,  "MAC tx ethernet octets" },
-	{ ENETC_PM0_TOCT,   "MAC tx octets" },
-	{ ENETC_PM0_TCRSE,  "MAC tx carrier sense errors" },
-	{ ENETC_PM0_TXPF,   "MAC tx valid pause frames" },
-	{ ENETC_PM0_TFRM,   "MAC tx frames" },
-	{ ENETC_PM0_TFCS,   "MAC tx fcs errors" },
-	{ ENETC_PM0_TVLAN,  "MAC tx VLAN frames" },
-	{ ENETC_PM0_TERR,   "MAC tx frames" },
-	{ ENETC_PM0_TUCA,   "MAC tx unicast frames" },
-	{ ENETC_PM0_TMCA,   "MAC tx multicast frames" },
-	{ ENETC_PM0_TBCA,   "MAC tx broadcast frames" },
-	{ ENETC_PM0_TPKT,   "MAC tx packets" },
-	{ ENETC_PM0_TUND,   "MAC tx undersized packets" },
-	{ ENETC_PM0_T127,   "MAC tx 65-127 byte packets" },
-	{ ENETC_PM0_T1023,  "MAC tx 512-1023 byte packets" },
-	{ ENETC_PM0_T1518,  "MAC tx 1024-1518 byte packets" },
-	{ ENETC_PM0_TCNP,   "MAC tx control packets" },
-	{ ENETC_PM0_TDFR,   "MAC tx deferred packets" },
-	{ ENETC_PM0_TMCOL,  "MAC tx multiple collisions" },
-	{ ENETC_PM0_TSCOL,  "MAC tx single collisions" },
-	{ ENETC_PM0_TLCOL,  "MAC tx late collisions" },
-	{ ENETC_PM0_TECOL,  "MAC tx excessive collisions" },
-	{ ENETC_UFDMF,      "SI MAC nomatch u-cast discards" },
-	{ ENETC_MFDMF,      "SI MAC nomatch m-cast discards" },
-	{ ENETC_PBFDSIR,    "SI MAC nomatch b-cast discards" },
-	{ ENETC_PUFDVFR,    "SI VLAN nomatch u-cast discards" },
-	{ ENETC_PMFDVFR,    "SI VLAN nomatch m-cast discards" },
-	{ ENETC_PBFDVFR,    "SI VLAN nomatch b-cast discards" },
-	{ ENETC_PFDMSAPR,   "SI pruning discarded frames" },
-	{ ENETC_PICDR(0),   "ICM DR0 discarded frames" },
-	{ ENETC_PICDR(1),   "ICM DR1 discarded frames" },
-	{ ENETC_PICDR(2),   "ICM DR2 discarded frames" },
-	{ ENETC_PICDR(3),   "ICM DR3 discarded frames" },
-};
-
-static const char rx_ring_stats[][ETH_GSTRING_LEN] = {
-	"Rx ring %2d frames",
-	"Rx ring %2d alloc errors",
-};
-
-static const char tx_ring_stats[][ETH_GSTRING_LEN] = {
-	"Tx ring %2d frames",
-	"Tx window drop %2d frames",
-};
-
-static int enetc_get_sset_count(struct net_device *ndev, int sset)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	if (sset == ETH_SS_STATS)
-		return ARRAY_SIZE(enetc_si_counters) +
-			ARRAY_SIZE(tx_ring_stats) * priv->num_tx_rings +
-			ARRAY_SIZE(rx_ring_stats) * priv->num_rx_rings +
-			(enetc_si_is_pf(priv->si) ?
-			ARRAY_SIZE(enetc_port_counters) : 0);
-
-	return -EOPNOTSUPP;
-}
-
-static void enetc_get_strings(struct net_device *ndev, u32 stringset, u8 *data)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	u8 *p = data;
-	int i, j;
-
-	switch (stringset) {
-	case ETH_SS_STATS:
-		for (i = 0; i < ARRAY_SIZE(enetc_si_counters); i++) {
-			strlcpy(p, enetc_si_counters[i].name, ETH_GSTRING_LEN);
-			p += ETH_GSTRING_LEN;
-		}
-		for (i = 0; i < priv->num_tx_rings; i++) {
-			for (j = 0; j < ARRAY_SIZE(tx_ring_stats); j++) {
-				snprintf(p, ETH_GSTRING_LEN, tx_ring_stats[j],
-					 i);
-				p += ETH_GSTRING_LEN;
-			}
-		}
-		for (i = 0; i < priv->num_rx_rings; i++) {
-			for (j = 0; j < ARRAY_SIZE(rx_ring_stats); j++) {
-				snprintf(p, ETH_GSTRING_LEN, rx_ring_stats[j],
-					 i);
-				p += ETH_GSTRING_LEN;
-			}
-		}
-
-		if (!enetc_si_is_pf(priv->si))
-			break;
-
-		for (i = 0; i < ARRAY_SIZE(enetc_port_counters); i++) {
-			strlcpy(p, enetc_port_counters[i].name,
-				ETH_GSTRING_LEN);
-			p += ETH_GSTRING_LEN;
-		}
-		break;
-	}
-}
-
-static void enetc_get_ethtool_stats(struct net_device *ndev,
-				    struct ethtool_stats *stats, u64 *data)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	int i, o = 0;
-
-	for (i = 0; i < ARRAY_SIZE(enetc_si_counters); i++)
-		data[o++] = enetc_rd64(hw, enetc_si_counters[i].reg);
-
-	for (i = 0; i < priv->num_tx_rings; i++) {
-		data[o++] = priv->tx_ring[i]->stats.packets;
-		data[o++] = priv->tx_ring[i]->stats.win_drop;
-	}
-
-	for (i = 0; i < priv->num_rx_rings; i++) {
-		data[o++] = priv->rx_ring[i]->stats.packets;
-		data[o++] = priv->rx_ring[i]->stats.rx_alloc_errs;
-	}
-
-	if (!enetc_si_is_pf(priv->si))
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(enetc_port_counters); i++)
-		data[o++] = enetc_port_rd(hw, enetc_port_counters[i].reg);
-}
-
-#define ENETC_RSSHASH_L3 (RXH_L2DA | RXH_VLAN | RXH_L3_PROTO | RXH_IP_SRC | \
-			  RXH_IP_DST)
-#define ENETC_RSSHASH_L4 (ENETC_RSSHASH_L3 | RXH_L4_B_0_1 | RXH_L4_B_2_3)
-static int enetc_get_rsshash(struct ethtool_rxnfc *rxnfc)
-{
-	static const u32 rsshash[] = {
-			[TCP_V4_FLOW]    = ENETC_RSSHASH_L4,
-			[UDP_V4_FLOW]    = ENETC_RSSHASH_L4,
-			[SCTP_V4_FLOW]   = ENETC_RSSHASH_L4,
-			[AH_ESP_V4_FLOW] = ENETC_RSSHASH_L3,
-			[IPV4_FLOW]      = ENETC_RSSHASH_L3,
-			[TCP_V6_FLOW]    = ENETC_RSSHASH_L4,
-			[UDP_V6_FLOW]    = ENETC_RSSHASH_L4,
-			[SCTP_V6_FLOW]   = ENETC_RSSHASH_L4,
-			[AH_ESP_V6_FLOW] = ENETC_RSSHASH_L3,
-			[IPV6_FLOW]      = ENETC_RSSHASH_L3,
-			[ETHER_FLOW]     = 0,
-	};
-
-	if (rxnfc->flow_type >= ARRAY_SIZE(rsshash))
-		return -EINVAL;
-
-	rxnfc->data = rsshash[rxnfc->flow_type];
-
-	return 0;
-}
-
-/* current HW spec does byte reversal on everything including MAC addresses */
-static void ether_addr_copy_swap(u8 *dst, const u8 *src)
-{
-	int i;
-
-	for (i = 0; i < ETH_ALEN; i++)
-		dst[i] = src[ETH_ALEN - i - 1];
-}
-
-static int enetc_set_cls_entry(struct enetc_si *si,
-			       struct ethtool_rx_flow_spec *fs, bool en)
-{
-	struct ethtool_tcpip4_spec *l4ip4_h, *l4ip4_m;
-	struct ethtool_usrip4_spec *l3ip4_h, *l3ip4_m;
-	struct ethhdr *eth_h, *eth_m;
-	struct enetc_cmd_rfse rfse = { {0} };
-
-	if (!en)
-		goto done;
-
-	switch (fs->flow_type & 0xff) {
-	case TCP_V4_FLOW:
-		l4ip4_h = &fs->h_u.tcp_ip4_spec;
-		l4ip4_m = &fs->m_u.tcp_ip4_spec;
-		goto l4ip4;
-	case UDP_V4_FLOW:
-		l4ip4_h = &fs->h_u.udp_ip4_spec;
-		l4ip4_m = &fs->m_u.udp_ip4_spec;
-		goto l4ip4;
-	case SCTP_V4_FLOW:
-		l4ip4_h = &fs->h_u.sctp_ip4_spec;
-		l4ip4_m = &fs->m_u.sctp_ip4_spec;
-l4ip4:
-		rfse.sip_h[0] = l4ip4_h->ip4src;
-		rfse.sip_m[0] = l4ip4_m->ip4src;
-		rfse.dip_h[0] = l4ip4_h->ip4dst;
-		rfse.dip_m[0] = l4ip4_m->ip4dst;
-		rfse.sport_h = ntohs(l4ip4_h->psrc);
-		rfse.sport_m = ntohs(l4ip4_m->psrc);
-		rfse.dport_h = ntohs(l4ip4_h->pdst);
-		rfse.dport_m = ntohs(l4ip4_m->pdst);
-		if (l4ip4_m->tos)
-			netdev_warn(si->ndev, "ToS field is not supported and was ignored\n");
-		rfse.ethtype_h = ETH_P_IP; /* IPv4 */
-		rfse.ethtype_m = 0xffff;
-		break;
-	case IP_USER_FLOW:
-		l3ip4_h = &fs->h_u.usr_ip4_spec;
-		l3ip4_m = &fs->m_u.usr_ip4_spec;
-
-		rfse.sip_h[0] = l3ip4_h->ip4src;
-		rfse.sip_m[0] = l3ip4_m->ip4src;
-		rfse.dip_h[0] = l3ip4_h->ip4dst;
-		rfse.dip_m[0] = l3ip4_m->ip4dst;
-		if (l3ip4_m->tos)
-			netdev_warn(si->ndev, "ToS field is not supported and was ignored\n");
-		rfse.ethtype_h = ETH_P_IP; /* IPv4 */
-		rfse.ethtype_m = 0xffff;
-		break;
-	case ETHER_FLOW:
-		eth_h = &fs->h_u.ether_spec;
-		eth_m = &fs->m_u.ether_spec;
-
-		ether_addr_copy_swap(rfse.smac_h, eth_h->h_source);
-		ether_addr_copy_swap(rfse.smac_m, eth_m->h_source);
-		ether_addr_copy_swap(rfse.dmac_h, eth_h->h_dest);
-		ether_addr_copy_swap(rfse.dmac_m, eth_m->h_dest);
-		rfse.ethtype_h = ntohs(eth_h->h_proto);
-		rfse.ethtype_m = ntohs(eth_m->h_proto);
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	rfse.mode |= ENETC_RFSE_EN;
-	if (fs->ring_cookie != RX_CLS_FLOW_DISC) {
-		rfse.mode |= ENETC_RFSE_MODE_BD;
-		rfse.result = fs->ring_cookie;
-	}
-done:
-	return enetc_set_fs_entry(si, &rfse, fs->location);
-}
-
-static int enetc_get_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *rxnfc,
-			   u32 *rule_locs)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int i, j;
-
-	switch (rxnfc->cmd) {
-	case ETHTOOL_GRXRINGS:
-		rxnfc->data = priv->num_rx_rings;
-		break;
-	case ETHTOOL_GRXFH:
-		/* get RSS hash config */
-		return enetc_get_rsshash(rxnfc);
-	case ETHTOOL_GRXCLSRLCNT:
-		/* total number of entries */
-		rxnfc->data = priv->si->num_fs_entries;
-		/* number of entries in use */
-		rxnfc->rule_cnt = 0;
-		for (i = 0; i < priv->si->num_fs_entries; i++)
-			if (priv->cls_rules[i].used)
-				rxnfc->rule_cnt++;
-		break;
-	case ETHTOOL_GRXCLSRULE:
-		if (rxnfc->fs.location >= priv->si->num_fs_entries)
-			return -EINVAL;
-
-		/* get entry x */
-		rxnfc->fs = priv->cls_rules[rxnfc->fs.location].fs;
-		break;
-	case ETHTOOL_GRXCLSRLALL:
-		/* total number of entries */
-		rxnfc->data = priv->si->num_fs_entries;
-		/* array of indexes of used entries */
-		j = 0;
-		for (i = 0; i < priv->si->num_fs_entries; i++) {
-			if (!priv->cls_rules[i].used)
-				continue;
-			if (j == rxnfc->rule_cnt)
-				return -EMSGSIZE;
-			rule_locs[j++] = i;
-		}
-		/* number of entries in use */
-		rxnfc->rule_cnt = j;
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-static int enetc_set_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *rxnfc)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int err;
-
-	switch (rxnfc->cmd) {
-	case ETHTOOL_SRXCLSRLINS:
-		if (rxnfc->fs.location >= priv->si->num_fs_entries)
-			return -EINVAL;
-
-		if (rxnfc->fs.ring_cookie >= priv->num_rx_rings &&
-		    rxnfc->fs.ring_cookie != RX_CLS_FLOW_DISC)
-			return -EINVAL;
-
-		err = enetc_set_cls_entry(priv->si, &rxnfc->fs, true);
-		if (err)
-			return err;
-		priv->cls_rules[rxnfc->fs.location].fs = rxnfc->fs;
-		priv->cls_rules[rxnfc->fs.location].used = 1;
-		break;
-	case ETHTOOL_SRXCLSRLDEL:
-		if (rxnfc->fs.location >= priv->si->num_fs_entries)
-			return -EINVAL;
-
-		err = enetc_set_cls_entry(priv->si, &rxnfc->fs, false);
-		if (err)
-			return err;
-		priv->cls_rules[rxnfc->fs.location].used = 0;
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-static u32 enetc_get_rxfh_key_size(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	/* return the size of the RX flow hash key.  PF only */
-	return (priv->si->hw.port) ? ENETC_RSSHASH_KEY_SIZE : 0;
-}
-
-static u32 enetc_get_rxfh_indir_size(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	/* return the size of the RX flow hash indirection table */
-	return priv->si->num_rss;
-}
-
-static int enetc_get_rxfh(struct net_device *ndev, u32 *indir, u8 *key,
-			  u8 *hfunc)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	int err = 0, i;
-
-	/* return hash function */
-	if (hfunc)
-		*hfunc = ETH_RSS_HASH_TOP;
-
-	/* return hash key */
-	if (key && hw->port)
-		for (i = 0; i < ENETC_RSSHASH_KEY_SIZE / 4; i++)
-			((u32 *)key)[i] = enetc_port_rd(hw, ENETC_PRSSK(i));
-
-	/* return RSS table */
-	if (indir)
-		err = enetc_get_rss_table(priv->si, indir, priv->si->num_rss);
-
-	return err;
-}
-
-void enetc_set_rss_key(struct enetc_hw *hw, const u8 *bytes)
-{
-	int i;
-
-	for (i = 0; i < ENETC_RSSHASH_KEY_SIZE / 4; i++)
-		enetc_port_wr(hw, ENETC_PRSSK(i), ((u32 *)bytes)[i]);
-}
-
-static int enetc_set_rxfh(struct net_device *ndev, const u32 *indir,
-			  const u8 *key, const u8 hfunc)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	int err = 0;
-
-	/* set hash key, if PF */
-	if (key && hw->port)
-		enetc_set_rss_key(hw, key);
-
-	/* set RSS table */
-	if (indir)
-		err = enetc_set_rss_table(priv->si, indir, priv->si->num_rss);
-
-	return err;
-}
-
-static void enetc_get_ringparam(struct net_device *ndev,
-				struct ethtool_ringparam *ring)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	ring->rx_pending = priv->rx_bd_count;
-	ring->tx_pending = priv->tx_bd_count;
-
-	/* do some h/w sanity checks for BDR length */
-	if (netif_running(ndev)) {
-		struct enetc_hw *hw = &priv->si->hw;
-		u32 val = enetc_rxbdr_rd(hw, 0, ENETC_RBLENR);
-
-		if (val != priv->rx_bd_count)
-			netif_err(priv, hw, ndev, "RxBDR[RBLENR] = %d!\n", val);
-
-		val = enetc_txbdr_rd(hw, 0, ENETC_TBLENR);
-
-		if (val != priv->tx_bd_count)
-			netif_err(priv, hw, ndev, "TxBDR[TBLENR] = %d!\n", val);
-	}
-}
-
-static int enetc_get_ts_info(struct net_device *ndev,
-			     struct ethtool_ts_info *info)
-{
-	int *phc_idx;
-
-	phc_idx = symbol_get(enetc_phc_index);
-	if (phc_idx) {
-		info->phc_index = *phc_idx;
-		symbol_put(enetc_phc_index);
-	} else {
-		info->phc_index = ENETC_PHC_INDEX_DEFAULT;
-	}
-
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
-				SOF_TIMESTAMPING_RX_HARDWARE |
-				SOF_TIMESTAMPING_RAW_HARDWARE;
-
-	info->tx_types = (1 << HWTSTAMP_TX_OFF) |
-			 (1 << HWTSTAMP_TX_ON);
-	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
-			   (1 << HWTSTAMP_FILTER_ALL);
-#else
-	info->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |
-				SOF_TIMESTAMPING_SOFTWARE;
-#endif
-	return 0;
-}
-
-static const struct ethtool_ops enetc_pf_ethtool_ops = {
-	.get_regs_len = enetc_get_reglen,
-	.get_regs = enetc_get_regs,
-	.get_sset_count = enetc_get_sset_count,
-	.get_strings = enetc_get_strings,
-	.get_ethtool_stats = enetc_get_ethtool_stats,
-	.get_rxnfc = enetc_get_rxnfc,
-	.set_rxnfc = enetc_set_rxnfc,
-	.get_rxfh_key_size = enetc_get_rxfh_key_size,
-	.get_rxfh_indir_size = enetc_get_rxfh_indir_size,
-	.get_rxfh = enetc_get_rxfh,
-	.set_rxfh = enetc_set_rxfh,
-	.get_ringparam = enetc_get_ringparam,
-	.get_ts_info = enetc_get_ts_info,
-	.get_link_ksettings = phy_ethtool_get_link_ksettings,
-	.set_link_ksettings = phy_ethtool_set_link_ksettings,
-};
-
-static const struct ethtool_ops enetc_vf_ethtool_ops = {
-	.get_regs_len = enetc_get_reglen,
-	.get_regs = enetc_get_regs,
-	.get_sset_count = enetc_get_sset_count,
-	.get_strings = enetc_get_strings,
-	.get_ethtool_stats = enetc_get_ethtool_stats,
-	.get_rxnfc = enetc_get_rxnfc,
-	.set_rxnfc = enetc_set_rxnfc,
-	.get_rxfh_indir_size = enetc_get_rxfh_indir_size,
-	.get_rxfh = enetc_get_rxfh,
-	.set_rxfh = enetc_set_rxfh,
-	.get_ringparam = enetc_get_ringparam,
-	.get_ts_info = enetc_get_ts_info,
-};
-
-void enetc_set_ethtool_ops(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	if (enetc_si_is_pf(priv->si))
-		ndev->ethtool_ops = &enetc_pf_ethtool_ops;
-	else
-		ndev->ethtool_ops = &enetc_vf_ethtool_ops;
-}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_hw.h b/drivers/net/ethernet/freescale/enetc/enetc_hw.h
deleted file mode 100644
index 9502e44448df..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_hw.h
+++ /dev/null
@@ -1,1045 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
-/* Copyright 2017-2019 NXP */
-
-#include <linux/bitops.h>
-
-/* ENETC device IDs */
-#define ENETC_DEV_ID_PF	0xe100
-#define ENETC_DEV_ID_VF	0xef00
-#define ENETC_DEV_ID_PTP	0xee02
-
-/* ENETC register block BAR */
-#define ENETC_BAR_REGS	0
-
-/** SI regs, offset: 0h */
-#define ENETC_SIMR	0
-#define ENETC_SIMR_EN	BIT(31)
-#define ENETC_SIMR_RSSE	BIT(0)
-#define ENETC_SICTR0	0x18
-#define ENETC_SICTR1	0x1c
-#define ENETC_SIPCAPR0	0x20
-#define ENETC_SIPCAPR0_QBV	BIT(4)
-#define ENETC_SIPCAPR0_RSS	BIT(8)
-#define ENETC_SIPCAPR1	0x24
-#define ENETC_SITGTGR	0x30
-#define ENETC_SIRBGCR	0x38
-/* cache attribute registers for transactions initiated by ENETC */
-#define ENETC_SICAR0	0x40
-#define ENETC_SICAR1	0x44
-#define ENETC_SICAR2	0x48
-/* rd snoop, no alloc
- * wr snoop, no alloc, partial cache line update for BDs and full cache line
- * update for data
- */
-#define ENETC_SICAR_RD_COHERENT	0x2b2b0000
-#define ENETC_SICAR_WR_COHERENT	0x00006727
-#define ENETC_SICAR_MSI	0x00300030 /* rd/wr device, no snoop, no alloc */
-
-#define ENETC_SIPMAR0	0x80
-#define ENETC_SIPMAR1	0x84
-
-/* VF-PF Message passing */
-#define ENETC_DEFAULT_MSG_SIZE	1024	/* and max size */
-/* msg size encoding: default and max msg value of 1024B encoded as 0 */
-static inline u32 enetc_vsi_set_msize(u32 size)
-{
-	return size < ENETC_DEFAULT_MSG_SIZE ? size >> 5 : 0;
-}
-
-#define ENETC_PSIMSGRR	0x204
-#define ENETC_PSIMSGRR_MR_MASK	GENMASK(2, 1)
-#define ENETC_PSIMSGRR_MR(n) BIT((n) + 1) /* n = VSI index */
-#define ENETC_PSIVMSGRCVAR0(n)	(0x210 + (n) * 0x8) /* n = VSI index */
-#define ENETC_PSIVMSGRCVAR1(n)	(0x214 + (n) * 0x8)
-
-#define ENETC_VSIMSGSR	0x204	/* RO */
-#define ENETC_VSIMSGSR_MB	BIT(0)
-#define ENETC_VSIMSGSR_MS	BIT(1)
-#define ENETC_VSIMSGSNDAR0	0x210
-#define ENETC_VSIMSGSNDAR1	0x214
-
-#define ENETC_SIMSGSR_SET_MC(val) ((val) << 16)
-#define ENETC_SIMSGSR_GET_MC(val) ((val) >> 16)
-
-/* SI statistics */
-#define ENETC_SIROCT	0x300
-#define ENETC_SIRFRM	0x308
-#define ENETC_SIRUCA	0x310
-#define ENETC_SIRMCA	0x318
-#define ENETC_SITOCT	0x320
-#define ENETC_SITFRM	0x328
-#define ENETC_SITUCA	0x330
-#define ENETC_SITMCA	0x338
-#define ENETC_RBDCR(n)	(0x8180 + (n) * 0x200)
-
-/* Control BDR regs */
-#define ENETC_SICBDRMR		0x800
-#define ENETC_SICBDRSR		0x804	/* RO */
-#define ENETC_SICBDRBAR0	0x810
-#define ENETC_SICBDRBAR1	0x814
-#define ENETC_SICBDRPIR		0x818
-#define ENETC_SICBDRCIR		0x81c
-#define ENETC_SICBDRLENR	0x820
-
-#define ENETC_SICAPR0	0x900
-#define ENETC_SICAPR1	0x904
-
-#define ENETC_PSIIER	0xa00
-#define ENETC_PSIIER_MR_MASK	GENMASK(2, 1)
-#define ENETC_PSIIDR	0xa08
-#define ENETC_SITXIDR	0xa18
-#define ENETC_SIRXIDR	0xa28
-#define ENETC_SIMSIVR	0xa30
-
-#define ENETC_SIMSITRV(n) (0xB00 + (n) * 0x4)
-#define ENETC_SIMSIRRV(n) (0xB80 + (n) * 0x4)
-
-#define ENETC_SIUEFDCR	0xe28
-
-#define ENETC_SIRFSCAPR	0x1200
-#define ENETC_SIRFSCAPR_GET_NUM_RFS(val) ((val) & 0x7f)
-#define ENETC_SIRSSCAPR	0x1600
-#define ENETC_SIRSSCAPR_GET_NUM_RSS(val) (BIT((val) & 0xf) * 32)
-
-/** SI BDR sub-blocks, n = 0..7 */
-enum enetc_bdr_type {TX, RX};
-#define ENETC_BDR_OFF(i)	((i) * 0x200)
-#define ENETC_BDR(t, i, r)	(0x8000 + (t) * 0x100 + ENETC_BDR_OFF(i) + (r))
-/* RX BDR reg offsets */
-#define ENETC_RBMR	0
-#define ENETC_RBMR_BDS	BIT(2)
-#define ENETC_RBMR_VTE	BIT(5)
-#define ENETC_RBMR_EN	BIT(31)
-#define ENETC_RBSR	0x4
-#define ENETC_RBBSR	0x8
-#define ENETC_RBCIR	0xc
-#define ENETC_RBBAR0	0x10
-#define ENETC_RBBAR1	0x14
-#define ENETC_RBPIR	0x18
-#define ENETC_RBLENR	0x20
-#define ENETC_RBIER	0xa0
-#define ENETC_RBIER_RXTIE	BIT(0)
-#define ENETC_RBIDR	0xa4
-#define ENETC_RBICIR0	0xa8
-#define ENETC_RBICIR0_ICEN	BIT(31)
-
-/* TX BDR reg offsets */
-#define ENETC_TBMR	0
-#define ENETC_TBSR_BUSY	BIT(0)
-#define ENETC_TBMR_VIH	BIT(9)
-#define ENETC_TBMR_PRIO_MASK		GENMASK(2, 0)
-#define ENETC_TBMR_PRIO_SET(val)	val
-#define ENETC_TBMR_EN	BIT(31)
-#define ENETC_TBSR	0x4
-#define ENETC_TBBAR0	0x10
-#define ENETC_TBBAR1	0x14
-#define ENETC_TBPIR	0x18
-#define ENETC_TBCIR	0x1c
-#define ENETC_TBCIR_IDX_MASK	0xffff
-#define ENETC_TBLENR	0x20
-#define ENETC_TBIER	0xa0
-#define ENETC_TBIER_TXTIE	BIT(0)
-#define ENETC_TBIDR	0xa4
-#define ENETC_TBICIR0	0xa8
-#define ENETC_TBICIR0_ICEN	BIT(31)
-
-#define ENETC_RTBLENR_LEN(n)	((n) & ~0x7)
-
-/* Port regs, offset: 1_0000h */
-#define ENETC_PORT_BASE		0x10000
-#define ENETC_PMR		0x0000
-#define ENETC_PMR_EN	GENMASK(18, 16)
-#define ENETC_PSR		0x0004 /* RO */
-#define ENETC_PSIPMR		0x0018
-#define ENETC_PSIPMR_SET_UP(n)	BIT(n) /* n = SI index */
-#define ENETC_PSIPMR_SET_MP(n)	BIT((n) + 16)
-#define ENETC_PSIPVMR		0x001c
-#define ENETC_VLAN_PROMISC_MAP_ALL	0x7
-#define ENETC_PSIPVMR_SET_VP(simap)	((simap) & 0x7)
-#define ENETC_PSIPVMR_SET_VUTA(simap)	(((simap) & 0x7) << 16)
-#define ENETC_PSIPMAR0(n)	(0x0100 + (n) * 0x8) /* n = SI index */
-#define ENETC_PSIPMAR1(n)	(0x0104 + (n) * 0x8)
-#define ENETC_PVCLCTR		0x0208
-#define ENETC_VLAN_TYPE_C	BIT(0)
-#define ENETC_VLAN_TYPE_S	BIT(1)
-#define ENETC_PVCLCTR_OVTPIDL(bmp)	((bmp) & 0xff) /* VLAN_TYPE */
-#define ENETC_PSIVLANR(n)	(0x0240 + (n) * 4) /* n = SI index */
-#define ENETC_PSIVLAN_EN	BIT(31)
-#define ENETC_PSIVLAN_SET_QOS(val)	((u32)(val) << 12)
-#define ENETC_PTXMBAR		0x0608
-#define ENETC_PCAPR0		0x0900
-#define ENETC_PCAPR0_RXBDR(val)	((val) >> 24)
-#define ENETC_PCAPR0_TXBDR(val)	(((val) >> 16) & 0xff)
-#define ENETC_PCAPR1		0x0904
-#define ENETC_PSICFGR0(n)	(0x0940 + (n) * 0xc)  /* n = SI index */
-#define ENETC_PSICFGR0_SET_TXBDR(val)	((val) & 0xff)
-#define ENETC_PSICFGR0_SET_RXBDR(val)	(((val) & 0xff) << 16)
-#define ENETC_PSICFGR0_VTE	BIT(12)
-#define ENETC_PSICFGR0_SIVIE	BIT(14)
-#define ENETC_PSICFGR0_ASE	BIT(15)
-#define ENETC_PSICFGR0_SIVC(bmp)	(((bmp) & 0xff) << 24) /* VLAN_TYPE */
-
-#define ENETC_PTCCBSR0(n)	(0x1110 + (n) * 8) /* n = 0 to 7*/
-#define ENETC_PTCCBSR1(n)	(0x1114 + (n) * 8) /* n = 0 to 7*/
-#define ENETC_RSSHASH_KEY_SIZE	40
-#define ENETC_PRSSK(n)		(0x1410 + (n) * 4) /* n = [0..9] */
-#define ENETC_PSIVLANFMR	0x1700
-#define ENETC_PSIVLANFMR_VS	BIT(0)
-#define ENETC_PRFSMR		0x1800
-#define ENETC_PRFSMR_RFSE	BIT(31)
-#define ENETC_PRFSCAPR		0x1804
-#define ENETC_PRFSCAPR_GET_NUM_RFS(val)	((((val) & 0xf) + 1) * 16)
-#define ENETC_PSIRFSCFGR(n)	(0x1814 + (n) * 4) /* n = SI index */
-#define ENETC_PFPMR		0x1900
-#define ENETC_PFPMR_PMACE	BIT(1)
-#define ENETC_PFPMR_MWLM	BIT(0)
-#define ENETC_PSIUMHFR0(n, err)	(((err) ? 0x1d08 : 0x1d00) + (n) * 0x10)
-#define ENETC_PSIUMHFR1(n)	(0x1d04 + (n) * 0x10)
-#define ENETC_PSIMMHFR0(n, err)	(((err) ? 0x1d00 : 0x1d08) + (n) * 0x10)
-#define ENETC_PSIMMHFR1(n)	(0x1d0c + (n) * 0x10)
-#define ENETC_PSIVHFR0(n)	(0x1e00 + (n) * 8) /* n = SI index */
-#define ENETC_PSIVHFR1(n)	(0x1e04 + (n) * 8) /* n = SI index */
-#define ENETC_MMCSR		0x1f00
-#define ENETC_MMCSR_ME		BIT(16)
-#define ENETC_PTCMSDUR(n)	(0x2020 + (n) * 4) /* n = TC index [0..7] */
-
-#define ENETC_PM0_CMD_CFG	0x8008
-#define ENETC_PM1_CMD_CFG	0x9008
-#define ENETC_PM0_TX_EN		BIT(0)
-#define ENETC_PM0_RX_EN		BIT(1)
-#define ENETC_PM0_PROMISC	BIT(4)
-#define ENETC_PM0_CMD_XGLP	BIT(10)
-#define ENETC_PM0_CMD_TXP	BIT(11)
-#define ENETC_PM0_CMD_PHY_TX_EN	BIT(15)
-#define ENETC_PM0_CMD_SFD	BIT(21)
-#define ENETC_PM0_MAXFRM	0x8014
-#define ENETC_SET_TX_MTU(val)	((val) << 16)
-#define ENETC_SET_MAXFRM(val)	((val) & 0xffff)
-#define ENETC_PM0_IF_MODE	0x8300
-#define ENETC_PM1_IF_MODE	0x9300
-#define ENETC_PMO_IFM_RG	BIT(2)
-#define ENETC_PM0_IFM_RLP	(BIT(5) | BIT(11))
-#define ENETC_PM0_IFM_RGAUTO	(BIT(15) | ENETC_PMO_IFM_RG | BIT(1))
-#define ENETC_PM0_IFM_XGMII	BIT(12)
-
-/* MAC counters */
-#define ENETC_PM0_REOCT		0x8100
-#define ENETC_PM0_RALN		0x8110
-#define ENETC_PM0_RXPF		0x8118
-#define ENETC_PM0_RFRM		0x8120
-#define ENETC_PM0_RFCS		0x8128
-#define ENETC_PM0_RVLAN		0x8130
-#define ENETC_PM0_RERR		0x8138
-#define ENETC_PM0_RUCA		0x8140
-#define ENETC_PM0_RMCA		0x8148
-#define ENETC_PM0_RBCA		0x8150
-#define ENETC_PM0_RDRP		0x8158
-#define ENETC_PM0_RPKT		0x8160
-#define ENETC_PM0_RUND		0x8168
-#define ENETC_PM0_R64		0x8170
-#define ENETC_PM0_R127		0x8178
-#define ENETC_PM0_R255		0x8180
-#define ENETC_PM0_R511		0x8188
-#define ENETC_PM0_R1023		0x8190
-#define ENETC_PM0_R1518		0x8198
-#define ENETC_PM0_R1519X	0x81A0
-#define ENETC_PM0_ROVR		0x81A8
-#define ENETC_PM0_RJBR		0x81B0
-#define ENETC_PM0_RFRG		0x81B8
-#define ENETC_PM0_RCNP		0x81C0
-#define ENETC_PM0_RDRNTP	0x81C8
-#define ENETC_PM0_TEOCT		0x8200
-#define ENETC_PM0_TOCT		0x8208
-#define ENETC_PM0_TCRSE		0x8210
-#define ENETC_PM0_TXPF		0x8218
-#define ENETC_PM0_TFRM		0x8220
-#define ENETC_PM0_TFCS		0x8228
-#define ENETC_PM0_TVLAN		0x8230
-#define ENETC_PM0_TERR		0x8238
-#define ENETC_PM0_TUCA		0x8240
-#define ENETC_PM0_TMCA		0x8248
-#define ENETC_PM0_TBCA		0x8250
-#define ENETC_PM0_TPKT		0x8260
-#define ENETC_PM0_TUND		0x8268
-#define ENETC_PM0_T127		0x8278
-#define ENETC_PM0_T1023		0x8290
-#define ENETC_PM0_T1518		0x8298
-#define ENETC_PM0_TCNP		0x82C0
-#define ENETC_PM0_TDFR		0x82D0
-#define ENETC_PM0_TMCOL		0x82D8
-#define ENETC_PM0_TSCOL		0x82E0
-#define ENETC_PM0_TLCOL		0x82E8
-#define ENETC_PM0_TECOL		0x82F0
-
-/* Port counters */
-#define ENETC_PICDR(n)		(0x0700 + (n) * 8) /* n = [0..3] */
-#define ENETC_PBFDSIR		0x0810
-#define ENETC_PFDMSAPR		0x0814
-#define ENETC_UFDMF		0x1680
-#define ENETC_MFDMF		0x1684
-#define ENETC_PUFDVFR		0x1780
-#define ENETC_PMFDVFR		0x1784
-#define ENETC_PBFDVFR		0x1788
-
-/** Global regs, offset: 2_0000h */
-#define ENETC_GLOBAL_BASE	0x20000
-#define ENETC_G_EIPBRR0		0x0bf8
-#define ENETC_G_EIPBRR1		0x0bfc
-#define ENETC_G_EPFBLPR(n)	(0xd00 + 4 * (n))
-#define ENETC_G_EPFBLPR1_XGMII	0x80000000
-
-
-/* PCI device info */
-struct enetc_hw {
-	/* SI registers, used by all PCI functions */
-	void __iomem *reg;
-	/* Port registers, PF only */
-	void __iomem *port;
-	/* IP global registers, PF only */
-	void __iomem *global;
-};
-
-/* general register accessors */
-#define enetc_rd_reg(reg)	ioread32((reg))
-#define enetc_wr_reg(reg, val)	iowrite32((val), (reg))
-#ifdef ioread64
-#define enetc_rd_reg64(reg)	ioread64((reg))
-#else
-/* using this to read out stats on 32b systems */
-static inline u64 enetc_rd_reg64(void __iomem *reg)
-{
-	u32 low, high, tmp;
-
-	do {
-		high = ioread32(reg + 4);
-		low = ioread32(reg);
-		tmp = ioread32(reg + 4);
-	} while (high != tmp);
-
-	return le64_to_cpu((__le64)high << 32 | low);
-}
-#endif
-
-#define enetc_rd(hw, off)		enetc_rd_reg((hw)->reg + (off))
-#define enetc_wr(hw, off, val)		enetc_wr_reg((hw)->reg + (off), val)
-#define enetc_rd64(hw, off)		enetc_rd_reg64((hw)->reg + (off))
-/* port register accessors - PF only */
-#define enetc_port_rd(hw, off)		enetc_rd_reg((hw)->port + (off))
-#define enetc_port_wr(hw, off, val)	enetc_wr_reg((hw)->port + (off), val)
-/* global register accessors - PF only */
-#define enetc_global_rd(hw, off)	enetc_rd_reg((hw)->global + (off))
-#define enetc_global_wr(hw, off, val)	enetc_wr_reg((hw)->global + (off), val)
-/* BDR register accessors, see ENETC_BDR() */
-#define enetc_bdr_rd(hw, t, n, off) \
-				enetc_rd(hw, ENETC_BDR(t, n, off))
-#define enetc_bdr_wr(hw, t, n, off, val) \
-				enetc_wr(hw, ENETC_BDR(t, n, off), val)
-#define enetc_txbdr_rd(hw, n, off) enetc_bdr_rd(hw, TX, n, off)
-#define enetc_rxbdr_rd(hw, n, off) enetc_bdr_rd(hw, RX, n, off)
-#define enetc_txbdr_wr(hw, n, off, val) \
-				enetc_bdr_wr(hw, TX, n, off, val)
-#define enetc_rxbdr_wr(hw, n, off, val) \
-				enetc_bdr_wr(hw, RX, n, off, val)
-
-/* Buffer Descriptors (BD) */
-union enetc_tx_bd {
-	struct {
-		__le64 addr;
-		__le16 buf_len;
-		__le16 frm_len;
-		union {
-			struct {
-				__le16 l3_csoff;
-				u8 l4_csoff;
-				u8 flags;
-			}; /* default layout */
-			__le32 lstatus;
-		};
-	};
-	struct {
-		__le32 tstamp;
-		__le16 tpid;
-		__le16 vid;
-		u8 reserved[6];
-		u8 e_flags;
-		u8 flags;
-	} ext; /* Tx BD extension */
-	struct {
-		__le32 tstamp;
-		u8 reserved[10];
-		u8 status;
-		u8 flags;
-	} wb; /* writeback descriptor */
-};
-
-#define ENETC_TXBD_FLAGS_L4CS	BIT(0)
-#define ENETC_TXBD_FLAGS_W	BIT(2)
-#define ENETC_TXBD_FLAGS_CSUM	BIT(3)
-#define ENETC_TXBD_FLAGS_EX	BIT(6)
-#define ENETC_TXBD_FLAGS_F	BIT(7)
-#define ENETC_TXBD_STATS_WIN	BIT(7)
-
-static inline void enetc_clear_tx_bd(union enetc_tx_bd *txbd)
-{
-	memset(txbd, 0, sizeof(*txbd));
-}
-
-/* L3 csum flags */
-#define ENETC_TXBD_L3_IPCS	BIT(7)
-#define ENETC_TXBD_L3_IPV6	BIT(15)
-
-#define ENETC_TXBD_L3_START_MASK	GENMASK(6, 0)
-#define ENETC_TXBD_L3_SET_HSIZE(val)	((((val) >> 2) & 0x7f) << 8)
-
-/* Extension flags */
-#define ENETC_TXBD_E_FLAGS_VLAN_INS	BIT(0)
-#define ENETC_TXBD_E_FLAGS_TWO_STEP_PTP	BIT(2)
-
-static inline __le16 enetc_txbd_l3_csoff(int start, int hdr_sz, u16 l3_flags)
-{
-	return cpu_to_le16(l3_flags | ENETC_TXBD_L3_SET_HSIZE(hdr_sz) |
-			   (start & ENETC_TXBD_L3_START_MASK));
-}
-
-/* L4 csum flags */
-#define ENETC_TXBD_L4_UDP	BIT(5)
-#define ENETC_TXBD_L4_TCP	BIT(6)
-
-// TODO: Add support for dynamic allocation of BD rings to replace #ifdefs
-#define enetc_has_extended_rxbds() IS_ENABLED(CONFIG_FSL_ENETC_HW_TIMESTAMPING)
-#define enetc_tsn_is_enabled() IS_ENABLED(CONFIG_ENETC_TSN)
-
-union enetc_rx_bd {
-	struct {
-		__le64 addr;
-		u8 reserved[8];
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-		u8 reserved1[16];
-#endif
-	} w;
-	struct {
-		__le16 inet_csum;
-		__le16 parse_summary;
-		__le32 rss_hash;
-		__le16 buf_len;
-		__le16 vlan_opt;
-		union {
-			struct {
-				__le16 flags;
-				__le16 error;
-			};
-			__le32 lstatus;
-		};
-#ifdef CONFIG_FSL_ENETC_HW_TIMESTAMPING
-		__le32 tstamp;
-		u8 reserved[12];
-#endif
-	} r;
-};
-
-#define ENETC_RXBD_LSTATUS_R	BIT(30)
-#define ENETC_RXBD_LSTATUS_F	BIT(31)
-#define ENETC_RXBD_ERR_MASK	0xff
-#define ENETC_RXBD_LSTATUS(flags)	((flags) << 16)
-#define ENETC_RXBD_FLAG_VLAN	BIT(9)
-#define ENETC_RXBD_FLAG_TSTMP	BIT(10)
-
-#define ENETC_MAC_ADDR_FILT_CNT	8 /* # of supported entries per port */
-#define EMETC_MAC_ADDR_FILT_RES	3 /* # of reserved entries at the beginning */
-#define ENETC_MAX_NUM_VFS	2
-
-#ifndef CONFIG_ENETC_TSN
-struct enetc_cbd {
-	union {
-		struct {
-			__le32 addr[2];
-			__le32 opt[4];
-		};
-		__le32 data[6];
-	};
-	__le16 index;
-	__le16 length;
-	u8 cmd;
-	u8 cls;
-	u8 _res;
-	u8 status_flags;
-};
-#endif
-
-#define ENETC_CBD_FLAGS_SF	BIT(7) /* short format */
-#define ENETC_CBD_STATUS_MASK	0xf
-
-struct enetc_cmd_rfse {
-	u8 smac_h[6];
-	u8 smac_m[6];
-	u8 dmac_h[6];
-	u8 dmac_m[6];
-	u32 sip_h[4];
-	u32 sip_m[4];
-	u32 dip_h[4];
-	u32 dip_m[4];
-	u16 ethtype_h;
-	u16 ethtype_m;
-	u16 ethtype4_h;
-	u16 ethtype4_m;
-	u16 sport_h;
-	u16 sport_m;
-	u16 dport_h;
-	u16 dport_m;
-	u16 vlan_h;
-	u16 vlan_m;
-	u8 proto_h;
-	u8 proto_m;
-	u16 flags;
-	u16 result;
-	u16 mode;
-};
-
-#define ENETC_RFSE_EN	BIT(15)
-#define ENETC_RFSE_MODE_BD	2
-
-static inline void enetc_get_primary_mac_addr(struct enetc_hw *hw, u8 *addr)
-{
-	*(u32 *)addr = __raw_readl(hw->reg + ENETC_SIPMAR0);
-	*(u16 *)(addr + 4) = __raw_readw(hw->reg + ENETC_SIPMAR1);
-}
-
-#define ENETC_SI_INT_IDX	0
-/* base index for Rx/Tx interrupts */
-#define ENETC_BDR_INT_BASE_IDX	1
-
-/* Messaging */
-
-/* Command completion status */
-enum enetc_msg_cmd_status {
-	ENETC_MSG_CMD_STATUS_OK,
-	ENETC_MSG_CMD_STATUS_FAIL
-};
-
-/* VSI-PSI command message types */
-enum enetc_msg_cmd_type {
-	ENETC_MSG_CMD_MNG_MAC = 1, /* manage MAC address */
-	ENETC_MSG_CMD_MNG_RX_MAC_FILTER,/* manage RX MAC table */
-	ENETC_MSG_CMD_MNG_RX_VLAN_FILTER /* manage RX VLAN table */
-};
-
-/* VS-PSI command action types */
-enum enetc_msg_cmd_action_type {
-	ENETC_MSG_CMD_MNG_ADD = 1,
-	ENETC_MSG_CMD_MNG_REMOVE
-};
-
-/* PSI-VSI command header format */
-struct enetc_msg_cmd_header {
-	u16 type;	/* command class type */
-	u16 id;		/* denotes the specific required action */
-};
-
-/* Common H/W utility functions */
-
-static inline void enetc_enable_rxvlan(struct enetc_hw *hw, int si_idx,
-				       bool en)
-{
-	u32 val = enetc_rxbdr_rd(hw, si_idx, ENETC_RBMR);
-
-	val = (val & ~ENETC_RBMR_VTE) | (en ? ENETC_RBMR_VTE : 0);
-	enetc_rxbdr_wr(hw, si_idx, ENETC_RBMR, val);
-}
-
-static inline void enetc_enable_txvlan(struct enetc_hw *hw, int si_idx,
-				       bool en)
-{
-	u32 val = enetc_txbdr_rd(hw, si_idx, ENETC_TBMR);
-
-	val = (val & ~ENETC_TBMR_VIH) | (en ? ENETC_TBMR_VIH : 0);
-	enetc_txbdr_wr(hw, si_idx, ENETC_TBMR, val);
-}
-
-#ifdef CONFIG_ENETC_TSN
-
-#define ENETC_BG_V108
-enum bdcr_cmd_class {
-	BDCR_CMD_UNSPEC = 0,
-	BDCR_CMD_MAC_FILTER,
-	BDCR_CMD_VLAN_FILTER,
-	BDCR_CMD_RSS,
-	BDCR_CMD_RFS,
-	BDCR_CMD_PORT_GCL,
-	BDCR_CMD_RECV_CLASSIFIER,
-	BDCR_CMD_STREAM_IDENTIFY,
-	BDCR_CMD_STREAM_FILTER,
-	BDCR_CMD_STREAM_GCL,
-	BDCR_CMD_FLOW_METER,
-	__BDCR_CMD_MAX_LEN,
-	BDCR_CMD_MAX_LEN = __BDCR_CMD_MAX_LEN - 1,
-};
-
-/* class 7, command 0, Stream Identity Entry Configuration */
-struct streamid_conf {
-	__le32	stream_handle;	/* init gate value */
-	__le32	iports;
-		u8	id_type;
-		u8	oui[3];
-		u8	res[3];
-		u8	en;
-};
-
-#define ENETC_CBDR_SID_VID_MASK 0xfff
-#define ENETC_CBDR_SID_VIDM BIT(12)
-#define ENETC_CBDR_SID_TG_MASK 0xc000
-/* streamid_conf address point to this data space */
-struct null_streamid_data {
-	u8	dmac[6];
-	u16	vid_vidm_tg;
-};
-
-struct smac_streamid_data {
-	u8	smac[6];
-	u16	vid_vidm_tg;
-};
-
-/* class 7, command 1, query config , long format */
-/* No need structure define */
-
-#define ENETC_CDBR_SID_ENABLE	BIT(7)
-/*  Stream ID Query Response Data Buffer */
-struct streamid_query_resp {
-	u32	stream_handle;
-	u32	input_ports;
-	u8	id_type;
-	u8	oui[3];
-	u8	mac[6];
-	u16	vid_vidm_tg;
-	u8	res[3];
-	u8  en;
-};
-
-/* class 7, command 2, qeury status count, Stream ID query long format */
-struct streamid_stat_query {
-	u8	res[12];
-	__le32 input_ports;
-};
-
-/* Stream Identity Statistics Query */
-struct streamid_stat_query_resp {
-	u32	psinl;
-	u32	psinh;
-	u64	pspi[32];
-};
-
-#define ENETC_CBDR_SFI_PRI_MASK 0x7
-#define ENETC_CBDR_SFI_PRIM		BIT(3)
-#define ENETC_CBDR_SFI_BLOV		BIT(4)
-#define ENETC_CBDR_SFI_BLEN		BIT(5)
-#define ENETC_CBDR_SFI_MSDUEN	BIT(6)
-#define ENETC_CBDR_SFI_FMITEN	BIT(7)
-#define ENETC_CBDR_SFI_ENABLE	BIT(7)
-/* class 8, command 0, Stream Filter Instance, Short Format */
-struct sfi_conf {
-	__le32	stream_handle;
-		u8	multi;
-		u8	res[2];
-		u8	sthm;
-	/*
-	 * Max Service Data Unit or Flow Meter Instance Table index.
-	 * Depending on the value of FLT this represents either Max
-	 * Service Data Unit (max frame size) allowed by the filter
-	 * entry or is an index into the Flow Meter Instance table
-	 * index identifying the policer which will be used to police
-	 * it.
-	 */
-	__le16	fm_inst_table_index;
-	__le16	msdu;
-	__le16	sg_inst_table_index;
-		u8	res1[2];
-	__le32	input_ports;
-		u8	res2[3];
-		u8	en;
-};
-
-/* class 8, command 1, Stream Filter Instance, write back, short Format */
-struct sfi_query {
-		u32	stream_handle;
-		u8	multi;
-		u8	res[2];
-		u8	sthm;
-		u16	fm_inst_table_index;
-		u16	msdu;
-		u16	sg_inst_table_index;
-		u8	res1[2];
-		u32	input_ports;
-		u8	res2[3];
-		u8	en;
-};
-
-/* class 8, command 2 stream Filter Instance status query short format */
-/* command no need structure define */
-
-/* Stream Filter Instance Query Statistics Response data */
-#if 0
-struct sfi_query_stat_resp {
-	u32	match_filter_countl;
-	u32	match_filter_counth;
-	u32	sdu_filter_drop_countl;
-	u32	sdu_filter_drop_counth;
-	u32	sdu_filter_pass_countl;
-	u32	sdu_filter_pass_counth;
-};
-#endif
-struct sfi_counter_data {
-	u32 matchl;
-	u32 matchh;
-	u32 msdu_dropl;
-	u32 msdu_droph;
-	u32 stream_gate_dropl;
-	u32 stream_gate_droph;
-	u32 flow_meter_dropl;
-	u32 flow_meter_droph;
-};
-
-#define ENETC_CBDR_SGI_OIPV_MASK 0x7
-#define ENETC_CBDR_SGI_OIPV_EN	BIT(3)
-#define ENETC_CBDR_SGI_CGTST	BIT(6)
-#define ENETC_CBDR_SGI_OGTST	BIT(7)
-#define ENETC_CBDR_SGI_CFG_CHG  BIT(1)
-#define ENETC_CBDR_SGI_CFG_PND  BIT(2)
-#define ENETC_CBDR_SGI_OEX		BIT(4)
-#define ENETC_CBDR_SGI_OEXEN	BIT(5)
-#define ENETC_CBDR_SGI_IRX		BIT(6)
-#define ENETC_CBDR_SGI_IRXEN	BIT(7)
-#define ENETC_CBDR_SGI_ACLLEN_MASK 0x3
-#define ENETC_CBDR_SGI_OCLLEN_MASK 0xc
-#define	ENETC_CBDR_SGI_EN		BIT(7)
-/* class 9, command 0, Stream Gate Instance Table, Short Format */
-/* class 9, command 2, Stream Gate Instance Table entry query write back ,Short Format */
-struct sgi_table {
-	u8	res[8];
-	u8	oipv;
-	u8	res0[2];
-	u8	ocgtst;
-	u8	res1[7];
-	u8	gset;
-	u8	oacl_len;
-	u8	res2[2];
-	u8	en;
-};
-
-#define ENETC_CBDR_SGI_AIPV_MASK 0x7
-#define ENETC_CBDR_SGI_AIPV_EN	BIT(3)
-#define ENETC_CBDR_SGI_AGTST	BIT(7)
-
-/* class 9, command 1, Stream Gate Control List, Long Format */
-struct sgcl_conf {
-	u8	aipv;
-	u8	res[2];
-	u8	agtst;
-	u8	res1[4];
-	union {
-		struct {
-			u8 res2[4];
-			u8 acl_len;
-			u8 res3[3];
-		};
-		u8 cct[8]; /* Config change time */
-	};
-};
-
-/* stream control list class 9 , cmd 1 data buffer */
-struct sgcl_data {
-	u32	btl;
-	u32 bth;
-	u32	ct;
-	u32	cte;
-	/*struct sgce	*sgcl;*/
-};
-
-/* class 9, command 2, stream gate instant table enery query, short format */
-/* write back see struct sgi_table. Do not need define.*/
-
-/* class 9, command 3 Stream Gate Control List Query Descriptor - Long Format
- * ocl_len or acl_len to be 0, oper or admin would not show in the data space
- * true len will be write back in the space.
- * */
-struct sgcl_query {
-	u8 res[12];
-	u8 oacl_len;
-	u8 res1[3];
-};
-
-/* define for 'stat' */
-#define ENETC_CBDR_SGIQ_AIPV_MASK 0x7
-#define ENETC_CBDR_SGIQ_AIPV_EN	BIT(3)
-#define ENETC_CBDR_SGIQ_AGTST	BIT(4)
-#define ENETC_CBDR_SGIQ_ACL_LEN_MASK 0x60
-#define ENETC_CBDR_SGIQ_OIPV_MASK 0x380
-#define ENETC_CBDR_SGIQ_OIPV_EN	BIT(10)
-#define ENETC_CBDR_SGIQ_OGTST	BIT(11)
-#define ENETC_CBDR_SGIQ_OCL_LEN_MASK 0x3000
-/* class 9, command 3 data space */
-struct sgcl_query_resp {
-	u16 stat;
-	u16 res;
-	u32	abtl;
-	u32 abth;
-	u32	act;
-	u32	acte;
-	u32	cctl;
-	u32 ccth;
-	u32	obtl;
-	u32 obth;
-	u32	oct;
-	u32	octe;
-};
-
-/* class 9, command 4 Stream Gate Instance Table Query Statistics Response
- * short command, write back, no command define
- */
-struct sgi_query_stat_resp {
-	u32	pgcl;
-	u32 pgch;
-	u32 dgcl;
-	u32 dgch;
-	u16	msdu_avail;
-	u8 res[6];
-};
-
-#define ENETC_CBDR_FMI_MR	BIT(0)
-#define ENETC_CBDR_FMI_MREN BIT(1)
-#define ENETC_CBDR_FMI_DOY	BIT(2)
-#define	ENETC_CBDR_FMI_CM	BIT(3)
-#define ENETC_CBDR_FMI_CF	BIT(4)
-#define ENETC_CBDR_FMI_NDOR BIT(5)
-#define ENETC_CBDR_FMI_OALEN BIT(6)
-#define ENETC_CBDR_FMI_IRFPP_MASK 0x1f
-/* class 10: command 0/1, Flow Meter Instance Set, short Format */
-struct fmi_conf {
-	__le32	cir;
-	__le32	cbs;
-	__le32	eir;
-	__le32	ebs;
-		u8	conf;
-		u8	res1;
-		u8	ir_fpp;
-		u8	res2[4];
-		u8	en;
-};
-
-/* class:10, command:2, Flow Meter Instance Statistics Query Response */
-struct fmi_query_stat_resp {
-	u32	bcl;
-	u32 bch;
-	u32 dfl;
-	u32 dfh;
-	u32 d0gfl;
-	u32 d0gfh;
-	u32 d1gfl;
-	u32 d1gfh;
-	u32 dyfl;
-	u32 dyfh;
-	u32 ryfl;
-	u32 ryfh;
-	u32 drfl;
-	u32 drfh;
-	u32 rrfl;
-	u32 rrfh;
-	u32 lts;
-	u32 bci;
-	u32 bcf;
-	u32 bei;
-	u32 bef;
-};
-
-/* class 5, command 0 */
-struct tgs_gcl_conf {
-	u8	atc;	/* init gate value */
-	u8	res[7];
-	union {
-		struct {
-			u8	res1[4];
-			__le16 acl_len;
-			u8 res2[2];
-		};
-		struct {
-			u32 cctl;
-			u32 ccth;
-		};
-	};
-};
-
-#define ENETC_CBDR_SGL_IOMEN	BIT(0)
-#define ENETC_CBDR_SGL_IPVEN	BIT(3)
-#define ENETC_CBDR_SGL_GTST		BIT(4)
-#define ENETC_CBDR_SGL_IPV_MASK 0xe
-/* Stream Gate Control List Entry */
-struct sgce {
-	u32	interval;
-	u8	msdu[3];
-	u8	multi;
-};
-
-/* gate control list entry */
-struct gce {
-	u32	period;
-	u8	gate;
-	u8	res[3];
-};
-
-/* tgs_gcl_conf address point to this data space */
-struct tgs_gcl_data {
-	u32	btl;
-	u32 bth;
-	u32 ct;
-	u32 cte;
-};
-
-/* class 5, command 1 */
-struct tgs_gcl_query {
-		u8	res[12];
-		union {
-			struct {
-				__le16	acl_len; /* admin list length */
-				__le16	ocl_len; /* operation list length */
-			};
-			struct {
-				u16 admin_list_len;
-				u16 oper_list_len;
-			};
-		};
-
-};
-
-/* tgs_gcl_query command response data format */
-struct tgs_gcl_resp {
-	u32	abtl;	/* base time */
-	u32 abth;
-	u32	act;	/* cycle time */
-	u32	acte;	/* cycle time extend */
-	u32	cctl;	/* config change time */
-	u32 ccth;
-	u32 obtl;	/* operation base time */
-	u32 obth;
-	u32	oct;	/* operation cycle time */
-	u32	octe;	/* operation cycle time extend */
-	u32	ccel;	/* config change error */
-	u32 cceh;
-	/*struct gce	*gcl;*/
-};
-
-struct enetc_cbd {
-	union{
-		struct sfi_conf sfi_conf; /* Just for Stream Filter Instance Entry */
-	/*	struct sfi_query_stat_resp sfi_query_stat_resp;*/
-		struct sgi_table sgi_table; /* Just for Stream Gate Instance table set */
-	/*	struct sgi_query_resp sgi_query_resp;*/
-		struct sgi_query_stat_resp sgi_query_stat_resp;
-		struct fmi_conf fmi_conf;
-	/*	struct fmi_query_stat_resp fmi_query_stat_resp;*/
-		struct {
-			__le32	addr[2];
-			union {
-				__le32	opt[4];
-				struct tgs_gcl_conf		gcl_conf;
-				struct tgs_gcl_query	gcl_query;
-				struct streamid_conf		sid_set;
-				struct streamid_stat_query	sid_stat;
-				struct sgcl_conf		sgcl_conf;
-				struct sgcl_query		sgcl_query;
-			};
-		};			/* Long format */
-		__le32 data[6];
-	};
-	__le16 index;
-	__le16 length;
-	u8 cmd;
-	u8 cls;
-	u8 _res;
-	u8 status_flags;
-};
-
-#define ENETC_PTCFPR(n)		(0x1910 + (n) * 4) /* n = [0 ..7] */
-#define ENETC_FPE		BIT(31)
-
-/* Port capability register 0 */
-#define ENETC_PCAPR0_PSFPM BIT(10)
-#define ENETC_PCAPR0_PSFP BIT(9)
-#define ENETC_PCAPR0_TSN BIT(4)
-#define ENETC_PCAPR0_QBU BIT(3)
-
-/* port time gating control register */
-#define QBV_PTGCR_OFFSET 0x11a00
-#define QBV_TGE		0x80000000
-#define QBV_TGPE	BIT(30)
-#define QBV_TGDROP_DISABLE BIT(29)
-
-/* Port time gating capability register */
-#define QBV_PTGCAPR_OFFSET 0x11a08
-#define QBV_MAX_GCL_LEN_MASK	0xffff
-
-/* Port time gating tick granularity register */
-#define QBV_PTGTGR_OFFSET 0x11a0c
-#define QBV_TICK_GRAN_MASK 0xffffffff
-
-/* Port time gating admin gate list status register */
-#define QBV_PTGAGLSR_OFFSET 0x11a10
-
-#define QBV_CFG_PEND_MASK 0x00000002
-
-/* Port time gating admin gate list length register */
-#define QBV_PTGAGLLR_OFFSET 0x11a14
-#define QBV_ADMIN_GATE_LIST_LENGTH_MASK 0xffff
-
-/* Port time gating operational gate list status register */
-#define QBV_PTGOGLSR_OFFSET 0x11a18
-#define QBV_HTA_POS_MASK 0xffff0000
-
-#define QBV_CURR_POS_MASK 0x0000ffff
-
-/* Port time gating operational gate list length register */
-#define QBV_PTGOGLLR_OFFSET 0x11a1c
-#define QBV_OPER_GATE_LIST_LENGTH_MASK 0xffff
-
-/* Port time gating current time register */
-#define QBV_PTGCTR_OFFSET 0x11a20
-#define QBV_CURR_TIME_MASK 0xffffffffffffffff
-
-/* Port traffic class a time gating control register */
-#define QBV_PTC0TGCR_OFFSET  0x11a40
-#define QBV_PTC1TGCR_OFFSET  0x11a50
-#define QBV_PTC2TGCR_OFFSET  0x11a60
-#define QBV_PTC3TGCR_OFFSET  0x11a70
-#define QBV_PTC4TGCR_OFFSET  0x11a80
-#define QBV_PTC5TGCR_OFFSET  0x11a90
-#define QBV_PTC6TGCR_OFFSET  0x11aa0
-#define QBV_PTC7TGCR_OFFSET  0x11ab0
-
-/* Maximum Service Data Unit. */
-#define ENETC_PTC0MSDUR 0x12020
-#define ENETC_PTC1MSDUR 0x12024
-#define ENETC_PTC2MSDUR 0x12028
-#define ENETC_PTC3MSDUR 0x1202c
-#define ENETC_PTC4MSDUR 0x12030
-#define ENETC_PTC5MSDUR 0x12034
-#define ENETC_PTC6MSDUR 0x12038
-#define ENETC_PTC7MSDUR 0x1203c
-
-#define QBV_MAXSDU_MASK 0xffff
-
-/* Port traffic class a time gating status register */
-#define QBV_PTC0TGSR_OFFSET  0x11a44
-#define QBV_HTA_STATE_MASK  0x10000
-#define QBV_CURR_STATE_MASK 0x1
-
-/* Port traffic class a time gating transmission overrun counter register*/
-#define QBV_PTC0TGTOCR_OFFSET 0x11a48
-#define QBV_TX_OVERRUN_MASK 0xffffffffffffffff
-#define ENETC_TGLSTR 0xa200
-#define ENETC_TGS_MIN_DIS_MASK 0x80000000
-#define ENETC_MIN_LOOKAHEAD_MASK 0xffff
-
-#define ENETC_PPSFPMR 0x11b00
-#define ENETC_PPSFPMR_PSFPEN BIT(0)
-#define ENETC_PPSFPMR_VS BIT(1)
-#define ENETC_PPSFPMR_PVC BIT(2)
-#define ENETC_PPSFPMR_PVZC BIT(3)
-
-#endif
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_mdio.c b/drivers/net/ethernet/freescale/enetc/enetc_mdio.c
deleted file mode 100644
index f71548704cf8..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_mdio.c
+++ /dev/null
@@ -1,199 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2019 NXP */
-
-#include <linux/mdio.h>
-#include <linux/of_mdio.h>
-#include <linux/iopoll.h>
-#include <linux/of.h>
-
-#include "enetc_pf.h"
-
-struct enetc_mdio_regs {
-	u32	mdio_cfg;	/* MDIO configuration and status */
-	u32	mdio_ctl;	/* MDIO control */
-	u32	mdio_data;	/* MDIO data */
-	u32	mdio_addr;	/* MDIO address */
-};
-
-#define bus_to_enetc_regs(bus)	(struct enetc_mdio_regs __iomem *)((bus)->priv)
-
-#define ENETC_MDIO_REG_OFFSET	0x1c00
-#define ENETC_MDC_DIV		258
-
-#define MDIO_CFG_CLKDIV(x)	((((x) >> 1) & 0xff) << 8)
-#define MDIO_CFG_BSY		BIT(0)
-#define MDIO_CFG_RD_ER		BIT(1)
-#define MDIO_CFG_ENC45		BIT(6)
- /* external MDIO only - driven on neg MDC edge */
-#define MDIO_CFG_NEG		BIT(23)
-
-#define MDIO_CTL_DEV_ADDR(x)	((x) & 0x1f)
-#define MDIO_CTL_PORT_ADDR(x)	(((x) & 0x1f) << 5)
-#define MDIO_CTL_READ		BIT(15)
-#define MDIO_DATA(x)		((x) & 0xffff)
-
-#define TIMEOUT	1000
-static int enetc_mdio_wait_complete(struct enetc_mdio_regs __iomem *regs)
-{
-	u32 val;
-
-	return readx_poll_timeout(enetc_rd_reg, &regs->mdio_cfg, val,
-				  !(val & MDIO_CFG_BSY), 10, 10 * TIMEOUT);
-}
-
-static int enetc_mdio_write(struct mii_bus *bus, int phy_id, int regnum,
-			    u16 value)
-{
-	struct enetc_mdio_regs __iomem *regs = bus_to_enetc_regs(bus);
-	u32 mdio_ctl, mdio_cfg;
-	u16 dev_addr;
-	int ret;
-
-	mdio_cfg = MDIO_CFG_CLKDIV(ENETC_MDC_DIV) | MDIO_CFG_NEG;
-	if (regnum & MII_ADDR_C45) {
-		dev_addr = (regnum >> 16) & 0x1f;
-		mdio_cfg |= MDIO_CFG_ENC45;
-	} else {
-		/* clause 22 (ie 1G) */
-		dev_addr = regnum & 0x1f;
-		mdio_cfg &= ~MDIO_CFG_ENC45;
-	}
-
-	enetc_wr_reg(&regs->mdio_cfg, mdio_cfg);
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	/* set port and dev addr */
-	mdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);
-	enetc_wr_reg(&regs->mdio_ctl, mdio_ctl);
-
-	/* set the register address */
-	if (regnum & MII_ADDR_C45) {
-		enetc_wr_reg(&regs->mdio_addr, regnum & 0xffff);
-
-		ret = enetc_mdio_wait_complete(regs);
-		if (ret)
-			return ret;
-	}
-
-	/* write the value */
-	enetc_wr_reg(&regs->mdio_data, MDIO_DATA(value));
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int enetc_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
-{
-	struct enetc_mdio_regs __iomem *regs = bus_to_enetc_regs(bus);
-	u32 mdio_ctl, mdio_cfg;
-	u16 dev_addr, value;
-	int ret;
-
-	mdio_cfg = MDIO_CFG_CLKDIV(ENETC_MDC_DIV) | MDIO_CFG_NEG;
-	if (regnum & MII_ADDR_C45) {
-		dev_addr = (regnum >> 16) & 0x1f;
-		mdio_cfg |= MDIO_CFG_ENC45;
-	} else {
-		dev_addr = regnum & 0x1f;
-		mdio_cfg &= ~MDIO_CFG_ENC45;
-	}
-
-	enetc_wr_reg(&regs->mdio_cfg, mdio_cfg);
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	/* set port and device addr */
-	mdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);
-	enetc_wr_reg(&regs->mdio_ctl, mdio_ctl);
-
-	/* set the register address */
-	if (regnum & MII_ADDR_C45) {
-		enetc_wr_reg(&regs->mdio_addr, regnum & 0xffff);
-
-		ret = enetc_mdio_wait_complete(regs);
-		if (ret)
-			return ret;
-	}
-
-	/* initiate the read */
-	enetc_wr_reg(&regs->mdio_ctl, mdio_ctl | MDIO_CTL_READ);
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	/* return all Fs if nothing was there */
-	if (enetc_rd_reg(&regs->mdio_cfg) & MDIO_CFG_RD_ER) {
-		dev_err(&bus->dev,
-			"Error while reading PHY%d reg at %d.%hhu\n",
-			phy_id, dev_addr, regnum);
-		return 0xffff;
-	}
-
-	value = enetc_rd_reg(&regs->mdio_data) & 0xffff;
-
-	return value;
-}
-
-int enetc_mdio_probe(struct enetc_pf *pf)
-{
-	struct device *dev = &pf->si->pdev->dev;
-	struct enetc_mdio_regs __iomem *regs;
-	struct device_node *np;
-	struct mii_bus *bus;
-	int ret;
-
-	bus = mdiobus_alloc_size(sizeof(regs));
-	if (!bus)
-		return -ENOMEM;
-
-	bus->name = "Freescale ENETC MDIO Bus";
-	bus->read = enetc_mdio_read;
-	bus->write = enetc_mdio_write;
-	bus->parent = dev;
-	snprintf(bus->id, MII_BUS_ID_SIZE, "%s", dev_name(dev));
-
-	/* store the enetc mdio base address for this bus */
-	regs = pf->si->hw.port + ENETC_MDIO_REG_OFFSET;
-	bus->priv = regs;
-
-	np = of_get_child_by_name(dev->of_node, "mdio");
-	if (!np) {
-		dev_err(dev, "MDIO node missing\n");
-		ret = -EINVAL;
-		goto err_registration;
-	}
-
-	ret = of_mdiobus_register(bus, np);
-	if (ret) {
-		of_node_put(np);
-		dev_err(dev, "cannot register MDIO bus\n");
-		goto err_registration;
-	}
-
-	of_node_put(np);
-	pf->mdio = bus;
-
-	return 0;
-
-err_registration:
-	mdiobus_free(bus);
-
-	return ret;
-}
-
-void enetc_mdio_remove(struct enetc_pf *pf)
-{
-	if (pf->mdio) {
-		mdiobus_unregister(pf->mdio);
-		mdiobus_free(pf->mdio);
-	}
-}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_msg.c b/drivers/net/ethernet/freescale/enetc/enetc_msg.c
deleted file mode 100644
index 6c01081ac0af..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_msg.c
+++ /dev/null
@@ -1,164 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include "enetc_pf.h"
-
-static void enetc_msg_disable_mr_int(struct enetc_hw *hw)
-{
-	u32 psiier = enetc_rd(hw, ENETC_PSIIER);
-	/* disable MR int source(s) */
-	enetc_wr(hw, ENETC_PSIIER, psiier & ~ENETC_PSIIER_MR_MASK);
-}
-
-static void enetc_msg_enable_mr_int(struct enetc_hw *hw)
-{
-	u32 psiier = enetc_rd(hw, ENETC_PSIIER);
-
-	enetc_wr(hw, ENETC_PSIIER, psiier | ENETC_PSIIER_MR_MASK);
-}
-
-static irqreturn_t enetc_msg_psi_msix(int irq, void *data)
-{
-	struct enetc_si *si = (struct enetc_si *)data;
-	struct enetc_pf *pf = enetc_si_priv(si);
-
-	enetc_msg_disable_mr_int(&si->hw);
-	schedule_work(&pf->msg_task);
-
-	return IRQ_HANDLED;
-}
-
-static void enetc_msg_task(struct work_struct *work)
-{
-	struct enetc_pf *pf = container_of(work, struct enetc_pf, msg_task);
-	struct enetc_hw *hw = &pf->si->hw;
-	unsigned long mr_mask;
-	int i;
-
-	for (;;) {
-		mr_mask = enetc_rd(hw, ENETC_PSIMSGRR) & ENETC_PSIMSGRR_MR_MASK;
-		if (!mr_mask) {
-			/* re-arm MR interrupts, w1c the IDR reg */
-			enetc_wr(hw, ENETC_PSIIDR, ENETC_PSIIER_MR_MASK);
-			enetc_msg_enable_mr_int(hw);
-			return;
-		}
-
-		for (i = 0; i < pf->num_vfs; i++) {
-			u32 psimsgrr;
-			u16 msg_code;
-
-			if (!(ENETC_PSIMSGRR_MR(i) & mr_mask))
-				continue;
-
-			enetc_msg_handle_rxmsg(pf, i, &msg_code);
-
-			psimsgrr = ENETC_SIMSGSR_SET_MC(msg_code);
-			psimsgrr |= ENETC_PSIMSGRR_MR(i); /* w1c */
-			enetc_wr(hw, ENETC_PSIMSGRR, psimsgrr);
-		}
-	}
-}
-
-/* Init */
-static int enetc_msg_alloc_mbx(struct enetc_si *si, int idx)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct device *dev = &si->pdev->dev;
-	struct enetc_hw *hw = &si->hw;
-	struct enetc_msg_swbd *msg;
-	u32 val;
-
-	msg = &pf->rxmsg[idx];
-	/* allocate and set receive buffer */
-	msg->size = ENETC_DEFAULT_MSG_SIZE;
-
-	msg->vaddr = dma_zalloc_coherent(dev, msg->size, &msg->dma,
-					 GFP_KERNEL);
-	if (!msg->vaddr) {
-		dev_err(dev, "msg: fail to alloc dma buffer of size: %d\n",
-			msg->size);
-		return -ENOMEM;
-	}
-
-	/* set multiple of 32 bytes */
-	val = lower_32_bits(msg->dma);
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR0(idx), val);
-	val = upper_32_bits(msg->dma);
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR1(idx), val);
-
-	return 0;
-}
-
-static void enetc_msg_free_mbx(struct enetc_si *si, int idx)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	struct enetc_msg_swbd *msg;
-
-	msg = &pf->rxmsg[idx];
-	dma_free_coherent(&si->pdev->dev, msg->size, msg->vaddr, msg->dma);
-	memset(msg, 0, sizeof(*msg));
-
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR0(idx), 0);
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR1(idx), 0);
-}
-
-int enetc_msg_psi_init(struct enetc_pf *pf)
-{
-	struct enetc_si *si = pf->si;
-	int vector, i, err;
-
-	/* register message passing interrupt handler */
-	snprintf(pf->msg_int_name, sizeof(pf->msg_int_name), "%s-vfmsg",
-		 si->ndev->name);
-	vector = pci_irq_vector(si->pdev, ENETC_SI_INT_IDX);
-	err = request_irq(vector, enetc_msg_psi_msix, 0, pf->msg_int_name, si);
-	if (err) {
-		dev_err(&si->pdev->dev,
-			"PSI messaging: request_irq() failed!\n");
-		return err;
-	}
-
-	/* set one IRQ entry for PSI message receive notification (SI int) */
-	enetc_wr(&si->hw, ENETC_SIMSIVR, ENETC_SI_INT_IDX);
-
-	/* initialize PSI mailbox */
-	INIT_WORK(&pf->msg_task, enetc_msg_task);
-
-	for (i = 0; i < pf->num_vfs; i++) {
-		err = enetc_msg_alloc_mbx(si, i);
-		if (err)
-			goto err_init_mbx;
-	}
-
-	/* enable MR interrupts */
-	enetc_msg_enable_mr_int(&si->hw);
-
-	return 0;
-
-err_init_mbx:
-	for (i--; i >= 0; i--)
-		enetc_msg_free_mbx(si, i);
-
-	free_irq(vector, si);
-
-	return err;
-}
-
-void enetc_msg_psi_free(struct enetc_pf *pf)
-{
-	struct enetc_si *si = pf->si;
-	int i;
-
-	cancel_work_sync(&pf->msg_task);
-
-	/* disable MR interrupts */
-	enetc_msg_disable_mr_int(&si->hw);
-
-	for (i = 0; i < pf->num_vfs; i++)
-		enetc_msg_free_mbx(si, i);
-
-	/* de-register message passing interrupt handler */
-	free_irq(pci_irq_vector(si->pdev, ENETC_SI_INT_IDX), si);
-}
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
deleted file mode 100644
index 8e2995d6c755..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+++ /dev/null
@@ -1,956 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include <linux/module.h>
-#include <linux/of_mdio.h>
-#include <linux/of_net.h>
-#include "enetc_pf.h"
-
-#define ENETC_DRV_VER_MAJ 0
-#define ENETC_DRV_VER_MIN 9
-
-#define ENETC_DRV_VER_STR __stringify(ENETC_DRV_VER_MAJ) "." \
-			  __stringify(ENETC_DRV_VER_MIN)
-static const char enetc_drv_ver[] = ENETC_DRV_VER_STR;
-#define ENETC_DRV_NAME_STR "ENETC PF driver"
-static const char enetc_drv_name[] = ENETC_DRV_NAME_STR;
-
-static void enetc_pf_get_primary_mac_addr(struct enetc_hw *hw, int si, u8 *addr)
-{
-	u32 upper = __raw_readl(hw->port + ENETC_PSIPMAR0(si));
-	u16 lower = __raw_readw(hw->port + ENETC_PSIPMAR1(si));
-
-	*(u32 *)addr = upper;
-	*(u16 *)(addr + 4) = lower;
-}
-
-static void enetc_pf_set_primary_mac_addr(struct enetc_hw *hw, int si,
-					  const u8 *addr)
-{
-	u32 upper = *(const u32 *)addr;
-	u16 lower = *(const u16 *)(addr + 4);
-
-	__raw_writel(upper, hw->port + ENETC_PSIPMAR0(si));
-	__raw_writew(lower, hw->port + ENETC_PSIPMAR1(si));
-}
-
-static int enetc_pf_set_mac_addr(struct net_device *ndev, void *addr)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct sockaddr *saddr = addr;
-
-	if (!is_valid_ether_addr(saddr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	memcpy(ndev->dev_addr, saddr->sa_data, ndev->addr_len);
-	enetc_pf_set_primary_mac_addr(&priv->si->hw, 0, saddr->sa_data);
-
-	return 0;
-}
-
-static void enetc_set_vlan_promisc(struct enetc_hw *hw, char si_map)
-{
-	u32 val = enetc_port_rd(hw, ENETC_PSIPVMR);
-
-	val &= ~ENETC_PSIPVMR_SET_VP(ENETC_VLAN_PROMISC_MAP_ALL);
-	enetc_port_wr(hw, ENETC_PSIPVMR, ENETC_PSIPVMR_SET_VP(si_map) | val);
-}
-
-static bool enetc_si_vlan_promisc_is_on(struct enetc_pf *pf, int si_idx)
-{
-	return pf->vlan_promisc_simap & BIT(si_idx);
-}
-
-static bool enetc_vlan_filter_is_on(struct enetc_pf *pf)
-{
-	int i;
-
-	for_each_set_bit(i, pf->active_vlans, VLAN_N_VID)
-		return true;
-
-	return false;
-}
-
-static void enetc_enable_si_vlan_promisc(struct enetc_pf *pf, int si_idx)
-{
-	pf->vlan_promisc_simap |= BIT(si_idx);
-	enetc_set_vlan_promisc(&pf->si->hw, pf->vlan_promisc_simap);
-}
-
-static void enetc_disable_si_vlan_promisc(struct enetc_pf *pf, int si_idx)
-{
-	pf->vlan_promisc_simap &= ~BIT(si_idx);
-	enetc_set_vlan_promisc(&pf->si->hw, pf->vlan_promisc_simap);
-}
-
-static void enetc_set_isol_vlan(struct enetc_hw *hw, int si, u16 vlan, u8 qos)
-{
-	u32 val = 0;
-
-	if (vlan)
-		val = ENETC_PSIVLAN_EN | ENETC_PSIVLAN_SET_QOS(qos) | vlan;
-
-	enetc_port_wr(hw, ENETC_PSIVLANR(si), val);
-}
-
-static int enetc_mac_addr_hash_idx(const u8 *addr)
-{
-	u64 fold = __swab64(ether_addr_to_u64(addr)) >> 16;
-	u64 mask = 0;
-	int res = 0;
-	int i;
-
-	for (i = 0; i < 8; i++)
-		mask |= BIT_ULL(i * 6);
-
-	for (i = 0; i < 6; i++)
-		res |= (hweight64(fold & (mask << i)) & 0x1) << i;
-
-	return res;
-}
-
-static void enetc_reset_mac_addr_filter(struct enetc_mac_filter *filter)
-{
-	filter->mac_addr_cnt = 0;
-
-	bitmap_zero(filter->mac_hash_table,
-		    ENETC_MADDR_HASH_TBL_SZ);
-}
-
-static void enetc_add_mac_addr_em_filter(struct enetc_mac_filter *filter,
-					 const unsigned char *addr)
-{
-	/* add exact match addr */
-	ether_addr_copy(filter->mac_addr, addr);
-	filter->mac_addr_cnt++;
-}
-
-static void enetc_add_mac_addr_ht_filter(struct enetc_mac_filter *filter,
-					 const unsigned char *addr)
-{
-	int idx = enetc_mac_addr_hash_idx(addr);
-
-	/* add hash table entry */
-	__set_bit(idx, filter->mac_hash_table);
-	filter->mac_addr_cnt++;
-}
-
-static void enetc_clear_mac_ht_flt(struct enetc_si *si, int si_idx, int type)
-{
-	bool err = si->errata & ENETC_ERR_UCMCSWP;
-
-	if (type == UC) {
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR0(si_idx, err), 0);
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR1(si_idx), 0);
-	} else { /* MC */
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR0(si_idx, err), 0);
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR1(si_idx), 0);
-	}
-}
-
-static void enetc_set_mac_ht_flt(struct enetc_si *si, int si_idx, int type,
-				 u32 *hash)
-{
-	bool err = si->errata & ENETC_ERR_UCMCSWP;
-
-	if (type == UC) {
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR0(si_idx, err), *hash);
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR1(si_idx), *(hash + 1));
-	} else { /* MC */
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR0(si_idx, err), *hash);
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR1(si_idx), *(hash + 1));
-	}
-}
-
-static void enetc_sync_mac_filters(struct enetc_pf *pf)
-{
-	struct enetc_mac_filter *f = pf->mac_filter;
-	struct enetc_si *si = pf->si;
-	int i, pos;
-
-	pos = EMETC_MAC_ADDR_FILT_RES;
-
-	for (i = 0; i < MADDR_TYPE; i++, f++) {
-		bool em = (f->mac_addr_cnt == 1) && (i == UC);
-		bool clear = !f->mac_addr_cnt;
-
-		if (clear) {
-			if (i == UC)
-				enetc_clear_mac_flt_entry(si, pos);
-
-			enetc_clear_mac_ht_flt(si, 0, i);
-			continue;
-		}
-
-		/* exact match filter */
-		if (em) {
-			int err;
-
-			enetc_clear_mac_ht_flt(si, 0, UC);
-
-			err = enetc_set_mac_flt_entry(si, pos, f->mac_addr,
-						      BIT(0));
-			if (!err)
-				continue;
-
-			/* fallback to HT filtering */
-			dev_warn(&si->pdev->dev, "fallback to HT filt (%d)\n",
-				 err);
-		}
-
-		/* hash table filter, clear EM filter for UC entries */
-		if (i == UC)
-			enetc_clear_mac_flt_entry(si, pos);
-
-		enetc_set_mac_ht_flt(si, 0, i, (u32 *)f->mac_hash_table);
-	}
-}
-
-static void enetc_pf_set_rx_mode(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	struct enetc_hw *hw = &priv->si->hw;
-	bool uprom = false, mprom = false;
-	struct enetc_mac_filter *filter;
-	struct netdev_hw_addr *ha;
-	u32 psipmr = 0;
-	bool em;
-
-	if (ndev->flags & IFF_PROMISC) {
-		/* enable promisc mode for SI0 (PF) */
-		psipmr = ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0);
-		uprom = true;
-		mprom = true;
-		/* enable VLAN promisc mode for SI0 */
-		if (!enetc_si_vlan_promisc_is_on(pf, 0))
-			enetc_enable_si_vlan_promisc(pf, 0);
-
-	} else if (ndev->flags & IFF_ALLMULTI) {
-		/* enable multi cast promisc mode for SI0 (PF) */
-		psipmr = ENETC_PSIPMR_SET_MP(0);
-		mprom = true;
-	}
-
-	/* first 2 filter entries belong to PF */
-	if (!uprom) {
-		/* Update unicast filters */
-		filter = &pf->mac_filter[UC];
-		enetc_reset_mac_addr_filter(filter);
-
-		em = (netdev_uc_count(ndev) == 1);
-		netdev_for_each_uc_addr(ha, ndev) {
-			if (em) {
-				enetc_add_mac_addr_em_filter(filter, ha->addr);
-				break;
-			}
-
-			enetc_add_mac_addr_ht_filter(filter, ha->addr);
-		}
-	}
-
-	if (!mprom) {
-		/* Update multicast filters */
-		filter = &pf->mac_filter[MC];
-		enetc_reset_mac_addr_filter(filter);
-
-		netdev_for_each_mc_addr(ha, ndev) {
-			if (!is_multicast_ether_addr(ha->addr))
-				continue;
-
-			enetc_add_mac_addr_ht_filter(filter, ha->addr);
-		}
-	}
-
-	if (!uprom || !mprom)
-		/* update PF entries */
-		enetc_sync_mac_filters(pf);
-
-	psipmr |= enetc_port_rd(hw, ENETC_PSIPMR) &
-		  ~(ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0));
-	enetc_port_wr(hw, ENETC_PSIPMR, psipmr);
-}
-
-static void enetc_set_vlan_ht_filter(struct enetc_hw *hw, int si_idx,
-				     u32 *hash)
-{
-	enetc_port_wr(hw, ENETC_PSIVHFR0(si_idx), *hash);
-	enetc_port_wr(hw, ENETC_PSIVHFR1(si_idx), *(hash + 1));
-}
-
-static int enetc_vid_hash_idx(unsigned int vid)
-{
-	int res = 0;
-	int i;
-
-	for (i = 0; i < 6; i++)
-		res |= (hweight8(vid & (BIT(i) | BIT(i + 6))) & 0x1) << i;
-
-	return res;
-}
-
-static void enetc_sync_vlan_ht_filter(struct enetc_pf *pf, bool rehash)
-{
-	int i;
-
-	if (rehash) {
-		bitmap_zero(pf->vlan_ht_filter, ENETC_VLAN_HT_SIZE);
-
-		for_each_set_bit(i, pf->active_vlans, VLAN_N_VID) {
-			int hidx = enetc_vid_hash_idx(i);
-
-			__set_bit(hidx, pf->vlan_ht_filter);
-		}
-	}
-
-	enetc_set_vlan_ht_filter(&pf->si->hw, 0, (u32 *)pf->vlan_ht_filter);
-}
-
-static int enetc_vlan_rx_add_vid(struct net_device *ndev, __be16 prot, u16 vid)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	int idx;
-
-	if (enetc_si_vlan_promisc_is_on(pf, 0))
-		enetc_disable_si_vlan_promisc(pf, 0);
-
-	__set_bit(vid, pf->active_vlans);
-
-	idx = enetc_vid_hash_idx(vid);
-	if (!__test_and_set_bit(idx, pf->vlan_ht_filter))
-		enetc_sync_vlan_ht_filter(pf, false);
-
-	return 0;
-}
-
-static int enetc_vlan_rx_del_vid(struct net_device *ndev, __be16 prot, u16 vid)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-
-	__clear_bit(vid, pf->active_vlans);
-	enetc_sync_vlan_ht_filter(pf, true);
-
-	if (!enetc_vlan_filter_is_on(pf))
-		enetc_enable_si_vlan_promisc(pf, 0);
-
-	return 0;
-}
-
-static void enetc_set_loopback(struct net_device *ndev, bool en)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	u32 reg;
-
-	reg = enetc_port_rd(hw, ENETC_PM0_IF_MODE);
-	if (reg & ENETC_PMO_IFM_RG) {
-		/* RGMII mode */
-		reg = (reg & ~ENETC_PM0_IFM_RLP) |
-		      (en ? ENETC_PM0_IFM_RLP : 0);
-		enetc_port_wr(hw, ENETC_PM0_IF_MODE, reg);
-	} else {
-		/* assume SGMII mode */
-		reg = enetc_port_rd(hw, ENETC_PM0_CMD_CFG);
-		reg = (reg & ~ENETC_PM0_CMD_XGLP) |
-		      (en ? ENETC_PM0_CMD_XGLP : 0);
-		reg = (reg & ~ENETC_PM0_CMD_PHY_TX_EN) |
-		      (en ? ENETC_PM0_CMD_PHY_TX_EN : 0);
-		enetc_port_wr(hw, ENETC_PM0_CMD_CFG, reg);
-		enetc_port_wr(hw, ENETC_PM1_CMD_CFG, reg);
-	}
-}
-
-static int enetc_pf_set_vf_mac(struct net_device *ndev, int vf, u8 *mac)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	struct enetc_vf_state *vf_state;
-
-	if (vf >= pf->total_vfs)
-		return -EINVAL;
-
-	if (!is_valid_ether_addr(mac))
-		return -EADDRNOTAVAIL;
-
-	vf_state = &pf->vf_state[vf];
-	vf_state->flags |= ENETC_VF_FLAG_PF_SET_MAC;
-	enetc_pf_set_primary_mac_addr(&priv->si->hw, vf + 1, mac);
-	return 0;
-}
-
-static int enetc_pf_set_vf_vlan(struct net_device *ndev, int vf, u16 vlan,
-				u8 qos, __be16 proto)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-
-	if (priv->si->errata & ENETC_ERR_VLAN_ISOL)
-		return -EOPNOTSUPP;
-
-	if (vf >= pf->total_vfs)
-		return -EINVAL;
-
-	if (proto != htons(ETH_P_8021Q))
-		/* only C-tags supported for now */
-		return -EPROTONOSUPPORT;
-
-	enetc_set_isol_vlan(&priv->si->hw, vf + 1, vlan, qos);
-	return 0;
-}
-
-static int enetc_pf_set_vf_spoofchk(struct net_device *ndev, int vf, bool en)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	u32 cfgr;
-
-	if (vf >= pf->total_vfs)
-		return -EINVAL;
-
-	cfgr = enetc_port_rd(&priv->si->hw, ENETC_PSICFGR0(vf + 1));
-	cfgr = (cfgr & ~ENETC_PSICFGR0_ASE) | (en ? ENETC_PSICFGR0_ASE : 0);
-	enetc_port_wr(&priv->si->hw, ENETC_PSICFGR0(vf + 1), cfgr);
-
-	return 0;
-}
-
-static void enetc_port_setup_primary_mac_address(struct enetc_si *si)
-{
-	unsigned char mac_addr[MAX_ADDR_LEN];
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	int i;
-
-	/* check MAC addresses for PF and all VFs, if any is 0 set it ro rand */
-	for (i = 0; i < pf->total_vfs + 1; i++) {
-		enetc_pf_get_primary_mac_addr(hw, i, mac_addr);
-		if (!is_zero_ether_addr(mac_addr))
-			continue;
-		eth_random_addr(mac_addr);
-		dev_info(&si->pdev->dev, "no MAC address specified for SI%d, using %pM\n",
-			 i, mac_addr);
-		enetc_pf_set_primary_mac_addr(hw, i, mac_addr);
-	}
-}
-
-static void enetc_port_assign_rfs_entries(struct enetc_si *si)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	int num_entries, vf_entries, i;
-	u32 val;
-
-	/* split RFS entries between functions */
-	val = enetc_port_rd(hw, ENETC_PRFSCAPR);
-	num_entries = ENETC_PRFSCAPR_GET_NUM_RFS(val);
-	vf_entries = num_entries / (pf->total_vfs + 1);
-
-	for (i = 0; i < pf->total_vfs; i++)
-		enetc_port_wr(hw, ENETC_PSIRFSCFGR(i + 1), vf_entries);
-	enetc_port_wr(hw, ENETC_PSIRFSCFGR(0),
-		      num_entries - vf_entries * pf->total_vfs);
-
-	/* enable RFS on port */
-	enetc_port_wr(hw, ENETC_PRFSMR, ENETC_PRFSMR_RFSE);
-}
-
-static void enetc_port_si_configure(struct enetc_si *si)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	int num_rings, i;
-	u32 val;
-
-	val = enetc_port_rd(hw, ENETC_PCAPR0);
-	num_rings = min(ENETC_PCAPR0_RXBDR(val), ENETC_PCAPR0_TXBDR(val));
-
-	val = ENETC_PSICFGR0_SET_TXBDR(ENETC_PF_NUM_RINGS);
-	val |= ENETC_PSICFGR0_SET_RXBDR(ENETC_PF_NUM_RINGS);
-
-	if (unlikely(num_rings < ENETC_PF_NUM_RINGS)) {
-		val = ENETC_PSICFGR0_SET_TXBDR(num_rings);
-		val |= ENETC_PSICFGR0_SET_RXBDR(num_rings);
-
-		dev_warn(&si->pdev->dev, "Found %d rings, expected %d!\n",
-			 num_rings, ENETC_PF_NUM_RINGS);
-
-		num_rings = 0;
-	}
-
-	/* Add default one-time settings for SI0 (PF) */
-	val |= ENETC_PSICFGR0_SIVC(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);
-
-	enetc_port_wr(hw, ENETC_PSICFGR0(0), val);
-
-	if (num_rings)
-		num_rings -= ENETC_PF_NUM_RINGS;
-
-	/* Configure the SIs for each available VF */
-	val = ENETC_PSICFGR0_SIVC(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);
-	val |= ENETC_PSICFGR0_VTE | ENETC_PSICFGR0_SIVIE;
-
-	if (num_rings) {
-		num_rings /= pf->total_vfs;
-		val |= ENETC_PSICFGR0_SET_TXBDR(num_rings);
-		val |= ENETC_PSICFGR0_SET_RXBDR(num_rings);
-	}
-
-	for (i = 0; i < pf->total_vfs; i++)
-		enetc_port_wr(hw, ENETC_PSICFGR0(i + 1), val);
-
-	/* Port level VLAN settings */
-	val = ENETC_PVCLCTR_OVTPIDL(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);
-	enetc_port_wr(hw, ENETC_PVCLCTR, val);
-	/* use outer tag for VLAN filtering */
-	enetc_port_wr(hw, ENETC_PSIVLANFMR, ENETC_PSIVLANFMR_VS);
-}
-
-static void enetc_configure_port_mac(struct enetc_hw *hw)
-{
-	enetc_port_wr(hw, ENETC_PM0_MAXFRM,
-		      ENETC_SET_MAXFRM(ENETC_RX_MAXFRM_SIZE));
-
-	enetc_port_wr(hw, ENETC_PTCMSDUR(0), ENETC_MAC_MAXFRM_SIZE);
-	enetc_port_wr(hw, ENETC_PTXMBAR, 2 * ENETC_MAC_MAXFRM_SIZE);
-
-	enetc_port_wr(hw, ENETC_PM0_CMD_CFG, ENETC_PM0_CMD_PHY_TX_EN |
-		      ENETC_PM0_CMD_TXP	| ENETC_PM0_PROMISC |
-		      ENETC_PM0_TX_EN | ENETC_PM0_RX_EN);
-
-	enetc_port_wr(hw, ENETC_PM1_CMD_CFG, ENETC_PM0_CMD_PHY_TX_EN |
-		      ENETC_PM0_CMD_TXP	| ENETC_PM0_PROMISC |
-		      ENETC_PM0_TX_EN | ENETC_PM0_RX_EN);
-	/* set auto-speed for RGMII */
-	if (enetc_port_rd(hw, ENETC_PM0_IF_MODE) & ENETC_PMO_IFM_RG) {
-		enetc_port_wr(hw, ENETC_PM0_IF_MODE, ENETC_PM0_IFM_RGAUTO);
-		enetc_port_wr(hw, ENETC_PM1_IF_MODE, ENETC_PM0_IFM_RGAUTO);
-	}
-	if (enetc_global_rd(hw, ENETC_G_EPFBLPR(1)) == ENETC_G_EPFBLPR1_XGMII) {
-		enetc_port_wr(hw, ENETC_PM0_IF_MODE, ENETC_PM0_IFM_XGMII);
-		enetc_port_wr(hw, ENETC_PM1_IF_MODE, ENETC_PM0_IFM_XGMII);
-	}
-}
-
-static void enetc_configure_port_pmac(struct enetc_hw *hw)
-{
-	u32 temp;
-
-	/* Set pMAC step lock */
-	temp = enetc_port_rd(hw, ENETC_PFPMR);
-	enetc_port_wr(hw, ENETC_PFPMR,
-		      temp | ENETC_PFPMR_PMACE | ENETC_PFPMR_MWLM);
-
-	temp = enetc_port_rd(hw, ENETC_MMCSR);
-	enetc_port_wr(hw, ENETC_MMCSR, temp | ENETC_MMCSR_ME);
-}
-
-static void enetc_configure_port(struct enetc_pf *pf)
-{
-	u8 hash_key[ENETC_RSSHASH_KEY_SIZE];
-	struct enetc_hw *hw = &pf->si->hw;
-
-	enetc_configure_port_pmac(hw);
-
-	enetc_configure_port_mac(hw);
-
-	enetc_port_si_configure(pf->si);
-
-	/* set up hash key */
-	get_random_bytes(hash_key, ENETC_RSSHASH_KEY_SIZE);
-	enetc_set_rss_key(hw, hash_key);
-
-	/* split up RFS entries */
-	enetc_port_assign_rfs_entries(pf->si);
-
-	/* fix-up primary MAC addresses, if not set already */
-	enetc_port_setup_primary_mac_address(pf->si);
-
-	/* enforce VLAN promisc mode for all SIs */
-	pf->vlan_promisc_simap = ENETC_VLAN_PROMISC_MAP_ALL;
-	enetc_set_vlan_promisc(hw, pf->vlan_promisc_simap);
-
-	enetc_port_wr(hw, ENETC_PSIPMR, 0);
-
-	/* enable port */
-	enetc_port_wr(hw, ENETC_PMR, ENETC_PMR_EN);
-}
-
-/* Messaging */
-static u16 enetc_msg_pf_set_vf_primary_mac_addr(struct enetc_pf *pf,
-						int vf_id)
-{
-	struct enetc_vf_state *vf_state = &pf->vf_state[vf_id];
-	struct enetc_msg_swbd *msg = &pf->rxmsg[vf_id];
-	struct enetc_msg_cmd_set_primary_mac *cmd;
-	struct device *dev = &pf->si->pdev->dev;
-	u16 cmd_id;
-	char *addr;
-
-	cmd = (struct enetc_msg_cmd_set_primary_mac *)msg->vaddr;
-	cmd_id = cmd->header.id;
-	if (cmd_id != ENETC_MSG_CMD_MNG_ADD)
-		return ENETC_MSG_CMD_STATUS_FAIL;
-
-	addr = cmd->mac.sa_data;
-	if (vf_state->flags & ENETC_VF_FLAG_PF_SET_MAC)
-		dev_warn(dev, "Attempt to override PF set mac addr for VF%d\n",
-			 vf_id);
-	else
-		enetc_pf_set_primary_mac_addr(&pf->si->hw, vf_id + 1, addr);
-
-	return ENETC_MSG_CMD_STATUS_OK;
-}
-
-void enetc_msg_handle_rxmsg(struct enetc_pf *pf, int vf_id, u16 *status)
-{
-	struct enetc_msg_swbd *msg = &pf->rxmsg[vf_id];
-	struct device *dev = &pf->si->pdev->dev;
-	struct enetc_msg_cmd_header *cmd_hdr;
-	u16 cmd_type;
-
-	*status = ENETC_MSG_CMD_STATUS_OK;
-	cmd_hdr = (struct enetc_msg_cmd_header *)msg->vaddr;
-	cmd_type = cmd_hdr->type;
-
-	switch (cmd_type) {
-	case ENETC_MSG_CMD_MNG_MAC:
-		*status = enetc_msg_pf_set_vf_primary_mac_addr(pf, vf_id);
-		break;
-	default:
-		dev_err(dev, "command not supported (cmd_type: 0x%x)\n",
-			cmd_type);
-	}
-}
-
-#ifdef CONFIG_PCI_IOV
-static int enetc_sriov_configure(struct pci_dev *pdev, int num_vfs)
-{
-	struct enetc_si *si = pci_get_drvdata(pdev);
-	struct enetc_pf *pf = enetc_si_priv(si);
-	int err;
-
-	if (!num_vfs) {
-		enetc_msg_psi_free(pf);
-		kfree(pf->vf_state);
-		pf->num_vfs = 0;
-		pci_disable_sriov(pdev);
-	} else {
-		pf->num_vfs = num_vfs;
-
-		pf->vf_state = kcalloc(num_vfs, sizeof(struct enetc_vf_state),
-				       GFP_KERNEL);
-		if (!pf->vf_state) {
-			pf->num_vfs = 0;
-			return -ENOMEM;
-		}
-
-		err = enetc_msg_psi_init(pf);
-		if (err) {
-			dev_err(&pdev->dev, "enetc_msg_psi_init (%d)\n", err);
-			goto err_msg_psi;
-		}
-
-		err = pci_enable_sriov(pdev, num_vfs);
-		if (err) {
-			dev_err(&pdev->dev, "pci_enable_sriov err %d\n", err);
-			goto err_en_sriov;
-		}
-	}
-
-	return num_vfs;
-
-err_en_sriov:
-	enetc_msg_psi_free(pf);
-err_msg_psi:
-	kfree(pf->vf_state);
-	pf->num_vfs = 0;
-
-	return err;
-}
-#else
-#define enetc_sriov_configure(pdev, num_vfs)	(void)0
-#endif
-
-static int enetc_pf_set_features(struct net_device *ndev,
-				 netdev_features_t features)
-{
-	netdev_features_t changed = ndev->features ^ features;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
-		enetc_enable_rxvlan(&priv->si->hw, 0,
-				    !!(features & NETIF_F_HW_VLAN_CTAG_RX));
-
-	if (changed & NETIF_F_HW_VLAN_CTAG_TX)
-		enetc_enable_txvlan(&priv->si->hw, 0,
-				    !!(features & NETIF_F_HW_VLAN_CTAG_TX));
-
-	if (changed & NETIF_F_LOOPBACK)
-		enetc_set_loopback(ndev, !!(features & NETIF_F_LOOPBACK));
-
-	return enetc_set_features(ndev, features);
-}
-
-static const struct net_device_ops enetc_ndev_ops = {
-	.ndo_open		= enetc_open,
-	.ndo_stop		= enetc_close,
-	.ndo_setup_tc		= enetc_setup_tc,
-	.ndo_start_xmit		= enetc_xmit,
-	.ndo_get_stats		= enetc_get_stats,
-	.ndo_set_mac_address	= enetc_pf_set_mac_addr,
-	.ndo_set_rx_mode	= enetc_pf_set_rx_mode,
-	.ndo_vlan_rx_add_vid	= enetc_vlan_rx_add_vid,
-	.ndo_vlan_rx_kill_vid	= enetc_vlan_rx_del_vid,
-	.ndo_set_vf_mac		= enetc_pf_set_vf_mac,
-	.ndo_set_vf_vlan	= enetc_pf_set_vf_vlan,
-	.ndo_set_vf_spoofchk	= enetc_pf_set_vf_spoofchk,
-	.ndo_set_features	= enetc_pf_set_features,
-	.ndo_do_ioctl		= enetc_ioctl,
-};
-
-static void enetc_pf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
-				  const struct net_device_ops *ndev_ops)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	SET_NETDEV_DEV(ndev, &si->pdev->dev);
-	priv->ndev = ndev;
-	priv->si = si;
-	priv->dev = &si->pdev->dev;
-	si->ndev = ndev;
-
-	priv->msg_enable = (NETIF_MSG_WOL << 1) - 1;
-	ndev->netdev_ops = ndev_ops;
-	enetc_set_ethtool_ops(ndev);
-	ndev->watchdog_timeo = 5 * HZ;
-	ndev->max_mtu = ENETC_MAX_MTU;
-
-	ndev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM | NETIF_F_HW_CSUM |
-			    NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |
-			    NETIF_F_LOOPBACK;
-	ndev->features = NETIF_F_HIGHDMA | NETIF_F_SG |
-			 NETIF_F_RXCSUM | NETIF_F_HW_CSUM |
-			 NETIF_F_HW_VLAN_CTAG_TX |
-			 NETIF_F_HW_VLAN_CTAG_RX |
-			 NETIF_F_HW_VLAN_CTAG_FILTER;
-
-	if (si->num_rss)
-		ndev->hw_features |= NETIF_F_RXHASH;
-
-	if (si->errata & ENETC_ERR_TXCSUM) {
-		ndev->hw_features &= ~NETIF_F_HW_CSUM;
-		ndev->features &= ~NETIF_F_HW_CSUM;
-	}
-
-	ndev->priv_flags |= IFF_UNICAST_FLT;
-
-	if (enetc_tsn_is_enabled() && (si->hw_features & ENETC_SI_F_QBV))
-		priv->hw_features |= ENETC_F_QBV;
-
-	/* pick up primary MAC address from SI */
-	enetc_get_primary_mac_addr(&si->hw, ndev->dev_addr);
-}
-
-static int enetc_of_get_phy(struct enetc_ndev_priv *priv)
-{
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	struct device_node *np = priv->dev->of_node;
-	int err;
-
-	if (!np) {
-		dev_err(priv->dev, "missing ENETC port node\n");
-		return -ENODEV;
-	}
-
-	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
-	if (!priv->phy_node) {
-		if (!of_phy_is_fixed_link(np)) {
-			dev_err(priv->dev, "PHY not specified\n");
-			return -ENODEV;
-		}
-
-		err = of_phy_register_fixed_link(np);
-		if (err < 0) {
-			dev_err(priv->dev, "fixed link registration failed\n");
-			return err;
-		}
-
-		priv->phy_node = of_node_get(np);
-	}
-
-	if (!of_phy_is_fixed_link(np)) {
-		err = enetc_mdio_probe(pf);
-		if (err) {
-			of_node_put(priv->phy_node);
-			return err;
-		}
-	}
-
-	priv->if_mode = of_get_phy_mode(np);
-	if (priv->if_mode < 0) {
-		dev_err(priv->dev, "missing phy type\n");
-		of_node_put(priv->phy_node);
-		if (of_phy_is_fixed_link(np))
-			of_phy_deregister_fixed_link(np);
-		else
-			enetc_mdio_remove(pf);
-
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void enetc_of_put_phy(struct enetc_ndev_priv *priv)
-{
-	struct device_node *np = priv->dev->of_node;
-
-	if (np && of_phy_is_fixed_link(np))
-		of_phy_deregister_fixed_link(np);
-	if (priv->phy_node)
-		of_node_put(priv->phy_node);
-}
-
-static int enetc_pf_probe(struct pci_dev *pdev,
-			  const struct pci_device_id *ent)
-{
-	struct enetc_ndev_priv *priv;
-	struct net_device *ndev;
-	struct enetc_si *si;
-	struct enetc_pf *pf;
-	int err;
-
-	if (pdev->dev.of_node && !of_device_is_available(pdev->dev.of_node)) {
-		dev_info(&pdev->dev, "device is disabled, skipping\n");
-		return -ENODEV;
-	}
-
-	err = enetc_pci_probe(pdev, KBUILD_MODNAME, sizeof(*pf));
-	if (err) {
-		dev_err(&pdev->dev, "PCI probing failed\n");
-		return err;
-	}
-
-	si = pci_get_drvdata(pdev);
-	if (!si->hw.port || !si->hw.global) {
-		err = -ENODEV;
-		dev_err(&pdev->dev, "could not map PF space, probing a VF?\n");
-		goto err_map_pf_space;
-	}
-
-	pf = enetc_si_priv(si);
-	pf->si = si;
-	pf->total_vfs = pci_sriov_get_totalvfs(pdev);
-
-	enetc_configure_port(pf);
-
-	enetc_get_si_caps(si);
-
-	ndev = alloc_etherdev_mq(sizeof(*priv), ENETC_MAX_NUM_TXQS);
-	if (!ndev) {
-		err = -ENOMEM;
-		dev_err(&pdev->dev, "netdev creation failed\n");
-		goto err_alloc_netdev;
-	}
-
-	enetc_pf_netdev_setup(si, ndev, &enetc_ndev_ops);
-
-	priv = netdev_priv(ndev);
-
-	enetc_init_si_rings_params(priv);
-
-	err = enetc_alloc_si_resources(priv);
-	if (err) {
-		dev_err(&pdev->dev, "SI resource alloc failed\n");
-		goto err_alloc_si_res;
-	}
-
-	err = enetc_alloc_msix(priv);
-	if (err) {
-		dev_err(&pdev->dev, "MSIX alloc failed\n");
-		goto err_alloc_msix;
-	}
-
-	err = enetc_of_get_phy(priv);
-	if (err)
-		dev_warn(&pdev->dev, "Fallback to PHY-less operation\n");
-
-	err = register_netdev(ndev);
-	if (err)
-		goto err_reg_netdev;
-
-	netif_carrier_off(ndev);
-
-	netif_info(priv, probe, ndev, "%s v%s\n",
-		   enetc_drv_name, enetc_drv_ver);
-
-	enetc_tsn_pf_init(ndev, pdev);
-
-	return 0;
-
-err_reg_netdev:
-	enetc_of_put_phy(priv);
-	enetc_free_msix(priv);
-err_alloc_msix:
-	enetc_free_si_resources(priv);
-err_alloc_si_res:
-	si->ndev = NULL;
-	free_netdev(ndev);
-err_alloc_netdev:
-err_map_pf_space:
-	enetc_pci_remove(pdev);
-
-	return err;
-}
-
-static void enetc_pf_remove(struct pci_dev *pdev)
-{
-	struct enetc_si *si = pci_get_drvdata(pdev);
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_ndev_priv *priv;
-
-	if (pf->num_vfs)
-		enetc_sriov_configure(pdev, 0);
-
-	priv = netdev_priv(si->ndev);
-	netif_info(priv, drv, si->ndev, "%s v%s remove\n",
-		   enetc_drv_name, enetc_drv_ver);
-
-	enetc_tsn_pf_deinit(si->ndev);
-
-	unregister_netdev(si->ndev);
-
-	enetc_mdio_remove(pf);
-	enetc_of_put_phy(priv);
-
-	enetc_free_msix(priv);
-
-	enetc_free_si_resources(priv);
-
-	free_netdev(si->ndev);
-
-	enetc_pci_remove(pdev);
-}
-
-static const struct pci_device_id enetc_pf_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PF) },
-	{ 0, } /* End of table. */
-};
-MODULE_DEVICE_TABLE(pci, enetc_pf_id_table);
-
-static struct pci_driver enetc_pf_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = enetc_pf_id_table,
-	.probe = enetc_pf_probe,
-	.remove = enetc_pf_remove,
-#ifdef CONFIG_PCI_IOV
-	.sriov_configure = enetc_sriov_configure,
-#endif
-};
-module_pci_driver(enetc_pf_driver);
-
-MODULE_DESCRIPTION(ENETC_DRV_NAME_STR);
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_VERSION(ENETC_DRV_VER_STR);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.h b/drivers/net/ethernet/freescale/enetc/enetc_pf.h
deleted file mode 100644
index 10dd1b53bb08..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
-/* Copyright 2017-2019 NXP */
-
-#include "enetc.h"
-
-#define ENETC_PF_NUM_RINGS	8
-
-enum enetc_mac_addr_type {UC, MC, MADDR_TYPE};
-#define ENETC_MAX_NUM_MAC_FLT	((ENETC_MAX_NUM_VFS + 1) * MADDR_TYPE)
-
-#define ENETC_MADDR_HASH_TBL_SZ	64
-struct enetc_mac_filter {
-	union {
-		char mac_addr[ETH_ALEN];
-		DECLARE_BITMAP(mac_hash_table, ENETC_MADDR_HASH_TBL_SZ);
-	};
-	int mac_addr_cnt;
-};
-
-#define ENETC_VLAN_HT_SIZE	64
-
-enum enetc_vf_flags {
-	ENETC_VF_FLAG_PF_SET_MAC	= BIT(0),
-};
-
-struct enetc_vf_state {
-	enum enetc_vf_flags flags;
-};
-
-struct enetc_pf {
-	struct enetc_si *si;
-	int num_vfs; /* number of active VFs, after sriov_init */
-	int total_vfs; /* max number of VFs, set for PF at probe */
-	struct enetc_vf_state *vf_state;
-
-	struct enetc_mac_filter mac_filter[ENETC_MAX_NUM_MAC_FLT];
-
-	struct enetc_msg_swbd rxmsg[ENETC_MAX_NUM_VFS];
-	struct work_struct msg_task;
-	char msg_int_name[ENETC_INT_NAME_MAX];
-
-	char vlan_promisc_simap; /* bitmap of SIs in VLAN promisc mode */
-	DECLARE_BITMAP(vlan_ht_filter, ENETC_VLAN_HT_SIZE);
-	DECLARE_BITMAP(active_vlans, VLAN_N_VID);
-
-	struct mii_bus *mdio; /* saved for cleanup */
-};
-
-int enetc_msg_psi_init(struct enetc_pf *pf);
-void enetc_msg_psi_free(struct enetc_pf *pf);
-void enetc_msg_handle_rxmsg(struct enetc_pf *pf, int mbox_id, u16 *status);
-
-/* MDIO */
-int enetc_mdio_probe(struct enetc_pf *pf);
-void enetc_mdio_remove(struct enetc_pf *pf);
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_ptp.c b/drivers/net/ethernet/freescale/enetc/enetc_ptp.c
deleted file mode 100644
index 2fd2586e42bf..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_ptp.c
+++ /dev/null
@@ -1,149 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2019 NXP */
-
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/fsl/ptp_qoriq.h>
-
-#include "enetc.h"
-
-int enetc_phc_index = -1;
-EXPORT_SYMBOL(enetc_phc_index);
-
-static struct ptp_clock_info enetc_ptp_caps = {
-	.owner		= THIS_MODULE,
-	.name		= "ENETC PTP clock",
-	.max_adj	= 512000,
-	.n_alarm	= 0,
-	.n_ext_ts	= 2,
-	.n_per_out	= 0,
-	.n_pins		= 0,
-	.pps		= 1,
-	.adjfine	= ptp_qoriq_adjfine,
-	.adjtime	= ptp_qoriq_adjtime,
-	.gettime64	= ptp_qoriq_gettime,
-	.settime64	= ptp_qoriq_settime,
-	.enable		= ptp_qoriq_enable,
-};
-
-static int enetc_ptp_probe(struct pci_dev *pdev,
-			   const struct pci_device_id *ent)
-{
-	struct ptp_qoriq *ptp_qoriq;
-	void __iomem *base;
-	int err, len, n;
-
-	if (pdev->dev.of_node && !of_device_is_available(pdev->dev.of_node)) {
-		dev_info(&pdev->dev, "device is disabled, skipping\n");
-		return -ENODEV;
-	}
-
-	err = pci_enable_device_mem(pdev);
-	if (err) {
-		dev_err(&pdev->dev, "device enable failed\n");
-		return err;
-	}
-
-	/* set up for high or low dma */
-	err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
-	if (err) {
-		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
-		if (err) {
-			dev_err(&pdev->dev,
-				"DMA configuration failed: 0x%x\n", err);
-			goto err_dma;
-		}
-	}
-
-	err = pci_request_mem_regions(pdev, KBUILD_MODNAME);
-	if (err) {
-		dev_err(&pdev->dev, "pci_request_regions failed err=%d\n", err);
-		goto err_pci_mem_reg;
-	}
-
-	pci_set_master(pdev);
-
-	ptp_qoriq = kzalloc(sizeof(*ptp_qoriq), GFP_KERNEL);
-	if (!ptp_qoriq) {
-		err = -ENOMEM;
-		goto err_alloc_ptp;
-	}
-
-	len = pci_resource_len(pdev, ENETC_BAR_REGS);
-
-	base = ioremap(pci_resource_start(pdev, ENETC_BAR_REGS), len);
-	if (!base) {
-		err = -ENXIO;
-		dev_err(&pdev->dev, "ioremap() failed\n");
-		goto err_ioremap;
-	}
-
-	/* Allocate 1 interrupt */
-	n = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSIX);
-	if (n != 1) {
-		err = -EPERM;
-		goto err_irq;
-	}
-
-	ptp_qoriq->irq = pci_irq_vector(pdev, 0);
-
-	err = request_irq(ptp_qoriq->irq, ptp_qoriq_isr, 0, DRIVER, ptp_qoriq);
-	if (err) {
-		dev_err(&pdev->dev, "request_irq() failed!\n");
-		goto err_irq;
-	}
-
-	ptp_qoriq->dev = &pdev->dev;
-
-	err = ptp_qoriq_init(ptp_qoriq, base, &enetc_ptp_caps);
-	if (err)
-		goto err_no_clock;
-
-	enetc_phc_index = ptp_qoriq->phc_index;
-	pci_set_drvdata(pdev, ptp_qoriq);
-
-	return 0;
-
-err_no_clock:
-	free_irq(ptp_qoriq->irq, ptp_qoriq);
-err_irq:
-	iounmap(base);
-err_ioremap:
-	kfree(ptp_qoriq);
-err_alloc_ptp:
-	pci_release_mem_regions(pdev);
-err_pci_mem_reg:
-err_dma:
-	pci_disable_device(pdev);
-
-	return err;
-}
-
-static void enetc_ptp_remove(struct pci_dev *pdev)
-{
-	struct ptp_qoriq *ptp_qoriq = pci_get_drvdata(pdev);
-
-	enetc_phc_index = -1;
-	ptp_qoriq_free(ptp_qoriq);
-	kfree(ptp_qoriq);
-
-	pci_release_mem_regions(pdev);
-	pci_disable_device(pdev);
-}
-
-static const struct pci_device_id enetc_ptp_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PTP) },
-	{ 0, } /* End of table. */
-};
-MODULE_DEVICE_TABLE(pci, enetc_ptp_id_table);
-
-static struct pci_driver enetc_ptp_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = enetc_ptp_id_table,
-	.probe = enetc_ptp_probe,
-	.remove = enetc_ptp_remove,
-};
-module_pci_driver(enetc_ptp_driver);
-
-MODULE_DESCRIPTION("ENETC PTP clock driver");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c b/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
deleted file mode 100644
index fb0c801c19c9..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_tsn.c
+++ /dev/null
@@ -1,1874 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2018 NXP */
-
-#ifdef CONFIG_ENETC_TSN
-#include "enetc.h"
-
-#include <net/tsn.h>
-#include <linux/module.h>
-#include <linux/irqflags.h>
-#include <linux/preempt.h>
-
-static int alloc_cbdr(struct enetc_si *si, struct enetc_cbd **curr_cbd)
-{
-	struct enetc_cbdr *ring = &si->cbd_ring;
-	int i;
-
-	i = ring->next_to_use;
-	*curr_cbd = ENETC_CBD(*ring, i);
-
-	memset(*curr_cbd, 0, sizeof(struct enetc_cbd));
-	return i;
-}
-
-/* Transmit the BD control ring by writing the pir register.
- * Update the counters maintained by software.
- */
-static int xmit_cbdr(struct enetc_si *si, int i)
-{
-	struct enetc_cbdr *ring = &si->cbd_ring;
-	struct enetc_cbd *dest_cbd;
-	int nc, timeout;
-
-	i = (i + 1) % ring->bd_count;
-
-	ring->next_to_use = i;
-	/* let H/W know BD ring has been updated */
-	enetc_wr_reg(ring->pir, i);
-
-	timeout = ENETC_CBDR_TIMEOUT;
-
-	do {
-		if (enetc_rd_reg(ring->cir) == i)
-			break;
-		udelay(10);
-		timeout -= 10;
-	} while (timeout);
-
-	if (!timeout)
-		return -EBUSY;
-#if 0
-	enetc_clean_cbdr(si);
-#endif
-	nc = ring->next_to_clean;
-
-	while (enetc_rd_reg(ring->cir) != nc) {
-		dest_cbd = ENETC_CBD(*ring, nc);
-		if (dest_cbd->status_flags & ENETC_CBD_STATUS_MASK)
-			WARN_ON(1);
-
-		/*memset(dest_cbd, 0, sizeof(*dest_cbd));*/
-
-		nc = (nc + 1) % ring->bd_count;
-	}
-
-	ring->next_to_clean = nc;
-
-	return 0;
-}
-
-/* Class 10: Flow Meter Instance Statistics Query Descriptor - Long Format */
-int enetc_qci_fmi_counters_get(struct net_device *ndev, u32 index,
-			struct fmi_query_stat_resp *counters)
-{
-	struct enetc_cbd *cbdr;
-	struct fmi_query_stat_resp *fmi_data;
-	dma_addr_t dma;
-	u16 data_size, dma_size;
-	int curr_cbd;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16((u16)index);
-	cbdr->cmd = 2;
-	cbdr->cls = BDCR_CMD_FLOW_METER;
-	cbdr->status_flags = 0;
-
-	data_size = sizeof(struct fmi_query_stat_resp);
-
-	fmi_data = (struct fmi_query_stat_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (fmi_data == NULL)
-		return -ENOMEM;
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-
-	dma = dma_map_single(&priv->si->pdev->dev, fmi_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(fmi_data);
-		return -ENOMEM;
-	}
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memcpy(counters, fmi_data, sizeof(struct fmi_query_stat_resp));
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	kfree(fmi_data);
-	return 0;
-}
-
-u16 enetc_get_max_gcl_len(struct enetc_hw *hw)
-{
-	return (enetc_rd(hw, QBV_PTGCAPR_OFFSET) & QBV_MAX_GCL_LEN_MASK);
-}
-
-/*
- * CBD Class 5: Time Gated Scheduling Gate Control List configuration
- * Descriptor - Long Format
- */
-int enetc_qbv_set(struct net_device *ndev, struct tsn_qbv_conf *admin_conf)
-{
-	struct enetc_cbd *cbdr;
-	struct tgs_gcl_data *gcl_data;
-	struct tgs_gcl_conf *gcl_config;
-	struct gce *gce;
-	u16 gcl_len;
-	u16 data_size;
-	int i;
-	dma_addr_t dma;
-	int curr_cbd;
-	struct tsn_qbv_basic *admin_basic = &admin_conf->admin;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	u32 temp;
-
-	gcl_len = admin_basic->control_list_length;
-	if (gcl_len > enetc_get_max_gcl_len(&priv->si->hw))
-		return -EINVAL;
-
-	temp = enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET);
-	if (admin_conf->gate_enabled && !(temp & QBV_TGE)) {
-		enetc_wr(&priv->si->hw, QBV_PTGCR_OFFSET, temp & (~QBV_TGE));
-		udelay(10);
-		enetc_wr(&priv->si->hw, QBV_PTGCR_OFFSET, temp | QBV_TGE);
-	} else if (!admin_conf->gate_enabled) {
-		enetc_wr(&priv->si->hw, QBV_PTGCR_OFFSET, temp & (~QBV_TGE));
-		return 0;
-	}
-
-	/*
-	 * Set the maximum frame size for each traffic class index
-	 * PTCaMSDUR[MAXSDU]. The maximum frame size cannot exceed
-	 * 9,600 bytes (0x2580). Frames that exceed the limit are
-	 * discarded.
-	 */
-	if (admin_conf->maxsdu) {
-		enetc_wr(&priv->si->hw, ENETC_PTC0MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC1MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC2MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC3MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC4MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC5MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC6MSDUR, admin_conf->maxsdu);
-		enetc_wr(&priv->si->hw, ENETC_PTC7MSDUR, admin_conf->maxsdu);
-	}
-
-	/*
-	 * Configure the (administrative) gate control list using the
-	 * control BD descriptor.
-	 */
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	gcl_config = &cbdr->gcl_conf;
-
-	data_size = sizeof(struct tgs_gcl_data) + gcl_len * sizeof(struct gce);
-
-	gcl_data = (struct tgs_gcl_data *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (gcl_data == NULL)
-		return -ENOMEM;
-
-	gce = (struct gce *)(gcl_data + 1);
-
-	gcl_config->atc = admin_basic->gate_states;
-	gcl_config->acl_len = cpu_to_le16(gcl_len);
-
-	if (!admin_basic->base_time) {
-		gcl_data->btl = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR0));
-		gcl_data->bth = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR1));
-	} else {
-		gcl_data->btl = cpu_to_le32(lower_32_bits(admin_basic->base_time));
-		gcl_data->bth = cpu_to_le32(upper_32_bits(admin_basic->base_time));
-	}
-
-	gcl_data->ct = cpu_to_le32(admin_basic->cycle_time);
-	gcl_data->cte = cpu_to_le32(admin_basic->cycle_time_extension);
-
-	for (i = 0; i < gcl_len; i++) {
-		struct gce *temp_gce = gce + i;
-		struct tsn_qbv_entry *temp_entry = admin_basic->control_list + i;
-
-		temp_gce->gate = temp_entry->gate_state;
-		temp_gce->period = cpu_to_le32(temp_entry->time_interval);
-	}
-
-	cbdr->length = cpu_to_le16(data_size);
-	cbdr->status_flags = 0; /* long format command no ie */
-
-	dma = dma_map_single(&priv->si->pdev->dev, gcl_data, data_size, DMA_TO_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(gcl_data);
-		return -ENOMEM;
-	}
-
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_PORT_GCL;
-
-	/*
-	 * Updated by ENETC on completion of the configuration
-	 * command. A zero value indicates success.
-	 */
-	cbdr->status_flags = 0;
-
-	xmit_cbdr(priv->si, curr_cbd);
-	 /* config change time could be read in the, but up layer could not get it
-	 */
-	memset(cbdr, 0, sizeof(struct enetc_cbd));
-	dma_unmap_single(&priv->si->pdev->dev, dma, data_size, DMA_TO_DEVICE);
-	kfree(gcl_data);
-
-	return 0;
-}
-
-/*
- * CBD Class 5: Time Gated Scheduling Gate Control List query
- * Descriptor - Long Format
- */
-int enetc_qbv_get(struct net_device *ndev, struct tsn_qbv_conf *admin_conf)
-{
-	struct enetc_cbd *cbdr;
-	struct tgs_gcl_resp *gcl_data;
-	struct tgs_gcl_query *gcl_query;
-	struct gce *gce;
-
-	struct tsn_qbv_basic *admin_basic = &admin_conf->admin;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	dma_addr_t dma;
-	int curr_cbd;
-	u16 maxlen;
-	u16 data_size, dma_size;
-	u16 admin_len;
-	u16 oper_len;
-	u64 temp;
-	int i;
-
-	if (enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET) & QBV_TGE) {
-		admin_conf->gate_enabled = true;
-	} else {
-		admin_conf->gate_enabled = false;
-		return 0;
-	}
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	gcl_query =  &cbdr->gcl_query;
-
-	maxlen = enetc_get_max_gcl_len(&priv->si->hw);
-
-	data_size = sizeof(struct tgs_gcl_resp) + sizeof(struct gce) * 2 * maxlen;
-
-	gcl_data = (struct tgs_gcl_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (gcl_data == NULL)
-		return -ENOMEM;
-
-	gce = (struct gce *)(gcl_data + 1);
-
-	gcl_query->acl_len = cpu_to_le16(maxlen);
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-	cbdr->status_flags = 0; /* long format command no ie */
-
-	dma = dma_map_single(&priv->si->pdev->dev, gcl_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(gcl_data);
-		return -ENOMEM;
-	}
-
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-	cbdr->cmd = 1;
-	cbdr->cls = BDCR_CMD_PORT_GCL;
-	xmit_cbdr(priv->si, curr_cbd);
-	dma_unmap_single(&priv->si->pdev->dev, dma, data_size, DMA_FROM_DEVICE);
-
-	/* since cbdr already passed to free, below could be get wrong */
-	admin_len = le16_to_cpu(gcl_query->admin_list_len);
-	oper_len = le16_to_cpu(gcl_query->oper_list_len);
-
-	admin_basic->control_list_length = admin_len;
-
-	temp = ((u64)le32_to_cpu(gcl_data->abth)) << 32;
-	admin_basic->base_time = le32_to_cpu(gcl_data->abtl) + temp;
-
-	admin_basic->cycle_time = le32_to_cpu(gcl_data->act);
-	admin_basic->cycle_time_extension = le32_to_cpu(gcl_data->acte);
-
-	admin_basic->control_list =
-		kzalloc(admin_len *	sizeof(*(admin_basic->control_list)), GFP_KERNEL);
-	if (admin_basic->control_list == NULL) {
-		memset(cbdr, 0, sizeof(*cbdr));
-		kfree(gcl_data);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < admin_len; i++) {
-		struct gce *temp_gce = gce + i;
-		struct tsn_qbv_entry *temp_entry = admin_basic->control_list + i;
-
-		temp_entry->gate_state = temp_gce->gate;
-		temp_entry->time_interval = le32_to_cpu(temp_gce->period);
-	}
-
-	/* Updated by ENETC on completion of the configuration
-	 * command. A zero value indicates success.
-	 */
-	admin_conf->config_change = true;
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	kfree(gcl_data);
-
-	return 0;
-}
-
-int enetc_qbv_get_status(struct net_device *ndev,
-			 struct tsn_qbv_status *status)
-{
-	struct enetc_cbd *cbdr;
-	struct tgs_gcl_resp *gcl_data;
-	struct tgs_gcl_query *gcl_query;
-	struct gce *gce;
-	struct tsn_qbv_basic *oper_basic;
-	struct enetc_ndev_priv *priv;
-	dma_addr_t dma;
-	int curr_cbd;
-	u16 maxlen;
-	u16 data_size, dma_size;
-	u16 admin_len;
-	u16 oper_len;
-	u64 temp;
-	int i;
-
-	if (!ndev)
-		return -EINVAL;
-
-	if (!status)
-		return -EINVAL;
-
-	oper_basic = &status->oper;
-	priv = netdev_priv(ndev);
-
-	if (!(enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET) & QBV_TGE))
-		return -EINVAL;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	gcl_query = &cbdr->gcl_query;
-
-	maxlen = enetc_get_max_gcl_len(&priv->si->hw);
-
-	data_size = sizeof(struct tgs_gcl_resp) + sizeof(struct gce) * 2 * maxlen;
-
-	gcl_data = (struct tgs_gcl_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (gcl_data == NULL)
-		return -ENOMEM;
-
-	gce = (struct gce *)(gcl_data + 1);
-
-	gcl_query->acl_len = cpu_to_le16(maxlen);
-	gcl_query->ocl_len = cpu_to_le16(maxlen);
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-	cbdr->status_flags = 0; /* long format command no ie */
-
-	dma = dma_map_single(&priv->si->pdev->dev, gcl_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(gcl_data);
-		return -ENOMEM;
-	}
-
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-	cbdr->cmd = 1;
-	cbdr->cls = BDCR_CMD_PORT_GCL;
-	xmit_cbdr(priv->si, curr_cbd);
-	dma_unmap_single(&priv->si->pdev->dev, dma, data_size, DMA_FROM_DEVICE);
-
-	/* since cbdr already passed to free, below could be get wrong */
-	admin_len = le16_to_cpu(gcl_query->admin_list_len);
-	oper_len = le16_to_cpu(gcl_query->oper_list_len);
-
-	if (enetc_rd(&priv->si->hw, QBV_PTGAGLSR_OFFSET) &
-						QBV_CFG_PEND_MASK) {
-		status->config_pending = true;
-		goto exit;
-	}
-
-	/* The Oper and Admin timing fields exist in the response buffer even
-	 * if no valid corresponding lists exists. These fields are considered
-	 * invalid if the corresponding list does not exist.
-	 */
-	status->config_pending = false;
-	temp = ((u64)le32_to_cpu(gcl_data->ccth)) << 32;
-	status->config_change_time = le32_to_cpu(gcl_data->cctl) + temp;
-
-	temp = ((u64)le32_to_cpu(gcl_data->cceh)) << 32;
-	status->config_change_error = le32_to_cpu(gcl_data->ccel) + temp;
-
-	/* changed to SITGTGR */
-	status->tick_granularity = enetc_rd(&priv->si->hw, ENETC_SITGTGR);
-
-	/* current time */
-	temp = ((u64)enetc_rd(&priv->si->hw, ENETC_SICTR1)) << 32;
-	status->current_time = enetc_rd(&priv->si->hw, ENETC_SICTR0) + temp;
-
-	status->supported_list_max = maxlen;
-
-	/* status->oper.gate_states , no init oper/admin gate state */
-	status->oper.control_list_length = oper_len;
-	temp = ((u64)le32_to_cpu(gcl_data->obth)) << 32;
-	status->oper.base_time = le32_to_cpu(gcl_data->obtl) + temp;
-	status->oper.cycle_time = le32_to_cpu(gcl_data->oct);
-	status->oper.cycle_time_extension = le32_to_cpu(gcl_data->octe);
-
-
-	oper_basic->control_list =
-		kzalloc(oper_len * sizeof(*(oper_basic->control_list)), GFP_KERNEL);
-	if (oper_basic->control_list == NULL) {
-		memset(cbdr, 0, sizeof(*cbdr));
-		kfree(gcl_data);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < oper_len; i++) {
-		struct gce *temp_gce = gce + maxlen + i;
-		struct tsn_qbv_entry *temp_entry = oper_basic->control_list + i;
-		temp_entry->gate_state = temp_gce->gate;
-		temp_entry->time_interval = le32_to_cpu(temp_gce->period);
-	}
-
-exit:
-	memset(cbdr, 0, sizeof(*cbdr));
-	kfree(gcl_data);
-	return 0;
-}
-
-/* CBD Class 7: Stream Identity Entry Set Descriptor - Long Format */
-int enetc_cb_streamid_set(struct net_device *ndev, u32 index,
-				bool en, struct tsn_cb_streamid *streamid)
-{
-	struct enetc_cbd *cbdr;
-	void *si_data;
-	struct null_streamid_data *si_data1;
-	struct smac_streamid_data *si_data2;
-	struct streamid_conf *si_conf;
-	struct enetc_ndev_priv *priv;
-	dma_addr_t dma;
-	u16 data_size, dma_size;
-	int curr_cbd;
-
-	if (!ndev)
-		return -EINVAL;
-
-	priv = netdev_priv(ndev);
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16((u16)index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_STREAM_IDENTIFY;
-	cbdr->status_flags = 0;
-
-	data_size = sizeof(struct null_streamid_data);
-	si_data = (struct null_streamid_data *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	cbdr->length = cpu_to_le16(data_size);
-
-	dma = dma_map_single(&priv->si->pdev->dev, si_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(si_data);
-		return -ENOMEM;
-	}
-
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-	si_data1 = (struct null_streamid_data *)si_data;
-	si_data1->dmac[0] = 0xFF;
-	si_data1->dmac[1] = 0xFF;
-	si_data1->dmac[2] = 0xFF;
-	si_data1->dmac[3] = 0xFF;
-	si_data1->dmac[4] = 0xFF;
-	si_data1->dmac[5] = 0xFF;
-	si_data1->vid_vidm_tg =	cpu_to_le16(ENETC_CBDR_SID_VID_MASK +
-								((0x3 << 14) | ENETC_CBDR_SID_VIDM));
-
-	si_conf = &cbdr->sid_set;
-	/* Only one port supported for one entry, set itself */
-	si_conf->iports = 1 << (priv->si->pdev->devfn & 0x7);
-	si_conf->id_type = 1;
-	si_conf->oui[2] = 0x0;
-	si_conf->oui[1] = 0x80;
-	si_conf->oui[0] = 0xC2;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	kfree(si_data);
-
-	if (!en)
-		return 0;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16((u16)index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_STREAM_IDENTIFY;
-	cbdr->status_flags = 0;
-
-	si_conf = &cbdr->sid_set;
-	si_conf->en = 0x80;
-	si_conf->stream_handle = cpu_to_le32(streamid->handle);
-	si_conf->iports = 1 << (priv->si->pdev->devfn & 0x7);
-	si_conf->id_type = streamid->type;
-	si_conf->oui[2] = 0x0;
-	si_conf->oui[1] = 0x80;
-	si_conf->oui[0] = 0xC2;
-
-	if (si_conf->id_type == 1) {
-		data_size = sizeof(struct null_streamid_data);
-		si_data = (struct null_streamid_data *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	} else if (si_conf->id_type == 2) {
-		data_size = sizeof(struct smac_streamid_data);
-		si_data = (struct smac_streamid_data *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	} else
-		return -EINVAL;
-
-	if (si_data == NULL)
-		return -ENOMEM;
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-	cbdr->status_flags = 0; /* long format command no ie */
-
-	dma = dma_map_single(&priv->si->pdev->dev, si_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		memset(cbdr, 0, sizeof(*cbdr));
-		kfree(si_data);
-		return -ENOMEM;
-	}
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-
-	/* VIDM default to be 1.
-	 * VID Match. If set (b1) then the VID must match, otherwise
-	 * any VID is considered a match. VIDM setting is only used
-	 * when TG is set to b01. */
-	if (si_conf->id_type == 1) {
-		si_data1 = (struct null_streamid_data *)si_data;
-		si_data1->dmac[0] = streamid->para.nid.dmac & 0xFF;
-		si_data1->dmac[1] = (streamid->para.nid.dmac >> 8) & 0xFF;
-		si_data1->dmac[2] = (streamid->para.nid.dmac >> 16) & 0xFF;
-		si_data1->dmac[3] = (streamid->para.nid.dmac >> 24) & 0xFF;
-		si_data1->dmac[4] = (streamid->para.nid.dmac >> 32) & 0xFF;
-		si_data1->dmac[5] = (streamid->para.nid.dmac >> 40) & 0xFF;
-		si_data1->vid_vidm_tg =
-		cpu_to_le16((streamid->para.nid.vid & ENETC_CBDR_SID_VID_MASK) +
-			((((u16)(streamid->para.nid.tagged) & 0x3) << 14) | ENETC_CBDR_SID_VIDM));
-	} else if (si_conf->id_type == 2) {
-		si_data2 = (struct smac_streamid_data *)si_data;
-		si_data2->smac[0] = streamid->para.sid.smac & 0xFF;
-		si_data2->smac[1] = (streamid->para.sid.smac >> 8) & 0xFF;
-		si_data2->smac[2] = (streamid->para.sid.smac >> 16) & 0xFF;
-		si_data2->smac[3] = (streamid->para.sid.smac >> 24) & 0xFF;
-		si_data2->smac[4] = (streamid->para.sid.smac >> 32) & 0xFF;
-		si_data2->smac[5] = (streamid->para.sid.smac >> 40) & 0xFF;
-		si_data2->vid_vidm_tg =
-		cpu_to_le16((streamid->para.sid.vid & ENETC_CBDR_SID_VID_MASK) +
-			((((u16)(streamid->para.sid.tagged) & 0x3) << 14) | ENETC_CBDR_SID_VIDM));
-	}
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	kfree(si_data);
-
-	return 0;
-}
-
-/* CBD Class 7: Stream Identity Entry Query Descriptor - Long Format */
-int enetc_cb_streamid_get(struct net_device *ndev, u32 index,
-			  struct tsn_cb_streamid *streamid)
-{
-	struct enetc_cbd *cbdr;
-	struct streamid_query_resp *si_data;
-	struct enetc_ndev_priv *priv;
-	dma_addr_t dma;
-	u16 data_size, dma_size;
-	int curr_cbd;
-	int valid;
-
-	if (!ndev)
-		return -EINVAL;
-
-	priv = netdev_priv(ndev);
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le32(index);
-	cbdr->cmd = 1;
-	cbdr->cls = BDCR_CMD_STREAM_IDENTIFY;
-	cbdr->status_flags = 0;
-
-	data_size = sizeof(struct streamid_query_resp);
-	si_data = (struct streamid_query_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (si_data == NULL)
-		return -ENOMEM;
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-	cbdr->status_flags = 0; /* long format command no ie */
-
-	dma = dma_map_single(&priv->si->pdev->dev, si_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(si_data);
-		return -ENOMEM;
-	}
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	streamid->type = si_data->id_type;
-
-	if (streamid->type == 1) {
-		streamid->para.nid.dmac = si_data->mac[0] + ((u64)si_data->mac[1] << 8)
-			+ ((u64)si_data->mac[2] << 16) + ((u64)si_data->mac[3] << 24)
-			+ ((u64)si_data->mac[4] << 32) + ((u64)si_data->mac[5] << 40);
-		/* VID Match. If set (b1) then the VID must match, otherwise
-		 * any VID is considered a match.
-		*/
-		streamid->para.nid.vid =
-				le16_to_cpu(si_data->vid_vidm_tg & ENETC_CBDR_SID_VID_MASK);
-		streamid->para.nid.tagged =
-				le16_to_cpu(si_data->vid_vidm_tg >> 14 & 0x3);
-	} else if (streamid->type == 2) {
-		streamid->para.sid.smac = si_data->mac[0] + ((u64)si_data->mac[1] << 8)
-			+ ((u64)si_data->mac[2] << 16) + ((u64)si_data->mac[3] << 24)
-			+ ((u64)si_data->mac[4] << 32) + ((u64)si_data->mac[5] << 40);
-		/* VID Match. If set (b1) then the VID must match, otherwise
-		 * any VID is considered a match.
-		 */
-		streamid->para.sid.vid =
-				le16_to_cpu(si_data->vid_vidm_tg & ENETC_CBDR_SID_VID_MASK);
-		streamid->para.sid.tagged =
-				le16_to_cpu(si_data->vid_vidm_tg >> 14 & 0x3);
-	}
-
-	streamid->handle = le32_to_cpu(si_data->stream_handle);
-	streamid->ifac_iport = le32_to_cpu(si_data->input_ports);
-	valid = si_data->en ? 1 : 0;
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	kfree(si_data);
-
-	return valid;
-}
-
-/*  CBD Class 7: Stream Identity Statistics Query Descriptor - Long Format */
-int enetc_cb_streamid_counters_get(struct net_device *ndev, u32 index,
-				   struct tsn_cb_streamid_counters *counters)
-{
-	return 0;
-}
-
-void enetc_qci_enable(struct enetc_hw *hw)
-{
-	enetc_wr(hw, ENETC_PPSFPMR, enetc_rd(hw, ENETC_PPSFPMR)
-					| ENETC_PPSFPMR_PSFPEN | ENETC_PPSFPMR_VS
-					| ENETC_PPSFPMR_PVC | ENETC_PPSFPMR_PVZC);
-}
-
-void enetc_qci_disable(struct enetc_hw *hw)
-{
-	enetc_wr(hw, ENETC_PPSFPMR, enetc_rd(hw, ENETC_PPSFPMR)
-					& ~ENETC_PPSFPMR_PSFPEN & ~ENETC_PPSFPMR_VS
-					& ~ENETC_PPSFPMR_PVC & ~ENETC_PPSFPMR_PVZC);
-}
-
-/* CBD Class 8: Stream Filter Instance Set Descriptor - Short Format */
-int enetc_qci_sfi_set(struct net_device *ndev, u32 index, bool en,
-		struct tsn_qci_psfp_sfi_conf *tsn_qci_sfi)
-{
-	struct enetc_cbd *cbdr;
-	struct sfi_conf *sfi_config;
-
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int curr_cbd;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_STREAM_FILTER;
-	cbdr->status_flags = 0x80;
-	cbdr->length = cpu_to_le16(1);
-
-	sfi_config = &cbdr->sfi_conf;
-	if (en)
-		sfi_config->en = 0x80;
-
-	if (tsn_qci_sfi->stream_handle_spec >= 0) {
-		sfi_config->stream_handle =
-			cpu_to_le32(tsn_qci_sfi->stream_handle_spec);
-		sfi_config->sthm |= 0x80;
-	}
-
-	sfi_config->sg_inst_table_index =
-		cpu_to_le16(tsn_qci_sfi->stream_gate_instance_id);
-	sfi_config->input_ports = 1 << (priv->si->pdev->devfn & 0x7);
-
-	/* The priority value which may be matched against the
-	 * frame’s priority value to determine a match for this entry.
-	 */
-	if (tsn_qci_sfi->priority_spec >= 0)
-		sfi_config->multi |= (tsn_qci_sfi->priority_spec & 0x7) | 0x8;
-
-	/* Filter Type. Identifies the contents of the MSDU/FM_INST_INDEX
-	 * field as being either an MSDU value or an index into the Flow
-	 * Meter Instance table.
-	 */
-	if (tsn_qci_sfi->stream_filter.maximum_sdu_size != 0) {
-		sfi_config->msdu =
-		cpu_to_le16(tsn_qci_sfi->stream_filter.maximum_sdu_size);
-		sfi_config->multi |= 0x40;
-	}
-
-	if (tsn_qci_sfi->stream_filter.flow_meter_instance_id >= 0) {
-		sfi_config->fm_inst_table_index =
-		cpu_to_le16(tsn_qci_sfi->stream_filter.flow_meter_instance_id);
-		sfi_config->multi |= 0x80;
-	}
-
-	/* Stream blocked due to oversized frame enable. TRUE or FALSE */
-	if (tsn_qci_sfi->block_oversize_enable)
-		sfi_config->multi |= 0x20;
-
-	/* Stream blocked due to oversized frame. TRUE or FALSE */
-	if (tsn_qci_sfi->block_oversize)
-		sfi_config->multi |= 0x10;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	return 0;
-}
-
-/* CBD Class 8: Stream Filter Instance Query Descriptor - Short Format */
-int enetc_qci_sfi_get(struct net_device *ndev, u32 index,
-						struct tsn_qci_psfp_sfi_conf *tsn_qci_sfi)
-{
-	struct enetc_cbd *cbdr;
-	struct sfi_conf *sfi_config;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int curr_cbd;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 1;
-	cbdr->cls = BDCR_CMD_STREAM_FILTER;
-	cbdr->status_flags = 0x80;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	sfi_config = &cbdr->sfi_conf;
-	if (sfi_config->sthm & 0x80)
-		tsn_qci_sfi->stream_handle_spec =
-			le32_to_cpu(sfi_config->stream_handle);
-	else
-		tsn_qci_sfi->stream_handle_spec = -1;
-
-	tsn_qci_sfi->stream_gate_instance_id =
-		le16_to_cpu(sfi_config->sg_inst_table_index);
-
-	if (sfi_config->multi & 0x8)
-		tsn_qci_sfi->priority_spec = le16_to_cpu(sfi_config->multi & 0x7);
-	else
-		tsn_qci_sfi->priority_spec = -1;
-
-	/* Filter Type. Identifies the contents of the MSDU/FM_INST_INDEX
-	 * field as being either an MSDU value or an index into the Flow
-	 * Meter Instance table.
-	 */
-	if (sfi_config->multi & 0x80)
-		tsn_qci_sfi->stream_filter.flow_meter_instance_id =
-			le16_to_cpu(sfi_config->fm_inst_table_index);
-	else
-		tsn_qci_sfi->stream_filter.flow_meter_instance_id = -1;
-
-	if (sfi_config->multi & 0x40)
-		tsn_qci_sfi->stream_filter.maximum_sdu_size =
-			le16_to_cpu(sfi_config->msdu);
-
-	/* Stream blocked due to oversized frame enable. TRUE or FALSE */
-	if (sfi_config->multi & 0x20)
-		tsn_qci_sfi->block_oversize_enable = true;
-	/* Stream blocked due to oversized frame. TRUE or FALSE */
-	if (sfi_config->multi & 0x10)
-		tsn_qci_sfi->block_oversize = true;
-
-	if (sfi_config->en & 0x80) {
-		memset(cbdr, 0, sizeof(*cbdr));
-		return 1;
-	}
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	return 0;
-}
-
-/* CBD Class 8: Stream Filter Instance Query Statistics
- * Descriptor - Long Format
- */
-int enetc_qci_sfi_counters_get(struct net_device *ndev, u32 index,
-							struct tsn_qci_psfp_sfi_counters *counters)
-{
-	struct enetc_cbd *cbdr;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int curr_cbd;
-	struct sfi_counter_data *sfi_counter_data;
-	dma_addr_t dma;
-	u16 data_size, dma_size;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16((u16)index);
-	cbdr->cmd = 2;
-	cbdr->cls = BDCR_CMD_STREAM_FILTER;
-	cbdr->status_flags = 0;
-
-	data_size = sizeof(struct sfi_counter_data);
-	sfi_counter_data = (struct sfi_counter_data *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (sfi_counter_data == NULL)
-		return -ENOMEM;
-
-	dma = dma_map_single(&priv->si->pdev->dev, sfi_counter_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(sfi_counter_data);
-		return -ENOMEM;
-	}
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	counters->matching_frames_count =
-			((u64)le32_to_cpu(sfi_counter_data->matchh) << 32)
-			+ sfi_counter_data->matchl;
-
-	counters->not_passing_sdu_count =
-			((u64)le32_to_cpu(sfi_counter_data->msdu_droph) << 32)
-			+ sfi_counter_data->msdu_dropl;
-
-	counters->passing_sdu_count = counters->matching_frames_count
-				- counters->not_passing_sdu_count;
-
-	counters->not_passing_frames_count = ((u64)le32_to_cpu(sfi_counter_data->stream_gate_droph) << 32)
-				+ le32_to_cpu(sfi_counter_data->stream_gate_dropl);
-
-	counters->passing_frames_count = counters->matching_frames_count
-				- counters->not_passing_sdu_count
-				- counters->not_passing_frames_count;
-
-	counters->red_frames_count = ((u64)le32_to_cpu(sfi_counter_data->flow_meter_droph) << 32)
-				+ le32_to_cpu(sfi_counter_data->flow_meter_dropl);
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	return 0;
-}
-
-/*
- * CBD Class 9: Stream Gate Instance Table Entry Set
- * Descriptor - Short Format
- */
-int enetc_qci_sgi_set(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_sgi_conf *tsn_qci_sgi)
-{
-	struct enetc_cbd *cbdr, *cbdr_sgcl;
-	struct sgi_table *sgi_config;
-	struct sgcl_conf *sgcl_config;
-	struct sgcl_data *sgcl_data;
-	struct sgce *sgce;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	dma_addr_t dma;
-	u16 data_size, dma_size;
-	int curr_cbd, i;
-
-	/* disable first */
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-	memset(cbdr, 0, sizeof(*cbdr));
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_STREAM_GCL;
-	cbdr->status_flags = 0x80;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	if (!tsn_qci_sgi->gate_enabled) {
-		memset(cbdr, 0, sizeof(*cbdr));
-		return 0;
-	}
-
-	/* Re-enable */
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-	memset(cbdr, 0, sizeof(*cbdr));
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_STREAM_GCL;
-	cbdr->status_flags = 0x80;
-
-	sgi_config = &cbdr->sgi_table;
-
-	sgi_config->ocgtst = tsn_qci_sgi->admin.control_list_length ?
-			0x80 : (tsn_qci_sgi->admin.gate_states ? 0x80 : 0x0);
-
-	sgi_config->oipv = tsn_qci_sgi->admin.control_list_length ?
-			0x0 : ((tsn_qci_sgi->admin.init_ipv < 0) ?
-					0x0 : ((tsn_qci_sgi->admin.init_ipv & 0x7) | 0x8));
-
-	sgi_config->en = 0x80;
-
-	if (tsn_qci_sgi->block_invalid_rx_enable)
-		sgi_config->gset |= 0x80;
-	if (tsn_qci_sgi->block_invalid_rx)
-		sgi_config->gset |= 0x40;
-	if (tsn_qci_sgi->block_octets_exceeded)
-		sgi_config->gset |= 0x10;
-	if (tsn_qci_sgi->block_octets_exceeded_enable)
-		sgi_config->gset |= 0x20;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	if (tsn_qci_sgi->admin.control_list_length == 0)
-		goto exit;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr_sgcl);
-	memset(cbdr, 0, sizeof(*cbdr));
-
-	cbdr_sgcl->index = cpu_to_le16(index);
-	cbdr_sgcl->cmd = 1;
-	cbdr_sgcl->cls = BDCR_CMD_STREAM_GCL;
-	cbdr_sgcl->status_flags = 0;
-
-	sgcl_config = &cbdr_sgcl->sgcl_conf;
-
-	/* tsn_qci_sgi->admin.control_list_length is not zero now */
-	if (tsn_qci_sgi->admin.control_list_length > 4)
-		return -EINVAL;
-	else
-		sgcl_config->acl_len = (tsn_qci_sgi->admin.control_list_length - 1) & 0x3;
-
-	data_size = sizeof(struct sgcl_data) +
-		(sgcl_config->acl_len + 1) * sizeof(struct sgce);
-
-	sgcl_data = (struct sgcl_data *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (sgcl_data == NULL)
-		return -ENOMEM;
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr_sgcl->length = dma_size;
-
-	dma = dma_map_single(&priv->si->pdev->dev, sgcl_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		memset(cbdr, 0, sizeof(*cbdr));
-		memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-		kfree(sgcl_data);
-		return -ENOMEM;
-	}
-	cbdr_sgcl->addr[0] = lower_32_bits(dma);
-	cbdr_sgcl->addr[1] = upper_32_bits(dma);
-
-	sgce = (struct sgce *)(sgcl_data + 1);
-
-	if (tsn_qci_sgi->admin.gate_states)
-		sgcl_config->agtst = 0x80;
-
-	sgcl_data->ct = cpu_to_le32(tsn_qci_sgi->admin.cycle_time);
-	sgcl_data->cte = cpu_to_le32(tsn_qci_sgi->admin.cycle_time_extension);
-
-	if (tsn_qci_sgi->admin.init_ipv >= 0)
-		sgcl_config->aipv = (tsn_qci_sgi->admin.init_ipv & 0x7) | 0x8;
-
-	for (i = 0; i < tsn_qci_sgi->admin.control_list_length; i++) {
-		struct tsn_qci_psfp_gcl *temp_sgcl = tsn_qci_sgi->admin.gcl + i;
-		struct sgce *temp_entry = (struct sgce *)(sgce + i);
-
-		if (temp_sgcl->gate_state)
-			temp_entry->multi |= 0x10;
-
-		if (temp_sgcl->ipv >= 0)
-			temp_entry->multi |= ((temp_sgcl->ipv & 0x7) << 5) | 0x08;
-
-		if (temp_sgcl->octet_max)
-			temp_entry->multi |= 0x01;
-
-		temp_entry->interval = cpu_to_le32(temp_sgcl->time_interval);
-		temp_entry->msdu[0] = temp_sgcl->octet_max & 0xFF;
-		temp_entry->msdu[1] = (temp_sgcl->octet_max >> 8) & 0xFF;
-		temp_entry->msdu[2] = (temp_sgcl->octet_max >> 16) & 0xFF;
-	}
-
-	if (!tsn_qci_sgi->admin.base_time) {
-		sgcl_data->btl = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR0));
-		sgcl_data->bth = cpu_to_le32(enetc_rd(&priv->si->hw, ENETC_SICTR1));
-	} else {
-		sgcl_data->bth = cpu_to_le32(upper_32_bits(tsn_qci_sgi->admin.base_time));
-		sgcl_data->btl = cpu_to_le32(lower_32_bits(tsn_qci_sgi->admin.base_time));
-	}
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-	kfree(sgcl_data);
-
-exit:
-	memset(cbdr, 0, sizeof(*cbdr));
-	return 0;
-}
-
-/* CBD Class 9: Stream Gate Instance Table Entry Query
- * Descriptor - Short Format
- */
-int enetc_qci_sgi_get(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_sgi_conf *tsn_qci_sgi)
-{
-	struct enetc_cbd *cbdr, *cbdr_sgcl;
-	struct sgi_table *sgi_config;
-	struct sgcl_query *sgcl_query;
-	struct sgcl_query_resp *sgcl_data;
-	struct sgce *sgce;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	dma_addr_t dma;
-	u16 data_size, dma_size, gcl_data_stat = 0;
-	u8 admin_len = 0;
-	int curr_cbd, i;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 2;
-	cbdr->cls = BDCR_CMD_STREAM_GCL;
-	cbdr->status_flags = 0x80;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	sgi_config = &cbdr->sgi_table;
-
-	tsn_qci_sgi->admin.gate_states = ((sgi_config->ocgtst & 0x80) ? true : false);
-	if (sgi_config->oipv & 0x08)
-		tsn_qci_sgi->admin.init_ipv = sgi_config->oipv & 0x7;
-	else
-		tsn_qci_sgi->admin.init_ipv = -1;
-
-	if (sgi_config->en & 0x80)
-		tsn_qci_sgi->gate_enabled = true;
-	if (sgi_config->gset & 0x80)
-		tsn_qci_sgi->block_invalid_rx_enable = true;
-	if (sgi_config->gset & 0x40)
-		tsn_qci_sgi->block_invalid_rx = true;
-	if (sgi_config->gset & 0x20)
-		tsn_qci_sgi->block_octets_exceeded_enable = true;
-	if (sgi_config->gset & 0x10)
-		tsn_qci_sgi->block_octets_exceeded = true;
-
-	/* Check gate list length is zero? */
-	if (!(sgi_config->oacl_len & 0x30)) {
-		tsn_qci_sgi->admin.control_list_length = 0;
-		goto exit;
-	}
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr_sgcl);
-
-	cbdr_sgcl->index = cpu_to_le16(index);
-	cbdr_sgcl->cmd = 3;
-	cbdr_sgcl->cls = BDCR_CMD_STREAM_GCL;
-	cbdr_sgcl->status_flags = 0;
-
-	data_size = sizeof(struct sgcl_query_resp) + 4 * sizeof(struct sgce); /* Max is 4 */
-
-	sgcl_data = (struct sgcl_query_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (sgcl_data == NULL)
-		return -ENOMEM;
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr_sgcl->length = dma_size;
-	cbdr_sgcl->status_flags = 0;
-
-	sgcl_query = &cbdr_sgcl->sgcl_query;
-
-	sgcl_query->oacl_len = 0x10;
-
-	dma = dma_map_single(&priv->si->pdev->dev, sgcl_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		memset(cbdr, 0, sizeof(*cbdr));
-		memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-		kfree(sgcl_data);
-		return -ENOMEM;
-	}
-	cbdr_sgcl->addr[0] = lower_32_bits(dma);
-	cbdr_sgcl->addr[1] = upper_32_bits(dma);
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	sgce = (struct sgce *)(sgcl_data + 1);
-
-	gcl_data_stat = le16_to_cpu(sgcl_data->stat);
-	if (gcl_data_stat & 0x10)
-		tsn_qci_sgi->admin.gate_states = true;
-
-	if (gcl_data_stat & 0x80)
-		tsn_qci_sgi->admin.init_ipv = gcl_data_stat & 0x7;
-	else
-		tsn_qci_sgi->admin.init_ipv = -1;
-
-	/* admin_len can also get from gcl_data_stat bit 5,6 OR sgi_config->oacl_len */
-	admin_len = (sgcl_query->oacl_len & 0x3) + 1;
-	tsn_qci_sgi->admin.control_list_length = admin_len;
-	tsn_qci_sgi->admin.cycle_time = le32_to_cpu(sgcl_data->act);
-	tsn_qci_sgi->admin.cycle_time_extension = le32_to_cpu(sgcl_data->acte);
-	tsn_qci_sgi->admin.base_time = ((u64)(le32_to_cpu(sgcl_data->abth)) << 32)
-						+ le32_to_cpu(sgcl_data->abtl);
-
-	tsn_qci_sgi->admin.gcl =
-		kzalloc(admin_len * sizeof(struct tsn_qci_psfp_gcl), GFP_KERNEL);
-	if (tsn_qci_sgi->admin.gcl == NULL) {
-		kfree(sgcl_data);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < admin_len; i++) {
-		struct tsn_qci_psfp_gcl *temp_sgcl = tsn_qci_sgi->admin.gcl + i;
-		struct sgce *temp_entry = (struct sgce *)(sgce + i);
-
-		if (temp_entry->multi & 0x10)
-			temp_sgcl->gate_state = true;
-
-		if (temp_entry->multi & 0x08)
-			temp_sgcl->ipv = temp_entry->multi >> 5;
-		else
-			temp_sgcl->ipv = -1;
-
-		temp_sgcl->time_interval = le32_to_cpu(temp_entry->interval);
-
-		if (temp_entry->multi & 0x01)
-			temp_sgcl->octet_max = (temp_entry->msdu[0] & 0xff)
-							| (((u32)temp_entry->msdu[1] << 8) & 0xff00)
-							| (((u32)temp_entry->msdu[1] << 16) & 0xff0000);
-		else
-			temp_sgcl->octet_max = 0;
-	}
-
-	memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-	kfree(sgcl_data);
-
-exit:
-	memset(cbdr, 0, sizeof(*cbdr));
-	return 0;
-}
-
-/* CBD Class 9: Stream Gate Instance Table Entry Query Descriptor - Short Format */
-/* CBD Class 9: Stream Gate Control List Query Descriptor - Long Format */
-int enetc_qci_sgi_status_get(struct net_device *ndev, u16 index,
-				struct tsn_psfp_sgi_status *status)
-{
-	struct enetc_cbd *cbdr_sgi, *cbdr_sgcl;
-	struct sgi_table *sgi_config;
-	struct sgcl_query *sgcl_query;
-	struct sgcl_query_resp *sgcl_data;
-	struct sgce *sgce;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	dma_addr_t dma;
-	u16 data_size, dma_size, gcl_data_stat = 0;
-	u8 oper_len = 0;
-	u64 temp;
-	int curr_cbd, i;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr_sgi);
-
-	cbdr_sgi->index = cpu_to_le16(index);
-	cbdr_sgi->cmd = 2;
-	cbdr_sgi->cls = BDCR_CMD_STREAM_GCL;
-	cbdr_sgi->status_flags = 0x80;
-
-	sgi_config = &cbdr_sgi->sgi_table;
-
-	if (sgi_config->gset & 0x4)
-		status->config_pending = true;
-
-	status->oper.gate_states = ((sgi_config->ocgtst & 0x80) ? true : false);
-
-	/* Check gate list length is zero? */
-	if (!(sgi_config->oacl_len & 0x30)) {
-		status->oper.control_list_length = 0;
-		goto cmd2quit;
-	}
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr_sgcl);
-
-	cbdr_sgcl->index = cpu_to_le16(index);
-	cbdr_sgcl->cmd = 3;
-	cbdr_sgcl->cls = BDCR_CMD_STREAM_GCL;
-	cbdr_sgcl->status_flags = 0;
-
-	data_size = sizeof(struct sgcl_query_resp) + 4 * sizeof(struct sgce); /* Max is 4 */
-
-	sgcl_data = (struct sgcl_query_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (sgcl_data == NULL)
-		return -ENOMEM;
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr_sgcl->length = dma_size;
-	cbdr_sgcl->status_flags = 0;
-
-	sgcl_query = &cbdr_sgcl->sgcl_query;
-
-	sgcl_query->oacl_len = 0x20;
-
-	dma = dma_map_single(&priv->si->pdev->dev, sgcl_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		memset(cbdr_sgi, 0, sizeof(*cbdr_sgi));
-		memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-		kfree(sgcl_data);
-		return -ENOMEM;
-	}
-	cbdr_sgcl->addr[0] = lower_32_bits(dma);
-	cbdr_sgcl->addr[1] = upper_32_bits(dma);
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	sgce = (struct sgce *)(sgcl_data + 1);
-
-	/* oper_len can also get from gcl_data_stat bit 5,6 OR sgi_config->oacl_len */
-	oper_len = ((sgcl_query->oacl_len & 0x0c) >> 2) + 1;
-
-	/* Get Stream Gate Control List */
-	status->oper.cycle_time = le32_to_cpu(sgcl_data->oct);
-	status->oper.cycle_time_extension = le32_to_cpu(sgcl_data->octe);
-	status->oper.base_time = le32_to_cpu(sgcl_data->obtl) + ((u64)le32_to_cpu(sgcl_data->obth) << 32);
-	status->oper.control_list_length = oper_len;
-
-	gcl_data_stat = le16_to_cpu(sgcl_data->stat);
-	if (gcl_data_stat & 0x400)
-		status->oper.init_ipv = gcl_data_stat & 0x38 >> 7;
-	else
-		status->oper.init_ipv = -1;
-
-	if (gcl_data_stat & 0x800)
-		status->oper.gate_states = true;
-
-	status->oper.gcl =
-		kzalloc(oper_len * sizeof(struct tsn_qci_psfp_gcl), GFP_KERNEL);
-	if (status->oper.gcl == NULL) {
-		memset(cbdr_sgi, 0, sizeof(*cbdr_sgi));
-		memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-		kfree(sgcl_data);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < oper_len; i++) {
-		struct tsn_qci_psfp_gcl *temp_sgcl = status->oper.gcl + i;
-		struct sgce *temp_entry = (struct sgce *)(sgce + i);
-
-		if (temp_entry->multi & 0x10)
-			temp_sgcl->gate_state = true;
-
-		if (temp_entry->multi & 0x08)
-			temp_sgcl->ipv = temp_entry->multi >> 5;
-		else
-			temp_sgcl->ipv = -1;
-
-		temp_sgcl->time_interval = le32_to_cpu(temp_entry->interval);
-
-		if (temp_entry->multi & 0x01)
-			temp_sgcl->octet_max = temp_entry->msdu[0]
-					| ((((u32)temp_entry->msdu[1]) << 8) & 0xff00)
-					| ((((u32)temp_entry->msdu[2]) << 16) & 0xff0000);
-		else
-			temp_sgcl->octet_max = 0;
-	}
-
-	status->config_change_time = le32_to_cpu(sgcl_data->cctl) + ((u64)le32_to_cpu(sgcl_data->ccth) << 32);
-
-	memset(cbdr_sgcl, 0, sizeof(*cbdr_sgcl));
-	kfree(sgcl_data);
-
-cmd2quit:
-	/* changed to SITGTGR */
-	status->tick_granularity = enetc_rd(&priv->si->hw, ENETC_SITGTGR);
-
-	/* current time */
-	temp = ((u64)enetc_rd(&priv->si->hw, ENETC_SICTR1)) << 32;
-	status->current_time = enetc_rd(&priv->si->hw, ENETC_SICTR0) + temp;
-
-	memset(cbdr_sgi, 0, sizeof(*cbdr_sgi));
-
-	return 0;
-}
-
-/* CBD Class 10: Flow Meter Instance Set Descriptor - Short Format */
-int enetc_qci_fmi_set(struct net_device *ndev, u32 index, bool enable,
-				struct tsn_qci_psfp_fmi *tsn_qci_fmi)
-{
-	struct enetc_cbd *cbdr;
-	struct fmi_conf *fmi_config;
-
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int curr_cbd;
-	u64 temp = 0;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16((u16)index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_FLOW_METER;
-	cbdr->status_flags = 0x80;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	if (!enable) {
-		memset(cbdr, 0, sizeof(*cbdr));
-		return 0;
-	}
-
-	/* Re-enable */
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-	memset(cbdr, 0, sizeof(*cbdr));
-	cbdr->index = cpu_to_le16((u16)index);
-	cbdr->cmd = 0;
-	cbdr->cls = BDCR_CMD_FLOW_METER;
-	cbdr->status_flags = 0x80;
-
-	fmi_config = &cbdr->fmi_conf;
-	fmi_config->en = 0x80;
-	if (tsn_qci_fmi->cir) {
-		temp = (u64)1000 * tsn_qci_fmi->cir;
-		temp = temp / 3725;
-	}
-	fmi_config->cir = cpu_to_le32((u32)temp);
-	fmi_config->cbs = cpu_to_le32(tsn_qci_fmi->cbs);
-	temp = 0;
-	if (tsn_qci_fmi->eir) {
-		temp = (u64)1000 * tsn_qci_fmi->eir;
-		temp = temp / 3725;
-	}
-	fmi_config->eir = cpu_to_le32((u32)temp);
-	fmi_config->ebs = cpu_to_le32(tsn_qci_fmi->ebs);
-
-	if (tsn_qci_fmi->mark_red)
-		fmi_config->conf |= 0x1;
-
-	if (tsn_qci_fmi->mark_red_enable)
-		fmi_config->conf |= 0x2;
-
-	if (tsn_qci_fmi->drop_on_yellow)
-		fmi_config->conf |= 0x4;
-
-	if (tsn_qci_fmi->cm)
-		fmi_config->conf |= 0x8;
-
-	if (tsn_qci_fmi->cf)
-		fmi_config->conf |= 0x10;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memset(cbdr, 0, sizeof(*cbdr));
-	return 0;
-}
-
-/* CBD Class 10: Flow Meter Instance Query Descriptor - Short Format */
-int enetc_qci_fmi_get(struct net_device *ndev, u32 index,
-						struct tsn_qci_psfp_fmi *tsn_qci_fmi,
-						struct tsn_qci_psfp_fmi_counters *counters)
-{
-	struct enetc_cbd *cbdr;
-	struct fmi_conf *fmi_config;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	int curr_cbd;
-	u16 data_size, dma_size;
-	dma_addr_t dma;
-	struct fmi_query_stat_resp *fmi_counter_data;
-	u64 temp = 0;
-
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 1;
-	cbdr->cls = BDCR_CMD_FLOW_METER;
-	cbdr->status_flags = 0x80;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	fmi_config = &cbdr->fmi_conf;
-	if (fmi_config->cir) {
-		temp = (u64)3725 * fmi_config->cir;
-		temp = temp / 1000;
-	}
-	tsn_qci_fmi->cir = le32_to_cpu((u32)temp);
-	tsn_qci_fmi->cbs = le32_to_cpu(fmi_config->cbs);
-	temp = 0;
-	if (fmi_config->eir) {
-		temp = (u64)3725 * fmi_config->eir;
-		temp = temp / 1000;
-	}
-	tsn_qci_fmi->eir = le32_to_cpu((u32)temp);
-	tsn_qci_fmi->ebs = le32_to_cpu(fmi_config->ebs);
-
-	if (fmi_config->conf & 0x1)
-		tsn_qci_fmi->mark_red = true;
-
-	if (fmi_config->conf & 0x2)
-		tsn_qci_fmi->mark_red_enable = true;
-
-	if (fmi_config->conf & 0x4)
-		tsn_qci_fmi->drop_on_yellow = true;
-
-	if (fmi_config->conf & 0x8)
-		tsn_qci_fmi->cm = true;
-
-	if (fmi_config->conf & 0x10)
-		tsn_qci_fmi->cf = true;
-
-	memset(cbdr, 0, sizeof(*cbdr));
-
-	/* Get counters */
-	curr_cbd = alloc_cbdr(priv->si, &cbdr);
-
-	cbdr->index = cpu_to_le16(index);
-	cbdr->cmd = 2;
-	cbdr->cls = BDCR_CMD_FLOW_METER;
-	cbdr->status_flags = 0x0;
-
-	data_size = sizeof(struct fmi_query_stat_resp);
-	fmi_counter_data = (struct fmi_query_stat_resp *)kzalloc(data_size, __GFP_DMA | GFP_KERNEL);
-	if (fmi_counter_data == NULL)
-		return -ENOMEM;
-
-	dma = dma_map_single(&priv->si->pdev->dev, fmi_counter_data, data_size, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&priv->si->pdev->dev, dma)) {
-		netdev_err(priv->si->ndev, "DMA mapping failed!\n");
-		kfree(fmi_counter_data);
-		return -ENOMEM;
-	}
-	cbdr->addr[0] = lower_32_bits(dma);
-	cbdr->addr[1] = upper_32_bits(dma);
-
-	dma_size = cpu_to_le16(data_size);
-	cbdr->length = dma_size;
-
-	xmit_cbdr(priv->si, curr_cbd);
-
-	memcpy(counters, fmi_counter_data, sizeof(*counters));
-
-	return 0;
-}
-
-int enetc_qbu_set(struct net_device *ndev, u8 ptvector)
-{
-	u32 temp;
-	int i;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	temp = enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET);
-	if (temp & QBV_TGE)
-		enetc_wr(&priv->si->hw, QBV_PTGCR_OFFSET, temp & (~QBV_TGPE));
-
-	for (i = 0; i < 8; i++) {
-		/* 1 Enabled. Traffic is transmitted on the preemptive MAC. */
-		temp = enetc_port_rd(&priv->si->hw, ENETC_PTCFPR(i));
-
-		if ((ptvector >> i) & 0x1)
-			enetc_port_wr(&priv->si->hw, ENETC_PTCFPR(i), temp | ENETC_FPE);
-		else
-			enetc_port_wr(&priv->si->hw, ENETC_PTCFPR(i), temp & ~ENETC_FPE);
-	}
-
-	return 0;
-}
-
-int enetc_qbu_get(struct net_device *ndev,
-		  struct tsn_preempt_status *preemptstat)
-{
-	int i;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	if (enetc_port_rd(&priv->si->hw, ENETC_PFPMR) & ENETC_PFPMR_PMACE) {
-		preemptstat->preemption_active = true;
-		if (enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET) & QBV_TGE)
-			preemptstat->hold_request = 1;
-		else
-			preemptstat->hold_request = 2;
-	} else {
-		preemptstat->preemption_active = false;
-		return 0;
-	}
-
-	for (i = 0; i < 8; i++)
-		if (enetc_port_rd(&priv->si->hw, ENETC_PTCFPR(i)) & 0x80000000)
-			preemptstat->admin_state |= 1 << i;
-
-	preemptstat->hold_advance =
-		enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET) & 0xFFFF;
-	preemptstat->release_advance =
-		enetc_rd(&priv->si->hw, QBV_PTGCR_OFFSET) & 0xFFFF;
-
-	return 0;
-}
-
-u32 __enetc_tsn_get_cap(struct enetc_si *si)
-{
-	u32 reg = 0;
-	u32 cap = 0;
-
-	reg = enetc_port_rd(&si->hw, ENETC_PCAPR0);
-
-	if (reg & ENETC_PCAPR0_PSFP)
-		cap |= TSN_CAP_QCI;
-
-	if (reg & ENETC_PCAPR0_TSN)
-		cap |= TSN_CAP_QBV;
-
-	if (reg & ENETC_PCAPR0_QBU)
-		cap |= TSN_CAP_QBU;
-
-	cap |= TSN_CAP_CBS;
-	cap |= TSN_CAP_TBS;
-
-	return cap;
-}
-
-u32 enetc_tsn_get_capability(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	return __enetc_tsn_get_cap(priv->si);
-}
-
-static int enetc_set_cbs(struct net_device *ndev, u8 tc, u8 bw)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_si *si = priv->si;
-	struct enetc_cbs *ecbs = si->ecbs;
-	struct cbs *cbs;
-
-	int bw_sum = 0;
-	u32 port_transmit_rate;
-	u32 port_frame_max_size;
-	u8 tc_nums;
-	int i;
-
-	u32 max_interfrence_size;
-	u32 send_slope;
-	u32 hi_credit;
-
-	if (!ecbs)
-		return -ENOMEM;
-
-	port_transmit_rate = ecbs->port_transmit_rate;
-	port_frame_max_size = ecbs->port_max_size_frame;
-	tc_nums = ecbs->tc_nums;
-	cbs = ecbs->cbs;
-
-	if (tc >= tc_nums) {
-		dev_err(&ndev->dev, "Make sure the TC less than %d\n", tc_nums);
-		return -EINVAL;
-	}
-
-	if (!bw) {
-		if (cbs[tc].enable) {
-			/* Make sure the other TC that are numerically
-			 * lower than this TC have been disabled.
-			 */
-			for (i = 0; i < tc; i++) {
-				if (cbs[i].enable)
-					break;
-			}
-			if (i < tc) {
-				dev_err(&ndev->dev,
-					"TC%d has been disabled first\n", i);
-				return -EINVAL;
-			}
-			memset(&cbs[tc], 0, sizeof(*cbs));
-			cbs[tc].enable = false;
-			enetc_port_wr(&si->hw, ENETC_PTCCBSR1(tc), 0);
-			enetc_port_wr(&si->hw, ENETC_PTCCBSR0(tc), 0);
-		}
-		return 0;
-	}
-
-	/* Make sure the other TC that are numerically
-	 * higher than this TC have been enabled.
-	 */
-	for (i = tc_nums - 1; i > tc; i--) {
-		if (!cbs[i].enable) {
-			dev_err(&ndev->dev,
-				"TC%d has been enabled first\n", i);
-			return -EINVAL;
-		}
-		bw_sum += cbs[i].bw;
-	}
-
-	if (bw_sum + bw >= 100) {
-		dev_err(&ndev->dev,
-			"The sum of all CBS Bandwidth cann't exceed 100\n");
-		return -EINVAL;
-	}
-
-	cbs[tc].bw = bw;
-	cbs[tc].tc_max_sized_frame = enetc_port_rd(&si->hw, ENETC_PTCMSDUR(tc));
-	cbs[tc].idle_slope = port_transmit_rate / 100 * bw;
-	cbs[tc].send_slope = port_transmit_rate - cbs[tc].idle_slope;
-
-	/* For TC7, the max_interfrence_size is ENETC_MAC_MAXFRM_SIZE.
-	 * For TC6, the max_interfrence_size is calculated as below:
-	 *
-	 *      max_interfrence_size = (M0 + Ma + Ra * M0 / (R0 - Ra))
-	 *
-	 * For other traffic class, for example SR class Q:
-	 *
-	 *                            R0 * (M0 + Ma + ... + Mp)
-	 *      max_interfrence_size =  ------------------------------
-	 *                            (R0 - Ra) + ... + (R0 - Rp)
-	 *
-	 */
-
-	if (tc == tc_nums - 1) {
-		cbs[tc].max_interfrence_size = port_frame_max_size * 8;
-
-	} else if (tc == tc_nums - 2) {
-		cbs[tc].max_interfrence_size = (port_frame_max_size
-				+ cbs[tc + 1].tc_max_sized_frame
-				+ port_frame_max_size * (cbs[tc + 1].idle_slope
-				/ cbs[tc + 1].send_slope)) * 8;
-	} else {
-		max_interfrence_size = port_frame_max_size;
-		send_slope = 0;
-		for (i = tc + 1; i < tc_nums; i++) {
-			send_slope += cbs[i].send_slope;
-			max_interfrence_size += cbs[i].tc_max_sized_frame;
-		}
-		max_interfrence_size = ((u64)port_transmit_rate
-				* max_interfrence_size) / send_slope;
-		cbs[tc].max_interfrence_size = max_interfrence_size * 8;
-	}
-
-	cbs[tc].hi_credit = cbs[tc].max_interfrence_size * cbs[tc].bw / 100;
-	cbs[tc].lo_credit = cbs[tc].tc_max_sized_frame * (cbs[tc].send_slope
-			/ port_transmit_rate);
-	cbs[tc].tc = tc;
-
-	hi_credit = (ENETC_CLK * 100L) * (u64)cbs[tc].hi_credit
-			/ port_transmit_rate;
-	enetc_port_wr(&si->hw, ENETC_PTCCBSR1(tc), hi_credit);
-
-	/* Set bw register and enable this traffic class*/
-	enetc_port_wr(&si->hw, ENETC_PTCCBSR0(tc),
-		      (cbs[tc].bw & 0x7F) | (1 << 31));
-	cbs[tc].enable = true;
-
-	return 0;
-}
-
-static int enetc_get_cbs(struct net_device *ndev, u8 tc)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_si *si = priv->si;
-	struct enetc_cbs *ecbs = si->ecbs;
-	struct cbs *cbs;
-
-	if (!ecbs)
-		return -ENOMEM;
-	cbs = ecbs->cbs;
-	if (tc >= ecbs->tc_nums) {
-		dev_err(&ndev->dev, "The maximum of TC is %d\n", ecbs->tc_nums);
-		return -EINVAL;
-	}
-
-	return cbs[tc].bw;
-}
-
-#define GET_CURRENT_TIME(si) (enetc_rd(&(si)->hw, ENETC_SICTR0) \
-		| ((u64)enetc_rd(&(si)->hw, ENETC_SICTR1) << 32))
-
-static int enetc_set_tsd(struct net_device *ndev, struct tsn_tsd *ttsd)
-{
-	return 0;
-}
-
-static int enetc_get_tsd(struct net_device *ndev, struct tsn_tsd_status *tts)
-{
-	return 0;
-}
-
-static u32 get_ndev_speed(struct net_device *netdev)
-{
-	struct ethtool_link_ksettings ksettings;
-	int rc = -1;
-	if (netdev->ethtool_ops->get_link_ksettings) {
-
-		if (netdev->ethtool_ops->begin) {
-			if ((rc = netdev->ethtool_ops->begin(netdev) < 0))
-				return 0;
-		}
-
-		memset(&ksettings, 0, sizeof(ksettings));
-
-		if (!netdev->ethtool_ops->get_link_ksettings)
-			return 0;
-
-		rc = netdev->ethtool_ops->get_link_ksettings(netdev, &ksettings);
-
-		if (netdev->ethtool_ops->complete)
-			netdev->ethtool_ops->complete(netdev);
-	}
-	return (rc < 0) ? 0 : ksettings.base.speed;
-}
-
-static void enetc_cbs_init(struct enetc_si *si)
-{
-	u8 tc_nums;
-
-	tc_nums = ((enetc_port_rd(&si->hw, ENETC_PCAPR1) >> 4) & 0x7) + 1;
-	si->ecbs = kzalloc(sizeof(*si->ecbs) +
-			   sizeof(struct cbs) * tc_nums, GFP_KERNEL);
-	if (!si->ecbs)
-		return;
-
-	si->ecbs->port_max_size_frame = si->ndev->mtu + ETH_HLEN
-						+ VLAN_HLEN + ETH_FCS_LEN;
-	si->ecbs->tc_nums = tc_nums;
-	si->ecbs->port_transmit_rate = get_ndev_speed(si->ndev);
-
-	/*This trick is used only for CFP*/
-	if (!si->ecbs->port_transmit_rate)
-		si->ecbs->port_transmit_rate = 1000000000;
-
-	if (!si->ecbs->port_transmit_rate) {
-		dev_err(&si->pdev->dev, "Failure to get port speed for CBS\n");
-		kfree(si->ecbs);
-		si->ecbs = NULL;
-	}
-
-	return;
-}
-
-static void enetc_qbv_init(struct enetc_hw *hw)
-{
-	/* Set PSPEED to be 1Gbps */
-	enetc_port_wr(hw, ENETC_PMR, (enetc_port_rd(hw, ENETC_PMR) & (~0xf00)) | 0x200);
-}
-
-void enetc_tsn_init(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_si *si = priv->si;
-	u32 capability = 0;
-
-	capability = __enetc_tsn_get_cap(si);
-
-	if (capability & TSN_CAP_CBS)
-		enetc_cbs_init(si);
-
-	if (capability & TSN_CAP_QBV)
-		enetc_qbv_init(&si->hw);
-
-	if (capability & TSN_CAP_QCI)
-		enetc_qci_enable(&si->hw);
-
-	dev_info(&si->pdev->dev, "%s: setup done\n", __func__);
-}
-
-void enetc_tsn_deinit(struct net_device *ndev)
-{
-	return;
-}
-
-static struct tsn_ops enetc_tsn_ops_full = {
-	.device_init = enetc_tsn_init,
-	.device_deinit = enetc_tsn_deinit,
-	.get_capability = enetc_tsn_get_capability,
-	.qbv_set = enetc_qbv_set,
-	.qbv_get = enetc_qbv_get,
-	.qbv_get_status = enetc_qbv_get_status,
-	.cb_streamid_set = enetc_cb_streamid_set,
-	.cb_streamid_get = enetc_cb_streamid_get,
-	.cb_streamid_counters_get = enetc_cb_streamid_counters_get,
-	.qci_sfi_set = enetc_qci_sfi_set,
-	.qci_sfi_get = enetc_qci_sfi_get,
-	.qci_sfi_counters_get = enetc_qci_sfi_counters_get,
-	.qci_sgi_set = enetc_qci_sgi_set,
-	.qci_sgi_get = enetc_qci_sgi_get,
-	.qci_sgi_status_get = enetc_qci_sgi_status_get,
-	.qci_fmi_set = enetc_qci_fmi_set,
-	.qci_fmi_get = enetc_qci_fmi_get,
-	.qbu_set = enetc_qbu_set,
-	.qbu_get = enetc_qbu_get,
-	.cbs_set = enetc_set_cbs,
-	.cbs_get = enetc_get_cbs,
-	.tsd_set = enetc_set_tsd,
-	.tsd_get = enetc_get_tsd,
-};
-
-static struct tsn_ops enetc_tsn_ops_part = {
-	.device_init = enetc_tsn_init,
-	.device_deinit = enetc_tsn_deinit,
-	.get_capability = enetc_tsn_get_capability,
-	.cb_streamid_set = enetc_cb_streamid_set,
-	.cb_streamid_get = enetc_cb_streamid_get,
-	.cb_streamid_counters_get = enetc_cb_streamid_counters_get,
-	.qci_sfi_set = enetc_qci_sfi_set,
-	.qci_sfi_get = enetc_qci_sfi_get,
-	.qci_sfi_counters_get = enetc_qci_sfi_counters_get,
-	.qci_sgi_set = enetc_qci_sgi_set,
-	.qci_sgi_get = enetc_qci_sgi_get,
-	.qci_sgi_status_get = enetc_qci_sgi_status_get,
-	.qci_fmi_set = enetc_qci_fmi_set,
-	.qci_fmi_get = enetc_qci_fmi_get,
-};
-
-void enetc_tsn_pf_init(struct net_device *netdev, struct pci_dev *pdev)
-{
-	int port = pdev->devfn & 0x7;
-	if (port == 1 || port == 3)
-		tsn_port_register(netdev, &enetc_tsn_ops_part, (u16)pdev->bus->number);
-	else
-		tsn_port_register(netdev, &enetc_tsn_ops_full, (u16)pdev->bus->number);
-}
-
-void enetc_tsn_pf_deinit(struct net_device *netdev)
-{
-	tsn_port_unregister(netdev);
-}
-#endif	/* #if IS_ENABLED(CONFIG_ENETC_TSN) */
diff --git a/drivers/net/ethernet/freescale/enetc/enetc_vf.c b/drivers/net/ethernet/freescale/enetc/enetc_vf.c
deleted file mode 100644
index f63501c92477..000000000000
--- a/drivers/net/ethernet/freescale/enetc/enetc_vf.c
+++ /dev/null
@@ -1,256 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include <linux/module.h>
-#include "enetc.h"
-
-#define ENETC_DRV_VER_MAJ 0
-#define ENETC_DRV_VER_MIN 9
-
-#define ENETC_DRV_VER_STR __stringify(ENETC_DRV_VER_MAJ) "." \
-			  __stringify(ENETC_DRV_VER_MIN)
-static const char enetc_drv_ver[] = ENETC_DRV_VER_STR;
-#define ENETC_DRV_NAME_STR "ENETC VF driver"
-static const char enetc_drv_name[] = ENETC_DRV_NAME_STR;
-
-/* Messaging */
-static void enetc_msg_vsi_write_msg(struct enetc_hw *hw,
-				    struct enetc_msg_swbd *msg)
-{
-	u32 val;
-
-	val = enetc_vsi_set_msize(msg->size) | lower_32_bits(msg->dma);
-	enetc_wr(hw, ENETC_VSIMSGSNDAR1, upper_32_bits(msg->dma));
-	enetc_wr(hw, ENETC_VSIMSGSNDAR0, val);
-}
-
-static int enetc_msg_vsi_send(struct enetc_si *si, struct enetc_msg_swbd *msg)
-{
-	int timeout = 100;
-	u32 vsimsgsr;
-
-	enetc_msg_vsi_write_msg(&si->hw, msg);
-
-	do {
-		vsimsgsr = enetc_rd(&si->hw, ENETC_VSIMSGSR);
-		if (!(vsimsgsr & ENETC_VSIMSGSR_MB))
-			break;
-
-		usleep_range(1000, 2000);
-	} while (--timeout);
-
-	if (!timeout)
-		return -ETIMEDOUT;
-
-	/* check for message delivery error */
-	if (vsimsgsr & ENETC_VSIMSGSR_MS) {
-		dev_err(&si->pdev->dev, "VSI command execute error: %d\n",
-			ENETC_SIMSGSR_GET_MC(vsimsgsr));
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static int enetc_msg_vsi_set_primary_mac_addr(struct enetc_ndev_priv *priv,
-					      struct sockaddr *saddr)
-{
-	struct enetc_msg_cmd_set_primary_mac *cmd;
-	struct enetc_msg_swbd msg;
-	int err;
-
-	msg.size = ALIGN(sizeof(struct enetc_msg_cmd_set_primary_mac), 64);
-	msg.vaddr = dma_zalloc_coherent(priv->dev, msg.size, &msg.dma,
-					GFP_KERNEL);
-	if (!msg.vaddr) {
-		dev_err(priv->dev, "Failed to alloc Tx msg (size: %d)\n",
-			msg.size);
-		return -ENOMEM;
-	}
-
-	cmd = (struct enetc_msg_cmd_set_primary_mac *)msg.vaddr;
-	cmd->header.type = ENETC_MSG_CMD_MNG_MAC;
-	cmd->header.id = ENETC_MSG_CMD_MNG_ADD;
-	memcpy(&cmd->mac, saddr, sizeof(struct sockaddr));
-
-	/* send the command and wait */
-	err = enetc_msg_vsi_send(priv->si, &msg);
-
-	dma_free_coherent(priv->dev, msg.size, msg.vaddr, msg.dma);
-
-	return err;
-}
-
-static int enetc_vf_set_mac_addr(struct net_device *ndev, void *addr)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct sockaddr *saddr = addr;
-	int err;
-
-	if (!is_valid_ether_addr(saddr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	err = enetc_msg_vsi_set_primary_mac_addr(priv, saddr);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-static int enetc_vf_set_features(struct net_device *ndev,
-				 netdev_features_t features)
-{
-	return enetc_set_features(ndev, features);
-}
-
-/* Probing/ Init */
-static const struct net_device_ops enetc_ndev_ops = {
-	.ndo_open		= enetc_open,
-	.ndo_stop		= enetc_close,
-	.ndo_start_xmit		= enetc_xmit,
-	.ndo_get_stats		= enetc_get_stats,
-	.ndo_set_mac_address	= enetc_vf_set_mac_addr,
-	.ndo_set_features	= enetc_vf_set_features,
-	.ndo_do_ioctl		= enetc_ioctl,
-};
-
-static void enetc_vf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
-				  const struct net_device_ops *ndev_ops)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	SET_NETDEV_DEV(ndev, &si->pdev->dev);
-	priv->ndev = ndev;
-	priv->si = si;
-	priv->dev = &si->pdev->dev;
-	si->ndev = ndev;
-
-	priv->msg_enable = (NETIF_MSG_IFUP << 1) - 1;
-	ndev->netdev_ops = ndev_ops;
-	enetc_set_ethtool_ops(ndev);
-	ndev->watchdog_timeo = 5 * HZ;
-	ndev->max_mtu = ENETC_MAX_MTU;
-
-	ndev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM | NETIF_F_HW_CSUM |
-			    NETIF_F_HW_VLAN_CTAG_TX |
-			    NETIF_F_HW_VLAN_CTAG_RX;
-	ndev->features = NETIF_F_HIGHDMA | NETIF_F_SG |
-			 NETIF_F_RXCSUM | NETIF_F_HW_CSUM |
-			 NETIF_F_HW_VLAN_CTAG_TX |
-			 NETIF_F_HW_VLAN_CTAG_RX;
-
-	if (si->num_rss)
-		ndev->hw_features |= NETIF_F_RXHASH;
-
-	if (si->errata & ENETC_ERR_TXCSUM) {
-		ndev->hw_features &= ~NETIF_F_HW_CSUM;
-		ndev->features &= ~NETIF_F_HW_CSUM;
-	}
-
-	/* pick up primary MAC address from SI */
-	enetc_get_primary_mac_addr(&si->hw, ndev->dev_addr);
-}
-
-static int enetc_vf_probe(struct pci_dev *pdev,
-			  const struct pci_device_id *ent)
-{
-	struct enetc_ndev_priv *priv;
-	struct net_device *ndev;
-	struct enetc_si *si;
-	int err;
-
-	err = enetc_pci_probe(pdev, KBUILD_MODNAME, 0);
-	if (err) {
-		dev_err(&pdev->dev, "PCI probing failed\n");
-		return err;
-	}
-
-	si = pci_get_drvdata(pdev);
-
-	enetc_get_si_caps(si);
-
-	ndev = alloc_etherdev_mq(sizeof(*priv), ENETC_MAX_NUM_TXQS);
-	if (!ndev) {
-		err = -ENOMEM;
-		dev_err(&pdev->dev, "netdev creation failed\n");
-		goto err_alloc_netdev;
-	}
-
-	enetc_vf_netdev_setup(si, ndev, &enetc_ndev_ops);
-
-	priv = netdev_priv(ndev);
-
-	enetc_init_si_rings_params(priv);
-
-	err = enetc_alloc_si_resources(priv);
-	if (err) {
-		dev_err(&pdev->dev, "SI resource alloc failed\n");
-		goto err_alloc_si_res;
-	}
-
-	err = enetc_alloc_msix(priv);
-	if (err) {
-		dev_err(&pdev->dev, "MSIX alloc failed\n");
-		goto err_alloc_msix;
-	}
-
-	err = register_netdev(ndev);
-	if (err)
-		goto err_reg_netdev;
-
-	netif_carrier_off(ndev);
-
-	netif_info(priv, probe, ndev, "%s v%s\n",
-		   enetc_drv_name, enetc_drv_ver);
-
-	return 0;
-
-err_reg_netdev:
-	enetc_free_msix(priv);
-err_alloc_msix:
-	enetc_free_si_resources(priv);
-err_alloc_si_res:
-	si->ndev = NULL;
-	free_netdev(ndev);
-err_alloc_netdev:
-	enetc_pci_remove(pdev);
-
-	return err;
-}
-
-static void enetc_vf_remove(struct pci_dev *pdev)
-{
-	struct enetc_si *si = pci_get_drvdata(pdev);
-	struct enetc_ndev_priv *priv;
-
-	priv = netdev_priv(si->ndev);
-	netif_info(priv, drv, si->ndev, "%s v%s remove\n",
-		   enetc_drv_name, enetc_drv_ver);
-	unregister_netdev(si->ndev);
-
-	enetc_free_msix(priv);
-
-	enetc_free_si_resources(priv);
-
-	free_netdev(si->ndev);
-
-	enetc_pci_remove(pdev);
-}
-
-static const struct pci_device_id enetc_vf_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_VF) },
-	{ 0, } /* End of table. */
-};
-MODULE_DEVICE_TABLE(pci, enetc_vf_id_table);
-
-static struct pci_driver enetc_vf_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = enetc_vf_id_table,
-	.probe = enetc_vf_probe,
-	.remove = enetc_vf_remove,
-};
-module_pci_driver(enetc_vf_driver);
-
-MODULE_DESCRIPTION(ENETC_DRV_NAME_STR);
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_VERSION(ENETC_DRV_VER_STR);
diff --git a/drivers/net/ethernet/freescale/enetc_mdio.c b/drivers/net/ethernet/freescale/enetc_mdio.c
deleted file mode 100644
index b12ec9cb2902..000000000000
--- a/drivers/net/ethernet/freescale/enetc_mdio.c
+++ /dev/null
@@ -1,70 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2019 NXP */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include "xgmac_mdio.h"
-
-#define ENETC_MDIO_DEV_ID	0xee01
-#define ENETC_DRV_NAME_STR "ENETC MDIO driver"
-
-static int enetc_pci_mdio_probe(struct pci_dev *pdev,
-				const struct pci_device_id *ent)
-{
-	const struct xgmac_mdio_cfg cfg = {
-		.bus_name = "Freescale PCI ENETC-RCIE MDIO Bus",
-		.regs_offset = 0x1C00,
-	};
-	int err;
-
-	err = pci_enable_device_mem(pdev);
-	if (err) {
-		dev_err(&pdev->dev, "device enable failed\n");
-		return err;
-	}
-
-	err = pci_request_mem_regions(pdev, KBUILD_MODNAME);
-	if (err) {
-		dev_err(&pdev->dev, "pci_request_regions failed err=%d\n", err);
-		goto err_pci_mem_reg;
-	}
-
-	pci_set_master(pdev);
-
-	err = xgmac_mdio_probe(&pdev->dev, &pdev->resource[0], &cfg);
-	if (err)
-		goto err_xgmac_probe;
-
-	return 0;
-
-err_xgmac_probe:
-	pci_release_mem_regions(pdev);
-err_pci_mem_reg:
-	pci_disable_device(pdev);
-
-	return err;
-}
-
-static void enetc_pci_mdio_remove(struct pci_dev *pdev)
-{
-	xgmac_mdio_remove(dev_get_drvdata(&pdev->dev));
-	pci_release_mem_regions(pdev);
-	pci_disable_device(pdev);
-}
-
-static const struct pci_device_id enetc_pci_mdio_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_MDIO_DEV_ID) },
-	{ 0, } /* End of table. */
-};
-MODULE_DEVICE_TABLE(pci, enetc_mdio_id_table);
-
-static struct pci_driver enetc_pci_mdio_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = enetc_pci_mdio_id_table,
-	.probe = enetc_pci_mdio_probe,
-	.remove = enetc_pci_mdio_remove,
-};
-module_pci_driver(enetc_pci_mdio_driver);
-
-MODULE_DESCRIPTION(ENETC_DRV_NAME_STR);
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/ethernet/mscc/felix_board.c b/drivers/net/ethernet/mscc/felix_board.c
deleted file mode 100644
index 288d9bc1ff12..000000000000
--- a/drivers/net/ethernet/mscc/felix_board.c
+++ /dev/null
@@ -1,907 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Felix Switch driver
- *
- * Copyright 2018-2019 NXP
- */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/netdevice.h>
-#include <linux/phy_fixed.h>
-#include <linux/phy.h>
-#include <linux/of_mdio.h>
-#include <linux/of_net.h>
-#include <net/sock.h>
-
-#include "ocelot.h"
-#include "felix_tsn.h"
-
-static const char felix_driver_string[] = "Felix Switch Driver";
-#define DRV_VERSION "0.3"
-static const char felix_driver_version[] = DRV_VERSION;
-
-#define FELIX_MAX_NUM_PHY_PORTS	6
-#define PORT_RES_START		(GCB + 1)
-
-#define PCI_DEVICE_ID_FELIX_PF5	0xEEF0
-
-/* Switch register block BAR */
-#define FELIX_SWITCH_BAR	4
-
-#define FELIX_INIT_TIMEOUT	50000
-
-static struct pci_device_id felix_ids[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FELIX_PF5) },
-	{ 0, }
-};
-MODULE_DEVICE_TABLE(pci, felix_ids);
-
-#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
-const struct tsn_ops switch_tsn_ops = {
-	.device_init                    = felix_tsn_init,
-	.qbv_set			= felix_qbv_set,
-	.qbv_get			= felix_qbv_get,
-	.qbv_get_status			= felix_qbv_get_status,
-	.qbu_set			= felix_qbu_set,
-	.qbu_get                        = felix_qbu_get,
-	.cb_streamid_set		= felix_cb_streamid_set,
-	.cb_streamid_get		= felix_cb_streamid_get,
-	.qci_sfi_set			= felix_qci_sfi_set,
-	.qci_sfi_get			= felix_qci_sfi_get,
-	.qci_sfi_counters_get		= felix_qci_sfi_counters_get,
-	.qci_sgi_set			= felix_qci_sgi_set,
-	.qci_sgi_get			= felix_qci_sgi_get,
-	.qci_sgi_status_get		= felix_qci_sgi_status_get,
-	.qci_fmi_set			= felix_qci_fmi_set,
-	.qci_fmi_get			= felix_qci_fmi_get,
-	.cbs_set			= felix_cbs_set,
-	.ct_set				= felix_cut_thru_set,
-	.cbgen_set			= felix_seq_gen_set,
-	.cbrec_set			= felix_seq_rec_set,
-	.cb_get				= felix_cb_get,
-	.pcpmap_set			= felix_pcp_map_set,
-	.dscp_set			= felix_dscp_set,
-};
-#endif
-
-/* Mimic the order of ocelot_target */
-static struct resource felix_switch_res[] = {
-	{
-		/* Nothing here */
-	},
-	{
-		.start = 0x0280000,
-		.end = 0x028ffff,
-		.name = "ana",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0090000,
-		.end = 0x00900ff,
-		.name = "ptp",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0080000,
-		.end = 0x00800ff,
-		.name = "qs",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0200000,
-		.end = 0x021ffff,
-		.name = "qsys",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0030000,
-		.end = 0x003ffff,
-		.name = "rew",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0010000,
-		.end = 0x001ffff,
-		.name = "sys",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0070000,
-		.end = 0x00701ff,
-		.name = "devcpu_gcb",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0100000,
-		.end = 0x010ffff,
-		.name = "port0",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0110000,
-		.end = 0x011ffff,
-		.name = "port1",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0120000,
-		.end = 0x012ffff,
-		.name = "port2",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0130000,
-		.end = 0x013ffff,
-		.name = "port3",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0140000,
-		.end = 0x014ffff,
-		.name = "port4",
-		.flags = IORESOURCE_MEM,
-	},
-	{
-		.start = 0x0150000,
-		.end = 0x015ffff,
-		.name = "port5",
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static void __iomem *regs;
-
-int felix_chip_init(struct ocelot *ocelot);
-
-/* Felix header bytes length */
-#define FELIX_XFH_LEN 16
-#define FELIX_MAX_MTU (VLAN_ETH_FRAME_LEN - XFH_LONG_PREFIX_LEN - VLAN_ETH_HLEN)
-
-static inline void felix_set_xfh_field(u64 *efh, u8 nth_bit, u8 w, u16 v)
-{
-	u8 i = (8 * FELIX_XFH_LEN - nth_bit) >> 6; /* MSB0 dword index */
-	u8 bit = nth_bit & GENMASK(5, 0); /* modulo: field start bit index */
-	u64 val = v & GENMASK(w - 1, 0);
-
-	efh[i] |= cpu_to_be64(val << bit);
-}
-
-static inline u32 felix_get_xfh_field(u64 *efh, u8 nth_bit, u8 w)
-{
-	u8 i = (8 * FELIX_XFH_LEN - nth_bit) >> 6; /* MSB0 dword index */
-	u8 bit = nth_bit & GENMASK(5, 0); /* modulo: field start bit index */
-
-	return (be64_to_cpu(efh[i]) >> bit) & GENMASK(w - 1, 0);
-}
-
-#define FELIX_IFH_FIELD(name, bit, w) \
-static inline void felix_set_ifh_##name(u64 *ifh, u16 v) \
-{ \
-	felix_set_xfh_field(ifh, bit, w, v); \
-}
-
-#define FELIX_EFH_FIELD(name, bit, w) \
-static inline u32 felix_get_efh_##name(u64 *efh) \
-{ \
-	return felix_get_xfh_field(efh, bit, w); \
-}
-
-/* Felix 128bit-value frame injection header:
- *
- * bit 127: bypass the analyzer processing
- * bit 56-61: destination port mask
- * bit 28-29: pop_cnt: 3 disables all rewriting of the frame
- * bit 20-27: cpu extraction queue mask
- */
-FELIX_IFH_FIELD(bypass, 127, 1)
-FELIX_IFH_FIELD(rew_op, 117, 9)
-FELIX_IFH_FIELD(dstp, 56, 6)
-FELIX_IFH_FIELD(srcp, 43, 4)
-FELIX_IFH_FIELD(popcnt, 28, 2)
-FELIX_IFH_FIELD(cpuq, 20, 8)
-
-#define FELIX_IFH_INJ_POP_CNT_DISABLE 3
-
-/* Felix 128bit-value frame extraction header */
-
-/* bit 85-116: rewriter val */
-/* bit 43-45: source port id */
-FELIX_EFH_FIELD(rew_val, 85, 32)
-FELIX_EFH_FIELD(srcp, 43, 4)
-
-static void felix_tx_hdr_set(struct sk_buff *skb, struct ocelot_port *port)
-{
-	u64 *ifh = skb_push(skb, FELIX_XFH_LEN);
-	struct ocelot *ocelot = port->ocelot;
-
-	/* fill frame injection header */
-	memset(ifh, 0x0, FELIX_XFH_LEN);
-	felix_set_ifh_bypass(ifh, 1);
-	felix_set_ifh_dstp(ifh, BIT(port->chip_port));
-	felix_set_ifh_srcp(ifh, ocelot->cpu_port_id);
-	felix_set_ifh_popcnt(ifh, 0);
-	felix_set_ifh_cpuq(ifh, 0x0);
-
-	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&
-	    port->tx_tstamp) {
-		u8 id = (port->ocelot->tstamp_id++) % 4;
-
-		felix_set_ifh_rew_op(ifh, 0x3 | id << 3);
-	}
-}
-
-static rx_handler_result_t felix_frm_ext_handler(struct sk_buff **pskb)
-{
-	struct net_device *ndev = (*pskb)->dev;
-	struct sk_buff *skb = *pskb;
-	struct skb_shared_hwtstamps *shhwtstamps;
-	struct timespec64 ts;
-	struct ocelot_port *port = NULL;
-	struct ocelot *ocelot = NULL;
-	char *start = skb->data;
-	u64 *efh, tstamp_in_ns;
-	u32 p, tstamp_lo, tstamp_hi;
-
-	/* extraction header offset: assume eth header was consumed */
-	efh = (u64 *)(start + FELIX_XFH_LEN - ETH_HLEN);
-
-	/* decode src port */
-	p = felix_get_efh_srcp(efh);
-
-	tstamp_lo = felix_get_efh_rew_val(efh);
-
-	/* don't pass frames with unknown header format back to interface */
-	if (unlikely(p >= FELIX_MAX_NUM_PHY_PORTS)) {
-		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
-	}
-
-	ocelot = rcu_dereference(ndev->rx_handler_data);
-	/* get the intf to fwd the frame */
-	if (ocelot && p != ocelot->cpu_port_id) {
-		port = ocelot->ports[p];
-		if (port)
-			ndev = port->dev;
-	}
-
-	/* pull the rest of extraction header */
-	skb_pull(skb, XFH_LONG_PREFIX_LEN - ETH_HLEN);
-
-	/* init with actual protocol type */
-	skb->protocol = eth_type_trans(skb, ndev);
-
-	skb_reset_transport_header(skb);
-	skb_reset_network_header(skb);
-	skb->pkt_type = PACKET_HOST;
-
-	/* remove from inet csum the extraction and eth headers */
-	skb_postpull_rcsum(skb, start, XFH_LONG_PREFIX_LEN);
-
-	/* frame for CPU */
-	if (ocelot && p == ocelot->cpu_port_id)
-		return RX_HANDLER_PASS;
-
-	if (port && port->rx_tstamp) {
-		felix_ptp_gettime(&ocelot->ptp_caps, &ts);
-		tstamp_in_ns = ktime_set(ts.tv_sec, ts.tv_nsec);
-
-		tstamp_hi = tstamp_in_ns >> 32;
-		if ((tstamp_in_ns & 0xffffffff) < tstamp_lo)
-			tstamp_hi = tstamp_hi - 1;
-
-		tstamp_in_ns = ((u64)tstamp_hi << 32) | tstamp_lo;
-
-		shhwtstamps = skb_hwtstamps(skb);
-		memset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));
-		shhwtstamps->hwtstamp = tstamp_in_ns;
-	}
-
-	if (ocelot->bridge_mask & BIT(p))
-		skb->offload_fwd_mark = 1;
-	netif_rx(skb);
-
-	return RX_HANDLER_CONSUMED;
-}
-
-static netdev_tx_t felix_cpu_inj_handler(struct sk_buff *skb,
-					 struct ocelot_port *port)
-{
-	struct net_device *pair_ndev = port->cpu_inj_handler_data;
-	bool do_tstamp = skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&
-			 port->tx_tstamp;
-
-	if (!netif_running(pair_ndev))
-		return NETDEV_TX_BUSY;
-
-	if (do_tstamp) {
-		struct ocelot_skb *oskb =
-			devm_kzalloc(port->ocelot->dev,
-				     sizeof(struct ocelot_skb),
-				     GFP_KERNEL);
-		oskb->skb = skb_clone(skb, GFP_ATOMIC);
-		if (skb->sk)
-			skb_set_owner_w(oskb->skb, skb->sk);
-		oskb->tstamp_id = port->ocelot->tstamp_id % 4;
-		oskb->tx_port = port->chip_port;
-		list_add_tail(&oskb->head, &port->ocelot->skbs);
-
-		skb_shinfo(oskb->skb)->tx_flags |= SKBTX_IN_PROGRESS;
-	}
-
-	if (unlikely(skb_headroom(skb) < FELIX_XFH_LEN)) {
-		struct sk_buff *skb_orig = skb;
-
-		skb = skb_realloc_headroom(skb, FELIX_XFH_LEN);
-
-		/* TODO: free skb in non irq context */
-		if (!skb) {
-			dev_kfree_skb_any(skb_orig);
-			return NETDEV_TX_OK;
-		}
-
-		if (skb_orig->sk)
-			skb_set_owner_w(skb, skb_orig->sk);
-
-		skb_copy_queue_mapping(skb, skb_orig);
-		skb->priority = skb_orig->priority;
-#ifdef CONFIG_NET_SCHED
-		skb->tc_index = skb_orig->tc_index;
-#endif
-		dev_consume_skb_any(skb_orig);
-	}
-
-	/* add cpu injection header */
-	felix_tx_hdr_set(skb, port);
-
-	skb->dev = pair_ndev;
-	dev_queue_xmit(skb);
-
-	return NETDEV_TX_OK;
-}
-
-static void felix_register_rx_handler(struct ocelot *ocelot,
-				      struct net_device *pair_ndev)
-{
-	int err = -EBUSY;
-
-	/* must obtain rtnl mutex first */
-	rtnl_lock();
-	if (netif_device_present(pair_ndev) &&
-	    !netdev_is_rx_handler_busy(pair_ndev))
-		err = netdev_rx_handler_register(pair_ndev,
-						 felix_frm_ext_handler, ocelot);
-	rtnl_unlock();
-	if (err)
-		dev_err(ocelot->dev,
-			"pair ndev busy: rx_handler not registered\n");
-}
-
-static struct regmap *felix_io_init(struct ocelot *ocelot, u8 target)
-{
-	void __iomem *target_regs;
-	struct regmap_config felix_regmap_config = {
-		.reg_bits	= 32,
-		.val_bits	= 32,
-		.reg_stride	= 4,
-	};
-
-	felix_regmap_config.name = felix_switch_res[target].name;
-	target_regs = devm_ioremap_resource(ocelot->dev,
-					    &felix_switch_res[target]);
-	if (IS_ERR(target_regs))
-		return ERR_CAST(target_regs);
-
-	return devm_regmap_init_mmio(ocelot->dev, target_regs,
-				     &felix_regmap_config);
-}
-
-static void felix_release_ports(struct ocelot *ocelot)
-{
-	struct ocelot_port *ocelot_port;
-	struct net_device *pair_ndev;
-	struct phy_device *phydev;
-	struct device_node *dn;
-	int i;
-
-	for (i = 0; i < ocelot->num_phys_ports; i++) {
-		ocelot_port = ocelot->ports[i];
-		if (!ocelot_port || !ocelot_port->phy || !ocelot_port->dev)
-			continue;
-
-		phydev = ocelot_port->phy;
-#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
-		tsn_port_unregister(ocelot_port->dev);
-#endif
-		unregister_netdev(ocelot_port->dev);
-		free_netdev(ocelot_port->dev);
-
-		if (phy_is_pseudo_fixed_link(phydev)) {
-			dn = phydev->mdio.dev.of_node;
-			/* decr refcnt: of_phy_register_fixed_link */
-			of_phy_deregister_fixed_link(dn);
-		}
-		phy_device_free(phydev); /* decr refcnt: of_find_phy_device */
-
-		/* unregister cpu port rx handler */
-		if (ocelot->cpu_port_id == i) {
-			pair_ndev = ocelot_port->cpu_inj_handler_data;
-			if (pair_ndev && netif_device_present(pair_ndev)) {
-				rtnl_lock();
-				netdev_rx_handler_unregister(pair_ndev);
-				rtnl_unlock();
-			}
-		}
-	}
-}
-
-static void felix_setup_port_mac(struct ocelot_port *port)
-{
-	/* Only 1G full duplex supported for now */
-	ocelot_port_writel(port, DEV_MAC_MODE_CFG_FDX_ENA |
-			   DEV_MAC_MODE_CFG_GIGA_MODE_ENA, DEV_MAC_MODE_CFG);
-	/* Take MAC, Port, Phy (intern) and PCS (SGMII/Serdes)
-	 * clock out of reset
-	 */
-	ocelot_port_writel(port, DEV_CLOCK_CFG_LINK_SPEED(OCELOT_SPEED_1000),
-			   DEV_CLOCK_CFG);
-}
-
-static void felix_setup_port_inj(struct ocelot_port *port,
-				 struct net_device *pair_ndev)
-{
-	struct ocelot *ocelot = port->ocelot;
-	struct net_device *pdev = port->dev;
-
-	if (port->chip_port == ocelot->cpu_port_id) {
-		/* expected frame formats on NPI:
-		 * short prefix frame tag on tx and long prefix on rx
-		 */
-		ocelot_write_rix(ocelot, SYS_PORT_MODE_INCL_XTR_HDR(3) |
-				 SYS_PORT_MODE_INCL_INJ_HDR(1), SYS_PORT_MODE,
-				 port->chip_port);
-
-		/* register rx handler for decoding tagged frames from NPI */
-		felix_register_rx_handler(port->ocelot, pair_ndev);
-		/* save for cleanup */
-		port->cpu_inj_handler_data = pair_ndev;
-	} else {
-		/* set frame injection handler on non-NPI ports */
-		port->cpu_inj_handler = &felix_cpu_inj_handler;
-		port->cpu_inj_handler_data = pair_ndev;
-		/* no CPU header, only normal frames */
-		ocelot_write_rix(ocelot, 0, SYS_PORT_MODE, port->chip_port);
-	}
-
-	/* set port max MTU size */
-	pdev->max_mtu = FELIX_MAX_MTU;
-	pdev->mtu = pdev->max_mtu;
-}
-
-static void felix_get_hwtimestamp(struct ocelot *ocelot, struct timespec64 *ts)
-{
-	/* Read current PTP time to get seconds */
-	u32 val = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);
-
-	val &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);
-	val |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_SAVE);
-	ocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);
-	ts->tv_sec = ocelot_read_rix(ocelot, PTP_TOD_SEC_LSB, TOD_ACC_PIN);
-
-	/* Read packet HW timestamp from FIFO */
-	val = ocelot_read(ocelot, SYS_PTP_TXSTAMP);
-	ts->tv_nsec = SYS_PTP_TXSTAMP_PTP_TXSTAMP(val);
-
-	/* Sec has incremented since the ts was registered */
-	if ((ts->tv_sec & 0x1) != !!(val & SYS_PTP_TXSTAMP_PTP_TXSTAMP_SEC))
-		ts->tv_sec--;
-}
-
-static bool felix_tx_tstamp_avail(struct ocelot *ocelot)
-{
-	return (!list_empty(&ocelot->skbs)) &&
-	       (ocelot_read(ocelot, SYS_PTP_STATUS) &
-		SYS_PTP_STATUS_PTP_MESS_VLD);
-}
-
-static void felix_tx_clean(struct ocelot *ocelot)
-{
-	do {
-		struct list_head *pos, *tmp;
-		struct ocelot_skb *entry;
-		struct sk_buff *skb = NULL;
-		struct timespec64 ts;
-		struct skb_shared_hwtstamps shhwtstamps;
-		u32 val, id, port;
-
-		val = ocelot_read(ocelot, SYS_PTP_STATUS);
-
-		id = SYS_PTP_STATUS_PTP_MESS_ID_X(val);
-		port = SYS_PTP_STATUS_PTP_MESS_TXPORT_X(val);
-
-		list_for_each_safe(pos, tmp, &ocelot->skbs) {
-			entry = list_entry(pos, struct ocelot_skb, head);
-			if (entry->tstamp_id != id ||
-			    entry->tx_port != port)
-				continue;
-			skb = entry->skb;
-
-			list_del(pos);
-			devm_kfree(ocelot->dev, entry);
-		}
-
-		if (likely(skb)) {
-			felix_get_hwtimestamp(ocelot, &ts);
-			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
-			shhwtstamps.hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);
-			skb_tstamp_tx(skb, &shhwtstamps);
-
-			dev_kfree_skb_any(skb);
-		}
-
-		/* Next tstamp */
-		ocelot_write(ocelot, SYS_PTP_NXT_PTP_NXT, SYS_PTP_NXT);
-
-	} while (ocelot_read(ocelot, SYS_PTP_STATUS) &
-		 SYS_PTP_STATUS_PTP_MESS_VLD);
-}
-
-static void felix_preempt_irq_clean(struct ocelot *ocelot)
-{
-	int port;
-	struct ocelot_port *ocelot_port;
-
-	for (port = 0; port < FELIX_MAX_NUM_PHY_PORTS; port++) {
-		ocelot_port = ocelot->ports[port];
-		ocelot_port_rmwl(
-			ocelot_port,
-		    DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STICKY,
-		    DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STICKY,
-		    DEV_GMII_MM_STATISTICS_MM_STATUS);
-	}
-}
-
-static void felix_irq_handle_work(struct work_struct *work)
-{
-	struct ocelot *ocelot = container_of(work, struct ocelot,
-					     irq_handle_work);
-	struct pci_dev *pdev = container_of(ocelot->dev, struct pci_dev, dev);
-
-	/* The INTB interrupt is used both for 1588 interrupt and
-	 * preemption status change interrupt on each port. So check
-	 * which interrupt it is, and clean it.
-	 */
-	if (felix_tx_tstamp_avail(ocelot))
-		felix_tx_clean(ocelot);
-	else
-		felix_preempt_irq_clean(ocelot);
-
-	enable_irq(pdev->irq);
-}
-
-static irqreturn_t felix_isr(int irq, void *data)
-{
-	struct ocelot *ocelot = (struct ocelot *)data;
-
-	disable_irq_nosync(irq);
-	queue_work(ocelot->ocelot_wq, &ocelot->irq_handle_work);
-
-	return IRQ_HANDLED;
-}
-
-static int felix_ports_init(struct pci_dev *pdev)
-{
-	struct ocelot *ocelot = pci_get_drvdata(pdev);
-	struct device_node *np = ocelot->dev->of_node;
-	struct net_device *pair_ndev = NULL;
-	struct device_node *phy_node = NULL;
-	struct device_node *portnp, *ethnp;
-	struct phy_device *phydev = NULL;
-	struct resource *felix_res;
-	void __iomem *port_regs;
-	u32 port;
-	int err;
-
-	portnp = of_find_node_with_property(np, "cpu-ethernet");
-	if (portnp) {
-		ethnp = of_parse_phandle(portnp, "cpu-ethernet", 0);
-		if (!ethnp)
-			return -EINVAL;
-		pair_ndev = of_find_net_device_by_node(ethnp);
-		if (!pair_ndev)
-			return -EPROBE_DEFER;
-		if (of_property_read_u32(portnp, "reg", &port))
-			return -EINVAL;
-
-		ocelot->cpu_port_id = port;
-		ocelot->num_cpu_ports = 1;
-	}
-
-	if (!pair_ndev)
-		ocelot->cpu_port_id = FELIX_MAX_NUM_PHY_PORTS;
-
-	ocelot->num_phys_ports = FELIX_MAX_NUM_PHY_PORTS;
-	ocelot->ports = devm_kcalloc(ocelot->dev, ocelot->num_phys_ports,
-				     sizeof(struct ocelot_port *), GFP_KERNEL);
-
-	/* alloc netdev for each port */
-	err = ocelot_init(ocelot);
-	if (err)
-		return err;
-
-	for_each_available_child_of_node(np, portnp) {
-		struct ocelot_port *ocelot_port;
-
-		if (!portnp || !portnp->name ||
-		    of_node_cmp(portnp->name, "port") ||
-		    of_property_read_u32(portnp, "reg", &port))
-			continue;
-		if (port >= FELIX_MAX_NUM_PHY_PORTS) {
-			dev_err(ocelot->dev, "invalid port num: %d\n", port);
-			continue;
-		}
-		if (ocelot->ports[port]) {
-			dev_warn(ocelot->dev, "port %d already defined\n",
-				 port);
-			continue;
-		}
-		felix_res = &felix_switch_res[PORT_RES_START + port];
-		port_regs = devm_ioremap_resource(ocelot->dev, felix_res);
-		if (IS_ERR(port_regs)) {
-			dev_err(ocelot->dev,
-				"failed to map registers for port %d\n", port);
-			continue;
-		}
-		if (phy_node) {
-			of_node_put(phy_node);
-			phy_node = NULL;
-		}
-		phy_node = of_parse_phandle(portnp, "phy-handle", 0);
-		if (!phy_node) {
-			if (!of_phy_is_fixed_link(portnp))
-				continue;
-			err = of_phy_register_fixed_link(portnp);
-			if (err < 0) {
-				dev_err(ocelot->dev,
-					"can't create fixed link for port:%d\n",
-					port);
-				continue;
-			}
-			phydev = of_phy_find_device(portnp);
-		} else {
-			phydev = of_phy_find_device(phy_node);
-		}
-		if (!phydev)
-			continue;
-
-		of_node_put(phy_node);
-		phy_node = NULL;
-
-		phy_attached_info(phydev);
-
-		err = ocelot_probe_port(ocelot, port, port_regs, phydev);
-		if (err) {
-			dev_err(ocelot->dev, "failed to probe ports\n");
-			goto release_ports;
-		}
-
-		/* apply felix config */
-		ocelot_port = ocelot->ports[port];
-
-		felix_setup_port_mac(ocelot_port);
-		if (pair_ndev)
-			felix_setup_port_inj(ocelot_port, pair_ndev);
-
-#ifdef CONFIG_MSCC_FELIX_SWITCH_TSN
-		tsn_port_register(ocelot_port->dev,
-				  (struct tsn_ops *)&switch_tsn_ops,
-				  (u16)pdev->bus->number + GROUP_OFFSET_SWITCH);
-#endif
-	}
-	/* set port for external CPU frame extraction/injection */
-	if (pair_ndev)
-		ocelot_write(ocelot, QSYS_EXT_CPU_CFG_EXT_CPUQ_MSK_M |
-			     QSYS_EXT_CPU_CFG_EXT_CPU_PORT(ocelot->cpu_port_id),
-			     QSYS_EXT_CPU_CFG);
-
-	return 0;
-
-release_ports:
-	felix_release_ports(ocelot);
-
-	return err;
-}
-
-static int felix_init_switch_core(struct ocelot *ocelot)
-{
-	int timeout = FELIX_INIT_TIMEOUT;
-	int val = 1;
-
-	/* soft-reset the switch core */
-	regmap_field_write(ocelot->regfields[GCB_SOFT_RST_SWC_RST], 1);
-	do {
-		usleep_range(10, 100);
-		regmap_field_read(ocelot->regfields[GCB_SOFT_RST_SWC_RST],
-				  &val);
-	} while (val && --timeout);
-
-	if (timeout == 0) {
-		dev_err(ocelot->dev, "timeout: switch core init\n");
-		return -ETIMEDOUT;
-	}
-	/* initialize switch mem ~40us */
-	ocelot_write(ocelot, SYS_RAM_INIT_RAM_INIT, SYS_RAM_INIT);
-	timeout = FELIX_INIT_TIMEOUT;
-	do {
-		usleep_range(40, 80);
-		val = ocelot_read(ocelot, SYS_RAM_INIT);
-	} while (val && --timeout);
-
-	if (timeout == 0) {
-		dev_err(ocelot->dev, "timeout: switch sram init\n");
-		return -ETIMEDOUT;
-	}
-
-	/* enable switch core */
-	regmap_field_write(ocelot->regfields[SYS_RESET_CFG_CORE_ENA], 1);
-
-	return 0;
-}
-
-static int felix_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-	resource_size_t offset;
-	struct ocelot *ocelot;
-	size_t len;
-	int i, err;
-
-	err = pci_enable_device(pdev);
-	if (err) {
-		dev_err(&pdev->dev, "device enable failed\n");
-		return err;
-	}
-
-	/* set up for high or low dma */
-	err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
-	if (err) {
-		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
-		if (err) {
-			dev_err(&pdev->dev,
-				"DMA configuration failed: 0x%x\n", err);
-			goto err_dma;
-		}
-	}
-
-	offset = pci_resource_start(pdev, FELIX_SWITCH_BAR);
-
-	pci_set_master(pdev);
-
-	ocelot = kzalloc(sizeof(*ocelot), GFP_KERNEL);
-	if (!ocelot) {
-		err = -ENOMEM;
-		goto err_alloc_ocelot;
-	}
-
-	pci_set_drvdata(pdev, ocelot);
-	ocelot->dev = &pdev->dev;
-
-	err = request_irq(pdev->irq, &felix_isr, 0, "felix-intb", ocelot);
-	if (err)
-		goto err_alloc_irq;
-
-	ocelot->ocelot_wq = alloc_workqueue("ocelot_wq", 0, 0);
-	if (!ocelot->ocelot_wq) {
-		err = -ENOMEM;
-		goto err_alloc_wq;
-	}
-
-	INIT_WORK(&ocelot->irq_handle_work, felix_irq_handle_work);
-
-	INIT_LIST_HEAD(&ocelot->skbs);
-
-	len = pci_resource_len(pdev, FELIX_SWITCH_BAR);
-	if (len == 0) {
-		err = -EINVAL;
-		goto err_resource_len;
-	}
-
-	regs = pci_iomap(pdev, FELIX_SWITCH_BAR, len);
-	if (!regs) {
-		err = -ENXIO;
-		dev_err(&pdev->dev, "ioremap() failed\n");
-		goto err_iomap;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(felix_switch_res); i++)
-		if (felix_switch_res[i].flags == IORESOURCE_MEM) {
-			felix_switch_res[i].start += offset;
-			felix_switch_res[i].end += offset;
-		}
-
-	for (i = ANA; i <= GCB; i++) {
-		struct regmap *target;
-
-		target = felix_io_init(ocelot, i);
-		if (IS_ERR(target))
-			return PTR_ERR(target);
-
-		ocelot->targets[i] = target;
-	}
-
-	err = felix_chip_init(ocelot);
-	if (err)
-		goto err_chip_init;
-
-	/* initialize switch core */
-	err = felix_init_switch_core(ocelot);
-	if (err)
-		goto err_sw_core_init;
-
-	err = felix_ptp_init(ocelot);
-	if (err)
-		goto err_ptp_init;
-
-	err = felix_ports_init(pdev);
-	if (err)
-		goto err_ports_init;
-
-	register_netdevice_notifier(&ocelot_netdevice_nb);
-
-	dev_info(&pdev->dev, "%s - version %s probed\n", felix_driver_string,
-		 felix_driver_version);
-	return 0;
-
-err_ports_init:
-	felix_ptp_remove(ocelot);
-err_ptp_init:
-err_chip_init:
-err_sw_core_init:
-	pci_iounmap(pdev, regs);
-err_iomap:
-err_resource_len:
-	destroy_workqueue(ocelot->ocelot_wq);
-err_alloc_wq:
-	free_irq(pdev->irq, ocelot);
-err_alloc_irq:
-	kfree(ocelot);
-err_alloc_ocelot:
-err_dma:
-	pci_disable_device(pdev);
-
-	return err;
-}
-
-static void felix_pci_remove(struct pci_dev *pdev)
-{
-	struct ocelot *ocelot;
-
-	ocelot = pci_get_drvdata(pdev);
-
-	/* stop workqueue thread */
-	ocelot_deinit(ocelot);
-
-	free_irq(pdev->irq, ocelot);
-
-	unregister_netdevice_notifier(&ocelot_netdevice_nb);
-
-	felix_release_ports(ocelot);
-
-	pci_iounmap(pdev, regs);
-	destroy_workqueue(ocelot->ocelot_wq);
-	kfree(ocelot);
-	pci_disable_device(pdev);
-	pr_debug("%s - version %s removed\n", felix_driver_string,
-		 felix_driver_version);
-}
-
-static struct pci_driver felix_pci_driver = {
-	.name = "mscc_felix",
-	.id_table = felix_ids,
-	.probe = felix_pci_probe,
-	.remove = felix_pci_remove,
-};
-
-module_pci_driver(felix_pci_driver);
-
-MODULE_DESCRIPTION("Felix switch driver");
-MODULE_AUTHOR("Razvan Stefanescu <razvan.stefanescu@nxp.com>");
-MODULE_LICENSE("Dual MIT/GPL");
diff --git a/drivers/net/ethernet/mscc/felix_ptp.c b/drivers/net/ethernet/mscc/felix_ptp.c
deleted file mode 100644
index 6b7112df3fef..000000000000
--- a/drivers/net/ethernet/mscc/felix_ptp.c
+++ /dev/null
@@ -1,154 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Felix switch PTP clock driver
- *
- * Copyright 2019 NXP
- */
-
-#include "ocelot.h"
-
-int felix_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)
-{
-	struct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_caps);
-	u32 val, tod_ns, tod_sec_lsb, tod_sec_msb;
-
-	val = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);
-	val &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);
-	val |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_SAVE);
-	ocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);
-
-	tod_sec_msb = ocelot_read_rix(ocelot, PTP_TOD_SEC_MSB, TOD_ACC_PIN);
-	tod_sec_lsb = ocelot_read_rix(ocelot, PTP_TOD_SEC_LSB, TOD_ACC_PIN);
-	tod_ns = ocelot_read_rix(ocelot, PTP_TOD_NSEC, TOD_ACC_PIN);
-
-	ts->tv_sec = ((u64)(tod_sec_msb & SEC_MSB_MASK) << 32) | tod_sec_lsb;
-	ts->tv_nsec = tod_ns & NSEC_MASK;
-
-	/* Deal with negative values -1 and -2 */
-	if (ts->tv_nsec == 0x3fffffff) {
-		ts->tv_sec -= 1;
-		ts->tv_nsec = 999999999;
-	} else if (ts->tv_nsec == 0x3ffffffe) {
-		ts->tv_sec -= 1;
-		ts->tv_nsec = 999999998;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(felix_ptp_gettime);
-
-static int felix_ptp_settime(struct ptp_clock_info *ptp,
-			     const struct timespec64 *ts)
-{
-	struct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_caps);
-	u32 val, tod_ns, tod_sec_lsb, tod_sec_msb;
-
-	val = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);
-	val &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);
-	val |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_IDLE);
-	ocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);
-
-	tod_ns = ts->tv_nsec & NSEC_MASK;
-	tod_sec_msb = (u32)(ts->tv_sec >> 32) & SEC_MSB_MASK;
-	tod_sec_lsb = (u32)ts->tv_sec;
-
-	ocelot_write_rix(ocelot, tod_ns, PTP_TOD_NSEC, TOD_ACC_PIN);
-	ocelot_write_rix(ocelot, tod_sec_msb, PTP_TOD_SEC_MSB, TOD_ACC_PIN);
-	ocelot_write_rix(ocelot, tod_sec_lsb, PTP_TOD_SEC_LSB, TOD_ACC_PIN);
-
-	val = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);
-	val &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);
-	val |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_LOAD);
-	ocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);
-
-	return 0;
-}
-
-static int felix_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
-{
-	struct timespec64 ts;
-	struct timespec64 offset;
-
-	offset = ns_to_timespec64(delta);
-
-	felix_ptp_gettime(ptp, &ts);
-	ts = timespec64_add(ts, offset);
-	felix_ptp_settime(ptp, &ts);
-
-	return 0;
-}
-
-static int felix_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
-{
-	struct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_caps);
-	u64 adj;
-	u32 reg_adjfreq = 0, reg_adjcfg = PTP_CLK_ADJ_ENA;
-
-	if (!ppb)
-		goto no_adj;
-
-	if (ppb < 0) {
-		reg_adjcfg |= PTP_CLK_ADJ_DIR;
-		ppb = -ppb;
-	}
-
-	adj = PSEC_PER_SEC;
-	do_div(adj, ppb);
-
-	if (adj >= (1L << 30)) {
-		reg_adjfreq |= PTP_CLK_ADJ_UNIT_NS;
-		do_div(adj, 1000);
-	}
-
-	if (adj >= (1L << 30))
-		goto no_adj;
-
-	reg_adjfreq |= adj;
-
-	ocelot_write(ocelot, reg_adjfreq, PTP_CLK_ADJ_FRQ);
-	ocelot_write(ocelot, reg_adjcfg, PTP_CLK_ADJ_CFG);
-	return 0;
-
-no_adj:
-	ocelot_write(ocelot, 0, PTP_CLK_ADJ_CFG);
-	return 0;
-}
-
-static const struct ptp_clock_info felix_ptp_caps = {
-	.owner		= THIS_MODULE,
-	.name		= "felix ptp clock",
-	.max_adj	= 0x7fffffff,
-	.n_alarm	= 0,
-	.n_ext_ts	= 0,
-	.n_per_out	= 0,
-	.n_pins		= 0,
-	.pps		= 0,
-	.gettime64	= felix_ptp_gettime,
-	.settime64	= felix_ptp_settime,
-	.adjtime	= felix_ptp_adjtime,
-	.adjfreq	= felix_ptp_adjfreq,
-};
-
-int felix_ptp_init(struct ocelot *ocelot)
-{
-	/* Reset and enable ptp clock */
-	regmap_field_write(ocelot->regfields[PTP_MISC_CFG_ENA], 0);
-	regmap_field_write(ocelot->regfields[PTP_SYS_CLK_CFG_PER_NS],
-			   SYS_CLK_PER_NS);
-	regmap_field_write(ocelot->regfields[PTP_SYS_CLK_CFG_PER_PS100],
-			   SYS_CLK_PER_PS100);
-	regmap_field_write(ocelot->regfields[PTP_MISC_CFG_ENA], 1);
-
-	ocelot->ptp_caps = felix_ptp_caps;
-
-	ocelot->clock = ptp_clock_register(&ocelot->ptp_caps, ocelot->dev);
-	if (IS_ERR(ocelot->clock))
-		return PTR_ERR(ocelot->clock);
-
-	ocelot->phc_index = ptp_clock_index(ocelot->clock);
-	return 0;
-}
-
-void felix_ptp_remove(struct ocelot *ocelot)
-{
-	ptp_clock_unregister(ocelot->clock);
-}
diff --git a/drivers/net/ethernet/mscc/felix_regs.c b/drivers/net/ethernet/mscc/felix_regs.c
deleted file mode 100644
index 970637f4d272..000000000000
--- a/drivers/net/ethernet/mscc/felix_regs.c
+++ /dev/null
@@ -1,607 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Felix Switch driver
- *
- * Copyright 2017 Microsemi Corporation
- * Copyright 2018-2019 NXP
- */
-#include <linux/phy.h>
-#include "ocelot.h"
-
-static const u32 felix_ana_regmap[] = {
-	REG(ANA_ADVLEARN,                  0x0089a0),
-	REG(ANA_VLANMASK,                  0x0089a4),
-//	REG(ANA_PORT_B_DOMAIN,             0x0089a8),
-	REG(ANA_ANAGEFIL,                  0x0089ac),
-	REG(ANA_ANEVENTS,                  0x0089b0),
-	REG(ANA_STORMLIMIT_BURST,          0x0089b4),
-	REG(ANA_STORMLIMIT_CFG,            0x0089b8),
-	REG(ANA_ISOLATED_PORTS,            0x0089c8),
-	REG(ANA_COMMUNITY_PORTS,           0x0089cc),
-	REG(ANA_AUTOAGE,                   0x0089d0),
-	REG(ANA_MACTOPTIONS,               0x0089d4),
-	REG(ANA_LEARNDISC,                 0x0089d8),
-	REG(ANA_AGENCTRL,                  0x0089dc),
-	REG(ANA_MIRRORPORTS,               0x0089e0),
-	REG(ANA_EMIRRORPORTS,              0x0089e4),
-	REG(ANA_FLOODING,                  0x0089e8),
-	REG(ANA_FLOODING_IPMC,             0x008a08),
-	REG(ANA_SFLOW_CFG,                 0x008a0c),
-	REG(ANA_PORT_MODE,                 0x008a28),
-	REG(ANA_CUT_THRU_CFG,              0x008a48),
-	REG(ANA_PGID_PGID,                 0x008400),
-	REG(ANA_TABLES_ANMOVED,            0x007f1c),
-	REG(ANA_TABLES_MACHDATA,           0x007f20),
-	REG(ANA_TABLES_MACLDATA,           0x007f24),
-	REG(ANA_TABLES_STREAMDATA,         0x007f28),
-	REG(ANA_TABLES_MACACCESS,          0x007f2c),
-	REG(ANA_TABLES_MACTINDX,           0x007f30),
-	REG(ANA_TABLES_VLANACCESS,         0x007f34),
-	REG(ANA_TABLES_VLANTIDX,           0x007f38),
-	REG(ANA_TABLES_ISDXACCESS,         0x007f3c),
-	REG(ANA_TABLES_ISDXTIDX,           0x007f40),
-	REG(ANA_TABLES_ENTRYLIM,           0x007f00),
-	REG(ANA_TABLES_PTP_ID_HIGH,        0x007f44),
-	REG(ANA_TABLES_PTP_ID_LOW,         0x007f48),
-	REG(ANA_TABLES_STREAMACCESS,       0x007f4c),
-	REG(ANA_TABLES_STREAMTIDX,         0x007f50),
-	REG(ANA_TABLES_SEQ_HISTORY,        0x007f54),
-	REG(ANA_TABLES_SEQ_MASK,           0x007f58),
-	REG(ANA_TABLES_SFID_MASK,          0x007f5c),
-	REG(ANA_TABLES_SFIDACCESS,         0x007f60),
-	REG(ANA_TABLES_SFIDTIDX,           0x007f64),
-	REG(ANA_MSTI_STATE,                0x008600),
-	REG(ANA_OAM_UPM_LM_CNT,            0x008000),
-	REG(ANA_SG_ACCESS_CTRL,            0x008a64),
-	REG(ANA_SG_CONFIG_REG_1,           0x007fb0),
-	REG(ANA_SG_CONFIG_REG_2,           0x007fb4),
-	REG(ANA_SG_CONFIG_REG_3,           0x007fb8),
-	REG(ANA_SG_CONFIG_REG_4,           0x007fbc),
-	REG(ANA_SG_CONFIG_REG_5,           0x007fc0),
-	REG(ANA_SG_GCL_GS_CONFIG,          0x007f80),
-	REG(ANA_SG_GCL_TI_CONFIG,          0x007f90),
-	REG(ANA_SG_STATUS_REG_1,           0x008980),
-	REG(ANA_SG_STATUS_REG_2,           0x008984),
-	REG(ANA_SG_STATUS_REG_3,           0x008988),
-	REG(ANA_PORT_VLAN_CFG,             0x007800),
-	REG(ANA_PORT_DROP_CFG,             0x007804),
-	REG(ANA_PORT_QOS_CFG,              0x007808),
-	REG(ANA_PORT_VCAP_CFG,             0x00780c),
-	REG(ANA_PORT_VCAP_S1_KEY_CFG,      0x007810),
-	REG(ANA_PORT_VCAP_S2_CFG,          0x00781c),
-	REG(ANA_PORT_PCP_DEI_MAP,          0x007820),
-	REG(ANA_PORT_CPU_FWD_CFG,          0x007860),
-	REG(ANA_PORT_CPU_FWD_BPDU_CFG,     0x007864),
-	REG(ANA_PORT_CPU_FWD_GARP_CFG,     0x007868),
-	REG(ANA_PORT_CPU_FWD_CCM_CFG,      0x00786c),
-	REG(ANA_PORT_PORT_CFG,             0x007870),
-	REG(ANA_PORT_POL_CFG,              0x007874),
-	REG(ANA_PORT_PTP_CFG,              0x007878),
-	REG(ANA_PORT_PTP_DLY1_CFG,         0x00787c),
-	REG(ANA_PORT_PTP_DLY2_CFG,         0x007880),
-	REG(ANA_PORT_SFID_CFG,             0x007884),
-	REG(ANA_PFC_PFC_CFG,               0x008800),
-//	REG(ANA_PFC_PFC_TIMER,             0x008804),
-//	REG(ANA_IPT_OAM_MEP_CFG,           0x007000),
-//	REG(ANA_IPT_IPT,                   0x007004),
-//	REG(ANA_PPT_PPT,                   0x007fd0),
-//	REG(ANA_FID_MAP_FID_MAP,           0x000000),
-	REG(ANA_AGGR_CFG,                  0x008a68),
-	REG(ANA_CPUQ_CFG,                  0x008a6c),
-//	REG(ANA_CPUQ_CFG2,                 0x008a70),
-	REG(ANA_CPUQ_8021_CFG,             0x008a74),
-	REG(ANA_DSCP_CFG,                  0x008ab4),
-	REG(ANA_DSCP_REWR_CFG,             0x008bb4),
-	REG(ANA_VCAP_RNG_TYPE_CFG,         0x008bf4),
-	REG(ANA_VCAP_RNG_VAL_CFG,          0x008c14),
-//	REG(ANA_VRAP_CFG,                  0x008c34),
-//	REG(ANA_VRAP_HDR_DATA,             0x008c38),
-//	REG(ANA_VRAP_HDR_MASK,             0x008c3c),
-	REG(ANA_DISCARD_CFG,               0x008c40),
-	REG(ANA_FID_CFG,                   0x008c44),
-	REG(ANA_POL_PIR_CFG,               0x004000),
-	REG(ANA_POL_CIR_CFG,               0x004004),
-	REG(ANA_POL_MODE_CFG,              0x004008),
-	REG(ANA_POL_PIR_STATE,             0x00400c),
-	REG(ANA_POL_CIR_STATE,             0x004010),
-//	REG(ANA_POL_STATE,                 0x004014),
-	REG(ANA_POL_FLOWC,                 0x008c48),
-	REG(ANA_POL_HYST,                  0x008cb4),
-//	REG(ANA_POL_MISC_CFG,              0x008c94),
-};
-
-static const u32 felix_ptp_regmap[] = {
-	REG(PTP_MISC_CFG,                  0x0000a0),
-	REG(PTP_CLK_ADJ_CFG,               0x0000a4),
-	REG(PTP_CLK_ADJ_FRQ,               0x0000a8),
-	REG(PTP_PIN_INTR,                  0x0000ac),
-	REG(PTP_PIN_INTR_ENA,              0x0000b0),
-	REG(PTP_INTR_IDENT,                0x0000b4),
-	REG(PTP_SYS_CLK_CFG,               0x0000b8),
-	REG(PTP_CUR_NSF,                   0x0000bc),
-	REG(PTP_CUR_NSEC,                  0x0000c0),
-	REG(PTP_CUR_SEC_LSB,               0x0000c4),
-	REG(PTP_CUR_SEC_MSB,               0x0000c8),
-	REG(PTP_PIN_CFG,                   0x000000),
-	REG(PTP_TOD_SEC_MSB,               0x000004),
-	REG(PTP_TOD_SEC_LSB,               0x000008),
-	REG(PTP_TOD_NSEC,                  0x00000c),
-	REG(PTP_NSF,                       0x000010),
-	REG(PTP_PIN_WF_HIGH_PERIOD,        0x000014),
-	REG(PTP_PIN_WF_LOW_PERIOD,         0x000018),
-};
-
-static const u32 felix_qs_regmap[] = {
-	REG(QS_XTR_GRP_CFG,                0x000000),
-	REG(QS_XTR_RD,                     0x000008),
-	REG(QS_XTR_FRM_PRUNING,            0x000010),
-	REG(QS_XTR_FLUSH,                  0x000018),
-	REG(QS_XTR_DATA_PRESENT,           0x00001c),
-	REG(QS_XTR_CFG,                    0x000020),
-	REG(QS_INJ_GRP_CFG,                0x000024),
-	REG(QS_INJ_WR,                     0x00002c),
-	REG(QS_INJ_CTRL,                   0x000034),
-	REG(QS_INJ_STATUS,                 0x00003c),
-	REG(QS_INJ_ERR,                    0x000040),
-//	REG(QS_INH_DBG,                    0x000048),
-};
-
-static const u32 felix_qsys_regmap[] = {
-	REG(QSYS_PORT_MODE,                0x00f460),
-	REG(QSYS_SWITCH_PORT_MODE,         0x00f480),
-	REG(QSYS_STAT_CNT_CFG,             0x00f49c),
-	REG(QSYS_EEE_CFG,                  0x00f4a0),
-	REG(QSYS_EEE_THRES,                0x00f4b8),
-	REG(QSYS_IGR_NO_SHARING,           0x00f4bc),
-	REG(QSYS_EGR_NO_SHARING,           0x00f4c0),
-	REG(QSYS_SW_STATUS,                0x00f4c4),
-	REG(QSYS_EXT_CPU_CFG,              0x00f4e0),
-//	REG(QSYS_PAD_CFG,                  0x00f4e4),
-	REG(QSYS_CPU_GROUP_MAP,            0x00f4e8),
-//	REG(QSYS_QMAP,                     0x00f4ec),
-//	REG(QSYS_ISDX_SGRP,                0x00f000),
-//	REG(QSYS_TIMED_FRAME_ENTRY,        0x00e000),
-	REG(QSYS_TFRM_MISC,                0x00f50c),
-	REG(QSYS_TFRM_PORT_DLY,            0x00f510),
-	REG(QSYS_TFRM_TIMER_CFG_1,         0x00f514),
-	REG(QSYS_TFRM_TIMER_CFG_2,         0x00f518),
-	REG(QSYS_TFRM_TIMER_CFG_3,         0x00f51c),
-	REG(QSYS_TFRM_TIMER_CFG_4,         0x00f520),
-	REG(QSYS_TFRM_TIMER_CFG_5,         0x00f524),
-	REG(QSYS_TFRM_TIMER_CFG_6,         0x00f528),
-	REG(QSYS_TFRM_TIMER_CFG_7,         0x00f52c),
-	REG(QSYS_TFRM_TIMER_CFG_8,         0x00f530),
-	REG(QSYS_RED_PROFILE,              0x00f534),
-	REG(QSYS_RES_QOS_MODE,             0x00f574),
-	REG(QSYS_RES_CFG,                  0x00c000),
-	REG(QSYS_RES_STAT,                 0x00c004),
-	REG(QSYS_EGR_DROP_MODE,            0x00f578),
-	REG(QSYS_EQ_CTRL,                  0x00f57c),
-//	REG(QSYS_EVENTS_CORE,              0x00f580),
-	REG(QSYS_QMAXSDU_CFG_0,            0x00f584),
-	REG(QSYS_QMAXSDU_CFG_1,            0x00f5a0),
-	REG(QSYS_QMAXSDU_CFG_2,            0x00f5bc),
-	REG(QSYS_QMAXSDU_CFG_3,            0x00f5d8),
-	REG(QSYS_QMAXSDU_CFG_4,            0x00f5f4),
-	REG(QSYS_QMAXSDU_CFG_5,            0x00f610),
-	REG(QSYS_QMAXSDU_CFG_6,            0x00f62c),
-	REG(QSYS_QMAXSDU_CFG_7,            0x00f648),
-	REG(QSYS_PREEMPTION_CFG,           0x00f664),
-	REG(QSYS_CIR_CFG,                  0x000000),
-	REG(QSYS_EIR_CFG,                  0x000004),
-	REG(QSYS_SE_CFG,                   0x000008),
-	REG(QSYS_SE_DWRR_CFG,              0x00000c),
-//	REG(QSYS_SE_CONNECT,               0x00003c),
-	REG(QSYS_SE_DLB_SENSE,             0x000040),
-	REG(QSYS_CIR_STATE,                0x000044),
-	REG(QSYS_EIR_STATE,                0x000048),
-//	REG(QSYS_SE_STATE,                 0x00004c),
-	REG(QSYS_HSCH_MISC_CFG,            0x00f67c),
-	REG(QSYS_TAG_CONFIG,               0x00f680),
-	REG(QSYS_TAS_PARAM_CFG_CTRL,       0x00f698),
-	REG(QSYS_PORT_MAX_SDU,             0x00f69c),
-	REG(QSYS_PARAM_CFG_REG_1,          0x00f440),
-	REG(QSYS_PARAM_CFG_REG_2,          0x00f444),
-	REG(QSYS_PARAM_CFG_REG_3,          0x00f448),
-	REG(QSYS_PARAM_CFG_REG_4,          0x00f44c),
-	REG(QSYS_PARAM_CFG_REG_5,          0x00f450),
-	REG(QSYS_GCL_CFG_REG_1,            0x00f454),
-	REG(QSYS_GCL_CFG_REG_2,            0x00f458),
-	REG(QSYS_PARAM_STATUS_REG_1,       0x00f400),
-	REG(QSYS_PARAM_STATUS_REG_2,       0x00f404),
-	REG(QSYS_PARAM_STATUS_REG_3,       0x00f408),
-	REG(QSYS_PARAM_STATUS_REG_4,       0x00f40c),
-	REG(QSYS_PARAM_STATUS_REG_5,       0x00f410),
-	REG(QSYS_PARAM_STATUS_REG_6,       0x00f414),
-	REG(QSYS_PARAM_STATUS_REG_7,       0x00f418),
-	REG(QSYS_PARAM_STATUS_REG_8,       0x00f41c),
-	REG(QSYS_PARAM_STATUS_REG_9,       0x00f420),
-	REG(QSYS_GCL_STATUS_REG_1,         0x00f424),
-	REG(QSYS_GCL_STATUS_REG_2,         0x00f428),
-};
-
-static const u32 felix_rew_regmap[] = {
-	REG(REW_PORT_VLAN_CFG,             0x000000),
-	REG(REW_TAG_CFG,                   0x000004),
-	REG(REW_PORT_CFG,                  0x000008),
-	REG(REW_DSCP_CFG,                  0x00000c),
-	REG(REW_PCP_DEI_QOS_MAP_CFG,       0x000010),
-	REG(REW_PTP_CFG,                   0x000050),
-	REG(REW_PTP_DLY1_CFG,              0x000054),
-	REG(REW_RED_TAG_CFG,               0x000058),
-	REG(REW_DSCP_REMAP_DP1_CFG,        0x000410),
-	REG(REW_DSCP_REMAP_CFG,            0x000510),
-//	REG(REW_STAT_CFG,                  0x000610),
-//	REG(REW_REW_STICKY,                0x000614),
-//	REG(REW_PPT,                       0x000400),
-};
-
-static const u32 felix_sys_regmap[] = {
-	REG(SYS_COUNT_RX_OCTETS,	   0x000000),
-	REG(SYS_COUNT_RX_MULTICAST,	   0x000008),
-	REG(SYS_COUNT_RX_SHORTS,	   0x000010),
-	REG(SYS_COUNT_RX_FRAGMENTS,	   0x000014),
-	REG(SYS_COUNT_RX_JABBERS,	   0x000018),
-	REG(SYS_COUNT_RX_64,		   0x000024),
-	REG(SYS_COUNT_RX_65_127,	   0x000028),
-	REG(SYS_COUNT_RX_128_255,	   0x00002c),
-	REG(SYS_COUNT_RX_256_1023,	   0x000030),
-	REG(SYS_COUNT_RX_1024_1526,	   0x000034),
-	REG(SYS_COUNT_RX_1527_MAX,	   0x000038),
-	REG(SYS_COUNT_RX_LONGS,		   0x000044),
-	REG(SYS_COUNT_TX_OCTETS,	   0x000200),
-	REG(SYS_COUNT_TX_COLLISION,	   0x000210),
-	REG(SYS_COUNT_TX_DROPS,		   0x000214),
-	REG(SYS_COUNT_TX_64,		   0x00021c),
-	REG(SYS_COUNT_TX_65_127,	   0x000220),
-	REG(SYS_COUNT_TX_128_511,	   0x000224),
-	REG(SYS_COUNT_TX_512_1023,	   0x000228),
-	REG(SYS_COUNT_TX_1024_1526,	   0x00022c),
-	REG(SYS_COUNT_TX_1527_MAX,	   0x000230),
-	REG(SYS_COUNT_TX_AGING,		   0x000278),
-	REG(SYS_RESET_CFG,                 0x000e00),
-	REG(SYS_SR_ETYPE_CFG,              0x000e04),
-	REG(SYS_VLAN_ETYPE_CFG,            0x000e08),
-	REG(SYS_PORT_MODE,                 0x000e0c),
-	REG(SYS_FRONT_PORT_MODE,           0x000e2c),
-	REG(SYS_FRM_AGING,                 0x000e44),
-	REG(SYS_STAT_CFG,                  0x000e48),
-	REG(SYS_SW_STATUS,                 0x000e4c),
-//	REG(SYS_MISC_CFG,                  0x000e68),
-	REG(SYS_REW_MAC_HIGH_CFG,          0x000e6c),
-	REG(SYS_REW_MAC_LOW_CFG,           0x000e84),
-	REG(SYS_TIMESTAMP_OFFSET,          0x000e9c),
-	REG(SYS_PAUSE_CFG,                 0x000ea0),
-	REG(SYS_PAUSE_TOT_CFG,             0x000ebc),
-	REG(SYS_ATOP,                      0x000ec0),
-	REG(SYS_ATOP_TOT_CFG,              0x000edc),
-	REG(SYS_MAC_FC_CFG,                0x000ee0),
-	REG(SYS_MMGT,                      0x000ef8),
-//	REG(SYS_MMGT_FAST,                 0x000efc),
-//	REG(SYS_EVENTS_DIF,                0x000f00),
-//	REG(SYS_EVENTS_CORE,               0x000f10),
-	REG(SYS_CNT,                       0x000000),
-	REG(SYS_PTP_STATUS,                0x000f14),
-	REG(SYS_PTP_TXSTAMP,               0x000f18),
-	REG(SYS_PTP_NXT,                   0x000f1c),
-	REG(SYS_PTP_CFG,                   0x000f20),
-	REG(SYS_RAM_INIT,                  0x000f24),
-//	REG(SYS_CM_ADDR,                   0x000f28),
-//	REG(SYS_CM_DATA_WR,                0x000f2c),
-//	REG(SYS_CM_DATA_RD,                0x000f30),
-//	REG(SYS_CM_OP,                     0x000f34),
-};
-
-static const u32 felix_gcb_regmap[] = {
-	REG(GCB_SOFT_RST,		   0x000004),
-};
-
-static const u32 *felix_regmap[] = {
-	[ANA] = felix_ana_regmap,
-	[QS] = felix_qs_regmap,
-	[QSYS] = felix_qsys_regmap,
-	[REW] = felix_rew_regmap,
-	[SYS] = felix_sys_regmap,
-	[PTP] = felix_ptp_regmap,
-	[GCB] = felix_gcb_regmap,
-};
-
-static const struct reg_field felix_regfields[] = {
-	[ANA_ADVLEARN_VLAN_CHK] = REG_FIELD(ANA_ADVLEARN, 6, 6),
-	[ANA_ADVLEARN_LEARN_MIRROR] = REG_FIELD(ANA_ADVLEARN, 0, 5),
-	[ANA_ANEVENTS_FLOOD_DISCARD] = REG_FIELD(ANA_ANEVENTS, 30, 30),
-	[ANA_ANEVENTS_AUTOAGE] = REG_FIELD(ANA_ANEVENTS, 26, 26),
-	[ANA_ANEVENTS_STORM_DROP] = REG_FIELD(ANA_ANEVENTS, 24, 24),
-	[ANA_ANEVENTS_LEARN_DROP] = REG_FIELD(ANA_ANEVENTS, 23, 23),
-	[ANA_ANEVENTS_AGED_ENTRY] = REG_FIELD(ANA_ANEVENTS, 22, 22),
-	[ANA_ANEVENTS_CPU_LEARN_FAILED] = REG_FIELD(ANA_ANEVENTS, 21, 21),
-	[ANA_ANEVENTS_AUTO_LEARN_FAILED] = REG_FIELD(ANA_ANEVENTS, 20, 20),
-	[ANA_ANEVENTS_LEARN_REMOVE] = REG_FIELD(ANA_ANEVENTS, 19, 19),
-	[ANA_ANEVENTS_AUTO_LEARNED] = REG_FIELD(ANA_ANEVENTS, 18, 18),
-	[ANA_ANEVENTS_AUTO_MOVED] = REG_FIELD(ANA_ANEVENTS, 17, 17),
-	[ANA_ANEVENTS_CLASSIFIED_DROP] = REG_FIELD(ANA_ANEVENTS, 15, 15),
-	[ANA_ANEVENTS_CLASSIFIED_COPY] = REG_FIELD(ANA_ANEVENTS, 14, 14),
-	[ANA_ANEVENTS_VLAN_DISCARD] = REG_FIELD(ANA_ANEVENTS, 13, 13),
-	[ANA_ANEVENTS_FWD_DISCARD] = REG_FIELD(ANA_ANEVENTS, 12, 12),
-	[ANA_ANEVENTS_MULTICAST_FLOOD] = REG_FIELD(ANA_ANEVENTS, 11, 11),
-	[ANA_ANEVENTS_UNICAST_FLOOD] = REG_FIELD(ANA_ANEVENTS, 10, 10),
-	[ANA_ANEVENTS_DEST_KNOWN] = REG_FIELD(ANA_ANEVENTS, 9, 9),
-	[ANA_ANEVENTS_BUCKET3_MATCH] = REG_FIELD(ANA_ANEVENTS, 8, 8),
-	[ANA_ANEVENTS_BUCKET2_MATCH] = REG_FIELD(ANA_ANEVENTS, 7, 7),
-	[ANA_ANEVENTS_BUCKET1_MATCH] = REG_FIELD(ANA_ANEVENTS, 6, 6),
-	[ANA_ANEVENTS_BUCKET0_MATCH] = REG_FIELD(ANA_ANEVENTS, 5, 5),
-	[ANA_ANEVENTS_CPU_OPERATION] = REG_FIELD(ANA_ANEVENTS, 4, 4),
-	[ANA_ANEVENTS_DMAC_LOOKUP] = REG_FIELD(ANA_ANEVENTS, 3, 3),
-	[ANA_ANEVENTS_SMAC_LOOKUP] = REG_FIELD(ANA_ANEVENTS, 2, 2),
-	[ANA_ANEVENTS_SEQ_GEN_ERR_0] = REG_FIELD(ANA_ANEVENTS, 1, 1),
-	[ANA_ANEVENTS_SEQ_GEN_ERR_1] = REG_FIELD(ANA_ANEVENTS, 0, 0),
-	[ANA_TABLES_MACACCESS_B_DOM] = REG_FIELD(ANA_TABLES_MACACCESS, 16, 16),
-	[ANA_TABLES_MACTINDX_BUCKET] = REG_FIELD(ANA_TABLES_MACTINDX, 11, 12),
-	[ANA_TABLES_MACTINDX_M_INDEX] = REG_FIELD(ANA_TABLES_MACTINDX, 0, 10),
-	[PTP_MISC_CFG_ENA] = REG_FIELD(PTP_MISC_CFG, 2, 2),
-	[PTP_SYS_CLK_CFG_PER_NS] = REG_FIELD(PTP_SYS_CLK_CFG, 4, 8),
-	[PTP_SYS_CLK_CFG_PER_PS100] = REG_FIELD(PTP_SYS_CLK_CFG, 0, 3),
-	[QSYS_TIMED_FRAME_ENTRY_TFRM_VLD] =
-		REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 19, 19),
-	[QSYS_TIMED_FRAME_ENTRY_TFRM_FP] =
-		REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 7, 18),
-	[QSYS_TIMED_FRAME_ENTRY_TFRM_PORTNO] =
-		REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 4, 6),
-	[QSYS_TIMED_FRAME_ENTRY_TFRM_TM_SEL] =
-		REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 1, 3),
-	[QSYS_TIMED_FRAME_ENTRY_TFRM_TM_T] =
-		REG_FIELD(QSYS_TIMED_FRAME_ENTRY, 0, 0),
-	[SYS_RESET_CFG_CORE_ENA] = REG_FIELD(SYS_RESET_CFG, 0, 0),
-	[SYS_RESET_CFG_MEM_ENA] = REG_FIELD(SYS_RESET_CFG, 1, 1),
-	[SYS_RESET_CFG_MEM_INIT] = REG_FIELD(SYS_RESET_CFG, 0, 0),
-	[ANA_TABLES_STREAMDATA_SFID_0] =
-		REG_FIELD(ANA_TABLES_STREAMDATA, 0, 7),
-	[ANA_TABLES_STREAMDATA_SFID_VALID_0] =
-		REG_FIELD(ANA_TABLES_STREAMDATA, 8, 8),
-	[ANA_TABLES_SFIDTIDX_SFID_INDEX_0] =
-		REG_FIELD(ANA_TABLES_SFIDTIDX, 0, 7),
-	[ANA_SG_ACCESS_CTRL_CONFIG_CHANGE_0] =
-		REG_FIELD(ANA_SG_ACCESS_CTRL, 28, 28),
-	[ANA_SG_ACCESS_CTRL_SGID_0] =
-		REG_FIELD(ANA_SG_ACCESS_CTRL, 0, 7),
-	[ANA_SG_CONFIG_REG_3_GATE_ENABLE_0] =
-		REG_FIELD(ANA_SG_CONFIG_REG_3, 20, 20),
-	[QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0] =
-		REG_FIELD(QSYS_TAS_PARAM_CFG_CTRL, 0, 7),
-	[QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM_0] =
-		REG_FIELD(QSYS_GCL_STATUS_REG_1, 0, 5),
-	[QSYS_GCL_CFG_REG_1_GATE_STATE_0] =
-		REG_FIELD(QSYS_GCL_CFG_REG_1, 8, 15),
-	[QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM_0] =
-		REG_FIELD(QSYS_GCL_CFG_REG_1, 0, 5),
-	[QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE_0] =
-		REG_FIELD(QSYS_TAS_PARAM_CFG_CTRL, 16, 16),
-	[QSYS_TAG_CONFIG_ENABLE_0] = REG_FIELD(QSYS_TAG_CONFIG, 0, 0),
-	[SYS_STAT_CFG_STAT_VIEW_0] = REG_FIELD(SYS_STAT_CFG, 0, 9),
-	[GCB_SOFT_RST_SWC_RST] = REG_FIELD(GCB_SOFT_RST, 0, 0),
-};
-
-static const struct ocelot_stat_layout felix_stats_layout[] = {
-	{ .name = "rx_octets", .offset = 0x00, },
-	{ .name = "rx_unicast", .offset = 0x01, },
-	{ .name = "rx_multicast", .offset = 0x02, },
-	{ .name = "rx_broadcast", .offset = 0x03, },
-	{ .name = "rx_shorts", .offset = 0x04, },
-	{ .name = "rx_fragments", .offset = 0x05, },
-	{ .name = "rx_jabbers", .offset = 0x06, },
-	{ .name = "rx_crc_align_errs", .offset = 0x07, },
-	{ .name = "rx_sym_errs", .offset = 0x08, },
-	{ .name = "rx_frames_below_65_octets", .offset = 0x09, },
-	{ .name = "rx_frames_65_to_127_octets", .offset = 0x0A, },
-	{ .name = "rx_frames_128_to_255_octets", .offset = 0x0B, },
-	{ .name = "rx_frames_256_to_511_octets", .offset = 0x0C, },
-	{ .name = "rx_frames_512_to_1023_octets", .offset = 0x0D, },
-	{ .name = "rx_frames_1024_to_1526_octets", .offset = 0x0E, },
-	{ .name = "rx_frames_over_1526_octets", .offset = 0x0F, },
-	{ .name = "rx_pause", .offset = 0x10, },
-	{ .name = "rx_control", .offset = 0x11, },
-	{ .name = "rx_longs", .offset = 0x12, },
-	{ .name = "rx_classified_drops", .offset = 0x13, },
-	{ .name = "rx_red_prio_0", .offset = 0x14, },
-	{ .name = "rx_red_prio_1", .offset = 0x15, },
-	{ .name = "rx_red_prio_2", .offset = 0x16, },
-	{ .name = "rx_red_prio_3", .offset = 0x17, },
-	{ .name = "rx_red_prio_4", .offset = 0x18, },
-	{ .name = "rx_red_prio_5", .offset = 0x19, },
-	{ .name = "rx_red_prio_6", .offset = 0x1A, },
-	{ .name = "rx_red_prio_7", .offset = 0x1B, },
-	{ .name = "rx_yellow_prio_0", .offset = 0x1C, },
-	{ .name = "rx_yellow_prio_1", .offset = 0x1D, },
-	{ .name = "rx_yellow_prio_2", .offset = 0x1E, },
-	{ .name = "rx_yellow_prio_3", .offset = 0x1F, },
-	{ .name = "rx_yellow_prio_4", .offset = 0x20, },
-	{ .name = "rx_yellow_prio_5", .offset = 0x21, },
-	{ .name = "rx_yellow_prio_6", .offset = 0x22, },
-	{ .name = "rx_yellow_prio_7", .offset = 0x23, },
-	{ .name = "rx_green_prio_0", .offset = 0x24, },
-	{ .name = "rx_green_prio_1", .offset = 0x25, },
-	{ .name = "rx_green_prio_2", .offset = 0x26, },
-	{ .name = "rx_green_prio_3", .offset = 0x27, },
-	{ .name = "rx_green_prio_4", .offset = 0x28, },
-	{ .name = "rx_green_prio_5", .offset = 0x29, },
-	{ .name = "rx_green_prio_6", .offset = 0x2A, },
-	{ .name = "rx_green_prio_7", .offset = 0x2B, },
-	{ .name = "tx_octets", .offset = 0x80, },
-	{ .name = "tx_unicast", .offset = 0x81, },
-	{ .name = "tx_multicast", .offset = 0x82, },
-	{ .name = "tx_broadcast", .offset = 0x83, },
-	{ .name = "tx_collision", .offset = 0x84, },
-	{ .name = "tx_drops", .offset = 0x85, },
-	{ .name = "tx_pause", .offset = 0x86, },
-	{ .name = "tx_frames_below_65_octets", .offset = 0x87, },
-	{ .name = "tx_frames_65_to_127_octets", .offset = 0x88, },
-	{ .name = "tx_frames_128_255_octets", .offset = 0x89, },
-	{ .name = "tx_frames_256_511_octets", .offset = 0x8A, },
-	{ .name = "tx_frames_512_1023_octets", .offset = 0x8B, },
-	{ .name = "tx_frames_1024_1526_octets", .offset = 0x8C, },
-	{ .name = "tx_frames_over_1526_octets", .offset = 0x8D, },
-	{ .name = "tx_yellow_prio_0", .offset = 0x8E, },
-	{ .name = "tx_yellow_prio_1", .offset = 0x8F, },
-	{ .name = "tx_yellow_prio_2", .offset = 0x90, },
-	{ .name = "tx_yellow_prio_3", .offset = 0x91, },
-	{ .name = "tx_yellow_prio_4", .offset = 0x92, },
-	{ .name = "tx_yellow_prio_5", .offset = 0x93, },
-	{ .name = "tx_yellow_prio_6", .offset = 0x94, },
-	{ .name = "tx_yellow_prio_7", .offset = 0x95, },
-	{ .name = "tx_green_prio_0", .offset = 0x96, },
-	{ .name = "tx_green_prio_1", .offset = 0x97, },
-	{ .name = "tx_green_prio_2", .offset = 0x98, },
-	{ .name = "tx_green_prio_3", .offset = 0x99, },
-	{ .name = "tx_green_prio_4", .offset = 0x9A, },
-	{ .name = "tx_green_prio_5", .offset = 0x9B, },
-	{ .name = "tx_green_prio_6", .offset = 0x9C, },
-	{ .name = "tx_green_prio_7", .offset = 0x9D, },
-	{ .name = "tx_aged", .offset = 0x9E, },
-	{ .name = "drop_local", .offset = 0x100, },
-	{ .name = "drop_tail", .offset = 0x101, },
-	{ .name = "drop_yellow_prio_0", .offset = 0x102, },
-	{ .name = "drop_yellow_prio_1", .offset = 0x103, },
-	{ .name = "drop_yellow_prio_2", .offset = 0x104, },
-	{ .name = "drop_yellow_prio_3", .offset = 0x105, },
-	{ .name = "drop_yellow_prio_4", .offset = 0x106, },
-	{ .name = "drop_yellow_prio_5", .offset = 0x107, },
-	{ .name = "drop_yellow_prio_6", .offset = 0x108, },
-	{ .name = "drop_yellow_prio_7", .offset = 0x109, },
-	{ .name = "drop_green_prio_0", .offset = 0x10A, },
-	{ .name = "drop_green_prio_1", .offset = 0x10B, },
-	{ .name = "drop_green_prio_2", .offset = 0x10C, },
-	{ .name = "drop_green_prio_3", .offset = 0x10D, },
-	{ .name = "drop_green_prio_4", .offset = 0x10E, },
-	{ .name = "drop_green_prio_5", .offset = 0x10F, },
-	{ .name = "drop_green_prio_6", .offset = 0x110, },
-	{ .name = "drop_green_prio_7", .offset = 0x111, },
-};
-
-/* FIXME this is duplicated */
-/* Watermark encode
- * Bit 8:   Unit; 0:1, 1:16
- * Bit 7-0: Value to be multiplied with unit
- */
-static u16 ocelot_wm_enc(u16 value)
-{
-	if (value >= BIT(8))
-		return BIT(8) | (value / 16);
-
-	return value;
-}
-
-void felix_port_adjust_link(struct net_device *dev)
-{
-	struct ocelot_port *port = netdev_priv(dev);
-	struct ocelot *ocelot = port->ocelot;
-	u8 p = port->chip_port;
-	int speed, atop_wm;
-
-	switch (dev->phydev->speed) {
-	case SPEED_10:
-		speed = OCELOT_SPEED_10;
-		break;
-	case SPEED_100:
-		speed = OCELOT_SPEED_100;
-		break;
-	case SPEED_1000:
-		speed = OCELOT_SPEED_1000;
-		break;
-	case SPEED_2500:
-		speed = OCELOT_SPEED_2500;
-		break;
-	default:
-		netdev_err(dev, "Unsupported PHY speed: %d\n",
-			   dev->phydev->speed);
-		return;
-	}
-
-	phy_print_status(dev->phydev);
-
-	if (!dev->phydev->link)
-		return;
-
-	/* Set MAC IFG Gaps
-	 * FDX: TX_IFG = 5, RX_IFG1 = RX_IFG2 = 0
-	 * !FDX: TX_IFG = 5, RX_IFG1 = RX_IFG2 = 5
-	 */
-	ocelot_port_writel(port, DEV_MAC_IFG_CFG_TX_IFG(5), DEV_MAC_IFG_CFG);
-
-	/* Load seed (0) and set MAC HDX late collision  */
-	ocelot_port_writel(port, DEV_MAC_HDX_CFG_LATE_COL_POS(67) |
-			   DEV_MAC_HDX_CFG_SEED_LOAD,
-			   DEV_MAC_HDX_CFG);
-	mdelay(1);
-	ocelot_port_writel(port, DEV_MAC_HDX_CFG_LATE_COL_POS(67),
-			   DEV_MAC_HDX_CFG);
-
-	/* Set Max Length and maximum tags allowed */
-	ocelot_port_writel(port, VLAN_ETH_FRAME_LEN, DEV_MAC_MAXLEN_CFG);
-	ocelot_port_writel(port, DEV_MAC_TAGS_CFG_TAG_ID(ETH_P_8021AD) |
-			   DEV_MAC_TAGS_CFG_VLAN_AWR_ENA |
-			   DEV_MAC_TAGS_CFG_VLAN_LEN_AWR_ENA,
-			   DEV_MAC_TAGS_CFG);
-
-	/* Enable MAC module */
-	ocelot_port_writel(port, DEV_MAC_ENA_CFG_RX_ENA |
-			   DEV_MAC_ENA_CFG_TX_ENA, DEV_MAC_ENA_CFG);
-
-	/* Set SMAC of Pause frame (00:00:00:00:00:00) */
-	ocelot_port_writel(port, 0, DEV_MAC_FC_MAC_HIGH_CFG);
-	ocelot_port_writel(port, 0, DEV_MAC_FC_MAC_LOW_CFG);
-
-	/* No PFC */
-	ocelot_write_gix(ocelot, ANA_PFC_PFC_CFG_FC_LINK_SPEED(speed),
-			 ANA_PFC_PFC_CFG, p);
-
-	/* Set Pause WM hysteresis
-	 * 152 = 6 * VLAN_ETH_FRAME_LEN / OCELOT_BUFFER_CELL_SZ
-	 * 101 = 4 * VLAN_ETH_FRAME_LEN / OCELOT_BUFFER_CELL_SZ
-	 */
-	ocelot_write_rix(ocelot, SYS_PAUSE_CFG_PAUSE_ENA |
-			 SYS_PAUSE_CFG_PAUSE_STOP(101) |
-			 SYS_PAUSE_CFG_PAUSE_START(152), SYS_PAUSE_CFG, p);
-
-	/* Core: Enable port for frame transfer */
-	ocelot_write_rix(ocelot, QSYS_SWITCH_PORT_MODE_INGRESS_DROP_MODE |
-			 QSYS_SWITCH_PORT_MODE_SCH_NEXT_CFG(1) |
-			 QSYS_SWITCH_PORT_MODE_PORT_ENA,
-			 QSYS_SWITCH_PORT_MODE, p);
-
-	/* Flow control */
-	ocelot_write_rix(ocelot, SYS_MAC_FC_CFG_PAUSE_VAL_CFG(0xffff) |
-			 SYS_MAC_FC_CFG_RX_FC_ENA | SYS_MAC_FC_CFG_TX_FC_ENA |
-			 SYS_MAC_FC_CFG_ZERO_PAUSE_ENA |
-			 SYS_MAC_FC_CFG_FC_LATENCY_CFG(0x7) |
-			 SYS_MAC_FC_CFG_FC_LINK_SPEED(speed),
-			 SYS_MAC_FC_CFG, p);
-	ocelot_write_rix(ocelot, 0, ANA_POL_FLOWC, p);
-
-	/* Tail dropping watermark */
-	atop_wm = ocelot->shared_queue_sz - 9 * VLAN_ETH_FRAME_LEN;
-	atop_wm /= OCELOT_BUFFER_CELL_SZ;
-	ocelot_write_rix(ocelot, ocelot_wm_enc(9 * VLAN_ETH_FRAME_LEN),
-			 SYS_ATOP, p);
-	ocelot_write(ocelot, ocelot_wm_enc(atop_wm), SYS_ATOP_TOT_CFG);
-}
-
-int felix_chip_init(struct ocelot *ocelot)
-{
-	int ret;
-
-	ocelot->map = felix_regmap;
-	ocelot->stats_layout = felix_stats_layout;
-	ocelot->num_stats = ARRAY_SIZE(felix_stats_layout);
-	ocelot->shared_queue_sz = 128 * 1024;
-	ocelot->port_adjust_link = &felix_port_adjust_link;
-
-	ret = ocelot_regfields_init(ocelot, felix_regfields);
-	if (ret) {
-		dev_err(ocelot->dev, "failed to init reg fields map\n");
-		return ret;
-	}
-
-	eth_random_addr(ocelot->base_mac);
-	ocelot->base_mac[5] &= 0xf0;
-	return 0;
-}
-EXPORT_SYMBOL(felix_chip_init);
diff --git a/drivers/net/ethernet/mscc/felix_tsn.c b/drivers/net/ethernet/mscc/felix_tsn.c
deleted file mode 100644
index bc2caa9228fb..000000000000
--- a/drivers/net/ethernet/mscc/felix_tsn.c
+++ /dev/null
@@ -1,1601 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Felix Switch TSN driver
- *
- * Copyright 2018-2019 NXP
- */
-
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/sys_soc.h>
-#include <linux/clk.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/phy.h>
-#include <linux/iopoll.h>
-#include "ocelot.h"
-#include "felix_tsn.h"
-
-#define MSCC_NUM_OUT_PORT 4 /* Number of physical output ports */
-#define SE_IX_PORT 64
-
-/* MSCC TSN parameters limited */
-#define NUM_MSCC_QOS_PRIO 8
-#define MSCC_PSFP_SFID_NUM 176
-#define MSCC_FRER_SSID_NUM 128
-
-/* Using the max number of MSCC_PSFP_SFID_NUM and MSCC_FRER_SSID_NUM */
-#define MSCC_STREAM_HANDLE_NUM	MSCC_PSFP_SFID_NUM
-
-int streamhandle_map[MSCC_STREAM_HANDLE_NUM] = {0};
-static struct mscc_switch_capa capa __ro_after_init = {
-	.num_tas_gcl	= 64,
-	.tas_ct_min	= 100,
-	.tas_ct_max	= 1000000000,
-	.tas_cte_max	= 999999999,
-	.tas_it_max	= 999999999,
-	.tas_it_min	= 1000,
-	.num_hsch	= 72,
-	.num_psfp_sfid	= MSCC_PSFP_SFID_NUM,
-	.num_psfp_sgid	= 184,
-	.psfp_fmi_max	= 246,
-	.psfp_fmi_min	= 63,
-	.num_sgi_gcl	= 4,
-	.sgi_ct_min	= 5000,
-	.sgi_ct_max	= 1000000000,
-	.sgi_cte_max	= 999999999,
-	.qos_pol_max	= 383,
-	/* Maximum allowed value of committed burst size(CBS) is 240 KB */
-	.pol_cbs_max	= 60,
-	/* Maximum allowed value of excess burst size(EBS) is 240 KB */
-	.pol_pbs_max	= 60,
-	.num_frer_ssid  = MSCC_FRER_SSID_NUM,
-	.frer_seq_len_min = 1,
-	.frer_seq_len_max = 28,
-	.frer_his_len_min = 1,
-	.frer_his_len_max = 32,
-	.qos_dscp_max	= 63,
-	.qos_cos_max	= NUM_MSCC_QOS_PRIO - 1,
-	.qos_dp_max	= 1,
-};
-
-static int qos_port_tas_gcl_set(struct net_device *ndev,
-				struct ocelot *ocelot, const u8 gcl_ix,
-				struct tsn_qbv_entry *control_list)
-{
-	if (gcl_ix >= capa.num_tas_gcl) {
-		netdev_info(ndev, "Invalid gcl ix %u\n", gcl_ix);
-		return -EINVAL;
-	}
-	if (control_list->time_interval < capa.tas_it_min ||
-	    control_list->time_interval > capa.tas_it_max) {
-		netdev_info(ndev, "Invalid time_interval %u\n",
-			    control_list->time_interval);
-
-		return -EINVAL;
-	}
-
-	ocelot_write(ocelot,
-		     QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM(gcl_ix) |
-		     QSYS_GCL_CFG_REG_1_GATE_STATE(control_list->gate_state),
-		     QSYS_GCL_CFG_REG_1);
-
-	ocelot_write(ocelot,
-		     control_list->time_interval,
-		     QSYS_GCL_CFG_REG_2);
-
-	return 0;
-}
-
-static u32 tas_read_status(struct ocelot *ocelot)
-{
-	u32 val;
-
-	val = ocelot_read(ocelot, QSYS_TAS_PARAM_CFG_CTRL);
-
-	return val;
-}
-
-int felix_qbv_set(struct net_device *ndev,
-		  struct tsn_qbv_conf *shaper_config)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	struct tsn_qbv_basic *admin_basic = &shaper_config->admin;
-	struct tsn_qbv_entry *control_list = admin_basic->control_list;
-	u32 base_time_nsec = admin_basic->base_time % 1000000000;
-	u64 base_time_sec = admin_basic->base_time / 1000000000;
-	u64 cur_time;
-	u32 val;
-	u8 speed;
-	int i;
-	int ret;
-
-	if (admin_basic->control_list_length > capa.num_tas_gcl) {
-		netdev_info(ndev, "Invalid admin_control_list_length %u\n",
-			    admin_basic->control_list_length);
-		return -EINVAL;
-	}
-
-	if ((admin_basic->cycle_time < capa.tas_ct_min ||
-	     admin_basic->cycle_time > capa.tas_ct_max) &&
-	    shaper_config->gate_enabled) {
-		netdev_info(ndev, "Invalid admin_cycle_time %u ns\n",
-			    admin_basic->cycle_time);
-		return -EINVAL;
-	}
-	if (admin_basic->cycle_time_extension > capa.tas_cte_max) {
-		netdev_info(ndev,
-			    "Invalid admin_cycle_time_extension %u\n",
-			    admin_basic->cycle_time_extension);
-		return -EINVAL;
-	}
-
-	cur_time = ocelot_read(ocelot, PTP_CUR_SEC_MSB);
-	cur_time = cur_time << 32;
-	cur_time += ocelot_read(ocelot, PTP_CUR_SEC_LSB);
-
-	if (base_time_sec < cur_time) {
-		base_time_sec = cur_time;
-		base_time_nsec = ocelot_read(ocelot, PTP_CUR_NSEC);
-	}
-
-	/* Select port */
-	ocelot_rmw(ocelot,
-		   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM(port->chip_port),
-		   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_M,
-		   QSYS_TAS_PARAM_CFG_CTRL);
-
-	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);
-	if (val & QSYS_PARAM_STATUS_REG_8_CONFIG_PENDING) {
-		ocelot_rmw_rix(ocelot, 0, QSYS_TAG_CONFIG_ENABLE,
-			       QSYS_TAG_CONFIG, port->chip_port);
-	}
-
-	if (!shaper_config->gate_enabled)
-		admin_basic->gate_states = 0xff;
-
-	speed = OCELOT_SPEED_1000;
-	if (ndev->phydev) {
-		switch (ndev->phydev->speed) {
-		case SPEED_10:
-			speed = OCELOT_SPEED_10;
-			break;
-		case SPEED_100:
-			speed = OCELOT_SPEED_100;
-			break;
-		case SPEED_1000:
-			speed = OCELOT_SPEED_1000;
-			break;
-		case SPEED_2500:
-			speed = OCELOT_SPEED_2500;
-			break;
-		}
-	}
-
-	ocelot_rmw_rix(ocelot,
-		       (shaper_config->gate_enabled ?
-			QSYS_TAG_CONFIG_ENABLE : 0) |
-		       QSYS_TAG_CONFIG_INIT_GATE_STATE(admin_basic->gate_states) |
-		       QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES(0xff) |
-		       QSYS_TAG_CONFIG_LINK_SPEED(speed),
-		       QSYS_TAG_CONFIG_ENABLE |
-		       QSYS_TAG_CONFIG_INIT_GATE_STATE_M |
-		       QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES_M |
-		       QSYS_TAG_CONFIG_LINK_SPEED_M,
-		       QSYS_TAG_CONFIG,
-		       port->chip_port);
-
-	ocelot_write_rix(ocelot, shaper_config->maxsdu,
-			 QSYS_PORT_MAX_SDU, port->chip_port);
-	/* TODO: add queue max SDU set */
-
-	if (shaper_config->gate_enabled) {
-		ocelot_write(ocelot, base_time_nsec,
-			     QSYS_PARAM_CFG_REG_1);
-
-		ocelot_write(ocelot, base_time_sec & GENMASK(31, 0),
-			     QSYS_PARAM_CFG_REG_2);
-
-		ocelot_write(ocelot,
-			     QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(base_time_sec >> 32) |
-			     QSYS_PARAM_CFG_REG_3_LIST_LENGTH(admin_basic->control_list_length),
-			     QSYS_PARAM_CFG_REG_3);
-
-		ocelot_write(ocelot, admin_basic->cycle_time,
-			     QSYS_PARAM_CFG_REG_4);
-
-		ocelot_write(ocelot, admin_basic->cycle_time_extension,
-			     QSYS_PARAM_CFG_REG_5);
-
-		for (i = 0; i < admin_basic->control_list_length; i++) {
-			qos_port_tas_gcl_set(ndev, ocelot, i, control_list);
-			control_list++;
-		}
-
-		/* Start configuration change */
-		ocelot_rmw(ocelot,
-			   QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,
-			   QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,
-			   QSYS_TAS_PARAM_CFG_CTRL);
-
-		ret = readx_poll_timeout(tas_read_status, ocelot, val,
-					 !(QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE
-					 & val), 10, 100000);
-		return ret;
-	}
-
-	return 0;
-}
-
-int felix_qbv_get(struct net_device *ndev,
-		  struct tsn_qbv_conf *shaper_config)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 val, reg;
-	int i;
-	u8 p_num = port->chip_port;
-	u32 base_timel;
-	u32 base_timeh;
-	struct tsn_qbv_basic *admin = &shaper_config->admin;
-	struct tsn_qbv_entry *list;
-
-	ocelot_field_write(ocelot,
-			   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0, p_num);
-
-	val = ocelot_read(ocelot, QSYS_TAG_CONFIG);
-	shaper_config->gate_enabled = (val & QSYS_TAG_CONFIG_ENABLE);
-	admin->gate_states = QSYS_TAG_CONFIG_INIT_GATE_STATE_X(val);
-
-	base_timel = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_1);
-	base_timeh = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_2);
-	reg = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_3);
-	admin->base_time = base_timeh |
-		(((u64)QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(reg)) << 32);
-
-	admin->base_time = (admin->base_time * 1000000000) + base_timel;
-
-	admin->control_list_length =
-		QSYS_PARAM_CFG_REG_3_LIST_LENGTH_X(reg);
-
-	admin->cycle_time = ocelot_read(ocelot, QSYS_PARAM_CFG_REG_4);
-	admin->cycle_time_extension =
-		ocelot_read(ocelot, QSYS_PARAM_CFG_REG_5);
-
-	list = kmalloc_array(admin->control_list_length,
-			     sizeof(struct tsn_qbv_entry), GFP_KERNEL);
-	admin->control_list = list;
-
-	for (i = 0; i < admin->control_list_length; i++) {
-		ocelot_field_write(ocelot,
-				   QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM_0, i);
-		list->time_interval =
-			ocelot_read(ocelot, QSYS_GCL_CFG_REG_2);
-
-		reg = ocelot_read(ocelot, QSYS_GCL_CFG_REG_1);
-		list->gate_state = QSYS_GCL_CFG_REG_1_GATE_STATE_X(reg);
-
-		list++;
-	}
-
-	return 0;
-}
-
-static int qbv_get_gatelist(struct ocelot *ocelot,
-			    struct tsn_qbv_basic *oper)
-{
-	u32 base_timel;
-	u32 base_timeh;
-	u32 val;
-	struct tsn_qbv_entry *glist;
-	int i;
-
-	base_timel = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_1);
-	base_timeh = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_2);
-	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_3);
-	oper->base_time = base_timeh;
-	oper->base_time +=
-		((u64)QSYS_PARAM_STATUS_REG_3_BASE_TIME_SEC_MSB(val)) <<
-		32;
-	oper->base_time = (oper->base_time * 1000000000) + base_timel;
-
-	oper->control_list_length =
-		QSYS_PARAM_STATUS_REG_3_LIST_LENGTH_X(val);
-
-	oper->cycle_time = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_4);
-	oper->cycle_time_extension = ocelot_read(ocelot,
-						 QSYS_PARAM_STATUS_REG_5);
-
-	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);
-	oper->gate_states = QSYS_PARAM_STATUS_REG_8_OPER_GATE_STATE_X(val);
-
-	glist = kmalloc_array(oper->control_list_length,
-			      sizeof(struct tsn_qbv_entry), GFP_KERNEL);
-
-	oper->control_list = glist;
-
-	for (i = 0; i < oper->control_list_length; i++) {
-		ocelot_field_write(ocelot,
-				   QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM_0,
-				   i);
-
-		val = ocelot_read(ocelot, QSYS_GCL_STATUS_REG_2);
-		glist->time_interval = val;
-		val = ocelot_read(ocelot, QSYS_GCL_STATUS_REG_1);
-		glist->gate_state =
-			QSYS_GCL_STATUS_REG_1_GATE_STATE_X(val);
-
-		glist++;
-	}
-
-	return 0;
-}
-
-int felix_qbv_get_status(struct net_device *ndev,
-			 struct tsn_qbv_status *qbvstatus)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	struct tsn_qbv_basic *oper = &qbvstatus->oper;
-	u8 p_num = port->chip_port;
-	u32 val;
-	ptptime_t cur_time;
-
-	ocelot_field_write(ocelot,
-			   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_0,
-			   p_num);
-
-	qbvstatus->supported_list_max = capa.num_tas_gcl;
-
-	val = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);
-	qbvstatus->config_pending =
-		(val & QSYS_PARAM_STATUS_REG_8_CONFIG_PENDING);
-
-	qbvstatus->config_change_time =
-		ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_7);
-
-	qbvstatus->config_change_time +=
-		((u64)QSYS_PARAM_STATUS_REG_8_CFG_CHG_TIME_SEC_MSB(val)) <<
-		32;
-
-	qbvstatus->config_change_time =
-		(qbvstatus->config_change_time * 1000000000) +
-		ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_6);
-
-	qbvstatus->config_change_error =
-		ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_9);
-
-	cur_time = ocelot_read(ocelot, PTP_CUR_SEC_MSB);
-	cur_time = cur_time << 32;
-	cur_time += ocelot_read(ocelot, PTP_CUR_SEC_LSB);
-	cur_time = (cur_time * 1000000000) +
-		   ocelot_read(ocelot, PTP_CUR_NSEC);
-
-	qbvstatus->current_time = cur_time;
-	qbv_get_gatelist(ocelot, oper);
-
-	return 0;
-}
-
-int felix_cut_thru_set(struct net_device *ndev, u8 cut_thru)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-
-	ocelot_write_rix(ocelot, cut_thru, ANA_CUT_THRU_CFG,
-			 ocelot_port->chip_port);
-
-	return 0;
-}
-
-static int qos_shaper_conf_set(struct net_device *ndev, u32 port_ix,
-			       u8 percent)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-	u32 cbs = 0;
-	u32 cir = 0;
-
-	if (percent > 100) {
-		netdev_info(ndev, "percentage %d larger than 100\n",
-			    percent);
-		return -EINVAL;
-	}
-	if (port_ix >= capa.num_hsch) {
-		netdev_info(ndev,
-			    "CIR_CFG: id %d is exceed num of HSCH instance\n",
-			    port_ix);
-		return -EINVAL;
-	}
-
-	if (ndev->phydev) {
-		switch (ndev->phydev->speed) {
-		case SPEED_10:
-			cir = 10000;
-			break;
-		case SPEED_100:
-			cir = 100000;
-			break;
-		case SPEED_1000:
-			cir = 1000000;
-			break;
-		case SPEED_2500:
-			cir = 2500000;
-			break;
-		}
-	} else {
-		cir = 1000000;
-	}
-
-	cir = cir * percent / 100;
-	cir = DIV_ROUND_UP(cir, 100);  /* Rate unit is 100 kbps */
-	cir = (cir ? cir : 1);              /* Avoid using zero rate */
-	cbs = DIV_ROUND_UP(cbs, 4096); /* Burst unit is 4kB */
-	cbs = (cbs ? cbs : 1);		/* Avoid using zero burst size */
-	cir = min_t(u32, GENMASK(15, 0), cir);
-	cbs = min_t(u32, GENMASK(6, 0), cbs);
-	ocelot_write_gix(ocelot,
-			 QSYS_CIR_CFG_CIR_RATE(cir) |
-			 QSYS_CIR_CFG_CIR_BURST(cbs),
-			 QSYS_CIR_CFG,
-			 port_ix);
-
-	return 0;
-}
-
-static int qos_shaper_conf_get(struct net_device *ndev, u32 port_ix)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-	u32 val;
-	u32 bandwidth = 0;
-	u32 cir = 0;
-	int percentage;
-
-	if (port_ix >= capa.num_hsch) {
-		netdev_info(ndev,
-			    "CIR_CFG: id %d is exceed num of HSCH instance\n",
-			    port_ix);
-		return -EINVAL;
-	}
-
-	if (ndev->phydev) {
-		switch (ndev->phydev->speed) {
-		case SPEED_10:
-			bandwidth = 10000;
-			break;
-		case SPEED_100:
-			bandwidth = 100000;
-			break;
-		case SPEED_1000:
-			bandwidth = 1000000;
-			break;
-		case SPEED_2500:
-			bandwidth = 2500000;
-			break;
-		}
-	} else {
-		bandwidth = 1000000;
-	}
-
-	val = ocelot_read_gix(ocelot, QSYS_CIR_CFG, port_ix);
-
-	cir = QSYS_CIR_CFG_CIR_RATE_X(val);
-	cir *= 100;
-	percentage = cir * 100 / bandwidth;
-
-	return percentage;
-}
-
-int felix_cbs_set(struct net_device *ndev, u8 tc, u8 bw)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-
-	if (tc > capa.qos_cos_max) {
-		netdev_info(ndev, "Invalid tc: %u\n", tc);
-		return -EINVAL;
-	}
-
-	qos_shaper_conf_set(ndev, ocelot_port->chip_port * 8 + tc, bw);
-
-	ocelot_rmw_gix(ocelot,
-		       QSYS_SE_CFG_SE_AVB_ENA,
-		       QSYS_SE_CFG_SE_AVB_ENA,
-		       QSYS_SE_CFG,
-		       ocelot_port->chip_port * 8 + tc);
-
-	return 0;
-}
-
-int felix_cbs_get(struct net_device *ndev, u8 tc)
-{
-	int ret;
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-
-	if (tc > capa.qos_cos_max) {
-		netdev_info(ndev, "Invalid tc: %u\n", tc);
-		return -EINVAL;
-	}
-
-	ret = qos_shaper_conf_get(ndev, ocelot_port->chip_port * 8 + tc);
-
-	return ret;
-}
-
-int felix_qbu_set(struct net_device *ndev, u8 preemptible)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-
-	ocelot_port_rmwl(ocelot_port,
-			 DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA |
-			 DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA,
-			 DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA |
-			 DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA,
-			 DEV_GMII_MM_CONFIG_ENABLE_CONFIG);
-
-	ocelot_rmw_rix(ocelot,
-		       QSYS_PREEMPTION_CFG_P_QUEUES(preemptible),
-		       QSYS_PREEMPTION_CFG_P_QUEUES_M,
-		       QSYS_PREEMPTION_CFG,
-		       ocelot_port->chip_port);
-
-	return 0;
-}
-
-int felix_qbu_get(struct net_device *ndev, struct tsn_preempt_status *c)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-	u32 val;
-
-	val = ocelot_read_rix(ocelot,
-			      QSYS_PREEMPTION_CFG,
-			      ocelot_port->chip_port);
-
-	c->admin_state = QSYS_PREEMPTION_CFG_P_QUEUES(val);
-	c->hold_advance = QSYS_PREEMPTION_CFG_HOLD_ADVANCE_X(val);
-
-	val = ocelot_port_readl(ocelot_port,
-				DEV_GMII_MM_STATISTICS_MM_STATUS);
-	c->preemption_active =
-		DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STATUS & val;
-
-	return 0;
-}
-
-int felix_cb_streamid_get(struct net_device *ndev, u32 index,
-			  struct tsn_cb_streamid *streamid)
-{
-	struct ocelot_port *ocelot_port = netdev_priv(ndev);
-	struct ocelot *ocelot = ocelot_port->ocelot;
-	u32 m_index;
-	u32 bucket;
-	u32 val, dst, reg;
-	u64 dmac;
-	u32 ldmac, hdmac;
-
-	if (index >= MSCC_STREAM_HANDLE_NUM) {
-		netdev_info(ndev, "Invalid stream handle %u, maximum:%u\n",
-			    index, MSCC_STREAM_HANDLE_NUM - 1);
-		return -EINVAL;
-	}
-
-	index = streamhandle_map[index];
-	m_index = index / 4;
-	bucket =  index % 4;
-	streamid->type = 1;
-	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
-			   bucket);
-	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
-			   m_index);
-
-	/*READ command MACACCESS.VALID(11 bit) must be 0 */
-	ocelot_write(ocelot,
-		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),
-		     ANA_TABLES_MACACCESS);
-
-	val = ocelot_read(ocelot, ANA_TABLES_MACACCESS);
-	dst = ANA_TABLES_MACACCESS_DEST_IDX_X(val);
-	reg = ocelot_read_rix(ocelot, ANA_PGID_PGID, dst);
-	streamid->ofac_oport = ANA_PGID_PGID_PGID(reg);
-
-	/*Get the entry's MAC address and VLAN id*/
-	ldmac = ocelot_read(ocelot, ANA_TABLES_MACLDATA);
-	val = ocelot_read(ocelot, ANA_TABLES_MACHDATA);
-	val &= 0x1fffffff;
-	hdmac = val & 0xffff;
-	dmac = hdmac;
-	dmac = (dmac << 32) | ldmac;
-	streamid->para.nid.dmac = dmac;
-
-	streamid->para.nid.vid = ANA_TABLES_MACHDATA_VID_X(val);
-
-	val = ocelot_read(ocelot, ANA_TABLES_STREAMDATA);
-	if (!(val & ANA_TABLES_STREAMDATA_SFID_VALID))
-		return -EINVAL;
-
-	streamid->handle = ANA_TABLES_STREAMDATA_SFID(val);
-
-	return 0;
-}
-
-int lookup_mactable(struct ocelot *ocelot, u16 vid, u64 mac)
-{
-	u32 mach, macl;
-	u32 reg1, reg2;
-	u32 index, bucket;
-
-	macl = mac & 0xffffffff;
-	mach = (mac >> 32) & 0xffff;
-	ocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);
-	ocelot_write(ocelot, ANA_TABLES_MACHDATA_VID(vid) |
-		     ANA_TABLES_MACHDATA_MACHDATA(mach),
-		     ANA_TABLES_MACHDATA);
-
-	ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
-		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),
-		     ANA_TABLES_MACACCESS);
-
-	reg1 = ocelot_read(ocelot, ANA_TABLES_MACLDATA);
-	reg2 = ocelot_read(ocelot, ANA_TABLES_MACHDATA);
-	if (reg1 == 0 && reg2 == 0)
-		return -1;
-
-	regmap_field_read(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
-			  &bucket);
-	regmap_field_read(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
-			  &index);
-
-	index = index * 4 + bucket;
-
-	return index;
-}
-
-int felix_cb_streamid_set(struct net_device *ndev, u32 index, bool enable,
-			  struct tsn_cb_streamid *streamid)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	struct regmap_field *rf;
-	u16 vid;
-	u64 mac;
-	u32 macl, mach;
-	u32 dst_idx;
-	int idx;
-	u32 reg;
-	int sfid, ssid;
-	u32 m_index, bucket;
-
-	if (!enable) {
-		if (index >= MSCC_STREAM_HANDLE_NUM) {
-			netdev_info(ndev,
-				    "Invalid index %u, maximum:%u\n",
-				    index, MSCC_STREAM_HANDLE_NUM - 1);
-			return -EINVAL;
-		}
-		m_index = streamhandle_map[index] / 4;
-		bucket =  streamhandle_map[index] % 4;
-		rf = ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET];
-		regmap_field_write(rf, bucket);
-		rf = ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX];
-		regmap_field_write(rf, m_index);
-
-		/*READ command MACACCESS.VALID(11 bit) must be 0 */
-		ocelot_write(ocelot,
-			     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),
-			     ANA_TABLES_MACACCESS);
-
-		ocelot_write(ocelot,
-			     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_FORGET),
-			     ANA_TABLES_MACACCESS);
-
-		streamhandle_map[index] = 0;
-
-		return 0;
-	}
-
-	if (streamid->type != 1) {
-		netdev_info(ndev, "Invalid stream type\n");
-		return -EINVAL;
-	}
-
-	if (streamid->handle >= MSCC_STREAM_HANDLE_NUM) {
-		netdev_info(ndev, "Invalid stream handle %u, maximum:%u\n",
-			    streamid->handle, MSCC_STREAM_HANDLE_NUM - 1);
-		return -EINVAL;
-	}
-
-	sfid = streamid->handle;
-	ssid = (streamid->handle < MSCC_FRER_SSID_NUM ?
-		streamid->handle : (MSCC_FRER_SSID_NUM - 1));
-
-	mac = streamid->para.nid.dmac;
-	macl = mac & 0xffffffff;
-	mach = (mac >> 32) & 0xffff;
-	vid = streamid->para.nid.vid;
-
-	idx = lookup_mactable(ocelot, vid, mac);
-
-	if (idx < 0) {
-		ocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);
-		ocelot_write(ocelot, ANA_TABLES_MACHDATA_VID(vid) |
-			     ANA_TABLES_MACHDATA_MACHDATA(mach),
-			     ANA_TABLES_MACHDATA);
-
-		ocelot_write(ocelot,
-			     ANA_TABLES_STREAMDATA_SFID_VALID |
-			     ANA_TABLES_STREAMDATA_SFID(sfid) |
-			     ANA_TABLES_STREAMDATA_SSID_VALID |
-			     ANA_TABLES_STREAMDATA_SSID(ssid),
-			     ANA_TABLES_STREAMDATA);
-
-		dst_idx = port->chip_port;
-		ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
-			     ANA_TABLES_MACACCESS_ENTRYTYPE(1) |
-			     ANA_TABLES_MACACCESS_DEST_IDX(dst_idx) |
-			     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_LEARN),
-			     ANA_TABLES_MACACCESS);
-
-		ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
-			     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),
-			     ANA_TABLES_MACACCESS);
-
-		regmap_field_read(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
-				  &bucket);
-		regmap_field_read(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
-				  &m_index);
-
-		m_index = m_index * 4 + bucket;
-		streamhandle_map[streamid->handle] = m_index;
-
-		return 0;
-	}
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMDATA_SFID_VALID |
-		     ANA_TABLES_STREAMDATA_SFID(sfid) |
-		     ANA_TABLES_STREAMDATA_SSID_VALID |
-		     ANA_TABLES_STREAMDATA_SSID(ssid),
-		     ANA_TABLES_STREAMDATA);
-
-	reg = ocelot_read(ocelot, ANA_TABLES_MACACCESS);
-	dst_idx = ANA_TABLES_MACACCESS_DEST_IDX_X(reg);
-	ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
-		     ANA_TABLES_MACACCESS_ENTRYTYPE(1) |
-		     ANA_TABLES_MACACCESS_DEST_IDX(dst_idx) |
-		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_WRITE),
-		     ANA_TABLES_MACACCESS);
-
-	streamhandle_map[streamid->handle] = idx;
-
-	return 0;
-}
-
-static int streamid_multi_forward_set(struct ocelot *ocelot, u32 index,
-				      u8 fwdmask)
-{
-	u32 m_index;
-	u32 bucket;
-	u32 val;
-	int m, n, i;
-	u8 pgid_val, fwdport;
-	u32 dst_idx;
-
-	m_index = index / 4;
-	bucket =  index % 4;
-
-	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_BUCKET],
-			   bucket);
-	regmap_field_write(ocelot->regfields[ANA_TABLES_MACTINDX_M_INDEX],
-			   m_index);
-
-	/*READ command MACACCESS.VALID(11 bit) must be 0 */
-	ocelot_write(ocelot,
-		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),
-		     ANA_TABLES_MACACCESS);
-
-	val = ocelot_read(ocelot, ANA_TABLES_MACACCESS);
-	fwdport = ANA_TABLES_MACACCESS_DEST_IDX_X(val);
-
-	if (fwdport >= MSCC_NUM_OUT_PORT) {
-		dst_idx = fwdport;
-		return 0;
-	}
-
-	fwdmask |= (1 << fwdport);
-
-	m = ocelot->num_phys_ports - 1;
-	for (i = m; i >= MSCC_NUM_OUT_PORT; i--) {
-		if (fwdmask & (1 << i)) {
-			dst_idx = PGID_MCRED +
-				  (m - i) * MSCC_NUM_OUT_PORT +
-				  fwdport;
-
-			pgid_val = (1 << i) | (1 << fwdport);
-			break;
-		}
-	}
-
-	if (i < MSCC_NUM_OUT_PORT) {
-		m = PGID_MCRED +
-		    (ocelot->num_phys_ports - MSCC_NUM_OUT_PORT) *
-		    MSCC_NUM_OUT_PORT;
-
-		for (; i > 0; i--) {
-			if (fwdmask & (1 << i))
-				break;
-
-			m = m + (1 << i) - 1;
-		}
-		n = fwdmask & ((1 << i) - 1);
-		if (n) {
-			dst_idx = m + n;
-			pgid_val = fwdmask & ((1 << MSCC_NUM_OUT_PORT) - 1);
-		} else {
-			dst_idx = fwdport;
-		}
-	}
-
-	if (dst_idx < PGID_MCRED)
-		return 0;
-
-	ocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |
-		     ANA_TABLES_MACACCESS_ENTRYTYPE(1) |
-		     ANA_TABLES_MACACCESS_DEST_IDX(dst_idx) |
-		     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_WRITE),
-		     ANA_TABLES_MACACCESS);
-
-	ocelot_write_rix(ocelot, pgid_val, ANA_PGID_PGID, dst_idx);
-
-	return 0;
-}
-
-int felix_qci_sfi_get(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_sfi_conf *sfi)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 val, reg, fmeter_id, max_sdu;
-	u32 sfid = index;
-
-	if (sfid >= capa.num_psfp_sfid) {
-		netdev_info(ndev, "Invalid index %u, maximum:%u\n",
-			    sfid, capa.num_psfp_sfid);
-		return -EINVAL;
-	}
-
-	ocelot_field_write(ocelot, ANA_TABLES_SFIDTIDX_SFID_INDEX_0, sfid);
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_READ),
-		     ANA_TABLES_SFIDACCESS);
-
-	val = ocelot_read(ocelot, ANA_TABLES_SFIDTIDX);
-	if (!(val & ANA_TABLES_SFIDTIDX_SGID_VALID))
-		return -EINVAL;
-
-	sfi->stream_gate_instance_id = ANA_TABLES_SFIDTIDX_SGID_X(val);
-	fmeter_id = ANA_TABLES_SFIDTIDX_POL_IDX_X(val);
-	sfi->stream_filter.flow_meter_instance_id = fmeter_id;
-
-	reg = ocelot_read(ocelot, ANA_TABLES_SFIDACCESS);
-	max_sdu = ANA_TABLES_SFIDACCESS_MAX_SDU_LEN_X(reg);
-	sfi->stream_filter.maximum_sdu_size  = max_sdu;
-
-	if (reg & ANA_TABLES_SFIDACCESS_IGR_PRIO_MATCH_ENA)
-		sfi->priority_spec = ANA_TABLES_SFIDACCESS_IGR_PRIO_X(reg);
-	else
-		netdev_info(ndev, "priority not enable\n");
-
-	return 0;
-}
-
-int felix_qci_sfi_set(struct net_device *ndev, u32 index, bool enable,
-		      struct tsn_qci_psfp_sfi_conf *sfi)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	int igr_prio = sfi->priority_spec;
-	u16 sgid  = sfi->stream_gate_instance_id;
-	u16 pol_idx;
-	int fmid = sfi->stream_filter.flow_meter_instance_id;
-	u16 max_sdu_len = sfi->stream_filter.maximum_sdu_size;
-	int sfid = index;
-
-	if (fmid == -1)
-		pol_idx = capa.psfp_fmi_max;
-	else
-		pol_idx = (u16)fmid;
-
-	if (sfid >= capa.num_psfp_sfid) {
-		netdev_info(ndev, "Invalid index %u, maximum:%u\n",
-			    sfid, capa.num_psfp_sfid);
-		return -EINVAL;
-	}
-
-	if (sgid >= capa.num_psfp_sgid) {
-		netdev_info(ndev, "Invalid sgid %u, maximum:%u\n",
-			    sgid, capa.num_psfp_sgid);
-		return -EINVAL;
-	}
-	if (pol_idx > capa.psfp_fmi_max || pol_idx < capa.psfp_fmi_min) {
-		netdev_info(ndev, "Invalid pol_idx %u, range:%d~%d\n",
-			    pol_idx, capa.psfp_fmi_min, capa.psfp_fmi_max);
-		return -EINVAL;
-	}
-
-	ocelot_write(ocelot, ANA_TABLES_SFIDTIDX_SGID_VALID |
-		     ANA_TABLES_SFIDTIDX_SGID(sgid) |
-		     ((fmid != -1) ? ANA_TABLES_SFIDTIDX_POL_ENA : 0) |
-		     ANA_TABLES_SFIDTIDX_POL_IDX(pol_idx) |
-		     ANA_TABLES_SFIDTIDX_SFID_INDEX(sfid),
-		     ANA_TABLES_SFIDTIDX);
-
-	ocelot_write(ocelot,
-		     ((igr_prio >= 0) ?
-		      ANA_TABLES_SFIDACCESS_IGR_PRIO_MATCH_ENA : 0) |
-		     ANA_TABLES_SFIDACCESS_IGR_PRIO(igr_prio) |
-		     ANA_TABLES_SFIDACCESS_MAX_SDU_LEN(max_sdu_len) |
-		     ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_WRITE),
-		     ANA_TABLES_SFIDACCESS);
-
-	return 0;
-}
-
-int felix_qci_sfi_counters_get(struct net_device *ndev, u32 index,
-			       struct tsn_qci_psfp_sfi_counters *sfi_counters)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 sfid = index;
-	u32 match, not_pass, not_pass_sdu, red;
-
-	if (sfid >= capa.num_psfp_sfid) {
-		netdev_info(ndev, "Invalid index %u, maximum:%u\n",
-			    sfid, capa.num_psfp_sfid);
-		return -EINVAL;
-	}
-
-	ocelot_field_write(ocelot, SYS_STAT_CFG_STAT_VIEW_0, sfid);
-	match = ocelot_read_gix(ocelot, SYS_CNT, 0x200);
-	not_pass = ocelot_read_gix(ocelot, SYS_CNT, 0x201);
-	not_pass_sdu = ocelot_read_gix(ocelot, SYS_CNT, 0x202);
-	red = ocelot_read_gix(ocelot, SYS_CNT, 0x203);
-
-	sfi_counters->matching_frames_count = match;
-	sfi_counters->not_passing_frames_count = not_pass;
-	sfi_counters->not_passing_sdu_count = not_pass_sdu;
-	sfi_counters->red_frames_count  =  red;
-
-	sfi_counters->passing_frames_count = match - not_pass;
-	sfi_counters->passing_sdu_count = match - not_pass - not_pass_sdu;
-
-	return 0;
-}
-
-static int sgi_set_glist(struct ocelot *ocelot,
-			 struct tsn_qci_psfp_gcl *gcl, uint32_t num)
-{
-	u32 time_sum = 0;
-	int i;
-
-	if (num > capa.num_sgi_gcl)
-		return -EINVAL;
-
-	for (i = 0; i < num; i++) {
-		u32 val = ANA_SG_GCL_GS_CONFIG_IPS((gcl->ipv < 0) ?
-						   0 : gcl->ipv + 8);
-		val |= (gcl->gate_state ? ANA_SG_GCL_GS_CONFIG_GATE_STATE : 0);
-		ocelot_write_rix(ocelot, val, ANA_SG_GCL_GS_CONFIG, i);
-
-		time_sum += gcl->time_interval;
-		ocelot_write_rix(ocelot, time_sum, ANA_SG_GCL_TI_CONFIG, i);
-
-		gcl++;
-	}
-
-	return 0;
-}
-
-static u32 sgi_read_status(struct ocelot *ocelot)
-{
-	u32 val;
-
-	val = ocelot_read(ocelot, ANA_SG_ACCESS_CTRL);
-
-	return val;
-}
-
-int felix_qci_sgi_set(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_sgi_conf *sgi_conf)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	struct tsn_qci_sg_control *admin_list = &sgi_conf->admin;
-	u32 sgid = index;
-	u32 list_length = sgi_conf->admin.control_list_length;
-	u32 cycle_time = sgi_conf->admin.cycle_time;
-	u32 cycle_time_ex = sgi_conf->admin.cycle_time_extension;
-	u32 l_basetime = sgi_conf->admin.base_time % 1000000000;
-	u64 h_basetime = sgi_conf->admin.base_time / 1000000000;
-	u64 cur_time;
-	u32 val;
-	int ret;
-
-	if (sgid >= capa.num_psfp_sgid) {
-		netdev_info(ndev, "Invalid sgid %u, maximum:%u\n",
-			    sgid, capa.num_psfp_sgid);
-		return -EINVAL;
-	}
-	if ((cycle_time < capa.sgi_ct_min ||
-	     cycle_time > capa.sgi_ct_max) &&
-	     sgi_conf->gate_enabled) {
-		netdev_info(ndev, "Invalid cycle_time %u ns\n",
-			    cycle_time);
-		return -EINVAL;
-	}
-	if (cycle_time_ex > capa.sgi_cte_max) {
-		netdev_info(ndev,
-			    "Invalid cycle_time_extension %u\n",
-			    cycle_time_ex);
-		return -EINVAL;
-	}
-	if (list_length > capa.num_sgi_gcl) {
-		netdev_info(ndev, "Invalid sgi_gcl len %u, maximum:%u\n",
-			    list_length, capa.num_sgi_gcl);
-		return -EINVAL;
-	}
-
-	/*configure SGID*/
-	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_SGID_0, sgid);
-
-	/*Disable SG*/
-	if (!sgi_conf->gate_enabled) {
-		ocelot_rmw(ocelot,
-			   ANA_SG_CONFIG_REG_3_INIT_GATE_STATE,
-			   ANA_SG_CONFIG_REG_3_INIT_GATE_STATE |
-			   ANA_SG_CONFIG_REG_3_GATE_ENABLE,
-			   ANA_SG_CONFIG_REG_3);
-		return 0;
-	}
-
-	/*admin parameters*/
-	cur_time = ocelot_read(ocelot, PTP_CUR_SEC_MSB);
-	cur_time = cur_time << 32;
-	cur_time += ocelot_read(ocelot, PTP_CUR_SEC_LSB);
-	if (h_basetime < cur_time) {
-		h_basetime = cur_time;
-		l_basetime = ocelot_read(ocelot, PTP_CUR_NSEC);
-	}
-
-	ocelot_write(ocelot, l_basetime, ANA_SG_CONFIG_REG_1);
-	ocelot_write(ocelot, h_basetime, ANA_SG_CONFIG_REG_2);
-
-	ocelot_write(ocelot,
-		     (sgi_conf->admin.init_ipv < 0 ?
-		      0 : ANA_SG_CONFIG_REG_3_IPV_VALID) |
-		     ANA_SG_CONFIG_REG_3_INIT_IPV(sgi_conf->admin.init_ipv) |
-		     ANA_SG_CONFIG_REG_3_GATE_ENABLE |
-		     ANA_SG_CONFIG_REG_3_LIST_LENGTH(list_length) |
-		     (sgi_conf->admin.gate_states > 0 ?
-		      ANA_SG_CONFIG_REG_3_INIT_GATE_STATE : 0) |
-		     ANA_SG_CONFIG_REG_3_BASE_TIME_SEC_MSB(h_basetime >> 32),
-		     ANA_SG_CONFIG_REG_3);
-
-	ocelot_write(ocelot, cycle_time, ANA_SG_CONFIG_REG_4);
-	ocelot_write(ocelot, cycle_time_ex, ANA_SG_CONFIG_REG_5);
-
-	ret = sgi_set_glist(ocelot, admin_list->gcl, list_length);
-	if (ret < 0)
-		return ret;
-
-	/*CONG_CHANGE TO 1*/
-	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_CONFIG_CHANGE_0, 1);
-
-	ret = readx_poll_timeout(sgi_read_status, ocelot, val,
-				 (!(ANA_SG_ACCESS_CTRL_CONFIG_CHANGE & val)),
-				 10, 100000);
-
-	return ret;
-}
-
-static int sgi_get_glist(struct ocelot *ocelot,
-			 struct tsn_qci_psfp_gcl *gcl,
-			 uint32_t num)
-{
-	int i;
-	u16 val;
-	u32 time = 0;
-	u32 reg;
-
-	if (num > capa.num_sgi_gcl)
-		return -EINVAL;
-
-	for (i = 0; i < num; i++) {
-		val = ocelot_read_rix(ocelot, ANA_SG_GCL_GS_CONFIG, i);
-		gcl->gate_state = (val & ANA_SG_GCL_GS_CONFIG_GATE_STATE);
-
-		if (val & ANA_SG_GCL_GS_CONFIG_IPV_VALID)
-			gcl->ipv = ANA_SG_GCL_GS_CONFIG_IPV(val);
-		else
-			gcl->ipv = -1;
-
-		reg = ocelot_read_rix(ocelot, ANA_SG_GCL_TI_CONFIG, i);
-		gcl->time_interval = (reg - time);
-		time = reg;
-
-		gcl++;
-	}
-
-	return 0;
-}
-
-int felix_qci_sgi_get(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_sgi_conf *sgi_conf)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	struct tsn_qci_sg_control *admin  = &sgi_conf->admin;
-	struct tsn_qci_psfp_gcl *glist;
-	u32 val, reg;
-	u32 list_num;
-	int ret;
-
-	if (index >= capa.num_psfp_sgid) {
-		netdev_info(ndev, "Invalid sgid %u, maximum:%u\n",
-			    index, capa.num_psfp_sgid);
-		return -EINVAL;
-	}
-
-	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_SGID_0, index);
-
-	admin->cycle_time = ocelot_read(ocelot, ANA_SG_CONFIG_REG_4);
-	admin->cycle_time_extension =
-		ocelot_read(ocelot, ANA_SG_CONFIG_REG_5);
-
-	val = ocelot_read(ocelot, ANA_SG_CONFIG_REG_2);
-	admin->base_time = val;
-
-	reg = ocelot_read(ocelot, ANA_SG_CONFIG_REG_1);
-	val = ocelot_read(ocelot, ANA_SG_CONFIG_REG_3);
-
-	admin->base_time +=
-		ANA_SG_CONFIG_REG_3_BASE_TIME_SEC_MSB(val) << 32;
-
-	admin->base_time = admin->base_time * 1000000000 + reg;
-
-	if (val & ANA_SG_CONFIG_REG_3_IPV_VALID)
-		admin->init_ipv = ANA_SG_CONFIG_REG_3_INIT_IPV_X(val);
-	else
-		admin->init_ipv = -1;
-
-	admin->control_list_length = ANA_SG_CONFIG_REG_3_LIST_LENGTH_X(val);
-
-	list_num = admin->control_list_length;
-
-	glist = kmalloc_array(list_num, sizeof(struct tsn_qci_psfp_gcl),
-			      GFP_KERNEL);
-	admin->gcl = glist;
-
-	ret = sgi_get_glist(ocelot, glist, list_num);
-
-	return ret;
-}
-
-int felix_qci_sgi_status_get(struct net_device *ndev, u16 index,
-			     struct tsn_psfp_sgi_status *sgi_status)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 val, reg;
-
-	if (index >= capa.num_psfp_sgid) {
-		netdev_info(ndev, "Invalid sgid %u, maximum:%u\n",
-			    index, capa.num_psfp_sgid);
-		return -EINVAL;
-	}
-
-	/*SET SGID*/
-	ocelot_field_write(ocelot, ANA_SG_ACCESS_CTRL_SGID_0, index);
-
-	val = ocelot_read(ocelot, ANA_SG_STATUS_REG_2);
-	sgi_status->config_change_time = val;
-
-	reg = ocelot_read(ocelot, ANA_SG_STATUS_REG_1);
-	val = ocelot_read(ocelot, ANA_SG_STATUS_REG_3);
-	sgi_status->config_change_time +=
-		ANA_SG_STATUS_REG_3_CFG_CHG_TIME_SEC_MSB(val) << 32;
-	sgi_status->config_change_time =
-		sgi_status->config_change_time * 1000000000 + reg;
-
-	if (val & ANA_SG_STATUS_REG_3_CONFIG_PENDING)
-		sgi_status->config_pending  = TRUE;
-	else
-		sgi_status->config_pending = FALSE;
-
-	if (val & ANA_SG_STATUS_REG_3_GATE_STATE)
-		sgi_status->oper.gate_states  =  TRUE;
-	else
-		sgi_status->oper.gate_states  =  FALSE;
-	/*bit 3 encoding 0:IPV [0:2]is invalid . 1:IPV[0:2] is valid*/
-	if (val & ANA_SG_STATUS_REG_3_IPV_VALID)
-		sgi_status->oper.init_ipv = ANA_SG_STATUS_REG_3_IPV_X(val);
-	else
-		sgi_status->oper.init_ipv = -1;
-
-	return 0;
-}
-
-int felix_qci_fmi_set(struct net_device *ndev, u32 index,
-		      bool enable, struct tsn_qci_psfp_fmi *fmi)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 cir = 0, cbs = 0, pir = 0, pbs = 0;
-	u32 cir_ena = 0;
-	u32 pbs_max = 0, cbs_max = 0;
-	bool cir_discard = 0, pir_discard = 0;
-
-	if (index > capa.qos_pol_max) {
-		netdev_info(ndev, "Invalid pol_idx %u, maximum: %u\n",
-			    index, capa.qos_pol_max);
-		return -EINVAL;
-	}
-
-	if (fmi->mark_red_enable && fmi->mark_red) {
-		fmi->eir = 0;
-		fmi->ebs = 0;
-		fmi->cir = 0;
-		fmi->cbs = 0;
-	}
-
-	pir = fmi->eir;
-	pbs = fmi->ebs;
-
-	if (!fmi->drop_on_yellow)
-		cir_ena = 1;
-
-	if (cir_ena) {
-		cir = fmi->cir;
-		cbs = fmi->cbs;
-		if (cir == 0 && cbs == 0) {
-			cir_discard = 1;
-		} else {
-			cir = DIV_ROUND_UP(cir, 100);
-			cir *= 3;  /* Rate unit is 33 1/3 kbps */
-			cbs = DIV_ROUND_UP(cbs, 4096);
-			cbs = (cbs ? cbs : 1);
-			cbs_max = capa.pol_cbs_max;
-			if (fmi->cf)
-				pir += fmi->cir;
-		}
-	}
-
-	if (pir == 0 && pbs == 0) {
-		pir_discard = 1;
-	} else {
-		pir = DIV_ROUND_UP(pir, 100);
-		pir *= 3;  /* Rate unit is 33 1/3 kbps */
-		pbs = DIV_ROUND_UP(pbs, 4096);
-		pbs = (pbs ? pbs : 1);
-		pbs_max = capa.pol_pbs_max;
-	}
-	pir = min_t(u32, GENMASK(15, 0), pir);
-	cir = min_t(u32, GENMASK(15, 0), cir);
-	pbs = min(pbs_max, pbs);
-	cbs = min(cbs_max, cbs);
-
-	ocelot_write_gix(ocelot, (ANA_POL_MODE_CFG_IPG_SIZE(20) |
-			 ANA_POL_MODE_CFG_FRM_MODE(1) |
-			 (fmi->cf ? ANA_POL_MODE_CFG_DLB_COUPLED : 0) |
-			 (cir_ena ? ANA_POL_MODE_CFG_CIR_ENA : 0) |
-			 ANA_POL_MODE_CFG_OVERSHOOT_ENA),
-			 ANA_POL_MODE_CFG, index);
-
-	ocelot_write_gix(ocelot, ANA_POL_PIR_CFG_PIR_RATE(pir) |
-			 ANA_POL_PIR_CFG_PIR_BURST(pbs),
-			 ANA_POL_PIR_CFG, index);
-
-	ocelot_write_gix(ocelot,
-			 (pir_discard ? GENMASK(22, 0) : 0),
-			 ANA_POL_PIR_STATE, index);
-
-	ocelot_write_gix(ocelot, ANA_POL_CIR_CFG_CIR_RATE(cir) |
-			 ANA_POL_CIR_CFG_CIR_BURST(cbs),
-			 ANA_POL_CIR_CFG, index);
-
-	ocelot_write_gix(ocelot,
-			 (cir_discard ? GENMASK(22, 0) : 0),
-			 ANA_POL_CIR_STATE, index);
-
-	return 0;
-}
-
-int felix_qci_fmi_get(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_fmi *fmi,
-		      struct tsn_qci_psfp_fmi_counters *counters)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 val, reg;
-
-	if (index > capa.qos_pol_max) {
-		netdev_info(ndev, "Invalid pol_idx %u, maximum: %u\n",
-			    index, capa.qos_pol_max);
-		return -EINVAL;
-	}
-
-	val = ocelot_read_gix(ocelot, ANA_POL_PIR_CFG, index);
-	reg = ocelot_read_gix(ocelot, ANA_POL_CIR_CFG, index);
-
-	fmi->eir = ANA_POL_PIR_CFG_PIR_RATE_X(val);
-	fmi->eir = fmi->eir * 100 / 3;
-	fmi->ebs = ANA_POL_PIR_CFG_PIR_BURST(val);
-	fmi->ebs *= 4096;
-	fmi->cir = ANA_POL_CIR_CFG_CIR_RATE_X(reg);
-	fmi->cir = fmi->cir * 100 / 3;
-	fmi->cbs = ANA_POL_CIR_CFG_CIR_BURST(reg);
-	fmi->cbs *= 4096;
-	if (!(fmi->eir | fmi->ebs | fmi->cir | fmi->cbs))
-		fmi->mark_red = TRUE;
-	else
-		fmi->mark_red = FALSE;
-
-	val = ocelot_read_gix(ocelot, ANA_POL_MODE_CFG, index);
-	if (val & ANA_POL_MODE_CFG_DLB_COUPLED)
-		fmi->cf = TRUE;
-	else
-		fmi->cf = FALSE;
-	if (val & ANA_POL_MODE_CFG_CIR_ENA)
-		fmi->drop_on_yellow = FALSE;
-	else
-		fmi->drop_on_yellow = TRUE;
-
-	return 0;
-}
-
-int felix_seq_gen_set(struct net_device *ndev, u32 index,
-		      struct tsn_seq_gen_conf *sg_conf)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u8 iport_mask = sg_conf->iport_mask;
-	u8 split_mask = sg_conf->split_mask;
-	u8 seq_len = sg_conf->seq_len;
-	u32 seq_num = sg_conf->seq_num;
-
-	if (index >= capa.num_frer_ssid) {
-		netdev_info(ndev, "Invalid SSID %u, maximum:%u\n",
-			    index, capa.num_frer_ssid - 1);
-		return -EINVAL;
-	}
-	if (seq_len < capa.frer_seq_len_min ||
-	    seq_len > capa.frer_seq_len_max) {
-		netdev_info(ndev,
-			    "Invalid seq_space_bits num %u,range:%d~%d\n",
-			    seq_len,
-			    capa.frer_seq_len_min,
-			    capa.frer_seq_len_max);
-		return -EINVAL;
-	}
-
-	streamid_multi_forward_set(ocelot,
-				   streamhandle_map[index],
-				   split_mask);
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_SEQ_MASK_SPLIT_MASK(split_mask) |
-		     ANA_TABLES_SEQ_MASK_INPUT_PORT_MASK(iport_mask),
-		     ANA_TABLES_SEQ_MASK);
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMTIDX_S_INDEX(index) |
-		     ANA_TABLES_STREAMTIDX_STREAM_SPLIT |
-		     ANA_TABLES_STREAMTIDX_SEQ_SPACE_LOG2(seq_len),
-		     ANA_TABLES_STREAMTIDX);
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMACCESS_GEN_REC_SEQ_NUM(seq_num) |
-		     ANA_TABLES_STREAMACCESS_SEQ_GEN_REC_ENA |
-		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(SFIDACCESS_CMD_WRITE),
-		     ANA_TABLES_STREAMACCESS);
-
-	return 0;
-}
-
-int felix_seq_rec_set(struct net_device *ndev, u32 index,
-		      struct tsn_seq_rec_conf *sr_conf)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u8 seq_len = sr_conf->seq_len;
-	u8 hislen = sr_conf->his_len;
-
-	if (index >= capa.num_frer_ssid) {
-		netdev_info(ndev, "Invalid SSID %u, maximum:%u\n",
-			    index, capa.num_frer_ssid - 1);
-		return -EINVAL;
-	}
-	if (seq_len < capa.frer_seq_len_min ||
-	    seq_len > capa.frer_seq_len_max) {
-		netdev_info(ndev,
-			    "Invalid seq_space_bits num %u,range:%d~%d\n",
-			    seq_len,
-			    capa.frer_seq_len_min,
-			    capa.frer_seq_len_max);
-		return -EINVAL;
-	}
-	if (hislen < capa.frer_his_len_min ||
-	    hislen > capa.frer_his_len_max) {
-		netdev_info(ndev,
-			    "Invalid history_bits num %u,range:%d~%d\n",
-			    hislen,
-			    capa.frer_his_len_min,
-			    capa.frer_his_len_max);
-		return -EINVAL;
-	}
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMTIDX_S_INDEX(index) |
-		     ANA_TABLES_STREAMTIDX_FORCE_SF_BEHAVIOUR |
-		     ANA_TABLES_STREAMTIDX_SEQ_HISTORY_LEN(hislen) |
-		     ANA_TABLES_STREAMTIDX_RESET_ON_ROGUE |
-		     (sr_conf->rtag_pop_en ?
-		      ANA_TABLES_STREAMTIDX_REDTAG_POP : 0) |
-		     ANA_TABLES_STREAMTIDX_SEQ_SPACE_LOG2(seq_len),
-		     ANA_TABLES_STREAMTIDX);
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMACCESS_SEQ_GEN_REC_ENA |
-		     ANA_TABLES_STREAMACCESS_GEN_REC_TYPE |
-		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(SFIDACCESS_CMD_WRITE),
-		     ANA_TABLES_STREAMACCESS);
-
-	return 0;
-}
-
-int felix_cb_get(struct net_device *ndev, u32 index,
-		 struct tsn_cb_status *c)
-{
-	u32 val;
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-
-	if (index >= capa.num_frer_ssid) {
-		netdev_info(ndev, "Invalid SSID %u, maximum:%u\n",
-			    index, capa.num_frer_ssid - 1);
-		return -EINVAL;
-	}
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMTIDX_S_INDEX(index),
-		     ANA_TABLES_STREAMTIDX);
-
-	ocelot_write(ocelot,
-		     ANA_TABLES_STREAMACCESS_STREAM_TBL_CMD(SFIDACCESS_CMD_READ),
-		     ANA_TABLES_STREAMACCESS);
-
-	val = ocelot_read(ocelot, ANA_TABLES_STREAMACCESS);
-	c->gen_rec = (ANA_TABLES_STREAMACCESS_GEN_REC_TYPE & val) >> 2;
-	c->seq_num = ANA_TABLES_STREAMACCESS_GEN_REC_SEQ_NUM_X(val);
-
-	val = ocelot_read(ocelot, ANA_TABLES_STREAMTIDX);
-	c->err = ANA_TABLES_STREAMTIDX_SEQ_GEN_ERR_STATUS_X(val);
-	c->his_len = ANA_TABLES_STREAMTIDX_SEQ_HISTORY_LEN_X(val);
-	c->seq_len = ANA_TABLES_STREAMTIDX_SEQ_SPACE_LOG2(val);
-
-	val = ocelot_read(ocelot, ANA_TABLES_SEQ_MASK);
-	c->split_mask = ANA_TABLES_SEQ_MASK_SPLIT_MASK_X(val);
-	c->iport_mask = ANA_TABLES_SEQ_MASK_INPUT_PORT_MASK(val);
-
-	c->seq_his = ocelot_read(ocelot, ANA_TABLES_SEQ_HISTORY);
-
-	return 0;
-}
-
-int felix_pcp_map_set(struct net_device *ndev, bool enable)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-
-	ocelot_rmw_gix(ocelot,
-		       (enable ? ANA_PORT_QOS_CFG_QOS_PCP_ENA : 0),
-		       ANA_PORT_QOS_CFG_QOS_PCP_ENA,
-		       ANA_PORT_QOS_CFG,
-		       port->chip_port);
-
-	return 0;
-}
-
-static int pcp_map_enable(struct ocelot *ocelot, u8 port)
-{
-	int i;
-
-	ocelot_rmw_gix(ocelot,
-		       ANA_PORT_QOS_CFG_QOS_PCP_ENA,
-		       ANA_PORT_QOS_CFG_QOS_PCP_ENA,
-		       ANA_PORT_QOS_CFG,
-		       port);
-
-	for (i = 0; i < NUM_MSCC_QOS_PRIO * 2; i++) {
-		ocelot_rmw_ix(ocelot,
-			      (ANA_PORT_PCP_DEI_MAP_DP_PCP_DEI_VAL & i) |
-			      ANA_PORT_PCP_DEI_MAP_QOS_PCP_DEI_VAL(i),
-			      ANA_PORT_PCP_DEI_MAP_DP_PCP_DEI_VAL |
-			      ANA_PORT_PCP_DEI_MAP_QOS_PCP_DEI_VAL_M,
-			      ANA_PORT_PCP_DEI_MAP,
-			      port, i);
-	}
-
-	return 0;
-}
-
-static int rtag_parse_enable(struct ocelot *ocelot, u8 port)
-{
-	ocelot_rmw_rix(ocelot,
-		       ANA_PORT_MODE_REDTAG_PARSE_CFG,
-		       ANA_PORT_MODE_REDTAG_PARSE_CFG,
-		       ANA_PORT_MODE,
-		       port);
-
-	return 0;
-}
-
-int felix_dscp_set(struct net_device *ndev,
-		   bool enable,
-		   const u8 dscp_ix,
-		   struct tsn_qos_switch_dscp_conf *c)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-	u32 val, ri = dscp_ix;
-
-	c->dscp = 0;
-	c->trust = 1;
-	c->remark = 0;
-
-	if (dscp_ix > capa.qos_dscp_max) {
-		netdev_info(ndev, "Invalid dscp_ix %u\n", dscp_ix);
-		return -EINVAL;
-	}
-	if (c->cos > capa.qos_cos_max) {
-		netdev_info(ndev, "Invalid cos %d\n", c->cos);
-		return -EINVAL;
-	}
-	if (c->dpl > capa.qos_dp_max) {
-		netdev_info(ndev, "Invalid dpl %d\n", c->dpl);
-		return -EINVAL;
-	}
-
-	ocelot_rmw_gix(ocelot,
-		       (enable ? ANA_PORT_QOS_CFG_QOS_DSCP_ENA : 0) |
-		       (c->dscp ? ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA : 0),
-		       ANA_PORT_QOS_CFG_QOS_DSCP_ENA |
-		       ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA,
-		       ANA_PORT_QOS_CFG,
-		       port->chip_port);
-
-	val = (c->dpl ? ANA_DSCP_CFG_DP_DSCP_VAL : 0) |
-	       ANA_DSCP_CFG_QOS_DSCP_VAL(c->cos) |
-	       ANA_DSCP_CFG_DSCP_TRANSLATE_VAL(c->dscp) |
-	       (c->trust ? ANA_DSCP_CFG_DSCP_TRUST_ENA : 0) |
-	       (c->remark ? ANA_DSCP_CFG_DSCP_REWR_ENA : 0);
-
-	ocelot_write_rix(ocelot, val, ANA_DSCP_CFG, ri);
-
-	return 0;
-}
-
-void felix_tsn_init(struct net_device *ndev)
-{
-	struct ocelot_port *port = netdev_priv(ndev);
-	struct ocelot *ocelot = port->ocelot;
-
-	pcp_map_enable(ocelot, port->chip_port);
-	rtag_parse_enable(ocelot, port->chip_port);
-}
diff --git a/drivers/net/ethernet/mscc/felix_tsn.h b/drivers/net/ethernet/mscc/felix_tsn.h
deleted file mode 100644
index 52030b1650a4..000000000000
--- a/drivers/net/ethernet/mscc/felix_tsn.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT)
- *
- * TSN_SWITCH driver
- *
- * Copyright 2018-2019 NXP
- */
-
-#ifndef _MSCC_FELIX_SWITCH_TSN_H_
-#define _MSCC_FELIX_SWITCH_TSN_H_
-#include <net/tsn.h>
-
-#define TRUE 1
-#define FALSE 0
-
-struct mscc_switch_capa {
-	u8 num_tas_gcl; /* Number of TAS Gate Control Lists */
-	u32 tas_ct_min; /* Minimum supported TAS CycleTime in nS */
-	u32 tas_ct_max; /* Maximum supported TAS CycleTime in nS */
-	u32 tas_cte_max; /* Maximum supported TAS CycleTimeExtension in nS
-			  */
-	u32 tas_it_max;
-	u32 tas_it_min;
-	u8 num_hsch;
-	u8 num_psfp_sfid;
-	u8 num_frer_ssid;
-	u8 num_psfp_sgid;
-	u16 psfp_fmi_max;
-	u16 psfp_fmi_min;
-	u8 num_sgi_gcl;
-	u32 sgi_ct_min;
-	u32 sgi_ct_max;
-	u32 sgi_cte_max;
-	u16 qos_pol_max;
-	u8 pol_cbs_max;
-	u8 pol_pbs_max;
-	u8 frer_seq_len_min;
-	u8 frer_seq_len_max;
-	u8 frer_his_len_min;
-	u8 frer_his_len_max;
-	u8 qos_dscp_max;
-	u8 qos_cos_max;
-	u8 qos_dp_max;
-};
-
-int felix_qbv_set(struct net_device *ndev,
-		  struct tsn_qbv_conf *shaper_config);
-int felix_qbv_get(struct net_device *ndev,
-		  struct tsn_qbv_conf *shaper_config);
-int felix_qbv_get_status(struct net_device *ndev,
-			 struct tsn_qbv_status *qbvstatus);
-int felix_cut_thru_set(struct net_device *ndev, u8 cut_thru);
-int felix_cbs_set(struct net_device *ndev, u8 tc, u8 bw);
-int felix_cbs_get(struct net_device *ndev, u8 tc);
-int felix_qbu_set(struct net_device *ndev, u8 preemptible);
-int felix_qbu_get(struct net_device *ndev, struct tsn_preempt_status *c);
-int felix_cb_streamid_get(struct net_device *ndev, u32 index,
-			  struct tsn_cb_streamid *streamid);
-int felix_cb_streamid_set(struct net_device *ndev, u32 index,
-			  bool enable, struct tsn_cb_streamid *streamid);
-int felix_qci_sfi_get(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_sfi_conf *sfi);
-int felix_qci_sfi_set(struct net_device *ndev, u32 index,
-		      bool enable, struct tsn_qci_psfp_sfi_conf *sfi);
-int felix_cb_streamid_counters_get(struct net_device *ndev, u32 index,
-				   struct tsn_cb_streamid_counters *s_counters);
-int felix_qci_sfi_counters_get(struct net_device *ndev, u32 index,
-			       struct tsn_qci_psfp_sfi_counters *sfi_counters);
-int felix_qci_sgi_set(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_sgi_conf *sgi_conf);
-int felix_qci_sgi_get(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_sgi_conf *sgi_conf);
-int felix_qci_sgi_status_get(struct net_device *ndev, u16 index,
-			     struct tsn_psfp_sgi_status *sgi_status);
-int felix_qci_fmi_set(struct net_device *ndev, u32 index,
-		      bool enable, struct tsn_qci_psfp_fmi *fmi);
-int felix_qci_fmi_get(struct net_device *ndev, u32 index,
-		      struct tsn_qci_psfp_fmi *fmi,
-		      struct tsn_qci_psfp_fmi_counters *counters);
-int felix_seq_gen_set(struct net_device *ndev, u32 index,
-		      struct tsn_seq_gen_conf *sg_conf);
-int felix_seq_rec_set(struct net_device *ndev, u32 index,
-		      struct tsn_seq_rec_conf *sr_conf);
-int felix_cb_get(struct net_device *ndev, u32 index,
-		 struct tsn_cb_status  *c);
-int felix_pcp_map_set(struct net_device *ndev, bool enable);
-int felix_dscp_set(struct net_device *ndev, bool enable, const u8 dscp_ix,
-		   struct tsn_qos_switch_dscp_conf *c);
-
-static inline void ocelot_port_rmwl(struct ocelot_port *port, u32 val,
-				    u32 mask, u32 reg)
-{
-	u32 cur = ocelot_port_readl(port, reg);
-
-	ocelot_port_writel(port, (cur & (~mask)) | val, reg);
-}
-
-void felix_tsn_init(struct net_device *ndev);
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_dev.h b/drivers/net/ethernet/mscc/ocelot_dev.h
deleted file mode 100644
index 0a50d53bbd3f..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_dev.h
+++ /dev/null
@@ -1,275 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_DEV_H_
-#define _MSCC_OCELOT_DEV_H_
-
-#define DEV_CLOCK_CFG                                     0x0
-
-#define DEV_CLOCK_CFG_MAC_TX_RST                          BIT(7)
-#define DEV_CLOCK_CFG_MAC_RX_RST                          BIT(6)
-#define DEV_CLOCK_CFG_PCS_TX_RST                          BIT(5)
-#define DEV_CLOCK_CFG_PCS_RX_RST                          BIT(4)
-#define DEV_CLOCK_CFG_PORT_RST                            BIT(3)
-#define DEV_CLOCK_CFG_PHY_RST                             BIT(2)
-#define DEV_CLOCK_CFG_LINK_SPEED(x)                       ((x) & GENMASK(1, 0))
-#define DEV_CLOCK_CFG_LINK_SPEED_M                        GENMASK(1, 0)
-
-#define DEV_PORT_MISC                                     0x4
-
-#define DEV_PORT_MISC_FWD_ERROR_ENA                       BIT(4)
-#define DEV_PORT_MISC_FWD_PAUSE_ENA                       BIT(3)
-#define DEV_PORT_MISC_FWD_CTRL_ENA                        BIT(2)
-#define DEV_PORT_MISC_DEV_LOOP_ENA                        BIT(1)
-#define DEV_PORT_MISC_HDX_FAST_DIS                        BIT(0)
-
-#define DEV_EVENTS                                        0x8
-
-#define DEV_EEE_CFG                                       0xc
-
-#define DEV_EEE_CFG_EEE_ENA                               BIT(22)
-#define DEV_EEE_CFG_EEE_TIMER_AGE(x)                      (((x) << 15) & GENMASK(21, 15))
-#define DEV_EEE_CFG_EEE_TIMER_AGE_M                       GENMASK(21, 15)
-#define DEV_EEE_CFG_EEE_TIMER_AGE_X(x)                    (((x) & GENMASK(21, 15)) >> 15)
-#define DEV_EEE_CFG_EEE_TIMER_WAKEUP(x)                   (((x) << 8) & GENMASK(14, 8))
-#define DEV_EEE_CFG_EEE_TIMER_WAKEUP_M                    GENMASK(14, 8)
-#define DEV_EEE_CFG_EEE_TIMER_WAKEUP_X(x)                 (((x) & GENMASK(14, 8)) >> 8)
-#define DEV_EEE_CFG_EEE_TIMER_HOLDOFF(x)                  (((x) << 1) & GENMASK(7, 1))
-#define DEV_EEE_CFG_EEE_TIMER_HOLDOFF_M                   GENMASK(7, 1)
-#define DEV_EEE_CFG_EEE_TIMER_HOLDOFF_X(x)                (((x) & GENMASK(7, 1)) >> 1)
-#define DEV_EEE_CFG_PORT_LPI                              BIT(0)
-
-#define DEV_RX_PATH_DELAY                                 0x10
-
-#define DEV_TX_PATH_DELAY                                 0x14
-
-#define DEV_PTP_PREDICT_CFG                               0x18
-
-#define DEV_PTP_PREDICT_CFG_PTP_PHY_PREDICT_CFG(x)        (((x) << 4) & GENMASK(11, 4))
-#define DEV_PTP_PREDICT_CFG_PTP_PHY_PREDICT_CFG_M         GENMASK(11, 4)
-#define DEV_PTP_PREDICT_CFG_PTP_PHY_PREDICT_CFG_X(x)      (((x) & GENMASK(11, 4)) >> 4)
-#define DEV_PTP_PREDICT_CFG_PTP_PHASE_PREDICT_CFG(x)      ((x) & GENMASK(3, 0))
-#define DEV_PTP_PREDICT_CFG_PTP_PHASE_PREDICT_CFG_M       GENMASK(3, 0)
-
-#define DEV_MAC_ENA_CFG                                   0x1c
-
-#define DEV_MAC_ENA_CFG_RX_ENA                            BIT(4)
-#define DEV_MAC_ENA_CFG_TX_ENA                            BIT(0)
-
-#define DEV_MAC_MODE_CFG                                  0x20
-
-#define DEV_MAC_MODE_CFG_FC_WORD_SYNC_ENA                 BIT(8)
-#define DEV_MAC_MODE_CFG_GIGA_MODE_ENA                    BIT(4)
-#define DEV_MAC_MODE_CFG_FDX_ENA                          BIT(0)
-
-#define DEV_MAC_MAXLEN_CFG                                0x24
-
-#define DEV_MAC_TAGS_CFG                                  0x28
-
-#define DEV_MAC_TAGS_CFG_TAG_ID(x)                        (((x) << 16) & GENMASK(31, 16))
-#define DEV_MAC_TAGS_CFG_TAG_ID_M                         GENMASK(31, 16)
-#define DEV_MAC_TAGS_CFG_TAG_ID_X(x)                      (((x) & GENMASK(31, 16)) >> 16)
-#define DEV_MAC_TAGS_CFG_VLAN_LEN_AWR_ENA                 BIT(2)
-#define DEV_MAC_TAGS_CFG_PB_ENA                           BIT(1)
-#define DEV_MAC_TAGS_CFG_VLAN_AWR_ENA                     BIT(0)
-
-#define DEV_MAC_ADV_CHK_CFG                               0x2c
-
-#define DEV_MAC_ADV_CHK_CFG_LEN_DROP_ENA                  BIT(0)
-
-#define DEV_MAC_IFG_CFG                                   0x30
-
-#define DEV_MAC_IFG_CFG_RESTORE_OLD_IPG_CHECK             BIT(17)
-#define DEV_MAC_IFG_CFG_REDUCED_TX_IFG                    BIT(16)
-#define DEV_MAC_IFG_CFG_TX_IFG(x)                         (((x) << 8) & GENMASK(12, 8))
-#define DEV_MAC_IFG_CFG_TX_IFG_M                          GENMASK(12, 8)
-#define DEV_MAC_IFG_CFG_TX_IFG_X(x)                       (((x) & GENMASK(12, 8)) >> 8)
-#define DEV_MAC_IFG_CFG_RX_IFG2(x)                        (((x) << 4) & GENMASK(7, 4))
-#define DEV_MAC_IFG_CFG_RX_IFG2_M                         GENMASK(7, 4)
-#define DEV_MAC_IFG_CFG_RX_IFG2_X(x)                      (((x) & GENMASK(7, 4)) >> 4)
-#define DEV_MAC_IFG_CFG_RX_IFG1(x)                        ((x) & GENMASK(3, 0))
-#define DEV_MAC_IFG_CFG_RX_IFG1_M                         GENMASK(3, 0)
-
-#define DEV_MAC_HDX_CFG                                   0x34
-
-#define DEV_MAC_HDX_CFG_BYPASS_COL_SYNC                   BIT(26)
-#define DEV_MAC_HDX_CFG_OB_ENA                            BIT(25)
-#define DEV_MAC_HDX_CFG_WEXC_DIS                          BIT(24)
-#define DEV_MAC_HDX_CFG_SEED(x)                           (((x) << 16) & GENMASK(23, 16))
-#define DEV_MAC_HDX_CFG_SEED_M                            GENMASK(23, 16)
-#define DEV_MAC_HDX_CFG_SEED_X(x)                         (((x) & GENMASK(23, 16)) >> 16)
-#define DEV_MAC_HDX_CFG_SEED_LOAD                         BIT(12)
-#define DEV_MAC_HDX_CFG_RETRY_AFTER_EXC_COL_ENA           BIT(8)
-#define DEV_MAC_HDX_CFG_LATE_COL_POS(x)                   ((x) & GENMASK(6, 0))
-#define DEV_MAC_HDX_CFG_LATE_COL_POS_M                    GENMASK(6, 0)
-
-#define DEV_MAC_DBG_CFG                                   0x38
-
-#define DEV_MAC_DBG_CFG_TBI_MODE                          BIT(4)
-#define DEV_MAC_DBG_CFG_IFG_CRS_EXT_CHK_ENA               BIT(0)
-
-#define DEV_MAC_FC_MAC_LOW_CFG                            0x3c
-
-#define DEV_MAC_FC_MAC_HIGH_CFG                           0x40
-
-#define DEV_MAC_STICKY                                    0x44
-
-#define DEV_MAC_STICKY_RX_IPG_SHRINK_STICKY               BIT(9)
-#define DEV_MAC_STICKY_RX_PREAM_SHRINK_STICKY             BIT(8)
-#define DEV_MAC_STICKY_RX_CARRIER_EXT_STICKY              BIT(7)
-#define DEV_MAC_STICKY_RX_CARRIER_EXT_ERR_STICKY          BIT(6)
-#define DEV_MAC_STICKY_RX_JUNK_STICKY                     BIT(5)
-#define DEV_MAC_STICKY_TX_RETRANSMIT_STICKY               BIT(4)
-#define DEV_MAC_STICKY_TX_JAM_STICKY                      BIT(3)
-#define DEV_MAC_STICKY_TX_FIFO_OFLW_STICKY                BIT(2)
-#define DEV_MAC_STICKY_TX_FRM_LEN_OVR_STICKY              BIT(1)
-#define DEV_MAC_STICKY_TX_ABORT_STICKY                    BIT(0)
-
-#define PCS1G_CFG                                         0x48
-
-#define PCS1G_CFG_LINK_STATUS_TYPE                        BIT(4)
-#define PCS1G_CFG_AN_LINK_CTRL_ENA                        BIT(1)
-#define PCS1G_CFG_PCS_ENA                                 BIT(0)
-
-#define PCS1G_MODE_CFG                                    0x4c
-
-#define PCS1G_MODE_CFG_UNIDIR_MODE_ENA                    BIT(4)
-#define PCS1G_MODE_CFG_SGMII_MODE_ENA                     BIT(0)
-
-#define PCS1G_SD_CFG                                      0x50
-
-#define PCS1G_SD_CFG_SD_SEL                               BIT(8)
-#define PCS1G_SD_CFG_SD_POL                               BIT(4)
-#define PCS1G_SD_CFG_SD_ENA                               BIT(0)
-
-#define PCS1G_ANEG_CFG                                    0x54
-
-#define PCS1G_ANEG_CFG_ADV_ABILITY(x)                     (((x) << 16) & GENMASK(31, 16))
-#define PCS1G_ANEG_CFG_ADV_ABILITY_M                      GENMASK(31, 16)
-#define PCS1G_ANEG_CFG_ADV_ABILITY_X(x)                   (((x) & GENMASK(31, 16)) >> 16)
-#define PCS1G_ANEG_CFG_SW_RESOLVE_ENA                     BIT(8)
-#define PCS1G_ANEG_CFG_ANEG_RESTART_ONE_SHOT              BIT(1)
-#define PCS1G_ANEG_CFG_ANEG_ENA                           BIT(0)
-
-#define PCS1G_ANEG_NP_CFG                                 0x58
-
-#define PCS1G_ANEG_NP_CFG_NP_TX(x)                        (((x) << 16) & GENMASK(31, 16))
-#define PCS1G_ANEG_NP_CFG_NP_TX_M                         GENMASK(31, 16)
-#define PCS1G_ANEG_NP_CFG_NP_TX_X(x)                      (((x) & GENMASK(31, 16)) >> 16)
-#define PCS1G_ANEG_NP_CFG_NP_LOADED_ONE_SHOT              BIT(0)
-
-#define PCS1G_LB_CFG                                      0x5c
-
-#define PCS1G_LB_CFG_RA_ENA                               BIT(4)
-#define PCS1G_LB_CFG_GMII_PHY_LB_ENA                      BIT(1)
-#define PCS1G_LB_CFG_TBI_HOST_LB_ENA                      BIT(0)
-
-#define PCS1G_DBG_CFG                                     0x60
-
-#define PCS1G_DBG_CFG_UDLT                                BIT(0)
-
-#define PCS1G_CDET_CFG                                    0x64
-
-#define PCS1G_CDET_CFG_CDET_ENA                           BIT(0)
-
-#define PCS1G_ANEG_STATUS                                 0x68
-
-#define PCS1G_ANEG_STATUS_LP_ADV_ABILITY(x)               (((x) << 16) & GENMASK(31, 16))
-#define PCS1G_ANEG_STATUS_LP_ADV_ABILITY_M                GENMASK(31, 16)
-#define PCS1G_ANEG_STATUS_LP_ADV_ABILITY_X(x)             (((x) & GENMASK(31, 16)) >> 16)
-#define PCS1G_ANEG_STATUS_PR                              BIT(4)
-#define PCS1G_ANEG_STATUS_PAGE_RX_STICKY                  BIT(3)
-#define PCS1G_ANEG_STATUS_ANEG_COMPLETE                   BIT(0)
-
-#define PCS1G_ANEG_NP_STATUS                              0x6c
-
-#define PCS1G_LINK_STATUS                                 0x70
-
-#define PCS1G_LINK_STATUS_DELAY_VAR(x)                    (((x) << 12) & GENMASK(15, 12))
-#define PCS1G_LINK_STATUS_DELAY_VAR_M                     GENMASK(15, 12)
-#define PCS1G_LINK_STATUS_DELAY_VAR_X(x)                  (((x) & GENMASK(15, 12)) >> 12)
-#define PCS1G_LINK_STATUS_SIGNAL_DETECT                   BIT(8)
-#define PCS1G_LINK_STATUS_LINK_STATUS                     BIT(4)
-#define PCS1G_LINK_STATUS_SYNC_STATUS                     BIT(0)
-
-#define PCS1G_LINK_DOWN_CNT                               0x74
-
-#define PCS1G_STICKY                                      0x78
-
-#define PCS1G_STICKY_LINK_DOWN_STICKY                     BIT(4)
-#define PCS1G_STICKY_OUT_OF_SYNC_STICKY                   BIT(0)
-
-#define PCS1G_DEBUG_STATUS                                0x7c
-
-#define PCS1G_LPI_CFG                                     0x80
-
-#define PCS1G_LPI_CFG_QSGMII_MS_SEL                       BIT(20)
-#define PCS1G_LPI_CFG_RX_LPI_OUT_DIS                      BIT(17)
-#define PCS1G_LPI_CFG_LPI_TESTMODE                        BIT(16)
-#define PCS1G_LPI_CFG_LPI_RX_WTIM(x)                      (((x) << 4) & GENMASK(5, 4))
-#define PCS1G_LPI_CFG_LPI_RX_WTIM_M                       GENMASK(5, 4)
-#define PCS1G_LPI_CFG_LPI_RX_WTIM_X(x)                    (((x) & GENMASK(5, 4)) >> 4)
-#define PCS1G_LPI_CFG_TX_ASSERT_LPIDLE                    BIT(0)
-
-#define PCS1G_LPI_WAKE_ERROR_CNT                          0x84
-
-#define PCS1G_LPI_STATUS                                  0x88
-
-#define PCS1G_LPI_STATUS_RX_LPI_FAIL                      BIT(16)
-#define PCS1G_LPI_STATUS_RX_LPI_EVENT_STICKY              BIT(12)
-#define PCS1G_LPI_STATUS_RX_QUIET                         BIT(9)
-#define PCS1G_LPI_STATUS_RX_LPI_MODE                      BIT(8)
-#define PCS1G_LPI_STATUS_TX_LPI_EVENT_STICKY              BIT(4)
-#define PCS1G_LPI_STATUS_TX_QUIET                         BIT(1)
-#define PCS1G_LPI_STATUS_TX_LPI_MODE                      BIT(0)
-
-#define PCS1G_TSTPAT_MODE_CFG                             0x8c
-
-#define PCS1G_TSTPAT_STATUS                               0x90
-
-#define PCS1G_TSTPAT_STATUS_JTP_ERR_CNT(x)                (((x) << 8) & GENMASK(15, 8))
-#define PCS1G_TSTPAT_STATUS_JTP_ERR_CNT_M                 GENMASK(15, 8)
-#define PCS1G_TSTPAT_STATUS_JTP_ERR_CNT_X(x)              (((x) & GENMASK(15, 8)) >> 8)
-#define PCS1G_TSTPAT_STATUS_JTP_ERR                       BIT(4)
-#define PCS1G_TSTPAT_STATUS_JTP_LOCK                      BIT(0)
-
-#define DEV_PCS_FX100_CFG                                 0x94
-
-#define DEV_PCS_FX100_CFG_SD_SEL                          BIT(26)
-#define DEV_PCS_FX100_CFG_SD_POL                          BIT(25)
-#define DEV_PCS_FX100_CFG_SD_ENA                          BIT(24)
-#define DEV_PCS_FX100_CFG_LOOPBACK_ENA                    BIT(20)
-#define DEV_PCS_FX100_CFG_SWAP_MII_ENA                    BIT(16)
-#define DEV_PCS_FX100_CFG_RXBITSEL(x)                     (((x) << 12) & GENMASK(15, 12))
-#define DEV_PCS_FX100_CFG_RXBITSEL_M                      GENMASK(15, 12)
-#define DEV_PCS_FX100_CFG_RXBITSEL_X(x)                   (((x) & GENMASK(15, 12)) >> 12)
-#define DEV_PCS_FX100_CFG_SIGDET_CFG(x)                   (((x) << 9) & GENMASK(10, 9))
-#define DEV_PCS_FX100_CFG_SIGDET_CFG_M                    GENMASK(10, 9)
-#define DEV_PCS_FX100_CFG_SIGDET_CFG_X(x)                 (((x) & GENMASK(10, 9)) >> 9)
-#define DEV_PCS_FX100_CFG_LINKHYST_TM_ENA                 BIT(8)
-#define DEV_PCS_FX100_CFG_LINKHYSTTIMER(x)                (((x) << 4) & GENMASK(7, 4))
-#define DEV_PCS_FX100_CFG_LINKHYSTTIMER_M                 GENMASK(7, 4)
-#define DEV_PCS_FX100_CFG_LINKHYSTTIMER_X(x)              (((x) & GENMASK(7, 4)) >> 4)
-#define DEV_PCS_FX100_CFG_UNIDIR_MODE_ENA                 BIT(3)
-#define DEV_PCS_FX100_CFG_FEFCHK_ENA                      BIT(2)
-#define DEV_PCS_FX100_CFG_FEFGEN_ENA                      BIT(1)
-#define DEV_PCS_FX100_CFG_PCS_ENA                         BIT(0)
-
-#define DEV_PCS_FX100_STATUS                              0x98
-
-#define DEV_PCS_FX100_STATUS_EDGE_POS_PTP(x)              (((x) << 8) & GENMASK(11, 8))
-#define DEV_PCS_FX100_STATUS_EDGE_POS_PTP_M               GENMASK(11, 8)
-#define DEV_PCS_FX100_STATUS_EDGE_POS_PTP_X(x)            (((x) & GENMASK(11, 8)) >> 8)
-#define DEV_PCS_FX100_STATUS_PCS_ERROR_STICKY             BIT(7)
-#define DEV_PCS_FX100_STATUS_FEF_FOUND_STICKY             BIT(6)
-#define DEV_PCS_FX100_STATUS_SSD_ERROR_STICKY             BIT(5)
-#define DEV_PCS_FX100_STATUS_SYNC_LOST_STICKY             BIT(4)
-#define DEV_PCS_FX100_STATUS_FEF_STATUS                   BIT(2)
-#define DEV_PCS_FX100_STATUS_SIGNAL_DETECT                BIT(1)
-#define DEV_PCS_FX100_STATUS_SYNC_STATUS                  BIT(0)
-
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_dev_gmii.h b/drivers/net/ethernet/mscc/ocelot_dev_gmii.h
deleted file mode 100644
index 6aa40ea223a2..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_dev_gmii.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_DEV_GMII_H_
-#define _MSCC_OCELOT_DEV_GMII_H_
-
-#define DEV_GMII_PORT_MODE_CLOCK_CFG                      0x0
-
-#define DEV_GMII_PORT_MODE_CLOCK_CFG_MAC_TX_RST           BIT(5)
-#define DEV_GMII_PORT_MODE_CLOCK_CFG_MAC_RX_RST           BIT(4)
-#define DEV_GMII_PORT_MODE_CLOCK_CFG_PORT_RST             BIT(3)
-#define DEV_GMII_PORT_MODE_CLOCK_CFG_PHY_RST              BIT(2)
-#define DEV_GMII_PORT_MODE_CLOCK_CFG_LINK_SPEED(x)        ((x) & GENMASK(1, 0))
-#define DEV_GMII_PORT_MODE_CLOCK_CFG_LINK_SPEED_M         GENMASK(1, 0)
-
-#define DEV_GMII_PORT_MODE_PORT_MISC                      0x4
-
-#define DEV_GMII_PORT_MODE_PORT_MISC_MPLS_RX_ENA          BIT(5)
-#define DEV_GMII_PORT_MODE_PORT_MISC_FWD_ERROR_ENA        BIT(4)
-#define DEV_GMII_PORT_MODE_PORT_MISC_FWD_PAUSE_ENA        BIT(3)
-#define DEV_GMII_PORT_MODE_PORT_MISC_FWD_CTRL_ENA         BIT(2)
-#define DEV_GMII_PORT_MODE_PORT_MISC_GMII_LOOP_ENA        BIT(1)
-#define DEV_GMII_PORT_MODE_PORT_MISC_DEV_LOOP_ENA         BIT(0)
-
-#define DEV_GMII_PORT_MODE_EVENTS                         0x8
-
-#define DEV_GMII_PORT_MODE_EEE_CFG                        0xc
-
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_ENA                BIT(22)
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_AGE(x)       (((x) << 15) & GENMASK(21, 15))
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_AGE_M        GENMASK(21, 15)
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_AGE_X(x)     (((x) & GENMASK(21, 15)) >> 15)
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_WAKEUP(x)    (((x) << 8) & GENMASK(14, 8))
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_WAKEUP_M     GENMASK(14, 8)
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_WAKEUP_X(x)  (((x) & GENMASK(14, 8)) >> 8)
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_HOLDOFF(x)   (((x) << 1) & GENMASK(7, 1))
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_HOLDOFF_M    GENMASK(7, 1)
-#define DEV_GMII_PORT_MODE_EEE_CFG_EEE_TIMER_HOLDOFF_X(x) (((x) & GENMASK(7, 1)) >> 1)
-#define DEV_GMII_PORT_MODE_EEE_CFG_PORT_LPI               BIT(0)
-
-#define DEV_GMII_PORT_MODE_RX_PATH_DELAY                  0x10
-
-#define DEV_GMII_PORT_MODE_TX_PATH_DELAY                  0x14
-
-#define DEV_GMII_PORT_MODE_PTP_PREDICT_CFG                0x18
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_ENA_CFG               0x1c
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_ENA_CFG_RX_ENA        BIT(4)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_ENA_CFG_TX_ENA        BIT(0)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_MODE_CFG              0x20
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_MODE_CFG_FC_WORD_SYNC_ENA BIT(8)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_MODE_CFG_GIGA_MODE_ENA BIT(4)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_MODE_CFG_FDX_ENA      BIT(0)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_MAXLEN_CFG            0x24
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG              0x28
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG_TAG_ID(x)    (((x) << 16) & GENMASK(31, 16))
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG_TAG_ID_M     GENMASK(31, 16)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG_TAG_ID_X(x)  (((x) & GENMASK(31, 16)) >> 16)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG_PB_ENA       BIT(1)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG_VLAN_AWR_ENA BIT(0)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_TAGS_CFG_VLAN_LEN_AWR_ENA BIT(2)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_ADV_CHK_CFG           0x2c
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_ADV_CHK_CFG_LEN_DROP_ENA BIT(0)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG               0x30
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_RESTORE_OLD_IPG_CHECK BIT(17)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_REDUCED_TX_IFG BIT(16)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_TX_IFG(x)     (((x) << 8) & GENMASK(12, 8))
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_TX_IFG_M      GENMASK(12, 8)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_TX_IFG_X(x)   (((x) & GENMASK(12, 8)) >> 8)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_RX_IFG2(x)    (((x) << 4) & GENMASK(7, 4))
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_RX_IFG2_M     GENMASK(7, 4)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_RX_IFG2_X(x)  (((x) & GENMASK(7, 4)) >> 4)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_RX_IFG1(x)    ((x) & GENMASK(3, 0))
-#define DEV_GMII_MAC_CFG_STATUS_MAC_IFG_CFG_RX_IFG1_M     GENMASK(3, 0)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG               0x34
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_BYPASS_COL_SYNC BIT(26)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_OB_ENA        BIT(25)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_WEXC_DIS      BIT(24)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_SEED(x)       (((x) << 16) & GENMASK(23, 16))
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_SEED_M        GENMASK(23, 16)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_SEED_X(x)     (((x) & GENMASK(23, 16)) >> 16)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_SEED_LOAD     BIT(12)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_RETRY_AFTER_EXC_COL_ENA BIT(8)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_LATE_COL_POS(x) ((x) & GENMASK(6, 0))
-#define DEV_GMII_MAC_CFG_STATUS_MAC_HDX_CFG_LATE_COL_POS_M GENMASK(6, 0)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_DBG_CFG               0x38
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_DBG_CFG_TBI_MODE      BIT(4)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_DBG_CFG_IFG_CRS_EXT_CHK_ENA BIT(0)
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_FC_MAC_LOW_CFG        0x3c
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_FC_MAC_HIGH_CFG       0x40
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY                0x44
-
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_RX_IPG_SHRINK_STICKY BIT(9)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_RX_PREAM_SHRINK_STICKY BIT(8)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_RX_CARRIER_EXT_STICKY BIT(7)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_RX_CARRIER_EXT_ERR_STICKY BIT(6)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_RX_JUNK_STICKY BIT(5)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_TX_RETRANSMIT_STICKY BIT(4)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_TX_JAM_STICKY  BIT(3)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_TX_FIFO_OFLW_STICKY BIT(2)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_TX_FRM_LEN_OVR_STICKY BIT(1)
-#define DEV_GMII_MAC_CFG_STATUS_MAC_STICKY_TX_ABORT_STICKY BIT(0)
-
-#define DEV_GMII_MM_CONFIG_ENABLE_CONFIG                  0x48
-
-#define DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA        BIT(0)
-#define DEV_GMII_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA        BIT(4)
-#define DEV_GMII_MM_CONFIG_ENABLE_CONFIG_KEEP_S_AFTER_D   BIT(8)
-
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG                   0x4c
-
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_DIS    BIT(0)
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME(x) (((x) << 4) & GENMASK(11, 4))
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME_M GENMASK(11, 4)
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME_X(x) (((x) & GENMASK(11, 4)) >> 4)
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_VERIF_TIMER_UNITS(x) (((x) << 12) & GENMASK(13, 12))
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_VERIF_TIMER_UNITS_M GENMASK(13, 12)
-#define DEV_GMII_MM_CONFIG_VERIF_CONFIG_VERIF_TIMER_UNITS_X(x) (((x) & GENMASK(13, 12)) >> 12)
-
-#define DEV_GMII_MM_STATISTICS_MM_STATUS                  0x50
-
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STATUS BIT(0)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STICKY BIT(4)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_VERIFY_STATE(x) (((x) << 8) & GENMASK(10, 8))
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_VERIFY_STATE_M GENMASK(10, 8)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_PRMPT_VERIFY_STATE_X(x) (((x) & GENMASK(10, 8)) >> 8)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_UNEXP_RX_PFRM_STICKY BIT(12)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_UNEXP_TX_PFRM_STICKY BIT(16)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_MM_RX_FRAME_STATUS BIT(20)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_MM_TX_FRAME_STATUS BIT(24)
-#define DEV_GMII_MM_STATISTICS_MM_STATUS_MM_TX_PRMPT_STATUS BIT(28)
-
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_hsio.h b/drivers/net/ethernet/mscc/ocelot_hsio.h
deleted file mode 100644
index d93ddec3931b..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_hsio.h
+++ /dev/null
@@ -1,785 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_HSIO_H_
-#define _MSCC_OCELOT_HSIO_H_
-
-#define HSIO_PLL5G_CFG0_ENA_ROT                           BIT(31)
-#define HSIO_PLL5G_CFG0_ENA_LANE                          BIT(30)
-#define HSIO_PLL5G_CFG0_ENA_CLKTREE                       BIT(29)
-#define HSIO_PLL5G_CFG0_DIV4                              BIT(28)
-#define HSIO_PLL5G_CFG0_ENA_LOCK_FINE                     BIT(27)
-#define HSIO_PLL5G_CFG0_SELBGV820(x)                      (((x) << 23) & GENMASK(26, 23))
-#define HSIO_PLL5G_CFG0_SELBGV820_M                       GENMASK(26, 23)
-#define HSIO_PLL5G_CFG0_SELBGV820_X(x)                    (((x) & GENMASK(26, 23)) >> 23)
-#define HSIO_PLL5G_CFG0_LOOP_BW_RES(x)                    (((x) << 18) & GENMASK(22, 18))
-#define HSIO_PLL5G_CFG0_LOOP_BW_RES_M                     GENMASK(22, 18)
-#define HSIO_PLL5G_CFG0_LOOP_BW_RES_X(x)                  (((x) & GENMASK(22, 18)) >> 18)
-#define HSIO_PLL5G_CFG0_SELCPI(x)                         (((x) << 16) & GENMASK(17, 16))
-#define HSIO_PLL5G_CFG0_SELCPI_M                          GENMASK(17, 16)
-#define HSIO_PLL5G_CFG0_SELCPI_X(x)                       (((x) & GENMASK(17, 16)) >> 16)
-#define HSIO_PLL5G_CFG0_ENA_VCO_CONTRH                    BIT(15)
-#define HSIO_PLL5G_CFG0_ENA_CP1                           BIT(14)
-#define HSIO_PLL5G_CFG0_ENA_VCO_BUF                       BIT(13)
-#define HSIO_PLL5G_CFG0_ENA_BIAS                          BIT(12)
-#define HSIO_PLL5G_CFG0_CPU_CLK_DIV(x)                    (((x) << 6) & GENMASK(11, 6))
-#define HSIO_PLL5G_CFG0_CPU_CLK_DIV_M                     GENMASK(11, 6)
-#define HSIO_PLL5G_CFG0_CPU_CLK_DIV_X(x)                  (((x) & GENMASK(11, 6)) >> 6)
-#define HSIO_PLL5G_CFG0_CORE_CLK_DIV(x)                   ((x) & GENMASK(5, 0))
-#define HSIO_PLL5G_CFG0_CORE_CLK_DIV_M                    GENMASK(5, 0)
-
-#define HSIO_PLL5G_CFG1_ENA_DIRECT                        BIT(18)
-#define HSIO_PLL5G_CFG1_ROT_SPEED                         BIT(17)
-#define HSIO_PLL5G_CFG1_ROT_DIR                           BIT(16)
-#define HSIO_PLL5G_CFG1_READBACK_DATA_SEL                 BIT(15)
-#define HSIO_PLL5G_CFG1_RC_ENABLE                         BIT(14)
-#define HSIO_PLL5G_CFG1_RC_CTRL_DATA(x)                   (((x) << 6) & GENMASK(13, 6))
-#define HSIO_PLL5G_CFG1_RC_CTRL_DATA_M                    GENMASK(13, 6)
-#define HSIO_PLL5G_CFG1_RC_CTRL_DATA_X(x)                 (((x) & GENMASK(13, 6)) >> 6)
-#define HSIO_PLL5G_CFG1_QUARTER_RATE                      BIT(5)
-#define HSIO_PLL5G_CFG1_PWD_TX                            BIT(4)
-#define HSIO_PLL5G_CFG1_PWD_RX                            BIT(3)
-#define HSIO_PLL5G_CFG1_OUT_OF_RANGE_RECAL_ENA            BIT(2)
-#define HSIO_PLL5G_CFG1_HALF_RATE                         BIT(1)
-#define HSIO_PLL5G_CFG1_FORCE_SET_ENA                     BIT(0)
-
-#define HSIO_PLL5G_CFG2_ENA_TEST_MODE                     BIT(30)
-#define HSIO_PLL5G_CFG2_ENA_PFD_IN_FLIP                   BIT(29)
-#define HSIO_PLL5G_CFG2_ENA_VCO_NREF_TESTOUT              BIT(28)
-#define HSIO_PLL5G_CFG2_ENA_FBTESTOUT                     BIT(27)
-#define HSIO_PLL5G_CFG2_ENA_RCPLL                         BIT(26)
-#define HSIO_PLL5G_CFG2_ENA_CP2                           BIT(25)
-#define HSIO_PLL5G_CFG2_ENA_CLK_BYPASS1                   BIT(24)
-#define HSIO_PLL5G_CFG2_AMPC_SEL(x)                       (((x) << 16) & GENMASK(23, 16))
-#define HSIO_PLL5G_CFG2_AMPC_SEL_M                        GENMASK(23, 16)
-#define HSIO_PLL5G_CFG2_AMPC_SEL_X(x)                     (((x) & GENMASK(23, 16)) >> 16)
-#define HSIO_PLL5G_CFG2_ENA_CLK_BYPASS                    BIT(15)
-#define HSIO_PLL5G_CFG2_PWD_AMPCTRL_N                     BIT(14)
-#define HSIO_PLL5G_CFG2_ENA_AMPCTRL                       BIT(13)
-#define HSIO_PLL5G_CFG2_ENA_AMP_CTRL_FORCE                BIT(12)
-#define HSIO_PLL5G_CFG2_FRC_FSM_POR                       BIT(11)
-#define HSIO_PLL5G_CFG2_DISABLE_FSM_POR                   BIT(10)
-#define HSIO_PLL5G_CFG2_GAIN_TEST(x)                      (((x) << 5) & GENMASK(9, 5))
-#define HSIO_PLL5G_CFG2_GAIN_TEST_M                       GENMASK(9, 5)
-#define HSIO_PLL5G_CFG2_GAIN_TEST_X(x)                    (((x) & GENMASK(9, 5)) >> 5)
-#define HSIO_PLL5G_CFG2_EN_RESET_OVERRUN                  BIT(4)
-#define HSIO_PLL5G_CFG2_EN_RESET_LIM_DET                  BIT(3)
-#define HSIO_PLL5G_CFG2_EN_RESET_FRQ_DET                  BIT(2)
-#define HSIO_PLL5G_CFG2_DISABLE_FSM                       BIT(1)
-#define HSIO_PLL5G_CFG2_ENA_GAIN_TEST                     BIT(0)
-
-#define HSIO_PLL5G_CFG3_TEST_ANA_OUT_SEL(x)               (((x) << 22) & GENMASK(23, 22))
-#define HSIO_PLL5G_CFG3_TEST_ANA_OUT_SEL_M                GENMASK(23, 22)
-#define HSIO_PLL5G_CFG3_TEST_ANA_OUT_SEL_X(x)             (((x) & GENMASK(23, 22)) >> 22)
-#define HSIO_PLL5G_CFG3_TESTOUT_SEL(x)                    (((x) << 19) & GENMASK(21, 19))
-#define HSIO_PLL5G_CFG3_TESTOUT_SEL_M                     GENMASK(21, 19)
-#define HSIO_PLL5G_CFG3_TESTOUT_SEL_X(x)                  (((x) & GENMASK(21, 19)) >> 19)
-#define HSIO_PLL5G_CFG3_ENA_ANA_TEST_OUT                  BIT(18)
-#define HSIO_PLL5G_CFG3_ENA_TEST_OUT                      BIT(17)
-#define HSIO_PLL5G_CFG3_SEL_FBDCLK                        BIT(16)
-#define HSIO_PLL5G_CFG3_SEL_CML_CMOS_PFD                  BIT(15)
-#define HSIO_PLL5G_CFG3_RST_FB_N                          BIT(14)
-#define HSIO_PLL5G_CFG3_FORCE_VCO_CONTRH                  BIT(13)
-#define HSIO_PLL5G_CFG3_FORCE_LO                          BIT(12)
-#define HSIO_PLL5G_CFG3_FORCE_HI                          BIT(11)
-#define HSIO_PLL5G_CFG3_FORCE_ENA                         BIT(10)
-#define HSIO_PLL5G_CFG3_FORCE_CP                          BIT(9)
-#define HSIO_PLL5G_CFG3_FBDIVSEL_TST_ENA                  BIT(8)
-#define HSIO_PLL5G_CFG3_FBDIVSEL(x)                       ((x) & GENMASK(7, 0))
-#define HSIO_PLL5G_CFG3_FBDIVSEL_M                        GENMASK(7, 0)
-
-#define HSIO_PLL5G_CFG4_IB_BIAS_CTRL(x)                   (((x) << 16) & GENMASK(23, 16))
-#define HSIO_PLL5G_CFG4_IB_BIAS_CTRL_M                    GENMASK(23, 16)
-#define HSIO_PLL5G_CFG4_IB_BIAS_CTRL_X(x)                 (((x) & GENMASK(23, 16)) >> 16)
-#define HSIO_PLL5G_CFG4_IB_CTRL(x)                        ((x) & GENMASK(15, 0))
-#define HSIO_PLL5G_CFG4_IB_CTRL_M                         GENMASK(15, 0)
-
-#define HSIO_PLL5G_CFG5_OB_BIAS_CTRL(x)                   (((x) << 16) & GENMASK(23, 16))
-#define HSIO_PLL5G_CFG5_OB_BIAS_CTRL_M                    GENMASK(23, 16)
-#define HSIO_PLL5G_CFG5_OB_BIAS_CTRL_X(x)                 (((x) & GENMASK(23, 16)) >> 16)
-#define HSIO_PLL5G_CFG5_OB_CTRL(x)                        ((x) & GENMASK(15, 0))
-#define HSIO_PLL5G_CFG5_OB_CTRL_M                         GENMASK(15, 0)
-
-#define HSIO_PLL5G_CFG6_REFCLK_SEL_SRC                    BIT(23)
-#define HSIO_PLL5G_CFG6_REFCLK_SEL(x)                     (((x) << 20) & GENMASK(22, 20))
-#define HSIO_PLL5G_CFG6_REFCLK_SEL_M                      GENMASK(22, 20)
-#define HSIO_PLL5G_CFG6_REFCLK_SEL_X(x)                   (((x) & GENMASK(22, 20)) >> 20)
-#define HSIO_PLL5G_CFG6_REFCLK_SRC                        BIT(19)
-#define HSIO_PLL5G_CFG6_POR_DEL_SEL(x)                    (((x) << 16) & GENMASK(17, 16))
-#define HSIO_PLL5G_CFG6_POR_DEL_SEL_M                     GENMASK(17, 16)
-#define HSIO_PLL5G_CFG6_POR_DEL_SEL_X(x)                  (((x) & GENMASK(17, 16)) >> 16)
-#define HSIO_PLL5G_CFG6_DIV125REF_SEL(x)                  (((x) << 8) & GENMASK(15, 8))
-#define HSIO_PLL5G_CFG6_DIV125REF_SEL_M                   GENMASK(15, 8)
-#define HSIO_PLL5G_CFG6_DIV125REF_SEL_X(x)                (((x) & GENMASK(15, 8)) >> 8)
-#define HSIO_PLL5G_CFG6_ENA_REFCLKC2                      BIT(7)
-#define HSIO_PLL5G_CFG6_ENA_FBCLKC2                       BIT(6)
-#define HSIO_PLL5G_CFG6_DDR_CLK_DIV(x)                    ((x) & GENMASK(5, 0))
-#define HSIO_PLL5G_CFG6_DDR_CLK_DIV_M                     GENMASK(5, 0)
-
-#define HSIO_PLL5G_STATUS0_RANGE_LIM                      BIT(12)
-#define HSIO_PLL5G_STATUS0_OUT_OF_RANGE_ERR               BIT(11)
-#define HSIO_PLL5G_STATUS0_CALIBRATION_ERR                BIT(10)
-#define HSIO_PLL5G_STATUS0_CALIBRATION_DONE               BIT(9)
-#define HSIO_PLL5G_STATUS0_READBACK_DATA(x)               (((x) << 1) & GENMASK(8, 1))
-#define HSIO_PLL5G_STATUS0_READBACK_DATA_M                GENMASK(8, 1)
-#define HSIO_PLL5G_STATUS0_READBACK_DATA_X(x)             (((x) & GENMASK(8, 1)) >> 1)
-#define HSIO_PLL5G_STATUS0_LOCK_STATUS                    BIT(0)
-
-#define HSIO_PLL5G_STATUS1_SIG_DEL(x)                     (((x) << 21) & GENMASK(28, 21))
-#define HSIO_PLL5G_STATUS1_SIG_DEL_M                      GENMASK(28, 21)
-#define HSIO_PLL5G_STATUS1_SIG_DEL_X(x)                   (((x) & GENMASK(28, 21)) >> 21)
-#define HSIO_PLL5G_STATUS1_GAIN_STAT(x)                   (((x) << 16) & GENMASK(20, 16))
-#define HSIO_PLL5G_STATUS1_GAIN_STAT_M                    GENMASK(20, 16)
-#define HSIO_PLL5G_STATUS1_GAIN_STAT_X(x)                 (((x) & GENMASK(20, 16)) >> 16)
-#define HSIO_PLL5G_STATUS1_FBCNT_DIF(x)                   (((x) << 4) & GENMASK(13, 4))
-#define HSIO_PLL5G_STATUS1_FBCNT_DIF_M                    GENMASK(13, 4)
-#define HSIO_PLL5G_STATUS1_FBCNT_DIF_X(x)                 (((x) & GENMASK(13, 4)) >> 4)
-#define HSIO_PLL5G_STATUS1_FSM_STAT(x)                    (((x) << 1) & GENMASK(3, 1))
-#define HSIO_PLL5G_STATUS1_FSM_STAT_M                     GENMASK(3, 1)
-#define HSIO_PLL5G_STATUS1_FSM_STAT_X(x)                  (((x) & GENMASK(3, 1)) >> 1)
-#define HSIO_PLL5G_STATUS1_FSM_LOCK                       BIT(0)
-
-#define HSIO_PLL5G_BIST_CFG0_PLLB_START_BIST              BIT(31)
-#define HSIO_PLL5G_BIST_CFG0_PLLB_MEAS_MODE               BIT(30)
-#define HSIO_PLL5G_BIST_CFG0_PLLB_LOCK_REPEAT(x)          (((x) << 20) & GENMASK(23, 20))
-#define HSIO_PLL5G_BIST_CFG0_PLLB_LOCK_REPEAT_M           GENMASK(23, 20)
-#define HSIO_PLL5G_BIST_CFG0_PLLB_LOCK_REPEAT_X(x)        (((x) & GENMASK(23, 20)) >> 20)
-#define HSIO_PLL5G_BIST_CFG0_PLLB_LOCK_UNCERT(x)          (((x) << 16) & GENMASK(19, 16))
-#define HSIO_PLL5G_BIST_CFG0_PLLB_LOCK_UNCERT_M           GENMASK(19, 16)
-#define HSIO_PLL5G_BIST_CFG0_PLLB_LOCK_UNCERT_X(x)        (((x) & GENMASK(19, 16)) >> 16)
-#define HSIO_PLL5G_BIST_CFG0_PLLB_DIV_FACTOR_PRE(x)       ((x) & GENMASK(15, 0))
-#define HSIO_PLL5G_BIST_CFG0_PLLB_DIV_FACTOR_PRE_M        GENMASK(15, 0)
-
-#define HSIO_PLL5G_BIST_STAT0_PLLB_FSM_STAT(x)            (((x) << 4) & GENMASK(7, 4))
-#define HSIO_PLL5G_BIST_STAT0_PLLB_FSM_STAT_M             GENMASK(7, 4)
-#define HSIO_PLL5G_BIST_STAT0_PLLB_FSM_STAT_X(x)          (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_PLL5G_BIST_STAT0_PLLB_BUSY                   BIT(2)
-#define HSIO_PLL5G_BIST_STAT0_PLLB_DONE_N                 BIT(1)
-#define HSIO_PLL5G_BIST_STAT0_PLLB_FAIL                   BIT(0)
-
-#define HSIO_PLL5G_BIST_STAT1_PLLB_CNT_OUT(x)             (((x) << 16) & GENMASK(31, 16))
-#define HSIO_PLL5G_BIST_STAT1_PLLB_CNT_OUT_M              GENMASK(31, 16)
-#define HSIO_PLL5G_BIST_STAT1_PLLB_CNT_OUT_X(x)           (((x) & GENMASK(31, 16)) >> 16)
-#define HSIO_PLL5G_BIST_STAT1_PLLB_CNT_REF_DIFF(x)        ((x) & GENMASK(15, 0))
-#define HSIO_PLL5G_BIST_STAT1_PLLB_CNT_REF_DIFF_M         GENMASK(15, 0)
-
-#define HSIO_RCOMP_CFG0_PWD_ENA                           BIT(13)
-#define HSIO_RCOMP_CFG0_RUN_CAL                           BIT(12)
-#define HSIO_RCOMP_CFG0_SPEED_SEL(x)                      (((x) << 10) & GENMASK(11, 10))
-#define HSIO_RCOMP_CFG0_SPEED_SEL_M                       GENMASK(11, 10)
-#define HSIO_RCOMP_CFG0_SPEED_SEL_X(x)                    (((x) & GENMASK(11, 10)) >> 10)
-#define HSIO_RCOMP_CFG0_MODE_SEL(x)                       (((x) << 8) & GENMASK(9, 8))
-#define HSIO_RCOMP_CFG0_MODE_SEL_M                        GENMASK(9, 8)
-#define HSIO_RCOMP_CFG0_MODE_SEL_X(x)                     (((x) & GENMASK(9, 8)) >> 8)
-#define HSIO_RCOMP_CFG0_FORCE_ENA                         BIT(4)
-#define HSIO_RCOMP_CFG0_RCOMP_VAL(x)                      ((x) & GENMASK(3, 0))
-#define HSIO_RCOMP_CFG0_RCOMP_VAL_M                       GENMASK(3, 0)
-
-#define HSIO_RCOMP_STATUS_BUSY                            BIT(12)
-#define HSIO_RCOMP_STATUS_DELTA_ALERT                     BIT(7)
-#define HSIO_RCOMP_STATUS_RCOMP(x)                        ((x) & GENMASK(3, 0))
-#define HSIO_RCOMP_STATUS_RCOMP_M                         GENMASK(3, 0)
-
-#define HSIO_SYNC_ETH_CFG_RSZ                             0x4
-
-#define HSIO_SYNC_ETH_CFG_SEL_RECO_CLK_SRC(x)             (((x) << 4) & GENMASK(7, 4))
-#define HSIO_SYNC_ETH_CFG_SEL_RECO_CLK_SRC_M              GENMASK(7, 4)
-#define HSIO_SYNC_ETH_CFG_SEL_RECO_CLK_SRC_X(x)           (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_SYNC_ETH_CFG_SEL_RECO_CLK_DIV(x)             (((x) << 1) & GENMASK(3, 1))
-#define HSIO_SYNC_ETH_CFG_SEL_RECO_CLK_DIV_M              GENMASK(3, 1)
-#define HSIO_SYNC_ETH_CFG_SEL_RECO_CLK_DIV_X(x)           (((x) & GENMASK(3, 1)) >> 1)
-#define HSIO_SYNC_ETH_CFG_RECO_CLK_ENA                    BIT(0)
-
-#define HSIO_SYNC_ETH_PLL_CFG_PLL_AUTO_SQUELCH_ENA        BIT(0)
-
-#define HSIO_S1G_DES_CFG_DES_PHS_CTRL(x)                  (((x) << 13) & GENMASK(16, 13))
-#define HSIO_S1G_DES_CFG_DES_PHS_CTRL_M                   GENMASK(16, 13)
-#define HSIO_S1G_DES_CFG_DES_PHS_CTRL_X(x)                (((x) & GENMASK(16, 13)) >> 13)
-#define HSIO_S1G_DES_CFG_DES_CPMD_SEL(x)                  (((x) << 11) & GENMASK(12, 11))
-#define HSIO_S1G_DES_CFG_DES_CPMD_SEL_M                   GENMASK(12, 11)
-#define HSIO_S1G_DES_CFG_DES_CPMD_SEL_X(x)                (((x) & GENMASK(12, 11)) >> 11)
-#define HSIO_S1G_DES_CFG_DES_MBTR_CTRL(x)                 (((x) << 8) & GENMASK(10, 8))
-#define HSIO_S1G_DES_CFG_DES_MBTR_CTRL_M                  GENMASK(10, 8)
-#define HSIO_S1G_DES_CFG_DES_MBTR_CTRL_X(x)               (((x) & GENMASK(10, 8)) >> 8)
-#define HSIO_S1G_DES_CFG_DES_BW_ANA(x)                    (((x) << 5) & GENMASK(7, 5))
-#define HSIO_S1G_DES_CFG_DES_BW_ANA_M                     GENMASK(7, 5)
-#define HSIO_S1G_DES_CFG_DES_BW_ANA_X(x)                  (((x) & GENMASK(7, 5)) >> 5)
-#define HSIO_S1G_DES_CFG_DES_SWAP_ANA                     BIT(4)
-#define HSIO_S1G_DES_CFG_DES_BW_HYST(x)                   (((x) << 1) & GENMASK(3, 1))
-#define HSIO_S1G_DES_CFG_DES_BW_HYST_M                    GENMASK(3, 1)
-#define HSIO_S1G_DES_CFG_DES_BW_HYST_X(x)                 (((x) & GENMASK(3, 1)) >> 1)
-#define HSIO_S1G_DES_CFG_DES_SWAP_HYST                    BIT(0)
-
-#define HSIO_S1G_IB_CFG_IB_FX100_ENA                      BIT(27)
-#define HSIO_S1G_IB_CFG_ACJTAG_HYST(x)                    (((x) << 24) & GENMASK(26, 24))
-#define HSIO_S1G_IB_CFG_ACJTAG_HYST_M                     GENMASK(26, 24)
-#define HSIO_S1G_IB_CFG_ACJTAG_HYST_X(x)                  (((x) & GENMASK(26, 24)) >> 24)
-#define HSIO_S1G_IB_CFG_IB_DET_LEV(x)                     (((x) << 19) & GENMASK(21, 19))
-#define HSIO_S1G_IB_CFG_IB_DET_LEV_M                      GENMASK(21, 19)
-#define HSIO_S1G_IB_CFG_IB_DET_LEV_X(x)                   (((x) & GENMASK(21, 19)) >> 19)
-#define HSIO_S1G_IB_CFG_IB_HYST_LEV                       BIT(14)
-#define HSIO_S1G_IB_CFG_IB_ENA_CMV_TERM                   BIT(13)
-#define HSIO_S1G_IB_CFG_IB_ENA_DC_COUPLING                BIT(12)
-#define HSIO_S1G_IB_CFG_IB_ENA_DETLEV                     BIT(11)
-#define HSIO_S1G_IB_CFG_IB_ENA_HYST                       BIT(10)
-#define HSIO_S1G_IB_CFG_IB_ENA_OFFSET_COMP                BIT(9)
-#define HSIO_S1G_IB_CFG_IB_EQ_GAIN(x)                     (((x) << 6) & GENMASK(8, 6))
-#define HSIO_S1G_IB_CFG_IB_EQ_GAIN_M                      GENMASK(8, 6)
-#define HSIO_S1G_IB_CFG_IB_EQ_GAIN_X(x)                   (((x) & GENMASK(8, 6)) >> 6)
-#define HSIO_S1G_IB_CFG_IB_SEL_CORNER_FREQ(x)             (((x) << 4) & GENMASK(5, 4))
-#define HSIO_S1G_IB_CFG_IB_SEL_CORNER_FREQ_M              GENMASK(5, 4)
-#define HSIO_S1G_IB_CFG_IB_SEL_CORNER_FREQ_X(x)           (((x) & GENMASK(5, 4)) >> 4)
-#define HSIO_S1G_IB_CFG_IB_RESISTOR_CTRL(x)               ((x) & GENMASK(3, 0))
-#define HSIO_S1G_IB_CFG_IB_RESISTOR_CTRL_M                GENMASK(3, 0)
-
-#define HSIO_S1G_OB_CFG_OB_SLP(x)                         (((x) << 17) & GENMASK(18, 17))
-#define HSIO_S1G_OB_CFG_OB_SLP_M                          GENMASK(18, 17)
-#define HSIO_S1G_OB_CFG_OB_SLP_X(x)                       (((x) & GENMASK(18, 17)) >> 17)
-#define HSIO_S1G_OB_CFG_OB_AMP_CTRL(x)                    (((x) << 13) & GENMASK(16, 13))
-#define HSIO_S1G_OB_CFG_OB_AMP_CTRL_M                     GENMASK(16, 13)
-#define HSIO_S1G_OB_CFG_OB_AMP_CTRL_X(x)                  (((x) & GENMASK(16, 13)) >> 13)
-#define HSIO_S1G_OB_CFG_OB_CMM_BIAS_CTRL(x)               (((x) << 10) & GENMASK(12, 10))
-#define HSIO_S1G_OB_CFG_OB_CMM_BIAS_CTRL_M                GENMASK(12, 10)
-#define HSIO_S1G_OB_CFG_OB_CMM_BIAS_CTRL_X(x)             (((x) & GENMASK(12, 10)) >> 10)
-#define HSIO_S1G_OB_CFG_OB_DIS_VCM_CTRL                   BIT(9)
-#define HSIO_S1G_OB_CFG_OB_EN_MEAS_VREG                   BIT(8)
-#define HSIO_S1G_OB_CFG_OB_VCM_CTRL(x)                    (((x) << 4) & GENMASK(7, 4))
-#define HSIO_S1G_OB_CFG_OB_VCM_CTRL_M                     GENMASK(7, 4)
-#define HSIO_S1G_OB_CFG_OB_VCM_CTRL_X(x)                  (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_S1G_OB_CFG_OB_RESISTOR_CTRL(x)               ((x) & GENMASK(3, 0))
-#define HSIO_S1G_OB_CFG_OB_RESISTOR_CTRL_M                GENMASK(3, 0)
-
-#define HSIO_S1G_SER_CFG_SER_IDLE                         BIT(9)
-#define HSIO_S1G_SER_CFG_SER_DEEMPH                       BIT(8)
-#define HSIO_S1G_SER_CFG_SER_CPMD_SEL                     BIT(7)
-#define HSIO_S1G_SER_CFG_SER_SWAP_CPMD                    BIT(6)
-#define HSIO_S1G_SER_CFG_SER_ALISEL(x)                    (((x) << 4) & GENMASK(5, 4))
-#define HSIO_S1G_SER_CFG_SER_ALISEL_M                     GENMASK(5, 4)
-#define HSIO_S1G_SER_CFG_SER_ALISEL_X(x)                  (((x) & GENMASK(5, 4)) >> 4)
-#define HSIO_S1G_SER_CFG_SER_ENHYS                        BIT(3)
-#define HSIO_S1G_SER_CFG_SER_BIG_WIN                      BIT(2)
-#define HSIO_S1G_SER_CFG_SER_EN_WIN                       BIT(1)
-#define HSIO_S1G_SER_CFG_SER_ENALI                        BIT(0)
-
-#define HSIO_S1G_COMMON_CFG_SYS_RST                       BIT(31)
-#define HSIO_S1G_COMMON_CFG_SE_AUTO_SQUELCH_ENA           BIT(21)
-#define HSIO_S1G_COMMON_CFG_ENA_LANE                      BIT(18)
-#define HSIO_S1G_COMMON_CFG_PWD_RX                        BIT(17)
-#define HSIO_S1G_COMMON_CFG_PWD_TX                        BIT(16)
-#define HSIO_S1G_COMMON_CFG_LANE_CTRL(x)                  (((x) << 13) & GENMASK(15, 13))
-#define HSIO_S1G_COMMON_CFG_LANE_CTRL_M                   GENMASK(15, 13)
-#define HSIO_S1G_COMMON_CFG_LANE_CTRL_X(x)                (((x) & GENMASK(15, 13)) >> 13)
-#define HSIO_S1G_COMMON_CFG_ENA_DIRECT                    BIT(12)
-#define HSIO_S1G_COMMON_CFG_ENA_ELOOP                     BIT(11)
-#define HSIO_S1G_COMMON_CFG_ENA_FLOOP                     BIT(10)
-#define HSIO_S1G_COMMON_CFG_ENA_ILOOP                     BIT(9)
-#define HSIO_S1G_COMMON_CFG_ENA_PLOOP                     BIT(8)
-#define HSIO_S1G_COMMON_CFG_HRATE                         BIT(7)
-#define HSIO_S1G_COMMON_CFG_IF_MODE                       BIT(0)
-
-#define HSIO_S1G_PLL_CFG_PLL_ENA_FB_DIV2                  BIT(22)
-#define HSIO_S1G_PLL_CFG_PLL_ENA_RC_DIV2                  BIT(21)
-#define HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA(x)             (((x) << 8) & GENMASK(15, 8))
-#define HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA_M              GENMASK(15, 8)
-#define HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA_X(x)           (((x) & GENMASK(15, 8)) >> 8)
-#define HSIO_S1G_PLL_CFG_PLL_FSM_ENA                      BIT(7)
-#define HSIO_S1G_PLL_CFG_PLL_FSM_FORCE_SET_ENA            BIT(6)
-#define HSIO_S1G_PLL_CFG_PLL_FSM_OOR_RECAL_ENA            BIT(5)
-#define HSIO_S1G_PLL_CFG_PLL_RB_DATA_SEL                  BIT(3)
-
-#define HSIO_S1G_PLL_STATUS_PLL_CAL_NOT_DONE              BIT(12)
-#define HSIO_S1G_PLL_STATUS_PLL_CAL_ERR                   BIT(11)
-#define HSIO_S1G_PLL_STATUS_PLL_OUT_OF_RANGE_ERR          BIT(10)
-#define HSIO_S1G_PLL_STATUS_PLL_RB_DATA(x)                ((x) & GENMASK(7, 0))
-#define HSIO_S1G_PLL_STATUS_PLL_RB_DATA_M                 GENMASK(7, 0)
-
-#define HSIO_S1G_DFT_CFG0_LAZYBIT                         BIT(31)
-#define HSIO_S1G_DFT_CFG0_INV_DIS                         BIT(23)
-#define HSIO_S1G_DFT_CFG0_PRBS_SEL(x)                     (((x) << 20) & GENMASK(21, 20))
-#define HSIO_S1G_DFT_CFG0_PRBS_SEL_M                      GENMASK(21, 20)
-#define HSIO_S1G_DFT_CFG0_PRBS_SEL_X(x)                   (((x) & GENMASK(21, 20)) >> 20)
-#define HSIO_S1G_DFT_CFG0_TEST_MODE(x)                    (((x) << 16) & GENMASK(18, 16))
-#define HSIO_S1G_DFT_CFG0_TEST_MODE_M                     GENMASK(18, 16)
-#define HSIO_S1G_DFT_CFG0_TEST_MODE_X(x)                  (((x) & GENMASK(18, 16)) >> 16)
-#define HSIO_S1G_DFT_CFG0_RX_PHS_CORR_DIS                 BIT(4)
-#define HSIO_S1G_DFT_CFG0_RX_PDSENS_ENA                   BIT(3)
-#define HSIO_S1G_DFT_CFG0_RX_DFT_ENA                      BIT(2)
-#define HSIO_S1G_DFT_CFG0_TX_DFT_ENA                      BIT(0)
-
-#define HSIO_S1G_DFT_CFG1_TX_JITTER_AMPL(x)               (((x) << 8) & GENMASK(17, 8))
-#define HSIO_S1G_DFT_CFG1_TX_JITTER_AMPL_M                GENMASK(17, 8)
-#define HSIO_S1G_DFT_CFG1_TX_JITTER_AMPL_X(x)             (((x) & GENMASK(17, 8)) >> 8)
-#define HSIO_S1G_DFT_CFG1_TX_STEP_FREQ(x)                 (((x) << 4) & GENMASK(7, 4))
-#define HSIO_S1G_DFT_CFG1_TX_STEP_FREQ_M                  GENMASK(7, 4)
-#define HSIO_S1G_DFT_CFG1_TX_STEP_FREQ_X(x)               (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_S1G_DFT_CFG1_TX_JI_ENA                       BIT(3)
-#define HSIO_S1G_DFT_CFG1_TX_WAVEFORM_SEL                 BIT(2)
-#define HSIO_S1G_DFT_CFG1_TX_FREQOFF_DIR                  BIT(1)
-#define HSIO_S1G_DFT_CFG1_TX_FREQOFF_ENA                  BIT(0)
-
-#define HSIO_S1G_DFT_CFG2_RX_JITTER_AMPL(x)               (((x) << 8) & GENMASK(17, 8))
-#define HSIO_S1G_DFT_CFG2_RX_JITTER_AMPL_M                GENMASK(17, 8)
-#define HSIO_S1G_DFT_CFG2_RX_JITTER_AMPL_X(x)             (((x) & GENMASK(17, 8)) >> 8)
-#define HSIO_S1G_DFT_CFG2_RX_STEP_FREQ(x)                 (((x) << 4) & GENMASK(7, 4))
-#define HSIO_S1G_DFT_CFG2_RX_STEP_FREQ_M                  GENMASK(7, 4)
-#define HSIO_S1G_DFT_CFG2_RX_STEP_FREQ_X(x)               (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_S1G_DFT_CFG2_RX_JI_ENA                       BIT(3)
-#define HSIO_S1G_DFT_CFG2_RX_WAVEFORM_SEL                 BIT(2)
-#define HSIO_S1G_DFT_CFG2_RX_FREQOFF_DIR                  BIT(1)
-#define HSIO_S1G_DFT_CFG2_RX_FREQOFF_ENA                  BIT(0)
-
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_ENA             BIT(20)
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_FBS_HIGH(x)     (((x) << 16) & GENMASK(17, 16))
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_FBS_HIGH_M      GENMASK(17, 16)
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_FBS_HIGH_X(x)   (((x) & GENMASK(17, 16)) >> 16)
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_HIGH(x)         (((x) << 8) & GENMASK(15, 8))
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_HIGH_M          GENMASK(15, 8)
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_HIGH_X(x)       (((x) & GENMASK(15, 8)) >> 8)
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_LOW(x)          ((x) & GENMASK(7, 0))
-#define HSIO_S1G_RC_PLL_BIST_CFG_PLL_BIST_LOW_M           GENMASK(7, 0)
-
-#define HSIO_S1G_MISC_CFG_DES_100FX_KICK_MODE(x)          (((x) << 11) & GENMASK(12, 11))
-#define HSIO_S1G_MISC_CFG_DES_100FX_KICK_MODE_M           GENMASK(12, 11)
-#define HSIO_S1G_MISC_CFG_DES_100FX_KICK_MODE_X(x)        (((x) & GENMASK(12, 11)) >> 11)
-#define HSIO_S1G_MISC_CFG_DES_100FX_CPMD_SWAP             BIT(10)
-#define HSIO_S1G_MISC_CFG_DES_100FX_CPMD_MODE             BIT(9)
-#define HSIO_S1G_MISC_CFG_DES_100FX_CPMD_ENA              BIT(8)
-#define HSIO_S1G_MISC_CFG_RX_LPI_MODE_ENA                 BIT(5)
-#define HSIO_S1G_MISC_CFG_TX_LPI_MODE_ENA                 BIT(4)
-#define HSIO_S1G_MISC_CFG_RX_DATA_INV_ENA                 BIT(3)
-#define HSIO_S1G_MISC_CFG_TX_DATA_INV_ENA                 BIT(2)
-#define HSIO_S1G_MISC_CFG_LANE_RST                        BIT(0)
-
-#define HSIO_S1G_DFT_STATUS_PLL_BIST_NOT_DONE             BIT(7)
-#define HSIO_S1G_DFT_STATUS_PLL_BIST_FAILED               BIT(6)
-#define HSIO_S1G_DFT_STATUS_PLL_BIST_TIMEOUT_ERR          BIT(5)
-#define HSIO_S1G_DFT_STATUS_BIST_ACTIVE                   BIT(3)
-#define HSIO_S1G_DFT_STATUS_BIST_NOSYNC                   BIT(2)
-#define HSIO_S1G_DFT_STATUS_BIST_COMPLETE_N               BIT(1)
-#define HSIO_S1G_DFT_STATUS_BIST_ERROR                    BIT(0)
-
-#define HSIO_S1G_MISC_STATUS_DES_100FX_PHASE_SEL          BIT(0)
-
-#define HSIO_MCB_S1G_ADDR_CFG_SERDES1G_WR_ONE_SHOT        BIT(31)
-#define HSIO_MCB_S1G_ADDR_CFG_SERDES1G_RD_ONE_SHOT        BIT(30)
-#define HSIO_MCB_S1G_ADDR_CFG_SERDES1G_ADDR(x)            ((x) & GENMASK(8, 0))
-#define HSIO_MCB_S1G_ADDR_CFG_SERDES1G_ADDR_M             GENMASK(8, 0)
-
-#define HSIO_S6G_DIG_CFG_GP(x)                            (((x) << 16) & GENMASK(18, 16))
-#define HSIO_S6G_DIG_CFG_GP_M                             GENMASK(18, 16)
-#define HSIO_S6G_DIG_CFG_GP_X(x)                          (((x) & GENMASK(18, 16)) >> 16)
-#define HSIO_S6G_DIG_CFG_TX_BIT_DOUBLING_MODE_ENA         BIT(7)
-#define HSIO_S6G_DIG_CFG_SIGDET_TESTMODE                  BIT(6)
-#define HSIO_S6G_DIG_CFG_SIGDET_AST(x)                    (((x) << 3) & GENMASK(5, 3))
-#define HSIO_S6G_DIG_CFG_SIGDET_AST_M                     GENMASK(5, 3)
-#define HSIO_S6G_DIG_CFG_SIGDET_AST_X(x)                  (((x) & GENMASK(5, 3)) >> 3)
-#define HSIO_S6G_DIG_CFG_SIGDET_DST(x)                    ((x) & GENMASK(2, 0))
-#define HSIO_S6G_DIG_CFG_SIGDET_DST_M                     GENMASK(2, 0)
-
-#define HSIO_S6G_DFT_CFG0_LAZYBIT                         BIT(31)
-#define HSIO_S6G_DFT_CFG0_INV_DIS                         BIT(23)
-#define HSIO_S6G_DFT_CFG0_PRBS_SEL(x)                     (((x) << 20) & GENMASK(21, 20))
-#define HSIO_S6G_DFT_CFG0_PRBS_SEL_M                      GENMASK(21, 20)
-#define HSIO_S6G_DFT_CFG0_PRBS_SEL_X(x)                   (((x) & GENMASK(21, 20)) >> 20)
-#define HSIO_S6G_DFT_CFG0_TEST_MODE(x)                    (((x) << 16) & GENMASK(18, 16))
-#define HSIO_S6G_DFT_CFG0_TEST_MODE_M                     GENMASK(18, 16)
-#define HSIO_S6G_DFT_CFG0_TEST_MODE_X(x)                  (((x) & GENMASK(18, 16)) >> 16)
-#define HSIO_S6G_DFT_CFG0_RX_PHS_CORR_DIS                 BIT(4)
-#define HSIO_S6G_DFT_CFG0_RX_PDSENS_ENA                   BIT(3)
-#define HSIO_S6G_DFT_CFG0_RX_DFT_ENA                      BIT(2)
-#define HSIO_S6G_DFT_CFG0_TX_DFT_ENA                      BIT(0)
-
-#define HSIO_S6G_DFT_CFG1_TX_JITTER_AMPL(x)               (((x) << 8) & GENMASK(17, 8))
-#define HSIO_S6G_DFT_CFG1_TX_JITTER_AMPL_M                GENMASK(17, 8)
-#define HSIO_S6G_DFT_CFG1_TX_JITTER_AMPL_X(x)             (((x) & GENMASK(17, 8)) >> 8)
-#define HSIO_S6G_DFT_CFG1_TX_STEP_FREQ(x)                 (((x) << 4) & GENMASK(7, 4))
-#define HSIO_S6G_DFT_CFG1_TX_STEP_FREQ_M                  GENMASK(7, 4)
-#define HSIO_S6G_DFT_CFG1_TX_STEP_FREQ_X(x)               (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_S6G_DFT_CFG1_TX_JI_ENA                       BIT(3)
-#define HSIO_S6G_DFT_CFG1_TX_WAVEFORM_SEL                 BIT(2)
-#define HSIO_S6G_DFT_CFG1_TX_FREQOFF_DIR                  BIT(1)
-#define HSIO_S6G_DFT_CFG1_TX_FREQOFF_ENA                  BIT(0)
-
-#define HSIO_S6G_DFT_CFG2_RX_JITTER_AMPL(x)               (((x) << 8) & GENMASK(17, 8))
-#define HSIO_S6G_DFT_CFG2_RX_JITTER_AMPL_M                GENMASK(17, 8)
-#define HSIO_S6G_DFT_CFG2_RX_JITTER_AMPL_X(x)             (((x) & GENMASK(17, 8)) >> 8)
-#define HSIO_S6G_DFT_CFG2_RX_STEP_FREQ(x)                 (((x) << 4) & GENMASK(7, 4))
-#define HSIO_S6G_DFT_CFG2_RX_STEP_FREQ_M                  GENMASK(7, 4)
-#define HSIO_S6G_DFT_CFG2_RX_STEP_FREQ_X(x)               (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_S6G_DFT_CFG2_RX_JI_ENA                       BIT(3)
-#define HSIO_S6G_DFT_CFG2_RX_WAVEFORM_SEL                 BIT(2)
-#define HSIO_S6G_DFT_CFG2_RX_FREQOFF_DIR                  BIT(1)
-#define HSIO_S6G_DFT_CFG2_RX_FREQOFF_ENA                  BIT(0)
-
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_ENA             BIT(20)
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_FBS_HIGH(x)     (((x) << 16) & GENMASK(19, 16))
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_FBS_HIGH_M      GENMASK(19, 16)
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_FBS_HIGH_X(x)   (((x) & GENMASK(19, 16)) >> 16)
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_HIGH(x)         (((x) << 8) & GENMASK(15, 8))
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_HIGH_M          GENMASK(15, 8)
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_HIGH_X(x)       (((x) & GENMASK(15, 8)) >> 8)
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_LOW(x)          ((x) & GENMASK(7, 0))
-#define HSIO_S6G_RC_PLL_BIST_CFG_PLL_BIST_LOW_M           GENMASK(7, 0)
-
-#define HSIO_S6G_MISC_CFG_SEL_RECO_CLK(x)                 (((x) << 13) & GENMASK(14, 13))
-#define HSIO_S6G_MISC_CFG_SEL_RECO_CLK_M                  GENMASK(14, 13)
-#define HSIO_S6G_MISC_CFG_SEL_RECO_CLK_X(x)               (((x) & GENMASK(14, 13)) >> 13)
-#define HSIO_S6G_MISC_CFG_DES_100FX_KICK_MODE(x)          (((x) << 11) & GENMASK(12, 11))
-#define HSIO_S6G_MISC_CFG_DES_100FX_KICK_MODE_M           GENMASK(12, 11)
-#define HSIO_S6G_MISC_CFG_DES_100FX_KICK_MODE_X(x)        (((x) & GENMASK(12, 11)) >> 11)
-#define HSIO_S6G_MISC_CFG_DES_100FX_CPMD_SWAP             BIT(10)
-#define HSIO_S6G_MISC_CFG_DES_100FX_CPMD_MODE             BIT(9)
-#define HSIO_S6G_MISC_CFG_DES_100FX_CPMD_ENA              BIT(8)
-#define HSIO_S6G_MISC_CFG_RX_BUS_FLIP_ENA                 BIT(7)
-#define HSIO_S6G_MISC_CFG_TX_BUS_FLIP_ENA                 BIT(6)
-#define HSIO_S6G_MISC_CFG_RX_LPI_MODE_ENA                 BIT(5)
-#define HSIO_S6G_MISC_CFG_TX_LPI_MODE_ENA                 BIT(4)
-#define HSIO_S6G_MISC_CFG_RX_DATA_INV_ENA                 BIT(3)
-#define HSIO_S6G_MISC_CFG_TX_DATA_INV_ENA                 BIT(2)
-#define HSIO_S6G_MISC_CFG_LANE_RST                        BIT(0)
-
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_POST0(x)               (((x) << 23) & GENMASK(28, 23))
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_POST0_M                GENMASK(28, 23)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_POST0_X(x)             (((x) & GENMASK(28, 23)) >> 23)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_POST1(x)               (((x) << 18) & GENMASK(22, 18))
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_POST1_M                GENMASK(22, 18)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_POST1_X(x)             (((x) & GENMASK(22, 18)) >> 18)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_PREC(x)                (((x) << 13) & GENMASK(17, 13))
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_PREC_M                 GENMASK(17, 13)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_PREC_X(x)              (((x) & GENMASK(17, 13)) >> 13)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_ENA_CAS(x)             (((x) << 6) & GENMASK(8, 6))
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_ENA_CAS_M              GENMASK(8, 6)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_ENA_CAS_X(x)           (((x) & GENMASK(8, 6)) >> 6)
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_LEV(x)                 ((x) & GENMASK(5, 0))
-#define HSIO_S6G_OB_ANEG_CFG_AN_OB_LEV_M                  GENMASK(5, 0)
-
-#define HSIO_S6G_DFT_STATUS_PRBS_SYNC_STAT                BIT(8)
-#define HSIO_S6G_DFT_STATUS_PLL_BIST_NOT_DONE             BIT(7)
-#define HSIO_S6G_DFT_STATUS_PLL_BIST_FAILED               BIT(6)
-#define HSIO_S6G_DFT_STATUS_PLL_BIST_TIMEOUT_ERR          BIT(5)
-#define HSIO_S6G_DFT_STATUS_BIST_ACTIVE                   BIT(3)
-#define HSIO_S6G_DFT_STATUS_BIST_NOSYNC                   BIT(2)
-#define HSIO_S6G_DFT_STATUS_BIST_COMPLETE_N               BIT(1)
-#define HSIO_S6G_DFT_STATUS_BIST_ERROR                    BIT(0)
-
-#define HSIO_S6G_MISC_STATUS_DES_100FX_PHASE_SEL          BIT(0)
-
-#define HSIO_S6G_DES_CFG_DES_PHS_CTRL(x)                  (((x) << 13) & GENMASK(16, 13))
-#define HSIO_S6G_DES_CFG_DES_PHS_CTRL_M                   GENMASK(16, 13)
-#define HSIO_S6G_DES_CFG_DES_PHS_CTRL_X(x)                (((x) & GENMASK(16, 13)) >> 13)
-#define HSIO_S6G_DES_CFG_DES_MBTR_CTRL(x)                 (((x) << 10) & GENMASK(12, 10))
-#define HSIO_S6G_DES_CFG_DES_MBTR_CTRL_M                  GENMASK(12, 10)
-#define HSIO_S6G_DES_CFG_DES_MBTR_CTRL_X(x)               (((x) & GENMASK(12, 10)) >> 10)
-#define HSIO_S6G_DES_CFG_DES_CPMD_SEL(x)                  (((x) << 8) & GENMASK(9, 8))
-#define HSIO_S6G_DES_CFG_DES_CPMD_SEL_M                   GENMASK(9, 8)
-#define HSIO_S6G_DES_CFG_DES_CPMD_SEL_X(x)                (((x) & GENMASK(9, 8)) >> 8)
-#define HSIO_S6G_DES_CFG_DES_BW_HYST(x)                   (((x) << 5) & GENMASK(7, 5))
-#define HSIO_S6G_DES_CFG_DES_BW_HYST_M                    GENMASK(7, 5)
-#define HSIO_S6G_DES_CFG_DES_BW_HYST_X(x)                 (((x) & GENMASK(7, 5)) >> 5)
-#define HSIO_S6G_DES_CFG_DES_SWAP_HYST                    BIT(4)
-#define HSIO_S6G_DES_CFG_DES_BW_ANA(x)                    (((x) << 1) & GENMASK(3, 1))
-#define HSIO_S6G_DES_CFG_DES_BW_ANA_M                     GENMASK(3, 1)
-#define HSIO_S6G_DES_CFG_DES_BW_ANA_X(x)                  (((x) & GENMASK(3, 1)) >> 1)
-#define HSIO_S6G_DES_CFG_DES_SWAP_ANA                     BIT(0)
-
-#define HSIO_S6G_IB_CFG_IB_SOFSI(x)                       (((x) << 29) & GENMASK(30, 29))
-#define HSIO_S6G_IB_CFG_IB_SOFSI_M                        GENMASK(30, 29)
-#define HSIO_S6G_IB_CFG_IB_SOFSI_X(x)                     (((x) & GENMASK(30, 29)) >> 29)
-#define HSIO_S6G_IB_CFG_IB_VBULK_SEL                      BIT(28)
-#define HSIO_S6G_IB_CFG_IB_RTRM_ADJ(x)                    (((x) << 24) & GENMASK(27, 24))
-#define HSIO_S6G_IB_CFG_IB_RTRM_ADJ_M                     GENMASK(27, 24)
-#define HSIO_S6G_IB_CFG_IB_RTRM_ADJ_X(x)                  (((x) & GENMASK(27, 24)) >> 24)
-#define HSIO_S6G_IB_CFG_IB_ICML_ADJ(x)                    (((x) << 20) & GENMASK(23, 20))
-#define HSIO_S6G_IB_CFG_IB_ICML_ADJ_M                     GENMASK(23, 20)
-#define HSIO_S6G_IB_CFG_IB_ICML_ADJ_X(x)                  (((x) & GENMASK(23, 20)) >> 20)
-#define HSIO_S6G_IB_CFG_IB_TERM_MODE_SEL(x)               (((x) << 18) & GENMASK(19, 18))
-#define HSIO_S6G_IB_CFG_IB_TERM_MODE_SEL_M                GENMASK(19, 18)
-#define HSIO_S6G_IB_CFG_IB_TERM_MODE_SEL_X(x)             (((x) & GENMASK(19, 18)) >> 18)
-#define HSIO_S6G_IB_CFG_IB_SIG_DET_CLK_SEL(x)             (((x) << 15) & GENMASK(17, 15))
-#define HSIO_S6G_IB_CFG_IB_SIG_DET_CLK_SEL_M              GENMASK(17, 15)
-#define HSIO_S6G_IB_CFG_IB_SIG_DET_CLK_SEL_X(x)           (((x) & GENMASK(17, 15)) >> 15)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_HP(x)              (((x) << 13) & GENMASK(14, 13))
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_HP_M               GENMASK(14, 13)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_HP_X(x)            (((x) & GENMASK(14, 13)) >> 13)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_MID(x)             (((x) << 11) & GENMASK(12, 11))
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_MID_M              GENMASK(12, 11)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_MID_X(x)           (((x) & GENMASK(12, 11)) >> 11)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_LP(x)              (((x) << 9) & GENMASK(10, 9))
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_LP_M               GENMASK(10, 9)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_LP_X(x)            (((x) & GENMASK(10, 9)) >> 9)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_OFFSET(x)          (((x) << 7) & GENMASK(8, 7))
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_OFFSET_M           GENMASK(8, 7)
-#define HSIO_S6G_IB_CFG_IB_REG_PAT_SEL_OFFSET_X(x)        (((x) & GENMASK(8, 7)) >> 7)
-#define HSIO_S6G_IB_CFG_IB_ANA_TEST_ENA                   BIT(6)
-#define HSIO_S6G_IB_CFG_IB_SIG_DET_ENA                    BIT(5)
-#define HSIO_S6G_IB_CFG_IB_CONCUR                         BIT(4)
-#define HSIO_S6G_IB_CFG_IB_CAL_ENA                        BIT(3)
-#define HSIO_S6G_IB_CFG_IB_SAM_ENA                        BIT(2)
-#define HSIO_S6G_IB_CFG_IB_EQZ_ENA                        BIT(1)
-#define HSIO_S6G_IB_CFG_IB_REG_ENA                        BIT(0)
-
-#define HSIO_S6G_IB_CFG1_IB_TJTAG(x)                      (((x) << 17) & GENMASK(21, 17))
-#define HSIO_S6G_IB_CFG1_IB_TJTAG_M                       GENMASK(21, 17)
-#define HSIO_S6G_IB_CFG1_IB_TJTAG_X(x)                    (((x) & GENMASK(21, 17)) >> 17)
-#define HSIO_S6G_IB_CFG1_IB_TSDET(x)                      (((x) << 12) & GENMASK(16, 12))
-#define HSIO_S6G_IB_CFG1_IB_TSDET_M                       GENMASK(16, 12)
-#define HSIO_S6G_IB_CFG1_IB_TSDET_X(x)                    (((x) & GENMASK(16, 12)) >> 12)
-#define HSIO_S6G_IB_CFG1_IB_SCALY(x)                      (((x) << 8) & GENMASK(11, 8))
-#define HSIO_S6G_IB_CFG1_IB_SCALY_M                       GENMASK(11, 8)
-#define HSIO_S6G_IB_CFG1_IB_SCALY_X(x)                    (((x) & GENMASK(11, 8)) >> 8)
-#define HSIO_S6G_IB_CFG1_IB_FILT_HP                       BIT(7)
-#define HSIO_S6G_IB_CFG1_IB_FILT_MID                      BIT(6)
-#define HSIO_S6G_IB_CFG1_IB_FILT_LP                       BIT(5)
-#define HSIO_S6G_IB_CFG1_IB_FILT_OFFSET                   BIT(4)
-#define HSIO_S6G_IB_CFG1_IB_FRC_HP                        BIT(3)
-#define HSIO_S6G_IB_CFG1_IB_FRC_MID                       BIT(2)
-#define HSIO_S6G_IB_CFG1_IB_FRC_LP                        BIT(1)
-#define HSIO_S6G_IB_CFG1_IB_FRC_OFFSET                    BIT(0)
-
-#define HSIO_S6G_IB_CFG2_IB_TINFV(x)                      (((x) << 27) & GENMASK(29, 27))
-#define HSIO_S6G_IB_CFG2_IB_TINFV_M                       GENMASK(29, 27)
-#define HSIO_S6G_IB_CFG2_IB_TINFV_X(x)                    (((x) & GENMASK(29, 27)) >> 27)
-#define HSIO_S6G_IB_CFG2_IB_OINFI(x)                      (((x) << 22) & GENMASK(26, 22))
-#define HSIO_S6G_IB_CFG2_IB_OINFI_M                       GENMASK(26, 22)
-#define HSIO_S6G_IB_CFG2_IB_OINFI_X(x)                    (((x) & GENMASK(26, 22)) >> 22)
-#define HSIO_S6G_IB_CFG2_IB_TAUX(x)                       (((x) << 19) & GENMASK(21, 19))
-#define HSIO_S6G_IB_CFG2_IB_TAUX_M                        GENMASK(21, 19)
-#define HSIO_S6G_IB_CFG2_IB_TAUX_X(x)                     (((x) & GENMASK(21, 19)) >> 19)
-#define HSIO_S6G_IB_CFG2_IB_OINFS(x)                      (((x) << 16) & GENMASK(18, 16))
-#define HSIO_S6G_IB_CFG2_IB_OINFS_M                       GENMASK(18, 16)
-#define HSIO_S6G_IB_CFG2_IB_OINFS_X(x)                    (((x) & GENMASK(18, 16)) >> 16)
-#define HSIO_S6G_IB_CFG2_IB_OCALS(x)                      (((x) << 10) & GENMASK(15, 10))
-#define HSIO_S6G_IB_CFG2_IB_OCALS_M                       GENMASK(15, 10)
-#define HSIO_S6G_IB_CFG2_IB_OCALS_X(x)                    (((x) & GENMASK(15, 10)) >> 10)
-#define HSIO_S6G_IB_CFG2_IB_TCALV(x)                      (((x) << 5) & GENMASK(9, 5))
-#define HSIO_S6G_IB_CFG2_IB_TCALV_M                       GENMASK(9, 5)
-#define HSIO_S6G_IB_CFG2_IB_TCALV_X(x)                    (((x) & GENMASK(9, 5)) >> 5)
-#define HSIO_S6G_IB_CFG2_IB_UMAX(x)                       (((x) << 3) & GENMASK(4, 3))
-#define HSIO_S6G_IB_CFG2_IB_UMAX_M                        GENMASK(4, 3)
-#define HSIO_S6G_IB_CFG2_IB_UMAX_X(x)                     (((x) & GENMASK(4, 3)) >> 3)
-#define HSIO_S6G_IB_CFG2_IB_UREG(x)                       ((x) & GENMASK(2, 0))
-#define HSIO_S6G_IB_CFG2_IB_UREG_M                        GENMASK(2, 0)
-
-#define HSIO_S6G_IB_CFG3_IB_INI_HP(x)                     (((x) << 18) & GENMASK(23, 18))
-#define HSIO_S6G_IB_CFG3_IB_INI_HP_M                      GENMASK(23, 18)
-#define HSIO_S6G_IB_CFG3_IB_INI_HP_X(x)                   (((x) & GENMASK(23, 18)) >> 18)
-#define HSIO_S6G_IB_CFG3_IB_INI_MID(x)                    (((x) << 12) & GENMASK(17, 12))
-#define HSIO_S6G_IB_CFG3_IB_INI_MID_M                     GENMASK(17, 12)
-#define HSIO_S6G_IB_CFG3_IB_INI_MID_X(x)                  (((x) & GENMASK(17, 12)) >> 12)
-#define HSIO_S6G_IB_CFG3_IB_INI_LP(x)                     (((x) << 6) & GENMASK(11, 6))
-#define HSIO_S6G_IB_CFG3_IB_INI_LP_M                      GENMASK(11, 6)
-#define HSIO_S6G_IB_CFG3_IB_INI_LP_X(x)                   (((x) & GENMASK(11, 6)) >> 6)
-#define HSIO_S6G_IB_CFG3_IB_INI_OFFSET(x)                 ((x) & GENMASK(5, 0))
-#define HSIO_S6G_IB_CFG3_IB_INI_OFFSET_M                  GENMASK(5, 0)
-
-#define HSIO_S6G_IB_CFG4_IB_MAX_HP(x)                     (((x) << 18) & GENMASK(23, 18))
-#define HSIO_S6G_IB_CFG4_IB_MAX_HP_M                      GENMASK(23, 18)
-#define HSIO_S6G_IB_CFG4_IB_MAX_HP_X(x)                   (((x) & GENMASK(23, 18)) >> 18)
-#define HSIO_S6G_IB_CFG4_IB_MAX_MID(x)                    (((x) << 12) & GENMASK(17, 12))
-#define HSIO_S6G_IB_CFG4_IB_MAX_MID_M                     GENMASK(17, 12)
-#define HSIO_S6G_IB_CFG4_IB_MAX_MID_X(x)                  (((x) & GENMASK(17, 12)) >> 12)
-#define HSIO_S6G_IB_CFG4_IB_MAX_LP(x)                     (((x) << 6) & GENMASK(11, 6))
-#define HSIO_S6G_IB_CFG4_IB_MAX_LP_M                      GENMASK(11, 6)
-#define HSIO_S6G_IB_CFG4_IB_MAX_LP_X(x)                   (((x) & GENMASK(11, 6)) >> 6)
-#define HSIO_S6G_IB_CFG4_IB_MAX_OFFSET(x)                 ((x) & GENMASK(5, 0))
-#define HSIO_S6G_IB_CFG4_IB_MAX_OFFSET_M                  GENMASK(5, 0)
-
-#define HSIO_S6G_IB_CFG5_IB_MIN_HP(x)                     (((x) << 18) & GENMASK(23, 18))
-#define HSIO_S6G_IB_CFG5_IB_MIN_HP_M                      GENMASK(23, 18)
-#define HSIO_S6G_IB_CFG5_IB_MIN_HP_X(x)                   (((x) & GENMASK(23, 18)) >> 18)
-#define HSIO_S6G_IB_CFG5_IB_MIN_MID(x)                    (((x) << 12) & GENMASK(17, 12))
-#define HSIO_S6G_IB_CFG5_IB_MIN_MID_M                     GENMASK(17, 12)
-#define HSIO_S6G_IB_CFG5_IB_MIN_MID_X(x)                  (((x) & GENMASK(17, 12)) >> 12)
-#define HSIO_S6G_IB_CFG5_IB_MIN_LP(x)                     (((x) << 6) & GENMASK(11, 6))
-#define HSIO_S6G_IB_CFG5_IB_MIN_LP_M                      GENMASK(11, 6)
-#define HSIO_S6G_IB_CFG5_IB_MIN_LP_X(x)                   (((x) & GENMASK(11, 6)) >> 6)
-#define HSIO_S6G_IB_CFG5_IB_MIN_OFFSET(x)                 ((x) & GENMASK(5, 0))
-#define HSIO_S6G_IB_CFG5_IB_MIN_OFFSET_M                  GENMASK(5, 0)
-
-#define HSIO_S6G_OB_CFG_OB_IDLE                           BIT(31)
-#define HSIO_S6G_OB_CFG_OB_ENA1V_MODE                     BIT(30)
-#define HSIO_S6G_OB_CFG_OB_POL                            BIT(29)
-#define HSIO_S6G_OB_CFG_OB_POST0(x)                       (((x) << 23) & GENMASK(28, 23))
-#define HSIO_S6G_OB_CFG_OB_POST0_M                        GENMASK(28, 23)
-#define HSIO_S6G_OB_CFG_OB_POST0_X(x)                     (((x) & GENMASK(28, 23)) >> 23)
-#define HSIO_S6G_OB_CFG_OB_PREC(x)                        (((x) << 18) & GENMASK(22, 18))
-#define HSIO_S6G_OB_CFG_OB_PREC_M                         GENMASK(22, 18)
-#define HSIO_S6G_OB_CFG_OB_PREC_X(x)                      (((x) & GENMASK(22, 18)) >> 18)
-#define HSIO_S6G_OB_CFG_OB_R_ADJ_MUX                      BIT(17)
-#define HSIO_S6G_OB_CFG_OB_R_ADJ_PDR                      BIT(16)
-#define HSIO_S6G_OB_CFG_OB_POST1(x)                       (((x) << 11) & GENMASK(15, 11))
-#define HSIO_S6G_OB_CFG_OB_POST1_M                        GENMASK(15, 11)
-#define HSIO_S6G_OB_CFG_OB_POST1_X(x)                     (((x) & GENMASK(15, 11)) >> 11)
-#define HSIO_S6G_OB_CFG_OB_R_COR                          BIT(10)
-#define HSIO_S6G_OB_CFG_OB_SEL_RCTRL                      BIT(9)
-#define HSIO_S6G_OB_CFG_OB_SR_H                           BIT(8)
-#define HSIO_S6G_OB_CFG_OB_SR(x)                          (((x) << 4) & GENMASK(7, 4))
-#define HSIO_S6G_OB_CFG_OB_SR_M                           GENMASK(7, 4)
-#define HSIO_S6G_OB_CFG_OB_SR_X(x)                        (((x) & GENMASK(7, 4)) >> 4)
-#define HSIO_S6G_OB_CFG_OB_RESISTOR_CTRL(x)               ((x) & GENMASK(3, 0))
-#define HSIO_S6G_OB_CFG_OB_RESISTOR_CTRL_M                GENMASK(3, 0)
-
-#define HSIO_S6G_OB_CFG1_OB_ENA_CAS(x)                    (((x) << 6) & GENMASK(8, 6))
-#define HSIO_S6G_OB_CFG1_OB_ENA_CAS_M                     GENMASK(8, 6)
-#define HSIO_S6G_OB_CFG1_OB_ENA_CAS_X(x)                  (((x) & GENMASK(8, 6)) >> 6)
-#define HSIO_S6G_OB_CFG1_OB_LEV(x)                        ((x) & GENMASK(5, 0))
-#define HSIO_S6G_OB_CFG1_OB_LEV_M                         GENMASK(5, 0)
-
-#define HSIO_S6G_SER_CFG_SER_4TAP_ENA                     BIT(8)
-#define HSIO_S6G_SER_CFG_SER_CPMD_SEL                     BIT(7)
-#define HSIO_S6G_SER_CFG_SER_SWAP_CPMD                    BIT(6)
-#define HSIO_S6G_SER_CFG_SER_ALISEL(x)                    (((x) << 4) & GENMASK(5, 4))
-#define HSIO_S6G_SER_CFG_SER_ALISEL_M                     GENMASK(5, 4)
-#define HSIO_S6G_SER_CFG_SER_ALISEL_X(x)                  (((x) & GENMASK(5, 4)) >> 4)
-#define HSIO_S6G_SER_CFG_SER_ENHYS                        BIT(3)
-#define HSIO_S6G_SER_CFG_SER_BIG_WIN                      BIT(2)
-#define HSIO_S6G_SER_CFG_SER_EN_WIN                       BIT(1)
-#define HSIO_S6G_SER_CFG_SER_ENALI                        BIT(0)
-
-#define HSIO_S6G_COMMON_CFG_SYS_RST                       BIT(17)
-#define HSIO_S6G_COMMON_CFG_SE_DIV2_ENA                   BIT(16)
-#define HSIO_S6G_COMMON_CFG_SE_AUTO_SQUELCH_ENA           BIT(15)
-#define HSIO_S6G_COMMON_CFG_ENA_LANE                      BIT(14)
-#define HSIO_S6G_COMMON_CFG_PWD_RX                        BIT(13)
-#define HSIO_S6G_COMMON_CFG_PWD_TX                        BIT(12)
-#define HSIO_S6G_COMMON_CFG_LANE_CTRL(x)                  (((x) << 9) & GENMASK(11, 9))
-#define HSIO_S6G_COMMON_CFG_LANE_CTRL_M                   GENMASK(11, 9)
-#define HSIO_S6G_COMMON_CFG_LANE_CTRL_X(x)                (((x) & GENMASK(11, 9)) >> 9)
-#define HSIO_S6G_COMMON_CFG_ENA_DIRECT                    BIT(8)
-#define HSIO_S6G_COMMON_CFG_ENA_ELOOP                     BIT(7)
-#define HSIO_S6G_COMMON_CFG_ENA_FLOOP                     BIT(6)
-#define HSIO_S6G_COMMON_CFG_ENA_ILOOP                     BIT(5)
-#define HSIO_S6G_COMMON_CFG_ENA_PLOOP                     BIT(4)
-#define HSIO_S6G_COMMON_CFG_HRATE                         BIT(3)
-#define HSIO_S6G_COMMON_CFG_QRATE                         BIT(2)
-#define HSIO_S6G_COMMON_CFG_IF_MODE(x)                    ((x) & GENMASK(1, 0))
-#define HSIO_S6G_COMMON_CFG_IF_MODE_M                     GENMASK(1, 0)
-
-#define HSIO_S6G_PLL_CFG_PLL_ENA_OFFS(x)                  (((x) << 16) & GENMASK(17, 16))
-#define HSIO_S6G_PLL_CFG_PLL_ENA_OFFS_M                   GENMASK(17, 16)
-#define HSIO_S6G_PLL_CFG_PLL_ENA_OFFS_X(x)                (((x) & GENMASK(17, 16)) >> 16)
-#define HSIO_S6G_PLL_CFG_PLL_DIV4                         BIT(15)
-#define HSIO_S6G_PLL_CFG_PLL_ENA_ROT                      BIT(14)
-#define HSIO_S6G_PLL_CFG_PLL_FSM_CTRL_DATA(x)             (((x) << 6) & GENMASK(13, 6))
-#define HSIO_S6G_PLL_CFG_PLL_FSM_CTRL_DATA_M              GENMASK(13, 6)
-#define HSIO_S6G_PLL_CFG_PLL_FSM_CTRL_DATA_X(x)           (((x) & GENMASK(13, 6)) >> 6)
-#define HSIO_S6G_PLL_CFG_PLL_FSM_ENA                      BIT(5)
-#define HSIO_S6G_PLL_CFG_PLL_FSM_FORCE_SET_ENA            BIT(4)
-#define HSIO_S6G_PLL_CFG_PLL_FSM_OOR_RECAL_ENA            BIT(3)
-#define HSIO_S6G_PLL_CFG_PLL_RB_DATA_SEL                  BIT(2)
-#define HSIO_S6G_PLL_CFG_PLL_ROT_DIR                      BIT(1)
-#define HSIO_S6G_PLL_CFG_PLL_ROT_FRQ                      BIT(0)
-
-#define HSIO_S6G_ACJTAG_CFG_ACJTAG_INIT_DATA_N            BIT(5)
-#define HSIO_S6G_ACJTAG_CFG_ACJTAG_INIT_DATA_P            BIT(4)
-#define HSIO_S6G_ACJTAG_CFG_ACJTAG_INIT_CLK               BIT(3)
-#define HSIO_S6G_ACJTAG_CFG_OB_DIRECT                     BIT(2)
-#define HSIO_S6G_ACJTAG_CFG_ACJTAG_ENA                    BIT(1)
-#define HSIO_S6G_ACJTAG_CFG_JTAG_CTRL_ENA                 BIT(0)
-
-#define HSIO_S6G_GP_CFG_GP_MSB(x)                         (((x) << 16) & GENMASK(31, 16))
-#define HSIO_S6G_GP_CFG_GP_MSB_M                          GENMASK(31, 16)
-#define HSIO_S6G_GP_CFG_GP_MSB_X(x)                       (((x) & GENMASK(31, 16)) >> 16)
-#define HSIO_S6G_GP_CFG_GP_LSB(x)                         ((x) & GENMASK(15, 0))
-#define HSIO_S6G_GP_CFG_GP_LSB_M                          GENMASK(15, 0)
-
-#define HSIO_S6G_IB_STATUS0_IB_CAL_DONE                   BIT(8)
-#define HSIO_S6G_IB_STATUS0_IB_HP_GAIN_ACT                BIT(7)
-#define HSIO_S6G_IB_STATUS0_IB_MID_GAIN_ACT               BIT(6)
-#define HSIO_S6G_IB_STATUS0_IB_LP_GAIN_ACT                BIT(5)
-#define HSIO_S6G_IB_STATUS0_IB_OFFSET_ACT                 BIT(4)
-#define HSIO_S6G_IB_STATUS0_IB_OFFSET_VLD                 BIT(3)
-#define HSIO_S6G_IB_STATUS0_IB_OFFSET_ERR                 BIT(2)
-#define HSIO_S6G_IB_STATUS0_IB_OFFSDIR                    BIT(1)
-#define HSIO_S6G_IB_STATUS0_IB_SIG_DET                    BIT(0)
-
-#define HSIO_S6G_IB_STATUS1_IB_HP_GAIN_STAT(x)            (((x) << 18) & GENMASK(23, 18))
-#define HSIO_S6G_IB_STATUS1_IB_HP_GAIN_STAT_M             GENMASK(23, 18)
-#define HSIO_S6G_IB_STATUS1_IB_HP_GAIN_STAT_X(x)          (((x) & GENMASK(23, 18)) >> 18)
-#define HSIO_S6G_IB_STATUS1_IB_MID_GAIN_STAT(x)           (((x) << 12) & GENMASK(17, 12))
-#define HSIO_S6G_IB_STATUS1_IB_MID_GAIN_STAT_M            GENMASK(17, 12)
-#define HSIO_S6G_IB_STATUS1_IB_MID_GAIN_STAT_X(x)         (((x) & GENMASK(17, 12)) >> 12)
-#define HSIO_S6G_IB_STATUS1_IB_LP_GAIN_STAT(x)            (((x) << 6) & GENMASK(11, 6))
-#define HSIO_S6G_IB_STATUS1_IB_LP_GAIN_STAT_M             GENMASK(11, 6)
-#define HSIO_S6G_IB_STATUS1_IB_LP_GAIN_STAT_X(x)          (((x) & GENMASK(11, 6)) >> 6)
-#define HSIO_S6G_IB_STATUS1_IB_OFFSET_STAT(x)             ((x) & GENMASK(5, 0))
-#define HSIO_S6G_IB_STATUS1_IB_OFFSET_STAT_M              GENMASK(5, 0)
-
-#define HSIO_S6G_ACJTAG_STATUS_ACJTAG_CAPT_DATA_N         BIT(2)
-#define HSIO_S6G_ACJTAG_STATUS_ACJTAG_CAPT_DATA_P         BIT(1)
-#define HSIO_S6G_ACJTAG_STATUS_IB_DIRECT                  BIT(0)
-
-#define HSIO_S6G_PLL_STATUS_PLL_CAL_NOT_DONE              BIT(10)
-#define HSIO_S6G_PLL_STATUS_PLL_CAL_ERR                   BIT(9)
-#define HSIO_S6G_PLL_STATUS_PLL_OUT_OF_RANGE_ERR          BIT(8)
-#define HSIO_S6G_PLL_STATUS_PLL_RB_DATA(x)                ((x) & GENMASK(7, 0))
-#define HSIO_S6G_PLL_STATUS_PLL_RB_DATA_M                 GENMASK(7, 0)
-
-#define HSIO_S6G_REVID_SERDES_REV(x)                      (((x) << 26) & GENMASK(31, 26))
-#define HSIO_S6G_REVID_SERDES_REV_M                       GENMASK(31, 26)
-#define HSIO_S6G_REVID_SERDES_REV_X(x)                    (((x) & GENMASK(31, 26)) >> 26)
-#define HSIO_S6G_REVID_RCPLL_REV(x)                       (((x) << 21) & GENMASK(25, 21))
-#define HSIO_S6G_REVID_RCPLL_REV_M                        GENMASK(25, 21)
-#define HSIO_S6G_REVID_RCPLL_REV_X(x)                     (((x) & GENMASK(25, 21)) >> 21)
-#define HSIO_S6G_REVID_SER_REV(x)                         (((x) << 16) & GENMASK(20, 16))
-#define HSIO_S6G_REVID_SER_REV_M                          GENMASK(20, 16)
-#define HSIO_S6G_REVID_SER_REV_X(x)                       (((x) & GENMASK(20, 16)) >> 16)
-#define HSIO_S6G_REVID_DES_REV(x)                         (((x) << 10) & GENMASK(15, 10))
-#define HSIO_S6G_REVID_DES_REV_M                          GENMASK(15, 10)
-#define HSIO_S6G_REVID_DES_REV_X(x)                       (((x) & GENMASK(15, 10)) >> 10)
-#define HSIO_S6G_REVID_OB_REV(x)                          (((x) << 5) & GENMASK(9, 5))
-#define HSIO_S6G_REVID_OB_REV_M                           GENMASK(9, 5)
-#define HSIO_S6G_REVID_OB_REV_X(x)                        (((x) & GENMASK(9, 5)) >> 5)
-#define HSIO_S6G_REVID_IB_REV(x)                          ((x) & GENMASK(4, 0))
-#define HSIO_S6G_REVID_IB_REV_M                           GENMASK(4, 0)
-
-#define HSIO_MCB_S6G_ADDR_CFG_SERDES6G_WR_ONE_SHOT        BIT(31)
-#define HSIO_MCB_S6G_ADDR_CFG_SERDES6G_RD_ONE_SHOT        BIT(30)
-#define HSIO_MCB_S6G_ADDR_CFG_SERDES6G_ADDR(x)            ((x) & GENMASK(24, 0))
-#define HSIO_MCB_S6G_ADDR_CFG_SERDES6G_ADDR_M             GENMASK(24, 0)
-
-#define HSIO_HW_CFG_DEV2G5_10_MODE                        BIT(6)
-#define HSIO_HW_CFG_DEV1G_9_MODE                          BIT(5)
-#define HSIO_HW_CFG_DEV1G_6_MODE                          BIT(4)
-#define HSIO_HW_CFG_DEV1G_5_MODE                          BIT(3)
-#define HSIO_HW_CFG_DEV1G_4_MODE                          BIT(2)
-#define HSIO_HW_CFG_PCIE_ENA                              BIT(1)
-#define HSIO_HW_CFG_QSGMII_ENA                            BIT(0)
-
-#define HSIO_HW_QSGMII_CFG_SHYST_DIS                      BIT(3)
-#define HSIO_HW_QSGMII_CFG_E_DET_ENA                      BIT(2)
-#define HSIO_HW_QSGMII_CFG_USE_I1_ENA                     BIT(1)
-#define HSIO_HW_QSGMII_CFG_FLIP_LANES                     BIT(0)
-
-#define HSIO_HW_QSGMII_STAT_DELAY_VAR_X200PS(x)           (((x) << 1) & GENMASK(6, 1))
-#define HSIO_HW_QSGMII_STAT_DELAY_VAR_X200PS_M            GENMASK(6, 1)
-#define HSIO_HW_QSGMII_STAT_DELAY_VAR_X200PS_X(x)         (((x) & GENMASK(6, 1)) >> 1)
-#define HSIO_HW_QSGMII_STAT_SYNC                          BIT(0)
-
-#define HSIO_CLK_CFG_CLKDIV_PHY(x)                        (((x) << 1) & GENMASK(8, 1))
-#define HSIO_CLK_CFG_CLKDIV_PHY_M                         GENMASK(8, 1)
-#define HSIO_CLK_CFG_CLKDIV_PHY_X(x)                      (((x) & GENMASK(8, 1)) >> 1)
-#define HSIO_CLK_CFG_CLKDIV_PHY_DIS                       BIT(0)
-
-#define HSIO_TEMP_SENSOR_CTRL_FORCE_TEMP_RD               BIT(5)
-#define HSIO_TEMP_SENSOR_CTRL_FORCE_RUN                   BIT(4)
-#define HSIO_TEMP_SENSOR_CTRL_FORCE_NO_RST                BIT(3)
-#define HSIO_TEMP_SENSOR_CTRL_FORCE_POWER_UP              BIT(2)
-#define HSIO_TEMP_SENSOR_CTRL_FORCE_CLK                   BIT(1)
-#define HSIO_TEMP_SENSOR_CTRL_SAMPLE_ENA                  BIT(0)
-
-#define HSIO_TEMP_SENSOR_CFG_RUN_WID(x)                   (((x) << 8) & GENMASK(15, 8))
-#define HSIO_TEMP_SENSOR_CFG_RUN_WID_M                    GENMASK(15, 8)
-#define HSIO_TEMP_SENSOR_CFG_RUN_WID_X(x)                 (((x) & GENMASK(15, 8)) >> 8)
-#define HSIO_TEMP_SENSOR_CFG_SAMPLE_PER(x)                ((x) & GENMASK(7, 0))
-#define HSIO_TEMP_SENSOR_CFG_SAMPLE_PER_M                 GENMASK(7, 0)
-
-#define HSIO_TEMP_SENSOR_STAT_TEMP_VALID                  BIT(8)
-#define HSIO_TEMP_SENSOR_STAT_TEMP(x)                     ((x) & GENMASK(7, 0))
-#define HSIO_TEMP_SENSOR_STAT_TEMP_M                      GENMASK(7, 0)
-
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_io.c b/drivers/net/ethernet/mscc/ocelot_io.c
deleted file mode 100644
index c6db8ad31fdf..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_io.c
+++ /dev/null
@@ -1,116 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-
-#include "ocelot.h"
-
-u32 __ocelot_read_ix(struct ocelot *ocelot, u32 reg, u32 offset)
-{
-	u16 target = reg >> TARGET_OFFSET;
-	u32 val;
-
-	WARN_ON(!target);
-
-	regmap_read(ocelot->targets[target],
-		    ocelot->map[target][reg & REG_MASK] + offset, &val);
-	return val;
-}
-EXPORT_SYMBOL(__ocelot_read_ix);
-
-void __ocelot_write_ix(struct ocelot *ocelot, u32 val, u32 reg, u32 offset)
-{
-	u16 target = reg >> TARGET_OFFSET;
-
-	WARN_ON(!target);
-
-	regmap_write(ocelot->targets[target],
-		     ocelot->map[target][reg & REG_MASK] + offset, val);
-}
-EXPORT_SYMBOL(__ocelot_write_ix);
-
-void __ocelot_rmw_ix(struct ocelot *ocelot, u32 val, u32 mask, u32 reg,
-		     u32 offset)
-{
-	u16 target = reg >> TARGET_OFFSET;
-
-	WARN_ON(!target);
-
-	regmap_update_bits(ocelot->targets[target],
-			   ocelot->map[target][reg & REG_MASK] + offset,
-			   mask, val);
-}
-EXPORT_SYMBOL(__ocelot_rmw_ix);
-
-u32 ocelot_port_readl(struct ocelot_port *port, u32 reg)
-{
-	return readl(port->regs + reg);
-}
-EXPORT_SYMBOL(ocelot_port_readl);
-
-void ocelot_port_writel(struct ocelot_port *port, u32 val, u32 reg)
-{
-	writel(val, port->regs + reg);
-}
-EXPORT_SYMBOL(ocelot_port_writel);
-
-int ocelot_regfields_init(struct ocelot *ocelot,
-			  const struct reg_field *const regfields)
-{
-	unsigned int i;
-	u16 target;
-
-	for (i = 0; i < REGFIELD_MAX; i++) {
-		struct reg_field regfield = {};
-		u32 reg = regfields[i].reg;
-
-		if (!reg)
-			continue;
-
-		target = regfields[i].reg >> TARGET_OFFSET;
-
-		regfield.reg = ocelot->map[target][reg & REG_MASK];
-		regfield.lsb = regfields[i].lsb;
-		regfield.msb = regfields[i].msb;
-
-		ocelot->regfields[i] =
-		devm_regmap_field_alloc(ocelot->dev,
-					ocelot->targets[target],
-					regfield);
-
-		if (IS_ERR(ocelot->regfields[i]))
-			return PTR_ERR(ocelot->regfields[i]);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(ocelot_regfields_init);
-
-static struct regmap_config ocelot_regmap_config = {
-	.reg_bits	= 32,
-	.val_bits	= 32,
-	.reg_stride	= 4,
-};
-
-struct regmap *ocelot_io_platform_init(struct ocelot *ocelot,
-				       struct platform_device *pdev,
-				       const char *name)
-{
-	struct resource *res;
-	void __iomem *regs;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
-	regs = devm_ioremap_resource(ocelot->dev, res);
-	if (IS_ERR(regs))
-		return ERR_CAST(regs);
-
-	ocelot_regmap_config.name = name;
-	return devm_regmap_init_mmio(ocelot->dev, regs,
-				     &ocelot_regmap_config);
-}
-EXPORT_SYMBOL(ocelot_io_platform_init);
diff --git a/drivers/net/ethernet/mscc/ocelot_ptp.h b/drivers/net/ethernet/mscc/ocelot_ptp.h
deleted file mode 100644
index d3c7f35e7ae6..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_ptp.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/* Copyright (c) 2017 Microsemi Corporation
- * Copyright 2019 NXP
- */
-
-#ifndef _MSCC_OCELOT_PTP_H_
-#define _MSCC_OCELOT_PTP_H_
-
-#define PTP_PIN_CFG_RSZ			0x20
-#define PTP_TOD_SEC_MSB_RSZ		PTP_PIN_CFG_RSZ
-#define PTP_TOD_SEC_LSB_RSZ		PTP_PIN_CFG_RSZ
-#define PTP_TOD_NSEC_RSZ		PTP_PIN_CFG_RSZ
-#define PTP_NSF_RSZ			PTP_PIN_CFG_RSZ
-#define PTP_PIN_WF_HIGH_PERIOD_RSZ	PTP_PIN_CFG_RSZ
-#define PTP_PIN_WF_LOW_PERIOD_RSZ	PTP_PIN_CFG_RSZ
-
-#define PTP_PIN_CFG_DOM			BIT(0)
-#define PTP_PIN_CFG_SYNC		BIT(2)
-#define PTP_PIN_CFG_ACTION(x)		((x) << 3)
-#define PTP_PIN_CFG_ACTION_MASK		PTP_PIN_CFG_ACTION(0x7)
-
-#define PTP_CLK_ADJ_DIR			BIT(1)
-#define PTP_CLK_ADJ_ENA			BIT(0)
-
-#define PTP_CLK_ADJ_UNIT_NS		BIT(30)
-
-enum {
-	PTP_PIN_ACTION_IDLE = 0,
-	PTP_PIN_ACTION_LOAD,
-	PTP_PIN_ACTION_SAVE,
-	PTP_PIN_ACTION_CLOCK,
-	PTP_PIN_ACTION_DELTA,
-};
-
-#define SEC_MSB_MASK           0x0000ffff
-#define NSEC_MASK              0x3fffffff
-
-// System clock period 6.4 ns (Frequency 156.25MHz)
-#define SYS_CLK_PER_NS		0x6
-#define SYS_CLK_PER_PS100	0x4
-
-#define PSEC_PER_SEC		1000000000000LL
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_qs.h b/drivers/net/ethernet/mscc/ocelot_qs.h
deleted file mode 100644
index d18ae726c01d..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_qs.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_QS_H_
-#define _MSCC_OCELOT_QS_H_
-
-/* TODO handle BE */
-#define XTR_EOF_0          0x00000080U
-#define XTR_EOF_1          0x01000080U
-#define XTR_EOF_2          0x02000080U
-#define XTR_EOF_3          0x03000080U
-#define XTR_PRUNED         0x04000080U
-#define XTR_ABORT          0x05000080U
-#define XTR_ESCAPE         0x06000080U
-#define XTR_NOT_READY      0x07000080U
-#define XTR_VALID_BYTES(x) (4 - (((x) >> 24) & 3))
-
-#define QS_XTR_GRP_CFG_RSZ                                0x4
-
-#define QS_XTR_GRP_CFG_MODE(x)                            (((x) << 2) & GENMASK(3, 2))
-#define QS_XTR_GRP_CFG_MODE_M                             GENMASK(3, 2)
-#define QS_XTR_GRP_CFG_MODE_X(x)                          (((x) & GENMASK(3, 2)) >> 2)
-#define QS_XTR_GRP_CFG_STATUS_WORD_POS                    BIT(1)
-#define QS_XTR_GRP_CFG_BYTE_SWAP                          BIT(0)
-
-#define QS_XTR_RD_RSZ                                     0x4
-
-#define QS_XTR_FRM_PRUNING_RSZ                            0x4
-
-#define QS_XTR_CFG_DP_WM(x)                               (((x) << 5) & GENMASK(7, 5))
-#define QS_XTR_CFG_DP_WM_M                                GENMASK(7, 5)
-#define QS_XTR_CFG_DP_WM_X(x)                             (((x) & GENMASK(7, 5)) >> 5)
-#define QS_XTR_CFG_SCH_WM(x)                              (((x) << 2) & GENMASK(4, 2))
-#define QS_XTR_CFG_SCH_WM_M                               GENMASK(4, 2)
-#define QS_XTR_CFG_SCH_WM_X(x)                            (((x) & GENMASK(4, 2)) >> 2)
-#define QS_XTR_CFG_OFLW_ERR_STICKY(x)                     ((x) & GENMASK(1, 0))
-#define QS_XTR_CFG_OFLW_ERR_STICKY_M                      GENMASK(1, 0)
-
-#define QS_INJ_GRP_CFG_RSZ                                0x4
-
-#define QS_INJ_GRP_CFG_MODE(x)                            (((x) << 2) & GENMASK(3, 2))
-#define QS_INJ_GRP_CFG_MODE_M                             GENMASK(3, 2)
-#define QS_INJ_GRP_CFG_MODE_X(x)                          (((x) & GENMASK(3, 2)) >> 2)
-#define QS_INJ_GRP_CFG_BYTE_SWAP                          BIT(0)
-
-#define QS_INJ_WR_RSZ                                     0x4
-
-#define QS_INJ_CTRL_RSZ                                   0x4
-
-#define QS_INJ_CTRL_GAP_SIZE(x)                           (((x) << 21) & GENMASK(24, 21))
-#define QS_INJ_CTRL_GAP_SIZE_M                            GENMASK(24, 21)
-#define QS_INJ_CTRL_GAP_SIZE_X(x)                         (((x) & GENMASK(24, 21)) >> 21)
-#define QS_INJ_CTRL_ABORT                                 BIT(20)
-#define QS_INJ_CTRL_EOF                                   BIT(19)
-#define QS_INJ_CTRL_SOF                                   BIT(18)
-#define QS_INJ_CTRL_VLD_BYTES(x)                          (((x) << 16) & GENMASK(17, 16))
-#define QS_INJ_CTRL_VLD_BYTES_M                           GENMASK(17, 16)
-#define QS_INJ_CTRL_VLD_BYTES_X(x)                        (((x) & GENMASK(17, 16)) >> 16)
-
-#define QS_INJ_STATUS_WMARK_REACHED(x)                    (((x) << 4) & GENMASK(5, 4))
-#define QS_INJ_STATUS_WMARK_REACHED_M                     GENMASK(5, 4)
-#define QS_INJ_STATUS_WMARK_REACHED_X(x)                  (((x) & GENMASK(5, 4)) >> 4)
-#define QS_INJ_STATUS_FIFO_RDY(x)                         (((x) << 2) & GENMASK(3, 2))
-#define QS_INJ_STATUS_FIFO_RDY_M                          GENMASK(3, 2)
-#define QS_INJ_STATUS_FIFO_RDY_X(x)                       (((x) & GENMASK(3, 2)) >> 2)
-#define QS_INJ_STATUS_INJ_IN_PROGRESS(x)                  ((x) & GENMASK(1, 0))
-#define QS_INJ_STATUS_INJ_IN_PROGRESS_M                   GENMASK(1, 0)
-
-#define QS_INJ_ERR_RSZ                                    0x4
-
-#define QS_INJ_ERR_ABORT_ERR_STICKY                       BIT(1)
-#define QS_INJ_ERR_WR_ERR_STICKY                          BIT(0)
-
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_qsys.h b/drivers/net/ethernet/mscc/ocelot_qsys.h
deleted file mode 100644
index d8c63aa761be..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_qsys.h
+++ /dev/null
@@ -1,270 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_QSYS_H_
-#define _MSCC_OCELOT_QSYS_H_
-
-#define QSYS_PORT_MODE_RSZ                                0x4
-
-#define QSYS_PORT_MODE_DEQUEUE_DIS                        BIT(1)
-#define QSYS_PORT_MODE_DEQUEUE_LATE                       BIT(0)
-
-#define QSYS_SWITCH_PORT_MODE_RSZ                         0x4
-
-#define QSYS_SWITCH_PORT_MODE_PORT_ENA                    BIT(14)
-#define QSYS_SWITCH_PORT_MODE_SCH_NEXT_CFG(x)             (((x) << 11) & GENMASK(13, 11))
-#define QSYS_SWITCH_PORT_MODE_SCH_NEXT_CFG_M              GENMASK(13, 11)
-#define QSYS_SWITCH_PORT_MODE_SCH_NEXT_CFG_X(x)           (((x) & GENMASK(13, 11)) >> 11)
-#define QSYS_SWITCH_PORT_MODE_YEL_RSRVD                   BIT(10)
-#define QSYS_SWITCH_PORT_MODE_INGRESS_DROP_MODE           BIT(9)
-#define QSYS_SWITCH_PORT_MODE_TX_PFC_ENA(x)               (((x) << 1) & GENMASK(8, 1))
-#define QSYS_SWITCH_PORT_MODE_TX_PFC_ENA_M                GENMASK(8, 1)
-#define QSYS_SWITCH_PORT_MODE_TX_PFC_ENA_X(x)             (((x) & GENMASK(8, 1)) >> 1)
-#define QSYS_SWITCH_PORT_MODE_TX_PFC_MODE                 BIT(0)
-
-#define QSYS_STAT_CNT_CFG_TX_GREEN_CNT_MODE               BIT(5)
-#define QSYS_STAT_CNT_CFG_TX_YELLOW_CNT_MODE              BIT(4)
-#define QSYS_STAT_CNT_CFG_DROP_GREEN_CNT_MODE             BIT(3)
-#define QSYS_STAT_CNT_CFG_DROP_YELLOW_CNT_MODE            BIT(2)
-#define QSYS_STAT_CNT_CFG_DROP_COUNT_ONCE                 BIT(1)
-#define QSYS_STAT_CNT_CFG_DROP_COUNT_EGRESS               BIT(0)
-
-#define QSYS_EEE_CFG_RSZ                                  0x4
-
-#define QSYS_EEE_THRES_EEE_HIGH_BYTES(x)                  (((x) << 8) & GENMASK(15, 8))
-#define QSYS_EEE_THRES_EEE_HIGH_BYTES_M                   GENMASK(15, 8)
-#define QSYS_EEE_THRES_EEE_HIGH_BYTES_X(x)                (((x) & GENMASK(15, 8)) >> 8)
-#define QSYS_EEE_THRES_EEE_HIGH_FRAMES(x)                 ((x) & GENMASK(7, 0))
-#define QSYS_EEE_THRES_EEE_HIGH_FRAMES_M                  GENMASK(7, 0)
-
-#define QSYS_SW_STATUS_RSZ                                0x4
-
-#define QSYS_EXT_CPU_CFG_EXT_CPU_PORT(x)                  (((x) << 8) & GENMASK(12, 8))
-#define QSYS_EXT_CPU_CFG_EXT_CPU_PORT_M                   GENMASK(12, 8)
-#define QSYS_EXT_CPU_CFG_EXT_CPU_PORT_X(x)                (((x) & GENMASK(12, 8)) >> 8)
-#define QSYS_EXT_CPU_CFG_EXT_CPUQ_MSK(x)                  ((x) & GENMASK(7, 0))
-#define QSYS_EXT_CPU_CFG_EXT_CPUQ_MSK_M                   GENMASK(7, 0)
-
-#define QSYS_QMAP_GSZ                                     0x4
-
-#define QSYS_QMAP_SE_BASE(x)                              (((x) << 5) & GENMASK(12, 5))
-#define QSYS_QMAP_SE_BASE_M                               GENMASK(12, 5)
-#define QSYS_QMAP_SE_BASE_X(x)                            (((x) & GENMASK(12, 5)) >> 5)
-#define QSYS_QMAP_SE_IDX_SEL(x)                           (((x) << 2) & GENMASK(4, 2))
-#define QSYS_QMAP_SE_IDX_SEL_M                            GENMASK(4, 2)
-#define QSYS_QMAP_SE_IDX_SEL_X(x)                         (((x) & GENMASK(4, 2)) >> 2)
-#define QSYS_QMAP_SE_INP_SEL(x)                           ((x) & GENMASK(1, 0))
-#define QSYS_QMAP_SE_INP_SEL_M                            GENMASK(1, 0)
-
-#define QSYS_ISDX_SGRP_GSZ                                0x4
-
-#define QSYS_TIMED_FRAME_ENTRY_GSZ                        0x4
-
-#define QSYS_TFRM_MISC_TIMED_CANCEL_SLOT(x)               (((x) << 9) & GENMASK(18, 9))
-#define QSYS_TFRM_MISC_TIMED_CANCEL_SLOT_M                GENMASK(18, 9)
-#define QSYS_TFRM_MISC_TIMED_CANCEL_SLOT_X(x)             (((x) & GENMASK(18, 9)) >> 9)
-#define QSYS_TFRM_MISC_TIMED_CANCEL_1SHOT                 BIT(8)
-#define QSYS_TFRM_MISC_TIMED_SLOT_MODE_MC                 BIT(7)
-#define QSYS_TFRM_MISC_TIMED_ENTRY_FAST_CNT(x)            ((x) & GENMASK(6, 0))
-#define QSYS_TFRM_MISC_TIMED_ENTRY_FAST_CNT_M             GENMASK(6, 0)
-
-#define QSYS_RED_PROFILE_RSZ                              0x4
-
-#define QSYS_RED_PROFILE_WM_RED_LOW(x)                    (((x) << 8) & GENMASK(15, 8))
-#define QSYS_RED_PROFILE_WM_RED_LOW_M                     GENMASK(15, 8)
-#define QSYS_RED_PROFILE_WM_RED_LOW_X(x)                  (((x) & GENMASK(15, 8)) >> 8)
-#define QSYS_RED_PROFILE_WM_RED_HIGH(x)                   ((x) & GENMASK(7, 0))
-#define QSYS_RED_PROFILE_WM_RED_HIGH_M                    GENMASK(7, 0)
-
-#define QSYS_RES_CFG_GSZ                                  0x8
-
-#define QSYS_RES_STAT_GSZ                                 0x8
-
-#define QSYS_RES_STAT_INUSE(x)                            (((x) << 12) & GENMASK(23, 12))
-#define QSYS_RES_STAT_INUSE_M                             GENMASK(23, 12)
-#define QSYS_RES_STAT_INUSE_X(x)                          (((x) & GENMASK(23, 12)) >> 12)
-#define QSYS_RES_STAT_MAXUSE(x)                           ((x) & GENMASK(11, 0))
-#define QSYS_RES_STAT_MAXUSE_M                            GENMASK(11, 0)
-
-#define QSYS_EVENTS_CORE_EV_FDC(x)                        (((x) << 2) & GENMASK(4, 2))
-#define QSYS_EVENTS_CORE_EV_FDC_M                         GENMASK(4, 2)
-#define QSYS_EVENTS_CORE_EV_FDC_X(x)                      (((x) & GENMASK(4, 2)) >> 2)
-#define QSYS_EVENTS_CORE_EV_FRD(x)                        ((x) & GENMASK(1, 0))
-#define QSYS_EVENTS_CORE_EV_FRD_M                         GENMASK(1, 0)
-
-#define QSYS_QMAXSDU_CFG_0_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_1_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_2_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_3_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_4_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_5_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_6_RSZ                            0x4
-
-#define QSYS_QMAXSDU_CFG_7_RSZ                            0x4
-
-#define QSYS_PREEMPTION_CFG_RSZ                           0x4
-
-#define QSYS_PREEMPTION_CFG_P_QUEUES(x)                   ((x) & GENMASK(7, 0))
-#define QSYS_PREEMPTION_CFG_P_QUEUES_M                    GENMASK(7, 0)
-#define QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE(x)           (((x) << 8) & GENMASK(9, 8))
-#define QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE_M            GENMASK(9, 8)
-#define QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE_X(x)         (((x) & GENMASK(9, 8)) >> 8)
-#define QSYS_PREEMPTION_CFG_STRICT_IPG(x)                 (((x) << 12) & GENMASK(13, 12))
-#define QSYS_PREEMPTION_CFG_STRICT_IPG_M                  GENMASK(13, 12)
-#define QSYS_PREEMPTION_CFG_STRICT_IPG_X(x)               (((x) & GENMASK(13, 12)) >> 12)
-#define QSYS_PREEMPTION_CFG_HOLD_ADVANCE(x)               (((x) << 16) & GENMASK(31, 16))
-#define QSYS_PREEMPTION_CFG_HOLD_ADVANCE_M                GENMASK(31, 16)
-#define QSYS_PREEMPTION_CFG_HOLD_ADVANCE_X(x)             (((x) & GENMASK(31, 16)) >> 16)
-
-#define QSYS_CIR_CFG_GSZ                                  0x80
-
-#define QSYS_CIR_CFG_CIR_RATE(x)                          (((x) << 6) & GENMASK(20, 6))
-#define QSYS_CIR_CFG_CIR_RATE_M                           GENMASK(20, 6)
-#define QSYS_CIR_CFG_CIR_RATE_X(x)                        (((x) & GENMASK(20, 6)) >> 6)
-#define QSYS_CIR_CFG_CIR_BURST(x)                         ((x) & GENMASK(5, 0))
-#define QSYS_CIR_CFG_CIR_BURST_M                          GENMASK(5, 0)
-
-#define QSYS_EIR_CFG_GSZ                                  0x80
-
-#define QSYS_EIR_CFG_EIR_RATE(x)                          (((x) << 7) & GENMASK(21, 7))
-#define QSYS_EIR_CFG_EIR_RATE_M                           GENMASK(21, 7)
-#define QSYS_EIR_CFG_EIR_RATE_X(x)                        (((x) & GENMASK(21, 7)) >> 7)
-#define QSYS_EIR_CFG_EIR_BURST(x)                         (((x) << 1) & GENMASK(6, 1))
-#define QSYS_EIR_CFG_EIR_BURST_M                          GENMASK(6, 1)
-#define QSYS_EIR_CFG_EIR_BURST_X(x)                       (((x) & GENMASK(6, 1)) >> 1)
-#define QSYS_EIR_CFG_EIR_MARK_ENA                         BIT(0)
-
-#define QSYS_SE_CFG_GSZ                                   0x80
-
-#define QSYS_SE_CFG_SE_DWRR_CNT(x)                        (((x) << 6) & GENMASK(9, 6))
-#define QSYS_SE_CFG_SE_DWRR_CNT_M                         GENMASK(9, 6)
-#define QSYS_SE_CFG_SE_DWRR_CNT_X(x)                      (((x) & GENMASK(9, 6)) >> 6)
-#define QSYS_SE_CFG_SE_RR_ENA                             BIT(5)
-#define QSYS_SE_CFG_SE_AVB_ENA                            BIT(4)
-#define QSYS_SE_CFG_SE_FRM_MODE(x)                        (((x) << 2) & GENMASK(3, 2))
-#define QSYS_SE_CFG_SE_FRM_MODE_M                         GENMASK(3, 2)
-#define QSYS_SE_CFG_SE_FRM_MODE_X(x)                      (((x) & GENMASK(3, 2)) >> 2)
-#define QSYS_SE_CFG_SE_EXC_ENA                            BIT(1)
-#define QSYS_SE_CFG_SE_EXC_FWD                            BIT(0)
-
-#define QSYS_SE_DWRR_CFG_GSZ                              0x80
-#define QSYS_SE_DWRR_CFG_RSZ                              0x4
-
-#define QSYS_SE_CONNECT_GSZ                               0x80
-
-#define QSYS_SE_CONNECT_SE_OUTP_IDX(x)                    (((x) << 17) & GENMASK(24, 17))
-#define QSYS_SE_CONNECT_SE_OUTP_IDX_M                     GENMASK(24, 17)
-#define QSYS_SE_CONNECT_SE_OUTP_IDX_X(x)                  (((x) & GENMASK(24, 17)) >> 17)
-#define QSYS_SE_CONNECT_SE_INP_IDX(x)                     (((x) << 9) & GENMASK(16, 9))
-#define QSYS_SE_CONNECT_SE_INP_IDX_M                      GENMASK(16, 9)
-#define QSYS_SE_CONNECT_SE_INP_IDX_X(x)                   (((x) & GENMASK(16, 9)) >> 9)
-#define QSYS_SE_CONNECT_SE_OUTP_CON(x)                    (((x) << 5) & GENMASK(8, 5))
-#define QSYS_SE_CONNECT_SE_OUTP_CON_M                     GENMASK(8, 5)
-#define QSYS_SE_CONNECT_SE_OUTP_CON_X(x)                  (((x) & GENMASK(8, 5)) >> 5)
-#define QSYS_SE_CONNECT_SE_INP_CNT(x)                     (((x) << 1) & GENMASK(4, 1))
-#define QSYS_SE_CONNECT_SE_INP_CNT_M                      GENMASK(4, 1)
-#define QSYS_SE_CONNECT_SE_INP_CNT_X(x)                   (((x) & GENMASK(4, 1)) >> 1)
-#define QSYS_SE_CONNECT_SE_TERMINAL                       BIT(0)
-
-#define QSYS_SE_DLB_SENSE_GSZ                             0x80
-
-#define QSYS_SE_DLB_SENSE_SE_DLB_PRIO(x)                  (((x) << 11) & GENMASK(13, 11))
-#define QSYS_SE_DLB_SENSE_SE_DLB_PRIO_M                   GENMASK(13, 11)
-#define QSYS_SE_DLB_SENSE_SE_DLB_PRIO_X(x)                (((x) & GENMASK(13, 11)) >> 11)
-#define QSYS_SE_DLB_SENSE_SE_DLB_SPORT(x)                 (((x) << 7) & GENMASK(10, 7))
-#define QSYS_SE_DLB_SENSE_SE_DLB_SPORT_M                  GENMASK(10, 7)
-#define QSYS_SE_DLB_SENSE_SE_DLB_SPORT_X(x)               (((x) & GENMASK(10, 7)) >> 7)
-#define QSYS_SE_DLB_SENSE_SE_DLB_DPORT(x)                 (((x) << 3) & GENMASK(6, 3))
-#define QSYS_SE_DLB_SENSE_SE_DLB_DPORT_M                  GENMASK(6, 3)
-#define QSYS_SE_DLB_SENSE_SE_DLB_DPORT_X(x)               (((x) & GENMASK(6, 3)) >> 3)
-#define QSYS_SE_DLB_SENSE_SE_DLB_PRIO_ENA                 BIT(2)
-#define QSYS_SE_DLB_SENSE_SE_DLB_SPORT_ENA                BIT(1)
-#define QSYS_SE_DLB_SENSE_SE_DLB_DPORT_ENA                BIT(0)
-
-#define QSYS_CIR_STATE_GSZ                                0x80
-
-#define QSYS_CIR_STATE_CIR_LVL(x)                         (((x) << 4) & GENMASK(25, 4))
-#define QSYS_CIR_STATE_CIR_LVL_M                          GENMASK(25, 4)
-#define QSYS_CIR_STATE_CIR_LVL_X(x)                       (((x) & GENMASK(25, 4)) >> 4)
-#define QSYS_CIR_STATE_SHP_TIME(x)                        ((x) & GENMASK(3, 0))
-#define QSYS_CIR_STATE_SHP_TIME_M                         GENMASK(3, 0)
-
-#define QSYS_EIR_STATE_GSZ                                0x80
-
-#define QSYS_SE_STATE_GSZ                                 0x80
-
-#define QSYS_SE_STATE_SE_OUTP_LVL(x)                      (((x) << 1) & GENMASK(2, 1))
-#define QSYS_SE_STATE_SE_OUTP_LVL_M                       GENMASK(2, 1)
-#define QSYS_SE_STATE_SE_OUTP_LVL_X(x)                    (((x) & GENMASK(2, 1)) >> 1)
-#define QSYS_SE_STATE_SE_WAS_YEL                          BIT(0)
-
-#define QSYS_HSCH_MISC_CFG_SE_CONNECT_VLD                 BIT(8)
-#define QSYS_HSCH_MISC_CFG_FRM_ADJ(x)                     (((x) << 3) & GENMASK(7, 3))
-#define QSYS_HSCH_MISC_CFG_FRM_ADJ_M                      GENMASK(7, 3)
-#define QSYS_HSCH_MISC_CFG_FRM_ADJ_X(x)                   (((x) & GENMASK(7, 3)) >> 3)
-#define QSYS_HSCH_MISC_CFG_LEAK_DIS                       BIT(2)
-#define QSYS_HSCH_MISC_CFG_QSHP_EXC_ENA                   BIT(1)
-#define QSYS_HSCH_MISC_CFG_PFC_BYP_UPD                    BIT(0)
-
-#define QSYS_TAG_CONFIG_RSZ                               0x4
-
-#define QSYS_TAG_CONFIG_ENABLE                            BIT(0)
-#define QSYS_TAG_CONFIG_LINK_SPEED(x)                     (((x) << 4) & GENMASK(5, 4))
-#define QSYS_TAG_CONFIG_LINK_SPEED_M                      GENMASK(5, 4)
-#define QSYS_TAG_CONFIG_LINK_SPEED_X(x)                   (((x) & GENMASK(5, 4)) >> 4)
-#define QSYS_TAG_CONFIG_INIT_GATE_STATE(x)                (((x) << 8) & GENMASK(15, 8))
-#define QSYS_TAG_CONFIG_INIT_GATE_STATE_M                 GENMASK(15, 8)
-#define QSYS_TAG_CONFIG_INIT_GATE_STATE_X(x)              (((x) & GENMASK(15, 8)) >> 8)
-#define QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES(x)             (((x) << 16) & GENMASK(23, 16))
-#define QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES_M              GENMASK(23, 16)
-#define QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES_X(x)           (((x) & GENMASK(23, 16)) >> 16)
-
-#define QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM(x)               ((x) & GENMASK(7, 0))
-#define QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_M                GENMASK(7, 0)
-#define QSYS_TAS_PARAM_CFG_CTRL_ALWAYS_GUARD_BAND_SCH_Q   BIT(8)
-#define QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE             BIT(16)
-
-#define QSYS_PORT_MAX_SDU_RSZ                             0x4
-
-#define QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(x)         ((x) & GENMASK(15, 0))
-#define QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB_M          GENMASK(15, 0)
-#define QSYS_PARAM_CFG_REG_3_LIST_LENGTH(x)               (((x) << 16) & GENMASK(31, 16))
-#define QSYS_PARAM_CFG_REG_3_LIST_LENGTH_M                GENMASK(31, 16)
-#define QSYS_PARAM_CFG_REG_3_LIST_LENGTH_X(x)             (((x) & GENMASK(31, 16)) >> 16)
-
-#define QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM(x)               ((x) & GENMASK(5, 0))
-#define QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM_M                GENMASK(5, 0)
-#define QSYS_GCL_CFG_REG_1_GATE_STATE(x)                  (((x) << 8) & GENMASK(15, 8))
-#define QSYS_GCL_CFG_REG_1_GATE_STATE_M                   GENMASK(15, 8)
-#define QSYS_GCL_CFG_REG_1_GATE_STATE_X(x)                (((x) & GENMASK(15, 8)) >> 8)
-
-#define QSYS_PARAM_STATUS_REG_3_BASE_TIME_SEC_MSB(x)      ((x) & GENMASK(15, 0))
-#define QSYS_PARAM_STATUS_REG_3_BASE_TIME_SEC_MSB_M       GENMASK(15, 0)
-#define QSYS_PARAM_STATUS_REG_3_LIST_LENGTH(x)            (((x) << 16) & GENMASK(31, 16))
-#define QSYS_PARAM_STATUS_REG_3_LIST_LENGTH_M             GENMASK(31, 16)
-#define QSYS_PARAM_STATUS_REG_3_LIST_LENGTH_X(x)          (((x) & GENMASK(31, 16)) >> 16)
-
-#define QSYS_PARAM_STATUS_REG_8_CFG_CHG_TIME_SEC_MSB(x)   ((x) & GENMASK(15, 0))
-#define QSYS_PARAM_STATUS_REG_8_CFG_CHG_TIME_SEC_MSB_M    GENMASK(15, 0)
-#define QSYS_PARAM_STATUS_REG_8_OPER_GATE_STATE(x)        (((x) << 16) & GENMASK(23, 16))
-#define QSYS_PARAM_STATUS_REG_8_OPER_GATE_STATE_M         GENMASK(23, 16)
-#define QSYS_PARAM_STATUS_REG_8_OPER_GATE_STATE_X(x)      (((x) & GENMASK(23, 16)) >> 16)
-#define QSYS_PARAM_STATUS_REG_8_CONFIG_PENDING            BIT(24)
-
-#define QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM(x)            ((x) & GENMASK(5, 0))
-#define QSYS_GCL_STATUS_REG_1_GCL_ENTRY_NUM_M             GENMASK(5, 0)
-#define QSYS_GCL_STATUS_REG_1_GATE_STATE(x)               (((x) << 8) & GENMASK(15, 8))
-#define QSYS_GCL_STATUS_REG_1_GATE_STATE_M                GENMASK(15, 8)
-#define QSYS_GCL_STATUS_REG_1_GATE_STATE_X(x)             (((x) & GENMASK(15, 8)) >> 8)
-
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_rew.h b/drivers/net/ethernet/mscc/ocelot_rew.h
deleted file mode 100644
index 210914b7e20f..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_rew.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_REW_H_
-#define _MSCC_OCELOT_REW_H_
-
-#define REW_PORT_VLAN_CFG_GSZ                             0x80
-
-#define REW_PORT_VLAN_CFG_PORT_TPID(x)                    (((x) << 16) & GENMASK(31, 16))
-#define REW_PORT_VLAN_CFG_PORT_TPID_M                     GENMASK(31, 16)
-#define REW_PORT_VLAN_CFG_PORT_TPID_X(x)                  (((x) & GENMASK(31, 16)) >> 16)
-#define REW_PORT_VLAN_CFG_PORT_DEI                        BIT(15)
-#define REW_PORT_VLAN_CFG_PORT_PCP(x)                     (((x) << 12) & GENMASK(14, 12))
-#define REW_PORT_VLAN_CFG_PORT_PCP_M                      GENMASK(14, 12)
-#define REW_PORT_VLAN_CFG_PORT_PCP_X(x)                   (((x) & GENMASK(14, 12)) >> 12)
-#define REW_PORT_VLAN_CFG_PORT_VID(x)                     ((x) & GENMASK(11, 0))
-#define REW_PORT_VLAN_CFG_PORT_VID_M                      GENMASK(11, 0)
-
-#define REW_TAG_CFG_GSZ                                   0x80
-
-#define REW_TAG_CFG_TAG_CFG(x)                            (((x) << 7) & GENMASK(8, 7))
-#define REW_TAG_CFG_TAG_CFG_M                             GENMASK(8, 7)
-#define REW_TAG_CFG_TAG_CFG_X(x)                          (((x) & GENMASK(8, 7)) >> 7)
-#define REW_TAG_CFG_TAG_TPID_CFG(x)                       (((x) << 5) & GENMASK(6, 5))
-#define REW_TAG_CFG_TAG_TPID_CFG_M                        GENMASK(6, 5)
-#define REW_TAG_CFG_TAG_TPID_CFG_X(x)                     (((x) & GENMASK(6, 5)) >> 5)
-#define REW_TAG_CFG_TAG_VID_CFG                           BIT(4)
-#define REW_TAG_CFG_TAG_PCP_CFG(x)                        (((x) << 2) & GENMASK(3, 2))
-#define REW_TAG_CFG_TAG_PCP_CFG_M                         GENMASK(3, 2)
-#define REW_TAG_CFG_TAG_PCP_CFG_X(x)                      (((x) & GENMASK(3, 2)) >> 2)
-#define REW_TAG_CFG_TAG_DEI_CFG(x)                        ((x) & GENMASK(1, 0))
-#define REW_TAG_CFG_TAG_DEI_CFG_M                         GENMASK(1, 0)
-
-#define REW_PORT_CFG_GSZ                                  0x80
-
-#define REW_PORT_CFG_ES0_EN                               BIT(5)
-#define REW_PORT_CFG_FCS_UPDATE_NONCPU_CFG(x)             (((x) << 3) & GENMASK(4, 3))
-#define REW_PORT_CFG_FCS_UPDATE_NONCPU_CFG_M              GENMASK(4, 3)
-#define REW_PORT_CFG_FCS_UPDATE_NONCPU_CFG_X(x)           (((x) & GENMASK(4, 3)) >> 3)
-#define REW_PORT_CFG_FCS_UPDATE_CPU_ENA                   BIT(2)
-#define REW_PORT_CFG_FLUSH_ENA                            BIT(1)
-#define REW_PORT_CFG_AGE_DIS                              BIT(0)
-
-#define REW_DSCP_CFG_GSZ                                  0x80
-
-#define REW_PCP_DEI_QOS_MAP_CFG_GSZ                       0x80
-#define REW_PCP_DEI_QOS_MAP_CFG_RSZ                       0x4
-
-#define REW_PCP_DEI_QOS_MAP_CFG_DEI_QOS_VAL               BIT(3)
-#define REW_PCP_DEI_QOS_MAP_CFG_PCP_QOS_VAL(x)            ((x) & GENMASK(2, 0))
-#define REW_PCP_DEI_QOS_MAP_CFG_PCP_QOS_VAL_M             GENMASK(2, 0)
-
-#define REW_PTP_CFG_GSZ                                   0x80
-
-#define REW_PTP_CFG_PTP_BACKPLANE_MODE                    BIT(7)
-#define REW_PTP_CFG_GP_CFG_UNUSED(x)                      (((x) << 3) & GENMASK(6, 3))
-#define REW_PTP_CFG_GP_CFG_UNUSED_M                       GENMASK(6, 3)
-#define REW_PTP_CFG_GP_CFG_UNUSED_X(x)                    (((x) & GENMASK(6, 3)) >> 3)
-#define REW_PTP_CFG_PTP_1STEP_DIS                         BIT(2)
-#define REW_PTP_CFG_PTP_2STEP_DIS                         BIT(1)
-#define REW_PTP_CFG_PTP_UDP_KEEP                          BIT(0)
-
-#define REW_PTP_DLY1_CFG_GSZ                              0x80
-
-#define REW_RED_TAG_CFG_GSZ                               0x80
-
-#define REW_RED_TAG_CFG_RED_TAG_CFG                       BIT(0)
-
-#define REW_DSCP_REMAP_DP1_CFG_RSZ                        0x4
-
-#define REW_DSCP_REMAP_CFG_RSZ                            0x4
-
-#define REW_REW_STICKY_ES0_TAGB_PUSH_FAILED               BIT(0)
-
-#define REW_PPT_RSZ                                       0x4
-
-#endif
diff --git a/drivers/net/ethernet/mscc/ocelot_sys.h b/drivers/net/ethernet/mscc/ocelot_sys.h
deleted file mode 100644
index 16f91e172bcb..000000000000
--- a/drivers/net/ethernet/mscc/ocelot_sys.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
-/*
- * Microsemi Ocelot Switch driver
- *
- * Copyright (c) 2017 Microsemi Corporation
- */
-
-#ifndef _MSCC_OCELOT_SYS_H_
-#define _MSCC_OCELOT_SYS_H_
-
-#define SYS_COUNT_RX_OCTETS_RSZ                           0x4
-
-#define SYS_COUNT_TX_OCTETS_RSZ                           0x4
-
-#define SYS_PORT_MODE_RSZ                                 0x4
-
-#define SYS_PORT_MODE_DATA_WO_TS(x)                       (((x) << 5) & GENMASK(6, 5))
-#define SYS_PORT_MODE_DATA_WO_TS_M                        GENMASK(6, 5)
-#define SYS_PORT_MODE_DATA_WO_TS_X(x)                     (((x) & GENMASK(6, 5)) >> 5)
-#define SYS_PORT_MODE_INCL_INJ_HDR(x)                     (((x) << 3) & GENMASK(4, 3))
-#define SYS_PORT_MODE_INCL_INJ_HDR_M                      GENMASK(4, 3)
-#define SYS_PORT_MODE_INCL_INJ_HDR_X(x)                   (((x) & GENMASK(4, 3)) >> 3)
-#define SYS_PORT_MODE_INCL_XTR_HDR(x)                     (((x) << 1) & GENMASK(2, 1))
-#define SYS_PORT_MODE_INCL_XTR_HDR_M                      GENMASK(2, 1)
-#define SYS_PORT_MODE_INCL_XTR_HDR_X(x)                   (((x) & GENMASK(2, 1)) >> 1)
-#define SYS_PORT_MODE_INJ_HDR_ERR                         BIT(0)
-
-#define SYS_FRONT_PORT_MODE_RSZ                           0x4
-
-#define SYS_FRONT_PORT_MODE_HDX_MODE                      BIT(0)
-
-#define SYS_FRM_AGING_AGE_TX_ENA                          BIT(20)
-#define SYS_FRM_AGING_MAX_AGE(x)                          ((x) & GENMASK(19, 0))
-#define SYS_FRM_AGING_MAX_AGE_M                           GENMASK(19, 0)
-
-#define SYS_STAT_CFG_STAT_CLEAR_SHOT(x)                   (((x) << 10) & GENMASK(16, 10))
-#define SYS_STAT_CFG_STAT_CLEAR_SHOT_M                    GENMASK(16, 10)
-#define SYS_STAT_CFG_STAT_CLEAR_SHOT_X(x)                 (((x) & GENMASK(16, 10)) >> 10)
-#define SYS_STAT_CFG_STAT_VIEW(x)                         ((x) & GENMASK(9, 0))
-#define SYS_STAT_CFG_STAT_VIEW_M                          GENMASK(9, 0)
-
-#define SYS_SW_STATUS_RSZ                                 0x4
-
-#define SYS_SW_STATUS_PORT_RX_PAUSED                      BIT(0)
-
-#define SYS_MISC_CFG_PTP_RSRV_CLR                         BIT(1)
-#define SYS_MISC_CFG_PTP_DIS_NEG_RO                       BIT(0)
-
-#define SYS_REW_MAC_HIGH_CFG_RSZ                          0x4
-
-#define SYS_REW_MAC_LOW_CFG_RSZ                           0x4
-
-#define SYS_TIMESTAMP_OFFSET_ETH_TYPE_CFG(x)              (((x) << 6) & GENMASK(21, 6))
-#define SYS_TIMESTAMP_OFFSET_ETH_TYPE_CFG_M               GENMASK(21, 6)
-#define SYS_TIMESTAMP_OFFSET_ETH_TYPE_CFG_X(x)            (((x) & GENMASK(21, 6)) >> 6)
-#define SYS_TIMESTAMP_OFFSET_TIMESTAMP_OFFSET(x)          ((x) & GENMASK(5, 0))
-#define SYS_TIMESTAMP_OFFSET_TIMESTAMP_OFFSET_M           GENMASK(5, 0)
-
-#define SYS_PAUSE_CFG_RSZ                                 0x4
-
-#define SYS_PAUSE_CFG_PAUSE_START(x)                      (((x) << 10) & GENMASK(18, 10))
-#define SYS_PAUSE_CFG_PAUSE_START_M                       GENMASK(18, 10)
-#define SYS_PAUSE_CFG_PAUSE_START_X(x)                    (((x) & GENMASK(18, 10)) >> 10)
-#define SYS_PAUSE_CFG_PAUSE_STOP(x)                       (((x) << 1) & GENMASK(9, 1))
-#define SYS_PAUSE_CFG_PAUSE_STOP_M                        GENMASK(9, 1)
-#define SYS_PAUSE_CFG_PAUSE_STOP_X(x)                     (((x) & GENMASK(9, 1)) >> 1)
-#define SYS_PAUSE_CFG_PAUSE_ENA                           BIT(0)
-
-#define SYS_PAUSE_TOT_CFG_PAUSE_TOT_START(x)              (((x) << 9) & GENMASK(17, 9))
-#define SYS_PAUSE_TOT_CFG_PAUSE_TOT_START_M               GENMASK(17, 9)
-#define SYS_PAUSE_TOT_CFG_PAUSE_TOT_START_X(x)            (((x) & GENMASK(17, 9)) >> 9)
-#define SYS_PAUSE_TOT_CFG_PAUSE_TOT_STOP(x)               ((x) & GENMASK(8, 0))
-#define SYS_PAUSE_TOT_CFG_PAUSE_TOT_STOP_M                GENMASK(8, 0)
-
-#define SYS_ATOP_RSZ                                      0x4
-
-#define SYS_MAC_FC_CFG_RSZ                                0x4
-
-#define SYS_MAC_FC_CFG_FC_LINK_SPEED(x)                   (((x) << 26) & GENMASK(27, 26))
-#define SYS_MAC_FC_CFG_FC_LINK_SPEED_M                    GENMASK(27, 26)
-#define SYS_MAC_FC_CFG_FC_LINK_SPEED_X(x)                 (((x) & GENMASK(27, 26)) >> 26)
-#define SYS_MAC_FC_CFG_FC_LATENCY_CFG(x)                  (((x) << 20) & GENMASK(25, 20))
-#define SYS_MAC_FC_CFG_FC_LATENCY_CFG_M                   GENMASK(25, 20)
-#define SYS_MAC_FC_CFG_FC_LATENCY_CFG_X(x)                (((x) & GENMASK(25, 20)) >> 20)
-#define SYS_MAC_FC_CFG_ZERO_PAUSE_ENA                     BIT(18)
-#define SYS_MAC_FC_CFG_TX_FC_ENA                          BIT(17)
-#define SYS_MAC_FC_CFG_RX_FC_ENA                          BIT(16)
-#define SYS_MAC_FC_CFG_PAUSE_VAL_CFG(x)                   ((x) & GENMASK(15, 0))
-#define SYS_MAC_FC_CFG_PAUSE_VAL_CFG_M                    GENMASK(15, 0)
-
-#define SYS_MMGT_RELCNT(x)                                (((x) << 16) & GENMASK(31, 16))
-#define SYS_MMGT_RELCNT_M                                 GENMASK(31, 16)
-#define SYS_MMGT_RELCNT_X(x)                              (((x) & GENMASK(31, 16)) >> 16)
-#define SYS_MMGT_FREECNT(x)                               ((x) & GENMASK(15, 0))
-#define SYS_MMGT_FREECNT_M                                GENMASK(15, 0)
-
-#define SYS_MMGT_FAST_FREEVLD(x)                          (((x) << 4) & GENMASK(7, 4))
-#define SYS_MMGT_FAST_FREEVLD_M                           GENMASK(7, 4)
-#define SYS_MMGT_FAST_FREEVLD_X(x)                        (((x) & GENMASK(7, 4)) >> 4)
-#define SYS_MMGT_FAST_RELVLD(x)                           ((x) & GENMASK(3, 0))
-#define SYS_MMGT_FAST_RELVLD_M                            GENMASK(3, 0)
-
-#define SYS_EVENTS_DIF_RSZ                                0x4
-
-#define SYS_EVENTS_DIF_EV_DRX(x)                          (((x) << 6) & GENMASK(8, 6))
-#define SYS_EVENTS_DIF_EV_DRX_M                           GENMASK(8, 6)
-#define SYS_EVENTS_DIF_EV_DRX_X(x)                        (((x) & GENMASK(8, 6)) >> 6)
-#define SYS_EVENTS_DIF_EV_DTX(x)                          ((x) & GENMASK(5, 0))
-#define SYS_EVENTS_DIF_EV_DTX_M                           GENMASK(5, 0)
-
-#define SYS_EVENTS_CORE_EV_FWR                            BIT(2)
-#define SYS_EVENTS_CORE_EV_ANA(x)                         ((x) & GENMASK(1, 0))
-#define SYS_EVENTS_CORE_EV_ANA_M                          GENMASK(1, 0)
-
-#define SYS_CNT_GSZ                                       0x4
-
-#define SYS_PTP_STATUS_PTP_TXSTAMP_OAM                    BIT(29)
-#define SYS_PTP_STATUS_PTP_OVFL                           BIT(28)
-#define SYS_PTP_STATUS_PTP_MESS_VLD                       BIT(27)
-#define SYS_PTP_STATUS_PTP_MESS_ID(x)                     (((x) << 21) & GENMASK(26, 21))
-#define SYS_PTP_STATUS_PTP_MESS_ID_M                      GENMASK(26, 21)
-#define SYS_PTP_STATUS_PTP_MESS_ID_X(x)                   (((x) & GENMASK(26, 21)) >> 21)
-#define SYS_PTP_STATUS_PTP_MESS_TXPORT(x)                 (((x) << 16) & GENMASK(20, 16))
-#define SYS_PTP_STATUS_PTP_MESS_TXPORT_M                  GENMASK(20, 16)
-#define SYS_PTP_STATUS_PTP_MESS_TXPORT_X(x)               (((x) & GENMASK(20, 16)) >> 16)
-#define SYS_PTP_STATUS_PTP_MESS_SEQ_ID(x)                 ((x) & GENMASK(15, 0))
-#define SYS_PTP_STATUS_PTP_MESS_SEQ_ID_M                  GENMASK(15, 0)
-
-#define SYS_PTP_TXSTAMP_PTP_TXSTAMP(x)                    ((x) & GENMASK(29, 0))
-#define SYS_PTP_TXSTAMP_PTP_TXSTAMP_M                     GENMASK(29, 0)
-#define SYS_PTP_TXSTAMP_PTP_TXSTAMP_SEC                   BIT(31)
-
-#define SYS_PTP_NXT_PTP_NXT                               BIT(0)
-
-#define SYS_PTP_CFG_PTP_STAMP_WID(x)                      (((x) << 2) & GENMASK(7, 2))
-#define SYS_PTP_CFG_PTP_STAMP_WID_M                       GENMASK(7, 2)
-#define SYS_PTP_CFG_PTP_STAMP_WID_X(x)                    (((x) & GENMASK(7, 2)) >> 2)
-#define SYS_PTP_CFG_PTP_CF_ROLL_MODE(x)                   ((x) & GENMASK(1, 0))
-#define SYS_PTP_CFG_PTP_CF_ROLL_MODE_M                    GENMASK(1, 0)
-
-#define SYS_RAM_INIT_RAM_INIT                             BIT(1)
-#define SYS_RAM_INIT_RAM_CFG_HOOK                         BIT(0)
-
-#endif
diff --git a/include/net/tsn.h b/include/net/tsn.h
deleted file mode 100644
index bcfb33637265..000000000000
--- a/include/net/tsn.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
-/* Copyright 2017-2018 NXP */
-
-#ifndef __TSN_H__
-#define __TSN_H__
-
-#include <uapi/linux/tsn.h>
-
-struct tsn_ops {
-	void (*device_init)(struct net_device *ndev);
-	void (*device_deinit)(struct net_device *ndev);
-	u32 (*get_capability)(struct net_device *ndev);
-	/* Qbv standard */
-	int (*qbv_set)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
-	int (*qbv_get)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
-	int (*qbv_get_status)(struct net_device *ndev,
-				struct tsn_qbv_status *qbvstat);
-	int (*cb_streamid_set)(struct net_device *ndev, u32 index,
-				bool enable, struct tsn_cb_streamid *sid);
-	int (*cb_streamid_get)(struct net_device *ndev, u32 index,
-				struct tsn_cb_streamid *sid);
-	int (*cb_streamid_counters_get)(struct net_device *ndev, u32 index,
-				struct tsn_cb_streamid_counters *sidcounter);
-	int (*qci_get_maxcap)(struct net_device *ndev,
-				struct tsn_qci_psfp_stream_param *qcicapa);
-	int (*qci_sfi_set)(struct net_device *ndev, u32 index, bool enable,
-				struct tsn_qci_psfp_sfi_conf *sficonf);
-	/* return: 0 stream filter instance not valid
-	 * 1 stream filter instance valid
-	 * -1 error happened
-	 */
-	int (*qci_sfi_get)(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_sfi_conf *sficonf);
-	int (*qci_sfi_counters_get)(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_sfi_counters *sficounter);
-	int (*qci_sgi_set)(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_sgi_conf *sgiconf);
-	int (*qci_sgi_get)(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_sgi_conf *sgiconf);
-	int (*qci_sgi_status_get)(struct net_device *ndev, u16 index,
-				struct tsn_psfp_sgi_status *sgistat);
-	int (*qci_fmi_set)(struct net_device *ndev, u32 index, bool enable,
-				struct tsn_qci_psfp_fmi *fmi);
-	int (*qci_fmi_get)(struct net_device *ndev, u32 index,
-				struct tsn_qci_psfp_fmi *fmi,
-				struct tsn_qci_psfp_fmi_counters *counters);
-	int (*cbs_set)(struct net_device *ndev, u8 tc, u8 bw);
-	int (*cbs_get)(struct net_device *ndev, u8 tc);
-	/* To set a 8 bits vector shows 8 traffic classes
-	 * preemtable(1) or express(0)
-	 */
-	int (*qbu_set)(struct net_device *ndev, u8 ptvector);
-	/* To get port preemtion status */
-	int (*qbu_get)(struct net_device *ndev,
-				struct tsn_preempt_status *preemptstat);
-	int (*tsd_set)(struct net_device *ndev, struct tsn_tsd *tsd);
-	int (*tsd_get)(struct net_device *ndev, struct tsn_tsd_status *stats);
-	int (*ct_set)(struct net_device *ndev, u8 cut_thru);
-	int (*cbgen_set)(struct net_device *ndev, u32 index,
-			 struct tsn_seq_gen_conf *seqgen);
-	int (*cbrec_set)(struct net_device *ndev, u32 index,
-			 struct tsn_seq_rec_conf *seqrec);
-	int (*cb_get)(struct net_device *ndev, u32 index,
-		      struct tsn_cb_status  *c);
-	int (*pcpmap_set)(struct net_device *ndev, bool enable);
-	int (*dscp_set)(struct net_device *ndev, bool enable,
-			const u8 dscp_ix,
-			struct tsn_qos_switch_dscp_conf *c);
-};
-
-enum ethdev_type {
-	TSN_SWITCH,
-	TSN_ENDPOINT,
-};
-
-#define GROUP_OFFSET_SWITCH 256
-
-struct tsn_port {
-	u16 groupid;
-	struct tsn_ops *tsnops;
-	struct net_device *netdev;
-	struct list_head list;
-	enum ethdev_type type;
-};
-
-int tsn_port_register(struct net_device *netdev,
-				struct tsn_ops *tsnops, u16 groupid);
-void tsn_port_unregister(struct net_device *netdev);
-#endif
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
deleted file mode 100644
index c074bee3390e..000000000000
--- a/include/uapi/linux/tsn.h
+++ /dev/null
@@ -1,1110 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
-/* Copyright 2017-2018 NXP */
-
-#ifndef __UAPI_GENL_TSN_H
-#define __UAPI_GENL_TSN_H
-
-#define	TSN_GENL_NAME		"TSN_GEN_CTRL"
-#define	TSN_GENL_VERSION	0x1
-
-#define MAX_USER_SIZE 0
-#define MAX_ATTR_SIZE 3072
-#define MAX_TOTAL_MSG_SIZE  (MAX_USER_SIZE + MAX_ATTR_SIZE)
-#define MAX_ENTRY_SIZE 2048
-#define MAX_ENTRY_NUMBER 128
-#define MAX_IFNAME_COUNT 64
-#define NUM_MSCC_QOS_PRIO 8
-#define MSCC_QOS_PRIO_MAX (NUM_MSCC_QOS_PRIO - 1)
-
-enum tsn_capability {
-	TSN_CAP_QBV = 0x1,
-	TSN_CAP_QCI = 0x2,
-	TSN_CAP_QBU = 0x4,
-	TSN_CAP_CBS = 0x8, /* Credit-based Shapter Qav */
-	TSN_CAP_CB  = 0x10, /* 8021CB redundancy and replication */
-	TSN_CAP_TBS = 0x20, /* Time Based schedule */
-};
-
-/*
- * Commands sent from userspace
- * Not versioned. New commands should only be inserted at the enum's end
- * prior to __TSN_CMD_MAX
- */
-
-enum {
-	TSN_CMD_UNSPEC = 0,	/* Reserved */
-	TSN_CMD_QBV_SET,
-	TSN_CMD_QBV_GET,
-	TSN_CMD_QBV_GET_STATUS,
-	TSN_CMD_CB_STREAMID_SET,
-	TSN_CMD_CB_STREAMID_GET,
-	TSN_CMD_CB_STREAMID_GET_COUNTS,
-	TSN_CMD_QCI_CAP_GET, /* Qci capability get length capability get */
-	TSN_CMD_QCI_SFI_SET,
-	TSN_CMD_QCI_SFI_GET,
-	TSN_CMD_QCI_SFI_GET_COUNTS,
-	TSN_CMD_QCI_SGI_SET,
-	TSN_CMD_QCI_SGI_GET,
-	TSN_CMD_QCI_SGI_GET_STATUS,
-	TSN_CMD_QCI_FMI_SET,
-	TSN_CMD_QCI_FMI_GET,
-	TSN_CMD_CBS_SET,
-	TSN_CMD_CBS_GET,
-	TSN_CMD_QBU_SET,
-	TSN_CMD_QBU_GET_STATUS,
-	TSN_CMD_QAV_SET_CBS,
-	TSN_CMD_QAV_GET_CBS,
-	TSN_CMD_TSD_SET,
-	TSN_CMD_TSD_GET,
-	TSN_CMD_CT_SET,
-	TSN_CMD_CBGEN_SET,
-	TSN_CMD_CBREC_SET,
-	TSN_CMD_CBSTAT_GET,
-	TSN_CMD_PCPMAP_SET,
-	TSN_CMD_DSCP_SET,
-	TSN_CMD_ECHO,			/* user->kernel request/get-response */
-	TSN_CMD_REPLY,			/* kernel->user event */
-	__TSN_CMD_MAX,
-};
-#define TSN_CMD_MAX (__TSN_CMD_MAX - 1)
-
-
-enum {
-	TSN_CMD_ATTR_UNSPEC = 0,
-	TSN_CMD_ATTR_MESG,		/* demo message  */
-	TSN_CMD_ATTR_DATA,		/* demo data */
-	TSN_ATTR_IFNAME,
-	TSN_ATTR_PORT_NUMBER,
-	TSN_ATTR_QBV,
-	TSN_ATTR_STREAM_IDENTIFY, /* stream identify */
-	TSN_ATTR_QCI_SP,		/* psfp port capbility parameters */
-	TSN_ATTR_QCI_SFI,		/* psfp stream filter instance */
-	TSN_ATTR_QCI_SGI,		/* psfp stream gate instance */
-	TSN_ATTR_QCI_FMI,		/* psfp flow meter instance */
-	TSN_ATTR_CBS,			/* credit-based shaper */
-	TSN_ATTR_TSD,			/* Time Specific Departure */
-	TSN_ATTR_QBU,			/* preemption */
-	TSN_ATTR_CT,			/* cut through */
-	TSN_ATTR_CBGEN,			/* 802.1CB sequence generate */
-	TSN_ATTR_CBREC,			/* 802.1CB sequence recover */
-	TSN_ATTR_CBSTAT,                 /* 802.1CB status */
-	TSN_ATTR_PCPMAP,		/* map queue number to PCP tag */
-	TSN_ATTR_DSCP,
-	__TSN_CMD_ATTR_MAX,
-};
-#define TSN_CMD_ATTR_MAX (__TSN_CMD_ATTR_MAX - 1)
-
-enum {
-	TSN_QBU_ATTR_UNSPEC,
-	TSN_QBU_ATTR_ADMIN_STATE,
-	TSN_QBU_ATTR_HOLD_ADVANCE,
-	TSN_QBU_ATTR_RELEASE_ADVANCE,
-	TSN_QBU_ATTR_ACTIVE,
-	TSN_QBU_ATTR_HOLD_REQUEST,
-	__TSN_QBU_ATTR_MAX,
-	TSN_QBU_ATTR_MAX = __TSN_QBU_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_CBS_ATTR_UNSPEC,
-	TSN_CBS_ATTR_TC_INDEX,
-	TSN_CBS_ATTR_BW,
-	__TSN_CBS_ATTR_MAX,
-	TSN_CBS_ATTR_MAX = __TSN_CBS_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_TSD_ATTR_UNSPEC,
-	TSN_TSD_ATTR_DISABLE,
-	TSN_TSD_ATTR_ENABLE,
-	TSN_TSD_ATTR_PERIOD,
-	TSN_TSD_ATTR_MAX_FRM_NUM,
-	TSN_TSD_ATTR_CYCLE_NUM,
-	TSN_TSD_ATTR_LOSS_STEPS,
-	TSN_TSD_ATTR_SYN_IMME,
-	__TSN_TSD_ATTR_MAX,
-	TSN_TSD_ATTR_MAX = __TSN_TSD_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_STREAMID_ATTR_UNSPEC,
-	TSN_STREAMID_ATTR_INDEX,
-	TSN_STREAMID_ATTR_ENABLE,
-	TSN_STREAMID_ATTR_DISABLE,
-	TSN_STREAMID_ATTR_STREAM_HANDLE,
-	TSN_STREAMID_ATTR_IFOP,
-	TSN_STREAMID_ATTR_OFOP,
-	TSN_STREAMID_ATTR_IFIP,
-	TSN_STREAMID_ATTR_OFIP,
-	TSN_STREAMID_ATTR_TYPE,
-	TSN_STREAMID_ATTR_NDMAC,
-	TSN_STREAMID_ATTR_NTAGGED,
-	TSN_STREAMID_ATTR_NVID,
-	TSN_STREAMID_ATTR_SMAC,
-	TSN_STREAMID_ATTR_STAGGED,
-	TSN_STREAMID_ATTR_SVID,
-	TSN_STREAMID_ATTR_COUNTERS_PSI,
-	TSN_STREAMID_ATTR_COUNTERS_PSO,
-	TSN_STREAMID_ATTR_COUNTERS_PSPPI,
-	TSN_STREAMID_ATTR_COUNTERS_PSPPO,
-	__TSN_STREAMID_ATTR_MAX,
-	TSN_STREAMID_ATTR_MAX = __TSN_STREAMID_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_QCI_SFI_ATTR_UNSPEC = 0,
-	TSN_QCI_SFI_ATTR_INDEX,
-	TSN_QCI_SFI_ATTR_ENABLE,
-	TSN_QCI_SFI_ATTR_DISABLE,
-	TSN_QCI_SFI_ATTR_STREAM_HANDLE,
-	TSN_QCI_SFI_ATTR_PRIO_SPEC,
-	TSN_QCI_SFI_ATTR_GATE_ID,
-	TSN_QCI_SFI_ATTR_FILTER_TYPE,
-	TSN_QCI_SFI_ATTR_FLOW_ID,
-	TSN_QCI_SFI_ATTR_MAXSDU,
-	TSN_QCI_SFI_ATTR_COUNTERS,
-	TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE,
-	TSN_QCI_SFI_ATTR_OVERSIZE,
-	__TSN_QCI_SFI_ATTR_MAX,
-	TSN_QCI_SFI_ATTR_MAX = __TSN_QCI_SFI_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_QCI_SFI_ATTR_COUNTERS_UNSPEC = 0,
-	TSN_QCI_SFI_ATTR_MATCH,
-	TSN_QCI_SFI_ATTR_PASS,
-	TSN_QCI_SFI_ATTR_DROP,
-	TSN_QCI_SFI_ATTR_SDU_DROP,
-	TSN_QCI_SFI_ATTR_SDU_PASS,
-	TSN_QCI_SFI_ATTR_RED,
-	__TSN_QCI_SFI_ATTR_COUNT_MAX,
-	TSN_QCI_SFI_ATTR_COUNT_MAX = __TSN_QCI_SFI_ATTR_COUNT_MAX - 1,
-};
-
-enum {
-	TSN_QCI_SGI_ATTR_UNSPEC = 0,
-	TSN_QCI_SGI_ATTR_INDEX,
-	TSN_QCI_SGI_ATTR_ENABLE,
-	TSN_QCI_SGI_ATTR_DISABLE,
-	TSN_QCI_SGI_ATTR_CONFCHANGE,
-	TSN_QCI_SGI_ATTR_IRXEN,		/* Invalid rx enable*/
-	TSN_QCI_SGI_ATTR_IRX,
-	TSN_QCI_SGI_ATTR_OEXEN,		/* Octet exceed enable */
-	TSN_QCI_SGI_ATTR_OEX,
-	TSN_QCI_SGI_ATTR_ADMINENTRY,
-	TSN_QCI_SGI_ATTR_OPERENTRY,
-	TSN_QCI_SGI_ATTR_CCTIME,	/* config change time */
-	TSN_QCI_SGI_ATTR_TICKG,
-	TSN_QCI_SGI_ATTR_CUTIME,
-	TSN_QCI_SGI_ATTR_CPENDING,
-	TSN_QCI_SGI_ATTR_CCERROR,
-	__TSN_QCI_SGI_ATTR_MAX,
-	TSN_QCI_SGI_ATTR_MAX = __TSN_QCI_SGI_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_SGI_ATTR_CTRL_UNSPEC = 0,
-	TSN_SGI_ATTR_CTRL_INITSTATE,
-	TSN_SGI_ATTR_CTRL_LEN,
-	TSN_SGI_ATTR_CTRL_CYTIME,
-	TSN_SGI_ATTR_CTRL_CYTIMEEX,
-	TSN_SGI_ATTR_CTRL_BTIME,
-	TSN_SGI_ATTR_CTRL_INITIPV,
-	TSN_SGI_ATTR_CTRL_GCLENTRY,
-	__TSN_SGI_ATTR_CTRL_MAX,
-	TSN_SGI_ATTR_CTRL_MAX = __TSN_SGI_ATTR_CTRL_MAX - 1,
-};
-
-enum {
-	TSN_SGI_ATTR_GCL_UNSPEC = 0,
-	TSN_SGI_ATTR_GCL_GATESTATE,
-	TSN_SGI_ATTR_GCL_IPV,
-	TSN_SGI_ATTR_GCL_INTERVAL,
-	TSN_SGI_ATTR_GCL_OCTMAX,
-	__TSN_SGI_ATTR_GCL_MAX,
-	TSN_SGI_ATTR_GCL_MAX = __TSN_SGI_ATTR_GCL_MAX - 1,
-};
-
-enum {
-	TSN_QCI_FMI_ATTR_UNSPEC = 0,
-	TSN_QCI_FMI_ATTR_INDEX,
-	TSN_QCI_FMI_ATTR_ENABLE,
-	TSN_QCI_FMI_ATTR_DISABLE,
-	TSN_QCI_FMI_ATTR_CIR,
-	TSN_QCI_FMI_ATTR_CBS,
-	TSN_QCI_FMI_ATTR_EIR,
-	TSN_QCI_FMI_ATTR_EBS,
-	TSN_QCI_FMI_ATTR_CF,
-	TSN_QCI_FMI_ATTR_CM,
-	TSN_QCI_FMI_ATTR_DROPYL,
-	TSN_QCI_FMI_ATTR_MAREDEN,
-	TSN_QCI_FMI_ATTR_MARED,
-	TSN_QCI_FMI_ATTR_COUNTERS,
-	__TSN_QCI_FMI_ATTR_MAX,
-	TSN_QCI_FMI_ATTR_MAX = __TSN_QCI_FMI_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_QBV_ATTR_UNSPEC,
-	TSN_QBV_ATTR_ENABLE,
-	TSN_QBV_ATTR_DISABLE,
-	TSN_QBV_ATTR_CONFIGCHANGE,
-	TSN_QBV_ATTR_CONFIGCHANGETIME,
-	TSN_QBV_ATTR_MAXSDU,
-	TSN_QBV_ATTR_GRANULARITY,
-	TSN_QBV_ATTR_CURRENTTIME,
-	TSN_QBV_ATTR_CONFIGPENDING,
-	TSN_QBV_ATTR_CONFIGCHANGEERROR,
-	TSN_QBV_ATTR_ADMINENTRY,
-	TSN_QBV_ATTR_OPERENTRY,
-	TSN_QBV_ATTR_LISTMAX,
-	__TSN_QBV_ATTR_MAX,
-	TSN_QBV_ATTR_MAX = __TSN_QBV_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_QBV_ATTR_CTRL_UNSPEC,
-	TSN_QBV_ATTR_CTRL_LISTCOUNT,
-	TSN_QBV_ATTR_CTRL_GATESTATE,
-	TSN_QBV_ATTR_CTRL_CYCLETIME,
-	TSN_QBV_ATTR_CTRL_CYCLETIMEEXT,
-	TSN_QBV_ATTR_CTRL_BASETIME,
-	TSN_QBV_ATTR_CTRL_LISTENTRY,
-	__TSN_QBV_ATTR_CTRL_MAX,
-	TSN_QBV_ATTR_CTRL_MAX = __TSN_QBV_ATTR_CTRL_MAX - 1,
-};
-
-enum {
-	TSN_QBV_ATTR_ENTRY_UNSPEC,
-	TSN_QBV_ATTR_ENTRY_ID,
-	TSN_QBV_ATTR_ENTRY_GC,
-	TSN_QBV_ATTR_ENTRY_TM,
-	__TSN_QBV_ATTR_ENTRY_MAX,
-	TSN_QBV_ATTR_ENTRY_MAX = __TSN_QBV_ATTR_ENTRY_MAX - 1,
-};
-
-enum {
-	TSN_CT_ATTR_UNSPEC,
-	TSN_CT_ATTR_QUEUE_STATE,
-	__TSN_CT_ATTR_MAX,
-	TSN_CT_ATTR_MAX = __TSN_CT_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_CBGEN_ATTR_UNSPEC,
-	TSN_CBGEN_ATTR_INDEX,
-	TSN_CBGEN_ATTR_PORT_MASK,
-	TSN_CBGEN_ATTR_SPLIT_MASK,
-	TSN_CBGEN_ATTR_SEQ_LEN,
-	TSN_CBGEN_ATTR_SEQ_NUM,
-	__TSN_CBGEN_ATTR_MAX,
-	TSN_CBGEN_ATTR_MAX = __TSN_CBGEN_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_CBREC_ATTR_UNSPEC,
-	TSN_CBREC_ATTR_INDEX,
-	TSN_CBREC_ATTR_SEQ_LEN,
-	TSN_CBREC_ATTR_HIS_LEN,
-	TSN_CBREC_ATTR_TAG_POP_EN,
-	__TSN_CBREC_ATTR_MAX,
-	TSN_CBREC_ATTR_MAX = __TSN_CBREC_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_CBSTAT_ATTR_UNSPEC,
-	TSN_CBSTAT_ATTR_INDEX,
-	TSN_CBSTAT_ATTR_GEN_REC,
-	TSN_CBSTAT_ATTR_ERR,
-	TSN_CBSTAT_ATTR_SEQ_NUM,
-	TSN_CBSTAT_ATTR_SEQ_LEN,
-	TSN_CBSTAT_ATTR_SPLIT_MASK,
-	TSN_CBSTAT_ATTR_PORT_MASK,
-	TSN_CBSTAT_ATTR_HIS_LEN,
-	TSN_CBSTAT_ATTR_SEQ_HIS,
-	__TSN_CBSTAT_ATTR_MAX,
-	TSN_CBSTAT_ATTR_MAX = __TSN_CBSTAT_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_PCPMAP_ATTR_UNSPEC,
-	TSN_PCPMAP_ATTR_ENABLE,
-	__TSN_PCPMAP_ATTR_MAX,
-	TSN_PCPMAP_ATTR_MAX = __TSN_PCPMAP_ATTR_MAX - 1,
-};
-
-enum {
-	TSN_DSCP_ATTR_UNSPEC,
-	TSN_DSCP_ATTR_DISABLE,
-	TSN_DSCP_ATTR_INDEX,
-	TSN_DSCP_ATTR_COS,
-	TSN_DSCP_ATTR_DPL,
-	__TSN_DSCP_ATTR_MAX,
-	TSN_DSCP_ATTR_MAX = __TSN_DSCP_ATTR_MAX - 1,
-};
-
-#define ptptime_t uint64_t
-
-#define MAX_QUEUE_CNT 8
-
-struct tsn_preempt_status {
-	/* The value of admin_state shows a 8-bits vector value for showing
-	 * the framePreemptionAdminStatus parameter and PreemptionPriority
-	 * for the traffic class. Bit-7 is the highest priority traffic class
-	 * and the bit-0 is the lowest priority traffic class.
-	 * The bit is express (0) and is preemptible (1).
-	 */
-	uint8_t admin_state;
-	/* The value of the holdAdvance parameter for the port in nanoseconds.
-	 * There is no default value; the holdAdvance is a property of the
-	 * underlying MAC." This parameter corresponds to the holdAdvance
-	 * parameter in 802.1Qbu.
-	 */
-	uint32_t hold_advance;
-
-	/* The value of the releaseAdvance parameter for the port in
-	 * nanoseconds.  There is no default value; the releaseAdvance is a
-	 * property of the underlying MAC." This parameter corresponds to the
-	 * releaseAdvance parameter in 802.1Qbu.
-	 */
-	uint32_t release_advance;
-
-	/* The value is active (TRUE) when preemption is operationally active
-	 * for the port, and idle (FALSE) otherwise.  This parameter corresponds
-	 * to the preemptionActive parameter in 802.1Qbu.
-	 */
-	bool preemption_active;
-
-	/* The value is hold (1) when the sequence of gate operations for
-	 * the port has executed a Set-And-Hold-MAC operation, and release
-	 * (2) when the sequence of gate operations has executed a
-	 * Set-And-Release-MAC operation. The value of this object is release
-	 * (FALSE) on system initialization.  This parameter corresponds to the
-	 * holdRequest parameter in 802.1Qbu.
-	 */
-	uint8_t hold_request;
-};
-
-enum tsn_tx_mode  {
-	TX_MODE_STRICT,
-	TX_MODE_CBS,
-	TX_MODE_ETS,
-	TX_MODE_VENDOR_DEFINE = 255,
-};
-
-#define QUEUE_TX_MASK ((1 << TX_MODE_STRICT) | (1 << TX_MODE_CBS) \
-			| (1 << TX_MODE_ETS) | (1 << TX_MODE_VENDOR_DEFINE))
-
-struct cbs_status {
-	uint8_t delta_bw; /* percentage, 0~100 */
-	uint32_t idleslope;
-	int32_t sendslope;
-	uint32_t maxframesize;
-	uint32_t hicredit;
-	int32_t locredit;
-	uint32_t maxninference;
-};
-
-struct tx_queue {
-	/* tx_queue_capbility shows the queue's capability mask.
-	 * refer the enum tsn_tx_mode
-	 */
-	uint8_t capability;
-
-	/* tx_queue_mode is current queue working mode */
-	uint8_t mode;
-
-	/* prio is showing the queue priority */
-	uint8_t prio;
-
-	/* mstat shows the status data of cbs or priority */
-	union {
-		struct cbs_status cbs;
-	};
-};
-
-struct port_status {
-	/* txqueue_cnt shows how many queues in this port */
-	uint8_t queue_cnt;
-
-	/* max_rate(Mbit/s) is the port transmit rate current port is setting */
-	uint32_t max_rate;
-
-	/* tsn_capability mask the tsn capability */
-	uint32_t tsn_capability;
-};
-
-enum tsn_cb_streamid_type {
-	STREAMID_RESERVED = 0,
-	/* Null Stream identification */
-	STREAMID_NULL,
-	/* Source MAC and VLAN Stream identification */
-	STREAMID_SMAC_VLAN,
-	/* Active Destination MAC and VLAN stream identification */
-	STREAMID_DMAC_VLAN,
-	/* IP stream identification */
-	STREAMID_IP,
-};
-
-/* When instantiating an instance of the Null Stream identification function
- * 8021CB(6.4) for a particular input Stream, the managed objects in the
- * following subsections serve as the tsnStreamIdParameters managed object
- * 8021CB claus(9.1.1.7).
- */
-struct tsn_cb_null_streamid {
-	/* tsnCpeNullDownDestMac. Specifies the destination_address that
-	 * identifies a packet in an Enhanced Internal Sublayer Service (EISS)
-	 * indication primitive, to the Null Stream identification function.
-	 */
-	uint64_t dmac;
-
-	/* tsnCpeNullDownTagged. It can take the following values:
-	 * 1 tagged: A frame must have a VLAN tag to be recognized as belonging
-	 * to the Stream.
-	 * 2 priority: A frame must be untagged, or have a VLAN tag with a VLAN
-	 * ID = 0 to be recognized as belonging to the Stream.
-	 * 3 all: A frame is recognized as belonging to the Stream whether
-	 * tagged or not.
-	 */
-	uint8_t tagged;
-
-	/* tsnCpeNullDownVlan. Specifies the vlan_identifier parameter that
-	 * identifies a packet in an EISS indication primitive to the Null
-	 * Stream identification function. A value of 0 indicates that the vlan
-	 * _identifier parameter is ignored on EISS indication primitives.
-	 */
-	uint16_t vid;
-};
-
-struct tsn_cb_source_streamid {
-	uint64_t smac;
-	uint8_t tagged;
-	uint16_t vid;
-};
-
-struct tsn_cb_dest_streamid {
-	uint64_t down_dmac;
-	uint8_t down_tagged;
-	uint16_t down_vid;
-	uint8_t down_prio;
-	uint64_t up_dmac;
-	uint8_t up_tagged;
-	uint16_t up_vid;
-	uint8_t up_prio;
-};
-
-struct tsn_cb_ip_streamid {
-	uint64_t dmac;
-	uint8_t tagged;
-	uint16_t vid;
-	uint64_t siph;
-	uint64_t sipl;
-	uint64_t diph;
-	uint64_t dipl;
-	uint8_t dscp;
-	uint8_t npt;
-	uint16_t sport;
-	uint16_t dport;
-};
-
-/* 802.1CB stream identify table clause 9.1 */
-struct tsn_cb_streamid {
-	/* The objects in a given entry of the Stream identity table are used
-	 * to control packets whose stream_handle subparameter is equal to the
-	 * entry tsnStreamIdHandle object.
-	 */
-	int32_t handle;
-
-	/* The list of ports on which an in-facing Stream identification
-	 * function in the output (towards the system forwarding function)
-	 * direction Only Active Destination MAC and VLAN Stream identification
-	 * (or nothing) can be configured.
-	 */
-	uint32_t ifac_oport;
-
-	/* The list of ports on which an out-facing Stream identification
-	 * function in the output (towards the physical interface) direction.
-	 * Only Active Destination MAC and VLAN Stream identification
-	 * (or nothing) can be configured.
-	 */
-	uint32_t ofac_oport;
-
-	/* The list of ports on which an in-facing Stream identification
-	 * function in the input (coming from the system forwarding function)
-	 * direction
-	 */
-	uint32_t ifac_iport;
-
-	/* The list of ports on which an out-facing Stream identification
-	 * function in the input (coming from the physical interface) direction
-	 * .
-	 */
-	uint32_t ofac_iport;
-
-	/* An enumerated value indicating the method used to identify packets
-	 * belonging to the Stream.
-	 * The Organizationally Unique Identifier (OUI) or Company Identifier
-	 * (CID) to identify the organization defining the enumerated type
-	 * should be: 00-80-C2
-	 * 1: null stream identification
-	 * 2: source mac and vlan stream identification
-	 * 3: activ destination mac and vlan stream identification
-	 * 4: ip stream identifaciton
-	 */
-	uint8_t type;
-
-	/* tsnStreamIdParameters The number of controlling parameters for a
-	 * Stream identification method, their types and values, are specific
-	 * to the tsnStreamIdIdentificationType
-	 */
-	union {
-		struct tsn_cb_null_streamid nid;
-		struct tsn_cb_source_streamid sid;
-		struct tsn_cb_dest_streamid did;
-		struct tsn_cb_ip_streamid iid;
-	} para;
-};
-
-/* Following counters are instantiated for each port on which the Stream
- * identification function (6.2) is configured. The counters are indexed by
- * port number, facing (in-facing or out-facing), and stream_handle value
- * (tsnStreamIdHandle, 9.1.1.1).
- */
-struct tsn_cb_streamid_counters {
-	struct {
-		uint64_t input;
-		uint64_t output;
-	} per_stream;
-
-	struct {
-		uint64_t input;
-		uint64_t output;
-	} per_streamport[32];
-};
-
-/* 802.1Qci Stream Parameter Table, read from port */
-struct tsn_qci_psfp_stream_param {
-	/* MaxStreamFilterInstances.
-	 * The maximum number of Stream Filter instances supported by this
-	 * Bridge component.
-	 */
-	int32_t max_sf_instance;
-
-	/* MaxStreamGateInstances
-	 * The maximum number of Stream Gate instances supported by this Bridge
-	 * component.
-	 */
-	int32_t max_sg_instance;
-
-	/* MaxFlowMeterInstances
-	 * The maximum number of Flow Meter instances supported by this Bridge
-	 * component.
-	 */
-	int32_t max_fm_instance;
-
-	/* SupportedListMax
-	 * The maximum value supported by this Bridge component of the
-	 * AdminControlListLength and OperControlListLength parameters.
-	 */
-	int32_t supported_list_max;
-};
-
-/* 802.1Qci Stream Filter Instance Table, counters part only. */
-struct tsn_qci_psfp_sfi_counters {
-	/* The MatchingFramesCount counter counts received frames that match
-	 * this stream filter.
-	 */
-	uint64_t matching_frames_count;
-
-	/* The PassingFramesCount counter counts received frames that pass the
-	 * gate associated with this stream filter.
-	 */
-	uint64_t passing_frames_count;
-
-	/* The NotPassingFramesCount counter counts received frames that do not
-	 * pass the gate associated with this stream filter.
-	 */
-	uint64_t not_passing_frames_count;
-
-	/* The PassingSDUCount counter counts received frames that pass the SDU
-	 * size filter specification associated with this stream filter.
-	 */
-	uint64_t passing_sdu_count;
-
-	/* The NotPassingSDUCount counter counts received frames that do not
-	 * pass the SDU size filter specification associated with this stream
-	 * filter.
-	 */
-	uint64_t not_passing_sdu_count;
-
-	/* The  REDFramesCount counter counts received random early detection
-	 * (RED) frames associated with this stream filter.
-	 */
-	uint64_t red_frames_count;
-};
-
-/* 802.1Qci Stream Filter Instance Table, configuration part only. */
-struct tsn_qci_psfp_sfi_conf {
-
-	/* The StreamHandleSpec parameter contains a stream identifier
-	 * specification value. A value of -1 denotes the wild card value; zero
-	 * or positive values denote stream identifier values.
-	 */
-	int32_t stream_handle_spec;
-
-	/* The PrioritySpec parameter contains a priority specification value.
-	 * A value of -1 denotes the wild card value; zero or positive values
-	 * denote priority values.
-	 */
-	int8_t priority_spec;
-
-	/* The StreamGateInstanceID parameter contains the index of an entry in
-	 * the Stream Gate Table.
-	 */
-	uint32_t stream_gate_instance_id;
-
-	/* The filter specifications. The actions specified in a filter
-	 * specification can result in a frame passing or failing the specified
-	 * filter. Frames that fail a filter are discarded.
-	 */
-	struct {
-		/* The MaximumSDUSize parameter specifies the maximum allowed
-		 * frame size for the stream. Any frame exceeding this value
-		 * will be dropped.  A value of 0 denote that the MaximumSDUSize
-		 * filter is disabled for this stream.
-		 */
-		uint16_t maximum_sdu_size;
-
-		/* The FlowMeterInstanceID parameter contains the index of an
-		 * entry in the Flow Meter Table.  A value of -1 denotes that
-		 * no flow meter is assigned; zero or positive values denote
-		 * flow meter IDs.
-		 */
-		int32_t flow_meter_instance_id;
-	} stream_filter;
-
-	/* The StreamBlockedDueToOversizeFrameEnable object contains a Boolean
-	 * value that indicates whether the StreamBlockedDueToOversizeFrame
-	 * function is enabled (TRUE) or disabled (FALSE).
-	 */
-	bool block_oversize_enable;
-
-	/* The StreamBlockedDueToOversizeFrame object contains a Boolean value
-	 * that indicates whether, if the StreamBlockedDueToOversizeFrame
-	 * function is enabled, all frames are to be discarded (TRUE) or not
-	 * (FALSE).
-	 */
-	bool block_oversize;
-};
-
-/* 802.1Qci Stream Gate Control List Entry. */
-struct tsn_qci_psfp_gcl {
-	/* The GateState parameter specifies a desired state, open (true) or
-	 * closed (false), for the stream gate.
-	 */
-	bool gate_state;
-
-	/* An IPV is encoded as a signed integer.  A negative denotes the null
-	 * value; zero or positive values denote internal priority values.
-	 */
-	int8_t ipv;
-
-	/* A TimeInterval is encoded in 4 octets as a 32-bit unsigned integer,
-	 * representing a number of nanoseconds.
-	 */
-	uint32_t time_interval;
-
-	/* The maximum number of octets that are permitted to pass the gate
-	 * during the specified TimeInterval.  If zero, there is no maximum.
-	 */
-	uint32_t octet_max;
-
-};
-
-/* 802.1Qci Stream Gate Admin/Operation common list control parameters */
-struct tsn_qci_sg_control {
-	/* The administrative/operation value of the GateStates parameter
-	 * for the stream gate.  A value of false indicates closed;
-	 * a value of true indicates open.
-	 */
-	bool gate_states;
-
-	/* The administrative/operation value of the ListMax parameter for the
-	 * gate. The integer value indicates the number of entries (TLVs) in
-	 * the AdminControlList/OperControlList.
-	 */
-	uint8_t control_list_length;
-
-	/* The administrative/operation value of the CycleTime parameter for
-	 * the gate.  The value is an unsigned integer number of nanoseconds.
-	 */
-	uint32_t cycle_time;
-
-	/* The administrative/operation value of the CycleTimeExtension
-	 * parameter for the gate.  The value is an unsigned integer number
-	 * of nanoseconds.
-	 */
-	uint32_t cycle_time_extension;
-
-	/* The administrative/operation value of the BaseTime parameter for the
-	 * gate.  The value is a representation of a PTPtime value, consisting
-	 * of a 48-bit integer number of seconds and a 32-bit integer number of
-	 * nanoseconds.
-	 */
-	ptptime_t base_time;
-
-	/* The administrative/operation value of the IPV parameter for the gate.
-	 * A value of -1 denotes the null value; zero or positive values denote
-	 * internal priority values.
-	 */
-	int8_t init_ipv;
-
-	/* control_list contend the gate control list of
-	 * administrative/operation
-	 */
-	struct tsn_qci_psfp_gcl *gcl;
-};
-
-/* 802.1Qci Stream Gate Instance Table, configuration part only. */
-struct tsn_qci_psfp_sgi_conf {
-	/* The GateEnabled parameter determines whether the stream gate is
-	 * active (true) or inactive (false).
-	 */
-	bool gate_enabled;
-
-	/* The ConfigChange parameter signals the start of a configuration
-	 * change when it is set to TRUE. This should only be done when the
-	 * various administrative parameters are all set to appropriate values.
-	 */
-	bool config_change;
-
-	/* admin control parameters with admin control list */
-	struct tsn_qci_sg_control admin;
-
-	/* The GateClosedDueToInvalidRxEnable object contains a Boolean value
-	 * that indicates whether the GateClosedDueToInvalidRx function is
-	 * enabled (TRUE) or disabled (FALSE).
-	 */
-	bool block_invalid_rx_enable;
-
-	/* The GateClosedDueToInvalidRx object contains a Boolean value that
-	 * indicates whether, if the GateClosedDueToInvalidRx function is
-	 * enabled, all frames are to be discarded (TRUE) or not (FALSE).
-	 */
-	bool block_invalid_rx;
-
-	/* The GateClosedDueToOctetsExceededEnable object contains a Boolean
-	 * value that indicates whether the GateClosedDueToOctetsExceeded
-	 * function is enabled (TRUE) or disabled (FALSE).
-	 */
-	bool block_octets_exceeded_enable;
-
-	/* The GateClosedDueToOctetsExceeded object contains a Boolean value
-	 * that indicates whether, if the GateClosedDueToOctetsExceeded
-	 * function is enabled, all frames are to be discarded (TRUE) or not
-	 * (FALSE).
-	 */
-	bool block_octets_exceeded;
-};
-
-/* 802.1Qci Stream Gate Instance Table, status part only. */
-struct tsn_psfp_sgi_status {
-
-	/* admin control parameters with admin control list */
-	struct tsn_qci_sg_control oper;
-
-	/* The PTPtime at which the next config change is scheduled to occur.
-	 * The value is a representation of a PTPtime value, consisting of a
-	 * 48-bit integer number of seconds and a 32-bit integer number of
-	 * nanoseconds.
-	 */
-	ptptime_t config_change_time;
-
-	/* The granularity of the cycle time clock, represented as an unsigned
-	 * number of tenths of nanoseconds.
-	 */
-	uint32_t tick_granularity;
-
-	/* The current time, in PTPtime, as maintained by the local system.
-	 * The value is a representation of a PTPtime value, consisting of a
-	 * 48-bit integer number of seconds and a 32-bit integer number of
-	 * nanoseconds.
-	 */
-	ptptime_t current_time;
-
-	/* The value of the ConfigPending state machine variable.  The value is
-	 * TRUE if a configuration change is in progress but has not yet
-	 * completed.
-	 */
-	bool config_pending;
-
-	/* A counter of the number of times that a re-configuration of the
-	 * traffic schedule has been requested with the old schedule still
-	 * running and the requested base time was in the past.
-	 */
-	uint64_t config_change_error;
-
-};
-
-/* 802.1Qci Flow Meter Instance Table. */
-struct tsn_qci_psfp_fmi {
-	/* The FlowMeterCIR parameter contains an integer value that represents
-	 * the CIR value for the flow meter, in kbit/s.
-	 */
-	uint32_t cir;
-
-	/* The FlowMeterCBS parameter contains an integer value that represents
-	 * the CBS value for the flow meter, in octets.
-	 */
-	uint32_t cbs;
-
-	/* The FlowMeterEIR parameter contains an integer value that represents
-	 * the EIR value for the flow meter, in kbit/s.
-	 */
-	uint32_t eir;
-
-	/* The FlowMeterEBS parameter contains an integer value that represents
-	 * the EBS value for the flow meter, in octets.
-	 */
-	uint32_t ebs;
-
-	/* The FlowMeterCF parameter contains a Boolean value that represents
-	 * the CF value for the flow meter, as a Boolean value indicating no
-	 * coupling (FALSE) or coupling (TRUE).
-	 */
-	bool cf;
-
-	/* The FlowMeterCM parameter contains a Boolean value that represents
-	 * the CM value for the flow meter, as a Boolean value indicating
-	 * colorBlind (FALSE) or colorAware (TRUE).
-	 */
-	bool cm;
-
-	/* The FlowMeterDropOnYellow parameter contains a Boolean value that
-	 * indicates whether yellow frames are dropped (TRUE) or have
-	 * drop_eligible set to TRUE (FALSE).
-	 */
-	bool drop_on_yellow;
-
-	/* The FlowMeterMarkAllFramesRedEnable parameter contains a Boolean
-	 * value that indicates whether the MarkAllFramesRed function
-	 * is enabled (TRUE) or disabled (FALSE).
-	 */
-	bool mark_red_enable;
-
-	/* The FlowMeterMarkAllFramesRed parameter contains a Boolean value
-	 * that indicates whether, if the MarkAllFramesRed function is enabled,
-	 * all frames are to be discarded (TRUE) or not (FALSE).
-	 */
-	bool mark_red;
-};
-
-struct tsn_qci_psfp_fmi_counters {
-	uint64_t bytecount;
-	uint64_t drop;
-	uint64_t dr0_green;
-	uint64_t dr1_green;
-	uint64_t dr2_yellow;
-	uint64_t remark_yellow;
-	uint64_t dr3_red;
-	uint64_t remark_red;
-};
-
-struct tsn_seq_gen_conf {
-	uint8_t iport_mask;
-	uint8_t split_mask;
-	uint8_t seq_len;
-	uint32_t seq_num;
-};
-
-struct tsn_seq_rec_conf {
-	uint8_t seq_len;
-	uint8_t his_len;
-	bool rtag_pop_en;
-};
-
-struct tsn_cb_status {
-	uint8_t gen_rec;
-	uint8_t err;
-	uint32_t seq_num;
-	uint8_t seq_len;
-	uint8_t split_mask;
-	uint8_t iport_mask;
-	uint8_t his_len;
-	uint32_t seq_his;
-};
-
-/* An entry for gate control list */
-struct tsn_qbv_entry {
-	/* Octet represent the gate states for the corresponding traffic
-	 * classes.
-	 * The MS bit corresponds to traffic class 7.
-	 * The LS bit to traffic class 0.
-	 * A bit value of 0 indicates closed;
-	 * A bit value of 1 indicates open.
-	 */
-	uint8_t gate_state;
-
-	/* A TimeInterval is encoded in 4 octets as a 32-bit unsigned integer,
-	 * representing a number of nanoseconds.
-	 */
-	uint32_t time_interval;
-};
-
-/* The administrative/operation time and gate list */
-struct tsn_qbv_basic {
-	/* The administrative/operation value of the GateStates parameter for
-	 * the Port.
-	 * The bits of the octet represent the gate states for the
-	 * corresponding traffic classes; the MS bit corresponds to traffic
-	 * class 7, the LS bit to traffic class 0. A bit value of 0 indicates
-	 * closed; a bit value of 1 indicates open.
-	 * The value of this object MUST be retained
-	 * across reinitializations of the management system.
-	 */
-	uint8_t gate_states;
-
-	/* The administrative/operation value of the ListMax parameter for the
-	 * port. The integer value indicates the number of entries (TLVs) in
-	 * the AdminControlList. The value of this object MUST be retained
-	 * across reinitializations of the management system.
-	 */
-	uint32_t control_list_length;
-
-	/* The administrative/operation value of the AdminCycleTime
-	 * parameter for the Port. The numerator and denominator together
-	 * represent the cycle time as a rational number of seconds.  The value
-	 * of this object MUST be retained across reinitializations of the
-	 * management system.
-	 */
-	uint32_t cycle_time;
-
-	/* The administrative/operation value of the CycleTimeExtension
-	 * parameter for the Port. The value is an unsigned integer number of
-	 * nanoseconds.
-	 * The value of this object MUST be retained across reinitializations
-	 * of the management system.
-	 */
-
-	uint32_t cycle_time_extension;
-
-	/* The administrative/operation value of the BaseTime parameter for the
-	 * Port.  The value is a representation of a PTPtime value, consisting
-	 * of a 48-bit integer number of seconds and a 32-bit integer number of
-	 * nanoseconds.
-	 * The value of this object MUST be retained across reinitializations of
-	 * the management system.
-	 */
-	ptptime_t base_time;
-
-	/* admin_control_list represent the AdminControlList/OperControlList.
-	 * The administrative version of the gate control list for the Port.
-	 */
-	struct tsn_qbv_entry *control_list;
-};
-
-struct tsn_qbv_conf {
-	/* The GateEnabled parameter determines whether traffic scheduling is
-	 * active (true) or inactive (false).  The value of this object MUST be
-	 * retained across reinitializations of the management system.
-	 */
-	bool gate_enabled;
-
-	/* The maxsdu parameter denoting the maximum SDU size supported by the
-	 * queue.
-	 */
-	uint32_t maxsdu;
-
-	/* The ConfigChange parameter signals the start of a configuration
-	 * change when it is set to TRUE. This should only be done when the
-	 * various administrative parameters are all set to appropriate values.
-	 */
-	bool config_change;
-
-	/* The admin parameter signals the admin relate cycletime, basictime,
-	 * gatelist paraters.
-	 */
-	struct tsn_qbv_basic admin;
-};
-
-/* 802.1Qbv (Time Aware Shaper) port status */
-struct tsn_qbv_status {
-	/* The PTPtime at which the next config change is scheduled to occur.
-	 * The value is a representation of a PTPtime value, consisting of a
-	 * 48-bit integer number of seconds and a 32-bit integer number of
-	 * nanoseconds.  The value of this object MUST be retained across
-	 * reinitializations of the management system.
-	 */
-	ptptime_t config_change_time;
-
-	/* The granularity of the cycle time clock, represented as an unsigned
-	 * number of tenths of nanoseconds.  The value of this object MUST be
-	 * retained across reinitializations of the management system.
-	 */
-	uint32_t tick_granularity;
-
-	/* The current time, in PTPtime, as maintained by the local system.
-	 * The value is a representation of a PTPtime value, consisting of a
-	 * 48-bit integer number of seconds and a 32-bit integer number of
-	 * nanoseconds.
-	 */
-	ptptime_t  current_time;
-
-	/* The value of the ConfigPending state machine variable.  The value is
-	 * TRUE if a configuration change is in progress but has not yet
-	 * completed.
-	 */
-	bool config_pending;
-
-	/* A counter of the number of times that a re-configuration of the
-	 * traffic schedule has been requested with the old schedule still
-	 * running and the requested base time was in the past.
-	 */
-	uint64_t config_change_error;
-
-	/* The maximum value supported by this Port of the
-	 * AdminControlListLength and OperControlListLength parameters.
-	 */
-	uint32_t supported_list_max;
-
-	/* Operation settings parameters and Oper gate list */
-	struct tsn_qbv_basic oper;
-};
-
-/* Time Specific Departure parameters */
-struct tsn_tsd {
-	bool enable;
-
-	/* The cycle time, in units of microsecond(us)*/
-	uint32_t period;
-
-	/* The maximum number of frames which could be transmitted on one cycle
-	 *  The exceeding frames will be transmitted on next cycle.
-	 */
-	uint32_t maxFrameNum;
-
-	/* Specify the time of the first cycle begins.
-	 *      1:  begin when the queue get the first frame to transmit.
-	 *      2:  begin immediately at the end of setting function.
-	 */
-	uint32_t syn_flag;
-};
-
-struct tsn_tsd_status {
-	bool enable;
-	uint32_t period;
-	uint32_t maxFrameNum;
-	uint32_t flag;
-	uint32_t cycleNum;
-	uint32_t loss_steps;
-};
-
-struct tsn_qos_switch_dscp_conf {
-	bool trust;
-	u8 cos;
-	u8 dpl;
-	bool remark;
-	u8 dscp; /* New ingress translated DSCP value */
-};
-
-#endif /* _UAPI_GENL_TSN_H */
diff --git a/net/tsn/Kconfig b/net/tsn/Kconfig
deleted file mode 100644
index 9f22807a74c9..000000000000
--- a/net/tsn/Kconfig
+++ /dev/null
@@ -1,15 +0,0 @@
-config TSN
-	bool "802.1 Time-Sensitive Networking support"
-	default n
-	depends on VLAN_8021Q && PTP_1588_CLOCK
-	help
-	  This enables support for TSN(time sensitive networking)
-	  TSN features include:
-		802.1Qav:
-		802.1Qbv:
-		802.1Qci:
-		802.1Qbu:
-		802.1AS:
-		802.1CB:
-
-	  If unsure, say N.
diff --git a/net/tsn/Makefile b/net/tsn/Makefile
deleted file mode 100644
index ed46381bf24f..000000000000
--- a/net/tsn/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-$(CONFIG_TSN) += genl_tsn.o
diff --git a/net/tsn/genl_tsn.c b/net/tsn/genl_tsn.c
deleted file mode 100644
index 8c245201f840..000000000000
--- a/net/tsn/genl_tsn.c
+++ /dev/null
@@ -1,3383 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2018 NXP */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/if_vlan.h>
-#include <net/genetlink.h>
-#include <net/netlink.h>
-#include <linux/version.h>
-#include <net/tsn.h>
-
-#define NLA_PARSE_NESTED(a, b, c, d) nla_parse_nested(a, b, c, d, NULL)
-#define NLA_PUT_U64(a, b, c) nla_put_u64_64bit(a, b, c, NLA_U64)
-
-static struct genl_family tsn_family;
-
-LIST_HEAD(port_list);
-
-enum TSN_REPLY_VALUE {
-	TSN_SUCCESS = 0,
-	TSN_NODEVOPS,
-	TSN_ATTRERR,
-	TSN_DEVRETERR,
-};
-
-static const struct nla_policy tsn_cmd_policy[TSN_CMD_ATTR_MAX + 1] = {
-	[TSN_CMD_ATTR_MESG]		= { .type = NLA_STRING },
-	[TSN_CMD_ATTR_DATA]		= { .type = NLA_S32 },
-	[TSN_ATTR_IFNAME]		= { .type = NLA_STRING },
-	[TSN_ATTR_PORT_NUMBER]		= { .type = NLA_U8 },
-	[TSN_ATTR_QBV]			= { .type = NLA_NESTED },
-	[TSN_ATTR_STREAM_IDENTIFY]	= { .type = NLA_NESTED },
-	[TSN_ATTR_QCI_SP]		= { .type = NLA_NESTED },
-	[TSN_ATTR_QCI_SFI]		= { .type = NLA_NESTED },
-	[TSN_ATTR_QCI_SGI]		= { .type = NLA_NESTED },
-	[TSN_ATTR_QCI_FMI]		= { .type = NLA_NESTED },
-	[TSN_ATTR_CBS]			= { .type = NLA_NESTED },
-	[TSN_ATTR_TSD]			= { .type = NLA_NESTED },
-	[TSN_ATTR_QBU]			= { .type = NLA_NESTED },
-	[TSN_ATTR_CT]			= { .type = NLA_NESTED },
-	[TSN_ATTR_CBGEN]		= { .type = NLA_NESTED },
-	[TSN_ATTR_CBREC]		= { .type = NLA_NESTED },
-	[TSN_ATTR_CBSTAT]               = { .type = NLA_NESTED },
-	[TSN_ATTR_PCPMAP]		= { .type = NLA_NESTED },
-	[TSN_ATTR_DSCP]                 = { .type = NLA_NESTED },
-};
-
-static const struct nla_policy ct_policy[TSN_CT_ATTR_MAX + 1] = {
-	[TSN_CT_ATTR_QUEUE_STATE]	= { .type = NLA_U8 }
-};
-
-static const struct nla_policy cbgen_policy[TSN_CBGEN_ATTR_MAX + 1] = {
-	[TSN_CBGEN_ATTR_INDEX]		= { .type = NLA_U32 },
-	[TSN_CBGEN_ATTR_PORT_MASK]	= { .type = NLA_U8 },
-	[TSN_CBGEN_ATTR_SPLIT_MASK]	= { .type = NLA_U8 },
-	[TSN_CBGEN_ATTR_SEQ_LEN]	= { .type = NLA_U8 },
-	[TSN_CBGEN_ATTR_SEQ_NUM]	= { .type = NLA_U32 },
-};
-
-static const struct nla_policy cbrec_policy[TSN_CBREC_ATTR_MAX + 1] = {
-	[TSN_CBREC_ATTR_INDEX]		= { .type = NLA_U32 },
-	[TSN_CBREC_ATTR_SEQ_LEN]	= { .type = NLA_U8 },
-	[TSN_CBREC_ATTR_HIS_LEN]	= { .type = NLA_U8 },
-	[TSN_CBREC_ATTR_TAG_POP_EN]	= { .type = NLA_FLAG },
-};
-
-static const struct nla_policy cbstat_policy[TSN_CBSTAT_ATTR_MAX + 1] = {
-	[TSN_CBSTAT_ATTR_INDEX]         = { .type = NLA_U32 },
-	[TSN_CBSTAT_ATTR_GEN_REC]       = { .type = NLA_U8 },
-	[TSN_CBSTAT_ATTR_ERR]		= { .type = NLA_U8 },
-	[TSN_CBSTAT_ATTR_SEQ_NUM]       = { .type = NLA_U32 },
-	[TSN_CBSTAT_ATTR_SEQ_LEN]       = { .type = NLA_U8 },
-	[TSN_CBSTAT_ATTR_SPLIT_MASK]    = { .type = NLA_U8 },
-	[TSN_CBSTAT_ATTR_PORT_MASK]	= { .type = NLA_U8 },
-	[TSN_CBSTAT_ATTR_HIS_LEN]       = { .type = NLA_U8 },
-	[TSN_CBSTAT_ATTR_SEQ_HIS]       = { .type = NLA_U32 },
-};
-
-static const struct nla_policy pcpmap_policy[TSN_PCPMAP_ATTR_MAX + 1] = {
-	[TSN_PCPMAP_ATTR_ENABLE]	= { .type = NLA_FLAG},
-};
-
-static const struct nla_policy qbu_policy[TSN_QBU_ATTR_MAX + 1] = {
-	[TSN_QBU_ATTR_ADMIN_STATE]	= { .type = NLA_U8 },
-	[TSN_QBU_ATTR_HOLD_ADVANCE]	= { .type = NLA_U32},
-	[TSN_QBU_ATTR_RELEASE_ADVANCE]	= { .type = NLA_U32},
-	[TSN_QBU_ATTR_ACTIVE]		= { .type = NLA_FLAG},
-	[TSN_QBU_ATTR_HOLD_REQUEST]	= { .type = NLA_U8},
-};
-
-static const struct nla_policy cbs_policy[TSN_CBS_ATTR_MAX + 1] = {
-	[TSN_CBS_ATTR_TC_INDEX]		= { .type = NLA_U8},
-	[TSN_CBS_ATTR_BW]		= { .type = NLA_U8},
-};
-
-static const struct nla_policy tsd_policy[TSN_TSD_ATTR_MAX + 1] = {
-	[TSN_TSD_ATTR_ENABLE]			= { .type = NLA_FLAG},
-	[TSN_TSD_ATTR_DISABLE]			= { .type = NLA_FLAG},
-	[TSN_TSD_ATTR_PERIOD]			= { .type = NLA_U32},
-	[TSN_TSD_ATTR_MAX_FRM_NUM]		= { .type = NLA_U32},
-	[TSN_TSD_ATTR_CYCLE_NUM]		= { .type = NLA_U32},
-	[TSN_TSD_ATTR_LOSS_STEPS]		= { .type = NLA_U32},
-	[TSN_TSD_ATTR_SYN_IMME]			= { .type = NLA_FLAG},
-};
-
-static const struct nla_policy qbv_policy[TSN_QBV_ATTR_MAX + 1] = {
-	[TSN_QBV_ATTR_ADMINENTRY]	= {	.type = NLA_NESTED},
-	[TSN_QBV_ATTR_OPERENTRY]	= { .type = NLA_NESTED},
-	[TSN_QBV_ATTR_ENABLE]		= { .type = NLA_FLAG},
-	[TSN_QBV_ATTR_DISABLE]		= { .type = NLA_FLAG},
-	[TSN_QBV_ATTR_CONFIGCHANGE]	= { .type = NLA_FLAG},
-	[TSN_QBV_ATTR_CONFIGCHANGETIME]	= { .type = NLA_U64},
-	[TSN_QBV_ATTR_MAXSDU]		= { .type = NLA_U32},
-	[TSN_QBV_ATTR_GRANULARITY]	= { .type = NLA_U32},
-	[TSN_QBV_ATTR_CURRENTTIME]	= { .type = NLA_U64},
-	[TSN_QBV_ATTR_CONFIGPENDING]	= {.type = NLA_FLAG},
-	[TSN_QBV_ATTR_CONFIGCHANGEERROR]	= { .type = NLA_U64},
-	[TSN_QBV_ATTR_LISTMAX]		= { .type = NLA_U32},
-};
-
-static const struct nla_policy qbv_ctrl_policy[TSN_QBV_ATTR_CTRL_MAX + 1] = {
-	[TSN_QBV_ATTR_CTRL_LISTCOUNT]		= { .type = NLA_U32},
-	[TSN_QBV_ATTR_CTRL_GATESTATE]		= { .type = NLA_U8},
-	[TSN_QBV_ATTR_CTRL_CYCLETIME]		= { .type = NLA_U32},
-	[TSN_QBV_ATTR_CTRL_CYCLETIMEEXT]	= { .type = NLA_U32},
-	[TSN_QBV_ATTR_CTRL_BASETIME]		= { .type = NLA_U64},
-	[TSN_QBV_ATTR_CTRL_LISTENTRY]		= { .type = NLA_NESTED},
-};
-
-static const struct nla_policy qbv_entry_policy[TSN_QBV_ATTR_ENTRY_MAX + 1] = {
-	[TSN_QBV_ATTR_ENTRY_ID]	= { .type = NLA_U32},
-	[TSN_QBV_ATTR_ENTRY_GC]	= { .type = NLA_U8},
-	[TSN_QBV_ATTR_ENTRY_TM]	= { .type = NLA_U32},
-};
-
-static const struct nla_policy cb_streamid_policy[TSN_STREAMID_ATTR_MAX + 1] = {
-	[TSN_STREAMID_ATTR_INDEX]	= { .type = NLA_U32},
-	[TSN_STREAMID_ATTR_ENABLE]	= { .type = NLA_FLAG},
-	[TSN_STREAMID_ATTR_DISABLE]	= { .type = NLA_FLAG},
-	[TSN_STREAMID_ATTR_STREAM_HANDLE]	= { .type = NLA_S32},
-	[TSN_STREAMID_ATTR_IFOP]	= { .type = NLA_U32},
-	[TSN_STREAMID_ATTR_OFOP]	= { .type = NLA_U32},
-	[TSN_STREAMID_ATTR_IFIP]	= { .type = NLA_U32},
-	[TSN_STREAMID_ATTR_OFIP]	= { .type = NLA_U32},
-	[TSN_STREAMID_ATTR_TYPE]	= { .type = NLA_U8},
-	[TSN_STREAMID_ATTR_NDMAC]	= { .type = NLA_U64},
-	[TSN_STREAMID_ATTR_NTAGGED]	= { .type = NLA_U8},
-	[TSN_STREAMID_ATTR_NVID]	= { .type = NLA_U16},
-	[TSN_STREAMID_ATTR_SMAC]	= { .type = NLA_U64},
-	[TSN_STREAMID_ATTR_STAGGED]	= { .type = NLA_U8},
-	[TSN_STREAMID_ATTR_SVID]	= { .type = NLA_U16},
-	[TSN_STREAMID_ATTR_COUNTERS_PSI] = { .type = NLA_U64},
-	[TSN_STREAMID_ATTR_COUNTERS_PSO] = { .type = NLA_U64},
-	[TSN_STREAMID_ATTR_COUNTERS_PSPPI] = { .type = NLA_U64},
-	[TSN_STREAMID_ATTR_COUNTERS_PSPPO] = { .type = NLA_U64},
-};
-
-static const struct nla_policy qci_sfi_policy[TSN_QCI_SFI_ATTR_MAX + 1] = {
-	[TSN_QCI_SFI_ATTR_INDEX]		= { .type = NLA_U32},
-	[TSN_QCI_SFI_ATTR_ENABLE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SFI_ATTR_DISABLE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SFI_ATTR_STREAM_HANDLE]	= { .type = NLA_S32},
-	[TSN_QCI_SFI_ATTR_PRIO_SPEC]		= { .type = NLA_S8},
-	[TSN_QCI_SFI_ATTR_GATE_ID]		= { .type = NLA_U32},
-	[TSN_QCI_SFI_ATTR_FILTER_TYPE]		= { .type = NLA_U8},
-	[TSN_QCI_SFI_ATTR_FLOW_ID]		= { .type = NLA_S32},
-	[TSN_QCI_SFI_ATTR_MAXSDU]		= { .type = NLA_U16},
-	[TSN_QCI_SFI_ATTR_COUNTERS]		= {
-		.len = sizeof(struct tsn_qci_psfp_sfi_counters)},
-	[TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE]	= { .type = NLA_FLAG},
-	[TSN_QCI_SFI_ATTR_OVERSIZE]		= { .type = NLA_FLAG},
-};
-
-static const struct nla_policy qci_sgi_policy[] = {
-	[TSN_QCI_SGI_ATTR_INDEX]		= { .type = NLA_U32},
-	[TSN_QCI_SGI_ATTR_ENABLE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_DISABLE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_CONFCHANGE]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_IRXEN]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_IRX]			= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_OEXEN]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_OEX]			= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_ADMINENTRY]		= { .type = NLA_NESTED},
-	[TSN_QCI_SGI_ATTR_OPERENTRY]		= { .type = NLA_NESTED},
-	[TSN_QCI_SGI_ATTR_CCTIME]		= { .type = NLA_U64},
-	[TSN_QCI_SGI_ATTR_TICKG]		= { .type = NLA_U32},
-	[TSN_QCI_SGI_ATTR_CUTIME]		= { .type = NLA_U64},
-	[TSN_QCI_SGI_ATTR_CPENDING]		= { .type = NLA_FLAG},
-	[TSN_QCI_SGI_ATTR_CCERROR]		= { .type = NLA_U64},
-};
-
-static const struct nla_policy qci_sgi_ctrl_policy[] = {
-	[TSN_SGI_ATTR_CTRL_INITSTATE]		= { .type = NLA_FLAG},
-	[TSN_SGI_ATTR_CTRL_LEN]			= { .type = NLA_U8},
-	[TSN_SGI_ATTR_CTRL_CYTIME]		= { .type = NLA_U32},
-	[TSN_SGI_ATTR_CTRL_CYTIMEEX]		= { .type = NLA_U32},
-	[TSN_SGI_ATTR_CTRL_BTIME]		= { .type = NLA_U64},
-	[TSN_SGI_ATTR_CTRL_INITIPV]		= { .type = NLA_S8},
-	[TSN_SGI_ATTR_CTRL_GCLENTRY]		= { .type = NLA_NESTED},
-};
-
-static const struct nla_policy qci_sgi_gcl_policy[] = {
-	[TSN_SGI_ATTR_GCL_GATESTATE]		= { .type = NLA_FLAG},
-	[TSN_SGI_ATTR_GCL_IPV]			= { .type = NLA_S8},
-	[TSN_SGI_ATTR_GCL_INTERVAL]		= { .type = NLA_U32},
-	[TSN_SGI_ATTR_GCL_OCTMAX]		= { .type = NLA_U32},
-};
-
-static const struct nla_policy qci_fmi_policy[] = {
-	[TSN_QCI_FMI_ATTR_INDEX]	= { .type = NLA_U32},
-	[TSN_QCI_FMI_ATTR_ENABLE]	= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_DISABLE]	= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_CIR]		= { .type = NLA_U32},
-	[TSN_QCI_FMI_ATTR_CBS]		= { .type = NLA_U32},
-	[TSN_QCI_FMI_ATTR_EIR]		= { .type = NLA_U32},
-	[TSN_QCI_FMI_ATTR_EBS]		= { .type = NLA_U32},
-	[TSN_QCI_FMI_ATTR_CF]		= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_CM]		= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_DROPYL]	= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_MAREDEN]	= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_MARED]	= { .type = NLA_FLAG},
-	[TSN_QCI_FMI_ATTR_COUNTERS]	= {
-		.len = sizeof(struct tsn_qci_psfp_fmi_counters)},
-};
-
-static const struct nla_policy dscp_policy[] = {
-	[TSN_DSCP_ATTR_INDEX]		= { .type = NLA_U32},
-	[TSN_DSCP_ATTR_DISABLE]		= { .type = NLA_FLAG},
-	[TSN_DSCP_ATTR_COS]		= { .type = NLA_U32},
-	[TSN_DSCP_ATTR_DPL]		= { .type = NLA_U32},
-};
-
-static int tsn_prepare_reply(struct genl_info *info, u8 cmd,
-			     struct sk_buff **skbp, size_t size)
-{
-	struct sk_buff *skb;
-	void *reply;
-
-	/* If new attributes are added, please revisit this allocation
-	 */
-	skb = genlmsg_new(size, GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-
-	if (!info) {
-		nlmsg_free(skb);
-		return -EINVAL;
-	}
-
-	reply = genlmsg_put_reply(skb, info, &tsn_family, 0, cmd);
-	if (!reply) {
-		nlmsg_free(skb);
-		return -EINVAL;
-	}
-
-	*skbp = skb;
-	return 0;
-}
-
-static int tsn_mk_reply(struct sk_buff *skb, int aggr, void *data, int len)
-{
-    /* add a netlink attribute to a socket buffer */
-	return nla_put(skb, aggr, len, data);
-}
-
-static int tsn_send_reply(struct sk_buff *skb, struct genl_info *info)
-{
-	struct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));
-	void *reply = genlmsg_data(genlhdr);
-
-	genlmsg_end(skb, reply);
-
-	return genlmsg_reply(skb, info);
-}
-
-static int cmd_attr_echo_message(struct genl_info *info)
-{
-	struct nlattr *na;
-	char *msg;
-	struct sk_buff *rep_skb;
-	size_t size;
-	int ret;
-
-	na = info->attrs[TSN_CMD_ATTR_MESG];
-	if (!na)
-		return -EINVAL;
-
-	msg = (char *)nla_data(na);
-	pr_info("tsn generic netlink receive echo mesg %s\n", msg);
-
-	size = nla_total_size(strlen(msg) + 1);
-
-	ret = tsn_prepare_reply(info, TSN_CMD_REPLY, &rep_skb,
-				size + NLMSG_ALIGN(MAX_USER_SIZE));
-	if (ret < 0)
-		return ret;
-
-	ret = tsn_mk_reply(rep_skb, TSN_CMD_ATTR_MESG, msg, size);
-	if (ret < 0)
-		goto err;
-
-	return tsn_send_reply(rep_skb, info);
-
-err:
-	nlmsg_free(rep_skb);
-	return ret;
-}
-
-static int cmd_attr_echo_data(struct genl_info *info)
-{
-	struct nlattr *na;
-	s32	data;
-	struct sk_buff *rep_skb;
-	size_t size;
-	int ret;
-
-	/*read data */
-	na = info->attrs[TSN_CMD_ATTR_DATA];
-	if (!na)
-		return -EINVAL;
-
-	data = nla_get_s32(info->attrs[TSN_CMD_ATTR_DATA]);
-	pr_info("tsn generic netlink receive echo data %d\n", data);
-
-	/* send back */
-	size = nla_total_size(sizeof(s32));
-
-	ret = tsn_prepare_reply(info, TSN_CMD_REPLY, &rep_skb,
-				size + NLMSG_ALIGN(MAX_USER_SIZE));
-	if (ret < 0)
-		return ret;
-
-	/* netlink lib func */
-	ret = nla_put_s32(rep_skb, TSN_CMD_ATTR_DATA, data);
-	if (ret < 0)
-		goto err;
-
-	return tsn_send_reply(rep_skb, info);
-
-err:
-	nlmsg_free(rep_skb);
-	return ret;
-}
-
-static int tsn_echo_cmd(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_CMD_ATTR_MESG])
-		return cmd_attr_echo_message(info);
-	else if (info->attrs[TSN_CMD_ATTR_DATA])
-		return cmd_attr_echo_data(info);
-
-	return -EINVAL;
-}
-
-static int tsn_simple_reply(struct genl_info *info, u32 cmd,
-			    char *portname, s32 retvalue)
-{
-	struct sk_buff *rep_skb;
-	size_t size;
-	int ret;
-
-	/* send back */
-	size = nla_total_size(strlen(portname) + 1);
-	size += nla_total_size(sizeof(s32));
-
-	ret = tsn_prepare_reply(info, cmd,
-				&rep_skb, size + NLMSG_ALIGN(MAX_USER_SIZE));
-	if (ret < 0)
-		return ret;
-
-	/* netlink lib func */
-	ret = nla_put_string(rep_skb, TSN_ATTR_IFNAME, portname);
-	if (ret < 0)
-		return ret;
-
-	ret = nla_put_s32(rep_skb, TSN_CMD_ATTR_DATA, retvalue);
-	if (ret < 0)
-		return ret;
-
-	return tsn_send_reply(rep_skb, info);
-}
-
-struct tsn_port *tsn_init_check(struct genl_info *info,
-				struct net_device **ndev)
-{
-	struct nlattr *na;
-	char *portname;
-	struct net_device *netdev;
-	struct tsn_port *port;
-	bool tsn_found = false;
-
-	if (!info->attrs[TSN_ATTR_IFNAME]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 "no portname", -TSN_ATTRERR);
-		return NULL;
-	}
-
-	na = info->attrs[TSN_ATTR_IFNAME];
-
-	portname = (char *)nla_data(na);
-
-	netdev = __dev_get_by_name(genl_info_net(info), portname);
-	if (!netdev) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 "error device", -TSN_NODEVOPS);
-		return NULL;
-	}
-
-	list_for_each_entry(port, &port_list, list) {
-		if (port->netdev == netdev) {
-			tsn_found = true;
-			break;
-		}
-	}
-
-	if (!tsn_found) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return NULL;
-	}
-
-	*ndev = netdev;
-
-	return port;
-}
-
-static int cmd_cb_streamid_set(struct genl_info *info)
-{
-	struct nlattr *na, *sid[TSN_STREAMID_ATTR_MAX + 1];
-	u32 sid_index;
-	u8 iden_type = 1;
-	bool enable;
-	int ret;
-	struct net_device *netdev;
-	struct tsn_cb_streamid sidconf;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&sidconf, 0, sizeof(struct tsn_cb_streamid));
-
-	if (!info->attrs[TSN_ATTR_STREAM_IDENTIFY])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_STREAM_IDENTIFY];
-
-	ret = NLA_PARSE_NESTED(sid, TSN_STREAMID_ATTR_MAX,
-			       na, cb_streamid_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (!sid[TSN_STREAMID_ATTR_INDEX])
-		return -EINVAL;
-
-	sid_index = nla_get_u32(sid[TSN_STREAMID_ATTR_INDEX]);
-
-	if (sid[TSN_STREAMID_ATTR_ENABLE])
-		enable = true;
-	else if (sid[TSN_STREAMID_ATTR_DISABLE])
-		enable = false;
-	else
-		return -EINVAL;
-
-	if (!enable)
-		goto loaddev;
-
-	if (sid[TSN_STREAMID_ATTR_TYPE])
-		iden_type = nla_get_u8(sid[TSN_STREAMID_ATTR_TYPE]);
-	else
-		return -EINVAL;
-
-	sidconf.type = iden_type;
-	switch (iden_type) {
-	case STREAMID_NULL:
-		if (!sid[TSN_STREAMID_ATTR_NDMAC] ||
-		    !sid[TSN_STREAMID_ATTR_NTAGGED] ||
-		    !sid[TSN_STREAMID_ATTR_NVID]) {
-			return -EINVAL;
-		}
-
-		sidconf.para.nid.dmac =
-			nla_get_u64(sid[TSN_STREAMID_ATTR_NDMAC]);
-		sidconf.para.nid.tagged =
-			nla_get_u8(sid[TSN_STREAMID_ATTR_NTAGGED]);
-		sidconf.para.nid.vid =
-			nla_get_u16(sid[TSN_STREAMID_ATTR_NVID]);
-		break;
-	case STREAMID_SMAC_VLAN:
-		/* TODO: not supportted yet */
-		if (!sid[TSN_STREAMID_ATTR_SMAC] ||
-		    !sid[TSN_STREAMID_ATTR_STAGGED] ||
-		    !sid[TSN_STREAMID_ATTR_SVID]) {
-			return -EINVAL;
-		}
-
-		sidconf.para.sid.smac =
-			nla_get_u64(sid[TSN_STREAMID_ATTR_SMAC]);
-		sidconf.para.sid.tagged =
-			nla_get_u8(sid[TSN_STREAMID_ATTR_STAGGED]);
-		sidconf.para.sid.vid =
-			nla_get_u16(sid[TSN_STREAMID_ATTR_SVID]);
-		break;
-	case STREAMID_DMAC_VLAN:
-
-	case STREAMID_IP:
-
-	default:
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (sid[TSN_STREAMID_ATTR_STREAM_HANDLE])
-		sidconf.handle =
-			nla_get_s32(sid[TSN_STREAMID_ATTR_STREAM_HANDLE]);
-
-	if (sid[TSN_STREAMID_ATTR_IFOP])
-		sidconf.ifac_oport = nla_get_u32(sid[TSN_STREAMID_ATTR_IFOP]);
-	if (sid[TSN_STREAMID_ATTR_OFOP])
-		sidconf.ofac_oport = nla_get_u32(sid[TSN_STREAMID_ATTR_OFOP]);
-	if (sid[TSN_STREAMID_ATTR_IFIP])
-		sidconf.ifac_iport = nla_get_u32(sid[TSN_STREAMID_ATTR_IFIP]);
-	if (sid[TSN_STREAMID_ATTR_OFIP])
-		sidconf.ofac_iport = nla_get_u32(sid[TSN_STREAMID_ATTR_OFIP]);
-
-loaddev:
-	if (!tsnops->cb_streamid_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -EOPNOTSUPP;
-	}
-
-	tsnops->cb_streamid_set(netdev, sid_index, enable, &sidconf);
-
-	/* simple reply here. To be continue */
-	if (tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, 0))
-		return -1;
-
-	return 0;
-}
-
-static int tsn_cb_streamid_set(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_cb_streamid_set(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_cb_streamid_get(struct genl_info *info)
-{
-	struct nlattr *na, *sidattr, *sid[TSN_STREAMID_ATTR_MAX + 1];
-	u32 sid_index;
-	struct genlmsghdr *genlhdr;
-	struct sk_buff *rep_skb;
-	int ret, i;
-	int valid;
-	struct net_device *netdev;
-	struct tsn_cb_streamid sidconf;
-	struct tsn_cb_streamid_counters sidcounts;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&sidconf, 0, sizeof(struct tsn_cb_streamid));
-	memset(&sidcounts, 0, sizeof(struct tsn_cb_streamid_counters));
-
-	if (!info->attrs[TSN_ATTR_STREAM_IDENTIFY])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_STREAM_IDENTIFY];
-
-	ret = NLA_PARSE_NESTED(sid, TSN_STREAMID_ATTR_MAX,
-			       na, cb_streamid_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (!sid[TSN_STREAMID_ATTR_INDEX])
-		return -EINVAL;
-
-	sid_index = nla_get_u32(sid[TSN_STREAMID_ATTR_INDEX]);
-
-	if (!tsnops->cb_streamid_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		ret = -EINVAL;
-		goto exit;
-	} else {
-		valid = tsnops->cb_streamid_get(netdev, sid_index, &sidconf);
-		if (valid < 0) {
-			tsn_simple_reply(info, TSN_CMD_REPLY,
-					 netdev->name, -TSN_DEVRETERR);
-			return -1;
-		}
-	}
-
-	/* send back */
-	genlhdr = info->genlhdr;
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
-				NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	/* input netlink the parameters */
-	sidattr = nla_nest_start(rep_skb, TSN_ATTR_STREAM_IDENTIFY);
-	if (!sidattr) {
-		ret = -EINVAL;
-		goto err;
-	}
-
-	if (nla_put_u32(rep_skb, TSN_STREAMID_ATTR_INDEX, sid_index))
-		return -EMSGSIZE;
-
-	if (valid == 1) {
-		nla_put_flag(rep_skb, TSN_STREAMID_ATTR_ENABLE);
-	} else if (valid == 0) {
-		nla_put_flag(rep_skb, TSN_STREAMID_ATTR_DISABLE);
-	} else {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		goto err;
-	}
-
-	if (nla_put_s32(rep_skb,
-			TSN_STREAMID_ATTR_STREAM_HANDLE, sidconf.handle) ||
-	    nla_put_u32(rep_skb, TSN_STREAMID_ATTR_IFOP, sidconf.ifac_oport) ||
-	    nla_put_u32(rep_skb, TSN_STREAMID_ATTR_OFOP, sidconf.ofac_oport) ||
-	    nla_put_u32(rep_skb, TSN_STREAMID_ATTR_IFIP, sidconf.ifac_iport) ||
-	    nla_put_u32(rep_skb, TSN_STREAMID_ATTR_OFIP, sidconf.ofac_iport) ||
-	    nla_put_u8(rep_skb, TSN_STREAMID_ATTR_TYPE, sidconf.type))
-		return -EMSGSIZE;
-
-	switch (sidconf.type) {
-	case STREAMID_NULL:
-		if (NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_NDMAC,
-				sidconf.para.nid.dmac) ||
-		    nla_put_u16(rep_skb, TSN_STREAMID_ATTR_NVID,
-				sidconf.para.nid.vid) ||
-		    nla_put_u8(rep_skb, TSN_STREAMID_ATTR_NTAGGED,
-			       sidconf.para.nid.tagged))
-			return -EMSGSIZE;
-		break;
-	case STREAMID_SMAC_VLAN:
-		if (NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_SMAC,
-				sidconf.para.sid.smac) ||
-		    nla_put_u16(rep_skb, TSN_STREAMID_ATTR_SVID,
-				sidconf.para.sid.vid) ||
-		    nla_put_u8(rep_skb, TSN_STREAMID_ATTR_STAGGED,
-			       sidconf.para.sid.tagged))
-			return -EMSGSIZE;
-		break;
-	case STREAMID_DMAC_VLAN:
-	case STREAMID_IP:
-	default:
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		goto err;
-	}
-
-	if (!tsnops->cb_streamid_counters_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		goto err;
-	} else {
-		ret = tsnops->cb_streamid_counters_get(netdev,
-							sid_index,
-							&sidcounts);
-		if (ret < 0) {
-			tsn_simple_reply(info, TSN_CMD_REPLY,
-					 netdev->name, -TSN_DEVRETERR);
-			goto err;
-		}
-	}
-
-	if (NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSI,
-			sidcounts.per_stream.input) ||
-	    NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSO,
-			sidcounts.per_stream.output))
-		return -EMSGSIZE;
-
-	for (i = 0; i < 32; i++) {
-		if (NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSPPI,
-				sidcounts.per_streamport[i].input) ||
-		    NLA_PUT_U64(rep_skb, TSN_STREAMID_ATTR_COUNTERS_PSPPO,
-				sidcounts.per_streamport[i].output))
-			return -EMSGSIZE;
-	}
-
-	nla_nest_end(rep_skb, sidattr);
-	/* end netlink input the parameters */
-
-	/* netlink lib func */
-	ret = nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name);
-	if (ret < 0)
-		goto err;
-
-	ret = nla_put_s32(rep_skb, TSN_CMD_ATTR_DATA, 0);
-	if (ret < 0)
-		goto err;
-
-	return tsn_send_reply(rep_skb, info);
-
-err:
-	nlmsg_free(rep_skb);
-exit:
-	return ret;
-}
-
-static int tsn_cb_streamid_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_cb_streamid_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmb_cb_streamid_counters_get(struct genl_info *info)
-{
-	return 0;
-}
-
-static int tsn_cb_streamid_counters_get(struct sk_buff *skb,
-					struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmb_cb_streamid_counters_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_sfi_set(struct genl_info *info)
-{
-	struct nlattr *na, *sfi[TSN_QCI_SFI_ATTR_MAX + 1];
-	u32 sfi_handle;
-	bool enable;
-	int ret;
-	struct net_device *netdev;
-	struct tsn_qci_psfp_sfi_conf sficonf;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&sficonf, 0, sizeof(struct tsn_qci_psfp_sfi_conf));
-
-	if (!info->attrs[TSN_ATTR_QCI_SFI])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_QCI_SFI];
-
-	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX, na, qci_sfi_policy);
-	if (ret) {
-		pr_info("tsn: parse value TSN_QCI_SFI_ATTR_MAX  error.");
-		return -EINVAL;
-	}
-
-	if (!sfi[TSN_QCI_SFI_ATTR_INDEX])
-		return -EINVAL;
-
-	sfi_handle = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_INDEX]);
-
-	if (sfi[TSN_QCI_SFI_ATTR_ENABLE]) {
-		enable = true;
-	} else if (sfi[TSN_QCI_SFI_ATTR_DISABLE]) {
-		enable = false;
-		goto loaddrive;
-	} else {
-		pr_err("tsn: must provde ENABLE or DISABLE attribute.\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (!sfi[TSN_QCI_SFI_ATTR_GATE_ID]) {
-		pr_err("tsn: must provide stream gate index\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (!sfi[TSN_QCI_SFI_ATTR_STREAM_HANDLE])
-		sficonf.stream_handle_spec = -1;
-	else
-		sficonf.stream_handle_spec =
-			nla_get_s32(sfi[TSN_QCI_SFI_ATTR_STREAM_HANDLE]);
-
-	if (!sfi[TSN_QCI_SFI_ATTR_PRIO_SPEC])
-		sficonf.priority_spec = -1;
-	else
-		sficonf.priority_spec =
-			nla_get_s8(sfi[TSN_QCI_SFI_ATTR_PRIO_SPEC]);
-
-	sficonf.stream_gate_instance_id =
-			nla_get_u32(sfi[TSN_QCI_SFI_ATTR_GATE_ID]);
-
-	if (sfi[TSN_QCI_SFI_ATTR_MAXSDU])
-		sficonf.stream_filter.maximum_sdu_size =
-			nla_get_u16(sfi[TSN_QCI_SFI_ATTR_MAXSDU]);
-	else
-		sficonf.stream_filter.maximum_sdu_size = 0;
-
-	if (sfi[TSN_QCI_SFI_ATTR_FLOW_ID])
-		sficonf.stream_filter.flow_meter_instance_id =
-			nla_get_s32(sfi[TSN_QCI_SFI_ATTR_FLOW_ID]);
-	else
-		sficonf.stream_filter.flow_meter_instance_id = -1;
-
-	if (sfi[TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE])
-		sficonf.block_oversize_enable = true;
-
-	if (sfi[TSN_QCI_SFI_ATTR_OVERSIZE])
-		sficonf.block_oversize = true;
-
-loaddrive:
-	if (!tsnops->qci_sfi_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
-	}
-
-	tsnops->qci_sfi_set(netdev, sfi_handle, enable, &sficonf);
-
-	if (tsn_simple_reply(info, TSN_CMD_REPLY,
-			     netdev->name, TSN_SUCCESS))
-		return -1;
-
-	return 0;
-}
-
-static int tsn_qci_sfi_set(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_sfi_set(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_sfi_get(struct genl_info *info)
-{
-	struct nlattr *na, *sfiattr;
-	struct nlattr *sfi[TSN_QCI_SFI_ATTR_MAX + 1];
-	u32 sfi_handle;
-	struct sk_buff *rep_skb;
-	int ret, valid = 0;
-	struct net_device *netdev;
-	struct genlmsghdr *genlhdr;
-	struct tsn_qci_psfp_sfi_conf sficonf;
-	struct tsn_qci_psfp_sfi_counters sficount;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	genlhdr = info->genlhdr;
-
-	if (!info->attrs[TSN_ATTR_QCI_SFI])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_QCI_SFI];
-
-	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX,
-			       na, qci_sfi_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (!sfi[TSN_QCI_SFI_ATTR_INDEX])
-		return -EINVAL;
-
-	sfi_handle = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_INDEX]);
-
-	memset(&sficonf, 0, sizeof(struct tsn_qci_psfp_sfi_conf));
-	memset(&sficount, 0, sizeof(struct tsn_qci_psfp_sfi_counters));
-
-	if (!tsnops->qci_sfi_get || !tsnops->qci_sfi_counters_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		ret = -EINVAL;
-		goto exit;
-	} else {
-		valid = tsnops->qci_sfi_get(netdev, sfi_handle, &sficonf);
-
-		if (valid < 0) {
-			tsn_simple_reply(info, TSN_CMD_REPLY,
-					 netdev->name, -TSN_DEVRETERR);
-			return -1;
-		}
-
-		tsnops->qci_sfi_counters_get(netdev, sfi_handle, &sficount);
-	}
-
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		goto err;
-
-	sfiattr = nla_nest_start(rep_skb, TSN_ATTR_QCI_SFI);
-	if (!sfiattr) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		ret = -EINVAL;
-		goto err;
-	}
-
-	if (nla_put_u32(rep_skb, TSN_QCI_SFI_ATTR_INDEX, sfi_handle))
-		return -EMSGSIZE;
-
-	if (valid) {
-		if (nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_ENABLE))
-			return -EMSGSIZE;
-	} else {
-		if (nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_DISABLE))
-			return -EMSGSIZE;
-	}
-
-	if (nla_put_s32(rep_skb, TSN_QCI_SFI_ATTR_STREAM_HANDLE,
-			sficonf.stream_handle_spec) ||
-	    nla_put_s8(rep_skb, TSN_QCI_SFI_ATTR_PRIO_SPEC,
-		       sficonf.priority_spec) ||
-	    nla_put_u32(rep_skb, TSN_QCI_SFI_ATTR_GATE_ID,
-			sficonf.stream_gate_instance_id))
-		return -EMSGSIZE;
-
-	if (sficonf.stream_filter.maximum_sdu_size)
-		if (nla_put_u16(rep_skb, TSN_QCI_SFI_ATTR_MAXSDU,
-				sficonf.stream_filter.maximum_sdu_size))
-			return -EMSGSIZE;
-
-	if (sficonf.stream_filter.flow_meter_instance_id >= 0)
-		if (nla_put_s32(rep_skb, TSN_QCI_SFI_ATTR_FLOW_ID,
-				sficonf.stream_filter.flow_meter_instance_id))
-			return -EMSGSIZE;
-
-	if (sficonf.block_oversize_enable)
-		if (nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE))
-			return -EMSGSIZE;
-	if (sficonf.block_oversize)
-		if (nla_put_flag(rep_skb, TSN_QCI_SFI_ATTR_OVERSIZE))
-			return -EMSGSIZE;
-
-	if (nla_put(rep_skb, TSN_QCI_SFI_ATTR_COUNTERS,
-		    sizeof(struct tsn_qci_psfp_sfi_counters), &sficount))
-		return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, sfiattr);
-
-	return tsn_send_reply(rep_skb, info);
-err:
-	nlmsg_free(rep_skb);
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, -TSN_ATTRERR);
-exit:
-	return ret;
-}
-
-static int tsn_qci_sfi_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_sfi_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_sfi_counters_get(struct genl_info *info)
-{
-	struct nlattr *na, *sfiattr;
-	struct nlattr *sfi[TSN_QCI_SFI_ATTR_MAX + 1];
-	u32 sfi_handle;
-	struct sk_buff *rep_skb;
-	int ret;
-	struct net_device *netdev;
-	struct genlmsghdr *genlhdr;
-	struct tsn_qci_psfp_sfi_counters sficount;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	genlhdr = info->genlhdr;
-
-	if (!info->attrs[TSN_ATTR_QCI_SFI])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_QCI_SFI];
-
-	ret = NLA_PARSE_NESTED(sfi, TSN_QCI_SFI_ATTR_MAX,
-			       na, qci_sfi_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (!sfi[TSN_QCI_SFI_ATTR_INDEX])
-		return -EINVAL;
-
-	sfi_handle = nla_get_u32(sfi[TSN_QCI_SFI_ATTR_INDEX]);
-
-	memset(&sficount, 0, sizeof(struct tsn_qci_psfp_sfi_counters));
-	if (!tsnops->qci_sfi_counters_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = tsnops->qci_sfi_counters_get(netdev, sfi_handle, &sficount);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
-				NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		goto err;
-
-	sfiattr = nla_nest_start(rep_skb, TSN_ATTR_QCI_SFI);
-	if (!sfiattr) {
-		ret = -EINVAL;
-		goto err;
-	}
-
-	if (nla_put_u32(rep_skb, TSN_QCI_SFI_ATTR_INDEX, sfi_handle))
-		return -EMSGSIZE;
-
-	tsnops->qci_sfi_counters_get(netdev, sfi_handle, &sficount);
-
-	if (nla_put(rep_skb, TSN_QCI_SFI_ATTR_COUNTERS,
-		    sizeof(struct tsn_qci_psfp_sfi_counters), &sficount))
-		return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, sfiattr);
-
-	return tsn_send_reply(rep_skb, info);
-err:
-	nlmsg_free(rep_skb);
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-	return ret;
-}
-
-static int tsn_qci_sfi_counters_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_sfi_counters_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_sgi_set(struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *sgia[TSN_QCI_SGI_ATTR_MAX + 1];
-	struct nlattr *admin[TSN_SGI_ATTR_CTRL_MAX + 1];
-	int ret = 0;
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	struct tsn_qci_psfp_sgi_conf sgi;
-	struct tsn_qci_psfp_gcl *gcl = NULL;
-	u16 sgi_handle = 0;
-	u16 listcount = 0;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&sgi, 0, sizeof(struct tsn_qci_psfp_sgi_conf));
-
-	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_QCI_SGI];
-
-	ret = NLA_PARSE_NESTED(sgia, TSN_QCI_SGI_ATTR_MAX,
-			       na, qci_sgi_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (sgia[TSN_QCI_SGI_ATTR_ENABLE] && sgia[TSN_QCI_SGI_ATTR_DISABLE]) {
-		pr_err("tsn: enable or disable?\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -1;
-	}
-
-	if (sgia[TSN_QCI_SGI_ATTR_INDEX])
-		sgi_handle = nla_get_u32(sgia[TSN_QCI_SGI_ATTR_INDEX]);
-
-	if (sgia[TSN_QCI_SGI_ATTR_DISABLE]) {
-		sgi.gate_enabled = 0;
-		goto loaddev;
-	} else {
-		/* set default to be enable*/
-		sgi.gate_enabled = 1;
-	}
-
-	if (sgia[TSN_QCI_SGI_ATTR_CONFCHANGE])
-		sgi.config_change = 1;
-
-	if (sgia[TSN_QCI_SGI_ATTR_IRXEN])
-		sgi.block_invalid_rx_enable = 1;
-
-	if (sgia[TSN_QCI_SGI_ATTR_IRX])
-		sgi.block_invalid_rx = 1;
-
-	if (sgia[TSN_QCI_SGI_ATTR_OEXEN])
-		sgi.block_octets_exceeded_enable = 1;
-
-	if (sgia[TSN_QCI_SGI_ATTR_OEX])
-		sgi.block_octets_exceeded = 1;
-
-	if (sgia[TSN_QCI_SGI_ATTR_ADMINENTRY]) {
-		struct nlattr *entry;
-		int rem;
-		int count = 0;
-
-		na = sgia[TSN_QCI_SGI_ATTR_ADMINENTRY];
-		ret = NLA_PARSE_NESTED(admin, TSN_SGI_ATTR_CTRL_MAX,
-				       na, qci_sgi_ctrl_policy);
-
-		/* Other parameters in admin control */
-		if (admin[TSN_SGI_ATTR_CTRL_INITSTATE])
-			sgi.admin.gate_states = 1;
-
-		if (admin[TSN_SGI_ATTR_CTRL_CYTIME])
-			sgi.admin.cycle_time =
-				nla_get_u32(admin[TSN_SGI_ATTR_CTRL_CYTIME]);
-
-		if (admin[TSN_SGI_ATTR_CTRL_CYTIMEEX])
-			sgi.admin.cycle_time_extension =
-				nla_get_u32(admin[TSN_SGI_ATTR_CTRL_CYTIMEEX]);
-
-		if (admin[TSN_SGI_ATTR_CTRL_BTIME])
-			sgi.admin.base_time =
-				nla_get_u64(admin[TSN_SGI_ATTR_CTRL_BTIME]);
-
-		if (admin[TSN_SGI_ATTR_CTRL_INITIPV])
-			sgi.admin.init_ipv =
-				nla_get_s8(admin[TSN_SGI_ATTR_CTRL_INITIPV]);
-		else
-			sgi.admin.init_ipv = -1;
-
-		if (admin[TSN_SGI_ATTR_CTRL_LEN]) {
-			sgi.admin.control_list_length =
-				nla_get_u8(admin[TSN_SGI_ATTR_CTRL_LEN]);
-			listcount = sgi.admin.control_list_length;
-		}
-
-		if (!listcount)
-			goto loaddev;
-
-		gcl = kmalloc_array(listcount, sizeof(*gcl), GFP_KERNEL);
-
-		memset(gcl, 0, listcount * sizeof(struct tsn_qci_psfp_gcl));
-
-		/* Check the whole admin attrs,
-		 * checkout the TSN_SGI_ATTR_CTRL_GCLENTRY attributes
-		 */
-		nla_for_each_nested(entry, na, rem) {
-			struct nlattr *gcl_entry[TSN_SGI_ATTR_GCL_MAX + 1];
-			struct nlattr *ti, *om;
-
-			if (nla_type(entry) != TSN_SGI_ATTR_CTRL_GCLENTRY)
-				continue;
-
-			/* parse each TSN_SGI_ATTR_CTRL_GCLENTRY */
-			ret = NLA_PARSE_NESTED(gcl_entry, TSN_SGI_ATTR_GCL_MAX,
-					       entry, qci_sgi_gcl_policy);
-			/* Parse gate control list */
-			if (gcl_entry[TSN_SGI_ATTR_GCL_GATESTATE])
-				(gcl + count)->gate_state = 1;
-
-			if (gcl_entry[TSN_SGI_ATTR_GCL_IPV])
-				(gcl + count)->ipv =
-				 nla_get_s8(gcl_entry[TSN_SGI_ATTR_GCL_IPV]);
-
-			if (gcl_entry[TSN_SGI_ATTR_GCL_INTERVAL]) {
-				ti = gcl_entry[TSN_SGI_ATTR_GCL_INTERVAL];
-				(gcl + count)->time_interval = nla_get_u32(ti);
-			}
-
-			if (gcl_entry[TSN_SGI_ATTR_GCL_OCTMAX]) {
-				om = gcl_entry[TSN_SGI_ATTR_GCL_OCTMAX];
-				(gcl + count)->octet_max = nla_get_u32(om);
-			}
-
-			count++;
-
-			if (count >= listcount)
-				break;
-		}
-
-		if (count < listcount) {
-			tsn_simple_reply(info, TSN_CMD_REPLY,
-					 netdev->name, -TSN_ATTRERR);
-			pr_err("tsn: count less than TSN_SGI_ATTR_CTRL_LEN\n");
-			kfree(gcl);
-			return -EINVAL;
-		}
-
-	} else {
-		pr_info("tsn: no admin list parameters setting\n");
-	}
-
-loaddev:
-	if (!tsnops->qci_sgi_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		kfree(gcl);
-		return -EINVAL;
-	}
-
-	sgi.admin.gcl = gcl;
-
-	ret = tsnops->qci_sgi_set(netdev, sgi_handle, &sgi);
-	kfree(gcl);
-	if (!ret)
-		return tsn_simple_reply(info, TSN_CMD_REPLY,
-					netdev->name, TSN_SUCCESS);
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, -TSN_DEVRETERR);
-	return -1;
-}
-
-static int tsn_qci_sgi_set(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_sgi_set(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_sgi_get(struct genl_info *info)
-{
-	struct nlattr *na, *sgiattr, *adminattr, *sglattr;
-	struct nlattr *sgi[TSN_QCI_SGI_ATTR_MAX + 1];
-	struct sk_buff *rep_skb;
-	int ret;
-	struct net_device *netdev;
-	struct genlmsghdr *genlhdr;
-	struct tsn_qci_psfp_sgi_conf sgiadmin;
-	struct tsn_qci_psfp_gcl *gcl = NULL;
-	const struct tsn_ops *tsnops;
-	u16 sgi_handle;
-	u8 listcount, i;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input\n");
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_QCI_SGI];
-
-	ret = NLA_PARSE_NESTED(sgi, TSN_QCI_SGI_ATTR_MAX,
-			       na, qci_sgi_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (!sgi[TSN_QCI_SGI_ATTR_INDEX]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input\n");
-		return -EINVAL;
-	}
-
-	sgi_handle = nla_get_u32(sgi[TSN_QCI_SGI_ATTR_INDEX]);
-
-	/* Get config data from device */
-	genlhdr = info->genlhdr;
-
-	memset(&sgiadmin, 0, sizeof(struct tsn_qci_psfp_sgi_conf));
-
-	if (!tsnops->qci_sgi_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = tsnops->qci_sgi_get(netdev, sgi_handle, &sgiadmin);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -1;
-	}
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	/* Down 1 */
-	sgiattr = nla_nest_start(rep_skb, TSN_ATTR_QCI_SGI);
-	if (!sgiattr)
-		return -EMSGSIZE;
-
-	if (nla_put_u32(rep_skb, TSN_QCI_SGI_ATTR_INDEX, sgi_handle))
-		return -EMSGSIZE;
-
-	/* Gate enable? sgiadmin.gate_enabled */
-	if (sgiadmin.gate_enabled) {
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_ENABLE))
-			return -EMSGSIZE;
-	} else {
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_DISABLE))
-			return -EMSGSIZE;
-	}
-
-	if (sgiadmin.config_change)
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_CONFCHANGE))
-			return -EMSGSIZE;
-
-	if (sgiadmin.block_invalid_rx_enable)
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_IRXEN))
-			return -EMSGSIZE;
-
-	if (sgiadmin.block_invalid_rx)
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_IRX))
-			return -EMSGSIZE;
-
-	if (sgiadmin.block_octets_exceeded_enable)
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_OEXEN))
-			return -EMSGSIZE;
-
-	if (sgiadmin.block_octets_exceeded)
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_OEX))
-			return -EMSGSIZE;
-
-	/* Administration Down 2 */
-	adminattr = nla_nest_start(rep_skb, TSN_QCI_SGI_ATTR_ADMINENTRY);
-	if (!adminattr)
-		return -EMSGSIZE;
-
-	if (sgiadmin.admin.gate_states)
-		if (nla_put_flag(rep_skb, TSN_SGI_ATTR_CTRL_INITSTATE))
-			return -EMSGSIZE;
-
-	if (nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIME,
-			sgiadmin.admin.cycle_time) ||
-	    nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIMEEX,
-			sgiadmin.admin.cycle_time_extension) ||
-	    NLA_PUT_U64(rep_skb, TSN_SGI_ATTR_CTRL_BTIME,
-			sgiadmin.admin.base_time) ||
-	    nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_INITIPV,
-		       sgiadmin.admin.init_ipv))
-		return -EMSGSIZE;
-
-	listcount = sgiadmin.admin.control_list_length;
-	if (!listcount)
-		goto out1;
-
-	if (!sgiadmin.admin.gcl) {
-		pr_err("error: no gate control list\n");
-		ret = -TSN_DEVRETERR;
-		goto err;
-	}
-
-	gcl = sgiadmin.admin.gcl;
-
-	/* loop list */
-	for (i = 0; i < listcount; i++) {
-		s8 ipv;
-		u32 ti, omax;
-
-		if (!(gcl + i)) {
-			pr_err("error: list count too big\n");
-			ret = -TSN_DEVRETERR;
-			kfree(sgiadmin.admin.gcl);
-			goto err;
-		}
-
-		/* Adminastration entry down 3 */
-		sglattr = nla_nest_start(rep_skb, TSN_SGI_ATTR_CTRL_GCLENTRY);
-		if (!sglattr)
-			return -EMSGSIZE;
-		ipv = (gcl + i)->ipv;
-		ti = (gcl + i)->time_interval;
-		omax = (gcl + i)->octet_max;
-
-		if ((gcl + i)->gate_state)
-			if (nla_put_flag(rep_skb, TSN_SGI_ATTR_GCL_GATESTATE))
-				return -EMSGSIZE;
-
-		if (nla_put_s8(rep_skb, TSN_SGI_ATTR_GCL_IPV, ipv) ||
-		    nla_put_u32(rep_skb, TSN_SGI_ATTR_GCL_INTERVAL, ti) ||
-		    nla_put_u32(rep_skb, TSN_SGI_ATTR_GCL_OCTMAX, omax))
-			return -EMSGSIZE;
-
-		/* End administration entry down 3 */
-		nla_nest_end(rep_skb, sglattr);
-	}
-
-	kfree(sgiadmin.admin.gcl);
-	if (nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_LEN, listcount))
-		return -EMSGSIZE;
-
-out1:
-	/* End adminastration down 2 */
-	nla_nest_end(rep_skb, adminattr);
-
-	/* End down 1 */
-	nla_nest_end(rep_skb, sgiattr);
-
-	return tsn_send_reply(rep_skb, info);
-err:
-	nlmsg_free(rep_skb);
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, ret);
-	return -1;
-}
-
-static int tsn_qci_sgi_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_sgi_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_sgi_status_get(struct genl_info *info)
-{
-	struct nlattr *na, *sgiattr, *operattr, *sglattr;
-	struct nlattr *sgi[TSN_QCI_SGI_ATTR_MAX + 1];
-	struct sk_buff *rep_skb;
-	int ret;
-	struct net_device *netdev;
-	struct genlmsghdr *genlhdr;
-	struct tsn_psfp_sgi_status sgistat;
-	struct tsn_qci_psfp_gcl *gcl = NULL;
-	const struct tsn_ops *tsnops;
-	u16 sgi_handle;
-	u8 listcount;
-	int valid, i;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_QCI_SGI]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input\n");
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_QCI_SGI];
-
-	ret = NLA_PARSE_NESTED(sgi, TSN_QCI_SGI_ATTR_MAX,
-			       na, qci_sgi_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (!sgi[TSN_QCI_SGI_ATTR_INDEX]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		pr_err("tsn: no sgi handle input\n");
-		return -EINVAL;
-	}
-
-	sgi_handle = nla_get_u32(sgi[TSN_QCI_SGI_ATTR_INDEX]);
-
-	/* Get status data from device */
-	genlhdr = info->genlhdr;
-
-	memset(&sgistat, 0, sizeof(struct tsn_psfp_sgi_status));
-
-	if (!tsnops->qci_sgi_status_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	valid = tsnops->qci_sgi_status_get(netdev, sgi_handle, &sgistat);
-	if (valid < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -1;
-	}
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	/* Down 1 */
-	sgiattr = nla_nest_start(rep_skb, TSN_ATTR_QCI_SGI);
-	if (!sgiattr)
-		return -EMSGSIZE;
-
-	if (nla_put_u32(rep_skb, TSN_QCI_SGI_ATTR_INDEX, sgi_handle))
-		return -EMSGSIZE;
-
-	/* Gate enable? */
-	if (valid == 1) {
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_ENABLE))
-			return -EMSGSIZE;
-	} else {
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_DISABLE))
-			return -EMSGSIZE;
-	}
-
-	if (nla_put_u32(rep_skb, TSN_QCI_SGI_ATTR_TICKG,
-			sgistat.tick_granularity) ||
-	    NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CCTIME,
-			sgistat.config_change_time) ||
-	    NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CUTIME,
-			sgistat.current_time) ||
-	    NLA_PUT_U64(rep_skb, TSN_QCI_SGI_ATTR_CCERROR,
-			sgistat.config_change_error))
-		return -EMSGSIZE;
-
-	if (sgistat.config_pending)
-		if (nla_put_flag(rep_skb, TSN_QCI_SGI_ATTR_CPENDING))
-			return -EMSGSIZE;
-
-	/* operation Down 2 */
-	operattr = nla_nest_start(rep_skb, TSN_QCI_SGI_ATTR_OPERENTRY);
-	if (!operattr)
-		return -EMSGSIZE;
-
-	if (sgistat.oper.gate_states)
-		if (nla_put_flag(rep_skb, TSN_SGI_ATTR_CTRL_INITSTATE))
-			return -EMSGSIZE;
-
-	if (nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIME,
-			sgistat.oper.cycle_time) ||
-	    nla_put_u32(rep_skb, TSN_SGI_ATTR_CTRL_CYTIMEEX,
-			sgistat.oper.cycle_time_extension) ||
-	    NLA_PUT_U64(rep_skb, TSN_SGI_ATTR_CTRL_BTIME,
-			sgistat.oper.base_time) ||
-	    nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_INITIPV,
-		       sgistat.oper.init_ipv))
-		return -EMSGSIZE;
-
-	/* Loop list */
-	listcount = sgistat.oper.control_list_length;
-	if (!listcount)
-		goto out1;
-
-	if (!sgistat.oper.gcl) {
-		pr_err("error: list lenghth is not zero!\n");
-		ret = -TSN_DEVRETERR;
-		goto err;
-	}
-
-	gcl = sgistat.oper.gcl;
-
-	/* loop list */
-	for (i = 0; i < listcount; i++) {
-		s8 ipv;
-		u32 ti, omax;
-
-		if (!(gcl + i)) {
-			pr_err("error: list count too big\n");
-			ret = -TSN_DEVRETERR;
-			kfree(sgistat.oper.gcl);
-			goto err;
-		}
-
-		/* Operation entry down 3 */
-		sglattr = nla_nest_start(rep_skb, TSN_SGI_ATTR_CTRL_GCLENTRY);
-		if (!sglattr)
-			return -EMSGSIZE;
-		ipv = (gcl + i)->ipv;
-		ti = (gcl + i)->time_interval;
-		omax = (gcl + i)->octet_max;
-
-		if ((gcl + i)->gate_state)
-			if (nla_put_flag(rep_skb, TSN_SGI_ATTR_GCL_GATESTATE))
-				return -EMSGSIZE;
-
-		if (nla_put_s8(rep_skb, TSN_SGI_ATTR_GCL_IPV, ipv) ||
-		    nla_put_u32(rep_skb, TSN_SGI_ATTR_GCL_INTERVAL, ti) ||
-		    nla_put_u32(rep_skb, TSN_SGI_ATTR_GCL_OCTMAX, omax))
-			return -EMSGSIZE;
-
-		/* End operation entry down 3 */
-		nla_nest_end(rep_skb, sglattr);
-	}
-
-	kfree(sgistat.oper.gcl);
-	if (nla_put_u8(rep_skb, TSN_SGI_ATTR_CTRL_LEN, listcount))
-		return -EMSGSIZE;
-out1:
-	/* End operation down 2 */
-	nla_nest_end(rep_skb, operattr);
-
-	/* End down 1 */
-	nla_nest_end(rep_skb, sgiattr);
-
-	return tsn_send_reply(rep_skb, info);
-err:
-	nlmsg_free(rep_skb);
-	tsn_simple_reply(info, TSN_CMD_REPLY, netdev->name, -TSN_ATTRERR);
-	return -1;
-}
-
-static int tsn_qci_sgi_status_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_sgi_status_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_fmi_set(struct genl_info *info)
-{
-	struct nlattr *na, *fmi[TSN_QCI_FMI_ATTR_MAX + 1];
-	u32 index;
-	int ret;
-	struct net_device *netdev;
-	struct tsn_qci_psfp_fmi fmiconf;
-	const struct tsn_ops *tsnops;
-	bool enable = 0;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&fmiconf, 0, sizeof(struct tsn_qci_psfp_fmi));
-
-	if (!info->attrs[TSN_ATTR_QCI_FMI])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_QCI_FMI];
-
-	ret = NLA_PARSE_NESTED(fmi, TSN_QCI_FMI_ATTR_MAX, na, qci_fmi_policy);
-	if (ret) {
-		pr_info("tsn: parse value TSN_QCI_FMI_ATTR_MAX  error.");
-		return -EINVAL;
-	}
-
-	if (!fmi[TSN_QCI_FMI_ATTR_INDEX])
-		return -EINVAL;
-
-	index = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_INDEX]);
-
-	if (fmi[TSN_QCI_FMI_ATTR_DISABLE])
-		goto loaddev;
-
-	enable = 1;
-
-	if (fmi[TSN_QCI_FMI_ATTR_CIR])
-		fmiconf.cir = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_CIR]);
-
-	if (fmi[TSN_QCI_FMI_ATTR_CBS])
-		fmiconf.cbs = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_CBS]);
-
-	if (fmi[TSN_QCI_FMI_ATTR_EIR])
-		fmiconf.eir = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_EIR]);
-
-	if (fmi[TSN_QCI_FMI_ATTR_EBS])
-		fmiconf.ebs = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_EBS]);
-
-	if (fmi[TSN_QCI_FMI_ATTR_CF])
-		fmiconf.cf = 1;
-
-	if (fmi[TSN_QCI_FMI_ATTR_CM])
-		fmiconf.cm = 1;
-
-	if (fmi[TSN_QCI_FMI_ATTR_DROPYL])
-		fmiconf.drop_on_yellow = 1;
-
-	if (fmi[TSN_QCI_FMI_ATTR_MAREDEN])
-		fmiconf.mark_red_enable = 1;
-
-	if (fmi[TSN_QCI_FMI_ATTR_MARED])
-		fmiconf.mark_red = 1;
-
-loaddev:
-
-	if (!tsnops->qci_fmi_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
-	}
-
-	tsnops->qci_fmi_set(netdev, index, enable, &fmiconf);
-
-	if (tsn_simple_reply(info, TSN_CMD_REPLY,
-			     netdev->name, TSN_SUCCESS))
-		return -1;
-
-	return 0;
-}
-
-static int tsn_qci_fmi_set(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_fmi_set(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qci_fmi_get(struct genl_info *info)
-{
-	struct nlattr *na, *fmi[TSN_QCI_FMI_ATTR_MAX + 1], *fmiattr;
-	u32 index;
-	struct sk_buff *rep_skb;
-	int ret;
-	struct net_device *netdev;
-	struct tsn_qci_psfp_fmi fmiconf;
-	struct tsn_qci_psfp_fmi_counters counters;
-	const struct tsn_ops *tsnops;
-	struct genlmsghdr *genlhdr;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_QCI_FMI])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_QCI_FMI];
-
-	ret = NLA_PARSE_NESTED(fmi, TSN_QCI_FMI_ATTR_MAX,
-			       na, qci_fmi_policy);
-	if (ret) {
-		pr_info("tsn: parse value TSN_QCI_FMI_ATTR_MAX  error.");
-		return -EINVAL;
-	}
-
-	if (!fmi[TSN_QCI_FMI_ATTR_INDEX])
-		return -EINVAL;
-
-	index = nla_get_u32(fmi[TSN_QCI_FMI_ATTR_INDEX]);
-
-	/* Get data from device */
-	memset(&fmiconf, 0, sizeof(struct tsn_qci_psfp_fmi));
-	memset(&counters, 0, sizeof(struct tsn_qci_psfp_fmi_counters));
-
-	if (!tsnops->qci_fmi_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
-	}
-
-	tsnops->qci_fmi_get(netdev, index, &fmiconf, &counters);
-
-	genlhdr = info->genlhdr;
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	fmiattr = nla_nest_start(rep_skb, TSN_ATTR_QCI_FMI);
-	if (!fmiattr)
-		return -EMSGSIZE;
-
-	if (nla_put_u32(rep_skb, TSN_QCI_FMI_ATTR_INDEX, index) ||
-	    nla_put_u32(rep_skb, TSN_QCI_FMI_ATTR_CIR, fmiconf.cir) ||
-	    nla_put_u32(rep_skb, TSN_QCI_FMI_ATTR_CBS, fmiconf.cbs) ||
-	    nla_put_u32(rep_skb, TSN_QCI_FMI_ATTR_EIR, fmiconf.eir) ||
-	    nla_put_u32(rep_skb, TSN_QCI_FMI_ATTR_EBS, fmiconf.ebs))
-		return -EMSGSIZE;
-
-	if (fmiconf.cf)
-		if (nla_put_flag(rep_skb, TSN_QCI_FMI_ATTR_CF))
-			return -EMSGSIZE;
-
-	if (fmiconf.cm)
-		if (nla_put_flag(rep_skb, TSN_QCI_FMI_ATTR_CM))
-			return -EMSGSIZE;
-
-	if (fmiconf.drop_on_yellow)
-		if (nla_put_flag(rep_skb, TSN_QCI_FMI_ATTR_DROPYL))
-			return -EMSGSIZE;
-
-	if (fmiconf.mark_red_enable)
-		if (nla_put_flag(rep_skb, TSN_QCI_FMI_ATTR_MAREDEN))
-			return -EMSGSIZE;
-
-	if (fmiconf.mark_red)
-		if (nla_put_flag(rep_skb, TSN_QCI_FMI_ATTR_MAREDEN))
-			return -EMSGSIZE;
-
-	if (nla_put(rep_skb, TSN_QCI_FMI_ATTR_COUNTERS,
-		    sizeof(struct tsn_qci_psfp_fmi_counters), &counters))
-		return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, fmiattr);
-
-	tsn_send_reply(rep_skb, info);
-
-	return 0;
-}
-
-static int tsn_qci_fmi_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qci_fmi_get(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qbv_set(struct genl_info *info)
-{
-	struct nlattr *na, *na1;
-	struct nlattr *qbv_table;
-	struct nlattr *qbv[TSN_QBV_ATTR_MAX + 1];
-	struct nlattr *qbvctrl[TSN_QBV_ATTR_CTRL_MAX + 1];
-	int rem;
-	int ret = 0;
-	struct net_device *netdev;
-	struct tsn_qbv_conf qbvconfig;
-	const struct tsn_ops *tsnops;
-	struct tsn_qbv_entry *gatelist = NULL;
-	int count = 0;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&qbvconfig, 0, sizeof(struct tsn_qbv_conf));
-
-	if (!info->attrs[TSN_ATTR_QBV])
-		return -EINVAL;
-
-	na = info->attrs[TSN_ATTR_QBV];
-
-	ret = NLA_PARSE_NESTED(qbv, TSN_QBV_ATTR_MAX, na, qbv_policy);
-	if (ret)
-		return -EINVAL;
-
-	if (qbv[TSN_QBV_ATTR_ENABLE])
-		qbvconfig.gate_enabled = 1;
-	else
-		goto setdrive;
-
-	if (qbv[TSN_QBV_ATTR_CONFIGCHANGE])
-		qbvconfig.config_change = 1;
-
-	if (!qbv[TSN_QBV_ATTR_ADMINENTRY]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -1;
-	}
-
-	na1 = qbv[TSN_QBV_ATTR_ADMINENTRY];
-	NLA_PARSE_NESTED(qbvctrl, TSN_QBV_ATTR_CTRL_MAX,
-			 na1, qbv_ctrl_policy);
-
-	if (qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIME]) {
-		qbvconfig.admin.cycle_time =
-			nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIME]);
-	}
-
-	if (qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIMEEXT]) {
-		qbvconfig.admin.cycle_time_extension =
-			nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_CYCLETIMEEXT]);
-	}
-
-	if (qbvctrl[TSN_QBV_ATTR_CTRL_BASETIME]) {
-		qbvconfig.admin.base_time =
-			nla_get_u64(qbvctrl[TSN_QBV_ATTR_CTRL_BASETIME]);
-	}
-
-	if (qbvctrl[TSN_QBV_ATTR_CTRL_GATESTATE]) {
-		qbvconfig.admin.gate_states =
-			nla_get_u8(qbvctrl[TSN_QBV_ATTR_CTRL_GATESTATE]);
-	}
-
-	if (qbvctrl[TSN_QBV_ATTR_CTRL_LISTCOUNT]) {
-		int listcount;
-
-		listcount = nla_get_u32(qbvctrl[TSN_QBV_ATTR_CTRL_LISTCOUNT]);
-
-		qbvconfig.admin.control_list_length = listcount;
-
-		gatelist = kmalloc_array(listcount,
-					 sizeof(*gatelist),
-					 GFP_KERNEL);
-
-		nla_for_each_nested(qbv_table, na1, rem) {
-			struct nlattr *qbv_entry[TSN_QBV_ATTR_ENTRY_MAX + 1];
-
-			if (nla_type(qbv_table) != TSN_QBV_ATTR_CTRL_LISTENTRY)
-				continue;
-
-			ret = NLA_PARSE_NESTED(qbv_entry,
-					       TSN_QBV_ATTR_ENTRY_MAX,
-					       qbv_table, qbv_entry_policy);
-			if (ret)
-				return -EINVAL;
-
-			(gatelist + count)->gate_state =
-				nla_get_u8(qbv_entry[TSN_QBV_ATTR_ENTRY_GC]);
-			(gatelist + count)->time_interval =
-				nla_get_u32(qbv_entry[TSN_QBV_ATTR_ENTRY_TM]);
-			count++;
-			if (count > listcount)
-				break;
-		}
-	}
-
-	if (gatelist)
-		qbvconfig.admin.control_list = gatelist;
-
-setdrive:
-	if (!tsnops->qbv_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		goto err;
-	}
-
-	ret = tsnops->qbv_set(netdev, &qbvconfig);
-
-	/* send back */
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-
-err:
-	kfree(gatelist);
-
-	return ret;
-}
-
-static int tsn_qbv_set(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME]) {
-		cmd_qbv_set(info);
-		return 0;
-	}
-
-	return -1;
-}
-
-static int cmd_qbv_get(struct genl_info *info)
-{
-	struct nlattr *qbv, *qbvadminattr;
-	struct sk_buff *rep_skb;
-	int ret;
-	int len = 0, i = 0;
-	struct net_device *netdev;
-	struct genlmsghdr *genlhdr;
-	struct tsn_qbv_conf qbvconf;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	genlhdr = info->genlhdr;
-
-	memset(&qbvconf, 0, sizeof(struct tsn_qbv_conf));
-
-	if (!tsnops->qbv_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = tsnops->qbv_get(netdev, &qbvconf);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return ret;
-	}
-
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	qbv = nla_nest_start(rep_skb, TSN_ATTR_QBV);
-	if (!qbv)
-		return -EMSGSIZE;
-
-	qbvadminattr = nla_nest_start(rep_skb, TSN_QBV_ATTR_ADMINENTRY);
-	if (!qbvadminattr)
-		return -EMSGSIZE;
-
-	if (qbvconf.admin.control_list) {
-		len = qbvconf.admin.control_list_length;
-		if (nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_LISTCOUNT, len))
-			return -EMSGSIZE;
-
-		for (i = 0; i < len; i++) {
-			struct nlattr *qbv_table;
-			u8 gs;
-			u32 tp;
-
-			gs = (qbvconf.admin.control_list + i)->gate_state;
-			tp = (qbvconf.admin.control_list + i)->time_interval;
-
-			qbv_table = nla_nest_start(rep_skb,
-						   TSN_QBV_ATTR_CTRL_LISTENTRY);
-			if (!qbv_table)
-				return -EMSGSIZE;
-
-			if (nla_put_u32(rep_skb, TSN_QBV_ATTR_ENTRY_ID, i) ||
-			    nla_put_u8(rep_skb, TSN_QBV_ATTR_ENTRY_GC, gs) ||
-			    nla_put_u32(rep_skb, TSN_QBV_ATTR_ENTRY_TM, tp))
-				return -EMSGSIZE;
-			nla_nest_end(rep_skb, qbv_table);
-		}
-
-		if (qbvconf.admin.gate_states)
-			if (nla_put_u8(rep_skb, TSN_QBV_ATTR_CTRL_GATESTATE,
-				       qbvconf.admin.gate_states))
-				return -EMSGSIZE;
-
-		if (qbvconf.admin.cycle_time)
-			if (nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIME,
-					qbvconf.admin.cycle_time))
-				return -EMSGSIZE;
-
-		if (qbvconf.admin.cycle_time_extension)
-			if (nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIMEEXT,
-					qbvconf.admin.cycle_time_extension))
-				return -EMSGSIZE;
-
-		if (qbvconf.admin.base_time)
-			if (NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME,
-					qbvconf.admin.base_time))
-				return -EMSGSIZE;
-
-		kfree(qbvconf.admin.control_list);
-
-	} else {
-		pr_info("tsn: error get administrator data.");
-	}
-
-	nla_nest_end(rep_skb, qbvadminattr);
-
-	if (qbvconf.gate_enabled) {
-		if (nla_put_flag(rep_skb, TSN_QBV_ATTR_ENABLE))
-			return -EMSGSIZE;
-	} else {
-		if (nla_put_flag(rep_skb, TSN_QBV_ATTR_DISABLE))
-			return -EMSGSIZE;
-	}
-
-	if (qbvconf.maxsdu)
-		if (nla_put_u32(rep_skb, TSN_QBV_ATTR_MAXSDU, qbvconf.maxsdu))
-			return -EMSGSIZE;
-
-	if (qbvconf.config_change)
-		if (nla_put_flag(rep_skb, TSN_QBV_ATTR_CONFIGCHANGE))
-			return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, qbv);
-
-	tsn_send_reply(rep_skb, info);
-
-	return ret;
-}
-
-static int cmd_qbv_status_get(struct genl_info *info)
-{
-	struct nlattr *qbv, *qbvoperattr;
-	struct sk_buff *rep_skb;
-	int ret;
-	int len = 0, i = 0;
-	struct net_device *netdev;
-	struct genlmsghdr *genlhdr;
-	struct tsn_qbv_status qbvstatus;
-	const struct tsn_ops *tsnops;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	genlhdr = info->genlhdr;
-
-	memset(&qbvstatus, 0, sizeof(struct tsn_qbv_status));
-
-	if (!tsnops->qbv_get_status) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = tsnops->qbv_get_status(netdev, &qbvstatus);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return ret;
-	}
-
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	qbv = nla_nest_start(rep_skb, TSN_ATTR_QBV);
-	if (!qbv)
-		return -EMSGSIZE;
-
-	qbvoperattr = nla_nest_start(rep_skb, TSN_QBV_ATTR_OPERENTRY);
-	if (!qbvoperattr)
-		return -EMSGSIZE;
-
-	if (qbvstatus.oper.control_list) {
-		len = qbvstatus.oper.control_list_length;
-		if (nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_LISTCOUNT, len)) {
-			nla_nest_cancel(rep_skb, qbvoperattr);
-			return -EMSGSIZE;
-		}
-
-		for (i = 0; i < len; i++) {
-			struct nlattr *qbv_table;
-			u8 gs;
-			u32 tp;
-
-			gs = (qbvstatus.oper.control_list + i)->gate_state;
-			tp = (qbvstatus.oper.control_list + i)->time_interval;
-
-			qbv_table = nla_nest_start(rep_skb,
-						   TSN_QBV_ATTR_CTRL_LISTENTRY);
-			if (!qbv_table)
-				return -EMSGSIZE;
-
-			if (nla_put_u32(rep_skb, TSN_QBV_ATTR_ENTRY_ID, i) ||
-			    nla_put_u8(rep_skb, TSN_QBV_ATTR_ENTRY_GC, gs) ||
-			    nla_put_u32(rep_skb, TSN_QBV_ATTR_ENTRY_TM, tp)) {
-				nla_nest_cancel(rep_skb, qbv_table);
-				return -EMSGSIZE;
-			}
-
-			nla_nest_end(rep_skb, qbv_table);
-		}
-
-		if (qbvstatus.oper.gate_states) {
-			if (nla_put_u8(rep_skb, TSN_QBV_ATTR_CTRL_GATESTATE,
-				       qbvstatus.oper.gate_states))
-				return -EMSGSIZE;
-		}
-
-		if (qbvstatus.oper.cycle_time) {
-			if (nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIME,
-					qbvstatus.oper.cycle_time))
-				return -EMSGSIZE;
-		}
-
-		if (qbvstatus.oper.cycle_time_extension) {
-			if (nla_put_u32(rep_skb, TSN_QBV_ATTR_CTRL_CYCLETIMEEXT,
-					qbvstatus.oper.cycle_time_extension))
-				return -EMSGSIZE;
-		}
-
-		if (qbvstatus.oper.base_time) {
-			if (NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CTRL_BASETIME,
-					qbvstatus.oper.base_time))
-				return -EMSGSIZE;
-		}
-
-		kfree(qbvstatus.oper.control_list);
-	} else {
-		pr_info("tsn: error get operation list data.");
-	}
-
-	nla_nest_end(rep_skb, qbvoperattr);
-
-	if (qbvstatus.config_change_time) {
-		if (NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGETIME,
-				qbvstatus.config_change_time))
-			return -EMSGSIZE;
-	}
-
-	if (qbvstatus.tick_granularity) {
-		if (nla_put_u32(rep_skb, TSN_QBV_ATTR_GRANULARITY,
-				qbvstatus.tick_granularity))
-			return -EMSGSIZE;
-	}
-
-	if (qbvstatus.current_time) {
-		if (NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CURRENTTIME,
-				qbvstatus.current_time))
-			return -EMSGSIZE;
-	}
-
-	if (qbvstatus.config_pending) {
-		if (nla_put_flag(rep_skb, TSN_QBV_ATTR_CONFIGPENDING))
-			return -EMSGSIZE;
-	}
-
-	if (qbvstatus.config_change_error) {
-		if (NLA_PUT_U64(rep_skb, TSN_QBV_ATTR_CONFIGCHANGEERROR,
-				qbvstatus.config_change_error))
-			return -EMSGSIZE;
-	}
-
-	if (qbvstatus.supported_list_max) {
-		if (nla_put_u32(rep_skb, TSN_QBV_ATTR_LISTMAX,
-				qbvstatus.supported_list_max))
-			return -EMSGSIZE;
-	}
-
-	nla_nest_end(rep_skb, qbv);
-
-	tsn_send_reply(rep_skb, info);
-
-	return ret;
-}
-
-static int tsn_qbv_status_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME])
-		cmd_qbv_status_get(info);
-
-	return 0;
-}
-
-static int tsn_qbv_get(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME])
-		cmd_qbv_get(info);
-
-	return 0;
-}
-
-static int tsn_cbs_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *cbsa[TSN_CBS_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	u8 tc, bw;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_CBS]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_CBS];
-
-	if (!tsnops->cbs_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = NLA_PARSE_NESTED(cbsa, TSN_CBS_ATTR_MAX, na, cbs_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (!cbsa[TSN_CBS_ATTR_TC_INDEX]) {
-		pr_err("tsn: no TSN_CBS_ATTR_TC_INDEX input\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-	tc = nla_get_u8(cbsa[TSN_CBS_ATTR_TC_INDEX]);
-
-	if (!cbsa[TSN_CBS_ATTR_BW]) {
-		pr_err("tsn: no TSN_CBS_ATTR_BW input\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	bw = nla_get_u8(cbsa[TSN_CBS_ATTR_BW]);
-	if (bw > 100) {
-		pr_err("tsn: TSN_CBS_ATTR_BW isn't in the range of 0~100\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	ret = tsnops->cbs_set(netdev, tc, bw);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-	return 0;
-}
-
-static int tsn_cbs_get(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na, *cbsattr;
-	struct nlattr *cbsa[TSN_CBS_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	struct sk_buff *rep_skb;
-	int ret;
-	struct genlmsghdr *genlhdr;
-	u8 tc;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_CBS]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (!tsnops->cbs_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	na = info->attrs[TSN_ATTR_CBS];
-	ret = NLA_PARSE_NESTED(cbsa, TSN_CBS_ATTR_MAX, na, cbs_policy);
-	if (ret) {
-		pr_err("tsn: parse value TSN_CBS_ATTR_MAX error.");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	/* Get status data from device */
-	genlhdr = info->genlhdr;
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
-				NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	cbsattr = nla_nest_start(rep_skb, TSN_ATTR_CBS);
-	if (!cbsattr)
-		return -EMSGSIZE;
-
-	if (!cbsa[TSN_CBS_ATTR_TC_INDEX]) {
-		pr_err("tsn: must to specify the TSN_CBS_ATTR_TC_INDEX\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-	tc = nla_get_u8(cbsa[TSN_CBS_ATTR_TC_INDEX]);
-
-	ret = tsnops->cbs_get(netdev, tc);
-	if (ret < 0) {
-		pr_err("tsn: cbs_get return error\n");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (nla_put_u8(rep_skb, TSN_CBS_ATTR_BW, ret & 0XF))
-		return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, cbsattr);
-	return tsn_send_reply(rep_skb, info);
-}
-
-static int cmd_qbu_set(struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *qbua[TSN_QBU_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	u8 preemptible = 0;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_QBU]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_QBU];
-
-	ret = NLA_PARSE_NESTED(qbua, TSN_QBU_ATTR_MAX, na, qbu_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (qbua[TSN_QBU_ATTR_ADMIN_STATE])
-		preemptible = nla_get_u8(qbua[TSN_QBU_ATTR_ADMIN_STATE]);
-	else
-		pr_info("No preemptible TSN_QBU_ATTR_ADMIN_STATE config!\n");
-
-	if (!tsnops->qbu_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
-	}
-
-	ret = tsnops->qbu_set(netdev, preemptible);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-	return 0;
-}
-
-static int tsn_qbu_set(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME])
-		return cmd_qbu_set(info);
-
-	return -1;
-}
-
-static int cmd_qbu_get_status(struct genl_info *info)
-{
-	struct nlattr *qbuattr;
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	struct sk_buff *rep_skb;
-	int ret;
-	struct genlmsghdr *genlhdr;
-	struct tsn_preempt_status pps;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	/* Get status data from device */
-	genlhdr = info->genlhdr;
-
-	memset(&pps, 0, sizeof(struct tsn_preempt_status));
-
-	if (!tsnops->qbu_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = tsnops->qbu_get(netdev, &pps);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -1;
-	}
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	qbuattr = nla_nest_start(rep_skb, TSN_ATTR_QBU);
-	if (!qbuattr)
-		return -EMSGSIZE;
-
-	if (nla_put_u8(rep_skb, TSN_QBU_ATTR_ADMIN_STATE, pps.admin_state) ||
-	    nla_put_u32(rep_skb,
-			TSN_QBU_ATTR_HOLD_ADVANCE, pps.hold_advance) ||
-	    nla_put_u32(rep_skb,
-			TSN_QBU_ATTR_RELEASE_ADVANCE, pps.release_advance))
-		return -EMSGSIZE;
-
-	if (pps.preemption_active) {
-		if (nla_put_flag(rep_skb, TSN_QBU_ATTR_ACTIVE))
-			return -EMSGSIZE;
-	}
-
-	if (nla_put_u8(rep_skb, TSN_QBU_ATTR_HOLD_REQUEST, pps.hold_request))
-		return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, qbuattr);
-
-	return tsn_send_reply(rep_skb, info);
-}
-
-static int tsn_qbu_get_status(struct sk_buff *skb, struct genl_info *info)
-{
-	if (info->attrs[TSN_ATTR_IFNAME])
-		return cmd_qbu_get_status(info);
-
-	return -1;
-}
-
-static int tsn_tsd_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *ntsd[TSN_TSD_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	struct tsn_tsd tsd;
-	int ret;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	memset(&tsd, 0, sizeof(struct tsn_tsd));
-
-	if (!info->attrs[TSN_ATTR_TSD]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_TSD];
-
-	ret = NLA_PARSE_NESTED(ntsd, TSN_TSD_ATTR_MAX, na, tsd_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (!tsnops->tsd_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -EINVAL;
-	}
-
-	if (nla_get_flag(ntsd[TSN_TSD_ATTR_DISABLE])) {
-		tsd.enable = false;
-	} else {
-		if (ntsd[TSN_TSD_ATTR_PERIOD])
-			tsd.period = nla_get_u32(ntsd[TSN_TSD_ATTR_PERIOD]);
-
-		if (!tsd.period) {
-			tsn_simple_reply(info, TSN_CMD_REPLY,
-					 netdev->name, -TSN_ATTRERR);
-			return -EINVAL;
-		}
-
-		if (ntsd[TSN_TSD_ATTR_MAX_FRM_NUM])
-			tsd.maxFrameNum =
-				nla_get_u32(ntsd[TSN_TSD_ATTR_MAX_FRM_NUM]);
-
-		if (ntsd[TSN_TSD_ATTR_SYN_IMME])
-			tsd.syn_flag = 2;
-		else
-			tsd.syn_flag = 1;
-
-		tsd.enable = true;
-	}
-
-	ret = tsnops->tsd_set(netdev, &tsd);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-	return 0;
-}
-
-static int tsn_tsd_get(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na, *tsdattr;
-	struct nlattr *tsda[TSN_TSD_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	struct sk_buff *rep_skb;
-	int ret;
-	struct genlmsghdr *genlhdr;
-	struct tsn_tsd_status tts;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_TSD]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	if (!tsnops->tsd_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = tsnops->tsd_get(netdev, &tts);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -1;
-	}
-
-	na = info->attrs[TSN_ATTR_TSD];
-
-	ret = NLA_PARSE_NESTED(tsda, TSN_TSD_ATTR_MAX,
-			       na, tsd_policy);
-	if (ret) {
-		pr_err("tsn: parse value TSN_TSD_ATTR_MAX error.");
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	/* Get status data from device */
-	genlhdr = info->genlhdr;
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd, &rep_skb,
-				NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	tsdattr = nla_nest_start(rep_skb, TSN_ATTR_TSD);
-	if (!tsdattr)
-		return -EMSGSIZE;
-
-	if (nla_put_u32(rep_skb, TSN_TSD_ATTR_PERIOD, tts.period) ||
-	    nla_put_u32(rep_skb, TSN_TSD_ATTR_MAX_FRM_NUM, tts.maxFrameNum) ||
-	    nla_put_u32(rep_skb, TSN_TSD_ATTR_CYCLE_NUM, tts.cycleNum) ||
-	    nla_put_u32(rep_skb, TSN_TSD_ATTR_LOSS_STEPS, tts.loss_steps) ||
-	    nla_put_u32(rep_skb, TSN_TSD_ATTR_MAX_FRM_NUM, tts.maxFrameNum))
-		return -EMSGSIZE;
-
-	if (!tts.enable) {
-		if (nla_put_flag(rep_skb, TSN_TSD_ATTR_DISABLE))
-			return -EMSGSIZE;
-	} else {
-		if (nla_put_flag(rep_skb, TSN_TSD_ATTR_ENABLE))
-			return -EMSGSIZE;
-	}
-
-	if (tts.flag == 2)
-		if (nla_put_flag(rep_skb, TSN_TSD_ATTR_SYN_IMME))
-			return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, tsdattr);
-	return tsn_send_reply(rep_skb, info);
-}
-
-static int tsn_ct_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *cta[TSN_CT_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	u8 queue_stat;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_CT]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_CT];
-
-	if (!tsnops->ct_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = NLA_PARSE_NESTED(cta, TSN_CT_ATTR_MAX,
-			       na, ct_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	queue_stat = nla_get_u8(cta[TSN_CT_ATTR_QUEUE_STATE]);
-
-	ret = tsnops->ct_set(netdev, queue_stat);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-	return 0;
-}
-
-static int tsn_cbgen_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *cbgena[TSN_CBGEN_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	u32 index;
-	struct tsn_seq_gen_conf sg_conf;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_CBGEN]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_CBGEN];
-
-	if (!tsnops->cbgen_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = NLA_PARSE_NESTED(cbgena, TSN_CBGEN_ATTR_MAX,
-			       na, cbgen_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	index = nla_get_u32(cbgena[TSN_CBGEN_ATTR_INDEX]);
-
-	memset(&sg_conf, 0, sizeof(struct tsn_seq_gen_conf));
-	sg_conf.iport_mask = nla_get_u8(cbgena[TSN_CBGEN_ATTR_PORT_MASK]);
-	sg_conf.split_mask = nla_get_u8(cbgena[TSN_CBGEN_ATTR_SPLIT_MASK]);
-	sg_conf.seq_len = nla_get_u8(cbgena[TSN_CBGEN_ATTR_SEQ_LEN]);
-	sg_conf.seq_num = nla_get_u32(cbgena[TSN_CBGEN_ATTR_SEQ_NUM]);
-
-	ret = tsnops->cbgen_set(netdev, index, &sg_conf);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-	return 0;
-}
-
-static int tsn_cbrec_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *cbreca[TSN_CBREC_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	u32 index;
-	struct tsn_seq_rec_conf sr_conf;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_CBREC]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_CBREC];
-
-	if (!tsnops->cbrec_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = NLA_PARSE_NESTED(cbreca, TSN_CBREC_ATTR_MAX,
-			       na, cbrec_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	index = nla_get_u32(cbreca[TSN_CBREC_ATTR_INDEX]);
-
-	memset(&sr_conf, 0, sizeof(struct tsn_seq_rec_conf));
-	sr_conf.seq_len = nla_get_u8(cbreca[TSN_CBREC_ATTR_SEQ_LEN]);
-	sr_conf.his_len = nla_get_u8(cbreca[TSN_CBREC_ATTR_HIS_LEN]);
-	sr_conf.rtag_pop_en = nla_get_flag(cbreca[TSN_CBREC_ATTR_TAG_POP_EN]);
-
-	ret = tsnops->cbrec_set(netdev, index, &sr_conf);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-	return 0;
-}
-
-static int tsn_cbstatus_get(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *cba[TSN_CBSTAT_ATTR_MAX + 1];
-	struct nlattr *cbattr;
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	struct sk_buff *rep_skb;
-	int ret;
-	unsigned int index;
-	struct genlmsghdr *genlhdr;
-	struct tsn_cb_status cbstat;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	/* Get status data from device */
-	genlhdr = info->genlhdr;
-
-	memset(&cbstat, 0, sizeof(struct tsn_cb_status));
-
-	if (!tsnops->cb_get) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	na = info->attrs[TSN_ATTR_CBSTAT];
-	ret = NLA_PARSE_NESTED(cba, TSN_CBSTAT_ATTR_MAX,
-			       na, cbstat_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	index = nla_get_u32(cba[TSN_CBSTAT_ATTR_INDEX]);
-
-	ret = tsnops->cb_get(netdev, index, &cbstat);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -1;
-	}
-
-	/* Form netlink reply data */
-	ret = tsn_prepare_reply(info, genlhdr->cmd,
-				&rep_skb, NLMSG_ALIGN(MAX_ATTR_SIZE));
-	if (ret < 0)
-		return ret;
-
-	if (nla_put_string(rep_skb, TSN_ATTR_IFNAME, netdev->name))
-		return -EMSGSIZE;
-
-	cbattr = nla_nest_start(rep_skb, TSN_ATTR_CBSTAT);
-	if (!cbattr)
-		return -EMSGSIZE;
-
-	if (nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_GEN_REC, cbstat.gen_rec) ||
-	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_ERR, cbstat.err) ||
-	    nla_put_u32(rep_skb, TSN_CBSTAT_ATTR_SEQ_NUM,
-			cbstat.seq_num) ||
-	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_SEQ_LEN, cbstat.seq_len) ||
-	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_SPLIT_MASK,
-		       cbstat.split_mask) ||
-	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_PORT_MASK,
-		       cbstat.iport_mask) ||
-	    nla_put_u8(rep_skb, TSN_CBSTAT_ATTR_HIS_LEN, cbstat.his_len) ||
-	    nla_put_u32(rep_skb, TSN_CBSTAT_ATTR_SEQ_HIS,
-			cbstat.seq_his))
-		return -EMSGSIZE;
-
-	nla_nest_end(rep_skb, cbattr);
-
-	return tsn_send_reply(rep_skb, info);
-}
-
-static int tsn_pcpmap_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *pcpmapa[TSN_PCPMAP_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	bool enable = 0;
-	struct tsn_port *port;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_PCPMAP]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_PCPMAP];
-
-	if (!tsnops->pcpmap_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = NLA_PARSE_NESTED(pcpmapa, TSN_PCPMAP_ATTR_MAX,
-			       na, pcpmap_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	enable = nla_get_flag(pcpmapa[TSN_PCPMAP_ATTR_ENABLE]);
-	ret = tsnops->pcpmap_set(netdev, enable);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-
-	return 0;
-}
-
-static int tsn_dscp_set(struct sk_buff *skb, struct genl_info *info)
-{
-	struct nlattr *na;
-	struct nlattr *dscpa[TSN_DSCP_ATTR_MAX + 1];
-	struct net_device *netdev;
-	const struct tsn_ops *tsnops;
-	int ret;
-	bool enable = 0;
-	struct tsn_port *port;
-	int dscp_ix;
-	struct tsn_qos_switch_dscp_conf dscp_conf;
-
-	port = tsn_init_check(info, &netdev);
-	if (!port)
-		return -ENODEV;
-
-	tsnops = port->tsnops;
-
-	if (!info->attrs[TSN_ATTR_DSCP]) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	na = info->attrs[TSN_ATTR_DSCP];
-
-	if (!tsnops->dscp_set) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_NODEVOPS);
-		return -1;
-	}
-
-	ret = NLA_PARSE_NESTED(dscpa, TSN_DSCP_ATTR_MAX,
-			       na, dscp_policy);
-	if (ret) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_ATTRERR);
-		return -EINVAL;
-	}
-
-	enable = 1;
-	if (dscpa[TSN_DSCP_ATTR_DISABLE])
-		enable = 0;
-	dscp_ix = nla_get_u32(dscpa[TSN_DSCP_ATTR_INDEX]);
-	dscp_conf.cos = nla_get_u32(dscpa[TSN_DSCP_ATTR_COS]);
-	dscp_conf.dpl = nla_get_u32(dscpa[TSN_DSCP_ATTR_DPL]);
-	ret = tsnops->dscp_set(netdev, enable, dscp_ix, &dscp_conf);
-	if (ret < 0) {
-		tsn_simple_reply(info, TSN_CMD_REPLY,
-				 netdev->name, -TSN_DEVRETERR);
-		return -EINVAL;
-	}
-
-	tsn_simple_reply(info, TSN_CMD_REPLY,
-			 netdev->name, TSN_SUCCESS);
-
-	return 0;
-}
-
-static const struct genl_ops tsnnl_ops[] = {
-	{
-		.cmd		= TSN_CMD_ECHO,
-		.doit		= tsn_echo_cmd,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QBV_SET,
-		.doit		= tsn_qbv_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QBV_GET,
-		.doit		= tsn_qbv_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QBV_GET_STATUS,
-		.doit		= tsn_qbv_status_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CB_STREAMID_SET,
-		.doit		= tsn_cb_streamid_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CB_STREAMID_GET,
-		.doit		= tsn_cb_streamid_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CB_STREAMID_GET_COUNTS,
-		.doit		= tsn_cb_streamid_counters_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SFI_SET,
-		.doit		= tsn_qci_sfi_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SFI_GET,
-		.doit		= tsn_qci_sfi_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SFI_GET_COUNTS,
-		.doit		= tsn_qci_sfi_counters_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SGI_SET,
-		.doit		= tsn_qci_sgi_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SGI_GET,
-		.doit		= tsn_qci_sgi_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_SGI_GET_STATUS,
-		.doit		= tsn_qci_sgi_status_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_FMI_SET,
-		.doit		= tsn_qci_fmi_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QCI_FMI_GET,
-		.doit		= tsn_qci_fmi_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CBS_SET,
-		.doit		= tsn_cbs_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CBS_GET,
-		.doit		= tsn_cbs_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QBU_SET,
-		.doit		= tsn_qbu_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_QBU_GET_STATUS,
-		.doit		= tsn_qbu_get_status,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_TSD_SET,
-		.doit		= tsn_tsd_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_TSD_GET,
-		.doit		= tsn_tsd_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CT_SET,
-		.doit		= tsn_ct_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CBGEN_SET,
-		.doit		= tsn_cbgen_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CBREC_SET,
-		.doit		= tsn_cbrec_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_CBSTAT_GET,
-		.doit		= tsn_cbstatus_get,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_PCPMAP_SET,
-		.doit		= tsn_pcpmap_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-	{
-		.cmd		= TSN_CMD_DSCP_SET,
-		.doit		= tsn_dscp_set,
-		.policy		= tsn_cmd_policy,
-		.flags		= GENL_ADMIN_PERM,
-	},
-};
-
-static struct genl_family tsn_family = {
-	.name		= TSN_GENL_NAME,
-	.version	= TSN_GENL_VERSION,
-	.maxattr	= TSN_CMD_ATTR_MAX,
-	.module		= THIS_MODULE,
-	.ops		= tsnnl_ops,
-	.n_ops		= ARRAY_SIZE(tsnnl_ops),
-};
-
-int tsn_port_register(struct net_device *netdev,
-		      struct tsn_ops *tsnops, u16 groupid)
-{
-	struct tsn_port *port;
-
-	if (list_empty(&port_list)) {
-		INIT_LIST_HEAD(&port_list);
-	} else {
-		list_for_each_entry(port, &port_list, list) {
-			if (port->netdev == netdev) {
-				pr_info("TSN device already registered!\n");
-				return -1;
-			}
-		}
-	}
-
-	port = kzalloc(sizeof(*port), GFP_KERNEL);
-	if (!port)
-		return -1;
-
-	port->netdev = netdev;
-	port->groupid = groupid;
-	port->tsnops = tsnops;
-
-	if (groupid < GROUP_OFFSET_SWITCH)
-		port->type = TSN_ENDPOINT;
-	else
-		port->type = TSN_SWITCH;
-
-	list_add_tail(&port->list, &port_list);
-
-	if (tsnops && tsnops->device_init)
-		port->tsnops->device_init(netdev);
-
-	return 0;
-}
-EXPORT_SYMBOL(tsn_port_register);
-
-void tsn_port_unregister(struct net_device *netdev)
-{
-	struct tsn_port *p;
-
-	list_for_each_entry(p, &port_list, list) {
-		if (!p || !p->netdev)
-			continue;
-		if (p->netdev == netdev) {
-			if (p->tsnops->device_deinit)
-				p->tsnops->device_deinit(netdev);
-			list_del(&p->list);
-			kfree(p);
-			break;
-		}
-	}
-}
-EXPORT_SYMBOL(tsn_port_unregister);
-
-static int __init tsn_genetlink_init(void)
-{
-	int ret;
-
-	pr_info("tsn generic netlink module v%d init...\n", TSN_GENL_VERSION);
-
-	ret = genl_register_family(&tsn_family);
-
-	if (ret != 0) {
-		pr_info("failed to init tsn generic netlink example module\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static void __exit tsn_genetlink_exit(void)
-{
-	int ret;
-
-	ret = genl_unregister_family(&tsn_family);
-	if (ret != 0)
-		pr_info("failed to unregister family:%i\n", ret);
-}
-
-module_init(tsn_genetlink_init);
-module_exit(tsn_genetlink_exit);
-MODULE_LICENSE("GPL");
-- 
2.17.1


From ceacd4d25ba99c5c4ab761efe012de82e7b2b629 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Fri, 1 Feb 2019 13:30:48 +0800
Subject: [PATCH] driver: perf: instead of get_cpu() with
 raw_smp_processor_id()

When call cci_pmu_init() between get_cpu and put_cpu, the
code is executed in preempt disable status. In this way,
if we enable configure CONFIG_DEBUG_ATOMIC_SLEEP, there is
a call trace as below:
BUG: sleeping function called from invalid context at
kernel/locking/mutex.c:239
in_atomic(): 1, irqs_disabled(): 0, pid: 1, name: swapper/0
Preemption disabled at:
[<ffffff8008976d00>] cci_pmu_probe+0x1c8/0x458
CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.18.17-yocto-standard #1
Hardware name: ZynqMP ZCU102 Rev1.0 (DT)
Call trace:
 dump_backtrace+0x0/0x158
 show_stack+0x24/0x30
 dump_stack+0x80/0xa4
 ___might_sleep+0x148/0x170
 __might_sleep+0x58/0x90
 mutex_lock+0x2c/0x60
 perf_pmu_register+0x2c/0x3d8
 cci_pmu_probe+0x2a8/0x458
 platform_drv_probe+0x58/0xa8
 driver_probe_device+0x210/0x2f8
 __driver_attach+0xf4/0xf8
 bus_for_each_dev+0x84/0xd8
 driver_attach+0x30/0x40
 bus_add_driver+0x1e0/0x210
 driver_register+0x64/0x110
 __platform_driver_register+0x54/0x60
 cci_pmu_driver_init+0x20/0x28
 do_one_initcall+0x68/0x248
 kernel_init_freeable+0x2d4/0x3cc
 kernel_init+0x18/0x108
 ret_from_fork+0x10/0x1c

The reason is that  might_sleep() is invoked in preempt disable
status.
In addition, it is not need to get a real cpu index when register
PMU. So, only keep the cpu filed of struct cci_pmu as -1 so that
PMU is not used and avoid getting out out sync before cpu hotplug
setup completely.
At the last of driver probe, get the cpu index with raw_smp_processor_id()
for perf event initialization.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/perf/arm-cci.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/drivers/perf/arm-cci.c b/drivers/perf/arm-cci.c
index 0d09d8e..2fe5a39 100644
--- a/drivers/perf/arm-cci.c
+++ b/drivers/perf/arm-cci.c
@@ -1336,9 +1336,9 @@ static int cci_pmu_event_init(struct perf_event *event)
 	 * the event being installed into its context, so the PMU's CPU can't
 	 * change under our feet.
 	 */
+	event->cpu = cci_pmu->cpu;
 	if (event->cpu < 0)
 		return -EINVAL;
-	event->cpu = cci_pmu->cpu;
 
 	event->destroy = hw_perf_event_destroy;
 	if (!atomic_inc_not_zero(active_events)) {
@@ -1678,19 +1678,21 @@ static int cci_pmu_probe(struct platform_device *pdev)
 	raw_spin_lock_init(&cci_pmu->hw_events.pmu_lock);
 	mutex_init(&cci_pmu->reserve_mutex);
 	atomic_set(&cci_pmu->active_events, 0);
-	cci_pmu->cpu = get_cpu();
+	cci_pmu->cpu = -1;
 
 	ret = cci_pmu_init(cci_pmu, pdev);
 	if (ret) {
-		put_cpu();
 		return ret;
 	}
 
+	g_cci_pmu = cci_pmu;
+
 	cpuhp_setup_state_nocalls(CPUHP_AP_PERF_ARM_CCI_ONLINE,
 				  "perf/arm/cci:online", NULL,
 				  cci_pmu_offline_cpu);
-	put_cpu();
-	g_cci_pmu = cci_pmu;
+
+	cci_pmu->cpu = raw_smp_processor_id();
+
 	pr_info("ARM %s PMU driver probed", cci_pmu->model->name);
 	return 0;
 }
-- 
1.7.9.5


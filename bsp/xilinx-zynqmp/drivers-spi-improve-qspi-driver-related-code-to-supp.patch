From 7e2578b0d6c1c57da064a2ad4a9d17359116e722 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Sun, 27 Jan 2019 13:18:45 +0800
Subject: [PATCH 1/2] drivers: spi: improve qspi driver related code to
 support the serial flash on xilinx-zcu102 platform

Compared with kernel v4.14, kernel v4.18 upgrades spi related code
and involve spi memory operation interface. But it is not compatible
with qspi driver of xilinx-zcu102 platform. So, it is need to do some
improvement so that qspi serial flash works fine. These code modifications
refer to below sdk patches:
commit ID a20bed804ba9("spi: zynqmp: gqspi: Added separate dummy
entry")
commit ID e6a0d9dfa87d ("pi: zynqmp-gqspi: Added a support for variable
tx bus width")
commit ID 11262a2a3c4a("mtd: Added dummy entry in the spi_transfer
structure")

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/mtd/devices/m25p80.c   |   14 +++++++
 drivers/spi/spi-mem.c          |    9 ++++
 drivers/spi/spi-zynqmp-gqspi.c |   84 +++++++++++++++++++++++++++++++++++++--
 include/linux/spi/spi.h        |    5 ++-
 4 files changed, 106 insertions(+), 6 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 9b5ed92..606a2db 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -62,6 +62,19 @@ static int m25p80_read_reg(struct spi_nor *nor, u8 code, u8 *val, int len)
 	return ret;
 }
 
+#ifdef CONFIG_SPI_ZYNQMP_GQSPI
+static int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
+{
+	struct m25p *flash = nor->priv;
+	struct spi_device *spi = flash->spimem->spi;
+
+	flash->command[0] = opcode;
+	if (buf)
+		memcpy(&flash->command[1], buf, len);
+
+	return spi_write(spi, flash->command, len + 1);
+}
+#else
 static int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
 {
 	struct m25p *flash = nor->priv;
@@ -82,6 +95,7 @@ static int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
 
 	return ret;
 }
+#endif
 
 static ssize_t m25p80_write(struct spi_nor *nor, loff_t to, size_t len,
 			    const u_char *buf)
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index ec0c24e..1464afb 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -247,6 +247,9 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 		return -ENOMEM;
 
 	spi_message_init(&msg);
+#ifdef CONFIG_SPI_ZYNQMP_GQSPI
+	memset(xfers, 0x00, ARRAY_SIZE(xfers)*sizeof(struct spi_transfer));
+#endif
 
 	tmpbuf[0] = op->cmd.opcode;
 	xfers[xferpos].tx_buf = tmpbuf;
@@ -266,6 +269,9 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 		xfers[xferpos].tx_buf = tmpbuf + 1;
 		xfers[xferpos].len = op->addr.nbytes;
 		xfers[xferpos].tx_nbits = op->addr.buswidth;
+#ifdef CONFIG_SPI_ZYNQMP_GQSPI
+		xfers[xferpos].isaddr = true;
+#endif
 		spi_message_add_tail(&xfers[xferpos], &msg);
 		xferpos++;
 		totalxferlen += op->addr.nbytes;
@@ -276,6 +282,9 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 		xfers[xferpos].tx_buf = tmpbuf + op->addr.nbytes + 1;
 		xfers[xferpos].len = op->dummy.nbytes;
 		xfers[xferpos].tx_nbits = op->dummy.buswidth;
+#ifdef CONFIG_SPI_ZYNQMP_GQSPI
+		xfers[xferpos].isdummy = true;
+#endif
 		spi_message_add_tail(&xfers[xferpos], &msg);
 		xferpos++;
 		totalxferlen += op->dummy.nbytes;
diff --git a/drivers/spi/spi-zynqmp-gqspi.c b/drivers/spi/spi-zynqmp-gqspi.c
index acc279d..5ee3aeb 100644
--- a/drivers/spi/spi-zynqmp-gqspi.c
+++ b/drivers/spi/spi-zynqmp-gqspi.c
@@ -137,6 +137,12 @@
 #define GQSPI_SELECT_MODE_QUADSPI	0x4
 #define GQSPI_DMA_UNALIGN		0x3
 #define GQSPI_DEFAULT_NUM_CS	1	/* Default number of chip selects */
+#define GQSPI_RX_BUS_WIDTH_QUAD		0x4
+#define GQSPI_RX_BUS_WIDTH_DUAL		0x2
+#define GQSPI_RX_BUS_WIDTH_SINGLE	0x1
+#define GQSPI_TX_BUS_WIDTH_QUAD		0x4
+#define GQSPI_TX_BUS_WIDTH_DUAL		0x2
+#define GQSPI_TX_BUS_WIDTH_SINGLE	0x1
 #define GQSPI_LPBK_DLY_ADJ_LPBK_SHIFT	5
 #define GQSPI_LPBK_DLY_ADJ_DLY_1	0x2
 #define GQSPI_LPBK_DLY_ADJ_DLY_1_SHIFT	3
@@ -193,6 +199,8 @@ struct zynqmp_qspi {
 	u32 genfifobus;
 	u32 dma_rx_bytes;
 	dma_addr_t dma_addr;
+	u32 rx_bus_width;
+	u32 tx_bus_width;
 	u32 genfifoentry;
 	bool isinstr;
 	enum mode_type mode;
@@ -470,7 +478,6 @@ static void zynqmp_qspi_chipselect(struct spi_device *qspi, bool is_high)
 	u32 genfifoentry = 0x0, statusreg;
 
 	genfifoentry |= GQSPI_GENFIFO_MODE_SPI;
-	genfifoentry |= xqspi->genfifobus;
 
 	if (qspi->master->flags & SPI_MASTER_BOTH_CS) {
 		zynqmp_gqspi_selectslave(xqspi,
@@ -486,6 +493,8 @@ static void zynqmp_qspi_chipselect(struct spi_device *qspi, bool is_high)
 			GQSPI_SELECT_FLASH_BUS_LOWER);
 	}
 
+	genfifoentry |= xqspi->genfifobus;
+
 	if (!is_high) {
 		genfifoentry |= xqspi->genfifocs;
 		genfifoentry |= GQSPI_GENFIFO_CS_SETUP;
@@ -792,6 +801,28 @@ static inline u32 zynqmp_qspi_selectspimode(struct zynqmp_qspi *xqspi,
 }
 
 /**
+ * zynqmp_qspi_selectspimode_dummy -	Selects SPI mode for dummy - x1 or x2 or x4.
+ * @xqspi:	xqspi is a pointer to the GQSPI instance
+ * Return:	Mask to set desired SPI mode in GENFIFO entry.
+ */
+static inline u32 zynqmp_qspi_selectspimode_dummy(struct zynqmp_qspi *xqspi)
+{
+	u32 mask = 0;
+
+	/* SPI mode */
+	if (xqspi->rx_bus_width == GQSPI_RX_BUS_WIDTH_QUAD ||
+			xqspi->tx_bus_width == GQSPI_TX_BUS_WIDTH_QUAD)
+			mask |= GQSPI_GENFIFO_MODE_QUADSPI;
+	else if (xqspi->rx_bus_width == GQSPI_RX_BUS_WIDTH_DUAL ||
+			xqspi->tx_bus_width == GQSPI_TX_BUS_WIDTH_DUAL)
+			mask |= GQSPI_GENFIFO_MODE_DUALSPI;
+	else
+			mask |= GQSPI_GENFIFO_MODE_SPI;
+
+	return mask;
+}
+
+/**
  * zynq_qspi_setuprxdma -	This function sets up the RX DMA operation
  * @xqspi:	xqspi is a pointer to the GQSPI instance.
  */
@@ -864,10 +895,20 @@ static void zynqmp_qspi_txrxsetup(struct zynqmp_qspi *xqspi,
 		/* Setup data to be TXed */
 		*genfifoentry &= ~GQSPI_GENFIFO_RX;
 		*genfifoentry |= GQSPI_GENFIFO_DATA_XFER;
-		*genfifoentry |= GQSPI_GENFIFO_TX;
-		*genfifoentry |=
-			zynqmp_qspi_selectspimode(xqspi, transfer->tx_nbits);
-		xqspi->bytes_to_transfer = transfer->len;
+		if (transfer->isdummy)
+			*genfifoentry &= ~GQSPI_GENFIFO_TX;
+		else
+			*genfifoentry |= GQSPI_GENFIFO_TX;
+
+		if (transfer->isdummy)
+			*genfifoentry |= zynqmp_qspi_selectspimode_dummy(xqspi);
+		else
+			*genfifoentry |=
+				zynqmp_qspi_selectspimode(xqspi, transfer->tx_nbits);
+		if (transfer->isdummy)
+			xqspi->bytes_to_transfer = 0;
+		else
+			xqspi->bytes_to_transfer = transfer->len;
 		if (xqspi->mode == GQSPI_MODE_DMA) {
 			config_reg = zynqmp_gqspi_read(xqspi,
 							GQSPI_CONFIG_OFST);
@@ -927,6 +968,9 @@ static int zynqmp_qspi_start_transfer(struct spi_master *master,
 		(master->flags & SPI_MASTER_DATA_STRIPE))
 		genfifoentry |= GQSPI_GENFIFO_STRIPE;
 
+	if (transfer->isaddr || transfer->isdummy)
+		genfifoentry &= ~GQSPI_GENFIFO_STRIPE;
+
 	zynqmp_qspi_txrxsetup(xqspi, transfer, &genfifoentry);
 
 	if (xqspi->mode == GQSPI_MODE_DMA)
@@ -934,6 +978,9 @@ static int zynqmp_qspi_start_transfer(struct spi_master *master,
 	else
 		transfer_len = transfer->len;
 
+	if (transfer->isdummy)
+		transfer_len = (transfer->len*8)/transfer->tx_nbits;
+
 	xqspi->genfifoentry = genfifoentry;
 	if ((transfer_len) < GQSPI_GENFIFO_IMM_DATA_MASK) {
 		genfifoentry &= ~GQSPI_GENFIFO_IMM_DATA_MASK;
@@ -1153,6 +1200,9 @@ static int zynqmp_qspi_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct device *dev = &pdev->dev;
 	u32 num_cs;
+	u32 rx_bus_width;
+	u32 tx_bus_width;
+	struct device_node *nc;
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*xqspi));
 	if (!master)
@@ -1223,6 +1273,30 @@ static int zynqmp_qspi_probe(struct platform_device *pdev)
 		goto clk_dis_all;
 	}
 
+	xqspi->rx_bus_width = GQSPI_RX_BUS_WIDTH_SINGLE;
+	for_each_available_child_of_node(pdev->dev.of_node, nc) {
+		ret = of_property_read_u32(nc, "spi-rx-bus-width",
+					&rx_bus_width);
+		if (!ret) {
+			xqspi->rx_bus_width = rx_bus_width;
+			break;
+		}
+	}
+	if (ret)
+		dev_err(dev, "rx bus width not found\n");
+
+	xqspi->tx_bus_width = GQSPI_TX_BUS_WIDTH_SINGLE;
+	for_each_available_child_of_node(pdev->dev.of_node, nc) {
+		ret = of_property_read_u32(nc, "spi-tx-bus-width",
+					&tx_bus_width);
+		if (!ret) {
+			xqspi->tx_bus_width = tx_bus_width;
+			break;
+		}
+	}
+	if (ret)
+		dev_err(dev, "tx bus width not found\n");
+
 	ret = of_property_read_u32(pdev->dev.of_node, "num-cs", &num_cs);
 	if (ret < 0)
 		master->num_chipselect = GQSPI_DEFAULT_NUM_CS;
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ad8931a..e3ff5d8 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -807,7 +807,10 @@ struct spi_transfer {
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
-
+#ifdef CONFIG_SPI_ZYNQMP_GQSPI
+	bool		isdummy;
+	bool		isaddr;
+#endif
 	struct list_head transfer_list;
 };
 
-- 
1.7.5.4


From 130949b8fa2b370d48bd7ebf73a2a9429892e04a Mon Sep 17 00:00:00 2001
From: Jon Maloy <jon.maloy@ericsson.com>
Date: Thu, 15 Feb 2018 10:40:47 +0100
Subject: [PATCH 101/176] tipc: collapse subscription creation functions

commit 242e82cc95f6b4e83e1771f9915edcb2a63708e1 upstream

After the previous changes it becomes logical to collapse the two-level
creation of subscription instances into one. We do that here.

We also rename the creation and deletion functions for more consistency.

Acked-by: Ying Xue <ying.xue@windriver.com>
Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 net/tipc/server.c |    4 ++--
 net/tipc/server.h |    1 +
 net/tipc/subscr.c |   46 ++++++++++++----------------------------------
 net/tipc/subscr.h |   14 +++++++-------
 4 files changed, 22 insertions(+), 43 deletions(-)

diff --git a/net/tipc/server.c b/net/tipc/server.c
index 5d231fa..6a18b10 100644
--- a/net/tipc/server.c
+++ b/net/tipc/server.c
@@ -203,7 +203,7 @@ static void tipc_con_delete_sub(struct tipc_conn *con, struct tipc_subscr *s)
 	spin_lock_bh(&con->sub_lock);
 	list_for_each_entry_safe(sub, tmp, sub_list, subscrp_list) {
 		if (!s || !memcmp(s, &sub->evt.s, sizeof(*s)))
-			tipc_sub_delete(sub);
+			tipc_sub_unsubscribe(sub);
 		else if (s)
 			break;
 	}
@@ -278,7 +278,7 @@ static int tipc_con_rcv_sub(struct tipc_server *srv,
 		tipc_con_delete_sub(con, s);
 		return 0;
 	}
-	sub = tipc_subscrp_subscribe(srv, s, con->conid);
+	sub = tipc_sub_subscribe(srv, s, con->conid);
 	if (!sub)
 		return -1;
 
diff --git a/net/tipc/server.h b/net/tipc/server.h
index 2de8709..995b795 100644
--- a/net/tipc/server.h
+++ b/net/tipc/server.h
@@ -2,6 +2,7 @@
  * net/tipc/server.h: Include file for TIPC server code
  *
  * Copyright (c) 2012-2013, Wind River Systems
+ * Copyright (c) 2017, Ericsson AB
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/net/tipc/subscr.c b/net/tipc/subscr.c
index 406b09f..8d37b61 100644
--- a/net/tipc/subscr.c
+++ b/net/tipc/subscr.c
@@ -134,33 +134,29 @@ void tipc_subscrp_get(struct tipc_subscription *subscription)
 	kref_get(&subscription->kref);
 }
 
-static struct tipc_subscription *tipc_subscrp_create(struct tipc_server *srv,
-						     struct tipc_subscr *s,
-						     int conid)
+struct tipc_subscription *tipc_sub_subscribe(struct tipc_server *srv,
+					     struct tipc_subscr *s,
+					     int conid)
 {
 	struct tipc_net *tn = tipc_net(srv->net);
 	struct tipc_subscription *sub;
 	u32 filter = tipc_sub_read(s, filter);
+	u32 timeout;
 
-	/* Refuse subscription if global limit exceeded */
-	if (atomic_read(&tn->subscription_count) >= TIPC_MAX_SUBSCRIPTIONS) {
-		pr_warn("Subscription rejected, limit reached (%u)\n",
-			TIPC_MAX_SUBSCRIPTIONS);
+	if (atomic_read(&tn->subscription_count) >= TIPC_MAX_SUBSCR) {
+		pr_warn("Subscription rejected, max (%u)\n", TIPC_MAX_SUBSCR);
+		return NULL;
+	}
+	if ((filter & TIPC_SUB_PORTS && filter & TIPC_SUB_SERVICE) ||
+	    (tipc_sub_read(s, seq.lower) > tipc_sub_read(s, seq.upper))) {
+		pr_warn("Subscription rejected, illegal request\n");
 		return NULL;
 	}
-
-	/* Allocate subscription object */
 	sub = kmalloc(sizeof(*sub), GFP_ATOMIC);
 	if (!sub) {
 		pr_warn("Subscription rejected, no memory\n");
 		return NULL;
 	}
-
-	/* Initialize subscription object */
-	if (filter & TIPC_SUB_PORTS && filter & TIPC_SUB_SERVICE)
-		goto err;
-	if (tipc_sub_read(s, seq.lower) > tipc_sub_read(s, seq.upper))
-		goto err;
 	sub->server = srv;
 	sub->conid = conid;
 	sub->inactive = false;
@@ -168,24 +164,6 @@ static struct tipc_subscription *tipc_subscrp_create(struct tipc_server *srv,
 	spin_lock_init(&sub->lock);
 	atomic_inc(&tn->subscription_count);
 	kref_init(&sub->kref);
-	return sub;
-err:
-	pr_warn("Subscription rejected, illegal request\n");
-	kfree(sub);
-	return NULL;
-}
-
-struct tipc_subscription *tipc_subscrp_subscribe(struct tipc_server *srv,
-						 struct tipc_subscr *s,
-						 int conid)
-{
-	struct tipc_subscription *sub = NULL;
-	u32 timeout;
-
-	sub = tipc_subscrp_create(srv, s, conid);
-	if (!sub)
-		return NULL;
-
 	tipc_nametbl_subscribe(sub);
 	timer_setup(&sub->timer, tipc_subscrp_timeout, 0);
 	timeout = tipc_sub_read(&sub->evt.s, timeout);
@@ -194,7 +172,7 @@ struct tipc_subscription *tipc_subscrp_subscribe(struct tipc_server *srv,
 	return sub;
 }
 
-void tipc_sub_delete(struct tipc_subscription *sub)
+void tipc_sub_unsubscribe(struct tipc_subscription *sub)
 {
 	tipc_nametbl_unsubscribe(sub);
 	if (sub->evt.s.timeout != TIPC_WAIT_FOREVER)
diff --git a/net/tipc/subscr.h b/net/tipc/subscr.h
index db80e41..2d35f10 100644
--- a/net/tipc/subscr.h
+++ b/net/tipc/subscr.h
@@ -1,7 +1,7 @@
 /*
  * net/tipc/subscr.h: Include file for TIPC network topology service
  *
- * Copyright (c) 2003-2006, Ericsson AB
+ * Copyright (c) 2003-2017, Ericsson AB
  * Copyright (c) 2005-2007, 2012-2013, Wind River Systems
  * All rights reserved.
  *
@@ -39,8 +39,8 @@
 
 #include "server.h"
 
-#define TIPC_MAX_SUBSCRIPTIONS	65535
-#define TIPC_MAX_PUBLICATIONS	65535
+#define TIPC_MAX_SUBSCR         65535
+#define TIPC_MAX_PUBLICATIONS   65535
 
 struct tipc_subscription;
 struct tipc_conn;
@@ -66,10 +66,10 @@ struct tipc_subscription {
 	spinlock_t lock; /* serialize up/down and timer events */
 };
 
-struct tipc_subscription *tipc_subscrp_subscribe(struct tipc_server *srv,
-						 struct tipc_subscr *s,
-						 int conid);
-void tipc_sub_delete(struct tipc_subscription *sub);
+struct tipc_subscription *tipc_sub_subscribe(struct tipc_server *srv,
+					     struct tipc_subscr *s,
+					     int conid);
+void tipc_sub_unsubscribe(struct tipc_subscription *sub);
 
 int tipc_subscrp_check_overlap(struct tipc_name_seq *seq, u32 found_lower,
 			       u32 found_upper);
-- 
1.7.9.5


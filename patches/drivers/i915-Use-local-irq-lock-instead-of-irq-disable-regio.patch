From 78bb9cf2dfc9a21f9a29784fbb878c641331419c Mon Sep 17 00:00:00 2001
From: Jiping Ma <jiping.ma2@windriver.com>
Date: Tue, 25 Dec 2018 07:13:56 +0000
Subject: [PATCH] i915: Use local irq lock instead of irq disable regions

Use a local_irq_lock as a replacement for irq off regions. We keep
the semantic of irq-off in regard to the pool->lock and remain preemptible.

BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:974
in_atomic(): 0, irqs_disabled(): 1, pid: 192, name: systemd-udevd
CPU: 2 PID: 192 Comm: systemd-udevd Not tainted 4.18.17-rt8-yocto-preempt-rt #1
Hardware name: NUC5i3MYBE, BIOS MYBDWi30.86A.0017.2014.1127.1854 11/27/201
Call Trace:
 dump_stack+0x4f/0x73
 ? migrate_enable+0x9e/0x3d0
 ___might_sleep.cold.19+0xca/0xdb
 rt_spin_lock+0x37/0x60
 i915_request_retire+0x226/0x4a0 [i915]
 i915_retire_requests+0xa2/0x110 [i915]
 i915_gem_switch_to_kernel_context+0x2c/0x150 [i915]
 ? __i915_request_add+0x27d/0x3f0 [i915]
 i915_gem_init+0x323/0x470 [i915]
 i915_driver_load+0xb3d/0xdf0 [i915]
 i915_pci_probe+0x2b/0x40 [i915]
 local_pci_probe+0x46/0x90
 pci_device_probe+0x119/0x1a0
 driver_probe_device+0x22f/0x300
 __driver_attach+0xbd/0xd0
 ? driver_probe_device+0x300/0x300
 bus_for_each_dev+0x7b/0xc0
 driver_attach+0x1e/0x20
 bus_add_driver+0x1a4/0x1e0
 driver_register+0x70/0xc0
 __pci_register_driver+0x7f/0x90
 ? 0xffffffffc02fb000
 i915_init+0x55/0x58 [i915]
 do_one_initcall+0x53/0x236
 ? __might_sleep+0x4a/0x80
 ? kmem_cache_alloc_trace+0x124/0x230
 ? do_init_module+0x27/0x210
 do_init_module+0x60/0x210
 load_module+0x20dc/0x25f0
 ? vfs_read+0x129/0x150
 ? vfs_read+0x129/0x150
 __se_sys_finit_module+0xc3/0xe0
 ? __se_sys_finit_module+0xc3/0xe0
 __x64_sys_finit_module+0x1a/0x20
 do_syscall_64+0x4d/0xf0
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x7ff026d71ba9

Signed-off-by: Jiping Ma <jiping.ma2@windriver.com>
---
 drivers/gpu/drm/i915/i915_request.c |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_request.c b/drivers/gpu/drm/i915/i915_request.c
index 8928894..e738fd7 100644
--- a/drivers/gpu/drm/i915/i915_request.c
+++ b/drivers/gpu/drm/i915/i915_request.c
@@ -27,9 +27,12 @@
 #include <linux/sched.h>
 #include <linux/sched/clock.h>
 #include <linux/sched/signal.h>
+#include <linux/locallock.h>
 
 #include "i915_drv.h"
 
+static DEFINE_LOCAL_IRQ_LOCK(pendingb_lock);
+
 static const char *i915_fence_get_driver_name(struct dma_fence *fence)
 {
 	return "i915";
@@ -346,6 +349,8 @@ static void free_capture_list(struct i915_request *request)
 static void __retire_engine_request(struct intel_engine_cs *engine,
 				    struct i915_request *rq)
 {
+	unsigned long flags;
+
 	GEM_TRACE("%s(%s) fence %llx:%d, global=%d, current %d\n",
 		  __func__, engine->name,
 		  rq->fence.context, rq->fence.seqno,
@@ -354,7 +359,7 @@ static void __retire_engine_request(struct intel_engine_cs *engine,
 
 	GEM_BUG_ON(!i915_request_completed(rq));
 
-	local_irq_disable();
+	local_lock_irqsave(pendingb_lock, flags);
 
 	spin_lock(&engine->timeline.lock);
 	GEM_BUG_ON(!list_is_first(&rq->link, &engine->timeline.requests));
@@ -372,7 +377,7 @@ static void __retire_engine_request(struct intel_engine_cs *engine,
 	}
 	spin_unlock(&rq->lock);
 
-	local_irq_enable();
+	local_unlock_irqrestore(pendingb_lock, flags);
 
 	/*
 	 * The backing object for the context is done after switching to the
-- 
1.7.5.4


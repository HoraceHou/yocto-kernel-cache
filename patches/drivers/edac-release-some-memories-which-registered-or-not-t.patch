From 4e51fc97f16baabaf1de1c8b6daf1483ac971274 Mon Sep 17 00:00:00 2001
From: Jun Miao <jun.miao@windriver.com>
Date: Mon, 17 Dec 2018 22:10:13 -0500
Subject: [PATCH] edac: release some memories which registered or not to the
 driver subsystem.

This patch can fix the following kmemleak:

unreferenced object 0xffffa1f639d645e0 (size 32):
  comm "systemd-udevd", pid 361, jiffies 4294679877 (age 653.289s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 c0 30 32 f6 a1 ff ff ..........02....
    00 c8 30 32 f6 a1 ff ff 00 00 00 00 00 00 00 00 ..02............
  backtrace:
    [<0000000085cb7a6c>] kmem_cache_alloc_trace+0x148/0x200
    [<00000000c3e7e24d>] edac_mc_alloc+0x316/0x660
    [<00000000a785dc39>] 0xffffffffc03b7566
    [<00000000e2a8abd5>] do_one_initcall+0x53/0x1fe
    [<00000000cc6e09bd>] do_init_module+0x60/0x210
    [<0000000094a5f135>] load_module+0x215b/0x2650
    [<00000000da96f61b>] __se_sys_finit_module+0xc3/0xe0
    [<0000000004a9f952>] __x64_sys_finit_module+0x1a/0x20
    [<00000000e2af0e30>] do_syscall_64+0x4d/0xf0
    [<00000000dee0ce8b>] entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [<00000000745c7f7a>] 0xffffffffffffffff

we have observed some memory leaks when removing the skx_edac.ko.
Actually there are two kinds of memory leaks. The first one is that
some memories used by the csrow and dimm devices are not released in
the corresponding release callback function when the device is unregistered
by using device_unregister(). The second is that some csrow and dimm
devices are not registered to the device driver subsystem at all in some
special cases, so we have to release all the memories used by csrow and
dimm devices.

Signed-off-by: Jun Miao <jun.miao@windriver.com>
---
 drivers/edac/edac_mc.c       |   37 +++++++++++++++++++++++++++++++++++++
 drivers/edac/edac_mc.h       |    9 +++++++++
 drivers/edac/edac_mc_sysfs.c |    8 +++++++-
 3 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 7d3edd7..281066e 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -305,6 +305,40 @@ static void _edac_mc_free(struct mem_ctl_info *mci)
 	kfree(mci);
 }
 
+static void _edac_mc_free_unregister(struct mem_ctl_info *mci)
+{
+	int i, chn, row;
+	struct csrow_info *csr;
+	const unsigned int tot_dimms = mci->tot_dimms;
+	const unsigned int tot_channels = mci->num_cschannel;
+	const unsigned int tot_csrows = mci->nr_csrows;
+
+	if (mci->dimms) {
+		for (i = 0; i < tot_dimms; i++) {
+			struct dimm_info *dimm = mci->dimms[i];
+
+			/* Only expose populated DIMMs */
+			if (!dimm->nr_pages)
+				kfree(mci->dimms[i]);
+		}
+		kfree(mci->dimms);
+	}
+	if (mci->csrows) {
+		for (row = 0; row < tot_csrows; row++) {
+			csr = mci->csrows[row];
+			if (csr && !nr_pages_per_csrow(csr)) {
+				if (csr->channels) {
+					for (chn = 0; chn < tot_channels; chn++)
+						kfree(csr->channels[chn]);
+					kfree(csr->channels);
+				}
+				kfree(csr);
+			}
+		}
+		kfree(mci->csrows);
+	}
+}
+
 struct mem_ctl_info *edac_mc_alloc(unsigned mc_num,
 				   unsigned n_layers,
 				   struct edac_mc_layer *layers,
@@ -514,6 +548,9 @@ void edac_mc_free(struct mem_ctl_info *mci)
 		return;
 	}
 
+	/*the unregistered mci intstance is freed here*/
+	_edac_mc_free_unregister(mci);
+
 	/* the mci instance is freed here, when the sysfs object is dropped */
 	edac_unregister_sysfs(mci);
 }
diff --git a/drivers/edac/edac_mc.h b/drivers/edac/edac_mc.h
index 4165e15..138f42d 100644
--- a/drivers/edac/edac_mc.h
+++ b/drivers/edac/edac_mc.h
@@ -259,4 +259,13 @@ void edac_mc_handle_error(const enum hw_event_mc_err_type type,
  */
 extern char *edac_op_state_to_string(int op_state);
 
+/**
+ * nr_pages_per_csrow()  - Calculate the nr_pages of csrow contains
+ *
+ * @csrow: pointer to a struct csrow_info structure
+ *
+ * Returns: returns the int nr_pages.
+ */
+extern int nr_pages_per_csrow(struct csrow_info *csrow);
+
 #endif				/* _EDAC_MC_H_ */
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index 20374b8..4405b02 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -390,7 +390,7 @@ static umode_t csrow_dev_is_visible(struct kobject *kobj,
 	NULL
 };
 
-static inline int nr_pages_per_csrow(struct csrow_info *csrow)
+int nr_pages_per_csrow(struct csrow_info *csrow)
 {
 	int chan, nr_pages = 0;
 
@@ -399,6 +399,7 @@ static inline int nr_pages_per_csrow(struct csrow_info *csrow)
 
 	return nr_pages;
 }
+EXPORT_SYMBOL(nr_pages_per_csrow);
 
 /* Create a CSROW object under specifed edac_mc_device */
 static int edac_create_csrow_object(struct mem_ctl_info *mci,
@@ -453,12 +454,17 @@ static int edac_create_csrow_objects(struct mem_ctl_info *mci)
 static void edac_delete_csrow_objects(struct mem_ctl_info *mci)
 {
 	int i;
+	int chn;
 	struct csrow_info *csrow;
+	const unsigned int tot_channels = mci->num_cschannel;
 
 	for (i = mci->nr_csrows - 1; i >= 0; i--) {
 		csrow = mci->csrows[i];
 		if (!nr_pages_per_csrow(csrow))
 			continue;
+		for (chn = 0; chn < tot_channels; chn++)
+			kfree(csrow->channels[chn]);
+		kfree(csrow->channels);
 		device_unregister(&mci->csrows[i]->dev);
 	}
 }
-- 
1.7.9.5


From 76f1001e0c23a23145b6a4637144ce115526cc78 Mon Sep 17 00:00:00 2001
From: Haiqing Bai <Haiqing.Bai@windriver.com>
Date: Mon, 28 Jan 2019 09:11:08 +0000
Subject: [PATCH] srcu: Use local irq lock instead of irq disable regions

Use a local_irq_lock as a replacement for irq off regions to fix:
(CONFIG_ATOMIC_SLEEP=y)

BUG: sleeping function called from invalid context at
/kernel-source//kernel/locking/rtmutex.c:986
in_atomic(): 0, irqs_disabled(): 1, pid: 370, name: kworker/u48:2
CPU: 3 PID: 370 Comm: kworker/u48:2 Tainted: G        W
4.12.29-rt0-yocto-preempt-rt #5
Workqueue: events_unbound .fsnotify_mark_destroy_workfn
Call Trace:
[c0000003e4d8f850] [c000000000ba9194] .dump_stack+0xac/0xec (unreliable)
[c0000003e4d8f8e0] [c0000000000a0a74] .___might_sleep+0x184/0x1f0
[c0000003e4d8f970] [c000000000ba5398] .rt_spin_lock+0x38/0xa0
[c0000003e4d8f9f0] [c0000000000e82dc] .__call_srcu+0x8c/0x490
[c0000003e4d8faa0] [c0000000000e87a0]
.__synchronize_srcu.part.4+0x80/0xb0
[c0000003e4d8fb50] [c000000000286918]
.fsnotify_mark_destroy_workfn+0x78/0xf0
[c0000003e4d8fbe0] [c00000000008c7e4] .process_one_work+0x284/0x610
[c0000003e4d8fc90] [c00000000008cbe8] .worker_thread+0x78/0x630
[c0000003e4d8fd70] [c000000000095738] .kthread+0x1b8/0x1c0
[c0000003e4d8fe30] [c0000000000009bc] .ret_from_kernel_thread+0x58/0x9c

Signed-off-by: Haiqing Bai <Haiqing.Bai@windriver.com>
---
 kernel/rcu/srcutree.c |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/kernel/rcu/srcutree.c b/kernel/rcu/srcutree.c
index 876d978..b94748a 100644
--- a/kernel/rcu/srcutree.c
+++ b/kernel/rcu/srcutree.c
@@ -36,6 +36,7 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/srcu.h>
+#include <linux/locallock.h>
 
 #include "rcu.h"
 #include "rcu_segcblist.h"
@@ -772,6 +773,8 @@ static bool srcu_might_be_idle(struct srcu_struct *sp)
  * srcu_read_lock(), and srcu_read_unlock() that are all passed the same
  * srcu_struct structure.
  */
+static DEFINE_LOCAL_IRQ_LOCK(callsrcu_lock);
+
 void __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,
 		 rcu_callback_t func, bool do_norm)
 {
@@ -783,7 +786,7 @@ void __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,
 
 	check_init_srcu_struct(sp);
 	rhp->func = func;
-	local_irq_save(flags);
+	local_lock_irqsave(callsrcu_lock, flags);
 	sdp = this_cpu_ptr(sp->sda);
 	spin_lock(&sdp->lock);
 	rcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);
@@ -799,7 +802,8 @@ void __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,
 		sdp->srcu_gp_seq_needed_exp = s;
 		needexp = true;
 	}
-	spin_unlock_irqrestore(&sdp->lock, flags);
+	spin_unlock(&sdp->lock);
+	local_unlock_irqrestore(callsrcu_lock, flags);
 	if (needgp)
 		srcu_funnel_gp_start(sp, sdp, s, do_norm);
 	else if (needexp)
-- 
1.7.9.5


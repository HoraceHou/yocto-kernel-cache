From 638f9fbaac362510fdf3d87387de58c293698ff9 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Mon, 28 May 2018 15:59:31 +0800
Subject: [PATCH 609/666] fsl_qbman: compatible with kernel update

To avoid below build error:
drivers/staging/fsl_qbman/fsl_usdpaa_irq.c:148:39: error: implicit declaration
of function 'tsk_cpus_allowed'; did you mean 'do_set_cpus_allowed'?
[-Werror=implicit-function-declaration]
|   ret = irq_set_affinity(ctx->irq_num, tsk_cpus_allowed(current));
|                                        ^~~~~~~~~~~~~~~~

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c    | 37 +++++++++--------------------
 drivers/staging/fsl_qbman/fsl_usdpaa_irq.c |  4 ++--
 drivers/staging/fsl_qbman/qman_driver.c    | 38 ++++++++++--------------------
 3 files changed, 25 insertions(+), 54 deletions(-)
 mode change 100644 => 100755 drivers/staging/fsl_qbman/bman_driver.c
 mode change 100644 => 100755 drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
 mode change 100644 => 100755 drivers/staging/fsl_qbman/qman_driver.c

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
old mode 100644
new mode 100755
index f27e58f..f4ae429
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -318,7 +318,7 @@ static int __init parse_bportals(char *str)
 }
 __setup("bportals=", parse_bportals);
 
-static void bman_offline_cpu(unsigned int cpu)
+static int bman_offline_cpu(unsigned int cpu)
 {
 	struct bman_portal *p;
 	const struct bm_portal_config *pcfg;
@@ -328,10 +328,11 @@ static void bman_offline_cpu(unsigned int cpu)
 		if (pcfg)
 			irq_set_affinity(pcfg->public_cfg.irq, cpumask_of(0));
 	}
+	return 0;
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
-static void bman_online_cpu(unsigned int cpu)
+static int bman_online_cpu(unsigned int cpu)
 {
 	struct bman_portal *p;
 	const struct bm_portal_config *pcfg;
@@ -341,30 +342,8 @@ static void bman_online_cpu(unsigned int cpu)
 		if (pcfg)
 			irq_set_affinity(pcfg->public_cfg.irq, cpumask_of(cpu));
 	}
+	return 0;
 }
-
-static int bman_hotplug_cpu_callback(struct notifier_block *nfb,
-					unsigned long action, void *hcpu)
-{
-	unsigned int cpu = (unsigned long)hcpu;
-
-	switch (action) {
-	case CPU_ONLINE:
-	case CPU_ONLINE_FROZEN:
-		bman_online_cpu(cpu);
-		break;
-	case CPU_DOWN_PREPARE:
-	case CPU_DOWN_PREPARE_FROZEN:
-		bman_offline_cpu(cpu);
-	default:
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block bman_hotplug_cpu_notifier = {
-	.notifier_call = bman_hotplug_cpu_callback,
-};
 #endif /* CONFIG_HOTPLUG_CPU */
 
 /* Initialise the Bman driver. The meat of this function deals with portals. The
@@ -512,7 +491,13 @@ __init int bman_init(void)
 	for_each_cpu(cpu, &offline_cpus)
 		bman_offline_cpu(cpu);
 #ifdef CONFIG_HOTPLUG_CPU
-	register_hotcpu_notifier(&bman_hotplug_cpu_notifier);
+	ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					"soc/qbman_portal:online",
+					bman_online_cpu, bman_offline_cpu);
+	if (ret < 0) {
+		pr_err("bman: failed to register hotplug callbacks.\n");
+		return 0;
+	}
 #endif
 	return 0;
 }
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c b/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
old mode 100644
new mode 100755
index b13ba32..914c7471
--- a/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
@@ -145,11 +145,11 @@ static int map_irq(struct file *fp, struct usdpaa_ioctl_irq_map *irq_map)
 		fput(ctx->usdpaa_filp);
 		return ret;
 	}
-	ret = irq_set_affinity(ctx->irq_num, tsk_cpus_allowed(current));
+	ret = irq_set_affinity(ctx->irq_num, &current->cpus_allowed);
 	if (ret)
 		pr_err("USDPAA irq_set_affinity() failed, ret= %d\n", ret);
 
-	ret = irq_set_affinity_hint(ctx->irq_num, tsk_cpus_allowed(current));
+	ret = irq_set_affinity_hint(ctx->irq_num, &current->cpus_allowed);
 	if (ret)
 		pr_err("USDPAA irq_set_affinity_hint() failed, ret= %d\n", ret);
 
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
old mode 100644
new mode 100755
index f1971eb..d32299f
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -655,7 +655,7 @@ static struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)
 static void init_slave(int cpu)
 {
 	struct qman_portal *p;
-	struct cpumask oldmask = *tsk_cpus_allowed(current);
+	struct cpumask oldmask = current->cpus_allowed;
 	set_cpus_allowed_ptr(current, get_cpu_mask(cpu));
 	p = qman_create_affine_slave(shared_portals[shared_portals_idx++], cpu);
 	if (!p)
@@ -703,7 +703,7 @@ static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
 #endif
 }
 
-static void qman_offline_cpu(unsigned int cpu)
+static int qman_offline_cpu(unsigned int cpu)
 {
 	struct qman_portal *p;
 	const struct qm_portal_config *pcfg;
@@ -715,10 +715,11 @@ static void qman_offline_cpu(unsigned int cpu)
 			qman_portal_update_sdest(pcfg, 0);
 		}
 	}
+	return 0;
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
-static void qman_online_cpu(unsigned int cpu)
+static int qman_online_cpu(unsigned int cpu)
 {
 	struct qman_portal *p;
 	const struct qm_portal_config *pcfg;
@@ -730,30 +731,9 @@ static void qman_online_cpu(unsigned int cpu)
 			qman_portal_update_sdest(pcfg, cpu);
 		}
 	}
+	return 0;
 }
 
-static int qman_hotplug_cpu_callback(struct notifier_block *nfb,
-				unsigned long action, void *hcpu)
-{
-	unsigned int cpu = (unsigned long)hcpu;
-
-	switch (action) {
-	case CPU_ONLINE:
-	case CPU_ONLINE_FROZEN:
-		qman_online_cpu(cpu);
-		break;
-	case CPU_DOWN_PREPARE:
-	case CPU_DOWN_PREPARE_FROZEN:
-		qman_offline_cpu(cpu);
-	default:
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block qman_hotplug_cpu_notifier = {
-	.notifier_call = qman_hotplug_cpu_callback,
-};
 #endif /* CONFIG_HOTPLUG_CPU */
 
 __init int qman_init(void)
@@ -903,7 +883,13 @@ __init int qman_init(void)
 	for_each_cpu(cpu, &offline_cpus)
 		qman_offline_cpu(cpu);
 #ifdef CONFIG_HOTPLUG_CPU
-	register_hotcpu_notifier(&qman_hotplug_cpu_notifier);
+	ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					"soc/qman_portal:online",
+					qman_online_cpu, qman_offline_cpu);
+	if (ret < 0) {
+		pr_err("qman: failed to register hotplug callbacks.\n");
+		return ret;
+	}
 #endif
 	return 0;
 }
-- 
2.7.4


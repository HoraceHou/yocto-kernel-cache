From 0d01b6e60126e4d57f031d1fdb9d9c6c88597cbb Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@nxp.com>
Date: Wed, 27 Jan 2016 10:28:37 +0800
Subject: [PATCH 098/666] mmc: sdhci-of-esdhc: add eMMC DDR mode support

The eSDHC is not the standard SD host controller of SD spec. To
support eMMC DDR mode, a Freescale eMMC4.4 adapter card will be
used for hardware support and the peripheral clock will be used
instead of the platform clock. The driver should define an esdhc-
specific esdhc_set_uhs_signaling() and esdhc_signal_voltage_switch()
functions for its speed mode switching and signal voltage switching.

Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc.h    |   9 ++
 drivers/mmc/host/sdhci-of-esdhc.c | 179 +++++++++++++++++++++++++++++++++++++-
 drivers/mmc/host/sdhci.c          |   5 ++
 drivers/mmc/host/sdhci.h          |   2 +
 4 files changed, 191 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index c4bbd74..1561fd3 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -35,6 +35,15 @@
 #define ESDHC_PRSSTAT			0x24
 #define ESDHC_CLOCK_STABLE		0x00000008
 
+#define ESDHC_CAPABILITIES_1		0x114
+#define ESDHC_SPEED_MODE_MASK		0x00000007
+#define ESDHC_SPEED_MODE_DDR50		0x00000004
+#define ESDHC_SPEED_MODE_DDR50_SEL	0xfffffffc
+
+#define ESDHC_CLOCK_CONTROL	0x144
+#define ESDHC_LPBK_CLK_SEL	0x80000000
+#define ESDHC_CMD_CLK_CTL	0x00008000
+
 /* Protocol Control Register */
 #define ESDHC_PROCTL			0x28
 #define ESDHC_VOLT_SEL			0x00000400
diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index 96e6f2a..28251d9 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -31,11 +31,21 @@
 #define VENDOR_V_22	0x12
 #define VENDOR_V_23	0x13
 
+/* eSDHC Adapter Card Type */
+#define ESDHC_ADAPTER_TYPE_EMMC45	0x1	/* eMMC Card Rev4.5 */
+#define ESDHC_ADAPTER_TYPE_SDMMC_LEGACY	0x2	/* SD/MMC Legacy Card */
+#define ESDHC_ADAPTER_TYPE_EMMC44	0x3	/* eMMC Card Rev4.4 */
+#define ESDHC_ADAPTER_TYPE_RSV		0x4	/* Reserved */
+#define ESDHC_ADAPTER_TYPE_MMC		0x5	/* MMC Card */
+#define ESDHC_ADAPTER_TYPE_SD		0x6	/* SD Card Rev2.0 3.0 */
+#define ESDHC_NO_ADAPTER		0x7	/* No Card is Present*/
+
 struct sdhci_esdhc {
 	u8 vendor_ver;
 	u8 spec_ver;
 	u32 soc_ver;
 	u8 soc_rev;
+	u8 adapter_type;
 	bool quirk_incorrect_hostver;
 	unsigned int peripheral_clock;
 };
@@ -76,6 +86,22 @@ static u32 esdhc_readl_fixup(struct sdhci_host *host,
 			return ret;
 		}
 	}
+
+	if (spec_reg == SDHCI_CAPABILITIES_1) {
+		switch (esdhc->adapter_type) {
+		case ESDHC_ADAPTER_TYPE_EMMC44:
+			if (value & ESDHC_SPEED_MODE_DDR50) {
+				ret = value & ESDHC_SPEED_MODE_DDR50_SEL;
+				/* enable 1/8V DDR capable */
+				host->mmc->caps |= MMC_CAP_1_8V_DDR;
+				return ret;
+			}
+			break;
+		}
+		ret = value & (~ESDHC_SPEED_MODE_MASK);
+		return ret;
+	}
+
 	/*
 	 * The DAT[3:0] line signal levels and the CMD line signal level are
 	 * not compatible with standard SDHC register. The line signal levels
@@ -241,6 +267,8 @@ static u32 esdhc_writeb_fixup(struct sdhci_host *host,
 
 		/* Prevent SDHCI core from writing reserved bits (e.g. HISPD) */
 		ret &= ~ESDHC_HOST_CONTROL_RES;
+		ret &= ~SDHCI_CTRL_HISPD;
+		ret |= (old_value & SDHCI_CTRL_HISPD);
 		return ret;
 	}
 
@@ -253,7 +281,15 @@ static u32 esdhc_be_readl(struct sdhci_host *host, int reg)
 	u32 ret;
 	u32 value;
 
-	value = ioread32be(host->ioaddr + reg);
+	/*
+	 * The eSDHC CAPABILITIES_1 register has a large address offset
+	 * from the standard CAPABILITIES_1 register. So, we have to
+	 * fix this here rather than in fixup function.
+	 */
+	if (reg == SDHCI_CAPABILITIES_1)
+		value = ioread32be(host->ioaddr + ESDHC_CAPABILITIES_1);
+	else
+		value = ioread32be(host->ioaddr + reg);
 	ret = esdhc_readl_fixup(host, reg, value);
 
 	return ret;
@@ -264,7 +300,15 @@ static u32 esdhc_le_readl(struct sdhci_host *host, int reg)
 	u32 ret;
 	u32 value;
 
-	value = ioread32(host->ioaddr + reg);
+	/*
+	 * The eSDHC CAPABILITIES_1 register has a large address offset
+	 * from the standard CAPABILITIES_1 register. So, we have to
+	 * fix this here rather than in fixup function.
+	 */
+	if (reg == SDHCI_CAPABILITIES_1)
+		value = ioread32(host->ioaddr + ESDHC_CAPABILITIES_1);
+	else
+		value = ioread32(host->ioaddr + reg);
 	ret = esdhc_readl_fixup(host, reg, value);
 
 	return ret;
@@ -775,6 +819,109 @@ static SIMPLE_DEV_PM_OPS(esdhc_of_dev_pm_ops,
 			esdhc_of_suspend,
 			esdhc_of_resume);
 
+static void esdhc_clock_control(struct sdhci_host *host, bool enable)
+{
+	u32 val;
+	u32 timeout;
+
+	val = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
+
+	if (enable)
+		val |= ESDHC_CLOCK_CRDEN;
+	else
+		val &= ~ESDHC_CLOCK_CRDEN;
+
+	sdhci_writel(host, val, ESDHC_SYSTEM_CONTROL);
+
+	timeout = 20;
+	val = ESDHC_CLOCK_STABLE;
+	while (!(sdhci_readl(host, ESDHC_PRESENT_STATE) & val)) {
+		if (timeout == 0) {
+			pr_err("%s: Internal clock never stabilised.\n",
+				mmc_hostname(host->mmc));
+			break;
+		}
+		timeout--;
+		mdelay(1);
+	}
+}
+
+static void esdhc_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
+{
+	u16 ctrl_2;
+	u32 val;
+	u32 timeout;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	if ((uhs == MMC_TIMING_MMC_HS200) ||
+		(uhs == MMC_TIMING_UHS_SDR104))
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+	else if (uhs == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (uhs == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if (uhs == MMC_TIMING_UHS_SDR50)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((uhs == MMC_TIMING_UHS_DDR50) ||
+		 (uhs == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (uhs == MMC_TIMING_MMC_HS400)
+		ctrl_2 |= SDHCI_CTRL_HS400; /* Non-standard */
+
+	if ((uhs == MMC_TIMING_UHS_DDR50) ||
+	    (uhs == MMC_TIMING_MMC_DDR52)) {
+		esdhc_clock_control(host, false);
+		sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+		val = sdhci_readl(host, ESDHC_CLOCK_CONTROL);
+		val |= (ESDHC_LPBK_CLK_SEL | ESDHC_CMD_CLK_CTL);
+		sdhci_writel(host, val, ESDHC_CLOCK_CONTROL);
+		esdhc_clock_control(host, true);
+
+		esdhc_clock_control(host, false);
+		val = sdhci_readl(host, ESDHC_DMA_SYSCTL);
+		val |= ESDHC_FLUSH_ASYNC_FIFO;
+		sdhci_writel(host, val, ESDHC_DMA_SYSCTL);
+		/* Wait max 20 ms */
+		timeout = 20;
+		val = ESDHC_FLUSH_ASYNC_FIFO;
+		while (sdhci_readl(host, ESDHC_DMA_SYSCTL) & val) {
+			if (timeout == 0) {
+				pr_err("%s: FAF bit is auto cleaned failed.\n",
+					mmc_hostname(host->mmc));
+
+				break;
+			}
+			timeout--;
+			mdelay(1);
+		}
+		esdhc_clock_control(host, true);
+	} else
+		sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+void esdhc_signal_voltage_switch(struct sdhci_host *host,
+				 unsigned char signal_voltage)
+{
+	u32 val;
+
+	val = sdhci_readl(host, ESDHC_PROCTL);
+
+	switch (signal_voltage) {
+	case MMC_SIGNAL_VOLTAGE_330:
+		val &= (~ESDHC_VOLT_SEL);
+		sdhci_writel(host, val, ESDHC_PROCTL);
+		break;
+	case MMC_SIGNAL_VOLTAGE_180:
+		val |= ESDHC_VOLT_SEL;
+		sdhci_writel(host, val, ESDHC_PROCTL);
+		break;
+	default:
+		return;
+	}
+}
+
 static const struct sdhci_ops sdhci_esdhc_be_ops = {
 	.read_l = esdhc_be_readl,
 	.read_w = esdhc_be_readw,
@@ -789,7 +936,8 @@ static const struct sdhci_ops sdhci_esdhc_be_ops = {
 	.adma_workaround = esdhc_of_adma_workaround,
 	.set_bus_width = esdhc_pltfm_set_bus_width,
 	.reset = esdhc_reset,
-	.set_uhs_signaling = sdhci_set_uhs_signaling,
+	.set_uhs_signaling = esdhc_set_uhs_signaling,
+	.signal_voltage_switch = esdhc_signal_voltage_switch,
 };
 
 static const struct sdhci_ops sdhci_esdhc_le_ops = {
@@ -806,7 +954,8 @@ static const struct sdhci_ops sdhci_esdhc_le_ops = {
 	.adma_workaround = esdhc_of_adma_workaround,
 	.set_bus_width = esdhc_pltfm_set_bus_width,
 	.reset = esdhc_reset,
-	.set_uhs_signaling = sdhci_set_uhs_signaling,
+	.set_uhs_signaling = esdhc_set_uhs_signaling,
+	.signal_voltage_switch = esdhc_signal_voltage_switch,
 };
 
 static const struct sdhci_pltfm_data sdhci_esdhc_be_pdata = {
@@ -837,6 +986,8 @@ static void esdhc_init(struct platform_device *pdev, struct sdhci_host *host)
 	struct sdhci_pltfm_host *pltfm_host;
 	struct sdhci_esdhc *esdhc;
 	struct device_node *np;
+	const __be32 *val;
+	int size;
 	struct clk *clk;
 	u32 val;
 	u16 host_ver;
@@ -859,6 +1010,15 @@ static void esdhc_init(struct platform_device *pdev, struct sdhci_host *host)
 		esdhc->quirk_incorrect_hostver = false;
 
 	np = pdev->dev.of_node;
+
+	val = of_get_property(np, "adapter-type", &size);
+	if (val && size == sizeof(*val) && *val)
+		esdhc->adapter_type = be32_to_cpup(val);
+
+	val = of_get_property(np, "peripheral-frequency", &size);
+	if (val && size == sizeof(*val) && *val)
+		esdhc->peripheral_clock = be32_to_cpup(val);
+
 	clk = of_clk_get(np, 0);
 	if (!IS_ERR(clk)) {
 		/*
@@ -892,6 +1052,7 @@ static int sdhci_esdhc_probe(struct platform_device *pdev)
 	struct sdhci_pltfm_host *pltfm_host;
 	struct sdhci_esdhc *esdhc;
 	int ret;
+	u32 val;
 
 	np = pdev->dev.of_node;
 
@@ -951,6 +1112,16 @@ static int sdhci_esdhc_probe(struct platform_device *pdev)
 
 	mmc_of_parse_voltage(np, &host->ocr_mask);
 
+	/* Select peripheral clock as the eSDHC clock */
+	if (esdhc->peripheral_clock) {
+		pltfm_host->clock = esdhc->peripheral_clock;
+		esdhc_clock_control(host, false);
+		val = sdhci_readl(host, ESDHC_DMA_SYSCTL);
+		val |= ESDHC_PERIPHERAL_CLK_SEL;
+		sdhci_writel(host, val, ESDHC_DMA_SYSCTL);
+		esdhc_clock_control(host, true);
+	}
+
 	ret = sdhci_add_host(host);
 	if (ret)
 		goto err;
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index c6c9654..b425543 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1871,6 +1871,11 @@ int sdhci_start_signal_voltage_switch(struct mmc_host *mmc,
 	if (host->version < SDHCI_SPEC_300)
 		return 0;
 
+	if (host->ops->signal_voltage_switch) {
+		host->ops->signal_voltage_switch(host, ios->signal_voltage);
+		return 0;
+	}
+
 	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 
 	switch (ios->signal_voltage) {
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 0469fa1..a34c61d 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -579,6 +579,8 @@ struct sdhci_ops {
 	void    (*adma_workaround)(struct sdhci_host *host, u32 intmask);
 	void    (*card_event)(struct sdhci_host *host);
 	void	(*voltage_switch)(struct sdhci_host *host);
+	void	(*signal_voltage_switch)(struct sdhci_host *host,
+					 unsigned char signal_voltage);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
-- 
2.7.4


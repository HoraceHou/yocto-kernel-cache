From d99457152915976815b173d15c969022b9456d42 Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@nxp.com>
Date: Wed, 27 Jan 2016 16:13:11 +0800
Subject: [PATCH 099/666] mmc: sdhci-of-esdhc: add eMMC HS200 mode support

The eSDHC is not the standard SD host controller of SD spec. To
support eMMC HS200 mode, a Freescale eMMC4.5 adapter card will be
used for hardware support and the peripheral clock will be used
instead of the platform clock. The driver should also define an
esdhc-specific esdhc_set_tuning_block() function for its tuning
process.

Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc.h    |  4 ++++
 drivers/mmc/host/sdhci-of-esdhc.c | 23 +++++++++++++++++++++++
 drivers/mmc/host/sdhci.c          |  5 ++++-
 drivers/mmc/host/sdhci.h          |  3 +++
 4 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index 1561fd3..890fb8a 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -38,8 +38,12 @@
 #define ESDHC_CAPABILITIES_1		0x114
 #define ESDHC_SPEED_MODE_MASK		0x00000007
 #define ESDHC_SPEED_MODE_DDR50		0x00000004
+#define ESDHC_SPEED_MODE_SDR104		0x00000002
 #define ESDHC_SPEED_MODE_DDR50_SEL	0xfffffffc
 
+#define ESDHC_TBCTL		0x120
+#define ESDHC_TB_EN		0x00000004
+
 #define ESDHC_CLOCK_CONTROL	0x144
 #define ESDHC_LPBK_CLK_SEL	0x80000000
 #define ESDHC_CMD_CLK_CTL	0x00008000
diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index 28251d9..6ed3470 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -89,6 +89,10 @@ static u32 esdhc_readl_fixup(struct sdhci_host *host,
 
 	if (spec_reg == SDHCI_CAPABILITIES_1) {
 		switch (esdhc->adapter_type) {
+		case ESDHC_ADAPTER_TYPE_EMMC45:
+			if (value & ESDHC_SPEED_MODE_SDR104)
+				host->mmc->caps2 |= MMC_CAP2_HS200;
+			break;
 		case ESDHC_ADAPTER_TYPE_EMMC44:
 			if (value & ESDHC_SPEED_MODE_DDR50) {
 				ret = value & ESDHC_SPEED_MODE_DDR50_SEL;
@@ -922,6 +926,21 @@ void esdhc_signal_voltage_switch(struct sdhci_host *host,
 	}
 }
 
+void esdhc_set_tuning_block(struct sdhci_host *host)
+{
+	u32 val;
+
+	esdhc_clock_control(host, false);
+	val = sdhci_readl(host, ESDHC_DMA_SYSCTL);
+	val |= ESDHC_FLUSH_ASYNC_FIFO;
+	sdhci_writel(host, val, ESDHC_DMA_SYSCTL);
+
+	val = sdhci_readl(host, ESDHC_TBCTL);
+	val |= ESDHC_TB_EN;
+	sdhci_writel(host, val, ESDHC_TBCTL);
+	esdhc_clock_control(host, true);
+}
+
 static const struct sdhci_ops sdhci_esdhc_be_ops = {
 	.read_l = esdhc_be_readl,
 	.read_w = esdhc_be_readw,
@@ -938,6 +957,7 @@ static const struct sdhci_ops sdhci_esdhc_be_ops = {
 	.reset = esdhc_reset,
 	.set_uhs_signaling = esdhc_set_uhs_signaling,
 	.signal_voltage_switch = esdhc_signal_voltage_switch,
+	.set_tuning_block = esdhc_set_tuning_block,
 };
 
 static const struct sdhci_ops sdhci_esdhc_le_ops = {
@@ -956,6 +976,7 @@ static const struct sdhci_ops sdhci_esdhc_le_ops = {
 	.reset = esdhc_reset,
 	.set_uhs_signaling = esdhc_set_uhs_signaling,
 	.signal_voltage_switch = esdhc_signal_voltage_switch,
+	.set_tuning_block = esdhc_set_tuning_block,
 };
 
 static const struct sdhci_pltfm_data sdhci_esdhc_be_pdata = {
@@ -1083,6 +1104,8 @@ static int sdhci_esdhc_probe(struct platform_device *pdev)
 	if (esdhc->vendor_ver > VENDOR_V_22)
 		host->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;
 
+	host->quirks2 |= SDHCI_QUIRK2_DELAY_BETWEEN_TUNING_CYCLES;
+
 	if (of_device_is_compatible(np, "fsl,p5040-esdhc") ||
 	    of_device_is_compatible(np, "fsl,p5020-esdhc") ||
 	    of_device_is_compatible(np, "fsl,p4080-esdhc") ||
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index b425543..51e856f 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2108,6 +2108,8 @@ static void __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
 			sdhci_abort_tuning(host, opcode);
 			return;
 		}
+		if (host->ops->set_tuning_block)
+			host->ops->set_tuning_block(host);
 
 		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 		if (!(ctrl & SDHCI_CTRL_EXEC_TUNING)) {
@@ -2117,7 +2119,8 @@ static void __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
 		}
 
 		/* Spec does not require a delay between tuning cycles */
-		if (host->tuning_delay > 0)
+		if ((opcode == MMC_SEND_TUNING_BLOCK) ||
+		    (host->quirks2 & SDHCI_QUIRK2_DELAY_BETWEEN_TUNING_CYCLES))
 			mdelay(host->tuning_delay);
 	}
 
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index a34c61d..ce6c4ca 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -435,6 +435,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_ACMD23_BROKEN			(1<<14)
 /* Broken Clock divider zero in controller */
 #define SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN		(1<<15)
+/*Controller needs delay between tuning cycles */
+#define SDHCI_QUIRK2_DELAY_BETWEEN_TUNING_CYCLES	(1<<16)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
@@ -581,6 +583,7 @@ struct sdhci_ops {
 	void	(*voltage_switch)(struct sdhci_host *host);
 	void	(*signal_voltage_switch)(struct sdhci_host *host,
 					 unsigned char signal_voltage);
+	void	(*set_tuning_block)(struct sdhci_host *host);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
-- 
2.7.4


From ffff1f4e0e487ae84e158fab77fa0341326a2fc4 Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Sun, 22 Jan 2017 22:56:25 +0800
Subject: [PATCH 0776/1345] uart: a3700: add TX interrupt trigger for pulse
 interrupt

commit  d3e395cd339dac631f3f2abe915edd58b2e479cf from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- For pulse interrupt, it needs the change of state to trigger
  the TX interrupt. In addition to enable the TX_READY_INT_EN, it
  also needs the FIFO state change from empty to not full or change
  from full to not full.
- In the case of FIFO state change from empty to not full, this
  patch will write only one byte data in TX start, making the
  TX FIFO not empty, and wait for the TX interrupt to continue
  the following transfers.
- In the other case of FIFO state change from full to not full,
  this patch remove the TX bytes limitation against fifo size,
  making the FIFO state reaching full state, and wait for the
  TX interrupt to continue the following transfers.

Change-Id: I78871a16062be6d19b64820433042c347e4c5f61
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35861
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/mvebu-uart.c |   11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index 21c1fc7..5fa7bcd 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -299,7 +299,15 @@ static void mvebu_uart_start_tx(struct uart_port *port)
 {
 	unsigned int ctl;
 	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
+	struct circ_buf *xmit = &port->state->xmit;
 
+	if (!IS_ERR_OR_NULL(uart_data->intr.uart_int_base)) {
+		if (!uart_circ_empty(xmit)) {
+			writel(xmit->buf[xmit->tail], port->membase + REG_TSH(uart_data));
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+		}
+	}
 	ctl = readl(port->membase + uart_data->intr.ctrl_reg);
 	ctl |= uart_data->reg_bits.ctrl_tx_rdy_int(uart_data);
 	writel(ctl, port->membase + uart_data->intr.ctrl_reg);
@@ -401,7 +409,6 @@ static void mvebu_uart_rx_chars(struct uart_port *port, unsigned int status)
 static void mvebu_uart_tx_chars(struct uart_port *port, unsigned int status)
 {
 	struct circ_buf *xmit = &port->state->xmit;
-	unsigned int count;
 	unsigned int st;
 	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
 
@@ -417,7 +424,7 @@ static void mvebu_uart_tx_chars(struct uart_port *port, unsigned int status)
 		return;
 	}
 
-	for (count = 0; count < port->fifosize; count++) {
+	for (;;) {
 		writel(xmit->buf[xmit->tail], port->membase + REG_TSH(uart_data));
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
-- 
1.7.9.5


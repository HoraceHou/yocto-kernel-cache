From f13e07780c5c563448cae343394c599649897fea Mon Sep 17 00:00:00 2001
From: Terry Zhou <bjzhou@marvell.com>
Date: Wed, 26 Jul 2017 09:25:34 +0300
Subject: [PATCH 1098/1345] Revert "fix: usb: add new state to avoid infinite
 interrupts in dynamic mode"

commit  4b0d3480e3c797934dc65b0802dc9995db5bb941 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This reverts 'commit 6064a006e636
("fix: usb: add new state to avoid infinite interrupts in dynamic mode")'.

The above commit instends to handle the unexpected USB controller status
when USB (type-C to type-A) cable is only connected to Armada3700 via a
Pericom USB switch (e.g., PI5USB30213 applied to DB-88F3720-DDR-Modular
board).
However, the issue is actually caused by the non-complicant cable. As it
is addressed in PI5USB30213 datasheet:

CC voltage depends on Rp value between VBUS-CC inside the PC cable (CC=
0.4 if Rp=56Kohm). Therefore, the only compliant cable is  Rp=56K while
Rp=10K,20K are used for Type-C device only.

Change-Id: Ia408f9887a3b2c83c2ce01ab25dbfd3c1acd6dfd
Reviewed-on: http://vgitil04.il.marvell.com:8080/42167
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/phy/phy-a3700-usb.c |   17 +----------------
 1 file changed, 1 insertion(+), 16 deletions(-)

diff --git a/drivers/usb/phy/phy-a3700-usb.c b/drivers/usb/phy/phy-a3700-usb.c
index 402df1a..e44d42a 100644
--- a/drivers/usb/phy/phy-a3700-usb.c
+++ b/drivers/usb/phy/phy-a3700-usb.c
@@ -53,7 +53,6 @@ enum port_status {
 	USB_PORT_IDLE,
 	USB_HOST_ATTACHED,
 	USB_DEVICE_ATTACHED,
-	USB_BOUNCING,
 };
 
 enum usb_mode {
@@ -230,10 +229,6 @@ static void a3700_otg_work(struct work_struct *work)
 			a3700_otg_start_periphrals(mvotg, 0);
 		}
 		break;
-	case USB_BOUNCING:
-		if (mvotg->port_state == USB_PORT_IDLE)
-			dev_dbg(mvotg->dev, "moving to idle mode\n");
-		break;
 	default:
 		dev_dbg(mvotg->dev, "wrong state.\n");
 		break;
@@ -358,17 +353,12 @@ static irqreturn_t a3700_usb_id_isr(int irq, void *data)
 	switch (mvotg->port_state) {
 	case USB_PORT_IDLE:
 		dev_dbg(mvotg->dev, "current state USB_PORT_IDLE!\n");
-		if (test_bit(USB_HOST_MODE_ACT_OFF, reg_val)
-			&& !test_bit(USB_HOST_MODE_DEACT_OFF, reg_val)
-			&& (usb_id == USB_ID_HOST)) {
+		if (test_bit(USB_HOST_MODE_ACT_OFF, reg_val) && (usb_id == USB_ID_HOST)) {
 			mvotg->port_state = USB_HOST_ATTACHED;
 		} else if (test_bit(USB_DEVICE_MODE_ACT_OFF, reg_val)
 			&& !test_bit(USB_DEVICE_MODE_DEACT_OFF, reg_val)
 			&& usb_id == USB_ID_DEVICE) {
 			mvotg->port_state = USB_DEVICE_ATTACHED;
-		} else if (test_bit(USB_DEVICE_MODE_ACT_OFF, reg_val)
-			&& test_bit(USB_DEVICE_MODE_DEACT_OFF, reg_val)) {
-			mvotg->port_state = USB_BOUNCING;
 		}
 		break;
 	case USB_HOST_ATTACHED:
@@ -381,11 +371,6 @@ static irqreturn_t a3700_usb_id_isr(int irq, void *data)
 		if (test_bit(USB_DEVICE_MODE_DEACT_OFF, reg_val))
 			mvotg->port_state = USB_PORT_IDLE;
 		break;
-	case USB_BOUNCING:
-		dev_dbg(mvotg->dev, "current state USB_BOUNCING!\n");
-		if (test_bit(USB_HOST_MODE_DEACT_OFF, reg_val))
-			mvotg->port_state = USB_PORT_IDLE;
-		break;
 	default:
 		dev_err(mvotg->dev, "Unknown state found!\n");
 		break;
-- 
1.7.9.5


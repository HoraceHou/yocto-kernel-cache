From 7c14d8c207dd73144c6d41ef4d72e86fdb1509b0 Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Tue, 7 Mar 2017 21:52:44 +0800
Subject: [PATCH 0815/1345] uart: a3700: save and restore uart registers for
 low power mode

commit  52da48fd5240d3cbb418dfbe5a721792950f83f3 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- In the original uart driver, it doesn't save the uart
  registers status before system suspend and it also
  doesn't restore the uart registers status after system
  resume. It may cause the uart ports can't work properly.
  This patch  add the uart registers save and restore
  in suspend and resume function and the uart ports can
  work well.
- This patch add uart_int_type to save the settings of the
  uart's interrupts trigger type and restore it after resume.
- This patch use uart_over_sample to restore the Progammable
  Oversampling Stack register which was setted in U-BOOT. It
  needs to restore because it will be changed after suspend
  and resume, but uart default use 16X scheme. If doesn't
  restore it, the baudrate settings will be affected.

Change-Id: I3c39223eeb4ff550e3c58a476fbec67aee988669
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37254
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/mvebu-uart.c |   55 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index bd03df2..3119d7e 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -49,6 +49,7 @@ struct uart_regs_layout {
 	unsigned int uart_tsh;
 	unsigned int uart_brdv;
 	unsigned int uart_stat;
+	unsigned int uart_over_sample;
 };
 /* Register Map */
 
@@ -104,6 +105,8 @@ struct uart_regs_layout {
 #define  BAUD_MASK		0x000003ff
 #define  BAUD_OFFSET		0
 
+#define UART_OSAMP		0x14
+
 /* REG_UART_A3700_EXT */
 #define UART_EXT_CTRL		0x04
 
@@ -113,6 +116,8 @@ struct uart_regs_layout {
 
 #define UART_EXT_BRDV		0x10
 
+#define UART_EXT_OSAMP		0x14
+
 #define UART_EXT_RBR_1BYTE	0x18
 
 #define UART_EXT_TSH_1BYTE	0x1c
@@ -148,6 +153,7 @@ struct uart_regs_layout {
 		.uart_tsh  = UART_TSH,
 		.uart_brdv = UART_BRDV,
 		.uart_stat = UART_STAT,
+		.uart_over_sample = UART_OSAMP,
 	},
 	[REG_UART_A3700_EXT] = {
 		.uart_ctrl  = UART_EXT_CTRL,
@@ -156,6 +162,7 @@ struct uart_regs_layout {
 		.uart_tsh   = UART_EXT_TSH_1BYTE,
 		.uart_brdv  = UART_EXT_BRDV,
 		.uart_stat  = UART_EXT_STAT,
+		.uart_over_sample = UART_EXT_OSAMP,
 	},
 };
 
@@ -172,6 +179,13 @@ struct mvebu_uart_data {
 	struct uart_regs_layout *regs;
 	enum reg_uart_type       reg_type;
 
+#ifdef CONFIG_PM
+	/* Used to restore the uart registers status*/
+	struct uart_regs_layout pm_reg_value;
+	/* Used to restore the uart interrupt type */
+	unsigned int		uart_ext_int_type;
+#endif
+
 	struct {
 		unsigned int (*ctrl_rx_rdy_int)(struct mvebu_uart_data *data);
 		unsigned int (*ctrl_tx_rdy_int)(struct mvebu_uart_data *data);
@@ -205,6 +219,8 @@ struct mvebu_uart_data {
 #define REG_TSH(uart_data)	((uart_data)->regs->uart_tsh)
 #define REG_BRDV(uart_data)	((uart_data)->regs->uart_brdv)
 #define REG_STAT(uart_data)	((uart_data)->regs->uart_stat)
+#define REG_OSAMP(uart_data)	((uart_data)->regs->uart_over_sample)
+
 
 /* helper functions for 1-byte transfer */
 static inline unsigned int get_ctrl_rx_1byte_rdy_int(struct mvebu_uart_data *data)
@@ -981,10 +997,47 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
+
+/* Uart registers status save in suspend process*/
+static int mvebu_uart_reg_save(struct mvebu_uart_data *data)
+{
+	data->pm_reg_value.uart_ctrl = readl(data->port->membase + REG_CTRL(data));
+
+	if (data->reg_type == REG_UART_A3700_EXT)
+		data->pm_reg_value.uart_ctrl2 = readl(data->port->membase + REG_CTRL2(data));
+
+	data->pm_reg_value.uart_tsh = readl(data->port->membase + REG_TSH(data));
+	data->pm_reg_value.uart_brdv = readl(data->port->membase + REG_BRDV(data));
+	data->pm_reg_value.uart_over_sample = readl(data->port->membase + REG_OSAMP(data));
+	if (!IS_ERR_OR_NULL(data->intr.uart_int_base))
+		data->uart_ext_int_type = readl(data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_SEL);
+
+	return 0;
+}
+
+/* Uart registers status restore in resume process*/
+static int mvebu_uart_reg_restore(struct mvebu_uart_data *data)
+{
+	writel(data->pm_reg_value.uart_ctrl, data->port->membase + REG_CTRL(data));
+
+	if (data->reg_type == REG_UART_A3700_EXT)
+		writel(data->pm_reg_value.uart_ctrl2, data->port->membase + REG_CTRL2(data));
+
+	writel(data->pm_reg_value.uart_tsh, data->port->membase + REG_TSH(data));
+	writel(data->pm_reg_value.uart_brdv, data->port->membase + REG_BRDV(data));
+	writel(data->pm_reg_value.uart_over_sample, data->port->membase + REG_OSAMP(data));
+	if (!IS_ERR_OR_NULL(data->intr.uart_int_base))
+		writel(data->uart_ext_int_type, data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_SEL);
+
+	return 0;
+}
+
 static int mvebu_uart_suspend(struct device *dev)
 {
 	struct mvebu_uart_data *data = dev_get_drvdata(dev);
 
+	mvebu_uart_reg_save(data);
+
 	if (data->port)
 		uart_suspend_port(&mvebu_uart_driver, data->port);
 
@@ -997,6 +1050,8 @@ static int mvebu_uart_resume(struct device *dev)
 {
 	struct mvebu_uart_data *data = dev_get_drvdata(dev);
 
+	mvebu_uart_reg_restore(data);
+
 	if (data->port)
 		uart_resume_port(&mvebu_uart_driver, data->port);
 
-- 
1.7.9.5


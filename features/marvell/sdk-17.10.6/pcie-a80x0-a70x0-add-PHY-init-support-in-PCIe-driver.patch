From 560373bd8e20ab9e5b21fb595be023a1b349e98a Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Fri, 16 Jun 2017 15:22:12 +0800
Subject: [PATCH 1154/1345] pcie: a80x0: a70x0: add PHY init support in PCIe
 driver

commit  47cf94b92055bb0fb51e65373cf79992f9241dc4 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

On A7/8K, the PCIe support X1, X2 and X4 and currently
the PHY depends on uboot initialization. In order to
cut off the dependency on uboot, the kernel driver
needs to support upto 4 PHYs initialization.

The patch added the PHY initialization when PCIe probe:
1) Parse the PHY connection to PCIe port from DTB file
2) Transfer the PCIe width via PHY command
3) Call callback function of PHY init and power on to
  initialize relevant COMPHY lanes. Currently it only
  supports PCIe RC mode.

Change-Id: I80bdb3e6a18dc350ab4241867b2341253eaea39b
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/40540
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Tested-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/host/pcie-armada8k.c |   75 +++++++++++++++++++++++++++++---------
 1 file changed, 57 insertions(+), 18 deletions(-)

diff --git a/drivers/pci/host/pcie-armada8k.c b/drivers/pci/host/pcie-armada8k.c
index 304a3b6..3d5c6d0 100644
--- a/drivers/pci/host/pcie-armada8k.c
+++ b/drivers/pci/host/pcie-armada8k.c
@@ -22,12 +22,14 @@
 #include <linux/resource.h>
 #include <linux/of_pci.h>
 #include <linux/of_irq.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
 
 #include "pcie-designware.h"
 
 struct armada8k_pcie {
 	void __iomem		*regs_base;
-	struct phy		*phy;
+	struct phy		**phys;
+	int			phy_count;
 	struct clk		*clk;
 	struct pcie_port	pp;
 };
@@ -231,8 +233,12 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 {
 	struct armada8k_pcie *armada8k_pcie;
 	struct pcie_port *pp;
+	struct phy **phys = NULL;
 	struct device *dev = &pdev->dev;
 	struct resource *base;
+	int i, phy_count = 0;
+	u32 command;
+	char phy_name[16];
 	int ret = 0;
 
 	armada8k_pcie = devm_kzalloc(dev, sizeof(*armada8k_pcie), GFP_KERNEL);
@@ -245,26 +251,54 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 
 	clk_prepare_enable(armada8k_pcie->clk);
 
-#if 0
-	/* Keep this code commented out till we write a PHY driver for
-	** armada-8k PCIe PHY. */
-	armada8k_pcie->phy = devm_phy_get(dev, "pcie-phy");
-	if (IS_ERR(armada8k_pcie->phy)) {
-		ret = PTR_ERR(armada8k_pcie->phy);
-		if (ret == -EPROBE_DEFER)
-			dev_info(dev, "probe deferred\n");
-		else
-			dev_err(dev, "couldn't get pcie-phy\n");
-
-		goto fail_free;
+	/* Get PHY count according to phy name */
+	phy_count = of_property_count_strings(pdev->dev.of_node, "phy-names");
+	if (phy_count > 0) {
+		phys = devm_kzalloc(dev, sizeof(*phys) * phy_count, GFP_KERNEL);
+		if (!phys)
+			return -ENOMEM;
+
+		for (i = 0; i < phy_count; i++) {
+			snprintf(phy_name, sizeof(phy_name), "pcie-phy%d", i);
+			phys[i] = devm_phy_get(dev, phy_name);
+			if (IS_ERR(phys[i]))
+				goto err_phy;
+
+			/* Tell COMPHY the PCIE width based on phy command,
+			 * and in PHY command callback, the width will be
+			 * checked for its validation.
+			 */
+			switch (phy_count) {
+			case PCIE_LNK_X1:
+				command = COMPHY_COMMAND_PCIE_WIDTH_1;
+				break;
+			case PCIE_LNK_X2:
+				command = COMPHY_COMMAND_PCIE_WIDTH_2;
+				break;
+			case PCIE_LNK_X4:
+				command = COMPHY_COMMAND_PCIE_WIDTH_4;
+				break;
+			default:
+				command = COMPHY_COMMAND_PCIE_WIDTH_UNSUPPORT;
+			}
+			phy_send_command(phys[i], command);
+
+			ret = phy_init(phys[i]);
+			if (ret < 0)
+				goto err_phy;
+
+			ret = phy_power_on(phys[i]);
+			if (ret < 0) {
+				phy_exit(phys[i]);
+				goto err_phy;
+			}
+		}
 	}
 
-	phy_init(armada8k_pcie->phy);
-#endif
-
 	pp = &armada8k_pcie->pp;
-
 	pp->dev = dev;
+	armada8k_pcie->phys = phys;
+	armada8k_pcie->phy_count = phy_count;
 	platform_set_drvdata(pdev, armada8k_pcie);
 
 	/* Get the dw-pcie unit configuration/control registers base. */
@@ -282,9 +316,14 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 	ret = armada8k_add_pcie_port(pp, pdev);
 	if (ret < 0)
 		goto fail_free;
-
 	return 0;
 
+err_phy:
+	while (--i >= 0) {
+		phy_power_off(phys[i]);
+		phy_exit(phys[i]);
+	}
+
 fail_free:
 	if (!IS_ERR(armada8k_pcie->clk))
 		clk_disable_unprepare(armada8k_pcie->clk);
-- 
1.7.9.5


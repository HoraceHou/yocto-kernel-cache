From fc57a7a09982e7512b66c49e0b47ce7e9a27bb69 Mon Sep 17 00:00:00 2001
From: Shadi Ammouri <shadi@marvell.com>
Date: Tue, 29 Dec 2015 09:48:08 +0200
Subject: [PATCH 0017/1345] clk: Enhance mvebu clock gating code to support
 multiple devices

commit  8f9f209fc9f71c8bbfa1fc97bcdff5dbff8a5d6e from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

	Add support for multiple clock gating domains.
	This is required to support multi CP system, where each CP will have
	it's own clock gating registers.

Signed-off-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/26382
Reviewed-by: Neta Zur Hershkovits <neta@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>

Conflicts:
	drivers/clk/mvebu/Kconfig

Change-Id: I0c52aaaff409b365be261db7e7bdc374f26b97b2
Reviewed-on: http://vgitil04.il.marvell.com:8080/27294
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
Tested-by: Lior Amsalem <alior@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/clk/mvebu/common.c |   58 +++++++++++++++++++++++++++-----------------
 1 file changed, 36 insertions(+), 22 deletions(-)

diff --git a/drivers/clk/mvebu/common.c b/drivers/clk/mvebu/common.c
index 472c88b..0ad7eff 100644
--- a/drivers/clk/mvebu/common.c
+++ b/drivers/clk/mvebu/common.c
@@ -198,34 +198,43 @@ struct clk_gating_ctrl {
 	u32 saved_reg;
 };
 
-static struct clk_gating_ctrl *ctrl;
+#define MAX_CLK_GATE_DOMAINS	(4)
+static struct clk_gating_ctrl *ctrl[MAX_CLK_GATE_DOMAINS];
+static int ctrl_cnt;
 
 static struct clk *clk_gating_get_src(
 	struct of_phandle_args *clkspec, void *data)
 {
+	struct clk_gating_ctrl *ctrlp = data;
 	int n;
 
 	if (clkspec->args_count < 1)
 		return ERR_PTR(-EINVAL);
 
-	for (n = 0; n < ctrl->num_gates; n++) {
+	for (n = 0; n < ctrlp->num_gates; n++) {
 		struct clk_gate *gate =
-			to_clk_gate(__clk_get_hw(ctrl->gates[n]));
+			to_clk_gate(__clk_get_hw(ctrlp->gates[n]));
 		if (clkspec->args[0] == gate->bit_idx)
-			return ctrl->gates[n];
+			return ctrlp->gates[n];
 	}
 	return ERR_PTR(-ENODEV);
 }
 
 static int mvebu_clk_gating_suspend(void)
 {
-	ctrl->saved_reg = readl(ctrl->base);
+	int i;
+
+	for (i = 0; i < ctrl_cnt; i++)
+		ctrl[i]->saved_reg = readl(ctrl[i]->base);
 	return 0;
 }
 
 static void mvebu_clk_gating_resume(void)
 {
-	writel(ctrl->saved_reg, ctrl->base);
+	int i;
+
+	for (i = 0; i < ctrl_cnt; i++)
+		writel(ctrl[i]->saved_reg, ctrl[i]->base);
 }
 
 static struct syscore_ops clk_gate_syscore_ops = {
@@ -240,9 +249,10 @@ void __init mvebu_clk_gating_setup(struct device_node *np,
 	void __iomem *base;
 	const char *default_parent = NULL;
 	int n;
+	struct clk_gating_ctrl *ctrlp;
 
-	if (ctrl) {
-		pr_err("mvebu-clk-gating: cannot instantiate more than one gatable clock device\n");
+	if (ctrl_cnt >= MAX_CLK_GATE_DOMAINS) {
+		pr_err("mvebu-clk-gating: too many gatable clock devices.\n");
 		return;
 	}
 
@@ -256,41 +266,45 @@ void __init mvebu_clk_gating_setup(struct device_node *np,
 		clk_put(clk);
 	}
 
-	ctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);
-	if (WARN_ON(!ctrl))
+	ctrlp = kzalloc(sizeof(*ctrlp), GFP_KERNEL);
+	if (WARN_ON(!ctrlp))
 		goto ctrl_out;
 
+	ctrl[ctrl_cnt] = ctrlp;
 	/* lock must already be initialized */
-	ctrl->lock = &ctrl_gating_lock;
+	ctrlp->lock = &ctrl_gating_lock;
 
-	ctrl->base = base;
+	ctrlp->base = base;
 
 	/* Count, allocate, and register clock gates */
 	for (n = 0; desc[n].name;)
 		n++;
 
-	ctrl->num_gates = n;
-	ctrl->gates = kcalloc(ctrl->num_gates, sizeof(*ctrl->gates),
+	ctrlp->num_gates = n;
+	ctrlp->gates = kcalloc(ctrlp->num_gates, sizeof(*ctrlp->gates),
 			      GFP_KERNEL);
-	if (WARN_ON(!ctrl->gates))
+	if (WARN_ON(!ctrlp->gates))
 		goto gates_out;
 
-	for (n = 0; n < ctrl->num_gates; n++) {
+	for (n = 0; n < ctrlp->num_gates; n++) {
 		const char *parent =
 			(desc[n].parent) ? desc[n].parent : default_parent;
-		ctrl->gates[n] = clk_register_gate(NULL, desc[n].name, parent,
+		ctrlp->gates[n] = clk_register_gate(NULL, desc[n].name, parent,
 					desc[n].flags, base, desc[n].bit_idx,
-					0, ctrl->lock);
-		WARN_ON(IS_ERR(ctrl->gates[n]));
+					0, ctrlp->lock);
+		WARN_ON(IS_ERR(ctrlp->gates[n]));
 	}
 
-	of_clk_add_provider(np, clk_gating_get_src, ctrl);
+	of_clk_add_provider(np, clk_gating_get_src, ctrlp);
 
-	register_syscore_ops(&clk_gate_syscore_ops);
+	/* Register ops only for first device. */
+	if (ctrl_cnt == 0)
+		register_syscore_ops(&clk_gate_syscore_ops);
 
+	ctrl_cnt++;
 	return;
 gates_out:
-	kfree(ctrl);
+	kfree(ctrlp);
 ctrl_out:
 	iounmap(base);
 }
-- 
1.7.9.5


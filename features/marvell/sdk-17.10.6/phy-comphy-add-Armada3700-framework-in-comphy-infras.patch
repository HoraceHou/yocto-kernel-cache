From 8866703ac06f7794a481bc20b5dd54335820cac3 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Thu, 12 Jan 2017 00:28:56 +0800
Subject: [PATCH 0782/1345] phy: comphy: add Armada3700 framework in comphy
 infrastructure

commit  8a3b78fcb0d556c272e8d0e1af799031b4f62fb5 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- The main purposes to support Armada-3700 comphy are as below:
  1. Initialize the comphy and run IO successfully without the
     dependency to bootloader comphy.
  2. Power off dedicated comphy during system suspend to save
     the power.
  3. Re-init the comphy after resume from low power state to
     make the IO work correctly
- create 2 files for armada-3700 with empty callback functions.
- update generic comphy driver to support upto 4 parameters from dts

Change-Id: I0e922d211f321074e540528e9fa2d8ff64e40053
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35530
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/phy/phy-comphy-mvebu.txt   |   18 ++
 drivers/phy/Kconfig                                |   10 +
 drivers/phy/Makefile                               |    1 +
 drivers/phy/phy-comphy-a3700.c                     |  211 ++++++++++++++++++++
 drivers/phy/phy-comphy-a3700.h                     |   24 +++
 drivers/phy/phy-comphy-mvebu.c                     |    4 +
 include/dt-bindings/phy/phy-comphy-mvebu.h         |    3 +
 7 files changed, 271 insertions(+)
 create mode 100644 drivers/phy/phy-comphy-a3700.c
 create mode 100644 drivers/phy/phy-comphy-a3700.h

diff --git a/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt b/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt
index 015e5e8..f6796ee 100644
--- a/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt
+++ b/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt
@@ -38,6 +38,7 @@ Each device using Comphy should have handle with the following properties:
 				- COMPHY_RXAUI0 COMPHY_RXAUI1
 				- COMPHY_XFI
 				- COMPHY_SFI
+				- COMPHY_USB3
 	  2. Complex description (for specific speed and/or polarity invert settings)
 	     With this approach, comphy settings are selected by the macro COMPHY_DEF,
 	     which defines comphy mode, unit index, comphy speed, and comphy RX/TX invert settings.
@@ -52,6 +53,7 @@ Each device using Comphy should have handle with the following properties:
 				- COMPHY_RXAUI_MODE
 				- COMPHY_XFI_MODE
 				- COMPHY_SFI_MODE
+				- COMPHY_USB3_MODE
 			COMPHY_UNIT_ID: unit index
 				- relevant to following interfaces, SATA, USB, RXAUI, SGMII and PCIE.
 				- SATA/USB/RXAUI: 0/1
@@ -88,6 +90,17 @@ Comphy Node:
 		status = "okay";
 	};
 
+	a3700_comphy: comphy@18300 {
+			compatible = "marvell,mvebu-comphy", "marvell,armada-3700-comphy";
+			reg = <0x18300 0x300>, /* comphy */
+			      <0x1F000 0x1000>, /* serdes */
+			      <0x5c000 0x1000>, /* usb3_gbe1 phy reg */
+			      <0xe0178 0x8>; /* lane2 indirect access */
+			reg-names = "comphy", "serdes", "usb3_gbe1_phy", "indirect";
+			#phy-cells = <2>;
+			status = "okay";
+	};
+
 Comphy consumer:
 ===============
 	(1) The example with simplified option of comphy description:
@@ -105,6 +118,11 @@ Comphy consumer:
 			- the speed is default
 			- the invert is also default without polarity inverted
 
+		sata@e0000 {
+				status = "okay";
+				phys = <&a3700_comphy 2 COMPHY_SATA0>;
+		};
+
 	(2) Examples with complex option of comphy description:
 		(2.1)	emac2: mac2 {
 				phys = <&comphy0 0 COMPHY_DEF(COMPHY_SGMII_MODE,
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index fa7a6f0..bf3aab7 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -135,6 +135,16 @@ config PHY_MVEBU_COMPHY_CP110
 	  responsible for configuring all SerDes lanes according to the
 	  selected configuration.
 
+config PHY_MVEBU_COMPHY_A3700
+	def_bool y
+	depends on ARCH_MVEBU
+	depends on OF
+	select PHY_MVEBU_COMPHY
+	help
+	  Enable this to support Marvell Armada3700 comphy driver. This driver is
+	  responsible for configuring all SerDes lanes according to the
+	  selected configuration.
+
 config PHY_MVEBU_SATA
 	def_bool y
 	depends on ARCH_DOVE || MACH_DOVE || MACH_KIRKWOOD
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 88da99b..60cb5c3 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_PHY_PXA_28NM_USB2)		+= phy-pxa-28nm-usb2.o
 obj-$(CONFIG_PHY_PXA_28NM_HSIC)		+= phy-pxa-28nm-hsic.o
 obj-$(CONFIG_PHY_MVEBU_COMPHY)		+= phy-comphy-mvebu.o
 obj-$(CONFIG_PHY_MVEBU_COMPHY_CP110)	+= phy-comphy-cp110.o
+obj-$(CONFIG_PHY_MVEBU_COMPHY_A3700)	+= phy-comphy-a3700.o
 obj-$(CONFIG_PHY_MVEBU_SATA)		+= phy-mvebu-sata.o
 obj-$(CONFIG_PHY_MIPHY28LP) 		+= phy-miphy28lp.o
 obj-$(CONFIG_PHY_RCAR_GEN2)		+= phy-rcar-gen2.o
diff --git a/drivers/phy/phy-comphy-a3700.c b/drivers/phy/phy-comphy-a3700.c
new file mode 100644
index 0000000..e797ba6
--- /dev/null
+++ b/drivers/phy/phy-comphy-a3700.c
@@ -0,0 +1,211 @@
+/*
+ * Marvell comphy driver
+ *
+ * Copyright (C) 2016 Marvell
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
+
+#include "phy-comphy-mvebu.h"
+#include "phy-comphy-a3700.h"
+
+
+/* PHY selector configures with corresponding modes */
+static void mvebu_a3700_comphy_set_phy_selector(struct mvebu_comphy_priv *priv,
+						struct mvebu_comphy *comphy)
+{
+	u32 reg;
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+
+
+	reg = readl(priv->comphy_regs + COMPHY_SELECTOR_PHY_REG_OFFSET);
+	switch (mode) {
+	case (COMPHY_SATA_MODE):
+		/* SATA must be in Lane2 */
+		if (comphy->index == COMPHY_LANE2)
+			reg &= ~COMPHY_SELECTOR_USB3_PHY_SEL_BIT;
+		else
+			dev_err(priv->dev, "COMPHY[%d] mode[%d] is invalid\n", comphy->index, mode);
+		break;
+
+	case (COMPHY_SGMII_MODE):
+	case (COMPHY_HS_SGMII_MODE):
+		if (comphy->index == COMPHY_LANE1)
+			reg &= ~COMPHY_SELECTOR_USB3_GBE1_SEL_BIT;
+		else if (comphy->index == COMPHY_LANE0)
+			reg &= ~COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT;
+		else
+			dev_err(priv->dev, "COMPHY[%d] mode[%d] is invalid\n", comphy->index, mode);
+		break;
+
+	case (COMPHY_USB3H_MODE):
+	case (COMPHY_USB3D_MODE):
+	case (COMPHY_USB3_MODE):
+		if (comphy->index == COMPHY_LANE2)
+			reg |= COMPHY_SELECTOR_USB3_PHY_SEL_BIT;
+		else if (comphy->index == COMPHY_LANE1)
+			reg |= COMPHY_SELECTOR_USB3_GBE1_SEL_BIT;
+		else
+			dev_err(priv->dev, "COMPHY[%d] mode[%d] is invalid\n", comphy->index, mode);
+		break;
+
+	case (COMPHY_PCIE_MODE):
+		/* PCIE must be in Lane0 */
+		if (comphy->index == COMPHY_LANE0)
+			reg |= COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT;
+		else
+			dev_err(priv->dev, "COMPHY[%d] mode[%d] is invalid\n", comphy->index, mode);
+		break;
+
+	default:
+		dev_err(priv->dev, "COMPHY[%d] mode[%d] is invalid\n", comphy->index, mode);
+		break;
+	}
+
+	writel(reg, priv->comphy_regs + COMPHY_SELECTOR_PHY_REG_OFFSET);
+}
+
+static int mvebu_a3700_comphy_sata_power_on(struct mvebu_comphy_priv *priv,
+					    struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	mvebu_a3700_comphy_set_phy_selector(priv, comphy);
+
+	dev_err(priv->dev, "SATA mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_a3700_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
+					     struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "SGMII mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_a3700_comphy_usb3_power_on(struct mvebu_comphy_priv *priv,
+					    struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "USB mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_a3700_comphy_pcie_power_on(struct mvebu_comphy_priv *priv,
+					    struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "PCIE mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_a3700_comphy_power_on(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+	int err = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	switch (mode) {
+	case(COMPHY_SATA_MODE):
+		err = mvebu_a3700_comphy_sata_power_on(priv, comphy);
+		break;
+
+	case(COMPHY_SGMII_MODE):
+	case(COMPHY_HS_SGMII_MODE):
+		err = mvebu_a3700_comphy_sgmii_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_USB3_MODE):
+		err = mvebu_a3700_comphy_usb3_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_PCIE_MODE):
+		err = mvebu_a3700_comphy_pcie_power_on(priv, comphy);
+		break;
+
+	default:
+		dev_err(priv->dev, "comphy%d: unsupported comphy mode\n",
+			comphy->index);
+		err = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return err;
+}
+
+static int mvebu_a3700_comphy_power_off(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	dev_dbg(priv->dev, "power off is not implemented\n");
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
+static struct phy_ops a3700_comphy_ops = {
+	.power_on	= mvebu_a3700_comphy_power_on,
+	.power_off	= mvebu_a3700_comphy_power_off,
+	.set_mode	= mvebu_comphy_set_mode,
+	.get_mode	= mvebu_comphy_get_mode,
+	.owner		= THIS_MODULE,
+};
+
+const struct mvebu_comphy_soc_info a3700_comphy = {
+	.num_of_lanes = 3,
+	.functions = {
+		/* Lane 0 */
+		{COMPHY_UNUSED, COMPHY_PCIE0, COMPHY_SGMII0},
+		/* Lane 1 */
+		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1, COMPHY_USB3},
+		/* Lane 2 */
+		{COMPHY_UNUSED, COMPHY_SATA0, COMPHY_USB3},
+	},
+	.comphy_ops = &a3700_comphy_ops,
+};
+
diff --git a/drivers/phy/phy-comphy-a3700.h b/drivers/phy/phy-comphy-a3700.h
new file mode 100644
index 0000000..003bddf
--- /dev/null
+++ b/drivers/phy/phy-comphy-a3700.h
@@ -0,0 +1,24 @@
+#ifndef _COMPHY_A3700_H
+#define _COMPHY_A3700_H
+
+extern const struct mvebu_comphy_soc_info a3700_comphy;
+
+#define PLL_SET_DELAY_US		600
+#define A3700_COMPHY_PLL_LOCK_TIMEOUT	1000
+
+enum {
+	COMPHY_LANE0 = 0,
+	COMPHY_LANE1,
+	COMPHY_LANE2,
+	COMPHY_LANE_MAX,
+};
+#define COMPHY_SELECTOR_PHY_REG_OFFSET		0xFC
+/* bit0: 0: Lane0 is GBE0; 1: Lane1 is PCIE */
+#define COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT	BIT(0)
+/* bit4: 0: Lane1 is GBE1; 1: Lane1 is USB3 */
+#define COMPHY_SELECTOR_USB3_GBE1_SEL_BIT	BIT(4)
+/* bit8: 0: Lane1 is USB, Lane2 is SATA; 1: Lane2 is USB3 */
+#define COMPHY_SELECTOR_USB3_PHY_SEL_BIT	BIT(8)
+
+#endif /* _COMPHY_A3700_H */
+
diff --git a/drivers/phy/phy-comphy-mvebu.c b/drivers/phy/phy-comphy-mvebu.c
index bc466ec..33fd513 100644
--- a/drivers/phy/phy-comphy-mvebu.c
+++ b/drivers/phy/phy-comphy-mvebu.c
@@ -21,6 +21,7 @@
 
 #include "phy-comphy-mvebu.h"
 #include "phy-comphy-cp110.h"
+#include "phy-comphy-a3700.h"
 
 /* mvebu_comphy_set_mode: shared by all SoCs */
 int mvebu_comphy_set_mode(struct phy *phy, enum phy_mode mode)
@@ -76,6 +77,9 @@ enum phy_mode mvebu_comphy_get_mode(struct phy *phy)
 #ifdef CONFIG_PHY_MVEBU_COMPHY_CP110
 	{ .compatible = "marvell,cp110-comphy", .data = &cp110_comphy },
 #endif /* CONFIG_PHY_MVEBU_COMPHY_CP110 */
+#ifdef CONFIG_PHY_MVEBU_COMPHY_A3700
+	{ .compatible = "marvell,armada-3700-comphy", .data = &a3700_comphy },
+#endif /* CONFIG_PHY_MVEBU_COMPHY_A3700 */
 	{ },
 };
 MODULE_DEVICE_TABLE(of, mvebu_comphy_of_match);
diff --git a/include/dt-bindings/phy/phy-comphy-mvebu.h b/include/dt-bindings/phy/phy-comphy-mvebu.h
index 919132d..ccb7202 100644
--- a/include/dt-bindings/phy/phy-comphy-mvebu.h
+++ b/include/dt-bindings/phy/phy-comphy-mvebu.h
@@ -82,6 +82,8 @@
 					COMPHY_SPEED_DEFAULT, COMPHY_POLARITY_NO_INVERT)
 #define COMPHY_SFI		COMPHY_DEF(COMPHY_SFI_MODE,  COMPHY_UNIT_ID0, \
 					COMPHY_SPEED_DEFAULT, COMPHY_POLARITY_NO_INVERT)
+#define COMPHY_USB3		COMPHY_DEF(COMPHY_USB3_MODE,  COMPHY_UNIT_ID0, \
+					COMPHY_SPEED_DEFAULT, COMPHY_POLARITY_NO_INVERT)	/* USB3 Host&Device */
 
 #define COMPHY_SATA_MODE	0x1
 #define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
@@ -92,6 +94,7 @@
 #define COMPHY_RXAUI_MODE	0x7
 #define COMPHY_XFI_MODE		0x8
 #define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
 
 /* Polarity invert macro */
 #define COMPHY_POLARITY_NO_INVERT	0
-- 
1.7.9.5


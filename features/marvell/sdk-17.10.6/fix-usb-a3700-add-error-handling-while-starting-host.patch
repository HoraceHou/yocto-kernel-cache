From 1d5eef180fadce7f0426db73869f9fcf26c7cdbb Mon Sep 17 00:00:00 2001
From: Leo Liang <lliang@marvell.com>
Date: Thu, 6 Jul 2017 16:40:29 +0800
Subject: [PATCH 1068/1345] fix: usb: a3700: add error handling while starting
 host

commit  f52935b38ae37c00f036479a7ce58bfdff5d04c1 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

If user plugs and unplugs USB3 DoK quickly and repeated, may have below
message:
xhci-hcd d0058000.usb3: Host not halted after 16000 microseconds.
xhci-hcd d0058000.usb3: can't setup: -110

Root casuse:
In this case, xhci driver cannot get status of STS_HALT and returns
ETIMEDOUT in function xhci_handshake. And otg driver is trying to
start host and don't check the return value of usb_add_hcd. If don't
handle this case, then will occurs NULL pointer oops while user remove
DoK. That's our otg driver is trying to call usb_remove_hcd functions.

Fix:
By checking the return value and don't transfer to new status if
starting host failed.

Change-Id: I13e75ba6d6b20607830dd7f4bd308f6d82adb698
Signed-off-by: Leo Liang <lliang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/40856
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/41576
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/phy/phy-a3700-usb.c |   32 ++++++++++++++++++++++++++------
 1 file changed, 26 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/phy/phy-a3700-usb.c b/drivers/usb/phy/phy-a3700-usb.c
index 8b4d700..e44d42a 100644
--- a/drivers/usb/phy/phy-a3700-usb.c
+++ b/drivers/usb/phy/phy-a3700-usb.c
@@ -99,21 +99,35 @@ struct a3700_otg {
 	(IRQF_SHARED | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | \
 		IRQF_ONESHOT)
 
-static void a3700_otg_start_host(struct a3700_otg *mvotg, int on)
+static int a3700_otg_start_host(struct a3700_otg *mvotg, int on)
 {
 	struct usb_hcd *hcd;
 	struct usb_otg *otg = mvotg->phy.otg;
+	int ret;
 
 	if (!otg->host)
-		return;
+		return -EINVAL;
 
 	dev_dbg(mvotg->dev, "%s, %s\n", __func__, on ? "on":"off");
 
 	hcd = bus_to_hcd(otg->host);
 
 	if (on) {
-		usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
-		usb_add_hcd(hcd->shared_hcd, hcd->irq, IRQF_SHARED);
+		/*
+		 * Sometimes host controller cannot read status (likes STS_HALT)
+		 * during USB DoK plug/unplugged quickly and repeated. Mostly this
+		 * case occurs in function xhci_handshake() and return -ETIMEDOUT.
+		 * If don't handle this case in here, will be oops while calling
+		 * usb_remove_hcd. Just return and will be handled by caller.
+		 */
+		ret = usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
+		if (ret < 0)
+			return ret;
+		ret = usb_add_hcd(hcd->shared_hcd, hcd->irq, IRQF_SHARED);
+		if (ret < 0) {
+			usb_remove_hcd(hcd);
+			return ret;
+		}
 		device_wakeup_enable(hcd->self.controller);
 	} else {
 		/*
@@ -144,6 +158,7 @@ static void a3700_otg_start_host(struct a3700_otg *mvotg, int on)
 				dev_err(mvotg->dev, "Failed to disable power\n");
 		}
 	}
+	return 0;
 }
 
 static void a3700_otg_start_periphrals(struct a3700_otg *mvotg, int on)
@@ -187,6 +202,7 @@ void a3700_otg_disable_irq(struct a3700_otg *mvotg)
 static void a3700_otg_work(struct work_struct *work)
 {
 	struct a3700_otg *mvotg;
+	int ret = 0;
 
 	mvotg = container_of(to_delayed_work(work), struct a3700_otg, work);
 
@@ -194,7 +210,7 @@ static void a3700_otg_work(struct work_struct *work)
 	case USB_PORT_IDLE:
 		if (mvotg->port_state == USB_HOST_ATTACHED) {
 			dev_dbg(mvotg->dev, "moving to host mode\n");
-			a3700_otg_start_host(mvotg, 1);
+			ret = a3700_otg_start_host(mvotg, 1);
 		} else if (mvotg->port_state == USB_DEVICE_ATTACHED) {
 			dev_dbg(mvotg->dev, "moving to device mode\n");
 			a3700_otg_start_periphrals(mvotg, 1);
@@ -203,6 +219,7 @@ static void a3700_otg_work(struct work_struct *work)
 	case USB_HOST_ATTACHED:
 		if (mvotg->port_state == USB_PORT_IDLE) {
 			dev_dbg(mvotg->dev, "moving to idle mode\n");
+			/* always success for host stop */
 			a3700_otg_start_host(mvotg, 0);
 		}
 		break;
@@ -216,7 +233,10 @@ static void a3700_otg_work(struct work_struct *work)
 		dev_dbg(mvotg->dev, "wrong state.\n");
 		break;
 	}
-	mvotg->old_state = mvotg->port_state;
+
+	/* transfer state machine for success only */
+	if (!ret)
+		mvotg->old_state = mvotg->port_state;
 }
 
 static void a3700_static_host_work(struct work_struct *work)
-- 
1.7.9.5


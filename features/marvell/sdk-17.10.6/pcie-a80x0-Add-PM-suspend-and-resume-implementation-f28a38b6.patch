From 8d7d925a4ce4d8eeaa93070cb6cde6be2e8bf8c9 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Fri, 14 Jul 2017 12:05:06 +0800
Subject: [PATCH 1329/1345] pcie: a80x0: Add PM suspend and resume
 implementation

commit  b25cfa20d6df32df29a1ee4aedfee9fe8ee56525 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Add suspend and resume implementation for S2RAM.
1) During suspend, the driver disables the PCIe clock and
   power off PHY used by PCIe in suspend routine
2) During resume, the driver re-enable the clock, then
   reinitializes the PCIe PHY; after that if the PCIe reset
   is connected to GPIO, reset the PCIe, and at last
   reinitializes PCIe host.

Change-Id: Ieeeaf9315959b703eb7c52e99b6a17e4ca3304b4
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42895
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/dwc/pcie-armada8k.c |   95 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/drivers/pci/dwc/pcie-armada8k.c b/drivers/pci/dwc/pcie-armada8k.c
index 3a1da63..31eb7c4 100644
--- a/drivers/pci/dwc/pcie-armada8k.c
+++ b/drivers/pci/dwc/pcie-armada8k.c
@@ -347,6 +347,101 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static int armada8k_pcie_suspend_noirq(struct device *dev)
+{
+	int i;
+	struct armada8k_pcie *pcie;
+
+	pcie = dev_get_drvdata(dev);
+
+	/* Gating clock */
+	if (!IS_ERR(pcie->clk))
+		clk_disable_unprepare(pcie->clk);
+
+	/* Power off PHY */
+	for (i = 0; i < pcie->phy_count; i++) {
+		if (pcie->phys[i]) {
+			phy_power_off(pcie->phys[i]);
+			phy_exit(pcie->phys[i]);
+		}
+	}
+
+	return 0;
+}
+
+static int armada8k_pcie_resume_noirq(struct device *dev)
+{
+	struct armada8k_pcie *pcie;
+	int i, ret;
+
+	pcie = dev_get_drvdata(dev);
+
+	if (!IS_ERR(pcie->clk)) {
+		ret = clk_prepare_enable(pcie->clk);
+		if (ret) {
+			dev_err(dev, "Failed to enable clock\n");
+			return ret;
+		}
+	}
+
+	/* Power on PHY */
+	for (i = 0; i < pcie->phy_count; i++) {
+		if (pcie->phys[i]) {
+			u32 command;
+			/* Tell COMPHY the PCIE width based on phy command,
+			 * and in PHY command callback, the width will be
+			 * checked for its validation.
+			 */
+			switch (pcie->phy_count) {
+			case PCIE_LNK_X1:
+				command = COMPHY_COMMAND_PCIE_WIDTH_1;
+				break;
+			case PCIE_LNK_X2:
+				command = COMPHY_COMMAND_PCIE_WIDTH_2;
+				break;
+			case PCIE_LNK_X4:
+				command = COMPHY_COMMAND_PCIE_WIDTH_4;
+				break;
+			default:
+				command = COMPHY_COMMAND_PCIE_WIDTH_UNSUPPORT;
+			}
+			phy_send_command(pcie->phys[i], command);
+
+			ret = phy_init(pcie->phys[i]);
+			if (ret < 0)
+				goto err_phy;
+			ret = phy_power_on(pcie->phys[i]);
+			if (ret < 0) {
+				phy_exit(pcie->phys[i]);
+				goto err_phy;
+			}
+		}
+	}
+
+	/* Reset PCIe if it is connected to GPIO */
+	if (pcie->reset_gpio)
+		armada8k_pcie_reset(pcie);
+
+	/* Reinit PCIE host */
+	armada8k_pcie_host_init(&pcie->pci->pp);
+	return 0;
+
+err_phy:
+	while (--i >= 0) {
+		phy_power_off(pcie->phys[i]);
+		phy_exit(pcie->phys[i]);
+	}
+	if (!IS_ERR(pcie->clk))
+		clk_disable_unprepare(pcie->clk);
+
+	return ret;
+}
+
+static const struct dev_pm_ops armada8k_pcie_pm_ops = {
+	.suspend_noirq = armada8k_pcie_suspend_noirq,
+	.resume_noirq = armada8k_pcie_resume_noirq,
+};
+
 static const struct of_device_id armada8k_pcie_of_match[] = {
 	{ .compatible = "marvell,armada8k-pcie", },
 	{},
-- 
1.7.9.5


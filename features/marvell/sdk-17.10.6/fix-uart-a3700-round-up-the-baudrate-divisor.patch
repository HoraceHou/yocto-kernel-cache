From 94700667a247dc60121a53b0d4d2c606a690b560 Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Wed, 15 Feb 2017 23:15:22 +0800
Subject: [PATCH 0786/1345] fix: uart: a3700: round up the baudrate divisor

commit  b1d84ea4fc4e204976033bbb8c07ce4570ef2334 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- Baudrate divisor for uart0/1 is calcualted as:
  input_freq / (16 * baudrate), and the result value
  used to be round down all the time.
- In the case of uart1 working with 115200 baudrate,
  the divisor would be 0xD when round down,
  25MHz / (115200 * 16) = 13.56
  but it doesn't work, since the error per bit frame
  is ((25MHz / (0xD * 16)) - 115200) / 115200 = 4.33%,
  and it is bigger than 3.5%, which is the maximum value
  for UART to work according to test.
- So this patch changes baudrate divisor value from
  round down to round up, and it works well with
  baudrate 9600, 19200, 38400, 57600, 115200, 230400
  on both UART0 and UART1.
- But when working with baudrate 460800, the way to
  round up the divisor doesn't work since the error
  per bit frame is 15.2%. In this case, baudrate should
  be get by feature Fractional Divisor, which provides
  more accurate value. And it should be supported in the
  future on demand.

Change-Id: I91727c7649b886a65883f35c3977f093ae4dcd33
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/36800
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hua Jing <jinghua@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/mvebu-uart.c |   19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index 461f5bf..e5f934f 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -558,12 +558,25 @@ static void mvebu_uart_baud_rate_set(struct uart_port *port, unsigned int baud)
 	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
 
 	/* The Uart clock is divided by the value of divisor to generate
-	 * UCLK_OUT clock, which must be 16 times faster than the target
-	 * baud rate:
+	 * UCLK_OUT clock, which is 16 times faster than the target baud rate:
 	 * UCLK_OUT = 16 times the taregt baud rate.
+	 * So the baudrate divisor can be calculated by:
+	 * divisor = input_clock / (baudrate * 16).
+	 * The divisor value is round up, and it works well with the baudrate 9600,
+	 * 19200, 38400, 57600, 115200, 230400.
+	 * But when working with baudrate 460800, the rounding up doesn't work,
+	 * since the error per bit frame is 15.2%.
+	 * (460800 - (25MHz / (0x4 * 16)))) / 460800 = 15.2%
+	 * Theoretically, neither round-up nor round-down will work well. However,
+	 * in this case, it needs to use Fractional Divisor when greater baud rate
+	 * accuracy is required. UCLK_OUT is no longer fixed at 16 times faster than
+	 * the desired baudrate but rather M times the desired baud rate. Where
+	 * M = (3*m1 + 3*m2 + 2*m3 +2*m4)/10. (m1, m2, m3, m4) are set with RD0012214h
+	 * (UART 2 Programmable Oversampling Stack).
+	 * Fraction divisor feature should be supported in the future on demand.
 	 */
 	if (!IS_ERR(uart_data->clk)) {
-		baud_rate_div = port->uartclk / (baud * 16);
+		baud_rate_div = DIV_ROUND_UP(port->uartclk, (16 * baud));
 		writel(baud_rate_div, port->membase + REG_BRDV(uart_data));
 	}
 }
-- 
1.7.9.5


From 3ab60e72db30c971d561963c1b100e8436e97fe5 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Mon, 9 Jan 2017 23:47:39 +0800
Subject: [PATCH 0730/1345] phy: comphy: split comphy driver to generic part
 and exclusive parts

commit  eec08659240259fe83984341fe38c211ac5d6b4c from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- cp110(Armada7K/8K) and Armada3700 can not share the same phy driver,
  so in order to make the driver dedicated for each soc, current comphy
  driver need to be splited to generic part and exclusive parts.
- the generic part supplies common phy driver framework, which lies
  in original comphy driver files.
- the exclusive parts provide phy operation API to generic part, which
  lies in dedicated files with name of socs.

Change-Id: Ic261fd2395c38d1bf0b5fb3a9f1d5ff3acd24966
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35398
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/phy/phy-comphy-mvebu.txt   |   52 +
 .../devicetree/bindings/phy/phy-mvebu-comphy.txt   |   52 -
 .../boot/dts/marvell/armada-cp110-master.dtsi      |    2 +-
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c  |    2 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |    2 +-
 drivers/phy/Kconfig                                |   14 +-
 drivers/phy/Makefile                               |    3 +-
 drivers/phy/phy-comphy-cp110.c                     |  821 +++++++++++++++
 drivers/phy/phy-comphy-cp110.h                     |  236 +++++
 drivers/phy/phy-comphy-mvebu.c                     |  199 ++++
 drivers/phy/phy-comphy-mvebu.h                     |   62 ++
 drivers/phy/phy-mvebu-comphy.c                     | 1040 --------------------
 drivers/phy/phy-mvebu-comphy.h                     |  233 -----
 include/dt-bindings/phy/phy-comphy-mvebu.h         |   46 +
 include/dt-bindings/phy/phy-mvebu-comphy.h         |   46 -
 15 files changed, 1433 insertions(+), 1377 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt
 delete mode 100644 Documentation/devicetree/bindings/phy/phy-mvebu-comphy.txt
 create mode 100644 drivers/phy/phy-comphy-cp110.c
 create mode 100644 drivers/phy/phy-comphy-cp110.h
 create mode 100644 drivers/phy/phy-comphy-mvebu.c
 create mode 100644 drivers/phy/phy-comphy-mvebu.h
 delete mode 100644 drivers/phy/phy-mvebu-comphy.c
 delete mode 100644 drivers/phy/phy-mvebu-comphy.h
 create mode 100644 include/dt-bindings/phy/phy-comphy-mvebu.h
 delete mode 100644 include/dt-bindings/phy/phy-mvebu-comphy.h

diff --git a/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt b/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt
new file mode 100644
index 0000000..dc88e468
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/phy-comphy-mvebu.txt
@@ -0,0 +1,52 @@
+Marvell EBU Comphy binding
+==========================
+
+This binding describes a Comphy device that is used to control
+and configure comphy hardware on Marvell SoCs.
+
+Each Comphy device has several PHYs which can be configured
+to support various modes:
+SATA, USB, PCIE, Network modes, etc.
+
+Required properties for comphy node:
+	- compatible:	Should be "marvell,cp110-comphy"
+	- reg:			Address and length of register sets
+				    for each device in "reg-names"
+	- reg-names:	The names of the register addresses
+					corresponding to the registers filled in "reg".
+	- #phy-cells:	Standard property (Documentation: phy-bindings.txt)
+					Should be 2.
+	Example will be provided in the end of this file.
+
+Each device using Comphy should have handle with the following properties:
+	- Handle to the Comphy node.
+	- Comphy index (SerDes lane number).
+	- Required Comphy mode (SATA/PCIE/USB/Network).
+	Example will be provided in the end of this file.
+
+Example:
+Comphy Node:
+============
+		comphy0: comphy {
+				compatible = "marvell,cp110-comphy";
+				reg = <0x441000 0x100>, <0x120000 0x6000>;
+				reg-names = "comphy", "serdes";
+				#phy-cells = <2>;
+				status = "okay";
+		};
+
+		comphy1: comphy {
+				compatible = "marvell,cp110-comphy";
+				reg = <0x441000 0x100>, <0x120000 0x6000>;
+				reg-names = "comphy", "serdes";
+				#phy-cells = <2>;
+				status = "okay";
+		};
+
+Comphy consumer:
+=============
+		sata@540000 {
+				phys = <&comphy0 4 COMPHY_SATA0>;
+				status = "okay";
+		};
+
diff --git a/Documentation/devicetree/bindings/phy/phy-mvebu-comphy.txt b/Documentation/devicetree/bindings/phy/phy-mvebu-comphy.txt
deleted file mode 100644
index dc88e468..0000000
--- a/Documentation/devicetree/bindings/phy/phy-mvebu-comphy.txt
+++ /dev/null
@@ -1,52 +0,0 @@
-Marvell EBU Comphy binding
-==========================
-
-This binding describes a Comphy device that is used to control
-and configure comphy hardware on Marvell SoCs.
-
-Each Comphy device has several PHYs which can be configured
-to support various modes:
-SATA, USB, PCIE, Network modes, etc.
-
-Required properties for comphy node:
-	- compatible:	Should be "marvell,cp110-comphy"
-	- reg:			Address and length of register sets
-				    for each device in "reg-names"
-	- reg-names:	The names of the register addresses
-					corresponding to the registers filled in "reg".
-	- #phy-cells:	Standard property (Documentation: phy-bindings.txt)
-					Should be 2.
-	Example will be provided in the end of this file.
-
-Each device using Comphy should have handle with the following properties:
-	- Handle to the Comphy node.
-	- Comphy index (SerDes lane number).
-	- Required Comphy mode (SATA/PCIE/USB/Network).
-	Example will be provided in the end of this file.
-
-Example:
-Comphy Node:
-============
-		comphy0: comphy {
-				compatible = "marvell,cp110-comphy";
-				reg = <0x441000 0x100>, <0x120000 0x6000>;
-				reg-names = "comphy", "serdes";
-				#phy-cells = <2>;
-				status = "okay";
-		};
-
-		comphy1: comphy {
-				compatible = "marvell,cp110-comphy";
-				reg = <0x441000 0x100>, <0x120000 0x6000>;
-				reg-names = "comphy", "serdes";
-				#phy-cells = <2>;
-				status = "okay";
-		};
-
-Comphy consumer:
-=============
-		sata@540000 {
-				phys = <&comphy0 4 COMPHY_SATA0>;
-				status = "okay";
-		};
-
diff --git a/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi b/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi
index da5334d..0b6b8904 100644
--- a/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi
@@ -44,7 +44,7 @@
  * Device Tree file for Marvell Armada CP110 Master.
  */
 
-#include <dt-bindings/phy/phy-mvebu-comphy.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
 
 / {
 	cp110-master {
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
index e75f2dd..05e79d0 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
@@ -38,7 +38,7 @@
 #include <net/ip.h>
 #include <net/ipv6.h>
 #include <linux/phy/phy.h>
-#include <dt-bindings/phy/phy-mvebu-comphy.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
 
 #include "mv_pp2x.h"
 #include "mv_pp2x_hw.h"
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index b9aa5ef..e3bd729 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -48,7 +48,7 @@
 #include <net/busy_poll.h>
 #include <asm/cacheflush.h>
 #include <linux/dma-mapping.h>
-#include <dt-bindings/phy/phy-mvebu-comphy.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
 
 #include "mv_pp2x.h"
 #include "mv_pp2x_hw.h"
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index 2b2327a..fa7a6f0 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -116,12 +116,22 @@ config PHY_PXA_28NM_USB2
 	  To compile this driver as a module, choose M here.
 
 config PHY_MVEBU_COMPHY
-	def_bool y
+	def_bool n
 	depends on ARCH_MVEBU
 	depends on OF
 	select GENERIC_PHY
 	help
-	  Enable this to support Marvell comphy driver. This driver is
+	  Enable this to support Marvell comphy driver. The comphy driver
+	  supports CP110 and Armada-3700 and each of them has a separate
+	  kconfig option.
+
+config PHY_MVEBU_COMPHY_CP110
+	def_bool y
+	depends on ARCH_MVEBU
+	depends on OF
+	select PHY_MVEBU_COMPHY
+	help
+	  Enable this to support Marvell CP110 comphy driver. This driver is
 	  responsible for configuring all SerDes lanes according to the
 	  selected configuration.
 
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 5c84220..88da99b 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -16,7 +16,8 @@ obj-$(CONFIG_PHY_EXYNOS_MIPI_VIDEO)	+= phy-exynos-mipi-video.o
 obj-$(CONFIG_PHY_LPC18XX_USB_OTG)	+= phy-lpc18xx-usb-otg.o
 obj-$(CONFIG_PHY_PXA_28NM_USB2)		+= phy-pxa-28nm-usb2.o
 obj-$(CONFIG_PHY_PXA_28NM_HSIC)		+= phy-pxa-28nm-hsic.o
-obj-$(CONFIG_PHY_MVEBU_COMPHY)		+= phy-mvebu-comphy.o
+obj-$(CONFIG_PHY_MVEBU_COMPHY)		+= phy-comphy-mvebu.o
+obj-$(CONFIG_PHY_MVEBU_COMPHY_CP110)	+= phy-comphy-cp110.o
 obj-$(CONFIG_PHY_MVEBU_SATA)		+= phy-mvebu-sata.o
 obj-$(CONFIG_PHY_MIPHY28LP) 		+= phy-miphy28lp.o
 obj-$(CONFIG_PHY_RCAR_GEN2)		+= phy-rcar-gen2.o
diff --git a/drivers/phy/phy-comphy-cp110.c b/drivers/phy/phy-comphy-cp110.c
new file mode 100644
index 0000000..ea8d962
--- /dev/null
+++ b/drivers/phy/phy-comphy-cp110.c
@@ -0,0 +1,821 @@
+/*
+ * Marvell cp110 comphy driver
+ *
+ * Copyright (C) 2016 Marvell
+ *
+ * Igal Liberman <igall@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
+
+#include "phy-comphy-mvebu.h"
+#include "phy-comphy-cp110.h"
+
+/* Clear PHY selector - avoid collision with prior u-boot configuration */
+static void mvebu_cp110_comphy_clr_phy_selector(struct mvebu_comphy_priv *priv,
+						struct mvebu_comphy *comphy)
+{
+	u32 reg, mask, field;
+	u32 comphy_offset = COMMON_SELECTOR_COMPHYN_FIELD_WIDTH * comphy->index;
+
+	mask = COMMON_SELECTOR_COMPHY_MASK << comphy_offset;
+	reg = readl(priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
+	field = reg & mask;
+
+	/* Clear comphy selector - if it was set by u-boot.
+	 * (might be that this comphy was configured as PCIe/USB,
+	 * in such case, no need to clear comphy selector because PCIe/USB
+	 * are controlled by hpipe selector.
+	 */
+	if (field) {
+		reg &= ~mask;
+		writel(reg, priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
+	}
+}
+
+/* PHY selector configures SATA and Network modes */
+static void mvebu_cp110_comphy_set_phy_selector(struct mvebu_comphy_priv *priv,
+						struct mvebu_comphy *comphy)
+{
+	u32 reg, mask;
+	u32 comphy_offset = COMMON_SELECTOR_COMPHYN_FIELD_WIDTH * comphy->index;
+	int mode;
+
+	/* Comphy mode (compound of the IO mode and id) is stored during
+	 * the execution of mvebu_comphy_of_xlate.
+	 * Here, only the IO mode is required to distinguish between SATA and
+	 * network modes.
+	 */
+	mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+
+	mask = COMMON_SELECTOR_COMPHY_MASK << comphy_offset;
+	reg = readl(priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
+	reg &= ~mask;
+
+	/* SATA port 0/1 require the same configuration */
+	if (mode == COMPHY_SATA_MODE) {
+		/* SATA selector values is always 4 */
+		reg |= COMMON_SELECTOR_COMPHYN_SATA << comphy_offset;
+	} else {
+		switch (comphy->index) {
+		case(0):
+		case(1):
+		case(2):
+			/* For comphy 0,1, and 2:
+			 *	Network selector value is always 1.
+			 */
+			reg |= COMMON_SELECTOR_COMPHY0_1_2_NETWORK << comphy_offset;
+			break;
+		case(3):
+			/* For comphy 3:
+			 * 0x1 = RXAUI_Lane1
+			 * 0x2 = SGMII/HS-SGMII Port1
+			 */
+			if (mode == COMPHY_RXAUI_MODE)
+				reg |= COMMON_SELECTOR_COMPHY3_RXAUI << comphy_offset;
+			else
+				reg |= COMMON_SELECTOR_COMPHY3_SGMII << comphy_offset;
+			break;
+		case(4):
+			 /* For comphy 4:
+			  * 0x1 = SGMII/HS-SGMII Port2
+			  * 0x2 = SGMII/HS-SGMII Port1: XFI/SFI, RXAUI_Lane0
+			  */
+			if (priv->lanes[comphy->index].mode == COMPHY_SGMII2 ||
+			    priv->lanes[comphy->index].mode == COMPHY_HS_SGMII2)
+				reg |= COMMON_SELECTOR_COMPHY4_SGMII2 << comphy_offset;
+			else
+				reg |= COMMON_SELECTOR_COMPHY4_ALL_OTHERS << comphy_offset;
+			break;
+		case(5):
+			/* For comphy 5:
+			 * 0x1 = SGMII/HS-SGMII Port2
+			 * 0x2 = RXAUI Lane1
+			 */
+			if (mode == COMPHY_RXAUI_MODE)
+				reg |= COMMON_SELECTOR_COMPHY5_RXAUI << comphy_offset;
+			else
+				reg |= COMMON_SELECTOR_COMPHY5_SGMII << comphy_offset;
+			break;
+		}
+	}
+
+	writel(reg, priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
+
+}
+
+static int mvebu_cp110_comphy_sata_power_on(struct mvebu_comphy_priv *priv,
+					    struct mvebu_comphy *comphy)
+{
+	void __iomem *hpipe_addr, *sd_ip_addr, *comphy_addr;
+	u32 mask, data;
+	int ret = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	/* configure phy selector for SATA */
+	mvebu_cp110_comphy_set_phy_selector(priv, comphy);
+
+	hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
+	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
+	comphy_addr = COMPHY_ADDR(priv->comphy_regs, comphy->index);
+
+	dev_dbg(priv->dev, "stage: RFU configurations - hard reset comphy\n");
+	/* RFU configurations - hard reset comphy */
+	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
+	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
+	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
+	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
+	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
+	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
+	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
+	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
+	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
+
+	/* Set select data  width 40Bit - SATA mode only */
+	reg_set(comphy_addr + COMMON_PHY_CFG6_REG,
+		0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET, COMMON_PHY_CFG6_IF_40_SEL_MASK);
+
+	/* release from hard reset in SD external */
+	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	/* Wait 1ms - until band gap and ref clock ready */
+	mdelay(1);
+
+	dev_dbg(priv->dev, "stage: Comphy configuration\n");
+	/* Start comphy Configuration */
+	/* Set reference clock to comes from group 1 - choose 25Mhz */
+	reg_set(hpipe_addr + HPIPE_MISC_REG,
+		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET, HPIPE_MISC_REFCLK_SEL_MASK);
+	/* Reference frequency select set 1 (for SATA = 25Mhz) */
+	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
+	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
+	/* PHY mode select (set SATA = 0x0 */
+	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
+	data |= 0x0 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
+	/* Set max PHY generation setting - 6Gbps */
+	reg_set(hpipe_addr + HPIPE_INTERFACE_REG,
+		0x2 << HPIPE_INTERFACE_GEN_MAX_OFFSET, HPIPE_INTERFACE_GEN_MAX_MASK);
+	/* Set select data  width 40Bit (SEL_BITS[2:0]) */
+	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
+		0x2 << HPIPE_LOOPBACK_SEL_OFFSET, HPIPE_LOOPBACK_SEL_MASK);
+
+	dev_dbg(priv->dev, "stage: Analog parameters from ETP(HW)\n");
+	/* G1 settings */
+	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
+	data = 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
+	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
+	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
+	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK;
+	data |= 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET;
+	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK;
+	data |= 0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET;
+	mask |= HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK;
+	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
+
+	mask = HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
+	data = 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
+	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
+	data |= 0x2 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
+	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
+	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
+	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK;
+	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET;
+	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK;
+	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
+
+	/* G2 settings */
+	mask = HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK;
+	data = 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET;
+	mask |= HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK;
+	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET;
+	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK;
+	data |= 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET;
+	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK;
+	data |= 0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET;
+	mask |= HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK;
+	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G2_SET_1_REG, data, mask);
+
+	/* G3 settings */
+	mask = HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK;
+	data = 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET;
+	mask |= HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK;
+	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET;
+	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK;
+	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET;
+	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK;
+	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET;
+	mask |= HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK;
+	data |= 0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET;
+	mask |= HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK;
+	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET;
+	mask |= HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK;
+	data |= 0x0 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G3_SET_1_REG, data, mask);
+
+	/* DTL Control */
+	mask = HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK;
+	data = 0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET;
+	mask |= HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK;
+	data |= 0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET;
+	mask |= HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
+	data |= 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
+	mask |= HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK;
+	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET;
+	mask |= HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK;
+	data |= 0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET;
+	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_MASK;
+	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET;
+	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK;
+	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
+
+	/* DFE reset sequence */
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
+		0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET, HPIPE_PWR_CTR_RST_DFE_MASK);
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
+		0x0 << HPIPE_PWR_CTR_RST_DFE_OFFSET, HPIPE_PWR_CTR_RST_DFE_MASK);
+	/* SW reset for interrupt logic */
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
+		0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET, HPIPE_PWR_CTR_SFT_RST_MASK);
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
+		0x0 << HPIPE_PWR_CTR_SFT_RST_OFFSET, HPIPE_PWR_CTR_SFT_RST_MASK);
+
+	dev_dbg(priv->dev, "stage: Comphy power up\n");
+
+	return ret;
+}
+
+static int mvebu_cp110_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
+					     struct mvebu_comphy *comphy)
+{
+	void __iomem *hpipe_addr, *sd_ip_addr, *comphy_addr, *addr;
+	u32 mask, data;
+	int ret = 0;
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
+	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
+	comphy_addr = COMPHY_ADDR(priv->comphy_regs, comphy->index);
+
+	/* configure phy selector for SGMII */
+	mvebu_cp110_comphy_set_phy_selector(priv, comphy);
+
+	/* Confiugre the lane */
+	dev_dbg(priv->dev, "stage: RFU configurations - hard reset comphy\n");
+	/* RFU configurations - hard reset comphy */
+	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
+	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
+	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
+	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
+	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
+
+	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
+	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
+	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
+
+	if (mode == COMPHY_SGMII_MODE) {
+		/* SGMII 1G, SerDes speed 1.25G */
+		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
+		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
+	} else if (mode == COMPHY_HS_SGMII_MODE) {
+		/* HS SGMII (2.5G), SerDes speed 3.125G */
+		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
+		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
+	} else {
+		/* Other rates are not supported */
+		dev_err(priv->dev, "unsupported SGMII speed on comphy%d\n",
+			comphy->index);
+		return -EINVAL;
+	}
+
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
+	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
+	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
+	data |= 1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
+
+	/* Set hard reset */
+	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
+	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
+	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
+	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	/* Release hard reset */
+	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	/* Wait 1ms - until band gap and ref clock ready */
+	mdelay(1);
+
+	/* Make sure that 40 data bits is disabled
+	 * This bit is not cleared by reset
+	 */
+	mask = COMMON_PHY_CFG6_IF_40_SEL_MASK;
+	data = 0 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET;
+	reg_set(comphy_addr + COMMON_PHY_CFG6_REG, data, mask);
+
+	/* Start comphy Configuration */
+	dev_dbg(priv->dev, "stage: Comphy configuration\n");
+	/* set reference clock */
+	mask = HPIPE_MISC_REFCLK_SEL_MASK;
+	data = 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
+	/* Power and PLL Control */
+	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
+	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
+	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
+	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
+	/* Loopback register */
+	mask = HPIPE_LOOPBACK_SEL_MASK;
+	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
+	/* rx control 1 */
+	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
+	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
+	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
+	data |= 0x0 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
+	/* DTL Control */
+	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
+	data = 0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
+
+	/* Set analog parameters from ETP(HW) - for now use the default datas */
+	dev_dbg(priv->dev, "stage: Analog parameters from ETP(HW)\n");
+
+	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG,
+		0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET, HPIPE_G1_SET_0_G1_TX_EMPH1_MASK);
+
+	dev_dbg(priv->dev, "stage: RFU configurations- Power Up PLL,Tx,Rx\n");
+	/* SERDES External Configuration */
+	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
+
+	/* check PLL rx & tx ready */
+	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
+	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK | SD_EXTERNAL_STATUS0_PLL_TX_MASK;
+	mask = data;
+	data = polling_with_timeout(addr, data, mask, 15000);
+	if (data != 0) {
+		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
+			dev_err(priv->dev, "RX PLL is not locked\n");
+		if (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK)
+			dev_err(priv->dev, "TX PLL is not locked\n");
+
+		ret = -ETIMEDOUT;
+	}
+
+	/* RX init */
+	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	/* check that RX init done */
+	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
+	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
+	mask = data;
+	data = polling_with_timeout(addr, data, mask, 100);
+	if (data != 0) {
+		dev_err(priv->dev, "RX init failed\n");
+		ret = -ETIMEDOUT;
+	}
+
+	dev_dbg(priv->dev, "stage: RF Reset\n");
+	/* RF Reset */
+	mask =	SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
+	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	return ret;
+}
+
+static int mvebu_cp110_comphy_usb3_power_on(struct mvebu_comphy_priv *priv,
+					    struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "USB mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_cp110_comphy_pcie_power_on(struct mvebu_comphy_priv *priv,
+					    struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "PCIE mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_cp110_comphy_rxaui_power_on(struct mvebu_comphy_priv *priv,
+					     struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "RXAUI mode is not implemented\n");
+
+	/* configure phy selector for RXAUI */
+	mvebu_cp110_comphy_set_phy_selector(priv, comphy);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_cp110_comphy_xfi_power_on(struct mvebu_comphy_priv *priv,
+					   struct mvebu_comphy *comphy)
+{
+	void __iomem *hpipe_addr, *sd_ip_addr, *comphy_addr, *addr;
+	u32 mask, data;
+	int ret = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
+	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
+	comphy_addr = COMPHY_ADDR(priv->comphy_regs, comphy->index);
+
+	/* configure phy selector for XFI/SFI */
+	mvebu_cp110_comphy_set_phy_selector(priv, comphy);
+
+	dev_dbg(priv->dev, "stage: RFU configurations - hard reset comphy\n");
+	/* RFU configurations - hard reset comphy */
+	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
+	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
+	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
+	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
+	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
+
+	/* Make sure that 40 data bits is disabled
+	 * This bit is not cleared by reset
+	 */
+	mask = COMMON_PHY_CFG6_IF_40_SEL_MASK;
+	data = 0 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET;
+	reg_set(comphy_addr + COMMON_PHY_CFG6_REG, data, mask);
+
+	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
+	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
+	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
+	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
+	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
+	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
+	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
+	data |= 0 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
+
+	/* release from hard reset */
+	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
+	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
+	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
+	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+
+	/* Wait 1ms - until band gap and ref clock ready */
+	mdelay(1);
+
+	/* Start comphy Configuration */
+	dev_dbg(priv->dev, "stage: Comphy configuration\n");
+	/* set reference clock */
+	mask = HPIPE_MISC_ICP_FORCE_MASK;
+	data = 0x1 << HPIPE_MISC_ICP_FORCE_OFFSET;
+	mask |= HPIPE_MISC_REFCLK_SEL_MASK;
+	data |= 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
+	/* Power and PLL Control */
+	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
+	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
+	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
+	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
+	/* Loopback register */
+	mask = HPIPE_LOOPBACK_SEL_MASK;
+	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
+	/* rx control 1 */
+	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
+	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
+	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
+	data |= 0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
+	/* DTL Control */
+	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
+	data = 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
+
+	/* Set analog parameters from ETP(HW) */
+	dev_dbg(priv->dev, "stage: Analog parameters from ETP(HW)\n");
+	/* SERDES External Configuration 2 */
+	mask = SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG, data, mask);
+	/* 0x7-DFE Resolution control */
+	mask = HPIPE_DFE_RES_FORCE_MASK;
+	data = 0x1 << HPIPE_DFE_RES_FORCE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
+	/* 0xd-G1_Setting_0 */
+	mask = HPIPE_G1_SET_0_G1_TX_AMP_MASK;
+	data = 0x1c << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET;
+	mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
+	data |= 0xe << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG, data, mask);
+	/* Genration 1 setting 2 (G1_Setting_2) */
+	mask = HPIPE_G1_SET_2_G1_TX_EMPH0_MASK;
+	data = 0x0 << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET;
+	mask |= HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK;
+	data |= 0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SET_2_REG, data, mask);
+	/* Transmitter Slew Rate Control register (tx_reg1) */
+	mask = HPIPE_TX_REG1_TX_EMPH_RES_MASK;
+	data = 0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET;
+	mask |= HPIPE_TX_REG1_SLC_EN_MASK;
+	data |= 0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_TX_REG1_REG, data, mask);
+	/* Impedance Calibration Control register (cal_reg1) */
+	mask = HPIPE_CAL_REG_1_EXT_TXIMP_MASK;
+	data = 0xe << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
+	mask |= HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK;
+	data |= 0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_CAL_REG1_REG, data, mask);
+	/* Generation 1 Setting 5 (g1_setting_5) */
+	mask = HPIPE_G1_SETTING_5_G1_ICP_MASK;
+	data = 0 << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SETTING_5_REG, data, mask);
+	/* 0xE-G1_Setting_1 */
+	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
+	data = 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
+	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
+	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
+	mask |= HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK;
+	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
+	/* 0xA-DFE_Reg3 */
+	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
+	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
+	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
+	data |= 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
+
+	/* 0x111-G1_Setting_4 */
+	mask = HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK;
+	data = 0x1 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_4_REG, data, mask);
+	/* Genration 1 setting 3 (G1_Setting_3) */
+	mask = HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK;
+	data = 0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
+
+	dev_dbg(priv->dev, "stage: RFU configurations- Power Up PLL,Tx,Rx\n");
+	/* SERDES External Configuration */
+	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
+
+	/* check PLL rx & tx ready */
+	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
+	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK | SD_EXTERNAL_STATUS0_PLL_TX_MASK;
+	mask = data;
+	data = polling_with_timeout(addr, data, mask, 15000);
+	if (data != 0) {
+		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
+			dev_err(priv->dev, "RX PLL is not locked\n");
+		if (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK)
+			dev_err(priv->dev, "TX PLL is not locked\n");
+
+		ret = -ETIMEDOUT;
+	}
+
+	/* RX init */
+	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
+	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	/* check that RX init done */
+	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
+	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
+	mask = data;
+	data = polling_with_timeout(addr, data, mask, 100);
+	if (data != 0) {
+		dev_err(priv->dev, "RX init failed\n");
+		ret = -ETIMEDOUT;
+	}
+
+	dev_dbg(priv->dev, "stage: RF Reset\n");
+	/* RF Reset */
+	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
+	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
+	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
+	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+
+	return ret;
+}
+
+static int mvebu_cp110_comphy_power_on(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+	int err = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	switch (mode) {
+	case(COMPHY_SATA_MODE):
+		err = mvebu_cp110_comphy_sata_power_on(priv, comphy);
+		break;
+
+	case(COMPHY_SGMII_MODE):
+	case(COMPHY_HS_SGMII_MODE):
+		err = mvebu_cp110_comphy_sgmii_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_USB3H_MODE):
+	case (COMPHY_USB3D_MODE):
+		err = mvebu_cp110_comphy_usb3_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_PCIE_MODE):
+		err = mvebu_cp110_comphy_pcie_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_RXAUI_MODE):
+		err = mvebu_cp110_comphy_rxaui_power_on(priv, comphy);
+		break;
+	/* From comphy perspective, XFI and SFI are the same */
+	case (COMPHY_XFI_MODE):
+	case (COMPHY_SFI_MODE):
+		err = mvebu_cp110_comphy_xfi_power_on(priv, comphy);
+		break;
+
+	default:
+		dev_err(priv->dev, "comphy%d: unsupported comphy mode\n",
+			comphy->index);
+		err = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return err;
+}
+
+static int mvebu_cp110_comphy_power_off(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	/* Clear comphy selector, can't rely on u-boot */
+	mvebu_cp110_comphy_clr_phy_selector(priv, comphy);
+
+	dev_dbg(priv->dev, "power off is not implemented\n");
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
+static int mvebu_cp110_comphy_is_pll_locked(struct phy *phy)
+{
+
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	void __iomem *sd_ip_addr, *addr;
+	u32 mask, data;
+	int ret = 0;
+
+	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
+
+	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
+	data = SD_EXTERNAL_STATUS0_PLL_TX_MASK & SD_EXTERNAL_STATUS0_PLL_RX_MASK;
+	mask = data;
+	data = polling_with_timeout(addr, data, mask, PLL_LOCK_TIMEOUT);
+	if (data != 0) {
+		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
+			dev_err(priv->dev, "RX PLL is not locked\n");
+		if (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK)
+			dev_err(priv->dev, "TX PLL is not locked\n");
+
+		ret = -ETIMEDOUT;
+	}
+
+	return ret;
+}
+
+static struct phy_ops cp110_comphy_ops = {
+	.power_on	= mvebu_cp110_comphy_power_on,
+	.power_off	= mvebu_cp110_comphy_power_off,
+	.set_mode	= mvebu_comphy_set_mode,
+	.get_mode	= mvebu_comphy_get_mode,
+	.is_pll_locked  = mvebu_cp110_comphy_is_pll_locked,
+	.owner		= THIS_MODULE,
+};
+
+/* For CP-110 there are 2 Selector registers "PHY Selectors"
+ * and "PIPE Selectors".
+ *	- PIPE selector include USB and PCIe options.
+ *	- PHY selector include the Ethernet and SATA options.
+ *	  every Ethernet option has different options,
+ *	  for example: serdes lane2 had option Eth_port_0 that include
+ *	  (SGMII0, XAUI0, RXAUI0, XFI, SFI)
+ */
+const struct mvebu_comphy_soc_info cp110_comphy = {
+	.num_of_lanes = 6,
+	.functions = {
+		/* Lane 0 */
+		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1,
+		 COMPHY_SATA1, COMPHY_PCIE0},
+		/* Lane 1 */
+		{COMPHY_UNUSED, COMPHY_SGMII2, COMPHY_HS_SGMII2,
+		 COMPHY_SATA0, COMPHY_USB3H0, COMPHY_USB3D0, COMPHY_PCIE0},
+		/* Lane 2 */
+		{COMPHY_UNUSED, COMPHY_SGMII0, COMPHY_HS_SGMII0, COMPHY_RXAUI0,
+		 COMPHY_XFI, COMPHY_SFI, COMPHY_SATA0, COMPHY_USB3H0,
+		 COMPHY_PCIE0},
+		/* Lane 3 */
+		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1, COMPHY_RXAUI1,
+		 COMPHY_SATA1, COMPHY_USB3H1, COMPHY_PCIE0},
+		/* Lane 4 */
+		{COMPHY_UNUSED, COMPHY_SGMII0, COMPHY_HS_SGMII0, COMPHY_SGMII1,
+		 COMPHY_HS_SGMII1, COMPHY_RXAUI0, COMPHY_XFI, COMPHY_SFI,
+		 COMPHY_USB3H1, COMPHY_USB3D0, COMPHY_PCIE1},
+		/* Lane 5 */
+		{COMPHY_UNUSED, COMPHY_RXAUI1, COMPHY_SGMII2, COMPHY_HS_SGMII2,
+		 COMPHY_SATA1, COMPHY_PCIE2},
+	},
+	.comphy_ops = &cp110_comphy_ops,
+};
+
diff --git a/drivers/phy/phy-comphy-cp110.h b/drivers/phy/phy-comphy-cp110.h
new file mode 100644
index 0000000..46a9783
--- /dev/null
+++ b/drivers/phy/phy-comphy-cp110.h
@@ -0,0 +1,236 @@
+#ifndef _COMPHY_CP110_H
+#define _COMPHY_CP110_H
+
+extern const struct mvebu_comphy_soc_info cp110_comphy;
+
+#define SD_ADDR(base, lane)			(base + 0x1000 * lane)
+#define HPIPE_ADDR(base, lane)			(SD_ADDR(base, lane) + 0x800)
+#define COMPHY_ADDR(base, lane)			(base + 0x28 * lane)
+
+/* Comphy registers */
+#define COMMON_PHY_CFG1_REG			0x0
+#define COMMON_PHY_CFG1_PWR_UP_OFFSET		1
+#define COMMON_PHY_CFG1_PWR_UP_MASK		(0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET)
+#define COMMON_PHY_CFG1_PIPE_SELECT_OFFSET	2
+#define COMMON_PHY_CFG1_PIPE_SELECT_MASK	(0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET)
+#define COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET	13
+#define COMMON_PHY_CFG1_PWR_ON_RESET_MASK	(0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET)
+#define COMMON_PHY_CFG1_CORE_RSTN_OFFSET	14
+#define COMMON_PHY_CFG1_CORE_RSTN_MASK		(0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET)
+
+#define COMMON_PHY_CFG6_REG			0x14
+#define COMMON_PHY_CFG6_IF_40_SEL_OFFSET	18
+#define COMMON_PHY_CFG6_IF_40_SEL_MASK		(0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET)
+
+#define COMMON_PHY_CFG6_REG			0x14
+#define COMMON_PHY_CFG6_IF_40_SEL_OFFSET	18
+#define COMMON_PHY_CFG6_IF_40_SEL_MASK		(0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET)
+
+#define COMMON_SELECTOR_PHY_REG_OFFSET		0x140
+#define COMMON_SELECTOR_PIPE_REG_OFFSET		0x144
+#define COMMON_SELECTOR_COMPHY_MASK		0xf
+#define COMMON_SELECTOR_COMPHYN_FIELD_WIDTH	4
+#define COMMON_SELECTOR_COMPHYN_SATA		0x4
+#define COMMON_SELECTOR_COMPHY0_1_2_NETWORK	0x1
+#define COMMON_SELECTOR_COMPHY3_RXAUI		0x1
+#define COMMON_SELECTOR_COMPHY3_SGMII		0x2
+#define COMMON_SELECTOR_COMPHY4_SGMII2		0x1
+#define COMMON_SELECTOR_COMPHY4_ALL_OTHERS	0x2
+#define COMMON_SELECTOR_COMPHY5_RXAUI		0x2
+#define COMMON_SELECTOR_COMPHY5_SGMII		0x1
+
+/* SerDes IP registers */
+#define SD_EXTERNAL_CONFIG0_REG				0
+#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET		1
+#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK		(1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET)
+#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET	3
+#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK		(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET)
+#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET	7
+#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK		(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET)
+#define SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET		11
+#define SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK		(1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET)
+#define SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET		12
+#define SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK		(1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET)
+#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET	14
+#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK		(1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET)
+
+#define SD_EXTERNAL_CONFIG1_REG			0x4
+#define SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET	3
+#define SD_EXTERNAL_CONFIG1_RESET_IN_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET)
+#define SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET	4
+#define SD_EXTERNAL_CONFIG1_RX_INIT_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET)
+#define SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET	5
+#define SD_EXTERNAL_CONFIG1_RESET_CORE_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET)
+#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET	6
+#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET)
+
+#define SD_EXTERNAL_CONFIG2_REG			0x8
+#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET	4
+#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK	(0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET)
+
+#define SD_EXTERNAL_STATUS0_REG			0x18
+#define SD_EXTERNAL_STATUS0_PLL_TX_OFFSET	2
+#define SD_EXTERNAL_STATUS0_PLL_TX_MASK		(0x1 << SD_EXTERNAL_STATUS0_PLL_TX_OFFSET)
+#define SD_EXTERNAL_STATUS0_PLL_RX_OFFSET	3
+#define SD_EXTERNAL_STATUS0_PLL_RX_MASK		(0x1 << SD_EXTERNAL_STATUS0_PLL_RX_OFFSET)
+#define SD_EXTERNAL_STATUS0_RX_INIT_OFFSET	4
+#define SD_EXTERNAL_STATUS0_RX_INIT_MASK	(0x1 << SD_EXTERNAL_STATUS0_RX_INIT_OFFSET)
+
+/* HPIPE registers */
+#define HPIPE_PWR_PLL_REG			0x4
+#define HPIPE_PWR_PLL_REF_FREQ_OFFSET		0
+#define HPIPE_PWR_PLL_REF_FREQ_MASK		(0x1f << HPIPE_PWR_PLL_REF_FREQ_OFFSET)
+#define HPIPE_PWR_PLL_PHY_MODE_OFFSET		5
+#define HPIPE_PWR_PLL_PHY_MODE_MASK		(0x7 << HPIPE_PWR_PLL_PHY_MODE_OFFSET)
+
+#define HPIPE_CAL_REG1_REG			0xc
+#define HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET	10
+#define HPIPE_CAL_REG_1_EXT_TXIMP_MASK		(0x1f << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET)
+#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET	15
+#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK	(0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET)
+
+#define HPIPE_DFE_REG0				0x1c
+#define HPIPE_DFE_RES_FORCE_OFFSET		15
+#define HPIPE_DFE_RES_FORCE_MASK		(0x1 << HPIPE_DFE_RES_FORCE_OFFSET)
+
+#define HPIPE_DFE_F3_F5_REG			0x28
+#define HPIPE_DFE_F3_F5_DFE_EN_OFFSET		14
+#define HPIPE_DFE_F3_F5_DFE_EN_MASK		(0x1 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET)
+#define HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET		15
+#define HPIPE_DFE_F3_F5_DFE_CTRL_MASK		(0x1 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET)
+
+#define HPIPE_G1_SET_0_REG			0x34
+#define HPIPE_G1_SET_0_G1_TX_AMP_OFFSET		1
+#define HPIPE_G1_SET_0_G1_TX_AMP_MASK		(0x1f << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET)
+#define HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET	7
+#define HPIPE_G1_SET_0_G1_TX_EMPH1_MASK		(0xf << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET)
+
+#define HPIPE_G1_SET_1_REG			0x38
+#define HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET	0
+#define HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET)
+#define HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET	3
+#define HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET)
+#define HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET	6
+#define HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET)
+#define HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET	8
+#define HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET)
+#define HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET	10
+#define HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK	(0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET)
+#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET	11
+#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK	(0x3 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET)
+
+#define HPIPE_G2_SET_1_REG			0x40
+#define HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET	0
+#define HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET)
+#define HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET	3
+#define HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET)
+#define HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET	6
+#define HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET)
+#define HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET	8
+#define HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET)
+#define HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET	10
+#define HPIPE_G2_SET_1_G2_RX_DFE_EN_MASK	(0x1 << HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET)
+#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET	11
+#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK	(0x3 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET)
+
+#define HPIPE_G3_SET_1_REG				0x48
+#define HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET		0
+#define HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK		(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET)
+#define HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET		3
+#define HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK		(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET)
+#define HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET		6
+#define HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK		(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET)
+#define HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET		8
+#define HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK		(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET)
+#define HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET		10
+#define HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK		(0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET)
+#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET		11
+#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK		(0x3 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET)
+#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET	13
+#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK	(0x1 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET)
+
+#define HPIPE_LOOPBACK_REG			0x8c
+#define HPIPE_LOOPBACK_SEL_OFFSET		1
+#define HPIPE_LOOPBACK_SEL_MASK			(0x7 << HPIPE_LOOPBACK_SEL_OFFSET)
+
+#define HPIPE_INTERFACE_REG			0x94
+#define HPIPE_INTERFACE_GEN_MAX_OFFSET		10
+#define HPIPE_INTERFACE_GEN_MAX_MASK		(0x3 << HPIPE_INTERFACE_GEN_MAX_OFFSET)
+
+#define HPIPE_G1_SET_2_REG			0xf4
+#define HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET	0
+#define HPIPE_G1_SET_2_G1_TX_EMPH0_MASK		(0xf << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET)
+#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET	4
+#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK	(0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_MASK)
+
+#define HPIPE_MISC_REG				0x13C
+#define HPIPE_MISC_ICP_FORCE_OFFSET		5
+#define HPIPE_MISC_ICP_FORCE_MASK		(0x1 << HPIPE_MISC_ICP_FORCE_OFFSET)
+#define HPIPE_MISC_REFCLK_SEL_OFFSET		10
+#define HPIPE_MISC_REFCLK_SEL_MASK		(0x1 << HPIPE_MISC_REFCLK_SEL_OFFSET)
+
+#define HPIPE_RX_CONTROL_1_REG			0x140
+#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET	11
+#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK	(0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET)
+#define HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET	12
+#define HPIPE_RX_CONTROL_1_CLK8T_EN_MASK	(0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET)
+
+#define HPIPE_PWR_CTR_REG			0x148
+#define HPIPE_PWR_CTR_RST_DFE_OFFSET		0
+#define HPIPE_PWR_CTR_RST_DFE_MASK		(0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET)
+#define HPIPE_PWR_CTR_SFT_RST_OFFSET		10
+#define HPIPE_PWR_CTR_SFT_RST_MASK		(0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET)
+
+#define HPIPE_TX_REG1_REG			0x174
+#define HPIPE_TX_REG1_TX_EMPH_RES_OFFSET	5
+#define HPIPE_TX_REG1_TX_EMPH_RES_MASK		(0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET)
+#define HPIPE_TX_REG1_SLC_EN_OFFSET		10
+#define HPIPE_TX_REG1_SLC_EN_MASK		(0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET)
+
+#define HPIPE_PWR_CTR_DTL_REG				0x184
+#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET		0
+#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK		(0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET)
+#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET		1
+#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK		(0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET)
+#define HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET		2
+#define HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK			(0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET)
+#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET		4
+#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK		(0x7 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET)
+#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET	10
+#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK	(0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET)
+#define HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET		12
+#define HPIPE_PWR_CTR_DTL_CLK_MODE_MASK			(0x3 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET)
+#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET		14
+#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK		(1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET)
+
+#define HPIPE_PWR_CTR_DTL_REG			0x184
+#define HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET	2
+#define HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK		(0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET)
+
+#define HPIPE_G1_SETTINGS_3_REG				0x440
+#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET	0
+#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK		(0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET)
+#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET	4
+#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK		(0x7 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET)
+#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET	7
+#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK	(0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET)
+#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET		9
+#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK		(0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET)
+#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET	12
+#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET)
+#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET	14
+#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET)
+
+#define HPIPE_G1_SETTINGS_4_REG			0x444
+#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET	8
+#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK	(0x3 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET)
+
+#define HPIPE_G1_SETTING_5_REG			0x538
+#define HPIPE_G1_SETTING_5_G1_ICP_OFFSET	0
+#define HPIPE_G1_SETTING_5_G1_ICP_MASK		(0xf << HPIPE_G1_SETTING_5_G1_ICP_OFFSET)
+
+/* General defines */
+#define PLL_LOCK_TIMEOUT			15000
+
+#endif /* _COMPHY_CP110_H */
+
diff --git a/drivers/phy/phy-comphy-mvebu.c b/drivers/phy/phy-comphy-mvebu.c
new file mode 100644
index 0000000..fbaa4d5
--- /dev/null
+++ b/drivers/phy/phy-comphy-mvebu.c
@@ -0,0 +1,199 @@
+/*
+ * Marvell comphy driver
+ *
+ * Copyright (C) 2016 Marvell
+ *
+ * Igal Liberman <igall@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
+
+#include "phy-comphy-mvebu.h"
+#include "phy-comphy-cp110.h"
+
+/* mvebu_comphy_set_mode: shared by all SoCs */
+int mvebu_comphy_set_mode(struct phy *phy, enum phy_mode mode)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	int i;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	for (i = 0; i < MVEBU_COMPHY_FUNC_MAX; i++)
+		if (priv->soc_info->functions[comphy->index][i] == (int)mode)
+			break;
+
+	if (i == MVEBU_COMPHY_FUNC_MAX) {
+		dev_err(priv->dev, "can't set mode 0x%x for COMPHY%d\n",
+			mode, comphy->index);
+		return -EINVAL;
+	}
+
+	priv->lanes[comphy->index].mode = (int)mode;
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
+/* mvebu_comphy_get_mode: shared by all SoCs */
+enum phy_mode mvebu_comphy_get_mode(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	int mode;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	mode = priv->lanes[comphy->index].mode;
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return (enum phy_mode)mode;
+}
+
+static const struct of_device_id mvebu_comphy_of_match[] = {
+#ifdef CONFIG_PHY_MVEBU_COMPHY_CP110
+	{ .compatible = "marvell,cp110-comphy", .data = &cp110_comphy },
+#endif /* CONFIG_PHY_MVEBU_COMPHY_CP110 */
+	{ },
+};
+MODULE_DEVICE_TABLE(of, mvebu_comphy_of_match);
+
+/**
+ * mvebu_comphy_of_xlate
+ *
+ * @dev - pointer to the device structure
+ * @args - pointer to the lane information (id and mode from the device-tree).
+ *
+ * This callback is registered during probe and called by the generic phy
+ * infrastructure when phy consumer calls 'devm_of_phy_get'.
+ * This function has 2 purposes:
+ *	- Check if the requested configuration is valid.
+ *	- Update comphy internal structure with the configuration for the
+ *	  specific lane (by default, all lanes set to 'COMPHY_UNUSED'.
+ *
+ * Return: pointer to the associated phy (on success), error code otherwise
+ */
+static struct phy *mvebu_comphy_of_xlate(struct device *dev,
+					 struct of_phandle_args *args)
+{
+	struct mvebu_comphy_priv *priv = dev_get_drvdata(dev);
+	int lane = args->args[0];
+	int mode = args->args[1];
+	int i;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	if (lane >= (int)priv->soc_info->num_of_lanes) {
+		dev_err(dev, "Wrong lane number %d for PHY, max is %d\n",
+			lane, priv->soc_info->num_of_lanes);
+		return ERR_PTR(-ENODEV);
+	}
+
+	for (i = 0; i < MVEBU_COMPHY_FUNC_MAX; i++)
+		if (priv->soc_info->functions[lane][i] == mode)
+			break;
+
+	if (i == MVEBU_COMPHY_FUNC_MAX) {
+		dev_err(dev, "Wrong mode 0x%x for COMPHY\n", mode);
+		return ERR_PTR(-ENODEV);
+	}
+
+	priv->lanes[lane].mode = mode;
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return priv->lanes[lane].phy;
+}
+
+static int mvebu_comphy_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	struct mvebu_comphy_priv *priv;
+	struct resource *res;
+	struct phy_provider *phy_provider;
+	const struct mvebu_comphy_soc_info *soc_info;
+	int i;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	match = of_match_device(mvebu_comphy_of_match, &pdev->dev);
+	soc_info = match->data;
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "comphy");
+	priv->comphy_regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->comphy_regs))
+		return PTR_ERR(priv->comphy_regs);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "serdes");
+	priv->comphy_pipe_regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->comphy_pipe_regs))
+		return PTR_ERR(priv->comphy_pipe_regs);
+
+	priv->soc_info = soc_info;
+	priv->dev = &pdev->dev;
+	spin_lock_init(&priv->lock);
+
+	for (i = 0; i < soc_info->num_of_lanes; i++) {
+		struct phy *phy;
+
+		phy = devm_phy_create(&pdev->dev, NULL, soc_info->comphy_ops);
+		if (IS_ERR(phy)) {
+			dev_err(&pdev->dev, "failed to create PHY\n");
+			return PTR_ERR(phy);
+		}
+
+		/* In this stage we have no information regarding comphy
+		 * configuration so we set all comphys to UNUSED.
+		 * Later, when all interfaces are probed, each interface
+		 * is responsible of calling to power_on call back for
+		 * comphy configuration.
+		 */
+		priv->lanes[i].phy = phy;
+		priv->lanes[i].index = i;
+		priv->lanes[i].mode = COMPHY_UNUSED;
+		phy_set_drvdata(phy, &priv->lanes[i]);
+
+		soc_info->comphy_ops->power_off(phy);
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	phy_provider = devm_of_phy_provider_register(&pdev->dev,
+						     mvebu_comphy_of_xlate);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static struct platform_driver mvebu_comphy_driver = {
+	.probe	= mvebu_comphy_probe,
+	.driver	= {
+		.name		= "phy-mvebu-comphy",
+		.owner		= THIS_MODULE,
+		.of_match_table	= mvebu_comphy_of_match,
+	 },
+};
+module_platform_driver(mvebu_comphy_driver);
+
+MODULE_AUTHOR("Igal Liberman <igall@marvell.com>");
+MODULE_DESCRIPTION("Marvell EBU COMPHY driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/phy/phy-comphy-mvebu.h b/drivers/phy/phy-comphy-mvebu.h
new file mode 100644
index 0000000..0ce26cf
--- /dev/null
+++ b/drivers/phy/phy-comphy-mvebu.h
@@ -0,0 +1,62 @@
+#ifndef _COMPHY_MVEBU_H
+#define _COMPHY_MVEBU_H
+
+#define MVEBU_COMPHY_MAX_CNT	6
+#define MVEBU_COMPHY_FUNC_MAX	11
+
+#define to_mvebu_comphy_priv(lane) \
+	container_of((lane), struct mvebu_comphy_priv, lanes[(lane)->index])
+
+struct mvebu_comphy_priv {
+	struct device *dev;
+	void __iomem *comphy_regs;
+	void __iomem *comphy_pipe_regs;
+	spinlock_t lock;
+	const struct mvebu_comphy_soc_info *soc_info;
+	struct mvebu_comphy {
+		struct phy *phy;
+		int mode;
+		int index;
+	} lanes[MVEBU_COMPHY_MAX_CNT];
+};
+
+struct mvebu_comphy_soc_info {
+	int num_of_lanes;
+	int functions[MVEBU_COMPHY_MAX_CNT][MVEBU_COMPHY_FUNC_MAX];
+	struct phy_ops *comphy_ops;
+};
+
+static inline void __maybe_unused reg_set(void __iomem *addr, u32 data, u32 mask)
+{
+	u32 reg_data;
+
+	reg_data = readl(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writel(reg_data, addr);
+}
+
+static inline u32 __maybe_unused polling_with_timeout(void __iomem *addr,
+						      u32 val,
+						      u32 mask,
+						      unsigned long usec_timout)
+{
+	u32 data;
+
+	do {
+		udelay(1);
+		data = readl(addr) & mask;
+	} while (data != val  && --usec_timout > 0);
+
+	if (usec_timout == 0)
+		return data;
+
+	return 0;
+}
+
+/* Function declaration */
+int mvebu_comphy_set_mode(struct phy *phy, enum phy_mode mode);
+enum phy_mode mvebu_comphy_get_mode(struct phy *phy);
+
+#endif /* _COMPHY_MVEBU_H */
+
diff --git a/drivers/phy/phy-mvebu-comphy.c b/drivers/phy/phy-mvebu-comphy.c
deleted file mode 100644
index c17debf..0000000
--- a/drivers/phy/phy-mvebu-comphy.c
+++ /dev/null
@@ -1,1040 +0,0 @@
-/*
- * Marvell comphy driver
- *
- * Copyright (C) 2016 Marvell
- *
- * Igal Liberman <igall@marvell.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/phy/phy.h>
-#include <linux/platform_device.h>
-#include <dt-bindings/phy/phy-mvebu-comphy.h>
-
-#include "phy-mvebu-comphy.h"
-
-#define MVEBU_COMPHY_MAX_CNT	6
-#define MVEBU_COMPHY_FUNC_MAX	11
-
-#define to_mvebu_comphy_priv(lane) \
-	container_of((lane), struct mvebu_comphy_priv, lanes[(lane)->index])
-
-struct mvebu_comphy_priv {
-	struct device *dev;
-	void __iomem *comphy_regs;
-	void __iomem *comphy_pipe_regs;
-	spinlock_t lock;
-	const struct mvebu_comphy_soc_info *sinfo;
-	struct mvebu_comphy {
-		struct phy *phy;
-		int mode;
-		int index;
-	} lanes[MVEBU_COMPHY_MAX_CNT];
-};
-
-struct mvebu_comphy_soc_info {
-	int num_of_lanes;
-	int functions[MVEBU_COMPHY_MAX_CNT][MVEBU_COMPHY_FUNC_MAX];
-};
-
-/* For CP-110 there are 2 Selector registers "PHY Selectors"
- * and "PIPE Selectors".
- *	- PIPE selector include USB and PCIe options.
- *	- PHY selector include the Ethernet and SATA options.
- *	  every Ethernet option has different options,
- *	  for example: serdes lane2 had option Eth_port_0 that include
- *	  (SGMII0, XAUI0, RXAUI0, XFI, SFI)
- */
-static const struct mvebu_comphy_soc_info cp110_comphy = {
-	.num_of_lanes = 6,
-	.functions = {
-		/* Lane 0 */
-		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1,
-		 COMPHY_SATA1, COMPHY_PCIE0},
-		/* Lane 1 */
-		{COMPHY_UNUSED, COMPHY_SGMII2, COMPHY_HS_SGMII2,
-		 COMPHY_SATA0, COMPHY_USB3H0, COMPHY_USB3D0, COMPHY_PCIE0},
-		/* Lane 2 */
-		{COMPHY_UNUSED, COMPHY_SGMII0, COMPHY_HS_SGMII0, COMPHY_RXAUI0,
-		 COMPHY_XFI, COMPHY_SFI, COMPHY_SATA0, COMPHY_USB3H0,
-		 COMPHY_PCIE0},
-		/* Lane 3 */
-		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1, COMPHY_RXAUI1,
-		 COMPHY_SATA1, COMPHY_USB3H1, COMPHY_PCIE0},
-		/* Lane 4 */
-		{COMPHY_UNUSED, COMPHY_SGMII0, COMPHY_HS_SGMII0, COMPHY_SGMII1,
-		 COMPHY_HS_SGMII1, COMPHY_RXAUI0, COMPHY_XFI, COMPHY_SFI,
-		 COMPHY_USB3H1, COMPHY_USB3D0, COMPHY_PCIE1},
-		/* Lane 5 */
-		{COMPHY_UNUSED, COMPHY_RXAUI1, COMPHY_SGMII2, COMPHY_HS_SGMII2,
-		 COMPHY_SATA1, COMPHY_PCIE2},
-	},
-};
-
-static void __maybe_unused reg_set(void __iomem *addr, u32 data, u32 mask)
-{
-	u32 reg_data;
-
-	reg_data = readl(addr);
-	reg_data &= ~mask;
-	reg_data |= data;
-	writel(reg_data, addr);
-}
-
-u32 __maybe_unused polling_with_timeout(void __iomem *addr, u32 val, u32 mask,
-					unsigned long usec_timout)
-{
-	u32 data;
-
-	do {
-		udelay(1);
-		data = readl(addr) & mask;
-	} while (data != val  && --usec_timout > 0);
-
-	if (usec_timout == 0)
-		return data;
-
-	return 0;
-}
-
-/* Clear PHY selector - avoid collision with prior u-boot configuration */
-static void mvebu_comphy_clr_phy_selector(struct mvebu_comphy_priv *priv,
-					  struct mvebu_comphy *comphy)
-{
-	u32 reg, mask, field;
-	u32 comphy_offset = COMMON_SELECTOR_COMPHYN_FIELD_WIDTH * comphy->index;
-
-	mask = COMMON_SELECTOR_COMPHY_MASK << comphy_offset;
-	reg = readl(priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
-	field = reg & mask;
-
-	/* Clear comphy selector - if it was set by u-boot.
-	 * (might be that this comphy was configured as PCIe/USB,
-	 * in such case, no need to clear comphy selector because PCIe/USB
-	 * are controlled by hpipe selector.
-	 */
-	if (field) {
-		reg &= ~mask;
-		writel(reg, priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
-	}
-}
-
-/* PHY selector configures SATA and Network modes */
-static void mvebu_comphy_set_phy_selector(struct mvebu_comphy_priv *priv,
-					  struct mvebu_comphy *comphy)
-{
-	u32 reg, mask;
-	u32 comphy_offset = COMMON_SELECTOR_COMPHYN_FIELD_WIDTH * comphy->index;
-	int mode;
-
-	/* Comphy mode (compound of the IO mode and id) is stored during
-	 * the execution of mvebu_comphy_of_xlate.
-	 * Here, only the IO mode is required to distinguish between SATA and
-	 * network modes.
-	 */
-	mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
-
-	mask = COMMON_SELECTOR_COMPHY_MASK << comphy_offset;
-	reg = readl(priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
-	reg &= ~mask;
-
-	/* SATA port 0/1 require the same configuration */
-	if (mode == COMPHY_SATA_MODE) {
-		/* SATA selector values is always 4 */
-		reg |= COMMON_SELECTOR_COMPHYN_SATA << comphy_offset;
-	} else {
-		switch (comphy->index) {
-		case(0):
-		case(1):
-		case(2):
-			/* For comphy 0,1, and 2:
-			 *	Network selector value is always 1.
-			 */
-			reg |= COMMON_SELECTOR_COMPHY0_1_2_NETWORK << comphy_offset;
-			break;
-		case(3):
-			/* For comphy 3:
-			 * 0x1 = RXAUI_Lane1
-			 * 0x2 = SGMII/HS-SGMII Port1
-			 */
-			if (mode == COMPHY_RXAUI_MODE)
-				reg |= COMMON_SELECTOR_COMPHY3_RXAUI << comphy_offset;
-			else
-				reg |= COMMON_SELECTOR_COMPHY3_SGMII << comphy_offset;
-			break;
-		case(4):
-			 /* For comphy 4:
-			  * 0x1 = SGMII/HS-SGMII Port2
-			  * 0x2 = SGMII/HS-SGMII Port1: XFI/SFI, RXAUI_Lane0
-			  */
-			if (priv->lanes[comphy->index].mode == COMPHY_SGMII2 ||
-			    priv->lanes[comphy->index].mode == COMPHY_HS_SGMII2)
-				reg |= COMMON_SELECTOR_COMPHY4_SGMII2 << comphy_offset;
-			else
-				reg |= COMMON_SELECTOR_COMPHY4_ALL_OTHERS << comphy_offset;
-			break;
-		case(5):
-			/* For comphy 5:
-			 * 0x1 = SGMII/HS-SGMII Port2
-			 * 0x2 = RXAUI Lane1
-			 */
-			if (mode == COMPHY_RXAUI_MODE)
-				reg |= COMMON_SELECTOR_COMPHY5_RXAUI << comphy_offset;
-			else
-				reg |= COMMON_SELECTOR_COMPHY5_SGMII << comphy_offset;
-			break;
-		}
-	}
-
-	writel(reg, priv->comphy_regs + COMMON_SELECTOR_PHY_REG_OFFSET);
-
-}
-
-static int mvebu_comphy_sata_power_on(struct mvebu_comphy_priv *priv,
-				      struct mvebu_comphy *comphy)
-{
-	void __iomem *hpipe_addr, *sd_ip_addr, *comphy_addr;
-	u32 mask, data;
-	int ret = 0;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	/* configure phy selector for SATA */
-	mvebu_comphy_set_phy_selector(priv, comphy);
-
-	hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
-	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
-	comphy_addr = COMPHY_ADDR(priv->comphy_regs, comphy->index);
-
-	dev_dbg(priv->dev, "stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Set select data  width 40Bit - SATA mode only */
-	reg_set(comphy_addr + COMMON_PHY_CFG6_REG,
-		0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET, COMMON_PHY_CFG6_IF_40_SEL_MASK);
-
-	/* release from hard reset in SD external */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	dev_dbg(priv->dev, "stage: Comphy configuration\n");
-	/* Start comphy Configuration */
-	/* Set reference clock to comes from group 1 - choose 25Mhz */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET, HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Reference frequency select set 1 (for SATA = 25Mhz) */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	/* PHY mode select (set SATA = 0x0 */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x0 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Set max PHY generation setting - 6Gbps */
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG,
-		0x2 << HPIPE_INTERFACE_GEN_MAX_OFFSET, HPIPE_INTERFACE_GEN_MAX_MASK);
-	/* Set select data  width 40Bit (SEL_BITS[2:0]) */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x2 << HPIPE_LOOPBACK_SEL_OFFSET, HPIPE_LOOPBACK_SEL_MASK);
-
-	dev_dbg(priv->dev, "stage: Analog parameters from ETP(HW)\n");
-	/* G1 settings */
-	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-
-	mask = HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
-	data = 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
-	data |= 0x2 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
-
-	/* G2 settings */
-	mask = HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_1_REG, data, mask);
-
-	/* G3 settings */
-	mask = HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK;
-	data = 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK;
-	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK;
-	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK;
-	data |= 0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK;
-	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_1_REG, data, mask);
-
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK;
-	data = 0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* DFE reset sequence */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET, HPIPE_PWR_CTR_RST_DFE_MASK);
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x0 << HPIPE_PWR_CTR_RST_DFE_OFFSET, HPIPE_PWR_CTR_RST_DFE_MASK);
-	/* SW reset for interrupt logic */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET, HPIPE_PWR_CTR_SFT_RST_MASK);
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x0 << HPIPE_PWR_CTR_SFT_RST_OFFSET, HPIPE_PWR_CTR_SFT_RST_MASK);
-
-	dev_dbg(priv->dev, "stage: Comphy power up\n");
-
-	return ret;
-}
-
-static int mvebu_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
-				       struct mvebu_comphy *comphy)
-{
-	void __iomem *hpipe_addr, *sd_ip_addr, *comphy_addr, *addr;
-	u32 mask, data;
-	int ret = 0;
-	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
-	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
-	comphy_addr = COMPHY_ADDR(priv->comphy_regs, comphy->index);
-
-	/* configure phy selector for SGMII */
-	mvebu_comphy_set_phy_selector(priv, comphy);
-
-	/* Confiugre the lane */
-	dev_dbg(priv->dev, "stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-
-	if (mode == COMPHY_SGMII_MODE) {
-		/* SGMII 1G, SerDes speed 1.25G */
-		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	} else if (mode == COMPHY_HS_SGMII_MODE) {
-		/* HS SGMII (2.5G), SerDes speed 3.125G */
-		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	} else {
-		/* Other rates are not supported */
-		dev_err(priv->dev, "unsupported SGMII speed on comphy%d\n",
-			comphy->index);
-		return -EINVAL;
-	}
-
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* Set hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Release hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Make sure that 40 data bits is disabled
-	 * This bit is not cleared by reset
-	 */
-	mask = COMMON_PHY_CFG6_IF_40_SEL_MASK;
-	data = 0 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG6_REG, data, mask);
-
-	/* Start comphy Configuration */
-	dev_dbg(priv->dev, "stage: Comphy configuration\n");
-	/* set reference clock */
-	mask = HPIPE_MISC_REFCLK_SEL_MASK;
-	data = 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	mask = HPIPE_LOOPBACK_SEL_MASK;
-	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x0 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Set analog parameters from ETP(HW) - for now use the default datas */
-	dev_dbg(priv->dev, "stage: Analog parameters from ETP(HW)\n");
-
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG,
-		0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET, HPIPE_G1_SET_0_G1_TX_EMPH1_MASK);
-
-	dev_dbg(priv->dev, "stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK | SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
-			dev_err(priv->dev, "RX PLL is not locked\n");
-		if (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK)
-			dev_err(priv->dev, "TX PLL is not locked\n");
-
-		ret = -ETIMEDOUT;
-	}
-
-	/* RX init */
-	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		dev_err(priv->dev, "RX init failed\n");
-		ret = -ETIMEDOUT;
-	}
-
-	dev_dbg(priv->dev, "stage: RF Reset\n");
-	/* RF Reset */
-	mask =	SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	return ret;
-}
-
-static int mvebu_comphy_usb3_power_on(struct mvebu_comphy_priv *priv,
-				      struct mvebu_comphy *comphy)
-{
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	dev_err(priv->dev, "USB mode is not implemented\n");
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return -ENOTSUPP;
-}
-
-static int mvebu_comphy_pcie_power_on(struct mvebu_comphy_priv *priv,
-				      struct mvebu_comphy *comphy)
-{
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	dev_err(priv->dev, "PCIE mode is not implemented\n");
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return -ENOTSUPP;
-}
-
-static int mvebu_comphy_rxaui_power_on(struct mvebu_comphy_priv *priv,
-				       struct mvebu_comphy *comphy)
-{
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	dev_err(priv->dev, "RXAUI mode is not implemented\n");
-
-	/* configure phy selector for RXAUI */
-	mvebu_comphy_set_phy_selector(priv, comphy);
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return -ENOTSUPP;
-}
-
-static int mvebu_comphy_xfi_power_on(struct mvebu_comphy_priv *priv,
-				     struct mvebu_comphy *comphy)
-{
-	void __iomem *hpipe_addr, *sd_ip_addr, *comphy_addr, *addr;
-	u32 mask, data;
-	int ret = 0;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
-	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
-	comphy_addr = COMPHY_ADDR(priv->comphy_regs, comphy->index);
-
-	/* configure phy selector for XFI/SFI */
-	mvebu_comphy_set_phy_selector(priv, comphy);
-
-	dev_dbg(priv->dev, "stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Make sure that 40 data bits is disabled
-	 * This bit is not cleared by reset
-	 */
-	mask = COMMON_PHY_CFG6_IF_40_SEL_MASK;
-	data = 0 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG6_REG, data, mask);
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	dev_dbg(priv->dev, "stage: Comphy configuration\n");
-	/* set reference clock */
-	mask = HPIPE_MISC_ICP_FORCE_MASK;
-	data = 0x1 << HPIPE_MISC_ICP_FORCE_OFFSET;
-	mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-	data |= 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	mask = HPIPE_LOOPBACK_SEL_MASK;
-	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Set analog parameters from ETP(HW) */
-	dev_dbg(priv->dev, "stage: Analog parameters from ETP(HW)\n");
-	/* SERDES External Configuration 2 */
-	mask = SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG, data, mask);
-	/* 0x7-DFE Resolution control */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x1 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
-	/* 0xd-G1_Setting_0 */
-	mask = HPIPE_G1_SET_0_G1_TX_AMP_MASK;
-	data = 0x1c << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-	data |= 0xe << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG, data, mask);
-	/* Genration 1 setting 2 (G1_Setting_2) */
-	mask = HPIPE_G1_SET_2_G1_TX_EMPH0_MASK;
-	data = 0x0 << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET;
-	mask |= HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_2_REG, data, mask);
-	/* Transmitter Slew Rate Control register (tx_reg1) */
-	mask = HPIPE_TX_REG1_TX_EMPH_RES_MASK;
-	data = 0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET;
-	mask |= HPIPE_TX_REG1_SLC_EN_MASK;
-	data |= 0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_REG1_REG, data, mask);
-	/* Impedance Calibration Control register (cal_reg1) */
-	mask = HPIPE_CAL_REG_1_EXT_TXIMP_MASK;
-	data = 0xe << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
-	mask |= HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK;
-	data |= 0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_CAL_REG1_REG, data, mask);
-	/* Generation 1 Setting 5 (g1_setting_5) */
-	mask = HPIPE_G1_SETTING_5_G1_ICP_MASK;
-	data = 0 << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTING_5_REG, data, mask);
-	/* 0xE-G1_Setting_1 */
-	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-	data = 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-	/* 0xA-DFE_Reg3 */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data |= 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* 0x111-G1_Setting_4 */
-	mask = HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_4_REG, data, mask);
-	/* Genration 1 setting 3 (G1_Setting_3) */
-	mask = HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
-
-	dev_dbg(priv->dev, "stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK | SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
-			dev_err(priv->dev, "RX PLL is not locked\n");
-		if (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK)
-			dev_err(priv->dev, "TX PLL is not locked\n");
-
-		ret = -ETIMEDOUT;
-	}
-
-	/* RX init */
-	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		dev_err(priv->dev, "RX init failed\n");
-		ret = -ETIMEDOUT;
-	}
-
-	dev_dbg(priv->dev, "stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	return ret;
-}
-
-static int mvebu_comphy_power_on(struct phy *phy)
-{
-	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
-	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
-	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
-	int err = 0;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	spin_lock(&priv->lock);
-
-	switch (mode) {
-	case(COMPHY_SATA_MODE):
-		err = mvebu_comphy_sata_power_on(priv, comphy);
-		break;
-
-	case(COMPHY_SGMII_MODE):
-	case(COMPHY_HS_SGMII_MODE):
-		err = mvebu_comphy_sgmii_power_on(priv, comphy);
-		break;
-
-	case (COMPHY_USB3H_MODE):
-	case (COMPHY_USB3D_MODE):
-		err = mvebu_comphy_usb3_power_on(priv, comphy);
-		break;
-
-	case (COMPHY_PCIE_MODE):
-		err = mvebu_comphy_pcie_power_on(priv, comphy);
-		break;
-
-	case (COMPHY_RXAUI_MODE):
-		err = mvebu_comphy_rxaui_power_on(priv, comphy);
-		break;
-	/* From comphy perspective, XFI and SFI are the same */
-	case (COMPHY_XFI_MODE):
-	case (COMPHY_SFI_MODE):
-		err = mvebu_comphy_xfi_power_on(priv, comphy);
-		break;
-
-	default:
-		dev_err(priv->dev, "comphy%d: unsupported comphy mode\n",
-			comphy->index);
-		err = -EINVAL;
-		break;
-	}
-
-	spin_unlock(&priv->lock);
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return err;
-}
-
-static int mvebu_comphy_power_off(struct phy *phy)
-{
-	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
-	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	spin_lock(&priv->lock);
-
-	/* Clear comphy selector, can't rely on u-boot */
-	mvebu_comphy_clr_phy_selector(priv, comphy);
-
-	dev_dbg(priv->dev, "power off is not implemented\n");
-
-	spin_unlock(&priv->lock);
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return 0;
-}
-
-static int mvebu_comphy_set_mode(struct phy *phy, enum phy_mode mode)
-{
-	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
-	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
-	int i;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	for (i = 0; i < MVEBU_COMPHY_FUNC_MAX; i++)
-		if (priv->sinfo->functions[comphy->index][i] == (int)mode)
-			break;
-
-	if (i == MVEBU_COMPHY_FUNC_MAX) {
-		dev_err(priv->dev, "can't set mode 0x%x for COMPHY%d\n",
-			mode, comphy->index);
-		return -EINVAL;
-	}
-
-	priv->lanes[comphy->index].mode = (int)mode;
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return 0;
-}
-
-static enum phy_mode mvebu_comphy_get_mode(struct phy *phy)
-{
-	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
-	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
-	int mode;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	mode = priv->lanes[comphy->index].mode;
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return (enum phy_mode)mode;
-}
-
-static int mvebu_comphy_is_pll_locked(struct phy *phy)
-{
-
-	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
-	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
-	void __iomem *sd_ip_addr, *addr;
-	u32 mask, data;
-	int ret = 0;
-
-	sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
-
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_TX_MASK & SD_EXTERNAL_STATUS0_PLL_RX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, PLL_LOCK_TIMEOUT);
-	if (data != 0) {
-		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
-			dev_err(priv->dev, "RX PLL is not locked\n");
-		if (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK)
-			dev_err(priv->dev, "TX PLL is not locked\n");
-
-		ret = -ETIMEDOUT;
-	}
-
-	return ret;
-}
-
-static struct phy_ops mvebu_comphy_ops = {
-	.power_on	= mvebu_comphy_power_on,
-	.power_off	= mvebu_comphy_power_off,
-	.set_mode	= mvebu_comphy_set_mode,
-	.get_mode	= mvebu_comphy_get_mode,
-	.is_pll_locked  = mvebu_comphy_is_pll_locked,
-	.owner		= THIS_MODULE,
-};
-
-static const struct of_device_id mvebu_comphy_of_match[] = {
-	{ .compatible = "marvell,cp110-comphy", .data = &cp110_comphy },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, mvebu_comphy_of_match);
-
-/**
- * mvebu_comphy_of_xlate
- *
- * @dev - pointer to the device structure
- * @args - pointer to the lane information (id and mode from the device-tree).
- *
- * This callback is registered during probe and called by the generic phy
- * infrastructure when phy consumer calls 'devm_of_phy_get'.
- * This function has 2 purposes:
- *	- Check if the requested configuration is valid.
- *	- Update comphy internal structure with the configuration for the
- *	  specific lane (by default, all lanes set to 'COMPHY_UNUSED'.
- *
- * Return: pointer to the associated phy (on success), error code otherwise
- */
-static struct phy *mvebu_comphy_of_xlate(struct device *dev,
-					 struct of_phandle_args *args)
-{
-	struct mvebu_comphy_priv *priv = dev_get_drvdata(dev);
-	int lane = args->args[0];
-	int mode = args->args[1];
-	int i;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	if (lane >= (int)priv->sinfo->num_of_lanes) {
-		dev_err(dev, "Wrong lane number %d for PHY, max is %d\n",
-			lane, priv->sinfo->num_of_lanes);
-		return ERR_PTR(-ENODEV);
-	}
-
-	for (i = 0; i < MVEBU_COMPHY_FUNC_MAX; i++)
-		if (priv->sinfo->functions[lane][i] == mode)
-			break;
-
-	if (i == MVEBU_COMPHY_FUNC_MAX) {
-		dev_err(dev, "Wrong mode 0x%x for COMPHY\n", mode);
-		return ERR_PTR(-ENODEV);
-	}
-
-	priv->lanes[lane].mode = mode;
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return priv->lanes[lane].phy;
-}
-
-static int mvebu_comphy_probe(struct platform_device *pdev)
-{
-	const struct of_device_id *match;
-	struct mvebu_comphy_priv *priv;
-	struct resource *res;
-	struct phy_provider *phy_provider;
-	const struct mvebu_comphy_soc_info *sinfo;
-	int i;
-
-	dev_dbg(priv->dev, "%s: Enter\n", __func__);
-
-	match = of_match_device(mvebu_comphy_of_match, &pdev->dev);
-	sinfo = match->data;
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "comphy");
-	priv->comphy_regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(priv->comphy_regs))
-		return PTR_ERR(priv->comphy_regs);
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "serdes");
-	priv->comphy_pipe_regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(priv->comphy_pipe_regs))
-		return PTR_ERR(priv->comphy_pipe_regs);
-
-	priv->sinfo = sinfo;
-	priv->dev = &pdev->dev;
-	spin_lock_init(&priv->lock);
-
-	for (i = 0; i < sinfo->num_of_lanes; i++) {
-		struct phy *phy;
-
-		phy = devm_phy_create(&pdev->dev, NULL, &mvebu_comphy_ops);
-		if (IS_ERR(phy)) {
-			dev_err(&pdev->dev, "failed to create PHY\n");
-			return PTR_ERR(phy);
-		}
-
-		/* In this stage we have no information regarding comphy
-		 * configuration so we set all comphys to UNUSED.
-		 * Later, when all interfaces are probed, each interface
-		 * is responsible of calling to power_on call back for
-		 * comphy configuration.
-		 */
-		priv->lanes[i].phy = phy;
-		priv->lanes[i].index = i;
-		priv->lanes[i].mode = COMPHY_UNUSED;
-		phy_set_drvdata(phy, &priv->lanes[i]);
-
-		mvebu_comphy_power_off(phy);
-	}
-
-	platform_set_drvdata(pdev, priv);
-
-	phy_provider = devm_of_phy_provider_register(&pdev->dev,
-						     mvebu_comphy_of_xlate);
-
-	dev_dbg(priv->dev, "%s: Exit\n", __func__);
-
-	return PTR_ERR_OR_ZERO(phy_provider);
-}
-
-static struct platform_driver mvebu_comphy_driver = {
-	.probe	= mvebu_comphy_probe,
-	.driver	= {
-		.name		= "phy-mvebu-comphy",
-		.owner		= THIS_MODULE,
-		.of_match_table	= mvebu_comphy_of_match,
-	 },
-};
-module_platform_driver(mvebu_comphy_driver);
-
-MODULE_AUTHOR("Igal Liberman <igall@marvell.com>");
-MODULE_DESCRIPTION("Marvell EBU COMPHY driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/phy/phy-mvebu-comphy.h b/drivers/phy/phy-mvebu-comphy.h
deleted file mode 100644
index 98803c3..0000000
--- a/drivers/phy/phy-mvebu-comphy.h
+++ /dev/null
@@ -1,233 +0,0 @@
-#ifndef _MVEBU_COMPHY_H
-#define _MVEBU_COMPHY_H
-
-#define SD_ADDR(base, lane)			(base + 0x1000 * lane)
-#define HPIPE_ADDR(base, lane)			(SD_ADDR(base, lane) + 0x800)
-#define COMPHY_ADDR(base, lane)			(base + 0x28 * lane)
-
-/* Comphy registers */
-#define COMMON_PHY_CFG1_REG			0x0
-#define COMMON_PHY_CFG1_PWR_UP_OFFSET		1
-#define COMMON_PHY_CFG1_PWR_UP_MASK		(0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET)
-#define COMMON_PHY_CFG1_PIPE_SELECT_OFFSET	2
-#define COMMON_PHY_CFG1_PIPE_SELECT_MASK	(0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET)
-#define COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET	13
-#define COMMON_PHY_CFG1_PWR_ON_RESET_MASK	(0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET)
-#define COMMON_PHY_CFG1_CORE_RSTN_OFFSET	14
-#define COMMON_PHY_CFG1_CORE_RSTN_MASK		(0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET)
-
-#define COMMON_PHY_CFG6_REG			0x14
-#define COMMON_PHY_CFG6_IF_40_SEL_OFFSET	18
-#define COMMON_PHY_CFG6_IF_40_SEL_MASK		(0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET)
-
-#define COMMON_PHY_CFG6_REG			0x14
-#define COMMON_PHY_CFG6_IF_40_SEL_OFFSET	18
-#define COMMON_PHY_CFG6_IF_40_SEL_MASK		(0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET)
-
-#define COMMON_SELECTOR_PHY_REG_OFFSET		0x140
-#define COMMON_SELECTOR_PIPE_REG_OFFSET		0x144
-#define COMMON_SELECTOR_COMPHY_MASK		0xf
-#define COMMON_SELECTOR_COMPHYN_FIELD_WIDTH	4
-#define COMMON_SELECTOR_COMPHYN_SATA		0x4
-#define COMMON_SELECTOR_COMPHY0_1_2_NETWORK	0x1
-#define COMMON_SELECTOR_COMPHY3_RXAUI		0x1
-#define COMMON_SELECTOR_COMPHY3_SGMII		0x2
-#define COMMON_SELECTOR_COMPHY4_SGMII2		0x1
-#define COMMON_SELECTOR_COMPHY4_ALL_OTHERS	0x2
-#define COMMON_SELECTOR_COMPHY5_RXAUI		0x2
-#define COMMON_SELECTOR_COMPHY5_SGMII		0x1
-
-/* SerDes IP registers */
-#define SD_EXTERNAL_CONFIG0_REG				0
-#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET		1
-#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK		(1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET	3
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK		(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET	7
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK		(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET		11
-#define SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK		(1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET		12
-#define SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK		(1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET	14
-#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK		(1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET)
-
-#define SD_EXTERNAL_CONFIG1_REG			0x4
-#define SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET	3
-#define SD_EXTERNAL_CONFIG1_RESET_IN_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET	4
-#define SD_EXTERNAL_CONFIG1_RX_INIT_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET	5
-#define SD_EXTERNAL_CONFIG1_RESET_CORE_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET	6
-#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK	(0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET)
-
-#define SD_EXTERNAL_CONFIG2_REG			0x8
-#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET	4
-#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK	(0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET)
-
-#define SD_EXTERNAL_STATUS0_REG			0x18
-#define SD_EXTERNAL_STATUS0_PLL_TX_OFFSET	2
-#define SD_EXTERNAL_STATUS0_PLL_TX_MASK		(0x1 << SD_EXTERNAL_STATUS0_PLL_TX_OFFSET)
-#define SD_EXTERNAL_STATUS0_PLL_RX_OFFSET	3
-#define SD_EXTERNAL_STATUS0_PLL_RX_MASK		(0x1 << SD_EXTERNAL_STATUS0_PLL_RX_OFFSET)
-#define SD_EXTERNAL_STATUS0_RX_INIT_OFFSET	4
-#define SD_EXTERNAL_STATUS0_RX_INIT_MASK	(0x1 << SD_EXTERNAL_STATUS0_RX_INIT_OFFSET)
-
-/* HPIPE registers */
-#define HPIPE_PWR_PLL_REG			0x4
-#define HPIPE_PWR_PLL_REF_FREQ_OFFSET		0
-#define HPIPE_PWR_PLL_REF_FREQ_MASK		(0x1f << HPIPE_PWR_PLL_REF_FREQ_OFFSET)
-#define HPIPE_PWR_PLL_PHY_MODE_OFFSET		5
-#define HPIPE_PWR_PLL_PHY_MODE_MASK		(0x7 << HPIPE_PWR_PLL_PHY_MODE_OFFSET)
-
-#define HPIPE_CAL_REG1_REG			0xc
-#define HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET	10
-#define HPIPE_CAL_REG_1_EXT_TXIMP_MASK		(0x1f << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET)
-#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET	15
-#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK	(0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET)
-
-#define HPIPE_DFE_REG0				0x1c
-#define HPIPE_DFE_RES_FORCE_OFFSET		15
-#define HPIPE_DFE_RES_FORCE_MASK		(0x1 << HPIPE_DFE_RES_FORCE_OFFSET)
-
-#define HPIPE_DFE_F3_F5_REG			0x28
-#define HPIPE_DFE_F3_F5_DFE_EN_OFFSET		14
-#define HPIPE_DFE_F3_F5_DFE_EN_MASK		(0x1 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET)
-#define HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET		15
-#define HPIPE_DFE_F3_F5_DFE_CTRL_MASK		(0x1 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET)
-
-#define HPIPE_G1_SET_0_REG			0x34
-#define HPIPE_G1_SET_0_G1_TX_AMP_OFFSET		1
-#define HPIPE_G1_SET_0_G1_TX_AMP_MASK		(0x1f << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET	7
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_MASK		(0xf << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET)
-
-#define HPIPE_G1_SET_1_REG			0x38
-#define HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET	0
-#define HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET	3
-#define HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET	6
-#define HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET	8
-#define HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET	10
-#define HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK	(0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK	(0x3 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET)
-
-#define HPIPE_G2_SET_1_REG			0x40
-#define HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET	0
-#define HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET	3
-#define HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET	6
-#define HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET	8
-#define HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET	10
-#define HPIPE_G2_SET_1_G2_RX_DFE_EN_MASK	(0x1 << HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK	(0x3 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET)
-
-#define HPIPE_G3_SET_1_REG				0x48
-#define HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET		0
-#define HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK		(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET		3
-#define HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK		(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET		6
-#define HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK		(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET		8
-#define HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK		(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET		10
-#define HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK		(0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET		11
-#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK		(0x3 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET)
-#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET	13
-#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK	(0x1 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET)
-
-#define HPIPE_LOOPBACK_REG			0x8c
-#define HPIPE_LOOPBACK_SEL_OFFSET		1
-#define HPIPE_LOOPBACK_SEL_MASK			(0x7 << HPIPE_LOOPBACK_SEL_OFFSET)
-
-#define HPIPE_INTERFACE_REG			0x94
-#define HPIPE_INTERFACE_GEN_MAX_OFFSET		10
-#define HPIPE_INTERFACE_GEN_MAX_MASK		(0x3 << HPIPE_INTERFACE_GEN_MAX_OFFSET)
-
-#define HPIPE_G1_SET_2_REG			0xf4
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET	0
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_MASK		(0xf << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET)
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET	4
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK	(0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_MASK)
-
-#define HPIPE_MISC_REG				0x13C
-#define HPIPE_MISC_ICP_FORCE_OFFSET		5
-#define HPIPE_MISC_ICP_FORCE_MASK		(0x1 << HPIPE_MISC_ICP_FORCE_OFFSET)
-#define HPIPE_MISC_REFCLK_SEL_OFFSET		10
-#define HPIPE_MISC_REFCLK_SEL_MASK		(0x1 << HPIPE_MISC_REFCLK_SEL_OFFSET)
-
-#define HPIPE_RX_CONTROL_1_REG			0x140
-#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET	11
-#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK	(0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET)
-#define HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET	12
-#define HPIPE_RX_CONTROL_1_CLK8T_EN_MASK	(0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET)
-
-#define HPIPE_PWR_CTR_REG			0x148
-#define HPIPE_PWR_CTR_RST_DFE_OFFSET		0
-#define HPIPE_PWR_CTR_RST_DFE_MASK		(0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET)
-#define HPIPE_PWR_CTR_SFT_RST_OFFSET		10
-#define HPIPE_PWR_CTR_SFT_RST_MASK		(0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET)
-
-#define HPIPE_TX_REG1_REG			0x174
-#define HPIPE_TX_REG1_TX_EMPH_RES_OFFSET	5
-#define HPIPE_TX_REG1_TX_EMPH_RES_MASK		(0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET)
-#define HPIPE_TX_REG1_SLC_EN_OFFSET		10
-#define HPIPE_TX_REG1_SLC_EN_MASK		(0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET)
-
-#define HPIPE_PWR_CTR_DTL_REG				0x184
-#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET		0
-#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK		(0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET		1
-#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK		(0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET		2
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK			(0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET		4
-#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK		(0x7 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET)
-#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET	10
-#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK	(0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET		12
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_MASK			(0x3 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET		14
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK		(1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET)
-
-#define HPIPE_PWR_CTR_DTL_REG			0x184
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET	2
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK		(0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET)
-
-#define HPIPE_G1_SETTINGS_3_REG				0x440
-#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET	0
-#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK		(0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET	4
-#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK		(0x7 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET	7
-#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK	(0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET		9
-#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK		(0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET	12
-#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET	14
-#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET)
-
-#define HPIPE_G1_SETTINGS_4_REG			0x444
-#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET	8
-#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK	(0x3 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET)
-
-#define HPIPE_G1_SETTING_5_REG			0x538
-#define HPIPE_G1_SETTING_5_G1_ICP_OFFSET	0
-#define HPIPE_G1_SETTING_5_G1_ICP_MASK		(0xf << HPIPE_G1_SETTING_5_G1_ICP_OFFSET)
-
-/* General defines */
-#define PLL_LOCK_TIMEOUT			15000
-#endif /* _MVEBU_COMPHY_H */
-
diff --git a/include/dt-bindings/phy/phy-comphy-mvebu.h b/include/dt-bindings/phy/phy-comphy-mvebu.h
new file mode 100644
index 0000000..97385dc
--- /dev/null
+++ b/include/dt-bindings/phy/phy-comphy-mvebu.h
@@ -0,0 +1,46 @@
+#ifndef _DT_BINDINGS_PHY_COMPHY_MVEBU
+#define _DT_BINDINGS_PHY_COMPHY_MVEBU
+
+/* A lane is described by 2 fields:
+ *	- 8 lsb represent the index of the lane
+ *	- 24 msb represent the mode
+ */
+#define COMPHY_DEF(x, y)	(((x) << 8) | (y))
+/* Macro the extract the mode from lane description */
+#define COMPHY_GET_MODE(x)	((x & 0xFFFFFF00) >> 8)
+/* Macro the extract the id from lane description */
+#define COMPHY_GET_ID(x)	(x & 0xff)
+
+#define	COMPHY_UNUSED		COMPHY_DEF(0xff, 0xff)
+#define COMPHY_SATA0		COMPHY_DEF(0x1,  0x0)
+#define COMPHY_SATA1		COMPHY_DEF(0x1,  0x1)
+#define COMPHY_SGMII0		COMPHY_DEF(0x2,  0x0)	/* SGMII 1G */
+#define COMPHY_SGMII1		COMPHY_DEF(0x2,  0x1)	/* SGMII 1G */
+#define COMPHY_SGMII2		COMPHY_DEF(0x2,  0x2)	/* SGMII 1G */
+#define COMPHY_HS_SGMII0	COMPHY_DEF(0x3,  0x0)	/* SGMII 2.5G */
+#define COMPHY_HS_SGMII1	COMPHY_DEF(0x3,  0x1)	/* SGMII 2.5G */
+#define COMPHY_HS_SGMII2	COMPHY_DEF(0x3,  0x2)	/* SGMII 2.5G */
+#define COMPHY_USB3H0		COMPHY_DEF(0x4,  0x0)
+#define COMPHY_USB3H1		COMPHY_DEF(0x4,  0x1)
+#define COMPHY_USB3D0		COMPHY_DEF(0x5,  0x0)
+#define COMPHY_PCIE0		COMPHY_DEF(0x6,  0x0)
+#define COMPHY_PCIE1		COMPHY_DEF(0x6,  0x1)
+#define COMPHY_PCIE2		COMPHY_DEF(0x6,  0x2)
+#define COMPHY_PCIE3		COMPHY_DEF(0x6,  0x3)
+#define COMPHY_RXAUI0		COMPHY_DEF(0x7,  0x0)
+#define COMPHY_RXAUI1		COMPHY_DEF(0x7,  0x1)
+#define COMPHY_XFI		COMPHY_DEF(0x8,  0x0)
+#define COMPHY_SFI		COMPHY_DEF(0x9,  0x0)
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+
+#endif /* _DT_BINDINGS_PHY_COMPHY_MVEBU */
+
diff --git a/include/dt-bindings/phy/phy-mvebu-comphy.h b/include/dt-bindings/phy/phy-mvebu-comphy.h
deleted file mode 100644
index 62bdf50..0000000
--- a/include/dt-bindings/phy/phy-mvebu-comphy.h
+++ /dev/null
@@ -1,46 +0,0 @@
-#ifndef _DT_BINDINGS_PHY_MVEBU_COMPHY
-#define _DT_BINDINGS_PHY_MVEBU_COMPHY
-
-/* A lane is described by 2 fields:
- *	- 8 lsb represent the index of the lane
- *	- 24 msb represent the mode
- */
-#define COMPHY_DEF(x, y)	(((x) << 8) | (y))
-/* Macro the extract the mode from lane description */
-#define COMPHY_GET_MODE(x)	((x & 0xFFFFFF00) >> 8)
-/* Macro the extract the id from lane description */
-#define COMPHY_GET_ID(x)	(x & 0xff)
-
-#define	COMPHY_UNUSED		COMPHY_DEF(0xff, 0xff)
-#define COMPHY_SATA0		COMPHY_DEF(0x1,  0x0)
-#define COMPHY_SATA1		COMPHY_DEF(0x1,  0x1)
-#define COMPHY_SGMII0		COMPHY_DEF(0x2,  0x0)	/* SGMII 1G */
-#define COMPHY_SGMII1		COMPHY_DEF(0x2,  0x1)	/* SGMII 1G */
-#define COMPHY_SGMII2		COMPHY_DEF(0x2,  0x2)	/* SGMII 1G */
-#define COMPHY_HS_SGMII0	COMPHY_DEF(0x3,  0x0)	/* SGMII 2.5G */
-#define COMPHY_HS_SGMII1	COMPHY_DEF(0x3,  0x1)	/* SGMII 2.5G */
-#define COMPHY_HS_SGMII2	COMPHY_DEF(0x3,  0x2)	/* SGMII 2.5G */
-#define COMPHY_USB3H0		COMPHY_DEF(0x4,  0x0)
-#define COMPHY_USB3H1		COMPHY_DEF(0x4,  0x1)
-#define COMPHY_USB3D0		COMPHY_DEF(0x5,  0x0)
-#define COMPHY_PCIE0		COMPHY_DEF(0x6,  0x0)
-#define COMPHY_PCIE1		COMPHY_DEF(0x6,  0x1)
-#define COMPHY_PCIE2		COMPHY_DEF(0x6,  0x2)
-#define COMPHY_PCIE3		COMPHY_DEF(0x6,  0x3)
-#define COMPHY_RXAUI0		COMPHY_DEF(0x7,  0x0)
-#define COMPHY_RXAUI1		COMPHY_DEF(0x7,  0x1)
-#define COMPHY_XFI		COMPHY_DEF(0x8,  0x0)
-#define COMPHY_SFI		COMPHY_DEF(0x9,  0x0)
-
-#define COMPHY_SATA_MODE	0x1
-#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
-#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
-#define COMPHY_USB3H_MODE	0x4
-#define COMPHY_USB3D_MODE	0x5
-#define COMPHY_PCIE_MODE	0x6
-#define COMPHY_RXAUI_MODE	0x7
-#define COMPHY_XFI_MODE		0x8
-#define COMPHY_SFI_MODE		0x9
-
-#endif /* _DT_BINDINGS_COMPHY_MVEBU_COMPHY */
-
-- 
1.7.9.5


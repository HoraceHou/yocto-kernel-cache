From 9afa88fef26340a4c8103b2443243a9c1a79045e Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Wed, 7 Dec 2016 13:39:27 +0200
Subject: [PATCH 0641/1345] fix: net: mvpp2x: fix multi CPU ring overrun issue

commit  2a870b68f00706a57c564e0314523972b641e1f1 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- with smp affinity configuration possible scenario is that one of the
  CPU do TX and other responsible for TX done interrupt. Both CPU's use
  same ring to add/remove buffers to ring and to check number of buffers
  in ring. In this commit two fixes were done.
1. To avoid ring overrun before buffer freed:
- increment TXQ get index after skb release

2. To avoid wrong check of number of buffers in ring (and ring overrun
   as result):
- do not allow illegal values for TXQ get and TXQ put index

Change-Id: I2b7222cef4e0fb90ae5baa3da00d30494ec80026
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/34443
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |   21 ++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 828d57e..aa2d319 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -214,17 +214,19 @@ static inline int mv_pp2x_txq_free_count(struct mv_pp2x_txq_pcpu *txq_pcpu)
 
 static void mv_pp2x_txq_inc_get(struct mv_pp2x_txq_pcpu *txq_pcpu)
 {
-	txq_pcpu->txq_get_index++;
-	if (txq_pcpu->txq_get_index == txq_pcpu->size)
+	if (txq_pcpu->txq_get_index == txq_pcpu->size - 1)
 		txq_pcpu->txq_get_index = 0;
+	else
+		txq_pcpu->txq_get_index++;
 }
 
 void mv_pp2x_txq_inc_error(struct mv_pp2x_txq_pcpu *txq_pcpu, int num)
 {
 	for (; num > 0; num--) {
-		txq_pcpu->txq_put_index--;
-		if (txq_pcpu->txq_put_index < 0)
+		if (txq_pcpu->txq_put_index < 1)
 			txq_pcpu->txq_put_index = txq_pcpu->size - 1;
+		else
+			txq_pcpu->txq_put_index--;
 		txq_pcpu->tx_skb[txq_pcpu->txq_put_index] = 0;
 		txq_pcpu->data_size[txq_pcpu->txq_put_index] = 0;
 		txq_pcpu->tx_buffs[txq_pcpu->txq_put_index] = 0;
@@ -240,9 +242,10 @@ void mv_pp2x_txq_inc_put(enum mvppv2_version pp2_ver,
 	txq_pcpu->data_size[txq_pcpu->txq_put_index] = tx_desc->data_size;
 	txq_pcpu->tx_buffs[txq_pcpu->txq_put_index] =
 				mv_pp2x_txdesc_phys_addr_get(pp2_ver, tx_desc);
-	txq_pcpu->txq_put_index++;
-	if (txq_pcpu->txq_put_index == txq_pcpu->size)
+	if (txq_pcpu->txq_put_index == txq_pcpu->size - 1)
 		txq_pcpu->txq_put_index = 0;
+	else
+		txq_pcpu->txq_put_index++;
 #if defined(__BIG_ENDIAN)
 	if (pp2_ver == PPV21)
 		mv_pp21_tx_desc_swap(tx_desc);
@@ -950,23 +953,21 @@ static void mv_pp2x_txq_bufs_free(struct mv_pp2x_port *port,
 		uintptr_t skb = (uintptr_t)txq_pcpu->tx_skb[txq_pcpu->txq_get_index];
 		int data_size = txq_pcpu->data_size[txq_pcpu->txq_get_index];
 
-		mv_pp2x_txq_inc_get(txq_pcpu);
-
 		dma_unmap_single(port->dev->dev.parent, buf_phys_addr,
 				 data_size, DMA_TO_DEVICE);
 
 		if (skb & MVPP2_ETH_SHADOW_EXT) {
 			skb &= ~MVPP2_ETH_SHADOW_EXT;
 			mv_pp2_extra_pool_put(port, (void *)skb);
+			mv_pp2x_txq_inc_get(txq_pcpu);
 			continue;
 		}
 
-		if (!skb)
-			continue;
 		if (skb & MVPP2_ETH_SHADOW_SKB) {
 			skb &= ~MVPP2_ETH_SHADOW_SKB;
 			dev_kfree_skb_any((struct sk_buff *)skb);
 		}
+		mv_pp2x_txq_inc_get(txq_pcpu);
 	}
 }
 
-- 
1.7.9.5


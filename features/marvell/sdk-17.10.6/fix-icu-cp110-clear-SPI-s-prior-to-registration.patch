From 6c2887af7b8e72208467d267d1dcc93b502f896a Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Thu, 2 Feb 2017 11:54:56 +0100
Subject: [PATCH 0768/1345] fix: icu: cp110: clear SPI's prior to registration

commit  236d459b921abe4f4f57491b951b98c22acea584 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

It may occur that certain Non-Secure SPI's remain asserted
after usage in bootloader, which may be mistakenly recognized as
an endless interrupt in Linux. In order to prevent it, by default
clear those interrupts prior to registration by writing its
number to GICP_CLRSPI_NSR register. For this purpose add new
field in struct mvebu_icu_irq_data which comprise remapped
contents of gicp_spi_reg array (elements 2 and 3).

This commit fixes SYSTEMSW-3254 and SYSTEMSW-3297.

Change-Id: I30846bdebd6793fb570defbd99e68623ad45978d
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/36405
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/36432
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/irqchip/irq-mvebu-icu.c |   18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/drivers/irqchip/irq-mvebu-icu.c b/drivers/irqchip/irq-mvebu-icu.c
index 5b28415..91f9610 100644
--- a/drivers/irqchip/irq-mvebu-icu.c
+++ b/drivers/irqchip/irq-mvebu-icu.c
@@ -75,6 +75,7 @@
 
 struct mvebu_icu_irq_data {
 	void __iomem *base;	/* ICU register base */
+	void __iomem *gicp_clr_spi_base;
 	struct irq_domain *domain;
 };
 
@@ -185,6 +186,13 @@ static int mvebu_icu_irq_domain_alloc(struct irq_domain *domain, unsigned int vi
 		return err;
 	}
 
+	/*
+	 * Clear Non-Secure SPI in GICP,
+	 * in case it was asserted in bootloader.
+	 */
+	if (icu_group == ICU_GRP_NSR)
+		writel(irq_msg_num, icu->gicp_clr_spi_base);
+
 	/* Configure the ICU with irq number & type */
 	icu_int  = (irq_msg_num) | (1 << ICU_INT_ENABLE_OFFSET);
 	if (type & IRQ_TYPE_EDGE_RISING)
@@ -250,6 +258,7 @@ static void mvebu_icu_irq_domain_free(struct irq_domain *domain,
 static int __init mvebu_icu_of_init(struct device_node *node, struct device_node *parent)
 {
 	int ret;
+	resource_size_t gicp_clr_spi_base;
 	struct mvebu_icu_irq_data *icu;
 	struct irq_domain *parent_domain;
 	u32 gicp_spi_reg[4];
@@ -296,6 +305,15 @@ static int __init mvebu_icu_of_init(struct device_node *node, struct device_node
 	writel(gicp_spi_reg[2], icu->base + ICU_CLRSPI_NSR_AH);
 	writel(gicp_spi_reg[3], icu->base + ICU_CLRSPI_NSR_AL);
 
+	gicp_clr_spi_base = (u64)gicp_spi_reg[3];
+
+	icu->gicp_clr_spi_base = ioremap(gicp_clr_spi_base, 0x4);
+	if (!icu->gicp_clr_spi_base) {
+		pr_err("Fail to map GICP SPI_CLR register\n");
+		ret = -ENOMEM;
+		goto err_iounmap;
+	}
+
 	/* Clean all ICU interrupts with type SPI_NSR, required to avoid
 	** unpredictable SPI assignments done by firmware
 	**/
-- 
1.7.9.5


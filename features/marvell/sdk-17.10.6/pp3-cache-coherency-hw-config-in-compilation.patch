From 4be5f7825c1be8344965707ca8957572ba485893 Mon Sep 17 00:00:00 2001
From: Yan Markman <ymarkman@marvell.com>
Date: Sun, 17 Jul 2016 10:30:47 +0300
Subject: [PATCH 0343/1345] pp3: cache coherency hw config in compilation

commit  6969a9a1fd5c7f6c035dc10cdacb97ebfa29d857 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

JIRA SYSTEMSW-2654

coherency_hard_mode = coherency_available();
is always TRUE on the PP3 ARMADA platform.

Using if(coherency_hard_mode) has 3 penalties
- check variable which is always =1 in run-time flexible code
- compile big INLINE dma_map_single() in run-time flexible code
- unexpected erros/panics with dma_map_single() presence

So disable run-time configuration enabling only HW option (no SW),
eliminating dma_map_single and coherency_hard_mode by wrapping with
new CONFIG_MV_PP3_COHERENCY_HARD_MODE_ONLY having default value "y"

Change-Id: Ifd79d284dec4131d044329d46ab946c88c2fb510
Signed-off-by: Yan Markman <ymarkman@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/31163
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/Kconfig           |    7 +++++++
 drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h |    8 ++++++--
 drivers/net/ethernet/marvell/pp3/platform/mv_pp3.c |    7 ++++++-
 3 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/Kconfig b/drivers/net/ethernet/marvell/pp3/Kconfig
index d585317..b4f4ec8 100644
--- a/drivers/net/ethernet/marvell/pp3/Kconfig
+++ b/drivers/net/ethernet/marvell/pp3/Kconfig
@@ -229,5 +229,12 @@ config  MV_PP3_PTP_SERVICE
 	---help---
 	PTP uio mapping and packet-timestamp in Marvell network driver
 
+config  MV_PP3_COHERENCY_HARD_MODE_ONLY
+	bool "Cache coherency HW mode"
+	default y
+	select UIO
+	---help---
+	coherency_available() is always HW, no SW run-time configuration
+
 endmenu
 
diff --git a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
index b658097..4b16137 100644
--- a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
+++ b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
@@ -92,25 +92,29 @@ static inline void mv_pp3_hw_reg_write(void __iomem *access_addr, u32 data)
 /* Cache coherency functions */
 static inline void mv_pp3_os_cache_io_sync(void *handle)
 {
+#ifndef CONFIG_MV_PP3_COHERENCY_HARD_MODE_ONLY
 	if (likely(coherency_hard_mode))
+#endif
 		dma_sync_single_for_cpu(handle, (dma_addr_t) NULL,
 			(size_t) NULL, DMA_FROM_DEVICE);
 }
 
 static inline dma_addr_t mv_pp3_os_dma_map_single(struct device *dev, void *addr, size_t size, int direction)
 {
+#ifndef CONFIG_MV_PP3_COHERENCY_HARD_MODE_ONLY
 	if (unlikely(!coherency_hard_mode))
 		return dma_map_single(dev, addr, size, direction);
-
+#endif
 	return virt_to_phys(addr);
 }
 
 static inline dma_addr_t mv_pp3_os_dma_map_page(struct device *dev, struct page *page, int offset,
 						size_t size, int direction)
 {
+#ifndef CONFIG_MV_PP3_COHERENCY_HARD_MODE_ONLY
 	if (unlikely(!coherency_hard_mode))
 		return dma_map_page(dev, page, offset, size, direction);
-
+#endif
 	return pfn_to_dma(dev, page_to_pfn(page)) + offset;
 }
 
diff --git a/drivers/net/ethernet/marvell/pp3/platform/mv_pp3.c b/drivers/net/ethernet/marvell/pp3/platform/mv_pp3.c
index b3e9176..0be310c 100644
--- a/drivers/net/ethernet/marvell/pp3/platform/mv_pp3.c
+++ b/drivers/net/ethernet/marvell/pp3/platform/mv_pp3.c
@@ -728,7 +728,12 @@ static int mv_pp3_shared_probe(struct platform_device *pdev)
 	char name[20];
 
 	coherency_hard_mode = coherency_available();
-
+#ifdef CONFIG_MV_PP3_COHERENCY_HARD_MODE_ONLY
+	if (!coherency_hard_mode) {
+		pr_err("pp3 supported on ARMADA platform with HW cache coherency only\n");
+		return -ENODEV;
+	}
+#endif
 	pp3_device = kzalloc(sizeof(struct mv_pp3), GFP_KERNEL);
 	if (!pp3_device) {
 		pr_err("%s: out of memory\n", __func__);
-- 
1.7.9.5


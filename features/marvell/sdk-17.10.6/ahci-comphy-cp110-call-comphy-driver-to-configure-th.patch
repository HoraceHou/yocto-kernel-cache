From 9c98e94064dd16c61b091b9ccc0d7b918a105486 Mon Sep 17 00:00:00 2001
From: Igal Liberman <igall@marvell.com>
Date: Tue, 8 Nov 2016 11:52:50 +0200
Subject: [PATCH 0653/1345] ahci: comphy: cp110: call comphy driver to
 configure the phy into SATA mode

commit  b4637450e51a186ea3ee0daea6c3943bb014cbbf from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Until now, in MVEBU AHCI Linux assumes that comphy (SerDes) was
configured by u-boot.
Now there's a new Linux comphy driver which configures the comphy (SerDes).

This patch adds a new flow in order to be able to use the new comphy
driver for cp110:
1. Power down AHCI macs
2. Configure the corresponding comphy (comphy driver).
3. Power up AHCI macs
4. Check if comphy PLL was locked

The new code is placed under "marvell,armada-cp110-ahci" because it's
required only for cp110 AHCI.

Change-Id: I3bd3b47fac0616f07ecf23dd8a779125d0a32abe
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/33629
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/ata/ahci_mvebu.c |  139 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 139 insertions(+)

diff --git a/drivers/ata/ahci_mvebu.c b/drivers/ata/ahci_mvebu.c
index d2ac310..67c1689 100644
--- a/drivers/ata/ahci_mvebu.c
+++ b/drivers/ata/ahci_mvebu.c
@@ -99,6 +99,137 @@ static int ahci_mvebu_resume(struct platform_device *pdev)
 	AHCI_SHT(DRV_NAME),
 };
 
+static void reg_set(void __iomem *addr, u32 data, u32 mask)
+{
+	u32 reg_data;
+
+	reg_data = readl(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writel(reg_data, addr);
+}
+
+#define SATA3_VENDOR_ADDRESS			0xA0
+#define SATA3_VENDOR_ADDR_OFSSET		0
+#define SATA3_VENDOR_ADDR_MASK			(0xFFFFFFFF << SATA3_VENDOR_ADDR_OFSSET)
+#define SATA3_VENDOR_DATA			0xA4
+
+#define SATA_CONTROL_REG			0x0
+#define SATA3_CTRL_SATA0_PD_OFFSET		6
+#define SATA3_CTRL_SATA0_PD_MASK		(1 << SATA3_CTRL_SATA0_PD_OFFSET)
+#define SATA3_CTRL_SATA1_PD_OFFSET		14
+#define SATA3_CTRL_SATA1_PD_MASK		(1 << SATA3_CTRL_SATA1_PD_OFFSET)
+#define SATA3_CTRL_SATA1_ENABLE_OFFSET		22
+#define SATA3_CTRL_SATA1_ENABLE_MASK		(1 << SATA3_CTRL_SATA1_ENABLE_OFFSET)
+#define SATA3_CTRL_SATA_SSU_OFFSET		23
+#define SATA3_CTRL_SATA_SSU_MASK		(1 << SATA3_CTRL_SATA_SSU_OFFSET)
+
+#define SATA_MBUS_SIZE_SELECT_REG		0x4
+#define SATA_MBUS_REGRET_EN_OFFSET		7
+#define SATA_MBUS_REGRET_EN_MASK		(0x1 << SATA_MBUS_REGRET_EN_OFFSET)
+/**
+ * ahci_mvebu_cp_110_power_up
+ *
+ * @pdev:	A pointer to ahci platform device
+ * @hpriv:	A pointer to achi host private structure
+ *
+ * This function configures corresponding comphy to SATA mode.
+ * AHCI driver acquires an handle to the corresponding PHY from
+ * the device-tree (In ahci_platform_get_resources).
+ * cp110 require the following sequence:
+ *	1. Power down AHCI macs
+ *	2. Configure the corresponding comphy (comphy driver).
+ *	3. Power up AHCI macs
+ *	4. Check if comphy PLL was locked
+ *
+ * Return: 0 on success; Error code otherwise.
+ */
+static int ahci_mvebu_cp_110_power_up(struct platform_device *pdev,
+				      struct ahci_host_priv *hpriv)
+{
+	u32 mask, data, i;
+	int err = 0;
+
+	/* Power off AHCI macs */
+	reg_set(hpriv->mmio + SATA3_VENDOR_ADDRESS,
+		SATA_CONTROL_REG << SATA3_VENDOR_ADDR_OFSSET,
+		SATA3_VENDOR_ADDR_MASK);
+	/* SATA port 0 power down */
+	mask = SATA3_CTRL_SATA0_PD_MASK;
+	data = 0x1 << SATA3_CTRL_SATA0_PD_OFFSET;
+	/* SATA port 1 power down */
+	mask |= SATA3_CTRL_SATA1_PD_MASK;
+	data |= 0x1 << SATA3_CTRL_SATA1_PD_OFFSET;
+	/* SATA SSU disable */
+	mask |= SATA3_CTRL_SATA1_ENABLE_MASK;
+	data |= 0x0 << SATA3_CTRL_SATA1_ENABLE_OFFSET;
+	/* SATA port 1 disable
+	 * There's no option to disable SATA port 0, so we power down both
+	 * ports (during previous steps) but disable onlt SATA port 1
+	 */
+	mask |= SATA3_CTRL_SATA_SSU_MASK;
+	data |= 0x0 << SATA3_CTRL_SATA_SSU_OFFSET;
+	reg_set(hpriv->mmio + SATA3_VENDOR_DATA, data, mask);
+
+	/* Configure corresponding comphy
+	 * First we need to call phy_power_off because the phy_power_on
+	 * was called by generic AHCI code.
+	 * Next, we call phy_power_on in order to configure the comphy
+	 * while AHCI is powered down.
+	 */
+	for (i = 0; i < hpriv->nports; i++) {
+		err = phy_power_off(hpriv->phys[i]);
+		if (err) {
+			dev_err(&pdev->dev, "unable to power off SATA comphy\n");
+			return -EINVAL;
+		}
+		err = phy_power_on(hpriv->phys[i]);
+		if (err) {
+			dev_err(&pdev->dev, "unable to power on SATA comphy\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Power up AHCI macs */
+	reg_set(hpriv->mmio + SATA3_VENDOR_ADDRESS,
+		SATA_CONTROL_REG << SATA3_VENDOR_ADDR_OFSSET,
+		SATA3_VENDOR_ADDR_MASK);
+	/* SATA port 0 power up */
+	mask = SATA3_CTRL_SATA0_PD_MASK;
+	data = 0x0 << SATA3_CTRL_SATA0_PD_OFFSET;
+	/* SATA port 1 power up */
+	mask |= SATA3_CTRL_SATA1_PD_MASK;
+	data |= 0x0 << SATA3_CTRL_SATA1_PD_OFFSET;
+	/* SATA SSU enable */
+	mask |= SATA3_CTRL_SATA1_ENABLE_MASK;
+	data |= 0x1 << SATA3_CTRL_SATA1_ENABLE_OFFSET;
+	/* SATA port 1 enable */
+	mask |= SATA3_CTRL_SATA_SSU_MASK;
+	data |= 0x1 << SATA3_CTRL_SATA_SSU_OFFSET;
+	reg_set(hpriv->mmio + SATA3_VENDOR_DATA, data, mask);
+
+	/* MBUS request size and interface select register */
+	reg_set(hpriv->mmio + SATA3_VENDOR_ADDRESS,
+		SATA_MBUS_SIZE_SELECT_REG << SATA3_VENDOR_ADDR_OFSSET,
+		SATA3_VENDOR_ADDR_MASK);
+	/* Mbus regret enable */
+	reg_set(hpriv->mmio + SATA3_VENDOR_DATA,
+		0x1 << SATA_MBUS_REGRET_EN_OFFSET,
+		SATA_MBUS_REGRET_EN_MASK);
+
+	/* Check if comphy PLL is locked */
+	for (i = 0; i < hpriv->nports; i++) {
+		err = phy_is_pll_locked(hpriv->phys[i]);
+		if (err) {
+			dev_err(&pdev->dev, "port %d: comphy PLL is not locked for SATA. Unable to power on SATA comphy\n",
+				i);
+			return err;
+		}
+	}
+
+	return err;
+}
+
 static int ahci_mvebu_probe(struct platform_device *pdev)
 {
 	struct ahci_host_priv *hpriv;
@@ -123,6 +254,14 @@ static int ahci_mvebu_probe(struct platform_device *pdev)
 		ahci_mvebu_regret_option(hpriv);
 	}
 
+	/* Call cp110 comphy initialization flow */
+	if (of_device_is_compatible(pdev->dev.of_node,
+	    "marvell,armada-cp110-ahci")) {
+		rc = ahci_mvebu_cp_110_power_up(pdev, hpriv);
+		if (rc)
+			return rc;
+	}
+
 	/* In A8k A0 AHCI unit the port register offsets are not
 	 * according to AHCI specification. We need a WA for a8k (cp110).
 	 */
-- 
1.7.9.5


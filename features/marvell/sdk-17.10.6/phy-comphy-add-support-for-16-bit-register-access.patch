From 9d15303d7b3ba7802c49e622721576b3fc7ae31d Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 11 Jan 2017 23:40:16 +0800
Subject: [PATCH 0741/1345] phy: comphy: add support for 16-bit register
 access

commit  bbcba07801682138155f271ec5002ea077bc2692 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- Some comphy registers of A3700 are 16bit, so it is necessary
  to add 16-bit access support

Change-Id: I61817e42483cea3c08963c86c9a338223d192a96
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35529
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/phy/phy-comphy-cp110.c |   10 +++++-----
 drivers/phy/phy-comphy-mvebu.h |   23 +++++++++++++++++++++--
 2 files changed, 26 insertions(+), 7 deletions(-)

diff --git a/drivers/phy/phy-comphy-cp110.c b/drivers/phy/phy-comphy-cp110.c
index ea8d962..87f08d3 100644
--- a/drivers/phy/phy-comphy-cp110.c
+++ b/drivers/phy/phy-comphy-cp110.c
@@ -393,7 +393,7 @@ static int mvebu_cp110_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
 	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
 	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK | SD_EXTERNAL_STATUS0_PLL_TX_MASK;
 	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
+	data = polling_with_timeout(addr, data, mask, 15000, REG_32BIT);
 	if (data != 0) {
 		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
 			dev_err(priv->dev, "RX PLL is not locked\n");
@@ -412,7 +412,7 @@ static int mvebu_cp110_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
 	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
 	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
 	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
+	data = polling_with_timeout(addr, data, mask, 100, REG_32BIT);
 	if (data != 0) {
 		dev_err(priv->dev, "RX init failed\n");
 		ret = -ETIMEDOUT;
@@ -638,7 +638,7 @@ static int mvebu_cp110_comphy_xfi_power_on(struct mvebu_comphy_priv *priv,
 	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
 	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK | SD_EXTERNAL_STATUS0_PLL_TX_MASK;
 	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
+	data = polling_with_timeout(addr, data, mask, 15000, REG_32BIT);
 	if (data != 0) {
 		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
 			dev_err(priv->dev, "RX PLL is not locked\n");
@@ -657,7 +657,7 @@ static int mvebu_cp110_comphy_xfi_power_on(struct mvebu_comphy_priv *priv,
 	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
 	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
 	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
+	data = polling_with_timeout(addr, data, mask, 100, REG_32BIT);
 	if (data != 0) {
 		dev_err(priv->dev, "RX init failed\n");
 		ret = -ETIMEDOUT;
@@ -762,7 +762,7 @@ static int mvebu_cp110_comphy_is_pll_locked(struct phy *phy)
 	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
 	data = SD_EXTERNAL_STATUS0_PLL_TX_MASK & SD_EXTERNAL_STATUS0_PLL_RX_MASK;
 	mask = data;
-	data = polling_with_timeout(addr, data, mask, PLL_LOCK_TIMEOUT);
+	data = polling_with_timeout(addr, data, mask, PLL_LOCK_TIMEOUT, REG_32BIT);
 	if (data != 0) {
 		if (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK)
 			dev_err(priv->dev, "RX PLL is not locked\n");
diff --git a/drivers/phy/phy-comphy-mvebu.h b/drivers/phy/phy-comphy-mvebu.h
index 0ce26cf..0e7620b 100644
--- a/drivers/phy/phy-comphy-mvebu.h
+++ b/drivers/phy/phy-comphy-mvebu.h
@@ -7,6 +7,11 @@
 #define to_mvebu_comphy_priv(lane) \
 	container_of((lane), struct mvebu_comphy_priv, lanes[(lane)->index])
 
+enum reg_width_type {
+	REG_16BIT = 0,
+	REG_32BIT,
+};
+
 struct mvebu_comphy_priv {
 	struct device *dev;
 	void __iomem *comphy_regs;
@@ -36,16 +41,30 @@ static inline void __maybe_unused reg_set(void __iomem *addr, u32 data, u32 mask
 	writel(reg_data, addr);
 }
 
+static inline void __maybe_unused reg_set16(void __iomem *addr, u16 data, u16 mask)
+{
+	u16 reg_data;
+
+	reg_data = readw(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writew(reg_data, addr);
+}
+
 static inline u32 __maybe_unused polling_with_timeout(void __iomem *addr,
 						      u32 val,
 						      u32 mask,
-						      unsigned long usec_timout)
+						      unsigned long usec_timout,
+						      enum reg_width_type type)
 {
 	u32 data;
 
 	do {
 		udelay(1);
-		data = readl(addr) & mask;
+		if (type == REG_16BIT)
+			data = readw(addr) & mask;
+		else
+			data = readl(addr) & mask;
 	} while (data != val  && --usec_timout > 0);
 
 	if (usec_timout == 0)
-- 
1.7.9.5


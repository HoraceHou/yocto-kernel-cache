From 050be822510c00cd6405bce632180c307a9a70df Mon Sep 17 00:00:00 2001
From: Igal Liberman <igall@marvell.com>
Date: Mon, 20 Mar 2017 10:12:37 +0200
Subject: [PATCH 0980/1345] crypto: inside-secure: add EIP97 support

commit  fccdd11078b26a80ff2e11d23bd23cdbfbd0a691 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

The PacketEngine-IP-97 available on A37x0 is a cryptographic engine
similar to PacketEngine-IP-197 available on A80x0 and A70x0.
There are some major differences between the engines:
- No firmware support on EIP97.
- No PRNG (Pseudo Random Number Generator) support on EIP97.
- No TRC (Transform Record Cache) support on EIP97.
- Some runtime differences related to invalidation.
- Differenct units offsets

This patch adds EIP97 support on top of the existing EIP197 support.

Documentation is updated accordingly.

Change-Id: I0064985930dbaf3ddcc4eca3f443c6235b66a0ae
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/38426
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../bindings/crypto/inside_secure_eip.txt          |   26 ++++-
 drivers/crypto/Kconfig                             |    2 +-
 drivers/crypto/inside-secure/cipher.c              |   30 +++++-
 drivers/crypto/inside-secure/hash.c                |   54 +++++++++--
 drivers/crypto/inside-secure/safexcel.c            |  102 ++++++++++++++------
 drivers/crypto/inside-secure/safexcel.h            |   12 +++
 6 files changed, 176 insertions(+), 50 deletions(-)

diff --git a/Documentation/devicetree/bindings/crypto/inside_secure_eip.txt b/Documentation/devicetree/bindings/crypto/inside_secure_eip.txt
index 65eb56c..df36467 100644
--- a/Documentation/devicetree/bindings/crypto/inside_secure_eip.txt
+++ b/Documentation/devicetree/bindings/crypto/inside_secure_eip.txt
@@ -1,18 +1,19 @@
-Inside-secure EIP197 Cryptographic Engines And Security Accelerator
+Inside-secure EIP197/97 Cryptographic Engines And Security Accelerator
 ======================================================================
 
-The EIP197 is a hybrid packet engine designed to off-load a security
+The EIP197/97 is a hybrid packet engine designed to off-load a security
 host processor to improve the speed of IPsec ESP, IPsec AH, SRTP, SSL, TLS,
 DTLS and MACsec protocol operations.
 
 Required properties:
 --------------------
-- compatible	  : Should be "inside-secure,safexcel-eip197".
+- compatible	  : Should be "inside-secure,safexcel-eip197" " for EIP197 or
+			      "inside-secure,safexcel-eip97" for EIP97.
 - reg		  : Base physical address of the engine and length
 		    of memory mapped region.
 - interrupts	  : A list of interrupts required for EIP engine.
 - interrupt-names : Names of the interrupts listed in interrupts property.
-- clocks	  : Reference to the crypto engine clocks.
+- clocks	  : Reference to the crypto engine clocks (Only for EIP197).
 - dma-coherent	  : Present if dma operations are coherent.
 - dma-bus-width   : DMA address bus width.
 - cell-index	  : Should contain the EIP197 engine ID.
@@ -38,3 +39,20 @@ Examples:
 		cell-index = <0>;
 		status = "disabled";
 	};
+
+	eip97: eip97@90000 {
+		compatible = "inside-secure,safexcel-eip97";
+		reg = <0x90000 0x20000>;
+		interrupt-names = "eip_out", "ring0", "ring1",
+				  "ring2", "ring3", "eip_addr";
+		interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+		dma-coherent;
+		dma-bus-width = <32>;
+		cell-index = <0>;
+		status = "disabled";
+	};
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index ff2bedc..c002eea 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -598,7 +598,7 @@ config CRYPTO_DEV_SAFEXCEL
 	select CRYPTO_AES
 	select CRYPTO_SHA1
 	help
-	  This driver interfaces with the SafeXcel EIP-197 cryptographic hardwares
+	  This driver interfaces with the SafeXcel EIP-97/197 cryptographic hardwares
 	  designed by Inside Secure. The driver support only basic initialiazation of the
 	  engine, without interacation with Kernel crypto API.
 
diff --git a/drivers/crypto/inside-secure/cipher.c b/drivers/crypto/inside-secure/cipher.c
index f3df43a..0b5f7d3 100644
--- a/drivers/crypto/inside-secure/cipher.c
+++ b/drivers/crypto/inside-secure/cipher.c
@@ -423,8 +423,16 @@ static int safexcel_aes(struct ablkcipher_request *req,
 	ctx->direction = dir;
 	ctx->mode = mode;
 
+	/*
+	 * Check if the context exists, if yes:
+	 *	- EIP197: check if it needs to be invalidated
+	 *	- EIP97: Nothing to be done
+	 * If context not exists, allocate it (for both EIP97 & EIP197)
+	 * and set the send routine for the new allocated context.
+	 * If it's EIP97 with existing context, the send routine is already set.
+	 */
 	if (ctx->base.ctxr) {
-		if (ctx->base.needs_inv)
+		if (priv->eip_type == EIP197 && ctx->base.needs_inv)
 			ctx->base.send = safexcel_cipher_send_inv;
 	} else {
 		ctx->base.ring = safexcel_select_ring(priv);
@@ -479,9 +487,23 @@ static void safexcel_ablkcipher_cra_exit(struct crypto_tfm *tfm)
 	if (!ctx->base.ctxr)
 		return;
 
-	ret = safexcel_cipher_exit_inv(tfm);
-	if (ret != -EINPROGRESS)
-		dev_warn(priv->dev, "cipher: invalidation error %d\n", ret);
+	/*
+	 * EIP197 has internal cache which needs to be invalidated
+	 * when the context is closed.
+	 * dma_pool_free will be called in the invalidation result
+	 * handler (different context).
+	 * EIP97 doesn't have internal cache, so no need to invalidate
+	 * it and we can just release the dma pool.
+	 */
+	if (priv->eip_type == EIP197) {
+		ret = safexcel_cipher_exit_inv(tfm);
+		if (ret != -EINPROGRESS)
+			dev_warn(priv->dev, "cipher: invalidation error %d\n",
+				 ret);
+	} else {
+		dma_pool_free(priv->context_pool, ctx->base.ctxr,
+			      ctx->base.ctxr_dma);
+	}
 }
 
 struct safexcel_alg_template safexcel_alg_ecb_aes = {
diff --git a/drivers/crypto/inside-secure/hash.c b/drivers/crypto/inside-secure/hash.c
index 9611dd8..a270a29 100644
--- a/drivers/crypto/inside-secure/hash.c
+++ b/drivers/crypto/inside-secure/hash.c
@@ -530,8 +530,16 @@ static int safexcel_ahash_update(struct ahash_request *areq)
 
 	ctx->base.send = safexcel_ahash_send;
 
+	/*
+	 * Check if the context exists, if yes:
+	 *	- EIP197: check if it needs to be invalidated
+	 *	- EIP97: Nothing to be done
+	 * If context not exists, allocate it (for both EIP97 & EIP197)
+	 * and set the send routine for the new allocated context.
+	 * If it's EIP97 with existing context, the send routine is already set.
+	 */
 	if (ctx->base.ctxr) {
-		if (ctx->base.needs_inv)
+		if (priv->eip_type == EIP197 && ctx->base.needs_inv)
 			ctx->base.send = safexcel_ahash_send_inv;
 	} else {
 		ctx->base.ring = safexcel_select_ring(priv);
@@ -556,11 +564,17 @@ static int safexcel_ahash_final(struct ahash_request *areq)
 {
 	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
 	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+	struct safexcel_crypto_priv *priv = ctx->priv;
 
 	req->last_req = true;
 	req->finish = true;
 
-	if (req->len && ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+	/*
+	 * Check if we need to invalidate the context,
+	 * this should be done only for EIP197 (no cache in EIP97).
+	 */
+	if (priv->eip_type == EIP197 && req->len &&
+	    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
 		ctx->base.needs_inv = safexcel_ahash_needs_inv_get(areq);
 
 	return safexcel_ahash_update(areq);
@@ -655,9 +669,22 @@ static void safexcel_ahash_cra_exit(struct crypto_tfm *tfm)
 	if (!ctx->base.ctxr)
 		return;
 
-	ret = safexcel_ahash_exit_inv(tfm);
-	if (ret != -EINPROGRESS)
-		dev_warn(priv->dev, "hash: invalidation error %d\n", ret);
+	/*
+	 * EIP197 has internal cache which needs to be invalidated
+	 * when the context is closed.
+	 * dma_pool_free will be called in the invalidation result
+	 * handler (different context).
+	 * EIP97 doesn't have internal cache, so no need to invalidate
+	 * it and we can just release the dma pool.
+	 */
+	if (priv->eip_type == EIP197) {
+		ret = safexcel_ahash_exit_inv(tfm);
+		if (ret != -EINPROGRESS)
+			dev_warn(priv->dev, "hash: invalidation error %d\n", ret);
+	} else {
+		dma_pool_free(priv->context_pool, ctx->base.ctxr,
+			      ctx->base.ctxr_dma);
+	}
 }
 
 struct safexcel_alg_template safexcel_alg_sha1 = {
@@ -766,6 +793,7 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
 				     unsigned int keylen)
 {
 	struct safexcel_ahash_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));
+	struct safexcel_crypto_priv *priv = ctx->priv;
 	struct ahash_request *areq;
 	struct crypto_ahash *ahash;
 	struct sha1_state s0, s1;
@@ -829,11 +857,17 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
 
 	ret = safexcel_hmac_prepare_pad(areq, opad, blocksize, &s1, false);
 
-	for (i = 0; i < ARRAY_SIZE(s0.state); i++) {
-		if (ctx->ipad[i] != le32_to_cpu(s0.state[i]) ||
-		    ctx->opad[i] != le32_to_cpu(s1.state[i])) {
-			ctx->base.needs_inv = true;
-			break;
+	/*
+	 * For EIP197 we need to Check if the ipad/opad were changed,
+	 * if yes, need to invalidate the context.
+	 */
+	if (priv->eip_type == EIP197) {
+		for (i = 0; i < ARRAY_SIZE(s0.state); i++) {
+			if (ctx->ipad[i] != le32_to_cpu(s0.state[i]) ||
+			    ctx->opad[i] != le32_to_cpu(s1.state[i])) {
+				ctx->base.needs_inv = true;
+				break;
+			}
 		}
 	}
 
diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
index ed8441a..92dd419 100644
--- a/drivers/crypto/inside-secure/safexcel.c
+++ b/drivers/crypto/inside-secure/safexcel.c
@@ -356,16 +356,29 @@ static void eip_priv_unit_offset_init(struct safexcel_crypto_priv *priv)
 {
 	struct safexcel_unit_offset *unit_off = &priv->unit_off;
 
-	unit_off->hia_aic = EIP197_HIA_AIC_ADDR;
-	unit_off->hia_aic_g = EIP197_HIA_AIC_G_ADDR;
-	unit_off->hia_aic_r = EIP197_HIA_AIC_R_ADDR;
-	unit_off->hia_xdr = EIP197_HIA_AIC_xDR_ADDR;
-	unit_off->hia_dfe = EIP197_HIA_AIC_DFE_ADDR;
-	unit_off->hia_dfe_thrd = EIP197_HIA_AIC_DFE_THRD_ADDR;
-	unit_off->hia_dse = EIP197_HIA_AIC_DSE_ADDR;
-	unit_off->hia_dse_thrd = EIP197_HIA_AIC_DSE_THRD_ADDR;
-	unit_off->hia_gen_cfg = EIP197_HIA_GC;
-	unit_off->pe = EIP197_HIA_PE_ADDR;
+	if (priv->eip_type == EIP197) {
+		unit_off->hia_aic = EIP197_HIA_AIC_ADDR;
+		unit_off->hia_aic_g = EIP197_HIA_AIC_G_ADDR;
+		unit_off->hia_aic_r = EIP197_HIA_AIC_R_ADDR;
+		unit_off->hia_xdr = EIP197_HIA_AIC_xDR_ADDR;
+		unit_off->hia_dfe = EIP197_HIA_AIC_DFE_ADDR;
+		unit_off->hia_dfe_thrd = EIP197_HIA_AIC_DFE_THRD_ADDR;
+		unit_off->hia_dse = EIP197_HIA_AIC_DSE_ADDR;
+		unit_off->hia_dse_thrd = EIP197_HIA_AIC_DSE_THRD_ADDR;
+		unit_off->hia_gen_cfg = EIP197_HIA_GC;
+		unit_off->pe = EIP197_HIA_PE_ADDR;
+	} else {
+		unit_off->hia_aic = EIP97_HIA_AIC_ADDR;
+		unit_off->hia_aic_g = EIP97_HIA_AIC_G_ADDR;
+		unit_off->hia_aic_r = EIP97_HIA_AIC_R_ADDR;
+		unit_off->hia_xdr = EIP97_HIA_AIC_xDR_ADDR;
+		unit_off->hia_dfe = EIP97_HIA_AIC_DFE_ADDR;
+		unit_off->hia_dfe_thrd = EIP97_HIA_AIC_DFE_THRD_ADDR;
+		unit_off->hia_dse = EIP97_HIA_AIC_DSE_ADDR;
+		unit_off->hia_dse_thrd = EIP97_HIA_AIC_DSE_THRD_ADDR;
+		unit_off->hia_gen_cfg = EIP97_HIA_GC;
+		unit_off->pe = EIP97_HIA_PE_ADDR;
+	}
 }
 
 /* Configure the command descriptor ring manager */
@@ -492,9 +505,12 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 	writel(EIP197_DxE_THR_CTRL_RESET_PE,
 	       EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL);
 
-	/* Reset HIA input interface arbiter */
-	writel(EIP197_HIA_RA_PE_CTRL_RESET,
-	       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
+	/* Configure ring arbiter, available only for EIP197 */
+	if (priv->eip_type == EIP197) {
+		/* Reset HIA input interface arbiter */
+		writel(EIP197_HIA_RA_PE_CTRL_RESET,
+		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
+	}
 
 	/* DMA transfer size to use */
 	val = EIP197_HIA_DFE_CFG_DIS_DEBUG;
@@ -513,9 +529,12 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(7),
 	      EIP197_PE(priv) + EIP197_PE_IN_TBUF_THRES);
 
-	/* enable HIA input interface arbiter and rings */
-	writel(EIP197_HIA_RA_PE_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
-	       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
+	/* Configure ring arbiter, available only for EIP197 */
+	if (priv->eip_type == EIP197) {
+		/* enable HIA input interface arbiter and rings */
+		writel(EIP197_HIA_RA_PE_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
+		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
+	}
 
 	/*
 	 * Data Store Engine configuration
@@ -535,7 +554,16 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
 	val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
-	val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
+	/*
+	 * TODO: Generally, EN_SINGLE_WR should be enabled.
+	 * Some instabilities with this option enabled might occur,
+	 * so further investigation is required before enabling it.
+	 *
+	 * Using EIP97 engine without SINGLE_WR impacts the performance.
+	 */
+	if (priv->eip_type == EIP197)
+		val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
+
 	writel(val, EIP197_HIA_DSE(priv) + EIP197_HIA_DSE_CFG);
 
 	/* Leave the DSE threads reset state */
@@ -610,21 +638,29 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 	/* Clear any HIA interrupt */
 	writel(EIP197_AIC_G_ACK_HIA_MASK, EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
 
-	/* init PRNG */
-	eip197_prng_init(priv);
+	/*
+	 * Initialize EIP197 specifics:
+	 *	- PRNG
+	 *	- Cache
+	 *	- Firmware
+	 */
+	if (priv->eip_type == EIP197) {
+		/* init PRNG */
+		eip197_prng_init(priv);
 
-	/* init transform record cache */
-	ret = eip197_trc_cache_init(dev, priv);
-	if (ret) {
-		dev_err(dev, "eip197_trc_cache_init failed\n");
-		return ret;
-	}
+		/* init transform record cache */
+		ret = eip197_trc_cache_init(dev, priv);
+		if (ret) {
+			dev_err(dev, "eip197_trc_cache_init failed\n");
+			return ret;
+		}
 
-	/* Firmware load */
-	ret = eip197_load_fw(dev, priv);
-	if (ret) {
-		dev_err(dev, "eip197_load_fw failed\n");
-		return ret;
+		/* Firmware load */
+		ret = eip197_load_fw(dev, priv);
+		if (ret) {
+			dev_err(dev, "eip197_load_fw failed\n");
+			return ret;
+		}
 	}
 
 	eip_hw_setup_cdesc_rings(priv);
@@ -1269,6 +1305,10 @@ static int safexcel_remove(struct platform_device *pdev)
 
 static const struct of_device_id safexcel_of_match_table[] = {
 	{
+		.compatible = "inside-secure,safexcel-eip97",
+		.data = (void *)EIP97,
+	},
+	{
 		.compatible = "inside-secure,safexcel-eip197",
 		.data = (void *)EIP197,
 	},
@@ -1288,5 +1328,5 @@ static int safexcel_remove(struct platform_device *pdev)
 MODULE_PARM_DESC(rings, "number of rings to be used by the driver");
 
 MODULE_AUTHOR("Antoine Tenart <antoine.tenart@free-electrons.com>");
-MODULE_DESCRIPTION("Support for SafeXcel Cryptographic Engines EIP197");
+MODULE_DESCRIPTION("Support for SafeXcel Cryptographic Engines EIP97/197");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
index b4b68ca..b980288 100644
--- a/drivers/crypto/inside-secure/safexcel.h
+++ b/drivers/crypto/inside-secure/safexcel.h
@@ -249,6 +249,17 @@
 #define EIP197_CLASSIFICATION_RAMS			0xe0000
 #define EIP197_HIA_GC					0xf0000
 
+#define EIP97_HIA_AIC_ADDR				0x00000
+#define EIP97_HIA_AIC_G_ADDR				0x00000
+#define EIP97_HIA_AIC_R_ADDR				0x00000
+#define EIP97_HIA_AIC_xDR_ADDR				0x00000
+#define EIP97_HIA_AIC_DFE_ADDR				0x0f000
+#define EIP97_HIA_AIC_DFE_THRD_ADDR			0x0f200
+#define EIP97_HIA_AIC_DSE_ADDR				0x0f400
+#define EIP97_HIA_AIC_DSE_THRD_ADDR			0x0f600
+#define EIP97_HIA_PE_ADDR				0x10000
+#define EIP97_HIA_GC					0x10000
+
 #define EIP197_HIA_AIC_R_OFF(r)			((r) * 0x1000)
 #define EIP197_HIA_AIC_R_ENABLE_CTRL(r)		(0xe008 - EIP197_HIA_AIC_R_OFF(r))
 #define EIP197_HIA_AIC_R_ENABLED_STAT(r)	(0xe010 - EIP197_HIA_AIC_R_OFF(r))
@@ -513,6 +524,7 @@ enum eip197_fw {
 
 enum safexcel_eip_type {
 	EIP197,
+	EIP97,
 };
 
 struct safexcel_ring {
-- 
1.7.9.5


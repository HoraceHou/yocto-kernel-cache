From 6b6d43a249c23d95eb99c41f3b14331affde6db6 Mon Sep 17 00:00:00 2001
From: Igal Liberman <igall@marvell.com>
Date: Sun, 5 Jun 2016 11:33:51 +0300
Subject: [PATCH 0592/1345] telephony: mvebu: introduce Marvell phone drivers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit  76e62cfed0071aae256343fea81ba5cf239125fe from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This drivers were originally imported from LKv3.10.

There are 2 types of telephony controllers in Marvel SoCs:
	- 2-channel TDM (TDM2C, available in A380)
	- Multi-channel TDM (TDMMC, available in A8k)
This patch adds support of both controllers.

Both drivers use SLIC (Subscriber line interface card) as the physical
Interface. SLIC requires its own drivers.

The general structure of the code is the following:
+¦¦ drivers
	+¦¦ telephony
		+¦¦ mvebu_phone
			+¦¦ slic
			+¦¦ tal
			+¦¦ tdm2c
			+¦¦ tdmmc

slic: glue layer between Marvell phone and SLIC drivers
tal: Telephony Adaptation Layer
tdm2c: TDM 2-channel support
tdmmc: TDM multi-channel support

NOTE: currently, TDMMC support only 2 channels.

Change-Id: I64de3eaed28a75e1f67b1fbbd10e18f2fb84cac4
Signed-off-by: Igal Liberman <igall@marvell.com>
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/33907
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/telephony/mvebu-phone.txt  |   78 ++
 drivers/Kconfig                                    |    2 +
 drivers/Makefile                                   |    1 +
 drivers/telephony/Kconfig                          |   32 +
 drivers/telephony/Makefile                         |    5 +
 drivers/telephony/mvebu_phone/Kconfig              |   34 +
 drivers/telephony/mvebu_phone/Makefile             |   35 +
 drivers/telephony/mvebu_phone/mv_phone.h           |  304 +++++
 drivers/telephony/mvebu_phone/mv_phone_dev.c       | 1290 ++++++++++++++++++++
 drivers/telephony/mvebu_phone/mv_phone_spi.c       |  199 +++
 drivers/telephony/mvebu_phone/slic/drv_dxt_if.c    |  184 +++
 drivers/telephony/mvebu_phone/slic/drv_dxt_if.h    |  116 ++
 drivers/telephony/mvebu_phone/slic/silabs_if.c     |  163 +++
 drivers/telephony/mvebu_phone/slic/silabs_if.h     |  119 ++
 drivers/telephony/mvebu_phone/slic/zarlink_if.c    |  158 +++
 drivers/telephony/mvebu_phone/slic/zarlink_if.h    |  117 ++
 drivers/telephony/mvebu_phone/tal/tal.c            |  212 ++++
 drivers/telephony/mvebu_phone/tal/tal.h            |  168 +++
 drivers/telephony/mvebu_phone/tal/tal_dev.c        |  342 ++++++
 drivers/telephony/mvebu_phone/tal/tal_dev.h        |  115 ++
 drivers/telephony/mvebu_phone/tdm2c/tdm2c.c        |  992 +++++++++++++++
 drivers/telephony/mvebu_phone/tdm2c/tdm2c.h        |  330 +++++
 drivers/telephony/mvebu_phone/tdmmc/tdmmc.c        |  986 +++++++++++++++
 drivers/telephony/mvebu_phone/tdmmc/tdmmc.h        |  401 ++++++
 24 files changed, 6383 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/telephony/mvebu-phone.txt
 create mode 100644 drivers/telephony/Kconfig
 create mode 100644 drivers/telephony/Makefile
 create mode 100644 drivers/telephony/mvebu_phone/Kconfig
 create mode 100644 drivers/telephony/mvebu_phone/Makefile
 create mode 100644 drivers/telephony/mvebu_phone/mv_phone.h
 create mode 100644 drivers/telephony/mvebu_phone/mv_phone_dev.c
 create mode 100644 drivers/telephony/mvebu_phone/mv_phone_spi.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/drv_dxt_if.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/drv_dxt_if.h
 create mode 100644 drivers/telephony/mvebu_phone/slic/silabs_if.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/silabs_if.h
 create mode 100644 drivers/telephony/mvebu_phone/slic/zarlink_if.c
 create mode 100644 drivers/telephony/mvebu_phone/slic/zarlink_if.h
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal.c
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal.h
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal_dev.c
 create mode 100644 drivers/telephony/mvebu_phone/tal/tal_dev.h
 create mode 100644 drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
 create mode 100644 drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
 create mode 100644 drivers/telephony/mvebu_phone/tdmmc/tdmmc.c
 create mode 100644 drivers/telephony/mvebu_phone/tdmmc/tdmmc.h

diff --git a/Documentation/devicetree/bindings/telephony/mvebu-phone.txt b/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
new file mode 100644
index 0000000..f5dfa4b
--- /dev/null
+++ b/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
@@ -0,0 +1,78 @@
+* mvebu (Armada 38x/XP/80x0) TDM telephony controller
+
+Required properties:
+
+- compatible:
+  "marvell,armada-380-tdm" for Armada 38x platforms
+  "marvell,armada-xp-tdm" for Armada AXP platforms
+  "marvell,armada-a8k-tdm" for Armada 80x0 platforms
+
+- reg: physical base address of the controller and length of memory mapped
+  region (named "tdm_regs").
+  With "marvell,armada-380-tdm" two other regions are required:
+  first of those is dedicated for Audio PLL Configuration registers
+  (named "pll_regs") and the second one ("dco_div") - for register
+  where DCO post-divider for PLL output is set.
+
+- interrupts - TDM controller interrupt
+
+- clocks: phandle for internal gate clock
+
+- clock-names: name associated to the clocks: "gateclk"
+
+Optional properties:
+
+- pclk-freq-mhz: internal pclk frequency. If not set, the driver uses
+  default value of 8 MHz
+
+- use-pclk-external: chooses SLIC as an external pclk source
+
+Example:
+
+tdm@b0000 {
+	compatible = "marvell,armada-380-tdm";
+	reg = <0xb0000 0x5000>, <0x18400 0xc>, <0x18730 0x4>;
+	reg-names = "tdm_regs", "pll_regs", "dco_div";
+	interrupts = <0 27 0x4>;
+	clocks = <&gateclk 25>;
+	clock-names = "gateclk";
+	pclk-freq-mhz = <8>;
+};
+
+In case an external SLIC is used, there is a need of instantiating it as
+a slave SPI device under one of SPI busses (please refer to:
+Documentation/devicetree/bindings/spi/spi-bus.txt)
+
+Required properties:
+
+- compatible: "mv_slic" for Armada 38x platforms
+
+- reg: SLIC slave spi device interface chip select number
+
+- spi-max-frequency: SLIC slave spi device interface max clock
+  frequency
+
+Zarlink/Silabs SLIC devices require also following properties:
+
+- spi-1byte-cs - switch CS every single byte transferred
+
+- spi-cpol - active-low clk
+
+- spi-cpha - accept data on clk trailing edge
+
+spi1: spi@10680 {
+	pinctrl-0 = <&spi1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	slic@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "mv_slic";
+		reg = <0>; /* Chip select 0 */
+		spi-max-frequency = <3000000>;
+		spi-1byte-cs;
+		spi-cpol;
+		spi-cpha;
+	};
+};
diff --git a/drivers/Kconfig b/drivers/Kconfig
index ba2901e..dccf043 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -186,6 +186,8 @@ source "drivers/perf/Kconfig"
 
 source "drivers/ras/Kconfig"
 
+source "drivers/telephony/Kconfig"
+
 source "drivers/thunderbolt/Kconfig"
 
 source "drivers/android/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index a5f3438..76ec079 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -149,6 +149,7 @@ obj-$(CONFIG_VHOST)		+= vhost/
 obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
+obj-$(CONFIG_PHONE)		+= telephony/
 
 obj-$(CONFIG_MAILBOX)		+= mailbox/
 obj-$(CONFIG_HWSPINLOCK)	+= hwspinlock/
diff --git a/drivers/telephony/Kconfig b/drivers/telephony/Kconfig
new file mode 100644
index 0000000..0ba3c89
--- /dev/null
+++ b/drivers/telephony/Kconfig
@@ -0,0 +1,32 @@
+#
+# Telephony device configuration
+#
+
+menuconfig PHONE
+	bool "Telephony devices support"
+	default y
+	---help---
+	  Say Y here to get to see options for hardware telephony devices.
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if PHONE
+
+config MV_INCLUDE_TDM
+	bool "Mvebu TDM Telephony"
+	depends on ARCH_MVEBU
+	default y
+	---help---
+	  This driver supports the TDM-based telephony interface
+	  units in the following Marvell SoC families:
+	  1. ARMADA-370.
+	  2. ARMADA-375.
+	  3. ARMADA-38x.
+	  4. ARMADA-XP.
+
+if MV_INCLUDE_TDM
+	source "drivers/telephony/mvebu_phone/Kconfig"
+endif
+
+endif # PHONE
diff --git a/drivers/telephony/Makefile b/drivers/telephony/Makefile
new file mode 100644
index 0000000..1a7a260
--- /dev/null
+++ b/drivers/telephony/Makefile
@@ -0,0 +1,5 @@
+#
+# linux/drivers/telephony/Makefile
+#
+
+obj-$(CONFIG_MV_INCLUDE_TDM)		+= mvebu_phone/
diff --git a/drivers/telephony/mvebu_phone/Kconfig b/drivers/telephony/mvebu_phone/Kconfig
new file mode 100644
index 0000000..24e5e32
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/Kconfig
@@ -0,0 +1,34 @@
+menu "Marvell Telephony options"
+	depends on MV_INCLUDE_TDM
+
+config MV_TDMMC_SUPPORT
+	bool "Support communit - multichannel TDM"
+	depends on MACH_ARMADA_XP || ARCH_MVEBU
+	default y
+	---help---
+	Choosing this option enables Marvell
+	32CH TDM voice interface.
+	The TDM bus may be used for transferring
+	voice samples through analog phone interface.
+
+config MV_TDM2C_SUPPORT
+	bool "Support legacy TDM(2 channels)"
+	depends on MACH_ARMADA_38X
+	default y
+	---help---
+	Choosing this option enables Marvell
+	2CH TDM voice interface.
+	The TDM bus may be used for transferring
+	voice samples through analog phone interface.
+
+config MV_TDM_EXT_STATS
+	bool "Enable legacy TDM extended statistics"
+	depends on MACH_ARMADA_38X
+	default y
+	---help---
+	Choosing this option will export
+	extended statistics to procfs.
+	This is relevant only for the
+	legacy TDM unit.
+
+endmenu
diff --git a/drivers/telephony/mvebu_phone/Makefile b/drivers/telephony/mvebu_phone/Makefile
new file mode 100644
index 0000000..a1c0f57
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/Makefile
@@ -0,0 +1,35 @@
+#
+# Makefile for mvebu_phone Marvell telephony driver
+#
+
+CPU_ARCH    = ARM
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+ccflags-y := -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+ccflags-y += -I$(srctree)/drivers/telephony/mvebu_phone
+
+# MAIN COMPONENTS
+PHONE_OBJS = mv_phone_dev.o
+PHONE_OBJS += mv_phone_spi.o
+
+# TAL
+PHONE_OBJS += tal/tal.o
+PHONE_OBJS += tal/tal_dev.o
+
+# SLIC
+PHONE_OBJS += slic/drv_dxt_if.o
+PHONE_OBJS += slic/silabs_if.o
+PHONE_OBJS += slic/zarlink_if.o
+
+# TDM2C support
+PHONE_OBJS += tdm2c/tdm2c.o
+
+# TDMMC support
+PHONE_OBJS += tdmmc/tdmmc.o
+
+mv_phone-objs := $(PHONE_OBJS)
+obj-y := mv_phone.o
diff --git a/drivers/telephony/mvebu_phone/mv_phone.h b/drivers/telephony/mvebu_phone/mv_phone.h
new file mode 100644
index 0000000..dcfdcb4
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone.h
@@ -0,0 +1,304 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*******************************************************************************
+* mv_phone.h - Marvell TDM unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef _MV_PHONE_H_
+#define _MV_PHONE_H_
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mbus.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include "tdm2c/tdm2c.h"
+#include "tdmmc/tdmmc.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+extern int use_pclk_external;
+extern long int tdm_base;
+#define MV_TDM_REGS_BASE	(tdm_base)
+
+/* Core DivClk Control Register */
+
+/* DCO clock apply/reset bits */
+#define DCO_CLK_DIV_MOD_OFFS			24
+#define DCO_CLK_DIV_APPLY_MASK			(0x1 << DCO_CLK_DIV_MOD_OFFS)
+#define DCO_CLK_DIV_RESET_OFFS			25
+#define DCO_CLK_DIV_RESET_MASK			(0x1 << DCO_CLK_DIV_RESET_OFFS)
+
+/* DCO clock ratio is 24Mhz/x */
+#define DCO_CLK_DIV_RATIO_OFFS			26
+#define DCO_CLK_DIV_RATIO_MASK			0xfc000000
+#define DCO_CLK_DIV_RATIO_8M			(0x3 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_4M			(0x6 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_2M			(0xc << DCO_CLK_DIV_RATIO_OFFS)
+
+/* TDM PLL configuration registers */
+#define TDM_PLL_CONF_REG0			0x0
+#define TDM_PLL_FB_CLK_DIV_OFFSET		10
+#define TDM_PLL_FB_CLK_DIV_MASK			0x7fc00
+
+#define TDM_PLL_CONF_REG1			0x4
+#define TDM_PLL_FREQ_OFFSET_MASK		0xffff
+#define TDM_PLL_FREQ_OFFSET_VALID		0x00010000
+#define TDM_PLL_SW_RESET			0x80000000
+
+#define TDM_PLL_CONF_REG2			0x8
+#define TDM_PLL_POSTDIV_MASK			0x7f
+
+/* TDM control/SPI registers used for suspend/resume */
+#define TDM_CTRL_REGS_NUM			36
+#define TDM_SPI_REGS_OFFSET			0x3100
+#define TDM_SPI_REGS_NUM			16
+
+/* Structures and enums */
+enum mv_phone_unit_type {
+	MV_TDM_UNIT_NONE,
+	MV_TDM_UNIT_TDM2C,
+	MV_TDM_UNIT_TDMMC
+};
+
+enum mv_phone_band_mode {
+	MV_NARROW_BAND = 0,
+	MV_WIDE_BAND,
+};
+
+enum mv_phone_pcm_format {
+	MV_PCM_FORMAT_1BYTE = 1,
+	MV_PCM_FORMAT_2BYTES = 2,
+	MV_PCM_FORMAT_4BYTES = 4
+};
+
+enum mv_phone_frame_ts {
+	MV_FRAME_32TS = 32,
+	MV_FRAME_64TS = 64,
+	MV_FRAME_128TS = 128
+};
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+struct mv_phone_extended_stats {
+	u32 int_rx_count;
+	u32 int_tx_count;
+	u32 int_rx0_count;
+	u32 int_tx0_count;
+	u32 int_rx1_count;
+	u32 int_tx1_count;
+	u32 int_rx0_miss;
+	u32 int_tx0_miss;
+	u32 int_rx1_miss;
+	u32 int_tx1_miss;
+	u32 pcm_restart_count;
+};
+#endif
+
+struct mv_phone_intr_info {
+	u8 *tdm_rx_buff;
+	u8 *tdm_tx_buff;
+	u32 int_type;
+	u8 cs;
+	u8 data;
+};
+
+struct mv_phone_params {
+	enum mv_phone_pcm_format pcm_format;
+	u16 pcm_slot[32];
+	u8 sampling_period;
+	u16 total_channels;
+};
+
+struct mv_phone_data {
+	u8 spi_mode;
+	u32 family_id;
+	enum mv_phone_frame_ts frame_ts;
+};
+
+struct mv_phone_dev {
+	void __iomem *tdm_base;
+	void __iomem *pll_base;
+	void __iomem *dco_div_reg;
+	struct mv_phone_params *tdm_params;
+	enum mv_phone_unit_type tdm_type;
+	struct platform_device *parent;
+	struct device_node *np;
+	struct clk *clk;
+	u32 pclk_freq_mhz;
+	int irq[3];
+
+	/* Used to preserve TDM registers across suspend/resume */
+	u32 tdm_ctrl_regs[TDM_CTRL_REGS_NUM];
+	u32 tdm_spi_regs[TDM_SPI_REGS_NUM];
+	u32 tdm_spi_mux_reg;
+	u32 tdm_mbus_config_reg;
+	u32 tdm_misc_reg;
+
+	struct device *dev;
+};
+
+/* This enumerator defines the Marvell Units ID */
+enum mv_phone_slic_unit_type {
+	SLIC_EXTERNAL_ID,
+	SLIC_ZARLINK_ID,
+	SLIC_SILABS_ID,
+	SLIC_LANTIQ_ID
+};
+
+enum mv_phone_spi_type {
+	SPI_TYPE_FLASH = 0,
+	SPI_TYPE_SLIC_ZARLINK_SILABS,
+	SPI_TYPE_SLIC_LANTIQ,
+	SPI_TYPE_SLIC_ZSI,
+	SPI_TYPE_SLIC_ISI
+};
+
+enum mv_phone_board_slic_type {
+	MV_BOARD_SLIC_DISABLED,
+	MV_BOARD_SLIC_SSI_ID, /* Lantiq Integrated SLIC */
+	MV_BOARD_SLIC_ISI_ID, /* Silicon Labs ISI Bus */
+	MV_BOARD_SLIC_ZSI_ID, /* Zarlink ZSI Bus */
+	MV_BOARD_SLIC_EXTERNAL_ID /* Cross vendor external SLIC */
+};
+
+/* Helper macros and routines */
+static inline void mv_phone_set_bit(void __iomem *addr, u32 bit_mask)
+{
+	writel(readl(addr) | bit_mask, addr);
+}
+
+static inline void mv_phone_reset_bit(void __iomem *addr, u32 bit_mask)
+{
+	writel(readl(addr) & ~bit_mask, addr);
+}
+
+/* MV Phone */
+u32 mv_phone_get_slic_board_type(void);
+void mv_phone_spi_write(u16 lineId, u8 *cmdBuff, u8 cmdSize,
+			u8 *dataBuff, u8 dataSize, u32 spiType);
+void mv_phone_spi_read(u16 lineId, u8 *cmdBuff, u8 cmdSize,
+		       u8 *dataBuff, u8 dataSize, u32 spiType);
+void mv_phone_intr_enable(u8 deviceId);
+void mv_phone_intr_disable(u8 deviceId);
+
+/* TDM2C */
+int tdm2c_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdmParams, struct mv_phone_data *halData);
+int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+void tdm2c_ext_stats_get(struct mv_phone_extended_stats *tdmExtStats);
+#endif
+
+/* TDMMC */
+int tdmmc_init(void __iomem *base, struct device *dev, struct mv_phone_params *tdm_params,
+	       struct mv_phone_data *hal_data);
+int tdmmc_intr_low(struct mv_phone_intr_info *tdm_intr_info);
+
+#endif /* _MV_PHONE_H_ */
+
diff --git a/drivers/telephony/mvebu_phone/mv_phone_dev.c b/drivers/telephony/mvebu_phone/mv_phone_dev.c
new file mode 100644
index 0000000..6b9ad28
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone_dev.c
@@ -0,0 +1,1290 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <slic/drv_dxt_if.h>
+#include <slic/silabs_if.h>
+#include <slic/zarlink_if.h>
+#include <tal/tal.h>
+#include <tal/tal_dev.h>
+#include "mv_phone.h"
+
+#define DRV_NAME "mvebu_phone"
+
+long int tdm_base;
+int use_pclk_external;
+int mv_phone_enabled;
+struct mv_phone_dev *priv;
+
+#define TDM_STOP_MAX_POLLING_TIME 20 /* ms */
+
+/* TDM Interrupt Service Routine */
+static irqreturn_t tdm_if_isr(int irq, void *dev_id);
+
+/* PCM start/stop */
+static void tdm_if_pcm_start(void);
+static void tdm_if_pcm_stop(void);
+
+/* Rx/Tx Tasklets  */
+#if !(defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) && !(defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static void tdm_if_pcm_rx_process(unsigned long arg);
+static void tdm_if_pcm_tx_process(unsigned long arg);
+#else
+static inline void tdm_if_pcm_rx_process(void);
+static inline void tdm_if_pcm_tx_process(void);
+#endif
+
+/* TDM SW Reset */
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+static void tdm2c_if_stop_channels(unsigned long args);
+#endif
+
+/* Module */
+static int tdm_if_module_init(void);
+static void tdm_if_module_exit(void);
+
+/* Globals */
+#if !(defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) && !(defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static DECLARE_TASKLET(tdm_if_rx_tasklet, tdm_if_pcm_rx_process, 0);
+static DECLARE_TASKLET(tdm_if_tx_tasklet, tdm_if_pcm_tx_process, 0);
+#endif
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+static DECLARE_TASKLET(tdm2c_if_stop_tasklet, tdm2c_if_stop_channels, 0);
+#endif
+static DEFINE_SPINLOCK(tdm_if_lock);
+static u8 *rx_buff, *tx_buff;
+static char irqnr[3];
+static u32 rx_miss, tx_miss;
+static u32 rx_over, tx_under;
+static struct proc_dir_entry *tdm_stats;
+static int pcm_enable;
+static int irq_init;
+static int tdm_init;
+static int buff_size;
+static u16 test_enable;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static u32 pcm_stop_fail;
+#endif
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+static int pcm_stop_flag;
+static int pcm_stop_status;
+static u32 pcm_start_stop_state;
+static u32 is_pcm_stopping;
+#endif
+static u32 mv_tdm_unit_type;
+
+/* Get TDM unit interrupt number */
+static u32 mv_phone_get_irq(int id)
+{
+	return priv->irq[id];
+}
+
+/* Get TDM unit type. */
+static enum mv_phone_unit_type mv_phone_get_unit_type(void)
+{
+	if (!mv_phone_enabled)
+		return MV_TDM_UNIT_NONE;
+
+	return priv->tdm_type;
+}
+
+/* Initialize the TDM subsystem. */
+static int mv_phone_init(struct mv_phone_params *tdm_params)
+{
+	struct mv_phone_data hal_data;
+	u8 spi_mode = 0;
+	int ret;
+
+	hal_data.spi_mode = spi_mode;
+
+	switch (priv->pclk_freq_mhz) {
+	case 8:
+		hal_data.frame_ts = MV_FRAME_128TS;
+		break;
+	case 4:
+		hal_data.frame_ts = MV_FRAME_64TS;
+		break;
+	case 2:
+		hal_data.frame_ts = MV_FRAME_32TS;
+		break;
+	default:
+		hal_data.frame_ts = MV_FRAME_128TS;
+		break;
+	}
+
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		ret = tdm2c_init(priv->tdm_base, priv->dev, tdm_params, &hal_data);
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		ret = tdmmc_init(priv->tdm_base, priv->dev, tdm_params, &hal_data);
+		/* Issue SLIC reset */
+		ret |= tdmmc_reset_slic();
+		break;
+	default:
+		dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	priv->tdm_params = tdm_params;
+
+	return ret;
+}
+
+static int proc_tdm_status_show(struct seq_file *m, void *v)
+{
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	struct mv_phone_extended_stats tdm_ext_stats;
+#endif
+
+	seq_printf(m, "tdm_init:	%u\n", tdm_init);
+	seq_printf(m, "rx_miss:		%u\n", rx_miss);
+	seq_printf(m, "tx_miss:		%u\n", tx_miss);
+	seq_printf(m, "rx_over:		%u\n", rx_over);
+	seq_printf(m, "tx_under:	%u\n", tx_under);
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	tdm2c_ext_stats_get(&tdm_ext_stats);
+
+	seq_puts(m, "\nTDM Extended Statistics:\n");
+	seq_printf(m, "int_rx_count	= %u\n", tdm_ext_stats.int_rx_count);
+	seq_printf(m, "int_tx_count	= %u\n", tdm_ext_stats.int_tx_count);
+	seq_printf(m, "int_rx0_count	= %u\n", tdm_ext_stats.int_rx0_count);
+	seq_printf(m, "int_tx0_count	= %u\n", tdm_ext_stats.int_tx0_count);
+	seq_printf(m, "int_rx1_count	= %u\n", tdm_ext_stats.int_rx1_count);
+	seq_printf(m, "int_tx1_count	= %u\n", tdm_ext_stats.int_tx1_count);
+	seq_printf(m, "int_rx0_miss	= %u\n", tdm_ext_stats.int_rx0_miss);
+	seq_printf(m, "int_tx0_miss	= %u\n", tdm_ext_stats.int_tx0_miss);
+	seq_printf(m, "int_tx1_miss	= %u\n", tdm_ext_stats.int_rx1_miss);
+	seq_printf(m, "int_tx1_miss	= %u\n", tdm_ext_stats.int_tx1_miss);
+	seq_printf(m, "pcm_restart_count= %u\n", tdm_ext_stats.pcm_restart_count);
+	seq_printf(m, "pcm_stop_fail	= %u\n", pcm_stop_fail);
+#endif
+	return 0;
+}
+
+static int proc_tdm_status_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_tdm_status_show, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_tdm_operations = {
+	.open		= proc_tdm_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static void tdm_if_unit_type_set(u32 tdm_unit)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+
+	mv_tdm_unit_type = tdm_unit;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+}
+
+static u32 tdm_if_unit_type_get(void)
+{
+	return mv_tdm_unit_type;
+}
+
+int tdm_if_init(struct tal_params *tal_params)
+{
+	struct mv_phone_params tdm_params;
+	int ret;
+
+	if (tdm_init) {
+		dev_warn(priv->dev, "Marvell Telephony Driver already started...\n");
+		return 0;
+	}
+
+	dev_info(priv->dev, "Loading Marvell Telephony Driver\n");
+
+	if (!tal_params) {
+		dev_err(priv->dev, "%s: bad parameters\n", __func__);
+		return -EINVAL;
+
+	}
+
+	/* Reset globals */
+	rx_buff = tx_buff = NULL;
+	irq_init = 0;
+	tdm_init = 0;
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C) {
+
+		pcm_enable = 0;
+		is_pcm_stopping = 0;
+		pcm_stop_flag = 0;
+		pcm_stop_status = 0;
+	}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC)
+		pcm_enable = 1;
+#endif
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	pcm_stop_fail = 0;
+#endif
+
+	/* Calculate Rx/Tx buffer size(use in callbacks) */
+	buff_size = (tal_params->pcm_format * tal_params->total_lines * 80 *
+			(tal_params->sampling_period/MV_TDM_BASE_SAMPLING_PERIOD));
+
+	/* Extract TDM irq number */
+	irqnr[0] = mv_phone_get_irq(0);
+#if (!(defined(CONFIG_MACH_ARMADA_38X) || defined(CONFIG_MACH_ARMADA_XP)))
+	irqnr[1] = mv_phone_get_irq(1);
+	irqnr[2] = mv_phone_get_irq(2);
+#endif
+
+	/* Assign TDM parameters */
+	memcpy(&tdm_params, tal_params, sizeof(struct mv_phone_params));
+
+	/* TDM init */
+	ret = mv_phone_init(&tdm_params);
+	if (ret) {
+		dev_err(priv->dev, "%s: Error, TDM initialization failed !!!\n", __func__);
+		return ret;
+	}
+	tdm_init = 1;
+
+	/* Soft reset to PCM I/F */
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C)
+		tdm2c_pcm_if_reset();
+#endif
+
+	/* Register TDM interrupt */
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	ret = request_fiq(irqnr[0], tdm_if_isr, 0x0, "tdm", NULL);
+	if (ret) {
+		dev_err(priv->dev, "%s: Failed to connect fiq(%d)\n", __func__, irqnr[0]);
+		return ret;
+	}
+#else /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+	ret = request_irq(irqnr[0], tdm_if_isr, 0x0, "tdm", NULL);
+	if (ret) {
+		dev_err(priv->dev, "%s: Failed to connect irq(%d)\n", __func__, irqnr[0]);
+		return ret;
+	}
+#if (!(defined(CONFIG_MACH_ARMADA_38X) || defined(CONFIG_MACH_ARMADA_XP)))
+	/* XXX add proper error path */
+	ret = request_irq(irqnr[1], tdm_if_isr, 0x0, "tdm", NULL);
+	if (ret) {
+		dev_err(priv->dev, "%s: Failed to connect irq(%d)\n", __func__, irqnr[1]);
+		return ret;
+	}
+	ret = request_irq(irqnr[2], tdm_if_isr, 0x0, "tdm", NULL);
+	if (ret) {
+		dev_err(priv->dev, "%s: Failed to connect irq(%d)\n", __func__, irqnr[2]);
+		return ret;
+	}
+#endif
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+
+	irq_init = 1;
+
+	/* Create TDM procFS statistics */
+	tdm_stats = proc_mkdir("tdm", NULL);
+	if (tdm_stats != NULL) {
+		if (!proc_create("tdm_stats", S_IRUGO, tdm_stats, &proc_tdm_operations))
+			return -ENOMEM;
+	}
+
+	/* WA to stop the MCDMA gracefully after commUnit initialization */
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC)
+		tdm_if_pcm_stop();
+#endif
+	return 0;
+}
+
+
+void tdm_if_exit(void)
+{
+	/* Check if already stopped */
+	if (!irq_init && !pcm_enable && !tdm_init)
+		return;
+
+	/* Stop PCM channels */
+	if (pcm_enable)
+		tdm_if_pcm_stop();
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C) {
+			u32 max_poll = 0;
+
+			while ((is_pcm_stopping != 0) && (max_poll < 20)) {
+				mdelay(1);
+				max_poll++;
+			}
+
+			if (max_poll >= 20)
+				dev_warn(priv->dev, "%s: waiting for pcm channels to stop exceeded 20ms\n", __func__);
+		}
+#endif
+
+	if (irq_init) {
+		/* Release interrupt */
+#ifndef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+		free_irq(irqnr[0], NULL);
+#if (!(defined(CONFIG_MACH_ARMADA_38X) || defined(CONFIG_MACH_ARMADA_XP)))
+		free_irq(irqnr[1], NULL);
+		free_irq(irqnr[2], NULL);
+#endif
+#else /* !CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+		free_fiq(irqnr[0], NULL);
+#endif /* !CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+		irq_init = 0;
+	}
+
+	if (tdm_init) {
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C)
+			tdm2c_release();
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC)
+			tdmmc_release();
+#endif
+		/* Remove proc directory & entries */
+		remove_proc_entry("tdm_stats", tdm_stats);
+		remove_proc_entry("tdm", NULL);
+
+		tdm_init = 0;
+	}
+}
+
+static void tdm_if_pcm_start(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	if (!pcm_enable) {
+		pcm_enable = 1;
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C) {
+			u32 max_poll = 0;
+
+			if (is_pcm_stopping == 0) {
+				pcm_stop_flag = 0;
+				pcm_stop_status = 0;
+				pcm_start_stop_state = 0;
+				rx_buff = tx_buff = NULL;
+				tdm2c_pcm_start();
+			} else {
+				pcm_start_stop_state++;
+				while (is_pcm_stopping && max_poll < TDM_STOP_MAX_POLLING_TIME) {
+					spin_unlock_irqrestore(&tdm_if_lock, flags);
+					mdelay(1);
+					max_poll++;
+					spin_lock_irqsave(&tdm_if_lock, flags);
+				}
+
+				if (is_pcm_stopping) {
+					/* Issue found or timeout */
+					if (tdm2c_pcm_stop_int_miss())
+						dev_dbg(priv->dev, "pcm stop issue found\n");
+					else
+						dev_dbg(priv->dev, "pcm stop timeout\n");
+
+					is_pcm_stopping = 0;
+					pcm_stop_flag = 0;
+					pcm_stop_status = 0;
+					pcm_start_stop_state = 0;
+					rx_buff = tx_buff = NULL;
+					tdm2c_pcm_start();
+				} else {
+					dev_dbg(priv->dev, "pcm_start_stop_state(%d), max_poll=%d\n",
+						pcm_start_stop_state, max_poll);
+				}
+			}
+		}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC) {
+			rx_buff = tx_buff = NULL;
+			tdmmc_pcm_start();
+		}
+#endif
+	}
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+}
+
+static void tdm_if_pcm_stop(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	if (pcm_enable) {
+		pcm_enable = 0;
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C) {
+			if (is_pcm_stopping == 0) {
+				is_pcm_stopping = 1;
+				tdm2c_pcm_stop();
+			} else {
+				pcm_start_stop_state--;
+				dev_dbg(priv->dev, "pcm_start_stop_state(%d)\n",
+					pcm_start_stop_state);
+			}
+		}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC)
+			tdmmc_pcm_stop();
+#endif
+	}
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+}
+
+static irqreturn_t tdm_if_isr(int irq, void *dev_id)
+{
+	struct mv_phone_intr_info tdm_int_info;
+	u32 int_type;
+	int ret = 0;
+
+	/* Extract interrupt information from low level ISR */
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C)
+		ret = tdm2c_intr_low(&tdm_int_info);
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC)
+		ret = tdmmc_intr_low(&tdm_int_info);
+#endif
+
+	int_type = tdm_int_info.int_type;
+	/*device_id = tdm_int_info.cs;*/
+
+	/* Handle ZSI interrupts */
+	if (mv_phone_get_slic_board_type() == MV_BOARD_SLIC_ZSI_ID)
+		zarlink_if_zsi_interrupt();
+	/* Handle ISI interrupts */
+	else if (mv_phone_get_slic_board_type() == MV_BOARD_SLIC_ISI_ID)
+		silabs_if_isi_interrupt();
+
+	/* Nothing to do - return */
+	if (int_type == MV_EMPTY_INT)
+		goto out;
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C) {
+		if ((ret == -1) && (pcm_stop_status == 0))	{
+			pcm_stop_status = 1;
+
+			/* If Rx/Tx tasklets already scheduled, let them do the work. */
+			if ((!rx_buff) && (!tx_buff)) {
+				dev_dbg(priv->dev, "Stopping the TDM\n");
+				tdm_if_pcm_stop();
+				pcm_stop_flag = 0;
+				tasklet_hi_schedule(&tdm2c_if_stop_tasklet);
+			} else {
+				dev_dbg(priv->dev, "Some tasklet is running, mark pcm_stop_flag\n");
+				pcm_stop_flag = 1;
+			}
+		}
+
+		/* Restarting PCM, skip Rx/Tx handling */
+		if (pcm_stop_status)
+			goto skip_rx_tx;
+	}
+#endif
+
+	/* Support multiple interrupt handling */
+	/* RX interrupt */
+	if (int_type & MV_RX_INT) {
+		if (rx_buff != NULL) {
+			rx_miss++;
+			dev_dbg(priv->dev, "%s: Warning, missed Rx buffer processing !!!\n", __func__);
+		} else {
+			rx_buff = tdm_int_info.tdm_rx_buff;
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+			dev_dbg(priv->dev, "%s: running Rx in ISR\n", __func__);
+			tdm_if_pcm_rx_process();
+#else
+			/* Schedule Rx processing within SOFT_IRQ context */
+			dev_dbg(priv->dev, "%s: schedule Rx tasklet\n", __func__);
+			tasklet_hi_schedule(&tdm_if_rx_tasklet);
+#endif
+		}
+	}
+
+	/* TX interrupt */
+	if (int_type & MV_TX_INT) {
+		if (tx_buff != NULL) {
+			tx_miss++;
+			dev_dbg(priv->dev, "%s: Warning, missed Tx buffer processing !!!\n", __func__);
+		} else {
+			tx_buff = tdm_int_info.tdm_tx_buff;
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+			dev_dbg(priv->dev, "%s: running Tx in ISR\n", __func__);
+			tdm_if_pcm_tx_process();
+#else
+			/* Schedule Tx processing within SOFT_IRQ context */
+			dev_dbg(priv->dev, "%s: schedule Tx tasklet\n", __func__);
+			tasklet_hi_schedule(&tdm_if_tx_tasklet);
+#endif
+		}
+	}
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C) {
+		/* TDM2CH PCM channels stop indication */
+		if ((int_type & MV_CHAN_STOP_INT) && (tdm_int_info.data == 4)) {
+			dev_dbg(priv->dev, "%s: Received MV_CHAN_STOP_INT indication\n", __func__);
+			is_pcm_stopping = 0;
+			if (pcm_start_stop_state) {
+				dev_dbg(priv->dev, "%s: calling to tdm_if_pcm_start()\n", __func__);
+				pcm_enable = 0;
+				tdm_if_pcm_start();
+			}
+		}
+	}
+#endif
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+skip_rx_tx:
+#endif
+
+	/* PHONE interrupt, Lantiq specific */
+	if (int_type & MV_PHONE_INT) {
+		/* TBD */
+		drv_dxt_if_signal_interrupt();
+	}
+
+	/* ERROR interrupt */
+	if (int_type & MV_ERROR_INT) {
+		if (int_type & MV_RX_ERROR_INT)
+			rx_over++;
+
+		if (int_type & MV_TX_ERROR_INT)
+			tx_under++;
+	}
+
+out:
+	return IRQ_HANDLED;
+}
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static inline void tdm_if_pcm_rx_process(void)
+#else
+/* Rx tasklet */
+static void tdm_if_pcm_rx_process(unsigned long arg)
+#endif
+{
+	unsigned long flags;
+	u32 tdm_type;
+
+	tdm_type = tdm_if_unit_type_get();
+	if (pcm_enable) {
+		if (rx_buff == NULL) {
+			dev_warn(priv->dev, "%s: Error, empty Rx processing\n", __func__);
+			return;
+		}
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		/* Fill TDM Rx aggregated buffer */
+		if (tdm_type == MV_TDM_UNIT_TDM2C) {
+			if (tdm2c_rx(rx_buff) == 0)
+				tal_mmp_rx(rx_buff, buff_size); /* Dispatch Rx handler */
+			else
+				dev_warn(priv->dev, "%s: could not fill Rx buffer\n", __func__);
+		}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (tdm_type == MV_TDM_UNIT_TDMMC) {
+			if (tdmmc_rx(rx_buff) == 0)
+				tal_mmp_rx(rx_buff, buff_size); /* Dispatch Rx handler */
+			else
+				dev_warn(priv->dev, "%s: could not fill Rx buffer\n", __func__);
+		}
+#endif
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	/* Clear rx_buff for next iteration */
+	rx_buff = NULL;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_type == MV_TDM_UNIT_TDM2C) {
+		if ((pcm_stop_flag == 1) && !tx_buff) {
+			dev_dbg(priv->dev, "Stopping TDM from Rx tasklet\n");
+			tdm_if_pcm_stop();
+			spin_lock_irqsave(&tdm_if_lock, flags);
+			pcm_stop_flag = 0;
+			spin_unlock_irqrestore(&tdm_if_lock, flags);
+			tasklet_hi_schedule(&tdm2c_if_stop_tasklet);
+		}
+	}
+#endif
+}
+
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static inline void tdm_if_pcm_tx_process(void)
+#else
+/* Tx tasklet */
+static void tdm_if_pcm_tx_process(unsigned long arg)
+#endif
+{
+	unsigned long flags;
+	u32 tdm_type;
+
+	tdm_type = tdm_if_unit_type_get();
+
+	if (pcm_enable) {
+		if (tx_buff == NULL) {
+			dev_warn(priv->dev, "%s: Error, empty Tx processing\n", __func__);
+			return;
+		}
+
+		/* Dispatch Tx handler */
+		tal_mmp_tx(tx_buff, buff_size);
+
+		if (test_enable == 0) {
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+			/* Fill Tx aggregated buffer */
+			if (tdm_type == MV_TDM_UNIT_TDM2C) {
+				if (tdm2c_tx(tx_buff) != 0)
+					dev_warn(priv->dev, "%s: could not fill Tx buffer\n", __func__);
+			}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+			if (tdm_type == MV_TDM_UNIT_TDMMC) {
+				if (tdmmc_tx(tx_buff) != 0)
+					dev_warn(priv->dev, "%s: could not fill Tx buffer\n", __func__);
+			}
+#endif
+		}
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	/* Clear tx_buff for next iteration */
+	tx_buff = NULL;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (tdm_type == MV_TDM_UNIT_TDM2C) {
+		if ((pcm_stop_flag == 1) && !rx_buff) {
+			dev_dbg(priv->dev, "Stopping TDM from Tx tasklet\n");
+			tdm_if_pcm_stop();
+			spin_lock_irqsave(&tdm_if_lock, flags);
+			pcm_stop_flag = 0;
+			spin_unlock_irqrestore(&tdm_if_lock, flags);
+			tasklet_hi_schedule(&tdm2c_if_stop_tasklet);
+		}
+	}
+#endif
+}
+
+static void tdm_if_stats_get(struct tal_stats *tdm_if_stats)
+{
+	if (tdm_init == 0)
+		return;
+
+	tdm_if_stats->tdm_init = tdm_init;
+	tdm_if_stats->rx_miss = rx_miss;
+	tdm_if_stats->tx_miss = tx_miss;
+	tdm_if_stats->rx_over = rx_over;
+	tdm_if_stats->tx_under = tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	tdm2c_ext_stats_get(&tdm_if_stats->tdm_ext_stats);
+#endif
+}
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+static void tdm2c_if_stop_channels(unsigned long arg)
+{
+	u32 max_poll = 0;
+	unsigned long flags;
+	void __iomem *tdm_base = get_tdm_base();
+
+	/* Wait for all channels to stop  */
+	while (((readl(tdm_base + CH_ENABLE_REG(0)) & 0x101) ||
+		(readl(tdm_base + CH_ENABLE_REG(1)) & 0x101)) && (max_poll < 30)) {
+		mdelay(1);
+		max_poll++;
+	}
+
+	dev_dbg(priv->dev, "Finished polling on channels disable\n");
+	if (max_poll >= 30) {
+		writel(0, tdm_base + CH_ENABLE_REG(0));
+		writel(0, tdm_base + CH_ENABLE_REG(1));
+		dev_warn(priv->dev, "\n\npolling on channels disabling exceeded 30ms\n\n");
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		pcm_stop_fail++;
+#endif
+		mdelay(10);
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	is_pcm_stopping = 0;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+	tdm_if_pcm_start();
+}
+#endif
+
+static int tdm_if_control(int cmd, void *arg)
+{
+	switch (cmd) {
+	case TDM_DEV_TDM_TEST_MODE_ENABLE:
+		test_enable = 1;
+		break;
+
+	case TDM_DEV_TDM_TEST_MODE_DISABLE:
+		test_enable = 0;
+		break;
+
+	default:
+		return -EINVAL;
+	};
+
+	return 0;
+}
+
+static int tdm_if_write(u8 *buffer, int size)
+{
+	if (test_enable) {
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDM2C)
+			return tdm2c_tx(buffer);
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (tdm_if_unit_type_get() == MV_TDM_UNIT_TDMMC)
+			return tdmmc_tx(buffer);
+#endif
+	}
+	return 0;
+}
+
+static struct tal_if tdm_if = {
+	.init		= tdm_if_init,
+	.exit		= tdm_if_exit,
+	.pcm_start	= tdm_if_pcm_start,
+	.pcm_stop	= tdm_if_pcm_stop,
+	.control	= tdm_if_control,
+	.write		= tdm_if_write,
+	.stats_get	= tdm_if_stats_get,
+};
+
+static int tdm_if_module_init(void)
+{
+	u32 tdm_unit;
+
+	tdm_unit = mv_phone_get_unit_type();
+
+	if ((tdm_unit == MV_TDM_UNIT_TDM2C) ||
+		tdm_unit == MV_TDM_UNIT_TDMMC) {
+		tal_set_if(&tdm_if);
+		tdm_if_unit_type_set(tdm_unit);
+	}
+	return 0;
+}
+
+static void tdm_if_module_exit(void)
+{
+	u32 tdm_unit;
+
+	tdm_unit = mv_phone_get_unit_type();
+	if (tdm_unit == MV_TDM_UNIT_TDM2C ||
+	    tdm_unit == MV_TDM_UNIT_TDMMC)
+		tal_set_if(NULL);
+}
+
+/* Enable device interrupts. */
+void mv_phone_intr_enable(u8 dev_id)
+{
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		tdm2c_intr_enable();
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		tdmmc_intr_enable(dev_id);
+		break;
+	default:
+		dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+			__func__);
+	}
+}
+
+/* Disable device interrupts. */
+void mv_phone_intr_disable(u8 dev_id)
+{
+	switch (priv->tdm_type) {
+	case MV_TDM_UNIT_TDM2C:
+		tdm2c_intr_disable();
+		break;
+	case MV_TDM_UNIT_TDMMC:
+		tdmmc_intr_disable(dev_id);
+		break;
+	default:
+		dev_err(&priv->parent->dev, "%s: undefined TDM type\n",
+			__func__);
+	}
+}
+
+/* Get board type for SLIC unit (pre-defined). */
+u32 mv_phone_get_slic_board_type(void)
+{
+	return MV_BOARD_SLIC_DISABLED;
+}
+
+/* Configure PLL to 24MHz */
+static int mv_phone_tdm_clk_pll_config(struct platform_device *pdev)
+{
+	struct resource *mem;
+	u32 reg_val;
+	u16 freq_offset = 0x22b0;
+	u8 tdm_postdiv = 0x6, fb_clk_div = 0x1d;
+
+	if (!priv->pll_base) {
+		mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "pll_regs");
+		priv->pll_base = devm_ioremap_resource(&pdev->dev, mem);
+		if (IS_ERR(priv->pll_base))
+			return -ENOMEM;
+	}
+
+	/* Set frequency offset value to not valid and enable PLL reset */
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG1);
+	reg_val &= ~TDM_PLL_FREQ_OFFSET_VALID;
+	reg_val &= ~TDM_PLL_SW_RESET;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Update PLL parameters */
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG0);
+	reg_val &= ~TDM_PLL_FB_CLK_DIV_MASK;
+	reg_val |= (fb_clk_div << TDM_PLL_FB_CLK_DIV_OFFSET);
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG0);
+
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG2);
+	reg_val &= ~TDM_PLL_POSTDIV_MASK;
+	reg_val |= tdm_postdiv;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG2);
+
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG1);
+	reg_val &= ~TDM_PLL_FREQ_OFFSET_MASK;
+	reg_val |= freq_offset;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Disable reset */
+	reg_val |= TDM_PLL_SW_RESET;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	/* Wait 50us for PLL to lock */
+	udelay(50);
+
+	/* Restore frequency offset value validity */
+	reg_val |= TDM_PLL_FREQ_OFFSET_VALID;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	return 0;
+}
+
+/* Set DCO post divider in respect of 24MHz PLL output */
+static int mv_phone_dco_post_div_config(struct platform_device *pdev,
+					u32 pclk_freq_mhz)
+{
+	struct resource *mem;
+	u32 reg_val, pcm_clk_ratio;
+
+	if (!priv->dco_div_reg) {
+		mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "dco_div");
+		priv->dco_div_reg = devm_ioremap_resource(&pdev->dev, mem);
+		if (IS_ERR(priv->dco_div_reg))
+			return -ENOMEM;
+	}
+
+	switch (pclk_freq_mhz) {
+	case 8:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_8M;
+		break;
+	case 4:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_4M;
+		break;
+	case 2:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_2M;
+		break;
+	default:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_8M;
+		break;
+	}
+
+	/* Disable output clock */
+	reg_val = readl(priv->dco_div_reg);
+	reg_val &= ~DCO_CLK_DIV_RESET_MASK;
+	writel(reg_val, priv->dco_div_reg);
+
+	/* Set DCO source ratio */
+	reg_val = readl(priv->dco_div_reg);
+	writel((reg_val & ~DCO_CLK_DIV_RATIO_MASK) | pcm_clk_ratio,
+	       priv->dco_div_reg);
+
+	/* Reload new DCO source ratio */
+	reg_val = readl(priv->dco_div_reg);
+	reg_val |= DCO_CLK_DIV_APPLY_MASK;
+	writel(reg_val, priv->dco_div_reg);
+	mdelay(1);
+
+	reg_val = readl(priv->dco_div_reg);
+	reg_val &= ~DCO_CLK_DIV_APPLY_MASK;
+	writel(reg_val, priv->dco_div_reg);
+	mdelay(1);
+
+	/* Enable output clock */
+	reg_val = readl(priv->dco_div_reg);
+	reg_val |= DCO_CLK_DIV_RESET_MASK;
+	writel(reg_val, priv->dco_div_reg);
+
+	return 0;
+}
+
+/* Initialize decoding windows */
+static int mv_tdm2c_mbus_windows(struct device *dev, void __iomem *regs,
+				 const struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	if (!dram) {
+		dev_err(dev, "no mbus dram info\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < TDM_MBUS_MAX_WIN; i++) {
+		writel(0, regs + TDM_WIN_CTRL_REG(i));
+		writel(0, regs + TDM_WIN_BASE_REG(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+
+		/* Write size, attributes and target id to control register */
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+			regs + TDM_WIN_CTRL_REG(i));
+		/* Write base address to base register */
+		writel(cs->base, regs + TDM_WIN_BASE_REG(i));
+	}
+
+	return 0;
+}
+
+/* Initialize decoding windows */
+static int mv_tdmmc_a8k_windows(struct device *dev, void __iomem *regs)
+{
+	int i;
+
+	for (i = 0; i < COMM_UNIT_MBUS_MAX_WIN; i++) {
+		writel(0xce00, regs + COMM_UNIT_WIN_CTRL_REG(i));
+		writel(0xffff0000, regs + COMM_UNIT_WIN_SIZE_REG(i));
+		if (i > 0)
+			writel(0x0, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+	}
+
+	return 0;
+}
+
+static int mvebu_phone_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *mem;
+	int err;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct mv_phone_dev),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->np = np;
+
+	mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tdm_regs");
+	priv->tdm_base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(priv->tdm_base))
+		return PTR_ERR(priv->tdm_base);
+	tdm_base = (long int)priv->tdm_base;
+
+	/* Get the first IRQ */
+	priv->irq[0] = platform_get_irq(pdev, 0);
+	if (priv->irq[0] <= 0) {
+		dev_err(&pdev->dev, "platform_get_irq failed\n");
+		return -ENXIO;
+	}
+
+	priv->clk = devm_clk_get(&pdev->dev, "gateclk");
+	if (PTR_ERR(priv->clk) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	if (IS_ERR(priv->clk)) {
+		dev_err(&pdev->dev, "no clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	if (of_property_read_bool(np, "use-external-pclk")) {
+		dev_info(&pdev->dev, "using external pclk\n");
+		use_pclk_external = 1;
+	} else {
+		dev_info(&pdev->dev, "using internal pclk\n");
+		use_pclk_external = 0;
+	}
+
+	if (of_property_read_u32(np, "pclk-freq-mhz", &priv->pclk_freq_mhz) ||
+	    (priv->pclk_freq_mhz != 8 && priv->pclk_freq_mhz != 4 &&
+	     priv->pclk_freq_mhz != 2)) {
+		priv->pclk_freq_mhz = 8;
+		dev_info(&pdev->dev, "wrong pclk frequency in the DT\n");
+	}
+	dev_info(&pdev->dev, "setting pclk frequency to %d MHz\n",
+		 priv->pclk_freq_mhz);
+
+	if (of_device_is_compatible(np, "marvell,armada-380-tdm")) {
+		priv->tdm_type = MV_TDM_UNIT_TDM2C;
+		err = mv_phone_tdm_clk_pll_config(pdev);
+		err |= mv_phone_dco_post_div_config(pdev, priv->pclk_freq_mhz);
+		err |= mv_tdm2c_mbus_windows(&pdev->dev, priv->tdm_base,
+					     mv_mbus_dram_info());
+		if (err < 0)
+			goto err_clk;
+	}
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-xp-tdm")) {
+		priv->tdm_type = MV_TDM_UNIT_TDMMC;
+		err = tdmmc_set_mbus_windows(&pdev->dev, priv->tdm_base);
+		if (err < 0)
+			goto err_clk;
+	}
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-a8k-tdm")) {
+		priv->tdm_type = MV_TDM_UNIT_TDMMC;
+		mv_tdmmc_a8k_windows(&pdev->dev, priv->tdm_base);
+
+		/* Get the second and third IRQ - in A8k there are 3 IRQs */
+		priv->irq[1] = platform_get_irq(pdev, 1);
+		if (priv->irq[1] <= 0) {
+			dev_err(&pdev->dev, "platform_get_irq failed\n");
+			return -ENXIO;
+		}
+		priv->irq[2] = platform_get_irq(pdev, 2);
+		if (priv->irq[2] <= 0) {
+			dev_err(&pdev->dev, "platform_get_irq failed\n");
+			return -ENXIO;
+		}
+	}
+
+	mv_phone_enabled = 1;
+
+	tdm_if_module_init();
+
+	priv->dev = &pdev->dev;
+	return 0;
+
+err_clk:
+	clk_disable_unprepare(priv->clk);
+
+	return err;
+}
+
+static int mvebu_phone_remove(struct platform_device *pdev)
+{
+	tdm_if_module_exit();
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int mvebu_phone_suspend(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < TDM_CTRL_REGS_NUM; i++)
+		priv->tdm_ctrl_regs[i] = readl(priv->tdm_base + i);
+
+	for (i = 0; i < TDM_SPI_REGS_NUM; i++)
+		priv->tdm_spi_regs[i] = readl(priv->tdm_base +
+					      TDM_SPI_REGS_OFFSET + i);
+
+	priv->tdm_spi_mux_reg = readl(priv->tdm_base + TDM_SPI_MUX_REG);
+	priv->tdm_mbus_config_reg = readl(priv->tdm_base + TDM_MBUS_CONFIG_REG);
+	priv->tdm_misc_reg = readl(priv->tdm_base + TDM_MISC_REG);
+
+	return 0;
+}
+
+static int mvebu_phone_resume(struct device *dev)
+{
+	struct platform_device *pdev = priv->parent;
+	int err, i;
+
+	err = mv_tdm2c_mbus_windows(dev, priv->tdm_base,
+				    mv_mbus_dram_info());
+	if (err < 0)
+		return err;
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-380-tdm")) {
+		err = mv_phone_tdm_clk_pll_config(pdev);
+		err |= mv_phone_dco_post_div_config(pdev, priv->pclk_freq_mhz);
+		if (err < 0)
+			return err;
+	}
+
+	for (i = 0; i < TDM_CTRL_REGS_NUM; i++)
+		writel(priv->tdm_ctrl_regs[i], priv->tdm_base + i);
+
+	for (i = 0; i < TDM_SPI_REGS_NUM; i++)
+		writel(priv->tdm_spi_regs[i], priv->tdm_base +
+					      TDM_SPI_REGS_OFFSET + i);
+
+	writel(priv->tdm_spi_mux_reg, priv->tdm_base + TDM_SPI_MUX_REG);
+	writel(priv->tdm_mbus_config_reg, priv->tdm_base + TDM_MBUS_CONFIG_REG);
+	writel(priv->tdm_misc_reg, priv->tdm_base + TDM_MISC_REG);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops mvebu_phone_pmops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mvebu_phone_suspend, mvebu_phone_resume)
+};
+
+#define MVEBU_PHONE_PMOPS (&mvebu_phone_pmops)
+
+#else
+#define MVEBU_PHONE_PMOPS NULL
+#endif
+
+static const struct of_device_id mvebu_phone_match[] = {
+	{ .compatible = "marvell,armada-380-tdm" },
+	{ .compatible = "marvell,armada-a8k-tdm" },
+	{ .compatible = "marvell,armada-xp-tdm" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mvebu_phone_match);
+
+static struct platform_driver mvebu_phone_driver = {
+	.probe	= mvebu_phone_probe,
+	.remove	= mvebu_phone_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.of_match_table = mvebu_phone_match,
+		.owner	= THIS_MODULE,
+		.pm	= MVEBU_PHONE_PMOPS,
+	},
+};
+
+module_platform_driver(mvebu_phone_driver);
+
+MODULE_DESCRIPTION("Marvell Telephony Driver");
+MODULE_AUTHOR("Marcin Wojtas <mw@semihalf.com>");
diff --git a/drivers/telephony/mvebu_phone/mv_phone_spi.c b/drivers/telephony/mvebu_phone/mv_phone_spi.c
new file mode 100644
index 0000000..7cb3a32
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone_spi.c
@@ -0,0 +1,199 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/spi/spi.h>
+#include "mv_phone.h"
+
+#define DRV_NAME "mvebu_phone_spi"
+
+#undef MVEBU_PHONE_SPI_DEBUG
+
+struct spi_device *slic_spi;
+
+/* Telephony register read via SPI interface. */
+void mv_phone_spi_read(u16 line_id, u8 *cmd_buff, u8 cmd_size,
+		       u8 *data_buff, u8 data_size, u32 spi_type)
+{
+	int err;
+
+#ifdef MVEBU_PHONE_SPI_DEBUG
+	pr_info("%s():line(%d) Spi ID=%d line_id=%d Spi CS=%d Spi type=%d\n",
+		__func__, __LINE__, slic_spi->master->bus_num, line_id,
+		slic_spi->chip_select, spi_type);
+#endif
+
+	err = spi_write_then_read(slic_spi, (const void *)cmd_buff, cmd_size,
+				  (void *)data_buff, data_size);
+	if (err)
+		dev_err(&slic_spi->dev, "SPI read failed\n");
+
+#ifdef MVEBU_PHONE_SPI_DEBUG
+	pr_info("CMD = 0x%x, cmd_size = 0x%x, DATA = 0x%x, data_size = 0x%x\n",
+		*cmd_buff, cmd_size, *data_buff, data_size);
+#endif
+}
+
+/* Telephony register write via SPI interface. */
+void mv_phone_spi_write(u16 line_id, u8 *cmd_buff, u8 cmd_size,
+			u8 *data_buff, u8 data_size, u32 spi_type)
+{
+	int err;
+	struct spi_message m;
+	struct spi_transfer t[2] = { { .tx_buf = (const void *)cmd_buff,
+				       .len = cmd_size, },
+				     { .tx_buf = (const void *)data_buff,
+				       .len = data_size, }, };
+
+#ifdef MVEBU_PHONE_SPI_DEBUG
+	pr_info("%s():line(%d) Spi ID=%d line_id=%d Spi CS=%d Spi type=%d\n",
+		__func__, __LINE__, slic_spi->master->bus_num, line_id,
+		slic_spi->chip_select, spi_type);
+	pr_info("CMD = 0x%x, cmd_size = 0x%x, DATA = 0x%x, data_size = 0x%x\n",
+		*cmd_buff, cmd_size, *data_buff, data_size);
+#endif
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+
+	err = spi_sync(slic_spi, &m);
+	if (err)
+		dev_err(&slic_spi->dev, "SPI write failed\n");
+}
+
+static int mvebu_phone_spi_probe(struct spi_device *spi)
+{
+	int err;
+
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi setup failed\n");
+		return err;
+	}
+
+	slic_spi = spi;
+
+	dev_info(&spi->dev, "registered slic spi device at bus #%d, CS #%d",
+		 spi->master->bus_num, spi->chip_select);
+
+	return 0;
+}
+
+static int mvebu_phone_spi_remove(struct spi_device *spi)
+{
+	return 0;
+}
+
+static const struct spi_device_id mvebu_phone_spi_ids[] = {
+	{ "mv_slic", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, mvebu_phone_spi_ids);
+
+static struct spi_driver mvebu_phone_spi_driver = {
+	.driver = {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table = mvebu_phone_spi_ids,
+	.probe	= mvebu_phone_spi_probe,
+	.remove	= mvebu_phone_spi_remove,
+};
+
+module_spi_driver(mvebu_phone_spi_driver);
+
+MODULE_DESCRIPTION("Marvell Telephony SPI Driver");
+MODULE_AUTHOR("Marcin Wojtas <mw@semihalf.com>");
diff --git a/drivers/telephony/mvebu_phone/slic/drv_dxt_if.c b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.c
new file mode 100644
index 0000000..285e9e4
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.c
@@ -0,0 +1,184 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "drv_dxt_if.h"
+
+static int drv_dxt_spi_cs;
+static int drv_dxt_irq;
+static void *drv_dxt_irq_dev;
+static irq_handler_t drv_dxt_irq_handler;
+
+void drv_dxt_if_signal_interrupt(void)
+{
+	if (drv_dxt_irq_handler == NULL)
+		return;
+
+	drv_dxt_irq_handler(drv_dxt_irq, drv_dxt_irq_dev);
+}
+
+void drv_dxt_if_enable_irq(u32 irq)
+{
+	/* We have only one TDM channel */
+	mv_phone_intr_enable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_enable_irq);
+
+void drv_dxt_if_disable_irq(u32 irq)
+{
+	/* We have only one TDM channel */
+	mv_phone_intr_disable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_disable_irq);
+
+int drv_dxt_if_request_irq(u32 irq, irq_handler_t handler, u64 flags,
+			   const char *name, void *dev)
+{
+	drv_dxt_irq = irq;
+	drv_dxt_irq_dev = dev;
+	drv_dxt_irq_handler = handler;
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_request_irq);
+
+void drv_dxt_if_free_irq(u32 irq, void *dev)
+{
+	drv_dxt_irq_handler = NULL;
+}
+EXPORT_SYMBOL(drv_dxt_if_free_irq);
+
+void drv_dxt_if_spi_cs_set(u32 dev_no, u32 hi_lo)
+{
+	if (hi_lo == 0)
+		drv_dxt_spi_cs = dev_no;
+	else
+		drv_dxt_spi_cs = -1;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_cs_set);
+
+int drv_dxt_if_spi_ll_read_write(u8 *tx_data, u32 tx_size,
+				 u8 *rx_data, u32 rx_size)
+{
+	uint16_t *ptr;
+	int i;
+
+	if ((tx_size & 1) || (rx_size & 1)) {
+		pr_err("drv_dxt_if: SPI transfer is not word aligned!\n");
+		return 0;
+	}
+
+	ptr = (uint16_t *)tx_data;
+	for (i = 0; i < tx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	if (rx_data != NULL && rx_size != 0) {
+		mv_phone_spi_read(drv_dxt_spi_cs, tx_data, tx_size,
+				  rx_data, rx_size, SPI_TYPE_SLIC_LANTIQ);
+	} else if (tx_data != NULL && tx_size > 2) {
+		mv_phone_spi_write(drv_dxt_spi_cs, tx_data, 2, tx_data + 2,
+				   tx_size - 2, SPI_TYPE_SLIC_LANTIQ);
+	} else {
+		pr_err("drv_dxt_if: Unsupported SPI access mode!\n");
+	}
+
+	ptr = (uint16_t *)rx_data;
+	for (i = 0; i < rx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_ll_read_write);
+
diff --git a/drivers/telephony/mvebu_phone/slic/drv_dxt_if.h b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.h
new file mode 100644
index 0000000..c35a593
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/drv_dxt_if.h
@@ -0,0 +1,116 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _DRV_DXT_IF_H
+#define _DRV_DXT_IF_H
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "mv_phone.h"
+
+/* Interface to drv_dxt driver */
+extern void drv_dxt_if_enable_irq(u32 irq);
+extern void drv_dxt_if_disable_irq(u32 irq);
+extern int drv_dxt_if_request_irq(u32 irq, irq_handler_t handler, u64 flags,
+				  const char *name, void *dev);
+extern void drv_dxt_if_free_irq(u32 irq, void *dev);
+extern void drv_dxt_if_spi_cs_set(u32 dev_no, u32 hi_lo);
+extern int drv_dxt_if_spi_ll_read_write(u8 *tx_data, u32 tx_size,
+					u8 *rx_data, u32 rx_size);
+extern void drv_dxt_if_signal_interrupt(void);
+
+#endif /* _DRV_DXT_IF_H */
diff --git a/drivers/telephony/mvebu_phone/slic/silabs_if.c b/drivers/telephony/mvebu_phone/slic/silabs_if.c
new file mode 100644
index 0000000..a41588b
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/silabs_if.c
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "silabs_if.h"
+
+static void (*isi_handler)(unsigned long);
+
+void silabs_if_enable_irq(u32 device)
+{
+	mv_phone_intr_enable(device);
+}
+EXPORT_SYMBOL(silabs_if_enable_irq);
+
+void silabs_if_disable_irq(u32 device)
+{
+	mv_phone_intr_disable(device);
+}
+EXPORT_SYMBOL(silabs_if_disable_irq);
+
+void silabs_if_handler_register(void *func)
+{
+	isi_handler = func;
+}
+EXPORT_SYMBOL(silabs_if_handler_register);
+
+void silabs_if_handler_unregister(void)
+{
+	isi_handler = NULL;
+}
+EXPORT_SYMBOL(silabs_if_handler_unregister);
+
+void silabs_if_isi_interrupt(void)
+{
+	if (isi_handler != NULL)
+		isi_handler(0);
+}
+EXPORT_SYMBOL(silabs_if_isi_interrupt);
+
+void silabs_if_spi_init(u32 line)
+{
+}
+EXPORT_SYMBOL(silabs_if_spi_init);
+
+void silabs_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+			u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_SILABS_ID)
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ISI);
+	else
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(silabs_if_spi_read);
+
+void silabs_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+			 u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_SILABS_ID)
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ISI);
+	else
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(silabs_if_spi_write);
diff --git a/drivers/telephony/mvebu_phone/slic/silabs_if.h b/drivers/telephony/mvebu_phone/slic/silabs_if.h
new file mode 100644
index 0000000..86d9464
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/silabs_if.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _SILABS_IF_H_
+#define _SILABS_IF_H_
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "mv_phone.h"
+
+/* Interface to Silabs SLIC driver */
+extern void silabs_if_enable_irq(u32 device);
+extern void silabs_if_disable_irq(u32 device);
+extern void silabs_if_handler_register(void *func);
+extern void silabs_if_handler_unregister(void);
+extern void silabs_if_isi_interrupt(void);
+extern void silabs_if_spi_init(u32 line);
+extern void silabs_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+			       u8 *data, u8 data_size);
+extern void silabs_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+				u8 *data, u8 data_size);
+
+#endif /* SILABS_IF_H_ */
+
diff --git a/drivers/telephony/mvebu_phone/slic/zarlink_if.c b/drivers/telephony/mvebu_phone/slic/zarlink_if.c
new file mode 100644
index 0000000..1b878ca
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/zarlink_if.c
@@ -0,0 +1,158 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "zarlink_if.h"
+
+static void (*zsi_handler)(unsigned long);
+
+void zarlink_if_enable_irq(u32 device)
+{
+	mv_phone_intr_enable(device);
+}
+EXPORT_SYMBOL(zarlink_if_enable_irq);
+
+void zarlink_if_disable_irq(u32 device)
+{
+	mv_phone_intr_disable(device);
+}
+EXPORT_SYMBOL(zarlink_if_disable_irq);
+
+void zarlink_if_handler_register(void *func)
+{
+	zsi_handler = func;
+}
+EXPORT_SYMBOL(zarlink_if_handler_register);
+
+void zarlink_if_handler_unregister(void)
+{
+	zsi_handler = NULL;
+}
+EXPORT_SYMBOL(zarlink_if_handler_unregister);
+
+void zarlink_if_zsi_interrupt(void)
+{
+	if (zsi_handler != NULL)
+		zsi_handler(0);
+}
+EXPORT_SYMBOL(zarlink_if_zsi_interrupt);
+
+void zarlink_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+			 u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_ZARLINK_ID)
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ZSI);
+	else
+		mv_phone_spi_read(line, cmd, cmd_size, data,
+				  data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(zarlink_if_spi_read);
+
+void zarlink_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+			  u8 *data, u8 data_size)
+{
+	uint32_t slic_device = mv_phone_get_slic_board_type();
+
+	if (slic_device == SLIC_ZARLINK_ID)
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ZSI);
+	else
+		mv_phone_spi_write(line, cmd, cmd_size, data,
+				   data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(zarlink_if_spi_write);
diff --git a/drivers/telephony/mvebu_phone/slic/zarlink_if.h b/drivers/telephony/mvebu_phone/slic/zarlink_if.h
new file mode 100644
index 0000000..65be365
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/slic/zarlink_if.h
@@ -0,0 +1,117 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _ZARLINK_IF_H_
+#define _ZARLINK_IF_H_
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "mv_phone.h"
+
+/* Interface to Zarlink SLIC driver */
+extern void zarlink_if_enable_irq(u32 device);
+extern void zarlink_if_disable_irq(u32 device);
+extern void zarlink_if_handler_register(void *func);
+extern void zarlink_if_handler_unregister(void);
+extern void zarlink_if_zsi_interrupt(void);
+extern void zarlink_if_spi_read(u32 line, u8 *cmd, u8 cmd_size,
+				u8 *data, u8 data_size);
+extern void zarlink_if_spi_write(u32 line, u8 *cmd, u8 cmd_size,
+				 u8 *data, u8 data_size);
+
+#endif /* _ZARLINK_IF_H_ */
+
diff --git a/drivers/telephony/mvebu_phone/tal/tal.c b/drivers/telephony/mvebu_phone/tal/tal.c
new file mode 100644
index 0000000..7904117
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal.c
@@ -0,0 +1,212 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Marvell Telephony Adaptation Layer */
+#include "tal.h"
+
+static struct tal_if *tal_if;
+static struct tal_mmp_ops *tal_mmp;
+
+enum tal_status tal_init(struct tal_params *tal_params,
+			 struct tal_mmp_ops *mmp_ops)
+{
+	if (!tal_params || !mmp_ops) {
+		pr_err("%s: Error, bad parameters.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	if (!mmp_ops->tal_mmp_rx_callback || !mmp_ops->tal_mmp_tx_callback) {
+		pr_err("%s: Error, MMP callbacks are missing.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	tal_mmp = mmp_ops;
+	if (tal_if && tal_if->init)
+		if (tal_if->init(tal_params) != 0)
+			return TAL_STAT_INIT_ERROR;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_init);
+
+void tal_exit(void)
+{
+	if (tal_if && tal_if->exit)
+		tal_if->exit();
+
+	tal_mmp = NULL;
+}
+EXPORT_SYMBOL(tal_exit);
+
+void tal_pcm_start(void)
+{
+	if (tal_if && tal_if->pcm_start)
+		tal_if->pcm_start();
+}
+EXPORT_SYMBOL(tal_pcm_start);
+
+void tal_pcm_stop(void)
+{
+	if (tal_if && tal_if->pcm_stop)
+		tal_if->pcm_stop();
+}
+EXPORT_SYMBOL(tal_pcm_stop);
+
+int tal_control(int cmd, void *data)
+{
+	if (tal_if && tal_if->control)
+		return tal_if->control(cmd, data);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(tal_control);
+
+enum tal_status tal_write(u8 *buffer, int size)
+{
+	if (tal_if && tal_if->write)
+		if (tal_if->write(buffer, size) != 0)
+			return TAL_STAT_BAD_PARAM;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_write);
+
+enum tal_status tal_stats_get(struct tal_stats *tal_stats)
+{
+	if (tal_stats && tal_if && tal_if->stats_get) {
+		tal_if->stats_get(tal_stats);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_stats_get);
+
+enum tal_status tal_set_if(struct tal_if *interface)
+{
+	if (interface && (!interface->init || !interface->exit ||
+			  !interface->pcm_start || !interface->pcm_stop)) {
+		pr_err("%s: Error, TAL callbacks are missing.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	tal_if = interface;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_set_if);
+
+enum tal_status tal_mmp_rx(u8 *buffer, int size)
+{
+	if (tal_mmp && tal_mmp->tal_mmp_rx_callback) {
+		tal_mmp->tal_mmp_rx_callback(buffer, size);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_mmp_rx);
+
+enum tal_status tal_mmp_tx(u8 *buffer, int size)
+{
+	if (tal_mmp && tal_mmp->tal_mmp_tx_callback) {
+		tal_mmp->tal_mmp_tx_callback(buffer, size);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_mmp_tx);
diff --git a/drivers/telephony/mvebu_phone/tal/tal.h b/drivers/telephony/mvebu_phone/tal/tal.h
new file mode 100644
index 0000000..475c927
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal.h
@@ -0,0 +1,168 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Marvell Telephony Adaptation Layer */
+
+#ifndef _TAL_H_
+#define _TAL_H_
+
+#include "mv_phone.h"
+
+/* Defines */
+#define TAL_MAX_PHONE_LINES	32
+
+/* Enumerators */
+enum tal_pcm_format {
+	TAL_PCM_FORMAT_1BYTE = 1,
+	TAL_PCM_FORMAT_2BYTES = 2,
+	TAL_PCM_FORMAT_4BYTES = 4,
+};
+
+enum tal_status {
+	TAL_STAT_OK = 0,
+	TAL_STAT_BAD_PARAM,
+	TAL_STAT_INIT_ERROR,
+};
+
+/* Structures */
+struct tal_params {
+	enum tal_pcm_format pcm_format;
+	u16 pcm_slot[TAL_MAX_PHONE_LINES];
+	u8 sampling_period;
+	u16 total_lines;
+};
+
+struct tal_stats {
+	int tdm_init;
+	u32 rx_miss;
+	u32 tx_miss;
+	u32 rx_over;
+	u32 tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	struct mv_phone_extended_stats tdm_ext_stats;
+#endif
+};
+
+struct tal_mmp_ops {
+	void (*tal_mmp_rx_callback)(u8 *rx_buff, int size);
+	void (*tal_mmp_tx_callback)(u8 *tx_buff, int size);
+};
+
+struct tal_if {
+	int (*init)(struct tal_params *tal_params);
+	void (*exit)(void);
+	void (*pcm_start)(void);
+	void (*pcm_stop)(void);
+	int (*control)(int cmd, void *data);
+	int (*write)(u8 *buffer, int size);
+	void (*stats_get)(struct tal_stats *tal_stats);
+};
+
+/* API */
+enum tal_status tal_init(struct tal_params *tal_params,
+			 struct tal_mmp_ops *mmp_ops);
+enum tal_status tal_stats_get(struct tal_stats *tal_stats);
+void tal_exit(void);
+void tal_pcm_start(void);
+void tal_pcm_stop(void);
+int tal_control(int cmd, void *data);
+
+enum tal_status tal_set_if(struct tal_if *interface);
+enum tal_status tal_mmp_rx(u8 *buffer, int size);
+enum tal_status tal_mmp_tx(u8 *buffer, int size);
+enum tal_status tal_write(u8 *buffer, int size);
+
+#endif /* _TAL_H */
diff --git a/drivers/telephony/mvebu_phone/tal/tal_dev.c b/drivers/telephony/mvebu_phone/tal/tal_dev.c
new file mode 100644
index 0000000..f7a5a08
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal_dev.c
@@ -0,0 +1,342 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "tal.h"
+#include "tal_dev.h"
+
+#define	TALDEV_NAME	"tal"
+
+static DECLARE_WAIT_QUEUE_HEAD(tal_dev_wait);
+static DEFINE_SPINLOCK(tal_dev_lock);
+static unsigned char *rx_buff_p, *tx_buff_p;
+static size_t rx_buff_size, tx_buff_size;
+
+static void tal_dev_rx_callback(unsigned char *rx_buff, int size)
+{
+	unsigned long flags;
+
+	/* Save buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	rx_buff_p = rx_buff;
+	rx_buff_size = size;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	wake_up_interruptible(&tal_dev_wait);
+}
+
+static void tal_dev_tx_callback(unsigned char *tx_buff, int size)
+{
+	unsigned long flags;
+
+	/* Save buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	tx_buff_p = tx_buff;
+	tx_buff_size = size;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	wake_up_interruptible(&tal_dev_wait);
+}
+
+static struct tal_params tal_params;
+static struct tal_mmp_ops tal_mmp_ops = {
+	.tal_mmp_rx_callback	= tal_dev_rx_callback,
+	.tal_mmp_tx_callback	= tal_dev_tx_callback,
+};
+
+static ssize_t tal_dev_read(struct file *file_p, char __user *buf,
+			    size_t size, loff_t *ppos)
+{
+	unsigned long flags;
+	unsigned char *rx_buff;
+
+	/* Check if we have got the buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	rx_buff = rx_buff_p;
+	rx_buff_p = NULL;
+	size = min(rx_buff_size, size);
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	if (!rx_buff)
+		return 0;
+
+	/* Copy data to userspace */
+	if (copy_to_user(buf, rx_buff, size))
+		return -EFAULT;
+
+	return size;
+}
+
+static ssize_t tal_dev_write(struct file *file_p, const char __user *buf,
+			     size_t size, loff_t *ppos)
+{
+	unsigned long flags;
+	unsigned char *tx_buff;
+
+	/* Check if we have got the buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	tx_buff = tx_buff_p;
+	tx_buff_p = NULL;
+	size = min(tx_buff_size, size);
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	if (!tx_buff)
+		return 0;
+
+	/* Copy data from userspace */
+	if (copy_from_user(tx_buff, buf, size))
+		size = -EFAULT;
+
+	/* Pass the buffer to TAL */
+	if (tal_write(tx_buff, size) != TAL_STAT_OK)
+		return -EIO;
+
+	return size;
+}
+
+static int tal_dev_open(struct inode *inode_p, struct file *file_p)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int tal_dev_release(struct inode *inode_p, struct file *file_p)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static unsigned int tal_dev_poll(struct file *file_p, poll_table *poll_table_p)
+{
+	unsigned long flags;
+	int mask = 0;
+
+	poll_wait(file_p, &tal_dev_wait, poll_table_p);
+
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	if (rx_buff_p)
+		mask |= POLLIN | POLLRDNORM;
+	if (tx_buff_p)
+		mask |= POLLOUT | POLLWRNORM;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	return mask;
+}
+
+static long tal_dev_ioctl(struct file *file_p, unsigned int cmd,
+							unsigned long arg)
+{
+	struct tal_dev_params tal_dev_params;
+	char buffer[16];
+	long ret = 0;
+	int i;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != TAL_DEV_IOCTL_MAGIC) {
+		pr_err("%s: invalid TAL DEV Magic Num %i %i\n",
+		       __func__, _IOC_TYPE(cmd), TAL_DEV_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if ((_IOC_DIR(cmd) & _IOC_WRITE) && !ret)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		pr_err("%s: invalid TAL DEV access type %i from cmd %i\n",
+		       __func__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case TAL_DEV_INIT:
+		if (copy_from_user(&tal_dev_params, (void *)arg, sizeof(tal_dev_params)))
+			return -EFAULT;
+
+		tal_params.pcm_format = tal_dev_params.pcm_format;
+		tal_params.sampling_period = 10; /* ms */
+		tal_params.total_lines = tal_dev_params.total_lines;
+		for (i = 0; i < TAL_MAX_PHONE_LINES; i++)
+			tal_params.pcm_slot[i] = (i + 1) * tal_dev_params.pcm_format;
+
+		if (tal_init(&tal_params, &tal_mmp_ops) != TAL_STAT_OK)
+			return -EIO;
+
+		break;
+
+	case TAL_DEV_EXIT:
+		tal_exit();
+		break;
+
+	case TAL_DEV_PCM_START:
+		rx_buff_p = NULL;
+		tx_buff_p = NULL;
+		tal_pcm_start();
+		break;
+
+	case TAL_DEV_PCM_STOP:
+		tal_pcm_stop();
+		break;
+
+	default:
+		/* Pass ioctl to the low-level interface */
+		if (_IOC_SIZE(cmd) > sizeof(buffer))
+			return -E2BIG;
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(buffer, (void *)arg, _IOC_SIZE(cmd)))
+				return -EFAULT;
+
+		ret = tal_control(cmd, buffer);
+
+		if (_IOC_DIR(cmd) & _IOC_READ)
+			if (copy_to_user((void *)arg, buffer, _IOC_SIZE(cmd)))
+				return -EFAULT;
+
+		break;
+	}
+
+	return ret;
+}
+
+static const struct file_operations tal_dev_fops = {
+	.owner		= THIS_MODULE,
+	.read		= tal_dev_read,
+	.write		= tal_dev_write,
+	.poll		= tal_dev_poll,
+	.unlocked_ioctl	= tal_dev_ioctl,
+	.open		= tal_dev_open,
+	.release	= tal_dev_release,
+};
+
+static struct miscdevice tal_dev = {
+	.minor	= TALDEV_MINOR,
+	.name	= TALDEV_NAME,
+	.fops	= &tal_dev_fops,
+};
+
+static int __init tal_dev_init(void)
+{
+	int status;
+
+	status = misc_register(&tal_dev);
+	if (status < 0) {
+		pr_err("Failed to register TAL device!\n");
+		return status;
+	}
+
+	return 0;
+}
+
+static void __exit tal_dev_exit(void)
+{
+	misc_deregister(&tal_dev);
+}
+
+/* Module stuff */
+module_init(tal_dev_init);
+module_exit(tal_dev_exit);
+MODULE_DESCRIPTION("Marvell TAL Device Interface");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@angel.net.pl>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/tal/tal_dev.h b/drivers/telephony/mvebu_phone/tal/tal_dev.h
new file mode 100644
index 0000000..4fcd45c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tal/tal_dev.h
@@ -0,0 +1,115 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _TAL_DEV_H_
+#define _TAL_DEV_H_
+
+#define TAL_DEV_IOCTL_MAGIC		't'
+
+#define TAL_DEV_INIT			_IOWR(TAL_DEV_IOCTL_MAGIC, 1, struct tal_dev_params)
+#define TAL_DEV_EXIT			_IO(TAL_DEV_IOCTL_MAGIC, 2)
+#define TAL_DEV_PCM_START		_IO(TAL_DEV_IOCTL_MAGIC, 3)
+#define TAL_DEV_PCM_STOP		_IO(TAL_DEV_IOCTL_MAGIC, 4)
+
+struct tal_dev_params {
+	unsigned char pcm_format;
+	unsigned short total_lines;
+};
+
+#define	TDM_DEV_TDM_TEST_MODE_ENABLE	_IO(TAL_DEV_IOCTL_MAGIC, 8)
+#define	TDM_DEV_TDM_TEST_MODE_DISABLE	_IO(TAL_DEV_IOCTL_MAGIC, 9)
+
+#endif /*_TAL_DEV_H_*/
diff --git a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
new file mode 100644
index 0000000..da9cdc2
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
@@ -0,0 +1,992 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "mv_phone.h"
+
+/* Defines */
+#define INT_SAMPLE			2
+#define BUFF_IS_FULL			1
+#define BUFF_IS_EMPTY			0
+#define FIRST_INT			1
+#define TOTAL_BUFFERS			2
+#define MV_TDM_NEXT_BUFFER(buf)		((buf + 1) % TOTAL_BUFFERS)
+#define MV_TDM_PREV_BUFFER(buf, step)	((TOTAL_BUFFERS + buf - step) % TOTAL_BUFFERS)
+#define MV_TDM_CS			0
+#define BUFF_INVALID			-1
+
+/* TDM channel info structure */
+struct tdm2c_ch_info {
+	u8 ch;
+	u8 *rxBuffVirt[TOTAL_BUFFERS], *txBuffVirt[TOTAL_BUFFERS];
+	dma_addr_t rxBuffPhys[TOTAL_BUFFERS], txBuffPhys[TOTAL_BUFFERS];
+	u8 rxBuffFull[TOTAL_BUFFERS], txBuffFull[TOTAL_BUFFERS];
+	u8 rxCurrBuff, txCurrBuff;
+	u8 rxFirst;
+};
+
+/* Globals */
+static u8 *rx_aggr_buff_virt, *tx_aggr_buff_virt;
+static u8 rx_int, tx_int;
+static u16 rx_full, tx_empty;
+static u8 tdm_enable;
+static u8 spi_mode;
+static u8 factor;
+static enum mv_phone_pcm_format pcm_format;
+static enum mv_phone_band_mode tdm_band_mode;
+static struct tdm2c_ch_info *tdm_ch_info[MV_TDM2C_TOTAL_CHANNELS] = { NULL, NULL };
+static u8 chan_stop_count;
+static u8 int_lock;
+static struct device *pdev;
+static void __iomem *regs;
+
+/* Stats */
+static u32 int_rx_count;
+static u32 int_tx_count;
+static u32 int_rx0_count;
+static u32 int_tx0_count;
+static u32 int_rx1_count;
+static u32 int_tx1_count;
+static u32 int_rx0_miss;
+static u32 int_tx0_miss;
+static u32 int_rx1_miss;
+static u32 int_tx1_miss;
+static u32 pcm_restart_count;
+
+static void tdm2c_daisy_chain_mode_set(void)
+{
+	while ((readl(regs + SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+	writel((0x80 << 8) | 0, regs + SPI_CODEC_CMD_LO_REG);
+	writel(TRANSFER_BYTES(2) | ENDIANNESS_MSB_MODE | WR_MODE | CLK_SPEED_LO_DIV, regs + SPI_CODEC_CTRL_REG);
+	writel(readl(regs + SPI_CTRL_REG) | SPI_ACTIVE, regs + SPI_CTRL_REG);
+	/* Poll for ready indication */
+	while ((readl(regs + SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+
+	dev_dbg(pdev, "%s: Exit\n", __func__);
+}
+
+static int tdm2c_ch_init(u8 ch)
+{
+	struct tdm2c_ch_info *ch_info;
+	u32 buff;
+
+	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+
+	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
+		dev_err(pdev, "%s: error, channel(%d) exceeds maximum(%d)\n",
+			__func__, ch, MV_TDM2C_TOTAL_CHANNELS);
+		return -EINVAL;
+	}
+
+	tdm_ch_info[ch] = ch_info = kmalloc(sizeof(struct tdm2c_ch_info),
+					    GFP_ATOMIC);
+	if (!ch_info) {
+		dev_err(pdev, "%s: error malloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	ch_info->ch = ch;
+
+	/* Per channel TDM init */
+	/* Disable channel (enable in pcm start) */
+	writel(CH_DISABLE, regs + CH_ENABLE_REG(ch));
+	/* Set total samples and int sample */
+	writel(CONFIG_CH_SAMPLE(tdm_band_mode, factor), regs + CH_SAMPLE_REG(ch));
+
+	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+		/* Buffers must be 32B aligned */
+		ch_info->rxBuffVirt[buff] = dma_alloc_coherent(pdev,
+							      MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
+							      &(ch_info->rxBuffPhys[buff]), GFP_KERNEL);
+		ch_info->rxBuffFull[buff] = BUFF_IS_EMPTY;
+
+		ch_info->txBuffVirt[buff] = dma_alloc_coherent(pdev,
+							      MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
+							      &(ch_info->txBuffPhys[buff]), GFP_KERNEL);
+		ch_info->txBuffFull[buff] = BUFF_IS_FULL;
+
+		memset(ch_info->txBuffVirt[buff], 0, MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+
+		if (((ulong) ch_info->rxBuffVirt[buff] | ch_info->rxBuffPhys[buff] |
+		     (ulong) ch_info->txBuffVirt[buff] | ch_info->txBuffPhys[buff]) & 0x1f) {
+			dev_err(pdev, "%s: error, unaligned buffer allocation\n", __func__);
+		}
+	}
+
+	return 0;
+}
+
+static inline int tdm2c_ch_tx_low(u8 ch)
+{
+	u32 max_poll = 0;
+	struct tdm2c_ch_info *ch_info = tdm_ch_info[ch];
+
+	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+
+	/* Count tx interrupts */
+	tx_int++;
+
+	if (ch_info->txBuffFull[ch_info->txCurrBuff] == BUFF_IS_FULL)
+		dev_dbg(pdev, "curr buff full for hw [MMP ok]\n");
+	else
+		dev_warn(pdev, "curr buf is empty [MMP miss write]\n");
+
+	/* Change buffers */
+	ch_info->txCurrBuff = MV_TDM_NEXT_BUFFER(ch_info->txCurrBuff);
+
+	/*
+	 * Mark next buff to be transmitted by HW as empty. Give it to the HW
+	 * for next frame. The app need to write the data before HW takes it.
+	 */
+	ch_info->txBuffFull[ch_info->txCurrBuff] = BUFF_IS_EMPTY;
+	dev_dbg(pdev, "->%s clear buf(%d) for channel(%d)\n", __func__, ch_info->txCurrBuff, ch);
+
+	/* Poll on SW ownership (single check) */
+	dev_dbg(pdev, "start poll for SW ownership\n");
+	while (((readb(regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
+	       && (max_poll < 2000)) {
+		udelay(1);
+		max_poll++;
+	}
+	if (max_poll == 2000) {
+		dev_err(pdev, "poll timeout (~2ms)\n");
+		return -ETIME;
+	}
+
+	dev_dbg(pdev, "ch%d, start tx buff %d\n", ch, ch_info->txCurrBuff);
+
+	/* Set TX buff address (must be 32 byte aligned) */
+	writel(ch_info->txBuffPhys[ch_info->txCurrBuff], regs + CH_TX_ADDR_REG(ch_info->ch));
+
+	/* Set HW ownership */
+	writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS);
+
+	/* Enable Tx */
+	writeb(CH_ENABLE, regs + CH_ENABLE_REG(ch_info->ch) + TX_ENABLE_BYTE_OFFS);
+
+	/* Did we get the required amount of irqs for Tx wakeup ? */
+	if (tx_int < MV_TDM_INT_COUNTER)
+		return -EBUSY;
+
+	tx_int = 0;
+	tx_empty = ch_info->txCurrBuff;
+
+	return 0;
+}
+
+static inline int tdm2c_ch_rx_low(u8 ch)
+{
+	u32 max_poll = 0;
+	struct tdm2c_ch_info *ch_info = tdm_ch_info[ch];
+
+	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+
+	if (ch_info->rxFirst)
+		ch_info->rxFirst = !FIRST_INT;
+	else
+		rx_int++;
+
+	if (ch_info->rxBuffFull[ch_info->rxCurrBuff] == BUFF_IS_EMPTY)
+		dev_dbg(pdev, "curr buff empty for hw [MMP ok]\n");
+	else
+		dev_warn(pdev, "curr buf is full [MMP miss read]\n");
+
+	/*
+	 * Mark last buff that was received by HW as full. Give next buff to HW for
+	 * next frame. The app need to read the data before next irq
+	 */
+	ch_info->rxBuffFull[ch_info->rxCurrBuff] = BUFF_IS_FULL;
+
+	/* Change buffers */
+	ch_info->rxCurrBuff = MV_TDM_NEXT_BUFFER(ch_info->rxCurrBuff);
+
+	/* Poll on SW ownership (single check) */
+	dev_dbg(pdev, "start poll for ownership\n");
+	while (((readb(regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
+	       && (max_poll < 2000)) {
+		udelay(1);
+		max_poll++;
+	}
+
+	if (max_poll == 2000) {
+		dev_err(pdev, "poll timeout (~2ms)\n");
+		return -ETIME;
+	}
+
+	dev_dbg(pdev, "ch%d, start rx buff %d\n", ch, ch_info->rxCurrBuff);
+
+	/* Set RX buff address (must be 32 byte aligned) */
+	writel(ch_info->rxBuffPhys[ch_info->rxCurrBuff], regs + CH_RX_ADDR_REG(ch_info->ch));
+
+	/* Set HW ownership */
+	writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS);
+
+	/* Enable Rx */
+	writeb(CH_ENABLE, regs + CH_ENABLE_REG(ch_info->ch) + RX_ENABLE_BYTE_OFFS);
+
+	/* Did we get the required amount of irqs for Rx wakeup ? */
+	if (rx_int < MV_TDM_INT_COUNTER)
+		return -EBUSY;
+
+	rx_int = 0;
+	rx_full = MV_TDM_PREV_BUFFER(ch_info->rxCurrBuff, 2);
+	dev_dbg(pdev, "buff %d is FULL for ch0/1\n", rx_full);
+
+	return 0;
+}
+
+static int tdm2c_ch_remove(u8 ch)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 buff;
+
+	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+
+	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
+		dev_err(pdev, "%s: error, channel(%d) exceeds maximum(%d)\n",
+			__func__, ch, MV_TDM2C_TOTAL_CHANNELS);
+		return -EINVAL;
+	}
+
+	ch_info = tdm_ch_info[ch];
+
+	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+		dma_free_coherent(pdev, MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
+				  ch_info->rxBuffVirt[buff], (dma_addr_t)ch_info->rxBuffPhys[buff]);
+		dma_free_coherent(pdev, MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
+				  ch_info->txBuffVirt[buff], (dma_addr_t)ch_info->txBuffPhys[buff]);
+	}
+
+	kfree(ch_info);
+
+	return 0;
+}
+
+static void tdm2c_reset(void)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 buff, ch;
+
+	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+
+	/* Reset globals */
+	rx_int = tx_int = 0;
+	rx_full = tx_empty = BUFF_INVALID;
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm_ch_info[ch];
+		ch_info->rxFirst = FIRST_INT;
+		ch_info->txCurrBuff = ch_info->rxCurrBuff = 0;
+		for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+			ch_info->rxBuffFull[buff] = BUFF_IS_EMPTY;
+			ch_info->txBuffFull[buff] = BUFF_IS_FULL;
+
+		}
+	}
+}
+
+void __iomem *get_tdm_base(void)
+{
+	return regs;
+}
+
+int tdm2c_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdmParams, struct mv_phone_data *halData)
+{
+	u8 ch;
+	u32 pcm_ctrl_reg, nb_delay = 0, wb_delay = 0;
+	u32 ch_delay[4] = { 0, 0, 0, 0 };
+	int ret;
+
+	regs = base;
+	dev_info(dev, "TDM dual channel device rev 0x%x\n",
+		 readl(regs + TDM_REV_REG));
+
+	/* Init globals */
+	rx_int = tx_int = 0;
+	rx_full = tx_empty = BUFF_INVALID;
+	tdm_enable = 0, int_lock = 0;
+	spi_mode = halData->spi_mode;
+	pcm_format = tdmParams->pcm_format;
+	int_rx_count = 0, int_tx_count = 0;
+	int_rx0_count = 0, int_tx0_count = 0;
+	int_rx1_count = 0, int_tx1_count = 0;
+	int_rx0_miss = 0, int_tx0_miss = 0;
+	int_rx1_miss = 0, int_tx1_miss = 0;
+	pcm_restart_count = 0;
+	pdev = dev;
+
+	if (tdmParams->sampling_period > MV_TDM_MAX_SAMPLING_PERIOD)
+		/* Use base sample period(10ms) */
+		factor = 1;
+	else
+		factor = (tdmParams->sampling_period / MV_TDM_BASE_SAMPLING_PERIOD);
+
+	/* Extract pcm format & band mode */
+	if (pcm_format == MV_PCM_FORMAT_4BYTES) {
+		pcm_format = MV_PCM_FORMAT_2BYTES;
+		tdm_band_mode = MV_WIDE_BAND;
+	} else {
+		tdm_band_mode = MV_NARROW_BAND;
+	}
+
+	/* Allocate aggregated buffers for data transport */
+	dev_dbg(pdev, "allocate %d bytes for aggregated buffer\n",
+		MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	rx_aggr_buff_virt = alloc_pages_exact(MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor), GFP_KERNEL);
+	tx_aggr_buff_virt = alloc_pages_exact(MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor), GFP_KERNEL);
+	if (!rx_aggr_buff_virt || !tx_aggr_buff_virt) {
+		dev_err(pdev, "%s: Error malloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* Clear buffers */
+	memset(rx_aggr_buff_virt, 0, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	memset(tx_aggr_buff_virt, 0, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+
+	/* Calculate CH(0/1) Delay Control for narrow/wideband modes */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		nb_delay = ((tdmParams->pcm_slot[ch] * PCM_SLOT_PCLK) + 1);
+		/* Offset required by ZARLINK VE880 SLIC */
+		wb_delay = (nb_delay + ((halData->frame_ts / 2) * PCM_SLOT_PCLK));
+		ch_delay[ch] = ((nb_delay << CH_RX_DELAY_OFFS) | (nb_delay << CH_TX_DELAY_OFFS));
+		ch_delay[(ch + 2)] = ((wb_delay << CH_RX_DELAY_OFFS) | (wb_delay << CH_TX_DELAY_OFFS));
+	}
+
+	/* Enable TDM/SPI interface */
+	mv_phone_reset_bit(regs + TDM_SPI_MUX_REG, 0x00000001);
+	/* Interrupt cause is not clear on read */
+	writel(CLEAR_ON_ZERO, regs + INT_RESET_SELECT_REG);
+	/* All interrupt bits latched in status */
+	writel(0x3ffff, regs + INT_EVENT_MASK_REG);
+	/* Disable interrupts */
+	writel(0, regs + INT_STATUS_MASK_REG);
+	/* Clear int status register */
+	writel(0, regs + INT_STATUS_REG);
+
+	/* Bypass clock divider - PCM PCLK freq */
+	writel(PCM_DIV_PASS, regs + PCM_CLK_RATE_DIV_REG);
+
+	/* Padding on Rx completion */
+	writel(0, regs + DUMMY_RX_WRITE_DATA_REG);
+	writeb(readl(regs + SPI_GLOBAL_CTRL_REG) | SPI_GLOBAL_ENABLE, regs + SPI_GLOBAL_CTRL_REG);
+	/* SPI SCLK freq */
+	writel(SPI_CLK_2MHZ, regs + SPI_CLK_PRESCALAR_REG);
+	/* Number of timeslots (PCLK) */
+	writel((u32)halData->frame_ts, regs + FRAME_TIMESLOT_REG);
+
+	if (tdm_band_mode == MV_NARROW_BAND) {
+		pcm_ctrl_reg = (CONFIG_PCM_CRTL | (((u8)pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
+
+		if (use_pclk_external)
+			pcm_ctrl_reg |= MASTER_PCLK_EXTERNAL;
+
+		/* PCM configuration */
+		writel(pcm_ctrl_reg, regs + PCM_CTRL_REG);
+		/* CH0 delay control register */
+		writel(ch_delay[0], regs + CH_DELAY_CTRL_REG(0));
+		/* CH1 delay control register */
+		writel(ch_delay[1], regs + CH_DELAY_CTRL_REG(1));
+	} else {		/* MV_WIDE_BAND */
+
+		pcm_ctrl_reg = (CONFIG_WB_PCM_CRTL | (((u8)pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
+
+		if (use_pclk_external)
+			pcm_ctrl_reg |= MASTER_PCLK_EXTERNAL;
+
+		/* PCM configuration - WB support */
+		writel(pcm_ctrl_reg, regs + PCM_CTRL_REG);
+		/* CH0 delay control register */
+		writel(ch_delay[0], regs + CH_DELAY_CTRL_REG(0));
+		/* CH1 delay control register */
+		writel(ch_delay[1], regs + CH_DELAY_CTRL_REG(1));
+		/* CH0 WB delay control register */
+		writel(ch_delay[2], regs + CH_WB_DELAY_CTRL_REG(0));
+		/* CH1 WB delay control register */
+		writel(ch_delay[3], regs + CH_WB_DELAY_CTRL_REG(1));
+	}
+
+	/* Issue reset to codec(s) */
+	dev_dbg(pdev, "resetting voice unit(s)\n");
+	writel(0, regs + MISC_CTRL_REG);
+	mdelay(1);
+	writel(1, regs + MISC_CTRL_REG);
+
+	if (spi_mode) {
+		/* Configure TDM to work in daisy chain mode */
+		tdm2c_daisy_chain_mode_set();
+	}
+
+	/* Initialize all HW units */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ret = tdm2c_ch_init(ch);
+		if (ret) {
+			dev_err(pdev, "tdm2c_ch_init(%d) failed !\n", ch);
+			return ret;
+		}
+	}
+
+	/* Enable SLIC/DAA interrupt detection(before pcm is active) */
+	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC), regs + INT_STATUS_MASK_REG);
+
+	return 0;
+}
+
+void tdm2c_release(void)
+{
+	u8 ch;
+
+	/* Free Rx/Tx aggregated buffers */
+	free_pages_exact(rx_aggr_buff_virt, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	free_pages_exact(tx_aggr_buff_virt, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+
+	/* Release HW channel resources */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++)
+		tdm2c_ch_remove(ch);
+
+	/* Disable TDM/SPI interface */
+	mv_phone_set_bit(regs + TDM_SPI_MUX_REG, 0x00000001);
+}
+
+void tdm2c_pcm_start(void)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 ch;
+
+	/* TDM is enabled */
+	tdm_enable = 1;
+	int_lock = 0;
+	chan_stop_count = 0;
+	tdm2c_reset();
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm_ch_info[ch];
+
+		/* Set Tx buff */
+		writel(ch_info->txBuffPhys[ch_info->txCurrBuff], regs + CH_TX_ADDR_REG(ch));
+		writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS);
+
+		/* Set Rx buff */
+		writel(ch_info->rxBuffPhys[ch_info->rxCurrBuff], regs + CH_RX_ADDR_REG(ch));
+		writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS);
+
+	}
+
+	/* Enable Tx */
+	writeb(CH_ENABLE, regs + CH_ENABLE_REG(0) + TX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, regs + CH_ENABLE_REG(1) + TX_ENABLE_BYTE_OFFS);
+
+	/* Enable Rx */
+	writeb(CH_ENABLE, regs + CH_ENABLE_REG(0) + RX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, regs + CH_ENABLE_REG(1) + RX_ENABLE_BYTE_OFFS);
+
+	/* Enable Tx interrupts */
+	writel(readl(regs + INT_STATUS_REG) & (~(TDM_INT_TX(0) | TDM_INT_TX(1))), regs + INT_STATUS_REG);
+	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_TX(0) | TDM_INT_TX(1)), regs + INT_STATUS_MASK_REG);
+
+	/* Enable Rx interrupts */
+	writel((readl(regs + INT_STATUS_REG) & (~(TDM_INT_RX(0) | TDM_INT_RX(1)))), regs + INT_STATUS_REG);
+	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_RX(0) | TDM_INT_RX(1)), regs + INT_STATUS_MASK_REG);
+}
+
+void tdm2c_pcm_stop(void)
+{
+	tdm_enable = 0;
+
+	tdm2c_reset();
+}
+
+int tdm2c_tx(u8 *tdm_tx_buff)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 ch;
+	u8 *tx_buff;
+
+	/* Sanity check */
+	if (tdm_tx_buff != tx_aggr_buff_virt) {
+		dev_err(pdev, "%s: Error, invalid Tx buffer !!!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!tdm_enable) {
+		dev_err(pdev, "%s: Error, no active Tx channels are available\n", __func__);
+		return -EINVAL;
+	}
+
+	if (tx_empty == BUFF_INVALID) {
+		dev_err(pdev, "%s: Tx not ready\n", __func__);
+		return -EINVAL;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm_ch_info[ch];
+		dev_dbg(pdev, "ch%d: fill buf %d with %d bytes\n",
+			ch, tx_empty,
+			MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+		ch_info->txBuffFull[tx_empty] = BUFF_IS_FULL;
+		tx_buff = tdm_tx_buff + (ch * MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+
+		/* Copy data from voice engine buffer to DMA */
+		memcpy(ch_info->txBuffVirt[tx_empty], tx_buff,
+		       MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	}
+
+	tx_empty = BUFF_INVALID;
+
+	return 0;
+}
+
+int tdm2c_rx(u8 *tdm_rx_buff)
+{
+	struct tdm2c_ch_info *ch_info;
+	u8 ch;
+	u8 *rx_buff;
+
+	/* Sanity check */
+	if (tdm_rx_buff != rx_aggr_buff_virt) {
+		dev_err(pdev, "%s: invalid Rx buffer !!!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!tdm_enable) {
+		dev_err(pdev, "%s: Error, no active Rx channels are available\n", __func__);
+		return -EINVAL;
+	}
+
+	if (rx_full == BUFF_INVALID) {
+		dev_err(pdev, "%s: Rx not ready\n", __func__);
+		return -EINVAL;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		ch_info = tdm_ch_info[ch];
+		ch_info->rxBuffFull[rx_full] = BUFF_IS_EMPTY;
+		dev_dbg(pdev, "%s get Rx buffer(%d) for channel(%d)\n",
+			__func__, rx_full, ch);
+		rx_buff = tdm_rx_buff + (ch * MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+
+		/* Copy data from DMA to voice engine buffer */
+		memcpy(rx_buff, ch_info->rxBuffVirt[rx_full],
+		       MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	}
+
+	rx_full = BUFF_INVALID;
+
+	return 0;
+}
+
+int tdm2c_pcm_stop_int_miss(void)
+{
+	u32 status_reg, mask_reg, status_stop_int, status_mask = 0, int_mask = 0;
+
+	status_reg = readl(regs + INT_STATUS_REG);
+	mask_reg = readl(regs + INT_STATUS_MASK_REG);
+
+	/* Refer only to unmasked bits */
+	status_stop_int = status_reg & mask_reg;
+
+	if (status_stop_int & TX_UNDERFLOW_BIT(1)) {
+		status_mask |= TX_UNDERFLOW_BIT(1);
+		int_mask |= TDM_INT_TX(1);
+	}
+
+	if (status_stop_int & TX_UNDERFLOW_BIT(0)) {
+		status_mask |= TX_UNDERFLOW_BIT(0);
+		int_mask |= TDM_INT_TX(0);
+	}
+
+	if (status_stop_int & RX_OVERFLOW_BIT(1)) {
+		status_mask |= RX_OVERFLOW_BIT(1);
+		int_mask |= TDM_INT_RX(1);
+	}
+
+	if (status_stop_int & RX_OVERFLOW_BIT(0)) {
+		status_mask |= TX_UNDERFLOW_BIT(0);
+		int_mask |= TDM_INT_RX(0);
+	}
+
+	if (int_mask != 0) {
+		dev_err(pdev, "Stop Interrupt missing found STATUS=%x, MASK=%x\n", status_reg, mask_reg);
+		writel(~(status_mask), regs + INT_STATUS_REG);
+		writel(readl(regs + INT_STATUS_MASK_REG) & (~(int_mask)),
+		       regs + INT_STATUS_MASK_REG);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Low level TDM interrupt service routine */
+int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
+{
+	u32 status_reg, mask_reg, status_and_mask;
+	int ret = 0;
+	int int_tx_miss = -1;
+	int int_rx_miss = -1;
+	u8 ch;
+
+	/* Read Status & mask registers */
+	status_reg = readl(regs + INT_STATUS_REG);
+	mask_reg = readl(regs + INT_STATUS_MASK_REG);
+	dev_dbg(pdev, "CAUSE(0x%x), MASK(0x%x)\n", status_reg, mask_reg);
+
+	/* Refer only to unmasked bits */
+	status_and_mask = status_reg & mask_reg;
+
+	/* Reset params */
+	tdm_intr_info->tdm_rx_buff = NULL;
+	tdm_intr_info->tdm_tx_buff = NULL;
+	tdm_intr_info->int_type = MV_EMPTY_INT;
+	tdm_intr_info->cs = MV_TDM_CS;
+
+	/* Handle SLIC/DAA int */
+	if (status_and_mask & SLIC_INT_BIT) {
+		dev_dbg(pdev, "Phone interrupt !!!\n");
+		tdm_intr_info->int_type |= MV_PHONE_INT;
+	}
+
+	if (status_and_mask & DMA_ABORT_BIT) {
+		dev_err(pdev, "DMA data abort. Address: 0x%08x, Info: 0x%08x\n",
+			readl(regs + DMA_ABORT_ADDR_REG),
+			readl(regs + DMA_ABORT_INFO_REG));
+		tdm_intr_info->int_type |= MV_DMA_ERROR_INT;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		/* Give next buff to TDM and set curr buff as empty */
+		if ((status_and_mask & TX_BIT(ch)) && tdm_enable && !int_lock) {
+			dev_dbg(pdev, "Tx interrupt(ch%d)\n", ch);
+
+			int_tx_count++;
+			if (ch == 0) {
+				int_tx0_count++;
+				if (int_tx0_count <= int_tx1_count) {
+					int_tx_miss = 0;
+					int_tx0_miss++;
+				}
+			} else {
+				int_tx1_count++;
+				if (int_tx1_count < int_tx0_count) {
+					int_tx_miss = 1;
+					int_tx1_miss++;
+				}
+			}
+
+			/* 0 -> Tx is done for both channels */
+			if (tdm2c_ch_tx_low(ch) == 0) {
+				dev_dbg(pdev, "Assign Tx aggregate buffer for further processing\n");
+				tdm_intr_info->tdm_tx_buff = tx_aggr_buff_virt;
+				tdm_intr_info->int_type |= MV_TX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		if ((status_and_mask & RX_BIT(ch)) && tdm_enable && !int_lock) {
+			dev_dbg(pdev, "Rx interrupt(ch%d)\n", ch);
+
+			int_rx_count++;
+			if (ch == 0) {
+				int_rx0_count++;
+				if (int_rx0_count <= int_rx1_count) {
+					int_rx_miss = 0;
+					int_rx0_miss++;
+				}
+			} else {
+				int_rx1_count++;
+				if (int_rx1_count < int_rx0_count) {
+					int_rx_miss = 1;
+					int_rx1_miss++;
+				}
+			}
+
+			/* 0 -> Rx is done for both channels */
+			if (tdm2c_ch_rx_low(ch) == 0) {
+				dev_dbg(pdev, "Assign Rx aggregate buffer for further processing\n");
+				tdm_intr_info->tdm_rx_buff = rx_aggr_buff_virt;
+				tdm_intr_info->int_type |= MV_RX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		if (status_and_mask & TX_UNDERFLOW_BIT(ch)) {
+
+			dev_dbg(pdev, "Tx underflow(ch%d) - checking for root cause...\n",
+				    ch);
+			if (tdm_enable) {
+				dev_dbg(pdev, "Tx underflow ERROR\n");
+				tdm_intr_info->int_type |= MV_TX_ERROR_INT;
+				if (!(status_and_mask & TX_BIT(ch))) {
+					ret = -1;
+					/* 0 -> Tx is done for both channels */
+					if (tdm2c_ch_tx_low(ch) == 0) {
+						dev_dbg(pdev, "Assign Tx aggregate buffer for further processing\n");
+						tdm_intr_info->tdm_tx_buff = tx_aggr_buff_virt;
+						tdm_intr_info->int_type |= MV_TX_INT;
+					}
+				}
+			} else {
+				dev_dbg(pdev, "Expected Tx underflow(not an error)\n");
+				tdm_intr_info->int_type |= MV_CHAN_STOP_INT;
+				/* Update number of channels already stopped */
+				tdm_intr_info->data = ++chan_stop_count;
+				writel(readl(regs + INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))),
+				       regs + INT_STATUS_MASK_REG);
+			}
+		}
+
+
+		if (status_and_mask & RX_OVERFLOW_BIT(ch)) {
+			dev_dbg(pdev, "Rx overflow(ch%d) - checking for root cause...\n", ch);
+			if (tdm_enable) {
+				dev_dbg(pdev, "Rx overflow ERROR\n");
+				tdm_intr_info->int_type |= MV_RX_ERROR_INT;
+				if (!(status_and_mask & RX_BIT(ch))) {
+					ret = -1;
+					/* 0 -> Rx is done for both channels */
+					if (tdm2c_ch_rx_low(ch) == 0) {
+						dev_dbg(pdev, "Assign Rx aggregate buffer for further processing\n");
+						tdm_intr_info->tdm_rx_buff = rx_aggr_buff_virt;
+						tdm_intr_info->int_type |= MV_RX_INT;
+					}
+				}
+			} else {
+				dev_dbg(pdev, "Expected Rx overflow(not an error)\n");
+				tdm_intr_info->int_type |= MV_CHAN_STOP_INT;
+				tdm_intr_info->data = ++chan_stop_count; /* Update number of channels already stopped */
+				writel(readl(regs + INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))),
+				       regs + INT_STATUS_MASK_REG);
+			}
+		}
+	}
+
+	/* clear TDM interrupts */
+	writel(~status_reg, regs + INT_STATUS_REG);
+
+	/* Check if interrupt was missed -> restart */
+	if  (int_tx_miss != -1)  {
+		dev_err(pdev, "Missing Tx Interrupt Detected ch%d!!!\n", int_tx_miss);
+		if (int_tx_miss)
+			int_tx1_count = int_tx0_count;
+		else
+			int_tx0_count  = (int_tx1_count + 1);
+		ret = -1;
+	}
+
+	if  (int_rx_miss != -1)  {
+		dev_err(pdev, "Missing Rx Interrupt Detected ch%d!!!\n", int_rx_miss);
+		if (int_rx_miss)
+			int_rx1_count = int_rx0_count;
+		else
+			int_rx0_count  = (int_rx1_count + 1);
+		ret = -1;
+	}
+
+	if (ret == -1) {
+		int_lock = 1;
+		pcm_restart_count++;
+	}
+
+	return ret;
+}
+
+void tdm2c_intr_enable(void)
+{
+	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC),
+	       regs + INT_STATUS_MASK_REG);
+}
+
+void tdm2c_intr_disable(void)
+{
+	u32 val = ~TDM_INT_SLIC;
+
+	writel((readl(regs + INT_STATUS_MASK_REG) & val),
+	       regs + INT_STATUS_MASK_REG);
+}
+
+void tdm2c_pcm_if_reset(void)
+{
+	/* SW PCM reset assert */
+	mv_phone_reset_bit(regs + TDM_MISC_REG, 0x00000001);
+
+	mdelay(10);
+
+	/* SW PCM reset de-assert */
+	mv_phone_set_bit(regs + TDM_MISC_REG, 0x00000001);
+
+	/* Wait a bit more - might be fine tuned */
+	mdelay(50);
+
+	dev_dbg(pdev, "%s: Exit\n", __func__);
+}
+
+/* Debug routines */
+void tdm2c_reg_dump(u32 offset)
+{
+	dev_info(pdev, "0x%05x: %08x\n", offset, readl(regs + offset));
+}
+
+void tdm2c_regs_dump(void)
+{
+	u8 i;
+	struct tdm2c_ch_info *ch_info;
+
+	dev_info(pdev, "TDM Control:\n");
+	tdm2c_reg_dump(TDM_SPI_MUX_REG);
+	tdm2c_reg_dump(INT_RESET_SELECT_REG);
+	tdm2c_reg_dump(INT_STATUS_MASK_REG);
+	tdm2c_reg_dump(INT_STATUS_REG);
+	tdm2c_reg_dump(INT_EVENT_MASK_REG);
+	tdm2c_reg_dump(PCM_CTRL_REG);
+	tdm2c_reg_dump(TIMESLOT_CTRL_REG);
+	tdm2c_reg_dump(PCM_CLK_RATE_DIV_REG);
+	tdm2c_reg_dump(FRAME_TIMESLOT_REG);
+	tdm2c_reg_dump(DUMMY_RX_WRITE_DATA_REG);
+	tdm2c_reg_dump(MISC_CTRL_REG);
+	dev_info(pdev, "TDM Channel Control:\n");
+	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
+		tdm2c_reg_dump(CH_DELAY_CTRL_REG(i));
+		tdm2c_reg_dump(CH_SAMPLE_REG(i));
+		tdm2c_reg_dump(CH_DBG_REG(i));
+		tdm2c_reg_dump(CH_TX_CUR_ADDR_REG(i));
+		tdm2c_reg_dump(CH_RX_CUR_ADDR_REG(i));
+		tdm2c_reg_dump(CH_ENABLE_REG(i));
+		tdm2c_reg_dump(CH_BUFF_OWN_REG(i));
+		tdm2c_reg_dump(CH_TX_ADDR_REG(i));
+		tdm2c_reg_dump(CH_RX_ADDR_REG(i));
+	}
+	dev_info(pdev, "TDM interrupts:\n");
+	tdm2c_reg_dump(INT_EVENT_MASK_REG);
+	tdm2c_reg_dump(INT_STATUS_MASK_REG);
+	tdm2c_reg_dump(INT_STATUS_REG);
+	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
+		dev_info(pdev, "ch%d info:\n", i);
+		ch_info = tdm_ch_info[i];
+		dev_info(pdev, "RX buffs:\n");
+		dev_info(pdev, "buff0: virt=%p phys=%p\n",
+			 ch_info->rxBuffVirt[0], (u32 *) (ch_info->rxBuffPhys[0]));
+		dev_info(pdev, "buff1: virt=%p phys=%p\n",
+			 ch_info->rxBuffVirt[1], (u32 *) (ch_info->rxBuffPhys[1]));
+		dev_info(pdev, "TX buffs:\n");
+		dev_info(pdev, "buff0: virt=%p phys=%p\n",
+			 ch_info->txBuffVirt[0], (u32 *) (ch_info->txBuffPhys[0]));
+		dev_info(pdev, "buff1: virt=%p phys=%p\n",
+			 ch_info->txBuffVirt[1], (u32 *) (ch_info->txBuffPhys[1]));
+	}
+}
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+void tdm2c_ext_stats_get(struct mv_phone_extended_stats *tdmExtStats)
+{
+	tdmExtStats->int_rx_count = int_rx_count;
+	tdmExtStats->int_tx_count = int_tx_count;
+	tdmExtStats->int_rx0_count = int_rx0_count;
+	tdmExtStats->int_tx0_count = int_tx0_count;
+	tdmExtStats->int_rx1_count = int_rx1_count;
+	tdmExtStats->int_tx1_count = int_tx1_count;
+	tdmExtStats->int_rx0_miss = int_rx0_miss;
+	tdmExtStats->int_tx0_miss = int_tx0_miss;
+	tdmExtStats->int_rx1_miss = int_rx1_miss;
+	tdmExtStats->int_tx1_miss = int_tx1_miss;
+	tdmExtStats->pcm_restart_count = pcm_restart_count;
+}
+#endif
diff --git a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
new file mode 100644
index 0000000..70d7fdc
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
@@ -0,0 +1,330 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _TDM2C_H_
+#define _TDM2C_H_
+
+/************************************************/
+/*        TDM to Mbus Bridge Register Map       */
+/************************************************/
+#define TDM_SPI_MUX_REG		0x4000
+#define TDM_MBUS_CONFIG_REG	0x4010
+#define TDM_MISC_REG		0x4070
+
+/* TDM Control Register Map */
+#define PCM_CTRL_REG		0x00
+#define TIMESLOT_CTRL_REG	0x04
+#define FRAME_TIMESLOT_REG	0x38
+#define PCM_CLK_RATE_DIV_REG	0x3c
+#define INT_EVENT_MASK_REG	0x40
+#define INT_STATUS_MASK_REG	0x48
+#define INT_RESET_SELECT_REG	0x4c
+#define INT_STATUS_REG		0x50
+#define DUMMY_RX_WRITE_DATA_REG 0x54
+#define MISC_CTRL_REG		0x58
+#define TDM_REV_REG		0x74
+#define DMA_ABORT_ADDR_REG	0x80
+#define DMA_ABORT_INFO_REG	0x84
+
+#define CH_WB_DELAY_CTRL_REG(ch)(0x88 | ((ch) << 2))
+#define CH_DELAY_CTRL_REG(ch)	(0x08 | ((ch) << 2))
+#define CH_SAMPLE_REG(ch)	(0x30 | ((ch) << 2))
+#define CH_DBG_REG(ch)		(0x78 | ((ch) << 2))
+#define CH_TX_CUR_ADDR_REG(ch)	(0x60 | ((ch) << 3))
+#define CH_RX_CUR_ADDR_REG(ch)	(0x64 | ((ch) << 3))
+#define CH_ENABLE_REG(ch)	(((ch) + 1) << 4)
+#define CH_BUFF_OWN_REG(ch)	(0x04 | (((ch) + 1) << 4))
+#define CH_TX_ADDR_REG(ch)	(0x08 | (((ch) + 1) << 4))
+#define CH_RX_ADDR_REG(ch)	(0x0c | (((ch) + 1) << 4))
+
+#define PCM_DIV_PASS	(1 << 6)
+
+/* PCM_CTRL_REG bits */
+#define MASTER_PCLK_OFFS	0
+#define MASTER_PCLK_TDM		(0 << MASTER_PCLK_OFFS)
+#define MASTER_PCLK_EXTERNAL	(1 << MASTER_PCLK_OFFS)
+#define MASTER_FS_OFFS		1
+#define MASTER_FS_TDM		(0 << MASTER_FS_OFFS)
+#define DATA_POLAR_OFFS		2
+#define DATA_POLAR_NEG		(0 << DATA_POLAR_OFFS)
+#define FS_POLAR_OFFS		3
+#define FS_POLAR_NEG		(0 << FS_POLAR_OFFS)
+#define INVERT_FS_OFFS		4
+#define INVERT_FS_HI		(0 << INVERT_FS_OFFS)
+#define FS_TYPE_OFFS		5
+#define FS_TYPE_SHORT		(0 << FS_TYPE_OFFS)
+#define PCM_SAMPLE_SIZE_OFFS	6
+#define CH_DELAY_OFFS		8
+#define CH_DELAY_ENABLE		(3 << CH_DELAY_OFFS)
+#define CH_QUALITY_OFFS		10
+#define CH_QUALITY_DISABLE	(0 << CH_QUALITY_OFFS)
+#define QUALITY_POLARITY_OFFS	12
+#define QUALITY_POLARITY_NEG	(0 << QUALITY_POLARITY_OFFS)
+#define QUALITY_TYPE_OFFS	13
+#define QUALITY_TYPE_TIME_SLOT	(0 << QUALITY_TYPE_OFFS)
+#define CS_CTRL_OFFS		15
+#define CS_CTRL_DONT_CARE	(0 << CS_CTRL_OFFS)
+#define CS_CTRL			(1 << CS_CTRL_OFFS)
+#define WIDEBAND_OFFS		16
+#define WIDEBAND_OFF		(0 << WIDEBAND_OFFS)
+#define WIDEBAND_ON		(3 << WIDEBAND_OFFS)
+#define PERF_GBUS_OFFS		31
+#define PERF_GBUS_TWO_ACCESS	(1 << PERF_GBUS_OFFS)
+
+/* CH_SAMPLE_REG bits */
+#define TOTAL_CNT_OFFS		0
+#define INT_CNT_OFFS		8
+
+/* CH_BUFF_OWN_REG bits */
+#define RX_OWN_BYTE_OFFS	0
+#define TX_OWN_BYTE_OFFS	1
+#define OWNER_MASK		1
+#define OWN_BY_HW		1
+
+/* CH_ENABLE_REG bits */
+#define RX_ENABLE_BYTE_OFFS	0
+#define TX_ENABLE_BYTE_OFFS	1
+#define CH_ENABLE		1
+#define CH_DISABLE		0
+
+/* INT_STATUS_REG bits */
+#define RX_OVERFLOW_BIT(ch)	(1 << (0 + ((ch) * 2)))
+#define TX_UNDERFLOW_BIT(ch)	(1 << (1 + ((ch) * 2)))
+#define RX_BIT(ch)		(1 << (4 + ((ch) * 2)))
+#define TX_BIT(ch)		(1 << (5 + ((ch) * 2)))
+#define RX_IDLE_BIT(ch)		(1 << (8 + ((ch) * 2)))
+#define TX_IDLE_BIT(ch)		(1 << (9 + ((ch) * 2)))
+#define DMA_ABORT_BIT		(1 << 16)
+#define SLIC_INT_BIT		(1 << 17)
+
+/* TDU_INTR_SET_RESET bits */
+#define CLEAR_MODE_OFFS		0
+#define CLEAR_ON_ZERO		(0 << CLEAR_MODE_OFFS)
+
+/* CH_DELAY_CTRL_REG bits */
+#define CH_RX_DELAY_OFFS	0
+#define CH_TX_DELAY_OFFS	16
+
+/* SPI Register Map */
+#define SPI_CLK_PRESCALAR_REG	0x3100
+#define SPI_GLOBAL_CTRL_REG	0x3104
+#define SPI_CTRL_REG		0x3108
+#define SPI_CODEC_CMD_LO_REG	0x3130
+#define SPI_CODEC_CMD_HI_REG	0x3134
+#define SPI_CODEC_CTRL_REG	0x3138
+#define SPI_CODEC_READ_DATA_REG	0x313c
+
+/* SPI CLK_PRESCALAR_REG bits */
+#define SPI_CLK_2MHZ	0x2A64  /* refers to tclk = 200MHz */
+
+/* SPI_CTRL_REG bits */
+#define SPI_STAT_OFFS	10
+#define SPI_STAT_MASK	(1 << SPI_STAT_OFFS)
+#define SPI_ACTIVE	(1 << SPI_STAT_OFFS)
+
+/* SPI_GLOBAL_CTRL_REG bits */
+#define SPI_GLOBAL_ENABLE_OFFS	0
+#define SPI_GLOBAL_ENABLE	(1 << SPI_GLOBAL_ENABLE_OFFS)
+
+/* SPI_CODEC_CTRL_REG bits */
+#define TRANSFER_BYTES_OFFS	0
+#define TRANSFER_BYTES(count)	((count-1) << TRANSFER_BYTES_OFFS)
+#define ENDIANNESS_MODE_OFFS	2
+#define ENDIANNESS_MSB_MODE	(0 << ENDIANNESS_MODE_OFFS)
+#define RD_WR_MODE_OFFS		3
+#define WR_MODE			(0 << RD_WR_MODE_OFFS)
+#define RD_MODE			(1 << RD_WR_MODE_OFFS)
+#define READ_BYTES_OFFS		4
+#define READ_1_BYTE		(0 << READ_BYTES_OFFS)
+#define READ_2_BYTE		(1 << READ_BYTES_OFFS)
+#define CLK_SPEED_OFFS		5
+#define CLK_SPEED_LO_DIV	(0 << CLK_SPEED_OFFS)
+
+/* TDM Address Decoding */
+#define TDM_MBUS_MAX_WIN	4
+#define TDM_WIN_CTRL_REG(win)	(0x4030 + (win<<4))
+#define TDM_WIN_BASE_REG(win)	(0x4034 + (win<<4))
+
+/* Defines */
+#define SAMPLES_BUFF_SIZE(band_mode, factor)  \
+	 ((band_mode == MV_NARROW_BAND) ? (factor * 80) : (factor * 160))
+
+#define MV_TDM_CH_BUFF_SIZE(pcm_format, band_mode, factor)	\
+	(pcm_format == MV_PCM_FORMAT_2BYTES ?			\
+	(2 * SAMPLES_BUFF_SIZE(band_mode, factor)) :		\
+	SAMPLES_BUFF_SIZE(band_mode, factor))
+
+#define MV_TDM_AGGR_BUFF_SIZE(pcm_format, band_mode, factor)	\
+	(2 * MV_TDM_CH_BUFF_SIZE(pcm_format, band_mode, factor))
+#define MV_TDM2C_TOTAL_CHANNELS			2
+#define MV_TDM_INT_COUNTER			2
+#define MV_TDM_MAX_SAMPLING_PERIOD		30	/* ms */
+#define MV_TDM_BASE_SAMPLING_PERIOD		10	/* ms */
+#define MV_TDM_TOTAL_CH_SAMPLES			80	/* samples */
+
+/* TDM IRQ types */
+#define MV_EMPTY_INT		0
+#define MV_RX_INT		0x00000001
+#define	MV_TX_INT		0x00000002
+#define	MV_PHONE_INT		0x00000004
+#define	MV_RX_ERROR_INT		0x00000008
+#define	MV_TX_ERROR_INT		0x00000010
+#define MV_DMA_ERROR_INT	0x00000020
+#define MV_CHAN_STOP_INT	0x00000040
+#define MV_ERROR_INT		(MV_RX_ERROR_INT | MV_TX_ERROR_INT | MV_DMA_ERROR_INT)
+
+/* PCM SLOT configuration */
+#define PCM_SLOT_PCLK	8
+
+#define TDM_INT_SLIC	(DMA_ABORT_BIT | SLIC_INT_BIT)
+#define TDM_INT_TX(ch)	(TX_UNDERFLOW_BIT(ch) | TX_BIT(ch) | TX_IDLE_BIT(ch))
+#define TDM_INT_RX(ch)	(RX_OVERFLOW_BIT(ch) | RX_BIT(ch) | RX_IDLE_BIT(ch))
+
+/* TDM Registers Configuration */
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_PCM_CRTL (MASTER_PCLK_EXTERNAL | MASTER_FS_TDM |		\
+			 DATA_POLAR_NEG | FS_POLAR_NEG | INVERT_FS_HI |	\
+			 FS_TYPE_SHORT | CH_DELAY_ENABLE |		\
+			 CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG |	\
+			 QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |	\
+			 WIDEBAND_OFF | PERF_GBUS_TWO_ACCESS)
+
+#else
+#define CONFIG_PCM_CRTL (MASTER_PCLK_TDM | MASTER_FS_TDM |		\
+			 DATA_POLAR_NEG | FS_POLAR_NEG | INVERT_FS_HI |	\
+			 FS_TYPE_SHORT | CH_DELAY_ENABLE |		\
+			 CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG |	\
+			 QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |	\
+			 WIDEBAND_OFF | PERF_GBUS_TWO_ACCESS)
+#endif
+
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_WB_PCM_CRTL (MASTER_PCLK_EXTERNAL | MASTER_FS_TDM |	\
+			    DATA_POLAR_NEG | FS_POLAR_NEG |		\
+			    INVERT_FS_HI | FS_TYPE_SHORT	 |	\
+			    CH_DELAY_ENABLE | CH_QUALITY_DISABLE |	\
+			    QUALITY_POLARITY_NEG |			\
+			    QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |\
+			    WIDEBAND_ON | PERF_GBUS_TWO_ACCESS)
+#else
+#define CONFIG_WB_PCM_CRTL (MASTER_PCLK_TDM | MASTER_FS_TDM |		\
+			    DATA_POLAR_NEG | FS_POLAR_NEG |		\
+			    INVERT_FS_HI | FS_TYPE_SHORT |		\
+			    CH_DELAY_ENABLE | CH_QUALITY_DISABLE |	\
+			    QUALITY_POLARITY_NEG |			\
+			    QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE |\
+			    WIDEBAND_ON | PERF_GBUS_TWO_ACCESS)
+#endif
+
+#define CONFIG_CH_SAMPLE(bandMode, factor)	\
+	((SAMPLES_BUFF_SIZE(bandMode, factor)<<TOTAL_CNT_OFFS) |	\
+	(INT_SAMPLE<<INT_CNT_OFFS))
+
+/* APIs */
+void __iomem *get_tdm_base(void);
+
+void tdm2c_release(void);
+int tdm2c_pcm_stop_int_miss(void);
+void tdm2c_pcm_start(void);
+void tdm2c_pcm_stop(void);
+int tdm2c_tx(u8 *tdmTxBuff);
+int tdm2c_rx(u8 *tdmRxBuff);
+void tdm2c_regs_dump(void);
+void tdm2c_intr_enable(void);
+void tdm2c_intr_disable(void);
+void tdm2c_pcm_if_reset(void);
+
+#endif /* _TDM2C_H_ */
diff --git a/drivers/telephony/mvebu_phone/tdmmc/tdmmc.c b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.c
new file mode 100644
index 0000000..eebd635
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.c
@@ -0,0 +1,986 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "mv_phone.h"
+
+#undef	MV_COMM_UNIT_DEBUG
+#define	MV_COMM_UNIT_RPT_SUPPORT /* Repeat mode must be set */
+#undef	MV_COMM_UNIT_TEST_SUPPORT
+
+/* defines */
+#define TOTAL_CHAINS		2
+#define CONFIG_RBSZ		16
+#define NEXT_BUFF(buff)		((buff + 1) % TOTAL_CHAINS)
+#define PREV_BUFF(buff)		(buff == 0 ? (TOTAL_CHAINS-1) : (buff-1))
+#define MAX_POLL_USEC		100000	/* 100ms */
+#define COMM_UNIT_SW_RST	(1 << 5)
+#define OLD_INT_WA_BIT		(1 << 15)
+#define MV_TDM_PCM_CLK_8MHZ	1
+
+/* globals */
+static int tdm_enable;
+static int pcm_enable;
+static u8 sample_size;
+static u8 sampling_coeff;
+static u16 total_channels;
+static u8 prev_rx_buff, next_tx_buff;
+static u8 *rx_buff_virt[TOTAL_CHAINS], *tx_buff_virt[TOTAL_CHAINS];
+static dma_addr_t rx_buff_phys[TOTAL_CHAINS], tx_buff_phys[TOTAL_CHAINS];
+static struct tdmmc_mcdma_rx_desc *mcdma_rx_desc_ptr[TOTAL_CHAINS];
+static struct tdmmc_mcdma_tx_desc *mcdma_tx_desc_ptr[TOTAL_CHAINS];
+static dma_addr_t mcdma_rx_desc_phys[TOTAL_CHAINS], mcdma_tx_desc_phys[TOTAL_CHAINS];
+static struct tdmmc_dram_entry def_dpram_entry = { 0, 0, 0x1, 0x1, 0, 0, 0x1, 0, 0, 0, 0 };
+static u32 ctrl_family_id;
+static struct device *pdev;
+static void __iomem *regs;
+
+static enum tdmmc_ip_version tdmmc_ip_ver_get(u32 ctrl_family_id)
+{
+	switch (ctrl_family_id) {
+	case MV_65XX_DEV_ID:
+		return MV_COMMUNIT_IP_VER_ORIGIN;
+	case MV_78XX0:
+	case MV_88F66X0:
+	case MV_88F67X0:
+		return MV_COMMUNIT_IP_VER_REVISE_1;
+	default:
+		return MV_COMMUNIT_IP_VER_REVISE_1;
+	}
+}
+
+static void tdmmc_desc_chain_build(void)
+{
+	u32 chan, index, buff_size;
+
+	/* Calculate single Rx/Tx buffer size */
+	buff_size = (sample_size * MV_TDM_TOTAL_CH_SAMPLES * sampling_coeff);
+
+	/* Initialize descriptors fields */
+	for (chan = 0; chan < total_channels; chan++) {
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Associate data buffers to descriptors physBuffPtr */
+			((struct tdmmc_mcdma_rx_desc *) (mcdma_rx_desc_ptr[index] + chan))->phys_buff_ptr =
+			    (u32) (rx_buff_phys[index] + (chan * buff_size));
+			((struct tdmmc_mcdma_tx_desc *) (mcdma_tx_desc_ptr[index] + chan))->phys_buff_ptr =
+			    (u32) (tx_buff_phys[index] + (chan * buff_size));
+
+			/* Build cyclic descriptors chain for each channel */
+			((struct tdmmc_mcdma_rx_desc *) (mcdma_rx_desc_ptr[index] + chan))->phys_next_desc_ptr =
+			    (u32) (mcdma_rx_desc_phys[((index + 1) % TOTAL_CHAINS)] +
+				      (chan * sizeof(struct tdmmc_mcdma_rx_desc)));
+
+			((struct tdmmc_mcdma_tx_desc *) (mcdma_tx_desc_ptr[index] + chan))->phys_next_desc_ptr =
+			    (u32) (mcdma_tx_desc_phys[((index + 1) % TOTAL_CHAINS)] +
+				      (chan * sizeof(struct tdmmc_mcdma_tx_desc)));
+
+			/* Set Byte_Count/Buffer_Size Rx descriptor fields */
+			((struct tdmmc_mcdma_rx_desc *) (mcdma_rx_desc_ptr[index] + chan))->byte_cnt = 0;
+			((struct tdmmc_mcdma_rx_desc *) (mcdma_rx_desc_ptr[index] + chan))->buff_size = buff_size;
+
+			/* Set Shadow_Byte_Count/Byte_Count Tx descriptor fields */
+			((struct tdmmc_mcdma_tx_desc *) (mcdma_tx_desc_ptr[index] + chan))->shadow_byte_cnt = buff_size;
+			((struct tdmmc_mcdma_tx_desc *) (mcdma_tx_desc_ptr[index] + chan))->byte_cnt = buff_size;
+
+			/* Set Command/Status Rx/Tx descriptor fields */
+			((struct tdmmc_mcdma_rx_desc *) (mcdma_rx_desc_ptr[index] + chan))->cmd_status =
+			    (CONFIG_MCDMA_DESC_CMD_STATUS);
+			((struct tdmmc_mcdma_tx_desc *) (mcdma_tx_desc_ptr[index] + chan))->cmd_status =
+			    (CONFIG_MCDMA_DESC_CMD_STATUS);
+		}
+	}
+}
+
+static void tdmmc_mcdma_mcsc_start(void)
+{
+	u32 chan;
+	dma_addr_t rx_desc_phys_addr, tx_desc_phys_addr;
+
+	tdmmc_desc_chain_build();
+
+	/* Set current Rx/Tx descriptors  */
+	for (chan = 0; chan < total_channels; chan++) {
+		rx_desc_phys_addr = mcdma_rx_desc_phys[0] + (chan * sizeof(struct tdmmc_mcdma_rx_desc));
+		tx_desc_phys_addr = mcdma_tx_desc_phys[0] + (chan * sizeof(struct tdmmc_mcdma_tx_desc));
+		writel(rx_desc_phys_addr, regs + MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan));
+		writel(tx_desc_phys_addr, regs + MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan));
+	}
+
+	/* Restore MCDMA Rx/Tx control registers */
+	for (chan = 0; chan < total_channels; chan++) {
+		/* Set RMCCx */
+		writel(CONFIG_RMCCx, regs + MCDMA_RECEIVE_CONTROL_REG(chan));
+
+		/* Set TMCCx */
+		writel(CONFIG_TMCCx, regs + MCDMA_TRANSMIT_CONTROL_REG(chan));
+	}
+
+	/* Set Rx/Tx periodical interrupts */
+	if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_ORIGIN)
+		writel(CONFIG_VOICE_PERIODICAL_INT_CONTROL_WA,
+		       regs + VOICE_PERIODICAL_INT_CONTROL_REG);
+	else
+		writel(CONFIG_VOICE_PERIODICAL_INT_CONTROL,
+		       regs + VOICE_PERIODICAL_INT_CONTROL_REG);
+
+	/* MCSC Global Tx Enable */
+	if (!tdm_enable)
+		mv_phone_set_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
+
+	/* Enable MCSC-Tx & MCDMA-Rx */
+	for (chan = 0; chan < total_channels; chan++) {
+		/* Enable Tx in TMCCx */
+		if (!tdm_enable)
+			mv_phone_set_bit(regs + MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
+
+		/* Enable Rx in: MCRDPx */
+		mv_phone_set_bit(regs + MCDMA_RECEIVE_CONTROL_REG(chan), MCDMA_ERD_MASK);
+	}
+
+	/* MCSC Global Rx Enable */
+	if (!tdm_enable)
+		mv_phone_set_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+
+	/* Enable MCSC-Rx & MCDMA-Tx */
+	for (chan = 0; chan < total_channels; chan++) {
+		/* Enable Rx in RMCCx */
+		if (!tdm_enable)
+			mv_phone_set_bit(regs + MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+
+		/* Enable Tx in MCTDPx */
+		mv_phone_set_bit(regs + MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_TXD_MASK);
+	}
+
+	/* Disable Rx/Tx return to half */
+	mv_phone_reset_bit(regs + FLEX_TDM_CONFIG_REG, (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	udelay(200);
+}
+
+static void tdmmc_mcdma_mcsc_abort(void)
+{
+	u32 chan;
+
+	/* Abort MCSC/MCDMA in case we got here from tdmmc_release() */
+	if (!tdm_enable) {
+		/* Clear MCSC Rx/Tx channel enable */
+		for (chan = 0; chan < total_channels; chan++) {
+			mv_phone_reset_bit(regs + MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+			mv_phone_reset_bit(regs + MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
+		}
+
+		/* MCSC Global Rx/Tx Disable */
+		mv_phone_reset_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+		mv_phone_reset_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
+	}
+}
+
+static void tdmmc_mcdma_stop(void)
+{
+	u32 index, chan, max_poll;
+	u32 curr_rx_desc, curr_tx_desc, next_tx_buff = 0, next_rx_buff = 0;
+
+	/***************************/
+	/*    Stop MCDMA - Rx/Tx   */
+	/***************************/
+	for (chan = 0; chan < total_channels; chan++) {
+		curr_rx_desc = readl(regs + MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (curr_rx_desc == (mcdma_rx_desc_phys[index] + (chan*(sizeof(struct tdmmc_mcdma_rx_desc))))) {
+				next_rx_buff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			dev_err(pdev, "%s: ERROR, couldn't Rx descriptor match for chan(%d)\n",
+				__func__, chan);
+			break;
+		}
+
+		((struct tdmmc_mcdma_rx_desc *)
+			(mcdma_rx_desc_ptr[next_rx_buff] + chan))->phys_next_desc_ptr = 0;
+		((struct tdmmc_mcdma_rx_desc *)
+			(mcdma_rx_desc_ptr[next_rx_buff] + chan))->cmd_status = (LAST_BIT | OWNER);
+	}
+
+	for (chan = 0; chan < total_channels; chan++) {
+		curr_tx_desc = readl(regs + MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (curr_tx_desc == (mcdma_tx_desc_phys[index] + (chan*(sizeof(struct tdmmc_mcdma_tx_desc))))) {
+				next_tx_buff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			dev_err(pdev, "%s: ERROR, couldn't Tx descriptor match for chan(%d)\n",
+				__func__, chan);
+			return;
+		}
+
+		((struct tdmmc_mcdma_tx_desc *)
+			(mcdma_tx_desc_ptr[next_tx_buff] + chan))->phys_next_desc_ptr = 0;
+		((struct tdmmc_mcdma_tx_desc *)
+			(mcdma_tx_desc_ptr[next_tx_buff] + chan))->cmd_status = (LAST_BIT | OWNER);
+	}
+
+	for (chan = 0; chan < total_channels; chan++) {
+		max_poll = 0;
+		while ((max_poll < MAX_POLL_USEC) &&
+			(readl(regs + MCDMA_TRANSMIT_CONTROL_REG(chan)) & MCDMA_TXD_MASK)) {
+			udelay(1);
+			max_poll++;
+		}
+
+		if (max_poll >= MAX_POLL_USEC) {
+			dev_err(pdev, "%s: Error, MCDMA TXD polling timeout(ch%d)\n", __func__, chan);
+			return;
+		}
+
+		max_poll = 0;
+		while ((max_poll < MAX_POLL_USEC) &&
+			(readl(regs + MCDMA_RECEIVE_CONTROL_REG(chan)) & MCDMA_ERD_MASK)) {
+			udelay(1);
+			max_poll++;
+		}
+
+		if (max_poll >= MAX_POLL_USEC) {
+			dev_err(pdev, "%s: Error, MCDMA ERD polling timeout(ch%d)\n", __func__, chan);
+			return;
+		}
+	}
+
+	/* Disable Rx/Tx periodical interrupts */
+	writel(0xffffffff, regs + VOICE_PERIODICAL_INT_CONTROL_REG);
+
+	/* Enable Rx/Tx return to half */
+	mv_phone_set_bit(regs + FLEX_TDM_CONFIG_REG, (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	udelay(200);
+
+	/* Manual reset to channel-balancing mechanism */
+	mv_phone_set_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_MAI_MASK);
+	udelay(1);
+}
+
+void tdmmc_intr_enable(u8 device_id)
+{
+}
+
+void tdmmc_intr_disable(u8 device_id)
+{
+}
+
+void tdmmc_show(void)
+{
+	u32 index;
+
+	/* Dump data buffers & descriptors addresses */
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		dev_info(pdev, "Rx Buff(%d): virt = 0x%lx, phys = 0x%lx\n",
+			 index, (ulong)rx_buff_virt[index],
+			 (ulong)rx_buff_phys[index]);
+		dev_info(pdev, "Tx Buff(%d): virt = 0x%lx, phys = 0x%lx\n",
+			 index, (ulong)tx_buff_virt[index],
+			 (ulong)tx_buff_phys[index]);
+		dev_info(pdev, "Rx Desc(%d): virt = 0x%lx, phys = 0x%lx\n",
+			 index, (ulong)mcdma_rx_desc_ptr[index],
+			 (ulong) mcdma_rx_desc_phys[index]);
+		dev_info(pdev, "Tx Desc(%d): virt = 0x%lx, phys = 0x%lx\n",
+			 index, (ulong)mcdma_tx_desc_ptr[index],
+			 (ulong)mcdma_tx_desc_phys[index]);
+	}
+}
+
+int tdmmc_init(void __iomem *base, struct device *dev,
+	       struct mv_phone_params *tdm_params, struct mv_phone_data *hal_data)
+{
+	u16 pcm_slot, index;
+	u32 buff_size, chan, total_rx_desc_size, total_tx_desc_size;
+	u32 max_poll, clk_sync_ctrl_reg, count;
+	struct tdmmc_dram_entry *act_dpram_entry;
+
+	regs = base;
+	/* Initialize driver resources */
+	tdm_enable = 0;
+	pcm_enable = 0;
+	total_channels = tdm_params->total_channels;
+	prev_rx_buff = 0;
+	next_tx_buff = 0;
+	ctrl_family_id = hal_data->family_id;
+	pdev = dev;
+
+	/* Check parameters */
+	if ((tdm_params->total_channels > MV_TDMMC_TOTAL_CHANNELS) ||
+	    (tdm_params->sampling_period > MV_TDM_MAX_SAMPLING_PERIOD)) {
+		dev_err(pdev, "%s: Error, bad parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Extract sampling period coefficient */
+	sampling_coeff = (tdm_params->sampling_period / MV_TDM_BASE_SAMPLING_PERIOD);
+
+	sample_size = tdm_params->pcm_format;
+
+	/* Calculate single Rx/Tx buffer size */
+	buff_size = (sample_size * MV_TDM_TOTAL_CH_SAMPLES * sampling_coeff);
+
+	/* Allocate cached data buffers for all channels */
+	dev_dbg(pdev, "%s: allocate 0x%x for data buffers total_channels = %d\n",
+		__func__, (buff_size * total_channels), total_channels);
+
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		rx_buff_virt[index] = dma_alloc_coherent(pdev, buff_size * total_channels,
+						       &rx_buff_phys[index], GFP_KERNEL);
+		tx_buff_virt[index] = dma_alloc_coherent(pdev, buff_size * total_channels,
+						       &tx_buff_phys[index], GFP_KERNEL);
+#ifdef MV_COMM_UNIT_TEST_SUPPORT
+	/* Fill Tx buffers with incremental pattern */
+		{
+			int i, j;
+
+			for (j = 0; j < total_channels; j++) {
+				for (i = 0; i < buffSize; i++)
+					*(u8 *) (tx_buff_virt[index]+i+(j*buffSize)) = (u8)(i+1);
+			}
+		}
+#endif
+	}
+
+	/* Allocate non-cached MCDMA Rx/Tx descriptors */
+	total_rx_desc_size = total_channels * sizeof(struct tdmmc_mcdma_rx_desc);
+	total_tx_desc_size = total_channels * sizeof(struct tdmmc_mcdma_tx_desc);
+
+	dev_dbg(dev, "%s: allocate %dB for Rx/Tx descriptors\n",
+		__func__, total_tx_desc_size);
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		mcdma_rx_desc_ptr[index] = dma_alloc_coherent(pdev, total_rx_desc_size,
+							   &mcdma_rx_desc_phys[index], GFP_KERNEL);
+		mcdma_tx_desc_ptr[index] = dma_alloc_coherent(pdev, total_tx_desc_size,
+							   &mcdma_tx_desc_phys[index], GFP_KERNEL);
+
+		/* XXX Add BUG() */
+		/* Check descriptors alignment */
+		if (((ulong) mcdma_rx_desc_ptr[index] | (ulong)mcdma_tx_desc_ptr[index]) &
+		    (sizeof(struct tdmmc_mcdma_rx_desc) - 1)) {
+			dev_err(pdev, "%s: Error, unaligned MCDMA Rx/Tx descriptors\n", __func__);
+			return -ENOMEM;
+		}
+	}
+
+	/* Poll MCDMA for reset completion */
+	max_poll = 0;
+	while ((max_poll < MAX_POLL_USEC) && !(readl(regs + MCDMA_GLOBAL_CONTROL_REG) & MCDMA_RID_MASK)) {
+		udelay(1);
+		max_poll++;
+	}
+
+	if (max_poll >= MAX_POLL_USEC) {
+		dev_err(pdev, "Error, MCDMA reset completion timout\n");
+		return -ETIME;
+	}
+
+	/* Poll MCSC for RAM initialization done */
+	if (!(readl(regs + MCSC_GLOBAL_INT_CAUSE_REG) & MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK)) {
+		max_poll = 0;
+		while ((max_poll < MAX_POLL_USEC) &&
+		       !(readl(regs + MCSC_GLOBAL_INT_CAUSE_REG) & MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK)) {
+			udelay(1);
+			max_poll++;
+		}
+
+		if (max_poll >= MAX_POLL_USEC) {
+			dev_err(pdev, "Error, MCDMA RAM initialization timout\n");
+			return -ETIME;
+		}
+	}
+
+	/***************************************************************/
+	/* MCDMA Configuration(use default MCDMA linked-list settings) */
+	/***************************************************************/
+	/* Set Rx Service Queue Arbiter Weight Register */
+	writel((readl(regs + RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG) & ~(0x1f << 24)), /*| MCDMA_RSQW_MASK));*/
+	       regs + RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG);
+
+	/* Set Tx Service Queue Arbiter Weight Register */
+	writel((readl(regs + TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG) & ~(0x1f << 24)), /*| MCDMA_TSQW_MASK));*/
+	       regs + TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG);
+
+	for (chan = 0; chan < total_channels; chan++) {
+		/* Set RMCCx */
+		writel(CONFIG_RMCCx, regs + MCDMA_RECEIVE_CONTROL_REG(chan));
+
+		/* Set TMCCx */
+		writel(CONFIG_TMCCx, regs + MCDMA_TRANSMIT_CONTROL_REG(chan));
+	}
+
+	/**********************/
+	/* MCSC Configuration */
+	/**********************/
+	/* Disable Rx/Tx channel balancing & Linear mode fix */
+	mv_phone_set_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TCBD_MASK);
+
+	for (chan = 0; chan < total_channels; chan++) {
+		writel(CONFIG_MRCRx, regs + MCSC_CHx_RECEIVE_CONFIG_REG(chan));
+		writel(CONFIG_MTCRx, regs + MCSC_CHx_TRANSMIT_CONFIG_REG(chan));
+	}
+
+	/* Enable RX/TX linear byte swap, only in linear mode */
+	if (tdm_params->pcm_format == MV_PCM_FORMAT_1BYTE)
+		writel((readl(regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG) & (~CONFIG_LINEAR_BYTE_SWAP)),
+		       regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG);
+	else
+		writel((readl(regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG) | CONFIG_LINEAR_BYTE_SWAP),
+		       regs + MCSC_GLOBAL_CONFIG_EXTENDED_REG);
+
+	/***********************************************/
+	/* Shared Bus to Crossbar Bridge Configuration */
+	/***********************************************/
+	/* Set Timeout Counter Register */
+	writel((readl(regs + TIME_OUT_COUNTER_REG) | TIME_OUT_THRESHOLD_COUNT_MASK), regs + TIME_OUT_COUNTER_REG);
+
+	/*************************************************/
+	/* Time Division Multiplexing(TDM) Configuration */
+	/*************************************************/
+	act_dpram_entry = kmalloc(sizeof(struct tdmmc_dram_entry), GFP_KERNEL);
+	if (!act_dpram_entry)
+		return -EINVAL;
+
+	memcpy(act_dpram_entry, &def_dpram_entry, sizeof(struct tdmmc_dram_entry));
+	/* Set repeat mode bits for (sample_size > 1) */
+	act_dpram_entry->rpt = ((sample_size == MV_PCM_FORMAT_1BYTE) ? 0 : 1);
+
+	/* Reset all Rx/Tx DPRAM entries to default value */
+	for (index = 0; index < (2 * MV_TDM_MAX_HALF_DPRAM_ENTRIES); index++) {
+		writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_RDPR_REG(index));
+		writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_TDPR_REG(index));
+	}
+
+	/* Set active Rx/Tx DPRAM entries */
+	for (chan = 0; chan < total_channels; chan++) {
+		/* Same time slot number for both Rx & Tx */
+		pcm_slot = tdm_params->pcm_slot[chan];
+
+		/* Verify time slot is within frame boundries */
+		if (pcm_slot >= hal_data->frame_ts) {
+			dev_err(pdev, "Error, time slot(%d) exceeded maximum(%d)\n",
+				pcm_slot, hal_data->frame_ts);
+			goto err;
+		}
+
+		/* Verify time slot is aligned to sample size */
+		if ((sample_size > MV_PCM_FORMAT_1BYTE) && (pcm_slot & 1)) {
+			dev_err(pdev, "Error, time slot(%d) not aligned to Linear PCM sample size\n",
+				pcm_slot);
+			goto err;
+		}
+
+		/* Update relevant DPRAM fields */
+		act_dpram_entry->ch = chan;
+		act_dpram_entry->mask = 0xff;
+
+		/* Extract physical DPRAM entry id */
+		index = ((sample_size == MV_PCM_FORMAT_1BYTE) ? pcm_slot : (pcm_slot / 2));
+
+		/* DPRAM low half */
+		writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_RDPR_REG(index));
+		writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_TDPR_REG(index));
+
+		/* DPRAM high half(mirroring DPRAM low half) */
+		act_dpram_entry->mask = 0;
+		writel(*((u32 *) act_dpram_entry),
+		       regs + FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+		writel(*((u32 *) act_dpram_entry),
+		       regs + FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+
+		/* WideBand mode */
+		if (sample_size == MV_PCM_FORMAT_4BYTES) {
+			index = (index + (hal_data->frame_ts / sample_size));
+			/* DPRAM low half */
+			act_dpram_entry->mask = 0xff;
+			writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_RDPR_REG(index));
+			writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_TDPR_REG(index));
+
+			/* DPRAM high half(mirroring DPRAM low half) */
+			act_dpram_entry->mask = 0;
+			writel(*((u32 *) act_dpram_entry),
+			       regs + FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+			writel(*((u32 *) act_dpram_entry),
+			       regs + FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+		}
+	}
+
+	/* Fill last Tx/Rx DPRAM entry('LAST'=1) */
+	act_dpram_entry->mask = 0;
+	act_dpram_entry->ch = 0;
+	act_dpram_entry->last = 1;
+
+	/* Index for last entry */
+	if (sample_size == MV_PCM_FORMAT_1BYTE)
+		index = (hal_data->frame_ts - 1);
+	else
+		index = ((hal_data->frame_ts / 2) - 1);
+
+	/* Low half */
+	writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_TDPR_REG(index));
+	writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_RDPR_REG(index));
+	/* High half */
+	writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+	writel(*((u32 *) act_dpram_entry), regs + FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)));
+
+	/* Set TDM_CLK_AND_SYNC_CONTROL register */
+	clk_sync_ctrl_reg = readl(regs + TDM_CLK_AND_SYNC_CONTROL_REG);
+	clk_sync_ctrl_reg &= ~(TDM_TX_FSYNC_OUT_ENABLE_MASK | TDM_RX_FSYNC_OUT_ENABLE_MASK |
+			TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK);
+	clk_sync_ctrl_reg |= CONFIG_TDM_CLK_AND_SYNC_CONTROL;
+	writel(clk_sync_ctrl_reg, regs + TDM_CLK_AND_SYNC_CONTROL_REG);
+
+	/* Set TDM TCR register */
+	writel((readl(regs + FLEX_TDM_CONFIG_REG) | CONFIG_FLEX_TDM_CONFIG), regs + FLEX_TDM_CONFIG_REG);
+
+	/**********************************************************************/
+	/* Time Division Multiplexing(TDM) Interrupt Controller Configuration */
+	/**********************************************************************/
+	/* Clear TDM cause and mask registers */
+	writel(0, regs + COMM_UNIT_TOP_MASK_REG);
+	writel(0, regs + TDM_MASK_REG);
+	writel(0, regs + COMM_UNIT_TOP_CAUSE_REG);
+	writel(0, regs + TDM_CAUSE_REG);
+
+	/* Clear MCSC cause and mask registers(except InitDone bit) */
+	writel(0, regs + MCSC_GLOBAL_INT_MASK_REG);
+	writel(0, regs + MCSC_EXTENDED_INT_MASK_REG);
+	writel(MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK, regs + MCSC_GLOBAL_INT_CAUSE_REG);
+	writel(0, regs + MCSC_EXTENDED_INT_CAUSE_REG);
+
+	/* Set output sync counter bits for FS */
+#if defined(MV_TDM_PCM_CLK_8MHZ)
+	count = MV_FRAME_128TS * 8;
+#elif defined(MV_TDM_PCM_CLK_4MHZ)
+	count = MV_FRAME_64TS * 8;
+#else /* MV_TDM_PCM_CLK_2MHZ */
+	count = MV_FRAME_32TS * 8;
+#endif
+	writel(((count << TDM_SYNC_BIT_RX_OFFS) & TDM_SYNC_BIT_RX_MASK) | (count & TDM_SYNC_BIT_TX_MASK),
+	       regs + TDM_OUTPUT_SYNC_BIT_COUNT_REG);
+
+#ifdef MV_COMM_UNIT_DEBUG
+	tdmmc_show();
+#endif
+
+	/* Enable PCM */
+	tdmmc_pcm_start();
+
+	/* Mark TDM I/F as enabled */
+	tdm_enable = 1;
+
+	/* Enable PCLK */
+	writel((readl(regs + TDM_DATA_DELAY_AND_CLK_CTRL_REG) | CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL),
+	       regs + TDM_DATA_DELAY_AND_CLK_CTRL_REG);
+
+	/* Keep the software workaround to enable TEN while set Fsync for none-ALP chips */
+	/* Enable TDM */
+	if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_ORIGIN)
+		mv_phone_set_bit(regs + FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+
+	dev_dbg(pdev, "%s: Exit\n", __func__);
+
+	kfree(act_dpram_entry);
+	return 0;
+err:
+	kfree(act_dpram_entry);
+	return -EINVAL;
+}
+
+void tdmmc_release(void)
+{
+	u32 buff_size, total_rx_desc_size, total_tx_desc_size, index;
+
+	if (tdm_enable) {
+
+		/* Mark TDM I/F as disabled */
+		tdm_enable = 0;
+
+		tdmmc_pcm_stop();
+
+		tdmmc_mcdma_mcsc_abort();
+
+		udelay(10);
+		mv_phone_reset_bit(regs + MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_MAI_MASK);
+
+		/* Disable TDM */
+		if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_ORIGIN)
+			mv_phone_reset_bit(regs + FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+
+		/* Disable PCLK */
+		mv_phone_reset_bit(regs + TDM_DATA_DELAY_AND_CLK_CTRL_REG,
+				   (TX_CLK_OUT_ENABLE_MASK |
+				    RX_CLK_OUT_ENABLE_MASK));
+
+		/* Calculate total Rx/Tx buffer size */
+		buff_size = (sample_size * MV_TDM_TOTAL_CH_SAMPLES * sampling_coeff * total_channels);
+
+		/* Calculate total MCDMA Rx/Tx descriptors chain size */
+		total_rx_desc_size = total_channels * sizeof(struct tdmmc_mcdma_rx_desc);
+		total_tx_desc_size = total_channels * sizeof(struct tdmmc_mcdma_tx_desc);
+
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Release Rx/Tx data buffers */
+			dma_free_coherent(pdev, buff_size, rx_buff_virt[index],
+					  rx_buff_phys[index]);
+			dma_free_coherent(pdev, buff_size, tx_buff_virt[index],
+					  tx_buff_phys[index]);
+
+			/* Release MCDMA Rx/Tx descriptors */
+			dma_free_coherent(pdev, total_rx_desc_size,
+					  mcdma_rx_desc_ptr[index], mcdma_rx_desc_phys[index]);
+			dma_free_coherent(pdev, total_tx_desc_size,
+					  mcdma_tx_desc_ptr[index], mcdma_tx_desc_phys[index]);
+		}
+	}
+}
+
+void tdmmc_pcm_start(void)
+{
+	u32 mask_reg;
+
+	if (!pcm_enable) {
+
+		/* Mark PCM I/F as enabled  */
+		pcm_enable = 1;
+
+		tdmmc_mcdma_mcsc_start();
+
+		/* Clear TDM cause and mask registers */
+		writel(0, regs + COMM_UNIT_TOP_MASK_REG);
+		writel(0, regs + TDM_MASK_REG);
+		writel(0, regs + COMM_UNIT_TOP_CAUSE_REG);
+		writel(0, regs + TDM_CAUSE_REG);
+
+		/* Clear MCSC cause and mask registers(except InitDone bit) */
+		writel(0, regs + MCSC_GLOBAL_INT_MASK_REG);
+		writel(0, regs + MCSC_EXTENDED_INT_MASK_REG);
+		writel(MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK, regs + MCSC_GLOBAL_INT_CAUSE_REG);
+		writel(0, regs + MCSC_EXTENDED_INT_CAUSE_REG);
+
+		/* Enable unit interrupts */
+		mask_reg = readl(regs + TDM_MASK_REG);
+		writel(mask_reg | CONFIG_TDM_CAUSE, regs + TDM_MASK_REG);
+		writel(CONFIG_COMM_UNIT_TOP_MASK, regs + COMM_UNIT_TOP_MASK_REG);
+
+		/* Enable TDM */
+		if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_REVISE_1)
+			mv_phone_set_bit(regs + FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+	}
+}
+
+void tdmmc_pcm_stop(void)
+{
+	u32 buff_size, index;
+
+	if (pcm_enable) {
+		/* Mark PCM I/F as disabled  */
+		pcm_enable = 0;
+
+		/* Clear TDM cause and mask registers */
+		writel(0, regs + COMM_UNIT_TOP_MASK_REG);
+		writel(0, regs + TDM_MASK_REG);
+		writel(0, regs + COMM_UNIT_TOP_CAUSE_REG);
+		writel(0, regs + TDM_CAUSE_REG);
+
+		/* Clear MCSC cause and mask registers(except InitDone bit) */
+		writel(0, regs + MCSC_GLOBAL_INT_MASK_REG);
+		writel(0, regs + MCSC_EXTENDED_INT_MASK_REG);
+		writel(MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK, regs + MCSC_GLOBAL_INT_CAUSE_REG);
+		writel(0, regs + MCSC_EXTENDED_INT_CAUSE_REG);
+
+		tdmmc_mcdma_stop();
+
+		/* Calculate total Rx/Tx buffer size */
+		buff_size = (sample_size * MV_TDM_TOTAL_CH_SAMPLES * sampling_coeff * total_channels);
+
+		/* Clear Rx buffers */
+		for (index = 0; index < TOTAL_CHAINS; index++)
+			memset(rx_buff_virt[index], 0, buff_size);
+
+		/* Disable TDM */
+		if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_REVISE_1)
+			mv_phone_reset_bit(regs + FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+	}
+}
+
+int tdmmc_tx(u8 *tdm_tx_buff)
+{
+	u32 buff_size, index;
+	u8 tmp;
+
+	/* Calculate total Tx buffer size */
+	buff_size = (sample_size * MV_TDM_TOTAL_CH_SAMPLES * sampling_coeff * total_channels);
+
+	if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_ORIGIN) {
+		if (sample_size > MV_PCM_FORMAT_1BYTE) {
+			dev_dbg(pdev, "Linear mode (Tx): swapping bytes\n");
+			for (index = 0; index < buff_size; index += 2) {
+				tmp = tdm_tx_buff[index];
+				tdm_tx_buff[index] = tdm_tx_buff[index+1];
+				tdm_tx_buff[index+1] = tmp;
+			}
+			dev_dbg(pdev, "Linear mode (Tx): swapping bytes...done.\n");
+		}
+	}
+
+	return 0;
+}
+
+int tdmmc_rx(u8 *tdm_rx_buff)
+{
+	u32 buff_size, index;
+	u8 tmp;
+
+	/* Calculate total Rx buffer size */
+	buff_size = (sample_size * MV_TDM_TOTAL_CH_SAMPLES * sampling_coeff * total_channels);
+
+	if (tdmmc_ip_ver_get(ctrl_family_id) == MV_COMMUNIT_IP_VER_ORIGIN) {
+		if (sample_size > MV_PCM_FORMAT_1BYTE) {
+			dev_dbg(pdev, "Linear mode (Rx): swapping bytes\n");
+			for (index = 0; index < buff_size; index += 2) {
+				tmp = tdm_rx_buff[index];
+				tdm_rx_buff[index] = tdm_rx_buff[index+1];
+				tdm_rx_buff[index+1] = tmp;
+			}
+			dev_dbg(pdev, "Linear mode (Rx): swapping bytes...done.\n");
+		}
+	}
+
+	return 0;
+}
+
+/* Low level TDM interrupt service routine */
+int tdmmc_intr_low(struct mv_phone_intr_info *tdm_intr_info)
+{
+	u32 cause_reg, mask_reg, cause_and_mask, curr_desc, int_ack_bits = 0;
+	u8 index;
+
+	/* Read TDM cause & mask registers */
+	cause_reg = readl(regs + TDM_CAUSE_REG);
+	mask_reg = readl(regs + TDM_MASK_REG);
+
+	dev_dbg(pdev, "%s: Cause register = 0x%x, Mask register = 0x%x\n",
+		__func__, cause_reg, mask_reg);
+
+	/* Refer only to unmasked bits */
+	cause_and_mask = cause_reg & mask_reg;
+
+	/* Reset ISR params */
+	tdm_intr_info->tdm_rx_buff = NULL;
+	tdm_intr_info->tdm_tx_buff = NULL;
+	tdm_intr_info->int_type = MV_EMPTY_INT;
+
+	/* Return in case TDM is disabled */
+	if (!tdm_enable) {
+		dev_dbg(pdev, "%s: TDM is disabled - quit low lever ISR\n", __func__);
+		writel(~int_ack_bits, regs + TDM_CAUSE_REG);
+		return 0;
+	}
+
+	/* Handle TDM Error/s */
+	if (cause_and_mask & TDM_ERROR_INT) {
+		dev_err(pdev, "TDM Error: TDM_CAUSE_REG = 0x%x\n", cause_reg);
+		int_ack_bits |= (int_ack_bits & TDM_ERROR_INT);
+	}
+
+	if (cause_and_mask & (TDM_TX_INT | TDM_RX_INT)) {
+		/* MCDMA current Tx desc. pointer is unreliable, thus, checking Rx desc. pointer only */
+		curr_desc = readl(regs + MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(0));
+		dev_dbg(pdev, "%s: current descriptor = 0x%x\n", __func__, curr_desc);
+
+		/* Handle Tx */
+		if (cause_and_mask & TDM_TX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (curr_desc == mcdma_rx_desc_phys[index]) {
+					next_tx_buff = NEXT_BUFF(index);
+					break;
+				}
+			}
+			dev_dbg(pdev, "%s: TX interrupt (next_tx_buff = %d\n",
+				__func__, next_tx_buff);
+			tdm_intr_info->tdm_tx_buff = tx_buff_virt[next_tx_buff];
+			tdm_intr_info->int_type |= MV_TX_INT;
+			int_ack_bits |= TDM_TX_INT;
+		}
+
+		/* Handle Rx */
+		if (cause_and_mask & TDM_RX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (curr_desc == mcdma_rx_desc_phys[index]) {
+					prev_rx_buff = PREV_BUFF(index);
+					break;
+				}
+			}
+			dev_dbg(pdev, "%s: RX interrupt (prev_rx_buff = %d)\n",
+				__func__, prev_rx_buff);
+			tdm_intr_info->tdm_rx_buff = rx_buff_virt[prev_rx_buff];
+			tdm_intr_info->int_type |= MV_RX_INT;
+			int_ack_bits |= TDM_RX_INT;
+		}
+	}
+
+	/* Clear TDM interrupts */
+	writel(~int_ack_bits, regs + TDM_CAUSE_REG);
+
+	return 0;
+}
+
+int tdmmc_reset_slic(void)
+{
+	/* Enable SLIC reset */
+	mv_phone_reset_bit(regs + TDM_CLK_AND_SYNC_CONTROL_REG, TDM_PROG_TDM_SLIC_RESET_MASK);
+
+	udelay(60);
+
+	/* Release SLIC reset */
+	mv_phone_set_bit(regs + TDM_CLK_AND_SYNC_CONTROL_REG, TDM_PROG_TDM_SLIC_RESET_MASK);
+
+	return 0;
+}
+
+/* Initialize decoding windows */
+int tdmmc_set_mbus_windows(struct device *dev, void __iomem *regs)
+{
+	const struct mbus_dram_target_info *dram = mv_mbus_dram_info();
+	u32 win_protect, win_enable;
+	int i;
+
+	if (!dram) {
+		dev_err(dev, "no mbus dram info\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < COMM_UNIT_MBUS_MAX_WIN; i++) {
+		writel(0, regs + COMM_UNIT_WIN_CTRL_REG(i));
+		writel(0, regs + COMM_UNIT_WIN_SIZE_REG(i));
+		writel(0, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+	}
+
+	win_enable = 0xff;
+	win_protect = 0;
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+
+		writel((cs->base & 0xffff0000) |
+		       (cs->mbus_attr << 8) |
+		       dram->mbus_dram_target_id,
+		       regs + COMM_UNIT_WIN_CTRL_REG(i));
+
+		writel((cs->size - 1) & 0xffff0000,
+		       regs + COMM_UNIT_WIN_SIZE_REG(i));
+
+		writel(win_enable, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+		win_protect |= 3 << (2 * i);
+	}
+
+	/* Configure an extra window for PCIE0 */
+	writel(0x8000e804, regs + COMM_UNIT_WIN_CTRL_REG(i));
+	writel(0x1fff0000, regs + COMM_UNIT_WIN_SIZE_REG(i));
+	writel(win_enable, regs + COMM_UNIT_WIN_ENABLE_REG(i));
+	win_protect |= 3 << (2 * i);
+
+	writel(win_protect, regs + COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG);
+
+	return 0;
+}
+
diff --git a/drivers/telephony/mvebu_phone/tdmmc/tdmmc.h b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.h
new file mode 100644
index 0000000..8534196
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/tdmmc/tdmmc.h
@@ -0,0 +1,401 @@
+/*******************************************************************************
+ * Copyright (C) 2016 Marvell International Ltd.
+ *
+ * This software file (the "File") is owned and distributed by Marvell
+ * International Ltd. and/or its affiliates ("Marvell") under the following
+ * alternative licensing terms.  Once you have made an election to distribute the
+ * File under one of the following license alternatives, please (i) delete this
+ * introductory statement regarding license alternatives, (ii) delete the three
+ * license alternatives that you have not elected to use and (iii) preserve the
+ * Marvell copyright notice above.
+ *
+ * ********************************************************************************
+ * Marvell Commercial License Option
+ *
+ * If you received this File from Marvell and you have entered into a commercial
+ * license agreement (a "Commercial License") with Marvell, the File is licensed
+ * to you under the terms of the applicable Commercial License.
+ *
+ * ********************************************************************************
+ * Marvell GPL License Option
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ********************************************************************************
+ * Marvell GNU General Public License FreeRTOS Exception
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File in accordance with the terms and conditions of the Lesser
+ * General Public License Version 2.1 plus the following FreeRTOS exception.
+ * An independent module is a module which is not derived from or based on
+ * FreeRTOS.
+ * Clause 1:
+ * Linking FreeRTOS statically or dynamically with other modules is making a
+ * combined work based on FreeRTOS. Thus, the terms and conditions of the GNU
+ * General Public License cover the whole combination.
+ * As a special exception, the copyright holder of FreeRTOS gives you permission
+ * to link FreeRTOS with independent modules that communicate with FreeRTOS solely
+ * through the FreeRTOS API interface, regardless of the license terms of these
+ * independent modules, and to copy and distribute the resulting combined work
+ * under terms of your choice, provided that:
+ * 1. Every copy of the combined work is accompanied by a written statement that
+ * details to the recipient the version of FreeRTOS used and an offer by yourself
+ * to provide the FreeRTOS source code (including any modifications you may have
+ * made) should the recipient request it.
+ * 2. The combined work is not itself an RTOS, scheduler, kernel or related
+ * product.
+ * 3. The independent modules add significant and primary functionality to
+ * FreeRTOS and do not merely extend the existing functionality already present in
+ * FreeRTOS.
+ * Clause 2:
+ * FreeRTOS may not be used for any competitive or comparative purpose, including
+ * the publication of any form of run time or compile time metric, without the
+ * express permission of Real Time Engineers Ltd. (this is the norm within the
+ * industry and is intended to ensure information accuracy).
+ *
+ * ********************************************************************************
+ * Marvell BSD License Option
+ *
+ * If you received this File from Marvell, you may opt to use, redistribute and/or
+ * modify this File under the following licensing terms.
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *	* Redistributions of source code must retain the above copyright notice,
+ *	  this list of conditions and the following disclaimer.
+ *
+ *	* Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *
+ *	* Neither the name of Marvell nor the names of its contributors may be
+ *	  used to endorse or promote products derived from this software without
+ *	  specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _TDMMC_H_
+#define _TDMMC_H_
+
+/****************************************************************/
+/*	Time Division Multiplexing Interrupt Controller		*/
+/****************************************************************/
+#define COMM_UNIT_TOP_CAUSE_REG			0x8C00
+#define TDM_CAUSE_REG				0x8C40
+#define COMM_UNIT_TOP_MASK_REG			0x8C80
+#define VOICE_PERIODICAL_INT_CONTROL_REG	0x8C90
+#define TDM_MASK_REG				0x8CC0
+
+/* COMM_UNIT_TOP_CAUSE_REG bits */
+#define TDM_SUM_INT_OFFS			6
+#define TDM_SUM_INT_MASK			(1 << TDM_SUM_INT_OFFS)
+#define MCSC_SUM_INT_OFFS			28
+#define MCSC_SUM_INT_MASK			(1 << MCSC_SUM_INT_OFFS)
+
+/* TDM_CAUSE_REG bits */
+#define FLEX_TDM_RX_SYNC_LOSS_OFFS		3
+#define FLEX_TDM_RX_SYNC_LOSS_MASK		(1 << FLEX_TDM_RX_SYNC_LOSS_OFFS)
+#define FLEX_TDM_TX_SYNC_LOSS_OFFS		7
+#define FLEX_TDM_TX_SYNC_LOSS_MASK		(1 << FLEX_TDM_TX_SYNC_LOSS_OFFS)
+#define RX_VOICE_INT_PULSE_OFFS			8
+#define RX_VOICE_INT_PULSE_MASK			(1 << RX_VOICE_INT_PULSE_OFFS)
+#define TX_VOICE_INT_PULSE_OFFS			9
+#define TX_VOICE_INT_PULSE_MASK			(1 << TX_VOICE_INT_PULSE_OFFS)
+#define COMM_UNIT_PAR_ERR_SUM_OFFS		18
+#define COMM_UNIT_PAR_ERR_SUM_MASK		(1 << COMM_UNIT_PAR_ERR_SUM_OFFS)
+#define TDM_RX_PAR_ERR_SUM_OFFS			19
+#define TDM_RX_PAR_ERR_SUM_MASK			(1 << TDM_RX_PAR_ERR_SUM_OFFS)
+#define TDM_TX_PAR_ERR_SUM_OFFS			20
+#define TDM_TX_PAR_ERR_SUM_MASK			(1 << TDM_TX_PAR_ERR_SUM_OFFS)
+#define MCSC_PAR_ERR_SUM_OFFS			21
+#define MCSC_PAR_ERR_SUM_MASK			(1 << MCSC_PAR_ERR_SUM_OFFS)
+#define MCDMA_PAR_ERR_SUM_OFFS			22
+#define MCDMA_PAR_ERR_SUM_MASK			(1 << MCDMA_PAR_ERR_SUM_OFFS)
+
+/*  VOICE_PERIODICAL_INT_CONTROL_REG bits  */
+#define RX_VOICE_INT_CNT_REF_OFFS		0
+#define RX_VOICE_INT_CNT_REF_MASK		(0xff << RX_VOICE_INT_CNT_REF_OFFS)
+#define TX_VOICE_INT_CNT_REF_OFFS		8
+#define TX_VOICE_INT_CNT_REF_MASK		(0xff << TX_VOICE_INT_CNT_REF_OFFS)
+#define RX_FIRST_DELAY_REF_OFFS			16
+#define RX_FIRST_DELAY_REF_MASK			(0xff << RX_FIRST_DELAY_REF_OFFS)
+#define TX_FIRST_DELAY_REF_OFFS			24
+#define TX_FIRST_DELAY_REF_MASK			(0xff << TX_FIRST_DELAY_REF_OFFS)
+
+/* Multi-Channel Serial Controller (MCSC) */
+#define MCSC_CHx_RECEIVE_CONFIG_REG(ch)		(0x400 + (ch << 2))
+#define MCSC_CHx_TRANSMIT_CONFIG_REG(ch)	(0x1800 + (ch<<2))
+#define MCSC_GLOBAL_CONFIG_REG			0x2800
+#define MCSC_GLOBAL_INT_CAUSE_REG		0x2804
+#define MCSC_EXTENDED_INT_CAUSE_REG		0x2808
+#define MCSC_GLOBAL_INT_MASK_REG		0x280C
+#define MCSC_EXTENDED_INT_MASK_REG		0x2810
+#define MCSC_GLOBAL_CONFIG_EXTENDED_REG		0x2890
+
+/* MCSC_RECEIVE_CONFIG_REG(MRCRx) bits */
+#define MRCRx_ER_OFFS				27
+#define MRCRx_ER_MASK				(1 << MRCRx_ER_OFFS)
+#define MRCRx_RRVD_OFFS				30
+#define MRCRx_RRVD_MASK				(1 << MRCRx_RRVD_OFFS)
+#define MRCRx_MODE_OFFS				31
+#define MRCRx_MODE_MASK				(1 << MRCRx_MODE_OFFS)
+
+/* MCSC_TRANSMIT_CONFIG_REG(MTCRx) bits */
+#define MTCRx_ET_OFFS				27
+#define MTCRx_ET_MASK				(1 << MTCRx_ET_OFFS)
+#define MTCRx_TRVD_OFFS				30
+#define MTCRx_TRVD_MASK				(1 << MTCRx_TRVD_OFFS)
+#define MTCRx_MODE_OFFS				31
+#define MTCRx_MODE_MASK				(1 << MTCRx_MODE_OFFS)
+
+/* MCSC_GLOBAL_CONFIG_REG bits */
+#define MCSC_GLOBAL_CONFIG_TCBD_OFFS		20
+#define MCSC_GLOBAL_CONFIG_TCBD_MASK		(1 << MCSC_GLOBAL_CONFIG_TCBD_OFFS)
+#define MCSC_GLOBAL_CONFIG_MAI_OFFS		21
+#define MCSC_GLOBAL_CONFIG_MAI_MASK		(1 << MCSC_GLOBAL_CONFIG_MAI_OFFS)
+#define MCSC_GLOBAL_CONFIG_RXEN_OFFS		30
+#define MCSC_GLOBAL_CONFIG_RXEN_MASK		(1 << MCSC_GLOBAL_CONFIG_RXEN_OFFS)
+#define MCSC_GLOBAL_CONFIG_TXEN_OFFS		31
+#define MCSC_GLOBAL_CONFIG_TXEN_MASK		(1 << MCSC_GLOBAL_CONFIG_TXEN_OFFS)
+
+/* MCSC_GLOBAL_INT_CAUSE_REG */
+#define  MCSC_GLOBAL_INT_CAUSE_INIT_DONE_OFFS	25
+#define  MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_INIT_DONE_OFFS)
+
+/* MCSC_GLOBAL_CONFIG_EXTENDED_REG bits */
+#define  MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_OFFS	2
+#define  MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_MASK	(1 << MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_OFFS)
+#define  MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_OFFS	3
+#define  MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_MASK	(1 << MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_OFFS)
+
+/* Multi-Channel DMA(MCDMA) */
+#define MCDMA_RECEIVE_CONTROL_REG(ch)		(0x3000 + (ch<<2))
+#define MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(ch)	(0x4000 + (ch<<2))
+#define MCDMA_GLOBAL_CONTROL_REG		0x4400
+#define RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG	0x4408
+#define MCDMA_TRANSMIT_CONTROL_REG(ch)		(0x5000 + (ch<<2))
+#define MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(ch)	(0x7000 + (ch<<2))
+#define TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG	0x7408
+
+/* MCDMA_RECEIVE_CONTROL_REG bits */
+#define MCDMA_RBSZ_16BYTE			0x1
+
+#define MCDMA_BLMR_OFFS				2
+#define MCDMA_BLMR_MASK				(1 << MCDMA_BLMR_OFFS)
+#define MCDMA_ERD_OFFS				6
+#define MCDMA_ERD_MASK				(1 << MCDMA_ERD_OFFS)
+
+/* MCDMA_GLOBAL_CONTROL_REG bits */
+#define MCDMA_RID_OFFS				1
+#define MCDMA_RID_MASK				(1 << MCDMA_RID_OFFS)
+
+/* MCDMA_TRANSMIT_CONTROL_REG bits */
+#define MCDMA_FSIZE_1BLK			0x1
+#define MCDMA_TBSZ_OFFS				8
+#define MCDMA_TBSZ_16BYTE			(0x1 << MCDMA_TBSZ_OFFS)
+#define MCDMA_BLMT_OFFS				10
+#define MCDMA_BLMT_MASK				(1 << MCDMA_BLMT_OFFS)
+#define MCDMA_TXD_OFFS				17
+#define MCDMA_TXD_MASK				(1 << MCDMA_TXD_OFFS)
+
+/* Time Division Multiplexing(TDM) */
+#define FLEX_TDM_TDPR_REG(entry)		(0x8000 + (entry<<2))
+#define FLEX_TDM_RDPR_REG(entry)		(0x8400 + (entry<<2))
+#define FLEX_TDM_CONFIG_REG			0x8808
+#define TDM_CLK_AND_SYNC_CONTROL_REG		0x881C
+#define TDM_OUTPUT_SYNC_BIT_COUNT_REG		0x8C8C
+#define TDM_DATA_DELAY_AND_CLK_CTRL_REG		0x8CD0
+
+/* TDM_CLK_AND_SYNC_CONTROL_REG bits */
+#define TDM_TX_FSYNC_OUT_ENABLE_OFFS		0
+#define TDM_TX_FSYNC_OUT_ENABLE_MASK		(1 << TDM_TX_FSYNC_OUT_ENABLE_OFFS)
+#define TDM_RX_FSYNC_OUT_ENABLE_OFFS		1
+#define TDM_RX_FSYNC_OUT_ENABLE_MASK		(1 << TDM_RX_FSYNC_OUT_ENABLE_OFFS)
+#define TDM_TX_CLK_OUT_ENABLE_OFFS		2
+#define TDM_TX_CLK_OUT_ENABLE_MASK		(1 << TDM_TX_CLK_OUT_ENABLE_OFFS)
+#define TDM_RX_CLK_OUT_ENABLE_OFFS		3
+#define TDM_RX_CLK_OUT_ENABLE_MASK		(1 << TDM_RX_CLK_OUT_ENABLE_OFFS)
+#define TDM_REFCLK_DIVIDER_BYPASS_OFFS		20
+#define TDM_REFCLK_DIVIDER_BYPASS_MASK		(3 << TDM_REFCLK_DIVIDER_BYPASS_OFFS)
+#define TDM_OUT_CLK_SRC_CTRL_OFFS		24
+#define TDM_OUT_CLK_SRC_CTRL_AFTER_DIV		(1 << TDM_OUT_CLK_SRC_CTRL_OFFS)
+#define TDM_PROG_TDM_SLIC_RESET_OFFS		31
+#define TDM_PROG_TDM_SLIC_RESET_MASK		(1 << TDM_PROG_TDM_SLIC_RESET_OFFS)
+
+/* FLEX_TDM_CONFIG_REG bits */
+#define TDM_RR2HALF_OFFS			15
+#define TDM_RR2HALF_MASK			(1 << TDM_RR2HALF_OFFS)
+#define TDM_TR2HALF_OFFS			16
+#define TDM_TR2HALF_MASK			(1 << TDM_TR2HALF_OFFS)
+#define TDM_SE_OFFS				20
+#define TDM_SE_MASK				(1 << TDM_SE_OFFS)
+#define TDM_COMMON_RX_TX_OFFS			23
+#define TDM_COMMON_RX_TX_MASK			(1 << TDM_COMMON_RX_TX_OFFS)
+#define TSD_OFFS				25
+#define TSD_NO_DELAY				(0 << TSD_OFFS)
+#define RSD_OFFS				27
+#define RSD_NO_DELAY				(0 << RSD_OFFS)
+#define TDM_TEN_OFFS				31
+#define TDM_TEN_MASK				(1 << TDM_TEN_OFFS)
+
+/* TDM_OUTPUT_SYNC_BIT_COUNT_REG bits */
+#define TDM_SYNC_BIT_TX_OFFS			0
+#define TDM_SYNC_BIT_TX_MASK			(0xffff << TDM_SYNC_BIT_TX_OFFS)
+#define TDM_SYNC_BIT_RX_OFFS			16
+#define TDM_SYNC_BIT_RX_MASK			(0xffff << TDM_SYNC_BIT_RX_OFFS)
+
+/* TDM_DATA_DELAY_AND_CLK_CTRL_REG bits */
+#define TX_CLK_OUT_ENABLE_OFFS			0
+#define TX_CLK_OUT_ENABLE_MASK			(1 << TX_CLK_OUT_ENABLE_OFFS)
+#define RX_CLK_OUT_ENABLE_OFFS			1
+#define RX_CLK_OUT_ENABLE_MASK			(1 << RX_CLK_OUT_ENABLE_OFFS)
+
+/************************************************/
+/*	Shared Bus to Crossbar Bridge		*/
+/************************************************/
+#define COMM_UNIT_MBUS_MAX_WIN			12
+
+#define COMM_UNIT_WIN_CTRL_REG(win)		(0x8A00 + (win<<3))
+#define COMM_UNIT_WIN_SIZE_REG(win)		(0x8A04 + (win<<3))
+#define COMM_UNIT_WIN_ENABLE_REG(win)		(0x8B04 + (win<<2))
+#define COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG	0x8B00
+#define TIME_OUT_COUNTER_REG			0x8ADC
+
+/* TIME_OUT_COUNTER_REG bits */
+#define	TIME_OUT_THRESHOLD_COUNT_OFFS		16
+#define	TIME_OUT_THRESHOLD_COUNT_MASK		(0xffff << TIME_OUT_THRESHOLD_COUNT_OFFS)
+
+/* Defines */
+#define MV_TDMMC_TOTAL_CHANNELS			32
+#define MV_TDM_MAX_HALF_DPRAM_ENTRIES		128
+
+/* IRQ types */
+#define TDM_TX_INT		 TX_VOICE_INT_PULSE_MASK
+#define TDM_RX_INT		 RX_VOICE_INT_PULSE_MASK
+#define TDM_ERROR_INT \
+	(FLEX_TDM_RX_SYNC_LOSS_MASK | FLEX_TDM_TX_SYNC_LOSS_MASK |	\
+	 COMM_UNIT_PAR_ERR_SUM_MASK | TDM_RX_PAR_ERR_SUM_MASK |		\
+	 TDM_TX_PAR_ERR_SUM_MASK | MCSC_PAR_ERR_SUM_MASK |		\
+	 MCDMA_PAR_ERR_SUM_MASK)
+
+/* MCDMA Descriptor Command/Status Bits */
+#define	LAST_BIT	0x00010000
+#define	FIRST_BIT	0x00020000
+#define	AUTO_MODE	0x40000000
+#define	OWNER		0x80000000
+
+/* MCDMA */
+#define CONFIG_MCDMA_DESC_CMD_STATUS	(FIRST_BIT | AUTO_MODE | OWNER)
+#define CONFIG_RMCCx			(MCDMA_RBSZ_16BYTE | MCDMA_BLMR_MASK)
+#define CONFIG_TMCCx \
+	(MCDMA_FSIZE_1BLK | MCDMA_TBSZ_16BYTE | MCDMA_BLMT_MASK)
+
+/* MCSC */
+#define CONFIG_MRCRx			(MRCRx_RRVD_MASK | MRCRx_MODE_MASK)
+#define CONFIG_MTCRx			(MTCRx_TRVD_MASK | MTCRx_MODE_MASK)
+#define CONFIG_LINEAR_BYTE_SWAP \
+	(MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_MASK |	\
+	MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_MASK)
+/* TDM */
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	\
+	(TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK |	\
+	TDM_REFCLK_DIVIDER_BYPASS_MASK)
+#else
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	\
+	(TDM_REFCLK_DIVIDER_BYPASS_MASK | TDM_OUT_CLK_SRC_CTRL_AFTER_DIV)
+#endif
+
+#define CONFIG_VOICE_PERIODICAL_INT_CONTROL \
+	(((MV_TDM_TOTAL_CH_SAMPLES) << RX_VOICE_INT_CNT_REF_OFFS) |	\
+	((MV_TDM_TOTAL_CH_SAMPLES) << TX_VOICE_INT_CNT_REF_OFFS) |	\
+	(2 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
+#define CONFIG_VOICE_PERIODICAL_INT_CONTROL_WA \
+	(((MV_TDM_TOTAL_CH_SAMPLES - 1) << RX_VOICE_INT_CNT_REF_OFFS) |	\
+	((MV_TDM_TOTAL_CH_SAMPLES - 1) << TX_VOICE_INT_CNT_REF_OFFS) |	\
+	(2 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
+#define CONFIG_TDM_CAUSE \
+	(TDM_RX_INT | TDM_TX_INT)
+#define CONFIG_COMM_UNIT_TOP_MASK \
+	(TDM_SUM_INT_MASK | MCSC_SUM_INT_MASK)
+#define CONFIG_FLEX_TDM_CONFIG \
+	(TDM_SE_MASK | TDM_COMMON_RX_TX_MASK | TSD_NO_DELAY | RSD_NO_DELAY)
+#define	CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL \
+	(TX_CLK_OUT_ENABLE_MASK | RX_CLK_OUT_ENABLE_MASK)
+
+/* SoC ID's */
+#define MV_65XX_DEV_ID		0x6500	/* MV88F6500 family */
+#define MV_78XX0		0x78000	/* Armada XP Family */
+#define MV_88F66X0		0x6600	/* Avanta LP Family */
+#define MV_88F67X0		0x6700	/* Armada 375 Family */
+
+enum tdmmc_ip_version {
+	MV_COMMUNIT_IP_VER_ORIGIN   = 0,
+	MV_COMMUNIT_IP_VER_REVISE_1,
+};
+
+/* Structures */
+struct tdmmc_mcdma_rx_desc {
+	u32 cmd_status;
+	u16 byte_cnt;
+	u16 buff_size;
+	u32 phys_buff_ptr;
+	u32 phys_next_desc_ptr;
+};
+
+struct tdmmc_mcdma_tx_desc {
+	u32 cmd_status;
+	u16 shadow_byte_cnt;
+	u16 byte_cnt;
+	u32 phys_buff_ptr;
+	u32 phys_next_desc_ptr;
+};
+
+struct tdmmc_dram_entry {
+	u32 mask:8;
+	u32 ch:8;
+	u32 mgs:2;
+	u32 byte:1;
+	u32 strb:2;
+	u32 elpb:1;
+	u32 tbs:1;
+	u32 rpt:2;
+	u32 last:1;
+	u32 ftint:1;
+	u32 reserved31_27:5;
+};
+
+/* TDMMC APIs */
+void tdmmc_pcm_start(void);
+void tdmmc_pcm_stop(void);
+int tdmmc_tx(u8 *tdm_tx_buff);
+int tdmmc_rx(u8 *tdm_rx_buff);
+void tdmmc_show(void);
+void tdmmc_release(void);
+void tdmmc_intr_enable(u8 device_id);
+void tdmmc_intr_disable(u8 device_id);
+int tdmmc_reset_slic(void);
+int tdmmc_set_mbus_windows(struct device *dev, void __iomem *regs);
+
+#endif /* _TDMMC_H_ */
+
-- 
1.7.9.5


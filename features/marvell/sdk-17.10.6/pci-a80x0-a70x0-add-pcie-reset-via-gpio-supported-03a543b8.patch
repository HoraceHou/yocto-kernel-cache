From 26e618d8696c7b654cd0c26ddc3d57385bce25e6 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Tue, 8 Aug 2017 16:07:30 +0800
Subject: [PATCH 1328/1345] pci: a80x0: a70x0: add pcie reset via gpio
 supported

commit  de0202d35b0489473186c4dfe087b942f531ff12 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

For some boards need PCIe reset, this patch added support
for PCIe reset using GPIO

Change-Id: If7498c04fb46fd7438165244c0f816042c9677f1
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42743
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/dwc/pcie-armada8k.c |   41 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 36 insertions(+), 5 deletions(-)

diff --git a/drivers/pci/dwc/pcie-armada8k.c b/drivers/pci/dwc/pcie-armada8k.c
index a6362a5..3a1da63 100644
--- a/drivers/pci/dwc/pcie-armada8k.c
+++ b/drivers/pci/dwc/pcie-armada8k.c
@@ -26,6 +26,7 @@
 #include <linux/of_pci.h>
 #include <linux/of_irq.h>
 #include <dt-bindings/phy/phy-comphy-mvebu.h>
+#include <linux/of_gpio.h>
 
 #include "pcie-designware.h"
 
@@ -34,6 +35,8 @@ struct armada8k_pcie {
 	struct clk *clk;
 	struct phy		**phys;
 	int			phy_count;
+	struct gpio_desc	*reset_gpio;
+	enum of_gpio_flags	flags;
 };
 
 #define PCIE_VENDOR_REGS_OFFSET		0x8000
@@ -204,6 +207,24 @@ static int armada8k_add_pcie_port(struct armada8k_pcie *pcie,
 	.link_up = armada8k_pcie_link_up,
 };
 
+/* armada8k_pcie_reset
+ * The function implements the PCIe reset via GPIO.
+ * First, pull down the GPIO used for PCIe reset, and wait 200ms;
+ * Second, set the GPIO output value with setting from DTS, and wait
+ * 200ms for taking effect.
+ * Return: void, always success.
+ */
+static void armada8k_pcie_reset(struct armada8k_pcie *pcie)
+{
+	/* Set the reset gpio to low first */
+	gpiod_direction_output(pcie->reset_gpio, 0);
+	/* After 200ms to reset pcie */
+	mdelay(200);
+	gpiod_direction_output(pcie->reset_gpio,
+			       (pcie->flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+	mdelay(200);
+}
+
 static int armada8k_pcie_probe(struct platform_device *pdev)
 {
 	struct dw_pcie *pci;
@@ -211,8 +232,7 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct resource *base;
 	struct phy **phys = NULL;
-	struct resource *base;
-	int i, phy_count = 0;
+	int i, reset_gpio, phy_count = 0;
 	u32 command;
 	char phy_name[16];
 	int ret;
@@ -247,8 +267,10 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 		for (i = 0; i < phy_count; i++) {
 			snprintf(phy_name, sizeof(phy_name), "pcie-phy%d", i);
 			phys[i] = devm_phy_get(dev, phy_name);
-			if (IS_ERR(phys[i]))
+			if (IS_ERR(phys[i])) {
+				ret = PTR_ERR(phys[i]);
 				goto err_phy;
+			}
 
 			/* Tell COMPHY the PCIE width based on phy command,
 			 * and in PHY command callback, the width will be
@@ -281,8 +303,17 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 		}
 	}
 
-	armada8k_pcie->phys = phys;
-	armada8k_pcie->phy_count = phy_count;
+	/* Config reset gpio for pcie if the reset connected to gpio */
+	reset_gpio = of_get_named_gpio_flags(pdev->dev.of_node,
+					     "reset-gpios", 0,
+					     &pcie->flags);
+	if (gpio_is_valid(reset_gpio)) {
+		pcie->reset_gpio = gpio_to_desc(reset_gpio);
+		armada8k_pcie_reset(pcie);
+	}
+
+	pcie->phys = phys;
+	pcie->phy_count = phy_count;
 
 	/* Get the dw-pcie unit configuration/control registers base. */
 	base = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl");
-- 
1.7.9.5


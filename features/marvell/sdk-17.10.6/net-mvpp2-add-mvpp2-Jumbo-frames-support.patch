From bd485685ba5d38913f809adcf0aecaa5ff69a06c Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Thu, 10 Aug 2017 13:08:13 +0300
Subject: [PATCH 1137/1345] net: mvpp2: add mvpp2 Jumbo frames support

commit  915b8b1dec703fd50cd24a6d1833ecc943e1e85f from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

For Jumbo pool support:
 - Added third buffers manager pool with 10KB buffers
 - If port MTU is higher than 1518B port will use 10KB
   buffers for packets with packet size > 1518B and
   2KB buffers for packets with packet size <= 1518B
 - Due to TX FIFO size limitation only 10G port 0
   support HW checksum offload.

Change-Id: I616e97a3455eb446eeca5a53abfdbf2878f6fc78
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42935
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2.c |  104 +++++++++++++++++++++++++++-------
 1 file changed, 83 insertions(+), 21 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2.c b/drivers/net/ethernet/marvell/mvpp2.c
index b230c96..fd2582a 100644
--- a/drivers/net/ethernet/marvell/mvpp2.c
+++ b/drivers/net/ethernet/marvell/mvpp2.c
@@ -741,6 +741,7 @@ enum mvpp2_prs_l3_cast {
 
 /* BM constants */
 #define MVPP2_BM_POOLS_NUM		8
+#define MVPP2_BM_JUMBO_BUF_NUM		512
 #define MVPP2_BM_LONG_BUF_NUM		1024
 #define MVPP2_BM_SHORT_BUF_NUM		2048
 #define MVPP2_BM_POOL_SIZE_MAX		(16*1024 - MVPP2_BM_POOL_PTR_ALIGN/4)
@@ -752,12 +753,14 @@ enum mvpp2_prs_l3_cast {
 
 #define MVPP2_BM_SHORT_FRAME_SIZE		1024
 #define MVPP2_BM_LONG_FRAME_SIZE		2048
+#define MVPP2_BM_JUMBO_FRAME_SIZE		10240
 /* BM short pool packet size
  * These value assure that for SWF the total number
  * of bytes allocated for each buffer will be 512
  */
 #define MVPP2_BM_SHORT_PKT_SIZE	MVPP2_RX_MAX_PKT_SIZE(MVPP2_BM_SHORT_FRAME_SIZE)
 #define MVPP2_BM_LONG_PKT_SIZE	MVPP2_RX_MAX_PKT_SIZE(MVPP2_BM_LONG_FRAME_SIZE)
+#define MVPP2_BM_JUMBO_PKT_SIZE	MVPP2_RX_MAX_PKT_SIZE(MVPP2_BM_JUMBO_FRAME_SIZE)
 
 #define MVPP21_ADDR_SPACE_SZ		0
 #define MVPP22_ADDR_SPACE_SZ		SZ_64K
@@ -768,6 +771,7 @@ enum mvpp2_prs_l3_cast {
 enum mvpp2_bm_pool_log_num {
 	MVPP2_BM_SHORT,
 	MVPP2_BM_LONG,
+	MVPP2_BM_JUMBO,
 	MVPP2_BM_NUM_POOLS
 };
 
@@ -1192,6 +1196,10 @@ struct mvpp2_pool_attributes mvpp2_pools[] = {
 	{
 		.description =  "long", /* pkt_size=MVPP2_BM_LONG_PKT_SIZE */
 		.buf_num     =  MVPP2_BM_LONG_BUF_NUM,
+	},
+	{
+		.description =	"jumbo", /* pkt_size=MVPP2_BM_JUMBO_PKT_SIZE */
+		.buf_num     =  MVPP2_BM_JUMBO_BUF_NUM,
 	}
 };
 
@@ -4020,6 +4028,8 @@ static void mvpp2_set_bm_pool_packet_size(void)
 		MVPP2_BM_SHORT_PKT_SIZE;
 	mvpp2_pools[MVPP2_BM_LONG].pkt_size =
 		MVPP2_BM_LONG_PKT_SIZE;
+	mvpp2_pools[MVPP2_BM_JUMBO].pkt_size =
+		MVPP2_BM_JUMBO_PKT_SIZE;
 }
 
 /* Attach long pool to rxq */
@@ -4188,7 +4198,7 @@ static int mvpp2_bm_buf_calc(enum mvpp2_bm_pool_log_num log_pool,
 	struct mvpp2_bm_pool *pool = &port->priv->bm_pools[pool_id];
 
 	if (pool_id < MVPP2_BM_SHORT ||
-	    pool_id > MVPP2_BM_LONG) {
+	    pool_id > MVPP2_BM_JUMBO) {
 		netdev_err(port->dev, "pool does not exist\n");
 		return NULL;
 	}
@@ -4225,11 +4235,23 @@ static int mvpp2_bm_buf_calc(enum mvpp2_bm_pool_log_num log_pool,
 static int mvpp2_swf_bm_pool_init(struct mvpp2_port *port)
 {
 	int rxq;
+	enum mvpp2_bm_pool_log_num long_log_pool, short_log_pool;
+
+	/* If port pkt_size is higher than 1518B:
+	 * HW Long pool - SW Jumbo pool, HW Short pool - SW Short pool
+	 * esle: HW Long pool - SW Long pool, HW Short pool - SW Short pool
+	 */
+	if (port->pkt_size > MVPP2_BM_LONG_PKT_SIZE) {
+		long_log_pool = MVPP2_BM_JUMBO;
+		short_log_pool = MVPP2_BM_LONG;
+	} else {
+		long_log_pool = MVPP2_BM_LONG;
+		short_log_pool = MVPP2_BM_SHORT;
+	}
 
 	if (!port->pool_long) {
 		port->pool_long =
-			mvpp2_bm_pool_use(port, MVPP2_BM_LONG,
-					  mvpp2_pools[MVPP2_BM_LONG].pkt_size);
+			mvpp2_bm_pool_use(port, long_log_pool, true);
 		if (!port->pool_long)
 			return -ENOMEM;
 
@@ -4241,8 +4263,7 @@ static int mvpp2_swf_bm_pool_init(struct mvpp2_port *port)
 
 	if (!port->pool_short) {
 		port->pool_short =
-			mvpp2_bm_pool_use(port, MVPP2_BM_SHORT,
-					  mvpp2_pools[MVPP2_BM_SHORT].pkt_size);
+			mvpp2_bm_pool_use(port, short_log_pool, true);
 		if (!port->pool_short)
 			return -ENOMEM;
 
@@ -4259,24 +4280,52 @@ static int mvpp2_swf_bm_pool_init(struct mvpp2_port *port)
 static int mvpp2_bm_update_mtu(struct net_device *dev, int mtu)
 {
 	struct mvpp2_port *port = netdev_priv(dev);
-	struct mvpp2_bm_pool *port_pool = port->pool_long;
-	int num, pkts_num = port_pool->buf_num;
+	enum mvpp2_bm_pool_log_num new_long_pool;
+	int pkt_size = MVPP2_RX_PKT_SIZE(mtu);
 
-	/* Update BM pool with new buffer size */
-	mvpp2_bm_bufs_free(dev->dev.parent, port->priv, port_pool,
-			   port_pool->buf_num);
-	if (port_pool->buf_num) {
-		WARN(1, "cannot free all buffers in pool %d\n", port_pool->id);
-		return -EIO;
+	/* If port MTU is higher than 1518B:
+	 * HW Long pool - SW Jumbo pool, HW Short pool - SW Short pool
+	 * esle: HW Long pool - SW Long pool, HW Short pool - SW Short pool
+	 */
+	if (pkt_size > MVPP2_BM_LONG_PKT_SIZE)
+		new_long_pool = MVPP2_BM_JUMBO;
+	else
+		new_long_pool = MVPP2_BM_LONG;
+
+	if (new_long_pool != port->pool_long->id) {
+		/* Remove port from old short&long pool */
+		port->pool_long = mvpp2_bm_pool_use(port, port->pool_long->id,
+						    false);
+		port->pool_long->port_map &= ~(1 << port->id);
+		port->pool_long = NULL;
+
+		port->pool_short = mvpp2_bm_pool_use(port, port->pool_short->id,
+						     false);
+		port->pool_short->port_map &= ~(1 << port->id);
+		port->pool_short = NULL;
+
+		port->pkt_size =  pkt_size;
+
+		/* Add port to new short&long pool */
+		mvpp2_swf_bm_pool_init(port);
+
+		/* Update L4 checksum when jumbo enable/disable on port */
+		if ((new_long_pool == MVPP2_BM_JUMBO) && (port->id != 0)) {
+			dev->features &=
+					~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+			dev->hw_features &=
+					~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+		} else {
+			dev->features |=
+				(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+			dev->hw_features |=
+				(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+		}
 	}
 
-	num = mvpp2_bm_bufs_add(port, port_pool, pkts_num);
-	if (num != pkts_num) {
-		WARN(1, "pool %d: %d of %d allocated\n",
-		     port_pool->id, num, pkts_num);
-		return -EIO;
-	}
 	dev->mtu = mtu;
+
+	dev->wanted_features = dev->features;
 	netdev_update_features(dev);
 	return 0;
 }
@@ -7576,8 +7625,21 @@ static int mvpp2_port_probe(struct platform_device *pdev,
 	}
 
 	features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
-	dev->features = features | NETIF_F_RXCSUM;
-	dev->hw_features |= features | NETIF_F_RXCSUM | NETIF_F_GRO;
+	dev->features = features;
+	dev->hw_features |= features | NETIF_F_GRO;
+
+	if ((port->pool_long->id == MVPP2_BM_JUMBO) && (port->id != 0)) {
+		dev->features &=
+				~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+		dev->hw_features &=
+				~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+	} else {
+		dev->features |=
+			(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+		dev->hw_features |=
+			(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+	}
+
 	dev->vlan_features |= features;
 	dev->gso_max_segs = MVPP2_MAX_TSO_SEGS;
 
-- 
1.7.9.5


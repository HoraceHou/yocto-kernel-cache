From 5035ad3b9c1c53b558af9d55e95ff97972f9e526 Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Tue, 28 Jun 2016 18:36:27 +0300
Subject: [PATCH 0307/1345] net: mvpp2x: clean-up FPGA/PALLADUIM code

commit  b71e0041f22a3dae433c66aa1bd88010e44ca577 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Change-Id: I6aaed15bdf41e5627314c5827e3c559404e6c42d
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/30803
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Yuval Caduri <cyuval@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |   43 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c   |  144 +-----
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |   43 --
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |  544 ++------------------
 4 files changed, 48 insertions(+), 726 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index c86150f..2382f82 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -36,32 +36,6 @@
 
 #define IRQ_NAME_SIZE (36)
 
-
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-#define CONFIG_MV_PP2_POLLING
-#endif
-
-#ifdef CONFIG_MV_PP2_PALLADIUM
-#define PALAD(x)	x
-#else
-#define PALAD(x)
-#endif
-
-#ifdef CONFIG_MV_PP2_FPGA
-#define FPGA	1
-#else
-#define FPGA	0
-#endif
-
-#if defined(CONFIG_MV_PP2_PALLADIUM)
-/*These are the indexes of
- * MVPP2_PRS_FL_IP4_UNTAG_NO_OPV4_OPTIONS/MVPP2_PRS_FL_NON_IP_UNTAG
- * in mv_pp2x_prs_flow_id_array[]
- */
-#define MVPP2_PRS_FL_IP4_UNTAG_NO_OPV4_OPTIONS	40
-#define MVPP2_PRS_FL_NON_IP_UNTAG_INDEX		50
-#endif
-
 #define DBG_MSG(fmt, args...)	printk(fmt, ## args)
 
 #ifdef MVPP2_DEBUG
@@ -182,20 +156,16 @@
 
 /* BM constants */
 #define MVPP2_BM_POOLS_NUM		16
-#define MVPP2_BM_POOLS_MAX_ALLOC_NUM	4 /* Max num of allowed BM pools allocations*/
+#define MVPP2_BM_POOLS_MAX_ALLOC_NUM	4 /* Max num of allowed BM pools
+					   * allocations
+					   */
 #define MVPP2_BM_POOL_SIZE_MAX		(16 * 1024 - \
 					MVPP2_BM_POOL_PTR_ALIGN / 4)
 #define MVPP2_BM_POOL_PTR_ALIGN		128
 
-#ifdef CONFIG_MV_PP2_PALLADIUM
-#define MVPP2_BM_SHORT_BUF_NUM		256
-#define MVPP2_BM_LONG_BUF_NUM		256
-#define MVPP2_BM_JUMBO_BUF_NUM		256
-#else
 #define MVPP2_BM_SHORT_BUF_NUM		2048
 #define MVPP2_BM_LONG_BUF_NUM		1024
 #define MVPP2_BM_JUMBO_BUF_NUM		512
-#endif
 
 #define MVPP2_ALL_BUFS			0
 
@@ -546,9 +516,6 @@ struct mv_pp2x_pcpu_stats {
 /* Per-CPU port control */
 struct mv_pp2x_port_pcpu {
 	struct hrtimer tx_done_timer;
-#ifdef CONFIG_MV_PP2_PALLADIUM
-	struct timer_list slow_tx_done_timer;
-#endif
 	bool timer_scheduled;
 	/* Tasklet for egress finalization */
 	struct tasklet_struct tx_done_tasklet;
@@ -749,10 +716,6 @@ struct mv_pp2x_pool_attributes {
 
 extern struct mv_pp2x_pool_attributes mv_pp2x_pools[];
 
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-void *mv_pp2x_vfpga_address_get(void);
-#endif
-
 void mv_pp2x_bm_bufs_free(struct mv_pp2x *priv, struct mv_pp2x_bm_pool *bm_pool,
 			  int buf_num, bool is_skb);
 int mv_pp2x_bm_bufs_add(struct mv_pp2x_port *port,
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
index f055815d..f64198d 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
@@ -63,7 +63,7 @@ void mv_pp2x_write(struct mv_pp2x_hw *hw, u32 offset, u32 data)
 {
 	void *reg_ptr = hw->cpu_base[smp_processor_id()] + offset;
 
-#if defined(MVPP2_DEBUG) && !defined(CONFIG_MV_PP2_PALLADIUM)
+#if defined(MVPP2_DEBUG)
 	static void *last_used[20] = {0};
 	static int next_write;
 	int i;
@@ -101,7 +101,7 @@ void mv_pp2x_relaxed_write(struct mv_pp2x_hw *hw, u32 offset, u32 data)
 
 u32 mv_pp2x_read(struct mv_pp2x_hw *hw, u32 offset)
 {
-#if defined(MVPP2_DEBUG) && !defined(CONFIG_MV_PP2_PALLADIUM)
+#if defined(MVPP2_DEBUG)
 	static void *last_used[20] = {0};
 	static int next_write;
 	int i;
@@ -110,7 +110,7 @@ u32 mv_pp2x_read(struct mv_pp2x_hw *hw, u32 offset)
 	u32 val;
 
 	val = readl(reg_ptr);
-#if defined(MVPP2_DEBUG) && !defined(CONFIG_MV_PP2_PALLADIUM)
+#if defined(MVPP2_DEBUG)
 	for (i = 0; i < MVPP2_REG_BUF_SIZE; i++) {
 		if (last_used[i] == reg_ptr)
 			break;
@@ -128,9 +128,7 @@ u32 mv_pp2x_read(struct mv_pp2x_hw *hw, u32 offset)
 
 	if (debug_param)
 		pr_info("mv_pp2x_read: 0x%p data=0x%x\n", reg_ptr, val);
-
 #endif
-
 	return val;
 }
 EXPORT_SYMBOL(mv_pp2x_read);
@@ -681,7 +679,6 @@ static void mv_pp2x_prs_tcam_data_dword_get(struct mv_pp2x_prs_entry *pe,
 	}
 }
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Compare tcam data bytes with a pattern */
 static bool mv_pp2x_prs_tcam_data_cmp(struct mv_pp2x_prs_entry *pe, int offs,
 				      u16 data)
@@ -693,7 +690,6 @@ static bool mv_pp2x_prs_tcam_data_cmp(struct mv_pp2x_prs_entry *pe, int offs,
 		return false;
 	return true;
 }
-#endif
 
 /* Update ai bits in tcam sw entry */
 void mv_pp2x_prs_tcam_ai_update(struct mv_pp2x_prs_entry *pe,
@@ -717,14 +713,11 @@ void mv_pp2x_prs_tcam_ai_update(struct mv_pp2x_prs_entry *pe,
 }
 EXPORT_SYMBOL(mv_pp2x_prs_tcam_ai_update);
 
-
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Get ai bits from tcam sw entry */
 static int mv_pp2x_prs_tcam_ai_get(struct mv_pp2x_prs_entry *pe)
 {
 	return pe->tcam.byte[HW_BYTE_OFFS(MVPP2_PRS_TCAM_AI_BYTE)];
 }
-#endif
 
 /* Set ethertype in tcam sw entry */
 static void mv_pp2x_prs_match_etype(struct mv_pp2x_prs_entry *pe, int offset,
@@ -771,13 +764,11 @@ void mv_pp2x_prs_sram_ri_update(struct mv_pp2x_prs_entry *pe,
 }
 EXPORT_SYMBOL(mv_pp2x_prs_sram_ri_update);
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Obtain ri bits from sram sw entry */
 static int mv_pp2x_prs_sram_ri_get(struct mv_pp2x_prs_entry *pe)
 {
 	return pe->sram.word[MVPP2_PRS_SRAM_RI_WORD];
 }
-#endif
 
 /* Update ai bits in sram sw entry */
 void mv_pp2x_prs_sram_ai_update(struct mv_pp2x_prs_entry *pe,
@@ -1165,7 +1156,6 @@ static void mv_pp2x_prs_dsa_tag_set(struct mv_pp2x_hw *hw, int port, bool add,
 	mv_pp2x_prs_hw_write(hw, &pe);
 }
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Set entry for dsa ethertype */
 static void mv_pp2x_prs_dsa_tag_ethertype_set(struct mv_pp2x_hw *hw, int port,
 					      bool add, bool tagged,
@@ -1235,9 +1225,7 @@ static void mv_pp2x_prs_dsa_tag_ethertype_set(struct mv_pp2x_hw *hw, int port,
 
 	mv_pp2x_prs_hw_write(hw, &pe);
 }
-#endif
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Search for existing single/triple vlan entry */
 static struct mv_pp2x_prs_entry *mv_pp2x_prs_vlan_find(struct mv_pp2x_hw *hw,
 						       unsigned short tpid,
@@ -1288,9 +1276,7 @@ static struct mv_pp2x_prs_entry *mv_pp2x_prs_vlan_find(struct mv_pp2x_hw *hw,
 
 	return NULL;
 }
-#endif
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Add/update single/triple vlan entry */
 static int mv_pp2x_prs_vlan_add(struct mv_pp2x_hw *hw, unsigned short tpid,
 				int ai, unsigned int port_map)
@@ -1369,9 +1355,7 @@ static int mv_pp2x_prs_vlan_add(struct mv_pp2x_hw *hw, unsigned short tpid,
 
 	return ret;
 }
-#endif
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Get first free double vlan ai number */
 static int mv_pp2x_prs_double_vlan_ai_free_get(struct mv_pp2x_hw *hw)
 {
@@ -1384,9 +1368,7 @@ static int mv_pp2x_prs_double_vlan_ai_free_get(struct mv_pp2x_hw *hw)
 
 	return -EINVAL;
 }
-#endif
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Search for existing double vlan entry */
 static struct mv_pp2x_prs_entry *mv_pp2x_prs_double_vlan_find(
 	struct mv_pp2x_hw *hw, unsigned short tpid1, unsigned short tpid2)
@@ -1426,9 +1408,7 @@ static struct mv_pp2x_prs_entry *mv_pp2x_prs_double_vlan_find(
 
 	return NULL;
 }
-#endif
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Add or update double vlan entry */
 static int mv_pp2x_prs_double_vlan_add(struct mv_pp2x_hw *hw,
 				       unsigned short tpid1,
@@ -1510,7 +1490,6 @@ static int mv_pp2x_prs_double_vlan_add(struct mv_pp2x_hw *hw,
 	kfree(pe);
 	return ret;
 }
-#endif
 
 /* IPv4 header parsing for fragmentation and L4 offset */
 static int mv_pp2x_prs_ip4_proto(struct mv_pp2x_hw *hw, unsigned short proto,
@@ -1634,7 +1613,6 @@ static int mv_pp2x_prs_ip4_cast(struct mv_pp2x_hw *hw, unsigned short l3_cast)
 	return 0;
 }
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Set entries for protocols over IPv6  */
 static int mv_pp2x_prs_ip6_proto(struct mv_pp2x_hw *hw, unsigned short proto,
 				 unsigned int ri, unsigned int ri_mask)
@@ -1676,9 +1654,7 @@ static int mv_pp2x_prs_ip6_proto(struct mv_pp2x_hw *hw, unsigned short proto,
 
 	return 0;
 }
-#endif
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* IPv6 L3 multicast entry */
 static int mv_pp2x_prs_ip6_cast(struct mv_pp2x_hw *hw, unsigned short l3_cast)
 {
@@ -1718,7 +1694,6 @@ static int mv_pp2x_prs_ip6_cast(struct mv_pp2x_hw *hw, unsigned short l3_cast)
 
 	return 0;
 }
-#endif
 
 /* Parser per-port initialization */
 void mv_pp2x_prs_hw_port_init(struct mv_pp2x_hw *hw, int port, int lu_first,
@@ -1826,10 +1801,8 @@ static void mv_pp2x_prs_mac_init(struct mv_pp2x_hw *hw)
 	mv_pp2x_prs_mac_drop_all_set(hw, 0, false);
 	mv_pp2x_prs_mac_promisc_set(hw, 0, false);
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	mv_pp2x_prs_mac_multi_set(hw, MVPP2_PE_MAC_MC_ALL, 0, false);
 	mv_pp2x_prs_mac_multi_set(hw, MVPP2_PE_MAC_MC_IP6, 0, false);
-#endif
 }
 
 /* Set default entries for various types of dsa packets */
@@ -1837,7 +1810,6 @@ static void mv_pp2x_prs_dsa_init(struct mv_pp2x_hw *hw)
 {
 	struct mv_pp2x_prs_entry pe;
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	/* None tagged EDSA entry - place holder */
 	mv_pp2x_prs_dsa_tag_set(hw, 0, false, MVPP2_PRS_UNTAGGED,
 				MVPP2_PRS_EDSA);
@@ -1867,7 +1839,6 @@ static void mv_pp2x_prs_dsa_init(struct mv_pp2x_hw *hw)
 	/* Tagged DSA ethertype entry */
 	mv_pp2x_prs_dsa_tag_ethertype_set(hw, 0, true,
 					  MVPP2_PRS_TAGGED, MVPP2_PRS_DSA);
-#endif
 
 	/* Set default entry, in case DSA or EDSA tag not found */
 	memset(&pe, 0, sizeof(struct mv_pp2x_prs_entry));
@@ -1894,7 +1865,6 @@ static int mv_pp2x_prs_etype_init(struct mv_pp2x_hw *hw)
 	struct mv_pp2x_prs_entry pe;
 	int tid;
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	/* Ethertype: PPPoE */
 	tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_FIRST_FREE_TID,
 					  MVPP2_PE_LAST_FREE_TID);
@@ -1921,7 +1891,6 @@ static int mv_pp2x_prs_etype_init(struct mv_pp2x_hw *hw)
 				  MVPP2_PRS_RI_PPPOE_MASK);
 	mv_pp2x_prs_hw_write(hw, &pe);
 
-#endif
 	/* Ethertype: ARP */
 	tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_FIRST_FREE_TID,
 					  MVPP2_PE_LAST_FREE_TID);
@@ -1952,7 +1921,6 @@ static int mv_pp2x_prs_etype_init(struct mv_pp2x_hw *hw)
 				  MVPP2_PRS_RI_L3_PROTO_MASK);
 	mv_pp2x_prs_hw_write(hw, &pe);
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	/* Ethertype: LBTD */
 	tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_FIRST_FREE_TID,
 					  MVPP2_PE_LAST_FREE_TID);
@@ -1986,7 +1954,6 @@ static int mv_pp2x_prs_etype_init(struct mv_pp2x_hw *hw)
 				  MVPP2_PRS_RI_CPU_CODE_MASK |
 				  MVPP2_PRS_RI_UDF3_MASK);
 	mv_pp2x_prs_hw_write(hw, &pe);
-#endif
 
 	/* Ethertype: IPv4 without options */
 	tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_FIRST_FREE_TID,
@@ -2053,7 +2020,6 @@ static int mv_pp2x_prs_etype_init(struct mv_pp2x_hw *hw)
 	mv_pp2x_prs_shadow_ri_set(hw, pe.index, MVPP2_PRS_RI_L3_IP4_OPT,
 				  MVPP2_PRS_RI_L3_PROTO_MASK);
 	mv_pp2x_prs_hw_write(hw, &pe);
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 
 	/* Ethertype: IPv6 without options */
 	tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_FIRST_FREE_TID,
@@ -2111,7 +2077,6 @@ static int mv_pp2x_prs_etype_init(struct mv_pp2x_hw *hw)
 	mv_pp2x_prs_shadow_ri_set(hw, pe.index, MVPP2_PRS_RI_L3_UN,
 				  MVPP2_PRS_RI_L3_PROTO_MASK);
 	mv_pp2x_prs_hw_write(hw, &pe);
-#endif
 	return 0;
 }
 
@@ -2126,16 +2091,13 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 				 struct mv_pp2x_hw *hw)
 {
 	struct mv_pp2x_prs_entry pe;
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	int err;
-#endif
 
 	hw->prs_double_vlans = devm_kcalloc(&pdev->dev, sizeof(bool),
 					    MVPP2_PRS_DBL_VLANS_MAX,
 					    GFP_KERNEL);
 	if (!hw->prs_double_vlans)
 		return -ENOMEM;
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	/* Double VLAN: 0x8100, 0x88A8 */
 	err = mv_pp2x_prs_double_vlan_add(hw, ETH_P_8021Q, ETH_P_8021AD,
 					  MVPP2_PRS_PORT_MASK);
@@ -2179,7 +2141,7 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 	/* Update shadow table and hw entry */
 	mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_VLAN);
 	mv_pp2x_prs_hw_write(hw, &pe);
-#endif
+
 	/* Set default vlan none entry */
 	memset(&pe, 0, sizeof(struct mv_pp2x_prs_entry));
 	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VLAN);
@@ -2199,7 +2161,6 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 	return 0;
 }
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Set entries for PPPoE ethertype */
 static int mv_pp2x_prs_pppoe_init(struct mv_pp2x_hw *hw)
 {
@@ -2310,7 +2271,6 @@ static int mv_pp2x_prs_pppoe_init(struct mv_pp2x_hw *hw)
 
 	return 0;
 }
-#endif
 
 /* Initialize entries for IPv4 */
 static int mv_pp2x_prs_ip4_init(struct mv_pp2x_hw *hw)
@@ -2322,14 +2282,12 @@ static int mv_pp2x_prs_ip4_init(struct mv_pp2x_hw *hw)
 	err = mv_pp2x_prs_ip4_proto(hw, IPPROTO_TCP, MVPP2_PRS_RI_L4_TCP,
 				    MVPP2_PRS_RI_L4_PROTO_MASK);
 
-	PALAD(MVPP2_PRINT_LINE());
 	if (err)
 		return err;
 
 	err = mv_pp2x_prs_ip4_proto(hw, IPPROTO_UDP, MVPP2_PRS_RI_L4_UDP,
 				    MVPP2_PRS_RI_L4_PROTO_MASK);
 
-	PALAD(MVPP2_PRINT_LINE());
 	if (err)
 		return err;
 
@@ -2339,21 +2297,18 @@ static int mv_pp2x_prs_ip4_init(struct mv_pp2x_hw *hw)
 				    MVPP2_PRS_RI_CPU_CODE_MASK |
 				    MVPP2_PRS_RI_UDF3_MASK);
 
-	PALAD(MVPP2_PRINT_LINE());
 	if (err)
 		return err;
 
 	/* IPv4 Broadcast */
 	err = mv_pp2x_prs_ip4_cast(hw, MVPP2_PRS_L3_BROAD_CAST);
 
-	PALAD(MVPP2_PRINT_LINE());
 	if (err)
 		return err;
 
 	/* IPv4 Multicast */
 	err = mv_pp2x_prs_ip4_cast(hw, MVPP2_PRS_L3_MULTI_CAST);
 
-	PALAD(MVPP2_PRINT_LINE());
 	if (err)
 		return err;
 
@@ -2401,13 +2356,9 @@ static int mv_pp2x_prs_ip4_init(struct mv_pp2x_hw *hw)
 	/* Update shadow table and hw entry */
 	mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_IP4);
 	mv_pp2x_prs_hw_write(hw, &pe);
-
-	PALAD(MVPP2_PRINT_LINE());
-
 	return 0;
 }
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 /* Initialize entries for IPv6 */
 static int mv_pp2x_prs_ip6_init(struct mv_pp2x_hw *hw)
 {
@@ -2542,7 +2493,6 @@ static int mv_pp2x_prs_ip6_init(struct mv_pp2x_hw *hw)
 
 	return 0;
 }
-#endif
 
 /* Compare MAC DA with tcam entry data */
 static bool mv_pp2x_prs_mac_range_equals(struct mv_pp2x_prs_entry *pe,
@@ -2893,7 +2843,6 @@ int mv_pp2x_prs_flow_set(struct mv_pp2x_port *port)
 {
 	int index, ret;
 
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	for (index = 0; index < MVPP2_PRS_FL_TCAM_NUM; index++) {
 		ret = mv_pp2x_prs_flow_id_gen(port,
 			mv_pp2x_prs_flow_id_array[index].flow_id,
@@ -2902,28 +2851,6 @@ int mv_pp2x_prs_flow_set(struct mv_pp2x_port *port)
 		if (ret)
 			return ret;
 	}
-#else
-
-	index = MVPP2_PRS_FL_IP4_UNTAG_NO_OPV4_OPTIONS;
-	ret = mv_pp2x_prs_flow_id_gen(port,
-			mv_pp2x_prs_flow_id_array[index].flow_id,
-			mv_pp2x_prs_flow_id_array[index].prs_result.ri,
-			mv_pp2x_prs_flow_id_array[index].prs_result.ri_mask);
-	if (ret)
-		return ret;
-
-	MVPP2_PRINT_LINE();
-
-	index = MVPP2_PRS_FL_NON_IP_UNTAG_INDEX;
-	ret = mv_pp2x_prs_flow_id_gen(port,
-			mv_pp2x_prs_flow_id_array[index].flow_id,
-			mv_pp2x_prs_flow_id_array[index].prs_result.ri,
-			mv_pp2x_prs_flow_id_array[index].prs_result.ri_mask);
-	if (ret)
-		return ret;
-
-	MVPP2_PRINT_LINE();
-#endif
 	return 0;
 }
 
@@ -3212,7 +3139,6 @@ void mv_pp2x_cls_flow_tbl_config(struct mv_pp2x_hw *hw)
 	struct mv_pp2x_cls_flow_entry fe;
 
 	for (lkpid = MVPP2_PRS_FL_START; lkpid < MVPP2_PRS_FL_LAST; lkpid++) {
-		PALAD(MVPP2_PRINT_LINE());
 		/* Get lookup id attribute */
 		lkpid_attr = mv_pp2x_prs_flow_id_attr_get(lkpid);
 		/* Default rss hash is based on 5T */
@@ -3372,7 +3298,6 @@ void mv_pp2x_cls_lookup_tbl_config(struct mv_pp2x_hw *hw)
 	for (index = 0; index < (MVPP2_PRS_FL_LAST - MVPP2_PRS_FL_START);
 		index++) {
 		flow_info = &(hw->cls_shadow->flow_info[index]);
-		PALAD(MVPP2_PRINT_LINE());
 		data[0] = MVPP2_FLOW_TBL_SIZE;
 		data[1] = MVPP2_FLOW_TBL_SIZE;
 		data[2] = MVPP2_FLOW_TBL_SIZE;
@@ -3415,21 +3340,17 @@ int mv_pp2x_cls_init(struct platform_device *pdev, struct mv_pp2x_hw *hw)
 
 	/* Enable classifier */
 	mv_pp2x_write(hw, MVPP2_CLS_MODE_REG, MVPP2_CLS_MODE_ACTIVE_MASK);
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Clear classifier flow table */
 	memset(&fe.data, 0, MVPP2_CLS_FLOWS_TBL_DATA_WORDS);
 	for (index = 0; index < MVPP2_CLS_FLOWS_TBL_SIZE; index++) {
-		PALAD(MVPP2_PRINT_LINE());
 		fe.index = index;
 		mv_pp2x_cls_flow_write(hw, &fe);
 	}
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Clear classifier lookup table */
 	le.data = 0;
 	for (index = 0; index < MVPP2_CLS_LKP_TBL_SIZE; index++) {
-		PALAD(MVPP2_PRINT_LINE());
 		le.lkpid = index;
 		le.way = 0;
 		mv_pp2x_cls_lookup_write(hw, &le);
@@ -3437,14 +3358,12 @@ int mv_pp2x_cls_init(struct platform_device *pdev, struct mv_pp2x_hw *hw)
 		le.way = 1;
 		mv_pp2x_cls_lookup_write(hw, &le);
 	}
-	PALAD(MVPP2_PRINT_LINE());
 
 	hw->cls_shadow = devm_kcalloc(&pdev->dev, 1,
 				      sizeof(struct mv_pp2x_cls_shadow),
 				      GFP_KERNEL);
 	if (!hw->cls_shadow)
 		return -ENOMEM;
-	PALAD(MVPP2_PRINT_LINE());
 
 	hw->cls_shadow->flow_info = devm_kcalloc(&pdev->dev,
 				(MVPP2_PRS_FL_LAST - MVPP2_PRS_FL_START),
@@ -3460,18 +3379,13 @@ int mv_pp2x_cls_init(struct platform_device *pdev, struct mv_pp2x_hw *hw)
 		index++)
 		hw->cls_shadow->flow_info[index].lkpid = index +
 			MVPP2_PRS_FL_START;
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Init flow table */
 	mv_pp2x_cls_flow_tbl_config(hw);
 
-	PALAD(MVPP2_PRINT_LINE());
-
 	/* Init lookup table */
 	mv_pp2x_cls_lookup_tbl_config(hw);
 
-	PALAD(MVPP2_PRINT_LINE());
-
 	return 0;
 }
 
@@ -3637,7 +3551,6 @@ void mv_pp2x_tx_done_time_coal_set(struct mv_pp2x_port *port, u32 usec)
 /* Change maximum receive size of the port */
 void mv_pp21_gmac_max_rx_size_set(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
@@ -3645,7 +3558,6 @@ void mv_pp21_gmac_max_rx_size_set(struct mv_pp2x_port *port)
 	val |= (((port->pkt_size - MVPP2_MH_SIZE) / 2) <<
 		MVPP2_GMAC_MAX_RX_SIZE_OFFS);
 	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
-#endif
 }
 
 /* Set max sizes for Tx queues */
@@ -3835,7 +3747,6 @@ void mv_pp2x_rxq_offset_set(struct mv_pp2x_port *port,
 
 void mv_pp21_port_mii_set(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_2_REG);
@@ -3851,62 +3762,49 @@ void mv_pp21_port_mii_set(struct mv_pp2x_port *port)
 	}
 
 	writel(val, port->base + MVPP2_GMAC_CTRL_2_REG);
-#endif
 }
 
 void mv_pp21_port_fc_adv_enable(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 	val |= MVPP2_GMAC_FC_ADV_EN;
 	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
-#endif
 }
 
 void mv_pp21_port_enable(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
 	val |= MVPP2_GMAC_PORT_EN_MASK;
 	val |= MVPP2_GMAC_MIB_CNTR_EN_MASK;
 	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
-#endif
 }
 
 void mv_pp21_port_disable(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
-
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
 	val &= ~(MVPP2_GMAC_PORT_EN_MASK);
 	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
-#endif
 }
 
 /* Set IEEE 802.3x Flow Control Xon Packet Transmission Mode */
 void mv_pp21_port_periodic_xon_disable(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
-
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_1_REG) &
 		    ~MVPP2_GMAC_PERIODIC_XON_EN_MASK;
 	writel(val, port->base + MVPP2_GMAC_CTRL_1_REG);
-#endif
 }
 
 /* Configure loopback port */
 void mv_pp21_port_loopback_set(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
-
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_1_REG);
@@ -3922,13 +3820,10 @@ void mv_pp21_port_loopback_set(struct mv_pp2x_port *port)
 		val &= ~MVPP2_GMAC_PCS_LB_EN_MASK;
 
 	writel(val, port->base + MVPP2_GMAC_CTRL_1_REG);
-#endif
 }
 
 void mv_pp21_port_reset(struct mv_pp2x_port *port)
 {
-#ifndef CONFIG_MV_PP2_PALLADIUM
-
 	u32 val;
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_2_REG) &
@@ -3938,7 +3833,6 @@ void mv_pp21_port_reset(struct mv_pp2x_port *port)
 	while (readl(port->base + MVPP2_GMAC_CTRL_2_REG) &
 	       MVPP2_GMAC_PORT_RESET_MASK)
 		continue;
-#endif
 }
 
 /* Refill BM pool */
@@ -4113,14 +4007,11 @@ int mv_pp2x_prs_default_init(struct platform_device *pdev,
 {
 	int err, index, i;
 
-	PALAD(MVPP2_PRINT_LINE());
-
 	/* Enable tcam table */
 	mv_pp2x_write(hw, MVPP2_PRS_TCAM_CTRL_REG, MVPP2_PRS_TCAM_EN_MASK);
 
 	/* Clear all tcam and sram entries */
 	for (index = 0; index < MVPP2_PRS_TCAM_SRAM_SIZE; index++) {
-		PALAD(MVPP2_PRINT_LINE());
 		mv_pp2x_write(hw, MVPP2_PRS_TCAM_IDX_REG, index);
 		for (i = 0; i < MVPP2_PRS_TCAM_WORDS; i++)
 			mv_pp2x_write(hw, MVPP2_PRS_TCAM_DATA_REG(i), 0);
@@ -4129,52 +4020,39 @@ int mv_pp2x_prs_default_init(struct platform_device *pdev,
 		for (i = 0; i < MVPP2_PRS_SRAM_WORDS; i++)
 			mv_pp2x_write(hw, MVPP2_PRS_SRAM_DATA_REG(i), 0);
 	}
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Invalidate all tcam entries */
 	for (index = 0; index < MVPP2_PRS_TCAM_SRAM_SIZE; index++) {
-		PALAD(MVPP2_PRINT_LINE());
 		mv_pp2x_prs_hw_inv(hw, index);
 	}
-	PALAD(MVPP2_PRINT_LINE());
 
 	hw->prs_shadow = devm_kcalloc(&pdev->dev, MVPP2_PRS_TCAM_SRAM_SIZE,
 				      sizeof(struct mv_pp2x_prs_shadow),
 				      GFP_KERNEL);
-	PALAD(MVPP2_PRINT_LINE());
 
 	if (!hw->prs_shadow)
 		return -ENOMEM;
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Always start from lookup = 0 */
 	for (index = 0; index < MVPP2_MAX_PORTS; index++)
 		mv_pp2x_prs_hw_port_init(hw, index, MVPP2_PRS_LU_MH,
 					 MVPP2_PRS_PORT_LU_MAX, 0);
-	PALAD(MVPP2_PRINT_LINE());
 
 	mv_pp2x_prs_def_flow_init(hw);
-	PALAD(MVPP2_PRINT_LINE());
 
 	mv_pp2x_prs_mh_init(hw);
-	PALAD(MVPP2_PRINT_LINE());
 
 	mv_pp2x_prs_mac_init(hw);
-	PALAD(MVPP2_PRINT_LINE());
 
 	mv_pp2x_prs_dsa_init(hw);
-	PALAD(MVPP2_PRINT_LINE());
 
 	err = mv_pp2x_prs_etype_init(hw);
 	if (err)
 		return err;
-	PALAD(MVPP2_PRINT_LINE());
 
 	err = mv_pp2x_prs_vlan_init(pdev, hw);
 	if (err)
 		return err;
-	PALAD(MVPP2_PRINT_LINE());
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	err = mv_pp2x_prs_pppoe_init(hw);
 	if (err)
 		return err;
@@ -4182,12 +4060,10 @@ int mv_pp2x_prs_default_init(struct platform_device *pdev,
 	err = mv_pp2x_prs_ip6_init(hw);
 	if (err)
 		return err;
-#endif
 
 	err = mv_pp2x_prs_ip4_init(hw);
 	if (err)
 		return err;
-	PALAD(MVPP2_PRINT_LINE());
 	return 0;
 }
 
@@ -5849,7 +5725,6 @@ void mv_pp2x_cls_c2_hw_inv_all(struct mv_pp2x_hw *hw)
 	int index;
 
 	for (index = 0; index < MVPP2_CLS_C2_TCAM_SIZE; index++) {
-		PALAD(MVPP2_PRINT_LINE());
 		mv_pp2x_cls_c2_hw_inv(hw, index);
 	}
 }
@@ -5868,7 +5743,6 @@ static void mv_pp2x_cls_c2_qos_hw_clear_all(struct mv_pp2x_hw *hw)
 		for (qos.tbl_line = 0; qos.tbl_line <
 			MVPP2_QOS_TBL_LINE_NUM_DSCP; qos.tbl_line++) {
 			mv_pp2x_cls_c2_qos_hw_write(hw, &qos);
-			PALAD(MVPP2_PRINT_LINE());
 		}
 	}
 
@@ -5878,7 +5752,6 @@ static void mv_pp2x_cls_c2_qos_hw_clear_all(struct mv_pp2x_hw *hw)
 		MVPP2_QOS_TBL_NUM_PRI; qos.tbl_id++)
 		for (qos.tbl_line = 0; qos.tbl_line <
 			MVPP2_QOS_TBL_LINE_NUM_PRI; qos.tbl_line++) {
-			PALAD(MVPP2_PRINT_LINE());
 			mv_pp2x_cls_c2_qos_hw_write(hw, &qos);
 		}
 }
@@ -6234,15 +6107,12 @@ int mv_pp2x_c2_init(struct platform_device *pdev, struct mv_pp2x_hw *hw)
 
 	/* Invalid all C2 and QoS entries */
 	mv_pp2x_cls_c2_hw_inv_all(hw);
-	PALAD(MVPP2_PRINT_LINE());
 
 	mv_pp2x_cls_c2_qos_hw_clear_all(hw);
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Set CLSC2_TCAM_CTRL to enable C2, or C2 does not work */
 	mv_pp2x_write(hw, MVPP2_CLS2_TCAM_CTRL_REG,
 		      MVPP2_CLS2_TCAM_CTRL_EN_MASK);
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Allocate mem for c2 shadow */
 	hw->c2_shadow = devm_kcalloc(&pdev->dev, 1,
@@ -6250,7 +6120,6 @@ int mv_pp2x_c2_init(struct platform_device *pdev, struct mv_pp2x_hw *hw)
 				      GFP_KERNEL);
 	if (!hw->c2_shadow)
 		return -ENOMEM;
-	PALAD(MVPP2_PRINT_LINE());
 
 	/* Init the rule idx to invalid value */
 	for (i = 0; i < 8; i++) {
@@ -6262,7 +6131,6 @@ int mv_pp2x_c2_init(struct platform_device *pdev, struct mv_pp2x_hw *hw)
 			MVPP2_CLS_C2_TCAM_SIZE;
 	}
 	hw->c2_shadow->c2_tcam_free_start = 0;
-	PALAD(MVPP2_PRINT_LINE());
 
 	return 0;
 }
@@ -6370,7 +6238,6 @@ static void mv_pp2x_cls_c2_qos_tbl_fill(struct mv_pp2x_port *port,
 		 */
 		queue = start_queue + cos_queue;
 		mv_pp2x_cls_c2_qos_queue_set(&qos_entry, queue);
-		PALAD(MVPP2_PRINT_LINE());
 		mv_pp2x_cls_c2_qos_hw_write(&port->priv->hw, &qos_entry);
 	}
 }
@@ -6456,7 +6323,6 @@ int mv_pp2x_cls_c2_rule_set(struct mv_pp2x_port *port, u8 start_queue)
 		c2_init_entry.rss_en = port->priv->pp2_cfg.rss_cfg.rss_en;
 
 		/* Add rule to C2 TCAM */
-		PALAD(MVPP2_PRINT_LINE());
 		ret = mv_pp2x_c2_rule_add(port, &c2_init_entry);
 		if (ret)
 			return ret;
@@ -6669,7 +6535,6 @@ int mv_pp22_rss_rxq_set(struct mv_pp2x_port *port, u32 cos_width)
 	rss_entry.sel = MVPP22_RSS_ACCESS_POINTER;
 
 	for (rxq = 0; rxq < port->num_rx_queues; rxq++) {
-		PALAD(MVPP2_PRINT_LINE());
 		rss_entry.u.pointer.rxq_idx = port->rxqs[rxq]->id;
 		rss_entry.u.pointer.rss_tbl_ptr =
 				port->rxqs[rxq]->id & cos_mask;
@@ -6694,7 +6559,6 @@ void mv_pp22_rss_c2_enable(struct mv_pp2x_port *port, bool en)
 	c2_index[MVPP2_CLS_LKP_DEFAULT] = rule_idx->default_rule_idx;
 
 	for (lkp_type = 0; lkp_type < MVPP2_CLS_LKP_MAX; lkp_type++) {
-		PALAD(MVPP2_PRINT_LINE());
 		/* For lookup type of MVPP2_CLS_LKP_HASH,
 		 * there is no corresponding C2 rule, so skip it
 		 */
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index cd2ddf5..7425e48 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1270,11 +1270,7 @@ enum mv_pp2x_tag_type {
 };
 
 /* Parser constants */
-#ifdef CONFIG_MV_PP2_PALLADIUM
-#define MVPP2_PRS_TCAM_SRAM_SIZE	32
-#else
 #define MVPP2_PRS_TCAM_SRAM_SIZE	256
-#endif
 #define MVPP2_PRS_TCAM_WORDS		6
 #define MVPP2_PRS_SRAM_WORDS		4
 #define MVPP2_PRS_FLOW_ID_SIZE		64
@@ -1314,7 +1310,6 @@ enum mv_pp2x_tag_type {
 #define MVPP2_PRS_TCAM_INV_MASK			BIT(31)
 
 /* Tcam entries ID */
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 #define MVPP2_PE_DROP_ALL		0
 #define MVPP2_PE_FIRST_FREE_TID		1
 #define MVPP2_PE_LAST_FREE_TID		(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
@@ -1342,40 +1337,6 @@ enum mv_pp2x_tag_type {
 #define MVPP2_PE_MAC_MC_ALL		(MVPP2_PRS_TCAM_SRAM_SIZE - 3)
 #define MVPP2_PE_MAC_PROMISCUOUS	(MVPP2_PRS_TCAM_SRAM_SIZE - 2)
 #define MVPP2_PE_MAC_NON_PROMISCUOUS	(MVPP2_PRS_TCAM_SRAM_SIZE - 1)
-#else
-#define MVPP2_PE_DROP_ALL		0
-#define MVPP2_PE_FIRST_FREE_TID		1
-#define MVPP2_PE_LAST_FREE_TID		(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
-
-#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
-#define MVPP2_PE_IP4_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
-
-#define MVPP2_PE_LAST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
-#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
-#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
-#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
-#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 5)
-#define MVPP2_PE_VLAN_NONE		(MVPP2_PRS_TCAM_SRAM_SIZE - 4)
-#define MVPP2_PE_MAC_PROMISCUOUS	(MVPP2_PRS_TCAM_SRAM_SIZE - 3)
-#define MVPP2_PE_MAC_NON_PROMISCUOUS	(MVPP2_PRS_TCAM_SRAM_SIZE - 2)
-#define MVPP2_PE_PALLADIUM_DUMMY_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 1)
-
-#define MVPP2_PE_IP6_EXT_PROTO_UN	(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_MAC_MC_IP6		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_IP6_ADDR_UN		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_DSA_TAGGED		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_VLAN_DBL		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-#define MVPP2_PE_MAC_MC_ALL		(MVPP2_PE_PALLADIUM_DUMMY_FLOW)
-
-#endif
 
 /* Sram structure
  * The fields are represented by MVPP2_PRS_TCAM_DATA_REG(3)->(0).
@@ -2006,11 +1967,7 @@ struct mv_pp2x_cls_shadow {
 /* Classifier engine2 and QoS structure */
 
 /* C2  constants */
-#ifdef CONFIG_MV_PP2_PALLADIUM
-#define MVPP2_CLS_C2_TCAM_SIZE			32
-#else
 #define MVPP2_CLS_C2_TCAM_SIZE			256
-#endif
 #define MVPP2_CLS_C2_TCAM_WORDS			5
 #define MVPP2_CLS_C2_TCAM_DATA_BYTES		10
 #define MVPP2_CLS_C2_SRAM_WORDS			5
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 329d105..dfcd039 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -47,9 +47,6 @@
 #include <asm/cacheflush.h>
 #include <linux/dma-mapping.h>
 
-#ifdef CONFIG_MV_PP2_FPGA
-#include <linux/pci.h>
-#endif
 #include "mv_pp2x.h"
 #include "mv_pp2x_hw.h"
 #include "mv_gop110_hw.h"
@@ -69,8 +66,12 @@
 static u8 rss_mode;
 static u8 default_cpu;
 static u8 cos_classifer;
-static u32 pri_map = 0x3210; /* As default, cos0--rxq0, cos1--rxq1, cos2--rxq2, cos3--rxq3 */
-static u8 default_cos = 3; /* As default, non-IP packet has the highest CoS value */
+static u32 pri_map = 0x3210; /* As default, cos0--rxq0, cos1--rxq1,
+			      * cos2--rxq2, cos3--rxq3
+			      */
+static u8 default_cos = 3; /* As default, non-IP packet has the
+			    * highest CoS value
+			    */
 static bool jumbo_pool;
 static u16 rx_queue_size = MVPP2_MAX_RXD;
 static u16 tx_queue_size = MVPP2_MAX_TXD;
@@ -83,22 +84,8 @@
 u32 debug_param;
 
 #if defined(CONFIG_MV_PP2_POLLING)
-#ifdef CONFIG_MV_PP2_PALLADIUM
-#define MV_PP2_FPGA_PERODIC_TIME 2
-#else
 #define MV_PP2_FPGA_PERODIC_TIME 100
 #endif
-#endif
-#ifdef CONFIG_MV_PP2_FPGA
-#define MAC_PORT0_OFFSET       0x104000
-#endif
-#ifdef CONFIG_MV_PP2_PALLADIUM
-#define MAC_PORT0_OFFSET       0x130E00
-#endif
-
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-void *mv_pp2_vfpga_address;
-#endif
 
 #if defined(CONFIG_MV_PP2_POLLING)
 struct timer_list cpu_poll_timer;
@@ -182,13 +169,6 @@ struct mv_pp2x_pool_attributes mv_pp2x_pools[] = {
 	}
 };
 
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-void *mv_pp2x_vfpga_address_get(void)
-{
-	return mv_pp2_vfpga_address;
-}
-#endif
-
 static inline int mv_pp2x_txq_count(struct mv_pp2x_txq_pcpu *txq_pcpu)
 {
 
@@ -350,8 +330,8 @@ static int mv_pp2x_bm_pool_create(struct device *dev,
 
 	bm_pool->size = size;
 	bm_pool->pkt_size = mv_pp2x_pool_pkt_size_get(bm_pool->log_id);
-	bm_pool->frag_size = SKB_DATA_ALIGN(MVPP2_RX_BUF_SIZE(bm_pool->pkt_size)) +
-				MVPP2_SKB_SHINFO_SIZE;
+	bm_pool->frag_size = SKB_DATA_ALIGN(MVPP2_RX_BUF_SIZE(
+				bm_pool->pkt_size)) + MVPP2_SKB_SHINFO_SIZE;
 	bm_pool->buf_num = 0;
 	mv_pp2x_bm_pool_bufsize_set(hw, bm_pool,
 				    MVPP2_RX_BUF_SIZE(bm_pool->pkt_size));
@@ -391,8 +371,8 @@ void mv_pp2x_bm_bufs_free(struct mv_pp2x *priv, struct mv_pp2x_bm_pool *bm_pool,
 			break;
 		if (is_skb) {
 #ifdef CONFIG_64BIT
-			dev_kfree_skb_any(
-				(struct sk_buff *)(priv->pp2xdata->skb_base_addr |
+			dev_kfree_skb_any((struct sk_buff *)
+				(priv->pp2xdata->skb_base_addr |
 				(uintptr_t)vaddr));
 #else
 			dev_kfree_skb_any(vaddr);
@@ -404,7 +384,6 @@ void mv_pp2x_bm_bufs_free(struct mv_pp2x *priv, struct mv_pp2x_bm_pool *bm_pool,
 	bm_pool->buf_num -= i;
 }
 
-
 /* Cleanup pool */
 int mv_pp2x_bm_pool_destroy(struct device *dev, struct mv_pp2x *priv,
 			   struct mv_pp2x_bm_pool *bm_pool, bool is_skb)
@@ -745,15 +724,6 @@ static void mv_pp2x_defaults_set(struct mv_pp2x_port *port)
 			mv_pp21_port_loopback_set(port);
 	}
 
-#ifdef CONFIG_MV_PP2_FPGA
-	writel(0x8be4, port->base);
-	writel(0xc200, port->base + 0x8);
-	writel(0x3, port->base + 0x90);
-
-	writel(0x902A, port->base + 0xC);    /*force link to 100Mb*/
-	writel(0x8be5, port->base);          /*enable port        */
-#endif
-
 	/* Disable Legacy WRR, Disable EJP, Release from reset */
 	tx_port_num = mv_pp2x_egress_port(port);
 	mv_pp2x_write(hw, MVPP2_TXP_SCHED_PORT_INDEX_REG,
@@ -821,7 +791,8 @@ int mv_pp2x_txq_reserved_desc_num_proc(
 	 * count and check again.
 	 */
 
-	/* Entire txq_size is used for SWF . Must be changed when HWF is implemented.
+	/* Entire txq_size is used for SWF . Must be changed when HWF
+	 * is implemented.
 	 * There will always be at least one CHUNK available
 	 */
 
@@ -942,7 +913,6 @@ static unsigned int mv_pp2x_tx_done(struct mv_pp2x_port *port, u32 cause,
 	return tx_todo;
 }
 
-
 /* Rx/Tx queue initialization/cleanup methods */
 
 /* Allocate and initialize descriptors for aggr TXQ */
@@ -1434,8 +1404,10 @@ int mv_pp2x_setup_irqs(struct net_device *dev, struct mv_pp2x_port *port)
 		if (qvec->qv_type == MVPP2_PRIVATE) {
 			cpu = QV_THR_2_CPU(qvec->sw_thread_id);
 			irq_set_affinity_hint(qvec->irq, cpumask_of(cpu));
-			if (port->priv->pp2_cfg.queue_mode == MVPP2_QDIST_MULTI_MODE)
-				irq_set_status_flags(qvec->irq, IRQ_NO_BALANCING);
+			if (port->priv->pp2_cfg.queue_mode ==
+				MVPP2_QDIST_MULTI_MODE)
+				irq_set_status_flags(qvec->irq,
+						     IRQ_NO_BALANCING);
 		}
 		if (err) {
 			netdev_err(dev, "cannot request IRQ %d\n",
@@ -1494,7 +1466,6 @@ static void mv_pp22_dev_link_event(struct net_device *dev)
 }
 
 /* Called from phy_lib */
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 static void mv_pp21_link_event(struct net_device *dev)
 {
 	struct mv_pp2x_port *port = netdev_priv(dev);
@@ -1557,7 +1528,6 @@ static void mv_pp21_link_event(struct net_device *dev)
 		phy_print_status(phydev);
 	}
 }
-#endif
 
 void mv_pp2_link_change_tasklet(unsigned long data)
 {
@@ -1576,21 +1546,13 @@ void mv_pp2_link_change_tasklet(unsigned long data)
 
 static void mv_pp2x_timer_set(struct mv_pp2x_port_pcpu *port_pcpu)
 {
-#if !defined(CONFIG_MV_PP2_PALLADIUM)
 	ktime_t interval;
-#endif
 
 	if (!port_pcpu->timer_scheduled) {
 		port_pcpu->timer_scheduled = true;
-#ifdef CONFIG_MV_PP2_PALLADIUM
-		 /*CONFIG_HZ=20*/
-		mod_timer(&port_pcpu->slow_tx_done_timer,
-			  jiffies + msecs_to_jiffies(MV_PP2_FPGA_PERODIC_TIME));
-#else
 		interval = ktime_set(0, MVPP2_TXDONE_HRTIMER_PERIOD_NS);
 		hrtimer_start(&port_pcpu->tx_done_timer, interval,
 			      HRTIMER_MODE_REL_PINNED);
-#endif
 	}
 }
 
@@ -1614,14 +1576,6 @@ static void mv_pp2x_tx_proc_cb(unsigned long data)
 		mv_pp2x_timer_set(port_pcpu);
 }
 
-#ifdef CONFIG_MV_PP2_PALLADIUM
-void  mv_pp2x_timer_cb(unsigned long data)
-{
-	struct mv_pp2x_port_pcpu *port_pcpu = (struct mv_pp2x_port_pcpu *) data;
-
-	tasklet_schedule(&port_pcpu->tx_done_tasklet);
-}
-#else
 static enum hrtimer_restart mv_pp2x_hr_timer_cb(struct hrtimer *timer)
 {
 	struct mv_pp2x_port_pcpu *port_pcpu = container_of(timer,
@@ -1631,10 +1585,6 @@ static enum hrtimer_restart mv_pp2x_hr_timer_cb(struct hrtimer *timer)
 
 	return HRTIMER_NORESTART;
 }
-#endif
-
-
-
 
 /* The function get the number of cpu online */
 static inline int mv_pp2x_num_online_cpu_get(struct mv_pp2x *pp2)
@@ -1670,7 +1620,6 @@ static inline void mv_pp2x_width_calc(struct mv_pp2x *pp2, u32 *cpu_width,
 	}
 }
 
-
 /* CoS API */
 
 /* mv_pp2x_cos_classifier_set
@@ -2244,14 +2193,16 @@ static int mv_pp2x_rx(struct mv_pp2x_port *port, struct napi_struct *napi,
 			continue;
 		}
 
-		skb = build_skb(data, bm_pool->frag_size > PAGE_SIZE ? 0 : bm_pool->frag_size);
+		skb = build_skb(data, bm_pool->frag_size > PAGE_SIZE ? 0 :
+				bm_pool->frag_size);
 		if (!skb) {
 			pr_err("skb build failed\n");
 			goto err_drop_frame;
 		}
 
 		dma_unmap_single(dev->dev.parent, buf_phys_addr,
-				 MVPP2_RX_BUF_SIZE(bm_pool->pkt_size), DMA_FROM_DEVICE);
+				 MVPP2_RX_BUF_SIZE(bm_pool->pkt_size),
+				 DMA_FROM_DEVICE);
 
 		atomic_inc(&bm_pool->in_use);
 		refill_array[bm_pool->log_id]++;
@@ -2592,8 +2543,6 @@ static inline int mv_pp2x_cause_rx_handle(struct mv_pp2x_port *port,
 	return rx_done;
 }
 
-
-
 static int mv_pp21_poll(struct napi_struct *napi, int budget)
 {
 	u32 cause_rx_tx, cause_rx;
@@ -2629,7 +2578,6 @@ static int mv_pp21_poll(struct napi_struct *napi, int budget)
 	return rx_done;
 }
 
-
 static int mv_pp22_poll(struct napi_struct *napi, int budget)
 {
 	u32 cause_rx_tx, cause_rx, cause_tx;
@@ -2661,7 +2609,6 @@ static int mv_pp22_poll(struct napi_struct *napi, int budget)
 		mv_pp2x_tx_done(port, cause_tx, txq_cpu);
 	}
 
-
 	/* Process RX packets */
 	cause_rx = cause_rx_tx & MVPP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK;
 	/*Convert queues from subgroup-relative to port-relative */
@@ -2697,7 +2644,6 @@ static inline void mv_pp2x_port_irqs_dispose_mapping(struct mv_pp2x_port *port)
 		irq_dispose_mapping(port->of_irqs[i]);
 }
 
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 static int mvcpn110_mac_hw_init(struct mv_pp2x_port *port)
 {
 
@@ -2720,7 +2666,6 @@ static int mvcpn110_mac_hw_init(struct mv_pp2x_port *port)
 
 	return 0;
 }
-#endif
 
 /* Set hw internals when starting port */
 void mv_pp2x_start_dev(struct mv_pp2x_port *port)
@@ -2738,19 +2683,21 @@ void mv_pp2x_start_dev(struct mv_pp2x_port *port)
 				__func__);
 	}
 #endif /* DEV_NETMAP */
-	if (FPGA || port->priv->pp2_version == PPV21)
+	if (port->priv->pp2_version == PPV21)
 		mv_pp21_gmac_max_rx_size_set(port);
 	else {
 		switch (mac->phy_mode) {
 		case PHY_INTERFACE_MODE_RGMII:
 		case PHY_INTERFACE_MODE_SGMII:
 		case PHY_INTERFACE_MODE_QSGMII:
-			mv_gop110_gmac_max_rx_size_set(gop, mac_num, port->pkt_size);
+			mv_gop110_gmac_max_rx_size_set(gop, mac_num,
+					port->pkt_size);
 		break;
 		case PHY_INTERFACE_MODE_XAUI:
 		case PHY_INTERFACE_MODE_RXAUI:
 		case PHY_INTERFACE_MODE_KR:
-			mv_gop110_xlg_mac_max_rx_size_set(gop, mac_num, port->pkt_size);
+			mv_gop110_xlg_mac_max_rx_size_set(gop,
+					mac_num, port->pkt_size);
 		break;
 		default:
 		break;
@@ -2765,22 +2712,16 @@ void mv_pp2x_start_dev(struct mv_pp2x_port *port)
 	mv_pp2x_port_interrupts_enable(port);
 #endif
 
-	if (FPGA || port->priv->pp2_version == PPV21) {
+	if (port->priv->pp2_version == PPV21) {
 		mv_pp21_port_enable(port);
 	} else {
 		mv_gop110_port_events_mask(gop, mac);
 		mv_gop110_port_enable(gop, mac);
 	}
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	if (port->mac_data.phy_dev)
 		phy_start(port->mac_data.phy_dev);
 	else
 		mv_pp22_dev_link_event(port->dev);
-#else
-	if (!netif_carrier_ok(port->dev))
-		netif_carrier_on(port->dev);
-	netif_tx_start_all_queues(port->dev);
-#endif
 
 	tasklet_init(&port->link_change_tasklet, mv_pp2_link_change_tasklet,
 		(unsigned long)(port->dev));
@@ -2815,7 +2756,7 @@ void mv_pp2x_stop_dev(struct mv_pp2x_port *port)
 	netif_tx_stop_all_queues(port->dev);
 
 	mv_pp2x_egress_disable(port);
-	if (FPGA || port->priv->pp2_version == PPV21) {
+	if (port->priv->pp2_version == PPV21) {
 		mv_pp21_port_disable(port);
 	} else {
 		mv_gop110_port_events_mask(gop, mac);
@@ -2824,11 +2765,8 @@ void mv_pp2x_stop_dev(struct mv_pp2x_port *port)
 		tasklet_kill(&port->link_change_tasklet);
 	}
 
-
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	if (port->mac_data.phy_dev)
 		phy_stop(port->mac_data.phy_dev);
-#endif
 }
 
 /* Return positive if MTU is valid */
@@ -2887,8 +2825,6 @@ int mv_pp2x_check_ringparam_valid(struct net_device *dev,
 	return 0;
 }
 
-
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 static int mv_pp2x_phy_connect(struct mv_pp2x_port *port)
 {
 	struct phy_device *phy_dev;
@@ -2917,7 +2853,6 @@ static void mv_pp2x_phy_disconnect(struct mv_pp2x_port *port)
 		port->mac_data.phy_dev = NULL;
 	}
 }
-#endif
 
 int mv_pp2x_open_cls(struct net_device *dev)
 {
@@ -3020,9 +2955,8 @@ int mv_pp2x_open_cls(struct net_device *dev)
 	}
 
 	return 0;
-
-
 }
+
 int mv_pp2x_open(struct net_device *dev)
 {
 	struct mv_pp2x_port *port = netdev_priv(dev);
@@ -3050,7 +2984,6 @@ int mv_pp2x_open(struct net_device *dev)
 	/* In default link is down */
 	netif_carrier_off(port->dev);
 
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	/*FIXME: Should check which gop_version
 	 * (better, gop_version_attr: support_phy_connect), not the pp_version
 	 */
@@ -3059,7 +2992,6 @@ int mv_pp2x_open(struct net_device *dev)
 		if (err < 0)
 			goto err_free_irq;
 	}
-#endif
 
 #if !defined(CONFIG_MV_PP2_POLLING)
 
@@ -3078,20 +3010,15 @@ int mv_pp2x_open(struct net_device *dev)
 		cpu_poll_timer_ref_cnt++;
 	}
 #endif
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	/* Port is init in uboot */
 
 	if (port->priv->pp2_version == PPV22)
 		mvcpn110_mac_hw_init(port);
-#endif
 	mv_pp2x_start_dev(port);
 
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-	netif_carrier_on(port->dev);
-	netif_tx_start_all_queues(port->dev);
-
-#endif
-	/* Before rxq and port init, all ingress packets should be blocked in classifier */
+	/* Before rxq and port init, all ingress packets should be blocked
+	 *  in classifier
+	 */
 	err = mv_pp2x_open_cls(dev);
 	if (err)
 		goto err_free_all;
@@ -3100,10 +3027,8 @@ int mv_pp2x_open(struct net_device *dev)
 	return 0;
 
 err_free_all:
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 err_free_irq:
 	mv_pp2x_cleanup_irqs(port);
-#endif
 #if !defined(CONFIG_MV_PP2_POLLING)
 err_cleanup_txqs:
 	mv_pp2x_cleanup_txqs(port);
@@ -3128,10 +3053,9 @@ int mv_pp2x_stop(struct net_device *dev)
 #endif
 	mv_pp2x_stop_dev(port);
 
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	if (port->priv->pp2_version == PPV21)
 		mv_pp2x_phy_disconnect(port);
-#endif
+
 #if !defined(CONFIG_MV_PP2_POLLING)
 	/* Mask interrupts on all CPUs */
 	on_each_cpu(mv_pp2x_interrupts_mask, port, 1);
@@ -3143,11 +3067,7 @@ int mv_pp2x_stop(struct net_device *dev)
 	if (port->priv->pp2xdata->interrupt_tx_done == false) {
 		for_each_online_cpu(cpu) {
 			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
-#ifdef CONFIG_MV_PP2_PALLADIUM
-			del_timer(&port_pcpu->slow_tx_done_timer);
-#else
 			hrtimer_cancel(&port_pcpu->tx_done_timer);
-#endif
 			port_pcpu->timer_scheduled = false;
 			tasklet_kill(&port_pcpu->tx_done_tasklet);
 		}
@@ -3336,12 +3256,9 @@ static int mv_pp2x_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 	if (!port->mac_data.phy_dev)
 		return -ENOTSUPP;
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	ret = phy_mii_ioctl(port->mac_data.phy_dev, ifr, cmd);
 	if (!ret)
 		mv_pp21_link_event(dev);
-#endif
-
 	return ret;
 }
 
@@ -3503,7 +3420,9 @@ static void mv_pp22_queue_vectors_init(struct mv_pp2x_port *port)
 	struct queue_vector *q_vec = &port->q_vector[0];
 	struct net_device  *net_dev = port->dev;
 
-	/* Each cpu has queue_vector for private tx_done counters and/or private rx_queues */
+	/* Each cpu has queue_vector for private tx_done counters and/or
+	 *  private rx_queues
+	 */
 	for (cpu = 0; cpu < num_active_cpus(); cpu++) {
 		q_vec[cpu].parent = port;
 		q_vec[cpu].qv_type = MVPP2_PRIVATE;
@@ -3545,7 +3464,6 @@ static void mv_pp22_queue_vectors_init(struct mv_pp2x_port *port)
 	}
 }
 
-
 static void mv_pp22_port_irq_names_update(struct mv_pp2x_port *port)
 {
 	int i, cpu;
@@ -3571,12 +3489,10 @@ static void mv_pp22_port_irq_names_update(struct mv_pp2x_port *port)
 				str_common, "rx_shared");
 		}
 	}
-
 	snprintf(port->mac_data.irq_name, IRQ_NAME_SIZE, "%s.%s", str_common,
 		"link");
 }
 
-
 static void mv_pp21x_port_isr_rx_group_cfg(struct mv_pp2x_port *port)
 {
 	mv_pp21_isr_rx_group_write(&port->priv->hw, port->id,
@@ -3599,8 +3515,6 @@ static void mv_pp22_port_isr_rx_group_cfg(struct mv_pp2x_port *port)
 	}
 }
 
-
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 static int mv_pp2_init_emac_data(struct mv_pp2x_port *port,
 		struct device_node *emac_node)
 {
@@ -3682,7 +3596,6 @@ static int mv_pp2_init_emac_data(struct mv_pp2x_port *port,
 	}
 return 0;
 }
-#endif
 
 static u32 mvp_pp2x_gop110_netc_cfg_create(struct mv_pp2x *priv)
 {
@@ -3710,12 +3623,10 @@ static u32 mvp_pp2x_gop110_netc_cfg_create(struct mv_pp2x *priv)
 			else if (mac->phy_mode == PHY_INTERFACE_MODE_RGMII)
 				val |= MV_NETC_GE_MAC3_RGMII;
 		}
-
 	}
 	return val;
 }
 
-
 /* Initialize port HW */
 static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 {
@@ -3725,11 +3636,10 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 	struct mv_mac_data *mac = &port->mac_data;
 	int queue, err;
 
-
 	/* Disable port */
 	mv_pp2x_egress_disable(port);
 
-	if (FPGA || port->priv->pp2_version == PPV21)
+	if (port->priv->pp2_version == PPV21)
 		mv_pp21_port_disable(port);
 	else
 		mv_gop110_port_disable(gop, mac);
@@ -3798,9 +3708,7 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 	return err;
 }
 
-
 /* Ports initialization */
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 static int mv_pp2x_port_probe(struct platform_device *pdev,
 			    struct device_node *port_node,
 			    struct mv_pp2x *priv)
@@ -3820,14 +3728,11 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	unsigned int *port_irqs;
 	int port_num_irq;
 #endif
-
 	dev = alloc_etherdev_mqs(sizeof(struct mv_pp2x_port),
 		mv_pp2x_txq_number, mv_pp2x_rxq_number);
 	if (!dev)
 		return -ENOMEM;
 
-
-
 	/*Connect entities */
 	port = netdev_priv(dev);
 	port->dev = dev;
@@ -3846,13 +3751,11 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		dev_err(&pdev->dev, "missing emac-data\n");
 		err = -EINVAL;
 		goto err_free_netdev;
-
 	}
 	/* Init emac_data, includes link interrupt */
 	if (mv_pp2_init_emac_data(port, emac_node))
 		goto err_free_netdev;
 
-
 	/* get MAC address */
 	dt_mac_addr = of_get_mac_address(emac_node);
 	if (dt_mac_addr && is_valid_ether_addr(dt_mac_addr)) {
@@ -3906,8 +3809,6 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 
 	port->num_tx_queues = mv_pp2x_txq_number;
 	port->num_rx_queues = mv_pp2x_rxq_number;
-
-
 	dev->tx_queue_len = MVPP2_MAX_TXD;
 	dev->watchdog_timeo = 5 * HZ;
 	dev->netdev_ops = &mv_pp2x_netdev_ops;
@@ -3936,7 +3837,6 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		goto err_free_irq;
 	}
 
-
 	port->tx_ring_size = tx_queue_size;
 	port->rx_ring_size = rx_queue_size;
 
@@ -3973,8 +3873,10 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		}
 	}
 	features = NETIF_F_SG;
-	dev->features = features | NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
-	dev->hw_features |= features | NETIF_F_RXCSUM | NETIF_F_GRO | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+	dev->features = features | NETIF_F_RXCSUM | NETIF_F_IP_CSUM |
+				NETIF_F_IPV6_CSUM;
+	dev->hw_features |= features | NETIF_F_RXCSUM | NETIF_F_GRO |
+				NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	/* Only when multi queue mode, rxhash is supported */
 	if (mv_pp2x_queue_mode)
 		dev->hw_features |= NETIF_F_RXHASH;
@@ -4014,163 +3916,6 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	return err;
 }
 
-#else
-
-static int mv_pp2x_port_probe_fpga(struct platform_device *pdev,
-				int port_i,
-			    struct mv_pp2x *priv)
-{
-	struct device_node *phy_node = NULL;
-	struct mv_pp2x_port *port;
-	struct mv_pp2x_port_pcpu *port_pcpu;
-	struct net_device *dev;
-	const char *mac_from;
-	char hw_mac_addr[ETH_ALEN];
-	u32 id;
-	int features, phy_mode = 0, err = 0, i, cpu;
-
-	dev = alloc_etherdev_mqs(sizeof(struct mv_pp2x_port),
-		mv_pp2x_txq_number, mv_pp2x_rxq_number);
-	if (!dev)
-		return -ENOMEM;
-
-	dev->tx_queue_len = MVPP2_MAX_TXD;
-	dev->watchdog_timeo = 5 * HZ;
-	dev->netdev_ops = &mv_pp2x_netdev_ops;
-	mv_pp2x_set_ethtool_ops(dev);
-
-	port = netdev_priv(dev);
-
-	port->priv = priv;
-	port->id = port_i;
-	port->num_tx_queues = mv_pp2x_txq_number;
-	port->num_rx_queues = mv_pp2x_rxq_number;
-
-	/*YuvalC: Port first_rxq relative to port->id, not dependent on
-	 * board topology, i.e. not dynamically allocated
-	 */
-	port->first_rxq = (port->id)*(priv->pp2xdata->pp2x_max_port_rxqs) +
-		first_log_rxq_queue;
-	port->mac_data.phy_node = phy_node;
-	port->mac_data.phy_mode = phy_mode;
-	port->base = ((mv_pp2_vfpga_address + MAC_PORT0_OFFSET) +
-		((port->id) * 0x1000));
-	pr_debug("mvpp2(%d): port_probe: id-%d vfpga_add=0x%p base=0x%p\n",
-		__LINE__, port->id, mv_pp2_vfpga_address, port->base);
-
-	if (IS_ERR(port->base)) {
-		err = PTR_ERR(port->base);
-		goto err_free_irq;
-	}
-
-	/* Alloc per-cpu stats */
-	port->stats = netdev_alloc_pcpu_stats(struct mv_pp2x_pcpu_stats);
-
-	if (!port->stats) {
-		MVPP2_PRINT_LINE();
-
-		err = -ENOMEM;
-		goto err_free_irq;
-	}
-
-
-	mac_from = "hardware";
-	hw_mac_addr[0] = 0x02;
-	hw_mac_addr[1] = 0x68;
-	hw_mac_addr[2] = 0xb3;
-	hw_mac_addr[3] = 0x29;
-	hw_mac_addr[4] = 0xda;
-	hw_mac_addr[5] = 0x98 | port_i;
-
-	ether_addr_copy(dev->dev_addr, hw_mac_addr);
-
-	port->tx_ring_size = tx_queue_size;
-	port->rx_ring_size = rx_queue_size;
-	port->dev = dev;
-	SET_NETDEV_DEV(dev, &pdev->dev);
-	err = mv_pp2x_port_init(port);
-
-	if (err < 0) {
-		dev_err(&pdev->dev, "failed to init port %d\n", port->id);
-		goto err_free_stats;
-	}
-	/* FPGA uses ppv21 GOP */
-	mv_pp21_port_power_up(port);
-
-	port->pcpu = alloc_percpu(struct mv_pp2x_port_pcpu);
-	if (!port->pcpu) {
-		err = -ENOMEM;
-		goto err_free_txq_pcpu;
-	}
-
-	if (port->priv->pp2xdata->interrupt_tx_done == false) {
-		for_each_online_cpu(cpu) {
-			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
-
-#ifdef CONFIG_MV_PP2_PALLADIUM
-			init_timer(&port_pcpu->slow_tx_done_timer);
-			port_pcpu->slow_tx_done_timer.function =
-				mv_pp2x_timer_cb;
-			port_pcpu->slow_tx_done_timer.data =
-				(unsigned long) (port_pcpu);
-#else
-			hrtimer_init(&port_pcpu->tx_done_timer,
-				CLOCK_MONOTONIC,
-				HRTIMER_MODE_REL_PINNED);
-			port_pcpu->tx_done_timer.function =
-				mv_pp2x_hr_timer_cb;
-#endif
-			port_pcpu->timer_scheduled = false;
-
-			tasklet_init(&port_pcpu->tx_done_tasklet,
-				mv_pp2x_tx_proc_cb, (unsigned long)dev);
-
-		}
-	}
-
-	features = NETIF_F_SG | NETIF_F_IP_CSUM;
-	dev->features = features | NETIF_F_RXCSUM;
-	dev->hw_features |= features | NETIF_F_RXCSUM | NETIF_F_GRO;
-	/* Only when multi queue mode, rxhash is supported */
-	if (mv_pp2x_queue_mode)
-		dev->hw_features |= NETIF_F_RXHASH;
-	dev->vlan_features |= features;
-
-	err = register_netdev(dev);
-
-	if (err < 0) {
-
-		dev_err(&pdev->dev, "failed to register netdev\n");
-		goto err_free_port_pcpu;
-	}
-
-#ifdef DEV_NETMAP
-	mv_pp2x_netmap_attach(port);
-#endif /* DEV_NETMAP */
-	netdev_info(dev, "Using %s mac address %pM\n", mac_from, dev->dev_addr);
-	priv->port_list[priv->num_ports] = port;
-	priv->num_ports++;
-	return 0;
-	dev_err(&pdev->dev, "%s failed for port_id(%d)\n", __func__, id);
-
-err_free_port_pcpu:
-	free_percpu(port->pcpu);
-err_free_txq_pcpu:
-	for (i = 0; i < mv_pp2x_txq_number; i++)
-		free_percpu(port->txqs[i]->pcpu);
-err_free_stats:
-	free_percpu(port->stats);
-err_free_irq:
-#if !defined(CONFIG_MV_PP2_POLLING)
-	mv_pp2x_port_irqs_dispose_mapping(port);
-#endif
-	free_netdev(dev);
-	return err;
-}
-
-
-#endif
-
 /* Ports removal routine */
 static void mv_pp2x_port_remove(struct mv_pp2x_port *port)
 {
@@ -4190,7 +3935,6 @@ static void mv_pp2x_port_remove(struct mv_pp2x_port *port)
 	free_netdev(port->dev);
 }
 
-
 /* Initialize decoding windows */
 static void mv_pp2x_conf_mbus_windows(const struct mbus_dram_target_info *dram,
 				    struct mv_pp2x_hw *hw)
@@ -4259,7 +4003,6 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 
 	mv_pp2x_write(hw, MVPP22_BM_PHY_VIRT_HIGH_RLS_REG, 0x0);
 
-#if !defined(CONFIG_MV_PP2_FPGA)
 	/*AXI Bridge Configuration */
 
 	if (is_device_dma_coherent(&pdev->dev)) {
@@ -4325,10 +4068,7 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 
 	mv_pp2x_write(hw, MVPP22_AXI_WR_SNOOP_CODE_REG, val);
 
-#endif
-
 	/* Disable HW PHY polling */
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	if (priv->pp2_version == PPV21) {
 		val = readl(hw->lms_base + MVPP2_PHY_AN_CFG0_REG);
 		val |= MVPP2_PHY_AN_STOP_SMI0_MASK;
@@ -4336,7 +4076,6 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 		writel(MVPP2_EXT_GLOBAL_CTRL_DEFAULT,
 			hw->lms_base + MVPP2_MNG_EXTENDED_GLOBAL_CTRL_REG);
 	}
-#endif
 
 	/* Allocate and initialize aggregated TXQs */
 	priv->aggr_txqs = devm_kcalloc(&pdev->dev, num_active_cpus(),
@@ -4375,7 +4114,6 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 	/* Parser flow id attribute tbl init */
 	mv_pp2x_prs_flow_id_attr_init();
 
-
 	/* Parser default initialization */
 	err = mv_pp2x_prs_default_init(pdev, hw);
 	if (err < 0)
@@ -4391,7 +4129,6 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 	if (err < 0)
 		return err;
 
-
 	if (pp2_ver == PPV22) {
 		for (i = 0; i < 128; i++) {
 			val = mv_pp2x_read(hw, MVPP2_RXQ_CONFIG_REG(i));
@@ -4403,7 +4140,6 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 	return 0;
 }
 
-
 static struct mv_pp2x_platform_data pp21_pdata = {
 	.pp2x_ver = PPV21,
 	.pp2x_max_port_rxqs = 8,
@@ -4442,8 +4178,6 @@ static int mv_pp2x_init(struct platform_device *pdev, struct mv_pp2x *priv)
 	.skb_base_mask = DMA_BIT_MASK(32),
 };
 
-
-
 static const struct of_device_id mv_pp2x_match_tbl[] = {
 		{
 			.compatible = "marvell,armada-375-pp2",
@@ -4577,7 +4311,6 @@ void mv_pp2x_pp2_port_print(struct mv_pp2x_port *port)
 			port->q_vector[i].num_rx_queues);
 		DBG_MSG("\t\t pending_cause_rx(%d)\n",
 			port->q_vector[i].pending_cause_rx);
-
 	}
 	DBG_MSG("\t GOP ind(%d) phy_mode(%d) phy_addr(%d)\n",
 		port->mac_data.gop_index, port->mac_data.phy_mode,
@@ -4618,25 +4351,17 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 	static int auto_cell_index;
 	static bool cell_index_dts_flag;
 	const struct of_device_id *match;
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	struct device_node *dn = pdev->dev.of_node;
 	struct resource *res;
 	resource_size_t mspg_base, mspg_end;
 	u32	err;
-#endif
 
-
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	match = of_match_node(mv_pp2x_match_tbl, dn);
-#else
-	match = &mv_pp2x_match_tbl[1];
-#endif
 	if (!match)
 		return -ENODEV;
 
 	priv->pp2xdata = (struct mv_pp2x_platform_data *) match->data;
 
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	if (of_property_read_u32(dn, "cell-index", cell_index)) {
 		*cell_index = auto_cell_index;
 		auto_cell_index++;
@@ -4684,7 +4409,6 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 			return PTR_ERR(hw->gop.gop_110.xmib.base);
 		hw->gop.gop_110.xmib.obj_size = 0x0100;
 
-
 		MVPP2_PRINT_2LINE();
 
 		/* skipped led */
@@ -4717,7 +4441,6 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 		if (IS_ERR(hw->gop.gop_110.xsmi_base))
 			return PTR_ERR(hw->gop.gop_110.xsmi_base);
 
-
 		MVPP2_PRINT_2LINE();
 
 		/* MSPG - base register */
@@ -4730,10 +4453,8 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 		mspg_base = res->start;
 		mspg_end  = res->end;
 
-
 		MVPP2_PRINT_2LINE();
 
-
 		/* xpcs */
 		res = platform_get_resource_byname(pdev,
 			IORESOURCE_MEM, "xpcs");
@@ -4743,7 +4464,6 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 			(void *)(hw->gop.gop_110.mspg_base +
 				(res->start-mspg_base));
 
-
 		MVPP2_PRINT_2LINE();
 
 		hw->gop.gop_110.ptp.base =
@@ -4759,10 +4479,8 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 			(res->start-mspg_base));
 		hw->gop.gop_110.gmac.obj_size = 0x1000;
 
-
 		MVPP2_PRINT_2LINE();
 
-
 		/* MSPG - xlg */
 		res = platform_get_resource_byname(pdev,
 			IORESOURCE_MEM, "xlg");
@@ -4773,17 +4491,8 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 			(res->start-mspg_base));
 		hw->gop.gop_110.xlg_mac.obj_size = 0x1000;
 
-
 		MVPP2_PRINT_2LINE();
-
 	}
-#else /*CONFIG_MV_PP2_FPGA*/
-	MVPP2_PRINT_VAR(hw->base);
-	hw->base = mv_pp2_vfpga_address;
-	pr_debug("mvpp2(%d): mv_pp2x_probe:mv_pp2_vfpga_address=0x%p\n",
-		__LINE__, mv_pp2_vfpga_address);
-#endif
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 
 	hw->gop_core_clk = devm_clk_get(&pdev->dev, "gop_core_clk");
 	if (IS_ERR(hw->gop_core_clk))
@@ -4823,23 +4532,15 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 	hw->tclk = clk_get_rate(hw->pp_clk);
 	MVPP2_PRINT_VAR(hw->tclk);
 
-#else
-	hw->tclk = 25000000;
-#endif
-
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	*port_count = of_get_available_child_count(dn);
 	MVPP2_PRINT_VAR(*port_count);
 	if (*port_count == 0) {
 		dev_err(&pdev->dev, "no ports enabled\n");
 		err = -ENODEV;
 	}
-#else
-	*port_count = 2;
-
-#endif
 	return 0;
 }
+
 static int mv_pp2x_probe(struct platform_device *pdev)
 {
 	struct mv_pp2x *priv;
@@ -4849,17 +4550,8 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 	u16 cpu_map;
 	u32 cell_index = 0;
 	u32 net_comp_config;
-
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	struct device_node *dn = pdev->dev.of_node;
 	struct device_node *port_node;
-#endif
-#ifdef CONFIG_MV_PP2_FPGA
-	int start_port = 0;
-#endif
-#ifdef CONFIG_MV_PP2_PALLADIUM
-	int start_port = 1;
-#endif
 
 	priv = devm_kzalloc(&pdev->dev, sizeof(struct mv_pp2x), GFP_KERNEL);
 	if (!priv)
@@ -4881,10 +4573,6 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 		pr_crit("mvpp2: cannot set dma_mask\n");
 		goto err_clk;
 	}
-	/*Disable dma_coherency in FPGA*/
-#ifdef CONFIG_MV_PP2_FPGA
-	pdev->dev.archdata.dma_coherent = 0;
-#endif
 
 #ifdef CONFIG_64BIT
 {
@@ -4905,7 +4593,6 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 }
 #endif
 
-
 	/* Save cpu_present_mask + populate the per_cpu address space */
 	cpu_map = 0;
 	i = 0;
@@ -4931,11 +4618,9 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 		goto err_clk;
 	}
 
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	/* smi init */
 	if (priv->pp2_version == PPV21)
 		mv_gop110_smi_init(&hw->gop);
-#endif
 
 	priv->port_list = devm_kcalloc(&pdev->dev, port_count,
 				      sizeof(struct mv_pp2x_port *),
@@ -4949,21 +4634,11 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 	mv_pp2x_init_rxfhindir(priv);
 
 	/* Initialize ports */
-#if !defined(CONFIG_MV_PP2_FPGA) && !defined(CONFIG_MV_PP2_PALLADIUM)
 	for_each_available_child_of_node(dn, port_node) {
 		err = mv_pp2x_port_probe(pdev, port_node, priv);
 		if (err < 0)
 			goto err_clk;
 	}
-#else
-
-	for (i = start_port ; i < (start_port+port_count) ; i++) {
-		err = mv_pp2x_port_probe_fpga(pdev, i, priv);
-		if (err < 0)
-			goto err_clk;
-	}
-#endif
-
 	net_comp_config = mvp_pp2x_gop110_netc_cfg_create(priv);
 	mv_gop110_netc_init(&priv->hw.gop, net_comp_config,
 				MV_NETC_FIRST_PHASE);
@@ -5023,9 +4698,6 @@ static int mv_pp2x_remove(struct platform_device *pdev)
 	return 0;
 }
 
-
-
-
 MODULE_DEVICE_TABLE(of, mv_pp2x_match_tbl);
 
 static struct platform_driver mv_pp2x_driver = {
@@ -5049,126 +4721,10 @@ static int mv_pp2x_rxq_number_get(void)
 	return rx_queue_num;
 }
 
-
-#ifdef CONFIG_MV_PP2_FPGA
-
-static int mv_pp2_pci_probe(struct pci_dev *pdev,
-	const struct pci_device_id *ent)
-{
-	unsigned long flags;
-
-	/* code below relevant for FPGA only */
-	if (pci_enable_device(pdev)) {
-		pr_err("mvpp2: can not enable PCI device\n");
-		return -1;
-	}
-	flags = pci_resource_flags(pdev, 0);
-
-	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
-		pr_err("mvpp2: can not find proper PCI device base address\n");
-		return -ENODEV;
-	}
-	pr_debug("pci flags:0x%lx\n", flags);
-
-	if (pci_request_regions(pdev, "mv_pp2_pci")) {
-		pr_err("mvpp2: can not obtain PCI resources\n");
-		return -ENODEV;
-	}
-
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
-		pr_err("mvpp2: no usable DMA configuration\n");
-		return -ENODEV;
-	}
-
-	mv_pp2_vfpga_address = pci_iomap(pdev, 0, 16 * 1024 * 1024);
-
-	if (!mv_pp2_vfpga_address)
-		pr_err("mvpp2: can not map device registers\n");
-
-	pr_debug("mvpp2: fpga base: VIRT=0x%p, size=%d KBytes\n",
-		mv_pp2_vfpga_address, 16 * 1024);
-	return 0;
-}
-
-
-static void mv_pp2_pci_remove(struct pci_dev *pdev)
-{
-	if (mv_pp2_vfpga_address)
-		pci_iounmap(pdev, mv_pp2_vfpga_address);
-	pci_release_regions(pdev);
-	pr_debug("mvpp2: PCI device removed\n");
-}
-
-static const struct pci_device_id fpga_id_table[] = {
-	{ 0x1234, 0x1234, PCI_ANY_ID, PCI_ANY_ID, 2, 0, 0}, {0}
-};
-
-MODULE_DEVICE_TABLE(pci, fpga_id_table);
-
-
-static struct pci_driver mv_pp2_pci_driver = {
-	.name	= "mv_pp2_pci",
-	.id_table = fpga_id_table,
-	.probe		= mv_pp2_pci_probe,
-	.remove		= mv_pp2_pci_remove,
-};
-
-#endif
-
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-
-static struct resource mv_pp2x_resources[] = {
-#ifdef CONFIG_MV_PP2_PALLADIUM
-	{
-		.name = MVPP2_DRIVER_NAME,
-		.start = MVPP2_ADDRESS,
-		.end   = MVPP2_ADDRESS + (CPN110_ADDRESS_SPACE_SIZE - 1),
-		.flags = IORESOURCE_MEM,
-	},
-#endif
-};
-
-static struct platform_device mv_pp2x_device = {
-	.name           = MVPP2_DRIVER_NAME,
-	.id             = 0,
-	.num_resources	= ARRAY_SIZE(mv_pp2x_resources),
-	.resource       = mv_pp2x_resources,
-	.dev            = {
-		.platform_data = 0,
-		.init_name = "f2000000.ppv22",
-	},
-};
-
-#endif
-
 static int __init mpp2_module_init(void)
 {
 	int ret = 0;
 
-
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-
-	if (platform_device_register(&mv_pp2x_device)) {
-		pr_debug("mvpp2(%d): platform_device_register failed\n",
-			__LINE__);
-		return -1;
-	}
-
-#ifdef CONFIG_MV_PP2_FPGA
-	ret = pci_register_driver(&mv_pp2_pci_driver);
-	if (ret < 0) {
-		pr_err(
-		"mvpp2: PCI card not found, driver not installed. rc=%d\n",
-		ret);
-		return ret;
-	}
-#endif
-
-
-	mv_pp2x_device.dev.dma_mask = &(mv_pp2x_device.dev.coherent_dma_mask);
-	mv_pp2x_num_cos_queues = 4;
-
-#endif
 	mv_pp2x_rxq_number = mv_pp2x_rxq_number_get();
 	mv_pp2x_txq_number = mv_pp2x_num_cos_queues;
 
@@ -5188,18 +4744,8 @@ static int __init mpp2_module_init(void)
 static void __exit mpp2_module_exit(void)
 {
 	platform_driver_unregister(&mv_pp2x_driver);
-#if defined(CONFIG_MV_PP2_FPGA) || defined(CONFIG_MV_PP2_PALLADIUM)
-	/* [AW] kfree(NULL) is safe, so no need for check */
-	/* if (mv_pp2x_device.dev.dma_mask) */
-		kfree(mv_pp2x_device.dev.dma_mask);
-#ifdef CONFIG_MV_PP2_FPGA
-	pci_unregister_driver(&mv_pp2_pci_driver);
-#endif
-	platform_device_unregister(&mv_pp2x_device);
-#endif
 }
 
-
 #if defined(CONFIG_MV_PP2_POLLING)
 static void mv_pp22_cpu_timer_callback(unsigned long data)
 {
@@ -5209,13 +4755,11 @@ static void mv_pp22_cpu_timer_callback(unsigned long data)
 	struct mv_pp2x_port *port;
 	u32 timeout;
 
-
 	/* Check link_change for initialized ports */
 	for (i = 0 ; i < priv->num_ports; i++) {
 		port = priv->port_list[i];
 		if (port && port->link_change_tasklet.func)
 			tasklet_schedule(&port->link_change_tasklet);
-
 	}
 
 	/* Schedule napi for ports with link_up. */
@@ -5243,20 +4787,14 @@ static void mv_pp22_cpu_timer_callback(unsigned long data)
 				__LINE__);
 	}
 
-
 	timeout = MV_PP2_FPGA_PERODIC_TIME;
-#ifdef CONFIG_MV_PP2_PALLADIUM
-	timeout = timeout*1000;
-#endif
 	mod_timer(&cpu_poll_timer, jiffies + msecs_to_jiffies(timeout));
-
 }
 
 #endif
 module_init(mpp2_module_init);
 module_exit(mpp2_module_exit);
 
-
 MODULE_DESCRIPTION("Marvell PPv2x Ethernet Driver - www.marvell.com");
 MODULE_AUTHOR("Marvell");
 MODULE_LICENSE("GPL v2");
-- 
1.7.9.5


From f41ff6e39af7a24dde420f7de6218df223cb36d1 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Thu, 22 Dec 2016 10:14:14 +0200
Subject: [PATCH 0659/1345] fix: icu: cp110: clear firmware ICU configuration
 to avoid SPI conflicts

commit  5be2f82b4eadbea511ca12cf4b456e99f2df97f3 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Firmware (ATF) is setting static initial ICU SPI assignments, which are
re-configured by dynamic ICU kernel driver afterwards. This caused
conflicts and unpredictable SPI assignments, and to some irqs to be
mapped to the same GIC index, since Kernel ICU driver didn't clean
previous firmware assignments
This patch add loop to clear all initial ICU metadata registers set
by firmware for SPI interrupts.
SYSTEMSW-3160

Change-Id: Ic5c190d80be3e0d909d3343e9ae3b03bec3b9e2f
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/34904
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/irqchip/irq-mvebu-icu.c |   21 ++++++++++++++++-----
 1 file changed, 16 insertions(+), 5 deletions(-)

diff --git a/drivers/irqchip/irq-mvebu-icu.c b/drivers/irqchip/irq-mvebu-icu.c
index 0def253..5b28415 100644
--- a/drivers/irqchip/irq-mvebu-icu.c
+++ b/drivers/irqchip/irq-mvebu-icu.c
@@ -45,7 +45,8 @@
 
 #include <dt-bindings/interrupt-controller/mvebu-icu.h>
 
-#define ICU_MAX_IRQ_SIZE	128
+#define ICU_MAX_IRQS		207
+#define ICU_MAX_SPI_IRQ_IN_GIC	128
 #define ICU_GIC_SPI_BASE0	64
 #define ICU_GIC_SPI_BASE1	288
 
@@ -78,7 +79,7 @@ struct mvebu_icu_irq_data {
 };
 
 static DEFINE_SPINLOCK(icu_lock);
-static DECLARE_BITMAP(icu_irq_alloc, ICU_MAX_IRQ_SIZE);
+static DECLARE_BITMAP(icu_irq_alloc, ICU_MAX_SPI_IRQ_IN_GIC);
 
 static struct irq_chip mvebu_icu_irq_chip = {
 	.name			= "ICU",
@@ -103,8 +104,8 @@ static int mvebu_icu_irq_parent_domain_alloc(struct irq_domain *domain,
 
 	/* Find first free interrupt in ICU pool */
 	spin_lock(&icu_lock);
-	*irq_msg_num = find_first_zero_bit(icu_irq_alloc, ICU_MAX_IRQ_SIZE);
-	if (*irq_msg_num == ICU_MAX_IRQ_SIZE) {
+	*irq_msg_num = find_first_zero_bit(icu_irq_alloc, ICU_MAX_SPI_IRQ_IN_GIC);
+	if (*irq_msg_num == ICU_MAX_SPI_IRQ_IN_GIC) {
 		pr_err("No free ICU interrupt found\n");
 		spin_unlock(&icu_lock);
 		return -EINVAL;
@@ -252,6 +253,7 @@ static int __init mvebu_icu_of_init(struct device_node *node, struct device_node
 	struct mvebu_icu_irq_data *icu;
 	struct irq_domain *parent_domain;
 	u32 gicp_spi_reg[4];
+	u32 i, icu_int;
 
 	icu = kzalloc(sizeof(struct mvebu_icu_irq_data), GFP_KERNEL);
 	if (!icu)
@@ -279,7 +281,7 @@ static int __init mvebu_icu_of_init(struct device_node *node, struct device_node
 		goto err_iounmap;
 	}
 
-	icu->domain = irq_domain_add_hierarchy(parent_domain, 0, ICU_MAX_IRQ_SIZE,
+	icu->domain = irq_domain_add_hierarchy(parent_domain, 0, ICU_MAX_SPI_IRQ_IN_GIC,
 			node, &mvebu_icu_domain_ops, icu);
 	if (!icu->domain) {
 		pr_err("Failed to create ICU domain\n");
@@ -294,6 +296,15 @@ static int __init mvebu_icu_of_init(struct device_node *node, struct device_node
 	writel(gicp_spi_reg[2], icu->base + ICU_CLRSPI_NSR_AH);
 	writel(gicp_spi_reg[3], icu->base + ICU_CLRSPI_NSR_AL);
 
+	/* Clean all ICU interrupts with type SPI_NSR, required to avoid
+	** unpredictable SPI assignments done by firmware
+	**/
+	for (i = 0 ; i < ICU_MAX_IRQS ; i++) {
+		icu_int = readl(icu->base + ICU_INT_CFG(i));
+		if ((icu_int >> ICU_GROUP_OFFSET) == ICU_GRP_NSR)
+			writel(0x0, icu->base + ICU_INT_CFG(i));
+	}
+
 	pr_debug("ICU irq chip init successfully\n");
 
 	return 0;
-- 
1.7.9.5


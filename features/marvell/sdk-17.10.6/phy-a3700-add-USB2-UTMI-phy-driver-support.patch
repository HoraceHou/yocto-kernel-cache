From 38dad5ff7fcd52943a3ea801baa72a27936e1dc3 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 11 Jan 2017 00:34:32 +0800
Subject: [PATCH 0800/1345] phy: a3700: add USB2 UTMI phy driver support

commit  92d323ee80d3f084e8bb32c0bbd48310bba10f29 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- The main purposes to support Armada-3700 utmi phy are as below:
  1. Initialize the utmi phy and run USB2 successfully without
     the dependency to bootloader utmi phy.
  2. Power off it during system suspend to save the power.
  3. Re-init the utmi phy after resume from low power state to
     make the USB work correctly
- The UTMI driver uses generic phy infrastructure.

Change-Id: I5619e8042719c0506ce47036b58d7705a027c2dd
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35444
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/phy/Kconfig                           |    6 +
 drivers/phy/Makefile                          |    1 +
 drivers/phy/phy-armada3700-utmi.c             |  272 +++++++++++++++++++++++++
 drivers/phy/phy-armada3700-utmi.h             |   57 ++++++
 include/dt-bindings/phy/phy-armada3700-utmi.h |   19 ++
 5 files changed, 355 insertions(+)
 create mode 100644 drivers/phy/phy-armada3700-utmi.c
 create mode 100644 drivers/phy/phy-armada3700-utmi.h
 create mode 100644 include/dt-bindings/phy/phy-armada3700-utmi.h

diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index bf3aab7..97a38ec 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -151,6 +151,12 @@ config PHY_MVEBU_SATA
 	depends on OF
 	select GENERIC_PHY
 
+config PHY_ARMADA3700_UTMI
+	def_bool y
+	depends on ARCH_MVEBU
+	depends on OF
+	select GENERIC_PHY
+
 config PHY_MIPHY28LP
 	tristate "STMicroelectronics MIPHY28LP PHY driver for STiH407"
 	depends on ARCH_STI
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 60cb5c3..73bdff3 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_PHY_MVEBU_COMPHY)		+= phy-comphy-mvebu.o
 obj-$(CONFIG_PHY_MVEBU_COMPHY_CP110)	+= phy-comphy-cp110.o
 obj-$(CONFIG_PHY_MVEBU_COMPHY_A3700)	+= phy-comphy-a3700.o
 obj-$(CONFIG_PHY_MVEBU_SATA)		+= phy-mvebu-sata.o
+obj-$(CONFIG_PHY_ARMADA3700_UTMI)	+= phy-armada3700-utmi.o
 obj-$(CONFIG_PHY_MIPHY28LP) 		+= phy-miphy28lp.o
 obj-$(CONFIG_PHY_RCAR_GEN2)		+= phy-rcar-gen2.o
 obj-$(CONFIG_PHY_RCAR_GEN3_USB2)	+= phy-rcar-gen3-usb2.o
diff --git a/drivers/phy/phy-armada3700-utmi.c b/drivers/phy/phy-armada3700-utmi.c
new file mode 100644
index 0000000..fe9f012
--- /dev/null
+++ b/drivers/phy/phy-armada3700-utmi.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2016 Marvell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Armada 3700 comes with an USB2 host and device controller and an
+ * USB32 controller. Each of them has a UTMI PHY for USB2 protocol.
+ */
+
+#include <linux/delay.h>
+#include <linux/of_device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/phy/phy-armada3700-utmi.h>
+#include "phy-armada3700-utmi.h"
+
+
+struct mvebu_a3700_utmi_phy {
+	struct phy *phy;
+	void __iomem *regs;
+	bool usb32;
+};
+
+/**************************************************************************
+  * poll_reg
+  *
+  * return: 0 on success, 1 on timeout
+ **************************************************************************/
+static u32 poll_reg(void __iomem *addr, u32 val, u32 mask, u32 timeout)
+{
+	u32 rval = 0xdead;
+
+	for (; timeout > 0; timeout--) {
+		rval = readl(addr);
+		if ((rval & mask) == val)
+			return 0;
+
+		mdelay(10);
+	}
+
+	return 1;
+}
+
+static void reg_set(void __iomem *addr, u32 data, u32 mask)
+{
+	u32 reg_data;
+
+	reg_data = readl(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writel(reg_data, addr);
+}
+
+static int mvebu_a3700_utmi_phy_power_on(struct phy *phy)
+{
+	int ret = 0;
+	u32 data, mask;
+	struct mvebu_a3700_utmi_phy *utmi_phy = phy_get_drvdata(phy);
+
+	dev_dbg(&phy->dev, "%s: Enter\n", __func__);
+
+	if (!utmi_phy)
+		return -ENODEV;
+
+	/*
+	 * 0. Setup PLL. 40MHz clock uses defaults.It is 25MHz now.
+	 *    See "PLL Settings for Typical REFCLK" table
+	 */
+	data = (PLL_REF_DIV_5 << PLL_REF_DIV_OFF) | (PLL_FB_DIV_96 << PLL_FB_DIV_OFF);
+	mask = PLL_REF_DIV_MASK | PLL_FB_DIV_MASK | PLL_SEL_LPFR_MASK;
+	reg_set(USB2_PHY_PLL_CTRL_REG0 + utmi_phy->regs, data, mask);
+
+	/*
+	 * 1. PHY pull up and disable USB2 suspend
+	 */
+	reg_set(USB2_PHY_CTRL_ADDR(utmi_phy->usb32) + utmi_phy->regs,
+		RB_USB2PHY_SUSPM(utmi_phy->usb32) | RB_USB2PHY_PU(utmi_phy->usb32), 0);
+
+	if (utmi_phy->usb32) {
+		/*
+		 * 2. Power up OTG module
+		 */
+		reg_set(USB2_PHY_OTG_CTRL_ADDR + utmi_phy->regs, PHY_PU_OTG, 0);
+
+		/*
+		 * 3. Configure PHY charger detection
+		 */
+		reg_set(USB2_PHY_CHRGR_DET_ADDR + utmi_phy->regs, 0,
+			PHY_CDP_EN | PHY_DCP_EN | PHY_PD_EN | PHY_CDP_DM_AUTO |
+			PHY_ENSWITCH_DP | PHY_ENSWITCH_DM | PHY_PU_CHRG_DTC);
+
+		/*
+		 * 4. Clear USB2 Host and Device OTG phy DP/DM pull-down,
+		 *    needed in evice mode
+		 */
+		reg_set(USB2_OTG_PHY_CTRL_ADDR + utmi_phy->regs, 0,
+			USB2_DP_PULLDN_DEV_MODE | USB2_DM_PULLDN_DEV_MODE);
+	}
+
+	/* Assert PLL calibration done */
+	ret = poll_reg(USB2_PHY_CAL_CTRL_ADDR + utmi_phy->regs,
+		       PHY_PLLCAL_DONE,
+		       PHY_PLLCAL_DONE,
+		       PLL_LOCK_TIMEOUT);
+	if (ret) {
+		dev_err(&phy->dev, "Failed to end USB2 PLL calibration\n");
+		return ret;
+	}
+
+	/* Assert impedance calibration done */
+	ret = poll_reg(USB2_PHY_CAL_CTRL_ADDR + utmi_phy->regs,
+		       PHY_IMPCAL_DONE,
+		       PHY_IMPCAL_DONE,
+		       PLL_LOCK_TIMEOUT);
+	if (ret) {
+		dev_err(&phy->dev, "Failed to end USB2 impedance calibration\n");
+		return ret;
+	}
+
+	/* Assert squetch calibration done */
+	ret = poll_reg(USB2_RX_CHAN_CTRL1_ADDR + utmi_phy->regs,
+		       USB2PHY_SQCAL_DONE,
+		       USB2PHY_SQCAL_DONE,
+		       PLL_LOCK_TIMEOUT);
+	if (ret) {
+		dev_err(&phy->dev, "Failed to end USB2 unknown calibration\n");
+		return ret;
+	}
+
+	/* Assert PLL is ready */
+	ret = poll_reg(USB2_PHY_PLL_CTRL_REG0 + utmi_phy->regs,
+		       PLL_READY,
+		       PLL_READY,
+		       PLL_LOCK_TIMEOUT);
+
+	if (ret) {
+		dev_err(&phy->dev, "Failed to lock USB2 PLL\n");
+		return ret;
+	}
+
+	dev_dbg(&phy->dev, "%s: Exit\n", __func__);
+
+	return ret;
+}
+
+static int mvebu_a3700_utmi_phy_power_off(struct phy *phy)
+{
+	struct mvebu_a3700_utmi_phy *utmi_phy = phy_get_drvdata(phy);
+
+	dev_dbg(&phy->dev, "%s: Enter\n", __func__);
+
+	if (!utmi_phy)
+		return -ENODEV;
+
+	/*
+	 * 1. PHY pull down and enable USB2 suspend
+	 */
+	reg_set(USB2_PHY_CTRL_ADDR(utmi_phy->usb32) + utmi_phy->regs,
+		0, RB_USB2PHY_SUSPM(utmi_phy->usb32) | RB_USB2PHY_PU(utmi_phy->usb32));
+
+	/*
+	 * 2. Power down OTG module
+	 */
+	if (utmi_phy->usb32)
+		reg_set(USB2_PHY_OTG_CTRL_ADDR + utmi_phy->regs, 0, PHY_PU_OTG);
+
+	dev_dbg(&phy->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
+static const struct phy_ops armada3700_utmi_phy_ops = {
+	.power_on = mvebu_a3700_utmi_phy_power_on,
+	.power_off = mvebu_a3700_utmi_phy_power_off,
+	.owner = THIS_MODULE,
+};
+
+static int mvebu_armada3700_utmi_phy_probe(struct platform_device *pdev)
+{
+	int ret;
+	u32 utmi_port = 0;
+	struct device *dev = &pdev->dev;
+	struct phy *phy;
+	struct resource *res;
+	struct phy_provider *phy_provider;
+	struct mvebu_a3700_utmi_phy *utmi_phy;
+
+	utmi_phy = devm_kzalloc(dev, sizeof(*utmi_phy), GFP_KERNEL);
+	if (!utmi_phy)
+		return  -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no UTMI PHY memory resource\n");
+		ret = -ENODEV;
+		goto free_utmi_phy;
+	}
+
+	utmi_phy->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(utmi_phy->regs)) {
+		ret = PTR_ERR(utmi_phy->regs);
+		goto free_utmi_phy;
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node, "utmi-port", &utmi_port);
+	if (ret) {
+		dev_err(&pdev->dev, "no property of utmi-port\n");
+		goto unmap_phy;
+	}
+
+	if (utmi_port == UTMI_PHY_TO_USB3_HOST0)
+		utmi_phy->usb32 = true;
+	else
+		utmi_phy->usb32 = false;
+
+	phy = devm_phy_create(dev, NULL, &armada3700_utmi_phy_ops);
+	if (IS_ERR(phy)) {
+		dev_err(dev, "failed to create PHY\n");
+		ret = PTR_ERR(phy);
+		goto unmap_phy;
+	}
+
+	utmi_phy->phy = phy;
+
+	dev_set_drvdata(dev, utmi_phy);
+	phy_set_drvdata(phy, utmi_phy);
+
+	phy_provider = devm_of_phy_provider_register(&pdev->dev,
+						     of_phy_simple_xlate);
+
+	ret = PTR_ERR_OR_ZERO(phy_provider);
+	if (ret)
+		goto unmap_phy;
+
+	return ret;
+
+unmap_phy:
+	iounmap(utmi_phy->regs);
+
+free_utmi_phy:
+	devm_kfree(dev, utmi_phy);
+
+	return ret;
+}
+
+static const struct of_device_id of_usb_utmi_table[] = {
+	{ .compatible = "marvell,armada-3700-utmi-phy", },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, of_usb_utmi_table);
+
+static struct platform_driver armada3700_utmi_phy_driver = {
+	.probe	= mvebu_armada3700_utmi_phy_probe,
+	.driver = {
+		.of_match_table	= of_usb_utmi_table,
+		.name  = "armada3700_utmi_phy_driver",
+	}
+};
+module_platform_driver(armada3700_utmi_phy_driver);
+
+MODULE_DESCRIPTION("Armada 3700 UTMI PHY driver");
+MODULE_AUTHOR("Evan Wang <xswang@marvell.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/phy/phy-armada3700-utmi.h b/drivers/phy/phy-armada3700-utmi.h
new file mode 100644
index 0000000..5217d9b
--- /dev/null
+++ b/drivers/phy/phy-armada3700-utmi.h
@@ -0,0 +1,57 @@
+#ifndef _ARMADA3700_UTMI_H
+#define _ARMADA3700_UTMI_H
+
+enum a3700_utmi_phy_id {
+	A3700_UTMI_USB2_PHY = 0,
+	A3700_UTMI_USB32_PHY,
+	A3700_UTMI_PHY_MAX,
+};
+
+#define PLL_LOCK_TIMEOUT		1000
+
+#define USB2_PHY_PLL_CTRL_REG0		0x0
+#define PLL_REF_DIV_OFF			(0)
+#define PLL_REF_DIV_MASK		(0x7F << PLL_REF_DIV_OFF)
+#define PLL_REF_DIV_5			(0x5)
+#define PLL_FB_DIV_OFF			(16)
+#define PLL_FB_DIV_MASK			(0x1FF << PLL_FB_DIV_OFF)
+#define PLL_FB_DIV_96			(96)
+#define PLL_SEL_LPFR_OFF		(28)
+#define PLL_SEL_LPFR_MASK		(0x3 << PLL_SEL_LPFR_OFF)
+#define PLL_READY			BIT(31)
+
+#define USB2_PHY2_CTRL_ADDR		(0x804)
+#define USB2_PHY2_SUSPM			BIT(7)
+#define USB2_PHY2_PU			BIT(0)
+
+#define USB2_PHY2_PLL_CTRL0_ADDR	(0x0)
+
+/* Both UTMI PHY and UTMI OTG PHY */
+#define USB2_PHY_CAL_CTRL_ADDR		(0x8)
+#define PHY_PLLCAL_DONE			BIT(31)
+#define PHY_IMPCAL_DONE			BIT(23)
+#define USB2_PHY_OTG_CTRL_ADDR		(0x34)
+#define PHY_PU_OTG			BIT(4)
+#define USB2_RX_CHAN_CTRL1_ADDR		(0x18)
+#define USB2PHY_SQCAL_DONE		BIT(31)
+
+#define USB2_PHY_CHRGR_DET_ADDR		(0x38)
+#define PHY_CDP_EN			BIT(2)
+#define PHY_DCP_EN			BIT(3)
+#define PHY_PD_EN			BIT(4)
+#define PHY_PU_CHRG_DTC			BIT(5)
+#define PHY_CDP_DM_AUTO			BIT(7)
+#define PHY_ENSWITCH_DP			BIT(12)
+#define PHY_ENSWITCH_DM			BIT(13)
+
+#define USB2_OTG_PHY_CTRL_ADDR		(0x820)
+#define USB2_OTGPHY2_SUSPM		BIT(14)
+#define USB2_OTGPHY2_PU			BIT(0)
+#define USB2_DP_PULLDN_DEV_MODE		BIT(5)
+#define USB2_DM_PULLDN_DEV_MODE		BIT(6)
+
+#define USB2_PHY_CTRL_ADDR(usb32) (usb32 == 0 ? USB2_PHY2_CTRL_ADDR : USB2_OTG_PHY_CTRL_ADDR)
+#define RB_USB2PHY_SUSPM(usb32) (usb32 == 0 ? USB2_PHY2_SUSPM : USB2_OTGPHY2_SUSPM)
+#define RB_USB2PHY_PU(usb32) (usb32 == 0 ? USB2_PHY2_PU : USB2_OTGPHY2_PU)
+
+#endif /* _ARMADA3700_UTMI_H */
diff --git a/include/dt-bindings/phy/phy-armada3700-utmi.h b/include/dt-bindings/phy/phy-armada3700-utmi.h
new file mode 100644
index 0000000..852e7cf
--- /dev/null
+++ b/include/dt-bindings/phy/phy-armada3700-utmi.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 Marvell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _DT_BINDINGS_PHY_ARMADA3700_UTMI
+#define _DT_BINDINGS_PHY_ARMADA3700_UTMI
+
+#define UTMI_PHY_TO_USB3_HOST0		0
+#define UTMI_PHY_TO_USB3_HOST1		1
+#define UTMI_PHY_TO_USB3_DEVICE0	2
+#define UTMI_PHY_TO_USB2_HOST0		3
+#define UTMI_PHY_INVALID		0xff
+
+#endif /* _DT_BINDINGS_PHY_ARMADA3700_UTMI */
-- 
1.7.9.5


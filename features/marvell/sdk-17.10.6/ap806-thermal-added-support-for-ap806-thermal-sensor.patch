From bb74e7d6d29360c2c1a7e1c32a043053915e54b5 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Wed, 17 Feb 2016 13:25:42 +0200
Subject: [PATCH 0039/1345] ap806: thermal: added support for ap806 thermal
 sensor

commit  234d86b40b8f4adeaac41510fb8a10c1cd2abdbd from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- extended the armada thermal driver to support ap806
- updated Kconfig description
- added device tree entries for ap806
- enabled driver in LSP defconfig

Change-Id: I7cfcb1f4a997247b73971e70e37cc94bc4891891
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/thermal/armada-thermal.txt |    1 +
 arch/arm64/boot/dts/marvell/armada-ap806.dtsi      |    6 ++
 drivers/thermal/Kconfig                            |    4 +-
 drivers/thermal/armada_thermal.c                   |   86 +++++++++++++++++++-
 4 files changed, 93 insertions(+), 4 deletions(-)

diff --git a/Documentation/devicetree/bindings/thermal/armada-thermal.txt b/Documentation/devicetree/bindings/thermal/armada-thermal.txt
index 4698e0e..b0048d5 100644
--- a/Documentation/devicetree/bindings/thermal/armada-thermal.txt
+++ b/Documentation/devicetree/bindings/thermal/armada-thermal.txt
@@ -7,6 +7,7 @@ Required properties:
 		marvell,armada375-thermal
 		marvell,armada380-thermal
 		marvell,armadaxp-thermal
+		marvell,armada-ap806-thermal
 
 - reg:		Device's register space.
 		Two entries are expected, see the examples below.
diff --git a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
index fe41bf9..da5e378 100644
--- a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
@@ -186,6 +186,12 @@
 				dma-coherent;
 			};
 
+			thermal@7f008c {
+				compatible = "marvell,armada-ap806-thermal";
+				reg = <0x7f008C 0x4>, <0x7f0084 0x4>;
+				status = "okay";
+			};
+
 			spi0: spi@510600 {
 				compatible = "marvell,armada-380-spi";
 				reg = <0x510600 0x50>;
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index b5b5fac..cf24911 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -300,13 +300,13 @@ config DB8500_THERMAL
 	  thermal zone if trip points reached.
 
 config ARMADA_THERMAL
-	tristate "Armada 370/XP thermal management"
+	tristate "Armada 370/XP/8K thermal management"
 	depends on ARCH_MVEBU || COMPILE_TEST
 	depends on HAS_IOMEM
 	depends on OF
 	help
 	  Enable this option if you want to have support for thermal management
-	  controller present in Armada 370 and Armada XP SoC.
+	  controller present in Armada 370, Armada XP, and Armada 8K SoC.
 
 config DA9062_THERMAL
 	tristate "DA9062/DA9061 Dialog Semiconductor thermal driver"
diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c
index ae75328..44bea5c 100644
--- a/drivers/thermal/armada_thermal.c
+++ b/drivers/thermal/armada_thermal.c
@@ -41,6 +41,15 @@
 #define A375_HW_RESETn			BIT(8)
 #define A380_HW_RESET			BIT(8)
 
+#define AP806_START	BIT(0)
+#define AP806_RESET	BIT(1)
+#define AP806_ENABLE	BIT(2)
+
+/* For AP806 TSEN output format is signed as a 2s complement number
+	ranging from-512 to +511*/
+#define AP806_TSEN_OUTPUT_MSB		512
+#define AP806_TSEN_OUTPUT_COMP		1024
+
 struct armada_thermal_data;
 
 /* Marvell EBU Thermal Sensor Dev Structure */
@@ -68,6 +77,8 @@ struct armada_thermal_data {
 	unsigned int temp_shift;
 	unsigned int temp_mask;
 	unsigned int is_valid_shift;
+
+	struct thermal_zone_device_ops *ops;
 };
 
 static void armadaxp_init_sensor(struct platform_device *pdev,
@@ -147,6 +158,18 @@ static void armada380_init_sensor(struct platform_device *pdev,
 	}
 }
 
+static void armada_ap806_init_sensor(struct platform_device *pdev,
+				  struct armada_thermal_priv *priv)
+{
+	unsigned long reg = readl_relaxed(priv->control);
+
+	reg &= ~AP806_RESET;
+	reg |= AP806_START;
+	reg |= AP806_ENABLE;
+	writel(reg, priv->control);
+	mdelay(10);
+}
+
 static bool armada_is_valid(struct armada_thermal_priv *priv)
 {
 	unsigned long reg = readl_relaxed(priv->sensor);
@@ -183,10 +206,47 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 	return 0;
 }
 
-static struct thermal_zone_device_ops ops = {
+static int armada_ap806_get_temp(struct thermal_zone_device *thermal, int *temp)
+{
+	struct armada_thermal_priv *priv = thermal->devdata;
+	unsigned long reg;
+	unsigned long m, b, div;
+
+	/* Valid check */
+	if (priv->data->is_valid && !priv->data->is_valid(priv)) {
+		dev_err(&thermal->device,
+			"Temperature sensor reading not valid\n");
+		return -EIO;
+	}
+
+	reg = readl_relaxed(priv->sensor);
+	reg = (reg >> priv->data->temp_shift) & priv->data->temp_mask;
+
+	/* TSEN output format is signed as a 2s complement number
+	    ranging from-512 to +511. when MSB is set, need to
+	    calculate the complement number */
+	if (reg >= AP806_TSEN_OUTPUT_MSB)
+		reg = reg - AP806_TSEN_OUTPUT_COMP;
+
+	/* Get formula coeficients */
+	b = priv->data->coef_b;
+	m = priv->data->coef_m;
+	div = priv->data->coef_div;
+
+	*temp = ((m * reg) + b) / div;
+
+	return 0;
+}
+
+static struct thermal_zone_device_ops armada_ops = {
 	.get_temp = armada_get_temp,
 };
 
+static struct thermal_zone_device_ops armada_ap806_ops = {
+	.get_temp = armada_ap806_get_temp,
+};
+
+
 static const struct armada_thermal_data armadaxp_data = {
 	.init_sensor = armadaxp_init_sensor,
 	.temp_shift = 10,
@@ -194,6 +254,7 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 	.coef_b = 3153000000UL,
 	.coef_m = 10000000UL,
 	.coef_div = 13825,
+	.ops = &armada_ops,
 };
 
 static const struct armada_thermal_data armada370_data = {
@@ -205,6 +266,7 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 	.coef_b = 3153000000UL,
 	.coef_m = 10000000UL,
 	.coef_div = 13825,
+	.ops = &armada_ops,
 };
 
 static const struct armada_thermal_data armada375_data = {
@@ -216,6 +278,7 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 	.coef_b = 3171900000UL,
 	.coef_m = 10000000UL,
 	.coef_div = 13616,
+	.ops = &armada_ops,
 };
 
 static const struct armada_thermal_data armada380_data = {
@@ -228,8 +291,23 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 	.coef_m = 2000096UL,
 	.coef_div = 4201,
 	.inverted = true,
+	.ops = &armada_ops,
+};
+
+static const struct armada_thermal_data armada_ap806_data = {
+	.is_valid = armada_is_valid,
+	.init_sensor = armada_ap806_init_sensor,
+	.is_valid_shift = 16,
+	.temp_shift = 0,
+	.temp_mask = 0x3ff,
+	.coef_b = 153400,
+	.coef_m = 425,
+	.coef_div = 1000,
+	.inverted = true,
+	.ops = &armada_ap806_ops,
 };
 
+
 static const struct of_device_id armada_thermal_id_table[] = {
 	{
 		.compatible = "marvell,armadaxp-thermal",
@@ -248,6 +326,10 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 		.data       = &armada380_data,
 	},
 	{
+		.compatible = "marvell,armada-ap806-thermal",
+		.data       = &armada_ap806_data,
+	},
+	{
 		/* sentinel */
 	},
 };
@@ -282,7 +364,7 @@ static int armada_thermal_probe(struct platform_device *pdev)
 	priv->data->init_sensor(pdev, priv);
 
 	thermal = thermal_zone_device_register("armada_thermal", 0, 0,
-					       priv, &ops, NULL, 0, 0);
+					       priv, priv->data->ops, NULL, 0, 0);
 	if (IS_ERR(thermal)) {
 		dev_err(&pdev->dev,
 			"Failed to register thermal zone device\n");
-- 
1.7.9.5


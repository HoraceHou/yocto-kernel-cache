From 78cdf1c9c776a3da6ab9646afcaaa17a15a88eb3 Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Sun, 8 Jan 2017 18:52:18 +0200
Subject: [PATCH 0718/1345] fix: net: mvpp2x: fix traffic stuck due to changed
 CPU ID in TX path

commit  258f384f807c2c918220950811214947e638ae56 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Issue:
- Driver set netdev_queue accordingly to CPU ID in .ndo_select_queue
  callback. Due to preemption capability, procedure could move to
  another CPU between .ndo_select_queue and .ndo_start_xmit callbacks.
  This will cause stop of wrong netdev_queue and traffic stuck.

Fix:
1. Prevent shadow_q override by moving TXQ free count check to start
   of xmit procedure.

2. Drop packet if TXQ free count is below TXQ stop limit and TXQ
   stopped only if current CPU ID is equal to sender CPU.

Change-Id: Ic260604c4feb0e74d37402d5a3beac45f8a41079
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35386
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |   27 +++++++++-----------
 1 file changed, 12 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 8b539f5..a02df69 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -2688,7 +2688,7 @@ static inline int mv_pp2_tx_tso(struct sk_buff *skb, struct net_device *dev,
 			 struct mv_pp2x_aggr_tx_queue *aggr_txq, int cpu)
 {
 	int frag = 0, i;
-	int total_len, hdr_len, size, frag_size, data_left, txq_id;
+	int total_len, hdr_len, size, frag_size, data_left;
 	int total_desc_num, total_bytes = 0, max_desc_num = 0;
 	char *frag_ptr;
 	struct mv_pp2x_tx_desc *tx_desc;
@@ -2698,14 +2698,10 @@ static inline int mv_pp2_tx_tso(struct sk_buff *skb, struct net_device *dev,
 	u32 tcp_seq = 0;
 	skb_frag_t *skb_frag_ptr;
 	const struct tcphdr *th = tcp_hdr(skb);
-	struct netdev_queue *nq;
 
 	if (mv_pp2_tso_validate(skb, dev))
 		return 0;
 
-	txq_id = skb_get_queue_mapping(skb) % mv_pp2x_txq_number;
-	nq = netdev_get_tx_queue(dev, (txq_id + (cpu * mv_pp2x_txq_number)));
-
 	/* Calculate expected number of TX descriptors */
 	max_desc_num = skb_shinfo(skb)->gso_segs * 2 + skb_shinfo(skb)->nr_frags;
 
@@ -2825,10 +2821,6 @@ static inline int mv_pp2_tx_tso(struct sk_buff *skb, struct net_device *dev,
 		}
 	}
 
-	/* Prevent shadow_q override, stop tx_queue until tx_done is called*/
-	if (mv_pp2x_txq_free_count(txq_pcpu) < port->txq_stop_limit)
-		netif_tx_stop_queue(nq);
-
 	/* TCP segment is ready - transmit it */
 	mv_pp2x_aggr_txq_pend_desc_add(port, total_desc_num);
 
@@ -2881,11 +2873,20 @@ static int mv_pp2x_tx(struct sk_buff *skb, struct net_device *dev)
 
 	/* Set relevant physical TxQ and Linux netdev queue */
 	txq_id = skb_get_queue_mapping(skb) % mv_pp2x_txq_number;
-	nq = netdev_get_tx_queue(dev, (txq_id + (cpu * mv_pp2x_txq_number)));
 	txq = port->txqs[txq_id];
 	txq_pcpu = this_cpu_ptr(txq->pcpu);
 	aggr_txq = &port->priv->aggr_txqs[cpu];
 
+	/* Prevent shadow_q override, stop tx_queue until tx_done is called*/
+	if (mv_pp2x_txq_free_count(txq_pcpu) < port->txq_stop_limit) {
+		if (cpu == skb->sender_cpu) {
+			nq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
+			netif_tx_stop_queue(nq);
+		}
+		frags = 0;
+		goto out;
+	}
+
 	/* GSO/TSO */
 	if (skb_is_gso(skb)) {
 		frags = mv_pp2_tx_tso(skb, dev, txq, aggr_txq, cpu);
@@ -2984,12 +2985,8 @@ static int mv_pp2x_tx(struct sk_buff *skb, struct net_device *dev)
 	mv_pp2_is_pkt_ptp_tx_proc(port, tx_desc, skb);
 #endif
 
-	/* Prevent shadow_q override, stop tx_queue until tx_done is called*/
-
-	if (mv_pp2x_txq_free_count(txq_pcpu) < port->txq_stop_limit)
-		netif_tx_stop_queue(nq);
 	/* Enable transmit */
-	if (!skb->xmit_more || netif_xmit_stopped(nq)) {
+	if (!skb->xmit_more) {
 		mv_pp2x_aggr_txq_pend_desc_add(port, aggr_txq->xmit_bulk);
 		aggr_txq->xmit_bulk = 0;
 	}
-- 
1.7.9.5


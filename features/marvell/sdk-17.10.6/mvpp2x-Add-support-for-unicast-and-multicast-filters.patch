From a511b927bcd746794b3ee43465e6b7b5c40940bd Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 20 Jul 2016 23:43:44 +0800
Subject: [PATCH 0369/1345] mvpp2x: Add support for unicast and multicast
 filters (IFF_UNICAST_FLT)

commit  44fe2b5838e882d7aa48c6a5809693e4c6bfc327 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

1) The sum of UC and MC filter size is upto 36 per port
2) A parameter of uc_filter_max added to set max size of UC list
3) The value of uc_filter_max should be multiple of 4
4) The max size of MC filter list is (36-uc_filter_max)
5) If UC list size exceeds uc_filter_max,dev is put in promisc mode
6) If MC list size exceeds (36-uc_filter_max),dev is put in allmulti mode

Change-Id: I9ea099d5c3415f2d196cde25fb986719eb0ed45b
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/31273
Reviewed-by: Yuval Caduri <cyuval@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Tested-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |    2 +
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c   |  131 ++++++++++++++------
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h   |    6 +-
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |   26 +++-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |  106 ++++++++++++----
 5 files changed, 210 insertions(+), 61 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index 40a15fa..4673112 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -458,6 +458,8 @@ struct mv_pp2x_param_config {
 	u32 rx_cpu_map; /* The CPU that port bind, each port has a nibble
 			* indexed by port_id, nibble value is CPU id
 			*/
+	u8 uc_filter_max; /* The unicast filter list max, multiple of 4 */
+	u8 mc_filter_max; /* The multicast filter list max, multiple of 4 */
 };
 
 /* Shared Packet Processor resources */
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
index cd25363..e1a4b5a 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
@@ -2431,8 +2431,8 @@ static bool mv_pp2x_prs_mac_range_equals(struct mv_pp2x_prs_entry *pe,
 	mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_MAC);
 
 	/* Go through the all entires with MVPP2_PRS_LU_MAC */
-	for (tid = MVPP2_PE_FIRST_FREE_TID;
-	     tid <= MVPP2_PE_LAST_FREE_TID; tid++) {
+	for (tid = MVPP2_PE_MAC_RANGE_START;
+	     tid <= MVPP2_PE_MAC_RANGE_END; tid++) {
 		unsigned int entry_pmap;
 
 		if (!hw->prs_shadow[tid].valid ||
@@ -2453,16 +2453,15 @@ static bool mv_pp2x_prs_mac_range_equals(struct mv_pp2x_prs_entry *pe,
 }
 
 /* Update parser's mac da entry */
-int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_hw *hw, int port,
-				   const u8 *da, bool add)
+int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_port *port, const u8 *da, bool add)
 {
 	struct mv_pp2x_prs_entry *pe;
-	unsigned int pmap, len, ri;
+	unsigned int pmap, len, ri, tid;
 	unsigned char mask[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-	int tid;
+	struct mv_pp2x_hw *hw = &port->priv->hw;
 
 	/* Scan TCAM and see if entry with this <MAC DA, port> already exist */
-	pe = mv_pp2x_prs_mac_da_range_find(hw, (1 << port), da, mask,
+	pe = mv_pp2x_prs_mac_da_range_find(hw, (1 << port->id), da, mask,
 					   MVPP2_PRS_UDF_MAC_DEF);
 
 	/* No such entry */
@@ -2471,18 +2470,9 @@ int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_hw *hw, int port,
 			return 0;
 
 		/* Create new TCAM entry */
-		/* Find first range mac entry*/
-		for (tid = MVPP2_PE_FIRST_FREE_TID;
-		     tid <= MVPP2_PE_LAST_FREE_TID; tid++)
-			if (hw->prs_shadow[tid].valid &&
-			    (hw->prs_shadow[tid].lu == MVPP2_PRS_LU_MAC) &&
-			    (hw->prs_shadow[tid].udf ==
-						       MVPP2_PRS_UDF_MAC_RANGE))
-				break;
-
-		/* Go through the all entries from first to last */
-		tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_FIRST_FREE_TID,
-						  tid - 1);
+		/* Go through all entries from first to last in MAC range */
+		tid = mv_pp2x_prs_tcam_first_free(hw, MVPP2_PE_MAC_RANGE_START,
+						  MVPP2_PE_MAC_RANGE_END);
 		if (tid < 0)
 			return tid;
 
@@ -2497,7 +2487,7 @@ int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_hw *hw, int port,
 	}
 
 	/* Update port mask */
-	mv_pp2x_prs_tcam_port_set(pe, port, add);
+	mv_pp2x_prs_tcam_port_set(pe, port->id, add);
 
 	/* Invalidate the entry if no ports are left enabled */
 	pmap = mv_pp2x_prs_tcam_port_map_get(pe);
@@ -2526,7 +2516,10 @@ int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_hw *hw, int port,
 	else if (is_multicast_ether_addr(da))
 		ri = MVPP2_PRS_RI_L2_MCAST;
 	else
-		ri = MVPP2_PRS_RI_L2_UCAST | MVPP2_PRS_RI_MAC_ME_MASK;
+		ri = MVPP2_PRS_RI_L2_UCAST;
+	/* Set M2M */
+	if (ether_addr_equal(da, port->dev->dev_addr))
+		ri |= MVPP2_PRS_RI_MAC_ME_MASK;
 
 	mv_pp2x_prs_sram_ri_update(pe, ri, MVPP2_PRS_RI_L2_CAST_MASK |
 				   MVPP2_PRS_RI_MAC_ME_MASK);
@@ -2550,33 +2543,75 @@ int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_hw *hw, int port,
 int mv_pp2x_prs_update_mac_da(struct net_device *dev, const u8 *da)
 {
 	struct mv_pp2x_port *port = netdev_priv(dev);
+	u8 old_da[ETH_ALEN];
 	int err;
 
-	/* Remove old parser entry */
-	err = mv_pp2x_prs_mac_da_accept(&port->priv->hw,
-		port->id, dev->dev_addr, false);
-	if (err)
-		return err;
+	if (ether_addr_equal(da, dev->dev_addr))
+		return 0;
 
-	/* Add new parser entry */
-	err = mv_pp2x_prs_mac_da_accept(&port->priv->hw, port->id, da, true);
+	/* Record old DA */
+	ether_addr_copy(old_da, dev->dev_addr);
+
+	/* Remove old parser entry */
+	err = mv_pp2x_prs_mac_da_accept(port, dev->dev_addr, false);
 	if (err)
 		return err;
 
 	/* Set addr in the device */
 	ether_addr_copy(dev->dev_addr, da);
 
+	/* Add new parser entry */
+	err = mv_pp2x_prs_mac_da_accept(port, da, true);
+	if (err) {
+		/* Restore addr in the device */
+		ether_addr_copy(dev->dev_addr, old_da);
+		return err;
+	}
+
 	return 0;
 }
 
-/* Delete all port's multicast simple (not range) entries */
-void mv_pp2x_prs_mcast_del_all(struct mv_pp2x_hw *hw, int port)
+static bool mv_pp2x_mac_in_uc_list(struct net_device *dev, const u8 *da)
+{
+	struct netdev_hw_addr *ha;
+
+	if (!netdev_uc_count(dev))
+		return false;
+
+	netdev_for_each_uc_addr(ha, dev) {
+		if (ether_addr_equal(da, dev->dev_addr))
+			return true;
+	}
+
+	return false;
+}
+
+static bool mv_pp2x_mac_in_mc_list(struct net_device *dev, const u8 *da)
+{
+	struct netdev_hw_addr *ha;
+
+	if (!netdev_mc_count(dev))
+		return false;
+
+	netdev_for_each_mc_addr(ha, dev) {
+		if (ether_addr_equal(da, dev->dev_addr))
+			return true;
+	}
+
+	return false;
+}
+
+/* Delete port's uc/mc/bc simple (not range) entries with options */
+void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
+			       enum mv_pp2x_l2_cast l2_cast,
+			       enum mv_pp2x_mac_del_option op)
 {
 	struct mv_pp2x_prs_entry pe;
+	struct mv_pp2x_hw *hw = &port->priv->hw;
 	int index, tid;
 
-	for (tid = MVPP2_PE_FIRST_FREE_TID;
-	     tid <= MVPP2_PE_LAST_FREE_TID; tid++) {
+	for (tid = MVPP2_PE_MAC_RANGE_START;
+	     tid <= MVPP2_PE_MAC_RANGE_END; tid++) {
 		unsigned char da[ETH_ALEN], da_mask[ETH_ALEN];
 
 		if (!hw->prs_shadow[tid].valid ||
@@ -2592,10 +2627,34 @@ void mv_pp2x_prs_mcast_del_all(struct mv_pp2x_hw *hw, int port)
 		for (index = 0; index < ETH_ALEN; index++)
 			mv_pp2x_prs_tcam_data_byte_get(&pe, index, &da[index],
 						       &da_mask[index]);
-
-		if (is_multicast_ether_addr(da) && !is_broadcast_ether_addr(da))
-			/* Delete this entry */
-			mv_pp2x_prs_mac_da_accept(hw, port, da, false);
+		switch (l2_cast) {
+		case MVPP2_PRS_MAC_UC:
+			/* Do not delete M2M entry */
+			if (is_unicast_ether_addr(da) &&
+			    !ether_addr_equal(da, port->dev->dev_addr)) {
+				if (op == MVPP2_DEL_MAC_NOT_IN_LIST &&
+				    mv_pp2x_mac_in_uc_list(port->dev, da))
+					continue;
+				/* Delete this entry */
+				mv_pp2x_prs_mac_da_accept(port, da, false);
+			}
+			break;
+		case MVPP2_PRS_MAC_MC:
+			if (is_multicast_ether_addr(da) &&
+			    !is_broadcast_ether_addr(da)) {
+				if (op == MVPP2_DEL_MAC_NOT_IN_LIST &&
+				    mv_pp2x_mac_in_mc_list(port->dev, da))
+					continue;
+				/* Delete this entry */
+				mv_pp2x_prs_mac_da_accept(port, da, false);
+			}
+			break;
+		case MVPP2_PRS_MAC_BC:
+			if (is_broadcast_ether_addr(da))
+				/* Delete this entry */
+				mv_pp2x_prs_mac_da_accept(port, da, false);
+			break;
+		}
 	}
 }
 
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
index 5805b15..cc33948 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
@@ -524,11 +524,13 @@ int mv_pp2x_prs_default_init(struct platform_device *pdev,
 void mv_pp2x_prs_mac_promisc_set(struct mv_pp2x_hw *hw, int port, bool add);
 void mv_pp2x_prs_mac_multi_set(struct mv_pp2x_hw *hw, int port, int index,
 			       bool add);
-int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_hw *hw, int port,
+int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_port *port,
 			      const u8 *da, bool add);
 int mv_pp2x_prs_def_flow(struct mv_pp2x_port *port);
 int mv_pp2x_prs_flow_set(struct mv_pp2x_port *port);
-void mv_pp2x_prs_mcast_del_all(struct mv_pp2x_hw *hw, int port);
+void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
+			       enum mv_pp2x_l2_cast l2_cast,
+			       enum mv_pp2x_mac_del_option op);
 int mv_pp2x_prs_tag_mode_set(struct mv_pp2x_hw *hw, int port, int type);
 int mv_pp2x_prs_update_mac_da(struct net_device *dev, const u8 *da);
 void mv_pp2x_prs_flow_id_attr_init(void);
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 964c18d..638bfff 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1296,6 +1296,15 @@ enum mv_pp2x_tag_type {
 #define MVPP2_PRS_TCAM_PROTO_MASK_L	0x3f
 #define MVPP2_PRS_DBL_VLANS_MAX		100
 
+/* There is TCAM range reserved for MAC entries, range size is 113
+ * 1 BC MAC entry for all ports
+ * 4 M2M entries, 1 entry per port, and 4 ports in all
+ * 36 UC/MC MAC filter entries per port
+ * It is assumed that there are 3 ports for filter, not including loopback port
+ */
+#define MVPP2_PRS_MAC_UC_MC_FILT_MAX	36
+#define MVPP2_PRS_MAC_RANGE_SIZE	113
+
 /* Tcam structure:
  * - lookup ID - 4 bits
  * - port ID - 1 byte
@@ -1316,7 +1325,10 @@ enum mv_pp2x_tag_type {
 /* Tcam entries ID */
 #define MVPP2_PE_DROP_ALL		0
 #define MVPP2_PE_FIRST_FREE_TID		1
-#define MVPP2_PE_LAST_FREE_TID		(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
+#define MVPP2_PE_MAC_RANGE_END		(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
+#define MVPP2_PE_MAC_RANGE_START	(MVPP2_PE_MAC_RANGE_END -\
+					 MVPP2_PRS_MAC_RANGE_SIZE + 1)
+#define MVPP2_PE_LAST_FREE_TID		(MVPP2_PE_MAC_RANGE_START - 1)
 #define MVPP2_PE_IP6_EXT_PROTO_UN	(MVPP2_PRS_TCAM_SRAM_SIZE - 30)
 #define MVPP2_PE_MAC_MC_IP6		(MVPP2_PRS_TCAM_SRAM_SIZE - 29)
 #define MVPP2_PE_IP6_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 28)
@@ -1599,6 +1611,13 @@ enum mv_pp2x_prs_udf {
 	MVPP2_PRS_UDF_L2_USER,
 };
 
+/* L2 cast in parser result info */
+enum mv_pp2x_l2_cast {
+	MVPP2_PRS_MAC_UC,
+	MVPP2_PRS_MAC_MC,
+	MVPP2_PRS_MAC_BC,
+};
+
 /* Lookup ID */
 enum mv_pp2x_prs_lookup {
 	MVPP2_PRS_LU_MH,
@@ -1693,6 +1712,11 @@ enum mv_pp2x_rss_hash_mode {
 	MVPP2_RSS_HASH_5T,
 };
 
+enum mv_pp2x_mac_del_option {
+	MVPP2_DEL_MAC_ALL = 0,
+	MVPP2_DEL_MAC_NOT_IN_LIST,
+};
+
 struct mv_pp2x_prs_result_info {
 	u32 ri;
 	u32 ri_mask;
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 58af52c..7a8bf99 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -85,6 +85,7 @@
 static u8 first_bm_pool;
 static u8 first_addr_space;
 static u8 first_log_rxq_queue;
+static u8 uc_filter_max = 4;
 
 u32 debug_param;
 
@@ -119,6 +120,10 @@
 module_param(buffer_scaling, ushort, S_IRUGO);
 MODULE_PARM_DESC(buffer_scaling, "Buffer scaling (TBD)");
 
+module_param(uc_filter_max, byte, S_IRUGO);
+MODULE_PARM_DESC(uc_filter_max,
+		 "Set unicast filter max size, it is multiple of 4. def=4");
+
 module_param(debug_param, uint, S_IRUGO);
 MODULE_PARM_DESC(debug_param,
 	"Ad-hoc parameter, which can be used for various debug operations.");
@@ -2886,14 +2891,13 @@ int mv_pp2x_open_cls(struct net_device *dev)
 		return err;
 	}
 
-	err = mv_pp2x_prs_mac_da_accept(hw, port->id, mac_bcast, true);
+	err = mv_pp2x_prs_mac_da_accept(port, mac_bcast, true);
 	if (err) {
 		netdev_err(dev, "mv_pp2x_prs_mac_da_accept BC failed\n");
 		return err;
 	}
 
-	err = mv_pp2x_prs_mac_da_accept(hw, port->id,
-				      dev->dev_addr, true);
+	err = mv_pp2x_prs_mac_da_accept(port, dev->dev_addr, true);
 	if (err) {
 		netdev_err(dev, "mv_pp2x_prs_mac_da_accept M2M failed\n");
 		return err;
@@ -3071,6 +3075,36 @@ int mv_pp2x_stop(struct net_device *dev)
 	return 0;
 }
 
+static void mv_pp2x_set_rx_promisc(struct mv_pp2x_port *port)
+{
+	struct mv_pp2x_hw *hw = &port->priv->hw;
+	int id = port->id;
+
+	/* Accept all: Multicast + Unicast */
+	mv_pp2x_prs_mac_multi_set(hw, id, MVPP2_PE_MAC_MC_ALL, true);
+	mv_pp2x_prs_mac_multi_set(hw, id, MVPP2_PE_MAC_MC_IP6, true);
+	/* Enter promisc mode */
+	mv_pp2x_prs_mac_promisc_set(hw, id, true);
+	/* Remove all port->id's mcast enries */
+	mv_pp2x_prs_mac_entry_del(port, MVPP2_PRS_MAC_MC, MVPP2_DEL_MAC_ALL);
+	/* Remove all port->id's ucast enries except M2M entry */
+	mv_pp2x_prs_mac_entry_del(port, MVPP2_PRS_MAC_UC, MVPP2_DEL_MAC_ALL);
+}
+
+static void mv_pp2x_set_rx_allmulti(struct mv_pp2x_port *port)
+{
+	struct mv_pp2x_hw *hw = &port->priv->hw;
+	int id = port->id;
+
+	/* Accept all multicast */
+	mv_pp2x_prs_mac_multi_set(hw, id,
+				  MVPP2_PE_MAC_MC_ALL, true);
+	mv_pp2x_prs_mac_multi_set(hw, id,
+				  MVPP2_PE_MAC_MC_IP6, true);
+	/* Remove all multicast filter entries from parser */
+	mv_pp2x_prs_mac_entry_del(port, MVPP2_PRS_MAC_MC, MVPP2_DEL_MAC_ALL);
+}
+
 /* register unicast and multicast addresses */
 static void mv_pp2x_set_rx_mode(struct net_device *dev)
 {
@@ -3081,28 +3115,51 @@ static void mv_pp2x_set_rx_mode(struct net_device *dev)
 	int err;
 
 	if (dev->flags & IFF_PROMISC) {
-		/* Accept all: Multicast + Unicast */
-		mv_pp2x_prs_mac_multi_set(hw, id, MVPP2_PE_MAC_MC_ALL, true);
-		mv_pp2x_prs_mac_multi_set(hw, id, MVPP2_PE_MAC_MC_IP6, true);
-		/* Remove all port->id's mcast enries */
-		mv_pp2x_prs_mcast_del_all(hw, id);
-		/* Enter promisc mode */
-		mv_pp2x_prs_mac_promisc_set(hw, id, true);
+		mv_pp2x_set_rx_promisc(port);
 	} else {
+		/* Put dev into promisc if MAC num greater than uc filter max */
+		if (netdev_uc_count(dev) > port->priv->pp2_cfg.uc_filter_max) {
+			mv_pp2x_set_rx_promisc(port);
+			return;
+		}
+		/* Remove old enries not in uc list except M2M entry */
+		mv_pp2x_prs_mac_entry_del(port,
+					  MVPP2_PRS_MAC_UC,
+					  MVPP2_DEL_MAC_NOT_IN_LIST);
+		/* Add all entries into to uc mac addr filter list */
+		netdev_for_each_uc_addr(ha, dev) {
+			err = mv_pp2x_prs_mac_da_accept(port,
+							ha->addr, true);
+			if (err)
+				netdev_err(dev,
+					   "[%2x:%2x:%2x:%2x:%2x:%x]add fail\n",
+					   ha->addr[0], ha->addr[1],
+					   ha->addr[2], ha->addr[3],
+					   ha->addr[4], ha->addr[5]);
+		}
+		/* Leave promisc mode */
+		mv_pp2x_prs_mac_promisc_set(hw, id, false);
+
 		if (dev->flags & IFF_ALLMULTI) {
-			/* Accept all multicast */
-			mv_pp2x_prs_mac_multi_set(hw, id,
-						  MVPP2_PE_MAC_MC_ALL, true);
-			mv_pp2x_prs_mac_multi_set(hw, id,
-						  MVPP2_PE_MAC_MC_IP6, true);
-			/* Remove all port->id's mcast enries */
-			mv_pp2x_prs_mcast_del_all(hw, id);
+			mv_pp2x_set_rx_allmulti(port);
 		} else {
-			/* Accept only initialized multicast */
+			/* Put dev allmulti if MAC num exceeds mc filter max */
+			if (netdev_mc_count(dev) >
+					port->priv->pp2_cfg.mc_filter_max) {
+				mv_pp2x_set_rx_allmulti(port);
+				return;
+			}
+			/* Remove old mcast entries not in mc list */
+			mv_pp2x_prs_mac_entry_del(port,
+						  MVPP2_PRS_MAC_MC,
+						  MVPP2_DEL_MAC_NOT_IN_LIST);
+			/* Add all entries into to mc mac filter list */
 			if (!netdev_mc_empty(dev)) {
 				netdev_for_each_mc_addr(ha, dev) {
-					err = mv_pp2x_prs_mac_da_accept(hw,
-							id, ha->addr, true);
+					err =
+					mv_pp2x_prs_mac_da_accept(port,
+								  ha->addr,
+								  true);
 					if (err)
 						netdev_err(dev,
 						"MAC[%2x:%2x:%2x:%2x:%2x:%2x] add failed\n",
@@ -3111,13 +3168,12 @@ static void mv_pp2x_set_rx_mode(struct net_device *dev)
 						ha->addr[4], ha->addr[5]);
 				}
 			}
+			/* Reject other MC mac entries */
 			mv_pp2x_prs_mac_multi_set(hw, id,
 						  MVPP2_PE_MAC_MC_ALL, false);
 			mv_pp2x_prs_mac_multi_set(hw, id,
 						  MVPP2_PE_MAC_MC_IP6, false);
 		}
-		/* Leave promisc mode */
-		mv_pp2x_prs_mac_promisc_set(hw, id, false);
 	}
 }
 
@@ -3861,6 +3917,9 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	if (mv_pp2x_queue_mode)
 		dev->hw_features |= NETIF_F_RXHASH;
 	dev->vlan_features |= features;
+
+	dev->priv_flags |= IFF_UNICAST_FLT;
+
 	err = register_netdev(dev);
 	if (err < 0) {
 		dev_err(&pdev->dev, "failed to register netdev\n");
@@ -4156,6 +4215,9 @@ static void mv_pp2x_init_config(struct mv_pp2x_param_config *pp2_cfg,
 	pp2_cfg->rss_cfg.rss_mode = rss_mode;
 
 	pp2_cfg->rx_cpu_map = port_cpu_bind_map;
+
+	pp2_cfg->uc_filter_max = uc_filter_max;
+	pp2_cfg->mc_filter_max = MVPP2_PRS_MAC_UC_MC_FILT_MAX - uc_filter_max;
 }
 
 static void mv_pp2x_init_rxfhindir(struct mv_pp2x *pp2)
-- 
1.7.9.5


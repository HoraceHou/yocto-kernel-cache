From eafffde2fcf8747c46c62ab41571333d18e226af Mon Sep 17 00:00:00 2001
From: Alan Winkowski <walan@marvell.com>
Date: Tue, 14 Mar 2017 13:16:22 +0200
Subject: [PATCH 0874/1345] mvpp2x: add support for vlan filtering

commit  390aa49edf7b52a9e9188e689afd7ff63df85e28 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- new netdev_ops supported:
	- ndo_vlan_rx_add_vid
	- ndo_vlan_rx_kill_vid

- number of supported MAC filtering entries reduced from 36
  to 25 per port

Change-Id: Iaed58df42bf0cf69fdee6bb3681f2502adef5cc2
Signed-off-by: Alan Winkowski <walan@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37443
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c   |  255 +++++++++++++++++++-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h   |    1 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |   62 +++--
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |    6 +
 4 files changed, 296 insertions(+), 28 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
index cac96df..70d976e 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
@@ -636,6 +636,14 @@ static void mv_pp2x_prs_match_etype(struct mv_pp2x_prs_entry *pe, int offset,
 	mv_pp2x_prs_tcam_data_byte_set(pe, offset + 1, ethertype & 0xff, 0xff);
 }
 
+/* Set vid in tcam sw entry */
+static void mv_pp2x_prs_match_vid(struct mv_pp2x_prs_entry *pe, int offset, unsigned short vid)
+{
+	mv_pp2x_prs_tcam_data_byte_set(pe, offset + 0, ((vid & MVPP2_PRS_VID_H_WORD) >>
+							MVPP2_PRS_VID_H_WORD_SHIFT), MVPP2_PRS_VID_H_WORD_MASK);
+	mv_pp2x_prs_tcam_data_byte_set(pe, offset + 1, vid & MVPP2_PRS_VID_L_WORD_MASK, MVPP2_PRS_VID_L_WORD_MASK);
+}
+
 /* Set bits in sram sw entry */
 static void mv_pp2x_prs_sram_bits_set(struct mv_pp2x_prs_entry *pe, int bit_num,
 				      int val)
@@ -1231,10 +1239,10 @@ static int mv_pp2x_prs_vlan_add(struct mv_pp2x_hw *hw, unsigned short tpid,
 
 		mv_pp2x_prs_match_etype(pe, 0, tpid);
 
-		mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
-		/* Shift 4 bytes - skip 1 vlan tag */
-		mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN,
-					   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+		mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_VID);
+
+		/* Do not shift now, will be shifted after VID is checked*/
+
 		/* Clear all ai bits for next iteration */
 		mv_pp2x_prs_sram_ai_update(pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 
@@ -1376,8 +1384,8 @@ static int mv_pp2x_prs_double_vlan_add(struct mv_pp2x_hw *hw,
 		mv_pp2x_prs_match_etype(pe, 4, tpid2);
 
 		mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_VLAN);
-		/* Shift 8 bytes - skip 2 vlan tags */
-		mv_pp2x_prs_sram_shift_set(pe, 2 * MVPP2_VLAN_TAG_LEN,
+		/* Shift 4 bytes - skip outer vlan tags */
+		mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN,
 					   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
 		mv_pp2x_prs_sram_ri_update(pe, MVPP2_PRS_RI_VLAN_DOUBLE,
 					   MVPP2_PRS_RI_VLAN_MASK);
@@ -2028,7 +2036,10 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VLAN);
 	pe.index = MVPP2_PE_VLAN_DBL;
 
-	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_L2);
+	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_VID);
+
+	/* Do not update offset, it is already positioned to inner vlan by double vlan parser entry*/
+
 	/* Clear ai for next iterations */
 	mv_pp2x_prs_sram_ai_update(&pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 	mv_pp2x_prs_sram_ri_update(&pe, MVPP2_PRS_RI_VLAN_DOUBLE,
@@ -2062,6 +2073,30 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 	return 0;
 }
 
+/* Initialize parser entries for VID filtering */
+static void mv_pp2x_prs_vid_init(struct mv_pp2x_hw *hw)
+{
+	struct mv_pp2x_prs_entry pe;
+
+	memset(&pe, 0, sizeof(struct mv_pp2x_prs_entry));
+
+	/* Set default vid  entry */
+	pe.index = MVPP2_PE_VID_FLTR_DEFAULT;
+	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VID);
+
+	/* Skip VLAN header - Set offset to 4 bytes */
+	mv_pp2x_prs_sram_shift_set(&pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_L2);
+
+	/* Unmask all ports */
+	mv_pp2x_prs_tcam_port_map_set(&pe, MVPP2_PRS_PORT_MASK);
+
+	/* Update shadow table and hw entry */
+	mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, &pe);
+}
+
 /* Set entries for PPPoE ethertype */
 static int mv_pp2x_prs_pppoe_init(struct mv_pp2x_hw *hw)
 {
@@ -2656,6 +2691,209 @@ void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
 	}
 }
 
+/* Write parser entry for default VID filtering */
+static int mv_pp2x_prs_vid_drop_entry_accept(struct net_device *dev, unsigned int tid, bool add)
+{
+	struct mv_pp2x_prs_entry *pe;
+	unsigned int pmap;
+	struct mv_pp2x_port *port = netdev_priv(dev);
+	struct mv_pp2x_hw *hw = &port->priv->hw;
+
+	pe = kzalloc(sizeof(*pe), GFP_KERNEL);
+	if (!pe)
+		return -ENOMEM;
+	pe->index = tid;
+
+	if (add) {
+		if (hw->prs_shadow[tid].valid) {
+			pr_info("Default vid drop entry already in place\n");
+			return 0;
+		}
+		mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_VID);
+
+		/* Mask all ports */
+		mv_pp2x_prs_tcam_port_map_set(pe, 0);
+	} else {
+		mv_pp2x_prs_hw_read(hw, pe);
+	}
+
+	/* Update port mask */
+	mv_pp2x_prs_tcam_port_set(pe, port->id, add);
+
+	/* Invalidate the entry if no ports are left enabled */
+	pmap = mv_pp2x_prs_tcam_port_map_get(pe);
+	if (pmap == 0) {
+		if (add) {
+			kfree(pe);
+			return -EPERM;
+		}
+		mv_pp2x_prs_hw_inv(hw, pe->index);
+		hw->prs_shadow[pe->index].valid = false;
+		kfree(pe);
+		return 0;
+	}
+
+	/* Continue - set next lookup */
+	mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
+
+	mv_pp2x_prs_sram_ri_update(pe, MVPP2_PRS_RI_DROP_MASK, MVPP2_PRS_RI_DROP_MASK);
+
+	/* Skip VLAN header - Set offset to 4 bytes */
+	mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Update shadow table */
+	mv_pp2x_prs_shadow_set(hw, pe->index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, pe);
+	kfree(pe);
+	return 0;
+}
+
+/* Return first free tcam index, seeking from start to end */
+static bool mv_pp2x_prs_tcam_vid_empty(struct mv_pp2x_hw *hw, unsigned char start, unsigned char end)
+{
+	int tid;
+
+	if (start > end)
+		swap(start, end);
+
+	for (tid = start; tid <= end; tid++) {
+		if (hw->prs_shadow[tid].valid)
+			return false;
+	}
+	return true;
+}
+
+/* Find tcam entry with matched pair <vid,port> */
+static struct mv_pp2x_prs_entry *
+mv_pp2x_prs_vid_range_find(struct mv_pp2x_hw *hw, int pmap, u16 vid, u16 mask)
+{
+	struct mv_pp2x_prs_entry *pe;
+	unsigned char byte[2], enable[2];
+	u16 rvid, rmask;
+	int tid;
+
+	pe = kzalloc(sizeof(*pe), GFP_KERNEL);
+	if (!pe)
+		return NULL;
+	mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_VID);
+
+	/* Go through the all entires with MVPP2_PRS_LU_VID */
+	for (tid = MVPP2_PE_VID_FILT_RANGE_START;
+	     tid <= MVPP2_PE_VID_FILT_RANGE_END; tid++) {
+		if (!hw->prs_shadow[tid].valid ||
+		    (hw->prs_shadow[tid].lu != MVPP2_PRS_LU_VID))
+			continue;
+
+		pe->index = tid;
+		mv_pp2x_prs_hw_read(hw, pe);
+		mv_pp2x_prs_tcam_data_byte_get(pe, 2, &byte[0], &enable[0]);
+		mv_pp2x_prs_tcam_data_byte_get(pe, 3, &byte[1], &enable[1]);
+		rvid = ((byte[0] & MVPP2_PRS_VID_H_WORD_MASK) << MVPP2_PRS_VID_H_WORD_SHIFT) + byte[1];
+		rmask = ((enable[0] & MVPP2_PRS_VID_H_WORD_MASK) << MVPP2_PRS_VID_H_WORD_SHIFT) + enable[1];
+
+		if ((rvid != vid) || (rmask != mask))
+			continue;
+
+		return pe;
+	}
+	kfree(pe);
+
+	return NULL;
+}
+
+/* Write parser entry for VID filtering */
+int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, bool add)
+{
+	struct mv_pp2x_prs_entry *pe;
+	int tid;
+	int rc;
+	bool empty = false;
+	unsigned int pmap;
+	unsigned int mask = 0xfff;
+	struct mv_pp2x_port *port = netdev_priv(dev);
+	struct mv_pp2x_hw *hw = &port->priv->hw;
+	unsigned int vid_start = MVPP2_PE_VID_FILT_RANGE_START + port->id * MVPP2_PRS_VLAN_FILT_MAX;
+
+	/* Scan TCAM and see if entry with this <vid,port> already exist */
+	pe = mv_pp2x_prs_vid_range_find(hw, (1 << port->id), vid, mask);
+
+	if (vid == 0)
+		/*no need to add vid 0 to HW*/
+		return 0;
+
+	/* No such entry */
+	if (!pe) {
+		if (!add)
+			return 0;
+
+		empty = mv_pp2x_prs_tcam_vid_empty(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX_ENTRY);
+		if (empty) {
+			rc = mv_pp2x_prs_vid_drop_entry_accept(dev, vid_start + MVPP2_PRS_VLAN_FILT_DFLT_ENTRY, true);
+			if (rc) {
+				netdev_err(dev, "failed to add default vid entry for non-match vlan packets (drop)\n");
+				return rc;
+			}
+		}
+
+		/* Create new TCAM entry */
+		/* Go through all entries from first to last in vlan range */
+		tid = mv_pp2x_prs_tcam_first_free(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX_ENTRY);
+
+		if (tid < 0)
+			return tid;
+
+		pe = kzalloc(sizeof(*pe), GFP_KERNEL);
+		if (!pe)
+			return -ENOMEM;
+
+		mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_VID);
+		pe->index = tid;
+
+		/* Mask all ports */
+		mv_pp2x_prs_tcam_port_map_set(pe, 0);
+	}
+
+	/* Update port mask */
+	mv_pp2x_prs_tcam_port_set(pe, port->id, add);
+
+	/* Invalidate the entry if no ports are left enabled */
+	pmap = mv_pp2x_prs_tcam_port_map_get(pe);
+	if (pmap == 0) {
+		if (add) {
+			kfree(pe);
+			return -EPERM;
+		}
+		mv_pp2x_prs_hw_inv(hw, pe->index);
+		hw->prs_shadow[pe->index].valid = false;
+		empty = mv_pp2x_prs_tcam_vid_empty(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX_ENTRY);
+		if (empty) {
+			rc = mv_pp2x_prs_vid_drop_entry_accept(dev, vid_start + MVPP2_PRS_VLAN_FILT_DFLT_ENTRY, false);
+			if (rc) {
+				netdev_err(dev, "failed to remove default vid for non-match vlan packets (drop)\n");
+				return rc;
+			}
+		}
+		kfree(pe);
+		return 0;
+	}
+
+	/* Continue - set next lookup */
+	mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
+
+	/* Set match on VID */
+	mv_pp2x_prs_match_vid(pe, MVPP2_PRS_VID_TCAM_BYTE, vid);
+
+	/* Skip VLAN header - Set offset to 4 bytes */
+	mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Update shadow table */
+	mv_pp2x_prs_shadow_set(hw, pe->index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, pe);
+	kfree(pe);
+
+	return 0;
+}
+
 int mv_pp2x_prs_tag_mode_set(struct mv_pp2x_hw *hw, int port, int type)
 {
 	switch (type) {
@@ -4042,6 +4280,9 @@ int mv_pp2x_prs_default_init(struct platform_device *pdev,
 	err = mv_pp2x_prs_vlan_init(pdev, hw);
 	if (err)
 		return err;
+
+	mv_pp2x_prs_vid_init(hw);
+
 	err = mv_pp2x_prs_pppoe_init(hw);
 	if (err)
 		return err;
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
index 5ce4d52..f8ccac9 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
@@ -535,6 +535,7 @@ void mv_pp2x_prs_mac_multi_set(struct mv_pp2x_hw *hw, int port, int index,
 			       bool add);
 int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_port *port,
 			      const u8 *da, bool add);
+int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, bool add);
 int mv_pp2x_prs_def_flow(struct mv_pp2x_port *port);
 int mv_pp2x_prs_flow_set(struct mv_pp2x_port *port);
 void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 2e56db8..1781d81 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1289,14 +1289,31 @@ enum mv_pp2x_tag_type {
 #define MVPP2_PRS_TCAM_PROTO_MASK_L	0x3f
 #define MVPP2_PRS_DBL_VLANS_MAX		100
 
-/* There is TCAM range reserved for MAC entries, range size is 113
+/* There is a TCAM range reserved for MAC entries, range size is 80
  * 1 BC MAC entry for all ports
  * 4 M2M entries, 1 entry per port, and 4 ports in all
- * 36 UC/MC MAC filter entries per port
+ * 25 UC/MC MAC filter entries per port
  * It is assumed that there are 3 ports for filter, not including loopback port
  */
-#define MVPP2_PRS_MAC_UC_MC_FILT_MAX	36
-#define MVPP2_PRS_MAC_RANGE_SIZE	113
+#define MVPP2_PRS_MAC_UC_MC_FILT_MAX	25
+#define MVPP2_PRS_MAC_RANGE_SIZE	80
+
+/* There is a TCAM range reserved for VLAN filtering entries, range size is 33
+ * 10 VLAN ID filter entries per port
+ * 1 default VLAN filter entry per port
+ * It is assumed that there are 3 ports for filter, not including loopback port
+ */
+#define MVPP2_PRS_VLAN_FILT_MAX		11
+#define MVPP2_PRS_VLAN_FILT_RANGE_SIZE	33
+
+#define MVPP2_PRS_VLAN_FILT_MAX_ENTRY	(MVPP2_PRS_VLAN_FILT_MAX - 2)
+#define MVPP2_PRS_VLAN_FILT_DFLT_ENTRY	(MVPP2_PRS_VLAN_FILT_MAX - 1)
+
+#define MVPP2_PRS_VID_H_WORD		0xf00
+#define MVPP2_PRS_VID_H_WORD_MASK	0xf
+#define MVPP2_PRS_VID_H_WORD_SHIFT	8
+#define MVPP2_PRS_VID_L_WORD_MASK	0xff
+#define MVPP2_PRS_VID_TCAM_BYTE		2
 
 /* Tcam structure:
  * - lookup ID - 4 bits
@@ -1318,29 +1335,31 @@ enum mv_pp2x_tag_type {
 /* Tcam entries ID */
 #define MVPP2_PE_DROP_ALL		0
 #define MVPP2_PE_FIRST_FREE_TID		1
-#define MVPP2_PE_MAC_RANGE_END		(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
-#define MVPP2_PE_MAC_RANGE_START	(MVPP2_PE_MAC_RANGE_END -\
-					 MVPP2_PRS_MAC_RANGE_SIZE + 1)
+#define MVPP2_PE_MAC_RANGE_END		(MVPP2_PE_VID_FILT_RANGE_START - 1)
+#define MVPP2_PE_MAC_RANGE_START	(MVPP2_PE_MAC_RANGE_END - MVPP2_PRS_MAC_RANGE_SIZE + 1)
+#define MVPP2_PE_VID_FILT_RANGE_END	(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
+#define MVPP2_PE_VID_FILT_RANGE_START	(MVPP2_PE_VID_FILT_RANGE_END - MVPP2_PRS_VLAN_FILT_RANGE_SIZE + 1)
 #define MVPP2_PE_LAST_FREE_TID		(MVPP2_PE_MAC_RANGE_START - 1)
 #define MVPP2_PE_IP6_EXT_PROTO_UN	(MVPP2_PRS_TCAM_SRAM_SIZE - 30)
 #define MVPP2_PE_MAC_MC_IP6		(MVPP2_PRS_TCAM_SRAM_SIZE - 29)
 #define MVPP2_PE_IP6_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 28)
 #define MVPP2_PE_IP4_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 27)
 #define MVPP2_PE_LAST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 26)
-#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 19)
-#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 18)
-#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 17)
-#define MVPP2_PE_DSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 16)
-#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 15)
-#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
-#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
-#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
-#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
-#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 10)
-#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 9)
-#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
-#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
-#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
+#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 20)
+#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 19)
+#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 18)
+#define MVPP2_PE_DSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 17)
+#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 16)
+#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 15)
+#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
+#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
+#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
+#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
+#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 10)
+#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 9)
+#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
+#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
+#define MVPP2_PE_VID_FLTR_DEFAULT	(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
 #define MVPP2_PE_VLAN_DBL		(MVPP2_PRS_TCAM_SRAM_SIZE - 5)
 #define MVPP2_PE_VLAN_NONE		(MVPP2_PRS_TCAM_SRAM_SIZE - 4)
 #define MVPP2_PE_MAC_MC_ALL		(MVPP2_PRS_TCAM_SRAM_SIZE - 3)
@@ -1617,6 +1636,7 @@ enum mv_pp2x_prs_lookup {
 	MVPP2_PRS_LU_MAC,
 	MVPP2_PRS_LU_DSA,
 	MVPP2_PRS_LU_VLAN,
+	MVPP2_PRS_LU_VID,
 	MVPP2_PRS_LU_L2,
 	MVPP2_PRS_LU_PPPOE,
 	MVPP2_PRS_LU_IP4,
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index dbaf6d1..8cdf8e3 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -37,6 +37,7 @@
 #include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/phy/phy.h>
+#include <linux/if_vlan.h>
 
 #include <linux/phy.h>
 #include <linux/clk.h>
@@ -4048,6 +4049,8 @@ u16 mv_pp2x_select_queue(struct net_device *dev, struct sk_buff *skb,
 	.ndo_get_stats64	= mv_pp2x_get_stats64,
 	.ndo_do_ioctl		= mv_pp2x_ioctl,
 	.ndo_set_features	= mv_pp2x_netdev_set_features,
+	.ndo_vlan_rx_add_vid	= mv_pp2x_rx_add_vid,
+	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
 };
 
 /* Driver initialization */
@@ -4748,6 +4751,9 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 
 	dev->vlan_features |= features;
 
+	/* Add support for VLAN filtering */
+	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+
 	dev->priv_flags |= IFF_UNICAST_FLT;
 
 	err = register_netdev(dev);
-- 
1.7.9.5


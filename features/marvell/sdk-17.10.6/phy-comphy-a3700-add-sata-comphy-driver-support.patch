From 9d00171440ef9dab5f83c3a85bbd83b31d6e902a Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Thu, 12 Jan 2017 22:26:43 +0800
Subject: [PATCH 0785/1345] phy: comphy: a3700: add sata comphy driver support

commit  5d257de98fd1df39548f18bdcd8760c0d2a72714 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- the patch add comphy initialization when configured
  in SATA mode

Change-Id: I09431e8b617ef10bfd1dbb89ff8d571907f830aa
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35532
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/phy/phy-comphy-a3700.c |  121 +++++++++++++++++++++++++++++++++++++++-
 drivers/phy/phy-comphy-a3700.h |   62 ++++++++++++++++++++
 2 files changed, 181 insertions(+), 2 deletions(-)

diff --git a/drivers/phy/phy-comphy-a3700.c b/drivers/phy/phy-comphy-a3700.c
index e797ba6..3376839 100644
--- a/drivers/phy/phy-comphy-a3700.c
+++ b/drivers/phy/phy-comphy-a3700.c
@@ -77,18 +77,135 @@ static void mvebu_a3700_comphy_set_phy_selector(struct mvebu_comphy_priv *priv,
 	writel(reg, priv->comphy_regs + COMPHY_SELECTOR_PHY_REG_OFFSET);
 }
 
+/***************************************************************************************************
+  * mvebu_comphy_reg_set_indirect
+  * It is only used for SATA and USB3 on comphy lane2.
+  * return: void
+ ***************************************************************************************************/
+static void mvebu_comphy_reg_set_indirect(void __iomem *addr, u32 reg_offset, u16 data, u16 mask, int mode)
+{
+	/*
+	 * When Lane 2 PHY is for USB3, access the PHY registers
+	 * through indirect Address and Data registers INDIR_ACC_PHY_ADDR (RD00E0178h [31:0]) and
+	 * INDIR_ACC_PHY_DATA (RD00E017Ch [31:0]) within the SATA Host Controller registers, Lane 2
+	 * base register offset is 0x200
+	 */
+	if (mode == COMPHY_UNUSED)
+		return;
+
+	if (mode == COMPHY_SATA_MODE)
+		writel(reg_offset, addr + COMPHY_LANE2_INDIR_ADDR_OFFSET);
+	else
+		writel(reg_offset + USB3PHY_LANE2_REG_BASE_OFFSET, addr + COMPHY_LANE2_INDIR_ADDR_OFFSET);
+
+	reg_set(addr + COMPHY_LANE2_INDIR_DATA_OFFSET, data, mask);
+}
+
 static int mvebu_a3700_comphy_sata_power_on(struct mvebu_comphy_priv *priv,
 					    struct mvebu_comphy *comphy)
 {
+	int ret = 0;
+	u32 reg_offset, data = 0;
+	void __iomem *comphy_indir_regs;
+	struct resource *res;
+	struct platform_device *pdev = container_of(priv->dev, struct platform_device, dev);
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+	int invert = COMPHY_GET_POLARITY_INVERT(priv->lanes[comphy->index].mode);
+
 	dev_dbg(priv->dev, "%s: Enter\n", __func__);
 
+	/* Get the indirect access register resource and map */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "indirect");
+	if (res) {
+		comphy_indir_regs = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(comphy_indir_regs))
+			return PTR_ERR(comphy_indir_regs);
+	} else {
+		dev_err(priv->dev, "no inirect register resource\n");
+		return -ENOTSUPP;
+	}
+
+	/* Configure phy selector for SATA */
 	mvebu_a3700_comphy_set_phy_selector(priv, comphy);
 
-	dev_err(priv->dev, "SATA mode is not implemented\n");
+	/*
+	 * 0. Check the Polarity invert bits
+	 */
+	if (invert & COMPHY_POLARITY_TXD_INVERT)
+		data |= TXD_INVERT_BIT;
+	if (invert & COMPHY_POLARITY_RXD_INVERT)
+		data |= RXD_INVERT_BIT;
+
+	reg_offset = COMPHY_SYNC_PATTERN_REG + SATAPHY_LANE2_REG_BASE_OFFSET;
+	mvebu_comphy_reg_set_indirect(comphy_indir_regs,
+				      reg_offset,
+				      data,
+				      TXD_INVERT_BIT | RXD_INVERT_BIT,
+				      mode);
+
+	/*
+	 * 1. Select 40-bit data width width
+	 */
+	reg_offset = COMPHY_LOOPBACK_REG0 + SATAPHY_LANE2_REG_BASE_OFFSET;
+	mvebu_comphy_reg_set_indirect(comphy_indir_regs,
+				      reg_offset,
+				      (DATA_WIDTH_40BIT << SEL_DATA_WIDTH_OFFSET),
+				      SEL_DATA_WIDTH_MASK,
+				      mode);
+
+	/*
+	 * 2. Select reference clock(25M) and PHY mode (SATA)
+	 */
+	reg_offset = COMPHY_POWER_PLL_CTRL + SATAPHY_LANE2_REG_BASE_OFFSET;
+	mvebu_comphy_reg_set_indirect(comphy_indir_regs,
+				      reg_offset,
+				      ((REF_CLOCK_SPEED_25M << REF_FREF_SEL_OFFSET) |
+				       (PHY_MODE_SATA << PHY_MODE_OFFSET)),
+				      REF_FREF_SEL_MASK | PHY_MODE_MASK,
+				      mode);
+
+	/*
+	 * 3. Use maximum PLL rate (no power save)
+	 */
+	reg_offset = COMPHY_KVCO_CAL_CTRL + SATAPHY_LANE2_REG_BASE_OFFSET;
+	mvebu_comphy_reg_set_indirect(comphy_indir_regs,
+				      reg_offset,
+				      USE_MAX_PLL_RATE_BIT,
+				      USE_MAX_PLL_RATE_BIT,
+				      mode);
+
+	/*
+	 * 4. Reset reserved bit
+	 */
+	mvebu_comphy_reg_set_indirect(comphy_indir_regs,
+				      COMPHY_RESERVED_REG,
+				      0,
+				      PHYCTRL_FRM_PIN_BIT,
+				      mode);
+
+	/*
+	 * 5. Set vendor-specific configuration (It is done in sata driver)
+	 */
+
+	/* Wait for > 55 us to allow PLL be enabled */
+	udelay(PLL_SET_DELAY_US);
+
+	/* Polling status */
+	writel(COMPHY_LOOPBACK_REG0 + SATAPHY_LANE2_REG_BASE_OFFSET,
+	       comphy_indir_regs + COMPHY_LANE2_INDIR_ADDR_OFFSET);
+	ret = polling_with_timeout(comphy_indir_regs + COMPHY_LANE2_INDIR_DATA_OFFSET,
+				   PLL_READY_TX_BIT,
+				   PLL_READY_TX_BIT,
+				   A3700_COMPHY_PLL_LOCK_TIMEOUT,
+				   REG_32BIT);
+
+	/* Unmap resource */
+	devm_iounmap(&pdev->dev, comphy_indir_regs);
+	devm_release_mem_region(&pdev->dev, res->start, resource_size(res));
 
 	dev_dbg(priv->dev, "%s: Exit\n", __func__);
 
-	return -ENOTSUPP;
+	return ret;
 }
 
 static int mvebu_a3700_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
diff --git a/drivers/phy/phy-comphy-a3700.h b/drivers/phy/phy-comphy-a3700.h
index 003bddf..fbbe39f 100644
--- a/drivers/phy/phy-comphy-a3700.h
+++ b/drivers/phy/phy-comphy-a3700.h
@@ -20,5 +20,67 @@ enum {
 /* bit8: 0: Lane1 is USB, Lane2 is SATA; 1: Lane2 is USB3 */
 #define COMPHY_SELECTOR_USB3_PHY_SEL_BIT	BIT(8)
 
+/* SATA PHY register offset */
+#define SATAPHY_LANE2_REG_BASE_OFFSET	0x200
+
+/* USB3 PHY offset compared to SATA PHY */
+#define USB3PHY_LANE2_REG_BASE_OFFSET	0x200
+
+/* Comphy lane2 indirect access register offset */
+#define COMPHY_LANE2_INDIR_ADDR_OFFSET		0x0
+#define COMPHY_LANE2_INDIR_DATA_OFFSET		0x4
+
+/* PHY shift to get related register address */
+enum {
+	PCIE = 1,
+	USB3,
+};
+#define PCIEPHY_SHFT			2
+#define USB3PHY_SHFT			2
+#define PHY_SHFT(unit)			((unit == PCIE) ? PCIEPHY_SHFT : USB3PHY_SHFT)
+
+/* PHY register */
+#define COMPHY_POWER_PLL_CTRL			0x01
+#define PWR_PLL_CTRL_ADDR(unit)			(COMPHY_POWER_PLL_CTRL * PHY_SHFT(unit))
+#define REF_FREF_SEL_OFFSET			0
+#define REF_FREF_SEL_MASK			(0x1F << REF_FREF_SEL_OFFSET)
+#define REF_CLOCK_SPEED_25M			0x1
+#define REF_CLOCK_SPEED_40M			0x3
+#define PHY_MODE_OFFSET				5
+#define PHY_MODE_MASK				(7 << PHY_MODE_OFFSET)
+#define PHY_MODE_SATA				0x0
+#define PHY_MODE_SGMII				0x4
+#define PHY_MODE_USB3				0x5
+
+#define COMPHY_KVCO_CAL_CTRL			0x02
+#define KVCO_CAL_CTRL_ADDR(unit)		(COMPHY_KVCO_CAL_CTRL * PHY_SHFT(unit))
+#define USE_MAX_PLL_RATE_BIT			BIT(12)
+
+#define COMPHY_RESERVED_REG			0x0e
+#define PHYCTRL_FRM_PIN_BIT			BIT(13)
+
+#define COMPHY_LOOPBACK_REG0			0x23
+#define DIG_LB_EN_ADDR(unit)			(COMPHY_LOOPBACK_REG0 * PHY_SHFT(unit))
+#define SEL_DATA_WIDTH_OFFSET			10
+#define SEL_DATA_WIDTH_MASK			(0x3 << SEL_DATA_WIDTH_OFFSET)
+#define DATA_WIDTH_10BIT			0x0
+#define DATA_WIDTH_20BIT			0x1
+#define DATA_WIDTH_40BIT			0x2
+#define PLL_READY_TX_BIT			BIT(4)
+
+#define COMPHY_SYNC_PATTERN_REG			0x24
+#define SYNC_PATTERN_REG_ADDR(unit)		(COMPHY_SYNC_PATTERN_REG * PHY_SHFT(unit))
+#define TXD_INVERT_BIT				BIT(10)
+#define RXD_INVERT_BIT				BIT(11)
+
+#define COMPHY_MISC_REG0_ADDR			0x4F
+#define MISC_REG0_ADDR(unit)			(COMPHY_MISC_REG0_ADDR * PHY_SHFT(unit))
+#define CLK100M_125M_EN				BIT(4)
+#define CLK500M_EN				BIT(7)
+#define PHY_REF_CLK_SEL				BIT(10)
+
+
+
+
 #endif /* _COMPHY_A3700_H */
 
-- 
1.7.9.5


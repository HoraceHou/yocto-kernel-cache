From 2928bd4817aaa401aa954f3b7b9d4cdaeb725323 Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Wed, 29 Jun 2016 14:57:59 +0300
Subject: [PATCH 0314/1345] net: mpp2x: add jumbo packet support

commit  9655d33fd22b29664fdd3a1bd36f991bdc6b8916 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- new parameter of l4_chksum_jumbo_port added in dts
- l4_chksum_jumbo_port used to  select jumbo port support L4 checksum
- jumbo max MTU is 9704
- jumbo max packet size is 9728B including MH and CRC

Change-Id: Id0e03109079d435d8ca6e58eeff54ed03e56edca
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/30848
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yuval Caduri <cyuval@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |   10 +-
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_debug.c    |    4 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c   |    8 ++
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h   |    1 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |    8 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |  120 +++++++++++++++-----
 6 files changed, 113 insertions(+), 38 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index f74de15..c8698b0 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -180,6 +180,10 @@
 
 #define PPV2_MAX_NUM_IRQ		4
 
+/* TX FIFO constants */
+#define MVPP2_TX_FIFO_DATA_SIZE_10KB		0xa
+#define MVPP2_TX_FIFO_DATA_SIZE_3KB		0x3
+
 enum mvppv2_version {
 	PPV21 = 21,
 	PPV22
@@ -456,11 +460,6 @@ struct mv_pp2x_param_config {
 	struct mv_pp2x_cos cos_cfg;
 	struct mv_pp2x_rss rss_cfg;
 	u8 first_bm_pool;
-	bool jumbo_pool; /* pp2 always supports 2 pools :
-			 * short=MV_DEF_256, long=MV_DEF_2K.
-			 * Param defines option to have additional pool,
-			 * jumbo=MV_DEF_10K.
-			 */
 	u8 first_sw_thread; /* The index of the first PPv2.2
 			* sub-address space for this NET_INSTANCE.
 			*/
@@ -503,6 +502,7 @@ struct mv_pp2x {
 	* CPU idx according to weight
 	*/
 	u32 rx_indir_table[MVPP22_RSS_TBL_LINE_NUM];
+	u32 l4_chksum_jumbo_port;
 };
 
 struct mv_pp2x_pcpu_stats {
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_debug.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_debug.c
index 39940d4..dba3f4b 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_debug.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_debug.c
@@ -106,7 +106,7 @@ void mv_pp2x_pool_status(struct mv_pp2x *priv, int log_pool_num)
 	struct mv_pp2x_bm_pool *bm_pool = NULL;
 	int /*buf_size,*/ total_size, i, pool;
 
-	if (mv_pp2x_max_check(log_pool_num, MVPP2_BM_SWF_POOL_OUT_OF_RANGE,
+	if (mv_pp2x_max_check(log_pool_num, MVPP2_BM_SWF_NUM_POOLS,
 			      "log_pool"))
 		return;
 
@@ -139,7 +139,7 @@ void mv_pp2_pool_stats_print(struct mv_pp2x *priv, int log_pool_num)
 	int i, pool;
 	struct mv_pp2x_bm_pool *bm_pool = NULL;
 
-	if (mv_pp2x_max_check(log_pool_num, MVPP2_BM_SWF_POOL_OUT_OF_RANGE,
+	if (mv_pp2x_max_check(log_pool_num, MVPP2_BM_SWF_NUM_POOLS,
 			      "log_pool"))
 		return;
 
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
index f64198d..6df70ae 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
@@ -6579,3 +6579,11 @@ void mv_pp22_rss_c2_enable(struct mv_pp2x_port *port, bool en)
 			      MVPP2_CLS2_ACT_DUP_ATTR_REG, regVal);
 	}
 }
+
+/* Initialize Tx FIFO's */
+void mv_pp2x_tx_fifo_set(struct mv_pp2x_hw *hw, u32 port_id, u32 val)
+{
+	mv_pp2x_write(hw,
+		      MVPP22_TX_FIFO_SIZE_REG(port_id),
+		      val & MVPP22_TX_FIFO_SIZE_MASK);
+}
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
index 023d517..67c29c8 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
@@ -781,5 +781,6 @@ int mv_pp22_rss_tbl_entry_get(struct mv_pp2x_hw *hw,
 
 void mv_pp22_rss_c2_enable(struct mv_pp2x_port *port, bool en);
 int mv_pp22_rss_hw_dump(struct mv_pp2x_hw *hw);
+void mv_pp2x_tx_fifo_set(struct mv_pp2x_hw *hw, u32 port_id, u32 val);
 
 #endif /* _MVPP2_HW_H_ */
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 890a2b9..0909ac4 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1247,6 +1247,10 @@
 	ALIGN((mtu) + MVPP2_MH_SIZE + MVPP2_VLAN_TAG_LEN + \
 	      ETH_HLEN + ETH_FCS_LEN, MVPP2_CPU_D_CACHE_LINE_SIZE)
 
+#define MVPP2_RX_MTU_SIZE(pkt_size) \
+	(pkt_size - MVPP2_MH_SIZE - MVPP2_VLAN_TAG_LEN - \
+	 ETH_HLEN - ETH_FCS_LEN)
+
 #define MVPP2_RX_BUF_SIZE(pkt_size)	((pkt_size) + NET_SKB_PAD)
 #define MVPP2_RX_TOTAL_SIZE(buf_size)	((buf_size) + MVPP2_SKB_SHINFO_SIZE)
 #define MVPP2_RX_MAX_PKT_SIZE(total_size) \
@@ -1720,13 +1724,13 @@ struct mv_pp2x_prs_flow_id {
 
 #define MVPP2_BM_SHORT_FRAME_SIZE		1024
 #define MVPP2_BM_LONG_FRAME_SIZE		2048
-#define MVPP2_BM_JUMBO_FRAME_SIZE		8192 /*FIXME: What is max. size ? */
+#define MVPP2_BM_JUMBO_FRAME_SIZE		10240
 
 enum mv_pp2x_bm_pool_log_num {
 	MVPP2_BM_SWF_SHORT_POOL,
 	MVPP2_BM_SWF_LONG_POOL,
 	MVPP2_BM_SWF_JUMBO_POOL,
-	MVPP2_BM_SWF_POOL_OUT_OF_RANGE
+	MVPP2_BM_SWF_NUM_POOLS
 };
 
 /* The mv_pp2x_tx_desc and mv_pp2x_rx_desc structures describe the
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 8bc8e23..c36ddf0 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -69,10 +69,7 @@
 static u32 pri_map = 0x3210; /* As default, cos0--rxq0, cos1--rxq1,
 			      * cos2--rxq2, cos3--rxq3
 			      */
-static u8 default_cos = 3; /* As default, non-IP packet has the
-			    * highest CoS value
-			    */
-static bool jumbo_pool;
+static u8 default_cos = 3; /* As default, non-IP packet has highest CoS value */
 static u16 rx_queue_size = MVPP2_MAX_RXD;
 static u16 tx_queue_size = MVPP2_MAX_TXD;
 static u16 buffer_scaling = 100;
@@ -115,9 +112,6 @@
 module_param(default_cos, byte, S_IRUGO);
 MODULE_PARM_DESC(default_cos, "Set default cos (0-(num_cose_queues-1)).");
 
-module_param(jumbo_pool, bool, S_IRUGO);
-MODULE_PARM_DESC(jumbo_pool, "no_jumbo_support(0), jumbo_support(1)");
-
 module_param(rx_queue_size, ushort, S_IRUGO);
 MODULE_PARM_DESC(rx_queue_size, "Rx queue size");
 
@@ -217,11 +211,6 @@ static inline u8 mv_pp2x_first_pool_get(struct mv_pp2x *priv)
 	return priv->pp2_cfg.first_bm_pool;
 }
 
-static inline u8 mv_pp2x_kernel_num_pools_get(struct mv_pp2x *priv)
-{
-	return((priv->pp2_cfg.jumbo_pool == true) ? 3 : 2);
-}
-
 static inline u8 mv_pp2x_last_pool_get(struct mv_pp2x *priv)
 {
 	return(mv_pp2x_first_pool_get(priv) + priv->num_pools);
@@ -494,7 +483,7 @@ static int mv_pp2x_bm_init(struct platform_device *pdev, struct mv_pp2x *priv)
 {
 	int i, err;
 	u8 first_pool = mv_pp2x_first_pool_get(priv);
-	u8 num_pools = mv_pp2x_kernel_num_pools_get(priv);
+	u8 num_pools = MVPP2_BM_SWF_NUM_POOLS;
 
 	for (i = first_pool; i < (first_pool + num_pools); i++) {
 		/* Mask BM all interrupts */
@@ -646,11 +635,17 @@ int mv_pp2x_swf_bm_pool_assign(struct mv_pp2x_port *port, u32 rxq,
 static int mv_pp2x_swf_bm_pool_init(struct mv_pp2x_port *port)
 {
 	int rxq;
+	enum mv_pp2x_bm_pool_log_num long_log_pool;
 	struct mv_pp2x_hw *hw = &(port->priv->hw);
 
+	if (port->pkt_size > MVPP2_BM_LONG_PKT_SIZE)
+		long_log_pool = MVPP2_BM_SWF_JUMBO_POOL;
+	else
+		long_log_pool = MVPP2_BM_SWF_LONG_POOL;
+
 	if (!port->pool_long) {
 		port->pool_long =
-		       mv_pp2x_bm_pool_use(port, MVPP2_BM_SWF_LONG_POOL);
+		       mv_pp2x_bm_pool_use(port, long_log_pool);
 		if (!port->pool_long)
 			return -ENOMEM;
 		port->pool_long->port_map |= (1 << port->id);
@@ -683,10 +678,12 @@ static int mv_pp2x_bm_update_mtu(struct net_device *dev, int mtu)
 	struct mv_pp2x_bm_pool *old_port_pool = port->pool_long;
 	struct mv_pp2x_hw *hw = &port->priv->hw;
 	enum mv_pp2x_bm_pool_log_num new_log_pool;
-	enum mv_pp2x_bm_pool_log_num old_log_pool = old_port_pool->log_id;
+	enum mv_pp2x_bm_pool_log_num old_log_pool;
 	int rxq;
 	int pkt_size = MVPP2_RX_PKT_SIZE(mtu);
 
+	old_log_pool = old_port_pool->log_id;
+
 	if (pkt_size > MVPP2_BM_LONG_PKT_SIZE)
 		new_log_pool = MVPP2_BM_SWF_JUMBO_POOL;
 	else
@@ -705,9 +702,20 @@ static int mv_pp2x_bm_update_mtu(struct net_device *dev, int mtu)
 		/* Remove port from old pool */
 		mv_pp2x_bm_pool_stop_use(port, old_log_pool);
 		old_port_pool->port_map &= ~(1 << port->id);
+
+		/* Update L4 checksum when jumbo enable/disable on port */
+		if (new_log_pool == MVPP2_BM_SWF_JUMBO_POOL) {
+			if (port->id != port->priv->l4_chksum_jumbo_port)
+				dev->hw_features &=
+					~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+		} else {
+			dev->hw_features |=
+				(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+		}
 	}
 
 	dev->mtu = mtu;
+
 	netdev_update_features(dev);
 	return 0;
 }
@@ -2110,7 +2118,7 @@ static int mv_pp2x_rx(struct mv_pp2x_port *port, struct napi_struct *napi,
 	u32 rcvd_bytes = 0;
 	u32 refill_array[MVPP2_BM_POOLS_NUM] = {0};
 	u8  first_bm_pool = port->priv->pp2_cfg.first_bm_pool;
-	u8  num_pool = mv_pp2x_kernel_num_pools_get(port->priv);
+	u8  num_pool = MVPP2_BM_SWF_NUM_POOLS;
 
 #ifdef DEV_NETMAP
 		if (port->flags & MVPP2_F_IFCAP_NETMAP) {
@@ -2776,16 +2784,10 @@ static inline int mv_pp2x_check_mtu_valid(struct net_device *dev, int mtu)
 		netdev_err(dev, "cannot change mtu to less than 68\n");
 		return -EINVAL;
 	}
-	if (MVPP2_RX_PKT_SIZE(mtu) > MVPP2_BM_LONG_PKT_SIZE &&
-		jumbo_pool == false) {
-		netdev_err(dev, "jumbo packet not supported (%d)\n", mtu);
-		return -EINVAL;
-	}
 
-	/* 9676 == 9700 - 20 and rounding to 8 */
-	if (mtu > 9676) {
-		netdev_info(dev, "illegal MTU value %d, round to 9676\n", mtu);
-		mtu = 9676;
+	if (MVPP2_RX_PKT_SIZE(mtu) > MVPP2_BM_JUMBO_PKT_SIZE) {
+		netdev_info(dev, "illegal MTU value %d, round to 9704\n", mtu);
+		mtu = MVPP2_RX_MTU_SIZE(MVPP2_BM_JUMBO_PKT_SIZE);
 	}
 
 	return mtu;
@@ -3580,7 +3582,6 @@ static int mv_pp2_init_emac_data(struct mv_pp2x_port *port,
 		phy_modes(phy_mode));
 	pr_debug("gop_mac(%d), phy_speed(%d)\n", id,  port->mac_data.speed);
 
-
 	phy_node = of_parse_phandle(emac_node, "phy", 0);
 	if (phy_node) {
 		port->mac_data.phy_node = phy_node;
@@ -4197,7 +4198,6 @@ static void mv_pp2x_init_config(struct mv_pp2x_param_config *pp2_cfg,
 	pp2_cfg->first_bm_pool = first_bm_pool;
 	pp2_cfg->first_sw_thread = first_addr_space;
 	pp2_cfg->first_log_rxq = first_log_rxq_queue;
-	pp2_cfg->jumbo_pool = jumbo_pool;
 	pp2_cfg->queue_mode = mv_pp2x_queue_mode;
 
 	pp2_cfg->cos_cfg.cos_classifier = cos_classifer;
@@ -4244,8 +4244,6 @@ void mv_pp2x_pp2_basic_print(struct platform_device *pdev, struct mv_pp2x *priv)
 
 	DBG_MSG("pp2_ver(%d)\n", priv->pp2_version);
 	DBG_MSG("queue_mode(%d)\n", priv->pp2_cfg.queue_mode);
-	DBG_MSG("first_bm_pool(%d) jumbo_pool(%d)\n",
-		priv->pp2_cfg.first_bm_pool, priv->pp2_cfg.jumbo_pool);
 	DBG_MSG("cell_index(%d) num_ports(%d)\n",
 		priv->pp2_cfg.cell_index, priv->num_ports);
 #ifdef CONFIG_64BIT
@@ -4492,6 +4490,14 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 		hw->gop.gop_110.xlg_mac.obj_size = 0x1000;
 
 		MVPP2_PRINT_2LINE();
+
+		/* Jumbo L4_checksum port */
+		if (of_property_read_u32(dn, "l4_chksum_jumbo_port",
+					 &priv->l4_chksum_jumbo_port))
+			/* Init as a invalid value */
+			priv->l4_chksum_jumbo_port = MVPP2_MAX_PORTS;
+
+		MVPP2_PRINT_VAR(priv->l4_chksum_jumbo_port);
 	}
 
 	hw->gop_core_clk = devm_clk_get(&pdev->dev, "gop_core_clk");
@@ -4541,6 +4547,58 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 	return 0;
 }
 
+static void mv_pp2x_tx_fifo_init(struct mv_pp2x *priv)
+{
+	int i;
+
+	/* Check l4_chksum_jumbo_port */
+	if (priv->l4_chksum_jumbo_port < MVPP2_MAX_PORTS) {
+		for (i = 0; i < priv->num_ports; i++) {
+			if (priv->port_list[i]->id ==
+				priv->l4_chksum_jumbo_port)
+				break;
+		}
+		if (i == priv->num_ports)
+			WARN(1, "Unavailable l4_chksum_jumbo_port %d\n",
+			     priv->l4_chksum_jumbo_port);
+	} else {
+		/* Find port with highest speed, allocate extra FIFO to it */
+		for (i = 0; i < priv->num_ports; i++) {
+			phy_interface_t phy_mode =
+					priv->port_list[i]->mac_data.phy_mode;
+
+			if ((phy_mode == PHY_INTERFACE_MODE_XAUI) ||
+			    (phy_mode == PHY_INTERFACE_MODE_RXAUI) ||
+			    (phy_mode == PHY_INTERFACE_MODE_KR)) {
+				/* Record l4_chksum_jumbo_port */
+				priv->l4_chksum_jumbo_port =
+							priv->port_list[i]->id;
+				break;
+			} else if (priv->port_list[i]->mac_data.speed == 2500 &&
+				   (priv->l4_chksum_jumbo_port ==
+							MVPP2_MAX_PORTS)) {
+				/* Only first 2.5G port may get extra FIFO */
+				priv->l4_chksum_jumbo_port =
+							priv->port_list[i]->id;
+			}
+		}
+		/* First 1G port in list get extra FIFO */
+		if (priv->l4_chksum_jumbo_port == MVPP2_MAX_PORTS)
+			priv->l4_chksum_jumbo_port = priv->port_list[0]->id;
+	}
+
+	/* Set FIFO according to l4_chksum_jumbo_port */
+	for (i = 0; i < priv->num_ports; i++) {
+		if (priv->port_list[i]->id != priv->l4_chksum_jumbo_port)
+			mv_pp2x_tx_fifo_set(&priv->hw,
+					    priv->port_list[i]->id,
+					    MVPP2_TX_FIFO_DATA_SIZE_3KB);
+	}
+	mv_pp2x_tx_fifo_set(&priv->hw,
+			    priv->l4_chksum_jumbo_port,
+			    MVPP2_TX_FIFO_DATA_SIZE_10KB);
+}
+
 static int mv_pp2x_probe(struct platform_device *pdev)
 {
 	struct mv_pp2x *priv;
@@ -4639,6 +4697,10 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 		if (err < 0)
 			goto err_clk;
 	}
+
+	/* Init tx fifo for each port */
+	mv_pp2x_tx_fifo_init(priv);
+
 	net_comp_config = mvp_pp2x_gop110_netc_cfg_create(priv);
 	mv_gop110_netc_init(&priv->hw.gop, net_comp_config,
 				MV_NETC_FIRST_PHASE);
-- 
1.7.9.5


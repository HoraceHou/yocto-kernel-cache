From 20daadfd98210ff8461ec0c28065d5a08d1473ce Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Fri, 13 Jan 2017 23:06:02 +0800
Subject: [PATCH 0742/1345] uart: a3700: add interrupt mode setting

commit  60a0eece7e55b556aea473ce2754150e0a1bef8b from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- This patch mainly select the uart TX and RX interrupt
  as the interrupt source by configured the North Bridge
  Interrupt Select register. This register doesn't belong
  uart register space, it is just a common North Bridge
  register.
- This patch also set the TX and RX interrupt state
  register on North Bridge in uart TX and RX interrupt
  handler. By setting '1' to these bits in North Bridge
  Interrupt State register, the TX and RX interrput will be
  cleared, and it is ready for the next coming interrupt.

Change-Id: I6d8cbbf14c058b88536e8bda8c91a2c927187ef4
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35475
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/serial/mvebu-uart.txt      |    1 +
 drivers/tty/serial/mvebu-uart.c                    |   49 ++++++++++++++++++++
 2 files changed, 50 insertions(+)

diff --git a/Documentation/devicetree/bindings/serial/mvebu-uart.txt b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
index a40beed..7beeae6 100644
--- a/Documentation/devicetree/bindings/serial/mvebu-uart.txt
+++ b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
@@ -15,6 +15,7 @@ Example:
 	serial@12200 {
 		compatible = "marvell,armada-3700-uart-ext";
 		reg = <0x12200 0x30>,
+		      <0x8a00 0x30>;
 		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
 		             <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
 		interrupt-names = "irq_rx", "irq_tx";
diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index 9e110de..9318b01 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -119,6 +119,25 @@ struct uart_regs_layout {
 #define EXT_CTRL2_TX_RDY_INT_1B	BIT(6)
 #define EXT_CTRL2_RX_RDY_INT_1B	BIT(5)
 
+/* REG_NORTH_BRIDGE_FOR_UART_A3700_EXT */
+/* UART Interrupt Registers are not part of UART Register space.
+ * It is in the common North Bridge Interrupt register space.
+ *
+ * UART Interrupt Select register:
+ * The Uart interrupt could be either level triggered or pulse trigger.
+ * By default, the interrupt mode is level triggered - '0'.
+ * In order to enable the pulse interrupt select register, the UART
+ * Interrupt Select register MUST be setted to '1'.
+ */
+#define NORTH_BRIDGE_UART_EXT_INT_SEL	0x1c
+#define UART_EXT_TX_INT_SEL		BIT(27)
+#define UART_EXT_RX_INT_SEL		BIT(26)
+
+/* UART Interrupt State register*/
+#define NORTH_BRIDGE_UART_EXT_INT_STAT	0x10
+#define UART_EXT_STAT_TX_INT		BIT(27)
+#define UART_EXT_STAT_RX_INT		BIT(26)
+
 /* UART register layout definitions */
 static struct uart_regs_layout uart_regs_layout[] = {
 	[REG_UART_A3700] = {
@@ -168,6 +187,13 @@ struct mvebu_uart_data {
 		int irq_sum;
 		int irq_rx;
 		int irq_tx;
+		/* Uart_int_base is the North Bridge Interrupt Register base.
+		 * It is necessary to fetch the Interrupt Status register and Interrupt
+		 * Select register.
+		 * It is used for setting Uart TX and RX interrupt trigger mode
+		 * and clearing the TX/RX interrupt in the ISR.
+		 */
+		unsigned char __iomem *uart_int_base;
 	} intr;
 };
 
@@ -438,6 +464,11 @@ static irqreturn_t mvebu_uart_rx_isr(int irq, void *dev_id)
 	if (st & (stat_bit_rx_rdy | STAT_OVR_ERR | STAT_FRM_ERR | STAT_BRK_DET))
 		mvebu_uart_rx_chars(port, st);
 
+	if (!IS_ERR_OR_NULL(uart_data->intr.uart_int_base)) {
+		st = readl(uart_data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_STAT);
+		/* Clear the RX Interrupt State Register*/
+		writel(st | UART_EXT_STAT_RX_INT, uart_data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_STAT);
+	}
 	return IRQ_HANDLED;
 }
 
@@ -451,6 +482,11 @@ static irqreturn_t mvebu_uart_tx_isr(int irq, void *dev_id)
 	if (st & stat_bit_tx_rdy)
 		mvebu_uart_tx_chars(port, st);
 
+	if (!IS_ERR_OR_NULL(uart_data->intr.uart_int_base)) {
+		st = readl(uart_data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_STAT);
+		/* Clear the TX Interrupt State Register*/
+		writel(st | UART_EXT_STAT_TX_INT, uart_data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_STAT);
+	}
 	return IRQ_HANDLED;
 }
 
@@ -776,6 +812,7 @@ static int __init mvebu_uart_console_init(void)
 static int mvebu_uart_probe(struct platform_device *pdev)
 {
 	struct resource *reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct resource *uart_int_base = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 
 	int irq_sum = platform_get_irq_byname(pdev, "irq_sum");
 	int irq_rx = platform_get_irq_byname(pdev, "irq_rx");
@@ -784,6 +821,7 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 	struct uart_port *port;
 	struct mvebu_uart_data *data;
 	int ret;
+	u32 value;
 
 	if (!reg) {
 		dev_err(&pdev->dev, "no registers defined\n");
@@ -867,6 +905,17 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 	port->private_data = data;
 	platform_set_drvdata(pdev, data);
 
+	/* UART interrupt status selected */
+	/* Select UART_EXT RX and TX as the interrupt status mode*/
+	if (uart_int_base) {
+		data->intr.uart_int_base = devm_ioremap_resource(&pdev->dev, uart_int_base);
+		if (IS_ERR(data->intr.uart_int_base))
+			return -PTR_ERR(data->intr.uart_int_base);
+		value = readl(data->intr.uart_int_base);
+		writel(value | UART_EXT_TX_INT_SEL | UART_EXT_RX_INT_SEL, data->intr.uart_int_base +
+			   NORTH_BRIDGE_UART_EXT_INT_SEL);
+	}
+
 	/* UART Soft Reset*/
 	writel(CTRL_SOFT_RST, port->membase + REG_CTRL(data));
 	udelay(1);
-- 
1.7.9.5


From cadd0149e505dd11290f62cbbce79b91e8b072c6 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Mon, 20 Mar 2017 17:58:10 +0200
Subject: [PATCH 0926/1345] dma: mv_xor_v2: add support for AP-806 & CP-110
 RAID6 offload support

commit  b019f4fe477291e8a857afc315532d5f7b143473 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

The offload engine in AP-806 & CP-110 introduce RAID6 capability.
This patch adds RAID6 offload support for mv_xor_v2 driver.

Change-Id: Ic7ace75ed380b984587abbd890c5a1a95fdf0ad3
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37696
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/dma/mv_xor_v2.c |   99 ++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 98 insertions(+), 1 deletion(-)

diff --git a/drivers/dma/mv_xor_v2.c b/drivers/dma/mv_xor_v2.c
index 1815c37..9ff3c77b 100644
--- a/drivers/dma/mv_xor_v2.c
+++ b/drivers/dma/mv_xor_v2.c
@@ -489,6 +489,100 @@ static irqreturn_t mv_xor_v2_interrupt_handler(int irq, void *data)
 }
 
 /*
+ * Prepare a HW descriptor for a XOR operation
+ */
+static struct dma_async_tx_descriptor *
+mv_xor_v2_prep_dma_pq(struct dma_chan *chan, dma_addr_t *dest, dma_addr_t *src,
+			unsigned int src_cnt, const unsigned char *scf,
+			size_t len, unsigned long flags)
+{
+	struct mv_xor_v2_sw_desc	*sw_desc;
+	struct mv_xor_v2_descriptor	*hw_descriptor;
+	struct mv_xor_v2_device		*xor_dev;
+	int i;
+
+	WARN_ON(src_cnt > MV_XOR_V2_CMD_LINE_NUM_MAX_D_BUF || src_cnt < 1);
+
+	xor_dev = container_of(chan, struct mv_xor_v2_device, dmachan);
+
+	dev_dbg(xor_dev->dmadev.dev,
+		"%s src_cnt: %d len: %zu dest %pad flags: %ld\n",
+		__func__, src_cnt, len, &dest, flags);
+
+	WARN_ON(xor_dev->desc_size != MV_XOR_V2_EXT_DESC_SIZE);
+
+	/*
+	 * Because of limitation in our XORv2 unit, XORv2 do not
+	 * support mult and sum product requests. If Raid6 have double
+	 * parity devices the scf array will include multiple and sum
+	 * parameters for the equations, but in XORv2 unit does not
+	 * support thus operations.
+	 * return NULL to DMA stack, to let the CPU do the mult
+	 * and SUM operations
+	 */
+	if ((flags & DMA_PREP_PQ_MULT) || (flags & DMA_PREP_PQ_SUM_PRODUCT))
+		return NULL;
+
+	sw_desc = mv_xor_v2_prep_sw_desc(xor_dev);
+
+	/* If there's no empty discriptor, return NULL to dma stack */
+	if (!sw_desc)
+		return NULL;
+
+	sw_desc->async_tx.flags = flags;
+
+	/* set the HW descriptor */
+	hw_descriptor = &sw_desc->hw_desc;
+
+	/* save the SW descriptor ID to restore when operation is done */
+	hw_descriptor->desc_id = sw_desc->idx;
+
+	/* Set the XOR control word */
+	hw_descriptor->desc_ctrl =
+		DESC_OP_MODE_RAID6 << DESC_OP_MODE_SHIFT;
+
+	if (flags & DMA_PREP_INTERRUPT)
+		hw_descriptor->desc_ctrl |= DESC_IOD;
+
+	hw_descriptor->desc_ctrl |=
+		src_cnt << DESC_NUM_ACTIVE_D_BUF_SHIFT;
+
+	if (!(flags & DMA_PREP_PQ_DISABLE_Q)) {
+		hw_descriptor->desc_ctrl |= DESC_Q_BUFFER_ENABLE;
+
+		/* Set Q-Buffer-Address */
+		hw_descriptor->fill_pattern_src_addr[0] = lower_32_bits(dest[1]);
+		if (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT))
+			hw_descriptor->fill_pattern_src_addr[1] =
+				upper_32_bits(dest[1]) & 0xFFFF;
+		else
+			hw_descriptor->fill_pattern_src_addr[1] = 0;
+	}
+
+	if (!(flags & DMA_PREP_PQ_DISABLE_P)) {
+		hw_descriptor->desc_ctrl |= DESC_P_BUFFER_ENABLE;
+
+		/* Set P-Buffer-Address */
+		hw_descriptor->fill_pattern_src_addr[2] = lower_32_bits(dest[0]);
+		if (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT))
+			hw_descriptor->fill_pattern_src_addr[3] =
+				upper_32_bits(dest[0]) & 0xFFFF;
+		else
+			hw_descriptor->fill_pattern_src_addr[3] = 0;
+	}
+
+	/* Set the data buffers */
+	for (i = 0; i < src_cnt; i++)
+		mv_xor_v2_set_data_buffers(xor_dev, hw_descriptor, src[i], i);
+
+	/* Set buffers size */
+	hw_descriptor->buff_size = len;
+
+	/* return the async tx descriptor */
+	return &sw_desc->async_tx;
+}
+
+/*
  * Prepare a HW descriptor for interrupt operation.
  */
 static struct dma_async_tx_descriptor *
@@ -828,6 +922,7 @@ static int mv_xor_v2_probe(struct platform_device *pdev)
 	dma_cap_set(DMA_MEMCPY, dma_dev->cap_mask);
 	dma_cap_set(DMA_XOR, dma_dev->cap_mask);
 	dma_cap_set(DMA_INTERRUPT, dma_dev->cap_mask);
+	dma_cap_set(DMA_PQ, dma_dev->cap_mask);
 
 	/* init dma link list */
 	INIT_LIST_HEAD(&dma_dev->channels);
@@ -839,8 +934,10 @@ static int mv_xor_v2_probe(struct platform_device *pdev)
 
 	dma_dev->device_prep_dma_memcpy = mv_xor_v2_prep_dma_memcpy;
 	dma_dev->device_prep_dma_interrupt = mv_xor_v2_prep_dma_interrupt;
-	dma_dev->max_xor = 8;
+	dma_dev->max_xor = MV_XOR_V2_CMD_LINE_NUM_MAX_D_BUF;
 	dma_dev->device_prep_dma_xor = mv_xor_v2_prep_dma_xor;
+	dma_set_maxpq(dma_dev, MV_XOR_V2_CMD_LINE_NUM_MAX_D_BUF, 0);
+	dma_dev->device_prep_dma_pq = mv_xor_v2_prep_dma_pq;
 
 	xor_dev->dmachan.device = dma_dev;
 
-- 
1.7.9.5


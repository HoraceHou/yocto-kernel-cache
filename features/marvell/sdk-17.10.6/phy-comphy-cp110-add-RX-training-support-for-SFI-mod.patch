From 083704803702b76e7975ee9e7adc282bd2ad613b Mon Sep 17 00:00:00 2001
From: Igal Liberman <igall@marvell.com>
Date: Tue, 8 Aug 2017 15:01:03 +0300
Subject: [PATCH 1198/1345] phy: comphy: cp110: add RX training support (for
 SFI mode)

commit  d0b70388a6544e2b4963dafd9d26cc009bedeee9 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Currently, we use static values for comphy configuration. When using SFI,
in some setups or different boards, might be that the link quality will be
not sufficient.

The RX training process is the following:
- There are 8 optional values for FFE (Feed Forward Equalization)
  and we need to choose the best.
- Each FFE is tested, the result can be found in Saved DFE values
  Register (SAV_F0D).  Higher SAV_F0D value is better.
- Determine which FFE gave us the best SAV_F0D value
- Set the best FFE and run RX training again

Change-Id: I36aa596bd373e4500df0b01f838feaad31e974c6
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42726
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/phy/phy-comphy-cp110.c             |  185 ++++++++++++++++++++++++++++
 drivers/phy/phy-comphy-cp110.h             |   49 ++++++++
 include/dt-bindings/phy/phy-comphy-mvebu.h |    1 +
 3 files changed, 235 insertions(+)

diff --git a/drivers/phy/phy-comphy-cp110.c b/drivers/phy/phy-comphy-cp110.c
index bd219cd..e1c477c 100644
--- a/drivers/phy/phy-comphy-cp110.c
+++ b/drivers/phy/phy-comphy-cp110.c
@@ -1568,6 +1568,180 @@ static int mvebu_cp110_comphy_xfi_power_on(struct mvebu_comphy_priv *priv,
 	return ret;
 }
 
+/* This function performs RX training for one Feed Forward Equalization (FFE)
+ * value.
+ * The RX traiing result is stored in 'Saved DFE values Register' (SAV_F0D).
+ *
+ * Return '0' on success, error code in  a case of failure.
+ */
+static int mvebu_cp110_comphy_test_single_ffe(struct mvebu_comphy_priv *priv,
+					      struct mvebu_comphy *comphy,
+					      u32 ffe, u32 *result)
+{
+	u32 mask, data, timeout;
+	void __iomem *hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
+	void __iomem *sd_ip_addr = SD_ADDR(priv->comphy_pipe_regs, comphy->index);
+
+	/* Configure PRBS counters */
+	mask = HPIPE_PHY_TEST_PATTERN_SEL_MASK;
+	data = 0xe << HPIPE_PHY_TEST_PATTERN_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PHY_TEST_CONTROL_REG, data, mask);
+
+	mask = HPIPE_PHY_TEST_DATA_MASK;
+	data = 0x64 << HPIPE_PHY_TEST_DATA_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PHY_TEST_DATA_REG, data, mask);
+
+	mask = HPIPE_PHY_TEST_EN_MASK;
+	data = 0x1 << HPIPE_PHY_TEST_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PHY_TEST_CONTROL_REG, data, mask);
+
+	mdelay(50);
+
+	/* Set the FFE value */
+	mask = HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
+	data = ffe << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
+
+	/* Start RX training */
+	mask = SD_EXTERNAL_STATUS_START_RX_TRAINING_MASK;
+	data = 1 << SD_EXTERNAL_STATUS_START_RX_TRAINING_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_STATUS_REG, data, mask);
+
+	/* Check the result of RX training */
+	timeout = RX_TRAINING_TIMEOUT;
+	while (timeout) {
+		data = readl(sd_ip_addr + SD_EXTERNAL_STATAUS1_REG);
+		if (data & SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_COMP_MASK)
+			break;
+		mdelay(1);
+		timeout--;
+	}
+
+	if (timeout == 0)
+		return -ETIMEDOUT;
+
+	if (data & SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_FAILED_MASK)
+		return -EINVAL;
+
+	/* Stop RX training */
+	mask = SD_EXTERNAL_STATUS_START_RX_TRAINING_MASK;
+	data = 0 << SD_EXTERNAL_STATUS_START_RX_TRAINING_OFFSET;
+	reg_set(sd_ip_addr + SD_EXTERNAL_STATUS_REG, data, mask);
+
+	/* Read the result */
+	data = readl(hpipe_addr + HPIPE_SAVED_DFE_VALUES_REG);
+	data &= HPIPE_SAVED_DFE_VALUES_SAV_F0D_MASK;
+	data >>= HPIPE_SAVED_DFE_VALUES_SAV_F0D_OFFSET;
+	*result = data;
+
+	mask = HPIPE_PHY_TEST_RESET_MASK;
+	data = 0x1 << HPIPE_PHY_TEST_RESET_OFFSET;
+	mask |= HPIPE_PHY_TEST_EN_MASK;
+	data |= 0x0 << HPIPE_PHY_TEST_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PHY_TEST_CONTROL_REG, data, mask);
+
+	mask = HPIPE_PHY_TEST_RESET_MASK;
+	data = 0x0 << HPIPE_PHY_TEST_RESET_OFFSET;
+	reg_set(hpipe_addr + HPIPE_PHY_TEST_CONTROL_REG, data, mask);
+
+	return 0;
+}
+
+/* This function runs complete RX training sequence:
+ *	- Run RX training for all possible Feed Forward Equalization values
+ *	- Choose the FFE which gives the best result.
+ *	- Run RX training again with the best result.
+ *
+ * Return '0' on success, error code in  a case of failure.
+ */
+static int mvebu_cp110_comphy_xfi_rx_training(struct mvebu_comphy_priv *priv,
+					      struct mvebu_comphy *comphy)
+{
+	u32 mask, data, max_rx_train = 0, max_rx_train_index = 0;
+	void __iomem *hpipe_addr = HPIPE_ADDR(priv->comphy_pipe_regs, comphy->index);
+	u32 rx_train_result;
+	int ret, i;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	/* Configure SQ threshold and CDR lock */
+	mask = HPIPE_SQUELCH_THRESH_IN_MASK;
+	data = 0xc << HPIPE_SQUELCH_THRESH_IN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_SQUELCH_FFE_SETTING_REG, data, mask);
+
+	mask = HPIPE_SQ_DEGLITCH_WIDTH_P_MASK;
+	data = 0xf << HPIPE_SQ_DEGLITCH_WIDTH_P_OFFSET;
+	mask |= HPIPE_SQ_DEGLITCH_WIDTH_N_MASK;
+	data |= 0xf << HPIPE_SQ_DEGLITCH_WIDTH_N_OFFSET;
+	mask |= HPIPE_SQ_DEGLITCH_EN_MASK;
+	data |= 0x1 << HPIPE_SQ_DEGLITCH_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_SQ_GLITCH_FILTER_CTRL, data, mask);
+
+	mask = HPIPE_CDR_LOCK_DET_EN_MASK;
+	data = 0x1 << HPIPE_CDR_LOCK_DET_EN_OFFSET;
+	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
+
+	udelay(100);
+
+	/* Determine if we have a cable attached to this comphy, if not,
+	 * we can't perform RX training.
+	 */
+	data = readl(hpipe_addr + HPIPE_SQUELCH_FFE_SETTING_REG);
+	if (data & HPIPE_SQUELCH_DETECTED_MASK) {
+		dev_err(priv->dev, "Squelsh is not detected, can't perform RX training\n");
+		return -EINVAL;
+	}
+
+	data = readl(hpipe_addr + HPIPE_LOOPBACK_REG);
+	if (!(data & HPIPE_CDR_LOCK_MASK)) {
+		dev_err(priv->dev, "CDR is not locked, can't perform RX training\n");
+		return -EINVAL;
+	}
+
+	/* Do preparations for RX training */
+	mask = HPIPE_DFE_RES_FORCE_MASK;
+	data = 0x0 << HPIPE_DFE_RES_FORCE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
+
+	mask = HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
+	data = 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
+	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
+	data |= 1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
+
+	/* Perform RX training for all possible FFE (Feed Forward
+	 * Equalization, possible values are 0-7).
+	 * We update the best value reached and the FFE which gave this value.
+	 */
+	for (i = 0; i < MAX_NUM_OF_FFE; i++) {
+		rx_train_result = 0;
+		ret = mvebu_cp110_comphy_test_single_ffe(priv, comphy, i,
+							 &rx_train_result);
+
+		if ((!ret) && (rx_train_result > max_rx_train)) {
+			max_rx_train = rx_train_result;
+			max_rx_train_index = i;
+		}
+	}
+
+	/* If we were able to determine which FFE gives the best value,
+	 * now we need to set it and run RX training again (only for this
+	 * FFE).
+	 */
+	if (max_rx_train) {
+		ret = mvebu_cp110_comphy_test_single_ffe(priv, comphy,
+							 max_rx_train_index,
+							 &rx_train_result);
+	} else {
+		dev_err(priv->dev, "RX Training failed for comphy%d\n", comphy->index);
+		ret = -EINVAL;
+	}
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return ret;
+}
+
 static int mvebu_cp110_comphy_power_on(struct phy *phy)
 {
 	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
@@ -1738,6 +1912,17 @@ static int mvebu_cp110_comphy_send_command(struct phy *phy, u32 command)
 	 */
 	case COMPHY_COMMAND_PCIE_IS_EP:
 		priv->lanes[comphy->index].misc.pcie_is_ep = true;
+	case(COMPHY_COMMAND_SFI_RX_TRAINING):
+		switch (COMPHY_GET_MODE(priv->lanes[comphy->index].mode)) {
+		case (COMPHY_XFI_MODE):
+		case (COMPHY_SFI_MODE):
+			ret = mvebu_cp110_comphy_xfi_rx_training(priv, comphy);
+			break;
+		default:
+			dev_err(priv->dev, "%s: RX training (command 0x%x) is supported only for SFI/XFI mode!\n",
+				__func__, command);
+			ret = -EINVAL;
+		}
 		break;
 	default:
 		dev_err(priv->dev, "%s: unsupported command (0x%x)\n",
diff --git a/drivers/phy/phy-comphy-cp110.h b/drivers/phy/phy-comphy-cp110.h
index ac99588..264d7e5 100644
--- a/drivers/phy/phy-comphy-cp110.h
+++ b/drivers/phy/phy-comphy-cp110.h
@@ -7,6 +7,9 @@
 #define HPIPE_ADDR(base, lane)			(SD_ADDR(base, lane) + 0x800)
 #define COMPHY_ADDR(base, lane)			(base + 0x28 * lane)
 
+#define MAX_NUM_OF_FFE				8
+#define RX_TRAINING_TIMEOUT			500
+
 /* Comphy registers */
 #define COMMON_PHY_CFG1_REG			0x0
 #define COMMON_PHY_CFG1_PWR_UP_OFFSET		1
@@ -99,6 +102,10 @@
 #define SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET	7
 #define SD_EXTERNAL_CONFIG2_SSC_ENABLE_MASK	(0x1 << SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET)
 
+#define SD_EXTERNAL_STATUS_REG				0xc
+#define SD_EXTERNAL_STATUS_START_RX_TRAINING_OFFSET	7
+#define SD_EXTERNAL_STATUS_START_RX_TRAINING_MASK	(1 << SD_EXTERNAL_STATUS_START_RX_TRAINING_OFFSET)
+
 #define SD_EXTERNAL_STATUS0_REG			0x18
 #define SD_EXTERNAL_STATUS0_PLL_TX_OFFSET	2
 #define SD_EXTERNAL_STATUS0_PLL_TX_MASK		(0x1 << SD_EXTERNAL_STATUS0_PLL_TX_OFFSET)
@@ -107,6 +114,14 @@
 #define SD_EXTERNAL_STATUS0_RX_INIT_OFFSET	4
 #define SD_EXTERNAL_STATUS0_RX_INIT_MASK	(0x1 << SD_EXTERNAL_STATUS0_RX_INIT_OFFSET)
 
+#define SD_EXTERNAL_STATAUS1_REG			0x1c
+#define SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_COMP_OFFSET	0
+#define SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_COMP_MASK	\
+	(1 << SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_COMP_OFFSET)
+#define SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_FAILED_OFFSET	1
+#define SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_FAILED_MASK	\
+	(1 << SD_EXTERNAL_STATAUS1_REG_RX_TRAIN_FAILED_OFFSET)
+
 /* HPIPE registers */
 #define HPIPE_PWR_PLL_REG			0x4
 #define HPIPE_PWR_PLL_REF_FREQ_OFFSET		0
@@ -120,6 +135,12 @@
 #define HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET	15
 #define HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK	(0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET)
 
+#define HPIPE_SQUELCH_FFE_SETTING_REG           0x18
+#define HPIPE_SQUELCH_THRESH_IN_OFFSET		8
+#define HPIPE_SQUELCH_THRESH_IN_MASK		(0xf << HPIPE_SQUELCH_THRESH_IN_OFFSET)
+#define HPIPE_SQUELCH_DETECTED_OFFSET		14
+#define HPIPE_SQUELCH_DETECTED_MASK		(0x1 << HPIPE_SQUELCH_DETECTED_OFFSET)
+
 #define HPIPE_DFE_REG0				0x1c
 #define HPIPE_DFE_RES_FORCE_OFFSET		15
 #define HPIPE_DFE_RES_FORCE_MASK		(0x1 << HPIPE_DFE_RES_FORCE_OFFSET)
@@ -208,9 +229,25 @@
 #define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET	13
 #define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK	(0x1 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET)
 
+#define HPIPE_PHY_TEST_CONTROL_REG		0x54
+#define HPIPE_PHY_TEST_PATTERN_SEL_OFFSET	4
+#define HPIPE_PHY_TEST_PATTERN_SEL_MASK		(0xf << HPIPE_PHY_TEST_PATTERN_SEL_OFFSET)
+#define HPIPE_PHY_TEST_RESET_OFFSET		14
+#define HPIPE_PHY_TEST_RESET_MASK		(0x1 << HPIPE_PHY_TEST_RESET_OFFSET)
+#define HPIPE_PHY_TEST_EN_OFFSET		15
+#define HPIPE_PHY_TEST_EN_MASK			(0x1 << HPIPE_PHY_TEST_EN_OFFSET)
+
+#define HPIPE_PHY_TEST_DATA_REG			0x6c
+#define HPIPE_PHY_TEST_DATA_OFFSET		0
+#define HPIPE_PHY_TEST_DATA_MASK		(0xffff << HPIPE_PHY_TEST_DATA_OFFSET)
+
 #define HPIPE_LOOPBACK_REG			0x8c
 #define HPIPE_LOOPBACK_SEL_OFFSET		1
 #define HPIPE_LOOPBACK_SEL_MASK			(0x7 << HPIPE_LOOPBACK_SEL_OFFSET)
+#define HPIPE_CDR_LOCK_OFFSET			7
+#define HPIPE_CDR_LOCK_MASK			(0x1 << HPIPE_CDR_LOCK_OFFSET)
+#define HPIPE_CDR_LOCK_DET_EN_OFFSET		8
+#define HPIPE_CDR_LOCK_DET_EN_MASK		(0x1 << HPIPE_CDR_LOCK_DET_EN_OFFSET)
 
 #define HPIPE_INTERFACE_REG			0x94
 #define HPIPE_INTERFACE_GEN_MAX_OFFSET		10
@@ -296,6 +333,14 @@
 #define HPIPE_OS_PH_VALID_OFFSET		8
 #define HPIPE_OS_PH_VALID_MASK			(0x1 << HPIPE_OS_PH_VALID_OFFSET)
 
+#define HPIPE_SQ_GLITCH_FILTER_CTRL		0x1c8
+#define HPIPE_SQ_DEGLITCH_WIDTH_P_OFFSET	0
+#define HPIPE_SQ_DEGLITCH_WIDTH_P_MASK		(0xf << HPIPE_SQ_DEGLITCH_WIDTH_P_OFFSET)
+#define HPIPE_SQ_DEGLITCH_WIDTH_N_OFFSET	4
+#define HPIPE_SQ_DEGLITCH_WIDTH_N_MASK		(0xf << HPIPE_SQ_DEGLITCH_WIDTH_N_OFFSET)
+#define HPIPE_SQ_DEGLITCH_EN_OFFSET		8
+#define HPIPE_SQ_DEGLITCH_EN_MASK		(0x1 << HPIPE_SQ_DEGLITCH_EN_OFFSET)
+
 #define HPIPE_FRAME_DETECT_CTRL_0_REG		0x214
 #define HPIPE_TRAIN_PAT_NUM_OFFSET		0x7
 #define HPIPE_TRAIN_PAT_NUM_MASK		(0x1FF << HPIPE_TRAIN_PAT_NUM_OFFSET)
@@ -322,6 +367,10 @@
 #define HPIPE_TX_TRAIN_PAT_SEL_OFFSET		9
 #define HPIPE_TX_TRAIN_PAT_SEL_MASK		(0x1 << HPIPE_TX_TRAIN_PAT_SEL_OFFSET)
 
+#define HPIPE_SAVED_DFE_VALUES_REG             0x328
+#define HPIPE_SAVED_DFE_VALUES_SAV_F0D_OFFSET  10
+#define HPIPE_SAVED_DFE_VALUES_SAV_F0D_MASK    (0x3f << HPIPE_SAVED_DFE_VALUES_SAV_F0D_OFFSET)
+
 #define HPIPE_G1_SETTINGS_3_REG				0x440
 #define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET	0
 #define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK		(0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET)
diff --git a/include/dt-bindings/phy/phy-comphy-mvebu.h b/include/dt-bindings/phy/phy-comphy-mvebu.h
index 95c56d7..299fe63 100644
--- a/include/dt-bindings/phy/phy-comphy-mvebu.h
+++ b/include/dt-bindings/phy/phy-comphy-mvebu.h
@@ -125,6 +125,7 @@
 #define COMPHY_COMMAND_PCIE_WIDTH_4		0x00000005
 #define COMPHY_COMMAND_PCIE_WIDTH_UNSUPPORT	0x00000006
 #define COMPHY_COMMAND_PCIE_IS_EP		0x00000007
+#define COMPHY_COMMAND_SFI_RX_TRAINING		0x00000008
 
 #endif /* _DT_BINDINGS_PHY_COMPHY_MVEBU */
 
-- 
1.7.9.5


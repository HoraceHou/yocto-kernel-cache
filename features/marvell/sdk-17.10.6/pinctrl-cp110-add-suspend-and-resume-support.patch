From 550a97068854a122854f688fb9ab5b7f2c513e82 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Fri, 11 Aug 2017 18:13:44 +0800
Subject: [PATCH 1202/1345] pinctrl: cp110: add suspend and resume support

commit  aecd8dc082851788e5771c4e5fc5b3dcc220306e from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Before suspend, value of all MPP registers are save in
DRAM and when resume, the MPP registers are recovered
with values from DRAM.

Change-Id: I9bbb22b648f155525f74a3ac64bdaa32a0734a95
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42905
Reviewed-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pinctrl/mvebu/pinctrl-armada-cp110.c |  105 ++++++++++++++++++++++++--
 drivers/pinctrl/mvebu/pinctrl-mvebu.h        |   14 ++++
 2 files changed, 113 insertions(+), 6 deletions(-)

diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c b/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c
index fd3dcb2..dc1ede2 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c
@@ -20,29 +20,33 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/pinctrl/pinctrl.h>
+#include <linux/syscore_ops.h>
 
 #include "pinctrl-mvebu.h"
 
+/* Global list of devices (struct mvebu_pinctrl_soc_info) */
+static LIST_HEAD(drvdata_list);
+
 static void __iomem *cp0_mpp_base;
 
-static int armada_cp110_0_mpp_ctrl_get(unsigned pid, unsigned long *config)
+static int armada_cp110_0_mpp_ctrl_get(struct mvebu_mpp_ctrl_data *data, unsigned pid, unsigned long *config)
 {
 	return default_mpp_ctrl_get(cp0_mpp_base, pid, config);
 }
 
-static int armada_cp110_0_mpp_ctrl_set(unsigned pid, unsigned long config)
+static int armada_cp110_0_mpp_ctrl_set(struct mvebu_mpp_ctrl_data *data, unsigned pid, unsigned long config)
 {
 	return default_mpp_ctrl_set(cp0_mpp_base, pid, config);
 }
 
 static void __iomem *cp1_mpp_base;
 
-static int armada_cp110_1_mpp_ctrl_get(unsigned pid, unsigned long *config)
+static int armada_cp110_1_mpp_ctrl_get(struct mvebu_mpp_ctrl_data *data, unsigned pid, unsigned long *config)
 {
 	return default_mpp_ctrl_get(cp1_mpp_base, pid, config);
 }
 
-static int armada_cp110_1_mpp_ctrl_set(unsigned pid, unsigned long config)
+static int armada_cp110_1_mpp_ctrl_set(struct mvebu_mpp_ctrl_data *data, unsigned pid, unsigned long config)
 {
 	return default_mpp_ctrl_set(cp1_mpp_base, pid, config);
 }
@@ -660,6 +664,7 @@ enum {
 static int armada_cp110_pinctrl_probe(struct platform_device *pdev)
 {
 	struct mvebu_pinctrl_soc_info *soc;
+	struct mvebu_pinctrl_pm_save *pm_save;
 	const struct of_device_id *match =
 		of_match_device(armada_cp110_pinctrl_of_match, &pdev->dev);
 	struct resource *res;
@@ -702,16 +707,86 @@ static int armada_cp110_pinctrl_probe(struct platform_device *pdev)
 		break;
 	}
 
+#ifdef CONFIG_PM
+	pm_save = devm_kzalloc(&pdev->dev,
+			       sizeof(struct mvebu_pinctrl_pm_save),
+			       GFP_KERNEL);
+	if (!pm_save)
+		return -ENOMEM;
+
+	pm_save->length = resource_size(res);
+	/* Allocate memory to save the register value before suspend. */
+	pm_save->regs = (unsigned int *)devm_kzalloc(&pdev->dev,
+						     pm_save->length,
+						     GFP_KERNEL);
+	if (!pm_save->regs)
+		return -ENOMEM;
+
+	soc->pm_save = pm_save;
+#endif /* CONFIG_PM */
+
 	pdev->dev.platform_data = soc;
 
+	/* Add to the global list */
+	list_add_tail(&soc->node, &drvdata_list);
+
 	return mvebu_pinctrl_probe(pdev);
 }
 
 static int armada_cp110_pinctrl_remove(struct platform_device *pdev)
 {
-	return mvebu_pinctrl_remove(pdev);
+	return 0;
 }
 
+#ifdef CONFIG_PM
+/* armada_cp110_pinctrl_suspend - save pinctrl register for suspend */
+static int armada_cp110_pinctrl_suspend(void)
+{
+	struct mvebu_pinctrl_soc_info *soc;
+	void __iomem *mpp_base;
+	u32 reg_num, offset, i;
+
+	list_for_each_entry(soc, &drvdata_list, node) {
+		mpp_base = (soc->variant == V_ARMADA_80X0_CP1) ? cp1_mpp_base :
+								 cp0_mpp_base;
+		reg_num = soc->pm_save->length / sizeof(unsigned int);
+		for (i = 0; i < reg_num; i++) {
+			offset = i * sizeof(unsigned int);
+			soc->pm_save->regs[i] = readl(mpp_base + offset);
+		}
+	}
+
+	return 0;
+}
+
+/* armada_cp110_pinctrl_resume - restore pinctrl register for suspend */
+static void armada_cp110_pinctrl_resume(void)
+{
+	struct mvebu_pinctrl_soc_info *soc;
+	void __iomem *mpp_base;
+	u32 reg_num, offset, i;
+
+	list_for_each_entry_reverse(soc, &drvdata_list, node) {
+		mpp_base = (soc->variant == V_ARMADA_80X0_CP1) ? cp1_mpp_base :
+								 cp0_mpp_base;
+		reg_num = soc->pm_save->length / sizeof(unsigned int);
+		for (i = 0; i < reg_num; i++) {
+			offset = i * sizeof(unsigned int);
+			writel(soc->pm_save->regs[i], mpp_base + offset);
+		}
+	}
+}
+
+#else
+#define armada_cp110_pinctrl_suspend		NULL
+#define armada_cp110_pinctrl_resume		NULL
+#endif /* CONFIG_PM */
+
+static struct syscore_ops armada_cp110_pinctrl_syscore_ops = {
+	.suspend	= armada_cp110_pinctrl_suspend,
+	.resume		= armada_cp110_pinctrl_resume,
+};
+
 static struct platform_driver armada_cp110_pinctrl_driver = {
 	.driver = {
 		.name = "armada-cp110-pinctrl",
@@ -721,7 +796,25 @@ static int armada_cp110_pinctrl_remove(struct platform_device *pdev)
 	.remove = armada_cp110_pinctrl_remove,
 };
 
-module_platform_driver(armada_cp110_pinctrl_driver);
+static int __init armada_cp110_pinctrl_drv_register(void)
+{
+	/*
+	 * Register syscore ops for save/restore of registers across suspend.
+	 * It's important to ensure that this driver is running at an earlier
+	 * initcall level than any arch-specific init calls that install syscore
+	 * ops that turn off pad retention.
+	 */
+	register_syscore_ops(&armada_cp110_pinctrl_syscore_ops);
+
+	return platform_driver_register(&armada_cp110_pinctrl_driver);
+}
+postcore_initcall(armada_cp110_pinctrl_drv_register);
+
+static void __exit armada_cp110_pinctrl_drv_unregister(void)
+{
+	platform_driver_unregister(&armada_cp110_pinctrl_driver);
+}
+module_exit(armada_cp110_pinctrl_drv_unregister);
 
 MODULE_AUTHOR("Hanna Hawa <hannah@marvell.com>");
 MODULE_DESCRIPTION("Marvell Armada CP-110 pinctrl driver");
diff --git a/drivers/pinctrl/mvebu/pinctrl-mvebu.h b/drivers/pinctrl/mvebu/pinctrl-mvebu.h
index 2b58fd3..e91f558 100644
--- a/drivers/pinctrl/mvebu/pinctrl-mvebu.h
+++ b/drivers/pinctrl/mvebu/pinctrl-mvebu.h
@@ -110,6 +110,7 @@ struct mvebu_mpp_mode {
 
 /**
  * struct mvebu_pinctrl_soc_info - SoC specific info passed to pinctrl-mvebu
+ * @node: global list node
  * @variant: variant mask of soc_info
  * @controls: list of available mvebu_mpp_ctrls
  * @control_data: optional array, one entry for each control
@@ -118,12 +119,14 @@ struct mvebu_mpp_mode {
  * @nmodes: number of available mvebu_mpp_modes
  * @gpioranges: list of pinctrl_gpio_ranges
  * @ngpioranges: number of available pinctrl_gpio_ranges
+ * @pm_save: saved register values during suspend
  *
  * This struct describes all pinctrl related information for a specific SoC.
  * If variant is unequal 0 it will be matched (AND) with variant of each
  * setting and allows to distinguish between different revisions of one SoC.
  */
 struct mvebu_pinctrl_soc_info {
+	struct list_head node;
 	u8 variant;
 	const struct mvebu_mpp_ctrl *controls;
 	struct mvebu_mpp_ctrl_data *control_data;
@@ -132,6 +135,17 @@ struct mvebu_pinctrl_soc_info {
 	int nmodes;
 	struct pinctrl_gpio_range *gpioranges;
 	int ngpioranges;
+	struct mvebu_pinctrl_pm_save *pm_save;
+};
+
+/**
+ * struct mvebu_pinctrl_pm_save - pinctrl register save when PM
+ * @regs: to save register value when suspend
+ * @settings: inidcates register space length to save
+ */
+struct mvebu_pinctrl_pm_save {
+	unsigned int *regs;
+	unsigned int length;
 };
 
 #define MPP_FUNC_CTRL(_idl, _idh, _name, _func)			\
-- 
1.7.9.5


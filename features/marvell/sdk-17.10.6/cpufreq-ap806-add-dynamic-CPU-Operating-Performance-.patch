From 7ef9f42dd9c891bf4150ab7405cafa2b5a50f0f5 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Thu, 10 Nov 2016 10:26:40 +0200
Subject: [PATCH 0602/1345] cpufreq: ap806: add dynamic CPU Operating
 Performance Points

commit  0e55877a97a30bd94a806c655680219bb46c3a80 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

AP806 supports DFS (Dynamic Frequnecy Scaling) between the nominal CPU
frequency and full integer divisions of it.
Additionally, AP806 can boot with different CPU frequency configuration
(Sampled at reset), so the supported DFS points are dependent on the
actual CPU boot settings.

This patch introduces dynamic support for OPP (Operating Performance
Points) according to booted CPU frequency, and registers 3 OPP (the
nominal CPU, and divison by 2 and 3 of it).
These OPP entries are registered dynamicaly, in addition to the default
100Mhz entry which is set in device tree.

Change-Id: Ie9d70f0f8fc2390a3784499eafb0bd9e3de18593
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/33660
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/cpufreq/armada8k-cpufreq.c |   53 ++++++++++++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

diff --git a/drivers/cpufreq/armada8k-cpufreq.c b/drivers/cpufreq/armada8k-cpufreq.c
index 4621c3f..9bc4c64 100644
--- a/drivers/cpufreq/armada8k-cpufreq.c
+++ b/drivers/cpufreq/armada8k-cpufreq.c
@@ -18,16 +18,69 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cpu.h>
+#include <linux/pm_opp.h>
+#include <linux/cpufreq.h>
 
 static int __init armada8k_cpufreq_driver_init(void)
 {
 	struct platform_device *pdev;
 	struct device_node *node;
+	int cpu;
+	unsigned int cur_frequency;
 
 	node = of_find_compatible_node(NULL, NULL, "marvell,ap806-cpu-clk");
 	if (!node || !of_device_is_available(node))
 		return -ENODEV;
 
+	/*
+	 * For each CPU, this loop registers the operating points
+	 * supported (which are the nominal CPU frequency and full integer
+	 * divisions of it).
+	 */
+	for_each_possible_cpu(cpu) {
+		struct device *cpu_dev;
+		struct clk *clk;
+		int ret;
+
+		cpu_dev = get_cpu_device(cpu);
+		if (!cpu_dev) {
+			dev_err(cpu_dev, "Cannot get CPU %d\n", cpu);
+			continue;
+		}
+
+		clk = clk_get(cpu_dev, 0);
+		if (IS_ERR(clk)) {
+			dev_err(cpu_dev, "Cannot get clock for CPU %d\n", cpu);
+			return PTR_ERR(clk);
+		}
+
+		/* Get nominal (current) CPU frequency */
+		cur_frequency = clk_get_rate(clk);
+		if (!cur_frequency) {
+			dev_err(cpu_dev, "Failed to get clock rate for CPU %d\n", cpu);
+			return -EINVAL;
+		}
+
+		/* In case of a failure of dev_pm_opp_add(), we don't
+		 * bother with cleaning up the registered OPP (there's
+		 * no function to do so), and simply cancel the
+		 * registration of the cpufreq device.
+		 */
+		ret = dev_pm_opp_add(cpu_dev, cur_frequency, 0);
+		if (ret)
+			return ret;
+
+		ret = dev_pm_opp_add(cpu_dev, cur_frequency / 2, 0);
+		if (ret)
+			return ret;
+
+		ret = dev_pm_opp_add(cpu_dev, cur_frequency / 3, 0);
+		if (ret)
+			return ret;
+	}
+
 	pdev = platform_device_register_simple("cpufreq-dt", -1, NULL, 0);
 
 	return PTR_ERR_OR_ZERO(pdev);
-- 
1.7.9.5


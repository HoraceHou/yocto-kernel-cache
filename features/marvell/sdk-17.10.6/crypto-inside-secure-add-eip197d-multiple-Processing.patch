From 2d3eaa4cb1c5c95ebde8595c93dbb259f86344f0 Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Thu, 23 Nov 2017 14:15:19 +0200
Subject: [PATCH 1274/1345] crypto: inside-secure: add eip197d multiple
 Processing Engine support

commit  677d4307c1e201e14a1fc2973c9c56ed9aaf6f4f from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

eip197d includes 4 PEs, this patch adds driver support to configure
all PEs. PE count comes from HW register and is saved per eip197
device, the eip197 HW version is also saved in this structure.

Change-Id: I232ba051b39bd593e4e58088a1e7302e5c60abe0
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/51655
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/crypto/inside-secure/safexcel.c |  315 ++++++++++++++++---------------
 drivers/crypto/inside-secure/safexcel.h |   61 +++---
 2 files changed, 203 insertions(+), 173 deletions(-)

diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
index b91e820..806c1b9 100644
--- a/drivers/crypto/inside-secure/safexcel.c
+++ b/drivers/crypto/inside-secure/safexcel.c
@@ -28,36 +28,36 @@
 static uint rings[MAX_EIP_DEVICE] = {RINGS_UNINITIALIZED, RINGS_UNINITIALIZED};
 
 /* Initialize pseudo random generator */
-static void eip197_prng_init(struct safexcel_crypto_priv *priv)
+static void eip197_prng_init(struct safexcel_crypto_priv *priv, int pe)
 {
 	/* disable PRNG and set to manual mode */
-	writel(0, EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_CTRL);
+	writel(0, EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_CTRL(pe));
 
 	/* Write seed data */
 	writel(EIP197_PE_EIP96_PRNG_SEED_L_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_SEED_L);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_SEED_L(pe));
 	writel(EIP197_PE_EIP96_PRNG_SEED_H_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_SEED_H);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_SEED_H(pe));
 
 	/* Write key data */
 	writel(EIP197_PE_EIP96_PRNG_KEY_0_L_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_0_L);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_0_L(pe));
 	writel(EIP197_PE_EIP96_PRNG_KEY_0_H_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_0_H);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_0_H(pe));
 	writel(EIP197_PE_EIP96_PRNG_KEY_1_L_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_1_L);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_1_L(pe));
 	writel(EIP197_PE_EIP96_PRNG_KEY_1_H_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_1_H);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_KEY_1_H(pe));
 
 	/* Write LFSR data */
 	writel(EIP197_PE_EIP96_PRNG_LFSR_L_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_LFSR_L);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_LFSR_L(pe));
 	writel(EIP197_PE_EIP96_PRNG_LFSR_H_VAL,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_LFSR_H);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_LFSR_H(pe));
 
 	/* enable PRNG and set to auto mode */
 	writel(EIP197_PE_EIP96_PRNG_EN | EIP197_PE_EIP96_PRNG_AUTO,
-	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_CTRL);
+	       EIP197_PE(priv) + EIP197_PE_EIP96_PRNG_CTRL(pe));
 }
 
 /* Initialize transform record cache */
@@ -253,7 +253,7 @@ static int eip197_load_fw(struct device *dev, struct safexcel_crypto_priv *priv)
 {
 	const struct firmware	*fw[MAX_FW_NR] = {0};
 	const u32		*fw_data;
-	int			i, ret;
+	int			i, ret, pe;
 	u32			fw_size, reg;
 	const char		*fw_name[MAX_FW_NR] = {"eip197/197b/ifpp.bin",
 						       "eip197/197b/ipue.bin"};
@@ -267,31 +267,33 @@ static int eip197_load_fw(struct device *dev, struct safexcel_crypto_priv *priv)
 		}
 	 }
 
-	/* Clear EIP-207c ICE Scratchpad RAM where the firmware */
-	reg = (EIP197_PE_ICE_SCRATCH_CTRL_DFLT				|
-	       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_TIMER			|
-	       EIP197_PE_ICE_SCRATCH_CTRL_TIMER_EN			|
-	       ((0x1 << EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS_OFFSET) &
-		EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS_MASK)		|
-	       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_ACCESS);
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL_OFFSET);
-
-	/* Write the ICE Scratchpad RAM with 0 */
-	for (i = 0; i < EIP197_NUM_OF_SCRATCH_BLOCKS; i++)
-		writel(0, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_RAM(i));
-
-	/* Reset the Input Flow Post-Processor micro-engine (IFPP) to make its
-	 * program RAM accessible.
-	 */
-	reg = (EIP197_PE_ICE_FPP_CTRL_SW_RESET			|
-	       EIP197_PE_ICE_FPP_CTRL_CLR_ECC_CORR		|
-	       EIP197_PE_ICE_FPP_CTRL_CLR_ECC_NON_CORR);
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_FPP_CTRL);
-
-	/* Enable access to IFPP Program RAM */
-	reg = (EIP197_PE_ICE_RAM_CTRL_DFLT |
-	       EIP197_PE_ICE_RAM_CTRL_FPP_PROG_EN);
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
+	for (pe = 0; pe < priv->nr_pe; pe++) {
+		/* Clear EIP-207c ICE Scratchpad RAM where the firmware */
+		reg = (EIP197_PE_ICE_SCRATCH_CTRL_DFLT				|
+		       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_TIMER			|
+		       EIP197_PE_ICE_SCRATCH_CTRL_TIMER_EN			|
+		       ((0x1 << EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS_OFFSET) &
+			EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS_MASK)		|
+		       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_ACCESS);
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL_OFFSET(pe));
+
+		/* Write the ICE Scratchpad RAM with 0 */
+		for (i = 0; i < EIP197_NUM_OF_SCRATCH_BLOCKS; i++)
+			writel(0, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_RAM(i, pe));
+
+		/* Reset the Input Flow Post-Processor micro-engine (IFPP) to make its
+		 * program RAM accessible.
+		 */
+		reg = (EIP197_PE_ICE_FPP_CTRL_SW_RESET			|
+		       EIP197_PE_ICE_FPP_CTRL_CLR_ECC_CORR		|
+		       EIP197_PE_ICE_FPP_CTRL_CLR_ECC_NON_CORR);
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_FPP_CTRL(pe));
+
+		/* Enable access to IFPP Program RAM */
+		reg = (EIP197_PE_ICE_RAM_CTRL_DFLT |
+		       EIP197_PE_ICE_RAM_CTRL_FPP_PROG_EN);
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL(pe));
+	}
 
 	/* Save pointer to the data and the size of the data */
 	fw_data = (const u32 *)fw[IFPP_FW]->data;
@@ -302,20 +304,22 @@ static int eip197_load_fw(struct device *dev, struct safexcel_crypto_priv *priv)
 		writel(be32_to_cpu(*(fw_data + i)),
 		       priv->base + EIP197_CLASSIF_RAM_ACCESS_SPACE + (i * 4));
 
-	/* Disable access to IFPP Program RAM
-	 * Enable access to IPUE Program RAM
-	 */
-	reg = (EIP197_PE_ICE_RAM_CTRL_DFLT |
-	       EIP197_PE_ICE_RAM_CTRL_PUE_PROG_EN);
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
-
-	/* Reset the Input Pull-Up micro-Engine (IPUE) to make its
-	 * program RAM accessible.
-	 */
-	reg = (EIP197_PE_ICE_PUE_CTRL_SW_RESET		|
-	       EIP197_PE_ICE_PUE_CTRL_CLR_ECC_CORR	|
-	       EIP197_PE_ICE_PUE_CTRL_CLR_ECC_NON_CORR);
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_PUE_CTRL);
+	for (pe = 0; pe < priv->nr_pe; pe++) {
+		/* Disable access to IFPP Program RAM
+		 * Enable access to IPUE Program RAM
+		 */
+		reg = (EIP197_PE_ICE_RAM_CTRL_DFLT |
+		       EIP197_PE_ICE_RAM_CTRL_PUE_PROG_EN);
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL(pe));
+
+		/* Reset the Input Pull-Up micro-Engine (IPUE) to make its
+		 * program RAM accessible.
+		 */
+		reg = (EIP197_PE_ICE_PUE_CTRL_SW_RESET		|
+		       EIP197_PE_ICE_PUE_CTRL_CLR_ECC_CORR	|
+		       EIP197_PE_ICE_PUE_CTRL_CLR_ECC_NON_CORR);
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_PUE_CTRL(pe));
+	}
 
 	/* Save pointer to the data and the size of the data */
 	fw_data = (const u32 *)fw[IPUE_FW]->data;
@@ -325,19 +329,21 @@ static int eip197_load_fw(struct device *dev, struct safexcel_crypto_priv *priv)
 	for (i = 0; i < fw_size; i++)
 		writel(be32_to_cpu(*(fw_data + i)), EIP197_RAM(priv) + (i * 4));
 
-	/* Disable access to IPUE Program RAM */
-	reg = EIP197_PE_ICE_RAM_CTRL_DFLT;
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
+	for (pe = 0; pe < priv->nr_pe; pe++) {
+		/* Disable access to IPUE Program RAM */
+		reg = EIP197_PE_ICE_RAM_CTRL_DFLT;
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL(pe));
 
-	/* Release IFPP from reset */
-	reg = readl(priv->base + EIP197_PE_ICE_PUE_CTRL);
-	reg &= ~EIP197_PE_ICE_FPP_CTRL_SW_RESET;
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_FPP_CTRL);
+		/* Release IFPP from reset */
+		reg = readl(priv->base + EIP197_PE_ICE_PUE_CTRL(pe));
+		reg &= ~EIP197_PE_ICE_FPP_CTRL_SW_RESET;
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_FPP_CTRL(pe));
 
-	/* Release IPUE from reset */
-	reg = readl(priv->base + EIP197_PE_ICE_PUE_CTRL);
-	reg &= ~EIP197_PE_ICE_PUE_CTRL_SW_RESET;
-	writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_PUE_CTRL);
+		/* Release IPUE from reset */
+		reg = readl(priv->base + EIP197_PE_ICE_PUE_CTRL(pe));
+		reg &= ~EIP197_PE_ICE_PUE_CTRL_SW_RESET;
+		writel(reg, EIP197_PE(priv) + EIP197_PE_ICE_PUE_CTRL(pe));
+	}
 
 	for (i = 0; i < MAX_FW_NR; i++)
 		release_firmware(fw[i]);
@@ -505,7 +511,7 @@ static int eip_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
 static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 {
 	u32 version, val;
-	int i, ret;
+	int i, ret, pe;
 
 	/* Determine endianness and configure byte swap */
 	version = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_VERSION);
@@ -518,7 +524,6 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 
 	writel(val, EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);
 
-
 	/* configure wr/rd cache values */
 	val = MST_CTRL_RD_CACHE(RD_CACHE_4BITS) | MST_CTRL_WD_CACHE(WR_CACHE_4BITS);
 	writel(val, EIP197_HIA_GEN_CFG(priv) + EIP197_MST_CTRL);
@@ -534,86 +539,87 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 	writel(EIP197_AIC_G_ACK_ALL_MASK, EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
 
 	/*
-	 * Data Fetch Engine configuration
+	 * Processing Engine configuration
 	 */
+	for (pe = 0; pe < priv->nr_pe; pe++) {
+		/*
+		 * Data Fetch Engine configuration
+		 */
+
+		/* Reset all DFE threads */
+		writel(EIP197_DxE_THR_CTRL_RESET_PE,
+		       EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL(pe));
+
+		/* Configure ring arbiter, available only for EIP197 */
+		if (priv->eip_type == EIP197) {
+			/* Reset HIA input interface arbiter */
+			writel(EIP197_HIA_RA_PE_CTRL_RESET,
+			       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL(pe));
+		}
 
-	/* Reset all DFE threads */
-	writel(EIP197_DxE_THR_CTRL_RESET_PE,
-	       EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL);
-
-	/* Configure ring arbiter, available only for EIP197 */
-	if (priv->eip_type == EIP197) {
-		/* Reset HIA input interface arbiter */
-		writel(EIP197_HIA_RA_PE_CTRL_RESET,
-		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
-	}
-
-	/* DMA transfer size to use */
-	val = EIP197_HIA_DFE_CFG_DIS_DEBUG;
-	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(5) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(9);
-	val |= EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(5) | EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(7);
-	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(RD_CACHE_3BITS);
-	val |= EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(RD_CACHE_3BITS);
-	writel(val, EIP197_HIA_DFE(priv) + EIP197_HIA_DFE_CFG);
-
-	/* Leave the DFE threads reset state */
-	writel(0, EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL);
-
-	/* Configure the procesing engine thresholds */
-	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(9),
-	      EIP197_PE(priv) + EIP197_PE_IN_DBUF_THRES);
-	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(7),
-	      EIP197_PE(priv) + EIP197_PE_IN_TBUF_THRES);
+		/* DMA transfer size to use */
+		val = EIP197_HIA_DFE_CFG_DIS_DEBUG;
+		val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(5) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(9);
+		val |= EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(5) | EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(7);
+		val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(RD_CACHE_3BITS);
+		val |= EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(RD_CACHE_3BITS);
+		writel(val, EIP197_HIA_DFE(priv) + EIP197_HIA_DFE_CFG(pe));
+
+		/* Leave the DFE threads reset state */
+		writel(0, EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL(pe));
+
+		/* Configure the procesing engine thresholds */
+		writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(9),
+		      EIP197_PE(priv) + EIP197_PE_IN_DBUF_THRES(pe));
+		writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(7),
+		      EIP197_PE(priv) + EIP197_PE_IN_TBUF_THRES(pe));
+
+		/* Configure ring arbiter, available only for EIP197 */
+		if (priv->eip_type == EIP197) {
+			/* enable HIA input interface arbiter and rings */
+			writel(EIP197_HIA_RA_PE_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
+			       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL(pe));
+		}
 
-	/* Configure ring arbiter, available only for EIP197 */
-	if (priv->eip_type == EIP197) {
-		/* enable HIA input interface arbiter and rings */
-		writel(EIP197_HIA_RA_PE_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
-		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
+		/*
+		 * Data Store Engine configuration
+		 */
+
+		/* Reset all DSE threads */
+		writel(EIP197_DxE_THR_CTRL_RESET_PE,
+		       EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_CTRL(pe));
+
+		/* Wait for all DSE threads to complete */
+		while ((readl(EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_STAT(pe)) &
+		       EIP197_DSE_THR_RDR_ID_MASK) != EIP197_DSE_THR_RDR_ID_MASK)
+			;
+
+		/* DMA transfer size to use */
+		val = EIP197_HIA_DSE_CFG_DIS_DEBUG;
+		val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
+		val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
+		val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
+		/*
+		 * TODO: Generally, EN_SINGLE_WR should be enabled.
+		 * Some instabilities with this option enabled might occur,
+		 * so further investigation is required before enabling it.
+		 *
+		 * Using EIP97 engine without SINGLE_WR impacts the performance.
+		 */
+		if (priv->eip_type == EIP197)
+			val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
+
+		writel(val, EIP197_HIA_DSE(priv) + EIP197_HIA_DSE_CFG(pe));
+
+		/* Leave the DSE threads reset state */
+		writel(0, EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_CTRL(pe));
+
+		/* Configure the procesing engine thresholds */
+		writel(EIP197_PE_OUT_DBUF_THRES_MIN(7) | EIP197_PE_OUT_DBUF_THRES_MAX(8),
+		       EIP197_PE(priv) + EIP197_PE_OUT_DBUF_THRES(pe));
 	}
 
 	/*
-	 * Data Store Engine configuration
-	 */
-
-	/* Reset all DSE threads */
-	writel(EIP197_DxE_THR_CTRL_RESET_PE,
-	       EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_CTRL);
-
-	/* Wait for all DSE threads to complete */
-	while ((readl(EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_STAT) &
-	       EIP197_DSE_THR_RDR_ID_MASK) != EIP197_DSE_THR_RDR_ID_MASK)
-		;
-
-	/* DMA transfer size to use */
-	val = EIP197_HIA_DSE_CFG_DIS_DEBUG;
-	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
-	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
-	val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
-	/*
-	 * TODO: Generally, EN_SINGLE_WR should be enabled.
-	 * Some instabilities with this option enabled might occur,
-	 * so further investigation is required before enabling it.
-	 *
-	 * Using EIP97 engine without SINGLE_WR impacts the performance.
-	 */
-	if (priv->eip_type == EIP197)
-		val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
-
-	writel(val, EIP197_HIA_DSE(priv) + EIP197_HIA_DSE_CFG);
-
-	/* Leave the DSE threads reset state */
-	writel(0, EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_CTRL);
-
-	/* Configure the procesing engine thresholds */
-	writel(EIP197_PE_OUT_DBUF_THRES_MIN(7) | EIP197_PE_OUT_DBUF_THRES_MAX(8),
-	       EIP197_PE(priv) + EIP197_PE_OUT_DBUF_THRES);
-
-	/*
-	 * Processing Engine configuration
-	 */
-
-	/*
 	 * Command Descriptor Rings prepare
 	 */
 	for (i = 0; i < priv->config.hw_rings; i++) {
@@ -663,13 +669,15 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 		       EIP197_HIA_AIC_xDR(priv) + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_SIZE);
 	}
 
-	/* Enable command descriptor rings */
-	writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
-	       EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL);
+	for (pe = 0; pe < priv->nr_pe; pe++) {
+		/* Enable command descriptor rings */
+		writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
+		       EIP197_HIA_DFE_THRD(priv) + EIP197_HIA_DFE_THR_CTRL(pe));
 
-	/* Enable result descriptor rings */
-	writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
-	       EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_CTRL);
+		/* Enable result descriptor rings */
+		writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.hw_rings - 1, 0),
+		       EIP197_HIA_DSE_THRD(priv) + EIP197_HIA_DSE_THR_CTRL(pe));
+	}
 
 	/* Clear any HIA interrupt */
 	writel(EIP197_AIC_G_ACK_HIA_MASK, EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
@@ -682,7 +690,8 @@ static int eip197_hw_init(struct device *dev, struct safexcel_crypto_priv *priv)
 	 */
 	if (priv->eip_type == EIP197) {
 		/* init PRNG */
-		eip197_prng_init(priv);
+		for (pe = 0; pe < priv->nr_pe; pe++)
+			eip197_prng_init(priv, pe);
 
 		/* init transform record cache */
 		ret = eip197_trc_cache_init(dev, priv);
@@ -1198,13 +1207,23 @@ static void safexcel_configure(struct safexcel_crypto_priv *priv)
 	u32 val, mask;
 
 	val = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
-	val = (val & EIP197_xDR_HDW_MASK) >> EIP197_xDR_HDW_OFFSET;
-	mask = BIT(val) - 1;
+
+	/* Read number of PEs from the engine & set eip197 HW version */
+	mask = (priv->eip_type == EIP97) ? EIP97_N_PES_MASK : EIP197_N_PES_MASK;
+	priv->nr_pe = (val >> EIP197_N_PES_OFFSET) & mask;
+	if (priv->eip_type == EIP197) {
+		if (priv->nr_pe == 1)
+			priv->eip197_hw_ver = EIP197B;
+		else
+			priv->eip197_hw_ver = EIP197D;
+	}
 
 	/* Read number of rings from the engine */
-	val = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
 	priv->config.hw_rings = val & EIP197_N_RINGS_MASK;
 
+	val = (val & EIP197_xDR_HDW_MASK) >> EIP197_xDR_HDW_OFFSET;
+	mask = BIT(val) - 1;
+
 	/* Check the requested number of rings given in the module param.
 	 * If the module param is uninitialized, use all available rings
 	 */
diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
index 954a155..af6c5c8 100644
--- a/drivers/crypto/inside-secure/safexcel.h
+++ b/drivers/crypto/inside-secure/safexcel.h
@@ -115,16 +115,16 @@
 
 /* EIP-96 PRNG */
 /* Registers   */
-#define EIP197_PE_EIP96_PRNG_STAT			0x01040
-#define EIP197_PE_EIP96_PRNG_CTRL			0x01044
-#define EIP197_PE_EIP96_PRNG_SEED_L			0x01048
-#define EIP197_PE_EIP96_PRNG_SEED_H			0x0104c
-#define EIP197_PE_EIP96_PRNG_KEY_0_L			0x01050
-#define EIP197_PE_EIP96_PRNG_KEY_0_H			0x01054
-#define EIP197_PE_EIP96_PRNG_KEY_1_L			0x01058
-#define EIP197_PE_EIP96_PRNG_KEY_1_H			0x0105c
-#define EIP197_PE_EIP96_PRNG_LFSR_L			0x01070
-#define EIP197_PE_EIP96_PRNG_LFSR_H			0x01074
+#define EIP197_PE_EIP96_PRNG_STAT(n)			(0x01040 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_CTRL(n)			(0x01044 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_SEED_L(n)			(0x01048 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_SEED_H(n)			(0x0104c + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_KEY_0_L(n)			(0x01050 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_KEY_0_H(n)			(0x01054 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_KEY_1_L(n)			(0x01058 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_KEY_1_H(n)			(0x0105c + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_LFSR_L(n)			(0x01070 + (0x2000 * n))
+#define EIP197_PE_EIP96_PRNG_LFSR_H(n)			(0x01074 + (0x2000 * n))
 /* Register bits */
 #define EIP197_PE_EIP96_PRNG_EN				BIT(0)
 #define EIP197_PE_EIP96_PRNG_AUTO			BIT(1)
@@ -139,10 +139,11 @@
 #define EIP197_PE_EIP96_PRNG_LFSR_H_VAL			0xd008c4b4
 
 /* Firmware */
-#define EIP197_PE_ICE_SCRATCH_RAM(x)			(0x800 + (x * 4))
+#define EIP197_PE_ICE_SCRATCH_RAM(x, n)			((0x800 + (x * 4)) + \
+							 (0x2000 * n))
 #define EIP197_NUM_OF_SCRATCH_BLOCKS			32
 
-#define EIP197_PE_ICE_SCRATCH_CTRL_OFFSET		0xd04
+#define EIP197_PE_ICE_SCRATCH_CTRL_OFFSET(n)		(0xd04 + (0x2000 * n))
 #define EIP197_PE_ICE_SCRATCH_CTRL_DFLT			0x001f0200
 #define EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_TIMER		BIT(2)
 #define EIP197_PE_ICE_SCRATCH_CTRL_TIMER_EN		BIT(3)
@@ -150,17 +151,17 @@
 #define EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS_OFFSET	25
 #define EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS_MASK	(GENMASK(28, 25))
 
-#define EIP197_PE_ICE_PUE_CTRL				0xc80
+#define EIP197_PE_ICE_PUE_CTRL(n)			(0xc80 + (0x2000 * n))
 #define EIP197_PE_ICE_PUE_CTRL_SW_RESET			BIT(0)
 #define EIP197_PE_ICE_PUE_CTRL_CLR_ECC_CORR		BIT(14)
 #define EIP197_PE_ICE_PUE_CTRL_CLR_ECC_NON_CORR		BIT(15)
 
-#define EIP197_PE_ICE_FPP_CTRL				0xd80
+#define EIP197_PE_ICE_FPP_CTRL(n)			(0xd80 + (0x2000 * n))
 #define EIP197_PE_ICE_FPP_CTRL_SW_RESET			BIT(0)
 #define EIP197_PE_ICE_FPP_CTRL_CLR_ECC_NON_CORR		BIT(14)
 #define EIP197_PE_ICE_FPP_CTRL_CLR_ECC_CORR		BIT(15)
 
-#define EIP197_PE_ICE_RAM_CTRL				0xff0
+#define EIP197_PE_ICE_RAM_CTRL(n)			(0xff0 + (0x2000 * n))
 #define EIP197_PE_ICE_RAM_CTRL_DFLT			0x00000000
 #define EIP197_PE_ICE_RAM_CTRL_PUE_PROG_EN		BIT(0)
 #define EIP197_PE_ICE_RAM_CTRL_FPP_PROG_EN		BIT(1)
@@ -267,15 +268,15 @@
 #define EIP197_HIA_AIC_R_ACK(r)			(0xe010 - EIP197_HIA_AIC_R_OFF(r))
 #define EIP197_HIA_AIC_R_ENABLE_CLR(r)		(0xe014 - EIP197_HIA_AIC_R_OFF(r))
 
-#define EIP197_HIA_RA_PE_CTRL			0x010
+#define EIP197_HIA_RA_PE_CTRL(n)		(0x010 + (8 * n))
 
-#define EIP197_HIA_DFE_CFG			0x000
-#define EIP197_HIA_DFE_THR_CTRL			0x000
-#define EIP197_HIA_DFE_THR_STAT			0x004
+#define EIP197_HIA_DFE_CFG(n)			(0x000 + (128 * n))
+#define EIP197_HIA_DFE_THR_CTRL(n)		(0x000 + (128 * n))
+#define EIP197_HIA_DFE_THR_STAT(n)		(0x004 + (128 * n))
 
-#define EIP197_HIA_DSE_CFG			0x000
-#define EIP197_HIA_DSE_THR_CTRL			0x000
-#define EIP197_HIA_DSE_THR_STAT			0x004
+#define EIP197_HIA_DSE_CFG(n)			(0x000 + (128 * n))
+#define EIP197_HIA_DSE_THR_CTRL(n)		(0x000 + (128 * n))
+#define EIP197_HIA_DSE_THR_STAT(n)		(0x004 + (128 * n))
 
 #define EIP197_HIA_AIC_G_ENABLE_CTRL		0xf808
 #define EIP197_HIA_AIC_G_ENABLED_STAT		0xf810
@@ -283,11 +284,11 @@
 #define EIP197_HIA_MST_CTRL			0xfff4
 #define EIP197_HIA_OPTIONS			0xfff8
 #define EIP197_HIA_VERSION			0xfffc
-#define EIP197_PE_IN_DBUF_THRES			0x0000
-#define EIP197_PE_IN_TBUF_THRES			0x0100
+#define EIP197_PE_IN_DBUF_THRES(n)		(0x0000 + (0x2000 * n))
+#define EIP197_PE_IN_TBUF_THRES(n)		(0x0100 + (0x2000 * n))
+#define EIP197_PE_OUT_DBUF_THRES(n)		(0x1c00 + (0x2000 * n))
 #define EIP197_FUNCTION_EN			0x1004
 #define EIP197_CONTEXT_CTRL			0x11008
-#define EIP197_PE_OUT_DBUF_THRES		0x1c00
 #define EIP197_OPTIONS				0x1fff8
 #define EIP197_IP_VERSION			0x1fffc
 #define EIP197_MST_CTRL				0xfff4
@@ -299,6 +300,9 @@
 #define EIP197_xDR_HDW_OFFSET			25
 #define EIP197_xDR_HDW_MASK			(GENMASK(27, 25))
 #define EIP197_N_RINGS_MASK			(GENMASK(3, 0))
+#define EIP197_N_PES_OFFSET			4
+#define EIP197_N_PES_MASK			(GENMASK(4, 0))
+#define EIP97_N_PES_MASK			(GENMASK(2, 0))
 
 /* EIP197_HIA_AIC_R_ENABLE_CTRL */
 #define EIP197_CDR_IRQ(n)			BIT((n) * 2)
@@ -528,6 +532,11 @@ enum safexcel_eip_type {
 	EIP97,
 };
 
+enum safexcel_eip197_hw {
+	EIP197B,
+	EIP197D,
+};
+
 struct safexcel_ring {
 	void *base;
 	void *base_end;
@@ -601,6 +610,8 @@ struct safexcel_crypto_priv {
 	struct device *dev;
 	struct clk *clk;
 	enum safexcel_eip_type eip_type;
+	int nr_pe;
+	enum safexcel_eip197_hw eip197_hw_ver;
 	struct safexcel_config config;
 
 	/* context DMA pool */
-- 
1.7.9.5


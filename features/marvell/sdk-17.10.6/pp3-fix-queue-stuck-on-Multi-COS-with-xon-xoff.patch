From ab11fc0eb74c8d5ed42d71f4d8302d5c0a65ecdd Mon Sep 17 00:00:00 2001
From: Yan Markman <ymarkman@marvell.com>
Date: Mon, 11 Jul 2016 13:52:47 +0300
Subject: [PATCH 0338/1345] pp3: fix queue stuck on Multi-COS with xon-xoff

commit  4c0b54858506152203d90ee1394c7eb3ca98d076 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

JIRA SYSTEMSW-2513

Suspend/resume (Xoff/Xon) re-configures napi queue mapping
list napi_proc_qs[array_ind].
The new configuration is placed into "unused" array_ind,
then index is swapped to be active in napi_proc_qs[napi_next_array]

Change-Id: I1911ebaa09fa80cd5c2e2be1b1378947000d41e3
Signed-off-by: Yan Markman <ymarkman@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/31040
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dovrat Zifroni <dovrat@marvell.com>
Tested-by: Dovrat Zifroni <dovrat@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../net/ethernet/marvell/pp3/net_dev/mv_dev_vq.c   |   25 +++++++++++++++++---
 1 file changed, 22 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_vq.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_vq.c
index 134cf5b..1a0e300 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_vq.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_vq.c
@@ -822,14 +822,32 @@ static inline int mv_pp3_free_array_ind_get(struct pp3_cpu_port *cpu)
 {
 	int i;
 
-	/* find free queues list for changes */
+	/* find free queues list for changes:
+	 * napi_proc_qs[3][MV_PP3_VQ_NUM] keeps napi/vq mapping
+	 * napi_proc_qs[array_ind=i] is updated upon suspend, resume
+	 *  and then "i" switched to be current-active.
+	 * Before napi suspend/resume delete/add operation
+	 * the napi_proc_qs[i][..vq..] must be sync to the
+	 * latest valid (current) napi_next_array.
+	 * Refer mv_pp3_napi_array_sync()
+	 */
 	for (i = 0; i < 3; i++)
 		if ((i != cpu->napi_master_array) && (i != cpu->napi_next_array))
 			return i;
-
 	return -1;
 }
 
+static inline void mv_pp3_napi_array_sync(struct pp3_cpu_port *cpu,
+						int old, int new, int num)
+{
+	int i;
+
+	if (old == new)
+		return;
+	for (i = 0; i < num; i++)
+		cpu->napi_proc_qs[new][i] = cpu->napi_proc_qs[old][i];
+}
+
 void mv_pp3_dev_napi_queue_update(struct net_device *dev)
 {
 	int cpu;
@@ -858,7 +876,6 @@ void mv_pp3_dev_napi_queue_update(struct net_device *dev)
 		for (i = 0; i < cpu_vp->rx_vqs_num; i++)
 			if (cpu_vp->rx_vqs[i]->valid)
 				cpu_vp->port.cpu.napi_proc_qs[array_ind][i] = cpu_vp->rx_vqs[i]->vq;
-
 		mv_pp3_vq_prio_sort(cpu_vp->rx_vqs, cpu_vp->port.cpu.napi_proc_qs[array_ind], cpu_vp->rx_vqs_num);
 		cpu_vp->port.cpu.napi_next_array = array_ind;
 	}
@@ -876,6 +893,7 @@ static void mv_pp3_dev_vq_napi_disable(struct pp3_vport *cpu_vp, int vq)
 	array_ind = mv_pp3_free_array_ind_get(cpu);
 	if (array_ind < 0)
 		return;
+	mv_pp3_napi_array_sync(cpu, cpu->napi_next_array, array_ind, cpu->napi_q_num);
 
 	/* to disable, remove queue from the list of napi queues */
 	for (i = 0; i < cpu->napi_q_num; i++) {
@@ -902,6 +920,7 @@ static void mv_pp3_dev_vq_napi_enable(struct pp3_vport *cpu_vp, int vq)
 	array_ind = mv_pp3_free_array_ind_get(cpu);
 	if (array_ind < 0)
 		return;
+	mv_pp3_napi_array_sync(cpu, cpu->napi_next_array, array_ind, cpu->napi_q_num);
 
 	/* to enable, add queue to the list of napi queues according to its priority */
 	cpu->napi_proc_qs[array_ind][cpu->napi_q_num] = vq;
-- 
1.7.9.5


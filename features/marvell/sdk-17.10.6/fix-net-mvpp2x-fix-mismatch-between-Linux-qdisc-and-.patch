From adbaa73c30effb4245f0cbbba5bfd8603b3af420 Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Mon, 12 Dec 2016 11:15:35 +0200
Subject: [PATCH 0696/1345] fix: net: mvpp2x: fix mismatch between Linux qdisc
 and aggregated TXQ

commit  130f2d78fd8d86610413dd582bdd1b0544ddd103 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- Increase number of Linux TXQ's to number of HW TXQ multiplied
  by number of online CPU's.
- Mark CPU ID in select queue callback
- Get netdev_queue in TX procedure by checking CPU ID

Change-Id: I1e4118bd38215c8b848b6a595e1dc009231d205f
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/34578
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |   23 +++++++++++++-------
 1 file changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 933b49d..68ab9e4 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -1007,7 +1007,8 @@ static void mv_pp2x_txq_done(struct mv_pp2x_port *port,
 			     struct mv_pp2x_tx_queue *txq,
 				   struct mv_pp2x_txq_pcpu *txq_pcpu)
 {
-	struct netdev_queue *nq = netdev_get_tx_queue(port->dev, txq->log_id);
+	struct netdev_queue *nq = netdev_get_tx_queue(port->dev, (txq->log_id +
+						     (txq_pcpu->cpu * mv_pp2x_txq_number)));
 	int tx_done;
 
 #ifdef DEV_NETMAP
@@ -2693,8 +2694,8 @@ static inline int mv_pp2_tx_tso(struct sk_buff *skb, struct net_device *dev,
 	if (mv_pp2_tso_validate(skb, dev))
 		return 0;
 
-	txq_id = skb_get_queue_mapping(skb);
-	nq = netdev_get_tx_queue(dev, txq_id);
+	txq_id = skb_get_queue_mapping(skb) % mv_pp2x_txq_number;
+	nq = netdev_get_tx_queue(dev, (txq_id + (cpu * mv_pp2x_txq_number)));
 
 	/* Calculate expected number of TX descriptors */
 	max_desc_num = skb_shinfo(skb)->gso_segs * 2 + skb_shinfo(skb)->nr_frags;
@@ -2870,8 +2871,9 @@ static int mv_pp2x_tx(struct sk_buff *skb, struct net_device *dev)
 	u32 tx_cmd;
 	int cpu = smp_processor_id();
 
-	txq_id = skb_get_queue_mapping(skb);
-	nq = netdev_get_tx_queue(dev, txq_id);
+	/* Set relevant physical TxQ and Linux netdev queue */
+	txq_id = skb_get_queue_mapping(skb) % mv_pp2x_txq_number;
+	nq = netdev_get_tx_queue(dev, (txq_id + (cpu * mv_pp2x_txq_number)));
 	txq = port->txqs[txq_id];
 	txq_pcpu = this_cpu_ptr(txq->pcpu);
 	aggr_txq = &port->priv->aggr_txqs[cpu];
@@ -3974,10 +3976,15 @@ u16 mv_pp2x_select_queue(struct net_device *dev, struct sk_buff *skb,
 			 void *accel_priv, select_queue_fallback_t fallback)
 
 {
+	int val;
+
+	/* If packet in coming from Rx -> RxQ = TxQ, callback function used for packets from CPU Tx */
 	if (skb->queue_mapping)
-		return skb->napi_id - 1;
+		val = skb->queue_mapping - 1;
+	else
+		val = fallback(dev, skb);
 
-	return fallback(dev, skb) % mv_pp2x_txq_number;
+	return (val % mv_pp2x_txq_number) + (smp_processor_id() * mv_pp2x_txq_number);
 }
 
 /* Device ops */
@@ -4459,7 +4466,7 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	struct phy *comphy;
 
 	dev = alloc_etherdev_mqs(sizeof(struct mv_pp2x_port),
-				 mv_pp2x_txq_number, mv_pp2x_rxq_number);
+				 mv_pp2x_txq_number * num_active_cpus(), mv_pp2x_rxq_number);
 	if (!dev)
 		return -ENOMEM;
 
-- 
1.7.9.5


From 92864c02e45c6b73a38da3bccfdc06b0e5ccf85b Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Mon, 18 Jul 2016 11:30:40 +0300
Subject: [PATCH 0362/1345] net: mvpp2x: flow control support

commit  7bff28749a184a976b3dda7e4d0195d27ae82dab from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- add flow  control configuration support to ethtool
- 2.5G Peridot ports don't support flow control
- support added for 1G and 10G ports
- TX flow control from FCA IP
- RX flow control from GOP IP
- add periodic timer support

Change-Id: If5eb8ba470bcde8bcf871a28890f32e6c4460ff1
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/31204
Reviewed-by: Yuval Caduri <cyuval@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.c |  161 +++++++++++++++++++-
 drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.h |   35 +++++
 .../ethernet/marvell/mvpp2x/mv_gop110_hw_type.h    |   43 ++++++
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |    1 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c  |  131 ++++++++++++++++
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |   11 ++
 6 files changed, 374 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.c
index f33cf18..9c2504c 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.c
@@ -256,6 +256,7 @@ static void mv_gop110_gmac_sgmii_cfg(struct gop_hw *gop, int mac_num)
 
 	val = mv_gop110_gmac_read(gop, mac_num, MV_GMAC_PORT_CTRL2_REG);
 	val |= MV_GMAC_PORT_CTRL2_DIS_PADING_OFFS;
+	val &= ~MV_GMAC_PORT_CTRL2_FC_MODE_MASK;
 	mv_gop110_gmac_write(gop, mac_num, MV_GMAC_PORT_CTRL2_REG, val);
 
 	val = mv_gop110_gmac_read(gop, mac_num, MV_GMAC_PORT_CTRL0_REG);
@@ -481,6 +482,17 @@ int mv_gop110_gmac_link_status(struct gop_hw *gop, int mac_num,
 	else
 		pstatus->rx_fc = MV_PORT_FC_DISABLE;
 
+	reg_val = mv_gop110_gmac_read(gop, mac_num, MV_GMAC_PORT_AUTO_NEG_CFG_REG);
+
+	if (reg_val & MV_GMAC_PORT_AUTO_NEG_CFG_EN_FC_AN_MASK) {
+		if (reg_val & MV_GMAC_PORT_AUTO_NEG_CFG_ADV_ASM_PAUSE_MASK)
+			pstatus->autoneg_fc = MV_PORT_FC_AN_ASYM;
+		else
+			pstatus->autoneg_fc = MV_PORT_FC_AN_SYM;
+		}
+	else
+		pstatus->autoneg_fc = MV_PORT_FC_AN_NO;
+
 	return 0;
 }
 
@@ -676,6 +688,7 @@ int mv_gop110_gmac_fc_set(struct gop_hw *gop, int mac_num, enum mv_port_fc fc)
 
 	reg_val = mv_gop110_gmac_read(gop, mac_num,
 				      MV_GMAC_PORT_AUTO_NEG_CFG_REG);
+	fc_en = mv_gop110_gmac_read(gop, mac_num, MV_GMAC_PORT_CTRL4_REG);
 
 	switch (fc) {
 	case MV_PORT_FC_AN_NO:
@@ -699,22 +712,32 @@ int mv_gop110_gmac_fc_set(struct gop_hw *gop, int mac_num, enum mv_port_fc fc)
 	case MV_PORT_FC_DISABLE:
 		reg_val &= ~MV_GMAC_PORT_AUTO_NEG_CFG_EN_FC_AN_MASK;
 		reg_val &= ~MV_GMAC_PORT_AUTO_NEG_CFG_ADV_ASM_PAUSE_MASK;
-		fc_en = mv_gop110_gmac_read(gop, mac_num,
-					    MV_GMAC_PORT_CTRL4_REG);
 		fc_en &= ~MV_GMAC_PORT_CTRL4_FC_EN_RX_MASK;
 		fc_en &= ~MV_GMAC_PORT_CTRL4_FC_EN_TX_MASK;
-		mv_gop110_gmac_write(gop, mac_num,
-				     MV_GMAC_PORT_CTRL4_REG, fc_en);
+		break;
+
+	case MV_PORT_FC_TX_DISABLE:
+		fc_en &= ~MV_GMAC_PORT_CTRL4_FC_EN_TX_MASK;
+		break;
+
+	case MV_PORT_FC_RX_DISABLE:
+		fc_en &= ~MV_GMAC_PORT_CTRL4_FC_EN_RX_MASK;
 		break;
 
 	case MV_PORT_FC_ENABLE:
 		reg_val &= ~MV_GMAC_PORT_AUTO_NEG_CFG_EN_FC_AN_MASK;
-		fc_en = mv_gop110_gmac_read(gop, mac_num,
-					    MV_GMAC_PORT_CTRL4_REG);
 		fc_en |= MV_GMAC_PORT_CTRL4_FC_EN_RX_MASK;
 		fc_en |= MV_GMAC_PORT_CTRL4_FC_EN_TX_MASK;
-		mv_gop110_gmac_write(gop, mac_num,
-				     MV_GMAC_PORT_CTRL4_REG, fc_en);
+		break;
+
+	case MV_PORT_FC_TX_ENABLE:
+		reg_val &= ~MV_GMAC_PORT_AUTO_NEG_CFG_EN_FC_AN_MASK;
+		fc_en |= MV_GMAC_PORT_CTRL4_FC_EN_TX_MASK;
+		break;
+
+	case MV_PORT_FC_RX_ENABLE:
+		reg_val &= ~MV_GMAC_PORT_AUTO_NEG_CFG_EN_FC_AN_MASK;
+		fc_en |= MV_GMAC_PORT_CTRL4_FC_EN_RX_MASK;
 		break;
 
 	default:
@@ -723,6 +746,8 @@ int mv_gop110_gmac_fc_set(struct gop_hw *gop, int mac_num, enum mv_port_fc fc)
 	}
 
 	mv_gop110_gmac_write(gop, mac_num,
+			     MV_GMAC_PORT_CTRL4_REG, fc_en);
+	mv_gop110_gmac_write(gop, mac_num,
 			     MV_GMAC_PORT_AUTO_NEG_CFG_REG, reg_val);
 	return 0;
 }
@@ -2102,6 +2127,22 @@ int mv_gop110_xlg_mac_fc_set(struct gop_hw *gop, int mac_num,
 		reg_val |= MV_XLG_MAC_CTRL0_TXFCEN_MASK;
 		break;
 
+	case MV_PORT_FC_TX_DISABLE:
+		reg_val &= ~MV_XLG_MAC_CTRL0_TXFCEN_MASK;
+		break;
+
+	case MV_PORT_FC_RX_DISABLE:
+		reg_val &= ~MV_XLG_MAC_CTRL0_RXFCEN_MASK;
+		break;
+
+	case MV_PORT_FC_TX_ENABLE:
+		reg_val |= MV_XLG_MAC_CTRL0_TXFCEN_MASK;
+		break;
+
+	case MV_PORT_FC_RX_ENABLE:
+		reg_val |= MV_XLG_MAC_CTRL0_RXFCEN_MASK;
+		break;
+
 	case MV_PORT_FC_AN_NO:
 	case MV_PORT_FC_AN_SYM:
 	case MV_PORT_FC_AN_ASYM:
@@ -2749,6 +2790,109 @@ int mv_gop110_netc_init(struct gop_hw *gop,
 	return 0;
 }
 
+void mv_gop110_netc_xon_set(struct gop_hw *gop, enum mv_gop_port port, bool en)
+{
+
+	u32 reg;
+
+	reg = mv_gop110_rfu1_read(gop, MV_NETCOMP_PORTS_CONTROL_0);
+
+	switch (port) {
+	case MV_GOP_PORT0:
+		U32_SET_FIELD(reg, NETC_PORT0_PAUSE_MASK,
+			      en << NETC_PORT0_PAUSE_OFFSET);
+		break;
+	case MV_GOP_PORT1:
+		pr_err("%s: Wrong gop port (%d)\n", __func__, port);
+		break;
+	case MV_GOP_PORT2:
+		U32_SET_FIELD(reg, NETC_PORT2_PAUSE_MASK,
+			      en << NETC_PORT2_PAUSE_OFFSET);
+		break;
+	case MV_GOP_PORT3:
+		U32_SET_FIELD(reg, NETC_PORT3_PAUSE_MASK,
+			      en << NETC_PORT3_PAUSE_OFFSET);
+		break;
+	}
+
+	mv_gop110_rfu1_write(gop, MV_NETCOMP_PORTS_CONTROL_0, reg);
+
+}
+EXPORT_SYMBOL(mv_gop110_netc_xon_set);
+
+void mv_gop110_fca_send_periodic(struct gop_hw *gop, int mac_num, bool en)
+{
+	int val;
+
+	val = mv_gop110_fca_read(gop, mac_num, FCA_CONTROL_REG);
+
+	U32_SET_FIELD(val, FCA_PORT_TYPE_MASK,
+			      FCA_PORT_TYPE_B << FCA_PORT_TYPE_OFFSET);
+	U32_SET_FIELD(val, FCA_SEND_PERIODIC_MASK,
+			      en << FCA_SEND_PERIODIC_OFFSET);
+	mv_gop110_fca_write(gop, mac_num, FCA_CONTROL_REG, val);
+}
+
+void mv_gop110_fca_enable_periodic(struct gop_hw *gop, int mac_num, bool en)
+{
+	int val;
+
+	val = mv_gop110_fca_read(gop, mac_num, FCA_CONTROL_REG);
+
+	U32_SET_FIELD(val, FCA_ENABLE_PERIODIC_MASK,
+			      en << FCA_ENABLE_PERIODIC_OFFSET);
+	mv_gop110_fca_write(gop, mac_num, FCA_CONTROL_REG, val);
+}
+
+void mv_gop110_fca_set_timer(struct gop_hw *gop, int mac_num, u32 lsb, u32 msb)
+{
+	mv_gop110_fca_write(gop, mac_num, PERIODIC_COUNTER_LSB_REG, lsb);
+	mv_gop110_fca_write(gop, mac_num, PERIODIC_COUNTER_MSB_REG, msb);
+}
+
+void mv_gop110_fca_set_periodic_timer(struct gop_hw *gop, int mac_num, u64 timer)
+{
+	u32 lsb, msb;
+
+	mv_gop110_fca_send_periodic(gop, mac_num, false);
+	mv_gop110_fca_enable_periodic(gop, mac_num, false);
+
+	lsb = lower_32_bits(timer);
+	msb = upper_32_bits(timer);
+
+	mv_gop110_fca_set_timer(gop, mac_num, lsb, msb);
+
+	mv_gop110_fca_send_periodic(gop, mac_num, true);
+	mv_gop110_fca_enable_periodic(gop, mac_num, true);
+}
+EXPORT_SYMBOL(mv_gop110_fca_set_periodic_timer);
+
+void mv_gop110_fca_tx_enable(struct gop_hw *gop, int mac_num, bool en)
+{
+	int val;
+
+	val = mv_gop110_fca_read(gop, mac_num, FCA_CONTROL_REG);
+
+	U32_SET_FIELD(val, FCA_PORT_TYPE_MASK,
+			      FCA_PORT_TYPE_B << FCA_PORT_TYPE_OFFSET);
+	U32_SET_FIELD(val, FCA_BYPASS_MASK,
+			      en << FCA_BYPASS_OFFSET);
+	mv_gop110_fca_write(gop, mac_num, FCA_CONTROL_REG, val);
+}
+
+
+bool mv_gop110_check_fca_tx_state(struct gop_hw *gop, int mac_num)
+{
+	int val;
+
+	val = mv_gop110_fca_read(gop, mac_num, FCA_CONTROL_REG);
+
+	if (val & FCA_BYPASS_MASK)
+		return false;
+
+	return true;
+}
+
 /* Register dump for ethtool */
 void mv_gop110_gmac_registers_dump(struct mv_pp2x_port *port, u32 *regs_buff)
 {
@@ -2956,3 +3100,4 @@ void mv_gop110_xlg_registers_dump(struct mv_pp2x_port *port, u32 *regs_buff)
 						    port->mac_data.gop_index,
 						    MV_XLG_MAC_DIC_PPM_IPG_REDUCE_REG);
 }
+
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.h b/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.h
index 1b0be73..17cda1b 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw.h
@@ -45,7 +45,11 @@ enum mv_port_fc {
 	MV_PORT_FC_AN_SYM,
 	MV_PORT_FC_AN_ASYM,
 	MV_PORT_FC_DISABLE,
+	MV_PORT_FC_TX_DISABLE,
+	MV_PORT_FC_RX_DISABLE,
 	MV_PORT_FC_ENABLE,
+	MV_PORT_FC_TX_ENABLE,
+	MV_PORT_FC_RX_ENABLE,
 	MV_PORT_FC_ACTIVE
 };
 
@@ -55,6 +59,7 @@ struct mv_port_link_status {
 	enum mv_port_duplex	duplex;
 	enum mv_port_fc		rx_fc;
 	enum mv_port_fc		tx_fc;
+	enum mv_port_fc		autoneg_fc;
 };
 
 /* different loopback types can be configure on different levels:
@@ -99,6 +104,13 @@ enum mv_netc_lanes {
 	MV_NETC_LANE_45,
 };
 
+enum mv_gop_port {
+	MV_GOP_PORT0 = 0,
+	MV_GOP_PORT1 = 1,
+	MV_GOP_PORT2 = 2,
+	MV_GOP_PORT3 = 3,
+};
+
 #define MV_RGMII_TX_FIFO_MIN_TH		(0x41)
 #define MV_SGMII_TX_FIFO_MIN_TH		(0x5)
 #define MV_SGMII2_5_TX_FIFO_MIN_TH	(0xB)
@@ -453,6 +465,29 @@ static inline void mv_gop110_rfu1_print(struct gop_hw *gop, char *reg_name,
 int mv_gop110_netc_init(struct gop_hw *gop,
 			u32 net_comp_config, enum mv_netc_phase phase);
 void mv_gop110_netc_active_port(struct gop_hw *gop, u32 port, u32 val);
+void mv_gop110_netc_xon_set(struct gop_hw *gop, enum mv_gop_port port, bool en);
+
+/* FCA Functions  */
+void mv_gop110_fca_send_periodic(struct gop_hw *gop, int mac_num, bool en);
+void mv_gop110_fca_set_periodic_timer(struct gop_hw *gop, int mac_num, u64 timer);
+
+void mv_gop110_fca_tx_enable(struct gop_hw *gop, int mac_num, bool en);
+
+bool mv_gop110_check_fca_tx_state(struct gop_hw *gop, int mac_num);
+
+static inline u32 mv_gop110_fca_read(struct gop_hw *gop, int mac_num,
+				     u32 offset)
+{
+	return mv_gop_gen_read(gop->gop_110.fca.base,
+			       mac_num * gop->gop_110.fca.obj_size + offset);
+}
+
+static inline void mv_gop110_fca_write(struct gop_hw *gop, int mac_num,
+				       u32 offset, u32 data)
+{
+	mv_gop_gen_write(gop->gop_110.fca.base,
+			 mac_num * gop->gop_110.fca.obj_size + offset, data);
+}
 
 /*Ethtool Functions */
 void mv_gop110_gmac_registers_dump(struct mv_pp2x_port *port, u32 *regs_buff);
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw_type.h
index 0ba4578..b962b9b 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_gop110_hw_type.h
@@ -1864,6 +1864,18 @@
 #define NETC_GIG_RX_DATA_SAMPLE_OFFSET		29
 #define NETC_GIG_RX_DATA_SAMPLE_MASK	(0x1 << NETC_GIG_RX_DATA_SAMPLE_OFFSET)
 
+#define NETC_PORT3_PAUSE_OFFSET		6
+#define NETC_PORT3_PAUSE_MASK	(0x1 << NETC_PORT3_PAUSE_OFFSET)
+
+#define NETC_PORT2_PAUSE_OFFSET		5
+#define NETC_PORT2_PAUSE_MASK	(0x1 << NETC_PORT2_PAUSE_OFFSET)
+
+#define NETC_PORT1_PAUSE_OFFSET		4
+#define NETC_PORT1_PAUSE_MASK	(0x1 << NETC_PORT1_PAUSE_OFFSET)
+
+#define NETC_PORT0_PAUSE_OFFSET		3
+#define NETC_PORT0_PAUSE_MASK	(0x1 << NETC_PORT0_PAUSE_OFFSET)
+
 #define NETC_BUS_WIDTH_SELECT_OFFSET		1
 #define NETC_BUS_WIDTH_SELECT_MASK	(0x1 << NETC_BUS_WIDTH_SELECT_OFFSET)
 
@@ -1964,4 +1976,35 @@
 #define TX_SD_CLK_RESET_OFFSET					0
 #define TX_SD_CLK_RESET_MASK	(0x1 << TX_SD_CLK_RESET_OFFSET)
 
+/***********/
+/*FCA REGS */
+/***********/
+
+/* FCA control */
+#define FCA_CONTROL_REG				(0x000)
+#define FCA_RESET_OFFSET					0
+#define FCA_RESET_MASK	(0x1 << FCA_RESET_OFFSET)
+
+#define FCA_BYPASS_OFFSET					1
+#define FCA_BYPASS_MASK	(0x1 << FCA_BYPASS_OFFSET)
+
+#define FCA_PORT_TYPE_OFFSET					4
+#define FCA_PORT_TYPE_MASK	(0x111 << FCA_PORT_TYPE_OFFSET)
+
+#define FCA_SEND_PERIODIC_OFFSET				7
+#define FCA_SEND_PERIODIC_MASK	(0x1 << FCA_SEND_PERIODIC_OFFSET)
+
+#define FCA_ENABLE_PERIODIC_OFFSET				11
+#define FCA_ENABLE_PERIODIC_MASK	(0x1 << FCA_ENABLE_PERIODIC_OFFSET)
+
+/* FCA periodic timer */
+#define PERIODIC_COUNTER_LSB_REG		(0x110)
+#define PERIODIC_COUNTER_MSB_REG		(0x114)
+
+#define FCA_PORT_TYPE_A		0x0
+#define FCA_PORT_TYPE_B		0x1
+#define FCA_PORT_TYPE_C		0x2
+#define FCA_PORT_TYPE_D		0x3
+#define FCA_PORT_TYPE_E		0x4
+
 #endif /*_MV_GOP_HW_TYPE_H_*/
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index f9d9119..815976f 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -374,6 +374,7 @@ struct cpn110_gop_hw {
 	struct mv_mac_unit_desc xmib;
 	struct mv_mac_unit_desc tai;
 	struct mv_mac_unit_desc ptp;
+	struct mv_mac_unit_desc fca;
 	void __iomem *smi_base;
 	void __iomem *xsmi_base;
 	void __iomem *mspg_base;
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
index ff884ce..cb902a1 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
@@ -228,6 +228,135 @@ int mv_pp2x_eth_tool_nway_reset(struct net_device *dev)
 	return 0;
 }
 
+/* Get pause fc settings for ethtools */
+static void mv_pp2x_get_pauseparam(struct net_device *dev,
+					struct ethtool_pauseparam *pause)
+{
+	struct mv_pp2x_port *port = netdev_priv(dev);
+	struct mv_port_link_status status;
+	struct mv_mac_data *mac = &port->mac_data;
+	struct gop_hw *gop = &port->priv->hw.gop;
+	int gop_port = mac->gop_index;
+	phy_interface_t phy_mode;
+
+	phy_mode = port->mac_data.phy_mode;
+
+	switch (phy_mode) {
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_QSGMII:
+		mv_gop110_port_link_status(gop,	mac, &status);
+		pause->autoneg =
+			(status.autoneg_fc ? AUTONEG_ENABLE : AUTONEG_DISABLE);
+	break;
+	case PHY_INTERFACE_MODE_XAUI:
+	case PHY_INTERFACE_MODE_RXAUI:
+	case PHY_INTERFACE_MODE_KR:
+		mv_gop110_port_link_status(gop,	mac, &status);
+		pause->autoneg = AUTONEG_DISABLE;
+	break;
+	default:
+		pr_err("%s: Wrong port mode (%d)", __func__, phy_mode);
+		return;
+	}
+
+	if (status.rx_fc == MV_PORT_FC_ACTIVE || status.rx_fc == MV_PORT_FC_ENABLE)
+		pause->rx_pause = 1;
+
+	if (mv_gop110_check_fca_tx_state(gop, gop_port)) {
+		pause->tx_pause = 1;
+		return;
+	}
+
+	if (status.tx_fc == MV_PORT_FC_ACTIVE || status.tx_fc == MV_PORT_FC_ENABLE)
+		pause->tx_pause = 1;
+}
+
+/* Set pause fc settings for ethtools */
+static int mv_pp2x_set_pauseparam(struct net_device *dev,
+					struct ethtool_pauseparam *pause)
+{
+	struct mv_pp2x_port *port = netdev_priv(dev);
+	struct mv_mac_data *mac = &port->mac_data;
+	struct gop_hw *gop = &port->priv->hw.gop;
+	int gop_port = mac->gop_index;
+	phy_interface_t phy_mode;
+	int err;
+
+	if (!(mac->flags & MV_EMAC_F_INIT)) {
+		pr_err("%s: interface %s is not initialized\n", __func__, dev->name);
+		return -EOPNOTSUPP;
+	}
+
+	phy_mode = port->mac_data.phy_mode;
+
+	switch (phy_mode) {
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_QSGMII:
+		if (mac->speed == SPEED_2500) {
+			err = mv_gop110_check_port_type(gop, gop_port);
+			if (err) {
+				pr_err("Peridot module doesn't support FC\n");
+				return -EINVAL;
+			}
+		}
+
+		mv_gop110_force_link_mode_set(gop, mac, false, true);
+
+		if (pause->autoneg) {
+			mv_gop110_gmac_fc_set(gop, gop_port, MV_PORT_FC_AN_SYM);
+			mv_gop110_autoneg_restart(gop, mac);
+			mv_gop110_fca_send_periodic(gop, gop_port, false);
+			}
+		else	{
+			mv_gop110_gmac_fc_set(gop, gop_port, MV_PORT_FC_AN_NO);
+			mv_gop110_fca_send_periodic(gop, gop_port, true);
+			}
+
+		if (pause->rx_pause)
+			mv_gop110_gmac_fc_set(gop, gop_port, MV_PORT_FC_RX_ENABLE);
+		else
+			mv_gop110_gmac_fc_set(gop, gop_port, MV_PORT_FC_RX_DISABLE);
+
+		if (pause->tx_pause) {
+			mv_gop110_gmac_fc_set(gop, gop_port, MV_PORT_FC_TX_ENABLE);
+			mv_gop110_fca_tx_enable(gop, gop_port, false);
+			}
+		else	{
+			mv_gop110_gmac_fc_set(gop, gop_port, MV_PORT_FC_TX_DISABLE);
+			mv_gop110_fca_tx_enable(gop, gop_port, true);
+			}
+
+		mv_gop110_force_link_mode_set(gop, mac, false, false);
+	break;
+	case PHY_INTERFACE_MODE_XAUI:
+	case PHY_INTERFACE_MODE_RXAUI:
+	case PHY_INTERFACE_MODE_KR:
+		if (pause->autoneg) {
+			pr_err("10G port doesn't support fc autoneg\n");
+			return -EINVAL;
+			}
+		if (pause->rx_pause)
+			mv_gop110_xlg_mac_fc_set(gop, gop_port, MV_PORT_FC_RX_ENABLE);
+		else
+			mv_gop110_xlg_mac_fc_set(gop, gop_port, MV_PORT_FC_RX_DISABLE);
+
+		if (pause->tx_pause)
+			mv_gop110_fca_tx_enable(gop, gop_port, false);
+		else	{
+			mv_gop110_xlg_mac_fc_set(gop, gop_port, MV_PORT_FC_TX_DISABLE);
+			mv_gop110_fca_tx_enable(gop, gop_port, true);
+			}
+	break;
+	default:
+		pr_err("%s: Wrong port mode (%d)", __func__, phy_mode);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 /* Get settings (phy address, speed) for ethtools */
 static int mv_pp2x_ethtool_get_settings(struct net_device *dev,
 					struct ethtool_cmd *cmd)
@@ -753,6 +882,8 @@ static void mv_pp2x_eth_tool_diag_test(struct net_device *netdev,
 	.get_strings		= mv_pp2x_eth_tool_get_strings,
 	.get_ringparam		= mv_pp2x_ethtool_get_ringparam,
 	.set_ringparam		= mv_pp2x_ethtool_set_ringparam,
+	.get_pauseparam		= mv_pp2x_get_pauseparam,
+	.set_pauseparam		= mv_pp2x_set_pauseparam,
 	.get_rxfh_indir_size	= mv_pp2x_ethtool_get_rxfh_indir_size,
 	.get_rxnfc		= mv_pp2x_ethtool_get_rxnfc,
 	.get_rxfh		= mv_pp2x_ethtool_get_rxfh,
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index b1c0684..cba3247 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -4279,6 +4279,17 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 		hw->gop.gop_110.gmac.obj_size = 0x1000;
 
 
+		/* FCA - flow control*/
+		res = platform_get_resource_byname(pdev,
+			IORESOURCE_MEM, "fca");
+		if ((res->start <= mspg_base) || (res->end >= mspg_end))
+			return -ENXIO;
+		hw->gop.gop_110.fca.base =
+			(void *)(hw->gop.gop_110.mspg_base +
+			(res->start-mspg_base));
+		hw->gop.gop_110.fca.obj_size = 0x1000;
+
+
 		/* MSPG - xlg */
 		res = platform_get_resource_byname(pdev,
 			IORESOURCE_MEM, "xlg");
-- 
1.7.9.5


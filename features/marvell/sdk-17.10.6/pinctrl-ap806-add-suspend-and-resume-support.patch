From 094abd00749d5e25ee4b56634c7e22fa1300d15b Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Fri, 4 Aug 2017 10:31:14 +0800
Subject: [PATCH 1213/1345] pinctrl: ap806: add suspend and resume support

commit  22d0aaccc3eca54c821c21e573f9841d2470a552 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Before suspend, value of all MPP registers are save in DRAM
and when resume, the MPP registers are recovered with
values from DRAM.

eMMC PHY IO Control 0 Register is configured in MPP
driver, so this register is also saved and recovered in
MPP PM routines if it is specified in device tree.

Change-Id: Ia9dce925f5cb0afd5a297ab2fb7b530574d6be6e
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42569
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pinctrl/mvebu/pinctrl-armada-ap806.c |  110 ++++++++++++++++++++++++--
 drivers/pinctrl/mvebu/pinctrl-mvebu.h        |    4 +-
 2 files changed, 105 insertions(+), 9 deletions(-)

diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
index d4a15f6..24782cb 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
@@ -21,6 +21,7 @@
 #include <linux/of_device.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/of_address.h>
+#include <linux/syscore_ops.h>
 
 #include "pinctrl-mvebu.h"
 
@@ -29,12 +30,15 @@
 static void __iomem *mpp_base;
 static void __iomem *emmc_phy_ctrl_reg;
 
-static int armada_ap806_mpp_ctrl_get(unsigned pid, unsigned long *config)
+/* Global list of devices (struct mvebu_pinctrl_soc_info) */
+static LIST_HEAD(drvdata_list);
+
+static int armada_ap806_mpp_ctrl_get(struct mvebu_mpp_ctrl_data *data, unsigned pid, unsigned long *config)
 {
 	return default_mpp_ctrl_get(mpp_base, pid, config);
 }
 
-static int armada_ap806_mpp_ctrl_set(unsigned pid, unsigned long config)
+static int armada_ap806_mpp_ctrl_set(struct mvebu_mpp_ctrl_data *data, unsigned pid, unsigned long config)
 {
 	/* To enable SDIO/eMMC in Armada-APN806, need to configure PHY mux.
 	 * eMMC/SD PHY register responsible for muxing between MPPs and SD/eMMC
@@ -149,7 +153,8 @@ static int armada_ap806_pinctrl_probe(struct platform_device *pdev)
 	struct mvebu_pinctrl_soc_info *soc = &armada_ap806_pinctrl_info;
 	const struct of_device_id *match =
 		of_match_device(armada_ap806_pinctrl_of_match, &pdev->dev);
-	struct resource *res;
+	struct resource *res, *res_mmcio;
+	struct mvebu_pinctrl_pm_save *pm_save;
 
 	if (!match)
 		return -ENODEV;
@@ -162,9 +167,10 @@ static int armada_ap806_pinctrl_probe(struct platform_device *pdev)
 	/* Get the eMMC PHY IO Control 0 Register base
 	 * Usage of this reg will be required in case MMC is enabled.
 	 */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mmcio");
-	if (res) {
-		emmc_phy_ctrl_reg = devm_ioremap_resource(&pdev->dev, res);
+	res_mmcio = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mmcio");
+	if (res_mmcio) {
+		emmc_phy_ctrl_reg = devm_ioremap_resource(&pdev->dev,
+							  res_mmcio);
 		if (IS_ERR(emmc_phy_ctrl_reg))
 			return PTR_ERR(emmc_phy_ctrl_reg);
 	} else {
@@ -179,16 +185,86 @@ static int armada_ap806_pinctrl_probe(struct platform_device *pdev)
 	soc->modes = armada_ap806_mpp_modes;
 	soc->nmodes = armada_ap806_mpp_controls[0].npins;
 
+#ifdef CONFIG_PM
+	pm_save = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_pinctrl_pm_save),
+			       GFP_KERNEL);
+	if (!pm_save)
+		return -ENOMEM;
+
+	/* Allocate memory to save the register value before suspend.
+	 * Registers to save includes MPP control registers and eMMC PHY
+	 * IO Control register if eMMC is enabled.
+	 */
+	pm_save->length = resource_size(res);
+	pm_save->regs = (unsigned int *)devm_kzalloc(&pdev->dev,
+						     pm_save->length,
+						     GFP_KERNEL);
+	if (!pm_save->regs)
+		return -ENOMEM;
+
+	soc->pm_save = pm_save;
+#endif /* CONFIG_PM */
+
 	pdev->dev.platform_data = soc;
 
+	/* Add to the global list so we can implement S2R later */
+	list_add_tail(&soc->node, &drvdata_list);
+
 	return mvebu_pinctrl_probe(pdev);
 }
 
 static int armada_ap806_pinctrl_remove(struct platform_device *pdev)
 {
-	return mvebu_pinctrl_remove(pdev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/* armada_ap806_pinctrl_suspend - save registers for suspend */
+static int armada_ap806_pinctrl_suspend(void)
+{
+	struct mvebu_pinctrl_soc_info *soc;
+
+	list_for_each_entry(soc, &drvdata_list, node) {
+		unsigned int offset, i = 0;
+
+		for (offset = 0; offset < soc->pm_save->length;
+		     offset += sizeof(unsigned int))
+			soc->pm_save->regs[i++] = readl(mpp_base + offset);
+
+		if (emmc_phy_ctrl_reg)
+			soc->pm_save->emmc_phy_ctrl = readl(emmc_phy_ctrl_reg);
+	}
+
+	return 0;
 }
 
+/* armada_ap806_pinctrl_resume - restore pinctrl register for suspend */
+static void armada_ap806_pinctrl_resume(void)
+{
+	struct mvebu_pinctrl_soc_info *soc;
+
+	list_for_each_entry_reverse(soc, &drvdata_list, node) {
+		unsigned int offset, i = 0;
+
+		for (offset = 0; offset < soc->pm_save->length;
+		     offset += sizeof(unsigned int))
+			writel(soc->pm_save->regs[i++], mpp_base + offset);
+
+		if (emmc_phy_ctrl_reg)
+			writel(soc->pm_save->emmc_phy_ctrl, emmc_phy_ctrl_reg);
+	}
+}
+
+#else
+#define armada_ap806_pinctrl_suspend		NULL
+#define armada_ap806_pinctrl_resume		NULL
+#endif /* CONFIG_PM */
+
+static struct syscore_ops armada_ap806_pinctrl_syscore_ops = {
+	.suspend	= armada_ap806_pinctrl_suspend,
+	.resume		= armada_ap806_pinctrl_resume,
+};
+
 static struct platform_driver armada_ap806_pinctrl_driver = {
 	.driver = {
 		.name = "armada-ap806-pinctrl",
@@ -198,7 +274,25 @@ static int armada_ap806_pinctrl_remove(struct platform_device *pdev)
 	.remove = armada_ap806_pinctrl_remove,
 };
 
-module_platform_driver(armada_ap806_pinctrl_driver);
+static int __init armada_ap806_pinctrl_drv_register(void)
+{
+	/*
+	 * Register syscore ops for save/restore of registers across suspend.
+	 * It's important to ensure that this driver is running at an earlier
+	 * initcall level than any arch-specific init calls that install syscore
+	 * ops that turn off pad retention.
+	 */
+	register_syscore_ops(&armada_ap806_pinctrl_syscore_ops);
+
+	return platform_driver_register(&armada_ap806_pinctrl_driver);
+}
+postcore_initcall(armada_ap806_pinctrl_drv_register);
+
+static void __exit armada_ap806_pinctrl_drv_unregister(void)
+{
+	platform_driver_unregister(&armada_ap806_pinctrl_driver);
+}
+module_exit(armada_ap806_pinctrl_drv_unregister);
 
 MODULE_AUTHOR("Thomas Petazzoni <thomas.petazzoni@free-electrons.com>");
 MODULE_DESCRIPTION("Marvell Armada ap806 pinctrl driver");
diff --git a/drivers/pinctrl/mvebu/pinctrl-mvebu.h b/drivers/pinctrl/mvebu/pinctrl-mvebu.h
index e91f558..40565fe 100644
--- a/drivers/pinctrl/mvebu/pinctrl-mvebu.h
+++ b/drivers/pinctrl/mvebu/pinctrl-mvebu.h
@@ -141,11 +141,13 @@ struct mvebu_pinctrl_soc_info {
 /**
  * struct mvebu_pinctrl_pm_save - pinctrl register save when PM
  * @regs: to save register value when suspend
- * @settings: inidcates register space length to save
+ * @length: inidcates register space length to save
+ * @emmc_phy_ctrl: used to save eMMC PHY IO Control register if eMMC is valid
  */
 struct mvebu_pinctrl_pm_save {
 	unsigned int *regs;
 	unsigned int length;
+	unsigned int emmc_phy_ctrl;
 };
 
 #define MPP_FUNC_CTRL(_idl, _idh, _name, _func)			\
-- 
1.7.9.5


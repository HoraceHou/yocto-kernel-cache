From 547b83886533b064769ae4019af9a8d410ba1472 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 28 Jun 2017 12:51:43 +0800
Subject: [PATCH 1207/1345] phy: utmi: cp110: add support of CP110 UTMI PHY

commit  6f0f4b1511b70fd2327694556b960232de4911ac from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Change-Id: I5700bf5a8e06ebb57f40ef605358c077103688c6
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/40911
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/phy/phy-mvebu.txt          |   61 +++-
 drivers/phy/Kconfig                                |    4 +-
 drivers/phy/phy-utmi-mvebu.c                       |  359 +++++++++++++++++++-
 3 files changed, 409 insertions(+), 15 deletions(-)

diff --git a/Documentation/devicetree/bindings/phy/phy-mvebu.txt b/Documentation/devicetree/bindings/phy/phy-mvebu.txt
index 42be7dc6..9885dd3 100644
--- a/Documentation/devicetree/bindings/phy/phy-mvebu.txt
+++ b/Documentation/devicetree/bindings/phy/phy-mvebu.txt
@@ -42,19 +42,27 @@ Example:
 			#phy-cells = <1>
 		};
 
-Armada 3700 UTMI PHY
+Armada 3700 and CP110 UTMI PHY
 ----------------------
-Armada 3700 comes with two UTMI PHYs for USB2.
+Armada 3700 and CP110 comes with two UTMI PHYs for USB2.
 
 Required Properties:
 
-- compatible: "marvell,armada-3700-utmi-phy"
-- reg: Offset and length of the register set for the UTMI PHY
-- utmi-port: The port utmi phy connected to
+- compatible: For Armada-3700 it is "marvell,armada-3700-utmi-phy",
+              and for CP110 it is "marvell,cp110-utmi-phy".
+- reg: register ranges as listed in the reg-names property
+- reg-names: include the following entries:
+             "utmi": utmi registers, which is mandatory and must be first one.
+             "utmi-cfg-reg": UTMI config Register, which is needed on CP110.
+             "usb-cfg-reg": USB config Register, which is needed on CP110, and
+             UTMI0 and UTMI1 share the same USB config register.
+- utmi-port: The USB port utmi phy connected to
 - #phy-cells: Standard property (Documentation: phy-bindings.txt) Should be 0.
+- utmi-index: The index to differentiate the PHY if there are 2 same UTMI PHY,
+              and currently it is used by CP110 for UTMI mux config.
 
 Example:
-UTMI PHY Node:
+Armada-3700 UTMI PHY Node:
 ============
 		utmi_usb32: utmi@5d000 {
 			compatible = "marvell,armada-3700-utmi-phy";
@@ -72,7 +80,33 @@ UTMI PHY Node:
 			status = "okay";
 		};
 
-UTMI PHY consumer:
+CP110 UTMI PHY Node:
+============
+		utmi0: utmi@580000 {
+			compatible = "marvell,cp110-utmi-phy";
+			reg = <0x580000 0x1000>,
+			      <0x440420 0x4>,
+			      <0x440440 0x4>;
+			reg-names = "utmi", "usb-cfg-reg", "utmi-cfg-reg";
+			utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
+			utmi-index = <0>;
+			#phy-cells = <0>;
+			status = "okay";
+		};
+
+		utmi1: utmi@581000 {
+			compatible = "marvell,cp110-utmi-phy";
+			reg = <0x581000 0x1000>,
+			      <0x440420 0x4>
+			      <0x440444 0x4>;
+			reg-names = "utmi", "usb-cfg-reg", "utmi-cfg-reg";
+			utmi-port = <UTMI_PHY_TO_USB3_HOST1>;
+			utmi-index = <1>;
+			#phy-cells = <0>;
+			status = "okay";
+		};
+
+Armada-3700 UTMI PHY consumer:
 =============
 		usb@5e000 {
 			status = "okay";
@@ -85,3 +119,16 @@ UTMI PHY consumer:
 			phys = <&utmi_usb32>;
 			phy-names = "usb";
 		};
+
+CP110 UTMI PHY consumer:
+=============
+		usb3h0: usb3@500000 {
+			status = "okay";
+			phys = <&utmi0>;
+			phy-names = "usb";
+		};
+		usb3h1: usb3@510000 {
+			status = "okay";
+			phys = <&utmi1>;
+			phy-names = "usb";
+		};
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index cff8cd6..9062917 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -158,8 +158,8 @@ config PHY_MVEBU_UTMI
 	select GENERIC_PHY
 	help
 	  Enable this to support Marvell utmi phy driver. The utmi driver
-	  supports Armada-3700. This driver is responsible for configuring
-	  PHY accordingly.
+	  supports Armada-3700 and CP110. This driver is responsible for
+	  configuring PHY accordingly.
 
 config PHY_MIPHY28LP
 	tristate "STMicroelectronics MIPHY28LP PHY driver for STiH407"
diff --git a/drivers/phy/phy-utmi-mvebu.c b/drivers/phy/phy-utmi-mvebu.c
index cc40873..8ce9d1f5 100644
--- a/drivers/phy/phy-utmi-mvebu.c
+++ b/drivers/phy/phy-utmi-mvebu.c
@@ -15,10 +15,9 @@
 #include <linux/of_device.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
+#include <linux/of_address.h>
 #include <dt-bindings/phy/phy-utmi-mvebu.h>
 
-#define PLL_LOCK_TIMEOUT		1000
-
 /* SoC Armada 37xx UTMI register macro definetions */
 #define USB2_PHY_PLL_CTRL_REG0		(0x0)
 #define PLL_REF_DIV_OFF			(0)
@@ -61,13 +60,102 @@
 						USB2_OTGPHY2_SUSPM)
 #define RB_USB2PHY_PU(usb32) (usb32 == 0 ? USB2_PHY2_PU : USB2_OTGPHY2_PU)
 
+/* CP110 UTMI register macro definetions */
+#define UTMI_USB_CFG_DEVICE_EN_OFFSET		0
+#define UTMI_USB_CFG_DEVICE_EN_MASK		\
+	(0x1 << UTMI_USB_CFG_DEVICE_EN_OFFSET)
+#define UTMI_USB_CFG_DEVICE_MUX_OFFSET		1
+#define UTMI_USB_CFG_DEVICE_MUX_MASK		\
+	(0x1 << UTMI_USB_CFG_DEVICE_MUX_OFFSET)
+#define UTMI_USB_CFG_PLL_OFFSET			25
+#define UTMI_USB_CFG_PLL_MASK			\
+	(0x1 << UTMI_USB_CFG_PLL_OFFSET)
+#define UTMI_PHY_CFG_PU_OFFSET			5
+#define UTMI_PHY_CFG_PU_MASK			\
+	(0x1 << UTMI_PHY_CFG_PU_OFFSET)
+#define UTMI_PLL_CTRL_REG			0x0
+#define UTMI_PLL_CTRL_REFDIV_OFFSET		0
+#define UTMI_PLL_CTRL_REFDIV_MASK		\
+	(0x7f << UTMI_PLL_CTRL_REFDIV_OFFSET)
+#define UTMI_PLL_CTRL_FBDIV_OFFSET		16
+#define UTMI_PLL_CTRL_FBDIV_MASK		\
+	(0x1FF << UTMI_PLL_CTRL_FBDIV_OFFSET)
+#define UTMI_PLL_CTRL_SEL_LPFR_OFFSET		28
+#define UTMI_PLL_CTRL_SEL_LPFR_MASK		\
+	(0x3 << UTMI_PLL_CTRL_SEL_LPFR_OFFSET)
+#define UTMI_PLL_CTRL_PLL_RDY_OFFSET		31
+#define UTMI_PLL_CTRL_PLL_RDY_MASK		\
+	(0x1 << UTMI_PLL_CTRL_PLL_RDY_OFFSET)
+#define UTMI_CALIB_CTRL_REG			0x8
+#define UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET	8
+#define UTMI_CALIB_CTRL_IMPCAL_VTH_MASK		\
+	(0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET)
+#define UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET	23
+#define UTMI_CALIB_CTRL_IMPCAL_DONE_MASK	\
+	(0x1 << UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET)
+#define UTMI_CALIB_CTRL_PLLCAL_DONE_OFFSET	31
+#define UTMI_CALIB_CTRL_PLLCAL_DONE_MASK	\
+	(0x1 << UTMI_CALIB_CTRL_PLLCAL_DONE_OFFSET)
+#define UTMI_TX_CH_CTRL_REG			0xC
+#define UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET	12
+#define UTMI_TX_CH_CTRL_DRV_EN_LS_MASK		\
+	(0xf << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET)
+#define UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET	16
+#define UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK		\
+	(0xf << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET)
+#define UTMI_TX_CH_CTRL_AMP_OFFSET		20
+#define UTMI_TX_CH_CTRL_AMP_MASK		\
+	(0x7 << UTMI_TX_CH_CTRL_AMP_OFFSET)
+#define UTMI_RX_CH_CTRL0_REG			0x14
+#define UTMI_RX_CH_CTRL0_SQ_DET_OFFSET		15
+#define UTMI_RX_CH_CTRL0_SQ_DET_MASK		\
+	(0x1 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET)
+#define UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET	28
+#define UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK	\
+	(0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET)
+#define UTMI_RX_CH_CTRL1_REG			0x18
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET	0
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_MASK	\
+	(0x7 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET)
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET	3
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_MASK	\
+	(0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET)
+#define UTMI_CTRL_STATUS0_REG			0x24
+#define UTMI_CTRL_STATUS0_SUSPENDM_OFFSET	22
+#define UTMI_CTRL_STATUS0_SUSPENDM_MASK		\
+	(0x1 << UTMI_CTRL_STATUS0_SUSPENDM_OFFSET)
+#define UTMI_CTRL_STATUS0_TEST_SEL_OFFSET	25
+#define UTMI_CTRL_STATUS0_TEST_SEL_MASK		\
+	(0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET)
+#define UTMI_CHGDTC_CTRL_REG			0x38
+#define UTMI_CHGDTC_CTRL_VDAT_OFFSET		8
+#define UTMI_CHGDTC_CTRL_VDAT_MASK		\
+	(0x3 << UTMI_CHGDTC_CTRL_VDAT_OFFSET)
+#define UTMI_CHGDTC_CTRL_VSRC_OFFSET		10
+#define UTMI_CHGDTC_CTRL_VSRC_MASK		\
+	(0x3 << UTMI_CHGDTC_CTRL_VSRC_OFFSET)
+
+#define ARMADA37XX_PLL_LOCK_TIMEOUT	1000
+#define CP110_PLL_LOCK_TIMEOUT		100
+
 struct mvebu_utmi_phy {
 	struct phy *phy;
 	void __iomem *regs;
+	void __iomem *utmi_cfg_reg;
+	void __iomem *usb_cfg_reg;
+	spinlock_t *usb_cfg_lock; /* USB config reg access lock */
 	u32 connect_to;
 	u32 index;
 };
 
+/* The same USB config register are accessed in both UTMI0 and
+ * UTMI1 initialization, so a spin lock is defined in case it
+ * may 2 CPUs power on/off the UTMI and need to access the
+ * register in the same time. The spin lock is shared by
+ * all CP110 units.
+ */
+static DEFINE_SPINLOCK(cp110_usb_cfg_lock);
+
 /**************************************************************************
   * poll_reg
   *
@@ -155,7 +243,7 @@ static int mvebu_a3700_utmi_phy_power_on(struct phy *phy)
 	ret = poll_reg(USB2_PHY_CAL_CTRL_ADDR + utmi_phy->regs,
 		       PHY_PLLCAL_DONE,
 		       PHY_PLLCAL_DONE,
-		       PLL_LOCK_TIMEOUT);
+		       ARMADA37XX_PLL_LOCK_TIMEOUT);
 	if (ret) {
 		dev_err(dev, "Failed to end USB2 PLL calibration\n");
 		return ret;
@@ -165,7 +253,7 @@ static int mvebu_a3700_utmi_phy_power_on(struct phy *phy)
 	ret = poll_reg(USB2_PHY_CAL_CTRL_ADDR + utmi_phy->regs,
 		       PHY_IMPCAL_DONE,
 		       PHY_IMPCAL_DONE,
-		       PLL_LOCK_TIMEOUT);
+		       ARMADA37XX_PLL_LOCK_TIMEOUT);
 	if (ret) {
 		dev_err(dev, "Failed to end USB2 impedance calibration\n");
 		return ret;
@@ -175,7 +263,7 @@ static int mvebu_a3700_utmi_phy_power_on(struct phy *phy)
 	ret = poll_reg(USB2_RX_CHAN_CTRL1_ADDR + utmi_phy->regs,
 		       USB2PHY_SQCAL_DONE,
 		       USB2PHY_SQCAL_DONE,
-		       PLL_LOCK_TIMEOUT);
+		       ARMADA37XX_PLL_LOCK_TIMEOUT);
 	if (ret) {
 		dev_err(dev, "Failed to end USB2 unknown calibration\n");
 		return ret;
@@ -185,7 +273,7 @@ static int mvebu_a3700_utmi_phy_power_on(struct phy *phy)
 	ret = poll_reg(USB2_PHY_PLL_CTRL_REG0 + utmi_phy->regs,
 		       PLL_READY,
 		       PLL_READY,
-		       PLL_LOCK_TIMEOUT);
+		       ARMADA37XX_PLL_LOCK_TIMEOUT);
 
 	if (ret) {
 		dev_err(dev, "Failed to lock USB2 PLL\n");
@@ -225,17 +313,234 @@ static int mvebu_a3700_utmi_phy_power_off(struct phy *phy)
 	return 0;
 }
 
+/* mvebu_cp110_usb_cfg_set
+ * The function sets the USB config register.
+ * The USB config register are accessed in both UTMI0 and UTMI1 initialization,
+ * so a spin lock is involved in case it may 2 CPUs power on/off the UTMI
+ * and need to access the register in the same time.
+ * Return: void.
+ */
+static inline void mvebu_cp110_usb_cfg_set(struct mvebu_utmi_phy *utmi_phy,
+					   u32 data, u32 mask)
+{
+	spin_lock(utmi_phy->usb_cfg_lock);
+
+	reg_set(utmi_phy->usb_cfg_reg, data, mask);
+
+	spin_unlock(utmi_phy->usb_cfg_lock);
+}
+
+/* mvebu_cp110_utmi_phy_power_off
+ * The function implements the UTMI power off.
+ * 1) Power down UTMI PHY
+ * 2) Power down PLL
+ * return: 0 for success; non-zero for failed.
+ */
+static int mvebu_cp110_utmi_phy_power_off(struct phy *phy)
+{
+	struct mvebu_utmi_phy *utmi_phy = phy_get_drvdata(phy);
+
+	dev_dbg(&phy->dev, "%s: Enter\n", __func__);
+
+	if (!utmi_phy)
+		return -ENODEV;
+
+	/* Power down UTMI PHY */
+	reg_set(utmi_phy->utmi_cfg_reg, 0x0, UTMI_PHY_CFG_PU_MASK);
+
+	/* PLL Power down */
+	mvebu_cp110_usb_cfg_set(utmi_phy,
+				0x0 << UTMI_USB_CFG_PLL_OFFSET,
+				UTMI_USB_CFG_PLL_MASK);
+
+	dev_dbg(&phy->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
+/* mvebu_cp110_utmi_phy_config
+ * The function implements the UTMI configurations.
+ * 1) Set clock
+ * 2) Set Calibration and LS TX driver
+ * 3) Enable SQ, analog squelch detect and External squelch calibration
+ * 4) Set VDAT/VSRC Reference Voltage
+ * return: void.
+ */
+static void mvebu_cp110_utmi_phy_config(struct phy *phy)
+{
+	u32 mask, data;
+	struct mvebu_utmi_phy *utmi_phy = phy_get_drvdata(phy);
+
+	/* Reference Clock Divider Select */
+	mask = UTMI_PLL_CTRL_REFDIV_MASK;
+	data = 0x5 << UTMI_PLL_CTRL_REFDIV_OFFSET;
+	/* Feedback Clock Divider Select - 90 for 25Mhz*/
+	mask |= UTMI_PLL_CTRL_FBDIV_MASK;
+	data |= 0x60 << UTMI_PLL_CTRL_FBDIV_OFFSET;
+	/* Select LPFR - 0x0 for 25Mhz/5=5Mhz*/
+	mask |= UTMI_PLL_CTRL_SEL_LPFR_MASK;
+	data |= 0x0 << UTMI_PLL_CTRL_SEL_LPFR_OFFSET;
+	reg_set(utmi_phy->regs + UTMI_PLL_CTRL_REG, data, mask);
+
+	/* Impedance Calibration Threshold Setting */
+	reg_set(utmi_phy->regs + UTMI_CALIB_CTRL_REG,
+		0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET,
+		UTMI_CALIB_CTRL_IMPCAL_VTH_MASK);
+
+	/* Set LS TX driver strength coarse control */
+	mask = UTMI_TX_CH_CTRL_AMP_MASK;
+	data = 0x4 << UTMI_TX_CH_CTRL_AMP_OFFSET;
+	reg_set(utmi_phy->regs + UTMI_TX_CH_CTRL_REG, data, mask);
+
+	/* Enable SQ */
+	mask = UTMI_RX_CH_CTRL0_SQ_DET_MASK;
+	data = 0x0 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET;
+	/* Enable analog squelch detect */
+	mask |= UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK;
+	data |= 0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET;
+	reg_set(utmi_phy->regs + UTMI_RX_CH_CTRL0_REG, data, mask);
+
+	/* Set External squelch calibration number */
+	mask = UTMI_RX_CH_CTRL1_SQ_AMP_CAL_MASK;
+	data = 0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET;
+	/* Enable the External squelch calibration */
+	mask |= UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_MASK;
+	data |= 0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET;
+	reg_set(utmi_phy->regs + UTMI_RX_CH_CTRL1_REG, data, mask);
+
+	/* Set Control VDAT Reference Voltage - 0.325V */
+	mask = UTMI_CHGDTC_CTRL_VDAT_MASK;
+	data = 0x1 << UTMI_CHGDTC_CTRL_VDAT_OFFSET;
+	/* Set Control VSRC Reference Voltage - 0.6V */
+	mask |= UTMI_CHGDTC_CTRL_VSRC_MASK;
+	data |= 0x1 << UTMI_CHGDTC_CTRL_VSRC_OFFSET;
+	reg_set(utmi_phy->regs + UTMI_CHGDTC_CTRL_REG, data, mask);
+}
+
+/* mvebu_cp110_utmi_phy_power_on
+ * The function implements the UTMI power on.
+ * 1) Power off UTMI PHY and PLL
+ * 2) Set SuspendDM
+ * 3) Configure UTMI PHY
+ * 4) Power up PHY
+ * 5) Disable Test UTMI select
+ * 6) Power up PLL
+ * return: 0 for success; non-zero for failed.
+ */
+static int mvebu_cp110_utmi_phy_power_on(struct phy *phy)
+{
+	int ret = 0;
+	u32 data, mask;
+	void __iomem *addr;
+	struct mvebu_utmi_phy *utmi_phy = phy_get_drvdata(phy);
+
+	dev_dbg(&phy->dev, "%s: Enter\n", __func__);
+
+	if (!utmi_phy)
+		return -ENODEV;
+
+	/* It is necessary to power off UTMI before configuration */
+	ret = mvebu_cp110_utmi_phy_power_off(phy);
+	if (ret) {
+		dev_err(&phy->dev, "UTMI power off failed\n");
+		return ret;
+	}
+
+	/*
+	 * If UTMI connected to USB Device, configure mux prior to PHY init
+	 * (Device can be connected to UTMI0 or to UTMI1)
+	 */
+	if (utmi_phy->connect_to == UTMI_PHY_TO_USB3_DEVICE0) {
+		/* USB3 Device UTMI enable */
+		mask = UTMI_USB_CFG_DEVICE_EN_MASK;
+		data = 0x1 << UTMI_USB_CFG_DEVICE_EN_OFFSET;
+		/* USB3 Device UTMI MUX */
+		mask |= UTMI_USB_CFG_DEVICE_MUX_MASK;
+		data |= utmi_phy->index << UTMI_USB_CFG_DEVICE_MUX_OFFSET;
+		mvebu_cp110_usb_cfg_set(utmi_phy, data, mask);
+	}
+
+	/* Set Test suspendm mode */
+	mask = UTMI_CTRL_STATUS0_SUSPENDM_MASK;
+	data = 0x1 << UTMI_CTRL_STATUS0_SUSPENDM_OFFSET;
+	/* Enable Test UTMI select */
+	mask |= UTMI_CTRL_STATUS0_TEST_SEL_MASK;
+	data |= 0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET;
+	reg_set(utmi_phy->regs + UTMI_CTRL_STATUS0_REG, data, mask);
+
+	/* Wait for UTMI power down */
+	mdelay(1);
+
+	/* PHY config first */
+	mvebu_cp110_utmi_phy_config(phy);
+
+	/* Power UP UTMI PHY */
+	data = 0x1 << UTMI_PHY_CFG_PU_OFFSET;
+	reg_set(utmi_phy->utmi_cfg_reg, data, UTMI_PHY_CFG_PU_MASK);
+
+	/* Disable Test UTMI select */
+	reg_set(utmi_phy->regs + UTMI_CTRL_STATUS0_REG,
+		0x0 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET,
+		UTMI_CTRL_STATUS0_TEST_SEL_MASK);
+
+	addr = utmi_phy->regs + UTMI_CALIB_CTRL_REG;
+	data = UTMI_CALIB_CTRL_IMPCAL_DONE_MASK;
+	mask = data;
+	ret = poll_reg(addr, data, mask, CP110_PLL_LOCK_TIMEOUT);
+	if (ret) {
+		dev_err(&phy->dev, "Impedance calibration is not done\n");
+		return ret;
+	}
+
+	data = UTMI_CALIB_CTRL_PLLCAL_DONE_MASK;
+	mask = data;
+	ret = poll_reg(addr, data, mask, CP110_PLL_LOCK_TIMEOUT);
+	if (ret) {
+		dev_err(&phy->dev, "PLL calibration is not done\n");
+		return ret;
+	}
+
+	addr = utmi_phy->regs + UTMI_PLL_CTRL_REG;
+	data = UTMI_PLL_CTRL_PLL_RDY_MASK;
+	mask = data;
+	ret = poll_reg(addr, data, mask, CP110_PLL_LOCK_TIMEOUT);
+	if (ret) {
+		dev_err(&phy->dev, "PLL is not ready\n");
+		return ret;
+	}
+
+	/* PLL Power up */
+	dev_dbg(&phy->dev, "stage: UTMI PHY power up PLL\n");
+	mvebu_cp110_usb_cfg_set(utmi_phy,
+				0x1 << UTMI_USB_CFG_PLL_OFFSET,
+				UTMI_USB_CFG_PLL_MASK);
+
+	dev_dbg(&phy->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
 const struct phy_ops armada3700_utmi_phy_ops = {
 	.power_on = mvebu_a3700_utmi_phy_power_on,
 	.power_off = mvebu_a3700_utmi_phy_power_off,
 	.owner = THIS_MODULE,
 };
 
+const struct phy_ops cp110_utmi_phy_ops = {
+	.power_on = mvebu_cp110_utmi_phy_power_on,
+	.power_off = mvebu_cp110_utmi_phy_power_off,
+	.owner = THIS_MODULE,
+};
+
 static const struct of_device_id mvebu_utmi_of_match[] = {
 	{
 		.compatible = "marvell,armada-3700-utmi-phy",
 		.data = &armada3700_utmi_phy_ops
 	},
+	{
+		.compatible = "marvell,cp110-utmi-phy",
+		.data = &cp110_utmi_phy_ops
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, mvebu_utmi_of_match);
@@ -269,6 +574,34 @@ static int mvebu_utmi_phy_probe(struct platform_device *pdev)
 	if (IS_ERR(utmi_phy->regs))
 		return PTR_ERR(utmi_phy->regs);
 
+	/* Get USB and UTMI config reg for CP110 */
+	if (of_device_is_compatible(pdev->dev.of_node,
+				    "marvell,cp110-utmi-phy")) {
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "usb-cfg-reg");
+		if (!res) {
+			dev_err(&pdev->dev, "No USB config memory resource\n");
+			return -ENODEV;
+		}
+		utmi_phy->usb_cfg_reg = ioremap(res->start,
+						resource_size(res));
+		if (!utmi_phy->usb_cfg_reg) {
+			pr_err("Unable to map USB config register\n");
+			return -ENOMEM;
+		}
+		utmi_phy->usb_cfg_lock = &cp110_usb_cfg_lock;
+
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "utmi-cfg-reg");
+		if (!res) {
+			dev_err(&pdev->dev, "No UTMI config memory resource\n");
+			return -ENODEV;
+		}
+		utmi_phy->utmi_cfg_reg = devm_ioremap_resource(dev, res);
+		if (IS_ERR(utmi_phy->utmi_cfg_reg))
+			return PTR_ERR(utmi_phy->utmi_cfg_reg);
+	}
+
 	/* Get property of utmi-port, used check the UTMI connect to where */
 	ret = of_property_read_u32(pdev->dev.of_node, "utmi-port",
 				   &utmi_phy->connect_to);
@@ -302,8 +635,22 @@ static int mvebu_utmi_phy_probe(struct platform_device *pdev)
 	return PTR_ERR_OR_ZERO(phy_provider);
 }
 
+static int mvebu_utmi_phy_remove(struct platform_device *pdev)
+{
+	struct mvebu_utmi_phy *utmi_phy;
+
+	utmi_phy = (struct mvebu_utmi_phy *)dev_get_drvdata(&pdev->dev);
+	/* Unmap USB config reg for CP110 */
+	if (of_device_is_compatible(pdev->dev.of_node,
+				    "marvell,cp110-utmi-phy"))
+		iounmap(utmi_phy->usb_cfg_reg);
+
+	return 0;
+}
+
 static struct platform_driver mvebu_utmi_driver = {
 	.probe	= mvebu_utmi_phy_probe,
+	.remove = mvebu_utmi_phy_remove,
 	.driver	= {
 		.name		= "phy-mvebu-utmi",
 		.owner		= THIS_MODULE,
-- 
1.7.9.5


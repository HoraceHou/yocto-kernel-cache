From c6a97231ee803b769e90278ba37012af1fc3abb4 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Wed, 25 May 2016 16:59:22 +0300
Subject: [PATCH 0257/1345] mvneta: Fix SWCC support

commit  f48598d5914ff5935c0ba9f1ea07552dc453df8a from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- dma_sync must be done after copy and before refill
- dma_unmap must be done on originally mapped address
(before add rx_offset_correction)
- Correct usage of rx_offset_correction and NETA_SKB_PAD

Change-Id: I4d78fa019c5ad5b6b156c67083dcd75db2fc08f0
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/30083
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvneta.c |   43 +++++++++++++++++++--------------
 1 file changed, 25 insertions(+), 18 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index eff840a..baa4678 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -1921,7 +1921,7 @@ static void mvneta_rxq_drop_pkts(struct mvneta_port *pp,
 		struct mvneta_rx_desc *rx_desc = rxq->descs + i;
 		void *data = rxq->buf_virt_addr[i];
 
-		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr,
+		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr - pp->rx_offset_correction,
 				 MVNETA_RX_BUF_SIZE(pp->pkt_size), DMA_FROM_DEVICE);
 		mvneta_frag_free(pp->frag_size, data);
 	}
@@ -1973,17 +1973,23 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 		if (rx_bytes <= rx_copybreak) {
 		/* better copy a small frame and not unmap the DMA region */
 			skb = netdev_alloc_skb_ip_align(dev, rx_bytes);
-			if (unlikely(!skb))
+			if (unlikely(!skb)) {
+				netdev_warn(dev, "rxq #%d - Can't allocate skb. rx_bytes = %d bytes\n",
+					    rxq->id, rx_bytes);
 				goto err_drop_frame;
+			}
 
+			/* Copy data from buffer to SKB without Marvell header */
+			memcpy(skb->data,
+			       data + MVNETA_MH_SIZE + NET_SKB_PAD,
+			       rx_bytes);
+
+			skb_put(skb, rx_bytes);
 			dma_sync_single_range_for_cpu(dev->dev.parent,
 						      phys_addr,
-						      MVNETA_MH_SIZE + NET_SKB_PAD,
-						      rx_bytes,
+						      NET_SKB_PAD - pp->rx_offset_correction,
+						      rx_bytes + MVNETA_MH_SIZE,
 						      DMA_FROM_DEVICE);
-			memcpy(skb_put(skb, rx_bytes),
-			       data + MVNETA_MH_SIZE + NET_SKB_PAD,
-			       rx_bytes);
 
 			skb->protocol = eth_type_trans(skb, dev);
 			mvneta_rx_csum(pp, rx_status, skb);
@@ -1996,27 +2002,28 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 			continue;
 		}
 
-		/* Refill processing */
-		err = mvneta_rx_refill(pp, rx_desc, rxq);
-		if (err) {
-			netdev_err(dev, "Linux processing - Can't refill\n");
-			rxq->missed++;
-			goto err_drop_frame;
-		}
-
 		frag_size = pp->frag_size;
-
 		skb = build_skb(data, frag_size > PAGE_SIZE ? 0 : frag_size);
+		if (unlikely(!skb)) {
+			netdev_warn(dev, "rxq #%d - Can't build skb. frag_size = %d bytes\n",
+				    rxq->id, pp->frag_size);
+			goto err_drop_frame;
+		}
 
 		/* After refill old buffer has to be unmapped regardless
 		 * the skb is successfully built or not.
 		 */
-		dma_unmap_single(dev->dev.parent, phys_addr,
+		dma_unmap_single(dev->dev.parent, phys_addr - pp->rx_offset_correction,
 				 MVNETA_RX_BUF_SIZE(pp->pkt_size),
 				 DMA_FROM_DEVICE);
 
-		if (!skb)
+		/* Refill processing */
+		err = mvneta_rx_refill(pp, rx_desc, rxq);
+		if (err) {
+			netdev_err(dev, "Linux processing - Can't refill\n");
+			rxq->missed++;
 			goto err_drop_frame;
+		}
 
 		rcvd_pkts++;
 		rcvd_bytes += rx_bytes;
-- 
1.7.9.5


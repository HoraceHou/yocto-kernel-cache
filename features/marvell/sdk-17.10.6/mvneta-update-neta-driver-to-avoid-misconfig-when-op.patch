From 98769a357ad9e3f0cc8196b33b5bd47ba62af194 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 24 Aug 2016 21:57:12 +0800
Subject: [PATCH 0542/1345] mvneta: update neta driver to avoid misconfig when
 operate auto negotiation

commit  e7dbc0f449bedcf7a99d33d84f6d771aa28770ef from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- the patch fix the issue SYSTEMSW-2544 that auto negotiation will
  make eth0 dead, no packet rx, mib counter is 0
- the reason is register of AN Configuration is updated wrongly

Change-Id: I04f06784416c2305d2678aec19f69ecf3d710688
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32354
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvneta.c |  219 +++++++++++++++++++++------------
 1 file changed, 141 insertions(+), 78 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index e360026..81f7a08 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -189,9 +189,10 @@
 #define MVNETA_GMAC_CTRL_0                       0x2c00
 #define      MVNETA_GMAC_MAX_RX_SIZE_SHIFT       2
 #define      MVNETA_GMAC_MAX_RX_SIZE_MASK        0x7ffc
+#define      MVNETA_GMAC0_PORT_1000BASE_X        BIT(1)
 #define      MVNETA_GMAC0_PORT_ENABLE            BIT(0)
 #define MVNETA_GMAC_CTRL_2                       0x2c08
-#define      MVNETA_GMAC2_INBAND_AN_ENABLE       BIT(0)
+#define      MVNETA_GMAC2_SGMII_INBAND_AN_MODE   BIT(0)
 #define      MVNETA_GMAC2_PCS_ENABLE             BIT(3)
 #define      MVNETA_GMAC2_PORT_RGMII             BIT(4)
 #define      MVNETA_GMAC2_PORT_RESET             BIT(6)
@@ -208,9 +209,14 @@
 #define      MVNETA_GMAC_FORCE_LINK_DOWN         BIT(0)
 #define      MVNETA_GMAC_FORCE_LINK_PASS         BIT(1)
 #define      MVNETA_GMAC_INBAND_AN_ENABLE        BIT(2)
+#define      MVNETA_GMAC_INBAND_AN_BYPASS_EN     BIT(3)
+#define      MVNETA_GMAC_INBAND_RESTART_AN       BIT(4)
 #define      MVNETA_GMAC_CONFIG_MII_SPEED        BIT(5)
 #define      MVNETA_GMAC_CONFIG_GMII_SPEED       BIT(6)
 #define      MVNETA_GMAC_AN_SPEED_EN             BIT(7)
+#define      MVNETA_GMAC_CONFIG_FLOW_CTRL        BIT(8)
+#define      MVNETA_GMAC_ADVERT_SYM_FLOW_CTRL    BIT(9)
+#define      MVNETA_GMAC_ADVERT_ASYM_FC_ADV      BIT(10)
 #define      MVNETA_GMAC_AN_FLOW_CTRL_EN         BIT(11)
 #define      MVNETA_GMAC_CONFIG_FULL_DUPLEX      BIT(12)
 #define      MVNETA_GMAC_AN_DUPLEX_EN            BIT(13)
@@ -241,6 +247,11 @@
 
 #define MVNETA_REGS_GMAC_LEN                     0xAC9
 
+enum mvneta_port_type {
+	PORT_TYPE_SGMII,
+	PORT_TYPE_1000BASE_X
+};
+
 /* Descriptor ring Macros */
 #define MVNETA_QUEUE_NEXT_DESC(q, index)	\
 	(((index) < (q)->last_desc) ? ((index) + 1) : 0)
@@ -1301,42 +1312,111 @@ static void mvneta_set_other_mcast_table(struct mvneta_port *pp, int queue)
 		mvreg_write(pp, MVNETA_DA_FILT_OTH_MCAST + offset, val);
 }
 
-static void mvneta_set_autoneg(struct mvneta_port *pp, int enable)
+/* Get the port type, 0 - SGMII, 1 -- 1000BaseX */
+static enum mvneta_port_type mvneta_port_type_get(struct mvneta_port *pp)
 {
 	u32 val;
 
-	if (enable) {
-		val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
-		val &= ~(MVNETA_GMAC_FORCE_LINK_PASS |
-			 MVNETA_GMAC_FORCE_LINK_DOWN |
-			 MVNETA_GMAC_AN_FLOW_CTRL_EN);
-		val |= MVNETA_GMAC_INBAND_AN_ENABLE |
-		       MVNETA_GMAC_AN_SPEED_EN |
-		       MVNETA_GMAC_AN_DUPLEX_EN;
-		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, val);
-
-		val = mvreg_read(pp, MVNETA_GMAC_CLOCK_DIVIDER);
-		val |= MVNETA_GMAC_1MS_CLOCK_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, val);
-
-		val = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
-		val |= MVNETA_GMAC2_INBAND_AN_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CTRL_2, val);
+	val = mvreg_read(pp, MVNETA_GMAC_CTRL_0);
+	if (val & MVNETA_GMAC0_PORT_1000BASE_X)
+		return PORT_TYPE_1000BASE_X;
+	else
+		return PORT_TYPE_SGMII;
+}
+
+static void mvneta_mac_config(struct mvneta_port *pp)
+{
+	enum mvneta_port_type port_type = mvneta_port_type_get(pp);
+	u32 new_ctrl2, gmac_ctrl2 = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
+	u32 new_clk, gmac_clk = mvreg_read(pp, MVNETA_GMAC_CLOCK_DIVIDER);
+	u32 new_an, gmac_an = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
+
+	/* Clear all fields need to config with different work mode */
+	new_ctrl2 = gmac_ctrl2 & ~MVNETA_GMAC2_SGMII_INBAND_AN_MODE;
+	new_clk = gmac_clk & ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
+	new_an = gmac_an & ~(MVNETA_GMAC_INBAND_AN_ENABLE |
+			     MVNETA_GMAC_INBAND_RESTART_AN |
+			     MVNETA_GMAC_CONFIG_MII_SPEED |
+			     MVNETA_GMAC_CONFIG_GMII_SPEED |
+			     MVNETA_GMAC_AN_SPEED_EN |
+			     MVNETA_GMAC_ADVERT_SYM_FLOW_CTRL |
+			     MVNETA_GMAC_CONFIG_FLOW_CTRL |
+			     MVNETA_GMAC_AN_FLOW_CTRL_EN |
+			     MVNETA_GMAC_CONFIG_FULL_DUPLEX |
+			     MVNETA_GMAC_AN_DUPLEX_EN |
+			     MVNETA_GMAC_FORCE_LINK_PASS |
+			     MVNETA_GMAC_FORCE_LINK_DOWN);
+
+	if (pp->use_inband_status) {
+		switch (port_type) {
+		case PORT_TYPE_SGMII:
+			/* SGMII mode receives the state from the PHY */
+			new_ctrl2 |= MVNETA_GMAC2_SGMII_INBAND_AN_MODE;
+			new_clk |= MVNETA_GMAC_1MS_CLOCK_ENABLE;
+			/* SGMII aoto-nego clock */
+			new_an |= MVNETA_GMAC_INBAND_AN_ENABLE |
+				   MVNETA_GMAC_INBAND_AN_BYPASS_EN |
+				   MVNETA_GMAC_AN_SPEED_EN |
+				   MVNETA_GMAC_AN_DUPLEX_EN;
+			break;
+
+		case PORT_TYPE_1000BASE_X:
+			/* A3700 spec: In 1000BASE-X, the port must be set to work
+			 * in full-duplex mode, at 1000 Mbps.
+			 * Duplex and Speed Auto-Negotiation must be disabled
+			 */
+			new_an |= MVNETA_GMAC_INBAND_AN_ENABLE |
+				  MVNETA_GMAC_INBAND_AN_BYPASS_EN |
+				  MVNETA_GMAC_CONFIG_GMII_SPEED |
+				  MVNETA_GMAC_ADVERT_SYM_FLOW_CTRL |
+				  MVNETA_GMAC_AN_FLOW_CTRL_EN |
+				  MVNETA_GMAC_CONFIG_FLOW_CTRL |
+				  MVNETA_GMAC_CONFIG_FULL_DUPLEX;
+
+			break;
+		}
 	} else {
-		val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
-		val &= ~(MVNETA_GMAC_INBAND_AN_ENABLE |
-		       MVNETA_GMAC_AN_SPEED_EN |
-		       MVNETA_GMAC_AN_DUPLEX_EN);
-		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, val);
-
-		val = mvreg_read(pp, MVNETA_GMAC_CLOCK_DIVIDER);
-		val &= ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, val);
-
-		val = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
-		val &= ~MVNETA_GMAC2_INBAND_AN_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CTRL_2, val);
+		/* SMI auto-nego, GMAC will get info from PHY with SMI */
+		if (pp->phy_dev) {
+			if (pp->phy_dev->duplex)
+				new_an |= MVNETA_GMAC_CONFIG_FULL_DUPLEX;
+
+			if (pp->phy_dev->speed == SPEED_1000)
+				new_an |= MVNETA_GMAC_CONFIG_GMII_SPEED;
+			else if (pp->phy_dev->speed == SPEED_100)
+				new_an |= MVNETA_GMAC_CONFIG_MII_SPEED;
+
+			if (pp->phy_dev->pause)
+				new_an |= MVNETA_GMAC_CONFIG_FLOW_CTRL;
+
+			if (pp->phy_dev->asym_pause)
+				new_an |= MVNETA_GMAC_ADVERT_ASYM_FC_ADV;
+
+			/* Fixed link, Force link up */
+			if (phy_is_pseudo_fixed_link(pp->phy_dev)) {
+				new_an |= MVNETA_GMAC_FORCE_LINK_PASS;
+				new_an &= ~MVNETA_GMAC_FORCE_LINK_DOWN;
+			}
+		}
 	}
+
+	/* Armada 370 documentation says we can only change the port mode
+	 * and in-band enable when the link is down, so force it down
+	 * while making these changes. We also do this for GMAC_CTRL2
+	 */
+	if ((new_ctrl2 ^ gmac_ctrl2) & MVNETA_GMAC2_SGMII_INBAND_AN_MODE ||
+	    (new_an  ^ gmac_an) & MVNETA_GMAC_INBAND_AN_ENABLE) {
+		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG,
+			    (gmac_an & ~MVNETA_GMAC_FORCE_LINK_PASS) |
+			    MVNETA_GMAC_FORCE_LINK_DOWN);
+	}
+
+	if (new_ctrl2 != gmac_ctrl2)
+		mvreg_write(pp, MVNETA_GMAC_CTRL_2, new_ctrl2);
+	if (new_clk != gmac_clk)
+		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, new_clk);
+	if (new_an != gmac_an)
+		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, new_an);
 }
 
 static void mvneta_percpu_unmask_interrupt(void *arg)
@@ -1491,7 +1571,7 @@ static void mvneta_defaults_set(struct mvneta_port *pp)
 	val &= ~MVNETA_PHY_POLLING_ENABLE;
 	mvreg_write(pp, MVNETA_UNIT_CONTROL, val);
 
-	mvneta_set_autoneg(pp, pp->use_inband_status);
+	mvneta_mac_config(pp);
 	mvneta_set_ucast_table(pp, -1);
 	mvneta_set_special_mcast_table(pp, -1);
 	mvneta_set_other_mcast_table(pp, -1);
@@ -3207,7 +3287,8 @@ static void mvneta_start_dev(struct mvneta_port *pp)
 		    MVNETA_CAUSE_LINK_CHANGE |
 		    MVNETA_CAUSE_PSC_SYNC_CHANGE);
 
-	phy_start(ndev->phydev);
+	if (!pp->use_inband_status)
+		phy_start(ndev->phydev);
 	netif_tx_start_all_queues(pp->dev);
 }
 
@@ -3216,7 +3297,8 @@ static void mvneta_stop_dev(struct mvneta_port *pp)
 	unsigned int cpu;
 	struct net_device *ndev = pp->dev;
 
-	phy_stop(ndev->phydev);
+	if (!pp->use_inband_status)
+		phy_stop(ndev->phydev);
 
 	if (!pp->neta_armada3700) {
 		for_each_online_cpu(cpu) {
@@ -3676,10 +3758,12 @@ static int mvneta_open(struct net_device *dev)
 	/* In default link is down */
 	netif_carrier_off(pp->dev);
 
-	ret = mvneta_mdio_probe(pp);
-	if (ret < 0) {
-		netdev_err(dev, "cannot probe MDIO bus\n");
-		goto err_free_dead_hp;
+	if (!pp->use_inband_status) {
+		err = mvneta_mdio_probe(pp);
+		if (err < 0) {
+			netdev_err(dev, "cannot probe MDIO bus\n");
+			goto err_free_stats;
+		}
 	}
 
 	mvneta_start_dev(pp);
@@ -3724,7 +3808,8 @@ static int mvneta_stop(struct net_device *dev)
 		spin_unlock(&pp->lock);
 
 		mvneta_stop_dev(pp);
-		mvneta_mdio_remove(pp);
+		if (!pp->use_inband_status)
+			mvneta_mdio_remove(pp);
 
 		cpuhp_state_remove_instance_nocalls(online_hpstate,
 						    &pp->node_online);
@@ -3734,7 +3819,8 @@ static int mvneta_stop(struct net_device *dev)
 		free_percpu_irq(dev->irq, pp->ports);
 	} else {
 		mvneta_stop_dev(pp);
-		mvneta_mdio_remove(pp);
+		if (!pp->use_inband_status)
+			mvneta_mdio_remove(pp);
 		free_irq(dev->irq, pp);
 	}
 
@@ -3780,48 +3866,25 @@ static int mvneta_spd_dplx_valid(struct mvneta_port *pp,
 mvneta_ethtool_set_link_ksettings(struct net_device *ndev,
 				  const struct ethtool_link_ksettings *cmd)
 {
+	int ret = 0;
 	struct mvneta_port *pp = netdev_priv(ndev);
 	struct phy_device *phydev = ndev->phydev;
 
-	if (!phydev)
-		return -ENODEV;
-
-	if (mvneta_spd_dplx_valid(pp, cmd))
-		return -EINVAL;
-
-	if ((cmd->base.autoneg == AUTONEG_ENABLE) != pp->use_inband_status) {
-		u32 val;
-
-		mvneta_set_autoneg(pp, cmd->base.autoneg == AUTONEG_ENABLE);
-
-		if (cmd->base.autoneg == AUTONEG_DISABLE) {
-			val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
-			val &= ~(MVNETA_GMAC_CONFIG_MII_SPEED |
-				 MVNETA_GMAC_CONFIG_GMII_SPEED |
-				 MVNETA_GMAC_CONFIG_FULL_DUPLEX);
-
-			if (phydev->duplex)
-				val |= MVNETA_GMAC_CONFIG_FULL_DUPLEX;
-
-			if (phydev->speed == SPEED_1000)
-				val |= MVNETA_GMAC_CONFIG_GMII_SPEED;
-			else if (phydev->speed == SPEED_100)
-				val |= MVNETA_GMAC_CONFIG_MII_SPEED;
-
-			mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, val);
-		}
-
-		pp->use_inband_status = (cmd->base.autoneg == AUTONEG_ENABLE);
-		netdev_info(pp->dev, "autoneg status set to %i\n",
-			    pp->use_inband_status);
-
-		if (netif_running(ndev)) {
-			mvneta_port_down(pp);
-			mvneta_port_up(pp);
-		}
+	if (phydev) {
+		/* Fixed link not allowed to update speed/duplex */
+		if (phy_is_pseudo_fixed_link(pp->phy_dev))
+			return -EINVAL;
+		if (mvneta_spd_dplx_valid(pp, cmd))
+			return -EINVAL;
+		ret = phy_ethtool_ksettings_set(ndev->phydev, cmd);
+		if (ret)
+			return ret;
 	}
 
-	return phy_ethtool_ksettings_set(ndev->phydev, cmd);
+	/* Config MAC */
+	mvneta_mac_config(pp);
+
+	return ret;
 }
 
 /* Set interrupt coalescing for ethtools */
-- 
1.7.9.5


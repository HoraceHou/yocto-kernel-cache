From 229393014f1a930c6f0eb2efb51c3abac9aff0c2 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 18 Jan 2017 00:23:06 +0800
Subject: [PATCH 1330/1345] phy: udc: add PHY infrastructure support in udc
 driver

commit  a005ad1127b459a6a06a362cffd11ac02c9413b8 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

The patch added call for PHY init if exists via calling API
(phy_init, phy_power_on, etc.)
The main purposes to support phy infrastructure are:
  - Initialize udc PHY without bootloader dependency
  - power on/off in case doing suspend/resume

Change-Id: Ibe2b782330c6a9ab7f9cc05deaa940595d0c6695
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37078
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/usb/marvell-udc.txt        |    4 +++
 drivers/usb/gadget/udc/mv_udc.h                    |    2 ++
 drivers/usb/gadget/udc/mv_udc_core.c               |   26 ++++++++++++++++++++
 3 files changed, 32 insertions(+)

diff --git a/Documentation/devicetree/bindings/usb/marvell-udc.txt b/Documentation/devicetree/bindings/usb/marvell-udc.txt
index ea858eb..6157471 100644
--- a/Documentation/devicetree/bindings/usb/marvell-udc.txt
+++ b/Documentation/devicetree/bindings/usb/marvell-udc.txt
@@ -13,6 +13,8 @@ Optional properties :
 - vbus-gpio	: VBUS interrupt GPIO pin
 		  set to trigger VBUS event notification to PHY/controller
 		  whether VBUS was powered or not
+- phys		: the UTMI PHY associated to this controller
+- phy-names	: the name of UTMI PHY indicated by above property
 
 Example:
 	udc@524100 {
@@ -22,6 +24,8 @@ Example:
 		clocks = <&gateclk 24>, <&gateclk 16>;
  		dma-coherent;
 		vbus-gpio = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+		phys = <&utmi_usb32>;
+		phy-names = "usb";
 		status = "disabled";
 	};
 
diff --git a/drivers/usb/gadget/udc/mv_udc.h b/drivers/usb/gadget/udc/mv_udc.h
index 910c137..6d80b9d 100644
--- a/drivers/usb/gadget/udc/mv_udc.h
+++ b/drivers/usb/gadget/udc/mv_udc.h
@@ -196,6 +196,8 @@ struct mv_udc {
 	struct mv_req			*status_req;
 	struct usb_ctrlrequest		local_setup_buff;
 
+	struct phy			*utmi_phy;
+
 	unsigned int		resume_state;	/* USB state to resume */
 	unsigned int		usb_state;	/* USB current state */
 	unsigned int		ep0_state;	/* Endpoint zero state */
diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c
index 19647ea..7cfa4d7 100644
--- a/drivers/usb/gadget/udc/mv_udc_core.c
+++ b/drivers/usb/gadget/udc/mv_udc_core.c
@@ -2149,6 +2149,12 @@ static int mv_udc_remove(struct platform_device *pdev)
 	/* free dev, wait for the release() finished */
 	wait_for_completion(udc->done);
 
+	/* Power off PHY and exit */
+	if (udc->utmi_phy) {
+		phy_power_off(udc->utmi_phy);
+		phy_exit(udc->utmi_phy);
+	}
+
 	return 0;
 }
 
@@ -2160,6 +2166,7 @@ static int mv_udc_probe(struct platform_device *pdev)
 	struct resource *capregs, *phyregs, *irq;
 	size_t size;
 	struct clk *clk;
+	int err;
 
 	udc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);
 	if (!udc)
@@ -2182,6 +2189,20 @@ static int mv_udc_probe(struct platform_device *pdev)
 		if (udc->vbus_pin < 0)
 			udc->vbus_pin = -ENODEV;
 
+		/* Get comphy and init if there is */
+		udc->utmi_phy = devm_of_phy_get(&pdev->dev, pdev->dev.of_node, "usb");
+		if (!IS_ERR(udc->utmi_phy)) {
+			err = phy_init(udc->utmi_phy);
+			if (err)
+				goto disable_phys;
+
+			err = phy_power_on(udc->utmi_phy);
+			if (err) {
+				phy_exit(udc->utmi_phy);
+				goto disable_phys;
+			}
+		}
+
 	} else if (pdata) {
 		udc->pdata = pdev->dev.platform_data;
 		if (pdata->mode == MV_USB_MODE_OTG) {
@@ -2410,6 +2431,11 @@ static int mv_udc_probe(struct platform_device *pdev)
 			udc->ep_dqh, udc->ep_dqh_dma);
 err_disable_clock:
 	mv_udc_disable_internal(udc);
+disable_phys:
+	if (udc->utmi_phy) {
+		phy_power_off(udc->utmi_phy);
+		phy_exit(udc->utmi_phy);
+	}
 
 	return retval;
 }
-- 
1.7.9.5


From c3512d6ed4d619973893c699315614a7c0c6c67a Mon Sep 17 00:00:00 2001
From: Stefan Chulski <stefanc@marvell.com>
Date: Wed, 23 Nov 2016 14:18:43 +0200
Subject: [PATCH 0652/1345] fix: net: mvxmdio: add mvxmdio support on 64 Bit
 system

commit  f6bdd0374ae5d05b6aa6a1c94535ed29a8f304e7 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- use iomep pointer for XSMI registers instead of u32
- use devm_ioremap to ioremap XSMI registers

Change-Id: I1c179944422a37417398ae0a757de4870f86c9a4
Signed-off-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/34026
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvxmdio.c |   51 +++++++++++++++++++-------------
 1 file changed, 31 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvxmdio.c b/drivers/net/ethernet/marvell/mvxmdio.c
index b755621..6eab861 100644
--- a/drivers/net/ethernet/marvell/mvxmdio.c
+++ b/drivers/net/ethernet/marvell/mvxmdio.c
@@ -39,17 +39,17 @@
 #define XPORT_ADDR(x)		((x & 0x1f) << XPHYADDR_OFFS)
 #define XDEVADDR_OFFS		21	/* Phy device addr offset */
 #define XDEV_ADDR(x)		((x & 0x1f) << XDEVADDR_OFFS)
+#define XSMI_ADDR_REG_OFFS	0x8
 
 struct xmdio_controller {
-	__u32 __bitwise xmdio_mngmnt;	/* XSMI Management Register */
-	__u32 __bitwise unused;		/* unused */
-	__u32 __bitwise xmdio_addr;	/* XSMI Address Register */
-} __packed;
+	void __iomem *xmdio_mngmnt;	/* XSMI Management Register */
+	void __iomem *xmdio_addr;	/* XSMI Address Register */
+};
 
 /* Check if XSMI bus is idle */
 static int xmdio_check_idle(struct xmdio_controller __iomem *regs)
 {
-	return !(readl(&regs->xmdio_mngmnt) & XBUSY);
+	return !(readl(regs->xmdio_mngmnt) & XBUSY);
 }
 
 /* Wait until XSMI bus is free */
@@ -72,7 +72,7 @@ static int xmdio_wait_free(struct device *dev, struct xmdio_controller __iomem *
 /* Check if XSMI bus read operaton is done */
 static int xmdio_check_read_done(struct xmdio_controller __iomem *regs)
 {
-	return readl(&regs->xmdio_mngmnt) & XREAD_VALID;
+	return readl(regs->xmdio_mngmnt) & XREAD_VALID;
 }
 
 /* Wait until XSMI bus read operation is done */
@@ -94,7 +94,7 @@ static int xmdio_wait_read_done(struct device *dev, struct xmdio_controller __io
 
 static int xmdio_read(struct mii_bus *bus, int phy_id, int regnum)
 {
-	struct xmdio_controller __iomem *regs = bus->priv;
+	struct xmdio_controller *regs = bus->priv;
 	u32 reg_val;
 	u16 dev_addr = regnum >> 16;
 	u16 data;
@@ -105,19 +105,19 @@ static int xmdio_read(struct mii_bus *bus, int phy_id, int regnum)
 		return ret;
 
 	/* Write phy reg addr */
-	writel(regnum & 0xffff, &regs->xmdio_addr);
+	writel(regnum & 0xffff, regs->xmdio_addr);
 
 	/* Set phy port and device addrs, and read opcode */
 	reg_val = XPORT_ADDR(phy_id) | XDEV_ADDR(dev_addr) | XOPCODE_ADDR_READ;
 
 	/* Initiate the read operation */
-	writel(reg_val, &regs->xmdio_mngmnt);
+	writel(reg_val, regs->xmdio_mngmnt);
 
 	ret = xmdio_wait_read_done(&bus->dev, regs);
 	if (ret)
 		return ret;
 
-	data = readl(&regs->xmdio_mngmnt) & 0xffff;
+	data = readl(regs->xmdio_mngmnt) & 0xffff;
 
 	return data;
 }
@@ -134,13 +134,13 @@ static int xmdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 value)
 		return ret;
 
 	/* Write phy reg addr */
-	writel(regnum & 0xffff, &regs->xmdio_addr);
+	writel(regnum & 0xffff, regs->xmdio_addr);
 
 	/* Set phy port and device addrs, write opcode, and value */
 	reg_val = XPORT_ADDR(phy_id) | XDEV_ADDR(dev_addr) | XOPCODE_ADDR_WRITE | value;
 
 	/* Initiate the write operation */
-	writel(reg_val, &regs->xmdio_mngmnt);
+	writel(reg_val, regs->xmdio_mngmnt);
 
 	ret = xmdio_wait_free(&bus->dev, regs);
 	if (ret)
@@ -158,14 +158,23 @@ static int xmdio_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct mii_bus *bus;
-	struct resource res;
+	struct resource *res;
 	int ret;
+	struct xmdio_controller *regs;
 
-	ret = of_address_to_resource(np, 0, &res);
-	if (ret) {
-		dev_err(&pdev->dev, "could not obtain address\n");
-		return ret;
-	}
+	regs = devm_kzalloc(&pdev->dev, sizeof(struct xmdio_controller), GFP_KERNEL);
+
+	if (!regs)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	regs->xmdio_mngmnt = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+
+	if (IS_ERR(regs->xmdio_mngmnt))
+		return PTR_ERR(regs->xmdio_mngmnt);
+
+	regs->xmdio_addr = regs->xmdio_mngmnt + XSMI_ADDR_REG_OFFS;
 
 	bus = mdiobus_alloc_size(PHY_MAX_ADDR * sizeof(int));
 	if (!bus)
@@ -176,10 +185,10 @@ static int xmdio_probe(struct platform_device *pdev)
 	bus->write = xmdio_write;
 	bus->reset = xmdio_reset;
 	bus->parent = &pdev->dev;
-	snprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res.start);
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res->start);
 
 	/* Set the PHY base address */
-	bus->priv = of_iomap(np, 0);
+	bus->priv = regs;
 
 	if (!bus->priv) {
 		ret = -ENOMEM;
@@ -209,6 +218,8 @@ static int xmdio_remove(struct platform_device *pdev)
 {
 	struct mii_bus *bus = platform_get_drvdata(pdev);
 
+	devm_kfree(&pdev->dev, bus->priv);
+
 	mdiobus_unregister(bus);
 	iounmap(bus->priv);
 	mdiobus_free(bus);
-- 
1.7.9.5


From 4bd588dc5755037934024499906a9d7d97bcef68 Mon Sep 17 00:00:00 2001
From: Igal Liberman <igall@marvell.com>
Date: Sun, 30 Oct 2016 18:24:50 +0200
Subject: [PATCH 0551/1345] ahci: cp110 : set SATA Workaround at run-time for
 a8k A0 revision

commit  3cadfabfdc1e0773e090d41a085929096d3adb17 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

In A0 CP-110 AHCI unit the port register offsets are not
according to AHCI specification.
This patch allows specifying the port base and offset
at run-time (instead of compilation option).

A1 revision doesn't require this workaround.

Important notice:
- When A8k A0 becomes unsupported - This commit should be
  removed!
- Don't submit this patch upstream

Change-Id: I512ed4de36d3c83ef4e1855d156fbddf4d3f9763
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/33470
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/ata/ahci.h       |   15 ++++++----
 drivers/ata/ahci_mvebu.c |   74 +++++++++++++++++++++++++++++++++++++++++++---
 2 files changed, 80 insertions(+), 9 deletions(-)

diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h
index 71969f2..b98cf24 100644
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@ -358,10 +358,16 @@ struct ahci_host_priv {
 	 * be overridden anytime before the host is activated.
 	 */
 	void			(*start_engine)(struct ata_port *ap);
-#ifdef CONFIG_CP110_SATA_ADDR_WA
+
+	/* In A8k A0 AHCI unit the port register offsets are not
+	 * according to AHCI specification. We determine at runtime the revision
+	 * and set the correct offsets from device-tree.
+	 */
 	u32			port_base;	/* Offset of ports registers */
 	u32			port_offset;	/* Offset between port registers */
-#endif
+	int			a8k_a0_wa;	/* Boolean to determine if A0
+						 * WA should be applied
+						 */
 	irqreturn_t 		(*irq_handler)(int irq, void *dev_instance);
 
 	/* only required for per-port MSI(-X) support */
@@ -426,10 +432,9 @@ static inline void __iomem *__ahci_port_base(struct ata_host *host,
 	struct ahci_host_priv *hpriv = host->private_data;
 	void __iomem *mmio = hpriv->mmio;
 
-#ifdef CONFIG_CP110_SATA_ADDR_WA
-	if (hpriv->port_base && hpriv->port_offset)
+	if (hpriv->a8k_a0_wa && hpriv->port_base && hpriv->port_offset)
 		return mmio + hpriv->port_base + (port_no * hpriv->port_offset);
-#endif
+
 	return mmio + 0x100 + (port_no * 0x80);
 }
 
diff --git a/drivers/ata/ahci_mvebu.c b/drivers/ata/ahci_mvebu.c
index b72bb03..d2ac310 100644
--- a/drivers/ata/ahci_mvebu.c
+++ b/drivers/ata/ahci_mvebu.c
@@ -16,6 +16,7 @@
 #include <linux/mbus.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include "ahci.h"
 
@@ -122,10 +123,75 @@ static int ahci_mvebu_probe(struct platform_device *pdev)
 		ahci_mvebu_regret_option(hpriv);
 	}
 
-#ifdef CONFIG_CP110_SATA_ADDR_WA
-	of_property_read_u32(pdev->dev.of_node, "port_base", &hpriv->port_base);
-	of_property_read_u32(pdev->dev.of_node, "port_offset", &hpriv->port_offset);
-#endif
+	/* In A8k A0 AHCI unit the port register offsets are not
+	 * according to AHCI specification. We need a WA for a8k (cp110).
+	 */
+	if (of_device_is_compatible(pdev->dev.of_node,
+	    "marvell,armada-cp110-ahci")) {
+
+		struct device_node *node;
+		void __iomem *gwd_iidr2;
+		const unsigned int *reg;
+		phys_addr_t paddr;
+
+		/* Read the node which holds the "Global Watchdog Interface
+		 * Identification Register (GWD_IIDR2)" address - holds the revision.
+		 */
+		node = of_find_compatible_node(NULL, NULL,
+					       "marvell,ap806-rev-info");
+		if (!node) {
+			dev_err(&pdev->dev, "unable to read rev-info node\n");
+			of_node_put(node);
+			return -ENODEV;
+		}
+
+		/* Read the offset of the register */
+		reg = of_get_property(node, "reg", NULL);
+		if (!reg) {
+			dev_err(&pdev->dev, "unable to read reg property from rev-info node\n");
+			of_node_put(node);
+			return -ENODEV;
+		}
+
+		/* Translate the offset to phyisical address */
+		paddr = of_translate_address(node, reg);
+		if (paddr == OF_BAD_ADDR) {
+			dev_err(&pdev->dev, "of_translate_address failed\n");
+			of_node_put(node);
+			return -EINVAL;
+		}
+
+		gwd_iidr2 = ioremap(paddr, reg[1]);
+		if (!gwd_iidr2) {
+			dev_err(&pdev->dev, "rev-info ioremap() failed\n");
+			of_node_put(node);
+			return -EINVAL;
+		}
+
+#define GWD_IIDR2_REV_ID_OFFSET	12
+#define GWD_IIDR2_REV_ID_MASK	0xF
+#define APN806_REV_ID_A0	0
+
+		/* The workaround is required only for A0 revision.
+		 * read gwd_iidr2 register to determing the revision
+		 */
+		if (((readl(gwd_iidr2) >> GWD_IIDR2_REV_ID_OFFSET) &
+		    GWD_IIDR2_REV_ID_MASK) == APN806_REV_ID_A0) {
+
+			/* Read the correct port base and offset from the
+			 * device tree and set hpriv->a8k_a0_wa for future use.
+			 */
+			hpriv->a8k_a0_wa = 1;
+			of_property_read_u32(pdev->dev.of_node, "port_base",
+					     &hpriv->port_base);
+			of_property_read_u32(pdev->dev.of_node, "port_offset",
+					     &hpriv->port_offset);
+		}
+
+		/* Release resources */
+		iounmap(gwd_iidr2);
+		of_node_put(node);
+	}
 
 	rc = ahci_platform_init_host(pdev, hpriv, &ahci_mvebu_port_info,
 				     &ahci_platform_sht);
-- 
1.7.9.5


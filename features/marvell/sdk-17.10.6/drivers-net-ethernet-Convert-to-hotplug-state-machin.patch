From 339b9d941a4cb9782147b589cab04ca5ab9c400f Mon Sep 17 00:00:00 2001
From: MengLi <meng.li@windriver.com>
Date: Sat, 21 Jul 2018 17:01:09 +0800
Subject: [PATCH 1341/1345] drivers: net: ethernet: Convert to hotplug state
 machine
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In mainline kernel, cpu notify design had been removed and instead
by cpu hotplug state machine. upstream commit ID 984581728eb4
(“cpu/hotplug: Split out cpu down functions”) include this part
modification.

Therefore, it is need to install the callbacks via the state machine
and let the core invoke the callbacks when plug out cpu.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |    4 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |  146 ++++++++++++--------
 include/linux/cpuhotplug.h                         |    1 +
 3 files changed, 89 insertions(+), 62 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index 91bb30b..71baedd 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -576,7 +576,7 @@ struct mv_pp2x {
 
 	struct delayed_work stats_task;
 	struct workqueue_struct *workqueue;
-	struct notifier_block	cp_hotplug_nb;
+	struct hlist_node node_dead;
 };
 
 struct mv_pp2x_pcpu_stats {
@@ -686,7 +686,7 @@ struct mv_pp2x_port {
 	struct mv_pp2x_ptp_desc *ptp_desc;
 	struct mv_pp2x_cos cos_cfg;
 	struct mv_pp2x_rss rss_cfg;
-	struct notifier_block	port_hotplug_nb;
+	struct hlist_node node_online;
 	int use_interrupts;
 };
 
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 6bbab97..05f1510 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -96,6 +96,7 @@
 static u8 uc_filter_max = 4;
 static u16 stats_delay_msec = STATS_DELAY;
 static u16 stats_delay;
+static enum cpuhp_state online_hpstate;
 
 u32 debug_param;
 
@@ -4028,8 +4029,12 @@ int mv_pp2x_open(struct net_device *dev)
 	}
 
 	/* Only Mvpp22 support hot plug feature */
-	if (port->priv->pp2_version == PPV22  && !(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK)))
-		register_hotcpu_notifier(&port->port_hotplug_nb);
+	if (port->priv->pp2_version == PPV22  && !(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK))) {
+		err = cpuhp_state_add_instance_nocalls(online_hpstate,
+						   &port->node_online);
+		if (err)
+			goto err_free_irq;
+	}
 
 	/* In default link is down */
 	netif_carrier_off(port->dev);
@@ -4057,6 +4062,9 @@ int mv_pp2x_open(struct net_device *dev)
 	return 0;
 
 err_free_all:
+	cpuhp_state_remove_instance_nocalls(online_hpstate,
+						&port->node_online);
+err_free_irq:
 	mv_pp2x_cleanup_irqs(port);
 err_cleanup_txqs:
 	mv_pp2x_cleanup_txqs(port);
@@ -4081,7 +4089,8 @@ int mv_pp2x_stop(struct net_device *dev)
 	mv_pp2x_cleanup_irqs(port);
 
 	if (port->priv->pp2_version == PPV22)
-		unregister_hotcpu_notifier(&port->port_hotplug_nb);
+		cpuhp_state_remove_instance_nocalls(online_hpstate,
+						&port->node_online);
 
 	/* Cancel tx timers in case Tx done interrupts are disabled and if port is not in Netmap mode */
 	if (!(port->flags & MVPP2_F_IFCAP_NETMAP) && !port->priv->pp2xdata->interrupt_tx_done)  {
@@ -4934,48 +4943,50 @@ static void mv_pp2x_port_init_config(struct mv_pp2x_port *port)
 /* Routine called by port CPU hot plug notifier. If port up callback set irq affinity for private interrupts,
 *  unmask private interrupt, set packet coalescing and clear counters.
 */
-static int mv_pp2x_port_cpu_callback(struct notifier_block *nfb,
-				     unsigned long action, void *hcpu)
+static int mv_pp2x_cpu_online(unsigned int cpu, struct hlist_node *node)
 {
-	unsigned int cpu = (unsigned long)hcpu;
 	int qvec_id;
 	struct queue_vector *qvec;
 	cpumask_t cpus_mask;
-	struct mv_pp2x_port *port = container_of(nfb, struct mv_pp2x_port, port_hotplug_nb);
-	struct mv_pp2x_aggr_tx_queue *aggr_txq;
-	struct mv_pp2x_cp_pcpu *cp_pcpu;
+	struct mv_pp2x_port *port;
 
-	switch (action) {
-	case CPU_ONLINE:
-	case CPU_ONLINE_FROZEN:
-		cpumask_set_cpu(cpu, &cpus_mask);
-		for (qvec_id = 0; qvec_id < port->num_qvector; qvec_id++) {
-			qvec = &port->q_vector[qvec_id];
-			if (!qvec->irq)
-				continue;
-			if (qvec->qv_type == MVPP2_PRIVATE && QV_THR_2_CPU(qvec->sw_thread_id) == cpu) {
-				irq_set_affinity_hint(qvec->irq, cpumask_of(cpu));
-				on_each_cpu_mask(&cpus_mask, mv_pp2x_interrupts_unmask, port, 1);
-				if (port->priv->pp2_cfg.queue_mode ==
-					MVPP2_QDIST_MULTI_MODE)
-					irq_set_status_flags(qvec->irq,
-							     IRQ_NO_BALANCING);
-			}
+	port = hlist_entry_safe(node, struct mv_pp2x_port, node_online);
+
+	cpumask_set_cpu(cpu, &cpus_mask);
+	for (qvec_id = 0; qvec_id < port->num_qvector; qvec_id++) {
+		qvec = &port->q_vector[qvec_id];
+		if (!qvec->irq)
+			continue;
+		if (qvec->qv_type == MVPP2_PRIVATE && QV_THR_2_CPU(qvec->sw_thread_id) == cpu) {
+			irq_set_affinity_hint(qvec->irq, cpumask_of(cpu));
+			on_each_cpu_mask(&cpus_mask, mv_pp2x_interrupts_unmask, port, 1);
+			if (port->priv->pp2_cfg.queue_mode == MVPP2_QDIST_MULTI_MODE)
+				irq_set_status_flags(qvec->irq, IRQ_NO_BALANCING);
 		}
-		if (port->priv->pp2xdata->interrupt_tx_done)
-			on_each_cpu_mask(&cpus_mask, mv_pp2x_tx_done_pkts_coal_set, port, 1);
-		break;
-	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
-		cp_pcpu = per_cpu_ptr(port->priv->pcpu, cpu);
-		aggr_txq = &port->priv->aggr_txqs[cpu];
-		mv_pp2x_tx_timer_kill(cp_pcpu);
-		aggr_txq->hw_count += aggr_txq->sw_count;
-		mv_pp22_thread_write(&port->priv->hw, cpu, MVPP2_AGGR_TXQ_UPDATE_REG, aggr_txq->sw_count);
-		aggr_txq->sw_count = 0;
 	}
 
-	return NOTIFY_OK;
+	if (port->priv->pp2xdata->interrupt_tx_done)
+		on_each_cpu_mask(&cpus_mask, mv_pp2x_tx_done_pkts_coal_set, port, 1);
+
+	return 0;
+}
+
+static int mv_pp2x_cpu_down_prepare(unsigned int cpu, struct hlist_node *node)
+{
+	struct mv_pp2x_aggr_tx_queue *aggr_txq;
+	struct mv_pp2x_cp_pcpu *cp_pcpu;
+	struct mv_pp2x_port *port;
+
+	port = hlist_entry_safe(node, struct mv_pp2x_port, node_online);
+
+	cp_pcpu = per_cpu_ptr(port->priv->pcpu, cpu);
+	aggr_txq = &port->priv->aggr_txqs[cpu];
+	mv_pp2x_tx_timer_kill(cp_pcpu);
+	aggr_txq->hw_count += aggr_txq->sw_count;
+	mv_pp22_thread_write(&port->priv->hw, cpu, MVPP2_AGGR_TXQ_UPDATE_REG, aggr_txq->sw_count);
+	aggr_txq->sw_count = 0;
+
+	return 0;
 }
 
 /* Ports initialization */
@@ -5279,9 +5290,6 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 
 	mv_pp2x_port_irq_names_update(port);
 
-	if (priv->pp2_version == PPV22)
-		port->port_hotplug_nb.notifier_call = mv_pp2x_port_cpu_callback;
-
 	netdev_info(dev, "Using %s mac address %pM\n", mac_from, dev->dev_addr);
 
 	priv->port_list[priv->num_ports] = port;
@@ -5931,33 +5939,27 @@ void mv_pp22_set_net_comp(struct mv_pp2x *priv)
 }
 
 /* Routine called by CP CPU hot plug notifier. Callback reconfigure RSS RX flow hash indir'n table */
-static int mv_pp2x_cp_cpu_callback(struct notifier_block *nfb,
-				   unsigned long action, void *hcpu)
+static int mv_pp2x_cpu_dead(unsigned int cpu, struct hlist_node *node)
 {
-	struct mv_pp2x *priv = container_of(nfb, struct mv_pp2x, cp_hotplug_nb);
-	unsigned int cpu = (unsigned long)hcpu;
+	struct mv_pp2x *priv = hlist_entry_safe(node, struct mv_pp2x, node_dead);
 	int i;
 	struct mv_pp2x_port *port;
 
 	/* RSS rebalanced to equal */
 	mv_pp22_init_rxfhindir(priv);
 
-	switch (action) {
-	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
-		/* If default CPU is down, CPU0 will be default CPU */
-		for (i = 0; i < priv->num_ports; i++) {
-			port = priv->port_list[i];
-			if (port && (cpu == port->rss_cfg.dflt_cpu)) {
-				port->rss_cfg.dflt_cpu = 0;
-				if (port->rss_cfg.rss_en && netif_running(port->dev))
-					mv_pp22_rss_default_cpu_set(port,
-								    port->rss_cfg.dflt_cpu);
-			}
+	/* If default CPU is down, CPU0 will be default CPU */
+	for (i = 0; i < priv->num_ports; i++) {
+		port = priv->port_list[i];
+		if (port && (cpu == port->rss_cfg.dflt_cpu)) {
+			port->rss_cfg.dflt_cpu = 0;
+			if (port->rss_cfg.rss_en && netif_running(port->dev))
+				mv_pp22_rss_default_cpu_set(port,
+								port->rss_cfg.dflt_cpu);
 		}
 	}
 
-	return NOTIFY_OK;
+	return 0;
 }
 
 static int mv_pp2x_probe(struct platform_device *pdev)
@@ -6098,8 +6100,10 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 
 	/* Only Mvpp22 support hot plug feature */
 	if (priv->pp2_version == PPV22 && mv_pp2x_queue_mode == MVPP2_QDIST_MULTI_MODE) {
-		priv->cp_hotplug_nb.notifier_call = mv_pp2x_cp_cpu_callback;
-		register_hotcpu_notifier(&priv->cp_hotplug_nb);
+		err = cpuhp_state_add_instance_nocalls(CPUHP_NET_MVPP2_DEAD,
+						       &priv->node_dead);
+		if (err)
+			goto err_clk;
 	}
 
 	INIT_DELAYED_WORK(&priv->stats_task, mv_pp2x_get_device_stats);
@@ -6127,7 +6131,8 @@ static int mv_pp2x_remove(struct platform_device *pdev)
 	struct mv_pp2x_cp_pcpu *cp_pcpu;
 
 	if (priv->pp2_version == PPV22 && mv_pp2x_queue_mode == MVPP2_QDIST_MULTI_MODE)
-		unregister_hotcpu_notifier(&priv->cp_hotplug_nb);
+		cpuhp_state_remove_instance_nocalls(CPUHP_NET_MVPP2_DEAD,
+						&priv->node_dead);
 
 	cancel_delayed_work(&priv->stats_task);
 	flush_workqueue(priv->workqueue);
@@ -6372,14 +6377,35 @@ static int __init mpp2_module_init(void)
 	mv_pp2x_pools[MVPP2_BM_SWF_JUMBO_POOL].pkt_size =
 		MVPP2_BM_JUMBO_PKT_SIZE;
 
+	ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, "net/mvpp2:online",
+				      mv_pp2x_cpu_online,
+				      mv_pp2x_cpu_down_prepare);
+	if (ret < 0)
+		goto out;
+	online_hpstate = ret;
+	ret = cpuhp_setup_state_multi(CPUHP_NET_MVPP2_DEAD, "net/mvpp2:dead",
+				      NULL, mv_pp2x_cpu_dead);
+	if (ret)
+		goto err_dead;
+
 	ret = platform_driver_register(&mv_pp2x_driver);
+	if (ret)
+		goto err;
+	return 0;
 
+err:
+	cpuhp_remove_multi_state(CPUHP_NET_MVPP2_DEAD);
+err_dead:
+	cpuhp_remove_multi_state(online_hpstate);
+out:
 	return ret;
 }
 
 static void __exit mpp2_module_exit(void)
 {
 	platform_driver_unregister(&mv_pp2x_driver);
+	cpuhp_remove_multi_state(CPUHP_NET_MVPP2_DEAD);
+	cpuhp_remove_multi_state(online_hpstate);
 }
 
 module_init(mpp2_module_init);
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index 174decd..9b6ff61 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -21,6 +21,7 @@ enum cpuhp_state {
 	CPUHP_MM_VMSTAT_DEAD,
 	CPUHP_SOFTIRQ_DEAD,
 	CPUHP_NET_MVNETA_DEAD,
+	CPUHP_NET_MVPP2_DEAD,
 	CPUHP_CPUIDLE_DEAD,
 	CPUHP_ARM64_FPSIMD_DEAD,
 	CPUHP_ARM_OMAP_WAKE_DEAD,
-- 
1.7.9.5


From 40b2c30effd93eea8b9ff901bb337b03afd066a1 Mon Sep 17 00:00:00 2001
From: Igal Liberman <igall@marvell.com>
Date: Tue, 1 Nov 2016 17:23:39 +0200
Subject: [PATCH 0565/1345] phy: mvebu: add new infrastructure for comphy
 driver

commit  597b43770d01853da2a795aa20773db59fd80127 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This patch adds basic infrastructure for mvebu comphy driver.
No actual configuration is done in this patch, the configuration
will be added in following patches.

In addition, this patch adds 2 helper routines which will be used
for configuring the hardware:
	- reg_set
	- polling_with_timeout

Change-Id: I521d91f8e605db37e6e8447fd8903ffb952d27d7
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/33527
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/phy/Kconfig                        |   10 +
 drivers/phy/Makefile                       |    1 +
 drivers/phy/phy-mvebu-comphy.c             |  385 ++++++++++++++++++++++++++++
 include/dt-bindings/phy/phy-mvebu-comphy.h |   46 ++++
 4 files changed, 442 insertions(+)
 create mode 100644 drivers/phy/phy-mvebu-comphy.c
 create mode 100644 include/dt-bindings/phy/phy-mvebu-comphy.h

diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index afaf7b6..2b2327a 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -115,6 +115,16 @@ config PHY_PXA_28NM_USB2
 
 	  To compile this driver as a module, choose M here.
 
+config PHY_MVEBU_COMPHY
+	def_bool y
+	depends on ARCH_MVEBU
+	depends on OF
+	select GENERIC_PHY
+	help
+	  Enable this to support Marvell comphy driver. This driver is
+	  responsible for configuring all SerDes lanes according to the
+	  selected configuration.
+
 config PHY_MVEBU_SATA
 	def_bool y
 	depends on ARCH_DOVE || MACH_DOVE || MACH_KIRKWOOD
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index f8047b4..5c84220 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_PHY_EXYNOS_MIPI_VIDEO)	+= phy-exynos-mipi-video.o
 obj-$(CONFIG_PHY_LPC18XX_USB_OTG)	+= phy-lpc18xx-usb-otg.o
 obj-$(CONFIG_PHY_PXA_28NM_USB2)		+= phy-pxa-28nm-usb2.o
 obj-$(CONFIG_PHY_PXA_28NM_HSIC)		+= phy-pxa-28nm-hsic.o
+obj-$(CONFIG_PHY_MVEBU_COMPHY)		+= phy-mvebu-comphy.o
 obj-$(CONFIG_PHY_MVEBU_SATA)		+= phy-mvebu-sata.o
 obj-$(CONFIG_PHY_MIPHY28LP) 		+= phy-miphy28lp.o
 obj-$(CONFIG_PHY_RCAR_GEN2)		+= phy-rcar-gen2.o
diff --git a/drivers/phy/phy-mvebu-comphy.c b/drivers/phy/phy-mvebu-comphy.c
new file mode 100644
index 0000000..c71c311
--- /dev/null
+++ b/drivers/phy/phy-mvebu-comphy.c
@@ -0,0 +1,385 @@
+/*
+ * Marvell comphy driver
+ *
+ * Copyright (C) 2016 Marvell
+ *
+ * Igal Liberman <igall@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/phy/phy-mvebu-comphy.h>
+
+#define MVEBU_COMPHY_MAX_CNT	6
+#define MVEBU_COMPHY_FUNC_MAX	11
+
+#define to_mvebu_comphy_priv(lane) \
+	container_of((lane), struct mvebu_comphy_priv, lanes[(lane)->index])
+
+struct mvebu_comphy_priv {
+	struct device *dev;
+	void __iomem *comphy_regs;
+	void __iomem *comphy_pipe_regs;
+	spinlock_t lock;
+	const struct mvebu_comphy_soc_info *sinfo;
+	struct mvebu_comphy {
+		struct phy *phy;
+		int mode;
+		int index;
+	} lanes[MVEBU_COMPHY_MAX_CNT];
+};
+
+struct mvebu_comphy_soc_info {
+	int num_of_lanes;
+	int functions[MVEBU_COMPHY_MAX_CNT][MVEBU_COMPHY_FUNC_MAX];
+};
+
+/* For CP-110 there are 2 Selector registers "PHY Selectors"
+ * and "PIPE Selectors".
+ *	- PIPE selector include USB and PCIe options.
+ *	- PHY selector include the Ethernet and SATA options.
+ *	  every Ethernet option has different options,
+ *	  for example: serdes lane2 had option Eth_port_0 that include
+ *	  (SGMII0, XAUI0, RXAUI0, XFI, SFI)
+ */
+static const struct mvebu_comphy_soc_info cp110_comphy = {
+	.num_of_lanes = 6,
+	.functions = {
+		/* Lane 0 */
+		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1,
+		 COMPHY_SATA1, COMPHY_PCIE0},
+		/* Lane 1 */
+		{COMPHY_UNUSED, COMPHY_SGMII2, COMPHY_HS_SGMII2,
+		 COMPHY_SATA0, COMPHY_USB3H0, COMPHY_USB3D0, COMPHY_PCIE0},
+		/* Lane 2 */
+		{COMPHY_UNUSED, COMPHY_SGMII0, COMPHY_HS_SGMII0, COMPHY_RXAUI0,
+		 COMPHY_XFI, COMPHY_SFI, COMPHY_SATA0, COMPHY_USB3H0,
+		 COMPHY_PCIE0},
+		/* Lane 3 */
+		{COMPHY_UNUSED, COMPHY_SGMII1, COMPHY_HS_SGMII1, COMPHY_RXAUI1,
+		 COMPHY_SATA1, COMPHY_USB3H1, COMPHY_PCIE0},
+		/* Lane 4 */
+		{COMPHY_UNUSED, COMPHY_SGMII0, COMPHY_HS_SGMII0, COMPHY_SGMII1,
+		 COMPHY_HS_SGMII1, COMPHY_RXAUI0, COMPHY_XFI, COMPHY_SFI,
+		 COMPHY_USB3H1, COMPHY_USB3D0, COMPHY_PCIE1},
+		/* Lane 5 */
+		{COMPHY_UNUSED, COMPHY_RXAUI1, COMPHY_SGMII2, COMPHY_HS_SGMII2,
+		 COMPHY_SATA1, COMPHY_PCIE2},
+	},
+};
+
+static void __maybe_unused reg_set(void __iomem *addr, u32 data, u32 mask)
+{
+	u32 reg_data;
+
+	reg_data = readl(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writel(reg_data, addr);
+}
+
+u32 __maybe_unused polling_with_timeout(void __iomem *addr, u32 val, u32 mask,
+					unsigned long usec_timout)
+{
+	u32 data;
+
+	do {
+		udelay(1);
+		data = readl(addr) & mask;
+	} while (data != val  && --usec_timout > 0);
+
+	if (usec_timout == 0)
+		return data;
+
+	return 0;
+}
+
+static int mvebu_comphy_sata_power_on(struct mvebu_comphy_priv *priv,
+				      struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "SATA mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_comphy_sgmii_power_on(struct mvebu_comphy_priv *priv,
+				       struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "SGMII mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_comphy_usb3_power_on(struct mvebu_comphy_priv *priv,
+				      struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "USB mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_comphy_pcie_power_on(struct mvebu_comphy_priv *priv,
+				      struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "PCIE mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_comphy_rxaui_power_on(struct mvebu_comphy_priv *priv,
+				       struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "RXAUI mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_comphy_xfi_power_on(struct mvebu_comphy_priv *priv,
+				     struct mvebu_comphy *comphy)
+{
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	dev_err(priv->dev, "XFI/SFI mode is not implemented\n");
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return -ENOTSUPP;
+}
+
+static int mvebu_comphy_power_on(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+	int err = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	switch (mode) {
+	case(COMPHY_SATA_MODE):
+		err = mvebu_comphy_sata_power_on(priv, comphy);
+		break;
+
+	case(COMPHY_SGMII_MODE):
+	case(COMPHY_HS_SGMII_MODE):
+		err = mvebu_comphy_sgmii_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_USB3H_MODE):
+	case (COMPHY_USB3D_MODE):
+		err = mvebu_comphy_usb3_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_PCIE_MODE):
+		err = mvebu_comphy_pcie_power_on(priv, comphy);
+		break;
+
+	case (COMPHY_RXAUI_MODE):
+		err = mvebu_comphy_rxaui_power_on(priv, comphy);
+		break;
+	/* From comphy perspective, XFI and SFI are the same */
+	case (COMPHY_XFI_MODE):
+	case (COMPHY_SFI_MODE):
+		err = mvebu_comphy_xfi_power_on(priv, comphy);
+		break;
+
+	default:
+		dev_err(priv->dev, "comphy%d: unsupported comphy mode\n",
+			comphy->index);
+		err = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return err;
+}
+
+static int mvebu_comphy_power_off(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	dev_dbg(priv->dev, "power off is not implemented\n");
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return 0;
+}
+
+static struct phy_ops mvebu_comphy_ops = {
+	.power_on	= mvebu_comphy_power_on,
+	.power_off	= mvebu_comphy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static const struct of_device_id mvebu_comphy_of_match[] = {
+	{ .compatible = "marvell,cp110-comphy", .data = &cp110_comphy },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, mvebu_comphy_of_match);
+
+/**
+ * mvebu_comphy_of_xlate
+ *
+ * @dev - pointer to the device structure
+ * @args - pointer to the lane information (id and mode from the device-tree).
+ *
+ * This callback is registered during probe and called by the generic phy
+ * infrastructure when phy consumer calls 'devm_of_phy_get'.
+ * This function has 2 purposes:
+ *	- Check if the requested configuration is valid.
+ *	- Update comphy internal structure with the configuration for the
+ *	  specific lane (by default, all lanes set to 'COMPHY_UNUSED'.
+ *
+ * Return: pointer to the associated phy (on success), error code otherwise
+ */
+static struct phy *mvebu_comphy_of_xlate(struct device *dev,
+					 struct of_phandle_args *args)
+{
+	struct mvebu_comphy_priv *priv = dev_get_drvdata(dev);
+	int lane = args->args[0];
+	int mode = args->args[1];
+	int i;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	if (lane >= (int)priv->sinfo->num_of_lanes) {
+		dev_err(dev, "Wrong lane number %d for PHY, max is %d\n",
+			lane, priv->sinfo->num_of_lanes);
+		return ERR_PTR(-ENODEV);
+	}
+
+	for (i = 0; i < MVEBU_COMPHY_FUNC_MAX; i++)
+		if (priv->sinfo->functions[lane][i] == mode)
+			break;
+
+	if (i == MVEBU_COMPHY_FUNC_MAX) {
+		dev_err(dev, "Wrong mode 0x%x for COMPHY\n", mode);
+		return ERR_PTR(-ENODEV);
+	}
+
+	priv->lanes[lane].mode = mode;
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return priv->lanes[lane].phy;
+}
+
+static int mvebu_comphy_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	struct mvebu_comphy_priv *priv;
+	struct resource *res;
+	struct phy_provider *phy_provider;
+	const struct mvebu_comphy_soc_info *sinfo;
+	int i;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	match = of_match_device(mvebu_comphy_of_match, &pdev->dev);
+	sinfo = match->data;
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "comphy");
+	priv->comphy_regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->comphy_regs))
+		return PTR_ERR(priv->comphy_regs);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "serdes");
+	priv->comphy_pipe_regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->comphy_pipe_regs))
+		return PTR_ERR(priv->comphy_pipe_regs);
+
+	priv->sinfo = sinfo;
+	priv->dev = &pdev->dev;
+	spin_lock_init(&priv->lock);
+
+	for (i = 0; i < sinfo->num_of_lanes; i++) {
+		struct phy *phy;
+
+		phy = devm_phy_create(&pdev->dev, NULL, &mvebu_comphy_ops);
+		if (IS_ERR(phy)) {
+			dev_err(&pdev->dev, "failed to create PHY\n");
+			return PTR_ERR(phy);
+		}
+
+		/* In this stage we have no information regarding comphy
+		 * configuration so we set all comphys to UNUSED.
+		 * Later, when all interfaces are probed, each interface
+		 * is responsible of calling to power_on call back for
+		 * comphy configuration.
+		 */
+		priv->lanes[i].phy = phy;
+		priv->lanes[i].index = i;
+		priv->lanes[i].mode = COMPHY_UNUSED;
+		phy_set_drvdata(phy, &priv->lanes[i]);
+
+		mvebu_comphy_power_off(phy);
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	phy_provider = devm_of_phy_provider_register(&pdev->dev,
+						     mvebu_comphy_of_xlate);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static struct platform_driver mvebu_comphy_driver = {
+	.probe	= mvebu_comphy_probe,
+	.driver	= {
+		.name		= "phy-mvebu-comphy",
+		.owner		= THIS_MODULE,
+		.of_match_table	= mvebu_comphy_of_match,
+	 },
+};
+module_platform_driver(mvebu_comphy_driver);
+
+MODULE_AUTHOR("Igal Liberman <igall@marvell.com>");
+MODULE_DESCRIPTION("Marvell EBU COMPHY driver");
+MODULE_LICENSE("GPL");
+
diff --git a/include/dt-bindings/phy/phy-mvebu-comphy.h b/include/dt-bindings/phy/phy-mvebu-comphy.h
new file mode 100644
index 0000000..62bdf50
--- /dev/null
+++ b/include/dt-bindings/phy/phy-mvebu-comphy.h
@@ -0,0 +1,46 @@
+#ifndef _DT_BINDINGS_PHY_MVEBU_COMPHY
+#define _DT_BINDINGS_PHY_MVEBU_COMPHY
+
+/* A lane is described by 2 fields:
+ *	- 8 lsb represent the index of the lane
+ *	- 24 msb represent the mode
+ */
+#define COMPHY_DEF(x, y)	(((x) << 8) | (y))
+/* Macro the extract the mode from lane description */
+#define COMPHY_GET_MODE(x)	((x & 0xFFFFFF00) >> 8)
+/* Macro the extract the id from lane description */
+#define COMPHY_GET_ID(x)	(x & 0xff)
+
+#define	COMPHY_UNUSED		COMPHY_DEF(0xff, 0xff)
+#define COMPHY_SATA0		COMPHY_DEF(0x1,  0x0)
+#define COMPHY_SATA1		COMPHY_DEF(0x1,  0x1)
+#define COMPHY_SGMII0		COMPHY_DEF(0x2,  0x0)	/* SGMII 1G */
+#define COMPHY_SGMII1		COMPHY_DEF(0x2,  0x1)	/* SGMII 1G */
+#define COMPHY_SGMII2		COMPHY_DEF(0x2,  0x2)	/* SGMII 1G */
+#define COMPHY_HS_SGMII0	COMPHY_DEF(0x3,  0x0)	/* SGMII 2.5G */
+#define COMPHY_HS_SGMII1	COMPHY_DEF(0x3,  0x1)	/* SGMII 2.5G */
+#define COMPHY_HS_SGMII2	COMPHY_DEF(0x3,  0x2)	/* SGMII 2.5G */
+#define COMPHY_USB3H0		COMPHY_DEF(0x4,  0x0)
+#define COMPHY_USB3H1		COMPHY_DEF(0x4,  0x1)
+#define COMPHY_USB3D0		COMPHY_DEF(0x5,  0x0)
+#define COMPHY_PCIE0		COMPHY_DEF(0x6,  0x0)
+#define COMPHY_PCIE1		COMPHY_DEF(0x6,  0x1)
+#define COMPHY_PCIE2		COMPHY_DEF(0x6,  0x2)
+#define COMPHY_PCIE3		COMPHY_DEF(0x6,  0x3)
+#define COMPHY_RXAUI0		COMPHY_DEF(0x7,  0x0)
+#define COMPHY_RXAUI1		COMPHY_DEF(0x7,  0x1)
+#define COMPHY_XFI		COMPHY_DEF(0x8,  0x0)
+#define COMPHY_SFI		COMPHY_DEF(0x9,  0x0)
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+
+#endif /* _DT_BINDINGS_COMPHY_MVEBU_COMPHY */
+
-- 
1.7.9.5


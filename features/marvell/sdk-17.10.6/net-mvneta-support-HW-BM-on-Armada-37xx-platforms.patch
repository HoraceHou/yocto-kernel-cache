From ec7e297075a3f9ffec731c5b4c60c8725c2563a0 Mon Sep 17 00:00:00 2001
From: Yelena Krivosheev <yelena@marvell.com>
Date: Wed, 15 Feb 2017 14:26:42 +0200
Subject: [PATCH 0840/1345] net: mvneta: support HW BM on Armada 37xx
 platforms

commit  9f43e5649a308c4a1f3059c21ffe0435bb40c863 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

NETA hw unit support up to 127 bytes RX Packet Offset.
In ARMv8 systems NET_SKB_PAD is 128 bytes.
In order to support it the rx correction mechanism was
implemented and used for all NETA platforms.

Change-Id: I50fd47f96bfde52f9831deab8b4e040e2f48e663
Signed-off-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37194
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvneta.c    |    9 ++----
 drivers/net/ethernet/marvell/mvneta_bm.c |   49 +++++++++++++++++++++---------
 drivers/net/ethernet/marvell/mvneta_bm.h |    8 +++++
 3 files changed, 45 insertions(+), 21 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 1e73e8d..087317a 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -311,12 +311,6 @@ enum mvneta_port_type {
 /* descriptor aligned size */
 #define MVNETA_DESC_ALIGNED_SIZE	32
 
-/* Number of bytes to be taken into account by HW when putting incoming data
- * to the buffers. It is needed in case NET_SKB_PAD exceeds maximum packet
- * offset supported in MVNETA_RXQ_CONFIG_REG(q) registers.
- */
-#define MVNETA_RX_PKT_OFFSET_CORRECTION		64
-
 #define MVNETA_RX_PKT_SIZE(mtu) \
 	ALIGN((mtu) + MVNETA_MH_SIZE + MVNETA_VLAN_TAG_LEN + \
 	      ETH_HLEN + ETH_FCS_LEN,			     \
@@ -984,6 +978,7 @@ static inline void mvneta_bm_pool_bufsize_set(struct mvneta_port *pp,
 {
 	u32 val;
 
+	buf_size -= pp->rx_offset_correction;
 	if (!IS_ALIGNED(buf_size, 8)) {
 		dev_warn(pp->dev->dev.parent,
 			 "illegal buf_size value %d, round to %d\n",
@@ -2379,7 +2374,7 @@ static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
 		/* After refill old buffer has to be unmapped regardless
 		 * the skb is successfully built or not.
 		 */
-		dma_unmap_single(&pp->bm_priv->pdev->dev, phys_addr,
+		dma_unmap_single(&pp->bm_priv->pdev->dev, phys_addr - pp->rx_offset_correction,
 				 bm_pool->buf_size, DMA_FROM_DEVICE);
 		if (!skb)
 			goto err_drop_frame;
diff --git a/drivers/net/ethernet/marvell/mvneta_bm.c b/drivers/net/ethernet/marvell/mvneta_bm.c
index 466939f..82b3bad 100644
--- a/drivers/net/ethernet/marvell/mvneta_bm.c
+++ b/drivers/net/ethernet/marvell/mvneta_bm.c
@@ -98,14 +98,18 @@ int mvneta_bm_construct(struct hwbm_pool *hwbm_pool, void *buf)
 
 	/* In order to update buf_cookie field of RX descriptor properly,
 	 * BM hardware expects buf virtual address to be placed in the
-	 * first four bytes of mapped buffer.
+	 * first four bytes of corrected mapped buffer.
 	 */
-	*(u32 *)buf = (u32)buf;
+	u8 *tmp = (u8 *)buf + priv->rx_offset_correction;
+	*(u32 *)tmp = (u32)((uintptr_t)buf & 0xffffffff);
+
 	phys_addr = dma_map_single(&priv->pdev->dev, buf, bm_pool->buf_size,
 				   DMA_FROM_DEVICE);
 	if (unlikely(dma_mapping_error(&priv->pdev->dev, phys_addr)))
 		return -ENOMEM;
 
+	phys_addr += priv->rx_offset_correction;
+
 	mvneta_bm_pool_put_bp(priv, bm_pool, phys_addr);
 	return 0;
 }
@@ -115,9 +119,11 @@ int mvneta_bm_construct(struct hwbm_pool *hwbm_pool, void *buf)
 static int mvneta_bm_pool_create(struct mvneta_bm *priv,
 				 struct mvneta_bm_pool *bm_pool)
 {
+	const struct mbus_dram_target_info *dram_target_info;
 	struct platform_device *pdev = priv->pdev;
 	u8 target_id, attr;
-	int size_bytes, err;
+	int size_bytes, i;
+
 	size_bytes = sizeof(u32) * bm_pool->hwbm_pool.size;
 	bm_pool->virt_addr = dma_alloc_coherent(&pdev->dev, size_bytes,
 						&bm_pool->phys_addr,
@@ -125,7 +131,7 @@ static int mvneta_bm_pool_create(struct mvneta_bm *priv,
 	if (!bm_pool->virt_addr)
 		return -ENOMEM;
 
-	if (!IS_ALIGNED((u32)bm_pool->virt_addr, MVNETA_BM_POOL_PTR_ALIGN)) {
+	if (!IS_ALIGNED((uintptr_t)bm_pool->virt_addr, MVNETA_BM_POOL_PTR_ALIGN)) {
 		dma_free_coherent(&pdev->dev, size_bytes, bm_pool->virt_addr,
 				  bm_pool->phys_addr);
 		dev_err(&pdev->dev, "BM pool %d is not %d bytes aligned\n",
@@ -133,19 +139,26 @@ static int mvneta_bm_pool_create(struct mvneta_bm *priv,
 		return -ENOMEM;
 	}
 
-	err = mvebu_mbus_get_dram_win_info(bm_pool->phys_addr, &target_id,
-					   &attr);
-	if (err < 0) {
-		dma_free_coherent(&pdev->dev, size_bytes, bm_pool->virt_addr,
-				  bm_pool->phys_addr);
-		return err;
+	dram_target_info = mv_mbus_dram_info();
+	if (dram_target_info) {
+		target_id = dram_target_info->mbus_dram_target_id;
+		attr = 0;
+		/* Try to find matching DRAM window for buffer phyaddr */
+		for (i = 0; i < dram_target_info->num_cs; i++) {
+			const struct mbus_dram_window *cs = dram_target_info->cs + i;
+
+			if ((cs->base <= bm_pool->phys_addr) &&
+			    (bm_pool->phys_addr <= (cs->base + cs->size - 1))) {
+				attr = cs->mbus_attr;
+				break;
+			}
+		}
+		mvneta_bm_pool_target_set(priv, bm_pool->id, target_id, attr);
 	}
 
 	/* Set pool address */
-	mvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(bm_pool->id),
-			bm_pool->phys_addr);
+	mvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(bm_pool->id), bm_pool->phys_addr);
 
-	mvneta_bm_pool_target_set(priv, bm_pool->id, target_id,  attr);
 	mvneta_bm_pool_enable(priv, bm_pool->id);
 
 	return 0;
@@ -374,8 +387,10 @@ static int mvneta_bm_get_sram(struct device_node *dn,
 			      struct mvneta_bm *priv)
 {
 	priv->bppi_pool = of_gen_pool_get(dn, "internal-mem", 0);
-	if (!priv->bppi_pool)
+	if (!priv->bppi_pool) {
+		pr_err("%s:: no internal-mem node found\n", __func__);
 		return -ENOMEM;
+	}
 
 	priv->bppi_virt_addr = gen_pool_dma_alloc(priv->bppi_pool,
 						  MVNETA_BM_BPPI_SIZE,
@@ -430,6 +445,12 @@ static int mvneta_bm_probe(struct platform_device *pdev)
 		goto err_sram;
 	}
 
+	/* HW support packet headroom up to 127 bytes.
+	 * MVNETA_RX_PKT_OFFSET_CORRECTION (64) defines maximum headroom size supported by driver.
+	 * rx_offset_correction calculated to meet requirement above.
+	 */
+	priv->rx_offset_correction = max(0, NET_SKB_PAD - MVNETA_RX_PKT_OFFSET_CORRECTION);
+
 	dn->data = priv;
 	platform_set_drvdata(pdev, priv);
 
diff --git a/drivers/net/ethernet/marvell/mvneta_bm.h b/drivers/net/ethernet/marvell/mvneta_bm.h
index a32de43..a1c3a74 100644
--- a/drivers/net/ethernet/marvell/mvneta_bm.h
+++ b/drivers/net/ethernet/marvell/mvneta_bm.h
@@ -13,6 +13,12 @@
 #ifndef _MVNETA_BM_H_
 #define _MVNETA_BM_H_
 
+/* Number of bytes to be taken into account by HW when putting incoming data
+ * to the buffers. It is needed in case NET_SKB_PAD exceeds maximum packet
+ * offset supported in MVNETA_RXQ_CONFIG_REG(q) registers.
+ */
+#define MVNETA_RX_PKT_OFFSET_CORRECTION		64
+
 /* BM Configuration Register */
 #define MVNETA_BM_CONFIG_REG			0x0
 #define    MVNETA_BM_STATUS_MASK		0x30
@@ -96,6 +102,7 @@ struct mvneta_bm {
 	void __iomem *reg_base;
 	struct clk *clk;
 	struct platform_device *pdev;
+	u16 rx_offset_correction;
 
 	struct gen_pool *bppi_pool;
 	/* BPPI virtual base address */
@@ -120,6 +127,7 @@ struct mvneta_bm_pool {
 
 	/* BPPE virtual base address */
 	u32 *virt_addr;
+
 	/* BPPE physical base address */
 	dma_addr_t phys_addr;
 
-- 
1.7.9.5


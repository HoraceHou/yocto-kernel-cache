From 3b4a00f17bf397a87d600de255b326919cb77558 Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Sun, 13 Mar 2016 16:16:21 +0200
Subject: [PATCH 0130/1345] fix: coherency: Use cacheable page allocations for
 I/O buffers

commit  8ac0bd95cf739bf0016a6aff985835124713e245 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

ARM PL-310 L2 relies on consistent cacheable attributes.
When IOCC is enabled, all the transactions arriving from the I/Os through
the ACP port are marked with cacheable attributes.
In order to comply with the L2 restriction, The CPU must use matching
cacheable attributes.

This patch updates mvebu_hwcc_dma_ops function pointers to use coherent
dma allocations.
This change makes the buffers that are allocated for I/Os cacheable.

Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Change-Id: I6ecefbecbcfe4b6bc1fb6f4ddb62f1614310d3c9
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/28263
Reviewed-by: Lior Amsalem <alior@marvell.com>
Tested-by: Lior Amsalem <alior@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/include/asm/dma-mapping.h |    6 ++++++
 arch/arm/mach-mvebu/coherency.c    |    8 ++++----
 arch/arm/mm/dma-mapping.c          |   33 +++++++++++++--------------------
 3 files changed, 23 insertions(+), 24 deletions(-)

diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index 680d3f3..7e79a76 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -159,6 +159,9 @@ static inline void dma_mark_clean(void *addr, size_t size) { }
 extern void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 			   gfp_t gfp, unsigned long attrs);
 
+extern void *arm_coherent_dma_alloc(struct device *dev, size_t size,
+				    dma_addr_t *handle, gfp_t gfp, unsigned long attrs);
+
 /**
  * arm_dma_free - free memory allocated by arm_dma_alloc
  * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
@@ -176,6 +179,9 @@ extern void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 extern void arm_dma_free(struct device *dev, size_t size, void *cpu_addr,
 			 dma_addr_t handle, unsigned long attrs);
 
+extern void arm_coherent_dma_free(struct device *dev, size_t size, void *cpu_addr,
+				  dma_addr_t handle, unsigned long attrs);
+
 /**
  * arm_dma_mmap - map a coherent DMA allocation into user space
  * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index c7cc119..a617364 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -125,9 +125,9 @@ static void mvebu_hwcc_dma_sync(struct device *dev, dma_addr_t dma_handle,
 		mvebu_hwcc_sync_io_barrier();
 }
 
-static const struct dma_map_ops mvebu_hwcc_dma_ops = {
-	.alloc			= arm_dma_alloc,
-	.free			= arm_dma_free,
+static struct dma_map_ops mvebu_hwcc_dma_ops = {
+	.alloc			= arm_coherent_dma_alloc,
+	.free			= arm_coherent_dma_free,
 	.mmap			= arm_dma_mmap,
 	.map_page		= mvebu_hwcc_dma_map_page,
 	.unmap_page		= mvebu_hwcc_dma_unmap_page,
@@ -138,7 +138,7 @@ static void mvebu_hwcc_dma_sync(struct device *dev, dma_addr_t dma_handle,
 	.sync_single_for_device	= mvebu_hwcc_dma_sync,
 	.sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
 	.sync_sg_for_device	= arm_dma_sync_sg_for_device,
-	.set_dma_mask	= arm_dma_set_mask,
+	.set_dma_mask		= arm_dma_set_mask,
 };
 
 static int mvebu_hwcc_notifier(struct notifier_block *nb,
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index bd83c53..f2f43ba 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -196,24 +196,6 @@ static void arm_dma_sync_single_for_device(struct device *dev,
 };
 EXPORT_SYMBOL(arm_dma_ops);
 
-static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
-	dma_addr_t *handle, gfp_t gfp, unsigned long attrs);
-static void arm_coherent_dma_free(struct device *dev, size_t size, void *cpu_addr,
-				  dma_addr_t handle, unsigned long attrs);
-static int arm_coherent_dma_mmap(struct device *dev, struct vm_area_struct *vma,
-		 void *cpu_addr, dma_addr_t dma_addr, size_t size,
-		 unsigned long attrs);
-
-const struct dma_map_ops arm_coherent_dma_ops = {
-	.alloc			= arm_coherent_dma_alloc,
-	.free			= arm_coherent_dma_free,
-	.mmap			= arm_coherent_dma_mmap,
-	.get_sgtable		= arm_dma_get_sgtable,
-	.map_page		= arm_coherent_dma_map_page,
-	.map_sg			= arm_dma_map_sg,
-};
-EXPORT_SYMBOL(arm_coherent_dma_ops);
-
 static int __dma_supported(struct device *dev, u64 mask, bool warn)
 {
 	unsigned long max_dma_pfn;
@@ -843,7 +825,7 @@ void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 			   attrs, __builtin_return_address(0));
 }
 
-static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
+void *arm_coherent_dma_alloc(struct device *dev, size_t size,
 	dma_addr_t *handle, gfp_t gfp, unsigned long attrs)
 {
 	return __dma_alloc(dev, size, handle, gfp, PAGE_KERNEL, true,
@@ -929,7 +911,7 @@ void arm_dma_free(struct device *dev, size_t size, void *cpu_addr,
 	__arm_dma_free(dev, size, cpu_addr, handle, attrs, false);
 }
 
-static void arm_coherent_dma_free(struct device *dev, size_t size, void *cpu_addr,
+void arm_coherent_dma_free(struct device *dev, size_t size, void *cpu_addr,
 				  dma_addr_t handle, unsigned long attrs)
 {
 	__arm_dma_free(dev, size, cpu_addr, handle, attrs, true);
@@ -2392,6 +2374,17 @@ static void arm_teardown_iommu_dma_ops(struct device *dev) { }
 
 #endif	/* CONFIG_ARM_DMA_USE_IOMMU */
 
+struct dma_map_ops arm_coherent_dma_ops = {
+	.alloc		= arm_coherent_dma_alloc,
+	.free		= arm_coherent_dma_free,
+	.mmap		= arm_coherent_dma_mmap,
+	.get_sgtable	= arm_dma_get_sgtable,
+	.map_page	= arm_coherent_dma_map_page,
+	.map_sg		= arm_dma_map_sg,
+	.set_dma_mask	= arm_dma_set_mask,
+};
+EXPORT_SYMBOL(arm_coherent_dma_ops);
+
 static const struct dma_map_ops *arm_get_dma_map_ops(bool coherent)
 {
 	return coherent ? &arm_coherent_dma_ops : &arm_dma_ops;
-- 
1.7.9.5


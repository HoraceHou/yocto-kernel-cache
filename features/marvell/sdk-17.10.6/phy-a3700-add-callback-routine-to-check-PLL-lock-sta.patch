From fe8f0b2e9590f116546a8512875b4b7955177aa4 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Thu, 16 Mar 2017 22:44:28 +0800
Subject: [PATCH 0861/1345] phy: a3700: add callback routine to check PLL lock
 state

commit  6fd2d23e10f8e8cc1df1bfdd2a3a78b49d8bb1a2 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This patch implements the callback to get PLL lock state,
which will be used by the driver such as AHCI.

Change-Id: I3463d08a839841ed552739de06649381b5227bc7
Signed-off-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37524
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/phy/phy-comphy-a3700.c |   77 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 77 insertions(+)

diff --git a/drivers/phy/phy-comphy-a3700.c b/drivers/phy/phy-comphy-a3700.c
index 857b1ed..1d26afd 100644
--- a/drivers/phy/phy-comphy-a3700.c
+++ b/drivers/phy/phy-comphy-a3700.c
@@ -813,11 +813,88 @@ static int mvebu_a3700_comphy_power_off(struct phy *phy)
 	return 0;
 }
 
+static int mvebu_a3700_comphy_sata_is_pll_locked(struct phy *phy)
+{
+	u32 data;
+	void __iomem *comphy_indir_regs;
+	struct resource *res;
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	struct platform_device *pdev = container_of(priv->dev, struct platform_device, dev);
+	int ret = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	/* Get the indirect access register resource and map */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "indirect");
+	if (res) {
+		comphy_indir_regs = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(comphy_indir_regs))
+			return PTR_ERR(comphy_indir_regs);
+	} else {
+		dev_err(priv->dev, "no inirect register resource\n");
+		return -ENOTSUPP;
+	}
+
+	/* Polling status */
+	writel(COMPHY_LOOPBACK_REG0 + SATAPHY_LANE2_REG_BASE_OFFSET,
+	       comphy_indir_regs + COMPHY_LANE2_INDIR_ADDR_OFFSET);
+	data = polling_with_timeout(comphy_indir_regs + COMPHY_LANE2_INDIR_DATA_OFFSET,
+				    PLL_READY_TX_BIT,
+				    PLL_READY_TX_BIT,
+				    A3700_COMPHY_PLL_LOCK_TIMEOUT,
+				    REG_32BIT);
+
+	if (data != 0) {
+		dev_err(priv->dev, "TX PLL is not locked\n");
+		ret = -ETIMEDOUT;
+	}
+
+	/* Unmap resource */
+	devm_iounmap(&pdev->dev, comphy_indir_regs);
+	devm_release_mem_region(&pdev->dev, res->start, resource_size(res));
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return ret;
+}
+
+static int mvebu_a3700_comphy_is_pll_locked(struct phy *phy)
+{
+	struct mvebu_comphy *comphy = phy_get_drvdata(phy);
+	struct mvebu_comphy_priv *priv = to_mvebu_comphy_priv(comphy);
+	int mode = COMPHY_GET_MODE(priv->lanes[comphy->index].mode);
+	int ret = 0;
+
+	dev_dbg(priv->dev, "%s: Enter\n", __func__);
+
+	spin_lock(&priv->lock);
+
+	switch (mode) {
+	case(COMPHY_SATA_MODE):
+		ret = mvebu_a3700_comphy_sata_is_pll_locked(phy);
+		break;
+
+	default:
+		dev_err(priv->dev, "comphy%d: unsupported comphy mode to get PLL lock state\n",
+			comphy->index);
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&priv->lock);
+
+	dev_dbg(priv->dev, "%s: Exit\n", __func__);
+
+	return ret;
+}
+
 static struct phy_ops a3700_comphy_ops = {
 	.power_on	= mvebu_a3700_comphy_power_on,
 	.power_off	= mvebu_a3700_comphy_power_off,
 	.set_mode	= mvebu_comphy_set_mode,
 	.get_mode	= mvebu_comphy_get_mode,
+	.is_pll_locked  = mvebu_a3700_comphy_is_pll_locked,
 	.owner		= THIS_MODULE,
 };
 
-- 
1.7.9.5


From 8ead531a368d685fc059cc1d9041e3c920ac12c8 Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Wed, 11 Jan 2017 23:41:39 +0800
Subject: [PATCH 0738/1345] uart: a3700: add separate tx and rx interrupt
 support

commit  3680c7d8608ad86d78bb0db40f337e226d8039aa from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- Armada3700 support either the summary interrupt or
  separate rx and tx interrupts. The existing uart driver
  just used the summary interrupt for the primary uart port.
  But the secondary uart only supports the separate rx and
  tx interrupt.
- This patch allows to use the separate rx and tx interrupt
  for all uart ports by device-tree. It added the support to
  parse the irq base according to irq name. If "irq-sum" is
  present in device-tree, the driver will use the summary
  interrupts. If not, both "irq-rx" and "irq-tx" should be
  supplied.

Change-Id: I0b6e93edbf6cd6ff214880ae0ba705f9abd6890d
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35471
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/serial/mvebu-uart.txt      |    6 +-
 arch/arm64/boot/dts/marvell/armada-37xx.dtsi       |    1 +
 drivers/tty/serial/mvebu-uart.c                    |   96 +++++++++++++++++---
 3 files changed, 90 insertions(+), 13 deletions(-)

diff --git a/Documentation/devicetree/bindings/serial/mvebu-uart.txt b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
index 849d9a4..a40beed 100644
--- a/Documentation/devicetree/bindings/serial/mvebu-uart.txt
+++ b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
@@ -9,10 +9,14 @@ Example:
 	serial@12000 {
 		compatible = "marvell,armada-3700-uart";
 		reg = <0x12000 0x200>;
-		interrupts = <43>;
+		interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_sum";
 	};
 	serial@12200 {
 		compatible = "marvell,armada-3700-uart-ext";
 		reg = <0x12200 0x30>,
+		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
+		             <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_rx", "irq_tx";
 		status = "disabled";
 	};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
index 7c8122b..925e631 100644
--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
@@ -132,6 +132,7 @@
 				compatible = "marvell,armada-3700-uart";
 				reg = <0x12000 0x200>;
 				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "irq_sum";
 				status = "disabled";
 			};
 
diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index 1222e9f..9e110de 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -160,6 +160,14 @@ struct mvebu_uart_data {
 
 	struct {
 		unsigned int ctrl_reg;
+		/* Uart summary interrupt includes the TX and RX interrupts
+		 * if the uart port uses summary interrupt, TX/RX interrupts
+		 * are not needed any more. Otherwise if the uart port doen't
+		 * use summary irq, TX/RX interrupts need to be handled separately.
+		 */
+		int irq_sum;
+		int irq_rx;
+		int irq_tx;
 	} intr;
 };
 
@@ -420,10 +428,62 @@ static irqreturn_t mvebu_uart_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int mvebu_uart_startup(struct uart_port *port)
+static irqreturn_t mvebu_uart_rx_isr(int irq, void *dev_id)
+{
+	struct uart_port *port = (struct uart_port *)dev_id;
+	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
+	unsigned int st = readl(port->membase + REG_STAT(uart_data));
+	unsigned int stat_bit_rx_rdy = uart_data->reg_bits.stat_rx_rdy(uart_data);
+
+	if (st & (stat_bit_rx_rdy | STAT_OVR_ERR | STAT_FRM_ERR | STAT_BRK_DET))
+		mvebu_uart_rx_chars(port, st);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mvebu_uart_tx_isr(int irq, void *dev_id)
+{
+	struct uart_port *port = (struct uart_port *)dev_id;
+	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
+	unsigned int st = readl(port->membase + REG_STAT(uart_data));
+	unsigned int stat_bit_tx_rdy = uart_data->reg_bits.stat_tx_rdy(uart_data);
+
+	if (st & stat_bit_tx_rdy)
+		mvebu_uart_tx_chars(port, st);
+
+	return IRQ_HANDLED;
+}
+
+static int mvebu_uart_irq_request(struct uart_port *port)
 {
 	int ret;
 	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
+
+	if (uart_data->intr.irq_sum > 0) {
+		ret = request_irq(port->irq, mvebu_uart_isr, port->irqflags, DRIVER_NAME, port);
+		if (ret) {
+			dev_err(port->dev, "failed to request irq\n");
+			return ret;
+		}
+	} else if ((uart_data->intr.irq_rx > 0) && (uart_data->intr.irq_tx > 0)) {
+		ret = request_irq(uart_data->intr.irq_rx, mvebu_uart_rx_isr, IRQF_SHARED, DRIVER_NAME"-rx", port);
+		if (ret) {
+			dev_err(port->dev, "failed to request rx irq\n");
+			return ret;
+		}
+		ret = request_irq(uart_data->intr.irq_tx, mvebu_uart_tx_isr, IRQF_SHARED, DRIVER_NAME"-tx", port);
+		if (ret) {
+			dev_err(port->dev, "failed to request tx irq\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int mvebu_uart_startup(struct uart_port *port)
+{
+	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
 	unsigned int ctl;
 
 	writel(CTRL_TXFIFO_RST | CTRL_RXFIFO_RST,
@@ -434,14 +494,9 @@ static int mvebu_uart_startup(struct uart_port *port)
 	ctl |= uart_data->reg_bits.ctrl_rx_rdy_int(uart_data);
 	writel(ctl, port->membase + uart_data->intr.ctrl_reg);
 
-	ret = request_irq(port->irq, mvebu_uart_isr, port->irqflags, DRIVER_NAME,
-			  port);
-	if (ret) {
-		dev_err(port->dev, "failed to request irq\n");
-		return ret;
-	}
+	/* Requset irq_sum, irq_tx, irq_rx separately for uart ports */
+	return mvebu_uart_irq_request(port);
 
-	return 0;
 }
 
 static void mvebu_uart_shutdown(struct uart_port *port)
@@ -721,14 +776,22 @@ static int __init mvebu_uart_console_init(void)
 static int mvebu_uart_probe(struct platform_device *pdev)
 {
 	struct resource *reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	struct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	int irq_sum = platform_get_irq_byname(pdev, "irq_sum");
+	int irq_rx = platform_get_irq_byname(pdev, "irq_rx");
+	int irq_tx = platform_get_irq_byname(pdev, "irq_tx");
 	const struct of_device_id *match = of_match_device(mvebu_uart_of_match, &pdev->dev);
 	struct uart_port *port;
 	struct mvebu_uart_data *data;
 	int ret;
 
-	if (!reg || !irq) {
-		dev_err(&pdev->dev, "no registers/irq defined\n");
+	if (!reg) {
+		dev_err(&pdev->dev, "no registers defined\n");
+		return -EINVAL;
+	}
+
+	if ((irq_sum < 0) && ((irq_rx < 0) || (irq_tx < 0))) {
+		dev_err(&pdev->dev, "no irq defined\n");
 		return -EINVAL;
 	}
 
@@ -754,7 +817,6 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 	port->flags      = UPF_FIXED_PORT;
 	port->line       = pdev->id;
 
-	port->irq        = irq->start;
 	port->irqflags   = IRQF_SHARED;
 	port->mapbase    = reg->start;
 
@@ -771,6 +833,16 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 	data->regs     = &uart_regs_layout[data->reg_type];
 	data->port     = port;
 
+	/* First of all, if sum irq is legal, use sum irq. Otherwise, use tx irq and rx irq.*/
+	if (irq_sum > 0) {
+		port->irq = irq_sum;
+		data->intr.irq_sum = irq_sum;
+	} else if ((irq_rx > 0) && (irq_tx > 0)) {
+		port->irq = irq_rx;
+		data->intr.irq_rx = irq_rx;
+		data->intr.irq_tx = irq_tx;
+	}
+
 	/* Set interrupt register bits callbacks */
 	/* Todo:
 	 *     Set the callbacks according to the transfer mode.
-- 
1.7.9.5


From 69e7d2950218372d6f50c35c12d788ca7f617a65 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Fri, 16 Jun 2017 15:22:12 +0800
Subject: [PATCH 1327/1345] pcie: a80x0: a70x0: add PHY init support in PCIe
 driver

commit  47cf94b92055bb0fb51e65373cf79992f9241dc4 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

On A7/8K, the PCIe support X1, X2 and X4 and currently
the PHY depends on uboot initialization. In order to
cut off the dependency on uboot, the kernel driver
needs to support upto 4 PHYs initialization.

The patch added the PHY initialization when PCIe probe:
1) Parse the PHY connection to PCIe port from DTB file
2) Transfer the PCIe width via PHY command
3) Call callback function of PHY init and power on to
  initialize relevant COMPHY lanes. Currently it only
  supports PCIe RC mode.

Change-Id: I80bdb3e6a18dc350ab4241867b2341253eaea39b
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/40540
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Tested-by: Igal Liberman <igall@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/dwc/pcie-armada8k.c |   62 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/drivers/pci/dwc/pcie-armada8k.c b/drivers/pci/dwc/pcie-armada8k.c
index 6d9b186..a6362a5 100644
--- a/drivers/pci/dwc/pcie-armada8k.c
+++ b/drivers/pci/dwc/pcie-armada8k.c
@@ -25,12 +25,15 @@
 #include <linux/resource.h>
 #include <linux/of_pci.h>
 #include <linux/of_irq.h>
+#include <dt-bindings/phy/phy-comphy-mvebu.h>
 
 #include "pcie-designware.h"
 
 struct armada8k_pcie {
 	struct dw_pcie *pci;
 	struct clk *clk;
+	struct phy		**phys;
+	int			phy_count;
 };
 
 #define PCIE_VENDOR_REGS_OFFSET		0x8000
@@ -207,6 +210,11 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 	struct armada8k_pcie *pcie;
 	struct device *dev = &pdev->dev;
 	struct resource *base;
+	struct phy **phys = NULL;
+	struct resource *base;
+	int i, phy_count = 0;
+	u32 command;
+	char phy_name[16];
 	int ret;
 
 	pcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);
@@ -228,6 +236,54 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 
 	clk_prepare_enable(pcie->clk);
 
+
+	/* Get PHY count according to phy name */
+	phy_count = of_property_count_strings(pdev->dev.of_node, "phy-names");
+	if (phy_count > 0) {
+		phys = devm_kzalloc(dev, sizeof(*phys) * phy_count, GFP_KERNEL);
+		if (!phys)
+			return -ENOMEM;
+
+		for (i = 0; i < phy_count; i++) {
+			snprintf(phy_name, sizeof(phy_name), "pcie-phy%d", i);
+			phys[i] = devm_phy_get(dev, phy_name);
+			if (IS_ERR(phys[i]))
+				goto err_phy;
+
+			/* Tell COMPHY the PCIE width based on phy command,
+			 * and in PHY command callback, the width will be
+			 * checked for its validation.
+			 */
+			switch (phy_count) {
+			case PCIE_LNK_X1:
+				command = COMPHY_COMMAND_PCIE_WIDTH_1;
+				break;
+			case PCIE_LNK_X2:
+				command = COMPHY_COMMAND_PCIE_WIDTH_2;
+				break;
+			case PCIE_LNK_X4:
+				command = COMPHY_COMMAND_PCIE_WIDTH_4;
+				break;
+			default:
+				command = COMPHY_COMMAND_PCIE_WIDTH_UNSUPPORT;
+			}
+			phy_send_command(phys[i], command);
+
+			ret = phy_init(phys[i]);
+			if (ret < 0)
+				goto err_phy;
+
+			ret = phy_power_on(phys[i]);
+			if (ret < 0) {
+				phy_exit(phys[i]);
+				goto err_phy;
+			}
+		}
+	}
+
+	armada8k_pcie->phys = phys;
+	armada8k_pcie->phy_count = phy_count;
+
 	/* Get the dw-pcie unit configuration/control registers base. */
 	base = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl");
 	pci->dbi_base = devm_pci_remap_cfg_resource(dev, base);
@@ -247,6 +303,12 @@ static int armada8k_pcie_probe(struct platform_device *pdev)
 
 	return 0;
 
+err_phy:
+	while (--i >= 0) {
+		phy_power_off(phys[i]);
+		phy_exit(phys[i]);
+	}
+
 fail:
 	if (!IS_ERR(pcie->clk))
 		clk_disable_unprepare(pcie->clk);
-- 
1.7.9.5


From ada33e008fc20891317cec159621a1b3140fff1e Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Fri, 28 Jul 2017 14:31:05 +0800
Subject: [PATCH 1103/1345] fix: uart: a37x0: fix start tx flow

commit  da13403d77f23f0b83b5100925815cb977b96d7a from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

When Armada37x0 works with pulse interrupt, the TX interrupt
is triggered only when TX FIFO state transmites in following
two scenarios:
- FIFO FULL => FIFO NON-FULL
- FIFO EMPTY => FIFO NON-FULL

In order to transmit the sequential data, the driver send out
the first byte to toggle the FIFO state. And the rest bytes
are supposed to be sent out until TX READY interrupt comes.

Now, the driver enqueues the first byte to the TX FIFO prior
to enable the TX interrupt. At that time, the first byte has
already been shifted out. The pulse interrupt state is not
able to be retained. Thus, the following issue is observed
on UART1 port, which uses pulse interrupt.

When transmitting a set of sequential data, the data is not
received with the expected intervals.

original data stream:
ABCDE-<interval>-ABCDE-<interval>-ABCDE-...

observed data stream:
A-<interval>-BCDEABCDE-<interval>-A-<interval>-BCDE...

This patch corrected the sequence of sending the first byte
and enabling TX interrupt in mvebu_uart_start_tx().

Change-Id: I39b1673f23dd2cea417116bc602b800877a7111b
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42382
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/tty/serial/mvebu-uart.c |   17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index e094291..fdd898f 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -319,6 +319,20 @@ static void mvebu_uart_start_tx(struct uart_port *port)
 	struct mvebu_uart_data *uart_data = (struct mvebu_uart_data *)port->private_data;
 	struct circ_buf *xmit = &port->state->xmit;
 
+	/* When Armada37x0 works with pulse interrupt, the TX interrupt
+	 * is triggered only when TX FIFO state transmites in following
+	 * two scenarios:
+	 * - FIFO FULL => FIFO NON-FULL
+	 * - FIFO EMPTY => FIFO NON-FULL
+	 *
+	 * In order to transmit the sequential data, the driver send out
+	 * the first byte to toggle the FIFO state. And the rest bytes
+	 * are supposed to be sent out until TX READY interrupt comes.
+	 */
+	ctl = readl(port->membase + uart_data->intr.ctrl_reg);
+	ctl |= uart_data->reg_bits.ctrl_tx_rdy_int(uart_data);
+	writel(ctl, port->membase + uart_data->intr.ctrl_reg);
+
 	if (!IS_ERR_OR_NULL(uart_data->intr.uart_int_base)) {
 		if (!uart_circ_empty(xmit)) {
 			writel(xmit->buf[xmit->tail], port->membase + REG_TSH(uart_data));
@@ -326,9 +340,6 @@ static void mvebu_uart_start_tx(struct uart_port *port)
 			port->icount.tx++;
 		}
 	}
-	ctl = readl(port->membase + uart_data->intr.ctrl_reg);
-	ctl |= uart_data->reg_bits.ctrl_tx_rdy_int(uart_data);
-	writel(ctl, port->membase + uart_data->intr.ctrl_reg);
 }
 
 static void mvebu_uart_stop_rx(struct uart_port *port)
-- 
1.7.9.5


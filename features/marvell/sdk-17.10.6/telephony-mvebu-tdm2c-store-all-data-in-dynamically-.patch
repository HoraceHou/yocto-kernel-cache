From 0de748555da7b90242161cf7532b9a27253ab3f4 Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Tue, 27 Dec 2016 10:41:38 +0100
Subject: [PATCH 0683/1345] telephony: mvebu: tdm2c: store all data in
 dynamically allocated structure

commit  efb0f5e0438e25b5d24755a190262090af52e123 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This patch is significant, but couldn't be split into smaller ones due to
big amount of global variables. Changes are following:
* Remove all global variables and store them in newly created tdm2c_dev
  structure.
* Structure is dynamically allocated by 'managed' allocator (devm_...)
  after calling tdm_if_init -> ... -> tdm2c_init. In consecutive
  initialization sequences the data are reset to initial values.
* Remove spi_mode variable, because it's used locally only in tdm2c_init.
* Improve line breaking and alignment of modified code.

Note: tdm2c_dev structure definition had to be placed in tdm2c.c file,
because of used enums from mv_phone.h and build dependencies.

Change-Id: Ia2eaf8ba710c2b35cf42857df78abfa7fd03df67
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35147
Reviewed-by: Igal Liberman <igall@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/telephony/mvebu_phone/tdm2c/tdm2c.c |  612 ++++++++++++++-------------
 drivers/telephony/mvebu_phone/tdm2c/tdm2c.h |    1 -
 2 files changed, 324 insertions(+), 289 deletions(-)

diff --git a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
index 20e7255..722ce87 100644
--- a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
+++ b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.c
@@ -96,46 +96,62 @@
 
 #include "mv_phone.h"
 
-/* Globals */
-static u8 *rx_aggr_buff_virt, *tx_aggr_buff_virt;
-static u8 rx_int, tx_int;
-static u16 rx_full, tx_empty;
-static u8 tdm_enable;
-static u8 spi_mode;
-static u8 factor;
-static enum mv_phone_pcm_format pcm_format;
-static enum mv_phone_band_mode tdm_band_mode;
-static struct tdm2c_ch_info *tdm_ch_info[MV_TDM2C_TOTAL_CHANNELS] = { NULL, NULL };
-static u8 chan_stop_count;
-static u8 int_lock;
-static struct device *pdev;
-static void __iomem *regs;
-
-/* Stats */
-static u32 int_rx_count;
-static u32 int_tx_count;
-static u32 int_rx0_count;
-static u32 int_tx0_count;
-static u32 int_rx1_count;
-static u32 int_tx1_count;
-static u32 int_rx0_miss;
-static u32 int_tx0_miss;
-static u32 int_rx1_miss;
-static u32 int_tx1_miss;
-static u32 pcm_restart_count;
+/* Main TDM structure definition */
+struct tdm2c_dev {
+	/* Resources */
+	void __iomem *regs;
+	struct device *dev;
+
+	/* Buffers */
+	u8 *rx_aggr_buff_virt;
+	u8 *tx_aggr_buff_virt;
+
+	/* Flags and counters */
+	u16 rx_full;
+	u16 tx_empty;
+	u8 rx_int;
+	u8 tx_int;
+	bool enable;
+	bool int_lock;
+	int chan_stop_count;
+
+	/* Parameters */
+	u8 factor;
+	enum mv_phone_pcm_format pcm_format;
+	enum mv_phone_band_mode band_mode;
+
+	/* Channels' data */
+	struct tdm2c_ch_info *ch_info[MV_TDM2C_TOTAL_CHANNELS];
+
+	/* Statistics */
+	u32 int_rx_count;
+	u32 int_tx_count;
+	u32 int_rx0_count;
+	u32 int_tx0_count;
+	u32 int_rx1_count;
+	u32 int_tx1_count;
+	u32 int_rx0_miss;
+	u32 int_tx0_miss;
+	u32 int_rx1_miss;
+	u32 int_tx1_miss;
+	u32 pcm_restart_count;
+};
+
+struct tdm2c_dev *tdm2c;
 
 static void tdm2c_daisy_chain_mode_set(void)
 {
-	while ((readl(regs + SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+	while ((readl(tdm2c->regs + SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
 		continue;
-	writel((0x80 << 8) | 0, regs + SPI_CODEC_CMD_LO_REG);
-	writel(TRANSFER_BYTES(2) | ENDIANNESS_MSB_MODE | WR_MODE | CLK_SPEED_LO_DIV, regs + SPI_CODEC_CTRL_REG);
-	writel(readl(regs + SPI_CTRL_REG) | SPI_ACTIVE, regs + SPI_CTRL_REG);
+	writel((0x80 << 8) | 0, tdm2c->regs + SPI_CODEC_CMD_LO_REG);
+	writel(TRANSFER_BYTES(2) | ENDIANNESS_MSB_MODE | WR_MODE | CLK_SPEED_LO_DIV,
+	       tdm2c->regs + SPI_CODEC_CTRL_REG);
+	writel(readl(tdm2c->regs + SPI_CTRL_REG) | SPI_ACTIVE, tdm2c->regs + SPI_CTRL_REG);
 	/* Poll for ready indication */
-	while ((readl(regs + SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+	while ((readl(tdm2c->regs + SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
 		continue;
 
-	dev_dbg(pdev, "%s: Exit\n", __func__);
+	dev_dbg(tdm2c->dev, "%s: Exit\n", __func__);
 }
 
 static int tdm2c_ch_init(u8 ch)
@@ -143,46 +159,47 @@ static int tdm2c_ch_init(u8 ch)
 	struct tdm2c_ch_info *ch_info;
 	u32 buff;
 
-	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
 
 	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
-		dev_err(pdev, "%s: error, channel(%d) exceeds maximum(%d)\n",
+		dev_err(tdm2c->dev, "%s: error, channel(%d) exceeds maximum(%d)\n",
 			__func__, ch, MV_TDM2C_TOTAL_CHANNELS);
 		return -EINVAL;
 	}
 
-	tdm_ch_info[ch] = ch_info = kmalloc(sizeof(struct tdm2c_ch_info),
-					    GFP_ATOMIC);
-	if (!ch_info) {
-		dev_err(pdev, "%s: error malloc failed\n", __func__);
+	tdm2c->ch_info[ch] = kmalloc(sizeof(struct tdm2c_ch_info), GFP_ATOMIC);
+	if (!tdm2c->ch_info) {
+		dev_err(tdm2c->dev, "%s: error malloc failed\n", __func__);
 		return -ENOMEM;
 	}
 
+	ch_info = tdm2c->ch_info[ch];
 	ch_info->ch = ch;
 
 	/* Per channel TDM init */
 	/* Disable channel (enable in pcm start) */
-	writel(CH_DISABLE, regs + CH_ENABLE_REG(ch));
+	writel(CH_DISABLE, tdm2c->regs + CH_ENABLE_REG(ch));
 	/* Set total samples and int sample */
-	writel(CONFIG_CH_SAMPLE(tdm_band_mode, factor), regs + CH_SAMPLE_REG(ch));
+	writel(CONFIG_CH_SAMPLE(tdm2c->band_mode, tdm2c->factor), tdm2c->regs + CH_SAMPLE_REG(ch));
 
 	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
 		/* Buffers must be 32B aligned */
-		ch_info->rxBuffVirt[buff] = dma_alloc_coherent(pdev,
-							      MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
-							      &(ch_info->rxBuffPhys[buff]), GFP_KERNEL);
+		ch_info->rxBuffVirt[buff] = dma_alloc_coherent(tdm2c->dev,
+				MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor),
+				&(ch_info->rxBuffPhys[buff]), GFP_KERNEL);
 		ch_info->rxBuffFull[buff] = BUFF_IS_EMPTY;
 
-		ch_info->txBuffVirt[buff] = dma_alloc_coherent(pdev,
-							      MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
-							      &(ch_info->txBuffPhys[buff]), GFP_KERNEL);
+		ch_info->txBuffVirt[buff] = dma_alloc_coherent(tdm2c->dev,
+				MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor),
+				&(ch_info->txBuffPhys[buff]), GFP_KERNEL);
 		ch_info->txBuffFull[buff] = BUFF_IS_FULL;
 
-		memset(ch_info->txBuffVirt[buff], 0, MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+		memset(ch_info->txBuffVirt[buff], 0,
+				MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 
 		if (((ulong) ch_info->rxBuffVirt[buff] | ch_info->rxBuffPhys[buff] |
 		     (ulong) ch_info->txBuffVirt[buff] | ch_info->txBuffPhys[buff]) & 0x1f) {
-			dev_err(pdev, "%s: error, unaligned buffer allocation\n", __func__);
+			dev_err(tdm2c->dev, "%s: error, unaligned buffer allocation\n", __func__);
 		}
 	}
 
@@ -192,17 +209,17 @@ static int tdm2c_ch_init(u8 ch)
 static inline int tdm2c_ch_tx_low(u8 ch)
 {
 	u32 max_poll = 0;
-	struct tdm2c_ch_info *ch_info = tdm_ch_info[ch];
+	struct tdm2c_ch_info *ch_info = tdm2c->ch_info[ch];
 
-	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
 
 	/* Count tx interrupts */
-	tx_int++;
+	tdm2c->tx_int++;
 
 	if (ch_info->txBuffFull[ch_info->txCurrBuff] == BUFF_IS_FULL)
-		dev_dbg(pdev, "curr buff full for hw [MMP ok]\n");
+		dev_dbg(tdm2c->dev, "curr buff full for hw [MMP ok]\n");
 	else
-		dev_warn(pdev, "curr buf is empty [MMP miss write]\n");
+		dev_warn(tdm2c->dev, "curr buf is empty [MMP miss write]\n");
 
 	/* Change buffers */
 	ch_info->txCurrBuff = MV_TDM_NEXT_BUFFER(ch_info->txCurrBuff);
@@ -212,37 +229,37 @@ static inline int tdm2c_ch_tx_low(u8 ch)
 	 * for next frame. The app need to write the data before HW takes it.
 	 */
 	ch_info->txBuffFull[ch_info->txCurrBuff] = BUFF_IS_EMPTY;
-	dev_dbg(pdev, "->%s clear buf(%d) for channel(%d)\n", __func__, ch_info->txCurrBuff, ch);
+	dev_dbg(tdm2c->dev, "->%s clear buf(%d) for channel(%d)\n", __func__, ch_info->txCurrBuff, ch);
 
 	/* Poll on SW ownership (single check) */
-	dev_dbg(pdev, "start poll for SW ownership\n");
-	while (((readb(regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
+	dev_dbg(tdm2c->dev, "start poll for SW ownership\n");
+	while (((readb(tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
 	       && (max_poll < 2000)) {
 		udelay(1);
 		max_poll++;
 	}
 	if (max_poll == 2000) {
-		dev_err(pdev, "poll timeout (~2ms)\n");
+		dev_err(tdm2c->dev, "poll timeout (~2ms)\n");
 		return -ETIME;
 	}
 
-	dev_dbg(pdev, "ch%d, start tx buff %d\n", ch, ch_info->txCurrBuff);
+	dev_dbg(tdm2c->dev, "ch%d, start tx buff %d\n", ch, ch_info->txCurrBuff);
 
 	/* Set TX buff address (must be 32 byte aligned) */
-	writel(ch_info->txBuffPhys[ch_info->txCurrBuff], regs + CH_TX_ADDR_REG(ch_info->ch));
+	writel(ch_info->txBuffPhys[ch_info->txCurrBuff], tdm2c->regs + CH_TX_ADDR_REG(ch_info->ch));
 
 	/* Set HW ownership */
-	writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS);
+	writeb(OWN_BY_HW, tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) + TX_OWN_BYTE_OFFS);
 
 	/* Enable Tx */
-	writeb(CH_ENABLE, regs + CH_ENABLE_REG(ch_info->ch) + TX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(ch_info->ch) + TX_ENABLE_BYTE_OFFS);
 
 	/* Did we get the required amount of irqs for Tx wakeup ? */
-	if (tx_int < MV_TDM_INT_COUNTER)
+	if (tdm2c->tx_int < MV_TDM_INT_COUNTER)
 		return -EBUSY;
 
-	tx_int = 0;
-	tx_empty = ch_info->txCurrBuff;
+	tdm2c->tx_int = 0;
+	tdm2c->tx_empty = ch_info->txCurrBuff;
 
 	return 0;
 }
@@ -250,19 +267,19 @@ static inline int tdm2c_ch_tx_low(u8 ch)
 static inline int tdm2c_ch_rx_low(u8 ch)
 {
 	u32 max_poll = 0;
-	struct tdm2c_ch_info *ch_info = tdm_ch_info[ch];
+	struct tdm2c_ch_info *ch_info = tdm2c->ch_info[ch];
 
-	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
 
 	if (ch_info->rxFirst)
 		ch_info->rxFirst = !FIRST_INT;
 	else
-		rx_int++;
+		tdm2c->rx_int++;
 
 	if (ch_info->rxBuffFull[ch_info->rxCurrBuff] == BUFF_IS_EMPTY)
-		dev_dbg(pdev, "curr buff empty for hw [MMP ok]\n");
+		dev_dbg(tdm2c->dev, "curr buff empty for hw [MMP ok]\n");
 	else
-		dev_warn(pdev, "curr buf is full [MMP miss read]\n");
+		dev_warn(tdm2c->dev, "curr buf is full [MMP miss read]\n");
 
 	/*
 	 * Mark last buff that was received by HW as full. Give next buff to HW for
@@ -274,36 +291,36 @@ static inline int tdm2c_ch_rx_low(u8 ch)
 	ch_info->rxCurrBuff = MV_TDM_NEXT_BUFFER(ch_info->rxCurrBuff);
 
 	/* Poll on SW ownership (single check) */
-	dev_dbg(pdev, "start poll for ownership\n");
-	while (((readb(regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
+	dev_dbg(tdm2c->dev, "start poll for ownership\n");
+	while (((readb(tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
 	       && (max_poll < 2000)) {
 		udelay(1);
 		max_poll++;
 	}
 
 	if (max_poll == 2000) {
-		dev_err(pdev, "poll timeout (~2ms)\n");
+		dev_err(tdm2c->dev, "poll timeout (~2ms)\n");
 		return -ETIME;
 	}
 
-	dev_dbg(pdev, "ch%d, start rx buff %d\n", ch, ch_info->rxCurrBuff);
+	dev_dbg(tdm2c->dev, "ch%d, start rx buff %d\n", ch, ch_info->rxCurrBuff);
 
 	/* Set RX buff address (must be 32 byte aligned) */
-	writel(ch_info->rxBuffPhys[ch_info->rxCurrBuff], regs + CH_RX_ADDR_REG(ch_info->ch));
+	writel(ch_info->rxBuffPhys[ch_info->rxCurrBuff], tdm2c->regs + CH_RX_ADDR_REG(ch_info->ch));
 
 	/* Set HW ownership */
-	writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS);
+	writeb(OWN_BY_HW, tdm2c->regs + CH_BUFF_OWN_REG(ch_info->ch) + RX_OWN_BYTE_OFFS);
 
 	/* Enable Rx */
-	writeb(CH_ENABLE, regs + CH_ENABLE_REG(ch_info->ch) + RX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(ch_info->ch) + RX_ENABLE_BYTE_OFFS);
 
 	/* Did we get the required amount of irqs for Rx wakeup ? */
-	if (rx_int < MV_TDM_INT_COUNTER)
+	if (tdm2c->rx_int < MV_TDM_INT_COUNTER)
 		return -EBUSY;
 
-	rx_int = 0;
-	rx_full = MV_TDM_PREV_BUFFER(ch_info->rxCurrBuff, 2);
-	dev_dbg(pdev, "buff %d is FULL for ch0/1\n", rx_full);
+	tdm2c->rx_int = 0;
+	tdm2c->rx_full = MV_TDM_PREV_BUFFER(ch_info->rxCurrBuff, 2);
+	dev_dbg(tdm2c->dev, "buff %d is FULL for ch0/1\n", tdm2c->rx_full);
 
 	return 0;
 }
@@ -313,20 +330,20 @@ static int tdm2c_ch_remove(u8 ch)
 	struct tdm2c_ch_info *ch_info;
 	u8 buff;
 
-	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
 
 	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
-		dev_err(pdev, "%s: error, channel(%d) exceeds maximum(%d)\n",
+		dev_err(tdm2c->dev, "%s: error, channel(%d) exceeds maximum(%d)\n",
 			__func__, ch, MV_TDM2C_TOTAL_CHANNELS);
 		return -EINVAL;
 	}
 
-	ch_info = tdm_ch_info[ch];
+	ch_info = tdm2c->ch_info[ch];
 
 	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
-		dma_free_coherent(pdev, MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
+		dma_free_coherent(tdm2c->dev, MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor),
 				  ch_info->rxBuffVirt[buff], (dma_addr_t)ch_info->rxBuffPhys[buff]);
-		dma_free_coherent(pdev, MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor),
+		dma_free_coherent(tdm2c->dev, MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor),
 				  ch_info->txBuffVirt[buff], (dma_addr_t)ch_info->txBuffPhys[buff]);
 	}
 
@@ -340,14 +357,16 @@ static void tdm2c_reset(void)
 	struct tdm2c_ch_info *ch_info;
 	u8 buff, ch;
 
-	dev_dbg(pdev, "%s: Enter, ch%d\n", __func__, ch);
+	dev_dbg(tdm2c->dev, "%s: Enter, ch%d\n", __func__, ch);
 
 	/* Reset globals */
-	rx_int = tx_int = 0;
-	rx_full = tx_empty = BUFF_INVALID;
+	tdm2c->rx_int = 0;
+	tdm2c->tx_int = 0;
+	tdm2c->rx_full = BUFF_INVALID;
+	tdm2c->tx_empty = BUFF_INVALID;
 
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
-		ch_info = tdm_ch_info[ch];
+		ch_info = tdm2c->ch_info[ch];
 		ch_info->rxFirst = FIRST_INT;
 		ch_info->txCurrBuff = ch_info->rxCurrBuff = 0;
 		for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
@@ -366,51 +385,58 @@ int tdm2c_init(void __iomem *base, struct device *dev,
 	u32 ch_delay[4] = { 0, 0, 0, 0 };
 	int ret;
 
-	regs = base;
+	/* Initialize or reset main structure */
+	if (!tdm2c) {
+		tdm2c = devm_kzalloc(dev, sizeof(struct tdm2c_dev), GFP_KERNEL);
+		if (!tdm2c)
+			return -ENOMEM;
+	} else {
+		memset(tdm2c, 0,  sizeof(struct tdm2c_dev));
+	}
+
+	/* Initialize remaining parameters */
+	tdm2c->regs = base;
+	tdm2c->pcm_format = tdmParams->pcm_format;
+	tdm2c->rx_full = BUFF_INVALID;
+	tdm2c->tx_empty = BUFF_INVALID;
+	tdm2c->dev = dev;
+
 	dev_info(dev, "TDM dual channel device rev 0x%x\n",
-		 readl(regs + TDM_REV_REG));
-
-	/* Init globals */
-	rx_int = tx_int = 0;
-	rx_full = tx_empty = BUFF_INVALID;
-	tdm_enable = 0, int_lock = 0;
-	spi_mode = halData->spi_mode;
-	pcm_format = tdmParams->pcm_format;
-	int_rx_count = 0, int_tx_count = 0;
-	int_rx0_count = 0, int_tx0_count = 0;
-	int_rx1_count = 0, int_tx1_count = 0;
-	int_rx0_miss = 0, int_tx0_miss = 0;
-	int_rx1_miss = 0, int_tx1_miss = 0;
-	pcm_restart_count = 0;
-	pdev = dev;
+		 readl(tdm2c->regs + TDM_REV_REG));
 
 	if (tdmParams->sampling_period > MV_TDM_MAX_SAMPLING_PERIOD)
 		/* Use base sample period(10ms) */
-		factor = 1;
+		tdm2c->factor = 1;
 	else
-		factor = (tdmParams->sampling_period / MV_TDM_BASE_SAMPLING_PERIOD);
+		tdm2c->factor = (tdmParams->sampling_period / MV_TDM_BASE_SAMPLING_PERIOD);
 
 	/* Extract pcm format & band mode */
-	if (pcm_format == MV_PCM_FORMAT_4BYTES) {
-		pcm_format = MV_PCM_FORMAT_2BYTES;
-		tdm_band_mode = MV_WIDE_BAND;
+	if (tdm2c->pcm_format == MV_PCM_FORMAT_4BYTES) {
+		tdm2c->pcm_format = MV_PCM_FORMAT_2BYTES;
+		tdm2c->band_mode = MV_WIDE_BAND;
 	} else {
-		tdm_band_mode = MV_NARROW_BAND;
+		tdm2c->band_mode = MV_NARROW_BAND;
 	}
 
 	/* Allocate aggregated buffers for data transport */
-	dev_dbg(pdev, "allocate %d bytes for aggregated buffer\n",
-		MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
-	rx_aggr_buff_virt = alloc_pages_exact(MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor), GFP_KERNEL);
-	tx_aggr_buff_virt = alloc_pages_exact(MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor), GFP_KERNEL);
-	if (!rx_aggr_buff_virt || !tx_aggr_buff_virt) {
-		dev_err(pdev, "%s: Error malloc failed\n", __func__);
+	dev_dbg(tdm2c->dev, "allocate %d bytes for aggregated buffer\n",
+		MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
+	tdm2c->rx_aggr_buff_virt = alloc_pages_exact(
+			MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor),
+			GFP_KERNEL);
+	tdm2c->tx_aggr_buff_virt = alloc_pages_exact(
+			MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor),
+			GFP_KERNEL);
+	if (!tdm2c->rx_aggr_buff_virt || !tdm2c->tx_aggr_buff_virt) {
+		dev_err(tdm2c->dev, "%s: Error malloc failed\n", __func__);
 		return -ENOMEM;
 	}
 
 	/* Clear buffers */
-	memset(rx_aggr_buff_virt, 0, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
-	memset(tx_aggr_buff_virt, 0, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	memset(tdm2c->rx_aggr_buff_virt, 0,
+	       MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
+	memset(tdm2c->tx_aggr_buff_virt, 0,
+	       MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 
 	/* Calculate CH(0/1) Delay Control for narrow/wideband modes */
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
@@ -422,65 +448,66 @@ int tdm2c_init(void __iomem *base, struct device *dev,
 	}
 
 	/* Enable TDM/SPI interface */
-	mv_phone_reset_bit(regs + TDM_SPI_MUX_REG, 0x00000001);
+	mv_phone_reset_bit(tdm2c->regs + TDM_SPI_MUX_REG, 0x00000001);
 	/* Interrupt cause is not clear on read */
-	writel(CLEAR_ON_ZERO, regs + INT_RESET_SELECT_REG);
+	writel(CLEAR_ON_ZERO, tdm2c->regs + INT_RESET_SELECT_REG);
 	/* All interrupt bits latched in status */
-	writel(0x3ffff, regs + INT_EVENT_MASK_REG);
+	writel(0x3ffff, tdm2c->regs + INT_EVENT_MASK_REG);
 	/* Disable interrupts */
-	writel(0, regs + INT_STATUS_MASK_REG);
+	writel(0, tdm2c->regs + INT_STATUS_MASK_REG);
 	/* Clear int status register */
-	writel(0, regs + INT_STATUS_REG);
+	writel(0, tdm2c->regs + INT_STATUS_REG);
 
 	/* Bypass clock divider - PCM PCLK freq */
-	writel(PCM_DIV_PASS, regs + PCM_CLK_RATE_DIV_REG);
+	writel(PCM_DIV_PASS, tdm2c->regs + PCM_CLK_RATE_DIV_REG);
 
 	/* Padding on Rx completion */
-	writel(0, regs + DUMMY_RX_WRITE_DATA_REG);
-	writeb(readl(regs + SPI_GLOBAL_CTRL_REG) | SPI_GLOBAL_ENABLE, regs + SPI_GLOBAL_CTRL_REG);
+	writel(0, tdm2c->regs + DUMMY_RX_WRITE_DATA_REG);
+	writeb(readl(tdm2c->regs + SPI_GLOBAL_CTRL_REG) | SPI_GLOBAL_ENABLE,
+	       tdm2c->regs + SPI_GLOBAL_CTRL_REG);
 	/* SPI SCLK freq */
-	writel(SPI_CLK_2MHZ, regs + SPI_CLK_PRESCALAR_REG);
+	writel(SPI_CLK_2MHZ, tdm2c->regs + SPI_CLK_PRESCALAR_REG);
 	/* Number of timeslots (PCLK) */
-	writel((u32)halData->frame_ts, regs + FRAME_TIMESLOT_REG);
+	writel((u32)halData->frame_ts, tdm2c->regs + FRAME_TIMESLOT_REG);
 
-	if (tdm_band_mode == MV_NARROW_BAND) {
-		pcm_ctrl_reg = (CONFIG_PCM_CRTL | (((u8)pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
+	if (tdm2c->band_mode == MV_NARROW_BAND) {
+		pcm_ctrl_reg = (CONFIG_PCM_CRTL | (((u8)tdm2c->pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
 
 		if (use_pclk_external)
 			pcm_ctrl_reg |= MASTER_PCLK_EXTERNAL;
 
 		/* PCM configuration */
-		writel(pcm_ctrl_reg, regs + PCM_CTRL_REG);
+		writel(pcm_ctrl_reg, tdm2c->regs + PCM_CTRL_REG);
 		/* CH0 delay control register */
-		writel(ch_delay[0], regs + CH_DELAY_CTRL_REG(0));
+		writel(ch_delay[0], tdm2c->regs + CH_DELAY_CTRL_REG(0));
 		/* CH1 delay control register */
-		writel(ch_delay[1], regs + CH_DELAY_CTRL_REG(1));
+		writel(ch_delay[1], tdm2c->regs + CH_DELAY_CTRL_REG(1));
 	} else {		/* MV_WIDE_BAND */
 
-		pcm_ctrl_reg = (CONFIG_WB_PCM_CRTL | (((u8)pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
+		pcm_ctrl_reg = (CONFIG_WB_PCM_CRTL | (((u8)tdm2c->pcm_format - 1) << PCM_SAMPLE_SIZE_OFFS));
 
 		if (use_pclk_external)
 			pcm_ctrl_reg |= MASTER_PCLK_EXTERNAL;
 
 		/* PCM configuration - WB support */
-		writel(pcm_ctrl_reg, regs + PCM_CTRL_REG);
+		writel(pcm_ctrl_reg, tdm2c->regs + PCM_CTRL_REG);
 		/* CH0 delay control register */
-		writel(ch_delay[0], regs + CH_DELAY_CTRL_REG(0));
+		writel(ch_delay[0], tdm2c->regs + CH_DELAY_CTRL_REG(0));
 		/* CH1 delay control register */
-		writel(ch_delay[1], regs + CH_DELAY_CTRL_REG(1));
+		writel(ch_delay[1], tdm2c->regs + CH_DELAY_CTRL_REG(1));
 		/* CH0 WB delay control register */
-		writel(ch_delay[2], regs + CH_WB_DELAY_CTRL_REG(0));
+		writel(ch_delay[2], tdm2c->regs + CH_WB_DELAY_CTRL_REG(0));
 		/* CH1 WB delay control register */
-		writel(ch_delay[3], regs + CH_WB_DELAY_CTRL_REG(1));
+		writel(ch_delay[3], tdm2c->regs + CH_WB_DELAY_CTRL_REG(1));
 	}
 
 	/* Issue reset to codec(s) */
-	dev_dbg(pdev, "resetting voice unit(s)\n");
-	writel(0, regs + MISC_CTRL_REG);
+	dev_dbg(tdm2c->dev, "resetting voice unit(s)\n");
+	writel(0, tdm2c->regs + MISC_CTRL_REG);
 	mdelay(1);
-	writel(1, regs + MISC_CTRL_REG);
+	writel(1, tdm2c->regs + MISC_CTRL_REG);
 
-	if (spi_mode) {
+	if (halData->spi_mode) {
 		/* Configure TDM to work in daisy chain mode */
 		tdm2c_daisy_chain_mode_set();
 	}
@@ -489,13 +516,13 @@ int tdm2c_init(void __iomem *base, struct device *dev,
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
 		ret = tdm2c_ch_init(ch);
 		if (ret) {
-			dev_err(pdev, "tdm2c_ch_init(%d) failed !\n", ch);
+			dev_err(tdm2c->dev, "tdm2c_ch_init(%d) failed !\n", ch);
 			return ret;
 		}
 	}
 
 	/* Enable SLIC/DAA interrupt detection(before pcm is active) */
-	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC), regs + INT_STATUS_MASK_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC), tdm2c->regs + INT_STATUS_MASK_REG);
 
 	return 0;
 }
@@ -505,15 +532,17 @@ void tdm2c_release(void)
 	u8 ch;
 
 	/* Free Rx/Tx aggregated buffers */
-	free_pages_exact(rx_aggr_buff_virt, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
-	free_pages_exact(tx_aggr_buff_virt, MV_TDM_AGGR_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+	free_pages_exact(tdm2c->rx_aggr_buff_virt,
+			 MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
+	free_pages_exact(tdm2c->tx_aggr_buff_virt,
+			 MV_TDM_AGGR_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 
 	/* Release HW channel resources */
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++)
 		tdm2c_ch_remove(ch);
 
 	/* Disable TDM/SPI interface */
-	mv_phone_set_bit(regs + TDM_SPI_MUX_REG, 0x00000001);
+	mv_phone_set_bit(tdm2c->regs + TDM_SPI_MUX_REG, 0x00000001);
 }
 
 void tdm2c_pcm_start(void)
@@ -522,44 +551,48 @@ void tdm2c_pcm_start(void)
 	u8 ch;
 
 	/* TDM is enabled */
-	tdm_enable = 1;
-	int_lock = 0;
-	chan_stop_count = 0;
+	tdm2c->enable = true;
+	tdm2c->int_lock = false;
+	tdm2c->chan_stop_count = 0;
 	tdm2c_reset();
 
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
-		ch_info = tdm_ch_info[ch];
+		ch_info = tdm2c->ch_info[ch];
 
 		/* Set Tx buff */
-		writel(ch_info->txBuffPhys[ch_info->txCurrBuff], regs + CH_TX_ADDR_REG(ch));
-		writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS);
+		writel(ch_info->txBuffPhys[ch_info->txCurrBuff], tdm2c->regs + CH_TX_ADDR_REG(ch));
+		writeb(OWN_BY_HW, tdm2c->regs + CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS);
 
 		/* Set Rx buff */
-		writel(ch_info->rxBuffPhys[ch_info->rxCurrBuff], regs + CH_RX_ADDR_REG(ch));
-		writeb(OWN_BY_HW, regs + CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS);
+		writel(ch_info->rxBuffPhys[ch_info->rxCurrBuff], tdm2c->regs + CH_RX_ADDR_REG(ch));
+		writeb(OWN_BY_HW, tdm2c->regs + CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS);
 
 	}
 
 	/* Enable Tx */
-	writeb(CH_ENABLE, regs + CH_ENABLE_REG(0) + TX_ENABLE_BYTE_OFFS);
-	writeb(CH_ENABLE, regs + CH_ENABLE_REG(1) + TX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(0) + TX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(1) + TX_ENABLE_BYTE_OFFS);
 
 	/* Enable Rx */
-	writeb(CH_ENABLE, regs + CH_ENABLE_REG(0) + RX_ENABLE_BYTE_OFFS);
-	writeb(CH_ENABLE, regs + CH_ENABLE_REG(1) + RX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(0) + RX_ENABLE_BYTE_OFFS);
+	writeb(CH_ENABLE, tdm2c->regs + CH_ENABLE_REG(1) + RX_ENABLE_BYTE_OFFS);
 
 	/* Enable Tx interrupts */
-	writel(readl(regs + INT_STATUS_REG) & (~(TDM_INT_TX(0) | TDM_INT_TX(1))), regs + INT_STATUS_REG);
-	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_TX(0) | TDM_INT_TX(1)), regs + INT_STATUS_MASK_REG);
+	writel(readl(tdm2c->regs + INT_STATUS_REG) & (~(TDM_INT_TX(0) | TDM_INT_TX(1))),
+	       tdm2c->regs + INT_STATUS_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_TX(0) | TDM_INT_TX(1)),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
 
 	/* Enable Rx interrupts */
-	writel((readl(regs + INT_STATUS_REG) & (~(TDM_INT_RX(0) | TDM_INT_RX(1)))), regs + INT_STATUS_REG);
-	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_RX(0) | TDM_INT_RX(1)), regs + INT_STATUS_MASK_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_REG) & (~(TDM_INT_RX(0) | TDM_INT_RX(1)))),
+	       tdm2c->regs + INT_STATUS_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_RX(0) | TDM_INT_RX(1)),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
 }
 
 void tdm2c_pcm_stop(void)
 {
-	tdm_enable = 0;
+	tdm2c->enable = false;
 
 	tdm2c_reset();
 }
@@ -571,35 +604,36 @@ int tdm2c_tx(u8 *tdm_tx_buff)
 	u8 *tx_buff;
 
 	/* Sanity check */
-	if (tdm_tx_buff != tx_aggr_buff_virt) {
-		dev_err(pdev, "%s: Error, invalid Tx buffer !!!\n", __func__);
+	if (tdm_tx_buff != tdm2c->tx_aggr_buff_virt) {
+		dev_err(tdm2c->dev, "%s: Error, invalid Tx buffer !!!\n", __func__);
 		return -EINVAL;
 	}
 
-	if (!tdm_enable) {
-		dev_err(pdev, "%s: Error, no active Tx channels are available\n", __func__);
+	if (!tdm2c->enable) {
+		dev_err(tdm2c->dev, "%s: Error, no active Tx channels are available\n", __func__);
 		return -EINVAL;
 	}
 
-	if (tx_empty == BUFF_INVALID) {
-		dev_err(pdev, "%s: Tx not ready\n", __func__);
+	if (tdm2c->tx_empty == BUFF_INVALID) {
+		dev_err(tdm2c->dev, "%s: Tx not ready\n", __func__);
 		return -EINVAL;
 	}
 
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
-		ch_info = tdm_ch_info[ch];
-		dev_dbg(pdev, "ch%d: fill buf %d with %d bytes\n",
-			ch, tx_empty,
-			MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
-		ch_info->txBuffFull[tx_empty] = BUFF_IS_FULL;
-		tx_buff = tdm_tx_buff + (ch * MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+		ch_info = tdm2c->ch_info[ch];
+		dev_dbg(tdm2c->dev, "ch%d: fill buf %d with %d bytes\n",
+			ch, tdm2c->tx_empty,
+			MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
+		ch_info->txBuffFull[tdm2c->tx_empty] = BUFF_IS_FULL;
+		tx_buff = tdm_tx_buff +
+			  (ch * MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 
 		/* Copy data from voice engine buffer to DMA */
-		memcpy(ch_info->txBuffVirt[tx_empty], tx_buff,
-		       MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+		memcpy(ch_info->txBuffVirt[tdm2c->tx_empty], tx_buff,
+		       MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 	}
 
-	tx_empty = BUFF_INVALID;
+	tdm2c->tx_empty = BUFF_INVALID;
 
 	return 0;
 }
@@ -611,34 +645,35 @@ int tdm2c_rx(u8 *tdm_rx_buff)
 	u8 *rx_buff;
 
 	/* Sanity check */
-	if (tdm_rx_buff != rx_aggr_buff_virt) {
-		dev_err(pdev, "%s: invalid Rx buffer !!!\n", __func__);
+	if (tdm_rx_buff != tdm2c->rx_aggr_buff_virt) {
+		dev_err(tdm2c->dev, "%s: invalid Rx buffer !!!\n", __func__);
 		return -EINVAL;
 	}
 
-	if (!tdm_enable) {
-		dev_err(pdev, "%s: Error, no active Rx channels are available\n", __func__);
+	if (!tdm2c->enable) {
+		dev_err(tdm2c->dev, "%s: Error, no active Rx channels are available\n", __func__);
 		return -EINVAL;
 	}
 
-	if (rx_full == BUFF_INVALID) {
-		dev_err(pdev, "%s: Rx not ready\n", __func__);
+	if (tdm2c->rx_full == BUFF_INVALID) {
+		dev_err(tdm2c->dev, "%s: Rx not ready\n", __func__);
 		return -EINVAL;
 	}
 
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
-		ch_info = tdm_ch_info[ch];
-		ch_info->rxBuffFull[rx_full] = BUFF_IS_EMPTY;
-		dev_dbg(pdev, "%s get Rx buffer(%d) for channel(%d)\n",
-			__func__, rx_full, ch);
-		rx_buff = tdm_rx_buff + (ch * MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+		ch_info = tdm2c->ch_info[ch];
+		ch_info->rxBuffFull[tdm2c->rx_full] = BUFF_IS_EMPTY;
+		dev_dbg(tdm2c->dev, "%s get Rx buffer(%d) for channel(%d)\n",
+			__func__, tdm2c->rx_full, ch);
+		rx_buff = tdm_rx_buff +
+			  (ch * MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 
 		/* Copy data from DMA to voice engine buffer */
-		memcpy(rx_buff, ch_info->rxBuffVirt[rx_full],
-		       MV_TDM_CH_BUFF_SIZE(pcm_format, tdm_band_mode, factor));
+		memcpy(rx_buff, ch_info->rxBuffVirt[tdm2c->rx_full],
+		       MV_TDM_CH_BUFF_SIZE(tdm2c->pcm_format, tdm2c->band_mode, tdm2c->factor));
 	}
 
-	rx_full = BUFF_INVALID;
+	tdm2c->rx_full = BUFF_INVALID;
 
 	return 0;
 }
@@ -647,8 +682,8 @@ int tdm2c_pcm_stop_int_miss(void)
 {
 	u32 status_reg, mask_reg, status_stop_int, status_mask = 0, int_mask = 0;
 
-	status_reg = readl(regs + INT_STATUS_REG);
-	mask_reg = readl(regs + INT_STATUS_MASK_REG);
+	status_reg = readl(tdm2c->regs + INT_STATUS_REG);
+	mask_reg = readl(tdm2c->regs + INT_STATUS_MASK_REG);
 
 	/* Refer only to unmasked bits */
 	status_stop_int = status_reg & mask_reg;
@@ -674,10 +709,10 @@ int tdm2c_pcm_stop_int_miss(void)
 	}
 
 	if (int_mask != 0) {
-		dev_err(pdev, "Stop Interrupt missing found STATUS=%x, MASK=%x\n", status_reg, mask_reg);
-		writel(~(status_mask), regs + INT_STATUS_REG);
-		writel(readl(regs + INT_STATUS_MASK_REG) & (~(int_mask)),
-		       regs + INT_STATUS_MASK_REG);
+		dev_err(tdm2c->dev, "Stop Interrupt missing found STATUS=%x, MASK=%x\n", status_reg, mask_reg);
+		writel(~(status_mask), tdm2c->regs + INT_STATUS_REG);
+		writel(readl(tdm2c->regs + INT_STATUS_MASK_REG) & (~(int_mask)),
+		       tdm2c->regs + INT_STATUS_MASK_REG);
 
 		return -EINVAL;
 	}
@@ -695,9 +730,9 @@ int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
 	u8 ch;
 
 	/* Read Status & mask registers */
-	status_reg = readl(regs + INT_STATUS_REG);
-	mask_reg = readl(regs + INT_STATUS_MASK_REG);
-	dev_dbg(pdev, "CAUSE(0x%x), MASK(0x%x)\n", status_reg, mask_reg);
+	status_reg = readl(tdm2c->regs + INT_STATUS_REG);
+	mask_reg = readl(tdm2c->regs + INT_STATUS_MASK_REG);
+	dev_dbg(tdm2c->dev, "CAUSE(0x%x), MASK(0x%x)\n", status_reg, mask_reg);
 
 	/* Refer only to unmasked bits */
 	status_and_mask = status_reg & mask_reg;
@@ -710,42 +745,42 @@ int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
 
 	/* Handle SLIC/DAA int */
 	if (status_and_mask & SLIC_INT_BIT) {
-		dev_dbg(pdev, "Phone interrupt !!!\n");
+		dev_dbg(tdm2c->dev, "Phone interrupt !!!\n");
 		tdm_intr_info->int_type |= MV_PHONE_INT;
 	}
 
 	if (status_and_mask & DMA_ABORT_BIT) {
-		dev_err(pdev, "DMA data abort. Address: 0x%08x, Info: 0x%08x\n",
-			readl(regs + DMA_ABORT_ADDR_REG),
-			readl(regs + DMA_ABORT_INFO_REG));
+		dev_err(tdm2c->dev, "DMA data abort. Address: 0x%08x, Info: 0x%08x\n",
+			readl(tdm2c->regs + DMA_ABORT_ADDR_REG),
+			readl(tdm2c->regs + DMA_ABORT_INFO_REG));
 		tdm_intr_info->int_type |= MV_DMA_ERROR_INT;
 	}
 
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
 
 		/* Give next buff to TDM and set curr buff as empty */
-		if ((status_and_mask & TX_BIT(ch)) && tdm_enable && !int_lock) {
-			dev_dbg(pdev, "Tx interrupt(ch%d)\n", ch);
+		if ((status_and_mask & TX_BIT(ch)) && tdm2c->enable && !tdm2c->int_lock) {
+			dev_dbg(tdm2c->dev, "Tx interrupt(ch%d)\n", ch);
 
-			int_tx_count++;
+			tdm2c->int_tx_count++;
 			if (ch == 0) {
-				int_tx0_count++;
-				if (int_tx0_count <= int_tx1_count) {
+				tdm2c->int_tx0_count++;
+				if (tdm2c->int_tx0_count <= tdm2c->int_tx1_count) {
 					int_tx_miss = 0;
-					int_tx0_miss++;
+					tdm2c->int_tx0_miss++;
 				}
 			} else {
-				int_tx1_count++;
-				if (int_tx1_count < int_tx0_count) {
+				tdm2c->int_tx1_count++;
+				if (tdm2c->int_tx1_count < tdm2c->int_tx0_count) {
 					int_tx_miss = 1;
-					int_tx1_miss++;
+					tdm2c->int_tx1_miss++;
 				}
 			}
 
 			/* 0 -> Tx is done for both channels */
 			if (tdm2c_ch_tx_low(ch) == 0) {
-				dev_dbg(pdev, "Assign Tx aggregate buffer for further processing\n");
-				tdm_intr_info->tdm_tx_buff = tx_aggr_buff_virt;
+				dev_dbg(tdm2c->dev, "Assign Tx aggregate buffer for further processing\n");
+				tdm_intr_info->tdm_tx_buff = tdm2c->tx_aggr_buff_virt;
 				tdm_intr_info->int_type |= MV_TX_INT;
 			}
 		}
@@ -753,28 +788,28 @@ int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
 
 	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
 
-		if ((status_and_mask & RX_BIT(ch)) && tdm_enable && !int_lock) {
-			dev_dbg(pdev, "Rx interrupt(ch%d)\n", ch);
+		if ((status_and_mask & RX_BIT(ch)) && tdm2c->enable && !tdm2c->int_lock) {
+			dev_dbg(tdm2c->dev, "Rx interrupt(ch%d)\n", ch);
 
-			int_rx_count++;
+			tdm2c->int_rx_count++;
 			if (ch == 0) {
-				int_rx0_count++;
-				if (int_rx0_count <= int_rx1_count) {
+				tdm2c->int_rx0_count++;
+				if (tdm2c->int_rx0_count <= tdm2c->int_rx1_count) {
 					int_rx_miss = 0;
-					int_rx0_miss++;
+					tdm2c->int_rx0_miss++;
 				}
 			} else {
-				int_rx1_count++;
-				if (int_rx1_count < int_rx0_count) {
+				tdm2c->int_rx1_count++;
+				if (tdm2c->int_rx1_count < tdm2c->int_rx0_count) {
 					int_rx_miss = 1;
-					int_rx1_miss++;
+					tdm2c->int_rx1_miss++;
 				}
 			}
 
 			/* 0 -> Rx is done for both channels */
 			if (tdm2c_ch_rx_low(ch) == 0) {
-				dev_dbg(pdev, "Assign Rx aggregate buffer for further processing\n");
-				tdm_intr_info->tdm_rx_buff = rx_aggr_buff_virt;
+				dev_dbg(tdm2c->dev, "Assign Rx aggregate buffer for further processing\n");
+				tdm_intr_info->tdm_rx_buff = tdm2c->rx_aggr_buff_virt;
 				tdm_intr_info->int_type |= MV_RX_INT;
 			}
 		}
@@ -784,80 +819,81 @@ int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
 
 		if (status_and_mask & TX_UNDERFLOW_BIT(ch)) {
 
-			dev_dbg(pdev, "Tx underflow(ch%d) - checking for root cause...\n",
+			dev_dbg(tdm2c->dev, "Tx underflow(ch%d) - checking for root cause...\n",
 				    ch);
-			if (tdm_enable) {
-				dev_dbg(pdev, "Tx underflow ERROR\n");
+			if (tdm2c->enable) {
+				dev_dbg(tdm2c->dev, "Tx underflow ERROR\n");
 				tdm_intr_info->int_type |= MV_TX_ERROR_INT;
 				if (!(status_and_mask & TX_BIT(ch))) {
 					ret = -1;
 					/* 0 -> Tx is done for both channels */
 					if (tdm2c_ch_tx_low(ch) == 0) {
-						dev_dbg(pdev, "Assign Tx aggregate buffer for further processing\n");
-						tdm_intr_info->tdm_tx_buff = tx_aggr_buff_virt;
+						dev_dbg(tdm2c->dev, "Assign Tx aggregate buffer for further processing\n");
+						tdm_intr_info->tdm_tx_buff = tdm2c->tx_aggr_buff_virt;
 						tdm_intr_info->int_type |= MV_TX_INT;
 					}
 				}
 			} else {
-				dev_dbg(pdev, "Expected Tx underflow(not an error)\n");
+				dev_dbg(tdm2c->dev, "Expected Tx underflow(not an error)\n");
 				tdm_intr_info->int_type |= MV_CHAN_STOP_INT;
 				/* Update number of channels already stopped */
-				tdm_intr_info->data = ++chan_stop_count;
-				writel(readl(regs + INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))),
-				       regs + INT_STATUS_MASK_REG);
+				tdm_intr_info->data = ++tdm2c->chan_stop_count;
+				writel(readl(tdm2c->regs + INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))),
+				       tdm2c->regs + INT_STATUS_MASK_REG);
 			}
 		}
 
 
 		if (status_and_mask & RX_OVERFLOW_BIT(ch)) {
-			dev_dbg(pdev, "Rx overflow(ch%d) - checking for root cause...\n", ch);
-			if (tdm_enable) {
-				dev_dbg(pdev, "Rx overflow ERROR\n");
+			dev_dbg(tdm2c->dev, "Rx overflow(ch%d) - checking for root cause...\n", ch);
+			if (tdm2c->enable) {
+				dev_dbg(tdm2c->dev, "Rx overflow ERROR\n");
 				tdm_intr_info->int_type |= MV_RX_ERROR_INT;
 				if (!(status_and_mask & RX_BIT(ch))) {
 					ret = -1;
 					/* 0 -> Rx is done for both channels */
 					if (tdm2c_ch_rx_low(ch) == 0) {
-						dev_dbg(pdev, "Assign Rx aggregate buffer for further processing\n");
-						tdm_intr_info->tdm_rx_buff = rx_aggr_buff_virt;
+						dev_dbg(tdm2c->dev, "Assign Rx aggregate buffer for further processing\n");
+						tdm_intr_info->tdm_rx_buff = tdm2c->rx_aggr_buff_virt;
 						tdm_intr_info->int_type |= MV_RX_INT;
 					}
 				}
 			} else {
-				dev_dbg(pdev, "Expected Rx overflow(not an error)\n");
+				dev_dbg(tdm2c->dev, "Expected Rx overflow(not an error)\n");
 				tdm_intr_info->int_type |= MV_CHAN_STOP_INT;
-				tdm_intr_info->data = ++chan_stop_count; /* Update number of channels already stopped */
-				writel(readl(regs + INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))),
-				       regs + INT_STATUS_MASK_REG);
+				/* Update number of channels already stopped */
+				tdm_intr_info->data = ++tdm2c->chan_stop_count;
+				writel(readl(tdm2c->regs + INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))),
+				       tdm2c->regs + INT_STATUS_MASK_REG);
 			}
 		}
 	}
 
 	/* clear TDM interrupts */
-	writel(~status_reg, regs + INT_STATUS_REG);
+	writel(~status_reg, tdm2c->regs + INT_STATUS_REG);
 
 	/* Check if interrupt was missed -> restart */
 	if  (int_tx_miss != -1)  {
-		dev_err(pdev, "Missing Tx Interrupt Detected ch%d!!!\n", int_tx_miss);
+		dev_err(tdm2c->dev, "Missing Tx Interrupt Detected ch%d!!!\n", int_tx_miss);
 		if (int_tx_miss)
-			int_tx1_count = int_tx0_count;
+			tdm2c->int_tx1_count = tdm2c->int_tx0_count;
 		else
-			int_tx0_count  = (int_tx1_count + 1);
+			tdm2c->int_tx0_count  = (tdm2c->int_tx1_count + 1);
 		ret = -1;
 	}
 
 	if  (int_rx_miss != -1)  {
-		dev_err(pdev, "Missing Rx Interrupt Detected ch%d!!!\n", int_rx_miss);
+		dev_err(tdm2c->dev, "Missing Rx Interrupt Detected ch%d!!!\n", int_rx_miss);
 		if (int_rx_miss)
-			int_rx1_count = int_rx0_count;
+			tdm2c->int_rx1_count = tdm2c->int_rx0_count;
 		else
-			int_rx0_count  = (int_rx1_count + 1);
+			tdm2c->int_rx0_count  = (tdm2c->int_rx1_count + 1);
 		ret = -1;
 	}
 
 	if (ret == -1) {
-		int_lock = 1;
-		pcm_restart_count++;
+		tdm2c->int_lock = true;
+		tdm2c->pcm_restart_count++;
 	}
 
 	return ret;
@@ -865,38 +901,38 @@ int tdm2c_intr_low(struct mv_phone_intr_info *tdm_intr_info)
 
 void tdm2c_intr_enable(void)
 {
-	writel((readl(regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC),
-	       regs + INT_STATUS_MASK_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) | TDM_INT_SLIC),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
 }
 
 void tdm2c_intr_disable(void)
 {
 	u32 val = ~TDM_INT_SLIC;
 
-	writel((readl(regs + INT_STATUS_MASK_REG) & val),
-	       regs + INT_STATUS_MASK_REG);
+	writel((readl(tdm2c->regs + INT_STATUS_MASK_REG) & val),
+	       tdm2c->regs + INT_STATUS_MASK_REG);
 }
 
 void tdm2c_pcm_if_reset(void)
 {
 	/* SW PCM reset assert */
-	mv_phone_reset_bit(regs + TDM_MISC_REG, 0x00000001);
+	mv_phone_reset_bit(tdm2c->regs + TDM_MISC_REG, 0x00000001);
 
 	mdelay(10);
 
 	/* SW PCM reset de-assert */
-	mv_phone_set_bit(regs + TDM_MISC_REG, 0x00000001);
+	mv_phone_set_bit(tdm2c->regs + TDM_MISC_REG, 0x00000001);
 
 	/* Wait a bit more - might be fine tuned */
 	mdelay(50);
 
-	dev_dbg(pdev, "%s: Exit\n", __func__);
+	dev_dbg(tdm2c->dev, "%s: Exit\n", __func__);
 }
 
 /* Debug routines */
 void tdm2c_reg_dump(u32 offset)
 {
-	dev_info(pdev, "0x%05x: %08x\n", offset, readl(regs + offset));
+	dev_info(tdm2c->dev, "0x%05x: %08x\n", offset, readl(tdm2c->regs + offset));
 }
 
 void tdm2c_regs_dump(void)
@@ -904,7 +940,7 @@ void tdm2c_regs_dump(void)
 	u8 i;
 	struct tdm2c_ch_info *ch_info;
 
-	dev_info(pdev, "TDM Control:\n");
+	dev_info(tdm2c->dev, "TDM Control:\n");
 	tdm2c_reg_dump(TDM_SPI_MUX_REG);
 	tdm2c_reg_dump(INT_RESET_SELECT_REG);
 	tdm2c_reg_dump(INT_STATUS_MASK_REG);
@@ -916,7 +952,7 @@ void tdm2c_regs_dump(void)
 	tdm2c_reg_dump(FRAME_TIMESLOT_REG);
 	tdm2c_reg_dump(DUMMY_RX_WRITE_DATA_REG);
 	tdm2c_reg_dump(MISC_CTRL_REG);
-	dev_info(pdev, "TDM Channel Control:\n");
+	dev_info(tdm2c->dev, "TDM Channel Control:\n");
 	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
 		tdm2c_reg_dump(CH_DELAY_CTRL_REG(i));
 		tdm2c_reg_dump(CH_SAMPLE_REG(i));
@@ -928,22 +964,22 @@ void tdm2c_regs_dump(void)
 		tdm2c_reg_dump(CH_TX_ADDR_REG(i));
 		tdm2c_reg_dump(CH_RX_ADDR_REG(i));
 	}
-	dev_info(pdev, "TDM interrupts:\n");
+	dev_info(tdm2c->dev, "TDM interrupts:\n");
 	tdm2c_reg_dump(INT_EVENT_MASK_REG);
 	tdm2c_reg_dump(INT_STATUS_MASK_REG);
 	tdm2c_reg_dump(INT_STATUS_REG);
 	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
-		dev_info(pdev, "ch%d info:\n", i);
-		ch_info = tdm_ch_info[i];
-		dev_info(pdev, "RX buffs:\n");
-		dev_info(pdev, "buff0: virt=%p phys=%p\n",
+		dev_info(tdm2c->dev, "ch%d info:\n", i);
+		ch_info = tdm2c->ch_info[i];
+		dev_info(tdm2c->dev, "RX buffs:\n");
+		dev_info(tdm2c->dev, "buff0: virt=%p phys=%p\n",
 			 ch_info->rxBuffVirt[0], (u32 *) (ch_info->rxBuffPhys[0]));
-		dev_info(pdev, "buff1: virt=%p phys=%p\n",
+		dev_info(tdm2c->dev, "buff1: virt=%p phys=%p\n",
 			 ch_info->rxBuffVirt[1], (u32 *) (ch_info->rxBuffPhys[1]));
-		dev_info(pdev, "TX buffs:\n");
-		dev_info(pdev, "buff0: virt=%p phys=%p\n",
+		dev_info(tdm2c->dev, "TX buffs:\n");
+		dev_info(tdm2c->dev, "buff0: virt=%p phys=%p\n",
 			 ch_info->txBuffVirt[0], (u32 *) (ch_info->txBuffPhys[0]));
-		dev_info(pdev, "buff1: virt=%p phys=%p\n",
+		dev_info(tdm2c->dev, "buff1: virt=%p phys=%p\n",
 			 ch_info->txBuffVirt[1], (u32 *) (ch_info->txBuffPhys[1]));
 	}
 }
@@ -951,17 +987,17 @@ void tdm2c_regs_dump(void)
 #ifdef CONFIG_MV_TDM_EXT_STATS
 void tdm2c_ext_stats_get(struct mv_phone_extended_stats *tdmExtStats)
 {
-	tdmExtStats->int_rx_count = int_rx_count;
-	tdmExtStats->int_tx_count = int_tx_count;
-	tdmExtStats->int_rx0_count = int_rx0_count;
-	tdmExtStats->int_tx0_count = int_tx0_count;
-	tdmExtStats->int_rx1_count = int_rx1_count;
-	tdmExtStats->int_tx1_count = int_tx1_count;
-	tdmExtStats->int_rx0_miss = int_rx0_miss;
-	tdmExtStats->int_tx0_miss = int_tx0_miss;
-	tdmExtStats->int_rx1_miss = int_rx1_miss;
-	tdmExtStats->int_tx1_miss = int_tx1_miss;
-	tdmExtStats->pcm_restart_count = pcm_restart_count;
+	tdmExtStats->int_rx_count = tdm2c->int_rx_count;
+	tdmExtStats->int_tx_count = tdm2c->int_tx_count;
+	tdmExtStats->int_rx0_count = tdm2c->int_rx0_count;
+	tdmExtStats->int_tx0_count = tdm2c->int_tx0_count;
+	tdmExtStats->int_rx1_count = tdm2c->int_rx1_count;
+	tdmExtStats->int_tx1_count = tdm2c->int_tx1_count;
+	tdmExtStats->int_rx0_miss = tdm2c->int_rx0_miss;
+	tdmExtStats->int_tx0_miss = tdm2c->int_tx0_miss;
+	tdmExtStats->int_rx1_miss = tdm2c->int_rx1_miss;
+	tdmExtStats->int_tx1_miss = tdm2c->int_tx1_miss;
+	tdmExtStats->pcm_restart_count = tdm2c->pcm_restart_count;
 }
 #endif
 
diff --git a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
index 188b652..02fd35a 100644
--- a/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
+++ b/drivers/telephony/mvebu_phone/tdm2c/tdm2c.h
@@ -326,7 +326,6 @@
 #define MV_TDM_CS			0
 #define BUFF_INVALID			-1
 
-/* Structures */
 /* TDM channel info structure */
 struct tdm2c_ch_info {
 	u8 ch;
-- 
1.7.9.5


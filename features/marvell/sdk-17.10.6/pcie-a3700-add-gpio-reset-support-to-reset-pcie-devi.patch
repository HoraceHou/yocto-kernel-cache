From 2315425304cb276325275bdd26852ae41ba2313e Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Mon, 16 Jan 2017 17:50:54 +0800
Subject: [PATCH 0795/1345] pcie: a3700: add gpio reset support to reset pcie
 device

commit  beabe8edd3709f850f1bd0bcac0a721756b9d90d from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- currently the gpio reset of pcie is done in uboot driver,
  if the uboot driver does not work, the kernel pcie also not work.
- in order to eliminate dependency, it is necessary to add the gpio
  reset config in kernel driver.
- the patch will config the gpio reset if it is sepcified in dts

Change-Id: Ie5db139a2c961286508e97195d1d0f54af286287
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35608
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/host/pci-aardvark.c |   56 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 55 insertions(+), 1 deletion(-)

diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
index e73074c..c71d292 100644
--- a/drivers/pci/host/pci-aardvark.c
+++ b/drivers/pci/host/pci-aardvark.c
@@ -23,6 +23,7 @@
 #include <linux/of_address.h>
 #include <linux/of_pci.h>
 #include <linux/phy/phy.h>
+#include <linux/of_gpio.h>
 
 /* PCIe core registers */
 #define PCIE_CORE_CMD_STATUS_REG				0x4
@@ -206,6 +207,8 @@ struct advk_pcie {
 	struct mutex msi_used_lock;
 	u16 msi_msg;
 	int root_bus_nr;
+	char *reset_name;
+	struct gpio_desc *reset_gpio;
 };
 
 static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)
@@ -887,6 +890,8 @@ static int advk_pcie_probe(struct platform_device *pdev)
 	struct phy *comphy;
 	struct device_node *dn = pdev->dev.of_node;
 	int ret, irq;
+	enum of_gpio_flags flags;
+	int reset_gpio;
 
 	pcie = devm_kzalloc(dev, sizeof(struct advk_pcie), GFP_KERNEL);
 	if (!pcie)
@@ -931,12 +936,61 @@ static int advk_pcie_probe(struct platform_device *pdev)
 		return PTR_ERR(clk);
 	}
 
+	/* Config reset gpio for pcie */
+	reset_gpio = of_get_named_gpio_flags(dn, "reset-gpios", 0, &flags);
+	if (reset_gpio != -EPROBE_DEFER) {
+		pcie->reset_gpio = gpio_to_desc(reset_gpio);
+		if (gpio_is_valid(reset_gpio)) {
+			unsigned long gpio_flags;
+
+			/* WA: to avoid reset fail, set the reset gpio to low first */
+			gpiod_direction_output(pcie->reset_gpio, 0);
+
+			/* Enable pcie clock and after 200ms to reset pcie */
+			ret = clk_prepare_enable(clk);
+			if (ret) {
+				dev_err(&pdev->dev, "Failed to enable clock\n");
+				return ret;
+			}
+			mdelay(200);
+
+			/* Set GPIO for pcie reset */
+			pcie->reset_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%s-reset",
+							  pdev->name);
+			if (!pcie->reset_name) {
+				ret = -ENOMEM;
+				dev_err(&pdev->dev, "devm_kasprintf failed\n");
+				return ret;
+			}
+
+			if (flags & OF_GPIO_ACTIVE_LOW) {
+				dev_info(&pdev->dev, "%s: reset gpio is active low\n",
+					 of_node_full_name(dn));
+				gpio_flags = GPIOF_ACTIVE_LOW |
+					     GPIOF_OUT_INIT_LOW;
+			} else {
+				gpio_flags = GPIOF_OUT_INIT_HIGH;
+			}
+
+			ret = devm_gpio_request_one(&pdev->dev, reset_gpio, gpio_flags,
+						    pcie->reset_name);
+			if (ret) {
+				dev_err(&pdev->dev,
+					"gpio_request for gpio failed, err = %d\n",
+					ret);
+				return ret;
+			}
+			/* continue init flow after pcie reset */
+			goto after_pcie_reset;
+		}
+	}
+
 	ret = clk_prepare_enable(clk);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to enable clock\n");
 		return ret;
 	}
-
+after_pcie_reset:
 	ret = advk_pcie_parse_request_of_pci_ranges(pcie);
 	if (ret) {
 		dev_err(dev, "Failed to parse resources\n");
-- 
1.7.9.5


From e76bfb10143035f82479f15d66578a94606f6244 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Fri, 1 Dec 2017 12:06:42 +0800
Subject: [PATCH 1250/1345] fix: clk: mvebu: cp110: always enable gate MG
 clock 5

commit  16832e28f0e8248836d9153b0044e7e821acd2fa from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Gate clock 5 together with gate clock 6 feed XSMI and CM3 for
KR-AP in CP110. If ppv2 ports on CP0 connected to XSMI on CP1
and there are no enabled ppv2 ports on CP1. XSMI won't be enabled.
This will cause system stuck during access to XSMI address space.
Also the CM3 clock should be enabled, otherwise it will cause
system stuck when CM3 starts the execution.

This is a workaround, the complete solution should be nesting all
clock providers and consumers in the CP110 driver.

Change-Id: I032a8d18d705fa3e1402e330f4d11b90e56c2ae6
Signed-off-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/47119
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
(cherry picked from commit 5cb600f45503ba4eb8332a10d3b950aa1255d5b5)
Reviewed-on: http://vgitil04.il.marvell.com:8080/47587
Reviewed-by: Igal Liberman <igall@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/clk/mvebu/cp110-system-controller.c |   18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/clk/mvebu/cp110-system-controller.c b/drivers/clk/mvebu/cp110-system-controller.c
index 50abab0..22b30e4 100644
--- a/drivers/clk/mvebu/cp110-system-controller.c
+++ b/drivers/clk/mvebu/cp110-system-controller.c
@@ -392,12 +392,14 @@ static int cp110_syscon_common_probe(struct platform_device *pdev,
 	}
 
 	/*
-	 * Gated clocks 18 and 6 feeds many core clocks in CP110.
+	 * Gated clocks 18, 6 and 5 feed many core clocks in CP110.
 	 * Clock 18 feeds eMMC clock. eMMC driver supports only one clock - the core
 	 * clock of eMMC) so we need to enable clock 18 in CP110 clock level
 	 * and not the eMMC driver itself.
-	 * Gated clock 6 feeds XSMI clock. If ppv2 ports on CP0 connected
+	 * Gated clock 6 and 5 feed XSMI clock and CM3 for KR-AP. If ppv2 ports on CP0 connected
 	 * to XSMI on CP1 and there are no enabled ppv2 ports on CP1. XSMI won't be enabled.
+	 * The CM3 clock should also be enabled, otherwise it will lead to stuck when CM3
+	 * is executing application.
 	 * TODO:
 	 * This is a workaround, the complete solution should be nesting all
 	 * clock providers and consumers in the CP110 driver. One possible
@@ -405,20 +407,26 @@ static int cp110_syscon_common_probe(struct platform_device *pdev,
 	 * use this clock, this clock will be still enabled.
 	 */
 	if (cp110_clks[CP110_MAX_CORE_CLOCKS + CP110_GATE_SDMMC_GOP]) {
-		ret = clk_prepare_enable(cp110_clks[CP110_MAX_CORE_CLOCKS +
+		ret = cp110_gate_enable(cp110_clks[CP110_MAX_CORE_CLOCKS +
 						    CP110_GATE_SDMMC_GOP]);
 		if (ret)
 			goto fail_clk_add;
-
 	}
 
 	if (cp110_clks[CP110_MAX_CORE_CLOCKS + CP110_GATE_MG_CORE]) {
-		ret = clk_prepare_enable(cp110_clks[CP110_MAX_CORE_CLOCKS +
+		ret = cp110_gate_enable(cp110_clks[CP110_MAX_CORE_CLOCKS +
 						    CP110_GATE_MG_CORE]);
 		if (ret)
 			goto fail_clk_add;
 	}
 
+	if (cp110_clks[CP110_MAX_CORE_CLOCKS + CP110_GATE_MG]) {
+		ret = cp110_gate_enable(cp110_clks[CP110_MAX_CORE_CLOCKS +
+						    CP110_GATE_MG]);
+		if (ret)
+			goto fail_clk_add;
+	}
+
 	ret = of_clk_add_hw_provider(np, cp110_of_clk_get, cp110_clk_data);
 	if (ret)
 		goto fail_clk_add;
-- 
1.7.9.5


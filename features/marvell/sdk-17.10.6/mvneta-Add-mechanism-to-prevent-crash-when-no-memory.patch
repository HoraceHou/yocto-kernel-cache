From ec63e0b34fe058e91d9b6d191d7ae9a0e813494d Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Tue, 24 May 2016 14:12:43 +0300
Subject: [PATCH 0258/1345] mvneta: Add mechanism to prevent crash when no
 memory

commit  a008ab4bff62a2add3d665b9531522646ea000c7 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- Add cleanup timer to refill missed buffers
- Stop further refill to prevent crash

Change-Id: I6198b44796e1ce18200d1469e8a783647549dcb0
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29928
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvneta.c |  127 ++++++++++++++++++++++++++++++---
 1 file changed, 119 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index baa4678..654f6ff 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -379,6 +379,8 @@ struct mvneta_pcpu_port {
 	u32			cause_rx_tx;
 };
 
+#define MVNETA_PORT_F_CLEANUP_TIMER_BIT  0
+
 struct mvneta_port {
 	u8 id;
 	struct mvneta_pcpu_port __percpu	*ports;
@@ -432,6 +434,10 @@ struct mvneta_port {
 	bool neta_armada3700;
 	u16 rx_offset_correction;
 	const struct mbus_dram_target_info *dram_target_info;
+
+	/* Timer to refill missed buffers */
+	struct timer_list   cleanup_timer;
+	unsigned long flags;
 };
 
 /* The mvneta_tx_desc and mvneta_rx_desc structures describe the
@@ -573,7 +579,9 @@ struct mvneta_rx_queue {
 	int size;
 
 	/* counter of times when mvneta_refill() failed */
-	int missed;
+	atomic_t missed;
+	atomic_t refill_stop;
+	struct mvneta_rx_desc *missed_desc;
 
 	u32 pkts_coal;
 	u32 time_coal;
@@ -770,6 +778,20 @@ static void mvneta_rxq_desc_num_update(struct mvneta_port *pp,
 	}
 }
 
+/* Return pointer to the following rx desc */
+static inline struct mvneta_rx_desc *
+mvneta_rxq_next_desc_ptr(struct mvneta_rx_queue *rxq, struct mvneta_rx_desc *rx_desc)
+{
+	struct mvneta_rx_desc *next_desc;
+
+	if (rx_desc == (rxq->descs + rxq->last_desc))
+		next_desc = rxq->descs;
+	else
+		next_desc = ++rx_desc;
+
+	return next_desc;
+}
+
 /* Get pointer to next RX descriptor to be processed by SW */
 static struct mvneta_rx_desc *
 mvneta_rxq_next_desc_get(struct mvneta_rx_queue *rxq)
@@ -1892,6 +1914,69 @@ static u32 mvneta_skb_tx_csum(struct mvneta_port *pp, struct sk_buff *skb)
 	return MVNETA_TX_L4_CSUM_NOT;
 }
 
+/* Add cleanup timer to refill missed buffer */
+static inline void mvneta_add_cleanup_timer(struct mvneta_port *pp)
+{
+	if (test_and_set_bit(MVNETA_PORT_F_CLEANUP_TIMER_BIT, &pp->flags) == 0) {
+		pp->cleanup_timer.expires = jiffies + ((HZ * 10) / 1000); /* ms */
+		add_timer_on(&pp->cleanup_timer, smp_processor_id());
+	}
+}
+
+/***********************************************************
+ * mvneta_cleanup_timer_callback --			   *
+ *   N msec periodic callback for error cleanup            *
+ ***********************************************************/
+static void mvneta_cleanup_timer_callback(unsigned long data)
+{
+	struct mvneta_port *pp = (struct mvneta_port *)data;
+	struct mvneta_rx_desc *rx_desc;
+	int refill_num, queue, err;
+
+	clear_bit(MVNETA_PORT_F_CLEANUP_TIMER_BIT, &pp->flags);
+
+	if (!netif_running(pp->dev))
+		return;
+
+	/* alloc new skb with rxq_ctrl.missed, attach it with rxq_desc and valid the desc again */
+	for (queue = 0; queue < rxq_number; queue++) {
+		struct mvneta_rx_queue *rxq = &pp->rxqs[queue];
+
+		if (!atomic_read(&rxq->missed))
+			continue;
+
+		rx_desc = rxq->missed_desc;
+		refill_num = 0;
+
+		/* Allocate memory, refill */
+		while (atomic_read(&rxq->missed)) {
+			err = mvneta_rx_refill(pp, rx_desc);
+			if (err) {
+				/* update missed_desc and restart timer */
+				rxq->missed_desc = rx_desc;
+				mvneta_add_cleanup_timer(pp);
+				break;
+			}
+			atomic_dec(&rxq->missed);
+			/* Get pointer to next rx desc */
+			rx_desc = mvneta_rxq_next_desc_ptr(rxq, rx_desc);
+			refill_num++;
+		}
+
+		/* Update RxQ management counters */
+		if (refill_num) {
+			mvneta_rxq_desc_num_update(pp, rxq, 0, refill_num);
+
+			/* Update refill stop flag */
+			if (!atomic_read(&rxq->missed))
+				atomic_set(&rxq->refill_stop, 0);
+
+			pr_debug("%s: %d buffers refilled to rxq #%d - missed = %d\n",
+				 __func__, refill_num, rxq->id, atomic_read(&rxq->missed));
+		}
+	}
+}
+
 /* Drop packets received by the RXQ and free buffers */
 static void mvneta_rxq_drop_pkts(struct mvneta_port *pp,
 				 struct mvneta_rx_queue *rxq)
@@ -1933,7 +2018,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 {
 	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
 	struct net_device *dev = pp->dev;
-	int rx_done;
+	int rx_done, rx_filled;
 	u32 rcvd_pkts = 0;
 	u32 rcvd_bytes = 0;
 
@@ -1944,6 +2029,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 		rx_todo = rx_done;
 
 	rx_done = 0;
+	rx_filled = 0;
 
 	/* Fairness NAPI loop */
 	while (rx_done < rx_todo) {
@@ -1967,6 +2053,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 			dev->stats.rx_errors++;
 			mvneta_rx_error(pp, rx_desc);
 			/* leave the descriptor untouched */
+			rx_filled++;
 			continue;
 		}
 
@@ -1999,6 +2086,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 			rcvd_bytes += rx_bytes;
 
 			/* leave the descriptor and buffer untouched */
+			rx_filled++;
 			continue;
 		}
 
@@ -2018,11 +2106,27 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 				 DMA_FROM_DEVICE);
 
 		/* Refill processing */
-		err = mvneta_rx_refill(pp, rx_desc, rxq);
-		if (err) {
-			netdev_err(dev, "Linux processing - Can't refill\n");
-			rxq->missed++;
-			goto err_drop_frame;
+		if (!atomic_read(&rxq->refill_stop)) {
+			err = mvneta_rx_refill(pp, rx_desc, rxq);
+			if (err) {
+				netdev_err(dev, "Linux processing - Can't refill\n");
+				/* set refill stop flag */
+				atomic_set(&rxq->refill_stop, 1);
+
+				atomic_inc(&rxq->missed);
+
+				/* record the first rx desc refilled failure */
+				rxq->missed_desc = rx_desc;
+
+				/* add cleanup timer */
+				mvneta_add_cleanup_timer(pp);
+			} else {
+				/* successful refill */
+				rx_filled++;
+			}
+		} else {
+			/* refill already stopped - only update missed counter */
+			atomic_inc(&rxq->missed);
 		}
 
 		rcvd_pkts++;
@@ -2049,7 +2153,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
 	}
 
 	/* Update rxq management counters */
-	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);
+	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_filled);
 
 	return rx_done;
 }
@@ -4038,6 +4142,8 @@ static int mvneta_init(struct device *dev, struct mvneta_port *pp)
 		rxq->size = pp->rx_ring_size;
 		rxq->pkts_coal = MVNETA_RX_COAL_PKTS;
 		rxq->time_coal = MVNETA_RX_COAL_USEC;
+		atomic_set(&rxq->missed, 0);
+		atomic_set(&rxq->refill_stop, 0);
 		rxq->buf_virt_addr
 			= devm_kmalloc_array(pp->dev->dev.parent,
 					     rxq->size,
@@ -4376,6 +4482,11 @@ static int mvneta_probe(struct platform_device *pdev)
 		put_device(&phy->mdio.dev);
 	}
 
+	/* Initialize cleanup */
+	init_timer(&pp->cleanup_timer);
+	pp->cleanup_timer.function = mvneta_cleanup_timer_callback;
+	pp->cleanup_timer.data = (unsigned long)pp;
+
 	return 0;
 
 err_netdev:
-- 
1.7.9.5


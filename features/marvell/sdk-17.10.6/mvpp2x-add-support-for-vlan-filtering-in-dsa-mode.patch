From 40c1d758bef4f98925861d279b7bbaab63454413 Mon Sep 17 00:00:00 2001
From: Alan Winkowski <walan@marvell.com>
Date: Mon, 16 Oct 2017 18:59:10 +0300
Subject: [PATCH 1246/1345] mvpp2x: add support for vlan filtering in dsa mode

commit  562bb676b8a49206b857a55fe23a293b4929e4f6 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- Previous implementation of vlan filtering worked only
  when the port is not set to DSA mode
- This patch enables vlan filtering also when the port
  is set to DSA mode or extended DSA mode
- Fixes A7K8K-3443

Change-Id: Ib2baa1ed897d6e85c6197bbfddccf82f9088b662
Signed-off-by: Alan Winkowski <walan@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/45228
Reviewed-by: Stefan Chulski <stefanc@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Yuval Caduri <cyuval@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/46857
Reviewed-by: Nir Erez <nerez@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c   |   99 ++++++++++++++++----
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |   46 +++++----
 2 files changed, 112 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
index 48e84a3..c998639 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
@@ -1033,10 +1033,6 @@ static void mv_pp2x_prs_dsa_tag_set(struct mv_pp2x_hw *hw, int port, bool add,
 		mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_DSA);
 		pe.index = tid;
 
-		/* Shift 4 bytes if DSA tag or 8 bytes in case of EDSA tag*/
-		mv_pp2x_prs_sram_shift_set(&pe, shift,
-					   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
-
 		/* Update shadow table */
 		mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_DSA);
 
@@ -1045,12 +1041,26 @@ static void mv_pp2x_prs_dsa_tag_set(struct mv_pp2x_hw *hw, int port, bool add,
 			mv_pp2x_prs_tcam_data_byte_set(&pe, 0,
 						       MVPP2_PRS_TCAM_DSA_TAGGED_BIT,
 					MVPP2_PRS_TCAM_DSA_TAGGED_BIT);
-			/* Clear all ai bits for next iteration */
-			mv_pp2x_prs_sram_ai_update(&pe, 0,
-						   MVPP2_PRS_SRAM_AI_MASK);
-			/* If packet is tagged continue check vlans */
-			mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_VLAN);
+
+			/* Set ai bits for next iteration */
+			if (extend)
+				mv_pp2x_prs_sram_ai_update(&pe, 1,
+							   MVPP2_PRS_SRAM_AI_MASK);
+			else
+				mv_pp2x_prs_sram_ai_update(&pe, 0,
+							   MVPP2_PRS_SRAM_AI_MASK);
+
+			/* Set result info bits to 'single vlan' */
+			mv_pp2x_prs_sram_ri_update(&pe, MVPP2_PRS_RI_VLAN_SINGLE,
+						   MVPP2_PRS_RI_VLAN_MASK);
+
+			/* If packet is tagged continue check vid filtering */
+			mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_VID);
 		} else {
+			/* Shift 4 bytes if DSA tag or 8 bytes in case of EDSA tag*/
+			mv_pp2x_prs_sram_shift_set(&pe, shift,
+						   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
 			/* Set result info bits to 'no vlans' */
 			mv_pp2x_prs_sram_ri_update(&pe, MVPP2_PRS_RI_VLAN_NONE,
 						   MVPP2_PRS_RI_VLAN_MASK);
@@ -2080,8 +2090,15 @@ static void mv_pp2x_prs_vid_init(struct mv_pp2x_hw *hw)
 	pe.index = MVPP2_PE_VID_FLTR_DEFAULT;
 	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VID);
 
+	mv_pp2x_prs_tcam_ai_update(&pe, 0,
+				   MVPP2_PRS_EDSA_VID_AI_BIT);
+
 	/* Skip VLAN header - Set offset to 4 bytes */
-	mv_pp2x_prs_sram_shift_set(&pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+	mv_pp2x_prs_sram_shift_set(&pe, MVPP2_VLAN_TAG_LEN,
+				   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Clear all ai bits for next iteration */
+	mv_pp2x_prs_sram_ai_update(&pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 
 	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_L2);
 
@@ -2091,6 +2108,33 @@ static void mv_pp2x_prs_vid_init(struct mv_pp2x_hw *hw)
 	/* Update shadow table and hw entry */
 	mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_VID);
 	mv_pp2x_prs_hw_write(hw, &pe);
+
+	/* Set default vid entry for extended DSA*/
+	memset(&pe, 0, sizeof(struct mv_pp2x_prs_entry));
+
+	/* Set default vid  entry */
+	pe.index = MVPP2_PE_VID_EDSA_FLTR_DEFAULT;
+	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VID);
+
+	mv_pp2x_prs_tcam_ai_update(&pe, MVPP2_PRS_EDSA_VID_AI_BIT,
+				   MVPP2_PRS_EDSA_VID_AI_BIT);
+
+	/* Skip VLAN header - Set offset to 8 bytes */
+	mv_pp2x_prs_sram_shift_set(&pe, MVPP2_VLAN_TAG_EDSA_LEN,
+				   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Clear all ai bits for next iteration */
+	mv_pp2x_prs_sram_ai_update(&pe, 0, MVPP2_PRS_SRAM_AI_MASK);
+
+	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_L2);
+
+	/* Unmask all ports */
+	mv_pp2x_prs_tcam_port_map_set(&pe, MVPP2_PRS_PORT_MASK);
+
+	/* Update shadow table and hw entry */
+	mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, &pe);
+
 }
 
 /* Set entries for PPPoE ethertype */
@@ -2662,7 +2706,10 @@ void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
 }
 
 /* Write parser entry for default VID filtering */
-static int mv_pp2x_prs_vid_drop_entry_accept(struct net_device *dev, unsigned int tid, bool add)
+static int mv_pp2x_prs_vid_drop_entry_accept(struct net_device *dev,
+					     unsigned int tid,
+					     unsigned int shift,
+					     bool add)
 {
 	struct mv_pp2x_prs_entry *pe;
 	unsigned int pmap;
@@ -2706,10 +2753,13 @@ static int mv_pp2x_prs_vid_drop_entry_accept(struct net_device *dev, unsigned in
 	/* Continue - set next lookup */
 	mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
 
+	/* Skip VLAN header - Set offset to 4 or 8 bytes */
+	mv_pp2x_prs_sram_shift_set(pe, shift, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
 	mv_pp2x_prs_sram_ri_update(pe, MVPP2_PRS_RI_DROP_MASK, MVPP2_PRS_RI_DROP_MASK);
 
-	/* Skip VLAN header - Set offset to 4 bytes */
-	mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+	/* Clear all ai bits for next iteration */
+	mv_pp2x_prs_sram_ai_update(pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 
 	/* Update shadow table */
 	mv_pp2x_prs_shadow_set(hw, pe->index, MVPP2_PRS_LU_VID);
@@ -2780,6 +2830,7 @@ int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, boo
 	bool empty = false;
 	unsigned int pmap;
 	unsigned int mask = 0xfff;
+	unsigned int reg_val, shift;
 	struct mv_pp2x_port *port = netdev_priv(dev);
 	struct mv_pp2x_hw *hw = &port->priv->hw;
 	unsigned int vid_start = MVPP2_PE_VID_FILT_RANGE_START + port->id * MVPP2_PRS_VLAN_FILT_MAX;
@@ -2791,6 +2842,13 @@ int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, boo
 		/*no need to add vid 0 to HW*/
 		return 0;
 
+	/* Check configured start header */
+	reg_val = mv_pp2x_read(hw, MVPP2_MH_REG(port->id));
+	if (reg_val & MVPP2_DSA_EXTENDED)
+		shift = MVPP2_VLAN_TAG_EDSA_LEN;
+	else
+		shift = MVPP2_VLAN_TAG_LEN;
+
 	/* No such entry */
 	if (!pe) {
 		if (!add)
@@ -2798,7 +2856,9 @@ int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, boo
 
 		empty = mv_pp2x_prs_tcam_vid_empty(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX_ENTRY);
 		if (empty) {
-			rc = mv_pp2x_prs_vid_drop_entry_accept(dev, vid_start + MVPP2_PRS_VLAN_FILT_DFLT_ENTRY, true);
+			rc = mv_pp2x_prs_vid_drop_entry_accept(dev,
+							       vid_start + MVPP2_PRS_VLAN_FILT_DFLT_ENTRY,
+							       shift, true);
 			if (rc) {
 				netdev_err(dev, "failed to add default vid entry for non-match vlan packets (drop)\n");
 				return rc;
@@ -2837,7 +2897,9 @@ int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, boo
 		hw->prs_shadow[pe->index].valid = false;
 		empty = mv_pp2x_prs_tcam_vid_empty(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX_ENTRY);
 		if (empty) {
-			rc = mv_pp2x_prs_vid_drop_entry_accept(dev, vid_start + MVPP2_PRS_VLAN_FILT_DFLT_ENTRY, false);
+			rc = mv_pp2x_prs_vid_drop_entry_accept(dev,
+							       vid_start + MVPP2_PRS_VLAN_FILT_DFLT_ENTRY,
+							       shift, false);
 			if (rc) {
 				netdev_err(dev, "failed to remove default vid for non-match vlan packets (drop)\n");
 				return rc;
@@ -2850,11 +2912,14 @@ int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, boo
 	/* Continue - set next lookup */
 	mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
 
+	/* Skip VLAN header - Set offset to 4 or 8 bytes */
+	mv_pp2x_prs_sram_shift_set(pe, shift, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
 	/* Set match on VID */
 	mv_pp2x_prs_match_vid(pe, MVPP2_PRS_VID_TCAM_BYTE, vid);
 
-	/* Skip VLAN header - Set offset to 4 bytes */
-	mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+	/* Clear all ai bits for next iteration */
+	mv_pp2x_prs_sram_ai_update(pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 
 	/* Update shadow table */
 	mv_pp2x_prs_shadow_set(hw, pe->index, MVPP2_PRS_LU_VID);
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index f0c7495..ec14bcb 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -38,7 +38,6 @@
 /*TODO*/
 /*AXI_BRIDGE*/
 /*AXI_CONTEXT*/
-/*Top Regfile*/
 
 #define MVPP21_DESC_ADDR_SHIFT		0 /*Applies to RXQ, AGGR_TXQ*/
 #define MVPP22_DESC_ADDR_SHIFT		(9 - 1) /*Applies to RXQ, AGGR_TXQ*/
@@ -157,6 +156,18 @@
 #define MVPP22_AXI_CODE_DOMAIN_SYSTEM		3
 #define MVPP22_AXI_CODE_DOMAIN_NON_SHARE	0
 
+/* Top Reg file */
+#define MVPP2_MH_REG(port)			(0x5040 + 4 * (port))
+
+#define MVPP2_MH_EN_OFFS			0
+#define MVPP2_MH_EN_MASK			BIT(MVPP2_MH_EN_OFFS)
+
+#define MVPP2_DSA_EN_OFFS			4
+#define MVPP2_DSA_EN_MASK			(0x3 << MVPP2_DSA_EN_OFFS)
+#define MVPP2_DSA_DISABLE			0
+#define MVPP2_DSA_NON_EXTENDED			(0x1 << MVPP2_DSA_EN_OFFS)
+#define MVPP2_DSA_EXTENDED			(0x2 << MVPP2_DSA_EN_OFFS)
+
 /* Parser Registers */
 #define MVPP2_PRS_INIT_LOOKUP_REG		0x1000
 #define MVPP2_PRS_PORT_LU_MAX			0xf
@@ -1167,6 +1178,7 @@
 #define MVPP2_ETH_TYPE_LEN		2
 #define MVPP2_PPPOE_HDR_SIZE		8
 #define MVPP2_VLAN_TAG_LEN		4
+#define MVPP2_VLAN_TAG_EDSA_LEN		8
 
 /* Lbtd 802.3 type */
 #define MVPP2_IP_LBDT_TYPE		0xfffa
@@ -1365,21 +1377,22 @@ enum mv_pp2x_tag_type {
 #define MVPP2_PE_IP6_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 28)
 #define MVPP2_PE_IP4_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 27)
 #define MVPP2_PE_LAST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 26)
-#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 20)
-#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 19)
-#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 18)
-#define MVPP2_PE_DSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 17)
-#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 16)
-#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 15)
-#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
-#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
-#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
-#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
-#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 10)
-#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 9)
-#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
-#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
-#define MVPP2_PE_VID_FLTR_DEFAULT	(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
+#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 21)
+#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 20)
+#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 19)
+#define MVPP2_PE_DSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 18)
+#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 17)
+#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 16)
+#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 15)
+#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
+#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
+#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
+#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
+#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 10)
+#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 9)
+#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
+#define MVPP2_PE_VID_FLTR_DEFAULT	(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
+#define MVPP2_PE_VID_EDSA_FLTR_DEFAULT	(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
 #define MVPP2_PE_VLAN_DBL		(MVPP2_PRS_TCAM_SRAM_SIZE - 5)
 #define MVPP2_PE_VLAN_NONE		(MVPP2_PRS_TCAM_SRAM_SIZE - 4)
 #define MVPP2_PE_MAC_MC_PROMISCUOUS	(MVPP2_PRS_TCAM_SRAM_SIZE - 3)
@@ -1480,6 +1493,7 @@ enum mv_pp2x_tag_type {
 #define MVPP2_PRS_IPV6_EXT_AH_L4_AI_BIT		BIT(4)
 #define MVPP2_PRS_SINGLE_VLAN_AI		0
 #define MVPP2_PRS_DBL_VLAN_AI_BIT		BIT(7)
+#define MVPP2_PRS_EDSA_VID_AI_BIT		BIT(0)
 
 #define MVPP2_PRS_SRAM_SHIFT_MASK		((1 << \
 					MVPP2_PRS_SRAM_SHIFT_BITS) - 1)
-- 
1.7.9.5


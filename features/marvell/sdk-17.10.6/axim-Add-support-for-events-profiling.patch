From 4ab513c6c82ebad29f733db74c95772ba0b7f87a Mon Sep 17 00:00:00 2001
From: Shadi Ammouri <shadi@marvell.com>
Date: Tue, 16 Aug 2016 17:57:14 +0300
Subject: [PATCH 0444/1345] axim: Add support for events profiling

commit  63cae366130e04e205a882966a310d81bcee2802 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This enables collecting various profiling counters on the transactions,
like bandwidth, max / min / avg latency...

Change-Id: I3f6576793928692337ed34b6c32fd20adea46746
Signed-off-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/31990
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../hwtracing/coresight/coresight-axi-monitor.c    |  159 +++++++++++++++++++-
 .../hwtracing/coresight/coresight-axi-monitor.h    |   23 +++
 2 files changed, 179 insertions(+), 3 deletions(-)

diff --git a/drivers/hwtracing/coresight/coresight-axi-monitor.c b/drivers/hwtracing/coresight/coresight-axi-monitor.c
index df17889..6f0928a 100644
--- a/drivers/hwtracing/coresight/coresight-axi-monitor.c
+++ b/drivers/hwtracing/coresight/coresight-axi-monitor.c
@@ -21,6 +21,7 @@
 #include <linux/err.h>
 #include <linux/coresight.h>
 #include <linux/amba/bus.h>
+#include <linux/delay.h>
 #include "coresight-axi-monitor.h"
 
 static int boot_enable;
@@ -338,6 +339,140 @@ static ssize_t mon_enable_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(mon_enable);
 
+
+static ssize_t prof_enable_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	unsigned long val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	val = readl(axim->base + AXI_MON_PR_CTL);
+	val = (val >> AXI_MON_PROF_EN_OFF) & 0x1;
+	return scnprintf(buf, PAGE_SIZE, "%ld\n", val);
+}
+
+static ssize_t prof_enable_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t size)
+{
+	unsigned long reg, val;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+
+	if (!axim->prof_en)
+		return -EPERM;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	reg = readl(axim->base + AXI_MON_PR_CTL);
+	if (val) {
+		reg |= (1 << AXI_MON_PROF_EN_OFF);
+		reg &= ~(AXI_MON_PROF_CYCG_MASK	<< AXI_MON_PROF_CYCG_OFF);
+		reg |= (AXI_MON_PROF_CYCG_4_CYC	<< AXI_MON_PROF_CYCG_OFF);
+		if (AXI_MON_PROF_CYCG_4_CYC != 0)
+			axim->prof_cyc_mul = 1 << (AXI_MON_PROF_CYCG_4_CYC + 1);
+		else
+			axim->prof_cyc_mul = 1;
+	} else {
+		reg &= ~(1 << AXI_MON_PROF_EN_OFF);
+	}
+	writel(reg, axim->base + AXI_MON_PR_CTL);
+
+	return size;
+}
+static DEVICE_ATTR_RW(prof_enable);
+
+static char *memfmt(char *buf, unsigned long n)
+{
+	if (n >= (1UL << 30))
+		sprintf(buf, "%lu GB", n >> 30);
+	else if (n >= (1UL << 20))
+		sprintf(buf, "%lu MB", n >> 20);
+	else
+		sprintf(buf, "%lu KB", n >> 10);
+	return buf;
+}
+
+
+static ssize_t prof_counters_show(struct device *dev,
+		       struct device_attribute *attr,
+		       char *buf)
+{
+	int timeout = 100;
+	ssize_t size = 0;
+	uint32_t msec, val, trans, temp;
+	uint64_t val_64;
+	uint32_t min_lat, max_lat, total_lat;
+	struct axim_drvdata *axim = dev_get_drvdata(dev->parent);
+	char fmt_buf[16];
+
+	/* Start event sampling */
+	val = readl(axim->base + AXI_MON_EV_SW_TRIG);
+	val |= AXI_EV_SW_TRIG_SAMPLE_EN;
+	writel(val, axim->base + AXI_MON_EV_SW_TRIG);
+
+	/* Wait till sampling is done. */
+	while (timeout) {
+		val = readl(axim->base + AXI_MON_STAT) & AXI_MON_STAT_SIP_MASK;
+		if (!val)
+			break;
+		udelay(10);
+		timeout--;
+	}
+
+	if (!timeout) {
+		size += scnprintf(buf, PAGE_SIZE, "Error - Event sampling timeout.\n");
+		return size;
+	}
+
+	/* # of cycles. */
+	val_64 = readl(axim->base + AXI_MON_PR_SMP_CYC) * axim->prof_cyc_mul;
+	msec = val_64 / axim->clock_freq_mhz / 1000;
+	size += scnprintf(buf + size, PAGE_SIZE, "Cycles  - %10u [%d msec]\n", (u32)val_64, msec);
+
+	/* # of transactions */
+	trans = readl(axim->base + AXI_MON_PR_SMP_TRANS);
+	size += scnprintf(buf + size, PAGE_SIZE, "Trans   - %10u [%d trans/sec]\n", trans, trans * 1000 / msec);
+
+	/* # of AXI beats */
+	val = readl(axim->base + AXI_MON_PR_SMP_BEATS);
+	size += scnprintf(buf + size, PAGE_SIZE, "Beats   - %10u [%d beats/sec]\n", val, (u32)((u64)val * 1000 / msec));
+
+	/* # of Bytes */
+	val = readl(axim->base + AXI_MON_PR_SMP_BYTES);
+	temp = (u32)((u64)val * 1000 / msec);
+	size += scnprintf(buf + size, PAGE_SIZE, "Bytes   - %10u [%d B/sec, %sps]\n", val, temp,
+			memfmt(fmt_buf, temp));
+
+	/* Latency */
+	total_lat = readl(axim->base + AXI_MON_PR_SMP_LATEN);
+	max_lat = readl(axim->base + AXI_MON_PR_SMP_MAX);
+	min_lat = readl(axim->base + AXI_MON_PR_SMP_MIN);
+
+	/* Convert latency values from clock cycles to nsec.
+	** Multiply by 1000 and divide by MHz
+	*/
+	size += scnprintf(buf + size, PAGE_SIZE, "Latency - %10u [Avg - %u ns]\n",
+			total_lat, (u32)((u64)total_lat * 1000 / trans / axim->clock_freq_mhz));
+	size += scnprintf(buf + size, PAGE_SIZE, "Min lat - %10u [%d ns]\n", min_lat,
+			min_lat * 1000 / axim->clock_freq_mhz);
+	size += scnprintf(buf + size, PAGE_SIZE, "Max lat - %10u [%d ns]\n", max_lat,
+			max_lat * 1000 / axim->clock_freq_mhz);
+
+	/* Resume event collection */
+	val = readl(axim->base + AXI_MON_EV_CLR);
+	val |= AXI_MON_EV_SMPR;
+	writel(val, axim->base + AXI_MON_EV_CLR);
+
+	if (val & AXI_MON_EV_PE)
+		size += scnprintf(buf + size, PAGE_SIZE,
+				"Warning - Counter overflow occurred in one of the SMP counters.\n");
+
+	return size;
+}
+static DEVICE_ATTR_RO(prof_counters);
+
 static ssize_t freeze_show(struct device *dev,
 		       struct device_attribute *attr,
 		       char *buf)
@@ -391,6 +526,8 @@ static ssize_t freeze_store(struct device *dev,
 	&dev_attr_counters.attr,
 	&dev_attr_mon_enable.attr,
 	&dev_attr_freeze.attr,
+	&dev_attr_prof_enable.attr,
+	&dev_attr_prof_counters.attr,
 	NULL,
 };
 
@@ -554,11 +691,13 @@ static void axim_init_default_data(struct axim_drvdata *axim)
 	 * return 0 when reading from AXI_MON_VER. For all fields it
 	 * emulates a VER register fine except for nr_chan
 	 */
-	if (reg)
+	if (reg) {
 		axim->nr_chan = BMVAL(reg, 12, 15); /* NCH */
-	else
+		axim->prof_en = true;
+	} else {
 		axim->nr_chan = 4;
-
+		axim->prof_en = false;
+	}
 }
 
 static int axim_probe(struct amba_device *adev, const struct amba_id *id)
@@ -610,6 +749,20 @@ static int axim_probe(struct amba_device *adev, const struct amba_id *id)
 	axim_init_default_data(axim);
 	axim_reset(axim);
 
+	if (axim->prof_en) {
+		axim->clk = devm_clk_get(dev, "hclk");
+		if (IS_ERR(axim->clk)) {
+			pr_warn("Cannot get profiling clock frequency, Disabling profiling support.\n");
+			axim->prof_en = false;
+		} else {
+			ret = clk_prepare_enable(axim->clk);
+			if (ret)
+				return ret;
+			axim->clock_freq_mhz = clk_get_rate(axim->clk) / 1000000;
+		}
+
+	}
+
 	desc->type = CORESIGHT_DEV_TYPE_SOURCE;
 	desc->subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;
 	desc->ops = &axim_cs_ops;
diff --git a/drivers/hwtracing/coresight/coresight-axi-monitor.h b/drivers/hwtracing/coresight/coresight-axi-monitor.h
index 1d937b2..e416b30 100644
--- a/drivers/hwtracing/coresight/coresight-axi-monitor.h
+++ b/drivers/hwtracing/coresight/coresight-axi-monitor.h
@@ -90,6 +90,22 @@
 /* Attribute register */
 #define AXI_CHAN_ATTR(dom, cache, qos, prot)	(dom << 24 | cache << 16 | qos << 8 | prot)
 
+/* Axi Mon Event Clear register */
+#define AXI_MON_EV_PE			(1 << 17)
+#define AXI_MON_EV_SMPR			(1 << 24)
+
+/* AXI Mon Stat register */
+#define AXI_MON_STAT_SIP_OFF		(23)
+#define AXI_MON_STAT_SIP_MASK		(0x3 << AXI_MON_STAT_SIP_OFF)
+
+/* SW Trigger register */
+#define AXI_EV_SW_TRIG_SAMPLE_EN	(1 << 16)
+
+/* Profiling Control */
+#define AXI_MON_PROF_EN_OFF		(31)
+#define AXI_MON_PROF_CYCG_OFF		(8)
+#define AXI_MON_PROF_CYCG_MASK		(7)
+#define AXI_MON_PROF_CYCG_4_CYC		(1)
 
 /* Supported versions */
 #define AXI_MON_VER_MASK		(0x0F)
@@ -155,27 +171,34 @@ struct axim_chan_data {
  * @boot_enable:True if we should start tracing at boot time.
  * @latency_en: Indicate latency measurment support.
  * @trace_en:	Indicate trace support.
+ * @prof_en:	Indicate profiling support.
  * @nr_chan:	Number of comparator channels.
  * @curr_chan:	Channel Number for configuration.
  * @nr_prof_reg:Number of profiling registers.
  * @major:	Major HW version.
  * @minor:	Minor HW version.
+ * @prof_cyc_mul: Cycle multiplier for profiling clock events.
+ * @clock_freq_mhz: Profiler clock frequency in MHz.
  * @channels:	Channel descriptor.
  */
 struct axim_drvdata {
 	void __iomem			*base;
 	struct device			*dev;
 	struct coresight_device		*csdev;
+	struct clk			*clk;
 	bool				enable;
 	bool				boot_enable;
 	bool				latency_en;
 	bool				trace_en;
+	bool				prof_en;
 	u8				nr_chan;
 	u8				curr_chan;
 	u8				nr_prof_reg;
 	u8				major;
 	u8				minor;
+	u8				prof_cyc_mul;
 	u32				bus_width;
+	u32				clock_freq_mhz;
 	struct axim_chan_data		channel[AXI_MON_MAX_CHANNELS];
 };
 
-- 
1.7.9.5


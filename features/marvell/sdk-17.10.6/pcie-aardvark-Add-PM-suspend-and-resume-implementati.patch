From 373b53d8efa545f82e3d2f31dda122539733517c Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Thu, 6 Apr 2017 18:04:50 +0800
Subject: [PATCH 0957/1345] pcie: aardvark: Add PM suspend and resume
 implementation

commit  5c4f5b31583e7312406cc4f0200f83bccbd2aa9a from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Add suspend and resume implementation for power management.
- In order to reuse code, the setting of reference clock
  buffer control is moved to routine of advk_pcie_setup_hw,
  so that it will be called both in cold booting and PM
  resume stages.
- When suspend, the patch disables the PCIe clock and power
  off PHY used by PCIe in suspend routine
- When resume, the patch reinitializes the PCIe PHY first,
  otherwise the PCIe register access fail; then reset the
  PCIe device and re-enable the clock.

Change-Id: If22a50e521977481eca280c7aae0e7ad33dd31a2
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/38651
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/pci/host/pci-aardvark.c |  143 +++++++++++++++++++++++++--------------
 1 file changed, 91 insertions(+), 52 deletions(-)

diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
index 2f0733d..f6ecd9d 100644
--- a/drivers/pci/host/pci-aardvark.c
+++ b/drivers/pci/host/pci-aardvark.c
@@ -46,10 +46,6 @@
 #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN			BIT(6)
 #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHCK			BIT(7)
 #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHCK_RCV			BIT(8)
-#define PCIE_PHY_REF_CLOCK					0x4814
-#define     PCIE_PHY_CTRL_OFF					16
-#define     PCIE_PHY_BUF_CTRL_OFF				0
-#define     PCIE_PHY_BUF_CTRL_INIT_VAL				0x1342
 
 /* PIO registers base address and register offsets */
 #define PIO_BASE_ADDR				0x4000
@@ -102,6 +98,10 @@
 #define     PCIE_CORE_CTRL2_STRICT_ORDER_ENABLE	BIT(5)
 #define     PCIE_CORE_CTRL2_OB_WIN_ENABLE	BIT(6)
 #define     PCIE_CORE_CTRL2_MSI_ENABLE		BIT(10)
+#define PCIE_PHY_REF_CLOCK			(CONTROL_BASE_ADDR + 0x14)
+#define     PCIE_PHY_CTRL_OFF			16
+#define     PCIE_PHY_BUF_CTRL_OFF		0
+#define     PCIE_PHY_BUF_CTRL_INIT_VAL		0x1342
 #define PCIE_ISR0_REG				(CONTROL_BASE_ADDR + 0x40)
 #define PCIE_ISR0_MASK_REG			(CONTROL_BASE_ADDR + 0x44)
 #define     PCIE_ISR0_MSI_INT_PENDING		BIT(24)
@@ -212,6 +212,8 @@ struct advk_pcie {
 	int root_bus_nr;
 	char *reset_name;
 	struct gpio_desc *reset_gpio;
+	enum of_gpio_flags flags;
+	struct clk *clk;
 };
 
 static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)
@@ -281,6 +283,9 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
 	for (i = 0; i < 8; i++)
 		advk_pcie_set_ob_win(pcie, i, 0, 0, 0, 0, 0, 0, 0);
 
+	/* Set HW Reference Clock Buffer Control */
+	advk_writel(pcie, PCIE_PHY_BUF_CTRL_INIT_VAL, PCIE_PHY_REF_CLOCK);
+
 	/* Set to Direct mode */
 	reg = advk_readl(pcie, CTRL_CONFIG_REG);
 	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
@@ -940,17 +945,37 @@ static void advk_pcie_configure_mps(struct pci_bus *bus, struct advk_pcie *pcie)
 	pci_walk_bus(bus, advk_pcie_bus_configure_mps, &smpss);
 }
 
+static int advk_pcie_clk_enable_then_reset(struct advk_pcie *pcie)
+{
+	int ret;
+
+	/* WA: to avoid reset fail, set the reset gpio to low first */
+	gpiod_direction_output(pcie->reset_gpio, 0);
+
+	/* Enable pcie clock */
+	ret = clk_prepare_enable(pcie->clk);
+	if (ret) {
+		dev_err(&pcie->pdev->dev, "Failed to enable clock\n");
+		return ret;
+	}
+
+	/* After 200ms to reset pcie */
+	mdelay(200);
+	gpiod_direction_output(pcie->reset_gpio,
+			       (pcie->flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+
+	return ret;
+}
+
 static int advk_pcie_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct advk_pcie *pcie;
 	struct resource *res;
 	struct pci_bus *bus, *child;
-	struct clk *clk;
 	struct phy *comphy;
 	struct device_node *dn = pdev->dev.of_node;
 	int ret, irq;
-	enum of_gpio_flags flags;
 	int reset_gpio;
 
 	pcie = devm_kzalloc(dev, sizeof(struct advk_pcie), GFP_KERNEL);
@@ -967,8 +992,6 @@ static int advk_pcie_probe(struct platform_device *pdev)
 	/* Get comphy and init if there is */
 	comphy = devm_of_phy_get(&pdev->dev, dn, "comphy");
 	if (!IS_ERR(comphy)) {
-		/* Set HW Reference Clock Buffer Control */
-		advk_writel(pcie, PCIE_PHY_BUF_CTRL_INIT_VAL, PCIE_PHY_REF_CLOCK);
 		pcie->phy = comphy;
 		ret = phy_init(pcie->phy);
 		if (ret)
@@ -990,62 +1013,27 @@ static int advk_pcie_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(clk)) {
+	pcie->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pcie->clk)) {
 		dev_err(&pdev->dev, "Failed to obtain clock from DT\n");
-		return PTR_ERR(clk);
+		return PTR_ERR(pcie->clk);
 	}
 
 	/* Config reset gpio for pcie */
-	reset_gpio = of_get_named_gpio_flags(dn, "reset-gpios", 0, &flags);
+	reset_gpio = of_get_named_gpio_flags(dn, "reset-gpios", 0, &pcie->flags);
 	if (reset_gpio != -EPROBE_DEFER) {
-		pcie->reset_gpio = gpio_to_desc(reset_gpio);
 		if (gpio_is_valid(reset_gpio)) {
-			unsigned long gpio_flags;
-
-			/* WA: to avoid reset fail, set the reset gpio to low first */
-			gpiod_direction_output(pcie->reset_gpio, 0);
-
-			/* Enable pcie clock and after 200ms to reset pcie */
-			ret = clk_prepare_enable(clk);
-			if (ret) {
-				dev_err(&pdev->dev, "Failed to enable clock\n");
-				return ret;
-			}
-			mdelay(200);
-
-			/* Set GPIO for pcie reset */
-			pcie->reset_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%s-reset",
-							  pdev->name);
-			if (!pcie->reset_name) {
-				ret = -ENOMEM;
-				dev_err(&pdev->dev, "devm_kasprintf failed\n");
+			pcie->reset_gpio = gpio_to_desc(reset_gpio);
+			ret = advk_pcie_clk_enable_then_reset(pcie);
+			if (ret)
 				return ret;
-			}
-
-			if (flags & OF_GPIO_ACTIVE_LOW) {
-				dev_info(&pdev->dev, "%s: reset gpio is active low\n",
-					 of_node_full_name(dn));
-				gpio_flags = GPIOF_ACTIVE_LOW |
-					     GPIOF_OUT_INIT_LOW;
-			} else {
-				gpio_flags = GPIOF_OUT_INIT_HIGH;
-			}
 
-			ret = devm_gpio_request_one(&pdev->dev, reset_gpio, gpio_flags,
-						    pcie->reset_name);
-			if (ret) {
-				dev_err(&pdev->dev,
-					"gpio_request for gpio failed, err = %d\n",
-					ret);
-				return ret;
-			}
 			/* continue init flow after pcie reset */
 			goto after_pcie_reset;
 		}
 	}
 
-	ret = clk_prepare_enable(clk);
+	ret = clk_prepare_enable(pcie->clk);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to enable clock\n");
 		return ret;
@@ -1093,7 +1081,7 @@ static int advk_pcie_probe(struct platform_device *pdev)
 	return 0;
 
 err_clk:
-	clk_disable_unprepare(clk);
+	clk_disable_unprepare(pcie->clk);
 err_exit_phy:
 	if (pcie->phy)
 		phy_exit(pcie->phy);
@@ -1101,17 +1089,68 @@ static int advk_pcie_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static int advk_pcie_suspend_noirq(struct device *dev)
+{
+	struct advk_pcie *pcie;
+
+	pcie = dev_get_drvdata(dev);
+
+	/* Gating clock */
+	clk_disable_unprepare(pcie->clk);
+
+	/* Power off PHY */
+	if (!IS_ERR(pcie->phy)) {
+		phy_power_off(pcie->phy);
+		phy_exit(pcie->phy);
+	}
+
+	return 0;
+}
+
+static int advk_pcie_resume_noirq(struct device *dev)
+{
+	struct advk_pcie *pcie;
+	int ret;
+
+	pcie = dev_get_drvdata(dev);
+
+	/* Power on PHY, it must be first, or pcie register access fail */
+	if (!IS_ERR(pcie->phy)) {
+		phy_init(pcie->phy);
+		phy_power_on(pcie->phy);
+	}
+
+	if (pcie->reset_gpio)
+		ret = advk_pcie_clk_enable_then_reset(pcie);
+	else
+		ret = clk_prepare_enable(pcie->clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clock\n");
+		return ret;
+	}
+
+	advk_pcie_setup_hw(pcie);
+
+	return 0;
+}
+
 static const struct of_device_id advk_pcie_of_match_table[] = {
 	{ .compatible = "marvell,armada-3700-pcie", },
 	{},
 };
 
+static const struct dev_pm_ops advk_pcie_pm_ops = {
+	.suspend_noirq = advk_pcie_suspend_noirq,
+	.resume_noirq = advk_pcie_resume_noirq,
+};
+
 static struct platform_driver advk_pcie_driver = {
 	.driver = {
 		.name = "advk-pcie",
 		.of_match_table = advk_pcie_of_match_table,
 		/* Driver unloading/unbinding currently not supported */
 		.suppress_bind_attrs = true,
+		.pm = &advk_pcie_pm_ops,
 	},
 	.probe = advk_pcie_probe,
 };
-- 
1.7.9.5


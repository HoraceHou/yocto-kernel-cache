From e783398848c67a863dd8c84b7158dc55d831d500 Mon Sep 17 00:00:00 2001
From: Yuval Caduri <cyuval@marvell.com>
Date: Tue, 20 Jun 2017 12:00:29 +0300
Subject: [PATCH 1039/1345] mvpp2x: add support for musdk

commit  ac2a3b3b29eafdc59210931bbc622e2322b04ead from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

Add support for musdk in mvpp2x driver.
- mvpp2x driver only inits phy+mac func. for musdk network devices.
  tx, rx, func. is non-existent.
- musdk network devices are not intended for linux,
  therefore they are set up with sets of dummy network operations.
- For further details, see musdk documentation.

Change-Id: I5eb05c80d2faffe6d4460bf1fb762f39a929f3cd
Signed-off-by: Yuval Caduri <cyuval@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/40761
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/net/marvell-pp2x.txt       |   14 ++
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |    1 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c  |   32 +++
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |    6 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |  229 ++++++++++++++------
 5 files changed, 209 insertions(+), 73 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/marvell-pp2x.txt b/Documentation/devicetree/bindings/net/marvell-pp2x.txt
index 7b163dd..647b2ec 100644
--- a/Documentation/devicetree/bindings/net/marvell-pp2x.txt
+++ b/Documentation/devicetree/bindings/net/marvell-pp2x.txt
@@ -26,6 +26,13 @@ ppv22 port required properties:
 - emac-data: A phandle to an emac node, defining the mac (a.k.a. GOP) properties of the node.
 	     The emac nodes are under the gop section.
 
+ppv22 port optional properties:
+==============================
+- musdk-status: Defines if this is a musdk port or not. Possible values are "private" or "shared".
+		'musdk' stands for the 'Marvell Userspace Development Kit', is intended for US networking in Linux env.
+- marvell,loopback: Is this the ppv2 loopback port.
+		    ppv2 loopback port is only used, if at least one musdk_port is defined.
+
 gop section:
 ===========
 The gop section is separated from the ppv22 node.
@@ -105,6 +112,7 @@ ppv22@000000 {
 		port-id = <0>; /* pp2_port_id */
 		emac-data = <&emac0>;
 		status = "disabled";
+		musdk-status = "private";
 	};
 	eth1: eth1@020000 {
 		interrupts = <GIC_SPI 06 IRQ_TYPE_LEVEL_HIGH>; /* TX/RX Interrupt */
@@ -118,4 +126,10 @@ ppv22@000000 {
 		emac-data = <&emac3>;
 		status = "disabled";
 	};
+	lpbk3_1: lpbk3@040000 {
+		interrupts = <ICU_GRP_NSR 42 IRQ_TYPE_LEVEL_HIGH>, /* TX CPU#0 Interrupt */
+		port-id = <3>; /* pp2_port_id */
+		marvell,loopback;
+		status = "disabled";
+     };
 };
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index 4125db5..4ddd8fd 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -853,6 +853,7 @@ int mv_pp2x_check_ringparam_valid(struct net_device *dev,
 int mv_pp2x_setup_txqs(struct mv_pp2x_port *port);
 void mv_pp2x_cleanup_txqs(struct mv_pp2x_port *port);
 void mv_pp2x_set_ethtool_ops(struct net_device *netdev);
+void mv_pp2x_set_non_kernel_ethtool_ops(struct net_device *netdev);
 int mv_pp22_rss_rxfh_indir_set(struct mv_pp2x_port *port);
 int mv_pp2x_cos_classifier_set(struct mv_pp2x_port *port,
 			       enum mv_pp2x_cos_classifier cos_mode);
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
index 2bde5be..2e19fdc 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
@@ -1190,3 +1190,35 @@ void mv_pp2x_set_ethtool_ops(struct net_device *netdev)
 {
 	netdev->ethtool_ops = &mv_pp2x_eth_tool_ops;
 }
+
+/* Following eth_tool_ops is for musdk_ports, i.e. eth_ports that have the musdk-status property in their dts. */
+static const struct ethtool_ops mv_pp2x_non_kernel_eth_tool_ops = {
+	.get_link		= ethtool_op_get_link,
+	.get_settings		= mv_pp2x_ethtool_get_settings,
+	/*.set_settings		= mv_pp2x_ethtool_set_settings,*/
+	/*.set_coalesce		= mv_pp2x_ethtool_set_coalesce,*/
+	/*.get_coalesce		= mv_pp2x_ethtool_get_coalesce,*/
+	.nway_reset		= mv_pp2x_eth_tool_nway_reset,
+	.get_drvinfo		= mv_pp2x_ethtool_get_drvinfo,
+	.get_ethtool_stats	= mv_pp2x_eth_tool_get_ethtool_stats,
+	.get_sset_count		= mv_pp2x_eth_tool_get_sset_count,
+	.get_strings		= mv_pp2x_eth_tool_get_strings,
+	/*.get_ringparam	= mv_pp2x_ethtool_get_ringparam,*/
+	/*.set_ringparam	= mv_pp2x_ethtool_set_ringparam,*/
+	.get_pauseparam		= mv_pp2x_get_pauseparam,
+	.set_pauseparam		= mv_pp2x_set_pauseparam,
+	.get_rxfh_indir_size	= mv_pp2x_ethtool_get_rxfh_indir_size,
+	.get_rxnfc		= mv_pp2x_ethtool_get_rxnfc,
+	.set_rxnfc		= mv_pp2x_ethtool_set_rxnfc,
+	.get_rxfh		= mv_pp2x_ethtool_get_rxfh,
+	.set_rxfh		= mv_pp2x_ethtool_set_rxfh,
+	.get_regs_len           = mv_pp2x_ethtool_get_regs_len,
+	.get_regs		= mv_pp2x_ethtool_get_regs,
+	.self_test		= mv_pp2x_eth_tool_diag_test,
+};
+
+void mv_pp2x_set_non_kernel_ethtool_ops(struct net_device *netdev)
+{
+	netdev->ethtool_ops = &mv_pp2x_non_kernel_eth_tool_ops;
+}
+
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 317cc6f..2faf9bc 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1269,8 +1269,10 @@
 #define MVPP2_MAX_L3_ADDR_SIZE		16
 
 /* Port flags */
-#define MVPP2_F_LOOPBACK		BIT(0)
-#define MVPP2_F_IFCAP_NETMAP    BIT(1)
+#define MVPP2_F_LOOPBACK		BIT(0) /* Loopback port */
+#define MVPP2_F_IFCAP_NETMAP		BIT(1) /* netmap port */
+#define MVPP2_F_IF_MUSDK		BIT(2) /* musdk port */
+#define MVPP2_F_IF_MUSDK_DOWN		BIT(3) /* musdk port that has been put stopped */
 
 /* Marvell tag types */
 enum mv_pp2x_tag_type {
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 6fd2980..6f499a86 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -3644,16 +3644,20 @@ void mv_pp2x_start_dev(struct mv_pp2x_port *port)
 	if (port->priv->pp2_version == PPV21) {
 		mv_pp21_port_enable(port);
 	} else {
-		mv_gop110_port_events_mask(gop, mac);
-		mv_gop110_port_enable(gop, mac, port->comphy);
+		if (!(port->flags & MVPP2_F_LOOPBACK)) {
+			mv_gop110_port_events_mask(gop, mac);
+			mv_gop110_port_enable(gop, mac, port->comphy);
+		}
 	}
 
 	if (port->mac_data.phy_dev) {
 		phy_start(port->mac_data.phy_dev);
 	} else {
-		mv_pp22_dev_link_event(port->dev);
-		tasklet_init(&port->link_change_tasklet, mv_pp2_link_change_tasklet,
-			     (unsigned long)(port->dev));
+		if (!(port->flags & MVPP2_F_LOOPBACK)) {
+			mv_pp22_dev_link_event(port->dev);
+			tasklet_init(&port->link_change_tasklet, mv_pp2_link_change_tasklet,
+				     (unsigned long)(port->dev));
+		}
 	}
 
 	if (port->mac_data.phy_dev)
@@ -3662,7 +3666,7 @@ void mv_pp2x_start_dev(struct mv_pp2x_port *port)
 	mv_pp2x_egress_enable(port);
 	mv_pp2x_ingress_enable(port);
 	/* Unmask link_event */
-	if (port->priv->pp2_version == PPV22) {
+	if (port->priv->pp2_version == PPV22 && !(port->flags & MVPP2_F_LOOPBACK)) {
 		mv_gop110_port_events_unmask(gop, mac);
 		port->mac_data.flags |= MV_EMAC_F_PORT_UP;
 	}
@@ -3695,16 +3699,19 @@ void mv_pp2x_stop_dev(struct mv_pp2x_port *port)
 	if (port->priv->pp2_version == PPV21) {
 		mv_pp21_port_disable(port);
 	} else {
-		mv_gop110_port_events_mask(gop, mac);
-		mv_gop110_port_disable(gop, mac, port->comphy);
-		port->mac_data.flags &= ~MV_EMAC_F_LINK_UP;
-		port->mac_data.flags &= ~MV_EMAC_F_PORT_UP;
+		if (!(port->flags & MVPP2_F_LOOPBACK)) {
+			mv_gop110_port_events_mask(gop, mac);
+			mv_gop110_port_disable(gop, mac, port->comphy);
+			port->mac_data.flags &= ~MV_EMAC_F_LINK_UP;
+			port->mac_data.flags &= ~MV_EMAC_F_PORT_UP;
+		}
 	}
 
 	if (port->mac_data.phy_dev)
 		phy_stop(port->mac_data.phy_dev);
 	else
-		tasklet_kill(&port->link_change_tasklet);
+		if (!(port->flags & MVPP2_F_LOOPBACK))
+			tasklet_kill(&port->link_change_tasklet);
 }
 
 /* Return positive if MTU is valid */
@@ -3930,6 +3937,11 @@ int mv_pp2x_open(struct net_device *dev)
 	struct mv_pp2x_port *port = netdev_priv(dev);
 	int err;
 
+	if (port->flags & MVPP2_F_IF_MUSDK_DOWN) {
+		netdev_warn(dev, "skipping ndo_open as this port isn't really down\n");
+		return 0;
+	}
+
 	set_device_base_address(dev);
 
 	/* Allocate the Rx/Tx queues */
@@ -3943,8 +3955,8 @@ int mv_pp2x_open(struct net_device *dev)
 		netdev_err(port->dev, "cannot allocate Tx queues\n");
 		goto err_cleanup_rxqs;
 	}
-
-	err = mv_pp2x_setup_irqs(dev, port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		err = mv_pp2x_setup_irqs(dev, port);
 	if (err) {
 		netdev_err(port->dev, "cannot allocate irq's\n");
 		goto err_cleanup_txqs;
@@ -3957,15 +3969,16 @@ int mv_pp2x_open(struct net_device *dev)
 	/* In default link is down */
 	netif_carrier_off(port->dev);
 
-	/* Unmask interrupts on all CPUs */
-	on_each_cpu(mv_pp2x_interrupts_unmask, port, 1);
-
-	/* Unmask shared interrupts */
-	mv_pp2x_shared_thread_interrupts_unmask(port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK)) {
+		/* Unmask interrupts on all CPUs */
+		on_each_cpu(mv_pp2x_interrupts_unmask, port, 1);
 
-	/* Port is init in uboot */
+		/* Unmask shared interrupts */
+		mv_pp2x_shared_thread_interrupts_unmask(port);
 
-	if (port->priv->pp2_version == PPV22)
+		/* Port is init in uboot */
+	}
+	if ((port->priv->pp2_version == PPV22) && !(port->flags & MVPP2_F_LOOPBACK))
 		mvcpn110_mac_hw_init(port);
 	mv_pp2x_start_dev(port);
 
@@ -4350,8 +4363,29 @@ u16 mv_pp2x_select_queue(struct net_device *dev, struct sk_buff *skb,
 	return (val % mv_pp2x_txq_number) + (smp_processor_id() * mv_pp2x_txq_number);
 }
 
-/* Device ops */
+/* Dummy netdev_ops for non-kernel (i.e. musdk) network devices */
+static int mv_pp2x_dummy_change_mtu(struct net_device *dev, int mtu)
+{
+	netdev_warn(dev, "ndo_change_mtu not supported\n");
+	return 0;
+}
 
+int mv_pp2x_dummy_stop(struct net_device *dev)
+{
+	struct mv_pp2x_port *port = netdev_priv(dev);
+
+	port->flags |= MVPP2_F_IF_MUSDK_DOWN;
+	netdev_warn(dev, "ndo_stop not supported\n");
+	return 0;
+}
+
+static int mv_pp2x_dummy_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	pr_debug("mv_pp2x_dummy_tx\n");
+	return NETDEV_TX_OK;
+}
+
+/* Device ops */
 static const struct net_device_ops mv_pp2x_netdev_ops = {
 	.ndo_open		= mv_pp2x_open,
 	.ndo_stop		= mv_pp2x_stop,
@@ -4367,6 +4401,22 @@ u16 mv_pp2x_select_queue(struct net_device *dev, struct sk_buff *skb,
 	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
 };
 
+/* musdk ports contain dummy operations for those functions that are performed in UserSpace (i.e. musdk) */
+static const struct net_device_ops mv_pp2x_non_kernel_netdev_ops = {
+	.ndo_open		= mv_pp2x_open,
+	.ndo_stop		= mv_pp2x_dummy_stop,
+	.ndo_start_xmit		= mv_pp2x_dummy_tx,
+	/*.ndo_select_queue	= mv_pp2x_select_queue,*/
+	.ndo_set_rx_mode	= mv_pp2x_set_rx_mode,
+	.ndo_set_mac_address	= mv_pp2x_set_mac_address,
+	.ndo_change_mtu		= mv_pp2x_dummy_change_mtu,
+	.ndo_get_stats64	= mv_pp2x_get_stats64,
+	.ndo_do_ioctl		= mv_pp2x_ioctl,
+	.ndo_set_features	= mv_pp2x_netdev_set_features,
+	.ndo_vlan_rx_add_vid	= mv_pp2x_rx_add_vid,
+	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
+};
+
 /* Driver initialization */
 
 static void mv_pp21_port_power_up(struct mv_pp2x_port *port)
@@ -4703,12 +4753,12 @@ static void mv_pp2x_get_port_stats(struct mv_pp2x_port *port)
 
 	if (port->priv->pp2_version == PPV21)
 		return;
-
-	link_is_up = mv_gop110_port_is_link_up(gop, &port->mac_data);
-
-	if (link_is_up) {
-		mv_gop110_mib_counters_stat_update(gop, gop_port, gop_statistics);
-		mv_pp2x_counters_stat_update(port, gop_statistics);
+	if (!(port->flags & MVPP2_F_LOOPBACK)) {
+		link_is_up = mv_gop110_port_is_link_up(gop, &port->mac_data);
+		if (link_is_up) {
+			mv_gop110_mib_counters_stat_update(gop, gop_port, gop_statistics);
+			mv_pp2x_counters_stat_update(port, gop_statistics);
+		}
 	}
 }
 
@@ -4742,7 +4792,8 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 	if (port->priv->pp2_version == PPV21)
 		mv_pp21_port_disable(port);
 	else
-		mv_gop110_port_disable(gop, mac, port->comphy);
+		if (!(port->flags & MVPP2_F_LOOPBACK))
+			mv_gop110_port_disable(gop, mac, port->comphy);
 
 	/* Allocate queues */
 	port->txqs = devm_kcalloc(dev, port->num_tx_queues, sizeof(*port->txqs),
@@ -4767,7 +4818,9 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 		goto err_free_percpu;
 
 	/* Configure queue_vectors */
-	priv->pp2xdata->mv_pp2x_port_queue_vectors_init(port);
+
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		priv->pp2xdata->mv_pp2x_port_queue_vectors_init(port);
 
 	/* Configure Rx queue group interrupt for this port */
 	priv->pp2xdata->mv_pp2x_port_isr_rx_group_cfg(port);
@@ -4794,7 +4847,8 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 	port->pkt_size = MVPP2_RX_PKT_SIZE(port->dev->mtu);
 
 	/* Initialize pools for swf */
-	err = mv_pp2x_swf_bm_pool_init(port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		err = mv_pp2x_swf_bm_pool_init(port);
 	if (err)
 		goto err_free_percpu;
 	return 0;
@@ -4865,15 +4919,15 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 			      struct device_node *port_node,
 			    struct mv_pp2x *priv)
 {
-	struct device_node *emac_node;
-	struct device_node *phy_node;
+	struct device_node *emac_node = NULL;
+	struct device_node *phy_node = NULL;
 	struct mv_pp2x_port *port;
 	struct mv_pp2x_port_pcpu *port_pcpu;
 	struct net_device *dev;
 	struct resource *res;
-	const char *dt_mac_addr;
+	const char *dt_mac_addr = NULL;
 	const char *mac_from;
-	char hw_mac_addr[ETH_ALEN];
+	char hw_mac_addr[ETH_ALEN] = {0};
 	u32 id;
 	int features, err = 0, i, cpu;
 	int priv_common_regs_num = 2;
@@ -4881,10 +4935,17 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	unsigned int *port_irqs;
 	int port_num_irq;
 	int phy_mode;
-	struct phy *comphy;
+	struct phy *comphy = NULL;
+	const char *musdk_status;
+	int statlen;
 
-	dev = alloc_etherdev_mqs(sizeof(struct mv_pp2x_port),
-				 mv_pp2x_txq_number * num_active_cpus(), mv_pp2x_rxq_number);
+	if (of_property_read_bool(port_node, "marvell,loopback")) {
+		dev = alloc_netdev_mqs(sizeof(struct mv_pp2x_port), "pp2_lpbk%d", NET_NAME_UNKNOWN,
+				       ether_setup, mv_pp2x_txq_number * num_active_cpus(), mv_pp2x_rxq_number);
+	} else {
+		dev = alloc_etherdev_mqs(sizeof(struct mv_pp2x_port),
+					 mv_pp2x_txq_number * num_active_cpus(), mv_pp2x_rxq_number);
+	}
 	if (!dev)
 		return -ENOMEM;
 
@@ -4893,6 +4954,13 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	port->dev = dev;
 	SET_NETDEV_DEV(dev, &pdev->dev);
 	port->priv = priv;
+	port->flags = 0;
+
+	musdk_status = of_get_property(port_node, "musdk-status", &statlen);
+
+	/* Set musdk_flag, only if status is "private", not if status is "shared" */
+	if (musdk_status && !strcmp(musdk_status, "private"))
+		port->flags |= MVPP2_F_IF_MUSDK;
 
 	mv_pp2x_port_init_config(port);
 
@@ -4921,20 +4989,27 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		port->mac_data.phy_node = phy_node;
 		emac_node = port_node;
 	} else {
-		emac_node = of_parse_phandle(port_node, "emac-data", 0);
-		if (!emac_node) {
-			dev_err(&pdev->dev, "missing emac-data\n");
-			err = -EINVAL;
-			goto err_free_netdev;
-		}
-		/* Init emac_data, includes link interrupt */
-		if (mv_pp2_init_emac_data(port, emac_node))
-			goto err_free_netdev;
+		if (of_property_read_bool(port_node, "marvell,loopback"))
+			port->flags |= MVPP2_F_LOOPBACK;
+
+		if (!(port->flags & MVPP2_F_LOOPBACK)) {
+			emac_node = of_parse_phandle(port_node, "emac-data", 0);
+			if (!emac_node) {
+				dev_err(&pdev->dev, "missing emac-data\n");
+				err = -EINVAL;
+				goto err_free_netdev;
+			}
+			/* Init emac_data, includes link interrupt */
+			if (mv_pp2_init_emac_data(port, emac_node))
+				goto err_free_netdev;
 
-		comphy = devm_of_phy_get(&pdev->dev, emac_node, "comphy");
+			comphy = devm_of_phy_get(&pdev->dev, emac_node, "comphy");
 
-		if (!IS_ERR(comphy))
-			port->comphy = comphy;
+			if (!IS_ERR(comphy))
+				port->comphy = comphy;
+		} else {
+			port->mac_data.link_irq = MVPP2_NO_LINK_IRQ;
+		}
 	}
 
 	if (port->mac_data.phy_node) {
@@ -4944,7 +5019,9 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	}
 
 	/* get MAC address */
-	dt_mac_addr = of_get_mac_address(emac_node);
+	if (emac_node)
+		dt_mac_addr = of_get_mac_address(emac_node);
+
 	if (dt_mac_addr && is_valid_ether_addr(dt_mac_addr)) {
 		mac_from = "device tree";
 		ether_addr_copy(dev->dev_addr, dt_mac_addr);
@@ -4966,7 +5043,9 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 
 	/* Tx/Rx Interrupt */
 	port_num_irq = mv_pp2x_of_irq_count(port_node);
-	if (port_num_irq != priv->pp2xdata->num_port_irq) {
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		port_num_irq = 0;
+	if ((!(port->flags & MVPP2_F_IF_MUSDK)) && port_num_irq != priv->pp2xdata->num_port_irq) {
 		dev_err(&pdev->dev,
 			"port(%d)-number of irq's doesn't match hw\n", id);
 		goto err_free_netdev;
@@ -4986,16 +5065,20 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		port->num_irqs++;
 	}
 
-	/*FIXME, full handling loopback */
-	if (of_property_read_bool(port_node, "marvell,loopback"))
-		port->flags |= MVPP2_F_LOOPBACK;
-
-	port->num_tx_queues = mv_pp2x_txq_number;
-	port->num_rx_queues = mv_pp2x_rxq_number;
 	dev->tx_queue_len = tx_queue_size;
 	dev->watchdog_timeo = 5 * HZ;
-	dev->netdev_ops = &mv_pp2x_netdev_ops;
-	mv_pp2x_set_ethtool_ops(dev);
+
+	if (port->flags & MVPP2_F_IF_MUSDK) {
+		port->num_tx_queues = 0;
+		port->num_rx_queues = 0;
+		dev->netdev_ops = &mv_pp2x_non_kernel_netdev_ops;
+		mv_pp2x_set_non_kernel_ethtool_ops(dev);
+	} else {
+		port->num_tx_queues = mv_pp2x_txq_number;
+		port->num_rx_queues = mv_pp2x_rxq_number;
+		dev->netdev_ops = &mv_pp2x_netdev_ops;
+		mv_pp2x_set_ethtool_ops(dev);
+	}
 
 	if (priv->pp2_version == PPV21)
 		port->first_rxq = (port->id) * mv_pp2x_rxq_number +
@@ -5045,7 +5128,7 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		err = -ENOMEM;
 		goto err_free_txq_pcpu;
 	}
-	if (!port->priv->pp2xdata->interrupt_tx_done) {
+	if ((!(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK))) && !port->priv->pp2xdata->interrupt_tx_done) {
 		for_each_present_cpu(cpu) {
 			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
 
@@ -5058,23 +5141,26 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 				     mv_pp2x_tx_proc_cb, (unsigned long)dev);
 		}
 	}
-
 	/* Init hrtimer for tx transmit procedure.
 	 * Instead of reg_write atfer each xmit callback, 50 microsecond
 	 * hrtimer would be started. Hrtimer will reduce amount of accesses
 	 * to transmit register and dmb() influence on network performance.
 	 */
-	for_each_present_cpu(cpu) {
-		port_pcpu = per_cpu_ptr(port->pcpu, cpu);
+	if (!(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK))) {
+		for_each_present_cpu(cpu) {
+			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
 
-		hrtimer_init(&port_pcpu->tx_timer, CLOCK_MONOTONIC,
-			     HRTIMER_MODE_REL_PINNED);
-		port_pcpu->tx_timer.function = mv_pp2x_tx_hr_timer_cb;
-		port_pcpu->tx_timer_scheduled = false;
+			hrtimer_init(&port_pcpu->tx_timer, CLOCK_MONOTONIC,
+				     HRTIMER_MODE_REL_PINNED);
+			port_pcpu->tx_timer.function = mv_pp2x_tx_hr_timer_cb;
+			port_pcpu->tx_timer_scheduled = false;
 
-		tasklet_init(&port_pcpu->tx_tasklet,
-			     mv_pp2x_tx_send_proc_cb, (unsigned long)dev);
+			tasklet_init(&port_pcpu->tx_tasklet,
+				     mv_pp2x_tx_send_proc_cb, (unsigned long)dev);
+		}
 	}
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		goto skip_tso_buffers;
 	/* Init pool of external buffers for TSO, fragmentation, etc */
 	for_each_present_cpu(cpu) {
 		port_pcpu = per_cpu_ptr(port->pcpu, cpu);
@@ -5103,7 +5189,7 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 			port_pcpu->ext_buf_pool->buf_pool_in_use++;
 		}
 	}
-
+skip_tso_buffers:
 	features = NETIF_F_SG;
 	dev->features = features | NETIF_F_RXCSUM | NETIF_F_IP_CSUM |
 			NETIF_F_IPV6_CSUM | NETIF_F_TSO;
@@ -5136,7 +5222,8 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	mv_gop110_mib_counters_clear(&port->priv->hw.gop, port->mac_data.gop_index);
 	mv_pp2x_counters_stat_clear(port);
 
-	mv_pp2x_port_irq_names_update(port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		mv_pp2x_port_irq_names_update(port);
 
 	if (priv->pp2_version == PPV22)
 		port->port_hotplug_nb.notifier_call = mv_pp2x_port_cpu_callback;
-- 
1.7.9.5


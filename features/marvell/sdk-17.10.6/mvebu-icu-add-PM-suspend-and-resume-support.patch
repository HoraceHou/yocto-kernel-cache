From f3bd93124445b56e33953d494c82f27ca25917d6 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Mon, 17 Jul 2017 17:53:10 +0800
Subject: [PATCH 1206/1345] mvebu: icu: add PM suspend and resume support

commit  ec0ed459a951d715e0763e893d560cea28652c2e from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

The icu should support suspend and resume so that the IOs
could continue to work after system suspend and resume.
Below registers are saved and restores:
1. generic ICU registers such as IRQ assert and deassert
2. ICU interrupt configuration registers

Change-Id: I29ea5a898608a2c76293750aba5d5f9225eec944
Signed-off-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/41678
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/irqchip/irq-mvebu-icu.c |   75 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 75 insertions(+)

diff --git a/drivers/irqchip/irq-mvebu-icu.c b/drivers/irqchip/irq-mvebu-icu.c
index 8d01d43..5de80cf 100644
--- a/drivers/irqchip/irq-mvebu-icu.c
+++ b/drivers/irqchip/irq-mvebu-icu.c
@@ -34,6 +34,7 @@
 
 #define pr_fmt(fmt) "mvebu-icu: " fmt
 
+#include <linux/cpu_pm.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/irqchip/chained_irq.h>
@@ -46,6 +47,7 @@
 #include <dt-bindings/interrupt-controller/mvebu-icu.h>
 
 #define ICU_MAX_IRQS		208
+#define ICU_MAX_REGS		28
 #define ICU_MAX_SPI_IRQ_IN_GIC	128
 #define ICU_GIC_SPI_BASE0	64
 #define ICU_GIC_SPI_BASE1	288
@@ -74,11 +76,18 @@
 #define ICU_SATA1_IRQ_INT		107
 
 struct mvebu_icu_irq_data {
+	struct list_head node;
 	void __iomem *base;	/* ICU register base */
 	void __iomem *gicp_clr_spi_base;
+
+	u32 *icu_reg;
+	u32 *icu_cfg;
 	struct irq_domain *domain;
 };
 
+/* Global list of devices for suspend and resume (struct mvebu_icu_irq_data) */
+static LIST_HEAD(icu_data_list);
+
 static DEFINE_SPINLOCK(icu_lock);
 static DECLARE_BITMAP(icu_irq_alloc, ICU_MAX_SPI_IRQ_IN_GIC);
 
@@ -274,6 +283,67 @@ static void mvebu_icu_irq_domain_free(struct irq_domain *domain,
 	.free			= mvebu_icu_irq_domain_free,
 };
 
+#ifdef CONFIG_PM_SLEEP
+/* Save ICU generic registers and all ICU interrupt registers */
+static void mvebu_icu_save(void)
+{
+	int reg;
+	int irq;
+	struct mvebu_icu_irq_data *icu;
+
+	list_for_each_entry(icu, &icu_data_list, node) {
+		for (reg = 0; reg < ICU_MAX_REGS; reg++)
+			icu->icu_reg[reg] = readl(icu->base + sizeof(u32) * reg);
+
+		for (irq = 0; irq < ICU_MAX_IRQS; irq++)
+			icu->icu_cfg[irq] = readl(icu->base + ICU_INT_CFG(irq));
+	}
+}
+
+/* Restore ICU generic registers and all ICU interrupt registers */
+static void mvebu_icu_restore(void)
+{
+	int reg;
+	int irq;
+	struct mvebu_icu_irq_data *icu;
+
+	list_for_each_entry(icu, &icu_data_list, node) {
+		for (reg = 0; reg < ICU_MAX_REGS; reg++)
+			writel(icu->icu_reg[reg], icu->base + sizeof(u32) * reg);
+
+		for (irq = 0; irq < ICU_MAX_IRQS; irq++)
+			writel(icu->icu_cfg[irq], icu->base + ICU_INT_CFG(irq));
+	}
+}
+
+static int mvebu_icu_notifier(struct notifier_block *self, unsigned long cmd, void *v)
+{
+	switch (cmd) {
+	case CPU_PM_ENTER:
+		mvebu_icu_save();
+		break;
+	case CPU_PM_ENTER_FAILED:
+	case CPU_PM_EXIT:
+		mvebu_icu_restore();
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block mvebu_icu_notifier_block = {
+	.notifier_call = mvebu_icu_notifier,
+};
+
+static int __init mvebu_icu_pm_init(void)
+{
+	return cpu_pm_register_notifier(&mvebu_icu_notifier_block);
+}
+arch_initcall(mvebu_icu_pm_init);
+#endif
+
 static int __init mvebu_icu_of_init(struct device_node *node, struct device_node *parent)
 {
 	int ret;
@@ -342,6 +412,11 @@ static int __init mvebu_icu_of_init(struct device_node *node, struct device_node
 			writel(0x0, icu->base + ICU_INT_CFG(i));
 	}
 
+	/* Initialize the ICU structure */
+	icu->icu_reg = kzalloc(sizeof(u32) * ICU_MAX_REGS, GFP_KERNEL);
+	icu->icu_cfg = kzalloc(sizeof(u32) * ICU_MAX_IRQS, GFP_KERNEL);
+	list_add_tail(&icu->node, &icu_data_list);
+
 	pr_debug("ICU irq chip init successfully\n");
 
 	return 0;
-- 
1.7.9.5


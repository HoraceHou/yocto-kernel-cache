From 2663ea13d71d35ddae7c188dd388c67f3810271f Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Wed, 11 Jan 2017 03:31:47 +0100
Subject: [PATCH 0751/1345] telephony: mvebu: spi: Enable using multiple SLIC
 devices

commit  252fd5be38bdaf2f1c13411d54a8f70015f8d065 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

This commit enables using multiple SLIC devices. Following changes
were required:
* Use global array of pointers to SLIC SPI devices (slic_devs), which
  is filled during driver probe. Later in mv_phone SPI API appropriate
  devices are picked with the ID passed from the upper layers.
* Introduce new optional DT property ('slic-id') - it is a logical ID
  of SPI device from range 0 - 31. If not used, the driver will set it
  to '0'. If more than one SLIC device is enabled, this property becomes
  obligatory for proper operation.

Binding documentation was updated accordingly. Feature tested on
on Armada XP DB board with 2 Zarlink ve880 SLIC devices (up to
4 channels).

Change-Id: Ic68037a8b127647bbfce8fa9a640ff6dfa5fd4ce
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35872
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/telephony/mvebu-phone.txt  |    7 ++++
 drivers/telephony/mvebu_phone/mv_phone_spi.c       |   37 +++++++++++++++++---
 2 files changed, 39 insertions(+), 5 deletions(-)

diff --git a/Documentation/devicetree/bindings/telephony/mvebu-phone.txt b/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
index 515b63d..db6aafe 100644
--- a/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
+++ b/Documentation/devicetree/bindings/telephony/mvebu-phone.txt
@@ -64,6 +64,12 @@ Zarlink/Silabs SLIC devices require also following properties:
 
 - spi-cpha - accept data on clk trailing edge
 
+Optional property:
+
+- slic-id - logical ID of SPI device from range 0 - 31. If not used,
+  the driver will set it to '0'. If more than one SLIC device is
+  used, this property is obligatory for proper operation.
+
 spi1: spi@10680 {
 	pinctrl-0 = <&spi1_pins>;
 	pinctrl-names = "default";
@@ -78,5 +84,6 @@ spi1: spi@10680 {
 		spi-1byte-cs;
 		spi-cpol;
 		spi-cpha;
+		slic-id = <1>;
 	};
 };
diff --git a/drivers/telephony/mvebu_phone/mv_phone_spi.c b/drivers/telephony/mvebu_phone/mv_phone_spi.c
index 3cda17d..c92056e 100644
--- a/drivers/telephony/mvebu_phone/mv_phone_spi.c
+++ b/drivers/telephony/mvebu_phone/mv_phone_spi.c
@@ -101,12 +101,16 @@
 
 #undef MVEBU_PHONE_SPI_DEBUG
 
-struct spi_device *slic_spi;
+#define MAX_SLIC_DEVICES 32
+
+/* Global array of pointers to SLIC SPI devices */
+struct spi_device *slic_devs[MAX_SLIC_DEVICES];
 
 /* Telephony register read via SPI interface. */
 void mv_phone_spi_read(u16 dev_id, u8 *cmd_buff, u8 cmd_size,
 		       u8 *data_buff, u8 data_size, u32 spi_type)
 {
+	struct spi_device *slic_spi = slic_devs[dev_id];
 	int err;
 
 #ifdef MVEBU_PHONE_SPI_DEBUG
@@ -132,6 +136,7 @@ void mv_phone_spi_write(u16 dev_id, u8 *cmd_buff, u8 cmd_size,
 {
 	int err;
 	struct spi_message m;
+	struct spi_device *slic_spi = slic_devs[dev_id];
 	struct spi_transfer t[2] = { { .tx_buf = (const void *)cmd_buff,
 				       .len = cmd_size, },
 				     { .tx_buf = (const void *)data_buff,
@@ -157,6 +162,30 @@ void mv_phone_spi_write(u16 dev_id, u8 *cmd_buff, u8 cmd_size,
 static int mvebu_phone_spi_probe(struct spi_device *spi)
 {
 	int err;
+	u32 dev_id;
+
+	/* Obtain SLIC ID */
+	err = of_property_read_u32(spi->dev.of_node, "slic-id", &dev_id);
+	if (err == -EINVAL) {
+		/* Assign '0' ID in case the 'slic-id' property is not used */
+		dev_id = 0;
+	} else if (err) {
+		dev_err(&spi->dev, "unable to get SLIC ID\n");
+		return err;
+	} else if (dev_id >= MAX_SLIC_DEVICES) {
+		dev_err(&spi->dev, "SLIC ID (%d) exceeds maximum (%d)\n",
+			dev_id, MAX_SLIC_DEVICES - 1);
+		return -EINVAL;
+	}
+
+	/* Check if this ID wasn't used by previous devices */
+	if (slic_devs[dev_id]) {
+		dev_err(&spi->dev, "overlapping ID (%d) at bus #%d, CS #%d\n",
+			dev_id, spi->master->bus_num, spi->chip_select);
+		return -EINVAL;
+	}
+
+	slic_devs[dev_id] = spi;
 
 	err = spi_setup(spi);
 	if (err) {
@@ -164,10 +193,8 @@ static int mvebu_phone_spi_probe(struct spi_device *spi)
 		return err;
 	}
 
-	slic_spi = spi;
-
-	dev_info(&spi->dev, "registered slic spi device at bus #%d, CS #%d",
-		 spi->master->bus_num, spi->chip_select);
+	dev_info(&spi->dev, "registered slic spi device %d at bus #%d, CS #%d",
+		 dev_id, spi->master->bus_num, spi->chip_select);
 
 	return 0;
 }
-- 
1.7.9.5


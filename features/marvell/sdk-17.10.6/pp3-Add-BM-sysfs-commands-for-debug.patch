From 7a4e1afb86d66229d9e28505f9370b4cc0d43285 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Mon, 12 Sep 2016 22:40:47 +0300
Subject: [PATCH 0496/1345] pp3: Add BM sysfs commands for debug

commit  a0f260d6bab959aef09782155c0d67caa2fa31c2 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

"echo [pool]     > bm/pool_check"   - check BM pool validity
- fix and improve output of other BM sysfs commands

Change-Id: I04e43027d527569a786dd84816bc15c0c79146b7
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32734
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-by: Neta Zur Hershkovits <neta@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.c        |  324 +++++++++++++++++++-
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.h        |    2 +
 drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c  |   58 +++-
 .../net/ethernet/marvell/pp3/vport/mv_pp3_pool.c   |   35 ---
 4 files changed, 370 insertions(+), 49 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
index b62b1bc..5c35cc0 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
@@ -207,8 +207,7 @@ static int bm_entry_print(char *name, int offs, int words)
 	unsigned int *entry;
 	int i;
 
-	entry = kzalloc(words * sizeof(unsigned int), GFP_KERNEL);
-
+	entry = kcalloc(words, sizeof(unsigned int), GFP_KERNEL);
 	if (!entry) {
 		pr_info("%s: Error - out of memory\n", __func__);
 		return -ENOMEM;
@@ -1131,7 +1130,8 @@ void bm_pool_status_dump(int pool)
 	dram_fill = mv_field_get(BM_TPR_DRW_MNG_BALL_DYN_DRAM_FILL_OFFS,
 		BM_TPR_DRW_MNG_BALL_DYN_DRAM_FILL_BITS, drw_mng_ball_entry);
 
-	pr_info("dram fill      [PEs]: %d\n", dram_fill * 8);
+	/* fields in unit of 8 bytes,  2 = 8 / PE size in dram */
+	pr_info("dram fill      [PEs]: %d\n", dram_fill * 2);
 	/*---------------------------------------------------------------------*/
 	entry_offset = BM_TPR_CTRS_BANK_TBL_ENTRY(bid, pid_local);
 	bm_entry_read(entry_offset, BM_TPR_CTRS_BANK_TBL_ENTRY_WORDS, tpr_ctrs_entry);
@@ -1173,8 +1173,7 @@ void bm_pool_registers_parse(int pool)
 	pid_local = bm_pid_to_local(pool);
 	pid_global = bm_pid_to_global(pool);
 
-	pr_info("\nbm_pool_registers_dump\n\n");
-	/*---------------------------------------------------------------------*/
+	pr_info("\n-------------- BM pool %d registers parse -----------\n", pool);
 
 	if  (bid == 0) {	/* QM pools */
 		bm_gl_reg_print("BANK_POOL_CFG_REG", BM_B0_POOL_CFG_REG(pid_local));
@@ -1394,7 +1393,7 @@ void bm_error_dump(void)
 
 
 	for (bid = 0; bid < BM_BANK_NUM; bid++) {
-		pr_info("bank %d innterrupt regs:\n", bid);
+		pr_info("bank %d interrupt regs:\n", bid);
 		sprintf(reg_name, "B%d_SYS_REC_INTERRUPT_CAUSE", bid);
 		bm_gl_reg_none_zr_print(reg_name, BM_BANK_SYS_REC_INTERRUPT_CAUSE_REG(bid));
 
@@ -1421,3 +1420,316 @@ void bm_error_dump(void)
 	bm_gl_reg_none_zr_print("FUNC_INTERRUPT_CAUSE_REG", BM_FUNC_INTERRUPT_CAUSE_REG);
 	bm_gl_reg_none_zr_print("ECC_ERR_INTERRUPT_CAUSE_REG", BM_ECC_ERR_INTERRUPT_CAUSE_REG);
 }
+
+/* mode: 0 - print only pool status, 1 - print all PEs from DRAM,  2 - print only valid PEs from DRAM */
+int bm_pool_dump(int pool, int mode, u32 *pool_base, int capacity)
+{
+	int i;
+
+	if ((mode > 0) && pool_base) {
+		pr_info("\n-------------- BM pool %d dump: vaddr = 0x%p, paddr = 0x%08x -----------\n",
+			pool, pool_base, virt_to_phys(pool_base));
+		pr_info(" Pool addr (offs)  :   paddr       vaddr     |    paddr       vaddr\n");
+		for (i = 0; i < capacity; i = i + 4)
+			pr_info("0x%p (%4d)  : 0x%08x  0x%08x  |  0x%08x  0x%08x\n",
+				&pool_base[i], i, pool_base[i], pool_base[i + 1],
+				pool_base[i + 2], pool_base[i + 3]);
+	}
+	bm_pool_status_dump(pool);
+	return 0;
+}
+
+int bm_bank0_pool_find_buf(int pool, u32 *pool_base, unsigned int buf)
+{
+	int count, bid, pid_local, pid_global, i, line, max = 0;
+	unsigned int dram_rd, dram_wr, dram_fill, dram_size, dram_start, entry_offset;
+	unsigned int cache_rd, cache_wr, cache_start, cache_end, cache_fill_min, cache_fill_max;
+	unsigned int start, end;
+	u32 val;
+	unsigned int drw_mng_ball_entry[BM_TPR_DRW_MNG_BALL_DYN_TBL_ENTRY_WORDS];
+	unsigned int tpr_dro_mng_entry[BM_TPR_DRO_MNG_BALL_DYN_TBL_ENTRY_WORDS];
+	unsigned int dpr_d_mng_entry[BM_DPR_D_MNG_BALL_STAT_TBL_ENTRY_WORDS];
+	unsigned int sram_cache_entry[BM_SRAM_B0_CACHE_TBL_ENTRY_WORDS];
+	unsigned int dpr_c_mng_entry[BM_DPR_C_MNG_BANK_STAT_TBL_ENTRY_WORDS];
+	unsigned int tpr_c_mng_entry[BM_TPR_C_MNG_BANK_DYN_TBL_ENTRY_WORDS];
+
+	if ((pool < BM_QM_GPM_POOL_0) && (pool > BM_QM_GPM_POOL_1)) {
+		pr_err("%s: Supported only for GPM pools 0..1\n", __func__);
+		return -1;
+	}
+
+	bid = bm_pid_to_bid(pool);
+	pid_local = bm_pid_to_local(pool);
+	pid_global = bm_pid_to_global(pool);
+
+	entry_offset = BM_TPR_DRW_MNG_BALL_DYN_TBL_ENTRY(pid_global);
+	bm_entry_read(entry_offset, BM_TPR_DRW_MNG_BALL_DYN_TBL_ENTRY_WORDS, drw_mng_ball_entry);
+
+	dram_fill = mv_field_get(BM_TPR_DRW_MNG_BALL_DYN_DRAM_FILL_OFFS,
+				 BM_TPR_DRW_MNG_BALL_DYN_DRAM_FILL_BITS, drw_mng_ball_entry);
+
+	entry_offset = BM_TPR_DRO_MNG_BALL_DYN_TBL_ENTRY(pid_global);
+	bm_entry_read(entry_offset, BM_TPR_DRO_MNG_BALL_DYN_TBL_ENTRY_WORDS, tpr_dro_mng_entry);
+
+	dram_rd = mv_field_get(BM_TPR_DRO_MNG_BALL_DYN_DRAM_RD_PTR_OFFS,
+			       BM_TPR_DRO_MNG_BALL_DYN_DRAM_RD_PTR_BITS, tpr_dro_mng_entry);
+	dram_wr = mv_field_get(BM_TPR_DRO_MNG_BALL_DYN_DRAM_WR_PTR_OFFS,
+			       BM_TPR_DRO_MNG_BALL_DYN_DRAM_WR_PTR_BITS, tpr_dro_mng_entry);
+
+	entry_offset = BM_DPR_D_MNG_BALL_STAT_TBL_ENTRY(pid_global);
+	bm_entry_read(entry_offset, BM_DPR_D_MNG_BALL_STAT_TBL_ENTRY_WORDS, dpr_d_mng_entry);
+	dram_start = mv_field_get(BM_DPR_D_MNG_BALL_STAT_DRAM_START_LSB_OFFS,
+				  BM_DPR_D_MNG_BALL_STAT_DRAM_START_LSB_BITS, dpr_d_mng_entry);
+
+	dram_size = mv_field_get(BM_DPR_D_MNG_BALL_STAT_DRAM_SIZE_OFFS,
+				 BM_DPR_D_MNG_BALL_STAT_DRAM_SIZE_BITS, dpr_d_mng_entry);
+
+	dram_size *= 16;
+	dram_rd *= 2;
+	dram_wr *= 2;
+	dram_fill *= 2;
+
+	/* valid DRAM enries from dram_read to dram_write */
+	start = dram_rd;
+	if (dram_wr > dram_rd)
+		end = dram_wr;
+	else
+		end = dram_size;
+
+	count = 0;
+	pr_cont("Buf 0x%04x: ", buf);
+	while (count < dram_fill) {
+		for (i = start; i < end; i++) {
+			val = pool_base[i];
+			if (val > dram_size) {
+				pr_info("BM pool #%d: Unexpected buffer index 0x%04x on DRAM offset %d\n",
+					pool, val, i);
+				break;
+			}
+			if (val == buf) {
+				pr_cont("D_%-4d ", i);
+				max++;
+			}
+			count++;
+		}
+		start = 0;
+		end = dram_wr;
+	}
+
+	/* Check Cache */
+	entry_offset = BM_DPR_C_MNG_BANK_STAT_TBL_ENTRY(bid, pid_local);
+	bm_entry_read(entry_offset, BM_DPR_C_MNG_BANK_STAT_TBL_ENTRY_WORDS, dpr_c_mng_entry);
+
+	cache_start = mv_field_get(BM_DPR_C_MNG_BANK_STAT_CACHE_START_OFFS,
+				   BM_DPR_C_MNG_BANK_STAT_CACHE_START_BITS, dpr_c_mng_entry);
+	cache_end = mv_field_get(BM_DPR_C_MNG_BANK_STAT_CACHE_END_OFFS,
+				 BM_DPR_C_MNG_BANK_STAT_CACHE_END_BITS, dpr_c_mng_entry);
+
+	cache_start *= 4;
+	cache_end = (cache_end + 1) * 4 - 1;
+
+	entry_offset = BM_TPR_C_MNG_BANK_DYN_TBL_ENTRY(bid, pid_local);
+	bm_entry_read(entry_offset, BM_TPR_C_MNG_BANK_DYN_TBL_ENTRY_WORDS, tpr_c_mng_entry);
+
+	cache_fill_min = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MIN_OFFS,
+				      BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MIN_BITS, tpr_c_mng_entry);
+	cache_fill_max = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MAX_OFFS,
+				      BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MAX_BITS, tpr_c_mng_entry);
+	cache_wr = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_WR_PTR_OFFS,
+				BM_TPR_C_MNG_BANK_DYN_CACHE_WR_PTR_BITS, tpr_c_mng_entry);
+	cache_rd = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_RD_PTR_OFFS,
+				BM_TPR_C_MNG_BANK_DYN_CACHE_RD_PTR_BITS, tpr_c_mng_entry);
+
+	start = cache_rd;
+	if (cache_wr > cache_rd)
+		end = cache_wr;
+	else
+		end = cache_end;
+
+	count = 0;
+	while (count < cache_fill_max) {
+		for (line = start; line < end; line++) {
+			entry_offset = BM_SRAM_B0_CACHE_TBL_ENTRY(line);
+			bm_entry_read(entry_offset, BM_SRAM_B0_CACHE_TBL_ENTRY_WORDS, sram_cache_entry);
+			for (i = 0; i < 4; i++) {
+				val = sram_cache_entry[i];
+				if (val > dram_size) {
+					pr_info("BM pool #%d: Unexpected buffer index 0x%04x on CACHE line #%d:%d\n",
+						pool, val, line, i);
+					break;
+				}
+
+				if (val == buf) {
+					pr_cont("C_%-3d:%d ", line, i);
+					max++;
+				}
+				count++;
+			}
+		}
+		start = cache_start;
+		end = cache_wr;
+	}
+	pr_cont("- found %d times\n", max);
+
+	return max;
+}
+
+int bm_bank0_pool_check(int pool, u32 *pool_base)
+{
+	int count, bid, pid_local, pid_global, i, line, dup;
+	unsigned int dram_rd, dram_wr, dram_fill, dram_size, dram_start, entry_offset;
+	unsigned int cache_rd, cache_wr, cache_start, cache_end, cache_fill_min, cache_fill_max;
+	unsigned int start, end;
+	u32 *pool_shadow, val;
+	unsigned int drw_mng_ball_entry[BM_TPR_DRW_MNG_BALL_DYN_TBL_ENTRY_WORDS];
+	unsigned int tpr_dro_mng_entry[BM_TPR_DRO_MNG_BALL_DYN_TBL_ENTRY_WORDS];
+	unsigned int dpr_d_mng_entry[BM_DPR_D_MNG_BALL_STAT_TBL_ENTRY_WORDS];
+	unsigned int sram_cache_entry[BM_SRAM_B0_CACHE_TBL_ENTRY_WORDS];
+	unsigned int dpr_c_mng_entry[BM_DPR_C_MNG_BANK_STAT_TBL_ENTRY_WORDS];
+	unsigned int tpr_c_mng_entry[BM_TPR_C_MNG_BANK_DYN_TBL_ENTRY_WORDS];
+
+	if ((pool < BM_QM_GPM_POOL_0) && (pool > BM_QM_GPM_POOL_1)) {
+		pr_err("%s: Supported only for GPM pools 0..1\n", __func__);
+		return -1;
+	}
+
+	bid = bm_pid_to_bid(pool);
+	pid_local = bm_pid_to_local(pool);
+	pid_global = bm_pid_to_global(pool);
+
+	pr_info("\n-------------- BM pool %d check: vaddr = 0x%p, paddr = 0x%08x -----------\n",
+		pool, pool_base, virt_to_phys(pool_base));
+
+	/* DRAM parameters */
+	entry_offset = BM_TPR_DRW_MNG_BALL_DYN_TBL_ENTRY(pid_global);
+	bm_entry_read(entry_offset, BM_TPR_DRW_MNG_BALL_DYN_TBL_ENTRY_WORDS, drw_mng_ball_entry);
+
+	dram_fill = mv_field_get(BM_TPR_DRW_MNG_BALL_DYN_DRAM_FILL_OFFS,
+				 BM_TPR_DRW_MNG_BALL_DYN_DRAM_FILL_BITS, drw_mng_ball_entry);
+
+	entry_offset = BM_TPR_DRO_MNG_BALL_DYN_TBL_ENTRY(pid_global);
+	bm_entry_read(entry_offset, BM_TPR_DRO_MNG_BALL_DYN_TBL_ENTRY_WORDS, tpr_dro_mng_entry);
+
+	dram_rd = mv_field_get(BM_TPR_DRO_MNG_BALL_DYN_DRAM_RD_PTR_OFFS,
+			       BM_TPR_DRO_MNG_BALL_DYN_DRAM_RD_PTR_BITS, tpr_dro_mng_entry);
+	dram_wr = mv_field_get(BM_TPR_DRO_MNG_BALL_DYN_DRAM_WR_PTR_OFFS,
+			       BM_TPR_DRO_MNG_BALL_DYN_DRAM_WR_PTR_BITS, tpr_dro_mng_entry);
+
+	entry_offset = BM_DPR_D_MNG_BALL_STAT_TBL_ENTRY(pid_global);
+	bm_entry_read(entry_offset, BM_DPR_D_MNG_BALL_STAT_TBL_ENTRY_WORDS, dpr_d_mng_entry);
+	dram_start = mv_field_get(BM_DPR_D_MNG_BALL_STAT_DRAM_START_LSB_OFFS,
+				  BM_DPR_D_MNG_BALL_STAT_DRAM_START_LSB_BITS, dpr_d_mng_entry);
+
+	dram_size = mv_field_get(BM_DPR_D_MNG_BALL_STAT_DRAM_SIZE_OFFS,
+				 BM_DPR_D_MNG_BALL_STAT_DRAM_SIZE_BITS, dpr_d_mng_entry);
+
+	dram_size *= 16;
+	dram_rd *= 2;
+	dram_wr *= 2;
+	dram_fill *= 2;
+
+	pr_info("BM pool #%d: DRAM [PEs]: size=%d, read=%d, write=%d, fill=%d\n",
+		pool, dram_size, dram_rd, dram_wr, dram_fill);
+
+	/* Cache parameters */
+	entry_offset = BM_DPR_C_MNG_BANK_STAT_TBL_ENTRY(bid, pid_local);
+	bm_entry_read(entry_offset, BM_DPR_C_MNG_BANK_STAT_TBL_ENTRY_WORDS, dpr_c_mng_entry);
+
+	cache_start = mv_field_get(BM_DPR_C_MNG_BANK_STAT_CACHE_START_OFFS,
+				   BM_DPR_C_MNG_BANK_STAT_CACHE_START_BITS, dpr_c_mng_entry);
+	cache_end = mv_field_get(BM_DPR_C_MNG_BANK_STAT_CACHE_END_OFFS,
+				 BM_DPR_C_MNG_BANK_STAT_CACHE_END_BITS, dpr_c_mng_entry);
+
+	cache_start *= 4;
+	cache_end = (cache_end + 1) * 4 - 1;
+
+	entry_offset = BM_TPR_C_MNG_BANK_DYN_TBL_ENTRY(bid, pid_local);
+	bm_entry_read(entry_offset, BM_TPR_C_MNG_BANK_DYN_TBL_ENTRY_WORDS, tpr_c_mng_entry);
+
+	cache_fill_min = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MIN_OFFS,
+				      BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MIN_BITS, tpr_c_mng_entry);
+	cache_fill_max = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MAX_OFFS,
+				      BM_TPR_C_MNG_BANK_DYN_CACHE_FILL_MAX_BITS, tpr_c_mng_entry);
+	cache_wr = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_WR_PTR_OFFS,
+				BM_TPR_C_MNG_BANK_DYN_CACHE_WR_PTR_BITS, tpr_c_mng_entry);
+	cache_rd = mv_field_get(BM_TPR_C_MNG_BANK_DYN_CACHE_RD_PTR_OFFS,
+				BM_TPR_C_MNG_BANK_DYN_CACHE_RD_PTR_BITS, tpr_c_mng_entry);
+
+	pr_info("BM pool #%d: CACHE [Lines]: start=%d, end=%d, read=%d, write=%d, fill=%d..%d\n",
+		pool, cache_start, cache_end, cache_rd, cache_wr, cache_fill_min, cache_fill_max);
+	pr_info("\n");
+
+	pool_shadow = kcalloc(dram_size, sizeof(u32), GFP_KERNEL);
+
+	/* valid DRAM enries from dram_read to dram_write */
+	start = dram_rd;
+	if (dram_wr > dram_rd)
+		end = dram_wr;
+	else
+		end = dram_size;
+
+	count = 0;
+	dup = 0;
+	while (count < dram_fill) {
+		for (i = start; i < end; i++) {
+			val = pool_base[i];
+			if (val > dram_size) {
+				pr_info("BM pool #%d: Unexpected buffer index 0x%04x on DRAM offset %d\n",
+					pool, val, i);
+				break;
+			}
+			if (pool_shadow[val] == 1) {
+				/* pr_info("BM pool #%d: Multiple index 0x%04x on DRAM offset %d. count=%d\n",
+				*	pool, val, i, pool_shadow[val]);
+				*/
+				bm_bank0_pool_find_buf(pool, pool_base, val);
+				dup++;
+			}
+			pool_shadow[val]++;
+			count++;
+		}
+		start = 0;
+		end = dram_wr;
+	}
+
+	/* Check Cache */
+	start = cache_rd;
+	if (cache_wr > cache_rd)
+		end = cache_wr;
+	else
+		end = cache_end;
+
+	count = 0;
+	while (count < cache_fill_max) {
+		for (line = start; line < end; line++) {
+			entry_offset = BM_SRAM_B0_CACHE_TBL_ENTRY(line);
+			bm_entry_read(entry_offset, BM_SRAM_B0_CACHE_TBL_ENTRY_WORDS, sram_cache_entry);
+			for (i = 0; i < 4; i++) {
+				val = sram_cache_entry[i];
+				if (val > dram_size) {
+					pr_info("BM pool #%d: Unexpected buffer index 0x%04x on CACHE line #%d:%d\n",
+						pool, val, line, i);
+					break;
+				}
+
+				if (pool_shadow[val] == 1) {
+				/*	pr_info("BM pool #%d: Multiple index 0x%04x on CACHE line #%d:%d. count=%d\n",
+				*			pool, val, line, i, pool_shadow[val]);
+				*/
+					bm_bank0_pool_find_buf(pool, pool_base, val);
+					dup++;
+				}
+				pool_shadow[val]++;
+				count++;
+			}
+		}
+		start = cache_start;
+		end = cache_wr;
+	}
+
+	pr_info("BM pool #%d: %d duplicated pointers are found\n", pool, dup);
+	pr_info("\n");
+
+	kfree(pool_shadow);
+	return 0;
+}
diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
index 4822371..c2717e3 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
@@ -279,7 +279,9 @@ license alternatives that you have not elected to use and (iii) preserve the
 
 void bm_pool_status_dump(int pool);
 
+int bm_bank0_pool_check(int pool, u32 *pool_base);
 
+int bm_pool_dump(int pool, int mode, u32 *pool_base, int capacity);
 /*
  BM sysFS function
 */
diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c b/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c
index 69ed1f3..d4a6da6 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c
@@ -34,6 +34,7 @@ license alternatives that you have not elected to use and (iii) preserve the
 
 #include "common/mv_sw_if.h"
 #include "platform/mv_pp3.h"
+#include "vport/mv_pp3_pool.h"
 #include "mv_bm.h"
 
 static ssize_t pp3_dev_bm_help(char *b)
@@ -44,8 +45,10 @@ static ssize_t pp3_dev_bm_help(char *b)
 	o += scnprintf(b+o, PAGE_SIZE-o, "cat                   > regs         - show BM registers\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "cat                   > err_regs     - show BM erorr registers\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "cat                   > idle_regs    - show BM idle mode registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [pool] [0|1]     > pool_regs    - show BM pool registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [pool] [0|1]     > pool_enable  - enable/disable BM pool\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [pool] [mode]    > pool_regs    - show BM pool registers\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [pool] [mode]    > pool_dump    - show BM pool memory dump\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [pool]           > pool_check   - check BM pool validity\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [pool] [mode]    > pool_enable  - enable/disable BM pool\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "echo [bank]           > bank_regs    - show BM bank registers\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "echo [bank]           > bank_dump    - show BM bank cache memory\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "echo [mask]           > debug        - Registers read and write debug outputs\n");
@@ -55,7 +58,8 @@ static ssize_t pp3_dev_bm_help(char *b)
 	o += scnprintf(b+o, PAGE_SIZE-o, "parameters:\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "      [pool]  - pool number\n");
 	o += scnprintf(b+o, PAGE_SIZE-o, "      [bank]  - bank number\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "      [mask]  - b0:read, b1:write\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "      [mask]  - b0 : read, b1 : write\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "      [mode]  - 0 : short, 1 : full\n");
 
 	return o;
 }
@@ -81,7 +85,42 @@ static ssize_t pp3_dev_bm_show(struct device *dev,
 	return off;
 }
 
+int pp3_dbg_pool_check(int pool)
+{
+	int err;
+	struct pp3_pool *ppool;
+
+	ppool = mv_pp3_pool_get(pool);
+
+	if (!ppool || !ppool->virt_base) {
+		pr_err("%s: pool=%d is not initialized\n", __func__, pool);
+		return -EINVAL;
+	}
+	err = bm_bank0_pool_check(pool, ppool->virt_base);
+
+	return err;
+}
 
+int pp3_dbg_pool_dump(int pool, int mode)
+{
+	int err, capacity = 0;
+	struct pp3_pool *ppool = NULL;
+	u32 *virt_base = NULL;
+
+	if (mode) {
+		ppool = mv_pp3_pool_get(pool);
+		if (!ppool || !ppool->virt_base) {
+			pr_err("%s: pool=%d is not initialized\n", __func__, pool);
+			return -EINVAL;
+		}
+		virt_base = (u32 *)ppool->virt_base;
+		capacity = ppool->capacity;
+	}
+
+	err = bm_pool_dump(pool, mode, virt_base, capacity);
+
+	return err;
+}
 
 static ssize_t pp3_dev_bm_store(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
@@ -89,7 +128,6 @@ static ssize_t pp3_dev_bm_store(struct device *dev,
 	const char      *name = attr->attr.name;
 	int             err;
 	unsigned int    a, b, c;
-	unsigned long   flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
@@ -98,12 +136,14 @@ static ssize_t pp3_dev_bm_store(struct device *dev,
 	err = a = b = c = 0;
 	sscanf(buf, "%d %d %d", &a, &b, &c);
 
-	local_irq_save(flags);
-
 	if (!strcmp(name, "pool_enable")) {
 		(b == 0) ? bm_pool_disable(a) : bm_pool_enable(a);
 	} else if (!strcmp(name, "pool_regs")) {
 		(b == 0) ? bm_pool_registers_dump(a) :  bm_pool_registers_parse(a);
+	} else if (!strcmp(name, "pool_dump")) {
+		pp3_dbg_pool_dump(a, b);
+	} else if (!strcmp(name, "pool_check")) {
+		pp3_dbg_pool_check(a);
 	} else if (!strcmp(name, "bank_regs")) {
 		bm_bank_registers_dump(a);
 	} else if (!strcmp(name, "bank_dump")) {
@@ -116,14 +156,14 @@ static ssize_t pp3_dev_bm_store(struct device *dev,
 		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
 	}
 
-	local_irq_restore(flags);
-
 	if (err)
 		pr_err("%s: error %d\n", __func__, err);
 
 	return err ? -EINVAL : len;
 }
 
+static DEVICE_ATTR(pool_check,		S_IWUSR, NULL, pp3_dev_bm_store);
+static DEVICE_ATTR(pool_dump,		S_IWUSR, NULL, pp3_dev_bm_store);
 static DEVICE_ATTR(pool_regs,		S_IWUSR, NULL, pp3_dev_bm_store);
 static DEVICE_ATTR(pool_enable,		S_IWUSR, NULL, pp3_dev_bm_store);
 static DEVICE_ATTR(bank_regs,		S_IWUSR, NULL, pp3_dev_bm_store);
@@ -142,6 +182,8 @@ static ssize_t pp3_dev_bm_store(struct device *dev,
 	&dev_attr_bank_dump.attr,
 	&dev_attr_regs.attr,
 	&dev_attr_pool_regs.attr,
+	&dev_attr_pool_dump.attr,
+	&dev_attr_pool_check.attr,
 	&dev_attr_pool_enable.attr,
 	&dev_attr_debug.attr,
 	NULL
diff --git a/drivers/net/ethernet/marvell/pp3/vport/mv_pp3_pool.c b/drivers/net/ethernet/marvell/pp3/vport/mv_pp3_pool.c
index 1813de5..8760233 100644
--- a/drivers/net/ethernet/marvell/pp3/vport/mv_pp3_pool.c
+++ b/drivers/net/ethernet/marvell/pp3/vport/mv_pp3_pool.c
@@ -412,41 +412,6 @@ void pp3_dbg_pool_status_print(int pool)
 }
 /*---------------------------------------------------------------------------*/
 
-int pp3_dbg_pool_dump(int pool, int v)
-{
-	int i;
-	struct pp3_pool *ppool;
-	u32 *arr;
-
-	if ((pool < 0) || (pool >= BM_POOLS_NUM)) {
-		pr_err("%s: pool=%d is out of range\n", __func__, pool);
-		return -EINVAL;
-	}
-
-	if (v) {
-
-		if ((pp3_pools == NULL) || (pp3_pools[pool] == NULL)) {
-			pr_err("%s: pool=%d is not initialized\n", __func__, pool);
-			return -EINVAL;
-		}
-
-		ppool = pp3_pools[pool];
-
-		arr = (u32 *)ppool->virt_base;
-
-		for (i = 0; i < ppool->capacity; i = i + 2)
-			pr_info("%d	virt = 0x%08x	phys = 0x%08x\n", i/2, arr[i+1], arr[i]);
-	}
-
-	pr_info("\n");
-
-	bm_pool_status_dump(pool);
-
-	return 0;
-}
-/*---------------------------------------------------------------------------*/
-
-
 /* Clear BM pool statistics */
 void pp3_dbg_pool_stats_clear(int pool)
 {
-- 
1.7.9.5


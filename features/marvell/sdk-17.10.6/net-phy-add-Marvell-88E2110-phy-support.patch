From b48f42df1f01cbab338225c9b9196743a764bde6 Mon Sep 17 00:00:00 2001
From: Kevin Shi <kshi@marvell.com>
Date: Wed, 5 Jul 2017 15:51:33 +0800
Subject: [PATCH 1224/1345] net: phy: add Marvell 88E2110 phy support

commit  ad1d18b5b389806538f83adf218f1758ad1ea293 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

E2110 support 10M/100M/1G/2.5G/5G speed and use C45 register definition.
Need to use C45 or C22 r13/r14 indirect method to access

Change-Id: I35191a51c7f04e8ddb65aef67d5f9ddf81033fb3
Signed-off-by: Kevin Shi <kshi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42506
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../devicetree/bindings/net/marvell-phy.txt        |   28 ++
 drivers/net/phy/marvell.c                          |  295 ++++++++++++++++++++
 include/linux/marvell_phy.h                        |    1 +
 3 files changed, 324 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/net/marvell-phy.txt

diff --git a/Documentation/devicetree/bindings/net/marvell-phy.txt b/Documentation/devicetree/bindings/net/marvell-phy.txt
new file mode 100644
index 0000000..7bc7508
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/marvell-phy.txt
@@ -0,0 +1,28 @@
+Marvell E2110 PHY supports 10M/100M/1G/2.5G/5G base-t and has more setup
+bindings in addition to the standard PHY bindings. For undescribed properties,
+please refer to Documentation/devicetree/bindings/net/phy.txt.
+
+Compatible: "ethernet-phy-ieee802.3-c45"
+
+Optional Properties:
+
+- marvell,c45-reg-init :
+  one of more sets of 4 cells to overwrite initial register value
+  1st: the MDIO Manageable Device (MMD) address
+  2nd: the second a register address within the MMD
+  3rd: the third cell contains a mask to be ANDed with the existing
+       register value
+  4th: ORed with he result to yield the new register value.
+  If the third cell has a value of zero, no read of the existing value is
+  performed.
+
+Example:
+	phy0: ethernet-phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <0>;
+		max-speed = <5000>;
+
+		/* setup the lane swap */
+		marvell,c45-reg-init = <1 0xc000 0xfffe 0x1>;
+        };
+
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 6dbd032..b4ca2e0 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -42,6 +42,7 @@
 #include <asm/irq.h>
 #include <linux/uaccess.h>
 
+#define MII_MARVELL_REG_INIT_FIELDS	4
 #define MII_MARVELL_PHY_PAGE		22
 
 #define MII_M1011_IEVENT		0x13
@@ -226,6 +227,39 @@
 #define MII_88E3310_AUT_NEG_CON		0x8000
 #define MII_88E3310_AUT_NEG_ST		0x8001
 
+#define MII_88E2110_IMASK		0x8010
+#define MII_88E2110_IMASK_INIT		0x6400
+#define MII_88E2110_IMASK_CLEAR		0x0000
+
+#define MII_88E2110_ISTATUS		0x8011
+
+#define MII_88E2110_PHY_STATUS		0x8008
+#define MII_88E2110_PHY_STATUS_SPD_MASK	0xc00c
+#define MII_88E2110_PHY_STATUS_5000	0xc008
+#define MII_88E2110_PHY_STATUS_2500	0xc004
+#define MII_88E2110_PHY_STATUS_1000	0x8000
+#define MII_88E2110_PHY_STATUS_100	0x4000
+#define MII_88E2110_PHY_STATUS_DUPLEX	0x2000
+#define MII_88E2110_PHY_STATUS_SPDDONE	0x0800
+#define MII_88E2110_PHY_STATUS_LINK	0x0400
+
+#define MII_88E2110_NG_EXT_CTRL			0xc000
+#define MII_88E2110_NG_EXT_CTRL_SWAP_ABCD	0x1
+
+#define MII_88E2110_AN_CTRL		0x0
+#define MII_88E2110_AN_CTRL_EXT_NP_CTRL 0x2000
+#define MII_88E2110_AN_CTRL_AN_EN	0x1000
+#define MII_88E2110_AN_CTRL_RESTART_AN	0x0200
+
+#define MII_88E2110_ADVERTISE		0x10
+#define MII_88E2110_LPA			0x13
+#define MII_88E2110_STAT1000		0x8001
+
+#define MII_88E2110_MGBASET_AN_CTRL1			0x20
+#define MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_5000	0x01e1
+#define MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_2500	0x00a1
+#define MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_1000	0x0001
+
 MODULE_DESCRIPTION("Marvell PHY driver");
 MODULE_AUTHOR("Andy Fleming");
 MODULE_LICENSE("GPL");
@@ -539,11 +573,71 @@ static int marvell_of_reg_init(struct phy_device *phydev)
 	}
 	return ret;
 }
+
+/* Set and/or override some configuration registers based on the
+ * "marvell,c45-reg-init" property stored in the of_node for the phydev.
+ *
+ * marvell,c45-reg-init = <devid reg mask value>,...;
+ *
+ * There may be one or more sets of <devid reg mask value>:
+ *
+ * devid: device id
+ * reg: the register offset belonging to specified id
+ * mask: if non-zero, ANDed with existing register value.
+ * val: mask != 0 ? reg |= val : reg = val
+ *
+ */
+static int marvell_of_reg_c45_init(struct phy_device *phydev)
+{
+	const __be32 *paddr;
+	int len, i, ret;
+
+	if (!phydev->mdio.dev.of_node)
+		return 0;
+
+	paddr = of_get_property(phydev->mdio.dev.of_node,
+				"marvell,c45-reg-init", &len);
+	if (!paddr)
+		return 0;
+
+	ret = 0;
+	len /= sizeof(*paddr);
+	for (i = 0; i < len - (MII_MARVELL_REG_INIT_FIELDS - 1);
+	     i += MII_MARVELL_REG_INIT_FIELDS) {
+		u16 devid = be32_to_cpup(paddr + i);
+		u16 reg = be32_to_cpup(paddr + i + 1);
+		u16 mask = be32_to_cpup(paddr + i + 2);
+		u16 val_bits = be32_to_cpup(paddr + i + 3);
+		int val;
+
+		val = 0;
+		if (mask) {
+			val = phy_read_mmd(phydev, devid, reg);
+			if (val < 0) {
+				ret = val;
+				goto err;
+			}
+			val &= mask;
+		}
+		val |= val_bits;
+
+		ret = phy_write_mmd(phydev, devid, reg, val);
+		if (ret < 0)
+			goto err;
+	}
+err:
+	return ret;
+}
 #else
 static int marvell_of_reg_init(struct phy_device *phydev)
 {
 	return 0;
 }
+
+static int marvell_of_reg_c45_init(struct phy_device *phydev)
+{
+	return 0;
+}
 #endif /* CONFIG_OF_MDIO */
 
 static int m88e1121_config_aneg(struct phy_device *phydev)
@@ -739,6 +833,12 @@ static int marvell_config_init(struct phy_device *phydev)
 	return marvell_of_reg_init(phydev);
 }
 
+static int marvell_c45_config_init(struct phy_device *phydev)
+{
+	/* Set registers from marvell,c45-reg-init DT property */
+	return marvell_of_reg_c45_init(phydev);
+}
+
 static int m88e1116r_config_init(struct phy_device *phydev)
 {
 	int temp;
@@ -2013,6 +2113,184 @@ int m88e3310_soft_reset(struct phy_device *phydev)
 	return 0;
 }
 
+static int m88e2110_ack_interrupt(struct phy_device *phydev)
+{
+	int err;
+
+	/* Clear the interrupts by reading the reg */
+	err = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_ISTATUS);
+
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int m88e2110_config_aneg(struct phy_device *phydev)
+{
+	struct device_node *node = phydev->mdio.dev.of_node;
+	u32 max_speed;
+	int reg, change = 0;
+
+	if (!of_property_read_u32(node, "max-speed", &max_speed)) {
+		reg = phy_read_mmd(phydev, MDIO_MMD_AN,
+				   MII_88E2110_MGBASET_AN_CTRL1);
+		switch (max_speed) {
+		case SPEED_5000:
+			/* Disabled 10G advertisement */
+			if (reg != MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_5000) {
+				phy_write_mmd(phydev, MDIO_MMD_AN,
+					      MII_88E2110_MGBASET_AN_CTRL1,
+					      MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_5000);
+				change = 1;
+			}
+			break;
+		case SPEED_2500:
+			/* Disabled 10G/5G advertisements */
+			if (reg != MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_2500) {
+				phy_write_mmd(phydev, MDIO_MMD_AN,
+					      MII_88E2110_MGBASET_AN_CTRL1,
+					      MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_2500);
+				change = 1;
+			}
+			break;
+		default:
+			/* Disable 10G/5G/2.5G auto-negotiation advertisements */
+			if (reg != MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_1000) {
+				phy_write_mmd(phydev, MDIO_MMD_AN,
+					      MII_88E2110_MGBASET_AN_CTRL1,
+					      MII_88E2110_MGBASET_AN_CTRL1_ADVERTISE_1000);
+				change = 1;
+			}
+			break;
+		}
+	}
+
+	/* Restart auto-negotiation */
+	if (change)
+		phy_write_mmd(phydev, MDIO_MMD_AN, MII_88E2110_AN_CTRL,
+			      MII_88E2110_AN_CTRL_EXT_NP_CTRL |
+			      MII_88E2110_AN_CTRL_AN_EN |
+			      MII_88E2110_AN_CTRL_RESTART_AN);
+
+	return 0;
+}
+
+static int m88e2110_config_init(struct phy_device *phydev)
+{
+	return marvell_c45_config_init(phydev);
+}
+
+static int m88e2110_config_intr(struct phy_device *phydev)
+{
+	int err;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		err = phy_write_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_IMASK,
+				    MII_88E2110_IMASK_INIT);
+	else
+		err = phy_write_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_IMASK,
+				    MII_88E2110_IMASK_CLEAR);
+
+	return err;
+}
+
+static int m88e2110_read_status(struct phy_device *phydev)
+{
+	int adv, lpa, lpagb, status;
+
+	status = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_PHY_STATUS);
+	if (status < 0)
+		return status;
+
+	if (!(status & MII_88E2110_PHY_STATUS_LINK)) {
+		phydev->link = 0;
+		return 0;
+	}
+
+	phydev->link = 1;
+	if (status & MII_88E2110_PHY_STATUS_DUPLEX)
+		phydev->duplex = DUPLEX_FULL;
+	else
+		phydev->duplex = DUPLEX_HALF;
+
+	phydev->pause = 0;
+	phydev->asym_pause = 0;
+
+	switch (status & MII_88E2110_PHY_STATUS_SPD_MASK) {
+	case MII_88E2110_PHY_STATUS_5000:
+		phydev->speed = SPEED_5000;
+		break;
+	case MII_88E2110_PHY_STATUS_2500:
+		phydev->speed = SPEED_2500;
+		break;
+	case MII_88E2110_PHY_STATUS_1000:
+		phydev->speed = SPEED_1000;
+		break;
+	case MII_88E2110_PHY_STATUS_100:
+		phydev->speed = SPEED_100;
+		break;
+	default:
+		phydev->speed = SPEED_10;
+		break;
+	}
+
+	if (phydev->autoneg == AUTONEG_ENABLE) {
+		lpa = phy_read_mmd(phydev, MDIO_MMD_AN, MII_88E2110_LPA);
+		if (lpa < 0)
+			return lpa;
+
+		lpagb = phy_read_mmd(phydev, MDIO_MMD_AN, MII_88E2110_STAT1000);
+		if (lpagb < 0)
+			return lpagb;
+
+		adv = phy_read_mmd(phydev, MDIO_MMD_AN, MII_88E2110_ADVERTISE);
+		if (adv < 0)
+			return adv;
+
+		phydev->lp_advertising = mii_stat1000_to_ethtool_lpa_t(lpagb) |
+					 mii_lpa_to_ethtool_lpa_t(lpa);
+
+		lpa &= adv;
+
+		if (phydev->duplex == DUPLEX_FULL) {
+			phydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;
+			phydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;
+		}
+	} else {
+		phydev->lp_advertising = 0;
+	}
+
+	return 0;
+}
+
+static int m88e2110_aneg_done(struct phy_device *phydev)
+{
+	int retval;
+
+	retval = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_PHY_STATUS);
+
+	return ((retval < 0) ? retval : (retval & MII_88E2110_PHY_STATUS_SPDDONE));
+}
+
+static int m88e2110_did_interrupt(struct phy_device *phydev)
+{
+	int imask;
+
+	imask = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_88E2110_ISTATUS);
+
+	if (imask & MII_88E2110_IMASK_INIT)
+		return 1;
+
+	return 0;
+}
+
+static int m88e2110_soft_reset(struct phy_device *phydev)
+{
+	/* Do nothing for now */
+	return 0;
+}
+
 #ifndef UINT64_MAX
 #define UINT64_MAX              (u64)(~((u64)0))
 #endif
@@ -2999,6 +3277,22 @@ static int m88e1112_read_status(struct phy_device *phydev)
 		.get_strings = marvell_get_strings,
 		.get_stats = marvell_get_stats,
 	},
+	{
+		.phy_id = MARVELL_PHY_ID_88E2110,
+		.phy_id_mask = MARVELL_PHY_ID_MASK,
+		.name = "Marvell 88E2110",
+		.features = PHY_BASIC_FEATURES,
+		.flags = PHY_HAS_INTERRUPT,
+		.probe = marvell_probe,
+		.config_aneg = &m88e2110_config_aneg,
+		.config_init = &m88e2110_config_init,
+		.aneg_done = &m88e2110_aneg_done,
+		.read_status = &m88e2110_read_status,
+		.ack_interrupt = &m88e2110_ack_interrupt,
+		.config_intr = &m88e2110_config_intr,
+		.did_interrupt = &m88e2110_did_interrupt,
+		.soft_reset = &m88e2110_soft_reset,
+	},
 };
 
 module_phy_driver(marvell_drivers);
@@ -3016,6 +3310,7 @@ static int m88e1112_read_status(struct phy_device *phydev)
 	{ MARVELL_PHY_ID_88E1116R, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1510, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1540, MARVELL_PHY_ID_MASK },
+	{ MARVELL_PHY_ID_88E2110, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1545, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E3016, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E6390, MARVELL_PHY_ID_MASK },
diff --git a/include/linux/marvell_phy.h b/include/linux/marvell_phy.h
index 69b0516..45050aa 100644
--- a/include/linux/marvell_phy.h
+++ b/include/linux/marvell_phy.h
@@ -17,6 +17,7 @@
 #define MARVELL_PHY_ID_88E1116R		0x01410e40
 #define MARVELL_PHY_ID_88E1510		0x01410dd0
 #define MARVELL_PHY_ID_88E1540		0x01410eb0
+#define MARVELL_PHY_ID_88E2110		0x002b09b8
 #define MARVELL_PHY_ID_88E1545		0x01410ea0
 #define MARVELL_PHY_ID_88E3016		0x01410e60
 #define MARVELL_PHY_ID_88E3310		0x01410da0
-- 
1.7.9.5


From 04e2cc6f7b7f52cd0e06d843bc52b8d47d585fd3 Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Fri, 10 Mar 2017 23:10:57 +0800
Subject: [PATCH 0916/1345] watchdog: a3700: introduce watchdog driver

commit  c9190b9ce2905e690d49833738284654122f5af2 from
https://github.com/MarvellEmbeddedProcessors/linux-marvell.git

- This patch added watchdog driver supported on Armada
  3700.
- The watchdog driver uses global counter 1 as the
  timeout timer. The default timeout seconds is 343
  seconds.

Change-Id: Id5561dcf0b4d84866ca4bb92e4cb35ea570b8222
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37373
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Hua Jing <jinghua@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../bindings/watchdog/armada3700-wdt.txt           |   18 +
 Documentation/watchdog/watchdog-parameters.txt     |    5 +
 drivers/watchdog/Kconfig                           |   10 +
 drivers/watchdog/Makefile                          |    1 +
 drivers/watchdog/armada3700_wdt.c                  |  354 ++++++++++++++++++++
 5 files changed, 388 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/watchdog/armada3700-wdt.txt
 create mode 100644 drivers/watchdog/armada3700_wdt.c

diff --git a/Documentation/devicetree/bindings/watchdog/armada3700-wdt.txt b/Documentation/devicetree/bindings/watchdog/armada3700-wdt.txt
new file mode 100644
index 0000000..3bb4f3c
--- /dev/null
+++ b/Documentation/devicetree/bindings/watchdog/armada3700-wdt.txt
@@ -0,0 +1,18 @@
+* Armada37x0 Watchdog driver : Watchdog driver used in Marvell Armada37x0 SoC
+
+Required properties:
+
+- compatible : should be "marvell,armada-3700-wdt"
+- reg : base addresses and lengths of the watchdog control register and global counter registers.
+	watchdog control register point to the CPU watchdog timer select register, while global
+	counter register points to the timers referred by watchdog.
+- clocks: input clock of watchdog timer.
+
+Example:
+
+wdt: watchdog-timer@8300 {
+	compatible = "marvell,armada-3700-wdt";
+	reg = <0xd064 0x4>,
+	      <0x8300 0x40>;
+	clocks = <&osc>;
+};
diff --git a/Documentation/watchdog/watchdog-parameters.txt b/Documentation/watchdog/watchdog-parameters.txt
index 4f7d86d..3733230 100644
--- a/Documentation/watchdog/watchdog-parameters.txt
+++ b/Documentation/watchdog/watchdog-parameters.txt
@@ -425,3 +425,8 @@ sun4v_wdt:
 timeout_ms: Watchdog timeout in milliseconds 1..180000, default=60000)
 nowayout: Watchdog cannot be stopped once started
 -------------------------------------------------
+a3700_wdt:
+heartbeat: Initial watchdog heartbeat in seconds
+nowayout: Watchdog cannot be stopped once started
+	(default=kernel config parameter)
+-------------------------------------------------
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 8b9049d..100861a8 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -461,6 +461,16 @@ config ORION_WATCHDOG
 	  To compile this driver as a module, choose M here: the
 	  module will be called orion_wdt.
 
+config ARMADA3700_WATCHDOG
+	tristate "Armada3700 watchdog"
+	depends on ARCH_MVEBU
+	select WATCHDOG_CORE
+	help
+	  Say Y here if to include support for the watchdog timer
+	  in the Marvell Armada-3700 SoC.
+	  To compile this driver as a module, choose M here: the
+	  module will be called armada3700_wdt.
+
 config RN5T618_WATCHDOG
 	tristate "Ricoh RN5T618 watchdog"
 	depends on MFD_RN5T618 || COMPILE_TEST
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index a2126e2..0cfeccd 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_ATLAS7_WATCHDOG) += atlas7_wdt.o
 obj-$(CONFIG_RENESAS_WDT) += renesas_wdt.o
 obj-$(CONFIG_ASPEED_WATCHDOG) += aspeed_wdt.o
 obj-$(CONFIG_ZX2967_WATCHDOG) += zx2967_wdt.o
+obj-$(CONFIG_ARMADA3700_WATCHDOG) += armada3700_wdt.o
 
 # AVR32 Architecture
 obj-$(CONFIG_AT32AP700X_WDT) += at32ap700x_wdt.o
diff --git a/drivers/watchdog/armada3700_wdt.c b/drivers/watchdog/armada3700_wdt.c
new file mode 100644
index 0000000..cd56d0a
--- /dev/null
+++ b/drivers/watchdog/armada3700_wdt.c
@@ -0,0 +1,354 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2017 Marvell International Ltd.
+* ***************************************************************************
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+* Redistributions of source code must retain the above copyright notice, this
+* list of conditions and the following disclaimer.
+*
+* Redistributions in binary form must reproduce the above copyright notice,
+* this list of conditions and the following disclaimer in the documentation
+* and/or other materials provided with the distribution.
+*
+* Neither the name of Marvell nor the names of its contributors may be used
+* to endorse or promote products derived from this software without specific
+* prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+
+#define WDT_MAX_CYCLE_COUNT			0xFFFFFFFF
+
+/* Global Counter register*/
+#define COUNTER_REGISTER_OFFSET			0x4
+#define COUNTER_ENABLE_BIT			BIT(0)
+
+#define COUNTER_CTRL_MODE_OFFSET		2
+#define COUNTER_CTRL_MODE_MASK			0x3
+
+#define COUNTER_CTRL_CLK_PRE_OFFSET		8
+#define COUNTER_CTRL_CLK_PRE_MASK		0xFF
+#define COUNTER_CTRL_CLK_MIN_FREQ_PRESCALE	2
+#define COUNTER_CTRL_CLK_MAX_FREQ_PRESCALE	255
+
+/* Get counter reg_base according the counter_id */
+#define COUNTER_REG(base, id)    ((base) + ((id) << 4))
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+static int heartbeat = -1;	/* module parameter (seconds) */
+
+enum watchdog_timer_id {
+	WATCHDOG_TIMER0,
+	WATCHDOG_TIMER1,
+	WATCHDOG_TIMER2,
+	WATCHDOG_TIMER3,
+	WATCHDOG_TIMER_MAX,
+};
+
+/* Counter Modes specify if the counter is retriggerable or oneshot
+ * and what is the trigger source.
+ */
+#define COUNTER_CTRL_MODE_ONESHOT					0
+#define COUNTER_CTRL_MODE_RETRIGGER_ENDCOUNT_PULSE			1
+#define COUNTER_CTRL_MODE_RETRIGGER_ENDCOUNT_PULSE_START_ON_HW_SIGNAL	2
+#define COUNTER_CTRL_MODE_RETRIGGER_ANYTIME_START_ON_HW_SIGNAL		3
+
+struct a3700_watchdog_data {
+	struct watchdog_device wdt;
+	unsigned char __iomem *reg;
+	unsigned char __iomem *cnt_reg;
+	unsigned long clk_rate;
+	unsigned int prescaler;
+	struct clk *clk;
+	enum watchdog_timer_id timer_id;
+};
+
+static int set_counter_mode(struct a3700_watchdog_data *data, unsigned int mode)
+{
+	int value;
+
+	value = readl(COUNTER_REG(data->cnt_reg, data->timer_id));
+	value &= ~(COUNTER_CTRL_MODE_MASK << COUNTER_CTRL_MODE_OFFSET);
+	value |= (mode << COUNTER_CTRL_MODE_OFFSET);
+	writel(value, COUNTER_REG(data->cnt_reg, data->timer_id));
+
+	return 0;
+}
+
+static int set_counter_divider(struct a3700_watchdog_data *data, unsigned int div)
+{
+	int value;
+
+	value = readl(COUNTER_REG(data->cnt_reg, data->timer_id));
+	value &= ~(COUNTER_CTRL_CLK_PRE_MASK << COUNTER_CTRL_CLK_PRE_OFFSET);
+	value |= (div << COUNTER_CTRL_CLK_PRE_OFFSET);
+	writel(value, COUNTER_REG(data->cnt_reg, data->timer_id));
+
+	return 0;
+}
+
+static int enable_watchdog_timer(struct a3700_watchdog_data *data)
+{
+	unsigned int value;
+
+	value = readl(COUNTER_REG(data->cnt_reg, data->timer_id));
+	value |= COUNTER_ENABLE_BIT;
+	writel(value, COUNTER_REG(data->cnt_reg, data->timer_id));
+
+	return 0;
+}
+
+static int disable_watchdog_timer(struct a3700_watchdog_data *data)
+{
+	unsigned int value;
+
+	value = readl(COUNTER_REG(data->cnt_reg, data->timer_id));
+	value &= ~COUNTER_ENABLE_BIT;
+	writel(value, COUNTER_REG(data->cnt_reg, data->timer_id));
+
+	return 0;
+}
+
+static int set_watchdog_timer_counter(struct watchdog_device *wdt_dev)
+{
+	struct a3700_watchdog_data *data = watchdog_get_drvdata(wdt_dev);
+	unsigned int value;
+
+	value = (data->clk_rate / data->prescaler) * wdt_dev->timeout;
+	writel(value, COUNTER_REG(data->cnt_reg, data->timer_id) + COUNTER_REGISTER_OFFSET);
+
+	return 0;
+}
+
+static int a3700_wdt_ping(struct watchdog_device *wdt_dev)
+{
+	struct a3700_watchdog_data *data = watchdog_get_drvdata(wdt_dev);
+
+	disable_watchdog_timer(data);
+	/* Set watchdog time out duration */
+	set_watchdog_timer_counter(wdt_dev);
+	enable_watchdog_timer(data);
+
+	return 0;
+}
+
+static int a3700_wdt_start(struct watchdog_device *wdt_dev)
+{
+	struct a3700_watchdog_data *data = watchdog_get_drvdata(wdt_dev);
+
+	/* Set watchdog time out duration */
+	set_watchdog_timer_counter(wdt_dev);
+	enable_watchdog_timer(data);
+
+	return 0;
+}
+
+static int a3700_wdt_stop(struct watchdog_device *wdt_dev)
+{
+	struct a3700_watchdog_data *data = watchdog_get_drvdata(wdt_dev);
+
+	disable_watchdog_timer(data);
+
+	return 0;
+}
+
+static unsigned int a3700_wdt_get_timeleft(struct watchdog_device *wdt_dev)
+{
+	struct a3700_watchdog_data *data = watchdog_get_drvdata(wdt_dev);
+
+	return readl(COUNTER_REG(data->cnt_reg, data->timer_id) + COUNTER_REGISTER_OFFSET) /
+				 (data->clk_rate / data->prescaler);
+}
+
+static int a3700_wdt_set_timeout(struct watchdog_device *wdt_dev,
+				 unsigned int timeout)
+{
+	unsigned int div;
+	struct a3700_watchdog_data *data = watchdog_get_drvdata(wdt_dev);
+
+	/* Get the Divisor according the timeout */
+	div = DIV_ROUND_UP(timeout, (WDT_MAX_CYCLE_COUNT / data->clk_rate));
+	if (div < COUNTER_CTRL_CLK_MIN_FREQ_PRESCALE)
+		div = COUNTER_CTRL_CLK_MIN_FREQ_PRESCALE;
+	else if (div > COUNTER_CTRL_CLK_MAX_FREQ_PRESCALE) {
+		pr_err("Timeout out of the MAX timeout\n");
+		return -EINVAL;
+	}
+
+	/* Counter Clock Prescaler setting */
+	set_counter_divider(data, div);
+
+	data->prescaler = div;
+	wdt_dev->timeout = timeout;
+
+	return 0;
+}
+
+static const struct watchdog_info a3700_wdt_info = {
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+	.identity = "Armada3700 Watchdog",
+};
+
+static const struct watchdog_ops a3700_wdt_ops = {
+	.owner = THIS_MODULE,
+	.start = a3700_wdt_start,
+	.stop = a3700_wdt_stop,
+	.ping = a3700_wdt_ping,
+	.set_timeout = a3700_wdt_set_timeout,
+	.get_timeleft = a3700_wdt_get_timeleft,
+};
+
+static const struct of_device_id a3700_wdt_of_match_table[] = {
+	{
+		.compatible = "marvell,armada-3700-wdt",
+		.data = (void *)WATCHDOG_TIMER1
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, a3700_wdt_of_match_table);
+
+static int a3700_wdt_probe(struct platform_device *pdev)
+{
+	struct a3700_watchdog_data *data;
+	struct resource *res;
+	const struct of_device_id *match;
+	int ret;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct a3700_watchdog_data),
+			   GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	match = of_match_device(a3700_wdt_of_match_table, &pdev->dev);
+	if (!match) {
+		dev_err(&pdev->dev, "Error: No device match found\n");
+		return -ENODEV;
+	}
+
+	data->wdt.info = &a3700_wdt_info;
+	data->wdt.ops = &a3700_wdt_ops;
+	data->wdt.min_timeout = 1;
+	data->timer_id = (enum watchdog_timer_id)match->data;
+	if (data->timer_id >= WATCHDOG_TIMER_MAX) {
+		dev_err(&pdev->dev, "Error: Timer ID out of the MAX timer number");
+		return -EINVAL;
+	}
+
+	/* Get reg_base from DTS*/
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	data->reg = devm_ioremap(&pdev->dev, res->start,
+				resource_size(res));
+
+	if (IS_ERR(data->reg))
+		return PTR_ERR(data->reg);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res)
+		return -ENODEV;
+
+	data->cnt_reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+
+	if (IS_ERR(data->cnt_reg))
+		return PTR_ERR(data->cnt_reg);
+
+	/* Initialize the Counter*/
+	set_counter_mode(data, COUNTER_CTRL_MODE_ONESHOT);
+	set_counter_divider(data, COUNTER_CTRL_CLK_MIN_FREQ_PRESCALE);
+
+	/* Select Watchdog Timer*/
+	writel(1 << data->timer_id, data->reg);
+
+	/* Clock initialize*/
+	data->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(data->clk))
+		return PTR_ERR(data->clk);
+
+	/* The Counter clock source is from Crystal Oscillator and the Timer divider is initialized by 2 */
+	data->clk_rate = clk_get_rate(data->clk);
+	data->prescaler = COUNTER_CTRL_CLK_MIN_FREQ_PRESCALE;
+
+	data->wdt.timeout = WDT_MAX_CYCLE_COUNT / (data->clk_rate / data->prescaler);
+	data->wdt.max_timeout = (WDT_MAX_CYCLE_COUNT / data->clk_rate) * COUNTER_CTRL_CLK_MAX_FREQ_PRESCALE;
+	data->wdt.parent = &pdev->dev;
+	watchdog_init_timeout(&data->wdt, heartbeat, &pdev->dev);
+
+	platform_set_drvdata(pdev, &data->wdt);
+	watchdog_set_drvdata(&data->wdt, data);
+
+	watchdog_set_nowayout(&data->wdt, nowayout);
+	ret = watchdog_register_device(&data->wdt);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register watchdog device\n");
+		return ret;
+	}
+	pr_info("Initial timeout %d sec%s\n",
+		data->wdt.timeout, nowayout ? ", nowayout" : "");
+
+	return 0;
+}
+
+static int a3700_wdt_remove(struct platform_device *pdev)
+{
+	struct watchdog_device *wdt_dev = platform_get_drvdata(pdev);
+
+	watchdog_unregister_device(wdt_dev);
+
+	return 0;
+}
+
+static void a3700_wdt_shutdown(struct platform_device *pdev)
+{
+	struct watchdog_device *wdt_dev = platform_get_drvdata(pdev);
+
+	a3700_wdt_stop(wdt_dev);
+}
+
+static struct platform_driver a3700_wdt_driver = {
+	.probe		= a3700_wdt_probe,
+	.remove		= a3700_wdt_remove,
+	.shutdown	= a3700_wdt_shutdown,
+	.driver		= {
+		.name	= "armada3700_wdt",
+		.of_match_table = a3700_wdt_of_match_table,
+	},
+};
+
+module_platform_driver(a3700_wdt_driver);
+
+MODULE_AUTHOR("Allen Yan <yanwei@marvell.com>");
+MODULE_DESCRIPTION("Armada3700 Processor Watchdog");
+
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat, "Initial watchdog heartbeat in seconds");
+
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
+				__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:armada3700_wdt");
-- 
1.7.9.5

